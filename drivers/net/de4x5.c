multiline_comment|/*  de4x5.c: A DIGITAL DE425/DE434/DE435 ethernet driver for linux.&n;&n;    Copyright 1994 Digital Equipment Corporation.&n;&n;    This software may be used and distributed according to the terms of&n;    the GNU Public License, incorporated herein by reference.&n;&n;    This driver is written for the Digital Equipment Corporation series&n;    of EtherWORKS ethernet cards:&n;&n;&t;DE425 TP/COAX EISA&n;&t;DE434 TP PCI&n;&t;DE435 TP/COAX/AUI PCI&n;&n;    The driver has been tested on a  relatively busy network using the DE425&n;    and DE435 cards and benchmarked with &squot;ttcp&squot;: it  transferred 16M of data&n;    at 1.08MB/s (8.6Mb/s) to a DECstation 5000/200.&n;&n;    ************************************************************************&n;    However there is still a known bug which causes ttcp to hang on transmit&n;    (receive  is  OK), although  the  adapter/driver  continues to  function&n;    normally for  other applications e.g.  nfs  mounting disks, pinging etc.&n;    The cause is under investigation.&n;    ************************************************************************&n;&n;    The author may    be  reached as davies@wanton.lkg.dec.com  or   Digital&n;    Equipment Corporation, 550 King Street, Littleton MA 01460.&n;&n;    =========================================================================&n;    This driver has been written  substantially  from scratch, although  its&n;    inheritance of style and stack interface from &squot;ewrk3.c&squot; and in turn from&n;    Donald Becker&squot;s &squot;lance.c&squot; should be obvious.&n;&n;    Upto 15 EISA cards can be supported under this driver, limited primarily&n;    by the available IRQ lines.  I have  checked different configurations of&n;    multiple depca, EtherWORKS 3 cards and de4x5 cards and  have not found a&n;    problem yet (provided you have at least depca.c v0.38) ...&n;&n;    PCI support  has been added  to allow the  driver to work with the DE434&n;    and  DE435 cards. The I/O  accesses  are a  bit of a   kludge due to the&n;    differences  in the  EISA and PCI    CSR address offsets  from the  base&n;    address.&n;&n;    The ability to load this driver  as a loadable  module has been included&n;    and used  extensively during the  driver development (to save those long&n;    reboot sequences).  I  don&squot;t  recommend using loadable drivers  with PCI&n;    however,  since the  PCI BIOS allocates   the  I/O and  memory addresses&n;    dynamically at  boot time.  To  utilise this  ability, you  have to do 8&n;    things:&n;&n;    0) have a copy of the loadable modules code installed on your system.&n;    1) copy de4x5.c from the  /linux/drivers/net directory to your favourite&n;    temporary directory.&n;    2) edit the  source code near  line 1945 to reflect  the I/O address and&n;    IRQ you&squot;re using, or assign these when loading by:&n;&n;                   insmod de4x5.o irq=x io=y&n;&n;    3) compile  de4x5.c, but include -DMODULE in  the command line to ensure&n;    that the correct bits are compiled (see end of source code).&n;    4) if you are wanting to add a new  card, goto 5. Otherwise, recompile a&n;    kernel with the de4x5 configuration turned off and reboot.&n;    5) insmod de4x5.o&n;    6) run the net startup bits for your new eth?? interface manually &n;    (usually /etc/rc.inet[12] at boot time). &n;    7) enjoy!&n;&n;    Note that autoprobing is not allowed in loadable modules - the system is&n;    already up and running and you&squot;re messing with interrupts.&n;&n;    To unload a module, turn off the associated interface &n;    &squot;ifconfig eth?? down&squot; then &squot;rmmod de4x5&squot;.&n;&n;    Automedia detection is included so that in  principal you can disconnect&n;    from, e.g.  TP, reconnect  to BNC  and  things will still work  (after a&n;    pause whilst the   driver figures out   where its media went).  My tests&n;    using ping showed that it appears to work....&n;&n;    TO DO:&n;    ------&n;      1.      Improve the timing loops to be accurate across different CPUs&n;              and speeds.&n;&n;&n;    Revision History&n;    ----------------&n;&n;    Version   Date        Description&n;  &n;      0.1     17-Nov-94   Initial writing. ALPHA code release.&n;      0.2     13-Jan-95   Added PCI support for DE435&squot;s&n;      0.21    19-Jan-95   Added auto media detection&n;&n;    =========================================================================&n;*/
DECL|variable|version
r_static
r_char
op_star
id|version
op_assign
l_string|&quot;de4x5.c:v0.21 1/19/95 davies@wanton.lkg.dec.com&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#endif /* MODULE */
macro_line|#include &quot;de4x5.h&quot;
macro_line|#ifdef DE4X5_DEBUG
DECL|variable|de4x5_debug
r_static
r_int
id|de4x5_debug
op_assign
id|DE4X5_DEBUG
suffix:semicolon
macro_line|#else
DECL|variable|de4x5_debug
r_static
r_int
id|de4x5_debug
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#ifndef PROBE_LENGTH
DECL|macro|PROBE_LENGTH
mdefine_line|#define PROBE_LENGTH    32
macro_line|#endif
DECL|macro|ETH_PROM_SIG
mdefine_line|#define ETH_PROM_SIG &quot;FF0055AAFF0055AA&quot;
DECL|macro|DE4X5_SIGNATURE
mdefine_line|#define DE4X5_SIGNATURE {&quot;DE425&quot;,&quot;&quot;}
DECL|macro|DE4X5_NAME_LENGTH
mdefine_line|#define DE4X5_NAME_LENGTH 8
DECL|macro|DE4X5_EISA_IO_PORTS
mdefine_line|#define DE4X5_EISA_IO_PORTS 0x0c00       /* I/O port base address, slot 0 */
DECL|macro|MAX_EISA_SLOTS
mdefine_line|#define MAX_EISA_SLOTS 16
DECL|macro|EISA_SLOT_INC
mdefine_line|#define EISA_SLOT_INC 0x1000
DECL|macro|DE4X5_EISA_SEARCH
mdefine_line|#define DE4X5_EISA_SEARCH 0x00000001     /* probe search mask */
DECL|variable|eisa_slots_full
r_static
id|u_long
id|eisa_slots_full
op_assign
id|DE4X5_EISA_SEARCH
suffix:semicolon
multiline_comment|/* holds which EISA slots hold */
multiline_comment|/* DE425s, for multi-DE425 case */
DECL|macro|PCI_MAX_BUS_NUM
mdefine_line|#define PCI_MAX_BUS_NUM 8
DECL|variable|pci_slots_full
r_static
id|u_long
id|pci_slots_full
(braket
id|PCI_MAX_BUS_NUM
)braket
suffix:semicolon
multiline_comment|/* Which PCI slots used */
multiline_comment|/* on up to PCI_MAX_BUS_NUM buses */
DECL|macro|CRC_POLYNOMIAL_BE
mdefine_line|#define CRC_POLYNOMIAL_BE 0x04c11db7UL   /* Ethernet CRC, big endian */
DECL|macro|CRC_POLYNOMIAL_LE
mdefine_line|#define CRC_POLYNOMIAL_LE 0xedb88320UL   /* Ethernet CRC, little endian */
DECL|macro|LWPAD
mdefine_line|#define LWPAD ((long)(sizeof(long) - 1)) /* for longword alignment */
multiline_comment|/*&n;** DE4X5 IRQ ENABLE/DISABLE&n;*/
DECL|variable|irq_mask
r_static
id|u_long
id|irq_mask
op_assign
id|IMR_RIM
op_or
id|IMR_TIM
op_or
id|IMR_TUM
suffix:semicolon
DECL|variable|irq_en
r_static
id|u_long
id|irq_en
op_assign
id|IMR_NIM
op_or
id|IMR_AIM
suffix:semicolon
DECL|macro|ENABLE_IRQs
mdefine_line|#define ENABLE_IRQs &bslash;&n;  imr |= irq_en;&bslash;&n;  outl(imr, DE4X5_IMR)                      /* Enable the IRQs */
DECL|macro|DISABLE_IRQs
mdefine_line|#define DISABLE_IRQs &bslash;&n;  imr = inl(DE4X5_IMR);&bslash;&n;  imr &amp;= ~irq_en;&bslash;&n;  outl(imr, DE4X5_IMR)                      /* Disable the IRQs */
DECL|macro|UNMASK_IRQs
mdefine_line|#define UNMASK_IRQs &bslash;&n;  imr |= irq_mask;&bslash;&n;  outl(imr, DE4X5_IMR)                      /* Unmask the IRQs */
DECL|macro|MASK_IRQs
mdefine_line|#define MASK_IRQs &bslash;&n;  imr = inl(DE4X5_IMR);&bslash;&n;  imr &amp;= ~irq_mask;&bslash;&n;  outl(imr, DE4X5_IMR)                      /* Mask the IRQs */
multiline_comment|/*&n;** DE4X5 START/STOP&n;*/
DECL|macro|START_DE4X5
mdefine_line|#define START_DE4X5 &bslash;&n;  omr = inl(DE4X5_OMR);&bslash;&n;  omr |= OMR_ST | OMR_SR;&bslash;&n;  outl(omr, DE4X5_OMR)                      /* Enable the TX and/or RX */
DECL|macro|STOP_DE4X5
mdefine_line|#define STOP_DE4X5 &bslash;&n;  omr = inl(DE4X5_OMR);&bslash;&n;  omr &amp;= ~(OMR_ST|OMR_SR);&bslash;&n;  outl(omr, DE4X5_OMR)                      /* Disable the TX and/or RX */
multiline_comment|/*&n;** DE4X5 SIA RESET&n;*/
DECL|macro|RESET_SIA
mdefine_line|#define RESET_SIA &bslash;&n;  outl(SICR_RESET, DE4X5_SICR);             /* Reset SIA connectivity regs */ &bslash;&n;  outl(STRR_RESET, DE4X5_STRR);             /* Write reset values */ &bslash;&n;  outl(SIGR_RESET, DE4X5_SIGR)              /* Write reset values */
multiline_comment|/*&n;** Ethernet Packet Info&n;*/
DECL|macro|PKT_BUF_SZ
mdefine_line|#define PKT_BUF_SZ&t;1544            /* Buffer size for each Tx/Rx buffer */
DECL|macro|MAX_PKT_SZ
mdefine_line|#define MAX_PKT_SZ   &t;1514            /* Maximum ethernet packet length */
DECL|macro|MAX_DAT_SZ
mdefine_line|#define MAX_DAT_SZ   &t;1500            /* Maximum ethernet data length */
DECL|macro|MIN_DAT_SZ
mdefine_line|#define MIN_DAT_SZ   &t;1               /* Minimum ethernet data length */
DECL|macro|PKT_HDR_LEN
mdefine_line|#define PKT_HDR_LEN     14              /* Addresses and data length info */
multiline_comment|/*&n;** DE4X5 Descriptors. Make sure that all the RX buffers are contiguous&n;** and have sizes of both a power of 2 and a multiple of 4.&n;** A size of 256 bytes for each buffer was chosen because over 90% of&n;** all packets in our network are &lt;256 bytes long.&n;*/
DECL|macro|NUM_RX_DESC
mdefine_line|#define NUM_RX_DESC 64                       /* Number of RX descriptors */
DECL|macro|NUM_TX_DESC
mdefine_line|#define NUM_TX_DESC 8                        /* Number of TX descriptors */
DECL|macro|BUFF_ALLOC_RETRIES
mdefine_line|#define BUFF_ALLOC_RETRIES 10                /* In case of memory shortage */
DECL|macro|RX_BUFF_SZ
mdefine_line|#define RX_BUFF_SZ 256                       /* Power of 2 for kmalloc and */
multiline_comment|/* Multiple of 4 for DC21040 */
DECL|struct|de4x5_desc
r_struct
id|de4x5_desc
(brace
DECL|member|status
r_volatile
r_int
id|status
suffix:semicolon
DECL|member|des1
id|u_long
id|des1
suffix:semicolon
DECL|member|buf
r_char
op_star
id|buf
suffix:semicolon
DECL|member|next
r_char
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;** The DE4X5 private structure&n;*/
DECL|macro|DE4X5_PKT_STAT_SZ
mdefine_line|#define DE4X5_PKT_STAT_SZ 16
DECL|macro|DE4X5_PKT_BIN_SZ
mdefine_line|#define DE4X5_PKT_BIN_SZ  128                /* Should be &gt;=100 unless you&n;                                                increase DE4X5_PKT_STAT_SZ */
DECL|struct|de4x5_private
r_struct
id|de4x5_private
(brace
DECL|member|rx_ring
r_struct
id|de4x5_desc
id|rx_ring
(braket
id|NUM_RX_DESC
)braket
suffix:semicolon
multiline_comment|/* RX descriptor ring */
DECL|member|tx_ring
r_struct
id|de4x5_desc
id|tx_ring
(braket
id|NUM_TX_DESC
)braket
suffix:semicolon
multiline_comment|/* TX descriptor ring */
DECL|member|skb
r_struct
id|sk_buff
op_star
id|skb
(braket
id|NUM_TX_DESC
)braket
suffix:semicolon
multiline_comment|/* TX skb for freeing when sent */
DECL|member|rx_new
DECL|member|rx_old
r_int
id|rx_new
comma
id|rx_old
suffix:semicolon
multiline_comment|/* RX descriptor ring pointers */
DECL|member|tx_new
DECL|member|tx_old
r_int
id|tx_new
comma
id|tx_old
suffix:semicolon
multiline_comment|/* TX descriptor ring pointers */
DECL|member|setup_frame
r_char
id|setup_frame
(braket
id|SETUP_FRAME_LEN
)braket
suffix:semicolon
multiline_comment|/* Holds MCA and PA info. */
DECL|member|stats
r_struct
id|enet_statistics
id|stats
suffix:semicolon
multiline_comment|/* Public stats */
r_struct
(brace
DECL|member|bins
r_int
r_int
id|bins
(braket
id|DE4X5_PKT_STAT_SZ
)braket
suffix:semicolon
multiline_comment|/* Private stats counters */
DECL|member|unicast
r_int
r_int
id|unicast
suffix:semicolon
DECL|member|multicast
r_int
r_int
id|multicast
suffix:semicolon
DECL|member|broadcast
r_int
r_int
id|broadcast
suffix:semicolon
DECL|member|excessive_collisions
r_int
r_int
id|excessive_collisions
suffix:semicolon
DECL|member|tx_underruns
r_int
r_int
id|tx_underruns
suffix:semicolon
DECL|member|excessive_underruns
r_int
r_int
id|excessive_underruns
suffix:semicolon
DECL|member|pktStats
)brace
id|pktStats
suffix:semicolon
DECL|member|rxRingSize
r_char
id|rxRingSize
suffix:semicolon
DECL|member|txRingSize
r_char
id|txRingSize
suffix:semicolon
DECL|member|bus
r_char
id|bus
suffix:semicolon
multiline_comment|/* EISA or PCI */
DECL|member|lostMedia
r_char
id|lostMedia
suffix:semicolon
multiline_comment|/* Possibly lost media */
)brace
suffix:semicolon
DECL|macro|TX_BUFFS_AVAIL
mdefine_line|#define TX_BUFFS_AVAIL ((lp-&gt;tx_old&lt;=lp-&gt;tx_new)?&bslash;&n;&t;&t;&t; lp-&gt;tx_old+lp-&gt;txRingSize-lp-&gt;tx_new-1:&bslash;&n;                         lp-&gt;tx_old               -lp-&gt;tx_new-1)
DECL|macro|TX_SUSPENDED
mdefine_line|#define TX_SUSPENDED   (((sts &amp; STS_TS) ^ TS_SUSP)==0)
multiline_comment|/*&n;** Public Functions&n;*/
r_static
r_int
id|de4x5_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|de4x5_queue_pkt
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|de4x5_interrupt
c_func
(paren
r_int
id|reg_ptr
)paren
suffix:semicolon
r_static
r_int
id|de4x5_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|enet_statistics
op_star
id|de4x5_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|num_addrs
comma
r_void
op_star
id|addrs
)paren
suffix:semicolon
r_static
r_int
id|de4x5_ioctl
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;** Private functions&n;*/
r_static
r_int
id|de4x5_hw_init
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|iobase
)paren
suffix:semicolon
r_static
r_int
id|de4x5_init
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|de4x5_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|de4x5_tx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|autoconf_media
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|create_packet
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|frame
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_void
id|load_packet
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
id|u_long
id|flags
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_void
id|EISA_signature
c_func
(paren
r_char
op_star
id|name
comma
r_int
id|iobase
)paren
suffix:semicolon
r_static
r_int
id|DevicePresent
c_func
(paren
r_int
id|iobase
)paren
suffix:semicolon
r_static
r_void
id|SetMulticastFilter
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|num_addrs
comma
r_char
op_star
id|addrs
comma
r_char
op_star
id|multicast_table
)paren
suffix:semicolon
r_static
r_int
id|aprom_crc
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|eisa_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|iobase
)paren
suffix:semicolon
r_static
r_void
id|pci_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|iobase
)paren
suffix:semicolon
r_static
r_struct
id|device
op_star
id|alloc_device
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|iobase
)paren
suffix:semicolon
macro_line|#ifdef MODULE
r_int
id|init_module
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|# else
DECL|variable|de4x5_irq
r_static
r_int
r_char
id|de4x5_irq
(braket
)braket
op_assign
(brace
l_int|5
comma
l_int|9
comma
l_int|10
comma
l_int|11
)brace
suffix:semicolon
macro_line|#endif /* MODULE */
DECL|variable|num_de4x5s
DECL|variable|num_eth
DECL|variable|autoprobed
r_static
r_int
id|num_de4x5s
op_assign
l_int|0
comma
id|num_eth
op_assign
l_int|0
comma
id|autoprobed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;** Kludge to get around the fact that the CSR addresses have different&n;** offsets in the PCI and EISA boards. Also note that the ethernet address&n;** PROM is accessed differently.&n;*/
DECL|struct|bus_type
r_static
r_struct
id|bus_type
(brace
DECL|member|bus
r_int
id|bus
suffix:semicolon
DECL|member|device
r_int
id|device
suffix:semicolon
DECL|variable|bus
)brace
id|bus
suffix:semicolon
multiline_comment|/*&n;** Miscellaneous defines...&n;*/
DECL|macro|RESET_DE4X5
mdefine_line|#define RESET_DE4X5 {&bslash;&n;    long i;&bslash;&n;    i=inl(DE4X5_BMR);&bslash;&n;    outl(i | BMR_SWR, DE4X5_BMR);&bslash;&n;    outl(i, DE4X5_BMR);&bslash;&n;    for (i=0;i&lt;5;i++) inl(DE4X5_BMR);&bslash;&n;&t;&t;   }
"&f;"
DECL|function|de4x5_probe
r_int
id|de4x5_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|tmp
op_assign
id|num_de4x5s
comma
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|status
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iobase
OG
l_int|0
)paren
op_logical_and
(paren
id|iobase
OL
l_int|0x100
)paren
)paren
(brace
multiline_comment|/* Don&squot;t probe at all. */
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
macro_line|#ifdef MODULE
)brace
r_else
r_if
c_cond
(paren
id|iobase
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Autoprobing is not supported when loading a module based driver.&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EIO
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* First probe for the Ethernet */
multiline_comment|/* Address PROM pattern */
id|eisa_probe
c_func
(paren
id|dev
comma
id|iobase
)paren
suffix:semicolon
id|pci_probe
c_func
(paren
id|dev
comma
id|iobase
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_eq
id|num_de4x5s
)paren
op_logical_and
(paren
id|iobase
op_ne
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: de4x5_probe() cannot find device at 0x%04x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|iobase
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;    ** Walk the device list to check that at least one device&n;    ** initialised OK&n;    */
r_for
c_loop
(paren
suffix:semicolon
id|dev-&gt;priv
op_eq
l_int|NULL
op_logical_and
id|dev-&gt;next
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
)paren
id|status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|iobase
op_eq
l_int|0
)paren
id|autoprobed
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
r_static
r_int
DECL|function|de4x5_hw_init
id|de4x5_hw_init
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|iobase
)paren
(brace
r_struct
id|bus_type
op_star
id|lp
op_assign
op_amp
id|bus
suffix:semicolon
r_int
id|tmpbus
comma
id|i
comma
id|j
comma
id|status
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|tmp
comma
id|name
(braket
id|DE4X5_NAME_LENGTH
op_plus
l_int|1
)braket
suffix:semicolon
id|u_long
id|nicsr
suffix:semicolon
multiline_comment|/*&n;  ** First, RESET the board.&n;  */
id|RESET_DE4X5
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|nicsr
op_assign
id|inl
c_func
(paren
id|DE4X5_STS
)paren
)paren
op_amp
(paren
id|STS_TS
op_or
id|STS_RS
)paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Really stopped */
multiline_comment|/* &n;    ** Now find out what kind of DC21040/DC21140 board we have.&n;    */
r_if
c_cond
(paren
id|lp-&gt;bus
op_eq
id|PCI
)paren
(brace
id|strcpy
c_func
(paren
id|name
comma
l_string|&quot;DE435&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|EISA_signature
c_func
(paren
id|name
comma
id|EISA_ID0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|name
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
multiline_comment|/* found a board signature */
id|dev-&gt;base_addr
op_assign
id|iobase
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;bus
op_eq
id|EISA
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s at %#3x (EISA slot %d)&quot;
comma
id|dev-&gt;name
comma
id|name
comma
(paren
id|u_short
)paren
id|iobase
comma
(paren
(paren
(paren
id|u_short
)paren
id|iobase
op_rshift
l_int|12
)paren
op_amp
l_int|0x0f
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* PCI port address */
id|printk
c_func
(paren
l_string|&quot;%s: %s at %#3x (PCI device %d)&quot;
comma
id|dev-&gt;name
comma
id|name
comma
(paren
id|u_short
)paren
id|iobase
comma
id|lp-&gt;device
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;, h/w address &quot;
)paren
suffix:semicolon
id|status
op_assign
id|aprom_crc
c_func
(paren
id|dev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* get the ethernet addr. */
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%2.2x,&bslash;n&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|tmpbus
op_assign
id|lp-&gt;bus
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
suffix:semicolon
multiline_comment|/* &n;&t;** Reserve a section of kernel memory for the adapter&n;&t;** private area and the TX/RX descriptor rings.&n;&t;*/
id|dev-&gt;priv
op_assign
(paren
r_void
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|de4x5_private
)paren
op_plus
id|LWPAD
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Align to a longword boundary&n;&t;*/
id|dev-&gt;priv
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
(paren
id|u_long
)paren
id|dev-&gt;priv
op_plus
id|LWPAD
)paren
op_amp
op_complement
id|LWPAD
)paren
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|de4x5_private
)paren
)paren
suffix:semicolon
id|lp-&gt;bus
op_assign
id|tmpbus
suffix:semicolon
multiline_comment|/*&n;&t;** Allocate contiguous receive buffers, long word aligned. &n;&t;** This could be a possible memory leak if the private area&n;&t;** is ever hosed.&n;&t;*/
r_for
c_loop
(paren
id|tmp
op_assign
l_int|NULL
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|BUFF_ALLOC_RETRIES
op_logical_and
id|tmp
op_eq
l_int|NULL
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|tmp
op_assign
(paren
r_void
op_star
)paren
id|kmalloc
c_func
(paren
id|RX_BUFF_SZ
op_star
id|NUM_RX_DESC
op_plus
id|LWPAD
comma
id|GFP_KERNEL
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|tmp
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
(paren
id|u_long
)paren
id|tmp
op_plus
id|LWPAD
)paren
op_amp
op_complement
id|LWPAD
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_RX_DESC
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|des1
op_assign
id|RX_BUFF_SZ
suffix:semicolon
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|buf
op_assign
id|tmp
op_plus
id|i
op_star
id|RX_BUFF_SZ
suffix:semicolon
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|next
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|tmp
op_ne
l_int|NULL
)paren
(brace
id|lp-&gt;rxRingSize
op_assign
id|NUM_RX_DESC
suffix:semicolon
id|lp-&gt;txRingSize
op_assign
id|NUM_TX_DESC
suffix:semicolon
multiline_comment|/* Write the end of list marker to the descriptor lists */
id|lp-&gt;rx_ring
(braket
id|lp-&gt;rxRingSize
op_minus
l_int|1
)braket
dot
id|des1
op_or_assign
id|RD_RER
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|lp-&gt;txRingSize
op_minus
l_int|1
)braket
dot
id|des1
op_or_assign
id|TD_TER
suffix:semicolon
multiline_comment|/* Tell the adapter where the TX/RX rings are located. */
id|outl
c_func
(paren
(paren
id|u_long
)paren
id|lp-&gt;rx_ring
comma
id|DE4X5_RRBA
)paren
suffix:semicolon
id|outl
c_func
(paren
(paren
id|u_long
)paren
id|lp-&gt;tx_ring
comma
id|DE4X5_TRBA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
)paren
(brace
macro_line|#ifndef MODULE
r_int
r_char
id|irqnum
suffix:semicolon
id|u_long
id|omr
suffix:semicolon
id|autoirq_setup
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|IMR_AIM
op_or
id|IMR_RUM
comma
id|DE4X5_IMR
)paren
suffix:semicolon
multiline_comment|/* Unmask RUM interrupt */
id|outl
c_func
(paren
id|OMR_SR
op_or
id|omr
comma
id|DE4X5_OMR
)paren
suffix:semicolon
multiline_comment|/* Start RX w/no descriptors */
id|irqnum
op_assign
id|autoirq_report
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|irqnum
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;      and failed to detect IRQ line.&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|dev-&gt;irq
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|de4x5_irq
)paren
op_logical_and
op_logical_neg
id|dev-&gt;irq
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|irqnum
op_eq
id|de4x5_irq
(braket
id|i
)braket
)paren
(brace
id|dev-&gt;irq
op_assign
id|irqnum
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;      and uses IRQ%d.&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;irq
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;      but incorrect IRQ line detected.&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
)brace
id|outl
c_func
(paren
l_int|0
comma
id|DE4X5_IMR
)paren
suffix:semicolon
multiline_comment|/* Re-mask RUM interrupt */
macro_line|#endif  /* MODULE */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;      and requires IRQ%d (not probed).&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Kernel could not allocate RX buffer memory.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;      which has an Ethernet PROM CRC error.&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
r_if
c_cond
(paren
id|de4x5_debug
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
)brace
multiline_comment|/* The DE4X5-specific entries in the device structure. */
id|dev-&gt;open
op_assign
op_amp
id|de4x5_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|de4x5_queue_pkt
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|de4x5_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|de4x5_get_stats
suffix:semicolon
macro_line|#ifdef HAVE_MULTICAST
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
macro_line|#endif
id|dev-&gt;do_ioctl
op_assign
op_amp
id|de4x5_ioctl
suffix:semicolon
id|dev-&gt;mem_start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fill in the generic field of the device structure. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Incorrectly initialised hardware */
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|lp
)paren
(brace
id|kfree_s
c_func
(paren
id|lp-&gt;rx_ring
comma
id|RX_BUFF_SZ
op_star
id|NUM_RX_DESC
op_plus
id|LWPAD
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;priv
)paren
(brace
id|kfree_s
c_func
(paren
id|dev-&gt;priv
comma
r_sizeof
(paren
r_struct
id|de4x5_private
)paren
op_plus
id|LWPAD
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|status
suffix:semicolon
)brace
"&f;"
r_static
r_int
DECL|function|de4x5_open
id|de4x5_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|u_long
id|imr
comma
id|omr
comma
id|sts
suffix:semicolon
multiline_comment|/*&n;  ** Stop the TX and RX...&n;  */
id|STOP_DE4X5
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
(paren
r_void
op_star
)paren
id|de4x5_interrupt
comma
l_int|0
comma
l_string|&quot;de4x5&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;de4x5_open(): Requested IRQ%d is busy&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
(brace
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
id|dev
suffix:semicolon
multiline_comment|/* &n;    ** Re-initialize the DE4X5... &n;    */
id|status
op_assign
id|de4x5_init
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de4x5_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: de4x5 open with irq %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tphysical address: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
(paren
r_int
)paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tchecked memory: 0x%08lx&bslash;n&quot;
comma
id|eisa_slots_full
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Descriptor head addresses:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;t0x%8.8lx  0x%8.8lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|lp-&gt;rx_ring
comma
(paren
r_int
)paren
id|lp-&gt;tx_ring
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Descriptor addresses:&bslash;nRX: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;rxRingSize
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;0x%8.8lx  &quot;
comma
(paren
r_int
)paren
op_amp
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;...0x%8.8lx&bslash;n&quot;
comma
(paren
r_int
)paren
op_amp
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TX: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;txRingSize
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;0x%8.8lx  &quot;
comma
(paren
r_int
)paren
op_amp
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|status
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;...0x%8.8lx&bslash;n&quot;
comma
(paren
r_int
)paren
op_amp
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|status
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Descriptor buffers:&bslash;nRX: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;rxRingSize
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;0x%8.8lx  &quot;
comma
(paren
r_int
)paren
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|buf
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;...0x%8.8lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|buf
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TX: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;txRingSize
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;0x%8.8lx  &quot;
comma
(paren
r_int
)paren
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|buf
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;...0x%8.8lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|buf
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Ring size: &bslash;nRX: %d&bslash;nTX: %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|lp-&gt;rxRingSize
comma
(paren
r_int
)paren
id|lp-&gt;txRingSize
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tstatus:  %d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;interrupt
op_assign
id|UNMASK_INTERRUPTS
suffix:semicolon
multiline_comment|/*&n;      ** Reset any pending interrupts&n;      */
id|sts
op_assign
id|inl
c_func
(paren
id|DE4X5_STS
)paren
suffix:semicolon
id|outl
c_func
(paren
id|sts
comma
id|DE4X5_STS
)paren
suffix:semicolon
multiline_comment|/*&n;      ** Unmask and enable DE4X5 board interrupts&n;      */
id|imr
op_assign
l_int|0
suffix:semicolon
id|UNMASK_IRQs
suffix:semicolon
id|ENABLE_IRQs
suffix:semicolon
id|START_DE4X5
suffix:semicolon
)brace
r_if
c_cond
(paren
id|de4x5_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;tsts:  0x%08x&bslash;n&quot;
comma
id|inl
c_func
(paren
id|DE4X5_STS
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tbmr:  0x%08x&bslash;n&quot;
comma
id|inl
c_func
(paren
id|DE4X5_BMR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;timr:  0x%08x&bslash;n&quot;
comma
id|inl
c_func
(paren
id|DE4X5_IMR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tomr:  0x%08x&bslash;n&quot;
comma
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tsisr: 0x%08x&bslash;n&quot;
comma
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tsicr: 0x%08x&bslash;n&quot;
comma
id|inl
c_func
(paren
id|DE4X5_SICR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tstrr: 0x%08x&bslash;n&quot;
comma
id|inl
c_func
(paren
id|DE4X5_STRR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tsigr: 0x%08x&bslash;n&quot;
comma
id|inl
c_func
(paren
id|DE4X5_SIGR
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif       
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;** Initialize the DE4X5 operating conditions&n;*/
r_static
r_int
DECL|function|de4x5_init
id|de4x5_init
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|offset
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|u_long
id|i
comma
id|j
comma
id|bmr
comma
id|omr
suffix:semicolon
r_char
op_star
id|pa
suffix:semicolon
multiline_comment|/* Ensure a full reset */
id|RESET_DE4X5
suffix:semicolon
multiline_comment|/* Set up automatic transmit polling every 1.6ms */
id|bmr
op_assign
id|inl
c_func
(paren
id|DE4X5_BMR
)paren
suffix:semicolon
id|bmr
op_or_assign
id|TAP_1_6MS
op_or
id|CAL_16LONG
suffix:semicolon
id|outl
c_func
(paren
id|bmr
comma
id|DE4X5_BMR
)paren
suffix:semicolon
multiline_comment|/* Set up imperfect filtering mode as default, turn off promiscuous mode */
id|omr
op_assign
id|OMR_HP
suffix:semicolon
id|offset
op_assign
id|IMPERF_PA_OFFSET
suffix:semicolon
multiline_comment|/* Lock out other processes whilst setting up the hardware */
id|set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|dev-&gt;tbusy
)paren
suffix:semicolon
multiline_comment|/* Rewrite the descriptor lists&squot; start addresses */
id|outl
c_func
(paren
(paren
id|u_long
)paren
id|lp-&gt;rx_ring
comma
id|DE4X5_RRBA
)paren
suffix:semicolon
multiline_comment|/* Start of RX Descriptor List */
id|outl
c_func
(paren
(paren
id|u_long
)paren
id|lp-&gt;tx_ring
comma
id|DE4X5_TRBA
)paren
suffix:semicolon
multiline_comment|/* Start of TX Descriptor List */
multiline_comment|/* Reset the buffer pointers */
id|lp-&gt;rx_new
op_assign
id|lp-&gt;rx_old
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tx_new
op_assign
id|lp-&gt;tx_old
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize each descriptor ownership in the RX ring */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;rxRingSize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status
op_assign
id|R_OWN
suffix:semicolon
)brace
multiline_comment|/* Initialize each descriptor ownership in the TX ring */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;txRingSize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|status
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Initialise the setup frame prior to starting the receive process */
id|memset
c_func
(paren
id|lp-&gt;setup_frame
comma
l_int|0
comma
id|SETUP_FRAME_LEN
)paren
suffix:semicolon
multiline_comment|/* Insert the physical address */
r_for
c_loop
(paren
id|pa
op_assign
id|lp-&gt;setup_frame
op_plus
id|offset
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ETH_ALEN
suffix:semicolon
id|j
op_increment
)paren
(brace
op_star
(paren
id|pa
op_plus
id|j
)paren
op_assign
id|dev-&gt;dev_addr
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|j
op_amp
l_int|0x01
)paren
id|pa
op_add_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/* Clear the multicast list */
id|set_multicast_list
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Tell the hardware there&squot;s a new packet to be sent */
id|load_packet
c_func
(paren
id|dev
comma
id|lp-&gt;setup_frame
comma
id|HASH_F
op_or
id|TD_SET
op_or
id|SETUP_FRAME_LEN
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Start the TX process */
id|outl
c_func
(paren
id|omr
op_or
id|OMR_ST
comma
id|DE4X5_OMR
)paren
suffix:semicolon
multiline_comment|/* Poll for completion of setup frame (interrupts are disabled for now) */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
op_logical_and
id|j
op_eq
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;tx_ring
(braket
id|lp-&gt;tx_new
)braket
dot
id|status
op_ge
l_int|0
)paren
id|j
op_assign
l_int|1
suffix:semicolon
)brace
id|outl
c_func
(paren
id|omr
comma
id|DE4X5_OMR
)paren
suffix:semicolon
multiline_comment|/* Stop everything! */
r_if
c_cond
(paren
id|i
op_eq
l_int|100
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Setup frame timed out, status %08x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inl
c_func
(paren
id|DE4X5_STS
)paren
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Update pointers */
id|lp-&gt;tx_new
op_assign
(paren
op_increment
id|lp-&gt;tx_new
)paren
op_mod
id|lp-&gt;txRingSize
suffix:semicolon
id|lp-&gt;tx_old
op_assign
id|lp-&gt;tx_new
suffix:semicolon
multiline_comment|/* Autoconfigure the connected port */
r_if
c_cond
(paren
id|autoconf_media
c_func
(paren
id|dev
)paren
op_eq
l_int|0
)paren
(brace
id|status
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n;** Writes a socket buffer address to the next available transmit descriptor&n;*/
r_static
r_int
DECL|function|de4x5_queue_pkt
id|de4x5_queue_pkt
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_volatile
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
id|u_long
id|imr
comma
id|omr
comma
id|sts
suffix:semicolon
id|sts
op_assign
id|inl
c_func
(paren
id|DE4X5_STS
)paren
suffix:semicolon
multiline_comment|/* &n;  ** Transmitter timeout, possibly serious problems.&n;  ** The &squot;lostMedia&squot; threshold accounts for transient errors that&n;  ** were noticed when switching media.&n;  */
r_if
c_cond
(paren
id|dev-&gt;tbusy
op_logical_or
(paren
id|lp-&gt;lostMedia
OG
l_int|3
)paren
)paren
(brace
r_int
id|tickssofar
op_assign
id|jiffies
op_minus
id|dev-&gt;trans_start
suffix:semicolon
r_if
c_cond
(paren
id|tickssofar
OL
l_int|10
op_logical_and
op_logical_neg
id|lp-&gt;lostMedia
)paren
(brace
multiline_comment|/* Check if TX ring is full or not - &squot;tbusy&squot; cleared if not full. */
r_if
c_cond
(paren
(paren
id|TX_BUFFS_AVAIL
OG
l_int|0
)paren
op_logical_and
id|dev-&gt;tbusy
)paren
(brace
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
)brace
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: transmit timed out, status %08x, tbusy:%d, lostMedia:%d tickssofar:%d, resetting.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inl
c_func
(paren
id|DE4X5_STS
)paren
comma
id|dev-&gt;tbusy
comma
id|lp-&gt;lostMedia
comma
id|tickssofar
)paren
suffix:semicolon
multiline_comment|/* Stop and reset the TX and RX... */
id|STOP_DE4X5
suffix:semicolon
id|status
op_assign
id|de4x5_init
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Unmask DE4X5 board interrupts */
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
multiline_comment|/* Start here to clean stale interrupts later */
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|START_DE4X5
suffix:semicolon
multiline_comment|/* Clear any pending (stale) interrupts */
id|sts
op_assign
id|inl
c_func
(paren
id|DE4X5_STS
)paren
suffix:semicolon
id|outl
c_func
(paren
id|sts
comma
id|DE4X5_STS
)paren
suffix:semicolon
multiline_comment|/* Unmask DE4X5 board interrupts */
id|imr
op_assign
l_int|0
suffix:semicolon
id|UNMASK_IRQs
suffix:semicolon
id|dev-&gt;interrupt
op_assign
id|UNMASK_INTERRUPTS
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|ENABLE_IRQs
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: hardware initialisation failure, status %08x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inl
c_func
(paren
id|DE4X5_STS
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|dev_tint
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|skb-&gt;len
OG
l_int|0
)paren
(brace
multiline_comment|/* &n;    ** Block a timer-based transmit from overlapping.  This could better be&n;    ** done with atomic_swap(1, dev-&gt;tbusy), but set_bit() works as well. &n;    */
r_if
c_cond
(paren
id|set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|dev-&gt;tbusy
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Transmitter access conflict.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TX_BUFFS_AVAIL
OG
l_int|0
)paren
(brace
multiline_comment|/* Fill in a Tx ring entry */
r_if
c_cond
(paren
(paren
(paren
id|u_long
)paren
id|skb-&gt;data
op_amp
op_complement
l_int|0x03
)paren
op_ne
(paren
id|u_long
)paren
id|skb-&gt;data
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: TX skb buffer alignment prob..&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
id|load_packet
c_func
(paren
id|dev
comma
id|skb-&gt;data
comma
id|TD_IC
op_or
id|TD_LS
op_or
id|TD_FS
op_or
id|skb-&gt;len
comma
id|skb
)paren
suffix:semicolon
id|outl
c_func
(paren
id|POLL_DEMAND
comma
id|DE4X5_TPD
)paren
suffix:semicolon
multiline_comment|/* Start the TX */
id|lp-&gt;tx_new
op_assign
(paren
op_increment
id|lp-&gt;tx_new
)paren
op_mod
id|lp-&gt;txRingSize
suffix:semicolon
multiline_comment|/* Ensure a wrap */
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TX_BUFFS_AVAIL
OG
l_int|0
)paren
(brace
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Another pkt may be queued */
)brace
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;** The DE4X5 interrupt handler. &n;*/
r_static
r_void
DECL|function|de4x5_interrupt
id|de4x5_interrupt
c_func
(paren
r_int
id|reg_ptr
)paren
(brace
r_int
id|irq
op_assign
op_minus
(paren
(paren
(paren
r_struct
id|pt_regs
op_star
)paren
id|reg_ptr
)paren
op_member_access_from_pointer
id|orig_eax
op_plus
l_int|2
)paren
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
(paren
r_struct
id|device
op_star
)paren
(paren
id|irq2dev_map
(braket
id|irq
)braket
)paren
suffix:semicolon
r_struct
id|de4x5_private
op_star
id|lp
suffix:semicolon
r_int
id|iobase
suffix:semicolon
id|u_long
id|imr
comma
id|sts
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;de4x5_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
r_else
(brace
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;interrupt
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Re-entering the interrupt handler.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|dev-&gt;interrupt
op_assign
id|MASK_INTERRUPTS
suffix:semicolon
multiline_comment|/* &n;      ** Get the interrupt information and disable them. &n;      ** The device read will ensure pending buffers are flushed&n;      ** in intermediate PCI bridges, so that the posted interrupt&n;      ** has some real data to work with.&n;      */
id|sts
op_assign
id|inl
c_func
(paren
id|DE4X5_STS
)paren
suffix:semicolon
id|MASK_IRQs
suffix:semicolon
multiline_comment|/* &n;      ** Acknowledge the DE4X5 board interrupts&n;      */
id|outl
c_func
(paren
id|sts
comma
id|DE4X5_STS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sts
op_amp
id|STS_RI
)paren
multiline_comment|/* Rx interrupt (packet[s] arrived) */
id|de4x5_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sts
op_amp
id|STS_TI
)paren
multiline_comment|/* Tx interrupt (packet sent) */
id|de4x5_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|TX_BUFFS_AVAIL
OG
l_int|0
)paren
op_logical_and
id|dev-&gt;tbusy
)paren
(brace
multiline_comment|/* any resources available? */
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clear TX busy flag */
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
id|dev-&gt;interrupt
op_assign
id|UNMASK_INTERRUPTS
suffix:semicolon
id|UNMASK_IRQs
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|de4x5_rx
id|de4x5_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
comma
id|entry
suffix:semicolon
r_volatile
r_int
id|status
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
multiline_comment|/* Loop over any new packets for sending up the stack */
r_for
c_loop
(paren
id|entry
op_assign
id|lp-&gt;rx_new
suffix:semicolon
id|lp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|status
op_ge
l_int|0
suffix:semicolon
id|entry
op_assign
id|lp-&gt;rx_new
)paren
(brace
id|status
op_assign
id|lp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|status
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RD_FS
)paren
(brace
multiline_comment|/* Remember the start of frame */
id|lp-&gt;rx_old
op_assign
id|entry
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|RD_LS
)paren
(brace
multiline_comment|/* Valid frame status */
r_if
c_cond
(paren
id|status
op_amp
id|RD_ES
)paren
(brace
multiline_comment|/* There was an error. */
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
multiline_comment|/* Update the error stats. */
r_if
c_cond
(paren
id|status
op_amp
(paren
id|RD_RF
op_or
id|RD_TL
)paren
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RD_CE
)paren
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RD_OF
)paren
id|lp-&gt;stats.rx_fifo_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* A valid frame received */
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|pkt_len
op_assign
(paren
r_int
)paren
(paren
id|lp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|status
op_rshift
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|pkt_len
comma
id|GFP_ATOMIC
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|skb-&gt;len
op_assign
id|pkt_len
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|entry
OL
id|lp-&gt;rx_old
)paren
(brace
multiline_comment|/* Wrapped buffer */
r_int
id|len
op_assign
(paren
id|lp-&gt;rxRingSize
op_minus
id|lp-&gt;rx_old
)paren
op_star
id|RX_BUFF_SZ
suffix:semicolon
id|memcpy
c_func
(paren
id|skb-&gt;data
comma
id|lp-&gt;rx_ring
(braket
id|lp-&gt;rx_old
)braket
dot
id|buf
comma
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb-&gt;data
op_plus
id|len
comma
id|lp-&gt;rx_ring
(braket
l_int|0
)braket
dot
id|buf
comma
id|pkt_len
op_minus
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Linear buffer */
id|memcpy
c_func
(paren
id|skb-&gt;data
comma
id|lp-&gt;rx_ring
(braket
id|lp-&gt;rx_old
)braket
dot
id|buf
comma
id|pkt_len
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;  ** Notify the upper protocol layers that there is another &n;&t;  ** packet to handle&n;&t;  */
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;  ** Update stats&n;&t;  */
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|DE4X5_PKT_STAT_SZ
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pkt_len
OL
id|i
op_star
id|DE4X5_PKT_BIN_SZ
)paren
(brace
id|lp-&gt;pktStats.bins
(braket
id|i
)braket
op_increment
suffix:semicolon
id|i
op_assign
id|DE4X5_PKT_STAT_SZ
suffix:semicolon
)brace
)brace
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* Look at the dest addr */
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_amp
l_int|0x01
)paren
(brace
multiline_comment|/* Multicast/Broadcast */
r_if
c_cond
(paren
(paren
op_star
(paren
r_int
op_star
)paren
op_amp
id|buf
(braket
l_int|0
)braket
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
op_star
(paren
r_int
op_star
)paren
op_amp
id|buf
(braket
l_int|4
)braket
op_eq
op_minus
l_int|1
)paren
)paren
(brace
id|lp-&gt;pktStats.broadcast
op_increment
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;pktStats.multicast
op_increment
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
op_star
(paren
r_int
op_star
)paren
op_amp
id|buf
(braket
l_int|0
)braket
op_eq
op_star
(paren
r_int
op_star
)paren
op_amp
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
)paren
op_logical_and
(paren
op_star
(paren
r_int
op_star
)paren
op_amp
id|buf
(braket
l_int|4
)braket
op_eq
op_star
(paren
r_int
op_star
)paren
op_amp
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
)paren
)paren
(brace
id|lp-&gt;pktStats.unicast
op_increment
suffix:semicolon
)brace
id|lp-&gt;pktStats.bins
(braket
l_int|0
)braket
op_increment
suffix:semicolon
multiline_comment|/* Duplicates stats.rx_packets */
r_if
c_cond
(paren
id|lp-&gt;pktStats.bins
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Reset counters */
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|lp-&gt;pktStats
comma
l_int|0
comma
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Insufficient memory; nuking packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
multiline_comment|/* Really, deferred. */
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Change buffer ownership for this last frame, back to the adapter */
r_for
c_loop
(paren
suffix:semicolon
id|lp-&gt;rx_old
op_ne
id|entry
suffix:semicolon
id|lp-&gt;rx_old
op_assign
(paren
op_increment
id|lp-&gt;rx_old
)paren
op_mod
id|lp-&gt;rxRingSize
)paren
(brace
id|lp-&gt;rx_ring
(braket
id|lp-&gt;rx_old
)braket
dot
id|status
op_assign
id|R_OWN
suffix:semicolon
)brace
id|lp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|status
op_assign
id|R_OWN
suffix:semicolon
)brace
multiline_comment|/*&n;    ** Update entry information&n;    */
id|lp-&gt;rx_new
op_assign
(paren
op_increment
id|lp-&gt;rx_new
)paren
op_mod
id|lp-&gt;rxRingSize
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** Buffer sent - check for TX buffer errors.&n;*/
r_static
r_int
DECL|function|de4x5_tx
id|de4x5_tx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|entry
comma
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_volatile
r_int
id|status
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|lp-&gt;tx_old
suffix:semicolon
id|entry
op_ne
id|lp-&gt;tx_new
suffix:semicolon
id|entry
op_assign
id|lp-&gt;tx_old
)paren
(brace
id|status
op_assign
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|status
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
multiline_comment|/* Buffer not sent yet */
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|TD_ES
)paren
(brace
multiline_comment|/* An error happened */
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_NC
)paren
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_LC
)paren
id|lp-&gt;stats.tx_window_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_UF
)paren
id|lp-&gt;stats.tx_fifo_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_LC
)paren
id|lp-&gt;stats.collisions
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_EC
)paren
id|lp-&gt;pktStats.excessive_collisions
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_DE
)paren
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|TD_LO
op_or
id|TD_NC
op_or
id|TD_EC
op_or
id|TD_LF
)paren
)paren
(brace
id|lp-&gt;lostMedia
op_increment
suffix:semicolon
)brace
r_else
(brace
id|outl
c_func
(paren
id|POLL_DEMAND
comma
id|DE4X5_TPD
)paren
suffix:semicolon
multiline_comment|/* Restart a stalled TX */
)brace
)brace
r_else
(brace
multiline_comment|/* Packet sent */
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|lp-&gt;lostMedia
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Remove transient problem */
)brace
multiline_comment|/* Free the buffer if it&squot;s not a setup frame. */
r_if
c_cond
(paren
id|lp-&gt;skb
(braket
id|entry
)braket
op_ne
l_int|NULL
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;skb
(braket
id|entry
)braket
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
multiline_comment|/* Update all the pointers */
id|lp-&gt;tx_old
op_assign
(paren
op_increment
id|lp-&gt;tx_old
)paren
op_mod
id|lp-&gt;txRingSize
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|de4x5_close
id|de4x5_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u_long
id|imr
comma
id|omr
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|de4x5_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Shutting down ethercard, status was %8.8x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inl
c_func
(paren
id|DE4X5_STS
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;  ** We stop the DE4X5 here... mask interrupts and stop TX &amp; RX&n;  */
id|DISABLE_IRQs
suffix:semicolon
id|STOP_DE4X5
suffix:semicolon
multiline_comment|/*&n;  ** Free the associated irq&n;  */
id|free_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif    
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|enet_statistics
op_star
DECL|function|de4x5_get_stats
id|de4x5_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp-&gt;stats.rx_missed_errors
op_assign
(paren
r_int
)paren
id|inl
c_func
(paren
id|DE4X5_MFC
)paren
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
DECL|function|load_packet
r_static
r_void
id|load_packet
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
id|u_long
id|flags
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|lp-&gt;tx_new
)braket
dot
id|buf
op_assign
id|buf
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|lp-&gt;tx_new
)braket
dot
id|des1
op_and_assign
id|TD_TER
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|lp-&gt;tx_new
)braket
dot
id|des1
op_or_assign
id|flags
suffix:semicolon
id|lp-&gt;skb
(braket
id|lp-&gt;tx_new
)braket
op_assign
id|skb
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|lp-&gt;tx_new
)braket
dot
id|status
op_assign
id|T_OWN
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** Set or clear the multicast filter for this adaptor.&n;** num_addrs == -1&t;Promiscuous mode, receive all packets&n;** num_addrs == 0&t;Normal mode, clear multicast list&n;** num_addrs &gt; 0&t;Multicast mode, receive normal and MC packets, and do&n;** &t;&t;&t;best-effort filtering.&n;** num_addrs == HASH_TABLE_LEN&n;**&t;                Set all multicast bits&n;*/
r_static
r_void
DECL|function|set_multicast_list
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|num_addrs
comma
r_void
op_star
id|addrs
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u_long
id|omr
suffix:semicolon
multiline_comment|/* First, double check that the adapter is open */
r_if
c_cond
(paren
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_ne
l_int|NULL
)paren
(brace
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_addrs
op_ge
l_int|0
)paren
(brace
id|SetMulticastFilter
c_func
(paren
id|dev
comma
id|num_addrs
comma
(paren
r_char
op_star
)paren
id|addrs
comma
id|lp-&gt;setup_frame
)paren
suffix:semicolon
multiline_comment|/* Tell the hardware that there&squot;s a new packet to be sent */
id|load_packet
c_func
(paren
id|dev
comma
id|lp-&gt;setup_frame
comma
id|TD_IC
op_or
id|HASH_F
op_or
id|TD_SET
op_or
id|SETUP_FRAME_LEN
comma
l_int|NULL
)paren
suffix:semicolon
id|lp-&gt;tx_new
op_assign
(paren
op_increment
id|lp-&gt;tx_new
)paren
op_mod
id|lp-&gt;txRingSize
suffix:semicolon
id|outl
c_func
(paren
id|POLL_DEMAND
comma
id|DE4X5_TPD
)paren
suffix:semicolon
multiline_comment|/* Start the TX */
id|omr
op_and_assign
op_complement
id|OMR_PR
suffix:semicolon
id|omr
op_or_assign
id|OMR_PM
suffix:semicolon
id|outl
c_func
(paren
id|omr
comma
id|DE4X5_OMR
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* set promiscuous mode */
id|omr
op_or_assign
id|OMR_PR
suffix:semicolon
id|omr
op_and_assign
op_complement
id|OMR_PM
suffix:semicolon
id|outl
c_func
(paren
id|omr
comma
id|DE4X5_OMR
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;** Calculate the hash code and update the logical address filter&n;** from a list of ethernet multicast addresses.&n;** Little endian crc one liner from Matt Thomas, DEC.&n;*/
DECL|function|SetMulticastFilter
r_static
r_void
id|SetMulticastFilter
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|num_addrs
comma
r_char
op_star
id|addrs
comma
r_char
op_star
id|multicast_table
)paren
(brace
r_char
id|j
comma
id|bit
comma
id|byte
suffix:semicolon
r_int
op_star
id|p
op_assign
(paren
r_int
op_star
)paren
id|multicast_table
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u_short
id|hashcode
suffix:semicolon
id|u_long
id|crc
comma
id|poly
op_assign
id|CRC_POLYNOMIAL_LE
suffix:semicolon
r_if
c_cond
(paren
id|num_addrs
op_eq
id|HASH_TABLE_LEN
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|4
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|p
op_increment
op_assign
l_int|0x0000ffff
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Clear the multicast table except for the broadcast bit */
id|memset
c_func
(paren
id|multicast_table
comma
l_int|0
comma
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|2
)paren
)paren
suffix:semicolon
op_star
(paren
id|multicast_table
op_plus
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
op_minus
l_int|3
)paren
op_assign
l_int|0x80
suffix:semicolon
multiline_comment|/* Now update the table */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_addrs
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* for each address in the list */
r_if
c_cond
(paren
(paren
op_star
id|addrs
op_amp
l_int|0x01
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* multicast address? */
id|crc
op_assign
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* init CRC for each address */
r_for
c_loop
(paren
id|byte
op_assign
l_int|0
suffix:semicolon
id|byte
OL
id|ETH_ALEN
suffix:semicolon
id|byte
op_increment
)paren
(brace
multiline_comment|/* for each address byte */
multiline_comment|/* process each address bit */
r_for
c_loop
(paren
id|bit
op_assign
op_star
id|addrs
op_increment
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
comma
id|bit
op_rshift_assign
l_int|1
)paren
(brace
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|1
)paren
op_xor
(paren
(paren
(paren
id|crc
op_xor
id|bit
)paren
op_amp
l_int|0x01
)paren
ques
c_cond
id|poly
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|hashcode
op_assign
id|crc
op_amp
(paren
(paren
l_int|1
op_lshift
l_int|9
)paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* hashcode is 9 LSb of CRC */
id|byte
op_assign
id|hashcode
op_rshift
l_int|3
suffix:semicolon
multiline_comment|/* bit[3-8] -&gt; byte in filter */
id|bit
op_assign
l_int|1
op_lshift
(paren
id|hashcode
op_amp
l_int|0x07
)paren
suffix:semicolon
multiline_comment|/* bit[0-2] -&gt; bit in byte */
id|byte
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* calc offset into setup frame */
r_if
c_cond
(paren
id|byte
op_amp
l_int|0x02
)paren
(brace
id|byte
op_sub_assign
l_int|1
suffix:semicolon
)brace
id|multicast_table
(braket
id|byte
)braket
op_or_assign
id|bit
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* skip this address */
id|addrs
op_add_assign
id|ETH_ALEN
suffix:semicolon
)brace
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** EISA bus I/O device probe. Probe from slot 1 since slot 0 is usually&n;** the motherboard. Upto 15 EISA devices are supported.&n;*/
DECL|function|eisa_probe
r_static
r_void
id|eisa_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
r_int
id|i
comma
id|maxSlots
suffix:semicolon
r_int
id|status
suffix:semicolon
id|u_short
id|iobase
suffix:semicolon
r_struct
id|bus_type
op_star
id|lp
op_assign
op_amp
id|bus
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioaddr
op_logical_and
id|autoprobed
)paren
r_return
suffix:semicolon
multiline_comment|/* Been here before ! */
id|lp-&gt;bus
op_assign
id|EISA
suffix:semicolon
r_if
c_cond
(paren
id|ioaddr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Autoprobing */
id|iobase
op_assign
id|EISA_SLOT_INC
suffix:semicolon
multiline_comment|/* Get the first slot address */
id|i
op_assign
l_int|1
suffix:semicolon
id|maxSlots
op_assign
id|MAX_EISA_SLOTS
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Probe a specific location */
id|iobase
op_assign
id|ioaddr
suffix:semicolon
id|i
op_assign
(paren
id|ioaddr
op_rshift
l_int|12
)paren
suffix:semicolon
id|maxSlots
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|status
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|i
OL
id|maxSlots
op_logical_and
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
comma
id|iobase
op_add_assign
id|EISA_SLOT_INC
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|eisa_slots_full
op_rshift
id|i
)paren
op_amp
l_int|0x01
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|DevicePresent
c_func
(paren
id|EISA_APROM
)paren
op_eq
l_int|0
)paren
(brace
id|eisa_slots_full
op_or_assign
(paren
l_int|0x01
op_lshift
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|alloc_device
c_func
(paren
id|dev
comma
id|iobase
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|status
op_assign
id|de4x5_hw_init
c_func
(paren
id|dev
comma
id|iobase
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|num_de4x5s
op_increment
suffix:semicolon
)brace
id|num_eth
op_increment
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: EISA device already allocated at 0x%04x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|iobase
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** PCI bus I/O device probe&n;*/
DECL|macro|PCI_DEVICE
mdefine_line|#define PCI_DEVICE (dev_num &lt;&lt; 3)
DECL|function|pci_probe
r_static
r_void
id|pci_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
id|u_char
id|irq
suffix:semicolon
id|u_short
id|pb
comma
id|dev_num
suffix:semicolon
id|u_short
id|i
comma
id|vendor
comma
id|device
comma
id|status
suffix:semicolon
id|u_long
r_class
comma
id|iobase
suffix:semicolon
r_struct
id|bus_type
op_star
id|lp
op_assign
op_amp
id|bus
suffix:semicolon
r_static
r_char
id|pci_init
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioaddr
op_logical_and
id|autoprobed
)paren
r_return
suffix:semicolon
multiline_comment|/* Been here before ! */
r_if
c_cond
(paren
op_logical_neg
id|pci_init
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PCI_MAX_BUS_NUM
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pci_slots_full
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|pci_init
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pcibios_present
c_func
(paren
)paren
)paren
(brace
id|lp-&gt;bus
op_assign
id|PCI
suffix:semicolon
r_for
c_loop
(paren
id|pb
op_assign
l_int|0
comma
id|dev_num
op_assign
l_int|0
suffix:semicolon
id|dev_num
OL
l_int|32
op_logical_and
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev_num
op_increment
)paren
(brace
id|pcibios_read_config_dword
c_func
(paren
id|pb
comma
id|PCI_DEVICE
comma
id|PCI_CLASS_REVISION
comma
op_amp
r_class
)paren
suffix:semicolon
r_if
c_cond
(paren
r_class
op_ne
l_int|0xffffffff
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|pci_slots_full
(braket
id|pb
)braket
op_rshift
id|dev_num
)paren
op_amp
l_int|0x01
)paren
op_eq
l_int|0
)paren
(brace
id|pcibios_read_config_word
c_func
(paren
id|pb
comma
id|PCI_DEVICE
comma
id|PCI_VENDOR_ID
comma
op_amp
id|vendor
)paren
suffix:semicolon
id|pcibios_read_config_word
c_func
(paren
id|pb
comma
id|PCI_DEVICE
comma
id|PCI_DEVICE_ID
comma
op_amp
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vendor
op_eq
id|DC21040_VID
)paren
op_logical_and
(paren
id|device
op_eq
id|DC21040_DID
)paren
)paren
(brace
multiline_comment|/* Set the device number information */
id|lp-&gt;device
op_assign
id|dev_num
suffix:semicolon
multiline_comment|/* Get the board I/O address */
id|pcibios_read_config_dword
c_func
(paren
id|pb
comma
id|PCI_DEVICE
comma
id|PCI_BASE_ADDRESS_0
comma
op_amp
id|iobase
)paren
suffix:semicolon
id|iobase
op_and_assign
id|CBIO_MASK
suffix:semicolon
multiline_comment|/* Fetch the IRQ to be used */
id|pcibios_read_config_byte
c_func
(paren
id|pb
comma
id|PCI_DEVICE
comma
id|PCI_INTERRUPT_LINE
comma
op_amp
id|irq
)paren
suffix:semicolon
multiline_comment|/* Enable I/O Accesses and Bus Mastering */
id|pcibios_read_config_word
c_func
(paren
id|pb
comma
id|PCI_DEVICE
comma
id|PCI_COMMAND
comma
op_amp
id|status
)paren
suffix:semicolon
id|status
op_or_assign
id|PCI_COMMAND_IO
op_or
id|PCI_COMMAND_MASTER
suffix:semicolon
id|pcibios_write_config_word
c_func
(paren
id|pb
comma
id|PCI_DEVICE
comma
id|PCI_COMMAND
comma
id|status
)paren
suffix:semicolon
multiline_comment|/* If a device is present, initialise it */
r_if
c_cond
(paren
id|DevicePresent
c_func
(paren
id|DE4X5_APROM
)paren
op_eq
l_int|0
)paren
(brace
id|pci_slots_full
(braket
id|pb
)braket
op_or_assign
(paren
l_int|0x01
op_lshift
id|dev_num
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|alloc_device
c_func
(paren
id|dev
comma
id|iobase
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|de4x5_hw_init
c_func
(paren
id|dev
comma
id|iobase
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|num_de4x5s
op_increment
suffix:semicolon
)brace
id|num_eth
op_increment
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: PCI device already allocated at slot %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev_num
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** Allocate the device by pointing to the next available space in the&n;** device structure. Should one not be available, it is created.&n;*/
DECL|function|alloc_device
r_static
r_struct
id|device
op_star
id|alloc_device
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|iobase
)paren
(brace
r_int
id|addAutoProbe
op_assign
l_int|0
suffix:semicolon
r_struct
id|device
op_star
id|tmp
op_assign
l_int|NULL
comma
op_star
id|ret
suffix:semicolon
r_int
(paren
op_star
id|init
)paren
(paren
r_struct
id|device
op_star
)paren
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;  ** Check the device structures for an end of list or unused device&n;  */
r_while
c_loop
(paren
id|dev-&gt;next
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;base_addr
op_eq
l_int|0xffe0
)paren
op_logical_or
(paren
id|dev-&gt;base_addr
op_eq
l_int|0
)paren
)paren
r_break
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
suffix:semicolon
multiline_comment|/* walk through eth device list */
id|num_eth
op_increment
suffix:semicolon
multiline_comment|/* increment eth device number */
)brace
multiline_comment|/*&n;  ** If an autoprobe is requested for another device, we must re-insert&n;  ** the request later in the list. Remember the current position first.&n;  */
r_if
c_cond
(paren
(paren
id|dev-&gt;base_addr
op_eq
l_int|0
)paren
op_logical_and
(paren
id|num_de4x5s
OG
l_int|0
)paren
)paren
(brace
id|addAutoProbe
op_increment
suffix:semicolon
id|tmp
op_assign
id|dev-&gt;next
suffix:semicolon
multiline_comment|/* point to the next device */
id|init
op_assign
id|dev-&gt;init
suffix:semicolon
multiline_comment|/* remember the probe function */
)brace
multiline_comment|/*&n;  ** If at end of list and can&squot;t use current entry, malloc one up. &n;  ** If memory could not be allocated, print an error message.&n;  */
r_if
c_cond
(paren
(paren
id|dev-&gt;next
op_eq
l_int|NULL
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|dev-&gt;base_addr
op_eq
l_int|0xffe0
)paren
op_logical_or
(paren
id|dev-&gt;base_addr
op_eq
l_int|0
)paren
)paren
)paren
(brace
id|dev-&gt;next
op_assign
(paren
r_struct
id|device
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|device
)paren
op_plus
l_int|8
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
suffix:semicolon
multiline_comment|/* point to the new device */
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eth%d: Device not initialised, insufficient memory&bslash;n&quot;
comma
id|num_eth
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;      ** If the memory was allocated, point to the new memory area&n;      ** and initialize it (name, I/O address, next device (NULL) and&n;      ** initialisation probe routine).&n;      */
id|dev-&gt;name
op_assign
(paren
r_char
op_star
)paren
(paren
id|dev
op_plus
r_sizeof
(paren
r_struct
id|device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_eth
OG
l_int|9999
)paren
(brace
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;eth????&quot;
)paren
suffix:semicolon
multiline_comment|/* New device name */
)brace
r_else
(brace
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;eth%d&quot;
comma
id|num_eth
)paren
suffix:semicolon
multiline_comment|/* New device name */
)brace
id|dev-&gt;base_addr
op_assign
id|iobase
suffix:semicolon
multiline_comment|/* assign the io address */
id|dev-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* mark the end of list */
id|dev-&gt;init
op_assign
op_amp
id|de4x5_probe
suffix:semicolon
multiline_comment|/* initialisation routine */
id|num_de4x5s
op_increment
suffix:semicolon
)brace
)brace
id|ret
op_assign
id|dev
suffix:semicolon
multiline_comment|/* return current struct, or NULL */
multiline_comment|/*&n;  ** Now figure out what to do with the autoprobe that has to be inserted.&n;  ** Firstly, search the (possibly altered) list for an empty space.&n;  */
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|addAutoProbe
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
(paren
id|tmp-&gt;next
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|tmp-&gt;base_addr
op_ne
l_int|0xffe0
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
suffix:semicolon
multiline_comment|/*&n;      ** If no more device structures and can&squot;t use the current one, malloc&n;      ** one up. If memory could not be allocated, print an error message.&n;      */
r_if
c_cond
(paren
(paren
id|tmp-&gt;next
op_eq
l_int|NULL
)paren
op_logical_and
op_logical_neg
(paren
id|tmp-&gt;base_addr
op_eq
l_int|0xffe0
)paren
)paren
(brace
id|tmp-&gt;next
op_assign
(paren
r_struct
id|device
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|device
)paren
op_plus
l_int|8
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
multiline_comment|/* point to the new device */
r_if
c_cond
(paren
id|tmp
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Insufficient memory to extend the device list.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;  ** If the memory was allocated, point to the new memory area&n;&t;  ** and initialize it (name, I/O address, next device (NULL) and&n;&t;  ** initialisation probe routine).&n;&t;  */
id|tmp-&gt;name
op_assign
(paren
r_char
op_star
)paren
(paren
id|tmp
op_plus
r_sizeof
(paren
r_struct
id|device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_eth
OG
l_int|9999
)paren
(brace
id|sprintf
c_func
(paren
id|tmp-&gt;name
comma
l_string|&quot;eth????&quot;
)paren
suffix:semicolon
multiline_comment|/* New device name */
)brace
r_else
(brace
id|sprintf
c_func
(paren
id|tmp-&gt;name
comma
l_string|&quot;eth%d&quot;
comma
id|num_eth
)paren
suffix:semicolon
multiline_comment|/* New device name */
)brace
id|tmp-&gt;base_addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* re-insert the io address */
id|tmp-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* mark the end of list */
id|tmp-&gt;init
op_assign
id|init
suffix:semicolon
multiline_comment|/* initialisation routine */
)brace
)brace
r_else
(brace
multiline_comment|/* structure already exists */
id|tmp-&gt;base_addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* re-insert the io address */
)brace
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;** Auto configure the media here rather than setting the port at compile&n;** time. This routine is called by de4x5_init() when a loss of media is&n;** detected (excessive collisions, loss of carrier, no carrier or link fail&n;** [TP]) to check whether the user has been sneaky and changed the port on us.&n;*/
DECL|function|autoconf_media
r_static
r_int
id|autoconf_media
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|media
comma
id|entry
comma
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_char
id|frame
(braket
l_int|64
)braket
suffix:semicolon
id|u_long
id|i
comma
id|omr
comma
id|sisr
comma
id|linkBad
suffix:semicolon
id|u_long
id|t_330ms
op_assign
l_int|920000
suffix:semicolon
id|u_long
id|t_3s
op_assign
l_int|8000000
suffix:semicolon
multiline_comment|/* Set up for TP port, with LEDs */
id|media
op_assign
id|TP
suffix:semicolon
id|RESET_SIA
suffix:semicolon
id|outl
c_func
(paren
id|SICR_OE57
op_or
id|SICR_SEL
op_or
id|SICR_SRL
comma
id|DE4X5_SICR
)paren
suffix:semicolon
multiline_comment|/* Test the TP port */
r_for
c_loop
(paren
id|linkBad
op_assign
l_int|1
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|t_3s
op_logical_and
id|linkBad
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|sisr
op_assign
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
)paren
op_amp
id|SISR_LKF
)paren
op_eq
l_int|0
)paren
id|linkBad
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sisr
op_amp
id|SISR_NCR
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|linkBad
)paren
(brace
multiline_comment|/* Set up for BNC (Thinwire) port, with LEDs */
id|media
op_assign
id|BNC
suffix:semicolon
id|RESET_SIA
suffix:semicolon
id|outl
c_func
(paren
id|SIGR_JCK
op_or
id|SIGR_HUJ
comma
id|DE4X5_SIGR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|STRR_CLD
op_or
id|STRR_CSQ
op_or
id|STRR_RSQ
op_or
id|STRR_DREN
op_or
id|STRR_ECEN
comma
id|DE4X5_STRR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|SICR_OE57
op_or
id|SICR_OE24
op_or
id|SICR_OE13
op_or
id|SICR_SEL
op_or
id|SICR_AUI
op_or
id|SICR_SRL
comma
id|DE4X5_SICR
)paren
suffix:semicolon
multiline_comment|/* Wait 330ms */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|t_330ms
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sisr
op_assign
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
suffix:semicolon
)brace
multiline_comment|/* Make up a dummy packet with CRC error */
id|create_packet
c_func
(paren
id|dev
comma
id|frame
comma
r_sizeof
(paren
id|frame
)paren
)paren
suffix:semicolon
multiline_comment|/* Setup the packet descriptor */
id|entry
op_assign
id|lp-&gt;tx_new
suffix:semicolon
multiline_comment|/* Remember the ring position */
id|load_packet
c_func
(paren
id|dev
comma
id|frame
comma
id|TD_LS
op_or
id|TD_FS
op_or
id|TD_AC
op_or
r_sizeof
(paren
id|frame
)paren
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Start the TX process */
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|omr
op_or
id|OMR_ST
comma
id|DE4X5_OMR
)paren
suffix:semicolon
multiline_comment|/* Update pointers */
id|lp-&gt;tx_new
op_assign
(paren
op_increment
id|lp-&gt;tx_new
)paren
op_mod
id|lp-&gt;txRingSize
suffix:semicolon
id|lp-&gt;tx_old
op_assign
id|lp-&gt;tx_new
suffix:semicolon
multiline_comment|/* &n;    ** Poll for completion of frame (interrupts are disabled for now)...&n;    ** Allow upto 3 seconds to complete.&n;    */
r_for
c_loop
(paren
id|linkBad
op_assign
l_int|1
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|t_3s
op_logical_and
id|linkBad
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
op_amp
id|SISR_NCR
)paren
op_eq
l_int|1
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|status
op_ge
l_int|0
)paren
id|linkBad
op_assign
l_int|0
suffix:semicolon
)brace
id|outl
c_func
(paren
id|omr
comma
id|DE4X5_OMR
)paren
suffix:semicolon
multiline_comment|/* Stop everything! */
r_if
c_cond
(paren
id|linkBad
op_logical_or
(paren
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|status
op_amp
id|TD_ES
)paren
)paren
(brace
multiline_comment|/* Set up for AUI (Thickwire) port, with LEDs */
id|media
op_assign
id|AUI
suffix:semicolon
id|RESET_SIA
suffix:semicolon
id|outl
c_func
(paren
id|SIGR_JCK
op_or
id|SIGR_HUJ
comma
id|DE4X5_SIGR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|STRR_CLD
op_or
id|STRR_CSQ
op_or
id|STRR_RSQ
op_or
id|STRR_DREN
op_or
id|STRR_ECEN
comma
id|DE4X5_STRR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|SICR_OE57
op_or
id|SICR_SEL
op_or
id|SICR_AUI
op_or
id|SICR_SRL
comma
id|DE4X5_SICR
)paren
suffix:semicolon
multiline_comment|/* Setup the packet descriptor */
id|entry
op_assign
id|lp-&gt;tx_new
suffix:semicolon
multiline_comment|/* Remember the ring position */
id|load_packet
c_func
(paren
id|dev
comma
id|frame
comma
id|TD_LS
op_or
id|TD_FS
op_or
id|TD_AC
op_or
r_sizeof
(paren
id|frame
)paren
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Start the TX process */
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|omr
op_or
id|OMR_ST
comma
id|DE4X5_OMR
)paren
suffix:semicolon
multiline_comment|/* Update pointers */
id|lp-&gt;tx_new
op_assign
(paren
op_increment
id|lp-&gt;tx_new
)paren
op_mod
id|lp-&gt;txRingSize
suffix:semicolon
id|lp-&gt;tx_old
op_assign
id|lp-&gt;tx_new
suffix:semicolon
multiline_comment|/* &n;      ** Poll for completion of frame (interrupts are disabled for now)...&n;      ** Allow 3 seconds to complete.&n;      */
r_for
c_loop
(paren
id|linkBad
op_assign
l_int|1
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|t_3s
op_logical_and
id|linkBad
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
op_amp
id|SISR_NCR
)paren
op_eq
l_int|1
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|status
op_ge
l_int|0
)paren
id|linkBad
op_assign
l_int|0
suffix:semicolon
)brace
id|outl
c_func
(paren
id|omr
comma
id|DE4X5_OMR
)paren
suffix:semicolon
multiline_comment|/* Stop everything! */
r_if
c_cond
(paren
id|linkBad
op_logical_or
(paren
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|status
op_amp
id|TD_ES
)paren
)paren
(brace
multiline_comment|/* Reset the SIA */
id|outl
c_func
(paren
id|SICR_RESET
comma
id|DE4X5_SICR
)paren
suffix:semicolon
multiline_comment|/* Reset SIA connectivity regs */
id|outl
c_func
(paren
id|STRR_RESET
comma
id|DE4X5_STRR
)paren
suffix:semicolon
multiline_comment|/* Write reset values */
id|outl
c_func
(paren
id|SIGR_RESET
comma
id|DE4X5_SIGR
)paren
suffix:semicolon
multiline_comment|/* Write reset values */
id|media
op_assign
id|NC
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|de4x5_debug
op_ge
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Media is %s.&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|media
op_eq
id|NC
ques
c_cond
l_string|&quot;unconnected to this device&quot;
suffix:colon
(paren
id|media
op_eq
id|TP
ques
c_cond
l_string|&quot;TP&quot;
suffix:colon
(paren
id|media
op_eq
id|BNC
ques
c_cond
l_string|&quot;BNC&quot;
suffix:colon
l_string|&quot;AUI&quot;
)paren
)paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|media
)paren
id|lp-&gt;lostMedia
op_assign
l_int|0
suffix:semicolon
r_return
id|media
suffix:semicolon
)brace
multiline_comment|/*&n;** Create an Ethernet packet with an invalid CRC&n;*/
DECL|function|create_packet
r_static
r_void
id|create_packet
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_char
op_star
id|frame
comma
r_int
id|len
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_char
op_star
id|buf
op_assign
id|frame
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Use this source address */
op_star
id|buf
op_increment
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Use this destination address */
op_star
id|buf
op_increment
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
op_ge
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
(brace
multiline_comment|/* Packet length (2 bytes) */
op_star
id|buf
op_increment
op_assign
(paren
r_char
)paren
(paren
(paren
id|len
op_rshift
l_int|8
op_star
id|j
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
op_star
id|buf
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Data */
r_for
c_loop
(paren
id|i
op_assign
id|len
op_minus
l_int|4
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* CRC */
id|buf
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** Look for a particular board name in the EISA configuration space&n;*/
DECL|function|EISA_signature
r_static
r_void
id|EISA_signature
c_func
(paren
r_char
op_star
id|name
comma
r_int
id|iobase
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_char
op_star
id|signatures
(braket
)braket
op_assign
id|DE4X5_SIGNATURE
suffix:semicolon
r_char
id|ManCode
(braket
l_int|8
)braket
suffix:semicolon
r_union
(brace
id|u_long
id|ID
suffix:semicolon
id|u_char
id|Id
(braket
l_int|4
)braket
suffix:semicolon
)brace
id|Eisa
suffix:semicolon
id|strcpy
c_func
(paren
id|name
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|Eisa.ID
op_assign
id|inl
c_func
(paren
id|iobase
)paren
suffix:semicolon
id|ManCode
(braket
l_int|0
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|0
)braket
op_rshift
l_int|2
)paren
op_amp
l_int|0x1f
)paren
op_plus
l_int|0x40
)paren
suffix:semicolon
id|ManCode
(braket
l_int|1
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|1
)braket
op_amp
l_int|0xe0
)paren
op_rshift
l_int|5
)paren
op_plus
(paren
(paren
id|Eisa.Id
(braket
l_int|0
)braket
op_amp
l_int|0x03
)paren
op_lshift
l_int|3
)paren
op_plus
l_int|0x40
)paren
suffix:semicolon
id|ManCode
(braket
l_int|2
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|2
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
op_plus
l_int|0x30
)paren
suffix:semicolon
id|ManCode
(braket
l_int|3
)braket
op_assign
(paren
(paren
id|Eisa.Id
(braket
l_int|2
)braket
op_amp
l_int|0x0f
)paren
op_plus
l_int|0x30
)paren
suffix:semicolon
id|ManCode
(braket
l_int|4
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|3
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
op_plus
l_int|0x30
)paren
suffix:semicolon
id|ManCode
(braket
l_int|5
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_star
id|signatures
(braket
id|i
)braket
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
op_star
id|name
op_eq
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|ManCode
comma
id|signatures
(braket
id|i
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|strcpy
c_func
(paren
id|name
comma
id|ManCode
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
multiline_comment|/* return the device name string */
)brace
multiline_comment|/*&n;** Look for a special sequence in the Ethernet station address PROM that&n;** is common across all DIGITAL network adapter products.&n;*/
DECL|function|DevicePresent
r_static
r_int
id|DevicePresent
c_func
(paren
r_int
id|aprom_addr
)paren
(brace
r_static
r_int
id|fp
op_assign
l_int|1
comma
id|sigLength
op_assign
l_int|0
suffix:semicolon
r_static
r_char
id|devSig
(braket
)braket
op_assign
id|ETH_PROM_SIG
suffix:semicolon
r_char
id|data
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_struct
id|bus_type
op_star
id|lp
op_assign
op_amp
id|bus
suffix:semicolon
r_static
r_char
id|asc2hex
c_func
(paren
r_char
id|value
)paren
suffix:semicolon
multiline_comment|/* &n;** Convert the ascii signature to a hex equivalent &amp; pack in place &n;*/
r_if
c_cond
(paren
id|fp
)paren
(brace
multiline_comment|/* only do this once!... */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|devSig
(braket
id|i
)braket
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
op_logical_neg
id|status
suffix:semicolon
id|i
op_add_assign
l_int|2
comma
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|devSig
(braket
id|i
)braket
op_assign
id|asc2hex
c_func
(paren
id|devSig
(braket
id|i
)braket
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|devSig
(braket
id|i
)braket
op_lshift_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|devSig
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|asc2hex
c_func
(paren
id|devSig
(braket
id|i
op_plus
l_int|1
)braket
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|devSig
(braket
id|j
)braket
op_assign
id|devSig
(braket
id|i
)braket
op_plus
id|devSig
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|sigLength
op_assign
id|j
suffix:semicolon
id|fp
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n;** Search the Ethernet address ROM for the signature. Since the ROM address&n;** counter can start at an arbitrary point, the search must include the entire&n;** probe sequence length plus the (length_of_the_signature - 1).&n;** Stop the search IMMEDIATELY after the signature is found so that the&n;** PROM address counter is correctly positioned at the start of the&n;** ethernet address for later read out.&n;*/
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
r_int
id|tmp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|sigLength
op_logical_and
id|i
OL
id|PROBE_LENGTH
op_plus
id|sigLength
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;bus
op_eq
id|PCI
)paren
(brace
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|inl
c_func
(paren
id|aprom_addr
)paren
)paren
OL
l_int|0
)paren
suffix:semicolon
id|data
op_assign
(paren
r_char
)paren
id|tmp
suffix:semicolon
)brace
r_else
(brace
id|data
op_assign
id|inb
c_func
(paren
id|aprom_addr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|devSig
(braket
id|j
)braket
op_eq
id|data
)paren
(brace
multiline_comment|/* track signature */
id|j
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* lost signature; begin search again */
id|j
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|j
op_ne
id|sigLength
)paren
(brace
id|status
op_assign
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* search failed */
)brace
)brace
r_return
id|status
suffix:semicolon
)brace
DECL|function|aprom_crc
r_static
r_int
id|aprom_crc
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
comma
id|k
comma
id|tmp
suffix:semicolon
r_int
r_int
id|j
comma
id|chksum
suffix:semicolon
r_int
r_char
id|status
op_assign
l_int|0
suffix:semicolon
r_struct
id|bus_type
op_star
id|lp
op_assign
op_amp
id|bus
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|k
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|3
suffix:semicolon
id|j
op_increment
)paren
(brace
id|k
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
l_int|0xffff
)paren
id|k
op_sub_assign
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;bus
op_eq
id|PCI
)paren
(brace
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|inl
c_func
(paren
id|DE4X5_APROM
)paren
)paren
OL
l_int|0
)paren
suffix:semicolon
id|k
op_add_assign
(paren
id|u_char
)paren
id|tmp
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_increment
)braket
op_assign
(paren
id|u_char
)paren
id|tmp
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|inl
c_func
(paren
id|DE4X5_APROM
)paren
)paren
OL
l_int|0
)paren
suffix:semicolon
id|k
op_add_assign
(paren
id|u_short
)paren
(paren
id|tmp
op_lshift
l_int|8
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_increment
)braket
op_assign
(paren
id|u_char
)paren
id|tmp
suffix:semicolon
)brace
r_else
(brace
id|k
op_add_assign
(paren
id|u_char
)paren
(paren
id|tmp
op_assign
id|inb
c_func
(paren
id|EISA_APROM
)paren
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_increment
)braket
op_assign
(paren
id|u_char
)paren
id|tmp
suffix:semicolon
id|k
op_add_assign
(paren
id|u_short
)paren
(paren
(paren
id|tmp
op_assign
id|inb
c_func
(paren
id|EISA_APROM
)paren
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_increment
)braket
op_assign
(paren
id|u_char
)paren
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
OG
l_int|0xffff
)paren
id|k
op_sub_assign
l_int|0xffff
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
op_eq
l_int|0xffff
)paren
id|k
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;bus
op_eq
id|PCI
)paren
(brace
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|inl
c_func
(paren
id|DE4X5_APROM
)paren
)paren
OL
l_int|0
)paren
suffix:semicolon
id|chksum
op_assign
(paren
id|u_char
)paren
id|tmp
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|inl
c_func
(paren
id|DE4X5_APROM
)paren
)paren
OL
l_int|0
)paren
suffix:semicolon
id|chksum
op_or_assign
(paren
id|u_short
)paren
(paren
id|tmp
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
r_else
(brace
id|chksum
op_assign
(paren
id|u_char
)paren
id|inb
c_func
(paren
id|EISA_APROM
)paren
suffix:semicolon
id|chksum
op_or_assign
(paren
id|u_short
)paren
(paren
id|inb
c_func
(paren
id|EISA_APROM
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
op_ne
id|chksum
)paren
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;** Perform IOCTL call functions here. Some are privileged operations and the&n;** effective uid is checked in those cases.&n;*/
DECL|function|de4x5_ioctl
r_static
r_int
id|de4x5_ioctl
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|de4x5_ioctl
op_star
id|ioc
op_assign
(paren
r_struct
id|de4x5_ioctl
op_star
)paren
op_amp
id|rq-&gt;ifr_data
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|iobase
op_assign
id|dev-&gt;base_addr
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|u_long
id|omr
suffix:semicolon
r_union
(brace
r_int
r_char
id|addr
(braket
id|HASH_TABLE_LEN
op_star
id|ETH_ALEN
)braket
suffix:semicolon
r_int
r_int
id|sval
(braket
(paren
id|HASH_TABLE_LEN
op_star
id|ETH_ALEN
)paren
op_rshift
l_int|1
)braket
suffix:semicolon
r_int
r_int
id|lval
(braket
(paren
id|HASH_TABLE_LEN
op_star
id|ETH_ALEN
)paren
op_rshift
l_int|2
)braket
suffix:semicolon
)brace
id|tmp
suffix:semicolon
r_switch
c_cond
(paren
id|ioc-&gt;cmd
)paren
(brace
r_case
id|DE4X5_GET_HWADDR
suffix:colon
multiline_comment|/* Get the hardware address */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp.addr
(braket
id|i
)braket
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
)brace
id|ioc-&gt;len
op_assign
id|ETH_ALEN
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|ioc-&gt;data
comma
id|tmp.addr
comma
id|ioc-&gt;len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DE4X5_SET_HWADDR
suffix:colon
multiline_comment|/* Set the hardware address */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
r_int
id|offset
suffix:semicolon
r_char
op_star
id|pa
suffix:semicolon
id|u_long
id|omr
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
id|tmp.addr
comma
id|ioc-&gt;data
comma
id|ETH_ALEN
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|tmp.addr
(braket
id|i
)braket
suffix:semicolon
)brace
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|omr
op_amp
id|OMR_HP
)paren
(brace
id|offset
op_assign
id|IMPERF_PA_OFFSET
suffix:semicolon
)brace
r_else
(brace
id|offset
op_assign
id|PERF_PA_OFFSET
suffix:semicolon
)brace
multiline_comment|/* Insert the physical address */
r_for
c_loop
(paren
id|pa
op_assign
id|lp-&gt;setup_frame
op_plus
id|offset
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
(paren
id|pa
op_plus
id|i
)paren
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
l_int|0x01
)paren
id|pa
op_add_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/* Set up the descriptor and give ownership to the card */
r_while
c_loop
(paren
id|set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|dev-&gt;tbusy
)paren
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Wait for lock to free */
id|load_packet
c_func
(paren
id|dev
comma
id|lp-&gt;setup_frame
comma
id|TD_IC
op_or
id|HASH_F
op_or
id|TD_SET
op_or
id|SETUP_FRAME_LEN
comma
l_int|NULL
)paren
suffix:semicolon
id|lp-&gt;tx_new
op_assign
(paren
op_increment
id|lp-&gt;tx_new
)paren
op_mod
id|lp-&gt;txRingSize
suffix:semicolon
id|outl
c_func
(paren
id|POLL_DEMAND
comma
id|DE4X5_TPD
)paren
suffix:semicolon
multiline_comment|/* Start the TX */
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Unlock the TX ring */
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DE4X5_SET_PROM
suffix:colon
multiline_comment|/* Set Promiscuous Mode */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
id|omr
op_or_assign
id|OMR_PR
suffix:semicolon
id|omr
op_and_assign
op_complement
id|OMR_PM
suffix:semicolon
id|outl
c_func
(paren
id|omr
comma
id|DE4X5_OMR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DE4X5_CLR_PROM
suffix:colon
multiline_comment|/* Clear Promiscuous Mode */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
id|omr
op_and_assign
op_complement
id|OMR_PR
suffix:semicolon
id|outb
c_func
(paren
id|omr
comma
id|DE4X5_OMR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DE4X5_SAY_BOO
suffix:colon
multiline_comment|/* Say &quot;Boo!&quot; to the kernel log file */
id|printk
c_func
(paren
l_string|&quot;%s: Boo!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DE4X5_GET_MCA
suffix:colon
multiline_comment|/* Get the multicast address table */
id|ioc-&gt;len
op_assign
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|ioc-&gt;data
comma
id|lp-&gt;setup_frame
comma
l_int|192
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DE4X5_SET_MCA
suffix:colon
multiline_comment|/* Set a multicast address */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|ioc-&gt;len
op_ne
id|HASH_TABLE_LEN
)paren
(brace
multiline_comment|/* MCA changes */
id|memcpy_fromfs
c_func
(paren
id|tmp.addr
comma
id|ioc-&gt;data
comma
id|ETH_ALEN
op_star
id|ioc-&gt;len
)paren
suffix:semicolon
)brace
id|set_multicast_list
c_func
(paren
id|dev
comma
id|ioc-&gt;len
comma
id|tmp.addr
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DE4X5_CLR_MCA
suffix:colon
multiline_comment|/* Clear all multicast addresses */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
id|set_multicast_list
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DE4X5_MCA_EN
suffix:colon
multiline_comment|/* Enable multicast addressing */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
id|omr
op_or_assign
id|OMR_PM
suffix:semicolon
id|omr
op_and_assign
op_complement
id|OMR_PR
suffix:semicolon
id|outl
c_func
(paren
id|omr
comma
id|DE4X5_OMR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DE4X5_GET_STATS
suffix:colon
multiline_comment|/* Get the driver statistics */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|ioc-&gt;data
comma
op_amp
id|lp-&gt;pktStats
comma
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
)paren
suffix:semicolon
id|ioc-&gt;len
op_assign
id|DE4X5_PKT_STAT_SZ
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DE4X5_CLR_STATS
suffix:colon
multiline_comment|/* Zero out the driver statistics */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|lp-&gt;pktStats
comma
l_int|0
comma
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DE4X5_GET_OMR
suffix:colon
multiline_comment|/* Get the OMR Register contents */
id|tmp.addr
(braket
l_int|0
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|ioc-&gt;data
comma
id|tmp.addr
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DE4X5_SET_OMR
suffix:colon
multiline_comment|/* Set the OMR Register contents */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
id|memcpy_fromfs
c_func
(paren
id|tmp.addr
comma
id|ioc-&gt;data
comma
l_int|1
)paren
suffix:semicolon
id|outl
c_func
(paren
id|tmp.addr
(braket
l_int|0
)braket
comma
id|DE4X5_OMR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DE4X5_GET_REG
suffix:colon
multiline_comment|/* Get the DE4X5 Registers */
id|tmp.lval
(braket
l_int|0
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_STS
)paren
suffix:semicolon
id|tmp.lval
(braket
l_int|1
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_BMR
)paren
suffix:semicolon
id|tmp.lval
(braket
l_int|2
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_IMR
)paren
suffix:semicolon
id|tmp.lval
(braket
l_int|3
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
id|tmp.lval
(braket
l_int|4
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
suffix:semicolon
id|tmp.lval
(braket
l_int|5
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_SICR
)paren
suffix:semicolon
id|tmp.lval
(braket
l_int|6
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_STRR
)paren
suffix:semicolon
id|tmp.lval
(braket
l_int|7
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_SIGR
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|ioc-&gt;data
comma
id|tmp.addr
comma
l_int|32
)paren
suffix:semicolon
r_break
suffix:semicolon
DECL|macro|DE4X5_DUMP
mdefine_line|#define DE4X5_DUMP              0x0f /* Dump the DE4X5 Status */
r_case
id|DE4X5_DUMP
suffix:colon
id|j
op_assign
l_int|0
suffix:semicolon
id|tmp.addr
(braket
id|j
op_increment
)braket
op_assign
id|dev-&gt;irq
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp.addr
(braket
id|j
op_increment
)braket
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
)brace
id|tmp.addr
(braket
id|j
op_increment
)braket
op_assign
id|lp-&gt;rxRingSize
suffix:semicolon
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
id|eisa_slots_full
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
(paren
r_int
)paren
id|lp-&gt;rx_ring
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
(paren
r_int
)paren
id|lp-&gt;tx_ring
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;rxRingSize
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|3
)paren
(brace
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
(paren
r_int
)paren
op_amp
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
)brace
)brace
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
(paren
r_int
)paren
op_amp
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;txRingSize
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|3
)paren
(brace
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
(paren
r_int
)paren
op_amp
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|status
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
)brace
)brace
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
(paren
r_int
)paren
op_amp
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|status
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;rxRingSize
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|3
)paren
(brace
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
(paren
r_int
)paren
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|buf
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
)brace
)brace
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
(paren
r_int
)paren
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|buf
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;txRingSize
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|3
)paren
(brace
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
(paren
r_int
)paren
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|buf
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
)brace
)brace
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
(paren
r_int
)paren
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|buf
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;rxRingSize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;txRingSize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|status
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
)brace
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_STS
)paren
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_BMR
)paren
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_IMR
)paren
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_SICR
)paren
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_STRR
)paren
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
id|tmp.lval
(braket
id|j
op_rshift
l_int|2
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_SIGR
)paren
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
id|tmp.addr
(braket
id|j
op_increment
)braket
op_assign
id|lp-&gt;txRingSize
suffix:semicolon
id|tmp.addr
(braket
id|j
op_increment
)braket
op_assign
id|dev-&gt;tbusy
suffix:semicolon
id|ioc-&gt;len
op_assign
id|j
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|ioc-&gt;data
comma
id|tmp.addr
comma
id|ioc-&gt;len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|status
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
DECL|function|asc2hex
r_static
r_char
id|asc2hex
c_func
(paren
r_char
id|value
)paren
(brace
id|value
op_sub_assign
l_int|0x30
suffix:semicolon
multiline_comment|/* normalise to 0..9 range */
r_if
c_cond
(paren
id|value
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|value
OG
l_int|9
)paren
(brace
multiline_comment|/* but may not be 10..15 */
id|value
op_and_assign
l_int|0x1f
suffix:semicolon
multiline_comment|/* make A..F &amp; a..f be the same */
id|value
op_sub_assign
l_int|0x07
suffix:semicolon
multiline_comment|/* normalise to 10..15 range */
r_if
c_cond
(paren
(paren
id|value
OL
l_int|0x0a
)paren
op_logical_or
(paren
id|value
OG
l_int|0x0f
)paren
)paren
(brace
multiline_comment|/* if outside range then... */
id|value
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* ...signal error */
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* outside 0..9 range... */
id|value
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* ...signal error */
)brace
r_return
id|value
suffix:semicolon
multiline_comment|/* return hex char or error */
)brace
macro_line|#ifdef MODULE
DECL|variable|kernel_version
r_char
id|kernel_version
(braket
)braket
op_assign
id|UTS_RELEASE
suffix:semicolon
DECL|variable|thisDE4X5
r_static
r_struct
id|device
id|thisDE4X5
op_assign
(brace
l_string|&quot;        &quot;
comma
multiline_comment|/* device name inserted by /linux/drivers/net/net_init.c */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0x2000
comma
l_int|10
comma
multiline_comment|/* I/O address, IRQ */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|de4x5_probe
)brace
suffix:semicolon
DECL|variable|io
r_int
id|io
op_assign
l_int|0x2000
suffix:semicolon
multiline_comment|/* &lt;--- EDIT THESE LINES FOR YOUR CONFIGURATION */
DECL|variable|irq
r_int
id|irq
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* or use the insmod io= irq= options &t;&t;*/
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
id|thisDE4X5.base_addr
op_assign
id|io
suffix:semicolon
id|thisDE4X5.irq
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
op_amp
id|thisDE4X5
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|MOD_IN_USE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: device busy, remove delayed&bslash;n&quot;
comma
id|thisDE4X5.name
)paren
suffix:semicolon
)brace
r_else
(brace
id|unregister_netdev
c_func
(paren
op_amp
id|thisDE4X5
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* MODULE */
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  kernel-compile-command: &quot;gcc -D__KERNEL__ -I/usr/src/linux/net/inet -Wall -Wstrict-prototypes -O2 -m486 -c de4x5.c&quot;&n; *&n; *  module-compile-command: &quot;gcc -D__KERNEL__ -DMODULE -I/usr/src/linux/net/inet -Wall -Wstrict-prototypes -O2 -m486 -c de4x5.c&quot;&n; * End:&n; */
eof
