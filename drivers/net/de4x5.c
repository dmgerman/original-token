multiline_comment|/*  de4x5.c: A DIGITAL DC21x4x DECchip and DE425/DE434/DE435/DE450/DE500&n;             ethernet driver for Linux.&n;&n;    Copyright 1994, 1995 Digital Equipment Corporation.&n;&n;    Testing resources for this driver have been made available&n;    in part by NASA Ames Research Center (mjacob@nas.nasa.gov).&n;&n;    The author may be reached at davies@maniac.ultranet.com.&n;&n;    This program is free software; you can redistribute  it and/or modify it&n;    under  the terms of  the GNU General  Public License as published by the&n;    Free Software Foundation;  either version 2 of the  License, or (at your&n;    option) any later version.&n;&n;    THIS  SOFTWARE  IS PROVIDED   ``AS  IS&squot;&squot; AND   ANY  EXPRESS OR   IMPLIED&n;    WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF&n;    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN&n;    NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT,  INDIRECT,&n;    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT&n;    NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF&n;    USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON&n;    ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT&n;    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF&n;    THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.&n;&n;    You should have received a copy of the  GNU General Public License along&n;    with this program; if not, write  to the Free Software Foundation, Inc.,&n;    675 Mass Ave, Cambridge, MA 02139, USA.&n;&n;    Originally,   this  driver  was    written  for the  Digital   Equipment&n;    Corporation series of EtherWORKS ethernet cards:&n;&n;        DE425 TP/COAX EISA&n;&t;DE434 TP PCI&n;&t;DE435 TP/COAX/AUI PCI&n;&t;DE450 TP/COAX/AUI PCI&n;&t;DE500 10/100 PCI Fasternet&n;&n;    but it  will  now attempt  to  support all  cards which   conform to the&n;    Digital Semiconductor   SROM   Specification.    The  driver   currently&n;    recognises the following chips:&n;&n;        DC21040  (no SROM) &n;&t;DC21041[A]  &n;&t;DC21140[A] &n;&t;DC21142 &n;&t;DC21143 &n;&n;    So far the driver is known to work with the following cards:&n;&n;        KINGSTON&n;&t;Linksys&n;&t;ZNYX342&n;&t;SMC8432&n;&t;SMC9332 (w/new SROM)&n;&t;ZNYX31[45]&n;&t;ZNYX346 10/100 4 port (can act as a 10/100 bridge!) &n;&n;    The driver has been tested on a relatively busy network using the DE425,&n;    DE434, DE435 and DE500 cards and benchmarked with &squot;ttcp&squot;: it transferred&n;    16M of data to a DECstation 5000/200 as follows:&n;&n;                TCP           UDP&n;             TX     RX     TX     RX&n;    DE425   1030k  997k   1170k  1128k&n;    DE434   1063k  995k   1170k  1125k&n;    DE435   1063k  995k   1170k  1125k&n;    DE500   1063k  998k   1170k  1125k  in 10Mb/s mode&n;&n;    All  values are typical (in   kBytes/sec) from a  sample  of 4 for  each&n;    measurement. Their error is +/-20k on a quiet (private) network and also&n;    depend on what load the CPU has.&n;&n;    =========================================================================&n;    This driver  has been written substantially  from  scratch, although its&n;    inheritance of style and stack interface from &squot;ewrk3.c&squot; and in turn from&n;    Donald Becker&squot;s &squot;lance.c&squot; should be obvious. With the module autoload of&n;    every  usable DECchip board,  I  pinched Donald&squot;s &squot;next_module&squot; field to&n;    link my modules together.&n;&n;    Upto 15 EISA cards can be supported under this driver, limited primarily&n;    by the available IRQ lines.  I have  checked different configurations of&n;    multiple depca, EtherWORKS 3 cards and de4x5 cards and  have not found a&n;    problem yet (provided you have at least depca.c v0.38) ...&n;&n;    PCI support has been added  to allow the driver  to work with the DE434,&n;    DE435, DE450 and DE500 cards. The I/O accesses are a bit of a kludge due&n;    to the differences in the EISA and PCI CSR address offsets from the base&n;    address.&n;&n;    The ability to load this  driver as a loadable  module has been included&n;    and used extensively  during the driver development  (to save those long&n;    reboot sequences).  Loadable module support  under PCI and EISA has been&n;    achieved by letting the driver autoprobe as if it were compiled into the&n;    kernel. Do make sure  you&squot;re not sharing  interrupts with anything  that&n;    cannot accommodate  interrupt  sharing!&n;&n;    To utilise this ability, you have to do 8 things:&n;&n;    0) have a copy of the loadable modules code installed on your system.&n;    1) copy de4x5.c from the  /linux/drivers/net directory to your favourite&n;    temporary directory.&n;    2) for fixed  autoprobes (not  recommended),  edit the source code  near&n;    line 5594 to reflect the I/O address  you&squot;re using, or assign these when&n;    loading by:&n;&n;                   insmod de4x5 io=0xghh           where g = bus number&n;&t;&t;                                        hh = device number   &n;&n;       NB: autoprobing for modules is now supported by default. You may just&n;           use:&n;&n;                   insmod de4x5&n;&n;           to load all available boards. For a specific board, still use&n;&t;   the &squot;io=?&squot; above.&n;    3) compile  de4x5.c, but include -DMODULE in  the command line to ensure&n;    that the correct bits are compiled (see end of source code).&n;    4) if you are wanting to add a new  card, goto 5. Otherwise, recompile a&n;    kernel with the de4x5 configuration turned off and reboot.&n;    5) insmod de4x5 [io=0xghh]&n;    6) run the net startup bits for your new eth?? interface(s) manually &n;    (usually /etc/rc.inet[12] at boot time). &n;    7) enjoy!&n;&n;    To unload a module, turn off the associated interface(s) &n;    &squot;ifconfig eth?? down&squot; then &squot;rmmod de4x5&squot;.&n;&n;    Automedia detection is included so that in  principal you can disconnect&n;    from, e.g.  TP, reconnect  to BNC  and  things will still work  (after a&n;    pause whilst the   driver figures out   where its media went).  My tests&n;    using ping showed that it appears to work....&n;&n;    By  default,  the driver will  now   autodetect any  DECchip based card.&n;    Should you have a need to restrict the driver to DIGITAL only cards, you&n;    can compile with a  DEC_ONLY define, or if  loading as a module, use the&n;    &squot;dec_only=1&squot;  parameter. &n;&n;    I&squot;ve changed the timing routines to  use the kernel timer and scheduling&n;    functions  so that the  hangs  and other assorted problems that occurred&n;    while autosensing the  media  should be gone.  A  bonus  for the DC21040&n;    auto  media sense algorithm is  that it can now  use one that is more in&n;    line with the  rest (the DC21040  chip doesn&squot;t  have a hardware  timer).&n;    The downside is the 1 &squot;jiffies&squot; (10ms) resolution.&n;&n;    IEEE 802.3u MII interface code has  been added in anticipation that some&n;    products may use it in the future.&n;&n;    The SMC9332 card  has a non-compliant SROM  which needs fixing -  I have&n;    patched this  driver to detect it  because the SROM format used complies&n;    to a previous DEC-STD format.&n;&n;    I have removed the buffer copies needed for receive on Intels.  I cannot&n;    remove them for   Alphas since  the  Tulip hardware   only does longword&n;    aligned  DMA transfers  and  the  Alphas get   alignment traps with  non&n;    longword aligned data copies (which makes them really slow). No comment.&n;&n;    I  have added SROM decoding  routines to make this  driver work with any&n;    card that  supports the Digital  Semiconductor SROM spec. This will help&n;    all  cards running the dc2114x  series chips in particular.  Cards using&n;    the dc2104x  chips should run correctly with  the basic  driver.  I&squot;m in&n;    debt to &lt;mjacob@feral.com&gt; for the  testing and feedback that helped get&n;    this feature working.  So far we have  tested KINGSTON, SMC8432, SMC9332&n;    (with the latest SROM complying  with the SROM spec  V3: their first was&n;    broken), ZNYX342  and  LinkSys. ZYNX314 (dual  21041  MAC) and  ZNYX 315&n;    (quad 21041 MAC)  cards also  appear  to work despite their  incorrectly&n;    wired IRQs.&n;&n;    I have added a temporary fix for interrupt problems when some SCSI cards&n;    share the same interrupt as the DECchip based  cards. The problem occurs&n;    because  the SCSI card wants to  grab the interrupt  as a fast interrupt&n;    (runs the   service routine with interrupts turned   off) vs.  this card&n;    which really needs to run the service routine with interrupts turned on.&n;    This driver will  now   add the interrupt service   routine  as  a  fast&n;    interrupt if it   is bounced from the   slow interrupt.  THIS IS NOT   A&n;    RECOMMENDED WAY TO RUN THE DRIVER  and has been done  for a limited time&n;    until  people   sort  out their  compatibility    issues and the  kernel&n;    interrupt  service code  is  fixed.   YOU  SHOULD SEPARATE OUT  THE FAST&n;    INTERRUPT CARDS FROM THE SLOW INTERRUPT CARDS to ensure that they do not&n;    run on the same interrupt. PCMCIA/CardBus is another can of worms...&n;&n;    Finally, I think  I have really  fixed  the module  loading problem with&n;    more than one DECchip based  card.  As a  side effect, I don&squot;t mess with&n;    the  device structure any  more which means that  if more than 1 card in&n;    2.0.x is    installed (4  in   2.1.x),  the  user   will have   to  edit&n;    linux/drivers/net/Space.c  to make room for  them. Hence, module loading&n;    is  the preferred way to use   this driver, since  it  doesn&squot;t have this&n;    limitation.&n;&n;    Where SROM media  detection is used and  full duplex is specified in the&n;    SROM,  the feature is  ignored unless  lp-&gt;params.fdx  is set at compile&n;    time  OR during  a   module load  (insmod  de4x5   args=&squot;eth??:fdx&squot; [see&n;    below]).  This is because there  is no way  to automatically detect full&n;    duplex   links  except through   autonegotiation.    When I  include the&n;    autonegotiation feature in  the SROM autoconf  code, this detection will&n;    occur automatically for that case.&n;&n;    Command  line arguments are  now  allowed, similar  to passing arguments&n;    through LILO. This will allow a per adapter board  set up of full duplex&n;    and media. The only lexical constraints  are: the board name (dev-&gt;name)&n;    appears in the list before its  parameters.  The list of parameters ends&n;    either at the end of the parameter list or with another board name.  The&n;    following parameters are allowed:&n;&n;            fdx        for full duplex&n;&t;    autosense  to set the media/speed; with the following &n;&t;               sub-parameters:&n;&t;&t;       TP, TP_NW, BNC, AUI, BNC_AUI, 100Mb, 10Mb, AUTO&n;&n;    Case sensitivity is important  for  the sub-parameters. They *must*   be&n;    upper case. Examples:&n;&n;        insmod de4x5 args=&squot;eth1:fdx autosense=BNC eth0:autosense=100Mb&squot;.&n;&n;    For a compiled in driver, at or above line 548, place e.g.&n;&t;#define DE4X5_PARM &quot;eth0:fdx autosense=AUI eth2:autosense=TP&quot;&n;&n;    Yes,  I know full duplex isn&squot;t  permissible on BNC  or AUI; they&squot;re just&n;    examples. By default, full duplex is turned off and  AUTO is the default&n;    autosense setting.  In reality, I expect only  the full duplex option to&n;    be used. Note the use of single quotes in the two examples above and the&n;    lack of commas to separate items. ALSO, you must get the requested media&n;    correct in relation to what the adapter SROM says it has. There&squot;s no way&n;    to  determine this in  advance other than by  trial and error and common&n;    sense, e.g. call a BNC connectored port &squot;BNC&squot;, not &squot;10Mb&squot;.&n;&n;    Changed the bus probing.  EISA used to be  done first,  followed by PCI.&n;    Most people probably don&squot;t even know  what a de425 is today and the EISA&n;    probe has messed  up some SCSI cards  in the past,  so now PCI is always&n;    probed  first  followed by  EISA if  a) the architecture allows EISA and&n;    either  b) there have been no PCI cards detected or  c) an EISA probe is&n;    forced by  the user.  To force  a probe  include  &quot;force_eisa&quot;  in  your&n;    insmod &quot;args&quot; line;  for built-in kernels either change the driver to do&n;    this  automatically  or include  #define DE4X5_FORCE_EISA  on or  before&n;    line 1040 in the driver.&n;&n;    TO DO: &n;    ------&n;&n;    Revision History&n;    ----------------&n;&n;    Version   Date        Description&n;  &n;      0.1     17-Nov-94   Initial writing. ALPHA code release.&n;      0.2     13-Jan-95   Added PCI support for DE435&squot;s.&n;      0.21    19-Jan-95   Added auto media detection.&n;      0.22    10-Feb-95   Fix interrupt handler call &lt;chris@cosy.sbg.ac.at&gt;.&n;                          Fix recognition bug reported by &lt;bkm@star.rl.ac.uk&gt;.&n;&t;&t;&t;  Add request/release_region code.&n;&t;&t;&t;  Add loadable modules support for PCI.&n;&t;&t;&t;  Clean up loadable modules support.&n;      0.23    28-Feb-95   Added DC21041 and DC21140 support. &n;                          Fix missed frame counter value and initialisation.&n;&t;&t;&t;  Fixed EISA probe.&n;      0.24    11-Apr-95   Change delay routine to use &lt;linux/udelay&gt;.&n;                          Change TX_BUFFS_AVAIL macro.&n;&t;&t;&t;  Change media autodetection to allow manual setting.&n;&t;&t;&t;  Completed DE500 (DC21140) support.&n;      0.241   18-Apr-95   Interim release without DE500 Autosense Algorithm.&n;      0.242   10-May-95   Minor changes.&n;      0.30    12-Jun-95   Timer fix for DC21140.&n;                          Portability changes.&n;&t;&t;&t;  Add ALPHA changes from &lt;jestabro@ant.tay1.dec.com&gt;.&n;&t;&t;&t;  Add DE500 semi automatic autosense.&n;&t;&t;&t;  Add Link Fail interrupt TP failure detection.&n;&t;&t;&t;  Add timer based link change detection.&n;&t;&t;&t;  Plugged a memory leak in de4x5_queue_pkt().&n;      0.31    13-Jun-95   Fixed PCI stuff for 1.3.1.&n;      0.32    26-Jun-95   Added verify_area() calls in de4x5_ioctl() from a&n;                          suggestion by &lt;heiko@colossus.escape.de&gt;.&n;      0.33     8-Aug-95   Add shared interrupt support (not released yet).&n;      0.331   21-Aug-95   Fix de4x5_open() with fast CPUs.&n;                          Fix de4x5_interrupt().&n;                          Fix dc21140_autoconf() mess.&n;&t;&t;&t;  No shared interrupt support.&n;      0.332   11-Sep-95   Added MII management interface routines.&n;      0.40     5-Mar-96   Fix setup frame timeout &lt;maartenb@hpkuipc.cern.ch&gt;.&n;                          Add kernel timer code (h/w is too flaky).&n;&t;&t;&t;  Add MII based PHY autosense.&n;&t;&t;&t;  Add new multicasting code.&n;&t;&t;&t;  Add new autosense algorithms for media/mode &n;&t;&t;&t;  selection using kernel scheduling/timing.&n;&t;&t;&t;  Re-formatted.&n;&t;&t;&t;  Made changes suggested by &lt;jeff@router.patch.net&gt;:&n;&t;&t;&t;    Change driver to detect all DECchip based cards&n;&t;&t;&t;    with DEC_ONLY restriction a special case.&n;&t;&t;&t;    Changed driver to autoprobe as a module. No irq&n;&t;&t;&t;    checking is done now - assume BIOS is good!&n;&t;&t;&t;  Added SMC9332 detection &lt;manabe@Roy.dsl.tutics.ac.jp&gt;&n;      0.41    21-Mar-96   Don&squot;t check for get_hw_addr checksum unless DEC card&n;                          only &lt;niles@axp745gsfc.nasa.gov&gt;&n;&t;&t;&t;  Fix for multiple PCI cards reported by &lt;jos@xos.nl&gt;&n;&t;&t;&t;  Duh, put the SA_SHIRQ flag into request_interrupt().&n;&t;&t;&t;  Fix SMC ethernet address in enet_det[].&n;&t;&t;&t;  Print chip name instead of &quot;UNKNOWN&quot; during boot.&n;      0.42    26-Apr-96   Fix MII write TA bit error.&n;                          Fix bug in dc21040 and dc21041 autosense code.&n;&t;&t;&t;  Remove buffer copies on receive for Intels.&n;&t;&t;&t;  Change sk_buff handling during media disconnects to&n;&t;&t;&t;   eliminate DUP packets.&n;&t;&t;&t;  Add dynamic TX thresholding.&n;&t;&t;&t;  Change all chips to use perfect multicast filtering.&n;&t;&t;&t;  Fix alloc_device() bug &lt;jari@markkus2.fimr.fi&gt;&n;      0.43   21-Jun-96    Fix unconnected media TX retry bug.&n;                          Add Accton to the list of broken cards.&n;&t;&t;&t;  Fix TX under-run bug for non DC21140 chips.&n;&t;&t;&t;  Fix boot command probe bug in alloc_device() as&n;&t;&t;&t;   reported by &lt;koen.gadeyne@barco.com&gt; and &n;&t;&t;&t;   &lt;orava@nether.tky.hut.fi&gt;.&n;&t;&t;&t;  Add cache locks to prevent a race condition as&n;&t;&t;&t;   reported by &lt;csd@microplex.com&gt; and &n;&t;&t;&t;   &lt;baba@beckman.uiuc.edu&gt;.&n;&t;&t;&t;  Upgraded alloc_device() code.&n;      0.431  28-Jun-96    Fix potential bug in queue_pkt() from discussion&n;                          with &lt;csd@microplex.com&gt;&n;      0.44   13-Aug-96    Fix RX overflow bug in 2114[023] chips.&n;                          Fix EISA probe bugs reported by &lt;os2@kpi.kharkov.ua&gt;&n;&t;&t;&t;  and &lt;michael@compurex.com&gt;.&n;      0.441   9-Sep-96    Change dc21041_autoconf() to probe quiet BNC media&n;                           with a loopback packet.&n;      0.442   9-Sep-96    Include AUI in dc21041 media printout. Bug reported&n;                           by &lt;bhat@mundook.cs.mu.OZ.AU&gt;&n;      0.45    8-Dec-96    Include endian functions for PPC use, from work &n;                           by &lt;cort@cs.nmt.edu&gt; and &lt;g.thomas@opengroup.org&gt;.&n;      0.451  28-Dec-96    Added fix to allow autoprobe for modules after&n;                           suggestion from &lt;mjacob@feral.com&gt;.&n;      0.5    30-Jan-97    Added SROM decoding functions.&n;                          Updated debug flags.&n;&t;&t;&t;  Fix sleep/wakeup calls for PCI cards, bug reported&n;&t;&t;&t;   by &lt;cross@gweep.lkg.dec.com&gt;.&n;&t;&t;&t;  Added multi-MAC, one SROM feature from discussion&n;&t;&t;&t;   with &lt;mjacob@feral.com&gt;.&n;&t;&t;&t;  Added full module autoprobe capability.&n;&t;&t;&t;  Added attempt to use an SMC9332 with broken SROM.&n;&t;&t;&t;  Added fix for ZYNX multi-mac cards that didn&squot;t&n;&t;&t;&t;   get their IRQs wired correctly.&n;      0.51   13-Feb-97    Added endian fixes for the SROM accesses from&n;&t;&t;&t;   &lt;paubert@iram.es&gt;&n;&t;&t;&t;  Fix init_connection() to remove extra device reset.&n;&t;&t;&t;  Fix MAC/PHY reset ordering in dc21140m_autoconf().&n;&t;&t;&t;  Fix initialisation problem with lp-&gt;timeout in&n;&t;&t;&t;   typeX_infoblock() from &lt;paubert@iram.es&gt;.&n;&t;&t;&t;  Fix MII PHY reset problem from work done by&n;&t;&t;&t;   &lt;paubert@iram.es&gt;.&n;      0.52   26-Apr-97    Some changes may not credit the right people -&n;                           a disk crash meant I lost some mail.&n;&t;&t;&t;  Change RX interrupt routine to drop rather than &n;&t;&t;&t;   defer packets to avoid hang reported by &n;&t;&t;&t;   &lt;g.thomas@opengroup.org&gt;.&n;&t;&t;&t;  Fix srom_exec() to return for COMPACT and type 1&n;&t;&t;&t;   infoblocks.&n;&t;&t;&t;  Added DC21142 and DC21143 functions.&n;&t;&t;&t;  Added byte counters from &lt;phil@tazenda.demon.co.uk&gt;&n;&t;&t;&t;  Added SA_INTERRUPT temporary fix from &n;&t;&t;&t;   &lt;mjacob@feral.com&gt;.&n;      0.53   12-Nov-97    Fix the *_probe() to include &squot;eth??&squot; name during&n;                           module load: bug reported by&n;&t;&t;&t;   &lt;Piete.Brooks@cl.cam.ac.uk&gt;&n;&t;&t;&t;  Fix multi-MAC, one SROM, to work with 2114x chips:&n;&t;&t;&t;   bug reported by &lt;cmetz@inner.net&gt;.&n;&t;&t;&t;  Make above search independent of BIOS device scan&n;&t;&t;&t;   direction.&n;&t;&t;&t;  Completed DC2114[23] autosense functions.&n;      0.531  21-Dec-97    Fix DE500-XA 100Mb/s bug reported by &n;                           &lt;robin@intercore.com&n;&t;&t;&t;  Fix type1_infoblock() bug introduced in 0.53, from&n;&t;&t;&t;   problem reports by &n;&t;&t;&t;   &lt;parmee@postecss.ncrfran.france.ncr.com&gt; and&n;&t;&t;&t;   &lt;jo@ice.dillingen.baynet.de&gt;.&n;&t;&t;&t;  Added argument list to set up each board from either&n;&t;&t;&t;   a module&squot;s command line or a compiled in #define.&n;&t;&t;&t;  Added generic MII PHY functionality to deal with&n;&t;&t;&t;   newer PHY chips.&n;&t;&t;&t;  Fix the mess in 2.1.67.&n;      0.532   5-Jan-98    Fix bug in mii_get_phy() reported by &n;                           &lt;redhat@cococo.net&gt;.&n;                          Fix bug in pci_probe() for 64 bit systems reported&n;&t;&t;&t;   by &lt;belliott@accessone.com&gt;.&n;      0.533   9-Jan-98    Fix more 64 bit bugs reported by &lt;jal@cs.brown.edu&gt;.&n;      0.534  24-Jan-98    Fix last (?) endian bug from &lt;geert@linux-m68k.org&gt;&n;      0.535  21-Feb-98    Fix Ethernet Address PROM reset bug for DC21040.&n;      0.536  21-Mar-98    Change pci_probe() to use the pci_dev structure.&n;&t;&t;&t;  **Incompatible with 2.0.x from here.**&n;      0.540   5-Jul-98    Atomicize assertion of dev-&gt;interrupt for SMP&n;                           from &lt;lma@varesearch.com&gt;&n;&t;&t;&t;  Add TP, AUI and BNC cases to 21140m_autoconf() for&n;&t;&t;&t;   case where a 21140 under SROM control uses, e.g. AUI&n;&t;&t;&t;   from problem report by &lt;delchini@lpnp09.in2p3.fr&gt;&n;&t;&t;&t;  Add MII parallel detection to 2114x_autoconf() for&n;&t;&t;&t;   case where no autonegotiation partner exists from&n;&t;&t;&t;   problem report by &lt;mlapsley@ndirect.co.uk&gt;.&n;&t;&t;&t;  Add ability to force connection type directly even&n;&t;&t;&t;   when using SROM control from problem report by&n;&t;&t;&t;   &lt;earl@exis.net&gt;.&n;&t;&t;&t;  Updated the PCI interface to conform with the latest&n;&t;&t;&t;   version. I hope nothing is broken...&n;          &t;&t;  Add TX done interrupt modification from suggestion&n;&t;&t;&t;   by &lt;Austin.Donnelly@cl.cam.ac.uk&gt;.&n;&t;&t;&t;  Fix is_anc_capable() bug reported by &n;&t;&t;&t;   &lt;Austin.Donnelly@cl.cam.ac.uk&gt;.&n;&t;&t;&t;  Fix type[13]_infoblock() bug: during MII search, PHY&n;&t;&t;&t;   lp-&gt;rst not run because lp-&gt;ibn not initialised -&n;&t;&t;&t;   from report &amp; fix by &lt;paubert@iram.es&gt;.&n;&t;&t;&t;  Fix probe bug with EISA &amp; PCI cards present from&n;                           report by &lt;eirik@netcom.com&gt;.&n;      0.541  24-Aug-98    Fix compiler problems associated with i386-string&n;                           ops from multiple bug reports and temporary fix&n;&t;&t;&t;   from &lt;paubert@iram.es&gt;.&n;&t;&t;&t;  Fix pci_probe() to correctly emulate the old&n;&t;&t;&t;   pcibios_find_class() function.&n;&t;&t;&t;  Add an_exception() for old ZYNX346 and fix compile&n;&t;&t;&t;   warning on PPC &amp; SPARC, from &lt;ecd@skynet.be&gt;.&n;&t;&t;&t;  Fix lastPCI to correctly work with compiled in&n;&t;&t;&t;   kernels and modules from bug report by &n;&t;&t;&t;   &lt;Zlatko.Calusic@CARNet.hr&gt; et al.&n;      0.542  15-Sep-98    Fix dc2114x_autoconf() to stop multiple messages&n;                           when media is unconnected.&n;&t;&t;&t;  Change dev-&gt;interrupt to lp-&gt;interrupt to ensure&n;&t;&t;&t;   alignment for Alpha&squot;s and avoid their unaligned&n;&t;&t;&t;   access traps. This flag is merely for log messages:&n;&t;&t;&t;   should do something more definitive though...&n;      0.543  30-Dec-98    Add SMP spin locking.&n;      0.544   8-May-99    Fix for buggy SROM in Motorola embedded boards using&n;                           a 21143 by &lt;mmporter@home.com&gt;.&n;&t;&t;&t;  Change PCI/EISA bus probing order.&n;      0.545  28-Nov-99    Further Moto SROM bug fix from &n;                           &lt;mporter@eng.mcd.mot.com&gt;&n;                          Remove double checking for DEBUG_RX in de4x5_dbg_rx()&n;&t;&t;&t;   from report by &lt;geert@linux-m68k.org&gt;&n; &n;    =========================================================================&n;*/
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;de4x5.c:V0.545 1999/11/28 davies@maniac.ultranet.com&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#ifdef CONFIG_PPC
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#endif /* CONFIG_PPC */
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &quot;de4x5.h&quot;
DECL|macro|c_char
mdefine_line|#define c_char const char
DECL|macro|TWIDDLE
mdefine_line|#define TWIDDLE(a) (u_short)le16_to_cpu(get_unaligned((u_short *)(a)))
multiline_comment|/*&n;** MII Information&n;*/
DECL|struct|phy_table
r_struct
id|phy_table
(brace
DECL|member|reset
r_int
id|reset
suffix:semicolon
multiline_comment|/* Hard reset required?                         */
DECL|member|id
r_int
id|id
suffix:semicolon
multiline_comment|/* IEEE OUI                                     */
DECL|member|ta
r_int
id|ta
suffix:semicolon
multiline_comment|/* One cycle TA time - 802.3u is confusing here */
r_struct
(brace
multiline_comment|/* Non autonegotiation (parallel) speed det.    */
DECL|member|reg
r_int
id|reg
suffix:semicolon
DECL|member|mask
r_int
id|mask
suffix:semicolon
DECL|member|value
r_int
id|value
suffix:semicolon
DECL|member|spd
)brace
id|spd
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|mii_phy
r_struct
id|mii_phy
(brace
DECL|member|reset
r_int
id|reset
suffix:semicolon
multiline_comment|/* Hard reset required?                      */
DECL|member|id
r_int
id|id
suffix:semicolon
multiline_comment|/* IEEE OUI                                  */
DECL|member|ta
r_int
id|ta
suffix:semicolon
multiline_comment|/* One cycle TA time                         */
r_struct
(brace
multiline_comment|/* Non autonegotiation (parallel) speed det. */
DECL|member|reg
r_int
id|reg
suffix:semicolon
DECL|member|mask
r_int
id|mask
suffix:semicolon
DECL|member|value
r_int
id|value
suffix:semicolon
DECL|member|spd
)brace
id|spd
suffix:semicolon
DECL|member|addr
r_int
id|addr
suffix:semicolon
multiline_comment|/* MII address for the PHY                   */
DECL|member|gep
id|u_char
op_star
id|gep
suffix:semicolon
multiline_comment|/* Start of GEP sequence block in SROM       */
DECL|member|rst
id|u_char
op_star
id|rst
suffix:semicolon
multiline_comment|/* Start of reset sequence in SROM           */
DECL|member|mc
id|u_int
id|mc
suffix:semicolon
multiline_comment|/* Media Capabilities                        */
DECL|member|ana
id|u_int
id|ana
suffix:semicolon
multiline_comment|/* NWay Advertisement                        */
DECL|member|fdx
id|u_int
id|fdx
suffix:semicolon
multiline_comment|/* Full DupleX capabilites for each media    */
DECL|member|ttm
id|u_int
id|ttm
suffix:semicolon
multiline_comment|/* Transmit Threshold Mode for each media    */
DECL|member|mci
id|u_int
id|mci
suffix:semicolon
multiline_comment|/* 21142 MII Connector Interrupt info        */
)brace
suffix:semicolon
DECL|macro|DE4X5_MAX_PHY
mdefine_line|#define DE4X5_MAX_PHY 8     /* Allow upto 8 attached PHY devices per board */
DECL|struct|sia_phy
r_struct
id|sia_phy
(brace
DECL|member|mc
id|u_char
id|mc
suffix:semicolon
multiline_comment|/* Media Code                                */
DECL|member|ext
id|u_char
id|ext
suffix:semicolon
multiline_comment|/* csr13-15 valid when set                   */
DECL|member|csr13
r_int
id|csr13
suffix:semicolon
multiline_comment|/* SIA Connectivity Register                 */
DECL|member|csr14
r_int
id|csr14
suffix:semicolon
multiline_comment|/* SIA TX/RX Register                        */
DECL|member|csr15
r_int
id|csr15
suffix:semicolon
multiline_comment|/* SIA General Register                      */
DECL|member|gepc
r_int
id|gepc
suffix:semicolon
multiline_comment|/* SIA GEP Control Information               */
DECL|member|gep
r_int
id|gep
suffix:semicolon
multiline_comment|/* SIA GEP Data                              */
)brace
suffix:semicolon
multiline_comment|/*&n;** Define the know universe of PHY devices that can be&n;** recognised by this driver.&n;*/
DECL|variable|phy_info
r_static
r_struct
id|phy_table
id|phy_info
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
id|NATIONAL_TX
comma
l_int|1
comma
(brace
l_int|0x19
comma
l_int|0x40
comma
l_int|0x00
)brace
)brace
comma
multiline_comment|/* National TX      */
(brace
l_int|1
comma
id|BROADCOM_T4
comma
l_int|1
comma
(brace
l_int|0x10
comma
l_int|0x02
comma
l_int|0x02
)brace
)brace
comma
multiline_comment|/* Broadcom T4      */
(brace
l_int|0
comma
id|SEEQ_T4
comma
l_int|1
comma
(brace
l_int|0x12
comma
l_int|0x10
comma
l_int|0x10
)brace
)brace
comma
multiline_comment|/* SEEQ T4          */
(brace
l_int|0
comma
id|CYPRESS_T4
comma
l_int|1
comma
(brace
l_int|0x05
comma
l_int|0x20
comma
l_int|0x20
)brace
)brace
comma
multiline_comment|/* Cypress T4       */
(brace
l_int|0
comma
l_int|0x7810
comma
l_int|1
comma
(brace
l_int|0x14
comma
l_int|0x0800
comma
l_int|0x0800
)brace
)brace
multiline_comment|/* Level One LTX970 */
)brace
suffix:semicolon
multiline_comment|/*&n;** These GENERIC values assumes that the PHY devices follow 802.3u and&n;** allow parallel detection to set the link partner ability register.&n;** Detection of 100Base-TX [H/F Duplex] and 100Base-T4 is supported.&n;*/
DECL|macro|GENERIC_REG
mdefine_line|#define GENERIC_REG   0x05      /* Autoneg. Link Partner Advertisement Reg. */
DECL|macro|GENERIC_MASK
mdefine_line|#define GENERIC_MASK  MII_ANLPA_100M /* All 100Mb/s Technologies            */
DECL|macro|GENERIC_VALUE
mdefine_line|#define GENERIC_VALUE MII_ANLPA_100M /* 100B-TX, 100B-TX FDX, 100B-T4       */
multiline_comment|/*&n;** Define special SROM detection cases&n;*/
DECL|variable|enet_det
r_static
id|c_char
id|enet_det
(braket
)braket
(braket
id|ETH_ALEN
)braket
op_assign
(brace
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0xc0
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
comma
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0xe8
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
)brace
suffix:semicolon
DECL|macro|SMC
mdefine_line|#define SMC    1
DECL|macro|ACCTON
mdefine_line|#define ACCTON 2
multiline_comment|/*&n;** SROM Repair definitions. If a broken SROM is detected a card may&n;** use this information to help figure out what to do. This is a&n;** &quot;stab in the dark&quot; and so far for SMC9332&squot;s only.&n;*/
DECL|variable|srom_repair_info
r_static
id|c_char
id|srom_repair_info
(braket
)braket
(braket
l_int|100
)braket
op_assign
(brace
(brace
l_int|0x00
comma
l_int|0x1e
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x08
comma
multiline_comment|/* SMC9332 */
l_int|0x1f
comma
l_int|0x01
comma
l_int|0x8f
comma
l_int|0x01
comma
l_int|0x00
comma
l_int|0x01
comma
l_int|0x00
comma
l_int|0x02
comma
l_int|0x01
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x78
comma
l_int|0xe0
comma
l_int|0x01
comma
l_int|0x00
comma
l_int|0x50
comma
l_int|0x00
comma
l_int|0x18
comma
)brace
)brace
suffix:semicolon
macro_line|#ifdef DE4X5_DEBUG
DECL|variable|de4x5_debug
r_static
r_int
id|de4x5_debug
op_assign
id|DE4X5_DEBUG
suffix:semicolon
macro_line|#else
multiline_comment|/*static int de4x5_debug = (DEBUG_MII | DEBUG_SROM | DEBUG_PCICFG | DEBUG_MEDIA | DEBUG_VERSION);*/
DECL|variable|de4x5_debug
r_static
r_int
id|de4x5_debug
op_assign
(paren
id|DEBUG_MEDIA
op_or
id|DEBUG_VERSION
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;** Allow per adapter set up. For modules this is simply a command line&n;** parameter, e.g.: &n;** insmod de4x5 args=&squot;eth1:fdx autosense=BNC eth0:autosense=100Mb&squot;.&n;**&n;** For a compiled in driver, place e.g.&n;**     #define DE4X5_PARM &quot;eth0:fdx autosense=AUI eth2:autosense=TP&quot;&n;** here&n;*/
macro_line|#ifdef DE4X5_PARM
DECL|variable|args
r_static
r_char
op_star
id|args
op_assign
id|DE4X5_PARM
suffix:semicolon
macro_line|#else
DECL|variable|args
r_static
r_char
op_star
id|args
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
DECL|struct|parameters
r_struct
id|parameters
(brace
DECL|member|fdx
r_int
id|fdx
suffix:semicolon
DECL|member|autosense
r_int
id|autosense
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|DE4X5_AUTOSENSE_MS
mdefine_line|#define DE4X5_AUTOSENSE_MS 250      /* msec autosense tick (DE500) */
DECL|macro|DE4X5_NDA
mdefine_line|#define DE4X5_NDA 0xffe0            /* No Device (I/O) Address */
multiline_comment|/*&n;** Ethernet PROM defines&n;*/
DECL|macro|PROBE_LENGTH
mdefine_line|#define PROBE_LENGTH    32
DECL|macro|ETH_PROM_SIG
mdefine_line|#define ETH_PROM_SIG    0xAA5500FFUL
multiline_comment|/*&n;** Ethernet Info&n;*/
DECL|macro|PKT_BUF_SZ
mdefine_line|#define PKT_BUF_SZ&t;1536            /* Buffer size for each Tx/Rx buffer */
DECL|macro|IEEE802_3_SZ
mdefine_line|#define IEEE802_3_SZ    1518            /* Packet + CRC */
DECL|macro|MAX_PKT_SZ
mdefine_line|#define MAX_PKT_SZ   &t;1514            /* Maximum ethernet packet length */
DECL|macro|MAX_DAT_SZ
mdefine_line|#define MAX_DAT_SZ   &t;1500            /* Maximum ethernet data length */
DECL|macro|MIN_DAT_SZ
mdefine_line|#define MIN_DAT_SZ   &t;1               /* Minimum ethernet data length */
DECL|macro|PKT_HDR_LEN
mdefine_line|#define PKT_HDR_LEN     14              /* Addresses and data length info */
DECL|macro|FAKE_FRAME_LEN
mdefine_line|#define FAKE_FRAME_LEN  (MAX_PKT_SZ + 1)
DECL|macro|QUEUE_PKT_TIMEOUT
mdefine_line|#define QUEUE_PKT_TIMEOUT (3*HZ)        /* 3 second timeout */
DECL|macro|CRC_POLYNOMIAL_BE
mdefine_line|#define CRC_POLYNOMIAL_BE 0x04c11db7UL  /* Ethernet CRC, big endian */
DECL|macro|CRC_POLYNOMIAL_LE
mdefine_line|#define CRC_POLYNOMIAL_LE 0xedb88320UL  /* Ethernet CRC, little endian */
multiline_comment|/*&n;** EISA bus defines&n;*/
DECL|macro|DE4X5_EISA_IO_PORTS
mdefine_line|#define DE4X5_EISA_IO_PORTS   0x0c00    /* I/O port base address, slot 0 */
DECL|macro|DE4X5_EISA_TOTAL_SIZE
mdefine_line|#define DE4X5_EISA_TOTAL_SIZE 0x100     /* I/O address extent */
DECL|macro|MAX_EISA_SLOTS
mdefine_line|#define MAX_EISA_SLOTS 16
DECL|macro|EISA_SLOT_INC
mdefine_line|#define EISA_SLOT_INC 0x1000
DECL|macro|EISA_ALLOWED_IRQ_LIST
mdefine_line|#define EISA_ALLOWED_IRQ_LIST  {5, 9, 10, 11}
DECL|macro|DE4X5_SIGNATURE
mdefine_line|#define DE4X5_SIGNATURE {&quot;DE425&quot;,&quot;DE434&quot;,&quot;DE435&quot;,&quot;DE450&quot;,&quot;DE500&quot;}
DECL|macro|DE4X5_NAME_LENGTH
mdefine_line|#define DE4X5_NAME_LENGTH 8
multiline_comment|/*&n;** Ethernet PROM defines for DC21040&n;*/
DECL|macro|PROBE_LENGTH
mdefine_line|#define PROBE_LENGTH    32
DECL|macro|ETH_PROM_SIG
mdefine_line|#define ETH_PROM_SIG    0xAA5500FFUL
multiline_comment|/*&n;** PCI Bus defines&n;*/
DECL|macro|PCI_MAX_BUS_NUM
mdefine_line|#define PCI_MAX_BUS_NUM      8
DECL|macro|DE4X5_PCI_TOTAL_SIZE
mdefine_line|#define DE4X5_PCI_TOTAL_SIZE 0x80       /* I/O address extent */
DECL|macro|DE4X5_CLASS_CODE
mdefine_line|#define DE4X5_CLASS_CODE     0x00020000 /* Network controller, Ethernet */
DECL|macro|NO_MORE_PCI
mdefine_line|#define NO_MORE_PCI          -2         /* PCI bus search all done */
multiline_comment|/*&n;** Memory Alignment. Each descriptor is 4 longwords long. To force a&n;** particular alignment on the TX descriptor, adjust DESC_SKIP_LEN and&n;** DESC_ALIGN. ALIGN aligns the start address of the private memory area&n;** and hence the RX descriptor ring&squot;s first entry. &n;*/
DECL|macro|ALIGN4
mdefine_line|#define ALIGN4      ((u_long)4 - 1)     /* 1 longword align */
DECL|macro|ALIGN8
mdefine_line|#define ALIGN8      ((u_long)8 - 1)     /* 2 longword align */
DECL|macro|ALIGN16
mdefine_line|#define ALIGN16     ((u_long)16 - 1)    /* 4 longword align */
DECL|macro|ALIGN32
mdefine_line|#define ALIGN32     ((u_long)32 - 1)    /* 8 longword align */
DECL|macro|ALIGN64
mdefine_line|#define ALIGN64     ((u_long)64 - 1)    /* 16 longword align */
DECL|macro|ALIGN128
mdefine_line|#define ALIGN128    ((u_long)128 - 1)   /* 32 longword align */
DECL|macro|ALIGN
mdefine_line|#define ALIGN         ALIGN32           /* Keep the DC21040 happy... */
DECL|macro|CACHE_ALIGN
mdefine_line|#define CACHE_ALIGN   CAL_16LONG
DECL|macro|DESC_SKIP_LEN
mdefine_line|#define DESC_SKIP_LEN DSL_0             /* Must agree with DESC_ALIGN */
multiline_comment|/*#define DESC_ALIGN    u32 dummy[4];  / * Must agree with DESC_SKIP_LEN */
DECL|macro|DESC_ALIGN
mdefine_line|#define DESC_ALIGN
macro_line|#ifndef DEC_ONLY                        /* See README.de4x5 for using this */
DECL|variable|dec_only
r_static
r_int
id|dec_only
op_assign
l_int|0
suffix:semicolon
macro_line|#else
DECL|variable|dec_only
r_static
r_int
id|dec_only
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;** DE4X5 IRQ ENABLE/DISABLE&n;*/
DECL|macro|ENABLE_IRQs
mdefine_line|#define ENABLE_IRQs { &bslash;&n;    imr |= lp-&gt;irq_en;&bslash;&n;    outl(imr, DE4X5_IMR);               /* Enable the IRQs */&bslash;&n;}
DECL|macro|DISABLE_IRQs
mdefine_line|#define DISABLE_IRQs {&bslash;&n;    imr = inl(DE4X5_IMR);&bslash;&n;    imr &amp;= ~lp-&gt;irq_en;&bslash;&n;    outl(imr, DE4X5_IMR);               /* Disable the IRQs */&bslash;&n;}
DECL|macro|UNMASK_IRQs
mdefine_line|#define UNMASK_IRQs {&bslash;&n;    imr |= lp-&gt;irq_mask;&bslash;&n;    outl(imr, DE4X5_IMR);               /* Unmask the IRQs */&bslash;&n;}
DECL|macro|MASK_IRQs
mdefine_line|#define MASK_IRQs {&bslash;&n;    imr = inl(DE4X5_IMR);&bslash;&n;    imr &amp;= ~lp-&gt;irq_mask;&bslash;&n;    outl(imr, DE4X5_IMR);               /* Mask the IRQs */&bslash;&n;}
multiline_comment|/*&n;** DE4X5 START/STOP&n;*/
DECL|macro|START_DE4X5
mdefine_line|#define START_DE4X5 {&bslash;&n;    omr = inl(DE4X5_OMR);&bslash;&n;    omr |= OMR_ST | OMR_SR;&bslash;&n;    outl(omr, DE4X5_OMR);               /* Enable the TX and/or RX */&bslash;&n;}
DECL|macro|STOP_DE4X5
mdefine_line|#define STOP_DE4X5 {&bslash;&n;    omr = inl(DE4X5_OMR);&bslash;&n;    omr &amp;= ~(OMR_ST|OMR_SR);&bslash;&n;    outl(omr, DE4X5_OMR);               /* Disable the TX and/or RX */ &bslash;&n;}
multiline_comment|/*&n;** DE4X5 SIA RESET&n;*/
DECL|macro|RESET_SIA
mdefine_line|#define RESET_SIA outl(0, DE4X5_SICR);  /* Reset SIA connectivity regs */
multiline_comment|/*&n;** DE500 AUTOSENSE TIMER INTERVAL (MILLISECS)&n;*/
DECL|macro|DE4X5_AUTOSENSE_MS
mdefine_line|#define DE4X5_AUTOSENSE_MS  250
multiline_comment|/*&n;** SROM Structure&n;*/
DECL|struct|de4x5_srom
r_struct
id|de4x5_srom
(brace
DECL|member|sub_vendor_id
r_char
id|sub_vendor_id
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|sub_system_id
r_char
id|sub_system_id
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|reserved
r_char
id|reserved
(braket
l_int|12
)braket
suffix:semicolon
DECL|member|id_block_crc
r_char
id|id_block_crc
suffix:semicolon
DECL|member|reserved2
r_char
id|reserved2
suffix:semicolon
DECL|member|version
r_char
id|version
suffix:semicolon
DECL|member|num_controllers
r_char
id|num_controllers
suffix:semicolon
DECL|member|ieee_addr
r_char
id|ieee_addr
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|info
r_char
id|info
(braket
l_int|100
)braket
suffix:semicolon
DECL|member|chksum
r_int
id|chksum
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|SUB_VENDOR_ID
mdefine_line|#define SUB_VENDOR_ID 0x500a
multiline_comment|/*&n;** DE4X5 Descriptors. Make sure that all the RX buffers are contiguous&n;** and have sizes of both a power of 2 and a multiple of 4.&n;** A size of 256 bytes for each buffer could be chosen because over 90% of&n;** all packets in our network are &lt;256 bytes long and 64 longword alignment&n;** is possible. 1536 showed better &squot;ttcp&squot; performance. Take your pick. 32 TX&n;** descriptors are needed for machines with an ALPHA CPU.&n;*/
DECL|macro|NUM_RX_DESC
mdefine_line|#define NUM_RX_DESC 8                   /* Number of RX descriptors   */
DECL|macro|NUM_TX_DESC
mdefine_line|#define NUM_TX_DESC 32                  /* Number of TX descriptors   */
DECL|macro|RX_BUFF_SZ
mdefine_line|#define RX_BUFF_SZ  1536                /* Power of 2 for kmalloc and */
multiline_comment|/* Multiple of 4 for DC21040  */
multiline_comment|/* Allows 512 byte alignment  */
DECL|struct|de4x5_desc
r_struct
id|de4x5_desc
(brace
DECL|member|status
r_volatile
id|s32
id|status
suffix:semicolon
DECL|member|des1
id|u32
id|des1
suffix:semicolon
DECL|member|buf
id|u32
id|buf
suffix:semicolon
DECL|member|next
id|u32
id|next
suffix:semicolon
id|DESC_ALIGN
)brace
suffix:semicolon
multiline_comment|/*&n;** The DE4X5 private structure&n;*/
DECL|macro|DE4X5_PKT_STAT_SZ
mdefine_line|#define DE4X5_PKT_STAT_SZ 16
DECL|macro|DE4X5_PKT_BIN_SZ
mdefine_line|#define DE4X5_PKT_BIN_SZ  128            /* Should be &gt;=100 unless you&n;                                            increase DE4X5_PKT_STAT_SZ */
DECL|struct|pkt_stats
r_struct
id|pkt_stats
(brace
DECL|member|bins
id|u_int
id|bins
(braket
id|DE4X5_PKT_STAT_SZ
)braket
suffix:semicolon
multiline_comment|/* Private stats counters       */
DECL|member|unicast
id|u_int
id|unicast
suffix:semicolon
DECL|member|multicast
id|u_int
id|multicast
suffix:semicolon
DECL|member|broadcast
id|u_int
id|broadcast
suffix:semicolon
DECL|member|excessive_collisions
id|u_int
id|excessive_collisions
suffix:semicolon
DECL|member|tx_underruns
id|u_int
id|tx_underruns
suffix:semicolon
DECL|member|excessive_underruns
id|u_int
id|excessive_underruns
suffix:semicolon
DECL|member|rx_runt_frames
id|u_int
id|rx_runt_frames
suffix:semicolon
DECL|member|rx_collision
id|u_int
id|rx_collision
suffix:semicolon
DECL|member|rx_dribble
id|u_int
id|rx_dribble
suffix:semicolon
DECL|member|rx_overflow
id|u_int
id|rx_overflow
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|de4x5_private
r_struct
id|de4x5_private
(brace
DECL|member|adapter_name
r_char
id|adapter_name
(braket
l_int|80
)braket
suffix:semicolon
multiline_comment|/* Adapter name                 */
DECL|member|interrupt
id|u_long
id|interrupt
suffix:semicolon
multiline_comment|/* Aligned ISR flag             */
DECL|member|rx_ring
r_struct
id|de4x5_desc
op_star
id|rx_ring
suffix:semicolon
multiline_comment|/* RX descriptor ring           */
DECL|member|tx_ring
r_struct
id|de4x5_desc
op_star
id|tx_ring
suffix:semicolon
multiline_comment|/* TX descriptor ring           */
DECL|member|tx_skb
r_struct
id|sk_buff
op_star
id|tx_skb
(braket
id|NUM_TX_DESC
)braket
suffix:semicolon
multiline_comment|/* TX skb for freeing when sent */
DECL|member|rx_skb
r_struct
id|sk_buff
op_star
id|rx_skb
(braket
id|NUM_RX_DESC
)braket
suffix:semicolon
multiline_comment|/* RX skb&squot;s                     */
DECL|member|rx_new
DECL|member|rx_old
r_int
id|rx_new
comma
id|rx_old
suffix:semicolon
multiline_comment|/* RX descriptor ring pointers  */
DECL|member|tx_new
DECL|member|tx_old
r_int
id|tx_new
comma
id|tx_old
suffix:semicolon
multiline_comment|/* TX descriptor ring pointers  */
DECL|member|setup_frame
r_char
id|setup_frame
(braket
id|SETUP_FRAME_LEN
)braket
suffix:semicolon
multiline_comment|/* Holds MCA and PA info.       */
DECL|member|frame
r_char
id|frame
(braket
l_int|64
)braket
suffix:semicolon
multiline_comment|/* Min sized packet for loopback*/
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* Adapter specific spinlock    */
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
multiline_comment|/* Public stats                 */
DECL|member|pktStats
r_struct
id|pkt_stats
id|pktStats
suffix:semicolon
multiline_comment|/* Private stats counters&t;    */
DECL|member|rxRingSize
r_char
id|rxRingSize
suffix:semicolon
DECL|member|txRingSize
r_char
id|txRingSize
suffix:semicolon
DECL|member|bus
r_int
id|bus
suffix:semicolon
multiline_comment|/* EISA or PCI                  */
DECL|member|bus_num
r_int
id|bus_num
suffix:semicolon
multiline_comment|/* PCI Bus number               */
DECL|member|device
r_int
id|device
suffix:semicolon
multiline_comment|/* Device number on PCI bus     */
DECL|member|state
r_int
id|state
suffix:semicolon
multiline_comment|/* Adapter OPENED or CLOSED     */
DECL|member|chipset
r_int
id|chipset
suffix:semicolon
multiline_comment|/* DC21040, DC21041 or DC21140  */
DECL|member|irq_mask
id|s32
id|irq_mask
suffix:semicolon
multiline_comment|/* Interrupt Mask (Enable) bits */
DECL|member|irq_en
id|s32
id|irq_en
suffix:semicolon
multiline_comment|/* Summary interrupt bits       */
DECL|member|media
r_int
id|media
suffix:semicolon
multiline_comment|/* Media (eg TP), mode (eg 100B)*/
DECL|member|c_media
r_int
id|c_media
suffix:semicolon
multiline_comment|/* Remember the last media conn */
DECL|member|fdx
r_int
id|fdx
suffix:semicolon
multiline_comment|/* media full duplex flag       */
DECL|member|linkOK
r_int
id|linkOK
suffix:semicolon
multiline_comment|/* Link is OK                   */
DECL|member|autosense
r_int
id|autosense
suffix:semicolon
multiline_comment|/* Allow/disallow autosensing   */
DECL|member|tx_enable
r_int
id|tx_enable
suffix:semicolon
multiline_comment|/* Enable descriptor polling    */
DECL|member|setup_f
r_int
id|setup_f
suffix:semicolon
multiline_comment|/* Setup frame filtering type   */
DECL|member|local_state
r_int
id|local_state
suffix:semicolon
multiline_comment|/* State within a &squot;media&squot; state */
DECL|member|phy
r_struct
id|mii_phy
id|phy
(braket
id|DE4X5_MAX_PHY
)braket
suffix:semicolon
multiline_comment|/* List of attached PHY devices */
DECL|member|sia
r_struct
id|sia_phy
id|sia
suffix:semicolon
multiline_comment|/* SIA PHY Information          */
DECL|member|active
r_int
id|active
suffix:semicolon
multiline_comment|/* Index to active PHY device   */
DECL|member|mii_cnt
r_int
id|mii_cnt
suffix:semicolon
multiline_comment|/* Number of attached PHY&squot;s     */
DECL|member|timeout
r_int
id|timeout
suffix:semicolon
multiline_comment|/* Scheduling counter           */
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* Timer info for kernel        */
DECL|member|tmp
r_int
id|tmp
suffix:semicolon
multiline_comment|/* Temporary global per card    */
r_struct
(brace
DECL|member|priv
r_void
op_star
id|priv
suffix:semicolon
multiline_comment|/* Original kmalloc&squot;d mem addr  */
DECL|member|lock
id|u_long
id|lock
suffix:semicolon
multiline_comment|/* Lock the cache accesses      */
DECL|member|csr0
id|s32
id|csr0
suffix:semicolon
multiline_comment|/* Saved Bus Mode Register      */
DECL|member|csr6
id|s32
id|csr6
suffix:semicolon
multiline_comment|/* Saved Operating Mode Reg.    */
DECL|member|csr7
id|s32
id|csr7
suffix:semicolon
multiline_comment|/* Saved IRQ Mask Register      */
DECL|member|gep
id|s32
id|gep
suffix:semicolon
multiline_comment|/* Saved General Purpose Reg.   */
DECL|member|gepc
id|s32
id|gepc
suffix:semicolon
multiline_comment|/* Control info for GEP         */
DECL|member|csr13
id|s32
id|csr13
suffix:semicolon
multiline_comment|/* Saved SIA Connectivity Reg.  */
DECL|member|csr14
id|s32
id|csr14
suffix:semicolon
multiline_comment|/* Saved SIA TX/RX Register     */
DECL|member|csr15
id|s32
id|csr15
suffix:semicolon
multiline_comment|/* Saved SIA General Register   */
DECL|member|save_cnt
r_int
id|save_cnt
suffix:semicolon
multiline_comment|/* Flag if state already saved  */
DECL|member|skb
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* Save the (re-ordered) skb&squot;s  */
DECL|member|cache
)brace
id|cache
suffix:semicolon
DECL|member|srom
r_struct
id|de4x5_srom
id|srom
suffix:semicolon
multiline_comment|/* A copy of the SROM           */
DECL|member|next_module
r_struct
id|net_device
op_star
id|next_module
suffix:semicolon
multiline_comment|/* Link to the next module      */
DECL|member|rx_ovf
r_int
id|rx_ovf
suffix:semicolon
multiline_comment|/* Check for &squot;RX overflow&squot; tag  */
DECL|member|useSROM
r_int
id|useSROM
suffix:semicolon
multiline_comment|/* For non-DEC card use SROM    */
DECL|member|useMII
r_int
id|useMII
suffix:semicolon
multiline_comment|/* Infoblock using the MII      */
DECL|member|asBitValid
r_int
id|asBitValid
suffix:semicolon
multiline_comment|/* Autosense bits in GEP?       */
DECL|member|asPolarity
r_int
id|asPolarity
suffix:semicolon
multiline_comment|/* 0 =&gt; asserted high           */
DECL|member|asBit
r_int
id|asBit
suffix:semicolon
multiline_comment|/* Autosense bit number in GEP  */
DECL|member|defMedium
r_int
id|defMedium
suffix:semicolon
multiline_comment|/* SROM default medium          */
DECL|member|tcount
r_int
id|tcount
suffix:semicolon
multiline_comment|/* Last infoblock number        */
DECL|member|infoblock_init
r_int
id|infoblock_init
suffix:semicolon
multiline_comment|/* Initialised this infoblock?  */
DECL|member|infoleaf_offset
r_int
id|infoleaf_offset
suffix:semicolon
multiline_comment|/* SROM infoleaf for controller */
DECL|member|infoblock_csr6
id|s32
id|infoblock_csr6
suffix:semicolon
multiline_comment|/* csr6 value in SROM infoblock */
DECL|member|infoblock_media
r_int
id|infoblock_media
suffix:semicolon
multiline_comment|/* infoblock media              */
DECL|member|infoleaf_fn
r_int
(paren
op_star
id|infoleaf_fn
)paren
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
multiline_comment|/* Pointer to infoleaf function */
DECL|member|rst
id|u_char
op_star
id|rst
suffix:semicolon
multiline_comment|/* Pointer to Type 5 reset info */
DECL|member|ibn
id|u_char
id|ibn
suffix:semicolon
multiline_comment|/* Infoblock number             */
DECL|member|params
r_struct
id|parameters
id|params
suffix:semicolon
multiline_comment|/* Command line/ #defined params */
DECL|member|pdev
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
multiline_comment|/* Device cookie for DMA alloc  */
DECL|member|dma_rings
id|dma_addr_t
id|dma_rings
suffix:semicolon
multiline_comment|/* DMA handle for rings&t;    */
DECL|member|dma_size
r_int
id|dma_size
suffix:semicolon
multiline_comment|/* Size of the DMA area&t;    */
DECL|member|rx_bufs
r_char
op_star
id|rx_bufs
suffix:semicolon
multiline_comment|/* rx bufs on alpha, sparc, ... */
)brace
suffix:semicolon
multiline_comment|/*&n;** Kludge to get around the fact that the CSR addresses have different&n;** offsets in the PCI and EISA boards. Also note that the ethernet address&n;** PROM is accessed differently.&n;*/
DECL|struct|bus_type
r_static
r_struct
id|bus_type
(brace
DECL|member|bus
r_int
id|bus
suffix:semicolon
DECL|member|bus_num
r_int
id|bus_num
suffix:semicolon
DECL|member|device
r_int
id|device
suffix:semicolon
DECL|member|chipset
r_int
id|chipset
suffix:semicolon
DECL|member|srom
r_struct
id|de4x5_srom
id|srom
suffix:semicolon
DECL|member|autosense
r_int
id|autosense
suffix:semicolon
DECL|member|useSROM
r_int
id|useSROM
suffix:semicolon
DECL|variable|bus
)brace
id|bus
suffix:semicolon
multiline_comment|/*&n;** To get around certain poxy cards that don&squot;t provide an SROM&n;** for the second and more DECchip, I have to key off the first&n;** chip&squot;s address. I&squot;ll assume there&squot;s not a bad SROM iff:&n;**&n;**      o the chipset is the same&n;**      o the bus number is the same and &gt; 0&n;**      o the sum of all the returned hw address bytes is 0 or 0x5fa&n;**&n;** Also have to save the irq for those cards whose hardware designers&n;** can&squot;t follow the PCI to PCI Bridge Architecture spec.&n;*/
r_static
r_struct
(brace
DECL|member|chipset
r_int
id|chipset
suffix:semicolon
DECL|member|bus
r_int
id|bus
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|addr
id|u_char
id|addr
(braket
id|ETH_ALEN
)braket
suffix:semicolon
DECL|variable|last
)brace
id|last
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/*&n;** The transmit ring full condition is described by the tx_old and tx_new&n;** pointers by:&n;**    tx_old            = tx_new    Empty ring&n;**    tx_old            = tx_new+1  Full ring&n;**    tx_old+txRingSize = tx_new+1  Full ring  (wrapped condition)&n;*/
DECL|macro|TX_BUFFS_AVAIL
mdefine_line|#define TX_BUFFS_AVAIL ((lp-&gt;tx_old&lt;=lp-&gt;tx_new)?&bslash;&n;&t;&t;&t;lp-&gt;tx_old+lp-&gt;txRingSize-lp-&gt;tx_new-1:&bslash;&n;&t;&t;&t;lp-&gt;tx_old               -lp-&gt;tx_new-1)
DECL|macro|TX_PKT_PENDING
mdefine_line|#define TX_PKT_PENDING (lp-&gt;tx_old != lp-&gt;tx_new)
multiline_comment|/*&n;** Public Functions&n;*/
r_static
r_int
id|de4x5_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|de4x5_queue_pkt
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|de4x5_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|de4x5_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|de4x5_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|de4x5_local_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|pkt_len
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|de4x5_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;** Private functions&n;*/
r_static
r_int
id|de4x5_hw_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
comma
r_struct
id|pci_dev
op_star
id|pdev
)paren
suffix:semicolon
r_static
r_int
id|de4x5_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|de4x5_sw_reset
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|de4x5_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|de4x5_tx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|de4x5_ast
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|de4x5_txur
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|de4x5_rx_ovfc
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|autoconf_media
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|create_packet
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_char
op_star
id|frame
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_void
id|de4x5_us_delay
c_func
(paren
id|u32
id|usec
)paren
suffix:semicolon
r_static
r_void
id|de4x5_ms_delay
c_func
(paren
id|u32
id|msec
)paren
suffix:semicolon
r_static
r_void
id|load_packet
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
id|u32
id|flags
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_int
id|dc21040_autoconf
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|dc21041_autoconf
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|dc21140m_autoconf
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|dc2114x_autoconf
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|srom_autoconf
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|de4x5_suspect_state
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|timeout
comma
r_int
id|prev_state
comma
r_int
(paren
op_star
id|fn
)paren
(paren
r_struct
id|net_device
op_star
comma
r_int
)paren
comma
r_int
(paren
op_star
id|asfn
)paren
(paren
r_struct
id|net_device
op_star
)paren
)paren
suffix:semicolon
r_static
r_int
id|dc21040_state
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|csr13
comma
r_int
id|csr14
comma
r_int
id|csr15
comma
r_int
id|timeout
comma
r_int
id|next_state
comma
r_int
id|suspect_state
comma
r_int
(paren
op_star
id|fn
)paren
(paren
r_struct
id|net_device
op_star
comma
r_int
)paren
)paren
suffix:semicolon
r_static
r_int
id|test_media
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|s32
id|irqs
comma
id|s32
id|irq_mask
comma
id|s32
id|csr13
comma
id|s32
id|csr14
comma
id|s32
id|csr15
comma
id|s32
id|msec
)paren
suffix:semicolon
r_static
r_int
id|test_for_100Mb
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|msec
)paren
suffix:semicolon
r_static
r_int
id|wait_for_link
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|test_mii_reg
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|reg
comma
r_int
id|mask
comma
r_int
id|pol
comma
r_int
id|msec
)paren
suffix:semicolon
r_static
r_int
id|is_spd_100
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|is_100_up
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|is_10_up
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|is_anc_capable
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|ping_media
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|msec
)paren
suffix:semicolon
r_static
r_struct
id|sk_buff
op_star
id|de4x5_alloc_rx_buff
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|index
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_void
id|de4x5_free_rx_buffs
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|de4x5_free_tx_buffs
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|de4x5_save_skbs
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|de4x5_rst_desc_ring
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|de4x5_cache_state
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|flag
)paren
suffix:semicolon
r_static
r_void
id|de4x5_put_cache
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_void
id|de4x5_putb_cache
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_struct
id|sk_buff
op_star
id|de4x5_get_cache
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|de4x5_setup_intr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|de4x5_init_connection
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|de4x5_reset_phy
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|reset_init_sia
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|s32
id|sicr
comma
id|s32
id|strr
comma
id|s32
id|sigr
)paren
suffix:semicolon
r_static
r_int
id|test_ans
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|s32
id|irqs
comma
id|s32
id|irq_mask
comma
id|s32
id|msec
)paren
suffix:semicolon
r_static
r_int
id|test_tp
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|s32
id|msec
)paren
suffix:semicolon
r_static
r_int
id|EISA_signature
c_func
(paren
r_char
op_star
id|name
comma
id|s32
id|eisa_id
)paren
suffix:semicolon
r_static
r_int
id|PCI_signature
c_func
(paren
r_char
op_star
id|name
comma
r_struct
id|bus_type
op_star
id|lp
)paren
suffix:semicolon
r_static
r_void
id|DevicePresent
c_func
(paren
id|u_long
id|iobase
)paren
suffix:semicolon
r_static
r_void
id|enet_addr_rst
c_func
(paren
id|u_long
id|aprom_addr
)paren
suffix:semicolon
r_static
r_int
id|de4x5_bad_srom
c_func
(paren
r_struct
id|bus_type
op_star
id|lp
)paren
suffix:semicolon
r_static
r_int
id|srom_rd
c_func
(paren
id|u_long
id|address
comma
id|u_char
id|offset
)paren
suffix:semicolon
r_static
r_void
id|srom_latch
c_func
(paren
id|u_int
id|command
comma
id|u_long
id|address
)paren
suffix:semicolon
r_static
r_void
id|srom_command
c_func
(paren
id|u_int
id|command
comma
id|u_long
id|address
)paren
suffix:semicolon
r_static
r_void
id|srom_address
c_func
(paren
id|u_int
id|command
comma
id|u_long
id|address
comma
id|u_char
id|offset
)paren
suffix:semicolon
r_static
r_int
id|srom_data
c_func
(paren
id|u_int
id|command
comma
id|u_long
id|address
)paren
suffix:semicolon
multiline_comment|/*static void    srom_busy(u_int command, u_long address);*/
r_static
r_void
id|sendto_srom
c_func
(paren
id|u_int
id|command
comma
id|u_long
id|addr
)paren
suffix:semicolon
r_static
r_int
id|getfrom_srom
c_func
(paren
id|u_long
id|addr
)paren
suffix:semicolon
r_static
r_int
id|srom_map_media
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|srom_infoleaf_info
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|srom_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|srom_exec
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
op_star
id|p
)paren
suffix:semicolon
r_static
r_int
id|mii_rd
c_func
(paren
id|u_char
id|phyreg
comma
id|u_char
id|phyaddr
comma
id|u_long
id|ioaddr
)paren
suffix:semicolon
r_static
r_void
id|mii_wr
c_func
(paren
r_int
id|data
comma
id|u_char
id|phyreg
comma
id|u_char
id|phyaddr
comma
id|u_long
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|mii_rdata
c_func
(paren
id|u_long
id|ioaddr
)paren
suffix:semicolon
r_static
r_void
id|mii_wdata
c_func
(paren
r_int
id|data
comma
r_int
id|len
comma
id|u_long
id|ioaddr
)paren
suffix:semicolon
r_static
r_void
id|mii_ta
c_func
(paren
id|u_long
id|rw
comma
id|u_long
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|mii_swap
c_func
(paren
r_int
id|data
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_void
id|mii_address
c_func
(paren
id|u_char
id|addr
comma
id|u_long
id|ioaddr
)paren
suffix:semicolon
r_static
r_void
id|sendto_mii
c_func
(paren
id|u32
id|command
comma
r_int
id|data
comma
id|u_long
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|getfrom_mii
c_func
(paren
id|u32
id|command
comma
id|u_long
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|mii_get_oui
c_func
(paren
id|u_char
id|phyaddr
comma
id|u_long
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|mii_get_phy
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|SetMulticastFilter
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|get_hw_addr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|srom_repair
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|card
)paren
suffix:semicolon
r_static
r_int
id|test_bad_enet
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|status
)paren
suffix:semicolon
r_static
r_int
id|an_exception
c_func
(paren
r_struct
id|bus_type
op_star
id|lp
)paren
suffix:semicolon
macro_line|#if !defined(__sparc_v9__) &amp;&amp; !defined(__powerpc__) &amp;&amp; !defined(__alpha__)
r_static
r_void
id|eisa_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|pci_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
suffix:semicolon
r_static
r_void
id|srom_search
c_func
(paren
r_struct
id|pci_dev
op_star
id|pdev
)paren
suffix:semicolon
r_static
r_char
op_star
id|build_setup_frame
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|mode
)paren
suffix:semicolon
r_static
r_void
id|disable_ast
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|enable_ast
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u32
id|time_out
)paren
suffix:semicolon
r_static
r_int
id|de4x5_switch_mac_port
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|gep_rd
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|gep_wr
c_func
(paren
id|s32
id|data
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
(paren
op_star
id|fn
)paren
(paren
id|u_long
id|data
)paren
comma
id|u_long
id|data
comma
id|u_long
id|msec
)paren
suffix:semicolon
r_static
r_void
id|yawn
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|state
)paren
suffix:semicolon
r_static
r_void
id|link_modules
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device
op_star
id|tmp
)paren
suffix:semicolon
r_static
r_void
id|de4x5_parse_params
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|de4x5_dbg_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|de4x5_dbg_mii
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|k
)paren
suffix:semicolon
r_static
r_void
id|de4x5_dbg_media
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|de4x5_dbg_srom
c_func
(paren
r_struct
id|de4x5_srom
op_star
id|p
)paren
suffix:semicolon
r_static
r_void
id|de4x5_dbg_rx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|de4x5_strncmp
c_func
(paren
r_char
op_star
id|a
comma
r_char
op_star
id|b
comma
r_int
id|n
)paren
suffix:semicolon
r_static
r_int
id|dc21041_infoleaf
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|dc21140_infoleaf
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|dc21142_infoleaf
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|dc21143_infoleaf
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|type0_infoblock
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
id|count
comma
id|u_char
op_star
id|p
)paren
suffix:semicolon
r_static
r_int
id|type1_infoblock
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
id|count
comma
id|u_char
op_star
id|p
)paren
suffix:semicolon
r_static
r_int
id|type2_infoblock
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
id|count
comma
id|u_char
op_star
id|p
)paren
suffix:semicolon
r_static
r_int
id|type3_infoblock
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
id|count
comma
id|u_char
op_star
id|p
)paren
suffix:semicolon
r_static
r_int
id|type4_infoblock
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
id|count
comma
id|u_char
op_star
id|p
)paren
suffix:semicolon
r_static
r_int
id|type5_infoblock
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
id|count
comma
id|u_char
op_star
id|p
)paren
suffix:semicolon
r_static
r_int
id|compact_infoblock
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
id|count
comma
id|u_char
op_star
id|p
)paren
suffix:semicolon
macro_line|#ifdef MODULE
r_int
id|init_module
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_struct
id|net_device
op_star
id|unlink_modules
c_func
(paren
r_struct
id|net_device
op_star
id|p
)paren
suffix:semicolon
r_static
r_struct
id|net_device
op_star
id|insert_device
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
comma
r_int
(paren
op_star
id|init
)paren
(paren
r_struct
id|net_device
op_star
)paren
)paren
suffix:semicolon
r_static
r_int
id|count_adapters
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|loading_module
r_static
r_int
id|loading_module
op_assign
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|de4x5_debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|dec_only
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|args
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
macro_line|# else
DECL|variable|loading_module
r_static
r_int
id|loading_module
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* MODULE */
DECL|variable|name
r_static
r_char
id|name
(braket
id|DE4X5_NAME_LENGTH
op_plus
l_int|1
)braket
suffix:semicolon
macro_line|#if !defined(__sparc_v9__) &amp;&amp; !defined(__powerpc__) &amp;&amp; !defined(__alpha__)
DECL|variable|de4x5_irq
r_static
id|u_char
id|de4x5_irq
(braket
)braket
op_assign
id|EISA_ALLOWED_IRQ_LIST
suffix:semicolon
DECL|variable|lastEISA
r_static
r_int
id|lastEISA
op_assign
l_int|0
suffix:semicolon
macro_line|#  ifdef DE4X5_FORCE_EISA                 /* Force an EISA bus probe or not */
DECL|variable|forceEISA
r_static
r_int
id|forceEISA
op_assign
l_int|1
suffix:semicolon
macro_line|#  else
DECL|variable|forceEISA
r_static
r_int
id|forceEISA
op_assign
l_int|0
suffix:semicolon
macro_line|#  endif
macro_line|#endif
DECL|variable|num_de4x5s
r_static
r_int
id|num_de4x5s
op_assign
l_int|0
suffix:semicolon
DECL|variable|cfrv
DECL|variable|useSROM
r_static
r_int
id|cfrv
op_assign
l_int|0
comma
id|useSROM
op_assign
l_int|0
suffix:semicolon
DECL|variable|lastPCI
r_static
r_int
id|lastPCI
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|lastModule
r_static
r_struct
id|net_device
op_star
id|lastModule
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|pdev
r_static
r_struct
id|pci_dev
op_star
id|pdev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;** List the SROM infoleaf functions and chipsets&n;*/
DECL|struct|InfoLeaf
r_struct
id|InfoLeaf
(brace
DECL|member|chipset
r_int
id|chipset
suffix:semicolon
DECL|member|fn
r_int
(paren
op_star
id|fn
)paren
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|infoleaf_array
r_static
r_struct
id|InfoLeaf
id|infoleaf_array
(braket
)braket
op_assign
(brace
(brace
id|DC21041
comma
id|dc21041_infoleaf
)brace
comma
(brace
id|DC21140
comma
id|dc21140_infoleaf
)brace
comma
(brace
id|DC21142
comma
id|dc21142_infoleaf
)brace
comma
(brace
id|DC21143
comma
id|dc21143_infoleaf
)brace
)brace
suffix:semicolon
DECL|macro|INFOLEAF_SIZE
mdefine_line|#define INFOLEAF_SIZE (sizeof(infoleaf_array)/(sizeof(int)+sizeof(int *)))
multiline_comment|/*&n;** List the SROM info block functions&n;*/
DECL|variable|dc_infoblock
r_static
r_int
(paren
op_star
id|dc_infoblock
(braket
)braket
)paren
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
comma
id|u_char
op_star
)paren
op_assign
(brace
id|type0_infoblock
comma
id|type1_infoblock
comma
id|type2_infoblock
comma
id|type3_infoblock
comma
id|type4_infoblock
comma
id|type5_infoblock
comma
id|compact_infoblock
)brace
suffix:semicolon
DECL|macro|COMPACT
mdefine_line|#define COMPACT (sizeof(dc_infoblock)/sizeof(int *) - 1)
multiline_comment|/*&n;** Miscellaneous defines...&n;*/
DECL|macro|RESET_DE4X5
mdefine_line|#define RESET_DE4X5 {&bslash;&n;    int i;&bslash;&n;    i=inl(DE4X5_BMR);&bslash;&n;    de4x5_ms_delay(1);&bslash;&n;    outl(i | BMR_SWR, DE4X5_BMR);&bslash;&n;    de4x5_ms_delay(1);&bslash;&n;    outl(i, DE4X5_BMR);&bslash;&n;    de4x5_ms_delay(1);&bslash;&n;    for (i=0;i&lt;5;i++) {inl(DE4X5_BMR); de4x5_ms_delay(1);}&bslash;&n;    de4x5_ms_delay(1);&bslash;&n;}
DECL|macro|PHY_HARD_RESET
mdefine_line|#define PHY_HARD_RESET {&bslash;&n;    outl(GEP_HRST, DE4X5_GEP);           /* Hard RESET the PHY dev. */&bslash;&n;    mdelay(1);                           /* Assert for 1ms */&bslash;&n;    outl(0x00, DE4X5_GEP);&bslash;&n;    mdelay(2);                           /* Wait for 2ms */&bslash;&n;}
"&f;"
multiline_comment|/*&n;** Autoprobing in modules is allowed here. See the top of the file for&n;** more info.&n;*/
r_int
id|__init
DECL|function|de4x5_probe
id|de4x5_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|pci_probe
c_func
(paren
id|dev
comma
id|iobase
)paren
suffix:semicolon
macro_line|#if !defined(__sparc_v9__) &amp;&amp; !defined(__powerpc__) &amp;&amp; !defined(__alpha__)
r_if
c_cond
(paren
(paren
id|lastPCI
op_eq
id|NO_MORE_PCI
)paren
op_logical_and
(paren
(paren
id|num_de4x5s
op_eq
l_int|0
)paren
op_logical_or
id|forceEISA
)paren
)paren
(brace
id|eisa_probe
c_func
(paren
id|dev
comma
id|iobase
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
(paren
id|dev-&gt;priv
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|de4x5_hw_init
id|de4x5_hw_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
comma
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
r_struct
id|bus_type
op_star
id|lp
op_assign
op_amp
id|bus
suffix:semicolon
r_int
id|i
comma
id|status
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
multiline_comment|/* Ensure we&squot;re not sleeping */
r_if
c_cond
(paren
id|lp-&gt;bus
op_eq
id|EISA
)paren
(brace
id|outb
c_func
(paren
id|WAKEUP
comma
id|PCI_CFPM
)paren
suffix:semicolon
)brace
r_else
(brace
id|pcibios_write_config_byte
c_func
(paren
id|lp-&gt;bus_num
comma
id|lp-&gt;device
op_lshift
l_int|3
comma
id|PCI_CFDA_PSM
comma
id|WAKEUP
)paren
suffix:semicolon
)brace
id|de4x5_ms_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|RESET_DE4X5
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inl
c_func
(paren
id|DE4X5_STS
)paren
op_amp
(paren
id|STS_TS
op_or
id|STS_RS
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* Hardware could not reset */
)brace
multiline_comment|/* &n;    ** Now find out what kind of DC21040/DC21041/DC21140 board we have.&n;    */
id|useSROM
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;bus
op_eq
id|PCI
)paren
(brace
id|PCI_signature
c_func
(paren
id|name
comma
id|lp
)paren
suffix:semicolon
)brace
r_else
(brace
id|EISA_signature
c_func
(paren
id|name
comma
id|EISA_ID0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|name
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
multiline_comment|/* Not found a board signature */
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|dev-&gt;base_addr
op_assign
id|iobase
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;bus
op_eq
id|EISA
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s at 0x%04lx (EISA slot %ld)&quot;
comma
id|dev-&gt;name
comma
id|name
comma
id|iobase
comma
(paren
(paren
id|iobase
op_rshift
l_int|12
)paren
op_amp
l_int|0x0f
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* PCI port address */
id|printk
c_func
(paren
l_string|&quot;%s: %s at 0x%04lx (PCI bus %d, device %d)&quot;
comma
id|dev-&gt;name
comma
id|name
comma
id|iobase
comma
id|lp-&gt;bus_num
comma
id|lp-&gt;device
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;, h/w address &quot;
)paren
suffix:semicolon
id|status
op_assign
id|get_hw_addr
c_func
(paren
id|dev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* get the ethernet addr. */
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%2.2x,&bslash;n&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;      which has an Ethernet PROM CRC error.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_else
(brace
r_struct
id|de4x5_private
op_star
id|lp
suffix:semicolon
multiline_comment|/* &n;&t;** Reserve a section of kernel memory for the adapter&n;&t;** private area and the TX/RX descriptor rings.&n;&t;*/
id|dev-&gt;priv
op_assign
(paren
r_void
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|de4x5_private
)paren
op_plus
id|ALIGN
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Align to a longword boundary&n;&t;*/
id|tmp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|dev-&gt;priv
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
(paren
id|u_long
)paren
id|dev-&gt;priv
op_plus
id|ALIGN
)paren
op_amp
op_complement
id|ALIGN
)paren
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|de4x5_private
)paren
)paren
suffix:semicolon
id|lp-&gt;bus
op_assign
id|bus.bus
suffix:semicolon
id|lp-&gt;bus_num
op_assign
id|bus.bus_num
suffix:semicolon
id|lp-&gt;device
op_assign
id|bus.device
suffix:semicolon
id|lp-&gt;chipset
op_assign
id|bus.chipset
suffix:semicolon
id|lp-&gt;cache.priv
op_assign
id|tmp
suffix:semicolon
id|lp-&gt;cache.gepc
op_assign
id|GEP_INIT
suffix:semicolon
id|lp-&gt;asBit
op_assign
id|GEP_SLNK
suffix:semicolon
id|lp-&gt;asPolarity
op_assign
id|GEP_SLNK
suffix:semicolon
id|lp-&gt;asBitValid
op_assign
id|TRUE
suffix:semicolon
id|lp-&gt;timeout
op_assign
op_minus
l_int|1
suffix:semicolon
id|lp-&gt;useSROM
op_assign
id|useSROM
suffix:semicolon
id|lp-&gt;pdev
op_assign
id|pdev
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|lp-&gt;srom
comma
(paren
r_char
op_star
)paren
op_amp
id|bus.srom
comma
r_sizeof
(paren
r_struct
id|de4x5_srom
)paren
)paren
suffix:semicolon
id|lp-&gt;lock
op_assign
(paren
id|spinlock_t
)paren
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|de4x5_parse_params
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Choose correct autosensing in case someone messed up&n;&t;*/
id|lp-&gt;autosense
op_assign
id|lp-&gt;params.autosense
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;chipset
op_ne
id|DC21140
)paren
(brace
r_if
c_cond
(paren
(paren
id|lp-&gt;chipset
op_eq
id|DC21040
)paren
op_logical_and
(paren
id|lp-&gt;params.autosense
op_amp
id|TP_NW
)paren
)paren
(brace
id|lp-&gt;params.autosense
op_assign
id|TP
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|lp-&gt;chipset
op_eq
id|DC21041
)paren
op_logical_and
(paren
id|lp-&gt;params.autosense
op_amp
id|BNC_AUI
)paren
)paren
(brace
id|lp-&gt;params.autosense
op_assign
id|BNC
suffix:semicolon
)brace
)brace
id|lp-&gt;fdx
op_assign
id|lp-&gt;params.fdx
suffix:semicolon
id|sprintf
c_func
(paren
id|lp-&gt;adapter_name
comma
l_string|&quot;%s (%s)&quot;
comma
id|name
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;dma_size
op_assign
(paren
id|NUM_RX_DESC
op_plus
id|NUM_TX_DESC
)paren
op_star
r_sizeof
(paren
r_struct
id|de4x5_desc
)paren
suffix:semicolon
macro_line|#if defined(__alpha__) || defined(__powerpc__) || defined(__sparc_v9__) || defined(DE4X5_DO_MEMCPY)
id|lp-&gt;dma_size
op_add_assign
id|RX_BUFF_SZ
op_star
id|NUM_RX_DESC
op_plus
id|ALIGN
suffix:semicolon
macro_line|#endif
id|lp-&gt;rx_ring
op_assign
id|pci_alloc_consistent
c_func
(paren
id|pdev
comma
id|lp-&gt;dma_size
comma
op_amp
id|lp-&gt;dma_rings
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;rx_ring
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|lp-&gt;cache.priv
)paren
suffix:semicolon
id|lp-&gt;cache.priv
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|lp-&gt;tx_ring
op_assign
id|lp-&gt;rx_ring
op_plus
id|NUM_RX_DESC
suffix:semicolon
multiline_comment|/*&n;&t;** Set up the RX descriptor ring (Intels)&n;&t;** Allocate contiguous receive buffers, long word aligned (Alphas) &n;&t;*/
macro_line|#if !defined(__alpha__) &amp;&amp; !defined(__powerpc__) &amp;&amp; !defined(__sparc_v9__) &amp;&amp; !defined(DE4X5_DO_MEMCPY)
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_RX_DESC
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|des1
op_assign
id|cpu_to_le32
c_func
(paren
id|RX_BUFF_SZ
)paren
suffix:semicolon
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|buf
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|next
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;rx_skb
(braket
id|i
)braket
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
l_int|1
suffix:semicolon
multiline_comment|/* Dummy entry */
)brace
macro_line|#else
(brace
id|dma_addr_t
id|dma_rx_bufs
suffix:semicolon
id|dma_rx_bufs
op_assign
id|lp-&gt;dma_rings
op_plus
(paren
id|NUM_RX_DESC
op_plus
id|NUM_TX_DESC
)paren
op_star
r_sizeof
(paren
r_struct
id|de4x5_desc
)paren
suffix:semicolon
id|dma_rx_bufs
op_assign
(paren
id|dma_rx_bufs
op_plus
id|ALIGN
)paren
op_amp
op_complement
id|ALIGN
suffix:semicolon
id|lp-&gt;rx_bufs
op_assign
(paren
r_char
op_star
)paren
(paren
(paren
(paren
r_int
)paren
(paren
id|lp-&gt;rx_ring
op_plus
id|NUM_RX_DESC
op_plus
id|NUM_TX_DESC
)paren
op_plus
id|ALIGN
)paren
op_amp
op_complement
id|ALIGN
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_RX_DESC
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|des1
op_assign
id|cpu_to_le32
c_func
(paren
id|RX_BUFF_SZ
)paren
suffix:semicolon
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|buf
op_assign
id|cpu_to_le32
c_func
(paren
id|dma_rx_bufs
op_plus
id|i
op_star
id|RX_BUFF_SZ
)paren
suffix:semicolon
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|next
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;rx_skb
(braket
id|i
)braket
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
l_int|1
suffix:semicolon
multiline_comment|/* Dummy entry */
)brace
)brace
macro_line|#endif
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|iobase
comma
(paren
id|lp-&gt;bus
op_eq
id|PCI
ques
c_cond
id|DE4X5_PCI_TOTAL_SIZE
suffix:colon
id|DE4X5_EISA_TOTAL_SIZE
)paren
comma
id|lp-&gt;adapter_name
)paren
suffix:semicolon
id|lp-&gt;rxRingSize
op_assign
id|NUM_RX_DESC
suffix:semicolon
id|lp-&gt;txRingSize
op_assign
id|NUM_TX_DESC
suffix:semicolon
multiline_comment|/* Write the end of list marker to the descriptor lists */
id|lp-&gt;rx_ring
(braket
id|lp-&gt;rxRingSize
op_minus
l_int|1
)braket
dot
id|des1
op_or_assign
id|cpu_to_le32
c_func
(paren
id|RD_RER
)paren
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|lp-&gt;txRingSize
op_minus
l_int|1
)braket
dot
id|des1
op_or_assign
id|cpu_to_le32
c_func
(paren
id|TD_TER
)paren
suffix:semicolon
multiline_comment|/* Tell the adapter where the TX/RX rings are located. */
id|outl
c_func
(paren
id|lp-&gt;dma_rings
comma
id|DE4X5_RRBA
)paren
suffix:semicolon
id|outl
c_func
(paren
id|lp-&gt;dma_rings
op_plus
id|NUM_RX_DESC
op_star
r_sizeof
(paren
r_struct
id|de4x5_desc
)paren
comma
id|DE4X5_TRBA
)paren
suffix:semicolon
multiline_comment|/* Initialise the IRQ mask and Enable/Disable */
id|lp-&gt;irq_mask
op_assign
id|IMR_RIM
op_or
id|IMR_TIM
op_or
id|IMR_TUM
op_or
id|IMR_UNM
suffix:semicolon
id|lp-&gt;irq_en
op_assign
id|IMR_NIM
op_or
id|IMR_AIM
suffix:semicolon
multiline_comment|/* Create a loopback packet frame for later media probing */
id|create_packet
c_func
(paren
id|dev
comma
id|lp-&gt;frame
comma
r_sizeof
(paren
id|lp-&gt;frame
)paren
)paren
suffix:semicolon
multiline_comment|/* Check if the RX overflow bug needs testing for */
id|i
op_assign
id|cfrv
op_amp
l_int|0x000000fe
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lp-&gt;chipset
op_eq
id|DC21140
)paren
op_logical_and
(paren
id|i
op_eq
l_int|0x20
)paren
)paren
(brace
id|lp-&gt;rx_ovf
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Initialise the SROM pointers if possible */
r_if
c_cond
(paren
id|lp-&gt;useSROM
)paren
(brace
id|lp-&gt;state
op_assign
id|INITIALISED
suffix:semicolon
r_if
c_cond
(paren
id|srom_infoleaf_info
c_func
(paren
id|dev
)paren
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|srom_init
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|lp-&gt;state
op_assign
id|CLOSED
suffix:semicolon
multiline_comment|/*&n;&t;** Check for an MII interface&n;&t;*/
r_if
c_cond
(paren
(paren
id|lp-&gt;chipset
op_ne
id|DC21040
)paren
op_logical_and
(paren
id|lp-&gt;chipset
op_ne
id|DC21041
)paren
)paren
(brace
id|mii_get_phy
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#ifndef __sparc_v9__
id|printk
(paren
l_string|&quot;      and requires IRQ%d (provided by %s).&bslash;n&quot;
comma
id|dev-&gt;irq
comma
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;      and requires IRQ%x (provided by %s).&bslash;n&quot;
comma
id|dev-&gt;irq
comma
macro_line|#endif
(paren
(paren
id|lp-&gt;bus
op_eq
id|PCI
)paren
ques
c_cond
l_string|&quot;PCI BIOS&quot;
suffix:colon
l_string|&quot;EISA CNFG&quot;
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|de4x5_debug
op_amp
id|DEBUG_VERSION
)paren
(brace
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
)brace
multiline_comment|/* The DE4X5-specific entries in the device structure. */
id|dev-&gt;open
op_assign
op_amp
id|de4x5_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|de4x5_queue_pkt
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|de4x5_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|de4x5_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
op_amp
id|de4x5_ioctl
suffix:semicolon
id|dev-&gt;mem_start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fill in the generic fields of the device structure. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Let the adapter sleep to save power */
id|yawn
c_func
(paren
id|dev
comma
id|SLEEP
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
"&f;"
r_static
r_int
DECL|function|de4x5_open
id|de4x5_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|s32
id|omr
suffix:semicolon
multiline_comment|/* Allocate the RX buffers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;rxRingSize
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|de4x5_alloc_rx_buff
c_func
(paren
id|dev
comma
id|i
comma
l_int|0
)paren
op_eq
l_int|NULL
)paren
(brace
id|de4x5_free_rx_buffs
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;    ** Wake up the adapter&n;    */
id|yawn
c_func
(paren
id|dev
comma
id|WAKEUP
)paren
suffix:semicolon
multiline_comment|/* &n;    ** Re-initialize the DE4X5... &n;    */
id|status
op_assign
id|de4x5_init
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;lock
op_assign
(paren
id|spinlock_t
)paren
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|lp-&gt;state
op_assign
id|OPEN
suffix:semicolon
id|de4x5_dbg_open
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
(paren
r_void
op_star
)paren
id|de4x5_interrupt
comma
id|SA_SHIRQ
comma
id|lp-&gt;adapter_name
comma
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;de4x5_open(): Requested IRQ%d is busy - attemping FAST/SHARE...&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
id|de4x5_interrupt
comma
id|SA_INTERRUPT
op_or
id|SA_SHIRQ
comma
id|lp-&gt;adapter_name
comma
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n              Cannot get IRQ- reconfigure your hardware.&bslash;n&quot;
)paren
suffix:semicolon
id|disable_ast
c_func
(paren
id|dev
)paren
suffix:semicolon
id|de4x5_free_rx_buffs
c_func
(paren
id|dev
)paren
suffix:semicolon
id|de4x5_free_tx_buffs
c_func
(paren
id|dev
)paren
suffix:semicolon
id|yawn
c_func
(paren
id|dev
comma
id|SLEEP
)paren
suffix:semicolon
id|lp-&gt;state
op_assign
id|CLOSED
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n              Succeeded, but you should reconfigure your hardware to avoid this.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;WARNING: there may be IRQ related problems in heavily loaded systems.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|lp-&gt;interrupt
op_assign
id|UNMASK_INTERRUPTS
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|START_DE4X5
suffix:semicolon
id|de4x5_setup_intr
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de4x5_debug
op_amp
id|DEBUG_OPEN
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;tsts:  0x%08x&bslash;n&quot;
comma
id|inl
c_func
(paren
id|DE4X5_STS
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tbmr:  0x%08x&bslash;n&quot;
comma
id|inl
c_func
(paren
id|DE4X5_BMR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;timr:  0x%08x&bslash;n&quot;
comma
id|inl
c_func
(paren
id|DE4X5_IMR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tomr:  0x%08x&bslash;n&quot;
comma
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tsisr: 0x%08x&bslash;n&quot;
comma
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tsicr: 0x%08x&bslash;n&quot;
comma
id|inl
c_func
(paren
id|DE4X5_SICR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tstrr: 0x%08x&bslash;n&quot;
comma
id|inl
c_func
(paren
id|DE4X5_STRR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tsigr: 0x%08x&bslash;n&quot;
comma
id|inl
c_func
(paren
id|DE4X5_SIGR
)paren
)paren
suffix:semicolon
)brace
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;** Initialize the DE4X5 operating conditions. NB: a chip problem with the&n;** DC21140 requires using perfect filtering mode for that chip. Since I can&squot;t&n;** see why I&squot;d want &gt; 14 multicast addresses, I have changed all chips to use&n;** the perfect filtering mode. Keep the DMA burst length at 8: there seems&n;** to be data corruption problems if it is larger (UDP errors seen from a&n;** ttcp source).&n;*/
r_static
r_int
DECL|function|de4x5_init
id|de4x5_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* Lock out other processes whilst setting up the hardware */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|de4x5_sw_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Autoconfigure the connected port */
id|autoconf_media
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|de4x5_sw_reset
id|de4x5_sw_reset
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|s32
id|bmr
comma
id|omr
suffix:semicolon
multiline_comment|/* Select the MII or SRL port now and RESET the MAC */
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;useSROM
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|id
op_ne
l_int|0
)paren
(brace
id|lp-&gt;infoblock_csr6
op_assign
id|OMR_SDP
op_or
id|OMR_PS
op_or
id|OMR_HBD
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;infoblock_csr6
op_assign
id|OMR_SDP
op_or
id|OMR_TTM
suffix:semicolon
)brace
id|de4x5_switch_mac_port
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;    ** Set the programmable burst length to 8 longwords for all the DC21140&n;    ** Fasternet chips and 4 longwords for all others: DMA errors result&n;    ** without these values. Cache align 16 long.&n;    */
id|bmr
op_assign
(paren
id|lp-&gt;chipset
op_eq
id|DC21140
ques
c_cond
id|PBL_8
suffix:colon
id|PBL_4
)paren
op_or
id|DESC_SKIP_LEN
op_or
id|CACHE_ALIGN
suffix:semicolon
id|bmr
op_or_assign
(paren
(paren
id|lp-&gt;chipset
op_amp
op_complement
l_int|0x00ff
)paren
op_eq
id|DC2114x
ques
c_cond
id|BMR_RML
suffix:colon
l_int|0
)paren
suffix:semicolon
id|outl
c_func
(paren
id|bmr
comma
id|DE4X5_BMR
)paren
suffix:semicolon
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
op_amp
op_complement
id|OMR_PR
suffix:semicolon
multiline_comment|/* Turn off promiscuous mode */
r_if
c_cond
(paren
id|lp-&gt;chipset
op_eq
id|DC21140
)paren
(brace
id|omr
op_or_assign
(paren
id|OMR_SDP
op_or
id|OMR_SB
)paren
suffix:semicolon
)brace
id|lp-&gt;setup_f
op_assign
id|PERFECT
suffix:semicolon
id|outl
c_func
(paren
id|lp-&gt;dma_rings
comma
id|DE4X5_RRBA
)paren
suffix:semicolon
id|outl
c_func
(paren
id|lp-&gt;dma_rings
op_plus
id|NUM_RX_DESC
op_star
r_sizeof
(paren
r_struct
id|de4x5_desc
)paren
comma
id|DE4X5_TRBA
)paren
suffix:semicolon
id|lp-&gt;rx_new
op_assign
id|lp-&gt;rx_old
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tx_new
op_assign
id|lp-&gt;tx_old
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;rxRingSize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status
op_assign
id|cpu_to_le32
c_func
(paren
id|R_OWN
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;txRingSize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|status
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Build the setup frame depending on filtering mode */
id|SetMulticastFilter
c_func
(paren
id|dev
)paren
suffix:semicolon
id|load_packet
c_func
(paren
id|dev
comma
id|lp-&gt;setup_frame
comma
id|PERFECT_F
op_or
id|TD_SET
op_or
id|SETUP_FRAME_LEN
comma
(paren
r_struct
id|sk_buff
op_star
)paren
l_int|1
)paren
suffix:semicolon
id|outl
c_func
(paren
id|omr
op_or
id|OMR_ST
comma
id|DE4X5_OMR
)paren
suffix:semicolon
multiline_comment|/* Poll for setup frame completion (adapter interrupts are disabled now) */
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Ensure timer interrupts */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
l_int|500
)paren
op_logical_and
(paren
id|j
op_eq
l_int|0
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Upto 500ms delay */
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s32
)paren
id|le32_to_cpu
c_func
(paren
id|lp-&gt;tx_ring
(braket
id|lp-&gt;tx_new
)braket
dot
id|status
)paren
op_ge
l_int|0
)paren
id|j
op_assign
l_int|1
suffix:semicolon
)brace
id|outl
c_func
(paren
id|omr
comma
id|DE4X5_OMR
)paren
suffix:semicolon
multiline_comment|/* Stop everything! */
r_if
c_cond
(paren
id|j
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Setup frame timed out, status %08x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inl
c_func
(paren
id|DE4X5_STS
)paren
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
id|lp-&gt;tx_new
op_assign
(paren
op_increment
id|lp-&gt;tx_new
)paren
op_mod
id|lp-&gt;txRingSize
suffix:semicolon
id|lp-&gt;tx_old
op_assign
id|lp-&gt;tx_new
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/* &n;** Writes a socket buffer address to the next available transmit descriptor.&n;*/
r_static
r_int
DECL|function|de4x5_queue_pkt
id|de4x5_queue_pkt
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
id|u_long
id|flags
op_assign
l_int|0
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_enable
op_eq
id|NO
)paren
(brace
multiline_comment|/* Cannot send for now */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;    ** Clean out the TX ring asynchronously to interrupts - sometimes the&n;    ** interrupts are lost by delayed descriptor status updates relative to&n;    ** the irq assertion, especially with a busy PCI bus.&n;    */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|de4x5_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Test if cache is already locked - requeue skb if so */
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|lp-&gt;cache.lock
)paren
op_logical_and
op_logical_neg
id|lp-&gt;interrupt
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Transmit descriptor ring full or stale skb */
r_if
c_cond
(paren
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
op_logical_or
(paren
id|u_long
)paren
id|lp-&gt;tx_skb
(braket
id|lp-&gt;tx_new
)braket
OG
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;interrupt
)paren
(brace
id|de4x5_putb_cache
c_func
(paren
id|dev
comma
id|skb
)paren
suffix:semicolon
multiline_comment|/* Requeue the buffer */
)brace
r_else
(brace
id|de4x5_put_cache
c_func
(paren
id|dev
comma
id|skb
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|de4x5_debug
op_amp
id|DEBUG_TX
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: transmit busy, lost media or stale skb found:&bslash;n  STS:%08x&bslash;n  tbusy:%d&bslash;n  IMR:%08x&bslash;n  OMR:%08x&bslash;n Stale skb: %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inl
c_func
(paren
id|DE4X5_STS
)paren
comma
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
comma
id|inl
c_func
(paren
id|DE4X5_IMR
)paren
comma
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
comma
(paren
(paren
id|u_long
)paren
id|lp-&gt;tx_skb
(braket
id|lp-&gt;tx_new
)braket
OG
l_int|1
)paren
ques
c_cond
l_string|&quot;YES&quot;
suffix:colon
l_string|&quot;NO&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|skb-&gt;len
OG
l_int|0
)paren
(brace
multiline_comment|/* If we already have stuff queued locally, use that first */
r_if
c_cond
(paren
id|lp-&gt;cache.skb
op_logical_and
op_logical_neg
id|lp-&gt;interrupt
)paren
(brace
id|de4x5_put_cache
c_func
(paren
id|dev
comma
id|skb
)paren
suffix:semicolon
id|skb
op_assign
id|de4x5_get_cache
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|skb
op_logical_and
op_logical_neg
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
op_logical_and
(paren
id|u_long
)paren
id|lp-&gt;tx_skb
(braket
id|lp-&gt;tx_new
)braket
op_le
l_int|1
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|load_packet
c_func
(paren
id|dev
comma
id|skb-&gt;data
comma
id|TD_IC
op_or
id|TD_LS
op_or
id|TD_FS
op_or
id|skb-&gt;len
comma
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|outl
c_func
(paren
id|POLL_DEMAND
comma
id|DE4X5_TPD
)paren
suffix:semicolon
multiline_comment|/* Start the TX */
id|lp-&gt;tx_new
op_assign
(paren
op_increment
id|lp-&gt;tx_new
)paren
op_mod
id|lp-&gt;txRingSize
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|TX_BUFFS_AVAIL
)paren
(brace
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Another pkt may be queued */
)brace
id|skb
op_assign
id|de4x5_get_cache
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb
)paren
id|de4x5_putb_cache
c_func
(paren
id|dev
comma
id|skb
)paren
suffix:semicolon
)brace
id|lp-&gt;cache.lock
op_assign
l_int|0
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;** The DE4X5 interrupt handler. &n;** &n;** I/O Read/Writes through intermediate PCI bridges are never &squot;posted&squot;,&n;** so that the asserted interrupt always has some real data to work with -&n;** if these I/O accesses are ever changed to memory accesses, ensure the&n;** STS write is read immediately to complete the transaction if the adapter&n;** is not on bus 0. Lost interrupts can still occur when the PCI bus load&n;** is high and descriptor status bits cannot be set before the associated&n;** interrupt is asserted and this routine entered.&n;*/
r_static
r_void
DECL|function|de4x5_interrupt
id|de4x5_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
r_struct
id|de4x5_private
op_star
id|lp
suffix:semicolon
id|s32
id|imr
comma
id|omr
comma
id|sts
comma
id|limit
suffix:semicolon
id|u_long
id|iobase
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;de4x5_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|DISABLE_IRQs
suffix:semicolon
multiline_comment|/* Ensure non re-entrancy */
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|MASK_INTERRUPTS
comma
(paren
r_void
op_star
)paren
op_amp
id|lp-&gt;interrupt
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Re-entering the interrupt handler.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|limit
op_assign
l_int|0
suffix:semicolon
id|limit
OL
l_int|8
suffix:semicolon
id|limit
op_increment
)paren
(brace
id|sts
op_assign
id|inl
c_func
(paren
id|DE4X5_STS
)paren
suffix:semicolon
multiline_comment|/* Read IRQ status */
id|outl
c_func
(paren
id|sts
comma
id|DE4X5_STS
)paren
suffix:semicolon
multiline_comment|/* Reset the board interrupts */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sts
op_amp
id|lp-&gt;irq_mask
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* All done */
r_if
c_cond
(paren
id|sts
op_amp
(paren
id|STS_RI
op_or
id|STS_RU
)paren
)paren
multiline_comment|/* Rx interrupt (packet[s] arrived) */
id|de4x5_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sts
op_amp
(paren
id|STS_TI
op_or
id|STS_TU
)paren
)paren
multiline_comment|/* Tx interrupt (packet sent) */
id|de4x5_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sts
op_amp
id|STS_LNF
)paren
(brace
multiline_comment|/* TP Link has failed */
id|lp-&gt;irq_mask
op_and_assign
op_complement
id|IMR_LFM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sts
op_amp
id|STS_UNF
)paren
(brace
multiline_comment|/* Transmit underrun */
id|de4x5_txur
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sts
op_amp
id|STS_SE
)paren
(brace
multiline_comment|/* Bus Error */
id|STOP_DE4X5
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Fatal bus error occurred, sts=%#8x, device stopped.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|sts
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Load the TX ring with any locally stored packets */
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|lp-&gt;cache.lock
)paren
)paren
(brace
r_while
c_loop
(paren
id|lp-&gt;cache.skb
op_logical_and
op_logical_neg
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
op_logical_and
id|lp-&gt;tx_enable
)paren
(brace
id|de4x5_queue_pkt
c_func
(paren
id|de4x5_get_cache
c_func
(paren
id|dev
)paren
comma
id|dev
)paren
suffix:semicolon
)brace
id|lp-&gt;cache.lock
op_assign
l_int|0
suffix:semicolon
)brace
id|lp-&gt;interrupt
op_assign
id|UNMASK_INTERRUPTS
suffix:semicolon
id|ENABLE_IRQs
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|de4x5_rx
id|de4x5_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|entry
suffix:semicolon
id|s32
id|status
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|lp-&gt;rx_new
suffix:semicolon
(paren
id|s32
)paren
id|le32_to_cpu
c_func
(paren
id|lp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|status
)paren
op_ge
l_int|0
suffix:semicolon
id|entry
op_assign
id|lp-&gt;rx_new
)paren
(brace
id|status
op_assign
(paren
id|s32
)paren
id|le32_to_cpu
c_func
(paren
id|lp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;rx_ovf
)paren
(brace
r_if
c_cond
(paren
id|inl
c_func
(paren
id|DE4X5_MFC
)paren
op_amp
id|MFC_FOCM
)paren
(brace
id|de4x5_rx_ovfc
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|status
op_amp
id|RD_FS
)paren
(brace
multiline_comment|/* Remember the start of frame */
id|lp-&gt;rx_old
op_assign
id|entry
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|RD_LS
)paren
(brace
multiline_comment|/* Valid frame status */
r_if
c_cond
(paren
id|lp-&gt;tx_enable
)paren
id|lp-&gt;linkOK
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RD_ES
)paren
(brace
multiline_comment|/* There was an error. */
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
multiline_comment|/* Update the error stats. */
r_if
c_cond
(paren
id|status
op_amp
(paren
id|RD_RF
op_or
id|RD_TL
)paren
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RD_CE
)paren
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RD_OF
)paren
id|lp-&gt;stats.rx_fifo_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RD_TL
)paren
id|lp-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RD_RF
)paren
id|lp-&gt;pktStats.rx_runt_frames
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RD_CS
)paren
id|lp-&gt;pktStats.rx_collision
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RD_DB
)paren
id|lp-&gt;pktStats.rx_dribble
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RD_OF
)paren
id|lp-&gt;pktStats.rx_overflow
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* A valid frame received */
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|pkt_len
op_assign
(paren
r_int
)paren
(paren
id|le32_to_cpu
c_func
(paren
id|lp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|status
)paren
op_rshift
l_int|16
)paren
op_minus
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|de4x5_alloc_rx_buff
c_func
(paren
id|dev
comma
id|entry
comma
id|pkt_len
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Insufficient memory; nuking packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
)brace
r_else
(brace
id|de4x5_dbg_rx
c_func
(paren
id|skb
comma
id|pkt_len
)paren
suffix:semicolon
multiline_comment|/* Push up the protocol stack */
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Update stats */
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.rx_bytes
op_add_assign
id|pkt_len
suffix:semicolon
id|de4x5_local_stats
c_func
(paren
id|dev
comma
id|skb-&gt;data
comma
id|pkt_len
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Change buffer ownership for this frame, back to the adapter */
r_for
c_loop
(paren
suffix:semicolon
id|lp-&gt;rx_old
op_ne
id|entry
suffix:semicolon
id|lp-&gt;rx_old
op_assign
(paren
op_increment
id|lp-&gt;rx_old
)paren
op_mod
id|lp-&gt;rxRingSize
)paren
(brace
id|lp-&gt;rx_ring
(braket
id|lp-&gt;rx_old
)braket
dot
id|status
op_assign
id|cpu_to_le32
c_func
(paren
id|R_OWN
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
id|lp-&gt;rx_ring
(braket
id|entry
)braket
dot
id|status
op_assign
id|cpu_to_le32
c_func
(paren
id|R_OWN
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Update entry information&n;&t;*/
id|lp-&gt;rx_new
op_assign
(paren
op_increment
id|lp-&gt;rx_new
)paren
op_mod
id|lp-&gt;rxRingSize
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|de4x5_free_tx_buff
id|de4x5_free_tx_buff
c_func
(paren
r_struct
id|de4x5_private
op_star
id|lp
comma
r_int
id|entry
)paren
(brace
id|pci_unmap_single
c_func
(paren
id|lp-&gt;pdev
comma
id|le32_to_cpu
c_func
(paren
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|buf
)paren
comma
id|le32_to_cpu
c_func
(paren
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|des1
)paren
op_amp
id|TD_TBS1
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|u_long
)paren
id|lp-&gt;tx_skb
(braket
id|entry
)braket
OG
l_int|1
)paren
id|dev_kfree_skb_irq
c_func
(paren
id|lp-&gt;tx_skb
(braket
id|entry
)braket
)paren
suffix:semicolon
id|lp-&gt;tx_skb
(braket
id|entry
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;** Buffer sent - check for TX buffer errors.&n;*/
r_static
r_int
DECL|function|de4x5_tx
id|de4x5_tx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|entry
suffix:semicolon
id|s32
id|status
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|lp-&gt;tx_old
suffix:semicolon
id|entry
op_ne
id|lp-&gt;tx_new
suffix:semicolon
id|entry
op_assign
id|lp-&gt;tx_old
)paren
(brace
id|status
op_assign
(paren
id|s32
)paren
id|le32_to_cpu
c_func
(paren
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
multiline_comment|/* Buffer not sent yet */
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_ne
l_int|0x7fffffff
)paren
(brace
multiline_comment|/* Not setup frame */
r_if
c_cond
(paren
id|status
op_amp
id|TD_ES
)paren
(brace
multiline_comment|/* An error happened */
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_NC
)paren
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_LC
)paren
id|lp-&gt;stats.tx_window_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_UF
)paren
id|lp-&gt;stats.tx_fifo_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_EC
)paren
id|lp-&gt;pktStats.excessive_collisions
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|TD_DE
)paren
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|TX_PKT_PENDING
)paren
(brace
id|outl
c_func
(paren
id|POLL_DEMAND
comma
id|DE4X5_TPD
)paren
suffix:semicolon
multiline_comment|/* Restart a stalled TX */
)brace
)brace
r_else
(brace
multiline_comment|/* Packet sent */
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_enable
)paren
id|lp-&gt;linkOK
op_increment
suffix:semicolon
)brace
multiline_comment|/* Update the collision counter */
id|lp-&gt;stats.collisions
op_add_assign
(paren
(paren
id|status
op_amp
id|TD_EC
)paren
ques
c_cond
l_int|16
suffix:colon
(paren
(paren
id|status
op_amp
id|TD_CC
)paren
op_rshift
l_int|3
)paren
)paren
suffix:semicolon
multiline_comment|/* Free the buffer. */
r_if
c_cond
(paren
id|lp-&gt;tx_skb
(braket
id|entry
)braket
op_ne
l_int|NULL
)paren
id|de4x5_free_tx_buff
c_func
(paren
id|lp
comma
id|entry
)paren
suffix:semicolon
)brace
multiline_comment|/* Update all the pointers */
id|lp-&gt;tx_old
op_assign
(paren
op_increment
id|lp-&gt;tx_old
)paren
op_mod
id|lp-&gt;txRingSize
suffix:semicolon
)brace
multiline_comment|/* Any resources available? */
r_if
c_cond
(paren
id|TX_BUFFS_AVAIL
op_logical_and
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;interrupt
)paren
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_else
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|de4x5_ast
id|de4x5_ast
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|next_tick
op_assign
id|DE4X5_AUTOSENSE_MS
suffix:semicolon
id|disable_ast
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;useSROM
)paren
(brace
id|next_tick
op_assign
id|srom_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;chipset
op_eq
id|DC21140
)paren
(brace
id|next_tick
op_assign
id|dc21140m_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;chipset
op_eq
id|DC21041
)paren
(brace
id|next_tick
op_assign
id|dc21041_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;chipset
op_eq
id|DC21040
)paren
(brace
id|next_tick
op_assign
id|dc21040_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|lp-&gt;linkOK
op_assign
l_int|0
suffix:semicolon
id|enable_ast
c_func
(paren
id|dev
comma
id|next_tick
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|de4x5_txur
id|de4x5_txur
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|omr
suffix:semicolon
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|omr
op_amp
id|OMR_SF
)paren
op_logical_or
(paren
id|lp-&gt;chipset
op_eq
id|DC21041
)paren
op_logical_or
(paren
id|lp-&gt;chipset
op_eq
id|DC21040
)paren
)paren
(brace
id|omr
op_and_assign
op_complement
(paren
id|OMR_ST
op_or
id|OMR_SR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|omr
comma
id|DE4X5_OMR
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inl
c_func
(paren
id|DE4X5_STS
)paren
op_amp
id|STS_TS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|omr
op_amp
id|OMR_TR
)paren
OL
id|OMR_TR
)paren
(brace
id|omr
op_add_assign
l_int|0x4000
suffix:semicolon
)brace
r_else
(brace
id|omr
op_or_assign
id|OMR_SF
suffix:semicolon
)brace
id|outl
c_func
(paren
id|omr
op_or
id|OMR_ST
op_or
id|OMR_SR
comma
id|DE4X5_OMR
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|de4x5_rx_ovfc
id|de4x5_rx_ovfc
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|omr
suffix:semicolon
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|omr
op_amp
op_complement
id|OMR_SR
comma
id|DE4X5_OMR
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inl
c_func
(paren
id|DE4X5_STS
)paren
op_amp
id|STS_RS
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
(paren
id|s32
)paren
id|le32_to_cpu
c_func
(paren
id|lp-&gt;rx_ring
(braket
id|lp-&gt;rx_new
)braket
dot
id|status
)paren
op_ge
l_int|0
suffix:semicolon
)paren
(brace
id|lp-&gt;rx_ring
(braket
id|lp-&gt;rx_new
)braket
dot
id|status
op_assign
id|cpu_to_le32
c_func
(paren
id|R_OWN
)paren
suffix:semicolon
id|lp-&gt;rx_new
op_assign
(paren
op_increment
id|lp-&gt;rx_new
op_mod
id|lp-&gt;rxRingSize
)paren
suffix:semicolon
)brace
id|outl
c_func
(paren
id|omr
comma
id|DE4X5_OMR
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|de4x5_close
id|de4x5_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|s32
id|imr
comma
id|omr
suffix:semicolon
id|disable_ast
c_func
(paren
id|dev
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de4x5_debug
op_amp
id|DEBUG_CLOSE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Shutting down ethercard, status was %8.8x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inl
c_func
(paren
id|DE4X5_STS
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;    ** We stop the DE4X5 here... mask interrupts and stop TX &amp; RX&n;    */
id|DISABLE_IRQs
suffix:semicolon
id|STOP_DE4X5
suffix:semicolon
multiline_comment|/* Free the associated irq */
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|lp-&gt;state
op_assign
id|CLOSED
suffix:semicolon
multiline_comment|/* Free any socket buffers */
id|de4x5_free_rx_buffs
c_func
(paren
id|dev
)paren
suffix:semicolon
id|de4x5_free_tx_buffs
c_func
(paren
id|dev
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
multiline_comment|/* Put the adapter to sleep to save power */
id|yawn
c_func
(paren
id|dev
comma
id|SLEEP
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|net_device_stats
op_star
DECL|function|de4x5_get_stats
id|de4x5_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp-&gt;stats.rx_missed_errors
op_assign
(paren
r_int
)paren
(paren
id|inl
c_func
(paren
id|DE4X5_MFC
)paren
op_amp
(paren
id|MFC_OVFL
op_or
id|MFC_CNTR
)paren
)paren
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
r_static
r_void
DECL|function|de4x5_local_stats
id|de4x5_local_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|pkt_len
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|DE4X5_PKT_STAT_SZ
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pkt_len
OL
(paren
id|i
op_star
id|DE4X5_PKT_BIN_SZ
)paren
)paren
(brace
id|lp-&gt;pktStats.bins
(braket
id|i
)braket
op_increment
suffix:semicolon
id|i
op_assign
id|DE4X5_PKT_STAT_SZ
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_amp
l_int|0x01
)paren
(brace
multiline_comment|/* Multicast/Broadcast */
r_if
c_cond
(paren
(paren
op_star
(paren
id|s32
op_star
)paren
op_amp
id|buf
(braket
l_int|0
)braket
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
op_star
(paren
id|s16
op_star
)paren
op_amp
id|buf
(braket
l_int|4
)braket
op_eq
op_minus
l_int|1
)paren
)paren
(brace
id|lp-&gt;pktStats.broadcast
op_increment
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;pktStats.multicast
op_increment
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
op_star
(paren
id|s32
op_star
)paren
op_amp
id|buf
(braket
l_int|0
)braket
op_eq
op_star
(paren
id|s32
op_star
)paren
op_amp
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
)paren
op_logical_and
(paren
op_star
(paren
id|s16
op_star
)paren
op_amp
id|buf
(braket
l_int|4
)braket
op_eq
op_star
(paren
id|s16
op_star
)paren
op_amp
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
)paren
)paren
(brace
id|lp-&gt;pktStats.unicast
op_increment
suffix:semicolon
)brace
id|lp-&gt;pktStats.bins
(braket
l_int|0
)braket
op_increment
suffix:semicolon
multiline_comment|/* Duplicates stats.rx_packets */
r_if
c_cond
(paren
id|lp-&gt;pktStats.bins
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Reset counters */
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|lp-&gt;pktStats
comma
l_int|0
comma
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** Removes the TD_IC flag from previous descriptor to improve TX performance.&n;** If the flag is changed on a descriptor that is being read by the hardware,&n;** I assume PCI transaction ordering will mean you are either successful or&n;** just miss asserting the change to the hardware. Anyway you&squot;re messing with&n;** a descriptor you don&squot;t own, but this shouldn&squot;t kill the chip provided&n;** the descriptor register is read only to the hardware.&n;*/
r_static
r_void
DECL|function|load_packet
id|load_packet
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_char
op_star
id|buf
comma
id|u32
id|flags
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|entry
op_assign
(paren
id|lp-&gt;tx_new
ques
c_cond
id|lp-&gt;tx_new
op_minus
l_int|1
suffix:colon
id|lp-&gt;txRingSize
op_minus
l_int|1
)paren
suffix:semicolon
id|dma_addr_t
id|buf_dma
op_assign
id|pci_map_single
c_func
(paren
id|lp-&gt;pdev
comma
id|buf
comma
id|flags
op_amp
id|TD_TBS1
comma
id|PCI_DMA_TODEVICE
)paren
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|lp-&gt;tx_new
)braket
dot
id|buf
op_assign
id|cpu_to_le32
c_func
(paren
id|buf_dma
)paren
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|lp-&gt;tx_new
)braket
dot
id|des1
op_and_assign
id|cpu_to_le32
c_func
(paren
id|TD_TER
)paren
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|lp-&gt;tx_new
)braket
dot
id|des1
op_or_assign
id|cpu_to_le32
c_func
(paren
id|flags
)paren
suffix:semicolon
id|lp-&gt;tx_skb
(braket
id|lp-&gt;tx_new
)braket
op_assign
id|skb
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|entry
)braket
dot
id|des1
op_and_assign
id|cpu_to_le32
c_func
(paren
op_complement
id|TD_IC
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|lp-&gt;tx_new
)braket
dot
id|status
op_assign
id|cpu_to_le32
c_func
(paren
id|T_OWN
)paren
suffix:semicolon
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** Set or clear the multicast filter for this adaptor.&n;*/
r_static
r_void
DECL|function|set_multicast_list
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
multiline_comment|/* First, double check that the adapter is open */
r_if
c_cond
(paren
id|lp-&gt;state
op_eq
id|OPEN
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/* set promiscuous mode */
id|u32
id|omr
suffix:semicolon
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
id|omr
op_or_assign
id|OMR_PR
suffix:semicolon
id|outl
c_func
(paren
id|omr
comma
id|DE4X5_OMR
)paren
suffix:semicolon
)brace
r_else
(brace
id|SetMulticastFilter
c_func
(paren
id|dev
)paren
suffix:semicolon
id|load_packet
c_func
(paren
id|dev
comma
id|lp-&gt;setup_frame
comma
id|TD_IC
op_or
id|PERFECT_F
op_or
id|TD_SET
op_or
id|SETUP_FRAME_LEN
comma
(paren
r_struct
id|sk_buff
op_star
)paren
l_int|1
)paren
suffix:semicolon
id|lp-&gt;tx_new
op_assign
(paren
op_increment
id|lp-&gt;tx_new
)paren
op_mod
id|lp-&gt;txRingSize
suffix:semicolon
id|outl
c_func
(paren
id|POLL_DEMAND
comma
id|DE4X5_TPD
)paren
suffix:semicolon
multiline_comment|/* Start the TX */
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** Calculate the hash code and update the logical address filter&n;** from a list of ethernet multicast addresses.&n;** Little endian crc one liner from Matt Thomas, DEC.&n;*/
r_static
r_void
DECL|function|SetMulticastFilter
id|SetMulticastFilter
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|bit
comma
id|byte
suffix:semicolon
id|u16
id|hashcode
suffix:semicolon
id|u32
id|omr
comma
id|crc
comma
id|poly
op_assign
id|CRC_POLYNOMIAL_LE
suffix:semicolon
r_char
op_star
id|pa
suffix:semicolon
r_int
r_char
op_star
id|addrs
suffix:semicolon
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
id|omr
op_and_assign
op_complement
(paren
id|OMR_PR
op_or
id|OMR_PM
)paren
suffix:semicolon
id|pa
op_assign
id|build_setup_frame
c_func
(paren
id|dev
comma
id|ALL
)paren
suffix:semicolon
multiline_comment|/* Build the basic frame */
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_or
(paren
id|dev-&gt;mc_count
OG
l_int|14
)paren
)paren
(brace
id|omr
op_or_assign
id|OMR_PM
suffix:semicolon
multiline_comment|/* Pass all multicasts */
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;setup_f
op_eq
id|HASH_PERF
)paren
(brace
multiline_comment|/* Hash Filtering */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;mc_count
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* for each address in the list */
id|addrs
op_assign
id|dmi-&gt;dmi_addr
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|addrs
op_amp
l_int|0x01
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* multicast address? */
id|crc
op_assign
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* init CRC for each address */
r_for
c_loop
(paren
id|byte
op_assign
l_int|0
suffix:semicolon
id|byte
OL
id|ETH_ALEN
suffix:semicolon
id|byte
op_increment
)paren
(brace
multiline_comment|/* for each address byte */
multiline_comment|/* process each address bit */
r_for
c_loop
(paren
id|bit
op_assign
op_star
id|addrs
op_increment
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
comma
id|bit
op_rshift_assign
l_int|1
)paren
(brace
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|1
)paren
op_xor
(paren
(paren
(paren
id|crc
op_xor
id|bit
)paren
op_amp
l_int|0x01
)paren
ques
c_cond
id|poly
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|hashcode
op_assign
id|crc
op_amp
id|HASH_BITS
suffix:semicolon
multiline_comment|/* hashcode is 9 LSb of CRC */
id|byte
op_assign
id|hashcode
op_rshift
l_int|3
suffix:semicolon
multiline_comment|/* bit[3-8] -&gt; byte in filter */
id|bit
op_assign
l_int|1
op_lshift
(paren
id|hashcode
op_amp
l_int|0x07
)paren
suffix:semicolon
multiline_comment|/* bit[0-2] -&gt; bit in byte */
id|byte
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* calc offset into setup frame */
r_if
c_cond
(paren
id|byte
op_amp
l_int|0x02
)paren
(brace
id|byte
op_sub_assign
l_int|1
suffix:semicolon
)brace
id|lp-&gt;setup_frame
(braket
id|byte
)braket
op_or_assign
id|bit
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* Perfect filtering */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|dev-&gt;mc_count
suffix:semicolon
id|j
op_increment
)paren
(brace
id|addrs
op_assign
id|dmi-&gt;dmi_addr
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
(paren
id|pa
op_plus
(paren
id|i
op_amp
l_int|1
)paren
)paren
op_assign
op_star
id|addrs
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
l_int|0x01
)paren
id|pa
op_add_assign
l_int|4
suffix:semicolon
)brace
)brace
)brace
id|outl
c_func
(paren
id|omr
comma
id|DE4X5_OMR
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if !defined(__sparc_v9__) &amp;&amp; !defined(__powerpc__) &amp;&amp; !defined(__alpha__)
multiline_comment|/*&n;** EISA bus I/O device probe. Probe from slot 1 since slot 0 is usually&n;** the motherboard. Upto 15 EISA devices are supported.&n;*/
r_static
r_void
id|__init
DECL|function|eisa_probe
id|eisa_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|ioaddr
)paren
(brace
r_int
id|i
comma
id|maxSlots
comma
id|status
comma
id|device
suffix:semicolon
id|u_char
id|irq
suffix:semicolon
id|u_short
id|vendor
suffix:semicolon
id|u32
id|cfid
suffix:semicolon
id|u_long
id|iobase
suffix:semicolon
r_struct
id|bus_type
op_star
id|lp
op_assign
op_amp
id|bus
suffix:semicolon
r_char
id|name
(braket
id|DE4X5_STRLEN
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lastEISA
op_eq
id|MAX_EISA_SLOTS
)paren
r_return
suffix:semicolon
multiline_comment|/* No more EISA devices to search */
id|lp-&gt;bus
op_assign
id|EISA
suffix:semicolon
r_if
c_cond
(paren
id|ioaddr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Autoprobing */
id|iobase
op_assign
id|EISA_SLOT_INC
suffix:semicolon
multiline_comment|/* Get the first slot address */
id|i
op_assign
l_int|1
suffix:semicolon
id|maxSlots
op_assign
id|MAX_EISA_SLOTS
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Probe a specific location */
id|iobase
op_assign
id|ioaddr
suffix:semicolon
id|i
op_assign
(paren
id|ioaddr
op_rshift
l_int|12
)paren
suffix:semicolon
id|maxSlots
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|status
op_assign
op_minus
id|ENODEV
suffix:semicolon
(paren
id|i
OL
id|maxSlots
)paren
op_logical_and
(paren
id|dev
op_ne
l_int|NULL
)paren
suffix:semicolon
id|i
op_increment
comma
id|iobase
op_add_assign
id|EISA_SLOT_INC
)paren
(brace
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|iobase
comma
id|DE4X5_EISA_TOTAL_SIZE
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|EISA_signature
c_func
(paren
id|name
comma
id|EISA_ID
)paren
)paren
r_continue
suffix:semicolon
id|cfid
op_assign
(paren
id|u32
)paren
id|inl
c_func
(paren
id|PCI_CFID
)paren
suffix:semicolon
id|cfrv
op_assign
(paren
id|u_short
)paren
id|inl
c_func
(paren
id|PCI_CFRV
)paren
suffix:semicolon
id|device
op_assign
(paren
id|cfid
op_rshift
l_int|8
)paren
op_amp
l_int|0x00ffff00
suffix:semicolon
id|vendor
op_assign
(paren
id|u_short
)paren
id|cfid
suffix:semicolon
multiline_comment|/* Read the EISA Configuration Registers */
id|irq
op_assign
id|inb
c_func
(paren
id|EISA_REG0
)paren
suffix:semicolon
id|irq
op_assign
id|de4x5_irq
(braket
(paren
id|irq
op_rshift
l_int|1
)paren
op_amp
l_int|0x03
)braket
suffix:semicolon
r_if
c_cond
(paren
id|is_DC2114x
)paren
(brace
id|device
op_assign
(paren
(paren
id|cfrv
op_amp
id|CFRV_RN
)paren
OL
id|DC2114x_BRK
ques
c_cond
id|DC21142
suffix:colon
id|DC21143
)paren
suffix:semicolon
)brace
id|lp-&gt;chipset
op_assign
id|device
suffix:semicolon
multiline_comment|/* Write the PCI Configuration Registers */
id|outl
c_func
(paren
id|PCI_COMMAND_IO
op_or
id|PCI_COMMAND_MASTER
comma
id|PCI_CFCS
)paren
suffix:semicolon
id|outl
c_func
(paren
l_int|0x00006000
comma
id|PCI_CFLT
)paren
suffix:semicolon
id|outl
c_func
(paren
id|iobase
comma
id|PCI_CBIO
)paren
suffix:semicolon
id|DevicePresent
c_func
(paren
id|EISA_APROM
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|de4x5_hw_init
c_func
(paren
id|dev
comma
id|iobase
comma
l_int|NULL
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|num_de4x5s
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|loading_module
)paren
id|link_modules
c_func
(paren
id|lastModule
comma
id|dev
)paren
suffix:semicolon
id|lastEISA
op_assign
id|i
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ioaddr
op_eq
l_int|0
)paren
id|lastEISA
op_assign
id|i
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif          /* !(__sparc_v9__) &amp;&amp; !(__powerpc__) &amp;&amp; !defined(__alpha__) */
multiline_comment|/*&n;** PCI bus I/O device probe&n;** NB: PCI I/O accesses and Bus Mastering are enabled by the PCI BIOS, not&n;** the driver. Some PCI BIOS&squot;s, pre V2.1, need the slot + features to be&n;** enabled by the user first in the set up utility. Hence we just check for&n;** enabled features and silently ignore the card if they&squot;re not.&n;**&n;** STOP PRESS: Some BIOS&squot;s __require__ the driver to enable the bus mastering&n;** bit. Here, check for I/O accesses and then set BM. If you put the card in&n;** a non BM slot, you&squot;re on your own (and complain to the PC vendor that your&n;** PC doesn&squot;t conform to the PCI standard)!&n;**&n;** This function is only compatible with the *latest* 2.1.x kernels. For 2.0.x&n;** kernels use the V0.535[n] drivers.&n;*/
DECL|macro|PCI_LAST_DEV
mdefine_line|#define PCI_LAST_DEV  32
r_static
r_void
id|__init
DECL|function|pci_probe
id|pci_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|ioaddr
)paren
(brace
id|u_char
id|pb
comma
id|pbus
comma
id|dev_num
comma
id|dnum
comma
id|timer
suffix:semicolon
id|u_short
id|vendor
comma
id|index
comma
id|status
suffix:semicolon
id|u_int
id|irq
op_assign
l_int|0
comma
id|device
comma
r_class
op_assign
id|DE4X5_CLASS_CODE
suffix:semicolon
id|u_long
id|iobase
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear upper 32 bits in Alphas */
r_struct
id|bus_type
op_star
id|lp
op_assign
op_amp
id|bus
suffix:semicolon
r_if
c_cond
(paren
id|lastPCI
op_eq
id|NO_MORE_PCI
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibios_present
c_func
(paren
)paren
)paren
(brace
id|lastPCI
op_assign
id|NO_MORE_PCI
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* No PCI bus in this machine! */
)brace
id|lp-&gt;bus
op_assign
id|PCI
suffix:semicolon
id|lp-&gt;bus_num
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ioaddr
OL
l_int|0x1000
)paren
op_logical_and
id|loading_module
)paren
(brace
id|pbus
op_assign
(paren
id|u_short
)paren
(paren
id|ioaddr
op_rshift
l_int|8
)paren
suffix:semicolon
id|dnum
op_assign
(paren
id|u_short
)paren
(paren
id|ioaddr
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
r_else
(brace
id|pbus
op_assign
l_int|0
suffix:semicolon
id|dnum
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|index
op_assign
id|lastPCI
op_plus
l_int|1
suffix:semicolon
(paren
id|pdev
op_assign
id|pci_find_class
c_func
(paren
r_class
comma
id|pdev
)paren
)paren
op_ne
l_int|NULL
suffix:semicolon
id|index
op_increment
)paren
(brace
id|dev_num
op_assign
id|PCI_SLOT
c_func
(paren
id|pdev-&gt;devfn
)paren
suffix:semicolon
id|pb
op_assign
id|pdev-&gt;bus-&gt;number
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pbus
op_logical_or
id|dnum
)paren
op_logical_and
(paren
(paren
id|pbus
op_ne
id|pb
)paren
op_logical_or
(paren
id|dnum
op_ne
id|dev_num
)paren
)paren
)paren
r_continue
suffix:semicolon
id|vendor
op_assign
id|pdev-&gt;vendor
suffix:semicolon
id|device
op_assign
id|pdev-&gt;device
op_lshift
l_int|8
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|is_DC21040
op_logical_or
id|is_DC21041
op_logical_or
id|is_DC21140
op_logical_or
id|is_DC2114x
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Search for an SROM on this bus */
r_if
c_cond
(paren
id|lp-&gt;bus_num
op_ne
id|pb
)paren
(brace
id|lp-&gt;bus_num
op_assign
id|pb
suffix:semicolon
id|srom_search
c_func
(paren
id|pdev
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the chip configuration revision register */
id|pcibios_read_config_dword
c_func
(paren
id|pb
comma
id|pdev-&gt;devfn
comma
id|PCI_REVISION_ID
comma
op_amp
id|cfrv
)paren
suffix:semicolon
multiline_comment|/* Set the device number information */
id|lp-&gt;device
op_assign
id|dev_num
suffix:semicolon
id|lp-&gt;bus_num
op_assign
id|pb
suffix:semicolon
multiline_comment|/* Set the chipset information */
r_if
c_cond
(paren
id|is_DC2114x
)paren
(brace
id|device
op_assign
(paren
(paren
id|cfrv
op_amp
id|CFRV_RN
)paren
OL
id|DC2114x_BRK
ques
c_cond
id|DC21142
suffix:colon
id|DC21143
)paren
suffix:semicolon
)brace
id|lp-&gt;chipset
op_assign
id|device
suffix:semicolon
multiline_comment|/* Get the board I/O address (64 bits on sparc64) */
id|iobase
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Fetch the IRQ to be used */
id|irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
r_if
c_cond
(paren
(paren
id|irq
op_eq
l_int|0
)paren
op_logical_or
(paren
id|irq
op_eq
l_int|0xff
)paren
op_logical_or
(paren
(paren
r_int
)paren
id|irq
op_eq
op_minus
l_int|1
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Check if I/O accesses and Bus Mastering are enabled */
id|pcibios_read_config_word
c_func
(paren
id|pb
comma
id|pdev-&gt;devfn
comma
id|PCI_COMMAND
comma
op_amp
id|status
)paren
suffix:semicolon
macro_line|#ifdef __powerpc__
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|PCI_COMMAND_IO
)paren
)paren
(brace
id|status
op_or_assign
id|PCI_COMMAND_IO
suffix:semicolon
id|pcibios_write_config_word
c_func
(paren
id|pb
comma
id|pdev-&gt;devfn
comma
id|PCI_COMMAND
comma
id|status
)paren
suffix:semicolon
id|pcibios_read_config_word
c_func
(paren
id|pb
comma
id|pdev-&gt;devfn
comma
id|PCI_COMMAND
comma
op_amp
id|status
)paren
suffix:semicolon
)brace
macro_line|#endif /* __powerpc__ */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|PCI_COMMAND_IO
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|PCI_COMMAND_MASTER
)paren
)paren
(brace
id|status
op_or_assign
id|PCI_COMMAND_MASTER
suffix:semicolon
id|pcibios_write_config_word
c_func
(paren
id|pb
comma
id|pdev-&gt;devfn
comma
id|PCI_COMMAND
comma
id|status
)paren
suffix:semicolon
id|pcibios_read_config_word
c_func
(paren
id|pb
comma
id|pdev-&gt;devfn
comma
id|PCI_COMMAND
comma
op_amp
id|status
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|PCI_COMMAND_MASTER
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Check the latency timer for values &gt;= 0x60 */
id|pcibios_read_config_byte
c_func
(paren
id|pb
comma
id|pdev-&gt;devfn
comma
id|PCI_LATENCY_TIMER
comma
op_amp
id|timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer
OL
l_int|0x60
)paren
(brace
id|pcibios_write_config_byte
c_func
(paren
id|pb
comma
id|pdev-&gt;devfn
comma
id|PCI_LATENCY_TIMER
comma
l_int|0x60
)paren
suffix:semicolon
)brace
id|DevicePresent
c_func
(paren
id|DE4X5_APROM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|iobase
comma
id|DE4X5_PCI_TOTAL_SIZE
)paren
op_eq
l_int|0
)paren
(brace
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|de4x5_hw_init
c_func
(paren
id|dev
comma
id|iobase
comma
id|pdev
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|num_de4x5s
op_increment
suffix:semicolon
id|lastPCI
op_assign
id|index
suffix:semicolon
r_if
c_cond
(paren
id|loading_module
)paren
id|link_modules
c_func
(paren
id|lastModule
comma
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|ioaddr
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: region already allocated at 0x%04lx.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|iobase
)paren
suffix:semicolon
)brace
)brace
id|lastPCI
op_assign
id|NO_MORE_PCI
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** This function searches the current bus (which is &gt;0) for a DECchip with an&n;** SROM, so that in multiport cards that have one SROM shared between multiple &n;** DECchips, we can find the base SROM irrespective of the BIOS scan direction.&n;** For single port cards this is a time waster...&n;*/
r_static
r_void
id|__init
DECL|function|srom_search
id|srom_search
c_func
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
id|u_char
id|pb
suffix:semicolon
id|u_short
id|vendor
comma
id|status
suffix:semicolon
id|u_int
id|irq
op_assign
l_int|0
comma
id|device
suffix:semicolon
id|u_long
id|iobase
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear upper 32 bits in Alphas */
r_int
id|i
comma
id|j
suffix:semicolon
r_struct
id|bus_type
op_star
id|lp
op_assign
op_amp
id|bus
suffix:semicolon
r_struct
id|list_head
op_star
id|walk
op_assign
op_amp
id|dev-&gt;bus_list
suffix:semicolon
r_for
c_loop
(paren
id|walk
op_assign
id|walk-&gt;next
suffix:semicolon
id|walk
op_ne
op_amp
id|dev-&gt;bus_list
suffix:semicolon
id|walk
op_assign
id|walk-&gt;next
)paren
(brace
r_struct
id|pci_dev
op_star
id|this_dev
op_assign
id|pci_dev_b
c_func
(paren
id|walk
)paren
suffix:semicolon
id|pb
op_assign
id|this_dev-&gt;bus-&gt;number
suffix:semicolon
id|vendor
op_assign
id|this_dev-&gt;vendor
suffix:semicolon
id|device
op_assign
id|this_dev-&gt;device
op_lshift
l_int|8
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|is_DC21040
op_logical_or
id|is_DC21041
op_logical_or
id|is_DC21140
op_logical_or
id|is_DC2114x
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Get the chip configuration revision register */
id|pcibios_read_config_dword
c_func
(paren
id|pb
comma
id|this_dev-&gt;devfn
comma
id|PCI_REVISION_ID
comma
op_amp
id|cfrv
)paren
suffix:semicolon
multiline_comment|/* Set the device number information */
id|lp-&gt;device
op_assign
id|PCI_SLOT
c_func
(paren
id|this_dev-&gt;devfn
)paren
suffix:semicolon
id|lp-&gt;bus_num
op_assign
id|pb
suffix:semicolon
multiline_comment|/* Set the chipset information */
r_if
c_cond
(paren
id|is_DC2114x
)paren
(brace
id|device
op_assign
(paren
(paren
id|cfrv
op_amp
id|CFRV_RN
)paren
OL
id|DC2114x_BRK
ques
c_cond
id|DC21142
suffix:colon
id|DC21143
)paren
suffix:semicolon
)brace
id|lp-&gt;chipset
op_assign
id|device
suffix:semicolon
multiline_comment|/* Get the board I/O address (64 bits on sparc64) */
id|iobase
op_assign
id|pci_resource_start
c_func
(paren
id|this_dev
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Fetch the IRQ to be used */
id|irq
op_assign
id|this_dev-&gt;irq
suffix:semicolon
r_if
c_cond
(paren
(paren
id|irq
op_eq
l_int|0
)paren
op_logical_or
(paren
id|irq
op_eq
l_int|0xff
)paren
op_logical_or
(paren
(paren
r_int
)paren
id|irq
op_eq
op_minus
l_int|1
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Check if I/O accesses are enabled */
id|pcibios_read_config_word
c_func
(paren
id|pb
comma
id|this_dev-&gt;devfn
comma
id|PCI_COMMAND
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|PCI_COMMAND_IO
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Search for a valid SROM attached to this DECchip */
id|DevicePresent
c_func
(paren
id|DE4X5_APROM
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|j
op_add_assign
(paren
id|u_char
)paren
op_star
(paren
(paren
id|u_char
op_star
)paren
op_amp
id|lp-&gt;srom
op_plus
id|SROM_HWADD
op_plus
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|j
op_ne
l_int|0
)paren
op_logical_and
(paren
id|j
op_ne
l_int|0x5fa
)paren
)paren
(brace
id|last.chipset
op_assign
id|device
suffix:semicolon
id|last.bus
op_assign
id|pb
suffix:semicolon
id|last.irq
op_assign
id|irq
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|last.addr
(braket
id|i
)braket
op_assign
(paren
id|u_char
)paren
op_star
(paren
(paren
id|u_char
op_star
)paren
op_amp
id|lp-&gt;srom
op_plus
id|SROM_HWADD
op_plus
id|i
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
r_static
r_void
id|__init
DECL|function|link_modules
id|link_modules
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|net_device
op_star
id|tmp
)paren
(brace
r_struct
id|net_device
op_star
id|p
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
r_while
c_loop
(paren
(paren
(paren
r_struct
id|de4x5_private
op_star
)paren
(paren
id|p-&gt;priv
)paren
)paren
op_member_access_from_pointer
id|next_module
)paren
(brace
id|p
op_assign
(paren
(paren
r_struct
id|de4x5_private
op_star
)paren
(paren
id|p-&gt;priv
)paren
)paren
op_member_access_from_pointer
id|next_module
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev
op_ne
id|tmp
)paren
(brace
(paren
(paren
r_struct
id|de4x5_private
op_star
)paren
(paren
id|p-&gt;priv
)paren
)paren
op_member_access_from_pointer
id|next_module
op_assign
id|tmp
suffix:semicolon
)brace
r_else
(brace
(paren
(paren
r_struct
id|de4x5_private
op_star
)paren
(paren
id|p-&gt;priv
)paren
)paren
op_member_access_from_pointer
id|next_module
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** Auto configure the media here rather than setting the port at compile&n;** time. This routine is called by de4x5_init() and when a loss of media is&n;** detected (excessive collisions, loss of carrier, no carrier or link fail&n;** [TP] or no recent receive activity) to check whether the user has been &n;** sneaky and changed the port on us.&n;*/
r_static
r_int
DECL|function|autoconf_media
id|autoconf_media
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|next_tick
op_assign
id|DE4X5_AUTOSENSE_MS
suffix:semicolon
id|lp-&gt;linkOK
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;c_media
op_assign
id|AUTO
suffix:semicolon
multiline_comment|/* Bogus last media */
id|disable_ast
c_func
(paren
id|dev
)paren
suffix:semicolon
id|inl
c_func
(paren
id|DE4X5_MFC
)paren
suffix:semicolon
multiline_comment|/* Zero the lost frames counter */
id|lp-&gt;media
op_assign
id|INIT
suffix:semicolon
id|lp-&gt;tcount
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;useSROM
)paren
(brace
id|next_tick
op_assign
id|srom_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;chipset
op_eq
id|DC21040
)paren
(brace
id|next_tick
op_assign
id|dc21040_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;chipset
op_eq
id|DC21041
)paren
(brace
id|next_tick
op_assign
id|dc21041_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;chipset
op_eq
id|DC21140
)paren
(brace
id|next_tick
op_assign
id|dc21140m_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|enable_ast
c_func
(paren
id|dev
comma
id|next_tick
)paren
suffix:semicolon
r_return
(paren
id|lp-&gt;media
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** Autoconfigure the media when using the DC21040. AUI cannot be distinguished&n;** from BNC as the port has a jumper to set thick or thin wire. When set for&n;** BNC, the BNC port will indicate activity if it&squot;s not terminated correctly.&n;** The only way to test for that is to place a loopback packet onto the&n;** network and watch for errors. Since we&squot;re messing with the interrupt mask&n;** register, disable the board interrupts and do not allow any more packets to&n;** be queued to the hardware. Re-enable everything only when the media is&n;** found.&n;** I may have to &quot;age out&quot; locally queued packets so that the higher layer&n;** timeouts don&squot;t effectively duplicate packets on the network.&n;*/
r_static
r_int
DECL|function|dc21040_autoconf
id|dc21040_autoconf
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|next_tick
op_assign
id|DE4X5_AUTOSENSE_MS
suffix:semicolon
id|s32
id|imr
suffix:semicolon
r_switch
c_cond
(paren
id|lp-&gt;media
)paren
(brace
r_case
id|INIT
suffix:colon
id|DISABLE_IRQs
suffix:semicolon
id|lp-&gt;tx_enable
op_assign
id|NO
suffix:semicolon
id|lp-&gt;timeout
op_assign
op_minus
l_int|1
suffix:semicolon
id|de4x5_save_skbs
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
op_logical_or
(paren
id|lp-&gt;autosense
op_eq
id|TP
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|TP
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|lp-&gt;autosense
op_eq
id|BNC
)paren
op_logical_or
(paren
id|lp-&gt;autosense
op_eq
id|AUI
)paren
op_logical_or
(paren
id|lp-&gt;autosense
op_eq
id|BNC_AUI
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|BNC_AUI
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;autosense
op_eq
id|EXT_SIA
)paren
(brace
id|lp-&gt;media
op_assign
id|EXT_SIA
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;media
op_assign
id|NC
suffix:semicolon
)brace
id|lp-&gt;local_state
op_assign
l_int|0
suffix:semicolon
id|next_tick
op_assign
id|dc21040_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TP
suffix:colon
id|next_tick
op_assign
id|dc21040_state
c_func
(paren
id|dev
comma
l_int|0x8f01
comma
l_int|0xffff
comma
l_int|0x0000
comma
l_int|3000
comma
id|BNC_AUI
comma
id|TP_SUSPECT
comma
id|test_tp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TP_SUSPECT
suffix:colon
id|next_tick
op_assign
id|de4x5_suspect_state
c_func
(paren
id|dev
comma
l_int|1000
comma
id|TP
comma
id|test_tp
comma
id|dc21040_autoconf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BNC
suffix:colon
r_case
id|AUI
suffix:colon
r_case
id|BNC_AUI
suffix:colon
id|next_tick
op_assign
id|dc21040_state
c_func
(paren
id|dev
comma
l_int|0x8f09
comma
l_int|0x0705
comma
l_int|0x0006
comma
l_int|3000
comma
id|EXT_SIA
comma
id|BNC_AUI_SUSPECT
comma
id|ping_media
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BNC_AUI_SUSPECT
suffix:colon
id|next_tick
op_assign
id|de4x5_suspect_state
c_func
(paren
id|dev
comma
l_int|1000
comma
id|BNC_AUI
comma
id|ping_media
comma
id|dc21040_autoconf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EXT_SIA
suffix:colon
id|next_tick
op_assign
id|dc21040_state
c_func
(paren
id|dev
comma
l_int|0x3041
comma
l_int|0x0000
comma
l_int|0x0006
comma
l_int|3000
comma
id|NC
comma
id|EXT_SIA_SUSPECT
comma
id|ping_media
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EXT_SIA_SUSPECT
suffix:colon
id|next_tick
op_assign
id|de4x5_suspect_state
c_func
(paren
id|dev
comma
l_int|1000
comma
id|EXT_SIA
comma
id|ping_media
comma
id|dc21040_autoconf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NC
suffix:colon
multiline_comment|/* default to TP for all */
id|reset_init_sia
c_func
(paren
id|dev
comma
l_int|0x8f01
comma
l_int|0xffff
comma
l_int|0x0000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;media
op_ne
id|lp-&gt;c_media
)paren
(brace
id|de4x5_dbg_media
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;c_media
op_assign
id|lp-&gt;media
suffix:semicolon
)brace
id|lp-&gt;media
op_assign
id|INIT
suffix:semicolon
id|lp-&gt;tx_enable
op_assign
id|NO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|next_tick
suffix:semicolon
)brace
r_static
r_int
DECL|function|dc21040_state
id|dc21040_state
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|csr13
comma
r_int
id|csr14
comma
r_int
id|csr15
comma
r_int
id|timeout
comma
r_int
id|next_state
comma
r_int
id|suspect_state
comma
r_int
(paren
op_star
id|fn
)paren
(paren
r_struct
id|net_device
op_star
comma
r_int
)paren
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|next_tick
op_assign
id|DE4X5_AUTOSENSE_MS
suffix:semicolon
r_int
id|linkBad
suffix:semicolon
r_switch
c_cond
(paren
id|lp-&gt;local_state
)paren
(brace
r_case
l_int|0
suffix:colon
id|reset_init_sia
c_func
(paren
id|dev
comma
id|csr13
comma
id|csr14
comma
id|csr15
)paren
suffix:semicolon
id|lp-&gt;local_state
op_increment
suffix:semicolon
id|next_tick
op_assign
l_int|500
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;tx_enable
)paren
(brace
id|linkBad
op_assign
id|fn
c_func
(paren
id|dev
comma
id|timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|linkBad
OL
l_int|0
)paren
(brace
id|next_tick
op_assign
id|linkBad
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|linkBad
op_logical_and
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
)paren
(brace
id|lp-&gt;local_state
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;media
op_assign
id|next_state
suffix:semicolon
)brace
r_else
(brace
id|de4x5_init_connection
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;linkOK
op_logical_and
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|suspect_state
suffix:semicolon
id|next_tick
op_assign
l_int|3000
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
id|next_tick
suffix:semicolon
)brace
r_static
r_int
DECL|function|de4x5_suspect_state
id|de4x5_suspect_state
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|timeout
comma
r_int
id|prev_state
comma
r_int
(paren
op_star
id|fn
)paren
(paren
r_struct
id|net_device
op_star
comma
r_int
)paren
comma
r_int
(paren
op_star
id|asfn
)paren
(paren
r_struct
id|net_device
op_star
)paren
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|next_tick
op_assign
id|DE4X5_AUTOSENSE_MS
suffix:semicolon
r_int
id|linkBad
suffix:semicolon
r_switch
c_cond
(paren
id|lp-&gt;local_state
)paren
(brace
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|lp-&gt;linkOK
)paren
(brace
id|lp-&gt;media
op_assign
id|prev_state
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;local_state
op_increment
suffix:semicolon
id|next_tick
op_assign
id|asfn
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|linkBad
op_assign
id|fn
c_func
(paren
id|dev
comma
id|timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|linkBad
OL
l_int|0
)paren
(brace
id|next_tick
op_assign
id|linkBad
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|linkBad
)paren
(brace
id|lp-&gt;local_state
op_decrement
suffix:semicolon
id|lp-&gt;media
op_assign
id|prev_state
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;media
op_assign
id|INIT
suffix:semicolon
id|lp-&gt;tcount
op_increment
suffix:semicolon
)brace
)brace
r_return
id|next_tick
suffix:semicolon
)brace
multiline_comment|/*&n;** Autoconfigure the media when using the DC21041. AUI needs to be tested&n;** before BNC, because the BNC port will indicate activity if it&squot;s not&n;** terminated correctly. The only way to test for that is to place a loopback&n;** packet onto the network and watch for errors. Since we&squot;re messing with&n;** the interrupt mask register, disable the board interrupts and do not allow&n;** any more packets to be queued to the hardware. Re-enable everything only&n;** when the media is found.&n;*/
r_static
r_int
DECL|function|dc21041_autoconf
id|dc21041_autoconf
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|s32
id|sts
comma
id|irqs
comma
id|irq_mask
comma
id|imr
comma
id|omr
suffix:semicolon
r_int
id|next_tick
op_assign
id|DE4X5_AUTOSENSE_MS
suffix:semicolon
r_switch
c_cond
(paren
id|lp-&gt;media
)paren
(brace
r_case
id|INIT
suffix:colon
id|DISABLE_IRQs
suffix:semicolon
id|lp-&gt;tx_enable
op_assign
id|NO
suffix:semicolon
id|lp-&gt;timeout
op_assign
op_minus
l_int|1
suffix:semicolon
id|de4x5_save_skbs
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Save non transmitted skb&squot;s */
r_if
c_cond
(paren
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
op_logical_or
(paren
id|lp-&gt;autosense
op_eq
id|TP_NW
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|TP
suffix:semicolon
multiline_comment|/* On chip auto negotiation is broken */
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;autosense
op_eq
id|TP
)paren
(brace
id|lp-&gt;media
op_assign
id|TP
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;autosense
op_eq
id|BNC
)paren
(brace
id|lp-&gt;media
op_assign
id|BNC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;autosense
op_eq
id|AUI
)paren
(brace
id|lp-&gt;media
op_assign
id|AUI
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;media
op_assign
id|NC
suffix:semicolon
)brace
id|lp-&gt;local_state
op_assign
l_int|0
suffix:semicolon
id|next_tick
op_assign
id|dc21041_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TP_NW
suffix:colon
r_if
c_cond
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
(brace
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
multiline_comment|/* Set up full duplex for the autonegotiate */
id|outl
c_func
(paren
id|omr
op_or
id|OMR_FDX
comma
id|DE4X5_OMR
)paren
suffix:semicolon
)brace
id|irqs
op_assign
id|STS_LNF
op_or
id|STS_LNP
suffix:semicolon
id|irq_mask
op_assign
id|IMR_LFM
op_or
id|IMR_LPM
suffix:semicolon
id|sts
op_assign
id|test_media
c_func
(paren
id|dev
comma
id|irqs
comma
id|irq_mask
comma
l_int|0xef01
comma
l_int|0xffff
comma
l_int|0x0008
comma
l_int|2400
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sts
OL
l_int|0
)paren
(brace
id|next_tick
op_assign
id|sts
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sts
op_amp
id|STS_LNP
)paren
(brace
id|lp-&gt;media
op_assign
id|ANS
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;media
op_assign
id|AUI
suffix:semicolon
)brace
id|next_tick
op_assign
id|dc21041_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ANS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;tx_enable
)paren
(brace
id|irqs
op_assign
id|STS_LNP
suffix:semicolon
id|irq_mask
op_assign
id|IMR_LPM
suffix:semicolon
id|sts
op_assign
id|test_ans
c_func
(paren
id|dev
comma
id|irqs
comma
id|irq_mask
comma
l_int|3000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sts
OL
l_int|0
)paren
(brace
id|next_tick
op_assign
id|sts
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|sts
op_amp
id|STS_LNP
)paren
op_logical_and
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|TP
suffix:semicolon
id|next_tick
op_assign
id|dc21041_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;local_state
op_assign
l_int|1
suffix:semicolon
id|de4x5_init_connection
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;linkOK
op_logical_and
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|ANS_SUSPECT
suffix:semicolon
id|next_tick
op_assign
l_int|3000
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ANS_SUSPECT
suffix:colon
id|next_tick
op_assign
id|de4x5_suspect_state
c_func
(paren
id|dev
comma
l_int|1000
comma
id|ANS
comma
id|test_tp
comma
id|dc21041_autoconf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;tx_enable
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
(brace
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
multiline_comment|/* Set up half duplex for TP */
id|outl
c_func
(paren
id|omr
op_amp
op_complement
id|OMR_FDX
comma
id|DE4X5_OMR
)paren
suffix:semicolon
)brace
id|irqs
op_assign
id|STS_LNF
op_or
id|STS_LNP
suffix:semicolon
id|irq_mask
op_assign
id|IMR_LFM
op_or
id|IMR_LPM
suffix:semicolon
id|sts
op_assign
id|test_media
c_func
(paren
id|dev
comma
id|irqs
comma
id|irq_mask
comma
l_int|0xef01
comma
l_int|0xff3f
comma
l_int|0x0008
comma
l_int|2400
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sts
OL
l_int|0
)paren
(brace
id|next_tick
op_assign
id|sts
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|sts
op_amp
id|STS_LNP
)paren
op_logical_and
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
)paren
(brace
r_if
c_cond
(paren
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
op_amp
id|SISR_NRA
)paren
(brace
id|lp-&gt;media
op_assign
id|AUI
suffix:semicolon
multiline_comment|/* Non selected port activity */
)brace
r_else
(brace
id|lp-&gt;media
op_assign
id|BNC
suffix:semicolon
)brace
id|next_tick
op_assign
id|dc21041_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;local_state
op_assign
l_int|1
suffix:semicolon
id|de4x5_init_connection
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;linkOK
op_logical_and
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|TP_SUSPECT
suffix:semicolon
id|next_tick
op_assign
l_int|3000
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TP_SUSPECT
suffix:colon
id|next_tick
op_assign
id|de4x5_suspect_state
c_func
(paren
id|dev
comma
l_int|1000
comma
id|TP
comma
id|test_tp
comma
id|dc21041_autoconf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUI
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;tx_enable
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
(brace
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
multiline_comment|/* Set up half duplex for AUI */
id|outl
c_func
(paren
id|omr
op_amp
op_complement
id|OMR_FDX
comma
id|DE4X5_OMR
)paren
suffix:semicolon
)brace
id|irqs
op_assign
l_int|0
suffix:semicolon
id|irq_mask
op_assign
l_int|0
suffix:semicolon
id|sts
op_assign
id|test_media
c_func
(paren
id|dev
comma
id|irqs
comma
id|irq_mask
comma
l_int|0xef09
comma
l_int|0xf73d
comma
l_int|0x000e
comma
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sts
OL
l_int|0
)paren
(brace
id|next_tick
op_assign
id|sts
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
op_amp
id|SISR_SRA
)paren
op_logical_and
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|BNC
suffix:semicolon
id|next_tick
op_assign
id|dc21041_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;local_state
op_assign
l_int|1
suffix:semicolon
id|de4x5_init_connection
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;linkOK
op_logical_and
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|AUI_SUSPECT
suffix:semicolon
id|next_tick
op_assign
l_int|3000
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AUI_SUSPECT
suffix:colon
id|next_tick
op_assign
id|de4x5_suspect_state
c_func
(paren
id|dev
comma
l_int|1000
comma
id|AUI
comma
id|ping_media
comma
id|dc21041_autoconf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BNC
suffix:colon
r_switch
c_cond
(paren
id|lp-&gt;local_state
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
(brace
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
multiline_comment|/* Set up half duplex for BNC */
id|outl
c_func
(paren
id|omr
op_amp
op_complement
id|OMR_FDX
comma
id|DE4X5_OMR
)paren
suffix:semicolon
)brace
id|irqs
op_assign
l_int|0
suffix:semicolon
id|irq_mask
op_assign
l_int|0
suffix:semicolon
id|sts
op_assign
id|test_media
c_func
(paren
id|dev
comma
id|irqs
comma
id|irq_mask
comma
l_int|0xef09
comma
l_int|0xf73d
comma
l_int|0x0006
comma
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sts
OL
l_int|0
)paren
(brace
id|next_tick
op_assign
id|sts
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;local_state
op_increment
suffix:semicolon
multiline_comment|/* Ensure media connected */
id|next_tick
op_assign
id|dc21041_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;tx_enable
)paren
(brace
r_if
c_cond
(paren
(paren
id|sts
op_assign
id|ping_media
c_func
(paren
id|dev
comma
l_int|3000
)paren
)paren
OL
l_int|0
)paren
(brace
id|next_tick
op_assign
id|sts
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sts
)paren
(brace
id|lp-&gt;local_state
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;media
op_assign
id|NC
suffix:semicolon
)brace
r_else
(brace
id|de4x5_init_connection
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;linkOK
op_logical_and
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|BNC_SUSPECT
suffix:semicolon
id|next_tick
op_assign
l_int|3000
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BNC_SUSPECT
suffix:colon
id|next_tick
op_assign
id|de4x5_suspect_state
c_func
(paren
id|dev
comma
l_int|1000
comma
id|BNC
comma
id|ping_media
comma
id|dc21041_autoconf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NC
suffix:colon
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
multiline_comment|/* Set up full duplex for the autonegotiate */
id|outl
c_func
(paren
id|omr
op_or
id|OMR_FDX
comma
id|DE4X5_OMR
)paren
suffix:semicolon
id|reset_init_sia
c_func
(paren
id|dev
comma
l_int|0xef01
comma
l_int|0xffff
comma
l_int|0x0008
)paren
suffix:semicolon
multiline_comment|/* Initialise the SIA */
r_if
c_cond
(paren
id|lp-&gt;media
op_ne
id|lp-&gt;c_media
)paren
(brace
id|de4x5_dbg_media
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;c_media
op_assign
id|lp-&gt;media
suffix:semicolon
)brace
id|lp-&gt;media
op_assign
id|INIT
suffix:semicolon
id|lp-&gt;tx_enable
op_assign
id|NO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|next_tick
suffix:semicolon
)brace
multiline_comment|/*&n;** Some autonegotiation chips are broken in that they do not return the&n;** acknowledge bit (anlpa &amp; MII_ANLPA_ACK) in the link partner advertisement&n;** register, except at the first power up negotiation.&n;*/
r_static
r_int
DECL|function|dc21140m_autoconf
id|dc21140m_autoconf
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ana
comma
id|anlpa
comma
id|cap
comma
id|cr
comma
id|slnk
comma
id|sr
suffix:semicolon
r_int
id|next_tick
op_assign
id|DE4X5_AUTOSENSE_MS
suffix:semicolon
id|u_long
id|imr
comma
id|omr
comma
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_switch
c_cond
(paren
id|lp-&gt;media
)paren
(brace
r_case
id|INIT
suffix:colon
r_if
c_cond
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
(brace
id|DISABLE_IRQs
suffix:semicolon
id|lp-&gt;tx_enable
op_assign
id|FALSE
suffix:semicolon
id|lp-&gt;linkOK
op_assign
l_int|0
suffix:semicolon
id|de4x5_save_skbs
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Save non transmitted skb&squot;s */
)brace
r_if
c_cond
(paren
(paren
id|next_tick
op_assign
id|de4x5_reset_phy
c_func
(paren
id|dev
)paren
)paren
OL
l_int|0
)paren
(brace
id|next_tick
op_and_assign
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|lp-&gt;useSROM
)paren
(brace
r_if
c_cond
(paren
id|srom_map_media
c_func
(paren
id|dev
)paren
OL
l_int|0
)paren
(brace
id|lp-&gt;tcount
op_increment
suffix:semicolon
r_return
id|next_tick
suffix:semicolon
)brace
id|srom_exec
c_func
(paren
id|dev
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|gep
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;infoblock_media
op_eq
id|ANS
)paren
(brace
id|ana
op_assign
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|ana
op_or
id|MII_ANA_CSMA
suffix:semicolon
id|mii_wr
c_func
(paren
id|ana
comma
id|MII_ANA
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|lp-&gt;tmp
op_assign
id|MII_SR_ASSC
suffix:semicolon
multiline_comment|/* Fake out the MII speed set */
id|SET_10Mb
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;autosense
op_eq
id|_100Mb
)paren
(brace
id|lp-&gt;media
op_assign
id|_100Mb
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;autosense
op_eq
id|_10Mb
)paren
(brace
id|lp-&gt;media
op_assign
id|_10Mb
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
op_logical_and
(paren
(paren
id|sr
op_assign
id|is_anc_capable
c_func
(paren
id|dev
)paren
)paren
op_amp
id|MII_SR_ANC
)paren
)paren
(brace
id|ana
op_assign
(paren
(paren
(paren
id|sr
op_rshift
l_int|6
)paren
op_amp
id|MII_ANA_TAF
)paren
op_or
id|MII_ANA_CSMA
)paren
suffix:semicolon
id|ana
op_and_assign
(paren
id|lp-&gt;fdx
ques
c_cond
op_complement
l_int|0
suffix:colon
op_complement
id|MII_ANA_FDAM
)paren
suffix:semicolon
id|mii_wr
c_func
(paren
id|ana
comma
id|MII_ANA
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
suffix:semicolon
id|lp-&gt;media
op_assign
id|ANS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
(brace
id|lp-&gt;media
op_assign
id|SPD_DET
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_spd_100
c_func
(paren
id|dev
)paren
op_logical_and
id|is_100_up
c_func
(paren
id|dev
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|_100Mb
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;media
op_assign
id|NC
suffix:semicolon
)brace
)brace
id|lp-&gt;local_state
op_assign
l_int|0
suffix:semicolon
id|next_tick
op_assign
id|dc21140m_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ANS
suffix:colon
r_switch
c_cond
(paren
id|lp-&gt;local_state
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
(brace
id|mii_wr
c_func
(paren
id|MII_CR_ASSE
op_or
id|MII_CR_RAN
comma
id|MII_CR
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
suffix:semicolon
)brace
id|cr
op_assign
id|test_mii_reg
c_func
(paren
id|dev
comma
id|MII_CR
comma
id|MII_CR_RAN
comma
id|FALSE
comma
l_int|500
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cr
OL
l_int|0
)paren
(brace
id|next_tick
op_assign
id|cr
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cr
)paren
(brace
id|lp-&gt;local_state
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;media
op_assign
id|SPD_DET
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;local_state
op_increment
suffix:semicolon
)brace
id|next_tick
op_assign
id|dc21140m_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
(paren
id|sr
op_assign
id|test_mii_reg
c_func
(paren
id|dev
comma
id|MII_SR
comma
id|MII_SR_ASSC
comma
id|TRUE
comma
l_int|2000
)paren
)paren
OL
l_int|0
)paren
(brace
id|next_tick
op_assign
id|sr
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;media
op_assign
id|SPD_DET
suffix:semicolon
id|lp-&gt;local_state
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sr
)paren
(brace
multiline_comment|/* Success! */
id|lp-&gt;tmp
op_assign
id|MII_SR_ASSC
suffix:semicolon
id|anlpa
op_assign
id|mii_rd
c_func
(paren
id|MII_ANLPA
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
suffix:semicolon
id|ana
op_assign
id|mii_rd
c_func
(paren
id|MII_ANA
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|anlpa
op_amp
id|MII_ANLPA_RF
)paren
op_logical_and
(paren
id|cap
op_assign
id|anlpa
op_amp
id|MII_ANLPA_TAF
op_amp
id|ana
)paren
)paren
(brace
r_if
c_cond
(paren
id|cap
op_amp
id|MII_ANA_100M
)paren
(brace
id|lp-&gt;fdx
op_assign
(paren
(paren
id|ana
op_amp
id|anlpa
op_amp
id|MII_ANA_FDAM
op_amp
id|MII_ANA_100M
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
)paren
suffix:semicolon
id|lp-&gt;media
op_assign
id|_100Mb
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cap
op_amp
id|MII_ANA_10M
)paren
(brace
id|lp-&gt;fdx
op_assign
(paren
(paren
id|ana
op_amp
id|anlpa
op_amp
id|MII_ANA_FDAM
op_amp
id|MII_ANA_10M
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
)paren
suffix:semicolon
id|lp-&gt;media
op_assign
id|_10Mb
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Auto Negotiation failed to finish */
id|next_tick
op_assign
id|dc21140m_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Auto Negotiation failed to start */
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SPD_DET
suffix:colon
multiline_comment|/* Choose 10Mb/s or 100Mb/s */
r_if
c_cond
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
(brace
id|lp-&gt;tmp
op_assign
(paren
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|id
ques
c_cond
id|MII_SR_LKS
suffix:colon
(paren
op_complement
id|gep_rd
c_func
(paren
id|dev
)paren
op_amp
id|GEP_LNP
)paren
)paren
suffix:semicolon
id|SET_100Mb_PDET
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|slnk
op_assign
id|test_for_100Mb
c_func
(paren
id|dev
comma
l_int|6500
)paren
)paren
OL
l_int|0
)paren
(brace
id|next_tick
op_assign
id|slnk
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|is_spd_100
c_func
(paren
id|dev
)paren
op_logical_and
id|is_100_up
c_func
(paren
id|dev
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|_100Mb
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
op_logical_neg
id|is_spd_100
c_func
(paren
id|dev
)paren
op_logical_and
(paren
id|is_10_up
c_func
(paren
id|dev
)paren
op_amp
id|lp-&gt;tmp
)paren
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|_10Mb
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;media
op_assign
id|NC
suffix:semicolon
)brace
id|next_tick
op_assign
id|dc21140m_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|_100Mb
suffix:colon
multiline_comment|/* Set 100Mb/s */
id|next_tick
op_assign
l_int|3000
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;tx_enable
)paren
(brace
id|SET_100Mb
suffix:semicolon
id|de4x5_init_connection
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;linkOK
op_logical_and
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_100_up
c_func
(paren
id|dev
)paren
op_logical_or
(paren
op_logical_neg
id|lp-&gt;useSROM
op_logical_and
op_logical_neg
id|is_spd_100
c_func
(paren
id|dev
)paren
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|INIT
suffix:semicolon
id|lp-&gt;tcount
op_increment
suffix:semicolon
id|next_tick
op_assign
id|DE4X5_AUTOSENSE_MS
suffix:semicolon
)brace
)brace
)brace
r_break
suffix:semicolon
r_case
id|BNC
suffix:colon
r_case
id|AUI
suffix:colon
r_case
id|_10Mb
suffix:colon
multiline_comment|/* Set 10Mb/s */
id|next_tick
op_assign
l_int|3000
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;tx_enable
)paren
(brace
id|SET_10Mb
suffix:semicolon
id|de4x5_init_connection
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;linkOK
op_logical_and
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_10_up
c_func
(paren
id|dev
)paren
op_logical_or
(paren
op_logical_neg
id|lp-&gt;useSROM
op_logical_and
id|is_spd_100
c_func
(paren
id|dev
)paren
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|INIT
suffix:semicolon
id|lp-&gt;tcount
op_increment
suffix:semicolon
id|next_tick
op_assign
id|DE4X5_AUTOSENSE_MS
suffix:semicolon
)brace
)brace
)brace
r_break
suffix:semicolon
r_case
id|NC
suffix:colon
r_if
c_cond
(paren
id|lp-&gt;media
op_ne
id|lp-&gt;c_media
)paren
(brace
id|de4x5_dbg_media
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;c_media
op_assign
id|lp-&gt;media
suffix:semicolon
)brace
id|lp-&gt;media
op_assign
id|INIT
suffix:semicolon
id|lp-&gt;tx_enable
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|next_tick
suffix:semicolon
)brace
multiline_comment|/*&n;** This routine may be merged into dc21140m_autoconf() sometime as I&squot;m&n;** changing how I figure out the media - but trying to keep it backwards&n;** compatible with the de500-xa and de500-aa.&n;** Whether it&squot;s BNC, AUI, SYM or MII is sorted out in the infoblock&n;** functions and set during de4x5_mac_port() and/or de4x5_reset_phy().&n;** This routine just has to figure out whether 10Mb/s or 100Mb/s is&n;** active.&n;** When autonegotiation is working, the ANS part searches the SROM for&n;** the highest common speed (TP) link that both can run and if that can&n;** be full duplex. That infoblock is executed and then the link speed set.&n;**&n;** Only _10Mb and _100Mb are tested here.&n;*/
r_static
r_int
DECL|function|dc2114x_autoconf
id|dc2114x_autoconf
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|s32
id|cr
comma
id|anlpa
comma
id|ana
comma
id|cap
comma
id|irqs
comma
id|irq_mask
comma
id|imr
comma
id|omr
comma
id|slnk
comma
id|sr
comma
id|sts
suffix:semicolon
r_int
id|next_tick
op_assign
id|DE4X5_AUTOSENSE_MS
suffix:semicolon
r_switch
c_cond
(paren
id|lp-&gt;media
)paren
(brace
r_case
id|INIT
suffix:colon
r_if
c_cond
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
(brace
id|DISABLE_IRQs
suffix:semicolon
id|lp-&gt;tx_enable
op_assign
id|FALSE
suffix:semicolon
id|lp-&gt;linkOK
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;timeout
op_assign
op_minus
l_int|1
suffix:semicolon
id|de4x5_save_skbs
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Save non transmitted skb&squot;s */
r_if
c_cond
(paren
id|lp-&gt;params.autosense
op_amp
op_complement
id|AUTO
)paren
(brace
id|srom_map_media
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Fixed media requested      */
r_if
c_cond
(paren
id|lp-&gt;media
op_ne
id|lp-&gt;params.autosense
)paren
(brace
id|lp-&gt;tcount
op_increment
suffix:semicolon
id|lp-&gt;media
op_assign
id|INIT
suffix:semicolon
r_return
id|next_tick
suffix:semicolon
)brace
id|lp-&gt;media
op_assign
id|INIT
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|next_tick
op_assign
id|de4x5_reset_phy
c_func
(paren
id|dev
)paren
)paren
OL
l_int|0
)paren
(brace
id|next_tick
op_and_assign
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|lp-&gt;autosense
op_eq
id|_100Mb
)paren
(brace
id|lp-&gt;media
op_assign
id|_100Mb
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;autosense
op_eq
id|_10Mb
)paren
(brace
id|lp-&gt;media
op_assign
id|_10Mb
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;autosense
op_eq
id|TP
)paren
(brace
id|lp-&gt;media
op_assign
id|TP
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;autosense
op_eq
id|BNC
)paren
(brace
id|lp-&gt;media
op_assign
id|BNC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;autosense
op_eq
id|AUI
)paren
(brace
id|lp-&gt;media
op_assign
id|AUI
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;media
op_assign
id|SPD_DET
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lp-&gt;infoblock_media
op_eq
id|ANS
)paren
op_logical_and
(paren
(paren
id|sr
op_assign
id|is_anc_capable
c_func
(paren
id|dev
)paren
)paren
op_amp
id|MII_SR_ANC
)paren
)paren
(brace
id|ana
op_assign
(paren
(paren
(paren
id|sr
op_rshift
l_int|6
)paren
op_amp
id|MII_ANA_TAF
)paren
op_or
id|MII_ANA_CSMA
)paren
suffix:semicolon
id|ana
op_and_assign
(paren
id|lp-&gt;fdx
ques
c_cond
op_complement
l_int|0
suffix:colon
op_complement
id|MII_ANA_FDAM
)paren
suffix:semicolon
id|mii_wr
c_func
(paren
id|ana
comma
id|MII_ANA
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
suffix:semicolon
id|lp-&gt;media
op_assign
id|ANS
suffix:semicolon
)brace
)brace
id|lp-&gt;local_state
op_assign
l_int|0
suffix:semicolon
id|next_tick
op_assign
id|dc2114x_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ANS
suffix:colon
r_switch
c_cond
(paren
id|lp-&gt;local_state
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
(brace
id|mii_wr
c_func
(paren
id|MII_CR_ASSE
op_or
id|MII_CR_RAN
comma
id|MII_CR
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
suffix:semicolon
)brace
id|cr
op_assign
id|test_mii_reg
c_func
(paren
id|dev
comma
id|MII_CR
comma
id|MII_CR_RAN
comma
id|FALSE
comma
l_int|500
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cr
OL
l_int|0
)paren
(brace
id|next_tick
op_assign
id|cr
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cr
)paren
(brace
id|lp-&gt;local_state
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;media
op_assign
id|SPD_DET
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;local_state
op_increment
suffix:semicolon
)brace
id|next_tick
op_assign
id|dc2114x_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
(paren
id|sr
op_assign
id|test_mii_reg
c_func
(paren
id|dev
comma
id|MII_SR
comma
id|MII_SR_ASSC
comma
id|TRUE
comma
l_int|2000
)paren
)paren
OL
l_int|0
)paren
(brace
id|next_tick
op_assign
id|sr
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;media
op_assign
id|SPD_DET
suffix:semicolon
id|lp-&gt;local_state
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sr
)paren
(brace
multiline_comment|/* Success! */
id|lp-&gt;tmp
op_assign
id|MII_SR_ASSC
suffix:semicolon
id|anlpa
op_assign
id|mii_rd
c_func
(paren
id|MII_ANLPA
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
suffix:semicolon
id|ana
op_assign
id|mii_rd
c_func
(paren
id|MII_ANA
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|anlpa
op_amp
id|MII_ANLPA_RF
)paren
op_logical_and
(paren
id|cap
op_assign
id|anlpa
op_amp
id|MII_ANLPA_TAF
op_amp
id|ana
)paren
)paren
(brace
r_if
c_cond
(paren
id|cap
op_amp
id|MII_ANA_100M
)paren
(brace
id|lp-&gt;fdx
op_assign
(paren
(paren
id|ana
op_amp
id|anlpa
op_amp
id|MII_ANA_FDAM
op_amp
id|MII_ANA_100M
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
)paren
suffix:semicolon
id|lp-&gt;media
op_assign
id|_100Mb
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cap
op_amp
id|MII_ANA_10M
)paren
(brace
id|lp-&gt;fdx
op_assign
(paren
(paren
id|ana
op_amp
id|anlpa
op_amp
id|MII_ANA_FDAM
op_amp
id|MII_ANA_10M
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
)paren
suffix:semicolon
id|lp-&gt;media
op_assign
id|_10Mb
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Auto Negotiation failed to finish */
id|next_tick
op_assign
id|dc2114x_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Auto Negotiation failed to start  */
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AUI
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;tx_enable
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
(brace
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
multiline_comment|/* Set up half duplex for AUI        */
id|outl
c_func
(paren
id|omr
op_amp
op_complement
id|OMR_FDX
comma
id|DE4X5_OMR
)paren
suffix:semicolon
)brace
id|irqs
op_assign
l_int|0
suffix:semicolon
id|irq_mask
op_assign
l_int|0
suffix:semicolon
id|sts
op_assign
id|test_media
c_func
(paren
id|dev
comma
id|irqs
comma
id|irq_mask
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sts
OL
l_int|0
)paren
(brace
id|next_tick
op_assign
id|sts
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
op_amp
id|SISR_SRA
)paren
op_logical_and
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|BNC
suffix:semicolon
id|next_tick
op_assign
id|dc2114x_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;local_state
op_assign
l_int|1
suffix:semicolon
id|de4x5_init_connection
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;linkOK
op_logical_and
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|AUI_SUSPECT
suffix:semicolon
id|next_tick
op_assign
l_int|3000
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AUI_SUSPECT
suffix:colon
id|next_tick
op_assign
id|de4x5_suspect_state
c_func
(paren
id|dev
comma
l_int|1000
comma
id|AUI
comma
id|ping_media
comma
id|dc2114x_autoconf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BNC
suffix:colon
r_switch
c_cond
(paren
id|lp-&gt;local_state
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
(brace
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
multiline_comment|/* Set up half duplex for BNC */
id|outl
c_func
(paren
id|omr
op_amp
op_complement
id|OMR_FDX
comma
id|DE4X5_OMR
)paren
suffix:semicolon
)brace
id|irqs
op_assign
l_int|0
suffix:semicolon
id|irq_mask
op_assign
l_int|0
suffix:semicolon
id|sts
op_assign
id|test_media
c_func
(paren
id|dev
comma
id|irqs
comma
id|irq_mask
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sts
OL
l_int|0
)paren
(brace
id|next_tick
op_assign
id|sts
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;local_state
op_increment
suffix:semicolon
multiline_comment|/* Ensure media connected */
id|next_tick
op_assign
id|dc2114x_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;tx_enable
)paren
(brace
r_if
c_cond
(paren
(paren
id|sts
op_assign
id|ping_media
c_func
(paren
id|dev
comma
l_int|3000
)paren
)paren
OL
l_int|0
)paren
(brace
id|next_tick
op_assign
id|sts
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sts
)paren
(brace
id|lp-&gt;local_state
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tcount
op_increment
suffix:semicolon
id|lp-&gt;media
op_assign
id|INIT
suffix:semicolon
)brace
r_else
(brace
id|de4x5_init_connection
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;linkOK
op_logical_and
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|BNC_SUSPECT
suffix:semicolon
id|next_tick
op_assign
l_int|3000
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BNC_SUSPECT
suffix:colon
id|next_tick
op_assign
id|de4x5_suspect_state
c_func
(paren
id|dev
comma
l_int|1000
comma
id|BNC
comma
id|ping_media
comma
id|dc2114x_autoconf
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SPD_DET
suffix:colon
multiline_comment|/* Choose 10Mb/s or 100Mb/s */
r_if
c_cond
(paren
id|srom_map_media
c_func
(paren
id|dev
)paren
OL
l_int|0
)paren
(brace
id|lp-&gt;tcount
op_increment
suffix:semicolon
id|lp-&gt;media
op_assign
id|INIT
suffix:semicolon
r_return
id|next_tick
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;media
op_eq
id|_100Mb
)paren
(brace
r_if
c_cond
(paren
(paren
id|slnk
op_assign
id|test_for_100Mb
c_func
(paren
id|dev
comma
l_int|6500
)paren
)paren
OL
l_int|0
)paren
(brace
id|lp-&gt;media
op_assign
id|SPD_DET
suffix:semicolon
r_return
(paren
id|slnk
op_amp
op_complement
id|TIMER_CB
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|wait_for_link
c_func
(paren
id|dev
)paren
OL
l_int|0
)paren
(brace
id|lp-&gt;media
op_assign
id|SPD_DET
suffix:semicolon
r_return
id|PDET_LINK_WAIT
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|lp-&gt;media
op_eq
id|ANS
)paren
(brace
multiline_comment|/* Do MII parallel detection */
r_if
c_cond
(paren
id|is_spd_100
c_func
(paren
id|dev
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|_100Mb
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;media
op_assign
id|_10Mb
suffix:semicolon
)brace
id|next_tick
op_assign
id|dc2114x_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|lp-&gt;media
op_eq
id|_100Mb
)paren
op_logical_and
id|is_100_up
c_func
(paren
id|dev
)paren
)paren
op_logical_or
(paren
(paren
(paren
id|lp-&gt;media
op_eq
id|_10Mb
)paren
op_logical_or
(paren
id|lp-&gt;media
op_eq
id|TP
)paren
op_logical_or
(paren
id|lp-&gt;media
op_eq
id|BNC
)paren
op_logical_or
(paren
id|lp-&gt;media
op_eq
id|AUI
)paren
)paren
op_logical_and
id|is_10_up
c_func
(paren
id|dev
)paren
)paren
)paren
(brace
id|next_tick
op_assign
id|dc2114x_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;tcount
op_increment
suffix:semicolon
id|lp-&gt;media
op_assign
id|INIT
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|_10Mb
suffix:colon
id|next_tick
op_assign
l_int|3000
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;tx_enable
)paren
(brace
id|SET_10Mb
suffix:semicolon
id|de4x5_init_connection
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;linkOK
op_logical_and
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_10_up
c_func
(paren
id|dev
)paren
op_logical_or
(paren
op_logical_neg
id|lp-&gt;useSROM
op_logical_and
id|is_spd_100
c_func
(paren
id|dev
)paren
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|INIT
suffix:semicolon
id|lp-&gt;tcount
op_increment
suffix:semicolon
id|next_tick
op_assign
id|DE4X5_AUTOSENSE_MS
suffix:semicolon
)brace
)brace
)brace
r_break
suffix:semicolon
r_case
id|_100Mb
suffix:colon
id|next_tick
op_assign
l_int|3000
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;tx_enable
)paren
(brace
id|SET_100Mb
suffix:semicolon
id|de4x5_init_connection
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;linkOK
op_logical_and
(paren
id|lp-&gt;autosense
op_eq
id|AUTO
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_100_up
c_func
(paren
id|dev
)paren
op_logical_or
(paren
op_logical_neg
id|lp-&gt;useSROM
op_logical_and
op_logical_neg
id|is_spd_100
c_func
(paren
id|dev
)paren
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|INIT
suffix:semicolon
id|lp-&gt;tcount
op_increment
suffix:semicolon
id|next_tick
op_assign
id|DE4X5_AUTOSENSE_MS
suffix:semicolon
)brace
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|lp-&gt;tcount
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Huh?: media:%02x&bslash;n&quot;
comma
id|lp-&gt;media
)paren
suffix:semicolon
id|lp-&gt;media
op_assign
id|INIT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|next_tick
suffix:semicolon
)brace
r_static
r_int
DECL|function|srom_autoconf
id|srom_autoconf
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
id|lp
op_member_access_from_pointer
id|infoleaf_fn
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** This mapping keeps the original media codes and FDX flag unchanged.&n;** While it isn&squot;t strictly necessary, it helps me for the moment...&n;** The early return avoids a media state / SROM media space clash.&n;*/
r_static
r_int
DECL|function|srom_map_media
id|srom_map_media
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|lp-&gt;fdx
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;infoblock_media
op_eq
id|lp-&gt;media
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|lp-&gt;infoblock_media
)paren
(brace
r_case
id|SROM_10BASETF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;params.fdx
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|lp-&gt;fdx
op_assign
id|TRUE
suffix:semicolon
r_case
id|SROM_10BASET
suffix:colon
r_if
c_cond
(paren
id|lp-&gt;params.fdx
op_logical_and
op_logical_neg
id|lp-&gt;fdx
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lp-&gt;chipset
op_eq
id|DC21140
)paren
op_logical_or
(paren
(paren
id|lp-&gt;chipset
op_amp
op_complement
l_int|0x00ff
)paren
op_eq
id|DC2114x
)paren
)paren
(brace
id|lp-&gt;media
op_assign
id|_10Mb
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;media
op_assign
id|TP
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SROM_10BASE2
suffix:colon
id|lp-&gt;media
op_assign
id|BNC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SROM_10BASE5
suffix:colon
id|lp-&gt;media
op_assign
id|AUI
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SROM_100BASETF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;params.fdx
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|lp-&gt;fdx
op_assign
id|TRUE
suffix:semicolon
r_case
id|SROM_100BASET
suffix:colon
r_if
c_cond
(paren
id|lp-&gt;params.fdx
op_logical_and
op_logical_neg
id|lp-&gt;fdx
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|lp-&gt;media
op_assign
id|_100Mb
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SROM_100BASET4
suffix:colon
id|lp-&gt;media
op_assign
id|_100Mb
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SROM_100BASEFF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;params.fdx
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|lp-&gt;fdx
op_assign
id|TRUE
suffix:semicolon
r_case
id|SROM_100BASEF
suffix:colon
r_if
c_cond
(paren
id|lp-&gt;params.fdx
op_logical_and
op_logical_neg
id|lp-&gt;fdx
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|lp-&gt;media
op_assign
id|_100Mb
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ANS
suffix:colon
id|lp-&gt;media
op_assign
id|ANS
suffix:semicolon
id|lp-&gt;fdx
op_assign
id|lp-&gt;params.fdx
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: Bad media code [%d] detected in SROM!&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|lp-&gt;infoblock_media
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|de4x5_init_connection
id|de4x5_init_connection
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u_long
id|flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;media
op_ne
id|lp-&gt;c_media
)paren
(brace
id|de4x5_dbg_media
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;c_media
op_assign
id|lp-&gt;media
suffix:semicolon
multiline_comment|/* Stop scrolling media messages */
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|de4x5_rst_desc_ring
c_func
(paren
id|dev
)paren
suffix:semicolon
id|de4x5_setup_intr
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;tx_enable
op_assign
id|YES
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|outl
c_func
(paren
id|POLL_DEMAND
comma
id|DE4X5_TPD
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** General PHY reset function. Some MII devices don&squot;t reset correctly&n;** since their MII address pins can float at voltages that are dependent&n;** on the signal pin use. Do a double reset to ensure a reset.&n;*/
r_static
r_int
DECL|function|de4x5_reset_phy
id|de4x5_reset_phy
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|next_tick
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lp-&gt;useSROM
)paren
op_logical_or
(paren
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|id
)paren
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;useSROM
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|rst
)paren
(brace
id|srom_exec
c_func
(paren
id|dev
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|rst
)paren
suffix:semicolon
id|srom_exec
c_func
(paren
id|dev
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|rst
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;rst
)paren
(brace
multiline_comment|/* Type 5 infoblock reset */
id|srom_exec
c_func
(paren
id|dev
comma
id|lp-&gt;rst
)paren
suffix:semicolon
id|srom_exec
c_func
(paren
id|dev
comma
id|lp-&gt;rst
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|PHY_HARD_RESET
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;useMII
)paren
(brace
id|mii_wr
c_func
(paren
id|MII_CR_RST
comma
id|MII_CR
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|lp-&gt;useMII
)paren
(brace
id|next_tick
op_assign
id|test_mii_reg
c_func
(paren
id|dev
comma
id|MII_CR
comma
id|MII_CR_RST
comma
id|FALSE
comma
l_int|500
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;chipset
op_eq
id|DC21140
)paren
(brace
id|PHY_HARD_RESET
suffix:semicolon
)brace
r_return
id|next_tick
suffix:semicolon
)brace
r_static
r_int
DECL|function|test_media
id|test_media
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|s32
id|irqs
comma
id|s32
id|irq_mask
comma
id|s32
id|csr13
comma
id|s32
id|csr14
comma
id|s32
id|csr15
comma
id|s32
id|msec
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|s32
id|sts
comma
id|csr12
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
(brace
id|lp-&gt;timeout
op_assign
id|msec
op_div
l_int|100
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;useSROM
)paren
(brace
multiline_comment|/* Already done if by SROM, else dc2104[01] */
id|reset_init_sia
c_func
(paren
id|dev
comma
id|csr13
comma
id|csr14
comma
id|csr15
)paren
suffix:semicolon
)brace
multiline_comment|/* set up the interrupt mask */
id|outl
c_func
(paren
id|irq_mask
comma
id|DE4X5_IMR
)paren
suffix:semicolon
multiline_comment|/* clear all pending interrupts */
id|sts
op_assign
id|inl
c_func
(paren
id|DE4X5_STS
)paren
suffix:semicolon
id|outl
c_func
(paren
id|sts
comma
id|DE4X5_STS
)paren
suffix:semicolon
multiline_comment|/* clear csr12 NRA and SRA bits */
r_if
c_cond
(paren
(paren
id|lp-&gt;chipset
op_eq
id|DC21041
)paren
op_logical_or
id|lp-&gt;useSROM
)paren
(brace
id|csr12
op_assign
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|csr12
comma
id|DE4X5_SISR
)paren
suffix:semicolon
)brace
)brace
id|sts
op_assign
id|inl
c_func
(paren
id|DE4X5_STS
)paren
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sts
op_amp
id|irqs
)paren
op_logical_and
op_decrement
id|lp-&gt;timeout
)paren
(brace
id|sts
op_assign
l_int|100
op_or
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;timeout
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|sts
suffix:semicolon
)brace
r_static
r_int
DECL|function|test_tp
id|test_tp
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|s32
id|msec
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|sisr
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
(brace
id|lp-&gt;timeout
op_assign
id|msec
op_div
l_int|100
suffix:semicolon
)brace
id|sisr
op_assign
(paren
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
op_amp
op_complement
id|TIMER_CB
)paren
op_amp
(paren
id|SISR_LKF
op_or
id|SISR_NCR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sisr
op_logical_and
op_decrement
id|lp-&gt;timeout
)paren
(brace
id|sisr
op_assign
l_int|100
op_or
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;timeout
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|sisr
suffix:semicolon
)brace
multiline_comment|/*&n;** Samples the 100Mb Link State Signal. The sample interval is important&n;** because too fast a rate can give erroneous results and confuse the&n;** speed sense algorithm.&n;*/
DECL|macro|SAMPLE_INTERVAL
mdefine_line|#define SAMPLE_INTERVAL 500  /* ms */
DECL|macro|SAMPLE_DELAY
mdefine_line|#define SAMPLE_DELAY    2000 /* ms */
r_static
r_int
DECL|function|test_for_100Mb
id|test_for_100Mb
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|msec
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|gep
op_assign
l_int|0
comma
id|ret
op_assign
(paren
(paren
id|lp-&gt;chipset
op_amp
op_complement
l_int|0x00ff
)paren
op_eq
id|DC2114x
ques
c_cond
op_minus
l_int|1
suffix:colon
id|GEP_SLNK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|msec
op_div
id|SAMPLE_INTERVAL
)paren
op_le
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|msec
OG
id|SAMPLE_DELAY
)paren
(brace
id|lp-&gt;timeout
op_assign
(paren
id|msec
op_minus
id|SAMPLE_DELAY
)paren
op_div
id|SAMPLE_INTERVAL
suffix:semicolon
id|gep
op_assign
id|SAMPLE_DELAY
op_or
id|TIMER_CB
suffix:semicolon
r_return
id|gep
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;timeout
op_assign
id|msec
op_div
id|SAMPLE_INTERVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|id
op_logical_or
id|lp-&gt;useSROM
)paren
(brace
id|gep
op_assign
id|is_100_up
c_func
(paren
id|dev
)paren
op_or
id|is_spd_100
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|gep
op_assign
(paren
op_complement
id|gep_rd
c_func
(paren
id|dev
)paren
op_amp
(paren
id|GEP_SLNK
op_or
id|GEP_LNP
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|gep
op_amp
id|ret
)paren
op_logical_and
op_decrement
id|lp-&gt;timeout
)paren
(brace
id|gep
op_assign
id|SAMPLE_INTERVAL
op_or
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;timeout
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|gep
suffix:semicolon
)brace
r_static
r_int
DECL|function|wait_for_link
id|wait_for_link
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
(brace
id|lp-&gt;timeout
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;timeout
op_decrement
)paren
(brace
r_return
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;timeout
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;**&n;**&n;*/
r_static
r_int
DECL|function|test_mii_reg
id|test_mii_reg
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|reg
comma
r_int
id|mask
comma
r_int
id|pol
comma
r_int
id|msec
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|test
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
(brace
id|lp-&gt;timeout
op_assign
id|msec
op_div
l_int|100
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pol
)paren
id|pol
op_assign
op_complement
l_int|0
suffix:semicolon
id|reg
op_assign
id|mii_rd
c_func
(paren
(paren
id|u_char
)paren
id|reg
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
op_amp
id|mask
suffix:semicolon
id|test
op_assign
(paren
id|reg
op_xor
id|pol
)paren
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|test
op_logical_and
op_decrement
id|lp-&gt;timeout
)paren
(brace
id|reg
op_assign
l_int|100
op_or
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;timeout
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|reg
suffix:semicolon
)brace
r_static
r_int
DECL|function|is_spd_100
id|is_spd_100
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|spd
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;useMII
)paren
(brace
id|spd
op_assign
id|mii_rd
c_func
(paren
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|spd.reg
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
suffix:semicolon
id|spd
op_assign
op_complement
(paren
id|spd
op_xor
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|spd.value
)paren
suffix:semicolon
id|spd
op_and_assign
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|spd.mask
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;useSROM
)paren
(brace
multiline_comment|/* de500-xa */
id|spd
op_assign
(paren
(paren
op_complement
id|gep_rd
c_func
(paren
id|dev
)paren
)paren
op_amp
id|GEP_SLNK
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|lp-&gt;ibn
op_eq
l_int|2
)paren
op_logical_or
op_logical_neg
id|lp-&gt;asBitValid
)paren
r_return
(paren
(paren
id|lp-&gt;chipset
op_eq
id|DC21143
)paren
ques
c_cond
(paren
op_complement
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
op_amp
id|SISR_LS100
)paren
suffix:colon
l_int|0
)paren
suffix:semicolon
id|spd
op_assign
(paren
id|lp-&gt;asBitValid
op_amp
(paren
id|lp-&gt;asPolarity
op_xor
(paren
id|gep_rd
c_func
(paren
id|dev
)paren
op_amp
id|lp-&gt;asBit
)paren
)paren
)paren
op_or
(paren
id|lp-&gt;linkOK
op_amp
op_complement
id|lp-&gt;asBitValid
)paren
suffix:semicolon
)brace
r_return
id|spd
suffix:semicolon
)brace
r_static
r_int
DECL|function|is_100_up
id|is_100_up
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;useMII
)paren
(brace
multiline_comment|/* Double read for sticky bits &amp; temporary drops */
id|mii_rd
c_func
(paren
id|MII_SR
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
suffix:semicolon
r_return
(paren
id|mii_rd
c_func
(paren
id|MII_SR
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
op_amp
id|MII_SR_LKS
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;useSROM
)paren
(brace
multiline_comment|/* de500-xa */
r_return
(paren
(paren
op_complement
id|gep_rd
c_func
(paren
id|dev
)paren
)paren
op_amp
id|GEP_SLNK
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|lp-&gt;ibn
op_eq
l_int|2
)paren
op_logical_or
op_logical_neg
id|lp-&gt;asBitValid
)paren
r_return
(paren
(paren
id|lp-&gt;chipset
op_eq
id|DC21143
)paren
ques
c_cond
(paren
op_complement
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
op_amp
id|SISR_LS100
)paren
suffix:colon
l_int|0
)paren
suffix:semicolon
r_return
(paren
(paren
id|lp-&gt;asBitValid
op_amp
(paren
id|lp-&gt;asPolarity
op_xor
(paren
id|gep_rd
c_func
(paren
id|dev
)paren
op_amp
id|lp-&gt;asBit
)paren
)paren
)paren
op_or
(paren
id|lp-&gt;linkOK
op_amp
op_complement
id|lp-&gt;asBitValid
)paren
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|is_10_up
id|is_10_up
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;useMII
)paren
(brace
multiline_comment|/* Double read for sticky bits &amp; temporary drops */
id|mii_rd
c_func
(paren
id|MII_SR
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
suffix:semicolon
r_return
(paren
id|mii_rd
c_func
(paren
id|MII_SR
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
op_amp
id|MII_SR_LKS
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;useSROM
)paren
(brace
multiline_comment|/* de500-xa */
r_return
(paren
(paren
op_complement
id|gep_rd
c_func
(paren
id|dev
)paren
)paren
op_amp
id|GEP_LNP
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|lp-&gt;ibn
op_eq
l_int|2
)paren
op_logical_or
op_logical_neg
id|lp-&gt;asBitValid
)paren
r_return
(paren
(paren
(paren
id|lp-&gt;chipset
op_amp
op_complement
l_int|0x00ff
)paren
op_eq
id|DC2114x
)paren
ques
c_cond
(paren
op_complement
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
op_amp
id|SISR_LS10
)paren
suffix:colon
l_int|0
)paren
suffix:semicolon
r_return
(paren
(paren
id|lp-&gt;asBitValid
op_amp
(paren
id|lp-&gt;asPolarity
op_xor
(paren
id|gep_rd
c_func
(paren
id|dev
)paren
op_amp
id|lp-&gt;asBit
)paren
)paren
)paren
op_or
(paren
id|lp-&gt;linkOK
op_amp
op_complement
id|lp-&gt;asBitValid
)paren
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|is_anc_capable
id|is_anc_capable
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|id
op_logical_and
(paren
op_logical_neg
id|lp-&gt;useSROM
op_logical_or
id|lp-&gt;useMII
)paren
)paren
(brace
r_return
(paren
id|mii_rd
c_func
(paren
id|MII_SR
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|lp-&gt;chipset
op_amp
op_complement
l_int|0x00ff
)paren
op_eq
id|DC2114x
)paren
(brace
r_return
(paren
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
op_amp
id|SISR_LPN
)paren
op_rshift
l_int|12
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;** Send a packet onto the media and watch for send errors that indicate the&n;** media is bad or unconnected.&n;*/
r_static
r_int
DECL|function|ping_media
id|ping_media
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|msec
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|sisr
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
(brace
id|lp-&gt;timeout
op_assign
id|msec
op_div
l_int|100
suffix:semicolon
id|lp-&gt;tmp
op_assign
id|lp-&gt;tx_new
suffix:semicolon
multiline_comment|/* Remember the ring position */
id|load_packet
c_func
(paren
id|dev
comma
id|lp-&gt;frame
comma
id|TD_LS
op_or
id|TD_FS
op_or
r_sizeof
(paren
id|lp-&gt;frame
)paren
comma
(paren
r_struct
id|sk_buff
op_star
)paren
l_int|1
)paren
suffix:semicolon
id|lp-&gt;tx_new
op_assign
(paren
op_increment
id|lp-&gt;tx_new
)paren
op_mod
id|lp-&gt;txRingSize
suffix:semicolon
id|outl
c_func
(paren
id|POLL_DEMAND
comma
id|DE4X5_TPD
)paren
suffix:semicolon
)brace
id|sisr
op_assign
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|sisr
op_amp
id|SISR_NCR
)paren
)paren
op_logical_and
(paren
(paren
id|s32
)paren
id|le32_to_cpu
c_func
(paren
id|lp-&gt;tx_ring
(braket
id|lp-&gt;tmp
)braket
dot
id|status
)paren
OL
l_int|0
)paren
op_logical_and
(paren
op_decrement
id|lp-&gt;timeout
)paren
)paren
(brace
id|sisr
op_assign
l_int|100
op_or
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|sisr
op_amp
id|SISR_NCR
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|le32_to_cpu
c_func
(paren
id|lp-&gt;tx_ring
(braket
id|lp-&gt;tmp
)braket
dot
id|status
)paren
op_amp
(paren
id|T_OWN
op_or
id|TD_ES
)paren
)paren
op_logical_and
id|lp-&gt;timeout
)paren
(brace
id|sisr
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|sisr
op_assign
l_int|1
suffix:semicolon
)brace
id|lp-&gt;timeout
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|sisr
suffix:semicolon
)brace
multiline_comment|/*&n;** This function does 2 things: on Intels it kmalloc&squot;s another buffer to&n;** replace the one about to be passed up. On Alpha&squot;s it kmallocs a buffer&n;** into which the packet is copied.&n;*/
r_static
r_struct
id|sk_buff
op_star
DECL|function|de4x5_alloc_rx_buff
id|de4x5_alloc_rx_buff
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|index
comma
r_int
id|len
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|sk_buff
op_star
id|p
suffix:semicolon
macro_line|#if !defined(__alpha__) &amp;&amp; !defined(__powerpc__) &amp;&amp; !defined(__sparc_v9__) &amp;&amp; !defined(DE4X5_DO_MEMCPY)
r_struct
id|sk_buff
op_star
id|ret
suffix:semicolon
id|u_long
id|i
op_assign
l_int|0
comma
id|tmp
suffix:semicolon
id|p
op_assign
id|dev_alloc_skb
c_func
(paren
id|IEEE802_3_SZ
op_plus
id|ALIGN
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
l_int|NULL
suffix:semicolon
id|p-&gt;dev
op_assign
id|dev
suffix:semicolon
id|tmp
op_assign
id|virt_to_bus
c_func
(paren
id|p-&gt;data
)paren
suffix:semicolon
id|i
op_assign
(paren
(paren
id|tmp
op_plus
id|ALIGN
)paren
op_amp
op_complement
id|ALIGN
)paren
op_minus
id|tmp
suffix:semicolon
id|skb_reserve
c_func
(paren
id|p
comma
id|i
)paren
suffix:semicolon
id|lp-&gt;rx_ring
(braket
id|index
)braket
dot
id|buf
op_assign
id|tmp
op_plus
id|i
suffix:semicolon
id|ret
op_assign
id|lp-&gt;rx_skb
(braket
id|index
)braket
suffix:semicolon
id|lp-&gt;rx_skb
(braket
id|index
)braket
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
(paren
id|u_long
)paren
id|ret
OG
l_int|1
)paren
(brace
id|skb_put
c_func
(paren
id|ret
comma
id|len
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|lp-&gt;state
op_ne
id|OPEN
)paren
r_return
(paren
r_struct
id|sk_buff
op_star
)paren
l_int|1
suffix:semicolon
multiline_comment|/* Fake out the open */
id|p
op_assign
id|dev_alloc_skb
c_func
(paren
id|len
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
l_int|NULL
suffix:semicolon
id|p-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_reserve
c_func
(paren
id|p
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Align */
r_if
c_cond
(paren
id|index
OL
id|lp-&gt;rx_old
)paren
(brace
multiline_comment|/* Wrapped buffer */
r_int
id|tlen
op_assign
(paren
id|lp-&gt;rxRingSize
op_minus
id|lp-&gt;rx_old
)paren
op_star
id|RX_BUFF_SZ
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|p
comma
id|tlen
)paren
comma
id|lp-&gt;rx_bufs
op_plus
id|lp-&gt;rx_old
op_star
id|RX_BUFF_SZ
comma
id|tlen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|p
comma
id|len
op_minus
id|tlen
)paren
comma
id|lp-&gt;rx_bufs
comma
id|len
op_minus
id|tlen
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Linear buffer */
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|p
comma
id|len
)paren
comma
id|lp-&gt;rx_bufs
op_plus
id|lp-&gt;rx_old
op_star
id|RX_BUFF_SZ
comma
id|len
)paren
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
macro_line|#endif
)brace
r_static
r_void
DECL|function|de4x5_free_rx_buffs
id|de4x5_free_rx_buffs
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;rxRingSize
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|u_long
)paren
id|lp-&gt;rx_skb
(braket
id|i
)braket
OG
l_int|1
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|lp-&gt;rx_skb
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;rx_skb
(braket
id|i
)braket
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
l_int|1
suffix:semicolon
multiline_comment|/* Dummy entry */
)brace
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|de4x5_free_tx_buffs
id|de4x5_free_tx_buffs
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;txRingSize
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;tx_skb
(braket
id|i
)braket
)paren
id|de4x5_free_tx_buff
c_func
(paren
id|lp
comma
id|i
)paren
suffix:semicolon
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|status
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Unload the locally queued packets */
r_while
c_loop
(paren
id|lp-&gt;cache.skb
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|de4x5_get_cache
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** When a user pulls a connection, the DECchip can end up in a&n;** &squot;running - waiting for end of transmission&squot; state. This means that we&n;** have to perform a chip soft reset to ensure that we can synchronize&n;** the hardware and software and make any media probes using a loopback&n;** packet meaningful.&n;*/
r_static
r_void
DECL|function|de4x5_save_skbs
id|de4x5_save_skbs
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|s32
id|omr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;cache.save_cnt
)paren
(brace
id|STOP_DE4X5
suffix:semicolon
id|de4x5_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Flush any sent skb&squot;s */
id|de4x5_free_tx_buffs
c_func
(paren
id|dev
)paren
suffix:semicolon
id|de4x5_cache_state
c_func
(paren
id|dev
comma
id|DE4X5_SAVE_STATE
)paren
suffix:semicolon
id|de4x5_sw_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
id|de4x5_cache_state
c_func
(paren
id|dev
comma
id|DE4X5_RESTORE_STATE
)paren
suffix:semicolon
id|lp-&gt;cache.save_cnt
op_increment
suffix:semicolon
id|START_DE4X5
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|de4x5_rst_desc_ring
id|de4x5_rst_desc_ring
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|s32
id|omr
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;cache.save_cnt
)paren
(brace
id|STOP_DE4X5
suffix:semicolon
id|outl
c_func
(paren
id|lp-&gt;dma_rings
comma
id|DE4X5_RRBA
)paren
suffix:semicolon
id|outl
c_func
(paren
id|lp-&gt;dma_rings
op_plus
id|NUM_RX_DESC
op_star
r_sizeof
(paren
r_struct
id|de4x5_desc
)paren
comma
id|DE4X5_TRBA
)paren
suffix:semicolon
id|lp-&gt;rx_new
op_assign
id|lp-&gt;rx_old
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tx_new
op_assign
id|lp-&gt;tx_old
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;rxRingSize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status
op_assign
id|cpu_to_le32
c_func
(paren
id|R_OWN
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;txRingSize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|status
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|lp-&gt;cache.save_cnt
op_decrement
suffix:semicolon
id|START_DE4X5
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|de4x5_cache_state
id|de4x5_cache_state
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|flag
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_switch
c_cond
(paren
id|flag
)paren
(brace
r_case
id|DE4X5_SAVE_STATE
suffix:colon
id|lp-&gt;cache.csr0
op_assign
id|inl
c_func
(paren
id|DE4X5_BMR
)paren
suffix:semicolon
id|lp-&gt;cache.csr6
op_assign
(paren
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
op_amp
op_complement
(paren
id|OMR_ST
op_or
id|OMR_SR
)paren
)paren
suffix:semicolon
id|lp-&gt;cache.csr7
op_assign
id|inl
c_func
(paren
id|DE4X5_IMR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DE4X5_RESTORE_STATE
suffix:colon
id|outl
c_func
(paren
id|lp-&gt;cache.csr0
comma
id|DE4X5_BMR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|lp-&gt;cache.csr6
comma
id|DE4X5_OMR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|lp-&gt;cache.csr7
comma
id|DE4X5_IMR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;chipset
op_eq
id|DC21140
)paren
(brace
id|gep_wr
c_func
(paren
id|lp-&gt;cache.gepc
comma
id|dev
)paren
suffix:semicolon
id|gep_wr
c_func
(paren
id|lp-&gt;cache.gep
comma
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|reset_init_sia
c_func
(paren
id|dev
comma
id|lp-&gt;cache.csr13
comma
id|lp-&gt;cache.csr14
comma
id|lp-&gt;cache.csr15
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|de4x5_put_cache
id|de4x5_put_cache
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|sk_buff
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;cache.skb
)paren
(brace
r_for
c_loop
(paren
id|p
op_assign
id|lp-&gt;cache.skb
suffix:semicolon
id|p-&gt;next
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
suffix:semicolon
id|p-&gt;next
op_assign
id|skb
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;cache.skb
op_assign
id|skb
suffix:semicolon
)brace
id|skb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|de4x5_putb_cache
id|de4x5_putb_cache
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|sk_buff
op_star
id|p
op_assign
id|lp-&gt;cache.skb
suffix:semicolon
id|lp-&gt;cache.skb
op_assign
id|skb
suffix:semicolon
id|skb-&gt;next
op_assign
id|p
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_struct
id|sk_buff
op_star
DECL|function|de4x5_get_cache
id|de4x5_get_cache
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|sk_buff
op_star
id|p
op_assign
id|lp-&gt;cache.skb
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|lp-&gt;cache.skb
op_assign
id|p-&gt;next
suffix:semicolon
id|p-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/*&n;** Check the Auto Negotiation State. Return OK when a link pass interrupt&n;** is received and the auto-negotiation status is NWAY OK.&n;*/
r_static
r_int
DECL|function|test_ans
id|test_ans
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|s32
id|irqs
comma
id|s32
id|irq_mask
comma
id|s32
id|msec
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|s32
id|sts
comma
id|ans
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
(brace
id|lp-&gt;timeout
op_assign
id|msec
op_div
l_int|100
suffix:semicolon
id|outl
c_func
(paren
id|irq_mask
comma
id|DE4X5_IMR
)paren
suffix:semicolon
multiline_comment|/* clear all pending interrupts */
id|sts
op_assign
id|inl
c_func
(paren
id|DE4X5_STS
)paren
suffix:semicolon
id|outl
c_func
(paren
id|sts
comma
id|DE4X5_STS
)paren
suffix:semicolon
)brace
id|ans
op_assign
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
op_amp
id|SISR_ANS
suffix:semicolon
id|sts
op_assign
id|inl
c_func
(paren
id|DE4X5_STS
)paren
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sts
op_amp
id|irqs
)paren
op_logical_and
(paren
id|ans
op_xor
id|ANS_NWOK
)paren
op_logical_and
op_decrement
id|lp-&gt;timeout
)paren
(brace
id|sts
op_assign
l_int|100
op_or
id|TIMER_CB
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;timeout
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|sts
suffix:semicolon
)brace
r_static
r_void
DECL|function|de4x5_setup_intr
id|de4x5_setup_intr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|s32
id|imr
comma
id|sts
suffix:semicolon
r_if
c_cond
(paren
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
op_amp
id|OMR_SR
)paren
(brace
multiline_comment|/* Only unmask if TX/RX is enabled */
id|imr
op_assign
l_int|0
suffix:semicolon
id|UNMASK_IRQs
suffix:semicolon
id|sts
op_assign
id|inl
c_func
(paren
id|DE4X5_STS
)paren
suffix:semicolon
multiline_comment|/* Reset any pending (stale) interrupts */
id|outl
c_func
(paren
id|sts
comma
id|DE4X5_STS
)paren
suffix:semicolon
id|ENABLE_IRQs
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;**&n;*/
r_static
r_void
DECL|function|reset_init_sia
id|reset_init_sia
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|s32
id|csr13
comma
id|s32
id|csr14
comma
id|s32
id|csr15
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|RESET_SIA
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;useSROM
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;ibn
op_eq
l_int|3
)paren
(brace
id|srom_exec
c_func
(paren
id|dev
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|rst
)paren
suffix:semicolon
id|srom_exec
c_func
(paren
id|dev
comma
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|gep
)paren
suffix:semicolon
id|outl
c_func
(paren
l_int|1
comma
id|DE4X5_SICR
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|csr15
op_assign
id|lp-&gt;cache.csr15
suffix:semicolon
id|csr14
op_assign
id|lp-&gt;cache.csr14
suffix:semicolon
id|csr13
op_assign
id|lp-&gt;cache.csr13
suffix:semicolon
id|outl
c_func
(paren
id|csr15
op_or
id|lp-&gt;cache.gepc
comma
id|DE4X5_SIGR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|csr15
op_or
id|lp-&gt;cache.gep
comma
id|DE4X5_SIGR
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|outl
c_func
(paren
id|csr15
comma
id|DE4X5_SIGR
)paren
suffix:semicolon
)brace
id|outl
c_func
(paren
id|csr14
comma
id|DE4X5_STRR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|csr13
comma
id|DE4X5_SICR
)paren
suffix:semicolon
id|de4x5_ms_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** Create a loopback ethernet packet&n;*/
r_static
r_void
DECL|function|create_packet
id|create_packet
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_char
op_star
id|frame
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|buf
op_assign
id|frame
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Use this source address */
op_star
id|buf
op_increment
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Use this destination address */
op_star
id|buf
op_increment
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
)brace
op_star
id|buf
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Packet length (2 bytes) */
op_star
id|buf
op_increment
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** Known delay in microseconds&n;*/
r_static
r_void
DECL|function|de4x5_us_delay
id|de4x5_us_delay
c_func
(paren
id|u32
id|usec
)paren
(brace
id|udelay
c_func
(paren
id|usec
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** Known delay in milliseconds, in millisecond steps.&n;*/
r_static
r_void
DECL|function|de4x5_ms_delay
id|de4x5_ms_delay
c_func
(paren
id|u32
id|msec
)paren
(brace
id|u_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|msec
suffix:semicolon
id|i
op_increment
)paren
(brace
id|de4x5_us_delay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** Look for a particular board name in the EISA configuration space&n;*/
r_static
r_int
DECL|function|EISA_signature
id|EISA_signature
c_func
(paren
r_char
op_star
id|name
comma
id|s32
id|eisa_id
)paren
(brace
r_static
id|c_char
op_star
id|signatures
(braket
)braket
op_assign
id|DE4X5_SIGNATURE
suffix:semicolon
r_char
id|ManCode
(braket
id|DE4X5_STRLEN
)braket
suffix:semicolon
r_union
(brace
id|s32
id|ID
suffix:semicolon
r_char
id|Id
(braket
l_int|4
)braket
suffix:semicolon
)brace
id|Eisa
suffix:semicolon
r_int
id|i
comma
id|status
op_assign
l_int|0
comma
id|siglen
op_assign
r_sizeof
(paren
id|signatures
)paren
op_div
r_sizeof
(paren
id|c_char
op_star
)paren
suffix:semicolon
op_star
id|name
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|Eisa.ID
op_assign
id|inl
c_func
(paren
id|eisa_id
)paren
suffix:semicolon
id|ManCode
(braket
l_int|0
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|0
)braket
op_rshift
l_int|2
)paren
op_amp
l_int|0x1f
)paren
op_plus
l_int|0x40
)paren
suffix:semicolon
id|ManCode
(braket
l_int|1
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|1
)braket
op_amp
l_int|0xe0
)paren
op_rshift
l_int|5
)paren
op_plus
(paren
(paren
id|Eisa.Id
(braket
l_int|0
)braket
op_amp
l_int|0x03
)paren
op_lshift
l_int|3
)paren
op_plus
l_int|0x40
)paren
suffix:semicolon
id|ManCode
(braket
l_int|2
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|2
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
op_plus
l_int|0x30
)paren
suffix:semicolon
id|ManCode
(braket
l_int|3
)braket
op_assign
(paren
(paren
id|Eisa.Id
(braket
l_int|2
)braket
op_amp
l_int|0x0f
)paren
op_plus
l_int|0x30
)paren
suffix:semicolon
id|ManCode
(braket
l_int|4
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|3
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
op_plus
l_int|0x30
)paren
suffix:semicolon
id|ManCode
(braket
l_int|5
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|siglen
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|ManCode
comma
id|signatures
(braket
id|i
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|strcpy
c_func
(paren
id|name
comma
id|ManCode
)paren
suffix:semicolon
id|status
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|status
suffix:semicolon
multiline_comment|/* return the device name string */
)brace
multiline_comment|/*&n;** Look for a particular board name in the PCI configuration space&n;*/
r_static
r_int
DECL|function|PCI_signature
id|PCI_signature
c_func
(paren
r_char
op_star
id|name
comma
r_struct
id|bus_type
op_star
id|lp
)paren
(brace
r_static
id|c_char
op_star
id|de4x5_signatures
(braket
)braket
op_assign
id|DE4X5_SIGNATURE
suffix:semicolon
r_int
id|i
comma
id|status
op_assign
l_int|0
comma
id|siglen
op_assign
r_sizeof
(paren
id|de4x5_signatures
)paren
op_div
r_sizeof
(paren
id|c_char
op_star
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;chipset
op_eq
id|DC21040
)paren
(brace
id|strcpy
c_func
(paren
id|name
comma
l_string|&quot;DE434/5&quot;
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Search for a DEC name in the SROM */
r_int
id|i
op_assign
op_star
(paren
(paren
r_char
op_star
)paren
op_amp
id|lp-&gt;srom
op_plus
l_int|19
)paren
op_star
l_int|3
suffix:semicolon
id|strncpy
c_func
(paren
id|name
comma
(paren
r_char
op_star
)paren
op_amp
id|lp-&gt;srom
op_plus
l_int|26
op_plus
id|i
comma
l_int|8
)paren
suffix:semicolon
)brace
id|name
(braket
l_int|8
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|siglen
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|name
comma
id|de4x5_signatures
(braket
id|i
)braket
)paren
op_ne
l_int|NULL
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|siglen
)paren
(brace
r_if
c_cond
(paren
id|dec_only
)paren
(brace
op_star
id|name
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Use chip name to avoid confusion */
id|strcpy
c_func
(paren
id|name
comma
(paren
(paren
(paren
id|lp-&gt;chipset
op_eq
id|DC21040
)paren
ques
c_cond
l_string|&quot;DC21040&quot;
suffix:colon
(paren
(paren
id|lp-&gt;chipset
op_eq
id|DC21041
)paren
ques
c_cond
l_string|&quot;DC21041&quot;
suffix:colon
(paren
(paren
id|lp-&gt;chipset
op_eq
id|DC21140
)paren
ques
c_cond
l_string|&quot;DC21140&quot;
suffix:colon
(paren
(paren
id|lp-&gt;chipset
op_eq
id|DC21142
)paren
ques
c_cond
l_string|&quot;DC21142&quot;
suffix:colon
(paren
(paren
id|lp-&gt;chipset
op_eq
id|DC21143
)paren
ques
c_cond
l_string|&quot;DC21143&quot;
suffix:colon
l_string|&quot;UNKNOWN&quot;
)paren
)paren
)paren
)paren
)paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;chipset
op_ne
id|DC21041
)paren
(brace
id|useSROM
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* card is not recognisably DEC */
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|lp-&gt;chipset
op_amp
op_complement
l_int|0x00ff
)paren
op_eq
id|DC2114x
)paren
(brace
id|useSROM
op_assign
id|TRUE
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;** Set up the Ethernet PROM counter to the start of the Ethernet address on&n;** the DC21040, else  read the SROM for the other chips.&n;** The SROM may not be present in a multi-MAC card, so first read the&n;** MAC address and check for a bad address. If there is a bad one then exit&n;** immediately with the prior srom contents intact (the h/w address will&n;** be fixed up later).&n;*/
r_static
r_void
DECL|function|DevicePresent
id|DevicePresent
c_func
(paren
id|u_long
id|aprom_addr
)paren
(brace
r_int
id|i
comma
id|j
op_assign
l_int|0
suffix:semicolon
r_struct
id|bus_type
op_star
id|lp
op_assign
op_amp
id|bus
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;chipset
op_eq
id|DC21040
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;bus
op_eq
id|EISA
)paren
(brace
id|enet_addr_rst
c_func
(paren
id|aprom_addr
)paren
suffix:semicolon
multiline_comment|/* Reset Ethernet Address ROM Pointer */
)brace
r_else
(brace
id|outl
c_func
(paren
l_int|0
comma
id|aprom_addr
)paren
suffix:semicolon
multiline_comment|/* Reset Ethernet Address ROM Pointer */
)brace
)brace
r_else
(brace
multiline_comment|/* Read new srom */
id|u_short
id|tmp
comma
op_star
id|p
op_assign
(paren
r_int
op_star
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|lp-&gt;srom
op_plus
id|SROM_HWADD
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|ETH_ALEN
op_rshift
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|srom_rd
c_func
(paren
id|aprom_addr
comma
(paren
id|SROM_HWADD
op_rshift
l_int|1
)paren
op_plus
id|i
)paren
suffix:semicolon
op_star
id|p
op_assign
id|le16_to_cpu
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|j
op_add_assign
op_star
id|p
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|j
op_eq
l_int|0
)paren
op_logical_or
(paren
id|j
op_eq
l_int|0x2fffd
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|p
op_assign
(paren
r_int
op_star
)paren
op_amp
id|lp-&gt;srom
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_sizeof
(paren
r_struct
id|de4x5_srom
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|srom_rd
c_func
(paren
id|aprom_addr
comma
id|i
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|le16_to_cpu
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|de4x5_dbg_srom
c_func
(paren
(paren
r_struct
id|de4x5_srom
op_star
)paren
op_amp
id|lp-&gt;srom
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** Since the write on the Enet PROM register doesn&squot;t seem to reset the PROM&n;** pointer correctly (at least on my DE425 EISA card), this routine should do&n;** it...from depca.c.&n;*/
r_static
r_void
DECL|function|enet_addr_rst
id|enet_addr_rst
c_func
(paren
id|u_long
id|aprom_addr
)paren
(brace
r_union
(brace
r_struct
(brace
id|u32
id|a
suffix:semicolon
id|u32
id|b
suffix:semicolon
)brace
id|llsig
suffix:semicolon
r_char
id|Sig
(braket
r_sizeof
(paren
id|u32
)paren
op_lshift
l_int|1
)braket
suffix:semicolon
)brace
id|dev
suffix:semicolon
r_int
id|sigLength
op_assign
l_int|0
suffix:semicolon
id|s8
id|data
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
id|dev.llsig.a
op_assign
id|ETH_PROM_SIG
suffix:semicolon
id|dev.llsig.b
op_assign
id|ETH_PROM_SIG
suffix:semicolon
id|sigLength
op_assign
r_sizeof
(paren
id|u32
)paren
op_lshift
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|sigLength
op_logical_and
id|i
OL
id|PROBE_LENGTH
op_plus
id|sigLength
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data
op_assign
id|inb
c_func
(paren
id|aprom_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev.Sig
(braket
id|j
)braket
op_eq
id|data
)paren
(brace
multiline_comment|/* track signature */
id|j
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* lost signature; begin search again */
r_if
c_cond
(paren
id|data
op_eq
id|dev.Sig
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* rare case.... */
id|j
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|j
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** For the bad status case and no SROM, then add one to the previous&n;** address. However, need to add one backwards in case we have 0xff&n;** as one or more of the bytes. Only the last 3 bytes should be checked&n;** as the first three are invariant - assigned to an organisation.&n;*/
r_static
r_int
DECL|function|get_hw_addr
id|get_hw_addr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|broken
comma
id|i
comma
id|k
comma
id|tmp
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|u_short
id|j
comma
id|chksum
suffix:semicolon
r_struct
id|bus_type
op_star
id|lp
op_assign
op_amp
id|bus
suffix:semicolon
id|broken
op_assign
id|de4x5_bad_srom
c_func
(paren
id|lp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|k
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|3
suffix:semicolon
id|j
op_increment
)paren
(brace
id|k
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
l_int|0xffff
)paren
id|k
op_sub_assign
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;bus
op_eq
id|PCI
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;chipset
op_eq
id|DC21040
)paren
(brace
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|inl
c_func
(paren
id|DE4X5_APROM
)paren
)paren
OL
l_int|0
)paren
suffix:semicolon
id|k
op_add_assign
(paren
id|u_char
)paren
id|tmp
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_increment
)braket
op_assign
(paren
id|u_char
)paren
id|tmp
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|inl
c_func
(paren
id|DE4X5_APROM
)paren
)paren
OL
l_int|0
)paren
suffix:semicolon
id|k
op_add_assign
(paren
id|u_short
)paren
(paren
id|tmp
op_lshift
l_int|8
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_increment
)braket
op_assign
(paren
id|u_char
)paren
id|tmp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|broken
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
(paren
id|u_char
)paren
id|lp-&gt;srom.ieee_addr
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
(paren
id|u_char
)paren
id|lp-&gt;srom.ieee_addr
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|broken
op_eq
id|SMC
)paren
op_logical_or
(paren
id|broken
op_eq
id|ACCTON
)paren
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
op_star
(paren
(paren
id|u_char
op_star
)paren
op_amp
id|lp-&gt;srom
op_plus
id|i
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
op_star
(paren
(paren
id|u_char
op_star
)paren
op_amp
id|lp-&gt;srom
op_plus
id|i
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
id|k
op_add_assign
(paren
id|u_char
)paren
(paren
id|tmp
op_assign
id|inb
c_func
(paren
id|EISA_APROM
)paren
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_increment
)braket
op_assign
(paren
id|u_char
)paren
id|tmp
suffix:semicolon
id|k
op_add_assign
(paren
id|u_short
)paren
(paren
(paren
id|tmp
op_assign
id|inb
c_func
(paren
id|EISA_APROM
)paren
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
op_increment
)braket
op_assign
(paren
id|u_char
)paren
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
OG
l_int|0xffff
)paren
id|k
op_sub_assign
l_int|0xffff
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
op_eq
l_int|0xffff
)paren
id|k
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;bus
op_eq
id|PCI
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;chipset
op_eq
id|DC21040
)paren
(brace
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|inl
c_func
(paren
id|DE4X5_APROM
)paren
)paren
OL
l_int|0
)paren
suffix:semicolon
id|chksum
op_assign
(paren
id|u_char
)paren
id|tmp
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|inl
c_func
(paren
id|DE4X5_APROM
)paren
)paren
OL
l_int|0
)paren
suffix:semicolon
id|chksum
op_or_assign
(paren
id|u_short
)paren
(paren
id|tmp
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|k
op_ne
id|chksum
)paren
op_logical_and
(paren
id|dec_only
)paren
)paren
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|chksum
op_assign
(paren
id|u_char
)paren
id|inb
c_func
(paren
id|EISA_APROM
)paren
suffix:semicolon
id|chksum
op_or_assign
(paren
id|u_short
)paren
(paren
id|inb
c_func
(paren
id|EISA_APROM
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|k
op_ne
id|chksum
)paren
op_logical_and
(paren
id|dec_only
)paren
)paren
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* If possible, try to fix a broken card - SMC only so far */
id|srom_repair
c_func
(paren
id|dev
comma
id|broken
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PPC
multiline_comment|/* &n;    ** If the address starts with 00 a0, we have to bit-reverse&n;    ** each byte of the address.&n;    */
r_if
c_cond
(paren
(paren
id|ppc_md.ppc_machine
op_amp
id|_MACH_Pmac
)paren
op_logical_and
(paren
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
op_logical_and
(paren
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
op_eq
l_int|0xa0
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int
id|x
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
id|x
op_assign
(paren
(paren
id|x
op_amp
l_int|0xf
)paren
op_lshift
l_int|4
)paren
op_plus
(paren
(paren
id|x
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
)paren
suffix:semicolon
id|x
op_assign
(paren
(paren
id|x
op_amp
l_int|0x33
)paren
op_lshift
l_int|2
)paren
op_plus
(paren
(paren
id|x
op_amp
l_int|0xcc
)paren
op_rshift
l_int|2
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
(paren
(paren
id|x
op_amp
l_int|0x55
)paren
op_lshift
l_int|1
)paren
op_plus
(paren
(paren
id|x
op_amp
l_int|0xaa
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_PPC */
multiline_comment|/* Test for a bad enet address */
id|status
op_assign
id|test_bad_enet
c_func
(paren
id|dev
comma
id|status
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;** Test for enet addresses in the first 32 bytes. The built-in strncmp&n;** didn&squot;t seem to work here...?&n;*/
r_static
r_int
DECL|function|de4x5_bad_srom
id|de4x5_bad_srom
c_func
(paren
r_struct
id|bus_type
op_star
id|lp
)paren
(brace
r_int
id|i
comma
id|status
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|enet_det
)paren
op_div
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|de4x5_strncmp
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|lp-&gt;srom
comma
(paren
r_char
op_star
)paren
op_amp
id|enet_det
(braket
id|i
)braket
comma
l_int|3
)paren
op_logical_and
op_logical_neg
id|de4x5_strncmp
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|lp-&gt;srom
op_plus
l_int|0x10
comma
(paren
r_char
op_star
)paren
op_amp
id|enet_det
(braket
id|i
)braket
comma
l_int|3
)paren
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|status
op_assign
id|SMC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|i
op_eq
l_int|1
)paren
(brace
id|status
op_assign
id|ACCTON
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_return
id|status
suffix:semicolon
)brace
r_static
r_int
DECL|function|de4x5_strncmp
id|de4x5_strncmp
c_func
(paren
r_char
op_star
id|a
comma
r_char
op_star
id|b
comma
r_int
id|n
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|n
op_logical_and
op_logical_neg
id|ret
suffix:semicolon
id|n
op_decrement
)paren
(brace
id|ret
op_assign
op_star
id|a
op_increment
op_minus
op_star
id|b
op_increment
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
r_void
DECL|function|srom_repair
id|srom_repair
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|card
)paren
(brace
r_struct
id|bus_type
op_star
id|lp
op_assign
op_amp
id|bus
suffix:semicolon
r_switch
c_cond
(paren
id|card
)paren
(brace
r_case
id|SMC
suffix:colon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|bus.srom
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|de4x5_srom
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|lp-&gt;srom.ieee_addr
comma
(paren
r_char
op_star
)paren
id|dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|lp-&gt;srom.info
comma
(paren
r_char
op_star
)paren
op_amp
id|srom_repair_info
(braket
id|SMC
op_minus
l_int|1
)braket
comma
l_int|100
)paren
suffix:semicolon
id|useSROM
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** Assume that the irq&squot;s do not follow the PCI spec - this is seems&n;** to be true so far (2 for 2).&n;*/
r_static
r_int
DECL|function|test_bad_enet
id|test_bad_enet
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|status
)paren
(brace
r_struct
id|bus_type
op_star
id|lp
op_assign
op_amp
id|bus
suffix:semicolon
r_int
id|i
comma
id|tmp
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
id|tmp
op_add_assign
(paren
id|u_char
)paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_eq
l_int|0
)paren
op_logical_or
(paren
id|tmp
op_eq
l_int|0x5fa
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|lp-&gt;chipset
op_eq
id|last.chipset
)paren
op_logical_and
(paren
id|lp-&gt;bus_num
op_eq
id|last.bus
)paren
op_logical_and
(paren
id|lp-&gt;bus_num
OG
l_int|0
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|last.addr
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|ETH_ALEN
op_minus
l_int|1
suffix:semicolon
id|i
OG
l_int|2
suffix:semicolon
op_decrement
id|i
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_ne
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
id|last.addr
(braket
id|i
)braket
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|an_exception
c_func
(paren
id|lp
)paren
)paren
(brace
id|dev-&gt;irq
op_assign
id|last.irq
suffix:semicolon
)brace
id|status
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
id|last.chipset
op_assign
id|lp-&gt;chipset
suffix:semicolon
id|last.bus
op_assign
id|lp-&gt;bus_num
suffix:semicolon
id|last.irq
op_assign
id|dev-&gt;irq
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
id|last.addr
(braket
id|i
)braket
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;** List of board exceptions with correctly wired IRQs&n;*/
r_static
r_int
DECL|function|an_exception
id|an_exception
c_func
(paren
r_struct
id|bus_type
op_star
id|lp
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
(paren
id|u_short
op_star
)paren
id|lp-&gt;srom.sub_vendor_id
op_eq
l_int|0x00c0
)paren
op_logical_and
(paren
op_star
(paren
id|u_short
op_star
)paren
id|lp-&gt;srom.sub_system_id
op_eq
l_int|0x95e0
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** SROM Read&n;*/
r_static
r_int
DECL|function|srom_rd
id|srom_rd
c_func
(paren
id|u_long
id|addr
comma
id|u_char
id|offset
)paren
(brace
id|sendto_srom
c_func
(paren
id|SROM_RD
op_or
id|SROM_SR
comma
id|addr
)paren
suffix:semicolon
id|srom_latch
c_func
(paren
id|SROM_RD
op_or
id|SROM_SR
op_or
id|DT_CS
comma
id|addr
)paren
suffix:semicolon
id|srom_command
c_func
(paren
id|SROM_RD
op_or
id|SROM_SR
op_or
id|DT_IN
op_or
id|DT_CS
comma
id|addr
)paren
suffix:semicolon
id|srom_address
c_func
(paren
id|SROM_RD
op_or
id|SROM_SR
op_or
id|DT_CS
comma
id|addr
comma
id|offset
)paren
suffix:semicolon
r_return
id|srom_data
c_func
(paren
id|SROM_RD
op_or
id|SROM_SR
op_or
id|DT_CS
comma
id|addr
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|srom_latch
id|srom_latch
c_func
(paren
id|u_int
id|command
comma
id|u_long
id|addr
)paren
(brace
id|sendto_srom
c_func
(paren
id|command
comma
id|addr
)paren
suffix:semicolon
id|sendto_srom
c_func
(paren
id|command
op_or
id|DT_CLK
comma
id|addr
)paren
suffix:semicolon
id|sendto_srom
c_func
(paren
id|command
comma
id|addr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|srom_command
id|srom_command
c_func
(paren
id|u_int
id|command
comma
id|u_long
id|addr
)paren
(brace
id|srom_latch
c_func
(paren
id|command
comma
id|addr
)paren
suffix:semicolon
id|srom_latch
c_func
(paren
id|command
comma
id|addr
)paren
suffix:semicolon
id|srom_latch
c_func
(paren
(paren
id|command
op_amp
l_int|0x0000ff00
)paren
op_or
id|DT_CS
comma
id|addr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|srom_address
id|srom_address
c_func
(paren
id|u_int
id|command
comma
id|u_long
id|addr
comma
id|u_char
id|offset
)paren
(brace
r_int
id|i
comma
id|a
suffix:semicolon
id|a
op_assign
id|offset
op_lshift
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
comma
id|a
op_lshift_assign
l_int|1
)paren
(brace
id|srom_latch
c_func
(paren
id|command
op_or
(paren
(paren
id|a
op_amp
l_int|0x80
)paren
ques
c_cond
id|DT_IN
suffix:colon
l_int|0
)paren
comma
id|addr
)paren
suffix:semicolon
)brace
id|de4x5_us_delay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|i
op_assign
(paren
id|getfrom_srom
c_func
(paren
id|addr
)paren
op_rshift
l_int|3
)paren
op_amp
l_int|0x01
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|srom_data
id|srom_data
c_func
(paren
id|u_int
id|command
comma
id|u_long
id|addr
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|word
op_assign
l_int|0
suffix:semicolon
id|s32
id|tmp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sendto_srom
c_func
(paren
id|command
op_or
id|DT_CLK
comma
id|addr
)paren
suffix:semicolon
id|tmp
op_assign
id|getfrom_srom
c_func
(paren
id|addr
)paren
suffix:semicolon
id|sendto_srom
c_func
(paren
id|command
comma
id|addr
)paren
suffix:semicolon
id|word
op_assign
(paren
id|word
op_lshift
l_int|1
)paren
op_or
(paren
(paren
id|tmp
op_rshift
l_int|3
)paren
op_amp
l_int|0x01
)paren
suffix:semicolon
)brace
id|sendto_srom
c_func
(paren
id|command
op_amp
l_int|0x0000ff00
comma
id|addr
)paren
suffix:semicolon
r_return
id|word
suffix:semicolon
)brace
multiline_comment|/*&n;static void&n;srom_busy(u_int command, u_long addr)&n;{&n;   sendto_srom((command &amp; 0x0000ff00) | DT_CS, addr);&n;   &n;   while (!((getfrom_srom(addr) &gt;&gt; 3) &amp; 0x01)) {&n;       de4x5_ms_delay(1);&n;   }&n;   &n;   sendto_srom(command &amp; 0x0000ff00, addr);&n;   &n;   return;&n;}&n;*/
r_static
r_void
DECL|function|sendto_srom
id|sendto_srom
c_func
(paren
id|u_int
id|command
comma
id|u_long
id|addr
)paren
(brace
id|outl
c_func
(paren
id|command
comma
id|addr
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|getfrom_srom
id|getfrom_srom
c_func
(paren
id|u_long
id|addr
)paren
(brace
id|s32
id|tmp
suffix:semicolon
id|tmp
op_assign
id|inl
c_func
(paren
id|addr
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
r_static
r_int
DECL|function|srom_infoleaf_info
id|srom_infoleaf_info
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
comma
id|count
suffix:semicolon
id|u_char
op_star
id|p
suffix:semicolon
multiline_comment|/* Find the infoleaf decoder function that matches this chipset */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|INFOLEAF_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;chipset
op_eq
id|infoleaf_array
(braket
id|i
)braket
dot
id|chipset
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|INFOLEAF_SIZE
)paren
(brace
id|lp-&gt;useSROM
op_assign
id|FALSE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Cannot find correct chipset for SROM decoding!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|lp-&gt;infoleaf_fn
op_assign
id|infoleaf_array
(braket
id|i
)braket
dot
id|fn
suffix:semicolon
multiline_comment|/* Find the information offset that this function should use */
id|count
op_assign
op_star
(paren
(paren
id|u_char
op_star
)paren
op_amp
id|lp-&gt;srom
op_plus
l_int|19
)paren
suffix:semicolon
id|p
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|lp-&gt;srom
op_plus
l_int|26
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|count
suffix:semicolon
id|i
suffix:semicolon
op_decrement
id|i
comma
id|p
op_add_assign
l_int|3
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;device
op_eq
op_star
id|p
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|lp-&gt;useSROM
op_assign
id|FALSE
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Cannot find correct PCI device [%d] for SROM decoding!&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|lp-&gt;device
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
)brace
id|lp-&gt;infoleaf_offset
op_assign
id|TWIDDLE
c_func
(paren
id|p
op_plus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** This routine loads any type 1 or 3 MII info into the mii device&n;** struct and executes any type 5 code to reset PHY devices for this&n;** controller.&n;** The info for the MII devices will be valid since the index used&n;** will follow the discovery process from MII address 1-31 then 0.&n;*/
r_static
r_void
DECL|function|srom_init
id|srom_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_char
op_star
id|p
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|lp-&gt;srom
op_plus
id|lp-&gt;infoleaf_offset
suffix:semicolon
id|u_char
id|count
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;chipset
op_eq
id|DC21140
)paren
(brace
id|lp-&gt;cache.gepc
op_assign
(paren
op_star
id|p
op_increment
op_or
id|GEP_CTRL
)paren
suffix:semicolon
id|gep_wr
c_func
(paren
id|lp-&gt;cache.gepc
comma
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Block count */
id|count
op_assign
op_star
id|p
op_increment
suffix:semicolon
multiline_comment|/* Jump the infoblocks to find types */
r_for
c_loop
(paren
suffix:semicolon
id|count
suffix:semicolon
op_decrement
id|count
)paren
(brace
r_if
c_cond
(paren
op_star
id|p
OL
l_int|128
)paren
(brace
id|p
op_add_assign
id|COMPACT_LEN
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
(paren
id|p
op_plus
l_int|1
)paren
op_eq
l_int|5
)paren
(brace
id|type5_infoblock
c_func
(paren
id|dev
comma
l_int|1
comma
id|p
)paren
suffix:semicolon
id|p
op_add_assign
(paren
(paren
op_star
id|p
op_amp
id|BLOCK_LEN
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
(paren
id|p
op_plus
l_int|1
)paren
op_eq
l_int|4
)paren
(brace
id|p
op_add_assign
(paren
(paren
op_star
id|p
op_amp
id|BLOCK_LEN
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
(paren
id|p
op_plus
l_int|1
)paren
op_eq
l_int|3
)paren
(brace
id|type3_infoblock
c_func
(paren
id|dev
comma
l_int|1
comma
id|p
)paren
suffix:semicolon
id|p
op_add_assign
(paren
(paren
op_star
id|p
op_amp
id|BLOCK_LEN
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
(paren
id|p
op_plus
l_int|1
)paren
op_eq
l_int|2
)paren
(brace
id|p
op_add_assign
(paren
(paren
op_star
id|p
op_amp
id|BLOCK_LEN
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
(paren
id|p
op_plus
l_int|1
)paren
op_eq
l_int|1
)paren
(brace
id|type1_infoblock
c_func
(paren
id|dev
comma
l_int|1
comma
id|p
)paren
suffix:semicolon
id|p
op_add_assign
(paren
(paren
op_star
id|p
op_amp
id|BLOCK_LEN
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|p
op_add_assign
(paren
(paren
op_star
id|p
op_amp
id|BLOCK_LEN
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** A generic routine that writes GEP control, data and reset information&n;** to the GEP register (21140) or csr15 GEP portion (2114[23]).&n;*/
r_static
r_void
DECL|function|srom_exec
id|srom_exec
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
op_star
id|p
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u_char
id|count
op_assign
(paren
id|p
ques
c_cond
op_star
id|p
op_increment
suffix:colon
l_int|0
)paren
suffix:semicolon
id|u_short
op_star
id|w
op_assign
(paren
id|u_short
op_star
)paren
id|p
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|lp-&gt;ibn
op_ne
l_int|1
)paren
op_logical_and
(paren
id|lp-&gt;ibn
op_ne
l_int|3
)paren
op_logical_and
(paren
id|lp-&gt;ibn
op_ne
l_int|5
)paren
)paren
op_logical_or
op_logical_neg
id|count
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;chipset
op_ne
id|DC21140
)paren
id|RESET_SIA
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|gep_wr
c_func
(paren
(paren
(paren
id|lp-&gt;chipset
op_eq
id|DC21140
)paren
op_logical_and
(paren
id|lp-&gt;ibn
op_ne
l_int|5
)paren
ques
c_cond
op_star
id|p
op_increment
suffix:colon
id|TWIDDLE
c_func
(paren
id|w
op_increment
)paren
)paren
comma
id|dev
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* 2ms per action */
)brace
r_if
c_cond
(paren
id|lp-&gt;chipset
op_ne
id|DC21140
)paren
(brace
id|outl
c_func
(paren
id|lp-&gt;cache.csr14
comma
id|DE4X5_STRR
)paren
suffix:semicolon
id|outl
c_func
(paren
id|lp-&gt;cache.csr13
comma
id|DE4X5_SICR
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** Basically this function is a NOP since it will never be called,&n;** unless I implement the DC21041 SROM functions. There&squot;s no need&n;** since the existing code will be satisfactory for all boards.&n;*/
r_static
r_int
DECL|function|dc21041_infoleaf
id|dc21041_infoleaf
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_return
id|DE4X5_AUTOSENSE_MS
suffix:semicolon
)brace
r_static
r_int
DECL|function|dc21140_infoleaf
id|dc21140_infoleaf
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_char
id|count
op_assign
l_int|0
suffix:semicolon
id|u_char
op_star
id|p
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|lp-&gt;srom
op_plus
id|lp-&gt;infoleaf_offset
suffix:semicolon
r_int
id|next_tick
op_assign
id|DE4X5_AUTOSENSE_MS
suffix:semicolon
multiline_comment|/* Read the connection type */
id|p
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* GEP control */
id|lp-&gt;cache.gepc
op_assign
(paren
op_star
id|p
op_increment
op_or
id|GEP_CTRL
)paren
suffix:semicolon
multiline_comment|/* Block count */
id|count
op_assign
op_star
id|p
op_increment
suffix:semicolon
multiline_comment|/* Recursively figure out the info blocks */
r_if
c_cond
(paren
op_star
id|p
OL
l_int|128
)paren
(brace
id|next_tick
op_assign
id|dc_infoblock
(braket
id|COMPACT
)braket
(paren
id|dev
comma
id|count
comma
id|p
)paren
suffix:semicolon
)brace
r_else
(brace
id|next_tick
op_assign
id|dc_infoblock
(braket
op_star
(paren
id|p
op_plus
l_int|1
)paren
)braket
(paren
id|dev
comma
id|count
comma
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;tcount
op_eq
id|count
)paren
(brace
id|lp-&gt;media
op_assign
id|NC
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;media
op_ne
id|lp-&gt;c_media
)paren
(brace
id|de4x5_dbg_media
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;c_media
op_assign
id|lp-&gt;media
suffix:semicolon
)brace
id|lp-&gt;media
op_assign
id|INIT
suffix:semicolon
id|lp-&gt;tcount
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tx_enable
op_assign
id|FALSE
suffix:semicolon
)brace
r_return
id|next_tick
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_static
r_int
DECL|function|dc21142_infoleaf
id|dc21142_infoleaf
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_char
id|count
op_assign
l_int|0
suffix:semicolon
id|u_char
op_star
id|p
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|lp-&gt;srom
op_plus
id|lp-&gt;infoleaf_offset
suffix:semicolon
r_int
id|next_tick
op_assign
id|DE4X5_AUTOSENSE_MS
suffix:semicolon
multiline_comment|/* Read the connection type */
id|p
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* Block count */
id|count
op_assign
op_star
id|p
op_increment
suffix:semicolon
multiline_comment|/* Recursively figure out the info blocks */
r_if
c_cond
(paren
op_star
id|p
OL
l_int|128
)paren
(brace
id|next_tick
op_assign
id|dc_infoblock
(braket
id|COMPACT
)braket
(paren
id|dev
comma
id|count
comma
id|p
)paren
suffix:semicolon
)brace
r_else
(brace
id|next_tick
op_assign
id|dc_infoblock
(braket
op_star
(paren
id|p
op_plus
l_int|1
)paren
)braket
(paren
id|dev
comma
id|count
comma
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;tcount
op_eq
id|count
)paren
(brace
id|lp-&gt;media
op_assign
id|NC
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;media
op_ne
id|lp-&gt;c_media
)paren
(brace
id|de4x5_dbg_media
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;c_media
op_assign
id|lp-&gt;media
suffix:semicolon
)brace
id|lp-&gt;media
op_assign
id|INIT
suffix:semicolon
id|lp-&gt;tcount
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tx_enable
op_assign
id|FALSE
suffix:semicolon
)brace
r_return
id|next_tick
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
)brace
r_static
r_int
DECL|function|dc21143_infoleaf
id|dc21143_infoleaf
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_char
id|count
op_assign
l_int|0
suffix:semicolon
id|u_char
op_star
id|p
op_assign
(paren
id|u_char
op_star
)paren
op_amp
id|lp-&gt;srom
op_plus
id|lp-&gt;infoleaf_offset
suffix:semicolon
r_int
id|next_tick
op_assign
id|DE4X5_AUTOSENSE_MS
suffix:semicolon
multiline_comment|/* Read the connection type */
id|p
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* Block count */
id|count
op_assign
op_star
id|p
op_increment
suffix:semicolon
multiline_comment|/* Recursively figure out the info blocks */
r_if
c_cond
(paren
op_star
id|p
OL
l_int|128
)paren
(brace
id|next_tick
op_assign
id|dc_infoblock
(braket
id|COMPACT
)braket
(paren
id|dev
comma
id|count
comma
id|p
)paren
suffix:semicolon
)brace
r_else
(brace
id|next_tick
op_assign
id|dc_infoblock
(braket
op_star
(paren
id|p
op_plus
l_int|1
)paren
)braket
(paren
id|dev
comma
id|count
comma
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;tcount
op_eq
id|count
)paren
(brace
id|lp-&gt;media
op_assign
id|NC
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;media
op_ne
id|lp-&gt;c_media
)paren
(brace
id|de4x5_dbg_media
c_func
(paren
id|dev
)paren
suffix:semicolon
id|lp-&gt;c_media
op_assign
id|lp-&gt;media
suffix:semicolon
)brace
id|lp-&gt;media
op_assign
id|INIT
suffix:semicolon
id|lp-&gt;tcount
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;tx_enable
op_assign
id|FALSE
suffix:semicolon
)brace
r_return
id|next_tick
op_amp
op_complement
id|TIMER_CB
suffix:semicolon
)brace
multiline_comment|/*&n;** The compact infoblock is only designed for DC21140[A] chips, so&n;** we&squot;ll reuse the dc21140m_autoconf function. Non MII media only.&n;*/
r_static
r_int
DECL|function|compact_infoblock
id|compact_infoblock
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
id|count
comma
id|u_char
op_star
id|p
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_char
id|flags
comma
id|csr6
suffix:semicolon
multiline_comment|/* Recursively figure out the info blocks */
r_if
c_cond
(paren
op_decrement
id|count
OG
id|lp-&gt;tcount
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
id|p
op_plus
id|COMPACT_LEN
)paren
OL
l_int|128
)paren
(brace
r_return
id|dc_infoblock
(braket
id|COMPACT
)braket
(paren
id|dev
comma
id|count
comma
id|p
op_plus
id|COMPACT_LEN
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|dc_infoblock
(braket
op_star
(paren
id|p
op_plus
id|COMPACT_LEN
op_plus
l_int|1
)paren
)braket
(paren
id|dev
comma
id|count
comma
id|p
op_plus
id|COMPACT_LEN
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|lp-&gt;media
op_eq
id|INIT
)paren
op_logical_and
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
)paren
(brace
id|lp-&gt;ibn
op_assign
id|COMPACT
suffix:semicolon
id|lp-&gt;active
op_assign
l_int|0
suffix:semicolon
id|gep_wr
c_func
(paren
id|lp-&gt;cache.gepc
comma
id|dev
)paren
suffix:semicolon
id|lp-&gt;infoblock_media
op_assign
(paren
op_star
id|p
op_increment
)paren
op_amp
id|COMPACT_MC
suffix:semicolon
id|lp-&gt;cache.gep
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|csr6
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|flags
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|lp-&gt;asBitValid
op_assign
(paren
id|flags
op_amp
l_int|0x80
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
suffix:semicolon
id|lp-&gt;defMedium
op_assign
(paren
id|flags
op_amp
l_int|0x40
)paren
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|lp-&gt;asBit
op_assign
l_int|1
op_lshift
(paren
(paren
id|csr6
op_rshift
l_int|1
)paren
op_amp
l_int|0x07
)paren
suffix:semicolon
id|lp-&gt;asPolarity
op_assign
(paren
(paren
id|csr6
op_amp
l_int|0x80
)paren
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|0
)paren
op_amp
id|lp-&gt;asBit
suffix:semicolon
id|lp-&gt;infoblock_csr6
op_assign
id|OMR_DEF
op_or
(paren
(paren
id|csr6
op_amp
l_int|0x71
)paren
op_lshift
l_int|18
)paren
suffix:semicolon
id|lp-&gt;useMII
op_assign
id|FALSE
suffix:semicolon
id|de4x5_switch_mac_port
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
id|dc21140m_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** This block describes non MII media for the DC21140[A] only.&n;*/
r_static
r_int
DECL|function|type0_infoblock
id|type0_infoblock
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
id|count
comma
id|u_char
op_star
id|p
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_char
id|flags
comma
id|csr6
comma
id|len
op_assign
(paren
op_star
id|p
op_amp
id|BLOCK_LEN
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Recursively figure out the info blocks */
r_if
c_cond
(paren
op_decrement
id|count
OG
id|lp-&gt;tcount
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
id|p
op_plus
id|len
)paren
OL
l_int|128
)paren
(brace
r_return
id|dc_infoblock
(braket
id|COMPACT
)braket
(paren
id|dev
comma
id|count
comma
id|p
op_plus
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|dc_infoblock
(braket
op_star
(paren
id|p
op_plus
id|len
op_plus
l_int|1
)paren
)braket
(paren
id|dev
comma
id|count
comma
id|p
op_plus
id|len
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|lp-&gt;media
op_eq
id|INIT
)paren
op_logical_and
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
)paren
(brace
id|lp-&gt;ibn
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;active
op_assign
l_int|0
suffix:semicolon
id|gep_wr
c_func
(paren
id|lp-&gt;cache.gepc
comma
id|dev
)paren
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|lp-&gt;infoblock_media
op_assign
(paren
op_star
id|p
op_increment
)paren
op_amp
id|BLOCK0_MC
suffix:semicolon
id|lp-&gt;cache.gep
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|csr6
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|flags
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|lp-&gt;asBitValid
op_assign
(paren
id|flags
op_amp
l_int|0x80
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
suffix:semicolon
id|lp-&gt;defMedium
op_assign
(paren
id|flags
op_amp
l_int|0x40
)paren
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|lp-&gt;asBit
op_assign
l_int|1
op_lshift
(paren
(paren
id|csr6
op_rshift
l_int|1
)paren
op_amp
l_int|0x07
)paren
suffix:semicolon
id|lp-&gt;asPolarity
op_assign
(paren
(paren
id|csr6
op_amp
l_int|0x80
)paren
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|0
)paren
op_amp
id|lp-&gt;asBit
suffix:semicolon
id|lp-&gt;infoblock_csr6
op_assign
id|OMR_DEF
op_or
(paren
(paren
id|csr6
op_amp
l_int|0x71
)paren
op_lshift
l_int|18
)paren
suffix:semicolon
id|lp-&gt;useMII
op_assign
id|FALSE
suffix:semicolon
id|de4x5_switch_mac_port
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
id|dc21140m_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* These functions are under construction! */
r_static
r_int
DECL|function|type1_infoblock
id|type1_infoblock
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
id|count
comma
id|u_char
op_star
id|p
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_char
id|len
op_assign
(paren
op_star
id|p
op_amp
id|BLOCK_LEN
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Recursively figure out the info blocks */
r_if
c_cond
(paren
op_decrement
id|count
OG
id|lp-&gt;tcount
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
id|p
op_plus
id|len
)paren
OL
l_int|128
)paren
(brace
r_return
id|dc_infoblock
(braket
id|COMPACT
)braket
(paren
id|dev
comma
id|count
comma
id|p
op_plus
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|dc_infoblock
(braket
op_star
(paren
id|p
op_plus
id|len
op_plus
l_int|1
)paren
)braket
(paren
id|dev
comma
id|count
comma
id|p
op_plus
id|len
)paren
suffix:semicolon
)brace
)brace
id|p
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;state
op_eq
id|INITIALISED
)paren
(brace
id|lp-&gt;ibn
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;active
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|gep
op_assign
(paren
op_star
id|p
ques
c_cond
id|p
suffix:colon
l_int|0
)paren
suffix:semicolon
id|p
op_add_assign
(paren
op_star
id|p
op_plus
l_int|1
)paren
suffix:semicolon
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|rst
op_assign
(paren
op_star
id|p
ques
c_cond
id|p
suffix:colon
l_int|0
)paren
suffix:semicolon
id|p
op_add_assign
(paren
op_star
id|p
op_plus
l_int|1
)paren
suffix:semicolon
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|mc
op_assign
id|TWIDDLE
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|ana
op_assign
id|TWIDDLE
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|fdx
op_assign
id|TWIDDLE
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|ttm
op_assign
id|TWIDDLE
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|lp-&gt;media
op_eq
id|INIT
)paren
op_logical_and
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
)paren
(brace
id|lp-&gt;ibn
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;active
op_assign
op_star
id|p
suffix:semicolon
id|lp-&gt;infoblock_csr6
op_assign
id|OMR_MII_100
suffix:semicolon
id|lp-&gt;useMII
op_assign
id|TRUE
suffix:semicolon
id|lp-&gt;infoblock_media
op_assign
id|ANS
suffix:semicolon
id|de4x5_switch_mac_port
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
id|dc21140m_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|type2_infoblock
id|type2_infoblock
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
id|count
comma
id|u_char
op_star
id|p
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_char
id|len
op_assign
(paren
op_star
id|p
op_amp
id|BLOCK_LEN
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Recursively figure out the info blocks */
r_if
c_cond
(paren
op_decrement
id|count
OG
id|lp-&gt;tcount
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
id|p
op_plus
id|len
)paren
OL
l_int|128
)paren
(brace
r_return
id|dc_infoblock
(braket
id|COMPACT
)braket
(paren
id|dev
comma
id|count
comma
id|p
op_plus
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|dc_infoblock
(braket
op_star
(paren
id|p
op_plus
id|len
op_plus
l_int|1
)paren
)braket
(paren
id|dev
comma
id|count
comma
id|p
op_plus
id|len
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|lp-&gt;media
op_eq
id|INIT
)paren
op_logical_and
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
)paren
(brace
id|lp-&gt;ibn
op_assign
l_int|2
suffix:semicolon
id|lp-&gt;active
op_assign
l_int|0
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|lp-&gt;infoblock_media
op_assign
(paren
op_star
id|p
)paren
op_amp
id|MEDIA_CODE
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|p
op_increment
)paren
op_amp
id|EXT_FIELD
)paren
(brace
id|lp-&gt;cache.csr13
op_assign
id|TWIDDLE
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|lp-&gt;cache.csr14
op_assign
id|TWIDDLE
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|lp-&gt;cache.csr15
op_assign
id|TWIDDLE
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;cache.csr13
op_assign
id|CSR13
suffix:semicolon
id|lp-&gt;cache.csr14
op_assign
id|CSR14
suffix:semicolon
id|lp-&gt;cache.csr15
op_assign
id|CSR15
suffix:semicolon
)brace
id|lp-&gt;cache.gepc
op_assign
(paren
(paren
id|s32
)paren
(paren
id|TWIDDLE
c_func
(paren
id|p
)paren
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|lp-&gt;cache.gep
op_assign
(paren
(paren
id|s32
)paren
(paren
id|TWIDDLE
c_func
(paren
id|p
)paren
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|lp-&gt;infoblock_csr6
op_assign
id|OMR_SIA
suffix:semicolon
id|lp-&gt;useMII
op_assign
id|FALSE
suffix:semicolon
id|de4x5_switch_mac_port
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
id|dc2114x_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|type3_infoblock
id|type3_infoblock
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
id|count
comma
id|u_char
op_star
id|p
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_char
id|len
op_assign
(paren
op_star
id|p
op_amp
id|BLOCK_LEN
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Recursively figure out the info blocks */
r_if
c_cond
(paren
op_decrement
id|count
OG
id|lp-&gt;tcount
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
id|p
op_plus
id|len
)paren
OL
l_int|128
)paren
(brace
r_return
id|dc_infoblock
(braket
id|COMPACT
)braket
(paren
id|dev
comma
id|count
comma
id|p
op_plus
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|dc_infoblock
(braket
op_star
(paren
id|p
op_plus
id|len
op_plus
l_int|1
)paren
)braket
(paren
id|dev
comma
id|count
comma
id|p
op_plus
id|len
)paren
suffix:semicolon
)brace
)brace
id|p
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;state
op_eq
id|INITIALISED
)paren
(brace
id|lp-&gt;ibn
op_assign
l_int|3
suffix:semicolon
id|lp-&gt;active
op_assign
op_star
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|MOTO_SROM_BUG
)paren
id|lp-&gt;active
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|gep
op_assign
(paren
op_star
id|p
ques
c_cond
id|p
suffix:colon
l_int|0
)paren
suffix:semicolon
id|p
op_add_assign
(paren
l_int|2
op_star
(paren
op_star
id|p
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|rst
op_assign
(paren
op_star
id|p
ques
c_cond
id|p
suffix:colon
l_int|0
)paren
suffix:semicolon
id|p
op_add_assign
(paren
l_int|2
op_star
(paren
op_star
id|p
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|mc
op_assign
id|TWIDDLE
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|ana
op_assign
id|TWIDDLE
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|fdx
op_assign
id|TWIDDLE
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|ttm
op_assign
id|TWIDDLE
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|mci
op_assign
op_star
id|p
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|lp-&gt;media
op_eq
id|INIT
)paren
op_logical_and
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
)paren
(brace
id|lp-&gt;ibn
op_assign
l_int|3
suffix:semicolon
id|lp-&gt;active
op_assign
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|MOTO_SROM_BUG
)paren
id|lp-&gt;active
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;infoblock_csr6
op_assign
id|OMR_MII_100
suffix:semicolon
id|lp-&gt;useMII
op_assign
id|TRUE
suffix:semicolon
id|lp-&gt;infoblock_media
op_assign
id|ANS
suffix:semicolon
id|de4x5_switch_mac_port
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
id|dc2114x_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|type4_infoblock
id|type4_infoblock
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
id|count
comma
id|u_char
op_star
id|p
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_char
id|flags
comma
id|csr6
comma
id|len
op_assign
(paren
op_star
id|p
op_amp
id|BLOCK_LEN
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Recursively figure out the info blocks */
r_if
c_cond
(paren
op_decrement
id|count
OG
id|lp-&gt;tcount
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
id|p
op_plus
id|len
)paren
OL
l_int|128
)paren
(brace
r_return
id|dc_infoblock
(braket
id|COMPACT
)braket
(paren
id|dev
comma
id|count
comma
id|p
op_plus
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|dc_infoblock
(braket
op_star
(paren
id|p
op_plus
id|len
op_plus
l_int|1
)paren
)braket
(paren
id|dev
comma
id|count
comma
id|p
op_plus
id|len
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|lp-&gt;media
op_eq
id|INIT
)paren
op_logical_and
(paren
id|lp-&gt;timeout
OL
l_int|0
)paren
)paren
(brace
id|lp-&gt;ibn
op_assign
l_int|4
suffix:semicolon
id|lp-&gt;active
op_assign
l_int|0
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|lp-&gt;infoblock_media
op_assign
(paren
op_star
id|p
op_increment
)paren
op_amp
id|MEDIA_CODE
suffix:semicolon
id|lp-&gt;cache.csr13
op_assign
id|CSR13
suffix:semicolon
multiline_comment|/* Hard coded defaults */
id|lp-&gt;cache.csr14
op_assign
id|CSR14
suffix:semicolon
id|lp-&gt;cache.csr15
op_assign
id|CSR15
suffix:semicolon
id|lp-&gt;cache.gepc
op_assign
(paren
(paren
id|s32
)paren
(paren
id|TWIDDLE
c_func
(paren
id|p
)paren
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|lp-&gt;cache.gep
op_assign
(paren
(paren
id|s32
)paren
(paren
id|TWIDDLE
c_func
(paren
id|p
)paren
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|p
op_add_assign
l_int|2
suffix:semicolon
id|csr6
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|flags
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|lp-&gt;asBitValid
op_assign
(paren
id|flags
op_amp
l_int|0x80
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
suffix:semicolon
id|lp-&gt;defMedium
op_assign
(paren
id|flags
op_amp
l_int|0x40
)paren
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|lp-&gt;asBit
op_assign
l_int|1
op_lshift
(paren
(paren
id|csr6
op_rshift
l_int|1
)paren
op_amp
l_int|0x07
)paren
suffix:semicolon
id|lp-&gt;asPolarity
op_assign
(paren
(paren
id|csr6
op_amp
l_int|0x80
)paren
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|0
)paren
op_amp
id|lp-&gt;asBit
suffix:semicolon
id|lp-&gt;infoblock_csr6
op_assign
id|OMR_DEF
op_or
(paren
(paren
id|csr6
op_amp
l_int|0x71
)paren
op_lshift
l_int|18
)paren
suffix:semicolon
id|lp-&gt;useMII
op_assign
id|FALSE
suffix:semicolon
id|de4x5_switch_mac_port
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
id|dc2114x_autoconf
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** This block type provides information for resetting external devices&n;** (chips) through the General Purpose Register.&n;*/
r_static
r_int
DECL|function|type5_infoblock
id|type5_infoblock
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
id|count
comma
id|u_char
op_star
id|p
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_char
id|len
op_assign
(paren
op_star
id|p
op_amp
id|BLOCK_LEN
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Recursively figure out the info blocks */
r_if
c_cond
(paren
op_decrement
id|count
OG
id|lp-&gt;tcount
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
id|p
op_plus
id|len
)paren
OL
l_int|128
)paren
(brace
r_return
id|dc_infoblock
(braket
id|COMPACT
)braket
(paren
id|dev
comma
id|count
comma
id|p
op_plus
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|dc_infoblock
(braket
op_star
(paren
id|p
op_plus
id|len
op_plus
l_int|1
)paren
)braket
(paren
id|dev
comma
id|count
comma
id|p
op_plus
id|len
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Must be initializing to run this code */
r_if
c_cond
(paren
(paren
id|lp-&gt;state
op_eq
id|INITIALISED
)paren
op_logical_or
(paren
id|lp-&gt;media
op_eq
id|INIT
)paren
)paren
(brace
id|p
op_add_assign
l_int|2
suffix:semicolon
id|lp-&gt;rst
op_assign
id|p
suffix:semicolon
id|srom_exec
c_func
(paren
id|dev
comma
id|lp-&gt;rst
)paren
suffix:semicolon
)brace
r_return
id|DE4X5_AUTOSENSE_MS
suffix:semicolon
)brace
multiline_comment|/*&n;** MII Read/Write&n;*/
r_static
r_int
DECL|function|mii_rd
id|mii_rd
c_func
(paren
id|u_char
id|phyreg
comma
id|u_char
id|phyaddr
comma
id|u_long
id|ioaddr
)paren
(brace
id|mii_wdata
c_func
(paren
id|MII_PREAMBLE
comma
l_int|2
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Start of 34 bit preamble...    */
id|mii_wdata
c_func
(paren
id|MII_PREAMBLE
comma
l_int|32
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* ...continued                   */
id|mii_wdata
c_func
(paren
id|MII_STRD
comma
l_int|4
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* SFD and Read operation         */
id|mii_address
c_func
(paren
id|phyaddr
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* PHY address to be accessed     */
id|mii_address
c_func
(paren
id|phyreg
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* PHY Register to read           */
id|mii_ta
c_func
(paren
id|MII_STRD
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Turn around time - 2 MDC       */
r_return
id|mii_rdata
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Read data                      */
)brace
r_static
r_void
DECL|function|mii_wr
id|mii_wr
c_func
(paren
r_int
id|data
comma
id|u_char
id|phyreg
comma
id|u_char
id|phyaddr
comma
id|u_long
id|ioaddr
)paren
(brace
id|mii_wdata
c_func
(paren
id|MII_PREAMBLE
comma
l_int|2
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Start of 34 bit preamble...    */
id|mii_wdata
c_func
(paren
id|MII_PREAMBLE
comma
l_int|32
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* ...continued                   */
id|mii_wdata
c_func
(paren
id|MII_STWR
comma
l_int|4
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* SFD and Write operation        */
id|mii_address
c_func
(paren
id|phyaddr
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* PHY address to be accessed     */
id|mii_address
c_func
(paren
id|phyreg
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* PHY Register to write          */
id|mii_ta
c_func
(paren
id|MII_STWR
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Turn around time - 2 MDC       */
id|data
op_assign
id|mii_swap
c_func
(paren
id|data
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Swap data bit ordering         */
id|mii_wdata
c_func
(paren
id|data
comma
l_int|16
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Write data                     */
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|mii_rdata
id|mii_rdata
c_func
(paren
id|u_long
id|ioaddr
)paren
(brace
r_int
id|i
suffix:semicolon
id|s32
id|tmp
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_lshift_assign
l_int|1
suffix:semicolon
id|tmp
op_or_assign
id|getfrom_mii
c_func
(paren
id|MII_MRD
op_or
id|MII_RD
comma
id|ioaddr
)paren
suffix:semicolon
)brace
r_return
id|tmp
suffix:semicolon
)brace
r_static
r_void
DECL|function|mii_wdata
id|mii_wdata
c_func
(paren
r_int
id|data
comma
r_int
id|len
comma
id|u_long
id|ioaddr
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sendto_mii
c_func
(paren
id|MII_MWR
op_or
id|MII_WR
comma
id|data
comma
id|ioaddr
)paren
suffix:semicolon
id|data
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|mii_address
id|mii_address
c_func
(paren
id|u_char
id|addr
comma
id|u_long
id|ioaddr
)paren
(brace
r_int
id|i
suffix:semicolon
id|addr
op_assign
id|mii_swap
c_func
(paren
id|addr
comma
l_int|5
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sendto_mii
c_func
(paren
id|MII_MWR
op_or
id|MII_WR
comma
id|addr
comma
id|ioaddr
)paren
suffix:semicolon
id|addr
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|mii_ta
id|mii_ta
c_func
(paren
id|u_long
id|rw
comma
id|u_long
id|ioaddr
)paren
(brace
r_if
c_cond
(paren
id|rw
op_eq
id|MII_STWR
)paren
(brace
id|sendto_mii
c_func
(paren
id|MII_MWR
op_or
id|MII_WR
comma
l_int|1
comma
id|ioaddr
)paren
suffix:semicolon
id|sendto_mii
c_func
(paren
id|MII_MWR
op_or
id|MII_WR
comma
l_int|0
comma
id|ioaddr
)paren
suffix:semicolon
)brace
r_else
(brace
id|getfrom_mii
c_func
(paren
id|MII_MRD
op_or
id|MII_RD
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* Tri-state MDIO */
)brace
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|mii_swap
id|mii_swap
c_func
(paren
r_int
id|data
comma
r_int
id|len
)paren
(brace
r_int
id|i
comma
id|tmp
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_lshift_assign
l_int|1
suffix:semicolon
id|tmp
op_or_assign
(paren
id|data
op_amp
l_int|1
)paren
suffix:semicolon
id|data
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_return
id|tmp
suffix:semicolon
)brace
r_static
r_void
DECL|function|sendto_mii
id|sendto_mii
c_func
(paren
id|u32
id|command
comma
r_int
id|data
comma
id|u_long
id|ioaddr
)paren
(brace
id|u32
id|j
suffix:semicolon
id|j
op_assign
(paren
id|data
op_amp
l_int|1
)paren
op_lshift
l_int|17
suffix:semicolon
id|outl
c_func
(paren
id|command
op_or
id|j
comma
id|ioaddr
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|outl
c_func
(paren
id|command
op_or
id|MII_MDC
op_or
id|j
comma
id|ioaddr
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|getfrom_mii
id|getfrom_mii
c_func
(paren
id|u32
id|command
comma
id|u_long
id|ioaddr
)paren
(brace
id|outl
c_func
(paren
id|command
comma
id|ioaddr
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|outl
c_func
(paren
id|command
op_or
id|MII_MDC
comma
id|ioaddr
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
(paren
(paren
id|inl
c_func
(paren
id|ioaddr
)paren
op_rshift
l_int|19
)paren
op_amp
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** Here&squot;s 3 ways to calculate the OUI from the ID registers.&n;*/
r_static
r_int
DECL|function|mii_get_oui
id|mii_get_oui
c_func
(paren
id|u_char
id|phyaddr
comma
id|u_long
id|ioaddr
)paren
(brace
multiline_comment|/*&n;    union {&n;&t;u_short reg;&n;&t;u_char breg[2];&n;    } a;&n;    int i, r2, r3, ret=0;*/
r_int
id|r2
comma
id|r3
suffix:semicolon
multiline_comment|/* Read r2 and r3 */
id|r2
op_assign
id|mii_rd
c_func
(paren
id|MII_ID0
comma
id|phyaddr
comma
id|ioaddr
)paren
suffix:semicolon
id|r3
op_assign
id|mii_rd
c_func
(paren
id|MII_ID1
comma
id|phyaddr
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* SEEQ and Cypress way * /&n;    / * Shuffle r2 and r3 * /&n;    a.reg=0;&n;    r3 = ((r3&gt;&gt;10)|(r2&lt;&lt;6))&amp;0x0ff;&n;    r2 = ((r2&gt;&gt;2)&amp;0x3fff);&n;&n;    / * Bit reverse r3 * /&n;    for (i=0;i&lt;8;i++) {&n;&t;ret&lt;&lt;=1;&n;&t;ret |= (r3&amp;1);&n;&t;r3&gt;&gt;=1;&n;    }&n;&n;    / * Bit reverse r2 * /&n;    for (i=0;i&lt;16;i++) {&n;&t;a.reg&lt;&lt;=1;&n;&t;a.reg |= (r2&amp;1);&n;&t;r2&gt;&gt;=1;&n;    }&n;&n;    / * Swap r2 bytes * /&n;    i=a.breg[0];&n;    a.breg[0]=a.breg[1];&n;    a.breg[1]=i;&n;&n;    return ((a.reg&lt;&lt;8)|ret); */
multiline_comment|/* SEEQ and Cypress way */
multiline_comment|/*    return ((r2&lt;&lt;6)|(u_int)(r3&gt;&gt;10)); */
multiline_comment|/* NATIONAL and BROADCOM way */
r_return
id|r2
suffix:semicolon
multiline_comment|/* (I did it) My way */
)brace
multiline_comment|/*&n;** The SROM spec forces us to search addresses [1-31 0]. Bummer.&n;*/
r_static
r_int
DECL|function|mii_get_phy
id|mii_get_phy
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|k
comma
id|n
comma
id|limit
op_assign
r_sizeof
(paren
id|phy_info
)paren
op_div
r_sizeof
(paren
r_struct
id|phy_table
)paren
suffix:semicolon
r_int
id|id
suffix:semicolon
id|lp-&gt;active
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;useMII
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Search the MII address space for possible PHY devices */
r_for
c_loop
(paren
id|n
op_assign
l_int|0
comma
id|lp-&gt;mii_cnt
op_assign
l_int|0
comma
id|i
op_assign
l_int|1
suffix:semicolon
op_logical_neg
(paren
(paren
id|i
op_eq
l_int|1
)paren
op_logical_and
(paren
id|n
op_eq
l_int|1
)paren
)paren
suffix:semicolon
id|i
op_assign
(paren
op_increment
id|i
)paren
op_mod
id|DE4X5_MAX_MII
)paren
(brace
id|lp-&gt;phy
(braket
id|lp-&gt;active
)braket
dot
id|addr
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
id|n
op_increment
suffix:semicolon
multiline_comment|/* Count cycles */
r_while
c_loop
(paren
id|de4x5_reset_phy
c_func
(paren
id|dev
)paren
OL
l_int|0
)paren
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Wait for reset */
id|id
op_assign
id|mii_get_oui
c_func
(paren
id|i
comma
id|DE4X5_MII
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id
op_eq
l_int|0
)paren
op_logical_or
(paren
id|id
op_eq
l_int|65535
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Valid ID? */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|limit
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/* Search PHY table */
r_if
c_cond
(paren
id|id
op_ne
id|phy_info
(braket
id|j
)braket
dot
id|id
)paren
r_continue
suffix:semicolon
multiline_comment|/* ID match? */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|id
op_logical_and
(paren
id|k
OL
id|DE4X5_MAX_PHY
)paren
suffix:semicolon
id|k
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
OL
id|DE4X5_MAX_PHY
)paren
(brace
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|lp-&gt;phy
(braket
id|k
)braket
comma
(paren
r_char
op_star
)paren
op_amp
id|phy_info
(braket
id|j
)braket
comma
r_sizeof
(paren
r_struct
id|phy_table
)paren
)paren
suffix:semicolon
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|addr
op_assign
id|i
suffix:semicolon
id|lp-&gt;mii_cnt
op_increment
suffix:semicolon
id|lp-&gt;active
op_increment
suffix:semicolon
)brace
r_else
(brace
r_goto
id|purgatory
suffix:semicolon
multiline_comment|/* Stop the search */
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|j
op_eq
id|limit
)paren
op_logical_and
(paren
id|i
OL
id|DE4X5_MAX_MII
)paren
)paren
(brace
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|id
op_logical_and
(paren
id|k
OL
id|DE4X5_MAX_PHY
)paren
suffix:semicolon
id|k
op_increment
)paren
suffix:semicolon
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|addr
op_assign
id|i
suffix:semicolon
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|id
op_assign
id|id
suffix:semicolon
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|spd.reg
op_assign
id|GENERIC_REG
suffix:semicolon
multiline_comment|/* ANLPA register         */
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|spd.mask
op_assign
id|GENERIC_MASK
suffix:semicolon
multiline_comment|/* 100Mb/s technologies   */
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|spd.value
op_assign
id|GENERIC_VALUE
suffix:semicolon
multiline_comment|/* TX &amp; T4, H/F Duplex    */
id|lp-&gt;mii_cnt
op_increment
suffix:semicolon
id|lp-&gt;active
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Using generic MII device control. If the board doesn&squot;t operate, &bslash;nplease mail the following dump to the author:&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|j
op_assign
id|de4x5_debug
suffix:semicolon
id|de4x5_debug
op_or_assign
id|DEBUG_MII
suffix:semicolon
id|de4x5_dbg_mii
c_func
(paren
id|dev
comma
id|k
)paren
suffix:semicolon
id|de4x5_debug
op_assign
id|j
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|purgatory
suffix:colon
id|lp-&gt;active
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;phy
(braket
l_int|0
)braket
dot
id|id
)paren
(brace
multiline_comment|/* Reset the PHY devices */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|id
op_logical_and
(paren
id|k
OL
id|DE4X5_MAX_PHY
)paren
suffix:semicolon
id|k
op_increment
)paren
(brace
multiline_comment|/*For each PHY*/
id|mii_wr
c_func
(paren
id|MII_CR_RST
comma
id|MII_CR
comma
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
suffix:semicolon
r_while
c_loop
(paren
id|mii_rd
c_func
(paren
id|MII_CR
comma
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
op_amp
id|MII_CR_RST
)paren
suffix:semicolon
id|de4x5_dbg_mii
c_func
(paren
id|dev
comma
id|k
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;mii_cnt
)paren
id|lp-&gt;useMII
op_assign
id|FALSE
suffix:semicolon
r_return
id|lp-&gt;mii_cnt
suffix:semicolon
)brace
r_static
r_char
op_star
DECL|function|build_setup_frame
id|build_setup_frame
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|mode
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
op_star
id|pa
op_assign
id|lp-&gt;setup_frame
suffix:semicolon
multiline_comment|/* Initialise the setup frame */
r_if
c_cond
(paren
id|mode
op_eq
id|ALL
)paren
(brace
id|memset
c_func
(paren
id|lp-&gt;setup_frame
comma
l_int|0
comma
id|SETUP_FRAME_LEN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;setup_f
op_eq
id|HASH_PERF
)paren
(brace
r_for
c_loop
(paren
id|pa
op_assign
id|lp-&gt;setup_frame
op_plus
id|IMPERF_PA_OFFSET
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
(paren
id|pa
op_plus
id|i
)paren
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Host address */
r_if
c_cond
(paren
id|i
op_amp
l_int|0x01
)paren
id|pa
op_add_assign
l_int|2
suffix:semicolon
)brace
op_star
(paren
id|lp-&gt;setup_frame
op_plus
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
op_minus
l_int|3
)paren
op_assign
l_int|0x80
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Host address */
op_star
(paren
id|pa
op_plus
(paren
id|i
op_amp
l_int|1
)paren
)paren
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
l_int|0x01
)paren
id|pa
op_add_assign
l_int|4
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Broadcast address */
op_star
(paren
id|pa
op_plus
(paren
id|i
op_amp
l_int|1
)paren
)paren
op_assign
(paren
r_char
)paren
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
l_int|0x01
)paren
id|pa
op_add_assign
l_int|4
suffix:semicolon
)brace
)brace
r_return
id|pa
suffix:semicolon
multiline_comment|/* Points to the next entry */
)brace
r_static
r_void
DECL|function|enable_ast
id|enable_ast
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u32
id|time_out
)paren
(brace
id|timeout
c_func
(paren
id|dev
comma
(paren
r_void
op_star
)paren
op_amp
id|de4x5_ast
comma
(paren
id|u_long
)paren
id|dev
comma
id|time_out
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|disable_ast
id|disable_ast
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|lp-&gt;timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|de4x5_switch_mac_port
id|de4x5_switch_mac_port
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|s32
id|omr
suffix:semicolon
id|STOP_DE4X5
suffix:semicolon
multiline_comment|/* Assert the OMR_PS bit in CSR6 */
id|omr
op_assign
(paren
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
op_amp
op_complement
(paren
id|OMR_PS
op_or
id|OMR_HBD
op_or
id|OMR_TTM
op_or
id|OMR_PCS
op_or
id|OMR_SCR
op_or
id|OMR_FDX
)paren
)paren
suffix:semicolon
id|omr
op_or_assign
id|lp-&gt;infoblock_csr6
suffix:semicolon
r_if
c_cond
(paren
id|omr
op_amp
id|OMR_PS
)paren
id|omr
op_or_assign
id|OMR_HBD
suffix:semicolon
id|outl
c_func
(paren
id|omr
comma
id|DE4X5_OMR
)paren
suffix:semicolon
multiline_comment|/* Soft Reset */
id|RESET_DE4X5
suffix:semicolon
multiline_comment|/* Restore the GEP - especially for COMPACT and Type 0 Infoblocks */
r_if
c_cond
(paren
id|lp-&gt;chipset
op_eq
id|DC21140
)paren
(brace
id|gep_wr
c_func
(paren
id|lp-&gt;cache.gepc
comma
id|dev
)paren
suffix:semicolon
id|gep_wr
c_func
(paren
id|lp-&gt;cache.gep
comma
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|lp-&gt;chipset
op_amp
op_complement
l_int|0x0ff
)paren
op_eq
id|DC2114x
)paren
(brace
id|reset_init_sia
c_func
(paren
id|dev
comma
id|lp-&gt;cache.csr13
comma
id|lp-&gt;cache.csr14
comma
id|lp-&gt;cache.csr15
)paren
suffix:semicolon
)brace
multiline_comment|/* Restore CSR6 */
id|outl
c_func
(paren
id|omr
comma
id|DE4X5_OMR
)paren
suffix:semicolon
multiline_comment|/* Reset CSR8 */
id|inl
c_func
(paren
id|DE4X5_MFC
)paren
suffix:semicolon
r_return
id|omr
suffix:semicolon
)brace
r_static
r_void
DECL|function|gep_wr
id|gep_wr
c_func
(paren
id|s32
id|data
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;chipset
op_eq
id|DC21140
)paren
(brace
id|outl
c_func
(paren
id|data
comma
id|DE4X5_GEP
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|lp-&gt;chipset
op_amp
op_complement
l_int|0x00ff
)paren
op_eq
id|DC2114x
)paren
(brace
id|outl
c_func
(paren
(paren
id|data
op_lshift
l_int|16
)paren
op_or
id|lp-&gt;cache.csr15
comma
id|DE4X5_SIGR
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|gep_rd
id|gep_rd
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;chipset
op_eq
id|DC21140
)paren
(brace
r_return
id|inl
c_func
(paren
id|DE4X5_GEP
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|lp-&gt;chipset
op_amp
op_complement
l_int|0x00ff
)paren
op_eq
id|DC2114x
)paren
(brace
r_return
(paren
id|inl
c_func
(paren
id|DE4X5_SIGR
)paren
op_amp
l_int|0x000fffff
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|timeout
id|timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
(paren
op_star
id|fn
)paren
(paren
id|u_long
id|data
)paren
comma
id|u_long
id|data
comma
id|u_long
id|msec
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|dt
suffix:semicolon
multiline_comment|/* First, cancel any pending timer events */
id|del_timer
c_func
(paren
op_amp
id|lp-&gt;timer
)paren
suffix:semicolon
multiline_comment|/* Convert msec to ticks */
id|dt
op_assign
(paren
id|msec
op_star
id|HZ
)paren
op_div
l_int|1000
suffix:semicolon
r_if
c_cond
(paren
id|dt
op_eq
l_int|0
)paren
id|dt
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Set up timer */
id|lp-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|dt
suffix:semicolon
id|lp-&gt;timer.function
op_assign
id|fn
suffix:semicolon
id|lp-&gt;timer.data
op_assign
id|data
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|lp-&gt;timer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|yawn
id|yawn
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|state
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lp-&gt;chipset
op_eq
id|DC21040
)paren
op_logical_or
(paren
id|lp-&gt;chipset
op_eq
id|DC21140
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;bus
op_eq
id|EISA
)paren
(brace
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|WAKEUP
suffix:colon
id|outb
c_func
(paren
id|WAKEUP
comma
id|PCI_CFPM
)paren
suffix:semicolon
id|de4x5_ms_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNOOZE
suffix:colon
id|outb
c_func
(paren
id|SNOOZE
comma
id|PCI_CFPM
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SLEEP
suffix:colon
id|outl
c_func
(paren
l_int|0
comma
id|DE4X5_SICR
)paren
suffix:semicolon
id|outb
c_func
(paren
id|SLEEP
comma
id|PCI_CFPM
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|WAKEUP
suffix:colon
id|pcibios_write_config_byte
c_func
(paren
id|lp-&gt;bus_num
comma
id|lp-&gt;device
op_lshift
l_int|3
comma
id|PCI_CFDA_PSM
comma
id|WAKEUP
)paren
suffix:semicolon
id|de4x5_ms_delay
c_func
(paren
l_int|10
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNOOZE
suffix:colon
id|pcibios_write_config_byte
c_func
(paren
id|lp-&gt;bus_num
comma
id|lp-&gt;device
op_lshift
l_int|3
comma
id|PCI_CFDA_PSM
comma
id|SNOOZE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SLEEP
suffix:colon
id|outl
c_func
(paren
l_int|0
comma
id|DE4X5_SICR
)paren
suffix:semicolon
id|pcibios_write_config_byte
c_func
(paren
id|lp-&gt;bus_num
comma
id|lp-&gt;device
op_lshift
l_int|3
comma
id|PCI_CFDA_PSM
comma
id|SLEEP
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|de4x5_parse_params
id|de4x5_parse_params
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_char
op_star
id|p
comma
op_star
id|q
comma
id|t
suffix:semicolon
id|lp-&gt;params.fdx
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;params.autosense
op_assign
id|AUTO
suffix:semicolon
r_if
c_cond
(paren
id|args
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p
op_assign
id|strstr
c_func
(paren
id|args
comma
id|dev-&gt;name
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|q
op_assign
id|strstr
c_func
(paren
id|p
op_plus
id|strlen
c_func
(paren
id|dev-&gt;name
)paren
comma
l_string|&quot;eth&quot;
)paren
)paren
)paren
id|q
op_assign
id|p
op_plus
id|strlen
c_func
(paren
id|p
)paren
suffix:semicolon
id|t
op_assign
op_star
id|q
suffix:semicolon
op_star
id|q
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
macro_line|#if !defined(__sparc_v9__) &amp;&amp; !defined(__powerpc__) &amp;&amp; !defined(__alpha__)
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|p
comma
l_string|&quot;force_eisa&quot;
)paren
op_logical_or
id|strstr
c_func
(paren
id|p
comma
l_string|&quot;FORCE_EISA&quot;
)paren
)paren
id|forceEISA
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|p
comma
l_string|&quot;fdx&quot;
)paren
op_logical_or
id|strstr
c_func
(paren
id|p
comma
l_string|&quot;FDX&quot;
)paren
)paren
id|lp-&gt;params.fdx
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|p
comma
l_string|&quot;autosense&quot;
)paren
op_logical_or
id|strstr
c_func
(paren
id|p
comma
l_string|&quot;AUTOSENSE&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|p
comma
l_string|&quot;TP&quot;
)paren
)paren
(brace
id|lp-&gt;params.autosense
op_assign
id|TP
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|p
comma
l_string|&quot;TP_NW&quot;
)paren
)paren
(brace
id|lp-&gt;params.autosense
op_assign
id|TP_NW
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|p
comma
l_string|&quot;BNC&quot;
)paren
)paren
(brace
id|lp-&gt;params.autosense
op_assign
id|BNC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|p
comma
l_string|&quot;AUI&quot;
)paren
)paren
(brace
id|lp-&gt;params.autosense
op_assign
id|AUI
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|p
comma
l_string|&quot;BNC_AUI&quot;
)paren
)paren
(brace
id|lp-&gt;params.autosense
op_assign
id|BNC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|p
comma
l_string|&quot;10Mb&quot;
)paren
)paren
(brace
id|lp-&gt;params.autosense
op_assign
id|_10Mb
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|p
comma
l_string|&quot;100Mb&quot;
)paren
)paren
(brace
id|lp-&gt;params.autosense
op_assign
id|_100Mb
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|p
comma
l_string|&quot;AUTO&quot;
)paren
)paren
(brace
id|lp-&gt;params.autosense
op_assign
id|AUTO
suffix:semicolon
)brace
)brace
op_star
id|q
op_assign
id|t
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|de4x5_dbg_open
id|de4x5_dbg_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|de4x5_debug
op_amp
id|DEBUG_OPEN
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: de4x5 opening with irq %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tphysical address: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
(paren
r_int
)paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Descriptor head addresses:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;t0x%8.8lx  0x%8.8lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
id|lp-&gt;rx_ring
comma
(paren
id|u_long
)paren
id|lp-&gt;tx_ring
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Descriptor addresses:&bslash;nRX: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;rxRingSize
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;0x%8.8lx  &quot;
comma
(paren
id|u_long
)paren
op_amp
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;...0x%8.8lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
op_amp
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|status
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TX: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;txRingSize
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;0x%8.8lx  &quot;
comma
(paren
id|u_long
)paren
op_amp
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|status
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;...0x%8.8lx&bslash;n&quot;
comma
(paren
id|u_long
)paren
op_amp
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|status
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Descriptor buffers:&bslash;nRX: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;rxRingSize
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;0x%8.8x  &quot;
comma
id|le32_to_cpu
c_func
(paren
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|buf
)paren
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;...0x%8.8x&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|lp-&gt;rx_ring
(braket
id|i
)braket
dot
id|buf
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TX: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lp-&gt;txRingSize
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;0x%8.8x  &quot;
comma
id|le32_to_cpu
c_func
(paren
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|buf
)paren
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;...0x%8.8x&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|lp-&gt;tx_ring
(braket
id|i
)braket
dot
id|buf
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Ring size: &bslash;nRX: %d&bslash;nTX: %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|lp-&gt;rxRingSize
comma
(paren
r_int
)paren
id|lp-&gt;txRingSize
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|de4x5_dbg_mii
id|de4x5_dbg_mii
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|k
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|de4x5_debug
op_amp
id|DEBUG_MII
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nMII device address: %d&bslash;n&quot;
comma
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|addr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MII CR:  %x&bslash;n&quot;
comma
id|mii_rd
c_func
(paren
id|MII_CR
comma
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MII SR:  %x&bslash;n&quot;
comma
id|mii_rd
c_func
(paren
id|MII_SR
comma
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MII ID0: %x&bslash;n&quot;
comma
id|mii_rd
c_func
(paren
id|MII_ID0
comma
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MII ID1: %x&bslash;n&quot;
comma
id|mii_rd
c_func
(paren
id|MII_ID1
comma
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|id
op_ne
id|BROADCOM_T4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;MII ANA: %x&bslash;n&quot;
comma
id|mii_rd
c_func
(paren
l_int|0x04
comma
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MII ANC: %x&bslash;n&quot;
comma
id|mii_rd
c_func
(paren
l_int|0x05
comma
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;MII 16:  %x&bslash;n&quot;
comma
id|mii_rd
c_func
(paren
l_int|0x10
comma
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|id
op_ne
id|BROADCOM_T4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;MII 17:  %x&bslash;n&quot;
comma
id|mii_rd
c_func
(paren
l_int|0x11
comma
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;MII 18:  %x&bslash;n&quot;
comma
id|mii_rd
c_func
(paren
l_int|0x12
comma
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;MII 20:  %x&bslash;n&quot;
comma
id|mii_rd
c_func
(paren
l_int|0x14
comma
id|lp-&gt;phy
(braket
id|k
)braket
dot
id|addr
comma
id|DE4X5_MII
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|de4x5_dbg_media
id|de4x5_dbg_media
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;media
op_ne
id|lp-&gt;c_media
)paren
(brace
r_if
c_cond
(paren
id|de4x5_debug
op_amp
id|DEBUG_MEDIA
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: media is %s%s&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|lp-&gt;media
op_eq
id|NC
ques
c_cond
l_string|&quot;unconnected, link down or incompatible connection&quot;
suffix:colon
(paren
id|lp-&gt;media
op_eq
id|TP
ques
c_cond
l_string|&quot;TP&quot;
suffix:colon
(paren
id|lp-&gt;media
op_eq
id|ANS
ques
c_cond
l_string|&quot;TP/Nway&quot;
suffix:colon
(paren
id|lp-&gt;media
op_eq
id|BNC
ques
c_cond
l_string|&quot;BNC&quot;
suffix:colon
(paren
id|lp-&gt;media
op_eq
id|AUI
ques
c_cond
l_string|&quot;AUI&quot;
suffix:colon
(paren
id|lp-&gt;media
op_eq
id|BNC_AUI
ques
c_cond
l_string|&quot;BNC/AUI&quot;
suffix:colon
(paren
id|lp-&gt;media
op_eq
id|EXT_SIA
ques
c_cond
l_string|&quot;EXT SIA&quot;
suffix:colon
(paren
id|lp-&gt;media
op_eq
id|_100Mb
ques
c_cond
l_string|&quot;100Mb/s&quot;
suffix:colon
(paren
id|lp-&gt;media
op_eq
id|_10Mb
ques
c_cond
l_string|&quot;10Mb/s&quot;
suffix:colon
l_string|&quot;???&quot;
)paren
)paren
)paren
)paren
)paren
)paren
)paren
)paren
)paren
comma
(paren
id|lp-&gt;fdx
ques
c_cond
l_string|&quot; full duplex.&quot;
suffix:colon
l_string|&quot;.&quot;
)paren
)paren
suffix:semicolon
)brace
id|lp-&gt;c_media
op_assign
id|lp-&gt;media
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|de4x5_dbg_srom
id|de4x5_dbg_srom
c_func
(paren
r_struct
id|de4x5_srom
op_star
id|p
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|de4x5_debug
op_amp
id|DEBUG_SROM
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sub-system Vendor ID: %04x&bslash;n&quot;
comma
op_star
(paren
(paren
id|u_short
op_star
)paren
id|p-&gt;sub_vendor_id
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Sub-system ID:        %04x&bslash;n&quot;
comma
op_star
(paren
(paren
id|u_short
op_star
)paren
id|p-&gt;sub_system_id
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ID Block CRC:         %02x&bslash;n&quot;
comma
(paren
id|u_char
)paren
(paren
id|p-&gt;id_block_crc
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SROM version:         %02x&bslash;n&quot;
comma
(paren
id|u_char
)paren
(paren
id|p-&gt;version
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;# controllers:         %02x&bslash;n&quot;
comma
(paren
id|u_char
)paren
(paren
id|p-&gt;num_controllers
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Hardware Address:     &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x:&quot;
comma
(paren
id|u_char
)paren
op_star
(paren
id|p-&gt;ieee_addr
op_plus
id|i
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%02x&bslash;n&quot;
comma
(paren
id|u_char
)paren
op_star
(paren
id|p-&gt;ieee_addr
op_plus
id|i
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CRC checksum:         %04x&bslash;n&quot;
comma
(paren
id|u_short
)paren
(paren
id|p-&gt;chksum
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|64
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%3d %04x&bslash;n&quot;
comma
id|i
op_lshift
l_int|1
comma
(paren
id|u_short
)paren
op_star
(paren
(paren
id|u_short
op_star
)paren
id|p
op_plus
id|i
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|de4x5_dbg_rx
id|de4x5_dbg_rx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|len
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
id|de4x5_debug
op_amp
id|DEBUG_RX
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;R: %02x:%02x:%02x:%02x:%02x:%02x &lt;- %02x:%02x:%02x:%02x:%02x:%02x len/SAP:%02x%02x [%d]&bslash;n&quot;
comma
(paren
id|u_char
)paren
id|skb-&gt;data
(braket
l_int|0
)braket
comma
(paren
id|u_char
)paren
id|skb-&gt;data
(braket
l_int|1
)braket
comma
(paren
id|u_char
)paren
id|skb-&gt;data
(braket
l_int|2
)braket
comma
(paren
id|u_char
)paren
id|skb-&gt;data
(braket
l_int|3
)braket
comma
(paren
id|u_char
)paren
id|skb-&gt;data
(braket
l_int|4
)braket
comma
(paren
id|u_char
)paren
id|skb-&gt;data
(braket
l_int|5
)braket
comma
(paren
id|u_char
)paren
id|skb-&gt;data
(braket
l_int|6
)braket
comma
(paren
id|u_char
)paren
id|skb-&gt;data
(braket
l_int|7
)braket
comma
(paren
id|u_char
)paren
id|skb-&gt;data
(braket
l_int|8
)braket
comma
(paren
id|u_char
)paren
id|skb-&gt;data
(braket
l_int|9
)braket
comma
(paren
id|u_char
)paren
id|skb-&gt;data
(braket
l_int|10
)braket
comma
(paren
id|u_char
)paren
id|skb-&gt;data
(braket
l_int|11
)braket
comma
(paren
id|u_char
)paren
id|skb-&gt;data
(braket
l_int|12
)braket
comma
(paren
id|u_char
)paren
id|skb-&gt;data
(braket
l_int|13
)braket
comma
id|len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|len
OG
l_int|0
suffix:semicolon
id|j
op_add_assign
l_int|16
comma
id|len
op_sub_assign
l_int|16
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;    %03x: &quot;
comma
id|j
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
op_logical_and
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
(paren
id|u_char
)paren
id|skb-&gt;data
(braket
id|i
op_plus
id|j
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** Perform IOCTL call functions here. Some are privileged operations and the&n;** effective uid is checked in those cases. In the normal course of events&n;** this function is only used for my testing.&n;*/
r_static
r_int
DECL|function|de4x5_ioctl
id|de4x5_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|de4x5_ioctl
op_star
id|ioc
op_assign
(paren
r_struct
id|de4x5_ioctl
op_star
)paren
op_amp
id|rq-&gt;ifr_data
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|s32
id|omr
suffix:semicolon
r_union
(brace
id|u8
id|addr
(braket
l_int|144
)braket
suffix:semicolon
id|u16
id|sval
(braket
l_int|72
)braket
suffix:semicolon
id|u32
id|lval
(braket
l_int|36
)braket
suffix:semicolon
)brace
id|tmp
suffix:semicolon
id|u_long
id|flags
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|ioc-&gt;cmd
)paren
(brace
r_case
id|DE4X5_GET_HWADDR
suffix:colon
multiline_comment|/* Get the hardware address */
id|ioc-&gt;len
op_assign
id|ETH_ALEN
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp.addr
(braket
id|i
)braket
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
id|tmp.addr
comma
id|ioc-&gt;len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DE4X5_SET_HWADDR
suffix:colon
multiline_comment|/* Set the hardware address */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|tmp.addr
comma
id|ioc-&gt;data
comma
id|ETH_ALEN
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|netif_queue_stopped
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|tmp.addr
(braket
id|i
)braket
suffix:semicolon
)brace
id|build_setup_frame
c_func
(paren
id|dev
comma
id|PHYS_ADDR_ONLY
)paren
suffix:semicolon
multiline_comment|/* Set up the descriptor and give ownership to the card */
id|load_packet
c_func
(paren
id|dev
comma
id|lp-&gt;setup_frame
comma
id|TD_IC
op_or
id|PERFECT_F
op_or
id|TD_SET
op_or
id|SETUP_FRAME_LEN
comma
(paren
r_struct
id|sk_buff
op_star
)paren
l_int|1
)paren
suffix:semicolon
id|lp-&gt;tx_new
op_assign
(paren
op_increment
id|lp-&gt;tx_new
)paren
op_mod
id|lp-&gt;txRingSize
suffix:semicolon
id|outl
c_func
(paren
id|POLL_DEMAND
comma
id|DE4X5_TPD
)paren
suffix:semicolon
multiline_comment|/* Start the TX */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Unlock the TX ring */
r_break
suffix:semicolon
r_case
id|DE4X5_SET_PROM
suffix:colon
multiline_comment|/* Set Promiscuous Mode */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
id|omr
op_or_assign
id|OMR_PR
suffix:semicolon
id|outl
c_func
(paren
id|omr
comma
id|DE4X5_OMR
)paren
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|IFF_PROMISC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DE4X5_CLR_PROM
suffix:colon
multiline_comment|/* Clear Promiscuous Mode */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
id|omr
op_and_assign
op_complement
id|OMR_PR
suffix:semicolon
id|outb
c_func
(paren
id|omr
comma
id|DE4X5_OMR
)paren
suffix:semicolon
id|dev-&gt;flags
op_and_assign
op_complement
id|IFF_PROMISC
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DE4X5_SAY_BOO
suffix:colon
multiline_comment|/* Say &quot;Boo!&quot; to the kernel log file */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Boo!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DE4X5_MCA_EN
suffix:colon
multiline_comment|/* Enable pass all multicast addressing */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|omr
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
id|omr
op_or_assign
id|OMR_PM
suffix:semicolon
id|outl
c_func
(paren
id|omr
comma
id|DE4X5_OMR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DE4X5_GET_STATS
suffix:colon
multiline_comment|/* Get the driver statistics */
(brace
r_struct
id|pkt_stats
id|statbuf
suffix:semicolon
id|ioc-&gt;len
op_assign
r_sizeof
(paren
id|statbuf
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|statbuf
comma
op_amp
id|lp-&gt;pktStats
comma
id|ioc-&gt;len
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
op_amp
id|statbuf
comma
id|ioc-&gt;len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|DE4X5_CLR_STATS
suffix:colon
multiline_comment|/* Zero out the driver statistics */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|lp-&gt;pktStats
comma
l_int|0
comma
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DE4X5_GET_OMR
suffix:colon
multiline_comment|/* Get the OMR Register contents */
id|tmp.addr
(braket
l_int|0
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
id|tmp.addr
comma
l_int|1
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DE4X5_SET_OMR
suffix:colon
multiline_comment|/* Set the OMR Register contents */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|tmp.addr
comma
id|ioc-&gt;data
comma
l_int|1
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|outl
c_func
(paren
id|tmp.addr
(braket
l_int|0
)braket
comma
id|DE4X5_OMR
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DE4X5_GET_REG
suffix:colon
multiline_comment|/* Get the DE4X5 Registers */
id|j
op_assign
l_int|0
suffix:semicolon
id|tmp.lval
(braket
l_int|0
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_STS
)paren
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
id|tmp.lval
(braket
l_int|1
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_BMR
)paren
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
id|tmp.lval
(braket
l_int|2
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_IMR
)paren
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
id|tmp.lval
(braket
l_int|3
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_OMR
)paren
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
id|tmp.lval
(braket
l_int|4
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_SISR
)paren
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
id|tmp.lval
(braket
l_int|5
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_SICR
)paren
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
id|tmp.lval
(braket
l_int|6
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_STRR
)paren
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
id|tmp.lval
(braket
l_int|7
)braket
op_assign
id|inl
c_func
(paren
id|DE4X5_SIGR
)paren
suffix:semicolon
id|j
op_add_assign
l_int|4
suffix:semicolon
id|ioc-&gt;len
op_assign
id|j
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
id|tmp.addr
comma
id|ioc-&gt;len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
DECL|macro|DE4X5_DUMP
mdefine_line|#define DE4X5_DUMP              0x0f /* Dump the DE4X5 Status */
multiline_comment|/*&t;&n;      case DE4X5_DUMP:&n;&t;j = 0;&n;&t;tmp.addr[j++] = dev-&gt;irq;&n;&t;for (i=0; i&lt;ETH_ALEN; i++) {&n;&t;    tmp.addr[j++] = dev-&gt;dev_addr[i];&n;&t;}&n;&t;tmp.addr[j++] = lp-&gt;rxRingSize;&n;&t;tmp.lval[j&gt;&gt;2] = (long)lp-&gt;rx_ring; j+=4;&n;&t;tmp.lval[j&gt;&gt;2] = (long)lp-&gt;tx_ring; j+=4;&n;&t;&n;&t;for (i=0;i&lt;lp-&gt;rxRingSize-1;i++){&n;&t;    if (i &lt; 3) {&n;&t;&t;tmp.lval[j&gt;&gt;2] = (long)&amp;lp-&gt;rx_ring[i].status; j+=4;&n;&t;    }&n;&t;}&n;&t;tmp.lval[j&gt;&gt;2] = (long)&amp;lp-&gt;rx_ring[i].status; j+=4;&n;&t;for (i=0;i&lt;lp-&gt;txRingSize-1;i++){&n;&t;    if (i &lt; 3) {&n;&t;&t;tmp.lval[j&gt;&gt;2] = (long)&amp;lp-&gt;tx_ring[i].status; j+=4;&n;&t;    }&n;&t;}&n;&t;tmp.lval[j&gt;&gt;2] = (long)&amp;lp-&gt;tx_ring[i].status; j+=4;&n;&t;&n;&t;for (i=0;i&lt;lp-&gt;rxRingSize-1;i++){&n;&t;    if (i &lt; 3) {&n;&t;&t;tmp.lval[j&gt;&gt;2] = (s32)le32_to_cpu(lp-&gt;rx_ring[i].buf); j+=4;&n;&t;    }&n;&t;}&n;&t;tmp.lval[j&gt;&gt;2] = (s32)le32_to_cpu(lp-&gt;rx_ring[i].buf); j+=4;&n;&t;for (i=0;i&lt;lp-&gt;txRingSize-1;i++){&n;&t;    if (i &lt; 3) {&n;&t;&t;tmp.lval[j&gt;&gt;2] = (s32)le32_to_cpu(lp-&gt;tx_ring[i].buf); j+=4;&n;&t;    }&n;&t;}&n;&t;tmp.lval[j&gt;&gt;2] = (s32)le32_to_cpu(lp-&gt;tx_ring[i].buf); j+=4;&n;&t;&n;&t;for (i=0;i&lt;lp-&gt;rxRingSize;i++){&n;&t;    tmp.lval[j&gt;&gt;2] = le32_to_cpu(lp-&gt;rx_ring[i].status); j+=4;&n;&t;}&n;&t;for (i=0;i&lt;lp-&gt;txRingSize;i++){&n;&t;    tmp.lval[j&gt;&gt;2] = le32_to_cpu(lp-&gt;tx_ring[i].status); j+=4;&n;&t;}&n;&t;&n;&t;tmp.lval[j&gt;&gt;2] = inl(DE4X5_BMR);  j+=4;&n;&t;tmp.lval[j&gt;&gt;2] = inl(DE4X5_TPD);  j+=4;&n;&t;tmp.lval[j&gt;&gt;2] = inl(DE4X5_RPD);  j+=4;&n;&t;tmp.lval[j&gt;&gt;2] = inl(DE4X5_RRBA); j+=4;&n;&t;tmp.lval[j&gt;&gt;2] = inl(DE4X5_TRBA); j+=4;&n;&t;tmp.lval[j&gt;&gt;2] = inl(DE4X5_STS);  j+=4;&n;&t;tmp.lval[j&gt;&gt;2] = inl(DE4X5_OMR);  j+=4;&n;&t;tmp.lval[j&gt;&gt;2] = inl(DE4X5_IMR);  j+=4;&n;&t;tmp.lval[j&gt;&gt;2] = lp-&gt;chipset; j+=4; &n;&t;if (lp-&gt;chipset == DC21140) {&n;&t;    tmp.lval[j&gt;&gt;2] = gep_rd(dev);  j+=4;&n;&t;} else {&n;&t;    tmp.lval[j&gt;&gt;2] = inl(DE4X5_SISR); j+=4;&n;&t;    tmp.lval[j&gt;&gt;2] = inl(DE4X5_SICR); j+=4;&n;&t;    tmp.lval[j&gt;&gt;2] = inl(DE4X5_STRR); j+=4;&n;&t;    tmp.lval[j&gt;&gt;2] = inl(DE4X5_SIGR); j+=4; &n;&t;}&n;&t;tmp.lval[j&gt;&gt;2] = lp-&gt;phy[lp-&gt;active].id; j+=4; &n;&t;if (lp-&gt;phy[lp-&gt;active].id &amp;&amp; (!lp-&gt;useSROM || lp-&gt;useMII)) {&n;&t;    tmp.lval[j&gt;&gt;2] = lp-&gt;active; j+=4; &n;&t;    tmp.lval[j&gt;&gt;2]=mii_rd(MII_CR,lp-&gt;phy[lp-&gt;active].addr,DE4X5_MII); j+=4;&n;&t;    tmp.lval[j&gt;&gt;2]=mii_rd(MII_SR,lp-&gt;phy[lp-&gt;active].addr,DE4X5_MII); j+=4;&n;&t;    tmp.lval[j&gt;&gt;2]=mii_rd(MII_ID0,lp-&gt;phy[lp-&gt;active].addr,DE4X5_MII); j+=4;&n;&t;    tmp.lval[j&gt;&gt;2]=mii_rd(MII_ID1,lp-&gt;phy[lp-&gt;active].addr,DE4X5_MII); j+=4;&n;&t;    if (lp-&gt;phy[lp-&gt;active].id != BROADCOM_T4) {&n;&t;&t;tmp.lval[j&gt;&gt;2]=mii_rd(MII_ANA,lp-&gt;phy[lp-&gt;active].addr,DE4X5_MII); j+=4;&n;&t;&t;tmp.lval[j&gt;&gt;2]=mii_rd(MII_ANLPA,lp-&gt;phy[lp-&gt;active].addr,DE4X5_MII); j+=4;&n;&t;    }&n;&t;    tmp.lval[j&gt;&gt;2]=mii_rd(0x10,lp-&gt;phy[lp-&gt;active].addr,DE4X5_MII); j+=4;&n;&t;    if (lp-&gt;phy[lp-&gt;active].id != BROADCOM_T4) {&n;&t;&t;tmp.lval[j&gt;&gt;2]=mii_rd(0x11,lp-&gt;phy[lp-&gt;active].addr,DE4X5_MII); j+=4;&n;&t;&t;tmp.lval[j&gt;&gt;2]=mii_rd(0x12,lp-&gt;phy[lp-&gt;active].addr,DE4X5_MII); j+=4;&n;&t;    } else {&n;&t;&t;tmp.lval[j&gt;&gt;2]=mii_rd(0x14,lp-&gt;phy[lp-&gt;active].addr,DE4X5_MII); j+=4;&n;&t;    }&n;&t;}&n;&t;&n;&t;tmp.addr[j++] = lp-&gt;txRingSize;&n;&t;tmp.addr[j++] = netif_queue_stopped(dev);&n;&t;&n;&t;ioc-&gt;len = j;&n;&t;if (copy_to_user(ioc-&gt;data, tmp.addr, ioc-&gt;len)) return -EFAULT;&n;&t;break;&n;&n;*/
r_default
suffix:colon
r_return
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
macro_line|#ifdef MODULE
multiline_comment|/*&n;** Note now that module autoprobing is allowed under EISA and PCI. The&n;** IRQ lines will not be auto-detected; instead I&squot;ll rely on the BIOSes&n;** to &quot;do the right thing&quot;.&n;*/
DECL|macro|LP
mdefine_line|#define LP(a) ((struct de4x5_private *)(a))
DECL|variable|mdev
r_static
r_struct
id|net_device
op_star
id|mdev
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|io
r_static
r_int
id|io
op_assign
l_int|0x0
suffix:semicolon
multiline_comment|/* EDIT THIS LINE FOR YOUR CONFIGURATION IF NEEDED        */
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|num
comma
id|status
op_assign
op_minus
id|EIO
suffix:semicolon
r_struct
id|net_device
op_star
id|p
suffix:semicolon
id|num
op_assign
id|count_adapters
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|p
op_assign
id|insert_device
c_func
(paren
l_int|NULL
comma
id|io
comma
id|de4x5_probe
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mdev
)paren
id|mdev
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
id|p
)paren
op_ne
l_int|0
)paren
(brace
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|p-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|lp
)paren
(brace
id|release_region
c_func
(paren
id|p-&gt;base_addr
comma
(paren
id|lp-&gt;bus
op_eq
id|PCI
ques
c_cond
id|DE4X5_PCI_TOTAL_SIZE
suffix:colon
id|DE4X5_EISA_TOTAL_SIZE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;cache.priv
)paren
(brace
multiline_comment|/* Private area allocated?   */
id|kfree
c_func
(paren
id|lp-&gt;cache.priv
)paren
suffix:semicolon
multiline_comment|/* Free the private area     */
)brace
r_if
c_cond
(paren
id|lp-&gt;rx_ring
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|lp-&gt;pdev
comma
id|lp-&gt;dma_size
comma
id|lp-&gt;rx_ring
comma
id|lp-&gt;dma_rings
)paren
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* At least one adapter will work */
id|lastModule
op_assign
id|p
suffix:semicolon
)brace
)brace
r_return
id|status
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_while
c_loop
(paren
id|mdev
op_ne
l_int|NULL
)paren
(brace
id|mdev
op_assign
id|unlink_modules
c_func
(paren
id|mdev
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_struct
id|net_device
op_star
DECL|function|unlink_modules
id|unlink_modules
c_func
(paren
r_struct
id|net_device
op_star
id|p
)paren
(brace
r_struct
id|net_device
op_star
id|next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;priv
)paren
(brace
multiline_comment|/* Private areas allocated?  */
r_struct
id|de4x5_private
op_star
id|lp
op_assign
(paren
r_struct
id|de4x5_private
op_star
)paren
id|p-&gt;priv
suffix:semicolon
id|next
op_assign
id|lp-&gt;next_module
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;rx_ring
)paren
(brace
id|pci_free_consistent
c_func
(paren
id|lp-&gt;pdev
comma
id|lp-&gt;dma_size
comma
id|lp-&gt;rx_ring
comma
id|lp-&gt;dma_rings
)paren
suffix:semicolon
)brace
id|release_region
c_func
(paren
id|p-&gt;base_addr
comma
(paren
id|lp-&gt;bus
op_eq
id|PCI
ques
c_cond
id|DE4X5_PCI_TOTAL_SIZE
suffix:colon
id|DE4X5_EISA_TOTAL_SIZE
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|lp-&gt;cache.priv
)paren
suffix:semicolon
multiline_comment|/* Free the private area     */
)brace
id|unregister_netdev
c_func
(paren
id|p
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
multiline_comment|/* Free the device structure */
r_return
id|next
suffix:semicolon
)brace
r_static
r_int
DECL|function|count_adapters
id|count_adapters
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|u_short
id|vendor
suffix:semicolon
id|u_int
r_class
op_assign
id|DE4X5_CLASS_CODE
suffix:semicolon
id|u_int
id|device
suffix:semicolon
macro_line|#if !defined(__sparc_v9__) &amp;&amp; !defined(__powerpc__) &amp;&amp; !defined(__alpha__)
r_char
id|name
(braket
id|DE4X5_STRLEN
)braket
suffix:semicolon
id|u_long
id|iobase
op_assign
l_int|0x1000
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|MAX_EISA_SLOTS
suffix:semicolon
id|i
op_increment
comma
id|iobase
op_add_assign
id|EISA_SLOT_INC
)paren
(brace
r_if
c_cond
(paren
id|EISA_signature
c_func
(paren
id|name
comma
id|EISA_ID
)paren
)paren
id|j
op_increment
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|pcibios_present
c_func
(paren
)paren
)paren
r_return
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|pdev
op_assign
id|pci_find_class
c_func
(paren
r_class
comma
id|pdev
)paren
)paren
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
id|vendor
op_assign
id|pdev-&gt;vendor
suffix:semicolon
id|device
op_assign
id|pdev-&gt;device
op_lshift
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|is_DC21040
op_logical_or
id|is_DC21041
op_logical_or
id|is_DC21140
op_logical_or
id|is_DC2114x
)paren
id|j
op_increment
suffix:semicolon
)brace
r_return
id|j
suffix:semicolon
)brace
multiline_comment|/*&n;** If at end of eth device list and can&squot;t use current entry, malloc&n;** one up. If memory could not be allocated, print an error message.&n;*/
r_static
r_struct
id|net_device
op_star
id|__init
DECL|function|insert_device
id|insert_device
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
comma
r_int
(paren
op_star
id|init
)paren
(paren
r_struct
id|net_device
op_star
)paren
)paren
(brace
r_struct
id|net_device
op_star
r_new
suffix:semicolon
r_new
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_device
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;de4x5.c: Device not initialised, insufficient memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
r_new
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_device
)paren
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|base_addr
op_assign
id|iobase
suffix:semicolon
multiline_comment|/* assign the io address */
r_new
op_member_access_from_pointer
id|init
op_assign
id|init
suffix:semicolon
multiline_comment|/* initialisation routine */
)brace
r_return
r_new
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
"&f;"
multiline_comment|/*&n; * Local variables:&n; *&n; * Delete -DMODVERSIONS below if you didn&squot;t define this in your kernel&n; *&n; *  compile-command: &quot;gcc -D__KERNEL__ -DMODULE -I/linux/include -Wall -Wstrict-prototypes -fomit-frame-pointer -fno-strength-reduce -malign-loops=2 -malign-jumps=2 -malign-functions=2 -O2 -m486 -DMODVERSIONS -include /linux/include/linux/modversions.h -c de4x5.c&quot;&n; * End:&n; */
eof
