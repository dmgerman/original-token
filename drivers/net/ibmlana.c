multiline_comment|/* &n;net-3-driver for the IBM LAN Adapter/A&n;&n;This is an extension to the Linux operating system, and is covered by the&n;same Gnu Public License that covers that work.&n;&n;Copyright 1999 by Alfred Arnold (alfred@ccac.rwth-aachen.de, aarnold@elsa.de)&n;&n;This driver is based both on the SK_MCA driver, which is itself based on the&n;SK_G16 and 3C523 driver.&n;&n;paper sources:&n;  &squot;PC Hardware: Aufbau, Funktionsweise, Programmierung&squot; by &n;  Hans-Peter Messmer for the basic Microchannel stuff&n;  &n;  &squot;Linux Geraetetreiber&squot; by Allesandro Rubini, Kalle Dalheimer&n;  for help on Ethernet driver programming&n;&n;  &squot;DP83934CVUL-20/25 MHz SONIC-T Ethernet Controller Datasheet&squot; by National&n;  Semiconductor for info on the MAC chip&n;&n;  &squot;LAN Technical Reference Ethernet Adapter Interface Version 1 Release 1.0&n;   Document Number SC30-3661-00&squot; by IBM for info on the adapter itself&n;&n;  Also see http://www.natsemi.com/&n;&n;special acknowledgements to:&n;  - Bob Eager for helping me out with documentation from IBM&n;  - Jim Shorney for his endless patience with me while I was using &n;    him as a beta tester to trace down the address filter bug ;-)&n;&n;  Missing things:&n;&n;  -&gt; set debug level via ioctl instead of compile-time switches&n;  -&gt; I didn&squot;t follow the development of the 2.1.x kernels, so my&n;     assumptions about which things changed with which kernel version &n;     are probably nonsense&n;&n;History:&n;  Nov 6th, 1999&n;  &t;startup from SK_MCA driver&n;  Dec 6th, 1999&n;&t;finally got docs about the card.  A big thank you to Bob Eager!&n;  Dec 12th, 1999&n;&t;first packet received&n;  Dec 13th, 1999&n;&t;recv queue done, tcpdump works&n;  Dec 15th, 1999&n;&t;transmission part works&n;  Dec 28th, 1999&n;&t;added usage of the isa_functions for Linux 2.3 .  Things should&n;&t;still work with 2.0.x....&n;  Jan 28th, 2000&n;&t;in Linux 2.2.13, the version.h file mysteriously didn&squot;t get&n;&t;included.  Added a workaround for this.  Futhermore, it now&n;&t;not only compiles as a modules ;-)&n;  Jan 30th, 2000&n;&t;newer kernels automatically probe more than one board, so the&n;&t;&squot;startslot&squot; as a variable is also needed here&n;  Apr 12th, 2000&n;&t;the interrupt mask register is not set &squot;hard&squot; instead of individually&n;&t;setting registers, since this seems to set bits that shouldn&squot;t be&n;&t;set&n;  May 21st, 2000&n;&t;reset interrupt status immediately after CAM load&n;&t;add a recovery delay after releasing the chip&squot;s reset line&n;  May 24th, 2000&n;&t;finally found the bug in the address filter setup - damned signed&n;        chars!&n;  June 1st, 2000&n;&t;corrected version codes, added support for the latest 2.3 changes&n;&n; *************************************************************************/
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/mca.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
DECL|macro|_IBM_LANA_DRIVER_
mdefine_line|#define _IBM_LANA_DRIVER_
macro_line|#include &quot;ibmlana.h&quot;
DECL|macro|DEBUG
macro_line|#undef DEBUG
multiline_comment|/* ------------------------------------------------------------------------&n; * global static data - not more since we can handle multiple boards and&n; * have to pack all state info into the device struct!&n; * ------------------------------------------------------------------------ */
DECL|variable|MediaNames
r_static
r_char
op_star
id|MediaNames
(braket
id|Media_Count
)braket
op_assign
(brace
l_string|&quot;10BaseT&quot;
comma
l_string|&quot;10Base5&quot;
comma
l_string|&quot;Unknown&quot;
comma
l_string|&quot;10Base2&quot;
)brace
suffix:semicolon
multiline_comment|/* ------------------------------------------------------------------------&n; * private subfunctions&n; * ------------------------------------------------------------------------ */
macro_line|#ifdef DEBUG
multiline_comment|/* dump all registers */
DECL|function|dumpregs
r_static
r_void
id|dumpregs
c_func
(paren
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
)paren
(brace
r_int
id|z
suffix:semicolon
r_for
c_loop
(paren
id|z
op_assign
l_int|0
suffix:semicolon
id|z
OL
l_int|160
suffix:semicolon
id|z
op_add_assign
l_int|2
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|z
op_amp
l_int|15
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;REGS: %04x:&quot;
comma
id|z
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %04x&quot;
comma
id|inw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|z
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|z
op_amp
l_int|15
)paren
op_eq
l_int|14
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* dump parts of shared memory - only needed during debugging */
DECL|function|dumpmem
r_static
r_void
id|dumpmem
c_func
(paren
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
comma
id|u32
id|start
comma
id|u32
id|len
)paren
(brace
r_int
id|z
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Address %04x:&bslash;n&quot;
comma
id|start
)paren
suffix:semicolon
r_for
c_loop
(paren
id|z
op_assign
l_int|0
suffix:semicolon
id|z
OL
id|len
suffix:semicolon
id|z
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|z
op_amp
l_int|15
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%04x:&quot;
comma
id|z
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
id|IBMLANA_READB
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|start
op_plus
id|z
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|z
op_amp
l_int|15
)paren
op_eq
l_int|15
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|z
op_amp
l_int|15
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* print exact time - ditto */
DECL|function|PrTime
r_static
r_void
id|PrTime
c_func
(paren
r_void
)paren
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%9d:%06d: &quot;
comma
(paren
r_int
)paren
id|tv.tv_sec
comma
(paren
r_int
)paren
id|tv.tv_usec
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* DEBUG */
multiline_comment|/* deduce resources out of POS registers */
DECL|function|getaddrs
r_static
r_void
id|getaddrs
c_func
(paren
r_int
id|slot
comma
r_int
op_star
id|base
comma
r_int
op_star
id|memlen
comma
r_int
op_star
id|iobase
comma
r_int
op_star
id|irq
comma
id|ibmlana_medium
op_star
id|medium
)paren
(brace
id|u_char
id|pos0
comma
id|pos1
suffix:semicolon
id|pos0
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|2
)paren
suffix:semicolon
id|pos1
op_assign
id|mca_read_stored_pos
c_func
(paren
id|slot
comma
l_int|3
)paren
suffix:semicolon
op_star
id|base
op_assign
l_int|0xc0000
op_plus
(paren
(paren
id|pos1
op_amp
l_int|0xf0
)paren
op_lshift
l_int|9
)paren
suffix:semicolon
op_star
id|memlen
op_assign
(paren
id|pos1
op_amp
l_int|0x01
)paren
ques
c_cond
l_int|0x8000
suffix:colon
l_int|0x4000
suffix:semicolon
op_star
id|iobase
op_assign
(paren
id|pos0
op_amp
l_int|0xe0
)paren
op_lshift
l_int|7
suffix:semicolon
r_switch
c_cond
(paren
id|pos0
op_amp
l_int|0x06
)paren
(brace
r_case
l_int|0
suffix:colon
op_star
id|irq
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
id|irq
op_assign
l_int|15
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
id|irq
op_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
op_star
id|irq
op_assign
l_int|11
suffix:semicolon
r_break
suffix:semicolon
)brace
op_star
id|medium
op_assign
(paren
id|pos0
op_amp
l_int|0x18
)paren
op_rshift
l_int|3
suffix:semicolon
)brace
multiline_comment|/* wait on register value with mask and timeout */
DECL|function|wait_timeout
r_static
r_int
id|wait_timeout
c_func
(paren
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
comma
r_int
id|regoffs
comma
id|u16
id|mask
comma
id|u16
id|value
comma
r_int
id|timeout
)paren
(brace
r_int
r_int
id|fin
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
op_ne
id|fin
)paren
r_if
c_cond
(paren
(paren
id|inw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|regoffs
)paren
op_amp
id|mask
)paren
op_eq
id|value
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* reset the whole board */
DECL|function|ResetBoard
r_static
r_void
id|ResetBoard
c_func
(paren
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
)paren
(brace
r_int
r_char
id|bcmval
suffix:semicolon
multiline_comment|/* read original board control value */
id|bcmval
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|BCMREG
)paren
suffix:semicolon
multiline_comment|/* set reset bit for a while */
id|bcmval
op_or_assign
id|BCMREG_RESET
suffix:semicolon
id|outb
c_func
(paren
id|bcmval
comma
id|dev-&gt;base_addr
op_plus
id|BCMREG
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|bcmval
op_and_assign
op_complement
id|BCMREG_RESET
suffix:semicolon
id|outb
c_func
(paren
id|bcmval
comma
id|dev-&gt;base_addr
op_plus
id|BCMREG
)paren
suffix:semicolon
multiline_comment|/* switch over to RAM again */
id|bcmval
op_or_assign
id|BCMREG_RAMEN
op_or
id|BCMREG_RAMWIN
suffix:semicolon
id|outb
c_func
(paren
id|bcmval
comma
id|dev-&gt;base_addr
op_plus
id|BCMREG
)paren
suffix:semicolon
)brace
multiline_comment|/* calculate RAM layout &amp; set up descriptors in RAM */
DECL|function|InitDscrs
r_static
r_void
id|InitDscrs
c_func
(paren
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
)paren
(brace
id|ibmlana_priv
op_star
id|priv
op_assign
(paren
id|ibmlana_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u32
id|addr
comma
id|baddr
comma
id|raddr
suffix:semicolon
r_int
id|z
suffix:semicolon
id|tda_t
id|tda
suffix:semicolon
id|rda_t
id|rda
suffix:semicolon
id|rra_t
id|rra
suffix:semicolon
multiline_comment|/* initialize RAM */
id|IBMLANA_SETIO
c_func
(paren
id|dev-&gt;mem_start
comma
l_int|0xaa
comma
id|dev-&gt;mem_start
op_minus
id|dev-&gt;mem_start
)paren
suffix:semicolon
multiline_comment|/* setup n TX descriptors - independent of RAM size */
id|priv-&gt;tdastart
op_assign
id|addr
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;txbufstart
op_assign
id|baddr
op_assign
r_sizeof
(paren
id|tda_t
)paren
op_star
id|TXBUFCNT
suffix:semicolon
r_for
c_loop
(paren
id|z
op_assign
l_int|0
suffix:semicolon
id|z
OL
id|TXBUFCNT
suffix:semicolon
id|z
op_increment
)paren
(brace
id|tda.status
op_assign
l_int|0
suffix:semicolon
id|tda.config
op_assign
l_int|0
suffix:semicolon
id|tda.length
op_assign
l_int|0
suffix:semicolon
id|tda.fragcount
op_assign
l_int|1
suffix:semicolon
id|tda.startlo
op_assign
id|baddr
suffix:semicolon
id|tda.starthi
op_assign
l_int|0
suffix:semicolon
id|tda.fraglength
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|z
op_eq
id|TXBUFCNT
op_minus
l_int|1
)paren
id|tda.link
op_assign
id|priv-&gt;tdastart
suffix:semicolon
r_else
id|tda.link
op_assign
id|addr
op_plus
r_sizeof
(paren
id|tda_t
)paren
suffix:semicolon
id|tda.link
op_or_assign
l_int|1
suffix:semicolon
id|IBMLANA_TOIO
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|addr
comma
op_amp
id|tda
comma
r_sizeof
(paren
id|tda_t
)paren
)paren
suffix:semicolon
id|addr
op_add_assign
r_sizeof
(paren
id|tda_t
)paren
suffix:semicolon
id|baddr
op_add_assign
id|PKTSIZE
suffix:semicolon
)brace
multiline_comment|/* calculate how many receive buffers fit into remaining memory */
id|priv-&gt;rxbufcnt
op_assign
(paren
id|dev-&gt;mem_end
op_minus
id|dev-&gt;mem_start
op_minus
id|baddr
)paren
op_div
(paren
r_sizeof
(paren
id|rra_t
)paren
op_plus
r_sizeof
(paren
id|rda_t
)paren
op_plus
id|PKTSIZE
)paren
suffix:semicolon
multiline_comment|/* calculate receive addresses */
id|priv-&gt;rrastart
op_assign
id|raddr
op_assign
id|priv-&gt;txbufstart
op_plus
(paren
id|TXBUFCNT
op_star
id|PKTSIZE
)paren
suffix:semicolon
id|priv-&gt;rdastart
op_assign
id|addr
op_assign
id|priv-&gt;rrastart
op_plus
(paren
id|priv-&gt;rxbufcnt
op_star
r_sizeof
(paren
id|rra_t
)paren
)paren
suffix:semicolon
id|priv-&gt;rxbufstart
op_assign
id|baddr
op_assign
id|priv-&gt;rdastart
op_plus
(paren
id|priv-&gt;rxbufcnt
op_star
r_sizeof
(paren
id|rda_t
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|z
op_assign
l_int|0
suffix:semicolon
id|z
OL
id|priv-&gt;rxbufcnt
suffix:semicolon
id|z
op_increment
)paren
(brace
id|rra.startlo
op_assign
id|baddr
suffix:semicolon
id|rra.starthi
op_assign
l_int|0
suffix:semicolon
id|rra.cntlo
op_assign
id|PKTSIZE
op_rshift
l_int|1
suffix:semicolon
id|rra.cnthi
op_assign
l_int|0
suffix:semicolon
id|IBMLANA_TOIO
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|raddr
comma
op_amp
id|rra
comma
r_sizeof
(paren
id|rra_t
)paren
)paren
suffix:semicolon
id|rda.status
op_assign
l_int|0
suffix:semicolon
id|rda.length
op_assign
l_int|0
suffix:semicolon
id|rda.startlo
op_assign
l_int|0
suffix:semicolon
id|rda.starthi
op_assign
l_int|0
suffix:semicolon
id|rda.seqno
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|z
OL
id|priv-&gt;rxbufcnt
op_minus
l_int|1
)paren
id|rda.link
op_assign
id|addr
op_plus
r_sizeof
(paren
id|rda_t
)paren
suffix:semicolon
r_else
id|rda.link
op_assign
l_int|1
suffix:semicolon
id|rda.inuse
op_assign
l_int|1
suffix:semicolon
id|IBMLANA_TOIO
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|addr
comma
op_amp
id|rda
comma
r_sizeof
(paren
id|rda_t
)paren
)paren
suffix:semicolon
id|baddr
op_add_assign
id|PKTSIZE
suffix:semicolon
id|raddr
op_add_assign
r_sizeof
(paren
id|rra_t
)paren
suffix:semicolon
id|addr
op_add_assign
r_sizeof
(paren
id|rda_t
)paren
suffix:semicolon
)brace
multiline_comment|/* initialize current pointers */
id|priv-&gt;nextrxdescr
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;lastrxdescr
op_assign
id|priv-&gt;rxbufcnt
op_minus
l_int|1
suffix:semicolon
id|priv-&gt;nexttxdescr
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;currtxdescr
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;txusedcnt
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|priv-&gt;txused
comma
l_int|0
comma
r_sizeof
(paren
id|priv-&gt;txused
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* set up Rx + Tx descriptors in SONIC */
DECL|function|InitSONIC
r_static
r_int
id|InitSONIC
c_func
(paren
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
)paren
(brace
id|ibmlana_priv
op_star
id|priv
op_assign
(paren
id|ibmlana_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* set up start &amp; end of resource area */
id|outw
c_func
(paren
l_int|0
comma
id|SONIC_URRA
)paren
suffix:semicolon
id|outw
c_func
(paren
id|priv-&gt;rrastart
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_RSA
)paren
suffix:semicolon
id|outw
c_func
(paren
id|priv-&gt;rrastart
op_plus
(paren
id|priv-&gt;rxbufcnt
op_star
r_sizeof
(paren
id|rra_t
)paren
)paren
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_REA
)paren
suffix:semicolon
id|outw
c_func
(paren
id|priv-&gt;rrastart
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_RRP
)paren
suffix:semicolon
id|outw
c_func
(paren
id|priv-&gt;rrastart
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_RWP
)paren
suffix:semicolon
multiline_comment|/* set EOBC so that only one packet goes into one buffer */
id|outw
c_func
(paren
(paren
id|PKTSIZE
op_minus
l_int|4
)paren
op_rshift
l_int|1
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_EOBC
)paren
suffix:semicolon
multiline_comment|/* let SONIC read the first RRA descriptor */
id|outw
c_func
(paren
id|CMDREG_RRRA
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_CMDREG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wait_timeout
c_func
(paren
id|dev
comma
id|SONIC_CMDREG
comma
id|CMDREG_RRRA
comma
l_int|0
comma
l_int|2
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: SONIC did not respond on RRRA command - giving up.&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* point SONIC to the first RDA */
id|outw
c_func
(paren
l_int|0
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_URDA
)paren
suffix:semicolon
id|outw
c_func
(paren
id|priv-&gt;rdastart
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_CRDA
)paren
suffix:semicolon
multiline_comment|/* set upper half of TDA address */
id|outw
c_func
(paren
l_int|0
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_UTDA
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* stop SONIC so we can reinitialize it */
DECL|function|StopSONIC
r_static
r_void
id|StopSONIC
c_func
(paren
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
)paren
(brace
multiline_comment|/* disable interrupts */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|BCMREG
)paren
op_amp
(paren
op_complement
id|BCMREG_IEN
)paren
comma
id|dev-&gt;base_addr
op_plus
id|BCMREG
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_IMREG
)paren
suffix:semicolon
multiline_comment|/* reset the SONIC */
id|outw
c_func
(paren
id|CMDREG_RST
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_CMDREG
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CMDREG_RST
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_CMDREG
)paren
suffix:semicolon
)brace
multiline_comment|/* initialize card and SONIC for proper operation */
DECL|function|putcam
r_static
r_void
id|putcam
c_func
(paren
id|camentry_t
op_star
id|cams
comma
r_int
op_star
id|camcnt
comma
r_char
op_star
id|addr
)paren
(brace
id|camentry_t
op_star
id|pcam
op_assign
id|cams
op_plus
(paren
op_star
id|camcnt
)paren
suffix:semicolon
id|u8
op_star
id|uaddr
op_assign
(paren
id|u8
op_star
)paren
id|addr
suffix:semicolon
id|pcam-&gt;index
op_assign
op_star
id|camcnt
suffix:semicolon
id|pcam-&gt;addr0
op_assign
(paren
(paren
(paren
id|u16
)paren
id|uaddr
(braket
l_int|1
)braket
)paren
op_lshift
l_int|8
)paren
op_or
id|uaddr
(braket
l_int|0
)braket
suffix:semicolon
id|pcam-&gt;addr1
op_assign
(paren
(paren
(paren
id|u16
)paren
id|uaddr
(braket
l_int|3
)braket
)paren
op_lshift
l_int|8
)paren
op_or
id|uaddr
(braket
l_int|2
)braket
suffix:semicolon
id|pcam-&gt;addr2
op_assign
(paren
(paren
(paren
id|u16
)paren
id|uaddr
(braket
l_int|5
)braket
)paren
op_lshift
l_int|8
)paren
op_or
id|uaddr
(braket
l_int|4
)braket
suffix:semicolon
(paren
op_star
id|camcnt
)paren
op_increment
suffix:semicolon
)brace
DECL|function|InitBoard
r_static
r_void
id|InitBoard
c_func
(paren
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
)paren
(brace
r_int
id|camcnt
suffix:semicolon
id|camentry_t
id|cams
(braket
l_int|16
)braket
suffix:semicolon
id|u32
id|cammask
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|mcptr
suffix:semicolon
id|u16
id|rcrval
suffix:semicolon
multiline_comment|/* reset the SONIC */
id|outw
c_func
(paren
id|CMDREG_RST
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_CMDREG
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* clear all spurious interrupts */
id|outw
c_func
(paren
id|inw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|SONIC_ISREG
)paren
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_ISREG
)paren
suffix:semicolon
multiline_comment|/* set up the SONIC&squot;s bus interface - constant for this adapter -&n;&t;   must be done while the SONIC is in reset */
id|outw
c_func
(paren
id|DCREG_USR1
op_or
id|DCREG_USR0
op_or
id|DCREG_WC1
op_or
id|DCREG_DW32
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_DCREG
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_DCREG2
)paren
suffix:semicolon
multiline_comment|/* remove reset form the SONIC */
id|outw
c_func
(paren
l_int|0
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_CMDREG
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* data sheet requires URRA to be programmed before setting up the CAM contents */
id|outw
c_func
(paren
l_int|0
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_URRA
)paren
suffix:semicolon
multiline_comment|/* program the CAM entry 0 to the device address */
id|camcnt
op_assign
l_int|0
suffix:semicolon
id|putcam
c_func
(paren
id|cams
comma
op_amp
id|camcnt
comma
id|dev-&gt;dev_addr
)paren
suffix:semicolon
multiline_comment|/* start putting the multicast addresses into the CAM list.  Stop if&n;&t;   it is full. */
r_for
c_loop
(paren
id|mcptr
op_assign
id|dev-&gt;mc_list
suffix:semicolon
id|mcptr
op_ne
l_int|NULL
suffix:semicolon
id|mcptr
op_assign
id|mcptr-&gt;next
)paren
(brace
id|putcam
c_func
(paren
id|cams
comma
op_amp
id|camcnt
comma
id|mcptr-&gt;dmi_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|camcnt
op_eq
l_int|16
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* calculate CAM mask */
id|cammask
op_assign
(paren
l_int|1
op_lshift
id|camcnt
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* feed CDA into SONIC, initialize RCR value (always get broadcasts) */
id|IBMLANA_TOIO
c_func
(paren
id|dev-&gt;mem_start
comma
id|cams
comma
r_sizeof
(paren
id|camentry_t
)paren
op_star
id|camcnt
)paren
suffix:semicolon
id|IBMLANA_TOIO
c_func
(paren
id|dev-&gt;mem_start
op_plus
(paren
r_sizeof
(paren
id|camentry_t
)paren
op_star
id|camcnt
)paren
comma
op_amp
id|cammask
comma
r_sizeof
(paren
id|cammask
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;CAM setup:&bslash;n&quot;
)paren
suffix:semicolon
id|dumpmem
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
id|camentry_t
)paren
op_star
id|camcnt
op_plus
r_sizeof
(paren
id|cammask
)paren
)paren
suffix:semicolon
macro_line|#endif
id|outw
c_func
(paren
l_int|0
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_CAMPTR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|camcnt
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_CAMCNT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CMDREG_LCAM
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_CMDREG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wait_timeout
c_func
(paren
id|dev
comma
id|SONIC_CMDREG
comma
id|CMDREG_LCAM
comma
l_int|0
comma
l_int|2
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s:SONIC did not respond on LCAM command - giving up.&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* clear interrupt condition */
id|outw
c_func
(paren
id|ISREG_LCD
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_ISREG
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Loading CAM done, address pointers %04x:%04x&bslash;n&quot;
comma
id|inw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|SONIC_URRA
)paren
comma
id|inw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|SONIC_CAMPTR
)paren
)paren
suffix:semicolon
(brace
r_int
id|z
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n--&gt;CAM: PTR %04x CNT %04x&bslash;n&quot;
comma
id|inw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|SONIC_CAMPTR
)paren
comma
id|inw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|SONIC_CAMCNT
)paren
)paren
suffix:semicolon
id|outw
c_func
(paren
id|CMDREG_RST
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_CMDREG
)paren
suffix:semicolon
r_for
c_loop
(paren
id|z
op_assign
l_int|0
suffix:semicolon
id|z
OL
id|camcnt
suffix:semicolon
id|z
op_increment
)paren
(brace
id|outw
c_func
(paren
id|z
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_CAMEPTR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Entry %d: %04x %04x %04x&bslash;n&quot;
comma
id|z
comma
id|inw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|SONIC_CAMADDR0
)paren
comma
id|inw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|SONIC_CAMADDR1
)paren
comma
id|inw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|SONIC_CAMADDR2
)paren
)paren
suffix:semicolon
)brace
id|outw
c_func
(paren
l_int|0
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_CMDREG
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
id|rcrval
op_assign
id|RCREG_BRD
op_or
id|RCREG_LB_NONE
suffix:semicolon
multiline_comment|/* if still multicast addresses left or ALLMULTI is set, set the multicast&n;&t;   enable bit */
r_if
c_cond
(paren
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
op_logical_or
(paren
id|mcptr
op_ne
l_int|NULL
)paren
)paren
id|rcrval
op_or_assign
id|RCREG_AMC
suffix:semicolon
multiline_comment|/* promiscous mode ? */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
id|rcrval
op_or_assign
id|RCREG_PRO
suffix:semicolon
multiline_comment|/* program receive mode */
id|outw
c_func
(paren
id|rcrval
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_RCREG
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;&bslash;nRCRVAL: %04x&bslash;n&quot;
comma
id|rcrval
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* set up descriptors in shared memory + feed them into SONIC registers */
id|InitDscrs
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|InitSONIC
c_func
(paren
id|dev
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* reset all pending interrupts */
id|outw
c_func
(paren
l_int|0xffff
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_ISREG
)paren
suffix:semicolon
multiline_comment|/* enable transmitter + receiver interrupts */
id|outw
c_func
(paren
id|CMDREG_RXEN
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_CMDREG
)paren
suffix:semicolon
id|outw
c_func
(paren
id|IMREG_PRXEN
op_or
id|IMREG_RBEEN
op_or
id|IMREG_PTXEN
op_or
id|IMREG_TXEREN
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_IMREG
)paren
suffix:semicolon
multiline_comment|/* turn on card interrupts */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|BCMREG
)paren
op_or
id|BCMREG_IEN
comma
id|dev-&gt;base_addr
op_plus
id|BCMREG
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Register dump after initialization:&bslash;n&quot;
)paren
suffix:semicolon
id|dumpregs
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* start transmission of a descriptor */
DECL|function|StartTx
r_static
r_void
id|StartTx
c_func
(paren
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
comma
r_int
id|descr
)paren
(brace
id|ibmlana_priv
op_star
id|priv
op_assign
(paren
id|ibmlana_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|addr
suffix:semicolon
id|addr
op_assign
id|priv-&gt;tdastart
op_plus
(paren
id|descr
op_star
r_sizeof
(paren
id|tda_t
)paren
)paren
suffix:semicolon
multiline_comment|/* put descriptor address into SONIC */
id|outw
c_func
(paren
id|addr
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_CTDA
)paren
suffix:semicolon
multiline_comment|/* trigger transmitter */
id|priv-&gt;currtxdescr
op_assign
id|descr
suffix:semicolon
id|outw
c_func
(paren
id|CMDREG_TXP
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_CMDREG
)paren
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------&n; * interrupt handler(s)&n; * ------------------------------------------------------------------------ */
multiline_comment|/* receive buffer area exhausted */
DECL|function|irqrbe_handler
r_static
r_void
id|irqrbe_handler
c_func
(paren
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
)paren
(brace
id|ibmlana_priv
op_star
id|priv
op_assign
(paren
id|ibmlana_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* point the SONIC back to the RRA start */
id|outw
c_func
(paren
id|priv-&gt;rrastart
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_RRP
)paren
suffix:semicolon
id|outw
c_func
(paren
id|priv-&gt;rrastart
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_RWP
)paren
suffix:semicolon
)brace
multiline_comment|/* receive interrupt */
DECL|function|irqrx_handler
r_static
r_void
id|irqrx_handler
c_func
(paren
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
)paren
(brace
id|ibmlana_priv
op_star
id|priv
op_assign
(paren
id|ibmlana_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|rda_t
id|rda
suffix:semicolon
id|u32
id|rdaaddr
comma
id|lrdaaddr
suffix:semicolon
multiline_comment|/* loop until ... */
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* read descriptor that was next to be filled by SONIC */
id|rdaaddr
op_assign
id|priv-&gt;rdastart
op_plus
(paren
id|priv-&gt;nextrxdescr
op_star
r_sizeof
(paren
id|rda_t
)paren
)paren
suffix:semicolon
id|lrdaaddr
op_assign
id|priv-&gt;rdastart
op_plus
(paren
id|priv-&gt;lastrxdescr
op_star
r_sizeof
(paren
id|rda_t
)paren
)paren
suffix:semicolon
id|IBMLANA_FROMIO
c_func
(paren
op_amp
id|rda
comma
id|dev-&gt;mem_start
op_plus
id|rdaaddr
comma
r_sizeof
(paren
id|rda_t
)paren
)paren
suffix:semicolon
multiline_comment|/* iron out upper word halves of fields we use - SONIC will duplicate &n;&t;&t;   bits 0..15 to 16..31 */
id|rda.status
op_and_assign
l_int|0xffff
suffix:semicolon
id|rda.length
op_and_assign
l_int|0xffff
suffix:semicolon
id|rda.startlo
op_and_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* stop if the SONIC still owns it, i.e. there is no data for us */
r_if
c_cond
(paren
id|rda.inuse
)paren
r_break
suffix:semicolon
multiline_comment|/* good packet? */
r_else
r_if
c_cond
(paren
id|rda.status
op_amp
id|RCREG_PRX
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
multiline_comment|/* fetch buffer */
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|rda.length
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
id|priv-&gt;stat.rx_dropped
op_increment
suffix:semicolon
r_else
(brace
multiline_comment|/* copy out data */
id|IBMLANA_FROMIO
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|rda.length
)paren
comma
id|dev-&gt;mem_start
op_plus
id|rda.startlo
comma
id|rda.length
)paren
suffix:semicolon
multiline_comment|/* set up skb fields */
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|skb-&gt;ip_summed
op_assign
id|CHECKSUM_NONE
suffix:semicolon
multiline_comment|/* bookkeeping */
id|priv-&gt;stat.rx_packets
op_increment
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x20119)&t;/* byte counters for kernel &gt;= 2.1.25 */
id|priv-&gt;stat.rx_bytes
op_add_assign
id|rda.length
suffix:semicolon
macro_line|#endif
multiline_comment|/* pass to the upper layers */
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* otherwise check error status bits and increase statistics */
r_else
(brace
id|priv-&gt;stat.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rda.status
op_amp
id|RCREG_FAER
)paren
id|priv-&gt;stat.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rda.status
op_amp
id|RCREG_CRCR
)paren
id|priv-&gt;stat.rx_crc_errors
op_increment
suffix:semicolon
)brace
multiline_comment|/* descriptor processed, will become new last descriptor in queue */
id|rda.link
op_assign
l_int|1
suffix:semicolon
id|rda.inuse
op_assign
l_int|1
suffix:semicolon
id|IBMLANA_TOIO
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|rdaaddr
comma
op_amp
id|rda
comma
r_sizeof
(paren
id|rda_t
)paren
)paren
suffix:semicolon
multiline_comment|/* set up link and EOL = 0 in currently last descriptor. Only write&n;&t;&t;   the link field since the SONIC may currently already access the&n;&t;&t;   other fields. */
id|IBMLANA_TOIO
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|lrdaaddr
op_plus
l_int|20
comma
op_amp
id|rdaaddr
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* advance indices */
id|priv-&gt;lastrxdescr
op_assign
id|priv-&gt;nextrxdescr
suffix:semicolon
r_if
c_cond
(paren
(paren
op_increment
id|priv-&gt;nextrxdescr
)paren
op_ge
id|priv-&gt;rxbufcnt
)paren
id|priv-&gt;nextrxdescr
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* transmit interrupt */
DECL|function|irqtx_handler
r_static
r_void
id|irqtx_handler
c_func
(paren
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
)paren
(brace
id|ibmlana_priv
op_star
id|priv
op_assign
(paren
id|ibmlana_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|tda_t
id|tda
suffix:semicolon
multiline_comment|/* fetch descriptor (we forgot the size ;-) */
id|IBMLANA_FROMIO
c_func
(paren
op_amp
id|tda
comma
id|dev-&gt;mem_start
op_plus
id|priv-&gt;tdastart
op_plus
(paren
id|priv-&gt;currtxdescr
op_star
r_sizeof
(paren
id|tda_t
)paren
)paren
comma
r_sizeof
(paren
id|tda_t
)paren
)paren
suffix:semicolon
multiline_comment|/* update statistics */
id|priv-&gt;stat.tx_packets
op_increment
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x020119)
id|priv-&gt;stat.tx_bytes
op_add_assign
id|tda.length
suffix:semicolon
macro_line|#endif
multiline_comment|/* update our pointers */
id|priv-&gt;txused
(braket
id|priv-&gt;currtxdescr
)braket
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;txusedcnt
op_decrement
suffix:semicolon
multiline_comment|/* if there are more descriptors present in RAM, start them */
r_if
c_cond
(paren
id|priv-&gt;txusedcnt
OG
l_int|0
)paren
id|StartTx
c_func
(paren
id|dev
comma
(paren
id|priv-&gt;currtxdescr
op_plus
l_int|1
)paren
op_mod
id|TXBUFCNT
)paren
suffix:semicolon
multiline_comment|/* tell the upper layer we can go on transmitting */
macro_line|#if LINUX_VERSION_CODE &gt;= 0x02032a
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#else
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|irqtxerr_handler
r_static
r_void
id|irqtxerr_handler
c_func
(paren
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
)paren
(brace
id|ibmlana_priv
op_star
id|priv
op_assign
(paren
id|ibmlana_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|tda_t
id|tda
suffix:semicolon
multiline_comment|/* fetch descriptor to check status */
id|IBMLANA_FROMIO
c_func
(paren
op_amp
id|tda
comma
id|dev-&gt;mem_start
op_plus
id|priv-&gt;tdastart
op_plus
(paren
id|priv-&gt;currtxdescr
op_star
r_sizeof
(paren
id|tda_t
)paren
)paren
comma
r_sizeof
(paren
id|tda_t
)paren
)paren
suffix:semicolon
multiline_comment|/* update statistics */
id|priv-&gt;stat.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tda.status
op_amp
(paren
id|TCREG_NCRS
op_or
id|TCREG_CRSL
)paren
)paren
id|priv-&gt;stat.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tda.status
op_amp
id|TCREG_EXC
)paren
id|priv-&gt;stat.tx_aborted_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tda.status
op_amp
id|TCREG_OWC
)paren
id|priv-&gt;stat.tx_window_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tda.status
op_amp
id|TCREG_FU
)paren
id|priv-&gt;stat.tx_fifo_errors
op_increment
suffix:semicolon
multiline_comment|/* update our pointers */
id|priv-&gt;txused
(braket
id|priv-&gt;currtxdescr
)braket
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;txusedcnt
op_decrement
suffix:semicolon
multiline_comment|/* if there are more descriptors present in RAM, start them */
r_if
c_cond
(paren
id|priv-&gt;txusedcnt
OG
l_int|0
)paren
id|StartTx
c_func
(paren
id|dev
comma
(paren
id|priv-&gt;currtxdescr
op_plus
l_int|1
)paren
op_mod
id|TXBUFCNT
)paren
suffix:semicolon
multiline_comment|/* tell the upper layer we can go on transmitting */
macro_line|#if LINUX_VERSION_CODE &gt;= 0x02032a
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#else
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* general interrupt entry */
DECL|function|irq_handler
r_static
r_void
id|irq_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|device
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
op_assign
(paren
r_struct
id|IBMLANA_NETDEV
op_star
)paren
id|device
suffix:semicolon
id|u16
id|ival
suffix:semicolon
multiline_comment|/* in case we&squot;re not meant... */
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|BCMREG
)paren
op_amp
id|BCMREG_IPEND
)paren
)paren
r_return
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x02032a)
macro_line|#if 0
id|set_bit
c_func
(paren
id|LINK_STATE_RXSEM
comma
op_amp
id|dev-&gt;state
)paren
suffix:semicolon
macro_line|#endif
macro_line|#else
id|dev-&gt;interrupt
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/* loop through the interrupt bits until everything is clear */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|ival
op_assign
id|inw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|SONIC_ISREG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ival
op_amp
id|ISREG_RBE
)paren
(brace
id|irqrbe_handler
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outw
c_func
(paren
id|ISREG_RBE
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_ISREG
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ival
op_amp
id|ISREG_PKTRX
)paren
(brace
id|irqrx_handler
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outw
c_func
(paren
id|ISREG_PKTRX
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_ISREG
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ival
op_amp
id|ISREG_TXDN
)paren
(brace
id|irqtx_handler
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outw
c_func
(paren
id|ISREG_TXDN
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_ISREG
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ival
op_amp
id|ISREG_TXER
)paren
(brace
id|irqtxerr_handler
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outw
c_func
(paren
id|ISREG_TXER
comma
id|dev-&gt;base_addr
op_plus
id|SONIC_ISREG
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x02032a)
macro_line|#if 0
id|clear_bit
c_func
(paren
id|LINK_STATE_RXSEM
comma
op_amp
id|dev-&gt;state
)paren
suffix:semicolon
macro_line|#endif
macro_line|#else
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* ------------------------------------------------------------------------&n; * driver methods&n; * ------------------------------------------------------------------------ */
multiline_comment|/* MCA info */
DECL|function|ibmlana_getinfo
r_static
r_int
id|ibmlana_getinfo
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|slot
comma
r_void
op_star
id|d
)paren
(brace
r_int
id|len
op_assign
l_int|0
comma
id|i
suffix:semicolon
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
op_assign
(paren
r_struct
id|IBMLANA_NETDEV
op_star
)paren
id|d
suffix:semicolon
id|ibmlana_priv
op_star
id|priv
suffix:semicolon
multiline_comment|/* can&squot;t say anything about an uninitialized device... */
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
r_return
id|len
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
r_return
id|len
suffix:semicolon
id|priv
op_assign
(paren
id|ibmlana_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* print info */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;IRQ: %d&bslash;n&quot;
comma
id|priv-&gt;realirq
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;I/O: %#lx&bslash;n&quot;
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Memory: %#lx-%#lx&bslash;n&quot;
comma
id|dev-&gt;mem_start
comma
id|dev-&gt;mem_end
op_minus
l_int|1
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Transceiver: %s&bslash;n&quot;
comma
id|MediaNames
(braket
id|priv-&gt;medium
)braket
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;Device: %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;MAC address:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot; %02x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|buf
(braket
id|len
op_increment
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|buf
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* open driver.  Means also initialization and start of LANCE */
DECL|function|ibmlana_open
r_static
r_int
id|ibmlana_open
c_func
(paren
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
)paren
(brace
r_int
id|result
suffix:semicolon
id|ibmlana_priv
op_star
id|priv
op_assign
(paren
id|ibmlana_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* register resources - only necessary for IRQ */
id|result
op_assign
id|request_irq
c_func
(paren
id|priv-&gt;realirq
comma
id|irq_handler
comma
id|SA_SHIRQ
op_or
id|SA_SAMPLE_RANDOM
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: failed to register irq %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|dev-&gt;irq
op_assign
id|priv-&gt;realirq
suffix:semicolon
multiline_comment|/* set up the card and SONIC */
id|InitBoard
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* initialize operational flags */
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x02032a)
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#else
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* close driver.  Shut down board and free allocated resources */
DECL|function|ibmlana_close
r_static
r_int
id|ibmlana_close
c_func
(paren
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
)paren
(brace
multiline_comment|/* turn off board */
multiline_comment|/* release resources */
r_if
c_cond
(paren
id|dev-&gt;irq
op_ne
l_int|0
)paren
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
l_int|0
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &lt; 0x02032a)
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* transmit a block. */
DECL|function|ibmlana_tx
r_static
r_int
id|ibmlana_tx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
)paren
(brace
id|ibmlana_priv
op_star
id|priv
op_assign
(paren
id|ibmlana_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
comma
id|tmplen
comma
id|addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|tda_t
id|tda
suffix:semicolon
r_int
id|baddr
suffix:semicolon
multiline_comment|/* if we get called with a NULL descriptor, the Ethernet layer thinks &n;&t;   our card is stuck an we should reset it.  We&squot;ll do this completely: */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Resetting SONIC&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|StopSONIC
c_func
(paren
id|dev
)paren
suffix:semicolon
id|InitBoard
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t try to free the block here ;-) */
)brace
multiline_comment|/* find out if there are free slots for a frame to transmit. If not,&n;&t;   the upper layer is in deep desperation and we simply ignore the frame. */
r_if
c_cond
(paren
id|priv-&gt;txusedcnt
op_ge
id|TXBUFCNT
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
id|priv-&gt;stat.tx_dropped
op_increment
suffix:semicolon
r_goto
id|tx_done
suffix:semicolon
)brace
multiline_comment|/* copy the frame data into the next free transmit buffer - fillup missing */
id|tmplen
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|tmplen
OL
l_int|60
)paren
id|tmplen
op_assign
l_int|60
suffix:semicolon
id|baddr
op_assign
id|priv-&gt;txbufstart
op_plus
(paren
id|priv-&gt;nexttxdescr
op_star
id|PKTSIZE
)paren
suffix:semicolon
id|IBMLANA_TOIO
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|baddr
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* copy filler into RAM - in case we&squot;re filling up... &n;&t;   we&squot;re filling a bit more than necessary, but that doesn&squot;t harm&n;&t;   since the buffer is far larger... &n;&t;   Sorry Linus for the filler string but I couldn&squot;t resist ;-) */
r_if
c_cond
(paren
id|tmplen
OG
id|skb-&gt;len
)paren
(brace
r_char
op_star
id|fill
op_assign
l_string|&quot;NetBSD is a nice OS too! &quot;
suffix:semicolon
r_int
r_int
id|destoffs
op_assign
id|skb-&gt;len
comma
id|l
op_assign
id|strlen
c_func
(paren
id|fill
)paren
suffix:semicolon
r_while
c_loop
(paren
id|destoffs
OL
id|tmplen
)paren
(brace
id|IBMLANA_TOIO
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|baddr
op_plus
id|destoffs
comma
id|fill
comma
id|l
)paren
suffix:semicolon
id|destoffs
op_add_assign
id|l
suffix:semicolon
)brace
)brace
multiline_comment|/* set up the new frame descriptor */
id|addr
op_assign
id|priv-&gt;tdastart
op_plus
(paren
id|priv-&gt;nexttxdescr
op_star
r_sizeof
(paren
id|tda_t
)paren
)paren
suffix:semicolon
id|IBMLANA_FROMIO
c_func
(paren
op_amp
id|tda
comma
id|dev-&gt;mem_start
op_plus
id|addr
comma
r_sizeof
(paren
id|tda_t
)paren
)paren
suffix:semicolon
id|tda.length
op_assign
id|tda.fraglength
op_assign
id|tmplen
suffix:semicolon
id|IBMLANA_TOIO
c_func
(paren
id|dev-&gt;mem_start
op_plus
id|addr
comma
op_amp
id|tda
comma
r_sizeof
(paren
id|tda_t
)paren
)paren
suffix:semicolon
multiline_comment|/* if there were no active descriptors, trigger the SONIC */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|priv-&gt;txusedcnt
op_increment
suffix:semicolon
id|priv-&gt;txused
(braket
id|priv-&gt;nexttxdescr
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* are all transmission slots used up ? */
r_if
c_cond
(paren
id|priv-&gt;txusedcnt
op_ge
id|TXBUFCNT
)paren
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x02032a)
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#else
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|priv-&gt;txusedcnt
op_eq
l_int|1
)paren
id|StartTx
c_func
(paren
id|dev
comma
id|priv-&gt;nexttxdescr
)paren
suffix:semicolon
id|priv-&gt;nexttxdescr
op_assign
(paren
id|priv-&gt;nexttxdescr
op_plus
l_int|1
)paren
op_mod
id|TXBUFCNT
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|tx_done
suffix:colon
multiline_comment|/* When did that change exactly ? */
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x20200)
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#else
id|dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
macro_line|#endif
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* return pointer to Ethernet statistics */
DECL|function|ibmlana_stats
r_static
r_struct
id|net_device_stats
op_star
id|ibmlana_stats
c_func
(paren
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
)paren
(brace
id|ibmlana_priv
op_star
id|priv
op_assign
(paren
id|ibmlana_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
(paren
id|priv-&gt;stat
)paren
suffix:semicolon
)brace
multiline_comment|/* we don&squot;t support runtime reconfiguration, since am MCA card can&n;   be unambigously identified by its POS registers. */
DECL|function|ibmlana_config
r_static
r_int
id|ibmlana_config
c_func
(paren
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
comma
r_struct
id|ifmap
op_star
id|map
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* switch receiver mode. */
DECL|function|ibmlana_set_multicast_list
r_static
r_void
id|ibmlana_set_multicast_list
c_func
(paren
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
)paren
(brace
multiline_comment|/* first stop the SONIC... */
id|StopSONIC
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* ...then reinit it with the new flags */
id|InitBoard
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------&n; * hardware check&n; * ------------------------------------------------------------------------ */
DECL|variable|startslot
r_static
r_int
id|startslot
suffix:semicolon
multiline_comment|/* counts through slots when probing multiple devices */
DECL|function|ibmlana_probe
r_int
id|ibmlana_probe
c_func
(paren
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
)paren
(brace
r_int
id|force_detect
op_assign
l_int|0
suffix:semicolon
r_int
id|slot
comma
id|z
suffix:semicolon
r_int
id|base
op_assign
l_int|0
comma
id|irq
op_assign
l_int|0
comma
id|iobase
op_assign
l_int|0
comma
id|memlen
op_assign
l_int|0
suffix:semicolon
id|ibmlana_priv
op_star
id|priv
suffix:semicolon
id|ibmlana_medium
id|medium
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x02032a)
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* can&squot;t work without an MCA bus ;-) */
r_if
c_cond
(paren
id|MCA_bus
op_eq
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* start address of 1 --&gt; forced detection */
r_if
c_cond
(paren
id|dev-&gt;mem_start
op_eq
l_int|1
)paren
id|force_detect
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* search through slots */
r_if
c_cond
(paren
id|dev
op_ne
l_int|NULL
)paren
(brace
id|base
op_assign
id|dev-&gt;mem_start
suffix:semicolon
id|irq
op_assign
id|dev-&gt;irq
suffix:semicolon
)brace
id|slot
op_assign
id|mca_find_adapter
c_func
(paren
id|IBM_LANA_ID
comma
id|startslot
)paren
suffix:semicolon
r_while
c_loop
(paren
id|slot
op_ne
op_minus
l_int|1
)paren
(brace
multiline_comment|/* deduce card addresses */
id|getaddrs
c_func
(paren
id|slot
comma
op_amp
id|base
comma
op_amp
id|memlen
comma
op_amp
id|iobase
comma
op_amp
id|irq
comma
op_amp
id|medium
)paren
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x20300)
multiline_comment|/* slot already in use ? */
r_if
c_cond
(paren
id|mca_is_adapter_used
c_func
(paren
id|slot
)paren
)paren
(brace
id|slot
op_assign
id|mca_find_adapter
c_func
(paren
id|IBM_LANA_ID
comma
id|slot
op_plus
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* were we looking for something different ? */
r_if
c_cond
(paren
(paren
id|dev-&gt;irq
op_ne
l_int|0
)paren
op_logical_or
(paren
id|dev-&gt;mem_start
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;irq
op_ne
l_int|0
)paren
op_logical_and
(paren
id|dev-&gt;irq
op_ne
id|irq
)paren
)paren
(brace
id|slot
op_assign
id|mca_find_adapter
c_func
(paren
id|IBM_LANA_ID
comma
id|slot
op_plus
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dev-&gt;mem_start
op_ne
l_int|0
)paren
op_logical_and
(paren
id|dev-&gt;mem_start
op_ne
id|base
)paren
)paren
(brace
id|slot
op_assign
id|mca_find_adapter
c_func
(paren
id|IBM_LANA_ID
comma
id|slot
op_plus
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
multiline_comment|/* found something that matches */
r_break
suffix:semicolon
)brace
multiline_comment|/* nothing found ? */
r_if
c_cond
(paren
id|slot
op_eq
op_minus
l_int|1
)paren
r_return
(paren
(paren
id|base
op_ne
l_int|0
)paren
op_logical_or
(paren
id|irq
op_ne
l_int|0
)paren
)paren
ques
c_cond
op_minus
id|ENXIO
suffix:colon
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* announce success */
id|printk
c_func
(paren
l_string|&quot;%s: IBM LAN Adapter/A found in slot %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|slot
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* try to obtain I/O range */
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|iobase
comma
id|IBM_LANA_IORANGE
comma
id|dev-&gt;name
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: cannot allocate I/O range at %#x!&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|iobase
)paren
suffix:semicolon
id|startslot
op_assign
id|slot
op_plus
l_int|1
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* make procfs entries */
id|mca_set_adapter_name
c_func
(paren
id|slot
comma
l_string|&quot;IBM LAN Adapter/A&quot;
)paren
suffix:semicolon
id|mca_set_adapter_procfn
c_func
(paren
id|slot
comma
(paren
id|MCA_ProcFn
)paren
id|ibmlana_getinfo
comma
id|dev
)paren
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x20200)
id|mca_mark_as_used
c_func
(paren
id|slot
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* allocate structure */
id|priv
op_assign
id|dev-&gt;priv
op_assign
(paren
id|ibmlana_priv
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ibmlana_priv
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv
)paren
(brace
id|release_region
c_func
(paren
id|iobase
comma
id|IBM_LANA_IORANGE
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|priv-&gt;slot
op_assign
id|slot
suffix:semicolon
id|priv-&gt;realirq
op_assign
id|irq
suffix:semicolon
id|priv-&gt;medium
op_assign
id|medium
suffix:semicolon
id|memset
c_func
(paren
op_amp
(paren
id|priv-&gt;stat
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_device_stats
)paren
)paren
suffix:semicolon
multiline_comment|/* set base + irq for this device (irq not allocated so far) */
id|dev-&gt;irq
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;mem_start
op_assign
id|base
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|base
op_plus
id|memlen
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|iobase
suffix:semicolon
multiline_comment|/* set methods */
id|dev-&gt;open
op_assign
id|ibmlana_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|ibmlana_close
suffix:semicolon
id|dev-&gt;set_config
op_assign
id|ibmlana_config
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|ibmlana_tx
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|ibmlana_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|ibmlana_set_multicast_list
suffix:semicolon
id|dev-&gt;flags
op_or_assign
id|IFF_MULTICAST
suffix:semicolon
multiline_comment|/* generic setup */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* copy out MAC address */
r_for
c_loop
(paren
id|z
op_assign
l_int|0
suffix:semicolon
id|z
OL
r_sizeof
(paren
id|dev-&gt;dev_addr
)paren
suffix:semicolon
id|z
op_increment
)paren
id|dev-&gt;dev_addr
(braket
id|z
)braket
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|MACADDRPROM
op_plus
id|z
)paren
suffix:semicolon
multiline_comment|/* print config */
id|printk
c_func
(paren
l_string|&quot;%s: IRQ %d, I/O %#lx, memory %#lx-%#lx, &quot;
l_string|&quot;MAC address %02x:%02x:%02x:%02x:%02x:%02x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|priv-&gt;realirq
comma
id|dev-&gt;base_addr
comma
id|dev-&gt;mem_start
comma
id|dev-&gt;mem_end
op_minus
l_int|1
comma
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|3
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s medium&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|MediaNames
(braket
id|priv-&gt;medium
)braket
)paren
suffix:semicolon
multiline_comment|/* reset board */
id|ResetBoard
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* next probe will start at next slot */
id|startslot
op_assign
id|slot
op_plus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------------&n; * modularization support&n; * ------------------------------------------------------------------------ */
macro_line|#ifdef MODULE
DECL|macro|DEVMAX
mdefine_line|#define DEVMAX 5
DECL|variable|moddevs
r_static
r_struct
id|IBMLANA_NETDEV
id|moddevs
(braket
id|DEVMAX
)braket
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
suffix:semicolon
DECL|variable|io
r_static
r_int
id|io
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|z
comma
id|res
suffix:semicolon
id|startslot
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|z
op_assign
l_int|0
suffix:semicolon
id|z
OL
id|DEVMAX
suffix:semicolon
id|z
op_increment
)paren
(brace
id|moddevs
(braket
id|z
)braket
dot
id|init
op_assign
id|ibmlana_probe
suffix:semicolon
id|moddevs
(braket
id|z
)braket
dot
id|irq
op_assign
id|irq
suffix:semicolon
id|moddevs
(braket
id|z
)braket
dot
id|base_addr
op_assign
id|io
suffix:semicolon
id|res
op_assign
id|register_netdev
c_func
(paren
id|moddevs
op_plus
id|z
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_ne
l_int|0
)paren
r_return
(paren
id|z
OG
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|IBMLANA_NETDEV
op_star
id|dev
suffix:semicolon
id|ibmlana_priv
op_star
id|priv
suffix:semicolon
r_int
id|z
suffix:semicolon
r_if
c_cond
(paren
id|MOD_IN_USE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cannot unload, module in use&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|z
op_assign
l_int|0
suffix:semicolon
id|z
OL
id|DEVMAX
suffix:semicolon
id|z
op_increment
)paren
(brace
id|dev
op_assign
id|moddevs
op_plus
id|z
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_ne
l_int|NULL
)paren
(brace
id|priv
op_assign
(paren
id|ibmlana_priv
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/*DeinitBoard(dev); */
r_if
c_cond
(paren
id|dev-&gt;irq
op_ne
l_int|0
)paren
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
l_int|0
suffix:semicolon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
id|IBM_LANA_IORANGE
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x20200)
id|mca_mark_as_unused
c_func
(paren
id|priv-&gt;slot
)paren
suffix:semicolon
macro_line|#endif
id|mca_set_adapter_name
c_func
(paren
id|priv-&gt;slot
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|mca_set_adapter_procfn
c_func
(paren
id|priv-&gt;slot
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif&t;&t;&t;&t;/* MODULE */
eof
