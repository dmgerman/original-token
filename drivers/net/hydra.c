multiline_comment|/* Linux/68k Hydra Amiganet board driver v2.1 BETA                          */
multiline_comment|/* copyleft by Topi Kanerva (topi@susanna.oulu.fi)                          */
multiline_comment|/* also some code &amp; lots of fixes by Timo Rossi (trossi@cc.jyu.fi)          */
multiline_comment|/* The code is mostly based on the linux/68k Ariadne driver                 */
multiline_comment|/* copyrighted by Geert Uytterhoeven (geert@linux-m68k.org)                 */
multiline_comment|/* and Peter De Schrijver (Peter.DeSchrijver@linux.cc.kuleuven.ac.be)       */
multiline_comment|/* This file is subject to the terms and conditions of the GNU General      */
multiline_comment|/* Public License.  See the file COPYING in the main directory of the       */
multiline_comment|/* Linux distribution for more details.                                     */
multiline_comment|/* The Amiganet is a Zorro-II board made by Hydra Systems. It contains a    */
multiline_comment|/* NS8390 NIC (network interface controller) clone, 16 or 64K on-board RAM  */
multiline_comment|/* and 10BASE-2 (thin coax) and AUI connectors.                             */
multiline_comment|/*                                                                          */
multiline_comment|/* Changes                                                                  */
multiline_comment|/* Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt; - 08/06/2000            */
multiline_comment|/* - check init_etherdev in hydra_probe                                     */
multiline_comment|/* - dev-&gt;priv is already zeroed by init_etherdev                           */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/amigaints.h&gt;
macro_line|#include &lt;asm/amigahw.h&gt;
macro_line|#include &lt;linux/zorro.h&gt;
macro_line|#include &quot;hydra.h&quot;
DECL|macro|HYDRA_DEBUG
mdefine_line|#define HYDRA_DEBUG
DECL|macro|HAVE_MULTICAST
macro_line|#undef HAVE_MULTICAST
DECL|macro|HYDRA_VERSION
mdefine_line|#define HYDRA_VERSION &quot;v2.1 BETA&quot;
DECL|macro|HYDRA_DEBUG
macro_line|#undef HYDRA_DEBUG        /* define this for (lots of) debugging information */
macro_line|#if 0                         /* currently hardwired to one transmit buffer */
mdefine_line|#define TX_RING_SIZE&t;5
mdefine_line|#define RX_RING_SIZE&t;16
macro_line|#else
DECL|macro|TX_RING_SIZE
mdefine_line|#define TX_RING_SIZE 1
DECL|macro|RX_RING_SIZE
mdefine_line|#define RX_RING_SIZE 8
macro_line|#endif
DECL|macro|ETHER_MIN_LEN
mdefine_line|#define ETHER_MIN_LEN 64
DECL|macro|ETHER_MAX_LEN
mdefine_line|#define ETHER_MAX_LEN 1518
DECL|macro|ETHER_ADDR_LEN
mdefine_line|#define ETHER_ADDR_LEN 6
multiline_comment|/*&n; *   let&squot;s define here nice macros for writing and reading NIC registers&n; *&n; * the CIA accesses here are uses to make sure the minimum time&n; * requirement between NIC chip selects is met.&n; */
DECL|macro|WRITE_REG
mdefine_line|#define WRITE_REG(reg, val) (ciaa.pra, ((u8)(*(nicbase+(reg))=val)))
DECL|macro|READ_REG
mdefine_line|#define READ_REG(reg) (ciaa.pra, ((u8)(*(nicbase+(reg)))))
multiline_comment|/* mask value for the interrupts we use */
DECL|macro|NIC_INTS
mdefine_line|#define NIC_INTS (ISR_PRX | ISR_PTX | ISR_RXE | ISR_TXE | ISR_OVW | ISR_CNT)
multiline_comment|/* only broadcasts, no promiscuous mode for now */
DECL|macro|NIC_RCRBITS
mdefine_line|#define NIC_RCRBITS (0)
multiline_comment|/*&n; *   Private Device Data&n; */
DECL|struct|hydra_private
r_struct
id|hydra_private
(brace
DECL|member|tx_page_start
id|u16
id|tx_page_start
suffix:semicolon
DECL|member|rx_page_start
id|u16
id|rx_page_start
suffix:semicolon
DECL|member|rx_page_stop
id|u16
id|rx_page_stop
suffix:semicolon
DECL|member|next_pkt
id|u16
id|next_pkt
suffix:semicolon
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
)brace
suffix:semicolon
r_static
r_int
id|hydra_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|hydra_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|hydra_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|data
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
suffix:semicolon
r_static
r_void
id|__inline__
id|hydra_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|hydra_private
op_star
id|priv
comma
r_volatile
id|u8
op_star
id|nicbase
)paren
suffix:semicolon
r_static
r_int
id|hydra_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|hydra_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
macro_line|#ifdef HAVE_MULTICAST
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|num_addrs
comma
r_void
op_star
id|addrs
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* this is now coherent with the C version below, */
multiline_comment|/* compile the source with -D__USE_ASM__ if you   */
multiline_comment|/* want it - it&squot;ll only be some 10% faster though */
macro_line|#if defined (__GNUC__) &amp;&amp; defined (__mc68000__) &amp;&amp; defined (USE_ASM)
DECL|function|memcpyw
r_static
id|__inline__
r_void
op_star
id|memcpyw
c_func
(paren
id|u16
op_star
id|dest
comma
id|u16
op_star
id|src
comma
r_int
id|len
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;   move.l %0,%/a1; move.l %1,%/a0; move.l %2,%/d0 &bslash;n&bslash;t&quot;
l_string|&quot;   cmpi.l #2,%/d0 &bslash;n&bslash;t&quot;
l_string|&quot;1: bcs.s  2f &bslash;n&bslash;t&quot;
l_string|&quot;   move.w %/a0@+,%/a1@+ &bslash;n&bslash;t&quot;
l_string|&quot;   subq.l #2,%/d0 &bslash;n&bslash;t&quot;
l_string|&quot;   bra.s  1b &bslash;n&bslash;t&quot;
l_string|&quot;2: cmpi.l #1,%/d0 &bslash;n&bslash;t&quot;
l_string|&quot;   bne.s  3f &bslash;n&bslash;t&quot;
l_string|&quot;   move.w %/a0@,%/d0 &bslash;n&bslash;t&quot;
l_string|&quot;   swap.w %/d0 &bslash;n&bslash;t&quot;
l_string|&quot;   move.b %/d0,%/a1@ &bslash;n&bslash;t&quot;
l_string|&quot;3: moveq  #0,%/d0 &bslash;n&bslash;t&quot;
suffix:colon
suffix:colon
l_string|&quot;g&quot;
(paren
id|dest
)paren
comma
l_string|&quot;g&quot;
(paren
id|src
)paren
comma
l_string|&quot;g&quot;
(paren
id|len
)paren
suffix:colon
l_string|&quot;a1&quot;
comma
l_string|&quot;a0&quot;
comma
l_string|&quot;d0&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/* hydra memory can only be read or written as words or longwords.  */
multiline_comment|/* that will mean that we&squot;ll have to write a special memcpy for it. */
multiline_comment|/* this one here relies on the fact that _writes_ to hydra memory   */
multiline_comment|/* are guaranteed to be of even length. (reads can be arbitrary)    */
multiline_comment|/*&n; *&t;FIXME: Surely we should be using the OS generic stuff and do&n; *&n; *&t;memcpy(dest,src,(len+1)&amp;~1);&n; *&n; *&t;Can a 68K guy with this card check that ? - better yet&n; *&t;use a copy/checksum on it.&n; */
DECL|function|memcpyw
r_static
r_void
id|memcpyw
c_func
(paren
id|u16
op_star
id|dest
comma
id|u16
op_star
id|src
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
op_amp
l_int|1
)paren
(brace
id|len
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|len
op_ge
l_int|2
)paren
(brace
op_star
(paren
id|dest
op_increment
)paren
op_assign
op_star
(paren
id|src
op_increment
)paren
suffix:semicolon
id|len
op_sub_assign
l_int|2
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|function|hydra_probe
r_int
id|__init
id|hydra_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|zorro_dev
op_star
id|z
op_assign
l_int|NULL
suffix:semicolon
r_int
id|j
suffix:semicolon
macro_line|#ifdef HYDRA_DEBUG
id|printk
c_func
(paren
l_string|&quot;hydra_probe(%x)&bslash;n&quot;
comma
id|dev
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
(paren
id|z
op_assign
id|zorro_find_device
c_func
(paren
id|ZORRO_PROD_HYDRA_SYSTEMS_AMIGANET
comma
id|z
)paren
)paren
)paren
(brace
r_int
r_int
id|board
op_assign
id|z-&gt;resource.start
suffix:semicolon
r_int
r_int
id|base_addr
op_assign
id|board
op_plus
id|HYDRA_NIC_BASE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_mem_region
c_func
(paren
id|base_addr
comma
l_int|0x20
comma
l_string|&quot;NS8390&quot;
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_mem_region
c_func
(paren
id|board
comma
l_int|0x4000
comma
l_string|&quot;RAM&quot;
)paren
)paren
(brace
id|release_mem_region
c_func
(paren
id|base_addr
comma
l_int|0x20
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|z-&gt;name
comma
l_string|&quot;Hydra Ethernet Card&quot;
)paren
suffix:semicolon
id|dev
op_assign
id|init_etherdev
c_func
(paren
l_int|NULL
comma
r_sizeof
(paren
r_struct
id|hydra_private
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
id|release_mem_region
c_func
(paren
id|base_addr
comma
l_int|0x20
)paren
suffix:semicolon
id|release_mem_region
c_func
(paren
id|board
comma
l_int|0x4000
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ETHER_ADDR_LEN
suffix:semicolon
id|j
op_increment
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|j
)braket
op_assign
op_star
(paren
(paren
id|u8
op_star
)paren
id|ZTWO_VADDR
c_func
(paren
id|board
op_plus
id|HYDRA_ADDRPROM
op_plus
l_int|2
op_star
id|j
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: hydra at 0x%08x, address %02x:%02x:%02x:%02x:%02x:%02x (hydra.c &quot;
id|HYDRA_VERSION
l_string|&quot;)&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
)paren
id|board
comma
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|3
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
comma
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|ZTWO_VADDR
c_func
(paren
id|base_addr
)paren
suffix:semicolon
id|dev-&gt;mem_start
op_assign
id|ZTWO_VADDR
c_func
(paren
id|board
)paren
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|dev-&gt;mem_start
op_plus
l_int|0x4000
suffix:semicolon
id|dev-&gt;open
op_assign
op_amp
id|hydra_open
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|hydra_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|hydra_start_xmit
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|hydra_get_stats
suffix:semicolon
macro_line|#ifdef HAVE_MULTICAST
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; *&t;Cannot yet do multicast&n;&t;&t; */
id|dev-&gt;flags
op_and_assign
op_complement
id|IFF_MULTICAST
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|hydra_open
r_static
r_int
id|hydra_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|hydra_private
op_star
id|priv
op_assign
(paren
r_struct
id|hydra_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_volatile
id|u8
op_star
id|nicbase
op_assign
(paren
id|u8
op_star
)paren
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef HYDRA_DEBUG
id|printk
c_func
(paren
l_string|&quot;hydra_open(0x%x)&bslash;n&quot;
comma
id|dev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* first, initialize the private structure */
id|priv-&gt;tx_page_start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* these are 256 byte buffers for NS8390 */
id|priv-&gt;rx_page_start
op_assign
l_int|6
suffix:semicolon
id|priv-&gt;rx_page_stop
op_assign
l_int|62
suffix:semicolon
multiline_comment|/* these values are hard coded for now */
multiline_comment|/* Reset the NS8390 NIC */
id|WRITE_REG
c_func
(paren
id|NIC_CR
comma
id|CR_PAGE0
op_or
id|CR_NODMA
op_or
id|CR_STOP
)paren
suffix:semicolon
multiline_comment|/* be sure that the NIC is in stopped state */
r_while
c_loop
(paren
op_logical_neg
(paren
id|READ_REG
c_func
(paren
id|NIC_ISR
)paren
op_amp
id|ISR_RST
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* word transfer, big endian bytes, loopback, FIFO threshold 4 bytes */
id|WRITE_REG
c_func
(paren
id|NIC_DCR
comma
id|DCR_WTS
op_or
id|DCR_BOS
op_or
id|DCR_LS
op_or
id|DCR_FT0
)paren
suffix:semicolon
multiline_comment|/* clear remote byte count registers */
id|WRITE_REG
c_func
(paren
id|NIC_RBCR0
comma
l_int|0
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_RBCR1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* accept packets addressed to this card and also broadcast packets */
id|WRITE_REG
c_func
(paren
id|NIC_RCR
comma
id|NIC_RCRBITS
)paren
suffix:semicolon
multiline_comment|/* enable loopback mode 1 */
id|WRITE_REG
c_func
(paren
id|NIC_TCR
comma
id|TCR_LB1
)paren
suffix:semicolon
multiline_comment|/* initialize receive buffer ring */
id|WRITE_REG
c_func
(paren
id|NIC_PSTART
comma
id|priv-&gt;rx_page_start
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_PSTOP
comma
id|priv-&gt;rx_page_stop
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_BNDRY
comma
id|priv-&gt;rx_page_start
)paren
suffix:semicolon
multiline_comment|/* clear interrupts */
id|WRITE_REG
c_func
(paren
id|NIC_ISR
comma
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* enable interrupts */
id|WRITE_REG
c_func
(paren
id|NIC_IMR
comma
id|NIC_INTS
)paren
suffix:semicolon
multiline_comment|/* set the ethernet hardware address */
id|WRITE_REG
c_func
(paren
id|NIC_CR
comma
id|CR_PAGE1
op_or
id|CR_NODMA
op_or
id|CR_STOP
)paren
suffix:semicolon
multiline_comment|/* goto page 1 */
id|WRITE_REG
c_func
(paren
id|NIC_PAR0
comma
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_PAR1
comma
id|dev-&gt;dev_addr
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_PAR2
comma
id|dev-&gt;dev_addr
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_PAR3
comma
id|dev-&gt;dev_addr
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_PAR4
comma
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_PAR5
comma
id|dev-&gt;dev_addr
(braket
l_int|5
)braket
)paren
suffix:semicolon
multiline_comment|/* clear multicast hash table */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|WRITE_REG
c_func
(paren
id|NIC_MAR0
op_plus
l_int|2
op_star
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
id|priv-&gt;next_pkt
op_assign
id|priv-&gt;rx_page_start
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* init our s/w variable */
id|WRITE_REG
c_func
(paren
id|NIC_CURR
comma
id|priv-&gt;next_pkt
)paren
suffix:semicolon
multiline_comment|/* set the next buf for current */
multiline_comment|/* goto page 0, start NIC */
id|WRITE_REG
c_func
(paren
id|NIC_CR
comma
id|CR_PAGE0
op_or
id|CR_NODMA
op_or
id|CR_START
)paren
suffix:semicolon
multiline_comment|/* take interface out of loopback */
id|WRITE_REG
c_func
(paren
id|NIC_TCR
comma
l_int|0
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|IRQ_AMIGA_PORTS
comma
id|hydra_interrupt
comma
id|SA_SHIRQ
comma
l_string|&quot;Hydra Ethernet&quot;
comma
id|dev
)paren
)paren
(brace
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hydra_close
r_static
r_int
id|hydra_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|hydra_private
op_star
id|priv
op_assign
(paren
r_struct
id|hydra_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_volatile
id|u8
op_star
id|nicbase
op_assign
(paren
id|u8
op_star
)paren
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|n
op_assign
l_int|5000
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef HYDRA_DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: Shutting down ethercard&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %d packets missed&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|priv-&gt;stats.rx_missed_errors
)paren
suffix:semicolon
macro_line|#endif
id|WRITE_REG
c_func
(paren
id|NIC_CR
comma
id|CR_PAGE0
op_or
id|CR_NODMA
op_or
id|CR_STOP
)paren
suffix:semicolon
multiline_comment|/* wait for NIC to stop (what a nice timeout..) */
r_while
c_loop
(paren
(paren
(paren
id|READ_REG
c_func
(paren
id|NIC_ISR
)paren
op_amp
id|ISR_RST
)paren
op_eq
l_int|0
)paren
op_logical_and
op_decrement
id|n
)paren
(brace
suffix:semicolon
)brace
id|free_irq
c_func
(paren
id|IRQ_AMIGA_PORTS
comma
id|dev
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hydra_interrupt
r_static
r_void
id|hydra_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|data
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_volatile
id|u8
op_star
id|nicbase
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|data
suffix:semicolon
r_struct
id|hydra_private
op_star
id|priv
suffix:semicolon
id|u16
id|intbits
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;hydra_interrupt(): irq for unknown device&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* this is not likely a problem - i think */
r_if
c_cond
(paren
id|dev-&gt;interrupt
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: re-entering the interrupt handler&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
id|dev-&gt;interrupt
op_assign
l_int|1
suffix:semicolon
id|priv
op_assign
(paren
r_struct
id|hydra_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|nicbase
op_assign
(paren
id|u8
op_star
)paren
id|dev-&gt;base_addr
suffix:semicolon
multiline_comment|/* select page 0 */
id|WRITE_REG
c_func
(paren
id|NIC_CR
comma
id|CR_PAGE0
op_or
id|CR_START
op_or
id|CR_NODMA
)paren
suffix:semicolon
id|intbits
op_assign
id|READ_REG
c_func
(paren
id|NIC_ISR
)paren
op_amp
id|NIC_INTS
suffix:semicolon
r_if
c_cond
(paren
id|intbits
op_eq
l_int|0
)paren
(brace
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* acknowledge all interrupts, by clearing the interrupt flag */
id|WRITE_REG
c_func
(paren
id|NIC_ISR
comma
id|intbits
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|intbits
op_amp
id|ISR_PTX
)paren
op_logical_and
op_logical_neg
(paren
id|intbits
op_amp
id|ISR_TXE
)paren
)paren
(brace
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|intbits
op_amp
id|ISR_PRX
)paren
op_logical_and
op_logical_neg
(paren
id|intbits
op_amp
id|ISR_RXE
)paren
)paren
(brace
multiline_comment|/* packet received OK */
id|hydra_rx
c_func
(paren
id|dev
comma
id|priv
comma
id|nicbase
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intbits
op_amp
id|ISR_TXE
)paren
(brace
id|priv-&gt;stats.tx_errors
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intbits
op_amp
id|ISR_RXE
)paren
(brace
id|priv-&gt;stats.rx_errors
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intbits
op_amp
id|ISR_CNT
)paren
(brace
multiline_comment|/*&n;&t;&t; * read the tally counters and (currently) ignore the values&n;&t;&t; * might be useful because of bugs of some versions of the 8390 NIC&n;&t;&t; */
macro_line|#ifdef HYDRA_DEBUG
id|printk
c_func
(paren
l_string|&quot;hydra_interrupt(): ISR_CNT&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
(paren
r_void
)paren
id|READ_REG
c_func
(paren
id|NIC_CNTR0
)paren
suffix:semicolon
(paren
r_void
)paren
id|READ_REG
c_func
(paren
id|NIC_CNTR1
)paren
suffix:semicolon
(paren
r_void
)paren
id|READ_REG
c_func
(paren
id|NIC_CNTR2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intbits
op_amp
id|ISR_OVW
)paren
(brace
macro_line|#ifdef HYDRA_DEBUG
id|WRITE_REG
c_func
(paren
id|NIC_CR
comma
id|CR_PAGE1
op_or
id|CR_START
op_or
id|CR_NODMA
)paren
suffix:semicolon
multiline_comment|/* another one just too much for me to comprehend - basically this could  */
multiline_comment|/* only occur because of invalid access to hydra ram, thus invalidating  */
multiline_comment|/* the interrupt bits read - in average usage these do not occur at all */
id|printk
c_func
(paren
l_string|&quot;hydra_interrupt(): overwrite warning, NIC_ISR %02x, NIC_CURR %02x&bslash;n&quot;
comma
id|intbits
comma
id|READ_REG
c_func
(paren
id|NIC_CURR
)paren
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_CR
comma
id|CR_PAGE0
op_or
id|CR_START
op_or
id|CR_NODMA
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* overwrite warning occurred, stop NIC &amp; check the BOUNDARY pointer */
multiline_comment|/* FIXME - real overwrite handling needed !! */
id|printk
c_func
(paren
l_string|&quot;hydra_interrupt(): overwrite warning, resetting NIC&bslash;n&quot;
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_CR
comma
id|CR_PAGE0
op_or
id|CR_NODMA
op_or
id|CR_STOP
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|READ_REG
c_func
(paren
id|NIC_ISR
)paren
op_amp
id|ISR_RST
)paren
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* wait for NIC to reset */
id|WRITE_REG
c_func
(paren
id|NIC_DCR
comma
id|DCR_WTS
op_or
id|DCR_BOS
op_or
id|DCR_LS
op_or
id|DCR_FT0
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_RBCR0
comma
l_int|0
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_RBCR1
comma
l_int|0
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_RCR
comma
id|NIC_RCRBITS
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_TCR
comma
id|TCR_LB1
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_PSTART
comma
id|priv-&gt;rx_page_start
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_PSTOP
comma
id|priv-&gt;rx_page_stop
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_BNDRY
comma
id|priv-&gt;rx_page_start
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_ISR
comma
l_int|0xff
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_IMR
comma
id|NIC_INTS
)paren
suffix:semicolon
multiline_comment|/* currently this _won&squot;t_ reset my hydra, even though it is */
multiline_comment|/* basically the same code as in the board init - any ideas? */
id|priv-&gt;next_pkt
op_assign
id|priv-&gt;rx_page_start
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* init our s/w variable */
id|WRITE_REG
c_func
(paren
id|NIC_CURR
comma
id|priv-&gt;next_pkt
)paren
suffix:semicolon
multiline_comment|/* set the next buf for current */
id|WRITE_REG
c_func
(paren
id|NIC_CR
comma
id|CR_PAGE0
op_or
id|CR_NODMA
op_or
id|CR_START
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_TCR
comma
l_int|0
)paren
suffix:semicolon
)brace
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * packet transmit routine&n; */
DECL|function|hydra_start_xmit
r_static
r_int
id|hydra_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|hydra_private
op_star
id|priv
op_assign
(paren
r_struct
id|hydra_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_volatile
id|u8
op_star
id|nicbase
op_assign
(paren
id|u8
op_star
)paren
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|len
comma
id|len1
suffix:semicolon
multiline_comment|/* Transmitter timeout, serious problems. */
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
(brace
r_int
id|tickssofar
op_assign
id|jiffies
op_minus
id|dev-&gt;trans_start
suffix:semicolon
r_if
c_cond
(paren
id|tickssofar
OL
l_int|20
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|WRITE_REG
c_func
(paren
id|NIC_CR
comma
id|CR_STOP
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: transmit timed out, status %4.4x, resetting.&bslash;n&quot;
comma
id|dev-&gt;name
comma
l_int|0
)paren
suffix:semicolon
id|priv-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
multiline_comment|/* fill in a tx ring entry */
macro_line|#ifdef HYDRA_DEBUG
id|printk
c_func
(paren
l_string|&quot;TX pkt type 0x%04x from &quot;
comma
(paren
(paren
id|u16
op_star
)paren
id|skb-&gt;data
)paren
(braket
l_int|6
)braket
)paren
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
id|u8
op_star
id|ptr
op_assign
op_amp
(paren
(paren
id|u8
op_star
)paren
id|skb-&gt;data
)paren
(braket
l_int|6
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
id|ptr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; to &quot;
)paren
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
id|u8
op_star
id|ptr
op_assign
(paren
id|u8
op_star
)paren
id|skb-&gt;data
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
id|ptr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; data 0x%08x len %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|skb-&gt;data
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * make sure that the packet size is at least the minimum&n;&t; * allowed ethernet packet length.&n;&t; * (FIXME: Should also clear the unused space...)&n;&t; * note: minimum packet length is 64, including CRC&n;&t; */
id|len1
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
(paren
id|ETHER_MIN_LEN
op_minus
l_int|4
)paren
)paren
(brace
id|len
op_assign
(paren
id|ETHER_MIN_LEN
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* make sure we&squot;ve got an even number of bytes to copy to hydra&squot;s mem */
r_if
c_cond
(paren
id|len
op_amp
l_int|1
)paren
(brace
id|len
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|u32
)paren
(paren
id|dev-&gt;mem_start
op_plus
(paren
id|priv-&gt;tx_page_start
op_lshift
l_int|8
)paren
)paren
OL
l_int|0x80000000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;weirdness: memcpyw(txbuf, skbdata, len): txbuf = 0x%x&bslash;n&quot;
comma
(paren
id|u_int
)paren
(paren
id|dev-&gt;mem_start
op_plus
(paren
id|priv-&gt;tx_page_start
op_lshift
l_int|8
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* copy the packet data to the transmit buffer &n;&t;   in the ethernet card RAM */
id|memcpyw
c_func
(paren
(paren
id|u16
op_star
)paren
(paren
id|dev-&gt;mem_start
op_plus
(paren
id|priv-&gt;tx_page_start
op_lshift
l_int|8
)paren
)paren
comma
(paren
id|u16
op_star
)paren
id|skb-&gt;data
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* clear the unused space */
r_for
c_loop
(paren
suffix:semicolon
id|len1
OL
id|len
suffix:semicolon
id|len1
op_increment
)paren
(brace
(paren
id|u16
)paren
op_star
(paren
(paren
id|u8
op_star
)paren
id|dev-&gt;mem_start
op_plus
(paren
id|priv-&gt;tx_page_start
op_lshift
l_int|8
)paren
op_plus
id|len1
)paren
op_assign
l_int|0
suffix:semicolon
)brace
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|priv-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* make sure we are on the correct page */
id|WRITE_REG
c_func
(paren
id|NIC_CR
comma
id|CR_PAGE0
op_or
id|CR_NODMA
op_or
id|CR_START
)paren
suffix:semicolon
multiline_comment|/* here we configure the transmit page start register etc */
multiline_comment|/* notice that this code is hardwired to one transmit buffer */
id|WRITE_REG
c_func
(paren
id|NIC_TPSR
comma
id|priv-&gt;tx_page_start
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_TBCR0
comma
id|len
op_amp
l_int|0xff
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_TBCR1
comma
id|len
op_rshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* commit the packet to the wire */
id|WRITE_REG
c_func
(paren
id|NIC_CR
comma
id|CR_PAGE0
op_or
id|CR_START
op_or
id|CR_NODMA
op_or
id|CR_TXP
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hydra_rx
r_static
r_void
id|__inline__
id|hydra_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|hydra_private
op_star
id|priv
comma
r_volatile
id|u8
op_star
id|nicbase
)paren
(brace
r_volatile
id|u16
op_star
id|board_ram_ptr
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|hdr_next_pkt
comma
id|pkt_len
comma
id|len1
comma
id|boundary
suffix:semicolon
multiline_comment|/* remove packet(s) from the ring and commit them to TCP layer */
id|WRITE_REG
c_func
(paren
id|NIC_CR
comma
id|CR_PAGE1
op_or
id|CR_NODMA
op_or
id|CR_START
)paren
suffix:semicolon
multiline_comment|/* page 1 */
r_while
c_loop
(paren
id|priv-&gt;next_pkt
op_ne
id|READ_REG
c_func
(paren
id|NIC_CURR
)paren
)paren
multiline_comment|/* should read this only once? */
(brace
id|board_ram_ptr
op_assign
(paren
id|u16
op_star
)paren
(paren
id|dev-&gt;mem_start
op_plus
(paren
id|priv-&gt;next_pkt
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
macro_line|#ifdef HYDRA_DEBUG
id|printk
c_func
(paren
l_string|&quot;next_pkt = 0x%x, board_ram_ptr = 0x%x&bslash;n&quot;
comma
id|priv-&gt;next_pkt
comma
id|board_ram_ptr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* the following must be done with two steps, or&n;&t;&t;   GCC optimizes it to a byte access to Hydra memory,&n;&t;&t;   which doesn&squot;t work... */
id|hdr_next_pkt
op_assign
id|board_ram_ptr
(braket
l_int|0
)braket
suffix:semicolon
id|hdr_next_pkt
op_rshift_assign
l_int|8
suffix:semicolon
id|pkt_len
op_assign
id|board_ram_ptr
(braket
l_int|1
)braket
suffix:semicolon
id|pkt_len
op_assign
(paren
(paren
id|pkt_len
op_rshift
l_int|8
)paren
op_or
(paren
(paren
id|pkt_len
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
macro_line|#ifdef HYDRA_DEBUG
id|printk
c_func
(paren
l_string|&quot;hydra_interrupt(): hdr_next_pkt = 0x%02x, len = %d&bslash;n&quot;
comma
id|hdr_next_pkt
comma
id|pkt_len
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|pkt_len
op_ge
id|ETHER_MIN_LEN
op_logical_and
id|pkt_len
op_le
id|ETHER_MAX_LEN
)paren
(brace
multiline_comment|/* note that board_ram_ptr is u16 */
multiline_comment|/* CRC is not included in the packet length */
id|pkt_len
op_sub_assign
l_int|4
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|priv-&gt;stats.rx_dropped
op_increment
suffix:semicolon
)brace
r_else
(brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hdr_next_pkt
OL
id|priv-&gt;next_pkt
op_logical_and
id|hdr_next_pkt
op_ne
id|priv-&gt;rx_page_start
)paren
(brace
multiline_comment|/* here, the packet is wrapped */
id|len1
op_assign
(paren
(paren
id|priv-&gt;rx_page_stop
op_minus
id|priv-&gt;next_pkt
)paren
op_lshift
l_int|8
)paren
op_minus
l_int|4
suffix:semicolon
id|memcpyw
c_func
(paren
(paren
id|u16
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
id|len1
)paren
comma
(paren
id|u16
op_star
)paren
(paren
id|board_ram_ptr
op_plus
l_int|2
)paren
comma
id|len1
)paren
suffix:semicolon
id|memcpyw
c_func
(paren
(paren
id|u16
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
op_minus
id|len1
)paren
comma
(paren
id|u16
op_star
)paren
(paren
id|dev-&gt;mem_start
op_plus
(paren
id|priv-&gt;rx_page_start
op_lshift
l_int|8
)paren
)paren
comma
id|pkt_len
op_minus
id|len1
)paren
suffix:semicolon
macro_line|#ifdef HYDRA_DEBUG
id|printk
c_func
(paren
l_string|&quot;wrapped packet: %d/%d bytes&bslash;n&quot;
comma
id|len1
comma
id|pkt_len
op_minus
id|len1
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* ... here, packet is not wrapped */
r_else
id|memcpyw
c_func
(paren
(paren
id|u16
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
comma
(paren
id|u16
op_star
)paren
(paren
id|board_ram_ptr
op_plus
l_int|2
)paren
comma
id|pkt_len
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|WRITE_REG
c_func
(paren
id|NIC_CR
comma
id|CR_PAGE1
op_or
id|CR_START
op_or
id|CR_NODMA
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;hydra_interrupt(): invalid packet len: %d, NIC_CURR = %02x&bslash;n&quot;
comma
id|pkt_len
comma
id|READ_REG
c_func
(paren
id|NIC_CURR
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;this is the error i kept getting until i switched to 0.9.10. it still doesn&squot;t&n;mean that the bug would have gone away - so be alarmed. the packet is likely&n;being fetched from a wrong memory location - but why - dunno&n;   &n;note-for-v2.1: not really problem anymore. hasn&squot;t been for a long time.&n;*/
id|WRITE_REG
c_func
(paren
id|NIC_CR
comma
id|CR_PAGE0
op_or
id|CR_START
op_or
id|CR_NODMA
)paren
suffix:semicolon
multiline_comment|/* should probably reset the NIC here ?? */
id|hydra_open
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* FIXME - i shouldn&squot;t really be doing this. */
r_return
suffix:semicolon
)brace
multiline_comment|/* now, update the next_pkt pointer */
r_if
c_cond
(paren
id|hdr_next_pkt
OL
id|priv-&gt;rx_page_stop
)paren
(brace
id|priv-&gt;next_pkt
op_assign
id|hdr_next_pkt
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;hydra_interrupt(): invalid next_pkt pointer %d&bslash;n&quot;
comma
id|hdr_next_pkt
)paren
suffix:semicolon
multiline_comment|/* update the boundary pointer */
id|boundary
op_assign
id|priv-&gt;next_pkt
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|boundary
OL
id|priv-&gt;rx_page_start
)paren
(brace
id|boundary
op_assign
id|priv-&gt;rx_page_stop
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* set NIC to page 0 to update the NIC_BNDRY register */
id|WRITE_REG
c_func
(paren
id|NIC_CR
comma
id|CR_PAGE0
op_or
id|CR_START
op_or
id|CR_NODMA
)paren
suffix:semicolon
id|WRITE_REG
c_func
(paren
id|NIC_BNDRY
comma
id|boundary
)paren
suffix:semicolon
multiline_comment|/* select page1 to access the NIC_CURR register */
id|WRITE_REG
c_func
(paren
id|NIC_CR
comma
id|CR_PAGE1
op_or
id|CR_START
op_or
id|CR_NODMA
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|priv-&gt;stats.rx_packets
op_increment
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|hydra_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|hydra_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|hydra_private
op_star
id|priv
op_assign
(paren
r_struct
id|hydra_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
macro_line|#if 0
id|u8
op_star
id|board
op_assign
(paren
id|u8
op_star
)paren
id|dev-&gt;mem_start
suffix:semicolon
r_int
id|saved_addr
suffix:semicolon
macro_line|#endif
multiline_comment|/* currently does nothing :) i&squot;ll finish this later */
r_return
op_amp
id|priv-&gt;stats
suffix:semicolon
)brace
macro_line|#ifdef HAVE_MULTICAST
DECL|function|set_multicast_list
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|num_addrs
comma
r_void
op_star
id|addrs
)paren
(brace
r_struct
id|hydra_private
op_star
id|priv
op_assign
(paren
r_struct
id|hydra_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u8
op_star
id|board
op_assign
(paren
id|u8
op_star
)paren
id|dev-&gt;mem_start
suffix:semicolon
multiline_comment|/* yes, this code is also waiting for someone to complete.. :) */
multiline_comment|/* (personally i don&squot;t care about multicasts at all :) */
r_return
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef MODULE
DECL|variable|devicename
r_static
r_char
id|devicename
(braket
l_int|9
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|hydra_dev
r_static
r_struct
id|net_device
id|hydra_dev
op_assign
(brace
id|devicename
comma
multiline_comment|/* filled in by register_netdev() */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* memory */
l_int|0
comma
l_int|0
comma
multiline_comment|/* base, irq */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|hydra_probe
comma
)brace
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|register_netdev
c_func
(paren
op_amp
id|hydra_dev
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EIO
)paren
id|printk
c_func
(paren
l_string|&quot;No Hydra board found. Module not loaded.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|hydra_private
op_star
id|priv
op_assign
(paren
r_struct
id|hydra_private
op_star
)paren
id|hydra_dev.priv
suffix:semicolon
id|unregister_netdev
c_func
(paren
op_amp
id|hydra_dev
)paren
suffix:semicolon
id|release_mem_region
c_func
(paren
id|ZTWO_PADDR
c_func
(paren
id|hydra_dev.base_addr
)paren
comma
l_int|0x20
)paren
suffix:semicolon
id|release_mem_region
c_func
(paren
id|ZTWO_PADDR
c_func
(paren
id|hydra_dev.mem_start
)paren
comma
l_int|0x4000
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|priv
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
