multiline_comment|/* mac_ns8390.c: A Macintosh 8390 based ethernet driver for linux. */
multiline_comment|/*&n;&t;Derived from code:&n;&t;&n;&t;Written 1993-94 by Donald Becker.&n;&n;&t;Copyright 1993 United States Government as represented by the&n;&t;Director, National Security Agency.&n;&n;&t;This software may be used and distributed according to the terms&n;&t;of the GNU Public License, incorporated herein by reference.&n;&n;&t;    TODO:&n;&n;&t;    The block output routines may be wrong for non Dayna&n;&t;    cards&n;&n;&t;    Reading MAC addresses&n;*/
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;mac_ns8390.c:v0.01 7/5/97 Alan Cox (Alan.Cox@linux.org)&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/nubus.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &quot;8390.h&quot;
r_int
id|ns8390_probe1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|word16
comma
r_char
op_star
id|name
comma
r_int
id|id
comma
r_int
id|prom
)paren
suffix:semicolon
r_static
r_int
id|ns8390_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|ns8390_no_reset
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|ns8390_close_card
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|interlan_reset
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|dayna_get_8390_hdr
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|e8390_pkt_hdr
op_star
id|hdr
comma
r_int
id|ring_page
)paren
suffix:semicolon
r_static
r_void
id|dayna_block_input
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|count
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|ring_offset
)paren
suffix:semicolon
r_static
r_void
id|dayna_block_output
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|count
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_const
id|start_page
)paren
suffix:semicolon
r_static
r_void
id|sane_get_8390_hdr
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|e8390_pkt_hdr
op_star
id|hdr
comma
r_int
id|ring_page
)paren
suffix:semicolon
r_static
r_void
id|sane_block_input
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|count
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|ring_offset
)paren
suffix:semicolon
r_static
r_void
id|sane_block_output
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|count
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_const
id|start_page
)paren
suffix:semicolon
"&f;"
DECL|macro|WD_START_PG
mdefine_line|#define WD_START_PG&t;0x00&t;/* First page of TX buffer */
DECL|macro|WD03_STOP_PG
mdefine_line|#define WD03_STOP_PG&t;0x20&t;/* Last page +1 of RX ring */
DECL|macro|WD13_STOP_PG
mdefine_line|#define WD13_STOP_PG&t;0x40&t;/* Last page +1 of RX ring */
DECL|macro|DAYNA_MAC_BASE
mdefine_line|#define DAYNA_MAC_BASE&t;&t;0xf0007
DECL|macro|DAYNA_8390_BASE
mdefine_line|#define DAYNA_8390_BASE&t;&t;0x80000 /* 3 */
DECL|macro|DAYNA_8390_MEM
mdefine_line|#define DAYNA_8390_MEM&t;&t;0x00000
DECL|macro|DAYNA_MEMSIZE
mdefine_line|#define DAYNA_MEMSIZE&t;&t;0x04000&t;/* First word of each long ! */
DECL|macro|APPLE_8390_BASE
mdefine_line|#define APPLE_8390_BASE&t;&t;0xE0000
DECL|macro|APPLE_8390_MEM
mdefine_line|#define APPLE_8390_MEM&t;&t;0xD0000
DECL|macro|APPLE_MEMSIZE
mdefine_line|#define APPLE_MEMSIZE&t;&t;8192    /* FIXME: need to dynamically check */
DECL|macro|KINETICS_8390_BASE
mdefine_line|#define KINETICS_8390_BASE&t;0x80003
DECL|macro|KINETICS_8390_MEM
mdefine_line|#define KINETICS_8390_MEM&t;0x00000
DECL|macro|KINETICS_MEMSIZE
mdefine_line|#define KINETICS_MEMSIZE&t;8192    /* FIXME: need to dynamically check */
DECL|function|test_8390
r_static
r_int
id|test_8390
c_func
(paren
r_volatile
r_char
op_star
id|ptr
comma
r_int
id|scale
)paren
(brace
r_int
id|regd
suffix:semicolon
r_int
id|v
suffix:semicolon
r_if
c_cond
(paren
id|nubus_hwreg_present
c_func
(paren
op_amp
id|ptr
(braket
l_int|0x00
)braket
)paren
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nubus_hwreg_present
c_func
(paren
op_amp
id|ptr
(braket
l_int|0x0D
op_lshift
id|scale
)braket
)paren
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nubus_hwreg_present
c_func
(paren
op_amp
id|ptr
(braket
l_int|0x0D
op_lshift
id|scale
)braket
)paren
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|ptr
(braket
l_int|0x00
)braket
op_assign
id|E8390_NODMA
op_plus
id|E8390_PAGE1
op_plus
id|E8390_STOP
suffix:semicolon
id|regd
op_assign
id|ptr
(braket
l_int|0x0D
op_lshift
id|scale
)braket
suffix:semicolon
id|ptr
(braket
l_int|0x0D
op_lshift
id|scale
)braket
op_assign
l_int|0xFF
suffix:semicolon
id|ptr
(braket
l_int|0x00
)braket
op_assign
id|E8390_NODMA
op_plus
id|E8390_PAGE0
suffix:semicolon
id|v
op_assign
id|ptr
(braket
l_int|0x0D
op_lshift
id|scale
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ptr
(braket
l_int|0x0D
op_lshift
id|scale
)braket
op_ne
l_int|0
)paren
(brace
id|ptr
(braket
l_int|0x0D
op_lshift
id|scale
)braket
op_assign
id|regd
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&t;printk(&quot;NS8390 found at %p scaled %d&bslash;n&quot;, ptr,scale);*/
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *    Identify the species of NS8390 card/driver we need&n; */
DECL|macro|NS8390_DAYNA
mdefine_line|#define NS8390_DAYNA&t;&t;1
DECL|macro|NS8390_INTERLAN
mdefine_line|#define NS8390_INTERLAN&t;&t;2
DECL|macro|NS8390_KINETICS
mdefine_line|#define NS8390_KINETICS&t;&t;3
DECL|macro|NS8390_APPLE
mdefine_line|#define NS8390_APPLE&t;&t;4
DECL|macro|NS8390_FARALLON
mdefine_line|#define NS8390_FARALLON&t;&t;5
DECL|macro|NS8390_ASANTE
mdefine_line|#define NS8390_ASANTE&t;&t;6
DECL|function|ns8390_ident
r_int
id|ns8390_ident
c_func
(paren
r_struct
id|nubus_type
op_star
id|nb
)paren
(brace
multiline_comment|/* It appears anything with a software type of 0 is an apple&n;&t;   compatible - even if the hardware matches others */
r_if
c_cond
(paren
id|nb-&gt;DrSW
op_eq
l_int|0x0001
op_logical_or
id|nb-&gt;DrSW
op_eq
l_int|0x0109
op_logical_or
id|nb-&gt;DrSW
op_eq
l_int|0x0000
op_logical_or
id|nb-&gt;DrSW
op_eq
l_int|0x0100
)paren
(brace
r_return
id|NS8390_APPLE
suffix:semicolon
)brace
multiline_comment|/* Dayna ex Kinetics board */
r_if
c_cond
(paren
id|nb-&gt;DrHW
op_eq
l_int|0x0103
)paren
(brace
r_return
id|NS8390_DAYNA
suffix:semicolon
)brace
multiline_comment|/* Asante board */
r_if
c_cond
(paren
id|nb-&gt;DrHW
op_eq
l_int|0x0104
)paren
(brace
r_return
id|NS8390_ASANTE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nb-&gt;DrHW
op_eq
l_int|0x0100
)paren
(brace
r_return
id|NS8390_INTERLAN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nb-&gt;DrHW
op_eq
l_int|0x0106
)paren
(brace
r_return
id|NS8390_KINETICS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nb-&gt;DrSW
op_eq
l_int|0x010C
)paren
(brace
r_return
id|NS8390_FARALLON
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *    Probe for 8390 cards.  &n; *    The ns8390_probe1() routine initializes the card and fills the&n; *    station address field. On entry base_addr is set, irq is set&n; *    (These come from the nubus probe code). dev-&gt;mem_start points&n; *    at the memory ring, dev-&gt;mem_end gives the end of it.&n; */
DECL|function|ns8390_probe
r_int
id|ns8390_probe
c_func
(paren
r_struct
id|nubus_device_specifier
op_star
id|d
comma
r_int
id|slot
comma
r_struct
id|nubus_type
op_star
id|match
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_volatile
r_int
r_int
op_star
id|i
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
id|plen
suffix:semicolon
r_int
id|id
suffix:semicolon
r_if
c_cond
(paren
id|match-&gt;category
op_ne
id|NUBUS_CAT_NETWORK
op_logical_or
id|match-&gt;type
op_ne
l_int|1
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* Ok so it is an ethernet network device */
r_if
c_cond
(paren
(paren
id|id
op_assign
id|ns8390_ident
c_func
(paren
id|match
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Ethernet but type unknown %d&bslash;n&quot;
comma
id|match-&gt;DrHW
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|dev
op_assign
id|init_etherdev
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Dayna specific init&n;&t; */
r_if
c_cond
(paren
id|id
op_eq
id|NS8390_DAYNA
)paren
(brace
id|dev-&gt;base_addr
op_assign
(paren
r_int
)paren
(paren
id|nubus_slot_addr
c_func
(paren
id|slot
)paren
op_plus
id|DAYNA_8390_BASE
)paren
suffix:semicolon
id|dev-&gt;mem_start
op_assign
(paren
r_int
)paren
(paren
id|nubus_slot_addr
c_func
(paren
id|slot
)paren
op_plus
id|DAYNA_8390_MEM
)paren
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|dev-&gt;mem_start
op_plus
id|DAYNA_MEMSIZE
suffix:semicolon
multiline_comment|/* 8K it seems */
id|printk
c_func
(paren
l_string|&quot;daynaport: testing board: &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;memory - &quot;
)paren
suffix:semicolon
id|i
op_assign
(paren
r_void
op_star
)paren
id|dev-&gt;mem_start
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|i
comma
l_int|0xAA
comma
id|DAYNA_MEMSIZE
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
(paren
r_volatile
r_int
r_int
op_star
)paren
id|dev-&gt;mem_end
)paren
(brace
r_if
c_cond
(paren
op_star
id|i
op_ne
l_int|0xAAAA
)paren
(brace
r_goto
id|membad
suffix:semicolon
)brace
op_star
id|i
op_assign
l_int|0x5555
suffix:semicolon
r_if
c_cond
(paren
op_star
id|i
op_ne
l_int|0x5555
)paren
(brace
r_goto
id|membad
suffix:semicolon
)brace
id|i
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* Skip a word */
)brace
id|printk
c_func
(paren
l_string|&quot;controller - &quot;
)paren
suffix:semicolon
id|p
op_assign
(paren
r_void
op_star
)paren
id|dev-&gt;base_addr
suffix:semicolon
id|plen
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|plen
OL
l_int|0x3FF00
)paren
(brace
r_if
c_cond
(paren
id|test_8390
c_func
(paren
id|p
comma
l_int|0
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_8390
c_func
(paren
id|p
comma
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_8390
c_func
(paren
id|p
comma
l_int|2
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_8390
c_func
(paren
id|p
comma
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|plen
op_increment
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|plen
op_eq
l_int|0x3FF00
)paren
(brace
r_goto
id|membad
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;OK&bslash;n&quot;
)paren
suffix:semicolon
id|dev-&gt;irq
op_assign
id|slot
suffix:semicolon
r_if
c_cond
(paren
id|ns8390_probe1
c_func
(paren
id|dev
comma
l_int|0
comma
l_string|&quot;dayna&quot;
comma
id|id
comma
op_minus
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Apple, Farallon, Asante */
r_if
c_cond
(paren
id|id
op_eq
id|NS8390_APPLE
op_logical_or
id|id
op_eq
id|NS8390_FARALLON
op_logical_or
id|id
op_eq
id|NS8390_ASANTE
)paren
(brace
id|dev-&gt;base_addr
op_assign
(paren
r_int
)paren
(paren
id|nubus_slot_addr
c_func
(paren
id|slot
)paren
op_plus
id|APPLE_8390_BASE
)paren
suffix:semicolon
id|dev-&gt;mem_start
op_assign
(paren
r_int
)paren
(paren
id|nubus_slot_addr
c_func
(paren
id|slot
)paren
op_plus
id|APPLE_8390_MEM
)paren
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|dev-&gt;mem_start
op_plus
id|APPLE_MEMSIZE
suffix:semicolon
multiline_comment|/* 8K it seems */
id|dev-&gt;irq
op_assign
id|slot
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;apple/clone: testing board: &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;memory - &quot;
)paren
suffix:semicolon
id|i
op_assign
(paren
r_void
op_star
)paren
id|dev-&gt;mem_start
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|i
comma
l_int|0xAA
comma
id|DAYNA_MEMSIZE
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
(paren
r_volatile
r_int
r_int
op_star
)paren
id|dev-&gt;mem_end
)paren
(brace
r_if
c_cond
(paren
op_star
id|i
op_ne
l_int|0xAAAA
)paren
(brace
r_goto
id|membad
suffix:semicolon
)brace
op_star
id|i
op_assign
l_int|0x5555
suffix:semicolon
r_if
c_cond
(paren
op_star
id|i
op_ne
l_int|0x5555
)paren
(brace
r_goto
id|membad
suffix:semicolon
)brace
id|i
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* Skip a word */
)brace
id|printk
c_func
(paren
l_string|&quot;OK&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
id|NS8390_FARALLON
)paren
(brace
r_if
c_cond
(paren
id|ns8390_probe1
c_func
(paren
id|dev
comma
l_int|1
comma
l_string|&quot;farallon&quot;
comma
id|id
comma
op_minus
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|ns8390_probe1
c_func
(paren
id|dev
comma
l_int|1
comma
l_string|&quot;apple/clone&quot;
comma
id|id
comma
op_minus
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Interlan */
r_if
c_cond
(paren
id|id
op_eq
id|NS8390_INTERLAN
)paren
(brace
multiline_comment|/* As apple and asante */
id|dev-&gt;base_addr
op_assign
(paren
r_int
)paren
(paren
id|nubus_slot_addr
c_func
(paren
id|slot
)paren
op_plus
id|APPLE_8390_BASE
)paren
suffix:semicolon
id|dev-&gt;mem_start
op_assign
(paren
r_int
)paren
(paren
id|nubus_slot_addr
c_func
(paren
id|slot
)paren
op_plus
id|APPLE_8390_MEM
)paren
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|dev-&gt;mem_start
op_plus
id|APPLE_MEMSIZE
suffix:semicolon
multiline_comment|/* 8K it seems */
id|dev-&gt;irq
op_assign
id|slot
suffix:semicolon
r_if
c_cond
(paren
id|ns8390_probe1
c_func
(paren
id|dev
comma
l_int|1
comma
l_string|&quot;interlan&quot;
comma
id|id
comma
op_minus
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Kinetics */
r_if
c_cond
(paren
id|id
op_eq
id|NS8390_KINETICS
)paren
(brace
id|dev-&gt;base_addr
op_assign
(paren
r_int
)paren
(paren
id|nubus_slot_addr
c_func
(paren
id|slot
)paren
op_plus
id|KINETICS_8390_BASE
)paren
suffix:semicolon
id|dev-&gt;mem_start
op_assign
(paren
r_int
)paren
(paren
id|nubus_slot_addr
c_func
(paren
id|slot
)paren
op_plus
id|KINETICS_8390_MEM
)paren
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|dev-&gt;mem_start
op_plus
id|KINETICS_MEMSIZE
suffix:semicolon
multiline_comment|/* 8K it seems */
id|dev-&gt;irq
op_assign
id|slot
suffix:semicolon
r_if
c_cond
(paren
id|ns8390_probe1
c_func
(paren
id|dev
comma
l_int|0
comma
l_string|&quot;kinetics&quot;
comma
id|id
comma
op_minus
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
id|membad
suffix:colon
id|printk
c_func
(paren
l_string|&quot;failed.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|ns8390_probe1
r_int
id|ns8390_probe1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|word16
comma
r_char
op_star
id|model_name
comma
r_int
id|type
comma
r_int
id|promoff
)paren
(brace
r_static
r_int
id|version_printed
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|fwrd4_offsets
(braket
l_int|16
)braket
op_assign
initialization_block
suffix:semicolon
r_static
r_int
id|back4_offsets
(braket
l_int|16
)braket
op_assign
initialization_block
suffix:semicolon
r_int
r_char
op_star
id|prom
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|nubus_slot_addr
c_func
(paren
id|dev-&gt;irq
)paren
)paren
op_plus
id|promoff
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
op_logical_and
id|version_printed
op_increment
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
multiline_comment|/* Snarf the interrupt now.  There&squot;s no point in waiting since we cannot&n;&t;   share a slot! and the board will usually be enabled. */
r_if
c_cond
(paren
id|nubus_request_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
comma
id|ei_interrupt
)paren
)paren
(brace
id|printk
(paren
l_string|&quot; unable to get nubus IRQ %d.&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* Allocate dev-&gt;priv and fill in 8390 specific dev fields. */
r_if
c_cond
(paren
id|ethdev_init
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
(paren
l_string|&quot; unable to get memory for dev-&gt;priv.&bslash;n&quot;
)paren
suffix:semicolon
id|nubus_free_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* OK, we are certain this is going to work.  Setup the device. */
id|ei_status.name
op_assign
id|model_name
suffix:semicolon
id|ei_status.word16
op_assign
id|word16
suffix:semicolon
id|ei_status.tx_start_page
op_assign
id|WD_START_PG
suffix:semicolon
id|ei_status.rx_start_page
op_assign
id|WD_START_PG
op_plus
id|TX_PAGES
suffix:semicolon
id|dev-&gt;rmem_start
op_assign
id|dev-&gt;mem_start
op_plus
id|TX_PAGES
op_star
l_int|256
suffix:semicolon
id|ei_status.stop_page
op_assign
(paren
id|dev-&gt;mem_end
op_minus
id|dev-&gt;mem_start
)paren
op_div
l_int|256
suffix:semicolon
id|dev-&gt;rmem_end
op_assign
id|dev-&gt;mem_end
suffix:semicolon
r_if
c_cond
(paren
id|promoff
op_eq
op_minus
l_int|1
)paren
multiline_comment|/* Use nubus resources ? */
(brace
r_if
c_cond
(paren
id|nubus_ethernet_addr
c_func
(paren
id|dev-&gt;irq
multiline_comment|/* slot */
comma
id|dev-&gt;dev_addr
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mac_ns8390: MAC address not in resources!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* Pull it off the card */
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|x
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* These should go in the end I hope */
r_if
c_cond
(paren
id|type
op_eq
id|NS8390_DAYNA
)paren
(brace
id|x
op_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_eq
id|NS8390_INTERLAN
)paren
(brace
id|x
op_assign
l_int|4
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OL
l_int|6
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
op_star
id|prom
suffix:semicolon
id|prom
op_add_assign
id|x
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;:&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%02X&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
op_increment
)braket
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot; %s, IRQ %d, shared memory at %#lx-%#lx.&bslash;n&quot;
comma
id|model_name
comma
id|dev-&gt;irq
comma
id|dev-&gt;mem_start
comma
id|dev-&gt;mem_end
op_minus
l_int|1
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|NS8390_DAYNA
suffix:colon
multiline_comment|/* Dayna card */
multiline_comment|/* 16 bit, 4 word offsets */
id|ei_status.reset_8390
op_assign
op_amp
id|ns8390_no_reset
suffix:semicolon
id|ei_status.block_input
op_assign
op_amp
id|dayna_block_input
suffix:semicolon
id|ei_status.block_output
op_assign
op_amp
id|dayna_block_output
suffix:semicolon
id|ei_status.get_8390_hdr
op_assign
op_amp
id|dayna_get_8390_hdr
suffix:semicolon
id|ei_status.reg_offset
op_assign
id|fwrd4_offsets
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS8390_APPLE
suffix:colon
multiline_comment|/* Apple/Asante/Farallon */
r_case
id|NS8390_FARALLON
suffix:colon
r_case
id|NS8390_ASANTE
suffix:colon
multiline_comment|/*      16 bit card, register map is reversed */
id|ei_status.reset_8390
op_assign
op_amp
id|ns8390_no_reset
suffix:semicolon
id|ei_status.block_input
op_assign
op_amp
id|sane_block_input
suffix:semicolon
id|ei_status.block_output
op_assign
op_amp
id|sane_block_output
suffix:semicolon
id|ei_status.get_8390_hdr
op_assign
op_amp
id|sane_get_8390_hdr
suffix:semicolon
id|ei_status.reg_offset
op_assign
id|back4_offsets
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS8390_INTERLAN
suffix:colon
multiline_comment|/* Interlan */
multiline_comment|/*      16 bit card, map is forward */
id|ei_status.reset_8390
op_assign
op_amp
id|interlan_reset
suffix:semicolon
id|ei_status.block_input
op_assign
op_amp
id|sane_block_input
suffix:semicolon
id|ei_status.block_output
op_assign
op_amp
id|sane_block_output
suffix:semicolon
id|ei_status.get_8390_hdr
op_assign
op_amp
id|sane_get_8390_hdr
suffix:semicolon
id|ei_status.reg_offset
op_assign
id|back4_offsets
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NS8390_KINETICS
suffix:colon
multiline_comment|/* Kinetics */
multiline_comment|/*      8bit card, map is forward */
id|ei_status.reset_8390
op_assign
op_amp
id|ns8390_no_reset
suffix:semicolon
id|ei_status.block_input
op_assign
op_amp
id|sane_block_input
suffix:semicolon
id|ei_status.block_output
op_assign
op_amp
id|sane_block_output
suffix:semicolon
id|ei_status.get_8390_hdr
op_assign
op_amp
id|sane_get_8390_hdr
suffix:semicolon
id|ei_status.reg_offset
op_assign
id|back4_offsets
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;Detected a card I can&squot;t drive - whoops&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|dev-&gt;open
op_assign
op_amp
id|ns8390_open
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|ns8390_close_card
suffix:semicolon
id|NS8390_init
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ns8390_open
r_static
r_int
id|ns8390_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|ei_open
c_func
(paren
id|dev
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ns8390_no_reset
r_static
r_void
id|ns8390_no_reset
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|ei_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;Need to reset the NS8390 t=%lu...&quot;
comma
id|jiffies
)paren
suffix:semicolon
id|ei_status.txing
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;reset not supported&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|ns8390_close_card
r_static
r_int
id|ns8390_close_card
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|ei_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Shutting down ethercard.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|ei_close
c_func
(paren
id|dev
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|nubus_8390
r_struct
id|nubus_device_specifier
id|nubus_8390
op_assign
initialization_block
suffix:semicolon
multiline_comment|/*&n; *    Interlan Specific Code Starts Here&n; */
DECL|function|interlan_reset
r_static
r_void
id|interlan_reset
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
r_char
op_star
id|target
op_assign
id|nubus_slot_addr
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;Need to reset the NS8390 t=%lu...&quot;
comma
id|jiffies
)paren
suffix:semicolon
id|ei_status.txing
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This write resets the card */
id|target
(braket
l_int|0xC0000
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ei_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;reset complete&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *    Daynaport code (some is used by other drivers)&n; */
multiline_comment|/* Grab the 8390 specific header. Similar to the block_input routine, but&n;   we don&squot;t need to be concerned with ring wrap as the header will be at&n;   the start of a page, so we optimize accordingly. */
multiline_comment|/* Block input and output are easy on shared memory ethercards, and trivial&n;   on the Daynaport card where there is no choice of how to do it.&n;   The only complications are that the ring buffer wraps.&n;*/
DECL|function|dayna_cpu_memcpy
r_static
r_void
id|dayna_cpu_memcpy
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|to
comma
r_int
id|from
comma
r_int
id|count
)paren
(brace
r_volatile
r_int
r_int
op_star
id|ptr
suffix:semicolon
r_int
r_int
op_star
id|target
op_assign
id|to
suffix:semicolon
id|from
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* word, skip overhead */
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|dev-&gt;mem_start
op_plus
id|from
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
op_ge
l_int|2
)paren
(brace
op_star
id|target
op_increment
op_assign
op_star
id|ptr
op_increment
suffix:semicolon
multiline_comment|/* Copy and */
id|ptr
op_increment
suffix:semicolon
multiline_comment|/* Cruft and */
id|count
op_sub_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Trailing byte ?&n;&t; */
r_if
c_cond
(paren
id|count
)paren
(brace
multiline_comment|/* Big endian */
r_int
r_int
id|v
op_assign
op_star
id|ptr
suffix:semicolon
op_star
(paren
(paren
r_char
op_star
)paren
id|target
)paren
op_assign
id|v
op_rshift
l_int|8
suffix:semicolon
)brace
)brace
DECL|function|cpu_dayna_memcpy
r_static
r_void
id|cpu_dayna_memcpy
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
id|count
)paren
(brace
r_volatile
r_int
r_int
op_star
id|ptr
suffix:semicolon
r_const
r_int
r_int
op_star
id|src
op_assign
id|from
suffix:semicolon
id|to
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* word, skip overhead */
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|dev-&gt;mem_start
op_plus
id|to
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
op_ge
l_int|2
)paren
(brace
op_star
id|ptr
op_increment
op_assign
op_star
id|src
op_increment
suffix:semicolon
multiline_comment|/* Copy and */
id|ptr
op_increment
suffix:semicolon
multiline_comment|/* Cruft and */
id|count
op_sub_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Trailing byte ?&n;&t; */
r_if
c_cond
(paren
id|count
)paren
(brace
multiline_comment|/* Big endian */
r_int
r_int
id|v
op_assign
op_star
id|src
suffix:semicolon
op_star
(paren
(paren
r_char
op_star
)paren
id|ptr
)paren
op_assign
id|v
op_rshift
l_int|8
suffix:semicolon
)brace
)brace
DECL|function|dayna_get_8390_hdr
r_static
r_void
id|dayna_get_8390_hdr
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|e8390_pkt_hdr
op_star
id|hdr
comma
r_int
id|ring_page
)paren
(brace
r_int
r_int
id|hdr_start
op_assign
(paren
id|ring_page
op_minus
id|WD_START_PG
)paren
op_lshift
l_int|8
suffix:semicolon
id|dayna_cpu_memcpy
c_func
(paren
id|dev
comma
(paren
r_void
op_star
)paren
id|hdr
comma
id|hdr_start
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Register endianism - fix here rather than 8390.c */
id|hdr-&gt;count
op_assign
(paren
id|hdr-&gt;count
op_amp
l_int|0xFF
)paren
op_lshift
l_int|8
op_or
(paren
id|hdr-&gt;count
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
DECL|function|dayna_block_input
r_static
r_void
id|dayna_block_input
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|count
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|ring_offset
)paren
(brace
r_int
r_int
id|xfer_base
op_assign
id|ring_offset
op_minus
(paren
id|WD_START_PG
op_lshift
l_int|8
)paren
suffix:semicolon
r_int
r_int
id|xfer_start
op_assign
id|xfer_base
op_plus
id|dev-&gt;mem_start
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Note the offset maths is done in card memory space which&n;&t; *&t;is word per long onto our space.&n;&t; */
r_if
c_cond
(paren
id|xfer_start
op_plus
id|count
OG
id|dev-&gt;rmem_end
)paren
(brace
multiline_comment|/* We must wrap the input move. */
r_int
id|semi_count
op_assign
id|dev-&gt;rmem_end
op_minus
id|xfer_start
suffix:semicolon
id|dayna_cpu_memcpy
c_func
(paren
id|dev
comma
id|skb-&gt;data
comma
id|xfer_base
comma
id|semi_count
)paren
suffix:semicolon
id|count
op_sub_assign
id|semi_count
suffix:semicolon
id|dayna_cpu_memcpy
c_func
(paren
id|dev
comma
id|skb-&gt;data
op_plus
id|semi_count
comma
id|dev-&gt;rmem_start
op_minus
id|dev-&gt;mem_start
comma
id|count
)paren
suffix:semicolon
)brace
r_else
(brace
id|dayna_cpu_memcpy
c_func
(paren
id|dev
comma
id|skb-&gt;data
comma
id|xfer_base
comma
id|count
)paren
suffix:semicolon
)brace
)brace
DECL|function|dayna_block_output
r_static
r_void
id|dayna_block_output
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|count
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|start_page
)paren
(brace
r_int
id|shmem
op_assign
(paren
id|start_page
op_minus
id|WD_START_PG
)paren
op_lshift
l_int|8
suffix:semicolon
id|cpu_dayna_memcpy
c_func
(paren
id|dev
comma
id|shmem
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Cards with full width memory&n; */
DECL|function|sane_get_8390_hdr
r_static
r_void
id|sane_get_8390_hdr
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|e8390_pkt_hdr
op_star
id|hdr
comma
r_int
id|ring_page
)paren
(brace
r_int
r_int
id|hdr_start
op_assign
(paren
id|ring_page
op_minus
id|WD_START_PG
)paren
op_lshift
l_int|8
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|hdr
comma
(paren
r_char
op_star
)paren
id|dev-&gt;mem_start
op_plus
id|hdr_start
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Register endianism - fix here rather than 8390.c */
id|hdr-&gt;count
op_assign
(paren
id|hdr-&gt;count
op_amp
l_int|0xFF
)paren
op_lshift
l_int|8
op_or
(paren
id|hdr-&gt;count
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
DECL|function|sane_block_input
r_static
r_void
id|sane_block_input
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|count
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|ring_offset
)paren
(brace
r_int
r_int
id|xfer_base
op_assign
id|ring_offset
op_minus
(paren
id|WD_START_PG
op_lshift
l_int|8
)paren
suffix:semicolon
r_int
r_int
id|xfer_start
op_assign
id|xfer_base
op_plus
id|dev-&gt;mem_start
suffix:semicolon
r_if
c_cond
(paren
id|xfer_start
op_plus
id|count
OG
id|dev-&gt;rmem_end
)paren
(brace
multiline_comment|/* We must wrap the input move. */
r_int
id|semi_count
op_assign
id|dev-&gt;rmem_end
op_minus
id|xfer_start
suffix:semicolon
id|memcpy
c_func
(paren
id|skb-&gt;data
comma
(paren
r_char
op_star
)paren
id|dev-&gt;mem_start
op_plus
id|xfer_base
comma
id|semi_count
)paren
suffix:semicolon
id|count
op_sub_assign
id|semi_count
suffix:semicolon
id|memcpy
c_func
(paren
id|skb-&gt;data
op_plus
id|semi_count
comma
(paren
r_char
op_star
)paren
id|dev-&gt;rmem_start
comma
id|count
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|skb-&gt;data
comma
(paren
r_char
op_star
)paren
id|dev-&gt;mem_start
op_plus
id|xfer_base
comma
id|count
)paren
suffix:semicolon
)brace
)brace
DECL|function|sane_block_output
r_static
r_void
id|sane_block_output
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|count
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|start_page
)paren
(brace
r_int
id|shmem
op_assign
(paren
id|start_page
op_minus
id|WD_START_PG
)paren
op_lshift
l_int|8
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|dev-&gt;mem_start
op_plus
id|shmem
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -D__KERNEL__ -I/usr/src/linux/net/inet -Wall -Wstrict-prototypes -O6 -m486 -c daynaport.c&quot;&n; *  version-control: t&n; *  tab-width: 4&n; *  kept-new-versions: 5&n; * End:&n; */
eof
