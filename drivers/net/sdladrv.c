multiline_comment|/*****************************************************************************&n;* sdladrv.c&t;SDLA Support Module.  Main module.&n;*&n;*&t;&t;This module is a library of common hardware-specific functions&n;*&t;&t;used by all Sangoma drivers.&n;*&n;* Author:&t;Gene Kozin&t;&lt;genek@compuserve.com&gt;&n;*&n;* Copyright:&t;(c) 1995-1996 Sangoma Technologies Inc.&n;*&n;*&t;&t;This program is free software; you can redistribute it and/or&n;*&t;&t;modify it under the terms of the GNU General Public License&n;*&t;&t;as published by the Free Software Foundation; either version&n;*&t;&t;2 of the License, or (at your option) any later version.&n;* ============================================================================&n;* May 19, 1999&t;Arnaldo Melo&t;wanpipe_init belongs to sdlamain.c&n;* Dec 20, 1996&t;Gene Kozin&t;Version 3.0.0. Complete overhaul.&n;* Jul 12, 1996&t;Gene Kozin&t;Changes for Linux 2.0 compatibility.&n;* Jun 12, 1996&t;Gene Kozin &t;Added support for S503 card.&n;* Apr 30, 1996&t;Gene Kozin&t;SDLA hardware interrupt is acknowledged before&n;*&t;&t;&t;&t;calling protocolspecific ISR.&n;*&t;&t;&t;&t;Register I/O ports with Linux kernel.&n;*&t;&t;&t;&t;Miscellaneous bug fixes.&n;* Dec 20, 1995&t;Gene Kozin&t;Fixed a bug in interrupt routine.&n;* Oct 14, 1995&t;Gene Kozin&t;Initial version.&n;*****************************************************************************/
multiline_comment|/*****************************************************************************&n; * Notes:&n; * ------&n; * 1. This code is ment to be system-independent (as much as possible).  To&n; *    achive this, various macros are used to hide system-specific interfaces.&n; *    To compile this code, one of the following constants must be defined:&n; *&n; *&t;Platform&t;Define&n; *&t;--------&t;------&n; *&t;Linux&t;&t;_LINUX_&n; *&t;SCO Unix&t;_SCO_UNIX_&n; *&n; * 2. Supported adapter types:&n; *&n; *&t;S502A&n; *&t;ES502A (S502E)&n; *&t;S503&n; *&t;S507&n; *&t;S508 (S509)&n; *&n; * 3. S502A Notes:&n; *&n; *&t;There is no separate DPM window enable/disable control in S502A.  It&n; *&t;opens immediately after a window number it written to the HMCR&n; *&t;register.  To close the window, HMCR has to be written a value&n; *&t;????1111b (e.g. 0x0F or 0xFF).&n; *&n; *&t;S502A DPM window cannot be located at offset E000 (e.g. 0xAE000).&n; *&n; *&t;There should be a delay of ??? before reading back S502A status&n; *&t;register.&n; *&n; * 4. S502E Notes:&n; *&n; *&t;S502E has a h/w bug: although default IRQ line state is HIGH, enabling&n; *&t;interrupts by setting bit 1 of the control register (BASE) to &squot;1&squot;&n; *&t;causes it to go LOW! Therefore, disabling interrupts by setting that&n; *&t;bit to &squot;0&squot; causes low-to-high transition on IRQ line (ghosty&n; *&t;interrupt). The same occurs when disabling CPU by resetting bit 0 of&n; *&t;CPU control register (BASE+3) - see the next note.&n; *&n; *&t;S502E CPU and DPM control is limited:&n; *&n; *&t;o CPU cannot be stopped independently. Resetting bit 0 of the CPUi&n; *&t;  control register (BASE+3) shuts the board down entirely, including&n; *&t;  DPM;&n; *&n; *&t;o DPM access cannot be controlled dynamically. Ones CPU is started,&n; *&t;  bit 1 of the control register (BASE) is used to enable/disable IRQ,&n; *&t;  so that access to shared memory cannot be disabled while CPU is&n; *&t;  running.&n; ****************************************************************************/
DECL|macro|_LINUX_
mdefine_line|#define&t;_LINUX_
macro_line|#if&t;defined(_LINUX_)&t;/****** Linux *******************************/
macro_line|#include &lt;linux/kernel.h&gt;&t;/* printk(), and other useful stuff */
macro_line|#include &lt;linux/stddef.h&gt;&t;/* offsetof(), etc. */
macro_line|#include &lt;linux/errno.h&gt;&t;/* return codes */
macro_line|#include &lt;linux/string.h&gt;&t;/* inline memset(), etc. */
macro_line|#include &lt;linux/module.h&gt;&t;/* support for loadable modules */
macro_line|#include &lt;linux/sched.h&gt;&t;/* for jiffies, HZ, etc. */
macro_line|#include &lt;linux/sdladrv.h&gt;&t;/* API definitions */
macro_line|#include &lt;linux/sdlasfm.h&gt;&t;/* SDLA firmware module definitions */
macro_line|#include &lt;asm/io.h&gt;&t;&t;/* for inb(), outb(), etc. */
DECL|macro|_INB
mdefine_line|#define _INB(port)&t;&t;(inb(port))
DECL|macro|_OUTB
mdefine_line|#define _OUTB(port, byte)&t;(outb((byte),(port)))
DECL|macro|SYSTEM_TICK
mdefine_line|#define&t;SYSTEM_TICK&t;&t;jiffies
macro_line|#elif&t;defined(_SCO_UNIX_)&t;/****** SCO Unix ****************************/
macro_line|#if&t;!defined(INKERNEL)
macro_line|#error&t;This code MUST be compiled in kernel mode!
macro_line|#endif
macro_line|#include &lt;sys/sdladrv.h&gt;&t;/* API definitions */
macro_line|#include &lt;sys/sdlasfm.h&gt;&t;/* SDLA firmware module definitions */
macro_line|#include &lt;sys/inline.h&gt;&t;&t;/* for inb(), outb(), etc. */
DECL|macro|_INB
mdefine_line|#define _INB(port)&t;&t;(inb(port))
DECL|macro|_OUTB
mdefine_line|#define _OUTB(port, byte)&t;(outb((port),(byte)))
DECL|macro|SYSTEM_TICK
mdefine_line|#define&t;SYSTEM_TICK&t;&t;lbolt
macro_line|#else
macro_line|#error&t;Unknown system type!
macro_line|#endif
DECL|macro|MOD_VERSION
mdefine_line|#define&t;MOD_VERSION&t;3
DECL|macro|MOD_RELEASE
mdefine_line|#define&t;MOD_RELEASE&t;0
DECL|macro|SDLA_IODELAY
mdefine_line|#define&t;SDLA_IODELAY&t;100&t;/* I/O Rd/Wr delay, 10 works for 486DX2-66 */
DECL|macro|EXEC_DELAY
mdefine_line|#define&t;EXEC_DELAY&t;20&t;/* shared memory access delay, mks */
DECL|macro|EXEC_TIMEOUT
mdefine_line|#define&t;EXEC_TIMEOUT&t;(HZ*2)&t;/* command timeout, in ticks */
multiline_comment|/* I/O port address range */
DECL|macro|S502A_IORANGE
mdefine_line|#define S502A_IORANGE&t;3
DECL|macro|S502E_IORANGE
mdefine_line|#define S502E_IORANGE&t;4
DECL|macro|S503_IORANGE
mdefine_line|#define S503_IORANGE&t;3
DECL|macro|S507_IORANGE
mdefine_line|#define S507_IORANGE&t;4
DECL|macro|S508_IORANGE
mdefine_line|#define S508_IORANGE&t;4
multiline_comment|/* Maximum amount of memory */
DECL|macro|S502_MAXMEM
mdefine_line|#define S502_MAXMEM&t;0x10000L
DECL|macro|S503_MAXMEM
mdefine_line|#define S503_MAXMEM&t;0x10000L
DECL|macro|S507_MAXMEM
mdefine_line|#define S507_MAXMEM&t;0x40000L
DECL|macro|S508_MAXMEM
mdefine_line|#define S508_MAXMEM&t;0x40000L
multiline_comment|/* Minimum amount of memory */
DECL|macro|S502_MINMEM
mdefine_line|#define S502_MINMEM&t;0x8000L
DECL|macro|S503_MINMEM
mdefine_line|#define S503_MINMEM&t;0x8000L
DECL|macro|S507_MINMEM
mdefine_line|#define S507_MINMEM&t;0x20000L
DECL|macro|S508_MINMEM
mdefine_line|#define S508_MINMEM&t;0x20000L
multiline_comment|/****** Function Prototypes *************************************************/
multiline_comment|/* Module entry points. These are called by the OS and must be public. */
r_int
id|init_module
(paren
r_void
)paren
suffix:semicolon
r_void
id|cleanup_module
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Hardware-specific functions */
r_static
r_int
id|sdla_detect
(paren
id|sdlahw_t
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int
id|sdla_autodpm
(paren
id|sdlahw_t
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int
id|sdla_setdpm
(paren
id|sdlahw_t
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int
id|sdla_load
(paren
id|sdlahw_t
op_star
id|hw
comma
id|sfm_t
op_star
id|sfm
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|sdla_init
(paren
id|sdlahw_t
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int
r_int
id|sdla_memtest
(paren
id|sdlahw_t
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int
id|sdla_bootcfg
(paren
id|sdlahw_t
op_star
id|hw
comma
id|sfm_info_t
op_star
id|sfminfo
)paren
suffix:semicolon
r_static
r_int
r_char
id|make_config_byte
(paren
id|sdlahw_t
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int
id|sdla_start
(paren
id|sdlahw_t
op_star
id|hw
comma
r_int
id|addr
)paren
suffix:semicolon
r_static
r_int
id|init_s502a
(paren
id|sdlahw_t
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int
id|init_s502e
(paren
id|sdlahw_t
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int
id|init_s503
(paren
id|sdlahw_t
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int
id|init_s507
(paren
id|sdlahw_t
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int
id|init_s508
(paren
id|sdlahw_t
op_star
id|hw
)paren
suffix:semicolon
r_static
r_int
id|detect_s502a
(paren
r_int
id|port
)paren
suffix:semicolon
r_static
r_int
id|detect_s502e
(paren
r_int
id|port
)paren
suffix:semicolon
r_static
r_int
id|detect_s503
(paren
r_int
id|port
)paren
suffix:semicolon
r_static
r_int
id|detect_s507
(paren
r_int
id|port
)paren
suffix:semicolon
r_static
r_int
id|detect_s508
(paren
r_int
id|port
)paren
suffix:semicolon
multiline_comment|/* Miscellaneous functions */
r_static
r_int
id|calibrate_delay
(paren
r_int
id|mks
)paren
suffix:semicolon
r_static
r_int
id|get_option_index
(paren
r_int
op_star
id|optlist
comma
r_int
id|optval
)paren
suffix:semicolon
r_static
r_int
id|check_memregion
(paren
r_void
op_star
id|ptr
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|test_memregion
(paren
r_void
op_star
id|ptr
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
r_int
id|checksum
(paren
r_int
r_char
op_star
id|buf
comma
r_int
id|len
)paren
suffix:semicolon
multiline_comment|/****** Global Data **********************************************************&n; * Note: All data must be explicitly initialized!!!&n; */
multiline_comment|/* private data */
DECL|variable|modname
r_static
r_char
id|modname
(braket
)braket
op_assign
l_string|&quot;sdladrv&quot;
suffix:semicolon
DECL|variable|fullname
r_static
r_char
id|fullname
(braket
)braket
op_assign
l_string|&quot;SDLA Support Module&quot;
suffix:semicolon
DECL|variable|copyright
r_static
r_char
id|copyright
(braket
)braket
op_assign
l_string|&quot;(c) 1995-1996 Sangoma Technologies Inc.&quot;
suffix:semicolon
DECL|variable|exec_idle
r_static
r_int
id|exec_idle
suffix:semicolon
multiline_comment|/* Hardware configuration options.&n; * These are arrays of configuration options used by verification routines.&n; * The first element of each array is its size (i.e. number of options).&n; */
DECL|variable|s502_port_options
r_static
r_int
id|s502_port_options
(braket
)braket
op_assign
(brace
l_int|4
comma
l_int|0x250
comma
l_int|0x300
comma
l_int|0x350
comma
l_int|0x360
)brace
suffix:semicolon
DECL|variable|s503_port_options
r_static
r_int
id|s503_port_options
(braket
)braket
op_assign
(brace
l_int|8
comma
l_int|0x250
comma
l_int|0x254
comma
l_int|0x300
comma
l_int|0x304
comma
l_int|0x350
comma
l_int|0x354
comma
l_int|0x360
comma
l_int|0x364
)brace
suffix:semicolon
DECL|variable|s508_port_options
r_static
r_int
id|s508_port_options
(braket
)braket
op_assign
(brace
l_int|8
comma
l_int|0x250
comma
l_int|0x270
comma
l_int|0x280
comma
l_int|0x300
comma
l_int|0x350
comma
l_int|0x360
comma
l_int|0x380
comma
l_int|0x390
)brace
suffix:semicolon
DECL|variable|s502a_irq_options
r_static
r_int
id|s502a_irq_options
(braket
)braket
op_assign
(brace
l_int|0
)brace
suffix:semicolon
DECL|variable|s502e_irq_options
r_static
r_int
id|s502e_irq_options
(braket
)braket
op_assign
(brace
l_int|4
comma
l_int|2
comma
l_int|3
comma
l_int|5
comma
l_int|7
)brace
suffix:semicolon
DECL|variable|s503_irq_options
r_static
r_int
id|s503_irq_options
(braket
)braket
op_assign
(brace
l_int|5
comma
l_int|2
comma
l_int|3
comma
l_int|4
comma
l_int|5
comma
l_int|7
)brace
suffix:semicolon
DECL|variable|s508_irq_options
r_static
r_int
id|s508_irq_options
(braket
)braket
op_assign
(brace
l_int|8
comma
l_int|3
comma
l_int|4
comma
l_int|5
comma
l_int|7
comma
l_int|10
comma
l_int|11
comma
l_int|12
comma
l_int|15
)brace
suffix:semicolon
DECL|variable|s502a_dpmbase_options
r_static
r_int
id|s502a_dpmbase_options
(braket
)braket
op_assign
(brace
l_int|28
comma
l_int|0xA0000
comma
l_int|0xA2000
comma
l_int|0xA4000
comma
l_int|0xA6000
comma
l_int|0xA8000
comma
l_int|0xAA000
comma
l_int|0xAC000
comma
l_int|0xC0000
comma
l_int|0xC2000
comma
l_int|0xC4000
comma
l_int|0xC6000
comma
l_int|0xC8000
comma
l_int|0xCA000
comma
l_int|0xCC000
comma
l_int|0xD0000
comma
l_int|0xD2000
comma
l_int|0xD4000
comma
l_int|0xD6000
comma
l_int|0xD8000
comma
l_int|0xDA000
comma
l_int|0xDC000
comma
l_int|0xE0000
comma
l_int|0xE2000
comma
l_int|0xE4000
comma
l_int|0xE6000
comma
l_int|0xE8000
comma
l_int|0xEA000
comma
l_int|0xEC000
comma
)brace
suffix:semicolon
DECL|variable|s507_dpmbase_options
r_static
r_int
id|s507_dpmbase_options
(braket
)braket
op_assign
(brace
l_int|32
comma
l_int|0xA0000
comma
l_int|0xA2000
comma
l_int|0xA4000
comma
l_int|0xA6000
comma
l_int|0xA8000
comma
l_int|0xAA000
comma
l_int|0xAC000
comma
l_int|0xAE000
comma
l_int|0xB0000
comma
l_int|0xB2000
comma
l_int|0xB4000
comma
l_int|0xB6000
comma
l_int|0xB8000
comma
l_int|0xBA000
comma
l_int|0xBC000
comma
l_int|0xBE000
comma
l_int|0xC0000
comma
l_int|0xC2000
comma
l_int|0xC4000
comma
l_int|0xC6000
comma
l_int|0xC8000
comma
l_int|0xCA000
comma
l_int|0xCC000
comma
l_int|0xCE000
comma
l_int|0xE0000
comma
l_int|0xE2000
comma
l_int|0xE4000
comma
l_int|0xE6000
comma
l_int|0xE8000
comma
l_int|0xEA000
comma
l_int|0xEC000
comma
l_int|0xEE000
comma
)brace
suffix:semicolon
DECL|variable|s508_dpmbase_options
r_static
r_int
id|s508_dpmbase_options
(braket
)braket
op_assign
multiline_comment|/* incl. S502E and S503 */
(brace
l_int|32
comma
l_int|0xA0000
comma
l_int|0xA2000
comma
l_int|0xA4000
comma
l_int|0xA6000
comma
l_int|0xA8000
comma
l_int|0xAA000
comma
l_int|0xAC000
comma
l_int|0xAE000
comma
l_int|0xC0000
comma
l_int|0xC2000
comma
l_int|0xC4000
comma
l_int|0xC6000
comma
l_int|0xC8000
comma
l_int|0xCA000
comma
l_int|0xCC000
comma
l_int|0xCE000
comma
l_int|0xD0000
comma
l_int|0xD2000
comma
l_int|0xD4000
comma
l_int|0xD6000
comma
l_int|0xD8000
comma
l_int|0xDA000
comma
l_int|0xDC000
comma
l_int|0xDE000
comma
l_int|0xE0000
comma
l_int|0xE2000
comma
l_int|0xE4000
comma
l_int|0xE6000
comma
l_int|0xE8000
comma
l_int|0xEA000
comma
l_int|0xEC000
comma
l_int|0xEE000
comma
)brace
suffix:semicolon
multiline_comment|/*&n;static unsigned&t;s502_dpmsize_options[] = { 2, 0x2000, 0x10000 };&n;static unsigned&t;s507_dpmsize_options[] = { 2, 0x2000, 0x4000 };&n;static unsigned&t;s508_dpmsize_options[] = { 1, 0x2000 };&n;*/
DECL|variable|s502a_pclk_options
r_static
r_int
id|s502a_pclk_options
(braket
)braket
op_assign
(brace
l_int|2
comma
l_int|3600
comma
l_int|7200
)brace
suffix:semicolon
DECL|variable|s502e_pclk_options
r_static
r_int
id|s502e_pclk_options
(braket
)braket
op_assign
(brace
l_int|5
comma
l_int|3600
comma
l_int|5000
comma
l_int|7200
comma
l_int|8000
comma
l_int|10000
)brace
suffix:semicolon
DECL|variable|s503_pclk_options
r_static
r_int
id|s503_pclk_options
(braket
)braket
op_assign
(brace
l_int|3
comma
l_int|7200
comma
l_int|8000
comma
l_int|10000
)brace
suffix:semicolon
DECL|variable|s507_pclk_options
r_static
r_int
id|s507_pclk_options
(braket
)braket
op_assign
(brace
l_int|1
comma
l_int|12288
)brace
suffix:semicolon
DECL|variable|s508_pclk_options
r_static
r_int
id|s508_pclk_options
(braket
)braket
op_assign
(brace
l_int|1
comma
l_int|16000
)brace
suffix:semicolon
multiline_comment|/* Host memory control register masks */
DECL|variable|s502a_hmcr
r_static
r_int
r_char
id|s502a_hmcr
(braket
)braket
op_assign
(brace
l_int|0x10
comma
l_int|0x12
comma
l_int|0x14
comma
l_int|0x16
comma
l_int|0x18
comma
l_int|0x1A
comma
l_int|0x1C
comma
multiline_comment|/* A0000 - AC000 */
l_int|0x20
comma
l_int|0x22
comma
l_int|0x24
comma
l_int|0x26
comma
l_int|0x28
comma
l_int|0x2A
comma
l_int|0x2C
comma
multiline_comment|/* C0000 - CC000 */
l_int|0x00
comma
l_int|0x02
comma
l_int|0x04
comma
l_int|0x06
comma
l_int|0x08
comma
l_int|0x0A
comma
l_int|0x0C
comma
multiline_comment|/* D0000 - DC000 */
l_int|0x30
comma
l_int|0x32
comma
l_int|0x34
comma
l_int|0x36
comma
l_int|0x38
comma
l_int|0x3A
comma
l_int|0x3C
comma
multiline_comment|/* E0000 - EC000 */
)brace
suffix:semicolon
DECL|variable|s502e_hmcr
r_static
r_int
r_char
id|s502e_hmcr
(braket
)braket
op_assign
(brace
l_int|0x10
comma
l_int|0x12
comma
l_int|0x14
comma
l_int|0x16
comma
l_int|0x18
comma
l_int|0x1A
comma
l_int|0x1C
comma
l_int|0x1E
comma
multiline_comment|/* A0000 - AE000 */
l_int|0x20
comma
l_int|0x22
comma
l_int|0x24
comma
l_int|0x26
comma
l_int|0x28
comma
l_int|0x2A
comma
l_int|0x2C
comma
l_int|0x2E
comma
multiline_comment|/* C0000 - CE000 */
l_int|0x00
comma
l_int|0x02
comma
l_int|0x04
comma
l_int|0x06
comma
l_int|0x08
comma
l_int|0x0A
comma
l_int|0x0C
comma
l_int|0x0E
comma
multiline_comment|/* D0000 - DE000 */
l_int|0x30
comma
l_int|0x32
comma
l_int|0x34
comma
l_int|0x36
comma
l_int|0x38
comma
l_int|0x3A
comma
l_int|0x3C
comma
l_int|0x3E
comma
multiline_comment|/* E0000 - EE000 */
)brace
suffix:semicolon
DECL|variable|s507_hmcr
r_static
r_int
r_char
id|s507_hmcr
(braket
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x02
comma
l_int|0x04
comma
l_int|0x06
comma
l_int|0x08
comma
l_int|0x0A
comma
l_int|0x0C
comma
l_int|0x0E
comma
multiline_comment|/* A0000 - AE000 */
l_int|0x40
comma
l_int|0x42
comma
l_int|0x44
comma
l_int|0x46
comma
l_int|0x48
comma
l_int|0x4A
comma
l_int|0x4C
comma
l_int|0x4E
comma
multiline_comment|/* B0000 - BE000 */
l_int|0x80
comma
l_int|0x82
comma
l_int|0x84
comma
l_int|0x86
comma
l_int|0x88
comma
l_int|0x8A
comma
l_int|0x8C
comma
l_int|0x8E
comma
multiline_comment|/* C0000 - CE000 */
l_int|0xC0
comma
l_int|0xC2
comma
l_int|0xC4
comma
l_int|0xC6
comma
l_int|0xC8
comma
l_int|0xCA
comma
l_int|0xCC
comma
l_int|0xCE
comma
multiline_comment|/* E0000 - EE000 */
)brace
suffix:semicolon
DECL|variable|s508_hmcr
r_static
r_int
r_char
id|s508_hmcr
(braket
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x01
comma
l_int|0x02
comma
l_int|0x03
comma
l_int|0x04
comma
l_int|0x05
comma
l_int|0x06
comma
l_int|0x07
comma
multiline_comment|/* A0000 - AE000 */
l_int|0x10
comma
l_int|0x11
comma
l_int|0x12
comma
l_int|0x13
comma
l_int|0x14
comma
l_int|0x15
comma
l_int|0x16
comma
l_int|0x17
comma
multiline_comment|/* C0000 - CE000 */
l_int|0x08
comma
l_int|0x09
comma
l_int|0x0A
comma
l_int|0x0B
comma
l_int|0x0C
comma
l_int|0x0D
comma
l_int|0x0E
comma
l_int|0x0F
comma
multiline_comment|/* D0000 - DE000 */
l_int|0x18
comma
l_int|0x19
comma
l_int|0x1A
comma
l_int|0x1B
comma
l_int|0x1C
comma
l_int|0x1D
comma
l_int|0x1E
comma
l_int|0x1F
comma
multiline_comment|/* E0000 - EE000 */
)brace
suffix:semicolon
DECL|variable|s507_irqmask
r_static
r_int
r_char
id|s507_irqmask
(braket
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x20
comma
l_int|0x40
comma
l_int|0x60
comma
l_int|0x80
comma
l_int|0xA0
comma
l_int|0xC0
comma
l_int|0xE0
)brace
suffix:semicolon
multiline_comment|/******* Kernel Loadable Module Entry Points ********************************/
multiline_comment|/*============================================================================&n; * Module &squot;insert&squot; entry point.&n; * o print announcement&n; * o initialize static data&n; * o calibrate SDLA shared memory access delay.&n; *&n; * Return:&t;0&t;Ok&n; *&t;&t;&lt; 0&t;error.&n; * Context:&t;process&n; */
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s v%u.%u %s&bslash;n&quot;
comma
id|fullname
comma
id|MOD_VERSION
comma
id|MOD_RELEASE
comma
id|copyright
)paren
suffix:semicolon
id|exec_idle
op_assign
id|calibrate_delay
c_func
(paren
id|EXEC_DELAY
)paren
suffix:semicolon
macro_line|#ifdef WANDEBUG&t;
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: exec_idle = %d&bslash;n&quot;
comma
id|modname
comma
id|exec_idle
)paren
suffix:semicolon
macro_line|#endif&t;
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Module &squot;remove&squot; entry point.&n; * o release all remaining system resources&n; */
DECL|function|cleanup_module
r_void
id|cleanup_module
(paren
r_void
)paren
(brace
)brace
macro_line|#endif
multiline_comment|/******* Kernel APIs ********************************************************/
multiline_comment|/*============================================================================&n; * Set up adapter.&n; * o detect adapter type&n; * o verify hardware configuration options&n; * o check for hardware conflicts&n; * o set up adapter shared memory&n; * o test adapter memory&n; * o load firmware&n; * Return:&t;0&t;ok.&n; *&t;&t;&lt; 0&t;error&n; */
DECL|variable|sdla_setup
id|EXPORT_SYMBOL
c_func
(paren
id|sdla_setup
)paren
suffix:semicolon
DECL|function|sdla_setup
r_int
id|sdla_setup
(paren
id|sdlahw_t
op_star
id|hw
comma
r_void
op_star
id|sfm
comma
r_int
id|len
)paren
(brace
r_int
op_star
id|irq_opt
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* IRQ options */
r_int
op_star
id|dpmbase_opt
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* DPM window base options */
r_int
op_star
id|pclk_opt
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* CPU clock rate options */
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|sdla_detect
c_func
(paren
id|hw
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: adapter S%04u not found at port 0x%X!&bslash;n&quot;
comma
id|modname
comma
id|hw-&gt;type
comma
id|hw-&gt;port
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: found S%04u card at port 0x%X.&bslash;n&quot;
comma
id|modname
comma
id|hw-&gt;type
comma
id|hw-&gt;port
)paren
suffix:semicolon
id|hw-&gt;dpmsize
op_assign
id|SDLA_WINDOWSIZE
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;type
)paren
(brace
r_case
id|SDLA_S502A
suffix:colon
id|hw-&gt;io_range
op_assign
id|S502A_IORANGE
suffix:semicolon
id|irq_opt
op_assign
id|s502a_irq_options
suffix:semicolon
id|dpmbase_opt
op_assign
id|s502a_dpmbase_options
suffix:semicolon
id|pclk_opt
op_assign
id|s502a_pclk_options
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S502E
suffix:colon
id|hw-&gt;io_range
op_assign
id|S502E_IORANGE
suffix:semicolon
id|irq_opt
op_assign
id|s502e_irq_options
suffix:semicolon
id|dpmbase_opt
op_assign
id|s508_dpmbase_options
suffix:semicolon
id|pclk_opt
op_assign
id|s502e_pclk_options
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S503
suffix:colon
id|hw-&gt;io_range
op_assign
id|S503_IORANGE
suffix:semicolon
id|irq_opt
op_assign
id|s503_irq_options
suffix:semicolon
id|dpmbase_opt
op_assign
id|s508_dpmbase_options
suffix:semicolon
id|pclk_opt
op_assign
id|s503_pclk_options
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S507
suffix:colon
id|hw-&gt;io_range
op_assign
id|S507_IORANGE
suffix:semicolon
id|irq_opt
op_assign
id|s508_irq_options
suffix:semicolon
id|dpmbase_opt
op_assign
id|s507_dpmbase_options
suffix:semicolon
id|pclk_opt
op_assign
id|s507_pclk_options
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S508
suffix:colon
id|hw-&gt;io_range
op_assign
id|S508_IORANGE
suffix:semicolon
id|irq_opt
op_assign
id|s508_irq_options
suffix:semicolon
id|dpmbase_opt
op_assign
id|s508_dpmbase_options
suffix:semicolon
id|pclk_opt
op_assign
id|s508_pclk_options
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Verify IRQ configuration options */
r_if
c_cond
(paren
op_logical_neg
id|get_option_index
c_func
(paren
id|irq_opt
comma
id|hw-&gt;irq
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: IRQ %d is illegal!&bslash;n&quot;
comma
id|modname
comma
id|hw-&gt;irq
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Verify CPU clock rate configuration options */
r_if
c_cond
(paren
id|hw-&gt;pclk
op_eq
l_int|0
)paren
id|hw-&gt;pclk
op_assign
id|pclk_opt
(braket
l_int|1
)braket
multiline_comment|/* use default */
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|get_option_index
c_func
(paren
id|pclk_opt
comma
id|hw-&gt;pclk
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: CPU clock %u is illegal!&bslash;n&quot;
comma
id|modname
comma
id|hw-&gt;pclk
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: assuming CPU clock rate of %u kHz.&bslash;n&quot;
comma
id|modname
comma
id|hw-&gt;pclk
)paren
suffix:semicolon
multiline_comment|/* Setup adapter dual-port memory window and test memory */
r_if
c_cond
(paren
id|hw-&gt;dpmbase
op_eq
l_int|0
)paren
(brace
id|err
op_assign
id|sdla_autodpm
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: can&squot;t find available memory region!&bslash;n&quot;
comma
id|modname
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|get_option_index
c_func
(paren
id|dpmbase_opt
comma
id|virt_to_phys
c_func
(paren
id|hw-&gt;dpmbase
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: memory address 0x%lX is illegal!&bslash;n&quot;
comma
id|modname
comma
id|virt_to_phys
c_func
(paren
id|hw-&gt;dpmbase
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sdla_setdpm
c_func
(paren
id|hw
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: 8K memory region at 0x%lX is not available!&bslash;n&quot;
comma
id|modname
comma
id|virt_to_phys
c_func
(paren
id|hw-&gt;dpmbase
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: dual-port memory window is set at 0x%lX.&bslash;n&quot;
comma
id|modname
comma
id|virt_to_phys
c_func
(paren
id|hw-&gt;dpmbase
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: found %luK bytes of on-board memory.&bslash;n&quot;
comma
id|modname
comma
id|hw-&gt;memory
op_div
l_int|1024
)paren
suffix:semicolon
multiline_comment|/* Load firmware. If loader fails then shut down adapter */
id|err
op_assign
id|sdla_load
c_func
(paren
id|hw
comma
id|sfm
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|sdla_down
c_func
(paren
id|hw
)paren
suffix:semicolon
multiline_comment|/* shutdown adapter */
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Shut down SDLA: disable shared memory access and interrupts, stop CPU, etc.&n; */
DECL|variable|sdla_down
id|EXPORT_SYMBOL
c_func
(paren
id|sdla_down
)paren
suffix:semicolon
DECL|function|sdla_down
r_int
id|sdla_down
(paren
id|sdlahw_t
op_star
id|hw
)paren
(brace
r_int
id|port
op_assign
id|hw-&gt;port
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;type
)paren
(brace
r_case
id|SDLA_S502A
suffix:colon
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x08
)paren
suffix:semicolon
multiline_comment|/* halt CPU */
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x08
)paren
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x08
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
l_int|0x08
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
op_plus
l_int|1
comma
l_int|0xFF
)paren
suffix:semicolon
multiline_comment|/* close memory window */
id|hw-&gt;regs
(braket
l_int|1
)braket
op_assign
l_int|0xFF
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S502E
suffix:colon
id|_OUTB
c_func
(paren
id|port
op_plus
l_int|3
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* stop CPU */
id|_OUTB
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reset board */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|S502E_IORANGE
suffix:semicolon
op_increment
id|i
)paren
id|hw-&gt;regs
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S503
suffix:colon
r_case
id|SDLA_S507
suffix:colon
r_case
id|SDLA_S508
suffix:colon
id|_OUTB
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reset board logic */
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Map shared memory window into SDLA address space.&n; */
DECL|variable|sdla_mapmem
id|EXPORT_SYMBOL
c_func
(paren
id|sdla_mapmem
)paren
suffix:semicolon
DECL|function|sdla_mapmem
r_int
id|sdla_mapmem
(paren
id|sdlahw_t
op_star
id|hw
comma
r_int
r_int
id|addr
)paren
(brace
r_int
id|port
op_assign
id|hw-&gt;port
suffix:semicolon
r_register
r_int
id|tmp
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;type
)paren
(brace
r_case
id|SDLA_S502A
suffix:colon
r_case
id|SDLA_S502E
suffix:colon
r_if
c_cond
(paren
id|addr
OL
id|S502_MAXMEM
)paren
multiline_comment|/* verify parameter */
(brace
id|tmp
op_assign
id|addr
op_rshift
l_int|13
suffix:semicolon
multiline_comment|/* convert to register mask */
id|_OUTB
c_func
(paren
id|port
op_plus
l_int|2
comma
id|tmp
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|2
)braket
op_assign
id|tmp
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S503
suffix:colon
r_if
c_cond
(paren
id|addr
OL
id|S503_MAXMEM
)paren
multiline_comment|/* verify parameter */
(brace
id|tmp
op_assign
(paren
id|hw-&gt;regs
(braket
l_int|0
)braket
op_amp
l_int|0x8F
)paren
op_or
(paren
(paren
id|addr
op_rshift
l_int|9
)paren
op_amp
l_int|0x70
)paren
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
id|tmp
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
id|tmp
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S507
suffix:colon
r_if
c_cond
(paren
id|addr
OL
id|S507_MAXMEM
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|_INB
c_func
(paren
id|port
)paren
op_amp
l_int|0x02
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|tmp
op_assign
id|addr
op_rshift
l_int|13
suffix:semicolon
multiline_comment|/* convert to register mask */
id|_OUTB
c_func
(paren
id|port
op_plus
l_int|2
comma
id|tmp
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|2
)braket
op_assign
id|tmp
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S508
suffix:colon
r_if
c_cond
(paren
id|addr
OL
id|S508_MAXMEM
)paren
(brace
id|tmp
op_assign
id|addr
op_rshift
l_int|13
suffix:semicolon
multiline_comment|/* convert to register mask */
id|_OUTB
c_func
(paren
id|port
op_plus
l_int|2
comma
id|tmp
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|2
)braket
op_assign
id|tmp
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|hw-&gt;vector
op_assign
id|addr
op_amp
l_int|0xFFFFE000L
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Enable interrupt generation.&n; */
DECL|variable|sdla_inten
id|EXPORT_SYMBOL
c_func
(paren
id|sdla_inten
)paren
suffix:semicolon
DECL|function|sdla_inten
r_int
id|sdla_inten
(paren
id|sdlahw_t
op_star
id|hw
)paren
(brace
r_int
id|port
op_assign
id|hw-&gt;port
suffix:semicolon
r_int
id|tmp
comma
id|i
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;type
)paren
(brace
r_case
id|SDLA_S502E
suffix:colon
multiline_comment|/* Note thar interrupt control operations on S502E are allowed&n;&t;&t; * only if CPU is enabled (bit 0 of status register is set).&n;&t;&t; */
r_if
c_cond
(paren
id|_INB
c_func
(paren
id|port
)paren
op_amp
l_int|0x01
)paren
(brace
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x02
)paren
suffix:semicolon
multiline_comment|/* bit1 = 1, bit2 = 0 */
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x06
)paren
suffix:semicolon
multiline_comment|/* bit1 = 1, bit2 = 1 */
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
l_int|0x06
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S503
suffix:colon
id|tmp
op_assign
id|hw-&gt;regs
(braket
l_int|0
)braket
op_or
l_int|0x04
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
id|tmp
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* update mirror */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
r_if
c_cond
(paren
op_logical_neg
(paren
id|_INB
c_func
(paren
id|port
)paren
op_amp
l_int|0x02
)paren
)paren
multiline_comment|/* verify */
r_return
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S508
suffix:colon
id|tmp
op_assign
id|hw-&gt;regs
(braket
l_int|0
)braket
op_or
l_int|0x10
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
id|tmp
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* update mirror */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
r_if
c_cond
(paren
op_logical_neg
(paren
id|_INB
c_func
(paren
id|port
op_plus
l_int|1
)paren
op_amp
l_int|0x10
)paren
)paren
multiline_comment|/* verify */
r_return
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S502A
suffix:colon
r_case
id|SDLA_S507
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Disable interrupt generation.&n; */
DECL|variable|sdla_intde
id|EXPORT_SYMBOL
c_func
(paren
id|sdla_intde
)paren
suffix:semicolon
DECL|function|sdla_intde
r_int
id|sdla_intde
(paren
id|sdlahw_t
op_star
id|hw
)paren
(brace
r_int
id|port
op_assign
id|hw-&gt;port
suffix:semicolon
r_int
id|tmp
comma
id|i
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;type
)paren
(brace
r_case
id|SDLA_S502E
suffix:colon
multiline_comment|/* Notes:&n;&t;&t; *  1) interrupt control operations are allowed only if CPU is&n;&t;&t; *     enabled (bit 0 of status register is set).&n;&t;&t; *  2) disabling interrupts using bit 1 of control register&n;&t;&t; *     causes IRQ line go high, therefore we are going to use&n;&t;&t; *     0x04 instead: lower it to inhibit interrupts to PC.&n;&t;&t; */
r_if
c_cond
(paren
id|_INB
c_func
(paren
id|port
)paren
op_amp
l_int|0x01
)paren
(brace
id|_OUTB
c_func
(paren
id|port
comma
id|hw-&gt;regs
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0x04
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|0
)braket
op_and_assign
op_complement
l_int|0x04
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S503
suffix:colon
id|tmp
op_assign
id|hw-&gt;regs
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0x04
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
id|tmp
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* update mirror */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
r_if
c_cond
(paren
id|_INB
c_func
(paren
id|port
)paren
op_amp
l_int|0x02
)paren
multiline_comment|/* verify */
r_return
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S508
suffix:colon
id|tmp
op_assign
id|hw-&gt;regs
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0x10
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
id|tmp
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* update mirror */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
r_if
c_cond
(paren
id|_INB
c_func
(paren
id|port
)paren
op_amp
l_int|0x10
)paren
multiline_comment|/* verify */
r_return
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S502A
suffix:colon
r_case
id|SDLA_S507
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Acknowledge SDLA hardware interrupt.&n; */
DECL|variable|sdla_intack
id|EXPORT_SYMBOL
c_func
(paren
id|sdla_intack
)paren
suffix:semicolon
DECL|function|sdla_intack
r_int
id|sdla_intack
(paren
id|sdlahw_t
op_star
id|hw
)paren
(brace
r_int
id|port
op_assign
id|hw-&gt;port
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;type
)paren
(brace
r_case
id|SDLA_S502E
suffix:colon
multiline_comment|/* To acknoledge hardware interrupt we have to toggle bit 3 of&n;&t;&t; * control register: &bslash;_/&n;&t;&t; * Note that interrupt control operations on S502E are allowed&n;&t;&t; * only if CPU is enabled (bit 1 of status register is set).&n;&t;&t; */
r_if
c_cond
(paren
id|_INB
c_func
(paren
id|port
)paren
op_amp
l_int|0x01
)paren
(brace
id|tmp
op_assign
id|hw-&gt;regs
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0x04
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
id|tmp
)paren
suffix:semicolon
id|tmp
op_or_assign
l_int|0x04
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
id|tmp
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
id|tmp
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S503
suffix:colon
r_if
c_cond
(paren
id|_INB
c_func
(paren
id|port
)paren
op_amp
l_int|0x04
)paren
(brace
id|tmp
op_assign
id|hw-&gt;regs
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0x08
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
id|tmp
)paren
suffix:semicolon
id|tmp
op_or_assign
l_int|0x08
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
id|tmp
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
id|tmp
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SDLA_S502A
suffix:colon
r_case
id|SDLA_S507
suffix:colon
r_case
id|SDLA_S508
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Generate an interrupt to adapter&squot;s CPU.&n; */
DECL|variable|sdla_intr
id|EXPORT_SYMBOL
c_func
(paren
id|sdla_intr
)paren
suffix:semicolon
DECL|function|sdla_intr
r_int
id|sdla_intr
(paren
id|sdlahw_t
op_star
id|hw
)paren
(brace
r_int
id|port
op_assign
id|hw-&gt;port
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;type
)paren
(brace
r_case
id|SDLA_S502A
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|_INB
c_func
(paren
id|port
)paren
op_amp
l_int|0x40
)paren
)paren
(brace
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* issue NMI to CPU */
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
l_int|0x10
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S507
suffix:colon
r_if
c_cond
(paren
(paren
id|_INB
c_func
(paren
id|port
)paren
op_amp
l_int|0x06
)paren
op_eq
l_int|0x06
)paren
(brace
id|_OUTB
c_func
(paren
id|port
op_plus
l_int|3
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S508
suffix:colon
r_if
c_cond
(paren
id|_INB
c_func
(paren
id|port
op_plus
l_int|1
)paren
op_amp
l_int|0x02
)paren
(brace
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x08
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S502E
suffix:colon
r_case
id|SDLA_S503
suffix:colon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Execute Adapter Command.&n; * o Set exec flag.&n; * o Busy-wait until flag is reset.&n; * o Return number of loops made, or 0 if command timed out.&n; */
DECL|variable|sdla_exec
id|EXPORT_SYMBOL
c_func
(paren
id|sdla_exec
)paren
suffix:semicolon
DECL|function|sdla_exec
r_int
id|sdla_exec
(paren
r_void
op_star
id|opflag
)paren
(brace
r_volatile
r_int
r_char
op_star
id|flag
op_assign
id|opflag
suffix:semicolon
r_int
r_int
id|tstop
suffix:semicolon
r_int
id|nloops
suffix:semicolon
r_if
c_cond
(paren
op_star
id|flag
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* ???? */
op_star
id|flag
op_assign
l_int|1
suffix:semicolon
id|tstop
op_assign
id|SYSTEM_TICK
op_plus
id|EXEC_TIMEOUT
suffix:semicolon
r_for
c_loop
(paren
id|nloops
op_assign
l_int|1
suffix:semicolon
op_star
id|flag
suffix:semicolon
op_increment
id|nloops
)paren
(brace
r_int
id|delay
op_assign
id|exec_idle
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|delay
)paren
suffix:semicolon
multiline_comment|/* delay */
r_if
c_cond
(paren
id|SYSTEM_TICK
OG
id|tstop
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* time is up! */
)brace
r_return
id|nloops
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Read absolute adapter memory.&n; * Transfer data from adapter&squot;s memory to data buffer.&n; *&n; * Note:&n; * Care should be taken when crossing dual-port memory window boundary.&n; * This function is not atomic, so caller must disable interrupt if&n; * interrupt routines are accessing adapter shared memory.&n; */
DECL|variable|sdla_peek
id|EXPORT_SYMBOL
c_func
(paren
id|sdla_peek
)paren
suffix:semicolon
DECL|function|sdla_peek
r_int
id|sdla_peek
(paren
id|sdlahw_t
op_star
id|hw
comma
r_int
r_int
id|addr
comma
r_void
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|oldvec
op_assign
id|hw-&gt;vector
suffix:semicolon
r_int
id|winsize
op_assign
id|hw-&gt;dpmsize
suffix:semicolon
r_int
id|curpos
comma
id|curlen
suffix:semicolon
multiline_comment|/* current offset and block size */
r_int
r_int
id|curvec
suffix:semicolon
multiline_comment|/* current DPM window vector */
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_plus
id|len
OG
id|hw-&gt;memory
)paren
multiline_comment|/* verify arguments */
r_return
op_minus
id|EINVAL
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
op_logical_neg
id|err
)paren
(brace
id|curpos
op_assign
id|addr
op_mod
id|winsize
suffix:semicolon
multiline_comment|/* current window offset */
id|curvec
op_assign
id|addr
op_minus
id|curpos
suffix:semicolon
multiline_comment|/* current window vector */
id|curlen
op_assign
(paren
id|len
OG
(paren
id|winsize
op_minus
id|curpos
)paren
)paren
ques
c_cond
(paren
id|winsize
op_minus
id|curpos
)paren
suffix:colon
id|len
suffix:semicolon
multiline_comment|/* Relocate window and copy block of data */
id|err
op_assign
id|sdla_mapmem
c_func
(paren
id|hw
comma
id|curvec
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
(paren
r_void
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|hw-&gt;dpmbase
op_plus
id|curpos
)paren
comma
id|curlen
)paren
suffix:semicolon
id|addr
op_add_assign
id|curlen
suffix:semicolon
(paren
r_char
op_star
)paren
id|buf
op_add_assign
id|curlen
suffix:semicolon
id|len
op_sub_assign
id|curlen
suffix:semicolon
)brace
multiline_comment|/* Restore DPM window position */
id|sdla_mapmem
c_func
(paren
id|hw
comma
id|oldvec
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Write Absolute Adapter Memory.&n; * Transfer data from data buffer to adapter&squot;s memory.&n; *&n; * Note:&n; * Care should be taken when crossing dual-port memory window boundary.&n; * This function is not atomic, so caller must disable interrupt if&n; * interrupt routines are accessing adapter shared memory.&n; */
DECL|variable|sdla_poke
id|EXPORT_SYMBOL
c_func
(paren
id|sdla_poke
)paren
suffix:semicolon
DECL|function|sdla_poke
r_int
id|sdla_poke
(paren
id|sdlahw_t
op_star
id|hw
comma
r_int
r_int
id|addr
comma
r_void
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|oldvec
op_assign
id|hw-&gt;vector
suffix:semicolon
r_int
id|winsize
op_assign
id|hw-&gt;dpmsize
suffix:semicolon
r_int
id|curpos
comma
id|curlen
suffix:semicolon
multiline_comment|/* current offset and block size */
r_int
r_int
id|curvec
suffix:semicolon
multiline_comment|/* current DPM window vector */
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_plus
id|len
OG
id|hw-&gt;memory
)paren
multiline_comment|/* verify arguments */
r_return
op_minus
id|EINVAL
suffix:semicolon
r_while
c_loop
(paren
id|len
op_logical_and
op_logical_neg
id|err
)paren
(brace
id|curpos
op_assign
id|addr
op_mod
id|winsize
suffix:semicolon
multiline_comment|/* current window offset */
id|curvec
op_assign
id|addr
op_minus
id|curpos
suffix:semicolon
multiline_comment|/* current window vector */
id|curlen
op_assign
(paren
id|len
OG
(paren
id|winsize
op_minus
id|curpos
)paren
)paren
ques
c_cond
(paren
id|winsize
op_minus
id|curpos
)paren
suffix:colon
id|len
suffix:semicolon
multiline_comment|/* Relocate window and copy block of data */
id|sdla_mapmem
c_func
(paren
id|hw
comma
id|curvec
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|hw-&gt;dpmbase
op_plus
id|curpos
)paren
comma
id|buf
comma
id|curlen
)paren
suffix:semicolon
id|addr
op_add_assign
id|curlen
suffix:semicolon
(paren
r_char
op_star
)paren
id|buf
op_add_assign
id|curlen
suffix:semicolon
id|len
op_sub_assign
id|curlen
suffix:semicolon
)brace
multiline_comment|/* Restore DPM window position */
id|sdla_mapmem
c_func
(paren
id|hw
comma
id|oldvec
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#ifdef&t;DONT_COMPIPLE_THIS
macro_line|#endif&t;/* DONT_COMPIPLE_THIS */
multiline_comment|/****** Hardware-Specific Functions *****************************************/
multiline_comment|/*============================================================================&n; * Detect adapter type.&n; * o if adapter type is specified then call detection routine for that adapter&n; *   type.  Otherwise call detection routines for every adapter types until&n; *   adapter is detected.&n; *&n; * Notes:&n; * 1) Detection tests are destructive! Adapter will be left in shutdown state&n; *    after the test.&n; */
DECL|function|sdla_detect
r_static
r_int
id|sdla_detect
(paren
id|sdlahw_t
op_star
id|hw
)paren
(brace
r_int
id|port
op_assign
id|hw-&gt;port
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;type
)paren
(brace
r_case
id|SDLA_S502A
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|detect_s502a
c_func
(paren
id|port
)paren
)paren
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S502E
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|detect_s502e
c_func
(paren
id|port
)paren
)paren
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S503
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|detect_s503
c_func
(paren
id|port
)paren
)paren
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S507
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|detect_s507
c_func
(paren
id|port
)paren
)paren
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S508
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|detect_s508
c_func
(paren
id|port
)paren
)paren
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|detect_s502a
c_func
(paren
id|port
)paren
)paren
id|hw-&gt;type
op_assign
id|SDLA_S502A
suffix:semicolon
r_else
r_if
c_cond
(paren
id|detect_s502e
c_func
(paren
id|port
)paren
)paren
id|hw-&gt;type
op_assign
id|SDLA_S502E
suffix:semicolon
r_else
r_if
c_cond
(paren
id|detect_s503
c_func
(paren
id|port
)paren
)paren
id|hw-&gt;type
op_assign
id|SDLA_S503
suffix:semicolon
r_else
r_if
c_cond
(paren
id|detect_s507
c_func
(paren
id|port
)paren
)paren
id|hw-&gt;type
op_assign
id|SDLA_S507
suffix:semicolon
r_else
r_if
c_cond
(paren
id|detect_s508
c_func
(paren
id|port
)paren
)paren
id|hw-&gt;type
op_assign
id|SDLA_S508
suffix:semicolon
r_else
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Autoselect memory region. &n; * o try all available DMP address options from the top down until success.&n; */
DECL|function|sdla_autodpm
r_static
r_int
id|sdla_autodpm
(paren
id|sdlahw_t
op_star
id|hw
)paren
(brace
r_int
id|i
comma
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_int
op_star
id|opt
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;type
)paren
(brace
r_case
id|SDLA_S502A
suffix:colon
id|opt
op_assign
id|s502a_dpmbase_options
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S502E
suffix:colon
r_case
id|SDLA_S503
suffix:colon
r_case
id|SDLA_S508
suffix:colon
id|opt
op_assign
id|s508_dpmbase_options
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S507
suffix:colon
id|opt
op_assign
id|s507_dpmbase_options
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|opt
(braket
l_int|0
)braket
suffix:semicolon
id|i
op_logical_and
id|err
suffix:semicolon
op_decrement
id|i
)paren
(brace
id|hw-&gt;dpmbase
op_assign
id|phys_to_virt
c_func
(paren
id|opt
(braket
id|i
)braket
)paren
suffix:semicolon
id|err
op_assign
id|sdla_setdpm
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Set up adapter dual-port memory window. &n; * o shut down adapter&n; * o make sure that no physical memory exists in this region, i.e entire&n; *   region reads 0xFF and is not writable when adapter is shut down.&n; * o initialize adapter hardware&n; * o make sure that region is usable with SDLA card, i.e. we can write to it&n; *   when adapter is configured.&n; */
DECL|function|sdla_setdpm
r_static
r_int
id|sdla_setdpm
(paren
id|sdlahw_t
op_star
id|hw
)paren
(brace
r_int
id|err
suffix:semicolon
multiline_comment|/* Shut down card and verify memory region */
id|sdla_down
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_memregion
c_func
(paren
id|hw-&gt;dpmbase
comma
id|hw-&gt;dpmsize
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Initialize adapter and test on-board memory segment by segment.&n;&t; * If memory size appears to be less than shared memory window size,&n;&t; * assume that memory region is unusable.&n;&t; */
id|err
op_assign
id|sdla_init
c_func
(paren
id|hw
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|sdla_memtest
c_func
(paren
id|hw
)paren
OL
id|hw-&gt;dpmsize
)paren
multiline_comment|/* less than window size */
(brace
id|sdla_down
c_func
(paren
id|hw
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|sdla_mapmem
c_func
(paren
id|hw
comma
l_int|0L
)paren
suffix:semicolon
multiline_comment|/* set window vector at bottom */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Load adapter from the memory image of the SDLA firmware module. &n; * o verify firmware integrity and compatibility&n; * o start adapter up&n; */
DECL|function|sdla_load
r_static
r_int
id|sdla_load
(paren
id|sdlahw_t
op_star
id|hw
comma
id|sfm_t
op_star
id|sfm
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Verify firmware signature */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|sfm-&gt;signature
comma
id|SFM_SIGNATURE
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: not SDLA firmware!&bslash;n&quot;
comma
id|modname
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Verify firmware module format version */
r_if
c_cond
(paren
id|sfm-&gt;version
op_ne
id|SFM_VERSION
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: firmware format %u rejected! Expecting %u.&bslash;n&quot;
comma
id|modname
comma
id|sfm-&gt;version
comma
id|SFM_VERSION
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Verify firmware module length and checksum */
r_if
c_cond
(paren
(paren
id|len
op_minus
m_offsetof
(paren
id|sfm_t
comma
id|image
)paren
op_ne
id|sfm-&gt;info.codesize
)paren
op_logical_or
(paren
id|checksum
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|sfm-&gt;info
comma
r_sizeof
(paren
id|sfm_info_t
)paren
op_plus
id|sfm-&gt;info.codesize
)paren
op_ne
id|sfm-&gt;checksum
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: firmware corrupted!&bslash;n&quot;
comma
id|modname
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Announce */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: loading %s (ID=%u)...&bslash;n&quot;
comma
id|modname
comma
(paren
id|sfm-&gt;descr
(braket
l_int|0
)braket
op_ne
l_char|&squot;&bslash;0&squot;
)paren
ques
c_cond
id|sfm-&gt;descr
suffix:colon
l_string|&quot;unknown firmware&quot;
comma
id|sfm-&gt;info.codeid
)paren
suffix:semicolon
multiline_comment|/* Scan through the list of compatible adapters and make sure our&n;&t; * adapter type is listed.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|SFM_MAX_SDLA
)paren
op_logical_and
(paren
id|sfm-&gt;info.adapter
(braket
id|i
)braket
op_ne
id|hw-&gt;type
)paren
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|SFM_MAX_SDLA
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: firmware is not compatible with S%u!&bslash;n&quot;
comma
id|modname
comma
id|hw-&gt;type
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Make sure there is enough on-board memory */
r_if
c_cond
(paren
id|hw-&gt;memory
OL
id|sfm-&gt;info.memsize
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: firmware needs %lu bytes of on-board memory!&bslash;n&quot;
comma
id|modname
comma
id|sfm-&gt;info.memsize
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Move code onto adapter */
r_if
c_cond
(paren
id|sdla_poke
c_func
(paren
id|hw
comma
id|sfm-&gt;info.codeoffs
comma
id|sfm-&gt;image
comma
id|sfm-&gt;info.codesize
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: failed to load code segment!&bslash;n&quot;
comma
id|modname
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Prepare boot-time configuration data and kick-off CPU */
id|sdla_bootcfg
c_func
(paren
id|hw
comma
op_amp
id|sfm-&gt;info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdla_start
c_func
(paren
id|hw
comma
id|sfm-&gt;info.startoffs
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Damn... Adapter won&squot;t start!&bslash;n&quot;
comma
id|modname
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* position DPM window over the mailbox and enable interrupts */
r_if
c_cond
(paren
id|sdla_mapmem
c_func
(paren
id|hw
comma
id|sfm-&gt;info.winoffs
)paren
op_logical_or
id|sdla_inten
c_func
(paren
id|hw
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: adapter hardware failure!&bslash;n&quot;
comma
id|modname
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|hw-&gt;fwid
op_assign
id|sfm-&gt;info.codeid
suffix:semicolon
multiline_comment|/* set firmware ID */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Initialize SDLA hardware: setup memory window, IRQ, etc.&n; */
DECL|function|sdla_init
r_static
r_int
id|sdla_init
(paren
id|sdlahw_t
op_star
id|hw
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_MAXIORANGE
suffix:semicolon
op_increment
id|i
)paren
id|hw-&gt;regs
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;type
)paren
(brace
r_case
id|SDLA_S502A
suffix:colon
r_return
id|init_s502a
c_func
(paren
id|hw
)paren
suffix:semicolon
r_case
id|SDLA_S502E
suffix:colon
r_return
id|init_s502e
c_func
(paren
id|hw
)paren
suffix:semicolon
r_case
id|SDLA_S503
suffix:colon
r_return
id|init_s503
c_func
(paren
id|hw
)paren
suffix:semicolon
r_case
id|SDLA_S507
suffix:colon
r_return
id|init_s507
c_func
(paren
id|hw
)paren
suffix:semicolon
r_case
id|SDLA_S508
suffix:colon
r_return
id|init_s508
c_func
(paren
id|hw
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Test adapter on-board memory.&n; * o slide DPM window from the bottom up and test adapter memory segment by&n; *   segment.&n; * Return adapter memory size.&n; */
DECL|function|sdla_memtest
r_static
r_int
r_int
id|sdla_memtest
(paren
id|sdlahw_t
op_star
id|hw
)paren
(brace
r_int
r_int
id|memsize
suffix:semicolon
r_int
id|winsize
suffix:semicolon
r_for
c_loop
(paren
id|memsize
op_assign
l_int|0
comma
id|winsize
op_assign
id|hw-&gt;dpmsize
suffix:semicolon
op_logical_neg
id|sdla_mapmem
c_func
(paren
id|hw
comma
id|memsize
)paren
op_logical_and
(paren
id|test_memregion
c_func
(paren
id|hw-&gt;dpmbase
comma
id|winsize
)paren
op_eq
id|winsize
)paren
suffix:semicolon
id|memsize
op_add_assign
id|winsize
)paren
suffix:semicolon
id|hw-&gt;memory
op_assign
id|memsize
suffix:semicolon
r_return
id|memsize
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Prepare boot-time firmware configuration data.&n; * o position DPM window&n; * o initialize configuration data area&n; */
DECL|function|sdla_bootcfg
r_static
r_int
id|sdla_bootcfg
(paren
id|sdlahw_t
op_star
id|hw
comma
id|sfm_info_t
op_star
id|sfminfo
)paren
(brace
r_int
r_char
op_star
id|data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sfminfo-&gt;datasize
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* nothing to do */
r_if
c_cond
(paren
id|sdla_mapmem
c_func
(paren
id|hw
comma
id|sfminfo-&gt;dataoffs
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|data
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
id|u8
op_star
)paren
id|hw-&gt;dpmbase
op_plus
(paren
id|sfminfo-&gt;dataoffs
op_minus
id|hw-&gt;vector
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|data
comma
l_int|0
comma
id|sfminfo-&gt;datasize
)paren
suffix:semicolon
id|data
(braket
l_int|0x00
)braket
op_assign
id|make_config_byte
c_func
(paren
id|hw
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sfminfo-&gt;codeid
)paren
(brace
r_case
id|SFID_X25_502
suffix:colon
r_case
id|SFID_X25_508
suffix:colon
id|data
(braket
l_int|0x01
)braket
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* T1 timer */
id|data
(braket
l_int|0x03
)braket
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* N2 */
id|data
(braket
l_int|0x06
)braket
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* HDLC window size */
id|data
(braket
l_int|0x0B
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* DTE */
id|data
(braket
l_int|0x0C
)braket
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* X.25 packet window size */
op_star
(paren
r_int
op_star
)paren
op_amp
id|data
(braket
l_int|0x0D
)braket
op_assign
l_int|128
suffix:semicolon
multiline_comment|/* default X.25 data size */
op_star
(paren
r_int
op_star
)paren
op_amp
id|data
(braket
l_int|0x0F
)braket
op_assign
l_int|128
suffix:semicolon
multiline_comment|/* maximum X.25 data size */
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Prepare configuration byte identifying adapter type and CPU clock rate.&n; */
DECL|function|make_config_byte
r_static
r_int
r_char
id|make_config_byte
(paren
id|sdlahw_t
op_star
id|hw
)paren
(brace
r_int
r_char
id|byte
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;pclk
)paren
(brace
r_case
l_int|5000
suffix:colon
id|byte
op_assign
l_int|0x01
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7200
suffix:colon
id|byte
op_assign
l_int|0x02
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8000
suffix:colon
id|byte
op_assign
l_int|0x03
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10000
suffix:colon
id|byte
op_assign
l_int|0x04
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|16000
suffix:colon
id|byte
op_assign
l_int|0x05
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|hw-&gt;type
)paren
(brace
r_case
id|SDLA_S502E
suffix:colon
id|byte
op_or_assign
l_int|0x80
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S503
suffix:colon
id|byte
op_or_assign
l_int|0x40
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|byte
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Start adapter&squot;s CPU.&n; * o calculate a pointer to adapter&squot;s cold boot entry point&n; * o position DPM window&n; * o place boot instruction (jp addr) at cold boot entry point&n; * o start CPU&n; */
DECL|function|sdla_start
r_static
r_int
id|sdla_start
(paren
id|sdlahw_t
op_star
id|hw
comma
r_int
id|addr
)paren
(brace
r_int
id|port
op_assign
id|hw-&gt;port
suffix:semicolon
r_int
r_char
op_star
id|bootp
suffix:semicolon
r_int
id|err
comma
id|tmp
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;type
)paren
(brace
r_case
id|SDLA_S502A
suffix:colon
id|bootp
op_assign
id|hw-&gt;dpmbase
suffix:semicolon
id|bootp
op_add_assign
l_int|0x66
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S502E
suffix:colon
r_case
id|SDLA_S503
suffix:colon
r_case
id|SDLA_S507
suffix:colon
r_case
id|SDLA_S508
suffix:colon
id|bootp
op_assign
id|hw-&gt;dpmbase
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|err
op_assign
id|sdla_mapmem
c_func
(paren
id|hw
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
op_star
id|bootp
op_assign
l_int|0xC3
suffix:semicolon
multiline_comment|/* Z80: &squot;jp&squot; opcode */
id|bootp
op_increment
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|bootp
)paren
)paren
op_assign
id|addr
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;type
)paren
(brace
r_case
id|SDLA_S502A
suffix:colon
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* issue NMI to CPU */
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
l_int|0x10
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S502E
suffix:colon
id|_OUTB
c_func
(paren
id|port
op_plus
l_int|3
comma
l_int|0x01
)paren
suffix:semicolon
multiline_comment|/* start CPU */
id|hw-&gt;regs
(braket
l_int|3
)braket
op_assign
l_int|0x01
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_INB
c_func
(paren
id|port
)paren
op_amp
l_int|0x01
)paren
multiline_comment|/* verify */
(brace
multiline_comment|/*&n;&t;&t;&t; * Enabling CPU changes functionality of the&n;&t;&t;&t; * control register, so we have to reset its&n;&t;&t;&t; * mirror.&n;&t;&t;&t; */
id|_OUTB
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* disable interrupts */
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S503
suffix:colon
id|tmp
op_assign
id|hw-&gt;regs
(braket
l_int|0
)braket
op_or
l_int|0x09
suffix:semicolon
multiline_comment|/* set bits 0 and 3 */
id|_OUTB
c_func
(paren
id|port
comma
id|tmp
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* update mirror */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|_INB
c_func
(paren
id|port
)paren
op_amp
l_int|0x01
)paren
)paren
multiline_comment|/* verify */
r_return
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S507
suffix:colon
id|tmp
op_assign
id|hw-&gt;regs
(braket
l_int|0
)braket
op_or
l_int|0x02
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
id|tmp
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* update mirror */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|_INB
c_func
(paren
id|port
)paren
op_amp
l_int|0x04
)paren
)paren
multiline_comment|/* verify */
r_return
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SDLA_S508
suffix:colon
id|tmp
op_assign
id|hw-&gt;regs
(braket
l_int|0
)braket
op_or
l_int|0x02
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
id|tmp
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* update mirror */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|_INB
c_func
(paren
id|port
op_plus
l_int|1
)paren
op_amp
l_int|0x02
)paren
)paren
multiline_comment|/* verify */
r_return
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Initialize S502A adapter.&n; */
DECL|function|init_s502a
r_static
r_int
id|init_s502a
(paren
id|sdlahw_t
op_star
id|hw
)paren
(brace
r_int
id|port
op_assign
id|hw-&gt;port
suffix:semicolon
r_int
id|tmp
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|detect_s502a
c_func
(paren
id|port
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
l_int|0x08
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|1
)braket
op_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/* Verify configuration options */
id|i
op_assign
id|get_option_index
c_func
(paren
id|s502a_dpmbase_options
comma
id|virt_to_phys
c_func
(paren
id|hw-&gt;dpmbase
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|tmp
op_assign
id|s502a_hmcr
(braket
id|i
op_minus
l_int|1
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;dpmsize
)paren
(brace
r_case
l_int|0x2000
suffix:colon
id|tmp
op_or_assign
l_int|0x01
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x10000L
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Setup dual-port memory window (this also enables memory access) */
id|_OUTB
c_func
(paren
id|port
op_plus
l_int|1
comma
id|tmp
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|1
)braket
op_assign
id|tmp
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
l_int|0x08
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Initialize S502E adapter.&n; */
DECL|function|init_s502e
r_static
r_int
id|init_s502e
(paren
id|sdlahw_t
op_star
id|hw
)paren
(brace
r_int
id|port
op_assign
id|hw-&gt;port
suffix:semicolon
r_int
id|tmp
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|detect_s502e
c_func
(paren
id|port
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* Verify configuration options */
id|i
op_assign
id|get_option_index
c_func
(paren
id|s508_dpmbase_options
comma
id|virt_to_phys
c_func
(paren
id|hw-&gt;dpmbase
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|tmp
op_assign
id|s502e_hmcr
(braket
id|i
op_minus
l_int|1
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;dpmsize
)paren
(brace
r_case
l_int|0x2000
suffix:colon
id|tmp
op_or_assign
l_int|0x01
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x10000L
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Setup dual-port memory window */
id|_OUTB
c_func
(paren
id|port
op_plus
l_int|1
comma
id|tmp
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|1
)braket
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* Enable memory access */
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x02
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
l_int|0x02
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
r_return
(paren
id|_INB
c_func
(paren
id|port
)paren
op_amp
l_int|0x02
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Initialize S503 adapter.&n; * ---------------------------------------------------------------------------&n; */
DECL|function|init_s503
r_static
r_int
id|init_s503
(paren
id|sdlahw_t
op_star
id|hw
)paren
(brace
r_int
id|port
op_assign
id|hw-&gt;port
suffix:semicolon
r_int
id|tmp
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|detect_s503
c_func
(paren
id|port
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* Verify configuration options */
id|i
op_assign
id|get_option_index
c_func
(paren
id|s508_dpmbase_options
comma
id|virt_to_phys
c_func
(paren
id|hw-&gt;dpmbase
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|tmp
op_assign
id|s502e_hmcr
(braket
id|i
op_minus
l_int|1
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;dpmsize
)paren
(brace
r_case
l_int|0x2000
suffix:colon
id|tmp
op_or_assign
l_int|0x01
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x10000L
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Setup dual-port memory window */
id|_OUTB
c_func
(paren
id|port
op_plus
l_int|1
comma
id|tmp
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|1
)braket
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* Enable memory access */
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x02
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
l_int|0x02
suffix:semicolon
multiline_comment|/* update mirror */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Initialize S507 adapter.&n; */
DECL|function|init_s507
r_static
r_int
id|init_s507
(paren
id|sdlahw_t
op_star
id|hw
)paren
(brace
r_int
id|port
op_assign
id|hw-&gt;port
suffix:semicolon
r_int
id|tmp
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|detect_s507
c_func
(paren
id|port
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* Verify configuration options */
id|i
op_assign
id|get_option_index
c_func
(paren
id|s507_dpmbase_options
comma
id|virt_to_phys
c_func
(paren
id|hw-&gt;dpmbase
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|tmp
op_assign
id|s507_hmcr
(braket
id|i
op_minus
l_int|1
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|hw-&gt;dpmsize
)paren
(brace
r_case
l_int|0x2000
suffix:colon
id|tmp
op_or_assign
l_int|0x01
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x10000L
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Enable adapter&squot;s logic */
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x01
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
l_int|0x01
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
r_if
c_cond
(paren
op_logical_neg
(paren
id|_INB
c_func
(paren
id|port
)paren
op_amp
l_int|0x20
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* Setup dual-port memory window */
id|_OUTB
c_func
(paren
id|port
op_plus
l_int|1
comma
id|tmp
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|1
)braket
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* Enable memory access */
id|tmp
op_assign
id|hw-&gt;regs
(braket
l_int|0
)braket
op_or
l_int|0x04
suffix:semicolon
r_if
c_cond
(paren
id|hw-&gt;irq
)paren
(brace
id|i
op_assign
id|get_option_index
c_func
(paren
id|s508_irq_options
comma
id|hw-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
id|tmp
op_or_assign
id|s507_irqmask
(braket
id|i
op_minus
l_int|1
)braket
suffix:semicolon
)brace
id|_OUTB
c_func
(paren
id|port
comma
id|tmp
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* update mirror */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
r_return
(paren
id|_INB
c_func
(paren
id|port
)paren
op_amp
l_int|0x08
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Initialize S508 adapter.&n; */
DECL|function|init_s508
r_static
r_int
id|init_s508
(paren
id|sdlahw_t
op_star
id|hw
)paren
(brace
r_int
id|port
op_assign
id|hw-&gt;port
suffix:semicolon
r_int
id|tmp
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|detect_s508
c_func
(paren
id|port
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* Verify configuration options */
id|i
op_assign
id|get_option_index
c_func
(paren
id|s508_dpmbase_options
comma
id|virt_to_phys
c_func
(paren
id|hw-&gt;dpmbase
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Setup memory configuration */
id|tmp
op_assign
id|s508_hmcr
(braket
id|i
op_minus
l_int|1
)braket
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
op_plus
l_int|1
comma
id|tmp
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|1
)braket
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* Enable memory access */
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x04
)paren
suffix:semicolon
id|hw-&gt;regs
(braket
l_int|0
)braket
op_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* update mirror */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
r_return
(paren
id|_INB
c_func
(paren
id|port
op_plus
l_int|1
)paren
op_amp
l_int|0x04
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Detect S502A adapter.&n; *&t;Following tests are used to detect S502A adapter:&n; *&t;1. All registers other than status (BASE) should read 0xFF&n; *&t;2. After writing 00001000b to control register, status register should&n; *&t;   read 01000000b.&n; *&t;3. After writing 0 to control register, status register should still&n; *&t;   read  01000000b.&n; *&t;4. After writing 00000100b to control register, status register should&n; *&t;   read 01000100b.&n; *&t;Return 1 if detected o.k. or 0 if failed.&n; *&t;Note:&t;This test is destructive! Adapter will be left in shutdown&n; *&t;&t;state after the test.&n; */
DECL|function|detect_s502a
r_static
r_int
id|detect_s502a
(paren
r_int
id|port
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_option_index
c_func
(paren
id|s502_port_options
comma
id|port
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
OL
id|SDLA_MAXIORANGE
suffix:semicolon
op_increment
id|j
)paren
(brace
r_if
c_cond
(paren
id|_INB
c_func
(paren
id|port
op_plus
id|j
)paren
op_ne
l_int|0xFF
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
)brace
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x08
)paren
suffix:semicolon
multiline_comment|/* halt CPU */
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x08
)paren
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x08
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
r_if
c_cond
(paren
id|_INB
c_func
(paren
id|port
)paren
op_ne
l_int|0x40
)paren
r_return
l_int|0
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x00
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
r_if
c_cond
(paren
id|_INB
c_func
(paren
id|port
)paren
op_ne
l_int|0x40
)paren
r_return
l_int|0
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x04
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
r_if
c_cond
(paren
id|_INB
c_func
(paren
id|port
)paren
op_ne
l_int|0x44
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Reset adapter */
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x08
)paren
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x08
)paren
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x08
)paren
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
op_plus
l_int|1
comma
l_int|0xFF
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Detect S502E adapter.&n; *&t;Following tests are used to verify adapter presence:&n; *&t;1. All registers other than status (BASE) should read 0xFF.&n; *&t;2. After writing 0 to CPU control register (BASE+3), status register&n; *&t;   (BASE) should read 11111000b.&n; *&t;3. After writing 00000100b to port BASE (set bit 2), status register&n; *&t;   (BASE) should read 11111100b.&n; *&t;Return 1 if detected o.k. or 0 if failed.&n; *&t;Note:&t;This test is destructive! Adapter will be left in shutdown&n; *&t;&t;state after the test.&n; */
DECL|function|detect_s502e
r_static
r_int
id|detect_s502e
(paren
r_int
id|port
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_option_index
c_func
(paren
id|s502_port_options
comma
id|port
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
OL
id|SDLA_MAXIORANGE
suffix:semicolon
op_increment
id|j
)paren
(brace
r_if
c_cond
(paren
id|_INB
c_func
(paren
id|port
op_plus
id|j
)paren
op_ne
l_int|0xFF
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
)brace
id|_OUTB
c_func
(paren
id|port
op_plus
l_int|3
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* CPU control reg. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
r_if
c_cond
(paren
id|_INB
c_func
(paren
id|port
)paren
op_ne
l_int|0xF8
)paren
multiline_comment|/* read status */
r_return
l_int|0
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x04
)paren
suffix:semicolon
multiline_comment|/* set bit 2 */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
r_if
c_cond
(paren
id|_INB
c_func
(paren
id|port
)paren
op_ne
l_int|0xFC
)paren
multiline_comment|/* verify */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Reset adapter */
id|_OUTB
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Detect s503 adapter.&n; *&t;Following tests are used to verify adapter presence:&n; *&t;1. All registers other than status (BASE) should read 0xFF.&n; *&t;2. After writing 0 to control register (BASE), status register (BASE)&n; *&t;   should read 11110000b.&n; *&t;3. After writing 00000100b (set bit 2) to control register (BASE),&n; *&t;   status register should read 11110010b.&n; *&t;Return 1 if detected o.k. or 0 if failed.&n; *&t;Note:&t;This test is destructive! Adapter will be left in shutdown&n; *&t;&t;state after the test.&n; */
DECL|function|detect_s503
r_static
r_int
id|detect_s503
(paren
r_int
id|port
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_option_index
c_func
(paren
id|s503_port_options
comma
id|port
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
OL
id|SDLA_MAXIORANGE
suffix:semicolon
op_increment
id|j
)paren
(brace
r_if
c_cond
(paren
id|_INB
c_func
(paren
id|port
op_plus
id|j
)paren
op_ne
l_int|0xFF
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
)brace
id|_OUTB
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* reset control reg.*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
r_if
c_cond
(paren
id|_INB
c_func
(paren
id|port
)paren
op_ne
l_int|0xF0
)paren
multiline_comment|/* read status */
r_return
l_int|0
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x04
)paren
suffix:semicolon
multiline_comment|/* set bit 2 */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
r_if
c_cond
(paren
id|_INB
c_func
(paren
id|port
)paren
op_ne
l_int|0xF2
)paren
multiline_comment|/* verify */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Reset adapter */
id|_OUTB
c_func
(paren
id|port
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Detect s507 adapter.&n; *&t;Following tests are used to detect s507 adapter:&n; *&t;1. All ports should read the same value.&n; *&t;2. After writing 0x00 to control register, status register should read&n; *&t;   ?011000?b.&n; *&t;3. After writing 0x01 to control register, status register should read&n; *&t;   ?011001?b.&n; *&t;Return 1 if detected o.k. or 0 if failed.&n; *&t;Note:&t;This test is destructive! Adapter will be left in shutdown&n; *&t;&t;state after the test.&n; */
DECL|function|detect_s507
r_static
r_int
id|detect_s507
(paren
r_int
id|port
)paren
(brace
r_int
id|tmp
comma
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_option_index
c_func
(paren
id|s508_port_options
comma
id|port
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|tmp
op_assign
id|_INB
c_func
(paren
id|port
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
OL
id|S507_IORANGE
suffix:semicolon
op_increment
id|j
)paren
(brace
r_if
c_cond
(paren
id|_INB
c_func
(paren
id|port
op_plus
id|j
)paren
op_ne
id|tmp
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
)brace
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x00
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
r_if
c_cond
(paren
(paren
id|_INB
c_func
(paren
id|port
)paren
op_amp
l_int|0x7E
)paren
op_ne
l_int|0x30
)paren
r_return
l_int|0
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x01
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
r_if
c_cond
(paren
(paren
id|_INB
c_func
(paren
id|port
)paren
op_amp
l_int|0x7E
)paren
op_ne
l_int|0x32
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Reset adapter */
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x00
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Detect s508 adapter.&n; *&t;Following tests are used to detect s508 adapter:&n; *&t;1. After writing 0x00 to control register, status register should read&n; *&t;   ??000000b.&n; *&t;2. After writing 0x10 to control register, status register should read&n; *&t;   ??010000b&n; *&t;Return 1 if detected o.k. or 0 if failed.&n; *&t;Note:&t;This test is destructive! Adapter will be left in shutdown&n; *&t;&t;state after the test.&n; */
DECL|function|detect_s508
r_static
r_int
id|detect_s508
(paren
r_int
id|port
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_option_index
c_func
(paren
id|s508_port_options
comma
id|port
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x00
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
r_if
c_cond
(paren
(paren
id|_INB
c_func
(paren
id|port
op_plus
l_int|1
)paren
op_amp
l_int|0x3F
)paren
op_ne
l_int|0x00
)paren
r_return
l_int|0
suffix:semicolon
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x10
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SDLA_IODELAY
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
multiline_comment|/* delay */
r_if
c_cond
(paren
(paren
id|_INB
c_func
(paren
id|port
op_plus
l_int|1
)paren
op_amp
l_int|0x3F
)paren
op_ne
l_int|0x10
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Reset adapter */
id|_OUTB
c_func
(paren
id|port
comma
l_int|0x00
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/******* Miscellaneous ******************************************************/
multiline_comment|/*============================================================================&n; * Calibrate SDLA memory access delay.&n; * Count number of idle loops made within 1 second and then calculate the&n; * number of loops that should be made to achive desired delay.&n; */
DECL|function|calibrate_delay
r_static
r_int
id|calibrate_delay
(paren
r_int
id|mks
)paren
(brace
r_int
r_int
id|delay
suffix:semicolon
r_int
r_int
id|stop
suffix:semicolon
r_for
c_loop
(paren
id|delay
op_assign
l_int|0
comma
id|stop
op_assign
id|SYSTEM_TICK
op_plus
id|HZ
suffix:semicolon
id|SYSTEM_TICK
OL
id|stop
suffix:semicolon
op_increment
id|delay
)paren
suffix:semicolon
r_return
(paren
id|delay
op_div
(paren
l_int|1000000L
op_div
id|mks
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Get option&squot;s index into the options list.&n; *&t;Return option&squot;s index (1 .. N) or zero if option is invalid.&n; */
DECL|function|get_option_index
r_static
r_int
id|get_option_index
(paren
r_int
op_star
id|optlist
comma
r_int
id|optval
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|optlist
(braket
l_int|0
)braket
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|optlist
(braket
id|i
)braket
op_eq
id|optval
)paren
r_return
id|i
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Check memory region to see if it&squot;s available. &n; * Return:&t;0&t;ok.&n; */
DECL|function|check_memregion
r_static
r_int
id|check_memregion
(paren
r_void
op_star
id|ptr
comma
r_int
id|len
)paren
(brace
r_volatile
r_int
r_char
op_star
id|p
op_assign
id|ptr
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|len
op_logical_and
(paren
op_star
id|p
op_eq
l_int|0xFF
)paren
suffix:semicolon
op_decrement
id|len
comma
op_increment
id|p
)paren
(brace
op_star
id|p
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* attempt to write 0 */
r_if
c_cond
(paren
op_star
id|p
op_ne
l_int|0xFF
)paren
multiline_comment|/* still has to read 0xFF */
(brace
op_star
id|p
op_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/* restore original value */
r_break
suffix:semicolon
multiline_comment|/* not good */
)brace
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Test memory region.&n; * Return:&t;size of the region that passed the test.&n; * Note:&t;Region size must be multiple of 2 !&n; */
DECL|function|test_memregion
r_static
r_int
id|test_memregion
(paren
r_void
op_star
id|ptr
comma
r_int
id|len
)paren
(brace
r_volatile
r_int
r_int
op_star
id|w_ptr
suffix:semicolon
r_int
id|len_w
op_assign
id|len
op_rshift
l_int|1
suffix:semicolon
multiline_comment|/* region len in words */
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|w_ptr
op_assign
id|ptr
suffix:semicolon
id|i
OL
id|len_w
suffix:semicolon
op_increment
id|i
comma
op_increment
id|w_ptr
)paren
op_star
id|w_ptr
op_assign
l_int|0xAA55
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|w_ptr
op_assign
id|ptr
suffix:semicolon
id|i
OL
id|len_w
suffix:semicolon
op_increment
id|i
comma
op_increment
id|w_ptr
)paren
r_if
c_cond
(paren
op_star
id|w_ptr
op_ne
l_int|0xAA55
)paren
(brace
id|len_w
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|w_ptr
op_assign
id|ptr
suffix:semicolon
id|i
OL
id|len_w
suffix:semicolon
op_increment
id|i
comma
op_increment
id|w_ptr
)paren
op_star
id|w_ptr
op_assign
l_int|0x55AA
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|w_ptr
op_assign
id|ptr
suffix:semicolon
id|i
OL
id|len_w
suffix:semicolon
op_increment
id|i
comma
op_increment
id|w_ptr
)paren
r_if
c_cond
(paren
op_star
id|w_ptr
op_ne
l_int|0x55AA
)paren
(brace
id|len_w
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|w_ptr
op_assign
id|ptr
suffix:semicolon
id|i
OL
id|len_w
suffix:semicolon
op_increment
id|i
comma
op_increment
id|w_ptr
)paren
op_star
id|w_ptr
op_assign
l_int|0
suffix:semicolon
r_return
id|len_w
op_lshift
l_int|1
suffix:semicolon
)brace
multiline_comment|/*============================================================================&n; * Calculate 16-bit CRC using CCITT polynomial.&n; */
DECL|function|checksum
r_static
r_int
r_int
id|checksum
(paren
r_int
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|crc
op_assign
l_int|0
suffix:semicolon
r_int
id|mask
comma
id|flag
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|len
suffix:semicolon
op_decrement
id|len
comma
op_increment
id|buf
)paren
(brace
r_for
c_loop
(paren
id|mask
op_assign
l_int|0x80
suffix:semicolon
id|mask
suffix:semicolon
id|mask
op_rshift_assign
l_int|1
)paren
(brace
id|flag
op_assign
(paren
id|crc
op_amp
l_int|0x8000
)paren
suffix:semicolon
id|crc
op_lshift_assign
l_int|1
suffix:semicolon
id|crc
op_or_assign
(paren
(paren
op_star
id|buf
op_amp
id|mask
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
id|crc
op_xor_assign
l_int|0x1021
suffix:semicolon
)brace
)brace
r_return
id|crc
suffix:semicolon
)brace
multiline_comment|/****** End *****************************************************************/
eof
