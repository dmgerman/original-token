multiline_comment|/* myri_sbus.h: MyriCOM MyriNET SBUS card driver.&n; *&n; * Copyright (C) 1996, 1999 David S. Miller (davem@redhat.com)&n; */
DECL|variable|version
r_static
r_char
op_star
id|version
op_assign
l_string|&quot;myri_sbus.c:v1.9 12/Sep/99 David S. Miller (davem@redhat.com)&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/idprom.h&gt;
macro_line|#include &lt;asm/sbus.h&gt;
macro_line|#include &lt;asm/openprom.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/auxio.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;net/dst.h&gt;
macro_line|#include &lt;net/arp.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;net/ipv6.h&gt;
macro_line|#include &lt;asm/checksum.h&gt;
macro_line|#include &quot;myri_sbus.h&quot;
macro_line|#include &quot;myri_code.h&quot;
multiline_comment|/* #define DEBUG_DETECT */
multiline_comment|/* #define DEBUG_IRQ */
multiline_comment|/* #define DEBUG_TRANSMIT */
multiline_comment|/* #define DEBUG_RECEIVE */
multiline_comment|/* #define DEBUG_HEADER */
macro_line|#ifdef DEBUG_DETECT
DECL|macro|DET
mdefine_line|#define DET(x)   printk x
macro_line|#else
DECL|macro|DET
mdefine_line|#define DET(x)
macro_line|#endif
macro_line|#ifdef DEBUG_IRQ
DECL|macro|DIRQ
mdefine_line|#define DIRQ(x)  printk x
macro_line|#else
DECL|macro|DIRQ
mdefine_line|#define DIRQ(x)
macro_line|#endif
macro_line|#ifdef DEBUG_TRANSMIT
DECL|macro|DTX
mdefine_line|#define DTX(x)  printk x
macro_line|#else
DECL|macro|DTX
mdefine_line|#define DTX(x)
macro_line|#endif
macro_line|#ifdef DEBUG_RECEIVE
DECL|macro|DRX
mdefine_line|#define DRX(x)  printk x
macro_line|#else
DECL|macro|DRX
mdefine_line|#define DRX(x)
macro_line|#endif
macro_line|#ifdef DEBUG_HEADER
DECL|macro|DHDR
mdefine_line|#define DHDR(x) printk x
macro_line|#else
DECL|macro|DHDR
mdefine_line|#define DHDR(x)
macro_line|#endif
macro_line|#ifdef MODULE
DECL|variable|root_myri_dev
r_static
r_struct
id|myri_eth
op_star
id|root_myri_dev
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
DECL|function|myri_reset_off
r_static
r_void
id|myri_reset_off
c_func
(paren
r_int
r_int
id|lp
comma
r_int
r_int
id|cregs
)paren
(brace
multiline_comment|/* Clear IRQ mask. */
id|sbus_writel
c_func
(paren
l_int|0
comma
id|lp
op_plus
id|LANAI_EIMASK
)paren
suffix:semicolon
multiline_comment|/* Turn RESET function off. */
id|sbus_writel
c_func
(paren
id|CONTROL_ROFF
comma
id|cregs
op_plus
id|MYRICTRL_CTRL
)paren
suffix:semicolon
)brace
DECL|function|myri_reset_on
r_static
r_void
id|myri_reset_on
c_func
(paren
r_int
r_int
id|cregs
)paren
(brace
multiline_comment|/* Enable RESET function. */
id|sbus_writel
c_func
(paren
id|CONTROL_RON
comma
id|cregs
op_plus
id|MYRICTRL_CTRL
)paren
suffix:semicolon
multiline_comment|/* Disable IRQ&squot;s. */
id|sbus_writel
c_func
(paren
id|CONTROL_DIRQ
comma
id|cregs
op_plus
id|MYRICTRL_CTRL
)paren
suffix:semicolon
)brace
DECL|function|myri_disable_irq
r_static
r_void
id|myri_disable_irq
c_func
(paren
r_int
r_int
id|lp
comma
r_int
r_int
id|cregs
)paren
(brace
id|sbus_writel
c_func
(paren
id|CONTROL_DIRQ
comma
id|cregs
op_plus
id|MYRICTRL_CTRL
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
l_int|0
comma
id|lp
op_plus
id|LANAI_EIMASK
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|ISTAT_HOST
comma
id|lp
op_plus
id|LANAI_ISTAT
)paren
suffix:semicolon
)brace
DECL|function|myri_enable_irq
r_static
r_void
id|myri_enable_irq
c_func
(paren
r_int
r_int
id|lp
comma
r_int
r_int
id|cregs
)paren
(brace
id|sbus_writel
c_func
(paren
id|CONTROL_EIRQ
comma
id|cregs
op_plus
id|MYRICTRL_CTRL
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|ISTAT_HOST
comma
id|lp
op_plus
id|LANAI_EIMASK
)paren
suffix:semicolon
)brace
DECL|function|bang_the_chip
r_static
r_inline
r_void
id|bang_the_chip
c_func
(paren
r_struct
id|myri_eth
op_star
id|mp
)paren
(brace
r_struct
id|myri_shmem
op_star
id|shmem
op_assign
id|mp-&gt;shmem
suffix:semicolon
r_int
r_int
id|cregs
op_assign
id|mp-&gt;cregs
suffix:semicolon
id|sbus_writel
c_func
(paren
l_int|1
comma
op_amp
id|shmem-&gt;send
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|CONTROL_WON
comma
id|cregs
op_plus
id|MYRICTRL_CTRL
)paren
suffix:semicolon
)brace
DECL|function|myri_do_handshake
r_static
r_int
id|myri_do_handshake
c_func
(paren
r_struct
id|myri_eth
op_star
id|mp
)paren
(brace
r_struct
id|myri_shmem
op_star
id|shmem
op_assign
id|mp-&gt;shmem
suffix:semicolon
r_int
r_int
id|cregs
op_assign
id|mp-&gt;cregs
suffix:semicolon
r_struct
id|myri_channel
op_star
id|chan
op_assign
op_amp
id|shmem-&gt;channel
suffix:semicolon
r_int
id|tick
op_assign
l_int|0
suffix:semicolon
id|DET
c_func
(paren
(paren
l_string|&quot;myri_do_handshake: &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sbus_readl
c_func
(paren
op_amp
id|chan-&gt;state
)paren
op_eq
id|STATE_READY
)paren
(brace
id|DET
c_func
(paren
(paren
l_string|&quot;Already STATE_READY, failed.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* We&squot;re hosed... */
)brace
id|myri_disable_irq
c_func
(paren
id|mp-&gt;lregs
comma
id|cregs
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tick
op_increment
op_le
l_int|25
)paren
(brace
id|u32
id|softstate
suffix:semicolon
multiline_comment|/* Wake it up. */
id|DET
c_func
(paren
(paren
l_string|&quot;shakedown, CONTROL_WON, &quot;
)paren
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
l_int|1
comma
op_amp
id|shmem-&gt;shakedown
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|CONTROL_WON
comma
id|cregs
op_plus
id|MYRICTRL_CTRL
)paren
suffix:semicolon
id|softstate
op_assign
id|sbus_readl
c_func
(paren
op_amp
id|chan-&gt;state
)paren
suffix:semicolon
id|DET
c_func
(paren
(paren
l_string|&quot;chanstate[%08x] &quot;
comma
id|softstate
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|softstate
op_eq
id|STATE_READY
)paren
(brace
id|DET
c_func
(paren
(paren
l_string|&quot;wakeup successful, &quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|softstate
op_ne
id|STATE_WFN
)paren
(brace
id|DET
c_func
(paren
(paren
l_string|&quot;not WFN setting that, &quot;
)paren
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|STATE_WFN
comma
op_amp
id|chan-&gt;state
)paren
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
)brace
id|myri_enable_irq
c_func
(paren
id|mp-&gt;lregs
comma
id|cregs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tick
OG
l_int|25
)paren
(brace
id|DET
c_func
(paren
(paren
l_string|&quot;25 ticks we lose, failure.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|DET
c_func
(paren
(paren
l_string|&quot;success&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|myri_load_lanai
r_static
r_int
id|myri_load_lanai
c_func
(paren
r_struct
id|myri_eth
op_star
id|mp
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|mp-&gt;dev
suffix:semicolon
r_struct
id|myri_shmem
op_star
id|shmem
op_assign
id|mp-&gt;shmem
suffix:semicolon
r_int
r_char
op_star
id|rptr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|myri_disable_irq
c_func
(paren
id|mp-&gt;lregs
comma
id|mp-&gt;cregs
)paren
suffix:semicolon
id|myri_reset_on
c_func
(paren
id|mp-&gt;cregs
)paren
suffix:semicolon
id|rptr
op_assign
(paren
r_int
r_char
op_star
)paren
id|mp-&gt;lanai
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mp-&gt;eeprom.ramsz
suffix:semicolon
id|i
op_increment
)paren
id|sbus_writeb
c_func
(paren
l_int|0
comma
op_amp
id|rptr
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;eeprom.cpuvers
op_ge
id|CPUVERS_3_0
)paren
id|sbus_writel
c_func
(paren
id|mp-&gt;eeprom.cval
comma
id|mp-&gt;lregs
op_plus
id|LANAI_CVAL
)paren
suffix:semicolon
multiline_comment|/* Load executable code. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|lanai4_code
)paren
suffix:semicolon
id|i
op_increment
)paren
id|sbus_writeb
c_func
(paren
id|lanai4_code
(braket
id|i
)braket
comma
op_amp
id|rptr
(braket
(paren
id|lanai4_code_off
op_star
l_int|2
)paren
op_plus
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Load data segment. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|lanai4_data
)paren
suffix:semicolon
id|i
op_increment
)paren
id|sbus_writeb
c_func
(paren
id|lanai4_data
(braket
id|i
)braket
comma
op_amp
id|rptr
(braket
(paren
id|lanai4_data_off
op_star
l_int|2
)paren
op_plus
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* Set device address. */
id|sbus_writeb
c_func
(paren
l_int|0
comma
op_amp
id|shmem-&gt;addr
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|sbus_writeb
c_func
(paren
l_int|0
comma
op_amp
id|shmem-&gt;addr
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|sbus_writeb
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
op_amp
id|shmem-&gt;addr
(braket
id|i
op_plus
l_int|2
)braket
)paren
suffix:semicolon
multiline_comment|/* Set SBUS bursts and interrupt mask. */
id|sbus_writel
c_func
(paren
(paren
(paren
id|mp-&gt;myri_bursts
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
)paren
comma
op_amp
id|shmem-&gt;burst
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|SHMEM_IMASK_RX
comma
op_amp
id|shmem-&gt;imask
)paren
suffix:semicolon
multiline_comment|/* Release the LANAI. */
id|myri_disable_irq
c_func
(paren
id|mp-&gt;lregs
comma
id|mp-&gt;cregs
)paren
suffix:semicolon
id|myri_reset_off
c_func
(paren
id|mp-&gt;lregs
comma
id|mp-&gt;cregs
)paren
suffix:semicolon
id|myri_disable_irq
c_func
(paren
id|mp-&gt;lregs
comma
id|mp-&gt;cregs
)paren
suffix:semicolon
multiline_comment|/* Wait for the reset to complete. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5000
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sbus_readl
c_func
(paren
op_amp
id|shmem-&gt;channel.state
)paren
op_ne
id|STATE_READY
)paren
r_break
suffix:semicolon
r_else
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|5000
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;myricom: Chip would not reset after firmware load.&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
id|myri_do_handshake
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;myricom: Handshake with LANAI failed.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;eeprom.cpuvers
op_eq
id|CPUVERS_4_0
)paren
id|sbus_writel
c_func
(paren
l_int|0
comma
id|mp-&gt;lregs
op_plus
id|LANAI_VERS
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|myri_clean_rings
r_static
r_void
id|myri_clean_rings
c_func
(paren
r_struct
id|myri_eth
op_star
id|mp
)paren
(brace
r_struct
id|sendq
op_star
id|sq
op_assign
id|mp-&gt;sq
suffix:semicolon
r_struct
id|recvq
op_star
id|rq
op_assign
id|mp-&gt;rq
suffix:semicolon
r_int
id|i
suffix:semicolon
id|sbus_writel
c_func
(paren
l_int|0
comma
op_amp
id|rq-&gt;tail
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
l_int|0
comma
op_amp
id|rq-&gt;head
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|RX_RING_SIZE
op_plus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;rx_skbs
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
r_struct
id|myri_rxd
op_star
id|rxd
op_assign
op_amp
id|rq-&gt;myri_rxd
(braket
id|i
)braket
suffix:semicolon
id|u32
id|dma_addr
suffix:semicolon
id|dma_addr
op_assign
id|sbus_readl
c_func
(paren
op_amp
id|rxd-&gt;myri_scatters
(braket
l_int|0
)braket
dot
id|addr
)paren
suffix:semicolon
id|sbus_unmap_single
c_func
(paren
id|mp-&gt;myri_sdev
comma
id|dma_addr
comma
id|RX_ALLOC_SIZE
comma
id|SBUS_DMA_FROMDEVICE
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|mp-&gt;rx_skbs
(braket
id|i
)braket
)paren
suffix:semicolon
id|mp-&gt;rx_skbs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|mp-&gt;tx_old
op_assign
l_int|0
suffix:semicolon
id|sbus_writel
c_func
(paren
l_int|0
comma
op_amp
id|sq-&gt;tail
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
l_int|0
comma
op_amp
id|sq-&gt;head
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;tx_skbs
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|mp-&gt;tx_skbs
(braket
id|i
)braket
suffix:semicolon
r_struct
id|myri_txd
op_star
id|txd
op_assign
op_amp
id|sq-&gt;myri_txd
(braket
id|i
)braket
suffix:semicolon
id|u32
id|dma_addr
suffix:semicolon
id|dma_addr
op_assign
id|sbus_readl
c_func
(paren
op_amp
id|txd-&gt;myri_gathers
(braket
l_int|0
)braket
dot
id|addr
)paren
suffix:semicolon
id|sbus_unmap_single
c_func
(paren
id|mp-&gt;myri_sdev
comma
id|dma_addr
comma
(paren
id|skb-&gt;len
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
comma
id|SBUS_DMA_TODEVICE
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|mp-&gt;tx_skbs
(braket
id|i
)braket
)paren
suffix:semicolon
id|mp-&gt;tx_skbs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
DECL|function|myri_init_rings
r_static
r_void
id|myri_init_rings
c_func
(paren
r_struct
id|myri_eth
op_star
id|mp
comma
r_int
id|from_irq
)paren
(brace
r_struct
id|recvq
op_star
id|rq
op_assign
id|mp-&gt;rq
suffix:semicolon
r_struct
id|myri_rxd
op_star
id|rxd
op_assign
op_amp
id|rq-&gt;myri_rxd
(braket
l_int|0
)braket
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|mp-&gt;dev
suffix:semicolon
r_int
id|gfp_flags
op_assign
id|GFP_KERNEL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|from_irq
op_logical_or
id|in_interrupt
c_func
(paren
)paren
)paren
id|gfp_flags
op_assign
id|GFP_ATOMIC
suffix:semicolon
id|myri_clean_rings
c_func
(paren
id|mp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|myri_alloc_skb
c_func
(paren
id|RX_ALLOC_SIZE
comma
id|gfp_flags
)paren
suffix:semicolon
id|u32
id|dma_addr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb
)paren
r_continue
suffix:semicolon
id|mp-&gt;rx_skbs
(braket
id|i
)braket
op_assign
id|skb
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_put
c_func
(paren
id|skb
comma
id|RX_ALLOC_SIZE
)paren
suffix:semicolon
id|dma_addr
op_assign
id|sbus_map_single
c_func
(paren
id|mp-&gt;myri_sdev
comma
id|skb-&gt;data
comma
id|RX_ALLOC_SIZE
comma
id|SBUS_DMA_FROMDEVICE
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|dma_addr
comma
op_amp
id|rxd
(braket
id|i
)braket
dot
id|myri_scatters
(braket
l_int|0
)braket
dot
id|addr
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|RX_ALLOC_SIZE
comma
op_amp
id|rxd
(braket
id|i
)braket
dot
id|myri_scatters
(braket
l_int|0
)braket
dot
id|len
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|i
comma
op_amp
id|rxd
(braket
id|i
)braket
dot
id|ctx
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
l_int|1
comma
op_amp
id|rxd
(braket
id|i
)braket
dot
id|num_sg
)paren
suffix:semicolon
)brace
id|sbus_writel
c_func
(paren
l_int|0
comma
op_amp
id|rq-&gt;head
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|RX_RING_SIZE
comma
op_amp
id|rq-&gt;tail
)paren
suffix:semicolon
)brace
DECL|function|myri_init
r_static
r_int
id|myri_init
c_func
(paren
r_struct
id|myri_eth
op_star
id|mp
comma
r_int
id|from_irq
)paren
(brace
id|myri_init_rings
c_func
(paren
id|mp
comma
id|from_irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|myri_is_not_so_happy
r_static
r_void
id|myri_is_not_so_happy
c_func
(paren
r_struct
id|myri_eth
op_star
id|mp
)paren
(brace
)brace
macro_line|#ifdef DEBUG_HEADER
DECL|function|dump_ehdr
r_static
r_void
id|dump_ehdr
c_func
(paren
r_struct
id|ethhdr
op_star
id|ehdr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ehdr[h_dst(%02x:%02x:%02x:%02x:%02x:%02x)&quot;
l_string|&quot;h_source(%02x:%02x:%02x:%02x:%02x:%02x)h_proto(%04x)]&bslash;n&quot;
comma
id|ehdr-&gt;h_dest
(braket
l_int|0
)braket
comma
id|ehdr-&gt;h_dest
(braket
l_int|1
)braket
comma
id|ehdr-&gt;h_dest
(braket
l_int|2
)braket
comma
id|ehdr-&gt;h_dest
(braket
l_int|3
)braket
comma
id|ehdr-&gt;h_dest
(braket
l_int|4
)braket
comma
id|ehdr-&gt;h_dest
(braket
l_int|4
)braket
comma
id|ehdr-&gt;h_source
(braket
l_int|0
)braket
comma
id|ehdr-&gt;h_source
(braket
l_int|1
)braket
comma
id|ehdr-&gt;h_source
(braket
l_int|2
)braket
comma
id|ehdr-&gt;h_source
(braket
l_int|3
)braket
comma
id|ehdr-&gt;h_source
(braket
l_int|4
)braket
comma
id|ehdr-&gt;h_source
(braket
l_int|4
)braket
comma
id|ehdr-&gt;h_proto
)paren
suffix:semicolon
)brace
DECL|function|dump_ehdr_and_myripad
r_static
r_void
id|dump_ehdr_and_myripad
c_func
(paren
r_int
r_char
op_star
id|stuff
)paren
(brace
r_struct
id|ethhdr
op_star
id|ehdr
op_assign
(paren
r_struct
id|ethhdr
op_star
)paren
(paren
id|stuff
op_plus
l_int|2
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;pad[%02x:%02x]&quot;
comma
id|stuff
(braket
l_int|0
)braket
comma
id|stuff
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ehdr[h_dst(%02x:%02x:%02x:%02x:%02x:%02x)&quot;
l_string|&quot;h_source(%02x:%02x:%02x:%02x:%02x:%02x)h_proto(%04x)]&bslash;n&quot;
comma
id|ehdr-&gt;h_dest
(braket
l_int|0
)braket
comma
id|ehdr-&gt;h_dest
(braket
l_int|1
)braket
comma
id|ehdr-&gt;h_dest
(braket
l_int|2
)braket
comma
id|ehdr-&gt;h_dest
(braket
l_int|3
)braket
comma
id|ehdr-&gt;h_dest
(braket
l_int|4
)braket
comma
id|ehdr-&gt;h_dest
(braket
l_int|4
)braket
comma
id|ehdr-&gt;h_source
(braket
l_int|0
)braket
comma
id|ehdr-&gt;h_source
(braket
l_int|1
)braket
comma
id|ehdr-&gt;h_source
(braket
l_int|2
)braket
comma
id|ehdr-&gt;h_source
(braket
l_int|3
)braket
comma
id|ehdr-&gt;h_source
(braket
l_int|4
)braket
comma
id|ehdr-&gt;h_source
(braket
l_int|4
)braket
comma
id|ehdr-&gt;h_proto
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|myri_tx
r_static
r_void
id|myri_tx
c_func
(paren
r_struct
id|myri_eth
op_star
id|mp
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sendq
op_star
id|sq
op_assign
id|mp-&gt;sq
suffix:semicolon
r_int
id|entry
op_assign
id|mp-&gt;tx_old
suffix:semicolon
r_int
id|limit
op_assign
id|sbus_readl
c_func
(paren
op_amp
id|sq-&gt;head
)paren
suffix:semicolon
id|DTX
c_func
(paren
(paren
l_string|&quot;entry[%d] limit[%d] &quot;
comma
id|entry
comma
id|limit
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
id|limit
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|entry
op_ne
id|limit
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|mp-&gt;tx_skbs
(braket
id|entry
)braket
suffix:semicolon
id|u32
id|dma_addr
suffix:semicolon
id|DTX
c_func
(paren
(paren
l_string|&quot;SKB[%d] &quot;
comma
id|entry
)paren
)paren
suffix:semicolon
id|dma_addr
op_assign
id|sbus_readl
c_func
(paren
op_amp
id|sq-&gt;myri_txd
(braket
id|entry
)braket
dot
id|myri_gathers
(braket
l_int|0
)braket
dot
id|addr
)paren
suffix:semicolon
id|sbus_unmap_single
c_func
(paren
id|mp-&gt;myri_sdev
comma
id|dma_addr
comma
id|skb-&gt;len
comma
id|SBUS_DMA_TODEVICE
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|mp-&gt;tx_skbs
(braket
id|entry
)braket
op_assign
l_int|NULL
suffix:semicolon
id|mp-&gt;enet_stats.tx_packets
op_increment
suffix:semicolon
id|entry
op_assign
id|NEXT_TX
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
id|mp-&gt;tx_old
op_assign
id|entry
suffix:semicolon
)brace
multiline_comment|/* Determine the packet&squot;s protocol ID. The rule here is that we &n; * assume 802.3 if the type field is short enough to be a length.&n; * This is normal practice and works for any &squot;now in use&squot; protocol.&n; */
DECL|function|myri_type_trans
r_static
r_int
r_int
id|myri_type_trans
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ethhdr
op_star
id|eth
suffix:semicolon
r_int
r_char
op_star
id|rawp
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|skb-&gt;data
)paren
op_plus
id|MYRI_PAD_LEN
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
id|dev-&gt;hard_header_len
)paren
suffix:semicolon
id|eth
op_assign
id|skb-&gt;mac.ethernet
suffix:semicolon
macro_line|#ifdef DEBUG_HEADER
id|DHDR
c_func
(paren
(paren
l_string|&quot;myri_type_trans: &quot;
)paren
)paren
suffix:semicolon
id|dump_ehdr
c_func
(paren
id|eth
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_star
id|eth-&gt;h_dest
op_amp
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|eth-&gt;h_dest
comma
id|dev-&gt;broadcast
comma
id|ETH_ALEN
)paren
op_eq
l_int|0
)paren
id|skb-&gt;pkt_type
op_assign
id|PACKET_BROADCAST
suffix:semicolon
r_else
id|skb-&gt;pkt_type
op_assign
id|PACKET_MULTICAST
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
(paren
id|IFF_PROMISC
op_or
id|IFF_ALLMULTI
)paren
)paren
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|eth-&gt;h_dest
comma
id|dev-&gt;dev_addr
comma
id|ETH_ALEN
)paren
)paren
id|skb-&gt;pkt_type
op_assign
id|PACKET_OTHERHOST
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ntohs
c_func
(paren
id|eth-&gt;h_proto
)paren
op_ge
l_int|1536
)paren
r_return
id|eth-&gt;h_proto
suffix:semicolon
id|rawp
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* This is a magic hack to spot IPX packets. Older Novell breaks&n;&t; * the protocol design and runs IPX over 802.3 without an 802.2 LLC&n;&t; * layer. We look for FFFF which isn&squot;t a used 802.2 SSAP/DSAP. This&n;&t; * won&squot;t work for fault tolerant netware but does for the rest.&n;&t; */
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|rawp
op_eq
l_int|0xFFFF
)paren
r_return
id|htons
c_func
(paren
id|ETH_P_802_3
)paren
suffix:semicolon
multiline_comment|/* Real 802.2 LLC */
r_return
id|htons
c_func
(paren
id|ETH_P_802_2
)paren
suffix:semicolon
)brace
DECL|function|myri_rx
r_static
r_void
id|myri_rx
c_func
(paren
r_struct
id|myri_eth
op_star
id|mp
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|recvq
op_star
id|rq
op_assign
id|mp-&gt;rq
suffix:semicolon
r_struct
id|recvq
op_star
id|rqa
op_assign
id|mp-&gt;rqack
suffix:semicolon
r_int
id|entry
op_assign
id|sbus_readl
c_func
(paren
op_amp
id|rqa-&gt;head
)paren
suffix:semicolon
r_int
id|limit
op_assign
id|sbus_readl
c_func
(paren
op_amp
id|rqa-&gt;tail
)paren
suffix:semicolon
r_int
id|drops
suffix:semicolon
id|DRX
c_func
(paren
(paren
l_string|&quot;entry[%d] limit[%d] &quot;
comma
id|entry
comma
id|limit
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
id|limit
)paren
r_return
suffix:semicolon
id|drops
op_assign
l_int|0
suffix:semicolon
id|DRX
c_func
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|entry
op_ne
id|limit
)paren
(brace
r_struct
id|myri_rxd
op_star
id|rxdack
op_assign
op_amp
id|rqa-&gt;myri_rxd
(braket
id|entry
)braket
suffix:semicolon
id|u32
id|csum
op_assign
id|sbus_readl
c_func
(paren
op_amp
id|rxdack-&gt;csum
)paren
suffix:semicolon
r_int
id|len
op_assign
id|sbus_readl
c_func
(paren
op_amp
id|rxdack-&gt;myri_scatters
(braket
l_int|0
)braket
dot
id|len
)paren
suffix:semicolon
r_int
id|index
op_assign
id|sbus_readl
c_func
(paren
op_amp
id|rxdack-&gt;ctx
)paren
suffix:semicolon
r_struct
id|myri_rxd
op_star
id|rxd
op_assign
op_amp
id|rq-&gt;myri_rxd
(braket
id|rq-&gt;tail
)braket
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|mp-&gt;rx_skbs
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/* Ack it. */
id|sbus_writel
c_func
(paren
id|NEXT_RX
c_func
(paren
id|entry
)paren
comma
op_amp
id|rqa-&gt;head
)paren
suffix:semicolon
multiline_comment|/* Check for errors. */
id|DRX
c_func
(paren
(paren
l_string|&quot;rxd[%d]: %p len[%d] csum[%08x] &quot;
comma
id|entry
comma
id|rxd
comma
id|len
comma
id|csum
)paren
)paren
suffix:semicolon
id|sbus_dma_sync_single
c_func
(paren
id|mp-&gt;myri_sdev
comma
id|sbus_readl
c_func
(paren
op_amp
id|rxd-&gt;myri_scatters
(braket
l_int|0
)braket
dot
id|addr
)paren
comma
id|RX_ALLOC_SIZE
comma
id|SBUS_DMA_FROMDEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
(paren
id|ETH_HLEN
op_plus
id|MYRI_PAD_LEN
)paren
op_logical_or
(paren
id|skb-&gt;data
(braket
l_int|0
)braket
op_ne
id|MYRI_PAD_LEN
)paren
)paren
(brace
id|DRX
c_func
(paren
(paren
l_string|&quot;ERROR[&quot;
)paren
)paren
suffix:semicolon
id|mp-&gt;enet_stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
(paren
id|ETH_HLEN
op_plus
id|MYRI_PAD_LEN
)paren
)paren
(brace
id|DRX
c_func
(paren
(paren
l_string|&quot;BAD_LENGTH] &quot;
)paren
)paren
suffix:semicolon
id|mp-&gt;enet_stats.rx_length_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
id|DRX
c_func
(paren
(paren
l_string|&quot;NO_PADDING] &quot;
)paren
)paren
suffix:semicolon
id|mp-&gt;enet_stats.rx_frame_errors
op_increment
suffix:semicolon
)brace
multiline_comment|/* Return it to the LANAI. */
id|drop_it
suffix:colon
id|drops
op_increment
suffix:semicolon
id|DRX
c_func
(paren
(paren
l_string|&quot;DROP &quot;
)paren
)paren
suffix:semicolon
id|mp-&gt;enet_stats.rx_dropped
op_increment
suffix:semicolon
id|sbus_writel
c_func
(paren
id|RX_ALLOC_SIZE
comma
op_amp
id|rxd-&gt;myri_scatters
(braket
l_int|0
)braket
dot
id|len
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|index
comma
op_amp
id|rxd-&gt;ctx
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
l_int|1
comma
op_amp
id|rxd-&gt;num_sg
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|NEXT_RX
c_func
(paren
id|sbus_readl
c_func
(paren
op_amp
id|rq-&gt;tail
)paren
)paren
comma
op_amp
id|rq-&gt;tail
)paren
suffix:semicolon
r_goto
id|next
suffix:semicolon
)brace
id|DRX
c_func
(paren
(paren
l_string|&quot;len[%d] &quot;
comma
id|len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|RX_COPY_THRESHOLD
)paren
(brace
r_struct
id|sk_buff
op_star
id|new_skb
suffix:semicolon
id|u32
id|dma_addr
suffix:semicolon
id|DRX
c_func
(paren
(paren
l_string|&quot;BIGBUFF &quot;
)paren
)paren
suffix:semicolon
id|new_skb
op_assign
id|myri_alloc_skb
c_func
(paren
id|RX_ALLOC_SIZE
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_skb
op_eq
l_int|NULL
)paren
(brace
id|DRX
c_func
(paren
(paren
l_string|&quot;skb_alloc(FAILED) &quot;
)paren
)paren
suffix:semicolon
r_goto
id|drop_it
suffix:semicolon
)brace
id|sbus_unmap_single
c_func
(paren
id|mp-&gt;myri_sdev
comma
id|sbus_readl
c_func
(paren
op_amp
id|rxd-&gt;myri_scatters
(braket
l_int|0
)braket
dot
id|addr
)paren
comma
id|RX_ALLOC_SIZE
comma
id|SBUS_DMA_FROMDEVICE
)paren
suffix:semicolon
id|mp-&gt;rx_skbs
(braket
id|index
)braket
op_assign
id|new_skb
suffix:semicolon
id|new_skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_put
c_func
(paren
id|new_skb
comma
id|RX_ALLOC_SIZE
)paren
suffix:semicolon
id|dma_addr
op_assign
id|sbus_map_single
c_func
(paren
id|mp-&gt;myri_sdev
comma
id|new_skb-&gt;data
comma
id|RX_ALLOC_SIZE
comma
id|SBUS_DMA_FROMDEVICE
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|dma_addr
comma
op_amp
id|rxd-&gt;myri_scatters
(braket
l_int|0
)braket
dot
id|addr
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|RX_ALLOC_SIZE
comma
op_amp
id|rxd-&gt;myri_scatters
(braket
l_int|0
)braket
dot
id|len
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|index
comma
op_amp
id|rxd-&gt;ctx
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
l_int|1
comma
op_amp
id|rxd-&gt;num_sg
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|NEXT_RX
c_func
(paren
id|sbus_readl
c_func
(paren
op_amp
id|rq-&gt;tail
)paren
)paren
comma
op_amp
id|rq-&gt;tail
)paren
suffix:semicolon
multiline_comment|/* Trim the original skb for the netif. */
id|DRX
c_func
(paren
(paren
l_string|&quot;trim(%d) &quot;
comma
id|len
)paren
)paren
suffix:semicolon
id|skb_trim
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|sk_buff
op_star
id|copy_skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|len
)paren
suffix:semicolon
id|DRX
c_func
(paren
(paren
l_string|&quot;SMALLBUFF &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_skb
op_eq
l_int|NULL
)paren
(brace
id|DRX
c_func
(paren
(paren
l_string|&quot;dev_alloc_skb(FAILED) &quot;
)paren
)paren
suffix:semicolon
r_goto
id|drop_it
suffix:semicolon
)brace
multiline_comment|/* DMA sync already done above. */
id|copy_skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|DRX
c_func
(paren
(paren
l_string|&quot;resv_and_put &quot;
)paren
)paren
suffix:semicolon
id|skb_put
c_func
(paren
id|copy_skb
comma
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|copy_skb-&gt;data
comma
id|skb-&gt;data
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Reuse original ring buffer. */
id|DRX
c_func
(paren
(paren
l_string|&quot;reuse &quot;
)paren
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|RX_ALLOC_SIZE
comma
op_amp
id|rxd-&gt;myri_scatters
(braket
l_int|0
)braket
dot
id|len
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|index
comma
op_amp
id|rxd-&gt;ctx
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
l_int|1
comma
op_amp
id|rxd-&gt;num_sg
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|NEXT_RX
c_func
(paren
id|sbus_readl
c_func
(paren
op_amp
id|rq-&gt;tail
)paren
)paren
comma
op_amp
id|rq-&gt;tail
)paren
suffix:semicolon
id|skb
op_assign
id|copy_skb
suffix:semicolon
)brace
multiline_comment|/* Just like the happy meal we get checksums from this card. */
id|skb-&gt;csum
op_assign
id|csum
suffix:semicolon
id|skb-&gt;ip_summed
op_assign
id|CHECKSUM_UNNECESSARY
suffix:semicolon
multiline_comment|/* XXX */
id|skb-&gt;protocol
op_assign
id|myri_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|DRX
c_func
(paren
(paren
l_string|&quot;prot[%04x] netif_rx &quot;
comma
id|skb-&gt;protocol
)paren
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|mp-&gt;enet_stats.rx_packets
op_increment
suffix:semicolon
id|next
suffix:colon
id|DRX
c_func
(paren
(paren
l_string|&quot;NEXT&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|entry
op_assign
id|NEXT_RX
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
)brace
DECL|function|myri_interrupt
r_static
r_void
id|myri_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|dev_id
suffix:semicolon
r_struct
id|myri_eth
op_star
id|mp
op_assign
(paren
r_struct
id|myri_eth
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|lregs
op_assign
id|mp-&gt;lregs
suffix:semicolon
r_struct
id|myri_channel
op_star
id|chan
op_assign
op_amp
id|mp-&gt;shmem-&gt;channel
suffix:semicolon
id|u32
id|status
suffix:semicolon
id|status
op_assign
id|sbus_readl
c_func
(paren
id|lregs
op_plus
id|LANAI_ISTAT
)paren
suffix:semicolon
id|DIRQ
c_func
(paren
(paren
l_string|&quot;myri_interrupt: status[%08x] &quot;
comma
id|status
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|ISTAT_HOST
)paren
(brace
id|u32
id|softstate
suffix:semicolon
id|DIRQ
c_func
(paren
(paren
l_string|&quot;IRQ_DISAB &quot;
)paren
)paren
suffix:semicolon
id|myri_disable_irq
c_func
(paren
id|lregs
comma
id|mp-&gt;cregs
)paren
suffix:semicolon
id|softstate
op_assign
id|sbus_readl
c_func
(paren
op_amp
id|chan-&gt;state
)paren
suffix:semicolon
id|DIRQ
c_func
(paren
(paren
l_string|&quot;state[%08x] &quot;
comma
id|softstate
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|softstate
op_ne
id|STATE_READY
)paren
(brace
id|DIRQ
c_func
(paren
(paren
l_string|&quot;myri_not_so_happy &quot;
)paren
)paren
suffix:semicolon
id|myri_is_not_so_happy
c_func
(paren
id|mp
)paren
suffix:semicolon
)brace
id|DIRQ
c_func
(paren
(paren
l_string|&quot;&bslash;nmyri_rx: &quot;
)paren
)paren
suffix:semicolon
id|myri_rx
c_func
(paren
id|mp
comma
id|dev
)paren
suffix:semicolon
id|DIRQ
c_func
(paren
(paren
l_string|&quot;&bslash;nistat=ISTAT_HOST &quot;
)paren
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|ISTAT_HOST
comma
id|lregs
op_plus
id|LANAI_ISTAT
)paren
suffix:semicolon
id|DIRQ
c_func
(paren
(paren
l_string|&quot;IRQ_ENAB &quot;
)paren
)paren
suffix:semicolon
id|myri_enable_irq
c_func
(paren
id|lregs
comma
id|mp-&gt;cregs
)paren
suffix:semicolon
)brace
id|DIRQ
c_func
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
DECL|function|myri_open
r_static
r_int
id|myri_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|myri_eth
op_star
id|mp
op_assign
(paren
r_struct
id|myri_eth
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
id|myri_init
c_func
(paren
id|mp
comma
id|in_interrupt
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|myri_close
r_static
r_int
id|myri_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|myri_eth
op_star
id|mp
op_assign
(paren
r_struct
id|myri_eth
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|myri_clean_rings
c_func
(paren
id|mp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|myri_tx_timeout
r_static
r_void
id|myri_tx_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|myri_eth
op_star
id|mp
op_assign
(paren
r_struct
id|myri_eth
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: transmit timed out, resetting&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|mp-&gt;enet_stats.tx_errors
op_increment
suffix:semicolon
id|myri_init
c_func
(paren
id|mp
comma
l_int|0
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|myri_start_xmit
r_static
r_int
id|myri_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|myri_eth
op_star
id|mp
op_assign
(paren
r_struct
id|myri_eth
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|sendq
op_star
id|sq
op_assign
id|mp-&gt;sq
suffix:semicolon
r_struct
id|myri_txd
op_star
id|txd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|head
comma
id|tail
suffix:semicolon
r_int
id|len
comma
id|entry
suffix:semicolon
id|u32
id|dma_addr
suffix:semicolon
id|DTX
c_func
(paren
(paren
l_string|&quot;myri_start_xmit: &quot;
)paren
)paren
suffix:semicolon
id|myri_tx
c_func
(paren
id|mp
comma
id|dev
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* This is just to prevent multiple PIO reads for TX_BUFFS_AVAIL. */
id|head
op_assign
id|sbus_readl
c_func
(paren
op_amp
id|sq-&gt;head
)paren
suffix:semicolon
id|tail
op_assign
id|sbus_readl
c_func
(paren
op_amp
id|sq-&gt;tail
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TX_BUFFS_AVAIL
c_func
(paren
id|head
comma
id|tail
)paren
)paren
(brace
id|DTX
c_func
(paren
(paren
l_string|&quot;no buffs available, returning 1&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DHDR
c_func
(paren
(paren
l_string|&quot;xmit[skbdata(%p)]&bslash;n&quot;
comma
id|skb-&gt;data
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_HEADER
id|dump_ehdr_and_myripad
c_func
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|skb-&gt;data
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* XXX Maybe this can go as well. */
id|len
op_assign
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|len
op_amp
l_int|3
)paren
(brace
id|DTX
c_func
(paren
(paren
l_string|&quot;len&amp;3 &quot;
)paren
)paren
suffix:semicolon
id|len
op_assign
(paren
id|len
op_plus
l_int|4
)paren
op_amp
(paren
op_complement
l_int|3
)paren
suffix:semicolon
)brace
id|entry
op_assign
id|sbus_readl
c_func
(paren
op_amp
id|sq-&gt;tail
)paren
suffix:semicolon
id|txd
op_assign
op_amp
id|sq-&gt;myri_txd
(braket
id|entry
)braket
suffix:semicolon
id|mp-&gt;tx_skbs
(braket
id|entry
)braket
op_assign
id|skb
suffix:semicolon
multiline_comment|/* Must do this before we sbus map it. */
r_if
c_cond
(paren
id|skb-&gt;data
(braket
id|MYRI_PAD_LEN
)braket
op_amp
l_int|0x1
)paren
(brace
id|sbus_writew
c_func
(paren
l_int|0xffff
comma
op_amp
id|txd-&gt;addr
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|sbus_writew
c_func
(paren
l_int|0xffff
comma
op_amp
id|txd-&gt;addr
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|sbus_writew
c_func
(paren
l_int|0xffff
comma
op_amp
id|txd-&gt;addr
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|sbus_writew
c_func
(paren
l_int|0xffff
comma
op_amp
id|txd-&gt;addr
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|sbus_writew
c_func
(paren
l_int|0xffff
comma
op_amp
id|txd-&gt;addr
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|sbus_writew
c_func
(paren
(paren
id|skb-&gt;data
(braket
l_int|0
)braket
op_lshift
l_int|8
)paren
op_or
id|skb-&gt;data
(braket
l_int|1
)braket
comma
op_amp
id|txd-&gt;addr
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|sbus_writew
c_func
(paren
(paren
id|skb-&gt;data
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
id|skb-&gt;data
(braket
l_int|3
)braket
comma
op_amp
id|txd-&gt;addr
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|sbus_writew
c_func
(paren
(paren
id|skb-&gt;data
(braket
l_int|4
)braket
op_lshift
l_int|8
)paren
op_or
id|skb-&gt;data
(braket
l_int|5
)braket
comma
op_amp
id|txd-&gt;addr
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
id|dma_addr
op_assign
id|sbus_map_single
c_func
(paren
id|mp-&gt;myri_sdev
comma
id|skb-&gt;data
comma
id|len
comma
id|SBUS_DMA_TODEVICE
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|dma_addr
comma
op_amp
id|txd-&gt;myri_gathers
(braket
l_int|0
)braket
dot
id|addr
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|len
comma
op_amp
id|txd-&gt;myri_gathers
(braket
l_int|0
)braket
dot
id|len
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
l_int|1
comma
op_amp
id|txd-&gt;num_sg
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|KERNEL_CHANNEL
comma
op_amp
id|txd-&gt;chan
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|len
comma
op_amp
id|txd-&gt;len
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
(paren
id|u32
)paren
op_minus
l_int|1
comma
op_amp
id|txd-&gt;csum_off
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
l_int|0
comma
op_amp
id|txd-&gt;csum_field
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|NEXT_TX
c_func
(paren
id|entry
)paren
comma
op_amp
id|sq-&gt;tail
)paren
suffix:semicolon
id|DTX
c_func
(paren
(paren
l_string|&quot;BangTheChip &quot;
)paren
)paren
suffix:semicolon
id|bang_the_chip
c_func
(paren
id|mp
)paren
suffix:semicolon
id|DTX
c_func
(paren
(paren
l_string|&quot;tbusy=0, returning 0&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Create the MyriNet MAC header for an arbitrary protocol layer &n; *&n; * saddr=NULL&t;means use device source address&n; * daddr=NULL&t;means leave destination address (eg unresolved arp)&n; */
DECL|function|myri_header
r_static
r_int
id|myri_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
)paren
(brace
r_struct
id|ethhdr
op_star
id|eth
op_assign
(paren
r_struct
id|ethhdr
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
id|ETH_HLEN
)paren
suffix:semicolon
r_int
r_char
op_star
id|pad
op_assign
(paren
r_int
r_char
op_star
)paren
id|skb_push
c_func
(paren
id|skb
comma
id|MYRI_PAD_LEN
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_HEADER
id|DHDR
c_func
(paren
(paren
l_string|&quot;myri_header: pad[%02x,%02x] &quot;
comma
id|pad
(braket
l_int|0
)braket
comma
id|pad
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|dump_ehdr
c_func
(paren
id|eth
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Set the MyriNET padding identifier. */
id|pad
(braket
l_int|0
)braket
op_assign
id|MYRI_PAD_LEN
suffix:semicolon
id|pad
(braket
l_int|1
)braket
op_assign
l_int|0xab
suffix:semicolon
multiline_comment|/* Set the protocol type. For a packet of type ETH_P_802_3 we put the length&n;&t; * in here instead. It is up to the 802.2 layer to carry protocol information.&n;&t; */
r_if
c_cond
(paren
id|type
op_ne
id|ETH_P_802_3
)paren
id|eth-&gt;h_proto
op_assign
id|htons
c_func
(paren
id|type
)paren
suffix:semicolon
r_else
id|eth-&gt;h_proto
op_assign
id|htons
c_func
(paren
id|len
)paren
suffix:semicolon
multiline_comment|/* Set the source hardware address. */
r_if
c_cond
(paren
id|saddr
)paren
id|memcpy
c_func
(paren
id|eth-&gt;h_source
comma
id|saddr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_else
id|memcpy
c_func
(paren
id|eth-&gt;h_source
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
multiline_comment|/* Anyway, the loopback-device should never use this function... */
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_LOOPBACK
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;addr_len
suffix:semicolon
id|i
op_increment
)paren
id|eth-&gt;h_dest
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|dev-&gt;hard_header_len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|daddr
)paren
(brace
id|memcpy
c_func
(paren
id|eth-&gt;h_dest
comma
id|daddr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_return
id|dev-&gt;hard_header_len
suffix:semicolon
)brace
r_return
op_minus
id|dev-&gt;hard_header_len
suffix:semicolon
)brace
multiline_comment|/* Rebuild the MyriNet MAC header. This is called after an ARP&n; * (or in future other address resolution) has completed on this&n; * sk_buff. We now let ARP fill in the other fields.&n; */
DECL|function|myri_rebuild_header
r_static
r_int
id|myri_rebuild_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_int
r_char
op_star
id|pad
op_assign
(paren
r_int
r_char
op_star
)paren
id|skb-&gt;data
suffix:semicolon
r_struct
id|ethhdr
op_star
id|eth
op_assign
(paren
r_struct
id|ethhdr
op_star
)paren
(paren
id|pad
op_plus
id|MYRI_PAD_LEN
)paren
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|skb-&gt;dev
suffix:semicolon
macro_line|#ifdef DEBUG_HEADER
id|DHDR
c_func
(paren
(paren
l_string|&quot;myri_rebuild_header: pad[%02x,%02x] &quot;
comma
id|pad
(braket
l_int|0
)braket
comma
id|pad
(braket
l_int|1
)braket
)paren
)paren
suffix:semicolon
id|dump_ehdr
c_func
(paren
id|eth
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Refill MyriNet padding identifiers, this is just being anal. */
id|pad
(braket
l_int|0
)braket
op_assign
id|MYRI_PAD_LEN
suffix:semicolon
id|pad
(braket
l_int|1
)braket
op_assign
l_int|0xab
suffix:semicolon
r_switch
c_cond
(paren
id|eth-&gt;h_proto
)paren
(brace
macro_line|#ifdef CONFIG_INET
r_case
id|__constant_htons
c_func
(paren
id|ETH_P_IP
)paren
suffix:colon
r_return
id|arp_find
c_func
(paren
id|eth-&gt;h_dest
comma
id|skb
)paren
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: unable to resolve type %X addresses.&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
)paren
id|eth-&gt;h_proto
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|eth-&gt;h_source
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|myri_header_cache
r_int
id|myri_header_cache
c_func
(paren
r_struct
id|neighbour
op_star
id|neigh
comma
r_struct
id|hh_cache
op_star
id|hh
)paren
(brace
r_int
r_int
id|type
op_assign
id|hh-&gt;hh_type
suffix:semicolon
r_int
r_char
op_star
id|pad
op_assign
(paren
r_int
r_char
op_star
)paren
id|hh-&gt;hh_data
suffix:semicolon
r_struct
id|ethhdr
op_star
id|eth
op_assign
(paren
r_struct
id|ethhdr
op_star
)paren
(paren
id|pad
op_plus
id|MYRI_PAD_LEN
)paren
suffix:semicolon
r_struct
id|net_device
op_star
id|dev
op_assign
id|neigh-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|__constant_htons
c_func
(paren
id|ETH_P_802_3
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Refill MyriNet padding identifiers, this is just being anal. */
id|pad
(braket
l_int|0
)braket
op_assign
id|MYRI_PAD_LEN
suffix:semicolon
id|pad
(braket
l_int|1
)braket
op_assign
l_int|0xab
suffix:semicolon
id|eth-&gt;h_proto
op_assign
id|type
suffix:semicolon
id|memcpy
c_func
(paren
id|eth-&gt;h_source
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|eth-&gt;h_dest
comma
id|neigh-&gt;ha
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
id|hh-&gt;hh_len
op_assign
l_int|16
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Called by Address Resolution module to notify changes in address. */
DECL|function|myri_header_cache_update
r_void
id|myri_header_cache_update
c_func
(paren
r_struct
id|hh_cache
op_star
id|hh
comma
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_char
op_star
id|haddr
)paren
(brace
id|memcpy
c_func
(paren
(paren
(paren
id|u8
op_star
)paren
id|hh-&gt;hh_data
)paren
op_plus
l_int|2
comma
id|haddr
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
)brace
DECL|function|myri_change_mtu
r_static
r_int
id|myri_change_mtu
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|new_mtu
)paren
(brace
r_if
c_cond
(paren
(paren
id|new_mtu
OL
(paren
id|ETH_HLEN
op_plus
id|MYRI_PAD_LEN
)paren
)paren
op_logical_or
(paren
id|new_mtu
OG
id|MYRINET_MTU
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|new_mtu
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|myri_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|myri_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_return
op_amp
(paren
(paren
(paren
r_struct
id|myri_eth
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|enet_stats
)paren
suffix:semicolon
)brace
DECL|macro|CRC_POLYNOMIAL_BE
mdefine_line|#define CRC_POLYNOMIAL_BE 0x04c11db7UL  /* Ethernet CRC, big endian */
DECL|macro|CRC_POLYNOMIAL_LE
mdefine_line|#define CRC_POLYNOMIAL_LE 0xedb88320UL  /* Ethernet CRC, little endian */
DECL|function|myri_set_multicast
r_static
r_void
id|myri_set_multicast
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
multiline_comment|/* Do nothing, all MyriCOM nodes transmit multicast frames&n;&t; * as broadcast packets...&n;&t; */
)brace
DECL|function|set_boardid_from_idprom
r_static
r_inline
r_void
id|set_boardid_from_idprom
c_func
(paren
r_struct
id|myri_eth
op_star
id|mp
comma
r_int
id|num
)paren
(brace
id|mp-&gt;eeprom.id
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|mp-&gt;eeprom.id
(braket
l_int|1
)braket
op_assign
id|idprom-&gt;id_machtype
suffix:semicolon
id|mp-&gt;eeprom.id
(braket
l_int|2
)braket
op_assign
(paren
id|idprom-&gt;id_sernum
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|mp-&gt;eeprom.id
(braket
l_int|3
)braket
op_assign
(paren
id|idprom-&gt;id_sernum
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|mp-&gt;eeprom.id
(braket
l_int|4
)braket
op_assign
(paren
id|idprom-&gt;id_sernum
op_rshift
l_int|0
)paren
op_amp
l_int|0xff
suffix:semicolon
id|mp-&gt;eeprom.id
(braket
l_int|5
)braket
op_assign
id|num
suffix:semicolon
)brace
DECL|function|determine_reg_space_size
r_static
r_inline
r_void
id|determine_reg_space_size
c_func
(paren
r_struct
id|myri_eth
op_star
id|mp
)paren
(brace
r_switch
c_cond
(paren
id|mp-&gt;eeprom.cpuvers
)paren
(brace
r_case
id|CPUVERS_2_3
suffix:colon
r_case
id|CPUVERS_3_0
suffix:colon
r_case
id|CPUVERS_3_1
suffix:colon
r_case
id|CPUVERS_3_2
suffix:colon
id|mp-&gt;reg_size
op_assign
(paren
l_int|3
op_star
l_int|128
op_star
l_int|1024
)paren
op_plus
l_int|4096
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPUVERS_4_0
suffix:colon
r_case
id|CPUVERS_4_1
suffix:colon
id|mp-&gt;reg_size
op_assign
(paren
(paren
l_int|4096
op_lshift
l_int|1
)paren
op_plus
id|mp-&gt;eeprom.ramsz
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CPUVERS_4_2
suffix:colon
r_case
id|CPUVERS_5_0
suffix:colon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;myricom: AIEEE weird cpu version %04x assuming pre4.0&bslash;n&quot;
comma
id|mp-&gt;eeprom.cpuvers
)paren
suffix:semicolon
id|mp-&gt;reg_size
op_assign
(paren
l_int|3
op_star
l_int|128
op_star
l_int|1024
)paren
op_plus
l_int|4096
suffix:semicolon
)brace
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_DETECT
DECL|function|dump_eeprom
r_static
r_void
id|dump_eeprom
c_func
(paren
r_struct
id|myri_eth
op_star
id|mp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;EEPROM: clockval[%08x] cpuvers[%04x] &quot;
l_string|&quot;id[%02x,%02x,%02x,%02x,%02x,%02x]&bslash;n&quot;
comma
id|mp-&gt;eeprom.cval
comma
id|mp-&gt;eeprom.cpuvers
comma
id|mp-&gt;eeprom.id
(braket
l_int|0
)braket
comma
id|mp-&gt;eeprom.id
(braket
l_int|1
)braket
comma
id|mp-&gt;eeprom.id
(braket
l_int|2
)braket
comma
id|mp-&gt;eeprom.id
(braket
l_int|3
)braket
comma
id|mp-&gt;eeprom.id
(braket
l_int|4
)braket
comma
id|mp-&gt;eeprom.id
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EEPROM: ramsz[%08x]&bslash;n&quot;
comma
id|mp-&gt;eeprom.ramsz
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EEPROM: fvers[%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x&bslash;n&quot;
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|0
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|1
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|2
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|3
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|4
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|5
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|6
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EEPROM:       %02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x&bslash;n&quot;
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|8
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|9
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|10
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|11
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|12
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|13
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|14
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|15
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EEPROM:       %02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x&bslash;n&quot;
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|16
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|17
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|18
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|19
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|20
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|21
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|22
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|23
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EEPROM:       %02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x]&bslash;n&quot;
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|24
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|25
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|26
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|27
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|28
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|29
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|30
)braket
comma
id|mp-&gt;eeprom.fvers
(braket
l_int|31
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EEPROM: mvers[%02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x&bslash;n&quot;
comma
id|mp-&gt;eeprom.mvers
(braket
l_int|0
)braket
comma
id|mp-&gt;eeprom.mvers
(braket
l_int|1
)braket
comma
id|mp-&gt;eeprom.mvers
(braket
l_int|2
)braket
comma
id|mp-&gt;eeprom.mvers
(braket
l_int|3
)braket
comma
id|mp-&gt;eeprom.mvers
(braket
l_int|4
)braket
comma
id|mp-&gt;eeprom.mvers
(braket
l_int|5
)braket
comma
id|mp-&gt;eeprom.mvers
(braket
l_int|6
)braket
comma
id|mp-&gt;eeprom.mvers
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EEPROM:       %02x,%02x,%02x,%02x,%02x,%02x,%02x,%02x]&bslash;n&quot;
comma
id|mp-&gt;eeprom.mvers
(braket
l_int|8
)braket
comma
id|mp-&gt;eeprom.mvers
(braket
l_int|9
)braket
comma
id|mp-&gt;eeprom.mvers
(braket
l_int|10
)braket
comma
id|mp-&gt;eeprom.mvers
(braket
l_int|11
)braket
comma
id|mp-&gt;eeprom.mvers
(braket
l_int|12
)braket
comma
id|mp-&gt;eeprom.mvers
(braket
l_int|13
)braket
comma
id|mp-&gt;eeprom.mvers
(braket
l_int|14
)braket
comma
id|mp-&gt;eeprom.mvers
(braket
l_int|15
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EEPROM: dlval[%04x] brd_type[%04x] bus_type[%04x] prod_code[%04x]&bslash;n&quot;
comma
id|mp-&gt;eeprom.dlval
comma
id|mp-&gt;eeprom.brd_type
comma
id|mp-&gt;eeprom.bus_type
comma
id|mp-&gt;eeprom.prod_code
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EEPROM: serial_num[%08x]&bslash;n&quot;
comma
id|mp-&gt;eeprom.serial_num
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|myri_ether_init
r_static
r_int
id|__init
id|myri_ether_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|sbus_dev
op_star
id|sdev
comma
r_int
id|num
)paren
(brace
r_static
r_int
id|version_printed
op_assign
l_int|0
suffix:semicolon
r_struct
id|myri_eth
op_star
id|mp
suffix:semicolon
r_int
r_char
id|prop_buf
(braket
l_int|32
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DET
c_func
(paren
(paren
l_string|&quot;myri_ether_init(%p,%p,%d):&bslash;n&quot;
comma
id|dev
comma
id|sdev
comma
id|num
)paren
)paren
suffix:semicolon
id|dev
op_assign
id|init_etherdev
c_func
(paren
l_int|0
comma
r_sizeof
(paren
r_struct
id|myri_eth
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|version_printed
op_increment
op_eq
l_int|0
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: MyriCOM MyriNET Ethernet &quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|mp
op_assign
(paren
r_struct
id|myri_eth
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|mp-&gt;myri_sdev
op_assign
id|sdev
suffix:semicolon
multiline_comment|/* Clean out skb arrays. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|RX_RING_SIZE
op_plus
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
id|mp-&gt;rx_skbs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TX_RING_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|mp-&gt;tx_skbs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* First check for EEPROM information. */
id|i
op_assign
id|prom_getproperty
c_func
(paren
id|sdev-&gt;prom_node
comma
l_string|&quot;myrinet-eeprom-info&quot;
comma
(paren
r_char
op_star
)paren
op_amp
id|mp-&gt;eeprom
comma
r_sizeof
(paren
r_struct
id|myri_eeprom
)paren
)paren
suffix:semicolon
id|DET
c_func
(paren
(paren
l_string|&quot;prom_getprop(myrinet-eeprom-info) returns %d&bslash;n&quot;
comma
id|i
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_or
id|i
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* No eeprom property, must cook up the values ourselves. */
id|DET
c_func
(paren
(paren
l_string|&quot;No EEPROM: &quot;
)paren
)paren
suffix:semicolon
id|mp-&gt;eeprom.bus_type
op_assign
id|BUS_TYPE_SBUS
suffix:semicolon
id|mp-&gt;eeprom.cpuvers
op_assign
id|prom_getintdefault
c_func
(paren
id|sdev-&gt;prom_node
comma
l_string|&quot;cpu_version&quot;
comma
l_int|0
)paren
suffix:semicolon
id|mp-&gt;eeprom.cval
op_assign
id|prom_getintdefault
c_func
(paren
id|sdev-&gt;prom_node
comma
l_string|&quot;clock_value&quot;
comma
l_int|0
)paren
suffix:semicolon
id|mp-&gt;eeprom.ramsz
op_assign
id|prom_getintdefault
c_func
(paren
id|sdev-&gt;prom_node
comma
l_string|&quot;sram_size&quot;
comma
l_int|0
)paren
suffix:semicolon
id|DET
c_func
(paren
(paren
l_string|&quot;cpuvers[%d] cval[%d] ramsz[%d]&bslash;n&quot;
comma
id|mp-&gt;eeprom.cpuvers
comma
id|mp-&gt;eeprom.cval
comma
id|mp-&gt;eeprom.ramsz
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;eeprom.cpuvers
op_eq
l_int|0
)paren
(brace
id|DET
c_func
(paren
(paren
l_string|&quot;EEPROM: cpuvers was zero, setting to %04x&bslash;n&quot;
comma
id|CPUVERS_2_3
)paren
)paren
suffix:semicolon
id|mp-&gt;eeprom.cpuvers
op_assign
id|CPUVERS_2_3
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mp-&gt;eeprom.cpuvers
OL
id|CPUVERS_3_0
)paren
(brace
id|DET
c_func
(paren
(paren
l_string|&quot;EEPROM: cpuvers &lt; CPUVERS_3_0, clockval set to zero.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|mp-&gt;eeprom.cval
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mp-&gt;eeprom.ramsz
op_eq
l_int|0
)paren
(brace
id|DET
c_func
(paren
(paren
l_string|&quot;EEPROM: ramsz == 0, setting to 128k&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|mp-&gt;eeprom.ramsz
op_assign
(paren
l_int|128
op_star
l_int|1024
)paren
suffix:semicolon
)brace
id|i
op_assign
id|prom_getproperty
c_func
(paren
id|sdev-&gt;prom_node
comma
l_string|&quot;myrinet-board-id&quot;
comma
op_amp
id|prop_buf
(braket
l_int|0
)braket
comma
l_int|10
)paren
suffix:semicolon
id|DET
c_func
(paren
(paren
l_string|&quot;EEPROM: prom_getprop(myrinet-board-id) returns %d&bslash;n&quot;
comma
id|i
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_ne
l_int|0
)paren
op_logical_and
(paren
id|i
op_ne
op_minus
l_int|1
)paren
)paren
id|memcpy
c_func
(paren
op_amp
id|mp-&gt;eeprom.id
(braket
l_int|0
)braket
comma
op_amp
id|prop_buf
(braket
l_int|0
)braket
comma
l_int|6
)paren
suffix:semicolon
r_else
id|set_boardid_from_idprom
c_func
(paren
id|mp
comma
id|num
)paren
suffix:semicolon
id|i
op_assign
id|prom_getproperty
c_func
(paren
id|sdev-&gt;prom_node
comma
l_string|&quot;fpga_version&quot;
comma
op_amp
id|mp-&gt;eeprom.fvers
(braket
l_int|0
)braket
comma
l_int|32
)paren
suffix:semicolon
id|DET
c_func
(paren
(paren
l_string|&quot;EEPROM: prom_getprop(fpga_version) returns %d&bslash;n&quot;
comma
id|i
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
op_logical_or
id|i
op_eq
op_minus
l_int|1
)paren
id|memset
c_func
(paren
op_amp
id|mp-&gt;eeprom.fvers
(braket
l_int|0
)braket
comma
l_int|0
comma
l_int|32
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;eeprom.cpuvers
op_eq
id|CPUVERS_4_1
)paren
(brace
id|DET
c_func
(paren
(paren
l_string|&quot;EEPROM: cpuvers CPUVERS_4_1, &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;eeprom.ramsz
op_eq
(paren
l_int|128
op_star
l_int|1024
)paren
)paren
(brace
id|DET
c_func
(paren
(paren
l_string|&quot;ramsize 128k, setting to 256k, &quot;
)paren
)paren
suffix:semicolon
id|mp-&gt;eeprom.ramsz
op_assign
(paren
l_int|256
op_star
l_int|1024
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mp-&gt;eeprom.cval
op_eq
l_int|0x40414041
)paren
op_logical_or
(paren
id|mp-&gt;eeprom.cval
op_eq
l_int|0x90449044
)paren
)paren
(brace
id|DET
c_func
(paren
(paren
l_string|&quot;changing cval from %08x to %08x &quot;
comma
id|mp-&gt;eeprom.cval
comma
l_int|0x50e450e4
)paren
)paren
suffix:semicolon
id|mp-&gt;eeprom.cval
op_assign
l_int|0x50e450e4
suffix:semicolon
)brace
id|DET
c_func
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG_DETECT
id|dump_eeprom
c_func
(paren
id|mp
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%2.2x%c&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|mp-&gt;eeprom.id
(braket
id|i
)braket
comma
id|i
op_eq
l_int|5
ques
c_cond
l_char|&squot; &squot;
suffix:colon
l_char|&squot;:&squot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|determine_reg_space_size
c_func
(paren
id|mp
)paren
suffix:semicolon
multiline_comment|/* Map in the MyriCOM register/localram set. */
r_if
c_cond
(paren
id|mp-&gt;eeprom.cpuvers
OL
id|CPUVERS_4_0
)paren
(brace
multiline_comment|/* XXX Makes no sense, if control reg is non-existant this&n;&t;&t; * XXX driver cannot function at all... maybe pre-4.0 is&n;&t;&t; * XXX only a valid version for PCI cards?  Ask feldy...&n;&t;&t; */
id|DET
c_func
(paren
(paren
l_string|&quot;Mapping regs for cpuvers &lt; CPUVERS_4_0&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|mp-&gt;regs
op_assign
id|sbus_ioremap
c_func
(paren
op_amp
id|sdev-&gt;resource
(braket
l_int|0
)braket
comma
l_int|0
comma
id|mp-&gt;reg_size
comma
l_string|&quot;MyriCOM Regs&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mp-&gt;regs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;MyriCOM: Cannot map MyriCOM registers.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|mp-&gt;lanai
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|mp-&gt;regs
op_plus
(paren
l_int|256
op_star
l_int|1024
)paren
)paren
suffix:semicolon
id|mp-&gt;lanai3
op_assign
(paren
r_int
r_int
op_star
)paren
id|mp-&gt;lanai
suffix:semicolon
id|mp-&gt;lregs
op_assign
(paren
r_int
r_int
)paren
op_amp
id|mp-&gt;lanai
(braket
l_int|0x10000
)braket
suffix:semicolon
)brace
r_else
(brace
id|DET
c_func
(paren
(paren
l_string|&quot;Mapping regs for cpuvers &gt;= CPUVERS_4_0&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|mp-&gt;cregs
op_assign
id|sbus_ioremap
c_func
(paren
op_amp
id|sdev-&gt;resource
(braket
l_int|0
)braket
comma
l_int|0
comma
id|PAGE_SIZE
comma
l_string|&quot;MyriCOM Control Regs&quot;
)paren
suffix:semicolon
id|mp-&gt;lregs
op_assign
id|sbus_ioremap
c_func
(paren
op_amp
id|sdev-&gt;resource
(braket
l_int|0
)braket
comma
(paren
l_int|256
op_star
l_int|1024
)paren
comma
id|PAGE_SIZE
comma
l_string|&quot;MyriCOM LANAI Regs&quot;
)paren
suffix:semicolon
id|mp-&gt;lanai
op_assign
(paren
r_int
r_int
op_star
)paren
id|sbus_ioremap
c_func
(paren
op_amp
id|sdev-&gt;resource
(braket
l_int|0
)braket
comma
(paren
l_int|512
op_star
l_int|1024
)paren
comma
id|mp-&gt;eeprom.ramsz
comma
l_string|&quot;MyriCOM SRAM&quot;
)paren
suffix:semicolon
id|mp-&gt;lanai3
op_assign
(paren
r_int
r_int
op_star
)paren
id|mp-&gt;lanai
suffix:semicolon
)brace
id|DET
c_func
(paren
(paren
l_string|&quot;Registers mapped: cregs[%lx] lregs[%lx] lanai[%p] lanai3[%p]&bslash;n&quot;
comma
id|mp-&gt;cregs
comma
id|mp-&gt;lregs
comma
id|mp-&gt;lanai
comma
id|mp-&gt;lanai3
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;eeprom.cpuvers
op_ge
id|CPUVERS_4_0
)paren
id|mp-&gt;shmem_base
op_assign
l_int|0xf000
suffix:semicolon
r_else
id|mp-&gt;shmem_base
op_assign
l_int|0x8000
suffix:semicolon
id|DET
c_func
(paren
(paren
l_string|&quot;Shared memory base is %04x, &quot;
comma
id|mp-&gt;shmem_base
)paren
)paren
suffix:semicolon
id|mp-&gt;shmem
op_assign
(paren
r_struct
id|myri_shmem
op_star
)paren
op_amp
id|mp-&gt;lanai
(braket
id|mp-&gt;shmem_base
)braket
suffix:semicolon
id|DET
c_func
(paren
(paren
l_string|&quot;shmem mapped at %p&bslash;n&quot;
comma
id|mp-&gt;shmem
)paren
)paren
suffix:semicolon
id|mp-&gt;rqack
op_assign
op_amp
id|mp-&gt;shmem-&gt;channel.recvqa
suffix:semicolon
id|mp-&gt;rq
op_assign
op_amp
id|mp-&gt;shmem-&gt;channel.recvq
suffix:semicolon
id|mp-&gt;sq
op_assign
op_amp
id|mp-&gt;shmem-&gt;channel.sendq
suffix:semicolon
multiline_comment|/* Reset the board. */
id|DET
c_func
(paren
(paren
l_string|&quot;Resetting LANAI&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|myri_reset_off
c_func
(paren
id|mp-&gt;lregs
comma
id|mp-&gt;cregs
)paren
suffix:semicolon
id|myri_reset_on
c_func
(paren
id|mp-&gt;cregs
)paren
suffix:semicolon
multiline_comment|/* Turn IRQ&squot;s off. */
id|myri_disable_irq
c_func
(paren
id|mp-&gt;lregs
comma
id|mp-&gt;cregs
)paren
suffix:semicolon
multiline_comment|/* Reset once more. */
id|myri_reset_on
c_func
(paren
id|mp-&gt;cregs
)paren
suffix:semicolon
multiline_comment|/* Get the supported DVMA burst sizes from our SBUS. */
id|mp-&gt;myri_bursts
op_assign
id|prom_getintdefault
c_func
(paren
id|mp-&gt;myri_sdev-&gt;bus-&gt;prom_node
comma
l_string|&quot;burst-sizes&quot;
comma
l_int|0x00
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sbus_can_burst64
c_func
(paren
id|sdev
)paren
)paren
id|mp-&gt;myri_bursts
op_and_assign
op_complement
(paren
id|DMA_BURST64
)paren
suffix:semicolon
id|DET
c_func
(paren
(paren
l_string|&quot;MYRI bursts %02x&bslash;n&quot;
comma
id|mp-&gt;myri_bursts
)paren
)paren
suffix:semicolon
multiline_comment|/* Encode SBUS interrupt level in second control register. */
id|i
op_assign
id|prom_getint
c_func
(paren
id|sdev-&gt;prom_node
comma
l_string|&quot;interrupts&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
id|i
op_assign
l_int|4
suffix:semicolon
id|DET
c_func
(paren
(paren
l_string|&quot;prom_getint(interrupts)==%d, irqlvl set to %04x&bslash;n&quot;
comma
id|i
comma
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
(paren
l_int|1
op_lshift
id|i
)paren
comma
id|mp-&gt;cregs
op_plus
id|MYRICTRL_IRQLVL
)paren
suffix:semicolon
id|mp-&gt;dev
op_assign
id|dev
suffix:semicolon
id|dev-&gt;open
op_assign
op_amp
id|myri_open
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|myri_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|myri_start_xmit
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
op_amp
id|myri_tx_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
l_int|5
op_star
id|HZ
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|myri_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|myri_set_multicast
suffix:semicolon
id|dev-&gt;irq
op_assign
id|sdev-&gt;irqs
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Register interrupt handler now. */
id|DET
c_func
(paren
(paren
l_string|&quot;Requesting MYRIcom IRQ line.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|myri_interrupt
comma
id|SA_SHIRQ
comma
l_string|&quot;MyriCOM Ethernet&quot;
comma
(paren
r_void
op_star
)paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;MyriCOM: Cannot register interrupt handler.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|DET
c_func
(paren
(paren
l_string|&quot;ether_setup()&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|MYRINET_MTU
suffix:semicolon
id|dev-&gt;change_mtu
op_assign
id|myri_change_mtu
suffix:semicolon
id|dev-&gt;hard_header
op_assign
id|myri_header
suffix:semicolon
id|dev-&gt;rebuild_header
op_assign
id|myri_rebuild_header
suffix:semicolon
id|dev-&gt;hard_header_len
op_assign
(paren
id|ETH_HLEN
op_plus
id|MYRI_PAD_LEN
)paren
suffix:semicolon
id|dev-&gt;hard_header_cache
op_assign
id|myri_header_cache
suffix:semicolon
id|dev-&gt;header_cache_update
op_assign
id|myri_header_cache_update
suffix:semicolon
multiline_comment|/* Load code onto the LANai. */
id|DET
c_func
(paren
(paren
l_string|&quot;Loading LANAI firmware&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|myri_load_lanai
c_func
(paren
id|mp
)paren
suffix:semicolon
macro_line|#ifdef MODULE
id|dev-&gt;ifindex
op_assign
id|dev_new_index
c_func
(paren
)paren
suffix:semicolon
id|mp-&gt;next_module
op_assign
id|root_myri_dev
suffix:semicolon
id|root_myri_dev
op_assign
id|mp
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|myri_sbus_match
r_static
r_int
id|__init
id|myri_sbus_match
c_func
(paren
r_struct
id|sbus_dev
op_star
id|sdev
)paren
(brace
r_char
op_star
id|name
op_assign
id|sdev-&gt;prom_name
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;MYRICOM,mlanai&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;myri&quot;
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|myri_sbus_probe
r_static
r_int
id|__init
id|myri_sbus_probe
c_func
(paren
r_void
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|sbus_bus
op_star
id|bus
suffix:semicolon
r_struct
id|sbus_dev
op_star
id|sdev
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|called
op_assign
l_int|0
suffix:semicolon
r_int
id|cards
op_assign
l_int|0
comma
id|v
suffix:semicolon
macro_line|#ifdef MODULE
id|root_myri_dev
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|called
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|called
op_increment
suffix:semicolon
id|for_each_sbus
c_func
(paren
id|bus
)paren
(brace
id|for_each_sbusdev
c_func
(paren
id|sdev
comma
id|bus
)paren
(brace
r_if
c_cond
(paren
id|cards
)paren
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|myri_sbus_match
c_func
(paren
id|sdev
)paren
)paren
(brace
id|cards
op_increment
suffix:semicolon
id|DET
c_func
(paren
(paren
l_string|&quot;Found myricom myrinet as %s&bslash;n&quot;
comma
id|sdev-&gt;prom_name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|v
op_assign
id|myri_ether_init
c_func
(paren
id|dev
comma
id|sdev
comma
(paren
id|cards
op_minus
l_int|1
)paren
)paren
)paren
)paren
r_return
id|v
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|cards
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|myri_sbus_cleanup
r_static
r_void
id|__exit
id|myri_sbus_cleanup
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef MODULE
multiline_comment|/* No need to check MOD_IN_USE, as sys_delete_module() checks. */
r_while
c_loop
(paren
id|root_myri_dev
)paren
(brace
r_struct
id|myri_eth
op_star
id|next
op_assign
id|root_myri_dev-&gt;next_module
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|root_myri_dev-&gt;dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|root_myri_dev-&gt;dev
)paren
suffix:semicolon
id|root_myri_dev
op_assign
id|next
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
)brace
DECL|variable|myri_sbus_probe
id|module_init
c_func
(paren
id|myri_sbus_probe
)paren
suffix:semicolon
DECL|variable|myri_sbus_cleanup
id|module_exit
c_func
(paren
id|myri_sbus_cleanup
)paren
suffix:semicolon
eof
