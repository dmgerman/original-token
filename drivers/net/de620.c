multiline_comment|/*&n; *&t;de620.c $Revision: 1.40 $ BETA&n; *&n; *&n; *&t;Linux driver for the D-Link DE-620 Ethernet pocket adapter.&n; *&n; *&t;Portions (C) Copyright 1993, 1994 by Bjorn Ekwall &lt;bj0rn@blox.se&gt;&n; *&n; *&t;Based on adapter information gathered from DOS packetdriver&n; *&t;sources from D-Link Inc:  (Special thanks to Henry Ngai of D-Link.)&n; *&t;&t;Portions (C) Copyright D-Link SYSTEM Inc. 1991, 1992&n; *&t;&t;Copyright, 1988, Russell Nelson, Crynwr Software&n; *&n; *&t;Adapted to the sample network driver core for linux,&n; *&t;written by: Donald Becker &lt;becker@super.org&gt;&n; *&t;&t;(Now at &lt;becker@cesdis.gsfc.nasa.gov&gt;&n; *&n; *&t;Valuable assistance from:&n; *&t;&t;J. Joshua Kopper &lt;kopper@rtsg.mot.com&gt;&n; *&t;&t;Olav Kvittem &lt;Olav.Kvittem@uninett.no&gt;&n; *&t;&t;Germano Caronni &lt;caronni@nessie.cs.id.ethz.ch&gt;&n; *&t;&t;Jeremy Fitzhardinge &lt;jeremy@suite.sw.oz.au&gt;&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2, or (at your option)&n; *&t;any later version.&n; *&n; *&t;This program is distributed in the hope that it will be useful,&n; *&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *&t;GNU General Public License for more details.&n; *&n; *&t;You should have received a copy of the GNU General Public License&n; *&t;along with this program; if not, write to the Free Software&n; *&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; *****************************************************************************/
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;de620.c: $Revision: 1.40 $,  Bjorn Ekwall &lt;bj0rn@blox.se&gt;&bslash;n&quot;
suffix:semicolon
"&f;"
multiline_comment|/***********************************************************************&n; *&n; * &quot;Tuning&quot; section.&n; *&n; * Compile-time options: (see below for descriptions)&n; * -DDE620_IO=0x378&t;(lpt1)&n; * -DDE620_IRQ=7&t;(lpt1)&n; * -DDE602_DEBUG=...&n; * -DSHUTDOWN_WHEN_LOST&n; * -DCOUNT_LOOPS&n; * -DLOWSPEED&n; * -DREAD_DELAY&n; * -DWRITE_DELAY&n; */
multiline_comment|/*&n; * This driver assumes that the printer port is a &quot;normal&quot;,&n; * dumb, uni-directional port!&n; * If your port is &quot;fancy&quot; in any way, please try to set it to &quot;normal&quot;&n; * with your BIOS setup.  I have no access to machines with bi-directional&n; * ports, so I can&squot;t test such a driver :-(&n; * (Yes, I _know_ it is possible to use DE620 with bidirectional ports...)&n; *&n; * There are some clones of DE620 out there, with different names.&n; * If the current driver does not recognize a clone, try to change&n; * the following #define to:&n; *&n; * #define DE620_CLONE 1&n; */
DECL|macro|DE620_CLONE
mdefine_line|#define DE620_CLONE 0
multiline_comment|/*&n; * If the adapter has problems with high speeds, enable this #define&n; * otherwise full printerport speed will be attempted.&n; *&n; * You can tune the READ_DELAY/WRITE_DELAY below if you enable LOWSPEED&n; *&n;#define LOWSPEED&n; */
macro_line|#ifndef READ_DELAY
DECL|macro|READ_DELAY
mdefine_line|#define READ_DELAY 100&t;/* adapter internal read delay in 100ns units */
macro_line|#endif
macro_line|#ifndef WRITE_DELAY
DECL|macro|WRITE_DELAY
mdefine_line|#define WRITE_DELAY 100&t;/* adapter internal write delay in 100ns units */
macro_line|#endif
multiline_comment|/*&n; * Enable this #define if you want the adapter to do a &quot;ifconfig down&quot; on&n; * itself when we have detected that something is possibly wrong with it.&n; * The default behaviour is to retry with &quot;adapter_init()&quot; until success.&n; * This should be used for debugging purposes only.&n; *&n;#define SHUTDOWN_WHEN_LOST&n; */
multiline_comment|/*&n; * Enable debugging by &quot;-DDE620_DEBUG=3&quot; when compiling,&n; * OR by enabling the following #define&n; *&n; * use 0 for production, 1 for verification, &gt;2 for debug&n; *&n;#define DE620_DEBUG 3&n; */
macro_line|#ifdef LOWSPEED
multiline_comment|/*&n; * Enable this #define if you want to see debugging output that show how long&n; * we have to wait before the DE-620 is ready for the next read/write/command.&n; *&n;#define COUNT_LOOPS&n; */
macro_line|#endif
"&f;"
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
multiline_comment|/* Constant definitions for the DE-620 registers, commands and bits */
macro_line|#include &quot;de620.h&quot;
DECL|typedef|byte
r_typedef
r_int
r_char
id|byte
suffix:semicolon
multiline_comment|/*******************************************************&n; *                                                     *&n; * Definition of D-Link DE-620 Ethernet Pocket adapter *&n; * See also &quot;de620.h&quot;                                  *&n; *                                                     *&n; *******************************************************/
macro_line|#ifndef DE620_IO /* Compile-time configurable */
DECL|macro|DE620_IO
mdefine_line|#define DE620_IO 0x378
macro_line|#endif
macro_line|#ifndef DE620_IRQ /* Compile-time configurable */
DECL|macro|DE620_IRQ
mdefine_line|#define DE620_IRQ&t;7
macro_line|#endif
DECL|macro|DATA_PORT
mdefine_line|#define DATA_PORT&t;(dev-&gt;base_addr)
DECL|macro|STATUS_PORT
mdefine_line|#define STATUS_PORT&t;(dev-&gt;base_addr + 1)
DECL|macro|COMMAND_PORT
mdefine_line|#define COMMAND_PORT&t;(dev-&gt;base_addr + 2)
DECL|macro|RUNT
mdefine_line|#define RUNT 60&t;&t;/* Too small Ethernet packet */
DECL|macro|GIANT
mdefine_line|#define GIANT 1514&t;/* largest legal size packet, no fcs */
macro_line|#ifdef DE620_DEBUG /* Compile-time configurable */
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x) if (de620_debug &gt;= 2) printk x
macro_line|#else
DECL|macro|DE620_DEBUG
mdefine_line|#define DE620_DEBUG 0
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x) /**/
macro_line|#endif
multiline_comment|/*&n; * Force media with insmod:&n; *&t;insmod de620.o bnc=1&n; * or&n; *&t;insmod de620.o utp=1&n; *&n; * Force io and/or irq with insmod:&n; *&t;insmod de620.o io=0x378 irq=7&n; *&n; * Make a clone skip the Ethernet-address range check:&n; *&t;insmod de620.o clone=1&n; */
DECL|variable|bnc
r_static
r_int
id|bnc
op_assign
l_int|0
suffix:semicolon
DECL|variable|utp
r_static
r_int
id|utp
op_assign
l_int|0
suffix:semicolon
DECL|variable|io
r_static
r_int
id|io
op_assign
id|DE620_IO
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
op_assign
id|DE620_IRQ
suffix:semicolon
DECL|variable|clone
r_static
r_int
id|clone
op_assign
id|DE620_CLONE
suffix:semicolon
DECL|variable|de620_debug
r_static
r_int
r_int
id|de620_debug
op_assign
id|DE620_DEBUG
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|bnc
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|utp
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|clone
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|de620_debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
multiline_comment|/***********************************************&n; *                                             *&n; * Index to functions, as function prototypes. *&n; *                                             *&n; ***********************************************/
multiline_comment|/*&n; * Routines used internally. (See also &quot;convenience macros.. below&quot;)&n; */
multiline_comment|/* Put in the device structure. */
r_static
r_int
id|de620_open
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
r_static
r_int
id|de620_close
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|get_stats
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
r_static
r_void
id|de620_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
r_static
r_int
id|de620_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
comma
r_struct
id|net_device
op_star
)paren
suffix:semicolon
multiline_comment|/* Dispatch from interrupts. */
r_static
r_void
id|de620_interrupt
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_int
id|de620_rx_intr
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
multiline_comment|/* Initialization */
r_static
r_int
id|adapter_init
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
r_int
id|de620_probe
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
r_static
r_int
id|read_eeprom
c_func
(paren
r_struct
id|net_device
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * D-Link driver variables:&n; */
DECL|macro|SCR_DEF
mdefine_line|#define SCR_DEF NIBBLEMODE |INTON | SLEEP | AUTOTX
DECL|macro|TCR_DEF
mdefine_line|#define&t;TCR_DEF RXPB&t;&t;&t;/* not used: | TXSUCINT | T16INT */
DECL|macro|DE620_RX_START_PAGE
mdefine_line|#define DE620_RX_START_PAGE 12&t;&t;/* 12 pages (=3k) reserved for tx */
DECL|macro|DEF_NIC_CMD
mdefine_line|#define DEF_NIC_CMD IRQEN | ICEN | DS1
DECL|variable|NIC_Cmd
r_static
r_volatile
id|byte
id|NIC_Cmd
suffix:semicolon
DECL|variable|next_rx_page
r_static
r_volatile
id|byte
id|next_rx_page
suffix:semicolon
DECL|variable|first_rx_page
r_static
id|byte
id|first_rx_page
suffix:semicolon
DECL|variable|last_rx_page
r_static
id|byte
id|last_rx_page
suffix:semicolon
DECL|variable|EIPRegister
r_static
id|byte
id|EIPRegister
suffix:semicolon
DECL|struct|nic
r_static
r_struct
id|nic
(brace
DECL|member|NodeID
id|byte
id|NodeID
(braket
l_int|6
)braket
suffix:semicolon
DECL|member|RAM_Size
id|byte
id|RAM_Size
suffix:semicolon
DECL|member|Model
id|byte
id|Model
suffix:semicolon
DECL|member|Media
id|byte
id|Media
suffix:semicolon
DECL|member|SCR
id|byte
id|SCR
suffix:semicolon
DECL|variable|nic_data
)brace
id|nic_data
suffix:semicolon
"&f;"
multiline_comment|/**********************************************************&n; *                                                        *&n; * Convenience macros/functions for D-Link DE-620 adapter *&n; *                                                        *&n; **********************************************************/
DECL|macro|de620_tx_buffs
mdefine_line|#define de620_tx_buffs(dd) (inb(STATUS_PORT) &amp; (TXBF0 | TXBF1))
DECL|macro|de620_flip_ds
mdefine_line|#define de620_flip_ds(dd) NIC_Cmd ^= DS0 | DS1; outb(NIC_Cmd, COMMAND_PORT);
multiline_comment|/* Check for ready-status, and return a nibble (high 4 bits) for data input */
macro_line|#ifdef COUNT_LOOPS
DECL|variable|tot_cnt
r_static
r_int
id|tot_cnt
suffix:semicolon
macro_line|#endif
r_static
r_inline
id|byte
DECL|function|de620_ready
id|de620_ready
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|byte
id|value
suffix:semicolon
r_register
r_int
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
(paren
id|value
op_assign
id|inb
c_func
(paren
id|STATUS_PORT
)paren
)paren
op_amp
id|READY
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|cnt
op_le
l_int|1000
)paren
)paren
op_increment
id|cnt
suffix:semicolon
macro_line|#ifdef COUNT_LOOPS
id|tot_cnt
op_add_assign
id|cnt
suffix:semicolon
macro_line|#endif
r_return
id|value
op_amp
l_int|0xf0
suffix:semicolon
multiline_comment|/* nibble */
)brace
r_static
r_inline
r_void
DECL|function|de620_send_command
id|de620_send_command
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|byte
id|cmd
)paren
(brace
id|de620_ready
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|W_DUMMY
)paren
id|outb
c_func
(paren
id|NIC_Cmd
comma
id|COMMAND_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|cmd
comma
id|DATA_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|NIC_Cmd
op_xor
id|CS0
comma
id|COMMAND_PORT
)paren
suffix:semicolon
id|de620_ready
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outb
c_func
(paren
id|NIC_Cmd
comma
id|COMMAND_PORT
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|de620_put_byte
id|de620_put_byte
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|byte
id|value
)paren
(brace
multiline_comment|/* The de620_ready() makes 7 loops, on the average, on a DX2/66 */
id|de620_ready
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outb
c_func
(paren
id|value
comma
id|DATA_PORT
)paren
suffix:semicolon
id|de620_flip_ds
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_static
r_inline
id|byte
DECL|function|de620_read_byte
id|de620_read_byte
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|byte
id|value
suffix:semicolon
multiline_comment|/* The de620_ready() makes 7 loops, on the average, on a DX2/66 */
id|value
op_assign
id|de620_ready
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* High nibble */
id|de620_flip_ds
c_func
(paren
id|dev
)paren
suffix:semicolon
id|value
op_or_assign
id|de620_ready
c_func
(paren
id|dev
)paren
op_rshift
l_int|4
suffix:semicolon
multiline_comment|/* Low nibble */
r_return
id|value
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|de620_write_block
id|de620_write_block
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|byte
op_star
id|buffer
comma
r_int
id|count
)paren
(brace
macro_line|#ifndef LOWSPEED
id|byte
id|uflip
op_assign
id|NIC_Cmd
op_xor
(paren
id|DS0
op_or
id|DS1
)paren
suffix:semicolon
id|byte
id|dflip
op_assign
id|NIC_Cmd
suffix:semicolon
macro_line|#else /* LOWSPEED */
macro_line|#ifdef COUNT_LOOPS
r_int
id|bytes
op_assign
id|count
suffix:semicolon
macro_line|#endif /* COUNT_LOOPS */
macro_line|#endif /* LOWSPEED */
macro_line|#ifdef LOWSPEED
macro_line|#ifdef COUNT_LOOPS
id|tot_cnt
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* COUNT_LOOPS */
multiline_comment|/* No further optimization useful, the limit is in the adapter. */
r_for
c_loop
(paren
suffix:semicolon
id|count
OG
l_int|0
suffix:semicolon
op_decrement
id|count
comma
op_increment
id|buffer
)paren
(brace
id|de620_put_byte
c_func
(paren
id|dev
comma
op_star
id|buffer
)paren
suffix:semicolon
)brace
id|de620_send_command
c_func
(paren
id|dev
comma
id|W_DUMMY
)paren
suffix:semicolon
macro_line|#ifdef COUNT_LOOPS
multiline_comment|/* trial debug output: loops per byte in de620_ready() */
id|printk
c_func
(paren
l_string|&quot;WRITE(%d)&bslash;n&quot;
comma
id|tot_cnt
op_div
(paren
(paren
id|bytes
ques
c_cond
id|bytes
suffix:colon
l_int|1
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif /* COUNT_LOOPS */
macro_line|#else /* not LOWSPEED */
r_for
c_loop
(paren
suffix:semicolon
id|count
OG
l_int|0
suffix:semicolon
id|count
op_sub_assign
l_int|2
)paren
(brace
id|outb
c_func
(paren
op_star
id|buffer
op_increment
comma
id|DATA_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|uflip
comma
id|COMMAND_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
op_star
id|buffer
op_increment
comma
id|DATA_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|dflip
comma
id|COMMAND_PORT
)paren
suffix:semicolon
)brace
id|de620_send_command
c_func
(paren
id|dev
comma
id|W_DUMMY
)paren
suffix:semicolon
macro_line|#endif /* LOWSPEED */
)brace
r_static
r_inline
r_void
DECL|function|de620_read_block
id|de620_read_block
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|byte
op_star
id|data
comma
r_int
id|count
)paren
(brace
macro_line|#ifndef LOWSPEED
id|byte
id|value
suffix:semicolon
id|byte
id|uflip
op_assign
id|NIC_Cmd
op_xor
(paren
id|DS0
op_or
id|DS1
)paren
suffix:semicolon
id|byte
id|dflip
op_assign
id|NIC_Cmd
suffix:semicolon
macro_line|#else /* LOWSPEED */
macro_line|#ifdef COUNT_LOOPS
r_int
id|bytes
op_assign
id|count
suffix:semicolon
id|tot_cnt
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* COUNT_LOOPS */
macro_line|#endif /* LOWSPEED */
macro_line|#ifdef LOWSPEED
multiline_comment|/* No further optimization useful, the limit is in the adapter. */
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
op_star
id|data
op_increment
op_assign
id|de620_read_byte
c_func
(paren
id|dev
)paren
suffix:semicolon
id|de620_flip_ds
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#ifdef COUNT_LOOPS
multiline_comment|/* trial debug output: loops per byte in de620_ready() */
id|printk
c_func
(paren
l_string|&quot;READ(%d)&bslash;n&quot;
comma
id|tot_cnt
op_div
(paren
l_int|2
op_star
(paren
id|bytes
ques
c_cond
id|bytes
suffix:colon
l_int|1
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif /* COUNT_LOOPS */
macro_line|#else /* not LOWSPEED */
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
id|value
op_assign
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
l_int|0xf0
suffix:semicolon
multiline_comment|/* High nibble */
id|outb
c_func
(paren
id|uflip
comma
id|COMMAND_PORT
)paren
suffix:semicolon
op_star
id|data
op_increment
op_assign
id|value
op_or
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_rshift
l_int|4
suffix:semicolon
multiline_comment|/* Low nibble */
id|outb
c_func
(paren
id|dflip
comma
id|COMMAND_PORT
)paren
suffix:semicolon
)brace
macro_line|#endif /* LOWSPEED */
)brace
r_static
r_inline
r_void
DECL|function|de620_set_delay
id|de620_set_delay
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|de620_ready
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outb
c_func
(paren
id|W_DFR
comma
id|DATA_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|NIC_Cmd
op_xor
id|CS0
comma
id|COMMAND_PORT
)paren
suffix:semicolon
id|de620_ready
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#ifdef LOWSPEED
id|outb
c_func
(paren
id|WRITE_DELAY
comma
id|DATA_PORT
)paren
suffix:semicolon
macro_line|#else
id|outb
c_func
(paren
l_int|0
comma
id|DATA_PORT
)paren
suffix:semicolon
macro_line|#endif
id|de620_flip_ds
c_func
(paren
id|dev
)paren
suffix:semicolon
id|de620_ready
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#ifdef LOWSPEED
id|outb
c_func
(paren
id|READ_DELAY
comma
id|DATA_PORT
)paren
suffix:semicolon
macro_line|#else
id|outb
c_func
(paren
l_int|0
comma
id|DATA_PORT
)paren
suffix:semicolon
macro_line|#endif
id|de620_flip_ds
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|de620_set_register
id|de620_set_register
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|byte
id|reg
comma
id|byte
id|value
)paren
(brace
id|de620_ready
c_func
(paren
id|dev
)paren
suffix:semicolon
id|outb
c_func
(paren
id|reg
comma
id|DATA_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|NIC_Cmd
op_xor
id|CS0
comma
id|COMMAND_PORT
)paren
suffix:semicolon
id|de620_put_byte
c_func
(paren
id|dev
comma
id|value
)paren
suffix:semicolon
)brace
r_static
r_inline
id|byte
DECL|function|de620_get_register
id|de620_get_register
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|byte
id|reg
)paren
(brace
id|byte
id|value
suffix:semicolon
id|de620_send_command
c_func
(paren
id|dev
comma
id|reg
)paren
suffix:semicolon
id|value
op_assign
id|de620_read_byte
c_func
(paren
id|dev
)paren
suffix:semicolon
id|de620_send_command
c_func
(paren
id|dev
comma
id|W_DUMMY
)paren
suffix:semicolon
r_return
id|value
suffix:semicolon
)brace
"&f;"
multiline_comment|/*********************************************************************&n; *&n; * Open/initialize the board.&n; *&n; * This routine should set everything up anew at each open, even&n; * registers that &quot;should&quot; only need to be set once at boot, so that&n; * there is a non-reboot way to recover if something goes wrong.&n; *&n; */
DECL|function|de620_open
r_static
r_int
id|de620_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ret
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
id|de620_interrupt
comma
l_int|0
comma
id|dev-&gt;name
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;%s: unable to get IRQ %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|adapter_init
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/************************************************&n; *&n; * The inverse routine to de620_open().&n; *&n; */
DECL|function|de620_close
r_static
r_int
id|de620_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* disable recv */
id|de620_set_register
c_func
(paren
id|dev
comma
id|W_TCR
comma
id|RXOFF
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*********************************************&n; *&n; * Return current statistics&n; *&n; */
DECL|function|get_stats
r_static
r_struct
id|net_device_stats
op_star
id|get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_return
(paren
r_struct
id|net_device_stats
op_star
)paren
(paren
id|dev-&gt;priv
)paren
suffix:semicolon
)brace
multiline_comment|/*********************************************&n; *&n; * Set or clear the multicast filter for this adaptor.&n; * (no real multicast implemented for the DE-620, but she can be promiscuous...)&n; *&n; */
DECL|function|de620_set_multicast_list
r_static
r_void
id|de620_set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;mc_count
op_logical_or
id|dev-&gt;flags
op_amp
(paren
id|IFF_ALLMULTI
op_or
id|IFF_PROMISC
)paren
)paren
(brace
multiline_comment|/* Enable promiscuous mode */
multiline_comment|/*&n;&t;&t; *&t;We must make the kernel realise we had to move&n;&t;&t; *&t;into promisc mode or we start all out war on&n;&t;&t; *&t;the cable. - AC&n;&t;&t; */
id|dev-&gt;flags
op_or_assign
id|IFF_PROMISC
suffix:semicolon
id|de620_set_register
c_func
(paren
id|dev
comma
id|W_TCR
comma
(paren
id|TCR_DEF
op_amp
op_complement
id|RXPBM
)paren
op_or
id|RXALL
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Disable promiscuous mode, use normal mode */
id|de620_set_register
c_func
(paren
id|dev
comma
id|W_TCR
comma
id|TCR_DEF
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*******************************************************&n; *&t;&n; * Handle timeouts on transmit&n; */
DECL|function|de620_timeout
r_static
r_void
id|de620_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: transmit timed out, %s?&bslash;n&quot;
comma
id|dev-&gt;name
comma
l_string|&quot;network cable problem&quot;
)paren
suffix:semicolon
multiline_comment|/* Restart the adapter. */
r_if
c_cond
(paren
op_logical_neg
id|adapter_init
c_func
(paren
id|dev
)paren
)paren
multiline_comment|/* maybe close it */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************&n; *&n; * Copy a buffer to the adapter transmit page memory.&n; * Start sending.&n; */
DECL|function|de620_start_xmit
r_static
r_int
id|de620_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|len
suffix:semicolon
id|byte
op_star
id|buffer
op_assign
id|skb-&gt;data
suffix:semicolon
id|byte
id|using_txbuf
suffix:semicolon
id|using_txbuf
op_assign
id|de620_tx_buffs
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Peek at the adapter */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
id|skb-&gt;len
)paren
OL
id|RUNT
)paren
id|len
op_assign
id|RUNT
suffix:semicolon
r_if
c_cond
(paren
id|len
op_amp
l_int|1
)paren
multiline_comment|/* send an even number of bytes */
op_increment
id|len
suffix:semicolon
multiline_comment|/* Start real output */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;de620_start_xmit: len=%d, bufs 0x%02x&bslash;n&quot;
comma
(paren
r_int
)paren
id|skb-&gt;len
comma
id|using_txbuf
)paren
)paren
suffix:semicolon
multiline_comment|/* select a free tx buffer. if there is one... */
r_switch
c_cond
(paren
id|using_txbuf
)paren
(brace
r_default
suffix:colon
multiline_comment|/* both are free: use TXBF0 */
r_case
id|TXBF1
suffix:colon
multiline_comment|/* use TXBF0 */
id|de620_send_command
c_func
(paren
id|dev
comma
id|W_CR
op_or
id|RW0
)paren
suffix:semicolon
id|using_txbuf
op_or_assign
id|TXBF0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TXBF0
suffix:colon
multiline_comment|/* use TXBF1 */
id|de620_send_command
c_func
(paren
id|dev
comma
id|W_CR
op_or
id|RW1
)paren
suffix:semicolon
id|using_txbuf
op_or_assign
id|TXBF1
suffix:semicolon
r_break
suffix:semicolon
r_case
(paren
id|TXBF0
op_or
id|TXBF1
)paren
suffix:colon
multiline_comment|/* NONE!!! */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: No tx-buffer available!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|de620_write_block
c_func
(paren
id|dev
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|using_txbuf
op_eq
(paren
id|TXBF0
op_or
id|TXBF1
)paren
)paren
)paren
(brace
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
(paren
(paren
r_struct
id|net_device_stats
op_star
)paren
(paren
id|dev-&gt;priv
)paren
)paren
op_member_access_from_pointer
id|tx_packets
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* interrupts maybe back on */
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/*****************************************************&n; *&n; * Handle the network interface interrupts.&n; *&n; */
DECL|function|de620_interrupt
r_static
r_void
id|de620_interrupt
c_func
(paren
r_int
id|irq_in
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
id|byte
id|irq_status
suffix:semicolon
r_int
id|bogus_count
op_assign
l_int|0
suffix:semicolon
r_int
id|again
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This might be deleted now, no crummy drivers present :-) Or..? */
r_if
c_cond
(paren
(paren
id|dev
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|irq
op_ne
id|irq_in
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: bogus interrupt %d&bslash;n&quot;
comma
id|dev
ques
c_cond
id|dev-&gt;name
suffix:colon
l_string|&quot;de620&quot;
comma
id|irq_in
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Read the status register (_not_ the status port) */
id|irq_status
op_assign
id|de620_get_register
c_func
(paren
id|dev
comma
id|R_STS
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;de620_interrupt (%2.2X)&bslash;n&quot;
comma
id|irq_status
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_status
op_amp
id|RXGOOD
)paren
(brace
r_do
(brace
id|again
op_assign
id|de620_rx_intr
c_func
(paren
id|dev
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;again=%d&bslash;n&quot;
comma
id|again
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|again
op_logical_and
(paren
op_increment
id|bogus_count
OL
l_int|100
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|de620_tx_buffs
c_func
(paren
id|dev
)paren
op_ne
(paren
id|TXBF0
op_or
id|TXBF1
)paren
)paren
(brace
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**************************************&n; *&n; * Get a packet from the adapter&n; *&n; * Send it &quot;upstairs&quot;&n; *&n; */
DECL|function|de620_rx_intr
r_static
r_int
id|de620_rx_intr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|header_buf
(brace
id|byte
id|status
suffix:semicolon
id|byte
id|Rx_NextPage
suffix:semicolon
r_int
r_int
id|Rx_ByteCount
suffix:semicolon
)brace
id|header_buf
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|size
suffix:semicolon
id|byte
op_star
id|buffer
suffix:semicolon
id|byte
id|pagelink
suffix:semicolon
id|byte
id|curr_page
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;de620_rx_intr: next_rx_page = %d&bslash;n&quot;
comma
id|next_rx_page
)paren
)paren
suffix:semicolon
multiline_comment|/* Tell the adapter that we are going to read data, and from where */
id|de620_send_command
c_func
(paren
id|dev
comma
id|W_CR
op_or
id|RRN
)paren
suffix:semicolon
id|de620_set_register
c_func
(paren
id|dev
comma
id|W_RSA1
comma
id|next_rx_page
)paren
suffix:semicolon
id|de620_set_register
c_func
(paren
id|dev
comma
id|W_RSA0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Deep breath, and away we goooooo */
id|de620_read_block
c_func
(paren
id|dev
comma
(paren
id|byte
op_star
)paren
op_amp
id|header_buf
comma
r_sizeof
(paren
r_struct
id|header_buf
)paren
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;page status=0x%02x, nextpage=%d, packetsize=%d&bslash;n&quot;
comma
id|header_buf.status
comma
id|header_buf.Rx_NextPage
comma
id|header_buf.Rx_ByteCount
)paren
)paren
suffix:semicolon
multiline_comment|/* Plausible page header? */
id|pagelink
op_assign
id|header_buf.Rx_NextPage
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pagelink
OL
id|first_rx_page
)paren
op_logical_or
(paren
id|last_rx_page
OL
id|pagelink
)paren
)paren
(brace
multiline_comment|/* Ouch... Forget it! Skip all and start afresh... */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Ring overrun? Restoring...&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* You win some, you lose some. And sometimes plenty... */
id|adapter_init
c_func
(paren
id|dev
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
(paren
(paren
r_struct
id|net_device_stats
op_star
)paren
(paren
id|dev-&gt;priv
)paren
)paren
op_member_access_from_pointer
id|rx_over_errors
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* OK, this look good, so far. Let&squot;s see if it&squot;s consistent... */
multiline_comment|/* Let&squot;s compute the start of the next packet, based on where we are */
id|pagelink
op_assign
id|next_rx_page
op_plus
(paren
(paren
id|header_buf.Rx_ByteCount
op_plus
(paren
l_int|4
op_minus
l_int|1
op_plus
l_int|0x100
)paren
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Are we going to wrap around the page counter? */
r_if
c_cond
(paren
id|pagelink
OG
id|last_rx_page
)paren
id|pagelink
op_sub_assign
(paren
id|last_rx_page
op_minus
id|first_rx_page
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Is the _computed_ next page number equal to what the adapter says? */
r_if
c_cond
(paren
id|pagelink
op_ne
id|header_buf.Rx_NextPage
)paren
(brace
multiline_comment|/* Naah, we&squot;ll skip this packet. Probably bogus data as well */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Page link out of sync! Restoring...&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|next_rx_page
op_assign
id|header_buf.Rx_NextPage
suffix:semicolon
multiline_comment|/* at least a try... */
id|de620_send_command
c_func
(paren
id|dev
comma
id|W_DUMMY
)paren
suffix:semicolon
id|de620_set_register
c_func
(paren
id|dev
comma
id|W_NPRF
comma
id|next_rx_page
)paren
suffix:semicolon
(paren
(paren
r_struct
id|net_device_stats
op_star
)paren
(paren
id|dev-&gt;priv
)paren
)paren
op_member_access_from_pointer
id|rx_over_errors
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|next_rx_page
op_assign
id|pagelink
suffix:semicolon
id|size
op_assign
id|header_buf.Rx_ByteCount
op_minus
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|size
OL
id|RUNT
)paren
op_logical_or
(paren
id|GIANT
OL
id|size
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Illegal packet size: %d!&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|size
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Good packet? */
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|size
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Yeah, but no place to put it... */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Couldn&squot;t allocate a sk_buff of size %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|size
)paren
suffix:semicolon
(paren
(paren
r_struct
id|net_device_stats
op_star
)paren
(paren
id|dev-&gt;priv
)paren
)paren
op_member_access_from_pointer
id|rx_dropped
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Yep! Go get it! */
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Align */
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb-&gt;used
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* skb-&gt;data points to the start of sk_buff data area */
id|buffer
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* copy the packet into the buffer */
id|de620_read_block
c_func
(paren
id|dev
comma
id|buffer
comma
id|size
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;Read %d bytes&bslash;n&quot;
comma
id|size
)paren
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* deliver it &quot;upstairs&quot; */
multiline_comment|/* count all receives */
(paren
(paren
r_struct
id|net_device_stats
op_star
)paren
(paren
id|dev-&gt;priv
)paren
)paren
op_member_access_from_pointer
id|rx_packets
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Let&squot;s peek ahead to see if we have read the last current packet */
multiline_comment|/* NOTE! We&squot;re _not_ checking the &squot;EMPTY&squot;-flag! This seems better... */
id|curr_page
op_assign
id|de620_get_register
c_func
(paren
id|dev
comma
id|R_CPR
)paren
suffix:semicolon
id|de620_set_register
c_func
(paren
id|dev
comma
id|W_NPRF
comma
id|next_rx_page
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;next_rx_page=%d CPR=%d&bslash;n&quot;
comma
id|next_rx_page
comma
id|curr_page
)paren
)paren
suffix:semicolon
r_return
(paren
id|next_rx_page
op_ne
id|curr_page
)paren
suffix:semicolon
multiline_comment|/* That was slightly tricky... */
)brace
"&f;"
multiline_comment|/*********************************************&n; *&n; * Reset the adapter to a known state&n; *&n; */
DECL|function|adapter_init
r_static
r_int
id|adapter_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_static
r_int
id|was_down
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nic_data.Model
op_eq
l_int|3
)paren
op_logical_or
(paren
id|nic_data.Model
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* CT */
id|EIPRegister
op_assign
id|NCTL0
suffix:semicolon
r_if
c_cond
(paren
id|nic_data.Media
op_ne
l_int|1
)paren
id|EIPRegister
op_or_assign
id|NIS0
suffix:semicolon
multiline_comment|/* not BNC */
)brace
r_else
r_if
c_cond
(paren
id|nic_data.Model
op_eq
l_int|2
)paren
(brace
multiline_comment|/* UTP */
id|EIPRegister
op_assign
id|NCTL0
op_or
id|NIS0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|utp
)paren
id|EIPRegister
op_assign
id|NCTL0
op_or
id|NIS0
suffix:semicolon
r_if
c_cond
(paren
id|bnc
)paren
id|EIPRegister
op_assign
id|NCTL0
suffix:semicolon
id|de620_send_command
c_func
(paren
id|dev
comma
id|W_CR
op_or
id|RNOP
op_or
id|CLEAR
)paren
suffix:semicolon
id|de620_send_command
c_func
(paren
id|dev
comma
id|W_CR
op_or
id|RNOP
)paren
suffix:semicolon
id|de620_set_register
c_func
(paren
id|dev
comma
id|W_SCR
comma
id|SCR_DEF
)paren
suffix:semicolon
multiline_comment|/* disable recv to wait init */
id|de620_set_register
c_func
(paren
id|dev
comma
id|W_TCR
comma
id|RXOFF
)paren
suffix:semicolon
multiline_comment|/* Set the node ID in the adapter */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
op_increment
id|i
)paren
(brace
multiline_comment|/* W_PARn = 0xaa + n */
id|de620_set_register
c_func
(paren
id|dev
comma
id|W_PAR0
op_plus
id|i
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|de620_set_register
c_func
(paren
id|dev
comma
id|W_EIP
comma
id|EIPRegister
)paren
suffix:semicolon
id|next_rx_page
op_assign
id|first_rx_page
op_assign
id|DE620_RX_START_PAGE
suffix:semicolon
r_if
c_cond
(paren
id|nic_data.RAM_Size
)paren
id|last_rx_page
op_assign
id|nic_data.RAM_Size
op_minus
l_int|1
suffix:semicolon
r_else
multiline_comment|/* 64k RAM */
id|last_rx_page
op_assign
l_int|255
suffix:semicolon
id|de620_set_register
c_func
(paren
id|dev
comma
id|W_SPR
comma
id|first_rx_page
)paren
suffix:semicolon
multiline_comment|/* Start Page Register*/
id|de620_set_register
c_func
(paren
id|dev
comma
id|W_EPR
comma
id|last_rx_page
)paren
suffix:semicolon
multiline_comment|/* End Page Register */
id|de620_set_register
c_func
(paren
id|dev
comma
id|W_CPR
comma
id|first_rx_page
)paren
suffix:semicolon
multiline_comment|/*Current Page Register*/
id|de620_send_command
c_func
(paren
id|dev
comma
id|W_NPR
op_or
id|first_rx_page
)paren
suffix:semicolon
multiline_comment|/* Next Page Register*/
id|de620_send_command
c_func
(paren
id|dev
comma
id|W_DUMMY
)paren
suffix:semicolon
id|de620_set_delay
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Final sanity check: Anybody out there? */
multiline_comment|/* Let&squot;s hope some bits from the statusregister make a good check */
DECL|macro|CHECK_MASK
mdefine_line|#define CHECK_MASK (  0 | TXSUC |  T16  |  0  | RXCRC | RXSHORT |  0  |  0  )
DECL|macro|CHECK_OK
mdefine_line|#define CHECK_OK   (  0 |   0   |  0    |  0  |   0   |   0     |  0  |  0  )
multiline_comment|/* success:   X     0      0       X      0       0        X     X  */
multiline_comment|/* ignore:   EEDI                RXGOOD                   COLS  LNKS*/
r_if
c_cond
(paren
(paren
(paren
id|i
op_assign
id|de620_get_register
c_func
(paren
id|dev
comma
id|R_STS
)paren
)paren
op_amp
id|CHECK_MASK
)paren
op_ne
id|CHECK_OK
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Something has happened to the DE-620!  Please check it&quot;
macro_line|#ifdef SHUTDOWN_WHEN_LOST
l_string|&quot; and do a new ifconfig&quot;
macro_line|#endif
l_string|&quot;! (%02x)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|i
)paren
suffix:semicolon
macro_line|#ifdef SHUTDOWN_WHEN_LOST
multiline_comment|/* Goodbye, cruel world... */
id|dev-&gt;flags
op_and_assign
op_complement
id|IFF_UP
suffix:semicolon
id|de620_close
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif
id|was_down
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* failed */
)brace
r_if
c_cond
(paren
id|was_down
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Thanks, I feel much better now!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|was_down
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* All OK, go ahead... */
id|de620_set_register
c_func
(paren
id|dev
comma
id|W_TCR
comma
id|TCR_DEF
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* all ok */
)brace
"&f;"
multiline_comment|/******************************************************************************&n; *&n; * Only start-up code below&n; *&n; */
multiline_comment|/****************************************&n; *&n; * Check if there is a DE-620 connected&n; */
DECL|function|de620_probe
r_int
id|__init
id|de620_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_static
r_struct
id|net_device_stats
id|de620_netstats
suffix:semicolon
r_int
id|i
suffix:semicolon
id|byte
id|checkbyte
op_assign
l_int|0xa5
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This is where the base_addr and irq gets set.&n;&t; * Tunable at compile-time and insmod-time&n;&t; */
id|dev-&gt;base_addr
op_assign
id|io
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|de620_debug
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;D-Link DE-620 pocket adapter&quot;
)paren
suffix:semicolon
multiline_comment|/* Initially, configure basic nibble mode, so we can read the EEPROM */
id|NIC_Cmd
op_assign
id|DEF_NIC_CMD
suffix:semicolon
id|de620_set_register
c_func
(paren
id|dev
comma
id|W_EIP
comma
id|EIPRegister
)paren
suffix:semicolon
multiline_comment|/* Anybody out there? */
id|de620_set_register
c_func
(paren
id|dev
comma
id|W_CPR
comma
id|checkbyte
)paren
suffix:semicolon
id|checkbyte
op_assign
id|de620_get_register
c_func
(paren
id|dev
comma
id|R_CPR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|checkbyte
op_ne
l_int|0xa5
)paren
op_logical_or
(paren
id|read_eeprom
c_func
(paren
id|dev
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; not identified in the printer port&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#if 0 /* Not yet */
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|dev-&gt;base_addr
comma
l_int|3
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, port 0x%x busy&bslash;n&quot;
comma
id|dev-&gt;base_addr
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
macro_line|#endif
id|request_region
c_func
(paren
id|dev-&gt;base_addr
comma
l_int|3
comma
l_string|&quot;de620&quot;
)paren
suffix:semicolon
multiline_comment|/* else, got it! */
id|printk
c_func
(paren
l_string|&quot;, Ethernet Address: %2.2X&quot;
comma
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
op_assign
id|nic_data.NodeID
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;:%2.2X&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|nic_data.NodeID
(braket
id|i
)braket
)paren
suffix:semicolon
id|dev-&gt;broadcast
(braket
id|i
)braket
op_assign
l_int|0xff
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; (%dk RAM,&quot;
comma
(paren
id|nic_data.RAM_Size
)paren
ques
c_cond
(paren
id|nic_data.RAM_Size
op_rshift
l_int|2
)paren
suffix:colon
l_int|64
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nic_data.Media
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot; BNC)&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; UTP)&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Initialize the device structure. */
id|dev-&gt;priv
op_assign
op_amp
id|de620_netstats
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_device_stats
)paren
)paren
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|get_stats
suffix:semicolon
id|dev-&gt;open
op_assign
id|de620_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|de620_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|de620_start_xmit
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|de620_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|HZ
op_star
l_int|2
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|de620_set_multicast_list
suffix:semicolon
multiline_comment|/* base_addr and irq are already set, see above! */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* dump eeprom */
r_if
c_cond
(paren
id|de620_debug
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nEEPROM contents:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;RAM_Size = 0x%02X&bslash;n&quot;
comma
id|nic_data.RAM_Size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NodeID = %02X:%02X:%02X:%02X:%02X:%02X&bslash;n&quot;
comma
id|nic_data.NodeID
(braket
l_int|0
)braket
comma
id|nic_data.NodeID
(braket
l_int|1
)braket
comma
id|nic_data.NodeID
(braket
l_int|2
)braket
comma
id|nic_data.NodeID
(braket
l_int|3
)braket
comma
id|nic_data.NodeID
(braket
l_int|4
)braket
comma
id|nic_data.NodeID
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Model = %d&bslash;n&quot;
comma
id|nic_data.Model
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Media = %d&bslash;n&quot;
comma
id|nic_data.Media
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SCR = 0x%02x&bslash;n&quot;
comma
id|nic_data.SCR
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/**********************************&n; *&n; * Read info from on-board EEPROM&n; *&n; * Note: Bitwise serial I/O to/from the EEPROM vi the status _register_!&n; */
DECL|macro|sendit
mdefine_line|#define sendit(dev,data) de620_set_register(dev, W_EIP, data | EIPRegister);
DECL|function|ReadAWord
r_static
r_int
r_int
id|__init
id|ReadAWord
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|from
)paren
(brace
r_int
r_int
id|data
suffix:semicolon
r_int
id|nbits
suffix:semicolon
multiline_comment|/* cs   [__~~] SET SEND STATE */
multiline_comment|/* di   [____]                */
multiline_comment|/* sck  [_~~_]                */
id|sendit
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|sendit
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|sendit
c_func
(paren
id|dev
comma
l_int|5
)paren
suffix:semicolon
id|sendit
c_func
(paren
id|dev
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Send the 9-bit address from where we want to read the 16-bit word */
r_for
c_loop
(paren
id|nbits
op_assign
l_int|9
suffix:semicolon
id|nbits
OG
l_int|0
suffix:semicolon
op_decrement
id|nbits
comma
id|from
op_lshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|from
op_amp
l_int|0x0100
)paren
(brace
multiline_comment|/* bit set? */
multiline_comment|/* cs    [~~~~] SEND 1 */
multiline_comment|/* di    [~~~~]        */
multiline_comment|/* sck   [_~~_]        */
id|sendit
c_func
(paren
id|dev
comma
l_int|6
)paren
suffix:semicolon
id|sendit
c_func
(paren
id|dev
comma
l_int|7
)paren
suffix:semicolon
id|sendit
c_func
(paren
id|dev
comma
l_int|7
)paren
suffix:semicolon
id|sendit
c_func
(paren
id|dev
comma
l_int|6
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* cs    [~~~~] SEND 0 */
multiline_comment|/* di    [____]        */
multiline_comment|/* sck   [_~~_]        */
id|sendit
c_func
(paren
id|dev
comma
l_int|4
)paren
suffix:semicolon
id|sendit
c_func
(paren
id|dev
comma
l_int|5
)paren
suffix:semicolon
id|sendit
c_func
(paren
id|dev
comma
l_int|5
)paren
suffix:semicolon
id|sendit
c_func
(paren
id|dev
comma
l_int|4
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Shift in the 16-bit word. The bits appear serially in EEDI (=0x80) */
r_for
c_loop
(paren
id|data
op_assign
l_int|0
comma
id|nbits
op_assign
l_int|16
suffix:semicolon
id|nbits
OG
l_int|0
suffix:semicolon
op_decrement
id|nbits
)paren
(brace
multiline_comment|/* cs    [~~~~] SEND 0 */
multiline_comment|/* di    [____]        */
multiline_comment|/* sck   [_~~_]        */
id|sendit
c_func
(paren
id|dev
comma
l_int|4
)paren
suffix:semicolon
id|sendit
c_func
(paren
id|dev
comma
l_int|5
)paren
suffix:semicolon
id|sendit
c_func
(paren
id|dev
comma
l_int|5
)paren
suffix:semicolon
id|sendit
c_func
(paren
id|dev
comma
l_int|4
)paren
suffix:semicolon
id|data
op_assign
(paren
id|data
op_lshift
l_int|1
)paren
op_or
(paren
(paren
id|de620_get_register
c_func
(paren
id|dev
comma
id|R_STS
)paren
op_amp
id|EEDI
)paren
op_rshift
l_int|7
)paren
suffix:semicolon
)brace
multiline_comment|/* cs    [____] RESET SEND STATE */
multiline_comment|/* di    [____]                  */
multiline_comment|/* sck   [_~~_]                  */
id|sendit
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|sendit
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|sendit
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|sendit
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
)brace
DECL|function|read_eeprom
r_static
r_int
id|__init
id|read_eeprom
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
r_int
id|wrd
suffix:semicolon
multiline_comment|/* D-Link Ethernet addresses are in the series  00:80:c8:7X:XX:XX:XX */
id|wrd
op_assign
id|ReadAWord
c_func
(paren
id|dev
comma
l_int|0x1aa
)paren
suffix:semicolon
multiline_comment|/* bytes 0 + 1 of NodeID */
r_if
c_cond
(paren
op_logical_neg
id|clone
op_logical_and
(paren
id|wrd
op_ne
id|htons
c_func
(paren
l_int|0x0080
)paren
)paren
)paren
multiline_comment|/* Valid D-Link ether sequence? */
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Nope, not a DE-620 */
id|nic_data.NodeID
(braket
l_int|0
)braket
op_assign
id|wrd
op_amp
l_int|0xff
suffix:semicolon
id|nic_data.NodeID
(braket
l_int|1
)braket
op_assign
id|wrd
op_rshift
l_int|8
suffix:semicolon
id|wrd
op_assign
id|ReadAWord
c_func
(paren
id|dev
comma
l_int|0x1ab
)paren
suffix:semicolon
multiline_comment|/* bytes 2 + 3 of NodeID */
r_if
c_cond
(paren
op_logical_neg
id|clone
op_logical_and
(paren
(paren
id|wrd
op_amp
l_int|0xff
)paren
op_ne
l_int|0xc8
)paren
)paren
multiline_comment|/* Valid D-Link ether sequence? */
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Nope, not a DE-620 */
id|nic_data.NodeID
(braket
l_int|2
)braket
op_assign
id|wrd
op_amp
l_int|0xff
suffix:semicolon
id|nic_data.NodeID
(braket
l_int|3
)braket
op_assign
id|wrd
op_rshift
l_int|8
suffix:semicolon
id|wrd
op_assign
id|ReadAWord
c_func
(paren
id|dev
comma
l_int|0x1ac
)paren
suffix:semicolon
multiline_comment|/* bytes 4 + 5 of NodeID */
id|nic_data.NodeID
(braket
l_int|4
)braket
op_assign
id|wrd
op_amp
l_int|0xff
suffix:semicolon
id|nic_data.NodeID
(braket
l_int|5
)braket
op_assign
id|wrd
op_rshift
l_int|8
suffix:semicolon
id|wrd
op_assign
id|ReadAWord
c_func
(paren
id|dev
comma
l_int|0x1ad
)paren
suffix:semicolon
multiline_comment|/* RAM size in pages (256 bytes). 0 = 64k */
id|nic_data.RAM_Size
op_assign
(paren
id|wrd
op_rshift
l_int|8
)paren
suffix:semicolon
id|wrd
op_assign
id|ReadAWord
c_func
(paren
id|dev
comma
l_int|0x1ae
)paren
suffix:semicolon
multiline_comment|/* hardware model (CT = 3) */
id|nic_data.Model
op_assign
(paren
id|wrd
op_amp
l_int|0xff
)paren
suffix:semicolon
id|wrd
op_assign
id|ReadAWord
c_func
(paren
id|dev
comma
l_int|0x1af
)paren
suffix:semicolon
multiline_comment|/* media (indicates BNC/UTP) */
id|nic_data.Media
op_assign
(paren
id|wrd
op_amp
l_int|0xff
)paren
suffix:semicolon
id|wrd
op_assign
id|ReadAWord
c_func
(paren
id|dev
comma
l_int|0x1a8
)paren
suffix:semicolon
multiline_comment|/* System Configuration Register */
id|nic_data.SCR
op_assign
(paren
id|wrd
op_rshift
l_int|8
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* no errors */
)brace
"&f;"
multiline_comment|/******************************************************************************&n; *&n; * Loadable module skeleton&n; *&n; */
macro_line|#ifdef MODULE
DECL|variable|de620_dev
r_static
r_struct
id|net_device
id|de620_dev
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
id|de620_dev.init
op_assign
id|de620_probe
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
op_amp
id|de620_dev
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|unregister_netdev
c_func
(paren
op_amp
id|de620_dev
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|de620_dev.base_addr
comma
l_int|3
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
"&f;"
multiline_comment|/*&n; * (add &squot;-DMODULE&squot; when compiling as loadable module)&n; *&n; * compile-command:&n; *&t;gcc -D__KERNEL__ -Wall -Wstrict-prototypes -O2 &bslash;&n; *&t; -fomit-frame-pointer -m486 &bslash;&n; *&t;-I/usr/src/linux/include -I../../net/inet -c de620.c&n;*/
multiline_comment|/*&n; * Local variables:&n; *  kernel-compile-command: &quot;gcc -D__KERNEL__ -Ilinux/include -I../../net/inet -Wall -Wstrict-prototypes -O2 -m486 -c de620.c&quot;&n; *  module-compile-command: &quot;gcc -D__KERNEL__ -DMODULE -Ilinux/include -I../../net/inet -Wall -Wstrict-prototypes -O2 -m486 -c de620.c&quot;&n; *  compile-command: &quot;gcc -D__KERNEL__ -DMODULE -Ilinux/include -I../../net/inet -Wall -Wstrict-prototypes -O2 -m486 -c de620.c&quot;&n; * End:&n; */
eof
