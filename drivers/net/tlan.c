multiline_comment|/********************************************************************&n; *&n; *  Linux ThunderLAN Driver&n; *&n; *  tlan.c&n; *  by James Banks, james.banks@caldera.com&n; *&n; *  (C) 1997 Caldera, Inc.&n; *&n; *  This software may be used and distributed according to the terms&n; *  of the GNU Public License, incorporated herein by reference.&n; *&n; ** This file is best viewed/edited with tabstop=4 and colums&gt;=132.&n; *&n; ** Useful (if not required) reading:&n; *&n; *&t;&t;Texas Instruments, ThunderLAN Programmer&squot;s Guide,&n; *&t;&t;&t;TI Literature Number SPWU013A&n; *&t;&t;&t;available in PDF format from www.ti.com&n; *&t;&t;National Semiconductor, DP83840A Data Sheet&n; *&t;&t;&t;available in PDF format from www.national.com&n; *&t;&t;Microchip Technology, 24C01A/02A/04A Data Sheet&n; *&t;&t;&t;available in PDF format from www.microchip.com&n; *&n; ********************************************************************/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &quot;tlan.h&quot;
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#ifdef MODULE
DECL|variable|TLanDevices
r_static
r_struct
id|device
op_star
id|TLanDevices
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|TLanDevicesInstalled
r_static
r_int
id|TLanDevicesInstalled
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|variable|debug
r_static
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
DECL|variable|TLanPadBuffer
r_static
id|u8
op_star
id|TLanPadBuffer
suffix:semicolon
DECL|variable|TLanSignature
r_static
r_char
id|TLanSignature
(braket
)braket
op_assign
l_string|&quot;TLAN&quot;
suffix:semicolon
DECL|variable|TLanVersionMajor
r_static
r_int
id|TLanVersionMajor
op_assign
l_int|0
suffix:semicolon
DECL|variable|TLanVersionMinor
r_static
r_int
id|TLanVersionMinor
op_assign
l_int|27
suffix:semicolon
DECL|variable|TLanDeviceList
r_static
id|TLanPciId
id|TLanDeviceList
(braket
)braket
op_assign
(brace
(brace
id|PCI_VENDOR_ID_COMPAQ
comma
id|PCI_DEVICE_ID_NETELLIGENT_10
comma
l_string|&quot;Compaq Netelligent 10&quot;
)brace
comma
(brace
id|PCI_VENDOR_ID_COMPAQ
comma
id|PCI_DEVICE_ID_NETELLIGENT_10_100
comma
l_string|&quot;Compaq Netelligent 10/100&quot;
)brace
comma
(brace
id|PCI_VENDOR_ID_COMPAQ
comma
id|PCI_DEVICE_ID_NETFLEX_3_INTEGRATED
comma
l_string|&quot;Compaq Integrated NetFlex-3&quot;
)brace
comma
(brace
l_int|0
comma
l_int|0
comma
l_int|NULL
)brace
multiline_comment|/* End of List */
)brace
suffix:semicolon
r_static
r_int
id|TLan_MiiReadReg
c_func
(paren
id|u16
comma
id|u16
comma
id|u16
comma
id|u16
op_star
)paren
suffix:semicolon
r_static
r_void
id|TLan_MiiSendData
c_func
(paren
id|u16
comma
id|u32
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|TLan_MiiSync
c_func
(paren
id|u16
)paren
suffix:semicolon
r_static
r_void
id|TLan_MiiWriteReg
c_func
(paren
id|u16
comma
id|u16
comma
id|u16
comma
id|u16
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************&n;******************************************************************************&n;&n;&t;ThunderLAN Driver MII Routines&n;&n;&t;These routines are based on the information in Chap. 2 of the&n;&t;&quot;ThunderLAN Programmer&squot;s Guide&quot;, pp. 15-24.&n;&n;******************************************************************************&n;*****************************************************************************/
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_MiiReadReg&n;&t; *&n;&t; *&t;Returns:&t;0 if ack received ok, 1 otherwise.&n;&t; *&t;Parms:&t;&t;base_port&t;The base IO port of the adapter in question.&n;&t; *&t;&t;&t;&t;dev&t;&t;&t;The address of the PHY to be queried.&n;&t; *&t;&t;&t;&t;reg&t;&t;&t;The register whose contents are to be&n;&t; *&t;&t;&t;&t;&t;&t;&t;retreived.&n;&t; *&t;&t;&t;&t;val&t;&t;&t;A pointer to a variable to store the retrieved&n;&t; *&t;&t;&t;&t;&t;&t;&t;value.&n;&t; *&n;&t; *&t;This function uses the TLAN&squot;s MII bus to retreive the contents of a&n;&t; *&t;given register on a PHY.  It sends the appropriate info and then&n;&t; *&t;reads the 16-bit register value from the MII bus via the TLAN SIO&n;&t; *&t;register.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_MiiReadReg
r_int
id|TLan_MiiReadReg
c_func
(paren
id|u16
id|base_port
comma
id|u16
id|dev
comma
id|u16
id|reg
comma
id|u16
op_star
id|val
)paren
(brace
id|u8
id|nack
suffix:semicolon
id|u16
id|sio
comma
id|tmp
suffix:semicolon
id|u32
id|i
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|FALSE
suffix:semicolon
id|outw
c_func
(paren
id|TLAN_NET_SIO
comma
id|base_port
op_plus
id|TLAN_DIO_ADR
)paren
suffix:semicolon
id|sio
op_assign
id|base_port
op_plus
id|TLAN_DIO_DATA
op_plus
id|TLAN_NET_SIO
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|TLan_MiiSync
c_func
(paren
id|base_port
)paren
suffix:semicolon
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_MINTEN
comma
id|sio
)paren
suffix:semicolon
multiline_comment|/* Disable PHY ints */
id|TLan_MiiSendData
c_func
(paren
id|base_port
comma
l_int|0x1
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Start ( 01b ) */
id|TLan_MiiSendData
c_func
(paren
id|base_port
comma
l_int|0x2
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Read  ( 10b ) */
id|TLan_MiiSendData
c_func
(paren
id|base_port
comma
id|dev
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Device #      */
id|TLan_MiiSendData
c_func
(paren
id|base_port
comma
id|reg
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Register #    */
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_MTXEN
comma
id|sio
)paren
suffix:semicolon
multiline_comment|/* Change direction */
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_MCLK
comma
id|sio
)paren
suffix:semicolon
multiline_comment|/* Clock through Idle bit */
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_MCLK
comma
id|sio
)paren
suffix:semicolon
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_MCLK
comma
id|sio
)paren
suffix:semicolon
multiline_comment|/* Use this to wait 300ns */
id|nack
op_assign
id|TLan_GetBit
c_func
(paren
id|TLAN_NET_SIO_MDATA
comma
id|sio
)paren
suffix:semicolon
multiline_comment|/* Check for ACK */
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_MCLK
comma
id|sio
)paren
suffix:semicolon
multiline_comment|/* Finish ACK clock cycle */
r_if
c_cond
(paren
id|nack
)paren
(brace
multiline_comment|/* No ACK, so fake it */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_MCLK
comma
id|sio
)paren
suffix:semicolon
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_MCLK
comma
id|sio
)paren
suffix:semicolon
)brace
id|tmp
op_assign
l_int|0xffff
suffix:semicolon
id|err
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ACKed, so read data */
r_for
c_loop
(paren
id|tmp
op_assign
l_int|0
comma
id|i
op_assign
l_int|0x8000
suffix:semicolon
id|i
suffix:semicolon
id|i
op_rshift_assign
l_int|1
)paren
(brace
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_MCLK
comma
id|sio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TLan_GetBit
c_func
(paren
id|TLAN_NET_SIO_MDATA
comma
id|sio
)paren
)paren
id|tmp
op_or_assign
id|i
suffix:semicolon
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_MCLK
comma
id|sio
)paren
suffix:semicolon
)brace
)brace
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_MCLK
comma
id|sio
)paren
suffix:semicolon
multiline_comment|/* Idle cycle */
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_MCLK
comma
id|sio
)paren
suffix:semicolon
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_MINTEN
comma
id|sio
)paren
suffix:semicolon
multiline_comment|/* Enable PHY ints */
op_star
id|val
op_assign
id|tmp
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* TLan_MiiReadReg */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_MiiSendData&n;&t; *&n;&t; *&t;Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;base_port&t;The base IO port of the adapter in question.&n;&t; *&t;&t;&t;&t;dev&t;&t;&t;The address of the PHY to be queried.&n;&t; *&t;&t;&t;&t;data&t;&t;The value to be placed on the MII bus.&n;&t; *&t;&t;&t;&t;num_bits&t;The number of bits in data that are to be&n;&t; *&t;&t;&t;&t;&t;&t;&t;placed on the MII bus.&n;&t; *&n;&t; *&t;This function sends on sequence of bits on the MII configuration&n;&t; *&t;bus.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_MiiSendData
r_void
id|TLan_MiiSendData
c_func
(paren
id|u16
id|base_port
comma
id|u32
id|data
comma
r_int
id|num_bits
)paren
(brace
id|u16
id|sio
suffix:semicolon
id|u32
id|i
suffix:semicolon
r_if
c_cond
(paren
id|num_bits
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|outw
c_func
(paren
id|TLAN_NET_SIO
comma
id|base_port
op_plus
id|TLAN_DIO_ADR
)paren
suffix:semicolon
id|sio
op_assign
id|base_port
op_plus
id|TLAN_DIO_DATA
op_plus
id|TLAN_NET_SIO
suffix:semicolon
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_MTXEN
comma
id|sio
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
(paren
l_int|0x1
op_lshift
(paren
id|num_bits
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|i
suffix:semicolon
id|i
op_rshift_assign
l_int|1
)paren
(brace
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_MCLK
comma
id|sio
)paren
suffix:semicolon
id|TLan_GetBit
c_func
(paren
id|TLAN_NET_SIO_MCLK
comma
id|sio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_amp
id|i
)paren
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_MDATA
comma
id|sio
)paren
suffix:semicolon
r_else
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_MDATA
comma
id|sio
)paren
suffix:semicolon
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_MCLK
comma
id|sio
)paren
suffix:semicolon
id|TLan_GetBit
c_func
(paren
id|TLAN_NET_SIO_MCLK
comma
id|sio
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* TLan_MiiSendData */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_MiiSync&n;&t; *&n;&t; *&t;Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;base_port&t;The base IO port of the adapter in question.&n;&t; *&n;&t; *&t;This functions syncs all PHYs in terms of the MII configuration bus.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_MiiSync
r_void
id|TLan_MiiSync
c_func
(paren
id|u16
id|base_port
)paren
(brace
r_int
id|i
suffix:semicolon
id|u16
id|sio
suffix:semicolon
id|outw
c_func
(paren
id|TLAN_NET_SIO
comma
id|base_port
op_plus
id|TLAN_DIO_ADR
)paren
suffix:semicolon
id|sio
op_assign
id|base_port
op_plus
id|TLAN_DIO_DATA
op_plus
id|TLAN_NET_SIO
suffix:semicolon
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_MTXEN
comma
id|sio
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_MCLK
comma
id|sio
)paren
suffix:semicolon
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_MCLK
comma
id|sio
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* TLan_MiiSync */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_MiiWriteReg&n;&t; *&n;&t; *&t;Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;base_port&t;The base IO port of the adapter in question.&n;&t; *&t;&t;&t;&t;dev&t;&t;&t;The address of the PHY to be written to.&n;&t; *&t;&t;&t;&t;reg&t;&t;&t;The register whose contents are to be&n;&t; *&t;&t;&t;&t;&t;&t;&t;written.&n;&t; *&t;&t;&t;&t;val&t;&t;&t;The value to be written to the register.&n;&t; *&n;&t; *&t;This function uses the TLAN&squot;s MII bus to write the contents of a&n;&t; *&t;given register on a PHY.  It sends the appropriate info and then&n;&t; *&t;writes the 16-bit register value from the MII configuration bus&n;&t; *&t;via the TLAN SIO register.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_MiiWriteReg
r_void
id|TLan_MiiWriteReg
c_func
(paren
id|u16
id|base_port
comma
id|u16
id|dev
comma
id|u16
id|reg
comma
id|u16
id|val
)paren
(brace
id|u16
id|sio
suffix:semicolon
id|outw
c_func
(paren
id|TLAN_NET_SIO
comma
id|base_port
op_plus
id|TLAN_DIO_ADR
)paren
suffix:semicolon
id|sio
op_assign
id|base_port
op_plus
id|TLAN_DIO_DATA
op_plus
id|TLAN_NET_SIO
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|TLan_MiiSync
c_func
(paren
id|base_port
)paren
suffix:semicolon
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_MINTEN
comma
id|sio
)paren
suffix:semicolon
id|TLan_MiiSendData
c_func
(paren
id|base_port
comma
l_int|0x1
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Start ( 01b ) */
id|TLan_MiiSendData
c_func
(paren
id|base_port
comma
l_int|0x1
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Write ( 01b ) */
id|TLan_MiiSendData
c_func
(paren
id|base_port
comma
id|dev
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Device #      */
id|TLan_MiiSendData
c_func
(paren
id|base_port
comma
id|reg
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/* Register #    */
id|TLan_MiiSendData
c_func
(paren
id|base_port
comma
l_int|0x2
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Send ACK */
id|TLan_MiiSendData
c_func
(paren
id|base_port
comma
id|val
comma
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Send Data */
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_MCLK
comma
id|sio
)paren
suffix:semicolon
multiline_comment|/* Idle cycle */
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_MCLK
comma
id|sio
)paren
suffix:semicolon
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_MINTEN
comma
id|sio
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* TLan_MiiWriteReg */
multiline_comment|/*****************************************************************************&n;******************************************************************************&n;&n;&t;ThunderLAN Driver PHY Layer Routines&n;&n;&t;The TLAN chip can drive any number of PHYs (physical devices).  Rather&n;&t;than having lots of &squot;if&squot; or &squot;#ifdef&squot; statements, I have created a&n;&t;second driver layer for the PHYs.  Each PHY can be identified from its&n;&t;id in registers 2 and 3, and can be given a Check and Service routine&n;&t;that will be called when the adapter is reset and when the adapter&n;&t;receives a Network Status interrupt, respectively.&n;&t;&n;******************************************************************************&n;*****************************************************************************/
r_static
r_int
id|TLan_PhyNop
c_func
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_void
id|TLan_PhyPrint
c_func
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_void
id|TLan_PhySelect
c_func
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_int
id|TLan_PhyInternalCheck
c_func
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_int
id|TLan_PhyInternalService
c_func
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_int
id|TLan_PhyDp83840aCheck
c_func
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
DECL|variable|TLanPhyIdTable
r_static
id|TLanPhyIdEntry
id|TLanPhyIdTable
(braket
)braket
op_assign
(brace
(brace
l_int|0x4000
comma
l_int|0x5014
comma
op_amp
id|TLan_PhyInternalCheck
comma
op_amp
id|TLan_PhyInternalService
comma
id|TLAN_PHY_ACTIVITY
)brace
comma
(brace
l_int|0x4000
comma
l_int|0x5015
comma
op_amp
id|TLan_PhyInternalCheck
comma
op_amp
id|TLan_PhyInternalService
comma
id|TLAN_PHY_ACTIVITY
)brace
comma
(brace
l_int|0x2000
comma
l_int|0x5C01
comma
op_amp
id|TLan_PhyDp83840aCheck
comma
op_amp
id|TLan_PhyNop
comma
id|TLAN_PHY_ACTIVITY
op_or
id|TLAN_PHY_AUTONEG
)brace
comma
(brace
l_int|0x0000
comma
l_int|0x0000
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/*************************************************************************&n;     *  TLan_PhyPrint&n;&t; *&n;&t; *&t;Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;dev&t;&t;A pointer to the device structure of the adapter&n;&t; *&t;&t;&t;&t;&t;&t;which the desired PHY is located.&n;&t; *&t;&t;&t;&t;&n;&t; *&t;This function prints the registers a PHY.&n;     *&n;     ************************************************************************/
DECL|function|TLan_PhyPrint
r_void
id|TLan_PhyPrint
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|TLanPrivateInfo
op_star
id|priv
op_assign
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u16
id|i
comma
id|data0
comma
id|data1
comma
id|data2
comma
id|data3
comma
id|phy
suffix:semicolon
id|u32
id|io
suffix:semicolon
id|phy
op_assign
id|priv-&gt;phyAddr
suffix:semicolon
id|io
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|phy
OG
l_int|0
)paren
op_logical_or
(paren
id|phy
op_le
id|TLAN_PHY_MAX_ADDR
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TLAN:   Device %s, PHY 0x%02x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|phy
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TLAN:      Off.  +0     +1     +2     +3 &bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x20
suffix:semicolon
id|i
op_add_assign
l_int|4
)paren
(brace
id|TLan_MiiReadReg
c_func
(paren
id|io
comma
id|phy
comma
id|i
comma
op_amp
id|data0
)paren
suffix:semicolon
id|TLan_MiiReadReg
c_func
(paren
id|io
comma
id|phy
comma
id|i
op_plus
l_int|1
comma
op_amp
id|data1
)paren
suffix:semicolon
id|TLan_MiiReadReg
c_func
(paren
id|io
comma
id|phy
comma
id|i
op_plus
l_int|2
comma
op_amp
id|data2
)paren
suffix:semicolon
id|TLan_MiiReadReg
c_func
(paren
id|io
comma
id|phy
comma
id|i
op_plus
l_int|3
comma
op_amp
id|data3
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TLAN:      0x%02x  0x%04hx 0x%04hx 0x%04hx 0x%04hx&bslash;n&quot;
comma
id|i
comma
id|data0
comma
id|data1
comma
id|data2
comma
id|data3
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;TLAN:   Device %s, PHY 0x%02x (Invalid).&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|phy
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* TLan_PhyPrint */
multiline_comment|/*************************************************************************&n;     *  TLan_PhySelect&n;&t; *&n;&t; *&t;Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;dev&t;&t;A pointer to the device structure of the adapter&n;&t; *&t;&t;&t;&t;&t;&t;for which the PHY needs determined.&n;     *&n;&t; *&t;This function decides which PHY amoung those attached to the TLAN chip&n;&t; *&t;is to be used.  The TLAN chip can be attached to multiple PHYs, and&n;&t; *&t;the driver needs to decide which one to talk to.  Currently this&n;&t; *&t;routine picks the PHY with the lowest address as the internal PHY&n;&t; *&t;address is 0x1F, the highest possible.  This strategy assumes that&n;&t; *&t;there can be only one other PHY, and, if it exists, it is the one to&n;&t; *&t;be used.  If token ring PHYs are ever supported, this routine will&n;&t; *&t;become a little more interesting...&n;&t; *&n;     ************************************************************************/
DECL|function|TLan_PhySelect
r_void
id|TLan_PhySelect
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
id|phy
suffix:semicolon
r_int
id|entry
suffix:semicolon
id|u16
id|id_hi
suffix:semicolon
id|u16
id|id_lo
suffix:semicolon
id|TLanPrivateInfo
op_star
id|priv
op_assign
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u16
id|val
suffix:semicolon
id|priv-&gt;phyCheck
op_assign
op_amp
id|TLan_PhyNop
suffix:semicolon
singleline_comment|// Make absolutely sure these aren&squot;t NULL
id|priv-&gt;phyService
op_assign
op_amp
id|TLan_PhyNop
suffix:semicolon
r_for
c_loop
(paren
id|phy
op_assign
l_int|0
suffix:semicolon
id|phy
op_le
id|TLAN_PHY_MAX_ADDR
suffix:semicolon
id|phy
op_increment
)paren
(brace
id|err
op_assign
id|TLan_MiiReadReg
c_func
(paren
id|dev-&gt;base_addr
comma
id|phy
comma
l_int|0
comma
op_amp
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|TLan_MiiReadReg
c_func
(paren
id|dev-&gt;base_addr
comma
id|phy
comma
id|MII_GEN_ID_HI
comma
op_amp
id|id_hi
)paren
suffix:semicolon
id|TLan_MiiReadReg
c_func
(paren
id|dev-&gt;base_addr
comma
id|phy
comma
id|MII_GEN_ID_LO
comma
op_amp
id|id_lo
)paren
suffix:semicolon
id|entry
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|TLanPhyIdTable
(braket
id|entry
)braket
dot
id|idHi
op_ne
l_int|0
)paren
op_logical_and
(paren
id|TLanPhyIdTable
(braket
id|entry
)braket
dot
id|idLo
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|TLanPhyIdTable
(braket
id|entry
)braket
dot
id|idHi
op_eq
id|id_hi
)paren
op_logical_and
(paren
id|TLanPhyIdTable
(braket
id|entry
)braket
dot
id|idLo
op_eq
id|id_lo
)paren
)paren
(brace
id|priv-&gt;phyAddr
op_assign
id|phy
suffix:semicolon
id|priv-&gt;phyEntry
op_assign
id|entry
suffix:semicolon
id|priv-&gt;phyCheck
op_assign
id|TLanPhyIdTable
(braket
id|entry
)braket
dot
id|check
suffix:semicolon
id|priv-&gt;phyService
op_assign
id|TLanPhyIdTable
(braket
id|entry
)braket
dot
id|service
suffix:semicolon
id|priv-&gt;phyFlags
op_assign
id|TLanPhyIdTable
(braket
id|entry
)braket
dot
id|flags
suffix:semicolon
r_break
suffix:semicolon
)brace
id|entry
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* TLan_PhySelect */
multiline_comment|/*************************************************************************&n;     *  TLan_PhyNop&n;     *&n;&t; *&t;Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;dev&t;&t;A pointer to a device structure.&n;&t; *&n;&t; *&t;This function does nothing and is meant as a stand-in for when&n;&t; *&t;a Check or Service function would be meaningless.&n;&t; *&n;     ************************************************************************/
DECL|function|TLan_PhyNop
r_int
id|TLan_PhyNop
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* TLan_PhyNop */
multiline_comment|/*************************************************************************&n;     *  TLan_PhyInternalCheck&n;     *&n;&t; *&t;Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;dev&t;&t;A pointer to a device structure of the adapter&n;&t; *&t;&t;&t;&t;&t;&t;holding the PHY to be checked.&n;&t; *&n;&t; *&t;This function resets the internal PHY on a TLAN chip.  See Chap. 7,&n;&t; *&t;&quot;Physical Interface (PHY)&quot; of &quot;ThunderLAN Programmer&squot;s Guide&quot;&n;     *&n;     ************************************************************************/
DECL|function|TLan_PhyInternalCheck
r_int
id|TLan_PhyInternalCheck
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|u16
id|gen_ctl
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u32
id|io
suffix:semicolon
id|u16
id|phy
suffix:semicolon
id|TLanPrivateInfo
op_star
id|priv
op_assign
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u16
id|value
suffix:semicolon
id|io
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|phy
op_assign
id|priv-&gt;phyAddr
suffix:semicolon
id|TLan_MiiReadReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_GEN_CTL
comma
op_amp
id|gen_ctl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gen_ctl
op_amp
id|MII_GC_PDOWN
)paren
(brace
id|TLan_MiiSync
c_func
(paren
id|io
)paren
suffix:semicolon
id|TLan_MiiWriteReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_GEN_CTL
comma
id|MII_GC_PDOWN
op_or
id|MII_GC_LOOPBK
op_or
id|MII_GC_ISOLATE
)paren
suffix:semicolon
id|TLan_MiiWriteReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_GEN_CTL
comma
id|MII_GC_LOOPBK
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|500000
suffix:semicolon
id|i
op_increment
)paren
id|SLOW_DOWN_IO
suffix:semicolon
id|TLan_MiiWriteReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_GEN_CTL
comma
id|MII_GC_RESET
op_or
id|MII_GC_LOOPBK
)paren
suffix:semicolon
id|TLan_MiiSync
c_func
(paren
id|io
)paren
suffix:semicolon
)brace
id|TLan_MiiReadReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_GEN_CTL
comma
op_amp
id|value
)paren
suffix:semicolon
r_while
c_loop
(paren
id|value
op_amp
id|MII_GC_RESET
)paren
id|TLan_MiiReadReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_GEN_CTL
comma
op_amp
id|value
)paren
suffix:semicolon
singleline_comment|// TLan_MiiWriteReg( io, phy, MII_GEN_CTL, MII_GC_LOOPBK | MII_GC_DUPLEX );
singleline_comment|// TLan_MiiWriteReg( io, phy, MII_GEN_CTL, MII_GC_DUPLEX );
id|TLan_MiiWriteReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_GEN_CTL
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|500000
suffix:semicolon
id|i
op_increment
)paren
id|SLOW_DOWN_IO
suffix:semicolon
singleline_comment|// Read Possible Latched Link Status
id|TLan_MiiReadReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_GEN_STS
comma
op_amp
id|value
)paren
suffix:semicolon
singleline_comment|// Read Real Link Status
id|TLan_MiiReadReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_GEN_STS
comma
op_amp
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_amp
id|MII_GS_LINK
)paren
(brace
id|priv-&gt;phyOnline
op_assign
l_int|1
suffix:semicolon
id|TLan_DioWrite8
c_func
(paren
id|io
comma
id|TLAN_LED_REG
comma
id|TLAN_LED_LINK
)paren
suffix:semicolon
)brace
r_else
(brace
id|priv-&gt;phyOnline
op_assign
l_int|0
suffix:semicolon
id|TLan_DioWrite8
c_func
(paren
id|io
comma
id|TLAN_LED_REG
comma
l_int|0
)paren
suffix:semicolon
)brace
singleline_comment|// Enable Interrupts
id|TLan_MiiReadReg
c_func
(paren
id|io
comma
id|phy
comma
id|TLAN_TLPHY_CTL
comma
op_amp
id|value
)paren
suffix:semicolon
id|value
op_or_assign
id|TLAN_TC_INTEN
suffix:semicolon
id|TLan_MiiWriteReg
c_func
(paren
id|io
comma
id|phy
comma
id|TLAN_TLPHY_CTL
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* TLanPhyInternalCheck */
multiline_comment|/*************************************************************************&n;     *  TLan_PhyInternalService&n;     *&n;&t; *&t;Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;dev&t;&t;A pointer to a device structure of the adapter&n;&t; *&t;&t;&t;&t;&t;&t;holding the PHY to be serviced.&n;&t; *&n;&t; *&t;This function services an interrupt generated by the internal PHY.&n;&t; *&t;It can turn on/off the link LED.  See Chap. 7,&n;&t; *&t;&quot;Physical Interface (PHY)&quot; of &quot;ThunderLAN Programmer&squot;s Guide&quot;.&n;     *&n;     ************************************************************************/
DECL|function|TLan_PhyInternalService
r_int
id|TLan_PhyInternalService
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|u16
id|tlphy_sts
suffix:semicolon
id|u16
id|gen_sts
suffix:semicolon
id|u16
id|an_exp
suffix:semicolon
id|u32
id|io
suffix:semicolon
id|u16
id|phy
suffix:semicolon
id|TLanPrivateInfo
op_star
id|priv
op_assign
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|io
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|phy
op_assign
id|priv-&gt;phyAddr
suffix:semicolon
id|TLan_MiiReadReg
c_func
(paren
id|io
comma
id|phy
comma
id|TLAN_TLPHY_STS
comma
op_amp
id|tlphy_sts
)paren
suffix:semicolon
id|TLan_MiiReadReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_GEN_STS
comma
op_amp
id|gen_sts
)paren
suffix:semicolon
id|TLan_MiiReadReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_AN_EXP
comma
op_amp
id|an_exp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gen_sts
op_amp
id|MII_GS_LINK
)paren
(brace
id|priv-&gt;phyOnline
op_assign
l_int|1
suffix:semicolon
id|TLan_DioWrite8
c_func
(paren
id|io
comma
id|TLAN_LED_REG
comma
id|TLAN_LED_LINK
)paren
suffix:semicolon
)brace
r_else
(brace
id|priv-&gt;phyOnline
op_assign
l_int|0
suffix:semicolon
id|TLan_DioWrite8
c_func
(paren
id|io
comma
id|TLAN_LED_REG
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* TLan_PhyInternalService */
multiline_comment|/*************************************************************************&n;     *  TLan_PhyDp83840aCheck&n;     *&n;&t; *&t;Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;dev&t;&t;A pointer to a device structure of the adapter&n;&t; *&t;&t;&t;&t;&t;&t;holding the PHY to be reset.&n;&t; *&n;&t; *&t;This function resets a National Semiconductor DP83840A 10/100 Mb/s&n;&t; *&t;PHY device.  See National Semiconductor&squot;s data sheet for more info.&n;&t; *&t;This PHY is used on Compaq Netelligent 10/100 cards.&n;     *&n;     ************************************************************************/
DECL|function|TLan_PhyDp83840aCheck
r_static
r_int
id|TLan_PhyDp83840aCheck
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|u16
id|gen_ctl
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u32
id|io
suffix:semicolon
id|u16
id|phy
suffix:semicolon
id|TLanPrivateInfo
op_star
id|priv
op_assign
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u16
id|value
suffix:semicolon
id|io
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|phy
op_assign
id|priv-&gt;phyAddr
suffix:semicolon
id|TLan_MiiReadReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_GEN_CTL
comma
op_amp
id|gen_ctl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gen_ctl
op_amp
id|MII_GC_PDOWN
)paren
(brace
id|TLan_MiiSync
c_func
(paren
id|io
)paren
suffix:semicolon
id|TLan_MiiWriteReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_GEN_CTL
comma
id|MII_GC_PDOWN
op_or
id|MII_GC_LOOPBK
op_or
id|MII_GC_ISOLATE
)paren
suffix:semicolon
id|TLan_MiiWriteReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_GEN_CTL
comma
id|MII_GC_LOOPBK
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|500000
suffix:semicolon
id|i
op_increment
)paren
id|SLOW_DOWN_IO
suffix:semicolon
id|TLan_MiiWriteReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_GEN_CTL
comma
id|MII_GC_RESET
op_or
id|MII_GC_LOOPBK
)paren
suffix:semicolon
id|TLan_MiiSync
c_func
(paren
id|io
)paren
suffix:semicolon
)brace
id|TLan_MiiReadReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_GEN_CTL
comma
op_amp
id|value
)paren
suffix:semicolon
r_while
c_loop
(paren
id|value
op_amp
id|MII_GC_RESET
)paren
id|TLan_MiiReadReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_GEN_CTL
comma
op_amp
id|value
)paren
suffix:semicolon
singleline_comment|// TLan_MiiWriteReg( io, phy, MII_GEN_CTL, MII_GC_LOOPBK | MII_GC_DUPLEX );
singleline_comment|// TLan_MiiWriteReg( io, phy, MII_GEN_CTL, MII_GC_DUPLEX );
id|TLan_MiiWriteReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_GEN_CTL
comma
l_int|0
)paren
suffix:semicolon
id|TLan_MiiWriteReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_GEN_CTL
comma
l_int|0x1000
)paren
suffix:semicolon
id|TLan_MiiWriteReg
c_func
(paren
id|io
comma
id|phy
comma
id|MII_GEN_CTL
comma
l_int|0x1200
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|50000
suffix:semicolon
id|i
op_increment
)paren
id|SLOW_DOWN_IO
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;// Read Possible Latched Link Status&n;            TLan_MiiReadReg( io, phy, MII_GEN_STS, &amp;value ); &n;&t;&t;&t;// Read Real Link Status&n;            TLan_MiiReadReg( io, phy, MII_GEN_STS, &amp;value ); &n;&t;&t;&t;if ( value &amp; MII_GS_LINK ) {&n;&t;&t;&t;&t;priv-&gt;phyOnline = 1;&n;&t;&t;&t;&t;TLan_DioWrite8( io, TLAN_LED_REG, TLAN_LED_LINK );&n;&t;&t;&t;} else {&n;&t;&t;&t;&t;priv-&gt;phyOnline = 0;&n;&t;&t;&t;&t;TLan_DioWrite8( io, TLAN_LED_REG, 0 );&n;&t;&t;&t;}&n;&n;&t;&t;&t;// Enable Interrupts&n;            TLan_MiiReadReg( io, phy, TLAN_TLPHY_CTL, &amp;value );&n;            value |= TLAN_TC_INTEN;&n;            TLan_MiiWriteReg( io, phy, TLAN_TLPHY_CTL, value );&n;*/
id|priv-&gt;phyOnline
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* TLan_PhyDp83840aCheck */
multiline_comment|/*****************************************************************************&n;******************************************************************************&n;&n;&t;ThunderLAN Driver Adapter Related Routines&n;&n;******************************************************************************&n;*****************************************************************************/
r_static
r_void
id|TLan_ResetLists
c_func
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_void
id|TLan_PrintDio
c_func
(paren
id|u16
)paren
suffix:semicolon
r_static
r_void
id|TLan_PrintList
c_func
(paren
id|TLanList
op_star
comma
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|TLan_ReadAndClearStats
c_func
(paren
r_struct
id|device
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|TLan_Reset
c_func
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_void
id|TLan_SetMac
c_func
(paren
r_struct
id|device
op_star
comma
r_int
id|areg
comma
r_char
op_star
id|mac
)paren
suffix:semicolon
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_ResetLists&n;&t; *  &n;&t; *  Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;dev&t;&t;The device structure with the list stuctures to&n;&t; *&t;&t;&t;&t;&t;&t;be reset.&n;&t; *&n;&t; *&t;This routine sets the variables associated with managing the TLAN&n;&t; *&t;lists to their initial values.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_ResetLists
r_void
id|TLan_ResetLists
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
id|TLanList
op_star
id|list
suffix:semicolon
id|TLanPrivateInfo
op_star
id|priv
op_assign
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|priv-&gt;txHead
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;txTail
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TLAN_NUM_TX_LISTS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|list
op_assign
id|priv-&gt;txList
op_plus
id|i
suffix:semicolon
id|list-&gt;cStat
op_assign
id|TLAN_CSTAT_UNUSED
suffix:semicolon
id|list-&gt;buffer
(braket
l_int|0
)braket
dot
id|address
op_assign
id|virt_to_bus
c_func
(paren
id|priv-&gt;txBuffer
op_plus
(paren
id|i
op_star
id|TLAN_MAX_FRAME_SIZE
)paren
)paren
suffix:semicolon
id|list-&gt;buffer
(braket
l_int|2
)braket
dot
id|count
op_assign
l_int|0
suffix:semicolon
id|list-&gt;buffer
(braket
l_int|2
)braket
dot
id|address
op_assign
l_int|0
suffix:semicolon
)brace
id|priv-&gt;rxHead
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;rxTail
op_assign
id|TLAN_NUM_RX_LISTS
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TLAN_NUM_RX_LISTS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|list
op_assign
id|priv-&gt;rxList
op_plus
id|i
suffix:semicolon
id|list-&gt;cStat
op_assign
id|TLAN_CSTAT_READY
suffix:semicolon
id|list-&gt;frameSize
op_assign
id|TLAN_MAX_FRAME_SIZE
suffix:semicolon
id|list-&gt;buffer
(braket
l_int|0
)braket
dot
id|count
op_assign
id|TLAN_MAX_FRAME_SIZE
op_or
id|TLAN_LAST_BUFFER
suffix:semicolon
id|list-&gt;buffer
(braket
l_int|0
)braket
dot
id|address
op_assign
id|virt_to_bus
c_func
(paren
id|priv-&gt;rxBuffer
op_plus
(paren
id|i
op_star
id|TLAN_MAX_FRAME_SIZE
)paren
)paren
suffix:semicolon
id|list-&gt;buffer
(braket
l_int|1
)braket
dot
id|count
op_assign
l_int|0
suffix:semicolon
id|list-&gt;buffer
(braket
l_int|1
)braket
dot
id|address
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|TLAN_NUM_RX_LISTS
op_minus
l_int|1
)paren
id|list-&gt;forward
op_assign
id|virt_to_bus
c_func
(paren
id|list
op_plus
l_int|1
)paren
suffix:semicolon
r_else
id|list-&gt;forward
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* TLan_ResetLists */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_PrintDio&n;&t; *  &n;&t; *  Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;io_base&t;&t;Base IO port of the device of which to print&n;&t; *&t;&t;&t;&t;&t;&t;&t;DIO registers.&n;&t; *&n;&t; *&t;This function prints out all the the internal (DIO) registers of a&n;&t; *&t;TLAN chip.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_PrintDio
r_void
id|TLan_PrintDio
c_func
(paren
id|u16
id|io_base
)paren
(brace
id|u32
id|data0
comma
id|data1
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TLAN:   Contents of internal registers for io base 0x%04hx.&bslash;n&quot;
comma
id|io_base
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TLAN:      Off.  +0         +4&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x4C
suffix:semicolon
id|i
op_add_assign
l_int|8
)paren
(brace
id|data0
op_assign
id|TLan_DioRead32
c_func
(paren
id|io_base
comma
id|i
)paren
suffix:semicolon
id|data1
op_assign
id|TLan_DioRead32
c_func
(paren
id|io_base
comma
id|i
op_plus
l_int|0x4
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TLAN:      0x%02x  0x%08x 0x%08x&bslash;n&quot;
comma
id|i
comma
id|data0
comma
id|data1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* TLan_PrintDio */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_PrintList&n;&t; *  &n;&t; *  Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;list&t;A pointer to the TLanList structure to be printed.&n;&t; *&t;&t;&t;&t;type&t;A string to designate type of list, &quot;Rx&quot; or &quot;Tx&quot;.&n;&t; *&t;&t;&t;&t;num&t;&t;The index of the list.&n;&t; *&n;&t; *&t;This function prints out the contents of the list pointed to by the&n;&t; *&t;list parameter.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_PrintList
r_void
id|TLan_PrintList
c_func
(paren
id|TLanList
op_star
id|list
comma
r_char
op_star
id|type
comma
r_int
id|num
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TLAN:   %s List %d at 0x%08x&bslash;n&quot;
comma
id|type
comma
id|num
comma
(paren
id|u32
)paren
id|list
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TLAN:      Forward    = 0x%08x&bslash;n&quot;
comma
id|list-&gt;forward
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TLAN:      CSTAT      = 0x%04hx&bslash;n&quot;
comma
id|list-&gt;cStat
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TLAN:      Frame Size = 0x%04hx&bslash;n&quot;
comma
id|list-&gt;frameSize
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TLAN:      Buffer[%d].count, addr = 0x%08x, 0x%08x&bslash;n&quot;
comma
id|i
comma
id|list-&gt;buffer
(braket
id|i
)braket
dot
id|count
comma
id|list-&gt;buffer
(braket
id|i
)braket
dot
id|address
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* TLan_PrintList */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_ReadAndClearStats&n;&t; *&n;&t; *&t;Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;dev&t;&t;Pointer to device structure of adapter to which&n;&t; *&t;&t;&t;&t;&t;&t;to read stats.&n;&t; *&t;&t;&t;&t;record&t;Flag indicating whether to add &n;&t; *&n;&t; *&t;This functions reads all the internal status registers of the TLAN&n;&t; *&t;chip, which clears them as a side effect.  It then either adds the&n;&t; *&t;values to the device&squot;s status struct, or discards them, depending&n;&t; *&t;on whether record is TLAN_RECORD (!=0)  or TLAN_IGNORE (==0).&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_ReadAndClearStats
r_void
id|TLan_ReadAndClearStats
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|record
)paren
(brace
id|TLanPrivateInfo
op_star
id|priv
op_assign
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u32
id|tx_good
comma
id|tx_under
suffix:semicolon
id|u32
id|rx_good
comma
id|rx_over
suffix:semicolon
id|u32
id|def_tx
comma
id|crc
comma
id|code
suffix:semicolon
id|u32
id|multi_col
comma
id|single_col
suffix:semicolon
id|u32
id|excess_col
comma
id|late_col
comma
id|loss
suffix:semicolon
id|outw
c_func
(paren
id|TLAN_GOOD_TX_FRMS
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_ADR
)paren
suffix:semicolon
id|tx_good
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
)paren
suffix:semicolon
id|tx_good
op_add_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
op_plus
l_int|1
)paren
op_lshift
l_int|8
suffix:semicolon
id|tx_good
op_add_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
op_plus
l_int|2
)paren
op_lshift
l_int|16
suffix:semicolon
id|tx_under
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
op_plus
l_int|3
)paren
suffix:semicolon
id|outw
c_func
(paren
id|TLAN_GOOD_RX_FRMS
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_ADR
)paren
suffix:semicolon
id|rx_good
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
)paren
suffix:semicolon
id|rx_good
op_add_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
op_plus
l_int|1
)paren
op_lshift
l_int|8
suffix:semicolon
id|rx_good
op_add_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
op_plus
l_int|2
)paren
op_lshift
l_int|16
suffix:semicolon
id|rx_over
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
op_plus
l_int|3
)paren
suffix:semicolon
id|outw
c_func
(paren
id|TLAN_DEFERRED_TX
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_ADR
)paren
suffix:semicolon
id|def_tx
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
)paren
suffix:semicolon
id|def_tx
op_add_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
op_plus
l_int|1
)paren
op_lshift
l_int|8
suffix:semicolon
id|crc
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
op_plus
l_int|2
)paren
suffix:semicolon
id|code
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
op_plus
l_int|3
)paren
suffix:semicolon
id|outw
c_func
(paren
id|TLAN_MULTICOL_FRMS
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_ADR
)paren
suffix:semicolon
id|multi_col
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
)paren
suffix:semicolon
id|multi_col
op_add_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
op_plus
l_int|1
)paren
op_lshift
l_int|8
suffix:semicolon
id|single_col
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
op_plus
l_int|2
)paren
suffix:semicolon
id|single_col
op_add_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
op_plus
l_int|3
)paren
op_lshift
l_int|8
suffix:semicolon
id|outw
c_func
(paren
id|TLAN_EXCESSCOL_FRMS
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_ADR
)paren
suffix:semicolon
id|excess_col
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
)paren
suffix:semicolon
id|late_col
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
op_plus
l_int|1
)paren
suffix:semicolon
id|loss
op_assign
id|inb
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|record
)paren
(brace
id|priv-&gt;stats.rx_packets
op_add_assign
id|rx_good
suffix:semicolon
id|priv-&gt;stats.rx_errors
op_add_assign
id|rx_over
op_plus
id|crc
op_plus
id|code
suffix:semicolon
id|priv-&gt;stats.tx_packets
op_add_assign
id|tx_good
suffix:semicolon
id|priv-&gt;stats.tx_errors
op_add_assign
id|tx_under
op_plus
id|loss
suffix:semicolon
id|priv-&gt;stats.collisions
op_add_assign
id|multi_col
op_plus
id|single_col
op_plus
id|excess_col
op_plus
id|late_col
suffix:semicolon
id|priv-&gt;stats.rx_over_errors
op_add_assign
id|rx_over
suffix:semicolon
id|priv-&gt;stats.rx_crc_errors
op_add_assign
id|crc
suffix:semicolon
id|priv-&gt;stats.rx_frame_errors
op_add_assign
id|code
suffix:semicolon
id|priv-&gt;stats.tx_aborted_errors
op_add_assign
id|tx_under
suffix:semicolon
id|priv-&gt;stats.tx_carrier_errors
op_add_assign
id|loss
suffix:semicolon
)brace
)brace
multiline_comment|/* TLan_ReadAndClearStats */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_Reset&n;&t; *&n;&t; *&t;Returns:&t;0&n;&t; *&t;Parms:&t;&t;dev&t;&t;Pointer to device structure of adapter to be&n;&t; *&t;&t;&t;&t;&t;&t;reset.&n;&t; *&n;&t; *&t;This function resets the adapter and it&squot;s physical device.  See&n;&t; *&t;Chap. 3, pp. 9-10 of the &quot;ThunderLAN Programmer&squot;s Guide&quot; for details.&n;&t; *&t;The routine tries to implement what is detailed there, though&n;&t; *&t;adjustments have been made.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_Reset
r_int
id|TLan_Reset
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|TLanPrivateInfo
op_star
id|priv
op_assign
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u32
id|data
suffix:semicolon
id|u8
id|data8
suffix:semicolon
singleline_comment|//&t;1.  Assume Stat registers have been dealt with.
singleline_comment|//&t;2.  Assert reset bit.
id|data
op_assign
id|inl
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_HOST_CMD
)paren
suffix:semicolon
id|data
op_or_assign
id|TLAN_HC_AD_RST
suffix:semicolon
id|outl
c_func
(paren
id|data
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_HOST_CMD
)paren
suffix:semicolon
singleline_comment|//&t;3.  Turn off interrupts.
id|data
op_assign
id|inl
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_HOST_CMD
)paren
suffix:semicolon
id|data
op_or_assign
id|TLAN_HC_INT_OFF
suffix:semicolon
id|outl
c_func
(paren
id|data
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_HOST_CMD
)paren
suffix:semicolon
singleline_comment|//&t;4.&t;Setup AREGs and HASHs.
r_for
c_loop
(paren
id|i
op_assign
id|TLAN_AREG_0
suffix:semicolon
id|i
op_le
id|TLAN_HASH_2
suffix:semicolon
id|i
op_add_assign
l_int|4
)paren
id|TLan_DioWrite32
c_func
(paren
id|dev-&gt;base_addr
comma
(paren
id|u16
)paren
id|i
comma
l_int|0
)paren
suffix:semicolon
singleline_comment|//&t;5.&t;Setup NetConfig register.
id|outw
c_func
(paren
id|TLAN_NET_CONFIG
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_ADR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|TLAN_NET_CFG_1FRAG
op_or
id|TLAN_NET_CFG_1CHAN
op_or
id|TLAN_NET_CFG_PHY_EN
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
)paren
suffix:semicolon
singleline_comment|//&t;6.&t;Setup BSIZE register.
singleline_comment|//&t;&t;Accept defaults, 0x22, for now.
singleline_comment|//&t;7.&t;Setup TX commit in Acommit.
singleline_comment|//&t;&t;Allow it to manage itself.
singleline_comment|//&t;8.&t;Load Ld_Tmr in HOST_CMD.
singleline_comment|//&t;&t;I don&squot;t know what this value should be.  I&squot;ll try 3.
id|outl
c_func
(paren
id|TLAN_HC_LD_TMR
op_or
l_int|0x0
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_HOST_CMD
)paren
suffix:semicolon
singleline_comment|//&t;9.&t;Load Ld_Thr in HOST_CMD.
singleline_comment|//&t;&t;Try 1 for now.
id|outl
c_func
(paren
id|TLAN_HC_LD_THR
op_or
l_int|0x1
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_HOST_CMD
)paren
suffix:semicolon
singleline_comment|//&t;10. Unreset the MII by setting NMRST (in NetSio) to 1.
id|outw
c_func
(paren
id|TLAN_NET_SIO
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_ADR
)paren
suffix:semicolon
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_NMRST
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_DIO_DATA
op_plus
id|TLAN_NET_SIO
)paren
suffix:semicolon
singleline_comment|//&t;10a. Other.
singleline_comment|//&t;12. Setup the NetMask register.
id|TLan_DioWrite8
c_func
(paren
id|dev-&gt;base_addr
comma
id|TLAN_INT_DIS
comma
id|TLAN_ID_TX_EOC
op_or
id|TLAN_ID_RX_EOC
)paren
suffix:semicolon
singleline_comment|//TLan_DioWrite8( dev-&gt;base_addr, TLAN_NET_CMD, TLAN_NET_CMD_NRESET | TLAN_NET_CMD_NWRAP | TLAN_NET_CMD_DUPLEX | TLAN_NET_CMD_CAF );
id|TLan_DioWrite8
c_func
(paren
id|dev-&gt;base_addr
comma
id|TLAN_NET_CMD
comma
id|TLAN_NET_CMD_NRESET
op_or
id|TLAN_NET_CMD_NWRAP
)paren
suffix:semicolon
singleline_comment|//&t;11. Initialize PHYs.
id|TLan_PhySelect
c_func
(paren
id|dev
)paren
suffix:semicolon
(paren
op_star
id|priv-&gt;phyCheck
)paren
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
id|TLan_PhyPrint
c_func
(paren
id|dev
)paren
suffix:semicolon
singleline_comment|//data8 = TLAN_NET_MASK_MASK4 | TLAN_NET_MASK_MASK5 | TLAN_NET_MASK_MASK6 | TLAN_NET_MASK_MASK7; 
id|data8
op_assign
id|TLAN_NET_MASK_MASK4
op_or
id|TLAN_NET_MASK_MASK5
op_or
id|TLAN_NET_MASK_MASK7
suffix:semicolon
id|TLan_DioWrite8
c_func
(paren
id|dev-&gt;base_addr
comma
id|TLAN_NET_MASK
comma
id|data8
)paren
suffix:semicolon
id|TLan_DioWrite16
c_func
(paren
id|dev-&gt;base_addr
comma
id|TLAN_MAX_RX
comma
l_int|1550
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;  *&t;13. Turn on interrupts to host.&n;&t;&t;  *&t;&t;I don&squot;t want any interrupts, yet.&n;&t;&t;  */
multiline_comment|/*&n;&t;&t;&t;data = inl(base_port + TLAN_HOST_CMD);&n;&t;&t;&t;data |= TLAN_HC_INT_ON;&n;&t;&t;&t;outl(data, base_port + TLAN_HOST_CMD);&n;&t;&t;&t;*/
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* TLan_Reset */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_SetMac&n;&t; *&n;&t; *&t;Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;dev&t;&t;Pointer to device structure of adapter on which to&n;&t; *&t;&t;&t;&t;&t;&t;change the AREG.&n;&t; *&t;&t;&t;&t;areg&t;The AREG to set the address in (0 - 3).&n;&t; *&t;&t;&t;&t;mac&t;&t;A pointer to an array of chars.  Each element&n;&t; *&t;&t;&t;&t;&t;&t;stores one byte of the address.  IE, it isn&squot;t&n;&t; *&t;&t;&t;&t;&t;&t;in ascii.&n;&t; *&n;&t; *&t;This function transfers a MAC address to one of the TLAN AREGs&n;&t; *&t;(address registers).  The TLAN chip locks the register on writing to&n;&t; *&t;offset 0 and unlocks the register after writing to offset 5.  If NULL&n;&t; *&t;is passed in mac, then the AREG is filled with 0&squot;s.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_SetMac
r_void
id|TLan_SetMac
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|areg
comma
r_char
op_star
id|mac
)paren
(brace
r_int
id|i
suffix:semicolon
id|areg
op_mul_assign
l_int|6
suffix:semicolon
r_if
c_cond
(paren
id|mac
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|TLan_DioWrite8
c_func
(paren
id|dev-&gt;base_addr
comma
id|TLAN_AREG_0
op_plus
id|areg
op_plus
id|i
comma
id|mac
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|TLan_DioWrite8
c_func
(paren
id|dev-&gt;base_addr
comma
id|TLAN_AREG_0
op_plus
id|areg
op_plus
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* TLan_SetMac */
multiline_comment|/*****************************************************************************&n;******************************************************************************&n;&n;&t;ThunderLAN Driver Eeprom routines&n;&n;&t;The Compaq Netelligent 10 and 10/100 cards use a Microchip 24C02A EEPROM.&n;&t;These functions are based on information in Microchip&squot;s data sheet.  I&n;&t;don&squot;t know how well this functions will work with other EEPROMs.&n;&n;******************************************************************************&n;*****************************************************************************/
r_static
r_void
id|TLan_EeSendStart
c_func
(paren
id|u16
)paren
suffix:semicolon
r_static
r_int
id|TLan_EeSendByte
c_func
(paren
id|u16
comma
id|u8
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|TLan_EeReceiveByte
c_func
(paren
id|u16
comma
id|u8
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|TLan_EeReadByte
c_func
(paren
id|u16
comma
id|u8
comma
id|u8
op_star
)paren
suffix:semicolon
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_EeSendStart&n;&t; *&n;&t; *&t;Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;io_base&t;&t;The IO port base address for the TLAN device&n;&t; *&t;&t;&t;&t;&t;&t;&t;with the EEPROM to use.&n;&t; *&n;&t; *&t;This function sends a start cycle to an EEPROM attached to a TLAN&n;&t; *&t;chip.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_EeSendStart
r_void
id|TLan_EeSendStart
c_func
(paren
id|u16
id|io_base
)paren
(brace
id|u16
id|sio
suffix:semicolon
id|outw
c_func
(paren
id|TLAN_NET_SIO
comma
id|io_base
op_plus
id|TLAN_DIO_ADR
)paren
suffix:semicolon
id|sio
op_assign
id|io_base
op_plus
id|TLAN_DIO_DATA
op_plus
id|TLAN_NET_SIO
suffix:semicolon
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_ECLOK
comma
id|sio
)paren
suffix:semicolon
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_EDATA
comma
id|sio
)paren
suffix:semicolon
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_ETXEN
comma
id|sio
)paren
suffix:semicolon
singleline_comment|//
singleline_comment|// FIXME: Do I really need these SLOW_DOWN_IOs?
singleline_comment|//
id|SLOW_DOWN_IO
suffix:semicolon
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_EDATA
comma
id|sio
)paren
suffix:semicolon
id|SLOW_DOWN_IO
suffix:semicolon
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_ECLOK
comma
id|sio
)paren
suffix:semicolon
id|SLOW_DOWN_IO
suffix:semicolon
)brace
multiline_comment|/* TLan_EeSendStart */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_EeSendByte&n;&t; *&n;&t; *&t;Returns:&t;If the correct ack was received, 0, otherwise 1&n;&t; *&t;Parms:&t;&t;io_base&t;&t;The IO port base address for the TLAN device&n;&t; *&t;&t;&t;&t;&t;&t;&t;with the EEPROM to use.&n;&t; *&t;&t;&t;&t;data&t;&t;The 8 bits of information to send to the&n;&t; *&t;&t;&t;&t;&t;&t;&t;EEPROM.&n;&t; *&t;&t;&t;&t;stop&t;&t;If TLAN_EEPROM_STOP is passed, a stop cycle is&n;&t; *&t;&t;&t;&t;&t;&t;&t;sent after the byte is sent after the ack is&n;&t; *&t;&t;&t;&t;&t;&t;&t;read.&n;&t; *&n;&t; *&t;This function sends a byte on the serial EEPROM line, driving the&n;&t; *&t;clock to send each bit. The function then reverses transmission&n;&t; *&t;direction and reads an acknowledge bit.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_EeSendByte
r_int
id|TLan_EeSendByte
c_func
(paren
id|u16
id|io_base
comma
id|u8
id|data
comma
r_int
id|stop
)paren
(brace
r_int
id|err
suffix:semicolon
id|u8
id|place
suffix:semicolon
id|u16
id|sio
suffix:semicolon
id|outw
c_func
(paren
id|TLAN_NET_SIO
comma
id|io_base
op_plus
id|TLAN_DIO_ADR
)paren
suffix:semicolon
id|sio
op_assign
id|io_base
op_plus
id|TLAN_DIO_DATA
op_plus
id|TLAN_NET_SIO
suffix:semicolon
singleline_comment|// Assume clock is low, tx is enabled;
r_for
c_loop
(paren
id|place
op_assign
l_int|0x80
suffix:semicolon
id|place
suffix:semicolon
id|place
op_rshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|place
op_amp
id|data
)paren
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_EDATA
comma
id|sio
)paren
suffix:semicolon
r_else
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_EDATA
comma
id|sio
)paren
suffix:semicolon
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_ECLOK
comma
id|sio
)paren
suffix:semicolon
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_ECLOK
comma
id|sio
)paren
suffix:semicolon
)brace
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_ETXEN
comma
id|sio
)paren
suffix:semicolon
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_ECLOK
comma
id|sio
)paren
suffix:semicolon
id|err
op_assign
id|TLan_GetBit
c_func
(paren
id|TLAN_NET_SIO_EDATA
comma
id|sio
)paren
suffix:semicolon
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_ECLOK
comma
id|sio
)paren
suffix:semicolon
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_ETXEN
comma
id|sio
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|err
)paren
op_logical_and
id|stop
)paren
(brace
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_EDATA
comma
id|sio
)paren
suffix:semicolon
singleline_comment|// STOP, raise data while clock is high
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_ECLOK
comma
id|sio
)paren
suffix:semicolon
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_EDATA
comma
id|sio
)paren
suffix:semicolon
)brace
r_return
(paren
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/* TLan_EeSendByte */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_EeReceiveByte&n;&t; *&n;&t; *&t;Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;io_base&t;&t;The IO port base address for the TLAN device&n;&t; *&t;&t;&t;&t;&t;&t;&t;with the EEPROM to use.&n;&t; *&t;&t;&t;&t;data&t;&t;An address to a char to hold the data sent&n;&t; *&t;&t;&t;&t;&t;&t;&t;from the EEPROM.&n;&t; *&t;&t;&t;&t;stop&t;&t;If TLAN_EEPROM_STOP is passed, a stop cycle is&n;&t; *&t;&t;&t;&t;&t;&t;&t;sent after the byte is received, and no ack is&n;&t; *&t;&t;&t;&t;&t;&t;&t;sent.&n;&t; *&n;&t; *&t;This function receives 8 bits of data from the EEPROM over the serial&n;&t; *&t;link.  It then sends and ack bit, or no ack and a stop bit.  This&n;&t; *&t;function is used to retrieve data after the address of a byte in the&n;&t; *&t;EEPROM has been sent.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_EeReceiveByte
r_void
id|TLan_EeReceiveByte
c_func
(paren
id|u16
id|io_base
comma
id|u8
op_star
id|data
comma
r_int
id|stop
)paren
(brace
id|u8
id|place
suffix:semicolon
id|u16
id|sio
suffix:semicolon
id|outw
c_func
(paren
id|TLAN_NET_SIO
comma
id|io_base
op_plus
id|TLAN_DIO_ADR
)paren
suffix:semicolon
id|sio
op_assign
id|io_base
op_plus
id|TLAN_DIO_DATA
op_plus
id|TLAN_NET_SIO
suffix:semicolon
op_star
id|data
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Assume clock is low, tx is enabled;
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_ETXEN
comma
id|sio
)paren
suffix:semicolon
r_for
c_loop
(paren
id|place
op_assign
l_int|0x80
suffix:semicolon
id|place
suffix:semicolon
id|place
op_rshift_assign
l_int|1
)paren
(brace
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_ECLOK
comma
id|sio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TLan_GetBit
c_func
(paren
id|TLAN_NET_SIO_EDATA
comma
id|sio
)paren
)paren
op_star
id|data
op_or_assign
id|place
suffix:semicolon
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_ECLOK
comma
id|sio
)paren
suffix:semicolon
)brace
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_ETXEN
comma
id|sio
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stop
)paren
(brace
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_EDATA
comma
id|sio
)paren
suffix:semicolon
singleline_comment|// Ack = 0
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_ECLOK
comma
id|sio
)paren
suffix:semicolon
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_ECLOK
comma
id|sio
)paren
suffix:semicolon
)brace
r_else
(brace
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_EDATA
comma
id|sio
)paren
suffix:semicolon
singleline_comment|// No ack = 1 (?)
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_ECLOK
comma
id|sio
)paren
suffix:semicolon
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_ECLOK
comma
id|sio
)paren
suffix:semicolon
id|TLan_ClearBit
c_func
(paren
id|TLAN_NET_SIO_EDATA
comma
id|sio
)paren
suffix:semicolon
singleline_comment|// STOP, raise data while clock is high
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_ECLOK
comma
id|sio
)paren
suffix:semicolon
id|TLan_SetBit
c_func
(paren
id|TLAN_NET_SIO_EDATA
comma
id|sio
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* TLan_EeReceiveByte */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_EeReadByte&n;&t; *&n;&t; *&t;Returns:&t;No error = 0, else, the stage at which the error occured.&n;&t; *&t;Parms:&t;&t;io_base&t;&t;The IO port base address for the TLAN device&n;&t; *&t;&t;&t;&t;&t;&t;&t;with the EEPROM to use.&n;&t; *&t;&t;&t;&t;ee_addr&t;&t;The address of the byte in the EEPROM whose&n;&t; *&t;&t;&t;&t;&t;&t;&t;contents are to be retrieved.&n;&t; *&t;&t;&t;&t;data&t;&t;An address to a char to hold the data obtained&n;&t; *&t;&t;&t;&t;&t;&t;&t;from the EEPROM.&n;&t; *&n;&t; *&t;This function reads a byte of information from an byte cell in the&n;&t; *&t;EEPROM.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_EeReadByte
r_int
id|TLan_EeReadByte
c_func
(paren
id|u16
id|io_base
comma
id|u8
id|ee_addr
comma
id|u8
op_star
id|data
)paren
(brace
r_int
id|err
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|TLan_EeSendStart
c_func
(paren
id|io_base
)paren
suffix:semicolon
id|err
op_assign
id|TLan_EeSendByte
c_func
(paren
id|io_base
comma
l_int|0xA0
comma
id|TLAN_EEPROM_ACK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
l_int|1
suffix:semicolon
id|err
op_assign
id|TLan_EeSendByte
c_func
(paren
id|io_base
comma
id|ee_addr
comma
id|TLAN_EEPROM_ACK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
l_int|2
suffix:semicolon
id|TLan_EeSendStart
c_func
(paren
id|io_base
)paren
suffix:semicolon
id|err
op_assign
id|TLan_EeSendByte
c_func
(paren
id|io_base
comma
l_int|0xA1
comma
id|TLAN_EEPROM_ACK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
l_int|3
suffix:semicolon
id|TLan_EeReceiveByte
c_func
(paren
id|io_base
comma
id|data
comma
id|TLAN_EEPROM_STOP
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* TLan_EeReadByte */
multiline_comment|/*****************************************************************************&n;******************************************************************************&n;&n;        ThunderLAN Driver Interrupt Vectors and Table&n;&n;&t;&t;Please see Chap. 4, &quot;Interrupt Handling&quot; of the&n;&t;&t;&quot;ThunderLAN Programmer&squot;s Guide&quot; for more informations on handling&n;&t;&t;interrupts generated by TLAN based adapters.  &n;&n;******************************************************************************&n;*****************************************************************************/
r_static
id|u32
id|TLan_HandleInvalid
c_func
(paren
r_struct
id|device
op_star
comma
id|u16
)paren
suffix:semicolon
r_static
id|u32
id|TLan_HandleTxEOF
c_func
(paren
r_struct
id|device
op_star
comma
id|u16
)paren
suffix:semicolon
r_static
id|u32
id|TLan_HandleStatOverflow
c_func
(paren
r_struct
id|device
op_star
comma
id|u16
)paren
suffix:semicolon
r_static
id|u32
id|TLan_HandleRxEOF
c_func
(paren
r_struct
id|device
op_star
comma
id|u16
)paren
suffix:semicolon
r_static
id|u32
id|TLan_HandleDummy
c_func
(paren
r_struct
id|device
op_star
comma
id|u16
)paren
suffix:semicolon
r_static
id|u32
id|TLan_HandleTxEOC
c_func
(paren
r_struct
id|device
op_star
comma
id|u16
)paren
suffix:semicolon
r_static
id|u32
id|TLan_HandleStatusCheck
c_func
(paren
r_struct
id|device
op_star
comma
id|u16
)paren
suffix:semicolon
r_static
id|u32
id|TLan_HandleRxEOC
c_func
(paren
r_struct
id|device
op_star
comma
id|u16
)paren
suffix:semicolon
DECL|typedef|TLanIntVectorFunc
r_typedef
id|u32
(paren
id|TLanIntVectorFunc
)paren
(paren
r_struct
id|device
op_star
comma
id|u16
)paren
suffix:semicolon
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_HandleInvalid&n;&t; *&n;&t; *&t;Returns:&t;0&n;&t; *&t;Parms:&t;&t;dev&t;&t;&t;Device assigned the IRQ that was raised.&n;&t; *&t;&t;&t;&t;host_int&t;The contents of the HOST_INT port.&n;&t; *&n;&t; *&t;This function handles invalid interrupts.  This should never happen&n;&t; *&t;unless some other adapter is trying to use the IRQ line assigned to&n;&t; *&t;the device.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_HandleInvalid
id|u32
id|TLan_HandleInvalid
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u16
id|host_int
)paren
(brace
id|host_int
op_assign
l_int|0
suffix:semicolon
singleline_comment|// printk( &quot;TLAN:  Invalid interrupt on %s.&bslash;n&quot;, dev-&gt;name );
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* TLan_HandleInvalid */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_HandleTxEOF&n;&t; *&n;&t; *&t;Returns:&t;1&n;&t; *&t;Parms:&t;&t;dev&t;&t;&t;Device assigned the IRQ that was raised.&n;&t; *&t;&t;&t;&t;host_int&t;The contents of the HOST_INT port.&n;&t; *&n;&t; *&t;This function handles Tx EOF interrupts which are raised by the&n;&t; *&t;adapter when it has completed sending the contents of a buffer.  If&n;&t; *&t;detemines which list/buffer was completed and resets it.  If the&n;&t; *&t;buffer was the last in the channel (EOC), then the function checks&n;&t; *&t;to see if another buffer is ready to send, and if so, sends a Tx Go&n;&t; *&t;command.  Finally, the driver activates/continues the activity LED.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_HandleTxEOF
id|u32
id|TLan_HandleTxEOF
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u16
id|host_int
)paren
(brace
id|TLanPrivateInfo
op_star
id|priv
op_assign
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|eoc
op_assign
l_int|0
suffix:semicolon
id|TLanList
op_star
id|head_list
suffix:semicolon
id|u32
id|ack
op_assign
l_int|1
suffix:semicolon
singleline_comment|// printk( &quot;TLAN:  Handling Tx EOF&bslash;n&quot; );
id|host_int
op_assign
l_int|0
suffix:semicolon
id|head_list
op_assign
id|priv-&gt;txList
op_plus
id|priv-&gt;txHead
suffix:semicolon
r_if
c_cond
(paren
id|head_list-&gt;cStat
op_amp
id|TLAN_CSTAT_EOC
)paren
id|eoc
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|head_list-&gt;cStat
op_amp
id|TLAN_CSTAT_FRM_CMP
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TLAN:  Received interrupt for uncompleted TX frame.&bslash;n&quot;
)paren
suffix:semicolon
)brace
singleline_comment|// printk( &quot;Ack %d CSTAT=%hx&bslash;n&quot;, priv-&gt;txHead, head_list-&gt;cStat );
id|head_list-&gt;cStat
op_assign
id|TLAN_CSTAT_UNUSED
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;txHead
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;txHead
op_ge
id|TLAN_NUM_TX_LISTS
)paren
id|priv-&gt;txHead
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|eoc
)paren
(brace
singleline_comment|// printk( &quot;TLAN:  Handling Tx EOC&bslash;n&quot; );
id|head_list
op_assign
id|priv-&gt;txList
op_plus
id|priv-&gt;txHead
suffix:semicolon
r_if
c_cond
(paren
(paren
id|head_list-&gt;cStat
op_amp
id|TLAN_CSTAT_READY
)paren
op_eq
id|TLAN_CSTAT_READY
)paren
(brace
id|outl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|head_list
)paren
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_CH_PARM
)paren
suffix:semicolon
id|ack
op_or_assign
id|TLAN_HC_GO
suffix:semicolon
)brace
r_else
(brace
id|priv-&gt;txInProgress
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|TLan_DioWrite8
c_func
(paren
id|dev-&gt;base_addr
comma
id|TLAN_LED_REG
comma
id|TLAN_LED_LINK
op_or
id|TLAN_LED_ACT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;phyFlags
op_amp
id|TLAN_PHY_ACTIVITY
)paren
(brace
r_if
c_cond
(paren
id|priv-&gt;timerSetAt
op_eq
l_int|0
)paren
(brace
singleline_comment|// printk(&quot;TxEOF Starting timer...&bslash;n&quot;);
id|priv-&gt;timerSetAt
op_assign
id|jiffies
suffix:semicolon
id|priv-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|TLAN_TIMER_ACT_DELAY
suffix:semicolon
id|priv-&gt;timerType
op_assign
id|TLAN_TIMER_ACT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|priv-&gt;timer
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|priv-&gt;timerType
op_eq
id|TLAN_TIMER_ACT
)paren
(brace
id|priv-&gt;timerSetAt
op_assign
id|jiffies
suffix:semicolon
singleline_comment|// printk(&quot;TxEOF continuing timer...&bslash;n&quot;);
)brace
)brace
r_return
id|ack
suffix:semicolon
)brace
multiline_comment|/* TLan_HandleTxEOF */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_HandleStatOverflow&n;&t; *&n;&t; *&t;Returns:&t;1&n;&t; *&t;Parms:&t;&t;dev&t;&t;&t;Device assigned the IRQ that was raised.&n;&t; *&t;&t;&t;&t;host_int&t;The contents of the HOST_INT port.&n;&t; *&n;&t; *&t;This function handles the Statistics Overflow interrupt which means&n;&t; *&t;that one or more of the TLAN statistics registers has reached 1/2&n;&t; *&t;capacity and needs to be read.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_HandleStatOverflow
id|u32
id|TLan_HandleStatOverflow
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u16
id|host_int
)paren
(brace
id|host_int
op_assign
l_int|0
suffix:semicolon
id|TLan_ReadAndClearStats
c_func
(paren
id|dev
comma
id|TLAN_RECORD
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* TLan_HandleStatOverflow */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_HandleRxEOF&n;&t; *&n;&t; *&t;Returns:&t;1&n;&t; *&t;Parms:&t;&t;dev&t;&t;&t;Device assigned the IRQ that was raised.&n;&t; *&t;&t;&t;&t;host_int&t;The contents of the HOST_INT port.&n;&t; *&n;&t; *&t;This function handles the Rx EOF interrupt which indicates a frame&n;&t; *&t;has been received by the adapter from the net and the frame has been&n;&t; *&t;transferred to memory.  The function determines the bounce buffer&n;&t; *&t;the frame has been loaded into, creates a new sk_buff big enough to&n;&t; *&t;hold the frame, and sends it to protocol stack.  It then resets the&n;&t; *&t;used buffer and appends it to the end of the list.  If the frame was&n;&t; *&t;the last in the Rx channel (EOC), the function restarts the receive&n;&t; *&t;channel by sending an Rx Go command to the adapter.  Then it activates/&n;&t; *&t;continues the the activity LED.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_HandleRxEOF
id|u32
id|TLan_HandleRxEOF
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u16
id|host_int
)paren
(brace
id|u32
id|ack
op_assign
l_int|1
suffix:semicolon
r_int
id|eoc
op_assign
l_int|0
suffix:semicolon
id|u8
op_star
id|head_buffer
suffix:semicolon
id|TLanList
op_star
id|head_list
suffix:semicolon
id|TLanPrivateInfo
op_star
id|priv
op_assign
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|TLanList
op_star
id|tail_list
suffix:semicolon
r_void
op_star
id|t
suffix:semicolon
singleline_comment|// printk( &quot;TLAN:  Handling Rx EOF Head=%d Tail=%d&bslash;n&quot;, priv-&gt;rxHead, priv-&gt;rxTail );
id|host_int
op_assign
l_int|0
suffix:semicolon
id|head_list
op_assign
id|priv-&gt;rxList
op_plus
id|priv-&gt;rxHead
suffix:semicolon
id|tail_list
op_assign
id|priv-&gt;rxList
op_plus
id|priv-&gt;rxTail
suffix:semicolon
r_if
c_cond
(paren
id|head_list-&gt;cStat
op_amp
id|TLAN_CSTAT_EOC
)paren
id|eoc
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|head_list-&gt;cStat
op_amp
id|TLAN_CSTAT_FRM_CMP
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TLAN:  Received interrupt for uncompleted RX frame.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|head_list-&gt;frameSize
op_plus
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TLAN:  Couldn&squot;t allocate memory for received data.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|head_buffer
op_assign
id|priv-&gt;rxBuffer
op_plus
(paren
id|priv-&gt;rxHead
op_star
id|TLAN_MAX_FRAME_SIZE
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
id|t
op_assign
(paren
r_void
op_star
)paren
id|skb_put
c_func
(paren
id|skb
comma
id|head_list-&gt;frameSize
)paren
suffix:semicolon
singleline_comment|// printk( &quot; %hd %p %p&bslash;n&quot;, head_list-&gt;frameSize, skb-&gt;data, t );
id|memcpy
c_func
(paren
id|t
comma
id|head_buffer
comma
id|head_list-&gt;frameSize
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
)brace
id|head_list-&gt;forward
op_assign
l_int|0
suffix:semicolon
id|head_list-&gt;frameSize
op_assign
id|TLAN_MAX_FRAME_SIZE
suffix:semicolon
id|head_list-&gt;buffer
(braket
l_int|0
)braket
dot
id|count
op_assign
id|TLAN_MAX_FRAME_SIZE
op_or
id|TLAN_LAST_BUFFER
suffix:semicolon
id|tail_list-&gt;forward
op_assign
id|virt_to_bus
c_func
(paren
id|head_list
)paren
suffix:semicolon
id|priv-&gt;rxHead
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;rxHead
op_ge
id|TLAN_NUM_RX_LISTS
)paren
id|priv-&gt;rxHead
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;rxTail
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;rxTail
op_ge
id|TLAN_NUM_RX_LISTS
)paren
id|priv-&gt;rxTail
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|eoc
)paren
(brace
singleline_comment|// printk( &quot;TLAN:  Handling Rx EOC Head=%d Tail=%d&bslash;n&quot;, priv-&gt;rxHead, priv-&gt;rxTail );
id|head_list
op_assign
id|priv-&gt;rxList
op_plus
id|priv-&gt;rxHead
suffix:semicolon
id|outl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|head_list
)paren
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_CH_PARM
)paren
suffix:semicolon
id|ack
op_or_assign
id|TLAN_HC_GO
op_or
id|TLAN_HC_RT
suffix:semicolon
id|priv-&gt;rxEocCount
op_increment
suffix:semicolon
)brace
id|TLan_DioWrite8
c_func
(paren
id|dev-&gt;base_addr
comma
id|TLAN_LED_REG
comma
id|TLAN_LED_LINK
op_or
id|TLAN_LED_ACT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;phyFlags
op_amp
id|TLAN_PHY_ACTIVITY
)paren
(brace
r_if
c_cond
(paren
id|priv-&gt;timerSetAt
op_eq
l_int|0
)paren
(brace
singleline_comment|// printk(&quot;RxEOF Starting timer...&bslash;n&quot;);
id|priv-&gt;timerSetAt
op_assign
id|jiffies
suffix:semicolon
id|priv-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|TLAN_TIMER_ACT_DELAY
suffix:semicolon
id|priv-&gt;timerType
op_assign
id|TLAN_TIMER_ACT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|priv-&gt;timer
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|priv-&gt;timerType
op_eq
id|TLAN_TIMER_ACT
)paren
(brace
singleline_comment|// printk(&quot;RxEOF tarting continuing timer...&bslash;n&quot;);
id|priv-&gt;timerSetAt
op_assign
id|jiffies
suffix:semicolon
)brace
)brace
id|dev-&gt;last_rx
op_assign
id|jiffies
suffix:semicolon
r_return
id|ack
suffix:semicolon
)brace
multiline_comment|/* TLan_HandleRxEOF */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_HandleDummy&n;&t; *&n;&t; *&t;Returns:&t;1&n;&t; *&t;Parms:&t;&t;dev&t;&t;&t;Device assigned the IRQ that was raised.&n;&t; *&t;&t;&t;&t;host_int&t;The contents of the HOST_INT port.&n;&t; *&n;&t; *&t;This function handles the Dummy interrupt, which is raised whenever&n;&t; *&t;a test interrupt is generated by setting the Req_Int bit of HOST_CMD&n;&t; *&t;to 1.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_HandleDummy
id|u32
id|TLan_HandleDummy
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u16
id|host_int
)paren
(brace
id|host_int
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TLAN:  Dummy interrupt on %s.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* TLan_HandleDummy */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_HandleTxEOC&n;&t; *&n;&t; *&t;Returns:&t;1&n;&t; *&t;Parms:&t;&t;dev&t;&t;&t;Device assigned the IRQ that was raised.&n;&t; *&t;&t;&t;&t;host_int&t;The contents of the HOST_INT port.&n;&t; *&n;&t; *&t;This driver is structured to determine EOC occurances by reading the&n;&t; *&t;CSTAT member of the list structure.  Tx EOC interrupts are disabled&n;&t; *&t;via the DIO INTDIS register.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_HandleTxEOC
id|u32
id|TLan_HandleTxEOC
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u16
id|host_int
)paren
(brace
id|host_int
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TLAN:  Tx EOC interrupt on %s.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* TLan_HandleTxEOC */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_HandleStatusCheck&n;&t; *&n;&t; *&t;Returns:&t;0 if Adapter check, 1 if Network Status check.&n;&t; *&t;Parms:&t;&t;dev&t;&t;&t;Device assigned the IRQ that was raised.&n;&t; *&t;&t;&t;&t;host_int&t;The contents of the HOST_INT port.&n;&t; *&n;&t; *&t;This function handles Adapter Check/Network Status interrupts&n;&t; *&t;generated by the adapter.  It checks the vector in the HOST_INT&n;&t; *&t;register to determine if it is an Adapter Check interrupt.  If so,&n;&t; *&t;it resets the adapter.  Otherwise it clears the status registers&n;&t; *&t;and services the PHY.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_HandleStatusCheck
id|u32
id|TLan_HandleStatusCheck
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u16
id|host_int
)paren
(brace
id|u32
id|ack
suffix:semicolon
id|u32
id|error
suffix:semicolon
id|u8
id|net_sts
suffix:semicolon
id|TLanPrivateInfo
op_star
id|priv
op_assign
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|ack
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|host_int
op_amp
id|TLAN_HI_IV_MASK
)paren
(brace
id|error
op_assign
id|inl
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_CH_PARM
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TLAN:   Adaptor Check on device %s err = 0x%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|error
)paren
suffix:semicolon
id|TLan_ReadAndClearStats
c_func
(paren
id|dev
comma
id|TLAN_RECORD
)paren
suffix:semicolon
id|outl
c_func
(paren
id|TLAN_HC_AD_RST
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_HOST_CMD
)paren
suffix:semicolon
id|TLan_ResetLists
c_func
(paren
id|dev
)paren
suffix:semicolon
id|TLan_Reset
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|TLan_SetMac
c_func
(paren
id|dev
comma
l_int|0
comma
id|dev-&gt;dev_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;timerType
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|priv-&gt;phyFlags
op_amp
id|TLAN_PHY_AUTONEG
)paren
(brace
id|priv-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|TLAN_TIMER_LINK_DELAY
suffix:semicolon
id|priv-&gt;timerSetAt
op_assign
id|jiffies
suffix:semicolon
id|priv-&gt;timerType
op_assign
id|TLAN_TIMER_LINK
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|priv-&gt;timer
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|//printk( &quot; RX GO----&gt;&bslash;n&quot; );
id|outl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|priv-&gt;rxList
)paren
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_CH_PARM
)paren
suffix:semicolon
id|outl
c_func
(paren
id|TLAN_HC_GO
op_or
id|TLAN_HC_RT
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_HOST_CMD
)paren
suffix:semicolon
)brace
)brace
id|ack
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|net_sts
op_assign
id|TLan_DioRead8
c_func
(paren
id|dev-&gt;base_addr
comma
id|TLAN_NET_STS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_sts
)paren
id|TLan_DioWrite8
c_func
(paren
id|dev-&gt;base_addr
comma
id|TLAN_NET_STS
comma
id|net_sts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_sts
op_amp
id|TLAN_NET_STS_MIRQ
)paren
(paren
op_star
id|priv-&gt;phyService
)paren
(paren
id|dev
)paren
suffix:semicolon
id|TLAN_DBG
c_func
(paren
l_int|1
comma
l_string|&quot;TLAN: Status Check! %s Net_Sts=%x&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
)paren
id|net_sts
)paren
suffix:semicolon
)brace
r_return
id|ack
suffix:semicolon
)brace
multiline_comment|/* TLan_HandleStatusCheck */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_HandleRxEOC&n;&t; *&n;&t; *&t;Returns:&t;1&n;&t; *&t;Parms:&t;&t;dev&t;&t;&t;Device assigned the IRQ that was raised.&n;&t; *&t;&t;&t;&t;host_int&t;The contents of the HOST_INT port.&n;&t; *&n;&t; *&t;This driver is structured to determine EOC occurances by reading the&n;&t; *&t;CSTAT member of the list structure.  Rx EOC interrupts are disabled&n;&t; *&t;via the DIO INTDIS register.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_HandleRxEOC
id|u32
id|TLan_HandleRxEOC
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
id|u16
id|host_int
)paren
(brace
id|host_int
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TLAN:  Rx EOC interrupt on %s.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* TLan_HandleRxEOC */
DECL|variable|TLanIntVector
r_static
id|TLanIntVectorFunc
op_star
id|TLanIntVector
(braket
id|TLAN_INT_NUMBER_OF_INTS
)braket
op_assign
(brace
id|TLan_HandleInvalid
comma
id|TLan_HandleTxEOF
comma
id|TLan_HandleStatOverflow
comma
id|TLan_HandleRxEOF
comma
id|TLan_HandleDummy
comma
id|TLan_HandleTxEOC
comma
id|TLan_HandleStatusCheck
comma
id|TLan_HandleRxEOC
)brace
suffix:semicolon
multiline_comment|/*****************************************************************************&n;******************************************************************************&n;&n;&t;ThunderLAN Driver Timer Function&n;&n;******************************************************************************&n;*****************************************************************************/
r_static
r_void
id|TLan_Timer
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_Timer&n;&t; *&n;&t; *&t;Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;data&t;A value given to add timer when add_timer was&n;&t; *&t;&t;&t;&t;&t;&t;called.&n;&t; *&n;&t; *&t;This function handles timed functionality for the TLAN driver.  The&n;&t; *&t;two current timer uses are for delaying for autonegotionation and&n;&t; *&t;driving the ACT LED.&n;&t; *&t;-&t;Autonegotiation requires being allowed about 2 1/2 seconds before&n;&t; *&t;&t;attempting to transmit a packet.  It would be a very bad thing&n;&t; *&t;&t;to hang the kernel this long, so the driver doesn&squot;t allow&n;&t; *&t;&t;transmission &squot;til after this time, for certain PHYs.  It would&n;&t; *&t;&t;be much nicer if all PHYs were interrupt-capable like the&n;&t; *&t;&t;internal PHY.&n;&t; *&t;-&t;The ACT LED, which shows adapter activity, is driven by the driver,&n;&t; *&t;&t;and so must be left on for a short period to power up the LED so&n;&t; *&t;&t;it can be seen.  This delay can be changed by changing the&n;&t; *&t;&t;TLAN_TIMER_ACT_DELAY in tlan.h, if desired.  10 jiffies produces a &n;&t; *&t;&t;slightly sluggish response.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_Timer
r_void
id|TLan_Timer
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|device
op_star
id|dev
op_assign
(paren
r_struct
id|device
op_star
)paren
id|data
suffix:semicolon
id|u16
id|gen_sts
suffix:semicolon
id|TLanPrivateInfo
op_star
id|priv
op_assign
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
singleline_comment|// printk( &quot;TLAN:  %s Entered Timer, type = %d&bslash;n&quot;, dev-&gt;name, priv-&gt;timerType );
r_switch
c_cond
(paren
id|priv-&gt;timerType
)paren
(brace
r_case
id|TLAN_TIMER_LINK
suffix:colon
id|TLan_MiiReadReg
c_func
(paren
id|dev-&gt;base_addr
comma
id|priv-&gt;phyAddr
comma
id|MII_GEN_STS
comma
op_amp
id|gen_sts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gen_sts
op_amp
id|MII_GS_LINK
)paren
(brace
id|priv-&gt;phyOnline
op_assign
l_int|1
suffix:semicolon
id|outl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|priv-&gt;rxList
)paren
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_CH_PARM
)paren
suffix:semicolon
id|outl
c_func
(paren
id|TLAN_HC_GO
op_or
id|TLAN_HC_RT
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_HOST_CMD
)paren
suffix:semicolon
id|priv-&gt;timerSetAt
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;timerType
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|priv-&gt;timer.expires
op_assign
id|jiffies
op_plus
(paren
id|TLAN_TIMER_LINK_DELAY
op_star
l_int|2
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|priv-&gt;timer
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TLAN_TIMER_ACT
suffix:colon
r_if
c_cond
(paren
id|jiffies
op_minus
id|priv-&gt;timerSetAt
op_ge
id|TLAN_TIMER_ACT_DELAY
)paren
(brace
id|TLan_DioWrite8
c_func
(paren
id|dev-&gt;base_addr
comma
id|TLAN_LED_REG
comma
id|TLAN_LED_LINK
)paren
suffix:semicolon
id|priv-&gt;timerSetAt
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;timerType
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|priv-&gt;timer.expires
op_assign
id|priv-&gt;timerSetAt
op_plus
id|TLAN_TIMER_ACT_DELAY
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|priv-&gt;timer
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* TLan_Timer */
multiline_comment|/*****************************************************************************&n;******************************************************************************&n;&n;&t;ThunderLAN Driver Primary Functions&n;&n;&t;These functions are more or less common to all Linux network drivers.&n;&n;******************************************************************************&n;*****************************************************************************/
r_static
r_int
id|TLan_PciProbe
c_func
(paren
id|u8
op_star
comma
id|u8
op_star
comma
id|u8
op_star
comma
id|u8
op_star
comma
id|u32
op_star
comma
id|u32
op_star
)paren
suffix:semicolon
r_static
r_int
id|TLan_Init
c_func
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_int
id|TLan_Open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|TLan_StartTx
c_func
(paren
r_struct
id|sk_buff
op_star
comma
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_void
id|TLan_HandleInterrupt
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_static
r_int
id|TLan_Close
c_func
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_struct
id|enet_statistics
op_star
id|TLan_GetStats
c_func
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
r_static
r_void
id|TLan_SetMulticastList
c_func
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
macro_line|#ifdef MODULE
multiline_comment|/*************************************************************************&n;&t; *&t;init_module&n;&t; *&n;&t; *&t;Returns:&t;0 if module installed ok, non-zero if not.&n;&t; *&t;Parms:&t;&t;None&n;&t; *&n;&t; *&t;This function begins the setup of the driver creating a pad buffer,&n;&t; *&t;finding all TLAN devices (matching TLanDeviceList entries), and&n;&t; *&t;creating and initializing a device structure for each adapter.&n;&t; *&n;&t; ************************************************************************/
DECL|function|init_module
r_extern
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|failed
comma
id|found
suffix:semicolon
r_int
id|dev_size
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
id|TLanPrivateInfo
op_star
id|priv
suffix:semicolon
id|u8
id|bus
comma
id|dfn
comma
id|irq
comma
id|rev
suffix:semicolon
id|u32
id|io_base
comma
id|dl_ix
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TLAN driver, v%d.%d, (C) 1997 Caldera, Inc.&bslash;n&quot;
comma
id|TLanVersionMajor
comma
id|TLanVersionMinor
)paren
suffix:semicolon
id|TLanPadBuffer
op_assign
(paren
id|u8
op_star
)paren
id|kmalloc
c_func
(paren
id|TLAN_MIN_FRAME_SIZE
comma
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TLanPadBuffer
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TLAN:  Could not allocate memory for pad buffer.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|TLanPadBuffer
comma
l_int|0
comma
id|TLAN_MIN_FRAME_SIZE
)paren
suffix:semicolon
id|dev_size
op_assign
r_sizeof
(paren
r_struct
id|device
)paren
op_plus
r_sizeof
(paren
id|TLanPrivateInfo
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|found
op_assign
id|TLan_PciProbe
c_func
(paren
op_amp
id|bus
comma
op_amp
id|dfn
comma
op_amp
id|irq
comma
op_amp
id|rev
comma
op_amp
id|io_base
comma
op_amp
id|dl_ix
)paren
)paren
)paren
(brace
id|dev
op_assign
(paren
r_struct
id|device
op_star
)paren
id|kmalloc
c_func
(paren
id|dev_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TLAN:  Could not allocate memory for device.&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
id|dev_size
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
id|priv
op_assign
(paren
(paren
r_void
op_star
)paren
id|dev
)paren
op_plus
r_sizeof
(paren
r_struct
id|device
)paren
suffix:semicolon
id|dev-&gt;name
op_assign
id|priv-&gt;devName
suffix:semicolon
id|strcpy
c_func
(paren
id|priv-&gt;devName
comma
l_string|&quot;    &quot;
)paren
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|io_base
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
id|dev-&gt;init
op_assign
id|TLan_Init
suffix:semicolon
id|priv-&gt;pciBus
op_assign
id|bus
suffix:semicolon
id|priv-&gt;pciDeviceFn
op_assign
id|dfn
suffix:semicolon
id|priv-&gt;pciRevision
op_assign
id|rev
suffix:semicolon
id|priv-&gt;pciEntry
op_assign
id|dl_ix
suffix:semicolon
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
id|failed
op_assign
id|register_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|failed
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TLAN:  Could not register network device.  Freeing struct.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|priv-&gt;nextDevice
op_assign
id|TLanDevices
suffix:semicolon
id|TLanDevices
op_assign
id|dev
suffix:semicolon
id|TLanDevicesInstalled
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TLAN:  %s irq=%2d io=%04x, %s&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
r_int
)paren
id|irq
comma
id|io_base
comma
id|TLanDeviceList
(braket
id|dl_ix
)braket
dot
id|deviceName
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// printk( &quot;TLAN:  Found %d device(s).&bslash;n&quot;, TLanDevicesInstalled );
r_return
(paren
(paren
id|TLanDevicesInstalled
op_ge
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
multiline_comment|/* init_module */
multiline_comment|/*************************************************************************&n;&t; *&t;cleanup_module&n;&t; *&n;&t; *&t;Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;None&n;&t; *&n;&t; *&t;Goes through the TLanDevices list and frees the device structs and&n;&t; *&t;memory associated with each device (lists and buffers).  It also&n;&t; *&t;ureserves the IO port regions associated with this device.&n;&t; *&n;&t; ************************************************************************/
DECL|function|cleanup_module
r_extern
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|device
op_star
id|dev
suffix:semicolon
id|TLanPrivateInfo
op_star
id|priv
suffix:semicolon
r_while
c_loop
(paren
id|TLanDevicesInstalled
)paren
(brace
id|dev
op_assign
id|TLanDevices
suffix:semicolon
id|priv
op_assign
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;dmaStorage
)paren
id|kfree
c_func
(paren
id|priv-&gt;dmaStorage
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|dev-&gt;base_addr
comma
l_int|0x10
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|TLanDevices
op_assign
id|priv-&gt;nextDevice
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
id|TLanDevicesInstalled
op_decrement
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|TLanPadBuffer
)paren
suffix:semicolon
)brace
multiline_comment|/* cleanup_module */
macro_line|#else /* MODULE */
multiline_comment|/*************************************************************************&n;&t; *&t;tlan_probe&n;&t; *&n;&t; *&t;Returns:&t;0 on success, error code on error&n;&t; *&t;Parms:&t;&t;dev&t;&t;device struct to use if adapter is found.&n;&t; *&n;&t; *&t;The name is lower case to fit in with all the rest of the&n;&t; *&t;netcard_probe names.  This function looks for a/another TLan based&n;&t; *&t;adapter, setting it up with the provided device struct if one is&n;&t; *&t;found.&n;&t; *&n;&t; ************************************************************************/
DECL|function|tlan_probe
r_extern
r_int
id|tlan_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_static
r_int
id|pad_allocated
op_assign
l_int|0
suffix:semicolon
r_int
id|found
suffix:semicolon
id|TLanPrivateInfo
op_star
id|priv
suffix:semicolon
id|u8
id|bus
comma
id|dfn
comma
id|irq
comma
id|rev
suffix:semicolon
id|u32
id|io_base
comma
id|dl_ix
suffix:semicolon
id|found
op_assign
id|TLan_PciProbe
c_func
(paren
op_amp
id|bus
comma
op_amp
id|dfn
comma
op_amp
id|irq
comma
op_amp
id|rev
comma
op_amp
id|io_base
comma
op_amp
id|dl_ix
)paren
suffix:semicolon
id|TLAN_DBG
c_func
(paren
l_int|1
comma
l_string|&quot;TLAN:  Probing...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|found
)paren
(brace
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|TLanPrivateInfo
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TLAN:  Could not allocate memory for device.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
id|TLanPrivateInfo
)paren
)paren
suffix:semicolon
id|priv
op_assign
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|dev-&gt;name
op_assign
id|priv-&gt;devName
suffix:semicolon
id|strcpy
c_func
(paren
id|priv-&gt;devName
comma
l_string|&quot;    &quot;
)paren
suffix:semicolon
id|dev
op_assign
id|init_etherdev
c_func
(paren
id|dev
comma
r_sizeof
(paren
id|TLanPrivateInfo
)paren
)paren
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|io_base
suffix:semicolon
id|dev-&gt;irq
op_assign
id|irq
suffix:semicolon
id|priv-&gt;pciBus
op_assign
id|bus
suffix:semicolon
id|priv-&gt;pciDeviceFn
op_assign
id|dfn
suffix:semicolon
id|priv-&gt;pciRevision
op_assign
id|rev
suffix:semicolon
id|priv-&gt;pciEntry
op_assign
id|dl_ix
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pad_allocated
)paren
(brace
id|TLanPadBuffer
op_assign
(paren
id|u8
op_star
)paren
id|kmalloc
c_func
(paren
id|TLAN_MIN_FRAME_SIZE
comma
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TLanPadBuffer
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TLAN:  Could not allocate memory for pad buffer.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|pad_allocated
op_assign
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|TLanPadBuffer
comma
l_int|0
comma
id|TLAN_MIN_FRAME_SIZE
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;TLAN %d.%d:  %s irq=%2d io=%04x, %s&bslash;n&quot;
comma
id|TLanVersionMajor
comma
id|TLanVersionMinor
comma
id|dev-&gt;name
comma
(paren
r_int
)paren
id|irq
comma
id|io_base
comma
id|TLanDeviceList
(braket
id|dl_ix
)braket
dot
id|deviceName
)paren
suffix:semicolon
id|TLan_Init
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
(paren
(paren
id|found
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
multiline_comment|/* tlan_probe */
macro_line|#endif /* MODULE */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_PciProbe&n;&t; *&n;&t; *&t;Returns:&t;1 if another TLAN card was found, 0 if not.&n;&t; *&t;Parms:&t;&t;pci_bus&t;&t;The PCI bus the card was found on.&n;&t; *&t;&t;&t;&t;pci_dfn&t;&t;The PCI whatever the card was found at.&n;&t; *&t;&t;&t;&t;pci_irq&t;&t;The IRQ of the found adapter.&n;&t; *&t;&t;&t;&t;pci_rev&t;&t;The revision of the adapter.&n;&t; *&t;&t;&t;&t;pci_io_base&t;The first IO port used by the adapter.&n;&t; *&t;&t;&t;&t;dl_ix&t;&t;The index in the device list of the adapter.&n;&t; *&n;&t; *&t;This function searches for an adapter with PCI vendor and device&n;&t; *&t;IDs matching those in the TLanDeviceList.  The function &squot;remembers&squot;&n;&t; *&t;the last device it found, and so finds a new device (if anymore are&n;&t; *&t;to be found) each time the function is called.  It then looks up&n;&t; *&t;pertinent PCI info and returns it to the caller.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_PciProbe
r_int
id|TLan_PciProbe
c_func
(paren
id|u8
op_star
id|pci_bus
comma
id|u8
op_star
id|pci_dfn
comma
id|u8
op_star
id|pci_irq
comma
id|u8
op_star
id|pci_rev
comma
id|u32
op_star
id|pci_io_base
comma
id|u32
op_star
id|dl_ix
)paren
(brace
r_static
r_int
id|dl_index
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|pci_index
op_assign
l_int|0
suffix:semicolon
r_int
id|not_found
suffix:semicolon
id|u8
id|pci_latency
suffix:semicolon
id|u16
id|pci_command
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibios_present
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TLAN:   PCI Bios not present.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|TLanDeviceList
(braket
id|dl_index
)braket
dot
id|vendorId
op_ne
l_int|0
suffix:semicolon
id|dl_index
op_increment
)paren
(brace
id|not_found
op_assign
id|pcibios_find_device
c_func
(paren
id|TLanDeviceList
(braket
id|dl_index
)braket
dot
id|vendorId
comma
id|TLanDeviceList
(braket
id|dl_index
)braket
dot
id|deviceId
comma
id|pci_index
comma
id|pci_bus
comma
id|pci_dfn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|not_found
)paren
(brace
id|TLAN_DBG
c_func
(paren
l_int|1
comma
l_string|&quot;TLAN:   found: Vendor Id = 0x%hx, Device Id = 0x%hx&bslash;n&quot;
comma
id|TLanDeviceList
(braket
id|dl_index
)braket
dot
id|vendorId
comma
id|TLanDeviceList
(braket
id|dl_index
)braket
dot
id|deviceId
)paren
suffix:semicolon
id|pcibios_read_config_byte
(paren
op_star
id|pci_bus
comma
op_star
id|pci_dfn
comma
id|PCI_REVISION_ID
comma
id|pci_rev
)paren
suffix:semicolon
id|pcibios_read_config_byte
(paren
op_star
id|pci_bus
comma
op_star
id|pci_dfn
comma
id|PCI_INTERRUPT_LINE
comma
id|pci_irq
)paren
suffix:semicolon
id|pcibios_read_config_word
(paren
op_star
id|pci_bus
comma
op_star
id|pci_dfn
comma
id|PCI_COMMAND
comma
op_amp
id|pci_command
)paren
suffix:semicolon
id|pcibios_read_config_dword
c_func
(paren
op_star
id|pci_bus
comma
op_star
id|pci_dfn
comma
id|PCI_BASE_ADDRESS_0
comma
id|pci_io_base
)paren
suffix:semicolon
id|pcibios_read_config_byte
(paren
op_star
id|pci_bus
comma
op_star
id|pci_dfn
comma
id|PCI_LATENCY_TIMER
comma
op_amp
id|pci_latency
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_latency
OL
l_int|0x10
)paren
(brace
id|pcibios_write_config_byte
c_func
(paren
op_star
id|pci_bus
comma
op_star
id|pci_dfn
comma
id|PCI_LATENCY_TIMER
comma
l_int|0xff
)paren
suffix:semicolon
id|TLAN_DBG
c_func
(paren
l_int|1
comma
l_string|&quot;TLAN:      Setting latency timer to max.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pci_command
op_amp
id|PCI_COMMAND_IO
)paren
op_logical_and
(paren
op_star
id|pci_io_base
op_amp
l_int|0x3
)paren
)paren
(brace
op_star
id|pci_io_base
op_and_assign
id|PCI_BASE_ADDRESS_IO_MASK
suffix:semicolon
id|TLAN_DBG
c_func
(paren
l_int|1
comma
l_string|&quot;TLAN:      IO mapping is available at %x.&bslash;n&quot;
comma
op_star
id|pci_io_base
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|pci_io_base
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TLAN:      IO mapping not available, ignoring device.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pci_command
op_amp
id|PCI_COMMAND_MASTER
)paren
(brace
id|TLAN_DBG
c_func
(paren
l_int|1
comma
l_string|&quot;TLAN:      Bus mastering is active.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|pci_index
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pci_io_base
)paren
(brace
op_star
id|dl_ix
op_assign
id|dl_index
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|pci_index
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* TLan_PciProbe */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_Init&n;&t; *&n;&t; *&t;Returns:&t;0 on success, error code otherwise.&n;&t; *&t;Parms:&t;&t;dev&t;&t;The structure of the device to be init&squot;ed.&n;&t; *&n;&t; *&t;This function completes the initialization of the device structure&n;&t; *&t;and driver.  It reserves the IO addresses, allocates memory for the&n;&t; *&t;lists and bounce buffers, retrieves the MAC address from the eeprom&n;&t; *&t;and assignes the device&squot;s methods.&n;&t; *&t;&n;&t; ************************************************************************/
DECL|function|TLan_Init
r_int
id|TLan_Init
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|dma_size
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|i
suffix:semicolon
id|TLanPrivateInfo
op_star
id|priv
suffix:semicolon
id|priv
op_assign
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|err
op_assign
id|check_region
c_func
(paren
id|dev-&gt;base_addr
comma
l_int|0x10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TLAN:  %s: Io port region 0x%lx size 0x%x in use.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;base_addr
comma
l_int|0x10
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|request_region
c_func
(paren
id|dev-&gt;base_addr
comma
l_int|0x10
comma
id|TLanSignature
)paren
suffix:semicolon
id|dma_size
op_assign
(paren
id|TLAN_NUM_RX_LISTS
op_plus
id|TLAN_NUM_TX_LISTS
)paren
op_star
(paren
r_sizeof
(paren
id|TLanList
)paren
op_plus
id|TLAN_MAX_FRAME_SIZE
)paren
suffix:semicolon
id|priv-&gt;dmaStorage
op_assign
id|kmalloc
c_func
(paren
id|dma_size
comma
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;dmaStorage
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TLAN:  Could not allocate lists and buffers for %s.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|priv-&gt;dmaStorage
comma
l_int|0
comma
id|dma_size
)paren
suffix:semicolon
id|priv-&gt;rxList
op_assign
(paren
id|TLanList
op_star
)paren
(paren
(paren
(paren
(paren
id|u32
)paren
id|priv-&gt;dmaStorage
)paren
op_plus
l_int|7
)paren
op_amp
l_int|0xFFFFFFF8
)paren
suffix:semicolon
id|priv-&gt;txList
op_assign
id|priv-&gt;rxList
op_plus
id|TLAN_NUM_RX_LISTS
suffix:semicolon
id|priv-&gt;rxBuffer
op_assign
(paren
id|u8
op_star
)paren
(paren
id|priv-&gt;txList
op_plus
id|TLAN_NUM_TX_LISTS
)paren
suffix:semicolon
id|priv-&gt;txBuffer
op_assign
id|priv-&gt;rxBuffer
op_plus
(paren
id|TLAN_NUM_RX_LISTS
op_star
id|TLAN_MAX_FRAME_SIZE
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|err
op_or_assign
id|TLan_EeReadByte
c_func
(paren
id|dev-&gt;base_addr
comma
(paren
id|u8
)paren
l_int|0x83
op_plus
id|i
comma
(paren
id|u8
op_star
)paren
op_amp
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
l_string|&quot;TLAN:  %s: Error reading MAC Address from eeprom: %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|err
)paren
suffix:semicolon
id|dev-&gt;addr_len
op_assign
l_int|6
suffix:semicolon
id|dev-&gt;open
op_assign
op_amp
id|TLan_Open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|TLan_StartTx
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|TLan_Close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|TLan_GetStats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|TLan_SetMulticastList
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* TLan_Init */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_Open&n;&t; *&n;&t; *&t;Returns:&t;0 on success, error code otherwise.&n;&t; *&t;Parms:&t;&t;dev&t;&t;Structure of device to be opened.&n;&t; *&n;&t; *&t;This routine puts the driver and TLAN adapter in a state where it is&n;&t; *&t;ready to send and receive packets.  It allocates the IRQ, resets and&n;&t; *&t;brings the adapter out of reset, and allows interrupts.  It also&n;&t; *&t;delays the startup for autonegotiation or sends a Rx GO command to&n;&t; *&t;the adapter, as appropriate.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_Open
r_int
id|TLan_Open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|err
suffix:semicolon
id|TLanPrivateInfo
op_star
id|priv
op_assign
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|err
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
id|TLan_HandleInterrupt
comma
id|SA_SHIRQ
comma
id|TLanSignature
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;TLAN:  %s: IRQ %d already in use.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|MOD_INC_USE_COUNT
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* NOTE: It might not be necessary to read the stats before a&n;&t;&t;&t;&t;&t; reset if you don&squot;t care what the values are.&n;&t;&t;&t;*/
id|TLan_ResetLists
c_func
(paren
id|dev
)paren
suffix:semicolon
id|TLan_ReadAndClearStats
c_func
(paren
id|dev
comma
id|TLAN_IGNORE
)paren
suffix:semicolon
id|TLan_Reset
c_func
(paren
id|dev
)paren
suffix:semicolon
id|TLan_SetMac
c_func
(paren
id|dev
comma
l_int|0
comma
id|dev-&gt;dev_addr
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|TLAN_HC_INT_ON
op_rshift
l_int|8
)paren
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_HOST_CMD
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
op_ge
l_int|1
)paren
id|outb
c_func
(paren
(paren
id|TLAN_HC_REQ_INT
op_rshift
l_int|8
)paren
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_HOST_CMD
op_plus
l_int|1
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|priv-&gt;timer
)paren
suffix:semicolon
id|priv-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|dev
suffix:semicolon
id|priv-&gt;timer.function
op_assign
op_amp
id|TLan_Timer
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;phyFlags
op_amp
id|TLAN_PHY_AUTONEG
)paren
(brace
id|priv-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|TLAN_TIMER_LINK_DELAY
suffix:semicolon
id|priv-&gt;timerSetAt
op_assign
id|jiffies
suffix:semicolon
id|priv-&gt;timerType
op_assign
id|TLAN_TIMER_LINK
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|priv-&gt;timer
)paren
suffix:semicolon
)brace
r_else
(brace
id|TLAN_DBG
c_func
(paren
l_int|1
comma
l_string|&quot;TLAN:  RX GO&bslash;n&quot;
)paren
suffix:semicolon
id|outl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|priv-&gt;rxList
)paren
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_CH_PARM
)paren
suffix:semicolon
id|outl
c_func
(paren
id|TLAN_HC_GO
op_or
id|TLAN_HC_RT
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_HOST_CMD
)paren
suffix:semicolon
)brace
id|TLAN_DBG
c_func
(paren
l_int|1
comma
l_string|&quot;TLAN:  Device %s opened.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* TLan_Open */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_StartTx&n;&t; *  &n;&t; *  Returns:&t;0 on success, non-zero on failure.&n;&t; *&t;Parms:&t;&t;skb&t;&t;A pointer to the sk_buff containing the frame to&n;&t; *&t;&t;&t;&t;&t;&t;be sent.&n;&t; *&t;&t;&t;&t;dev&t;&t;The device to send the data on.&n;&t; *&n;&t; *&t;This function adds a frame to the Tx list to be sent ASAP.  First it&n;&t; *&t;verifies that the adapter is ready and there is room in the queue.&n;&t; *&t;Then it sets up the next available list, copies the frame to the&n;&t; *&t;corresponding buffer.  If the adapter Tx channel is idle, it gives&n;&t; *&t;adapter a Tx Go command on the list, otherwise it sets the forward&n;&t; *&t;address of the previous list to point to this one.  Then it frees&n;&t; *&t;the sk_buff.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_StartTx
r_int
id|TLan_StartTx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
id|TLanPrivateInfo
op_star
id|priv
op_assign
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|TLanList
op_star
id|tail_list
suffix:semicolon
id|u8
op_star
id|tail_buffer
suffix:semicolon
r_int
id|pad
suffix:semicolon
singleline_comment|// printk( &quot;Entering StartTx&bslash;n&quot; );
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;phyOnline
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|tail_list
op_assign
id|priv-&gt;txList
op_plus
id|priv-&gt;txTail
suffix:semicolon
r_if
c_cond
(paren
id|tail_list-&gt;cStat
op_ne
id|TLAN_CSTAT_UNUSED
)paren
(brace
singleline_comment|// printk( &quot;TLAN:  %s TX is busy, Head=%d Tail=%d&bslash;n&quot;, dev-&gt;name, priv-&gt;txHead, priv-&gt;txTail );
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
singleline_comment|// printk( &quot;TLAN:   Tx is busy.&bslash;n&quot;);
id|priv-&gt;txBusyCount
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|tail_list-&gt;forward
op_assign
l_int|0
suffix:semicolon
id|tail_buffer
op_assign
id|priv-&gt;txBuffer
op_plus
(paren
id|priv-&gt;txTail
op_star
id|TLAN_MAX_FRAME_SIZE
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tail_buffer
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|pad
op_assign
id|TLAN_MIN_FRAME_SIZE
op_minus
id|skb-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|pad
OG
l_int|0
)paren
(brace
id|tail_list-&gt;frameSize
op_assign
(paren
id|u16
)paren
id|skb-&gt;len
op_plus
id|pad
suffix:semicolon
id|tail_list-&gt;buffer
(braket
l_int|0
)braket
dot
id|count
op_assign
(paren
id|u32
)paren
id|skb-&gt;len
suffix:semicolon
id|tail_list-&gt;buffer
(braket
l_int|1
)braket
dot
id|count
op_assign
id|TLAN_LAST_BUFFER
op_or
(paren
id|u32
)paren
id|pad
suffix:semicolon
id|tail_list-&gt;buffer
(braket
l_int|1
)braket
dot
id|address
op_assign
id|virt_to_bus
c_func
(paren
id|TLanPadBuffer
)paren
suffix:semicolon
)brace
r_else
(brace
id|tail_list-&gt;frameSize
op_assign
(paren
id|u16
)paren
id|skb-&gt;len
suffix:semicolon
id|tail_list-&gt;buffer
(braket
l_int|0
)braket
dot
id|count
op_assign
id|TLAN_LAST_BUFFER
op_or
(paren
id|u32
)paren
id|skb-&gt;len
suffix:semicolon
id|tail_list-&gt;buffer
(braket
l_int|1
)braket
dot
id|count
op_assign
l_int|0
suffix:semicolon
id|tail_list-&gt;buffer
(braket
l_int|1
)braket
dot
id|address
op_assign
l_int|0
suffix:semicolon
)brace
singleline_comment|// are we transferring?
id|cli
c_func
(paren
)paren
suffix:semicolon
id|tail_list-&gt;cStat
op_assign
id|TLAN_CSTAT_READY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv-&gt;txInProgress
)paren
(brace
id|priv-&gt;txInProgress
op_assign
l_int|1
suffix:semicolon
id|outw
c_func
(paren
l_int|0x4
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_HOST_INT
)paren
suffix:semicolon
singleline_comment|// printk(&quot;TLAN: Sending GO for 0%d&bslash;n&quot;, priv-&gt;txTail );
id|outl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|tail_list
)paren
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_CH_PARM
)paren
suffix:semicolon
id|outl
c_func
(paren
id|TLAN_HC_GO
op_or
id|TLAN_HC_ACK
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_HOST_CMD
)paren
suffix:semicolon
)brace
r_else
(brace
singleline_comment|// printk(&quot;TLAN: Adding 0%d&bslash;n&quot;, priv-&gt;txTail );
singleline_comment|// Assign previous list to point to this one.  If previous has
singleline_comment|// already been read, the EOC check in the TX EOF interrupt handler
singleline_comment|// will start another transfer.
r_if
c_cond
(paren
id|priv-&gt;txTail
op_eq
l_int|0
)paren
(paren
id|priv-&gt;txList
op_plus
(paren
id|TLAN_NUM_TX_LISTS
op_minus
l_int|1
)paren
)paren
op_member_access_from_pointer
id|forward
op_assign
id|virt_to_bus
c_func
(paren
id|tail_list
)paren
suffix:semicolon
r_else
(paren
id|priv-&gt;txList
op_plus
(paren
id|priv-&gt;txTail
op_minus
l_int|1
)paren
)paren
op_member_access_from_pointer
id|forward
op_assign
id|virt_to_bus
c_func
(paren
id|tail_list
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|priv-&gt;txTail
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;txTail
op_ge
id|TLAN_NUM_TX_LISTS
)paren
id|priv-&gt;txTail
op_assign
l_int|0
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
singleline_comment|// printk( &quot;Leaving StartTx&bslash;n&quot; );
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* TLan_StartTx */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_HandleInterrupt&n;&t; *  &n;&t; *  Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;irq&t;&t;The line on which the interrupt occurred.&n;&t; *&t;&t;&t;&t;dev_id&t;A pointer to the device assigned to this irq line.&n;&t; *&t;&t;&t;&t;regs&t;???&n;&t; *&n;&t; *&t;This function handles an interrupt generated by its assigned TLAN&n;&t; *&t;adapter.  The function deactivates interrupts on its adapter, records&n;&t; *&t;the type of interrupt, executes the appropriate subhandler, and&n;&t; *&t;acknowdges the interrupt to the adapter (thus re-enabling adapter&n;&t; *&t;interrupts.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_HandleInterrupt
r_void
id|TLan_HandleInterrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|u32
id|ack
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
id|u32
id|host_cmd
suffix:semicolon
id|u16
id|host_int
suffix:semicolon
r_int
id|type
suffix:semicolon
id|dev
op_assign
(paren
r_struct
id|device
op_star
)paren
id|dev_id
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;interrupt
)paren
id|TLAN_DBG
c_func
(paren
l_int|1
comma
l_string|&quot;TLAN:   Re-entering interrupt handler for %s: %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;interrupt
)paren
suffix:semicolon
id|dev-&gt;interrupt
op_increment
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|host_int
op_assign
id|inw
c_func
(paren
id|dev-&gt;base_addr
op_plus
id|TLAN_HOST_INT
)paren
suffix:semicolon
id|outw
c_func
(paren
id|host_int
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_HOST_INT
)paren
suffix:semicolon
singleline_comment|// Deactivate Ints
id|type
op_assign
(paren
id|host_int
op_amp
id|TLAN_HI_IT_MASK
)paren
op_rshift
l_int|2
suffix:semicolon
id|ack
op_assign
id|TLanIntVector
(braket
id|type
)braket
(paren
id|dev
comma
id|host_int
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ack
)paren
(brace
id|host_cmd
op_assign
id|TLAN_HC_ACK
op_or
id|ack
op_or
(paren
id|type
op_lshift
l_int|18
)paren
suffix:semicolon
id|outl
c_func
(paren
id|host_cmd
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_HOST_CMD
)paren
suffix:semicolon
)brace
id|dev-&gt;interrupt
op_decrement
suffix:semicolon
)brace
multiline_comment|/* TLan_HandleInterrupts */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_Close&n;&t; *  &n;&t; *  Returns:&t;An error code.&n;&t; *&t;Parms:&t;&t;dev&t;&t;The device structure of the device to close.&n;&t; *&n;&t; *&t;This function shuts down the adapter.  It records any stats, puts&n;&t; *  the adapter into reset state, deactivates its time as needed, and&n;&t; *&t;frees the irq it is using.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_Close
r_int
id|TLan_Close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|TLanPrivateInfo
op_star
id|priv
op_assign
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
id|TLan_ReadAndClearStats
c_func
(paren
id|dev
comma
id|TLAN_RECORD
)paren
suffix:semicolon
id|outl
c_func
(paren
id|TLAN_HC_AD_RST
comma
id|dev-&gt;base_addr
op_plus
id|TLAN_HOST_CMD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;timerSetAt
op_ne
l_int|0
)paren
id|del_timer
c_func
(paren
op_amp
id|priv-&gt;timer
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|TLAN_DBG
c_func
(paren
l_int|1
comma
l_string|&quot;TLAN:   Device %s closed.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* TLan_Close */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_GetStats&n;&t; *  &n;&t; *  Returns:&t;A pointer to the device&squot;s statistics structure.&n;&t; *&t;Parms:&t;&t;dev&t;&t;The device structure to return the stats for.&n;&t; *&n;&t; *&t;This function updates the devices statistics by reading the TLAN&n;&t; *&t;chip&squot;s onboard registers.  Then it returns the address of the&n;&t; *&t;statistics structure.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_GetStats
r_struct
id|enet_statistics
op_star
id|TLan_GetStats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|TLanPrivateInfo
op_star
id|priv
op_assign
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Should only read stats if open ? */
id|TLan_ReadAndClearStats
c_func
(paren
id|dev
comma
id|TLAN_RECORD
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TLAN:  %s Rx EOC Count: %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|priv-&gt;rxEocCount
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TLAN:  %s Tx Busy Count: %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|priv-&gt;txBusyCount
)paren
suffix:semicolon
singleline_comment|// printk( &quot;TLAN:   Got stats for %s.&bslash;n&quot;, dev-&gt;name );
id|TLan_PrintDio
c_func
(paren
id|dev-&gt;base_addr
)paren
suffix:semicolon
id|TLan_PhyPrint
c_func
(paren
id|dev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TLAN_NUM_RX_LISTS
suffix:semicolon
id|i
op_increment
)paren
id|TLan_PrintList
c_func
(paren
id|priv-&gt;rxList
op_plus
id|i
comma
l_string|&quot;RX&quot;
comma
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TLAN_NUM_TX_LISTS
suffix:semicolon
id|i
op_increment
)paren
id|TLan_PrintList
c_func
(paren
id|priv-&gt;txList
op_plus
id|i
comma
l_string|&quot;TX&quot;
comma
id|i
)paren
suffix:semicolon
r_return
(paren
op_amp
(paren
(paren
id|TLanPrivateInfo
op_star
)paren
id|dev-&gt;priv
)paren
op_member_access_from_pointer
id|stats
)paren
suffix:semicolon
)brace
multiline_comment|/* TLan_GetStats */
multiline_comment|/*************************************************************************&n;&t; *&t;TLan_SetMulticastList&n;&t; *  &n;&t; *  Returns:&t;Nothing&n;&t; *&t;Parms:&t;&t;dev&t;&t;The device structure to set the multicast list for.&n;&t; *&n;&t; *&t;This function sets the TLAN adaptor to various receive modes.  If the&n;&t; *&t;IFF_PROMISC flag is set, promiscuous mode is acitviated.  Otherwise,&n;&t; *&t;promiscuous mode is turned off.  If the IFF_ALLMULTI flag is set, then&n;&t; *&t;the hash table is set to receive all group addresses.  Otherwise, the&n;&t; *&t;first three multicast addresses are stored in AREG_1-3, and the rest&n;&t; *  are selected via the hash table, as necessary.&n;&t; *&n;&t; ************************************************************************/
DECL|function|TLan_SetMulticastList
r_void
id|TLan_SetMulticastList
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|dev_mc_list
op_star
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
id|u32
id|hash1
op_assign
l_int|0
suffix:semicolon
id|u32
id|hash2
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u32
id|offset
suffix:semicolon
id|u8
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|tmp
op_assign
id|TLan_DioRead8
c_func
(paren
id|dev-&gt;base_addr
comma
id|TLAN_NET_CMD
)paren
suffix:semicolon
id|TLan_DioWrite8
c_func
(paren
id|dev-&gt;base_addr
comma
id|TLAN_NET_CMD
comma
id|tmp
op_or
id|TLAN_NET_CMD_CAF
)paren
suffix:semicolon
)brace
r_else
(brace
id|tmp
op_assign
id|TLan_DioRead8
c_func
(paren
id|dev-&gt;base_addr
comma
id|TLAN_NET_CMD
)paren
suffix:semicolon
id|TLan_DioWrite8
c_func
(paren
id|dev-&gt;base_addr
comma
id|TLAN_NET_CMD
comma
id|tmp
op_amp
op_complement
id|TLAN_NET_CMD_CAF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|TLan_SetMac
c_func
(paren
id|dev
comma
id|i
op_plus
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
id|TLan_DioWrite32
c_func
(paren
id|dev-&gt;base_addr
comma
id|TLAN_HASH_1
comma
l_int|0xFFFFFFFF
)paren
suffix:semicolon
id|TLan_DioWrite32
c_func
(paren
id|dev-&gt;base_addr
comma
id|TLAN_HASH_2
comma
l_int|0xFFFFFFFF
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;mc_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|3
)paren
(brace
id|TLan_SetMac
c_func
(paren
id|dev
comma
id|i
op_plus
l_int|1
comma
(paren
r_char
op_star
)paren
op_amp
id|dmi-&gt;dmi_addr
)paren
suffix:semicolon
)brace
r_else
(brace
id|offset
op_assign
id|TLan_HashFunc
c_func
(paren
(paren
id|u8
op_star
)paren
op_amp
id|dmi-&gt;dmi_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
l_int|32
)paren
id|hash1
op_or_assign
(paren
l_int|1
op_lshift
id|offset
)paren
suffix:semicolon
r_else
id|hash2
op_or_assign
(paren
l_int|1
op_lshift
(paren
id|offset
op_minus
l_int|32
)paren
)paren
suffix:semicolon
)brace
id|dmi
op_assign
id|dmi-&gt;next
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|TLan_SetMac
c_func
(paren
id|dev
comma
id|i
op_plus
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
id|TLan_DioWrite32
c_func
(paren
id|dev-&gt;base_addr
comma
id|TLAN_HASH_1
comma
id|hash1
)paren
suffix:semicolon
id|TLan_DioWrite32
c_func
(paren
id|dev-&gt;base_addr
comma
id|TLAN_HASH_2
comma
id|hash2
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* TLan_SetRxMode */
eof
