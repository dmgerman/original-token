multiline_comment|/*&n; * 6pack.c&t;This module implements the 6pack protocol for kernel-based&n; *&t;&t;devices like TTY. It interfaces between a raw TTY and the&n; *&t;&t;kernel&squot;s AX.25 protocol layers.&n; *&n; * Version:&t;@(#)6pack.c&t;0.3.0&t;04/07/98&n; *&n; * Authors:&t;Andreas K&#xfffd;nsgen &lt;ajk@iehk.rwth-aachen.de&gt;&n; *&n; * Quite a lot of stuff &quot;stolen&quot; by J&#xfffd;rg Reuter from slip.c, written by&n; *&n; *&t;&t;Laurence Culhane, &lt;loz@holmes.demon.co.uk&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uwalt.nl.mugnet.org&gt;&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;net/ax25.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/rtnetlink.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/if_slip.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ip.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
DECL|macro|SIXPACK_VERSION
mdefine_line|#define SIXPACK_VERSION    &quot;Revision: 0.3.0&quot;
multiline_comment|/* sixpack priority commands */
DECL|macro|SIXP_SEOF
mdefine_line|#define SIXP_SEOF&t;0x40&t;/* start and end of a 6pack frame */
DECL|macro|SIXP_TX_URUN
mdefine_line|#define SIXP_TX_URUN&t;0x48&t;/* transmit overrun */
DECL|macro|SIXP_RX_ORUN
mdefine_line|#define SIXP_RX_ORUN&t;0x50&t;/* receive overrun */
DECL|macro|SIXP_RX_BUF_OVL
mdefine_line|#define SIXP_RX_BUF_OVL&t;0x58&t;/* receive buffer overflow */
DECL|macro|SIXP_CHKSUM
mdefine_line|#define SIXP_CHKSUM&t;0xFF&t;/* valid checksum of a 6pack frame */
multiline_comment|/* masks to get certain bits out of the status bytes sent by the TNC */
DECL|macro|SIXP_CMD_MASK
mdefine_line|#define SIXP_CMD_MASK&t;&t;0xC0
DECL|macro|SIXP_CHN_MASK
mdefine_line|#define SIXP_CHN_MASK&t;&t;0x07
DECL|macro|SIXP_PRIO_CMD_MASK
mdefine_line|#define SIXP_PRIO_CMD_MASK&t;0x80
DECL|macro|SIXP_STD_CMD_MASK
mdefine_line|#define SIXP_STD_CMD_MASK&t;0x40
DECL|macro|SIXP_PRIO_DATA_MASK
mdefine_line|#define SIXP_PRIO_DATA_MASK&t;0x38
DECL|macro|SIXP_TX_MASK
mdefine_line|#define SIXP_TX_MASK&t;&t;0x20
DECL|macro|SIXP_RX_MASK
mdefine_line|#define SIXP_RX_MASK&t;&t;0x10
DECL|macro|SIXP_RX_DCD_MASK
mdefine_line|#define SIXP_RX_DCD_MASK&t;0x18
DECL|macro|SIXP_LEDS_ON
mdefine_line|#define SIXP_LEDS_ON&t;&t;0x78
DECL|macro|SIXP_LEDS_OFF
mdefine_line|#define SIXP_LEDS_OFF&t;&t;0x60
DECL|macro|SIXP_CON
mdefine_line|#define SIXP_CON&t;&t;0x08
DECL|macro|SIXP_STA
mdefine_line|#define SIXP_STA&t;&t;0x10
DECL|macro|SIXP_FOUND_TNC
mdefine_line|#define SIXP_FOUND_TNC&t;&t;0xe9
DECL|macro|SIXP_CON_ON
mdefine_line|#define SIXP_CON_ON&t;&t;0x68
DECL|macro|SIXP_DCD_MASK
mdefine_line|#define SIXP_DCD_MASK&t;&t;0x08
DECL|macro|SIXP_DAMA_OFF
mdefine_line|#define SIXP_DAMA_OFF&t;&t;0
multiline_comment|/* default level 2 parameters */
DECL|macro|SIXP_TXDELAY
mdefine_line|#define SIXP_TXDELAY&t;&t;&t;25&t;/* in 10 ms */
DECL|macro|SIXP_PERSIST
mdefine_line|#define SIXP_PERSIST&t;&t;&t;50&t;/* in 256ths */
DECL|macro|SIXP_SLOTTIME
mdefine_line|#define SIXP_SLOTTIME&t;&t;&t;10&t;/* in 10 ms */
DECL|macro|SIXP_INIT_RESYNC_TIMEOUT
mdefine_line|#define SIXP_INIT_RESYNC_TIMEOUT&t;150&t;/* in 10 ms */
DECL|macro|SIXP_RESYNC_TIMEOUT
mdefine_line|#define SIXP_RESYNC_TIMEOUT&t;&t;500&t;/* in 10 ms */
multiline_comment|/* 6pack configuration. */
DECL|macro|SIXP_NRUNIT
mdefine_line|#define SIXP_NRUNIT&t;&t;&t;256&t;/* MAX number of 6pack channels */
DECL|macro|SIXP_MTU
mdefine_line|#define SIXP_MTU&t;&t;&t;256&t;/* Default MTU */
DECL|enum|sixpack_flags
r_enum
id|sixpack_flags
(brace
DECL|enumerator|SIXPF_INUSE
id|SIXPF_INUSE
comma
multiline_comment|/* Channel in use&t;*/
DECL|enumerator|SIXPF_ERROR
id|SIXPF_ERROR
comma
multiline_comment|/* Parity, etc. error&t;*/
)brace
suffix:semicolon
DECL|struct|sixpack
r_struct
id|sixpack
(brace
DECL|member|magic
r_int
id|magic
suffix:semicolon
multiline_comment|/* Various fields. */
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
multiline_comment|/* ptr to TTY structure&t;&t;*/
DECL|member|dev
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* easy for intr handling&t;*/
multiline_comment|/* These are pointers to the malloc()ed frame buffers. */
DECL|member|rbuff
r_int
r_char
op_star
id|rbuff
suffix:semicolon
multiline_comment|/* receiver buffer&t;&t;*/
DECL|member|rcount
r_int
id|rcount
suffix:semicolon
multiline_comment|/* received chars counter       */
DECL|member|xbuff
r_int
r_char
op_star
id|xbuff
suffix:semicolon
multiline_comment|/* transmitter buffer&t;&t;*/
DECL|member|xhead
r_int
r_char
op_star
id|xhead
suffix:semicolon
multiline_comment|/* pointer to next byte to XMIT */
DECL|member|xleft
r_int
id|xleft
suffix:semicolon
multiline_comment|/* bytes left in XMIT queue     */
DECL|member|raw_buf
r_int
r_char
id|raw_buf
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|cooked_buf
r_int
r_char
id|cooked_buf
(braket
l_int|400
)braket
suffix:semicolon
DECL|member|rx_count
r_int
r_int
id|rx_count
suffix:semicolon
DECL|member|rx_count_cooked
r_int
r_int
id|rx_count_cooked
suffix:semicolon
multiline_comment|/* 6pack interface statistics. */
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|mtu
r_int
id|mtu
suffix:semicolon
multiline_comment|/* Our mtu (to spot changes!)   */
DECL|member|buffsize
r_int
id|buffsize
suffix:semicolon
multiline_comment|/* Max buffers sizes            */
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Flag values/ mode etc&t;*/
DECL|member|mode
r_int
r_char
id|mode
suffix:semicolon
multiline_comment|/* 6pack mode&t;&t;&t;*/
multiline_comment|/* 6pack stuff */
DECL|member|tx_delay
r_int
r_char
id|tx_delay
suffix:semicolon
DECL|member|persistance
r_int
r_char
id|persistance
suffix:semicolon
DECL|member|slottime
r_int
r_char
id|slottime
suffix:semicolon
DECL|member|duplex
r_int
r_char
id|duplex
suffix:semicolon
DECL|member|led_state
r_int
r_char
id|led_state
suffix:semicolon
DECL|member|status
r_int
r_char
id|status
suffix:semicolon
DECL|member|status1
r_int
r_char
id|status1
suffix:semicolon
DECL|member|status2
r_int
r_char
id|status2
suffix:semicolon
DECL|member|tx_enable
r_int
r_char
id|tx_enable
suffix:semicolon
DECL|member|tnc_ok
r_int
r_char
id|tnc_ok
suffix:semicolon
DECL|member|tx_t
r_struct
id|timer_list
id|tx_t
suffix:semicolon
DECL|member|resync_t
r_struct
id|timer_list
id|resync_t
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* should later be moved to include/net/ax25.h */
DECL|macro|AX25_6PACK_HEADER_LEN
mdefine_line|#define AX25_6PACK_HEADER_LEN 0
DECL|macro|SIXPACK_MAGIC
mdefine_line|#define SIXPACK_MAGIC 0x5304
DECL|variable|__initdata
r_static
r_const
r_char
id|banner
(braket
)braket
id|__initdata
op_assign
id|KERN_INFO
l_string|&quot;AX.25: 6pack driver, &quot;
id|SIXPACK_VERSION
l_string|&quot; (dynamic channels, max=%d)&bslash;n&quot;
suffix:semicolon
DECL|struct|sixpack_ctrl
r_typedef
r_struct
id|sixpack_ctrl
(brace
DECL|member|ctrl
r_struct
id|sixpack
id|ctrl
suffix:semicolon
multiline_comment|/* 6pack things&t;&t;&t;*/
DECL|member|dev
r_struct
id|net_device
id|dev
suffix:semicolon
multiline_comment|/* the device&t;&t;&t;*/
DECL|typedef|sixpack_ctrl_t
)brace
id|sixpack_ctrl_t
suffix:semicolon
DECL|variable|sixpack_ctrls
r_static
id|sixpack_ctrl_t
op_star
op_star
id|sixpack_ctrls
suffix:semicolon
DECL|variable|sixpack_maxdev
r_int
id|sixpack_maxdev
op_assign
id|SIXP_NRUNIT
suffix:semicolon
multiline_comment|/* Can be overridden with insmod! */
DECL|variable|sp_ldisc
r_static
r_struct
id|tty_ldisc
id|sp_ldisc
suffix:semicolon
r_static
r_void
id|sp_start_tx_timer
c_func
(paren
r_struct
id|sixpack
op_star
)paren
suffix:semicolon
r_static
r_void
id|sp_xmit_on_air
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|resync_tnc
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|sixpack_decode
c_func
(paren
r_struct
id|sixpack
op_star
comma
r_int
r_char
(braket
)braket
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|encode_sixpack
c_func
(paren
r_int
r_char
op_star
comma
r_int
r_char
op_star
comma
r_int
comma
r_int
r_char
)paren
suffix:semicolon
r_static
r_int
id|sixpack_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|decode_prio_command
c_func
(paren
r_int
r_char
comma
r_struct
id|sixpack
op_star
)paren
suffix:semicolon
r_static
r_void
id|decode_std_command
c_func
(paren
r_int
r_char
comma
r_struct
id|sixpack
op_star
)paren
suffix:semicolon
r_static
r_void
id|decode_data
c_func
(paren
r_int
r_char
comma
r_struct
id|sixpack
op_star
)paren
suffix:semicolon
r_static
r_int
id|tnc_init
c_func
(paren
r_struct
id|sixpack
op_star
)paren
suffix:semicolon
multiline_comment|/* Find a free 6pack channel, and link in this `tty&squot; line. */
DECL|function|sp_alloc
r_static
r_inline
r_struct
id|sixpack
op_star
id|sp_alloc
c_func
(paren
r_void
)paren
(brace
id|sixpack_ctrl_t
op_star
id|spp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sixpack_maxdev
suffix:semicolon
id|i
op_increment
)paren
(brace
id|spp
op_assign
id|sixpack_ctrls
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|spp
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|SIXPF_INUSE
comma
op_amp
id|spp-&gt;ctrl.flags
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Too many devices... */
r_if
c_cond
(paren
id|i
op_ge
id|sixpack_maxdev
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* If no channels are available, allocate one */
r_if
c_cond
(paren
op_logical_neg
id|spp
op_logical_and
(paren
id|sixpack_ctrls
(braket
id|i
)braket
op_assign
(paren
id|sixpack_ctrl_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|sixpack_ctrl_t
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|spp
op_assign
id|sixpack_ctrls
(braket
id|i
)braket
suffix:semicolon
id|memset
c_func
(paren
id|spp
comma
l_int|0
comma
r_sizeof
(paren
id|sixpack_ctrl_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Initialize channel control data */
id|set_bit
c_func
(paren
id|SIXPF_INUSE
comma
op_amp
id|spp-&gt;ctrl.flags
)paren
suffix:semicolon
id|spp-&gt;ctrl.tty
op_assign
l_int|NULL
suffix:semicolon
id|sprintf
c_func
(paren
id|spp-&gt;dev.name
comma
l_string|&quot;sp%d&quot;
comma
id|i
)paren
suffix:semicolon
id|spp-&gt;dev.base_addr
op_assign
id|i
suffix:semicolon
id|spp-&gt;dev.priv
op_assign
(paren
r_void
op_star
)paren
op_amp
id|spp-&gt;ctrl
suffix:semicolon
id|spp-&gt;dev.next
op_assign
l_int|NULL
suffix:semicolon
id|spp-&gt;dev.init
op_assign
id|sixpack_init
suffix:semicolon
)brace
r_if
c_cond
(paren
id|spp
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* register device so that it can be ifconfig&squot;ed       */
multiline_comment|/* sixpack_init() will be called as a side-effect         */
multiline_comment|/* SIDE-EFFECT WARNING: sixpack_init() CLEARS spp-&gt;ctrl ! */
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
op_amp
id|spp-&gt;dev
)paren
op_eq
l_int|0
)paren
(brace
id|set_bit
c_func
(paren
id|SIXPF_INUSE
comma
op_amp
id|spp-&gt;ctrl.flags
)paren
suffix:semicolon
id|spp-&gt;ctrl.dev
op_assign
op_amp
id|spp-&gt;dev
suffix:semicolon
id|spp-&gt;dev.priv
op_assign
(paren
r_void
op_star
)paren
op_amp
id|spp-&gt;ctrl
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
op_amp
id|spp-&gt;dev
)paren
suffix:semicolon
r_return
op_amp
id|spp-&gt;ctrl
suffix:semicolon
)brace
r_else
(brace
id|clear_bit
c_func
(paren
id|SIXPF_INUSE
comma
op_amp
id|spp-&gt;ctrl.flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;sp_alloc() - register_netdev() failure.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Free a 6pack channel. */
DECL|function|sp_free
r_static
r_inline
r_void
id|sp_free
c_func
(paren
r_struct
id|sixpack
op_star
id|sp
)paren
(brace
multiline_comment|/* Free all 6pack frame buffers. */
r_if
c_cond
(paren
id|sp-&gt;rbuff
)paren
id|kfree
c_func
(paren
id|sp-&gt;rbuff
)paren
suffix:semicolon
id|sp-&gt;rbuff
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;xbuff
)paren
id|kfree
c_func
(paren
id|sp-&gt;xbuff
)paren
suffix:semicolon
id|sp-&gt;xbuff
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_and_clear_bit
c_func
(paren
id|SIXPF_INUSE
comma
op_amp
id|sp-&gt;flags
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: sp_free for already free unit.&bslash;n&quot;
comma
id|sp-&gt;dev-&gt;name
)paren
suffix:semicolon
)brace
multiline_comment|/* Send one completely decapsulated IP datagram to the IP layer. */
multiline_comment|/* This is the routine that sends the received data to the kernel AX.25.&n;   &squot;cmd&squot; is the KISS command. For AX.25 data, it is zero. */
DECL|function|sp_bump
r_static
r_void
id|sp_bump
c_func
(paren
r_struct
id|sixpack
op_star
id|sp
comma
r_char
id|cmd
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_char
op_star
id|ptr
suffix:semicolon
id|count
op_assign
id|sp-&gt;rcount
op_plus
l_int|1
suffix:semicolon
id|sp-&gt;stats.rx_bytes
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|count
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: memory squeeze, dropping packet.&bslash;n&quot;
comma
id|sp-&gt;dev-&gt;name
)paren
suffix:semicolon
id|sp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|skb-&gt;dev
op_assign
id|sp-&gt;dev
suffix:semicolon
id|ptr
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|count
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|cmd
suffix:semicolon
multiline_comment|/* KISS command */
id|memcpy
c_func
(paren
id|ptr
comma
(paren
id|sp-&gt;cooked_buf
)paren
op_plus
l_int|1
comma
id|count
)paren
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_AX25
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|sp-&gt;stats.rx_packets
op_increment
suffix:semicolon
)brace
multiline_comment|/* ----------------------------------------------------------------------- */
multiline_comment|/* Encapsulate one AX.25 frame and stuff into a TTY queue. */
DECL|function|sp_encaps
r_static
r_void
id|sp_encaps
c_func
(paren
r_struct
id|sixpack
op_star
id|sp
comma
r_int
r_char
op_star
id|icp
comma
r_int
id|len
)paren
(brace
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
id|actual
comma
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|sp-&gt;mtu
)paren
(brace
multiline_comment|/* sp-&gt;mtu = AX25_MTU = max. PACLEN = 256 */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: truncating oversized transmit packet!&bslash;n&quot;
comma
id|sp-&gt;dev-&gt;name
)paren
suffix:semicolon
id|sp-&gt;stats.tx_dropped
op_increment
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|sp-&gt;dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|p
op_assign
id|icp
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
OG
l_int|5
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: invalid KISS command -- dropped&bslash;n&quot;
comma
id|sp-&gt;dev-&gt;name
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|sp-&gt;dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|p
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
op_logical_and
(paren
id|len
OG
l_int|2
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: KISS control packet too long -- dropped&bslash;n&quot;
comma
id|sp-&gt;dev-&gt;name
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|sp-&gt;dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|p
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
op_logical_and
(paren
id|len
OL
l_int|15
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: bad AX.25 packet to transmit -- dropped&bslash;n&quot;
comma
id|sp-&gt;dev-&gt;name
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|sp-&gt;dev
)paren
suffix:semicolon
id|sp-&gt;stats.tx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|count
op_assign
id|encode_sixpack
c_func
(paren
id|p
comma
(paren
r_int
r_char
op_star
)paren
id|sp-&gt;xbuff
comma
id|len
comma
id|sp-&gt;tx_delay
)paren
suffix:semicolon
id|sp-&gt;tty-&gt;flags
op_or_assign
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|p
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|1
suffix:colon
id|sp-&gt;tx_delay
op_assign
id|p
(braket
l_int|1
)braket
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|2
suffix:colon
id|sp-&gt;persistance
op_assign
id|p
(braket
l_int|1
)braket
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|3
suffix:colon
id|sp-&gt;slottime
op_assign
id|p
(braket
l_int|1
)braket
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* ignored */
r_return
suffix:semicolon
r_case
l_int|5
suffix:colon
id|sp-&gt;duplex
op_assign
id|p
(braket
l_int|1
)braket
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* in case of fullduplex or DAMA operation, we don&squot;t take care&n;&t;&t;   about the state of the DCD or of any timers, as the determination&n;&t;&t;   of the correct time to send is the job of the AX.25 layer. We send&n;&t;&t;   immediately after data has arrived. */
r_if
c_cond
(paren
id|sp-&gt;duplex
op_eq
l_int|1
)paren
(brace
id|sp-&gt;led_state
op_assign
l_int|0x70
suffix:semicolon
id|sp-&gt;tty-&gt;driver
dot
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|sp-&gt;led_state
comma
l_int|1
)paren
suffix:semicolon
id|sp-&gt;tx_enable
op_assign
l_int|1
suffix:semicolon
id|actual
op_assign
id|sp-&gt;tty-&gt;driver
dot
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
id|sp-&gt;xbuff
comma
id|count
)paren
suffix:semicolon
id|sp-&gt;xleft
op_assign
id|count
op_minus
id|actual
suffix:semicolon
id|sp-&gt;xhead
op_assign
id|sp-&gt;xbuff
op_plus
id|actual
suffix:semicolon
id|sp-&gt;led_state
op_assign
l_int|0x60
suffix:semicolon
id|sp-&gt;tty-&gt;driver
dot
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|sp-&gt;led_state
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|sp-&gt;xleft
op_assign
id|count
suffix:semicolon
id|sp-&gt;xhead
op_assign
id|sp-&gt;xbuff
suffix:semicolon
id|sp-&gt;status2
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;duplex
op_eq
l_int|0
)paren
id|sp_start_tx_timer
c_func
(paren
id|sp
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Called by the TTY driver when there&squot;s room for more data.  If we have&n; * more packets to send, we send them here.&n; */
DECL|function|sixpack_write_wakeup
r_static
r_void
id|sixpack_write_wakeup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
id|actual
suffix:semicolon
r_struct
id|sixpack
op_star
id|sp
op_assign
(paren
r_struct
id|sixpack
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
multiline_comment|/* First make sure we&squot;re connected. */
r_if
c_cond
(paren
op_logical_neg
id|sp
op_logical_or
id|sp-&gt;magic
op_ne
id|SIXPACK_MAGIC
op_logical_or
op_logical_neg
id|netif_running
c_func
(paren
id|sp-&gt;dev
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;xleft
op_le
l_int|0
)paren
(brace
multiline_comment|/* Now serial buffer is almost free &amp; we can start&n;&t;&t; * transmission of another packet */
id|sp-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|tty-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
id|sp-&gt;tx_enable
op_assign
l_int|0
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|sp-&gt;dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sp-&gt;tx_enable
op_eq
l_int|1
)paren
(brace
id|actual
op_assign
id|tty-&gt;driver
dot
id|write
c_func
(paren
id|tty
comma
l_int|0
comma
id|sp-&gt;xhead
comma
id|sp-&gt;xleft
)paren
suffix:semicolon
id|sp-&gt;xleft
op_sub_assign
id|actual
suffix:semicolon
id|sp-&gt;xhead
op_add_assign
id|actual
suffix:semicolon
)brace
)brace
multiline_comment|/* ----------------------------------------------------------------------- */
multiline_comment|/* Encapsulate an IP datagram and kick it into a TTY queue. */
DECL|function|sp_xmit
r_static
r_int
id|sp_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
(paren
r_struct
id|sixpack
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* We were not busy, so we are now... :-) */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sp-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|sp_encaps
c_func
(paren
id|sp
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* perform the persistence/slottime algorithm for CSMA access. If the persistence&n;   check was successful, write the data to the serial driver. Note that in case&n;   of DAMA operation, the data is not sent here. */
DECL|function|sp_xmit_on_air
r_static
r_void
id|sp_xmit_on_air
c_func
(paren
r_int
r_int
id|channel
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
(paren
r_struct
id|sixpack
op_star
)paren
id|channel
suffix:semicolon
r_int
id|actual
suffix:semicolon
r_static
r_int
r_char
id|random
suffix:semicolon
id|random
op_assign
id|random
op_star
l_int|17
op_plus
l_int|41
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|sp-&gt;status1
op_amp
id|SIXP_DCD_MASK
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|random
OL
id|sp-&gt;persistance
)paren
)paren
(brace
id|sp-&gt;led_state
op_assign
l_int|0x70
suffix:semicolon
id|sp-&gt;tty-&gt;driver
dot
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|sp-&gt;led_state
comma
l_int|1
)paren
suffix:semicolon
id|sp-&gt;tx_enable
op_assign
l_int|1
suffix:semicolon
id|actual
op_assign
id|sp-&gt;tty-&gt;driver
dot
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
id|sp-&gt;xbuff
comma
id|sp-&gt;status2
)paren
suffix:semicolon
id|sp-&gt;xleft
op_sub_assign
id|actual
suffix:semicolon
id|sp-&gt;xhead
op_add_assign
id|actual
suffix:semicolon
id|sp-&gt;led_state
op_assign
l_int|0x60
suffix:semicolon
id|sp-&gt;tty-&gt;driver
dot
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|sp-&gt;led_state
comma
l_int|1
)paren
suffix:semicolon
id|sp-&gt;status2
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|sp_start_tx_timer
c_func
(paren
id|sp
)paren
suffix:semicolon
)brace
multiline_comment|/* Return the frame type ID */
DECL|function|sp_header
r_static
r_int
id|sp_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
comma
r_int
r_int
id|type
comma
r_void
op_star
id|daddr
comma
r_void
op_star
id|saddr
comma
r_int
id|len
)paren
(brace
macro_line|#ifdef CONFIG_INET
r_if
c_cond
(paren
id|type
op_ne
id|htons
c_func
(paren
id|ETH_P_AX25
)paren
)paren
r_return
id|ax25_encapsulate
c_func
(paren
id|skb
comma
id|dev
comma
id|type
comma
id|daddr
comma
id|saddr
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sp_rebuild_header
r_static
r_int
id|sp_rebuild_header
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
macro_line|#ifdef CONFIG_INET
r_return
id|ax25_rebuild_header
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#else
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Open the low-level part of the 6pack channel. */
DECL|function|sp_open
r_static
r_int
id|sp_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
(paren
r_struct
id|sixpack
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;tty
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate the 6pack frame buffers:&n;&t; *&n;&t; * rbuff&t;Receive buffer.&n;&t; * xbuff&t;Transmit buffer.&n;&t; */
multiline_comment|/* !!! length of the buffers. MTU is IP MTU, not PACLEN!&n;&t; */
id|len
op_assign
id|dev-&gt;mtu
op_star
l_int|2
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sp-&gt;rbuff
op_assign
id|kmalloc
c_func
(paren
id|len
op_plus
l_int|4
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sp-&gt;xbuff
op_assign
id|kmalloc
c_func
(paren
id|len
op_plus
l_int|4
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|sp-&gt;rbuff
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|sp-&gt;mtu
op_assign
id|AX25_MTU
op_plus
l_int|73
suffix:semicolon
id|sp-&gt;buffsize
op_assign
id|len
suffix:semicolon
id|sp-&gt;rcount
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;rx_count
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;rx_count_cooked
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;xleft
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;flags
op_and_assign
(paren
l_int|1
op_lshift
id|SIXPF_INUSE
)paren
suffix:semicolon
multiline_comment|/* Clear ESCAPE &amp; ERROR flags */
id|sp-&gt;duplex
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;tx_delay
op_assign
id|SIXP_TXDELAY
suffix:semicolon
id|sp-&gt;persistance
op_assign
id|SIXP_PERSIST
suffix:semicolon
id|sp-&gt;slottime
op_assign
id|SIXP_SLOTTIME
suffix:semicolon
id|sp-&gt;led_state
op_assign
l_int|0x60
suffix:semicolon
id|sp-&gt;status
op_assign
l_int|1
suffix:semicolon
id|sp-&gt;status1
op_assign
l_int|1
suffix:semicolon
id|sp-&gt;status2
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;tnc_ok
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;tx_enable
op_assign
l_int|0
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|sp-&gt;tx_t
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|sp-&gt;resync_t
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Close the low-level part of the 6pack channel. */
DECL|function|sp_close
r_static
r_int
id|sp_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
(paren
r_struct
id|sixpack
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;tty
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|sp-&gt;tty-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sixpack_receive_room
r_static
r_int
id|sixpack_receive_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_return
l_int|65536
suffix:semicolon
multiline_comment|/* We can handle an infinite amount of data. :-) */
)brace
multiline_comment|/* !!! receive state machine */
multiline_comment|/*&n; * Handle the &squot;receiver data ready&squot; interrupt.&n; * This function is called by the &squot;tty_io&squot; module in the kernel when&n; * a block of 6pack data has been received, which can now be decapsulated&n; * and sent on to some IP layer for further processing.&n; */
DECL|function|sixpack_receive_buf
r_static
r_void
id|sixpack_receive_buf
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
r_int
r_char
op_star
id|cp
comma
r_char
op_star
id|fp
comma
r_int
id|count
)paren
(brace
r_int
r_char
id|buf
(braket
l_int|512
)braket
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|count1
suffix:semicolon
r_struct
id|sixpack
op_star
id|sp
op_assign
(paren
r_struct
id|sixpack
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sp
op_logical_or
id|sp-&gt;magic
op_ne
id|SIXPACK_MAGIC
op_logical_or
op_logical_neg
id|netif_running
c_func
(paren
id|sp-&gt;dev
)paren
op_logical_or
op_logical_neg
id|count
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
comma
id|cp
comma
id|count
OL
r_sizeof
(paren
id|buf
)paren
ques
c_cond
id|count
suffix:colon
r_sizeof
(paren
id|buf
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Read the characters out of the buffer */
id|count1
op_assign
id|count
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|fp
op_logical_and
op_star
id|fp
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|SIXPF_ERROR
comma
op_amp
id|sp-&gt;flags
)paren
)paren
id|sp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|sixpack_decode
c_func
(paren
id|sp
comma
id|buf
comma
id|count1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Open the high-level part of the 6pack channel.&n; * This function is called by the TTY module when the&n; * 6pack line discipline is called for.  Because we are&n; * sure the tty line exists, we only have to link it to&n; * a free 6pcack channel...&n; */
DECL|function|sixpack_open
r_static
r_int
id|sixpack_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
(paren
r_struct
id|sixpack
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/* First make sure we&squot;re not already connected. */
r_if
c_cond
(paren
id|sp
op_logical_and
id|sp-&gt;magic
op_eq
id|SIXPACK_MAGIC
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
multiline_comment|/* OK.  Find a free 6pack channel to use. */
r_if
c_cond
(paren
(paren
id|sp
op_assign
id|sp_alloc
c_func
(paren
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENFILE
suffix:semicolon
id|sp-&gt;tty
op_assign
id|tty
suffix:semicolon
id|tty-&gt;disc_data
op_assign
id|sp
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
multiline_comment|/* Restore default settings */
id|sp-&gt;dev-&gt;type
op_assign
id|ARPHRD_AX25
suffix:semicolon
multiline_comment|/* Perform the low-level 6pack initialization. */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|sp_open
c_func
(paren
id|sp-&gt;dev
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* Done.  We have linked the TTY line to a channel. */
id|tnc_init
c_func
(paren
id|sp
)paren
suffix:semicolon
r_return
id|sp-&gt;dev-&gt;base_addr
suffix:semicolon
)brace
multiline_comment|/*&n; * Close down a 6pack channel.&n; * This means flushing out any pending queues, and then restoring the&n; * TTY line discipline to what it was before it got hooked to 6pack&n; * (which usually is TTY again).&n; */
DECL|function|sixpack_close
r_static
r_void
id|sixpack_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
(paren
r_struct
id|sixpack
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
multiline_comment|/* First make sure we&squot;re connected. */
r_if
c_cond
(paren
op_logical_neg
id|sp
op_logical_or
id|sp-&gt;magic
op_ne
id|SIXPACK_MAGIC
)paren
r_return
suffix:semicolon
id|rtnl_lock
c_func
(paren
)paren
suffix:semicolon
id|dev_close
c_func
(paren
id|sp-&gt;dev
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sp-&gt;tx_t
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sp-&gt;resync_t
)paren
suffix:semicolon
id|tty-&gt;disc_data
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|sp_free
c_func
(paren
id|sp
)paren
suffix:semicolon
id|unregister_netdevice
c_func
(paren
id|sp-&gt;dev
)paren
suffix:semicolon
id|rtnl_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|sp_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|sp_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
(paren
r_struct
id|sixpack
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|sp-&gt;stats
suffix:semicolon
)brace
DECL|function|sp_set_mac_address
r_static
r_int
id|sp_set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
(brace
r_return
id|copy_from_user
c_func
(paren
id|dev-&gt;dev_addr
comma
id|addr
comma
id|AX25_ADDR_LEN
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|sp_set_dev_mac_address
r_static
r_int
id|sp_set_dev_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
(brace
r_struct
id|sockaddr
op_star
id|sa
op_assign
id|addr
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|sa-&gt;sa_data
comma
id|AX25_ADDR_LEN
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Perform I/O control on an active 6pack channel. */
DECL|function|sixpack_ioctl
r_static
r_int
id|sixpack_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_void
op_star
id|file
comma
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
(paren
r_struct
id|sixpack
op_star
)paren
id|tty-&gt;disc_data
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
multiline_comment|/* First make sure we&squot;re connected. */
r_if
c_cond
(paren
op_logical_neg
id|sp
op_logical_or
id|sp-&gt;magic
op_ne
id|SIXPACK_MAGIC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCGIFNAME
suffix:colon
r_return
id|copy_to_user
c_func
(paren
id|arg
comma
id|sp-&gt;dev-&gt;name
comma
id|strlen
c_func
(paren
id|sp-&gt;dev-&gt;name
)paren
op_plus
l_int|1
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
r_case
id|SIOCGIFENCAP
suffix:colon
r_return
id|put_user
c_func
(paren
l_int|0
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SIOCSIFENCAP
suffix:colon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|tmp
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|sp-&gt;mode
op_assign
id|tmp
suffix:semicolon
id|sp-&gt;dev-&gt;addr_len
op_assign
id|AX25_ADDR_LEN
suffix:semicolon
multiline_comment|/* sizeof an AX.25 addr */
id|sp-&gt;dev-&gt;hard_header_len
op_assign
id|AX25_KISS_HEADER_LEN
op_plus
id|AX25_MAX_HEADER_LEN
op_plus
l_int|3
suffix:semicolon
id|sp-&gt;dev-&gt;type
op_assign
id|ARPHRD_AX25
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSIFHWADDR
suffix:colon
r_return
id|sp_set_mac_address
c_func
(paren
id|sp-&gt;dev
comma
id|arg
)paren
suffix:semicolon
multiline_comment|/* Allow stty to read, but not set, the serial port */
r_case
id|TCGETS
suffix:colon
r_case
id|TCGETA
suffix:colon
r_return
id|n_tty_ioctl
c_func
(paren
id|tty
comma
(paren
r_struct
id|file
op_star
)paren
id|file
comma
id|cmd
comma
(paren
r_int
r_int
)paren
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
)brace
DECL|function|sp_open_dev
r_static
r_int
id|sp_open_dev
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
(paren
r_struct
id|sixpack
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;tty
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Initialize 6pack control device -- register 6pack line discipline */
DECL|function|sixpack_init_driver
r_static
r_int
id|__init
id|sixpack_init_driver
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
id|sixpack_maxdev
OL
l_int|4
)paren
id|sixpack_maxdev
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* Sanity */
id|printk
c_func
(paren
id|banner
comma
id|sixpack_maxdev
)paren
suffix:semicolon
id|sixpack_ctrls
op_assign
(paren
id|sixpack_ctrl_t
op_star
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_void
op_star
)paren
op_star
id|sixpack_maxdev
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sixpack_ctrls
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;6pack: Can&squot;t allocate sixpack_ctrls[] array!  Uaargh! (-&gt; No 6pack available)&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Clear the pointer array, we allocate devices when we need them */
id|memset
c_func
(paren
id|sixpack_ctrls
comma
l_int|0
comma
r_sizeof
(paren
r_void
op_star
)paren
op_star
id|sixpack_maxdev
)paren
suffix:semicolon
multiline_comment|/* Pointers */
multiline_comment|/* Fill in our line protocol discipline, and register it */
id|sp_ldisc.magic
op_assign
id|TTY_LDISC_MAGIC
suffix:semicolon
id|sp_ldisc.name
op_assign
l_string|&quot;6pack&quot;
suffix:semicolon
id|sp_ldisc.flags
op_assign
l_int|0
suffix:semicolon
id|sp_ldisc.open
op_assign
id|sixpack_open
suffix:semicolon
id|sp_ldisc.close
op_assign
id|sixpack_close
suffix:semicolon
id|sp_ldisc.read
op_assign
l_int|NULL
suffix:semicolon
id|sp_ldisc.write
op_assign
l_int|NULL
suffix:semicolon
id|sp_ldisc.ioctl
op_assign
(paren
r_int
(paren
op_star
)paren
(paren
r_struct
id|tty_struct
op_star
comma
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
)paren
id|sixpack_ioctl
suffix:semicolon
id|sp_ldisc.poll
op_assign
l_int|NULL
suffix:semicolon
id|sp_ldisc.receive_buf
op_assign
id|sixpack_receive_buf
suffix:semicolon
id|sp_ldisc.receive_room
op_assign
id|sixpack_receive_room
suffix:semicolon
id|sp_ldisc.write_wakeup
op_assign
id|sixpack_write_wakeup
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|tty_register_ldisc
c_func
(paren
id|N_6PACK
comma
op_amp
id|sp_ldisc
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;6pack: can&squot;t register line discipline (err = %d)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sixpack_ctrls
)paren
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
DECL|function|sixpack_cleanup_driver
r_static
r_void
id|__exit
id|sixpack_cleanup_driver
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sixpack_maxdev
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sixpack_ctrls
(braket
id|i
)braket
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;* VSV = if dev-&gt;start==0, then device&n;&t;&t;&t;* unregistered while close proc.&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|netif_running
c_func
(paren
op_amp
id|sixpack_ctrls
(braket
id|i
)braket
op_member_access_from_pointer
id|dev
)paren
)paren
id|unregister_netdev
c_func
(paren
op_amp
id|sixpack_ctrls
(braket
id|i
)braket
op_member_access_from_pointer
id|dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sixpack_ctrls
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|sixpack_ctrls
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|tty_register_ldisc
c_func
(paren
id|N_6PACK
comma
l_int|NULL
)paren
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;6pack: can&squot;t unregister line discipline (err = %d)&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize the 6pack driver.  Called by DDI. */
DECL|function|sixpack_init
r_static
r_int
id|sixpack_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|sixpack
op_star
id|sp
op_assign
(paren
r_struct
id|sixpack
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_static
r_char
id|ax25_bcast
(braket
id|AX25_ADDR_LEN
)braket
op_assign
(brace
l_char|&squot;Q&squot;
op_lshift
l_int|1
comma
l_char|&squot;S&squot;
op_lshift
l_int|1
comma
l_char|&squot;T&squot;
op_lshift
l_int|1
comma
l_char|&squot; &squot;
op_lshift
l_int|1
comma
l_char|&squot; &squot;
op_lshift
l_int|1
comma
l_char|&squot; &squot;
op_lshift
l_int|1
comma
l_char|&squot;0&squot;
op_lshift
l_int|1
)brace
suffix:semicolon
r_static
r_char
id|ax25_test
(braket
id|AX25_ADDR_LEN
)braket
op_assign
(brace
l_char|&squot;L&squot;
op_lshift
l_int|1
comma
l_char|&squot;I&squot;
op_lshift
l_int|1
comma
l_char|&squot;N&squot;
op_lshift
l_int|1
comma
l_char|&squot;U&squot;
op_lshift
l_int|1
comma
l_char|&squot;X&squot;
op_lshift
l_int|1
comma
l_char|&squot; &squot;
op_lshift
l_int|1
comma
l_char|&squot;1&squot;
op_lshift
l_int|1
)brace
suffix:semicolon
r_if
c_cond
(paren
id|sp
op_eq
l_int|NULL
)paren
multiline_comment|/* Allocation failed ?? */
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* Set up the &quot;6pack Control Block&quot;. (And clear statistics) */
id|memset
c_func
(paren
id|sp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sixpack
)paren
)paren
suffix:semicolon
id|sp-&gt;magic
op_assign
id|SIXPACK_MAGIC
suffix:semicolon
id|sp-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Finish setting up the DEVICE info. */
id|dev-&gt;mtu
op_assign
id|SIXP_MTU
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|sp_xmit
suffix:semicolon
id|dev-&gt;open
op_assign
id|sp_open_dev
suffix:semicolon
id|dev-&gt;stop
op_assign
id|sp_close
suffix:semicolon
id|dev-&gt;hard_header
op_assign
id|sp_header
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|sp_get_stats
suffix:semicolon
id|dev-&gt;set_mac_address
op_assign
id|sp_set_dev_mac_address
suffix:semicolon
id|dev-&gt;hard_header_len
op_assign
id|AX25_MAX_HEADER_LEN
suffix:semicolon
id|dev-&gt;addr_len
op_assign
id|AX25_ADDR_LEN
suffix:semicolon
id|dev-&gt;type
op_assign
id|ARPHRD_AX25
suffix:semicolon
id|dev-&gt;tx_queue_len
op_assign
l_int|10
suffix:semicolon
id|dev-&gt;rebuild_header
op_assign
id|sp_rebuild_header
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
l_int|NULL
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;broadcast
comma
id|ax25_bcast
comma
id|AX25_ADDR_LEN
)paren
suffix:semicolon
multiline_comment|/* Only activated in AX.25 mode */
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|ax25_test
comma
id|AX25_ADDR_LEN
)paren
suffix:semicolon
multiline_comment|/*    &quot;&quot;      &quot;&quot;       &quot;&quot;    &quot;&quot; */
id|dev_init_buffers
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* New-style flags. */
id|dev-&gt;flags
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ----&gt; 6pack timer interrupt handler and friends. &lt;---- */
DECL|function|sp_start_tx_timer
r_static
r_void
id|sp_start_tx_timer
c_func
(paren
r_struct
id|sixpack
op_star
id|sp
)paren
(brace
r_int
id|when
op_assign
id|sp-&gt;slottime
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sp-&gt;tx_t
)paren
suffix:semicolon
id|sp-&gt;tx_t.data
op_assign
(paren
r_int
r_int
)paren
id|sp
suffix:semicolon
id|sp-&gt;tx_t.function
op_assign
id|sp_xmit_on_air
suffix:semicolon
id|sp-&gt;tx_t.expires
op_assign
id|jiffies
op_plus
(paren
(paren
id|when
op_plus
l_int|1
)paren
op_star
id|HZ
)paren
op_div
l_int|100
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sp-&gt;tx_t
)paren
suffix:semicolon
)brace
multiline_comment|/* encode an AX.25 packet into 6pack */
DECL|function|encode_sixpack
r_static
r_int
id|encode_sixpack
c_func
(paren
r_int
r_char
op_star
id|tx_buf
comma
r_int
r_char
op_star
id|tx_buf_raw
comma
r_int
id|length
comma
r_int
r_char
id|tx_delay
)paren
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|checksum
op_assign
l_int|0
comma
id|buf
(braket
l_int|400
)braket
suffix:semicolon
r_int
id|raw_count
op_assign
l_int|0
suffix:semicolon
id|tx_buf_raw
(braket
id|raw_count
op_increment
)braket
op_assign
id|SIXP_PRIO_CMD_MASK
op_or
id|SIXP_TX_MASK
suffix:semicolon
id|tx_buf_raw
(braket
id|raw_count
op_increment
)braket
op_assign
id|SIXP_SEOF
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_assign
id|tx_delay
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|1
suffix:semicolon
id|count
OL
id|length
suffix:semicolon
id|count
op_increment
)paren
id|buf
(braket
id|count
)braket
op_assign
id|tx_buf
(braket
id|count
)braket
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|length
suffix:semicolon
id|count
op_increment
)paren
id|checksum
op_add_assign
id|buf
(braket
id|count
)braket
suffix:semicolon
id|buf
(braket
id|length
)braket
op_assign
(paren
r_int
r_char
)paren
l_int|0xff
op_minus
id|checksum
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
op_le
id|length
suffix:semicolon
id|count
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|count
op_mod
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
id|tx_buf_raw
(braket
id|raw_count
op_increment
)braket
op_assign
(paren
id|buf
(braket
id|count
)braket
op_amp
l_int|0x3f
)paren
suffix:semicolon
id|tx_buf_raw
(braket
id|raw_count
)braket
op_assign
(paren
(paren
id|buf
(braket
id|count
)braket
op_rshift
l_int|2
)paren
op_amp
l_int|0x30
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|count
op_mod
l_int|3
)paren
op_eq
l_int|1
)paren
(brace
id|tx_buf_raw
(braket
id|raw_count
op_increment
)braket
op_or_assign
(paren
id|buf
(braket
id|count
)braket
op_amp
l_int|0x0f
)paren
suffix:semicolon
id|tx_buf_raw
(braket
id|raw_count
)braket
op_assign
(paren
(paren
id|buf
(braket
id|count
)braket
op_rshift
l_int|2
)paren
op_amp
l_int|0x3c
)paren
suffix:semicolon
)brace
r_else
(brace
id|tx_buf_raw
(braket
id|raw_count
op_increment
)braket
op_or_assign
(paren
id|buf
(braket
id|count
)braket
op_amp
l_int|0x03
)paren
suffix:semicolon
id|tx_buf_raw
(braket
id|raw_count
op_increment
)braket
op_assign
(paren
id|buf
(braket
id|count
)braket
op_rshift
l_int|2
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|length
op_mod
l_int|3
)paren
op_ne
l_int|2
)paren
id|raw_count
op_increment
suffix:semicolon
id|tx_buf_raw
(braket
id|raw_count
op_increment
)braket
op_assign
id|SIXP_SEOF
suffix:semicolon
r_return
id|raw_count
suffix:semicolon
)brace
multiline_comment|/* decode a 6pack packet */
r_static
r_void
DECL|function|sixpack_decode
id|sixpack_decode
c_func
(paren
r_struct
id|sixpack
op_star
id|sp
comma
r_int
r_char
id|pre_rbuff
(braket
)braket
comma
r_int
id|count
)paren
(brace
r_int
r_char
id|inbyte
suffix:semicolon
r_int
id|count1
suffix:semicolon
r_for
c_loop
(paren
id|count1
op_assign
l_int|0
suffix:semicolon
id|count1
OL
id|count
suffix:semicolon
id|count1
op_increment
)paren
(brace
id|inbyte
op_assign
id|pre_rbuff
(braket
id|count1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|inbyte
op_eq
id|SIXP_FOUND_TNC
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;6pack: TNC found.&bslash;n&quot;
)paren
suffix:semicolon
id|sp-&gt;tnc_ok
op_assign
l_int|1
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sp-&gt;resync_t
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|inbyte
op_amp
id|SIXP_PRIO_CMD_MASK
)paren
op_ne
l_int|0
)paren
id|decode_prio_command
c_func
(paren
id|inbyte
comma
id|sp
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|inbyte
op_amp
id|SIXP_STD_CMD_MASK
)paren
op_ne
l_int|0
)paren
id|decode_std_command
c_func
(paren
id|inbyte
comma
id|sp
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|sp-&gt;status
op_amp
id|SIXP_RX_DCD_MASK
)paren
op_eq
id|SIXP_RX_DCD_MASK
)paren
id|decode_data
c_func
(paren
id|inbyte
comma
id|sp
)paren
suffix:semicolon
)brace
)brace
DECL|function|tnc_init
r_static
r_int
id|tnc_init
c_func
(paren
r_struct
id|sixpack
op_star
id|sp
)paren
(brace
r_int
r_char
id|inbyte
op_assign
l_int|0xe8
suffix:semicolon
id|sp-&gt;tty-&gt;driver
dot
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|inbyte
comma
l_int|1
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sp-&gt;resync_t
)paren
suffix:semicolon
id|sp-&gt;resync_t.data
op_assign
(paren
r_int
r_int
)paren
id|sp
suffix:semicolon
id|sp-&gt;resync_t.function
op_assign
id|resync_tnc
suffix:semicolon
id|sp-&gt;resync_t.expires
op_assign
id|jiffies
op_plus
id|SIXP_RESYNC_TIMEOUT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sp-&gt;resync_t
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* identify and execute a 6pack priority command byte */
DECL|function|decode_prio_command
r_static
r_void
id|decode_prio_command
c_func
(paren
r_int
r_char
id|cmd
comma
r_struct
id|sixpack
op_star
id|sp
)paren
(brace
r_int
r_char
id|channel
suffix:semicolon
r_int
id|actual
suffix:semicolon
id|channel
op_assign
id|cmd
op_amp
id|SIXP_CHN_MASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_amp
id|SIXP_PRIO_DATA_MASK
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* idle ? */
multiline_comment|/* RX and DCD flags can only be set in the same prio command,&n;&t;   if the DCD flag has been set without the RX flag in the previous&n;&t;   prio command. If DCD has not been set before, something in the&n;&t;   transmission has gone wrong. In this case, RX and DCD are&n;&t;   cleared in order to prevent the decode_data routine from&n;&t;   reading further data that might be corrupt. */
r_if
c_cond
(paren
(paren
(paren
id|sp-&gt;status
op_amp
id|SIXP_DCD_MASK
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|cmd
op_amp
id|SIXP_RX_DCD_MASK
)paren
op_eq
id|SIXP_RX_DCD_MASK
)paren
)paren
(brace
r_if
c_cond
(paren
id|sp-&gt;status
op_ne
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;6pack: protocol violation&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|sp-&gt;status
op_assign
l_int|0
suffix:semicolon
id|cmd
op_and_assign
op_logical_neg
id|SIXP_RX_DCD_MASK
suffix:semicolon
)brace
id|sp-&gt;status
op_assign
id|cmd
op_amp
id|SIXP_PRIO_DATA_MASK
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* output watchdog char if idle */
r_if
c_cond
(paren
(paren
id|sp-&gt;status2
op_ne
l_int|0
)paren
op_logical_and
(paren
id|sp-&gt;duplex
op_eq
l_int|1
)paren
)paren
(brace
id|sp-&gt;led_state
op_assign
l_int|0x70
suffix:semicolon
id|sp-&gt;tty-&gt;driver
dot
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|sp-&gt;led_state
comma
l_int|1
)paren
suffix:semicolon
id|sp-&gt;tx_enable
op_assign
l_int|1
suffix:semicolon
id|actual
op_assign
id|sp-&gt;tty-&gt;driver
dot
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
id|sp-&gt;xbuff
comma
id|sp-&gt;status2
)paren
suffix:semicolon
id|sp-&gt;xleft
op_sub_assign
id|actual
suffix:semicolon
id|sp-&gt;xhead
op_add_assign
id|actual
suffix:semicolon
id|sp-&gt;led_state
op_assign
l_int|0x60
suffix:semicolon
id|sp-&gt;status2
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* needed to trigger the TNC watchdog */
id|sp-&gt;tty-&gt;driver
dot
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|sp-&gt;led_state
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* if the state byte has been received, the TNC is present,&n;           so the resync timer can be reset. */
r_if
c_cond
(paren
id|sp-&gt;tnc_ok
op_eq
l_int|1
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|sp-&gt;resync_t
)paren
suffix:semicolon
id|sp-&gt;resync_t.data
op_assign
(paren
r_int
r_int
)paren
id|sp
suffix:semicolon
id|sp-&gt;resync_t.function
op_assign
id|resync_tnc
suffix:semicolon
id|sp-&gt;resync_t.expires
op_assign
id|jiffies
op_plus
id|SIXP_INIT_RESYNC_TIMEOUT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sp-&gt;resync_t
)paren
suffix:semicolon
)brace
id|sp-&gt;status1
op_assign
id|cmd
op_amp
id|SIXP_PRIO_DATA_MASK
suffix:semicolon
)brace
multiline_comment|/* try to resync the TNC. Called by the resync timer defined in&n;  decode_prio_command */
DECL|function|resync_tnc
r_static
r_void
id|resync_tnc
c_func
(paren
r_int
r_int
id|channel
)paren
(brace
r_static
r_char
id|resync_cmd
op_assign
l_int|0xe8
suffix:semicolon
r_struct
id|sixpack
op_star
id|sp
op_assign
(paren
r_struct
id|sixpack
op_star
)paren
id|channel
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;6pack: resyncing TNC&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* clear any data that might have been received */
id|sp-&gt;rx_count
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;rx_count_cooked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reset state machine */
id|sp-&gt;status
op_assign
l_int|1
suffix:semicolon
id|sp-&gt;status1
op_assign
l_int|1
suffix:semicolon
id|sp-&gt;status2
op_assign
l_int|0
suffix:semicolon
id|sp-&gt;tnc_ok
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* resync the TNC */
id|sp-&gt;led_state
op_assign
l_int|0x60
suffix:semicolon
id|sp-&gt;tty-&gt;driver
dot
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|sp-&gt;led_state
comma
l_int|1
)paren
suffix:semicolon
id|sp-&gt;tty-&gt;driver
dot
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|resync_cmd
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Start resync timer again -- the TNC might be still absent */
id|del_timer
c_func
(paren
op_amp
id|sp-&gt;resync_t
)paren
suffix:semicolon
id|sp-&gt;resync_t.data
op_assign
(paren
r_int
r_int
)paren
id|sp
suffix:semicolon
id|sp-&gt;resync_t.function
op_assign
id|resync_tnc
suffix:semicolon
id|sp-&gt;resync_t.expires
op_assign
id|jiffies
op_plus
id|SIXP_RESYNC_TIMEOUT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sp-&gt;resync_t
)paren
suffix:semicolon
)brace
multiline_comment|/* identify and execute a standard 6pack command byte */
DECL|function|decode_std_command
r_static
r_void
id|decode_std_command
c_func
(paren
r_int
r_char
id|cmd
comma
r_struct
id|sixpack
op_star
id|sp
)paren
(brace
r_int
r_char
id|checksum
op_assign
l_int|0
comma
id|rest
op_assign
l_int|0
comma
id|channel
suffix:semicolon
r_int
id|i
suffix:semicolon
id|channel
op_assign
id|cmd
op_amp
id|SIXP_CHN_MASK
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
op_amp
id|SIXP_CMD_MASK
)paren
(brace
multiline_comment|/* normal command */
r_case
id|SIXP_SEOF
suffix:colon
r_if
c_cond
(paren
(paren
id|sp-&gt;rx_count
op_eq
l_int|0
)paren
op_logical_and
(paren
id|sp-&gt;rx_count_cooked
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|sp-&gt;status
op_amp
id|SIXP_RX_DCD_MASK
)paren
op_eq
id|SIXP_RX_DCD_MASK
)paren
(brace
id|sp-&gt;led_state
op_assign
l_int|0x68
suffix:semicolon
id|sp-&gt;tty-&gt;driver
dot
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|sp-&gt;led_state
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|sp-&gt;led_state
op_assign
l_int|0x60
suffix:semicolon
multiline_comment|/* fill trailing bytes with zeroes */
id|sp-&gt;tty-&gt;driver
dot
id|write
c_func
(paren
id|sp-&gt;tty
comma
l_int|0
comma
op_amp
id|sp-&gt;led_state
comma
l_int|1
)paren
suffix:semicolon
id|rest
op_assign
id|sp-&gt;rx_count
suffix:semicolon
r_if
c_cond
(paren
id|rest
op_ne
l_int|0
)paren
r_for
c_loop
(paren
id|i
op_assign
id|rest
suffix:semicolon
id|i
op_le
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|decode_data
c_func
(paren
l_int|0
comma
id|sp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rest
op_eq
l_int|2
)paren
id|sp-&gt;rx_count_cooked
op_sub_assign
l_int|2
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rest
op_eq
l_int|3
)paren
id|sp-&gt;rx_count_cooked
op_sub_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sp-&gt;rx_count_cooked
suffix:semicolon
id|i
op_increment
)paren
id|checksum
op_add_assign
id|sp-&gt;cooked_buf
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|checksum
op_ne
id|SIXP_CHKSUM
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;6pack: bad checksum %2.2x&bslash;n&quot;
comma
id|checksum
)paren
suffix:semicolon
)brace
r_else
(brace
id|sp-&gt;rcount
op_assign
id|sp-&gt;rx_count_cooked
op_minus
l_int|2
suffix:semicolon
id|sp_bump
c_func
(paren
id|sp
comma
l_int|0
)paren
suffix:semicolon
)brace
id|sp-&gt;rx_count_cooked
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SIXP_TX_URUN
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;6pack: TX underrun&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIXP_RX_ORUN
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;6pack: RX overrun&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIXP_RX_BUF_OVL
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;6pack: RX buffer overflow&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* decode 4 sixpack-encoded bytes into 3 data bytes */
DECL|function|decode_data
r_static
r_void
id|decode_data
c_func
(paren
r_int
r_char
id|inbyte
comma
r_struct
id|sixpack
op_star
id|sp
)paren
(brace
r_int
r_char
op_star
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|sp-&gt;rx_count
op_ne
l_int|3
)paren
id|sp-&gt;raw_buf
(braket
id|sp-&gt;rx_count
op_increment
)braket
op_assign
id|inbyte
suffix:semicolon
r_else
(brace
id|buf
op_assign
id|sp-&gt;raw_buf
suffix:semicolon
id|sp-&gt;cooked_buf
(braket
id|sp-&gt;rx_count_cooked
op_increment
)braket
op_assign
id|buf
(braket
l_int|0
)braket
op_or
(paren
(paren
id|buf
(braket
l_int|1
)braket
op_lshift
l_int|2
)paren
op_amp
l_int|0xc0
)paren
suffix:semicolon
id|sp-&gt;cooked_buf
(braket
id|sp-&gt;rx_count_cooked
op_increment
)braket
op_assign
(paren
id|buf
(braket
l_int|1
)braket
op_amp
l_int|0x0f
)paren
op_or
(paren
(paren
id|buf
(braket
l_int|2
)braket
op_lshift
l_int|2
)paren
op_amp
l_int|0xf0
)paren
suffix:semicolon
id|sp-&gt;cooked_buf
(braket
id|sp-&gt;rx_count_cooked
op_increment
)braket
op_assign
(paren
id|buf
(braket
l_int|2
)braket
op_amp
l_int|0x03
)paren
op_or
(paren
id|inbyte
op_lshift
l_int|2
)paren
suffix:semicolon
id|sp-&gt;rx_count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Andreas K&#xfffd;nsgen &lt;ajk@ccac.rwth-aachen.de&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;6pack driver for AX.25&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|sixpack_maxdev
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|sixpack_maxdev
comma
l_string|&quot;number of 6PACK devices&quot;
)paren
suffix:semicolon
DECL|variable|sixpack_init_driver
id|module_init
c_func
(paren
id|sixpack_init_driver
)paren
suffix:semicolon
DECL|variable|sixpack_cleanup_driver
id|module_exit
c_func
(paren
id|sixpack_cleanup_driver
)paren
suffix:semicolon
eof
