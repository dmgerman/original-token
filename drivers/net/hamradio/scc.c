DECL|macro|RCS_ID
mdefine_line|#define RCS_ID &quot;$Id: scc.c,v 1.75 1998/11/04 15:15:01 jreuter Exp jreuter $&quot;
DECL|macro|VERSION
mdefine_line|#define VERSION &quot;3.0&quot;
multiline_comment|/*&n; * Please use z8530drv-utils-3.0 with this version.&n; *            ------------------&n; *&n; * You can find a subset of the documentation in &n; * linux/Documentation/networking/z8530drv.txt.&n; */
multiline_comment|/*&n;   ********************************************************************&n;   *   SCC.C - Linux driver for Z8530 based HDLC cards for AX.25      *&n;   ********************************************************************&n;&n;&n;   ********************************************************************&n;&n;&t;Copyright (c) 1993, 2000 Joerg Reuter DL1BKE&n;&n;&t;portions (c) 1993 Guido ten Dolle PE1NNZ&n;&n;   ********************************************************************&n;   &n;   The driver and the programs in the archive are UNDER CONSTRUCTION.&n;   The code is likely to fail, and so your kernel could --- even &n;   a whole network. &n;&n;   This driver is intended for Amateur Radio use. If you are running it&n;   for commercial purposes, please drop me a note. I am nosy...&n;&n;   ...BUT:&n; &n;   ! You  m u s t  recognize the appropriate legislations of your country !&n;   ! before you connect a radio to the SCC board and start to transmit or !&n;   ! receive. The GPL allows you to use the  d r i v e r,  NOT the RADIO! !&n;&n;   For non-Amateur-Radio use please note that you might need a special&n;   allowance/licence from the designer of the SCC Board and/or the&n;   MODEM. &n;&n;   This program is free software; you can redistribute it and/or modify &n;   it under the terms of the (modified) GNU General Public License &n;   delivered with the Linux kernel source.&n;   &n;   This program is distributed in the hope that it will be useful,&n;   but WITHOUT ANY WARRANTY; without even the implied warranty of&n;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;   GNU General Public License for more details.&n;&n;   You should find a copy of the GNU General Public License in &n;   /usr/src/linux/COPYING; &n;   &n;   ******************************************************************** &n;&n;&t;&t;&n;   Incomplete history of z8530drv:&n;   -------------------------------&n;&n;   1994-09-13&t;started to write the driver, rescued most of my own&n;&t;&t;code (and Hans Alblas&squot; memory buffer pool concept) from &n;&t;&t;an earlier project &quot;sccdrv&quot; which was initiated by &n;&t;&t;Guido ten Dolle. Not much of the old driver survived, &n;&t;&t;though. The first version I put my hands on was sccdrv1.3&n;&t;&t;from August 1993. The memory buffer pool concept&n;&t;&t;appeared in an unauthorized sccdrv version (1.5) from&n;&t;&t;August 1994.&n;&n;   1995-01-31&t;changed copyright notice to GPL without limitations.&n;   &n;     .&n;     .&t;&lt;SNIP&gt;&n;     .&n;   &t;&t;  &n;   1996-10-05&t;New semester, new driver... &n;&n;   &t;&t;  * KISS TNC emulator removed (TTY driver)&n;   &t;&t;  * Source moved to drivers/net/&n;   &t;&t;  * Includes Z8530 defines from drivers/net/z8530.h&n;   &t;&t;  * Uses sk_buffer memory management&n;   &t;&t;  * Reduced overhead of /proc/net/z8530drv output&n;   &t;&t;  * Streamlined quite a lot things&n;   &t;&t;  * Invents brand new bugs... ;-)&n;&n;   &t;&t;  The move to version number 3.0 reflects theses changes.&n;   &t;&t;  You can use &squot;kissbridge&squot; if you need a KISS TNC emulator.&n;&n;   1996-12-13&t;Fixed for Linux networking changes. (G4KLX)&n;   1997-01-08&t;Fixed the remaining problems.&n;   1997-04-02&t;Hopefully fixed the problems with the new *_timer()&n;   &t;&t;routines, added calibration code.&n;   1997-10-12&t;Made SCC_DELAY a CONFIG option, added CONFIG_SCC_TRXECHO&n;   1998-01-29&t;Small fix to avoid lock-up on initialization&n;   1998-09-29&t;Fixed the &quot;grouping&quot; bugs, tx_inhibit works again,&n;   &t;&t;using dev-&gt;tx_queue_len now instead of MAXQUEUE now.&n;   1998-10-21&t;Postponed the spinlock changes, would need a lot of&n;   &t;&t;testing I currently don&squot;t have the time to. Softdcd doesn&squot;t&n;   &t;&t;work.&n;   1998-11-04&t;Softdcd does not work correctly in DPLL mode, in fact it &n;   &t;&t;never did. The DPLL locks on noise, the SYNC unit sees&n;   &t;&t;flags that aren&squot;t... Restarting the DPLL does not help&n;   &t;&t;either, it resynchronizes too slow and the first received&n;   &t;&t;frame gets lost.&n;   2000-02-13&t;Fixed for new network driver interface changes, still&n;   &t;&t;does TX timeouts itself since it uses its own queue&n;   &t;&t;scheme.&n;&n;   Thanks to all who contributed to this driver with ideas and bug&n;   reports!&n;   &n;   NB -- if you find errors, change something, please let me know&n;      &t; first before you distribute it... And please don&squot;t touch&n;   &t; the version number. Just replace my callsign in&n;   &t; &quot;v3.0.dl1bke&quot; with your own. Just to avoid confusion...&n;&n;   If you want to add your modification to the linux distribution&n;   please (!) contact me first.&n;   &n;   New versions of the driver will be announced on the linux-hams&n;   mailing list on vger.kernel.org. To subscribe send an e-mail&n;   to majordomo@vger.kernel.org with the following line in&n;   the body of the mail:&n;   &n;&t;   subscribe linux-hams&n;&t;   &n;   The content of the &quot;Subject&quot; field will be ignored.&n;&n;   vy 73,&n;   Joerg Reuter&t;ampr-net: dl1bke@db0pra.ampr.org&n;&t;&t;AX-25   : DL1BKE @ DB0ABH.#BAY.DEU.EU&n;&t;&t;Internet: jreuter@yaina.de&n;&t;&t;www     : http://yaina.de/jreuter&n;*/
multiline_comment|/* ----------------------------------------------------------------------- */
DECL|macro|SCC_LDELAY
macro_line|#undef  SCC_LDELAY&t;1&t;/* slow it even a bit more down */
DECL|macro|SCC_DONT_CHECK
macro_line|#undef  SCC_DONT_CHECK&t;&t;/* don&squot;t look if the SCCs you specified are available */
DECL|macro|SCC_MAXCHIPS
mdefine_line|#define SCC_MAXCHIPS&t;4       /* number of max. supported chips */
DECL|macro|SCC_BUFSIZE
mdefine_line|#define SCC_BUFSIZE&t;384     /* must not exceed 4096 */
DECL|macro|SCC_DEBUG
macro_line|#undef&t;SCC_DEBUG
DECL|macro|SCC_DEFAULT_CLOCK
mdefine_line|#define SCC_DEFAULT_CLOCK&t;4915200 
multiline_comment|/* default pclock if nothing is specified */
multiline_comment|/* ----------------------------------------------------------------------- */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/if_ether.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/scc.h&gt;
macro_line|#include &quot;z8530.h&quot;
macro_line|#include &lt;net/ax25.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
DECL|variable|__initdata
r_static
r_const
r_char
id|banner
(braket
)braket
id|__initdata
op_assign
id|KERN_INFO
l_string|&quot;AX.25: Z8530 SCC driver version &quot;
id|VERSION
l_string|&quot;.dl1bke&bslash;n&quot;
suffix:semicolon
r_static
r_void
id|t_dwait
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|t_txdelay
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|t_tail
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|t_busy
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|t_maxkeyup
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|t_idle
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|scc_tx_done
c_func
(paren
r_struct
id|scc_channel
op_star
)paren
suffix:semicolon
r_static
r_void
id|scc_start_tx_timer
c_func
(paren
r_struct
id|scc_channel
op_star
comma
r_void
(paren
op_star
)paren
(paren
r_int
r_int
)paren
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|scc_start_maxkeyup
c_func
(paren
r_struct
id|scc_channel
op_star
)paren
suffix:semicolon
r_static
r_void
id|scc_start_defer
c_func
(paren
r_struct
id|scc_channel
op_star
)paren
suffix:semicolon
r_static
r_void
id|z8530_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|init_channel
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
suffix:semicolon
r_static
r_void
id|scc_key_trx
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_char
id|tx
)paren
suffix:semicolon
r_static
r_void
id|scc_isr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|scc_init_timer
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
suffix:semicolon
r_static
r_int
id|scc_net_setup
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_int
r_char
op_star
id|name
comma
r_int
id|addev
)paren
suffix:semicolon
r_static
r_int
id|scc_net_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|scc_net_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|scc_net_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|scc_net_rx
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_static
r_int
id|scc_net_tx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|scc_net_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_int
id|scc_net_set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|scc_net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
DECL|variable|SCC_DriverName
r_static
r_int
r_char
op_star
id|SCC_DriverName
op_assign
l_string|&quot;scc&quot;
suffix:semicolon
DECL|struct|irqflags
DECL|member|used
DECL|variable|Ivec
r_static
r_struct
id|irqflags
(brace
r_int
r_char
id|used
suffix:colon
l_int|1
suffix:semicolon
)brace
id|Ivec
(braket
l_int|16
)braket
suffix:semicolon
DECL|variable|SCC_Info
r_static
r_struct
id|scc_channel
id|SCC_Info
(braket
l_int|2
op_star
id|SCC_MAXCHIPS
)braket
suffix:semicolon
multiline_comment|/* information per channel */
DECL|struct|scc_ctrl
r_static
r_struct
id|scc_ctrl
(brace
DECL|member|chan_A
id|io_port
id|chan_A
suffix:semicolon
DECL|member|chan_B
id|io_port
id|chan_B
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|variable|SCC_ctrl
)brace
id|SCC_ctrl
(braket
id|SCC_MAXCHIPS
op_plus
l_int|1
)braket
suffix:semicolon
DECL|variable|Driver_Initialized
r_static
r_int
r_char
id|Driver_Initialized
suffix:semicolon
DECL|variable|Nchips
r_static
r_int
id|Nchips
suffix:semicolon
DECL|variable|Vector_Latch
r_static
id|io_port
id|Vector_Latch
suffix:semicolon
multiline_comment|/* ******************************************************************** */
multiline_comment|/* *&t;&t;&t;Port Access Functions&t;&t;&t;      * */
multiline_comment|/* ******************************************************************** */
multiline_comment|/* These provide interrupt save 2-step access to the Z8530 registers */
DECL|function|InReg
r_static
r_inline
r_int
r_char
id|InReg
c_func
(paren
id|io_port
id|port
comma
r_int
r_char
id|reg
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|r
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef SCC_LDELAY
id|Outb
c_func
(paren
id|port
comma
id|reg
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|SCC_LDELAY
)paren
suffix:semicolon
id|r
op_assign
id|Inb
c_func
(paren
id|port
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|SCC_LDELAY
)paren
suffix:semicolon
macro_line|#else
id|Outb
c_func
(paren
id|port
comma
id|reg
)paren
suffix:semicolon
id|r
op_assign
id|Inb
c_func
(paren
id|port
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|function|OutReg
r_static
r_inline
r_void
id|OutReg
c_func
(paren
id|io_port
id|port
comma
r_int
r_char
id|reg
comma
r_int
r_char
id|val
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef SCC_LDELAY
id|Outb
c_func
(paren
id|port
comma
id|reg
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|SCC_LDELAY
)paren
suffix:semicolon
id|Outb
c_func
(paren
id|port
comma
id|val
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|SCC_LDELAY
)paren
suffix:semicolon
macro_line|#else
id|Outb
c_func
(paren
id|port
comma
id|reg
)paren
suffix:semicolon
id|Outb
c_func
(paren
id|port
comma
id|val
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|wr
r_static
r_inline
r_void
id|wr
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_int
r_char
id|reg
comma
r_int
r_char
id|val
)paren
(brace
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|reg
comma
(paren
id|scc-&gt;wreg
(braket
id|reg
)braket
op_assign
id|val
)paren
)paren
suffix:semicolon
)brace
DECL|function|or
r_static
r_inline
r_void
op_logical_or
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_int
r_char
id|reg
comma
r_int
r_char
id|val
)paren
(brace
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|reg
comma
(paren
id|scc-&gt;wreg
(braket
id|reg
)braket
op_or_assign
id|val
)paren
)paren
suffix:semicolon
)brace
DECL|function|cl
r_static
r_inline
r_void
id|cl
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_int
r_char
id|reg
comma
r_int
r_char
id|val
)paren
(brace
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|reg
comma
(paren
id|scc-&gt;wreg
(braket
id|reg
)braket
op_and_assign
op_complement
id|val
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* ******************************************************************** */
multiline_comment|/* *&t;&t;&t;Some useful macros&t;&t;&t;      * */
multiline_comment|/* ******************************************************************** */
DECL|function|scc_discard_buffers
r_static
r_inline
r_void
id|scc_discard_buffers
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;tx_buff
op_ne
l_int|NULL
)paren
(brace
id|dev_kfree_skb
c_func
(paren
id|scc-&gt;tx_buff
)paren
suffix:semicolon
id|scc-&gt;tx_buff
op_assign
l_int|NULL
suffix:semicolon
)brace
r_while
c_loop
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|scc-&gt;tx_queue
)paren
)paren
id|dev_kfree_skb
c_func
(paren
id|skb_dequeue
c_func
(paren
op_amp
id|scc-&gt;tx_queue
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* ******************************************************************** */
multiline_comment|/* *&t;&t;&t;Interrupt Service Routines&t;&t;      * */
multiline_comment|/* ******************************************************************** */
multiline_comment|/* ----&gt; subroutines for the interrupt handlers &lt;---- */
DECL|function|scc_notify
r_static
r_inline
r_void
id|scc_notify
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_int
id|event
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_char
op_star
id|bp
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;kiss.fulldup
op_ne
id|KISS_DUPLEX_OPTIMA
)paren
r_return
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
(brace
id|bp
op_assign
id|skb_put
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
op_star
id|bp
op_increment
op_assign
id|PARAM_HWEVENT
suffix:semicolon
op_star
id|bp
op_increment
op_assign
id|event
suffix:semicolon
id|scc_net_rx
c_func
(paren
id|scc
comma
id|skb
)paren
suffix:semicolon
)brace
r_else
id|scc-&gt;stat.nospace
op_increment
suffix:semicolon
)brace
DECL|function|flush_rx_FIFO
r_static
r_inline
r_void
id|flush_rx_FIFO
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_int
id|k
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|3
suffix:semicolon
id|k
op_increment
)paren
id|Inb
c_func
(paren
id|scc-&gt;data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;rx_buff
op_ne
l_int|NULL
)paren
multiline_comment|/* did we receive something? */
(brace
id|scc-&gt;stat.rxerrs
op_increment
suffix:semicolon
multiline_comment|/* then count it as an error */
id|dev_kfree_skb_irq
c_func
(paren
id|scc-&gt;rx_buff
)paren
suffix:semicolon
id|scc-&gt;rx_buff
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|start_hunt
r_static
r_void
id|start_hunt
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_if
c_cond
(paren
(paren
id|scc-&gt;modem.clocksrc
op_ne
id|CLK_EXTERNAL
)paren
)paren
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R14
comma
id|SEARCH
op_or
id|scc-&gt;wreg
(braket
id|R14
)braket
)paren
suffix:semicolon
multiline_comment|/* DPLL: enter search mode */
op_logical_or
(paren
id|scc
comma
id|R3
comma
id|ENT_HM
op_or
id|RxENABLE
)paren
suffix:semicolon
multiline_comment|/* enable the receiver, hunt mode */
)brace
multiline_comment|/* ----&gt; four different interrupt handlers for Tx, Rx, changing of&t;*/
multiline_comment|/*       DCD/CTS and Rx/Tx errors&t;&t;&t;&t;&t;*/
multiline_comment|/* Transmitter interrupt handler */
DECL|function|scc_txint
r_static
r_inline
r_void
id|scc_txint
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|scc-&gt;stat.txints
op_increment
suffix:semicolon
id|skb
op_assign
id|scc-&gt;tx_buff
suffix:semicolon
multiline_comment|/* send first octet */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|skb
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|scc-&gt;tx_queue
)paren
suffix:semicolon
id|scc-&gt;tx_buff
op_assign
id|skb
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|scc-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|scc_tx_done
c_func
(paren
id|scc
)paren
suffix:semicolon
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_Tx_P
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;len
op_eq
l_int|0
)paren
multiline_comment|/* Paranoia... */
(brace
id|dev_kfree_skb_irq
c_func
(paren
id|skb
)paren
suffix:semicolon
id|scc-&gt;tx_buff
op_assign
l_int|NULL
suffix:semicolon
id|scc_tx_done
c_func
(paren
id|scc
)paren
suffix:semicolon
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_Tx_P
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|scc-&gt;stat.tx_state
op_assign
id|TXS_ACTIVE
suffix:semicolon
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R0
comma
id|RES_Tx_CRC
)paren
suffix:semicolon
multiline_comment|/* reset CRC generator */
op_logical_or
(paren
id|scc
comma
id|R10
comma
id|ABUNDER
)paren
suffix:semicolon
multiline_comment|/* re-install underrun protection */
id|Outb
c_func
(paren
id|scc-&gt;data
comma
op_star
id|skb-&gt;data
)paren
suffix:semicolon
multiline_comment|/* send byte */
id|skb_pull
c_func
(paren
id|skb
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scc-&gt;enhanced
)paren
multiline_comment|/* reset EOM latch */
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_EOM_L
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* End Of Frame... */
r_if
c_cond
(paren
id|skb-&gt;len
op_eq
l_int|0
)paren
(brace
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_Tx_P
)paren
suffix:semicolon
multiline_comment|/* reset pending int */
id|cl
c_func
(paren
id|scc
comma
id|R10
comma
id|ABUNDER
)paren
suffix:semicolon
multiline_comment|/* send CRC */
id|dev_kfree_skb_irq
c_func
(paren
id|skb
)paren
suffix:semicolon
id|scc-&gt;tx_buff
op_assign
l_int|NULL
suffix:semicolon
id|scc-&gt;stat.tx_state
op_assign
id|TXS_NEWFRAME
suffix:semicolon
multiline_comment|/* next frame... */
r_return
suffix:semicolon
)brace
multiline_comment|/* send octet */
id|Outb
c_func
(paren
id|scc-&gt;data
comma
op_star
id|skb-&gt;data
)paren
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* External/Status interrupt handler */
DECL|function|scc_exint
r_static
r_inline
r_void
id|scc_exint
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_int
r_char
id|status
comma
id|changes
comma
id|chg_and_stat
suffix:semicolon
id|scc-&gt;stat.exints
op_increment
suffix:semicolon
id|status
op_assign
id|InReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R0
)paren
suffix:semicolon
id|changes
op_assign
id|status
op_xor
id|scc-&gt;status
suffix:semicolon
id|chg_and_stat
op_assign
id|changes
op_amp
id|status
suffix:semicolon
multiline_comment|/* ABORT: generated whenever DCD drops while receiving */
r_if
c_cond
(paren
id|chg_and_stat
op_amp
id|BRK_ABRT
)paren
multiline_comment|/* Received an ABORT */
id|flush_rx_FIFO
c_func
(paren
id|scc
)paren
suffix:semicolon
multiline_comment|/* HUNT: software DCD; on = waiting for SYNC, off = receiving frame */
r_if
c_cond
(paren
(paren
id|changes
op_amp
id|SYNC_HUNT
)paren
op_logical_and
id|scc-&gt;kiss.softdcd
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
id|SYNC_HUNT
)paren
(brace
id|scc-&gt;dcd
op_assign
l_int|0
suffix:semicolon
id|flush_rx_FIFO
c_func
(paren
id|scc
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scc-&gt;modem.clocksrc
op_ne
id|CLK_EXTERNAL
)paren
)paren
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R14
comma
id|SEARCH
op_or
id|scc-&gt;wreg
(braket
id|R14
)braket
)paren
suffix:semicolon
multiline_comment|/* DPLL: enter search mode */
)brace
r_else
(brace
id|scc-&gt;dcd
op_assign
l_int|1
suffix:semicolon
)brace
id|scc_notify
c_func
(paren
id|scc
comma
id|scc-&gt;dcd
ques
c_cond
id|HWEV_DCD_OFF
suffix:colon
id|HWEV_DCD_ON
)paren
suffix:semicolon
)brace
multiline_comment|/* DCD: on = start to receive packet, off = ABORT condition */
multiline_comment|/* (a successfully received packet generates a special condition int) */
r_if
c_cond
(paren
(paren
id|changes
op_amp
id|DCD
)paren
op_logical_and
op_logical_neg
id|scc-&gt;kiss.softdcd
)paren
multiline_comment|/* DCD input changed state */
(brace
r_if
c_cond
(paren
id|status
op_amp
id|DCD
)paren
multiline_comment|/* DCD is now ON */
(brace
id|start_hunt
c_func
(paren
id|scc
)paren
suffix:semicolon
id|scc-&gt;dcd
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* DCD is now OFF */
id|cl
c_func
(paren
id|scc
comma
id|R3
comma
id|ENT_HM
op_or
id|RxENABLE
)paren
suffix:semicolon
multiline_comment|/* disable the receiver */
id|flush_rx_FIFO
c_func
(paren
id|scc
)paren
suffix:semicolon
id|scc-&gt;dcd
op_assign
l_int|0
suffix:semicolon
)brace
id|scc_notify
c_func
(paren
id|scc
comma
id|scc-&gt;dcd
ques
c_cond
id|HWEV_DCD_ON
suffix:colon
id|HWEV_DCD_OFF
)paren
suffix:semicolon
)brace
macro_line|#ifdef notdef
multiline_comment|/* CTS: use external TxDelay (what&squot;s that good for?!)&n;&t; * Anyway: If we _could_ use it (BayCom USCC uses CTS for&n;&t; * own purposes) we _should_ use the &quot;autoenable&quot; feature&n;&t; * of the Z8530 and not this interrupt...&n;&t; */
r_if
c_cond
(paren
id|chg_and_stat
op_amp
id|CTS
)paren
multiline_comment|/* CTS is now ON */
(brace
r_if
c_cond
(paren
id|scc-&gt;kiss.txdelay
op_eq
l_int|0
)paren
multiline_comment|/* zero TXDELAY = wait for CTS */
id|scc_start_tx_timer
c_func
(paren
id|scc
comma
id|t_txdelay
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|scc-&gt;stat.tx_state
op_eq
id|TXS_ACTIVE
op_logical_and
(paren
id|status
op_amp
id|TxEOM
)paren
)paren
(brace
id|scc-&gt;stat.tx_under
op_increment
suffix:semicolon
multiline_comment|/* oops, an underrun! count &squot;em */
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_EXT_INT
)paren
suffix:semicolon
multiline_comment|/* reset ext/status interrupts */
r_if
c_cond
(paren
id|scc-&gt;tx_buff
op_ne
l_int|NULL
)paren
(brace
id|dev_kfree_skb_irq
c_func
(paren
id|scc-&gt;tx_buff
)paren
suffix:semicolon
id|scc-&gt;tx_buff
op_assign
l_int|NULL
suffix:semicolon
)brace
op_logical_or
(paren
id|scc
comma
id|R10
comma
id|ABUNDER
)paren
suffix:semicolon
id|scc_start_tx_timer
c_func
(paren
id|scc
comma
id|t_txdelay
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* restart transmission */
)brace
id|scc-&gt;status
op_assign
id|status
suffix:semicolon
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_EXT_INT
)paren
suffix:semicolon
)brace
multiline_comment|/* Receiver interrupt handler */
DECL|function|scc_rxint
r_static
r_inline
r_void
id|scc_rxint
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|scc-&gt;stat.rxints
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scc-&gt;wreg
(braket
l_int|5
)braket
op_amp
id|RTS
)paren
op_logical_and
id|scc-&gt;kiss.fulldup
op_eq
id|KISS_DUPLEX_HALF
)paren
(brace
id|Inb
c_func
(paren
id|scc-&gt;data
)paren
suffix:semicolon
multiline_comment|/* discard char */
op_logical_or
(paren
id|scc
comma
id|R3
comma
id|ENT_HM
)paren
suffix:semicolon
multiline_comment|/* enter hunt mode for next flag */
r_return
suffix:semicolon
)brace
id|skb
op_assign
id|scc-&gt;rx_buff
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|scc-&gt;stat.bufsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|scc-&gt;dev_stat.rx_dropped
op_increment
suffix:semicolon
id|scc-&gt;stat.nospace
op_increment
suffix:semicolon
id|Inb
c_func
(paren
id|scc-&gt;data
)paren
suffix:semicolon
op_logical_or
(paren
id|scc
comma
id|R3
comma
id|ENT_HM
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|scc-&gt;rx_buff
op_assign
id|skb
suffix:semicolon
op_star
(paren
id|skb_put
c_func
(paren
id|skb
comma
l_int|1
)paren
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* KISS data */
)brace
r_if
c_cond
(paren
id|skb-&gt;len
op_ge
id|scc-&gt;stat.bufsize
)paren
(brace
macro_line|#ifdef notdef
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;z8530drv: oops, scc_rxint() received huge frame...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|dev_kfree_skb_irq
c_func
(paren
id|skb
)paren
suffix:semicolon
id|scc-&gt;rx_buff
op_assign
l_int|NULL
suffix:semicolon
id|Inb
c_func
(paren
id|scc-&gt;data
)paren
suffix:semicolon
op_logical_or
(paren
id|scc
comma
id|R3
comma
id|ENT_HM
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
op_star
(paren
id|skb_put
c_func
(paren
id|skb
comma
l_int|1
)paren
)paren
op_assign
id|Inb
c_func
(paren
id|scc-&gt;data
)paren
suffix:semicolon
)brace
multiline_comment|/* Receive Special Condition interrupt handler */
DECL|function|scc_spint
r_static
r_inline
r_void
id|scc_spint
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|scc-&gt;stat.spints
op_increment
suffix:semicolon
id|status
op_assign
id|InReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R1
)paren
suffix:semicolon
multiline_comment|/* read receiver status */
id|Inb
c_func
(paren
id|scc-&gt;data
)paren
suffix:semicolon
multiline_comment|/* throw away Rx byte */
id|skb
op_assign
id|scc-&gt;rx_buff
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|Rx_OVR
)paren
multiline_comment|/* receiver overrun */
(brace
id|scc-&gt;stat.rx_over
op_increment
suffix:semicolon
multiline_comment|/* count them */
op_logical_or
(paren
id|scc
comma
id|R3
comma
id|ENT_HM
)paren
suffix:semicolon
multiline_comment|/* enter hunt mode for next flag */
r_if
c_cond
(paren
id|skb
op_ne
l_int|NULL
)paren
id|dev_kfree_skb_irq
c_func
(paren
id|skb
)paren
suffix:semicolon
id|scc-&gt;rx_buff
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|END_FR
op_logical_and
id|skb
op_ne
l_int|NULL
)paren
multiline_comment|/* end of frame */
(brace
multiline_comment|/* CRC okay, frame ends on 8 bit boundary and received something ? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|CRC_ERR
)paren
op_logical_and
(paren
id|status
op_amp
l_int|0xe
)paren
op_eq
id|RES8
op_logical_and
id|skb-&gt;len
OG
l_int|0
)paren
(brace
multiline_comment|/* ignore last received byte (first of the CRC bytes) */
id|skb_trim
c_func
(paren
id|skb
comma
id|skb-&gt;len
op_minus
l_int|1
)paren
suffix:semicolon
id|scc_net_rx
c_func
(paren
id|scc
comma
id|skb
)paren
suffix:semicolon
id|scc-&gt;rx_buff
op_assign
l_int|NULL
suffix:semicolon
id|scc-&gt;stat.rxframes
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* a bad frame */
id|dev_kfree_skb_irq
c_func
(paren
id|skb
)paren
suffix:semicolon
id|scc-&gt;rx_buff
op_assign
l_int|NULL
suffix:semicolon
id|scc-&gt;stat.rxerrs
op_increment
suffix:semicolon
)brace
)brace
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|ERR_RES
)paren
suffix:semicolon
)brace
multiline_comment|/* ----&gt; interrupt service routine for the Z8530 &lt;---- */
DECL|function|scc_isr_dispatch
r_static
r_void
id|scc_isr_dispatch
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_int
id|vector
)paren
(brace
r_switch
c_cond
(paren
id|vector
op_amp
id|VECTOR_MASK
)paren
(brace
r_case
id|TXINT
suffix:colon
id|scc_txint
c_func
(paren
id|scc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EXINT
suffix:colon
id|scc_exint
c_func
(paren
id|scc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RXINT
suffix:colon
id|scc_rxint
c_func
(paren
id|scc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SPINT
suffix:colon
id|scc_spint
c_func
(paren
id|scc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* If the card has a latch for the interrupt vector (like the PA0HZP card)&n;   use it to get the number of the chip that generated the int.&n;   If not: poll all defined chips.&n; */
DECL|macro|SCC_IRQTIMEOUT
mdefine_line|#define SCC_IRQTIMEOUT 30000
DECL|function|scc_isr
r_static
r_void
id|scc_isr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_char
id|vector
suffix:semicolon
r_struct
id|scc_channel
op_star
id|scc
suffix:semicolon
r_struct
id|scc_ctrl
op_star
id|ctrl
suffix:semicolon
r_int
id|k
suffix:semicolon
r_if
c_cond
(paren
id|Vector_Latch
)paren
(brace
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|SCC_IRQTIMEOUT
suffix:semicolon
id|k
op_increment
)paren
(brace
id|Outb
c_func
(paren
id|Vector_Latch
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Generate INTACK */
multiline_comment|/* Read the vector */
r_if
c_cond
(paren
(paren
id|vector
op_assign
id|Inb
c_func
(paren
id|Vector_Latch
)paren
)paren
op_ge
l_int|16
op_star
id|Nchips
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vector
op_amp
l_int|0x01
)paren
r_break
suffix:semicolon
id|scc
op_assign
op_amp
id|SCC_Info
(braket
id|vector
op_rshift
l_int|3
op_xor
l_int|0x01
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scc-&gt;dev
)paren
r_break
suffix:semicolon
id|scc_isr_dispatch
c_func
(paren
id|scc
comma
id|vector
)paren
suffix:semicolon
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R0
comma
id|RES_H_IUS
)paren
suffix:semicolon
multiline_comment|/* Reset Highest IUS */
)brace
r_if
c_cond
(paren
id|k
op_eq
id|SCC_IRQTIMEOUT
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;z8530drv: endless loop in scc_isr()?&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Find the SCC generating the interrupt by polling all attached SCCs&n;&t; * reading RR3A (the interrupt pending register)&n;&t; */
id|ctrl
op_assign
id|SCC_ctrl
suffix:semicolon
r_while
c_loop
(paren
id|ctrl-&gt;chan_A
)paren
(brace
r_if
c_cond
(paren
id|ctrl-&gt;irq
op_ne
id|irq
)paren
(brace
id|ctrl
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|scc
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|InReg
c_func
(paren
id|ctrl-&gt;chan_A
comma
id|R3
)paren
op_logical_and
id|k
OL
id|SCC_IRQTIMEOUT
suffix:semicolon
id|k
op_increment
)paren
(brace
id|vector
op_assign
id|InReg
c_func
(paren
id|ctrl-&gt;chan_B
comma
id|R2
)paren
suffix:semicolon
multiline_comment|/* Read the vector */
r_if
c_cond
(paren
id|vector
op_amp
l_int|0x01
)paren
r_break
suffix:semicolon
id|scc
op_assign
op_amp
id|SCC_Info
(braket
id|vector
op_rshift
l_int|3
op_xor
l_int|0x01
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scc-&gt;dev
)paren
r_break
suffix:semicolon
id|scc_isr_dispatch
c_func
(paren
id|scc
comma
id|vector
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
op_eq
id|SCC_IRQTIMEOUT
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;z8530drv: endless loop in scc_isr()?!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* This looks wierd and it is. At least the BayCom USCC doesn&squot;t&n;&t;&t; * use the Interrupt Daisy Chain, thus we&squot;ll have to start&n;&t;&t; * all over again to be sure not to miss an interrupt from &n;&t;&t; * (any of) the other chip(s)...&n;&t;&t; * Honestly, the situation *is* braindamaged...&n;&t;&t; */
r_if
c_cond
(paren
id|scc
op_ne
l_int|NULL
)paren
(brace
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R0
comma
id|RES_H_IUS
)paren
suffix:semicolon
id|ctrl
op_assign
id|SCC_ctrl
suffix:semicolon
)brace
r_else
id|ctrl
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* ******************************************************************** */
multiline_comment|/* *&t;&t;&t;Init Channel&t;&t;&t;&t;&t;*/
multiline_comment|/* ******************************************************************** */
multiline_comment|/* ----&gt; set SCC channel speed &lt;---- */
DECL|function|set_brg
r_static
r_inline
r_void
id|set_brg
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_int
r_int
id|tc
)paren
(brace
id|cl
c_func
(paren
id|scc
comma
id|R14
comma
id|BRENABL
)paren
suffix:semicolon
multiline_comment|/* disable baudrate generator */
id|wr
c_func
(paren
id|scc
comma
id|R12
comma
id|tc
op_amp
l_int|255
)paren
suffix:semicolon
multiline_comment|/* brg rate LOW */
id|wr
c_func
(paren
id|scc
comma
id|R13
comma
id|tc
op_rshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* brg rate HIGH */
op_logical_or
(paren
id|scc
comma
id|R14
comma
id|BRENABL
)paren
suffix:semicolon
multiline_comment|/* enable baudrate generator */
)brace
DECL|function|set_speed
r_static
r_inline
r_void
id|set_speed
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
id|disable_irq
c_func
(paren
id|scc-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;modem.speed
OG
l_int|0
)paren
multiline_comment|/* paranoia... */
id|set_brg
c_func
(paren
id|scc
comma
(paren
r_int
)paren
(paren
id|scc-&gt;clock
op_div
(paren
id|scc-&gt;modem.speed
op_star
l_int|64
)paren
)paren
op_minus
l_int|2
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|scc-&gt;irq
)paren
suffix:semicolon
)brace
multiline_comment|/* ----&gt; initialize a SCC channel &lt;---- */
DECL|function|init_brg
r_static
r_inline
r_void
id|init_brg
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
id|wr
c_func
(paren
id|scc
comma
id|R14
comma
id|BRSRC
)paren
suffix:semicolon
multiline_comment|/* BRG source = PCLK */
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R14
comma
id|SSBR
op_or
id|scc-&gt;wreg
(braket
id|R14
)braket
)paren
suffix:semicolon
multiline_comment|/* DPLL source = BRG */
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R14
comma
id|SNRZI
op_or
id|scc-&gt;wreg
(braket
id|R14
)braket
)paren
suffix:semicolon
multiline_comment|/* DPLL NRZI mode */
)brace
multiline_comment|/*&n; * Initialization according to the Z8530 manual (SGS-Thomson&squot;s version):&n; *&n; * 1. Modes and constants&n; *&n; * WR9&t;11000000&t;chip reset&n; * WR4&t;XXXXXXXX&t;Tx/Rx control, async or sync mode&n; * WR1&t;0XX00X00&t;select W/REQ (optional)&n; * WR2&t;XXXXXXXX&t;program interrupt vector&n; * WR3&t;XXXXXXX0&t;select Rx control&n; * WR5&t;XXXX0XXX&t;select Tx control&n; * WR6&t;XXXXXXXX&t;sync character&n; * WR7&t;XXXXXXXX&t;sync character&n; * WR9&t;000X0XXX&t;select interrupt control&n; * WR10&t;XXXXXXXX&t;miscellaneous control (optional)&n; * WR11&t;XXXXXXXX&t;clock control&n; * WR12&t;XXXXXXXX&t;time constant lower byte (optional)&n; * WR13&t;XXXXXXXX&t;time constant upper byte (optional)&n; * WR14&t;XXXXXXX0&t;miscellaneous control&n; * WR14&t;XXXSSSSS&t;commands (optional)&n; *&n; * 2. Enables&n; *&n; * WR14&t;000SSSS1&t;baud rate enable&n; * WR3&t;SSSSSSS1&t;Rx enable&n; * WR5&t;SSSS1SSS&t;Tx enable&n; * WR0&t;10000000&t;reset Tx CRG (optional)&n; * WR1&t;XSS00S00&t;DMA enable (optional)&n; *&n; * 3. Interrupt status&n; *&n; * WR15&t;XXXXXXXX&t;enable external/status&n; * WR0&t;00010000&t;reset external status&n; * WR0&t;00010000&t;reset external status twice&n; * WR1&t;SSSXXSXX&t;enable Rx, Tx and Ext/status&n; * WR9&t;000SXSSS&t;enable master interrupt enable&n; *&n; * 1 = set to one, 0 = reset to zero&n; * X = user defined, S = same as previous init&n; *&n; *&n; * Note that the implementation differs in some points from above scheme.&n; *&n; */
DECL|function|init_channel
r_static
r_void
id|init_channel
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|scc-&gt;tx_t
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|scc-&gt;tx_wdog
)paren
suffix:semicolon
id|disable_irq
c_func
(paren
id|scc-&gt;irq
)paren
suffix:semicolon
id|wr
c_func
(paren
id|scc
comma
id|R4
comma
id|X1CLK
op_or
id|SDLC
)paren
suffix:semicolon
multiline_comment|/* *1 clock, SDLC mode */
id|wr
c_func
(paren
id|scc
comma
id|R1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* no W/REQ operation */
id|wr
c_func
(paren
id|scc
comma
id|R3
comma
id|Rx8
op_or
id|RxCRC_ENAB
)paren
suffix:semicolon
multiline_comment|/* RX 8 bits/char, CRC, disabled */
id|wr
c_func
(paren
id|scc
comma
id|R5
comma
id|Tx8
op_or
id|DTR
op_or
id|TxCRC_ENAB
)paren
suffix:semicolon
multiline_comment|/* TX 8 bits/char, disabled, DTR */
id|wr
c_func
(paren
id|scc
comma
id|R6
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* SDLC address zero (not used) */
id|wr
c_func
(paren
id|scc
comma
id|R7
comma
id|FLAG
)paren
suffix:semicolon
multiline_comment|/* SDLC flag value */
id|wr
c_func
(paren
id|scc
comma
id|R9
comma
id|VIS
)paren
suffix:semicolon
multiline_comment|/* vector includes status */
id|wr
c_func
(paren
id|scc
comma
id|R10
comma
(paren
id|scc-&gt;modem.nrz
ques
c_cond
id|NRZ
suffix:colon
id|NRZI
)paren
op_or
id|CRCPS
op_or
id|ABUNDER
)paren
suffix:semicolon
multiline_comment|/* abort on underrun, preset CRC generator, NRZ(I) */
id|wr
c_func
(paren
id|scc
comma
id|R14
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* set clock sources:&n;&n;   CLK_DPLL: normal halfduplex operation&n;   &n;&t;&t;RxClk: use DPLL&n;&t;&t;TxClk: use DPLL&n;&t;&t;TRxC mode DPLL output&n;&t;&t;&n;   CLK_EXTERNAL: external clocking (G3RUH or DF9IC modem)&n;   &n;  &t;        BayCom: &t;&t;others:&n;  &t;        &n;  &t;        TxClk = pin RTxC&t;TxClk = pin TRxC&n;  &t;        RxClk = pin TRxC &t;RxClk = pin RTxC&n;  &t;     &n;&n;   CLK_DIVIDER:&n;   &t;&t;RxClk = use DPLL&n;   &t;&t;TxClk = pin RTxC&n;   &t;&t;&n;   &t;&t;BayCom:&t;&t;&t;others:&n;   &t;&t;pin TRxC = DPLL&t;&t;pin TRxC = BRG&n;   &t;&t;(RxClk * 1)&t;&t;(RxClk * 32)&n;*/
r_switch
c_cond
(paren
id|scc-&gt;modem.clocksrc
)paren
(brace
r_case
id|CLK_DPLL
suffix:colon
id|wr
c_func
(paren
id|scc
comma
id|R11
comma
id|RCDPLL
op_or
id|TCDPLL
op_or
id|TRxCOI
op_or
id|TRxCDP
)paren
suffix:semicolon
id|init_brg
c_func
(paren
id|scc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CLK_DIVIDER
suffix:colon
id|wr
c_func
(paren
id|scc
comma
id|R11
comma
(paren
(paren
id|scc-&gt;brand
op_amp
id|BAYCOM
)paren
ques
c_cond
id|TRxCDP
suffix:colon
id|TRxCBR
)paren
op_or
id|RCDPLL
op_or
id|TCRTxCP
op_or
id|TRxCOI
)paren
suffix:semicolon
id|init_brg
c_func
(paren
id|scc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CLK_EXTERNAL
suffix:colon
id|wr
c_func
(paren
id|scc
comma
id|R11
comma
(paren
id|scc-&gt;brand
op_amp
id|BAYCOM
)paren
ques
c_cond
id|RCTRxCP
op_or
id|TCRTxCP
suffix:colon
id|RCRTxCP
op_or
id|TCTRxCP
)paren
suffix:semicolon
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R14
comma
id|DISDPLL
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|set_speed
c_func
(paren
id|scc
)paren
suffix:semicolon
multiline_comment|/* set baudrate */
r_if
c_cond
(paren
id|scc-&gt;enhanced
)paren
(brace
op_logical_or
(paren
id|scc
comma
id|R15
comma
id|SHDLCE
op_or
id|FIFOE
)paren
suffix:semicolon
multiline_comment|/* enable FIFO, SDLC/HDLC Enhancements (From now R7 is R7&squot;) */
id|wr
c_func
(paren
id|scc
comma
id|R7
comma
id|AUTOEOM
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scc-&gt;kiss.softdcd
op_logical_or
(paren
id|InReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R0
)paren
op_amp
id|DCD
)paren
)paren
multiline_comment|/* DCD is now ON */
(brace
id|start_hunt
c_func
(paren
id|scc
)paren
suffix:semicolon
)brace
multiline_comment|/* enable ABORT, DCD &amp; SYNC/HUNT interrupts */
id|wr
c_func
(paren
id|scc
comma
id|R15
comma
id|BRKIE
op_or
id|TxUIE
op_or
(paren
id|scc-&gt;kiss.softdcd
ques
c_cond
id|SYNCIE
suffix:colon
id|DCDIE
)paren
)paren
suffix:semicolon
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_EXT_INT
)paren
suffix:semicolon
multiline_comment|/* reset ext/status interrupts */
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_EXT_INT
)paren
suffix:semicolon
multiline_comment|/* must be done twice */
op_logical_or
(paren
id|scc
comma
id|R1
comma
id|INT_ALL_Rx
op_or
id|TxINT_ENAB
op_or
id|EXT_INT_ENAB
)paren
suffix:semicolon
multiline_comment|/* enable interrupts */
id|scc-&gt;status
op_assign
id|InReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R0
)paren
suffix:semicolon
multiline_comment|/* read initial status */
op_logical_or
(paren
id|scc
comma
id|R9
comma
id|MIE
)paren
suffix:semicolon
multiline_comment|/* master interrupt enable */
id|scc_init_timer
c_func
(paren
id|scc
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|scc-&gt;irq
)paren
suffix:semicolon
)brace
multiline_comment|/* ******************************************************************** */
multiline_comment|/* *&t;&t;&t;SCC timer functions&t;&t;&t;      * */
multiline_comment|/* ******************************************************************** */
multiline_comment|/* ----&gt; scc_key_trx sets the time constant for the baudrate &n;         generator and keys the transmitter&t;&t;     &lt;---- */
DECL|function|scc_key_trx
r_static
r_void
id|scc_key_trx
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_char
id|tx
)paren
(brace
r_int
r_int
id|time_const
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;brand
op_amp
id|PRIMUS
)paren
id|Outb
c_func
(paren
id|scc-&gt;ctrl
op_plus
l_int|4
comma
id|scc-&gt;option
op_or
(paren
id|tx
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;modem.speed
OL
l_int|300
)paren
id|scc-&gt;modem.speed
op_assign
l_int|1200
suffix:semicolon
id|time_const
op_assign
(paren
r_int
)paren
(paren
id|scc-&gt;clock
op_div
(paren
id|scc-&gt;modem.speed
op_star
(paren
id|tx
ques
c_cond
l_int|2
suffix:colon
l_int|64
)paren
)paren
)paren
op_minus
l_int|2
suffix:semicolon
id|disable_irq
c_func
(paren
id|scc-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tx
)paren
(brace
op_logical_or
(paren
id|scc
comma
id|R1
comma
id|TxINT_ENAB
)paren
suffix:semicolon
multiline_comment|/* t_maxkeyup may have reset these */
op_logical_or
(paren
id|scc
comma
id|R15
comma
id|TxUIE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scc-&gt;modem.clocksrc
op_eq
id|CLK_DPLL
)paren
(brace
multiline_comment|/* force simplex operation */
r_if
c_cond
(paren
id|tx
)paren
(brace
macro_line|#ifdef CONFIG_SCC_TRXECHO
id|cl
c_func
(paren
id|scc
comma
id|R3
comma
id|RxENABLE
op_or
id|ENT_HM
)paren
suffix:semicolon
multiline_comment|/* switch off receiver */
id|cl
c_func
(paren
id|scc
comma
id|R15
comma
id|DCDIE
op_or
id|SYNCIE
)paren
suffix:semicolon
multiline_comment|/* No DCD changes, please */
macro_line|#endif
id|set_brg
c_func
(paren
id|scc
comma
id|time_const
)paren
suffix:semicolon
multiline_comment|/* reprogram baudrate generator */
multiline_comment|/* DPLL -&gt; Rx clk, BRG -&gt; Tx CLK, TRxC mode output, TRxC = BRG */
id|wr
c_func
(paren
id|scc
comma
id|R11
comma
id|RCDPLL
op_or
id|TCBR
op_or
id|TRxCOI
op_or
id|TRxCBR
)paren
suffix:semicolon
multiline_comment|/* By popular demand: tx_inhibit */
r_if
c_cond
(paren
id|scc-&gt;kiss.tx_inhibit
)paren
(brace
op_logical_or
(paren
id|scc
comma
id|R5
comma
id|TxENAB
)paren
suffix:semicolon
id|scc-&gt;wreg
(braket
id|R5
)braket
op_or_assign
id|RTS
suffix:semicolon
)brace
r_else
(brace
op_logical_or
(paren
id|scc
comma
id|R5
comma
id|RTS
op_or
id|TxENAB
)paren
suffix:semicolon
multiline_comment|/* set the RTS line and enable TX */
)brace
)brace
r_else
(brace
id|cl
c_func
(paren
id|scc
comma
id|R5
comma
id|RTS
op_or
id|TxENAB
)paren
suffix:semicolon
id|set_brg
c_func
(paren
id|scc
comma
id|time_const
)paren
suffix:semicolon
multiline_comment|/* reprogram baudrate generator */
multiline_comment|/* DPLL -&gt; Rx clk, DPLL -&gt; Tx CLK, TRxC mode output, TRxC = DPLL */
id|wr
c_func
(paren
id|scc
comma
id|R11
comma
id|RCDPLL
op_or
id|TCDPLL
op_or
id|TRxCOI
op_or
id|TRxCDP
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_SCC_TRXECHO
r_if
c_cond
(paren
id|scc-&gt;kiss.softdcd
)paren
macro_line|#endif
(brace
op_logical_or
(paren
id|scc
comma
id|R15
comma
id|scc-&gt;kiss.softdcd
ques
c_cond
id|SYNCIE
suffix:colon
id|DCDIE
)paren
suffix:semicolon
id|start_hunt
c_func
(paren
id|scc
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|tx
)paren
(brace
macro_line|#ifdef CONFIG_SCC_TRXECHO
r_if
c_cond
(paren
id|scc-&gt;kiss.fulldup
op_eq
id|KISS_DUPLEX_HALF
)paren
(brace
id|cl
c_func
(paren
id|scc
comma
id|R3
comma
id|RxENABLE
)paren
suffix:semicolon
id|cl
c_func
(paren
id|scc
comma
id|R15
comma
id|DCDIE
op_or
id|SYNCIE
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|scc-&gt;kiss.tx_inhibit
)paren
(brace
op_logical_or
(paren
id|scc
comma
id|R5
comma
id|TxENAB
)paren
suffix:semicolon
id|scc-&gt;wreg
(braket
id|R5
)braket
op_or_assign
id|RTS
suffix:semicolon
)brace
r_else
(brace
op_logical_or
(paren
id|scc
comma
id|R5
comma
id|RTS
op_or
id|TxENAB
)paren
suffix:semicolon
multiline_comment|/* enable tx */
)brace
)brace
r_else
(brace
id|cl
c_func
(paren
id|scc
comma
id|R5
comma
id|RTS
op_or
id|TxENAB
)paren
suffix:semicolon
multiline_comment|/* disable tx */
r_if
c_cond
(paren
(paren
id|scc-&gt;kiss.fulldup
op_eq
id|KISS_DUPLEX_HALF
)paren
op_logical_and
macro_line|#ifndef CONFIG_SCC_TRXECHO
id|scc-&gt;kiss.softdcd
)paren
macro_line|#else
l_int|1
)paren
macro_line|#endif
(brace
op_logical_or
(paren
id|scc
comma
id|R15
comma
id|scc-&gt;kiss.softdcd
ques
c_cond
id|SYNCIE
suffix:colon
id|DCDIE
)paren
suffix:semicolon
id|start_hunt
c_func
(paren
id|scc
)paren
suffix:semicolon
)brace
)brace
)brace
id|enable_irq
c_func
(paren
id|scc-&gt;irq
)paren
suffix:semicolon
)brace
multiline_comment|/* ----&gt; SCC timer interrupt handler and friends. &lt;---- */
DECL|function|scc_start_tx_timer
r_static
r_void
id|scc_start_tx_timer
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
r_int
)paren
comma
r_int
r_int
id|when
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|scc-&gt;tx_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|when
op_eq
l_int|0
)paren
(brace
id|handler
c_func
(paren
(paren
r_int
r_int
)paren
id|scc
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|when
op_ne
id|TIMER_OFF
)paren
(brace
id|scc-&gt;tx_t.data
op_assign
(paren
r_int
r_int
)paren
id|scc
suffix:semicolon
id|scc-&gt;tx_t.function
op_assign
id|handler
suffix:semicolon
id|scc-&gt;tx_t.expires
op_assign
id|jiffies
op_plus
(paren
id|when
op_star
id|HZ
)paren
op_div
l_int|100
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|scc-&gt;tx_t
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|scc_start_defer
r_static
r_void
id|scc_start_defer
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|scc-&gt;tx_wdog
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;kiss.maxdefer
op_ne
l_int|0
op_logical_and
id|scc-&gt;kiss.maxdefer
op_ne
id|TIMER_OFF
)paren
(brace
id|scc-&gt;tx_wdog.data
op_assign
(paren
r_int
r_int
)paren
id|scc
suffix:semicolon
id|scc-&gt;tx_wdog.function
op_assign
id|t_busy
suffix:semicolon
id|scc-&gt;tx_wdog.expires
op_assign
id|jiffies
op_plus
id|HZ
op_star
id|scc-&gt;kiss.maxdefer
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|scc-&gt;tx_wdog
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|scc_start_maxkeyup
r_static
r_void
id|scc_start_maxkeyup
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|scc-&gt;tx_wdog
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;kiss.maxkeyup
op_ne
l_int|0
op_logical_and
id|scc-&gt;kiss.maxkeyup
op_ne
id|TIMER_OFF
)paren
(brace
id|scc-&gt;tx_wdog.data
op_assign
(paren
r_int
r_int
)paren
id|scc
suffix:semicolon
id|scc-&gt;tx_wdog.function
op_assign
id|t_maxkeyup
suffix:semicolon
id|scc-&gt;tx_wdog.expires
op_assign
id|jiffies
op_plus
id|HZ
op_star
id|scc-&gt;kiss.maxkeyup
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|scc-&gt;tx_wdog
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * This is called from scc_txint() when there are no more frames to send.&n; * Not exactly a timer function, but it is a close friend of the family...&n; */
DECL|function|scc_tx_done
r_static
r_void
id|scc_tx_done
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
multiline_comment|/* &n;&t; * trx remains keyed in fulldup mode 2 until t_idle expires.&n;&t; */
r_switch
c_cond
(paren
id|scc-&gt;kiss.fulldup
)paren
(brace
r_case
id|KISS_DUPLEX_LINK
suffix:colon
id|scc-&gt;stat.tx_state
op_assign
id|TXS_IDLE2
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;kiss.idletime
op_ne
id|TIMER_OFF
)paren
id|scc_start_tx_timer
c_func
(paren
id|scc
comma
id|t_idle
comma
id|scc-&gt;kiss.idletime
op_star
l_int|100
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KISS_DUPLEX_OPTIMA
suffix:colon
id|scc_notify
c_func
(paren
id|scc
comma
id|HWEV_ALL_SENT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|scc-&gt;stat.tx_state
op_assign
id|TXS_BUSY
suffix:semicolon
id|scc_start_tx_timer
c_func
(paren
id|scc
comma
id|t_tail
comma
id|scc-&gt;kiss.tailtime
)paren
suffix:semicolon
)brace
id|netif_wake_queue
c_func
(paren
id|scc-&gt;dev
)paren
suffix:semicolon
)brace
DECL|variable|Rand
r_static
r_int
r_char
id|Rand
op_assign
l_int|17
suffix:semicolon
DECL|function|is_grouped
r_static
r_inline
r_int
id|is_grouped
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_int
id|k
suffix:semicolon
r_struct
id|scc_channel
op_star
id|scc2
suffix:semicolon
r_int
r_char
id|grp1
comma
id|grp2
suffix:semicolon
id|grp1
op_assign
id|scc-&gt;kiss.group
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
(paren
id|Nchips
op_star
l_int|2
)paren
suffix:semicolon
id|k
op_increment
)paren
(brace
id|scc2
op_assign
op_amp
id|SCC_Info
(braket
id|k
)braket
suffix:semicolon
id|grp2
op_assign
id|scc2-&gt;kiss.group
suffix:semicolon
r_if
c_cond
(paren
id|scc2
op_eq
id|scc
op_logical_or
op_logical_neg
(paren
id|scc2-&gt;dev
op_logical_and
id|grp2
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|grp1
op_amp
l_int|0x3f
)paren
op_eq
(paren
id|grp2
op_amp
l_int|0x3f
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|grp1
op_amp
id|TXGROUP
)paren
op_logical_and
(paren
id|scc2-&gt;wreg
(braket
id|R5
)braket
op_amp
id|RTS
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|grp1
op_amp
id|RXGROUP
)paren
op_logical_and
id|scc2-&gt;dcd
)paren
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* DWAIT and SLOTTIME expired&n; *&n; * fulldup == 0:  DCD is active or Rand &gt; P-persistence: start t_busy timer&n; *                else key trx and start txdelay&n; * fulldup == 1:  key trx and start txdelay&n; * fulldup == 2:  mintime expired, reset status or key trx and start txdelay&n; */
DECL|function|t_dwait
r_static
r_void
id|t_dwait
c_func
(paren
r_int
r_int
id|channel
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
(paren
r_struct
id|scc_channel
op_star
)paren
id|channel
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;stat.tx_state
op_eq
id|TXS_WAIT
)paren
multiline_comment|/* maxkeyup or idle timeout */
(brace
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|scc-&gt;tx_queue
)paren
op_eq
l_int|0
)paren
multiline_comment|/* nothing to send */
(brace
id|scc-&gt;stat.tx_state
op_assign
id|TXS_IDLE
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|scc-&gt;dev
)paren
suffix:semicolon
multiline_comment|/* t_maxkeyup locked it. */
r_return
suffix:semicolon
)brace
id|scc-&gt;stat.tx_state
op_assign
id|TXS_BUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scc-&gt;kiss.fulldup
op_eq
id|KISS_DUPLEX_HALF
)paren
(brace
id|Rand
op_assign
id|Rand
op_star
l_int|17
op_plus
l_int|31
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;dcd
op_logical_or
(paren
id|scc-&gt;kiss.persist
)paren
OL
id|Rand
op_logical_or
(paren
id|scc-&gt;kiss.group
op_logical_and
id|is_grouped
c_func
(paren
id|scc
)paren
)paren
)paren
(brace
id|scc_start_defer
c_func
(paren
id|scc
)paren
suffix:semicolon
id|scc_start_tx_timer
c_func
(paren
id|scc
comma
id|t_dwait
comma
id|scc-&gt;kiss.slottime
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|scc-&gt;wreg
(braket
id|R5
)braket
op_amp
id|RTS
)paren
)paren
(brace
id|scc_key_trx
c_func
(paren
id|scc
comma
id|TX_ON
)paren
suffix:semicolon
id|scc_start_tx_timer
c_func
(paren
id|scc
comma
id|t_txdelay
comma
id|scc-&gt;kiss.txdelay
)paren
suffix:semicolon
)brace
r_else
(brace
id|scc_start_tx_timer
c_func
(paren
id|scc
comma
id|t_txdelay
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* TXDELAY expired&n; *&n; * kick transmission by a fake scc_txint(scc), start &squot;maxkeyup&squot; watchdog.&n; */
DECL|function|t_txdelay
r_static
r_void
id|t_txdelay
c_func
(paren
r_int
r_int
id|channel
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
(paren
r_struct
id|scc_channel
op_star
)paren
id|channel
suffix:semicolon
id|scc_start_maxkeyup
c_func
(paren
id|scc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;tx_buff
op_eq
l_int|NULL
)paren
(brace
id|disable_irq
c_func
(paren
id|scc-&gt;irq
)paren
suffix:semicolon
id|scc_txint
c_func
(paren
id|scc
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|scc-&gt;irq
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* TAILTIME expired&n; *&n; * switch off transmitter. If we were stopped by Maxkeyup restart&n; * transmission after &squot;mintime&squot; seconds&n; */
DECL|function|t_tail
r_static
r_void
id|t_tail
c_func
(paren
r_int
r_int
id|channel
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
(paren
r_struct
id|scc_channel
op_star
)paren
id|channel
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|scc-&gt;tx_wdog
)paren
suffix:semicolon
id|scc_key_trx
c_func
(paren
id|scc
comma
id|TX_OFF
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;stat.tx_state
op_eq
id|TXS_TIMEOUT
)paren
multiline_comment|/* we had a timeout? */
(brace
id|scc-&gt;stat.tx_state
op_assign
id|TXS_WAIT
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;kiss.mintime
op_ne
id|TIMER_OFF
)paren
multiline_comment|/* try it again */
id|scc_start_tx_timer
c_func
(paren
id|scc
comma
id|t_dwait
comma
id|scc-&gt;kiss.mintime
op_star
l_int|100
)paren
suffix:semicolon
r_else
id|scc_start_tx_timer
c_func
(paren
id|scc
comma
id|t_dwait
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|scc-&gt;stat.tx_state
op_assign
id|TXS_IDLE
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|scc-&gt;dev
)paren
suffix:semicolon
)brace
multiline_comment|/* BUSY timeout&n; *&n; * throw away send buffers if DCD remains active too long.&n; */
DECL|function|t_busy
r_static
r_void
id|t_busy
c_func
(paren
r_int
r_int
id|channel
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
(paren
r_struct
id|scc_channel
op_star
)paren
id|channel
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|scc-&gt;tx_t
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|scc-&gt;dev
)paren
suffix:semicolon
multiline_comment|/* don&squot;t pile on the wabbit! */
id|scc_discard_buffers
c_func
(paren
id|scc
)paren
suffix:semicolon
id|scc-&gt;stat.txerrs
op_increment
suffix:semicolon
id|scc-&gt;stat.tx_state
op_assign
id|TXS_IDLE
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|scc-&gt;dev
)paren
suffix:semicolon
)brace
multiline_comment|/* MAXKEYUP timeout&n; *&n; * this is our watchdog.&n; */
DECL|function|t_maxkeyup
r_static
r_void
id|t_maxkeyup
c_func
(paren
r_int
r_int
id|channel
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
(paren
r_struct
id|scc_channel
op_star
)paren
id|channel
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * let things settle down before we start to&n;&t; * accept new data.&n;&t; */
id|netif_stop_queue
c_func
(paren
id|scc-&gt;dev
)paren
suffix:semicolon
id|scc_discard_buffers
c_func
(paren
id|scc
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|scc-&gt;tx_t
)paren
suffix:semicolon
id|cl
c_func
(paren
id|scc
comma
id|R1
comma
id|TxINT_ENAB
)paren
suffix:semicolon
multiline_comment|/* force an ABORT, but don&squot;t */
id|cl
c_func
(paren
id|scc
comma
id|R15
comma
id|TxUIE
)paren
suffix:semicolon
multiline_comment|/* count it. */
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R0
comma
id|RES_Tx_P
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|scc-&gt;stat.txerrs
op_increment
suffix:semicolon
id|scc-&gt;stat.tx_state
op_assign
id|TXS_TIMEOUT
suffix:semicolon
id|scc_start_tx_timer
c_func
(paren
id|scc
comma
id|t_tail
comma
id|scc-&gt;kiss.tailtime
)paren
suffix:semicolon
)brace
multiline_comment|/* IDLE timeout&n; *&n; * in fulldup mode 2 it keys down the transmitter after &squot;idle&squot; seconds&n; * of inactivity. We will not restart transmission before &squot;mintime&squot;&n; * expires.&n; */
DECL|function|t_idle
r_static
r_void
id|t_idle
c_func
(paren
r_int
r_int
id|channel
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
(paren
r_struct
id|scc_channel
op_star
)paren
id|channel
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|scc-&gt;tx_wdog
)paren
suffix:semicolon
id|scc_key_trx
c_func
(paren
id|scc
comma
id|TX_OFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;kiss.mintime
op_ne
id|TIMER_OFF
)paren
id|scc_start_tx_timer
c_func
(paren
id|scc
comma
id|t_dwait
comma
id|scc-&gt;kiss.mintime
op_star
l_int|100
)paren
suffix:semicolon
id|scc-&gt;stat.tx_state
op_assign
id|TXS_WAIT
suffix:semicolon
)brace
DECL|function|scc_init_timer
r_static
r_void
id|scc_init_timer
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|scc-&gt;stat.tx_state
op_assign
id|TXS_IDLE
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* ******************************************************************** */
multiline_comment|/* *&t;&t;&t;Set/get L1 parameters&t;&t;&t;      * */
multiline_comment|/* ******************************************************************** */
multiline_comment|/*&n; * this will set the &quot;hardware&quot; parameters through KISS commands or ioctl()&n; */
DECL|macro|CAST
mdefine_line|#define CAST(x) (unsigned long)(x)
DECL|function|scc_set_param
r_static
r_int
r_int
id|scc_set_param
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PARAM_TXDELAY
suffix:colon
id|scc-&gt;kiss.txdelay
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_PERSIST
suffix:colon
id|scc-&gt;kiss.persist
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_SLOTTIME
suffix:colon
id|scc-&gt;kiss.slottime
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_TXTAIL
suffix:colon
id|scc-&gt;kiss.tailtime
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_FULLDUP
suffix:colon
id|scc-&gt;kiss.fulldup
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_DTR
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* does someone need this? */
r_case
id|PARAM_GROUP
suffix:colon
id|scc-&gt;kiss.group
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_IDLE
suffix:colon
id|scc-&gt;kiss.idletime
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_MIN
suffix:colon
id|scc-&gt;kiss.mintime
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_MAXKEY
suffix:colon
id|scc-&gt;kiss.maxkeyup
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_WAIT
suffix:colon
id|scc-&gt;kiss.waittime
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_MAXDEFER
suffix:colon
id|scc-&gt;kiss.maxdefer
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_TX
suffix:colon
id|scc-&gt;kiss.tx_inhibit
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_SOFTDCD
suffix:colon
id|scc-&gt;kiss.softdcd
op_assign
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|arg
)paren
(brace
op_logical_or
(paren
id|scc
comma
id|R15
comma
id|SYNCIE
)paren
suffix:semicolon
id|cl
c_func
(paren
id|scc
comma
id|R15
comma
id|DCDIE
)paren
suffix:semicolon
id|start_hunt
c_func
(paren
id|scc
)paren
suffix:semicolon
)brace
r_else
(brace
op_logical_or
(paren
id|scc
comma
id|R15
comma
id|DCDIE
)paren
suffix:semicolon
id|cl
c_func
(paren
id|scc
comma
id|R15
comma
id|SYNCIE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PARAM_SPEED
suffix:colon
r_if
c_cond
(paren
id|arg
OL
l_int|256
)paren
id|scc-&gt;modem.speed
op_assign
id|arg
op_star
l_int|100
suffix:semicolon
r_else
id|scc-&gt;modem.speed
op_assign
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;stat.tx_state
op_eq
l_int|0
)paren
multiline_comment|/* only switch baudrate on rx... ;-) */
id|set_speed
c_func
(paren
id|scc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_RTS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|scc-&gt;wreg
(braket
id|R5
)braket
op_amp
id|RTS
)paren
)paren
(brace
r_if
c_cond
(paren
id|arg
op_ne
id|TX_OFF
)paren
id|scc_key_trx
c_func
(paren
id|scc
comma
id|TX_ON
)paren
suffix:semicolon
id|scc_start_tx_timer
c_func
(paren
id|scc
comma
id|t_txdelay
comma
id|scc-&gt;kiss.txdelay
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|arg
op_eq
id|TX_OFF
)paren
(brace
id|scc-&gt;stat.tx_state
op_assign
id|TXS_BUSY
suffix:semicolon
id|scc_start_tx_timer
c_func
(paren
id|scc
comma
id|t_tail
comma
id|scc-&gt;kiss.tailtime
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|PARAM_HWEVENT
suffix:colon
id|scc_notify
c_func
(paren
id|scc
comma
id|scc-&gt;dcd
ques
c_cond
id|HWEV_DCD_ON
suffix:colon
id|HWEV_DCD_OFF
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scc_get_param
r_static
r_int
r_int
id|scc_get_param
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_int
r_int
id|cmd
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PARAM_TXDELAY
suffix:colon
r_return
id|CAST
c_func
(paren
id|scc-&gt;kiss.txdelay
)paren
suffix:semicolon
r_case
id|PARAM_PERSIST
suffix:colon
r_return
id|CAST
c_func
(paren
id|scc-&gt;kiss.persist
)paren
suffix:semicolon
r_case
id|PARAM_SLOTTIME
suffix:colon
r_return
id|CAST
c_func
(paren
id|scc-&gt;kiss.slottime
)paren
suffix:semicolon
r_case
id|PARAM_TXTAIL
suffix:colon
r_return
id|CAST
c_func
(paren
id|scc-&gt;kiss.tailtime
)paren
suffix:semicolon
r_case
id|PARAM_FULLDUP
suffix:colon
r_return
id|CAST
c_func
(paren
id|scc-&gt;kiss.fulldup
)paren
suffix:semicolon
r_case
id|PARAM_SOFTDCD
suffix:colon
r_return
id|CAST
c_func
(paren
id|scc-&gt;kiss.softdcd
)paren
suffix:semicolon
r_case
id|PARAM_DTR
suffix:colon
r_return
id|CAST
c_func
(paren
(paren
id|scc-&gt;wreg
(braket
id|R5
)braket
op_amp
id|DTR
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_case
id|PARAM_RTS
suffix:colon
r_return
id|CAST
c_func
(paren
(paren
id|scc-&gt;wreg
(braket
id|R5
)braket
op_amp
id|RTS
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_case
id|PARAM_SPEED
suffix:colon
r_return
id|CAST
c_func
(paren
id|scc-&gt;modem.speed
)paren
suffix:semicolon
r_case
id|PARAM_GROUP
suffix:colon
r_return
id|CAST
c_func
(paren
id|scc-&gt;kiss.group
)paren
suffix:semicolon
r_case
id|PARAM_IDLE
suffix:colon
r_return
id|CAST
c_func
(paren
id|scc-&gt;kiss.idletime
)paren
suffix:semicolon
r_case
id|PARAM_MIN
suffix:colon
r_return
id|CAST
c_func
(paren
id|scc-&gt;kiss.mintime
)paren
suffix:semicolon
r_case
id|PARAM_MAXKEY
suffix:colon
r_return
id|CAST
c_func
(paren
id|scc-&gt;kiss.maxkeyup
)paren
suffix:semicolon
r_case
id|PARAM_WAIT
suffix:colon
r_return
id|CAST
c_func
(paren
id|scc-&gt;kiss.waittime
)paren
suffix:semicolon
r_case
id|PARAM_MAXDEFER
suffix:colon
r_return
id|CAST
c_func
(paren
id|scc-&gt;kiss.maxdefer
)paren
suffix:semicolon
r_case
id|PARAM_TX
suffix:colon
r_return
id|CAST
c_func
(paren
id|scc-&gt;kiss.tx_inhibit
)paren
suffix:semicolon
r_default
suffix:colon
r_return
id|NO_SUCH_PARAM
suffix:semicolon
)brace
)brace
DECL|macro|CAST
macro_line|#undef CAST
multiline_comment|/* ******************************************************************* */
multiline_comment|/* *&t;&t;&t;Send calibration pattern&t;&t;     * */
multiline_comment|/* ******************************************************************* */
DECL|function|scc_stop_calibrate
r_static
r_void
id|scc_stop_calibrate
c_func
(paren
r_int
r_int
id|channel
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
(paren
r_struct
id|scc_channel
op_star
)paren
id|channel
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|scc-&gt;tx_wdog
)paren
suffix:semicolon
id|scc_key_trx
c_func
(paren
id|scc
comma
id|TX_OFF
)paren
suffix:semicolon
id|wr
c_func
(paren
id|scc
comma
id|R6
comma
l_int|0
)paren
suffix:semicolon
id|wr
c_func
(paren
id|scc
comma
id|R7
comma
id|FLAG
)paren
suffix:semicolon
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_EXT_INT
)paren
suffix:semicolon
multiline_comment|/* reset ext/status interrupts */
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_EXT_INT
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|scc-&gt;dev
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|scc_start_calibrate
id|scc_start_calibrate
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_int
id|duration
comma
r_int
r_char
id|pattern
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|scc-&gt;dev
)paren
suffix:semicolon
id|scc_discard_buffers
c_func
(paren
id|scc
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|scc-&gt;tx_wdog
)paren
suffix:semicolon
id|scc-&gt;tx_wdog.data
op_assign
(paren
r_int
r_int
)paren
id|scc
suffix:semicolon
id|scc-&gt;tx_wdog.function
op_assign
id|scc_stop_calibrate
suffix:semicolon
id|scc-&gt;tx_wdog.expires
op_assign
id|jiffies
op_plus
id|HZ
op_star
id|duration
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|scc-&gt;tx_wdog
)paren
suffix:semicolon
multiline_comment|/* This doesn&squot;t seem to work. Why not? */
id|wr
c_func
(paren
id|scc
comma
id|R6
comma
l_int|0
)paren
suffix:semicolon
id|wr
c_func
(paren
id|scc
comma
id|R7
comma
id|pattern
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Don&squot;t know if this works. &n;&t; * Damn, where is my Z8530 programming manual...? &n;&t; */
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_EXT_INT
)paren
suffix:semicolon
multiline_comment|/* reset ext/status interrupts */
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_EXT_INT
)paren
suffix:semicolon
id|scc_key_trx
c_func
(paren
id|scc
comma
id|TX_ON
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* ******************************************************************* */
multiline_comment|/* *&t;&t;Init channel structures, special HW, etc...&t;     * */
multiline_comment|/* ******************************************************************* */
multiline_comment|/*&n; * Reset the Z8530s and setup special hardware&n; */
DECL|function|z8530_init
r_static
r_void
id|z8530_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
suffix:semicolon
r_int
id|chip
comma
id|k
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|flag
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Init Z8530 driver: %u channels, IRQ&quot;
comma
id|Nchips
op_star
l_int|2
)paren
suffix:semicolon
id|flag
op_assign
l_string|&quot; &quot;
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|16
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
id|Ivec
(braket
id|k
)braket
dot
id|used
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s%d&quot;
comma
id|flag
comma
id|k
)paren
suffix:semicolon
id|flag
op_assign
l_string|&quot;,&quot;
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* reset and pre-init all chips in the system */
r_for
c_loop
(paren
id|chip
op_assign
l_int|0
suffix:semicolon
id|chip
OL
id|Nchips
suffix:semicolon
id|chip
op_increment
)paren
(brace
id|scc
op_assign
op_amp
id|SCC_Info
(braket
l_int|2
op_star
id|chip
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scc-&gt;ctrl
)paren
r_continue
suffix:semicolon
multiline_comment|/* Special SCC cards */
r_if
c_cond
(paren
id|scc-&gt;brand
op_amp
id|EAGLE
)paren
(brace
multiline_comment|/* this is an EAGLE card */
id|Outb
c_func
(paren
id|scc-&gt;special
comma
l_int|0x08
)paren
suffix:semicolon
)brace
multiline_comment|/* enable interrupt on the board */
r_if
c_cond
(paren
id|scc-&gt;brand
op_amp
(paren
id|PC100
op_or
id|PRIMUS
)paren
)paren
(brace
multiline_comment|/* this is a PC100/PRIMUS card */
id|Outb
c_func
(paren
id|scc-&gt;special
comma
id|scc-&gt;option
)paren
suffix:semicolon
)brace
multiline_comment|/* set the MODEM mode (0x22) */
multiline_comment|/* Reset and pre-init Z8530 */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
l_int|0
)paren
suffix:semicolon
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R9
comma
id|FHWRES
)paren
suffix:semicolon
multiline_comment|/* force hardware reset */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* give it &squot;a bit&squot; more time than required */
id|wr
c_func
(paren
id|scc
comma
id|R2
comma
id|chip
op_star
l_int|16
)paren
suffix:semicolon
multiline_comment|/* interrupt vector */
id|wr
c_func
(paren
id|scc
comma
id|R9
comma
id|VIS
)paren
suffix:semicolon
multiline_comment|/* vector includes status */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|Driver_Initialized
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate device structure, err, instance, and register driver&n; */
DECL|function|scc_net_setup
r_static
r_int
id|scc_net_setup
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_int
r_char
op_star
id|name
comma
r_int
id|addev
)paren
(brace
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|dev_get
c_func
(paren
id|name
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Z8530drv: device %s already exists.&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|scc-&gt;dev
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_device
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|dev
op_assign
id|scc-&gt;dev
suffix:semicolon
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_device
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|dev-&gt;name
comma
id|name
)paren
suffix:semicolon
id|dev-&gt;priv
op_assign
(paren
r_void
op_star
)paren
id|scc
suffix:semicolon
id|dev-&gt;init
op_assign
id|scc_net_init
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addev
ques
c_cond
id|register_netdevice
c_func
(paren
id|dev
)paren
suffix:colon
id|register_netdev
c_func
(paren
id|dev
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ******************************************************************** */
multiline_comment|/* *&t;&t;&t;    Network driver methods&t;&t;      * */
multiline_comment|/* ******************************************************************** */
DECL|variable|ax25_bcast
r_static
r_int
r_char
id|ax25_bcast
(braket
id|AX25_ADDR_LEN
)braket
op_assign
(brace
l_char|&squot;Q&squot;
op_lshift
l_int|1
comma
l_char|&squot;S&squot;
op_lshift
l_int|1
comma
l_char|&squot;T&squot;
op_lshift
l_int|1
comma
l_char|&squot; &squot;
op_lshift
l_int|1
comma
l_char|&squot; &squot;
op_lshift
l_int|1
comma
l_char|&squot; &squot;
op_lshift
l_int|1
comma
l_char|&squot;0&squot;
op_lshift
l_int|1
)brace
suffix:semicolon
DECL|variable|ax25_nocall
r_static
r_int
r_char
id|ax25_nocall
(braket
id|AX25_ADDR_LEN
)braket
op_assign
(brace
l_char|&squot;L&squot;
op_lshift
l_int|1
comma
l_char|&squot;I&squot;
op_lshift
l_int|1
comma
l_char|&squot;N&squot;
op_lshift
l_int|1
comma
l_char|&squot;U&squot;
op_lshift
l_int|1
comma
l_char|&squot;X&squot;
op_lshift
l_int|1
comma
l_char|&squot; &squot;
op_lshift
l_int|1
comma
l_char|&squot;1&squot;
op_lshift
l_int|1
)brace
suffix:semicolon
multiline_comment|/* ----&gt; Initialize device &lt;----- */
DECL|function|scc_net_init
r_static
r_int
id|scc_net_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
id|dev_init_buffers
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;tx_queue_len
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* should be enough... */
id|dev-&gt;open
op_assign
id|scc_net_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|scc_net_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|scc_net_tx
suffix:semicolon
id|dev-&gt;hard_header
op_assign
id|ax25_encapsulate
suffix:semicolon
id|dev-&gt;rebuild_header
op_assign
id|ax25_rebuild_header
suffix:semicolon
id|dev-&gt;set_mac_address
op_assign
id|scc_net_set_mac_address
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|scc_net_get_stats
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
id|scc_net_ioctl
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
l_int|NULL
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;broadcast
comma
id|ax25_bcast
comma
id|AX25_ADDR_LEN
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|ax25_nocall
comma
id|AX25_ADDR_LEN
)paren
suffix:semicolon
id|dev-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;type
op_assign
id|ARPHRD_AX25
suffix:semicolon
id|dev-&gt;hard_header_len
op_assign
id|AX25_MAX_HEADER_LEN
op_plus
id|AX25_BPQ_HEADER_LEN
suffix:semicolon
id|dev-&gt;mtu
op_assign
id|AX25_DEF_PACLEN
suffix:semicolon
id|dev-&gt;addr_len
op_assign
id|AX25_ADDR_LEN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ----&gt; open network device &lt;---- */
DECL|function|scc_net_open
r_static
r_int
id|scc_net_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
(paren
r_struct
id|scc_channel
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scc-&gt;init
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|scc-&gt;tx_buff
op_assign
l_int|NULL
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|scc-&gt;tx_queue
)paren
suffix:semicolon
id|init_channel
c_func
(paren
id|scc
)paren
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ----&gt; close network device &lt;---- */
DECL|function|scc_net_close
r_static
r_int
id|scc_net_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
(paren
r_struct
id|scc_channel
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Make sure pointer is written */
id|wr
c_func
(paren
id|scc
comma
id|R1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* disable interrupts */
id|wr
c_func
(paren
id|scc
comma
id|R3
comma
l_int|0
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|scc-&gt;tx_t
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|scc-&gt;tx_wdog
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|scc_discard_buffers
c_func
(paren
id|scc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ----&gt; receive frame, called from scc_rxint() &lt;---- */
DECL|function|scc_net_rx
r_static
r_void
id|scc_net_rx
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;len
op_eq
l_int|0
)paren
(brace
id|dev_kfree_skb_irq
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|scc-&gt;dev_stat.rx_packets
op_increment
suffix:semicolon
id|skb-&gt;dev
op_assign
id|scc-&gt;dev
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_AX25
)paren
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|skb-&gt;pkt_type
op_assign
id|PACKET_HOST
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* ----&gt; transmit frame &lt;---- */
DECL|function|scc_net_tx
r_static
r_int
id|scc_net_tx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
(paren
r_struct
id|scc_channel
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_char
id|kisscmd
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|scc-&gt;stat.bufsize
op_logical_or
id|skb-&gt;len
OL
l_int|2
)paren
(brace
id|scc-&gt;dev_stat.tx_dropped
op_increment
suffix:semicolon
multiline_comment|/* bogus frame */
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|scc-&gt;dev_stat.tx_packets
op_increment
suffix:semicolon
id|scc-&gt;stat.txframes
op_increment
suffix:semicolon
id|kisscmd
op_assign
op_star
id|skb-&gt;data
op_amp
l_int|0x1f
suffix:semicolon
id|skb_pull
c_func
(paren
id|skb
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kisscmd
)paren
(brace
id|scc_set_param
c_func
(paren
id|scc
comma
id|kisscmd
comma
op_star
id|skb-&gt;data
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|scc-&gt;tx_queue
)paren
OG
id|scc-&gt;dev-&gt;tx_queue_len
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb_del
suffix:semicolon
id|skb_del
op_assign
id|skb_dequeue
c_func
(paren
op_amp
id|scc-&gt;tx_queue
)paren
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb_del
)paren
suffix:semicolon
)brace
id|skb_queue_tail
c_func
(paren
op_amp
id|scc-&gt;tx_queue
comma
id|skb
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t; * Start transmission if the trx state is idle or&n;&t; * t_idle hasn&squot;t expired yet. Use dwait/persistance/slottime&n;&t; * algorithm for normal halfduplex operation.&n;&t; */
r_if
c_cond
(paren
id|scc-&gt;stat.tx_state
op_eq
id|TXS_IDLE
op_logical_or
id|scc-&gt;stat.tx_state
op_eq
id|TXS_IDLE2
)paren
(brace
id|scc-&gt;stat.tx_state
op_assign
id|TXS_BUSY
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;kiss.fulldup
op_eq
id|KISS_DUPLEX_HALF
)paren
id|scc_start_tx_timer
c_func
(paren
id|scc
comma
id|t_dwait
comma
id|scc-&gt;kiss.waittime
)paren
suffix:semicolon
r_else
id|scc_start_tx_timer
c_func
(paren
id|scc
comma
id|t_dwait
comma
l_int|0
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ----&gt; ioctl functions &lt;---- */
multiline_comment|/*&n; * SIOCSCCCFG&t;&t;- configure driver&t;arg: (struct scc_hw_config *) arg&n; * SIOCSCCINI&t;&t;- initialize driver&t;arg: ---&n; * SIOCSCCCHANINI&t;- initialize channel&t;arg: (struct scc_modem *) arg&n; * SIOCSCCSMEM&t;&t;- set memory&t;&t;arg: (struct scc_mem_config *) arg&n; * SIOCSCCGKISS&t;&t;- get level 1 parameter&t;arg: (struct scc_kiss_cmd *) arg&n; * SIOCSCCSKISS&t;&t;- set level 1 parameter arg: (struct scc_kiss_cmd *) arg&n; * SIOCSCCGSTAT&t;&t;- get driver status&t;arg: (struct scc_stat *) arg&n; * SIOCSCCCAL&t;&t;- send calib. pattern&t;arg: (struct scc_calibrate *) arg&n; */
DECL|function|scc_net_ioctl
r_static
r_int
id|scc_net_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
(brace
r_struct
id|scc_kiss_cmd
id|kiss_cmd
suffix:semicolon
r_struct
id|scc_mem_config
id|memcfg
suffix:semicolon
r_struct
id|scc_hw_config
id|hwcfg
suffix:semicolon
r_struct
id|scc_calibrate
id|cal
suffix:semicolon
r_int
id|chan
suffix:semicolon
r_int
r_char
id|device_name
(braket
l_int|10
)braket
suffix:semicolon
r_void
op_star
id|arg
suffix:semicolon
r_struct
id|scc_channel
op_star
id|scc
suffix:semicolon
id|scc
op_assign
(paren
r_struct
id|scc_channel
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|arg
op_assign
(paren
r_void
op_star
)paren
id|ifr-&gt;ifr_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Driver_Initialized
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_eq
id|SIOCSCCCFG
)paren
(brace
r_int
id|found
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RAWIO
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|Nchips
op_ge
id|SCC_MAXCHIPS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|hwcfg
comma
id|arg
comma
r_sizeof
(paren
id|hwcfg
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|hwcfg.irq
op_eq
l_int|2
)paren
id|hwcfg.irq
op_assign
l_int|9
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Ivec
(braket
id|hwcfg.irq
)braket
dot
id|used
op_logical_and
id|hwcfg.irq
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|hwcfg.irq
comma
id|scc_isr
comma
id|SA_INTERRUPT
comma
l_string|&quot;AX.25 SCC&quot;
comma
l_int|NULL
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;z8530drv: warning, cannot get IRQ %d&bslash;n&quot;
comma
id|hwcfg.irq
)paren
suffix:semicolon
r_else
id|Ivec
(braket
id|hwcfg.irq
)braket
dot
id|used
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwcfg.vector_latch
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|Vector_Latch
comma
l_int|1
comma
l_string|&quot;scc vector latch&quot;
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;z8530drv: warning, cannot reserve vector latch port 0x%x&bslash;n, disabled.&quot;
comma
id|hwcfg.vector_latch
)paren
suffix:semicolon
r_else
id|Vector_Latch
op_assign
id|hwcfg.vector_latch
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwcfg.clock
op_eq
l_int|0
)paren
id|hwcfg.clock
op_assign
id|SCC_DEFAULT_CLOCK
suffix:semicolon
macro_line|#ifndef SCC_DONT_CHECK
id|disable_irq
c_func
(paren
id|hwcfg.irq
)paren
suffix:semicolon
id|check_region
c_func
(paren
id|scc-&gt;ctrl
comma
l_int|1
)paren
suffix:semicolon
id|Outb
c_func
(paren
id|hwcfg.ctrl_a
comma
l_int|0
)paren
suffix:semicolon
id|OutReg
c_func
(paren
id|hwcfg.ctrl_a
comma
id|R9
comma
id|FHWRES
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|OutReg
c_func
(paren
id|hwcfg.ctrl_a
comma
id|R13
comma
l_int|0x55
)paren
suffix:semicolon
multiline_comment|/* is this chip really there? */
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|InReg
c_func
(paren
id|hwcfg.ctrl_a
comma
id|R13
)paren
op_ne
l_int|0x55
)paren
id|found
op_assign
l_int|0
suffix:semicolon
id|enable_irq
c_func
(paren
id|hwcfg.irq
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|found
)paren
(brace
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
)braket
dot
id|ctrl
op_assign
id|hwcfg.ctrl_a
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
)braket
dot
id|data
op_assign
id|hwcfg.data_a
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
)braket
dot
id|irq
op_assign
id|hwcfg.irq
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
l_int|1
)braket
dot
id|ctrl
op_assign
id|hwcfg.ctrl_b
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
l_int|1
)braket
dot
id|data
op_assign
id|hwcfg.data_b
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
l_int|1
)braket
dot
id|irq
op_assign
id|hwcfg.irq
suffix:semicolon
id|SCC_ctrl
(braket
id|Nchips
)braket
dot
id|chan_A
op_assign
id|hwcfg.ctrl_a
suffix:semicolon
id|SCC_ctrl
(braket
id|Nchips
)braket
dot
id|chan_B
op_assign
id|hwcfg.ctrl_b
suffix:semicolon
id|SCC_ctrl
(braket
id|Nchips
)braket
dot
id|irq
op_assign
id|hwcfg.irq
suffix:semicolon
)brace
r_for
c_loop
(paren
id|chan
op_assign
l_int|0
suffix:semicolon
id|chan
OL
l_int|2
suffix:semicolon
id|chan
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|device_name
comma
l_string|&quot;%s%i&quot;
comma
id|SCC_DriverName
comma
l_int|2
op_star
id|Nchips
op_plus
id|chan
)paren
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
id|chan
)braket
dot
id|special
op_assign
id|hwcfg.special
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
id|chan
)braket
dot
id|clock
op_assign
id|hwcfg.clock
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
id|chan
)braket
dot
id|brand
op_assign
id|hwcfg.brand
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
id|chan
)braket
dot
id|option
op_assign
id|hwcfg.option
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
id|chan
)braket
dot
id|enhanced
op_assign
id|hwcfg.escc
suffix:semicolon
macro_line|#ifdef SCC_DONT_CHECK
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: data port = 0x%3.3x  control port = 0x%3.3x&bslash;n&quot;
comma
id|device_name
comma
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
id|chan
)braket
dot
id|data
comma
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
id|chan
)braket
dot
id|ctrl
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: data port = 0x%3.3lx  control port = 0x%3.3lx -- %s&bslash;n&quot;
comma
id|device_name
comma
id|chan
ques
c_cond
id|hwcfg.data_b
suffix:colon
id|hwcfg.data_a
comma
id|chan
ques
c_cond
id|hwcfg.ctrl_b
suffix:colon
id|hwcfg.ctrl_a
comma
id|found
ques
c_cond
l_string|&quot;found&quot;
suffix:colon
l_string|&quot;missing&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|found
)paren
(brace
id|request_region
c_func
(paren
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
id|chan
)braket
dot
id|ctrl
comma
l_int|1
comma
l_string|&quot;scc ctrl&quot;
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
id|chan
)braket
dot
id|data
comma
l_int|1
comma
l_string|&quot;scc data&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Nchips
op_plus
id|chan
op_ne
l_int|0
)paren
id|scc_net_setup
c_func
(paren
op_amp
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
id|chan
)braket
comma
id|device_name
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|found
)paren
id|Nchips
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|SIOCSCCINI
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RAWIO
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|Nchips
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|z8530_init
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* confuse the user */
)brace
r_if
c_cond
(paren
op_logical_neg
id|scc-&gt;init
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_eq
id|SIOCSCCCHANINI
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|scc-&gt;stat.bufsize
op_assign
id|SCC_BUFSIZE
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|scc-&gt;modem
comma
id|arg
comma
r_sizeof
(paren
r_struct
id|scc_modem
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* default KISS Params */
r_if
c_cond
(paren
id|scc-&gt;modem.speed
OL
l_int|4800
)paren
(brace
id|scc-&gt;kiss.txdelay
op_assign
l_int|36
suffix:semicolon
multiline_comment|/* 360 ms */
id|scc-&gt;kiss.persist
op_assign
l_int|42
suffix:semicolon
multiline_comment|/* 25% persistence */
multiline_comment|/* was 25 */
id|scc-&gt;kiss.slottime
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* 160 ms */
id|scc-&gt;kiss.tailtime
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* minimal reasonable value */
id|scc-&gt;kiss.fulldup
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* CSMA */
id|scc-&gt;kiss.waittime
op_assign
l_int|50
suffix:semicolon
multiline_comment|/* 500 ms */
id|scc-&gt;kiss.maxkeyup
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* 10 s */
id|scc-&gt;kiss.mintime
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* 3 s */
id|scc-&gt;kiss.idletime
op_assign
l_int|30
suffix:semicolon
multiline_comment|/* 30 s */
id|scc-&gt;kiss.maxdefer
op_assign
l_int|120
suffix:semicolon
multiline_comment|/* 2 min */
id|scc-&gt;kiss.softdcd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* hardware dcd */
)brace
r_else
(brace
id|scc-&gt;kiss.txdelay
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* 100 ms */
id|scc-&gt;kiss.persist
op_assign
l_int|64
suffix:semicolon
multiline_comment|/* 25% persistence */
multiline_comment|/* was 25 */
id|scc-&gt;kiss.slottime
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* 160 ms */
id|scc-&gt;kiss.tailtime
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* minimal reasonable value */
id|scc-&gt;kiss.fulldup
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* CSMA */
id|scc-&gt;kiss.waittime
op_assign
l_int|50
suffix:semicolon
multiline_comment|/* 500 ms */
id|scc-&gt;kiss.maxkeyup
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* 7 s */
id|scc-&gt;kiss.mintime
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* 3 s */
id|scc-&gt;kiss.idletime
op_assign
l_int|30
suffix:semicolon
multiline_comment|/* 30 s */
id|scc-&gt;kiss.maxdefer
op_assign
l_int|120
suffix:semicolon
multiline_comment|/* 2 min */
id|scc-&gt;kiss.softdcd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* hardware dcd */
)brace
id|scc-&gt;tx_buff
op_assign
l_int|NULL
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|scc-&gt;tx_queue
)paren
suffix:semicolon
id|scc-&gt;init
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SIOCSCCRESERVED
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
r_case
id|SIOCSCCSMEM
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RAWIO
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
op_logical_or
id|copy_from_user
c_func
(paren
op_amp
id|memcfg
comma
id|arg
comma
r_sizeof
(paren
id|memcfg
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|scc-&gt;stat.bufsize
op_assign
id|memcfg.bufsize
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSCCGSTAT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
op_logical_or
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|scc-&gt;stat
comma
r_sizeof
(paren
id|scc-&gt;stat
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSCCGKISS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
op_logical_or
id|copy_from_user
c_func
(paren
op_amp
id|kiss_cmd
comma
id|arg
comma
r_sizeof
(paren
id|kiss_cmd
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|kiss_cmd.param
op_assign
id|scc_get_param
c_func
(paren
id|scc
comma
id|kiss_cmd.command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|arg
comma
op_amp
id|kiss_cmd
comma
r_sizeof
(paren
id|kiss_cmd
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SIOCSCCSKISS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
op_logical_or
id|copy_from_user
c_func
(paren
op_amp
id|kiss_cmd
comma
id|arg
comma
r_sizeof
(paren
id|kiss_cmd
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|scc_set_param
c_func
(paren
id|scc
comma
id|kiss_cmd.command
comma
id|kiss_cmd.param
)paren
suffix:semicolon
r_case
id|SIOCSCCCAL
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RAWIO
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
op_logical_or
id|copy_from_user
c_func
(paren
op_amp
id|cal
comma
id|arg
comma
r_sizeof
(paren
id|cal
)paren
)paren
op_logical_or
id|cal.time
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|scc_start_calibrate
c_func
(paren
id|scc
comma
id|cal.time
comma
id|cal.pattern
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* ----&gt; set interface callsign &lt;---- */
DECL|function|scc_net_set_mac_address
r_static
r_int
id|scc_net_set_mac_address
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_void
op_star
id|addr
)paren
(brace
r_struct
id|sockaddr
op_star
id|sa
op_assign
(paren
r_struct
id|sockaddr
op_star
)paren
id|addr
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|sa-&gt;sa_data
comma
id|dev-&gt;addr_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ----&gt; get statistics &lt;---- */
DECL|function|scc_net_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|scc_net_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
(paren
r_struct
id|scc_channel
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|scc-&gt;dev_stat.rx_errors
op_assign
id|scc-&gt;stat.rxerrs
op_plus
id|scc-&gt;stat.rx_over
suffix:semicolon
id|scc-&gt;dev_stat.tx_errors
op_assign
id|scc-&gt;stat.txerrs
op_plus
id|scc-&gt;stat.tx_under
suffix:semicolon
id|scc-&gt;dev_stat.rx_fifo_errors
op_assign
id|scc-&gt;stat.rx_over
suffix:semicolon
id|scc-&gt;dev_stat.tx_fifo_errors
op_assign
id|scc-&gt;stat.tx_under
suffix:semicolon
r_return
op_amp
id|scc-&gt;dev_stat
suffix:semicolon
)brace
multiline_comment|/* ******************************************************************** */
multiline_comment|/* *&t;&t;dump statistics to /proc/net/z8530drv&t;&t;      * */
multiline_comment|/* ******************************************************************** */
DECL|function|scc_net_get_info
r_static
r_int
id|scc_net_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
suffix:semicolon
r_struct
id|scc_kiss
op_star
id|kiss
suffix:semicolon
r_struct
id|scc_stat
op_star
id|stat
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
r_int
id|k
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;z8530drv-&quot;
id|VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Driver_Initialized
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;not initialized&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|Nchips
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;chips missing&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|Nchips
op_star
l_int|2
suffix:semicolon
id|k
op_increment
)paren
(brace
id|scc
op_assign
op_amp
id|SCC_Info
(braket
id|k
)braket
suffix:semicolon
id|stat
op_assign
op_amp
id|scc-&gt;stat
suffix:semicolon
id|kiss
op_assign
op_amp
id|scc-&gt;kiss
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scc-&gt;init
)paren
r_continue
suffix:semicolon
multiline_comment|/* dev&t;data ctrl irq clock brand enh vector special option &n;&t;&t; *&t;baud nrz clocksrc softdcd bufsize&n;&t;&t; *&t;rxints txints exints spints&n;&t;&t; *&t;rcvd rxerrs over / xmit txerrs under / nospace bufsize&n;&t;&t; *&t;txd pers slot tail ful wait min maxk idl defr txof grp&n;&t;&t; *&t;W ## ## ## ## ## ## ## ## ## ## ## ## ## ## ## ##&n;&t;&t; *&t;R ## ## XX ## ## ## ## ## XX ## ## ## ## ## ## ##&n;&t;&t; */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%s&bslash;t%3.3lx %3.3lx %d %lu %2.2x %d %3.3lx %3.3lx %d&bslash;n&quot;
comma
id|scc-&gt;dev-&gt;name
comma
id|scc-&gt;data
comma
id|scc-&gt;ctrl
comma
id|scc-&gt;irq
comma
id|scc-&gt;clock
comma
id|scc-&gt;brand
comma
id|scc-&gt;enhanced
comma
id|Vector_Latch
comma
id|scc-&gt;special
comma
id|scc-&gt;option
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;t%lu %d %d %d %d&bslash;n&quot;
comma
id|scc-&gt;modem.speed
comma
id|scc-&gt;modem.nrz
comma
id|scc-&gt;modem.clocksrc
comma
id|kiss-&gt;softdcd
comma
id|stat-&gt;bufsize
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;t%lu %lu %lu %lu&bslash;n&quot;
comma
id|stat-&gt;rxints
comma
id|stat-&gt;txints
comma
id|stat-&gt;exints
comma
id|stat-&gt;spints
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;t%lu %lu %d / %lu %lu %d / %d %d&bslash;n&quot;
comma
id|stat-&gt;rxframes
comma
id|stat-&gt;rxerrs
comma
id|stat-&gt;rx_over
comma
id|stat-&gt;txframes
comma
id|stat-&gt;txerrs
comma
id|stat-&gt;tx_under
comma
id|stat-&gt;nospace
comma
id|stat-&gt;tx_state
)paren
suffix:semicolon
DECL|macro|K
mdefine_line|#define K(x) kiss-&gt;x
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;t%d %d %d %d %d %d %d %d %d %d %d %d&bslash;n&quot;
comma
id|K
c_func
(paren
id|txdelay
)paren
comma
id|K
c_func
(paren
id|persist
)paren
comma
id|K
c_func
(paren
id|slottime
)paren
comma
id|K
c_func
(paren
id|tailtime
)paren
comma
id|K
c_func
(paren
id|fulldup
)paren
comma
id|K
c_func
(paren
id|waittime
)paren
comma
id|K
c_func
(paren
id|mintime
)paren
comma
id|K
c_func
(paren
id|maxkeyup
)paren
comma
id|K
c_func
(paren
id|idletime
)paren
comma
id|K
c_func
(paren
id|maxdefer
)paren
comma
id|K
c_func
(paren
id|tx_inhibit
)paren
comma
id|K
c_func
(paren
id|group
)paren
)paren
suffix:semicolon
DECL|macro|K
macro_line|#undef K
macro_line|#ifdef SCC_DEBUG
(brace
r_int
id|reg
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;tW &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|reg
op_assign
l_int|0
suffix:semicolon
id|reg
OL
l_int|16
suffix:semicolon
id|reg
op_increment
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%2.2x &quot;
comma
id|scc-&gt;wreg
(braket
id|reg
)braket
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;tR %2.2x %2.2x XX &quot;
comma
id|InReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R0
)paren
comma
id|InReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R1
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|reg
op_assign
l_int|3
suffix:semicolon
id|reg
OL
l_int|8
suffix:semicolon
id|reg
op_increment
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%2.2x &quot;
comma
id|InReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|reg
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;XX &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|reg
op_assign
l_int|9
suffix:semicolon
id|reg
OL
l_int|16
suffix:semicolon
id|reg
op_increment
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%2.2x &quot;
comma
id|InReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|reg
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
r_break
suffix:semicolon
)brace
id|done
suffix:colon
op_star
id|start
op_assign
id|buffer
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/* ******************************************************************** */
multiline_comment|/* * &t;&t;&t;Init SCC driver &t;&t;&t;      * */
multiline_comment|/* ******************************************************************** */
DECL|function|scc_init_driver
r_static
r_int
id|__init
id|scc_init_driver
(paren
r_void
)paren
(brace
r_int
id|result
suffix:semicolon
r_char
id|devname
(braket
l_int|10
)braket
suffix:semicolon
id|printk
c_func
(paren
id|banner
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|devname
comma
l_string|&quot;%s0&quot;
comma
id|SCC_DriverName
)paren
suffix:semicolon
id|result
op_assign
id|scc_net_setup
c_func
(paren
id|SCC_Info
comma
id|devname
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;z8530drv: cannot initialize module&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|proc_net_create
c_func
(paren
l_string|&quot;z8530drv&quot;
comma
l_int|0
comma
id|scc_net_get_info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scc_cleanup_driver
r_static
r_void
id|__exit
id|scc_cleanup_driver
c_func
(paren
r_void
)paren
(brace
r_int
id|flags
suffix:semicolon
id|io_port
id|ctrl
suffix:semicolon
r_int
id|k
suffix:semicolon
r_struct
id|scc_channel
op_star
id|scc
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Nchips
op_eq
l_int|0
)paren
(brace
id|unregister_netdev
c_func
(paren
id|SCC_Info
(braket
l_int|0
)braket
dot
id|dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|SCC_Info
(braket
l_int|0
)braket
dot
id|dev
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|Nchips
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
(paren
id|ctrl
op_assign
id|SCC_ctrl
(braket
id|k
)braket
dot
id|chan_A
)paren
)paren
(brace
id|Outb
c_func
(paren
id|ctrl
comma
l_int|0
)paren
suffix:semicolon
id|OutReg
c_func
(paren
id|ctrl
comma
id|R9
comma
id|FHWRES
)paren
suffix:semicolon
multiline_comment|/* force hardware reset */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|Nchips
op_star
l_int|2
suffix:semicolon
id|k
op_increment
)paren
(brace
id|scc
op_assign
op_amp
id|SCC_Info
(braket
id|k
)braket
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;ctrl
)paren
(brace
id|release_region
c_func
(paren
id|scc-&gt;ctrl
comma
l_int|1
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|scc-&gt;data
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scc-&gt;dev
)paren
(brace
id|unregister_netdev
c_func
(paren
id|scc-&gt;dev
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|scc-&gt;dev
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|16
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
id|Ivec
(braket
id|k
)braket
dot
id|used
)paren
id|free_irq
c_func
(paren
id|k
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Vector_Latch
)paren
id|release_region
c_func
(paren
id|Vector_Latch
comma
l_int|1
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|proc_net_remove
c_func
(paren
l_string|&quot;z8530drv&quot;
)paren
suffix:semicolon
)brace
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Joerg Reuter &lt;jreuter@yaina.de&gt;&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;AX.25 Device Driver for Z8530 based HDLC cards&quot;
)paren
suffix:semicolon
id|MODULE_SUPPORTED_DEVICE
c_func
(paren
l_string|&quot;Z8530 based SCC cards for Amateur Radio&quot;
)paren
suffix:semicolon
DECL|variable|scc_init_driver
id|module_init
c_func
(paren
id|scc_init_driver
)paren
suffix:semicolon
DECL|variable|scc_cleanup_driver
id|module_exit
c_func
(paren
id|scc_cleanup_driver
)paren
suffix:semicolon
eof
