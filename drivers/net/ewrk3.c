multiline_comment|/*  ewrk3.c: A DIGITAL EtherWORKS 3 ethernet driver for Linux.&n;&n;   Written 1994 by David C. Davies.&n;&n;   Copyright 1994 Digital Equipment Corporation.&n;&n;   This software may be used and distributed according to the terms of&n;   the GNU Public License, incorporated herein by reference.&n;&n;   This driver is written for the Digital Equipment Corporation series&n;   of EtherWORKS ethernet cards:&n;&n;   DE203 Turbo (BNC)&n;   DE204 Turbo (TP)&n;   DE205 Turbo (TP BNC)&n;&n;   The driver has been tested on a relatively busy  network using the DE205&n;   card and benchmarked with &squot;ttcp&squot;: it transferred 16M  of data at 975kB/s&n;   (7.8Mb/s) to a DECstation 5000/200.&n;&n;   The author may be reached at davies@maniac.ultranet.com.&n;&n;   =========================================================================&n;   This driver has been written  substantially  from scratch, although  its&n;   inheritance of style and stack interface from &squot;depca.c&squot; and in turn from&n;   Donald Becker&squot;s &squot;lance.c&squot; should be obvious.&n;&n;   The  DE203/4/5 boards  all  use a new proprietary   chip in place of the&n;   LANCE chip used in prior cards  (DEPCA, DE100, DE200/1/2, DE210, DE422).&n;   Use the depca.c driver in the standard distribution  for the LANCE based&n;   cards from DIGITAL; this driver will not work with them.&n;&n;   The DE203/4/5 cards have 2  main modes: shared memory  and I/O only. I/O&n;   only makes  all the card accesses through  I/O transactions and  no high&n;   (shared)  memory is used. This  mode provides a &gt;48% performance penalty&n;   and  is deprecated in this  driver,  although allowed to provide initial&n;   setup when hardstrapped.&n;&n;   The shared memory mode comes in 3 flavours: 2kB, 32kB and 64kB. There is&n;   no point in using any mode other than the 2kB  mode - their performances&n;   are virtually identical, although the driver has  been tested in the 2kB&n;   and 32kB modes. I would suggest you uncomment the line:&n;&n;   FORCE_2K_MODE;&n;&n;   to allow the driver to configure the card as a  2kB card at your current&n;   base  address, thus leaving more  room to clutter  your  system box with&n;   other memory hungry boards.&n;&n;   As many ISA  and EISA cards  can be supported  under this driver  as you&n;   wish, limited primarily  by the available IRQ lines,  rather than by the&n;   available I/O addresses  (24 ISA,  16 EISA).   I have  checked different&n;   configurations of  multiple  depca cards and  ewrk3 cards  and have  not&n;   found a problem yet (provided you have at least depca.c v0.38) ...&n;&n;   The board IRQ setting   must be at  an unused  IRQ which is  auto-probed&n;   using  Donald  Becker&squot;s autoprobe  routines.   All  these cards   are at&n;   {5,10,11,15}.&n;&n;   No 16MB memory  limitation should exist with this  driver as DMA is  not&n;   used and the common memory area is in low memory on the network card (my&n;   current system has 20MB and I&squot;ve not had problems yet).&n;&n;   The ability to load  this driver as a  loadable module has been included&n;   and used  extensively during the  driver development (to save those long&n;   reboot sequences). To utilise this ability, you have to do 8 things:&n;&n;   0) have a copy of the loadable modules code installed on your system.&n;   1) copy ewrk3.c from the  /linux/drivers/net directory to your favourite&n;   temporary directory.&n;   2) edit the  source code near  line 1898 to reflect  the I/O address and&n;   IRQ you&squot;re using.&n;   3) compile  ewrk3.c, but include -DMODULE in  the command line to ensure&n;   that the correct bits are compiled (see end of source code).&n;   4) if you are wanting to add a new  card, goto 5. Otherwise, recompile a&n;   kernel with the ewrk3 configuration turned off and reboot.&n;   5) insmod ewrk3.o&n;   [Alan Cox: Changed this so you can insmod ewrk3.o irq=x io=y]&n;   6) run the net startup bits for your new eth?? interface manually&n;   (usually /etc/rc.inet[12] at boot time).&n;   7) enjoy!&n;&n;   Note that autoprobing is not allowed in loadable modules - the system is&n;   already up and running and you&squot;re messing with interrupts.&n;&n;   To unload a module, turn off the associated interface&n;   &squot;ifconfig eth?? down&squot; then &squot;rmmod ewrk3&squot;.&n;&n;   Promiscuous   mode has been  turned  off  in this driver,   but  all the&n;   multicast  address bits  have been   turned on. This  improved the  send&n;   performance on a busy network by about 13%.&n;&n;   Ioctl&squot;s have now been provided (primarily because  I wanted to grab some&n;   packet size statistics). They  are patterned after &squot;plipconfig.c&squot; from a&n;   suggestion by Alan Cox.  Using these  ioctls, you can enable promiscuous&n;   mode, add/delete multicast  addresses, change the hardware address,  get&n;   packet size distribution statistics and muck around with the control and&n;   status register. I&squot;ll add others if and when the need arises.&n;&n;   TO DO:&n;   ------&n;&n;&n;   Revision History&n;   ----------------&n;&n;   Version   Date        Description&n;&n;   0.1     26-aug-94   Initial writing. ALPHA code release.&n;   0.11    31-aug-94   Fixed: 2k mode memory base calc.,&n;   LeMAC version calc.,&n;   IRQ vector assignments during autoprobe.&n;   0.12    31-aug-94   Tested working on LeMAC2 (DE20[345]-AC) card.&n;   Fixed up MCA hash table algorithm.&n;   0.20     4-sep-94   Added IOCTL functionality.&n;   0.21    14-sep-94   Added I/O mode.&n;   0.21axp 15-sep-94   Special version for ALPHA AXP Linux V1.0.&n;   0.22    16-sep-94   Added more IOCTLs &amp; tidied up.&n;   0.23    21-sep-94   Added transmit cut through.&n;   0.24    31-oct-94   Added uid checks in some ioctls.&n;   0.30     1-nov-94   BETA code release.&n;   0.31     5-dec-94   Added check/allocate region code.&n;   0.32    16-jan-95   Broadcast packet fix.&n;   0.33    10-Feb-95   Fix recognition bug reported by &lt;bkm@star.rl.ac.uk&gt;.&n;   0.40    27-Dec-95   Rationalise MODULE and autoprobe code.&n;   Rewrite for portability &amp; updated.&n;   ALPHA support from &lt;jestabro@amt.tay1.dec.com&gt;&n;   Added verify_area() calls in ewrk3_ioctl() from&n;   suggestion by &lt;heiko@colossus.escape.de&gt;.&n;   Add new multicasting code.&n;   0.41    20-Jan-96   Fix IRQ set up problem reported by&n;   &lt;kenneth@bbs.sas.ntu.ac.sg&gt;.&n;   0.42    22-Apr-96      Fix alloc_device() bug &lt;jari@markkus2.fimr.fi&gt;&n;   0.43    16-Aug-96      Update alloc_device() to conform to de4x5.c&n;&n;   =========================================================================&n; */
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;ewrk3.c:v0.43 96/8/16 davies@maniac.ultranet.com&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &quot;ewrk3.h&quot;
macro_line|#ifdef EWRK3_DEBUG
DECL|variable|ewrk3_debug
r_static
r_int
id|ewrk3_debug
op_assign
id|EWRK3_DEBUG
suffix:semicolon
macro_line|#else
DECL|variable|ewrk3_debug
r_static
r_int
id|ewrk3_debug
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
DECL|macro|EWRK3_NDA
mdefine_line|#define EWRK3_NDA 0xffe0&t;/* No Device Address */
DECL|macro|PROBE_LENGTH
mdefine_line|#define PROBE_LENGTH    32
DECL|macro|ETH_PROM_SIG
mdefine_line|#define ETH_PROM_SIG    0xAA5500FFUL
macro_line|#ifndef EWRK3_SIGNATURE
DECL|macro|EWRK3_SIGNATURE
mdefine_line|#define EWRK3_SIGNATURE {&quot;DE203&quot;,&quot;DE204&quot;,&quot;DE205&quot;,&quot;&quot;}
DECL|macro|EWRK3_STRLEN
mdefine_line|#define EWRK3_STRLEN 8
macro_line|#endif
macro_line|#ifndef EWRK3_RAM_BASE_ADDRESSES
DECL|macro|EWRK3_RAM_BASE_ADDRESSES
mdefine_line|#define EWRK3_RAM_BASE_ADDRESSES {0xc0000,0xd0000,0x00000}
macro_line|#endif
multiline_comment|/*&n;   ** Sets up the I/O area for the autoprobe.&n; */
DECL|macro|EWRK3_IO_BASE
mdefine_line|#define EWRK3_IO_BASE 0x100&t;/* Start address for probe search */
DECL|macro|EWRK3_IOP_INC
mdefine_line|#define EWRK3_IOP_INC 0x20&t;/* I/O address increment */
DECL|macro|EWRK3_TOTAL_SIZE
mdefine_line|#define EWRK3_TOTAL_SIZE 0x20&t;/* required I/O address length */
macro_line|#ifndef MAX_NUM_EWRK3S
DECL|macro|MAX_NUM_EWRK3S
mdefine_line|#define MAX_NUM_EWRK3S 21
macro_line|#endif
macro_line|#ifndef EWRK3_EISA_IO_PORTS
DECL|macro|EWRK3_EISA_IO_PORTS
mdefine_line|#define EWRK3_EISA_IO_PORTS 0x0c00&t;/* I/O port base address, slot 0 */
macro_line|#endif
macro_line|#ifndef MAX_EISA_SLOTS
DECL|macro|MAX_EISA_SLOTS
mdefine_line|#define MAX_EISA_SLOTS 16
DECL|macro|EISA_SLOT_INC
mdefine_line|#define EISA_SLOT_INC 0x1000
macro_line|#endif
DECL|macro|CRC_POLYNOMIAL_BE
mdefine_line|#define CRC_POLYNOMIAL_BE 0x04c11db7UL&t;/* Ethernet CRC, big endian */
DECL|macro|CRC_POLYNOMIAL_LE
mdefine_line|#define CRC_POLYNOMIAL_LE 0xedb88320UL&t;/* Ethernet CRC, little endian */
DECL|macro|QUEUE_PKT_TIMEOUT
mdefine_line|#define QUEUE_PKT_TIMEOUT (1*HZ)&t;/* Jiffies */
multiline_comment|/*&n;   ** EtherWORKS 3 shared memory window sizes&n; */
DECL|macro|IO_ONLY
mdefine_line|#define IO_ONLY         0x00
DECL|macro|SHMEM_2K
mdefine_line|#define SHMEM_2K        0x800
DECL|macro|SHMEM_32K
mdefine_line|#define SHMEM_32K       0x8000
DECL|macro|SHMEM_64K
mdefine_line|#define SHMEM_64K       0x10000
multiline_comment|/*&n;   ** EtherWORKS 3 IRQ ENABLE/DISABLE&n; */
DECL|macro|ENABLE_IRQs
mdefine_line|#define ENABLE_IRQs { &bslash;&n;  icr |= lp-&gt;irq_mask;&bslash;&n;  outb(icr, EWRK3_ICR);                     /* Enable the IRQs */&bslash;&n;}
DECL|macro|DISABLE_IRQs
mdefine_line|#define DISABLE_IRQs { &bslash;&n;  icr = inb(EWRK3_ICR);&bslash;&n;  icr &amp;= ~lp-&gt;irq_mask;&bslash;&n;  outb(icr, EWRK3_ICR);                     /* Disable the IRQs */&bslash;&n;}
multiline_comment|/*&n;   ** EtherWORKS 3 START/STOP&n; */
DECL|macro|START_EWRK3
mdefine_line|#define START_EWRK3 { &bslash;&n;  csr = inb(EWRK3_CSR);&bslash;&n;  csr &amp;= ~(CSR_TXD|CSR_RXD);&bslash;&n;  outb(csr, EWRK3_CSR);                     /* Enable the TX and/or RX */&bslash;&n;}
DECL|macro|STOP_EWRK3
mdefine_line|#define STOP_EWRK3 { &bslash;&n;  csr = (CSR_TXD|CSR_RXD);&bslash;&n;  outb(csr, EWRK3_CSR);                     /* Disable the TX and/or RX */&bslash;&n;}
multiline_comment|/*&n;   ** The EtherWORKS 3 private structure&n; */
DECL|macro|EWRK3_PKT_STAT_SZ
mdefine_line|#define EWRK3_PKT_STAT_SZ 16
DECL|macro|EWRK3_PKT_BIN_SZ
mdefine_line|#define EWRK3_PKT_BIN_SZ  128&t;/* Should be &gt;=100 unless you&n;&t;&t;&t;&t;   increase EWRK3_PKT_STAT_SZ */
DECL|struct|ewrk3_private
r_struct
id|ewrk3_private
(brace
DECL|member|adapter_name
r_char
id|adapter_name
(braket
l_int|80
)braket
suffix:semicolon
multiline_comment|/* Name exported to /proc/ioports */
DECL|member|shmem_base
id|u_long
id|shmem_base
suffix:semicolon
multiline_comment|/* Shared memory start address */
DECL|member|shmem_length
id|u_long
id|shmem_length
suffix:semicolon
multiline_comment|/* Shared memory window length */
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
multiline_comment|/* Public stats */
r_struct
(brace
DECL|member|bins
id|u32
id|bins
(braket
id|EWRK3_PKT_STAT_SZ
)braket
suffix:semicolon
multiline_comment|/* Private stats counters */
DECL|member|unicast
id|u32
id|unicast
suffix:semicolon
DECL|member|multicast
id|u32
id|multicast
suffix:semicolon
DECL|member|broadcast
id|u32
id|broadcast
suffix:semicolon
DECL|member|excessive_collisions
id|u32
id|excessive_collisions
suffix:semicolon
DECL|member|tx_underruns
id|u32
id|tx_underruns
suffix:semicolon
DECL|member|excessive_underruns
id|u32
id|excessive_underruns
suffix:semicolon
DECL|member|pktStats
)brace
id|pktStats
suffix:semicolon
DECL|member|irq_mask
id|u_char
id|irq_mask
suffix:semicolon
multiline_comment|/* Adapter IRQ mask bits */
DECL|member|mPage
id|u_char
id|mPage
suffix:semicolon
multiline_comment|/* Maximum 2kB Page number */
DECL|member|lemac
id|u_char
id|lemac
suffix:semicolon
multiline_comment|/* Chip rev. level */
DECL|member|hard_strapped
id|u_char
id|hard_strapped
suffix:semicolon
multiline_comment|/* Don&squot;t allow a full open */
DECL|member|lock
id|u_char
id|lock
suffix:semicolon
multiline_comment|/* Lock the page register */
DECL|member|txc
id|u_char
id|txc
suffix:semicolon
multiline_comment|/* Transmit cut through */
DECL|member|mctbl
id|u_char
op_star
id|mctbl
suffix:semicolon
multiline_comment|/* Pointer to the multicast table */
)brace
suffix:semicolon
multiline_comment|/*&n;   ** Force the EtherWORKS 3 card to be in 2kB MODE&n; */
DECL|macro|FORCE_2K_MODE
mdefine_line|#define FORCE_2K_MODE { &bslash;&n;  shmem_length = SHMEM_2K;&bslash;&n;  outb(((mem_start - 0x80000) &gt;&gt; 11), EWRK3_MBR);&bslash;&n;}
multiline_comment|/*&n;   ** Public Functions&n; */
r_static
r_int
id|ewrk3_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|ewrk3_queue_pkt
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|ewrk3_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|ewrk3_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|ewrk3_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|ewrk3_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;   ** Private functions&n; */
r_static
r_int
id|ewrk3_hw_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
suffix:semicolon
r_static
r_void
id|ewrk3_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|ewrk3_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|ewrk3_tx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|ewrk3_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|EthwrkSignature
c_func
(paren
r_char
op_star
id|name
comma
r_char
op_star
id|eeprom_image
)paren
suffix:semicolon
r_static
r_int
id|DevicePresent
c_func
(paren
id|u_long
id|iobase
)paren
suffix:semicolon
r_static
r_void
id|SetMulticastFilter
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|EISA_signature
c_func
(paren
r_char
op_star
id|name
comma
id|s32
id|eisa_id
)paren
suffix:semicolon
r_static
r_int
id|Read_EEPROM
c_func
(paren
id|u_long
id|iobase
comma
id|u_char
id|eaddr
)paren
suffix:semicolon
r_static
r_int
id|Write_EEPROM
c_func
(paren
r_int
id|data
comma
id|u_long
id|iobase
comma
id|u_char
id|eaddr
)paren
suffix:semicolon
r_static
id|u_char
id|get_hw_addr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
op_star
id|eeprom_image
comma
r_char
id|chipType
)paren
suffix:semicolon
r_static
r_void
id|isa_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
suffix:semicolon
r_static
r_void
id|eisa_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
suffix:semicolon
r_static
r_struct
id|net_device
op_star
id|alloc_device
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
suffix:semicolon
r_static
r_int
id|ewrk3_dev_index
c_func
(paren
r_char
op_star
id|s
)paren
suffix:semicolon
r_static
r_struct
id|net_device
op_star
id|insert_device
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
comma
r_int
(paren
op_star
id|init
)paren
(paren
r_struct
id|net_device
op_star
)paren
)paren
suffix:semicolon
macro_line|#ifdef MODULE
r_int
id|init_module
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|autoprobed
DECL|variable|loading_module
r_static
r_int
id|autoprobed
op_assign
l_int|1
comma
id|loading_module
op_assign
l_int|1
suffix:semicolon
macro_line|#else
DECL|variable|irq
r_static
id|u_char
id|irq
(braket
)braket
op_assign
(brace
l_int|5
comma
l_int|0
comma
l_int|10
comma
l_int|3
comma
l_int|11
comma
l_int|9
comma
l_int|15
comma
l_int|12
)brace
suffix:semicolon
DECL|variable|autoprobed
DECL|variable|loading_module
r_static
r_int
id|autoprobed
op_assign
l_int|0
comma
id|loading_module
op_assign
l_int|0
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* MODULE */
DECL|variable|name
r_static
r_char
id|name
(braket
id|EWRK3_STRLEN
op_plus
l_int|1
)braket
suffix:semicolon
DECL|variable|num_ewrk3s
DECL|variable|num_eth
r_static
r_int
id|num_ewrk3s
op_assign
l_int|0
comma
id|num_eth
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;   ** Miscellaneous defines...&n; */
DECL|macro|INIT_EWRK3
mdefine_line|#define INIT_EWRK3 {&bslash;&n;    outb(EEPROM_INIT, EWRK3_IOPR);&bslash;&n;    mdelay(1);&bslash;&n;}
DECL|function|ewrk3_probe
r_int
id|__init
id|ewrk3_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|tmp
op_assign
id|num_ewrk3s
comma
id|status
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iobase
op_eq
l_int|0
)paren
op_logical_and
id|loading_module
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Autoprobing is not supported when loading a module based driver.&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* First probe for the Ethernet */
multiline_comment|/* Address PROM pattern */
id|isa_probe
c_func
(paren
id|dev
comma
id|iobase
)paren
suffix:semicolon
id|eisa_probe
c_func
(paren
id|dev
comma
id|iobase
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_eq
id|num_ewrk3s
)paren
op_logical_and
(paren
id|iobase
op_ne
l_int|0
)paren
op_logical_and
id|loading_module
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: ewrk3_probe() cannot find device at 0x%04lx.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|iobase
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;   ** Walk the device list to check that at least one device&n;&t;&t;   ** initialised OK&n;&t;&t; */
r_for
c_loop
(paren
suffix:semicolon
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|dev-&gt;next
op_ne
l_int|NULL
)paren
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
)paren
id|status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|iobase
op_eq
l_int|0
)paren
id|autoprobed
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|ewrk3_hw_init
id|ewrk3_hw_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
suffix:semicolon
r_int
id|i
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|u_long
id|mem_start
comma
id|shmem_length
suffix:semicolon
id|u_char
id|cr
comma
id|cmr
comma
id|icr
comma
id|nicsr
comma
id|lemac
comma
id|hard_strapped
op_assign
l_int|0
suffix:semicolon
id|u_char
id|eeprom_image
(braket
id|EEPROM_MAX
)braket
comma
id|chksum
comma
id|eisa_cr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;   ** Stop the EWRK3. Enable the DBR ROM. Disable interrupts and remote boot.&n;&t;   ** This also disables the EISA_ENABLE bit in the EISA Control Register.&n;&t; */
r_if
c_cond
(paren
id|iobase
OG
l_int|0x400
)paren
id|eisa_cr
op_assign
id|inb
c_func
(paren
id|EISA_CR
)paren
suffix:semicolon
id|INIT_EWRK3
suffix:semicolon
id|nicsr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
id|icr
op_assign
id|inb
c_func
(paren
id|EWRK3_ICR
)paren
suffix:semicolon
id|icr
op_and_assign
l_int|0x70
suffix:semicolon
id|outb
c_func
(paren
id|icr
comma
id|EWRK3_ICR
)paren
suffix:semicolon
multiline_comment|/* Disable all the IRQs */
r_if
c_cond
(paren
id|nicsr
op_eq
(paren
id|CSR_TXD
op_or
id|CSR_RXD
)paren
)paren
(brace
multiline_comment|/* Check that the EEPROM is alive and well and not living on Pluto... */
r_for
c_loop
(paren
id|chksum
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|EEPROM_MAX
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
r_union
(brace
r_int
id|val
suffix:semicolon
r_char
id|c
(braket
l_int|2
)braket
suffix:semicolon
)brace
id|tmp
suffix:semicolon
id|tmp.val
op_assign
(paren
r_int
)paren
id|Read_EEPROM
c_func
(paren
id|iobase
comma
(paren
id|i
op_rshift
l_int|1
)paren
)paren
suffix:semicolon
id|eeprom_image
(braket
id|i
)braket
op_assign
id|tmp.c
(braket
l_int|0
)braket
suffix:semicolon
id|eeprom_image
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|tmp.c
(braket
l_int|1
)braket
suffix:semicolon
id|chksum
op_add_assign
id|eeprom_image
(braket
id|i
)braket
op_plus
id|eeprom_image
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chksum
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Bad EEPROM Data! */
id|printk
c_func
(paren
l_string|&quot;%s: Device has a bad on-board EEPROM.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
r_else
(brace
id|EthwrkSignature
c_func
(paren
id|name
comma
id|eeprom_image
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|name
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
multiline_comment|/* found a EWRK3 device */
id|dev-&gt;base_addr
op_assign
id|iobase
suffix:semicolon
r_if
c_cond
(paren
id|iobase
OG
l_int|0x400
)paren
(brace
id|outb
c_func
(paren
id|eisa_cr
comma
id|EISA_CR
)paren
suffix:semicolon
multiline_comment|/* Rewrite the EISA CR */
)brace
id|lemac
op_assign
id|eeprom_image
(braket
id|EEPROM_CHIPVER
)braket
suffix:semicolon
id|cmr
op_assign
id|inb
c_func
(paren
id|EWRK3_CMR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|lemac
op_eq
id|LeMAC
)paren
op_logical_and
(paren
(paren
id|cmr
op_amp
id|CMR_NO_EEPROM
)paren
op_ne
id|CMR_NO_EEPROM
)paren
)paren
op_logical_or
(paren
(paren
id|lemac
op_eq
id|LeMAC2
)paren
op_logical_and
op_logical_neg
(paren
id|cmr
op_amp
id|CMR_HS
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s at %#4lx&quot;
comma
id|dev-&gt;name
comma
id|name
comma
id|iobase
)paren
suffix:semicolon
id|hard_strapped
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|iobase
op_amp
l_int|0x0fff
)paren
op_eq
id|EWRK3_EISA_IO_PORTS
)paren
(brace
multiline_comment|/* EISA slot address */
id|printk
c_func
(paren
l_string|&quot;%s: %s at %#4lx (EISA slot %ld)&quot;
comma
id|dev-&gt;name
comma
id|name
comma
id|iobase
comma
(paren
(paren
id|iobase
op_rshift
l_int|12
)paren
op_amp
l_int|0x0f
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ISA port address */
id|printk
c_func
(paren
l_string|&quot;%s: %s at %#4lx&quot;
comma
id|dev-&gt;name
comma
id|name
comma
id|iobase
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, h/w address &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lemac
op_ne
id|LeMAC2
)paren
id|DevicePresent
c_func
(paren
id|iobase
)paren
suffix:semicolon
multiline_comment|/* need after EWRK3_INIT */
id|status
op_assign
id|get_hw_addr
c_func
(paren
id|dev
comma
id|eeprom_image
comma
id|lemac
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* get the ethernet addr. */
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%2.2x,&bslash;n&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;      which has an EEPROM CRC error.&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|lemac
op_eq
id|LeMAC2
)paren
(brace
multiline_comment|/* Special LeMAC2 CMR things */
id|cmr
op_and_assign
op_complement
(paren
id|CMR_RA
op_or
id|CMR_WB
op_or
id|CMR_LINK
op_or
id|CMR_POLARITY
op_or
id|CMR_0WS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_image
(braket
id|EEPROM_MISC0
)braket
op_amp
id|READ_AHEAD
)paren
id|cmr
op_or_assign
id|CMR_RA
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_image
(braket
id|EEPROM_MISC0
)braket
op_amp
id|WRITE_BEHIND
)paren
id|cmr
op_or_assign
id|CMR_WB
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_image
(braket
id|EEPROM_NETMAN0
)braket
op_amp
id|NETMAN_POL
)paren
id|cmr
op_or_assign
id|CMR_POLARITY
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_image
(braket
id|EEPROM_NETMAN0
)braket
op_amp
id|NETMAN_LINK
)paren
id|cmr
op_or_assign
id|CMR_LINK
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_image
(braket
id|EEPROM_MISC0
)braket
op_amp
id|_0WS_ENA
)paren
id|cmr
op_or_assign
id|CMR_0WS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eeprom_image
(braket
id|EEPROM_SETUP
)braket
op_amp
id|SETUP_DRAM
)paren
id|cmr
op_or_assign
id|CMR_DRAM
suffix:semicolon
id|outb
c_func
(paren
id|cmr
comma
id|EWRK3_CMR
)paren
suffix:semicolon
id|cr
op_assign
id|inb
c_func
(paren
id|EWRK3_CR
)paren
suffix:semicolon
multiline_comment|/* Set up the Control Register */
id|cr
op_or_assign
id|eeprom_image
(braket
id|EEPROM_SETUP
)braket
op_amp
id|SETUP_APD
suffix:semicolon
r_if
c_cond
(paren
id|cr
op_amp
id|SETUP_APD
)paren
id|cr
op_or_assign
id|eeprom_image
(braket
id|EEPROM_SETUP
)braket
op_amp
id|SETUP_PS
suffix:semicolon
id|cr
op_or_assign
id|eeprom_image
(braket
id|EEPROM_MISC0
)braket
op_amp
id|FAST_BUS
suffix:semicolon
id|cr
op_or_assign
id|eeprom_image
(braket
id|EEPROM_MISC0
)braket
op_amp
id|ENA_16
suffix:semicolon
id|outb
c_func
(paren
id|cr
comma
id|EWRK3_CR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;   ** Determine the base address and window length for the EWRK3&n;&t;&t;&t;&t;&t;&t;   ** RAM from the memory base register.&n;&t;&t;&t;&t;&t;&t; */
id|mem_start
op_assign
id|inb
c_func
(paren
id|EWRK3_MBR
)paren
suffix:semicolon
id|shmem_length
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mem_start
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|mem_start
op_ge
l_int|0x0a
)paren
op_logical_and
(paren
id|mem_start
op_le
l_int|0x0f
)paren
)paren
(brace
id|mem_start
op_mul_assign
id|SHMEM_64K
suffix:semicolon
id|shmem_length
op_assign
id|SHMEM_64K
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|mem_start
op_ge
l_int|0x14
)paren
op_logical_and
(paren
id|mem_start
op_le
l_int|0x1f
)paren
)paren
(brace
id|mem_start
op_mul_assign
id|SHMEM_32K
suffix:semicolon
id|shmem_length
op_assign
id|SHMEM_32K
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|mem_start
op_ge
l_int|0x40
)paren
op_logical_and
(paren
id|mem_start
op_le
l_int|0xff
)paren
)paren
(brace
id|mem_start
op_assign
id|mem_start
op_star
id|SHMEM_2K
op_plus
l_int|0x80000
suffix:semicolon
id|shmem_length
op_assign
id|SHMEM_2K
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;   ** See the top of this source code for comments about&n;&t;&t;&t;&t;&t;&t;   ** uncommenting this line.&n;&t;&t;&t;&t;&t;&t; */
multiline_comment|/*          FORCE_2K_MODE; */
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
r_if
c_cond
(paren
id|hard_strapped
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;      is hard strapped.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mem_start
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;      has a %dk RAM window&quot;
comma
(paren
r_int
)paren
(paren
id|shmem_length
op_rshift
l_int|10
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; at 0x%.5lx&quot;
comma
id|mem_start
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;      is in I/O only mode&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* private area &amp; initialise */
id|dev-&gt;priv
op_assign
(paren
r_void
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ewrk3_private
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ewrk3_private
)paren
)paren
suffix:semicolon
id|lp-&gt;shmem_base
op_assign
id|mem_start
suffix:semicolon
id|lp-&gt;shmem_length
op_assign
id|shmem_length
suffix:semicolon
id|lp-&gt;lemac
op_assign
id|lemac
suffix:semicolon
id|lp-&gt;hard_strapped
op_assign
id|hard_strapped
suffix:semicolon
id|lp-&gt;mPage
op_assign
l_int|64
suffix:semicolon
r_if
c_cond
(paren
id|cmr
op_amp
id|CMR_DRAM
)paren
id|lp-&gt;mPage
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* 2 DRAMS on module */
id|sprintf
c_func
(paren
id|lp-&gt;adapter_name
comma
l_string|&quot;%s (%s)&quot;
comma
id|name
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|iobase
comma
id|EWRK3_TOTAL_SIZE
comma
id|lp-&gt;adapter_name
)paren
suffix:semicolon
id|lp-&gt;irq_mask
op_assign
id|ICR_TNEM
op_or
id|ICR_TXDM
op_or
id|ICR_RNEM
op_or
id|ICR_RXDM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hard_strapped
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;&t;&t;   ** Enable EWRK3 board interrupts for autoprobing&n;&t;&t;&t;&t;&t;&t;&t;&t; */
id|icr
op_or_assign
id|ICR_IE
suffix:semicolon
multiline_comment|/* Enable interrupts */
id|outb
c_func
(paren
id|icr
comma
id|EWRK3_ICR
)paren
suffix:semicolon
multiline_comment|/* The DMA channel may be passed in on this parameter. */
id|dev-&gt;dma
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* To auto-IRQ we enable the initialization-done and DMA err,&n;&t;&t;&t;&t;&t;&t;&t;&t;   interrupts. For now we will always get a DMA error. */
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
)paren
(brace
macro_line|#ifndef MODULE
id|u_char
id|irqnum
suffix:semicolon
id|autoirq_setup
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;   ** Trigger a TNE interrupt.&n;&t;&t;&t;&t;&t;&t;&t;&t;&t; */
id|icr
op_or_assign
id|ICR_TNEM
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|EWRK3_TDQ
)paren
suffix:semicolon
multiline_comment|/* Write to the TX done queue */
id|outb
c_func
(paren
id|icr
comma
id|EWRK3_ICR
)paren
suffix:semicolon
multiline_comment|/* Unmask the TXD interrupt */
id|irqnum
op_assign
id|irq
(braket
(paren
(paren
id|icr
op_amp
id|IRQ_SEL
)paren
op_rshift
l_int|4
)paren
)braket
suffix:semicolon
id|dev-&gt;irq
op_assign
id|autoirq_report
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;irq
)paren
op_logical_and
(paren
id|irqnum
op_eq
id|dev-&gt;irq
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; and uses IRQ%d.&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;irq
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; and failed to detect IRQ line.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|irqnum
op_eq
l_int|1
)paren
op_logical_and
(paren
id|lemac
op_eq
id|LeMAC2
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; and an illegal IRQ line detected.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, but incorrect IRQ line detected.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
id|DISABLE_IRQs
suffix:semicolon
multiline_comment|/* Mask all interrupts */
macro_line|#endif&t;&t;&t;&t;/* MODULE */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot; and requires IRQ%d.&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|status
)paren
id|release_region
c_func
(paren
id|iobase
comma
id|EWRK3_TOTAL_SIZE
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
r_if
c_cond
(paren
id|ewrk3_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
)brace
multiline_comment|/* The EWRK3-specific entries in the device structure. */
id|dev-&gt;open
op_assign
id|ewrk3_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|ewrk3_queue_pkt
suffix:semicolon
id|dev-&gt;stop
op_assign
id|ewrk3_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|ewrk3_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
id|set_multicast_list
suffix:semicolon
id|dev-&gt;do_ioctl
op_assign
id|ewrk3_ioctl
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
id|ewrk3_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|QUEUE_PKT_TIMEOUT
suffix:semicolon
id|dev-&gt;mem_start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fill in the generic field of the device structure. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
"&f;"
DECL|function|ewrk3_open
r_static
r_int
id|ewrk3_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|u_char
id|icr
comma
id|csr
suffix:semicolon
multiline_comment|/*&n;&t;   ** Stop the TX and RX...&n;&t; */
id|STOP_EWRK3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;hard_strapped
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
(paren
r_void
op_star
)paren
id|ewrk3_interrupt
comma
l_int|0
comma
l_string|&quot;ewrk3&quot;
comma
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ewrk3_open(): Requested IRQ%d is busy&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;   ** Re-initialize the EWRK3...&n;&t;&t;&t; */
id|ewrk3_init
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ewrk3_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: ewrk3 open with irq %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  physical address: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
(paren
id|u_char
)paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%2.2x&bslash;n&quot;
comma
(paren
id|u_char
)paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;  no shared memory, I/O only mode&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;  start of shared memory: 0x%08lx&bslash;n&quot;
comma
id|lp-&gt;shmem_base
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  window length: 0x%04lx&bslash;n&quot;
comma
id|lp-&gt;shmem_length
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  # of DRAMS: %d&bslash;n&quot;
comma
(paren
(paren
id|inb
c_func
(paren
id|EWRK3_CMR
)paren
op_amp
l_int|0x02
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  csr:  0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  cr:   0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|EWRK3_CR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  icr:  0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|EWRK3_ICR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  cmr:  0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|EWRK3_CMR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  fmqc: 0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|EWRK3_FMQC
)paren
)paren
suffix:semicolon
)brace
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;   ** Unmask EWRK3 board interrupts&n;&t;&t;&t; */
id|icr
op_assign
id|inb
c_func
(paren
id|EWRK3_ICR
)paren
suffix:semicolon
id|ENABLE_IRQs
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: ewrk3 available for hard strapped set up only.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;      Run the &squot;ewrk3setup&squot; utility or remove the hard straps.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;   ** Initialize the EtherWORKS 3 operating conditions&n; */
DECL|function|ewrk3_init
r_static
r_void
id|ewrk3_init
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_char
id|csr
comma
id|page
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
multiline_comment|/*&n;&t;   ** Enable any multicasts&n;&t; */
id|set_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   ** Clean out any remaining entries in all the queues here&n;&t; */
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_TQ
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_TDQ
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_RQ
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_FMQ
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;   ** Write a clean free memory queue&n;&t; */
r_for
c_loop
(paren
id|page
op_assign
l_int|1
suffix:semicolon
id|page
OL
id|lp-&gt;mPage
suffix:semicolon
id|page
op_increment
)paren
(brace
multiline_comment|/* Write the free page numbers */
id|outb
c_func
(paren
id|page
comma
id|EWRK3_FMQ
)paren
suffix:semicolon
multiline_comment|/* to the Free Memory Queue */
)brace
id|lp-&gt;lock
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Ensure there are no locks */
id|START_EWRK3
suffix:semicolon
multiline_comment|/* Enable the TX and/or RX */
)brace
multiline_comment|/*&n; *  Transmit timeout&n; */
DECL|function|ewrk3_timeout
r_static
r_void
id|ewrk3_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_char
id|icr
comma
id|csr
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;hard_strapped
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: transmit timed/locked out, status %04x, resetting.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;   ** Mask all board interrupts&n;&t;&t; */
id|DISABLE_IRQs
suffix:semicolon
multiline_comment|/*&n;&t;&t;   ** Stop the TX and RX...&n;&t;&t; */
id|STOP_EWRK3
suffix:semicolon
id|ewrk3_init
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;   ** Unmask EWRK3 board interrupts&n;&t;&t; */
id|ENABLE_IRQs
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   ** Writes a socket buffer to the free page queue&n; */
DECL|function|ewrk3_queue_pkt
r_static
r_int
id|ewrk3_queue_pkt
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
id|u_char
id|icr
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
macro_line|#error &quot;This needs spinlocks&quot;
macro_line|#endif
id|DISABLE_IRQs
suffix:semicolon
multiline_comment|/* So that the page # remains correct */
multiline_comment|/*&n;&t;   ** Get a free page from the FMQ when resources are available&n;&t; */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|EWRK3_FMQC
)paren
OG
l_int|0
)paren
(brace
id|u_long
id|buf
op_assign
l_int|0
suffix:semicolon
id|u_char
id|page
suffix:semicolon
r_if
c_cond
(paren
(paren
id|page
op_assign
id|inb
c_func
(paren
id|EWRK3_FMQ
)paren
)paren
OL
id|lp-&gt;mPage
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;   ** Set up shared memory window and pointer into the window&n;&t;&t;&t; */
r_while
c_loop
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|lp-&gt;lock
)paren
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Wait for lock to free */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|outb
c_func
(paren
id|page
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|SHMEM_2K
)paren
(brace
id|buf
op_assign
id|lp-&gt;shmem_base
suffix:semicolon
id|outb
c_func
(paren
id|page
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|SHMEM_32K
)paren
(brace
id|buf
op_assign
(paren
(paren
(paren
(paren
r_int
)paren
id|page
op_lshift
l_int|11
)paren
op_amp
l_int|0x7800
)paren
op_plus
id|lp-&gt;shmem_base
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|page
op_rshift
l_int|4
)paren
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|SHMEM_64K
)paren
(brace
id|buf
op_assign
(paren
(paren
(paren
(paren
r_int
)paren
id|page
op_lshift
l_int|11
)paren
op_amp
l_int|0xf800
)paren
op_plus
id|lp-&gt;shmem_base
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|page
op_rshift
l_int|5
)paren
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: Oops - your private data area is hosed!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;   ** Set up the buffer control structures and copy the data from&n;&t;&t;&t;&t;   ** the socket buffer to the shared memory .&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
r_int
id|i
suffix:semicolon
id|u_char
op_star
id|p
op_assign
id|skb-&gt;data
suffix:semicolon
id|outb
c_func
(paren
(paren
r_char
)paren
(paren
id|TCR_QMODE
op_or
id|TCR_PAD
op_or
id|TCR_IFC
)paren
comma
id|EWRK3_DATA
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
r_char
)paren
(paren
id|skb-&gt;len
op_amp
l_int|0xff
)paren
comma
id|EWRK3_DATA
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
r_char
)paren
(paren
(paren
id|skb-&gt;len
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
comma
id|EWRK3_DATA
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
r_char
)paren
l_int|0x04
comma
id|EWRK3_DATA
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb-&gt;len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
op_star
id|p
op_increment
comma
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|page
comma
id|EWRK3_TQ
)paren
suffix:semicolon
multiline_comment|/* Start sending pkt */
)brace
r_else
(brace
id|writeb
c_func
(paren
(paren
r_char
)paren
(paren
id|TCR_QMODE
op_or
id|TCR_PAD
op_or
id|TCR_IFC
)paren
comma
(paren
r_char
op_star
)paren
id|buf
)paren
suffix:semicolon
multiline_comment|/* ctrl byte */
id|buf
op_add_assign
l_int|1
suffix:semicolon
id|writeb
c_func
(paren
(paren
r_char
)paren
(paren
id|skb-&gt;len
op_amp
l_int|0xff
)paren
comma
(paren
r_char
op_star
)paren
id|buf
)paren
suffix:semicolon
multiline_comment|/* length (16 bit xfer) */
id|buf
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;txc
)paren
(brace
id|writeb
c_func
(paren
(paren
r_char
)paren
(paren
(paren
(paren
id|skb-&gt;len
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
op_or
id|XCT
)paren
comma
(paren
r_char
op_star
)paren
id|buf
)paren
suffix:semicolon
id|buf
op_add_assign
l_int|1
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x04
comma
(paren
r_char
op_star
)paren
id|buf
)paren
suffix:semicolon
multiline_comment|/* index byte */
id|buf
op_add_assign
l_int|1
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x00
comma
(paren
r_char
op_star
)paren
(paren
id|buf
op_plus
id|skb-&gt;len
)paren
)paren
suffix:semicolon
multiline_comment|/* Write the XCT flag */
id|isa_memcpy_toio
c_func
(paren
id|buf
comma
id|skb-&gt;data
comma
id|PRELOAD
)paren
suffix:semicolon
multiline_comment|/* Write PRELOAD bytes */
id|outb
c_func
(paren
id|page
comma
id|EWRK3_TQ
)paren
suffix:semicolon
multiline_comment|/* Start sending pkt */
id|isa_memcpy_toio
c_func
(paren
id|buf
op_plus
id|PRELOAD
comma
id|skb-&gt;data
op_plus
id|PRELOAD
comma
id|skb-&gt;len
op_minus
id|PRELOAD
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0xff
comma
(paren
r_char
op_star
)paren
(paren
id|buf
op_plus
id|skb-&gt;len
)paren
)paren
suffix:semicolon
multiline_comment|/* Write the XCT flag */
)brace
r_else
(brace
id|writeb
c_func
(paren
(paren
r_char
)paren
(paren
(paren
id|skb-&gt;len
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
comma
(paren
r_char
op_star
)paren
id|buf
)paren
suffix:semicolon
id|buf
op_add_assign
l_int|1
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x04
comma
(paren
r_char
op_star
)paren
id|buf
)paren
suffix:semicolon
multiline_comment|/* index byte */
id|buf
op_add_assign
l_int|1
suffix:semicolon
id|isa_memcpy_toio
c_func
(paren
id|buf
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Write data bytes */
id|outb
c_func
(paren
id|page
comma
id|EWRK3_TQ
)paren
suffix:semicolon
multiline_comment|/* Start sending pkt */
)brace
)brace
id|lp-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* return unused page to the free memory queue */
id|outb
c_func
(paren
id|page
comma
id|EWRK3_FMQ
)paren
suffix:semicolon
)brace
id|lp-&gt;lock
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unlock the page register */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;ewrk3_queue_pkt(): Invalid free memory page (%d).&bslash;n&quot;
comma
(paren
id|u_char
)paren
id|page
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: ewrk3_queue_pkt(): No free resources...&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: ewrk3_queue_pkt(): CSR: %02x ICR: %02x FMQC: %02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
comma
id|inb
c_func
(paren
id|EWRK3_ICR
)paren
comma
id|inb
c_func
(paren
id|EWRK3_FMQC
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for free resources: clear &squot;tbusy&squot; if there are some */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|EWRK3_FMQC
)paren
OG
l_int|0
)paren
(brace
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|ENABLE_IRQs
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;   ** The EWRK3 interrupt handler.&n; */
DECL|function|ewrk3_interrupt
r_static
r_void
id|ewrk3_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_struct
id|ewrk3_private
op_star
id|lp
suffix:semicolon
id|u_long
id|iobase
suffix:semicolon
id|u_char
id|icr
comma
id|cr
comma
id|csr
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
multiline_comment|/* get the interrupt information */
id|csr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; ** Mask the EWRK3 board interrupts and turn on the LED&n;&t; */
id|DISABLE_IRQs
suffix:semicolon
id|cr
op_assign
id|inb
c_func
(paren
id|EWRK3_CR
)paren
suffix:semicolon
id|cr
op_or_assign
id|CR_LED
suffix:semicolon
id|outb
c_func
(paren
id|cr
comma
id|EWRK3_CR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csr
op_amp
id|CSR_RNE
)paren
multiline_comment|/* Rx interrupt (packet[s] arrived) */
id|ewrk3_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csr
op_amp
id|CSR_TNE
)paren
multiline_comment|/* Tx interrupt (packet sent) */
id|ewrk3_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; ** Now deal with the TX/RX disable flags. These are set when there&n;&t; ** are no more resources. If resources free up then enable these&n;&t; ** interrupts, otherwise mask them - failure to do this will result&n;&t; ** in the system hanging in an interrupt loop.&n;&t; */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|EWRK3_FMQC
)paren
)paren
(brace
multiline_comment|/* any resources available? */
id|lp-&gt;irq_mask
op_or_assign
id|ICR_TXDM
op_or
id|ICR_RXDM
suffix:semicolon
multiline_comment|/* enable the interrupt source */
id|csr
op_and_assign
op_complement
(paren
id|CSR_TXD
op_or
id|CSR_RXD
)paren
suffix:semicolon
multiline_comment|/* ensure restart of a stalled TX or RX */
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;irq_mask
op_and_assign
op_complement
(paren
id|ICR_TXDM
op_or
id|ICR_RXDM
)paren
suffix:semicolon
multiline_comment|/* disable the interrupt source */
)brace
multiline_comment|/* Unmask the EWRK3 board interrupts and turn off the LED */
id|cr
op_and_assign
op_complement
id|CR_LED
suffix:semicolon
id|outb
c_func
(paren
id|cr
comma
id|EWRK3_CR
)paren
suffix:semicolon
id|ENABLE_IRQs
suffix:semicolon
)brace
DECL|function|ewrk3_rx
r_static
r_int
id|ewrk3_rx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|u_char
id|page
comma
id|tmpPage
op_assign
l_int|0
comma
id|tmpLock
op_assign
l_int|0
suffix:semicolon
id|u_long
id|buf
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_RQC
)paren
op_logical_and
op_logical_neg
id|status
)paren
(brace
multiline_comment|/* Whilst there&squot;s incoming data */
r_if
c_cond
(paren
(paren
id|page
op_assign
id|inb
c_func
(paren
id|EWRK3_RQ
)paren
)paren
OL
id|lp-&gt;mPage
)paren
(brace
multiline_comment|/* Get next entry&squot;s buffer page */
multiline_comment|/*&n;&t;&t;&t;   ** Preempt any process using the current page register. Check for&n;&t;&t;&t;   ** an existing lock to reduce time taken in I/O transactions.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|tmpLock
op_assign
id|test_and_set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|lp-&gt;lock
)paren
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Assert lock */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
multiline_comment|/* Get existing page */
id|tmpPage
op_assign
id|inb
c_func
(paren
id|EWRK3_IOPR
)paren
suffix:semicolon
)brace
r_else
(brace
id|tmpPage
op_assign
id|inb
c_func
(paren
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t;   ** Set up shared memory window and pointer into the window&n;&t;&t;&t; */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|outb
c_func
(paren
id|page
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|SHMEM_2K
)paren
(brace
id|buf
op_assign
id|lp-&gt;shmem_base
suffix:semicolon
id|outb
c_func
(paren
id|page
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|SHMEM_32K
)paren
(brace
id|buf
op_assign
(paren
(paren
(paren
(paren
r_int
)paren
id|page
op_lshift
l_int|11
)paren
op_amp
l_int|0x7800
)paren
op_plus
id|lp-&gt;shmem_base
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|page
op_rshift
l_int|4
)paren
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|SHMEM_64K
)paren
(brace
id|buf
op_assign
(paren
(paren
(paren
(paren
r_int
)paren
id|page
op_lshift
l_int|11
)paren
op_amp
l_int|0xf800
)paren
op_plus
id|lp-&gt;shmem_base
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|page
op_rshift
l_int|5
)paren
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Oops - your private data area is hosed!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
r_char
id|rx_status
suffix:semicolon
r_int
id|pkt_len
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|rx_status
op_assign
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
suffix:semicolon
id|pkt_len
op_assign
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
suffix:semicolon
id|pkt_len
op_or_assign
(paren
(paren
id|u_short
)paren
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
r_else
(brace
id|rx_status
op_assign
id|readb
c_func
(paren
id|buf
)paren
suffix:semicolon
id|buf
op_add_assign
l_int|1
suffix:semicolon
id|pkt_len
op_assign
id|readw
c_func
(paren
id|buf
)paren
suffix:semicolon
id|buf
op_add_assign
l_int|3
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|rx_status
op_amp
id|R_ROK
)paren
)paren
(brace
multiline_comment|/* There was an error. */
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
multiline_comment|/* Update the error stats. */
r_if
c_cond
(paren
id|rx_status
op_amp
id|R_DBE
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rx_status
op_amp
id|R_CRC
)paren
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rx_status
op_amp
id|R_PLL
)paren
id|lp-&gt;stats.rx_fifo_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
op_plus
l_int|2
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
r_char
op_star
id|p
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Align to 16 bytes */
id|p
op_assign
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
op_star
id|p
op_assign
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
suffix:semicolon
multiline_comment|/* dummy read */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pkt_len
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|p
op_increment
op_assign
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|isa_memcpy_fromio
c_func
(paren
id|p
comma
id|buf
comma
id|pkt_len
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;   ** Notify the upper protocol layers that there is another&n;&t;&t;&t;&t;&t;&t;   ** packet to handle&n;&t;&t;&t;&t;&t;&t; */
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;   ** Update stats&n;&t;&t;&t;&t;&t;&t; */
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.rx_bytes
op_add_assign
id|pkt_len
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|EWRK3_PKT_STAT_SZ
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pkt_len
OL
id|i
op_star
id|EWRK3_PKT_BIN_SZ
)paren
(brace
id|lp-&gt;pktStats.bins
(braket
id|i
)braket
op_increment
suffix:semicolon
id|i
op_assign
id|EWRK3_PKT_STAT_SZ
suffix:semicolon
)brace
)brace
id|p
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* Look at the dest addr */
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_amp
l_int|0x01
)paren
(brace
multiline_comment|/* Multicast/Broadcast */
r_if
c_cond
(paren
(paren
op_star
(paren
id|s32
op_star
)paren
op_amp
id|p
(braket
l_int|0
)braket
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
op_star
(paren
id|s16
op_star
)paren
op_amp
id|p
(braket
l_int|4
)braket
op_eq
op_minus
l_int|1
)paren
)paren
(brace
id|lp-&gt;pktStats.broadcast
op_increment
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;pktStats.multicast
op_increment
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
op_star
(paren
id|s32
op_star
)paren
op_amp
id|p
(braket
l_int|0
)braket
op_eq
op_star
(paren
id|s32
op_star
)paren
op_amp
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
)paren
op_logical_and
(paren
op_star
(paren
id|s16
op_star
)paren
op_amp
id|p
(braket
l_int|4
)braket
op_eq
op_star
(paren
id|s16
op_star
)paren
op_amp
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
)paren
)paren
(brace
id|lp-&gt;pktStats.unicast
op_increment
suffix:semicolon
)brace
id|lp-&gt;pktStats.bins
(braket
l_int|0
)braket
op_increment
suffix:semicolon
multiline_comment|/* Duplicates stats.rx_packets */
r_if
c_cond
(paren
id|lp-&gt;pktStats.bins
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Reset counters */
id|memset
c_func
(paren
op_amp
id|lp-&gt;pktStats
comma
l_int|0
comma
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Insufficient memory; nuking packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
multiline_comment|/* Really, deferred. */
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t;&t;   ** Return the received buffer to the free memory queue&n;&t;&t;&t; */
id|outb
c_func
(paren
id|page
comma
id|EWRK3_FMQ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmpLock
)paren
(brace
multiline_comment|/* If a lock was preempted */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
multiline_comment|/* Replace old page */
id|outb
c_func
(paren
id|tmpPage
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
id|tmpPage
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
)brace
id|lp-&gt;lock
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Unlock the page register */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;ewrk3_rx(): Illegal page number, page %d&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ewrk3_rx(): CSR: %02x ICR: %02x FMQC: %02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
comma
id|inb
c_func
(paren
id|EWRK3_ICR
)paren
comma
id|inb
c_func
(paren
id|EWRK3_FMQC
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;   ** Buffer sent - check for TX buffer errors.&n; */
DECL|function|ewrk3_tx
r_static
r_int
id|ewrk3_tx
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u_char
id|tx_status
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tx_status
op_assign
id|inb
c_func
(paren
id|EWRK3_TDQ
)paren
)paren
OG
l_int|0
)paren
(brace
multiline_comment|/* Whilst there&squot;s old buffers */
r_if
c_cond
(paren
id|tx_status
op_amp
id|T_VSTS
)paren
(brace
multiline_comment|/* The status is valid */
r_if
c_cond
(paren
id|tx_status
op_amp
id|T_TXE
)paren
(brace
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
id|T_NCL
)paren
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
id|T_LCL
)paren
id|lp-&gt;stats.tx_window_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
id|T_CTU
)paren
(brace
r_if
c_cond
(paren
(paren
id|tx_status
op_amp
id|T_COLL
)paren
op_xor
id|T_XUR
)paren
(brace
id|lp-&gt;pktStats.tx_underruns
op_increment
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;pktStats.excessive_underruns
op_increment
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|tx_status
op_amp
id|T_COLL
)paren
(brace
r_if
c_cond
(paren
(paren
id|tx_status
op_amp
id|T_COLL
)paren
op_xor
id|T_XCOLL
)paren
(brace
id|lp-&gt;stats.collisions
op_increment
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;pktStats.excessive_collisions
op_increment
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ewrk3_close
r_static
r_int
id|ewrk3_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u_char
id|icr
comma
id|csr
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ewrk3_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Shutting down ethercard, status was %2.2x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;   ** We stop the EWRK3 here... mask interrupts and stop TX &amp; RX&n;&t; */
id|DISABLE_IRQs
suffix:semicolon
id|STOP_EWRK3
suffix:semicolon
multiline_comment|/*&n;&t;   ** Clean out the TX and RX queues here (note that one entry&n;&t;   ** may get added to either the TXD or RX queues if the TX or RX&n;&t;   ** just starts processing a packet before the STOP_EWRK3 command&n;&t;   ** is received. This will be flushed in the ewrk3_open() call).&n;&t; */
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_TQ
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_TDQ
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_RQ
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;hard_strapped
)paren
(brace
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ewrk3_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|ewrk3_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Null body since there is no framing error counter */
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/*&n;   ** Set or clear the multicast filter for this adapter.&n; */
DECL|function|set_multicast_list
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u_char
id|csr
suffix:semicolon
id|csr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|lp-&gt;mctbl
op_assign
(paren
r_char
op_star
)paren
id|PAGE0_HTE
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;mctbl
op_assign
(paren
r_char
op_star
)paren
(paren
id|lp-&gt;shmem_base
op_plus
id|PAGE0_HTE
)paren
suffix:semicolon
)brace
id|csr
op_and_assign
op_complement
(paren
id|CSR_PME
op_or
id|CSR_MCE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
multiline_comment|/* set promiscuous mode */
id|csr
op_or_assign
id|CSR_PME
suffix:semicolon
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
)brace
r_else
(brace
id|SetMulticastFilter
c_func
(paren
id|dev
)paren
suffix:semicolon
id|csr
op_or_assign
id|CSR_MCE
suffix:semicolon
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   ** Calculate the hash code and update the logical address filter&n;   ** from a list of ethernet multicast addresses.&n;   ** Little endian crc one liner from Matt Thomas, DEC.&n;   **&n;   ** Note that when clearing the table, the broadcast bit must remain asserted&n;   ** to receive broadcast messages.&n; */
DECL|function|SetMulticastFilter
r_static
r_void
id|SetMulticastFilter
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|dev_mc_list
op_star
id|dmi
op_assign
id|dev-&gt;mc_list
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
op_star
id|addrs
comma
id|j
comma
id|bit
comma
id|byte
suffix:semicolon
r_int
op_star
id|p
op_assign
(paren
r_int
op_star
)paren
id|lp-&gt;mctbl
suffix:semicolon
id|u16
id|hashcode
suffix:semicolon
id|s32
id|crc
comma
id|poly
op_assign
id|CRC_POLYNOMIAL_LE
suffix:semicolon
r_while
c_loop
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|lp-&gt;lock
)paren
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Wait for lock to free */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|EEPROM_OFFSET
c_func
(paren
id|lp-&gt;mctbl
)paren
comma
id|EWRK3_PIR1
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
l_int|0
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|outb
c_func
(paren
l_int|0xff
comma
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* memset didn&squot;t work here */
id|writew
c_func
(paren
l_int|0xffff
comma
id|p
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* Clear table except for broadcast bit */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|4
)paren
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
l_int|0x00
comma
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0x80
comma
id|EWRK3_DATA
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
multiline_comment|/* insert the broadcast bit */
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
l_int|0x00
comma
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|memset_io
c_func
(paren
id|lp-&gt;mctbl
comma
l_int|0
comma
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x80
comma
(paren
r_char
op_star
)paren
(paren
id|lp-&gt;mctbl
op_plus
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|4
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Update table */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|dev-&gt;mc_count
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* for each address in the list */
id|addrs
op_assign
id|dmi-&gt;dmi_addr
suffix:semicolon
id|dmi
op_assign
id|dmi-&gt;next
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|addrs
op_amp
l_int|0x01
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* multicast address? */
id|crc
op_assign
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* init CRC for each address */
r_for
c_loop
(paren
id|byte
op_assign
l_int|0
suffix:semicolon
id|byte
OL
id|ETH_ALEN
suffix:semicolon
id|byte
op_increment
)paren
(brace
multiline_comment|/* for each address byte */
multiline_comment|/* process each address bit */
r_for
c_loop
(paren
id|bit
op_assign
op_star
id|addrs
op_increment
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
comma
id|bit
op_rshift_assign
l_int|1
)paren
(brace
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|1
)paren
op_xor
(paren
(paren
(paren
id|crc
op_xor
id|bit
)paren
op_amp
l_int|0x01
)paren
ques
c_cond
id|poly
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|hashcode
op_assign
id|crc
op_amp
(paren
(paren
l_int|1
op_lshift
l_int|9
)paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* hashcode is 9 LSb of CRC */
id|byte
op_assign
id|hashcode
op_rshift
l_int|3
suffix:semicolon
multiline_comment|/* bit[3-8] -&gt; byte in filter */
id|bit
op_assign
l_int|1
op_lshift
(paren
id|hashcode
op_amp
l_int|0x07
)paren
suffix:semicolon
multiline_comment|/* bit[0-2] -&gt; bit in byte */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|u_char
id|tmp
suffix:semicolon
id|outw
c_func
(paren
(paren
r_int
)paren
(paren
(paren
r_int
)paren
id|lp-&gt;mctbl
)paren
op_plus
id|byte
comma
id|EWRK3_PIR1
)paren
suffix:semicolon
id|tmp
op_assign
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
suffix:semicolon
id|tmp
op_or_assign
id|bit
suffix:semicolon
id|outw
c_func
(paren
(paren
r_int
)paren
(paren
(paren
r_int
)paren
id|lp-&gt;mctbl
)paren
op_plus
id|byte
comma
id|EWRK3_PIR1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|tmp
comma
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
r_else
(brace
id|writeb
c_func
(paren
id|readb
c_func
(paren
id|lp-&gt;mctbl
op_plus
id|byte
)paren
op_or
id|bit
comma
id|lp-&gt;mctbl
op_plus
id|byte
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
id|lp-&gt;lock
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Unlock the page register */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;   ** ISA bus I/O device probe&n; */
DECL|function|isa_probe
r_static
r_void
id|__init
id|isa_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|ioaddr
)paren
(brace
r_int
id|i
op_assign
id|num_ewrk3s
comma
id|maxSlots
suffix:semicolon
id|u_long
id|iobase
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioaddr
op_logical_and
id|autoprobed
)paren
r_return
suffix:semicolon
multiline_comment|/* Been here before ! */
r_if
c_cond
(paren
id|ioaddr
op_ge
l_int|0x400
)paren
r_return
suffix:semicolon
multiline_comment|/* Not ISA */
r_if
c_cond
(paren
id|ioaddr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Autoprobing */
id|iobase
op_assign
id|EWRK3_IO_BASE
suffix:semicolon
multiline_comment|/* Get the first slot address */
id|maxSlots
op_assign
l_int|24
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Probe a specific location */
id|iobase
op_assign
id|ioaddr
suffix:semicolon
id|maxSlots
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
(paren
id|i
OL
id|maxSlots
)paren
op_logical_and
(paren
id|dev
op_ne
l_int|NULL
)paren
suffix:semicolon
id|iobase
op_add_assign
id|EWRK3_IOP_INC
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|check_region
c_func
(paren
id|iobase
comma
id|EWRK3_TOTAL_SIZE
)paren
)paren
(brace
r_if
c_cond
(paren
id|DevicePresent
c_func
(paren
id|iobase
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|alloc_device
c_func
(paren
id|dev
comma
id|iobase
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ewrk3_hw_init
c_func
(paren
id|dev
comma
id|iobase
)paren
op_eq
l_int|0
)paren
(brace
id|num_ewrk3s
op_increment
suffix:semicolon
)brace
id|num_eth
op_increment
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|autoprobed
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: region already allocated at 0x%04lx.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|iobase
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;   ** EISA bus I/O device probe. Probe from slot 1 since slot 0 is usually&n;   ** the motherboard.&n; */
DECL|function|eisa_probe
r_static
r_void
id|__init
id|eisa_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|ioaddr
)paren
(brace
r_int
id|i
comma
id|maxSlots
suffix:semicolon
id|u_long
id|iobase
suffix:semicolon
r_char
id|name
(braket
id|EWRK3_STRLEN
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioaddr
op_logical_and
id|autoprobed
)paren
r_return
suffix:semicolon
multiline_comment|/* Been here before ! */
r_if
c_cond
(paren
id|ioaddr
OL
l_int|0x1000
)paren
r_return
suffix:semicolon
multiline_comment|/* Not EISA */
r_if
c_cond
(paren
id|ioaddr
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Autoprobing */
id|iobase
op_assign
id|EISA_SLOT_INC
suffix:semicolon
multiline_comment|/* Get the first slot address */
id|i
op_assign
l_int|1
suffix:semicolon
id|maxSlots
op_assign
id|MAX_EISA_SLOTS
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Probe a specific location */
id|iobase
op_assign
id|ioaddr
suffix:semicolon
id|i
op_assign
(paren
id|ioaddr
op_rshift
l_int|12
)paren
suffix:semicolon
id|maxSlots
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
(paren
id|i
OL
id|maxSlots
)paren
op_logical_and
(paren
id|dev
op_ne
l_int|NULL
)paren
suffix:semicolon
id|i
op_increment
comma
id|iobase
op_add_assign
id|EISA_SLOT_INC
)paren
(brace
r_if
c_cond
(paren
id|EISA_signature
c_func
(paren
id|name
comma
id|EISA_ID
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|check_region
c_func
(paren
id|iobase
comma
id|EWRK3_TOTAL_SIZE
)paren
)paren
(brace
r_if
c_cond
(paren
id|DevicePresent
c_func
(paren
id|iobase
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|alloc_device
c_func
(paren
id|dev
comma
id|iobase
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|ewrk3_hw_init
c_func
(paren
id|dev
comma
id|iobase
)paren
op_eq
l_int|0
)paren
(brace
id|num_ewrk3s
op_increment
suffix:semicolon
)brace
id|num_eth
op_increment
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|autoprobed
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: region already allocated at 0x%04lx.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|iobase
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;   ** Search the entire &squot;eth&squot; device list for a fixed probe. If a match isn&squot;t&n;   ** found then check for an autoprobe or unused device location. If they&n;   ** are not available then insert a new device structure at the end of&n;   ** the current list.&n; */
DECL|function|alloc_device
r_static
r_struct
id|net_device
op_star
id|__init
id|alloc_device
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
)paren
(brace
r_struct
id|net_device
op_star
id|adev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|fixed
op_assign
l_int|0
comma
id|new_dev
op_assign
l_int|0
suffix:semicolon
id|num_eth
op_assign
id|ewrk3_dev_index
c_func
(paren
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|loading_module
)paren
r_return
id|dev
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|dev-&gt;base_addr
op_eq
id|EWRK3_NDA
)paren
op_logical_or
(paren
id|dev-&gt;base_addr
op_eq
l_int|0
)paren
)paren
op_logical_and
op_logical_neg
id|adev
)paren
(brace
id|adev
op_assign
id|dev
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|dev-&gt;base_addr
op_eq
id|iobase
)paren
)paren
(brace
id|fixed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dev-&gt;next
op_eq
l_int|NULL
)paren
(brace
id|new_dev
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|dev-&gt;next-&gt;name
comma
l_string|&quot;eth&quot;
comma
l_int|3
)paren
op_ne
l_int|0
)paren
(brace
id|new_dev
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|dev-&gt;next
op_eq
l_int|NULL
)paren
op_logical_or
id|new_dev
op_logical_or
id|fixed
)paren
r_break
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
suffix:semicolon
id|num_eth
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|adev
op_logical_and
op_logical_neg
id|fixed
)paren
(brace
id|dev
op_assign
id|adev
suffix:semicolon
id|num_eth
op_assign
id|ewrk3_dev_index
c_func
(paren
id|dev-&gt;name
)paren
suffix:semicolon
id|new_dev
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|dev-&gt;next
op_eq
l_int|NULL
)paren
op_logical_and
(paren
(paren
id|dev-&gt;base_addr
op_ne
id|EWRK3_NDA
)paren
op_logical_and
(paren
id|dev-&gt;base_addr
op_ne
l_int|0
)paren
)paren
op_logical_and
op_logical_neg
id|fixed
)paren
op_logical_or
id|new_dev
)paren
(brace
id|num_eth
op_increment
suffix:semicolon
multiline_comment|/* New device */
id|dev
op_assign
id|insert_device
c_func
(paren
id|dev
comma
id|iobase
comma
id|ewrk3_probe
)paren
suffix:semicolon
)brace
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/*&n;   ** If at end of eth device list and can&squot;t use current entry, malloc&n;   ** one up. If memory could not be allocated, print an error message.&n; */
r_static
r_struct
id|net_device
op_star
id|__init
DECL|function|insert_device
id|insert_device
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_long
id|iobase
comma
r_int
(paren
op_star
id|init
)paren
(paren
r_struct
id|net_device
op_star
)paren
)paren
(brace
r_struct
id|net_device
op_star
r_new
suffix:semicolon
r_new
op_assign
(paren
r_struct
id|net_device
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_device
)paren
op_plus
l_int|8
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eth%d: Device not initialised, insufficient memory&bslash;n&quot;
comma
id|num_eth
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
r_new
op_member_access_from_pointer
id|next
op_assign
id|dev-&gt;next
suffix:semicolon
id|dev-&gt;next
op_assign
r_new
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
suffix:semicolon
multiline_comment|/* point to the new device */
r_if
c_cond
(paren
id|num_eth
OG
l_int|9999
)paren
(brace
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;eth????&quot;
)paren
suffix:semicolon
multiline_comment|/* New device name */
)brace
r_else
(brace
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;eth%d&quot;
comma
id|num_eth
)paren
suffix:semicolon
multiline_comment|/* New device name */
)brace
id|dev-&gt;base_addr
op_assign
id|iobase
suffix:semicolon
multiline_comment|/* assign the io address */
id|dev-&gt;init
op_assign
id|init
suffix:semicolon
multiline_comment|/* initialisation routine */
)brace
r_return
id|dev
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|ewrk3_dev_index
id|ewrk3_dev_index
c_func
(paren
r_char
op_star
id|s
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
op_star
id|s
suffix:semicolon
id|s
op_increment
)paren
(brace
r_if
c_cond
(paren
id|isdigit
c_func
(paren
op_star
id|s
)paren
)paren
(brace
id|j
op_assign
l_int|1
suffix:semicolon
id|i
op_assign
(paren
id|i
op_star
l_int|10
)paren
op_plus
(paren
op_star
id|s
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|j
)paren
r_break
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n;   ** Read the EWRK3 EEPROM using this routine&n; */
DECL|function|Read_EEPROM
r_static
r_int
id|Read_EEPROM
c_func
(paren
id|u_long
id|iobase
comma
id|u_char
id|eaddr
)paren
(brace
r_int
id|i
suffix:semicolon
id|outb
c_func
(paren
(paren
id|eaddr
op_amp
l_int|0x3f
)paren
comma
id|EWRK3_PIR1
)paren
suffix:semicolon
multiline_comment|/* set up 6 bits of address info */
id|outb
c_func
(paren
id|EEPROM_RD
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
multiline_comment|/* issue read command */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5000
suffix:semicolon
id|i
op_increment
)paren
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
multiline_comment|/* wait 1msec */
r_return
id|inw
c_func
(paren
id|EWRK3_EPROM1
)paren
suffix:semicolon
multiline_comment|/* 16 bits data return */
)brace
multiline_comment|/*&n;   ** Write the EWRK3 EEPROM using this routine&n; */
DECL|function|Write_EEPROM
r_static
r_int
id|Write_EEPROM
c_func
(paren
r_int
id|data
comma
id|u_long
id|iobase
comma
id|u_char
id|eaddr
)paren
(brace
r_int
id|i
suffix:semicolon
id|outb
c_func
(paren
id|EEPROM_WR_EN
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
multiline_comment|/* issue write enable command */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5000
suffix:semicolon
id|i
op_increment
)paren
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
multiline_comment|/* wait 1msec */
id|outw
c_func
(paren
id|data
comma
id|EWRK3_EPROM1
)paren
suffix:semicolon
multiline_comment|/* write data to register */
id|outb
c_func
(paren
(paren
id|eaddr
op_amp
l_int|0x3f
)paren
comma
id|EWRK3_PIR1
)paren
suffix:semicolon
multiline_comment|/* set up 6 bits of address info */
id|outb
c_func
(paren
id|EEPROM_WR
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
multiline_comment|/* issue write command */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|75000
suffix:semicolon
id|i
op_increment
)paren
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
multiline_comment|/* wait 15msec */
id|outb
c_func
(paren
id|EEPROM_WR_DIS
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
multiline_comment|/* issue write disable command */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5000
suffix:semicolon
id|i
op_increment
)paren
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
multiline_comment|/* wait 1msec */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;   ** Look for a particular board name in the on-board EEPROM.&n; */
DECL|function|EthwrkSignature
r_static
r_void
id|__init
id|EthwrkSignature
c_func
(paren
r_char
op_star
id|name
comma
r_char
op_star
id|eeprom_image
)paren
(brace
id|u_long
id|i
comma
id|j
comma
id|k
suffix:semicolon
r_char
op_star
id|signatures
(braket
)braket
op_assign
id|EWRK3_SIGNATURE
suffix:semicolon
id|strcpy
c_func
(paren
id|name
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_star
id|signatures
(braket
id|i
)braket
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
op_star
id|name
op_eq
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|EEPROM_PNAME7
comma
id|k
op_assign
l_int|0
suffix:semicolon
id|j
op_le
id|EEPROM_PNAME0
op_logical_and
id|k
OL
id|strlen
c_func
(paren
id|signatures
(braket
id|i
)braket
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|signatures
(braket
id|i
)braket
(braket
id|k
)braket
op_eq
id|eeprom_image
(braket
id|j
)braket
)paren
(brace
multiline_comment|/* track signature */
id|k
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* lost signature; begin search again */
id|k
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|k
op_eq
id|strlen
c_func
(paren
id|signatures
(braket
id|i
)braket
)paren
)paren
(brace
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|EWRK3_STRLEN
suffix:semicolon
id|k
op_increment
)paren
(brace
id|name
(braket
id|k
)braket
op_assign
id|eeprom_image
(braket
id|EEPROM_PNAME7
op_plus
id|k
)braket
suffix:semicolon
id|name
(braket
id|EWRK3_STRLEN
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
)brace
)brace
r_return
suffix:semicolon
multiline_comment|/* return the device name string */
)brace
multiline_comment|/*&n;   ** Look for a special sequence in the Ethernet station address PROM that&n;   ** is common across all EWRK3 products.&n;   **&n;   ** Search the Ethernet address ROM for the signature. Since the ROM address&n;   ** counter can start at an arbitrary point, the search must include the entire&n;   ** probe sequence length plus the (length_of_the_signature - 1).&n;   ** Stop the search IMMEDIATELY after the signature is found so that the&n;   ** PROM address counter is correctly positioned at the start of the&n;   ** ethernet address for later read out.&n; */
DECL|function|DevicePresent
r_static
r_int
id|__init
id|DevicePresent
c_func
(paren
id|u_long
id|iobase
)paren
(brace
r_union
(brace
r_struct
(brace
id|u32
id|a
suffix:semicolon
id|u32
id|b
suffix:semicolon
)brace
id|llsig
suffix:semicolon
r_char
id|Sig
(braket
r_sizeof
(paren
id|u32
)paren
op_lshift
l_int|1
)braket
suffix:semicolon
)brace
id|dev
suffix:semicolon
r_int
id|sigLength
suffix:semicolon
r_char
id|data
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|dev.llsig.a
op_assign
id|ETH_PROM_SIG
suffix:semicolon
id|dev.llsig.b
op_assign
id|ETH_PROM_SIG
suffix:semicolon
id|sigLength
op_assign
r_sizeof
(paren
id|u32
)paren
op_lshift
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|sigLength
op_logical_and
id|i
OL
id|PROBE_LENGTH
op_plus
id|sigLength
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data
op_assign
id|inb
c_func
(paren
id|EWRK3_APROM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev.Sig
(braket
id|j
)braket
op_eq
id|data
)paren
(brace
multiline_comment|/* track signature */
id|j
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* lost signature; begin search again */
r_if
c_cond
(paren
id|data
op_eq
id|dev.Sig
(braket
l_int|0
)braket
)paren
(brace
id|j
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|j
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|j
op_ne
id|sigLength
)paren
(brace
id|status
op_assign
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* search failed */
)brace
r_return
id|status
suffix:semicolon
)brace
DECL|function|get_hw_addr
r_static
id|u_char
id|__init
id|get_hw_addr
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
id|u_char
op_star
id|eeprom_image
comma
r_char
id|chipType
)paren
(brace
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
id|u_short
id|chksum
suffix:semicolon
id|u_char
id|crc
comma
id|lfsr
comma
id|sd
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|u16
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|chipType
op_eq
id|LeMAC2
)paren
(brace
r_for
c_loop
(paren
id|crc
op_assign
l_int|0x6a
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ETH_ALEN
suffix:semicolon
id|j
op_increment
)paren
(brace
id|sd
op_assign
id|dev-&gt;dev_addr
(braket
id|j
)braket
op_assign
id|eeprom_image
(braket
id|EEPROM_PADDR0
op_plus
id|j
)braket
suffix:semicolon
id|outb
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|j
)braket
comma
id|EWRK3_PAR0
op_plus
id|j
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|8
suffix:semicolon
id|k
op_increment
comma
id|sd
op_rshift_assign
l_int|1
)paren
(brace
id|lfsr
op_assign
(paren
(paren
(paren
(paren
id|crc
op_amp
l_int|0x02
)paren
op_rshift
l_int|1
)paren
op_xor
(paren
id|crc
op_amp
l_int|0x01
)paren
)paren
op_xor
(paren
id|sd
op_amp
l_int|0x01
)paren
)paren
op_lshift
l_int|7
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|1
)paren
op_plus
id|lfsr
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|crc
op_ne
id|eeprom_image
(braket
id|EEPROM_PA_CRC
)braket
)paren
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|k
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
)paren
(brace
id|k
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
l_int|0xffff
)paren
id|k
op_sub_assign
l_int|0xffff
suffix:semicolon
id|k
op_add_assign
(paren
id|u_char
)paren
(paren
id|tmp
op_assign
id|inb
c_func
(paren
id|EWRK3_APROM
)paren
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
(paren
id|u_char
)paren
id|tmp
suffix:semicolon
id|outb
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
id|EWRK3_PAR0
op_plus
id|i
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|k
op_add_assign
(paren
id|u_short
)paren
(paren
(paren
id|tmp
op_assign
id|inb
c_func
(paren
id|EWRK3_APROM
)paren
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
(paren
id|u_char
)paren
id|tmp
suffix:semicolon
id|outb
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
id|EWRK3_PAR0
op_plus
id|i
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
l_int|0xffff
)paren
id|k
op_sub_assign
l_int|0xffff
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
op_eq
l_int|0xffff
)paren
id|k
op_assign
l_int|0
suffix:semicolon
id|chksum
op_assign
id|inb
c_func
(paren
id|EWRK3_APROM
)paren
suffix:semicolon
id|chksum
op_or_assign
(paren
id|inb
c_func
(paren
id|EWRK3_APROM
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
op_ne
id|chksum
)paren
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;   ** Look for a particular board name in the EISA configuration space&n; */
DECL|function|EISA_signature
r_static
r_int
id|__init
id|EISA_signature
c_func
(paren
r_char
op_star
id|name
comma
id|s32
id|eisa_id
)paren
(brace
id|u_long
id|i
suffix:semicolon
r_char
op_star
id|signatures
(braket
)braket
op_assign
id|EWRK3_SIGNATURE
suffix:semicolon
r_char
id|ManCode
(braket
id|EWRK3_STRLEN
)braket
suffix:semicolon
r_union
(brace
id|s32
id|ID
suffix:semicolon
r_char
id|Id
(braket
l_int|4
)braket
suffix:semicolon
)brace
id|Eisa
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
op_star
id|name
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|Eisa.Id
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|eisa_id
op_plus
id|i
)paren
suffix:semicolon
)brace
id|ManCode
(braket
l_int|0
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|0
)braket
op_rshift
l_int|2
)paren
op_amp
l_int|0x1f
)paren
op_plus
l_int|0x40
)paren
suffix:semicolon
id|ManCode
(braket
l_int|1
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|1
)braket
op_amp
l_int|0xe0
)paren
op_rshift
l_int|5
)paren
op_plus
(paren
(paren
id|Eisa.Id
(braket
l_int|0
)braket
op_amp
l_int|0x03
)paren
op_lshift
l_int|3
)paren
op_plus
l_int|0x40
)paren
suffix:semicolon
id|ManCode
(braket
l_int|2
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|2
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
op_plus
l_int|0x30
)paren
suffix:semicolon
id|ManCode
(braket
l_int|3
)braket
op_assign
(paren
(paren
id|Eisa.Id
(braket
l_int|2
)braket
op_amp
l_int|0x0f
)paren
op_plus
l_int|0x30
)paren
suffix:semicolon
id|ManCode
(braket
l_int|4
)braket
op_assign
(paren
(paren
(paren
id|Eisa.Id
(braket
l_int|3
)braket
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
op_plus
l_int|0x30
)paren
suffix:semicolon
id|ManCode
(braket
l_int|5
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
op_star
id|signatures
(braket
id|i
)braket
op_ne
l_char|&squot;&bslash;0&squot;
)paren
op_logical_and
(paren
op_star
id|name
op_eq
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|ManCode
comma
id|signatures
(braket
id|i
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|strcpy
c_func
(paren
id|name
comma
id|ManCode
)paren
suffix:semicolon
id|status
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|status
suffix:semicolon
multiline_comment|/* return the device name string */
)brace
multiline_comment|/*&n;   ** Perform IOCTL call functions here. Some are privileged operations and the&n;   ** effective uid is checked in those cases.&n; */
DECL|function|ewrk3_ioctl
r_static
r_int
id|ewrk3_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
comma
r_int
id|cmd
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|ewrk3_ioctl
op_star
id|ioc
op_assign
(paren
r_struct
id|ewrk3_ioctl
op_star
)paren
op_amp
id|rq-&gt;ifr_data
suffix:semicolon
id|u_long
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|status
op_assign
l_int|0
suffix:semicolon
id|u_char
id|csr
suffix:semicolon
r_union
(brace
id|u_char
id|addr
(braket
id|HASH_TABLE_LEN
op_star
id|ETH_ALEN
)braket
suffix:semicolon
id|u_short
id|val
(braket
(paren
id|HASH_TABLE_LEN
op_star
id|ETH_ALEN
)paren
op_rshift
l_int|1
)braket
suffix:semicolon
)brace
id|tmp
suffix:semicolon
r_switch
c_cond
(paren
id|ioc-&gt;cmd
)paren
(brace
r_case
id|EWRK3_GET_HWADDR
suffix:colon
multiline_comment|/* Get the hardware address */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp.addr
(braket
id|i
)braket
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
)brace
id|ioc-&gt;len
op_assign
id|ETH_ALEN
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
id|tmp.addr
comma
id|ioc-&gt;len
)paren
)paren
(brace
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|EWRK3_SET_HWADDR
suffix:colon
multiline_comment|/* Set the hardware address */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|csr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
id|csr
op_or_assign
(paren
id|CSR_TXD
op_or
id|CSR_RXD
)paren
suffix:semicolon
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
multiline_comment|/* Disable the TX and RX */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|tmp.addr
comma
id|ioc-&gt;data
comma
id|ETH_ALEN
)paren
)paren
(brace
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|tmp.addr
(braket
id|i
)braket
suffix:semicolon
id|outb
c_func
(paren
id|tmp.addr
(braket
id|i
)braket
comma
id|EWRK3_PAR0
op_plus
id|i
)paren
suffix:semicolon
)brace
id|csr
op_and_assign
op_complement
(paren
id|CSR_TXD
op_or
id|CSR_RXD
)paren
suffix:semicolon
multiline_comment|/* Enable the TX and RX */
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_SET_PROM
suffix:colon
multiline_comment|/* Set Promiscuous Mode */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|csr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
id|csr
op_or_assign
id|CSR_PME
suffix:semicolon
id|csr
op_and_assign
op_complement
id|CSR_MCE
suffix:semicolon
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_CLR_PROM
suffix:colon
multiline_comment|/* Clear Promiscuous Mode */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|csr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
id|csr
op_and_assign
op_complement
id|CSR_PME
suffix:semicolon
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_SAY_BOO
suffix:colon
multiline_comment|/* Say &quot;Boo!&quot; to the kernel log file */
id|printk
c_func
(paren
l_string|&quot;%s: Boo!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EWRK3_GET_MCA
suffix:colon
multiline_comment|/* Get the multicast address table */
r_while
c_loop
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|lp-&gt;lock
)paren
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Wait for lock to free */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|PAGE0_HTE
comma
id|EWRK3_PIR1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp.addr
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|outb
c_func
(paren
l_int|0
comma
id|EWRK3_MPR
)paren
suffix:semicolon
id|isa_memcpy_fromio
c_func
(paren
id|tmp.addr
comma
id|lp-&gt;shmem_base
op_plus
id|PAGE0_HTE
comma
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
)paren
suffix:semicolon
)brace
id|ioc-&gt;len
op_assign
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
id|tmp.addr
comma
id|ioc-&gt;len
)paren
)paren
(brace
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|lp-&gt;lock
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Unlock the page register */
r_break
suffix:semicolon
r_case
id|EWRK3_SET_MCA
suffix:colon
multiline_comment|/* Set a multicast address */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|tmp.addr
comma
id|ioc-&gt;data
comma
id|ETH_ALEN
op_star
id|ioc-&gt;len
)paren
)paren
(brace
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|set_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_CLR_MCA
suffix:colon
multiline_comment|/* Clear all multicast addresses */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|set_multicast_list
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_MCA_EN
suffix:colon
multiline_comment|/* Enable multicast addressing */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|csr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
id|csr
op_or_assign
id|CSR_MCE
suffix:semicolon
id|csr
op_and_assign
op_complement
id|CSR_PME
suffix:semicolon
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_GET_STATS
suffix:colon
multiline_comment|/* Get the driver statistics */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ioc-&gt;len
op_assign
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
op_amp
id|lp-&gt;pktStats
comma
id|ioc-&gt;len
)paren
)paren
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EWRK3_CLR_STATS
suffix:colon
multiline_comment|/* Zero out the driver statistics */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|lp-&gt;pktStats
comma
l_int|0
comma
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_GET_CSR
suffix:colon
multiline_comment|/* Get the CSR Register contents */
id|tmp.addr
(braket
l_int|0
)braket
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
id|ioc-&gt;len
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
id|tmp.addr
comma
id|ioc-&gt;len
)paren
)paren
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EWRK3_SET_CSR
suffix:colon
multiline_comment|/* Set the CSR Register contents */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|tmp.addr
comma
id|ioc-&gt;data
comma
l_int|1
)paren
)paren
(brace
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|outb
c_func
(paren
id|tmp.addr
(braket
l_int|0
)braket
comma
id|EWRK3_CSR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_GET_EEPROM
suffix:colon
multiline_comment|/* Get the EEPROM contents */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|EEPROM_MAX
op_rshift
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp.val
(braket
id|i
)braket
op_assign
(paren
r_int
)paren
id|Read_EEPROM
c_func
(paren
id|iobase
comma
id|i
)paren
suffix:semicolon
)brace
id|i
op_assign
id|EEPROM_MAX
suffix:semicolon
id|tmp.addr
(braket
id|i
op_increment
)braket
op_assign
id|inb
c_func
(paren
id|EWRK3_CMR
)paren
suffix:semicolon
multiline_comment|/* Config/Management Reg. */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ETH_ALEN
suffix:semicolon
id|j
op_increment
)paren
(brace
id|tmp.addr
(braket
id|i
op_increment
)braket
op_assign
id|inb
c_func
(paren
id|EWRK3_PAR0
op_plus
id|j
)paren
suffix:semicolon
)brace
id|ioc-&gt;len
op_assign
id|EEPROM_MAX
op_plus
l_int|1
op_plus
id|ETH_ALEN
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
id|tmp.addr
comma
id|ioc-&gt;len
)paren
)paren
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_SET_EEPROM
suffix:colon
multiline_comment|/* Set the EEPROM contents */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|tmp.addr
comma
id|ioc-&gt;data
comma
id|EEPROM_MAX
)paren
)paren
(brace
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|EEPROM_MAX
op_rshift
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|Write_EEPROM
c_func
(paren
id|tmp.val
(braket
id|i
)braket
comma
id|iobase
comma
id|i
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_GET_CMR
suffix:colon
multiline_comment|/* Get the CMR Register contents */
id|tmp.addr
(braket
l_int|0
)braket
op_assign
id|inb
c_func
(paren
id|EWRK3_CMR
)paren
suffix:semicolon
id|ioc-&gt;len
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ioc-&gt;data
comma
id|tmp.addr
comma
id|ioc-&gt;len
)paren
)paren
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EWRK3_SET_TX_CUT_THRU
suffix:colon
multiline_comment|/* Set TX cut through mode */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|lp-&gt;txc
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_CLR_TX_CUT_THRU
suffix:colon
multiline_comment|/* Clear TX cut through mode */
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_NET_ADMIN
)paren
)paren
(brace
id|lp-&gt;txc
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|status
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|thisEthwrk
r_static
r_struct
id|net_device
id|thisEthwrk
suffix:semicolon
DECL|variable|io
r_static
r_int
id|io
op_assign
l_int|0x300
suffix:semicolon
multiline_comment|/* &lt;--- EDIT THESE LINES FOR YOUR CONFIGURATION */
DECL|variable|irq
r_static
r_int
id|irq
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* or use the insmod io= irq= options           */
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
id|thisEthwrk.base_addr
op_assign
id|io
suffix:semicolon
id|thisEthwrk.irq
op_assign
id|irq
suffix:semicolon
id|thisEthwrk.init
op_assign
id|ewrk3_probe
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
op_amp
id|thisEthwrk
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|unregister_netdev
c_func
(paren
op_amp
id|thisEthwrk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thisEthwrk.priv
)paren
(brace
id|kfree
c_func
(paren
id|thisEthwrk.priv
)paren
suffix:semicolon
id|thisEthwrk.priv
op_assign
l_int|NULL
suffix:semicolon
)brace
id|thisEthwrk.irq
op_assign
l_int|0
suffix:semicolon
id|release_region
c_func
(paren
id|thisEthwrk.base_addr
comma
id|EWRK3_TOTAL_SIZE
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* MODULE */
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -D__KERNEL__ -I/linux/include -Wall -Wstrict-prototypes -fomit-frame-pointer -fno-strength-reduce -malign-loops=2 -malign-jumps=2 -malign-functions=2 -O2 -m486 -c ewrk3.c&quot;&n; *&n; *  compile-command: &quot;gcc -D__KERNEL__ -DMODULE -I/linux/include -Wall -Wstrict-prototypes -fomit-frame-pointer -fno-strength-reduce -malign-loops=2 -malign-jumps=2 -malign-functions=2 -O2 -m486 -c ewrk3.c&quot;&n; * End:&n; */
eof
