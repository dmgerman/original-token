multiline_comment|/*  ewrk3.c: A DIGITAL EtherWORKS 3 ethernet driver for linux.&n;&n;    Written 1994 by David C. Davies.&n;&n;    Copyright 1994 Digital Equipment Corporation.&n;&n;    This software may be used and distributed according to the terms of&n;    the GNU Public License, incorporated herein by reference.&n;&n;    This driver is written for the Digital Equipment Corporation series&n;    of EtherWORKS ethernet cards:&n;&n;&t;DE203 Turbo (BNC)&n;&t;DE204 Turbo (TP)&n;&t;DE205 Turbo (TP BNC)&n;&n;    The driver has been tested on a relatively busy  network using the DE205&n;    card and benchmarked with &squot;ttcp&squot;: it transferred 16M  of data at 975kB/s&n;    (7.8Mb/s) to a DECstation 5000/200.&n;&n;    The author may    be  reached as davies@wanton.lkg.dec.com  or   Digital&n;    Equipment Corporation, 550 King Street, Littleton MA 01460.&n;&n;    =========================================================================&n;    This driver has been written  substantially  from scratch, although  its&n;    inheritance of style and stack interface from &squot;depca.c&squot; and in turn from&n;    Donald Becker&squot;s &squot;lance.c&squot; should be obvious.&n;&n;    The  DE203/4/5 boards  all  use a new proprietary   chip in place of the&n;    LANCE chip used in prior cards  (DEPCA, DE100, DE200/1/2, DE210, DE422).&n;    Use the depca.c driver in the standard distribution  for the LANCE based&n;    cards from DIGITAL; this driver will not work with them.&n;&n;    The DE203/4/5 cards have 2  main modes: shared memory  and I/O only. I/O&n;    only makes  all the card accesses through  I/O transactions and  no high&n;    (shared)  memory is used. This  mode provides a &gt;48% performance penalty&n;    and  is deprecated in this  driver,  although allowed to provide initial&n;    setup when hardstrapped.&n;&n;    The shared memory mode comes in 3 flavours: 2kB, 32kB and 64kB. There is&n;    no point in using any mode other than the 2kB  mode - their performances&n;    are virtually identical, although the driver has  been tested in the 2kB&n;    and 32kB modes. I would suggest you uncomment the line:&n;&n;                             FORCE_2K_MODE;&n;&n;    to allow the driver to configure the card as a  2kB card at your current&n;    base  address, thus leaving more  room to clutter  your  system box with&n;    other memory hungry boards.&n;&n;    Upto 21 ISA and 7 EISA cards can be supported under this driver, limited&n;    primarily by the  available  IRQ   lines.   I have   checked   different&n;    configurations  of multiple depca  cards and  ewrk3 cards  and  have not&n;    found a problem yet (provided you have at least depca.c v0.38) ...&n;&n;    The board IRQ setting   must be at  an unused  IRQ which is  auto-probed&n;    using  Donald  Becker&squot;s autoprobe  routines.   All  these cards   are at&n;    {5,10,11,15}.&n;&n;    No 16MB memory  limitation should exist with this  driver as DMA is  not&n;    used and the common memory area is in low memory on the network card (my&n;    current system has 20MB and I&squot;ve not had problems yet).&n;&n;    The ability to load  this driver as a  loadable module has been included&n;    and used  extensively during the  driver development (to save those long&n;    reboot sequences). To utilise this ability, you have to do 8 things:&n;&n;    0) have a copy of the loadable modules code installed on your system.&n;    1) copy ewrk3.c from the  /linux/drivers/net directory to your favourite&n;    temporary directory.&n;    2) edit the  source code near  line 1340 to reflect  the I/O address and&n;    IRQ you&squot;re using.&n;    3) compile  ewrk3.c, but include -DMODULE in  the command line to ensure&n;    that the correct bits are compiled (see end of source code).&n;    4) if you are wanting to add a new  card, goto 5. Otherwise, recompile a&n;    kernel with the ewrk3 configuration turned off and reboot.&n;    5) insmod ewrk3.o&n;    6) run the net startup bits for your new eth?? interface manually &n;    (usually /etc/rc.inet[12] at boot time). &n;    7) enjoy!&n;&n;    Note that autoprobing is not allowed in loadable modules - the system is&n;    already up and running and you&squot;re messing with interrupts.&n;&n;    To unload a module, turn off the associated interface &n;    &squot;ifconfig eth?? down&squot; then &squot;rmmod ewrk3&squot;.&n;&n;    Promiscuous   mode has been  turned  off  in this driver,   but  all the&n;    multicast  address bits  have been   turned on. This  improved the  send&n;    performance on a busy network by about 13%.&n;&n;    Ioctl&squot;s have now been provided (primarily because  I wanted to grab some&n;    packet size statistics). They  are patterned after &squot;plipconfig.c&squot; from a&n;    suggestion by Alan Cox.  Using these  ioctls, you can enable promiscuous&n;    mode, add/delete multicast  addresses, change the hardware address,  get&n;    packet size distribution statistics and muck around with the control and&n;    status register. I&squot;ll add others if and when the need arises.&n;&n;    TO DO:&n;    ------&n;&n;&n;    Revision History&n;    ----------------&n;&n;    Version   Date        Description&n;  &n;      0.1     26-aug-94   Initial writing. ALPHA code release.&n;      0.11    31-aug-94   Fixed: 2k mode memory base calc., &n;                                 LeMAC version calc.,&n;&t;&t;&t;&t; IRQ vector assignments during autoprobe.&n;      0.12    31-aug-94   Tested working on LeMAC2 (DE20[345]-AC) card.&n;                          Fixed up MCA hash table algorithm.&n;      0.20     4-sep-94   Added IOCTL functionality.&n;      0.21    14-sep-94   Added I/O mode.&n;      0.21axp 15-sep-94   Special version for ALPHA AXP Linux V1.0&n;      0.22    16-sep-94   Added more IOCTLs &amp; tidied up.&n;      0.23    21-sep-94   Added transmit cut through&n;      0.24    31-oct-94   Added uid checks in some ioctls&n;      0.30     1-nov-94   BETA code release&n;&n;    =========================================================================&n;*/
DECL|variable|version
r_static
r_char
op_star
id|version
op_assign
l_string|&quot;ewrk3.c:v0.30 11/1/94 davies@wanton.lkg.dec.com&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &quot;/linux/tools/version.h&quot;
macro_line|#endif /* MODULE */
macro_line|#include &quot;ewrk3.h&quot;
macro_line|#ifdef EWRK3_DEBUG
DECL|variable|ewrk3_debug
r_static
r_int
id|ewrk3_debug
op_assign
id|EWRK3_DEBUG
suffix:semicolon
macro_line|#else
DECL|variable|ewrk3_debug
r_static
r_int
id|ewrk3_debug
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#ifndef PROBE_LENGTH
DECL|macro|PROBE_LENGTH
mdefine_line|#define PROBE_LENGTH    32
macro_line|#endif
macro_line|#ifndef PROBE_SEQUENCE
DECL|macro|PROBE_SEQUENCE
mdefine_line|#define PROBE_SEQUENCE &quot;FF0055AAFF0055AA&quot;
macro_line|#endif
macro_line|#ifndef EWRK3_SIGNATURE
DECL|macro|EWRK3_SIGNATURE
mdefine_line|#define EWRK3_SIGNATURE {&quot;DE203&quot;,&quot;DE204&quot;,&quot;DE205&quot;,&quot;&quot;}
DECL|macro|EWRK3_NAME_LENGTH
mdefine_line|#define EWRK3_NAME_LENGTH 8
macro_line|#endif
macro_line|#ifndef EWRK3_RAM_BASE_ADDRESSES
DECL|macro|EWRK3_RAM_BASE_ADDRESSES
mdefine_line|#define EWRK3_RAM_BASE_ADDRESSES {0xc0000,0xd0000,0x00000}
macro_line|#endif
multiline_comment|/*&n;** Sets up the search areas for the autoprobe. You can disable an area&n;** by writing a zero into the corresponding bit position in EWRK3_IO_SEARCH.&n;** The LSb -&gt; I/O 0x100. Each bit increments the I/O location searched by 0x20.&n;** Bit 24 -&gt; I/O 0x400.&n;**&n;** By default, probes at locations:&n;**             0x1e0   (may conflict with hard disk)&n;**             0x320   (may conflict with hard disk)&n;**             0x3e0   (may conflict with floppy disk)&n;**&n;** are disabled.&n;*/
DECL|macro|EWRK3_IO_BASE
mdefine_line|#define EWRK3_IO_BASE 0x100             /* Start address for probe search */
DECL|macro|EWRK3_IOP_INC
mdefine_line|#define EWRK3_IOP_INC 0x20              /* I/O address increment */
DECL|macro|EWRK3_IO_SEARCH
mdefine_line|#define EWRK3_IO_SEARCH 0x007dff7f      /* probe search mask */
DECL|variable|mem_chkd
r_static
r_int
id|mem_chkd
op_assign
id|EWRK3_IO_SEARCH
suffix:semicolon
multiline_comment|/* holds which I/O addrs should be */
multiline_comment|/* checked, for multi-EWRK3 case */
macro_line|#ifndef MAX_NUM_EWRK3S
DECL|macro|MAX_NUM_EWRK3S
mdefine_line|#define MAX_NUM_EWRK3S 21
macro_line|#endif
macro_line|#ifndef EWRK3_EISA_IO_PORTS 
DECL|macro|EWRK3_EISA_IO_PORTS
mdefine_line|#define EWRK3_EISA_IO_PORTS 0x0c00      /* I/O port base address, slot 0 */
macro_line|#endif
macro_line|#ifndef MAX_EISA_SLOTS
DECL|macro|MAX_EISA_SLOTS
mdefine_line|#define MAX_EISA_SLOTS 8
DECL|macro|EISA_SLOT_INC
mdefine_line|#define EISA_SLOT_INC 0x1000
macro_line|#endif
macro_line|#ifndef CRC_POLYNOMIAL
DECL|macro|CRC_POLYNOMIAL
mdefine_line|#define CRC_POLYNOMIAL 0x04c11db7       /* Ethernet CRC polynomial */
macro_line|#endif /* CRC_POLYNOMIAL */
multiline_comment|/*&n;** EtherWORKS 3 shared memory window sizes&n;*/
DECL|macro|IO_ONLY
mdefine_line|#define IO_ONLY         0x00
DECL|macro|SHMEM_2K
mdefine_line|#define SHMEM_2K        0x800
DECL|macro|SHMEM_32K
mdefine_line|#define SHMEM_32K       0x8000
DECL|macro|SHMEM_64K
mdefine_line|#define SHMEM_64K       0x10000
multiline_comment|/*&n;** EtherWORKS 3 IRQ ENABLE/DISABLE&n;*/
DECL|variable|irq_mask
r_static
r_int
r_char
id|irq_mask
op_assign
id|TNEM
op_or
id|TXDM
op_or
id|RNEM
op_or
id|RXDM
suffix:semicolon
DECL|macro|ENABLE_IRQs
mdefine_line|#define ENABLE_IRQs &bslash;&n;  icr |= irq_mask;&bslash;&n;  outb(icr, EWRK3_ICR)                      /* Enable the IRQs */
DECL|macro|DISABLE_IRQs
mdefine_line|#define DISABLE_IRQs &bslash;&n;  icr = inb(EWRK3_ICR);&bslash;&n;  icr &amp;= ~irq_mask;&bslash;&n;  outb(icr, EWRK3_ICR)                      /* Disable the IRQs */
multiline_comment|/*&n;** EtherWORKS 3 START/STOP&n;*/
DECL|macro|START_EWRK3
mdefine_line|#define START_EWRK3 &bslash;&n;  csr = inb(EWRK3_CSR);&bslash;&n;  csr &amp;= ~(TXD|RXD);&bslash;&n;  outb(csr, EWRK3_CSR)                      /* Enable the TX and/or RX */
DECL|macro|STOP_EWRK3
mdefine_line|#define STOP_EWRK3 &bslash;&n;  csr = (TXD|RXD);&bslash;&n;  outb(csr, EWRK3_CSR)                      /* Disable the TX and/or RX */
multiline_comment|/*&n;** The EtherWORKS 3 private structure&n;*/
DECL|macro|EWRK3_PKT_STAT_SZ
mdefine_line|#define EWRK3_PKT_STAT_SZ 16
DECL|macro|EWRK3_PKT_BIN_SZ
mdefine_line|#define EWRK3_PKT_BIN_SZ  128           /* Should be &gt;=100 unless you&n;                                           increase EWRK3_PKT_STAT_SZ */
DECL|struct|ewrk3_private
r_struct
id|ewrk3_private
(brace
DECL|member|shmem_base
r_int
id|shmem_base
suffix:semicolon
multiline_comment|/* Shared memory start address */
DECL|member|shmem_length
r_int
id|shmem_length
suffix:semicolon
multiline_comment|/* Shared memory window length */
DECL|member|stats
r_struct
id|enet_statistics
id|stats
suffix:semicolon
multiline_comment|/* Public stats */
r_struct
(brace
DECL|member|bins
r_int
r_int
id|bins
(braket
id|EWRK3_PKT_STAT_SZ
)braket
suffix:semicolon
multiline_comment|/* Private stats counters */
DECL|member|unicast
r_int
r_int
id|unicast
suffix:semicolon
DECL|member|multicast
r_int
r_int
id|multicast
suffix:semicolon
DECL|member|broadcast
r_int
r_int
id|broadcast
suffix:semicolon
DECL|member|excessive_collisions
r_int
r_int
id|excessive_collisions
suffix:semicolon
DECL|member|tx_underruns
r_int
r_int
id|tx_underruns
suffix:semicolon
DECL|member|excessive_underruns
r_int
r_int
id|excessive_underruns
suffix:semicolon
DECL|member|pktStats
)brace
id|pktStats
suffix:semicolon
DECL|member|mPage
r_int
id|mPage
suffix:semicolon
multiline_comment|/* Maximum 2kB Page number */
DECL|member|lemac
r_int
r_char
id|lemac
suffix:semicolon
multiline_comment|/* Chip rev. level */
DECL|member|hard_strapped
r_int
r_char
id|hard_strapped
suffix:semicolon
multiline_comment|/* Don&squot;t allow a full open */
DECL|member|lock
r_int
r_char
id|lock
suffix:semicolon
multiline_comment|/* Lock the page register */
DECL|member|txc
r_int
r_char
id|txc
suffix:semicolon
multiline_comment|/* Transmit cut through */
)brace
suffix:semicolon
multiline_comment|/*&n;** Force the EtherWORKS 3 card to be in 2kB MODE&n;*/
DECL|macro|FORCE_2K_MODE
mdefine_line|#define FORCE_2K_MODE &bslash;&n;  shmem_length = SHMEM_2K;&bslash;&n;  outb(((mem_start - 0x80000) &gt;&gt; 11), EWRK3_MBR)
multiline_comment|/*&n;** Public Functions&n;*/
r_static
r_int
id|ewrk3_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|ewrk3_queue_pkt
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|ewrk3_interrupt
c_func
(paren
r_int
id|reg_ptr
)paren
suffix:semicolon
r_static
r_int
id|ewrk3_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|enet_statistics
op_star
id|ewrk3_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|num_addrs
comma
r_void
op_star
id|addrs
)paren
suffix:semicolon
r_static
r_int
id|ewrk3_ioctl
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
)paren
suffix:semicolon
multiline_comment|/*&n;** Private functions&n;*/
r_static
r_int
id|ewrk3_hw_init
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|iobase
)paren
suffix:semicolon
r_static
r_void
id|ewrk3_init
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|ewrk3_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|ewrk3_tx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|EthwrkSignature
c_func
(paren
r_char
op_star
id|name
comma
r_char
op_star
id|eeprom_image
)paren
suffix:semicolon
r_static
r_int
id|DevicePresent
c_func
(paren
r_int
id|iobase
)paren
suffix:semicolon
r_static
r_void
id|SetMulticastFilter
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|num_addrs
comma
r_char
op_star
id|addrs
comma
r_char
op_star
id|multicast_table
)paren
suffix:semicolon
r_static
r_int
id|Read_EEPROM
c_func
(paren
r_int
id|iobase
comma
r_int
r_char
id|eaddr
)paren
suffix:semicolon
r_static
r_int
id|Write_EEPROM
c_func
(paren
r_int
id|data
comma
r_int
id|iobase
comma
r_int
r_char
id|eaddr
)paren
suffix:semicolon
r_static
r_int
r_char
id|aprom_crc
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
r_char
op_star
id|eeprom_image
comma
r_char
id|chipType
)paren
suffix:semicolon
macro_line|#ifndef MODULE
r_static
r_struct
id|device
op_star
id|isa_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|device
op_star
id|eisa_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|device
op_star
id|alloc_device
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|iobase
)paren
suffix:semicolon
DECL|variable|num_ewrk3s
DECL|variable|num_eth
DECL|variable|autoprobed
r_static
r_int
id|num_ewrk3s
op_assign
l_int|0
comma
id|num_eth
op_assign
l_int|0
comma
id|autoprobed
op_assign
l_int|0
suffix:semicolon
DECL|variable|irq
r_static
r_int
r_char
id|irq
(braket
)braket
op_assign
(brace
l_int|5
comma
l_int|0
comma
l_int|10
comma
l_int|3
comma
l_int|11
comma
l_int|9
comma
l_int|15
comma
l_int|12
)brace
suffix:semicolon
macro_line|#else
r_int
id|init_module
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif /* MODULE */
multiline_comment|/*&n;** Miscellaneous defines...&n;*/
DECL|macro|INIT_EWRK3
mdefine_line|#define INIT_EWRK3 {&bslash;&n;    int i;&bslash;&n;    outb(EEPROM_INIT, EWRK3_IOPR);&bslash;&n;    for (i=0;i&lt;5000;i++) inb(EWRK3_CSR);&bslash;&n;&t;&t;   }
"&f;"
DECL|function|ewrk3_probe
r_int
id|ewrk3_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|status
op_assign
op_minus
id|ENODEV
suffix:semicolon
macro_line|#ifndef MODULE
r_struct
id|device
op_star
id|eth0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|base_addr
OG
l_int|0x0ff
)paren
(brace
multiline_comment|/* Check a single specified location. */
r_if
c_cond
(paren
(paren
(paren
id|mem_chkd
op_rshift
(paren
(paren
id|base_addr
op_minus
id|EWRK3_IO_BASE
)paren
op_div
id|EWRK3_IOP_INC
)paren
)paren
op_amp
l_int|0x01
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|DevicePresent
c_func
(paren
id|base_addr
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Is EWRK3 really here? */
id|status
op_assign
id|ewrk3_hw_init
c_func
(paren
id|dev
comma
id|base_addr
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;ewrk3_probe(): No device found&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
id|ewrk3_hw_init
c_func
(paren
id|dev
comma
id|base_addr
)paren
suffix:semicolon
multiline_comment|/* Yes there is h/w */
)brace
)brace
r_else
r_if
c_cond
(paren
id|base_addr
OG
l_int|0
)paren
(brace
multiline_comment|/* Don&squot;t probe at all. */
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
macro_line|#ifdef MODULE
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Autoprobing is not supported when loading a module based driver.&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EIO
suffix:semicolon
macro_line|#else
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|autoprobed
)paren
(brace
multiline_comment|/* First probe for the EWRK3 test */
multiline_comment|/* pattern in ROM */
id|eth0
op_assign
id|isa_probe
c_func
(paren
id|dev
)paren
suffix:semicolon
id|eth0
op_assign
id|eisa_probe
c_func
(paren
id|eth0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
)paren
id|status
op_assign
l_int|0
suffix:semicolon
id|autoprobed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
macro_line|#endif /* MODULE */
)brace
r_if
c_cond
(paren
id|status
)paren
id|dev-&gt;base_addr
op_assign
id|base_addr
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
r_static
r_int
DECL|function|ewrk3_hw_init
id|ewrk3_hw_init
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|iobase
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
suffix:semicolon
r_int
id|i
comma
id|status
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|mem_start
comma
id|shmem_length
suffix:semicolon
r_char
id|name
(braket
id|EWRK3_NAME_LENGTH
op_plus
l_int|1
)braket
suffix:semicolon
r_int
r_char
id|cr
comma
id|cmr
comma
id|icr
comma
id|nicsr
comma
id|lemac
comma
id|hard_strapped
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|eeprom_image
(braket
id|EEPROM_MAX
)braket
comma
id|chksum
comma
id|eisa_cr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;  ** Stop the EWRK3. Enable the DBR ROM. Disable interrupts and remote boot.&n;  ** This also disables the EISA_ENABLE bit in the EISA Control Register.&n;  */
r_if
c_cond
(paren
id|iobase
OG
l_int|0x400
)paren
id|eisa_cr
op_assign
id|inb
c_func
(paren
id|EISA_CR
)paren
suffix:semicolon
id|INIT_EWRK3
suffix:semicolon
id|nicsr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
multiline_comment|/*&n;  ** Disable &amp; mask all board interrupts&n;  */
id|DISABLE_IRQs
suffix:semicolon
r_if
c_cond
(paren
id|nicsr
op_eq
id|TXD
op_or
id|RXD
)paren
(brace
multiline_comment|/*&n;    ** Check that the EEPROM is alive and well and not living on Pluto...&n;    */
r_for
c_loop
(paren
id|chksum
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|EEPROM_MAX
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
r_union
(brace
r_int
id|val
suffix:semicolon
r_char
id|c
(braket
l_int|2
)braket
suffix:semicolon
)brace
id|tmp
suffix:semicolon
id|tmp.val
op_assign
(paren
r_int
)paren
id|Read_EEPROM
c_func
(paren
id|iobase
comma
(paren
id|i
op_rshift
l_int|1
)paren
)paren
suffix:semicolon
id|eeprom_image
(braket
id|i
)braket
op_assign
id|tmp.c
(braket
l_int|0
)braket
suffix:semicolon
id|eeprom_image
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|tmp.c
(braket
l_int|1
)braket
suffix:semicolon
id|chksum
op_add_assign
id|eeprom_image
(braket
id|i
)braket
op_plus
id|eeprom_image
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|chksum
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Bad EEPROM Data! */
id|printk
c_func
(paren
l_string|&quot;%s: Device has a bad on-board EEPROM.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* &n;      ** Now find out what kind of EWRK3 we have.&n;      */
id|EthwrkSignature
c_func
(paren
id|name
comma
id|eeprom_image
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|name
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
multiline_comment|/* found a EWRK3 device */
id|dev-&gt;base_addr
op_assign
id|iobase
suffix:semicolon
r_if
c_cond
(paren
id|iobase
OG
l_int|0x400
)paren
(brace
id|outb
c_func
(paren
id|eisa_cr
comma
id|EISA_CR
)paren
suffix:semicolon
multiline_comment|/* Rewrite the EISA CR */
)brace
id|lemac
op_assign
id|eeprom_image
(braket
id|EEPROM_CHIPVER
)braket
suffix:semicolon
id|cmr
op_assign
id|inb
c_func
(paren
id|EWRK3_CMR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|lemac
op_eq
id|LeMAC
)paren
op_logical_and
(paren
(paren
id|cmr
op_amp
id|NO_EEPROM
)paren
op_ne
id|NO_EEPROM
)paren
)paren
op_logical_or
(paren
(paren
id|lemac
op_eq
id|LeMAC2
)paren
op_logical_and
op_logical_neg
(paren
id|cmr
op_amp
id|HS
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s at %#3x&quot;
comma
id|dev-&gt;name
comma
id|name
comma
id|iobase
)paren
suffix:semicolon
id|hard_strapped
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|iobase
op_amp
l_int|0x0fff
)paren
op_eq
id|EWRK3_EISA_IO_PORTS
)paren
(brace
multiline_comment|/* EISA slot address */
id|printk
c_func
(paren
l_string|&quot;%s: %s at %#3x (EISA slot %d)&quot;
comma
id|dev-&gt;name
comma
id|name
comma
id|iobase
comma
(paren
(paren
id|iobase
op_rshift
l_int|12
)paren
op_amp
l_int|0x0f
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ISA port address */
id|printk
c_func
(paren
l_string|&quot;%s: %s at %#3x&quot;
comma
id|dev-&gt;name
comma
id|name
comma
id|iobase
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, h/w address &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lemac
op_eq
id|LeMAC2
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* get the ethernet address */
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|eeprom_image
(braket
id|EEPROM_PADDR0
op_plus
id|i
)braket
)paren
suffix:semicolon
id|outb
c_func
(paren
id|eeprom_image
(braket
id|EEPROM_PADDR0
op_plus
id|i
)braket
comma
id|EWRK3_PAR0
op_plus
id|i
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%2.2x,&bslash;n&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|eeprom_image
(braket
id|EEPROM_PADDR0
op_plus
id|i
)braket
)paren
suffix:semicolon
id|outb
c_func
(paren
id|eeprom_image
(braket
id|EEPROM_PADDR0
op_plus
id|i
)braket
comma
id|EWRK3_PAR0
op_plus
id|i
)paren
suffix:semicolon
)brace
r_else
(brace
id|DevicePresent
c_func
(paren
id|iobase
)paren
suffix:semicolon
multiline_comment|/* needed after the EWRK3_INIT */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* get the ethernet addr. */
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|EWRK3_APROM
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
id|EWRK3_PAR0
op_plus
id|i
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%2.2x,&bslash;n&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|EWRK3_APROM
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
id|EWRK3_PAR0
op_plus
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aprom_crc
c_func
(paren
id|dev
comma
id|eeprom_image
comma
id|lemac
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;      which has an EEPROM CRC error.&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|lemac
op_eq
id|LeMAC2
)paren
(brace
multiline_comment|/* Special LeMAC2 CMR things */
id|cmr
op_and_assign
op_complement
(paren
id|RA
op_or
id|WB
op_or
id|LINK
op_or
id|POLARITY
op_or
id|_0WS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_image
(braket
id|EEPROM_MISC0
)braket
op_amp
id|READ_AHEAD
)paren
id|cmr
op_or_assign
id|RA
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_image
(braket
id|EEPROM_MISC0
)braket
op_amp
id|WRITE_BEHIND
)paren
id|cmr
op_or_assign
id|WB
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_image
(braket
id|EEPROM_NETMAN0
)braket
op_amp
id|NETMAN_POL
)paren
id|cmr
op_or_assign
id|POLARITY
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_image
(braket
id|EEPROM_NETMAN0
)braket
op_amp
id|NETMAN_LINK
)paren
id|cmr
op_or_assign
id|LINK
suffix:semicolon
r_if
c_cond
(paren
id|eeprom_image
(braket
id|EEPROM_MISC0
)braket
op_amp
id|_0WS_ENA
)paren
id|cmr
op_or_assign
id|_0WS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eeprom_image
(braket
id|EEPROM_SETUP
)braket
op_amp
id|SETUP_DRAM
)paren
id|cmr
op_or_assign
id|DRAM
suffix:semicolon
id|outb
c_func
(paren
id|cmr
comma
id|EWRK3_CMR
)paren
suffix:semicolon
id|cr
op_assign
id|inb
c_func
(paren
id|EWRK3_CR
)paren
suffix:semicolon
multiline_comment|/* Set up the Control Register */
id|cr
op_or_assign
id|eeprom_image
(braket
id|EEPROM_SETUP
)braket
op_amp
id|SETUP_APD
suffix:semicolon
r_if
c_cond
(paren
id|cr
op_amp
id|SETUP_APD
)paren
id|cr
op_or_assign
id|eeprom_image
(braket
id|EEPROM_SETUP
)braket
op_amp
id|SETUP_PS
suffix:semicolon
id|cr
op_or_assign
id|eeprom_image
(braket
id|EEPROM_MISC0
)braket
op_amp
id|FAST_BUS
suffix:semicolon
id|cr
op_or_assign
id|eeprom_image
(braket
id|EEPROM_MISC0
)braket
op_amp
id|ENA_16
suffix:semicolon
id|outb
c_func
(paren
id|cr
comma
id|EWRK3_CR
)paren
suffix:semicolon
multiline_comment|/* &n;&t;    ** Determine the base address and window length for the EWRK3&n;&t;    ** RAM from the memory base register.&n;&t;    */
id|mem_start
op_assign
id|inb
c_func
(paren
id|EWRK3_MBR
)paren
suffix:semicolon
id|shmem_length
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mem_start
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|mem_start
op_ge
l_int|0x0a
)paren
op_logical_and
(paren
id|mem_start
op_le
l_int|0x0f
)paren
)paren
(brace
id|mem_start
op_mul_assign
id|SHMEM_64K
suffix:semicolon
id|shmem_length
op_assign
id|SHMEM_64K
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|mem_start
op_ge
l_int|0x14
)paren
op_logical_and
(paren
id|mem_start
op_le
l_int|0x1f
)paren
)paren
(brace
id|mem_start
op_mul_assign
id|SHMEM_32K
suffix:semicolon
id|shmem_length
op_assign
id|SHMEM_32K
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|mem_start
op_ge
l_int|0x40
)paren
op_logical_and
(paren
id|mem_start
op_le
l_int|0xff
)paren
)paren
(brace
id|mem_start
op_assign
id|mem_start
op_star
id|SHMEM_2K
op_plus
l_int|0x80000
suffix:semicolon
id|shmem_length
op_assign
id|SHMEM_2K
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;    ** See the top of this source code for comments about&n;&t;    ** uncommenting this line.&n;&t;    */
multiline_comment|/*&t;    FORCE_2K_MODE;*/
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
r_if
c_cond
(paren
id|hard_strapped
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;      is hard strapped.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mem_start
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;      has a %dk RAM window&quot;
comma
(paren
r_int
)paren
(paren
id|shmem_length
op_rshift
l_int|10
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; at 0x%.5lx&quot;
comma
id|mem_start
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;      is in I/O only mode&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* private area &amp; initialise */
id|dev-&gt;priv
op_assign
(paren
r_void
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|ewrk3_private
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ewrk3_private
)paren
)paren
suffix:semicolon
id|lp-&gt;shmem_base
op_assign
id|mem_start
suffix:semicolon
id|lp-&gt;shmem_length
op_assign
id|shmem_length
suffix:semicolon
id|lp-&gt;lemac
op_assign
id|lemac
suffix:semicolon
id|lp-&gt;hard_strapped
op_assign
id|hard_strapped
suffix:semicolon
id|lp-&gt;mPage
op_assign
l_int|64
suffix:semicolon
r_if
c_cond
(paren
id|cmr
op_amp
id|DRAM
)paren
id|lp-&gt;mPage
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* 2 DRAMS on module */
r_if
c_cond
(paren
op_logical_neg
id|hard_strapped
)paren
(brace
multiline_comment|/*&n;&t;&t;** Enable EWRK3 board interrupts for autoprobing&n;&t;&t;*/
id|icr
op_or_assign
id|IE
suffix:semicolon
multiline_comment|/* Enable interrupts */
id|outb
c_func
(paren
id|icr
comma
id|EWRK3_ICR
)paren
suffix:semicolon
multiline_comment|/* The DMA channel may be passed in on this parameter. */
id|dev-&gt;dma
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* To auto-IRQ we enable the initialization-done and DMA err,&n;&t;&t;   interrupts. For now we will always get a DMA error. */
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
)paren
(brace
macro_line|#ifndef MODULE
r_int
r_char
id|irqnum
suffix:semicolon
id|autoirq_setup
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;  ** Trigger a TNE interrupt.&n;&t;&t;  */
id|icr
op_or_assign
id|TNEM
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|EWRK3_TDQ
)paren
suffix:semicolon
multiline_comment|/* Write to the TX done queue */
id|outb
c_func
(paren
id|icr
comma
id|EWRK3_ICR
)paren
suffix:semicolon
multiline_comment|/* Unmask the TXD interrupt */
id|irqnum
op_assign
id|irq
(braket
(paren
(paren
id|icr
op_amp
id|IRQ_SEL
)paren
op_rshift
l_int|4
)paren
)braket
suffix:semicolon
id|dev-&gt;irq
op_assign
id|autoirq_report
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;irq
)paren
op_logical_and
(paren
id|irqnum
op_eq
id|dev-&gt;irq
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; and uses IRQ%d.&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;irq
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; and failed to detect IRQ line.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|irqnum
op_eq
l_int|1
)paren
op_logical_and
(paren
id|lemac
op_eq
id|LeMAC2
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; and an illegal IRQ line detected.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, but incorrect IRQ line detected.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
id|DISABLE_IRQs
suffix:semicolon
multiline_comment|/* Mask all interrupts */
macro_line|#endif /* MODULE */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot; and requires IRQ%d.&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
r_if
c_cond
(paren
id|ewrk3_debug
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
)brace
multiline_comment|/* The EWRK3-specific entries in the device structure. */
id|dev-&gt;open
op_assign
op_amp
id|ewrk3_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|ewrk3_queue_pkt
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|ewrk3_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|ewrk3_get_stats
suffix:semicolon
macro_line|#ifdef HAVE_MULTICAST
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
macro_line|#endif
id|dev-&gt;do_ioctl
op_assign
op_amp
id|ewrk3_ioctl
suffix:semicolon
id|dev-&gt;mem_start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fill in the generic field of the device structure. */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
"&f;"
r_static
r_int
DECL|function|ewrk3_open
id|ewrk3_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
comma
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|icr
comma
id|csr
suffix:semicolon
multiline_comment|/*&n;  ** Stop the TX and RX...&n;  */
id|STOP_EWRK3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;hard_strapped
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|ewrk3_interrupt
comma
l_int|0
comma
l_string|&quot;ewrk3&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ewrk3_open(): Requested IRQ%d is busy&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|status
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
(brace
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
id|dev
suffix:semicolon
multiline_comment|/* &n;      ** Re-initialize the EWRK3... &n;      */
id|ewrk3_init
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ewrk3_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: ewrk3 open with irq %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tphysical address: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2.2x:&quot;
comma
(paren
r_int
)paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tchecked memory: 0x%08lx&bslash;n&quot;
comma
id|mem_chkd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;tno shared memory, I/O only mode&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;tstart of shared memory: 0x%08lx&bslash;n&quot;
comma
id|lp-&gt;shmem_base
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;twindow length: 0x%04lx&bslash;n&quot;
comma
id|lp-&gt;shmem_length
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;t# of DRAMS: %d&bslash;n&quot;
comma
(paren
(paren
id|inb
c_func
(paren
id|EWRK3_CMR
)paren
op_amp
l_int|0x02
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tcsr:  0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tcr:   0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|EWRK3_CR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;ticr:  0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|EWRK3_ICR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tcmr:  0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|EWRK3_CMR
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;tfmqc: 0x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|EWRK3_FMQC
)paren
)paren
suffix:semicolon
)brace
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;interrupt
op_assign
id|UNMASK_INTERRUPTS
suffix:semicolon
multiline_comment|/*&n;      ** Unmask EWRK3 board interrupts&n;      */
id|icr
op_assign
id|inb
c_func
(paren
id|EWRK3_ICR
)paren
suffix:semicolon
id|ENABLE_IRQs
suffix:semicolon
)brace
)brace
r_else
(brace
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: ewrk3 available for hard strapped set up only.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;      Run the &squot;ewrk3setup&squot; utility or remove the hard straps.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif       
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;** Initialize the EtherWORKS 3 operating conditions&n;*/
r_static
r_void
DECL|function|ewrk3_init
id|ewrk3_init
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_char
id|csr
comma
id|page
suffix:semicolon
r_int
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
multiline_comment|/* &n;  ** Enable all multicasts &n;  */
id|set_multicast_list
c_func
(paren
id|dev
comma
id|HASH_TABLE_LEN
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;  ** Clean out any remaining entries in all the queues here&n;  */
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_TQ
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_TDQ
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_RQ
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_FMQ
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;  ** Write a clean free memory queue&n;  */
r_for
c_loop
(paren
id|page
op_assign
l_int|1
suffix:semicolon
id|page
OL
id|lp-&gt;mPage
suffix:semicolon
id|page
op_increment
)paren
(brace
multiline_comment|/* Write the free page numbers */
id|outb
c_func
(paren
id|page
comma
id|EWRK3_FMQ
)paren
suffix:semicolon
multiline_comment|/* to the Free Memory Queue */
)brace
id|lp-&gt;lock
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Ensure there are no locks */
id|START_EWRK3
suffix:semicolon
multiline_comment|/* Enable the TX and/or RX */
)brace
multiline_comment|/* &n;** Writes a socket buffer to the free page queue&n;*/
r_static
r_int
DECL|function|ewrk3_queue_pkt
id|ewrk3_queue_pkt
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|icr
comma
id|csr
suffix:semicolon
multiline_comment|/* Transmitter timeout, serious problems. */
r_if
c_cond
(paren
id|dev-&gt;tbusy
op_logical_or
id|lp-&gt;lock
)paren
(brace
r_int
id|tickssofar
op_assign
id|jiffies
op_minus
id|dev-&gt;trans_start
suffix:semicolon
r_if
c_cond
(paren
id|tickssofar
OL
l_int|10
)paren
(brace
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;hard_strapped
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: transmit timed/locked out, status %04x, resetting.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;      ** Mask all board interrupts&n;      */
id|DISABLE_IRQs
suffix:semicolon
multiline_comment|/*&n;      ** Stop the TX and RX...&n;      */
id|STOP_EWRK3
suffix:semicolon
id|ewrk3_init
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;      ** Unmask EWRK3 board interrupts&n;      */
id|ENABLE_IRQs
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|dev_tint
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|skb-&gt;len
OG
l_int|0
)paren
(brace
multiline_comment|/* &n;    ** Block a timer-based transmit from overlapping.  This could better be&n;    ** done with atomic_swap(1, dev-&gt;tbusy), but set_bit() works as well. &n;    */
r_if
c_cond
(paren
id|set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|dev-&gt;tbusy
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Transmitter access conflict.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|DISABLE_IRQs
suffix:semicolon
multiline_comment|/* So that the page # remains correct */
multiline_comment|/* &n;    ** Get a free page from the FMQ when resources are available&n;    */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|EWRK3_FMQC
)paren
OG
l_int|0
)paren
(brace
r_int
r_char
op_star
id|buf
suffix:semicolon
r_int
r_char
id|page
suffix:semicolon
r_if
c_cond
(paren
(paren
id|page
op_assign
id|inb
c_func
(paren
id|EWRK3_FMQ
)paren
)paren
OL
id|lp-&gt;mPage
)paren
(brace
id|buf
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;** Set up shared memory window and pointer into the window&n;&t;*/
r_while
c_loop
(paren
id|set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|lp-&gt;lock
)paren
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Wait for lock to free */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|outb
c_func
(paren
id|page
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|SHMEM_2K
)paren
(brace
id|buf
op_assign
(paren
r_char
op_star
)paren
id|lp-&gt;shmem_base
suffix:semicolon
id|outb
c_func
(paren
id|page
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|SHMEM_32K
)paren
(brace
id|buf
op_assign
(paren
r_char
op_star
)paren
(paren
(paren
(paren
(paren
r_int
)paren
id|page
op_lshift
l_int|11
)paren
op_amp
l_int|0x7800
)paren
op_plus
id|lp-&gt;shmem_base
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|page
op_rshift
l_int|4
)paren
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|SHMEM_64K
)paren
(brace
id|buf
op_assign
(paren
r_char
op_star
)paren
(paren
(paren
(paren
(paren
r_int
)paren
id|page
op_lshift
l_int|11
)paren
op_amp
l_int|0xf800
)paren
op_plus
id|lp-&gt;shmem_base
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|page
op_rshift
l_int|5
)paren
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Oops - your private data area is hosed!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
multiline_comment|/* &n;&t;  ** Set up the buffer control structures and copy the data from&n;&t;  ** the socket buffer to the shared memory .&n;&t;  */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
op_star
id|p
op_assign
id|skb-&gt;data
suffix:semicolon
id|outb
c_func
(paren
(paren
r_char
)paren
(paren
id|QMODE
op_or
id|PAD
op_or
id|IFC
)paren
comma
id|EWRK3_DATA
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
r_char
)paren
(paren
id|skb-&gt;len
op_amp
l_int|0xff
)paren
comma
id|EWRK3_DATA
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
r_char
)paren
(paren
(paren
id|skb-&gt;len
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
comma
id|EWRK3_DATA
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
r_char
)paren
l_int|0x04
comma
id|EWRK3_DATA
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb-&gt;len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
op_star
id|p
op_increment
comma
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|page
comma
id|EWRK3_TQ
)paren
suffix:semicolon
multiline_comment|/* Start sending pkt */
)brace
r_else
(brace
op_star
id|buf
op_increment
op_assign
(paren
r_char
)paren
(paren
id|QMODE
op_or
id|PAD
op_or
id|IFC
)paren
suffix:semicolon
multiline_comment|/* control byte */
op_star
id|buf
op_increment
op_assign
(paren
r_char
)paren
(paren
id|skb-&gt;len
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* length (16 bit xfer)*/
r_if
c_cond
(paren
id|lp-&gt;txc
)paren
(brace
op_star
id|buf
op_increment
op_assign
(paren
r_char
)paren
(paren
(paren
(paren
id|skb-&gt;len
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
op_or
id|XCT
)paren
suffix:semicolon
op_star
id|buf
op_increment
op_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* index byte */
op_star
(paren
id|buf
op_plus
id|skb-&gt;len
)paren
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* Write the XCT flag */
id|memcpy
c_func
(paren
id|buf
comma
id|skb-&gt;data
comma
id|PRELOAD
)paren
suffix:semicolon
multiline_comment|/* Write PRELOAD bytes */
id|outb
c_func
(paren
id|page
comma
id|EWRK3_TQ
)paren
suffix:semicolon
multiline_comment|/* Start sending pkt */
id|memcpy
c_func
(paren
id|buf
op_plus
id|PRELOAD
comma
id|skb-&gt;data
op_plus
id|PRELOAD
comma
id|skb-&gt;len
op_minus
id|PRELOAD
)paren
suffix:semicolon
op_star
(paren
id|buf
op_plus
id|skb-&gt;len
)paren
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* Write the XCT flag */
)brace
r_else
(brace
op_star
id|buf
op_increment
op_assign
(paren
r_char
)paren
(paren
(paren
id|skb-&gt;len
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
op_star
id|buf
op_increment
op_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* index byte */
id|memcpy
c_func
(paren
id|buf
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* Write data bytes */
id|outb
c_func
(paren
id|page
comma
id|EWRK3_TQ
)paren
suffix:semicolon
multiline_comment|/* Start sending pkt */
)brace
)brace
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* return unused page to the free memory queue */
id|outb
c_func
(paren
id|page
comma
id|EWRK3_FMQ
)paren
suffix:semicolon
)brace
id|lp-&gt;lock
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unlock the page register */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;ewrk3_queue_pkt(): Invalid free memory page (%d).&bslash;n&quot;
comma
(paren
r_int
r_char
)paren
id|page
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;ewrk3_queue_pkt(): No free resources...&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ewrk3_queue_pkt(): CSR: %02x ICR: %02x FMQC: %02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
comma
id|inb
c_func
(paren
id|EWRK3_ICR
)paren
comma
id|inb
c_func
(paren
id|EWRK3_FMQC
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for free resources: clear &squot;tbusy&squot; if there are some */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|EWRK3_FMQC
)paren
OG
l_int|0
)paren
(brace
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
)brace
id|ENABLE_IRQs
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;** The EWRK3 interrupt handler. &n;*/
r_static
r_void
DECL|function|ewrk3_interrupt
id|ewrk3_interrupt
c_func
(paren
r_int
id|reg_ptr
)paren
(brace
r_int
id|irq
op_assign
op_minus
(paren
(paren
(paren
r_struct
id|pt_regs
op_star
)paren
id|reg_ptr
)paren
op_member_access_from_pointer
id|orig_eax
op_plus
l_int|2
)paren
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
(paren
r_struct
id|device
op_star
)paren
(paren
id|irq2dev_map
(braket
id|irq
)braket
)paren
suffix:semicolon
r_struct
id|ewrk3_private
op_star
id|lp
suffix:semicolon
r_int
id|iobase
suffix:semicolon
r_int
r_char
id|icr
comma
id|cr
comma
id|csr
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;ewrk3_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
r_else
(brace
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;interrupt
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Re-entering the interrupt handler.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|dev-&gt;interrupt
op_assign
id|MASK_INTERRUPTS
suffix:semicolon
multiline_comment|/* get the interrupt information */
id|csr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
multiline_comment|/* &n;      ** Mask the EWRK3 board interrupts and turn on the LED &n;      */
id|DISABLE_IRQs
suffix:semicolon
id|cr
op_assign
id|inb
c_func
(paren
id|EWRK3_CR
)paren
suffix:semicolon
id|cr
op_or_assign
id|LED
suffix:semicolon
id|outb
c_func
(paren
id|cr
comma
id|EWRK3_CR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csr
op_amp
id|RNE
)paren
multiline_comment|/* Rx interrupt (packet[s] arrived) */
id|ewrk3_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csr
op_amp
id|TNE
)paren
multiline_comment|/* Tx interrupt (packet sent) */
id|ewrk3_tx
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;      ** Now deal with the TX/RX disable flags. These are set when there&n;      ** are no more resources. If resources free up then enable these&n;      ** interrupts, otherwise mask them - failure to do this will result&n;      ** in the system hanging in an interrupt loop.&n;      */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|EWRK3_FMQC
)paren
)paren
(brace
multiline_comment|/* any resources available? */
id|irq_mask
op_or_assign
id|TXDM
op_or
id|RXDM
suffix:semicolon
multiline_comment|/* enable the interrupt source */
id|csr
op_and_assign
op_complement
(paren
id|TXD
op_or
id|RXD
)paren
suffix:semicolon
multiline_comment|/* ensure restart of a stalled TX or RX */
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clear TX busy flag */
id|mark_bh
c_func
(paren
id|NET_BH
)paren
suffix:semicolon
)brace
r_else
(brace
id|irq_mask
op_and_assign
op_complement
(paren
id|TXDM
op_or
id|RXDM
)paren
suffix:semicolon
multiline_comment|/* disable the interrupt source */
)brace
multiline_comment|/* Unmask the EWRK3 board interrupts and turn off the LED */
id|cr
op_and_assign
op_complement
id|LED
suffix:semicolon
id|outb
c_func
(paren
id|cr
comma
id|EWRK3_CR
)paren
suffix:semicolon
id|dev-&gt;interrupt
op_assign
id|UNMASK_INTERRUPTS
suffix:semicolon
id|ENABLE_IRQs
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|ewrk3_rx
id|ewrk3_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|i
comma
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_char
id|page
comma
id|tmpPage
op_assign
l_int|0
comma
id|tmpLock
op_assign
l_int|0
comma
op_star
id|buf
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_RQC
)paren
op_logical_and
op_logical_neg
id|status
)paren
(brace
multiline_comment|/* Whilst there&squot;s incoming data */
r_if
c_cond
(paren
(paren
id|page
op_assign
id|inb
c_func
(paren
id|EWRK3_RQ
)paren
)paren
OL
id|lp-&gt;mPage
)paren
(brace
multiline_comment|/* Get next entry&squot;s buffer page */
id|buf
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;      ** Preempt any process using the current page register. Check for&n;      ** an existing lock to reduce time taken in I/O transactions.&n;      */
r_if
c_cond
(paren
(paren
id|tmpLock
op_assign
id|set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|lp-&gt;lock
)paren
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Assert lock */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
multiline_comment|/* Get existing page */
id|tmpPage
op_assign
id|inb
c_func
(paren
id|EWRK3_IOPR
)paren
suffix:semicolon
)brace
r_else
(brace
id|tmpPage
op_assign
id|inb
c_func
(paren
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;      ** Set up shared memory window and pointer into the window&n;      */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|outb
c_func
(paren
id|page
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|SHMEM_2K
)paren
(brace
id|buf
op_assign
(paren
r_char
op_star
)paren
id|lp-&gt;shmem_base
suffix:semicolon
id|outb
c_func
(paren
id|page
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|SHMEM_32K
)paren
(brace
id|buf
op_assign
(paren
r_char
op_star
)paren
(paren
(paren
(paren
(paren
r_int
)paren
id|page
op_lshift
l_int|11
)paren
op_amp
l_int|0x7800
)paren
op_plus
id|lp-&gt;shmem_base
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|page
op_rshift
l_int|4
)paren
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|SHMEM_64K
)paren
(brace
id|buf
op_assign
(paren
r_char
op_star
)paren
(paren
(paren
(paren
(paren
r_int
)paren
id|page
op_lshift
l_int|11
)paren
op_amp
l_int|0xf800
)paren
op_plus
id|lp-&gt;shmem_base
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|page
op_rshift
l_int|5
)paren
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Oops - your private data area is hosed!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
r_char
id|rx_status
suffix:semicolon
r_int
id|pkt_len
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|rx_status
op_assign
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
suffix:semicolon
id|pkt_len
op_assign
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
suffix:semicolon
id|pkt_len
op_or_assign
(paren
(paren
r_int
r_int
)paren
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
r_else
(brace
id|rx_status
op_assign
(paren
r_char
)paren
(paren
op_star
id|buf
op_increment
)paren
suffix:semicolon
id|pkt_len
op_assign
(paren
r_int
)paren
(paren
op_star
id|buf
op_plus
(paren
(paren
op_star
(paren
id|buf
op_plus
l_int|1
)paren
)paren
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
id|buf
op_add_assign
l_int|3
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|rx_status
op_amp
id|ROK
)paren
)paren
(brace
multiline_comment|/* There was an error. */
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
multiline_comment|/* Update the error stats. */
r_if
c_cond
(paren
id|rx_status
op_amp
id|DBE
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rx_status
op_amp
id|CRC
)paren
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rx_status
op_amp
id|PLL
)paren
id|lp-&gt;stats.rx_fifo_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_if
c_cond
(paren
(paren
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|pkt_len
comma
id|GFP_ATOMIC
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|skb-&gt;len
op_assign
id|pkt_len
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
r_int
r_char
op_star
id|p
op_assign
id|skb-&gt;data
suffix:semicolon
op_star
id|p
op_assign
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
suffix:semicolon
multiline_comment|/* dummy read */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|skb-&gt;len
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|p
op_increment
op_assign
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|skb-&gt;data
comma
id|buf
comma
id|pkt_len
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t;    ** Notify the upper protocol layers that there is another &n;&t;    ** packet to handle&n;&t;    */
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/*&n;&t;    ** Update stats&n;&t;    */
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|EWRK3_PKT_STAT_SZ
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pkt_len
OL
id|i
op_star
id|EWRK3_PKT_BIN_SZ
)paren
(brace
id|lp-&gt;pktStats.bins
(braket
id|i
)braket
op_increment
suffix:semicolon
id|i
op_assign
id|EWRK3_PKT_STAT_SZ
suffix:semicolon
)brace
)brace
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* Look at the dest addr */
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_amp
l_int|0x01
)paren
(brace
multiline_comment|/* Multicast/Broadcast */
r_if
c_cond
(paren
(paren
op_star
(paren
r_int
op_star
)paren
op_amp
id|buf
(braket
l_int|0
)braket
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
op_star
(paren
r_int
op_star
)paren
op_amp
id|buf
(braket
l_int|4
)braket
op_eq
op_minus
l_int|1
)paren
)paren
(brace
id|lp-&gt;pktStats.broadcast
op_increment
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;pktStats.multicast
op_increment
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
op_star
(paren
r_int
op_star
)paren
op_amp
id|buf
(braket
l_int|0
)braket
op_eq
op_star
(paren
r_int
op_star
)paren
op_amp
id|dev-&gt;dev_addr
(braket
l_int|0
)braket
)paren
op_logical_and
(paren
op_star
(paren
r_int
op_star
)paren
op_amp
id|buf
(braket
l_int|4
)braket
op_eq
op_star
(paren
r_int
op_star
)paren
op_amp
id|dev-&gt;dev_addr
(braket
l_int|4
)braket
)paren
)paren
(brace
id|lp-&gt;pktStats.unicast
op_increment
suffix:semicolon
)brace
id|lp-&gt;pktStats.bins
(braket
l_int|0
)braket
op_increment
suffix:semicolon
multiline_comment|/* Duplicates stats.rx_packets */
r_if
c_cond
(paren
id|lp-&gt;pktStats.bins
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Reset counters */
id|memset
c_func
(paren
op_amp
id|lp-&gt;pktStats
comma
l_int|0
comma
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Insufficient memory; nuking packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
multiline_comment|/* Really, deferred. */
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;      ** Return the received buffer to the free memory queue&n;      */
id|outb
c_func
(paren
id|page
comma
id|EWRK3_FMQ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmpLock
)paren
(brace
multiline_comment|/* If a lock was preempted */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
multiline_comment|/* Replace old page */
id|outb
c_func
(paren
id|tmpPage
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
id|tmpPage
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
)brace
id|lp-&gt;lock
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Unlock the page register */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;ewrk3_rx(): Illegal page number, page %d&bslash;n&quot;
comma
id|page
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ewrk3_rx(): CSR: %02x ICR: %02x FMQC: %02x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
comma
id|inb
c_func
(paren
id|EWRK3_ICR
)paren
comma
id|inb
c_func
(paren
id|EWRK3_FMQC
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;** Buffer sent - check for TX buffer errors.&n;*/
r_static
r_int
DECL|function|ewrk3_tx
id|ewrk3_tx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_char
id|tx_status
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tx_status
op_assign
id|inb
c_func
(paren
id|EWRK3_TDQ
)paren
)paren
OG
l_int|0
)paren
(brace
multiline_comment|/* Whilst there&squot;s old buffers */
r_if
c_cond
(paren
id|tx_status
op_amp
id|VSTS
)paren
(brace
multiline_comment|/* The status is valid */
r_if
c_cond
(paren
id|tx_status
op_amp
id|MAC_TXE
)paren
(brace
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
id|MAC_NCL
)paren
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
id|MAC_LCL
)paren
id|lp-&gt;stats.tx_window_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
id|MAC_CTU
)paren
(brace
r_if
c_cond
(paren
(paren
id|tx_status
op_amp
id|MAC_COLL
)paren
op_xor
id|MAC_XUR
)paren
(brace
id|lp-&gt;pktStats.tx_underruns
op_increment
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;pktStats.excessive_underruns
op_increment
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|tx_status
op_amp
id|MAC_COLL
)paren
(brace
r_if
c_cond
(paren
(paren
id|tx_status
op_amp
id|MAC_COLL
)paren
op_xor
id|MAC_XCOLL
)paren
(brace
id|lp-&gt;stats.collisions
op_increment
suffix:semicolon
)brace
r_else
(brace
id|lp-&gt;pktStats.excessive_collisions
op_increment
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|ewrk3_close
id|ewrk3_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_char
id|icr
comma
id|csr
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ewrk3_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Shutting down ethercard, status was %2.2x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;  ** We stop the EWRK3 here... mask interrupts and stop TX &amp; RX&n;  */
id|DISABLE_IRQs
suffix:semicolon
id|STOP_EWRK3
suffix:semicolon
multiline_comment|/*&n;  ** Clean out the TX and RX queues here (note that one entry&n;  ** may get added to either the TXD or RX queues if the the TX or RX&n;  ** just starts processing a packet before the STOP_EWRK3 command&n;  ** is received. This will be flushed in the ewrk3_open() call).&n;  */
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_TQ
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_TDQ
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|EWRK3_RQ
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp-&gt;hard_strapped
)paren
(brace
id|free_irq
c_func
(paren
id|dev-&gt;irq
)paren
suffix:semicolon
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif    
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_struct
id|enet_statistics
op_star
DECL|function|ewrk3_get_stats
id|ewrk3_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* Null body since there is no framing error counter */
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/*&n;** Set or clear the multicast filter for this adaptor.&n;** num_addrs == -1&t;Promiscuous mode, receive all packets&n;** num_addrs == 0&t;Normal mode, clear multicast list&n;** num_addrs &gt; 0&t;Multicast mode, receive normal and MC packets, and do&n;** &t;&t;&t;best-effort filtering.&n;*/
r_static
r_void
DECL|function|set_multicast_list
id|set_multicast_list
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|num_addrs
comma
r_void
op_star
id|addrs
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_char
op_star
id|multicast_table
suffix:semicolon
r_int
r_char
id|csr
suffix:semicolon
id|csr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|multicast_table
op_assign
(paren
r_char
op_star
)paren
id|PAGE0_HTE
suffix:semicolon
)brace
r_else
(brace
id|multicast_table
op_assign
(paren
r_char
op_star
)paren
(paren
id|lp-&gt;shmem_base
op_plus
id|PAGE0_HTE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|num_addrs
op_ge
l_int|0
)paren
(brace
id|SetMulticastFilter
c_func
(paren
id|dev
comma
id|num_addrs
comma
(paren
r_char
op_star
)paren
id|addrs
comma
id|multicast_table
)paren
suffix:semicolon
id|csr
op_and_assign
op_complement
id|PME
suffix:semicolon
id|csr
op_or_assign
id|MCE
suffix:semicolon
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* set promiscuous mode */
id|csr
op_or_assign
id|PME
suffix:semicolon
id|csr
op_and_assign
op_complement
id|MCE
suffix:semicolon
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;** Calculate the hash code and update the logical address filter&n;** from a list of ethernet multicast addresses.&n;** Derived from a &squot;C&squot; program in the AMD data book:&n;** &quot;Am79C90 CMOS Local Area Network Controller for Ethernet (C-LANCE)&quot;, &n;** Pub #17781, Rev. A, May 1993&n;**&n;*/
DECL|function|SetMulticastFilter
r_static
r_void
id|SetMulticastFilter
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|num_addrs
comma
r_char
op_star
id|addrs
comma
r_char
op_star
id|multicast_table
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_char
id|j
comma
id|ctrl
comma
id|bit
comma
id|octet
suffix:semicolon
r_int
op_star
id|p
op_assign
(paren
r_int
op_star
)paren
id|multicast_table
suffix:semicolon
r_int
r_int
id|hashcode
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|crc
comma
id|poly
op_assign
(paren
r_int
r_int
)paren
id|CRC_POLYNOMIAL
suffix:semicolon
r_while
c_loop
(paren
id|set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|lp-&gt;lock
)paren
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Wait for lock to free */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
id|outw
c_func
(paren
(paren
r_int
)paren
(paren
(paren
r_int
)paren
id|multicast_table
)paren
comma
id|EWRK3_PIR1
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
l_int|0
comma
id|EWRK3_MPR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|num_addrs
op_eq
id|HASH_TABLE_LEN
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|outb
c_func
(paren
l_int|0xff
comma
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* memset didn&squot;t work here */
op_star
id|p
op_increment
op_assign
l_int|0xffff
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|num_addrs
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
l_int|0x00
comma
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|memset
c_func
(paren
id|multicast_table
comma
l_int|0
comma
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_addrs
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* for each address in the list */
r_if
c_cond
(paren
(paren
(paren
r_char
)paren
op_star
(paren
id|addrs
op_plus
id|ETH_ALEN
op_star
id|i
)paren
op_amp
l_int|0x01
)paren
op_eq
l_int|1
)paren
(brace
multiline_comment|/* multicast address? */
id|crc
op_assign
(paren
r_int
r_int
)paren
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* init CRC for each address */
r_for
c_loop
(paren
id|octet
op_assign
l_int|0
suffix:semicolon
id|octet
OL
id|ETH_ALEN
suffix:semicolon
id|octet
op_increment
)paren
(brace
multiline_comment|/* for each address octet */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/* process each address bit */
id|bit
op_assign
(paren
(paren
(paren
r_char
)paren
op_star
(paren
id|addrs
op_plus
id|ETH_ALEN
op_star
id|i
op_plus
id|octet
)paren
)paren
op_rshift
id|j
)paren
op_amp
l_int|0x01
suffix:semicolon
id|ctrl
op_assign
(paren
(paren
id|crc
OL
l_int|0
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/* shift the control bit */
id|crc
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* shift the CRC */
r_if
c_cond
(paren
id|bit
op_xor
id|ctrl
)paren
(brace
multiline_comment|/* (bit) XOR (control bit) */
id|crc
op_xor_assign
id|poly
suffix:semicolon
multiline_comment|/* (CRC) XOR (polynomial) */
)brace
)brace
)brace
id|hashcode
op_assign
(paren
id|crc
op_amp
l_int|0x01
)paren
suffix:semicolon
multiline_comment|/* hashcode is 9 LSb of CRC ... */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/* ... in reverse order. */
id|hashcode
op_lshift_assign
l_int|1
suffix:semicolon
id|crc
op_rshift_assign
l_int|1
suffix:semicolon
id|hashcode
op_or_assign
(paren
id|crc
op_amp
l_int|0x01
)paren
suffix:semicolon
)brace
id|octet
op_assign
id|hashcode
op_rshift
l_int|3
suffix:semicolon
multiline_comment|/* bit[3-8] -&gt; octet in filter */
multiline_comment|/* bit[0-2] -&gt; bit in octet */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
r_int
r_char
id|tmp
suffix:semicolon
id|outw
c_func
(paren
(paren
r_int
)paren
(paren
(paren
r_int
)paren
id|multicast_table
)paren
op_plus
id|octet
comma
id|EWRK3_PIR1
)paren
suffix:semicolon
id|tmp
op_assign
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
suffix:semicolon
id|tmp
op_or_assign
(paren
l_int|1
op_lshift
(paren
id|hashcode
op_amp
l_int|0x07
)paren
)paren
suffix:semicolon
id|outw
c_func
(paren
(paren
r_int
)paren
(paren
(paren
r_int
)paren
id|multicast_table
)paren
op_plus
id|octet
comma
id|EWRK3_PIR1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|tmp
comma
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
r_else
(brace
id|multicast_table
(braket
id|octet
)braket
op_or_assign
(paren
l_int|1
op_lshift
(paren
id|hashcode
op_amp
l_int|0x07
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
id|lp-&gt;lock
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Unlock the page register */
r_return
suffix:semicolon
)brace
macro_line|#ifndef MODULE
multiline_comment|/*&n;** ISA bus I/O device probe&n;*/
DECL|function|isa_probe
r_static
r_struct
id|device
op_star
id|isa_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|i
comma
id|iobase
comma
id|status
suffix:semicolon
r_int
r_int
r_int
id|tmp
op_assign
id|mem_chkd
suffix:semicolon
r_for
c_loop
(paren
id|status
op_assign
op_minus
id|ENODEV
comma
id|iobase
op_assign
id|EWRK3_IO_BASE
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|24
suffix:semicolon
id|iobase
op_add_assign
id|EWRK3_IOP_INC
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|tmp
op_amp
l_int|0x01
)paren
(brace
r_if
c_cond
(paren
id|DevicePresent
c_func
(paren
id|iobase
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;** Device found. Mark its (I/O) location for future reference. Only 24&n;** EtherWORKS devices can exist between 0x100 and 0x3e0.&n;*/
r_if
c_cond
(paren
id|num_ewrk3s
OG
l_int|0
)paren
(brace
multiline_comment|/* only gets here in autoprobe */
id|dev
op_assign
id|alloc_device
c_func
(paren
id|dev
comma
id|iobase
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|status
op_assign
id|ewrk3_hw_init
c_func
(paren
id|dev
comma
id|iobase
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|num_ewrk3s
op_increment
suffix:semicolon
)brace
)brace
id|num_eth
op_increment
suffix:semicolon
)brace
r_else
(brace
id|mem_chkd
op_and_assign
op_complement
(paren
l_int|0x01
op_lshift
(paren
(paren
id|iobase
op_minus
id|EWRK3_IO_BASE
)paren
op_div
id|EWRK3_IOP_INC
)paren
)paren
suffix:semicolon
)brace
)brace
id|tmp
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/*&n;** EISA bus I/O device probe. Probe from slot 1 since slot 0 is usually&n;** the motherboard.&n;*/
DECL|function|eisa_probe
r_static
r_struct
id|device
op_star
id|eisa_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|i
comma
id|iobase
op_assign
id|EWRK3_EISA_IO_PORTS
suffix:semicolon
r_int
id|status
suffix:semicolon
id|iobase
op_add_assign
id|EISA_SLOT_INC
suffix:semicolon
multiline_comment|/* get the first slot address */
r_for
c_loop
(paren
id|status
op_assign
op_minus
id|ENODEV
comma
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|MAX_EISA_SLOTS
suffix:semicolon
id|i
op_increment
comma
id|iobase
op_add_assign
id|EISA_SLOT_INC
)paren
(brace
r_if
c_cond
(paren
id|DevicePresent
c_func
(paren
id|iobase
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;** Device found. Mark its slot location for future reference. Only 7&n;** EtherWORKS devices can exist in EISA space....&n;*/
id|mem_chkd
op_or_assign
(paren
l_int|0x01
op_lshift
(paren
id|i
op_plus
l_int|24
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_ewrk3s
OG
l_int|0
)paren
(brace
multiline_comment|/* only gets here in autoprobe */
id|dev
op_assign
id|alloc_device
c_func
(paren
id|dev
comma
id|iobase
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|status
op_assign
id|ewrk3_hw_init
c_func
(paren
id|dev
comma
id|iobase
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|num_ewrk3s
op_increment
suffix:semicolon
)brace
)brace
id|num_eth
op_increment
suffix:semicolon
)brace
)brace
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/*&n;** Allocate the device by pointing to the next available space in the&n;** device structure. Should one not be available, it is created.&n;*/
DECL|function|alloc_device
r_static
r_struct
id|device
op_star
id|alloc_device
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|iobase
)paren
(brace
multiline_comment|/*&n;  ** Check the device structures for an end of list or unused device&n;  */
r_while
c_loop
(paren
id|dev-&gt;next
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;next-&gt;base_addr
op_eq
l_int|0xffe0
)paren
r_break
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
suffix:semicolon
multiline_comment|/* walk through eth device list */
id|num_eth
op_increment
suffix:semicolon
multiline_comment|/* increment eth device number */
)brace
multiline_comment|/*&n;  ** If no more device structures, malloc one up. If memory could&n;  ** not be allocated, print an error message.&n;  */
r_if
c_cond
(paren
id|dev-&gt;next
op_eq
l_int|NULL
)paren
(brace
id|dev-&gt;next
op_assign
(paren
r_struct
id|device
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|device
)paren
op_plus
l_int|8
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;next
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;eth%d: Device not initialised, insufficient memory&bslash;n&quot;
comma
id|num_eth
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;  ** If the memory was allocated, point to the new memory area&n;  ** and initialize it (name, I/O address, next device (NULL) and&n;  ** initialisation probe routine).&n;  */
r_if
c_cond
(paren
(paren
id|dev-&gt;next
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|num_eth
OG
l_int|0
)paren
op_logical_and
(paren
id|num_eth
OL
l_int|9999
)paren
)paren
(brace
id|dev
op_assign
id|dev-&gt;next
suffix:semicolon
multiline_comment|/* point to the new device */
id|dev-&gt;name
op_assign
(paren
r_char
op_star
)paren
(paren
id|dev
op_plus
r_sizeof
(paren
r_struct
id|device
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;eth%d&quot;
comma
id|num_eth
)paren
suffix:semicolon
multiline_comment|/* New device name */
id|dev-&gt;base_addr
op_assign
id|iobase
suffix:semicolon
multiline_comment|/* assign the io address */
id|dev-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* mark the end of list */
id|dev-&gt;init
op_assign
op_amp
id|ewrk3_probe
suffix:semicolon
multiline_comment|/* initialisation routine */
id|num_ewrk3s
op_increment
suffix:semicolon
)brace
r_return
id|dev
suffix:semicolon
)brace
macro_line|#endif    /* MODULE */
multiline_comment|/*&n;** Read the EWRK3 EEPROM using this routine&n;*/
DECL|function|Read_EEPROM
r_static
r_int
id|Read_EEPROM
c_func
(paren
r_int
id|iobase
comma
r_int
r_char
id|eaddr
)paren
(brace
r_int
id|i
suffix:semicolon
id|outb
c_func
(paren
(paren
id|eaddr
op_amp
l_int|0x3f
)paren
comma
id|EWRK3_PIR1
)paren
suffix:semicolon
multiline_comment|/* set up 6 bits of address info */
id|outb
c_func
(paren
id|EEPROM_RD
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
multiline_comment|/* issue read command */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5000
suffix:semicolon
id|i
op_increment
)paren
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
multiline_comment|/* wait 1msec */
r_return
id|inw
c_func
(paren
id|EWRK3_EPROM1
)paren
suffix:semicolon
multiline_comment|/* 16 bits data return */
)brace
multiline_comment|/*&n;** Write the EWRK3 EEPROM using this routine&n;*/
DECL|function|Write_EEPROM
r_static
r_int
id|Write_EEPROM
c_func
(paren
r_int
id|data
comma
r_int
id|iobase
comma
r_int
r_char
id|eaddr
)paren
(brace
r_int
id|i
suffix:semicolon
id|outb
c_func
(paren
id|EEPROM_WR_EN
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
multiline_comment|/* issue write enable command */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5000
suffix:semicolon
id|i
op_increment
)paren
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
multiline_comment|/* wait 1msec */
id|outw
c_func
(paren
id|data
comma
id|EWRK3_EPROM1
)paren
suffix:semicolon
multiline_comment|/* write data to register */
id|outb
c_func
(paren
(paren
id|eaddr
op_amp
l_int|0x3f
)paren
comma
id|EWRK3_PIR1
)paren
suffix:semicolon
multiline_comment|/* set up 6 bits of address info */
id|outb
c_func
(paren
id|EEPROM_WR
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
multiline_comment|/* issue write command */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|75000
suffix:semicolon
id|i
op_increment
)paren
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
multiline_comment|/* wait 15msec */
id|outb
c_func
(paren
id|EEPROM_WR_DIS
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
multiline_comment|/* issue write disable command */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5000
suffix:semicolon
id|i
op_increment
)paren
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
multiline_comment|/* wait 1msec */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** Look for a particular board name in the on-board EEPROM.&n;*/
DECL|function|EthwrkSignature
r_static
r_void
id|EthwrkSignature
c_func
(paren
r_char
op_star
id|name
comma
r_char
op_star
id|eeprom_image
)paren
(brace
r_int
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
r_char
id|signatures
(braket
)braket
(braket
id|EWRK3_NAME_LENGTH
)braket
op_assign
id|EWRK3_SIGNATURE
suffix:semicolon
id|strcpy
c_func
(paren
id|name
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_star
id|signatures
(braket
id|i
)braket
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
op_star
id|name
op_eq
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|EEPROM_PNAME7
comma
id|k
op_assign
l_int|0
suffix:semicolon
id|j
op_le
id|EEPROM_PNAME0
op_logical_and
id|k
OL
id|strlen
c_func
(paren
id|signatures
(braket
id|i
)braket
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|signatures
(braket
id|i
)braket
(braket
id|k
)braket
op_eq
id|eeprom_image
(braket
id|j
)braket
)paren
(brace
multiline_comment|/* track signature */
id|k
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* lost signature; begin search again */
id|k
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|k
op_eq
id|strlen
c_func
(paren
id|signatures
(braket
id|i
)braket
)paren
)paren
(brace
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|EWRK3_NAME_LENGTH
suffix:semicolon
id|k
op_increment
)paren
(brace
id|name
(braket
id|k
)braket
op_assign
id|eeprom_image
(braket
id|EEPROM_PNAME7
op_plus
id|k
)braket
suffix:semicolon
id|name
(braket
id|EWRK3_NAME_LENGTH
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
)brace
)brace
r_return
suffix:semicolon
multiline_comment|/* return the device name string */
)brace
multiline_comment|/*&n;** Look for a special sequence in the Ethernet station address PROM that&n;** is common across all EWRK3 products.&n;*/
DECL|function|DevicePresent
r_static
r_int
id|DevicePresent
c_func
(paren
r_int
id|iobase
)paren
(brace
r_static
r_int
id|fp
op_assign
l_int|1
comma
id|sigLength
op_assign
l_int|0
suffix:semicolon
r_static
r_char
id|devSig
(braket
)braket
op_assign
id|PROBE_SEQUENCE
suffix:semicolon
r_char
id|data
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|status
op_assign
l_int|0
suffix:semicolon
r_static
r_char
id|asc2hex
c_func
(paren
r_char
id|value
)paren
suffix:semicolon
multiline_comment|/* &n;** Convert the ascii signature to a hex equivalent &amp; pack in place &n;*/
r_if
c_cond
(paren
id|fp
)paren
(brace
multiline_comment|/* only do this once!... */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|devSig
(braket
id|i
)braket
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
op_logical_neg
id|status
suffix:semicolon
id|i
op_add_assign
l_int|2
comma
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|devSig
(braket
id|i
)braket
op_assign
id|asc2hex
c_func
(paren
id|devSig
(braket
id|i
)braket
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|devSig
(braket
id|i
)braket
op_lshift_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
(paren
id|devSig
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|asc2hex
c_func
(paren
id|devSig
(braket
id|i
op_plus
l_int|1
)braket
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|devSig
(braket
id|j
)braket
op_assign
id|devSig
(braket
id|i
)braket
op_plus
id|devSig
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|sigLength
op_assign
id|j
suffix:semicolon
id|fp
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n;** Search the Ethernet address ROM for the signature. Since the ROM address&n;** counter can start at an arbitrary point, the search must include the entire&n;** probe sequence length plus the (length_of_the_signature - 1).&n;** Stop the search IMMEDIATELY after the signature is found so that the&n;** PROM address counter is correctly positioned at the start of the&n;** ethernet address for later read out.&n;*/
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|sigLength
op_logical_and
id|i
OL
id|PROBE_LENGTH
op_plus
id|sigLength
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|data
op_assign
id|inb
c_func
(paren
id|EWRK3_APROM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devSig
(braket
id|j
)braket
op_eq
id|data
)paren
(brace
multiline_comment|/* track signature */
id|j
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* lost signature; begin search again */
id|j
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|j
op_ne
id|sigLength
)paren
(brace
id|status
op_assign
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* search failed */
)brace
)brace
r_return
id|status
suffix:semicolon
)brace
DECL|function|aprom_crc
r_static
r_int
r_char
id|aprom_crc
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
r_char
op_star
id|eeprom_image
comma
r_char
id|chipType
)paren
(brace
r_int
id|k
suffix:semicolon
r_int
r_int
id|j
comma
id|chksum
suffix:semicolon
r_int
r_char
id|crc
comma
id|lfsr
comma
id|sd
comma
id|status
op_assign
l_int|0
suffix:semicolon
r_int
id|iobase
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|chipType
op_eq
id|LeMAC2
)paren
(brace
r_for
c_loop
(paren
id|crc
op_assign
l_int|0x6a
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ETH_ALEN
suffix:semicolon
id|j
op_increment
)paren
(brace
r_for
c_loop
(paren
id|sd
op_assign
id|inb
c_func
(paren
id|EWRK3_PAR0
op_plus
id|j
)paren
comma
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|8
suffix:semicolon
id|k
op_increment
comma
id|sd
op_rshift_assign
l_int|1
)paren
(brace
id|lfsr
op_assign
(paren
(paren
(paren
(paren
id|crc
op_amp
l_int|0x02
)paren
op_rshift
l_int|1
)paren
op_xor
(paren
id|crc
op_amp
l_int|0x01
)paren
)paren
op_xor
(paren
id|sd
op_amp
l_int|0x01
)paren
)paren
op_lshift
l_int|7
suffix:semicolon
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|1
)paren
op_plus
id|lfsr
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|crc
op_ne
id|eeprom_image
(braket
id|EEPROM_PA_CRC
)braket
)paren
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|k
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|3
suffix:semicolon
id|j
op_increment
)paren
(brace
id|k
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
l_int|0xffff
)paren
id|k
op_sub_assign
l_int|0xffff
suffix:semicolon
id|k
op_add_assign
id|inw
c_func
(paren
id|EWRK3_PAR0
op_plus
(paren
id|j
op_lshift
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
l_int|0xffff
)paren
id|k
op_sub_assign
l_int|0xffff
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
op_eq
l_int|0xffff
)paren
id|k
op_assign
l_int|0
suffix:semicolon
id|chksum
op_assign
id|inb
c_func
(paren
id|EWRK3_APROM
)paren
suffix:semicolon
id|chksum
op_or_assign
(paren
id|inb
c_func
(paren
id|EWRK3_APROM
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|k
op_ne
id|chksum
)paren
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;** Perform IOCTL call functions here. Some are privileged operations and the&n;** effective uid is checked in those cases.&n;*/
DECL|function|ewrk3_ioctl
r_static
r_int
id|ewrk3_ioctl
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|rq
)paren
(brace
r_struct
id|ewrk3_private
op_star
id|lp
op_assign
(paren
r_struct
id|ewrk3_private
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_struct
id|ewrk3_ioctl
op_star
id|ioc
op_assign
(paren
r_struct
id|ewrk3_ioctl
op_star
)paren
op_amp
id|rq-&gt;ifr_data
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|iobase
op_assign
id|dev-&gt;base_addr
comma
id|status
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|csr
suffix:semicolon
r_union
(brace
r_int
r_char
id|addr
(braket
id|HASH_TABLE_LEN
op_star
id|ETH_ALEN
)braket
suffix:semicolon
r_int
r_int
id|val
(braket
(paren
id|HASH_TABLE_LEN
op_star
id|ETH_ALEN
)paren
op_rshift
l_int|1
)braket
suffix:semicolon
)brace
id|tmp
suffix:semicolon
r_switch
c_cond
(paren
id|ioc-&gt;cmd
)paren
(brace
r_case
id|EWRK3_GET_HWADDR
suffix:colon
multiline_comment|/* Get the hardware address */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp.addr
(braket
id|i
)braket
op_assign
id|dev-&gt;dev_addr
(braket
id|i
)braket
suffix:semicolon
)brace
id|ioc-&gt;len
op_assign
id|ETH_ALEN
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|ioc-&gt;data
comma
id|tmp.addr
comma
id|ioc-&gt;len
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EWRK3_SET_HWADDR
suffix:colon
multiline_comment|/* Set the hardware address */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
id|csr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
id|csr
op_or_assign
(paren
id|TXD
op_or
id|RXD
)paren
suffix:semicolon
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
multiline_comment|/* Disable the TX and RX */
id|memcpy_fromfs
c_func
(paren
id|tmp.addr
comma
id|ioc-&gt;data
comma
id|ETH_ALEN
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|tmp.addr
(braket
id|i
)braket
suffix:semicolon
id|outb
c_func
(paren
id|tmp.addr
(braket
id|i
)braket
comma
id|EWRK3_PAR0
op_plus
id|i
)paren
suffix:semicolon
)brace
id|csr
op_and_assign
op_complement
(paren
id|TXD
op_or
id|RXD
)paren
suffix:semicolon
multiline_comment|/* Enable the TX and RX */
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_SET_PROM
suffix:colon
multiline_comment|/* Set Promiscuous Mode */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
id|csr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
id|csr
op_or_assign
id|PME
suffix:semicolon
id|csr
op_and_assign
op_complement
id|MCE
suffix:semicolon
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_CLR_PROM
suffix:colon
multiline_comment|/* Clear Promiscuous Mode */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
id|csr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
id|csr
op_and_assign
op_complement
id|PME
suffix:semicolon
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_SAY_BOO
suffix:colon
multiline_comment|/* Say &quot;Boo!&quot; to the kernel log file */
id|printk
c_func
(paren
l_string|&quot;%s: Boo!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EWRK3_GET_MCA
suffix:colon
multiline_comment|/* Get the multicast address table */
r_while
c_loop
(paren
id|set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|lp-&gt;lock
)paren
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Wait for lock to free */
r_if
c_cond
(paren
id|lp-&gt;shmem_length
op_eq
id|IO_ONLY
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|EWRK3_IOPR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|PAGE0_HTE
comma
id|EWRK3_PIR1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp.addr
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|EWRK3_DATA
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|outb
c_func
(paren
l_int|0
comma
id|EWRK3_MPR
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tmp.addr
comma
(paren
r_char
op_star
)paren
(paren
id|lp-&gt;shmem_base
op_plus
id|PAGE0_HTE
)paren
comma
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
)paren
suffix:semicolon
)brace
id|ioc-&gt;len
op_assign
(paren
id|HASH_TABLE_LEN
op_rshift
l_int|3
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|ioc-&gt;data
comma
id|tmp.addr
comma
id|ioc-&gt;len
)paren
suffix:semicolon
id|lp-&gt;lock
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Unlock the page register */
r_break
suffix:semicolon
r_case
id|EWRK3_SET_MCA
suffix:colon
multiline_comment|/* Set a multicast address */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|ioc-&gt;len
op_ne
id|HASH_TABLE_LEN
)paren
(brace
multiline_comment|/* MCA changes */
id|memcpy_fromfs
c_func
(paren
id|tmp.addr
comma
id|ioc-&gt;data
comma
id|ETH_ALEN
op_star
id|ioc-&gt;len
)paren
suffix:semicolon
)brace
id|set_multicast_list
c_func
(paren
id|dev
comma
id|ioc-&gt;len
comma
id|tmp.addr
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_CLR_MCA
suffix:colon
multiline_comment|/* Clear all multicast addresses */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
id|set_multicast_list
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_MCA_EN
suffix:colon
multiline_comment|/* Enable multicast addressing */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
id|csr
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
id|csr
op_or_assign
id|MCE
suffix:semicolon
id|csr
op_and_assign
op_complement
id|PME
suffix:semicolon
id|outb
c_func
(paren
id|csr
comma
id|EWRK3_CSR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_GET_STATS
suffix:colon
multiline_comment|/* Get the driver statistics */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|ioc-&gt;data
comma
op_amp
id|lp-&gt;pktStats
comma
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
)paren
suffix:semicolon
id|ioc-&gt;len
op_assign
id|EWRK3_PKT_STAT_SZ
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EWRK3_CLR_STATS
suffix:colon
multiline_comment|/* Zero out the driver statistics */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|lp-&gt;pktStats
comma
l_int|0
comma
r_sizeof
(paren
id|lp-&gt;pktStats
)paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_GET_CSR
suffix:colon
multiline_comment|/* Get the CSR Register contents */
id|tmp.addr
(braket
l_int|0
)braket
op_assign
id|inb
c_func
(paren
id|EWRK3_CSR
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|ioc-&gt;data
comma
id|tmp.addr
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EWRK3_SET_CSR
suffix:colon
multiline_comment|/* Set the CSR Register contents */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
id|memcpy_fromfs
c_func
(paren
id|tmp.addr
comma
id|ioc-&gt;data
comma
l_int|1
)paren
suffix:semicolon
id|outb
c_func
(paren
id|tmp.addr
(braket
l_int|0
)braket
comma
id|EWRK3_CSR
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_GET_EEPROM
suffix:colon
multiline_comment|/* Get the EEPROM contents */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|EEPROM_MAX
op_rshift
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp.val
(braket
id|i
)braket
op_assign
(paren
r_int
)paren
id|Read_EEPROM
c_func
(paren
id|iobase
comma
id|i
)paren
suffix:semicolon
)brace
id|i
op_assign
id|EEPROM_MAX
suffix:semicolon
id|tmp.addr
(braket
id|i
op_increment
)braket
op_assign
id|inb
c_func
(paren
id|EWRK3_CMR
)paren
suffix:semicolon
multiline_comment|/* Config/Management Reg. */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ETH_ALEN
suffix:semicolon
id|j
op_increment
)paren
(brace
id|tmp.addr
(braket
id|i
op_increment
)braket
op_assign
id|inb
c_func
(paren
id|EWRK3_PAR0
op_plus
id|j
)paren
suffix:semicolon
)brace
id|ioc-&gt;len
op_assign
id|EEPROM_MAX
op_plus
l_int|1
op_plus
id|ETH_ALEN
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|ioc-&gt;data
comma
id|tmp.addr
comma
id|ioc-&gt;len
)paren
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_SET_EEPROM
suffix:colon
multiline_comment|/* Set the EEPROM contents */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
id|memcpy_fromfs
c_func
(paren
id|tmp.addr
comma
id|ioc-&gt;data
comma
id|EEPROM_MAX
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|EEPROM_MAX
op_rshift
l_int|1
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|Write_EEPROM
c_func
(paren
id|tmp.val
(braket
id|i
)braket
comma
id|iobase
comma
id|i
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_GET_CMR
suffix:colon
multiline_comment|/* Get the CMR Register contents */
id|tmp.addr
(braket
l_int|0
)braket
op_assign
id|inb
c_func
(paren
id|EWRK3_CMR
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|ioc-&gt;data
comma
id|tmp.addr
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EWRK3_SET_TX_CUT_THRU
suffix:colon
multiline_comment|/* Set TX cut through mode */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
id|lp-&gt;txc
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|EWRK3_CLR_TX_CUT_THRU
suffix:colon
multiline_comment|/* Clear TX cut through mode */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
id|lp-&gt;txc
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|status
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
DECL|function|asc2hex
r_static
r_char
id|asc2hex
c_func
(paren
r_char
id|value
)paren
(brace
id|value
op_sub_assign
l_int|0x30
suffix:semicolon
multiline_comment|/* normalise to 0..9 range */
r_if
c_cond
(paren
id|value
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|value
OG
l_int|9
)paren
(brace
multiline_comment|/* but may not be 10..15 */
id|value
op_and_assign
l_int|0x1f
suffix:semicolon
multiline_comment|/* make A..F &amp; a..f be the same */
id|value
op_sub_assign
l_int|0x07
suffix:semicolon
multiline_comment|/* normalise to 10..15 range */
r_if
c_cond
(paren
(paren
id|value
OL
l_int|0x0a
)paren
op_logical_or
(paren
id|value
OG
l_int|0x0f
)paren
)paren
(brace
multiline_comment|/* if outside range then... */
id|value
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* ...signal error */
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* outside 0..9 range... */
id|value
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* ...signal error */
)brace
r_return
id|value
suffix:semicolon
multiline_comment|/* return hex char or error */
)brace
macro_line|#ifdef MODULE
DECL|variable|kernel_version
r_char
id|kernel_version
(braket
)braket
op_assign
id|UTS_RELEASE
suffix:semicolon
DECL|variable|thisEthwrk
r_static
r_struct
id|device
id|thisEthwrk
op_assign
(brace
l_string|&quot;        &quot;
comma
multiline_comment|/* device name inserted by /linux/drivers/net/net_init.c */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0x300
comma
l_int|5
comma
multiline_comment|/* I/O address, IRQ &lt;--- EDIT THIS LINE FOR YOUR CONFIGURATION */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
id|ewrk3_probe
)brace
suffix:semicolon
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
op_amp
id|thisEthwrk
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|MOD_IN_USE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: device busy, remove delayed&bslash;n&quot;
comma
id|thisEthwrk.name
)paren
suffix:semicolon
)brace
r_else
(brace
id|unregister_netdev
c_func
(paren
op_amp
id|thisEthwrk
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* MODULE */
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  kernel-compile-command: &quot;gcc -D__KERNEL__ -I/usr/src/linux/net/inet -Wall -Wstrict-prototypes -O2 -m486 -c ewrk3.c&quot;&n; *&n; *  module-compile-command: &quot;gcc -D__KERNEL__ -DMODULE -I/usr/src/linux/net/inet -Wall -Wstrict-prototypes -O2 -m486 -c ewrk3.c&quot;&n; * End:&n; */
eof
