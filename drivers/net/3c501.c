multiline_comment|/* 3c501.c: A 3Com 3c501 Ethernet driver for Linux. */
multiline_comment|/*&n;    Written 1992,1993,1994  Donald Becker&n;&n;    Copyright 1993 United States Government as represented by the&n;    Director, National Security Agency.  This software may be used and&n;    distributed according to the terms of the GNU Public License,&n;    incorporated herein by reference.&n;&n;    This is a device driver for the 3Com Etherlink 3c501.&n;    Do not purchase this card, even as a joke.  It&squot;s performance is horrible,&n;    and it breaks in many ways.&n;&n;    The author may be reached as becker@CESDIS.gsfc.nasa.gov, or C/O&n;    Center of Excellence in Space Data and Information Sciences&n;       Code 930.5, Goddard Space Flight Center, Greenbelt MD 20771&n;&n;    Fixed (again!) the missing interrupt locking on TX/RX shifting.&n;    &t;&t;Alan Cox &lt;Alan.Cox@linux.org&gt;&n;&n;    Removed calls to init_etherdev since they are no longer needed, and&n;    cleaned up modularization just a bit. The driver still allows only&n;    the default address for cards when loaded as a module, but that&squot;s&n;    really less braindead than anyone using a 3c501 board. :)&n;&t;&t;    19950208 (invid@msen.com)&n;&n;    Added traps for interrupts hitting the window as we clear and TX load&n;    the board. Now getting 150K/second FTP with a 3c501 card. Still playing&n;    with a TX-TX optimisation to see if we can touch 180-200K/second as seems&n;    theoretically maximum.&n;    &t;&t;19950402 Alan Cox &lt;Alan.Cox@linux.org&gt;&n;    &t;&t;&n;    Cleaned up for 2.3.x because we broke SMP now. &n;    &t;&t;20000208 Alan Cox &lt;alan@redhat.com&gt;&n;    &t;&t;&n;*/
multiline_comment|/**&n; * DOC: 3c501 Card Notes&n; *&n; *  Some notes on this thing if you have to hack it.  [Alan]&n; *&n; *  Some documentation is available from 3Com. Due to the boards age&n; *  standard responses when you ask for this will range from &squot;be serious&squot;&n; *  to &squot;give it to a museum&squot;. The documentation is incomplete and mostly&n; *  of historical interest anyway. &n; *&n; *  The basic system is a single buffer which can be used to receive or&n; *  transmit a packet. A third command mode exists when you are setting&n; *  things up.&n; *&n; *  If it&squot;s transmitting it&squot;s not receiving and vice versa. In fact the&n; *  time to get the board back into useful state after an operation is&n; *  quite large.&n; *&n; *  The driver works by keeping the board in receive mode waiting for a&n; *  packet to arrive. When one arrives it is copied out of the buffer&n; *  and delivered to the kernel. The card is reloaded and off we go.&n; *&n; *  When transmitting lp-&gt;txing is set and the card is reset (from&n; *  receive mode) [possibly losing a packet just received] to command&n; *  mode. A packet is loaded and transmit mode triggered. The interrupt&n; *  handler runs different code for transmit interrupts and can handle&n; *  returning to receive mode or retransmissions (yes you have to help&n; *  out with those too).&n; *&n; * DOC: Problems&n; *  &n; *  There are a wide variety of undocumented error returns from the card&n; *  and you basically have to kick the board and pray if they turn up. Most&n; *  only occur under extreme load or if you do something the board doesn&squot;t&n; *  like (eg touching a register at the wrong time).&n; *&n; *  The driver is less efficient than it could be. It switches through&n; *  receive mode even if more transmits are queued. If this worries you buy&n; *  a real Ethernet card.&n; *&n; *  The combination of slow receive restart and no real multicast&n; *  filter makes the board unusable with a kernel compiled for IP&n; *  multicasting in a real multicast environment. That&squot;s down to the board,&n; *  but even with no multicast programs running a multicast IP kernel is&n; *  in group 224.0.0.1 and you will therefore be listening to all multicasts.&n; *  One nv conference running over that Ethernet and you can give up.&n; *&n; */
DECL|variable|version
r_static
r_const
r_char
op_star
id|version
op_assign
l_string|&quot;3c501.c: 2000/02/08 Alan Cox (alan@redhat.com).&bslash;n&quot;
suffix:semicolon
multiline_comment|/*&n; *&t;Braindamage remaining:&n; *&t;The 3c501 board.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/config.h&gt;&t;/* for CONFIG_IP_MULTICAST */
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/etherdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/init.h&gt;
multiline_comment|/* A zero-terminated list of I/O addresses to be probed.&n;   The 3c501 can be at many locations, but here are the popular ones. */
DECL|variable|__initdata
r_static
r_int
r_int
id|netcard_portlist
(braket
)braket
id|__initdata
op_assign
(brace
l_int|0x280
comma
l_int|0x300
comma
l_int|0
)brace
suffix:semicolon
"&f;"
multiline_comment|/*&n; *&t;Index to functions.&n; */
r_int
id|el1_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|el1_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|el_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|el_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|el_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|el_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|el_receive
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|el_reset
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|el1_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|net_device_stats
op_star
id|el1_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
DECL|macro|EL1_IO_EXTENT
mdefine_line|#define EL1_IO_EXTENT&t;16
macro_line|#ifndef EL_DEBUG
DECL|macro|EL_DEBUG
mdefine_line|#define EL_DEBUG  0&t;/* use 0 for production, 1 for devel., &gt;2 for debug */
macro_line|#endif&t;&t;&t;/* Anything above 5 is wordy death! */
DECL|variable|el_debug
r_static
r_int
id|el_debug
op_assign
id|EL_DEBUG
suffix:semicolon
multiline_comment|/*&n; *&t;Board-specific info in dev-&gt;priv.&n; */
DECL|struct|net_local
r_struct
id|net_local
(brace
DECL|member|stats
r_struct
id|net_device_stats
id|stats
suffix:semicolon
DECL|member|tx_pkt_start
r_int
id|tx_pkt_start
suffix:semicolon
multiline_comment|/* The length of the current Tx packet. */
DECL|member|collisions
r_int
id|collisions
suffix:semicolon
multiline_comment|/* Tx collisions this packet */
DECL|member|loading
r_int
id|loading
suffix:semicolon
multiline_comment|/* Spot buffer load collisions */
DECL|member|txing
r_int
id|txing
suffix:semicolon
multiline_comment|/* True if card is in TX mode */
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
multiline_comment|/* Serializing lock */
)brace
suffix:semicolon
"&f;"
DECL|macro|RX_STATUS
mdefine_line|#define RX_STATUS (ioaddr + 0x06)
DECL|macro|RX_CMD
mdefine_line|#define RX_CMD&t;  RX_STATUS
DECL|macro|TX_STATUS
mdefine_line|#define TX_STATUS (ioaddr + 0x07)
DECL|macro|TX_CMD
mdefine_line|#define TX_CMD&t;  TX_STATUS
DECL|macro|GP_LOW
mdefine_line|#define GP_LOW &t;  (ioaddr + 0x08)
DECL|macro|GP_HIGH
mdefine_line|#define GP_HIGH   (ioaddr + 0x09)
DECL|macro|RX_BUF_CLR
mdefine_line|#define RX_BUF_CLR (ioaddr + 0x0A)
DECL|macro|RX_LOW
mdefine_line|#define RX_LOW&t;  (ioaddr + 0x0A)
DECL|macro|RX_HIGH
mdefine_line|#define RX_HIGH   (ioaddr + 0x0B)
DECL|macro|SAPROM
mdefine_line|#define SAPROM&t;  (ioaddr + 0x0C)
DECL|macro|AX_STATUS
mdefine_line|#define AX_STATUS (ioaddr + 0x0E)
DECL|macro|AX_CMD
mdefine_line|#define AX_CMD&t;  AX_STATUS
DECL|macro|DATAPORT
mdefine_line|#define DATAPORT  (ioaddr + 0x0F)
DECL|macro|TX_RDY
mdefine_line|#define TX_RDY 0x08&t;&t;/* In TX_STATUS */
DECL|macro|EL1_DATAPTR
mdefine_line|#define EL1_DATAPTR&t;0x08
DECL|macro|EL1_RXPTR
mdefine_line|#define EL1_RXPTR&t;0x0A
DECL|macro|EL1_SAPROM
mdefine_line|#define EL1_SAPROM&t;0x0C
DECL|macro|EL1_DATAPORT
mdefine_line|#define EL1_DATAPORT &t;0x0f
multiline_comment|/*&n; *&t;Writes to the ax command register.&n; */
DECL|macro|AX_OFF
mdefine_line|#define AX_OFF&t;0x00&t;&t;&t;/* Irq off, buffer access on */
DECL|macro|AX_SYS
mdefine_line|#define AX_SYS  0x40&t;&t;&t;/* Load the buffer */
DECL|macro|AX_XMIT
mdefine_line|#define AX_XMIT 0x44&t;&t;&t;/* Transmit a packet */
DECL|macro|AX_RX
mdefine_line|#define AX_RX&t;0x48&t;&t;&t;/* Receive a packet */
DECL|macro|AX_LOOP
mdefine_line|#define AX_LOOP&t;0x0C&t;&t;&t;/* Loopback mode */
DECL|macro|AX_RESET
mdefine_line|#define AX_RESET 0x80
multiline_comment|/*&n; *&t;Normal receive mode written to RX_STATUS.  We must intr on short packets&n; *&t;to avoid bogus rx lockups.&n; */
DECL|macro|RX_NORM
mdefine_line|#define RX_NORM 0xA8&t;&t;/* 0x68 == all addrs, 0xA8 only to me. */
DECL|macro|RX_PROM
mdefine_line|#define RX_PROM 0x68&t;&t;/* Senior Prom, uhmm promiscuous mode. */
DECL|macro|RX_MULT
mdefine_line|#define RX_MULT 0xE8&t;&t;/* Accept multicast packets. */
DECL|macro|TX_NORM
mdefine_line|#define TX_NORM 0x0A&t;&t;/* Interrupt on everything that might hang the chip */
multiline_comment|/*&n; *&t;TX_STATUS register.&n; */
DECL|macro|TX_COLLISION
mdefine_line|#define TX_COLLISION 0x02
DECL|macro|TX_16COLLISIONS
mdefine_line|#define TX_16COLLISIONS 0x04
DECL|macro|TX_READY
mdefine_line|#define TX_READY 0x08
DECL|macro|RX_RUNT
mdefine_line|#define RX_RUNT 0x08
DECL|macro|RX_MISSED
mdefine_line|#define RX_MISSED 0x01&t;&t;/* Missed a packet due to 3c501 braindamage. */
DECL|macro|RX_GOOD
mdefine_line|#define RX_GOOD&t;0x30&t;&t;/* Good packet 0x20, or simple overflow 0x10. */
"&f;"
multiline_comment|/*&n; *&t;The boilerplate probe code.&n; */
multiline_comment|/**&n; * el1_probe:&n; * @dev: The device structure passed in to probe. &n; *&n; * This can be called from two places. The network layer will probe using&n; * a device structure passed in with the probe information completed. For a&n; * modular driver we use #init_module to fill in our own structure and probe&n; * for it.&n; *&n; * Returns 0 on success. ENXIO if asked not to probe and ENODEV if asked to&n; * probe and failing to find anything.&n; */
DECL|function|el1_probe
r_int
id|__init
id|el1_probe
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|SET_MODULE_OWNER
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
OG
l_int|0x1ff
)paren
multiline_comment|/* Check a single specified location. */
r_return
id|el1_probe1
c_func
(paren
id|dev
comma
id|base_addr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|base_addr
op_ne
l_int|0
)paren
multiline_comment|/* Don&squot;t probe at all. */
r_return
op_minus
id|ENXIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|netcard_portlist
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|el1_probe1
c_func
(paren
id|dev
comma
id|netcard_portlist
(braket
id|i
)braket
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;el1_probe: &n; *&t;@dev: The device structure to use&n; *&t;@ioaddr: An I/O address to probe at.&n; *&n; *&t;The actual probe. This is iterated over by #el1_probe in order to&n; *&t;check all the applicable device locations.&n; *&n; *&t;Returns 0 for a success, in which case the device is activated,&n; *&t;EAGAIN if the IRQ is in use by another driver, and ENODEV if the&n; *&t;board cannot be found.&n; */
DECL|function|el1_probe1
r_static
r_int
id|__init
id|el1_probe1
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
r_struct
id|net_local
op_star
id|lp
suffix:semicolon
r_const
r_char
op_star
id|mname
suffix:semicolon
multiline_comment|/* Vendor name */
r_int
r_char
id|station_addr
(braket
l_int|6
)braket
suffix:semicolon
r_int
id|autoirq
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Reserve I/O resource for exclusive use by this driver&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|ioaddr
comma
id|EL1_IO_EXTENT
comma
id|dev-&gt;name
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Read the station address PROM data from the special port.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outw
c_func
(paren
id|i
comma
id|ioaddr
op_plus
id|EL1_DATAPTR
)paren
suffix:semicolon
id|station_addr
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|EL1_SAPROM
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Check the first three octets of the S.A. for 3Com&squot;s prefix, or&n;&t; *&t;for the Sager NP943 prefix.&n;&t; */
r_if
c_cond
(paren
id|station_addr
(braket
l_int|0
)braket
op_eq
l_int|0x02
op_logical_and
id|station_addr
(braket
l_int|1
)braket
op_eq
l_int|0x60
op_logical_and
id|station_addr
(braket
l_int|2
)braket
op_eq
l_int|0x8c
)paren
(brace
id|mname
op_assign
l_string|&quot;3c501&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|station_addr
(braket
l_int|0
)braket
op_eq
l_int|0x00
op_logical_and
id|station_addr
(braket
l_int|1
)braket
op_eq
l_int|0x80
op_logical_and
id|station_addr
(braket
l_int|2
)braket
op_eq
l_int|0xC8
)paren
(brace
id|mname
op_assign
l_string|&quot;NP943&quot;
suffix:semicolon
)brace
r_else
(brace
id|release_region
c_func
(paren
id|ioaddr
comma
id|EL1_IO_EXTENT
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;We auto-IRQ by shutting off the interrupt line and letting it float&n;&t; *&t;high.&n;&t; */
r_if
c_cond
(paren
id|dev-&gt;irq
OL
l_int|2
)paren
(brace
id|autoirq_setup
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|inb
c_func
(paren
id|RX_STATUS
)paren
suffix:semicolon
multiline_comment|/* Clear pending interrupts. */
id|inb
c_func
(paren
id|TX_STATUS
)paren
suffix:semicolon
id|outb
c_func
(paren
id|AX_LOOP
op_plus
l_int|1
comma
id|AX_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|AX_CMD
)paren
suffix:semicolon
id|autoirq
op_assign
id|autoirq_report
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|autoirq
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s probe at %#x failed to detect IRQ line.&bslash;n&quot;
comma
id|mname
comma
id|ioaddr
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|ioaddr
comma
id|EL1_IO_EXTENT
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
)brace
id|outb
c_func
(paren
id|AX_RESET
op_plus
id|AX_LOOP
comma
id|AX_CMD
)paren
suffix:semicolon
multiline_comment|/* Loopback mode. */
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
id|memcpy
c_func
(paren
id|dev-&gt;dev_addr
comma
id|station_addr
comma
id|ETH_ALEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;mem_start
op_amp
l_int|0xf
)paren
id|el_debug
op_assign
id|dev-&gt;mem_start
op_amp
l_int|0x7
suffix:semicolon
r_if
c_cond
(paren
id|autoirq
)paren
id|dev-&gt;irq
op_assign
id|autoirq
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: %s EtherLink at %#lx, using %sIRQ %d.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|mname
comma
id|dev-&gt;base_addr
comma
id|autoirq
ques
c_cond
l_string|&quot;auto&quot;
suffix:colon
l_string|&quot;assigned &quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_IP_MULTICAST
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;WARNING: Use of the 3c501 in a multicast kernel is NOT recommended.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|el_debug
)paren
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|version
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Initialize the device structure.&n;&t; */
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;priv
op_eq
l_int|NULL
)paren
(brace
id|release_region
c_func
(paren
id|ioaddr
comma
id|EL1_IO_EXTENT
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
id|lp
op_assign
id|dev-&gt;priv
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;The EL1-specific entries in the device structure.&n;&t; */
id|dev-&gt;open
op_assign
op_amp
id|el_open
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
op_amp
id|el_start_xmit
suffix:semicolon
id|dev-&gt;tx_timeout
op_assign
op_amp
id|el_timeout
suffix:semicolon
id|dev-&gt;watchdog_timeo
op_assign
id|HZ
suffix:semicolon
id|dev-&gt;stop
op_assign
op_amp
id|el1_close
suffix:semicolon
id|dev-&gt;get_stats
op_assign
op_amp
id|el1_get_stats
suffix:semicolon
id|dev-&gt;set_multicast_list
op_assign
op_amp
id|set_multicast_list
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Setup the generic properties&n;&t; */
id|ether_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;el1_open:&n; *&t;@dev: device that is being opened&n; *&n; *&t;When an ifconfig is issued which changes the device flags to include&n; *&t;IFF_UP this function is called. It is only called when the change &n; *&t;occurs, not when the interface remains up. #el1_close will be called&n; *&t;when it goes down.&n; *&n; *&t;Returns 0 for a successful open, or -EAGAIN if someone has run off&n; *&t;with our interrupt line.&n; */
DECL|function|el_open
r_static
r_int
id|el_open
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|el_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Doing el_open()...&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|el_interrupt
comma
l_int|0
comma
id|dev-&gt;name
comma
id|dev
)paren
)paren
)paren
r_return
id|retval
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|el_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|lp-&gt;txing
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Board in RX mode */
id|outb
c_func
(paren
id|AX_RX
comma
id|AX_CMD
)paren
suffix:semicolon
multiline_comment|/* Aux control, irq and receive enabled */
id|netif_start_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * el_timeout:&n; * @dev: The 3c501 card that has timed out&n; *&n; * Attempt to restart the board. This is basically a mixture of extreme&n; * violence and prayer&n; *&n; */
DECL|function|el_timeout
r_static
r_void
id|el_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|el_debug
)paren
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: transmit timed out, txsr %#2x axsr=%02x rxsr=%02x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|inb
c_func
(paren
id|TX_STATUS
)paren
comma
id|inb
c_func
(paren
id|AX_STATUS
)paren
comma
id|inb
c_func
(paren
id|RX_STATUS
)paren
)paren
suffix:semicolon
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
id|outb
c_func
(paren
id|TX_NORM
comma
id|TX_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
id|RX_NORM
comma
id|RX_CMD
)paren
suffix:semicolon
id|outb
c_func
(paren
id|AX_OFF
comma
id|AX_CMD
)paren
suffix:semicolon
multiline_comment|/* Just trigger a false interrupt. */
id|outb
c_func
(paren
id|AX_RX
comma
id|AX_CMD
)paren
suffix:semicolon
multiline_comment|/* Aux control, irq and receive enabled */
id|lp-&gt;txing
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Ripped back in to RX */
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * el_start_xmit:&n; * @skb: The packet that is queued to be sent&n; * @dev: The 3c501 card we want to throw it down&n; *&n; * Attempt to send a packet to a 3c501 card. There are some interesting&n; * catches here because the 3c501 is an extremely old and therefore&n; * stupid piece of technology.&n; *&n; * If we are handling an interrupt on the other CPU we cannot load a packet&n; * as we may still be attempting to retrieve the last RX packet buffer.&n; *&n; * When a transmit times out we dump the card into control mode and just&n; * start again. It happens enough that it isnt worth logging.&n; *&n; * We avoid holding the spin locks when doing the packet load to the board.&n; * The device is very slow, and its DMA mode is even slower. If we held the&n; * lock while loading 1500 bytes onto the controller we would drop a lot of&n; * serial port characters. This requires we do extra locking, but we have&n; * no real choice.&n; */
DECL|function|el_start_xmit
r_static
r_int
id|el_start_xmit
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Avoid incoming interrupts between us flipping txing and flipping&n;&t; *&t;mode as the driver assumes txing is a faithful indicator of card&n;&t; *&t;state&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Avoid timer-based retransmission conflicts.&n;&t; */
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_do
(brace
r_int
id|gp_start
op_assign
l_int|0x800
op_minus
(paren
id|ETH_ZLEN
OL
id|skb-&gt;len
ques
c_cond
id|skb-&gt;len
suffix:colon
id|ETH_ZLEN
)paren
suffix:semicolon
r_int
r_char
op_star
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
id|lp-&gt;tx_pkt_start
op_assign
id|gp_start
suffix:semicolon
id|lp-&gt;collisions
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;stats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Command mode with status cleared should [in theory]&n;&t;&t; *&t;mean no more interrupts can be pending on the card.&n;&t;&t; */
id|outb_p
c_func
(paren
id|AX_SYS
comma
id|AX_CMD
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|RX_STATUS
)paren
suffix:semicolon
id|inb_p
c_func
(paren
id|TX_STATUS
)paren
suffix:semicolon
id|lp-&gt;loading
op_assign
l_int|1
suffix:semicolon
id|lp-&gt;txing
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Turn interrupts back on while we spend a pleasant afternoon&n;&t;&t; *&t;loading bytes into the board&n;&t;&t; */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x00
comma
id|RX_BUF_CLR
)paren
suffix:semicolon
multiline_comment|/* Set rx packet area to 0. */
id|outw
c_func
(paren
id|gp_start
comma
id|GP_LOW
)paren
suffix:semicolon
multiline_comment|/* aim - packet will be loaded into buffer start */
id|outsb
c_func
(paren
id|DATAPORT
comma
id|buf
comma
id|skb-&gt;len
)paren
suffix:semicolon
multiline_comment|/* load buffer (usual thing each byte increments the pointer) */
id|outw
c_func
(paren
id|gp_start
comma
id|GP_LOW
)paren
suffix:semicolon
multiline_comment|/* the board reuses the same register */
r_if
c_cond
(paren
id|lp-&gt;loading
op_ne
l_int|2
)paren
(brace
id|outb
c_func
(paren
id|AX_XMIT
comma
id|AX_CMD
)paren
suffix:semicolon
multiline_comment|/* fire ... Trigger xmit.  */
id|lp-&gt;loading
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|el_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot; queued xmit.&bslash;n&quot;
)paren
suffix:semicolon
id|dev_kfree_skb
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* A receive upset our load, despite our best efforts */
r_if
c_cond
(paren
id|el_debug
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: burped during tx load.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|lp-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
suffix:semicolon
)brace
)brace
"&f;"
multiline_comment|/**&n; * el_interrupt:&n; * @irq: Interrupt number&n; * @dev_id: The 3c501 that burped&n; * @regs: Register data (surplus to our requirements)&n; *&n; * Handle the ether interface interrupts. The 3c501 needs a lot more &n; * hand holding than most cards. In paticular we get a transmit interrupt&n; * with a collision error because the board firmware isnt capable of rewinding&n; * its own transmit buffer pointers. It can however count to 16 for us.&n; *&n; * On the receive side the card is also very dumb. It has no buffering to&n; * speak of. We simply pull the packet out of its PIO buffer (which is slow)&n; * and queue it for the kernel. Then we reset the card for the next packet.&n; *&n; * We sometimes get suprise interrupts late both because the SMP IRQ delivery&n; * is message passing and because the card sometimes seems to deliver late. I&n; * think if it is part way through a receive and the mode is changed it carries&n; * on receiving and sends us an interrupt. We have to band aid all these cases&n; * to get a sensible 150kbytes/second performance. Even then you want a small&n; * TCP window.&n; */
DECL|function|el_interrupt
r_static
r_void
id|el_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|net_device
op_star
id|dev
op_assign
id|dev_id
suffix:semicolon
r_struct
id|net_local
op_star
id|lp
suffix:semicolon
r_int
id|ioaddr
suffix:semicolon
r_int
id|axsr
suffix:semicolon
multiline_comment|/* Aux. status reg. */
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;What happened ?&n;&t; */
id|axsr
op_assign
id|inb
c_func
(paren
id|AX_STATUS
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Log it&n;&t; */
r_if
c_cond
(paren
id|el_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: el_interrupt() aux=%#02x&quot;
comma
id|dev-&gt;name
comma
id|axsr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;loading
op_eq
l_int|1
op_logical_and
op_logical_neg
id|lp-&gt;txing
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: Inconsistent state loading while not in tx&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;txing
)paren
(brace
multiline_comment|/*&n;    &t;&t; *&t;Board in transmit mode. May be loading. If we are&n;    &t;&t; *&t;loading we shouldn&squot;t have got this.&n;    &t;&t; */
r_int
id|txsr
op_assign
id|inb
c_func
(paren
id|TX_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;loading
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|el_debug
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: Interrupt while loading [&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; txsr=%02x gp=%04x rp=%04x]&bslash;n&quot;
comma
id|txsr
comma
id|inw
c_func
(paren
id|GP_LOW
)paren
comma
id|inw
c_func
(paren
id|RX_LOW
)paren
)paren
suffix:semicolon
)brace
id|lp-&gt;loading
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* Force a reload */
id|spin_unlock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|el_debug
OG
l_int|6
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot; txsr=%02x gp=%04x rp=%04x&quot;
comma
id|txsr
comma
id|inw
c_func
(paren
id|GP_LOW
)paren
comma
id|inw
c_func
(paren
id|RX_LOW
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|axsr
op_amp
l_int|0x80
)paren
op_logical_and
(paren
id|txsr
op_amp
id|TX_READY
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;FIXME: is there a logic to whether to keep on trying or&n;&t;&t;&t; *&t;reset immediately ?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|el_debug
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Unusual interrupt during Tx, txsr=%02x axsr=%02x&quot;
l_string|&quot; gp=%03x rp=%03x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|txsr
comma
id|axsr
comma
id|inw
c_func
(paren
id|ioaddr
op_plus
id|EL1_DATAPTR
)paren
comma
id|inw
c_func
(paren
id|ioaddr
op_plus
id|EL1_RXPTR
)paren
)paren
suffix:semicolon
)brace
id|lp-&gt;txing
op_assign
l_int|0
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|txsr
op_amp
id|TX_16COLLISIONS
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Timed out&n;&t;&t;&t; */
r_if
c_cond
(paren
id|el_debug
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Transmit failed 16 times, Ethernet jammed?&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|outb
c_func
(paren
id|AX_SYS
comma
id|AX_CMD
)paren
suffix:semicolon
id|lp-&gt;txing
op_assign
l_int|0
suffix:semicolon
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|txsr
op_amp
id|TX_COLLISION
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Retrigger xmit.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|el_debug
OG
l_int|6
)paren
id|printk
c_func
(paren
l_string|&quot; retransmitting after a collision.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Poor little chip can&squot;t reset its own start pointer&n;&t;&t;&t; */
id|outb
c_func
(paren
id|AX_SYS
comma
id|AX_CMD
)paren
suffix:semicolon
id|outw
c_func
(paren
id|lp-&gt;tx_pkt_start
comma
id|GP_LOW
)paren
suffix:semicolon
id|outb
c_func
(paren
id|AX_XMIT
comma
id|AX_CMD
)paren
suffix:semicolon
id|lp-&gt;stats.collisions
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;It worked.. we will now fall through and receive&n;&t;&t;&t; */
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|el_debug
OG
l_int|6
)paren
id|printk
c_func
(paren
l_string|&quot; Tx succeeded %s&bslash;n&quot;
comma
(paren
id|txsr
op_amp
id|TX_RDY
)paren
ques
c_cond
l_string|&quot;.&quot;
suffix:colon
l_string|&quot;but tx is busy!&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;This is safe the interrupt is atomic WRT itself.&n;&t;&t;&t; */
id|lp-&gt;txing
op_assign
l_int|0
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* In case more to transmit */
)brace
)brace
r_else
(brace
multiline_comment|/*&n;    &t;&t; *&t;In receive mode.&n;    &t;&t; */
r_int
id|rxsr
op_assign
id|inb
c_func
(paren
id|RX_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|el_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot; rxsr=%02x txsr=%02x rp=%04x&quot;
comma
id|rxsr
comma
id|inb
c_func
(paren
id|TX_STATUS
)paren
comma
id|inw
c_func
(paren
id|RX_LOW
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Just reading rx_status fixes most errors.&n;&t;&t; */
r_if
c_cond
(paren
id|rxsr
op_amp
id|RX_MISSED
)paren
id|lp-&gt;stats.rx_missed_errors
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rxsr
op_amp
id|RX_RUNT
)paren
(brace
multiline_comment|/* Handled to avoid board lock-up. */
id|lp-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|el_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot; runt.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rxsr
op_amp
id|RX_GOOD
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Receive worked.&n;&t;&t;&t; */
id|el_receive
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Nothing?  Something is broken!&n;&t;&t;&t; */
r_if
c_cond
(paren
id|el_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;%s: No packet seen, rxsr=%02x **resetting 3c501***&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rxsr
)paren
suffix:semicolon
id|el_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|el_debug
OG
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Move into receive mode&n;&t; */
id|outb
c_func
(paren
id|AX_RX
comma
id|AX_CMD
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0x00
comma
id|RX_BUF_CLR
)paren
suffix:semicolon
id|inb
c_func
(paren
id|RX_STATUS
)paren
suffix:semicolon
multiline_comment|/* Be certain that interrupts are cleared. */
id|inb
c_func
(paren
id|TX_STATUS
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lp-&gt;lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * el_receive:&n; * @dev: Device to pull the packets from&n; *&n; * We have a good packet. Well, not really &quot;good&quot;, just mostly not broken.&n; * We must check everything to see if it is good. In paticular we occasionally&n; * get wild packet sizes from the card. If the packet seems sane we PIO it&n; * off the card and queue it for the protocol layers.&n; */
DECL|function|el_receive
r_static
r_void
id|el_receive
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
id|pkt_len
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|pkt_len
op_assign
id|inw
c_func
(paren
id|RX_LOW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|el_debug
OG
l_int|4
)paren
id|printk
c_func
(paren
l_string|&quot; el_receive %d.&bslash;n&quot;
comma
id|pkt_len
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pkt_len
OL
l_int|60
)paren
op_logical_or
(paren
id|pkt_len
OG
l_int|1536
)paren
)paren
(brace
r_if
c_cond
(paren
id|el_debug
)paren
id|printk
c_func
(paren
l_string|&quot;%s: bogus packet, length=%d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|pkt_len
)paren
suffix:semicolon
id|lp-&gt;stats.rx_over_errors
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Command mode so we can empty the buffer&n;&t; */
id|outb
c_func
(paren
id|AX_SYS
comma
id|AX_CMD
)paren
suffix:semicolon
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|pkt_len
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Start of frame&n;&t; */
id|outw
c_func
(paren
l_int|0x00
comma
id|GP_LOW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Force 16 byte alignment */
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;The read increments through the bytes. The interrupt&n;&t;&t; *&t;handler will fix the pointer when it returns to&n;&t;&t; *&t;receive mode.&n;&t;&t; */
id|insb
c_func
(paren
id|DATAPORT
comma
id|skb_put
c_func
(paren
id|skb
comma
id|pkt_len
)paren
comma
id|pkt_len
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|eth_type_trans
c_func
(paren
id|skb
comma
id|dev
)paren
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.rx_bytes
op_add_assign
id|pkt_len
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/**&n; * el_reset: Reset a 3c501 card&n; * @dev: The 3c501 card about to get zapped&n; *&n; * Even resetting a 3c501 isnt simple. When you activate reset it loses all&n; * its configuration. You must hold the lock when doing this. The function&n; * cannot take the lock itself as it is callable from the irq handler.&n; */
DECL|function|el_reset
r_static
r_void
id|el_reset
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|el_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;3c501 reset...&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
id|AX_RESET
comma
id|AX_CMD
)paren
suffix:semicolon
multiline_comment|/* Reset the chip */
id|outb
c_func
(paren
id|AX_LOOP
comma
id|AX_CMD
)paren
suffix:semicolon
multiline_comment|/* Aux control, irq and loopback enabled */
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* Set the station address. */
id|outb
c_func
(paren
id|dev-&gt;dev_addr
(braket
id|i
)braket
comma
id|ioaddr
op_plus
id|i
)paren
suffix:semicolon
)brace
id|outw
c_func
(paren
l_int|0
comma
id|RX_BUF_CLR
)paren
suffix:semicolon
multiline_comment|/* Set rx packet area to 0. */
id|outb
c_func
(paren
id|TX_NORM
comma
id|TX_CMD
)paren
suffix:semicolon
multiline_comment|/* tx irq on done, collision */
id|outb
c_func
(paren
id|RX_NORM
comma
id|RX_CMD
)paren
suffix:semicolon
multiline_comment|/* Set Rx commands. */
id|inb
c_func
(paren
id|RX_STATUS
)paren
suffix:semicolon
multiline_comment|/* Clear status. */
id|inb
c_func
(paren
id|TX_STATUS
)paren
suffix:semicolon
id|lp-&gt;txing
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * el1_close:&n; * @dev: 3c501 card to shut down&n; *&n; * Close a 3c501 card. The IFF_UP flag has been cleared by the user via&n; * the SIOCSIFFLAGS ioctl. We stop any further transmissions being queued,&n; * and then disable the interrupts. Finally we reset the chip. The effects&n; * of the rest will be cleaned up by #el1_open. Always returns 0 indicating&n; * a success.&n; */
DECL|function|el1_close
r_static
r_int
id|el1_close
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|el_debug
OG
l_int|2
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Shutting down Ethernet card at %#x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ioaddr
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Free and disable the IRQ.&n;&t; */
id|free_irq
c_func
(paren
id|dev-&gt;irq
comma
id|dev
)paren
suffix:semicolon
id|outb
c_func
(paren
id|AX_RESET
comma
id|AX_CMD
)paren
suffix:semicolon
multiline_comment|/* Reset the chip */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * el1_get_stats:&n; * @dev: The card to get the statistics for&n; *&n; * In smarter devices this function is needed to pull statistics off the&n; * board itself. The 3c501 has no hardware statistics. We maintain them all&n; * so they are by definition always up to date.&n; *&n; * Returns the statistics for the card from the card private data&n; */
DECL|function|el1_get_stats
r_static
r_struct
id|net_device_stats
op_star
id|el1_get_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/**&n; * set_multicast_list:&n; * @dev: The device to adjust&n; *&n; * Set or clear the multicast filter for this adaptor to use the best-effort &n; * filtering supported. The 3c501 supports only three modes of filtering.&n; * It always receives broadcasts and packets for itself. You can choose to&n; * optionally receive all packets, or all multicast packets on top of this.&n; */
DECL|function|set_multicast_list
r_static
r_void
id|set_multicast_list
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_PROMISC
)paren
(brace
id|outb
c_func
(paren
id|RX_PROM
comma
id|RX_CMD
)paren
suffix:semicolon
id|inb
c_func
(paren
id|RX_STATUS
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dev-&gt;mc_list
op_logical_or
id|dev-&gt;flags
op_amp
id|IFF_ALLMULTI
)paren
(brace
id|outb
c_func
(paren
id|RX_MULT
comma
id|RX_CMD
)paren
suffix:semicolon
multiline_comment|/* Multicast or all multicast is the same */
id|inb
c_func
(paren
id|RX_STATUS
)paren
suffix:semicolon
multiline_comment|/* Clear status. */
)brace
r_else
(brace
id|outb
c_func
(paren
id|RX_NORM
comma
id|RX_CMD
)paren
suffix:semicolon
id|inb
c_func
(paren
id|RX_STATUS
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef MODULE
DECL|variable|dev_3c501
r_static
r_struct
id|net_device
id|dev_3c501
op_assign
(brace
id|init
suffix:colon
id|el1_probe
comma
id|base_addr
suffix:colon
l_int|0x280
comma
id|irq
suffix:colon
l_int|5
comma
)brace
suffix:semicolon
DECL|variable|io
r_static
r_int
id|io
op_assign
l_int|0x280
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
op_assign
l_int|5
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
multiline_comment|/**&n; * init_module:&n; *&n; * When the driver is loaded as a module this function is called. We fake up&n; * a device structure with the base I/O and interrupt set as if it was being&n; * called from Space.c. This minimises the extra code that would otherwise&n; * be required.&n; *&n; * Returns 0 for success or -EIO if a card is not found. Returning an error&n; * here also causes the module to be unloaded&n; */
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
id|dev_3c501.irq
op_assign
id|irq
suffix:semicolon
id|dev_3c501.base_addr
op_assign
id|io
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
op_amp
id|dev_3c501
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * cleanup_module:&n; * &n; * The module is being unloaded. We unhook our network device from the system&n; * and then free up the resources we took when the card was found.&n; */
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; *&t;No need to check MOD_IN_USE, as sys_delete_module() checks.&n;&t; */
id|unregister_netdev
c_func
(paren
op_amp
id|dev_3c501
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Free up the private structure, or leak memory :-)&n;&t; */
id|kfree
c_func
(paren
id|dev_3c501.priv
)paren
suffix:semicolon
id|dev_3c501.priv
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* gets re-allocated by el1_probe1 */
multiline_comment|/*&n;&t; *&t;If we don&squot;t do this, we can&squot;t re-insmod it later.&n;&t; */
id|release_region
c_func
(paren
id|dev_3c501.base_addr
comma
id|EL1_IO_EXTENT
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -D__KERNEL__ -Wall -Wstrict-prototypes -O6 -fomit-frame-pointer  -m486 -c -o 3c501.o 3c501.c&quot;&n; *  kept-new-versions: 5&n; * End:&n; */
eof
