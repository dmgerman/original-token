multiline_comment|/* 3c507.c: An EtherLink16 device driver for Linux. */
multiline_comment|/*&n;&t;Written 1993 by Donald Becker.&n;&t;Copyright 1993 United States Government as represented by the Director,&n;&t;National Security Agency.  This software may only be used and distributed&n;&t;according to the terms of the GNU Public License as modified by SRC,&n;&t;incorported herein by reference.&n;&n;&t;The author may be reached as becker@super.org or&n;&t;C/O Supercomputing Research Ctr., 17100 Science Dr., Bowie MD 20715&n;&n;&t;Thanks go to jennings@Montrouge.SMR.slb.com ( Patrick Jennings)&n;&t;and jrs@world.std.com (Rick Sladkey) for testing and bugfixes.&n;&n;&t;Things remaining to do:&n;&t;Verify that the tx and rx buffers don&squot;t have fencepost errors.&n;&t;Move the theory of operation and memory map documentation.&n;&t;The statistics need to be updated correctly.&n;*/
DECL|variable|version
r_static
r_char
op_star
id|version
op_assign
l_string|&quot;3c507.c:v0.03 10/27/93 Donald Becker (becker@super.org)&bslash;n&quot;
suffix:semicolon
macro_line|#include &lt;linux/config.h&gt;
multiline_comment|/*&n;  Sources:&n;&t;This driver wouldn&squot;t have been written with the availability of the&n;&t;Crynwr driver source code.&t;It provided a known-working implementation&n;&t;that filled in the gaping holes of the Intel documention.  Three cheers&n;&t;for Russ Nelson.&n;&n;&t;Intel Microcommunications Databook, Vol. 1, 1990. It provides just enough&n;&t;info that the casual reader might think that it documents the i82586.&n;*/
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;memory.h&gt;
macro_line|#include &quot;dev.h&quot;
macro_line|#include &quot;eth.h&quot;
macro_line|#include &quot;skbuff.h&quot;
macro_line|#include &quot;arp.h&quot;
macro_line|#ifndef HAVE_ALLOC_SKB
DECL|macro|alloc_skb
mdefine_line|#define alloc_skb(size, priority) (struct sk_buff *) kmalloc(size,priority)
DECL|macro|kfree_skbmem
mdefine_line|#define kfree_skbmem(addr, size) kfree_s(addr,size);
macro_line|#else
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#endif
multiline_comment|/* use 0 for production, 1 for verification, 2..7 for debug */
macro_line|#ifndef NET_DEBUG
DECL|macro|NET_DEBUG
mdefine_line|#define NET_DEBUG 1
macro_line|#endif
DECL|variable|net_debug
r_static
r_int
r_int
id|net_debug
op_assign
id|NET_DEBUG
suffix:semicolon
multiline_comment|/*&n;  &t;&t;&t;Details of the i82586.&n;&n;   You&squot;ll really need the databook to understand the details of this part,&n;   but the outline is that the i82586 has two seperate processing units.&n;   Both are started from a list of three configuration tables, of which only&n;   the last, the System Control Block (SCB), is used after reset-time.  The SCB&n;   has the following fileds:&n;&t;&t;Status word&n;&t;&t;Command word&n;&t;&t;Tx/Command block addr.&n;&t;&t;Rx block addr.&n;   The command word accepts the following controls for the Tx and Rx units:&n;  */
DECL|macro|CUC_START
mdefine_line|#define&t; CUC_START&t; 0x0100
DECL|macro|CUC_RESUME
mdefine_line|#define&t; CUC_RESUME&t; 0x0200
DECL|macro|CUC_SUSPEND
mdefine_line|#define&t; CUC_SUSPEND 0x0300
DECL|macro|RX_START
mdefine_line|#define&t; RX_START&t; 0x0010
DECL|macro|RX_RESUME
mdefine_line|#define&t; RX_RESUME&t; 0x0020
DECL|macro|RX_SUSPEND
mdefine_line|#define&t; RX_SUSPEND&t; 0x0030
multiline_comment|/* The Rx unit uses a list of frame descriptors and a list of data buffer&n;   descriptors.  We use full-sized (1518 byte) data buffers, so there is&n;   a one-to-one pairing of frame descriptors to buffer descriptors.&n;&n;   The Tx (&quot;command&quot;) unit executes a list of commands that look like:&n;&t;&t;Status word&t;&t;Written by the 82586 when the command is done.&n;&t;&t;Command word&t;Command in lower 3 bits, post-command action in upper 3&n;&t;&t;Link word&t;&t;The address of the next command.&n;&t;&t;Parameters&t;&t;(as needed).&n;&n;&t;Some definitions related to the Command Word are:&n; */
DECL|macro|CMD_EOL
mdefine_line|#define CMD_EOL&t;&t;0x8000&t;&t;&t;/* The last command of the list, stop. */
DECL|macro|CMD_SUSP
mdefine_line|#define CMD_SUSP&t;0x4000&t;&t;&t;/* Suspend after doing cmd. */
DECL|macro|CMD_INTR
mdefine_line|#define CMD_INTR&t;0x2000&t;&t;&t;/* Interrupt after doing cmd. */
DECL|enum|commands
r_enum
id|commands
(brace
DECL|enumerator|CmdNOp
DECL|enumerator|CmdSASetup
DECL|enumerator|CmdConfigure
DECL|enumerator|CmdMulticastList
id|CmdNOp
op_assign
l_int|0
comma
id|CmdSASetup
op_assign
l_int|1
comma
id|CmdConfigure
op_assign
l_int|2
comma
id|CmdMulticastList
op_assign
l_int|3
comma
DECL|enumerator|CmdTx
DECL|enumerator|CmdTDR
DECL|enumerator|CmdDump
DECL|enumerator|CmdDiagnose
id|CmdTx
op_assign
l_int|4
comma
id|CmdTDR
op_assign
l_int|5
comma
id|CmdDump
op_assign
l_int|6
comma
id|CmdDiagnose
op_assign
l_int|7
)brace
suffix:semicolon
multiline_comment|/* Information that need to be kept for each board. */
DECL|struct|net_local
r_struct
id|net_local
(brace
DECL|member|stats
r_struct
id|enet_statistics
id|stats
suffix:semicolon
DECL|member|last_restart
r_int
id|last_restart
suffix:semicolon
DECL|member|rx_head
id|ushort
id|rx_head
suffix:semicolon
DECL|member|rx_tail
id|ushort
id|rx_tail
suffix:semicolon
DECL|member|tx_head
id|ushort
id|tx_head
suffix:semicolon
DECL|member|tx_cmd_link
id|ushort
id|tx_cmd_link
suffix:semicolon
DECL|member|tx_reap
id|ushort
id|tx_reap
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;  &t;&t;Details of the EtherLink16 Implementation&n;  The 3c507 is a generic shared-memory i82586 implementation.&n;  The host can map 16K, 32K, 48K, or 64K of the 64K memory into&n;  0x0[CD][08]0000, or all 64K into 0xF[02468]0000.&n;  */
multiline_comment|/* Offsets from the base I/O address. */
DECL|macro|SA_DATA
mdefine_line|#define&t;SA_DATA&t;&t;0&t;/* Station address data, or 3Com signature. */
DECL|macro|MISC_CTRL
mdefine_line|#define MISC_CTRL&t;6&t;/* Switch the SA_DATA banks, and bus config bits. */
DECL|macro|RESET_IRQ
mdefine_line|#define RESET_IRQ&t;10&t;/* Reset the latched IRQ line. */
DECL|macro|SIGNAL_CA
mdefine_line|#define SIGNAL_CA&t;11&t;/* Frob the 82586 Channel Attention line. */
DECL|macro|ROM_CONFIG
mdefine_line|#define ROM_CONFIG&t;13
DECL|macro|MEM_CONFIG
mdefine_line|#define MEM_CONFIG&t;14
DECL|macro|IRQ_CONFIG
mdefine_line|#define IRQ_CONFIG&t;15
multiline_comment|/* The ID port is used at boot-time to locate the ethercard. */
DECL|macro|ID_PORT
mdefine_line|#define ID_PORT&t;&t;0x100
multiline_comment|/* Offsets to registers in the mailbox (SCB). */
DECL|macro|iSCB_STATUS
mdefine_line|#define iSCB_STATUS&t;0x8
DECL|macro|iSCB_CMD
mdefine_line|#define iSCB_CMD&t;&t;0xA
DECL|macro|iSCB_CBL
mdefine_line|#define iSCB_CBL&t;&t;0xC&t;/* Command BLock offset. */
DECL|macro|iSCB_RFA
mdefine_line|#define iSCB_RFA&t;&t;0xE&t;/* Rx Frame Area offset. */
multiline_comment|/*&n;  What follows in &squot;init_words[]&squot; is the &quot;program&quot; that is downloaded to the&n;  82586 memory.&t; It&squot;s mostly tables and command blocks, and starts at the&n;  reset address 0xfffff6.  This is designed to be similar to the EtherExpress,&n;  thus the unusual location of the SCB at 0x0008.&n;&n;  Even with the additional &quot;don&squot;t care&quot; values, doing it this way takes less&n;  program space than initializing the individual tables, and I feel it&squot;s much&n;  cleaner.&n;&n;  The databook is particularly useless for the first two structures, I had&n;  to use the Crynwr driver as an example.&n;&n;   The memory setup is as follows:&n;   */
DECL|macro|CONFIG_CMD
mdefine_line|#define CONFIG_CMD&t;0x0018
DECL|macro|SET_SA_CMD
mdefine_line|#define SET_SA_CMD&t;0x0024
DECL|macro|SA_OFFSET
mdefine_line|#define SA_OFFSET&t;0x002A
DECL|macro|IDLELOOP
mdefine_line|#define IDLELOOP&t;0x30
DECL|macro|TDR_CMD
mdefine_line|#define TDR_CMD&t;&t;0x38
DECL|macro|TDR_TIME
mdefine_line|#define TDR_TIME&t;0x3C
DECL|macro|DUMP_CMD
mdefine_line|#define DUMP_CMD&t;0x40
DECL|macro|DIAG_CMD
mdefine_line|#define DIAG_CMD&t;0x48
DECL|macro|SET_MC_CMD
mdefine_line|#define SET_MC_CMD&t;0x4E
DECL|macro|DUMP_DATA
mdefine_line|#define DUMP_DATA&t;0x56&t;/* A 170 byte buffer for dump and Set-MC into. */
DECL|macro|TX_BUF_START
mdefine_line|#define TX_BUF_START&t;0x0100
DECL|macro|NUM_TX_BUFS
mdefine_line|#define NUM_TX_BUFS &t;4
DECL|macro|TX_BUF_SIZE
mdefine_line|#define TX_BUF_SIZE &t;(1518+14+20+16) /* packet+header+TBD */
DECL|macro|RX_BUF_START
mdefine_line|#define RX_BUF_START&t;0x2000
DECL|macro|RX_BUF_SIZE
mdefine_line|#define RX_BUF_SIZE &t;(1518+14+18)&t;/* packet+header+RBD */
DECL|macro|RX_BUF_END
mdefine_line|#define RX_BUF_END&t;&t;(dev-&gt;mem_end - dev-&gt;mem_start)
multiline_comment|/*&n;  That&squot;s it: only 86 bytes to set up the beast, including every extra&n;  command available.  The 170 byte buffer at DUMP_DATA is shared between the&n;  Dump command (called only by the diagnostic program) and the SetMulticastList&n;  command. &n;&n;  To complete the memory setup you only have to write the station address at&n;  SA_OFFSET and create the Tx &amp; Rx buffer lists.&n;&n;  The Tx command chain and buffer list is setup as follows:&n;  A Tx command table, with the data buffer pointing to...&n;  A Tx data buffer descriptor.  The packet is in a single buffer, rather than&n;     chaining together several smaller buffers.&n;  A NoOp command, which initially points to itself,&n;  And the packet data.&n;&n;  A transmit is done by filling in the Tx command table and data buffer,&n;  re-writing the NoOp command, and finally changing the offset of the last&n;  command to point to the current Tx command.  When the Tx command is finished,&n;  it jumps to the NoOp, when it loops until the next Tx command changes the&n;  &quot;link offset&quot; in the NoOp.  This way the 82586 never has to go through the&n;  slow restart sequence.&n;&n;  The Rx buffer list is set up in the obvious ring structure.  We have enough&n;  memory (and low enough interrupt latency) that we can avoid the complicated&n;  Rx buffer linked lists by alway associating a full-size Rx data buffer with&n;  each Rx data frame.&n;&n;  I current use four transmit buffers starting at TX_BUF_START (0x0100), and&n;  use the rest of memory, from RX_BUF_START to RX_BUF_END, for Rx buffers.&n;&n;  */
DECL|variable|init_words
r_int
id|init_words
(braket
)braket
op_assign
(brace
l_int|0x0000
comma
multiline_comment|/* Set bus size to 16 bits. */
l_int|0x0000
comma
l_int|0x0000
comma
multiline_comment|/* Set control mailbox (SCB) addr. */
l_int|0
comma
l_int|0
comma
multiline_comment|/* pad to 0x000000. */
l_int|0x0001
comma
multiline_comment|/* Status word that&squot;s cleared when init is done. */
l_int|0x0008
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* SCB offset, (skip, skip) */
l_int|0
comma
l_int|0xf000
op_or
id|RX_START
op_or
id|CUC_START
comma
multiline_comment|/* SCB status and cmd. */
id|CONFIG_CMD
comma
multiline_comment|/* Command list pointer, points to Configure. */
id|RX_BUF_START
comma
multiline_comment|/* Rx block list. */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* Error count: CRC, align, buffer, overrun. */
multiline_comment|/* 0x0018: Configure command.  Change to put MAC data with packet. */
l_int|0
comma
id|CmdConfigure
comma
multiline_comment|/* Status, command.&t;&t;*/
id|SET_SA_CMD
comma
multiline_comment|/* Next command is Set Station Addr. */
l_int|0x0804
comma
multiline_comment|/* &quot;4&quot; bytes of config data, 8 byte FIFO. */
l_int|0x2e40
comma
multiline_comment|/* Magic values, including MAC data location. */
l_int|0
comma
multiline_comment|/* Unused pad word. */
multiline_comment|/* 0x0024: Setup station address command. */
l_int|0
comma
id|CmdSASetup
comma
id|SET_MC_CMD
comma
multiline_comment|/* Next command. */
l_int|0xaa00
comma
l_int|0xb000
comma
l_int|0x0bad
comma
multiline_comment|/* Station address (to be filled in) */
multiline_comment|/* 0x0030: NOP, looping back to itself.&t; Point to first Tx buffer to Tx. */
l_int|0
comma
id|CmdNOp
comma
id|IDLELOOP
comma
l_int|0
multiline_comment|/* pad */
comma
multiline_comment|/* 0x0038: A unused Time-Domain Reflectometer command. */
l_int|0
comma
id|CmdTDR
comma
id|IDLELOOP
comma
l_int|0
comma
multiline_comment|/* 0x0040: An unused Dump State command. */
l_int|0
comma
id|CmdDump
comma
id|IDLELOOP
comma
id|DUMP_DATA
comma
multiline_comment|/* 0x0048: An unused Diagnose command. */
l_int|0
comma
id|CmdDiagnose
comma
id|IDLELOOP
comma
multiline_comment|/* 0x004E: An empty set-multicast-list command. */
l_int|0
comma
id|CmdMulticastList
comma
id|IDLELOOP
comma
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* Index to functions, as function prototypes. */
r_extern
r_int
id|el16_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* Called from Space.c */
r_static
r_int
id|el16_probe1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
suffix:semicolon
r_static
r_int
id|el16_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|el16_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|el16_interrupt
c_func
(paren
r_int
id|reg_ptr
)paren
suffix:semicolon
r_static
r_void
id|el16_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_int
id|el16_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_struct
id|enet_statistics
op_star
id|el16_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_static
r_void
id|hardware_send_packet
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|buf
comma
r_int
id|length
)paren
suffix:semicolon
r_void
id|init_82586_mem
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
"&f;"
multiline_comment|/* Check for a network adaptor of this type, and return &squot;0&squot; iff one exists.&n;   If dev-&gt;base_addr == 0, probe all likely locations.&n;   If dev-&gt;base_addr == 1, always return failure.&n;   If dev-&gt;base_addr == 2, (detachable devices only) alloate space for the&n;   device and return success.&n;   */
r_int
DECL|function|el16_probe
id|el16_probe
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
multiline_comment|/* Don&squot;t probe all settable addresses, 0x[23][0-F]0, just common ones. */
r_int
op_star
id|port
comma
id|ports
(braket
)braket
op_assign
(brace
l_int|0x300
comma
l_int|0x320
comma
l_int|0x340
comma
l_int|0x280
comma
l_int|0
)brace
suffix:semicolon
r_int
id|base_addr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|ushort
id|lrs_state
op_assign
l_int|0xff
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
OG
l_int|0x1ff
)paren
multiline_comment|/* Check a single specified location. */
r_return
id|el16_probe1
c_func
(paren
id|dev
comma
id|base_addr
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|base_addr
OG
l_int|0
)paren
r_return
id|ENXIO
suffix:semicolon
multiline_comment|/* Don&squot;t probe at all. */
multiline_comment|/* Send the ID sequence to the ID_PORT to enable the board. */
id|outb
c_func
(paren
l_int|0x00
comma
id|ID_PORT
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|255
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
id|lrs_state
comma
id|ID_PORT
)paren
suffix:semicolon
id|lrs_state
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lrs_state
op_amp
l_int|0x100
)paren
id|lrs_state
op_xor_assign
l_int|0xe7
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0x00
comma
id|ID_PORT
)paren
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
op_amp
id|ports
(braket
l_int|0
)braket
suffix:semicolon
op_star
id|port
suffix:semicolon
id|port
op_increment
)paren
(brace
r_int
id|ioaddr
op_assign
op_star
id|port
suffix:semicolon
macro_line|#if 0
multiline_comment|/* This is my original code. */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|ioaddr
)paren
op_eq
l_char|&squot;*&squot;
op_logical_and
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|1
)paren
op_eq
l_char|&squot;3&squot;
op_logical_and
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|2
)paren
op_eq
l_char|&squot;C&squot;
op_logical_and
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|3
)paren
op_eq
l_char|&squot;O&squot;
op_logical_and
id|el16_probe1
c_func
(paren
id|dev
comma
op_star
id|port
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#else
multiline_comment|/* This is code from jennings@Montrouge.SMR.slb.com, done so that&n;&t;   the string can be printed out. */
r_char
id|res
(braket
l_int|5
)braket
suffix:semicolon
id|res
(braket
l_int|0
)braket
op_assign
id|inb
c_func
(paren
id|ioaddr
)paren
suffix:semicolon
id|res
(braket
l_int|1
)braket
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|1
)paren
suffix:semicolon
id|res
(braket
l_int|2
)braket
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|2
)paren
suffix:semicolon
id|res
(braket
l_int|3
)braket
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
l_int|3
)paren
suffix:semicolon
id|res
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|res
(braket
l_int|0
)braket
op_eq
l_char|&squot;*&squot;
op_logical_and
id|res
(braket
l_int|1
)braket
op_eq
l_char|&squot;3&squot;
op_logical_and
id|res
(braket
l_int|2
)braket
op_eq
l_char|&squot;C&squot;
op_logical_and
id|res
(braket
l_int|3
)braket
op_eq
l_char|&squot;O&squot;
op_logical_and
id|el16_probe1
c_func
(paren
id|dev
comma
op_star
id|port
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
r_return
id|ENODEV
suffix:semicolon
multiline_comment|/* ENODEV would be more accurate. */
)brace
DECL|function|el16_probe1
r_int
id|el16_probe1
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_int
id|ioaddr
)paren
(brace
r_int
id|i
comma
id|irq
comma
id|irqval
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: 3c507 at %#x,&quot;
comma
id|dev-&gt;name
comma
id|ioaddr
)paren
suffix:semicolon
multiline_comment|/* We should make a few more checks here, like the first three octets of&n;&t;   the S.A. for the manufactor&squot;s code. */
id|irq
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|IRQ_CONFIG
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|irqval
op_assign
id|request_irq
c_func
(paren
id|irq
comma
op_amp
id|el16_interrupt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irqval
)paren
(brace
id|printk
(paren
l_string|&quot;unable to get IRQ %d (irqval=%d).&bslash;n&quot;
comma
id|irq
comma
id|irqval
)paren
suffix:semicolon
r_return
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/* We&squot;ve committed to using the board, and can start filling in *dev. */
id|snarf_region
c_func
(paren
id|ioaddr
comma
l_int|16
)paren
suffix:semicolon
id|dev-&gt;base_addr
op_assign
id|ioaddr
suffix:semicolon
id|outb
c_func
(paren
l_int|0x01
comma
id|ioaddr
op_plus
id|MISC_CTRL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;dev_addr
(braket
id|i
)braket
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
id|dev-&gt;dev_addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|dev-&gt;mem_start
op_amp
l_int|0xf
)paren
OG
l_int|0
)paren
id|net_debug
op_assign
id|dev-&gt;mem_start
op_amp
l_int|7
suffix:semicolon
macro_line|#ifdef MEM_BASE
id|dev-&gt;mem_start
op_assign
id|MEM_BASE
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|dev-&gt;mem_start
op_plus
l_int|0x10000
suffix:semicolon
macro_line|#else
(brace
r_int
id|base
suffix:semicolon
r_int
id|size
suffix:semicolon
r_char
id|mem_config
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|MEM_CONFIG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mem_config
op_amp
l_int|0x20
)paren
(brace
id|size
op_assign
l_int|64
op_star
l_int|1024
suffix:semicolon
id|base
op_assign
l_int|0xf00000
op_plus
(paren
id|mem_config
op_amp
l_int|0x08
ques
c_cond
l_int|0x080000
suffix:colon
(paren
(paren
id|mem_config
op_amp
l_int|3
)paren
op_lshift
l_int|17
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|size
op_assign
(paren
(paren
id|mem_config
op_amp
l_int|3
)paren
op_plus
l_int|1
)paren
op_lshift
l_int|14
suffix:semicolon
id|base
op_assign
l_int|0x0c0000
op_plus
(paren
(paren
id|mem_config
op_amp
l_int|0x18
)paren
op_lshift
l_int|12
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
op_ne
l_int|0x10000
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Warning, this version probably only works with 64K of&quot;
l_string|&quot;shared memory.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|dev-&gt;mem_start
op_assign
id|base
suffix:semicolon
id|dev-&gt;mem_end
op_assign
id|base
op_plus
id|size
suffix:semicolon
)brace
macro_line|#endif
id|dev-&gt;if_port
op_assign
(paren
id|inb
c_func
(paren
id|ioaddr
op_plus
id|ROM_CONFIG
)paren
op_amp
l_int|0x80
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|dev-&gt;irq
op_assign
id|inb
c_func
(paren
id|ioaddr
op_plus
id|IRQ_CONFIG
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, IRQ %d, %sternal xcvr, memory %#x-%#x.&bslash;n&quot;
comma
id|dev-&gt;irq
comma
id|dev-&gt;if_port
ques
c_cond
l_string|&quot;ex&quot;
suffix:colon
l_string|&quot;in&quot;
comma
id|dev-&gt;mem_start
comma
id|dev-&gt;mem_end
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
)paren
id|printk
c_func
(paren
id|version
)paren
suffix:semicolon
multiline_comment|/* Initialize the device structure. */
id|dev-&gt;priv
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|net_local
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dev-&gt;priv
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|net_local
)paren
)paren
suffix:semicolon
id|dev-&gt;open
op_assign
id|el16_open
suffix:semicolon
id|dev-&gt;stop
op_assign
id|el16_close
suffix:semicolon
id|dev-&gt;hard_start_xmit
op_assign
id|el16_send_packet
suffix:semicolon
id|dev-&gt;get_stats
op_assign
id|el16_get_stats
suffix:semicolon
multiline_comment|/* Fill in the fields of the device structure with ethernet-generic values.&n;&t;   This should be in a common file instead of per-driver.  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEV_NUMBUFFS
suffix:semicolon
id|i
op_increment
)paren
id|dev-&gt;buffs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;hard_header
op_assign
id|eth_header
suffix:semicolon
id|dev-&gt;add_arp
op_assign
id|eth_add_arp
suffix:semicolon
id|dev-&gt;queue_xmit
op_assign
id|dev_queue_xmit
suffix:semicolon
id|dev-&gt;rebuild_header
op_assign
id|eth_rebuild_header
suffix:semicolon
id|dev-&gt;type_trans
op_assign
id|eth_type_trans
suffix:semicolon
id|dev-&gt;type
op_assign
id|ARPHRD_ETHER
suffix:semicolon
id|dev-&gt;hard_header_len
op_assign
id|ETH_HLEN
suffix:semicolon
id|dev-&gt;mtu
op_assign
l_int|1500
suffix:semicolon
multiline_comment|/* eth_mtu */
id|dev-&gt;addr_len
op_assign
id|ETH_ALEN
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ETH_ALEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;broadcast
(braket
id|i
)braket
op_assign
l_int|0xff
suffix:semicolon
)brace
multiline_comment|/* New-style flags. */
id|dev-&gt;flags
op_assign
id|IFF_BROADCAST
suffix:semicolon
id|dev-&gt;family
op_assign
id|AF_INET
suffix:semicolon
id|dev-&gt;pa_addr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_brdaddr
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_mask
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;pa_alen
op_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
r_static
r_int
DECL|function|el16_open
id|el16_open
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
id|dev
suffix:semicolon
multiline_comment|/* Initialize the 82586 memory and start it. */
id|init_82586_mem
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;interrupt
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|el16_send_packet
id|el16_send_packet
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
r_int
op_star
id|shmem
op_assign
(paren
r_int
op_star
)paren
id|dev-&gt;mem_start
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;tbusy
)paren
(brace
multiline_comment|/* If we get here, some higher level has decided we are broken.&n;&t;&t;   There should really be a &quot;kick me&quot; function call instead. */
r_int
id|tickssofar
op_assign
id|jiffies
op_minus
id|dev-&gt;trans_start
suffix:semicolon
r_if
c_cond
(paren
id|tickssofar
OL
l_int|5
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: transmit timed out, %s?  &quot;
comma
id|dev-&gt;name
comma
id|shmem
(braket
id|iSCB_STATUS
op_rshift
l_int|1
)braket
op_amp
l_int|0x8000
ques
c_cond
l_string|&quot;IRQ conflict&quot;
suffix:colon
l_string|&quot;network cable problem&quot;
)paren
suffix:semicolon
multiline_comment|/* Try to restart the adaptor. */
r_if
c_cond
(paren
id|lp-&gt;last_restart
op_eq
id|lp-&gt;stats.tx_packets
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;Resetting board.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Completely reset the adaptor. */
id|init_82586_mem
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Issue the channel attention signal and hope it &quot;gets better&quot;. */
r_if
c_cond
(paren
id|net_debug
OG
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;Kicking board.&bslash;n&quot;
)paren
suffix:semicolon
id|shmem
(braket
id|iSCB_CMD
op_rshift
l_int|1
)braket
op_assign
l_int|0xf000
op_or
id|CUC_START
op_or
id|RX_START
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
multiline_comment|/* Issue channel-attn. */
id|lp-&gt;last_restart
op_assign
id|lp-&gt;stats.tx_packets
suffix:semicolon
)brace
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
)brace
multiline_comment|/* If some higher layer thinks we&squot;ve missed an tx-done interrupt&n;&t;   we are passed NULL. Caution: dev_tint() handles the cli()/sti()&n;&t;   itself. */
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|dev_tint
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* For ethernet, fill in the header.  This should really be done by a&n;&t;   higher level, rather than duplicated for each ethernet adaptor. */
r_if
c_cond
(paren
op_logical_neg
id|skb-&gt;arp
op_logical_and
id|dev
op_member_access_from_pointer
id|rebuild_header
c_func
(paren
id|skb-&gt;data
comma
id|dev
)paren
)paren
(brace
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
id|arp_queue
(paren
id|skb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|skb-&gt;arp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Block a timer-based transmit from overlapping. */
r_if
c_cond
(paren
id|set_bit
c_func
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|dev-&gt;tbusy
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Transmitter access conflict.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_else
(brace
r_int
id|length
op_assign
id|ETH_ZLEN
OL
id|skb-&gt;len
ques
c_cond
id|skb-&gt;len
suffix:colon
id|ETH_ZLEN
suffix:semicolon
r_int
r_char
op_star
id|buf
op_assign
id|skb-&gt;data
suffix:semicolon
multiline_comment|/* Disable the 82586&squot;s input to the interrupt line. */
id|outb
c_func
(paren
l_int|0x80
comma
id|ioaddr
op_plus
id|MISC_CTRL
)paren
suffix:semicolon
id|hardware_send_packet
c_func
(paren
id|dev
comma
id|buf
comma
id|length
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Enable the 82586 interrupt input. */
id|outb
c_func
(paren
l_int|0x84
comma
id|ioaddr
op_plus
id|MISC_CTRL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|skb-&gt;free
)paren
id|kfree_skb
(paren
id|skb
comma
id|FREE_WRITE
)paren
suffix:semicolon
multiline_comment|/* You might need to clean up and record Tx statistics here. */
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&t;The typical workload of the driver:&n;&t;Handle the network interface interrupts. */
r_static
r_void
DECL|function|el16_interrupt
id|el16_interrupt
c_func
(paren
r_int
id|reg_ptr
)paren
(brace
r_int
id|irq
op_assign
op_minus
(paren
(paren
(paren
r_struct
id|pt_regs
op_star
)paren
id|reg_ptr
)paren
op_member_access_from_pointer
id|orig_eax
op_plus
l_int|2
)paren
suffix:semicolon
r_struct
id|device
op_star
id|dev
op_assign
(paren
r_struct
id|device
op_star
)paren
(paren
id|irq2dev_map
(braket
id|irq
)braket
)paren
suffix:semicolon
r_struct
id|net_local
op_star
id|lp
suffix:semicolon
r_int
id|ioaddr
comma
id|status
comma
id|boguscount
op_assign
l_int|0
suffix:semicolon
id|ushort
id|ack_cmd
op_assign
l_int|0
suffix:semicolon
id|ushort
op_star
id|shmem
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;net_interrupt(): irq %d for unknown device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev-&gt;interrupt
op_assign
l_int|1
suffix:semicolon
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
id|shmem
op_assign
(paren
(paren
id|ushort
op_star
)paren
id|dev-&gt;mem_start
)paren
suffix:semicolon
id|status
op_assign
id|shmem
(braket
id|iSCB_STATUS
op_rshift
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: 3c507 interrupt, status %4.4x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* Disable the 82586&squot;s input to the interrupt line. */
id|outb
c_func
(paren
l_int|0x80
comma
id|ioaddr
op_plus
id|MISC_CTRL
)paren
suffix:semicolon
multiline_comment|/* Reap the Tx packet buffers. */
r_while
c_loop
(paren
id|lp-&gt;tx_reap
op_ne
id|lp-&gt;tx_head
)paren
(brace
r_int
r_int
id|tx_status
op_assign
id|shmem
(braket
id|lp-&gt;tx_reap
op_rshift
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;Couldn&squot;t reap %#x.&bslash;n&quot;
comma
id|lp-&gt;tx_reap
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tx_status
op_amp
l_int|0x2000
)paren
(brace
id|lp-&gt;stats.tx_packets
op_increment
suffix:semicolon
id|lp-&gt;stats.collisions
op_add_assign
id|tx_status
op_amp
l_int|0xf
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|mark_bh
c_func
(paren
id|INET_BH
)paren
suffix:semicolon
multiline_comment|/* Inform upper layers. */
)brace
r_else
(brace
id|lp-&gt;stats.tx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
l_int|0x0600
)paren
id|lp-&gt;stats.tx_carrier_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
l_int|0x0100
)paren
id|lp-&gt;stats.tx_fifo_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tx_status
op_amp
l_int|0x0040
)paren
)paren
id|lp-&gt;stats.tx_heartbeat_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tx_status
op_amp
l_int|0x0020
)paren
id|lp-&gt;stats.tx_aborted_errors
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;Reaped %x, Tx status %04x.&bslash;n&quot;
comma
id|lp-&gt;tx_reap
comma
id|tx_status
)paren
suffix:semicolon
id|lp-&gt;tx_reap
op_add_assign
id|TX_BUF_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_reap
OG
id|RX_BUF_START
op_minus
id|TX_BUF_SIZE
)paren
id|lp-&gt;tx_reap
op_assign
id|TX_BUF_START
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|boguscount
OG
l_int|4
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
l_int|0x4000
)paren
(brace
multiline_comment|/* Packet received. */
r_if
c_cond
(paren
id|net_debug
OG
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;Received packet, rx_head %04x.&bslash;n&quot;
comma
id|lp-&gt;rx_head
)paren
suffix:semicolon
id|el16_rx
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Acknowledge the interrupt sources. */
id|ack_cmd
op_assign
id|status
op_amp
l_int|0xf000
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0x0700
)paren
op_ne
l_int|0x0200
op_logical_and
id|dev-&gt;start
)paren
(brace
r_if
c_cond
(paren
id|net_debug
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Command unit stopped, status %04x, restarting.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
)paren
suffix:semicolon
multiline_comment|/* If this ever occurs we should really re-write the idle loop, reset&n;&t;&t;   the Tx list, and do a complete restart of the command unit.&n;&t;&t;   For now we rely on the Tx timeout if the resume doesn&squot;t work. */
id|ack_cmd
op_or_assign
id|CUC_RESUME
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0x0070
)paren
op_ne
l_int|0x0040
op_logical_and
id|dev-&gt;start
)paren
(brace
r_static
r_void
id|init_rx_bufs
c_func
(paren
r_struct
id|device
op_star
)paren
suffix:semicolon
multiline_comment|/* The Rx unit is not ready, it must be hung.  Restart the receiver by&n;&t;&t;   initializing the rx buffers, and issuing an Rx start command. */
r_if
c_cond
(paren
id|net_debug
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Rx unit stopped, status %04x, restarting.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|status
)paren
suffix:semicolon
id|init_rx_bufs
c_func
(paren
id|dev
)paren
suffix:semicolon
id|shmem
(braket
id|iSCB_RFA
op_rshift
l_int|1
)braket
op_assign
id|RX_BUF_START
suffix:semicolon
id|ack_cmd
op_or_assign
id|RX_START
suffix:semicolon
)brace
id|shmem
(braket
id|iSCB_CMD
op_rshift
l_int|1
)braket
op_assign
id|ack_cmd
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
multiline_comment|/* Issue channel-attn. */
multiline_comment|/* Clear the latched interrupt. */
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|RESET_IRQ
)paren
suffix:semicolon
multiline_comment|/* Enable the 82586&squot;s interrupt input. */
id|outb
c_func
(paren
l_int|0x84
comma
id|ioaddr
op_plus
id|MISC_CTRL
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_int
DECL|function|el16_close
id|el16_close
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|ushort
op_star
id|shmem
op_assign
(paren
r_int
op_star
)paren
id|dev-&gt;mem_start
suffix:semicolon
id|dev-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Flush the Tx and disable Rx. */
id|shmem
(braket
id|iSCB_CMD
op_rshift
l_int|1
)braket
op_assign
id|RX_SUSPEND
op_or
id|CUC_SUSPEND
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
multiline_comment|/* Disable the 82586&squot;s input to the interrupt line. */
id|outb
c_func
(paren
l_int|0x80
comma
id|ioaddr
op_plus
id|MISC_CTRL
)paren
suffix:semicolon
multiline_comment|/* We always physically use the IRQ line, so we don&squot;t do free_irq().&n;&t;   We do remove ourselves from the map. */
id|irq2dev_map
(braket
id|dev-&gt;irq
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Update the statistics here. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the current statistics.&t;This may be called with the card open or&n;   closed. */
r_static
r_struct
id|enet_statistics
op_star
DECL|function|el16_get_stats
id|el16_get_stats
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
multiline_comment|/* ToDo: decide if there are any useful statistics from the SCB. */
r_return
op_amp
id|lp-&gt;stats
suffix:semicolon
)brace
multiline_comment|/* Initialize the Rx-block list. */
r_static
r_void
DECL|function|init_rx_bufs
id|init_rx_bufs
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
op_star
id|write_ptr
suffix:semicolon
r_int
id|cur_rxbuf
op_assign
id|lp-&gt;rx_head
op_assign
id|RX_BUF_START
suffix:semicolon
multiline_comment|/* Initialize each Rx frame + data buffer. */
r_do
(brace
multiline_comment|/* While there is room for one more. */
id|write_ptr
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|dev-&gt;mem_start
op_plus
id|cur_rxbuf
)paren
suffix:semicolon
op_star
id|write_ptr
op_increment
op_assign
l_int|0x0000
suffix:semicolon
multiline_comment|/* Status */
op_star
id|write_ptr
op_increment
op_assign
l_int|0x0000
suffix:semicolon
multiline_comment|/* Command */
op_star
id|write_ptr
op_increment
op_assign
id|cur_rxbuf
op_plus
id|RX_BUF_SIZE
suffix:semicolon
multiline_comment|/* Link */
op_star
id|write_ptr
op_increment
op_assign
id|cur_rxbuf
op_plus
l_int|22
suffix:semicolon
multiline_comment|/* Buffer offset */
op_star
id|write_ptr
op_increment
op_assign
l_int|0x0000
suffix:semicolon
multiline_comment|/* Pad for dest addr. */
op_star
id|write_ptr
op_increment
op_assign
l_int|0x0000
suffix:semicolon
op_star
id|write_ptr
op_increment
op_assign
l_int|0x0000
suffix:semicolon
op_star
id|write_ptr
op_increment
op_assign
l_int|0x0000
suffix:semicolon
multiline_comment|/* Pad for source addr. */
op_star
id|write_ptr
op_increment
op_assign
l_int|0x0000
suffix:semicolon
op_star
id|write_ptr
op_increment
op_assign
l_int|0x0000
suffix:semicolon
op_star
id|write_ptr
op_increment
op_assign
l_int|0x0000
suffix:semicolon
multiline_comment|/* Pad for protocol. */
op_star
id|write_ptr
op_increment
op_assign
l_int|0x0000
suffix:semicolon
multiline_comment|/* Buffer: Actual count */
op_star
id|write_ptr
op_increment
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Buffer: Next (none). */
op_star
id|write_ptr
op_increment
op_assign
id|cur_rxbuf
op_plus
l_int|0x20
suffix:semicolon
multiline_comment|/* Buffer: Address low */
op_star
id|write_ptr
op_increment
op_assign
l_int|0x0000
suffix:semicolon
multiline_comment|/* Finally, the number of bytes in the buffer. */
op_star
id|write_ptr
op_increment
op_assign
l_int|0x8000
op_plus
id|RX_BUF_SIZE
op_minus
l_int|0x20
suffix:semicolon
id|lp-&gt;rx_tail
op_assign
id|cur_rxbuf
suffix:semicolon
id|cur_rxbuf
op_add_assign
id|RX_BUF_SIZE
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cur_rxbuf
op_le
id|RX_BUF_END
op_minus
id|RX_BUF_SIZE
)paren
suffix:semicolon
multiline_comment|/* Terminate the list by setting the EOL bit, and wrap the pointer to make&n;&t;   the list a ring. */
id|write_ptr
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|dev-&gt;mem_start
op_plus
id|lp-&gt;rx_tail
op_plus
l_int|2
)paren
suffix:semicolon
op_star
id|write_ptr
op_increment
op_assign
l_int|0xC000
suffix:semicolon
multiline_comment|/* Command, mark as last. */
op_star
id|write_ptr
op_increment
op_assign
id|lp-&gt;rx_head
suffix:semicolon
multiline_comment|/* Link */
)brace
r_void
DECL|function|init_82586_mem
id|init_82586_mem
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|ushort
op_star
id|shmem
op_assign
(paren
r_int
op_star
)paren
id|dev-&gt;mem_start
suffix:semicolon
multiline_comment|/* Enable loopback to protect the wire while starting up,&n;&t;   and hold the 586 in reset during the memory initialization. */
id|outb
c_func
(paren
l_int|0x20
comma
id|ioaddr
op_plus
id|MISC_CTRL
)paren
suffix:semicolon
multiline_comment|/* Write the words at 0xfff6 (address-aliased to 0xfffff6). */
macro_line|#ifdef old
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|dev-&gt;mem_start
op_plus
l_int|0xfff6
comma
id|init_words
comma
l_int|10
)paren
suffix:semicolon
macro_line|#else
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|dev-&gt;mem_end
op_minus
l_int|10
comma
id|init_words
comma
l_int|10
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Write the words at 0x0000. */
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|dev-&gt;mem_start
comma
id|init_words
op_plus
l_int|5
comma
r_sizeof
(paren
id|init_words
)paren
op_minus
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Fill in the station address. */
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|dev-&gt;mem_start
op_plus
id|SA_OFFSET
comma
id|dev-&gt;dev_addr
comma
r_sizeof
(paren
id|dev-&gt;dev_addr
)paren
)paren
suffix:semicolon
multiline_comment|/* The Tx-block list is written as needed.  We just set up the values. */
id|lp-&gt;tx_cmd_link
op_assign
id|IDLELOOP
op_plus
l_int|4
suffix:semicolon
id|lp-&gt;tx_head
op_assign
id|lp-&gt;tx_reap
op_assign
id|TX_BUF_START
suffix:semicolon
id|init_rx_bufs
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Start the 586 by releasing the reset line, but leave loopback. */
id|outb
c_func
(paren
l_int|0xA0
comma
id|ioaddr
op_plus
id|MISC_CTRL
)paren
suffix:semicolon
multiline_comment|/* This was time consuming to track down: you need to give two channel&n;&t;   attention signals to reliably start up the i82586. */
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
(brace
r_int
id|boguscnt
op_assign
l_int|50
suffix:semicolon
r_while
c_loop
(paren
id|shmem
(braket
id|iSCB_STATUS
op_rshift
l_int|1
)braket
op_eq
l_int|0
)paren
r_if
c_cond
(paren
op_decrement
id|boguscnt
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: i82586 initialization timed out with status %04x,&quot;
l_string|&quot;cmd %04x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|shmem
(braket
id|iSCB_STATUS
op_rshift
l_int|1
)braket
comma
id|shmem
(braket
id|iSCB_CMD
op_rshift
l_int|1
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Issue channel-attn -- the 82586 won&squot;t start. */
id|outb
c_func
(paren
l_int|0
comma
id|ioaddr
op_plus
id|SIGNAL_CA
)paren
suffix:semicolon
)brace
multiline_comment|/* Disable loopback and enable interrupts. */
id|outb
c_func
(paren
l_int|0x84
comma
id|ioaddr
op_plus
id|MISC_CTRL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Initialized 82586, status %04x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|shmem
(braket
id|iSCB_STATUS
op_rshift
l_int|1
)braket
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|hardware_send_packet
id|hardware_send_packet
c_func
(paren
r_struct
id|device
op_star
id|dev
comma
r_void
op_star
id|buf
comma
r_int
id|length
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
id|ioaddr
op_assign
id|dev-&gt;base_addr
suffix:semicolon
id|ushort
id|tx_block
op_assign
id|lp-&gt;tx_head
suffix:semicolon
id|ushort
op_star
id|write_ptr
op_assign
(paren
id|ushort
op_star
)paren
(paren
id|dev-&gt;mem_start
op_plus
id|tx_block
)paren
suffix:semicolon
multiline_comment|/* Set the write pointer to the Tx block, and put out the header. */
op_star
id|write_ptr
op_increment
op_assign
l_int|0x0000
suffix:semicolon
multiline_comment|/* Tx status */
op_star
id|write_ptr
op_increment
op_assign
id|CMD_INTR
op_or
id|CmdTx
suffix:semicolon
multiline_comment|/* Tx command */
op_star
id|write_ptr
op_increment
op_assign
id|tx_block
op_plus
l_int|16
suffix:semicolon
multiline_comment|/* Next command is a NoOp. */
op_star
id|write_ptr
op_increment
op_assign
id|tx_block
op_plus
l_int|8
suffix:semicolon
multiline_comment|/* Data Buffer offset. */
multiline_comment|/* Output the data buffer descriptor. */
op_star
id|write_ptr
op_increment
op_assign
id|length
op_or
l_int|0x8000
suffix:semicolon
multiline_comment|/* Byte count parameter. */
op_star
id|write_ptr
op_increment
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* No next data buffer. */
op_star
id|write_ptr
op_increment
op_assign
id|tx_block
op_plus
l_int|22
suffix:semicolon
multiline_comment|/* Buffer follows the NoOp command. */
op_star
id|write_ptr
op_increment
op_assign
l_int|0x0000
suffix:semicolon
multiline_comment|/* Buffer address high bits (always zero). */
multiline_comment|/* Output the Loop-back NoOp command. */
op_star
id|write_ptr
op_increment
op_assign
l_int|0x0000
suffix:semicolon
multiline_comment|/* Tx status */
op_star
id|write_ptr
op_increment
op_assign
id|CmdNOp
suffix:semicolon
multiline_comment|/* Tx command */
op_star
id|write_ptr
op_increment
op_assign
id|tx_block
op_plus
l_int|16
suffix:semicolon
multiline_comment|/* Next is myself. */
multiline_comment|/* Output the packet at the write pointer. */
id|memcpy
c_func
(paren
id|write_ptr
comma
id|buf
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* Set the old command link pointing to this send packet. */
op_star
(paren
id|ushort
op_star
)paren
(paren
id|dev-&gt;mem_start
op_plus
id|lp-&gt;tx_cmd_link
)paren
op_assign
id|tx_block
suffix:semicolon
id|lp-&gt;tx_cmd_link
op_assign
id|tx_block
op_plus
l_int|20
suffix:semicolon
multiline_comment|/* Set the next free tx region. */
id|lp-&gt;tx_head
op_assign
id|tx_block
op_plus
id|TX_BUF_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;tx_head
OG
id|RX_BUF_START
op_minus
id|TX_BUF_SIZE
)paren
id|lp-&gt;tx_head
op_assign
id|TX_BUF_START
suffix:semicolon
r_if
c_cond
(paren
id|net_debug
OG
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: 3c507 @%x send length = %d, tx_block %3x, next %3x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ioaddr
comma
id|length
comma
id|tx_block
comma
id|lp-&gt;tx_head
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lp-&gt;tx_head
op_ne
id|lp-&gt;tx_reap
)paren
id|dev-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|el16_rx
id|el16_rx
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_struct
id|net_local
op_star
id|lp
op_assign
(paren
r_struct
id|net_local
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_int
op_star
id|shmem
op_assign
(paren
r_int
op_star
)paren
id|dev-&gt;mem_start
suffix:semicolon
id|ushort
id|rx_head
op_assign
id|lp-&gt;rx_head
suffix:semicolon
id|ushort
id|rx_tail
op_assign
id|lp-&gt;rx_tail
suffix:semicolon
id|ushort
id|boguscount
op_assign
l_int|10
suffix:semicolon
r_int
id|frame_status
suffix:semicolon
r_while
c_loop
(paren
(paren
id|frame_status
op_assign
id|shmem
(braket
id|rx_head
op_rshift
l_int|1
)braket
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* Command complete */
id|ushort
op_star
id|read_frame
op_assign
(paren
r_int
op_star
)paren
(paren
id|dev-&gt;mem_start
op_plus
id|rx_head
)paren
suffix:semicolon
id|ushort
id|rfd_cmd
op_assign
id|read_frame
(braket
l_int|1
)braket
suffix:semicolon
id|ushort
id|next_rx_frame
op_assign
id|read_frame
(braket
l_int|2
)braket
suffix:semicolon
id|ushort
id|data_buffer_addr
op_assign
id|read_frame
(braket
l_int|3
)braket
suffix:semicolon
id|ushort
op_star
id|data_frame
op_assign
(paren
r_int
op_star
)paren
(paren
id|dev-&gt;mem_start
op_plus
id|data_buffer_addr
)paren
suffix:semicolon
id|ushort
id|pkt_len
op_assign
id|data_frame
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|rfd_cmd
op_ne
l_int|0
op_logical_or
id|data_buffer_addr
op_ne
id|rx_head
op_plus
l_int|22
op_logical_or
id|pkt_len
op_amp
l_int|0xC000
op_ne
l_int|0xC000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Rx frame at %#x corrupted, status %04x cmd %04x&quot;
l_string|&quot;next %04x data-buf @%04x %04x.&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rx_head
comma
id|frame_status
comma
id|rfd_cmd
comma
id|next_rx_frame
comma
id|data_buffer_addr
comma
id|pkt_len
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|frame_status
op_amp
l_int|0x2000
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Frame Rxed, but with error. */
id|lp-&gt;stats.rx_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|frame_status
op_amp
l_int|0x0800
)paren
id|lp-&gt;stats.rx_crc_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|frame_status
op_amp
l_int|0x0400
)paren
id|lp-&gt;stats.rx_frame_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|frame_status
op_amp
l_int|0x0200
)paren
id|lp-&gt;stats.rx_fifo_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|frame_status
op_amp
l_int|0x0100
)paren
id|lp-&gt;stats.rx_over_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|frame_status
op_amp
l_int|0x0080
)paren
id|lp-&gt;stats.rx_length_errors
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Malloc up new buffer. */
r_int
id|sksize
suffix:semicolon
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|pkt_len
op_and_assign
l_int|0x3fff
suffix:semicolon
id|sksize
op_assign
r_sizeof
(paren
r_struct
id|sk_buff
)paren
op_plus
id|pkt_len
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|sksize
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Memory squeeze, dropping packet.&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|skb-&gt;mem_len
op_assign
id|sksize
suffix:semicolon
id|skb-&gt;mem_addr
op_assign
id|skb
suffix:semicolon
id|skb-&gt;len
op_assign
id|pkt_len
suffix:semicolon
id|skb-&gt;dev
op_assign
id|dev
suffix:semicolon
multiline_comment|/* &squot;skb-&gt;data&squot; points to the start of sk_buff data area. */
id|memcpy
c_func
(paren
id|skb-&gt;data
comma
id|data_frame
op_plus
l_int|5
comma
id|pkt_len
)paren
suffix:semicolon
macro_line|#ifdef HAVE_NETIF_RX
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
macro_line|#else
id|skb-&gt;lock
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev_rint
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|skb
comma
id|pkt_len
comma
id|IN_SKBUFF
comma
id|dev
)paren
op_ne
l_int|0
)paren
(brace
id|kfree_skbmem
c_func
(paren
id|skb
comma
id|sksize
)paren
suffix:semicolon
id|lp-&gt;stats.rx_dropped
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
id|lp-&gt;stats.rx_packets
op_increment
suffix:semicolon
)brace
multiline_comment|/* Clear the status word and set End-of-List on the rx frame. */
id|read_frame
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|read_frame
(braket
l_int|1
)braket
op_assign
l_int|0xC000
suffix:semicolon
multiline_comment|/* Clear the end-of-list on the prev. RFD. */
op_star
(paren
r_int
op_star
)paren
(paren
id|dev-&gt;mem_start
op_plus
id|rx_tail
op_plus
l_int|2
)paren
op_assign
l_int|0x0000
suffix:semicolon
id|rx_tail
op_assign
id|rx_head
suffix:semicolon
id|rx_head
op_assign
id|next_rx_frame
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|boguscount
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|lp-&gt;rx_head
op_assign
id|rx_head
suffix:semicolon
id|lp-&gt;rx_tail
op_assign
id|rx_tail
suffix:semicolon
)brace
"&f;"
multiline_comment|/*&n; * Local variables:&n; *  compile-command: &quot;gcc -D__KERNEL__ -I/usr/src/linux/net/inet -I/usr/src/linux/drivers/net -Wall -Wstrict-prototypes -O6 -m486 -c 3c507.c&quot;&n; *  version-control: t&n; *  kept-new-versions: 5&n; *  tab-width: 4&n; * End:&n; */
eof
