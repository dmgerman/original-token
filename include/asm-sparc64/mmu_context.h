multiline_comment|/* $Id: mmu_context.h,v 1.31 1998/09/24 03:22:01 davem Exp $ */
macro_line|#ifndef __SPARC64_MMU_CONTEXT_H
DECL|macro|__SPARC64_MMU_CONTEXT_H
mdefine_line|#define __SPARC64_MMU_CONTEXT_H
multiline_comment|/* Derived heavily from Linus&squot;s Alpha/AXP ASN code... */
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/spitfire.h&gt;
macro_line|#include &lt;asm/spinlock.h&gt;
DECL|macro|NO_CONTEXT
mdefine_line|#define NO_CONTEXT     0
macro_line|#ifndef __ASSEMBLY__
r_extern
r_int
r_int
id|tlb_context_cache
suffix:semicolon
r_extern
id|spinlock_t
id|scheduler_lock
suffix:semicolon
r_extern
r_int
r_int
id|mmu_context_bmap
(braket
)braket
suffix:semicolon
DECL|macro|CTX_VERSION_SHIFT
mdefine_line|#define CTX_VERSION_SHIFT&t;(PAGE_SHIFT - 3)
DECL|macro|CTX_VERSION_MASK
mdefine_line|#define CTX_VERSION_MASK&t;((~0UL) &lt;&lt; CTX_VERSION_SHIFT)
DECL|macro|CTX_FIRST_VERSION
mdefine_line|#define CTX_FIRST_VERSION&t;((1UL &lt;&lt; CTX_VERSION_SHIFT) + 1UL)
r_extern
r_void
id|get_new_mmu_context
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
suffix:semicolon
multiline_comment|/* Initialize/destroy the context related info for a new mm_struct&n; * instance.&n; */
DECL|macro|init_new_context
mdefine_line|#define init_new_context(__mm)&t;((__mm)-&gt;context = NO_CONTEXT)
multiline_comment|/* Kernel threads like rpciod and nfsd drop their mm, and then use&n; * init_mm, when this happens we must make sure the tsk-&gt;tss.ctx is&n; * updated as well.  Otherwise we have disasters relating to&n; * set_fs/get_fs usage later on.&n; *&n; * Also we can only clear the mmu_context_bmap bit when this is&n; * the final reference to the address space.&n; */
DECL|macro|destroy_context
mdefine_line|#define destroy_context(__mm)&t;do { &t;&t;&t;&t;&t;&t;&bslash;&n;&t;if ((__mm)-&gt;context != NO_CONTEXT &amp;&amp;&t;&t;&t;&t;&t;&bslash;&n;&t;    atomic_read(&amp;(__mm)-&gt;count) == 1) { &t;&t;&t;&t;&bslash;&n;&t;&t;spin_lock(&amp;scheduler_lock); &t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (!(((__mm)-&gt;context ^ tlb_context_cache) &amp; CTX_VERSION_MASK))&bslash;&n;&t;&t;&t;clear_bit((__mm)-&gt;context &amp; ~(CTX_VERSION_MASK),&t;&bslash;&n;&t;&t;&t;&t;  mmu_context_bmap);&t;&t;&t;&t;&bslash;&n;&t;&t;spin_unlock(&amp;scheduler_lock); &t;&t;&t;&t;&t;&bslash;&n;&t;&t;(__mm)-&gt;context = NO_CONTEXT; &t;&t;&t;&t;&t;&bslash;&n;&t;&t;if(current-&gt;mm == (__mm)) {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;current-&gt;tss.ctx = 0;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;spitfire_set_secondary_context(0);&t;&t;&t;&bslash;&n;&t;&t;&t;__asm__ __volatile__(&quot;flush %g6&quot;);&t;&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;} &t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;} while (0)
multiline_comment|/* This routine must called with interrupts off,&n; * this is necessary to guarentee that the current-&gt;tss.ctx&n; * to CPU secontary context register relationship is maintained&n; * when traps can happen.&n; *&n; * Also the caller must flush the current set of user windows&n; * to the stack (if necessary) before we get here.&n; */
DECL|function|__get_mmu_context
r_extern
id|__inline__
r_void
id|__get_mmu_context
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_register
r_int
r_int
id|paddr
id|asm
c_func
(paren
l_string|&quot;o5&quot;
)paren
suffix:semicolon
r_register
r_int
r_int
id|pgd_cache
id|asm
c_func
(paren
l_string|&quot;o4&quot;
)paren
suffix:semicolon
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|tsk-&gt;mm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tsk-&gt;tss.flags
op_amp
id|SPARC_FLAG_KTHREAD
)paren
op_logical_and
op_logical_neg
(paren
id|tsk-&gt;flags
op_amp
id|PF_EXITING
)paren
)paren
(brace
r_int
r_int
id|ctx
op_assign
id|tlb_context_cache
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mm-&gt;context
op_xor
id|ctx
)paren
op_amp
id|CTX_VERSION_MASK
)paren
(brace
id|get_new_mmu_context
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|mm-&gt;cpu_vm_mask
op_amp
(paren
l_int|1UL
op_lshift
id|smp_processor_id
c_func
(paren
)paren
)paren
)paren
)paren
(brace
id|spitfire_set_secondary_context
c_func
(paren
id|mm-&gt;context
op_amp
l_int|0x3ff
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;flush %g6&quot;
)paren
suffix:semicolon
id|spitfire_flush_dtlb_secondary_context
c_func
(paren
)paren
suffix:semicolon
id|spitfire_flush_itlb_secondary_context
c_func
(paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;flush %g6&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t worry, set_fs() will restore it... */
multiline_comment|/* Sigh, damned include loops... just poke seg directly.  */
id|tsk-&gt;tss.ctx
op_assign
(paren
id|tsk-&gt;tss.current_ds.seg
ques
c_cond
(paren
id|mm-&gt;context
op_amp
l_int|0x3ff
)paren
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_else
id|tsk-&gt;tss.ctx
op_assign
l_int|0
suffix:semicolon
id|spitfire_set_secondary_context
c_func
(paren
id|tsk-&gt;tss.ctx
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;flush %g6&quot;
)paren
suffix:semicolon
id|paddr
op_assign
id|__pa
c_func
(paren
id|mm-&gt;pgd
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tsk-&gt;tss.flags
op_amp
(paren
id|SPARC_FLAG_32BIT
op_or
id|SPARC_FLAG_KTHREAD
)paren
)paren
op_eq
(paren
id|SPARC_FLAG_32BIT
)paren
)paren
(brace
id|pgd_cache
op_assign
(paren
r_int
r_int
)paren
id|mm-&gt;pgd
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
id|pgd_cache
op_assign
l_int|0
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|rdpr
op_mod
op_mod
id|pstate
comma
op_mod
op_mod
id|o2
id|andn
op_mod
op_mod
id|o2
comma
op_mod
l_int|2
comma
op_mod
op_mod
id|o3
id|wrpr
op_mod
op_mod
id|o3
comma
op_mod
l_int|5
comma
op_mod
op_mod
id|pstate
id|mov
op_mod
l_int|4
comma
op_mod
op_mod
id|g4
id|mov
op_mod
l_int|0
comma
op_mod
op_mod
id|g7
id|stxa
op_mod
l_int|1
comma
(braket
op_mod
op_mod
id|g4
)braket
op_mod
l_int|3
id|wrpr
op_mod
op_mod
id|o2
comma
l_int|0x0
comma
op_mod
op_mod
id|pstate
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|paddr
)paren
comma
l_string|&quot;r&quot;
(paren
id|pgd_cache
)paren
comma
l_string|&quot;i&quot;
(paren
id|PSTATE_IE
)paren
comma
l_string|&quot;i&quot;
(paren
id|ASI_DMMU
)paren
comma
l_string|&quot;i&quot;
(paren
id|TSB_REG
)paren
comma
l_string|&quot;i&quot;
(paren
id|PSTATE_MG
)paren
suffix:colon
l_string|&quot;o2&quot;
comma
l_string|&quot;o3&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Now we define this as a do nothing macro, because the only&n; * generic user right now is the scheduler, and we handle all&n; * the atomicity issues by having switch_to() call the above&n; * function itself.&n; */
DECL|macro|get_mmu_context
mdefine_line|#define get_mmu_context(x)&t;do { } while(0)
multiline_comment|/*&n; * After we have set current-&gt;mm to a new value, this activates&n; * the context for the new mm so we see the new mappings.&n; */
DECL|macro|activate_context
mdefine_line|#define activate_context(__tsk)&t;&t;&bslash;&n;do {&t;unsigned long __flags;&t;&t;&bslash;&n;&t;__save_and_cli(__flags);&t;&bslash;&n;&t;flushw_user();&t;&t;&t;&bslash;&n;&t;__get_mmu_context(__tsk);&t;&bslash;&n;&t;__restore_flags(__flags);&t;&bslash;&n;} while(0)
macro_line|#endif /* !(__ASSEMBLY__) */
macro_line|#endif /* !(__SPARC64_MMU_CONTEXT_H) */
eof
