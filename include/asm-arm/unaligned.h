macro_line|#ifndef __ASM_ARM_UNALIGNED_H
DECL|macro|__ASM_ARM_UNALIGNED_H
mdefine_line|#define __ASM_ARM_UNALIGNED_H
macro_line|#include &lt;asm/types.h&gt;
r_extern
r_int
id|__bug_unaligned_x
c_func
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
multiline_comment|/*&n; * What is the most efficient way of loading/storing an unaligned value?&n; *&n; * That is the subject of this file.  Efficiency here is defined as&n; * minimum code size with minimum register usage for the common cases.&n; * It is currently not believed that long longs are common, so we&n; * trade efficiency for the chars, shorts and longs against the long&n; * longs.&n; *&n; * Current stats with gcc 2.7.2.2 for these functions:&n; *&n; *&t;ptrsize&t;get:&t;code&t;regs&t;put:&t;code&t;regs&n; *&t;1&t;&t;1&t;1&t;&t;1&t;2&n; *&t;2&t;&t;3&t;2&t;&t;3&t;2&n; *&t;4&t;&t;7&t;3&t;&t;7&t;3&n; *&t;8&t;&t;20&t;6&t;&t;16&t;6&n; *&n; * gcc 2.95.1 seems to code differently:&n; *&n; *&t;ptrsize&t;get:&t;code&t;regs&t;put:&t;code&t;regs&n; *&t;1&t;&t;1&t;1&t;&t;1&t;2&n; *&t;2&t;&t;3&t;2&t;&t;3&t;2&n; *&t;4&t;&t;7&t;4&t;&t;7&t;4&n; *&t;8&t;&t;19&t;8&t;&t;15&t;6&n; *&n; * which may or may not be more efficient (depending upon whether&n; * you can afford the extra registers).  Hopefully the gcc 2.95&n; * is inteligent enough to decide if it is better to use the&n; * extra register, but evidence so far seems to suggest otherwise.&n; *&n; * Unfortunately, gcc is not able to optimise the high word&n; * out of long long &gt;&gt; 32, or the low word from long long &lt;&lt; 32&n; */
DECL|macro|__get_unaligned_2
mdefine_line|#define __get_unaligned_2(__p)&t;&t;&t;&t;&t;&bslash;&n;&t;(__p[0] | __p[1] &lt;&lt; 8)
DECL|macro|__get_unaligned_4
mdefine_line|#define __get_unaligned_4(__p)&t;&t;&t;&t;&t;&bslash;&n;&t;(__p[0] | __p[1] &lt;&lt; 8 | __p[2] &lt;&lt; 16 | __p[3] &lt;&lt; 24)
DECL|macro|get_unaligned
mdefine_line|#define get_unaligned(ptr)&t;&t;&t;&t;&t;&bslash;&n;&t;({&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__typeof__(*(ptr)) __v;&t;&t;&t;&t;&bslash;&n;&t;&t;__u8 *__p = (__u8 *)(ptr);&t;&t;&t;&bslash;&n;&t;&t;switch (sizeof(*(ptr))) {&t;&t;&t;&bslash;&n;&t;&t;case 1:&t;__v = *(ptr);&t;&t;&t;break;&t;&bslash;&n;&t;&t;case 2: __v = __get_unaligned_2(__p);&t;break;&t;&bslash;&n;&t;&t;case 4: __v = __get_unaligned_4(__p);&t;break;&t;&bslash;&n;&t;&t;case 8: {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;unsigned int __v1, __v2;&t;&bslash;&n;&t;&t;&t;&t;__v2 = __get_unaligned_4((__p+4)); &bslash;&n;&t;&t;&t;&t;__v1 = __get_unaligned_4(__p);&t;&bslash;&n;&t;&t;&t;&t;__v = ((unsigned long long)__v2 &lt;&lt; 32 | __v1);&t;&bslash;&n;&t;&t;&t;}&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;break;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;default: __v = __bug_unaligned_x(__p);&t;break;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__v;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;})
DECL|function|__put_unaligned_2
r_static
r_inline
r_void
id|__put_unaligned_2
c_func
(paren
id|__u32
id|__v
comma
r_register
id|__u8
op_star
id|__p
)paren
(brace
op_star
id|__p
op_increment
op_assign
id|__v
suffix:semicolon
op_star
id|__p
op_increment
op_assign
id|__v
op_rshift
l_int|8
suffix:semicolon
)brace
DECL|function|__put_unaligned_4
r_static
r_inline
r_void
id|__put_unaligned_4
c_func
(paren
id|__u32
id|__v
comma
r_register
id|__u8
op_star
id|__p
)paren
(brace
id|__put_unaligned_2
c_func
(paren
id|__v
op_rshift
l_int|16
comma
id|__p
op_plus
l_int|2
)paren
suffix:semicolon
id|__put_unaligned_2
c_func
(paren
id|__v
comma
id|__p
)paren
suffix:semicolon
)brace
DECL|function|__put_unaligned_8
r_static
r_inline
r_void
id|__put_unaligned_8
c_func
(paren
r_const
r_int
r_int
r_int
id|__v
comma
r_register
id|__u8
op_star
id|__p
)paren
(brace
multiline_comment|/*&n;&t; * tradeoff: 8 bytes of stack for all unaligned puts (2&n;&t; * instructions), or an extra register in the long long&n;&t; * case - go for the extra register.&n;&t; */
id|__put_unaligned_4
c_func
(paren
id|__v
op_rshift
l_int|32
comma
id|__p
op_plus
l_int|4
)paren
suffix:semicolon
id|__put_unaligned_4
c_func
(paren
id|__v
comma
id|__p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to store an unaligned value as efficiently as possible.&n; */
DECL|macro|put_unaligned
mdefine_line|#define put_unaligned(val,ptr)&t;&t;&t;&t;&t;&bslash;&n;&t;({&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;switch (sizeof(*(ptr))) {&t;&t;&t;&bslash;&n;&t;&t;case 1:&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;*(ptr) = (val);&t;&t;&t;&t;&bslash;&n;&t;&t;&t;break;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;case 2: __put_unaligned_2((val),(__u8 *)(ptr));&t;&bslash;&n;&t;&t;&t;break;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;case 4:&t;__put_unaligned_4((val),(__u8 *)(ptr));&t;&bslash;&n;&t;&t;&t;break;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;case 8:&t;__put_unaligned_8((val),(__u8 *)(ptr)); &bslash;&n;&t;&t;&t;break;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;default: __bug_unaligned_x(ptr);&t;&t;&bslash;&n;&t;&t;&t;break;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;(void) 0;&t;&t;&t;&t;&t;&bslash;&n;&t;})
macro_line|#endif
eof
