multiline_comment|/* spinlock.h: 32-bit Sparc spinlock support.&n; *&n; * Copyright (C) 1997 David S. Miller (davem@caip.rutgers.edu)&n; */
macro_line|#ifndef __SPARC_SPINLOCK_H
DECL|macro|__SPARC_SPINLOCK_H
mdefine_line|#define __SPARC_SPINLOCK_H
macro_line|#ifndef __ASSEMBLY__
macro_line|#ifndef __SMP__
DECL|typedef|spinlock_t
r_typedef
r_struct
(brace
)brace
id|spinlock_t
suffix:semicolon
DECL|macro|SPIN_LOCK_UNLOCKED
mdefine_line|#define SPIN_LOCK_UNLOCKED { }
DECL|macro|spin_lock_init
mdefine_line|#define spin_lock_init(lock)&t;do { } while(0)
DECL|macro|spin_lock
mdefine_line|#define spin_lock(lock)&t;&t;do { } while(0)
DECL|macro|spin_trylock
mdefine_line|#define spin_trylock(lock)&t;do { } while(0)
DECL|macro|spin_unlock_wait
mdefine_line|#define spin_unlock_wait(lock)&t;do { } while(0)
DECL|macro|spin_unlock
mdefine_line|#define spin_unlock(lock)&t;do { } while(0)
DECL|macro|spin_lock_irq
mdefine_line|#define spin_lock_irq(lock)&t;cli()
DECL|macro|spin_unlock_irq
mdefine_line|#define spin_unlock_irq(lock)&t;sti()
DECL|macro|spin_lock_irqsave
mdefine_line|#define spin_lock_irqsave(lock, flags)&t;&t;save_and_cli(flags)
DECL|macro|spin_unlock_irqrestore
mdefine_line|#define spin_unlock_irqrestore(lock, flags)&t;restore_flags(flags)
multiline_comment|/*&n; * Read-write spinlocks, allowing multiple readers&n; * but only one writer.&n; *&n; * NOTE! it is quite common to have readers in interrupts&n; * but no interrupt writers. For those circumstances we&n; * can &quot;mix&quot; irq-safe locks - any writer needs to get a&n; * irq-safe write-lock, but readers can get non-irqsafe&n; * read-locks.&n; */
DECL|typedef|rwlock_t
r_typedef
r_struct
(brace
)brace
id|rwlock_t
suffix:semicolon
DECL|macro|RW_LOCK_UNLOCKED
mdefine_line|#define RW_LOCK_UNLOCKED { }
DECL|macro|read_lock
mdefine_line|#define read_lock(lock)&t;&t;do { } while(0)
DECL|macro|read_unlock
mdefine_line|#define read_unlock(lock)&t;do { } while(0)
DECL|macro|write_lock
mdefine_line|#define write_lock(lock)&t;do { } while(0)
DECL|macro|write_unlock
mdefine_line|#define write_unlock(lock)&t;do { } while(0)
DECL|macro|read_lock_irq
mdefine_line|#define read_lock_irq(lock)&t;cli()
DECL|macro|read_unlock_irq
mdefine_line|#define read_unlock_irq(lock)&t;sti()
DECL|macro|write_lock_irq
mdefine_line|#define write_lock_irq(lock)&t;cli()
DECL|macro|write_unlock_irq
mdefine_line|#define write_unlock_irq(lock)&t;sti()
DECL|macro|read_lock_irqsave
mdefine_line|#define read_lock_irqsave(lock, flags)&t;&t;save_and_cli(flags)
DECL|macro|read_unlock_irqrestore
mdefine_line|#define read_unlock_irqrestore(lock, flags)&t;restore_flags(flags)
DECL|macro|write_lock_irqsave
mdefine_line|#define write_lock_irqsave(lock, flags)&t;&t;save_and_cli(flags)
DECL|macro|write_unlock_irqrestore
mdefine_line|#define write_unlock_irqrestore(lock, flags)&t;restore_flags(flags)
macro_line|#else /* !(__SMP__) */
macro_line|#include &lt;asm/psr.h&gt;
multiline_comment|/* Define this to use the verbose/debugging versions in arch/sparc/lib/debuglocks.c */
multiline_comment|/* #define SPIN_LOCK_DEBUG */
macro_line|#ifdef SPIN_LOCK_DEBUG
DECL|struct|_spinlock_debug
r_struct
id|_spinlock_debug
(brace
DECL|member|lock
r_int
r_char
id|lock
suffix:semicolon
DECL|member|owner_pc
r_int
r_int
id|owner_pc
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|spinlock_t
r_typedef
r_struct
id|_spinlock_debug
id|spinlock_t
suffix:semicolon
DECL|macro|SPIN_LOCK_UNLOCKED
mdefine_line|#define SPIN_LOCK_UNLOCKED&t;{ 0, 0 }
DECL|macro|spin_lock_init
mdefine_line|#define spin_lock_init(lp)&t;do { (lp)-&gt;owner_pc = 0; (lp)-&gt;lock = 0; } while(0)
DECL|macro|spin_unlock_wait
mdefine_line|#define spin_unlock_wait(lp)&t;do { barrier(); } while((lp)-&gt;lock)
r_extern
r_void
id|_spin_lock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
suffix:semicolon
r_extern
r_int
id|_spin_trylock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
suffix:semicolon
r_extern
r_void
id|_spin_unlock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
suffix:semicolon
r_extern
r_void
id|_spin_lock_irq
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
suffix:semicolon
r_extern
r_void
id|_spin_unlock_irq
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
suffix:semicolon
r_extern
r_void
id|_spin_lock_irqsave
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
suffix:semicolon
r_extern
r_void
id|_spin_unlock_irqrestore
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
suffix:semicolon
DECL|macro|spin_lock
mdefine_line|#define spin_lock(lp)&t;&t;&t;_spin_lock(lp)
DECL|macro|spin_trylock
mdefine_line|#define spin_trylock(lp)&t;&t;_spin_trylock(lp)
DECL|macro|spin_unlock
mdefine_line|#define spin_unlock(lp)&t;&t;&t;_spin_unlock(lp)
DECL|macro|spin_lock_irq
mdefine_line|#define spin_lock_irq(lp)&t;&t;_spin_lock_irq(lp)
DECL|macro|spin_unlock_irq
mdefine_line|#define spin_unlock_irq(lp)&t;&t;_spin_unlock_irq(lp)
DECL|macro|spin_lock_irqsave
mdefine_line|#define spin_lock_irqsave(lp, flags)&t;do { __save_and_cli(flags); &bslash;&n;&t;&t;&t;&t;&t;     _spin_lock_irqsave(lp); } while (0)
DECL|macro|spin_unlock_irqrestore
mdefine_line|#define spin_unlock_irqrestore(lp, flags) do { _spin_unlock_irqrestore(lp); &bslash;&n;&t;&t;&t;&t;&t;       __restore_flags(flags); } while(0)
DECL|struct|_rwlock_debug
r_struct
id|_rwlock_debug
(brace
DECL|member|lock
r_volatile
r_int
r_int
id|lock
suffix:semicolon
DECL|member|owner_pc
r_int
r_int
id|owner_pc
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|rwlock_t
r_typedef
r_struct
id|_rwlock_debug
id|rwlock_t
suffix:semicolon
DECL|macro|RW_LOCK_UNLOCKED
mdefine_line|#define RW_LOCK_UNLOCKED { 0, 0 }
r_extern
r_void
id|_read_lock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
suffix:semicolon
r_extern
r_void
id|_read_unlock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
suffix:semicolon
r_extern
r_void
id|_write_lock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
suffix:semicolon
r_extern
r_void
id|_write_unlock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
suffix:semicolon
r_extern
r_void
id|_read_lock_irq
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
suffix:semicolon
r_extern
r_void
id|_read_unlock_irq
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
suffix:semicolon
r_extern
r_void
id|_write_lock_irq
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
suffix:semicolon
r_extern
r_void
id|_write_unlock_irq
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
suffix:semicolon
r_extern
r_void
id|_read_lock_irqsave
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
suffix:semicolon
r_extern
r_void
id|_read_unlock_irqrestore
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
suffix:semicolon
r_extern
r_void
id|_write_lock_irqsave
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
suffix:semicolon
r_extern
r_void
id|_write_unlock_irqrestore
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
suffix:semicolon
DECL|macro|read_lock
mdefine_line|#define read_lock(rw)&t;&t;_read_lock(rw)
DECL|macro|read_unlock
mdefine_line|#define read_unlock(rw)&t;&t;_read_unlock(rw)
DECL|macro|write_lock
mdefine_line|#define write_lock(rw)&t;&t;_write_lock(rw)
DECL|macro|write_unlock
mdefine_line|#define write_unlock(rw)&t;_write_unlock(rw)
DECL|macro|read_lock_irq
mdefine_line|#define read_lock_irq(rw)&t;_read_lock_irq(rw)
DECL|macro|read_unlock_irq
mdefine_line|#define read_unlock_irq(rw)&t;_read_unlock_irq(rw)
DECL|macro|write_lock_irq
mdefine_line|#define write_lock_irq(rw)&t;_write_lock_irq(rw)
DECL|macro|write_unlock_irq
mdefine_line|#define write_unlock_irq(rw)&t;_write_unlock_irq(rw)
DECL|macro|read_lock_irqsave
mdefine_line|#define read_lock_irqsave(rw, flags) &bslash;&n;do { __save_and_cli(flags); _read_lock_irqsave(rw); } while (0)
DECL|macro|read_unlock_irqrestore
mdefine_line|#define read_unlock_irqrestore(rw, flags) do { _read_unlock_irqrestore(rw); &bslash;&n;&t;&t;&t;&t;&t;       __restore_flags(flags); } while(0)
DECL|macro|write_lock_irqsave
mdefine_line|#define write_lock_irqsave(rw, flags) &bslash;&n;do { __save_and_cli(flags); _write_lock_irqsave(rw); } while(0)
DECL|macro|write_unlock_irqrestore
mdefine_line|#define write_unlock_irqrestore(rw, flags) do { _write_unlock_irqrestore(rw); &bslash;&n;&t;&t;&t;&t;&t;        __restore_flags(flags); } while(0)
macro_line|#else /* !SPIN_LOCK_DEBUG */
DECL|typedef|spinlock_t
r_typedef
r_int
r_char
id|spinlock_t
suffix:semicolon
DECL|macro|SPIN_LOCK_UNLOCKED
mdefine_line|#define SPIN_LOCK_UNLOCKED&t;0
DECL|macro|spin_lock_init
mdefine_line|#define spin_lock_init(lock)&t;(*(lock) = 0)
DECL|macro|spin_unlock_wait
mdefine_line|#define spin_unlock_wait(lock)&t;do { barrier(); } while(*(volatile spinlock_t *)lock)
DECL|function|spin_lock
r_extern
id|__inline__
r_void
id|spin_lock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
l_int|1
suffix:colon
id|ldstub
(braket
op_mod
l_int|0
)braket
comma
op_mod
op_mod
id|g2
id|orcc
op_mod
op_mod
id|g2
comma
l_int|0x0
comma
op_mod
op_mod
id|g0
id|bne
comma
id|a
l_float|2f
id|ldub
(braket
op_mod
l_int|0
)braket
comma
op_mod
op_mod
id|g2
dot
id|text
l_int|2
l_int|2
suffix:colon
id|orcc
op_mod
op_mod
id|g2
comma
l_int|0x0
comma
op_mod
op_mod
id|g0
id|bne
comma
id|a
l_int|2
id|b
id|ldub
(braket
op_mod
l_int|0
)braket
comma
op_mod
op_mod
id|g2
id|b
comma
id|a
l_int|1
id|b
dot
id|previous
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|lock
)paren
suffix:colon
l_string|&quot;g2&quot;
comma
l_string|&quot;memory&quot;
comma
l_string|&quot;cc&quot;
)paren
suffix:semicolon
)brace
DECL|function|spin_trylock
r_extern
id|__inline__
r_int
id|spin_trylock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
r_int
r_int
id|result
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;ldstub [%1], %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|result
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|lock
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
(paren
id|result
op_eq
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|spin_unlock
r_extern
id|__inline__
r_void
id|spin_unlock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;stb %%g0, [%0]&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|lock
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|function|spin_lock_irq
r_extern
id|__inline__
r_void
id|spin_lock_irq
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|rd
op_mod
op_mod
id|psr
comma
op_mod
op_mod
id|g2
op_logical_or
op_mod
op_mod
id|g2
comma
op_mod
l_int|0
comma
op_mod
op_mod
id|g2
id|wr
op_mod
op_mod
id|g2
comma
l_int|0x0
comma
op_mod
op_mod
id|psr
id|nop
suffix:semicolon
id|nop
suffix:semicolon
id|nop
suffix:semicolon
l_int|1
suffix:colon
id|ldstub
(braket
op_mod
l_int|1
)braket
comma
op_mod
op_mod
id|g2
id|orcc
op_mod
op_mod
id|g2
comma
l_int|0x0
comma
op_mod
op_mod
id|g0
id|bne
comma
id|a
l_float|2f
id|ldub
(braket
op_mod
l_int|1
)braket
comma
op_mod
op_mod
id|g2
dot
id|text
l_int|2
l_int|2
suffix:colon
id|orcc
op_mod
op_mod
id|g2
comma
l_int|0x0
comma
op_mod
op_mod
id|g0
id|bne
comma
id|a
l_int|2
id|b
id|ldub
(braket
op_mod
l_int|1
)braket
comma
op_mod
op_mod
id|g2
id|b
comma
id|a
l_int|1
id|b
dot
id|previous
"&quot;"
suffix:colon
multiline_comment|/* No outputs */
suffix:colon
l_string|&quot;i&quot;
(paren
id|PSR_PIL
)paren
comma
l_string|&quot;r&quot;
(paren
id|lock
)paren
suffix:colon
l_string|&quot;g2&quot;
comma
l_string|&quot;memory&quot;
comma
l_string|&quot;cc&quot;
)paren
suffix:semicolon
)brace
DECL|function|spin_unlock_irq
r_extern
id|__inline__
r_void
id|spin_unlock_irq
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|rd
op_mod
op_mod
id|psr
comma
op_mod
op_mod
id|g2
id|andn
op_mod
op_mod
id|g2
comma
op_mod
l_int|1
comma
op_mod
op_mod
id|g2
id|stb
op_mod
op_mod
id|g0
comma
(braket
op_mod
l_int|0
)braket
id|wr
op_mod
op_mod
id|g2
comma
l_int|0x0
comma
op_mod
op_mod
id|psr
id|nop
suffix:semicolon
id|nop
suffix:semicolon
id|nop
suffix:semicolon
"&quot;"
suffix:colon
multiline_comment|/* No outputs. */
suffix:colon
l_string|&quot;r&quot;
(paren
id|lock
)paren
comma
l_string|&quot;i&quot;
(paren
id|PSR_PIL
)paren
suffix:colon
l_string|&quot;g2&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|macro|spin_lock_irqsave
mdefine_line|#define spin_lock_irqsave(lock, flags)&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;register spinlock_t *lp asm(&quot;g1&quot;);&t;&bslash;&n;&t;lp = lock;&t;&t;&t;&t;&bslash;&n;&t;__asm__ __volatile__(&t;&t;&t;&bslash;&n;&t;&quot;rd&t;%%psr, %0&bslash;n&bslash;t&quot;&t;&t;&t;&bslash;&n;&t;&quot;or&t;%0, %1, %%g2&bslash;n&bslash;t&quot;&t;&t;&bslash;&n;&t;&quot;wr&t;%%g2, 0x0, %%psr&bslash;n&bslash;t&quot;&t;&t;&bslash;&n;&t;&quot;nop; nop; nop;&bslash;n&quot;&t;&t;&t;&bslash;&n;&t;&quot;1:&bslash;n&bslash;t&quot;&t;&t;&t;&t;&bslash;&n;&t;&quot;ldstub&t;[%2], %%g2&bslash;n&bslash;t&quot;&t;&t;&t;&bslash;&n;&t;&quot;orcc&t;%%g2, 0x0, %%g0&bslash;n&bslash;t&quot;&t;&t;&bslash;&n;&t;&quot;bne,a&t;2f&bslash;n&bslash;t&quot;&t;&t;&t;&t;&bslash;&n;&t;&quot; ldub&t;[%2], %%g2&bslash;n&bslash;t&quot;&t;&t;&t;&bslash;&n;&t;&quot;.text&t;2&bslash;n&quot;&t;&t;&t;&t;&bslash;&n;&t;&quot;2:&bslash;n&bslash;t&quot;&t;&t;&t;&t;&bslash;&n;&t;&quot;orcc&t;%%g2, 0x0, %%g0&bslash;n&bslash;t&quot;&t;&t;&bslash;&n;&t;&quot;bne,a&t;2b&bslash;n&bslash;t&quot;&t;&t;&t;&t;&bslash;&n;&t;&quot; ldub&t;[%2], %%g2&bslash;n&bslash;t&quot;&t;&t;&t;&bslash;&n;&t;&quot;b,a&t;1b&bslash;n&bslash;t&quot;&t;&t;&t;&t;&bslash;&n;&t;&quot;.previous&bslash;n&quot;&t;&t;&t;&t;&bslash;&n;&t;: &quot;=r&quot; (flags)&t;&t;&t;&t;&bslash;&n;&t;: &quot;i&quot; (PSR_PIL), &quot;r&quot; (lp)&t;&t;&bslash;&n;&t;: &quot;g2&quot;, &quot;memory&quot;, &quot;cc&quot;);&t;&t;&bslash;&n;} while(0)
DECL|function|spin_unlock_irqrestore
r_extern
id|__inline__
r_void
id|spin_unlock_irqrestore
c_func
(paren
id|spinlock_t
op_star
id|lock
comma
r_int
r_int
id|flags
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|stb
op_mod
op_mod
id|g0
comma
(braket
op_mod
l_int|0
)braket
id|wr
op_mod
l_int|1
comma
l_int|0x0
comma
op_mod
op_mod
id|psr
id|nop
suffix:semicolon
id|nop
suffix:semicolon
id|nop
suffix:semicolon
"&quot;"
suffix:colon
multiline_comment|/* No outputs. */
suffix:colon
l_string|&quot;r&quot;
(paren
id|lock
)paren
comma
l_string|&quot;r&quot;
(paren
id|flags
)paren
suffix:colon
l_string|&quot;memory&quot;
comma
l_string|&quot;cc&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Read-write spinlocks, allowing multiple readers&n; * but only one writer.&n; *&n; * NOTE! it is quite common to have readers in interrupts&n; * but no interrupt writers. For those circumstances we&n; * can &quot;mix&quot; irq-safe locks - any writer needs to get a&n; * irq-safe write-lock, but readers can get non-irqsafe&n; * read-locks.&n; *&n; * XXX This might create some problems with my dual spinlock&n; * XXX scheme, deadlocks etc. -DaveM&n; */
DECL|member|lock
DECL|typedef|rwlock_t
r_typedef
r_struct
(brace
r_volatile
r_int
r_int
id|lock
suffix:semicolon
)brace
id|rwlock_t
suffix:semicolon
DECL|macro|RW_LOCK_UNLOCKED
mdefine_line|#define RW_LOCK_UNLOCKED { 0 }
multiline_comment|/* Sort of like atomic_t&squot;s on Sparc, but even more clever.&n; *&n; *&t;------------------------------------&n; *&t;| 16-bit counter   | clock | wlock |  rwlock_t&n; *&t;------------------------------------&n; *&t; 31              16 15    8 7     0&n; *&n; * wlock signifies the one writer is in, the clock protects&n; * counter bumping, however a reader must acquire wlock&n; * before he can bump the counter on a read_lock().&n; * Similarly a writer, once he has the wlock, must await&n; * for the top 24 bits to all clear before he can finish&n; * going in (this includes the clock of course).&n; *&n; * Unfortunately this scheme limits us to ~65,000 cpus.&n; */
DECL|function|_read_lock
r_extern
id|__inline__
r_void
id|_read_lock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_register
id|rwlock_t
op_star
id|lp
id|asm
c_func
(paren
l_string|&quot;g1&quot;
)paren
suffix:semicolon
id|lp
op_assign
id|rw
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|mov
op_mod
op_mod
id|o7
comma
op_mod
op_mod
id|g4
id|call
id|___rw_read_enter
id|ldstub
(braket
op_mod
op_mod
id|g1
op_plus
l_int|3
)braket
comma
op_mod
op_mod
id|g2
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|lp
)paren
suffix:colon
l_string|&quot;g2&quot;
comma
l_string|&quot;g4&quot;
comma
l_string|&quot;g7&quot;
comma
l_string|&quot;memory&quot;
comma
l_string|&quot;cc&quot;
)paren
suffix:semicolon
)brace
DECL|macro|read_lock
mdefine_line|#define read_lock(lock) &bslash;&n;do {&t;unsigned long flags; &bslash;&n;&t;__save_and_cli(flags); &bslash;&n;&t;_read_lock(lock); &bslash;&n;&t;__restore_flags(flags); &bslash;&n;} while(0)
DECL|function|_read_unlock
r_extern
id|__inline__
r_void
id|_read_unlock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_register
id|rwlock_t
op_star
id|lp
id|asm
c_func
(paren
l_string|&quot;g1&quot;
)paren
suffix:semicolon
id|lp
op_assign
id|rw
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|mov
op_mod
op_mod
id|o7
comma
op_mod
op_mod
id|g4
id|call
id|___rw_read_exit
id|ldstub
(braket
op_mod
op_mod
id|g1
op_plus
l_int|2
)braket
comma
op_mod
op_mod
id|g2
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|lp
)paren
suffix:colon
l_string|&quot;g2&quot;
comma
l_string|&quot;g4&quot;
comma
l_string|&quot;g7&quot;
comma
l_string|&quot;memory&quot;
comma
l_string|&quot;cc&quot;
)paren
suffix:semicolon
)brace
DECL|macro|read_unlock
mdefine_line|#define read_unlock(lock) &bslash;&n;do {&t;unsigned long flags; &bslash;&n;&t;__save_and_cli(flags); &bslash;&n;&t;_read_unlock(lock); &bslash;&n;&t;__restore_flags(flags); &bslash;&n;} while(0)
DECL|function|write_lock
r_extern
id|__inline__
r_void
id|write_lock
c_func
(paren
id|rwlock_t
op_star
id|rw
)paren
(brace
r_register
id|rwlock_t
op_star
id|lp
id|asm
c_func
(paren
l_string|&quot;g1&quot;
)paren
suffix:semicolon
id|lp
op_assign
id|rw
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|mov
op_mod
op_mod
id|o7
comma
op_mod
op_mod
id|g4
id|call
id|___rw_write_enter
id|ldstub
(braket
op_mod
op_mod
id|g1
op_plus
l_int|3
)braket
comma
op_mod
op_mod
id|g2
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|lp
)paren
suffix:colon
l_string|&quot;g2&quot;
comma
l_string|&quot;g4&quot;
comma
l_string|&quot;g7&quot;
comma
l_string|&quot;memory&quot;
comma
l_string|&quot;cc&quot;
)paren
suffix:semicolon
)brace
DECL|macro|write_unlock
mdefine_line|#define write_unlock(rw)&t;do { (rw)-&gt;lock = 0; } while(0)
DECL|macro|read_lock_irq
mdefine_line|#define read_lock_irq(lock)&t;do { __cli(); _read_lock(lock); } while (0)
DECL|macro|read_unlock_irq
mdefine_line|#define read_unlock_irq(lock)&t;do { _read_unlock(lock); __sti(); } while (0)
DECL|macro|write_lock_irq
mdefine_line|#define write_lock_irq(lock)&t;do { __cli(); write_lock(lock); } while (0)
DECL|macro|write_unlock_irq
mdefine_line|#define write_unlock_irq(lock)&t;do { write_unlock(lock); __sti(); } while (0)
DECL|macro|read_lock_irqsave
mdefine_line|#define read_lock_irqsave(lock, flags)&t;&bslash;&n;&t;do { __save_and_cli(flags); _read_lock(lock); } while (0)
DECL|macro|read_unlock_irqrestore
mdefine_line|#define read_unlock_irqrestore(lock, flags) &bslash;&n;&t;do { _read_unlock(lock); __restore_flags(flags); } while (0)
DECL|macro|write_lock_irqsave
mdefine_line|#define write_lock_irqsave(lock, flags)&t;&bslash;&n;&t;do { __save_and_cli(flags); write_lock(lock); } while (0)
DECL|macro|write_unlock_irqrestore
mdefine_line|#define write_unlock_irqrestore(lock, flags) &bslash;&n;&t;do { write_unlock(lock); __restore_flags(flags); } while (0)
macro_line|#endif /* SPIN_LOCK_DEBUG */
macro_line|#endif /* __SMP__ */
macro_line|#endif /* !(__ASSEMBLY__) */
macro_line|#endif /* __SPARC_SPINLOCK_H */
eof
