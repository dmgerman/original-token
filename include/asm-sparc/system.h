multiline_comment|/* $Id: system.h,v 1.51 1997/01/25 01:33:05 davem Exp $ */
macro_line|#ifndef __SPARC_SYSTEM_H
DECL|macro|__SPARC_SYSTEM_H
mdefine_line|#define __SPARC_SYSTEM_H
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#ifdef __KERNEL__
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/psr.h&gt;
macro_line|#endif
DECL|macro|EMPTY_PGT
mdefine_line|#define EMPTY_PGT       (&amp;empty_bad_page)
DECL|macro|EMPTY_PGE
mdefine_line|#define EMPTY_PGE&t;(&amp;empty_bad_page_table)
macro_line|#ifndef __ASSEMBLY__
multiline_comment|/*&n; * Sparc (general) CPU types&n; */
DECL|enum|sparc_cpu
r_enum
id|sparc_cpu
(brace
DECL|enumerator|sun4
id|sun4
op_assign
l_int|0x00
comma
DECL|enumerator|sun4c
id|sun4c
op_assign
l_int|0x01
comma
DECL|enumerator|sun4m
id|sun4m
op_assign
l_int|0x02
comma
DECL|enumerator|sun4d
id|sun4d
op_assign
l_int|0x03
comma
DECL|enumerator|sun4e
id|sun4e
op_assign
l_int|0x04
comma
DECL|enumerator|sun4u
id|sun4u
op_assign
l_int|0x05
comma
multiline_comment|/* V8 ploos ploos */
DECL|enumerator|sun_unknown
id|sun_unknown
op_assign
l_int|0x06
comma
DECL|enumerator|ap1000
id|ap1000
op_assign
l_int|0x07
comma
multiline_comment|/* almost a sun4m */
)brace
suffix:semicolon
r_extern
r_enum
id|sparc_cpu
id|sparc_cpu_model
suffix:semicolon
r_extern
r_int
r_int
id|empty_bad_page
suffix:semicolon
r_extern
r_int
r_int
id|empty_bad_page_table
suffix:semicolon
r_extern
r_int
r_int
id|empty_zero_page
suffix:semicolon
r_extern
r_struct
id|linux_romvec
op_star
id|romvec
suffix:semicolon
DECL|macro|halt
mdefine_line|#define halt() romvec-&gt;pv_halt()
multiline_comment|/* When a context switch happens we must flush all user windows so that&n; * the windows of the current process are flushed onto its stack. This&n; * way the windows are all clean for the next process and the stack&n; * frames are up to date.&n; */
r_extern
r_void
id|flush_user_windows
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|kill_user_windows
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|synchronize_user_stack
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|fpsave
c_func
(paren
r_int
r_int
op_star
id|fpregs
comma
r_int
r_int
op_star
id|fsr
comma
r_void
op_star
id|fpqueue
comma
r_int
r_int
op_star
id|fpqdepth
)paren
suffix:semicolon
macro_line|#ifdef __SMP__
DECL|macro|SWITCH_ENTER
mdefine_line|#define SWITCH_ENTER &bslash;&n;&t;cli(); &bslash;&n;&t;if(prev-&gt;flags &amp; PF_USEDFPU) { &bslash;&n;&t;&t;put_psr(get_psr() | PSR_EF); &bslash;&n;&t;&t;fpsave(&amp;prev-&gt;tss.float_regs[0], &amp;prev-&gt;tss.fsr, &bslash;&n;&t;&t;       &amp;prev-&gt;tss.fpqueue[0], &amp;prev-&gt;tss.fpqdepth); &bslash;&n;&t;&t;prev-&gt;flags &amp;= ~PF_USEDFPU; &bslash;&n;&t;&t;prev-&gt;tss.kregs-&gt;psr &amp;= ~PSR_EF; &bslash;&n;&t;}
DECL|macro|SWITCH_EXIT
mdefine_line|#define SWITCH_EXIT sti();
DECL|macro|SWITCH_DO_LAZY_FPU
mdefine_line|#define SWITCH_DO_LAZY_FPU
macro_line|#else
DECL|macro|SWITCH_ENTER
mdefine_line|#define SWITCH_ENTER
DECL|macro|SWITCH_EXIT
mdefine_line|#define SWITCH_EXIT
DECL|macro|SWITCH_DO_LAZY_FPU
mdefine_line|#define SWITCH_DO_LAZY_FPU if(last_task_used_math != next) next-&gt;tss.kregs-&gt;psr&amp;=~PSR_EF;
macro_line|#endif
multiline_comment|/* Much care has gone into this code, do not touch it. */
DECL|macro|switch_to
mdefine_line|#define switch_to(prev, next) do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;__label__ here;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;register unsigned long task_pc asm(&quot;o7&quot;);&t;&t;&t;&t;&t;&bslash;&n;&t;SWITCH_ENTER&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;SWITCH_DO_LAZY_FPU&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;__asm__ __volatile__(&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;.globl&bslash;tflush_patch_switch&bslash;nflush_patch_switch:&bslash;n&bslash;t&quot;&t;&t;&t;&t;&bslash;&n;&t;&quot;save %sp, -0x40, %sp; save %sp, -0x40, %sp; save %sp, -0x40, %sp&bslash;n&bslash;t&quot;&t;&t;&bslash;&n;&t;&quot;save %sp, -0x40, %sp; save %sp, -0x40, %sp; save %sp, -0x40, %sp&bslash;n&bslash;t&quot;&t;&t;&bslash;&n;&t;&quot;save %sp, -0x40, %sp&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;restore; restore; restore; restore; restore; restore; restore&quot;);&t;&t;&bslash;&n;&t;if(!(next-&gt;tss.flags &amp; SPARC_FLAG_KTHREAD) &amp;&amp;&t;&t;&t;&t;&t;&bslash;&n;&t;   !(next-&gt;flags &amp; PF_EXITING))&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;switch_to_context(next);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;task_pc = ((unsigned long) &amp;&amp;here) - 0x8;&t;&t;&t;&t;&t;&bslash;&n;&t;__asm__ __volatile__(&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;rd&t;%%psr, %%g4&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;std&t;%%sp, [%%g6 + %3]&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;rd&t;%%wim, %%g5&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;wr&t;%%g4, 0x20, %%psr&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;nop&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;std&t;%%g4, [%%g6 + %2]&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;ldd&t;[%1 + %2], %%g4&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;mov&t;%1, %%g6&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;st&t;%1, [%0]&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;wr&t;%%g4, 0x20, %%psr&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;nop&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;nop&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;ldd&t;[%%g6 + %3], %%sp&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;wr&t;%%g5, 0x0, %%wim&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;ldd&t;[%%sp + 0x00], %%l0&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;ldd&t;[%%sp + 0x38], %%i6&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;wr&t;%%g4, 0x0, %%psr&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;nop&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;nop&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot;jmpl&t;%%o7 + 0x8, %%g0&bslash;n&bslash;t&quot;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&quot; nop&bslash;n&bslash;t&quot; : : &quot;r&quot; (&amp;(current_set[smp_processor_id()])), &quot;r&quot; (next),&t;&t;&bslash;&n;&t;&quot;i&quot; ((const unsigned long)(&amp;((struct task_struct *)0)-&gt;tss.kpsr)),&t;&t;&bslash;&n;&t;&quot;i&quot; ((const unsigned long)(&amp;((struct task_struct *)0)-&gt;tss.ksp)),&t;&t;&bslash;&n;&t;&quot;r&quot; (task_pc) : &quot;g1&quot;, &quot;g2&quot;, &quot;g3&quot;, &quot;g4&quot;, &quot;g5&quot;, &quot;g7&quot;, &quot;l2&quot;, &quot;l3&quot;,&t;&t;&t;&bslash;&n;&t;&quot;l4&quot;, &quot;l5&quot;, &quot;l6&quot;, &quot;l7&quot;, &quot;i0&quot;, &quot;i1&quot;, &quot;i2&quot;, &quot;i3&quot;, &quot;i4&quot;, &quot;i5&quot;, &quot;o0&quot;, &quot;o1&quot;, &quot;o2&quot;,&t;&bslash;&n;&t;&quot;o3&quot;);&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;here: SWITCH_EXIT } while(0)
multiline_comment|/* Changing the IRQ level on the Sparc.   We now avoid writing the psr&n; * whenever possible.&n; */
DECL|function|setipl
r_extern
id|__inline__
r_void
id|setipl
c_func
(paren
r_int
r_int
id|__orig_psr
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|wr
op_mod
l_int|0
comma
l_int|0x0
comma
op_mod
op_mod
id|psr
id|nop
id|nop
id|nop
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
id|__orig_psr
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|function|cli
r_extern
id|__inline__
r_void
id|cli
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|rd
op_mod
op_mod
id|psr
comma
op_mod
l_int|0
id|andcc
op_mod
l_int|0
comma
op_mod
l_int|1
comma
op_mod
op_mod
id|g0
id|bne
l_float|1f
id|nop
id|wr
op_mod
l_int|0
comma
op_mod
l_int|1
comma
op_mod
op_mod
id|psr
id|nop
id|nop
id|nop
l_int|1
suffix:colon
l_string|&quot;&t;&t;: &quot;
op_assign
id|r
"&quot;"
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|PSR_PIL
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|function|sti
r_extern
id|__inline__
r_void
id|sti
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|rd
op_mod
op_mod
id|psr
comma
op_mod
l_int|0
id|andcc
op_mod
l_int|0
comma
op_mod
l_int|1
comma
op_mod
op_mod
id|g0
id|be
l_float|1f
id|nop
id|wr
op_mod
l_int|0
comma
op_mod
l_int|1
comma
op_mod
op_mod
id|psr
id|nop
id|nop
id|nop
l_int|1
suffix:colon
l_string|&quot;&t;&t;: &quot;
op_assign
id|r
"&quot;"
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|PSR_PIL
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|function|getipl
r_extern
id|__inline__
r_int
r_int
id|getipl
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|retval
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rd&t;%%psr, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|retval
)paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|swap_pil
r_extern
id|__inline__
r_int
r_int
id|swap_pil
c_func
(paren
r_int
r_int
id|__new_psr
)paren
(brace
r_int
r_int
id|retval
comma
id|tmp1
comma
id|tmp2
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|rd
op_mod
op_mod
id|psr
comma
op_mod
l_int|0
op_logical_and
op_mod
l_int|0
comma
op_mod
l_int|4
comma
op_mod
l_int|1
op_logical_and
op_mod
l_int|3
comma
op_mod
l_int|4
comma
op_mod
l_int|2
id|xorcc
op_mod
l_int|1
comma
op_mod
l_int|2
comma
op_mod
op_mod
id|g0
id|be
l_float|1f
id|nop
id|wr
op_mod
l_int|0
comma
op_mod
l_int|4
comma
op_mod
op_mod
id|psr
id|nop
id|nop
id|nop
l_int|1
suffix:colon
l_string|&quot;&t;&t;: &quot;
op_assign
id|r
l_string|&quot; (retval), &quot;
op_assign
id|r
l_string|&quot; (tmp1), &quot;
op_assign
id|r
"&quot;"
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|__new_psr
)paren
comma
l_string|&quot;i&quot;
(paren
id|PSR_PIL
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|read_psr_and_cli
r_extern
id|__inline__
r_int
r_int
id|read_psr_and_cli
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|retval
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|rd
op_mod
op_mod
id|psr
comma
op_mod
l_int|0
id|andcc
op_mod
l_int|0
comma
op_mod
l_int|1
comma
op_mod
op_mod
id|g0
id|bne
l_float|1f
id|nop
id|wr
op_mod
l_int|0
comma
op_mod
l_int|1
comma
op_mod
op_mod
id|psr
id|nop
id|nop
id|nop
l_int|1
suffix:colon
l_string|&quot;&t;&t;: &quot;
op_assign
id|r
"&quot;"
(paren
id|retval
)paren
suffix:colon
l_string|&quot;i&quot;
(paren
id|PSR_PIL
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_extern
r_char
id|spdeb_buf
(braket
l_int|256
)braket
suffix:semicolon
DECL|macro|save_flags
mdefine_line|#define save_flags(flags)&t;((flags) = getipl())
DECL|macro|save_and_cli
mdefine_line|#define save_and_cli(flags)&t;((flags) = read_psr_and_cli())
DECL|macro|restore_flags
mdefine_line|#define restore_flags(flags)&t;setipl((flags))
multiline_comment|/* XXX Change this if we ever use a PSO mode kernel. */
DECL|macro|mb
mdefine_line|#define mb()  __asm__ __volatile__ (&quot;&quot; : : : &quot;memory&quot;)
DECL|macro|nop
mdefine_line|#define nop() __asm__ __volatile__ (&quot;nop&quot;);
DECL|function|xchg_u32
r_extern
id|__inline__
r_int
r_int
id|xchg_u32
c_func
(paren
id|__volatile__
r_int
r_int
op_star
id|m
comma
r_int
r_int
id|val
)paren
(brace
r_register
r_int
r_int
op_star
id|ptr
id|asm
c_func
(paren
l_string|&quot;g1&quot;
)paren
suffix:semicolon
r_register
r_int
r_int
id|ret
id|asm
c_func
(paren
l_string|&quot;g2&quot;
)paren
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
id|m
suffix:semicolon
id|ret
op_assign
id|val
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|mov
op_mod
op_mod
id|o7
comma
op_mod
op_mod
id|g4
id|call
id|___xchg32
id|add
op_mod
op_mod
id|o7
comma
l_int|8
comma
op_mod
op_mod
id|o7
l_string|&quot;&t;: &quot;
op_assign
op_amp
id|r
"&quot;"
(paren
id|ret
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|ret
)paren
comma
l_string|&quot;r&quot;
(paren
id|ptr
)paren
suffix:colon
l_string|&quot;g3&quot;
comma
l_string|&quot;g4&quot;
comma
l_string|&quot;g7&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|xchg
mdefine_line|#define xchg(ptr,x) ((__typeof__(*(ptr)))__xchg((unsigned long)(x),(ptr),sizeof(*(ptr))))
DECL|macro|tas
mdefine_line|#define tas(ptr) (xchg((ptr),1))
r_extern
r_void
id|__xchg_called_with_bad_pointer
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|__xchg
r_static
id|__inline__
r_int
r_int
id|__xchg
c_func
(paren
r_int
r_int
id|x
comma
id|__volatile__
r_void
op_star
id|ptr
comma
r_int
id|size
)paren
(brace
r_switch
c_cond
(paren
id|size
)paren
(brace
r_case
l_int|4
suffix:colon
r_return
id|xchg_u32
c_func
(paren
id|ptr
comma
id|x
)paren
suffix:semicolon
)brace
suffix:semicolon
id|__xchg_called_with_bad_pointer
c_func
(paren
)paren
suffix:semicolon
r_return
id|x
suffix:semicolon
)brace
macro_line|#endif /* __ASSEMBLY__ */
macro_line|#endif /* !(__SPARC_SYSTEM_H) */
eof
