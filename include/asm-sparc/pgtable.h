macro_line|#ifndef _SPARC_PGTABLE_H
DECL|macro|_SPARC_PGTABLE_H
mdefine_line|#define _SPARC_PGTABLE_H
multiline_comment|/*  asm-sparc/pgtable.h:  Defines and functions used to work&n; *                        with Sparc page tables.&n; *&n; *  Copyright (C) 1995 David S. Miller (davem@caip.rutgers.edu)&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/asi.h&gt;
macro_line|#include &lt;asm/pgtsun4c.h&gt;
macro_line|#include &lt;asm/pgtsrmmu.h&gt;
r_extern
r_void
id|load_mmu
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
id|pmd_shift
suffix:semicolon
r_extern
r_int
r_int
id|pmd_size
suffix:semicolon
r_extern
r_int
r_int
id|pmd_mask
suffix:semicolon
r_extern
r_int
r_int
(paren
op_star
id|pmd_align
)paren
(paren
r_int
r_int
)paren
suffix:semicolon
r_extern
r_int
r_int
id|pgdir_shift
suffix:semicolon
r_extern
r_int
r_int
id|pgdir_size
suffix:semicolon
r_extern
r_int
r_int
id|pgdir_mask
suffix:semicolon
r_extern
r_int
r_int
(paren
op_star
id|pgdir_align
)paren
(paren
r_int
r_int
)paren
suffix:semicolon
r_extern
r_int
r_int
id|ptrs_per_pte
suffix:semicolon
r_extern
r_int
r_int
id|ptrs_per_pmd
suffix:semicolon
r_extern
r_int
r_int
id|ptrs_per_pgd
suffix:semicolon
r_extern
r_int
r_int
id|ptrs_per_page
suffix:semicolon
r_extern
r_int
r_int
(paren
op_star
(paren
id|vmalloc_start
)paren
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|macro|VMALLOC_VMADDR
mdefine_line|#define VMALLOC_VMADDR(x) ((unsigned long)(x))
DECL|macro|VMALLOC_START
mdefine_line|#define VMALLOC_START vmalloc_start()
r_extern
id|pgprot_t
id|page_none
suffix:semicolon
r_extern
id|pgprot_t
id|page_shared
suffix:semicolon
r_extern
id|pgprot_t
id|page_copy
suffix:semicolon
r_extern
id|pgprot_t
id|page_readonly
suffix:semicolon
r_extern
id|pgprot_t
id|page_kernel
suffix:semicolon
r_extern
id|pgprot_t
id|page_invalid
suffix:semicolon
DECL|macro|PMD_SHIFT
mdefine_line|#define PMD_SHIFT      (pmd_shift)
DECL|macro|PMD_SIZE
mdefine_line|#define PMD_SIZE       (pmd_size)
DECL|macro|PMD_MASK
mdefine_line|#define PMD_MASK       (pmd_mask)
DECL|macro|PMD_ALIGN
mdefine_line|#define PMD_ALIGN      (pmd_align)
DECL|macro|PGDIR_SHIFT
mdefine_line|#define PGDIR_SHIFT    (pgdir_shift)
DECL|macro|PGDIR_SIZE
mdefine_line|#define PGDIR_SIZE     (pgdir_size)
DECL|macro|PGDIR_MASK
mdefine_line|#define PGDIR_MASK     (pgdir_mask)
DECL|macro|PGDIR_ALIGN
mdefine_line|#define PGDIR_ALIGN    (pgdir_align)
DECL|macro|PTRS_PER_PTE
mdefine_line|#define PTRS_PER_PTE   (ptrs_per_pte)
DECL|macro|PTRS_PER_PMD
mdefine_line|#define PTRS_PER_PMD   (ptrs_per_pmd)
DECL|macro|PTRS_PER_PGD
mdefine_line|#define PTRS_PER_PGD   (ptrs_per_pgd)
DECL|macro|PAGE_NONE
mdefine_line|#define PAGE_NONE      (page_none)
DECL|macro|PAGE_SHARED
mdefine_line|#define PAGE_SHARED    (page_shared)
DECL|macro|PAGE_COPY
mdefine_line|#define PAGE_COPY      (page_copy)
DECL|macro|PAGE_READONLY
mdefine_line|#define PAGE_READONLY  (page_readonly)
DECL|macro|PAGE_KERNEL
mdefine_line|#define PAGE_KERNEL    (page_kernel)
DECL|macro|PAGE_INVALID
mdefine_line|#define PAGE_INVALID   (page_invalid)
multiline_comment|/* Top-level page directory */
r_extern
id|pgd_t
id|swapper_pg_dir
(braket
l_int|1024
)braket
suffix:semicolon
multiline_comment|/* Page table for 0-4MB for everybody, on the Sparc this&n; * holds the same as on the i386.&n; */
r_extern
r_int
r_int
id|pg0
(braket
l_int|1024
)braket
suffix:semicolon
r_extern
r_int
r_int
id|ptr_in_current_pgd
suffix:semicolon
multiline_comment|/* the no. of pointers that fit on a page: this will go away */
DECL|macro|PTRS_PER_PAGE
mdefine_line|#define PTRS_PER_PAGE   (PAGE_SIZE/sizeof(void*))
multiline_comment|/* I define these like the i386 does because the check for text or data fault&n; * is done at trap time by the low level handler. Maybe I can set these bits&n; * then once determined. I leave them like this for now though.&n; */
DECL|macro|__P000
mdefine_line|#define __P000  PAGE_NONE
DECL|macro|__P001
mdefine_line|#define __P001  PAGE_READONLY
DECL|macro|__P010
mdefine_line|#define __P010  PAGE_COPY
DECL|macro|__P011
mdefine_line|#define __P011  PAGE_COPY
DECL|macro|__P100
mdefine_line|#define __P100  PAGE_READONLY
DECL|macro|__P101
mdefine_line|#define __P101  PAGE_READONLY
DECL|macro|__P110
mdefine_line|#define __P110  PAGE_COPY
DECL|macro|__P111
mdefine_line|#define __P111  PAGE_COPY
DECL|macro|__S000
mdefine_line|#define __S000&t;PAGE_NONE
DECL|macro|__S001
mdefine_line|#define __S001&t;PAGE_READONLY
DECL|macro|__S010
mdefine_line|#define __S010&t;PAGE_SHARED
DECL|macro|__S011
mdefine_line|#define __S011&t;PAGE_SHARED
DECL|macro|__S100
mdefine_line|#define __S100&t;PAGE_READONLY
DECL|macro|__S101
mdefine_line|#define __S101&t;PAGE_READONLY
DECL|macro|__S110
mdefine_line|#define __S110&t;PAGE_SHARED
DECL|macro|__S111
mdefine_line|#define __S111&t;PAGE_SHARED
multiline_comment|/* Contexts on the Sparc. */
DECL|macro|MAX_CTXS
mdefine_line|#define MAX_CTXS 256
DECL|macro|NO_CTX
mdefine_line|#define NO_CTX   0xffff     /* In tss.context means task has no context currently */
r_extern
r_struct
id|task_struct
op_star
id|ctx_tasks
(braket
id|MAX_CTXS
)braket
suffix:semicolon
r_extern
r_int
id|ctx_tasks_last_frd
suffix:semicolon
r_extern
r_int
id|num_contexts
suffix:semicolon
multiline_comment|/* This routine allocates a new context.  And &squot;p&squot; must not be &squot;current&squot;! */
DECL|function|alloc_mmu_ctx
r_extern
r_inline
r_int
id|alloc_mmu_ctx
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_contexts
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ctx_tasks
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
id|num_contexts
)paren
(brace
id|p-&gt;tss.context
op_assign
id|i
suffix:semicolon
id|ctx_tasks
(braket
id|i
)braket
op_assign
id|p
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* Have to free one up */
id|ctx_tasks_last_frd
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ctx_tasks_last_frd
op_ge
id|num_contexts
)paren
(brace
id|ctx_tasks_last_frd
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Right here is where we invalidate the user mappings that were&n;&t; * present.  TODO&n;&t; */
id|ctx_tasks
(braket
id|ctx_tasks_last_frd
)braket
op_member_access_from_pointer
id|tss.context
op_assign
id|NO_CTX
suffix:semicolon
id|ctx_tasks
(braket
id|ctx_tasks_last_frd
)braket
op_assign
id|p
suffix:semicolon
id|p-&gt;tss.context
op_assign
id|ctx_tasks_last_frd
suffix:semicolon
r_return
id|ctx_tasks_last_frd
suffix:semicolon
)brace
multiline_comment|/*&n; * BAD_PAGETABLE is used when we need a bogus page-table, while&n; * BAD_PAGE is used for a bogus page.&n; *&n; * ZERO_PAGE is a global shared page that is always zero: used&n; * for zero-mapped memory areas etc..&n; */
r_extern
id|pte_t
id|__bad_page
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|pte_t
op_star
id|__bad_pagetable
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
id|__zero_page
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|BAD_PAGETABLE
mdefine_line|#define BAD_PAGETABLE __bad_pagetable()
DECL|macro|BAD_PAGE
mdefine_line|#define BAD_PAGE __bad_page()
DECL|macro|ZERO_PAGE
mdefine_line|#define ZERO_PAGE __zero_page()
multiline_comment|/* number of bits that fit into a memory pointer */
DECL|macro|BITS_PER_PTR
mdefine_line|#define BITS_PER_PTR      (8*sizeof(unsigned long))
multiline_comment|/* to align the pointer to a pointer address */
DECL|macro|PTR_MASK
mdefine_line|#define PTR_MASK          (~(sizeof(void*)-1))
DECL|macro|SIZEOF_PTR_LOG2
mdefine_line|#define SIZEOF_PTR_LOG2   2
r_extern
r_int
r_int
(paren
op_star
id|pte_page
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
r_int
r_int
(paren
op_star
id|pmd_page
)paren
(paren
id|pmd_t
)paren
suffix:semicolon
r_extern
r_int
r_int
(paren
op_star
id|pgd_page
)paren
(paren
id|pgd_t
)paren
suffix:semicolon
multiline_comment|/* to set the page-dir&n; *&n; * On the Sparc the page segments hold 64 pte&squot;s which means 256k/segment.&n; * Therefore there is no global idea of &squot;the&squot; page directory, although we&n; * make a virtual one in kernel memory so that we can keep the stats on&n; * all the pages since not all can be loaded at once in the mmu.&n; *&n; * Actually on the SRMMU things do work exactly like the i386, the&n; * page tables live in real physical ram, no funky TLB buisness.  But&n; * we have to do lots of flushing. And we have to update the root level&n; * page table pointer for this process if it has a context.&n; */
r_extern
r_void
(paren
op_star
id|sparc_update_rootmmu_dir
)paren
(paren
r_struct
id|task_struct
op_star
comma
id|pgd_t
op_star
id|pgdir
)paren
suffix:semicolon
DECL|macro|SET_PAGE_DIR
mdefine_line|#define SET_PAGE_DIR(tsk,pgdir) &bslash;&n;do { sparc_update_rootmmu_dir(tsk, pgdir); } while (0)
multiline_comment|/* to find an entry in a page-table */
DECL|macro|PAGE_PTR
mdefine_line|#define PAGE_PTR(address) &bslash;&n;((unsigned long)(address)&gt;&gt;(PAGE_SHIFT-SIZEOF_PTR_LOG2)&amp;PTR_MASK&amp;~PAGE_MASK)
r_extern
r_int
r_int
id|high_memory
suffix:semicolon
r_extern
r_int
(paren
op_star
id|pte_none
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
r_int
(paren
op_star
id|pte_present
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
r_int
(paren
op_star
id|pte_inuse
)paren
(paren
id|pte_t
op_star
)paren
suffix:semicolon
r_extern
r_void
(paren
op_star
id|pte_clear
)paren
(paren
id|pte_t
op_star
)paren
suffix:semicolon
r_extern
r_void
(paren
op_star
id|pte_reuse
)paren
(paren
id|pte_t
op_star
)paren
suffix:semicolon
r_extern
r_int
(paren
op_star
id|pmd_none
)paren
(paren
id|pmd_t
)paren
suffix:semicolon
r_extern
r_int
(paren
op_star
id|pmd_bad
)paren
(paren
id|pmd_t
)paren
suffix:semicolon
r_extern
r_int
(paren
op_star
id|pmd_present
)paren
(paren
id|pmd_t
)paren
suffix:semicolon
r_extern
r_int
(paren
op_star
id|pmd_inuse
)paren
(paren
id|pmd_t
op_star
)paren
suffix:semicolon
r_extern
r_void
(paren
op_star
id|pmd_clear
)paren
(paren
id|pmd_t
op_star
)paren
suffix:semicolon
r_extern
r_void
(paren
op_star
id|pmd_reuse
)paren
(paren
id|pmd_t
op_star
)paren
suffix:semicolon
r_extern
r_int
(paren
op_star
id|pgd_none
)paren
(paren
id|pgd_t
)paren
suffix:semicolon
r_extern
r_int
(paren
op_star
id|pgd_bad
)paren
(paren
id|pgd_t
)paren
suffix:semicolon
r_extern
r_int
(paren
op_star
id|pgd_present
)paren
(paren
id|pgd_t
)paren
suffix:semicolon
r_extern
r_int
(paren
op_star
id|pgd_inuse
)paren
(paren
id|pgd_t
op_star
)paren
suffix:semicolon
r_extern
r_void
(paren
op_star
id|pgd_clear
)paren
(paren
id|pgd_t
op_star
)paren
suffix:semicolon
r_extern
r_void
(paren
op_star
id|pgd_reuse
)paren
(paren
id|pgd_t
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * The following only work if pte_present() is true.&n; * Undefined behaviour if not..&n; */
r_extern
r_int
(paren
op_star
id|pte_read
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
r_int
(paren
op_star
id|pte_write
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
r_int
(paren
op_star
id|pte_exec
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
r_int
(paren
op_star
id|pte_dirty
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
r_int
(paren
op_star
id|pte_young
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
r_int
(paren
op_star
id|pte_cow
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
id|pte_t
(paren
op_star
id|pte_wrprotect
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
id|pte_t
(paren
op_star
id|pte_rdprotect
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
id|pte_t
(paren
op_star
id|pte_exprotect
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
id|pte_t
(paren
op_star
id|pte_mkclean
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
id|pte_t
(paren
op_star
id|pte_mkold
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
id|pte_t
(paren
op_star
id|pte_uncow
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
id|pte_t
(paren
op_star
id|pte_mkwrite
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
id|pte_t
(paren
op_star
id|pte_mkread
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
id|pte_t
(paren
op_star
id|pte_mkexec
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
id|pte_t
(paren
op_star
id|pte_mkdirty
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
id|pte_t
(paren
op_star
id|pte_mkyoung
)paren
(paren
id|pte_t
)paren
suffix:semicolon
r_extern
id|pte_t
(paren
op_star
id|pte_mkcow
)paren
(paren
id|pte_t
)paren
suffix:semicolon
multiline_comment|/*&n; * Conversion functions: convert a page and protection to a page entry,&n; * and a page entry and page directory to the page they refer to.&n; */
r_extern
id|pte_t
(paren
op_star
id|mk_pte
)paren
(paren
r_int
r_int
comma
id|pgprot_t
)paren
suffix:semicolon
r_extern
r_void
(paren
op_star
id|pgd_set
)paren
(paren
id|pgd_t
op_star
comma
id|pte_t
op_star
)paren
suffix:semicolon
r_extern
id|pte_t
(paren
op_star
id|pte_modify
)paren
(paren
id|pte_t
comma
id|pgprot_t
)paren
suffix:semicolon
multiline_comment|/* to find an entry in a page-table-directory */
r_extern
id|pgd_t
op_star
(paren
op_star
id|pgd_offset
)paren
(paren
r_struct
id|task_struct
op_star
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* Find an entry in the second-level page table.. */
r_extern
id|pmd_t
op_star
(paren
op_star
id|pmd_offset
)paren
(paren
id|pgd_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* Find an entry in the third-level page table.. */
r_extern
id|pte_t
op_star
(paren
op_star
id|pte_offset
)paren
(paren
id|pmd_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * Allocate and free page tables. The xxx_kernel() versions are&n; * used to allocate a kernel page table - this turns on ASN bits&n; * if any, and marks the page tables reserved.&n; */
r_extern
r_void
(paren
op_star
id|pte_free_kernel
)paren
(paren
id|pte_t
op_star
)paren
suffix:semicolon
r_extern
id|pte_t
op_star
(paren
op_star
id|pte_alloc_kernel
)paren
(paren
id|pmd_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * allocating and freeing a pmd is trivial: the 1-entry pmd is&n; * inside the pgd, so has no extra memory associated with it.&n; */
r_extern
r_void
(paren
op_star
id|pmd_free_kernel
)paren
(paren
id|pmd_t
op_star
)paren
suffix:semicolon
r_extern
id|pmd_t
op_star
(paren
op_star
id|pmd_alloc_kernel
)paren
(paren
id|pgd_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
(paren
op_star
id|pte_free
)paren
(paren
id|pte_t
op_star
)paren
suffix:semicolon
r_extern
id|pte_t
op_star
(paren
op_star
id|pte_alloc
)paren
(paren
id|pmd_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * allocating and freeing a pmd is trivial: the 1-entry pmd is&n; * inside the pgd, so has no extra memory associated with it.&n; */
r_extern
r_void
(paren
op_star
id|pmd_free
)paren
(paren
id|pmd_t
op_star
)paren
suffix:semicolon
r_extern
id|pmd_t
op_star
(paren
op_star
id|pmd_alloc
)paren
(paren
id|pgd_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
(paren
op_star
id|pgd_free
)paren
(paren
id|pgd_t
op_star
)paren
suffix:semicolon
multiline_comment|/* A page directory on the sun4c needs 16k, thus we request an order of&n; * two.&n; *&n; * I need 16k for a sun4c page table, so I use kmalloc since kmalloc_init()&n; * is called before pgd_alloc ever is (I think).&n; */
r_extern
id|pgd_t
op_star
(paren
op_star
id|pgd_alloc
)paren
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|invalid_segment
suffix:semicolon
multiline_comment|/* Sun4c specific routines.  They can stay inlined. */
DECL|function|alloc_sun4c_pseg
r_extern
r_inline
r_int
id|alloc_sun4c_pseg
c_func
(paren
r_void
)paren
(brace
r_int
id|oldseg
comma
id|i
suffix:semicolon
multiline_comment|/* First see if any are free already */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PSEG_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|phys_seg_map
(braket
id|i
)braket
op_eq
id|PSEG_AVL
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* Uh-oh, gotta unallocate a TLB pseg */
id|oldseg
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PSEG_ENTRIES
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Can not touch PSEG_KERNEL and PSEG_RSV segmaps */
r_if
c_cond
(paren
id|phys_seg_map
(braket
id|i
)braket
op_ne
id|PSEG_USED
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* Ok, take a look at it&squot;s lifespan */
id|oldseg
op_assign
(paren
id|phys_seg_life
(braket
id|i
)braket
OG
id|oldseg
)paren
ques
c_cond
id|phys_seg_life
(braket
id|i
)braket
suffix:colon
id|oldseg
suffix:semicolon
)brace
id|phys_seg_life
(braket
id|oldseg
)braket
op_assign
id|PSEG_BORN
suffix:semicolon
r_return
id|oldseg
suffix:semicolon
)brace
multiline_comment|/* Age all psegs except pseg_skip */
DECL|function|age_sun4c_psegs
r_extern
r_inline
r_void
id|age_sun4c_psegs
c_func
(paren
r_int
id|pseg_skip
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pseg_skip
suffix:semicolon
id|i
op_increment
)paren
(brace
id|phys_seg_life
(braket
id|i
)braket
op_increment
suffix:semicolon
)brace
id|i
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|PSEG_ENTRIES
)paren
(brace
id|phys_seg_life
(braket
id|i
op_increment
)braket
op_increment
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * This is only ever called when the sun4c page fault routines run&n; * so we can keep this here as the srmmu code will never get to it.&n; */
DECL|function|update_mmu_cache
r_extern
r_inline
r_void
id|update_mmu_cache
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
id|pte_t
id|pte
)paren
(brace
r_int
r_int
id|clr_addr
suffix:semicolon
r_int
id|segmap
suffix:semicolon
id|segmap
op_assign
(paren
r_int
)paren
id|get_segmap
c_func
(paren
id|address
op_amp
id|SUN4C_REAL_PGDIR_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|segmap
op_eq
id|invalid_segment
)paren
(brace
id|segmap
op_assign
id|alloc_sun4c_pseg
c_func
(paren
)paren
suffix:semicolon
id|put_segmap
c_func
(paren
(paren
id|address
op_amp
id|SUN4C_REAL_PGDIR_MASK
)paren
comma
id|segmap
)paren
suffix:semicolon
id|phys_seg_map
(braket
id|segmap
)braket
op_assign
id|PSEG_USED
suffix:semicolon
multiline_comment|/* We got a segmap, clear all the pte&squot;s in it. */
r_for
c_loop
(paren
id|clr_addr
op_assign
(paren
id|address
op_amp
id|SUN4C_REAL_PGDIR_MASK
)paren
suffix:semicolon
id|clr_addr
OL
(paren
(paren
id|address
op_amp
id|SUN4C_REAL_PGDIR_MASK
)paren
op_plus
id|SUN4C_REAL_PGDIR_SIZE
)paren
suffix:semicolon
id|clr_addr
op_add_assign
id|PAGE_SIZE
)paren
(brace
id|put_pte
c_func
(paren
id|clr_addr
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Do aging */
id|age_sun4c_psegs
c_func
(paren
id|segmap
)paren
suffix:semicolon
id|put_pte
c_func
(paren
(paren
id|address
op_amp
id|PAGE_MASK
)paren
comma
id|pte_val
c_func
(paren
id|pte
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* !(_SPARC_PGTABLE_H) */
eof
