macro_line|#ifndef _M68K_STRING_H_
DECL|macro|_M68K_STRING_H_
mdefine_line|#define _M68K_STRING_H_
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/page.h&gt;
DECL|macro|__HAVE_ARCH_STRCPY
mdefine_line|#define __HAVE_ARCH_STRCPY
DECL|function|strcpy
r_static
r_inline
r_char
op_star
id|strcpy
c_func
(paren
r_char
op_star
id|dest
comma
r_const
r_char
op_star
id|src
)paren
(brace
r_char
op_star
id|xdest
op_assign
id|dest
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;1:&bslash;tmoveb %1@+,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;jne 1b&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|dest
)paren
comma
l_string|&quot;=a&quot;
(paren
id|src
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|dest
)paren
comma
l_string|&quot;1&quot;
(paren
id|src
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|xdest
suffix:semicolon
)brace
DECL|macro|__HAVE_ARCH_STRNCPY
mdefine_line|#define __HAVE_ARCH_STRNCPY
DECL|function|strncpy
r_static
r_inline
r_char
op_star
id|strncpy
c_func
(paren
r_char
op_star
id|dest
comma
r_const
r_char
op_star
id|src
comma
r_int
id|n
)paren
(brace
r_char
op_star
id|xdest
op_assign
id|dest
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|0
)paren
r_return
id|xdest
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;1:&bslash;tmoveb %1@+,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;jeq 2f&bslash;n&bslash;t&quot;
l_string|&quot;subql #1,%2&bslash;n&bslash;t&quot;
l_string|&quot;jne 1b&bslash;n&bslash;t&quot;
l_string|&quot;2:&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|dest
)paren
comma
l_string|&quot;=a&quot;
(paren
id|src
)paren
comma
l_string|&quot;=d&quot;
(paren
id|n
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|dest
)paren
comma
l_string|&quot;1&quot;
(paren
id|src
)paren
comma
l_string|&quot;2&quot;
(paren
id|n
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|xdest
suffix:semicolon
)brace
DECL|macro|__HAVE_ARCH_STRCAT
mdefine_line|#define __HAVE_ARCH_STRCAT
DECL|function|strcat
r_static
r_inline
r_char
op_star
id|strcat
c_func
(paren
r_char
op_star
id|dest
comma
r_const
r_char
op_star
id|src
)paren
(brace
r_char
op_star
id|tmp
op_assign
id|dest
suffix:semicolon
r_while
c_loop
(paren
op_star
id|dest
)paren
id|dest
op_increment
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|dest
op_increment
op_assign
op_star
id|src
op_increment
)paren
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
DECL|macro|__HAVE_ARCH_STRNCAT
mdefine_line|#define __HAVE_ARCH_STRNCAT
DECL|function|strncat
r_static
r_inline
r_char
op_star
id|strncat
c_func
(paren
r_char
op_star
id|dest
comma
r_const
r_char
op_star
id|src
comma
r_int
id|count
)paren
(brace
r_char
op_star
id|tmp
op_assign
id|dest
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
r_while
c_loop
(paren
op_star
id|dest
)paren
id|dest
op_increment
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|dest
op_increment
op_assign
op_star
id|src
op_increment
)paren
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|count
op_eq
l_int|0
)paren
(brace
op_star
id|dest
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_return
id|tmp
suffix:semicolon
)brace
DECL|macro|__HAVE_ARCH_STRCHR
mdefine_line|#define __HAVE_ARCH_STRCHR
DECL|function|strchr
r_static
r_inline
r_char
op_star
id|strchr
c_func
(paren
r_const
r_char
op_star
id|s
comma
r_int
id|c
)paren
(brace
r_const
r_char
id|ch
op_assign
id|c
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
op_star
id|s
op_ne
id|ch
suffix:semicolon
op_increment
id|s
)paren
r_if
c_cond
(paren
op_star
id|s
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
(paren
r_char
op_star
)paren
id|s
suffix:semicolon
)brace
DECL|macro|__HAVE_ARCH_STRPBRK
mdefine_line|#define __HAVE_ARCH_STRPBRK
DECL|function|strpbrk
r_static
r_inline
r_char
op_star
id|strpbrk
c_func
(paren
r_const
r_char
op_star
id|cs
comma
r_const
r_char
op_star
id|ct
)paren
(brace
r_const
r_char
op_star
id|sc1
comma
op_star
id|sc2
suffix:semicolon
r_for
c_loop
(paren
id|sc1
op_assign
id|cs
suffix:semicolon
op_star
id|sc1
op_ne
l_char|&squot;&bslash;0&squot;
suffix:semicolon
op_increment
id|sc1
)paren
r_for
c_loop
(paren
id|sc2
op_assign
id|ct
suffix:semicolon
op_star
id|sc2
op_ne
l_char|&squot;&bslash;0&squot;
suffix:semicolon
op_increment
id|sc2
)paren
r_if
c_cond
(paren
op_star
id|sc1
op_eq
op_star
id|sc2
)paren
r_return
(paren
r_char
op_star
)paren
id|sc1
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|macro|__HAVE_ARCH_STRSPN
mdefine_line|#define __HAVE_ARCH_STRSPN
DECL|function|strspn
r_static
r_inline
r_int
id|strspn
c_func
(paren
r_const
r_char
op_star
id|s
comma
r_const
r_char
op_star
id|accept
)paren
(brace
r_const
r_char
op_star
id|p
suffix:semicolon
r_const
r_char
op_star
id|a
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|s
suffix:semicolon
op_star
id|p
op_ne
l_char|&squot;&bslash;0&squot;
suffix:semicolon
op_increment
id|p
)paren
(brace
r_for
c_loop
(paren
id|a
op_assign
id|accept
suffix:semicolon
op_star
id|a
op_ne
l_char|&squot;&bslash;0&squot;
suffix:semicolon
op_increment
id|a
)paren
r_if
c_cond
(paren
op_star
id|p
op_eq
op_star
id|a
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_star
id|a
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
id|count
suffix:semicolon
r_else
op_increment
id|count
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|macro|__HAVE_ARCH_STRTOK
mdefine_line|#define __HAVE_ARCH_STRTOK
DECL|function|strtok
r_static
r_inline
r_char
op_star
id|strtok
c_func
(paren
r_char
op_star
id|s
comma
r_const
r_char
op_star
id|ct
)paren
(brace
r_char
op_star
id|sbegin
comma
op_star
id|send
suffix:semicolon
id|sbegin
op_assign
id|s
ques
c_cond
id|s
suffix:colon
id|___strtok
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sbegin
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|sbegin
op_add_assign
id|strspn
c_func
(paren
id|sbegin
comma
id|ct
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|sbegin
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|___strtok
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|send
op_assign
id|strpbrk
c_func
(paren
id|sbegin
comma
id|ct
)paren
suffix:semicolon
r_if
c_cond
(paren
id|send
op_logical_and
op_star
id|send
op_ne
l_char|&squot;&bslash;0&squot;
)paren
op_star
id|send
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|___strtok
op_assign
id|send
suffix:semicolon
r_return
(paren
id|sbegin
)paren
suffix:semicolon
)brace
multiline_comment|/* strstr !! */
DECL|macro|__HAVE_ARCH_STRLEN
mdefine_line|#define __HAVE_ARCH_STRLEN
DECL|function|strlen
r_static
r_inline
r_int
id|strlen
c_func
(paren
r_const
r_char
op_star
id|s
)paren
(brace
r_const
r_char
op_star
id|sc
suffix:semicolon
r_for
c_loop
(paren
id|sc
op_assign
id|s
suffix:semicolon
op_star
id|sc
op_ne
l_char|&squot;&bslash;0&squot;
suffix:semicolon
op_increment
id|sc
)paren
suffix:semicolon
r_return
id|sc
op_minus
id|s
suffix:semicolon
)brace
multiline_comment|/* strnlen !! */
DECL|macro|__HAVE_ARCH_STRCMP
mdefine_line|#define __HAVE_ARCH_STRCMP
DECL|function|strcmp
r_static
r_inline
r_int
id|strcmp
c_func
(paren
r_const
r_char
op_star
id|cs
comma
r_const
r_char
op_star
id|ct
)paren
(brace
r_char
id|__res
suffix:semicolon
id|__asm__
(paren
l_string|&quot;1:&bslash;tmoveb %0@+,%2&bslash;n&bslash;t&quot;
multiline_comment|/* get *cs */
l_string|&quot;cmpb %1@+,%2&bslash;n&bslash;t&quot;
multiline_comment|/* compare a byte */
l_string|&quot;jne  2f&bslash;n&bslash;t&quot;
multiline_comment|/* not equal, break out */
l_string|&quot;tstb %2&bslash;n&bslash;t&quot;
multiline_comment|/* at end of cs? */
l_string|&quot;jne  1b&bslash;n&bslash;t&quot;
multiline_comment|/* no, keep going */
l_string|&quot;jra  3f&bslash;n&bslash;t&quot;
multiline_comment|/* strings are equal */
l_string|&quot;2:&bslash;tsubb %1@-,%2&bslash;n&bslash;t&quot;
multiline_comment|/* *cs - *ct */
l_string|&quot;3:&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|cs
)paren
comma
l_string|&quot;=a&quot;
(paren
id|ct
)paren
comma
l_string|&quot;=d&quot;
(paren
id|__res
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|cs
)paren
comma
l_string|&quot;1&quot;
(paren
id|ct
)paren
)paren
suffix:semicolon
r_return
id|__res
suffix:semicolon
)brace
DECL|macro|__HAVE_ARCH_STRNCMP
mdefine_line|#define __HAVE_ARCH_STRNCMP
DECL|function|strncmp
r_static
r_inline
r_int
id|strncmp
c_func
(paren
r_const
r_char
op_star
id|cs
comma
r_const
r_char
op_star
id|ct
comma
r_int
id|count
)paren
(brace
r_char
id|__res
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_return
l_int|0
suffix:semicolon
id|__asm__
(paren
l_string|&quot;1:&bslash;tmovb %0@+,%3&bslash;n&bslash;t&quot;
multiline_comment|/* get *cs */
l_string|&quot;cmpb   %1@+,%3&bslash;n&bslash;t&quot;
multiline_comment|/* compare a byte */
l_string|&quot;jne    3f&bslash;n&bslash;t&quot;
multiline_comment|/* not equal, break out */
l_string|&quot;tstb   %3&bslash;n&bslash;t&quot;
multiline_comment|/* at end of cs? */
l_string|&quot;jeq    4f&bslash;n&bslash;t&quot;
multiline_comment|/* yes, all done */
l_string|&quot;subql  #1,%2&bslash;n&bslash;t&quot;
multiline_comment|/* no, adjust count */
l_string|&quot;jne    1b&bslash;n&bslash;t&quot;
multiline_comment|/* more to do, keep going */
l_string|&quot;2:&bslash;tmoveq #0,%3&bslash;n&bslash;t&quot;
multiline_comment|/* strings are equal */
l_string|&quot;jra    4f&bslash;n&bslash;t&quot;
l_string|&quot;3:&bslash;tsubb %1@-,%3&bslash;n&bslash;t&quot;
multiline_comment|/* *cs - *ct */
l_string|&quot;4:&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|cs
)paren
comma
l_string|&quot;=a&quot;
(paren
id|ct
)paren
comma
l_string|&quot;=d&quot;
(paren
id|count
)paren
comma
l_string|&quot;=d&quot;
(paren
id|__res
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|cs
)paren
comma
l_string|&quot;1&quot;
(paren
id|ct
)paren
comma
l_string|&quot;2&quot;
(paren
id|count
)paren
)paren
suffix:semicolon
r_return
id|__res
suffix:semicolon
)brace
DECL|macro|__HAVE_ARCH_MEMSET
mdefine_line|#define __HAVE_ARCH_MEMSET
multiline_comment|/*&n; * This is really ugly, but its highly optimizatiable by the&n; * compiler and is meant as compensation for gcc&squot;s missing&n; * __builtin_memset(). For the 680[23]0&t;it might be worth considering&n; * the optimal number of misaligned writes compared to the number of&n; * tests&squot;n&squot;branches needed to align the destination address. The&n; * 680[46]0 doesn&squot;t really care due to their copy-back caches.&n; *&t;&t;&t;&t;&t;&t;10/09/96 - Jes Sorensen&n; */
DECL|function|__memset_g
r_static
r_inline
r_void
op_star
id|__memset_g
c_func
(paren
r_void
op_star
id|s
comma
r_int
id|c
comma
r_int
id|count
)paren
(brace
r_void
op_star
id|xs
op_assign
id|s
suffix:semicolon
r_int
id|temp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_return
id|xs
suffix:semicolon
id|c
op_and_assign
l_int|0xff
suffix:semicolon
id|c
op_or_assign
id|c
op_lshift
l_int|8
suffix:semicolon
id|c
op_or_assign
id|c
op_lshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|36
)paren
(brace
r_int
op_star
id|ls
op_assign
id|s
suffix:semicolon
r_switch
c_cond
(paren
id|count
)paren
(brace
r_case
l_int|32
suffix:colon
r_case
l_int|33
suffix:colon
r_case
l_int|34
suffix:colon
r_case
l_int|35
suffix:colon
op_star
id|ls
op_increment
op_assign
id|c
suffix:semicolon
r_case
l_int|28
suffix:colon
r_case
l_int|29
suffix:colon
r_case
l_int|30
suffix:colon
r_case
l_int|31
suffix:colon
op_star
id|ls
op_increment
op_assign
id|c
suffix:semicolon
r_case
l_int|24
suffix:colon
r_case
l_int|25
suffix:colon
r_case
l_int|26
suffix:colon
r_case
l_int|27
suffix:colon
op_star
id|ls
op_increment
op_assign
id|c
suffix:semicolon
r_case
l_int|20
suffix:colon
r_case
l_int|21
suffix:colon
r_case
l_int|22
suffix:colon
r_case
l_int|23
suffix:colon
op_star
id|ls
op_increment
op_assign
id|c
suffix:semicolon
r_case
l_int|16
suffix:colon
r_case
l_int|17
suffix:colon
r_case
l_int|18
suffix:colon
r_case
l_int|19
suffix:colon
op_star
id|ls
op_increment
op_assign
id|c
suffix:semicolon
r_case
l_int|12
suffix:colon
r_case
l_int|13
suffix:colon
r_case
l_int|14
suffix:colon
r_case
l_int|15
suffix:colon
op_star
id|ls
op_increment
op_assign
id|c
suffix:semicolon
r_case
l_int|8
suffix:colon
r_case
l_int|9
suffix:colon
r_case
l_int|10
suffix:colon
r_case
l_int|11
suffix:colon
op_star
id|ls
op_increment
op_assign
id|c
suffix:semicolon
r_case
l_int|4
suffix:colon
r_case
l_int|5
suffix:colon
r_case
l_int|6
suffix:colon
r_case
l_int|7
suffix:colon
op_star
id|ls
op_increment
op_assign
id|c
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|s
op_assign
id|ls
suffix:semicolon
r_if
c_cond
(paren
id|count
op_amp
l_int|0x02
)paren
(brace
r_int
op_star
id|ss
op_assign
id|s
suffix:semicolon
op_star
id|ss
op_increment
op_assign
id|c
suffix:semicolon
id|s
op_assign
id|ss
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_amp
l_int|0x01
)paren
(brace
r_char
op_star
id|cs
op_assign
id|s
suffix:semicolon
op_star
id|cs
op_increment
op_assign
id|c
suffix:semicolon
id|s
op_assign
id|cs
suffix:semicolon
)brace
r_return
id|xs
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|s
op_amp
l_int|1
)paren
(brace
r_char
op_star
id|cs
op_assign
id|s
suffix:semicolon
op_star
id|cs
op_increment
op_assign
id|c
suffix:semicolon
id|s
op_assign
id|cs
suffix:semicolon
id|count
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OG
l_int|2
op_logical_and
(paren
r_int
)paren
id|s
op_amp
l_int|2
)paren
(brace
r_int
op_star
id|ss
op_assign
id|s
suffix:semicolon
op_star
id|ss
op_increment
op_assign
id|c
suffix:semicolon
id|s
op_assign
id|ss
suffix:semicolon
id|count
op_sub_assign
l_int|2
suffix:semicolon
)brace
id|temp
op_assign
id|count
op_rshift
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|temp
)paren
(brace
r_int
op_star
id|ls
op_assign
id|s
suffix:semicolon
id|temp
op_decrement
suffix:semicolon
r_do
op_star
id|ls
op_increment
op_assign
id|c
suffix:semicolon
r_while
c_loop
(paren
id|temp
op_decrement
)paren
suffix:semicolon
id|s
op_assign
id|ls
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_amp
l_int|2
)paren
(brace
r_int
op_star
id|ss
op_assign
id|s
suffix:semicolon
op_star
id|ss
op_increment
op_assign
id|c
suffix:semicolon
id|s
op_assign
id|ss
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_amp
l_int|1
)paren
(brace
r_char
op_star
id|cs
op_assign
id|s
suffix:semicolon
op_star
id|cs
op_assign
id|c
suffix:semicolon
)brace
r_return
id|xs
suffix:semicolon
)brace
multiline_comment|/*&n; * __memset_page assumes that data is longword aligned. Most, if not&n; * all, of these page sized memsets are performed on page aligned&n; * areas, thus we do not need to check if the destination is longword&n; * aligned. Of course we suffer a serious performance loss if this is&n; * not the case but I think the risk of this ever happening is&n; * extremely small. We spend a lot of time clearing pages in&n; * get_empty_page() so I think it is worth it anyway. Besides, the&n; * 680[46]0 do not really care about misaligned writes due to their&n; * copy-back cache.&n; *&n; * The optimized case for the 680[46]0 is implemented using the move16&n; * instruction. My tests showed that this implementation is 35-45%&n; * faster than the original implementation using movel, the only&n; * caveat is that the destination address must be 16-byte aligned.&n; *                                            01/09/96 - Jes Sorensen&n; */
DECL|function|__memset_page
r_static
r_inline
r_void
op_star
id|__memset_page
c_func
(paren
r_void
op_star
id|s
comma
r_int
id|c
comma
r_int
id|count
)paren
(brace
r_int
r_int
id|data
comma
id|tmp
suffix:semicolon
r_void
op_star
id|xs
comma
op_star
id|sp
suffix:semicolon
id|xs
op_assign
id|sp
op_assign
id|s
suffix:semicolon
id|c
op_assign
id|c
op_amp
l_int|255
suffix:semicolon
id|data
op_assign
id|c
op_or
(paren
id|c
op_lshift
l_int|8
)paren
suffix:semicolon
id|data
op_or_assign
id|data
op_lshift
l_int|16
suffix:semicolon
macro_line|#ifdef CPU_M68040_OR_M68060_ONLY
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|s
)paren
op_amp
l_int|0x0f
)paren
id|memset
c_func
(paren
id|s
comma
id|c
comma
id|count
)paren
suffix:semicolon
r_else
(brace
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
)paren
)paren
op_increment
op_assign
id|data
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
)paren
)paren
op_increment
op_assign
id|data
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
)paren
)paren
op_increment
op_assign
id|data
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
)paren
)paren
op_increment
op_assign
id|data
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&bslash;t&quot;
l_string|&quot;.chip 68040&bslash;n&bslash;t&quot;
l_string|&quot;move16 %2@+,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;.chip 68k&bslash;n&bslash;t&quot;
l_string|&quot;subqw  #8,%2&bslash;n&bslash;t&quot;
l_string|&quot;subqw  #8,%2&bslash;n&bslash;t&quot;
l_string|&quot;dbra   %1,1b&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|s
)paren
comma
l_string|&quot;=d&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
id|sp
)paren
comma
l_string|&quot;0&quot;
(paren
id|s
)paren
comma
l_string|&quot;1&quot;
(paren
(paren
id|count
op_minus
l_int|16
)paren
op_div
l_int|16
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
macro_line|#else
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&bslash;t&quot;
l_string|&quot;movel %2,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;movel %2,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;movel %2,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;movel %2,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;movel %2,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;movel %2,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;movel %2,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;movel %2,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;dbra  %1,1b&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|s
)paren
comma
l_string|&quot;=d&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;d&quot;
(paren
id|data
)paren
comma
l_string|&quot;0&quot;
(paren
id|s
)paren
comma
l_string|&quot;1&quot;
(paren
id|count
op_div
l_int|32
op_minus
l_int|1
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|xs
suffix:semicolon
)brace
DECL|macro|__memset_const
mdefine_line|#define __memset_const(s,c,count) &bslash;&n;((count==PAGE_SIZE) ? &bslash;&n;  __memset_page((s),(c),(count)) : &bslash;&n;  __memset_g((s),(c),(count)))
DECL|macro|memset
mdefine_line|#define memset(s, c, count) &bslash;&n;(__builtin_constant_p(count) ? &bslash;&n; __memset_const((s),(c),(count)) : &bslash;&n; memset((s),(c),(count)))
DECL|macro|__HAVE_ARCH_MEMCPY
mdefine_line|#define __HAVE_ARCH_MEMCPY
multiline_comment|/*&n; * __builtin_memcpy() does not handle page-sized memcpys very well,&n; * thus following the same assumptions as for page-sized memsets, this&n; * function copies page-sized areas using an unrolled loop, without&n; * considering alignment.&n; *&n; * For the 680[46]0 only kernels we use the move16 instruction instead&n; * as it writes through the data-cache, invalidating the cache-lines&n; * touched. In this way we do not use up the entire data-cache (well,&n; * half of it on the 68060) by copying a page. An unrolled loop of two&n; * move16 instructions seem to the fastest. The only caveat is that&n; * both source and destination must be 16-byte aligned, if not we fall&n; * back to the generic memcpy function.  - Jes&n; */
DECL|function|__memcpy_page
r_static
r_inline
r_void
op_star
id|__memcpy_page
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
id|count
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_void
op_star
id|xto
op_assign
id|to
suffix:semicolon
macro_line|#ifdef CPU_M68040_OR_M68060_ONLY
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|to
op_or
(paren
r_int
r_int
)paren
id|from
)paren
op_amp
l_int|0x0f
)paren
r_return
id|memcpy
c_func
(paren
id|to
comma
id|from
comma
id|count
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&bslash;t&quot;
l_string|&quot;.chip 68040&bslash;n&bslash;t&quot;
l_string|&quot;move16 %1@+,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;move16 %1@+,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;.chip 68k&bslash;n&bslash;t&quot;
l_string|&quot;dbra  %2,1b&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|to
)paren
comma
l_string|&quot;=a&quot;
(paren
id|from
)paren
comma
l_string|&quot;=d&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|to
)paren
comma
l_string|&quot;1&quot;
(paren
id|from
)paren
comma
l_string|&quot;2&quot;
(paren
id|count
op_div
l_int|32
op_minus
l_int|1
)paren
)paren
suffix:semicolon
macro_line|#else
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&bslash;t&quot;
l_string|&quot;movel %1@+,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;movel %1@+,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;movel %1@+,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;movel %1@+,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;movel %1@+,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;movel %1@+,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;movel %1@+,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;movel %1@+,%0@+&bslash;n&bslash;t&quot;
l_string|&quot;dbra  %2,1b&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|to
)paren
comma
l_string|&quot;=a&quot;
(paren
id|from
)paren
comma
l_string|&quot;=d&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|to
)paren
comma
l_string|&quot;1&quot;
(paren
id|from
)paren
comma
l_string|&quot;2&quot;
(paren
id|count
op_div
l_int|32
op_minus
l_int|1
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|xto
suffix:semicolon
)brace
DECL|macro|__memcpy_const
mdefine_line|#define __memcpy_const(to, from, n) &bslash;&n;((n==PAGE_SIZE) ? &bslash;&n;  __memcpy_page((to),(from),(n)) : &bslash;&n;  __builtin_memcpy((to),(from),(n)))
DECL|macro|memcpy
mdefine_line|#define memcpy(to, from, n) &bslash;&n;(__builtin_constant_p(n) ? &bslash;&n; __memcpy_const((to),(from),(n)) : &bslash;&n; memcpy((to),(from),(n)))
DECL|macro|__HAVE_ARCH_MEMMOVE
mdefine_line|#define __HAVE_ARCH_MEMMOVE
DECL|function|memmove
r_static
r_inline
r_void
op_star
id|memmove
c_func
(paren
r_void
op_star
id|dest
comma
r_const
r_void
op_star
id|src
comma
r_int
id|n
)paren
(brace
r_void
op_star
id|xdest
op_assign
id|dest
suffix:semicolon
r_int
id|temp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
id|xdest
suffix:semicolon
r_if
c_cond
(paren
id|dest
OL
id|src
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|dest
op_amp
l_int|1
)paren
(brace
r_char
op_star
id|cdest
op_assign
id|dest
suffix:semicolon
r_const
r_char
op_star
id|csrc
op_assign
id|src
suffix:semicolon
op_star
id|cdest
op_increment
op_assign
op_star
id|csrc
op_increment
suffix:semicolon
id|dest
op_assign
id|cdest
suffix:semicolon
id|src
op_assign
id|csrc
suffix:semicolon
id|n
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
OG
l_int|2
op_logical_and
(paren
r_int
)paren
id|dest
op_amp
l_int|2
)paren
(brace
r_int
op_star
id|sdest
op_assign
id|dest
suffix:semicolon
r_const
r_int
op_star
id|ssrc
op_assign
id|src
suffix:semicolon
op_star
id|sdest
op_increment
op_assign
op_star
id|ssrc
op_increment
suffix:semicolon
id|dest
op_assign
id|sdest
suffix:semicolon
id|src
op_assign
id|ssrc
suffix:semicolon
id|n
op_sub_assign
l_int|2
suffix:semicolon
)brace
id|temp
op_assign
id|n
op_rshift
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|temp
)paren
(brace
r_int
op_star
id|ldest
op_assign
id|dest
suffix:semicolon
r_const
r_int
op_star
id|lsrc
op_assign
id|src
suffix:semicolon
id|temp
op_decrement
suffix:semicolon
r_do
op_star
id|ldest
op_increment
op_assign
op_star
id|lsrc
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|temp
op_decrement
)paren
suffix:semicolon
id|dest
op_assign
id|ldest
suffix:semicolon
id|src
op_assign
id|lsrc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
op_amp
l_int|2
)paren
(brace
r_int
op_star
id|sdest
op_assign
id|dest
suffix:semicolon
r_const
r_int
op_star
id|ssrc
op_assign
id|src
suffix:semicolon
op_star
id|sdest
op_increment
op_assign
op_star
id|ssrc
op_increment
suffix:semicolon
id|dest
op_assign
id|sdest
suffix:semicolon
id|src
op_assign
id|ssrc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
op_amp
l_int|1
)paren
(brace
r_char
op_star
id|cdest
op_assign
id|dest
suffix:semicolon
r_const
r_char
op_star
id|csrc
op_assign
id|src
suffix:semicolon
op_star
id|cdest
op_assign
op_star
id|csrc
suffix:semicolon
)brace
)brace
r_else
(brace
id|dest
op_assign
(paren
r_char
op_star
)paren
id|dest
op_plus
id|n
suffix:semicolon
id|src
op_assign
(paren
r_const
r_char
op_star
)paren
id|src
op_plus
id|n
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|dest
op_amp
l_int|1
)paren
(brace
r_char
op_star
id|cdest
op_assign
id|dest
suffix:semicolon
r_const
r_char
op_star
id|csrc
op_assign
id|src
suffix:semicolon
op_star
op_decrement
id|cdest
op_assign
op_star
op_decrement
id|csrc
suffix:semicolon
id|dest
op_assign
id|cdest
suffix:semicolon
id|src
op_assign
id|csrc
suffix:semicolon
id|n
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
OG
l_int|2
op_logical_and
(paren
r_int
)paren
id|dest
op_amp
l_int|2
)paren
(brace
r_int
op_star
id|sdest
op_assign
id|dest
suffix:semicolon
r_const
r_int
op_star
id|ssrc
op_assign
id|src
suffix:semicolon
op_star
op_decrement
id|sdest
op_assign
op_star
op_decrement
id|ssrc
suffix:semicolon
id|dest
op_assign
id|sdest
suffix:semicolon
id|src
op_assign
id|ssrc
suffix:semicolon
id|n
op_sub_assign
l_int|2
suffix:semicolon
)brace
id|temp
op_assign
id|n
op_rshift
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|temp
)paren
(brace
r_int
op_star
id|ldest
op_assign
id|dest
suffix:semicolon
r_const
r_int
op_star
id|lsrc
op_assign
id|src
suffix:semicolon
id|temp
op_decrement
suffix:semicolon
r_do
op_star
op_decrement
id|ldest
op_assign
op_star
op_decrement
id|lsrc
suffix:semicolon
r_while
c_loop
(paren
id|temp
op_decrement
)paren
suffix:semicolon
id|dest
op_assign
id|ldest
suffix:semicolon
id|src
op_assign
id|lsrc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
op_amp
l_int|2
)paren
(brace
r_int
op_star
id|sdest
op_assign
id|dest
suffix:semicolon
r_const
r_int
op_star
id|ssrc
op_assign
id|src
suffix:semicolon
op_star
op_decrement
id|sdest
op_assign
op_star
op_decrement
id|ssrc
suffix:semicolon
id|dest
op_assign
id|sdest
suffix:semicolon
id|src
op_assign
id|ssrc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
op_amp
l_int|1
)paren
(brace
r_char
op_star
id|cdest
op_assign
id|dest
suffix:semicolon
r_const
r_char
op_star
id|csrc
op_assign
id|src
suffix:semicolon
op_star
op_decrement
id|cdest
op_assign
op_star
op_decrement
id|csrc
suffix:semicolon
)brace
)brace
r_return
id|xdest
suffix:semicolon
)brace
DECL|macro|__HAVE_ARCH_MEMCMP
mdefine_line|#define __HAVE_ARCH_MEMCMP
DECL|macro|memcmp
mdefine_line|#define memcmp(cs, ct, n) &bslash;&n;(__builtin_constant_p(n) ? &bslash;&n; __builtin_memcmp((cs),(ct),(n)) : &bslash;&n; memcmp((cs),(ct),(n)))
macro_line|#endif /* _M68K_STRING_H_ */
eof
