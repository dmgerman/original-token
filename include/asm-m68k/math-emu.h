macro_line|#ifndef _ASM_M68K_SETUP_H
DECL|macro|_ASM_M68K_SETUP_H
mdefine_line|#define _ASM_M68K_SETUP_H
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;linux/linkage.h&gt;
multiline_comment|/* Status Register bits */
multiline_comment|/* accrued exception bits */
DECL|macro|FPSR_AEXC_INEX
mdefine_line|#define FPSR_AEXC_INEX&t;3
DECL|macro|FPSR_AEXC_DZ
mdefine_line|#define FPSR_AEXC_DZ&t;4
DECL|macro|FPSR_AEXC_UNFL
mdefine_line|#define FPSR_AEXC_UNFL&t;5
DECL|macro|FPSR_AEXC_OVFL
mdefine_line|#define FPSR_AEXC_OVFL&t;6
DECL|macro|FPSR_AEXC_IOP
mdefine_line|#define FPSR_AEXC_IOP&t;7
multiline_comment|/* exception status bits */
DECL|macro|FPSR_EXC_INEX1
mdefine_line|#define FPSR_EXC_INEX1&t;8
DECL|macro|FPSR_EXC_INEX2
mdefine_line|#define FPSR_EXC_INEX2&t;9
DECL|macro|FPSR_EXC_DZ
mdefine_line|#define FPSR_EXC_DZ&t;10
DECL|macro|FPSR_EXC_UNFL
mdefine_line|#define FPSR_EXC_UNFL&t;11
DECL|macro|FPSR_EXC_OVFL
mdefine_line|#define FPSR_EXC_OVFL&t;12
DECL|macro|FPSR_EXC_OPERR
mdefine_line|#define FPSR_EXC_OPERR&t;13
DECL|macro|FPSR_EXC_SNAN
mdefine_line|#define FPSR_EXC_SNAN&t;14
DECL|macro|FPSR_EXC_BSUN
mdefine_line|#define FPSR_EXC_BSUN&t;15
multiline_comment|/* quotient byte, assumes big-endian, of course */
DECL|macro|FPSR_QUOTIENT
mdefine_line|#define FPSR_QUOTIENT(fpsr) (*((signed char *) &amp;(fpsr) + 1))
multiline_comment|/* condition code bits */
DECL|macro|FPSR_CC_NAN
mdefine_line|#define FPSR_CC_NAN&t;24
DECL|macro|FPSR_CC_INF
mdefine_line|#define FPSR_CC_INF&t;25
DECL|macro|FPSR_CC_Z
mdefine_line|#define FPSR_CC_Z&t;26
DECL|macro|FPSR_CC_NEG
mdefine_line|#define FPSR_CC_NEG&t;27
multiline_comment|/* Control register bits */
multiline_comment|/* rounding mode */
DECL|macro|FPCR_ROUND_RN
mdefine_line|#define&t;FPCR_ROUND_RN&t;0&t;&t;/* round to nearest/even */
DECL|macro|FPCR_ROUND_RZ
mdefine_line|#define FPCR_ROUND_RZ&t;1&t;&t;/* round to zero */
DECL|macro|FPCR_ROUND_RM
mdefine_line|#define FPCR_ROUND_RM&t;2&t;&t;/* minus infinity */
DECL|macro|FPCR_ROUND_RP
mdefine_line|#define FPCR_ROUND_RP&t;3&t;&t;/* plus infinity */
multiline_comment|/* rounding precision */
DECL|macro|FPCR_PRECISION_X
mdefine_line|#define FPCR_PRECISION_X&t;0&t;/* long double */
DECL|macro|FPCR_PRECISION_S
mdefine_line|#define FPCR_PRECISION_S&t;1&t;/* double */
DECL|macro|FPCR_PRECISION_D
mdefine_line|#define FPCR_PRECISION_D&t;2&t;/* float */
multiline_comment|/* Flags to select the debugging output */
DECL|macro|PDECODE
mdefine_line|#define PDECODE&t;&t;0
DECL|macro|PEXECUTE
mdefine_line|#define PEXECUTE&t;1
DECL|macro|PCONV
mdefine_line|#define PCONV&t;&t;2
DECL|macro|PNORM
mdefine_line|#define PNORM&t;&t;3
DECL|macro|PREGISTER
mdefine_line|#define PREGISTER&t;4
DECL|macro|PINSTR
mdefine_line|#define PINSTR&t;&t;5
DECL|macro|PUNIMPL
mdefine_line|#define PUNIMPL&t;&t;6
DECL|macro|PMOVEM
mdefine_line|#define PMOVEM&t;&t;7
DECL|macro|PMDECODE
mdefine_line|#define PMDECODE&t;(1&lt;&lt;PDECODE)
DECL|macro|PMEXECUTE
mdefine_line|#define PMEXECUTE&t;(1&lt;&lt;PEXECUTE)
DECL|macro|PMCONV
mdefine_line|#define PMCONV&t;&t;(1&lt;&lt;PCONV)
DECL|macro|PMNORM
mdefine_line|#define PMNORM&t;&t;(1&lt;&lt;PNORM)
DECL|macro|PMREGISTER
mdefine_line|#define PMREGISTER&t;(1&lt;&lt;PREGISTER)
DECL|macro|PMINSTR
mdefine_line|#define PMINSTR&t;&t;(1&lt;&lt;PINSTR)
DECL|macro|PMUNIMPL
mdefine_line|#define PMUNIMPL&t;(1&lt;&lt;PUNIMPL)
DECL|macro|PMMOVEM
mdefine_line|#define PMMOVEM&t;&t;(1&lt;&lt;PMOVEM)
macro_line|#ifndef __ASSEMBLY__
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
DECL|union|fp_mant64
r_union
id|fp_mant64
(brace
DECL|member|m64
r_int
r_int
r_int
id|m64
suffix:semicolon
DECL|member|m32
r_int
r_int
id|m32
(braket
l_int|2
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|union|fp_mant128
r_union
id|fp_mant128
(brace
DECL|member|m64
r_int
r_int
r_int
id|m64
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|m32
r_int
r_int
id|m32
(braket
l_int|4
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* internal representation of extended fp numbers */
DECL|struct|fp_ext
r_struct
id|fp_ext
(brace
DECL|member|lowmant
r_int
r_char
id|lowmant
suffix:semicolon
DECL|member|sign
r_int
r_char
id|sign
suffix:semicolon
DECL|member|exp
r_int
r_int
id|exp
suffix:semicolon
DECL|member|mant
r_union
id|fp_mant64
id|mant
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* C representation of FPU registers */
multiline_comment|/* NOTE: if you change this, you have to change the assembler offsets&n;   below and the size in &lt;asm/fpu.h&gt;, too */
DECL|struct|fp_data
r_struct
id|fp_data
(brace
DECL|member|fpreg
r_struct
id|fp_ext
id|fpreg
(braket
l_int|8
)braket
suffix:semicolon
DECL|member|fpcr
r_int
r_int
id|fpcr
suffix:semicolon
DECL|member|fpsr
r_int
r_int
id|fpsr
suffix:semicolon
DECL|member|fpiar
r_int
r_int
id|fpiar
suffix:semicolon
DECL|member|prec
r_int
r_int
id|prec
suffix:semicolon
DECL|member|rnd
r_int
r_int
id|rnd
suffix:semicolon
DECL|member|temp
r_struct
id|fp_ext
id|temp
(braket
l_int|2
)braket
suffix:semicolon
)brace
suffix:semicolon
macro_line|#if FPU_EMU_DEBUG
r_extern
r_int
r_int
id|fp_debugprint
suffix:semicolon
DECL|macro|dprint
mdefine_line|#define dprint(bit, fmt, args...) ({&t;&t;&t;&bslash;&n;&t;if (fp_debugprint &amp; (1 &lt;&lt; (bit)))&t;&t;&bslash;&n;&t;&t;printk(fmt, ## args);&t;&t;&t;&bslash;&n;})
macro_line|#else
DECL|macro|dprint
mdefine_line|#define dprint(bit, fmt, args...)
macro_line|#endif
DECL|macro|uprint
mdefine_line|#define uprint(str) ({&t;&t;&t;&t;&t;&bslash;&n;&t;static int __count = 3;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (__count &gt; 0) {&t;&t;&t;&t;&bslash;&n;&t;&t;printk(&quot;You just hit an unimplemented &quot;&t;&bslash;&n;&t;&t;       &quot;fpu instruction (%s)&bslash;n&quot;, str);&t;&bslash;&n;&t;&t;printk(&quot;Please report this to ....&bslash;n&quot;);&t;&bslash;&n;&t;&t;__count--;&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&bslash;&n;})
DECL|macro|FPDATA
mdefine_line|#define FPDATA&t;&t;((struct fp_data *)current-&gt;thread.fp)
macro_line|#else&t;/* __ASSEMBLY__ */
DECL|macro|FPDATA
mdefine_line|#define FPDATA&t;&t;%a2
multiline_comment|/* offsets from the base register to the floating point data in the task struct */
DECL|macro|FPD_FPREG
mdefine_line|#define FPD_FPREG&t;(TASK_THREAD+THREAD_FPREG+0)
DECL|macro|FPD_FPCR
mdefine_line|#define FPD_FPCR&t;(TASK_THREAD+THREAD_FPREG+96)
DECL|macro|FPD_FPSR
mdefine_line|#define FPD_FPSR&t;(TASK_THREAD+THREAD_FPREG+100)
DECL|macro|FPD_FPIAR
mdefine_line|#define FPD_FPIAR&t;(TASK_THREAD+THREAD_FPREG+104)
DECL|macro|FPD_PREC
mdefine_line|#define FPD_PREC&t;(TASK_THREAD+THREAD_FPREG+108)
DECL|macro|FPD_RND
mdefine_line|#define FPD_RND&t;&t;(TASK_THREAD+THREAD_FPREG+110)
DECL|macro|FPD_TEMPFP1
mdefine_line|#define FPD_TEMPFP1&t;(TASK_THREAD+THREAD_FPREG+112)
DECL|macro|FPD_TEMPFP2
mdefine_line|#define FPD_TEMPFP2&t;(TASK_THREAD+THREAD_FPREG+124)
DECL|macro|FPD_SIZEOF
mdefine_line|#define FPD_SIZEOF&t;(TASK_THREAD+THREAD_FPREG+136)
multiline_comment|/* offsets on the stack to access saved registers,&n; * these are only used during instruction decoding&n; * where we always know how deep we&squot;re on the stack.&n; */
DECL|macro|FPS_DO
mdefine_line|#define FPS_DO&t;&t;(PT_D0)
DECL|macro|FPS_D1
mdefine_line|#define FPS_D1&t;&t;(PT_D1)
DECL|macro|FPS_D2
mdefine_line|#define FPS_D2&t;&t;(PT_D2)
DECL|macro|FPS_A0
mdefine_line|#define FPS_A0&t;&t;(PT_A0)
DECL|macro|FPS_A1
mdefine_line|#define FPS_A1&t;&t;(PT_A1)
DECL|macro|FPS_A2
mdefine_line|#define FPS_A2&t;&t;(PT_A2)
DECL|macro|FPS_SR
mdefine_line|#define FPS_SR&t;&t;(PT_SR)
DECL|macro|FPS_PC
mdefine_line|#define FPS_PC&t;&t;(PT_PC)
DECL|macro|FPS_EA
mdefine_line|#define FPS_EA&t;&t;(PT_PC+6)
DECL|macro|FPS_PC2
mdefine_line|#define FPS_PC2&t;&t;(PT_PC+10)
dot
id|macro
id|fp_get_fp_reg
id|lea
(paren
id|FPD_FPREG
comma
id|FPDATA
comma
op_mod
id|d0.w
op_star
l_int|4
)paren
comma
op_mod
id|a0
id|lea
(paren
op_mod
id|a0
comma
op_mod
id|d0.w
op_star
l_int|8
)paren
comma
op_mod
id|a0
dot
id|endm
multiline_comment|/* Macros used to get/put the current program counter.&n; * 020/030 use a different stack frame then 040/060, for the&n; * 040/060 the return pc points already to the next location,&n; * so this only needs to be modified for jump instructions.&n; */
dot
id|macro
id|fp_get_pc
id|dest
id|move.l
(paren
id|FPS_PC
op_plus
l_int|4
comma
op_mod
id|sp
)paren
comma
"&bslash;"
id|dest
dot
id|endm
DECL|variable|jump
dot
id|macro
id|fp_put_pc
id|src
comma
id|jump
op_assign
l_int|0
DECL|variable|FPS_PC
id|move.l
"&bslash;"
id|src
comma
(paren
id|FPS_PC
op_plus
l_int|4
comma
op_mod
id|sp
)paren
dot
id|endm
DECL|variable|s
DECL|variable|dest
dot
id|macro
id|fp_get_instr_data
id|f
comma
id|s
comma
id|dest
comma
id|label
DECL|variable|f
id|getuser
"&bslash;"
id|f
comma
op_mod
id|sp
"@"
(paren
id|FPS_PC
op_plus
l_int|4
)paren
"@"
(paren
l_int|0
)paren
comma
"&bslash;"
id|dest
comma
"&bslash;"
id|label
comma
op_mod
id|sp
"@"
(paren
id|FPS_PC
op_plus
l_int|4
)paren
id|addq.l
macro_line|#&bslash;s,%sp@(FPS_PC+4)
dot
id|endm
DECL|variable|label
dot
id|macro
id|fp_get_instr_word
id|dest
comma
id|label
comma
id|addr
DECL|variable|w
DECL|variable|dest
DECL|variable|label
id|fp_get_instr_data
id|w
comma
l_int|2
comma
"&bslash;"
id|dest
comma
"&bslash;"
id|label
comma
"&bslash;"
id|addr
dot
id|endm
DECL|variable|label
dot
id|macro
id|fp_get_instr_long
id|dest
comma
id|label
comma
id|addr
DECL|variable|l
DECL|variable|dest
DECL|variable|label
id|fp_get_instr_data
id|l
comma
l_int|4
comma
"&bslash;"
id|dest
comma
"&bslash;"
id|label
comma
"&bslash;"
id|addr
dot
id|endm
multiline_comment|/* These macros are used to read from/write to user space&n; * on error we jump to the fixup section, load the fault&n; * address into %a0 and jump to the exit.&n; * (derived from &lt;asm/uaccess.h&gt;)&n; */
DECL|variable|src
DECL|variable|dest
DECL|variable|label
dot
id|macro
id|getuser
id|size
comma
id|src
comma
id|dest
comma
id|label
comma
id|addr
DECL|variable|printf
op_or
id|printf
comma
l_string|&quot;[&bslash;size&lt;%08x]&quot;
comma
l_int|1
comma
"&bslash;"
id|addr
dot
id|Lu1
"&bslash;@"
suffix:colon
id|moves
"&bslash;"
id|size
"&bslash;"
id|src
comma
"&bslash;"
id|dest
dot
id|section
dot
id|fixup
comma
l_string|&quot;ax&quot;
dot
id|even
dot
id|Lu2
"&bslash;@"
suffix:colon
id|move.l
"&bslash;"
id|addr
comma
op_mod
id|a0
id|jra
"&bslash;"
id|label
dot
id|previous
dot
id|section
id|__ex_table
comma
l_string|&quot;a&quot;
dot
id|align
l_int|4
dot
r_int
dot
id|Lu1
"&bslash;@"
comma
dot
id|Lu2
"&bslash;@"
dot
id|previous
dot
id|endm
DECL|variable|src
DECL|variable|dest
DECL|variable|label
dot
id|macro
id|putuser
id|size
comma
id|src
comma
id|dest
comma
id|label
comma
id|addr
DECL|variable|printf
op_or
id|printf
comma
l_string|&quot;[&bslash;size&gt;%08x]&quot;
comma
l_int|1
comma
"&bslash;"
id|addr
dot
id|Lu1
"&bslash;@"
suffix:colon
id|moves
"&bslash;"
id|size
"&bslash;"
id|src
comma
"&bslash;"
id|dest
dot
id|Lu2
"&bslash;@"
suffix:colon
dot
id|section
dot
id|fixup
comma
l_string|&quot;ax&quot;
dot
id|even
dot
id|Lu3
"&bslash;@"
suffix:colon
id|move.l
"&bslash;"
id|addr
comma
op_mod
id|a0
id|jra
"&bslash;"
id|label
dot
id|previous
dot
id|section
id|__ex_table
comma
l_string|&quot;a&quot;
dot
id|align
l_int|4
dot
r_int
dot
id|Lu1
"&bslash;@"
comma
dot
id|Lu3
"&bslash;@"
dot
r_int
dot
id|Lu2
"&bslash;@"
comma
dot
id|Lu3
"&bslash;@"
dot
id|previous
dot
id|endm
DECL|variable|arg1
DECL|variable|arg2
DECL|variable|arg3
DECL|variable|arg4
dot
id|macro
id|movestack
id|nr
comma
id|arg1
comma
id|arg2
comma
id|arg3
comma
id|arg4
comma
id|arg5
dot
r_if
c_cond
"&bslash;"
id|nr
id|movestack
(paren
"&bslash;"
id|nr
op_minus
l_int|1
)paren
comma
"&bslash;"
id|arg2
comma
"&bslash;"
id|arg3
comma
"&bslash;"
id|arg4
comma
"&bslash;"
id|arg5
id|move.l
"&bslash;"
id|arg1
comma
op_minus
(paren
op_mod
id|sp
)paren
dot
id|endif
dot
id|endm
DECL|variable|string
DECL|variable|nr
DECL|variable|arg1
DECL|variable|arg2
DECL|variable|arg3
DECL|variable|arg4
dot
id|macro
id|printf
id|bit
op_assign
op_minus
l_int|1
comma
id|string
comma
id|nr
op_assign
l_int|0
comma
id|arg1
comma
id|arg2
comma
id|arg3
comma
id|arg4
comma
id|arg5
macro_line|#ifdef FPU_EMU_DEBUG
dot
id|data
dot
id|Lpdata
"&bslash;@"
suffix:colon
dot
id|string
l_string|&quot;&bslash;string&quot;
dot
id|previous
id|movem.l
op_mod
id|d0
op_div
op_mod
id|d1
op_div
op_mod
id|a0
op_div
op_mod
id|a1
comma
op_minus
(paren
op_mod
id|sp
)paren
dot
r_if
c_cond
"&bslash;"
id|bit
op_plus
l_int|1
macro_line|#if 0
id|moveq
macro_line|#&bslash;bit,%d0
id|andw
macro_line|#7,%d0
id|btst
op_mod
id|d0
comma
id|fp_debugprint
op_plus
(paren
(paren
l_int|31
op_minus
"&bslash;"
id|bit
)paren
op_div
l_int|8
)paren
macro_line|#else
id|btst
macro_line|#&bslash;bit,fp_debugprint+((31-&bslash;bit)/8)
macro_line|#endif
id|jeq
dot
id|Lpskip
"&bslash;@"
dot
id|endif
DECL|variable|arg1
DECL|variable|arg2
DECL|variable|arg3
DECL|variable|arg4
id|movestack
"&bslash;"
id|nr
comma
"&bslash;"
id|arg1
comma
"&bslash;"
id|arg2
comma
"&bslash;"
id|arg3
comma
"&bslash;"
id|arg4
comma
"&bslash;"
id|arg5
id|pea
dot
id|Lpdata
"&bslash;@"
id|jsr
id|printk
id|lea
(paren
(paren
"&bslash;"
id|nr
op_plus
l_int|1
)paren
op_star
l_int|4
comma
op_mod
id|sp
)paren
comma
op_mod
id|sp
dot
id|Lpskip
"&bslash;@"
suffix:colon
id|movem.l
(paren
op_mod
id|sp
)paren
op_plus
comma
op_mod
id|d0
op_div
op_mod
id|d1
op_div
op_mod
id|a0
op_div
op_mod
id|a1
macro_line|#endif
dot
id|endm
dot
id|macro
id|printx
id|bit
comma
id|fp
macro_line|#ifdef FPU_EMU_DEBUG
id|movem.l
op_mod
id|d0
op_div
op_mod
id|a0
comma
op_minus
(paren
op_mod
id|sp
)paren
id|lea
"&bslash;"
id|fp
comma
op_mod
id|a0
macro_line|#if 0
id|moveq
macro_line|#&squot;+&squot;,%d0
id|tst.w
(paren
op_mod
id|a0
)paren
id|jeq
dot
id|Lx1
"&bslash;@"
id|moveq
macro_line|#&squot;-&squot;,%d0
dot
id|Lx1
"&bslash;@"
suffix:colon
id|printf
"&bslash;"
id|bit
comma
l_string|&quot; %c&quot;
comma
l_int|1
comma
op_mod
id|d0
id|move.l
(paren
l_int|4
comma
op_mod
id|a0
)paren
comma
op_mod
id|d0
id|bclr
macro_line|#31,%d0
id|jne
dot
id|Lx2
"&bslash;@"
id|printf
"&bslash;"
id|bit
comma
l_string|&quot;0.&quot;
id|jra
dot
id|Lx3
"&bslash;@"
dot
id|Lx2
"&bslash;@"
suffix:colon
id|printf
"&bslash;"
id|bit
comma
l_string|&quot;1.&quot;
dot
id|Lx3
"&bslash;@"
suffix:colon
id|printf
"&bslash;"
id|bit
comma
l_string|&quot;%08x%08x&quot;
comma
l_int|2
comma
op_mod
id|d0
comma
op_mod
id|a0
"@"
(paren
l_int|8
)paren
id|move.w
(paren
l_int|2
comma
op_mod
id|a0
)paren
comma
op_mod
id|d0
id|ext.l
op_mod
id|d0
id|printf
"&bslash;"
id|bit
comma
l_string|&quot;E%04x&quot;
comma
l_int|1
comma
op_mod
id|d0
macro_line|#else
DECL|variable|bit
DECL|variable|a0
id|printf
"&bslash;"
id|bit
comma
l_string|&quot; %08x%08x%08x&quot;
comma
l_int|3
comma
op_mod
id|a0
"@"
comma
op_mod
id|a0
"@"
(paren
l_int|4
)paren
comma
op_mod
id|a0
"@"
(paren
l_int|8
)paren
macro_line|#endif
id|movem.l
(paren
op_mod
id|sp
)paren
op_plus
comma
op_mod
id|d0
op_div
op_mod
id|a0
macro_line|#endif
dot
id|endm
dot
id|macro
id|debug
id|instr
comma
id|args
macro_line|#ifdef FPU_EMU_DEBUG
"&bslash;"
id|instr
"&bslash;"
id|args
macro_line|#endif
dot
id|endm
macro_line|#endif&t;/* __ASSEMBLY__ */
macro_line|#endif&t;/* _ASM_M68K_SETUP_H */
eof
