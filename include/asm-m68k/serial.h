multiline_comment|/*&n; * include/linux/serial.h&n; *&n; * Copyright (C) 1992 by Theodore Ts&squot;o.&n; * &n; * Redistribution of this file is permitted under the terms of the GNU &n; * Public License (GPL)&n; */
macro_line|#ifndef _M68K_SERIAL_H
DECL|macro|_M68K_SERIAL_H
mdefine_line|#define _M68K_SERIAL_H
multiline_comment|/* m68k serial port types are numbered from 100 to avoid interference&n; * with the PC types (1..4)&n; */
DECL|macro|PORT_UNKNOWN
mdefine_line|#define PORT_UNKNOWN&t;0
DECL|macro|PORT_8250
mdefine_line|#define PORT_8250&t;1
DECL|macro|PORT_16450
mdefine_line|#define PORT_16450&t;2
DECL|macro|PORT_16550
mdefine_line|#define PORT_16550&t;3
DECL|macro|PORT_16550A
mdefine_line|#define PORT_16550A&t;4
DECL|macro|PORT_CIRRUS
mdefine_line|#define PORT_CIRRUS     5
DECL|macro|PORT_16650V2
mdefine_line|#define PORT_16650V2&t;7
DECL|macro|PORT_16750
mdefine_line|#define PORT_16750&t;8
DECL|macro|SER_SCC_NORM
mdefine_line|#define SER_SCC_NORM&t;100&t;/* standard SCC channel */
DECL|macro|SER_SCC_DMA
mdefine_line|#define&t;SER_SCC_DMA&t;101&t;/* SCC channel with DMA support */
DECL|macro|SER_MFP_CTRL
mdefine_line|#define&t;SER_MFP_CTRL&t;102&t;/* standard MFP port with modem control signals */
DECL|macro|SER_MFP_BARE
mdefine_line|#define&t;SER_MFP_BARE&t;103&t;/* MFP port without modem controls */
DECL|macro|SER_MIDI
mdefine_line|#define&t;SER_MIDI&t;104&t;/* Atari MIDI */
DECL|macro|SER_AMIGA
mdefine_line|#define&t;SER_AMIGA&t;105&t;/* Amiga built-in serial port */
DECL|macro|SER_IOEXT
mdefine_line|#define SER_IOEXT&t;106&t;/* Amiga GVP IO-Extender (16c552) */
DECL|macro|SER_MFC_III
mdefine_line|#define SER_MFC_III&t;107&t;/* Amiga BSC Multiface Card III (MC68681) */
DECL|macro|SER_WHIPPET
mdefine_line|#define SER_WHIPPET&t;108&t;/* Amiga Hisoft Whippet PCMCIA (16c550B) */
DECL|macro|SER_SCC_MVME
mdefine_line|#define SER_SCC_MVME&t;109&t;/* MVME162/MVME172 ports */
DECL|macro|SER_SCC_MAC
mdefine_line|#define SER_SCC_MAC&t;110&t;/* Macintosh SCC channel */
DECL|macro|SER_HPDCA
mdefine_line|#define SER_HPDCA&t;111&t;/* HP DCA serial */
DECL|macro|SER_SCC_BVME
mdefine_line|#define SER_SCC_BVME&t;112&t;/* BVME6000 ports */
DECL|struct|serial_struct
r_struct
id|serial_struct
(brace
DECL|member|type
r_int
id|type
suffix:semicolon
DECL|member|line
r_int
id|line
suffix:semicolon
DECL|member|port
r_int
id|port
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
DECL|member|xmit_fifo_size
r_int
id|xmit_fifo_size
suffix:semicolon
DECL|member|custom_divisor
r_int
id|custom_divisor
suffix:semicolon
DECL|member|baud_base
r_int
id|baud_base
suffix:semicolon
DECL|member|close_delay
r_int
r_int
id|close_delay
suffix:semicolon
DECL|member|reserved_char
r_char
id|reserved_char
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|hub6
r_int
id|hub6
suffix:semicolon
DECL|member|closing_wait
r_int
r_int
id|closing_wait
suffix:semicolon
multiline_comment|/* time to wait before closing */
DECL|member|closing_wait2
r_int
r_int
id|closing_wait2
suffix:semicolon
multiline_comment|/* no longer used... */
DECL|member|reserved
r_int
id|reserved
(braket
l_int|4
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * For the close wait times, 0 means wait forever for serial port to&n; * flush its output.  65535 means don&squot;t wait at all.&n; */
DECL|macro|ASYNC_CLOSING_WAIT_INF
mdefine_line|#define ASYNC_CLOSING_WAIT_INF&t;0
DECL|macro|ASYNC_CLOSING_WAIT_NONE
mdefine_line|#define ASYNC_CLOSING_WAIT_NONE&t;65535
multiline_comment|/* This function tables does the abstraction from the underlying&n; * hardware:&n; *&n; *   init(): Initialize the port as necessary, set RTS and DTR and&n; *      enable interrupts. It does not need to set the speed and other&n; *      parameters, because change_speed() is called, too.&n; *   deinit(): Stop and shutdown the port (e.g. disable interrupts, ...)&n; *   enab_tx_int(): Enable or disable the Tx Buffer Empty interrupt&n; *      independently from other interrupt sources. If the int is&n; *      enabled, the transmitter should also be restarted, i.e. if there&n; *      are any chars to be sent, they should be put into the Tx&n; *      register. The real en/disabling of the interrupt may be a no-op&n; *      if there is no way to do this or it is too complex. This Tx ints&n; *      are just disabled to save some interrupts if the transmitter is&n; *      stopped anyway. But the restarting must be implemented!&n; *   check_custom_divisor(): Check the given custom divisor for legality&n; *      and return 0 if OK, non-zero otherwise.&n; *   change_speed(): Set port speed, character size, number of stop&n; *      bits and parity from the termios structure. If the user wants&n; *      to set the speed with a custom divisor, he is required to&n; *      check the baud_base first!&n; *   throttle(): Set or clear the RTS line according to &squot;status&squot;.&n; *   set_break(): Set or clear the &squot;Send a Break&squot; flag.&n; *   get_serial_info(): Fill in the baud_base and custom_divisor&n; *      fields of a serial_struct. It may also modify other fields, if&n; *      needed.&n; *   get_modem_info(): Return the status of RTS, DTR, DCD, RI, DSR and CTS.&n; *   set_modem_info(): Set the status of RTS and DTR according to&n; *      &squot;new_dtr&squot; and &squot;new_rts&squot;, resp. 0 = clear, 1 = set, -1 = don&squot;t change&n; *   ioctl(): Process any port-specific ioctl&squot;s. This pointer may be&n; *      NULL, if the port has no own ioctl&squot;s.&n; *   stop_receive(): Turn off the Rx part of the port, so no more characters&n; *      will be received. This is called before shutting the port down.&n; *   trans_empty(): Return !=0 if there are no more characters still to be&n; *      sent out (Tx buffer register and FIFOs empty)&n; *   check_open(): Is called before the port is opened. The driver can check&n; *      if that&squot;s ok and return an error code, or keep track of the opening&n; *      even before init() is called. Use deinit() for matching closing of the&n; *      port.&n; *&n; */
r_struct
id|m68k_async_struct
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|init
r_void
(paren
op_star
id|init
)paren
(paren
r_struct
id|m68k_async_struct
op_star
id|info
)paren
suffix:semicolon
DECL|member|deinit
r_void
(paren
op_star
id|deinit
)paren
(paren
r_struct
id|m68k_async_struct
op_star
id|info
comma
r_int
id|leave_dtr
)paren
suffix:semicolon
DECL|member|enab_tx_int
r_void
(paren
op_star
id|enab_tx_int
)paren
(paren
r_struct
id|m68k_async_struct
op_star
id|info
comma
r_int
id|enab_flag
)paren
suffix:semicolon
DECL|member|check_custom_divisor
r_int
(paren
op_star
id|check_custom_divisor
)paren
(paren
r_struct
id|m68k_async_struct
op_star
id|info
comma
r_int
id|baud_base
comma
r_int
id|divisor
)paren
suffix:semicolon
DECL|member|change_speed
r_void
(paren
op_star
id|change_speed
)paren
(paren
r_struct
id|m68k_async_struct
op_star
id|info
)paren
suffix:semicolon
DECL|member|throttle
r_void
(paren
op_star
id|throttle
)paren
(paren
r_struct
id|m68k_async_struct
op_star
id|info
comma
r_int
id|status
)paren
suffix:semicolon
DECL|member|set_break
r_void
(paren
op_star
id|set_break
)paren
(paren
r_struct
id|m68k_async_struct
op_star
id|info
comma
r_int
id|break_flag
)paren
suffix:semicolon
DECL|member|get_serial_info
r_void
(paren
op_star
id|get_serial_info
)paren
(paren
r_struct
id|m68k_async_struct
op_star
id|info
comma
r_struct
id|serial_struct
op_star
id|retinfo
)paren
suffix:semicolon
DECL|member|get_modem_info
r_int
r_int
(paren
op_star
id|get_modem_info
)paren
(paren
r_struct
id|m68k_async_struct
op_star
id|info
)paren
suffix:semicolon
DECL|member|set_modem_info
r_int
(paren
op_star
id|set_modem_info
)paren
(paren
r_struct
id|m68k_async_struct
op_star
id|info
comma
r_int
id|new_dtr
comma
r_int
id|new_rts
)paren
suffix:semicolon
DECL|member|ioctl
r_int
(paren
op_star
id|ioctl
)paren
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_struct
id|m68k_async_struct
op_star
id|info
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
DECL|member|stop_receive
r_void
(paren
op_star
id|stop_receive
)paren
(paren
r_struct
id|m68k_async_struct
op_star
id|info
)paren
suffix:semicolon
DECL|member|trans_empty
r_int
(paren
op_star
id|trans_empty
)paren
(paren
r_struct
id|m68k_async_struct
op_star
id|info
)paren
suffix:semicolon
DECL|member|check_open
r_int
(paren
op_star
id|check_open
)paren
(paren
r_struct
id|m68k_async_struct
op_star
id|info
comma
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
DECL|typedef|SERIALSWITCH
)brace
id|SERIALSWITCH
suffix:semicolon
multiline_comment|/*&n; * Definitions for m68k_async_struct (and serial_struct) flags field&n; */
DECL|macro|ASYNC_HUP_NOTIFY
mdefine_line|#define ASYNC_HUP_NOTIFY 0x0001 /* Notify getty on hangups and closes &n;&t;&t;&t;&t;   on the callout port */
DECL|macro|ASYNC_FOURPORT
mdefine_line|#define ASYNC_FOURPORT  0x0002&t;/* Set OU1, OUT2 per AST Fourport settings */
DECL|macro|ASYNC_SAK
mdefine_line|#define ASYNC_SAK&t;0x0004&t;/* Secure Attention Key (Orange book) */
DECL|macro|ASYNC_SPLIT_TERMIOS
mdefine_line|#define ASYNC_SPLIT_TERMIOS 0x0008 /* Separate termios for dialin/callout */
DECL|macro|ASYNC_SPD_MASK
mdefine_line|#define ASYNC_SPD_MASK&t;0x1030
DECL|macro|ASYNC_SPD_HI
mdefine_line|#define ASYNC_SPD_HI&t;0x0010&t;/* Use 56000 instead of 38400 bps */
DECL|macro|ASYNC_SPD_VHI
mdefine_line|#define ASYNC_SPD_VHI&t;0x0020  /* Use 115200 instead of 38400 bps */
DECL|macro|ASYNC_SPD_CUST
mdefine_line|#define ASYNC_SPD_CUST&t;0x0030  /* Use user-specified divisor */
DECL|macro|ASYNC_SKIP_TEST
mdefine_line|#define ASYNC_SKIP_TEST&t;0x0040 /* Skip UART test during autoconfiguration */
DECL|macro|ASYNC_AUTO_IRQ
mdefine_line|#define ASYNC_AUTO_IRQ  0x0080 /* Do automatic IRQ during autoconfiguration */
DECL|macro|ASYNC_SESSION_LOCKOUT
mdefine_line|#define ASYNC_SESSION_LOCKOUT 0x0100 /* Lock out cua opens based on session */
DECL|macro|ASYNC_PGRP_LOCKOUT
mdefine_line|#define ASYNC_PGRP_LOCKOUT    0x0200 /* Lock out cua opens based on pgrp */
DECL|macro|ASYNC_CALLOUT_NOHUP
mdefine_line|#define ASYNC_CALLOUT_NOHUP   0x0400 /* Don&squot;t do hangups for cua device */
DECL|macro|ASYNC_HARDPPS_CD
mdefine_line|#define ASYNC_HARDPPS_CD&t;0x0800&t;/* Call hardpps when CD goes high  */
DECL|macro|ASYNC_SPD_SHI
mdefine_line|#define ASYNC_SPD_SHI&t;0x1000&t;/* Use 230400 instead of 38400 bps */
DECL|macro|ASYNC_SPD_WARP
mdefine_line|#define ASYNC_SPD_WARP&t;0x1010&t;/* Use 460800 instead of 38400 bps */
DECL|macro|ASYNC_FLAGS
mdefine_line|#define ASYNC_FLAGS&t;0x1FFF&t;/* Possible legal async flags */
DECL|macro|ASYNC_USR_MASK
mdefine_line|#define ASYNC_USR_MASK 0x1430&t;/* Legal flags that non-privileged&n;&t;&t;&t;&t; * users can set or reset */
multiline_comment|/* Internal flags used only by drivers/char/m68kserial.c */
DECL|macro|ASYNC_INITIALIZED
mdefine_line|#define ASYNC_INITIALIZED&t;0x80000000 /* Serial port was initialized */
DECL|macro|ASYNC_CALLOUT_ACTIVE
mdefine_line|#define ASYNC_CALLOUT_ACTIVE&t;0x40000000 /* Call out device is active */
DECL|macro|ASYNC_NORMAL_ACTIVE
mdefine_line|#define ASYNC_NORMAL_ACTIVE&t;0x20000000 /* Normal device is active */
DECL|macro|ASYNC_BOOT_AUTOCONF
mdefine_line|#define ASYNC_BOOT_AUTOCONF&t;0x10000000 /* Autoconfigure port on bootup */
DECL|macro|ASYNC_CLOSING
mdefine_line|#define ASYNC_CLOSING&t;&t;0x08000000 /* Serial port is closing */
DECL|macro|ASYNC_CTS_FLOW
mdefine_line|#define ASYNC_CTS_FLOW&t;&t;0x04000000 /* Do CTS flow control */
DECL|macro|ASYNC_CHECK_CD
mdefine_line|#define ASYNC_CHECK_CD&t;&t;0x02000000 /* i.e., CLOCAL */
DECL|macro|ASYNC_INTERNAL_FLAGS
mdefine_line|#define ASYNC_INTERNAL_FLAGS&t;0xFF000000 /* Internal flags */
multiline_comment|/*&n; * Serial input interrupt line counters -- external structure&n; * Four lines can interrupt: CTS, DSR, RI, DCD&n; */
DECL|struct|serial_icounter_struct
r_struct
id|serial_icounter_struct
(brace
DECL|member|cts
DECL|member|dsr
DECL|member|rng
DECL|member|dcd
r_int
id|cts
comma
id|dsr
comma
id|rng
comma
id|dcd
suffix:semicolon
DECL|member|rx
DECL|member|tx
r_int
id|rx
comma
id|tx
suffix:semicolon
DECL|member|frame
DECL|member|overrun
DECL|member|parity
DECL|member|brk
r_int
id|frame
comma
id|overrun
comma
id|parity
comma
id|brk
suffix:semicolon
DECL|member|buf_overrun
r_int
id|buf_overrun
suffix:semicolon
DECL|member|reserved
r_int
id|reserved
(braket
l_int|9
)braket
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifdef __KERNEL__
multiline_comment|/*&n; * This is our internal structure for each serial port&squot;s state.&n; * &n; * Many fields are paralleled by the structure used by the serial_struct&n; * structure.&n; *&n; * For definitions of the flags field, see tty.h&n; */
macro_line|#include &lt;linux/termios.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/config.h&gt;&t;/* for Mac SCC extensions */
macro_line|#ifdef CONFIG_MAC
DECL|macro|NUM_ZSREGS
mdefine_line|#define NUM_ZSREGS    16
DECL|struct|mac_zschannel
r_struct
id|mac_zschannel
(brace
DECL|member|control
r_volatile
r_int
r_char
op_star
id|control
suffix:semicolon
DECL|member|data
r_volatile
r_int
r_char
op_star
id|data
suffix:semicolon
)brace
suffix:semicolon
r_struct
id|m68k_async_private
suffix:semicolon
macro_line|#endif
DECL|struct|m68k_async_struct
r_struct
id|m68k_async_struct
(brace
DECL|member|magic
r_int
id|magic
suffix:semicolon
DECL|member|baud_base
r_int
id|baud_base
suffix:semicolon
DECL|member|port
r_int
id|port
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
multiline_comment|/* defined in tty.h */
DECL|member|hub6
r_int
id|hub6
suffix:semicolon
multiline_comment|/* HUB6 plus one */
DECL|member|type
r_int
id|type
suffix:semicolon
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
DECL|member|read_status_mask
r_int
id|read_status_mask
suffix:semicolon
DECL|member|ignore_status_mask
r_int
id|ignore_status_mask
suffix:semicolon
DECL|member|timeout
r_int
id|timeout
suffix:semicolon
DECL|member|xmit_fifo_size
r_int
id|xmit_fifo_size
suffix:semicolon
DECL|member|custom_divisor
r_int
id|custom_divisor
suffix:semicolon
DECL|member|x_char
r_int
id|x_char
suffix:semicolon
multiline_comment|/* xon/xoff character */
DECL|member|close_delay
r_int
id|close_delay
suffix:semicolon
DECL|member|closing_wait
r_int
r_int
id|closing_wait
suffix:semicolon
DECL|member|closing_wait2
r_int
r_int
id|closing_wait2
suffix:semicolon
DECL|member|IER
r_int
id|IER
suffix:semicolon
multiline_comment|/* Interrupt Enable Register */
DECL|member|MCR
r_int
id|MCR
suffix:semicolon
multiline_comment|/* Modem control register */
DECL|member|MCR_noint
r_int
id|MCR_noint
suffix:semicolon
multiline_comment|/* MCR with interrupts off */
DECL|member|event
r_int
r_int
id|event
suffix:semicolon
DECL|member|last_active
r_int
r_int
id|last_active
suffix:semicolon
DECL|member|line
r_int
id|line
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
multiline_comment|/* # of fd on device */
DECL|member|blocked_open
r_int
id|blocked_open
suffix:semicolon
multiline_comment|/* # of blocked opens */
DECL|member|session
r_int
id|session
suffix:semicolon
multiline_comment|/* Session of opening process */
DECL|member|pgrp
r_int
id|pgrp
suffix:semicolon
multiline_comment|/* pgrp of opening process */
DECL|member|xmit_buf
r_int
r_char
op_star
id|xmit_buf
suffix:semicolon
DECL|member|xmit_head
r_int
id|xmit_head
suffix:semicolon
DECL|member|xmit_tail
r_int
id|xmit_tail
suffix:semicolon
DECL|member|xmit_cnt
r_int
id|xmit_cnt
suffix:semicolon
DECL|member|tqueue
r_struct
id|tq_struct
id|tqueue
suffix:semicolon
DECL|member|normal_termios
r_struct
id|termios
id|normal_termios
suffix:semicolon
DECL|member|callout_termios
r_struct
id|termios
id|callout_termios
suffix:semicolon
DECL|member|open_wait
r_struct
id|wait_queue
op_star
id|open_wait
suffix:semicolon
DECL|member|close_wait
r_struct
id|wait_queue
op_star
id|close_wait
suffix:semicolon
DECL|member|delta_msr_wait
r_struct
id|wait_queue
op_star
id|delta_msr_wait
suffix:semicolon
DECL|member|icount
r_struct
id|async_icount
id|icount
suffix:semicolon
multiline_comment|/* kernel counters for the 4 input interrupts */
DECL|member|next_port
r_struct
id|m68k_async_struct
op_star
id|next_port
suffix:semicolon
multiline_comment|/* For the linked list */
DECL|member|prev_port
r_struct
id|m68k_async_struct
op_star
id|prev_port
suffix:semicolon
DECL|member|board_base
r_void
op_star
id|board_base
suffix:semicolon
multiline_comment|/* board-base address for use with&n;&t;&t;&t;&t;&t;&t;boards carrying several UART&squot;s,&n;&t;&t;&t;&t;&t;&t;like some Amiga boards. */
DECL|member|nr_uarts
r_int
r_int
id|nr_uarts
suffix:semicolon
multiline_comment|/* UART-counter, that indicates&n;&t;&t;&t;&t;&t;&t;how many UART&squot;s there are on&n;&t;&t;&t;&t;&t;&t;the board.  If the board has a&n;&t;&t;&t;&t;&t;&t;IRQ-register, this can be used&n;&t;&t;&t;&t;&t;&t;to check if any of the uarts,&n;&t;&t;&t;&t;&t;&t;on the board has requested an&n;&t;&t;&t;&t;&t;&t;interrupt, instead of checking&n;&t;&t;&t;&t;&t;&t;IRQ-registers on all UART&squot;s */
DECL|member|sw
id|SERIALSWITCH
op_star
id|sw
suffix:semicolon
multiline_comment|/* functions to manage this port */
macro_line|#ifdef CONFIG_MAC
DECL|member|private
r_struct
id|m68k_async_private
op_star
r_private
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_MAC
DECL|struct|m68k_async_private
r_struct
id|m68k_async_private
(brace
DECL|member|zs_next
r_struct
id|m68k_async_info
op_star
id|zs_next
suffix:semicolon
multiline_comment|/* For IRQ servicing chain */
DECL|member|zs_channel
r_struct
id|mac_zschannel
op_star
id|zs_channel
suffix:semicolon
multiline_comment|/* Channel registers */
DECL|member|zs_chan_a
r_struct
id|mac_zschannel
op_star
id|zs_chan_a
suffix:semicolon
multiline_comment|/* A side registers */
DECL|member|read_reg_zero
r_int
r_char
id|read_reg_zero
suffix:semicolon
DECL|member|soft_carrier
r_char
id|soft_carrier
suffix:semicolon
multiline_comment|/* Use soft carrier on this */
DECL|member|break_abort
r_char
id|break_abort
suffix:semicolon
multiline_comment|/* console, process brk/abrt */
DECL|member|kgdb_channel
r_char
id|kgdb_channel
suffix:semicolon
multiline_comment|/* Kgdb running on this channel */
DECL|member|is_cons
r_char
id|is_cons
suffix:semicolon
multiline_comment|/* Is this our console. */
DECL|member|tx_active
r_int
r_char
id|tx_active
suffix:semicolon
multiline_comment|/* character being xmitted */
DECL|member|tx_stopped
r_int
r_char
id|tx_stopped
suffix:semicolon
multiline_comment|/* output is suspended */
multiline_comment|/* We need to know the current clock divisor&n;&t; * to read the bps rate the chip has currently&n;&t; * loaded.&n;&t; */
DECL|member|clk_divisor
r_int
r_char
id|clk_divisor
suffix:semicolon
multiline_comment|/* May be 1, 16, 32, or 64 */
DECL|member|zs_baud
r_int
id|zs_baud
suffix:semicolon
multiline_comment|/* Current write register values */
DECL|member|curregs
r_int
r_char
id|curregs
(braket
id|NUM_ZSREGS
)braket
suffix:semicolon
multiline_comment|/* Values we need to set next opportunity */
DECL|member|pendregs
r_int
r_char
id|pendregs
(braket
id|NUM_ZSREGS
)braket
suffix:semicolon
DECL|member|change_needed
r_char
id|change_needed
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
DECL|macro|SERIAL_MAGIC
mdefine_line|#define SERIAL_MAGIC 0x5301
multiline_comment|/*&n; * The size of the serial xmit buffer is 1 page, or 4096 bytes&n; */
DECL|macro|SERIAL_XMIT_SIZE
mdefine_line|#define SERIAL_XMIT_SIZE 4096
multiline_comment|/*&n; * Events are used to schedule things to happen at timer-interrupt&n; * time, instead of at rs interrupt time.&n; */
DECL|macro|RS_EVENT_WRITE_WAKEUP
mdefine_line|#define RS_EVENT_WRITE_WAKEUP&t;0
multiline_comment|/* number of characters left in xmit buffer before we ask for more */
DECL|macro|WAKEUP_CHARS
mdefine_line|#define WAKEUP_CHARS 256
multiline_comment|/* Export to allow PCMCIA to use this - Dave Hinds */
r_extern
r_int
id|register_serial
c_func
(paren
r_struct
id|serial_struct
op_star
id|req
)paren
suffix:semicolon
r_extern
r_void
id|unregister_serial
c_func
(paren
r_int
id|line
)paren
suffix:semicolon
r_extern
r_struct
id|m68k_async_struct
id|rs_table
(braket
)braket
suffix:semicolon
r_extern
id|task_queue
id|tq_serial
suffix:semicolon
multiline_comment|/*&n; * This routine is used by the interrupt handler to schedule&n; * processing in the software interrupt portion of the driver.&n; */
DECL|function|rs_sched_event
r_static
id|__inline__
r_void
id|rs_sched_event
c_func
(paren
r_struct
id|m68k_async_struct
op_star
id|info
comma
r_int
id|event
)paren
(brace
id|info-&gt;event
op_or_assign
l_int|1
op_lshift
id|event
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|info-&gt;tqueue
comma
op_amp
id|tq_serial
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|SERIAL_BH
)paren
suffix:semicolon
)brace
DECL|function|rs_receive_char
r_static
id|__inline__
r_void
id|rs_receive_char
c_func
(paren
r_struct
id|m68k_async_struct
op_star
id|info
comma
r_int
id|ch
comma
r_int
id|err
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|info-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;flip.count
op_ge
id|TTY_FLIPBUF_SIZE
)paren
r_return
suffix:semicolon
id|tty-&gt;flip.count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
id|TTY_BREAK
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SAK
)paren
id|do_SAK
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
op_star
id|tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
id|err
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_increment
op_assign
id|ch
suffix:semicolon
id|info-&gt;icount.rx
op_increment
suffix:semicolon
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|rs_get_tx_char
r_static
id|__inline__
r_int
id|rs_get_tx_char
c_func
(paren
r_struct
id|m68k_async_struct
op_star
id|info
)paren
(brace
r_int
r_char
id|ch
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;x_char
)paren
(brace
id|ch
op_assign
id|info-&gt;x_char
suffix:semicolon
id|info-&gt;icount.tx
op_increment
suffix:semicolon
id|info-&gt;x_char
op_assign
l_int|0
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;xmit_cnt
op_le
l_int|0
op_logical_or
id|info-&gt;tty-&gt;stopped
op_logical_or
id|info-&gt;tty-&gt;hw_stopped
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|ch
op_assign
id|info-&gt;xmit_buf
(braket
id|info-&gt;xmit_tail
op_increment
)braket
suffix:semicolon
id|info-&gt;xmit_tail
op_and_assign
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
suffix:semicolon
id|info-&gt;icount.tx
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|info-&gt;xmit_cnt
OL
id|WAKEUP_CHARS
)paren
id|rs_sched_event
c_func
(paren
id|info
comma
id|RS_EVENT_WRITE_WAKEUP
)paren
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
DECL|function|rs_no_more_tx
r_static
id|__inline__
r_int
id|rs_no_more_tx
c_func
(paren
r_struct
id|m68k_async_struct
op_star
id|info
)paren
(brace
r_return
id|info-&gt;xmit_cnt
op_le
l_int|0
op_logical_or
id|info-&gt;tty-&gt;stopped
op_logical_or
id|info-&gt;tty-&gt;hw_stopped
suffix:semicolon
)brace
DECL|function|rs_dcd_changed
r_static
id|__inline__
r_void
id|rs_dcd_changed
c_func
(paren
r_struct
id|m68k_async_struct
op_star
id|info
comma
r_int
id|dcd
)paren
(brace
multiline_comment|/* update input line counter */
id|info-&gt;icount.dcd
op_increment
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;delta_msr_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CHECK_CD
)paren
(brace
macro_line|#if (defined(SERIAL_DEBUG_OPEN) || defined(SERIAL_DEBUG_INTR))
id|printk
c_func
(paren
l_string|&quot;ttyS%d CD now %s...&quot;
comma
id|info-&gt;line
comma
id|dcd
ques
c_cond
l_string|&quot;on&quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
macro_line|#endif&t;&t;
r_if
c_cond
(paren
id|dcd
)paren
(brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_NOHUP
)paren
)paren
)paren
(brace
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;scheduling hangup...&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|info-&gt;tty
)paren
id|tty_hangup
c_func
(paren
id|info-&gt;tty
)paren
suffix:semicolon
)brace
)brace
)brace
r_void
id|rs_stop
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_void
id|rs_start
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
DECL|function|rs_check_cts
r_static
id|__inline__
r_void
id|rs_check_cts
c_func
(paren
r_struct
id|m68k_async_struct
op_star
id|info
comma
r_int
id|cts
)paren
(brace
multiline_comment|/* update input line counter */
id|info-&gt;icount.cts
op_increment
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;delta_msr_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CTS_FLOW
)paren
op_logical_and
id|info-&gt;tty
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;tty-&gt;hw_stopped
)paren
(brace
r_if
c_cond
(paren
id|cts
)paren
(brace
macro_line|#if (defined(SERIAL_DEBUG_INTR) || defined(SERIAL_DEBUG_FLOW))
id|printk
c_func
(paren
l_string|&quot;CTS tx start...&quot;
)paren
suffix:semicolon
macro_line|#endif
id|info-&gt;tty-&gt;hw_stopped
op_assign
l_int|0
suffix:semicolon
id|rs_start
c_func
(paren
id|info-&gt;tty
)paren
suffix:semicolon
id|rs_sched_event
c_func
(paren
id|info
comma
id|RS_EVENT_WRITE_WAKEUP
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|cts
)paren
(brace
id|info-&gt;tty-&gt;hw_stopped
op_assign
l_int|1
suffix:semicolon
id|rs_stop
c_func
(paren
id|info-&gt;tty
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#endif /* __KERNEL__ */
macro_line|#endif /* _M68K_SERIAL_H */
eof
