multiline_comment|/* * Last edited: Nov  7 23:44 1995 (cort) */
macro_line|#ifndef _PPC_PGTABLE_H
DECL|macro|_PPC_PGTABLE_H
mdefine_line|#define _PPC_PGTABLE_H
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
multiline_comment|/*&n; * Memory management on the PowerPC is a software emulation of the i386&n; * MMU folded onto the PowerPC hardware MMU.  The emulated version looks&n; * and behaves like the two-level i386 MMU.  Entries from these tables&n; * are merged into the PowerPC hashed MMU tables, on demand, treating the&n; * hashed tables like a special cache.&n; *&n; * Since the PowerPC does not have separate kernel and user address spaces,&n; * the user virtual address space must be a [proper] subset of the kernel&n; * space.  Thus, all tasks will have a specific virtual mapping for the&n; * user virtual space and a common mapping for the kernel space.  The&n; * simplest way to split this was literally in half.  Also, life is so&n; * much simpler for the kernel if the machine hardware resources are&n; * always mapped in.  Thus, some additional space is given up to the&n; * kernel space to accommodate this.&n; *&n; * CAUTION! Some of the trade-offs make sense for the PreP platform on&n; * which this code was originally developed.  When it migrates to other&n; * PowerPC environments, some of the assumptions may fail and the whole&n; * setup may need to be reevaluated.&n; *&n; * On the PowerPC, page translations are kept in a hashed table.  There&n; * is exactly one of these tables [although the architecture supports&n; * an arbitrary number].  Page table entries move in/out of this hashed&n; * structure on demand, with the kernel filling in entries as they are&n; * needed.  Just where a page table entry hits in the hashed table is a&n; * function of the hashing which is in turn based on the upper 4 bits&n; * of the logical address.  These 4 bits address a &quot;virtual segment id&quot;&n; * which is unique per task/page combination for user addresses and&n; * fixed for the kernel addresses.  Thus, the kernel space can be simply&n; * shared [indeed at low overhead] among all tasks.&n; *&n; * The basic virtual address space is thus:&n; *&n; * 0x0XXXXXX  --+&n; * 0x1XXXXXX    |&n; * 0x2XXXXXX    |  User address space. &n; * 0x3XXXXXX    |&n; * 0x4XXXXXX    |&n; * 0x5XXXXXX    |&n; * 0x6XXXXXX    |&n; * 0x7XXXXXX  --+&n; * 0x8XXXXXX       PCI/ISA I/O space&n; * 0x9XXXXXX  --+&n; * 0xAXXXXXX    |  Kernel virtual memory&n; * 0xBXXXXXX  --+&n; * 0xCXXXXXX       PCI/ISA Memory space&n; * 0xDXXXXXX&n; * 0xEXXXXXX&n; * 0xFXXXXXX       Board I/O space&n; *&n; * CAUTION!  One of the real problems here is keeping the software&n; * managed tables coherent with the hardware hashed tables.  When&n; * the software decides to update the table, it&squot;s normally easy to&n; * update the hardware table.  But when the hardware tables need&n; * changed, e.g. as the result of a page fault, it&squot;s more difficult&n; * to reflect those changes back into the software entries.  Currently,&n; * this process is quite crude, with updates causing the entire set&n; * of tables to become invalidated.  Some performance could certainly&n; * be regained by improving this.&n; *&n; * The Linux memory management assumes a three-level page table setup. On&n; * the i386, we use that, but &quot;fold&quot; the mid level into the top-level page&n; * table, so that we physically have the same two-level page table as the&n; * i386 mmu expects.&n; *&n; * This file contains the functions and defines necessary to modify and use&n; * the i386 page table tree.&n; */
multiline_comment|/* PMD_SHIFT determines the size of the area a second-level page table can map */
DECL|macro|PMD_SHIFT
mdefine_line|#define PMD_SHIFT&t;22
DECL|macro|PMD_SIZE
mdefine_line|#define PMD_SIZE&t;(1UL &lt;&lt; PMD_SHIFT)
DECL|macro|PMD_MASK
mdefine_line|#define PMD_MASK&t;(~(PMD_SIZE-1))
multiline_comment|/* PGDIR_SHIFT determines what a third-level page table entry can map */
DECL|macro|PGDIR_SHIFT
mdefine_line|#define PGDIR_SHIFT&t;22
DECL|macro|PGDIR_SIZE
mdefine_line|#define PGDIR_SIZE&t;(1UL &lt;&lt; PGDIR_SHIFT)
DECL|macro|PGDIR_MASK
mdefine_line|#define PGDIR_MASK&t;(~(PGDIR_SIZE-1))
multiline_comment|/*&n; * entries per page directory level: the i386 is two-level, so&n; * we don&squot;t really have any PMD directory physically.&n; */
DECL|macro|PTRS_PER_PTE
mdefine_line|#define PTRS_PER_PTE&t;1024
DECL|macro|PTRS_PER_PMD
mdefine_line|#define PTRS_PER_PMD&t;1
DECL|macro|PTRS_PER_PGD
mdefine_line|#define PTRS_PER_PGD&t;1024
multiline_comment|/* Just any arbitrary offset to the start of the vmalloc VM area: the&n; * current 8MB value just means that there will be a 8MB &quot;hole&quot; after the&n; * physical memory until the kernel virtual memory starts.  That means that&n; * any out-of-bounds memory accesses will hopefully be caught.&n; * The vmalloc() routines leaves a hole of 4kB between each vmalloced&n; * area for the same reason. ;)&n; */
DECL|macro|VMALLOC_OFFSET
mdefine_line|#define VMALLOC_OFFSET&t;(8*1024*1024)
DECL|macro|VMALLOC_START
mdefine_line|#define VMALLOC_START ((high_memory + VMALLOC_OFFSET) &amp; ~(VMALLOC_OFFSET-1))
DECL|macro|VMALLOC_VMADDR
mdefine_line|#define VMALLOC_VMADDR(x) ((unsigned long)(x))
DECL|macro|_PAGE_PRESENT
mdefine_line|#define _PAGE_PRESENT&t;0x001
DECL|macro|_PAGE_RW
mdefine_line|#define _PAGE_RW&t;0x002
DECL|macro|_PAGE_USER
mdefine_line|#define _PAGE_USER&t;0x004
DECL|macro|_PAGE_PCD
mdefine_line|#define _PAGE_PCD&t;0x010
DECL|macro|_PAGE_ACCESSED
mdefine_line|#define _PAGE_ACCESSED&t;0x020
DECL|macro|_PAGE_DIRTY
mdefine_line|#define _PAGE_DIRTY&t;0x040
DECL|macro|_PAGE_COW
mdefine_line|#define _PAGE_COW&t;0x200&t;/* implemented in software (one of the AVL bits) */
DECL|macro|_PAGE_TABLE
mdefine_line|#define _PAGE_TABLE&t;(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER | _PAGE_ACCESSED | _PAGE_DIRTY)
DECL|macro|_PAGE_CHG_MASK
mdefine_line|#define _PAGE_CHG_MASK&t;(PAGE_MASK | _PAGE_ACCESSED | _PAGE_DIRTY)
DECL|macro|PAGE_NONE
mdefine_line|#define PAGE_NONE&t;__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED)
DECL|macro|PAGE_SHARED
mdefine_line|#define PAGE_SHARED&t;__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER | _PAGE_ACCESSED)
DECL|macro|PAGE_COPY
mdefine_line|#define PAGE_COPY&t;__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED | _PAGE_COW)
DECL|macro|PAGE_READONLY
mdefine_line|#define PAGE_READONLY&t;__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
DECL|macro|PAGE_KERNEL
mdefine_line|#define PAGE_KERNEL&t;__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | _PAGE_ACCESSED)
multiline_comment|/*&n; * The i386 can&squot;t do page protection for execute, and considers that the same are read.&n; * Also, write permissions imply read permissions. This is the closest we can get..&n; */
DECL|macro|__P000
mdefine_line|#define __P000&t;PAGE_NONE
DECL|macro|__P001
mdefine_line|#define __P001&t;PAGE_READONLY
DECL|macro|__P010
mdefine_line|#define __P010&t;PAGE_COPY
DECL|macro|__P011
mdefine_line|#define __P011&t;PAGE_COPY
DECL|macro|__P100
mdefine_line|#define __P100&t;PAGE_READONLY
DECL|macro|__P101
mdefine_line|#define __P101&t;PAGE_READONLY
DECL|macro|__P110
mdefine_line|#define __P110&t;PAGE_COPY
DECL|macro|__P111
mdefine_line|#define __P111&t;PAGE_COPY
DECL|macro|__S000
mdefine_line|#define __S000&t;PAGE_NONE
DECL|macro|__S001
mdefine_line|#define __S001&t;PAGE_READONLY
DECL|macro|__S010
mdefine_line|#define __S010&t;PAGE_SHARED
DECL|macro|__S011
mdefine_line|#define __S011&t;PAGE_SHARED
DECL|macro|__S100
mdefine_line|#define __S100&t;PAGE_READONLY
DECL|macro|__S101
mdefine_line|#define __S101&t;PAGE_READONLY
DECL|macro|__S110
mdefine_line|#define __S110&t;PAGE_SHARED
DECL|macro|__S111
mdefine_line|#define __S111&t;PAGE_SHARED
multiline_comment|/*&n; * Define this if things work differently on a i386 and a i486:&n; * it will (on a i486) warn about kernel memory accesses that are&n; * done without a &squot;verify_area(VERIFY_WRITE,..)&squot;&n; */
DECL|macro|CONFIG_TEST_VERIFY_AREA
macro_line|#undef CONFIG_TEST_VERIFY_AREA
multiline_comment|/* page table for 0-4MB for everybody */
r_extern
r_int
r_int
id|pg0
(braket
l_int|1024
)braket
suffix:semicolon
multiline_comment|/*&n; * BAD_PAGETABLE is used when we need a bogus page-table, while&n; * BAD_PAGE is used for a bogus page.&n; *&n; * ZERO_PAGE is a global shared page that is always zero: used&n; * for zero-mapped memory areas etc..&n; */
r_extern
id|pte_t
id|__bad_page
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|pte_t
op_star
id|__bad_pagetable
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
id|__zero_page
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|BAD_PAGETABLE
mdefine_line|#define BAD_PAGETABLE __bad_pagetable()
DECL|macro|BAD_PAGE
mdefine_line|#define BAD_PAGE __bad_page()
DECL|macro|ZERO_PAGE
mdefine_line|#define ZERO_PAGE __zero_page()
multiline_comment|/* number of bits that fit into a memory pointer */
DECL|macro|BITS_PER_PTR
mdefine_line|#define BITS_PER_PTR&t;&t;&t;(8*sizeof(unsigned long))
multiline_comment|/* to align the pointer to a pointer address */
DECL|macro|PTR_MASK
mdefine_line|#define PTR_MASK&t;&t;&t;(~(sizeof(void*)-1))
multiline_comment|/* sizeof(void*)==1&lt;&lt;SIZEOF_PTR_LOG2 */
multiline_comment|/* 64-bit machines, beware!  SRB. */
DECL|macro|SIZEOF_PTR_LOG2
mdefine_line|#define SIZEOF_PTR_LOG2&t;&t;&t;2
multiline_comment|/* to find an entry in a page-table */
DECL|macro|PAGE_PTR
mdefine_line|#define PAGE_PTR(address) &bslash;&n;((unsigned long)(address)&gt;&gt;(PAGE_SHIFT-SIZEOF_PTR_LOG2)&amp;PTR_MASK&amp;~PAGE_MASK)
multiline_comment|/* to set the page-dir */
multiline_comment|/* tsk is a task_struct and pgdir is a pte_t */
DECL|macro|SET_PAGE_DIR
mdefine_line|#define SET_PAGE_DIR(tsk,pgdir) &bslash;&n;do { &bslash;&n;&t;(tsk)-&gt;tss.pg_tables = (unsigned long *)(pgdir); &bslash;&n;&t;if ((tsk) == current) &bslash;&n;&t;{ &bslash;&n;/*_printk(&quot;Change page tables = %x&bslash;n&quot;, pgdir);*/ &bslash;&n;&t;} &bslash;&n;} while (0)
r_extern
r_int
r_int
id|high_memory
suffix:semicolon
DECL|function|pte_none
r_extern
r_inline
r_int
id|pte_none
c_func
(paren
id|pte_t
id|pte
)paren
(brace
r_return
op_logical_neg
id|pte_val
c_func
(paren
id|pte
)paren
suffix:semicolon
)brace
DECL|function|pte_present
r_extern
r_inline
r_int
id|pte_present
c_func
(paren
id|pte_t
id|pte
)paren
(brace
r_return
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_PRESENT
suffix:semicolon
)brace
DECL|function|pte_inuse
r_extern
r_inline
r_int
id|pte_inuse
c_func
(paren
id|pte_t
op_star
id|ptep
)paren
(brace
r_return
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|ptep
)paren
)braket
dot
id|reserved
suffix:semicolon
)brace
multiline_comment|/*extern inline int pte_inuse(pte_t *ptep)&t;{ return mem_map[MAP_NR(ptep)] != 1; }*/
DECL|function|pte_clear
r_extern
r_inline
r_void
id|pte_clear
c_func
(paren
id|pte_t
op_star
id|ptep
)paren
(brace
id|pte_val
c_func
(paren
op_star
id|ptep
)paren
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|pte_reuse
r_extern
r_inline
r_void
id|pte_reuse
c_func
(paren
id|pte_t
op_star
id|ptep
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|ptep
)paren
)braket
dot
id|reserved
)paren
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|ptep
)paren
)braket
dot
id|count
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;   extern inline void pte_reuse(pte_t * ptep)&n;{&n;&t;if (!(mem_map[MAP_NR(ptep)] &amp; MAP_PAGE_RESERVED))&n;&t;&t;mem_map[MAP_NR(ptep)]++;&n;}&n;*/
DECL|function|pmd_none
r_extern
r_inline
r_int
id|pmd_none
c_func
(paren
id|pmd_t
id|pmd
)paren
(brace
r_return
op_logical_neg
id|pmd_val
c_func
(paren
id|pmd
)paren
suffix:semicolon
)brace
DECL|function|pmd_bad
r_extern
r_inline
r_int
id|pmd_bad
c_func
(paren
id|pmd_t
id|pmd
)paren
(brace
r_return
(paren
id|pmd_val
c_func
(paren
id|pmd
)paren
op_amp
op_complement
id|PAGE_MASK
)paren
op_ne
id|_PAGE_TABLE
suffix:semicolon
)brace
DECL|function|pmd_present
r_extern
r_inline
r_int
id|pmd_present
c_func
(paren
id|pmd_t
id|pmd
)paren
(brace
r_return
id|pmd_val
c_func
(paren
id|pmd
)paren
op_amp
id|_PAGE_PRESENT
suffix:semicolon
)brace
DECL|function|pmd_inuse
r_extern
r_inline
r_int
id|pmd_inuse
c_func
(paren
id|pmd_t
op_star
id|pmdp
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pmd_clear
r_extern
r_inline
r_void
id|pmd_clear
c_func
(paren
id|pmd_t
op_star
id|pmdp
)paren
(brace
id|pmd_val
c_func
(paren
op_star
id|pmdp
)paren
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|pmd_reuse
r_extern
r_inline
r_void
id|pmd_reuse
c_func
(paren
id|pmd_t
op_star
id|pmdp
)paren
(brace
)brace
multiline_comment|/*&n; * The &quot;pgd_xxx()&quot; functions here are trivial for a folded two-level&n; * setup: the pgd is never bad, and a pmd always exists (as it&squot;s folded&n; * into the pgd entry)&n; */
DECL|function|pgd_none
r_extern
r_inline
r_int
id|pgd_none
c_func
(paren
id|pgd_t
id|pgd
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pgd_bad
r_extern
r_inline
r_int
id|pgd_bad
c_func
(paren
id|pgd_t
id|pgd
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pgd_present
r_extern
r_inline
r_int
id|pgd_present
c_func
(paren
id|pgd_t
id|pgd
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*extern inline int pgd_inuse(pgd_t * pgdp)&t;{ return mem_map[MAP_NR(pgdp)] != 1; }*/
DECL|function|pgd_inuse
r_extern
r_inline
r_int
id|pgd_inuse
c_func
(paren
id|pgd_t
op_star
id|pgdp
)paren
(brace
r_return
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|pgdp
)paren
)braket
dot
id|reserved
suffix:semicolon
)brace
DECL|function|pgd_clear
r_extern
r_inline
r_void
id|pgd_clear
c_func
(paren
id|pgd_t
op_star
id|pgdp
)paren
(brace
)brace
multiline_comment|/*&n;extern inline void pgd_reuse(pgd_t * pgdp)&n;{&n;&t;if (!mem_map[MAP_NR(pgdp)].reserved)&n;&t;&t;mem_map[MAP_NR(pgdp)].count++;&n;}&n;*/
multiline_comment|/*&n; * The following only work if pte_present() is true.&n; * Undefined behaviour if not..&n; */
DECL|function|pte_read
r_extern
r_inline
r_int
id|pte_read
c_func
(paren
id|pte_t
id|pte
)paren
(brace
r_return
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_USER
suffix:semicolon
)brace
DECL|function|pte_write
r_extern
r_inline
r_int
id|pte_write
c_func
(paren
id|pte_t
id|pte
)paren
(brace
r_return
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_RW
suffix:semicolon
)brace
DECL|function|pte_exec
r_extern
r_inline
r_int
id|pte_exec
c_func
(paren
id|pte_t
id|pte
)paren
(brace
r_return
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_USER
suffix:semicolon
)brace
DECL|function|pte_dirty
r_extern
r_inline
r_int
id|pte_dirty
c_func
(paren
id|pte_t
id|pte
)paren
(brace
r_return
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_DIRTY
suffix:semicolon
)brace
DECL|function|pte_young
r_extern
r_inline
r_int
id|pte_young
c_func
(paren
id|pte_t
id|pte
)paren
(brace
r_return
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_ACCESSED
suffix:semicolon
)brace
DECL|function|pte_cow
r_extern
r_inline
r_int
id|pte_cow
c_func
(paren
id|pte_t
id|pte
)paren
(brace
r_return
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_COW
suffix:semicolon
)brace
DECL|function|pte_wrprotect
r_extern
r_inline
id|pte_t
id|pte_wrprotect
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_and_assign
op_complement
id|_PAGE_RW
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_rdprotect
r_extern
r_inline
id|pte_t
id|pte_rdprotect
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_and_assign
op_complement
id|_PAGE_USER
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_exprotect
r_extern
r_inline
id|pte_t
id|pte_exprotect
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_and_assign
op_complement
id|_PAGE_USER
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_mkclean
r_extern
r_inline
id|pte_t
id|pte_mkclean
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_and_assign
op_complement
id|_PAGE_DIRTY
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_mkold
r_extern
r_inline
id|pte_t
id|pte_mkold
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_and_assign
op_complement
id|_PAGE_ACCESSED
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_uncow
r_extern
r_inline
id|pte_t
id|pte_uncow
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_and_assign
op_complement
id|_PAGE_COW
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_mkwrite
r_extern
r_inline
id|pte_t
id|pte_mkwrite
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_or_assign
id|_PAGE_RW
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_mkread
r_extern
r_inline
id|pte_t
id|pte_mkread
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_or_assign
id|_PAGE_USER
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_mkexec
r_extern
r_inline
id|pte_t
id|pte_mkexec
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_or_assign
id|_PAGE_USER
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_mkdirty
r_extern
r_inline
id|pte_t
id|pte_mkdirty
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_or_assign
id|_PAGE_DIRTY
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_mkyoung
r_extern
r_inline
id|pte_t
id|pte_mkyoung
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_or_assign
id|_PAGE_ACCESSED
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_mkcow
r_extern
r_inline
id|pte_t
id|pte_mkcow
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_or_assign
id|_PAGE_COW
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
multiline_comment|/*&n; * Conversion functions: convert a page and protection to a page entry,&n; * and a page entry and page directory to the page they refer to.&n; */
DECL|function|mk_pte
r_extern
r_inline
id|pte_t
id|mk_pte
c_func
(paren
r_int
r_int
id|page
comma
id|pgprot_t
id|pgprot
)paren
(brace
id|pte_t
id|pte
suffix:semicolon
id|pte_val
c_func
(paren
id|pte
)paren
op_assign
id|page
op_or
id|pgprot_val
c_func
(paren
id|pgprot
)paren
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_modify
r_extern
r_inline
id|pte_t
id|pte_modify
c_func
(paren
id|pte_t
id|pte
comma
id|pgprot_t
id|newprot
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_assign
(paren
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_CHG_MASK
)paren
op_or
id|pgprot_val
c_func
(paren
id|newprot
)paren
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
multiline_comment|/*extern inline void pmd_set(pmd_t * pmdp, pte_t * ptep)&n;{ pmd_val(*pmdp) = _PAGE_TABLE | ((((unsigned long) ptep) - PAGE_OFFSET) &lt;&lt; (32-PAGE_SHIFT)); }&n;*/
DECL|function|pte_page
r_extern
r_inline
r_int
r_int
id|pte_page
c_func
(paren
id|pte_t
id|pte
)paren
(brace
r_return
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
)brace
DECL|function|pmd_page
r_extern
r_inline
r_int
r_int
id|pmd_page
c_func
(paren
id|pmd_t
id|pmd
)paren
(brace
r_return
id|pmd_val
c_func
(paren
id|pmd
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
)brace
multiline_comment|/* to find an entry in a page-table-directory */
DECL|function|pgd_offset
r_extern
r_inline
id|pgd_t
op_star
id|pgd_offset
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|address
)paren
(brace
r_return
id|mm-&gt;pgd
op_plus
(paren
id|address
op_rshift
id|PGDIR_SHIFT
)paren
suffix:semicolon
)brace
multiline_comment|/* Find an entry in the second-level page table.. */
DECL|function|pmd_offset
r_extern
r_inline
id|pmd_t
op_star
id|pmd_offset
c_func
(paren
id|pgd_t
op_star
id|dir
comma
r_int
r_int
id|address
)paren
(brace
r_return
(paren
id|pmd_t
op_star
)paren
id|dir
suffix:semicolon
)brace
multiline_comment|/* Find an entry in the third-level page table.. */
DECL|function|pte_offset
r_extern
r_inline
id|pte_t
op_star
id|pte_offset
c_func
(paren
id|pmd_t
op_star
id|dir
comma
r_int
r_int
id|address
)paren
(brace
r_return
(paren
id|pte_t
op_star
)paren
id|pmd_page
c_func
(paren
op_star
id|dir
)paren
op_plus
(paren
(paren
id|address
op_rshift
id|PAGE_SHIFT
)paren
op_amp
(paren
id|PTRS_PER_PTE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate and free page tables. The xxx_kernel() versions are&n; * used to allocate a kernel page table - this turns on ASN bits&n; * if any, and marks the page tables reserved.&n; */
DECL|function|pte_free_kernel
r_extern
r_inline
r_void
id|pte_free_kernel
c_func
(paren
id|pte_t
op_star
id|pte
)paren
(brace
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|pte
)paren
)braket
dot
id|reserved
op_assign
l_int|1
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|pte
)paren
suffix:semicolon
)brace
multiline_comment|/*extern inline void pte_free_kernel(pte_t * pte)&n;{&n;&t;mem_map[MAP_NR(pte)] = 1;&n;&t;free_page((unsigned long) pte);&n;}&n;*/
multiline_comment|/*&n;extern inline pte_t * pte_alloc_kernel(pmd_t * pmd, unsigned long address)&n;{&n;&t;address = (address &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - 1);&n;&t;if (pmd_none(*pmd)) {&n;&t;&t;pte_t * page = (pte_t *) get_free_page(GFP_KERNEL);&n;&t;&t;if (pmd_none(*pmd)) {&n;&t;&t;&t;if (page) {&n;&t;&t;&t;&t;pmd_val(*pmd) = _PAGE_TABLE | (unsigned long) page;&n;&t;&t;&t;&t;mem_map[MAP_NR(page)] = MAP_PAGE_RESERVED;&n;&t;&t;&t;&t;return page + address;&n;&t;&t;&t;}&n;&t;&t;&t;pmd_val(*pmd) = _PAGE_TABLE | (unsigned long) BAD_PAGETABLE;&n;&t;&t;&t;return NULL;&n;&t;&t;}&n;&t;&t;free_page((unsigned long) page);&n;&t;}&n;&t;if (pmd_bad(*pmd)) {&n;&t;&t;printk(&quot;Bad pmd in pte_alloc: %08lx&bslash;n&quot;, pmd_val(*pmd));&n;&t;&t;pmd_val(*pmd) = _PAGE_TABLE | (unsigned long) BAD_PAGETABLE;&n;&t;&t;return NULL;&n;&t;}&n;&t;return (pte_t *) pmd_page(*pmd) + address;&n;}*/
multiline_comment|/*&n;extern inline pte_t * pte_alloc_kernel(pmd_t *pmd, unsigned long address)&n;{&n;printk(&quot;pte_alloc_kernel pmd = %08X, address = %08X&bslash;n&quot;, pmd, address);&n;&t;address = (address &gt;&gt; PAGE_SHIFT) &amp; (PTRS_PER_PTE - 1);&n;printk(&quot;address now = %08X&bslash;n&quot;, address);&n;&t;if (pmd_none(*pmd)) {&n;&t;&t;pte_t *page;&n;printk(&quot;pmd_none(*pmd) true&bslash;n&quot;);&n;&t;&t;page = (pte_t *) get_free_page(GFP_KERNEL);&n;printk(&quot;page = %08X after get_free_page(%08X)&bslash;n&quot;,page,GFP_KERNEL);&n;&t;&t;if (pmd_none(*pmd)) {&n;printk(&quot;pmd_none(*pmd=%08X) still&bslash;n&quot;,*pmd);&t;&t;  &n;&t;&t;&t;if (page) {&n;printk(&quot;page true = %08X&bslash;n&quot;,page);&t;&t;&t;  &n;&t;&t;&t;&t;pmd_set(pmd, page);&n;printk(&quot;pmd_set(%08X,%08X)&bslash;n&quot;,pmd,page);&t;&t;&t;  &n;&t;&t;&t;&t;mem_map[MAP_NR(page)].reserved = 1;&n;printk(&quot;did mem_map&bslash;n&quot;,pmd,page);&t;&t;&t;  &n;&t;&t;&t;&t;return page + address;&n;&t;&t;&t;}&n;printk(&quot;did pmd_set(%08X, %08X&bslash;n&quot;,pmd,BAD_PAGETABLE);&t;&t;&t;  &n;&t;&t;&t;pmd_set(pmd, (pte_t *) BAD_PAGETABLE);&n;&t;&t;&t;return NULL;&n;&t;&t;}&n;printk(&quot;did free_page(%08X)&bslash;n&quot;,page);&t;&t;&t;  &t;&t;&n;&t;&t;free_page((unsigned long) page);&n;&t;}&n;&t;if (pmd_bad(*pmd)) {&n;&t;&t;printk(&quot;Bad pmd in pte_alloc: %08lx&bslash;n&quot;, pmd_val(*pmd));&n;&t;&t;pmd_set(pmd, (pte_t *) BAD_PAGETABLE);&n;&t;&t;return NULL;&n;&t;}&n;printk(&quot;returning pmd_page(%08X) + %08X&bslash;n&quot;,pmd_page(*pmd) , address);&t;  &n;&n;&t;return (pte_t *) pmd_page(*pmd) + address;&n;}&n;*/
DECL|function|pte_alloc_kernel
r_extern
r_inline
id|pte_t
op_star
id|pte_alloc_kernel
c_func
(paren
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|address
)paren
(brace
id|address
op_assign
(paren
id|address
op_rshift
id|PAGE_SHIFT
)paren
op_amp
(paren
id|PTRS_PER_PTE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|pte_t
op_star
id|page
op_assign
(paren
id|pte_t
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
r_if
c_cond
(paren
id|page
)paren
(brace
multiline_comment|/*                                pmd_set(pmd,page);*/
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
id|_PAGE_TABLE
op_or
(paren
r_int
r_int
)paren
id|page
suffix:semicolon
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
dot
id|reserved
op_assign
l_int|1
suffix:semicolon
r_return
id|page
op_plus
id|address
suffix:semicolon
)brace
multiline_comment|/*&t;&t;&t;pmd_set(pmd, BAD_PAGETABLE);*/
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
id|_PAGE_TABLE
op_or
(paren
r_int
r_int
)paren
id|BAD_PAGETABLE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bad pmd in pte_alloc: %08lx&bslash;n&quot;
comma
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
)paren
suffix:semicolon
multiline_comment|/*&t;&t;pmd_set(pmd, (pte_t *) BAD_PAGETABLE);&t;&t;*/
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
id|_PAGE_TABLE
op_or
(paren
r_int
r_int
)paren
id|BAD_PAGETABLE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
(paren
id|pte_t
op_star
)paren
id|pmd_page
c_func
(paren
op_star
id|pmd
)paren
op_plus
id|address
suffix:semicolon
)brace
multiline_comment|/*&n; * allocating and freeing a pmd is trivial: the 1-entry pmd is&n; * inside the pgd, so has no extra memory associated with it.&n; */
DECL|function|pmd_free_kernel
r_extern
r_inline
r_void
id|pmd_free_kernel
c_func
(paren
id|pmd_t
op_star
id|pmd
)paren
(brace
)brace
DECL|function|pmd_alloc_kernel
r_extern
r_inline
id|pmd_t
op_star
id|pmd_alloc_kernel
c_func
(paren
id|pgd_t
op_star
id|pgd
comma
r_int
r_int
id|address
)paren
(brace
r_return
(paren
id|pmd_t
op_star
)paren
id|pgd
suffix:semicolon
)brace
DECL|function|pte_free
r_extern
r_inline
r_void
id|pte_free
c_func
(paren
id|pte_t
op_star
id|pte
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|pte
)paren
suffix:semicolon
)brace
DECL|function|pte_alloc
r_extern
r_inline
id|pte_t
op_star
id|pte_alloc
c_func
(paren
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|address
)paren
(brace
id|address
op_assign
(paren
id|address
op_rshift
id|PAGE_SHIFT
)paren
op_amp
(paren
id|PTRS_PER_PTE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|pte_t
op_star
id|page
op_assign
(paren
id|pte_t
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
r_if
c_cond
(paren
id|page
)paren
(brace
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
id|_PAGE_TABLE
op_or
(paren
r_int
r_int
)paren
id|page
suffix:semicolon
r_return
id|page
op_plus
id|address
suffix:semicolon
)brace
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
id|_PAGE_TABLE
op_or
(paren
r_int
r_int
)paren
id|BAD_PAGETABLE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bad pmd in pte_alloc: %08lx&bslash;n&quot;
comma
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
)paren
suffix:semicolon
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
op_assign
id|_PAGE_TABLE
op_or
(paren
r_int
r_int
)paren
id|BAD_PAGETABLE
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
(paren
id|pte_t
op_star
)paren
id|pmd_page
c_func
(paren
op_star
id|pmd
)paren
op_plus
id|address
suffix:semicolon
)brace
multiline_comment|/*&n; * allocating and freeing a pmd is trivial: the 1-entry pmd is&n; * inside the pgd, so has no extra memory associated with it.&n; */
DECL|function|pmd_free
r_extern
r_inline
r_void
id|pmd_free
c_func
(paren
id|pmd_t
op_star
id|pmd
)paren
(brace
)brace
DECL|function|pmd_alloc
r_extern
r_inline
id|pmd_t
op_star
id|pmd_alloc
c_func
(paren
id|pgd_t
op_star
id|pgd
comma
r_int
r_int
id|address
)paren
(brace
r_return
(paren
id|pmd_t
op_star
)paren
id|pgd
suffix:semicolon
)brace
DECL|function|pgd_free
r_extern
r_inline
r_void
id|pgd_free
c_func
(paren
id|pgd_t
op_star
id|pgd
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|pgd
)paren
suffix:semicolon
)brace
DECL|function|pgd_alloc
r_extern
r_inline
id|pgd_t
op_star
id|pgd_alloc
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|pgd_t
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_extern
id|pgd_t
id|swapper_pg_dir
(braket
l_int|1024
op_star
l_int|8
)braket
suffix:semicolon
multiline_comment|/*extern pgd_t *swapper_pg_dir;*/
multiline_comment|/*&n; * Software maintained MMU tables may have changed -- update the&n; * hardware [aka cache]&n; */
DECL|function|update_mmu_cache
r_extern
r_inline
r_void
id|update_mmu_cache
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
id|pte_t
id|_pte
)paren
(brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;Update MMU cache - VMA: %x, Addr: %x, PTE: %x&bslash;n&quot;
comma
id|vma
comma
id|address
comma
op_star
(paren
r_int
op_star
)paren
op_amp
id|_pte
)paren
suffix:semicolon
id|_printk
c_func
(paren
l_string|&quot;Update MMU cache - VMA: %x, Addr: %x, PTE: %x&bslash;n&quot;
comma
id|vma
comma
id|address
comma
op_star
(paren
r_int
op_star
)paren
op_amp
id|_pte
)paren
suffix:semicolon
multiline_comment|/*&t;MMU_hash_page(&amp;(vma-&gt;vm_task)-&gt;tss, address &amp; PAGE_MASK, (pte *)&amp;_pte);*/
macro_line|#endif&t;
id|MMU_hash_page
c_func
(paren
op_amp
(paren
id|current
)paren
op_member_access_from_pointer
id|tss
comma
id|address
op_amp
id|PAGE_MASK
comma
(paren
id|pte
op_star
)paren
op_amp
id|_pte
)paren
suffix:semicolon
)brace
macro_line|#ifdef _SCHED_INIT_
DECL|macro|INIT_MMAP
mdefine_line|#define INIT_MMAP { &amp;init_task, 0, 0x40000000, PAGE_SHARED, VM_READ | VM_WRITE | VM_EXEC }
macro_line|#endif&t;
DECL|macro|SWP_TYPE
mdefine_line|#define SWP_TYPE(entry) (((entry) &gt;&gt; 1) &amp; 0x7f)
DECL|macro|SWP_OFFSET
mdefine_line|#define SWP_OFFSET(entry) ((entry) &gt;&gt; 8)
DECL|macro|SWP_ENTRY
mdefine_line|#define SWP_ENTRY(type,offset) (((type) &lt;&lt; 1) | ((offset) &lt;&lt; 8))
macro_line|#endif /* _PPC_PAGE_H */
eof
