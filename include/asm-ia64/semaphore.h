macro_line|#ifndef _ASM_IA64_SEMAPHORE_H
DECL|macro|_ASM_IA64_SEMAPHORE_H
mdefine_line|#define _ASM_IA64_SEMAPHORE_H
multiline_comment|/*&n; * Copyright (C) 1998-2000 Hewlett-Packard Co&n; * Copyright (C) 1998-2000 David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; */
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
DECL|struct|semaphore
r_struct
id|semaphore
(brace
DECL|member|count
id|atomic_t
id|count
suffix:semicolon
DECL|member|sleepers
r_int
id|sleepers
suffix:semicolon
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
DECL|member|__magic
r_int
id|__magic
suffix:semicolon
multiline_comment|/* initialized by __SEM_DEBUG_INIT() */
macro_line|#endif
)brace
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
DECL|macro|__SEM_DEBUG_INIT
macro_line|# define __SEM_DEBUG_INIT(name)&t;&t;, (long) &amp;(name).__magic
macro_line|#else
DECL|macro|__SEM_DEBUG_INIT
macro_line|# define __SEM_DEBUG_INIT(name)
macro_line|#endif
DECL|macro|__SEMAPHORE_INITIALIZER
mdefine_line|#define __SEMAPHORE_INITIALIZER(name,count)&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ATOMIC_INIT(count), 0, __WAIT_QUEUE_HEAD_INITIALIZER((name).wait)&t;&bslash;&n;&t;__SEM_DEBUG_INIT(name)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}
DECL|macro|__MUTEX_INITIALIZER
mdefine_line|#define __MUTEX_INITIALIZER(name)&t;__SEMAPHORE_INITIALIZER(name,1)
DECL|macro|__DECLARE_SEMAPHORE_GENERIC
mdefine_line|#define __DECLARE_SEMAPHORE_GENERIC(name,count)&t;&t;&t;&t;&t;&bslash;&n;&t;struct semaphore name = __SEMAPHORE_INITIALIZER(name, count)
DECL|macro|DECLARE_MUTEX
mdefine_line|#define DECLARE_MUTEX(name)&t;&t;__DECLARE_SEMAPHORE_GENERIC(name, 1)
DECL|macro|DECLARE_MUTEX_LOCKED
mdefine_line|#define DECLARE_MUTEX_LOCKED(name)&t;__DECLARE_SEMAPHORE_GENERIC(name, 0)
r_static
r_inline
r_void
DECL|function|sema_init
id|sema_init
(paren
r_struct
id|semaphore
op_star
id|sem
comma
r_int
id|val
)paren
(brace
op_star
id|sem
op_assign
(paren
r_struct
id|semaphore
)paren
id|__SEMAPHORE_INITIALIZER
c_func
(paren
op_star
id|sem
comma
id|val
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|init_MUTEX
id|init_MUTEX
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
id|sema_init
c_func
(paren
id|sem
comma
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|init_MUTEX_LOCKED
id|init_MUTEX_LOCKED
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
id|sema_init
c_func
(paren
id|sem
comma
l_int|0
)paren
suffix:semicolon
)brace
r_extern
r_void
id|__down
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
suffix:semicolon
r_extern
r_int
id|__down_interruptible
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
suffix:semicolon
r_extern
r_int
id|__down_trylock
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
suffix:semicolon
r_extern
r_void
id|__up
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
suffix:semicolon
r_extern
id|spinlock_t
id|semaphore_wake_lock
suffix:semicolon
multiline_comment|/*&n; * Atomically decrement the semaphore&squot;s count.  If it goes negative,&n; * block the calling thread in the TASK_UNINTERRUPTIBLE state.&n; */
r_static
r_inline
r_void
DECL|function|down
id|down
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC
c_func
(paren
id|sem-&gt;__magic
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|atomic_dec_return
c_func
(paren
op_amp
id|sem-&gt;count
)paren
OL
l_int|0
)paren
id|__down
c_func
(paren
id|sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Atomically decrement the semaphore&squot;s count.  If it goes negative,&n; * block the calling thread in the TASK_INTERRUPTIBLE state.&n; */
r_static
r_inline
r_int
DECL|function|down_interruptible
id|down_interruptible
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC
c_func
(paren
id|sem-&gt;__magic
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|atomic_dec_return
c_func
(paren
op_amp
id|sem-&gt;count
)paren
OL
l_int|0
)paren
id|ret
op_assign
id|__down_interruptible
c_func
(paren
id|sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|down_trylock
id|down_trylock
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC
c_func
(paren
id|sem-&gt;__magic
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|atomic_dec_return
c_func
(paren
op_amp
id|sem-&gt;count
)paren
OL
l_int|0
)paren
id|ret
op_assign
id|__down_trylock
c_func
(paren
id|sem
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|up
id|up
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC
c_func
(paren
id|sem-&gt;__magic
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|atomic_inc_return
c_func
(paren
op_amp
id|sem-&gt;count
)paren
op_le
l_int|0
)paren
id|__up
c_func
(paren
id|sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * rw mutexes (should that be mutices? =) -- throw rw spinlocks and&n; * semaphores together, and this is what we end up with...&n; *&n; * The lock is initialized to BIAS.  This way, a writer subtracts BIAS&n; * ands gets 0 for the case of an uncontended lock.  Readers decrement&n; * by 1 and see a positive value when uncontended, negative if there&n; * are writers waiting (in which case it goes to sleep).  BIAS must be&n; * chosen such that subtracting BIAS once per CPU will result either&n; * in zero (uncontended case) or in a negative value (contention&n; * case).  On the other hand, BIAS must be at least as big as the&n; * number of processes in the system.&n; *&n; * On IA-64, we use a BIAS value of 0x100000000, which supports up to&n; * 2 billion (2^31) processors and 4 billion processes.&n; *&n; * In terms of fairness, when there is heavy use of the lock, we want&n; * to see the lock being passed back and forth between readers and&n; * writers (like in a producer/consumer style of communication).&n; *&n; *&t;      -ben (with clarifications &amp; IA-64 comments by davidm)&n; */
DECL|macro|RW_LOCK_BIAS
mdefine_line|#define RW_LOCK_BIAS&t;&t;0x100000000ul
DECL|struct|rw_semaphore
r_struct
id|rw_semaphore
(brace
DECL|member|count
r_volatile
r_int
id|count
suffix:semicolon
DECL|member|write_bias_granted
r_volatile
id|__u8
id|write_bias_granted
suffix:semicolon
DECL|member|read_bias_granted
r_volatile
id|__u8
id|read_bias_granted
suffix:semicolon
DECL|member|pad1
id|__u16
id|pad1
suffix:semicolon
DECL|member|pad2
id|__u32
id|pad2
suffix:semicolon
DECL|member|wait
id|wait_queue_head_t
id|wait
suffix:semicolon
DECL|member|write_bias_wait
id|wait_queue_head_t
id|write_bias_wait
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
DECL|member|__magic
r_int
id|__magic
suffix:semicolon
DECL|member|readers
id|atomic_t
id|readers
suffix:semicolon
DECL|member|writers
id|atomic_t
id|writers
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
DECL|macro|__RWSEM_DEBUG_INIT
macro_line|# define __RWSEM_DEBUG_INIT&t;, ATOMIC_INIT(0), ATOMIC_INIT(0)
macro_line|#else
DECL|macro|__RWSEM_DEBUG_INIT
macro_line|# define __RWSEM_DEBUG_INIT
macro_line|#endif
DECL|macro|__RWSEM_INITIALIZER
mdefine_line|#define __RWSEM_INITIALIZER(name,count)&t;&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;(count), 0, 0, 0, 0, __WAIT_QUEUE_HEAD_INITIALIZER((name).wait),&t;&bslash;&n;&t;__WAIT_QUEUE_HEAD_INITIALIZER((name).write_bias_wait)&t;&t;&t;&bslash;&n;&t;__SEM_DEBUG_INIT(name) __RWSEM_DEBUG_INIT&t;&t;&t;&t;&bslash;&n;}
DECL|macro|__DECLARE_RWSEM_GENERIC
mdefine_line|#define __DECLARE_RWSEM_GENERIC(name,count)&t;&t;&t;&t;&t;&bslash;&n;&t;struct rw_semaphore name = __RWSEM_INITIALIZER(name,count)
DECL|macro|DECLARE_RWSEM
mdefine_line|#define DECLARE_RWSEM(name)&t;&t;&t;__DECLARE_RWSEM_GENERIC(name, RW_LOCK_BIAS)
DECL|macro|DECLARE_RWSEM_READ_LOCKED
mdefine_line|#define DECLARE_RWSEM_READ_LOCKED(name)&t;&t;__DECLARE_RWSEM_GENERIC(name, RW_LOCK_BIAS - 1)
DECL|macro|DECLARE_RWSEM_WRITE_LOCKED
mdefine_line|#define DECLARE_RWSEM_WRITE_LOCKED(name)&t;__DECLARE_RWSEM_GENERIC(name, 0)
r_extern
r_void
id|__down_read_failed
(paren
r_struct
id|rw_semaphore
op_star
id|sem
comma
r_int
id|count
)paren
suffix:semicolon
r_extern
r_void
id|__down_write_failed
(paren
r_struct
id|rw_semaphore
op_star
id|sem
comma
r_int
id|count
)paren
suffix:semicolon
r_extern
r_void
id|__rwsem_wake
(paren
r_struct
id|rw_semaphore
op_star
id|sem
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_inline
r_void
DECL|function|init_rwsem
id|init_rwsem
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
id|sem-&gt;count
op_assign
id|RW_LOCK_BIAS
suffix:semicolon
id|sem-&gt;read_bias_granted
op_assign
l_int|0
suffix:semicolon
id|sem-&gt;write_bias_granted
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|sem-&gt;write_bias_wait
)paren
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
id|sem-&gt;__magic
op_assign
(paren
r_int
)paren
op_amp
id|sem-&gt;__magic
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|sem-&gt;readers
comma
l_int|0
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|sem-&gt;writers
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_inline
r_void
DECL|function|down_read
id|down_read
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_int
id|count
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC
c_func
(paren
id|sem-&gt;__magic
)paren
suffix:semicolon
macro_line|#endif
id|count
op_assign
id|ia64_fetch_and_add
c_func
(paren
op_minus
l_int|1
comma
op_amp
id|sem-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
id|__down_read_failed
c_func
(paren
id|sem
comma
id|count
)paren
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
r_if
c_cond
(paren
id|sem-&gt;write_bias_granted
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;writers
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|sem-&gt;readers
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_inline
r_void
DECL|function|down_write
id|down_write
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_int
id|old_count
comma
id|new_count
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC
c_func
(paren
id|sem-&gt;__magic
)paren
suffix:semicolon
macro_line|#endif
r_do
(brace
id|old_count
op_assign
id|sem-&gt;count
suffix:semicolon
id|new_count
op_assign
id|old_count
op_minus
id|RW_LOCK_BIAS
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cmpxchg_acq
c_func
(paren
op_amp
id|sem-&gt;count
comma
id|old_count
comma
id|new_count
)paren
op_ne
id|old_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_count
op_ne
l_int|0
)paren
id|__down_write_failed
c_func
(paren
id|sem
comma
id|new_count
)paren
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;writers
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;readers
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem-&gt;read_bias_granted
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem-&gt;write_bias_granted
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|sem-&gt;writers
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * When a reader does a release, the only significant&n; * case is when there was a writer waiting, and we&squot;ve&n; * bumped the count to 0: we must wake the writer up.&n; */
r_static
r_inline
r_void
DECL|function|__up_read
id|__up_read
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_int
id|count
suffix:semicolon
id|count
op_assign
id|ia64_fetch_and_add
c_func
(paren
l_int|1
comma
op_amp
id|sem-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
multiline_comment|/*&n;&t;&t; * Other processes are blocked already; resolve&n;&t;&t; * contention by letting either a writer or a reader&n;&t;&t; * proceed...&n;&t;&t; */
id|__rwsem_wake
c_func
(paren
id|sem
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Releasing the writer is easy -- just release it and&n; * wake up any sleepers.&n; */
r_static
r_inline
r_void
DECL|function|__up_write
id|__up_write
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
r_int
id|old_count
comma
id|new_count
suffix:semicolon
r_do
(brace
id|old_count
op_assign
id|sem-&gt;count
suffix:semicolon
id|new_count
op_assign
id|old_count
op_plus
id|RW_LOCK_BIAS
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cmpxchg_rel
c_func
(paren
op_amp
id|sem-&gt;count
comma
id|old_count
comma
id|new_count
)paren
op_ne
id|old_count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Note: new_count &lt;u RW_LOCK_BIAS &lt;=&gt; old_count &lt; 0 &amp;&amp; new_count &gt;= 0.&n;&t; *&t; (where &lt;u is &quot;unsigned less-than&quot;).&n;&t; */
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|new_count
OL
id|RW_LOCK_BIAS
)paren
multiline_comment|/* someone is blocked already, resolve contention... */
id|__rwsem_wake
c_func
(paren
id|sem
comma
id|new_count
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|up_read
id|up_read
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
macro_line|#if WAITQUEUE_DEBUG
r_if
c_cond
(paren
id|sem-&gt;write_bias_granted
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;writers
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|sem-&gt;readers
)paren
suffix:semicolon
macro_line|#endif
id|__up_read
c_func
(paren
id|sem
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|up_write
id|up_write
(paren
r_struct
id|rw_semaphore
op_star
id|sem
)paren
(brace
macro_line|#if WAITQUEUE_DEBUG
r_if
c_cond
(paren
id|sem-&gt;read_bias_granted
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sem-&gt;write_bias_granted
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;readers
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;writers
)paren
op_ne
l_int|1
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|sem-&gt;writers
)paren
suffix:semicolon
macro_line|#endif
id|__up_write
c_func
(paren
id|sem
)paren
suffix:semicolon
)brace
macro_line|#endif /* _ASM_IA64_SEMAPHORE_H */
eof
