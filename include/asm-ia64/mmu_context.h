macro_line|#ifndef _ASM_IA64_MMU_CONTEXT_H
DECL|macro|_ASM_IA64_MMU_CONTEXT_H
mdefine_line|#define _ASM_IA64_MMU_CONTEXT_H
multiline_comment|/*&n; * Copyright (C) 1998, 1999 Hewlett-Packard Co&n; * Copyright (C) 1998, 1999 David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
multiline_comment|/*&n; * Routines to manage the allocation of task context numbers.  Task&n; * context numbers are used to reduce or eliminate the need to perform&n; * TLB flushes due to context switches.  Context numbers are&n; * implemented using ia-64 region ids.  Since ia-64 TLBs do not&n; * guarantee that the region number is checked when performing a TLB&n; * lookup, we need to assign a unique region id to each region in a&n; * process.  We use the least significant three bits in a region id&n; * for this purpose.  On processors where the region number is checked&n; * in TLB lookups, we can get back those two bits by defining&n; * CONFIG_IA64_TLB_CHECKS_REGION_NUMBER.  The macro&n; * IA64_REGION_ID_BITS gives the number of bits in a region id.  The&n; * architecture manual guarantees this number to be in the range&n; * 18-24.&n; *&n; * A context number has the following format:&n; *&n; *  +--------------------+---------------------+&n; *  |  generation number |    region id        |&n; *  +--------------------+---------------------+&n; *&n; * A context number of 0 is considered &quot;invalid&quot;.&n; *&n; * The generation number is incremented whenever we end up having used&n; * up all available region ids.  At that point with flush the entire&n; * TLB and reuse the first region id.  The new generation number&n; * ensures that when we context switch back to an old process, we do&n; * not inadvertently end up using its possibly reused region id.&n; * Instead, we simply allocate a new region id for that process.&n; *&n; * Copyright (C) 1998 David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; */
DECL|macro|IA64_REGION_ID_KERNEL
mdefine_line|#define IA64_REGION_ID_KERNEL&t;0 /* the kernel&squot;s region id (tlb.c depends on this being 0) */
DECL|macro|IA64_REGION_ID_BITS
mdefine_line|#define IA64_REGION_ID_BITS&t;18
macro_line|#ifdef CONFIG_IA64_TLB_CHECKS_REGION_NUMBER
DECL|macro|IA64_HW_CONTEXT_BITS
macro_line|# define IA64_HW_CONTEXT_BITS&t;IA64_REGION_ID_BITS
macro_line|#else
DECL|macro|IA64_HW_CONTEXT_BITS
macro_line|# define IA64_HW_CONTEXT_BITS&t;(IA64_REGION_ID_BITS - 3)
macro_line|#endif
DECL|macro|IA64_HW_CONTEXT_MASK
mdefine_line|#define IA64_HW_CONTEXT_MASK&t;((1UL &lt;&lt; IA64_HW_CONTEXT_BITS) - 1)
r_extern
r_int
r_int
id|ia64_next_context
suffix:semicolon
r_extern
r_void
id|get_new_mmu_context
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
suffix:semicolon
r_extern
r_inline
r_int
r_int
DECL|function|ia64_rid
id|ia64_rid
(paren
r_int
r_int
id|context
comma
r_int
r_int
id|region_addr
)paren
(brace
macro_line|# ifdef CONFIG_IA64_TLB_CHECKS_REGION_NUMBER
r_return
id|context
suffix:semicolon
macro_line|# else
r_return
id|context
op_lshift
l_int|3
op_or
(paren
id|region_addr
op_rshift
l_int|61
)paren
suffix:semicolon
macro_line|# endif
)brace
r_extern
r_inline
r_void
DECL|function|get_mmu_context
id|get_mmu_context
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
multiline_comment|/* check if our ASN is of an older generation and thus invalid: */
r_if
c_cond
(paren
(paren
(paren
id|mm-&gt;context
op_xor
id|ia64_next_context
)paren
op_amp
op_complement
id|IA64_HW_CONTEXT_MASK
)paren
op_ne
l_int|0
)paren
(brace
id|get_new_mmu_context
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
)brace
r_extern
r_inline
r_void
DECL|function|init_new_context
id|init_new_context
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
id|mm-&gt;context
op_assign
l_int|0
suffix:semicolon
)brace
r_extern
r_inline
r_void
DECL|function|destroy_context
id|destroy_context
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
multiline_comment|/* Nothing to do.  */
)brace
r_extern
r_inline
r_void
DECL|function|reload_context
id|reload_context
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_int
r_int
id|rid
suffix:semicolon
r_int
r_int
id|rid_incr
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|rr0
comma
id|rr1
comma
id|rr2
comma
id|rr3
comma
id|rr4
suffix:semicolon
id|rid
op_assign
(paren
id|mm-&gt;context
op_amp
id|IA64_HW_CONTEXT_MASK
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_IA64_TLB_CHECKS_REGION_NUMBER
id|rid
op_lshift_assign
l_int|3
suffix:semicolon
multiline_comment|/* make space for encoding the region number */
id|rid_incr
op_assign
l_int|1
op_lshift
l_int|8
suffix:semicolon
macro_line|#endif
multiline_comment|/* encode the region id, preferred page size, and VHPT enable bit: */
id|rr0
op_assign
(paren
id|rid
op_lshift
l_int|8
)paren
op_or
(paren
id|PAGE_SHIFT
op_lshift
l_int|2
)paren
op_or
l_int|1
suffix:semicolon
id|rr1
op_assign
id|rr0
op_plus
l_int|1
op_star
id|rid_incr
suffix:semicolon
id|rr2
op_assign
id|rr0
op_plus
l_int|2
op_star
id|rid_incr
suffix:semicolon
id|rr3
op_assign
id|rr0
op_plus
l_int|3
op_star
id|rid_incr
suffix:semicolon
id|rr4
op_assign
id|rr0
op_plus
l_int|4
op_star
id|rid_incr
suffix:semicolon
id|ia64_set_rr
c_func
(paren
l_int|0x0000000000000000
comma
id|rr0
)paren
suffix:semicolon
id|ia64_set_rr
c_func
(paren
l_int|0x2000000000000000
comma
id|rr1
)paren
suffix:semicolon
id|ia64_set_rr
c_func
(paren
l_int|0x4000000000000000
comma
id|rr2
)paren
suffix:semicolon
id|ia64_set_rr
c_func
(paren
l_int|0x6000000000000000
comma
id|rr3
)paren
suffix:semicolon
id|ia64_set_rr
c_func
(paren
l_int|0x8000000000000000
comma
id|rr4
)paren
suffix:semicolon
id|ia64_insn_group_barrier
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* srlz.i implies srlz.d */
id|ia64_insn_group_barrier
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Switch from address space PREV to address space NEXT.  Note that&n; * TSK may be NULL.&n; */
r_static
r_inline
r_void
DECL|function|switch_mm
id|switch_mm
(paren
r_struct
id|mm_struct
op_star
id|prev
comma
r_struct
id|mm_struct
op_star
id|next
comma
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
id|cpu
)paren
(brace
multiline_comment|/*&n;&t; * We may get interrupts here, but that&squot;s OK because interrupt&n;&t; * handlers cannot touch user-space.&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;mov ar.k7=%0&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|__pa
c_func
(paren
id|next-&gt;pgd
)paren
)paren
)paren
suffix:semicolon
id|get_mmu_context
c_func
(paren
id|next
)paren
suffix:semicolon
id|reload_context
c_func
(paren
id|next
)paren
suffix:semicolon
)brace
DECL|macro|activate_mm
mdefine_line|#define activate_mm(prev,next)&t;&t;&t;&t;&t;&bslash;&n;&t;switch_mm((prev), (next), NULL, smp_processor_id())
macro_line|#endif /* _ASM_IA64_MMU_CONTEXT_H */
eof
