macro_line|#ifndef _ASM_IA64_MMU_CONTEXT_H
DECL|macro|_ASM_IA64_MMU_CONTEXT_H
mdefine_line|#define _ASM_IA64_MMU_CONTEXT_H
multiline_comment|/*&n; * Copyright (C) 1998-2000 Hewlett-Packard Co&n; * Copyright (C) 1998-2000 David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
multiline_comment|/*&n; * Routines to manage the allocation of task context numbers.  Task&n; * context numbers are used to reduce or eliminate the need to perform&n; * TLB flushes due to context switches.  Context numbers are&n; * implemented using ia-64 region ids.  Since ia-64 TLBs do not&n; * guarantee that the region number is checked when performing a TLB&n; * lookup, we need to assign a unique region id to each region in a&n; * process.  We use the least significant three bits in a region id&n; * for this purpose.  On processors where the region number is checked&n; * in TLB lookups, we can get back those two bits by defining&n; * CONFIG_IA64_TLB_CHECKS_REGION_NUMBER.  The macro&n; * IA64_REGION_ID_BITS gives the number of bits in a region id.  The&n; * architecture manual guarantees this number to be in the range&n; * 18-24.&n; *&n; * Copyright (C) 1998 David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; */
DECL|macro|IA64_REGION_ID_KERNEL
mdefine_line|#define IA64_REGION_ID_KERNEL&t;0 /* the kernel&squot;s region id (tlb.c depends on this being 0) */
DECL|struct|ia64_ctx
r_struct
id|ia64_ctx
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|next
r_int
r_int
id|next
suffix:semicolon
multiline_comment|/* next context number to use */
DECL|member|limit
r_int
r_int
id|limit
suffix:semicolon
multiline_comment|/* next &gt;= limit =&gt; must call wrap_mmu_context() */
DECL|member|max_ctx
r_int
r_int
id|max_ctx
suffix:semicolon
multiline_comment|/* max. context value supported by all CPUs */
)brace
suffix:semicolon
r_extern
r_struct
id|ia64_ctx
id|ia64_ctx
suffix:semicolon
r_extern
r_void
id|wrap_mmu_context
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
suffix:semicolon
r_static
r_inline
r_void
DECL|function|enter_lazy_tlb
id|enter_lazy_tlb
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_struct
id|task_struct
op_star
id|tsk
comma
r_int
id|cpu
)paren
(brace
)brace
r_static
r_inline
r_int
r_int
DECL|function|ia64_rid
id|ia64_rid
(paren
r_int
r_int
id|context
comma
r_int
r_int
id|region_addr
)paren
(brace
r_return
id|context
op_lshift
l_int|3
op_or
(paren
id|region_addr
op_rshift
l_int|61
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|get_new_mmu_context
id|get_new_mmu_context
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|ia64_ctx.lock
)paren
suffix:semicolon
(brace
r_if
c_cond
(paren
id|ia64_ctx.next
op_ge
id|ia64_ctx.limit
)paren
id|wrap_mmu_context
c_func
(paren
id|mm
)paren
suffix:semicolon
id|mm-&gt;context
op_assign
id|ia64_ctx.next
op_increment
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|ia64_ctx.lock
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|get_mmu_context
id|get_mmu_context
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
multiline_comment|/* check if our ASN is of an older generation and thus invalid: */
r_if
c_cond
(paren
id|mm-&gt;context
op_eq
l_int|0
)paren
id|get_new_mmu_context
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|init_new_context
id|init_new_context
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
id|mm-&gt;context
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|destroy_context
id|destroy_context
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
multiline_comment|/* Nothing to do.  */
)brace
r_static
r_inline
r_void
DECL|function|reload_context
id|reload_context
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_int
r_int
id|rid
suffix:semicolon
r_int
r_int
id|rid_incr
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|rr0
comma
id|rr1
comma
id|rr2
comma
id|rr3
comma
id|rr4
suffix:semicolon
id|rid
op_assign
id|mm-&gt;context
op_lshift
l_int|3
suffix:semicolon
multiline_comment|/* make space for encoding the region number */
id|rid_incr
op_assign
l_int|1
op_lshift
l_int|8
suffix:semicolon
multiline_comment|/* encode the region id, preferred page size, and VHPT enable bit: */
id|rr0
op_assign
(paren
id|rid
op_lshift
l_int|8
)paren
op_or
(paren
id|PAGE_SHIFT
op_lshift
l_int|2
)paren
op_or
l_int|1
suffix:semicolon
id|rr1
op_assign
id|rr0
op_plus
l_int|1
op_star
id|rid_incr
suffix:semicolon
id|rr2
op_assign
id|rr0
op_plus
l_int|2
op_star
id|rid_incr
suffix:semicolon
id|rr3
op_assign
id|rr0
op_plus
l_int|3
op_star
id|rid_incr
suffix:semicolon
id|rr4
op_assign
id|rr0
op_plus
l_int|4
op_star
id|rid_incr
suffix:semicolon
id|ia64_set_rr
c_func
(paren
l_int|0x0000000000000000
comma
id|rr0
)paren
suffix:semicolon
id|ia64_set_rr
c_func
(paren
l_int|0x2000000000000000
comma
id|rr1
)paren
suffix:semicolon
id|ia64_set_rr
c_func
(paren
l_int|0x4000000000000000
comma
id|rr2
)paren
suffix:semicolon
id|ia64_set_rr
c_func
(paren
l_int|0x6000000000000000
comma
id|rr3
)paren
suffix:semicolon
id|ia64_set_rr
c_func
(paren
l_int|0x8000000000000000
comma
id|rr4
)paren
suffix:semicolon
id|ia64_insn_group_barrier
c_func
(paren
)paren
suffix:semicolon
id|ia64_srlz_i
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* srlz.i implies srlz.d */
id|ia64_insn_group_barrier
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Switch from address space PREV to address space NEXT.&n; */
r_static
r_inline
r_void
DECL|function|activate_mm
id|activate_mm
(paren
r_struct
id|mm_struct
op_star
id|prev
comma
r_struct
id|mm_struct
op_star
id|next
)paren
(brace
multiline_comment|/*&n;&t; * We may get interrupts here, but that&squot;s OK because interrupt&n;&t; * handlers cannot touch user-space.&n;&t; */
id|__asm__
id|__volatile__
(paren
l_string|&quot;mov ar.k7=%0&quot;
op_scope_resolution
l_string|&quot;r&quot;
(paren
id|__pa
c_func
(paren
id|next-&gt;pgd
)paren
)paren
)paren
suffix:semicolon
id|get_mmu_context
c_func
(paren
id|next
)paren
suffix:semicolon
id|reload_context
c_func
(paren
id|next
)paren
suffix:semicolon
)brace
DECL|macro|switch_mm
mdefine_line|#define switch_mm(prev_mm,next_mm,next_task,cpu)&t;activate_mm(prev_mm, next_mm)
macro_line|#endif /* _ASM_IA64_MMU_CONTEXT_H */
eof
