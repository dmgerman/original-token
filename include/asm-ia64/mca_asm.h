multiline_comment|/*&n; * File: &t;mca_asm.h&n; *&n; * Copyright (C) 1999 Silicon Graphics, Inc.&n; * Copyright (C) Vijay Chander (vijay@engr.sgi.com)&n; * Copyright (C) Srinivasa Thirumalachar &lt;sprasad@engr.sgi.com&gt;&n; * Copyright (C) 2000 Hewlett-Packard Co.&n; * Copyright (C) 2000 David Mosberger-Tang &lt;davidm@hpl.hp.com&gt;&n; */
macro_line|#ifndef _ASM_IA64_MCA_ASM_H
DECL|macro|_ASM_IA64_MCA_ASM_H
mdefine_line|#define _ASM_IA64_MCA_ASM_H
DECL|macro|PSR_IC
mdefine_line|#define PSR_IC&t;&t;13
DECL|macro|PSR_I
mdefine_line|#define PSR_I&t;&t;14
DECL|macro|PSR_DT
mdefine_line|#define&t;PSR_DT&t;&t;17
DECL|macro|PSR_RT
mdefine_line|#define PSR_RT&t;&t;27
DECL|macro|PSR_IT
mdefine_line|#define PSR_IT&t;&t;36
DECL|macro|PSR_BN
mdefine_line|#define PSR_BN&t;&t;44
multiline_comment|/*&n; * This macro converts a instruction virtual address to a physical address&n; * Right now for simulation purposes the virtual addresses are&n; * direct mapped to physical addresses.&n; * &t;1. Lop off bits 61 thru 63 in the virtual address&n; */
DECL|macro|INST_VA_TO_PA
mdefine_line|#define INST_VA_TO_PA(addr)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;dep &t;addr&t;= 0, addr, 61, 3;
multiline_comment|/*&n; * This macro converts a data virtual address to a physical address&n; * Right now for simulation purposes the virtual addresses are&n; * direct mapped to physical addresses.&n; * &t;1. Lop off bits 61 thru 63 in the virtual address&n; */
DECL|macro|DATA_VA_TO_PA
mdefine_line|#define DATA_VA_TO_PA(addr)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;dep &t;addr&t;= 0, addr, 61, 3;
multiline_comment|/*&n; * This macro converts a data physical address to a virtual address&n; * Right now for simulation purposes the virtual addresses are&n; * direct mapped to physical addresses.&n; *&t;1. Put 0x7 in bits 61 thru 63.&n; */
DECL|macro|DATA_PA_TO_VA
mdefine_line|#define DATA_PA_TO_VA(addr,temp)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;temp&t;= 0x7&t;;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;dep&t;addr&t;= temp, addr, 61, 3;
multiline_comment|/*&n; * This macro jumps to the instruction at the given virtual address&n; * and starts execution in physical mode with all the address&n; * translations turned off.&n; *&t;1.&t;Save the current psr&n; *&t;2. &t;Make sure that all the upper 32 bits are off&n; *&n; *&t;3.&t;Clear the interrupt enable and interrupt state collection bits&n; *&t;&t;in the psr before updating the ipsr and iip.&n; *&t;&n; *&t;4.&t;Turn off the instruction, data and rse translation bits of the psr&n; *&t;&t;and store the new value into ipsr&n; *&t;&t;Also make sure that the interrupts are disabled.&n; *&t;&t;Ensure that we are in little endian mode.&n; *&t;&t;[psr.{rt, it, dt, i, be} = 0]&n; *&n; *&t;5.&t;Get the physical address corresponding to the virtual address&n; *&t;&t;of the next instruction bundle and put it in iip.&n; *&t;&t;(Using magic numbers 24 and 40 in the deposint instruction since&n; *&t;&t; the IA64_SDK code directly maps to lower 24bits as physical address&n; *&t;&t; from a virtual address).&n; *&n; *&t;6.&t;Do an rfi to move the values from ipsr to psr and iip to ip.&n; */
DECL|macro|PHYSICAL_MODE_ENTER
mdefine_line|#define  PHYSICAL_MODE_ENTER(temp1, temp2, start_addr, old_psr)&t;&t;&t;&t;&bslash;&n;&t;mov&t;old_psr = psr;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;dep&t;old_psr = 0, old_psr, 32, 32;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;                                                                                &bslash;&n;&t;mov&t;ar.rsc = r0 ;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;temp2 = ar.bspstore;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;DATA_VA_TO_PA(temp2);&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;temp1 = ar.rnat;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;ar.bspstore = temp2;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;ar.rnat = temp1;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;temp1 = psr;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;temp2 = psr;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;                                                                                &bslash;&n;&t;dep&t;temp2 = 0, temp2, PSR_IC, 2;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;psr.l = temp2;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;srlz.d;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;dep&t;temp1 = 0, temp1, 32, 32;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n; &t;dep&t;temp1 = 0, temp1, PSR_IT, 1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n; &t;dep&t;temp1 = 0, temp1, PSR_DT, 1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n; &t;dep&t;temp1 = 0, temp1, PSR_RT, 1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;dep&t;temp1 = 0, temp1, PSR_I, 1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;movl&t;temp2 = start_addr;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;cr.ipsr = temp1;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;INST_VA_TO_PA(temp2);&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;cr.iip = temp2;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;cr.ifs = r0;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;DATA_VA_TO_PA(sp)&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;DATA_VA_TO_PA(gp)&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;srlz.i;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;nop&t;1;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;nop&t;2;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;nop&t;1;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;nop&t;2;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;rfi;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;
multiline_comment|/*&n; * This macro jumps to the instruction at the given virtual address&n; * and starts execution in virtual mode with all the address&n; * translations turned on.&n; *&t;1. &t;Get the old saved psr&n; *&t;&n; *&t;2. &t;Clear the interrupt enable and interrupt state collection bits&n; *&t;&t;in the current psr.&n; *&t;&n; *&t;3.&t;Set the instruction translation bit back in the old psr&n; *&t;&t;Note we have to do this since we are right now saving only the&n; *&t;&t;lower 32-bits of old psr.(Also the old psr has the data and&n; *&t;&t;rse translation bits on)&n; *&t;&n; *&t;4.&t;Set ipsr to this old_psr with &quot;it&quot; bit set and &quot;bn&quot; = 1.&n; *&n; *&t;5. &t;Set iip to the virtual address of the next instruction bundle.&n; *&n; *&t;6.&t;Do an rfi to move ipsr to psr and iip to ip.&n; */
DECL|macro|VIRTUAL_MODE_ENTER
mdefine_line|#define VIRTUAL_MODE_ENTER(temp1, temp2, start_addr, old_psr)&t;&t;&t;&t;&bslash;&n;&t;mov&t;temp2 = psr;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;dep&t;temp2 = 0, temp2, PSR_IC, 2;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;psr.l = temp2;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;ar.rsc = r0;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;srlz.d;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;temp2 = ar.bspstore;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;DATA_PA_TO_VA(temp2,temp1);&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;temp1 = ar.rnat;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;ar.bspstore = temp2;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;ar.rnat = temp1;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;temp1 = old_psr;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;temp2 = 1&t;;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;dep&t;temp1 = temp2, temp1, PSR_I,  1;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n; &t;dep&t;temp1 = temp2, temp1, PSR_IC, 1;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;dep&t;temp1 = temp2, temp1, PSR_IT, 1;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n; &t;dep&t;temp1 = temp2, temp1, PSR_DT, 1;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n; &t;dep&t;temp1 = temp2, temp1, PSR_RT, 1;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;dep&t;temp1 = temp2, temp1, PSR_BN, 1;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;                                                                                &bslash;&n;&t;mov     cr.ipsr = temp1;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;movl&t;temp2 = start_addr;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;mov&t;cr.iip = temp2;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;DATA_PA_TO_VA(sp, temp1);&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;DATA_PA_TO_VA(gp, temp2);&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;nop&t;1;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;nop&t;2;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;nop&t;1;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;rfi;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;;;
multiline_comment|/* &n; * The following offsets capture the order in which the&n; * RSE related registers from the old context are&n; * saved onto the new stack frame.&n; *&n; *&t;+-----------------------+&n; *&t;|NDIRTY [BSP - BSPSTORE]|&n; *&t;+-----------------------+&n; *&t;| &t;RNAT&t;      &t;|&n; *&t;+-----------------------+&n; *&t;| &t;BSPSTORE      &t;|&n; *&t;+-----------------------+&n; *&t;| &t;IFS&t;      &t;|&n; *&t;+-----------------------+&n; *&t;| &t;PFS&t;      &t;|&n; *&t;+-----------------------+&n; *&t;| &t;RSC&t;      &t;|&n; *&t;+-----------------------+ &lt;-------- Bottom of new stack frame&n; */
DECL|macro|rse_rsc_offset
mdefine_line|#define  rse_rsc_offset&t;&t;0
DECL|macro|rse_pfs_offset
mdefine_line|#define  rse_pfs_offset&t;&t;(rse_rsc_offset+0x08)
DECL|macro|rse_ifs_offset
mdefine_line|#define  rse_ifs_offset&t;&t;(rse_pfs_offset+0x08)
DECL|macro|rse_bspstore_offset
mdefine_line|#define  rse_bspstore_offset&t;(rse_ifs_offset+0x08)
DECL|macro|rse_rnat_offset
mdefine_line|#define  rse_rnat_offset&t;(rse_bspstore_offset+0x08)
DECL|macro|rse_ndirty_offset
mdefine_line|#define  rse_ndirty_offset&t;(rse_rnat_offset+0x08)
multiline_comment|/*&n; * rse_switch_context&n; *&n; *&t;1. Save old RSC onto the new stack frame&n; *&t;2. Save PFS onto new stack frame&n; *&t;3. Cover the old frame and start a new frame.&n; *&t;4. Save IFS onto new stack frame&n; *&t;5. Save the old BSPSTORE on the new stack frame&n; *&t;6. Save the old RNAT on the new stack frame&n; *&t;7. Write BSPSTORE with the new backing store pointer&n; *&t;8. Read and save the new BSP to calculate the #dirty registers&n; * NOTE: Look at pages 11-10, 11-11 in PRM Vol 2&n; */
DECL|macro|rse_switch_context
mdefine_line|#define rse_switch_context(temp,p_stackframe,p_bspstore) &t;&t;&t;&bslash;&n;        ;; &t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        mov     temp=ar.rsc;; &t;&t;&t;&t;&t;&t;&t;&bslash;&n;        st8     [p_stackframe]=temp,8;; &t;&t;&t;&t;&t;&bslash;&n;        mov     temp=ar.pfs;; &t;&t;&t;&t;&t;&t;&t;&bslash;&n;        st8     [p_stackframe]=temp,8; &t;&t;&t;&t;&t;&t;&bslash;&n;        cover ;;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        mov     temp=cr.ifs;; &t;&t;&t;&t;&t;&t;&t;&bslash;&n;        st8     [p_stackframe]=temp,8;;&t; &t;&t;&t;&t;&t;&bslash;&n;        mov     temp=ar.bspstore;; &t;&t;&t;&t;&t;&t;&bslash;&n;        st8     [p_stackframe]=temp,8;; &t;&t;&t;&t;&t;&bslash;&n;        mov     temp=ar.rnat;; &t;&t;&t;&t;&t;&t;&t;&bslash;&n;        st8     [p_stackframe]=temp,8; &t;&t;&t;&t;&t;&t;&bslash;&n;        mov     ar.bspstore=p_bspstore;; &t;&t;&t;&t;&t;&bslash;&n;        mov     temp=ar.bsp;; &t;&t;&t;&t;&t;&t;&t;&bslash;&n;        sub     temp=temp,p_bspstore;;&t;&t;&t;&t;&t;&t;&bslash;&n;        st8     [p_stackframe]=temp,8
multiline_comment|/*&n; * rse_return_context&n; *&t;1. Allocate a zero-sized frame&n; *&t;2. Store the number of dirty registers RSC.loadrs field&n; *&t;3. Issue a loadrs to insure that any registers from the interrupted&n; *&t;   context which were saved on the new stack frame have been loaded&n; * &t;   back into the stacked registers&n; *&t;4. Restore BSPSTORE&n; *&t;5. Restore RNAT&n; *&t;6. Restore PFS&n; *&t;7. Restore IFS&n; *&t;8. Restore RSC&n; *&t;9. Issue an RFI&n; */
DECL|macro|rse_return_context
mdefine_line|#define rse_return_context(psr_mask_reg,temp,p_stackframe) &t;&t;&t;&bslash;&n;        ;; &t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        alloc   temp=ar.pfs,0,0,0,0;&t;&t;&t;&t;&t;&t;&bslash;&n;        add     p_stackframe=rse_ndirty_offset,p_stackframe;;&t;&t;&t;&bslash;&n;        ld8     temp=[p_stackframe];; &t;&t;&t;&t;&t;&t;&bslash;&n;        shl     temp=temp,16;;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        mov     ar.rsc=temp;; &t;&t;&t;&t;&t;&t;&t;&bslash;&n;        loadrs;;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        add     p_stackframe=-rse_ndirty_offset+rse_bspstore_offset,p_stackframe;;&bslash;&n;        ld8     temp=[p_stackframe];; &t;&t;&t;&t;&t;&t;&bslash;&n;        mov     ar.bspstore=temp;; &t;&t;&t;&t;&t;&t;&bslash;&n;        add     p_stackframe=-rse_bspstore_offset+rse_rnat_offset,p_stackframe;;&bslash;&n;        ld8     temp=[p_stackframe];; &t;&t;&t;&t;&t;&t;&bslash;&n;        mov     ar.rnat=temp;;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        add     p_stackframe=-rse_rnat_offset+rse_pfs_offset,p_stackframe;;&t;&bslash;&n;        ld8     temp=[p_stackframe];; &t;&t;&t;&t;&t;&t;&bslash;&n;        mov     ar.pfs=temp;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        add     p_stackframe=-rse_pfs_offset+rse_ifs_offset,p_stackframe;;&t;&bslash;&n;        ld8     temp=[p_stackframe];; &t;&t;&t;&t;&t;&t;&bslash;&n;        mov     cr.ifs=temp;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        add     p_stackframe=-rse_ifs_offset+rse_rsc_offset,p_stackframe;;&t;&bslash;&n;        ld8     temp=[p_stackframe];; &t;&t;&t;&t;&t;&t;&bslash;&n;        mov     ar.rsc=temp ;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        add     p_stackframe=-rse_rsc_offset,p_stackframe;&t;&t;&t;&bslash;&n;        mov     temp=cr.ipsr;;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        st8     [p_stackframe]=temp,8;&t;&t;&t;&t;&t;&t;&bslash;&n;        mov     temp=cr.iip;;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        st8     [p_stackframe]=temp,-8;&t;&t;&t;&t;&t;&t;&bslash;&n;        mov     temp=psr;;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        or      temp=temp,psr_mask_reg;;&t;&t;&t;&t;&t;&bslash;&n;        mov     cr.ipsr=temp;;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        mov     temp=ip;;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        add     temp=0x30,temp;;&t;&t;&t;&t;&t;&t;&bslash;&n;        mov     cr.iip=temp;;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        rfi;;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        ld8     temp=[p_stackframe],8;;&t;&t;&t;&t;&t;&t;&bslash;&n;        mov     cr.ipsr=temp;;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        ld8     temp=[p_stackframe];;&t;&t;&t;&t;&t;&t;&bslash;&n;        mov     cr.iip=temp
macro_line|#endif /* _ASM_IA64_MCA_ASM_H */
eof
