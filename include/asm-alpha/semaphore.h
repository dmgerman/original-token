macro_line|#ifndef _ALPHA_SEMAPHORE_H
DECL|macro|_ALPHA_SEMAPHORE_H
mdefine_line|#define _ALPHA_SEMAPHORE_H
multiline_comment|/*&n; * SMP- and interrupt-safe semaphores..&n; *&n; * (C) Copyright 1996 Linus Torvalds&n; * (C) Copyright 1996 Richard Henderson&n; */
macro_line|#include &lt;asm/current.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
DECL|struct|semaphore
r_struct
id|semaphore
(brace
multiline_comment|/* Careful, inline assembly knows about the position of these two.  */
DECL|member|count
id|atomic_t
id|count
suffix:semicolon
DECL|member|waking
id|atomic_t
id|waking
suffix:semicolon
multiline_comment|/* biased by -1 */
DECL|member|wait
r_struct
id|wait_queue
op_star
id|wait
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|MUTEX
mdefine_line|#define MUTEX ((struct semaphore) &bslash;&n; { ATOMIC_INIT(1), ATOMIC_INIT(-1), NULL })
DECL|macro|MUTEX_LOCKED
mdefine_line|#define MUTEX_LOCKED ((struct semaphore) &bslash;&n; { ATOMIC_INIT(0), ATOMIC_INIT(-1), NULL })
DECL|macro|sema_init
mdefine_line|#define sema_init(sem, val)&t;atomic_set(&amp;((sem)-&gt;count), val)
r_extern
r_void
id|__down
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
suffix:semicolon
r_extern
r_int
id|__down_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
suffix:semicolon
r_extern
r_int
id|__down_trylock
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
suffix:semicolon
r_extern
r_void
id|__up
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
suffix:semicolon
multiline_comment|/* All have custom assembly linkages.  */
r_extern
r_void
id|__down_failed
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
suffix:semicolon
r_extern
r_void
id|__down_failed_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
suffix:semicolon
r_extern
r_void
id|__down_failed_trylock
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
suffix:semicolon
r_extern
r_void
id|__up_wakeup
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
suffix:semicolon
multiline_comment|/*&n; * Whee.  Hidden out of line code is fun.  The contention cases are&n; * handled out of line in kernel/sched.c; arch/alpha/lib/semaphore.S&n; * takes care of making sure we can call it without clobbering regs.&n; */
DECL|function|down
r_extern
r_inline
r_void
id|down
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
multiline_comment|/* Given that we have to use particular hard registers to &n;&t;   communicate with __down_failed anyway, reuse them in &n;&t;   the atomic operation as well. &n;&n;&t;   __down_failed takes the semaphore address in $24, and&n;&t;   it&squot;s return address in $28.  The pv is loaded as usual.&n;&t;   The gp is clobbered (in the module case) as usual.  */
id|__asm__
id|__volatile__
(paren
l_string|&quot;/* semaphore down operation */&bslash;n&quot;
l_string|&quot;1:&t;ldl_l&t;$27,%0&bslash;n&quot;
l_string|&quot;&t;subl&t;$27,1,$27&bslash;n&quot;
l_string|&quot;&t;mov&t;$27,$28&bslash;n&quot;
l_string|&quot;&t;stl_c&t;$28,%0&bslash;n&quot;
l_string|&quot;&t;beq&t;$28,2f&bslash;n&quot;
l_string|&quot;&t;blt&t;$27,3f&bslash;n&quot;
l_string|&quot;4:&t;mb&bslash;n&quot;
l_string|&quot;.section .text2,&bslash;&quot;ax&bslash;&quot;&bslash;n&quot;
l_string|&quot;2:&t;br&t;1b&bslash;n&quot;
l_string|&quot;3:&t;lda&t;$24,%0&bslash;n&quot;
l_string|&quot;&t;jsr&t;$28,__down_failed&bslash;n&quot;
l_string|&quot;&t;ldgp&t;$29,0($28)&bslash;n&quot;
l_string|&quot;&t;br&t;4b&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
id|sem-&gt;count
)paren
suffix:colon
l_string|&quot;$24&quot;
comma
l_string|&quot;$27&quot;
comma
l_string|&quot;$28&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|function|down_interruptible
r_extern
r_inline
r_int
id|down_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
multiline_comment|/* __down_failed_interruptible takes the semaphore address in $24,&n;&t;   and it&squot;s return address in $28.  The pv is loaded as usual.&n;&t;   The gp is clobbered (in the module case) as usual.  The return&n;&t;   value is in $24.  */
r_register
r_int
id|ret
id|__asm__
c_func
(paren
l_string|&quot;$24&quot;
)paren
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;/* semaphore down interruptible operation */&bslash;n&quot;
l_string|&quot;1:&t;ldl_l&t;$27,%1&bslash;n&quot;
l_string|&quot;&t;subl&t;$27,1,$27&bslash;n&quot;
l_string|&quot;&t;mov&t;$27,$28&bslash;n&quot;
l_string|&quot;&t;stl_c&t;$28,%1&bslash;n&quot;
l_string|&quot;&t;beq&t;$28,2f&bslash;n&quot;
l_string|&quot;&t;blt&t;$27,3f&bslash;n&quot;
l_string|&quot;&t;mov&t;$31,%0&bslash;n&quot;
l_string|&quot;4:&t;mb&bslash;n&quot;
l_string|&quot;.section .text2,&bslash;&quot;ax&bslash;&quot;&bslash;n&quot;
l_string|&quot;2:&t;br&t;1b&bslash;n&quot;
l_string|&quot;3:&t;lda&t;$24,%1&bslash;n&quot;
l_string|&quot;&t;jsr&t;$28,__down_failed_interruptible&bslash;n&quot;
l_string|&quot;&t;ldgp&t;$29,0($28)&bslash;n&quot;
l_string|&quot;&t;br&t;4b&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ret
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
id|sem-&gt;count
)paren
suffix:colon
l_string|&quot;$27&quot;
comma
l_string|&quot;$28&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * down_trylock returns 0 on success, 1 if we failed to get the lock.&n; *&n; * We must manipulate count and waking simultaneously and atomically.&n; * Do this by using ll/sc on the pair of 32-bit words.&n; */
DECL|function|down_trylock
r_extern
r_inline
r_int
id|down_trylock
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
id|ret
comma
id|tmp
comma
id|tmp2
suffix:semicolon
multiline_comment|/* &quot;Equivalent&quot; C.  Note that we have to do this all without&n;&t;   (taken) branches in order to be a valid ll/sc sequence.&n;&n;&t;   do {&n;&t;       tmp = ldq_l;&n;&t;       ret = 0;&n;&t;       tmp -= 1;&n;&t;       if ((int)tmp &lt; 0)&t;&t;// count&n;&t;           break;&n;&t;       if ((long)tmp &lt; 0)&t;&t;// waking&n;&t;           break;&n;&t;       tmp += 0xffffffff00000000;&n;&t;       ret = 1;&n;&t;       tmp = stq_c = tmp;&n;&t;   } while (tmp == 0);&n;&t;*/
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&t;ldq_l&t;%1,%3&bslash;n&quot;
l_string|&quot;&t;lda&t;%0,0&bslash;n&quot;
l_string|&quot;&t;subl&t;%1,1,%2&bslash;n&quot;
l_string|&quot;&t;subq&t;%1,1,%1&bslash;n&quot;
l_string|&quot;&t;blt&t;%2,2f&bslash;n&quot;
l_string|&quot;&t;blt&t;%1,2f&bslash;n&quot;
l_string|&quot;&t;ldah&t;%1,0x8000(%1)&bslash;n&quot;
l_string|&quot;&t;ldah&t;%1,0x8000(%1)&bslash;n&quot;
l_string|&quot;&t;lda&t;%0,1&bslash;n&quot;
l_string|&quot;&t;stq_c&t;%1,%3&bslash;n&quot;
l_string|&quot;&t;beq&t;%1,3f&bslash;n&quot;
l_string|&quot;2:&t;mb&bslash;n&quot;
l_string|&quot;.section .text2,&bslash;&quot;ax&bslash;&quot;&bslash;n&quot;
l_string|&quot;3:&t;br&t;1b&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|ret
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp2
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
op_star
id|sem
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|up
r_extern
r_inline
r_void
id|up
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
multiline_comment|/* Given that we have to use particular hard registers to &n;&t;   communicate with __up_wakeup anyway, reuse them in &n;&t;   the atomic operation as well. &n;&n;&t;   __up_wakeup takes the semaphore address in $24, and&n;&t;   it&squot;s return address in $28.  The pv is loaded as usual.&n;&t;   The gp is clobbered (in the module case) as usual.  */
id|__asm__
id|__volatile__
(paren
l_string|&quot;/* semaphore up operation */&bslash;n&quot;
l_string|&quot;&t;mb&bslash;n&quot;
l_string|&quot;1:&t;ldl_l&t;$27,%0&bslash;n&quot;
l_string|&quot;&t;addl&t;$27,1,$27&bslash;n&quot;
l_string|&quot;&t;mov&t;$27,$28&bslash;n&quot;
l_string|&quot;&t;stl_c&t;$28,%0&bslash;n&quot;
l_string|&quot;&t;beq&t;$28,2f&bslash;n&quot;
l_string|&quot;&t;mb&bslash;n&quot;
l_string|&quot;&t;ble&t;$27,3f&bslash;n&quot;
l_string|&quot;4:&bslash;n&quot;
l_string|&quot;.section .text2,&bslash;&quot;ax&bslash;&quot;&bslash;n&quot;
l_string|&quot;2:&t;br&t;1b&bslash;n&quot;
l_string|&quot;3:&t;lda&t;$24,%0&bslash;n&quot;
l_string|&quot;&t;jsr&t;$28,__up_wakeup&bslash;n&quot;
l_string|&quot;&t;ldgp&t;$29,0($28)&bslash;n&quot;
l_string|&quot;&t;br&t;4b&bslash;n&quot;
l_string|&quot;.previous&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
id|sem-&gt;count
)paren
suffix:colon
l_string|&quot;$24&quot;
comma
l_string|&quot;$27&quot;
comma
l_string|&quot;$28&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
