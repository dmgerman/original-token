multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Definitions for the TCP module.&n; *&n; * Version:&t;@(#)tcp.h&t;1.0.5&t;05/23/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#ifndef _TCP_H
DECL|macro|_TCP_H
mdefine_line|#define _TCP_H
DECL|macro|TCP_DEBUG
mdefine_line|#define TCP_DEBUG 1
DECL|macro|FASTRETRANS_DEBUG
mdefine_line|#define FASTRETRANS_DEBUG 1
multiline_comment|/* Be paranoid about data immediately beyond right edge of window. */
DECL|macro|TCP_FORMAL_WINDOW
macro_line|#undef  TCP_FORMAL_WINDOW
multiline_comment|/* Cancel timers, when they are not required. */
DECL|macro|TCP_CLEAR_TIMERS
macro_line|#undef TCP_CLEAR_TIMERS
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
macro_line|#include &lt;net/sock.h&gt;
multiline_comment|/* This is for all connections with a full identity, no wildcards.&n; * New scheme, half the table is for TIME_WAIT, the other half is&n; * for the rest.  I&squot;ll experiment with dynamic table growth later.&n; */
DECL|struct|tcp_ehash_bucket
r_struct
id|tcp_ehash_bucket
(brace
DECL|member|lock
id|rwlock_t
id|lock
suffix:semicolon
DECL|member|chain
r_struct
id|sock
op_star
id|chain
suffix:semicolon
)brace
id|__attribute__
c_func
(paren
(paren
id|__aligned__
c_func
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* This is for listening sockets, thus all sockets which possess wildcards. */
DECL|macro|TCP_LHTABLE_SIZE
mdefine_line|#define TCP_LHTABLE_SIZE&t;32&t;/* Yes, really, this is all you need. */
multiline_comment|/* There are a few simple rules, which allow for local port reuse by&n; * an application.  In essence:&n; *&n; *&t;1) Sockets bound to different interfaces may share a local port.&n; *&t;   Failing that, goto test 2.&n; *&t;2) If all sockets have sk-&gt;reuse set, and none of them are in&n; *&t;   TCP_LISTEN state, the port may be shared.&n; *&t;   Failing that, goto test 3.&n; *&t;3) If all sockets are bound to a specific sk-&gt;rcv_saddr local&n; *&t;   address, and none of them are the same, the port may be&n; *&t;   shared.&n; *&t;   Failing this, the port cannot be shared.&n; *&n; * The interesting point, is test #2.  This is what an FTP server does&n; * all day.  To optimize this case we use a specific flag bit defined&n; * below.  As we add sockets to a bind bucket list, we perform a&n; * check of: (newsk-&gt;reuse &amp;&amp; (newsk-&gt;state != TCP_LISTEN))&n; * As long as all sockets added to a bind bucket pass this test,&n; * the flag bit will be set.&n; * The resulting situation is that tcp_v[46]_verify_bind() can just check&n; * for this flag bit, if it is set and the socket trying to bind has&n; * sk-&gt;reuse set, we don&squot;t even have to walk the owners list at all,&n; * we return that it is ok to bind this socket to the requested local port.&n; *&n; * Sounds like a lot of work, but it is worth it.  In a more naive&n; * implementation (ie. current FreeBSD etc.) the entire list of ports&n; * must be walked for each data port opened by an ftp server.  Needless&n; * to say, this does not scale at all.  With a couple thousand FTP&n; * users logged onto your box, isn&squot;t it nice to know that new data&n; * ports are created in O(1) time?  I thought so. ;-)&t;-DaveM&n; */
DECL|struct|tcp_bind_bucket
r_struct
id|tcp_bind_bucket
(brace
DECL|member|port
r_int
r_int
id|port
suffix:semicolon
DECL|member|fastreuse
r_int
r_int
id|fastreuse
suffix:semicolon
DECL|member|next
r_struct
id|tcp_bind_bucket
op_star
id|next
suffix:semicolon
DECL|member|owners
r_struct
id|sock
op_star
id|owners
suffix:semicolon
DECL|member|pprev
r_struct
id|tcp_bind_bucket
op_star
op_star
id|pprev
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|tcp_bind_hashbucket
r_struct
id|tcp_bind_hashbucket
(brace
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
DECL|member|chain
r_struct
id|tcp_bind_bucket
op_star
id|chain
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|tcp_hashinfo
r_extern
r_struct
id|tcp_hashinfo
(brace
multiline_comment|/* This is for sockets with full identity only.  Sockets here will&n;&t; * always be without wildcards and will have the following invariant:&n;&t; *&n;&t; *          TCP_ESTABLISHED &lt;= sk-&gt;state &lt; TCP_CLOSE&n;&t; *&n;&t; * First half of the table is for sockets not in TIME_WAIT, second half&n;&t; * is for TIME_WAIT sockets only.&n;&t; */
DECL|member|__tcp_ehash
r_struct
id|tcp_ehash_bucket
op_star
id|__tcp_ehash
suffix:semicolon
multiline_comment|/* Ok, let&squot;s try this, I give up, we do need a local binding&n;&t; * TCP hash as well as the others for fast bind/connect.&n;&t; */
DECL|member|__tcp_bhash
r_struct
id|tcp_bind_hashbucket
op_star
id|__tcp_bhash
suffix:semicolon
DECL|member|__tcp_bhash_size
r_int
id|__tcp_bhash_size
suffix:semicolon
DECL|member|__tcp_ehash_size
r_int
id|__tcp_ehash_size
suffix:semicolon
multiline_comment|/* All sockets in TCP_LISTEN state will be in here.  This is the only&n;&t; * table where wildcard&squot;d TCP sockets can exist.  Hash function here&n;&t; * is just local port number.&n;&t; */
DECL|member|__tcp_listening_hash
r_struct
id|sock
op_star
id|__tcp_listening_hash
(braket
id|TCP_LHTABLE_SIZE
)braket
suffix:semicolon
multiline_comment|/* All the above members are written once at bootup and&n;&t; * never written again _or_ are predominantly read-access.&n;&t; *&n;&t; * Now align to a new cache line as all the following members&n;&t; * are often dirty.&n;&t; */
DECL|member|__tcp_lhash_lock
id|rwlock_t
id|__tcp_lhash_lock
id|__attribute__
c_func
(paren
(paren
id|__aligned__
c_func
(paren
id|SMP_CACHE_BYTES
)paren
)paren
)paren
suffix:semicolon
DECL|member|__tcp_lhash_users
id|atomic_t
id|__tcp_lhash_users
suffix:semicolon
DECL|member|__tcp_lhash_wait
id|wait_queue_head_t
id|__tcp_lhash_wait
suffix:semicolon
DECL|member|__tcp_portalloc_lock
id|spinlock_t
id|__tcp_portalloc_lock
suffix:semicolon
)brace
id|tcp_hashinfo
suffix:semicolon
DECL|macro|tcp_ehash
mdefine_line|#define tcp_ehash&t;(tcp_hashinfo.__tcp_ehash)
DECL|macro|tcp_bhash
mdefine_line|#define tcp_bhash&t;(tcp_hashinfo.__tcp_bhash)
DECL|macro|tcp_ehash_size
mdefine_line|#define tcp_ehash_size&t;(tcp_hashinfo.__tcp_ehash_size)
DECL|macro|tcp_bhash_size
mdefine_line|#define tcp_bhash_size&t;(tcp_hashinfo.__tcp_bhash_size)
DECL|macro|tcp_listening_hash
mdefine_line|#define tcp_listening_hash (tcp_hashinfo.__tcp_listening_hash)
DECL|macro|tcp_lhash_lock
mdefine_line|#define tcp_lhash_lock&t;(tcp_hashinfo.__tcp_lhash_lock)
DECL|macro|tcp_lhash_users
mdefine_line|#define tcp_lhash_users&t;(tcp_hashinfo.__tcp_lhash_users)
DECL|macro|tcp_lhash_wait
mdefine_line|#define tcp_lhash_wait&t;(tcp_hashinfo.__tcp_lhash_wait)
DECL|macro|tcp_portalloc_lock
mdefine_line|#define tcp_portalloc_lock (tcp_hashinfo.__tcp_portalloc_lock)
r_extern
id|kmem_cache_t
op_star
id|tcp_bucket_cachep
suffix:semicolon
r_extern
r_struct
id|tcp_bind_bucket
op_star
id|tcp_bucket_create
c_func
(paren
r_struct
id|tcp_bind_hashbucket
op_star
id|head
comma
r_int
r_int
id|snum
)paren
suffix:semicolon
r_extern
r_void
id|tcp_bucket_unlock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_int
id|tcp_port_rover
suffix:semicolon
r_extern
r_struct
id|sock
op_star
id|tcp_v4_lookup_listener
c_func
(paren
id|u32
id|addr
comma
r_int
r_int
id|hnum
comma
r_int
id|dif
)paren
suffix:semicolon
multiline_comment|/* These are AF independent. */
DECL|function|tcp_bhashfn
r_static
id|__inline__
r_int
id|tcp_bhashfn
c_func
(paren
id|__u16
id|lport
)paren
(brace
r_return
(paren
id|lport
op_amp
(paren
id|tcp_bhash_size
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This is a TIME_WAIT bucket.  It works around the memory consumption&n; * problems of sockets in such a state on heavily loaded servers, but&n; * without violating the protocol specification.&n; */
DECL|struct|tcp_tw_bucket
r_struct
id|tcp_tw_bucket
(brace
multiline_comment|/* These _must_ match the beginning of struct sock precisely.&n;&t; * XXX Yes I know this is gross, but I&squot;d have to edit every single&n;&t; * XXX networking file if I created a &quot;struct sock_header&quot;. -DaveM&n;&t; */
DECL|member|daddr
id|__u32
id|daddr
suffix:semicolon
DECL|member|rcv_saddr
id|__u32
id|rcv_saddr
suffix:semicolon
DECL|member|dport
id|__u16
id|dport
suffix:semicolon
DECL|member|num
r_int
r_int
id|num
suffix:semicolon
DECL|member|bound_dev_if
r_int
id|bound_dev_if
suffix:semicolon
DECL|member|next
r_struct
id|sock
op_star
id|next
suffix:semicolon
DECL|member|pprev
r_struct
id|sock
op_star
op_star
id|pprev
suffix:semicolon
DECL|member|bind_next
r_struct
id|sock
op_star
id|bind_next
suffix:semicolon
DECL|member|bind_pprev
r_struct
id|sock
op_star
op_star
id|bind_pprev
suffix:semicolon
DECL|member|state
r_int
r_char
id|state
comma
DECL|member|substate
id|substate
suffix:semicolon
multiline_comment|/* &quot;zapped&quot; is replaced with &quot;substate&quot; */
DECL|member|sport
id|__u16
id|sport
suffix:semicolon
DECL|member|family
r_int
r_int
id|family
suffix:semicolon
DECL|member|reuse
r_int
r_char
id|reuse
comma
DECL|member|rcv_wscale
id|rcv_wscale
suffix:semicolon
multiline_comment|/* It is also TW bucket specific */
DECL|member|refcnt
id|atomic_t
id|refcnt
suffix:semicolon
multiline_comment|/* And these are ours. */
DECL|member|hashent
r_int
id|hashent
suffix:semicolon
DECL|member|timeout
r_int
id|timeout
suffix:semicolon
DECL|member|rcv_nxt
id|__u32
id|rcv_nxt
suffix:semicolon
DECL|member|snd_nxt
id|__u32
id|snd_nxt
suffix:semicolon
DECL|member|rcv_wnd
id|__u32
id|rcv_wnd
suffix:semicolon
DECL|member|syn_seq
id|__u32
id|syn_seq
suffix:semicolon
DECL|member|ts_recent
id|__u32
id|ts_recent
suffix:semicolon
DECL|member|ts_recent_stamp
r_int
id|ts_recent_stamp
suffix:semicolon
DECL|member|ttd
r_int
r_int
id|ttd
suffix:semicolon
DECL|member|tb
r_struct
id|tcp_bind_bucket
op_star
id|tb
suffix:semicolon
DECL|member|next_death
r_struct
id|tcp_tw_bucket
op_star
id|next_death
suffix:semicolon
DECL|member|pprev_death
r_struct
id|tcp_tw_bucket
op_star
op_star
id|pprev_death
suffix:semicolon
macro_line|#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
DECL|member|v6_daddr
r_struct
id|in6_addr
id|v6_daddr
suffix:semicolon
DECL|member|v6_rcv_saddr
r_struct
id|in6_addr
id|v6_rcv_saddr
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
r_extern
id|kmem_cache_t
op_star
id|tcp_timewait_cachep
suffix:semicolon
DECL|function|tcp_tw_put
r_static
r_inline
r_void
id|tcp_tw_put
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|tw-&gt;refcnt
)paren
)paren
(brace
macro_line|#ifdef INET_REFCNT_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;tw_bucket %p released&bslash;n&quot;
comma
id|tw
)paren
suffix:semicolon
macro_line|#endif
id|kmem_cache_free
c_func
(paren
id|tcp_timewait_cachep
comma
id|tw
)paren
suffix:semicolon
)brace
)brace
r_extern
id|atomic_t
id|tcp_orphan_count
suffix:semicolon
r_extern
r_int
id|tcp_tw_count
suffix:semicolon
r_extern
r_void
id|tcp_time_wait
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|state
comma
r_int
id|timeo
)paren
suffix:semicolon
r_extern
r_void
id|tcp_timewait_kill
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
)paren
suffix:semicolon
r_extern
r_void
id|tcp_tw_schedule
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
comma
r_int
id|timeo
)paren
suffix:semicolon
r_extern
r_void
id|tcp_tw_deschedule
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
)paren
suffix:semicolon
multiline_comment|/* Socket demux engine toys. */
macro_line|#ifdef __BIG_ENDIAN
DECL|macro|TCP_COMBINED_PORTS
mdefine_line|#define TCP_COMBINED_PORTS(__sport, __dport) &bslash;&n;&t;(((__u32)(__sport)&lt;&lt;16) | (__u32)(__dport))
macro_line|#else /* __LITTLE_ENDIAN */
DECL|macro|TCP_COMBINED_PORTS
mdefine_line|#define TCP_COMBINED_PORTS(__sport, __dport) &bslash;&n;&t;(((__u32)(__dport)&lt;&lt;16) | (__u32)(__sport))
macro_line|#endif
macro_line|#if (BITS_PER_LONG == 64)
macro_line|#ifdef __BIG_ENDIAN
DECL|macro|TCP_V4_ADDR_COOKIE
mdefine_line|#define TCP_V4_ADDR_COOKIE(__name, __saddr, __daddr) &bslash;&n;&t;__u64 __name = (((__u64)(__saddr))&lt;&lt;32)|((__u64)(__daddr));
macro_line|#else /* __LITTLE_ENDIAN */
DECL|macro|TCP_V4_ADDR_COOKIE
mdefine_line|#define TCP_V4_ADDR_COOKIE(__name, __saddr, __daddr) &bslash;&n;&t;__u64 __name = (((__u64)(__daddr))&lt;&lt;32)|((__u64)(__saddr));
macro_line|#endif /* __BIG_ENDIAN */
DECL|macro|TCP_IPV4_MATCH
mdefine_line|#define TCP_IPV4_MATCH(__sk, __cookie, __saddr, __daddr, __ports, __dif)&bslash;&n;&t;(((*((__u64 *)&amp;((__sk)-&gt;daddr)))== (__cookie))&t;&amp;&amp;&t;&t;&bslash;&n;&t; ((*((__u32 *)&amp;((__sk)-&gt;dport)))== (__ports))   &amp;&amp;&t;&t;&bslash;&n;&t; (!((__sk)-&gt;bound_dev_if) || ((__sk)-&gt;bound_dev_if == (__dif))))
macro_line|#else /* 32-bit arch */
DECL|macro|TCP_V4_ADDR_COOKIE
mdefine_line|#define TCP_V4_ADDR_COOKIE(__name, __saddr, __daddr)
DECL|macro|TCP_IPV4_MATCH
mdefine_line|#define TCP_IPV4_MATCH(__sk, __cookie, __saddr, __daddr, __ports, __dif)&bslash;&n;&t;(((__sk)-&gt;daddr&t;&t;&t;== (__saddr))&t;&amp;&amp;&t;&t;&bslash;&n;&t; ((__sk)-&gt;rcv_saddr&t;&t;== (__daddr))&t;&amp;&amp;&t;&t;&bslash;&n;&t; ((*((__u32 *)&amp;((__sk)-&gt;dport)))== (__ports))   &amp;&amp;&t;&t;&bslash;&n;&t; (!((__sk)-&gt;bound_dev_if) || ((__sk)-&gt;bound_dev_if == (__dif))))
macro_line|#endif /* 64-bit arch */
DECL|macro|TCP_IPV6_MATCH
mdefine_line|#define TCP_IPV6_MATCH(__sk, __saddr, __daddr, __ports, __dif)&t;&t;&t;   &bslash;&n;&t;(((*((__u32 *)&amp;((__sk)-&gt;dport)))== (__ports))   &t;&t;&t;&amp;&amp; &bslash;&n;&t; ((__sk)-&gt;family&t;&t;== AF_INET6)&t;&t;&t;&t;&amp;&amp; &bslash;&n;&t; !ipv6_addr_cmp(&amp;(__sk)-&gt;net_pinfo.af_inet6.daddr, (__saddr))&t;&t;&amp;&amp; &bslash;&n;&t; !ipv6_addr_cmp(&amp;(__sk)-&gt;net_pinfo.af_inet6.rcv_saddr, (__daddr))&t;&amp;&amp; &bslash;&n;&t; (!((__sk)-&gt;bound_dev_if) || ((__sk)-&gt;bound_dev_if == (__dif))))
multiline_comment|/* These can have wildcards, don&squot;t try too hard. */
DECL|function|tcp_lhashfn
r_static
id|__inline__
r_int
id|tcp_lhashfn
c_func
(paren
r_int
r_int
id|num
)paren
(brace
r_return
id|num
op_amp
(paren
id|TCP_LHTABLE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|tcp_sk_listen_hashfn
r_static
id|__inline__
r_int
id|tcp_sk_listen_hashfn
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|tcp_lhashfn
c_func
(paren
id|sk-&gt;num
)paren
suffix:semicolon
)brace
DECL|macro|MAX_TCP_HEADER
mdefine_line|#define MAX_TCP_HEADER&t;(128 + MAX_HEADER)
multiline_comment|/* &n; * Never offer a window over 32767 without using window scaling. Some&n; * poor stacks do signed 16bit maths! &n; */
DECL|macro|MAX_TCP_WINDOW
mdefine_line|#define MAX_TCP_WINDOW&t;&t;32767
multiline_comment|/* Minimal accepted MSS. It is (60+60+8) - (20+20). */
DECL|macro|TCP_MIN_MSS
mdefine_line|#define TCP_MIN_MSS&t;&t;88
multiline_comment|/* Minimal RCV_MSS. */
DECL|macro|TCP_MIN_RCVMSS
mdefine_line|#define TCP_MIN_RCVMSS&t;&t;536
multiline_comment|/* After receiving this amount of duplicate ACKs fast retransmit starts. */
DECL|macro|TCP_FASTRETRANS_THRESH
mdefine_line|#define TCP_FASTRETRANS_THRESH 3
multiline_comment|/* Maximal reordering. */
DECL|macro|TCP_MAX_REORDERING
mdefine_line|#define TCP_MAX_REORDERING&t;127
multiline_comment|/* Maximal number of ACKs sent quickly to accelerate slow-start. */
DECL|macro|TCP_MAX_QUICKACKS
mdefine_line|#define TCP_MAX_QUICKACKS&t;16
multiline_comment|/* urg_data states */
DECL|macro|TCP_URG_VALID
mdefine_line|#define TCP_URG_VALID&t;0x0100
DECL|macro|TCP_URG_NOTYET
mdefine_line|#define TCP_URG_NOTYET&t;0x0200
DECL|macro|TCP_URG_READ
mdefine_line|#define TCP_URG_READ&t;0x0400
DECL|macro|TCP_RETR1
mdefine_line|#define TCP_RETR1&t;3&t;/*&n;&t;&t;&t;&t; * This is how many retries it does before it&n;&t;&t;&t;&t; * tries to figure out if the gateway is&n;&t;&t;&t;&t; * down. Minimal RFC value is 3; it corresponds&n;&t;&t;&t;&t; * to ~3sec-8min depending on RTO.&n;&t;&t;&t;&t; */
DECL|macro|TCP_RETR2
mdefine_line|#define TCP_RETR2&t;15&t;/*&n;&t;&t;&t;&t; * This should take at least&n;&t;&t;&t;&t; * 90 minutes to time out.&n;&t;&t;&t;&t; * RFC1122 says that the limit is 100 sec.&n;&t;&t;&t;&t; * 15 is ~13-30min depending on RTO.&n;&t;&t;&t;&t; */
DECL|macro|TCP_SYN_RETRIES
mdefine_line|#define TCP_SYN_RETRIES&t; 5&t;/* number of times to retry active opening a&n;&t;&t;&t;&t; * connection: ~180sec is RFC minumum&t;*/
DECL|macro|TCP_SYNACK_RETRIES
mdefine_line|#define TCP_SYNACK_RETRIES 5&t;/* number of times to retry passive opening a&n;&t;&t;&t;&t; * connection: ~180sec is RFC minumum&t;*/
DECL|macro|TCP_ORPHAN_RETRIES
mdefine_line|#define TCP_ORPHAN_RETRIES 7&t;/* number of times to retry on an orphaned&n;&t;&t;&t;&t; * socket. 7 is ~50sec-16min.&n;&t;&t;&t;&t; */
DECL|macro|TCP_TIMEWAIT_LEN
mdefine_line|#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT&n;&t;&t;&t;&t;  * state, about 60 seconds&t;*/
DECL|macro|TCP_FIN_TIMEOUT
mdefine_line|#define TCP_FIN_TIMEOUT&t;TCP_TIMEWAIT_LEN
multiline_comment|/* BSD style FIN_WAIT2 deadlock breaker.&n;&t;&t;&t;&t;  * It used to be 3min, new value is 60sec,&n;&t;&t;&t;&t;  * to combine FIN-WAIT-2 timeout with&n;&t;&t;&t;&t;  * TIME-WAIT timer.&n;&t;&t;&t;&t;  */
DECL|macro|TCP_DELACK_MAX
mdefine_line|#define TCP_DELACK_MAX&t;(HZ/5)&t;/* maximal time to delay before sending an ACK */
macro_line|#if HZ &gt;= 100
DECL|macro|TCP_DELACK_MIN
mdefine_line|#define TCP_DELACK_MIN&t;(HZ/25)&t;/* minimal time to delay before sending an ACK */
DECL|macro|TCP_ATO_MIN
mdefine_line|#define TCP_ATO_MIN&t;(HZ/25)
macro_line|#else
DECL|macro|TCP_DELACK_MIN
mdefine_line|#define TCP_DELACK_MIN&t;4
DECL|macro|TCP_ATO_MIN
mdefine_line|#define TCP_ATO_MIN&t;4
macro_line|#endif
DECL|macro|TCP_RTO_MAX
mdefine_line|#define TCP_RTO_MAX&t;(120*HZ)
DECL|macro|TCP_RTO_MIN
mdefine_line|#define TCP_RTO_MIN&t;(HZ/5)
DECL|macro|TCP_TIMEOUT_INIT
mdefine_line|#define TCP_TIMEOUT_INIT (3*HZ)&t;/* RFC 1122 initial RTO value&t;*/
DECL|macro|TCP_RESOURCE_PROBE_INTERVAL
mdefine_line|#define TCP_RESOURCE_PROBE_INTERVAL (HZ/2) /* Maximal interval between probes&n;&t;&t;&t;&t;&t;    * for local resources.&n;&t;&t;&t;&t;&t;    */
DECL|macro|TCP_KEEPALIVE_TIME
mdefine_line|#define TCP_KEEPALIVE_TIME&t;(120*60*HZ)&t;/* two hours */
DECL|macro|TCP_KEEPALIVE_PROBES
mdefine_line|#define TCP_KEEPALIVE_PROBES&t;9&t;&t;/* Max of 9 keepalive probes&t;*/
DECL|macro|TCP_KEEPALIVE_INTVL
mdefine_line|#define TCP_KEEPALIVE_INTVL&t;(75*HZ)
DECL|macro|MAX_TCP_KEEPIDLE
mdefine_line|#define MAX_TCP_KEEPIDLE&t;32767
DECL|macro|MAX_TCP_KEEPINTVL
mdefine_line|#define MAX_TCP_KEEPINTVL&t;32767
DECL|macro|MAX_TCP_KEEPCNT
mdefine_line|#define MAX_TCP_KEEPCNT&t;&t;127
DECL|macro|MAX_TCP_SYNCNT
mdefine_line|#define MAX_TCP_SYNCNT&t;&t;127
multiline_comment|/* TIME_WAIT reaping mechanism. */
DECL|macro|TCP_TWKILL_SLOTS
mdefine_line|#define TCP_TWKILL_SLOTS&t;8&t;/* Please keep this a power of 2. */
DECL|macro|TCP_TWKILL_PERIOD
mdefine_line|#define TCP_TWKILL_PERIOD&t;(TCP_TIMEWAIT_LEN/TCP_TWKILL_SLOTS)
DECL|macro|TCP_SYNQ_INTERVAL
mdefine_line|#define TCP_SYNQ_INTERVAL&t;(HZ/5)&t;/* Period of SYNACK timer */
DECL|macro|TCP_SYNQ_HSIZE
mdefine_line|#define TCP_SYNQ_HSIZE&t;&t;64&t;/* Size of SYNACK hash table */
DECL|macro|TCP_PAWS_24DAYS
mdefine_line|#define TCP_PAWS_24DAYS&t;(60 * 60 * 24 * 24)
DECL|macro|TCP_PAWS_MSL
mdefine_line|#define TCP_PAWS_MSL&t;60&t;&t;/* Per-host timestamps are invalidated&n;&t;&t;&t;&t;&t; * after this time. It should be equal&n;&t;&t;&t;&t;&t; * (or greater than) TCP_TIMEWAIT_LEN&n;&t;&t;&t;&t;&t; * to provide reliability equal to one&n;&t;&t;&t;&t;&t; * provided by timewait state.&n;&t;&t;&t;&t;&t; */
DECL|macro|TCP_PAWS_WINDOW
mdefine_line|#define TCP_PAWS_WINDOW&t;1&t;&t;/* Replay window for per-host&n;&t;&t;&t;&t;&t; * timestamps. It must be less than&n;&t;&t;&t;&t;&t; * minimal timewait lifetime.&n;&t;&t;&t;&t;&t; */
DECL|macro|TCP_TW_RECYCLE_SLOTS_LOG
mdefine_line|#define TCP_TW_RECYCLE_SLOTS_LOG&t;5
DECL|macro|TCP_TW_RECYCLE_SLOTS
mdefine_line|#define TCP_TW_RECYCLE_SLOTS&t;&t;(1&lt;&lt;TCP_TW_RECYCLE_SLOTS_LOG)
multiline_comment|/* If time &gt; 4sec, it is &quot;slow&quot; path, no recycling is required,&n;   so that we select tick to get range about 4 seconds.&n; */
macro_line|#if HZ &lt;= 16 || HZ &gt; 4096
macro_line|# error Unsupported: HZ &lt;= 16 or HZ &gt; 4096
macro_line|#elif HZ &lt;= 32
DECL|macro|TCP_TW_RECYCLE_TICK
macro_line|# define TCP_TW_RECYCLE_TICK (5+2-TCP_TW_RECYCLE_SLOTS_LOG)
macro_line|#elif HZ &lt;= 64
DECL|macro|TCP_TW_RECYCLE_TICK
macro_line|# define TCP_TW_RECYCLE_TICK (6+2-TCP_TW_RECYCLE_SLOTS_LOG)
macro_line|#elif HZ &lt;= 128
DECL|macro|TCP_TW_RECYCLE_TICK
macro_line|# define TCP_TW_RECYCLE_TICK (7+2-TCP_TW_RECYCLE_SLOTS_LOG)
macro_line|#elif HZ &lt;= 256
DECL|macro|TCP_TW_RECYCLE_TICK
macro_line|# define TCP_TW_RECYCLE_TICK (8+2-TCP_TW_RECYCLE_SLOTS_LOG)
macro_line|#elif HZ &lt;= 512
DECL|macro|TCP_TW_RECYCLE_TICK
macro_line|# define TCP_TW_RECYCLE_TICK (9+2-TCP_TW_RECYCLE_SLOTS_LOG)
macro_line|#elif HZ &lt;= 1024
DECL|macro|TCP_TW_RECYCLE_TICK
macro_line|# define TCP_TW_RECYCLE_TICK (10+2-TCP_TW_RECYCLE_SLOTS_LOG)
macro_line|#elif HZ &lt;= 2048
DECL|macro|TCP_TW_RECYCLE_TICK
macro_line|# define TCP_TW_RECYCLE_TICK (11+2-TCP_TW_RECYCLE_SLOTS_LOG)
macro_line|#else
DECL|macro|TCP_TW_RECYCLE_TICK
macro_line|# define TCP_TW_RECYCLE_TICK (12+2-TCP_TW_RECYCLE_SLOTS_LOG)
macro_line|#endif
multiline_comment|/*&n; *&t;TCP option&n; */
DECL|macro|TCPOPT_NOP
mdefine_line|#define TCPOPT_NOP&t;&t;1&t;/* Padding */
DECL|macro|TCPOPT_EOL
mdefine_line|#define TCPOPT_EOL&t;&t;0&t;/* End of options */
DECL|macro|TCPOPT_MSS
mdefine_line|#define TCPOPT_MSS&t;&t;2&t;/* Segment size negotiating */
DECL|macro|TCPOPT_WINDOW
mdefine_line|#define TCPOPT_WINDOW&t;&t;3&t;/* Window scaling */
DECL|macro|TCPOPT_SACK_PERM
mdefine_line|#define TCPOPT_SACK_PERM        4       /* SACK Permitted */
DECL|macro|TCPOPT_SACK
mdefine_line|#define TCPOPT_SACK             5       /* SACK Block */
DECL|macro|TCPOPT_TIMESTAMP
mdefine_line|#define TCPOPT_TIMESTAMP&t;8&t;/* Better RTT estimations/PAWS */
multiline_comment|/*&n; *     TCP option lengths&n; */
DECL|macro|TCPOLEN_MSS
mdefine_line|#define TCPOLEN_MSS            4
DECL|macro|TCPOLEN_WINDOW
mdefine_line|#define TCPOLEN_WINDOW         3
DECL|macro|TCPOLEN_SACK_PERM
mdefine_line|#define TCPOLEN_SACK_PERM      2
DECL|macro|TCPOLEN_TIMESTAMP
mdefine_line|#define TCPOLEN_TIMESTAMP      10
multiline_comment|/* But this is what stacks really send out. */
DECL|macro|TCPOLEN_TSTAMP_ALIGNED
mdefine_line|#define TCPOLEN_TSTAMP_ALIGNED&t;&t;12
DECL|macro|TCPOLEN_WSCALE_ALIGNED
mdefine_line|#define TCPOLEN_WSCALE_ALIGNED&t;&t;4
DECL|macro|TCPOLEN_SACKPERM_ALIGNED
mdefine_line|#define TCPOLEN_SACKPERM_ALIGNED&t;4
DECL|macro|TCPOLEN_SACK_BASE
mdefine_line|#define TCPOLEN_SACK_BASE&t;&t;2
DECL|macro|TCPOLEN_SACK_BASE_ALIGNED
mdefine_line|#define TCPOLEN_SACK_BASE_ALIGNED&t;4
DECL|macro|TCPOLEN_SACK_PERBLOCK
mdefine_line|#define TCPOLEN_SACK_PERBLOCK&t;&t;8
DECL|macro|TCP_TIME_RETRANS
mdefine_line|#define TCP_TIME_RETRANS&t;1&t;/* Retransmit timer */
DECL|macro|TCP_TIME_DACK
mdefine_line|#define TCP_TIME_DACK&t;&t;2&t;/* Delayed ack timer */
DECL|macro|TCP_TIME_PROBE0
mdefine_line|#define TCP_TIME_PROBE0&t;&t;3&t;/* Zero window probe timer */
DECL|macro|TCP_TIME_KEEPOPEN
mdefine_line|#define TCP_TIME_KEEPOPEN&t;4&t;/* Keepalive timer */
multiline_comment|/* sysctl variables for tcp */
r_extern
r_int
id|sysctl_max_syn_backlog
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_timestamps
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_window_scaling
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_sack
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_fin_timeout
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_tw_recycle
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_keepalive_time
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_keepalive_probes
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_keepalive_intvl
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_syn_retries
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_synack_retries
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_retries1
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_retries2
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_orphan_retries
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_syncookies
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_retrans_collapse
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_stdurg
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_rfc1337
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_tw_recycle
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_abort_on_overflow
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_max_orphans
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_max_tw_buckets
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_fack
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_reordering
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_ecn
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_dsack
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_mem
(braket
l_int|3
)braket
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_wmem
(braket
l_int|3
)braket
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_rmem
(braket
l_int|3
)braket
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_app_win
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_adv_win_scale
suffix:semicolon
r_extern
id|atomic_t
id|tcp_memory_allocated
suffix:semicolon
r_extern
id|atomic_t
id|tcp_sockets_allocated
suffix:semicolon
r_extern
r_int
id|tcp_memory_pressure
suffix:semicolon
r_struct
id|open_request
suffix:semicolon
DECL|struct|or_calltable
r_struct
id|or_calltable
(brace
DECL|member|family
r_int
id|family
suffix:semicolon
DECL|member|rtx_syn_ack
r_int
(paren
op_star
id|rtx_syn_ack
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|open_request
op_star
id|req
comma
r_struct
id|dst_entry
op_star
)paren
suffix:semicolon
DECL|member|send_ack
r_void
(paren
op_star
id|send_ack
)paren
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|open_request
op_star
id|req
)paren
suffix:semicolon
DECL|member|destructor
r_void
(paren
op_star
id|destructor
)paren
(paren
r_struct
id|open_request
op_star
id|req
)paren
suffix:semicolon
DECL|member|send_reset
r_void
(paren
op_star
id|send_reset
)paren
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|tcp_v4_open_req
r_struct
id|tcp_v4_open_req
(brace
DECL|member|loc_addr
id|__u32
id|loc_addr
suffix:semicolon
DECL|member|rmt_addr
id|__u32
id|rmt_addr
suffix:semicolon
DECL|member|opt
r_struct
id|ip_options
op_star
id|opt
suffix:semicolon
)brace
suffix:semicolon
macro_line|#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
DECL|struct|tcp_v6_open_req
r_struct
id|tcp_v6_open_req
(brace
DECL|member|loc_addr
r_struct
id|in6_addr
id|loc_addr
suffix:semicolon
DECL|member|rmt_addr
r_struct
id|in6_addr
id|rmt_addr
suffix:semicolon
DECL|member|pktopts
r_struct
id|sk_buff
op_star
id|pktopts
suffix:semicolon
DECL|member|iif
r_int
id|iif
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/* this structure is too big */
DECL|struct|open_request
r_struct
id|open_request
(brace
DECL|member|dl_next
r_struct
id|open_request
op_star
id|dl_next
suffix:semicolon
multiline_comment|/* Must be first member! */
DECL|member|rcv_isn
id|__u32
id|rcv_isn
suffix:semicolon
DECL|member|snt_isn
id|__u32
id|snt_isn
suffix:semicolon
DECL|member|rmt_port
id|__u16
id|rmt_port
suffix:semicolon
DECL|member|mss
id|__u16
id|mss
suffix:semicolon
DECL|member|retrans
id|__u8
id|retrans
suffix:semicolon
DECL|member|index
id|__u8
id|index
suffix:semicolon
DECL|member|snd_wscale
id|__u16
id|snd_wscale
suffix:colon
l_int|4
comma
DECL|member|rcv_wscale
id|rcv_wscale
suffix:colon
l_int|4
comma
DECL|member|tstamp_ok
id|tstamp_ok
suffix:colon
l_int|1
comma
DECL|member|sack_ok
id|sack_ok
suffix:colon
l_int|1
comma
DECL|member|wscale_ok
id|wscale_ok
suffix:colon
l_int|1
comma
DECL|member|ecn_ok
id|ecn_ok
suffix:colon
l_int|1
comma
DECL|member|acked
id|acked
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* The following two fields can be easily recomputed I think -AK */
DECL|member|window_clamp
id|__u32
id|window_clamp
suffix:semicolon
multiline_comment|/* window clamp at creation time */
DECL|member|rcv_wnd
id|__u32
id|rcv_wnd
suffix:semicolon
multiline_comment|/* rcv_wnd offered first time */
DECL|member|ts_recent
id|__u32
id|ts_recent
suffix:semicolon
DECL|member|expires
r_int
r_int
id|expires
suffix:semicolon
DECL|member|class
r_struct
id|or_calltable
op_star
r_class
suffix:semicolon
DECL|member|sk
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_union
(brace
DECL|member|v4_req
r_struct
id|tcp_v4_open_req
id|v4_req
suffix:semicolon
macro_line|#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
DECL|member|v6_req
r_struct
id|tcp_v6_open_req
id|v6_req
suffix:semicolon
macro_line|#endif
DECL|member|af
)brace
id|af
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* SLAB cache for open requests. */
r_extern
id|kmem_cache_t
op_star
id|tcp_openreq_cachep
suffix:semicolon
DECL|macro|tcp_openreq_alloc
mdefine_line|#define tcp_openreq_alloc()&t;&t;kmem_cache_alloc(tcp_openreq_cachep, SLAB_ATOMIC)
DECL|macro|tcp_openreq_fastfree
mdefine_line|#define tcp_openreq_fastfree(req)&t;kmem_cache_free(tcp_openreq_cachep, req)
DECL|function|tcp_openreq_free
r_static
r_inline
r_void
id|tcp_openreq_free
c_func
(paren
r_struct
id|open_request
op_star
id|req
)paren
(brace
id|req
op_member_access_from_pointer
r_class
op_member_access_from_pointer
id|destructor
c_func
(paren
id|req
)paren
suffix:semicolon
id|tcp_openreq_fastfree
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
DECL|macro|TCP_INET_FAMILY
mdefine_line|#define TCP_INET_FAMILY(fam) ((fam) == AF_INET)
macro_line|#else
DECL|macro|TCP_INET_FAMILY
mdefine_line|#define TCP_INET_FAMILY(fam) 1
macro_line|#endif
multiline_comment|/*&n; *&t;Pointers to address related TCP functions&n; *&t;(i.e. things that depend on the address family)&n; *&n; * &t;BUGGG_FUTURE: all the idea behind this struct is wrong.&n; *&t;It mixes socket frontend with transport function.&n; *&t;With port sharing between IPv6/v4 it gives the only advantage,&n; *&t;only poor IPv6 needs to permanently recheck, that it&n; *&t;is still IPv6 8)8) It must be cleaned up as soon as possible.&n; *&t;&t;&t;&t;&t;&t;--ANK (980802)&n; */
DECL|struct|tcp_func
r_struct
id|tcp_func
(brace
DECL|member|queue_xmit
r_int
(paren
op_star
id|queue_xmit
)paren
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
DECL|member|send_check
r_void
(paren
op_star
id|send_check
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
DECL|member|rebuild_header
r_int
(paren
op_star
id|rebuild_header
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|conn_request
r_int
(paren
op_star
id|conn_request
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
DECL|member|syn_recv_sock
r_struct
id|sock
op_star
(paren
op_star
id|syn_recv_sock
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|open_request
op_star
id|req
comma
r_struct
id|dst_entry
op_star
id|dst
)paren
suffix:semicolon
DECL|member|hash_connecting
r_int
(paren
op_star
id|hash_connecting
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|remember_stamp
r_int
(paren
op_star
id|remember_stamp
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|net_header_len
id|__u16
id|net_header_len
suffix:semicolon
DECL|member|setsockopt
r_int
(paren
op_star
id|setsockopt
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
suffix:semicolon
DECL|member|getsockopt
r_int
(paren
op_star
id|getsockopt
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
suffix:semicolon
DECL|member|addr2sockaddr
r_void
(paren
op_star
id|addr2sockaddr
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
)paren
suffix:semicolon
DECL|member|sockaddr_len
r_int
id|sockaddr_len
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * The next routines deal with comparing 32 bit unsigned ints&n; * and worry about wraparound (automatic with unsigned arithmetic).&n; */
DECL|function|before
r_extern
id|__inline
r_int
id|before
c_func
(paren
id|__u32
id|seq1
comma
id|__u32
id|seq2
)paren
(brace
r_return
(paren
id|__s32
)paren
(paren
id|seq1
op_minus
id|seq2
)paren
OL
l_int|0
suffix:semicolon
)brace
DECL|function|after
r_extern
id|__inline
r_int
id|after
c_func
(paren
id|__u32
id|seq1
comma
id|__u32
id|seq2
)paren
(brace
r_return
(paren
id|__s32
)paren
(paren
id|seq2
op_minus
id|seq1
)paren
OL
l_int|0
suffix:semicolon
)brace
multiline_comment|/* is s2&lt;=s1&lt;=s3 ? */
DECL|function|between
r_extern
id|__inline
r_int
id|between
c_func
(paren
id|__u32
id|seq1
comma
id|__u32
id|seq2
comma
id|__u32
id|seq3
)paren
(brace
r_return
id|seq3
op_minus
id|seq2
op_ge
id|seq1
op_minus
id|seq2
suffix:semicolon
)brace
r_extern
r_struct
id|proto
id|tcp_prot
suffix:semicolon
r_extern
r_struct
id|tcp_mib
id|tcp_statistics
(braket
id|NR_CPUS
op_star
l_int|2
)braket
suffix:semicolon
DECL|macro|TCP_INC_STATS
mdefine_line|#define TCP_INC_STATS(field)&t;&t;SNMP_INC_STATS(tcp_statistics, field)
DECL|macro|TCP_INC_STATS_BH
mdefine_line|#define TCP_INC_STATS_BH(field)&t;&t;SNMP_INC_STATS_BH(tcp_statistics, field)
DECL|macro|TCP_INC_STATS_USER
mdefine_line|#define TCP_INC_STATS_USER(field) &t;SNMP_INC_STATS_USER(tcp_statistics, field)
r_extern
r_void
id|tcp_put_port
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_void
id|__tcp_put_port
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_void
id|tcp_inherit_port
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sock
op_star
id|child
)paren
suffix:semicolon
r_extern
r_void
id|tcp_v4_err
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|tcp_shutdown
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|how
)paren
suffix:semicolon
r_extern
r_int
id|tcp_v4_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
suffix:semicolon
r_extern
r_int
id|tcp_v4_remember_stamp
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_int
id|tcp_v4_tw_remember_stamp
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
)paren
suffix:semicolon
r_extern
r_int
id|tcp_sendmsg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|size
)paren
suffix:semicolon
r_extern
r_int
id|tcp_ioctl
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_extern
r_int
id|tcp_rcv_state_process
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
)paren
suffix:semicolon
r_extern
r_int
id|tcp_rcv_established
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
)paren
suffix:semicolon
DECL|enum|tcp_ack_state_t
r_enum
id|tcp_ack_state_t
(brace
DECL|enumerator|TCP_ACK_SCHED
id|TCP_ACK_SCHED
op_assign
l_int|1
comma
DECL|enumerator|TCP_ACK_TIMER
id|TCP_ACK_TIMER
op_assign
l_int|2
comma
DECL|enumerator|TCP_ACK_PUSHED
id|TCP_ACK_PUSHED
op_assign
l_int|4
)brace
suffix:semicolon
DECL|function|tcp_schedule_ack
r_static
r_inline
r_void
id|tcp_schedule_ack
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
id|tp-&gt;ack.pending
op_or_assign
id|TCP_ACK_SCHED
suffix:semicolon
)brace
DECL|function|tcp_ack_scheduled
r_static
r_inline
r_int
id|tcp_ack_scheduled
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_return
id|tp-&gt;ack.pending
op_amp
id|TCP_ACK_SCHED
suffix:semicolon
)brace
DECL|function|tcp_dec_quickack_mode
r_static
id|__inline__
r_void
id|tcp_dec_quickack_mode
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;ack.quick
op_logical_and
op_decrement
id|tp-&gt;ack.quick
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Leaving quickack mode we deflate ATO. */
id|tp-&gt;ack.ato
op_assign
id|TCP_ATO_MIN
suffix:semicolon
)brace
)brace
r_extern
r_void
id|tcp_enter_quickack_mode
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
suffix:semicolon
DECL|function|tcp_delack_init
r_static
id|__inline__
r_void
id|tcp_delack_init
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
id|memset
c_func
(paren
op_amp
id|tp-&gt;ack
comma
l_int|0
comma
r_sizeof
(paren
id|tp-&gt;ack
)paren
)paren
suffix:semicolon
)brace
DECL|function|tcp_clear_options
r_static
r_inline
r_void
id|tcp_clear_options
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
id|tp-&gt;tstamp_ok
op_assign
id|tp-&gt;sack_ok
op_assign
id|tp-&gt;wscale_ok
op_assign
id|tp-&gt;snd_wscale
op_assign
l_int|0
suffix:semicolon
)brace
DECL|enum|tcp_tw_status
r_enum
id|tcp_tw_status
(brace
DECL|enumerator|TCP_TW_SUCCESS
id|TCP_TW_SUCCESS
op_assign
l_int|0
comma
DECL|enumerator|TCP_TW_RST
id|TCP_TW_RST
op_assign
l_int|1
comma
DECL|enumerator|TCP_TW_ACK
id|TCP_TW_ACK
op_assign
l_int|2
comma
DECL|enumerator|TCP_TW_SYN
id|TCP_TW_SYN
op_assign
l_int|3
)brace
suffix:semicolon
r_extern
r_enum
id|tcp_tw_status
id|tcp_timewait_state_process
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
)paren
suffix:semicolon
r_extern
r_struct
id|sock
op_star
id|tcp_check_req
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|open_request
op_star
id|req
comma
r_struct
id|open_request
op_star
op_star
id|prev
)paren
suffix:semicolon
r_extern
r_int
id|tcp_child_process
c_func
(paren
r_struct
id|sock
op_star
id|parent
comma
r_struct
id|sock
op_star
id|child
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_void
id|tcp_enter_loss
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|how
)paren
suffix:semicolon
r_extern
r_void
id|tcp_clear_retrans
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
suffix:semicolon
r_extern
r_void
id|tcp_update_metrics
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_void
id|tcp_close
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeout
)paren
suffix:semicolon
r_extern
r_struct
id|sock
op_star
id|tcp_accept
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
comma
r_int
op_star
id|err
)paren
suffix:semicolon
r_extern
r_int
r_int
id|tcp_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
suffix:semicolon
r_extern
r_void
id|tcp_write_space
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_int
id|tcp_getsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
suffix:semicolon
r_extern
r_int
id|tcp_setsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
suffix:semicolon
r_extern
r_void
id|tcp_set_keepalive
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|val
)paren
suffix:semicolon
r_extern
r_int
id|tcp_recvmsg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
comma
r_int
op_star
id|addr_len
)paren
suffix:semicolon
r_extern
r_int
id|tcp_listen_start
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_void
id|tcp_parse_options
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcp_opt
op_star
id|tp
comma
r_int
id|estab
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;TCP v4 functions exported for the inet6 API&n; */
r_extern
r_int
id|tcp_v4_rebuild_header
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_int
id|tcp_v4_build_header
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_void
id|tcp_v4_send_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_int
id|tcp_v4_conn_request
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_struct
id|sock
op_star
id|tcp_create_openreq_child
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|open_request
op_star
id|req
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_struct
id|sock
op_star
id|tcp_v4_syn_recv_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|open_request
op_star
id|req
comma
r_struct
id|dst_entry
op_star
id|dst
)paren
suffix:semicolon
r_extern
r_int
id|tcp_v4_do_rcv
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_int
id|tcp_v4_connect
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
)paren
suffix:semicolon
r_extern
r_int
id|tcp_connect
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|tcp_make_synack
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|dst_entry
op_star
id|dst
comma
r_struct
id|open_request
op_star
id|req
)paren
suffix:semicolon
r_extern
r_int
id|tcp_disconnect
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
)paren
suffix:semicolon
r_extern
r_void
id|tcp_unhash
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_int
id|tcp_v4_hash_connecting
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
multiline_comment|/* From syncookies.c */
r_extern
r_struct
id|sock
op_star
id|cookie_v4_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|ip_options
op_star
id|opt
)paren
suffix:semicolon
r_extern
id|__u32
id|cookie_v4_init_sequence
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
id|__u16
op_star
id|mss
)paren
suffix:semicolon
multiline_comment|/* tcp_output.c */
r_extern
r_int
id|tcp_write_xmit
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_int
id|tcp_retransmit_skb
c_func
(paren
r_struct
id|sock
op_star
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_xmit_retransmit_queue
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_simple_retransmit
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_send_probe0
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_send_partial
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_int
id|tcp_write_wakeup
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_send_fin
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_void
id|tcp_send_active_reset
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|priority
)paren
suffix:semicolon
r_extern
r_int
id|tcp_send_synack
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_int
id|tcp_transmit_skb
c_func
(paren
r_struct
id|sock
op_star
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_send_skb
c_func
(paren
r_struct
id|sock
op_star
comma
r_struct
id|sk_buff
op_star
comma
r_int
id|force_queue
comma
r_int
id|mss_now
)paren
suffix:semicolon
r_extern
r_void
id|tcp_send_ack
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_void
id|tcp_send_delayed_ack
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
multiline_comment|/* tcp_timer.c */
r_extern
r_void
id|tcp_init_xmit_timers
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_clear_xmit_timers
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_delete_keepalive_timer
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_reset_keepalive_timer
(paren
r_struct
id|sock
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_int
id|tcp_sync_mss
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|pmtu
)paren
suffix:semicolon
r_extern
r_const
r_char
id|timer_bug_msg
(braket
)braket
suffix:semicolon
DECL|function|tcp_clear_xmit_timer
r_static
r_inline
r_void
id|tcp_clear_xmit_timer
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|what
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_switch
c_cond
(paren
id|what
)paren
(brace
r_case
id|TCP_TIME_RETRANS
suffix:colon
r_case
id|TCP_TIME_PROBE0
suffix:colon
id|tp-&gt;pending
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef TCP_CLEAR_TIMERS
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|tp-&gt;retransmit_timer
)paren
op_logical_and
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;retransmit_timer
)paren
)paren
id|__sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|TCP_TIME_DACK
suffix:colon
id|tp-&gt;ack.blocked
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;ack.pending
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef TCP_CLEAR_TIMERS
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|tp-&gt;delack_timer
)paren
op_logical_and
id|del_timer
c_func
(paren
op_amp
id|tp-&gt;delack_timer
)paren
)paren
id|__sock_put
c_func
(paren
id|sk
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|timer_bug_msg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Reset the retransmission timer&n; */
DECL|function|tcp_reset_xmit_timer
r_static
r_inline
r_void
id|tcp_reset_xmit_timer
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|what
comma
r_int
r_int
id|when
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_if
c_cond
(paren
id|when
OG
id|TCP_RTO_MAX
)paren
(brace
macro_line|#ifdef TCP_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;reset_xmit_timer sk=%p %d when=0x%lx, caller=%p&bslash;n&quot;
comma
id|sk
comma
id|what
comma
id|when
comma
id|current_text_addr
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
id|when
op_assign
id|TCP_RTO_MAX
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|what
)paren
(brace
r_case
id|TCP_TIME_RETRANS
suffix:colon
r_case
id|TCP_TIME_PROBE0
suffix:colon
id|tp-&gt;pending
op_assign
id|what
suffix:semicolon
id|tp-&gt;timeout
op_assign
id|jiffies
op_plus
id|when
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|tp-&gt;retransmit_timer
comma
id|tp-&gt;timeout
)paren
)paren
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_TIME_DACK
suffix:colon
id|tp-&gt;ack.pending
op_or_assign
id|TCP_ACK_TIMER
suffix:semicolon
id|tp-&gt;ack.timeout
op_assign
id|jiffies
op_plus
id|when
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mod_timer
c_func
(paren
op_amp
id|tp-&gt;delack_timer
comma
id|tp-&gt;ack.timeout
)paren
)paren
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;bug: unknown timer value&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/* Compute the current effective MSS, taking SACKs and IP options,&n; * and even PMTU discovery events into account.&n; */
DECL|function|tcp_current_mss
r_static
id|__inline__
r_int
r_int
id|tcp_current_mss
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|__sk_dst_get
c_func
(paren
id|sk
)paren
suffix:semicolon
r_int
id|mss_now
op_assign
id|tp-&gt;mss_cache
suffix:semicolon
r_if
c_cond
(paren
id|dst
op_logical_and
id|dst-&gt;pmtu
op_ne
id|tp-&gt;pmtu_cookie
)paren
id|mss_now
op_assign
id|tcp_sync_mss
c_func
(paren
id|sk
comma
id|dst-&gt;pmtu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;eff_sacks
)paren
id|mss_now
op_sub_assign
(paren
id|TCPOLEN_SACK_BASE_ALIGNED
op_plus
(paren
id|tp-&gt;eff_sacks
op_star
id|TCPOLEN_SACK_PERBLOCK
)paren
)paren
suffix:semicolon
r_return
id|mss_now
suffix:semicolon
)brace
multiline_comment|/* Initialize RCV_MSS value.&n; * RCV_MSS is an our guess about MSS used by the peer.&n; * We haven&squot;t any direct information about the MSS.&n; * It&squot;s better to underestimate the RCV_MSS rather than overestimate.&n; * Overestimations make us ACKing less frequently than needed.&n; * Underestimations are more easy to detect and fix by tcp_measure_rcv_mss().&n; */
DECL|function|tcp_initialize_rcv_mss
r_static
r_inline
r_void
id|tcp_initialize_rcv_mss
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_int
id|hint
op_assign
id|min
c_func
(paren
id|tp-&gt;advmss
comma
id|tp-&gt;mss_cache
)paren
suffix:semicolon
id|hint
op_assign
id|min
c_func
(paren
id|hint
comma
id|tp-&gt;rcv_wnd
op_div
l_int|2
)paren
suffix:semicolon
id|tp-&gt;ack.rcv_mss
op_assign
id|max
c_func
(paren
id|min
c_func
(paren
id|hint
comma
id|TCP_MIN_RCVMSS
)paren
comma
id|TCP_MIN_MSS
)paren
suffix:semicolon
)brace
DECL|function|__tcp_fast_path_on
r_static
id|__inline__
r_void
id|__tcp_fast_path_on
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
id|u32
id|snd_wnd
)paren
(brace
id|tp-&gt;pred_flags
op_assign
id|htonl
c_func
(paren
(paren
id|tp-&gt;tcp_header_len
op_lshift
l_int|26
)paren
op_or
id|ntohl
c_func
(paren
id|TCP_FLAG_ACK
)paren
op_or
id|snd_wnd
)paren
suffix:semicolon
)brace
DECL|function|tcp_fast_path_on
r_static
id|__inline__
r_void
id|tcp_fast_path_on
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
id|__tcp_fast_path_on
c_func
(paren
id|tp
comma
id|tp-&gt;snd_wnd
op_rshift
id|tp-&gt;snd_wscale
)paren
suffix:semicolon
)brace
multiline_comment|/* Compute the actual receive window we are currently advertising.&n; * Rcv_nxt can be after the window if our peer push more data&n; * than the offered window.&n; */
DECL|function|tcp_receive_window
r_static
id|__inline__
id|u32
id|tcp_receive_window
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
id|s32
id|win
op_assign
id|tp-&gt;rcv_wup
op_plus
id|tp-&gt;rcv_wnd
op_minus
id|tp-&gt;rcv_nxt
suffix:semicolon
r_if
c_cond
(paren
id|win
OL
l_int|0
)paren
id|win
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|u32
)paren
id|win
suffix:semicolon
)brace
multiline_comment|/* Choose a new window, without checks for shrinking, and without&n; * scaling applied to the result.  The caller does these things&n; * if necessary.  This is a &quot;raw&quot; window selection.&n; */
r_extern
id|u32
id|__tcp_select_window
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
multiline_comment|/* TCP timestamps are only 32-bits, this causes a slight&n; * complication on 64-bit systems since we store a snapshot&n; * of jiffies in the buffer control blocks below.  We decidely&n; * only use of the low 32-bits of jiffies and hide the ugly&n; * casts with the following macro.&n; */
DECL|macro|tcp_time_stamp
mdefine_line|#define tcp_time_stamp&t;&t;((__u32)(jiffies))
multiline_comment|/* This is what the send packet queueing engine uses to pass&n; * TCP per-packet control information to the transmission&n; * code.  We also store the host-order sequence numbers in&n; * here too.  This is 36 bytes on 32-bit architectures,&n; * 40 bytes on 64-bit machines, if this grows please adjust&n; * skbuff.h:skbuff-&gt;cb[xxx] size appropriately.&n; */
DECL|struct|tcp_skb_cb
r_struct
id|tcp_skb_cb
(brace
r_union
(brace
DECL|member|h4
r_struct
id|inet_skb_parm
id|h4
suffix:semicolon
macro_line|#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
DECL|member|h6
r_struct
id|inet6_skb_parm
id|h6
suffix:semicolon
macro_line|#endif
DECL|member|header
)brace
id|header
suffix:semicolon
multiline_comment|/* For incoming frames&t;&t;*/
DECL|member|seq
id|__u32
id|seq
suffix:semicolon
multiline_comment|/* Starting sequence number&t;*/
DECL|member|end_seq
id|__u32
id|end_seq
suffix:semicolon
multiline_comment|/* SEQ + FIN + SYN + datalen&t;*/
DECL|member|when
id|__u32
id|when
suffix:semicolon
multiline_comment|/* used to compute rtt&squot;s&t;*/
DECL|member|flags
id|__u8
id|flags
suffix:semicolon
multiline_comment|/* TCP header flags.&t;&t;*/
multiline_comment|/* NOTE: These must match up to the flags byte in a&n;&t; *       real TCP header.&n;&t; */
DECL|macro|TCPCB_FLAG_FIN
mdefine_line|#define TCPCB_FLAG_FIN&t;&t;0x01
DECL|macro|TCPCB_FLAG_SYN
mdefine_line|#define TCPCB_FLAG_SYN&t;&t;0x02
DECL|macro|TCPCB_FLAG_RST
mdefine_line|#define TCPCB_FLAG_RST&t;&t;0x04
DECL|macro|TCPCB_FLAG_PSH
mdefine_line|#define TCPCB_FLAG_PSH&t;&t;0x08
DECL|macro|TCPCB_FLAG_ACK
mdefine_line|#define TCPCB_FLAG_ACK&t;&t;0x10
DECL|macro|TCPCB_FLAG_URG
mdefine_line|#define TCPCB_FLAG_URG&t;&t;0x20
DECL|macro|TCPCB_FLAG_ECE
mdefine_line|#define TCPCB_FLAG_ECE&t;&t;0x40
DECL|macro|TCPCB_FLAG_CWR
mdefine_line|#define TCPCB_FLAG_CWR&t;&t;0x80
DECL|member|sacked
id|__u8
id|sacked
suffix:semicolon
multiline_comment|/* State flags for SACK/FACK.&t;*/
DECL|macro|TCPCB_SACKED_ACKED
mdefine_line|#define TCPCB_SACKED_ACKED&t;0x01&t;/* SKB ACK&squot;d by a SACK block&t;*/
DECL|macro|TCPCB_SACKED_RETRANS
mdefine_line|#define TCPCB_SACKED_RETRANS&t;0x02&t;/* SKB retransmitted&t;&t;*/
DECL|macro|TCPCB_LOST
mdefine_line|#define TCPCB_LOST&t;&t;0x04&t;/* SKB is lost&t;&t;&t;*/
DECL|macro|TCPCB_TAGBITS
mdefine_line|#define TCPCB_TAGBITS&t;&t;0x07&t;/* All tag bits&t;&t;&t;*/
DECL|macro|TCPCB_EVER_RETRANS
mdefine_line|#define TCPCB_EVER_RETRANS&t;0x80&t;/* Ever retransmitted frame&t;*/
DECL|macro|TCPCB_RETRANS
mdefine_line|#define TCPCB_RETRANS&t;&t;(TCPCB_SACKED_RETRANS|TCPCB_EVER_RETRANS)
DECL|macro|TCPCB_URG
mdefine_line|#define TCPCB_URG&t;&t;0x20&t;/* Urgent pointer advenced here&t;*/
DECL|macro|TCPCB_AT_TAIL
mdefine_line|#define TCPCB_AT_TAIL&t;&t;(TCPCB_URG)
DECL|member|urg_ptr
id|__u16
id|urg_ptr
suffix:semicolon
multiline_comment|/* Valid w/URG flags is set.&t;*/
DECL|member|ack_seq
id|__u32
id|ack_seq
suffix:semicolon
multiline_comment|/* Sequence number ACK&squot;d&t;*/
)brace
suffix:semicolon
DECL|macro|TCP_SKB_CB
mdefine_line|#define TCP_SKB_CB(__skb)&t;((struct tcp_skb_cb *)&amp;((__skb)-&gt;cb[0]))
DECL|macro|for_retrans_queue
mdefine_line|#define for_retrans_queue(skb, sk, tp) &bslash;&n;&t;&t;for (skb = (sk)-&gt;write_queue.next;&t;&t;&t;&bslash;&n;&t;&t;     (skb != (tp)-&gt;send_head) &amp;&amp;&t;&t;&t;&bslash;&n;&t;&t;     (skb != (struct sk_buff *)&amp;(sk)-&gt;write_queue);&t;&bslash;&n;&t;&t;     skb=skb-&gt;next)
macro_line|#include &lt;net/tcp_ecn.h&gt;
multiline_comment|/*&n; *&t;Compute minimal free write space needed to queue new packets. &n; */
DECL|function|tcp_min_write_space
r_static
r_inline
r_int
id|tcp_min_write_space
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|sk-&gt;wmem_queued
op_div
l_int|2
suffix:semicolon
)brace
DECL|function|tcp_wspace
r_static
r_inline
r_int
id|tcp_wspace
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|sk-&gt;sndbuf
op_minus
id|sk-&gt;wmem_queued
suffix:semicolon
)brace
multiline_comment|/* This determines how many packets are &quot;in the network&quot; to the best&n; * of our knowledge.  In many cases it is conservative, but where&n; * detailed information is available from the receiver (via SACK&n; * blocks etc.) we can make more aggressive calculations.&n; *&n; * Use this for decisions involving congestion control, use just&n; * tp-&gt;packets_out to determine if the send queue is empty or not.&n; *&n; * Read this equation as:&n; *&n; *&t;&quot;Packets sent once on transmission queue&quot; MINUS&n; *&t;&quot;Packets left network, but not honestly ACKed yet&quot; PLUS&n; *&t;&quot;Packets fast retransmitted&quot;&n; */
DECL|function|tcp_packets_in_flight
r_static
id|__inline__
r_int
id|tcp_packets_in_flight
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_return
id|tp-&gt;packets_out
op_minus
id|tp-&gt;left_out
op_plus
id|tp-&gt;retrans_out
suffix:semicolon
)brace
multiline_comment|/* Recalculate snd_ssthresh, we want to set it to:&n; *&n; * &t;one half the current congestion window, but no&n; *&t;less than two segments&n; */
DECL|function|tcp_recalc_ssthresh
r_static
r_inline
id|__u32
id|tcp_recalc_ssthresh
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_return
id|max
c_func
(paren
id|tp-&gt;snd_cwnd
op_rshift
l_int|1
comma
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* If cwnd &gt; ssthresh, we may raise ssthresh to be half-way to cwnd.&n; * The exception is rate halving phase, when cwnd is decreasing towards&n; * ssthresh.&n; */
DECL|function|tcp_current_ssthresh
r_static
r_inline
id|__u32
id|tcp_current_ssthresh
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|tp-&gt;ca_state
)paren
op_amp
(paren
id|TCPF_CA_CWR
op_or
id|TCPF_CA_Recovery
)paren
)paren
r_return
id|tp-&gt;snd_ssthresh
suffix:semicolon
r_else
r_return
id|max
c_func
(paren
id|tp-&gt;snd_ssthresh
comma
(paren
id|tp-&gt;snd_cwnd
op_rshift
l_int|1
)paren
op_plus
(paren
id|tp-&gt;snd_cwnd
op_rshift
l_int|2
)paren
)paren
suffix:semicolon
)brace
r_extern
r_void
id|tcp_cwnd_application_limited
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
multiline_comment|/* Congestion window validation. (RFC2861) */
DECL|function|tcp_cwnd_validate
r_static
r_inline
r_void
id|tcp_cwnd_validate
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;packets_out
op_ge
id|tp-&gt;snd_cwnd
)paren
(brace
multiline_comment|/* Network is feed fully. */
id|tp-&gt;snd_cwnd_used
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;snd_cwnd_stamp
op_assign
id|tcp_time_stamp
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Network starves. */
r_if
c_cond
(paren
id|tp-&gt;packets_out
OG
id|tp-&gt;snd_cwnd_used
)paren
id|tp-&gt;snd_cwnd_used
op_assign
id|tp-&gt;packets_out
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s32
)paren
(paren
id|tcp_time_stamp
op_minus
id|tp-&gt;snd_cwnd_stamp
)paren
op_ge
id|tp-&gt;rto
)paren
id|tcp_cwnd_application_limited
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Set slow start threshould and cwnd not falling to slow start */
DECL|function|__tcp_enter_cwr
r_static
r_inline
r_void
id|__tcp_enter_cwr
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
id|tp-&gt;undo_marker
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;snd_ssthresh
op_assign
id|tcp_recalc_ssthresh
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;snd_cwnd
op_assign
id|min
c_func
(paren
id|tp-&gt;snd_cwnd
comma
id|tcp_packets_in_flight
c_func
(paren
id|tp
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|tp-&gt;snd_cwnd_cnt
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;high_seq
op_assign
id|tp-&gt;snd_nxt
suffix:semicolon
id|tp-&gt;snd_cwnd_stamp
op_assign
id|tcp_time_stamp
suffix:semicolon
id|TCP_ECN_queue_cwr
c_func
(paren
id|tp
)paren
suffix:semicolon
)brace
DECL|function|tcp_enter_cwr
r_static
r_inline
r_void
id|tcp_enter_cwr
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
id|tp-&gt;prior_ssthresh
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ca_state
OL
id|TCP_CA_CWR
)paren
(brace
id|__tcp_enter_cwr
c_func
(paren
id|tp
)paren
suffix:semicolon
id|tp-&gt;ca_state
op_assign
id|TCP_CA_CWR
suffix:semicolon
)brace
)brace
r_extern
id|__u32
id|tcp_init_cwnd
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
suffix:semicolon
multiline_comment|/* Slow start with delack produces 3 packets of burst, so that&n; * it is safe &quot;de facto&quot;.&n; */
DECL|function|tcp_max_burst
r_static
id|__inline__
id|__u32
id|tcp_max_burst
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_return
l_int|3
suffix:semicolon
)brace
DECL|function|tcp_minshall_check
r_static
id|__inline__
r_int
id|tcp_minshall_check
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_return
id|after
c_func
(paren
id|tp-&gt;snd_sml
comma
id|tp-&gt;snd_una
)paren
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|tp-&gt;snd_sml
comma
id|tp-&gt;snd_nxt
)paren
suffix:semicolon
)brace
DECL|function|tcp_minshall_update
r_static
id|__inline__
r_void
id|tcp_minshall_update
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
r_int
id|mss
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;len
OL
id|mss
)paren
id|tp-&gt;snd_sml
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
suffix:semicolon
)brace
multiline_comment|/* Return 0, if packet can be sent now without violation Nagle&squot;s rules:&n;   1. It is full sized.&n;   2. Or it contains FIN.&n;   3. Or TCP_NODELAY was set.&n;   4. Or TCP_CORK is not set, and all sent packets are ACKed.&n;      With Minshall&squot;s modification: all sent small packets are ACKed.&n; */
r_static
id|__inline__
r_int
DECL|function|tcp_nagle_check
id|tcp_nagle_check
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|mss_now
comma
r_int
id|nonagle
)paren
(brace
r_return
(paren
id|skb-&gt;len
OL
id|mss_now
op_logical_and
op_logical_neg
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_amp
id|TCPCB_FLAG_FIN
)paren
op_logical_and
(paren
id|nonagle
op_eq
l_int|2
op_logical_or
(paren
op_logical_neg
id|nonagle
op_logical_and
id|tp-&gt;packets_out
op_logical_and
id|tcp_minshall_check
c_func
(paren
id|tp
)paren
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This checks if the data bearing packet SKB (usually tp-&gt;send_head)&n; * should be put on the wire right now.&n; */
DECL|function|tcp_snd_test
r_static
id|__inline__
r_int
id|tcp_snd_test
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|cur_mss
comma
r_int
id|nonagle
)paren
(brace
multiline_comment|/*&t;RFC 1122 - section 4.2.3.4&n;&t; *&n;&t; *&t;We must queue if&n;&t; *&n;&t; *&t;a) The right edge of this frame exceeds the window&n;&t; *&t;b) There are packets in flight and we have a small segment&n;&t; *&t;   [SWS avoidance and Nagle algorithm]&n;&t; *&t;   (part of SWS is done on packetization)&n;&t; *&t;   Minshall version sounds: there are no _small_&n;&t; *&t;   segments in flight. (tcp_nagle_check)&n;&t; *&t;c) We have too many packets &squot;in flight&squot;&n;&t; *&n;&t; * &t;Don&squot;t use the nagle rule for urgent data (or&n;&t; *&t;for the final FIN -DaveM).&n;&t; *&n;&t; *&t;Also, Nagle rule does not apply to frames, which&n;&t; *&t;sit in the middle of queue (they have no chances&n;&t; *&t;to get new data) and if room at tail of skb is&n;&t; *&t;not enough to save something seriously (&lt;32 for now).&n;&t; */
multiline_comment|/* Don&squot;t be strict about the congestion window for the&n;&t; * final FIN frame.  -DaveM&n;&t; */
r_return
(paren
(paren
id|nonagle
op_eq
l_int|1
op_logical_or
id|tp-&gt;urg_mode
op_logical_or
op_logical_neg
id|tcp_nagle_check
c_func
(paren
id|tp
comma
id|skb
comma
id|cur_mss
comma
id|nonagle
)paren
)paren
op_logical_and
(paren
(paren
id|tcp_packets_in_flight
c_func
(paren
id|tp
)paren
OL
id|tp-&gt;snd_cwnd
)paren
op_logical_or
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_amp
id|TCPCB_FLAG_FIN
)paren
)paren
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|tp-&gt;snd_una
op_plus
id|tp-&gt;snd_wnd
)paren
)paren
suffix:semicolon
)brace
DECL|function|tcp_check_probe_timer
r_static
id|__inline__
r_void
id|tcp_check_probe_timer
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;packets_out
op_logical_and
op_logical_neg
id|tp-&gt;pending
)paren
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_PROBE0
comma
id|tp-&gt;rto
)paren
suffix:semicolon
)brace
DECL|function|tcp_skb_is_last
r_static
id|__inline__
r_int
id|tcp_skb_is_last
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
(paren
id|skb-&gt;next
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
op_amp
id|sk-&gt;write_queue
)paren
suffix:semicolon
)brace
multiline_comment|/* Push out any pending frames which were held back due to&n; * TCP_CORK or attempt at coalescing tiny packets.&n; * The socket must be locked by the caller.&n; */
DECL|function|__tcp_push_pending_frames
r_static
id|__inline__
r_void
id|__tcp_push_pending_frames
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_opt
op_star
id|tp
comma
r_int
id|cur_mss
comma
r_int
id|nonagle
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|tp-&gt;send_head
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tcp_skb_is_last
c_func
(paren
id|sk
comma
id|skb
)paren
)paren
id|nonagle
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_snd_test
c_func
(paren
id|tp
comma
id|skb
comma
id|cur_mss
comma
id|nonagle
)paren
op_logical_or
id|tcp_write_xmit
c_func
(paren
id|sk
)paren
)paren
id|tcp_check_probe_timer
c_func
(paren
id|sk
comma
id|tp
)paren
suffix:semicolon
)brace
id|tcp_cwnd_validate
c_func
(paren
id|sk
comma
id|tp
)paren
suffix:semicolon
)brace
DECL|function|tcp_push_pending_frames
r_static
id|__inline__
r_void
id|tcp_push_pending_frames
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
id|__tcp_push_pending_frames
c_func
(paren
id|sk
comma
id|tp
comma
id|tcp_current_mss
c_func
(paren
id|sk
)paren
comma
id|tp-&gt;nonagle
)paren
suffix:semicolon
)brace
DECL|function|tcp_may_send_now
r_static
id|__inline__
r_int
id|tcp_may_send_now
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|tp-&gt;send_head
suffix:semicolon
r_return
(paren
id|skb
op_logical_and
id|tcp_snd_test
c_func
(paren
id|tp
comma
id|skb
comma
id|tcp_current_mss
c_func
(paren
id|sk
)paren
comma
id|tcp_skb_is_last
c_func
(paren
id|sk
comma
id|skb
)paren
ques
c_cond
l_int|1
suffix:colon
id|tp-&gt;nonagle
)paren
)paren
suffix:semicolon
)brace
DECL|function|tcp_init_wl
r_static
id|__inline__
r_void
id|tcp_init_wl
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
id|u32
id|ack
comma
id|u32
id|seq
)paren
(brace
id|tp-&gt;snd_wl1
op_assign
id|seq
suffix:semicolon
)brace
DECL|function|tcp_update_wl
r_static
id|__inline__
r_void
id|tcp_update_wl
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
id|u32
id|ack
comma
id|u32
id|seq
)paren
(brace
id|tp-&gt;snd_wl1
op_assign
id|seq
suffix:semicolon
)brace
r_extern
r_void
id|tcp_destroy_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
multiline_comment|/*&n; * Calculate(/check) TCP checksum&n; */
DECL|function|tcp_v4_check
r_static
id|__inline__
id|u16
id|tcp_v4_check
c_func
(paren
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|base
)paren
(brace
r_return
id|csum_tcpudp_magic
c_func
(paren
id|saddr
comma
id|daddr
comma
id|len
comma
id|IPPROTO_TCP
comma
id|base
)paren
suffix:semicolon
)brace
DECL|function|__tcp_checksum_complete
r_static
id|__inline__
r_int
id|__tcp_checksum_complete
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
(paren
r_int
r_int
)paren
id|csum_fold
c_func
(paren
id|csum_partial
c_func
(paren
id|skb-&gt;h.raw
comma
id|skb-&gt;len
comma
id|skb-&gt;csum
)paren
)paren
suffix:semicolon
)brace
DECL|function|tcp_checksum_complete
r_static
id|__inline__
r_int
id|tcp_checksum_complete
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
id|skb-&gt;ip_summed
op_ne
id|CHECKSUM_UNNECESSARY
op_logical_and
id|__tcp_checksum_complete
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* Prequeue for VJ style copy to user, combined with checksumming. */
DECL|function|tcp_prequeue_init
r_static
id|__inline__
r_void
id|tcp_prequeue_init
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
id|tp-&gt;ucopy.task
op_assign
l_int|NULL
suffix:semicolon
id|tp-&gt;ucopy.len
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;ucopy.memory
op_assign
l_int|0
suffix:semicolon
id|skb_queue_head_init
c_func
(paren
op_amp
id|tp-&gt;ucopy.prequeue
)paren
suffix:semicolon
)brace
multiline_comment|/* Packet is added to VJ-style prequeue for processing in process&n; * context, if a reader task is waiting. Apparently, this exciting&n; * idea (VJ&squot;s mail &quot;Re: query about TCP header on tcp-ip&quot; of 07 Sep 93)&n; * failed somewhere. Latency? Burstiness? Well, at least now we will&n; * see, why it failed. 8)8)&t;&t;&t;&t;  --ANK&n; */
DECL|function|tcp_prequeue
r_static
id|__inline__
r_int
id|tcp_prequeue
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;ucopy.task
)paren
(brace
r_if
c_cond
(paren
(paren
id|tp-&gt;ucopy.memory
op_add_assign
id|skb-&gt;truesize
)paren
op_le
(paren
id|sk-&gt;rcvbuf
op_lshift
l_int|1
)paren
)paren
(brace
id|__skb_queue_tail
c_func
(paren
op_amp
id|tp-&gt;ucopy.prequeue
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb_queue_len
c_func
(paren
op_amp
id|tp-&gt;ucopy.prequeue
)paren
op_eq
l_int|1
)paren
(brace
id|wake_up_interruptible
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tcp_ack_scheduled
c_func
(paren
id|tp
)paren
)paren
id|tcp_reset_xmit_timer
c_func
(paren
id|sk
comma
id|TCP_TIME_DACK
comma
(paren
l_int|3
op_star
id|TCP_RTO_MIN
)paren
op_div
l_int|4
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|NET_INC_STATS_BH
c_func
(paren
id|TCPPrequeueDropped
)paren
suffix:semicolon
id|tp-&gt;ucopy.memory
op_sub_assign
id|skb-&gt;truesize
suffix:semicolon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|STATE_TRACE
macro_line|#undef STATE_TRACE
macro_line|#ifdef STATE_TRACE
DECL|variable|statename
r_static
r_char
op_star
id|statename
(braket
)braket
op_assign
initialization_block
suffix:semicolon
macro_line|#endif
DECL|function|tcp_set_state
r_static
id|__inline__
r_void
id|tcp_set_state
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|state
)paren
(brace
r_int
id|oldstate
op_assign
id|sk-&gt;state
suffix:semicolon
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|TCP_ESTABLISHED
suffix:colon
r_if
c_cond
(paren
id|oldstate
op_ne
id|TCP_ESTABLISHED
)paren
id|TCP_INC_STATS
c_func
(paren
id|TcpCurrEstab
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE
suffix:colon
id|sk-&gt;prot
op_member_access_from_pointer
id|unhash
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;prev
op_logical_and
op_logical_neg
(paren
id|sk-&gt;userlocks
op_amp
id|SOCK_BINDPORT_LOCK
)paren
)paren
id|tcp_put_port
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|oldstate
op_eq
id|TCP_ESTABLISHED
)paren
id|tcp_statistics
(braket
id|smp_processor_id
c_func
(paren
)paren
op_star
l_int|2
op_plus
op_logical_neg
id|in_softirq
c_func
(paren
)paren
)braket
dot
id|TcpCurrEstab
op_decrement
suffix:semicolon
)brace
multiline_comment|/* Change state AFTER socket is unhashed to avoid closed&n;&t; * socket sitting in hash tables.&n;&t; */
id|sk-&gt;state
op_assign
id|state
suffix:semicolon
macro_line|#ifdef STATE_TRACE
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;TCP sk=%p, State %s -&gt; %s&bslash;n&quot;
comma
id|sk
comma
id|statename
(braket
id|oldstate
)braket
comma
id|statename
(braket
id|state
)braket
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
DECL|function|tcp_done
r_static
id|__inline__
r_void
id|tcp_done
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|tcp_set_state
c_func
(paren
id|sk
comma
id|TCP_CLOSE
)paren
suffix:semicolon
id|tcp_clear_xmit_timers
c_func
(paren
id|sk
)paren
suffix:semicolon
id|sk-&gt;shutdown
op_assign
id|SHUTDOWN_MASK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|state_change
c_func
(paren
id|sk
)paren
suffix:semicolon
r_else
id|tcp_destroy_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
DECL|function|tcp_sack_reset
r_static
id|__inline__
r_void
id|tcp_sack_reset
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
id|tp-&gt;dsack
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;eff_sacks
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;num_sacks
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|tcp_build_and_update_options
r_static
id|__inline__
r_void
id|tcp_build_and_update_options
c_func
(paren
id|__u32
op_star
id|ptr
comma
r_struct
id|tcp_opt
op_star
id|tp
comma
id|__u32
id|tstamp
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;tstamp_ok
)paren
(brace
op_star
id|ptr
op_increment
op_assign
id|__constant_htonl
c_func
(paren
(paren
id|TCPOPT_NOP
op_lshift
l_int|24
)paren
op_or
(paren
id|TCPOPT_NOP
op_lshift
l_int|16
)paren
op_or
(paren
id|TCPOPT_TIMESTAMP
op_lshift
l_int|8
)paren
op_or
id|TCPOLEN_TIMESTAMP
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|htonl
c_func
(paren
id|tstamp
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|htonl
c_func
(paren
id|tp-&gt;ts_recent
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;eff_sacks
)paren
(brace
r_struct
id|tcp_sack_block
op_star
id|sp
op_assign
id|tp-&gt;dsack
ques
c_cond
id|tp-&gt;duplicate_sack
suffix:colon
id|tp-&gt;selective_acks
suffix:semicolon
r_int
id|this_sack
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|__constant_htonl
c_func
(paren
(paren
id|TCPOPT_NOP
op_lshift
l_int|24
)paren
op_or
(paren
id|TCPOPT_NOP
op_lshift
l_int|16
)paren
op_or
(paren
id|TCPOPT_SACK
op_lshift
l_int|8
)paren
op_or
(paren
id|TCPOLEN_SACK_BASE
op_plus
(paren
id|tp-&gt;eff_sacks
op_star
id|TCPOLEN_SACK_PERBLOCK
)paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|this_sack
op_assign
l_int|0
suffix:semicolon
id|this_sack
OL
id|tp-&gt;eff_sacks
suffix:semicolon
id|this_sack
op_increment
)paren
(brace
op_star
id|ptr
op_increment
op_assign
id|htonl
c_func
(paren
id|sp
(braket
id|this_sack
)braket
dot
id|start_seq
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|htonl
c_func
(paren
id|sp
(braket
id|this_sack
)braket
dot
id|end_seq
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;dsack
)paren
(brace
id|tp-&gt;dsack
op_assign
l_int|0
suffix:semicolon
id|tp-&gt;eff_sacks
op_decrement
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Construct a tcp options header for a SYN or SYN_ACK packet.&n; * If this is every changed make sure to change the definition of&n; * MAX_SYN_SIZE to match the new maximum number of options that you&n; * can generate.&n; */
DECL|function|tcp_syn_build_options
r_static
r_inline
r_void
id|tcp_syn_build_options
c_func
(paren
id|__u32
op_star
id|ptr
comma
r_int
id|mss
comma
r_int
id|ts
comma
r_int
id|sack
comma
r_int
id|offer_wscale
comma
r_int
id|wscale
comma
id|__u32
id|tstamp
comma
id|__u32
id|ts_recent
)paren
(brace
multiline_comment|/* We always get an MSS option.&n;&t; * The option bytes which will be seen in normal data&n;&t; * packets should timestamps be used, must be in the MSS&n;&t; * advertised.  But we subtract them from tp-&gt;mss_cache so&n;&t; * that calculations in tcp_sendmsg are simpler etc.&n;&t; * So account for this fact here if necessary.  If we&n;&t; * don&squot;t do this correctly, as a receiver we won&squot;t&n;&t; * recognize data packets as being full sized when we&n;&t; * should, and thus we won&squot;t abide by the delayed ACK&n;&t; * rules correctly.&n;&t; * SACKs don&squot;t matter, we never delay an ACK when we&n;&t; * have any of those going out.&n;&t; */
op_star
id|ptr
op_increment
op_assign
id|htonl
c_func
(paren
(paren
id|TCPOPT_MSS
op_lshift
l_int|24
)paren
op_or
(paren
id|TCPOLEN_MSS
op_lshift
l_int|16
)paren
op_or
id|mss
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ts
)paren
(brace
r_if
c_cond
(paren
id|sack
)paren
(brace
op_star
id|ptr
op_increment
op_assign
id|__constant_htonl
c_func
(paren
(paren
id|TCPOPT_SACK_PERM
op_lshift
l_int|24
)paren
op_or
(paren
id|TCPOLEN_SACK_PERM
op_lshift
l_int|16
)paren
op_or
(paren
id|TCPOPT_TIMESTAMP
op_lshift
l_int|8
)paren
op_or
id|TCPOLEN_TIMESTAMP
)paren
suffix:semicolon
)brace
r_else
op_star
id|ptr
op_increment
op_assign
id|__constant_htonl
c_func
(paren
(paren
id|TCPOPT_NOP
op_lshift
l_int|24
)paren
op_or
(paren
id|TCPOPT_NOP
op_lshift
l_int|16
)paren
op_or
(paren
id|TCPOPT_TIMESTAMP
op_lshift
l_int|8
)paren
op_or
id|TCPOLEN_TIMESTAMP
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|htonl
c_func
(paren
id|tstamp
)paren
suffix:semicolon
multiline_comment|/* TSVAL */
op_star
id|ptr
op_increment
op_assign
id|htonl
c_func
(paren
id|ts_recent
)paren
suffix:semicolon
multiline_comment|/* TSECR */
)brace
r_else
r_if
c_cond
(paren
id|sack
)paren
(brace
op_star
id|ptr
op_increment
op_assign
id|__constant_htonl
c_func
(paren
(paren
id|TCPOPT_NOP
op_lshift
l_int|24
)paren
op_or
(paren
id|TCPOPT_NOP
op_lshift
l_int|16
)paren
op_or
(paren
id|TCPOPT_SACK_PERM
op_lshift
l_int|8
)paren
op_or
id|TCPOLEN_SACK_PERM
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offer_wscale
)paren
op_star
id|ptr
op_increment
op_assign
id|htonl
c_func
(paren
(paren
id|TCPOPT_NOP
op_lshift
l_int|24
)paren
op_or
(paren
id|TCPOPT_WINDOW
op_lshift
l_int|16
)paren
op_or
(paren
id|TCPOLEN_WINDOW
op_lshift
l_int|8
)paren
op_or
(paren
id|wscale
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Determine a window scaling and initial window to offer.&n; * Based on the assumption that the given amount of space&n; * will be offered. Store the results in the tp structure.&n; * NOTE: for smooth operation initial space offering should&n; * be a multiple of mss if possible. We assume here that mss &gt;= 1.&n; * This MUST be enforced by all callers.&n; */
DECL|function|tcp_select_initial_window
r_static
r_inline
r_void
id|tcp_select_initial_window
c_func
(paren
r_int
id|space
comma
id|__u32
id|mss
comma
id|__u32
op_star
id|rcv_wnd
comma
id|__u32
op_star
id|window_clamp
comma
r_int
id|wscale_ok
comma
id|__u8
op_star
id|rcv_wscale
)paren
(brace
multiline_comment|/* If no clamp set the clamp to the max possible scaled window */
r_if
c_cond
(paren
op_star
id|window_clamp
op_eq
l_int|0
)paren
(paren
op_star
id|window_clamp
)paren
op_assign
(paren
l_int|65535
op_lshift
l_int|14
)paren
suffix:semicolon
id|space
op_assign
id|min
c_func
(paren
op_star
id|window_clamp
comma
id|space
)paren
suffix:semicolon
multiline_comment|/* Quantize space offering to a multiple of mss if possible. */
r_if
c_cond
(paren
id|space
OG
id|mss
)paren
id|space
op_assign
(paren
id|space
op_div
id|mss
)paren
op_star
id|mss
suffix:semicolon
multiline_comment|/* NOTE: offering an initial window larger than 32767&n;&t; * will break some buggy TCP stacks. We try to be nice.&n;&t; * If we are not window scaling, then this truncates&n;&t; * our initial window offering to 32k. There should also&n;&t; * be a sysctl option to stop being nice.&n;&t; */
(paren
op_star
id|rcv_wnd
)paren
op_assign
id|min
c_func
(paren
id|space
comma
id|MAX_TCP_WINDOW
)paren
suffix:semicolon
(paren
op_star
id|rcv_wscale
)paren
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|wscale_ok
)paren
(brace
multiline_comment|/* See RFC1323 for an explanation of the limit to 14 */
r_while
c_loop
(paren
id|space
OG
l_int|65535
op_logical_and
(paren
op_star
id|rcv_wscale
)paren
OL
l_int|14
)paren
(brace
id|space
op_rshift_assign
l_int|1
suffix:semicolon
(paren
op_star
id|rcv_wscale
)paren
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|rcv_wscale
op_logical_and
id|sysctl_tcp_app_win
op_logical_and
id|space
op_ge
id|mss
op_logical_and
id|space
op_minus
id|max
c_func
(paren
(paren
id|space
op_rshift
id|sysctl_tcp_app_win
)paren
comma
id|mss
op_rshift
op_star
id|rcv_wscale
)paren
OL
l_int|65536
op_div
l_int|2
)paren
(paren
op_star
id|rcv_wscale
)paren
op_decrement
suffix:semicolon
)brace
multiline_comment|/* Set initial window to value enough for senders,&n;&t; * following RFC1414. Senders, not following this RFC,&n;&t; * will be satisfied with 2.&n;&t; */
r_if
c_cond
(paren
id|mss
OG
(paren
l_int|1
op_lshift
op_star
id|rcv_wscale
)paren
)paren
(brace
r_int
id|init_cwnd
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|mss
OG
l_int|1460
op_star
l_int|3
)paren
id|init_cwnd
op_assign
l_int|2
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mss
OG
l_int|1460
)paren
id|init_cwnd
op_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
op_star
id|rcv_wnd
OG
id|init_cwnd
op_star
id|mss
)paren
op_star
id|rcv_wnd
op_assign
id|init_cwnd
op_star
id|mss
suffix:semicolon
)brace
multiline_comment|/* Set the clamp no higher than max representable value */
(paren
op_star
id|window_clamp
)paren
op_assign
id|min
c_func
(paren
l_int|65535
op_lshift
(paren
op_star
id|rcv_wscale
)paren
comma
op_star
id|window_clamp
)paren
suffix:semicolon
)brace
DECL|function|tcp_win_from_space
r_static
r_inline
r_int
id|tcp_win_from_space
c_func
(paren
r_int
id|space
)paren
(brace
r_return
id|sysctl_tcp_adv_win_scale
op_le
l_int|0
ques
c_cond
(paren
id|space
op_rshift
(paren
op_minus
id|sysctl_tcp_adv_win_scale
)paren
)paren
suffix:colon
id|space
op_minus
(paren
id|space
op_rshift
id|sysctl_tcp_adv_win_scale
)paren
suffix:semicolon
)brace
multiline_comment|/* Note: caller must be prepared to deal with negative returns */
DECL|function|tcp_space
r_static
r_inline
r_int
id|tcp_space
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|tcp_win_from_space
c_func
(paren
id|sk-&gt;rcvbuf
op_minus
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
)paren
suffix:semicolon
)brace
DECL|function|tcp_full_space
r_static
r_inline
r_int
id|tcp_full_space
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|tcp_win_from_space
c_func
(paren
id|sk-&gt;rcvbuf
)paren
suffix:semicolon
)brace
DECL|function|tcp_acceptq_removed
r_static
r_inline
r_void
id|tcp_acceptq_removed
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sk-&gt;ack_backlog
op_decrement
suffix:semicolon
)brace
DECL|function|tcp_acceptq_added
r_static
r_inline
r_void
id|tcp_acceptq_added
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sk-&gt;ack_backlog
op_increment
suffix:semicolon
)brace
DECL|function|tcp_acceptq_is_full
r_static
r_inline
r_int
id|tcp_acceptq_is_full
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|sk-&gt;ack_backlog
OG
id|sk-&gt;max_ack_backlog
suffix:semicolon
)brace
DECL|function|tcp_acceptq_queue
r_static
r_inline
r_void
id|tcp_acceptq_queue
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|open_request
op_star
id|req
comma
r_struct
id|sock
op_star
id|child
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
id|req-&gt;sk
op_assign
id|child
suffix:semicolon
id|tcp_acceptq_added
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp-&gt;accept_queue_tail
)paren
(brace
id|tp-&gt;accept_queue
op_assign
id|req
suffix:semicolon
)brace
r_else
(brace
id|tp-&gt;accept_queue_tail-&gt;dl_next
op_assign
id|req
suffix:semicolon
)brace
id|tp-&gt;accept_queue_tail
op_assign
id|req
suffix:semicolon
id|req-&gt;dl_next
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|struct|tcp_listen_opt
r_struct
id|tcp_listen_opt
(brace
DECL|member|max_qlen_log
id|u8
id|max_qlen_log
suffix:semicolon
multiline_comment|/* log_2 of maximal queued SYNs */
DECL|member|qlen
r_int
id|qlen
suffix:semicolon
DECL|member|qlen_young
r_int
id|qlen_young
suffix:semicolon
DECL|member|clock_hand
r_int
id|clock_hand
suffix:semicolon
DECL|member|syn_table
r_struct
id|open_request
op_star
id|syn_table
(braket
id|TCP_SYNQ_HSIZE
)braket
suffix:semicolon
)brace
suffix:semicolon
r_static
r_inline
r_void
DECL|function|tcp_synq_removed
id|tcp_synq_removed
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|open_request
op_star
id|req
)paren
(brace
r_struct
id|tcp_listen_opt
op_star
id|lopt
op_assign
id|sk-&gt;tp_pinfo.af_tcp.listen_opt
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|lopt-&gt;qlen
op_eq
l_int|0
)paren
id|tcp_delete_keepalive_timer
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;retrans
op_eq
l_int|0
)paren
id|lopt-&gt;qlen_young
op_decrement
suffix:semicolon
)brace
DECL|function|tcp_synq_added
r_static
r_inline
r_void
id|tcp_synq_added
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_listen_opt
op_star
id|lopt
op_assign
id|sk-&gt;tp_pinfo.af_tcp.listen_opt
suffix:semicolon
r_if
c_cond
(paren
id|lopt-&gt;qlen
op_increment
op_eq
l_int|0
)paren
id|tcp_reset_keepalive_timer
c_func
(paren
id|sk
comma
id|TCP_TIMEOUT_INIT
)paren
suffix:semicolon
id|lopt-&gt;qlen_young
op_increment
suffix:semicolon
)brace
DECL|function|tcp_synq_len
r_static
r_inline
r_int
id|tcp_synq_len
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|sk-&gt;tp_pinfo.af_tcp.listen_opt-&gt;qlen
suffix:semicolon
)brace
DECL|function|tcp_synq_young
r_static
r_inline
r_int
id|tcp_synq_young
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|sk-&gt;tp_pinfo.af_tcp.listen_opt-&gt;qlen_young
suffix:semicolon
)brace
DECL|function|tcp_synq_is_full
r_static
r_inline
r_int
id|tcp_synq_is_full
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|tcp_synq_len
c_func
(paren
id|sk
)paren
op_rshift
id|sk-&gt;tp_pinfo.af_tcp.listen_opt-&gt;max_qlen_log
suffix:semicolon
)brace
DECL|function|tcp_synq_unlink
r_static
r_inline
r_void
id|tcp_synq_unlink
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
r_struct
id|open_request
op_star
id|req
comma
r_struct
id|open_request
op_star
op_star
id|prev
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|tp-&gt;syn_wait_lock
)paren
suffix:semicolon
op_star
id|prev
op_assign
id|req-&gt;dl_next
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|tp-&gt;syn_wait_lock
)paren
suffix:semicolon
)brace
DECL|function|tcp_synq_drop
r_static
r_inline
r_void
id|tcp_synq_drop
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|open_request
op_star
id|req
comma
r_struct
id|open_request
op_star
op_star
id|prev
)paren
(brace
id|tcp_synq_unlink
c_func
(paren
op_amp
id|sk-&gt;tp_pinfo.af_tcp
comma
id|req
comma
id|prev
)paren
suffix:semicolon
id|tcp_synq_removed
c_func
(paren
id|sk
comma
id|req
)paren
suffix:semicolon
id|tcp_openreq_free
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
DECL|function|tcp_openreq_init
r_static
id|__inline__
r_void
id|tcp_openreq_init
c_func
(paren
r_struct
id|open_request
op_star
id|req
comma
r_struct
id|tcp_opt
op_star
id|tp
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|req-&gt;rcv_wnd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* So that tcp_send_synack() knows! */
id|req-&gt;rcv_isn
op_assign
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|seq
suffix:semicolon
id|req-&gt;mss
op_assign
id|tp-&gt;mss_clamp
suffix:semicolon
id|req-&gt;ts_recent
op_assign
id|tp-&gt;saw_tstamp
ques
c_cond
id|tp-&gt;rcv_tsval
suffix:colon
l_int|0
suffix:semicolon
id|req-&gt;tstamp_ok
op_assign
id|tp-&gt;tstamp_ok
suffix:semicolon
id|req-&gt;sack_ok
op_assign
id|tp-&gt;sack_ok
suffix:semicolon
id|req-&gt;snd_wscale
op_assign
id|tp-&gt;snd_wscale
suffix:semicolon
id|req-&gt;wscale_ok
op_assign
id|tp-&gt;wscale_ok
suffix:semicolon
id|req-&gt;acked
op_assign
l_int|0
suffix:semicolon
id|req-&gt;ecn_ok
op_assign
l_int|0
suffix:semicolon
id|req-&gt;rmt_port
op_assign
id|skb-&gt;h.th-&gt;source
suffix:semicolon
)brace
DECL|macro|TCP_MEM_QUANTUM
mdefine_line|#define TCP_MEM_QUANTUM&t;((int)PAGE_SIZE)
DECL|function|tcp_free_skb
r_static
r_inline
r_void
id|tcp_free_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|sk-&gt;tp_pinfo.af_tcp.queue_shrunk
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;wmem_queued
op_sub_assign
id|skb-&gt;truesize
suffix:semicolon
id|sk-&gt;forward_alloc
op_add_assign
id|skb-&gt;truesize
suffix:semicolon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
DECL|function|tcp_charge_skb
r_static
r_inline
r_void
id|tcp_charge_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|sk-&gt;wmem_queued
op_add_assign
id|skb-&gt;truesize
suffix:semicolon
id|sk-&gt;forward_alloc
op_sub_assign
id|skb-&gt;truesize
suffix:semicolon
)brace
r_extern
r_void
id|__tcp_mem_reclaim
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_int
id|tcp_mem_schedule
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|size
comma
r_int
id|kind
)paren
suffix:semicolon
DECL|function|tcp_mem_reclaim
r_static
r_inline
r_void
id|tcp_mem_reclaim
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;forward_alloc
op_ge
id|TCP_MEM_QUANTUM
)paren
id|__tcp_mem_reclaim
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
DECL|function|tcp_enter_memory_pressure
r_static
r_inline
r_void
id|tcp_enter_memory_pressure
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tcp_memory_pressure
)paren
(brace
id|NET_INC_STATS
c_func
(paren
id|TCPMemoryPressures
)paren
suffix:semicolon
id|tcp_memory_pressure
op_assign
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|tcp_moderate_sndbuf
r_static
r_inline
r_void
id|tcp_moderate_sndbuf
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|sk-&gt;userlocks
op_amp
id|SOCK_SNDBUF_LOCK
)paren
)paren
(brace
id|sk-&gt;sndbuf
op_assign
id|min
c_func
(paren
id|sk-&gt;sndbuf
comma
id|sk-&gt;wmem_queued
op_div
l_int|2
)paren
suffix:semicolon
id|sk-&gt;sndbuf
op_assign
id|max
c_func
(paren
id|sk-&gt;sndbuf
comma
id|SOCK_MIN_SNDBUF
)paren
suffix:semicolon
)brace
)brace
DECL|function|tcp_alloc_skb
r_static
r_inline
r_struct
id|sk_buff
op_star
id|tcp_alloc_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|size
comma
r_int
id|gfp
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|size
comma
id|gfp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;forward_alloc
op_ge
(paren
r_int
)paren
id|skb-&gt;truesize
op_logical_or
id|tcp_mem_schedule
c_func
(paren
id|sk
comma
id|skb-&gt;truesize
comma
l_int|0
)paren
)paren
r_return
id|skb
suffix:semicolon
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
r_else
(brace
id|tcp_enter_memory_pressure
c_func
(paren
)paren
suffix:semicolon
id|tcp_moderate_sndbuf
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|tcp_writequeue_purge
r_static
r_inline
r_void
id|tcp_writequeue_purge
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
op_amp
id|sk-&gt;write_queue
)paren
)paren
op_ne
l_int|NULL
)paren
id|tcp_free_skb
c_func
(paren
id|sk
comma
id|skb
)paren
suffix:semicolon
id|tcp_mem_reclaim
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
r_extern
r_void
id|tcp_rfree
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
DECL|function|tcp_set_owner_r
r_static
r_inline
r_void
id|tcp_set_owner_r
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;destructor
op_assign
id|tcp_rfree
suffix:semicolon
id|atomic_add
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|sk-&gt;rmem_alloc
)paren
suffix:semicolon
id|sk-&gt;forward_alloc
op_sub_assign
id|skb-&gt;truesize
suffix:semicolon
)brace
r_extern
r_void
id|tcp_listen_wlock
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* - We may sleep inside this lock.&n; * - If sleeping is not required (or called from BH),&n; *   use plain read_(un)lock(&amp;tcp_lhash_lock).&n; */
DECL|function|tcp_listen_lock
r_static
r_inline
r_void
id|tcp_listen_lock
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* read_lock synchronizes to candidates to writers */
id|read_lock
c_func
(paren
op_amp
id|tcp_lhash_lock
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|tcp_lhash_users
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tcp_lhash_lock
)paren
suffix:semicolon
)brace
DECL|function|tcp_listen_unlock
r_static
r_inline
r_void
id|tcp_listen_unlock
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|tcp_lhash_users
)paren
)paren
id|wake_up
c_func
(paren
op_amp
id|tcp_lhash_wait
)paren
suffix:semicolon
)brace
DECL|function|keepalive_intvl_when
r_static
r_inline
r_int
id|keepalive_intvl_when
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_return
id|tp-&gt;keepalive_intvl
ques
c_cond
suffix:colon
id|sysctl_tcp_keepalive_intvl
suffix:semicolon
)brace
DECL|function|keepalive_time_when
r_static
r_inline
r_int
id|keepalive_time_when
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_return
id|tp-&gt;keepalive_time
ques
c_cond
suffix:colon
id|sysctl_tcp_keepalive_time
suffix:semicolon
)brace
DECL|function|tcp_fin_time
r_static
r_inline
r_int
id|tcp_fin_time
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_int
id|fin_timeout
op_assign
id|tp-&gt;linger2
ques
c_cond
suffix:colon
id|sysctl_tcp_fin_timeout
suffix:semicolon
r_if
c_cond
(paren
id|fin_timeout
OL
(paren
id|tp-&gt;rto
op_lshift
l_int|2
)paren
op_minus
(paren
id|tp-&gt;rto
op_rshift
l_int|1
)paren
)paren
id|fin_timeout
op_assign
(paren
id|tp-&gt;rto
op_lshift
l_int|2
)paren
op_minus
(paren
id|tp-&gt;rto
op_rshift
l_int|1
)paren
suffix:semicolon
r_return
id|fin_timeout
suffix:semicolon
)brace
DECL|function|tcp_paws_check
r_static
r_inline
r_int
id|tcp_paws_check
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
r_int
id|rst
)paren
(brace
r_if
c_cond
(paren
(paren
id|s32
)paren
(paren
id|tp-&gt;rcv_tsval
op_minus
id|tp-&gt;ts_recent
)paren
op_ge
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|xtime.tv_sec
op_ge
id|tp-&gt;ts_recent_stamp
op_plus
id|TCP_PAWS_24DAYS
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* RST segments are not recommended to carry timestamp,&n;&t;   and, if they do, it is recommended to ignore PAWS because&n;&t;   &quot;their cleanup function should take precedence over timestamps.&quot;&n;&t;   Certainly, it is mistake. It is necessary to understand the reasons&n;&t;   of this constraint to relax it: if peer reboots, clock may go&n;&t;   out-of-sync and half-open connections will not be reset.&n;&t;   Actually, the problem would be not existing if all&n;&t;   the implementations followed draft about maintaining clock&n;&t;   via reboots. Linux-2.2 DOES NOT!&n;&n;&t;   However, we can relax time bounds for RST segments to MSL.&n;&t; */
r_if
c_cond
(paren
id|rst
op_logical_and
id|xtime.tv_sec
op_ge
id|tp-&gt;ts_recent_stamp
op_plus
id|TCP_PAWS_MSL
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|macro|TCP_CHECK_TIMER
mdefine_line|#define TCP_CHECK_TIMER(sk) do { } while (0);
macro_line|#endif&t;/* _TCP_H */
eof
