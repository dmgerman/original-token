multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Definitions for the TCP module.&n; *&n; * Version:&t;@(#)tcp.h&t;1.0.5&t;05/23/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#ifndef _TCP_H
DECL|macro|_TCP_H
mdefine_line|#define _TCP_H
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/tcp.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;net/checksum.h&gt;
multiline_comment|/* This is for all connections with a full identity, no wildcards.&n; * New scheme, half the table is for TIME_WAIT, the other half is&n; * for the rest.  I&squot;ll experiment with dynamic table growth later.&n; */
DECL|macro|TCP_HTABLE_SIZE
mdefine_line|#define TCP_HTABLE_SIZE&t;&t;512
multiline_comment|/* This is for listening sockets, thus all sockets which possess wildcards. */
DECL|macro|TCP_LHTABLE_SIZE
mdefine_line|#define TCP_LHTABLE_SIZE&t;32&t;/* Yes, really, this is all you need. */
multiline_comment|/* This is for all sockets, to keep track of the local port allocations. */
DECL|macro|TCP_BHTABLE_SIZE
mdefine_line|#define TCP_BHTABLE_SIZE&t;512
multiline_comment|/* tcp_ipv4.c: These need to be shared by v4 and v6 because the lookup&n; *             and hashing code needs to work with different AF&squot;s yet&n; *             the port space is shared.&n; */
r_extern
r_struct
id|sock
op_star
id|tcp_established_hash
(braket
id|TCP_HTABLE_SIZE
)braket
suffix:semicolon
r_extern
r_struct
id|sock
op_star
id|tcp_listening_hash
(braket
id|TCP_LHTABLE_SIZE
)braket
suffix:semicolon
multiline_comment|/* There are a few simple rules, which allow for local port reuse by&n; * an application.  In essence:&n; *&n; *&t;1) Sockets bound to different interfaces may share a local port.&n; *&t;   Failing that, goto test 2.&n; *&t;2) If all sockets have sk-&gt;reuse set, and none of them are in&n; *&t;   TCP_LISTEN state, the port may be shared.&n; *&t;   Failing that, goto test 3.&n; *&t;3) If all sockets are bound to a specific sk-&gt;rcv_saddr local&n; *&t;   address, and none of them are the same, the port may be&n; *&t;   shared.&n; *&t;   Failing this, the port cannot be shared.&n; *&n; * The interesting point, is test #2.  This is what an FTP server does&n; * all day.  To optimize this case we use a specific flag bit defined&n; * below.  As we add sockets to a bind bucket list, we perform a&n; * check of: (newsk-&gt;reuse &amp;&amp; (newsk-&gt;state != TCP_LISTEN))&n; * As long as all sockets added to a bind bucket pass this test,&n; * the flag bit will be set.&n; * The resulting situation is that tcp_v[46]_verify_bind() can just check&n; * for this flag bit, if it is set and the socket trying to bind has&n; * sk-&gt;reuse set, we don&squot;t even have to walk the owners list at all,&n; * we return that it is ok to bind this socket to the requested local port.&n; *&n; * Sounds like a lot of work, but it is worth it.  In a more naive&n; * implementation (ie. current FreeBSD etc.) the entire list of ports&n; * must be walked for each data port opened by an ftp server.  Needless&n; * to say, this does not scale at all.  With a couple thousand FTP&n; * users logged onto your box, isn&squot;t it nice to know that new data&n; * ports are created in O(1) time?  I thought so. ;-)&t;-DaveM&n; */
DECL|struct|tcp_bind_bucket
r_struct
id|tcp_bind_bucket
(brace
DECL|member|port
r_int
r_int
id|port
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|macro|TCPB_FLAG_LOCKED
mdefine_line|#define TCPB_FLAG_LOCKED&t;0x0001
DECL|macro|TCPB_FLAG_FASTREUSE
mdefine_line|#define TCPB_FLAG_FASTREUSE&t;0x0002
DECL|member|next
r_struct
id|tcp_bind_bucket
op_star
id|next
suffix:semicolon
DECL|member|owners
r_struct
id|sock
op_star
id|owners
suffix:semicolon
DECL|member|pprev
r_struct
id|tcp_bind_bucket
op_star
op_star
id|pprev
suffix:semicolon
)brace
suffix:semicolon
r_extern
r_struct
id|tcp_bind_bucket
op_star
id|tcp_bound_hash
(braket
id|TCP_BHTABLE_SIZE
)braket
suffix:semicolon
r_extern
id|kmem_cache_t
op_star
id|tcp_bucket_cachep
suffix:semicolon
r_extern
r_struct
id|tcp_bind_bucket
op_star
id|tcp_bucket_create
c_func
(paren
r_int
r_int
id|snum
)paren
suffix:semicolon
r_extern
r_void
id|tcp_bucket_unlock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_int
id|tcp_port_rover
suffix:semicolon
multiline_comment|/* Level-1 socket-demux cache. */
DECL|macro|TCP_NUM_REGS
mdefine_line|#define TCP_NUM_REGS&t;&t;32
r_extern
r_struct
id|sock
op_star
id|tcp_regs
(braket
id|TCP_NUM_REGS
)braket
suffix:semicolon
DECL|macro|TCP_RHASH_FN
mdefine_line|#define TCP_RHASH_FN(__fport) &bslash;&n;&t;((((__fport) &gt;&gt; 7) ^ (__fport)) &amp; (TCP_NUM_REGS - 1))
DECL|macro|TCP_RHASH
mdefine_line|#define TCP_RHASH(__fport)&t;tcp_regs[TCP_RHASH_FN((__fport))]
DECL|macro|TCP_SK_RHASH_FN
mdefine_line|#define TCP_SK_RHASH_FN(__sock)&t;TCP_RHASH_FN((__sock)-&gt;dport)
DECL|macro|TCP_SK_RHASH
mdefine_line|#define TCP_SK_RHASH(__sock)&t;tcp_regs[TCP_SK_RHASH_FN((__sock))]
DECL|function|tcp_reg_zap
r_static
id|__inline__
r_void
id|tcp_reg_zap
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|sock
op_star
op_star
id|rpp
suffix:semicolon
id|rpp
op_assign
op_amp
(paren
id|TCP_SK_RHASH
c_func
(paren
id|sk
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|rpp
op_eq
id|sk
)paren
(brace
op_star
id|rpp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* These are AF independent. */
DECL|function|tcp_bhashfn
r_static
id|__inline__
r_int
id|tcp_bhashfn
c_func
(paren
id|__u16
id|lport
)paren
(brace
r_return
(paren
id|lport
op_amp
(paren
id|TCP_BHTABLE_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
DECL|function|tcp_sk_bindify
r_static
id|__inline__
r_void
id|tcp_sk_bindify
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_bind_bucket
op_star
id|tb
suffix:semicolon
r_int
r_int
id|snum
op_assign
id|sk-&gt;num
suffix:semicolon
r_for
c_loop
(paren
id|tb
op_assign
id|tcp_bound_hash
(braket
id|tcp_bhashfn
c_func
(paren
id|snum
)paren
)braket
suffix:semicolon
id|tb-&gt;port
op_ne
id|snum
suffix:semicolon
id|tb
op_assign
id|tb-&gt;next
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Update bucket flags. */
r_if
c_cond
(paren
id|tb-&gt;owners
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* We&squot;re the first. */
r_if
c_cond
(paren
id|sk-&gt;reuse
op_logical_and
id|sk-&gt;state
op_ne
id|TCP_LISTEN
)paren
(brace
id|tb-&gt;flags
op_assign
id|TCPB_FLAG_FASTREUSE
suffix:semicolon
)brace
r_else
id|tb-&gt;flags
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|tb-&gt;flags
op_amp
id|TCPB_FLAG_FASTREUSE
)paren
op_logical_and
(paren
(paren
id|sk-&gt;reuse
op_eq
l_int|0
)paren
op_logical_or
(paren
id|sk-&gt;state
op_eq
id|TCP_LISTEN
)paren
)paren
)paren
(brace
id|tb-&gt;flags
op_and_assign
op_complement
id|TCPB_FLAG_FASTREUSE
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|sk-&gt;bind_next
op_assign
id|tb-&gt;owners
)paren
op_ne
l_int|NULL
)paren
(brace
id|tb-&gt;owners-&gt;bind_pprev
op_assign
op_amp
id|sk-&gt;bind_next
suffix:semicolon
)brace
id|tb-&gt;owners
op_assign
id|sk
suffix:semicolon
id|sk-&gt;bind_pprev
op_assign
op_amp
id|tb-&gt;owners
suffix:semicolon
id|sk-&gt;prev
op_assign
(paren
r_struct
id|sock
op_star
)paren
id|tb
suffix:semicolon
)brace
multiline_comment|/* This is a TIME_WAIT bucket.  It works around the memory consumption&n; * problems of sockets in such a state on heavily loaded servers, but&n; * without violating the protocol specification.&n; */
DECL|struct|tcp_tw_bucket
r_struct
id|tcp_tw_bucket
(brace
multiline_comment|/* These _must_ match the beginning of struct sock precisely.&n;&t; * XXX Yes I know this is gross, but I&squot;d have to edit every single&n;&t; * XXX networking file if I created a &quot;struct sock_header&quot;. -DaveM&n;&t; */
DECL|member|sklist_next
r_struct
id|sock
op_star
id|sklist_next
suffix:semicolon
DECL|member|sklist_prev
r_struct
id|sock
op_star
id|sklist_prev
suffix:semicolon
DECL|member|bind_next
r_struct
id|sock
op_star
id|bind_next
suffix:semicolon
DECL|member|bind_pprev
r_struct
id|sock
op_star
op_star
id|bind_pprev
suffix:semicolon
DECL|member|next
r_struct
id|sock
op_star
id|next
suffix:semicolon
DECL|member|pprev
r_struct
id|sock
op_star
op_star
id|pprev
suffix:semicolon
DECL|member|daddr
id|__u32
id|daddr
suffix:semicolon
DECL|member|rcv_saddr
id|__u32
id|rcv_saddr
suffix:semicolon
DECL|member|bound_dev_if
r_int
id|bound_dev_if
suffix:semicolon
DECL|member|num
r_int
r_int
id|num
suffix:semicolon
DECL|member|state
r_int
r_char
id|state
comma
DECL|member|zapped
id|zapped
suffix:semicolon
DECL|member|sport
id|__u16
id|sport
suffix:semicolon
DECL|member|dport
id|__u16
id|dport
suffix:semicolon
DECL|member|family
r_int
r_int
id|family
suffix:semicolon
DECL|member|reuse
r_int
r_char
id|reuse
comma
DECL|member|nonagle
id|nonagle
suffix:semicolon
multiline_comment|/* And these are ours. */
DECL|member|rcv_nxt
id|__u32
id|rcv_nxt
suffix:semicolon
DECL|member|af_specific
r_struct
id|tcp_func
op_star
id|af_specific
suffix:semicolon
DECL|member|tb
r_struct
id|tcp_bind_bucket
op_star
id|tb
suffix:semicolon
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
macro_line|#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
DECL|member|v6_daddr
r_struct
id|in6_addr
id|v6_daddr
suffix:semicolon
DECL|member|v6_rcv_saddr
r_struct
id|in6_addr
id|v6_rcv_saddr
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
r_extern
id|kmem_cache_t
op_star
id|tcp_timewait_cachep
suffix:semicolon
multiline_comment|/* tcp_ipv4.c: These sysctl variables need to be shared between v4 and v6&n; * because the v6 tcp code to intialize a connection needs to interoperate&n; * with the v4 code using the same variables.&n; * FIXME: It would be better to rewrite the connection code to be&n; * address family independent and just leave one copy in the ipv4 section.&n; * This would also clean up some code duplication. -- erics&n; */
r_extern
r_int
id|sysctl_tcp_timestamps
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_window_scaling
suffix:semicolon
r_extern
r_int
id|sysctl_tcp_sack
suffix:semicolon
multiline_comment|/* These can have wildcards, don&squot;t try too hard. */
DECL|function|tcp_lhashfn
r_static
id|__inline__
r_int
id|tcp_lhashfn
c_func
(paren
r_int
r_int
id|num
)paren
(brace
r_return
id|num
op_amp
(paren
id|TCP_LHTABLE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|tcp_sk_listen_hashfn
r_static
id|__inline__
r_int
id|tcp_sk_listen_hashfn
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|tcp_lhashfn
c_func
(paren
id|sk-&gt;num
)paren
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
DECL|macro|NETHDR_SIZE
mdefine_line|#define NETHDR_SIZE&t;sizeof(struct ipv6hdr)
macro_line|#else
DECL|macro|NETHDR_SIZE
mdefine_line|#define NETHDR_SIZE&t;sizeof(struct iphdr) + 40
macro_line|#endif
multiline_comment|/*&n; * 40 is maximal IP options size&n; * 20 is the maximum TCP options size we can currently construct on a SYN.&n; * 40 is the maximum possible TCP options size.&n; */
DECL|macro|MAX_SYN_SIZE
mdefine_line|#define MAX_SYN_SIZE&t;(NETHDR_SIZE + sizeof(struct tcphdr) + 20 + MAX_HEADER + 15)
DECL|macro|MAX_FIN_SIZE
mdefine_line|#define MAX_FIN_SIZE&t;(NETHDR_SIZE + sizeof(struct tcphdr) + MAX_HEADER + 15)
DECL|macro|BASE_ACK_SIZE
mdefine_line|#define BASE_ACK_SIZE&t;(NETHDR_SIZE + MAX_HEADER + 15)
DECL|macro|MAX_ACK_SIZE
mdefine_line|#define MAX_ACK_SIZE&t;(NETHDR_SIZE + sizeof(struct tcphdr) + MAX_HEADER + 15)
DECL|macro|MAX_RESET_SIZE
mdefine_line|#define MAX_RESET_SIZE&t;(NETHDR_SIZE + sizeof(struct tcphdr) + MAX_HEADER + 15)
DECL|macro|MAX_TCPHEADER_SIZE
mdefine_line|#define MAX_TCPHEADER_SIZE (NETHDR_SIZE + sizeof(struct tcphdr) + 20 + MAX_HEADER + 15)
DECL|macro|MAX_WINDOW
mdefine_line|#define MAX_WINDOW&t;32767&t;&t;/* Never offer a window over 32767 without using&n;&t;&t;&t;&t;&t;   window scaling (not yet supported). Some poor&n;&t;&t;&t;&t;&t;   stacks do signed 16bit maths! */
DECL|macro|MIN_WINDOW
mdefine_line|#define MIN_WINDOW&t;2048
DECL|macro|MAX_ACK_BACKLOG
mdefine_line|#define MAX_ACK_BACKLOG&t;2
DECL|macro|MAX_DELAY_ACK
mdefine_line|#define MAX_DELAY_ACK&t;2
DECL|macro|MIN_WRITE_SPACE
mdefine_line|#define MIN_WRITE_SPACE&t;2048
DECL|macro|TCP_WINDOW_DIFF
mdefine_line|#define TCP_WINDOW_DIFF&t;2048
multiline_comment|/* urg_data states */
DECL|macro|URG_VALID
mdefine_line|#define URG_VALID&t;0x0100
DECL|macro|URG_NOTYET
mdefine_line|#define URG_NOTYET&t;0x0200
DECL|macro|URG_READ
mdefine_line|#define URG_READ&t;0x0400
DECL|macro|TCP_RETR1
mdefine_line|#define TCP_RETR1&t;7&t;/*&n;&t;&t;&t;&t; * This is how many retries it does before it&n;&t;&t;&t;&t; * tries to figure out if the gateway is&n;&t;&t;&t;&t; * down.&n;&t;&t;&t;&t; */
DECL|macro|TCP_RETR2
mdefine_line|#define TCP_RETR2&t;15&t;/*&n;&t;&t;&t;&t; * This should take at least&n;&t;&t;&t;&t; * 90 minutes to time out.&n;&t;&t;&t;&t; */
DECL|macro|TCP_TIMEOUT_LEN
mdefine_line|#define TCP_TIMEOUT_LEN&t;(15*60*HZ) /* should be about 15 mins&t;&t;*/
DECL|macro|TCP_TIMEWAIT_LEN
mdefine_line|#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to successfully &n;&t;&t;&t;&t;  * close the socket, about 60 seconds&t;*/
DECL|macro|TCP_FIN_TIMEOUT
mdefine_line|#define TCP_FIN_TIMEOUT (3*60*HZ) /* BSD style FIN_WAIT2 deadlock breaker */
DECL|macro|TCP_ACK_TIME
mdefine_line|#define TCP_ACK_TIME&t;(3*HZ)&t;/* time to delay before sending an ACK&t;*/
DECL|macro|TCP_DONE_TIME
mdefine_line|#define TCP_DONE_TIME&t;(5*HZ/2)/* maximum time to wait before actually&n;&t;&t;&t;&t; * destroying a socket&t;&t;&t;*/
DECL|macro|TCP_WRITE_TIME
mdefine_line|#define TCP_WRITE_TIME&t;(30*HZ)&t;/* initial time to wait for an ACK,&n;&t;&t;&t;         * after last transmit&t;&t;&t;*/
DECL|macro|TCP_TIMEOUT_INIT
mdefine_line|#define TCP_TIMEOUT_INIT (3*HZ)&t;/* RFC 1122 initial timeout value&t;*/
DECL|macro|TCP_SYN_RETRIES
mdefine_line|#define TCP_SYN_RETRIES&t; 10&t;/* number of times to retry opening a&n;&t;&t;&t;&t; * connection &t;(TCP_RETR2-....)&t;*/
DECL|macro|TCP_PROBEWAIT_LEN
mdefine_line|#define TCP_PROBEWAIT_LEN (1*HZ)/* time to wait between probes when&n;&t;&t;&t;&t; * I&squot;ve got something to write and&n;&t;&t;&t;&t; * there is no window&t;&t;&t;*/
DECL|macro|TCP_KEEPALIVE_TIME
mdefine_line|#define TCP_KEEPALIVE_TIME (180*60*HZ)&t;&t;/* two hours */
DECL|macro|TCP_KEEPALIVE_PROBES
mdefine_line|#define TCP_KEEPALIVE_PROBES&t;9&t;&t;/* Max of 9 keepalive probes&t;*/
DECL|macro|TCP_KEEPALIVE_PERIOD
mdefine_line|#define TCP_KEEPALIVE_PERIOD ((75*HZ)&gt;&gt;2)&t;/* period of keepalive check&t;*/
DECL|macro|TCP_SYNACK_PERIOD
mdefine_line|#define TCP_SYNACK_PERIOD&t;(HZ/2)
DECL|macro|TCP_QUICK_TRIES
mdefine_line|#define TCP_QUICK_TRIES&t;&t;8  /* How often we try to retransmit, until&n;&t;&t;&t;&t;    * we tell the LL layer that it is something&n;&t;&t;&t;&t;    * wrong (e.g. that it can expire redirects) */
DECL|macro|TCP_BUCKETGC_PERIOD
mdefine_line|#define TCP_BUCKETGC_PERIOD&t;(HZ)
multiline_comment|/*&n; *&t;TCP option&n; */
DECL|macro|TCPOPT_NOP
mdefine_line|#define TCPOPT_NOP&t;&t;1&t;/* Padding */
DECL|macro|TCPOPT_EOL
mdefine_line|#define TCPOPT_EOL&t;&t;0&t;/* End of options */
DECL|macro|TCPOPT_MSS
mdefine_line|#define TCPOPT_MSS&t;&t;2&t;/* Segment size negotiating */
DECL|macro|TCPOPT_WINDOW
mdefine_line|#define TCPOPT_WINDOW&t;&t;3&t;/* Window scaling */
DECL|macro|TCPOPT_SACK_PERM
mdefine_line|#define TCPOPT_SACK_PERM        4       /* SACK Permitted */
DECL|macro|TCPOPT_SACK
mdefine_line|#define TCPOPT_SACK             5       /* SACK Block */
DECL|macro|TCPOPT_TIMESTAMP
mdefine_line|#define TCPOPT_TIMESTAMP&t;8&t;/* Better RTT estimations/PAWS */
multiline_comment|/*&n; *     TCP option lengths&n; */
DECL|macro|TCPOLEN_MSS
mdefine_line|#define TCPOLEN_MSS            4
DECL|macro|TCPOLEN_WINDOW
mdefine_line|#define TCPOLEN_WINDOW         3
DECL|macro|TCPOLEN_SACK_PERM
mdefine_line|#define TCPOLEN_SACK_PERM      2
DECL|macro|TCPOLEN_TIMESTAMP
mdefine_line|#define TCPOLEN_TIMESTAMP      10
multiline_comment|/* But this is what stacks really send out. */
DECL|macro|TCPOLEN_TSTAMP_ALIGNED
mdefine_line|#define TCPOLEN_TSTAMP_ALIGNED&t;&t;12
DECL|macro|TCPOLEN_WSCALE_ALIGNED
mdefine_line|#define TCPOLEN_WSCALE_ALIGNED&t;&t;4
DECL|macro|TCPOLEN_SACKPERM_ALIGNED
mdefine_line|#define TCPOLEN_SACKPERM_ALIGNED&t;4
DECL|macro|TCPOLEN_SACK_BASE
mdefine_line|#define TCPOLEN_SACK_BASE&t;&t;2
DECL|macro|TCPOLEN_SACK_BASE_ALIGNED
mdefine_line|#define TCPOLEN_SACK_BASE_ALIGNED&t;4
DECL|macro|TCPOLEN_SACK_PERBLOCK
mdefine_line|#define TCPOLEN_SACK_PERBLOCK&t;&t;8
multiline_comment|/*&n; *&t;TCP Vegas constants&n; */
DECL|macro|TCP_VEGAS_ALPHA
mdefine_line|#define TCP_VEGAS_ALPHA&t;&t;2&t;/*  v_cong_detect_top_nseg */
DECL|macro|TCP_VEGAS_BETA
mdefine_line|#define TCP_VEGAS_BETA&t;&t;4&t;/*  v_cong_detect_bot_nseg */
DECL|macro|TCP_VEGAS_GAMMA
mdefine_line|#define TCP_VEGAS_GAMMA&t;&t;1&t;/*  v_exp_inc_nseg&t;   */
r_struct
id|open_request
suffix:semicolon
DECL|struct|or_calltable
r_struct
id|or_calltable
(brace
DECL|member|rtx_syn_ack
r_void
(paren
op_star
id|rtx_syn_ack
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|open_request
op_star
id|req
)paren
suffix:semicolon
DECL|member|destructor
r_void
(paren
op_star
id|destructor
)paren
(paren
r_struct
id|open_request
op_star
id|req
)paren
suffix:semicolon
DECL|member|send_reset
r_void
(paren
op_star
id|send_reset
)paren
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|tcp_v4_open_req
r_struct
id|tcp_v4_open_req
(brace
DECL|member|loc_addr
id|__u32
id|loc_addr
suffix:semicolon
DECL|member|rmt_addr
id|__u32
id|rmt_addr
suffix:semicolon
DECL|member|opt
r_struct
id|ip_options
op_star
id|opt
suffix:semicolon
)brace
suffix:semicolon
macro_line|#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
DECL|struct|tcp_v6_open_req
r_struct
id|tcp_v6_open_req
(brace
DECL|member|loc_addr
r_struct
id|in6_addr
id|loc_addr
suffix:semicolon
DECL|member|rmt_addr
r_struct
id|in6_addr
id|rmt_addr
suffix:semicolon
DECL|member|opt
r_struct
id|ipv6_options
op_star
id|opt
suffix:semicolon
DECL|member|iif
r_int
id|iif
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/* this structure is too big */
DECL|struct|open_request
r_struct
id|open_request
(brace
DECL|member|dl_next
r_struct
id|open_request
op_star
id|dl_next
suffix:semicolon
multiline_comment|/* Must be first member! */
DECL|member|rcv_isn
id|__u32
id|rcv_isn
suffix:semicolon
DECL|member|snt_isn
id|__u32
id|snt_isn
suffix:semicolon
DECL|member|rmt_port
id|__u16
id|rmt_port
suffix:semicolon
DECL|member|mss
id|__u16
id|mss
suffix:semicolon
DECL|member|retrans
id|__u8
id|retrans
suffix:semicolon
DECL|member|__pad
id|__u8
id|__pad
suffix:semicolon
DECL|member|snd_wscale
r_int
id|snd_wscale
suffix:colon
l_int|4
comma
DECL|member|rcv_wscale
id|rcv_wscale
suffix:colon
l_int|4
comma
DECL|member|tstamp_ok
id|tstamp_ok
suffix:colon
l_int|1
comma
DECL|member|sack_ok
id|sack_ok
suffix:colon
l_int|1
comma
DECL|member|wscale_ok
id|wscale_ok
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* The following two fields can be easily recomputed I think -AK */
DECL|member|window_clamp
id|__u32
id|window_clamp
suffix:semicolon
multiline_comment|/* window clamp at creation time */
DECL|member|rcv_wnd
id|__u32
id|rcv_wnd
suffix:semicolon
multiline_comment|/* rcv_wnd offered first time */
DECL|member|ts_recent
id|__u32
id|ts_recent
suffix:semicolon
DECL|member|expires
r_int
r_int
id|expires
suffix:semicolon
DECL|member|class
r_struct
id|or_calltable
op_star
r_class
suffix:semicolon
DECL|member|sk
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_union
(brace
DECL|member|v4_req
r_struct
id|tcp_v4_open_req
id|v4_req
suffix:semicolon
macro_line|#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
DECL|member|v6_req
r_struct
id|tcp_v6_open_req
id|v6_req
suffix:semicolon
macro_line|#endif
DECL|member|af
)brace
id|af
suffix:semicolon
macro_line|#ifdef CONFIG_IP_TRANSPARENT_PROXY
DECL|member|lcl_port
id|__u16
id|lcl_port
suffix:semicolon
multiline_comment|/* LVE */
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* SLAB cache for open requests. */
r_extern
id|kmem_cache_t
op_star
id|tcp_openreq_cachep
suffix:semicolon
DECL|macro|tcp_openreq_alloc
mdefine_line|#define tcp_openreq_alloc()&t;kmem_cache_alloc(tcp_openreq_cachep, SLAB_ATOMIC)
DECL|macro|tcp_openreq_free
mdefine_line|#define tcp_openreq_free(req)&t;kmem_cache_free(tcp_openreq_cachep, req)
multiline_comment|/*&n; *&t;Pointers to address related TCP functions&n; *&t;(i.e. things that depend on the address family)&n; */
DECL|struct|tcp_func
r_struct
id|tcp_func
(brace
DECL|member|queue_xmit
r_void
(paren
op_star
id|queue_xmit
)paren
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
DECL|member|send_check
r_void
(paren
op_star
id|send_check
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
DECL|member|rebuild_header
r_int
(paren
op_star
id|rebuild_header
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|conn_request
r_int
(paren
op_star
id|conn_request
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_void
op_star
id|opt
comma
id|__u32
id|isn
)paren
suffix:semicolon
DECL|member|syn_recv_sock
r_struct
id|sock
op_star
(paren
op_star
id|syn_recv_sock
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|open_request
op_star
id|req
comma
r_struct
id|dst_entry
op_star
id|dst
)paren
suffix:semicolon
DECL|member|get_sock
r_struct
id|sock
op_star
(paren
op_star
id|get_sock
)paren
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcphdr
op_star
id|th
)paren
suffix:semicolon
DECL|member|setsockopt
r_int
(paren
op_star
id|setsockopt
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
suffix:semicolon
DECL|member|getsockopt
r_int
(paren
op_star
id|getsockopt
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
suffix:semicolon
DECL|member|addr2sockaddr
r_void
(paren
op_star
id|addr2sockaddr
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
)paren
suffix:semicolon
DECL|member|sockaddr_len
r_int
id|sockaddr_len
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * The next routines deal with comparing 32 bit unsigned ints&n; * and worry about wraparound (automatic with unsigned arithmetic).&n; */
DECL|function|before
r_extern
id|__inline
r_int
id|before
c_func
(paren
id|__u32
id|seq1
comma
id|__u32
id|seq2
)paren
(brace
r_return
(paren
id|__s32
)paren
(paren
id|seq1
op_minus
id|seq2
)paren
OL
l_int|0
suffix:semicolon
)brace
DECL|function|after
r_extern
id|__inline
r_int
id|after
c_func
(paren
id|__u32
id|seq1
comma
id|__u32
id|seq2
)paren
(brace
r_return
(paren
id|__s32
)paren
(paren
id|seq2
op_minus
id|seq1
)paren
OL
l_int|0
suffix:semicolon
)brace
multiline_comment|/* is s2&lt;=s1&lt;=s3 ? */
DECL|function|between
r_extern
id|__inline
r_int
id|between
c_func
(paren
id|__u32
id|seq1
comma
id|__u32
id|seq2
comma
id|__u32
id|seq3
)paren
(brace
r_return
id|seq3
op_minus
id|seq2
op_ge
id|seq1
op_minus
id|seq2
suffix:semicolon
)brace
r_extern
r_struct
id|proto
id|tcp_prot
suffix:semicolon
r_extern
r_struct
id|tcp_mib
id|tcp_statistics
suffix:semicolon
r_extern
r_int
r_int
id|tcp_good_socknum
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|tcp_v4_err
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|tcp_shutdown
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|how
)paren
suffix:semicolon
r_extern
r_int
id|tcp_v4_rcv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
suffix:semicolon
r_extern
r_int
id|tcp_do_sendmsg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|iovlen
comma
r_struct
id|iovec
op_star
id|iov
comma
r_int
id|flags
)paren
suffix:semicolon
r_extern
r_int
id|tcp_ioctl
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_extern
r_int
id|tcp_rcv_state_process
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_void
op_star
id|opt
comma
id|__u16
id|len
)paren
suffix:semicolon
r_extern
r_int
id|tcp_rcv_established
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcphdr
op_star
id|th
comma
id|__u16
id|len
)paren
suffix:semicolon
r_extern
r_int
id|tcp_timewait_state_process
c_func
(paren
r_struct
id|tcp_tw_bucket
op_star
id|tw
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_void
op_star
id|opt
comma
id|__u16
id|len
)paren
suffix:semicolon
r_extern
r_void
id|tcp_close
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|timeout
)paren
suffix:semicolon
r_extern
r_struct
id|sock
op_star
id|tcp_accept
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
)paren
suffix:semicolon
r_extern
r_int
r_int
id|tcp_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
suffix:semicolon
r_extern
r_int
id|tcp_getsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
suffix:semicolon
r_extern
r_int
id|tcp_setsockopt
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
suffix:semicolon
r_extern
r_void
id|tcp_set_keepalive
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|val
)paren
suffix:semicolon
r_extern
r_int
id|tcp_recvmsg
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
comma
r_int
id|nonblock
comma
r_int
id|flags
comma
r_int
op_star
id|addr_len
)paren
suffix:semicolon
r_extern
r_void
id|tcp_parse_options
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_struct
id|tcp_opt
op_star
id|tp
comma
r_int
id|no_fancy
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;TCP v4 functions exported for the inet6 API&n; */
r_extern
r_int
id|tcp_v4_rebuild_header
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_int
id|tcp_v4_build_header
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_void
id|tcp_v4_send_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_int
id|tcp_v4_conn_request
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_void
op_star
id|ptr
comma
id|__u32
id|isn
)paren
suffix:semicolon
r_extern
r_struct
id|sock
op_star
id|tcp_create_openreq_child
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|open_request
op_star
id|req
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|mss
)paren
suffix:semicolon
r_extern
r_struct
id|sock
op_star
id|tcp_v4_syn_recv_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|open_request
op_star
id|req
comma
r_struct
id|dst_entry
op_star
id|dst
)paren
suffix:semicolon
r_extern
r_int
id|tcp_v4_do_rcv
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_int
id|tcp_v4_connect
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
)paren
suffix:semicolon
r_extern
r_void
id|tcp_connect
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|est_mss
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|tcp_make_synack
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|dst_entry
op_star
id|dst
comma
r_struct
id|open_request
op_star
id|req
comma
r_int
id|mss
)paren
suffix:semicolon
multiline_comment|/* From syncookies.c */
r_extern
r_struct
id|sock
op_star
id|cookie_v4_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|ip_options
op_star
id|opt
)paren
suffix:semicolon
r_extern
id|__u32
id|cookie_v4_init_sequence
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
id|__u16
op_star
id|mss
)paren
suffix:semicolon
r_extern
r_void
id|tcp_read_wakeup
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_write_xmit
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_time_wait
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_int
id|tcp_retransmit_skb
c_func
(paren
r_struct
id|sock
op_star
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_fack_retransmit
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_xmit_retransmit_queue
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_simple_retransmit
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
multiline_comment|/* tcp_output.c */
r_extern
r_void
id|tcp_send_probe0
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_send_partial
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_write_wakeup
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_send_fin
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_void
id|tcp_send_active_reset
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_int
id|tcp_send_synack
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_transmit_skb
c_func
(paren
r_struct
id|sock
op_star
comma
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_send_skb
c_func
(paren
r_struct
id|sock
op_star
comma
r_struct
id|sk_buff
op_star
comma
r_int
id|force_queue
)paren
suffix:semicolon
r_extern
r_void
id|tcp_send_ack
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_void
id|tcp_send_delayed_ack
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
r_int
id|max_timeout
)paren
suffix:semicolon
multiline_comment|/* CONFIG_IP_TRANSPARENT_PROXY */
r_extern
r_int
id|tcp_chkaddr
c_func
(paren
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
multiline_comment|/* tcp_timer.c */
DECL|macro|tcp_reset_msl_timer
mdefine_line|#define     tcp_reset_msl_timer(x,y,z)&t;net_reset_timer(x,y,z)
r_extern
r_void
id|tcp_reset_xmit_timer
c_func
(paren
r_struct
id|sock
op_star
comma
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
id|tcp_init_xmit_timers
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_clear_xmit_timers
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
r_extern
r_void
id|tcp_retransmit_timer
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
id|tcp_delack_timer
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
id|tcp_probe_timer
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_extern
r_struct
id|sock
op_star
id|tcp_check_req
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|open_request
op_star
id|req
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;TCP slow timer&n; */
r_extern
r_struct
id|timer_list
id|tcp_slow_timer
suffix:semicolon
DECL|struct|tcp_sl_timer
r_struct
id|tcp_sl_timer
(brace
DECL|member|count
id|atomic_t
id|count
suffix:semicolon
DECL|member|period
r_int
r_int
id|period
suffix:semicolon
DECL|member|last
r_int
r_int
id|last
suffix:semicolon
DECL|member|handler
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
r_int
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|TCP_SLT_SYNACK
mdefine_line|#define TCP_SLT_SYNACK&t;&t;0
DECL|macro|TCP_SLT_KEEPALIVE
mdefine_line|#define TCP_SLT_KEEPALIVE&t;1
DECL|macro|TCP_SLT_BUCKETGC
mdefine_line|#define TCP_SLT_BUCKETGC&t;2
DECL|macro|TCP_SLT_MAX
mdefine_line|#define TCP_SLT_MAX&t;&t;3
r_extern
r_struct
id|tcp_sl_timer
id|tcp_slt_array
(braket
id|TCP_SLT_MAX
)braket
suffix:semicolon
multiline_comment|/* Compute the actual receive window we are currently advertising. */
DECL|function|tcp_receive_window
r_static
id|__inline__
id|u32
id|tcp_receive_window
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_return
id|tp-&gt;rcv_wup
op_minus
(paren
id|tp-&gt;rcv_nxt
op_minus
id|tp-&gt;rcv_wnd
)paren
suffix:semicolon
)brace
multiline_comment|/* Choose a new window, without checks for shrinking, and without&n; * scaling applied to the result.  The caller does these things&n; * if necessary.  This is a &quot;raw&quot; window selection.&n; */
r_extern
id|u32
id|__tcp_select_window
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
multiline_comment|/* Chose a new window to advertise, update state in tcp_opt for the&n; * socket, and return result with RFC1323 scaling applied.  The return&n; * value can be stuffed directly into th-&gt;window for an outgoing&n; * frame.&n; */
DECL|function|tcp_select_window
r_extern
id|__inline__
id|u16
id|tcp_select_window
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|u32
id|new_win
op_assign
id|__tcp_select_window
c_func
(paren
id|sk
)paren
suffix:semicolon
id|u32
id|cur_win
op_assign
id|tcp_receive_window
c_func
(paren
id|tp
)paren
suffix:semicolon
multiline_comment|/* Never shrink the offered window */
r_if
c_cond
(paren
id|new_win
OL
id|cur_win
)paren
(brace
id|new_win
op_assign
id|cur_win
suffix:semicolon
)brace
id|tp-&gt;rcv_wnd
op_assign
id|new_win
suffix:semicolon
id|tp-&gt;rcv_wup
op_assign
id|tp-&gt;rcv_nxt
suffix:semicolon
multiline_comment|/* RFC1323 scaling applied */
r_return
id|new_win
op_rshift
id|tp-&gt;rcv_wscale
suffix:semicolon
)brace
multiline_comment|/* See if we can advertise non-zero, and if so how much we&n; * can increase our advertisement.  If it becomes more than&n; * twice what we are talking about right now, return true.&n; */
DECL|function|tcp_raise_window
r_extern
id|__inline__
r_int
id|tcp_raise_window
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
id|u32
id|new_win
op_assign
id|__tcp_select_window
c_func
(paren
id|sk
)paren
suffix:semicolon
id|u32
id|cur_win
op_assign
id|tcp_receive_window
c_func
(paren
id|tp
)paren
suffix:semicolon
r_return
(paren
id|new_win
op_logical_and
(paren
id|new_win
OG
(paren
id|cur_win
op_lshift
l_int|1
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This is what the send packet queueing engine uses to pass&n; * TCP per-packet control information to the transmission&n; * code.  We also store the host-order sequence numbers in&n; * here too.  This is 36 bytes on 32-bit architectures,&n; * 40 bytes on 64-bit machines, if this grows please adjust&n; * skbuff.h:skbuff-&gt;cb[xxx] size appropriately.&n; */
DECL|struct|tcp_skb_cb
r_struct
id|tcp_skb_cb
(brace
DECL|member|header
r_struct
id|inet_skb_parm
id|header
suffix:semicolon
multiline_comment|/* For incoming frames&t;&t;*/
DECL|member|seq
id|__u32
id|seq
suffix:semicolon
multiline_comment|/* Starting sequence number&t;*/
DECL|member|end_seq
id|__u32
id|end_seq
suffix:semicolon
multiline_comment|/* SEQ + FIN + SYN + datalen&t;*/
DECL|member|when
r_int
r_int
id|when
suffix:semicolon
multiline_comment|/* used to compute rtt&squot;s&t;*/
DECL|member|flags
id|__u8
id|flags
suffix:semicolon
multiline_comment|/* TCP header flags.&t;&t;*/
multiline_comment|/* NOTE: These must match up to the flags byte in a&n;&t; *       real TCP header.&n;&t; */
DECL|macro|TCPCB_FLAG_FIN
mdefine_line|#define TCPCB_FLAG_FIN&t;&t;0x01
DECL|macro|TCPCB_FLAG_SYN
mdefine_line|#define TCPCB_FLAG_SYN&t;&t;0x02
DECL|macro|TCPCB_FLAG_RST
mdefine_line|#define TCPCB_FLAG_RST&t;&t;0x04
DECL|macro|TCPCB_FLAG_PSH
mdefine_line|#define TCPCB_FLAG_PSH&t;&t;0x08
DECL|macro|TCPCB_FLAG_ACK
mdefine_line|#define TCPCB_FLAG_ACK&t;&t;0x10
DECL|macro|TCPCB_FLAG_URG
mdefine_line|#define TCPCB_FLAG_URG&t;&t;0x20
DECL|member|sacked
id|__u8
id|sacked
suffix:semicolon
multiline_comment|/* State flags for SACK/FACK.&t;*/
DECL|macro|TCPCB_SACKED_ACKED
mdefine_line|#define TCPCB_SACKED_ACKED&t;0x01&t;/* SKB ACK&squot;d by a SACK block&t;*/
DECL|macro|TCPCB_SACKED_RETRANS
mdefine_line|#define TCPCB_SACKED_RETRANS&t;0x02&t;/* SKB retransmitted&t;&t;*/
DECL|member|urg_ptr
id|__u16
id|urg_ptr
suffix:semicolon
multiline_comment|/* Valid w/URG flags is set.&t;*/
DECL|member|ack_seq
id|__u32
id|ack_seq
suffix:semicolon
multiline_comment|/* Sequence number ACK&squot;d&t;*/
)brace
suffix:semicolon
DECL|macro|TCP_SKB_CB
mdefine_line|#define TCP_SKB_CB(__skb)&t;((struct tcp_skb_cb *)&amp;((__skb)-&gt;cb[0]))
multiline_comment|/* This determines how many packets are &quot;in the network&quot; to the best&n; * or our knowledge.  In many cases it is conservative, but where&n; * detailed information is available from the receiver (via SACK&n; * blocks etc.) we can make more agressive calculations.&n; *&n; * Use this for decisions involving congestion control, use just&n; * tp-&gt;packets_out to determine if the send queue is empty or not.&n; *&n; * Read this equation as:&n; *&n; *&t;&quot;Packets sent once on transmission queue&quot; MINUS&n; *&t;&quot;Packets acknowledged by FACK information&quot; PLUS&n; *&t;&quot;Packets fast retransmitted&quot;&n; */
DECL|function|tcp_packets_in_flight
r_static
id|__inline__
r_int
id|tcp_packets_in_flight
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_return
id|tp-&gt;packets_out
op_minus
id|tp-&gt;fackets_out
op_plus
id|tp-&gt;retrans_out
suffix:semicolon
)brace
multiline_comment|/* This checks if the data bearing packet SKB (usually tp-&gt;send_head)&n; * should be put on the wire right now.&n; */
DECL|function|tcp_snd_test
r_static
id|__inline__
r_int
id|tcp_snd_test
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
(paren
id|sk-&gt;tp_pinfo.af_tcp
)paren
suffix:semicolon
r_int
id|nagle_check
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&t;RFC 1122 - section 4.2.3.4&n;&t; *&n;&t; *&t;We must queue if&n;&t; *&n;&t; *&t;a) The right edge of this frame exceeds the window&n;&t; *&t;b) There are packets in flight and we have a small segment&n;&t; *&t;   [SWS avoidance and Nagle algorithm]&n;&t; *&t;   (part of SWS is done on packetization)&n;&t; *&t;c) We are retransmiting [Nagle]&n;&t; *&t;d) We have too many packets &squot;in flight&squot;&n;&t; *&n;&t; * &t;Don&squot;t use the nagle rule for urgent data.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;nonagle
op_logical_and
id|skb-&gt;len
OL
(paren
id|sk-&gt;mss
op_rshift
l_int|1
)paren
op_logical_and
id|tp-&gt;packets_out
op_logical_and
op_logical_neg
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|flags
op_amp
id|TCPCB_FLAG_URG
)paren
)paren
id|nagle_check
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|nagle_check
op_logical_and
id|tcp_packets_in_flight
c_func
(paren
id|tp
)paren
OL
id|tp-&gt;snd_cwnd
op_logical_and
op_logical_neg
id|after
c_func
(paren
id|TCP_SKB_CB
c_func
(paren
id|skb
)paren
op_member_access_from_pointer
id|end_seq
comma
id|tp-&gt;snd_una
op_plus
id|tp-&gt;snd_wnd
)paren
op_logical_and
id|tp-&gt;retransmits
op_eq
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* This tells the input processing path that an ACK should go out&n; * right now.&n; */
DECL|macro|tcp_enter_quickack_mode
mdefine_line|#define tcp_enter_quickack_mode(__tp)&t;((__tp)-&gt;ato = (HZ/100))
DECL|macro|tcp_in_quickack_mode
mdefine_line|#define tcp_in_quickack_mode(__tp)&t;((__tp)-&gt;ato == (HZ/100))
multiline_comment|/*&n; * List all states of a TCP socket that can be viewed as a &quot;connected&quot;&n; * state.  This now includes TCP_SYN_RECV, although I am not yet fully&n; * convinced that this is the solution for the &squot;getpeername(2)&squot;&n; * problem. Thanks to Stephen A. Wood &lt;saw@cebaf.gov&gt;  -FvK&n; */
DECL|function|tcp_connected
r_extern
id|__inline
r_const
r_int
id|tcp_connected
c_func
(paren
r_const
r_int
id|state
)paren
(brace
r_return
(paren
(paren
l_int|1
op_lshift
id|state
)paren
op_amp
(paren
id|TCPF_ESTABLISHED
op_or
id|TCPF_CLOSE_WAIT
op_or
id|TCPF_FIN_WAIT1
op_or
id|TCPF_FIN_WAIT2
op_or
id|TCPF_SYN_RECV
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Calculate(/check) TCP checksum&n; */
DECL|function|tcp_v4_check
r_static
id|__inline__
id|u16
id|tcp_v4_check
c_func
(paren
r_struct
id|tcphdr
op_star
id|th
comma
r_int
id|len
comma
r_int
r_int
id|saddr
comma
r_int
r_int
id|daddr
comma
r_int
r_int
id|base
)paren
(brace
r_return
id|csum_tcpudp_magic
c_func
(paren
id|saddr
comma
id|daddr
comma
id|len
comma
id|IPPROTO_TCP
comma
id|base
)paren
suffix:semicolon
)brace
DECL|macro|STATE_TRACE
macro_line|#undef STATE_TRACE
macro_line|#ifdef STATE_TRACE
DECL|variable|statename
r_static
r_char
op_star
id|statename
(braket
)braket
op_assign
initialization_block
suffix:semicolon
macro_line|#endif
DECL|function|tcp_set_state
r_static
id|__inline__
r_void
id|tcp_set_state
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|state
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_int
id|oldstate
op_assign
id|sk-&gt;state
suffix:semicolon
id|sk-&gt;state
op_assign
id|state
suffix:semicolon
macro_line|#ifdef STATE_TRACE
id|SOCK_DEBUG
c_func
(paren
id|sk
comma
l_string|&quot;TCP sk=%p, State %s -&gt; %s&bslash;n&quot;
comma
id|sk
comma
id|statename
(braket
id|oldstate
)braket
comma
id|statename
(braket
id|state
)braket
)paren
suffix:semicolon
macro_line|#endif&t;
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|TCP_ESTABLISHED
suffix:colon
r_if
c_cond
(paren
id|oldstate
op_ne
id|TCP_ESTABLISHED
)paren
id|tcp_statistics.TcpCurrEstab
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCP_CLOSE
suffix:colon
multiline_comment|/* Should be about 2 rtt&squot;s */
id|net_reset_timer
c_func
(paren
id|sk
comma
id|TIME_DONE
comma
id|min
c_func
(paren
id|tp-&gt;srtt
op_star
l_int|2
comma
id|TCP_DONE_TIME
)paren
)paren
suffix:semicolon
id|sk-&gt;prot
op_member_access_from_pointer
id|unhash
c_func
(paren
id|sk
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|oldstate
op_eq
id|TCP_ESTABLISHED
)paren
id|tcp_statistics.TcpCurrEstab
op_decrement
suffix:semicolon
)brace
)brace
DECL|function|tcp_build_and_update_options
r_static
id|__inline__
r_void
id|tcp_build_and_update_options
c_func
(paren
id|__u32
op_star
id|ptr
comma
r_struct
id|tcp_opt
op_star
id|tp
comma
id|__u32
id|tstamp
)paren
(brace
r_if
c_cond
(paren
id|tp-&gt;tstamp_ok
)paren
(brace
op_star
id|ptr
op_increment
op_assign
id|__constant_htonl
c_func
(paren
(paren
id|TCPOPT_NOP
op_lshift
l_int|24
)paren
op_or
(paren
id|TCPOPT_NOP
op_lshift
l_int|16
)paren
op_or
(paren
id|TCPOPT_TIMESTAMP
op_lshift
l_int|8
)paren
op_or
id|TCPOLEN_TIMESTAMP
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|htonl
c_func
(paren
id|tstamp
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|htonl
c_func
(paren
id|tp-&gt;ts_recent
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp-&gt;sack_ok
op_logical_and
id|tp-&gt;num_sacks
)paren
(brace
r_int
id|this_sack
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|__constant_htonl
c_func
(paren
(paren
id|TCPOPT_NOP
op_lshift
l_int|24
)paren
op_or
(paren
id|TCPOPT_NOP
op_lshift
l_int|16
)paren
op_or
(paren
id|TCPOPT_SACK
op_lshift
l_int|8
)paren
op_or
(paren
id|TCPOLEN_SACK_BASE
op_plus
(paren
id|tp-&gt;num_sacks
op_star
id|TCPOLEN_SACK_PERBLOCK
)paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|this_sack
op_assign
l_int|0
suffix:semicolon
id|this_sack
OL
id|tp-&gt;num_sacks
suffix:semicolon
id|this_sack
op_increment
)paren
(brace
op_star
id|ptr
op_increment
op_assign
id|htonl
c_func
(paren
id|tp-&gt;selective_acks
(braket
id|this_sack
)braket
dot
id|start_seq
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|htonl
c_func
(paren
id|tp-&gt;selective_acks
(braket
id|this_sack
)braket
dot
id|end_seq
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Construct a tcp options header for a SYN or SYN_ACK packet.&n; * If this is every changed make sure to change the definition of&n; * MAX_SYN_SIZE to match the new maximum number of options that you&n; * can generate.&n; */
DECL|function|tcp_syn_build_options
r_extern
id|__inline__
r_void
id|tcp_syn_build_options
c_func
(paren
id|__u32
op_star
id|ptr
comma
r_int
id|mss
comma
r_int
id|ts
comma
r_int
id|sack
comma
r_int
id|offer_wscale
comma
r_int
id|wscale
comma
id|__u32
id|tstamp
)paren
(brace
multiline_comment|/* We always get an MSS option.&n;&t; * The option bytes which will be seen in normal data&n;&t; * packets should timestamps be used, must be in the MSS&n;&t; * advertised.  But we subtract them from sk-&gt;mss so&n;&t; * that calculations in tcp_sendmsg are simpler etc.&n;&t; * So account for this fact here if necessary.  If we&n;&t; * don&squot;t do this correctly, as a receiver we won&squot;t&n;&t; * recognize data packets as being full sized when we&n;&t; * should, and thus we won&squot;t abide by the delayed ACK&n;&t; * rules correctly.&n;&t; * SACKs don&squot;t matter, we never delay an ACK when we&n;&t; * have any of those going out.&n;&t; */
r_if
c_cond
(paren
id|ts
)paren
(brace
id|mss
op_add_assign
id|TCPOLEN_TSTAMP_ALIGNED
suffix:semicolon
)brace
op_star
id|ptr
op_increment
op_assign
id|htonl
c_func
(paren
(paren
id|TCPOPT_MSS
op_lshift
l_int|24
)paren
op_or
(paren
id|TCPOLEN_MSS
op_lshift
l_int|16
)paren
op_or
id|mss
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ts
)paren
(brace
r_if
c_cond
(paren
id|sack
)paren
(brace
op_star
id|ptr
op_increment
op_assign
id|__constant_htonl
c_func
(paren
(paren
id|TCPOPT_SACK_PERM
op_lshift
l_int|24
)paren
op_or
(paren
id|TCPOLEN_SACK_PERM
op_lshift
l_int|16
)paren
op_or
(paren
id|TCPOPT_TIMESTAMP
op_lshift
l_int|8
)paren
op_or
id|TCPOLEN_TIMESTAMP
)paren
suffix:semicolon
)brace
r_else
op_star
id|ptr
op_increment
op_assign
id|__constant_htonl
c_func
(paren
(paren
id|TCPOPT_NOP
op_lshift
l_int|24
)paren
op_or
(paren
id|TCPOPT_NOP
op_lshift
l_int|16
)paren
op_or
(paren
id|TCPOPT_TIMESTAMP
op_lshift
l_int|8
)paren
op_or
id|TCPOLEN_TIMESTAMP
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|htonl
c_func
(paren
id|tstamp
)paren
suffix:semicolon
multiline_comment|/* TSVAL */
op_star
id|ptr
op_increment
op_assign
id|__constant_htonl
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* TSECR */
)brace
r_else
r_if
c_cond
(paren
id|sack
)paren
(brace
op_star
id|ptr
op_increment
op_assign
id|__constant_htonl
c_func
(paren
(paren
id|TCPOPT_NOP
op_lshift
l_int|24
)paren
op_or
(paren
id|TCPOPT_NOP
op_lshift
l_int|16
)paren
op_or
(paren
id|TCPOPT_SACK_PERM
op_lshift
l_int|8
)paren
op_or
id|TCPOLEN_SACK_PERM
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offer_wscale
)paren
op_star
id|ptr
op_increment
op_assign
id|htonl
c_func
(paren
(paren
id|TCPOPT_NOP
op_lshift
l_int|24
)paren
op_or
(paren
id|TCPOPT_WINDOW
op_lshift
l_int|16
)paren
op_or
(paren
id|TCPOLEN_WINDOW
op_lshift
l_int|8
)paren
op_or
(paren
id|wscale
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Determine a window scaling and initial window to offer.&n; * Based on the assumption that the given amount of space&n; * will be offered. Store the results in the tp structure.&n; * NOTE: for smooth operation initial space offering should&n; * be a multiple of mss if possible. We assume here that mss &gt;= 1.&n; * This MUST be enforced by all callers.&n; */
DECL|function|tcp_select_initial_window
r_extern
id|__inline__
r_void
id|tcp_select_initial_window
c_func
(paren
id|__u32
id|space
comma
id|__u16
id|mss
comma
id|__u32
op_star
id|rcv_wnd
comma
id|__u32
op_star
id|window_clamp
comma
r_int
id|wscale_ok
comma
id|__u8
op_star
id|rcv_wscale
)paren
(brace
multiline_comment|/* If no clamp set the clamp to the max possible scaled window */
r_if
c_cond
(paren
op_star
id|window_clamp
op_eq
l_int|0
)paren
(paren
op_star
id|window_clamp
)paren
op_assign
(paren
l_int|65535
op_lshift
l_int|14
)paren
suffix:semicolon
id|space
op_assign
id|min
c_func
(paren
op_star
id|window_clamp
comma
id|space
)paren
suffix:semicolon
multiline_comment|/* Quantize space offering to a multiple of mss if possible. */
r_if
c_cond
(paren
id|space
OG
id|mss
)paren
id|space
op_assign
(paren
id|space
op_div
id|mss
)paren
op_star
id|mss
suffix:semicolon
multiline_comment|/* NOTE: offering an initial window larger than 32767&n;&t; * will break some buggy TCP stacks. We try to be nice.&n;&t; * If we are not window scaling, then this truncates&n;&t; * our initial window offering to 32k. There should also&n;&t; * be a sysctl option to stop being nice.&n;&t; */
(paren
op_star
id|rcv_wnd
)paren
op_assign
id|min
c_func
(paren
id|space
comma
l_int|32767
)paren
suffix:semicolon
(paren
op_star
id|rcv_wscale
)paren
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|wscale_ok
)paren
(brace
multiline_comment|/* See RFC1323 for an explanation of the limit to 14 */
r_while
c_loop
(paren
id|space
OG
l_int|65535
op_logical_and
(paren
op_star
id|rcv_wscale
)paren
OL
l_int|14
)paren
(brace
id|space
op_rshift_assign
l_int|1
suffix:semicolon
(paren
op_star
id|rcv_wscale
)paren
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Set the clamp no higher than max representable value */
(paren
op_star
id|window_clamp
)paren
op_assign
id|min
c_func
(paren
l_int|65535
op_lshift
(paren
op_star
id|rcv_wscale
)paren
comma
op_star
id|window_clamp
)paren
suffix:semicolon
)brace
DECL|function|tcp_synq_unlink
r_extern
id|__inline__
r_void
id|tcp_synq_unlink
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
r_struct
id|open_request
op_star
id|req
comma
r_struct
id|open_request
op_star
id|prev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|req-&gt;dl_next
)paren
(brace
id|tp-&gt;syn_wait_last
op_assign
(paren
r_struct
id|open_request
op_star
op_star
)paren
id|prev
suffix:semicolon
)brace
id|prev-&gt;dl_next
op_assign
id|req-&gt;dl_next
suffix:semicolon
)brace
DECL|function|tcp_synq_queue
r_extern
id|__inline__
r_void
id|tcp_synq_queue
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
comma
r_struct
id|open_request
op_star
id|req
)paren
(brace
id|req-&gt;dl_next
op_assign
l_int|NULL
suffix:semicolon
op_star
id|tp-&gt;syn_wait_last
op_assign
id|req
suffix:semicolon
id|tp-&gt;syn_wait_last
op_assign
op_amp
id|req-&gt;dl_next
suffix:semicolon
)brace
DECL|function|tcp_synq_init
r_extern
id|__inline__
r_void
id|tcp_synq_init
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
id|tp-&gt;syn_wait_queue
op_assign
l_int|NULL
suffix:semicolon
id|tp-&gt;syn_wait_last
op_assign
op_amp
id|tp-&gt;syn_wait_queue
suffix:semicolon
)brace
DECL|function|tcp_synq_unlink_tail
r_extern
id|__inline__
r_struct
id|open_request
op_star
id|tcp_synq_unlink_tail
c_func
(paren
r_struct
id|tcp_opt
op_star
id|tp
)paren
(brace
r_struct
id|open_request
op_star
id|head
op_assign
id|tp-&gt;syn_wait_queue
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Should be a net-ratelimit&squot;d thing, not all the time. */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;synq tail drop with expire=%ld&bslash;n&quot;
comma
id|head-&gt;expires
op_minus
id|jiffies
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|head-&gt;dl_next
op_eq
l_int|NULL
)paren
id|tp-&gt;syn_wait_last
op_assign
op_amp
id|tp-&gt;syn_wait_queue
suffix:semicolon
id|tp-&gt;syn_wait_queue
op_assign
id|head-&gt;dl_next
suffix:semicolon
r_return
id|head
suffix:semicolon
)brace
r_extern
r_void
id|__tcp_inc_slow_timer
c_func
(paren
r_struct
id|tcp_sl_timer
op_star
id|slt
)paren
suffix:semicolon
DECL|function|tcp_inc_slow_timer
r_extern
id|__inline__
r_void
id|tcp_inc_slow_timer
c_func
(paren
r_int
id|timer
)paren
(brace
r_struct
id|tcp_sl_timer
op_star
id|slt
op_assign
op_amp
id|tcp_slt_array
(braket
id|timer
)braket
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|slt-&gt;count
)paren
op_eq
l_int|0
)paren
(brace
id|__tcp_inc_slow_timer
c_func
(paren
id|slt
)paren
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|slt-&gt;count
)paren
suffix:semicolon
)brace
DECL|function|tcp_dec_slow_timer
r_extern
id|__inline__
r_void
id|tcp_dec_slow_timer
c_func
(paren
r_int
id|timer
)paren
(brace
r_struct
id|tcp_sl_timer
op_star
id|slt
op_assign
op_amp
id|tcp_slt_array
(braket
id|timer
)braket
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|slt-&gt;count
)paren
suffix:semicolon
)brace
multiline_comment|/* This needs to use a slow timer, so it is here. */
DECL|function|tcp_sk_unbindify
r_static
id|__inline__
r_void
id|tcp_sk_unbindify
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|tcp_bind_bucket
op_star
id|tb
op_assign
(paren
r_struct
id|tcp_bind_bucket
op_star
)paren
id|sk-&gt;prev
suffix:semicolon
r_if
c_cond
(paren
id|sk-&gt;bind_next
)paren
(brace
id|sk-&gt;bind_next-&gt;bind_pprev
op_assign
id|sk-&gt;bind_pprev
suffix:semicolon
)brace
op_star
id|sk-&gt;bind_pprev
op_assign
id|sk-&gt;bind_next
suffix:semicolon
r_if
c_cond
(paren
id|tb-&gt;owners
op_eq
l_int|NULL
)paren
(brace
id|tcp_inc_slow_timer
c_func
(paren
id|TCP_SLT_BUCKETGC
)paren
suffix:semicolon
)brace
)brace
r_extern
r_const
r_char
id|timer_bug_msg
(braket
)braket
suffix:semicolon
DECL|function|tcp_clear_xmit_timer
r_static
r_inline
r_void
id|tcp_clear_xmit_timer
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|what
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_struct
id|timer_list
op_star
id|timer
suffix:semicolon
r_switch
c_cond
(paren
id|what
)paren
(brace
r_case
id|TIME_RETRANS
suffix:colon
id|timer
op_assign
op_amp
id|tp-&gt;retransmit_timer
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_DACK
suffix:colon
id|timer
op_assign
op_amp
id|tp-&gt;delack_timer
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_PROBE0
suffix:colon
id|timer
op_assign
op_amp
id|tp-&gt;probe_timer
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|timer_bug_msg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|timer-&gt;prev
op_ne
l_int|NULL
)paren
(brace
id|del_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
)brace
)brace
DECL|function|tcp_timer_is_set
r_static
r_inline
r_int
id|tcp_timer_is_set
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|what
)paren
(brace
r_struct
id|tcp_opt
op_star
id|tp
op_assign
op_amp
id|sk-&gt;tp_pinfo.af_tcp
suffix:semicolon
r_switch
c_cond
(paren
id|what
)paren
(brace
r_case
id|TIME_RETRANS
suffix:colon
r_return
id|tp-&gt;retransmit_timer.prev
op_ne
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_DACK
suffix:colon
r_return
id|tp-&gt;delack_timer.prev
op_ne
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_PROBE0
suffix:colon
r_return
id|tp-&gt;probe_timer.prev
op_ne
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|timer_bug_msg
)paren
suffix:semicolon
)brace
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;/* _TCP_H */
eof
