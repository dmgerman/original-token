multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;Definitions for the AF_INET socket handler.&n; *&n; * Version:&t;@(#)sock.h&t;1.0.4&t;05/13/93&n; *&n; * Authors:&t;Ross Biro, &lt;bir7@leland.Stanford.Edu&gt;&n; *&t;&t;Fred N. van Kempen, &lt;waltje@uWalt.NL.Mugnet.ORG&gt;&n; *&t;&t;Corey Minyard &lt;wf-rch!minyard@relay.EU.net&gt;&n; *&t;&t;Florian La Roche &lt;flla@stud.uni-sb.de&gt;&n; *&n; * Fixes:&n; *&t;&t;Alan Cox&t;:&t;Volatiles in skbuff pointers. See&n; *&t;&t;&t;&t;&t;skbuff comments. May be overdone,&n; *&t;&t;&t;&t;&t;better to prove they can be removed&n; *&t;&t;&t;&t;&t;than the reverse.&n; *&t;&t;Alan Cox&t;:&t;Added a zapped field for tcp to note&n; *&t;&t;&t;&t;&t;a socket is reset and must stay shut up&n; *&t;&t;Alan Cox&t;:&t;New fields for options&n; *&t;Pauline Middelink&t;:&t;identd support&n; *&t;&t;Alan Cox&t;:&t;Eliminate low level recv/recvfrom&n; *&t;&t;David S. Miller&t;:&t;New socket lookup architecture.&n; *              Steve Whitehouse:       Default routines for sock_ops&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#ifndef _SOCK_H
DECL|macro|_SOCK_H
mdefine_line|#define _SOCK_H
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/cache.h&gt;
macro_line|#include &lt;linux/in.h&gt;&t;&t;/* struct sockaddr_in */
macro_line|#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
macro_line|#include &lt;linux/in6.h&gt;&t;&t;/* struct sockaddr_in6 */
macro_line|#include &lt;linux/ipv6.h&gt;&t;&t;/* dest_cache, inet6_options */
macro_line|#include &lt;linux/icmpv6.h&gt;
macro_line|#include &lt;net/if_inet6.h&gt;&t;/* struct ipv6_mc_socklist */
macro_line|#endif
macro_line|#if defined(CONFIG_INET) || defined (CONFIG_INET_MODULE)
macro_line|#include &lt;linux/icmp.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/tcp.h&gt;&t;&t;/* struct tcphdr */
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/skbuff.h&gt;&t;/* struct sk_buff */
macro_line|#include &lt;net/protocol.h&gt;&t;&t;/* struct inet_protocol */
macro_line|#if defined(CONFIG_X25) || defined(CONFIG_X25_MODULE)
macro_line|#include &lt;net/x25.h&gt;
macro_line|#endif
macro_line|#if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)
macro_line|#include &lt;net/ax25.h&gt;
macro_line|#if defined(CONFIG_NETROM) || defined(CONFIG_NETROM_MODULE)
macro_line|#include &lt;net/netrom.h&gt;
macro_line|#endif
macro_line|#if defined(CONFIG_ROSE) || defined(CONFIG_ROSE_MODULE)
macro_line|#include &lt;net/rose.h&gt;
macro_line|#endif
macro_line|#endif
macro_line|#if defined(CONFIG_PPPOE) || defined(CONFIG_PPPOE_MODULE)
macro_line|#include &lt;linux/if_pppox.h&gt;
macro_line|#include &lt;linux/ppp_channel.h&gt;   /* struct ppp_channel */
macro_line|#endif
macro_line|#if defined(CONFIG_IPX) || defined(CONFIG_IPX_MODULE)
macro_line|#if defined(CONFIG_SPX) || defined(CONFIG_SPX_MODULE)
macro_line|#include &lt;net/spx.h&gt;
macro_line|#else
macro_line|#include &lt;net/ipx.h&gt;
macro_line|#endif /* CONFIG_SPX */
macro_line|#endif /* CONFIG_IPX */
macro_line|#if defined(CONFIG_ATALK) || defined(CONFIG_ATALK_MODULE)
macro_line|#include &lt;linux/atalk.h&gt;
macro_line|#endif
macro_line|#if defined(CONFIG_DECNET) || defined(CONFIG_DECNET_MODULE)
macro_line|#include &lt;net/dn.h&gt;
macro_line|#endif
macro_line|#if defined(CONFIG_IRDA) || defined(CONFIG_IRDA_MODULE)
macro_line|#include &lt;net/irda/irda.h&gt;
macro_line|#endif
macro_line|#if defined(CONFIG_ATM) || defined(CONFIG_ATM_MODULE)
r_struct
id|atm_vcc
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_FILTER
macro_line|#include &lt;linux/filter.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;net/dst.h&gt;
multiline_comment|/* The AF_UNIX specific socket options */
DECL|struct|unix_opt
r_struct
id|unix_opt
(brace
DECL|member|addr
r_struct
id|unix_address
op_star
id|addr
suffix:semicolon
DECL|member|dentry
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
DECL|member|mnt
r_struct
id|vfsmount
op_star
id|mnt
suffix:semicolon
DECL|member|readsem
r_struct
id|semaphore
id|readsem
suffix:semicolon
DECL|member|other
r_struct
id|sock
op_star
id|other
suffix:semicolon
DECL|member|list
r_struct
id|sock
op_star
op_star
id|list
suffix:semicolon
DECL|member|gc_tree
r_struct
id|sock
op_star
id|gc_tree
suffix:semicolon
DECL|member|inflight
id|atomic_t
id|inflight
suffix:semicolon
DECL|member|lock
id|rwlock_t
id|lock
suffix:semicolon
DECL|member|peer_wait
id|wait_queue_head_t
id|peer_wait
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Once the IPX ncpd patches are in these are going into protinfo. */
macro_line|#if defined(CONFIG_IPX) || defined(CONFIG_IPX_MODULE)
DECL|struct|ipx_opt
r_struct
id|ipx_opt
(brace
DECL|member|dest_addr
id|ipx_address
id|dest_addr
suffix:semicolon
DECL|member|intrfc
id|ipx_interface
op_star
id|intrfc
suffix:semicolon
DECL|member|port
r_int
r_int
id|port
suffix:semicolon
macro_line|#ifdef CONFIG_IPX_INTERN
DECL|member|node
r_int
r_char
id|node
(braket
id|IPX_NODE_LEN
)braket
suffix:semicolon
macro_line|#endif
DECL|member|type
r_int
r_int
id|type
suffix:semicolon
multiline_comment|/* &n; * To handle special ncp connection-handling sockets for mars_nwe,&n; * the connection number must be stored in the socket.&n; */
DECL|member|ipx_ncp_conn
r_int
r_int
id|ipx_ncp_conn
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
DECL|struct|ipv6_pinfo
r_struct
id|ipv6_pinfo
(brace
DECL|member|saddr
r_struct
id|in6_addr
id|saddr
suffix:semicolon
DECL|member|rcv_saddr
r_struct
id|in6_addr
id|rcv_saddr
suffix:semicolon
DECL|member|daddr
r_struct
id|in6_addr
id|daddr
suffix:semicolon
DECL|member|daddr_cache
r_struct
id|in6_addr
op_star
id|daddr_cache
suffix:semicolon
DECL|member|flow_label
id|__u32
id|flow_label
suffix:semicolon
DECL|member|frag_size
id|__u32
id|frag_size
suffix:semicolon
DECL|member|hop_limit
r_int
id|hop_limit
suffix:semicolon
DECL|member|mcast_hops
r_int
id|mcast_hops
suffix:semicolon
DECL|member|mcast_oif
r_int
id|mcast_oif
suffix:semicolon
multiline_comment|/* pktoption flags */
r_union
(brace
r_struct
(brace
DECL|member|srcrt
id|__u8
id|srcrt
suffix:colon
l_int|2
comma
DECL|member|rxinfo
id|rxinfo
suffix:colon
l_int|1
comma
DECL|member|rxhlim
id|rxhlim
suffix:colon
l_int|1
comma
DECL|member|hopopts
id|hopopts
suffix:colon
l_int|1
comma
DECL|member|dstopts
id|dstopts
suffix:colon
l_int|1
comma
DECL|member|authhdr
id|authhdr
suffix:colon
l_int|1
comma
DECL|member|rxflow
id|rxflow
suffix:colon
l_int|1
suffix:semicolon
DECL|member|bits
)brace
id|bits
suffix:semicolon
DECL|member|all
id|__u8
id|all
suffix:semicolon
DECL|member|rxopt
)brace
id|rxopt
suffix:semicolon
multiline_comment|/* sockopt flags */
DECL|member|mc_loop
id|__u8
id|mc_loop
suffix:colon
l_int|1
comma
DECL|member|recverr
id|recverr
suffix:colon
l_int|1
comma
DECL|member|sndflow
id|sndflow
suffix:colon
l_int|1
comma
DECL|member|pmtudisc
id|pmtudisc
suffix:colon
l_int|2
suffix:semicolon
DECL|member|ipv6_mc_list
r_struct
id|ipv6_mc_socklist
op_star
id|ipv6_mc_list
suffix:semicolon
DECL|member|ipv6_fl_list
r_struct
id|ipv6_fl_socklist
op_star
id|ipv6_fl_list
suffix:semicolon
DECL|member|dst_cookie
id|__u32
id|dst_cookie
suffix:semicolon
DECL|member|opt
r_struct
id|ipv6_txoptions
op_star
id|opt
suffix:semicolon
DECL|member|pktoptions
r_struct
id|sk_buff
op_star
id|pktoptions
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|raw6_opt
r_struct
id|raw6_opt
(brace
DECL|member|checksum
id|__u32
id|checksum
suffix:semicolon
multiline_comment|/* perform checksum */
DECL|member|offset
id|__u32
id|offset
suffix:semicolon
multiline_comment|/* checksum offset  */
DECL|member|filter
r_struct
id|icmp6_filter
id|filter
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif /* IPV6 */
macro_line|#if defined(CONFIG_INET) || defined(CONFIG_INET_MODULE)
DECL|struct|raw_opt
r_struct
id|raw_opt
(brace
DECL|member|filter
r_struct
id|icmp_filter
id|filter
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_INET) || defined (CONFIG_INET_MODULE)
DECL|struct|inet_opt
r_struct
id|inet_opt
(brace
DECL|member|ttl
r_int
id|ttl
suffix:semicolon
multiline_comment|/* TTL setting */
DECL|member|tos
r_int
id|tos
suffix:semicolon
multiline_comment|/* TOS */
DECL|member|cmsg_flags
r_int
id|cmsg_flags
suffix:semicolon
DECL|member|opt
r_struct
id|ip_options
op_star
id|opt
suffix:semicolon
DECL|member|hdrincl
r_int
r_char
id|hdrincl
suffix:semicolon
multiline_comment|/* Include headers ? */
DECL|member|mc_ttl
id|__u8
id|mc_ttl
suffix:semicolon
multiline_comment|/* Multicasting TTL */
DECL|member|mc_loop
id|__u8
id|mc_loop
suffix:semicolon
multiline_comment|/* Loopback */
DECL|member|recverr
r_int
id|recverr
suffix:colon
l_int|1
comma
DECL|member|freebind
id|freebind
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pmtudisc
id|__u8
id|pmtudisc
suffix:semicolon
DECL|member|mc_index
r_int
id|mc_index
suffix:semicolon
multiline_comment|/* Multicast device index */
DECL|member|mc_addr
id|__u32
id|mc_addr
suffix:semicolon
DECL|member|mc_list
r_struct
id|ip_mc_socklist
op_star
id|mc_list
suffix:semicolon
multiline_comment|/* Group array */
)brace
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_PPPOE) || defined (CONFIG_PPPOE_MODULE)
DECL|struct|pppoe_opt
r_struct
id|pppoe_opt
(brace
DECL|member|dev
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* device associated with socket*/
DECL|member|pa
r_struct
id|pppoe_addr
id|pa
suffix:semicolon
multiline_comment|/* what this socket is bound to*/
DECL|member|relay
r_struct
id|sockaddr_pppox
id|relay
suffix:semicolon
multiline_comment|/* what socket data will be&n;&t;&t;&t;&t;&t;     relayed to (PPPoE relaying) */
)brace
suffix:semicolon
DECL|struct|pppox_opt
r_struct
id|pppox_opt
(brace
DECL|member|chan
r_struct
id|ppp_channel
id|chan
suffix:semicolon
DECL|member|sk
r_struct
id|sock
op_star
id|sk
suffix:semicolon
DECL|member|next
r_struct
id|pppox_opt
op_star
id|next
suffix:semicolon
multiline_comment|/* for hash table */
r_union
(brace
DECL|member|pppoe
r_struct
id|pppoe_opt
id|pppoe
suffix:semicolon
DECL|member|proto
)brace
id|proto
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|pppoe_dev
mdefine_line|#define pppoe_dev&t;proto.pppoe.dev
DECL|macro|pppoe_pa
mdefine_line|#define pppoe_pa&t;proto.pppoe.pa
DECL|macro|pppoe_relay
mdefine_line|#define pppoe_relay&t;proto.pppoe.relay
macro_line|#endif
multiline_comment|/* This defines a selective acknowledgement block. */
DECL|struct|tcp_sack_block
r_struct
id|tcp_sack_block
(brace
DECL|member|start_seq
id|__u32
id|start_seq
suffix:semicolon
DECL|member|end_seq
id|__u32
id|end_seq
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|tcp_opt
r_struct
id|tcp_opt
(brace
DECL|member|tcp_header_len
r_int
id|tcp_header_len
suffix:semicolon
multiline_comment|/* Bytes of tcp header to send&t;&t;*/
multiline_comment|/*&n; *&t;Header prediction flags&n; *&t;0x5?10 &lt;&lt; 16 + snd_wnd in net byte order&n; */
DECL|member|pred_flags
id|__u32
id|pred_flags
suffix:semicolon
multiline_comment|/*&n; *&t;RFC793 variables by their proper names. This means you can&n; *&t;read the code and the spec side by side (and laugh ...)&n; *&t;See RFC793 and RFC1122. The RFC writes these in capitals.&n; */
DECL|member|rcv_nxt
id|__u32
id|rcv_nxt
suffix:semicolon
multiline_comment|/* What we want to receive next &t;*/
DECL|member|snd_nxt
id|__u32
id|snd_nxt
suffix:semicolon
multiline_comment|/* Next sequence we send&t;&t;*/
DECL|member|snd_una
id|__u32
id|snd_una
suffix:semicolon
multiline_comment|/* First byte we want an ack for&t;*/
DECL|member|snd_sml
id|__u32
id|snd_sml
suffix:semicolon
multiline_comment|/* Last byte of the most recently transmitted small packet */
DECL|member|rcv_tstamp
id|__u32
id|rcv_tstamp
suffix:semicolon
multiline_comment|/* timestamp of last received ACK (for keepalives) */
DECL|member|lsndtime
id|__u32
id|lsndtime
suffix:semicolon
multiline_comment|/* timestamp of last sent data packet (for restart window) */
multiline_comment|/* Delayed ACK control data */
r_struct
(brace
DECL|member|pending
id|__u8
id|pending
suffix:semicolon
multiline_comment|/* ACK is pending */
DECL|member|quick
id|__u8
id|quick
suffix:semicolon
multiline_comment|/* Scheduled number of quick acks&t;*/
DECL|member|pingpong
id|__u8
id|pingpong
suffix:semicolon
multiline_comment|/* The session is interactive&t;&t;*/
DECL|member|blocked
id|__u8
id|blocked
suffix:semicolon
multiline_comment|/* Delayed ACK was blocked by socket lock*/
DECL|member|ato
id|__u32
id|ato
suffix:semicolon
multiline_comment|/* Predicted tick of soft clock&t;&t;*/
DECL|member|timeout
r_int
r_int
id|timeout
suffix:semicolon
multiline_comment|/* Currently scheduled timeout&t;&t;*/
DECL|member|lrcvtime
id|__u32
id|lrcvtime
suffix:semicolon
multiline_comment|/* timestamp of last received data packet*/
DECL|member|last_seg_size
id|__u16
id|last_seg_size
suffix:semicolon
multiline_comment|/* Size of last incoming segment&t;*/
DECL|member|rcv_mss
id|__u16
id|rcv_mss
suffix:semicolon
multiline_comment|/* MSS used for delayed ACK decisions&t;*/
DECL|member|ack
)brace
id|ack
suffix:semicolon
multiline_comment|/* Data for direct copy to user */
r_struct
(brace
DECL|member|prequeue
r_struct
id|sk_buff_head
id|prequeue
suffix:semicolon
DECL|member|memory
r_int
id|memory
suffix:semicolon
DECL|member|task
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
DECL|member|iov
r_struct
id|iovec
op_star
id|iov
suffix:semicolon
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|member|ucopy
)brace
id|ucopy
suffix:semicolon
DECL|member|snd_wl1
id|__u32
id|snd_wl1
suffix:semicolon
multiline_comment|/* Sequence for window update&t;&t;*/
DECL|member|snd_wnd
id|__u32
id|snd_wnd
suffix:semicolon
multiline_comment|/* The window we expect to receive&t;*/
DECL|member|max_window
id|__u32
id|max_window
suffix:semicolon
multiline_comment|/* Maximal window ever seen from peer&t;*/
DECL|member|pmtu_cookie
id|__u32
id|pmtu_cookie
suffix:semicolon
multiline_comment|/* Last pmtu seen by socket&t;&t;*/
DECL|member|mss_cache
id|__u16
id|mss_cache
suffix:semicolon
multiline_comment|/* Cached effective mss, not including SACKS */
DECL|member|mss_clamp
id|__u16
id|mss_clamp
suffix:semicolon
multiline_comment|/* Maximal mss, negotiated at connection setup */
DECL|member|ext_header_len
id|__u16
id|ext_header_len
suffix:semicolon
multiline_comment|/* Network protocol overhead (IP/IPv6 options) */
DECL|member|ca_state
id|__u8
id|ca_state
suffix:semicolon
multiline_comment|/* State of fast-retransmit machine &t;*/
DECL|member|retransmits
id|__u8
id|retransmits
suffix:semicolon
multiline_comment|/* Number of unrecovered RTO timeouts.&t;*/
DECL|member|reordering
id|__u8
id|reordering
suffix:semicolon
multiline_comment|/* Packet reordering metric.&t;&t;*/
DECL|member|queue_shrunk
id|__u8
id|queue_shrunk
suffix:semicolon
multiline_comment|/* Write queue has been shrunk recently.*/
DECL|member|defer_accept
id|__u8
id|defer_accept
suffix:semicolon
multiline_comment|/* User waits for some data after accept() */
multiline_comment|/* RTT measurement */
DECL|member|backoff
id|__u8
id|backoff
suffix:semicolon
multiline_comment|/* backoff&t;&t;&t;&t;*/
DECL|member|srtt
id|__u32
id|srtt
suffix:semicolon
multiline_comment|/* smothed round trip time &lt;&lt; 3&t;&t;*/
DECL|member|mdev
id|__u32
id|mdev
suffix:semicolon
multiline_comment|/* medium deviation&t;&t;&t;*/
DECL|member|mdev_max
id|__u32
id|mdev_max
suffix:semicolon
multiline_comment|/* maximal mdev for the last rtt period&t;*/
DECL|member|rttvar
id|__u32
id|rttvar
suffix:semicolon
multiline_comment|/* smoothed mdev_max&t;&t;&t;*/
DECL|member|rtt_seq
id|__u32
id|rtt_seq
suffix:semicolon
multiline_comment|/* sequence number to update rttvar&t;*/
DECL|member|rto
id|__u32
id|rto
suffix:semicolon
multiline_comment|/* retransmit timeout&t;&t;&t;*/
DECL|member|packets_out
id|__u32
id|packets_out
suffix:semicolon
multiline_comment|/* Packets which are &quot;in flight&quot;&t;*/
DECL|member|left_out
id|__u32
id|left_out
suffix:semicolon
multiline_comment|/* Packets which leaved network&t;&t;*/
DECL|member|retrans_out
id|__u32
id|retrans_out
suffix:semicolon
multiline_comment|/* Retransmitted packets out&t;&t;*/
multiline_comment|/*&n; *&t;Slow start and congestion control (see also Nagle, and Karn &amp; Partridge)&n; */
DECL|member|snd_ssthresh
id|__u32
id|snd_ssthresh
suffix:semicolon
multiline_comment|/* Slow start size threshold&t;&t;*/
DECL|member|snd_cwnd
id|__u32
id|snd_cwnd
suffix:semicolon
multiline_comment|/* Sending congestion window&t;&t;*/
DECL|member|snd_cwnd_cnt
id|__u16
id|snd_cwnd_cnt
suffix:semicolon
multiline_comment|/* Linear increase counter&t;&t;*/
DECL|member|snd_cwnd_clamp
id|__u16
id|snd_cwnd_clamp
suffix:semicolon
multiline_comment|/* Do not allow snd_cwnd to grow above this */
DECL|member|snd_cwnd_used
id|__u32
id|snd_cwnd_used
suffix:semicolon
DECL|member|snd_cwnd_stamp
id|__u32
id|snd_cwnd_stamp
suffix:semicolon
multiline_comment|/* Two commonly used timers in both sender and receiver paths. */
DECL|member|timeout
r_int
r_int
id|timeout
suffix:semicolon
DECL|member|retransmit_timer
r_struct
id|timer_list
id|retransmit_timer
suffix:semicolon
multiline_comment|/* Resend (no ack)&t;*/
DECL|member|delack_timer
r_struct
id|timer_list
id|delack_timer
suffix:semicolon
multiline_comment|/* Ack delay &t;&t;*/
DECL|member|out_of_order_queue
r_struct
id|sk_buff_head
id|out_of_order_queue
suffix:semicolon
multiline_comment|/* Out of order segments go here */
DECL|member|af_specific
r_struct
id|tcp_func
op_star
id|af_specific
suffix:semicolon
multiline_comment|/* Operations which are AF_INET{4,6} specific&t;*/
DECL|member|send_head
r_struct
id|sk_buff
op_star
id|send_head
suffix:semicolon
multiline_comment|/* Front of stuff to transmit&t;&t;&t;*/
DECL|member|rcv_wnd
id|__u32
id|rcv_wnd
suffix:semicolon
multiline_comment|/* Current receiver window&t;&t;*/
DECL|member|rcv_wup
id|__u32
id|rcv_wup
suffix:semicolon
multiline_comment|/* rcv_nxt on last window update sent&t;*/
DECL|member|write_seq
id|__u32
id|write_seq
suffix:semicolon
multiline_comment|/* Tail(+1) of data held in tcp send buffer */
DECL|member|pushed_seq
id|__u32
id|pushed_seq
suffix:semicolon
multiline_comment|/* Last pushed seq, required to talk to windows */
DECL|member|copied_seq
id|__u32
id|copied_seq
suffix:semicolon
multiline_comment|/* Head of yet unread data&t;&t;*/
multiline_comment|/*&n; *      Options received (usually on last packet, some only on SYN packets).&n; */
DECL|member|tstamp_ok
r_char
id|tstamp_ok
comma
multiline_comment|/* TIMESTAMP seen on SYN packet&t;&t;*/
DECL|member|wscale_ok
id|wscale_ok
comma
multiline_comment|/* Wscale seen on SYN packet&t;&t;*/
DECL|member|sack_ok
id|sack_ok
suffix:semicolon
multiline_comment|/* SACK seen on SYN packet&t;&t;*/
DECL|member|saw_tstamp
r_char
id|saw_tstamp
suffix:semicolon
multiline_comment|/* Saw TIMESTAMP on last packet&t;&t;*/
DECL|member|snd_wscale
id|__u8
id|snd_wscale
suffix:semicolon
multiline_comment|/* Window scaling received from sender&t;*/
DECL|member|rcv_wscale
id|__u8
id|rcv_wscale
suffix:semicolon
multiline_comment|/* Window scaling to send to receiver&t;*/
DECL|member|nonagle
id|__u8
id|nonagle
suffix:semicolon
multiline_comment|/* Disable Nagle algorithm?             */
DECL|member|keepalive_probes
id|__u8
id|keepalive_probes
suffix:semicolon
multiline_comment|/* num of allowed keep alive probes&t;*/
multiline_comment|/*&t;PAWS/RTTM data&t;*/
DECL|member|rcv_tsval
id|__u32
id|rcv_tsval
suffix:semicolon
multiline_comment|/* Time stamp value             &t;*/
DECL|member|rcv_tsecr
id|__u32
id|rcv_tsecr
suffix:semicolon
multiline_comment|/* Time stamp echo reply        &t;*/
DECL|member|ts_recent
id|__u32
id|ts_recent
suffix:semicolon
multiline_comment|/* Time stamp to echo next&t;&t;*/
DECL|member|ts_recent_stamp
r_int
id|ts_recent_stamp
suffix:semicolon
multiline_comment|/* Time we stored ts_recent (for aging) */
multiline_comment|/*&t;SACKs data&t;*/
DECL|member|user_mss
id|__u16
id|user_mss
suffix:semicolon
multiline_comment|/* mss requested by user in ioctl */
DECL|member|dsack
id|__u8
id|dsack
suffix:semicolon
multiline_comment|/* D-SACK is scheduled&t;&t;&t;*/
DECL|member|eff_sacks
id|__u8
id|eff_sacks
suffix:semicolon
multiline_comment|/* Size of SACK array to send with next packet */
DECL|member|duplicate_sack
r_struct
id|tcp_sack_block
id|duplicate_sack
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* D-SACK block */
DECL|member|selective_acks
r_struct
id|tcp_sack_block
id|selective_acks
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* The SACKS themselves*/
DECL|member|window_clamp
id|__u32
id|window_clamp
suffix:semicolon
multiline_comment|/* Maximal window to advertise&t;&t;*/
DECL|member|rcv_ssthresh
id|__u32
id|rcv_ssthresh
suffix:semicolon
multiline_comment|/* Current window clamp&t;&t;&t;*/
DECL|member|probes_out
id|__u8
id|probes_out
suffix:semicolon
multiline_comment|/* unanswered 0 window probes&t;&t;*/
DECL|member|num_sacks
id|__u8
id|num_sacks
suffix:semicolon
multiline_comment|/* Number of SACK blocks&t;&t;*/
DECL|member|advmss
id|__u16
id|advmss
suffix:semicolon
multiline_comment|/* Advertised MSS&t;&t;&t;*/
DECL|member|syn_retries
id|__u8
id|syn_retries
suffix:semicolon
multiline_comment|/* num of allowed syn retries */
DECL|member|ecn_flags
id|__u8
id|ecn_flags
suffix:semicolon
multiline_comment|/* ECN status bits.&t;&t;&t;*/
DECL|member|prior_ssthresh
id|__u16
id|prior_ssthresh
suffix:semicolon
multiline_comment|/* ssthresh saved at recovery start&t;*/
DECL|member|lost_out
id|__u32
id|lost_out
suffix:semicolon
multiline_comment|/* Lost packets&t;&t;&t;&t;*/
DECL|member|sacked_out
id|__u32
id|sacked_out
suffix:semicolon
multiline_comment|/* SACK&squot;d packets&t;&t;&t;*/
DECL|member|fackets_out
id|__u32
id|fackets_out
suffix:semicolon
multiline_comment|/* FACK&squot;d packets&t;&t;&t;*/
DECL|member|high_seq
id|__u32
id|high_seq
suffix:semicolon
multiline_comment|/* snd_nxt at onset of congestion&t;*/
DECL|member|retrans_stamp
id|__u32
id|retrans_stamp
suffix:semicolon
multiline_comment|/* Timestamp of the last retransmit,&n;&t;&t;&t;&t; * also used in SYN-SENT to remember stamp of&n;&t;&t;&t;&t; * the first SYN. */
DECL|member|undo_marker
id|__u32
id|undo_marker
suffix:semicolon
multiline_comment|/* tracking retrans started here. */
DECL|member|undo_retrans
r_int
id|undo_retrans
suffix:semicolon
multiline_comment|/* number of undoable retransmissions. */
DECL|member|syn_seq
id|__u32
id|syn_seq
suffix:semicolon
multiline_comment|/* Seq of received SYN. */
DECL|member|fin_seq
id|__u32
id|fin_seq
suffix:semicolon
multiline_comment|/* Seq of received FIN. */
DECL|member|urg_seq
id|__u32
id|urg_seq
suffix:semicolon
multiline_comment|/* Seq of received urgent pointer */
DECL|member|urg_data
id|__u16
id|urg_data
suffix:semicolon
multiline_comment|/* Saved octet of OOB data and control flags */
DECL|member|pending
id|__u8
id|pending
suffix:semicolon
multiline_comment|/* Scheduled timer event&t;*/
DECL|member|urg_mode
id|__u8
id|urg_mode
suffix:semicolon
multiline_comment|/* In urgent mode&t;&t;*/
DECL|member|snd_up
id|__u32
id|snd_up
suffix:semicolon
multiline_comment|/* Urgent pointer&t;&t;*/
multiline_comment|/* The syn_wait_lock is necessary only to avoid tcp_get_info having&n;&t; * to grab the main lock sock while browsing the listening hash&n;&t; * (otherwise it&squot;s deadlock prone).&n;&t; * This lock is acquired in read mode only from tcp_get_info() and&n;&t; * it&squot;s acquired in write mode _only_ from code that is actively&n;&t; * changing the syn_wait_queue. All readers that are holding&n;&t; * the master sock lock don&squot;t need to grab this lock in read mode&n;&t; * too as the syn_wait_queue writes are always protected from&n;&t; * the main sock lock.&n;&t; */
DECL|member|syn_wait_lock
id|rwlock_t
id|syn_wait_lock
suffix:semicolon
DECL|member|listen_opt
r_struct
id|tcp_listen_opt
op_star
id|listen_opt
suffix:semicolon
multiline_comment|/* FIFO of established children */
DECL|member|accept_queue
r_struct
id|open_request
op_star
id|accept_queue
suffix:semicolon
DECL|member|accept_queue_tail
r_struct
id|open_request
op_star
id|accept_queue_tail
suffix:semicolon
DECL|member|write_pending
r_int
id|write_pending
suffix:semicolon
multiline_comment|/* A write to socket waits to start. */
DECL|member|keepalive_time
r_int
r_int
id|keepalive_time
suffix:semicolon
multiline_comment|/* time before keep alive takes place */
DECL|member|keepalive_intvl
r_int
r_int
id|keepalive_intvl
suffix:semicolon
multiline_comment|/* time interval between keep alive probes */
DECL|member|linger2
r_int
id|linger2
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * This structure really needs to be cleaned up.&n; * Most of it is for TCP, and not used by any of&n; * the other protocols.&n; */
multiline_comment|/*&n; * The idea is to start moving to a newer struct gradualy&n; * &n; * IMHO the newer struct should have the following format:&n; * &n; *&t;struct sock {&n; *&t;&t;sockmem [mem, proto, callbacks]&n; *&n; *&t;&t;union or struct {&n; *&t;&t;&t;ax25;&n; *&t;&t;} ll_pinfo;&n; *&t;&n; *&t;&t;union {&n; *&t;&t;&t;ipv4;&n; *&t;&t;&t;ipv6;&n; *&t;&t;&t;ipx;&n; *&t;&t;&t;netrom;&n; *&t;&t;&t;rose;&n; * &t;&t;&t;x25;&n; *&t;&t;} net_pinfo;&n; *&n; *&t;&t;union {&n; *&t;&t;&t;tcp;&n; *&t;&t;&t;udp;&n; *&t;&t;&t;spx;&n; *&t;&t;&t;netrom;&n; *&t;&t;} tp_pinfo;&n; *&n; *&t;}&n; *&n; * The idea failed because IPv6 transition asssumes dual IP/IPv6 sockets.&n; * So, net_pinfo is IPv6 are really, and protinfo unifies all another&n; * private areas.&n; */
multiline_comment|/* Define this to get the sk-&gt;debug debugging facility. */
DECL|macro|SOCK_DEBUGGING
mdefine_line|#define SOCK_DEBUGGING
macro_line|#ifdef SOCK_DEBUGGING
DECL|macro|SOCK_DEBUG
mdefine_line|#define SOCK_DEBUG(sk, msg...) do { if((sk) &amp;&amp; ((sk)-&gt;debug)) printk(KERN_DEBUG msg); } while (0)
macro_line|#else
DECL|macro|SOCK_DEBUG
mdefine_line|#define SOCK_DEBUG(sk, msg...) do { } while (0)
macro_line|#endif
multiline_comment|/* This is the per-socket lock.  The spinlock provides a synchronization&n; * between user contexts and software interrupt processing, whereas the&n; * mini-semaphore synchronizes multiple users amongst themselves.&n; */
r_typedef
r_struct
(brace
DECL|member|slock
id|spinlock_t
id|slock
suffix:semicolon
DECL|member|users
r_int
r_int
id|users
suffix:semicolon
DECL|member|wq
id|wait_queue_head_t
id|wq
suffix:semicolon
DECL|typedef|socket_lock_t
)brace
id|socket_lock_t
suffix:semicolon
DECL|macro|sock_lock_init
mdefine_line|#define sock_lock_init(__sk) &bslash;&n;do {&t;spin_lock_init(&amp;((__sk)-&gt;lock.slock)); &bslash;&n;&t;(__sk)-&gt;lock.users = 0; &bslash;&n;&t;init_waitqueue_head(&amp;((__sk)-&gt;lock.wq)); &bslash;&n;} while(0);
DECL|struct|sock
r_struct
id|sock
(brace
multiline_comment|/* Socket demultiplex comparisons on incoming packets. */
DECL|member|daddr
id|__u32
id|daddr
suffix:semicolon
multiline_comment|/* Foreign IPv4 addr&t;&t;&t;*/
DECL|member|rcv_saddr
id|__u32
id|rcv_saddr
suffix:semicolon
multiline_comment|/* Bound local IPv4 addr&t;&t;*/
DECL|member|dport
id|__u16
id|dport
suffix:semicolon
multiline_comment|/* Destination port&t;&t;&t;*/
DECL|member|num
r_int
r_int
id|num
suffix:semicolon
multiline_comment|/* Local port&t;&t;&t;&t;*/
DECL|member|bound_dev_if
r_int
id|bound_dev_if
suffix:semicolon
multiline_comment|/* Bound device index if != 0&t;&t;*/
multiline_comment|/* Main hash linkage for various protocol lookup tables. */
DECL|member|next
r_struct
id|sock
op_star
id|next
suffix:semicolon
DECL|member|pprev
r_struct
id|sock
op_star
op_star
id|pprev
suffix:semicolon
DECL|member|bind_next
r_struct
id|sock
op_star
id|bind_next
suffix:semicolon
DECL|member|bind_pprev
r_struct
id|sock
op_star
op_star
id|bind_pprev
suffix:semicolon
DECL|member|state
r_volatile
r_int
r_char
id|state
comma
multiline_comment|/* Connection state&t;&t;&t;*/
DECL|member|zapped
id|zapped
suffix:semicolon
multiline_comment|/* In ax25 &amp; ipx means not linked&t;*/
DECL|member|sport
id|__u16
id|sport
suffix:semicolon
multiline_comment|/* Source port&t;&t;&t;&t;*/
DECL|member|family
r_int
r_int
id|family
suffix:semicolon
multiline_comment|/* Address family&t;&t;&t;*/
DECL|member|reuse
r_int
r_char
id|reuse
suffix:semicolon
multiline_comment|/* SO_REUSEADDR setting&t;&t;&t;*/
DECL|member|shutdown
r_int
r_char
id|shutdown
suffix:semicolon
DECL|member|refcnt
id|atomic_t
id|refcnt
suffix:semicolon
multiline_comment|/* Reference count&t;&t;&t;*/
DECL|member|lock
id|socket_lock_t
id|lock
suffix:semicolon
multiline_comment|/* Synchronizer...&t;&t;&t;*/
DECL|member|rcvbuf
r_int
id|rcvbuf
suffix:semicolon
multiline_comment|/* Size of receive buffer in bytes&t;*/
DECL|member|sleep
id|wait_queue_head_t
op_star
id|sleep
suffix:semicolon
multiline_comment|/* Sock wait queue&t;&t;&t;*/
DECL|member|dst_cache
r_struct
id|dst_entry
op_star
id|dst_cache
suffix:semicolon
multiline_comment|/* Destination cache&t;&t;&t;*/
DECL|member|dst_lock
id|rwlock_t
id|dst_lock
suffix:semicolon
DECL|member|rmem_alloc
id|atomic_t
id|rmem_alloc
suffix:semicolon
multiline_comment|/* Receive queue bytes committed&t;*/
DECL|member|receive_queue
r_struct
id|sk_buff_head
id|receive_queue
suffix:semicolon
multiline_comment|/* Incoming packets&t;&t;&t;*/
DECL|member|wmem_alloc
id|atomic_t
id|wmem_alloc
suffix:semicolon
multiline_comment|/* Transmit queue bytes committed&t;*/
DECL|member|write_queue
r_struct
id|sk_buff_head
id|write_queue
suffix:semicolon
multiline_comment|/* Packet sending queue&t;&t;&t;*/
DECL|member|omem_alloc
id|atomic_t
id|omem_alloc
suffix:semicolon
multiline_comment|/* &quot;o&quot; is &quot;option&quot; or &quot;other&quot; */
DECL|member|wmem_queued
r_int
id|wmem_queued
suffix:semicolon
multiline_comment|/* Persistent queue size */
DECL|member|forward_alloc
r_int
id|forward_alloc
suffix:semicolon
multiline_comment|/* Space allocated forward. */
DECL|member|saddr
id|__u32
id|saddr
suffix:semicolon
multiline_comment|/* Sending source&t;&t;&t;*/
DECL|member|allocation
r_int
r_int
id|allocation
suffix:semicolon
multiline_comment|/* Allocation mode&t;&t;&t;*/
DECL|member|sndbuf
r_int
id|sndbuf
suffix:semicolon
multiline_comment|/* Size of send buffer in bytes&t;&t;*/
DECL|member|prev
r_struct
id|sock
op_star
id|prev
suffix:semicolon
multiline_comment|/* Not all are volatile, but some are, so we might as well say they all are.&n;&t; * XXX Make this a flag word -DaveM&n;&t; */
DECL|member|dead
r_volatile
r_char
id|dead
comma
DECL|member|done
id|done
comma
DECL|member|urginline
id|urginline
comma
DECL|member|keepopen
id|keepopen
comma
DECL|member|linger
id|linger
comma
DECL|member|destroy
id|destroy
comma
DECL|member|no_check
id|no_check
comma
DECL|member|broadcast
id|broadcast
comma
DECL|member|bsdism
id|bsdism
suffix:semicolon
DECL|member|debug
r_int
r_char
id|debug
suffix:semicolon
DECL|member|rcvtstamp
r_int
r_char
id|rcvtstamp
suffix:semicolon
DECL|member|userlocks
r_int
r_char
id|userlocks
suffix:semicolon
DECL|member|proc
r_int
id|proc
suffix:semicolon
DECL|member|lingertime
r_int
r_int
id|lingertime
suffix:semicolon
DECL|member|hashent
r_int
id|hashent
suffix:semicolon
DECL|member|pair
r_struct
id|sock
op_star
id|pair
suffix:semicolon
multiline_comment|/* The backlog queue is special, it is always used with&n;&t; * the per-socket spinlock held and requires low latency&n;&t; * access.  Therefore we special case it&squot;s implementation.&n;&t; */
r_struct
(brace
DECL|member|head
r_struct
id|sk_buff
op_star
id|head
suffix:semicolon
DECL|member|tail
r_struct
id|sk_buff
op_star
id|tail
suffix:semicolon
DECL|member|backlog
)brace
id|backlog
suffix:semicolon
DECL|member|callback_lock
id|rwlock_t
id|callback_lock
suffix:semicolon
multiline_comment|/* Error queue, rarely used. */
DECL|member|error_queue
r_struct
id|sk_buff_head
id|error_queue
suffix:semicolon
DECL|member|prot
r_struct
id|proto
op_star
id|prot
suffix:semicolon
macro_line|#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
r_union
(brace
DECL|member|af_inet6
r_struct
id|ipv6_pinfo
id|af_inet6
suffix:semicolon
DECL|member|net_pinfo
)brace
id|net_pinfo
suffix:semicolon
macro_line|#endif
r_union
(brace
DECL|member|af_tcp
r_struct
id|tcp_opt
id|af_tcp
suffix:semicolon
macro_line|#if defined(CONFIG_INET) || defined (CONFIG_INET_MODULE)
DECL|member|tp_raw4
r_struct
id|raw_opt
id|tp_raw4
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
DECL|member|tp_raw
r_struct
id|raw6_opt
id|tp_raw
suffix:semicolon
macro_line|#endif /* CONFIG_IPV6 */
macro_line|#if defined(CONFIG_SPX) || defined (CONFIG_SPX_MODULE)
DECL|member|af_spx
r_struct
id|spx_opt
id|af_spx
suffix:semicolon
macro_line|#endif /* CONFIG_SPX */
DECL|member|tp_pinfo
)brace
id|tp_pinfo
suffix:semicolon
DECL|member|err
DECL|member|err_soft
r_int
id|err
comma
id|err_soft
suffix:semicolon
multiline_comment|/* Soft holds errors that don&squot;t&n;&t;&t;&t;&t;&t;&t;   cause failure but are the cause&n;&t;&t;&t;&t;&t;&t;   of a persistent failure not just&n;&t;&t;&t;&t;&t;&t;   &squot;timed out&squot; */
DECL|member|ack_backlog
r_int
r_int
id|ack_backlog
suffix:semicolon
DECL|member|max_ack_backlog
r_int
r_int
id|max_ack_backlog
suffix:semicolon
DECL|member|priority
id|__u32
id|priority
suffix:semicolon
DECL|member|type
r_int
r_int
id|type
suffix:semicolon
DECL|member|localroute
r_int
r_char
id|localroute
suffix:semicolon
multiline_comment|/* Route locally only */
DECL|member|protocol
r_int
r_char
id|protocol
suffix:semicolon
DECL|member|peercred
r_struct
id|ucred
id|peercred
suffix:semicolon
DECL|member|rcvlowat
r_int
id|rcvlowat
suffix:semicolon
DECL|member|rcvtimeo
r_int
id|rcvtimeo
suffix:semicolon
DECL|member|sndtimeo
r_int
id|sndtimeo
suffix:semicolon
macro_line|#ifdef CONFIG_FILTER
multiline_comment|/* Socket Filtering Instructions */
DECL|member|filter
r_struct
id|sk_filter
op_star
id|filter
suffix:semicolon
macro_line|#endif /* CONFIG_FILTER */
multiline_comment|/* This is where all the private (optional) areas that don&squot;t&n;&t; * overlap will eventually live. &n;&t; */
r_union
(brace
DECL|member|destruct_hook
r_void
op_star
id|destruct_hook
suffix:semicolon
DECL|member|af_unix
r_struct
id|unix_opt
id|af_unix
suffix:semicolon
macro_line|#if defined(CONFIG_INET) || defined (CONFIG_INET_MODULE)
DECL|member|af_inet
r_struct
id|inet_opt
id|af_inet
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_ATALK) || defined(CONFIG_ATALK_MODULE)
DECL|member|af_at
r_struct
id|atalk_sock
id|af_at
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_IPX) || defined(CONFIG_IPX_MODULE)
DECL|member|af_ipx
r_struct
id|ipx_opt
id|af_ipx
suffix:semicolon
macro_line|#endif
macro_line|#if defined (CONFIG_DECNET) || defined(CONFIG_DECNET_MODULE)
DECL|member|dn
r_struct
id|dn_scp
id|dn
suffix:semicolon
macro_line|#endif
macro_line|#if defined (CONFIG_PACKET) || defined(CONFIG_PACKET_MODULE)
DECL|member|af_packet
r_struct
id|packet_opt
op_star
id|af_packet
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_X25) || defined(CONFIG_X25_MODULE)
DECL|member|x25
id|x25_cb
op_star
id|x25
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_AX25) || defined(CONFIG_AX25_MODULE)
DECL|member|ax25
id|ax25_cb
op_star
id|ax25
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_NETROM) || defined(CONFIG_NETROM_MODULE)
DECL|member|nr
id|nr_cb
op_star
id|nr
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_ROSE) || defined(CONFIG_ROSE_MODULE)
DECL|member|rose
id|rose_cb
op_star
id|rose
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_PPPOE) || defined(CONFIG_PPPOE_MODULE)
DECL|member|pppox
r_struct
id|pppox_opt
op_star
id|pppox
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NETLINK
DECL|member|af_netlink
r_struct
id|netlink_opt
op_star
id|af_netlink
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_ECONET) || defined(CONFIG_ECONET_MODULE)
DECL|member|af_econet
r_struct
id|econet_opt
op_star
id|af_econet
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_ATM) || defined(CONFIG_ATM_MODULE)
DECL|member|af_atm
r_struct
id|atm_vcc
op_star
id|af_atm
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_IRDA) || defined(CONFIG_IRDA_MODULE)
DECL|member|irda
r_struct
id|irda_sock
op_star
id|irda
suffix:semicolon
macro_line|#endif
DECL|member|protinfo
)brace
id|protinfo
suffix:semicolon
multiline_comment|/* This part is used for the timeout functions. */
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* This is the sock cleanup timer. */
DECL|member|stamp
r_struct
id|timeval
id|stamp
suffix:semicolon
multiline_comment|/* Identd and reporting IO signals */
DECL|member|socket
r_struct
id|socket
op_star
id|socket
suffix:semicolon
multiline_comment|/* RPC layer private data */
DECL|member|user_data
r_void
op_star
id|user_data
suffix:semicolon
multiline_comment|/* Callbacks */
DECL|member|state_change
r_void
(paren
op_star
id|state_change
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|data_ready
r_void
(paren
op_star
id|data_ready
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|bytes
)paren
suffix:semicolon
DECL|member|write_space
r_void
(paren
op_star
id|write_space
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|error_report
r_void
(paren
op_star
id|error_report
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|backlog_rcv
r_int
(paren
op_star
id|backlog_rcv
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
DECL|member|destruct
r_void
(paren
op_star
id|destruct
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* The per-socket spinlock must be held here. */
DECL|macro|sk_add_backlog
mdefine_line|#define sk_add_backlog(__sk, __skb)&t;&t;&t;&bslash;&n;do {&t;if((__sk)-&gt;backlog.tail == NULL) {&t;&t;&bslash;&n;&t;&t;(__sk)-&gt;backlog.head =&t;&t;&t;&bslash;&n;&t;&t;     (__sk)-&gt;backlog.tail = (__skb);&t;&bslash;&n;&t;} else {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;((__sk)-&gt;backlog.tail)-&gt;next = (__skb);&t;&bslash;&n;&t;&t;(__sk)-&gt;backlog.tail = (__skb);&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&bslash;&n;&t;(__skb)-&gt;next = NULL;&t;&t;&t;&t;&bslash;&n;} while(0)
multiline_comment|/* IP protocol blocks we attach to sockets.&n; * socket layer -&gt; transport layer interface&n; * transport -&gt; network interface is defined by struct inet_proto&n; */
DECL|struct|proto
r_struct
id|proto
(brace
DECL|member|close
r_void
(paren
op_star
id|close
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|timeout
)paren
suffix:semicolon
DECL|member|connect
r_int
(paren
op_star
id|connect
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
)paren
suffix:semicolon
DECL|member|disconnect
r_int
(paren
op_star
id|disconnect
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
)paren
suffix:semicolon
DECL|member|accept
r_struct
id|sock
op_star
(paren
op_star
id|accept
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
comma
r_int
op_star
id|err
)paren
suffix:semicolon
DECL|member|ioctl
r_int
(paren
op_star
id|ioctl
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
DECL|member|init
r_int
(paren
op_star
id|init
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|destroy
r_int
(paren
op_star
id|destroy
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|shutdown
r_void
(paren
op_star
id|shutdown
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|how
)paren
suffix:semicolon
DECL|member|setsockopt
r_int
(paren
op_star
id|setsockopt
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
suffix:semicolon
DECL|member|getsockopt
r_int
(paren
op_star
id|getsockopt
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|level
comma
r_int
id|optname
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|option
)paren
suffix:semicolon
DECL|member|sendmsg
r_int
(paren
op_star
id|sendmsg
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
)paren
suffix:semicolon
DECL|member|recvmsg
r_int
(paren
op_star
id|recvmsg
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|msghdr
op_star
id|msg
comma
r_int
id|len
comma
r_int
id|noblock
comma
r_int
id|flags
comma
r_int
op_star
id|addr_len
)paren
suffix:semicolon
DECL|member|bind
r_int
(paren
op_star
id|bind
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sockaddr
op_star
id|uaddr
comma
r_int
id|addr_len
)paren
suffix:semicolon
DECL|member|backlog_rcv
r_int
(paren
op_star
id|backlog_rcv
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
multiline_comment|/* Keeping track of sk&squot;s, looking them up, and port selection methods. */
DECL|member|hash
r_void
(paren
op_star
id|hash
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|unhash
r_void
(paren
op_star
id|unhash
)paren
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|member|get_port
r_int
(paren
op_star
id|get_port
)paren
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|snum
)paren
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
r_struct
(brace
DECL|member|inuse
r_int
id|inuse
suffix:semicolon
DECL|member|__pad
id|u8
id|__pad
(braket
id|SMP_CACHE_BYTES
op_minus
r_sizeof
(paren
r_int
)paren
)braket
suffix:semicolon
DECL|member|stats
)brace
id|stats
(braket
id|NR_CPUS
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Called with local bh disabled */
DECL|function|sock_prot_inc_use
r_static
r_void
id|__inline__
id|sock_prot_inc_use
c_func
(paren
r_struct
id|proto
op_star
id|prot
)paren
(brace
id|prot-&gt;stats
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|inuse
op_increment
suffix:semicolon
)brace
DECL|function|sock_prot_dec_use
r_static
r_void
id|__inline__
id|sock_prot_dec_use
c_func
(paren
r_struct
id|proto
op_star
id|prot
)paren
(brace
id|prot-&gt;stats
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|inuse
op_decrement
suffix:semicolon
)brace
multiline_comment|/* About 10 seconds */
DECL|macro|SOCK_DESTROY_TIME
mdefine_line|#define SOCK_DESTROY_TIME (10*HZ)
multiline_comment|/* Sockets 0-1023 can&squot;t be bound to unless you are superuser */
DECL|macro|PROT_SOCK
mdefine_line|#define PROT_SOCK&t;1024
DECL|macro|SHUTDOWN_MASK
mdefine_line|#define SHUTDOWN_MASK&t;3
DECL|macro|RCV_SHUTDOWN
mdefine_line|#define RCV_SHUTDOWN&t;1
DECL|macro|SEND_SHUTDOWN
mdefine_line|#define SEND_SHUTDOWN&t;2
DECL|macro|SOCK_SNDBUF_LOCK
mdefine_line|#define SOCK_SNDBUF_LOCK&t;1
DECL|macro|SOCK_RCVBUF_LOCK
mdefine_line|#define SOCK_RCVBUF_LOCK&t;2
DECL|macro|SOCK_BINDADDR_LOCK
mdefine_line|#define SOCK_BINDADDR_LOCK&t;4
DECL|macro|SOCK_BINDPORT_LOCK
mdefine_line|#define SOCK_BINDPORT_LOCK&t;8
multiline_comment|/* Used by processes to &quot;lock&quot; a socket state, so that&n; * interrupts and bottom half handlers won&squot;t change it&n; * from under us. It essentially blocks any incoming&n; * packets, so that we won&squot;t get any new data or any&n; * packets that change the state of the socket.&n; *&n; * While locked, BH processing will add new packets to&n; * the backlog queue.  This queue is processed by the&n; * owner of the socket lock right before it is released.&n; *&n; * Since ~2.3.5 it is also exclusive sleep lock serializing&n; * accesses from user process context.&n; */
r_extern
r_void
id|__lock_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_void
id|__release_sock
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
DECL|macro|lock_sock
mdefine_line|#define lock_sock(__sk) &bslash;&n;do {&t;spin_lock_bh(&amp;((__sk)-&gt;lock.slock)); &bslash;&n;&t;if ((__sk)-&gt;lock.users != 0) &bslash;&n;&t;&t;__lock_sock(__sk); &bslash;&n;&t;(__sk)-&gt;lock.users = 1; &bslash;&n;&t;spin_unlock_bh(&amp;((__sk)-&gt;lock.slock)); &bslash;&n;} while(0)
DECL|macro|release_sock
mdefine_line|#define release_sock(__sk) &bslash;&n;do {&t;spin_lock_bh(&amp;((__sk)-&gt;lock.slock)); &bslash;&n;&t;if ((__sk)-&gt;backlog.tail != NULL) &bslash;&n;&t;&t;__release_sock(__sk); &bslash;&n;&t;(__sk)-&gt;lock.users = 0; &bslash;&n;        if (waitqueue_active(&amp;((__sk)-&gt;lock.wq))) wake_up(&amp;((__sk)-&gt;lock.wq)); &bslash;&n;&t;spin_unlock_bh(&amp;((__sk)-&gt;lock.slock)); &bslash;&n;} while(0)
multiline_comment|/* BH context may only use the following locking interface. */
DECL|macro|bh_lock_sock
mdefine_line|#define bh_lock_sock(__sk)&t;spin_lock(&amp;((__sk)-&gt;lock.slock))
DECL|macro|bh_unlock_sock
mdefine_line|#define bh_unlock_sock(__sk)&t;spin_unlock(&amp;((__sk)-&gt;lock.slock))
multiline_comment|/*&n; *&t;This might not be the most appropriate place for this two&t; &n; *&t;but since they are used by a lot of the net related code&n; *&t;at least they get declared on a include that is common to all&n; */
DECL|function|min
r_static
id|__inline__
r_int
id|min
c_func
(paren
r_int
r_int
id|a
comma
r_int
r_int
id|b
)paren
(brace
r_if
c_cond
(paren
id|a
OG
id|b
)paren
id|a
op_assign
id|b
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
DECL|function|max
r_static
id|__inline__
r_int
id|max
c_func
(paren
r_int
r_int
id|a
comma
r_int
r_int
id|b
)paren
(brace
r_if
c_cond
(paren
id|a
OL
id|b
)paren
id|a
op_assign
id|b
suffix:semicolon
r_return
id|a
suffix:semicolon
)brace
r_extern
r_struct
id|sock
op_star
id|sk_alloc
c_func
(paren
r_int
id|family
comma
r_int
id|priority
comma
r_int
id|zero_it
)paren
suffix:semicolon
r_extern
r_void
id|sk_free
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|sock_wmalloc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
id|force
comma
r_int
id|priority
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|sock_rmalloc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
id|force
comma
r_int
id|priority
)paren
suffix:semicolon
r_extern
r_void
id|sock_wfree
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_void
id|sock_rfree
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_int
id|sock_setsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|op
comma
r_char
op_star
id|optval
comma
r_int
id|optlen
)paren
suffix:semicolon
r_extern
r_int
id|sock_getsockopt
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_int
id|level
comma
r_int
id|op
comma
r_char
op_star
id|optval
comma
r_int
op_star
id|optlen
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|sock_alloc_send_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
r_int
id|size
comma
r_int
r_int
id|fallback
comma
r_int
id|noblock
comma
r_int
op_star
id|errcode
)paren
suffix:semicolon
r_extern
r_void
op_star
id|sock_kmalloc
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|size
comma
r_int
id|priority
)paren
suffix:semicolon
r_extern
r_void
id|sock_kfree_s
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_void
op_star
id|mem
comma
r_int
id|size
)paren
suffix:semicolon
r_extern
r_int
id|copy_and_csum_toiovec
c_func
(paren
r_struct
id|iovec
op_star
id|iov
comma
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|hlen
)paren
suffix:semicolon
multiline_comment|/*&n; * Functions to fill in entries in struct proto_ops when a protocol&n; * does not implement a particular function.&n; */
r_extern
r_int
id|sock_no_release
c_func
(paren
r_struct
id|socket
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_bind
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|sockaddr
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_connect
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|sockaddr
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_socketpair
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|socket
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_accept
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|socket
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_getname
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|sockaddr
op_star
comma
r_int
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
r_int
id|sock_no_poll
c_func
(paren
r_struct
id|file
op_star
comma
r_struct
id|socket
op_star
comma
r_struct
id|poll_table_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_ioctl
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_listen
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_shutdown
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_getsockopt
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
comma
r_int
comma
r_char
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_setsockopt
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
comma
r_int
comma
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_fcntl
c_func
(paren
r_struct
id|socket
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_sendmsg
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|msghdr
op_star
comma
r_int
comma
r_struct
id|scm_cookie
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_recvmsg
c_func
(paren
r_struct
id|socket
op_star
comma
r_struct
id|msghdr
op_star
comma
r_int
comma
r_int
comma
r_struct
id|scm_cookie
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_no_mmap
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|vm_area_struct
op_star
id|vma
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Default socket callbacks and setup code&n; */
r_extern
r_void
id|sock_def_destruct
c_func
(paren
r_struct
id|sock
op_star
)paren
suffix:semicolon
multiline_comment|/* Initialise core socket variables */
r_extern
r_void
id|sock_init_data
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_void
id|sklist_remove_socket
c_func
(paren
r_struct
id|sock
op_star
op_star
id|list
comma
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_void
id|sklist_insert_socket
c_func
(paren
r_struct
id|sock
op_star
op_star
id|list
comma
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
r_extern
r_void
id|sklist_destroy_socket
c_func
(paren
r_struct
id|sock
op_star
op_star
id|list
comma
r_struct
id|sock
op_star
id|sk
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_FILTER
multiline_comment|/**&n; *&t;sk_filter - run a packet through a socket filter&n; *&t;@skb: buffer to filter&n; *&t;@filter: filter to apply&n; *&n; * Run the filter code and then cut skb-&gt;data to correct size returned by&n; * sk_run_filter. If pkt_len is 0 we toss packet. If skb-&gt;len is smaller&n; * than pkt_len we keep whole skb-&gt;data. This is the socket level&n; * wrapper to sk_run_filter. It returns 0 if the packet should&n; * be accepted or 1 if the packet should be tossed.&n; */
DECL|function|sk_filter
r_static
r_inline
r_int
id|sk_filter
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sk_filter
op_star
id|filter
)paren
(brace
r_int
id|pkt_len
suffix:semicolon
id|pkt_len
op_assign
id|sk_run_filter
c_func
(paren
id|skb
comma
id|filter-&gt;insns
comma
id|filter-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pkt_len
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Toss Packet */
r_else
id|skb_trim
c_func
(paren
id|skb
comma
id|pkt_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;sk_filter_release: Release a socket filter&n; *&t;@sk: socket&n; *&t;@fp: filter to remove&n; *&n; *&t;Remove a filter from a socket and release its resources.&n; */
DECL|function|sk_filter_release
r_static
r_inline
r_void
id|sk_filter_release
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_filter
op_star
id|fp
)paren
(brace
r_int
r_int
id|size
op_assign
id|sk_filter_len
c_func
(paren
id|fp
)paren
suffix:semicolon
id|atomic_sub
c_func
(paren
id|size
comma
op_amp
id|sk-&gt;omem_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|fp-&gt;refcnt
)paren
)paren
id|kfree
c_func
(paren
id|fp
)paren
suffix:semicolon
)brace
DECL|function|sk_filter_charge
r_static
r_inline
r_void
id|sk_filter_charge
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_filter
op_star
id|fp
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|fp-&gt;refcnt
)paren
suffix:semicolon
id|atomic_add
c_func
(paren
id|sk_filter_len
c_func
(paren
id|fp
)paren
comma
op_amp
id|sk-&gt;omem_alloc
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_FILTER */
multiline_comment|/*&n; * Socket reference counting postulates.&n; *&n; * * Each user of socket SHOULD hold a reference count.&n; * * Each access point to socket (an hash table bucket, reference from a list,&n; *   running timer, skb in flight MUST hold a reference count.&n; * * When reference count hits 0, it means it will never increase back.&n; * * When reference count hits 0, it means that no references from&n; *   outside exist to this socket and current process on current CPU&n; *   is last user and may/should destroy this socket.&n; * * sk_free is called from any context: process, BH, IRQ. When&n; *   it is called, socket has no references from outside -&gt; sk_free&n; *   may release descendant resources allocated by the socket, but&n; *   to the time when it is called, socket is NOT referenced by any&n; *   hash tables, lists etc.&n; * * Packets, delivered from outside (from network or from another process)&n; *   and enqueued on receive/error queues SHOULD NOT grab reference count,&n; *   when they sit in queue. Otherwise, packets will leak to hole, when&n; *   socket is looked up by one cpu and unhasing is made by another CPU.&n; *   It is true for udp/raw, netlink (leak to receive and error queues), tcp&n; *   (leak to backlog). Packet socket does all the processing inside&n; *   BR_NETPROTO_LOCK, so that it has not this race condition. UNIX sockets&n; *   use separate SMP lock, so that they are prone too.&n; */
multiline_comment|/* Grab socket reference count. This operation is valid only&n;   when sk is ALREADY grabbed f.e. it is found in hash table&n;   or a list and the lookup is made under lock preventing hash table&n;   modifications.&n; */
DECL|function|sock_hold
r_static
r_inline
r_void
id|sock_hold
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
suffix:semicolon
)brace
multiline_comment|/* Ungrab socket in the context, which assumes that socket refcnt&n;   cannot hit zero, f.e. it is true in context of any socketcall.&n; */
DECL|function|__sock_put
r_static
r_inline
r_void
id|__sock_put
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
suffix:semicolon
)brace
multiline_comment|/* Ungrab socket and destroy it, if it was the last reference. */
DECL|function|sock_put
r_static
r_inline
r_void
id|sock_put
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|sk-&gt;refcnt
)paren
)paren
id|sk_free
c_func
(paren
id|sk
)paren
suffix:semicolon
)brace
multiline_comment|/* Detach socket from process context.&n; * Announce socket dead, detach it from wait queue and inode.&n; * Note that parent inode held reference count on this struct sock,&n; * we do not release it in this function, because protocol&n; * probably wants some additional cleanups or even continuing&n; * to work with this socket (TCP).&n; */
DECL|function|sock_orphan
r_static
r_inline
r_void
id|sock_orphan
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
id|sk-&gt;dead
op_assign
l_int|1
suffix:semicolon
id|sk-&gt;socket
op_assign
l_int|NULL
suffix:semicolon
id|sk-&gt;sleep
op_assign
l_int|NULL
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
)brace
DECL|function|sock_graft
r_static
r_inline
r_void
id|sock_graft
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|socket
op_star
id|parent
)paren
(brace
id|write_lock_bh
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
id|sk-&gt;sleep
op_assign
op_amp
id|parent-&gt;wait
suffix:semicolon
id|parent-&gt;sk
op_assign
id|sk
suffix:semicolon
id|sk-&gt;socket
op_assign
id|parent
suffix:semicolon
id|write_unlock_bh
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
)brace
DECL|function|sock_i_uid
r_static
r_inline
r_int
id|sock_i_uid
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|uid
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
id|uid
op_assign
id|sk-&gt;socket
ques
c_cond
id|sk-&gt;socket-&gt;inode-&gt;i_uid
suffix:colon
l_int|0
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
r_return
id|uid
suffix:semicolon
)brace
DECL|function|sock_i_ino
r_static
r_inline
r_int
r_int
id|sock_i_ino
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
r_int
id|ino
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
id|ino
op_assign
id|sk-&gt;socket
ques
c_cond
id|sk-&gt;socket-&gt;inode-&gt;i_ino
suffix:colon
l_int|0
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
r_return
id|ino
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|dst_entry
op_star
DECL|function|__sk_dst_get
id|__sk_dst_get
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|sk-&gt;dst_cache
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|dst_entry
op_star
DECL|function|sk_dst_get
id|sk_dst_get
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|sk-&gt;dst_lock
)paren
suffix:semicolon
id|dst
op_assign
id|sk-&gt;dst_cache
suffix:semicolon
r_if
c_cond
(paren
id|dst
)paren
id|dst_hold
c_func
(paren
id|dst
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|sk-&gt;dst_lock
)paren
suffix:semicolon
r_return
id|dst
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|__sk_dst_set
id|__sk_dst_set
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
r_struct
id|dst_entry
op_star
id|old_dst
suffix:semicolon
id|old_dst
op_assign
id|sk-&gt;dst_cache
suffix:semicolon
id|sk-&gt;dst_cache
op_assign
id|dst
suffix:semicolon
id|dst_release
c_func
(paren
id|old_dst
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|sk_dst_set
id|sk_dst_set
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|dst_entry
op_star
id|dst
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|sk-&gt;dst_lock
)paren
suffix:semicolon
id|__sk_dst_set
c_func
(paren
id|sk
comma
id|dst
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|sk-&gt;dst_lock
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|__sk_dst_reset
id|__sk_dst_reset
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_struct
id|dst_entry
op_star
id|old_dst
suffix:semicolon
id|old_dst
op_assign
id|sk-&gt;dst_cache
suffix:semicolon
id|sk-&gt;dst_cache
op_assign
l_int|NULL
suffix:semicolon
id|dst_release
c_func
(paren
id|old_dst
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|sk_dst_reset
id|sk_dst_reset
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|sk-&gt;dst_lock
)paren
suffix:semicolon
id|__sk_dst_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|sk-&gt;dst_lock
)paren
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|dst_entry
op_star
DECL|function|__sk_dst_check
id|__sk_dst_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|cookie
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|sk-&gt;dst_cache
suffix:semicolon
r_if
c_cond
(paren
id|dst
op_logical_and
id|dst-&gt;obsolete
op_logical_and
id|dst-&gt;ops
op_member_access_from_pointer
id|check
c_func
(paren
id|dst
comma
id|cookie
)paren
op_eq
l_int|NULL
)paren
(brace
id|sk-&gt;dst_cache
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|dst_entry
op_star
DECL|function|sk_dst_check
id|sk_dst_check
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
id|u32
id|cookie
)paren
(brace
r_struct
id|dst_entry
op_star
id|dst
op_assign
id|sk_dst_get
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst
op_logical_and
id|dst-&gt;obsolete
op_logical_and
id|dst-&gt;ops
op_member_access_from_pointer
id|check
c_func
(paren
id|dst
comma
id|cookie
)paren
op_eq
l_int|NULL
)paren
(brace
id|sk_dst_reset
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
id|dst
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Queue a received datagram if it will fit. Stream and sequenced&n; *&t;protocols can&squot;t normally use this as they need to fit buffers in&n; *&t;and play with them.&n; *&n; * &t;Inlined as it&squot;s very short and called for pretty much every&n; *&t;packet ever received.&n; */
DECL|function|skb_set_owner_w
r_static
r_inline
r_void
id|skb_set_owner_w
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|sock_hold
c_func
(paren
id|sk
)paren
suffix:semicolon
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;destructor
op_assign
id|sock_wfree
suffix:semicolon
id|atomic_add
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|sk-&gt;wmem_alloc
)paren
suffix:semicolon
)brace
DECL|function|skb_set_owner_r
r_static
r_inline
r_void
id|skb_set_owner_r
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sock
op_star
id|sk
)paren
(brace
id|skb-&gt;sk
op_assign
id|sk
suffix:semicolon
id|skb-&gt;destructor
op_assign
id|sock_rfree
suffix:semicolon
id|atomic_add
c_func
(paren
id|skb-&gt;truesize
comma
op_amp
id|sk-&gt;rmem_alloc
)paren
suffix:semicolon
)brace
DECL|function|sock_queue_rcv_skb
r_static
r_inline
r_int
id|sock_queue_rcv_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* Cast skb-&gt;rcvbuf to unsigned... It&squot;s pointless, but reduces&n;&t;   number of warnings when compiling with -W --ANK&n;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
op_plus
id|skb-&gt;truesize
op_ge
(paren
r_int
)paren
id|sk-&gt;rcvbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
macro_line|#ifdef CONFIG_FILTER
r_if
c_cond
(paren
id|sk-&gt;filter
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|sk_filter
op_star
id|filter
suffix:semicolon
multiline_comment|/* It would be deadlock, if sock_queue_rcv_skb is used&n;&t;&t;   with socket lock! We assume that users of this&n;&t;&t;   function are lock free.&n;&t;&t; */
id|bh_lock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|filter
op_assign
id|sk-&gt;filter
)paren
op_ne
l_int|NULL
op_logical_and
id|sk_filter
c_func
(paren
id|skb
comma
id|filter
)paren
)paren
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
id|bh_unlock_sock
c_func
(paren
id|sk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* Toss packet */
)brace
macro_line|#endif /* CONFIG_FILTER */
id|skb-&gt;dev
op_assign
l_int|NULL
suffix:semicolon
id|skb_set_owner_r
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;receive_queue
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
id|skb-&gt;len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sock_queue_err_skb
r_static
r_inline
r_int
id|sock_queue_err_skb
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
multiline_comment|/* Cast skb-&gt;rcvbuf to unsigned... It&squot;s pointless, but reduces&n;&t;   number of warnings when compiling with -W --ANK&n;&t; */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;rmem_alloc
)paren
op_plus
id|skb-&gt;truesize
op_ge
(paren
r_int
)paren
id|sk-&gt;rcvbuf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|skb_set_owner_r
c_func
(paren
id|skb
comma
id|sk
)paren
suffix:semicolon
id|skb_queue_tail
c_func
(paren
op_amp
id|sk-&gt;error_queue
comma
id|skb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
id|sk
op_member_access_from_pointer
id|data_ready
c_func
(paren
id|sk
comma
id|skb-&gt;len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Recover an error report and clear atomically&n; */
DECL|function|sock_error
r_static
r_inline
r_int
id|sock_error
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|err
op_assign
id|xchg
c_func
(paren
op_amp
id|sk-&gt;err
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|err
suffix:semicolon
)brace
DECL|function|sock_wspace
r_static
r_inline
r_int
r_int
id|sock_wspace
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_int
id|amt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sk-&gt;shutdown
op_amp
id|SEND_SHUTDOWN
)paren
)paren
(brace
id|amt
op_assign
id|sk-&gt;sndbuf
op_minus
id|atomic_read
c_func
(paren
op_amp
id|sk-&gt;wmem_alloc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amt
OL
l_int|0
)paren
id|amt
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|amt
suffix:semicolon
)brace
DECL|function|sk_wake_async
r_static
r_inline
r_void
id|sk_wake_async
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|how
comma
r_int
id|band
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;socket
op_logical_and
id|sk-&gt;socket-&gt;fasync_list
)paren
id|sock_wake_async
c_func
(paren
id|sk-&gt;socket
comma
id|how
comma
id|band
)paren
suffix:semicolon
)brace
DECL|macro|SOCK_MIN_SNDBUF
mdefine_line|#define SOCK_MIN_SNDBUF 2048
DECL|macro|SOCK_MIN_RCVBUF
mdefine_line|#define SOCK_MIN_RCVBUF 256
multiline_comment|/* Must be less or equal SOCK_MIN_SNDBUF */
DECL|macro|SOCK_MIN_WRITE_SPACE
mdefine_line|#define SOCK_MIN_WRITE_SPACE&t;SOCK_MIN_SNDBUF
multiline_comment|/*&n; *&t;Default write policy as shown to user space via poll/select/SIGIO&n; *&t;Kernel internally doesn&squot;t use the MIN_WRITE_SPACE threshold.&n; */
DECL|function|sock_writeable
r_static
r_inline
r_int
id|sock_writeable
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
r_return
id|sock_wspace
c_func
(paren
id|sk
)paren
op_ge
id|SOCK_MIN_WRITE_SPACE
suffix:semicolon
)brace
DECL|function|gfp_any
r_static
r_inline
r_int
id|gfp_any
c_func
(paren
r_void
)paren
(brace
r_return
id|in_softirq
c_func
(paren
)paren
ques
c_cond
id|GFP_ATOMIC
suffix:colon
id|GFP_KERNEL
suffix:semicolon
)brace
DECL|function|sock_rcvtimeo
r_static
r_inline
r_int
id|sock_rcvtimeo
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|noblock
)paren
(brace
r_return
id|noblock
ques
c_cond
l_int|0
suffix:colon
id|sk-&gt;rcvtimeo
suffix:semicolon
)brace
DECL|function|sock_sndtimeo
r_static
r_inline
r_int
id|sock_sndtimeo
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|noblock
)paren
(brace
r_return
id|noblock
ques
c_cond
l_int|0
suffix:colon
id|sk-&gt;sndtimeo
suffix:semicolon
)brace
DECL|function|sock_rcvlowat
r_static
r_inline
r_int
id|sock_rcvlowat
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|waitall
comma
r_int
id|len
)paren
(brace
r_return
(paren
id|waitall
ques
c_cond
id|len
suffix:colon
id|min
c_func
(paren
id|sk-&gt;rcvlowat
comma
id|len
)paren
)paren
ques
c_cond
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Alas, with timeout socket operations are not restartable.&n; * Compare this to poll().&n; */
DECL|function|sock_intr_errno
r_static
r_inline
r_int
id|sock_intr_errno
c_func
(paren
r_int
id|timeo
)paren
(brace
r_return
id|timeo
op_eq
id|MAX_SCHEDULE_TIMEOUT
ques
c_cond
op_minus
id|ERESTARTSYS
suffix:colon
op_minus
id|EINTR
suffix:semicolon
)brace
r_static
id|__inline__
r_void
DECL|function|sock_recv_timestamp
id|sock_recv_timestamp
c_func
(paren
r_struct
id|msghdr
op_star
id|msg
comma
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|sk-&gt;rcvtstamp
)paren
id|put_cmsg
c_func
(paren
id|msg
comma
id|SOL_SOCKET
comma
id|SO_TIMESTAMP
comma
r_sizeof
(paren
id|skb-&gt;stamp
)paren
comma
op_amp
id|skb-&gt;stamp
)paren
suffix:semicolon
r_else
id|sk-&gt;stamp
op_assign
id|skb-&gt;stamp
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Enable debug/info messages &n; */
macro_line|#if 0
mdefine_line|#define NETDEBUG(x)&t;do { } while (0)
macro_line|#else
DECL|macro|NETDEBUG
mdefine_line|#define NETDEBUG(x)&t;do { x; } while (0)
macro_line|#endif
multiline_comment|/*&n; * Macros for sleeping on a socket. Use them like this:&n; *&n; * SOCK_SLEEP_PRE(sk)&n; * if (condition)&n; * &t;schedule();&n; * SOCK_SLEEP_POST(sk)&n; *&n; */
DECL|macro|SOCK_SLEEP_PRE
mdefine_line|#define SOCK_SLEEP_PRE(sk) &t;{ struct task_struct *tsk = current; &bslash;&n;&t;&t;&t;&t;DECLARE_WAITQUEUE(wait, tsk); &bslash;&n;&t;&t;&t;&t;tsk-&gt;state = TASK_INTERRUPTIBLE; &bslash;&n;&t;&t;&t;&t;add_wait_queue((sk)-&gt;sleep, &amp;wait); &bslash;&n;&t;&t;&t;&t;release_sock(sk);
DECL|macro|SOCK_SLEEP_POST
mdefine_line|#define SOCK_SLEEP_POST(sk)&t;tsk-&gt;state = TASK_RUNNING; &bslash;&n;&t;&t;&t;&t;remove_wait_queue((sk)-&gt;sleep, &amp;wait); &bslash;&n;&t;&t;&t;&t;lock_sock(sk); &bslash;&n;&t;&t;&t;&t;}
r_extern
id|__u32
id|sysctl_wmem_max
suffix:semicolon
r_extern
id|__u32
id|sysctl_rmem_max
suffix:semicolon
macro_line|#endif&t;/* _SOCK_H */
eof
