macro_line|#ifndef __NET_PKT_SCHED_H
DECL|macro|__NET_PKT_SCHED_H
mdefine_line|#define __NET_PKT_SCHED_H
macro_line|#include &lt;linux/pkt_sched.h&gt;
DECL|struct|Qdisc_ops
r_struct
id|Qdisc_ops
(brace
DECL|member|next
r_struct
id|Qdisc_ops
op_star
id|next
suffix:semicolon
DECL|member|id
r_char
id|id
(braket
id|IFNAMSIZ
)braket
suffix:semicolon
DECL|member|refcnt
r_int
id|refcnt
suffix:semicolon
DECL|member|priv_size
r_int
id|priv_size
suffix:semicolon
DECL|member|enqueue
r_int
(paren
op_star
id|enqueue
)paren
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
)paren
suffix:semicolon
DECL|member|dequeue
r_struct
id|sk_buff
op_star
(paren
op_star
id|dequeue
)paren
(paren
r_struct
id|Qdisc
op_star
)paren
suffix:semicolon
DECL|member|reset
r_void
(paren
op_star
id|reset
)paren
(paren
r_struct
id|Qdisc
op_star
)paren
suffix:semicolon
DECL|member|destroy
r_void
(paren
op_star
id|destroy
)paren
(paren
r_struct
id|Qdisc
op_star
)paren
suffix:semicolon
DECL|member|init
r_int
(paren
op_star
id|init
)paren
(paren
r_struct
id|Qdisc
op_star
comma
r_void
op_star
id|arg
)paren
suffix:semicolon
DECL|member|control
r_int
(paren
op_star
id|control
)paren
(paren
r_struct
id|Qdisc
op_star
comma
r_void
op_star
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|Qdisc_head
r_struct
id|Qdisc_head
(brace
DECL|member|forw
r_struct
id|Qdisc_head
op_star
id|forw
suffix:semicolon
)brace
suffix:semicolon
r_extern
r_struct
id|Qdisc_head
id|qdisc_head
suffix:semicolon
DECL|struct|Qdisc
r_struct
id|Qdisc
(brace
DECL|member|h
r_struct
id|Qdisc_head
id|h
suffix:semicolon
DECL|member|enqueue
r_int
(paren
op_star
id|enqueue
)paren
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|Qdisc
op_star
id|dev
)paren
suffix:semicolon
DECL|member|dequeue
r_struct
id|sk_buff
op_star
(paren
op_star
id|dequeue
)paren
(paren
r_struct
id|Qdisc
op_star
id|dev
)paren
suffix:semicolon
DECL|member|ops
r_struct
id|Qdisc_ops
op_star
id|ops
suffix:semicolon
DECL|member|handle
r_int
id|handle
suffix:semicolon
DECL|member|parent
r_struct
id|Qdisc
op_star
id|parent
suffix:semicolon
DECL|member|q
r_struct
id|sk_buff_head
id|q
suffix:semicolon
DECL|member|dev
r_struct
id|device
op_star
id|dev
suffix:semicolon
DECL|member|failure_q
r_struct
id|sk_buff_head
id|failure_q
suffix:semicolon
DECL|member|dropped
r_int
r_int
id|dropped
suffix:semicolon
DECL|member|tx_last
r_int
r_int
id|tx_last
suffix:semicolon
DECL|member|tx_timeo
r_int
r_int
id|tx_timeo
suffix:semicolon
DECL|member|data
r_char
id|data
(braket
l_int|0
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Yes, it is slow for [34]86, but we have no choice.&n;   10 msec resolution is appropriate only for bandwidth &lt; 32Kbit/sec.&n;&n;   RULE:&n;   Timer resolution MUST BE &lt; 10% of min_schedulable_packet_size/bandwidth&n;   &n;   Normal IP packet size ~ 512byte, hence:&n;&n;   0.5Kbyte/1Mbyte/sec = 0.5msec, so that we need 50usec timer for&n;   10Mbit ethernet.&n;&n;   10msec resolution -&gt; &lt;50Kbit/sec.&n;   &n;   The result: [34]86 is not good choice for QoS router :-(&n; */
DECL|typedef|psched_time_t
r_typedef
r_struct
id|timeval
id|psched_time_t
suffix:semicolon
multiline_comment|/* On 64bit architecures it would be clever to define:&n;typedef u64 psched_time_t;&n;   and make all this boring arithmetics directly&n; */
macro_line|#ifndef SCHEDULE_ONLY_LOW_BANDWIDTH
DECL|macro|PSCHED_GET_TIME
mdefine_line|#define PSCHED_GET_TIME(stamp) do_gettimeofday(&amp;(stamp))
macro_line|#else
DECL|macro|PSCHED_GET_TIME
mdefine_line|#define PSCHED_GET_TIME(stamp) ((stamp) = xtime)
macro_line|#endif
DECL|macro|PSCHED_TDIFF
mdefine_line|#define PSCHED_TDIFF(tv1, tv2) &bslash;&n;({ &bslash;&n;&t;   int __delta_sec = (tv1).tv_sec - (tv2).tv_sec; &bslash;&n;&t;   int __delta = (tv1).tv_usec - (tv2).tv_usec; &bslash;&n;&t;   if (__delta_sec) { &bslash;&n;&t;           switch (__delta_sec) { &bslash;&n;&t;&t;   default: &bslash;&n;&t;&t;&t;   __delta = 0; &bslash;&n;&t;&t;   case 2: &bslash;&n;&t;&t;&t;   __delta += 1000000; &bslash;&n;&t;&t;   case 1: &bslash;&n;&t;&t;&t;   __delta += 1000000; &bslash;&n;&t;           } &bslash;&n;&t;   } &bslash;&n;&t;   __delta; &bslash;&n;})
DECL|macro|PSCHED_TDIFF_SAFE
mdefine_line|#define PSCHED_TDIFF_SAFE(tv1, tv2, bound, guard) &bslash;&n;({ &bslash;&n;&t;   int __delta_sec = (tv1).tv_sec - (tv2).tv_sec; &bslash;&n;&t;   int __delta = (tv1).tv_usec - (tv2).tv_usec; &bslash;&n;&t;   switch (__delta_sec) { &bslash;&n;&t;   default: &bslash;&n;&t;&t;   __delta = (bound); guard; break; &bslash;&n;&t;   case 2: &bslash;&n;&t;&t;   __delta += 1000000; &bslash;&n;&t;   case 1: &bslash;&n;&t;&t;   __delta += 1000000; &bslash;&n;&t;   case 0: ; &bslash;&n;&t;   } &bslash;&n;&t;   __delta; &bslash;&n;})
DECL|macro|PSCHED_US2JIFFIE
mdefine_line|#define PSCHED_US2JIFFIE(usecs) (((usecs)+(1000000/HZ-1))/(1000000/HZ))
DECL|macro|PSCHED_TLESS
mdefine_line|#define PSCHED_TLESS(tv1, tv2) (((tv1).tv_usec &lt; (tv2).tv_usec &amp;&amp; &bslash;&n;&t;&t;&t;&t;(tv1).tv_sec &lt; (tv2).tv_sec) || &bslash;&n;&t;&t;&t;&t; (tv1).tv_sec &lt; (tv2).tv_sec)
DECL|macro|PSCHED_TADD2
mdefine_line|#define PSCHED_TADD2(tv, delta, tv_res) &bslash;&n;({ &bslash;&n;&t;   int __delta = (tv).tv_usec + (delta); &bslash;&n;&t;   (tv_res).tv_sec = (tv).tv_sec; &bslash;&n;&t;   if (__delta &gt; 1000000) { (tv_res).tv_sec++; __delta -= 1000000; } &bslash;&n;&t;   (tv_res).tv_sec = __delta; &bslash;&n;})
DECL|macro|PSCHED_TADD
mdefine_line|#define PSCHED_TADD(tv, delta) &bslash;&n;({ &bslash;&n;&t;   (tv).tv_usec += (delta); &bslash;&n;&t;   if ((tv).tv_usec &gt; 1000000) { (tv).tv_sec++; &bslash;&n;&t;&t; (tv).tv_usec -= 1000000; } &bslash;&n;})
multiline_comment|/* Set/check that undertime is in the &quot;past perfect&quot;;&n;   it depends on concrete representation of system time&n; */
DECL|macro|PSCHED_SET_PASTPERFECT
mdefine_line|#define PSCHED_SET_PASTPERFECT(t)&t;((t).tv_sec = 0)
DECL|macro|PSCHED_IS_PASTPERFECT
mdefine_line|#define PSCHED_IS_PASTPERFECT(t)&t;((t).tv_sec == 0)
r_extern
r_struct
id|Qdisc
id|noop_qdisc
suffix:semicolon
r_int
id|register_qdisc
c_func
(paren
r_struct
id|Qdisc_ops
op_star
id|qops
)paren
suffix:semicolon
r_int
id|unregister_qdisc
c_func
(paren
r_struct
id|Qdisc_ops
op_star
id|qops
)paren
suffix:semicolon
r_void
id|dev_init_scheduler
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_void
id|dev_shutdown
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_void
id|dev_activate
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_void
id|dev_deactivate
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
r_void
id|qdisc_reset
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
)paren
suffix:semicolon
r_void
id|qdisc_destroy
c_func
(paren
r_struct
id|Qdisc
op_star
id|qdisc
)paren
suffix:semicolon
r_int
id|pktsched_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|qdisc_run_queues
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|qdisc_restart
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
suffix:semicolon
DECL|function|qdisc_wakeup
r_extern
id|__inline__
r_void
id|qdisc_wakeup
c_func
(paren
r_struct
id|device
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;tbusy
)paren
(brace
r_struct
id|Qdisc
op_star
id|q
op_assign
id|dev-&gt;qdisc
suffix:semicolon
r_if
c_cond
(paren
id|qdisc_restart
c_func
(paren
id|dev
)paren
op_logical_and
id|q-&gt;h.forw
op_eq
l_int|NULL
)paren
(brace
id|q-&gt;h.forw
op_assign
id|qdisc_head.forw
suffix:semicolon
id|qdisc_head.forw
op_assign
op_amp
id|q-&gt;h
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
eof
