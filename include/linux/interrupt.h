multiline_comment|/* interrupt.h */
macro_line|#ifndef _LINUX_INTERRUPT_H
DECL|macro|_LINUX_INTERRUPT_H
mdefine_line|#define _LINUX_INTERRUPT_H
macro_line|#include &lt;linux/linkage.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
DECL|struct|bh_struct
r_struct
id|bh_struct
(brace
DECL|member|routine
r_void
(paren
op_star
id|routine
)paren
(paren
r_void
op_star
)paren
suffix:semicolon
DECL|member|data
r_void
op_star
id|data
suffix:semicolon
)brace
suffix:semicolon
r_extern
r_int
r_int
id|bh_active
suffix:semicolon
r_extern
r_int
r_int
id|bh_mask
suffix:semicolon
r_extern
r_struct
id|bh_struct
id|bh_base
(braket
l_int|32
)braket
suffix:semicolon
id|asmlinkage
r_void
id|do_bottom_half
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Who gets which entry in bh_base.  Things which will occur most often&n;   should come first - in which case NET should be up the top with SERIAL/TQUEUE! */
r_enum
(brace
DECL|enumerator|TIMER_BH
id|TIMER_BH
op_assign
l_int|0
comma
DECL|enumerator|CONSOLE_BH
id|CONSOLE_BH
comma
DECL|enumerator|TQUEUE_BH
id|TQUEUE_BH
comma
DECL|enumerator|SERIAL_BH
id|SERIAL_BH
comma
DECL|enumerator|NET_BH
id|NET_BH
comma
DECL|enumerator|IMMEDIATE_BH
id|IMMEDIATE_BH
comma
DECL|enumerator|KEYBOARD_BH
id|KEYBOARD_BH
comma
DECL|enumerator|CYCLADES_BH
id|CYCLADES_BH
comma
DECL|enumerator|CM206_BH
id|CM206_BH
)brace
suffix:semicolon
DECL|function|mark_bh
r_extern
r_inline
r_void
id|mark_bh
c_func
(paren
r_int
id|nr
)paren
(brace
id|set_bit
c_func
(paren
id|nr
comma
op_amp
id|bh_active
)paren
suffix:semicolon
)brace
DECL|function|disable_bh
r_extern
r_inline
r_void
id|disable_bh
c_func
(paren
r_int
id|nr
)paren
(brace
id|clear_bit
c_func
(paren
id|nr
comma
op_amp
id|bh_mask
)paren
suffix:semicolon
)brace
DECL|function|enable_bh
r_extern
r_inline
r_void
id|enable_bh
c_func
(paren
r_int
id|nr
)paren
(brace
id|set_bit
c_func
(paren
id|nr
comma
op_amp
id|bh_mask
)paren
suffix:semicolon
)brace
DECL|function|start_bh_atomic
r_extern
r_inline
r_void
id|start_bh_atomic
c_func
(paren
r_void
)paren
(brace
id|intr_count
op_increment
suffix:semicolon
)brace
DECL|function|end_bh_atomic
r_extern
r_inline
r_void
id|end_bh_atomic
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|intr_count
op_eq
l_int|1
op_logical_and
(paren
id|bh_active
op_amp
id|bh_mask
)paren
)paren
id|do_bottom_half
c_func
(paren
)paren
suffix:semicolon
id|intr_count
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n; * Autoprobing for irqs:&n; *&n; * probe_irq_on() and probe_irq_off() provide robust primitives&n; * for accurate IRQ probing during kernel initialization.  They are&n; * reasonably simple to use, are not &quot;fooled&quot; by spurious interrupts,&n; * and, unlike other attempts at IRQ probing, they do not get hung on&n; * stuck interrupts (such as unused PS2 mouse interfaces on ASUS boards).&n; *&n; * For reasonably foolproof probing, use them as follows:&n; *&n; * 1. clear and/or mask the device&squot;s internal interrupt.&n; * 2. sti();&n; * 3. irqs = probe_irq_on();      // &quot;take over&quot; all unassigned idle IRQs&n; * 4. enable the device and cause it to trigger an interrupt.&n; * 5. wait for the device to interrupt, using non-intrusive polling or a delay.&n; * 6. irq = probe_irq_off(irqs);  // get IRQ number, 0=none, negative=multiple&n; * 7. service the device to clear its pending interrupt.&n; * 8. loop again if paranoia is required.&n; *&n; * probe_irq_on() returns a mask of snarfed irq&squot;s.&n; *&n; * probe_irq_off() takes the mask as a parameter,&n; * and returns the irq number which occurred,&n; * or zero if none occurred, or a negative irq number&n; * if more than one irq occurred.&n; */
r_extern
r_int
r_int
id|probe_irq_on
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* returns 0 on failure */
r_extern
r_int
id|probe_irq_off
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* returns 0 or negative on failure */
macro_line|#endif
eof
