multiline_comment|/* interrupt.h */
macro_line|#ifndef _LINUX_INTERRUPT_H
DECL|macro|_LINUX_INTERRUPT_H
mdefine_line|#define _LINUX_INTERRUPT_H
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
DECL|struct|irqaction
r_struct
id|irqaction
(brace
DECL|member|handler
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|mask
r_int
r_int
id|mask
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|dev_id
r_void
op_star
id|dev_id
suffix:semicolon
DECL|member|next
r_struct
id|irqaction
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
r_extern
r_volatile
r_int
r_char
id|bh_running
suffix:semicolon
r_extern
r_int
id|bh_mask_count
(braket
l_int|32
)braket
suffix:semicolon
r_extern
r_int
r_int
id|bh_active
suffix:semicolon
r_extern
r_int
r_int
id|bh_mask
suffix:semicolon
r_extern
r_void
(paren
op_star
id|bh_base
(braket
l_int|32
)braket
)paren
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|do_bottom_half
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Who gets which entry in bh_base.  Things which will occur most often&n;   should come first - in which case NET should be up the top with SERIAL/TQUEUE! */
r_enum
(brace
DECL|enumerator|TIMER_BH
id|TIMER_BH
op_assign
l_int|0
comma
DECL|enumerator|CONSOLE_BH
id|CONSOLE_BH
comma
DECL|enumerator|TQUEUE_BH
id|TQUEUE_BH
comma
DECL|enumerator|DIGI_BH
id|DIGI_BH
comma
DECL|enumerator|SERIAL_BH
id|SERIAL_BH
comma
DECL|enumerator|RISCOM8_BH
id|RISCOM8_BH
comma
DECL|enumerator|SPECIALIX_BH
id|SPECIALIX_BH
comma
DECL|enumerator|ESP_BH
id|ESP_BH
comma
DECL|enumerator|NET_BH
id|NET_BH
comma
DECL|enumerator|SCSI_BH
id|SCSI_BH
comma
DECL|enumerator|IMMEDIATE_BH
id|IMMEDIATE_BH
comma
DECL|enumerator|KEYBOARD_BH
id|KEYBOARD_BH
comma
DECL|enumerator|CYCLADES_BH
id|CYCLADES_BH
comma
DECL|enumerator|CM206_BH
id|CM206_BH
comma
DECL|enumerator|JS_BH
id|JS_BH
)brace
suffix:semicolon
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#include &lt;asm/softirq.h&gt;
multiline_comment|/*&n; * Autoprobing for irqs:&n; *&n; * probe_irq_on() and probe_irq_off() provide robust primitives&n; * for accurate IRQ probing during kernel initialization.  They are&n; * reasonably simple to use, are not &quot;fooled&quot; by spurious interrupts,&n; * and, unlike other attempts at IRQ probing, they do not get hung on&n; * stuck interrupts (such as unused PS2 mouse interfaces on ASUS boards).&n; *&n; * For reasonably foolproof probing, use them as follows:&n; *&n; * 1. clear and/or mask the device&squot;s internal interrupt.&n; * 2. sti();&n; * 3. irqs = probe_irq_on();      // &quot;take over&quot; all unassigned idle IRQs&n; * 4. enable the device and cause it to trigger an interrupt.&n; * 5. wait for the device to interrupt, using non-intrusive polling or a delay.&n; * 6. irq = probe_irq_off(irqs);  // get IRQ number, 0=none, negative=multiple&n; * 7. service the device to clear its pending interrupt.&n; * 8. loop again if paranoia is required.&n; *&n; * probe_irq_on() returns a mask of allocated irq&squot;s.&n; *&n; * probe_irq_off() takes the mask as a parameter,&n; * and returns the irq number which occurred,&n; * or zero if none occurred, or a negative irq number&n; * if more than one irq occurred.&n; */
r_extern
r_int
r_int
id|probe_irq_on
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* returns 0 on failure */
r_extern
r_int
id|probe_irq_off
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* returns 0 or negative on failure */
macro_line|#endif
eof
