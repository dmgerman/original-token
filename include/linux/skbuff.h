multiline_comment|/*&n; *&t;Definitions for the &squot;struct sk_buff&squot; memory handlers.&n; *&n; *&t;Authors:&n; *&t;&t;Alan Cox, &lt;gw4pts@gw4pts.ampr.org&gt;&n; *&t;&t;Florian La Roche, &lt;rzsfl@rz.uni-sb.de&gt;&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License&n; *&t;as published by the Free Software Foundation; either version&n; *&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#ifndef _LINUX_SKBUFF_H
DECL|macro|_LINUX_SKBUFF_H
mdefine_line|#define _LINUX_SKBUFF_H
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/types.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
DECL|macro|HAVE_ALLOC_SKB
mdefine_line|#define HAVE_ALLOC_SKB&t;&t;/* For the drivers to know */
DECL|macro|HAVE_ALIGNABLE_SKB
mdefine_line|#define HAVE_ALIGNABLE_SKB&t;/* Ditto 8)&t;&t;   */
DECL|macro|SLAB_SKB
mdefine_line|#define SLAB_SKB &t;&t;/* Slabified skbuffs &t;   */
DECL|macro|CHECKSUM_NONE
mdefine_line|#define CHECKSUM_NONE 0
DECL|macro|CHECKSUM_HW
mdefine_line|#define CHECKSUM_HW 1
DECL|macro|CHECKSUM_UNNECESSARY
mdefine_line|#define CHECKSUM_UNNECESSARY 2
macro_line|#ifdef __i386__
DECL|macro|NET_CALLER
mdefine_line|#define NET_CALLER(arg) (*(((void**)&amp;arg)-1))
macro_line|#else
DECL|macro|NET_CALLER
mdefine_line|#define NET_CALLER(arg) __builtin_return_address(0)
macro_line|#endif
macro_line|#ifdef CONFIG_NETFILTER
DECL|struct|nf_conntrack
r_struct
id|nf_conntrack
(brace
DECL|member|use
id|atomic_t
id|use
suffix:semicolon
DECL|member|destroy
r_void
(paren
op_star
id|destroy
)paren
(paren
r_struct
id|nf_conntrack
op_star
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|nf_ct_info
r_struct
id|nf_ct_info
(brace
DECL|member|master
r_struct
id|nf_conntrack
op_star
id|master
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
DECL|struct|sk_buff_head
r_struct
id|sk_buff_head
(brace
multiline_comment|/* These two members must be first. */
DECL|member|next
r_struct
id|sk_buff
op_star
id|next
suffix:semicolon
DECL|member|prev
r_struct
id|sk_buff
op_star
id|prev
suffix:semicolon
DECL|member|qlen
id|__u32
id|qlen
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|sk_buff
r_struct
id|sk_buff
(brace
multiline_comment|/* These two members must be first. */
DECL|member|next
r_struct
id|sk_buff
op_star
id|next
suffix:semicolon
multiline_comment|/* Next buffer in list &t;&t;&t;&t;*/
DECL|member|prev
r_struct
id|sk_buff
op_star
id|prev
suffix:semicolon
multiline_comment|/* Previous buffer in list &t;&t;&t;*/
DECL|member|list
r_struct
id|sk_buff_head
op_star
id|list
suffix:semicolon
multiline_comment|/* List we are on&t;&t;&t;&t;*/
DECL|member|sk
r_struct
id|sock
op_star
id|sk
suffix:semicolon
multiline_comment|/* Socket we are owned by &t;&t;&t;*/
DECL|member|stamp
r_struct
id|timeval
id|stamp
suffix:semicolon
multiline_comment|/* Time we arrived&t;&t;&t;&t;*/
DECL|member|dev
r_struct
id|net_device
op_star
id|dev
suffix:semicolon
multiline_comment|/* Device we arrived on/are leaving by&t;&t;*/
multiline_comment|/* Transport layer header */
r_union
(brace
DECL|member|th
r_struct
id|tcphdr
op_star
id|th
suffix:semicolon
DECL|member|uh
r_struct
id|udphdr
op_star
id|uh
suffix:semicolon
DECL|member|icmph
r_struct
id|icmphdr
op_star
id|icmph
suffix:semicolon
DECL|member|igmph
r_struct
id|igmphdr
op_star
id|igmph
suffix:semicolon
DECL|member|ipiph
r_struct
id|iphdr
op_star
id|ipiph
suffix:semicolon
DECL|member|spxh
r_struct
id|spxhdr
op_star
id|spxh
suffix:semicolon
DECL|member|raw
r_int
r_char
op_star
id|raw
suffix:semicolon
DECL|member|h
)brace
id|h
suffix:semicolon
multiline_comment|/* Network layer header */
r_union
(brace
DECL|member|iph
r_struct
id|iphdr
op_star
id|iph
suffix:semicolon
DECL|member|ipv6h
r_struct
id|ipv6hdr
op_star
id|ipv6h
suffix:semicolon
DECL|member|arph
r_struct
id|arphdr
op_star
id|arph
suffix:semicolon
DECL|member|ipxh
r_struct
id|ipxhdr
op_star
id|ipxh
suffix:semicolon
DECL|member|raw
r_int
r_char
op_star
id|raw
suffix:semicolon
DECL|member|nh
)brace
id|nh
suffix:semicolon
multiline_comment|/* Link layer header */
r_union
(brace
DECL|member|ethernet
r_struct
id|ethhdr
op_star
id|ethernet
suffix:semicolon
DECL|member|raw
r_int
r_char
op_star
id|raw
suffix:semicolon
DECL|member|mac
)brace
id|mac
suffix:semicolon
DECL|member|dst
r_struct
id|dst_entry
op_star
id|dst
suffix:semicolon
multiline_comment|/* &n;&t; * This is the control buffer. It is free to use for every&n;&t; * layer. Please put your private variables there. If you&n;&t; * want to keep them across layers you have to do a skb_clone()&n;&t; * first. This is owned by whoever has the skb queued ATM.&n;&t; */
DECL|member|cb
r_char
id|cb
(braket
l_int|48
)braket
suffix:semicolon
DECL|member|len
r_int
r_int
id|len
suffix:semicolon
multiline_comment|/* Length of actual data&t;&t;&t;*/
DECL|member|csum
r_int
r_int
id|csum
suffix:semicolon
multiline_comment|/* Checksum &t;&t;&t;&t;&t;*/
DECL|member|used
r_volatile
r_char
id|used
suffix:semicolon
multiline_comment|/* Data moved to user and not MSG_PEEK&t;&t;*/
DECL|member|cloned
r_int
r_char
id|cloned
comma
multiline_comment|/* head may be cloned (check refcnt to be sure). */
DECL|member|pkt_type
id|pkt_type
comma
multiline_comment|/* Packet class&t;&t;&t;&t;&t;*/
DECL|member|ip_summed
id|ip_summed
suffix:semicolon
multiline_comment|/* Driver fed us an IP checksum&t;&t;&t;*/
DECL|member|priority
id|__u32
id|priority
suffix:semicolon
multiline_comment|/* Packet queueing priority&t;&t;&t;*/
DECL|member|users
id|atomic_t
id|users
suffix:semicolon
multiline_comment|/* User count - see datagram.c,tcp.c &t;&t;*/
DECL|member|protocol
r_int
r_int
id|protocol
suffix:semicolon
multiline_comment|/* Packet protocol from driver. &t;&t;*/
DECL|member|security
r_int
r_int
id|security
suffix:semicolon
multiline_comment|/* Security level of packet&t;&t;&t;*/
DECL|member|truesize
r_int
r_int
id|truesize
suffix:semicolon
multiline_comment|/* Buffer size &t;&t;&t;&t;&t;*/
DECL|member|head
r_int
r_char
op_star
id|head
suffix:semicolon
multiline_comment|/* Head of buffer &t;&t;&t;&t;*/
DECL|member|data
r_int
r_char
op_star
id|data
suffix:semicolon
multiline_comment|/* Data head pointer&t;&t;&t;&t;*/
DECL|member|tail
r_int
r_char
op_star
id|tail
suffix:semicolon
multiline_comment|/* Tail pointer&t;&t;&t;&t;&t;*/
DECL|member|end
r_int
r_char
op_star
id|end
suffix:semicolon
multiline_comment|/* End pointer&t;&t;&t;&t;&t;*/
DECL|member|destructor
r_void
(paren
op_star
id|destructor
)paren
(paren
r_struct
id|sk_buff
op_star
)paren
suffix:semicolon
multiline_comment|/* Destruct function&t;&t;*/
macro_line|#ifdef CONFIG_NETFILTER
multiline_comment|/* Can be used for communication between hooks. */
DECL|member|nfmark
r_int
r_int
id|nfmark
suffix:semicolon
multiline_comment|/* Cache info */
DECL|member|nfcache
id|__u32
id|nfcache
suffix:semicolon
multiline_comment|/* Associated connection, if any */
DECL|member|nfct
r_struct
id|nf_ct_info
op_star
id|nfct
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER_DEBUG
DECL|member|nf_debug
r_int
r_int
id|nf_debug
suffix:semicolon
macro_line|#endif
macro_line|#endif /*CONFIG_NETFILTER*/
macro_line|#if defined(CONFIG_HIPPI)
(def_block
r_union
(brace
DECL|member|ifield
id|__u32
id|ifield
suffix:semicolon
DECL|member|private
)brace
)def_block
r_private
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_NET_SCHED
DECL|member|tc_index
id|__u32
id|tc_index
suffix:semicolon
multiline_comment|/* traffic control index */
macro_line|#endif
)brace
suffix:semicolon
DECL|macro|SK_WMEM_MAX
mdefine_line|#define SK_WMEM_MAX&t;65535
DECL|macro|SK_RMEM_MAX
mdefine_line|#define SK_RMEM_MAX&t;65535
macro_line|#ifdef __KERNEL__
multiline_comment|/*&n; *&t;Handling routines are only of interest to the kernel&n; */
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/system.h&gt;
r_extern
r_void
id|__kfree_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|skb_peek_copy
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|alloc_skb
c_func
(paren
r_int
r_int
id|size
comma
r_int
id|priority
)paren
suffix:semicolon
r_extern
r_void
id|kfree_skbmem
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|skb_clone
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|priority
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|skb_copy
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|priority
)paren
suffix:semicolon
r_extern
r_struct
id|sk_buff
op_star
id|skb_copy_expand
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|newheadroom
comma
r_int
id|newtailroom
comma
r_int
id|priority
)paren
suffix:semicolon
DECL|macro|dev_kfree_skb
mdefine_line|#define dev_kfree_skb(a)&t;kfree_skb(a)
r_extern
r_void
id|skb_over_panic
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|len
comma
r_void
op_star
id|here
)paren
suffix:semicolon
r_extern
r_void
id|skb_under_panic
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|len
comma
r_void
op_star
id|here
)paren
suffix:semicolon
multiline_comment|/* Backwards compatibility */
DECL|macro|skb_realloc_headroom
mdefine_line|#define skb_realloc_headroom(skb, nhr) skb_copy_expand(skb, nhr, skb_tailroom(skb), GFP_ATOMIC)
multiline_comment|/* Internal */
DECL|function|skb_datarefp
r_static
r_inline
id|atomic_t
op_star
id|skb_datarefp
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
(paren
id|atomic_t
op_star
)paren
(paren
id|skb-&gt;end
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_queue_empty - check if a queue is empty&n; *&t;@list: queue head&n; *&n; *&t;Returns true if the queue is empty, false otherwise.&n; */
DECL|function|skb_queue_empty
r_static
r_inline
r_int
id|skb_queue_empty
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_return
(paren
id|list-&gt;next
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_get - reference buffer&n; *&t;@skb: buffer to reference&n; *&n; *&t;Makes another reference to a socket buffer and returns a pointer&n; *&t;to the buffer.&n; */
DECL|function|skb_get
r_static
r_inline
r_struct
id|sk_buff
op_star
id|skb_get
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|skb-&gt;users
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/*&n; * If users==1, we are the only owner and are can avoid redundant&n; * atomic change.&n; */
multiline_comment|/**&n; *&t;kfree_skb - free an sk_buff&n; *&t;@skb: buffer to free&n; *&n; *&t;Drop a reference to the buffer and free it if the usage count has&n; *&t;hit zero.&n; */
DECL|function|kfree_skb
r_static
r_inline
r_void
id|kfree_skb
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|skb-&gt;users
)paren
op_eq
l_int|1
op_logical_or
id|atomic_dec_and_test
c_func
(paren
op_amp
id|skb-&gt;users
)paren
)paren
id|__kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/* Use this if you didn&squot;t touch the skb state [for fast switching] */
DECL|function|kfree_skb_fast
r_static
r_inline
r_void
id|kfree_skb_fast
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|skb-&gt;users
)paren
op_eq
l_int|1
op_logical_or
id|atomic_dec_and_test
c_func
(paren
op_amp
id|skb-&gt;users
)paren
)paren
id|kfree_skbmem
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_cloned - is the buffer a clone&n; *&t;@skb: buffer to check&n; *&n; *&t;Returns true if the buffer was generated with skb_clone() and is&n; *&t;one of multiple shared copies of the buffer. Cloned buffers are&n; *&t;shared data so must not be written to under normal circumstances.&n; */
DECL|function|skb_cloned
r_static
r_inline
r_int
id|skb_cloned
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
id|skb-&gt;cloned
op_logical_and
id|atomic_read
c_func
(paren
id|skb_datarefp
c_func
(paren
id|skb
)paren
)paren
op_ne
l_int|1
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_shared - is the buffer shared&n; *&t;@skb: buffer to check&n; *&n; *&t;Returns true if more than one person has a reference to this&n; *&t;buffer.&n; */
DECL|function|skb_shared
r_static
r_inline
r_int
id|skb_shared
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
(paren
id|atomic_read
c_func
(paren
op_amp
id|skb-&gt;users
)paren
op_ne
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/** &n; *&t;skb_share_check - check if buffer is shared and if so clone it&n; *&t;@skb: buffer to check&n; *&t;@pri: priority for memory allocation&n; *&t;&n; *&t;If the buffer is shared the buffer is cloned and the old copy&n; *&t;drops a reference. A new clone with a single reference is returned.&n; *&t;If the buffer is not shared the original buffer is returned. When&n; *&t;being called from interrupt status or with spinlocks held pri must&n; *&t;be GFP_ATOMIC.&n; *&n; *&t;NULL is returned on a memory allocation failure.&n; */
DECL|function|skb_share_check
r_static
r_inline
r_struct
id|sk_buff
op_star
id|skb_share_check
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|pri
)paren
(brace
r_if
c_cond
(paren
id|skb_shared
c_func
(paren
id|skb
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|nskb
suffix:semicolon
id|nskb
op_assign
id|skb_clone
c_func
(paren
id|skb
comma
id|pri
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
r_return
id|nskb
suffix:semicolon
)brace
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Copy shared buffers into a new sk_buff. We effectively do COW on&n; *&t;packets to handle cases where we have a local reader and forward&n; *&t;and a couple of other messy ones. The normal one is tcpdumping&n; *&t;a packet thats being forwarded.&n; */
multiline_comment|/**&n; *&t;skb_unshare - make a copy of a shared buffer&n; *&t;@skb: buffer to check&n; *&t;@pri: priority for memory allocation&n; *&n; *&t;If the socket buffer is a clone then this function creates a new&n; *&t;copy of the data, drops a reference count on the old copy and returns&n; *&t;the new copy with the reference count at 1. If the buffer is not a clone&n; *&t;the original buffer is returned. When called with a spinlock held or&n; *&t;from interrupt state @pri must be %GFP_ATOMIC&n; *&n; *&t;%NULL is returned on a memory allocation failure.&n; */
DECL|function|skb_unshare
r_static
r_inline
r_struct
id|sk_buff
op_star
id|skb_unshare
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
id|pri
)paren
(brace
r_struct
id|sk_buff
op_star
id|nskb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|skb_cloned
c_func
(paren
id|skb
)paren
)paren
(brace
r_return
id|skb
suffix:semicolon
)brace
id|nskb
op_assign
id|skb_copy
c_func
(paren
id|skb
comma
id|pri
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
multiline_comment|/* Free our shared copy */
r_return
id|nskb
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_peek&n; *&t;@list_: list to peek at&n; *&n; *&t;Peek an &amp;sk_buff. Unlike most other operations you _MUST_&n; *&t;be careful with this one. A peek leaves the buffer on the&n; *&t;list and someone else may run off with it. You must hold&n; *&t;the appropriate locks or have a private queue to do this.&n; *&n; *&t;Returns %NULL for an empty list or a pointer to the head element.&n; *&t;The reference count is not incremented and the reference is therefore&n; *&t;volatile. Use with caution.&n; */
DECL|function|skb_peek
r_static
r_inline
r_struct
id|sk_buff
op_star
id|skb_peek
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list_
)paren
(brace
r_struct
id|sk_buff
op_star
id|list
op_assign
(paren
(paren
r_struct
id|sk_buff
op_star
)paren
id|list_
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_if
c_cond
(paren
id|list
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
id|list_
)paren
id|list
op_assign
l_int|NULL
suffix:semicolon
r_return
id|list
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_peek_tail&n; *&t;@list_: list to peek at&n; *&n; *&t;Peek an &amp;sk_buff. Unlike most other operations you _MUST_&n; *&t;be careful with this one. A peek leaves the buffer on the&n; *&t;list and someone else may run off with it. You must hold&n; *&t;the appropriate locks or have a private queue to do this.&n; *&n; *&t;Returns %NULL for an empty list or a pointer to the tail element.&n; *&t;The reference count is not incremented and the reference is therefore&n; *&t;volatile. Use with caution.&n; */
DECL|function|skb_peek_tail
r_static
r_inline
r_struct
id|sk_buff
op_star
id|skb_peek_tail
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list_
)paren
(brace
r_struct
id|sk_buff
op_star
id|list
op_assign
(paren
(paren
r_struct
id|sk_buff
op_star
)paren
id|list_
)paren
op_member_access_from_pointer
id|prev
suffix:semicolon
r_if
c_cond
(paren
id|list
op_eq
(paren
r_struct
id|sk_buff
op_star
)paren
id|list_
)paren
id|list
op_assign
l_int|NULL
suffix:semicolon
r_return
id|list
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_queue_len&t;- get queue length&n; *&t;@list_: list to measure&n; *&n; *&t;Return the length of an &amp;sk_buff queue. &n; */
DECL|function|skb_queue_len
r_static
r_inline
id|__u32
id|skb_queue_len
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list_
)paren
(brace
r_return
id|list_-&gt;qlen
suffix:semicolon
)brace
DECL|function|skb_queue_head_init
r_static
r_inline
r_void
id|skb_queue_head_init
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
id|spin_lock_init
c_func
(paren
op_amp
id|list-&gt;lock
)paren
suffix:semicolon
id|list-&gt;prev
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
suffix:semicolon
id|list-&gt;next
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
suffix:semicolon
id|list-&gt;qlen
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Insert an sk_buff at the start of a list.&n; *&n; *&t;The &quot;__skb_xxxx()&quot; functions are the non-atomic ones that&n; *&t;can only be called with interrupts disabled.&n; */
multiline_comment|/**&n; *&t;__skb_queue_head - queue a buffer at the list head&n; *&t;@list: list to use&n; *&t;@newsk: buffer to queue&n; *&n; *&t;Queue a buffer at the start of a list. This function takes no locks&n; *&t;and you must therefore hold required locks before calling it.&n; *&n; *&t;A buffer cannot be placed on two lists at the same time.&n; */
DECL|function|__skb_queue_head
r_static
r_inline
r_void
id|__skb_queue_head
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_struct
id|sk_buff
op_star
id|prev
comma
op_star
id|next
suffix:semicolon
id|newsk-&gt;list
op_assign
id|list
suffix:semicolon
id|list-&gt;qlen
op_increment
suffix:semicolon
id|prev
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
suffix:semicolon
id|next
op_assign
id|prev-&gt;next
suffix:semicolon
id|newsk-&gt;next
op_assign
id|next
suffix:semicolon
id|newsk-&gt;prev
op_assign
id|prev
suffix:semicolon
id|next-&gt;prev
op_assign
id|newsk
suffix:semicolon
id|prev-&gt;next
op_assign
id|newsk
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_queue_head - queue a buffer at the list head&n; *&t;@list: list to use&n; *&t;@newsk: buffer to queue&n; *&n; *&t;Queue a buffer at the start of the list. This function takes the&n; *&t;list lock and can be used safely with other locking &amp;sk_buff functions&n; *&t;safely.&n; *&n; *&t;A buffer cannot be placed on two lists at the same time.&n; */
DECL|function|skb_queue_head
r_static
r_inline
r_void
id|skb_queue_head
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__skb_queue_head
c_func
(paren
id|list
comma
id|newsk
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;__skb_queue_tail - queue a buffer at the list tail&n; *&t;@list: list to use&n; *&t;@newsk: buffer to queue&n; *&n; *&t;Queue a buffer at the end of a list. This function takes no locks&n; *&t;and you must therefore hold required locks before calling it.&n; *&n; *&t;A buffer cannot be placed on two lists at the same time.&n; */
DECL|function|__skb_queue_tail
r_static
r_inline
r_void
id|__skb_queue_tail
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_struct
id|sk_buff
op_star
id|prev
comma
op_star
id|next
suffix:semicolon
id|newsk-&gt;list
op_assign
id|list
suffix:semicolon
id|list-&gt;qlen
op_increment
suffix:semicolon
id|next
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
suffix:semicolon
id|prev
op_assign
id|next-&gt;prev
suffix:semicolon
id|newsk-&gt;next
op_assign
id|next
suffix:semicolon
id|newsk-&gt;prev
op_assign
id|prev
suffix:semicolon
id|next-&gt;prev
op_assign
id|newsk
suffix:semicolon
id|prev-&gt;next
op_assign
id|newsk
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_queue_tail - queue a buffer at the list tail&n; *&t;@list: list to use&n; *&t;@newsk: buffer to queue&n; *&n; *&t;Queue a buffer at the tail of the list. This function takes the&n; *&t;list lock and can be used safely with other locking &amp;sk_buff functions&n; *&t;safely.&n; *&n; *&t;A buffer cannot be placed on two lists at the same time.&n; */
DECL|function|skb_queue_tail
r_static
r_inline
r_void
id|skb_queue_tail
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__skb_queue_tail
c_func
(paren
id|list
comma
id|newsk
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;__skb_dequeue - remove from the head of the queue&n; *&t;@list: list to dequeue from&n; *&n; *&t;Remove the head of the list. This function does not take any locks&n; *&t;so must be used with appropriate locks held only. The head item is&n; *&t;returned or %NULL if the list is empty.&n; */
DECL|function|__skb_dequeue
r_static
r_inline
r_struct
id|sk_buff
op_star
id|__skb_dequeue
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_struct
id|sk_buff
op_star
id|next
comma
op_star
id|prev
comma
op_star
id|result
suffix:semicolon
id|prev
op_assign
(paren
r_struct
id|sk_buff
op_star
)paren
id|list
suffix:semicolon
id|next
op_assign
id|prev-&gt;next
suffix:semicolon
id|result
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|next
op_ne
id|prev
)paren
(brace
id|result
op_assign
id|next
suffix:semicolon
id|next
op_assign
id|next-&gt;next
suffix:semicolon
id|list-&gt;qlen
op_decrement
suffix:semicolon
id|next-&gt;prev
op_assign
id|prev
suffix:semicolon
id|prev-&gt;next
op_assign
id|next
suffix:semicolon
id|result-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|result-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|result-&gt;list
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_dequeue - remove from the head of the queue&n; *&t;@list: list to dequeue from&n; *&n; *&t;Remove the head of the list. The list lock is taken so the function&n; *&t;may be used safely with other locking list functions. The head item is&n; *&t;returned or %NULL if the list is empty.&n; */
DECL|function|skb_dequeue
r_static
r_inline
r_struct
id|sk_buff
op_star
id|skb_dequeue
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_int
id|flags
suffix:semicolon
r_struct
id|sk_buff
op_star
id|result
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|result
op_assign
id|__skb_dequeue
c_func
(paren
id|list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Insert a packet on a list.&n; */
DECL|function|__skb_insert
r_static
r_inline
r_void
id|__skb_insert
c_func
(paren
r_struct
id|sk_buff
op_star
id|newsk
comma
r_struct
id|sk_buff
op_star
id|prev
comma
r_struct
id|sk_buff
op_star
id|next
comma
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
id|newsk-&gt;next
op_assign
id|next
suffix:semicolon
id|newsk-&gt;prev
op_assign
id|prev
suffix:semicolon
id|next-&gt;prev
op_assign
id|newsk
suffix:semicolon
id|prev-&gt;next
op_assign
id|newsk
suffix:semicolon
id|newsk-&gt;list
op_assign
id|list
suffix:semicolon
id|list-&gt;qlen
op_increment
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_insert&t;-&t;insert a buffer&n; *&t;@old: buffer to insert before&n; *&t;@newsk: buffer to insert&n; *&n; *&t;Place a packet before a given packet in a list. The list locks are taken&n; *&t;and this function is atomic with respect to other list locked calls&n; *&t;A buffer cannot be placed on two lists at the same time.&n; */
DECL|function|skb_insert
r_static
r_inline
r_void
id|skb_insert
c_func
(paren
r_struct
id|sk_buff
op_star
id|old
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|old-&gt;list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__skb_insert
c_func
(paren
id|newsk
comma
id|old-&gt;prev
comma
id|old
comma
id|old-&gt;list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|old-&gt;list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Place a packet after a given packet in a list.&n; */
DECL|function|__skb_append
r_static
r_inline
r_void
id|__skb_append
c_func
(paren
r_struct
id|sk_buff
op_star
id|old
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
id|__skb_insert
c_func
(paren
id|newsk
comma
id|old
comma
id|old-&gt;next
comma
id|old-&gt;list
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_append&t;-&t;append a buffer&n; *&t;@old: buffer to insert after&n; *&t;@newsk: buffer to insert&n; *&n; *&t;Place a packet after a given packet in a list. The list locks are taken&n; *&t;and this function is atomic with respect to other list locked calls.&n; *&t;A buffer cannot be placed on two lists at the same time.&n; */
DECL|function|skb_append
r_static
r_inline
r_void
id|skb_append
c_func
(paren
r_struct
id|sk_buff
op_star
id|old
comma
r_struct
id|sk_buff
op_star
id|newsk
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|old-&gt;list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__skb_append
c_func
(paren
id|old
comma
id|newsk
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|old-&gt;list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * remove sk_buff from list. _Must_ be called atomically, and with&n; * the list known..&n; */
DECL|function|__skb_unlink
r_static
r_inline
r_void
id|__skb_unlink
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_struct
id|sk_buff
op_star
id|next
comma
op_star
id|prev
suffix:semicolon
id|list-&gt;qlen
op_decrement
suffix:semicolon
id|next
op_assign
id|skb-&gt;next
suffix:semicolon
id|prev
op_assign
id|skb-&gt;prev
suffix:semicolon
id|skb-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;list
op_assign
l_int|NULL
suffix:semicolon
id|next-&gt;prev
op_assign
id|prev
suffix:semicolon
id|prev-&gt;next
op_assign
id|next
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_unlink&t;-&t;remove a buffer from a list&n; *&t;@skb: buffer to remove&n; *&n; *&t;Place a packet after a given packet in a list. The list locks are taken&n; *&t;and this function is atomic with respect to other list locked calls&n; *&t;&n; *&t;Works even without knowing the list it is sitting on, which can be &n; *&t;handy at times. It also means that THE LIST MUST EXIST when you &n; *&t;unlink. Thus a list must have its contents unlinked before it is&n; *&t;destroyed.&n; */
DECL|function|skb_unlink
r_static
r_inline
r_void
id|skb_unlink
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_struct
id|sk_buff_head
op_star
id|list
op_assign
id|skb-&gt;list
suffix:semicolon
r_if
c_cond
(paren
id|list
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;list
op_eq
id|list
)paren
(brace
id|__skb_unlink
c_func
(paren
id|skb
comma
id|skb-&gt;list
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* XXX: more streamlined implementation */
multiline_comment|/**&n; *&t;__skb_dequeue_tail - remove from the tail of the queue&n; *&t;@list: list to dequeue from&n; *&n; *&t;Remove the tail of the list. This function does not take any locks&n; *&t;so must be used with appropriate locks held only. The tail item is&n; *&t;returned or %NULL if the list is empty.&n; */
DECL|function|__skb_dequeue_tail
r_static
r_inline
r_struct
id|sk_buff
op_star
id|__skb_dequeue_tail
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|skb_peek_tail
c_func
(paren
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|__skb_unlink
c_func
(paren
id|skb
comma
id|list
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_dequeue - remove from the head of the queue&n; *&t;@list: list to dequeue from&n; *&n; *&t;Remove the head of the list. The list lock is taken so the function&n; *&t;may be used safely with other locking list functions. The tail item is&n; *&t;returned or %NULL if the list is empty.&n; */
DECL|function|skb_dequeue_tail
r_static
r_inline
r_struct
id|sk_buff
op_star
id|skb_dequeue_tail
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_int
id|flags
suffix:semicolon
r_struct
id|sk_buff
op_star
id|result
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|result
op_assign
id|__skb_dequeue_tail
c_func
(paren
id|list
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|list-&gt;lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Add data to an sk_buff&n; */
DECL|function|__skb_put
r_static
r_inline
r_int
r_char
op_star
id|__skb_put
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_char
op_star
id|tmp
op_assign
id|skb-&gt;tail
suffix:semicolon
id|skb-&gt;tail
op_add_assign
id|len
suffix:semicolon
id|skb-&gt;len
op_add_assign
id|len
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_put - add data to a buffer&n; *&t;@skb: buffer to use &n; *&t;@len: amount of data to add&n; *&n; *&t;This function extends the used data area of the buffer. If this would&n; *&t;exceed the total buffer size the kernel will panic. A pointer to the&n; *&t;first byte of the extra data is returned.&n; */
DECL|function|skb_put
r_static
r_inline
r_int
r_char
op_star
id|skb_put
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_char
op_star
id|tmp
op_assign
id|skb-&gt;tail
suffix:semicolon
id|skb-&gt;tail
op_add_assign
id|len
suffix:semicolon
id|skb-&gt;len
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;tail
OG
id|skb-&gt;end
)paren
(brace
id|skb_over_panic
c_func
(paren
id|skb
comma
id|len
comma
id|current_text_addr
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|__skb_push
r_static
r_inline
r_int
r_char
op_star
id|__skb_push
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
id|skb-&gt;data
op_sub_assign
id|len
suffix:semicolon
id|skb-&gt;len
op_add_assign
id|len
suffix:semicolon
r_return
id|skb-&gt;data
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_push - add data to the start of a buffer&n; *&t;@skb: buffer to use &n; *&t;@len: amount of data to add&n; *&n; *&t;This function extends the used data area of the buffer at the buffer&n; *&t;start. If this would exceed the total buffer headroom the kernel will&n; *&t;panic. A pointer to the first byte of the extra data is returned.&n; */
DECL|function|skb_push
r_static
r_inline
r_int
r_char
op_star
id|skb_push
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
id|skb-&gt;data
op_sub_assign
id|len
suffix:semicolon
id|skb-&gt;len
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|skb-&gt;data
OL
id|skb-&gt;head
)paren
(brace
id|skb_under_panic
c_func
(paren
id|skb
comma
id|len
comma
id|current_text_addr
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_return
id|skb-&gt;data
suffix:semicolon
)brace
DECL|function|__skb_pull
r_static
r_inline
r_char
op_star
id|__skb_pull
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
id|skb-&gt;len
op_sub_assign
id|len
suffix:semicolon
r_return
id|skb-&gt;data
op_add_assign
id|len
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_pull - remove data from the start of a buffer&n; *&t;@skb: buffer to use &n; *&t;@len: amount of data to remove&n; *&n; *&t;This function removes data from the start of a buffer, returning&n; *&t;the memory to the headroom. A pointer to the next data in the buffer&n; *&t;is returned. Once the data has been pulled future pushes will overwrite&n; *&t;the old data.&n; */
DECL|function|skb_pull
r_static
r_inline
r_int
r_char
op_star
id|skb_pull
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
OG
id|skb-&gt;len
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|__skb_pull
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_headroom - bytes at buffer head&n; *&t;@skb: buffer to check&n; *&n; *&t;Return the number of bytes of free space at the head of an &amp;sk_buff.&n; */
DECL|function|skb_headroom
r_static
r_inline
r_int
id|skb_headroom
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
id|skb-&gt;data
op_minus
id|skb-&gt;head
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_tailroom - bytes at buffer end&n; *&t;@skb: buffer to check&n; *&n; *&t;Return the number of bytes of free space at the tail of an sk_buff&n; */
DECL|function|skb_tailroom
r_static
r_inline
r_int
id|skb_tailroom
c_func
(paren
r_const
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_return
id|skb-&gt;end
op_minus
id|skb-&gt;tail
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_reserve - adjust headroom&n; *&t;@skb: buffer to alter&n; *&t;@len: bytes to move&n; *&n; *&t;Increase the headroom of an empty &amp;sk_buff by reducing the tail&n; *&t;room. This is only allowed for an empty buffer.&n; */
DECL|function|skb_reserve
r_static
r_inline
r_void
id|skb_reserve
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
id|skb-&gt;data
op_add_assign
id|len
suffix:semicolon
id|skb-&gt;tail
op_add_assign
id|len
suffix:semicolon
)brace
DECL|function|__skb_trim
r_static
r_inline
r_void
id|__skb_trim
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
id|skb-&gt;len
op_assign
id|len
suffix:semicolon
id|skb-&gt;tail
op_assign
id|skb-&gt;data
op_plus
id|len
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_trim - remove end from a buffer&n; *&t;@skb: buffer to alter&n; *&t;@len: new length&n; *&n; *&t;Cut the length of a buffer down by removing data from the tail. If&n; *&t;the buffer is already under the length specified it is not modified.&n; */
DECL|function|skb_trim
r_static
r_inline
r_void
id|skb_trim
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;len
OG
id|len
)paren
(brace
id|__skb_trim
c_func
(paren
id|skb
comma
id|len
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;skb_orphan - orphan a buffer&n; *&t;@skb: buffer to orphan&n; *&n; *&t;If a buffer currently has an owner then we call the owner&squot;s&n; *&t;destructor function and make the @skb unowned. The buffer continues&n; *&t;to exist but is no longer charged to its former owner.&n; */
DECL|function|skb_orphan
r_static
r_inline
r_void
id|skb_orphan
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
)paren
(brace
r_if
c_cond
(paren
id|skb-&gt;destructor
)paren
id|skb
op_member_access_from_pointer
id|destructor
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb-&gt;destructor
op_assign
l_int|NULL
suffix:semicolon
id|skb-&gt;sk
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_purge - empty a list&n; *&t;@list: list to empty&n; *&n; *&t;Delete all buffers on an &amp;sk_buff list. Each buffer is removed from&n; *&t;the list and one reference dropped. This function takes the list&n; *&t;lock and is atomic with respect to other list locking functions.&n; */
DECL|function|skb_queue_purge
r_static
r_inline
r_void
id|skb_queue_purge
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|skb_dequeue
c_func
(paren
id|list
)paren
)paren
op_ne
l_int|NULL
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;__skb_purge - empty a list&n; *&t;@list: list to empty&n; *&n; *&t;Delete all buffers on an &amp;sk_buff list. Each buffer is removed from&n; *&t;the list and one reference dropped. This function does not take the&n; *&t;list lock and the caller must hold the relevant locks to use it.&n; */
DECL|function|__skb_queue_purge
r_static
r_inline
r_void
id|__skb_queue_purge
c_func
(paren
r_struct
id|sk_buff_head
op_star
id|list
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
r_while
c_loop
(paren
(paren
id|skb
op_assign
id|__skb_dequeue
c_func
(paren
id|list
)paren
)paren
op_ne
l_int|NULL
)paren
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;dev_alloc_skb - allocate an skbuff for sending&n; *&t;@length: length to allocate&n; *&n; *&t;Allocate a new &amp;sk_buff and assign it a usage count of one. The&n; *&t;buffer has unspecified headroom built in. Users should allocate&n; *&t;the headroom they think they need without accounting for the&n; *&t;built in space. The built in space is used for optimisations.&n; *&n; *&t;%NULL is returned in there is no free memory. Although this function&n; *&t;allocates memory it can be called from an interrupt.&n; */
DECL|function|dev_alloc_skb
r_static
r_inline
r_struct
id|sk_buff
op_star
id|dev_alloc_skb
c_func
(paren
r_int
r_int
id|length
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
suffix:semicolon
id|skb
op_assign
id|alloc_skb
c_func
(paren
id|length
op_plus
l_int|16
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
)paren
id|skb_reserve
c_func
(paren
id|skb
comma
l_int|16
)paren
suffix:semicolon
r_return
id|skb
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;skb_cow - copy a buffer if need be&n; *&t;@skb: buffer to copy&n; *&t;@headroom: needed headroom&n; *&n; *&t;If the buffer passed lacks sufficient headroom or is a clone then&n; *&t;it is copied and the additional headroom made available. If there&n; *&t;is no free memory %NULL is returned. The new buffer is returned if&n; *&t;a copy was made (and the old one dropped a reference). The existing&n; *&t;buffer is returned otherwise.&n; *&n; *&t;This function primarily exists to avoid making two copies when making&n; *&t;a writable copy of a buffer and then growing the headroom.&n; */
r_static
r_inline
r_struct
id|sk_buff
op_star
DECL|function|skb_cow
id|skb_cow
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_int
r_int
id|headroom
)paren
(brace
id|headroom
op_assign
(paren
id|headroom
op_plus
l_int|15
)paren
op_amp
op_complement
l_int|15
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|skb_headroom
c_func
(paren
id|skb
)paren
OL
id|headroom
op_logical_or
id|skb_cloned
c_func
(paren
id|skb
)paren
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb2
op_assign
id|skb_realloc_headroom
c_func
(paren
id|skb
comma
id|headroom
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|skb
op_assign
id|skb2
suffix:semicolon
)brace
r_return
id|skb
suffix:semicolon
)brace
DECL|macro|skb_queue_walk
mdefine_line|#define skb_queue_walk(queue, skb) &bslash;&n;&t;&t;for (skb = (queue)-&gt;next;&t;&t;&t;&bslash;&n;&t;&t;     (skb != (struct sk_buff *)(queue));&t;&bslash;&n;&t;&t;     skb=skb-&gt;next)
r_extern
r_struct
id|sk_buff
op_star
id|skb_recv_datagram
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|flags
comma
r_int
id|noblock
comma
r_int
op_star
id|err
)paren
suffix:semicolon
r_extern
r_int
r_int
id|datagram_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|socket
op_star
id|sock
comma
r_struct
id|poll_table_struct
op_star
id|wait
)paren
suffix:semicolon
r_extern
r_int
id|skb_copy_datagram
c_func
(paren
r_struct
id|sk_buff
op_star
id|from
comma
r_int
id|offset
comma
r_char
op_star
id|to
comma
r_int
id|size
)paren
suffix:semicolon
r_extern
r_int
id|skb_copy_datagram_iovec
c_func
(paren
r_struct
id|sk_buff
op_star
id|from
comma
r_int
id|offset
comma
r_struct
id|iovec
op_star
id|to
comma
r_int
id|size
)paren
suffix:semicolon
r_extern
r_void
id|skb_free_datagram
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_struct
id|sk_buff
op_star
id|skb
)paren
suffix:semicolon
r_extern
r_void
id|skb_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|skb_add_mtu
c_func
(paren
r_int
id|mtu
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NETFILTER
r_static
r_inline
r_void
DECL|function|nf_conntrack_put
id|nf_conntrack_put
c_func
(paren
r_struct
id|nf_ct_info
op_star
id|nfct
)paren
(brace
r_if
c_cond
(paren
id|nfct
op_logical_and
id|atomic_dec_and_test
c_func
(paren
op_amp
id|nfct-&gt;master-&gt;use
)paren
)paren
id|nfct-&gt;master
op_member_access_from_pointer
id|destroy
c_func
(paren
id|nfct-&gt;master
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|nf_conntrack_get
id|nf_conntrack_get
c_func
(paren
r_struct
id|nf_ct_info
op_star
id|nfct
)paren
(brace
r_if
c_cond
(paren
id|nfct
)paren
id|atomic_inc
c_func
(paren
op_amp
id|nfct-&gt;master-&gt;use
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif&t;/* __KERNEL__ */
macro_line|#endif&t;/* _LINUX_SKBUFF_H */
eof
