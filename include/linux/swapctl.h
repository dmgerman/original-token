macro_line|#ifndef _LINUX_SWAPCTL_H
DECL|macro|_LINUX_SWAPCTL_H
mdefine_line|#define _LINUX_SWAPCTL_H
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
multiline_comment|/* Swap tuning control */
multiline_comment|/* First, enumerate the different reclaim policies */
DECL|enum|RCL_POLICY
DECL|enumerator|RCL_ROUND_ROBIN
DECL|enumerator|RCL_BUFF_FIRST
DECL|enumerator|RCL_PERSIST
r_enum
id|RCL_POLICY
(brace
id|RCL_ROUND_ROBIN
comma
id|RCL_BUFF_FIRST
comma
id|RCL_PERSIST
)brace
suffix:semicolon
DECL|struct|swap_control_v5
r_typedef
r_struct
id|swap_control_v5
(brace
DECL|member|sc_max_page_age
r_int
r_int
id|sc_max_page_age
suffix:semicolon
DECL|member|sc_page_advance
r_int
r_int
id|sc_page_advance
suffix:semicolon
DECL|member|sc_page_decline
r_int
r_int
id|sc_page_decline
suffix:semicolon
DECL|member|sc_page_initial_age
r_int
r_int
id|sc_page_initial_age
suffix:semicolon
DECL|member|sc_max_buff_age
r_int
r_int
id|sc_max_buff_age
suffix:semicolon
DECL|member|sc_buff_advance
r_int
r_int
id|sc_buff_advance
suffix:semicolon
DECL|member|sc_buff_decline
r_int
r_int
id|sc_buff_decline
suffix:semicolon
DECL|member|sc_buff_initial_age
r_int
r_int
id|sc_buff_initial_age
suffix:semicolon
DECL|member|sc_age_cluster_fract
r_int
r_int
id|sc_age_cluster_fract
suffix:semicolon
DECL|member|sc_age_cluster_min
r_int
r_int
id|sc_age_cluster_min
suffix:semicolon
DECL|member|sc_pageout_weight
r_int
r_int
id|sc_pageout_weight
suffix:semicolon
DECL|member|sc_bufferout_weight
r_int
r_int
id|sc_bufferout_weight
suffix:semicolon
DECL|member|sc_buffer_grace
r_int
r_int
id|sc_buffer_grace
suffix:semicolon
DECL|member|sc_nr_buffs_to_free
r_int
r_int
id|sc_nr_buffs_to_free
suffix:semicolon
DECL|member|sc_nr_pages_to_free
r_int
r_int
id|sc_nr_pages_to_free
suffix:semicolon
DECL|member|sc_policy
r_enum
id|RCL_POLICY
id|sc_policy
suffix:semicolon
DECL|typedef|swap_control_v5
)brace
id|swap_control_v5
suffix:semicolon
DECL|typedef|swap_control_t
r_typedef
r_struct
id|swap_control_v5
id|swap_control_t
suffix:semicolon
r_extern
id|swap_control_t
id|swap_control
suffix:semicolon
DECL|struct|kswapd_control_v1
r_typedef
r_struct
id|kswapd_control_v1
(brace
DECL|member|maxpages
r_int
r_int
id|maxpages
suffix:semicolon
DECL|member|pages_buff
r_int
r_int
id|pages_buff
suffix:semicolon
DECL|member|pages_shm
r_int
r_int
id|pages_shm
suffix:semicolon
DECL|member|pages_mmap
r_int
r_int
id|pages_mmap
suffix:semicolon
DECL|member|pages_swap
r_int
r_int
id|pages_swap
suffix:semicolon
DECL|typedef|kswapd_control_v1
)brace
id|kswapd_control_v1
suffix:semicolon
DECL|typedef|kswapd_control_t
r_typedef
id|kswapd_control_v1
id|kswapd_control_t
suffix:semicolon
r_extern
id|kswapd_control_t
id|kswapd_ctl
suffix:semicolon
DECL|struct|swapstat_v1
r_typedef
r_struct
id|swapstat_v1
(brace
DECL|member|wakeups
r_int
r_int
id|wakeups
suffix:semicolon
DECL|member|pages_reclaimed
r_int
r_int
id|pages_reclaimed
suffix:semicolon
DECL|member|pages_shm
r_int
r_int
id|pages_shm
suffix:semicolon
DECL|member|pages_mmap
r_int
r_int
id|pages_mmap
suffix:semicolon
DECL|member|pages_swap
r_int
r_int
id|pages_swap
suffix:semicolon
DECL|typedef|swapstat_v1
)brace
id|swapstat_v1
suffix:semicolon
DECL|typedef|swapstat_t
r_typedef
id|swapstat_v1
id|swapstat_t
suffix:semicolon
r_extern
id|swapstat_t
id|swapstats
suffix:semicolon
r_extern
r_int
id|min_free_pages
comma
id|free_pages_low
comma
id|free_pages_high
suffix:semicolon
DECL|macro|SC_VERSION
mdefine_line|#define SC_VERSION&t;1
DECL|macro|SC_MAX_VERSION
mdefine_line|#define SC_MAX_VERSION&t;1
macro_line|#ifdef __KERNEL__
multiline_comment|/* Define the maximum (least urgent) priority for the page reclaim code */
DECL|macro|RCL_MAXPRI
mdefine_line|#define RCL_MAXPRI 6
multiline_comment|/* We use an extra priority in the swap accounting code to represent&n;   failure to free a resource at any priority */
DECL|macro|RCL_FAILURE
mdefine_line|#define RCL_FAILURE (RCL_MAXPRI + 1)
DECL|macro|RCL_POLICY
mdefine_line|#define RCL_POLICY&t;&t;(swap_control.sc_policy)
DECL|macro|AGE_CLUSTER_FRACT
mdefine_line|#define AGE_CLUSTER_FRACT&t;(swap_control.sc_age_cluster_fract)
DECL|macro|AGE_CLUSTER_MIN
mdefine_line|#define AGE_CLUSTER_MIN&t;&t;(swap_control.sc_age_cluster_min)
DECL|macro|PAGEOUT_WEIGHT
mdefine_line|#define PAGEOUT_WEIGHT&t;&t;(swap_control.sc_pageout_weight)
DECL|macro|BUFFEROUT_WEIGHT
mdefine_line|#define BUFFEROUT_WEIGHT&t;(swap_control.sc_bufferout_weight)
DECL|macro|NR_BUFFS_TO_FREE
mdefine_line|#define NR_BUFFS_TO_FREE&t;(swap_control.sc_nr_buffs_to_free)
DECL|macro|NR_PAGES_TO_FREE
mdefine_line|#define NR_PAGES_TO_FREE&t;(swap_control.sc_nr_pages_to_free)
DECL|macro|BUFFERMEM_GRACE
mdefine_line|#define BUFFERMEM_GRACE&t;&t;(swap_control.sc_buffer_grace)
multiline_comment|/* Page aging (see mm/swap.c) */
DECL|macro|MAX_PAGE_AGE
mdefine_line|#define MAX_PAGE_AGE&t;&t;(swap_control.sc_max_page_age)
DECL|macro|PAGE_ADVANCE
mdefine_line|#define PAGE_ADVANCE&t;&t;(swap_control.sc_page_advance)
DECL|macro|PAGE_DECLINE
mdefine_line|#define PAGE_DECLINE&t;&t;(swap_control.sc_page_decline)
DECL|macro|PAGE_INITIAL_AGE
mdefine_line|#define PAGE_INITIAL_AGE&t;(swap_control.sc_page_initial_age)
DECL|macro|MAX_BUFF_AGE
mdefine_line|#define MAX_BUFF_AGE&t;&t;(swap_control.sc_max_buff_age)
DECL|macro|BUFF_ADVANCE
mdefine_line|#define BUFF_ADVANCE&t;&t;(swap_control.sc_buff_advance)
DECL|macro|BUFF_DECLINE
mdefine_line|#define BUFF_DECLINE&t;&t;(swap_control.sc_buff_decline)
DECL|macro|BUFF_INITIAL_AGE
mdefine_line|#define BUFF_INITIAL_AGE&t;(swap_control.sc_buff_initial_age)
multiline_comment|/* Given a resource of N units (pages or buffers etc), we only try to&n; * age and reclaim AGE_CLUSTER_FRACT per 1024 resources each time we&n; * scan the resource list. */
DECL|function|AGE_CLUSTER_SIZE
r_static
r_inline
r_int
id|AGE_CLUSTER_SIZE
c_func
(paren
r_int
id|resources
)paren
(brace
r_int
r_int
id|n
op_assign
(paren
id|resources
op_star
id|AGE_CLUSTER_FRACT
)paren
op_rshift
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
id|AGE_CLUSTER_MIN
)paren
r_return
id|AGE_CLUSTER_MIN
suffix:semicolon
r_else
r_return
id|n
suffix:semicolon
)brace
DECL|function|touch_page
r_static
r_inline
r_void
id|touch_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|page-&gt;age
OL
(paren
id|MAX_PAGE_AGE
op_minus
id|PAGE_ADVANCE
)paren
)paren
id|page-&gt;age
op_add_assign
id|PAGE_ADVANCE
suffix:semicolon
r_else
id|page-&gt;age
op_assign
id|MAX_PAGE_AGE
suffix:semicolon
)brace
DECL|function|age_page
r_static
r_inline
r_void
id|age_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|page-&gt;age
OG
id|PAGE_DECLINE
)paren
id|page-&gt;age
op_sub_assign
id|PAGE_DECLINE
suffix:semicolon
r_else
id|page-&gt;age
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|age_of
r_static
r_inline
r_int
id|age_of
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
r_return
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|addr
)paren
)braket
dot
id|age
suffix:semicolon
)brace
DECL|function|set_page_new
r_static
r_inline
r_void
id|set_page_new
c_func
(paren
r_int
r_int
id|addr
)paren
(brace
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|addr
)paren
)braket
dot
id|age
op_assign
id|PAGE_INITIAL_AGE
suffix:semicolon
)brace
macro_line|#endif /* __KERNEL */
macro_line|#endif /* _LINUX_SWAPCTL_H */
eof
