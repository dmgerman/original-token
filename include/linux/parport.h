multiline_comment|/* $Id: parport.h,v 1.1 1998/05/17 10:57:52 andrea Exp andrea $ */
macro_line|#ifndef _PARPORT_H_
DECL|macro|_PARPORT_H_
mdefine_line|#define _PARPORT_H_
multiline_comment|/* Start off with user-visible constants */
multiline_comment|/* Maximum of 8 ports per machine */
DECL|macro|PARPORT_MAX
mdefine_line|#define PARPORT_MAX  8 
multiline_comment|/* Magic numbers */
DECL|macro|PARPORT_IRQ_NONE
mdefine_line|#define PARPORT_IRQ_NONE  -1
DECL|macro|PARPORT_DMA_NONE
mdefine_line|#define PARPORT_DMA_NONE  -1
DECL|macro|PARPORT_IRQ_AUTO
mdefine_line|#define PARPORT_IRQ_AUTO  -2
DECL|macro|PARPORT_DMA_AUTO
mdefine_line|#define PARPORT_DMA_AUTO  -2
DECL|macro|PARPORT_DISABLE
mdefine_line|#define PARPORT_DISABLE   -2
DECL|macro|PARPORT_IRQ_PROBEONLY
mdefine_line|#define PARPORT_IRQ_PROBEONLY -3
DECL|macro|PARPORT_CONTROL_STROBE
mdefine_line|#define PARPORT_CONTROL_STROBE    0x1
DECL|macro|PARPORT_CONTROL_AUTOFD
mdefine_line|#define PARPORT_CONTROL_AUTOFD    0x2
DECL|macro|PARPORT_CONTROL_INIT
mdefine_line|#define PARPORT_CONTROL_INIT      0x4
DECL|macro|PARPORT_CONTROL_SELECT
mdefine_line|#define PARPORT_CONTROL_SELECT    0x8
DECL|macro|PARPORT_CONTROL_INTEN
mdefine_line|#define PARPORT_CONTROL_INTEN     0x10
DECL|macro|PARPORT_CONTROL_DIRECTION
mdefine_line|#define PARPORT_CONTROL_DIRECTION 0x20
DECL|macro|PARPORT_STATUS_ERROR
mdefine_line|#define PARPORT_STATUS_ERROR      0x8
DECL|macro|PARPORT_STATUS_SELECT
mdefine_line|#define PARPORT_STATUS_SELECT     0x10
DECL|macro|PARPORT_STATUS_PAPEROUT
mdefine_line|#define PARPORT_STATUS_PAPEROUT   0x20
DECL|macro|PARPORT_STATUS_ACK
mdefine_line|#define PARPORT_STATUS_ACK        0x40
DECL|macro|PARPORT_STATUS_BUSY
mdefine_line|#define PARPORT_STATUS_BUSY       0x80
multiline_comment|/* Type classes for Plug-and-Play probe.  */
r_typedef
r_enum
(brace
DECL|enumerator|PARPORT_CLASS_LEGACY
id|PARPORT_CLASS_LEGACY
op_assign
l_int|0
comma
multiline_comment|/* Non-IEEE1284 device */
DECL|enumerator|PARPORT_CLASS_PRINTER
id|PARPORT_CLASS_PRINTER
comma
DECL|enumerator|PARPORT_CLASS_MODEM
id|PARPORT_CLASS_MODEM
comma
DECL|enumerator|PARPORT_CLASS_NET
id|PARPORT_CLASS_NET
comma
DECL|enumerator|PARPORT_CLASS_HDC
id|PARPORT_CLASS_HDC
comma
multiline_comment|/* Hard disk controller */
DECL|enumerator|PARPORT_CLASS_PCMCIA
id|PARPORT_CLASS_PCMCIA
comma
DECL|enumerator|PARPORT_CLASS_MEDIA
id|PARPORT_CLASS_MEDIA
comma
multiline_comment|/* Multimedia device */
DECL|enumerator|PARPORT_CLASS_FDC
id|PARPORT_CLASS_FDC
comma
multiline_comment|/* Floppy disk controller */
DECL|enumerator|PARPORT_CLASS_PORTS
id|PARPORT_CLASS_PORTS
comma
DECL|enumerator|PARPORT_CLASS_SCANNER
id|PARPORT_CLASS_SCANNER
comma
DECL|enumerator|PARPORT_CLASS_DIGCAM
id|PARPORT_CLASS_DIGCAM
comma
DECL|enumerator|PARPORT_CLASS_OTHER
id|PARPORT_CLASS_OTHER
comma
multiline_comment|/* Anything else */
DECL|enumerator|PARPORT_CLASS_UNSPEC
id|PARPORT_CLASS_UNSPEC
multiline_comment|/* No CLS field in ID */
DECL|typedef|parport_device_class
)brace
id|parport_device_class
suffix:semicolon
multiline_comment|/* The &quot;modes&quot; entry in parport is a bit field representing the following&n; * modes.&n; * Note that PARPORT_MODE_PCECPEPP is for the SMC EPP+ECP mode which is NOT&n; * 100% compatible with EPP.&n; */
DECL|macro|PARPORT_MODE_PCSPP
mdefine_line|#define PARPORT_MODE_PCSPP&t;        0x0001
DECL|macro|PARPORT_MODE_PCPS2
mdefine_line|#define PARPORT_MODE_PCPS2&t;&t;0x0002
DECL|macro|PARPORT_MODE_PCEPP
mdefine_line|#define PARPORT_MODE_PCEPP&t;&t;0x0004
DECL|macro|PARPORT_MODE_PCECP
mdefine_line|#define PARPORT_MODE_PCECP&t;&t;0x0008
DECL|macro|PARPORT_MODE_PCECPEPP
mdefine_line|#define PARPORT_MODE_PCECPEPP&t;&t;0x0010
DECL|macro|PARPORT_MODE_PCECR
mdefine_line|#define PARPORT_MODE_PCECR&t;&t;0x0020  /* ECR Register Exists */
DECL|macro|PARPORT_MODE_PCECPPS2
mdefine_line|#define PARPORT_MODE_PCECPPS2&t;&t;0x0040
multiline_comment|/* The rest is for the kernel only */
macro_line|#ifdef __KERNEL__
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/spinlock.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/config.h&gt;
DECL|macro|PARPORT_NEED_GENERIC_OPS
mdefine_line|#define PARPORT_NEED_GENERIC_OPS
multiline_comment|/* Define this later. */
r_struct
id|parport
suffix:semicolon
DECL|struct|pc_parport_state
r_struct
id|pc_parport_state
(brace
DECL|member|ctr
r_int
r_int
id|ctr
suffix:semicolon
DECL|member|ecr
r_int
r_int
id|ecr
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|parport_state
r_struct
id|parport_state
(brace
r_union
(brace
DECL|member|pc
r_struct
id|pc_parport_state
id|pc
suffix:semicolon
multiline_comment|/* ARC has no state. */
multiline_comment|/* AX uses same state information as PC */
DECL|member|misc
r_void
op_star
id|misc
suffix:semicolon
DECL|member|u
)brace
id|u
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|parport_operations
r_struct
id|parport_operations
(brace
DECL|member|write_data
r_void
(paren
op_star
id|write_data
)paren
(paren
r_struct
id|parport
op_star
comma
r_int
r_char
)paren
suffix:semicolon
DECL|member|read_data
r_int
r_char
(paren
op_star
id|read_data
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|write_control
r_void
(paren
op_star
id|write_control
)paren
(paren
r_struct
id|parport
op_star
comma
r_int
r_char
)paren
suffix:semicolon
DECL|member|read_control
r_int
r_char
(paren
op_star
id|read_control
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|frob_control
r_int
r_char
(paren
op_star
id|frob_control
)paren
(paren
r_struct
id|parport
op_star
comma
r_int
r_char
id|mask
comma
r_int
r_char
id|val
)paren
suffix:semicolon
DECL|member|write_econtrol
r_void
(paren
op_star
id|write_econtrol
)paren
(paren
r_struct
id|parport
op_star
comma
r_int
r_char
)paren
suffix:semicolon
DECL|member|read_econtrol
r_int
r_char
(paren
op_star
id|read_econtrol
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|frob_econtrol
r_int
r_char
(paren
op_star
id|frob_econtrol
)paren
(paren
r_struct
id|parport
op_star
comma
r_int
r_char
id|mask
comma
r_int
r_char
id|val
)paren
suffix:semicolon
DECL|member|write_status
r_void
(paren
op_star
id|write_status
)paren
(paren
r_struct
id|parport
op_star
comma
r_int
r_char
)paren
suffix:semicolon
DECL|member|read_status
r_int
r_char
(paren
op_star
id|read_status
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|write_fifo
r_void
(paren
op_star
id|write_fifo
)paren
(paren
r_struct
id|parport
op_star
comma
r_int
r_char
)paren
suffix:semicolon
DECL|member|read_fifo
r_int
r_char
(paren
op_star
id|read_fifo
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|change_mode
r_void
(paren
op_star
id|change_mode
)paren
(paren
r_struct
id|parport
op_star
comma
r_int
)paren
suffix:semicolon
DECL|member|release_resources
r_void
(paren
op_star
id|release_resources
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|claim_resources
r_int
(paren
op_star
id|claim_resources
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|epp_write_data
r_void
(paren
op_star
id|epp_write_data
)paren
(paren
r_struct
id|parport
op_star
comma
r_int
r_char
)paren
suffix:semicolon
DECL|member|epp_read_data
r_int
r_char
(paren
op_star
id|epp_read_data
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|epp_write_addr
r_void
(paren
op_star
id|epp_write_addr
)paren
(paren
r_struct
id|parport
op_star
comma
r_int
r_char
)paren
suffix:semicolon
DECL|member|epp_read_addr
r_int
r_char
(paren
op_star
id|epp_read_addr
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|epp_check_timeout
r_int
(paren
op_star
id|epp_check_timeout
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|epp_write_block
r_int
(paren
op_star
id|epp_write_block
)paren
(paren
r_struct
id|parport
op_star
comma
r_void
op_star
comma
r_int
)paren
suffix:semicolon
DECL|member|epp_read_block
r_int
(paren
op_star
id|epp_read_block
)paren
(paren
r_struct
id|parport
op_star
comma
r_void
op_star
comma
r_int
)paren
suffix:semicolon
DECL|member|ecp_write_block
r_int
(paren
op_star
id|ecp_write_block
)paren
(paren
r_struct
id|parport
op_star
comma
r_void
op_star
comma
r_int
comma
r_void
(paren
op_star
id|fn
)paren
(paren
r_struct
id|parport
op_star
comma
r_void
op_star
comma
r_int
)paren
comma
r_void
op_star
)paren
suffix:semicolon
DECL|member|ecp_read_block
r_int
(paren
op_star
id|ecp_read_block
)paren
(paren
r_struct
id|parport
op_star
comma
r_void
op_star
comma
r_int
comma
r_void
(paren
op_star
id|fn
)paren
(paren
r_struct
id|parport
op_star
comma
r_void
op_star
comma
r_int
)paren
comma
r_void
op_star
)paren
suffix:semicolon
DECL|member|init_state
r_void
(paren
op_star
id|init_state
)paren
(paren
r_struct
id|parport_state
op_star
)paren
suffix:semicolon
DECL|member|save_state
r_void
(paren
op_star
id|save_state
)paren
(paren
r_struct
id|parport
op_star
comma
r_struct
id|parport_state
op_star
)paren
suffix:semicolon
DECL|member|restore_state
r_void
(paren
op_star
id|restore_state
)paren
(paren
r_struct
id|parport
op_star
comma
r_struct
id|parport_state
op_star
)paren
suffix:semicolon
DECL|member|enable_irq
r_void
(paren
op_star
id|enable_irq
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|disable_irq
r_void
(paren
op_star
id|disable_irq
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|interrupt
r_void
(paren
op_star
id|interrupt
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
DECL|member|inc_use_count
r_void
(paren
op_star
id|inc_use_count
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|member|dec_use_count
r_void
(paren
op_star
id|dec_use_count
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|member|fill_inode
r_void
(paren
op_star
id|fill_inode
)paren
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|fill
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|parport_device_info
r_struct
id|parport_device_info
(brace
DECL|member|class
id|parport_device_class
r_class
suffix:semicolon
DECL|member|class_name
r_const
r_char
op_star
id|class_name
suffix:semicolon
DECL|member|mfr
r_const
r_char
op_star
id|mfr
suffix:semicolon
DECL|member|model
r_const
r_char
op_star
id|model
suffix:semicolon
DECL|member|cmdset
r_const
r_char
op_star
id|cmdset
suffix:semicolon
DECL|member|description
r_const
r_char
op_star
id|description
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Each device can have two callback functions:&n; *  1) a preemption function, called by the resource manager to request&n; *     that the driver relinquish control of the port.  The driver should&n; *     return zero if it agrees to release the port, and nonzero if it &n; *     refuses.  Do not call parport_release() - the kernel will do this&n; *     implicitly.&n; *&n; *  2) a wake-up function, called by the resource manager to tell drivers&n; *     that the port is available to be claimed.  If a driver wants to use&n; *     the port, it should call parport_claim() here.&n; */
multiline_comment|/* A parallel port device */
DECL|struct|pardevice
r_struct
id|pardevice
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|port
r_struct
id|parport
op_star
id|port
suffix:semicolon
DECL|member|preempt
r_int
(paren
op_star
id|preempt
)paren
(paren
r_void
op_star
)paren
suffix:semicolon
DECL|member|wakeup
r_void
(paren
op_star
id|wakeup
)paren
(paren
r_void
op_star
)paren
suffix:semicolon
DECL|member|private
r_void
op_star
r_private
suffix:semicolon
DECL|member|irq_func
r_void
(paren
op_star
id|irq_func
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|next
r_struct
id|pardevice
op_star
id|next
suffix:semicolon
DECL|member|prev
r_struct
id|pardevice
op_star
id|prev
suffix:semicolon
DECL|member|state
r_struct
id|parport_state
op_star
id|state
suffix:semicolon
multiline_comment|/* saved status over preemption */
DECL|member|wait_q
r_struct
id|wait_queue
op_star
id|wait_q
suffix:semicolon
DECL|member|time
r_int
r_int
r_int
id|time
suffix:semicolon
DECL|member|timeslice
r_int
r_int
r_int
id|timeslice
suffix:semicolon
DECL|member|waiting
r_int
r_int
id|waiting
suffix:semicolon
DECL|member|waitprev
r_struct
id|pardevice
op_star
id|waitprev
suffix:semicolon
DECL|member|waitnext
r_struct
id|pardevice
op_star
id|waitnext
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Directory information for the /proc interface */
DECL|struct|parport_dir
r_struct
id|parport_dir
(brace
DECL|member|entry
r_struct
id|proc_dir_entry
op_star
id|entry
suffix:semicolon
multiline_comment|/* Directory /proc/parport/X     */
DECL|member|irq
r_struct
id|proc_dir_entry
op_star
id|irq
suffix:semicolon
multiline_comment|/*&t;&t;.../irq           */
DECL|member|devices
r_struct
id|proc_dir_entry
op_star
id|devices
suffix:semicolon
multiline_comment|/*&t;&t;.../devices       */
DECL|member|hardware
r_struct
id|proc_dir_entry
op_star
id|hardware
suffix:semicolon
multiline_comment|/*&t;&t;.../hardware      */
DECL|member|probe
r_struct
id|proc_dir_entry
op_star
id|probe
suffix:semicolon
multiline_comment|/*&t;&t;.../autoprobe&t;  */
DECL|member|name
r_char
id|name
(braket
l_int|4
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* A parallel port */
DECL|struct|parport
r_struct
id|parport
(brace
DECL|member|base
r_int
r_int
id|base
suffix:semicolon
multiline_comment|/* base address */
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
multiline_comment|/* IO extent */
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* interrupt (or -1 for none) */
DECL|member|dma
r_int
id|dma
suffix:semicolon
DECL|member|modes
r_int
r_int
id|modes
suffix:semicolon
DECL|member|devices
r_struct
id|pardevice
op_star
id|devices
suffix:semicolon
DECL|member|cad
r_struct
id|pardevice
op_star
id|cad
suffix:semicolon
multiline_comment|/* port owner */
DECL|member|waithead
r_struct
id|pardevice
op_star
id|waithead
suffix:semicolon
DECL|member|waittail
r_struct
id|pardevice
op_star
id|waittail
suffix:semicolon
DECL|member|next
r_struct
id|parport
op_star
id|next
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|pdir
r_struct
id|parport_dir
id|pdir
suffix:semicolon
DECL|member|probe_info
r_struct
id|parport_device_info
id|probe_info
suffix:semicolon
DECL|member|ops
r_struct
id|parport_operations
op_star
id|ops
suffix:semicolon
DECL|member|private_data
r_void
op_star
id|private_data
suffix:semicolon
multiline_comment|/* for lowlevel driver */
DECL|member|number
r_int
id|number
suffix:semicolon
multiline_comment|/* port index - the `n&squot; in `parportn&squot; */
DECL|member|pardevice_lock
id|spinlock_t
id|pardevice_lock
suffix:semicolon
DECL|member|waitlist_lock
id|spinlock_t
id|waitlist_lock
suffix:semicolon
DECL|member|cad_lock
id|rwlock_t
id|cad_lock
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* parport_register_port registers a new parallel port at the given address (if&n; * one does not already exist) and returns a pointer to it.  This entails&n; * claiming the I/O region, IRQ and DMA.&n; * NULL is returned if initialisation fails. &n; */
r_struct
id|parport
op_star
id|parport_register_port
c_func
(paren
r_int
r_int
id|base
comma
r_int
id|irq
comma
r_int
id|dma
comma
r_struct
id|parport_operations
op_star
id|ops
)paren
suffix:semicolon
multiline_comment|/* Unregister a port. */
r_extern
r_void
id|parport_unregister_port
c_func
(paren
r_struct
id|parport
op_star
id|port
)paren
suffix:semicolon
multiline_comment|/* parport_in_use returns nonzero if there are devices attached to a port. */
DECL|macro|parport_in_use
mdefine_line|#define parport_in_use(x)  ((x)-&gt;devices != NULL)
multiline_comment|/* Put a parallel port to sleep; release its hardware resources.  Only possible&n; * if no devices are registered.  */
r_extern
r_void
id|parport_quiesce
c_func
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
multiline_comment|/* parport_enumerate returns a pointer to the linked list of all the ports&n; * in this machine.&n; */
r_struct
id|parport
op_star
id|parport_enumerate
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* parport_register_device declares that a device is connected to a port, and &n; * tells the kernel all it needs to know.  &n; * pf is the preemption function (may be NULL for no callback)&n; * kf is the wake-up function (may be NULL for no callback)&n; * irq_func is the interrupt handler (may be NULL for no interrupts)&n; * handle is a user pointer that gets handed to callback functions. &n; */
r_struct
id|pardevice
op_star
id|parport_register_device
c_func
(paren
r_struct
id|parport
op_star
id|port
comma
r_const
r_char
op_star
id|name
comma
r_int
(paren
op_star
id|pf
)paren
(paren
r_void
op_star
)paren
comma
r_void
(paren
op_star
id|kf
)paren
(paren
r_void
op_star
)paren
comma
r_void
(paren
op_star
id|irq_func
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
id|flags
comma
r_void
op_star
id|handle
)paren
suffix:semicolon
multiline_comment|/* parport_unregister unlinks a device from the chain. */
r_extern
r_void
id|parport_unregister_device
c_func
(paren
r_struct
id|pardevice
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* parport_claim tries to gain ownership of the port for a particular driver.&n; * This may fail (return non-zero) if another driver is busy.  If this&n; * driver has registered an interrupt handler, it will be enabled. &n; */
r_extern
r_int
id|parport_claim
c_func
(paren
r_struct
id|pardevice
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* parport_claim_or_block is the same, but sleeps if the port cannot be &n;   claimed.  Return value is 1 if it slept, 0 normally and -errno on error.  */
r_extern
r_int
id|parport_claim_or_block
c_func
(paren
r_struct
id|pardevice
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* parport_release reverses a previous parport_claim.  This can never fail, &n; * though the effects are undefined (except that they are bad) if you didn&squot;t&n; * previously own the port.  Once you have released the port you should make&n; * sure that neither your code nor the hardware on the port tries to initiate&n; * any communication without first re-claiming the port.&n; * If you mess with the port state (enabling ECP for example) you should&n; * clean up before releasing the port. &n; */
r_extern
r_void
id|parport_release
c_func
(paren
r_struct
id|pardevice
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* parport_yield relinquishes the port if it would be helpful to other&n; * drivers.  The return value is the same as for parport_claim.&n; */
DECL|function|parport_yield
r_extern
id|__inline__
r_int
id|parport_yield
c_func
(paren
r_struct
id|pardevice
op_star
id|dev
)paren
(brace
r_int
r_int
r_int
id|timeslip
op_assign
(paren
id|jiffies
op_minus
id|dev-&gt;time
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;port-&gt;waithead
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|timeslip
OL
id|dev-&gt;timeslice
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|parport_release
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|parport_claim
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* parport_yield_blocking is the same but uses parport_claim_or_block&n; * instead of parport_claim.&n; */
DECL|function|parport_yield_blocking
r_extern
id|__inline__
r_int
id|parport_yield_blocking
c_func
(paren
r_struct
id|pardevice
op_star
id|dev
)paren
(brace
r_int
r_int
r_int
id|timeslip
op_assign
(paren
id|jiffies
op_minus
id|dev-&gt;time
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;port-&gt;waithead
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|timeslip
OL
id|dev-&gt;timeslice
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|parport_release
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|parport_claim_or_block
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Lowlevel drivers _can_ call this support function to handle irqs.&n; */
DECL|function|parport_generic_irq
r_extern
id|__inline__
r_void
id|parport_generic_irq
c_func
(paren
r_int
id|irq
comma
r_struct
id|parport
op_star
id|port
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|port-&gt;cad_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;cad
)paren
r_goto
id|out_unlock
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;cad-&gt;irq_func
)paren
id|port-&gt;cad
op_member_access_from_pointer
id|irq_func
c_func
(paren
id|irq
comma
id|port-&gt;cad
op_member_access_from_pointer
r_private
comma
id|regs
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: irq%d happened with irq_func NULL &quot;
l_string|&quot;with %s as cad!&bslash;n&quot;
comma
id|port-&gt;name
comma
id|irq
comma
id|port-&gt;cad-&gt;name
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|port-&gt;cad_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Flags used to identify what a device does. */
DECL|macro|PARPORT_DEV_TRAN
mdefine_line|#define PARPORT_DEV_TRAN&t;&t;0&t;/* WARNING !! DEPRECATED !! */
DECL|macro|PARPORT_DEV_LURK
mdefine_line|#define PARPORT_DEV_LURK&t;&t;(1&lt;&lt;0)&t;/* WARNING !! DEPRECATED !! */
DECL|macro|PARPORT_DEV_EXCL
mdefine_line|#define PARPORT_DEV_EXCL&t;&t;(1&lt;&lt;1)&t;/* Need exclusive access. */
DECL|macro|PARPORT_FLAG_COMA
mdefine_line|#define PARPORT_FLAG_COMA&t;&t;(1&lt;&lt;0)
DECL|macro|PARPORT_FLAG_EXCL
mdefine_line|#define PARPORT_FLAG_EXCL&t;&t;(1&lt;&lt;1)&t;/* EXCL driver registered. */
r_extern
r_void
id|parport_parse_irqs
c_func
(paren
r_int
comma
r_const
r_char
op_star
(braket
)braket
comma
r_int
id|irqval
(braket
)braket
)paren
suffix:semicolon
r_extern
r_int
id|parport_ieee1284_nibble_mode_ok
c_func
(paren
r_struct
id|parport
op_star
comma
r_int
r_char
)paren
suffix:semicolon
r_extern
r_int
id|parport_wait_peripheral
c_func
(paren
r_struct
id|parport
op_star
comma
r_int
r_char
comma
r_int
r_char
)paren
suffix:semicolon
multiline_comment|/* Prototypes from parport_procfs */
r_extern
r_int
id|parport_proc_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|parport_proc_cleanup
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|parport_proc_register
c_func
(paren
r_struct
id|parport
op_star
id|pp
)paren
suffix:semicolon
r_extern
r_int
id|parport_proc_unregister
c_func
(paren
r_struct
id|parport
op_star
id|pp
)paren
suffix:semicolon
r_extern
r_void
id|dec_parport_count
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|inc_parport_count
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|parport_probe
c_func
(paren
r_struct
id|parport
op_star
id|port
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
suffix:semicolon
r_extern
r_void
id|parport_probe_one
c_func
(paren
r_struct
id|parport
op_star
id|port
)paren
suffix:semicolon
r_extern
r_void
(paren
op_star
id|parport_probe_hook
)paren
(paren
r_struct
id|parport
op_star
id|port
)paren
suffix:semicolon
multiline_comment|/* If PC hardware is the only type supported, we can optimise a bit.  */
macro_line|#if (defined(CONFIG_PARPORT_PC) || defined(CONFIG_PARPORT_PC_MODULE)) &amp;&amp; !(defined(CONFIG_PARPORT_AX) || defined(CONFIG_PARPORT_AX_MODULE)) &amp;&amp; !(defined(CONFIG_PARPORT_ARC) || defined(CONFIG_PARPORT_ARC_MODULE)) &amp;&amp; !defined(CONFIG_PARPORT_OTHER)
DECL|macro|PARPORT_NEED_GENERIC_OPS
macro_line|#undef PARPORT_NEED_GENERIC_OPS
macro_line|#include &lt;linux/parport_pc.h&gt;
DECL|macro|parport_write_data
mdefine_line|#define parport_write_data(p,x)            parport_pc_write_data(p,x)
DECL|macro|parport_read_data
mdefine_line|#define parport_read_data(p)               parport_pc_read_data(p)
DECL|macro|parport_write_control
mdefine_line|#define parport_write_control(p,x)         parport_pc_write_control(p,x)
DECL|macro|parport_read_control
mdefine_line|#define parport_read_control(p)            parport_pc_read_control(p)
DECL|macro|parport_frob_control
mdefine_line|#define parport_frob_control(p,m,v)        parport_pc_frob_control(p,m,v)
DECL|macro|parport_write_econtrol
mdefine_line|#define parport_write_econtrol(p,x)        parport_pc_write_econtrol(p,x)
DECL|macro|parport_read_econtrol
mdefine_line|#define parport_read_econtrol(p)           parport_pc_read_econtrol(p)
DECL|macro|parport_frob_econtrol
mdefine_line|#define parport_frob_econtrol(p,m,v)       parport_pc_frob_econtrol(p,m,v)
DECL|macro|parport_write_status
mdefine_line|#define parport_write_status(p,v)          parport_pc_write_status(p,v)
DECL|macro|parport_read_status
mdefine_line|#define parport_read_status(p)             parport_pc_read_status(p)
DECL|macro|parport_write_fifo
mdefine_line|#define parport_write_fifo(p,v)            parport_pc_write_fifo(p,v)
DECL|macro|parport_read_fifo
mdefine_line|#define parport_read_fifo(p)               parport_pc_read_fifo(p)
DECL|macro|parport_change_mode
mdefine_line|#define parport_change_mode(p,m)           parport_pc_change_mode(p,m)
DECL|macro|parport_release_resources
mdefine_line|#define parport_release_resources(p)       parport_pc_release_resources(p)
DECL|macro|parport_claim_resources
mdefine_line|#define parport_claim_resources(p)         parport_pc_claim_resources(p)
DECL|macro|parport_epp_write_data
mdefine_line|#define parport_epp_write_data(p,x)        parport_pc_write_epp(p,x)
DECL|macro|parport_epp_read_data
mdefine_line|#define parport_epp_read_data(p)           parport_pc_read_epp(p)
DECL|macro|parport_epp_write_addr
mdefine_line|#define parport_epp_write_addr(p,x)        parport_pc_write_epp_addr(p,x)
DECL|macro|parport_epp_read_addr
mdefine_line|#define parport_epp_read_addr(p)           parport_pc_read_epp_addr(p)
DECL|macro|parport_epp_check_timeout
mdefine_line|#define parport_epp_check_timeout(p)       parport_pc_check_epp_timeout(p)
macro_line|#endif
macro_line|#ifdef PARPORT_NEED_GENERIC_OPS
multiline_comment|/* Generic operations vector through the dispatch table. */
DECL|macro|parport_write_data
mdefine_line|#define parport_write_data(p,x)            (p)-&gt;ops-&gt;write_data(p,x)
DECL|macro|parport_read_data
mdefine_line|#define parport_read_data(p)               (p)-&gt;ops-&gt;read_data(p)
DECL|macro|parport_write_control
mdefine_line|#define parport_write_control(p,x)         (p)-&gt;ops-&gt;write_control(p,x)
DECL|macro|parport_read_control
mdefine_line|#define parport_read_control(p)            (p)-&gt;ops-&gt;read_control(p)
DECL|macro|parport_frob_control
mdefine_line|#define parport_frob_control(p,m,v)        (p)-&gt;ops-&gt;frob_control(p,m,v)
DECL|macro|parport_write_econtrol
mdefine_line|#define parport_write_econtrol(p,x)        (p)-&gt;ops-&gt;write_econtrol(p,x)
DECL|macro|parport_read_econtrol
mdefine_line|#define parport_read_econtrol(p)           (p)-&gt;ops-&gt;read_econtrol(p)
DECL|macro|parport_frob_econtrol
mdefine_line|#define parport_frob_econtrol(p,m,v)       (p)-&gt;ops-&gt;frob_econtrol(p,m,v)
DECL|macro|parport_write_status
mdefine_line|#define parport_write_status(p,v)          (p)-&gt;ops-&gt;write_status(p,v)
DECL|macro|parport_read_status
mdefine_line|#define parport_read_status(p)             (p)-&gt;ops-&gt;read_status(p)
DECL|macro|parport_write_fifo
mdefine_line|#define parport_write_fifo(p,v)            (p)-&gt;ops-&gt;write_fifo(p,v)
DECL|macro|parport_read_fifo
mdefine_line|#define parport_read_fifo(p)               (p)-&gt;ops-&gt;read_fifo(p)
DECL|macro|parport_change_mode
mdefine_line|#define parport_change_mode(p,m)           (p)-&gt;ops-&gt;change_mode(p,m)
DECL|macro|parport_release_resources
mdefine_line|#define parport_release_resources(p)       (p)-&gt;ops-&gt;release_resources(p)
DECL|macro|parport_claim_resources
mdefine_line|#define parport_claim_resources(p)         (p)-&gt;ops-&gt;claim_resources(p)
DECL|macro|parport_epp_write_data
mdefine_line|#define parport_epp_write_data(p,x)        (p)-&gt;ops-&gt;epp_write_data(p,x)
DECL|macro|parport_epp_read_data
mdefine_line|#define parport_epp_read_data(p)           (p)-&gt;ops-&gt;epp_read_data(p)
DECL|macro|parport_epp_write_addr
mdefine_line|#define parport_epp_write_addr(p,x)        (p)-&gt;ops-&gt;epp_write_addr(p,x)
DECL|macro|parport_epp_read_addr
mdefine_line|#define parport_epp_read_addr(p)           (p)-&gt;ops-&gt;epp_read_addr(p)
DECL|macro|parport_epp_check_timeout
mdefine_line|#define parport_epp_check_timeout(p)       (p)-&gt;ops-&gt;epp_check_timeout(p)
macro_line|#endif
macro_line|#endif /* __KERNEL__ */
macro_line|#endif /* _PARPORT_H_ */
eof
