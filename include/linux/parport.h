multiline_comment|/* $Id: parport.h,v 1.1.2.5 1997/03/29 21:08:31 phil Exp $ */
macro_line|#ifndef _PARPORT_H_
DECL|macro|_PARPORT_H_
mdefine_line|#define _PARPORT_H_
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
multiline_comment|/* Maximum of 8 ports per machine */
DECL|macro|PARPORT_MAX
mdefine_line|#define PARPORT_MAX  8 
multiline_comment|/* Type classes for Plug-and-Play probe */
r_typedef
r_enum
(brace
DECL|enumerator|PARPORT_CLASS_LEGACY
id|PARPORT_CLASS_LEGACY
op_assign
l_int|0
comma
multiline_comment|/* Non-IEEE1284 device */
DECL|enumerator|PARPORT_CLASS_PRINTER
id|PARPORT_CLASS_PRINTER
comma
DECL|enumerator|PARPORT_CLASS_MODEM
id|PARPORT_CLASS_MODEM
comma
DECL|enumerator|PARPORT_CLASS_NET
id|PARPORT_CLASS_NET
comma
DECL|enumerator|PARPORT_CLASS_HDC
id|PARPORT_CLASS_HDC
comma
multiline_comment|/* Hard disk controller */
DECL|enumerator|PARPORT_CLASS_PCMCIA
id|PARPORT_CLASS_PCMCIA
comma
DECL|enumerator|PARPORT_CLASS_MEDIA
id|PARPORT_CLASS_MEDIA
comma
multiline_comment|/* Multimedia device */
DECL|enumerator|PARPORT_CLASS_FDC
id|PARPORT_CLASS_FDC
comma
multiline_comment|/* Floppy disk controller */
DECL|enumerator|PARPORT_CLASS_PORTS
id|PARPORT_CLASS_PORTS
comma
DECL|enumerator|PARPORT_CLASS_SCANNER
id|PARPORT_CLASS_SCANNER
comma
DECL|enumerator|PARPORT_CLASS_DIGCAM
id|PARPORT_CLASS_DIGCAM
comma
DECL|enumerator|PARPORT_CLASS_OTHER
id|PARPORT_CLASS_OTHER
comma
multiline_comment|/* Anything else */
DECL|enumerator|PARPORT_CLASS_UNSPEC
id|PARPORT_CLASS_UNSPEC
multiline_comment|/* No CLS field in ID */
DECL|typedef|parport_device_class
)brace
id|parport_device_class
suffix:semicolon
DECL|struct|parport_device_info
r_struct
id|parport_device_info
(brace
DECL|member|class
id|parport_device_class
r_class
suffix:semicolon
DECL|member|mfr
r_char
op_star
id|mfr
suffix:semicolon
DECL|member|model
r_char
op_star
id|model
suffix:semicolon
DECL|member|cmdset
r_char
op_star
id|cmdset
suffix:semicolon
DECL|member|description
r_char
op_star
id|description
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Definitions for parallel port sharing */
multiline_comment|/* Forward declare some stuff so we can use mutually circular structures */
r_struct
id|ppd
suffix:semicolon
r_struct
id|parport
suffix:semicolon
multiline_comment|/* Each device can have two callback functions:&n; *  1) a preemption function, called by the resource manager to request&n; *     that the driver relinquish control of the port.  The driver should&n; *     return zero if it agrees to release the port, and nonzero if it &n; *     refuses.  Do not call parport_release() - the kernel will do this&n; *     implicitly.&n; *&n; *  2) a wake-up function, called by the resource manager to tell drivers&n; *     that the port is available to be claimed.  If a driver wants to use&n; *     the port, it should call parport_claim() here.  The return value from&n; *     this function is ignored.&n; */
DECL|typedef|callback_func
r_typedef
r_int
(paren
op_star
id|callback_func
)paren
(paren
r_void
op_star
)paren
suffix:semicolon
multiline_comment|/* This is an ordinary kernel IRQ handler routine.&n; * The dev_id field (void *) will point the the port structure&n; * associated with the interrupt request (to allow IRQ sharing)&n; * Please make code IRQ sharing as this function may be called&n; * when it isn&squot;t meant for you...&n; */
DECL|typedef|irq_handler_func
r_typedef
r_void
(paren
op_star
id|irq_handler_func
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
multiline_comment|/* A parallel port device */
DECL|struct|ppd
r_struct
id|ppd
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|port
r_struct
id|parport
op_star
id|port
suffix:semicolon
multiline_comment|/* The port this is associated with */
DECL|member|preempt
id|callback_func
id|preempt
suffix:semicolon
multiline_comment|/* preemption function */
DECL|member|wakeup
id|callback_func
id|wakeup
suffix:semicolon
multiline_comment|/* kick function */
DECL|member|private
r_void
op_star
r_private
suffix:semicolon
DECL|member|irq_func
id|irq_handler_func
id|irq_func
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
DECL|member|ctr
r_int
r_char
id|ctr
suffix:semicolon
multiline_comment|/* SPP CTR register */
DECL|member|ecr
r_int
r_char
id|ecr
suffix:semicolon
multiline_comment|/* ECP ECR register */
DECL|member|next
r_struct
id|ppd
op_star
id|next
suffix:semicolon
DECL|member|prev
r_struct
id|ppd
op_star
id|prev
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* A parallel port */
DECL|struct|parport
r_struct
id|parport
(brace
DECL|member|base
r_int
r_int
id|base
suffix:semicolon
multiline_comment|/* base address */
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
multiline_comment|/* IO extent */
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* interrupt (or -1 for none) */
DECL|member|dma
r_int
id|dma
suffix:semicolon
DECL|member|modes
r_int
r_int
id|modes
suffix:semicolon
DECL|member|devices
r_struct
id|ppd
op_star
id|devices
suffix:semicolon
DECL|member|cad
r_struct
id|ppd
op_star
id|cad
suffix:semicolon
multiline_comment|/* port owner */
DECL|member|lurker
r_struct
id|ppd
op_star
id|lurker
suffix:semicolon
DECL|member|ctr
r_int
r_int
id|ctr
suffix:semicolon
multiline_comment|/* SPP CTR register */
DECL|member|ecr
r_int
r_int
id|ecr
suffix:semicolon
multiline_comment|/* ECP ECR register */
DECL|member|next
r_struct
id|parport
op_star
id|next
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|proc_dir
r_struct
id|proc_dir_entry
op_star
id|proc_dir
suffix:semicolon
DECL|member|probe_info
r_struct
id|parport_device_info
id|probe_info
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* parport_register_port registers a new parallel port at the given address (if&n; * one does not already exist) and returns a pointer to it.  This entails&n; * claiming the I/O region, IRQ and DMA.&n; * NULL is returned if initialisation fails. &n; */
r_struct
id|parport
op_star
id|parport_register_port
c_func
(paren
r_int
r_int
id|base
comma
r_int
id|irq
comma
r_int
id|dma
)paren
suffix:semicolon
multiline_comment|/* parport_in_use returns nonzero if there are devices attached to a port. */
DECL|macro|parport_in_use
mdefine_line|#define parport_in_use(x)  ((x)-&gt;devices != NULL)
multiline_comment|/* parport_destroy blows away a parallel port.  This fails if any devices are&n; * registered.&n; */
r_void
id|parport_destroy
c_func
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
multiline_comment|/* parport_enumerate returns a pointer to the linked list of all the ports&n; * in this machine.&n; */
r_struct
id|parport
op_star
id|parport_enumerate
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* parport_register_device declares that a device is connected to a port, and &n; * tells the kernel all it needs to know.  &n; * pf is the preemption function (may be NULL for a transient driver)&n; * kf is the wake-up function (may be NULL for a transient driver)&n; * irq_func is the interrupt handler (may be NULL for no interrupts)&n; * Only one lurking driver can be used on a given port. &n; * handle is a user pointer that gets handed to callback functions. &n; */
r_struct
id|ppd
op_star
id|parport_register_device
c_func
(paren
r_struct
id|parport
op_star
id|port
comma
r_const
r_char
op_star
id|name
comma
id|callback_func
id|pf
comma
id|callback_func
id|kf
comma
id|irq_handler_func
id|irq_func
comma
r_int
id|flags
comma
r_void
op_star
id|handle
)paren
suffix:semicolon
multiline_comment|/* parport_deregister causes the kernel to forget about a device */
r_void
id|parport_unregister_device
c_func
(paren
r_struct
id|ppd
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* parport_claim tries to gain ownership of the port for a particular driver.&n; * This may fail (return non-zero) if another driver is busy.  If this&n; * driver has registered an interrupt handler, it will be enabled. &n; */
r_int
id|parport_claim
c_func
(paren
r_struct
id|ppd
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* parport_release reverses a previous parport_claim.  This can never fail, &n; * though the effects are undefined (except that they are bad) if you didn&squot;t&n; * previously own the port.  Once you have released the port you should make&n; * sure that neither your code nor the hardware on the port tries to initiate&n; * any communication without first re-claiming the port.&n; * If you mess with the port state (enabling ECP for example) you should&n; * clean up before releasing the port. &n; */
r_void
id|parport_release
c_func
(paren
r_struct
id|ppd
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* The &quot;modes&quot; entry in parport is a bit field representing the following&n; * modes.&n; * Note that LP_ECPEPP is for the SMC EPP+ECP mode which is NOT&n; * 100% compatible with EPP.&n; */
DECL|macro|PARPORT_MODE_SPP
mdefine_line|#define PARPORT_MODE_SPP&t;        0x0001
DECL|macro|PARPORT_MODE_PS2
mdefine_line|#define PARPORT_MODE_PS2&t;&t;0x0002
DECL|macro|PARPORT_MODE_EPP
mdefine_line|#define PARPORT_MODE_EPP&t;&t;0x0004
DECL|macro|PARPORT_MODE_ECP
mdefine_line|#define PARPORT_MODE_ECP&t;&t;0x0008
DECL|macro|PARPORT_MODE_ECPEPP
mdefine_line|#define PARPORT_MODE_ECPEPP&t;&t;0x0010
DECL|macro|PARPORT_MODE_ECR
mdefine_line|#define PARPORT_MODE_ECR&t;&t;0x0020  /* ECR Register Exists */
DECL|macro|PARPORT_MODE_ECPPS2
mdefine_line|#define PARPORT_MODE_ECPPS2&t;&t;0x0040
multiline_comment|/* Flags used to identify what a device does&n; */
DECL|macro|PARPORT_DEV_TRAN
mdefine_line|#define PARPORT_DEV_TRAN&t;        0x0000
DECL|macro|PARPORT_DEV_LURK
mdefine_line|#define PARPORT_DEV_LURK&t;        0x0001
DECL|macro|PARPORT_FLAG_COMA
mdefine_line|#define PARPORT_FLAG_COMA&t;&t;1
r_extern
r_int
id|parport_ieee1284_nibble_mode_ok
c_func
(paren
r_struct
id|parport
op_star
comma
r_int
r_char
)paren
suffix:semicolon
r_extern
r_int
id|parport_wait_peripheral
c_func
(paren
r_struct
id|parport
op_star
comma
r_int
r_char
comma
r_int
r_char
)paren
suffix:semicolon
multiline_comment|/* Prototypes from parport_procfs */
r_extern
r_int
id|parport_proc_register
c_func
(paren
r_struct
id|parport
op_star
id|pp
)paren
suffix:semicolon
r_extern
r_void
id|parport_proc_unregister
c_func
(paren
r_struct
id|parport
op_star
id|pp
)paren
suffix:semicolon
multiline_comment|/* Prototypes from parport_ksyms.c */
r_extern
r_void
id|dec_parport_count
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|inc_parport_count
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|parport_probe
c_func
(paren
r_struct
id|parport
op_star
id|port
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
suffix:semicolon
r_extern
r_void
id|parport_probe_one
c_func
(paren
r_struct
id|parport
op_star
id|port
)paren
suffix:semicolon
multiline_comment|/* Primitive port access functions */
DECL|function|parport_w_ctrl
r_extern
r_inline
r_void
id|parport_w_ctrl
c_func
(paren
r_struct
id|parport
op_star
id|port
comma
r_int
id|val
)paren
(brace
id|outb
c_func
(paren
id|val
comma
id|port-&gt;base
op_plus
l_int|2
)paren
suffix:semicolon
)brace
DECL|function|parport_r_ctrl
r_extern
r_inline
r_int
id|parport_r_ctrl
c_func
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
r_return
id|inb
c_func
(paren
id|port-&gt;base
op_plus
l_int|2
)paren
suffix:semicolon
)brace
DECL|function|parport_w_data
r_extern
r_inline
r_void
id|parport_w_data
c_func
(paren
r_struct
id|parport
op_star
id|port
comma
r_int
id|val
)paren
(brace
id|outb
c_func
(paren
id|val
comma
id|port-&gt;base
)paren
suffix:semicolon
)brace
DECL|function|parport_r_data
r_extern
r_inline
r_int
id|parport_r_data
c_func
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
r_return
id|inb
c_func
(paren
id|port-&gt;base
)paren
suffix:semicolon
)brace
DECL|function|parport_r_status
r_extern
r_inline
r_int
id|parport_r_status
c_func
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
r_return
id|inb
c_func
(paren
id|port-&gt;base
op_plus
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif /* _PARPORT_H_ */
eof
