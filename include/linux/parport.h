multiline_comment|/* $Id: parport.h,v 1.2.6.3.2.2 1997/04/18 15:03:53 phil Exp $ */
macro_line|#ifndef _PARPORT_H_
DECL|macro|_PARPORT_H_
mdefine_line|#define _PARPORT_H_
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
multiline_comment|/* Maximum of 8 ports per machine */
DECL|macro|PARPORT_MAX
mdefine_line|#define PARPORT_MAX  8 
multiline_comment|/* Magic numbers */
DECL|macro|PARPORT_IRQ_NONE
mdefine_line|#define PARPORT_IRQ_NONE  -2
DECL|macro|PARPORT_DMA_NONE
mdefine_line|#define PARPORT_DMA_NONE  -2
DECL|macro|PARPORT_IRQ_AUTO
mdefine_line|#define PARPORT_IRQ_AUTO  -1
DECL|macro|PARPORT_DMA_AUTO
mdefine_line|#define PARPORT_DMA_AUTO  -1
DECL|macro|PARPORT_DISABLE
mdefine_line|#define PARPORT_DISABLE   -2
multiline_comment|/* Define this later. */
r_struct
id|parport
suffix:semicolon
DECL|struct|pc_parport_state
r_struct
id|pc_parport_state
(brace
DECL|member|ctr
r_int
r_int
id|ctr
suffix:semicolon
DECL|member|ecr
r_int
r_int
id|ecr
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|parport_state
r_struct
id|parport_state
(brace
r_union
(brace
DECL|member|pc
r_struct
id|pc_parport_state
id|pc
suffix:semicolon
multiline_comment|/* ARC has no state. */
DECL|member|misc
r_void
op_star
id|misc
suffix:semicolon
DECL|member|u
)brace
id|u
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Generic operations vector through the dispatch table. */
DECL|macro|parport_write_data
mdefine_line|#define parport_write_data(p,x)            (p)-&gt;ops-&gt;write_data(p,x)
DECL|macro|parport_read_data
mdefine_line|#define parport_read_data(p)               (p)-&gt;ops-&gt;read_data(p)
DECL|macro|parport_write_control
mdefine_line|#define parport_write_control(p,x)         (p)-&gt;ops-&gt;write_control(p,x)
DECL|macro|parport_read_control
mdefine_line|#define parport_read_control(p)            (p)-&gt;ops-&gt;read_control(p)
DECL|macro|parport_frob_control
mdefine_line|#define parport_frob_control(p,m,v)        (p)-&gt;ops-&gt;frob_control(p,m,v)
DECL|macro|parport_write_econtrol
mdefine_line|#define parport_write_econtrol(p,x)        (p)-&gt;ops-&gt;write_econtrol(p,x)
DECL|macro|parport_read_econtrol
mdefine_line|#define parport_read_econtrol(p)           (p)-&gt;ops-&gt;read_econtrol(p)
DECL|macro|parport_frob_econtrol
mdefine_line|#define parport_frob_econtrol(p,m,v)       (p)-&gt;ops-&gt;frob_econtrol(p,m,v)
DECL|macro|parport_write_status
mdefine_line|#define parport_write_status(p,v)          (p)-&gt;ops-&gt;write_status(p,v)
DECL|macro|parport_read_status
mdefine_line|#define parport_read_status(p)             (p)-&gt;ops-&gt;read_status(p)
DECL|macro|parport_write_fifo
mdefine_line|#define parport_write_fifo(p,v)            (p)-&gt;ops-&gt;write_fifo(p,v)
DECL|macro|parport_read_fifo
mdefine_line|#define parport_read_fifo(p)               (p)-&gt;ops-&gt;read_fifo(p)
DECL|macro|parport_change_mode
mdefine_line|#define parport_change_mode(p,m)           (p)-&gt;ops-&gt;change_mode(p,m)
DECL|macro|parport_release_resources
mdefine_line|#define parport_release_resources(p)       (p)-&gt;ops-&gt;release_resources(p)
DECL|macro|parport_claim_resources
mdefine_line|#define parport_claim_resources(p)         (p)-&gt;ops-&gt;claim_resources(p)
DECL|struct|parport_operations
r_struct
id|parport_operations
(brace
DECL|member|write_data
r_void
(paren
op_star
id|write_data
)paren
(paren
r_struct
id|parport
op_star
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|read_data
r_int
r_int
(paren
op_star
id|read_data
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|write_control
r_void
(paren
op_star
id|write_control
)paren
(paren
r_struct
id|parport
op_star
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|read_control
r_int
r_int
(paren
op_star
id|read_control
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|frob_control
r_int
r_int
(paren
op_star
id|frob_control
)paren
(paren
r_struct
id|parport
op_star
comma
r_int
r_int
id|mask
comma
r_int
r_int
id|val
)paren
suffix:semicolon
DECL|member|write_econtrol
r_void
(paren
op_star
id|write_econtrol
)paren
(paren
r_struct
id|parport
op_star
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|read_econtrol
r_int
r_int
(paren
op_star
id|read_econtrol
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|frob_econtrol
r_int
r_int
(paren
op_star
id|frob_econtrol
)paren
(paren
r_struct
id|parport
op_star
comma
r_int
r_int
id|mask
comma
r_int
r_int
id|val
)paren
suffix:semicolon
DECL|member|write_status
r_void
(paren
op_star
id|write_status
)paren
(paren
r_struct
id|parport
op_star
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|read_status
r_int
r_int
(paren
op_star
id|read_status
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|write_fifo
r_void
(paren
op_star
id|write_fifo
)paren
(paren
r_struct
id|parport
op_star
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|read_fifo
r_int
r_int
(paren
op_star
id|read_fifo
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|change_mode
r_void
(paren
op_star
id|change_mode
)paren
(paren
r_struct
id|parport
op_star
comma
r_int
)paren
suffix:semicolon
DECL|member|release_resources
r_void
(paren
op_star
id|release_resources
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|claim_resources
r_int
(paren
op_star
id|claim_resources
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|epp_write_block
r_int
r_int
(paren
op_star
id|epp_write_block
)paren
(paren
r_struct
id|parport
op_star
comma
r_void
op_star
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|epp_read_block
r_int
r_int
(paren
op_star
id|epp_read_block
)paren
(paren
r_struct
id|parport
op_star
comma
r_void
op_star
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|ecp_write_block
r_int
r_int
(paren
op_star
id|ecp_write_block
)paren
(paren
r_struct
id|parport
op_star
comma
r_void
op_star
comma
r_int
r_int
comma
r_void
(paren
op_star
id|fn
)paren
(paren
r_struct
id|parport
op_star
comma
r_void
op_star
comma
r_int
r_int
)paren
comma
r_void
op_star
)paren
suffix:semicolon
DECL|member|ecp_read_block
r_int
r_int
(paren
op_star
id|ecp_read_block
)paren
(paren
r_struct
id|parport
op_star
comma
r_void
op_star
comma
r_int
r_int
comma
r_void
(paren
op_star
id|fn
)paren
(paren
r_struct
id|parport
op_star
comma
r_void
op_star
comma
r_int
r_int
)paren
comma
r_void
op_star
)paren
suffix:semicolon
DECL|member|save_state
r_void
(paren
op_star
id|save_state
)paren
(paren
r_struct
id|parport
op_star
comma
r_struct
id|parport_state
op_star
)paren
suffix:semicolon
DECL|member|restore_state
r_void
(paren
op_star
id|restore_state
)paren
(paren
r_struct
id|parport
op_star
comma
r_struct
id|parport_state
op_star
)paren
suffix:semicolon
DECL|member|enable_irq
r_void
(paren
op_star
id|enable_irq
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|disable_irq
r_void
(paren
op_star
id|disable_irq
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
DECL|member|examine_irq
r_int
(paren
op_star
id|examine_irq
)paren
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|PARPORT_CONTROL_STROBE
mdefine_line|#define PARPORT_CONTROL_STROBE    0x1
DECL|macro|PARPORT_CONTROL_AUTOFD
mdefine_line|#define PARPORT_CONTROL_AUTOFD    0x2
DECL|macro|PARPORT_CONTROL_INIT
mdefine_line|#define PARPORT_CONTROL_INIT      0x4
DECL|macro|PARPORT_CONTROL_SELECT
mdefine_line|#define PARPORT_CONTROL_SELECT    0x8
DECL|macro|PARPORT_CONTROL_INTEN
mdefine_line|#define PARPORT_CONTROL_INTEN     0x10
DECL|macro|PARPORT_CONTROL_DIRECTION
mdefine_line|#define PARPORT_CONTROL_DIRECTION 0x20
DECL|macro|PARPORT_STATUS_ERROR
mdefine_line|#define PARPORT_STATUS_ERROR      0x8
DECL|macro|PARPORT_STATUS_SELECT
mdefine_line|#define PARPORT_STATUS_SELECT     0x10
DECL|macro|PARPORT_STATUS_PAPEROUT
mdefine_line|#define PARPORT_STATUS_PAPEROUT   0x20
DECL|macro|PARPORT_STATUS_ACK
mdefine_line|#define PARPORT_STATUS_ACK        0x40
DECL|macro|PARPORT_STATUS_BUSY
mdefine_line|#define PARPORT_STATUS_BUSY       0x80
multiline_comment|/* Type classes for Plug-and-Play probe.  */
r_typedef
r_enum
(brace
DECL|enumerator|PARPORT_CLASS_LEGACY
id|PARPORT_CLASS_LEGACY
op_assign
l_int|0
comma
multiline_comment|/* Non-IEEE1284 device */
DECL|enumerator|PARPORT_CLASS_PRINTER
id|PARPORT_CLASS_PRINTER
comma
DECL|enumerator|PARPORT_CLASS_MODEM
id|PARPORT_CLASS_MODEM
comma
DECL|enumerator|PARPORT_CLASS_NET
id|PARPORT_CLASS_NET
comma
DECL|enumerator|PARPORT_CLASS_HDC
id|PARPORT_CLASS_HDC
comma
multiline_comment|/* Hard disk controller */
DECL|enumerator|PARPORT_CLASS_PCMCIA
id|PARPORT_CLASS_PCMCIA
comma
DECL|enumerator|PARPORT_CLASS_MEDIA
id|PARPORT_CLASS_MEDIA
comma
multiline_comment|/* Multimedia device */
DECL|enumerator|PARPORT_CLASS_FDC
id|PARPORT_CLASS_FDC
comma
multiline_comment|/* Floppy disk controller */
DECL|enumerator|PARPORT_CLASS_PORTS
id|PARPORT_CLASS_PORTS
comma
DECL|enumerator|PARPORT_CLASS_SCANNER
id|PARPORT_CLASS_SCANNER
comma
DECL|enumerator|PARPORT_CLASS_DIGCAM
id|PARPORT_CLASS_DIGCAM
comma
DECL|enumerator|PARPORT_CLASS_OTHER
id|PARPORT_CLASS_OTHER
comma
multiline_comment|/* Anything else */
DECL|enumerator|PARPORT_CLASS_UNSPEC
id|PARPORT_CLASS_UNSPEC
multiline_comment|/* No CLS field in ID */
DECL|typedef|parport_device_class
)brace
id|parport_device_class
suffix:semicolon
DECL|struct|parport_device_info
r_struct
id|parport_device_info
(brace
DECL|member|class
id|parport_device_class
r_class
suffix:semicolon
DECL|member|mfr
r_char
op_star
id|mfr
suffix:semicolon
DECL|member|model
r_char
op_star
id|model
suffix:semicolon
DECL|member|cmdset
r_char
op_star
id|cmdset
suffix:semicolon
DECL|member|description
r_char
op_star
id|description
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Each device can have two callback functions:&n; *  1) a preemption function, called by the resource manager to request&n; *     that the driver relinquish control of the port.  The driver should&n; *     return zero if it agrees to release the port, and nonzero if it &n; *     refuses.  Do not call parport_release() - the kernel will do this&n; *     implicitly.&n; *&n; *  2) a wake-up function, called by the resource manager to tell drivers&n; *     that the port is available to be claimed.  If a driver wants to use&n; *     the port, it should call parport_claim() here.  The return value from&n; *     this function is ignored.&n; */
multiline_comment|/* A parallel port device */
DECL|struct|pardevice
r_struct
id|pardevice
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|port
r_struct
id|parport
op_star
id|port
suffix:semicolon
DECL|member|preempt
r_int
(paren
op_star
id|preempt
)paren
(paren
r_void
op_star
)paren
suffix:semicolon
DECL|member|wakeup
r_void
(paren
op_star
id|wakeup
)paren
(paren
r_void
op_star
)paren
suffix:semicolon
DECL|member|private
r_void
op_star
r_private
suffix:semicolon
DECL|member|irq_func
r_void
(paren
op_star
id|irq_func
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
DECL|member|next
r_struct
id|pardevice
op_star
id|next
suffix:semicolon
DECL|member|prev
r_struct
id|pardevice
op_star
id|prev
suffix:semicolon
DECL|member|state
r_struct
id|parport_state
op_star
id|state
suffix:semicolon
multiline_comment|/* saved status over preemption */
)brace
suffix:semicolon
DECL|struct|parport_dir
r_struct
id|parport_dir
(brace
DECL|member|entry
r_struct
id|proc_dir_entry
op_star
id|entry
suffix:semicolon
multiline_comment|/* Directory /proc/parport/X     */
DECL|member|irq
r_struct
id|proc_dir_entry
op_star
id|irq
suffix:semicolon
multiline_comment|/* IRQ entry /proc/parport/X/irq */
DECL|member|devices
r_struct
id|proc_dir_entry
op_star
id|devices
suffix:semicolon
multiline_comment|/* /proc/parport/X/devices       */
DECL|member|hardware
r_struct
id|proc_dir_entry
op_star
id|hardware
suffix:semicolon
multiline_comment|/* /proc/parport/X/hardware      */
DECL|member|name
r_char
id|name
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* /proc/parport/&quot;XXXX&quot; */
)brace
suffix:semicolon
multiline_comment|/* A parallel port */
DECL|struct|parport
r_struct
id|parport
(brace
DECL|member|base
r_int
r_int
id|base
suffix:semicolon
multiline_comment|/* base address */
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
multiline_comment|/* IO extent */
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* interrupt (or -1 for none) */
DECL|member|dma
r_int
id|dma
suffix:semicolon
DECL|member|modes
r_int
r_int
id|modes
suffix:semicolon
DECL|member|devices
r_struct
id|pardevice
op_star
id|devices
suffix:semicolon
DECL|member|cad
r_struct
id|pardevice
op_star
id|cad
suffix:semicolon
multiline_comment|/* port owner */
DECL|member|lurker
r_struct
id|pardevice
op_star
id|lurker
suffix:semicolon
DECL|member|next
r_struct
id|parport
op_star
id|next
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|pdir
r_struct
id|parport_dir
id|pdir
suffix:semicolon
DECL|member|probe_info
r_struct
id|parport_device_info
id|probe_info
suffix:semicolon
DECL|member|ops
r_struct
id|parport_operations
op_star
id|ops
suffix:semicolon
DECL|member|private_data
r_void
op_star
id|private_data
suffix:semicolon
multiline_comment|/* for lowlevel driver */
)brace
suffix:semicolon
multiline_comment|/* parport_register_port registers a new parallel port at the given address (if&n; * one does not already exist) and returns a pointer to it.  This entails&n; * claiming the I/O region, IRQ and DMA.&n; * NULL is returned if initialisation fails. &n; */
r_struct
id|parport
op_star
id|parport_register_port
c_func
(paren
r_int
r_int
id|base
comma
r_int
id|irq
comma
r_int
id|dma
comma
r_struct
id|parport_operations
op_star
id|ops
)paren
suffix:semicolon
multiline_comment|/* parport_in_use returns nonzero if there are devices attached to a port. */
DECL|macro|parport_in_use
mdefine_line|#define parport_in_use(x)  ((x)-&gt;devices != NULL)
multiline_comment|/* Put a parallel port to sleep; release its hardware resources.  Only possible&n; * if no devices are registered.  */
r_void
id|parport_quiesce
c_func
(paren
r_struct
id|parport
op_star
)paren
suffix:semicolon
multiline_comment|/* parport_enumerate returns a pointer to the linked list of all the ports&n; * in this machine.&n; */
r_struct
id|parport
op_star
id|parport_enumerate
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* parport_register_device declares that a device is connected to a port, and &n; * tells the kernel all it needs to know.  &n; * pf is the preemption function (may be NULL for a transient driver)&n; * kf is the wake-up function (may be NULL for a transient driver)&n; * irq_func is the interrupt handler (may be NULL for no interrupts)&n; * Only one lurking driver can be used on a given port. &n; * handle is a user pointer that gets handed to callback functions. &n; */
r_struct
id|pardevice
op_star
id|parport_register_device
c_func
(paren
r_struct
id|parport
op_star
id|port
comma
r_const
r_char
op_star
id|name
comma
r_int
(paren
op_star
id|pf
)paren
(paren
r_void
op_star
)paren
comma
r_int
(paren
op_star
id|kf
)paren
(paren
r_void
op_star
)paren
comma
r_void
(paren
op_star
id|irq_func
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
id|flags
comma
r_void
op_star
id|handle
)paren
suffix:semicolon
multiline_comment|/* parport_unregister unlinks a device from the chain. */
r_void
id|parport_unregister_device
c_func
(paren
r_struct
id|pardevice
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* parport_claim tries to gain ownership of the port for a particular driver.&n; * This may fail (return non-zero) if another driver is busy.  If this&n; * driver has registered an interrupt handler, it will be enabled. &n; */
r_int
id|parport_claim
c_func
(paren
r_struct
id|pardevice
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* parport_release reverses a previous parport_claim.  This can never fail, &n; * though the effects are undefined (except that they are bad) if you didn&squot;t&n; * previously own the port.  Once you have released the port you should make&n; * sure that neither your code nor the hardware on the port tries to initiate&n; * any communication without first re-claiming the port.&n; * If you mess with the port state (enabling ECP for example) you should&n; * clean up before releasing the port. &n; */
r_void
id|parport_release
c_func
(paren
r_struct
id|pardevice
op_star
id|dev
)paren
suffix:semicolon
multiline_comment|/* The &quot;modes&quot; entry in parport is a bit field representing the following&n; * modes.&n; * Note that LP_ECPEPP is for the SMC EPP+ECP mode which is NOT&n; * 100% compatible with EPP.&n; */
DECL|macro|PARPORT_MODE_PCSPP
mdefine_line|#define PARPORT_MODE_PCSPP&t;        0x0001
DECL|macro|PARPORT_MODE_PCPS2
mdefine_line|#define PARPORT_MODE_PCPS2&t;&t;0x0002
DECL|macro|PARPORT_MODE_PCEPP
mdefine_line|#define PARPORT_MODE_PCEPP&t;&t;0x0004
DECL|macro|PARPORT_MODE_PCECP
mdefine_line|#define PARPORT_MODE_PCECP&t;&t;0x0008
DECL|macro|PARPORT_MODE_PCECPEPP
mdefine_line|#define PARPORT_MODE_PCECPEPP&t;&t;0x0010
DECL|macro|PARPORT_MODE_PCECR
mdefine_line|#define PARPORT_MODE_PCECR&t;&t;0x0020  /* ECR Register Exists */
DECL|macro|PARPORT_MODE_PCECPPS2
mdefine_line|#define PARPORT_MODE_PCECPPS2&t;&t;0x0040
multiline_comment|/* Flags used to identify what a device does. */
DECL|macro|PARPORT_DEV_TRAN
mdefine_line|#define PARPORT_DEV_TRAN&t;        0x0000  /* We&squot;re transient. */
DECL|macro|PARPORT_DEV_LURK
mdefine_line|#define PARPORT_DEV_LURK&t;        0x0001  /* We lurk. */
DECL|macro|PARPORT_FLAG_COMA
mdefine_line|#define PARPORT_FLAG_COMA&t;&t;1
r_extern
r_int
id|parport_ieee1284_nibble_mode_ok
c_func
(paren
r_struct
id|parport
op_star
comma
r_int
r_char
)paren
suffix:semicolon
r_extern
r_int
id|parport_wait_peripheral
c_func
(paren
r_struct
id|parport
op_star
comma
r_int
r_char
comma
r_int
r_char
)paren
suffix:semicolon
multiline_comment|/* Prototypes from parport_procfs */
r_extern
r_int
id|parport_proc_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|parport_proc_cleanup
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|parport_proc_register
c_func
(paren
r_struct
id|parport
op_star
id|pp
)paren
suffix:semicolon
r_extern
r_int
id|parport_proc_unregister
c_func
(paren
r_struct
id|parport
op_star
id|pp
)paren
suffix:semicolon
multiline_comment|/* Prototypes from parport_ksyms.c */
r_extern
r_void
id|dec_parport_count
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|inc_parport_count
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|parport_probe
c_func
(paren
r_struct
id|parport
op_star
id|port
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
suffix:semicolon
r_extern
r_void
id|parport_probe_one
c_func
(paren
r_struct
id|parport
op_star
id|port
)paren
suffix:semicolon
macro_line|#endif /* _PARPORT_H_ */
eof
