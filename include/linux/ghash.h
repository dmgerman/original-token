multiline_comment|/*&n; * include/linux/ghash.h -- generic hashing with fuzzy retrieval&n; *&n; * (C) 1997 Thomas Schoebel-Theuer&n; *&n; * The algorithms implemented here seem to be a completely new invention,&n; * and I&squot;ll publish the fundamentals in a paper.&n; */
macro_line|#ifndef _GHASH_H
DECL|macro|_GHASH_H
mdefine_line|#define _GHASH_H
multiline_comment|/* HASHSIZE _must_ be a power of two!!! */
DECL|macro|DEF_HASH_FUZZY_STRUCTS
mdefine_line|#define DEF_HASH_FUZZY_STRUCTS(NAME,HASHSIZE,TYPE) &bslash;&n;&bslash;&n;struct NAME##_table {&bslash;&n;&t;TYPE * hashtable[HASHSIZE];&bslash;&n;&t;TYPE * sorted_list;&bslash;&n;&t;int nr_entries;&bslash;&n;};&bslash;&n;&bslash;&n;struct NAME##_ptrs {&bslash;&n;&t;TYPE * next_hash;&bslash;&n;&t;TYPE * prev_hash;&bslash;&n;&t;TYPE * next_sorted;&bslash;&n;&t;TYPE * prev_sorted;&bslash;&n;};
DECL|macro|DEF_HASH_FUZZY
mdefine_line|#define DEF_HASH_FUZZY(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)&bslash;&n;&bslash;&n;LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)&bslash;&n;{&bslash;&n;&t;int ix = HASHFN(elem-&gt;KEY);&bslash;&n;&t;TYPE ** base = &amp;tbl-&gt;hashtable[ix];&bslash;&n;&t;TYPE * ptr = *base;&bslash;&n;&t;TYPE * prev = NULL;&bslash;&n;&bslash;&n;&t;tbl-&gt;nr_entries++;&bslash;&n;&t;while(ptr &amp;&amp; KEYCMP(ptr-&gt;KEY, elem-&gt;KEY)) {&bslash;&n;&t;&t;base = &amp;ptr-&gt;PTRS.next_hash;&bslash;&n;&t;&t;prev = ptr;&bslash;&n;&t;&t;ptr = *base;&bslash;&n;&t;}&bslash;&n;&t;elem-&gt;PTRS.next_hash = ptr;&bslash;&n;&t;elem-&gt;PTRS.prev_hash = prev;&bslash;&n;&t;if(ptr) {&bslash;&n;&t;&t;ptr-&gt;PTRS.prev_hash = elem;&bslash;&n;&t;}&bslash;&n;&t;*base = elem;&bslash;&n;&bslash;&n;&t;ptr = prev;&bslash;&n;&t;if(!ptr) {&bslash;&n;&t;&t;ptr = tbl-&gt;sorted_list;&bslash;&n;&t;&t;prev = NULL;&bslash;&n;&t;} else {&bslash;&n;&t;&t;prev = ptr-&gt;PTRS.prev_sorted;&bslash;&n;&t;}&bslash;&n;&t;while(ptr) {&bslash;&n;&t;&t;TYPE * next = ptr-&gt;PTRS.next_hash;&bslash;&n;&t;&t;if(next &amp;&amp; KEYCMP(next-&gt;KEY, elem-&gt;KEY)) {&bslash;&n;&t;&t;&t;prev = ptr;&bslash;&n;&t;&t;&t;ptr = next;&bslash;&n;&t;&t;} else if(KEYCMP(ptr-&gt;KEY, elem-&gt;KEY)) {&bslash;&n;&t;&t;&t;prev = ptr;&bslash;&n;&t;&t;&t;ptr = ptr-&gt;PTRS.next_sorted;&bslash;&n;&t;&t;} else&bslash;&n;&t;&t;&t;break;&bslash;&n;&t;}&bslash;&n;&t;elem-&gt;PTRS.next_sorted = ptr;&bslash;&n;&t;elem-&gt;PTRS.prev_sorted = prev;&bslash;&n;&t;if(ptr) {&bslash;&n;&t;&t;ptr-&gt;PTRS.prev_sorted = elem;&bslash;&n;&t;}&bslash;&n;&t;if(prev) {&bslash;&n;&t;&t;prev-&gt;PTRS.next_sorted = elem;&bslash;&n;&t;} else {&bslash;&n;&t;&t;tbl-&gt;sorted_list = elem;&bslash;&n;&t;}&bslash;&n;}&bslash;&n;&bslash;&n;LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)&bslash;&n;{&bslash;&n;&t;TYPE * next = elem-&gt;PTRS.next_hash;&bslash;&n;&t;TYPE * prev = elem-&gt;PTRS.prev_hash;&bslash;&n;&bslash;&n;&t;tbl-&gt;nr_entries--;&bslash;&n;&t;if(next)&bslash;&n;&t;&t;next-&gt;PTRS.prev_hash = prev;&bslash;&n;&t;if(prev)&bslash;&n;&t;&t;prev-&gt;PTRS.next_hash = next;&bslash;&n;&t;else {&bslash;&n;&t;&t;int ix = HASHFN(elem-&gt;KEY);&bslash;&n;&t;&t;tbl-&gt;hashtable[ix] = next;&bslash;&n;&t;}&bslash;&n;&bslash;&n;&t;next = elem-&gt;PTRS.next_sorted;&bslash;&n;&t;prev = elem-&gt;PTRS.prev_sorted;&bslash;&n;&t;if(next)&bslash;&n;&t;&t;next-&gt;PTRS.prev_sorted = prev;&bslash;&n;&t;if(prev)&bslash;&n;&t;&t;prev-&gt;PTRS.next_sorted = next;&bslash;&n;&t;else&bslash;&n;&t;&t;tbl-&gt;sorted_list = next;&bslash;&n;}&bslash;&n;&bslash;&n;LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)&bslash;&n;{&bslash;&n;&t;int ix = hashfn(pos);&bslash;&n;&t;TYPE * ptr = tbl-&gt;hashtable[ix];&bslash;&n;&t;while(ptr &amp;&amp; KEYCMP(ptr-&gt;KEY, pos))&bslash;&n;&t;&t;ptr = ptr-&gt;PTRS.next_hash;&bslash;&n;&t;if(ptr &amp;&amp; !KEYEQ(ptr-&gt;KEY, pos))&bslash;&n;&t;&t;ptr = NULL;&bslash;&n;&t;return ptr;&bslash;&n;}&bslash;&n;&bslash;&n;LINKAGE TYPE * find_##NAME##_hash_fuzzy(struct NAME##_table * tbl, KEYTYPE pos)&bslash;&n;{&bslash;&n;&t;int ix;&bslash;&n;&t;int offset;&bslash;&n;&t;TYPE * ptr;&bslash;&n;&t;TYPE * next;&bslash;&n;&bslash;&n;&t;ptr = tbl-&gt;sorted_list;&bslash;&n;&t;if(!ptr || KEYCMP(pos, ptr-&gt;KEY))&bslash;&n;&t;&t;return NULL;&bslash;&n;&t;ix = HASHFN(pos);&bslash;&n;&t;offset = HASHSIZE;&bslash;&n;&t;do {&bslash;&n;&t;&t;offset &gt;&gt;= 1;&bslash;&n;&t;&t;next = tbl-&gt;hashtable[(ix+offset) &amp; ((HASHSIZE)-1)];&bslash;&n;&t;&t;if(next &amp;&amp; (KEYCMP(next-&gt;KEY, pos) || KEYEQ(next-&gt;KEY, pos))&bslash;&n;&t;&t;   &amp;&amp; KEYCMP(ptr-&gt;KEY, next-&gt;KEY))&bslash;&n;&t;&t;&t;ptr = next;&bslash;&n;&t;} while(offset);&bslash;&n;&bslash;&n;&t;for(;;) {&bslash;&n;&t;&t;next = ptr-&gt;PTRS.next_hash;&bslash;&n;&t;&t;if(next) {&bslash;&n;&t;&t;&t;if(KEYCMP(next-&gt;KEY, pos)) {&bslash;&n;&t;&t;&t;&t;ptr = next;&bslash;&n;&t;&t;&t;&t;continue;&bslash;&n;&t;&t;&t;}&bslash;&n;&t;&t;}&bslash;&n;&t;&t;next = ptr-&gt;PTRS.next_sorted;&bslash;&n;&t;&t;if(next &amp;&amp; KEYCMP(next-&gt;KEY, pos)) {&bslash;&n;&t;&t;&t;ptr = next;&bslash;&n;&t;&t;&t;continue;&bslash;&n;&t;&t;}&bslash;&n;&t;&t;return ptr;&bslash;&n;&t;}&bslash;&n;&t;return NULL;&bslash;&n;}
DECL|macro|DEF_HASH_STRUCTS
mdefine_line|#define DEF_HASH_STRUCTS(NAME,HASHSIZE,TYPE) &bslash;&n;&bslash;&n;struct NAME##_table {&bslash;&n;&t;TYPE * hashtable[HASHSIZE];&bslash;&n;&t;int nr_entries;&bslash;&n;};&bslash;&n;&bslash;&n;struct NAME##_ptrs {&bslash;&n;&t;TYPE * next_hash;&bslash;&n;&t;TYPE * prev_hash;&bslash;&n;};
DECL|macro|DEF_HASH
mdefine_line|#define DEF_HASH(LINKAGE,NAME,HASHSIZE,TYPE,PTRS,KEYTYPE,KEY,KEYCMP,KEYEQ,HASHFN)&bslash;&n;&bslash;&n;LINKAGE void insert_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)&bslash;&n;{&bslash;&n;&t;int ix = HASHFN(elem-&gt;KEY);&bslash;&n;&t;TYPE ** base = &amp;tbl-&gt;hashtable[ix];&bslash;&n;&t;TYPE * ptr = *base;&bslash;&n;&t;TYPE * prev = NULL;&bslash;&n;&bslash;&n;&t;tbl-&gt;nr_entries++;&bslash;&n;&t;while(ptr &amp;&amp; KEYCMP(ptr-&gt;KEY, elem-&gt;KEY)) {&bslash;&n;&t;&t;base = &amp;ptr-&gt;PTRS.next_hash;&bslash;&n;&t;&t;prev = ptr;&bslash;&n;&t;&t;ptr = *base;&bslash;&n;&t;}&bslash;&n;&t;elem-&gt;PTRS.next_hash = ptr;&bslash;&n;&t;elem-&gt;PTRS.prev_hash = prev;&bslash;&n;&t;if(ptr) {&bslash;&n;&t;&t;ptr-&gt;PTRS.prev_hash = elem;&bslash;&n;&t;}&bslash;&n;&t;*base = elem;&bslash;&n;}&bslash;&n;&bslash;&n;LINKAGE void remove_##NAME##_hash(struct NAME##_table * tbl, TYPE * elem)&bslash;&n;{&bslash;&n;&t;TYPE * next = elem-&gt;PTRS.next_hash;&bslash;&n;&t;TYPE * prev = elem-&gt;PTRS.prev_hash;&bslash;&n;&bslash;&n;&t;tbl-&gt;nr_entries--;&bslash;&n;&t;if(next)&bslash;&n;&t;&t;next-&gt;PTRS.prev_hash = prev;&bslash;&n;&t;if(prev)&bslash;&n;&t;&t;prev-&gt;PTRS.next_hash = next;&bslash;&n;&t;else {&bslash;&n;&t;&t;int ix = HASHFN(elem-&gt;KEY);&bslash;&n;&t;&t;tbl-&gt;hashtable[ix] = next;&bslash;&n;&t;}&bslash;&n;}&bslash;&n;&bslash;&n;LINKAGE TYPE * find_##NAME##_hash(struct NAME##_table * tbl, KEYTYPE pos)&bslash;&n;{&bslash;&n;&t;int ix = hashfn(pos);&bslash;&n;&t;TYPE * ptr = tbl-&gt;hashtable[ix];&bslash;&n;&t;while(ptr &amp;&amp; KEYCMP(ptr-&gt;KEY, pos))&bslash;&n;&t;&t;ptr = ptr-&gt;PTRS.next_hash;&bslash;&n;&t;if(ptr &amp;&amp; !KEYEQ(ptr-&gt;KEY, pos))&bslash;&n;&t;&t;ptr = NULL;&bslash;&n;&t;return ptr;&bslash;&n;}
macro_line|#endif
eof
