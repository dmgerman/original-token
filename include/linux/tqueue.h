multiline_comment|/*&n; * tqueue.h --- task queue handling for Linux.&n; *&n; * Mostly based on a proposed bottom-half replacement code written by&n; * Kai Petzke, wpp@marie.physik.tu-berlin.de.&n; *&n; * Modified for use in the Linux kernel by Theodore Ts&squot;o,&n; * tytso@mit.edu.  Any bugs are my fault, not Kai&squot;s.&n; *&n; * The original comment follows below.&n; */
macro_line|#ifndef _LINUX_TQUEUE_H
DECL|macro|_LINUX_TQUEUE_H
mdefine_line|#define _LINUX_TQUEUE_H
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/system.h&gt;
multiline_comment|/*&n; * New proposed &quot;bottom half&quot; handlers:&n; * (C) 1994 Kai Petzke, wpp@marie.physik.tu-berlin.de&n; *&n; * Advantages:&n; * - Bottom halfs are implemented as a linked list.  You can have as many&n; *   of them, as you want.&n; * - No more scanning of a bit field is required upon call of a bottom half.&n; * - Support for chained bottom half lists.  The run_task_queue() function can be&n; *   used as a bottom half handler.  This is for example useful for bottom&n; *   halfs, which want to be delayed until the next clock tick.&n; *&n; * Notes:&n; * - Bottom halfs are called in the reverse order that they were linked into&n; *   the list.&n; */
DECL|struct|tq_struct
r_struct
id|tq_struct
(brace
DECL|member|next
r_struct
id|tq_struct
op_star
id|next
suffix:semicolon
multiline_comment|/* linked list of active bh&squot;s */
DECL|member|sync
r_int
r_int
id|sync
suffix:semicolon
multiline_comment|/* must be initialized to zero */
DECL|member|routine
r_void
(paren
op_star
id|routine
)paren
(paren
r_void
op_star
)paren
suffix:semicolon
multiline_comment|/* function to call */
DECL|member|data
r_void
op_star
id|data
suffix:semicolon
multiline_comment|/* argument to function */
)brace
suffix:semicolon
DECL|typedef|task_queue
r_typedef
r_struct
id|tq_struct
op_star
id|task_queue
suffix:semicolon
DECL|macro|DECLARE_TASK_QUEUE
mdefine_line|#define DECLARE_TASK_QUEUE(q)  task_queue q = NULL
r_extern
id|task_queue
id|tq_timer
comma
id|tq_immediate
comma
id|tq_disk
suffix:semicolon
multiline_comment|/*&n; * To implement your own list of active bottom halfs, use the following&n; * two definitions:&n; *&n; * struct tq_struct *my_bh = NULL;&n; * struct tq_struct run_my_bh = {&n; *&t;0, 0, (void (*)(void *)) run_task_queue, &amp;my_bh&n; * };&n; *&n; * To activate a bottom half on your list, use:&n; *&n; *     queue_task(tq_pointer, &amp;my_bh);&n; *&n; * To run the bottom halfs on your list put them on the immediate list by:&n; *&n; *     queue_task(&amp;run_my_bh, &amp;tq_immediate);&n; *&n; * This allows you to do deferred procession.  For example, you could&n; * have a bottom half list tq_timer, which is marked active by the timer&n; * interrupt.&n; */
r_extern
id|spinlock_t
id|tqueue_lock
suffix:semicolon
multiline_comment|/*&n; * Queue a task on a tq.  Return non-zero if it was successfully&n; * added.&n; */
DECL|function|queue_task
r_static
r_inline
r_int
id|queue_task
c_func
(paren
r_struct
id|tq_struct
op_star
id|bh_pointer
comma
id|task_queue
op_star
id|bh_list
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|bh_pointer-&gt;sync
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tqueue_lock
comma
id|flags
)paren
suffix:semicolon
id|bh_pointer-&gt;next
op_assign
op_star
id|bh_list
suffix:semicolon
op_star
id|bh_list
op_assign
id|bh_pointer
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tqueue_lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Call all &quot;bottom halfs&quot; on a given list.&n; */
DECL|function|run_task_queue
r_static
r_inline
r_void
id|run_task_queue
c_func
(paren
id|task_queue
op_star
id|list
)paren
(brace
r_if
c_cond
(paren
op_star
id|list
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|tq_struct
op_star
id|p
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tqueue_lock
comma
id|flags
)paren
suffix:semicolon
id|p
op_assign
op_star
id|list
suffix:semicolon
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tqueue_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|p
)paren
(brace
r_void
op_star
id|arg
suffix:semicolon
r_void
(paren
op_star
id|f
)paren
(paren
r_void
op_star
)paren
suffix:semicolon
r_struct
id|tq_struct
op_star
id|save_p
suffix:semicolon
id|arg
op_assign
id|p
op_member_access_from_pointer
id|data
suffix:semicolon
id|f
op_assign
id|p
op_member_access_from_pointer
id|routine
suffix:semicolon
id|save_p
op_assign
id|p
suffix:semicolon
id|p
op_assign
id|p
op_member_access_from_pointer
id|next
suffix:semicolon
id|smp_mb
c_func
(paren
)paren
suffix:semicolon
id|save_p
op_member_access_from_pointer
id|sync
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
(paren
op_star
id|f
)paren
(paren
id|arg
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* _LINUX_TQUEUE_H */
eof
