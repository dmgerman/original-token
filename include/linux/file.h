multiline_comment|/*&n; * Wrapper functions for accessing the file_struct fd array.&n; */
macro_line|#ifndef __LINUX_FILE_H
DECL|macro|__LINUX_FILE_H
mdefine_line|#define __LINUX_FILE_H
r_extern
r_int
id|__fput
c_func
(paren
r_struct
id|file
op_star
)paren
suffix:semicolon
r_extern
r_void
id|insert_file_free
c_func
(paren
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
multiline_comment|/*&n; * Check whether the specified task has the fd open. Since the task&n; * may not have a files_struct, we must test for p-&gt;files != NULL.&n; */
DECL|function|fcheck_task
r_extern
r_inline
r_struct
id|file
op_star
id|fcheck_task
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
r_int
id|fd
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;files
op_logical_and
id|fd
OL
id|p-&gt;files-&gt;max_fds
)paren
id|file
op_assign
id|p-&gt;files-&gt;fd
(braket
id|fd
)braket
suffix:semicolon
r_return
id|file
suffix:semicolon
)brace
multiline_comment|/*&n; * Check whether the specified fd has an open file.&n; */
DECL|function|fcheck
r_extern
r_inline
r_struct
id|file
op_star
id|fcheck
c_func
(paren
r_int
r_int
id|fd
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
id|current-&gt;files-&gt;max_fds
)paren
id|file
op_assign
id|current-&gt;files-&gt;fd
(braket
id|fd
)braket
suffix:semicolon
r_return
id|file
suffix:semicolon
)brace
DECL|function|fget
r_extern
r_inline
r_struct
id|file
op_star
id|fget
c_func
(paren
r_int
r_int
id|fd
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|fcheck
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
id|file-&gt;f_count
op_increment
suffix:semicolon
r_return
id|file
suffix:semicolon
)brace
multiline_comment|/*&n; * Install a file pointer in the fd array.&n; */
DECL|function|fd_install
r_extern
r_inline
r_void
id|fd_install
c_func
(paren
r_int
r_int
id|fd
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|current-&gt;files-&gt;fd
(braket
id|fd
)braket
op_assign
id|file
suffix:semicolon
)brace
multiline_comment|/* It does not matter which list it is on. */
DECL|function|remove_filp
r_extern
r_inline
r_void
id|remove_filp
c_func
(paren
r_struct
id|file
op_star
id|file
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_next
)paren
(brace
id|file-&gt;f_next-&gt;f_pprev
op_assign
id|file-&gt;f_pprev
suffix:semicolon
)brace
op_star
id|file-&gt;f_pprev
op_assign
id|file-&gt;f_next
suffix:semicolon
)brace
DECL|function|fput
r_extern
r_inline
r_int
id|fput
c_func
(paren
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|count
op_assign
id|file-&gt;f_count
op_minus
l_int|1
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
(brace
id|locks_remove_flock
c_func
(paren
id|file
)paren
suffix:semicolon
id|error
op_assign
id|__fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|file-&gt;f_count
op_assign
l_int|0
suffix:semicolon
id|remove_filp
c_func
(paren
id|file
)paren
suffix:semicolon
id|insert_file_free
c_func
(paren
id|file
)paren
suffix:semicolon
)brace
r_else
id|file-&gt;f_count
op_assign
id|count
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|put_filp
r_extern
r_inline
r_void
id|put_filp
c_func
(paren
r_struct
id|file
op_star
id|file
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|file-&gt;f_count
op_eq
l_int|0
)paren
(brace
id|remove_filp
c_func
(paren
id|file
)paren
suffix:semicolon
id|insert_file_free
c_func
(paren
id|file
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
eof
