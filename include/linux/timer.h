macro_line|#ifndef _LINUX_TIMER_H
DECL|macro|_LINUX_TIMER_H
mdefine_line|#define _LINUX_TIMER_H
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/list.h&gt;
multiline_comment|/*&n; * This is completely separate from the above, and is the&n; * &quot;new and improved&quot; way of handling timers more dynamically.&n; * Hopefully efficient and general enough for most things.&n; *&n; * The &quot;hardcoded&quot; timers above are still useful for well-&n; * defined problems, but the timer-list is probably better&n; * when you need multiple outstanding timers or similar.&n; *&n; * The &quot;data&quot; field is in case you want to use the same&n; * timeout function for several timeouts. You can use this&n; * to distinguish between the different invocations.&n; */
DECL|struct|timer_list
r_struct
id|timer_list
(brace
DECL|member|list
r_struct
id|list_head
id|list
suffix:semicolon
DECL|member|expires
r_int
r_int
id|expires
suffix:semicolon
DECL|member|data
r_int
r_int
id|data
suffix:semicolon
DECL|member|function
r_void
(paren
op_star
id|function
)paren
(paren
r_int
r_int
)paren
suffix:semicolon
)brace
suffix:semicolon
r_extern
r_void
id|add_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
suffix:semicolon
r_extern
r_int
id|del_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_extern
r_int
id|del_timer_sync
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
suffix:semicolon
r_extern
r_void
id|sync_timers
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#else
DECL|macro|del_timer_sync
mdefine_line|#define del_timer_sync(t)&t;del_timer(t)
DECL|macro|sync_timers
mdefine_line|#define sync_timers()&t;&t;do { } while (0)
macro_line|#endif
multiline_comment|/*&n; * mod_timer is a more efficient way to update the expire field of an&n; * active timer (if the timer is inactive it will be activated)&n; * mod_timer(a,b) is equivalent to del_timer(a); a-&gt;expires = b; add_timer(a).&n; * If the timer is known to be not pending (ie, in the handler), mod_timer&n; * is less efficient than a-&gt;expires = b; add_timer(a).&n; */
r_int
id|mod_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
comma
r_int
r_int
id|expires
)paren
suffix:semicolon
r_extern
r_void
id|it_real_fn
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|function|init_timer
r_static
r_inline
r_void
id|init_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
id|timer-&gt;list.next
op_assign
id|timer-&gt;list.prev
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|timer_pending
r_static
r_inline
r_int
id|timer_pending
(paren
r_const
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
r_return
id|timer-&gt;list.next
op_ne
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;These inlines deal with timer wrapping correctly. You are &n; *&t;strongly encouraged to use them&n; *&t;1. Because people otherwise forget&n; *&t;2. Because if the timer wrap changes in future you wont have to&n; *&t;   alter your driver code.&n; *&n; * Do this with &quot;&lt;0&quot; and &quot;&gt;=0&quot; to only test the sign of the result. A&n; * good compiler would generate better code (and a really good compiler&n; * wouldn&squot;t care). Gcc is currently neither.&n; */
DECL|macro|time_after
mdefine_line|#define time_after(a,b)&t;&t;((long)(b) - (long)(a) &lt; 0)
DECL|macro|time_before
mdefine_line|#define time_before(a,b)&t;time_after(b,a)
DECL|macro|time_after_eq
mdefine_line|#define time_after_eq(a,b)&t;((long)(a) - (long)(b) &gt;= 0)
DECL|macro|time_before_eq
mdefine_line|#define time_before_eq(a,b)&t;time_after_eq(b,a)
macro_line|#endif
eof
