multiline_comment|/* Overhauled routines for dealing with different mmap regions of flash */
multiline_comment|/* $Id: map.h,v 1.10 2000/12/04 13:18:33 dwmw2 Exp $ */
macro_line|#ifndef __LINUX_MTD_MAP_H__
DECL|macro|__LINUX_MTD_MAP_H__
mdefine_line|#define __LINUX_MTD_MAP_H__
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
multiline_comment|/* The map stuff is very simple. You fill in your struct map_info with&n;   a handful of routines for accessing the device, making sure they handle&n;   paging etc. correctly if your device needs it. Then you pass it off&n;   to a chip driver which deals with a mapped device - generally either&n;   do_cfi_probe() or do_ram_probe(), either of which will return a &n;   struct mtd_info if they liked what they saw. At which point, you&n;   fill in the mtd-&gt;module with your own module address, and register &n;   it.&n;   &n;   The mtd-&gt;priv field will point to the struct map_info, and any further&n;   private data required by the chip driver is linked from the &n;   mtd-&gt;priv-&gt;fldrv_priv field. This allows the map driver to get at &n;   the destructor function map-&gt;fldrv_destroy() when it&squot;s tired&n;   of living.&n;*/
DECL|struct|map_info
r_struct
id|map_info
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
DECL|member|buswidth
r_int
id|buswidth
suffix:semicolon
multiline_comment|/* in octets */
DECL|member|read8
id|__u8
(paren
op_star
id|read8
)paren
(paren
r_struct
id|map_info
op_star
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|read16
id|__u16
(paren
op_star
id|read16
)paren
(paren
r_struct
id|map_info
op_star
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|read32
id|__u32
(paren
op_star
id|read32
)paren
(paren
r_struct
id|map_info
op_star
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* If it returned a &squot;long&squot; I&squot;d call it readl.&n;&t; * It doesn&squot;t.&n;&t; * I won&squot;t.&n;&t; * dwmw2 */
DECL|member|copy_from
r_void
(paren
op_star
id|copy_from
)paren
(paren
r_struct
id|map_info
op_star
comma
r_void
op_star
comma
r_int
r_int
comma
id|ssize_t
)paren
suffix:semicolon
DECL|member|write8
r_void
(paren
op_star
id|write8
)paren
(paren
r_struct
id|map_info
op_star
comma
id|__u8
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|write16
r_void
(paren
op_star
id|write16
)paren
(paren
r_struct
id|map_info
op_star
comma
id|__u16
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|write32
r_void
(paren
op_star
id|write32
)paren
(paren
r_struct
id|map_info
op_star
comma
id|__u32
comma
r_int
r_int
)paren
suffix:semicolon
DECL|member|copy_to
r_void
(paren
op_star
id|copy_to
)paren
(paren
r_struct
id|map_info
op_star
comma
r_int
r_int
comma
r_const
r_void
op_star
comma
id|ssize_t
)paren
suffix:semicolon
DECL|member|set_vpp
r_void
(paren
op_star
id|set_vpp
)paren
(paren
r_int
)paren
suffix:semicolon
multiline_comment|/* We put these two here rather than a single void *map_priv, &n;&t;   because we want mappers to be able to have quickly-accessible&n;&t;   cache for the &squot;currently-mapped page&squot; without the _extra_&n;&t;   redirection that would be necessary. If you need more than&n;&t;   two longs, turn the second into a pointer. dwmw2 */
DECL|member|map_priv_1
r_int
r_int
id|map_priv_1
suffix:semicolon
DECL|member|map_priv_2
r_int
r_int
id|map_priv_2
suffix:semicolon
DECL|member|fldrv_priv
r_void
op_star
id|fldrv_priv
suffix:semicolon
DECL|member|fldrv_destroy
r_void
(paren
op_star
id|fldrv_destroy
)paren
(paren
r_struct
id|mtd_info
op_star
)paren
suffix:semicolon
DECL|member|im_name
r_const
r_char
op_star
id|im_name
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_MODULES
multiline_comment|/* &n; * Probe for the contents of a map device and make an MTD structure&n; * if anything is recognised. Doesn&squot;t register it because the calling&n; * map driver needs to set the &squot;module&squot; field first.&n; */
DECL|function|do_map_probe
r_static
r_inline
r_struct
id|mtd_info
op_star
id|do_map_probe
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
r_const
r_char
op_star
id|funcname
comma
r_const
r_char
op_star
id|modname
)paren
(brace
r_struct
id|mtd_info
op_star
(paren
op_star
id|probe_p
)paren
(paren
r_struct
id|map_info
op_star
)paren
suffix:semicolon
r_struct
id|mtd_info
op_star
id|mtd
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|probe_p
op_assign
id|inter_module_get_request
c_func
(paren
id|modname
comma
id|funcname
)paren
)paren
)paren
id|mtd
op_assign
(paren
op_star
id|probe_p
)paren
(paren
id|map
)paren
suffix:semicolon
multiline_comment|/* map-&gt;im_name is set by probe */
r_return
id|mtd
suffix:semicolon
)brace
multiline_comment|/* &n; * Commonly-used probe functions for different types of chip.&n; */
DECL|macro|do_cfi_probe
mdefine_line|#define do_cfi_probe(x) do_map_probe(x, &quot;cfi_probe&quot;, &quot;cfi_probe&quot;)
DECL|macro|do_jedec_probe
mdefine_line|#define do_jedec_probe(x) do_map_probe(x, &quot;jedec_probe&quot;, &quot;jedec_probe&quot;)
DECL|macro|do_ram_probe
mdefine_line|#define do_ram_probe(x) do_map_probe(x, &quot;map_ram_probe&quot;, &quot;map_ram&quot;)
DECL|macro|do_rom_probe
mdefine_line|#define do_rom_probe(x) do_map_probe(x, &quot;map_rom_probe&quot;, &quot;map_rom&quot;)
macro_line|#else
multiline_comment|/* without module support, call probe function directly */
r_extern
r_struct
id|mtd_info
op_star
id|cfi_probe
c_func
(paren
r_struct
id|map_info
op_star
)paren
suffix:semicolon
r_extern
r_struct
id|mtd_info
op_star
id|jedec_probe
c_func
(paren
r_struct
id|map_info
op_star
)paren
suffix:semicolon
r_extern
r_struct
id|mtd_info
op_star
id|map_ram_probe
c_func
(paren
r_struct
id|map_info
op_star
)paren
suffix:semicolon
r_extern
r_struct
id|mtd_info
op_star
id|map_rom_probe
c_func
(paren
r_struct
id|map_info
op_star
)paren
suffix:semicolon
DECL|macro|do_cfi_probe
mdefine_line|#define do_cfi_probe(x) cfi_probe(x)
DECL|macro|do_jedec_probe
mdefine_line|#define do_jedec_probe(x) jedec_probe(x)
DECL|macro|do_ram_probe
mdefine_line|#define do_ram_probe(x) map_ram_probe(x)
DECL|macro|do_rom_probe
mdefine_line|#define do_rom_probe(x) map_rom_probe(x)
macro_line|#endif
multiline_comment|/*&n; * Destroy an MTD device which was created for a map device.&n; * Make sure the MTD device is already unregistered before calling this&n; */
DECL|function|map_destroy
r_static
r_inline
r_void
id|map_destroy
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|map_info
op_star
id|map
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|map
op_member_access_from_pointer
id|fldrv_destroy
c_func
(paren
id|mtd
)paren
suffix:semicolon
id|inter_module_put
c_func
(paren
id|map-&gt;im_name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
)brace
DECL|macro|ENABLE_VPP
mdefine_line|#define ENABLE_VPP(map) do { if(map-&gt;set_vpp) map-&gt;set_vpp(1); } while(0)
DECL|macro|DISABLE_VPP
mdefine_line|#define DISABLE_VPP(map) do { if(map-&gt;set_vpp) map-&gt;set_vpp(0); } while(0)
macro_line|#endif /* __LINUX_MTD_MAP_H__ */
eof
