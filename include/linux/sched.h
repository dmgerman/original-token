macro_line|#ifndef _LINUX_SCHED_H
DECL|macro|_LINUX_SCHED_H
mdefine_line|#define _LINUX_SCHED_H
macro_line|#include &lt;asm/param.h&gt;&t;/* for HZ */
r_extern
r_int
r_int
id|event
suffix:semicolon
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/binfmts.h&gt;
macro_line|#include &lt;linux/personality.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/times.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;asm/mmu.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/sem.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/securebits.h&gt;
macro_line|#include &lt;linux/fs_struct.h&gt;
multiline_comment|/*&n; * cloning flags:&n; */
DECL|macro|CSIGNAL
mdefine_line|#define CSIGNAL&t;&t;0x000000ff&t;/* signal mask to be sent at exit */
DECL|macro|CLONE_VM
mdefine_line|#define CLONE_VM&t;0x00000100&t;/* set if VM shared between processes */
DECL|macro|CLONE_FS
mdefine_line|#define CLONE_FS&t;0x00000200&t;/* set if fs info shared between processes */
DECL|macro|CLONE_FILES
mdefine_line|#define CLONE_FILES&t;0x00000400&t;/* set if open files shared between processes */
DECL|macro|CLONE_SIGHAND
mdefine_line|#define CLONE_SIGHAND&t;0x00000800&t;/* set if signal handlers and blocked signals shared */
DECL|macro|CLONE_PID
mdefine_line|#define CLONE_PID&t;0x00001000&t;/* set if pid shared */
DECL|macro|CLONE_PTRACE
mdefine_line|#define CLONE_PTRACE&t;0x00002000&t;/* set if we want to let tracing continue on the child too */
DECL|macro|CLONE_VFORK
mdefine_line|#define CLONE_VFORK&t;0x00004000&t;/* set if the parent wants the child to wake it up on mm_release */
DECL|macro|CLONE_PARENT
mdefine_line|#define CLONE_PARENT&t;0x00008000&t;/* set if we want to have the same parent as the cloner */
DECL|macro|CLONE_THREAD
mdefine_line|#define CLONE_THREAD&t;0x00010000&t;/* Same thread group? */
DECL|macro|CLONE_SIGNAL
mdefine_line|#define CLONE_SIGNAL&t;(CLONE_SIGHAND | CLONE_THREAD)
multiline_comment|/*&n; * These are the constant used to fake the fixed-point load-average&n; * counting. Some notes:&n; *  - 11 bit fractions expand to 22 bits by the multiplies: this gives&n; *    a load-average precision of 10 bits integer + 11 bits fractional&n; *  - if you want to count load-averages more often, you need more&n; *    precision, or rounding will get you. With 2-second counting freq,&n; *    the EXP_n values would be 1981, 2034 and 2043 if still using only&n; *    11 bit fractions.&n; */
r_extern
r_int
r_int
id|avenrun
(braket
)braket
suffix:semicolon
multiline_comment|/* Load averages */
DECL|macro|FSHIFT
mdefine_line|#define FSHIFT&t;&t;11&t;&t;/* nr of bits of precision */
DECL|macro|FIXED_1
mdefine_line|#define FIXED_1&t;&t;(1&lt;&lt;FSHIFT)&t;/* 1.0 as fixed-point */
DECL|macro|LOAD_FREQ
mdefine_line|#define LOAD_FREQ&t;(5*HZ)&t;&t;/* 5 sec intervals */
DECL|macro|EXP_1
mdefine_line|#define EXP_1&t;&t;1884&t;&t;/* 1/exp(5sec/1min) as fixed-point */
DECL|macro|EXP_5
mdefine_line|#define EXP_5&t;&t;2014&t;&t;/* 1/exp(5sec/5min) */
DECL|macro|EXP_15
mdefine_line|#define EXP_15&t;&t;2037&t;&t;/* 1/exp(5sec/15min) */
DECL|macro|CALC_LOAD
mdefine_line|#define CALC_LOAD(load,exp,n) &bslash;&n;&t;load *= exp; &bslash;&n;&t;load += n*(FIXED_1-exp); &bslash;&n;&t;load &gt;&gt;= FSHIFT;
DECL|macro|CT_TO_SECS
mdefine_line|#define CT_TO_SECS(x)&t;((x) / HZ)
DECL|macro|CT_TO_USECS
mdefine_line|#define CT_TO_USECS(x)&t;(((x) % HZ) * 1000000/HZ)
r_extern
r_int
id|nr_running
comma
id|nr_threads
suffix:semicolon
r_extern
r_int
id|last_pid
suffix:semicolon
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/param.h&gt;
macro_line|#include &lt;linux/resource.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
DECL|macro|TASK_RUNNING
mdefine_line|#define TASK_RUNNING&t;&t;0
DECL|macro|TASK_INTERRUPTIBLE
mdefine_line|#define TASK_INTERRUPTIBLE&t;1
DECL|macro|TASK_UNINTERRUPTIBLE
mdefine_line|#define TASK_UNINTERRUPTIBLE&t;2
DECL|macro|TASK_ZOMBIE
mdefine_line|#define TASK_ZOMBIE&t;&t;4
DECL|macro|TASK_STOPPED
mdefine_line|#define TASK_STOPPED&t;&t;8
DECL|macro|__set_task_state
mdefine_line|#define __set_task_state(tsk, state_value)&t;&t;&bslash;&n;&t;do { (tsk)-&gt;state = (state_value); } while (0)
macro_line|#ifdef CONFIG_SMP
DECL|macro|set_task_state
mdefine_line|#define set_task_state(tsk, state_value)&t;&t;&bslash;&n;&t;set_mb((tsk)-&gt;state, (state_value))
macro_line|#else
DECL|macro|set_task_state
mdefine_line|#define set_task_state(tsk, state_value)&t;&t;&bslash;&n;&t;__set_task_state((tsk), (state_value))
macro_line|#endif
DECL|macro|__set_current_state
mdefine_line|#define __set_current_state(state_value)&t;&t;&t;&bslash;&n;&t;do { current-&gt;state = (state_value); } while (0)
macro_line|#ifdef CONFIG_SMP
DECL|macro|set_current_state
mdefine_line|#define set_current_state(state_value)&t;&t;&bslash;&n;&t;set_mb(current-&gt;state, (state_value))
macro_line|#else
DECL|macro|set_current_state
mdefine_line|#define set_current_state(state_value)&t;&t;&bslash;&n;&t;__set_current_state(state_value)
macro_line|#endif
multiline_comment|/*&n; * Scheduling policies&n; */
DECL|macro|SCHED_OTHER
mdefine_line|#define SCHED_OTHER&t;&t;0
DECL|macro|SCHED_FIFO
mdefine_line|#define SCHED_FIFO&t;&t;1
DECL|macro|SCHED_RR
mdefine_line|#define SCHED_RR&t;&t;2
multiline_comment|/*&n; * This is an additional bit set when we want to&n; * yield the CPU for one re-schedule..&n; */
DECL|macro|SCHED_YIELD
mdefine_line|#define SCHED_YIELD&t;&t;0x10
DECL|struct|sched_param
r_struct
id|sched_param
(brace
DECL|member|sched_priority
r_int
id|sched_priority
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifdef __KERNEL__
macro_line|#include &lt;linux/spinlock.h&gt;
multiline_comment|/*&n; * This serializes &quot;schedule()&quot; and also protects&n; * the run-queue from deletions/modifications (but&n; * _adding_ to the beginning of the run-queue has&n; * a separate lock).&n; */
r_extern
id|rwlock_t
id|tasklist_lock
suffix:semicolon
r_extern
id|spinlock_t
id|runqueue_lock
suffix:semicolon
r_extern
id|spinlock_t
id|mmlist_lock
suffix:semicolon
r_extern
r_void
id|sched_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|init_idle
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|show_state
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|cpu_init
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|trap_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|update_process_times
c_func
(paren
r_int
id|user
)paren
suffix:semicolon
r_extern
r_void
id|update_one_process
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
r_int
id|user
comma
r_int
r_int
id|system
comma
r_int
id|cpu
)paren
suffix:semicolon
DECL|macro|MAX_SCHEDULE_TIMEOUT
mdefine_line|#define&t;MAX_SCHEDULE_TIMEOUT&t;LONG_MAX
r_extern
r_int
r_int
id|FASTCALL
c_func
(paren
id|schedule_timeout
c_func
(paren
r_int
r_int
id|timeout
)paren
)paren
suffix:semicolon
id|asmlinkage
r_void
id|schedule
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|schedule_task
c_func
(paren
r_struct
id|tq_struct
op_star
id|task
)paren
suffix:semicolon
r_extern
r_void
id|flush_scheduled_tasks
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|start_context_thread
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|current_is_keventd
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * The default fd array needs to be at least BITS_PER_LONG,&n; * as this is the granularity returned by copy_fdset().&n; */
DECL|macro|NR_OPEN_DEFAULT
mdefine_line|#define NR_OPEN_DEFAULT BITS_PER_LONG
multiline_comment|/*&n; * Open file table structure&n; */
DECL|struct|files_struct
r_struct
id|files_struct
(brace
DECL|member|count
id|atomic_t
id|count
suffix:semicolon
DECL|member|file_lock
id|rwlock_t
id|file_lock
suffix:semicolon
DECL|member|max_fds
r_int
id|max_fds
suffix:semicolon
DECL|member|max_fdset
r_int
id|max_fdset
suffix:semicolon
DECL|member|next_fd
r_int
id|next_fd
suffix:semicolon
DECL|member|fd
r_struct
id|file
op_star
op_star
id|fd
suffix:semicolon
multiline_comment|/* current fd array */
DECL|member|close_on_exec
id|fd_set
op_star
id|close_on_exec
suffix:semicolon
DECL|member|open_fds
id|fd_set
op_star
id|open_fds
suffix:semicolon
DECL|member|close_on_exec_init
id|fd_set
id|close_on_exec_init
suffix:semicolon
DECL|member|open_fds_init
id|fd_set
id|open_fds_init
suffix:semicolon
DECL|member|fd_array
r_struct
id|file
op_star
id|fd_array
(braket
id|NR_OPEN_DEFAULT
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|INIT_FILES
mdefine_line|#define INIT_FILES &bslash;&n;{ &t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;count:&t;&t;ATOMIC_INIT(1), &t;&t;&bslash;&n;&t;file_lock:&t;RW_LOCK_UNLOCKED, &t;&t;&bslash;&n;&t;max_fds:&t;NR_OPEN_DEFAULT, &t;&t;&bslash;&n;&t;max_fdset:&t;__FD_SETSIZE, &t;&t;&t;&bslash;&n;&t;next_fd:&t;0, &t;&t;&t;&t;&bslash;&n;&t;fd:&t;&t;&amp;init_files.fd_array[0], &t;&bslash;&n;&t;close_on_exec:&t;&amp;init_files.close_on_exec_init, &bslash;&n;&t;open_fds:&t;&amp;init_files.open_fds_init, &t;&bslash;&n;&t;close_on_exec_init: { { 0, } }, &t;&t;&bslash;&n;&t;open_fds_init:&t;{ { 0, } }, &t;&t;&t;&bslash;&n;&t;fd_array:&t;{ NULL, } &t;&t;&t;&bslash;&n;}
multiline_comment|/* Maximum number of active map areas.. This is a random (large) number */
DECL|macro|MAX_MAP_COUNT
mdefine_line|#define MAX_MAP_COUNT&t;(65536)
multiline_comment|/* Number of map areas at which the AVL tree is activated. This is arbitrary. */
DECL|macro|AVL_MIN_MAP_COUNT
mdefine_line|#define AVL_MIN_MAP_COUNT&t;32
DECL|struct|mm_struct
r_struct
id|mm_struct
(brace
DECL|member|mmap
r_struct
id|vm_area_struct
op_star
id|mmap
suffix:semicolon
multiline_comment|/* list of VMAs */
DECL|member|mmap_avl
r_struct
id|vm_area_struct
op_star
id|mmap_avl
suffix:semicolon
multiline_comment|/* tree of VMAs */
DECL|member|mmap_cache
r_struct
id|vm_area_struct
op_star
id|mmap_cache
suffix:semicolon
multiline_comment|/* last find_vma result */
DECL|member|pgd
id|pgd_t
op_star
id|pgd
suffix:semicolon
DECL|member|mm_users
id|atomic_t
id|mm_users
suffix:semicolon
multiline_comment|/* How many users with user space? */
DECL|member|mm_count
id|atomic_t
id|mm_count
suffix:semicolon
multiline_comment|/* How many references to &quot;struct mm_struct&quot; (users count as 1) */
DECL|member|map_count
r_int
id|map_count
suffix:semicolon
multiline_comment|/* number of VMAs */
DECL|member|mmap_sem
r_struct
id|semaphore
id|mmap_sem
suffix:semicolon
DECL|member|page_table_lock
id|spinlock_t
id|page_table_lock
suffix:semicolon
DECL|member|mmlist
r_struct
id|list_head
id|mmlist
suffix:semicolon
multiline_comment|/* List of all active mm&squot;s */
DECL|member|start_code
DECL|member|end_code
DECL|member|start_data
DECL|member|end_data
r_int
r_int
id|start_code
comma
id|end_code
comma
id|start_data
comma
id|end_data
suffix:semicolon
DECL|member|start_brk
DECL|member|brk
DECL|member|start_stack
r_int
r_int
id|start_brk
comma
id|brk
comma
id|start_stack
suffix:semicolon
DECL|member|arg_start
DECL|member|arg_end
DECL|member|env_start
DECL|member|env_end
r_int
r_int
id|arg_start
comma
id|arg_end
comma
id|env_start
comma
id|env_end
suffix:semicolon
DECL|member|rss
DECL|member|total_vm
DECL|member|locked_vm
r_int
r_int
id|rss
comma
id|total_vm
comma
id|locked_vm
suffix:semicolon
DECL|member|def_flags
r_int
r_int
id|def_flags
suffix:semicolon
DECL|member|cpu_vm_mask
r_int
r_int
id|cpu_vm_mask
suffix:semicolon
DECL|member|swap_cnt
r_int
r_int
id|swap_cnt
suffix:semicolon
multiline_comment|/* number of pages to swap on next pass */
DECL|member|swap_address
r_int
r_int
id|swap_address
suffix:semicolon
multiline_comment|/* Architecture-specific MM context */
DECL|member|context
id|mm_context_t
id|context
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|INIT_MM
mdefine_line|#define INIT_MM(name) &bslash;&n;{&t;&t;&t; &t;&t;&t;&t;&bslash;&n;&t;mmap:&t;&t;&amp;init_mmap, &t;&t;&t;&bslash;&n;&t;mmap_avl:&t;NULL, &t;&t;&t;&t;&bslash;&n;&t;mmap_cache:&t;NULL, &t;&t;&t;&t;&bslash;&n;&t;pgd:&t;&t;swapper_pg_dir, &t;&t;&bslash;&n;&t;mm_users:&t;ATOMIC_INIT(2), &t;&t;&bslash;&n;&t;mm_count:&t;ATOMIC_INIT(1), &t;&t;&bslash;&n;&t;map_count:&t;1, &t;&t;&t;&t;&bslash;&n;&t;mmap_sem:&t;__MUTEX_INITIALIZER(name.mmap_sem), &bslash;&n;&t;page_table_lock: SPIN_LOCK_UNLOCKED, &t;&t;&bslash;&n;&t;mmlist:&t;&t;LIST_HEAD_INIT(name.mmlist),&t;&bslash;&n;}
DECL|struct|signal_struct
r_struct
id|signal_struct
(brace
DECL|member|count
id|atomic_t
id|count
suffix:semicolon
DECL|member|action
r_struct
id|k_sigaction
id|action
(braket
id|_NSIG
)braket
suffix:semicolon
DECL|member|siglock
id|spinlock_t
id|siglock
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|INIT_SIGNALS
mdefine_line|#define INIT_SIGNALS {&t;&bslash;&n;&t;count:&t;&t;ATOMIC_INIT(1), &t;&t;&bslash;&n;&t;action:&t;&t;{ {{0,}}, }, &t;&t;&t;&bslash;&n;&t;siglock:&t;SPIN_LOCK_UNLOCKED &t;&t;&bslash;&n;}
multiline_comment|/*&n; * Some day this will be a full-fledged user tracking system..&n; */
DECL|struct|user_struct
r_struct
id|user_struct
(brace
DECL|member|__count
id|atomic_t
id|__count
suffix:semicolon
multiline_comment|/* reference count */
DECL|member|processes
id|atomic_t
id|processes
suffix:semicolon
multiline_comment|/* How many processes does this user have? */
DECL|member|files
id|atomic_t
id|files
suffix:semicolon
multiline_comment|/* How many open files does this user have? */
multiline_comment|/* Hash table maintenance information */
DECL|member|next
DECL|member|pprev
r_struct
id|user_struct
op_star
id|next
comma
op_star
op_star
id|pprev
suffix:semicolon
DECL|member|uid
id|uid_t
id|uid
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|get_current_user
mdefine_line|#define get_current_user() ({ &t;&t;&t;&t;&bslash;&n;&t;struct user_struct *__user = current-&gt;user;&t;&bslash;&n;&t;atomic_inc(&amp;__user-&gt;__count);&t;&t;&t;&bslash;&n;&t;__user; })
r_extern
r_struct
id|user_struct
id|root_user
suffix:semicolon
DECL|macro|INIT_USER
mdefine_line|#define INIT_USER (&amp;root_user)
DECL|struct|task_struct
r_struct
id|task_struct
(brace
multiline_comment|/*&n;&t; * offsets of these are hardcoded elsewhere - touch with care&n;&t; */
DECL|member|state
r_volatile
r_int
id|state
suffix:semicolon
multiline_comment|/* -1 unrunnable, 0 runnable, &gt;0 stopped */
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* per process flags, defined below */
DECL|member|sigpending
r_int
id|sigpending
suffix:semicolon
DECL|member|addr_limit
id|mm_segment_t
id|addr_limit
suffix:semicolon
multiline_comment|/* thread address space:&n;&t;&t;&t;&t;&t; &t;0-0xBFFFFFFF for user-thead&n;&t;&t;&t;&t;&t;&t;0-0xFFFFFFFF for kernel-thread&n;&t;&t;&t;&t;&t; */
DECL|member|exec_domain
r_struct
id|exec_domain
op_star
id|exec_domain
suffix:semicolon
DECL|member|need_resched
r_volatile
r_int
id|need_resched
suffix:semicolon
DECL|member|ptrace
r_int
r_int
id|ptrace
suffix:semicolon
DECL|member|lock_depth
r_int
id|lock_depth
suffix:semicolon
multiline_comment|/* Lock depth */
multiline_comment|/*&n; * offset 32 begins here on 32-bit platforms. We keep&n; * all fields in a single cacheline that are needed for&n; * the goodness() loop in schedule().&n; */
DECL|member|counter
r_int
id|counter
suffix:semicolon
DECL|member|nice
r_int
id|nice
suffix:semicolon
DECL|member|policy
r_int
r_int
id|policy
suffix:semicolon
DECL|member|mm
r_struct
id|mm_struct
op_star
id|mm
suffix:semicolon
DECL|member|has_cpu
DECL|member|processor
r_int
id|has_cpu
comma
id|processor
suffix:semicolon
DECL|member|cpus_allowed
r_int
r_int
id|cpus_allowed
suffix:semicolon
multiline_comment|/*&n;&t; * (only the &squot;next&squot; pointer fits into the cacheline, but&n;&t; * that&squot;s just fine.)&n;&t; */
DECL|member|run_list
r_struct
id|list_head
id|run_list
suffix:semicolon
DECL|member|sleep_time
r_int
r_int
id|sleep_time
suffix:semicolon
DECL|member|next_task
DECL|member|prev_task
r_struct
id|task_struct
op_star
id|next_task
comma
op_star
id|prev_task
suffix:semicolon
DECL|member|active_mm
r_struct
id|mm_struct
op_star
id|active_mm
suffix:semicolon
multiline_comment|/* task state */
DECL|member|binfmt
r_struct
id|linux_binfmt
op_star
id|binfmt
suffix:semicolon
DECL|member|exit_code
DECL|member|exit_signal
r_int
id|exit_code
comma
id|exit_signal
suffix:semicolon
DECL|member|pdeath_signal
r_int
id|pdeath_signal
suffix:semicolon
multiline_comment|/*  The signal sent when the parent dies  */
multiline_comment|/* ??? */
DECL|member|personality
r_int
r_int
id|personality
suffix:semicolon
DECL|member|dumpable
r_int
id|dumpable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|did_exec
r_int
id|did_exec
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pid
id|pid_t
id|pid
suffix:semicolon
DECL|member|pgrp
id|pid_t
id|pgrp
suffix:semicolon
DECL|member|tty_old_pgrp
id|pid_t
id|tty_old_pgrp
suffix:semicolon
DECL|member|session
id|pid_t
id|session
suffix:semicolon
DECL|member|tgid
id|pid_t
id|tgid
suffix:semicolon
multiline_comment|/* boolean value for session group leader */
DECL|member|leader
r_int
id|leader
suffix:semicolon
multiline_comment|/* &n;&t; * pointers to (original) parent process, youngest child, younger sibling,&n;&t; * older sibling, respectively.  (p-&gt;father can be replaced with &n;&t; * p-&gt;p_pptr-&gt;pid)&n;&t; */
DECL|member|p_opptr
DECL|member|p_pptr
DECL|member|p_cptr
DECL|member|p_ysptr
DECL|member|p_osptr
r_struct
id|task_struct
op_star
id|p_opptr
comma
op_star
id|p_pptr
comma
op_star
id|p_cptr
comma
op_star
id|p_ysptr
comma
op_star
id|p_osptr
suffix:semicolon
DECL|member|thread_group
r_struct
id|list_head
id|thread_group
suffix:semicolon
multiline_comment|/* PID hash table linkage. */
DECL|member|pidhash_next
r_struct
id|task_struct
op_star
id|pidhash_next
suffix:semicolon
DECL|member|pidhash_pprev
r_struct
id|task_struct
op_star
op_star
id|pidhash_pprev
suffix:semicolon
DECL|member|wait_chldexit
id|wait_queue_head_t
id|wait_chldexit
suffix:semicolon
multiline_comment|/* for wait4() */
DECL|member|vfork_sem
r_struct
id|semaphore
op_star
id|vfork_sem
suffix:semicolon
multiline_comment|/* for vfork() */
DECL|member|rt_priority
r_int
r_int
id|rt_priority
suffix:semicolon
DECL|member|it_real_value
DECL|member|it_prof_value
DECL|member|it_virt_value
r_int
r_int
id|it_real_value
comma
id|it_prof_value
comma
id|it_virt_value
suffix:semicolon
DECL|member|it_real_incr
DECL|member|it_prof_incr
DECL|member|it_virt_incr
r_int
r_int
id|it_real_incr
comma
id|it_prof_incr
comma
id|it_virt_incr
suffix:semicolon
DECL|member|real_timer
r_struct
id|timer_list
id|real_timer
suffix:semicolon
DECL|member|times
r_struct
id|tms
id|times
suffix:semicolon
DECL|member|start_time
r_int
r_int
id|start_time
suffix:semicolon
DECL|member|per_cpu_utime
DECL|member|per_cpu_stime
r_int
id|per_cpu_utime
(braket
id|NR_CPUS
)braket
comma
id|per_cpu_stime
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */
DECL|member|min_flt
DECL|member|maj_flt
DECL|member|nswap
DECL|member|cmin_flt
DECL|member|cmaj_flt
DECL|member|cnswap
r_int
r_int
id|min_flt
comma
id|maj_flt
comma
id|nswap
comma
id|cmin_flt
comma
id|cmaj_flt
comma
id|cnswap
suffix:semicolon
DECL|member|swappable
r_int
id|swappable
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* process credentials */
DECL|member|uid
DECL|member|euid
DECL|member|suid
DECL|member|fsuid
id|uid_t
id|uid
comma
id|euid
comma
id|suid
comma
id|fsuid
suffix:semicolon
DECL|member|gid
DECL|member|egid
DECL|member|sgid
DECL|member|fsgid
id|gid_t
id|gid
comma
id|egid
comma
id|sgid
comma
id|fsgid
suffix:semicolon
DECL|member|ngroups
r_int
id|ngroups
suffix:semicolon
DECL|member|groups
id|gid_t
id|groups
(braket
id|NGROUPS
)braket
suffix:semicolon
DECL|member|cap_effective
DECL|member|cap_inheritable
DECL|member|cap_permitted
id|kernel_cap_t
id|cap_effective
comma
id|cap_inheritable
comma
id|cap_permitted
suffix:semicolon
DECL|member|keep_capabilities
r_int
id|keep_capabilities
suffix:colon
l_int|1
suffix:semicolon
DECL|member|user
r_struct
id|user_struct
op_star
id|user
suffix:semicolon
multiline_comment|/* limits */
DECL|member|rlim
r_struct
id|rlimit
id|rlim
(braket
id|RLIM_NLIMITS
)braket
suffix:semicolon
DECL|member|used_math
r_int
r_int
id|used_math
suffix:semicolon
DECL|member|comm
r_char
id|comm
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* file system info */
DECL|member|link_count
r_int
id|link_count
suffix:semicolon
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
multiline_comment|/* NULL if no tty */
DECL|member|locks
r_int
r_int
id|locks
suffix:semicolon
multiline_comment|/* How many file locks are being held */
multiline_comment|/* ipc stuff */
DECL|member|semundo
r_struct
id|sem_undo
op_star
id|semundo
suffix:semicolon
DECL|member|semsleeping
r_struct
id|sem_queue
op_star
id|semsleeping
suffix:semicolon
multiline_comment|/* CPU-specific state of this task */
DECL|member|thread
r_struct
id|thread_struct
id|thread
suffix:semicolon
multiline_comment|/* filesystem information */
DECL|member|fs
r_struct
id|fs_struct
op_star
id|fs
suffix:semicolon
multiline_comment|/* open file information */
DECL|member|files
r_struct
id|files_struct
op_star
id|files
suffix:semicolon
multiline_comment|/* signal handlers */
DECL|member|sigmask_lock
id|spinlock_t
id|sigmask_lock
suffix:semicolon
multiline_comment|/* Protects signal and blocked */
DECL|member|sig
r_struct
id|signal_struct
op_star
id|sig
suffix:semicolon
DECL|member|blocked
id|sigset_t
id|blocked
suffix:semicolon
DECL|member|pending
r_struct
id|sigpending
id|pending
suffix:semicolon
DECL|member|sas_ss_sp
r_int
r_int
id|sas_ss_sp
suffix:semicolon
DECL|member|sas_ss_size
r_int
id|sas_ss_size
suffix:semicolon
DECL|member|notifier
r_int
(paren
op_star
id|notifier
)paren
(paren
r_void
op_star
id|priv
)paren
suffix:semicolon
DECL|member|notifier_data
r_void
op_star
id|notifier_data
suffix:semicolon
DECL|member|notifier_mask
id|sigset_t
op_star
id|notifier_mask
suffix:semicolon
multiline_comment|/* Thread group tracking */
DECL|member|parent_exec_id
id|u32
id|parent_exec_id
suffix:semicolon
DECL|member|self_exec_id
id|u32
id|self_exec_id
suffix:semicolon
multiline_comment|/* Protection of (de-)allocation: mm, files, fs, tty */
DECL|member|alloc_lock
id|spinlock_t
id|alloc_lock
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Per process flags&n; */
DECL|macro|PF_ALIGNWARN
mdefine_line|#define PF_ALIGNWARN&t;0x00000001&t;/* Print alignment warning msgs */
multiline_comment|/* Not implemented yet, only for 486*/
DECL|macro|PF_STARTING
mdefine_line|#define PF_STARTING&t;0x00000002&t;/* being created */
DECL|macro|PF_EXITING
mdefine_line|#define PF_EXITING&t;0x00000004&t;/* getting shut down */
DECL|macro|PF_FORKNOEXEC
mdefine_line|#define PF_FORKNOEXEC&t;0x00000040&t;/* forked but didn&squot;t exec */
DECL|macro|PF_SUPERPRIV
mdefine_line|#define PF_SUPERPRIV&t;0x00000100&t;/* used super-user privileges */
DECL|macro|PF_DUMPCORE
mdefine_line|#define PF_DUMPCORE&t;0x00000200&t;/* dumped core */
DECL|macro|PF_SIGNALED
mdefine_line|#define PF_SIGNALED&t;0x00000400&t;/* killed by a signal */
DECL|macro|PF_MEMALLOC
mdefine_line|#define PF_MEMALLOC&t;0x00000800&t;/* Allocating memory */
DECL|macro|PF_VFORK
mdefine_line|#define PF_VFORK&t;0x00001000&t;/* Wake up parent in mm_release */
DECL|macro|PF_USEDFPU
mdefine_line|#define PF_USEDFPU&t;0x00100000&t;/* task used FPU this quantum (SMP) */
multiline_comment|/*&n; * Ptrace flags&n; */
DECL|macro|PT_PTRACED
mdefine_line|#define PT_PTRACED&t;0x00000001
DECL|macro|PT_TRACESYS
mdefine_line|#define PT_TRACESYS&t;0x00000002
DECL|macro|PT_DTRACE
mdefine_line|#define PT_DTRACE&t;0x00000004&t;/* delayed trace (used on m68k, i386) */
DECL|macro|PT_TRACESYSGOOD
mdefine_line|#define PT_TRACESYSGOOD&t;0x00000008
multiline_comment|/*&n; * Limit the stack by to some sane default: root can always&n; * increase this limit if needed..  8MB seems reasonable.&n; */
DECL|macro|_STK_LIM
mdefine_line|#define _STK_LIM&t;(8*1024*1024)
DECL|macro|DEF_COUNTER
mdefine_line|#define DEF_COUNTER&t;(10*HZ/100)&t;/* 100 ms time slice */
DECL|macro|MAX_COUNTER
mdefine_line|#define MAX_COUNTER&t;(20*HZ/100)
DECL|macro|DEF_NICE
mdefine_line|#define DEF_NICE&t;(0)
multiline_comment|/*&n; *  INIT_TASK is used to set up the first task table, touch at&n; * your own risk!. Base=0, limit=0x1fffff (=2MB)&n; */
DECL|macro|INIT_TASK
mdefine_line|#define INIT_TASK(tsk)&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    state:&t;&t;0,&t;&t;&t;&t;&t;&t;&bslash;&n;    flags:&t;&t;0,&t;&t;&t;&t;&t;&t;&bslash;&n;    sigpending:&t;&t;0,&t;&t;&t;&t;&t;&t;&bslash;&n;    addr_limit:&t;&t;KERNEL_DS,&t;&t;&t;&t;&t;&bslash;&n;    exec_domain:&t;&amp;default_exec_domain,&t;&t;&t;&t;&bslash;&n;    lock_depth:&t;&t;-1,&t;&t;&t;&t;&t;&t;&bslash;&n;    counter:&t;&t;DEF_COUNTER,&t;&t;&t;&t;&t;&bslash;&n;    nice:&t;&t;DEF_NICE,&t;&t;&t;&t;&t;&bslash;&n;    policy:&t;&t;SCHED_OTHER,&t;&t;&t;&t;&t;&bslash;&n;    mm:&t;&t;&t;NULL,&t;&t;&t;&t;&t;&t;&bslash;&n;    active_mm:&t;&t;&amp;init_mm,&t;&t;&t;&t;&t;&bslash;&n;    cpus_allowed:&t;-1,&t;&t;&t;&t;&t;&t;&bslash;&n;    run_list:&t;&t;LIST_HEAD_INIT(tsk.run_list),&t;&t;&t;&bslash;&n;    next_task:&t;&t;&amp;tsk,&t;&t;&t;&t;&t;&t;&bslash;&n;    prev_task:&t;&t;&amp;tsk,&t;&t;&t;&t;&t;&t;&bslash;&n;    p_opptr:&t;&t;&amp;tsk,&t;&t;&t;&t;&t;&t;&bslash;&n;    p_pptr:&t;&t;&amp;tsk,&t;&t;&t;&t;&t;&t;&bslash;&n;    thread_group:&t;LIST_HEAD_INIT(tsk.thread_group),&t;&t;&bslash;&n;    wait_chldexit:&t;__WAIT_QUEUE_HEAD_INITIALIZER(tsk.wait_chldexit),&bslash;&n;    real_timer:&t;&t;{&t;&t;&t;&t;&t;&t;&bslash;&n;&t;function:&t;&t;it_real_fn&t;&t;&t;&t;&bslash;&n;    },&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    cap_effective:&t;CAP_INIT_EFF_SET,&t;&t;&t;&t;&bslash;&n;    cap_inheritable:&t;CAP_INIT_INH_SET,&t;&t;&t;&t;&bslash;&n;    cap_permitted:&t;CAP_FULL_SET,&t;&t;&t;&t;&t;&bslash;&n;    keep_capabilities:&t;0,&t;&t;&t;&t;&t;&t;&bslash;&n;    rlim:&t;&t;INIT_RLIMITS,&t;&t;&t;&t;&t;&bslash;&n;    user:&t;&t;INIT_USER,&t;&t;&t;&t;&t;&bslash;&n;    comm:&t;&t;&quot;swapper&quot;,&t;&t;&t;&t;&t;&bslash;&n;    thread:&t;&t;INIT_THREAD,&t;&t;&t;&t;&t;&bslash;&n;    fs:&t;&t;&t;&amp;init_fs,&t;&t;&t;&t;&t;&bslash;&n;    files:&t;&t;&amp;init_files,&t;&t;&t;&t;&t;&bslash;&n;    sigmask_lock:&t;SPIN_LOCK_UNLOCKED,&t;&t;&t;&t;&bslash;&n;    sig:&t;&t;&amp;init_signals,&t;&t;&t;&t;&t;&bslash;&n;    pending:&t;&t;{ NULL, &amp;tsk.pending.head, {{0}}},&t;&t;&bslash;&n;    blocked:&t;&t;{{0}},&t;&t;&t;&t;&t;&t;&bslash;&n;    alloc_lock:&t;&t;SPIN_LOCK_UNLOCKED&t;&t;&t;&t;&bslash;&n;}
macro_line|#ifndef INIT_TASK_SIZE
DECL|macro|INIT_TASK_SIZE
macro_line|# define INIT_TASK_SIZE&t;2048*sizeof(long)
macro_line|#endif
DECL|union|task_union
r_union
id|task_union
(brace
DECL|member|task
r_struct
id|task_struct
id|task
suffix:semicolon
DECL|member|stack
r_int
r_int
id|stack
(braket
id|INIT_TASK_SIZE
op_div
r_sizeof
(paren
r_int
)paren
)braket
suffix:semicolon
)brace
suffix:semicolon
r_extern
r_union
id|task_union
id|init_task_union
suffix:semicolon
r_extern
r_struct
id|mm_struct
id|init_mm
suffix:semicolon
r_extern
r_struct
id|task_struct
op_star
id|init_tasks
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* PID hashing. (shouldnt this be dynamic?) */
DECL|macro|PIDHASH_SZ
mdefine_line|#define PIDHASH_SZ (4096 &gt;&gt; 2)
r_extern
r_struct
id|task_struct
op_star
id|pidhash
(braket
id|PIDHASH_SZ
)braket
suffix:semicolon
DECL|macro|pid_hashfn
mdefine_line|#define pid_hashfn(x)&t;((((x) &gt;&gt; 8) ^ (x)) &amp; (PIDHASH_SZ - 1))
DECL|function|hash_pid
r_static
r_inline
r_void
id|hash_pid
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_struct
id|task_struct
op_star
op_star
id|htable
op_assign
op_amp
id|pidhash
(braket
id|pid_hashfn
c_func
(paren
id|p-&gt;pid
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;pidhash_next
op_assign
op_star
id|htable
)paren
op_ne
l_int|NULL
)paren
(brace
(paren
op_star
id|htable
)paren
op_member_access_from_pointer
id|pidhash_pprev
op_assign
op_amp
id|p-&gt;pidhash_next
suffix:semicolon
)brace
op_star
id|htable
op_assign
id|p
suffix:semicolon
id|p-&gt;pidhash_pprev
op_assign
id|htable
suffix:semicolon
)brace
DECL|function|unhash_pid
r_static
r_inline
r_void
id|unhash_pid
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;pidhash_next
)paren
(brace
id|p-&gt;pidhash_next-&gt;pidhash_pprev
op_assign
id|p-&gt;pidhash_pprev
suffix:semicolon
)brace
op_star
id|p-&gt;pidhash_pprev
op_assign
id|p-&gt;pidhash_next
suffix:semicolon
)brace
DECL|function|find_task_by_pid
r_static
r_inline
r_struct
id|task_struct
op_star
id|find_task_by_pid
c_func
(paren
r_int
id|pid
)paren
(brace
r_struct
id|task_struct
op_star
id|p
comma
op_star
op_star
id|htable
op_assign
op_amp
id|pidhash
(braket
id|pid_hashfn
c_func
(paren
id|pid
)paren
)braket
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_star
id|htable
suffix:semicolon
id|p
op_logical_and
id|p-&gt;pid
op_ne
id|pid
suffix:semicolon
id|p
op_assign
id|p-&gt;pidhash_next
)paren
(brace
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/* per-UID process charging. */
r_extern
r_struct
id|user_struct
op_star
id|alloc_uid
c_func
(paren
id|uid_t
)paren
suffix:semicolon
r_extern
r_void
id|free_uid
c_func
(paren
r_struct
id|user_struct
op_star
)paren
suffix:semicolon
macro_line|#include &lt;asm/current.h&gt;
r_extern
r_int
r_int
r_volatile
id|jiffies
suffix:semicolon
r_extern
r_int
r_int
id|itimer_ticks
suffix:semicolon
r_extern
r_int
r_int
id|itimer_next
suffix:semicolon
r_extern
r_struct
id|timeval
id|xtime
suffix:semicolon
r_extern
r_void
id|do_timer
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_extern
r_int
r_int
op_star
id|prof_buffer
suffix:semicolon
r_extern
r_int
r_int
id|prof_len
suffix:semicolon
r_extern
r_int
r_int
id|prof_shift
suffix:semicolon
DECL|macro|CURRENT_TIME
mdefine_line|#define CURRENT_TIME (xtime.tv_sec)
r_extern
r_void
id|FASTCALL
c_func
(paren
id|__wake_up
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
r_int
id|mode
comma
r_int
r_int
id|wq_mode
)paren
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|__wake_up_sync
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
r_int
id|mode
comma
r_int
r_int
id|wq_mode
)paren
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|sleep_on
c_func
(paren
id|wait_queue_head_t
op_star
id|q
)paren
)paren
suffix:semicolon
r_extern
r_int
id|FASTCALL
c_func
(paren
id|sleep_on_timeout
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
r_int
id|timeout
)paren
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|interruptible_sleep_on
c_func
(paren
id|wait_queue_head_t
op_star
id|q
)paren
)paren
suffix:semicolon
r_extern
r_int
id|FASTCALL
c_func
(paren
id|interruptible_sleep_on_timeout
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
r_int
id|timeout
)paren
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|wake_up_process
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
)paren
suffix:semicolon
DECL|macro|wake_up
mdefine_line|#define wake_up(x)&t;&t;&t;__wake_up((x),TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE,WQ_FLAG_EXCLUSIVE)
DECL|macro|wake_up_all
mdefine_line|#define wake_up_all(x)&t;&t;&t;__wake_up((x),TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE,0)
DECL|macro|wake_up_sync
mdefine_line|#define wake_up_sync(x)&t;&t;&t;__wake_up_sync((x),TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE,WQ_FLAG_EXCLUSIVE)
DECL|macro|wake_up_interruptible
mdefine_line|#define wake_up_interruptible(x)&t;__wake_up((x),TASK_INTERRUPTIBLE,WQ_FLAG_EXCLUSIVE)
DECL|macro|wake_up_interruptible_all
mdefine_line|#define wake_up_interruptible_all(x)&t;__wake_up((x),TASK_INTERRUPTIBLE,0)
DECL|macro|wake_up_interruptible_sync
mdefine_line|#define wake_up_interruptible_sync(x)&t;__wake_up_sync((x),TASK_INTERRUPTIBLE,WQ_FLAG_EXCLUSIVE)
r_extern
r_int
id|in_group_p
c_func
(paren
id|gid_t
)paren
suffix:semicolon
r_extern
r_int
id|in_egroup_p
c_func
(paren
id|gid_t
)paren
suffix:semicolon
r_extern
r_void
id|proc_caches_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|flush_signals
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|flush_signal_handlers
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|dequeue_signal
c_func
(paren
id|sigset_t
op_star
comma
id|siginfo_t
op_star
)paren
suffix:semicolon
r_extern
r_void
id|block_all_signals
c_func
(paren
r_int
(paren
op_star
id|notifier
)paren
(paren
r_void
op_star
id|priv
)paren
comma
r_void
op_star
id|priv
comma
id|sigset_t
op_star
id|mask
)paren
suffix:semicolon
r_extern
r_void
id|unblock_all_signals
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|send_sig_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|force_sig_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|kill_pg_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
id|pid_t
)paren
suffix:semicolon
r_extern
r_int
id|kill_sl_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
id|pid_t
)paren
suffix:semicolon
r_extern
r_int
id|kill_proc_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
id|pid_t
)paren
suffix:semicolon
r_extern
r_void
id|notify_parent
c_func
(paren
r_struct
id|task_struct
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|do_notify_parent
c_func
(paren
r_struct
id|task_struct
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|force_sig
c_func
(paren
r_int
comma
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|send_sig
c_func
(paren
r_int
comma
r_struct
id|task_struct
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|kill_pg
c_func
(paren
id|pid_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|kill_sl
c_func
(paren
id|pid_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|kill_proc
c_func
(paren
id|pid_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|do_sigaction
c_func
(paren
r_int
comma
r_const
r_struct
id|k_sigaction
op_star
comma
r_struct
id|k_sigaction
op_star
)paren
suffix:semicolon
r_extern
r_int
id|do_sigaltstack
c_func
(paren
r_const
id|stack_t
op_star
comma
id|stack_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
DECL|function|signal_pending
r_static
r_inline
r_int
id|signal_pending
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_return
(paren
id|p-&gt;sigpending
op_ne
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Re-calculate pending state from the set of locally pending&n; * signals, globally pending signals, and blocked signals.&n; */
DECL|function|has_pending_signals
r_static
r_inline
r_int
id|has_pending_signals
c_func
(paren
id|sigset_t
op_star
id|signal
comma
id|sigset_t
op_star
id|blocked
)paren
(brace
r_int
r_int
id|ready
suffix:semicolon
r_int
id|i
suffix:semicolon
r_switch
c_cond
(paren
id|_NSIG_WORDS
)paren
(brace
r_default
suffix:colon
(brace
)brace
r_for
c_loop
(paren
id|i
op_assign
id|_NSIG_WORDS
comma
id|ready
op_assign
l_int|0
suffix:semicolon
op_decrement
id|i
op_ge
l_int|0
suffix:semicolon
)paren
id|ready
op_or_assign
id|signal-&gt;sig
(braket
id|i
)braket
op_amp
op_complement
id|blocked-&gt;sig
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|ready
op_assign
id|signal-&gt;sig
(braket
l_int|3
)braket
op_amp
op_complement
id|blocked-&gt;sig
(braket
l_int|3
)braket
suffix:semicolon
id|ready
op_or_assign
id|signal-&gt;sig
(braket
l_int|2
)braket
op_amp
op_complement
id|blocked-&gt;sig
(braket
l_int|2
)braket
suffix:semicolon
id|ready
op_or_assign
id|signal-&gt;sig
(braket
l_int|1
)braket
op_amp
op_complement
id|blocked-&gt;sig
(braket
l_int|1
)braket
suffix:semicolon
id|ready
op_or_assign
id|signal-&gt;sig
(braket
l_int|0
)braket
op_amp
op_complement
id|blocked-&gt;sig
(braket
l_int|0
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|ready
op_assign
id|signal-&gt;sig
(braket
l_int|1
)braket
op_amp
op_complement
id|blocked-&gt;sig
(braket
l_int|1
)braket
suffix:semicolon
id|ready
op_or_assign
id|signal-&gt;sig
(braket
l_int|0
)braket
op_amp
op_complement
id|blocked-&gt;sig
(braket
l_int|0
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|ready
op_assign
id|signal-&gt;sig
(braket
l_int|0
)braket
op_amp
op_complement
id|blocked-&gt;sig
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_return
id|ready
op_ne
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Reevaluate whether the task has signals pending delivery.&n;   This is required every time the blocked sigset_t changes.&n;   All callers should have t-&gt;sigmask_lock.  */
DECL|function|recalc_sigpending
r_static
r_inline
r_void
id|recalc_sigpending
c_func
(paren
r_struct
id|task_struct
op_star
id|t
)paren
(brace
id|t-&gt;sigpending
op_assign
id|has_pending_signals
c_func
(paren
op_amp
id|t-&gt;pending.signal
comma
op_amp
id|t-&gt;blocked
)paren
suffix:semicolon
)brace
multiline_comment|/* True if we are on the alternate signal stack.  */
DECL|function|on_sig_stack
r_static
r_inline
r_int
id|on_sig_stack
c_func
(paren
r_int
r_int
id|sp
)paren
(brace
r_return
(paren
id|sp
op_minus
id|current-&gt;sas_ss_sp
OL
id|current-&gt;sas_ss_size
)paren
suffix:semicolon
)brace
DECL|function|sas_ss_flags
r_static
r_inline
r_int
id|sas_ss_flags
c_func
(paren
r_int
r_int
id|sp
)paren
(brace
r_return
(paren
id|current-&gt;sas_ss_size
op_eq
l_int|0
ques
c_cond
id|SS_DISABLE
suffix:colon
id|on_sig_stack
c_func
(paren
id|sp
)paren
ques
c_cond
id|SS_ONSTACK
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_extern
r_int
id|request_irq
c_func
(paren
r_int
r_int
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
comma
r_const
r_char
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_extern
r_void
id|free_irq
c_func
(paren
r_int
r_int
comma
r_void
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * This has now become a routine instead of a macro, it sets a flag if&n; * it returns true (to do BSD-style accounting where the process is flagged&n; * if it uses root privs). The implication of this is that you should do&n; * normal permissions checks first, and check suser() last.&n; *&n; * [Dec 1997 -- Chris Evans]&n; * For correctness, the above considerations need to be extended to&n; * fsuser(). This is done, along with moving fsuser() checks to be&n; * last.&n; *&n; * These will be removed, but in the mean time, when the SECURE_NOROOT &n; * flag is set, uids don&squot;t grant privilege.&n; */
DECL|function|suser
r_static
r_inline
r_int
id|suser
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|issecure
c_func
(paren
id|SECURE_NOROOT
)paren
op_logical_and
id|current-&gt;euid
op_eq
l_int|0
)paren
(brace
id|current-&gt;flags
op_or_assign
id|PF_SUPERPRIV
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fsuser
r_static
r_inline
r_int
id|fsuser
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|issecure
c_func
(paren
id|SECURE_NOROOT
)paren
op_logical_and
id|current-&gt;fsuid
op_eq
l_int|0
)paren
(brace
id|current-&gt;flags
op_or_assign
id|PF_SUPERPRIV
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * capable() checks for a particular capability.  &n; * New privilege checks should use this interface, rather than suser() or&n; * fsuser(). See include/linux/capability.h for defined capabilities.&n; */
DECL|function|capable
r_static
r_inline
r_int
id|capable
c_func
(paren
r_int
id|cap
)paren
(brace
macro_line|#if 1 /* ok now */
r_if
c_cond
(paren
id|cap_raised
c_func
(paren
id|current-&gt;cap_effective
comma
id|cap
)paren
)paren
macro_line|#else
r_if
c_cond
(paren
id|cap_is_fs_cap
c_func
(paren
id|cap
)paren
ques
c_cond
id|current-&gt;fsuid
op_eq
l_int|0
suffix:colon
id|current-&gt;euid
op_eq
l_int|0
)paren
macro_line|#endif
(brace
id|current-&gt;flags
op_or_assign
id|PF_SUPERPRIV
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Routines for handling mm_structs&n; */
r_extern
r_struct
id|mm_struct
op_star
id|mm_alloc
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_struct
id|mm_struct
op_star
id|start_lazy_tlb
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|end_lazy_tlb
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
suffix:semicolon
multiline_comment|/* mmdrop drops the mm and the page tables */
r_extern
r_inline
r_void
id|FASTCALL
c_func
(paren
id|__mmdrop
c_func
(paren
r_struct
id|mm_struct
op_star
)paren
)paren
suffix:semicolon
DECL|function|mmdrop
r_static
r_inline
r_void
id|mmdrop
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|mm-&gt;mm_count
)paren
)paren
id|__mmdrop
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
multiline_comment|/* mmput gets rid of the mappings and all user-space */
r_extern
r_void
id|mmput
c_func
(paren
r_struct
id|mm_struct
op_star
)paren
suffix:semicolon
multiline_comment|/* Remove the current tasks stale references to the old mm_struct */
r_extern
r_void
id|mm_release
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * Routines for handling the fd arrays&n; */
r_extern
r_struct
id|file
op_star
op_star
id|alloc_fd_array
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_int
id|expand_fd_array
c_func
(paren
r_struct
id|files_struct
op_star
comma
r_int
id|nr
)paren
suffix:semicolon
r_extern
r_void
id|free_fd_array
c_func
(paren
r_struct
id|file
op_star
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
id|fd_set
op_star
id|alloc_fdset
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_int
id|expand_fdset
c_func
(paren
r_struct
id|files_struct
op_star
comma
r_int
id|nr
)paren
suffix:semicolon
r_extern
r_void
id|free_fdset
c_func
(paren
id|fd_set
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|copy_thread
c_func
(paren
r_int
comma
r_int
r_int
comma
r_int
r_int
comma
r_int
r_int
comma
r_struct
id|task_struct
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_extern
r_void
id|flush_thread
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|exit_thread
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|exit_mm
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|exit_files
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|exit_sighand
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|daemonize
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|do_execve
c_func
(paren
r_char
op_star
comma
r_char
op_star
op_star
comma
r_char
op_star
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_extern
r_int
id|do_fork
c_func
(paren
r_int
r_int
comma
r_int
r_int
comma
r_struct
id|pt_regs
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|add_wait_queue
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
id|wait_queue_t
op_star
id|wait
)paren
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|add_wait_queue_exclusive
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
id|wait_queue_t
op_star
id|wait
)paren
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|remove_wait_queue
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
id|wait_queue_t
op_star
id|wait
)paren
)paren
suffix:semicolon
DECL|macro|__wait_event
mdefine_line|#define __wait_event(wq, condition) &t;&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;wait_queue_t __wait;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;init_waitqueue_entry(&amp;__wait, current);&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;add_wait_queue(&amp;wq, &amp;__wait);&t;&t;&t;&t;&t;&bslash;&n;&t;for (;;) {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;set_current_state(TASK_UNINTERRUPTIBLE);&t;&t;&bslash;&n;&t;&t;if (condition)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;schedule();&t;&t;&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;current-&gt;state = TASK_RUNNING;&t;&t;&t;&t;&t;&bslash;&n;&t;remove_wait_queue(&amp;wq, &amp;__wait);&t;&t;&t;&t;&bslash;&n;} while (0)
DECL|macro|wait_event
mdefine_line|#define wait_event(wq, condition) &t;&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (condition)&t; &t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;__wait_event(wq, condition);&t;&t;&t;&t;&t;&bslash;&n;} while (0)
DECL|macro|__wait_event_interruptible
mdefine_line|#define __wait_event_interruptible(wq, condition, ret)&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;wait_queue_t __wait;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;init_waitqueue_entry(&amp;__wait, current);&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;add_wait_queue(&amp;wq, &amp;__wait);&t;&t;&t;&t;&t;&bslash;&n;&t;for (;;) {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;set_current_state(TASK_INTERRUPTIBLE);&t;&t;&t;&bslash;&n;&t;&t;if (condition)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (!signal_pending(current)) {&t;&t;&t;&t;&bslash;&n;&t;&t;&t;schedule();&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;continue;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;ret = -ERESTARTSYS;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;current-&gt;state = TASK_RUNNING;&t;&t;&t;&t;&t;&bslash;&n;&t;remove_wait_queue(&amp;wq, &amp;__wait);&t;&t;&t;&t;&bslash;&n;} while (0)
DECL|macro|wait_event_interruptible
mdefine_line|#define wait_event_interruptible(wq, condition)&t;&t;&t;&t;&bslash;&n;({&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;int __ret = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (!(condition))&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__wait_event_interruptible(wq, condition, __ret);&t;&bslash;&n;&t;__ret;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;})
DECL|macro|REMOVE_LINKS
mdefine_line|#define REMOVE_LINKS(p) do { &bslash;&n;&t;(p)-&gt;next_task-&gt;prev_task = (p)-&gt;prev_task; &bslash;&n;&t;(p)-&gt;prev_task-&gt;next_task = (p)-&gt;next_task; &bslash;&n;&t;if ((p)-&gt;p_osptr) &bslash;&n;&t;&t;(p)-&gt;p_osptr-&gt;p_ysptr = (p)-&gt;p_ysptr; &bslash;&n;&t;if ((p)-&gt;p_ysptr) &bslash;&n;&t;&t;(p)-&gt;p_ysptr-&gt;p_osptr = (p)-&gt;p_osptr; &bslash;&n;&t;else &bslash;&n;&t;&t;(p)-&gt;p_pptr-&gt;p_cptr = (p)-&gt;p_osptr; &bslash;&n;&t;} while (0)
DECL|macro|SET_LINKS
mdefine_line|#define SET_LINKS(p) do { &bslash;&n;&t;(p)-&gt;next_task = &amp;init_task; &bslash;&n;&t;(p)-&gt;prev_task = init_task.prev_task; &bslash;&n;&t;init_task.prev_task-&gt;next_task = (p); &bslash;&n;&t;init_task.prev_task = (p); &bslash;&n;&t;(p)-&gt;p_ysptr = NULL; &bslash;&n;&t;if (((p)-&gt;p_osptr = (p)-&gt;p_pptr-&gt;p_cptr) != NULL) &bslash;&n;&t;&t;(p)-&gt;p_osptr-&gt;p_ysptr = p; &bslash;&n;&t;(p)-&gt;p_pptr-&gt;p_cptr = p; &bslash;&n;&t;} while (0)
DECL|macro|for_each_task
mdefine_line|#define for_each_task(p) &bslash;&n;&t;for (p = &amp;init_task ; (p = p-&gt;next_task) != &amp;init_task ; )
DECL|macro|next_thread
mdefine_line|#define next_thread(p) &bslash;&n;&t;list_entry((p)-&gt;thread_group.next, struct task_struct, thread_group)
DECL|function|del_from_runqueue
r_static
r_inline
r_void
id|del_from_runqueue
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|nr_running
op_decrement
suffix:semicolon
id|p-&gt;sleep_time
op_assign
id|jiffies
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|p-&gt;run_list
)paren
suffix:semicolon
id|p-&gt;run_list.next
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|task_on_runqueue
r_static
r_inline
r_int
id|task_on_runqueue
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_return
(paren
id|p-&gt;run_list.next
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|unhash_process
r_static
r_inline
r_void
id|unhash_process
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|task_on_runqueue
c_func
(paren
id|p
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|write_lock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|nr_threads
op_decrement
suffix:semicolon
id|unhash_pid
c_func
(paren
id|p
)paren
suffix:semicolon
id|REMOVE_LINKS
c_func
(paren
id|p
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|p-&gt;thread_group
)paren
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
DECL|function|task_lock
r_static
r_inline
r_void
id|task_lock
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|p-&gt;alloc_lock
)paren
suffix:semicolon
)brace
DECL|function|task_unlock
r_static
r_inline
r_void
id|task_unlock
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|p-&gt;alloc_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* write full pathname into buffer and return start of pathname */
DECL|function|d_path
r_static
r_inline
r_char
op_star
id|d_path
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|vfsmount
op_star
id|vfsmnt
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
)paren
(brace
r_char
op_star
id|res
suffix:semicolon
r_struct
id|vfsmount
op_star
id|rootmnt
suffix:semicolon
r_struct
id|dentry
op_star
id|root
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
id|rootmnt
op_assign
id|mntget
c_func
(paren
id|current-&gt;fs-&gt;rootmnt
)paren
suffix:semicolon
id|root
op_assign
id|dget
c_func
(paren
id|current-&gt;fs-&gt;root
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|res
op_assign
id|__d_path
c_func
(paren
id|dentry
comma
id|vfsmnt
comma
id|root
comma
id|rootmnt
comma
id|buf
comma
id|buflen
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|dput
c_func
(paren
id|root
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|rootmnt
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
macro_line|#endif /* __KERNEL__ */
macro_line|#endif
eof
