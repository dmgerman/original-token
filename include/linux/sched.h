macro_line|#ifndef _LINUX_SCHED_H
DECL|macro|_LINUX_SCHED_H
mdefine_line|#define _LINUX_SCHED_H
macro_line|#include &lt;asm/param.h&gt;&t;/* for HZ */
r_extern
r_int
r_int
id|event
suffix:semicolon
macro_line|#include &lt;linux/binfmts.h&gt;
macro_line|#include &lt;linux/personality.h&gt;
macro_line|#include &lt;linux/threads.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/times.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/sem.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/securebits.h&gt;
multiline_comment|/*&n; * cloning flags:&n; */
DECL|macro|CSIGNAL
mdefine_line|#define CSIGNAL&t;&t;0x000000ff&t;/* signal mask to be sent at exit */
DECL|macro|CLONE_VM
mdefine_line|#define CLONE_VM&t;0x00000100&t;/* set if VM shared between processes */
DECL|macro|CLONE_FS
mdefine_line|#define CLONE_FS&t;0x00000200&t;/* set if fs info shared between processes */
DECL|macro|CLONE_FILES
mdefine_line|#define CLONE_FILES&t;0x00000400&t;/* set if open files shared between processes */
DECL|macro|CLONE_SIGHAND
mdefine_line|#define CLONE_SIGHAND&t;0x00000800&t;/* set if signal handlers shared */
DECL|macro|CLONE_PID
mdefine_line|#define CLONE_PID&t;0x00001000&t;/* set if pid shared */
DECL|macro|CLONE_PTRACE
mdefine_line|#define CLONE_PTRACE&t;0x00002000&t;/* set if we want to let tracing continue on the child too */
DECL|macro|CLONE_VFORK
mdefine_line|#define CLONE_VFORK&t;0x00004000&t;/* set if the parent wants the child to wake it up on mm_release */
DECL|macro|CLONE_PARENT
mdefine_line|#define CLONE_PARENT&t;0x00008000&t;/* set if we want to have the same parent as the cloner */
multiline_comment|/*&n; * These are the constant used to fake the fixed-point load-average&n; * counting. Some notes:&n; *  - 11 bit fractions expand to 22 bits by the multiplies: this gives&n; *    a load-average precision of 10 bits integer + 11 bits fractional&n; *  - if you want to count load-averages more often, you need more&n; *    precision, or rounding will get you. With 2-second counting freq,&n; *    the EXP_n values would be 1981, 2034 and 2043 if still using only&n; *    11 bit fractions.&n; */
r_extern
r_int
r_int
id|avenrun
(braket
)braket
suffix:semicolon
multiline_comment|/* Load averages */
DECL|macro|FSHIFT
mdefine_line|#define FSHIFT&t;&t;11&t;&t;/* nr of bits of precision */
DECL|macro|FIXED_1
mdefine_line|#define FIXED_1&t;&t;(1&lt;&lt;FSHIFT)&t;/* 1.0 as fixed-point */
DECL|macro|LOAD_FREQ
mdefine_line|#define LOAD_FREQ&t;(5*HZ)&t;&t;/* 5 sec intervals */
DECL|macro|EXP_1
mdefine_line|#define EXP_1&t;&t;1884&t;&t;/* 1/exp(5sec/1min) as fixed-point */
DECL|macro|EXP_5
mdefine_line|#define EXP_5&t;&t;2014&t;&t;/* 1/exp(5sec/5min) */
DECL|macro|EXP_15
mdefine_line|#define EXP_15&t;&t;2037&t;&t;/* 1/exp(5sec/15min) */
DECL|macro|CALC_LOAD
mdefine_line|#define CALC_LOAD(load,exp,n) &bslash;&n;&t;load *= exp; &bslash;&n;&t;load += n*(FIXED_1-exp); &bslash;&n;&t;load &gt;&gt;= FSHIFT;
DECL|macro|CT_TO_SECS
mdefine_line|#define CT_TO_SECS(x)&t;((x) / HZ)
DECL|macro|CT_TO_USECS
mdefine_line|#define CT_TO_USECS(x)&t;(((x) % HZ) * 1000000/HZ)
r_extern
r_int
id|nr_running
comma
id|nr_threads
suffix:semicolon
r_extern
r_int
id|last_pid
suffix:semicolon
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/param.h&gt;
macro_line|#include &lt;linux/resource.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
DECL|macro|TASK_RUNNING
mdefine_line|#define TASK_RUNNING&t;&t;0
DECL|macro|TASK_INTERRUPTIBLE
mdefine_line|#define TASK_INTERRUPTIBLE&t;1
DECL|macro|TASK_UNINTERRUPTIBLE
mdefine_line|#define TASK_UNINTERRUPTIBLE&t;2
DECL|macro|TASK_ZOMBIE
mdefine_line|#define TASK_ZOMBIE&t;&t;4
DECL|macro|TASK_STOPPED
mdefine_line|#define TASK_STOPPED&t;&t;8
DECL|macro|TASK_EXCLUSIVE
mdefine_line|#define TASK_EXCLUSIVE&t;&t;32
DECL|macro|__set_task_state
mdefine_line|#define __set_task_state(tsk, state_value)&t;&t;&bslash;&n;&t;do { (tsk)-&gt;state = (state_value); } while (0)
macro_line|#ifdef __SMP__
DECL|macro|set_task_state
mdefine_line|#define set_task_state(tsk, state_value)&t;&t;&bslash;&n;&t;set_mb((tsk)-&gt;state, (state_value))
macro_line|#else
DECL|macro|set_task_state
mdefine_line|#define set_task_state(tsk, state_value)&t;&t;&bslash;&n;&t;__set_task_state((tsk), (state_value))
macro_line|#endif
DECL|macro|__set_current_state
mdefine_line|#define __set_current_state(state_value)&t;&t;&t;&bslash;&n;&t;do { current-&gt;state = (state_value); } while (0)
macro_line|#ifdef __SMP__
DECL|macro|set_current_state
mdefine_line|#define set_current_state(state_value)&t;&t;&bslash;&n;&t;set_mb(current-&gt;state, (state_value))
macro_line|#else
DECL|macro|set_current_state
mdefine_line|#define set_current_state(state_value)&t;&t;&bslash;&n;&t;__set_current_state(state_value)
macro_line|#endif
multiline_comment|/*&n; * Scheduling policies&n; */
DECL|macro|SCHED_OTHER
mdefine_line|#define SCHED_OTHER&t;&t;0
DECL|macro|SCHED_FIFO
mdefine_line|#define SCHED_FIFO&t;&t;1
DECL|macro|SCHED_RR
mdefine_line|#define SCHED_RR&t;&t;2
multiline_comment|/*&n; * This is an additional bit set when we want to&n; * yield the CPU for one re-schedule..&n; */
DECL|macro|SCHED_YIELD
mdefine_line|#define SCHED_YIELD&t;&t;0x10
DECL|struct|sched_param
r_struct
id|sched_param
(brace
DECL|member|sched_priority
r_int
id|sched_priority
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifdef __KERNEL__
macro_line|#include &lt;linux/spinlock.h&gt;
multiline_comment|/*&n; * This serializes &quot;schedule()&quot; and also protects&n; * the run-queue from deletions/modifications (but&n; * _adding_ to the beginning of the run-queue has&n; * a separate lock).&n; */
r_extern
id|rwlock_t
id|tasklist_lock
suffix:semicolon
r_extern
id|spinlock_t
id|runqueue_lock
suffix:semicolon
r_extern
r_void
id|sched_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|init_idle
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|show_state
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|cpu_init
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|trap_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|update_one_process
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
r_int
id|ticks
comma
r_int
r_int
id|user
comma
r_int
r_int
id|system
comma
r_int
id|cpu
)paren
suffix:semicolon
DECL|macro|MAX_SCHEDULE_TIMEOUT
mdefine_line|#define&t;MAX_SCHEDULE_TIMEOUT&t;LONG_MAX
r_extern
r_int
r_int
id|FASTCALL
c_func
(paren
id|schedule_timeout
c_func
(paren
r_int
r_int
id|timeout
)paren
)paren
suffix:semicolon
id|asmlinkage
r_void
id|schedule
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * The default fd array needs to be at least BITS_PER_LONG,&n; * as this is the granularity returned by copy_fdset().&n; */
DECL|macro|NR_OPEN_DEFAULT
mdefine_line|#define NR_OPEN_DEFAULT BITS_PER_LONG
multiline_comment|/*&n; * Open file table structure&n; */
DECL|struct|files_struct
r_struct
id|files_struct
(brace
DECL|member|count
id|atomic_t
id|count
suffix:semicolon
DECL|member|file_lock
id|rwlock_t
id|file_lock
suffix:semicolon
DECL|member|max_fds
r_int
id|max_fds
suffix:semicolon
DECL|member|max_fdset
r_int
id|max_fdset
suffix:semicolon
DECL|member|next_fd
r_int
id|next_fd
suffix:semicolon
DECL|member|fd
r_struct
id|file
op_star
op_star
id|fd
suffix:semicolon
multiline_comment|/* current fd array */
DECL|member|close_on_exec
id|fd_set
op_star
id|close_on_exec
suffix:semicolon
DECL|member|open_fds
id|fd_set
op_star
id|open_fds
suffix:semicolon
DECL|member|close_on_exec_init
id|fd_set
id|close_on_exec_init
suffix:semicolon
DECL|member|open_fds_init
id|fd_set
id|open_fds_init
suffix:semicolon
DECL|member|fd_array
r_struct
id|file
op_star
id|fd_array
(braket
id|NR_OPEN_DEFAULT
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|INIT_FILES
mdefine_line|#define INIT_FILES { &bslash;&n;&t;ATOMIC_INIT(1), &bslash;&n;&t;RW_LOCK_UNLOCKED, &bslash;&n;&t;NR_OPEN_DEFAULT, &bslash;&n;&t;__FD_SETSIZE, &bslash;&n;&t;0, &bslash;&n;&t;&amp;init_files.fd_array[0], &bslash;&n;&t;&amp;init_files.close_on_exec_init, &bslash;&n;&t;&amp;init_files.open_fds_init, &bslash;&n;&t;{ { 0, } }, &bslash;&n;&t;{ { 0, } }, &bslash;&n;&t;{ NULL, } &bslash;&n;}
DECL|struct|fs_struct
r_struct
id|fs_struct
(brace
DECL|member|count
id|atomic_t
id|count
suffix:semicolon
DECL|member|umask
r_int
id|umask
suffix:semicolon
DECL|member|root
DECL|member|pwd
r_struct
id|dentry
op_star
id|root
comma
op_star
id|pwd
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|INIT_FS
mdefine_line|#define INIT_FS { &bslash;&n;&t;ATOMIC_INIT(1), &bslash;&n;&t;0022, &bslash;&n;&t;NULL, NULL &bslash;&n;}
multiline_comment|/* Maximum number of active map areas.. This is a random (large) number */
DECL|macro|MAX_MAP_COUNT
mdefine_line|#define MAX_MAP_COUNT&t;(65536)
multiline_comment|/* Number of map areas at which the AVL tree is activated. This is arbitrary. */
DECL|macro|AVL_MIN_MAP_COUNT
mdefine_line|#define AVL_MIN_MAP_COUNT&t;32
DECL|struct|mm_struct
r_struct
id|mm_struct
(brace
DECL|member|mmap
r_struct
id|vm_area_struct
op_star
id|mmap
suffix:semicolon
multiline_comment|/* list of VMAs */
DECL|member|mmap_avl
r_struct
id|vm_area_struct
op_star
id|mmap_avl
suffix:semicolon
multiline_comment|/* tree of VMAs */
DECL|member|mmap_cache
r_struct
id|vm_area_struct
op_star
id|mmap_cache
suffix:semicolon
multiline_comment|/* last find_vma result */
DECL|member|pgd
id|pgd_t
op_star
id|pgd
suffix:semicolon
DECL|member|mm_users
id|atomic_t
id|mm_users
suffix:semicolon
multiline_comment|/* How many users with user space? */
DECL|member|mm_count
id|atomic_t
id|mm_count
suffix:semicolon
multiline_comment|/* How many references to &quot;struct mm_struct&quot; (users count as 1) */
DECL|member|map_count
r_int
id|map_count
suffix:semicolon
multiline_comment|/* number of VMAs */
DECL|member|mmap_sem
r_struct
id|semaphore
id|mmap_sem
suffix:semicolon
DECL|member|page_table_lock
id|spinlock_t
id|page_table_lock
suffix:semicolon
DECL|member|context
r_int
r_int
id|context
suffix:semicolon
DECL|member|start_code
DECL|member|end_code
DECL|member|start_data
DECL|member|end_data
r_int
r_int
id|start_code
comma
id|end_code
comma
id|start_data
comma
id|end_data
suffix:semicolon
DECL|member|start_brk
DECL|member|brk
DECL|member|start_stack
r_int
r_int
id|start_brk
comma
id|brk
comma
id|start_stack
suffix:semicolon
DECL|member|arg_start
DECL|member|arg_end
DECL|member|env_start
DECL|member|env_end
r_int
r_int
id|arg_start
comma
id|arg_end
comma
id|env_start
comma
id|env_end
suffix:semicolon
DECL|member|rss
DECL|member|total_vm
DECL|member|locked_vm
r_int
r_int
id|rss
comma
id|total_vm
comma
id|locked_vm
suffix:semicolon
DECL|member|def_flags
r_int
r_int
id|def_flags
suffix:semicolon
DECL|member|cpu_vm_mask
r_int
r_int
id|cpu_vm_mask
suffix:semicolon
DECL|member|swap_cnt
r_int
r_int
id|swap_cnt
suffix:semicolon
multiline_comment|/* number of pages to swap on next pass */
DECL|member|swap_address
r_int
r_int
id|swap_address
suffix:semicolon
multiline_comment|/*&n;&t; * This is an architecture-specific pointer: the portable&n;&t; * part of Linux does not know about any segments.&n;&t; */
DECL|member|segments
r_void
op_star
id|segments
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|INIT_MM
mdefine_line|#define INIT_MM(name) {&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&amp;init_mmap, NULL, NULL,&t;&t;&t;&bslash;&n;&t;&t;swapper_pg_dir, &t;&t;&t;&bslash;&n;&t;&t;ATOMIC_INIT(2), ATOMIC_INIT(1), 1,&t;&bslash;&n;&t;&t;__MUTEX_INITIALIZER(name.mmap_sem),&t;&bslash;&n;&t;&t;SPIN_LOCK_UNLOCKED,&t;&t;&t;&bslash;&n;&t;&t;0,&t;&t;&t;&t;&t;&bslash;&n;&t;&t;0, 0, 0, 0,&t;&t;&t;&t;&bslash;&n;&t;&t;0, 0, 0, &t;&t;&t;&t;&bslash;&n;&t;&t;0, 0, 0, 0,&t;&t;&t;&t;&bslash;&n;&t;&t;0, 0, 0,&t;&t;&t;&t;&bslash;&n;&t;&t;0, 0, 0, 0, NULL }
DECL|struct|signal_struct
r_struct
id|signal_struct
(brace
DECL|member|count
id|atomic_t
id|count
suffix:semicolon
DECL|member|action
r_struct
id|k_sigaction
id|action
(braket
id|_NSIG
)braket
suffix:semicolon
DECL|member|siglock
id|spinlock_t
id|siglock
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|INIT_SIGNALS
mdefine_line|#define INIT_SIGNALS { &bslash;&n;&t;&t;ATOMIC_INIT(1), &bslash;&n;&t;&t;{ {{0,}}, }, &bslash;&n;&t;&t;SPIN_LOCK_UNLOCKED }
multiline_comment|/*&n; * Some day this will be a full-fledged user tracking system..&n; * Right now it is only used to track how many processes a&n; * user has, but it has the potential to track memory usage etc.&n; */
r_struct
id|user_struct
suffix:semicolon
DECL|struct|task_struct
r_struct
id|task_struct
(brace
multiline_comment|/* these are hardcoded - don&squot;t touch */
DECL|member|state
r_volatile
r_int
id|state
suffix:semicolon
multiline_comment|/* -1 unrunnable, 0 runnable, &gt;0 stopped */
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* per process flags, defined below */
DECL|member|sigpending
r_int
id|sigpending
suffix:semicolon
DECL|member|addr_limit
id|mm_segment_t
id|addr_limit
suffix:semicolon
multiline_comment|/* thread address space:&n;&t;&t;&t;&t;&t; &t;0-0xBFFFFFFF for user-thead&n;&t;&t;&t;&t;&t;&t;0-0xFFFFFFFF for kernel-thread&n;&t;&t;&t;&t;&t; */
DECL|member|exec_domain
r_struct
id|exec_domain
op_star
id|exec_domain
suffix:semicolon
DECL|member|need_resched
r_volatile
r_int
id|need_resched
suffix:semicolon
DECL|member|avg_slice
id|cycles_t
id|avg_slice
suffix:semicolon
DECL|member|lock_depth
r_int
id|lock_depth
suffix:semicolon
multiline_comment|/* Lock depth. We can context switch in and out of holding a syscall kernel lock... */
multiline_comment|/* begin intel cache line */
DECL|member|counter
r_int
id|counter
suffix:semicolon
DECL|member|priority
r_int
id|priority
suffix:semicolon
DECL|member|policy
r_int
r_int
id|policy
suffix:semicolon
multiline_comment|/* memory management info */
DECL|member|mm
DECL|member|active_mm
r_struct
id|mm_struct
op_star
id|mm
comma
op_star
id|active_mm
suffix:semicolon
DECL|member|has_cpu
r_int
id|has_cpu
suffix:semicolon
DECL|member|processor
r_int
id|processor
suffix:semicolon
DECL|member|run_list
r_struct
id|list_head
id|run_list
suffix:semicolon
DECL|member|next_task
DECL|member|prev_task
r_struct
id|task_struct
op_star
id|next_task
comma
op_star
id|prev_task
suffix:semicolon
DECL|member|last_processor
r_int
id|last_processor
suffix:semicolon
multiline_comment|/* task state */
DECL|member|binfmt
r_struct
id|linux_binfmt
op_star
id|binfmt
suffix:semicolon
DECL|member|exit_code
DECL|member|exit_signal
r_int
id|exit_code
comma
id|exit_signal
suffix:semicolon
DECL|member|pdeath_signal
r_int
id|pdeath_signal
suffix:semicolon
multiline_comment|/*  The signal sent when the parent dies  */
multiline_comment|/* ??? */
DECL|member|personality
r_int
r_int
id|personality
suffix:semicolon
DECL|member|dumpable
r_int
id|dumpable
suffix:colon
l_int|1
suffix:semicolon
DECL|member|did_exec
r_int
id|did_exec
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pid
id|pid_t
id|pid
suffix:semicolon
DECL|member|pgrp
id|pid_t
id|pgrp
suffix:semicolon
DECL|member|tty_old_pgrp
id|pid_t
id|tty_old_pgrp
suffix:semicolon
DECL|member|session
id|pid_t
id|session
suffix:semicolon
multiline_comment|/* boolean value for session group leader */
DECL|member|leader
r_int
id|leader
suffix:semicolon
multiline_comment|/* &n;&t; * pointers to (original) parent process, youngest child, younger sibling,&n;&t; * older sibling, respectively.  (p-&gt;father can be replaced with &n;&t; * p-&gt;p_pptr-&gt;pid)&n;&t; */
DECL|member|p_opptr
DECL|member|p_pptr
DECL|member|p_cptr
DECL|member|p_ysptr
DECL|member|p_osptr
r_struct
id|task_struct
op_star
id|p_opptr
comma
op_star
id|p_pptr
comma
op_star
id|p_cptr
comma
op_star
id|p_ysptr
comma
op_star
id|p_osptr
suffix:semicolon
multiline_comment|/* PID hash table linkage. */
DECL|member|pidhash_next
r_struct
id|task_struct
op_star
id|pidhash_next
suffix:semicolon
DECL|member|pidhash_pprev
r_struct
id|task_struct
op_star
op_star
id|pidhash_pprev
suffix:semicolon
DECL|member|wait_chldexit
id|wait_queue_head_t
id|wait_chldexit
suffix:semicolon
multiline_comment|/* for wait4() */
DECL|member|vfork_sem
r_struct
id|semaphore
op_star
id|vfork_sem
suffix:semicolon
multiline_comment|/* for vfork() */
DECL|member|rt_priority
r_int
r_int
id|rt_priority
suffix:semicolon
DECL|member|it_real_value
DECL|member|it_prof_value
DECL|member|it_virt_value
r_int
r_int
id|it_real_value
comma
id|it_prof_value
comma
id|it_virt_value
suffix:semicolon
DECL|member|it_real_incr
DECL|member|it_prof_incr
DECL|member|it_virt_incr
r_int
r_int
id|it_real_incr
comma
id|it_prof_incr
comma
id|it_virt_incr
suffix:semicolon
DECL|member|real_timer
r_struct
id|timer_list
id|real_timer
suffix:semicolon
DECL|member|times
r_struct
id|tms
id|times
suffix:semicolon
DECL|member|start_time
r_int
r_int
id|start_time
suffix:semicolon
DECL|member|per_cpu_utime
DECL|member|per_cpu_stime
r_int
id|per_cpu_utime
(braket
id|NR_CPUS
)braket
comma
id|per_cpu_stime
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */
DECL|member|min_flt
DECL|member|maj_flt
DECL|member|nswap
DECL|member|cmin_flt
DECL|member|cmaj_flt
DECL|member|cnswap
r_int
r_int
id|min_flt
comma
id|maj_flt
comma
id|nswap
comma
id|cmin_flt
comma
id|cmaj_flt
comma
id|cnswap
suffix:semicolon
DECL|member|swappable
r_int
id|swappable
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* process credentials */
DECL|member|uid
DECL|member|euid
DECL|member|suid
DECL|member|fsuid
id|uid_t
id|uid
comma
id|euid
comma
id|suid
comma
id|fsuid
suffix:semicolon
DECL|member|gid
DECL|member|egid
DECL|member|sgid
DECL|member|fsgid
id|gid_t
id|gid
comma
id|egid
comma
id|sgid
comma
id|fsgid
suffix:semicolon
DECL|member|ngroups
r_int
id|ngroups
suffix:semicolon
DECL|member|groups
id|gid_t
id|groups
(braket
id|NGROUPS
)braket
suffix:semicolon
DECL|member|cap_effective
DECL|member|cap_inheritable
DECL|member|cap_permitted
id|kernel_cap_t
id|cap_effective
comma
id|cap_inheritable
comma
id|cap_permitted
suffix:semicolon
DECL|member|user
r_struct
id|user_struct
op_star
id|user
suffix:semicolon
multiline_comment|/* limits */
DECL|member|rlim
r_struct
id|rlimit
id|rlim
(braket
id|RLIM_NLIMITS
)braket
suffix:semicolon
DECL|member|used_math
r_int
r_int
id|used_math
suffix:semicolon
DECL|member|comm
r_char
id|comm
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* file system info */
DECL|member|link_count
r_int
id|link_count
suffix:semicolon
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
multiline_comment|/* NULL if no tty */
multiline_comment|/* ipc stuff */
DECL|member|semundo
r_struct
id|sem_undo
op_star
id|semundo
suffix:semicolon
DECL|member|semsleeping
r_struct
id|sem_queue
op_star
id|semsleeping
suffix:semicolon
multiline_comment|/* CPU-specific state of this task */
DECL|member|thread
r_struct
id|thread_struct
id|thread
suffix:semicolon
multiline_comment|/* filesystem information */
DECL|member|fs
r_struct
id|fs_struct
op_star
id|fs
suffix:semicolon
multiline_comment|/* open file information */
DECL|member|files
r_struct
id|files_struct
op_star
id|files
suffix:semicolon
multiline_comment|/* signal handlers */
DECL|member|sigmask_lock
id|spinlock_t
id|sigmask_lock
suffix:semicolon
multiline_comment|/* Protects signal and blocked */
DECL|member|sig
r_struct
id|signal_struct
op_star
id|sig
suffix:semicolon
DECL|member|signal
DECL|member|blocked
id|sigset_t
id|signal
comma
id|blocked
suffix:semicolon
DECL|member|sigqueue
DECL|member|sigqueue_tail
r_struct
id|signal_queue
op_star
id|sigqueue
comma
op_star
op_star
id|sigqueue_tail
suffix:semicolon
DECL|member|sas_ss_sp
r_int
r_int
id|sas_ss_sp
suffix:semicolon
DECL|member|sas_ss_size
r_int
id|sas_ss_size
suffix:semicolon
multiline_comment|/* Thread group tracking */
DECL|member|parent_exec_id
id|u32
id|parent_exec_id
suffix:semicolon
DECL|member|self_exec_id
id|u32
id|self_exec_id
suffix:semicolon
multiline_comment|/* Protection of fields allocatio/deallocation */
DECL|member|exit_sem
r_struct
id|semaphore
id|exit_sem
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Per process flags&n; */
DECL|macro|PF_ALIGNWARN
mdefine_line|#define PF_ALIGNWARN&t;0x00000001&t;/* Print alignment warning msgs */
multiline_comment|/* Not implemented yet, only for 486*/
DECL|macro|PF_STARTING
mdefine_line|#define PF_STARTING&t;0x00000002&t;/* being created */
DECL|macro|PF_EXITING
mdefine_line|#define PF_EXITING&t;0x00000004&t;/* getting shut down */
DECL|macro|PF_PTRACED
mdefine_line|#define PF_PTRACED&t;0x00000010&t;/* set if ptrace (0) has been called */
DECL|macro|PF_TRACESYS
mdefine_line|#define PF_TRACESYS&t;0x00000020&t;/* tracing system calls */
DECL|macro|PF_FORKNOEXEC
mdefine_line|#define PF_FORKNOEXEC&t;0x00000040&t;/* forked but didn&squot;t exec */
DECL|macro|PF_SUPERPRIV
mdefine_line|#define PF_SUPERPRIV&t;0x00000100&t;/* used super-user privileges */
DECL|macro|PF_DUMPCORE
mdefine_line|#define PF_DUMPCORE&t;0x00000200&t;/* dumped core */
DECL|macro|PF_SIGNALED
mdefine_line|#define PF_SIGNALED&t;0x00000400&t;/* killed by a signal */
DECL|macro|PF_MEMALLOC
mdefine_line|#define PF_MEMALLOC&t;0x00000800&t;/* Allocating memory */
DECL|macro|PF_VFORK
mdefine_line|#define PF_VFORK&t;0x00001000&t;/* Wake up parent in mm_release */
DECL|macro|PF_USEDFPU
mdefine_line|#define PF_USEDFPU&t;0x00100000&t;/* task used FPU this quantum (SMP) */
DECL|macro|PF_DTRACE
mdefine_line|#define PF_DTRACE&t;0x00200000&t;/* delayed trace (used on m68k, i386) */
multiline_comment|/*&n; * Limit the stack by to some sane default: root can always&n; * increase this limit if needed..  8MB seems reasonable.&n; */
DECL|macro|_STK_LIM
mdefine_line|#define _STK_LIM&t;(8*1024*1024)
DECL|macro|DEF_PRIORITY
mdefine_line|#define DEF_PRIORITY&t;(20*HZ/100)&t;/* 200 ms time slices */
multiline_comment|/*&n; *  INIT_TASK is used to set up the first task table, touch at&n; * your own risk!. Base=0, limit=0x1fffff (=2MB)&n; */
DECL|macro|INIT_TASK
mdefine_line|#define INIT_TASK(name) &bslash;&n;/* state etc */&t;{ 0,0,0,KERNEL_DS,&amp;default_exec_domain,0, &bslash;&n;/* avg_slice */&t;0, -1, &bslash;&n;/* counter */&t;DEF_PRIORITY,DEF_PRIORITY,SCHED_OTHER, &bslash;&n;/* mm */&t;NULL, &amp;init_mm, &bslash;&n;/* has_cpu */&t;0,0, &bslash;&n;/* run_list */&t;LIST_HEAD_INIT(init_task.run_list), &bslash;&n;/* next_task */&t;&amp;init_task,&amp;init_task, &bslash;&n;/* last_proc */&t;0, &bslash;&n;/* binfmt */&t;NULL, &bslash;&n;/* ec,brk... */&t;0,0,0,0,0,0, &bslash;&n;/* pid etc.. */&t;0,0,0,0,0, &bslash;&n;/* proc links*/ &amp;init_task,&amp;init_task,NULL,NULL,NULL, &bslash;&n;/* pidhash */&t;NULL, NULL, &bslash;&n;/* chld wait */&t;__WAIT_QUEUE_HEAD_INITIALIZER(name.wait_chldexit), NULL, &bslash;&n;/* timeout */&t;0,0,0,0,0,0,0, &bslash;&n;/* timer */&t;{ NULL, NULL, 0, 0, it_real_fn }, &bslash;&n;/* utime */&t;{0,0,0,0},0, &bslash;&n;/* per CPU times */ {0, }, {0, }, &bslash;&n;/* flt */&t;0,0,0,0,0,0, &bslash;&n;/* swp */&t;0, &bslash;&n;/* process credentials */&t;&t;&t;&t;&t;&bslash;&n;/* uid etc */&t;0,0,0,0,0,0,0,0,&t;&t;&t;&t;&bslash;&n;/* suppl grps*/ 0, {0,},&t;&t;&t;&t;&t;&bslash;&n;/* caps */      CAP_INIT_EFF_SET,CAP_INIT_INH_SET,CAP_FULL_SET, &bslash;&n;/* user */&t;NULL,&t;&t;&t;&t;&t;&t;&bslash;&n;/* rlimits */   INIT_RLIMITS, &bslash;&n;/* math */&t;0, &bslash;&n;/* comm */&t;&quot;swapper&quot;, &bslash;&n;/* fs info */&t;0,NULL, &bslash;&n;/* ipc */&t;NULL, NULL, &bslash;&n;/* thread */&t;INIT_THREAD, &bslash;&n;/* fs */&t;&amp;init_fs, &bslash;&n;/* files */&t;&amp;init_files, &bslash;&n;/* signals */&t;SPIN_LOCK_UNLOCKED, &amp;init_signals, {{0}}, {{0}}, NULL, &amp;init_task.sigqueue, 0, 0, &bslash;&n;/* exec cts */&t;0,0, &bslash;&n;/* exit_sem */&t;__MUTEX_INITIALIZER(name.exit_sem),&t;&bslash;&n;}
macro_line|#ifndef INIT_TASK_SIZE
DECL|macro|INIT_TASK_SIZE
macro_line|# define INIT_TASK_SIZE&t;2048*sizeof(long)
macro_line|#endif
DECL|union|task_union
r_union
id|task_union
(brace
DECL|member|task
r_struct
id|task_struct
id|task
suffix:semicolon
DECL|member|stack
r_int
r_int
id|stack
(braket
id|INIT_TASK_SIZE
op_div
r_sizeof
(paren
r_int
)paren
)braket
suffix:semicolon
)brace
suffix:semicolon
r_extern
r_union
id|task_union
id|init_task_union
suffix:semicolon
r_extern
r_struct
id|mm_struct
id|init_mm
suffix:semicolon
r_extern
r_struct
id|task_struct
op_star
id|init_tasks
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* PID hashing. (shouldnt this be dynamic?) */
DECL|macro|PIDHASH_SZ
mdefine_line|#define PIDHASH_SZ (4096 &gt;&gt; 2)
r_extern
r_struct
id|task_struct
op_star
id|pidhash
(braket
id|PIDHASH_SZ
)braket
suffix:semicolon
DECL|macro|pid_hashfn
mdefine_line|#define pid_hashfn(x)&t;((((x) &gt;&gt; 8) ^ (x)) &amp; (PIDHASH_SZ - 1))
DECL|function|hash_pid
r_extern
id|__inline__
r_void
id|hash_pid
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_struct
id|task_struct
op_star
op_star
id|htable
op_assign
op_amp
id|pidhash
(braket
id|pid_hashfn
c_func
(paren
id|p-&gt;pid
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;pidhash_next
op_assign
op_star
id|htable
)paren
op_ne
l_int|NULL
)paren
(brace
(paren
op_star
id|htable
)paren
op_member_access_from_pointer
id|pidhash_pprev
op_assign
op_amp
id|p-&gt;pidhash_next
suffix:semicolon
)brace
op_star
id|htable
op_assign
id|p
suffix:semicolon
id|p-&gt;pidhash_pprev
op_assign
id|htable
suffix:semicolon
)brace
DECL|function|unhash_pid
r_extern
id|__inline__
r_void
id|unhash_pid
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;pidhash_next
)paren
(brace
id|p-&gt;pidhash_next-&gt;pidhash_pprev
op_assign
id|p-&gt;pidhash_pprev
suffix:semicolon
)brace
op_star
id|p-&gt;pidhash_pprev
op_assign
id|p-&gt;pidhash_next
suffix:semicolon
)brace
DECL|function|find_task_by_pid
r_extern
id|__inline__
r_struct
id|task_struct
op_star
id|find_task_by_pid
c_func
(paren
r_int
id|pid
)paren
(brace
r_struct
id|task_struct
op_star
id|p
comma
op_star
op_star
id|htable
op_assign
op_amp
id|pidhash
(braket
id|pid_hashfn
c_func
(paren
id|pid
)paren
)braket
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_star
id|htable
suffix:semicolon
id|p
op_logical_and
id|p-&gt;pid
op_ne
id|pid
suffix:semicolon
id|p
op_assign
id|p-&gt;pidhash_next
)paren
(brace
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/* per-UID process charging. */
r_extern
r_int
id|alloc_uid
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_void
id|free_uid
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
macro_line|#include &lt;asm/current.h&gt;
r_extern
r_int
r_int
r_volatile
id|jiffies
suffix:semicolon
r_extern
r_int
r_int
id|itimer_ticks
suffix:semicolon
r_extern
r_int
r_int
id|itimer_next
suffix:semicolon
r_extern
r_struct
id|timeval
id|xtime
suffix:semicolon
r_extern
r_void
id|do_timer
c_func
(paren
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_extern
r_int
r_int
op_star
id|prof_buffer
suffix:semicolon
r_extern
r_int
r_int
id|prof_len
suffix:semicolon
r_extern
r_int
r_int
id|prof_shift
suffix:semicolon
DECL|macro|CURRENT_TIME
mdefine_line|#define CURRENT_TIME (xtime.tv_sec)
r_extern
r_void
id|FASTCALL
c_func
(paren
id|__wake_up
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
r_int
id|mode
)paren
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|__wake_up_sync
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
r_int
id|mode
)paren
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|sleep_on
c_func
(paren
id|wait_queue_head_t
op_star
id|q
)paren
)paren
suffix:semicolon
r_extern
r_int
id|FASTCALL
c_func
(paren
id|sleep_on_timeout
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
r_int
id|timeout
)paren
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|interruptible_sleep_on
c_func
(paren
id|wait_queue_head_t
op_star
id|q
)paren
)paren
suffix:semicolon
r_extern
r_int
id|FASTCALL
c_func
(paren
id|interruptible_sleep_on_timeout
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
r_int
id|timeout
)paren
)paren
suffix:semicolon
r_extern
r_void
id|FASTCALL
c_func
(paren
id|wake_up_process
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
)paren
)paren
suffix:semicolon
DECL|macro|wake_up
mdefine_line|#define wake_up(x)&t;&t;&t;__wake_up((x),TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE | TASK_EXCLUSIVE)
DECL|macro|wake_up_all
mdefine_line|#define wake_up_all(x)&t;&t;&t;__wake_up((x),TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE)
DECL|macro|wake_up_sync
mdefine_line|#define wake_up_sync(x)&t;&t;&t;__wake_up_sync((x),TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE | TASK_EXCLUSIVE)
DECL|macro|wake_up_interruptible
mdefine_line|#define wake_up_interruptible(x)&t;__wake_up((x),TASK_INTERRUPTIBLE | TASK_EXCLUSIVE)
DECL|macro|wake_up_interruptible_all
mdefine_line|#define wake_up_interruptible_all(x)&t;__wake_up((x),TASK_INTERRUPTIBLE)
DECL|macro|wake_up_interruptible_sync
mdefine_line|#define wake_up_interruptible_sync(x)&t;__wake_up_sync((x),TASK_INTERRUPTIBLE | TASK_EXCLUSIVE)
r_extern
r_int
id|in_group_p
c_func
(paren
id|gid_t
)paren
suffix:semicolon
r_extern
r_int
id|in_egroup_p
c_func
(paren
id|gid_t
)paren
suffix:semicolon
r_extern
r_void
id|flush_signals
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|flush_signal_handlers
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|dequeue_signal
c_func
(paren
id|sigset_t
op_star
comma
id|siginfo_t
op_star
)paren
suffix:semicolon
r_extern
r_int
id|send_sig_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|force_sig_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|kill_pg_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
id|pid_t
)paren
suffix:semicolon
r_extern
r_int
id|kill_sl_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
id|pid_t
)paren
suffix:semicolon
r_extern
r_int
id|kill_proc_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
id|pid_t
)paren
suffix:semicolon
r_extern
r_int
id|kill_something_info
c_func
(paren
r_int
comma
r_struct
id|siginfo
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|notify_parent
c_func
(paren
r_struct
id|task_struct
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_void
id|force_sig
c_func
(paren
r_int
comma
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_int
id|send_sig
c_func
(paren
r_int
comma
r_struct
id|task_struct
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|kill_pg
c_func
(paren
id|pid_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|kill_sl
c_func
(paren
id|pid_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|kill_proc
c_func
(paren
id|pid_t
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|do_sigaction
c_func
(paren
r_int
comma
r_const
r_struct
id|k_sigaction
op_star
comma
r_struct
id|k_sigaction
op_star
)paren
suffix:semicolon
r_extern
r_int
id|do_sigaltstack
c_func
(paren
r_const
id|stack_t
op_star
comma
id|stack_t
op_star
comma
r_int
r_int
)paren
suffix:semicolon
DECL|function|signal_pending
r_extern
r_inline
r_int
id|signal_pending
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_return
(paren
id|p-&gt;sigpending
op_ne
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Reevaluate whether the task has signals pending delivery.&n;   This is required every time the blocked sigset_t changes.&n;   All callers should have t-&gt;sigmask_lock.  */
DECL|function|recalc_sigpending
r_static
r_inline
r_void
id|recalc_sigpending
c_func
(paren
r_struct
id|task_struct
op_star
id|t
)paren
(brace
r_int
r_int
id|ready
suffix:semicolon
r_int
id|i
suffix:semicolon
r_switch
c_cond
(paren
id|_NSIG_WORDS
)paren
(brace
r_default
suffix:colon
(brace
)brace
r_for
c_loop
(paren
id|i
op_assign
id|_NSIG_WORDS
comma
id|ready
op_assign
l_int|0
suffix:semicolon
op_decrement
id|i
op_ge
l_int|0
suffix:semicolon
)paren
id|ready
op_or_assign
id|t-&gt;signal.sig
(braket
id|i
)braket
op_amp
op_complement
id|t-&gt;blocked.sig
(braket
id|i
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|ready
op_assign
id|t-&gt;signal.sig
(braket
l_int|3
)braket
op_amp
op_complement
id|t-&gt;blocked.sig
(braket
l_int|3
)braket
suffix:semicolon
id|ready
op_or_assign
id|t-&gt;signal.sig
(braket
l_int|2
)braket
op_amp
op_complement
id|t-&gt;blocked.sig
(braket
l_int|2
)braket
suffix:semicolon
id|ready
op_or_assign
id|t-&gt;signal.sig
(braket
l_int|1
)braket
op_amp
op_complement
id|t-&gt;blocked.sig
(braket
l_int|1
)braket
suffix:semicolon
id|ready
op_or_assign
id|t-&gt;signal.sig
(braket
l_int|0
)braket
op_amp
op_complement
id|t-&gt;blocked.sig
(braket
l_int|0
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|ready
op_assign
id|t-&gt;signal.sig
(braket
l_int|1
)braket
op_amp
op_complement
id|t-&gt;blocked.sig
(braket
l_int|1
)braket
suffix:semicolon
id|ready
op_or_assign
id|t-&gt;signal.sig
(braket
l_int|0
)braket
op_amp
op_complement
id|t-&gt;blocked.sig
(braket
l_int|0
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|ready
op_assign
id|t-&gt;signal.sig
(braket
l_int|0
)braket
op_amp
op_complement
id|t-&gt;blocked.sig
(braket
l_int|0
)braket
suffix:semicolon
)brace
id|t-&gt;sigpending
op_assign
(paren
id|ready
op_ne
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* True if we are on the alternate signal stack.  */
DECL|function|on_sig_stack
r_static
r_inline
r_int
id|on_sig_stack
c_func
(paren
r_int
r_int
id|sp
)paren
(brace
r_return
(paren
id|sp
op_minus
id|current-&gt;sas_ss_sp
OL
id|current-&gt;sas_ss_size
)paren
suffix:semicolon
)brace
DECL|function|sas_ss_flags
r_static
r_inline
r_int
id|sas_ss_flags
c_func
(paren
r_int
r_int
id|sp
)paren
(brace
r_return
(paren
id|current-&gt;sas_ss_size
op_eq
l_int|0
ques
c_cond
id|SS_DISABLE
suffix:colon
id|on_sig_stack
c_func
(paren
id|sp
)paren
ques
c_cond
id|SS_ONSTACK
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_extern
r_int
id|request_irq
c_func
(paren
r_int
r_int
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
comma
r_const
r_char
op_star
comma
r_void
op_star
)paren
suffix:semicolon
r_extern
r_void
id|free_irq
c_func
(paren
r_int
r_int
comma
r_void
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * This has now become a routine instead of a macro, it sets a flag if&n; * it returns true (to do BSD-style accounting where the process is flagged&n; * if it uses root privs). The implication of this is that you should do&n; * normal permissions checks first, and check suser() last.&n; *&n; * [Dec 1997 -- Chris Evans]&n; * For correctness, the above considerations need to be extended to&n; * fsuser(). This is done, along with moving fsuser() checks to be&n; * last.&n; *&n; * These will be removed, but in the mean time, when the SECURE_NOROOT &n; * flag is set, uids don&squot;t grant privilege.&n; */
DECL|function|suser
r_extern
r_inline
r_int
id|suser
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|issecure
c_func
(paren
id|SECURE_NOROOT
)paren
op_logical_and
id|current-&gt;euid
op_eq
l_int|0
)paren
(brace
id|current-&gt;flags
op_or_assign
id|PF_SUPERPRIV
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fsuser
r_extern
r_inline
r_int
id|fsuser
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|issecure
c_func
(paren
id|SECURE_NOROOT
)paren
op_logical_and
id|current-&gt;fsuid
op_eq
l_int|0
)paren
(brace
id|current-&gt;flags
op_or_assign
id|PF_SUPERPRIV
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * capable() checks for a particular capability.  &n; * New privilege checks should use this interface, rather than suser() or&n; * fsuser(). See include/linux/capability.h for defined capabilities.&n; */
DECL|function|capable
r_extern
r_inline
r_int
id|capable
c_func
(paren
r_int
id|cap
)paren
(brace
macro_line|#if 1 /* ok now */
r_if
c_cond
(paren
id|cap_raised
c_func
(paren
id|current-&gt;cap_effective
comma
id|cap
)paren
)paren
macro_line|#else
r_if
c_cond
(paren
id|cap_is_fs_cap
c_func
(paren
id|cap
)paren
ques
c_cond
id|current-&gt;fsuid
op_eq
l_int|0
suffix:colon
id|current-&gt;euid
op_eq
l_int|0
)paren
macro_line|#endif
(brace
id|current-&gt;flags
op_or_assign
id|PF_SUPERPRIV
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Routines for handling mm_structs&n; */
r_extern
r_struct
id|mm_struct
op_star
id|mm_alloc
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_struct
id|mm_struct
op_star
id|start_lazy_tlb
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|end_lazy_tlb
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
suffix:semicolon
multiline_comment|/* mmdrop drops the mm and the page tables */
r_extern
r_inline
r_void
id|FASTCALL
c_func
(paren
id|__mmdrop
c_func
(paren
r_struct
id|mm_struct
op_star
)paren
)paren
suffix:semicolon
DECL|function|mmdrop
r_static
r_inline
r_void
id|mmdrop
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|mm-&gt;mm_count
)paren
)paren
id|__mmdrop
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
multiline_comment|/* mmput gets rid of the mappings and all user-space */
r_extern
r_void
id|mmput
c_func
(paren
r_struct
id|mm_struct
op_star
)paren
suffix:semicolon
multiline_comment|/* Remove the current tasks stale references to the old mm_struct */
r_extern
r_void
id|mm_release
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * Routines for handling the fd arrays&n; */
r_extern
r_struct
id|file
op_star
op_star
id|alloc_fd_array
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_int
id|expand_fd_array
c_func
(paren
r_struct
id|files_struct
op_star
comma
r_int
id|nr
)paren
suffix:semicolon
r_extern
r_void
id|free_fd_array
c_func
(paren
r_struct
id|file
op_star
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
id|fd_set
op_star
id|alloc_fdset
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_int
id|expand_fdset
c_func
(paren
r_struct
id|files_struct
op_star
comma
r_int
id|nr
)paren
suffix:semicolon
r_extern
r_void
id|free_fdset
c_func
(paren
id|fd_set
op_star
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* Expand files.  Return &lt;0 on error; 0 nothing done; 1 files expanded,&n; * we may have blocked. &n; *&n; * Should be called with the files-&gt;file_lock spinlock held for write.&n; */
DECL|function|expand_files
r_static
r_inline
r_int
id|expand_files
c_func
(paren
r_struct
id|files_struct
op_star
id|files
comma
r_int
id|nr
)paren
(brace
r_int
id|err
comma
id|expand
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef FDSET_DEBUG&t;
id|printk
(paren
id|KERN_ERR
id|__FUNCTION__
l_string|&quot; %d: nr = %d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|nr
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|nr
op_ge
id|files-&gt;max_fdset
)paren
(brace
id|expand
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|expand_fdset
c_func
(paren
id|files
comma
id|nr
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nr
op_ge
id|files-&gt;max_fds
)paren
(brace
id|expand
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|expand_fd_array
c_func
(paren
id|files
comma
id|nr
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
id|err
op_assign
id|expand
suffix:semicolon
id|out
suffix:colon
macro_line|#ifdef FDSET_DEBUG&t;
r_if
c_cond
(paren
id|err
)paren
id|printk
(paren
id|KERN_ERR
id|__FUNCTION__
l_string|&quot; %d: return %d&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|err
)paren
suffix:semicolon
macro_line|#endif
r_return
id|err
suffix:semicolon
)brace
r_extern
r_int
id|copy_thread
c_func
(paren
r_int
comma
r_int
r_int
comma
r_int
r_int
comma
r_struct
id|task_struct
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_extern
r_void
id|flush_thread
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|exit_thread
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|exit_mm
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|exit_fs
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|exit_files
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|exit_sighand
c_func
(paren
r_struct
id|task_struct
op_star
)paren
suffix:semicolon
r_extern
r_void
id|daemonize
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|do_execve
c_func
(paren
r_char
op_star
comma
r_char
op_star
op_star
comma
r_char
op_star
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
r_extern
r_int
id|do_fork
c_func
(paren
r_int
r_int
comma
r_int
r_int
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
DECL|function|add_wait_queue
r_extern
r_inline
r_void
id|add_wait_queue
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
id|wait_queue_t
op_star
id|wait
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|wq_write_lock_irqsave
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__add_wait_queue
c_func
(paren
id|q
comma
id|wait
)paren
suffix:semicolon
id|wq_write_unlock_irqrestore
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|add_wait_queue_exclusive
r_extern
r_inline
r_void
id|add_wait_queue_exclusive
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
id|wait_queue_t
op_star
id|wait
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|wq_write_lock_irqsave
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__add_wait_queue_tail
c_func
(paren
id|q
comma
id|wait
)paren
suffix:semicolon
id|wq_write_unlock_irqrestore
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|remove_wait_queue
r_extern
r_inline
r_void
id|remove_wait_queue
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
id|wait_queue_t
op_star
id|wait
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|wq_write_lock_irqsave
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|__remove_wait_queue
c_func
(paren
id|q
comma
id|wait
)paren
suffix:semicolon
id|wq_write_unlock_irqrestore
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|macro|__wait_event
mdefine_line|#define __wait_event(wq, condition) &t;&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;wait_queue_t __wait;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;init_waitqueue_entry(&amp;__wait, current);&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;add_wait_queue(&amp;wq, &amp;__wait);&t;&t;&t;&t;&t;&bslash;&n;&t;for (;;) {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;set_current_state(TASK_UNINTERRUPTIBLE);&t;&t;&bslash;&n;&t;&t;if (condition)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;schedule();&t;&t;&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;current-&gt;state = TASK_RUNNING;&t;&t;&t;&t;&t;&bslash;&n;&t;remove_wait_queue(&amp;wq, &amp;__wait);&t;&t;&t;&t;&bslash;&n;} while (0)
DECL|macro|wait_event
mdefine_line|#define wait_event(wq, condition) &t;&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (condition)&t; &t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;__wait_event(wq, condition);&t;&t;&t;&t;&t;&bslash;&n;} while (0)
DECL|macro|__wait_event_interruptible
mdefine_line|#define __wait_event_interruptible(wq, condition, ret)&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;wait_queue_t __wait;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;init_waitqueue_entry(&amp;__wait, current);&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;add_wait_queue(&amp;wq, &amp;__wait);&t;&t;&t;&t;&t;&bslash;&n;&t;for (;;) {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;set_current_state(TASK_INTERRUPTIBLE);&t;&t;&t;&bslash;&n;&t;&t;if (condition)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (!signal_pending(current)) {&t;&t;&t;&t;&bslash;&n;&t;&t;&t;schedule();&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;continue;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;ret = -ERESTARTSYS;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;current-&gt;state = TASK_RUNNING;&t;&t;&t;&t;&t;&bslash;&n;&t;remove_wait_queue(&amp;wq, &amp;__wait);&t;&t;&t;&t;&bslash;&n;} while (0)
DECL|macro|wait_event_interruptible
mdefine_line|#define wait_event_interruptible(wq, condition)&t;&t;&t;&t;&bslash;&n;({&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;int __ret = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (!(condition))&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__wait_event_interruptible(wq, condition, __ret);&t;&bslash;&n;&t;__ret;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;})
DECL|macro|REMOVE_LINKS
mdefine_line|#define REMOVE_LINKS(p) do { &bslash;&n;&t;(p)-&gt;next_task-&gt;prev_task = (p)-&gt;prev_task; &bslash;&n;&t;(p)-&gt;prev_task-&gt;next_task = (p)-&gt;next_task; &bslash;&n;&t;if ((p)-&gt;p_osptr) &bslash;&n;&t;&t;(p)-&gt;p_osptr-&gt;p_ysptr = (p)-&gt;p_ysptr; &bslash;&n;&t;if ((p)-&gt;p_ysptr) &bslash;&n;&t;&t;(p)-&gt;p_ysptr-&gt;p_osptr = (p)-&gt;p_osptr; &bslash;&n;&t;else &bslash;&n;&t;&t;(p)-&gt;p_pptr-&gt;p_cptr = (p)-&gt;p_osptr; &bslash;&n;&t;} while (0)
DECL|macro|SET_LINKS
mdefine_line|#define SET_LINKS(p) do { &bslash;&n;&t;(p)-&gt;next_task = &amp;init_task; &bslash;&n;&t;(p)-&gt;prev_task = init_task.prev_task; &bslash;&n;&t;init_task.prev_task-&gt;next_task = (p); &bslash;&n;&t;init_task.prev_task = (p); &bslash;&n;&t;(p)-&gt;p_ysptr = NULL; &bslash;&n;&t;if (((p)-&gt;p_osptr = (p)-&gt;p_pptr-&gt;p_cptr) != NULL) &bslash;&n;&t;&t;(p)-&gt;p_osptr-&gt;p_ysptr = p; &bslash;&n;&t;(p)-&gt;p_pptr-&gt;p_cptr = p; &bslash;&n;&t;} while (0)
DECL|macro|for_each_task
mdefine_line|#define for_each_task(p) &bslash;&n;&t;for (p = &amp;init_task ; (p = p-&gt;next_task) != &amp;init_task ; )
DECL|function|del_from_runqueue
r_static
r_inline
r_void
id|del_from_runqueue
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|nr_running
op_decrement
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|p-&gt;run_list
)paren
suffix:semicolon
id|p-&gt;run_list.next
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|task_on_runqueue
r_extern
r_inline
r_int
id|task_on_runqueue
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_return
(paren
id|p-&gt;run_list.next
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|unhash_process
r_extern
r_inline
r_void
id|unhash_process
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
id|task_on_runqueue
c_func
(paren
id|p
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|write_lock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|nr_threads
op_decrement
suffix:semicolon
id|unhash_pid
c_func
(paren
id|p
)paren
suffix:semicolon
id|REMOVE_LINKS
c_func
(paren
id|p
)paren
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
DECL|function|task_lock
r_static
r_inline
r_int
id|task_lock
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|down
c_func
(paren
op_amp
id|p-&gt;exit_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;p_pptr
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* He&squot;s dead, Jim. You take his wallet, I&squot;ll take the tricorder... */
id|up
c_func
(paren
op_amp
id|p-&gt;exit_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|task_unlock
r_static
r_inline
r_void
id|task_unlock
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|up
c_func
(paren
op_amp
id|p-&gt;exit_sem
)paren
suffix:semicolon
)brace
macro_line|#endif /* __KERNEL__ */
macro_line|#endif
eof
