multiline_comment|/*&n; * linux/include/linux/hfs_sysdep.h&n; *&n; * Copyright (C) 1996-1997  Paul H. Hargrove&n; * This file may be distributed under the terms of the GNU Public License.&n; *&n; * This file contains constants, types and inline&n; * functions for various system dependent things.&n; *&n; * &quot;XXX&quot; in a comment is a note to myself to consider changing something.&n; *&n; * In function preconditions the term &quot;valid&quot; applied to a pointer to&n; * a structure means that the pointer is non-NULL and the structure it&n; * points to has all fields initialized to consistent values.&n; */
macro_line|#ifndef _HFS_SYSDEP_H
DECL|macro|_HFS_SYSDEP_H
mdefine_line|#define _HFS_SYSDEP_H
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
r_extern
r_struct
id|timezone
id|sys_tz
suffix:semicolon
DECL|macro|offsetof
macro_line|#undef offsetof
DECL|macro|offsetof
mdefine_line|#define offsetof(TYPE, MEMB) ((size_t) &amp;((TYPE *)0)-&gt;MEMB)
multiline_comment|/* Typedefs for integer types by size and signedness */
DECL|typedef|hfs_u8
r_typedef
id|__u8
id|hfs_u8
suffix:semicolon
DECL|typedef|hfs_u16
r_typedef
id|__u16
id|hfs_u16
suffix:semicolon
DECL|typedef|hfs_u32
r_typedef
id|__u32
id|hfs_u32
suffix:semicolon
DECL|typedef|hfs_s8
r_typedef
id|__s8
id|hfs_s8
suffix:semicolon
DECL|typedef|hfs_s16
r_typedef
id|__s16
id|hfs_s16
suffix:semicolon
DECL|typedef|hfs_s32
r_typedef
id|__s32
id|hfs_s32
suffix:semicolon
multiline_comment|/* Typedefs for unaligned integer types */
DECL|typedef|hfs_byte_t
r_typedef
r_int
r_char
id|hfs_byte_t
suffix:semicolon
DECL|typedef|hfs_word_t
r_typedef
r_int
r_char
id|hfs_word_t
(braket
l_int|2
)braket
suffix:semicolon
DECL|typedef|hfs_lword_t
r_typedef
r_int
r_char
id|hfs_lword_t
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* these funny looking things are GCC variable argument macros */
DECL|macro|hfs_warn
mdefine_line|#define hfs_warn(format, args...) printk(KERN_WARNING format , ## args)
DECL|macro|hfs_error
mdefine_line|#define hfs_error(format, args...) printk(KERN_ERR format , ## args)
macro_line|#if defined(DEBUG_ALL) || defined(DEBUG_MEM)
r_extern
r_int
r_int
id|hfs_alloc
suffix:semicolon
macro_line|#endif
DECL|function|hfs_malloc
r_static
r_inline
r_void
op_star
id|hfs_malloc
c_func
(paren
r_int
r_int
id|size
)paren
(brace
macro_line|#if defined(DEBUG_ALL) || defined(DEBUG_MEM)
id|hfs_warn
c_func
(paren
l_string|&quot;%ld bytes allocation at %s:%u&bslash;n&quot;
comma
(paren
id|hfs_alloc
op_add_assign
id|size
)paren
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
r_return
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
DECL|function|hfs_free
r_static
r_inline
r_void
id|hfs_free
c_func
(paren
r_void
op_star
id|ptr
comma
r_int
r_int
id|size
)paren
(brace
id|kfree
c_func
(paren
id|ptr
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_ALL) || defined(DEBUG_MEM)
id|hfs_warn
c_func
(paren
l_string|&quot;%ld bytes allocation at %s:%u&bslash;n&quot;
comma
(paren
id|hfs_alloc
op_sub_assign
id|ptr
ques
c_cond
id|size
suffix:colon
l_int|0
)paren
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* handle conversion between times. &n; *&n; * NOTE: hfs+ doesn&squot;t need this. also, we don&squot;t use tz_dsttime as that&squot;s&n; *       not a good thing to do. instead, we depend upon tz_minuteswest&n; *       having the correct daylight savings correction. &n; */
DECL|function|hfs_from_utc
r_static
r_inline
id|hfs_u32
id|hfs_from_utc
c_func
(paren
id|hfs_s32
id|time
)paren
(brace
r_return
id|time
op_minus
id|sys_tz.tz_minuteswest
op_star
l_int|60
suffix:semicolon
)brace
DECL|function|hfs_to_utc
r_static
r_inline
id|hfs_s32
id|hfs_to_utc
c_func
(paren
id|hfs_u32
id|time
)paren
(brace
r_return
id|time
op_plus
id|sys_tz.tz_minuteswest
op_star
l_int|60
suffix:semicolon
)brace
DECL|function|hfs_time
r_static
r_inline
id|hfs_u32
id|hfs_time
c_func
(paren
r_void
)paren
(brace
r_return
id|htonl
c_func
(paren
id|hfs_from_utc
c_func
(paren
id|CURRENT_TIME
)paren
op_plus
l_int|2082844800U
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_wait_queue &n; */
DECL|typedef|hfs_wait_queue
r_typedef
id|wait_queue_head_t
id|hfs_wait_queue
suffix:semicolon
DECL|function|hfs_init_waitqueue
r_static
r_inline
r_void
id|hfs_init_waitqueue
c_func
(paren
id|hfs_wait_queue
op_star
id|queue
)paren
(brace
id|init_waitqueue_head
c_func
(paren
id|queue
)paren
suffix:semicolon
)brace
DECL|function|hfs_sleep_on
r_static
r_inline
r_void
id|hfs_sleep_on
c_func
(paren
id|hfs_wait_queue
op_star
id|queue
)paren
(brace
id|sleep_on
c_func
(paren
id|queue
)paren
suffix:semicolon
)brace
DECL|function|hfs_wake_up
r_static
r_inline
r_void
id|hfs_wake_up
c_func
(paren
id|hfs_wait_queue
op_star
id|queue
)paren
(brace
id|wake_up
c_func
(paren
id|queue
)paren
suffix:semicolon
)brace
DECL|function|hfs_relinquish
r_static
r_inline
r_void
id|hfs_relinquish
c_func
(paren
r_void
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_sysmdb &n; */
DECL|typedef|hfs_sysmdb
r_typedef
r_struct
id|super_block
op_star
id|hfs_sysmdb
suffix:semicolon
DECL|function|hfs_mdb_dirty
r_static
r_inline
r_void
id|hfs_mdb_dirty
c_func
(paren
id|hfs_sysmdb
id|sys_mdb
)paren
(brace
id|sys_mdb-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|hfs_mdb_name
r_static
r_inline
r_const
r_char
op_star
id|hfs_mdb_name
c_func
(paren
id|hfs_sysmdb
id|sys_mdb
)paren
(brace
r_return
id|kdevname
c_func
(paren
id|sys_mdb-&gt;s_dev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_sysentry&n; */
DECL|typedef|hfs_sysentry
r_typedef
r_struct
id|dentry
op_star
id|hfs_sysentry
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/*&n; * hfs_buffer&n; */
DECL|typedef|hfs_buffer
r_typedef
r_struct
id|buffer_head
op_star
id|hfs_buffer
suffix:semicolon
DECL|macro|HFS_BAD_BUFFER
mdefine_line|#define HFS_BAD_BUFFER NULL
multiline_comment|/* In sysdep.c, since it needs HFS_SECTOR_SIZE */
r_extern
id|hfs_buffer
id|hfs_buffer_get
c_func
(paren
id|hfs_sysmdb
comma
r_int
comma
r_int
)paren
suffix:semicolon
DECL|function|hfs_buffer_ok
r_static
r_inline
r_int
id|hfs_buffer_ok
c_func
(paren
id|hfs_buffer
id|buffer
)paren
(brace
r_return
(paren
id|buffer
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|hfs_buffer_put
r_static
r_inline
r_void
id|hfs_buffer_put
c_func
(paren
id|hfs_buffer
id|buffer
)paren
(brace
id|brelse
c_func
(paren
id|buffer
)paren
suffix:semicolon
)brace
DECL|function|hfs_buffer_dirty
r_static
r_inline
r_void
id|hfs_buffer_dirty
c_func
(paren
id|hfs_buffer
id|buffer
)paren
(brace
id|mark_buffer_dirty
c_func
(paren
id|buffer
)paren
suffix:semicolon
)brace
DECL|function|hfs_buffer_sync
r_static
r_inline
r_void
id|hfs_buffer_sync
c_func
(paren
id|hfs_buffer
id|buffer
)paren
(brace
r_while
c_loop
(paren
id|buffer_locked
c_func
(paren
id|buffer
)paren
)paren
(brace
id|wait_on_buffer
c_func
(paren
id|buffer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|buffer
)paren
)paren
(brace
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|buffer
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|buffer
)paren
suffix:semicolon
)brace
)brace
DECL|function|hfs_buffer_data
r_static
r_inline
r_void
op_star
id|hfs_buffer_data
c_func
(paren
r_const
id|hfs_buffer
id|buffer
)paren
(brace
r_return
id|buffer-&gt;b_data
suffix:semicolon
)brace
multiline_comment|/*&n; * bit operations&n; */
DECL|macro|BITNR
macro_line|#undef BITNR
macro_line|#if defined(__BIG_ENDIAN)
DECL|macro|BITNR
macro_line|#&t;define BITNR(X)&t;((X)^31)
macro_line|#&t;if !defined(__constant_htonl)
DECL|macro|__constant_htonl
macro_line|#&t;&t;define __constant_htonl(x) (x)
macro_line|#&t;endif
macro_line|#&t;if !defined(__constant_htons)
DECL|macro|__constant_htons
macro_line|#&t;&t;define __constant_htons(x) (x)
macro_line|#&t;endif
macro_line|#elif defined(__LITTLE_ENDIAN)
DECL|macro|BITNR
macro_line|#&t;define BITNR(X)&t;((X)^7)
macro_line|#&t;if !defined(__constant_htonl)
DECL|macro|__constant_htonl
macro_line|#&t;&t;define __constant_htonl(x) &bslash;&n;        ((unsigned long int)((((unsigned long int)(x) &amp; 0x000000ffU) &lt;&lt; 24) | &bslash;&n;                             (((unsigned long int)(x) &amp; 0x0000ff00U) &lt;&lt;  8) | &bslash;&n;                             (((unsigned long int)(x) &amp; 0x00ff0000U) &gt;&gt;  8) | &bslash;&n;                             (((unsigned long int)(x) &amp; 0xff000000U) &gt;&gt; 24)))
macro_line|#&t;endif
macro_line|#&t;if !defined(__constant_htons)
DECL|macro|__constant_htons
macro_line|#&t;&t;define __constant_htons(x) &bslash;&n;        ((unsigned short int)((((unsigned short int)(x) &amp; 0x00ff) &lt;&lt; 8) | &bslash;&n;                              (((unsigned short int)(x) &amp; 0xff00) &gt;&gt; 8)))
macro_line|#&t;endif
macro_line|#else
macro_line|#&t;error &quot;Don&squot;t know if bytes are big- or little-endian!&quot;
macro_line|#endif
DECL|function|hfs_clear_bit
r_static
r_inline
r_int
id|hfs_clear_bit
c_func
(paren
r_int
id|bitnr
comma
id|hfs_u32
op_star
id|lword
)paren
(brace
r_return
id|test_and_clear_bit
c_func
(paren
id|BITNR
c_func
(paren
id|bitnr
)paren
comma
id|lword
)paren
suffix:semicolon
)brace
DECL|function|hfs_set_bit
r_static
r_inline
r_int
id|hfs_set_bit
c_func
(paren
r_int
id|bitnr
comma
id|hfs_u32
op_star
id|lword
)paren
(brace
r_return
id|test_and_set_bit
c_func
(paren
id|BITNR
c_func
(paren
id|bitnr
)paren
comma
id|lword
)paren
suffix:semicolon
)brace
DECL|function|hfs_test_bit
r_static
r_inline
r_int
id|hfs_test_bit
c_func
(paren
r_int
id|bitnr
comma
r_const
id|hfs_u32
op_star
id|lword
)paren
(brace
multiline_comment|/* the kernel should declare the second arg of test_bit as const */
r_return
id|test_bit
c_func
(paren
id|BITNR
c_func
(paren
id|bitnr
)paren
comma
(paren
r_void
op_star
)paren
id|lword
)paren
suffix:semicolon
)brace
DECL|macro|BITNR
macro_line|#undef BITNR
multiline_comment|/*&n; * HFS structures have fields aligned to 16-bit boundaries.&n; * So, 16-bit get/put are easy while 32-bit get/put need&n; * some care on architectures like the DEC Alpha.&n; *&n; * In what follows:&n; *&t;ns  = 16-bit integer in network byte-order w/ 16-bit alignment&n; *&t;hs  = 16-bit integer in host byte-order w/ 16-bit alignment&n; *&t;nl  = 32-bit integer in network byte-order w/ unknown alignment&n; *&t;hl  = 32-bit integer in host byte-order w/ unknown alignment&n; *&t;anl = 32-bit integer in network byte-order w/ 32-bit alignment&n; *&t;ahl = 32-bit integer in host byte-order w/ 32-bit alignment&n; * Example: hfs_get_hl() gets an unaligned 32-bit integer converting&n; *&t;it to host byte-order.&n; */
DECL|macro|hfs_get_hs
mdefine_line|#define hfs_get_hs(addr)&t;ntohs(*((hfs_u16 *)(addr)))
DECL|macro|hfs_get_ns
mdefine_line|#define hfs_get_ns(addr)&t;(*((hfs_u16 *)(addr)))
DECL|macro|hfs_get_hl
mdefine_line|#define hfs_get_hl(addr)&t;ntohl(get_unaligned((hfs_u32 *)(addr)))
DECL|macro|hfs_get_nl
mdefine_line|#define hfs_get_nl(addr)&t;get_unaligned((hfs_u32 *)(addr))
DECL|macro|hfs_get_ahl
mdefine_line|#define hfs_get_ahl(addr)&t;ntohl(*((hfs_u32 *)(addr)))
DECL|macro|hfs_get_anl
mdefine_line|#define hfs_get_anl(addr)&t;(*((hfs_u32 *)(addr)))
DECL|macro|hfs_put_hs
mdefine_line|#define hfs_put_hs(val, addr) &t;((void)(*((hfs_u16 *)(addr)) = ntohs(val)))
DECL|macro|hfs_put_ns
mdefine_line|#define hfs_put_ns(val, addr) &t;((void)(*((hfs_u16 *)(addr)) = (val)))
DECL|macro|hfs_put_hl
mdefine_line|#define hfs_put_hl(val, addr) &t;put_unaligned(htonl(val), (hfs_u32 *)(addr))
DECL|macro|hfs_put_nl
mdefine_line|#define hfs_put_nl(val, addr) &t;put_unaligned((val), (hfs_u32 *)(addr))
DECL|macro|hfs_put_ahl
mdefine_line|#define hfs_put_ahl(val, addr) &t;((void)(*((hfs_u32 *)(addr)) = ntohl(val)))
DECL|macro|hfs_put_anl
mdefine_line|#define hfs_put_anl(val, addr) &t;((void)(*((hfs_u32 *)(addr)) = (val)))
macro_line|#endif
eof
