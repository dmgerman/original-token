multiline_comment|/* Software floating-point emulation. Common operations.&n;   Copyright (C) 1997,1998,1999 Free Software Foundation, Inc.&n;   This file is part of the GNU C Library.&n;   Contributed by Richard Henderson (rth@cygnus.com),&n;&t;&t;  Jakub Jelinek (jj@ultra.linux.cz),&n;&t;&t;  David S. Miller (davem@redhat.com) and&n;&t;&t;  Peter Maydell (pmaydell@chiark.greenend.org.uk).&n;&n;   The GNU C Library is free software; you can redistribute it and/or&n;   modify it under the terms of the GNU Library General Public License as&n;   published by the Free Software Foundation; either version 2 of the&n;   License, or (at your option) any later version.&n;&n;   The GNU C Library is distributed in the hope that it will be useful,&n;   but WITHOUT ANY WARRANTY; without even the implied warranty of&n;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n;   Library General Public License for more details.&n;&n;   You should have received a copy of the GNU Library General Public&n;   License along with the GNU C Library; see the file COPYING.LIB.  If&n;   not, write to the Free Software Foundation, Inc.,&n;   59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
DECL|macro|_FP_DECL
mdefine_line|#define _FP_DECL(wc, X)&t;&t;&t;&bslash;&n;  _FP_I_TYPE X##_c, X##_s, X##_e;&t;&bslash;&n;  _FP_FRAC_DECL_##wc(X)
multiline_comment|/*&n; * Finish truely unpacking a native fp value by classifying the kind&n; * of fp value and normalizing both the exponent and the fraction.&n; */
DECL|macro|_FP_UNPACK_CANONICAL
mdefine_line|#define _FP_UNPACK_CANONICAL(fs, wc, X)&t;&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  switch (X##_e)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  default:&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_HIGH_RAW_##fs(X) |= _FP_IMPLBIT_##fs;&t;&t;&t;&bslash;&n;    _FP_FRAC_SLL_##wc(X, _FP_WORKBITS);&t;&t;&t;&t;&t;&bslash;&n;    X##_e -= _FP_EXPBIAS_##fs;&t;&t;&t;&t;&t;&t;&bslash;&n;    X##_c = FP_CLS_NORMAL;&t;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case 0:&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    if (_FP_FRAC_ZEROP_##wc(X))&t;&t;&t;&t;&t;&t;&bslash;&n;      X##_c = FP_CLS_ZERO;&t;&t;&t;&t;&t;&t;&bslash;&n;    else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;/* a denormalized number */&t;&t;&t;&t;&t;&bslash;&n;&t;_FP_I_TYPE _shift;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;_FP_FRAC_CLZ_##wc(_shift, X);&t;&t;&t;&t;&t;&bslash;&n;&t;_shift -= _FP_FRACXBITS_##fs;&t;&t;&t;&t;&t;&bslash;&n;&t;_FP_FRAC_SLL_##wc(X, (_shift+_FP_WORKBITS));&t;&t;&t;&bslash;&n;&t;X##_e -= _FP_EXPBIAS_##fs - 1 + _shift;&t;&t;&t;&t;&bslash;&n;&t;X##_c = FP_CLS_NORMAL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;FP_SET_EXCEPTION(FP_EX_DENORM);&t;&t;&t;&t;&t;&bslash;&n;&t;if (FP_DENORM_ZERO)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    FP_SET_EXCEPTION(FP_EX_INEXACT);&t;&t;&t;&t;&bslash;&n;&t;    X##_c = FP_CLS_ZERO;&t;&t;&t;&t;&t;&bslash;&n;&t;  }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_EXPMAX_##fs:&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    if (_FP_FRAC_ZEROP_##wc(X))&t;&t;&t;&t;&t;&t;&bslash;&n;      X##_c = FP_CLS_INF;&t;&t;&t;&t;&t;&t;&bslash;&n;    else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;X##_c = FP_CLS_NAN;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;/* Check for signaling NaN */&t;&t;&t;&t;&t;&bslash;&n;&t;if (!(_FP_FRAC_HIGH_RAW_##fs(X) &amp; _FP_QNANBIT_##fs))&t;&t;&bslash;&n;&t;  FP_SET_EXCEPTION(FP_EX_INVALID);&t;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;} while (0)
multiline_comment|/*&n; * Before packing the bits back into the native fp result, take care&n; * of such mundane things as rounding and overflow.  Also, for some&n; * kinds of fp values, the original parts may not have been fully&n; * extracted -- but that is ok, we can regenerate them now.&n; */
DECL|macro|_FP_PACK_CANONICAL
mdefine_line|#define _FP_PACK_CANONICAL(fs, wc, X)&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  switch (X##_c)&t;&t;&t;&t;&t;&t;&bslash;&n;  {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case FP_CLS_NORMAL:&t;&t;&t;&t;&t;&t;&bslash;&n;    X##_e += _FP_EXPBIAS_##fs;&t;&t;&t;&t;&t;&bslash;&n;    if (X##_e &gt; 0)&t;&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;_FP_ROUND(wc, X);&t;&t;&t;&t;&t;&bslash;&n;&t;if (_FP_FRAC_OVERP_##wc(fs, X))&t;&t;&t;&t;&bslash;&n;&t;  {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    _FP_FRAC_SRL_##wc(X, (_FP_WORKBITS+1));&t;&t;&bslash;&n;&t;    X##_e++;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  _FP_FRAC_SRL_##wc(X, _FP_WORKBITS);&t;&t;&t;&bslash;&n;&t;if (X##_e &gt;= _FP_EXPMAX_##fs)&t;&t;&t;&t;&bslash;&n;&t;  {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    /* overflow */&t;&t;&t;&t;&t;&bslash;&n;&t;    switch (FP_ROUNDMODE)&t;&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      case FP_RND_NEAREST:&t;&t;&t;&t;&bslash;&n;&t;&t;X##_c = FP_CLS_INF;&t;&t;&t;&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      case FP_RND_PINF:&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (!X##_s) X##_c = FP_CLS_INF;&t;&t;&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      case FP_RND_MINF:&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (X##_s) X##_c = FP_CLS_INF;&t;&t;&t;&bslash;&n;&t;&t;break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    if (X##_c == FP_CLS_INF)&t;&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;/* Overflow to infinity */&t;&t;&t;&bslash;&n;&t;&t;X##_e = _FP_EXPMAX_##fs;&t;&t;&t;&bslash;&n;&t;&t;_FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    else&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;/* Overflow to maximum normal */&t;&t;&bslash;&n;&t;&t;X##_e = _FP_EXPMAX_##fs - 1;&t;&t;&t;&bslash;&n;&t;&t;_FP_FRAC_SET_##wc(X, _FP_MAXFRAC_##wc);&t;&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    FP_SET_EXCEPTION(FP_EX_OVERFLOW);&t;&t;&t;&bslash;&n;            FP_SET_EXCEPTION(FP_EX_INEXACT);&t;&t;&t;&bslash;&n;&t;  }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    else&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;/* we&squot;ve got a denormalized number */&t;&t;&t;&bslash;&n;&t;X##_e = -X##_e + 1;&t;&t;&t;&t;&t;&bslash;&n;&t;if (X##_e &lt;= _FP_WFRACBITS_##fs)&t;&t;&t;&bslash;&n;&t;  {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    _FP_FRAC_SRS_##wc(X, X##_e, _FP_WFRACBITS_##fs);&t;&bslash;&n;&t;    _FP_ROUND(wc, X);&t;&t;&t;&t;&t;&bslash;&n;&t;    if (_FP_FRAC_HIGH_##fs(X)&t;&t;&t;&t;&bslash;&n;&t;&t;&amp; (_FP_OVERFLOW_##fs &gt;&gt; 1))&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;        X##_e = 1;&t;&t;&t;&t;&t;&bslash;&n;&t;        _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    else&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;X##_e = 0;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;_FP_FRAC_SRL_##wc(X, _FP_WORKBITS);&t;&t;&bslash;&n;&t;&t;FP_SET_EXCEPTION(FP_EX_UNDERFLOW);&t;&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    /* underflow to zero */&t;&t;&t;&t;&bslash;&n;&t;    X##_e = 0;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    if (!_FP_FRAC_ZEROP_##wc(X))&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;        _FP_FRAC_SET_##wc(X, _FP_MINFRAC_##wc);&t;&t;&bslash;&n;&t;        _FP_ROUND(wc, X);&t;&t;&t;&t;&bslash;&n;&t;        _FP_FRAC_LOW_##wc(X) &gt;&gt;= (_FP_WORKBITS);&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    FP_SET_EXCEPTION(FP_EX_UNDERFLOW);&t;&t;&t;&bslash;&n;&t;  }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case FP_CLS_ZERO:&t;&t;&t;&t;&t;&t;&bslash;&n;    X##_e = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case FP_CLS_INF:&t;&t;&t;&t;&t;&t;&bslash;&n;    X##_e = _FP_EXPMAX_##fs;&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_SET_##wc(X, _FP_ZEROFRAC_##wc);&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case FP_CLS_NAN:&t;&t;&t;&t;&t;&t;&bslash;&n;    X##_e = _FP_EXPMAX_##fs;&t;&t;&t;&t;&t;&bslash;&n;    if (!_FP_KEEPNANFRACP)&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;_FP_FRAC_SET_##wc(X, _FP_NANFRAC_##fs);&t;&t;&t;&bslash;&n;&t;X##_s = _FP_NANSIGN_##fs;&t;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    else&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      _FP_FRAC_HIGH_RAW_##fs(X) |= _FP_QNANBIT_##fs;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;} while (0)
multiline_comment|/* This one accepts raw argument and not cooked,  returns&n; * 1 if X is a signaling NaN.&n; */
DECL|macro|_FP_ISSIGNAN
mdefine_line|#define _FP_ISSIGNAN(fs, wc, X)&t;&t;&t;&t;&t;&bslash;&n;({&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  int __ret = 0;&t;&t;&t;&t;&t;&t;&bslash;&n;  if (X##_e == _FP_EXPMAX_##fs)&t;&t;&t;&t;&t;&bslash;&n;    {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      if (!_FP_FRAC_ZEROP_##wc(X)&t;&t;&t;&t;&bslash;&n;&t;  &amp;&amp; !(_FP_FRAC_HIGH_RAW_##fs(X) &amp; _FP_QNANBIT_##fs))&t;&bslash;&n;&t;__ret = 1;&t;&t;&t;&t;&t;&t;&bslash;&n;    }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  __ret;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;})
multiline_comment|/*&n; * Main addition routine.  The input values should be cooked.&n; */
DECL|macro|_FP_ADD_INTERNAL
mdefine_line|#define _FP_ADD_INTERNAL(fs, wc, R, X, Y, OP)&t;&t;&t;&t;     &bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  switch (_FP_CLS_COMBINE(X##_c, Y##_c))&t;&t;&t;&t;     &bslash;&n;  {&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NORMAL):&t;&t;&t;     &bslash;&n;    {&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      /* shift the smaller number so that its exponent matches the larger */ &bslash;&n;      _FP_I_TYPE diff = X##_e - Y##_e;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      if (diff &lt; 0)&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;  diff = -diff;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;  if (diff &lt;= _FP_WFRACBITS_##fs)&t;&t;&t;&t;     &bslash;&n;&t;    _FP_FRAC_SRS_##wc(X, diff, _FP_WFRACBITS_##fs);&t;&t;     &bslash;&n;&t;  else if (!_FP_FRAC_ZEROP_##wc(X))&t;&t;&t;&t;     &bslash;&n;&t;    _FP_FRAC_SET_##wc(X, _FP_MINFRAC_##wc);&t;&t;&t;     &bslash;&n;&t;  R##_e = Y##_e;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      else&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;  if (diff &gt; 0)&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;    {&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;      if (diff &lt;= _FP_WFRACBITS_##fs)&t;&t;&t;&t;     &bslash;&n;&t;        _FP_FRAC_SRS_##wc(Y, diff, _FP_WFRACBITS_##fs);&t;&t;     &bslash;&n;&t;      else if (!_FP_FRAC_ZEROP_##wc(Y))&t;&t;&t;&t;     &bslash;&n;&t;        _FP_FRAC_SET_##wc(Y, _FP_MINFRAC_##wc);&t;&t;&t;     &bslash;&n;&t;    }&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;  R##_e = X##_e;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      R##_c = FP_CLS_NORMAL;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      if (X##_s == Y##_s)&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;  R##_s = X##_s;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;  _FP_FRAC_ADD_##wc(R, X, Y);&t;&t;&t;&t;&t;     &bslash;&n;&t;  if (_FP_FRAC_OVERP_##wc(fs, R))&t;&t;&t;&t;     &bslash;&n;&t;    {&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;      _FP_FRAC_SRS_##wc(R, 1, _FP_WFRACBITS_##fs);&t;&t;     &bslash;&n;&t;      R##_e++;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;    }&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      else&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;{&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;  R##_s = X##_s;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;  _FP_FRAC_SUB_##wc(R, X, Y);&t;&t;&t;&t;&t;     &bslash;&n;&t;  if (_FP_FRAC_ZEROP_##wc(R))&t;&t;&t;&t;&t;     &bslash;&n;&t;    {&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;      /* return an exact zero */&t;&t;&t;&t;     &bslash;&n;&t;      if (FP_ROUNDMODE == FP_RND_MINF)&t;&t;&t;&t;     &bslash;&n;&t;&t;R##_s |= Y##_s;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;      else&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;R##_s &amp;= Y##_s;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;      R##_c = FP_CLS_ZERO;&t;&t;&t;&t;&t;     &bslash;&n;&t;    }&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;  else&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;    {&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;      if (_FP_FRAC_NEGP_##wc(R))&t;&t;&t;&t;     &bslash;&n;&t;&t;{&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;  _FP_FRAC_SUB_##wc(R, Y, X);&t;&t;&t;&t;     &bslash;&n;&t;&t;  R##_s = Y##_s;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;      /* renormalize after subtraction */&t;&t;&t;     &bslash;&n;&t;      _FP_FRAC_CLZ_##wc(diff, R);&t;&t;&t;&t;     &bslash;&n;&t;      diff -= _FP_WFRACXBITS_##fs;&t;&t;&t;&t;     &bslash;&n;&t;      if (diff)&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;{&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;  R##_e -= diff;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;  _FP_FRAC_SLL_##wc(R, diff);&t;&t;&t;&t;     &bslash;&n;&t;&t;}&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;    }&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      break;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    }&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NAN):&t;&t;&t;&t;     &bslash;&n;    _FP_CHOOSENAN(fs, wc, R, X, Y, OP);&t;&t;&t;&t;&t;     &bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_ZERO):&t;&t;&t;     &bslash;&n;    R##_e = X##_e;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NORMAL):&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_INF):&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_ZERO):&t;&t;&t;&t;     &bslash;&n;    _FP_FRAC_COPY_##wc(R, X);&t;&t;&t;&t;&t;&t;     &bslash;&n;    R##_s = X##_s;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    R##_c = X##_c;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NORMAL):&t;&t;&t;     &bslash;&n;    R##_e = Y##_e;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NAN):&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NAN):&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NAN):&t;&t;&t;&t;     &bslash;&n;    _FP_FRAC_COPY_##wc(R, Y);&t;&t;&t;&t;&t;&t;     &bslash;&n;    R##_s = Y##_s;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    R##_c = Y##_c;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_INF):&t;&t;&t;&t;     &bslash;&n;    if (X##_s != Y##_s)&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;/* +INF + -INF =&gt; NAN */&t;&t;&t;&t;&t;     &bslash;&n;&t;_FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);&t;&t;&t;&t;     &bslash;&n;&t;R##_s = _FP_NANSIGN_##fs;&t;&t;&t;&t;&t;     &bslash;&n;&t;R##_c = FP_CLS_NAN;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;FP_SET_EXCEPTION(FP_EX_INVALID);&t;&t;&t;&t;     &bslash;&n;&t;break;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    /* FALLTHRU */&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NORMAL):&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_ZERO):&t;&t;&t;&t;     &bslash;&n;    R##_s = X##_s;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    R##_c = FP_CLS_INF;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_INF):&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_INF):&t;&t;&t;&t;     &bslash;&n;    R##_s = Y##_s;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    R##_c = FP_CLS_INF;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_ZERO):&t;&t;&t;     &bslash;&n;    /* make sure the sign is correct */&t;&t;&t;&t;&t;     &bslash;&n;    if (FP_ROUNDMODE == FP_RND_MINF)&t;&t;&t;&t;&t;     &bslash;&n;      R##_s = X##_s | Y##_s;&t;&t;&t;&t;&t;&t;     &bslash;&n;    else&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;      R##_s = X##_s &amp; Y##_s;&t;&t;&t;&t;&t;&t;     &bslash;&n;    R##_c = FP_CLS_ZERO;&t;&t;&t;&t;&t;&t;     &bslash;&n;    break;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  default:&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    abort();&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;  }&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;} while (0)
DECL|macro|_FP_ADD
mdefine_line|#define _FP_ADD(fs, wc, R, X, Y) _FP_ADD_INTERNAL(fs, wc, R, X, Y, &squot;+&squot;)
DECL|macro|_FP_SUB
mdefine_line|#define _FP_SUB(fs, wc, R, X, Y)&t;&t;&t;&t;&t;     &bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;    if (Y##_c != FP_CLS_NAN) Y##_s ^= 1;&t;&t;&t;&t;     &bslash;&n;    _FP_ADD_INTERNAL(fs, wc, R, X, Y, &squot;-&squot;);&t;&t;&t;&t;     &bslash;&n;  } while (0)
multiline_comment|/*&n; * Main negation routine.  FIXME -- when we care about setting exception&n; * bits reliably, this will not do.  We should examine all of the fp classes.&n; */
DECL|macro|_FP_NEG
mdefine_line|#define _FP_NEG(fs, wc, R, X)&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_COPY_##wc(R, X);&t;&t;&bslash;&n;    R##_c = X##_c;&t;&t;&t;&bslash;&n;    R##_e = X##_e;&t;&t;&t;&bslash;&n;    R##_s = 1 ^ X##_s;&t;&t;&t;&bslash;&n;  } while (0)
multiline_comment|/*&n; * Main multiplication routine.  The input values should be cooked.&n; */
DECL|macro|_FP_MUL
mdefine_line|#define _FP_MUL(fs, wc, R, X, Y)&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  R##_s = X##_s ^ Y##_s;&t;&t;&t;&t;&bslash;&n;  switch (_FP_CLS_COMBINE(X##_c, Y##_c))&t;&t;&bslash;&n;  {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NORMAL):&t;&bslash;&n;    R##_c = FP_CLS_NORMAL;&t;&t;&t;&t;&bslash;&n;    R##_e = X##_e + Y##_e + 1;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    _FP_MUL_MEAT_##fs(R,X,Y);&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    if (_FP_FRAC_OVERP_##wc(fs, R))&t;&t;&t;&bslash;&n;      _FP_FRAC_SRS_##wc(R, 1, _FP_WFRACBITS_##fs);&t;&bslash;&n;    else&t;&t;&t;&t;&t;&t;&bslash;&n;      R##_e--;&t;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NAN):&t;&t;&bslash;&n;    _FP_CHOOSENAN(fs, wc, R, X, Y, &squot;*&squot;);&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NORMAL):&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_INF):&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_ZERO):&t;&t;&bslash;&n;    R##_s = X##_s;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_INF):&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NORMAL):&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NORMAL):&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_ZERO):&t;&bslash;&n;    _FP_FRAC_COPY_##wc(R, X);&t;&t;&t;&t;&bslash;&n;    R##_c = X##_c;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NAN):&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NAN):&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NAN):&t;&t;&bslash;&n;    R##_s = Y##_s;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_INF):&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_ZERO):&t;&bslash;&n;    _FP_FRAC_COPY_##wc(R, Y);&t;&t;&t;&t;&bslash;&n;    R##_c = Y##_c;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_ZERO):&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_INF):&t;&t;&bslash;&n;    R##_s = _FP_NANSIGN_##fs;&t;&t;&t;&t;&bslash;&n;    R##_c = FP_CLS_NAN;&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);&t;&t;&bslash;&n;    FP_SET_EXCEPTION(FP_EX_INVALID);&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  default:&t;&t;&t;&t;&t;&t;&bslash;&n;    abort();&t;&t;&t;&t;&t;&t;&bslash;&n;  }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;} while (0)
multiline_comment|/*&n; * Main division routine.  The input values should be cooked.&n; */
DECL|macro|_FP_DIV
mdefine_line|#define _FP_DIV(fs, wc, R, X, Y)&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  R##_s = X##_s ^ Y##_s;&t;&t;&t;&t;&bslash;&n;  switch (_FP_CLS_COMBINE(X##_c, Y##_c))&t;&t;&bslash;&n;  {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NORMAL):&t;&bslash;&n;    R##_c = FP_CLS_NORMAL;&t;&t;&t;&t;&bslash;&n;    R##_e = X##_e - Y##_e;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    _FP_DIV_MEAT_##fs(R,X,Y);&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NAN):&t;&t;&bslash;&n;    _FP_CHOOSENAN(fs, wc, R, X, Y, &squot;/&squot;);&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_NORMAL):&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_INF):&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NAN,FP_CLS_ZERO):&t;&t;&bslash;&n;    R##_s = X##_s;&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_COPY_##wc(R, X);&t;&t;&t;&t;&bslash;&n;    R##_c = X##_c;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_NAN):&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NAN):&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NAN):&t;&t;&bslash;&n;    R##_s = Y##_s;&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_COPY_##wc(R, Y);&t;&t;&t;&t;&bslash;&n;    R##_c = Y##_c;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_INF):&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_INF):&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_NORMAL):&t;&bslash;&n;    R##_c = FP_CLS_ZERO;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_NORMAL,FP_CLS_ZERO):&t;&bslash;&n;    FP_SET_EXCEPTION(FP_EX_DIVZERO);&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_ZERO):&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_NORMAL):&t;&bslash;&n;    R##_c = FP_CLS_INF;&t;&t;&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_INF,FP_CLS_INF):&t;&t;&bslash;&n;  case _FP_CLS_COMBINE(FP_CLS_ZERO,FP_CLS_ZERO):&t;&bslash;&n;    R##_s = _FP_NANSIGN_##fs;&t;&t;&t;&t;&bslash;&n;    R##_c = FP_CLS_NAN;&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);&t;&t;&bslash;&n;    FP_SET_EXCEPTION(FP_EX_INVALID);&t;&t;&t;&bslash;&n;    break;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  default:&t;&t;&t;&t;&t;&t;&bslash;&n;    abort();&t;&t;&t;&t;&t;&t;&bslash;&n;  }&t;&t;&t;&t;&t;&t;&t;&bslash;&n;} while (0)
multiline_comment|/*&n; * Main differential comparison routine.  The inputs should be raw not&n; * cooked.  The return is -1,0,1 for normal values, 2 otherwise.&n; */
DECL|macro|_FP_CMP
mdefine_line|#define _FP_CMP(fs, wc, ret, X, Y, un)&t;&t;&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    /* NANs are unordered */&t;&t;&t;&t;&t;&t;&bslash;&n;    if ((X##_e == _FP_EXPMAX_##fs &amp;&amp; !_FP_FRAC_ZEROP_##wc(X))&t;&t;&bslash;&n;&t;|| (Y##_e == _FP_EXPMAX_##fs &amp;&amp; !_FP_FRAC_ZEROP_##wc(Y)))&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ret = un;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;int __is_zero_x;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;int __is_zero_y;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;__is_zero_x = (!X##_e &amp;&amp; _FP_FRAC_ZEROP_##wc(X)) ? 1 : 0;&t;&bslash;&n;&t;__is_zero_y = (!Y##_e &amp;&amp; _FP_FRAC_ZEROP_##wc(Y)) ? 1 : 0;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (__is_zero_x &amp;&amp; __is_zero_y)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;ret = 0;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else if (__is_zero_x)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;ret = Y##_s ? 1 : -1;&t;&t;&t;&t;&t;&bslash;&n;&t;else if (__is_zero_y)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;ret = X##_s ? -1 : 1;&t;&t;&t;&t;&t;&bslash;&n;&t;else if (X##_s != Y##_s)&t;&t;&t;&t;&t;&bslash;&n;&t;  ret = X##_s ? -1 : 1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else if (X##_e &gt; Y##_e)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  ret = X##_s ? -1 : 1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else if (X##_e &lt; Y##_e)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  ret = X##_s ? 1 : -1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else if (_FP_FRAC_GT_##wc(X, Y))&t;&t;&t;&t;&bslash;&n;&t;  ret = X##_s ? -1 : 1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else if (_FP_FRAC_GT_##wc(Y, X))&t;&t;&t;&t;&bslash;&n;&t;  ret = X##_s ? 1 : -1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  ret = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
multiline_comment|/* Simplification for strict equality.  */
DECL|macro|_FP_CMP_EQ
mdefine_line|#define _FP_CMP_EQ(fs, wc, ret, X, Y)&t;&t;&t;&t;&t;  &bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;    /* NANs are unordered */&t;&t;&t;&t;&t;&t;  &bslash;&n;    if ((X##_e == _FP_EXPMAX_##fs &amp;&amp; !_FP_FRAC_ZEROP_##wc(X))&t;&t;  &bslash;&n;&t;|| (Y##_e == _FP_EXPMAX_##fs &amp;&amp; !_FP_FRAC_ZEROP_##wc(Y)))&t;  &bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;&t;ret = 1;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;    else&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;&t;ret = !(X##_e == Y##_e&t;&t;&t;&t;&t;&t;  &bslash;&n;&t;&t;&amp;&amp; _FP_FRAC_EQ_##wc(X, Y)&t;&t;&t;&t;  &bslash;&n;&t;&t;&amp;&amp; (X##_s == Y##_s || !X##_e &amp;&amp; _FP_FRAC_ZEROP_##wc(X))); &bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;  &bslash;&n;  } while (0)
multiline_comment|/*&n; * Main square root routine.  The input value should be cooked.&n; */
DECL|macro|_FP_SQRT
mdefine_line|#define _FP_SQRT(fs, wc, R, X)&t;&t;&t;&t;&t;&t;&bslash;&n;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_DECL_##wc(T); _FP_FRAC_DECL_##wc(S);&t;&t;&t;&bslash;&n;    _FP_W_TYPE q;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    switch (X##_c)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    case FP_CLS_NAN:&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;_FP_FRAC_COPY_##wc(R, X);&t;&t;&t;&t;&t;&bslash;&n;&t;R##_s = X##_s;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;R##_c = FP_CLS_NAN;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;break;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    case FP_CLS_INF:&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;if (X##_s)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;  {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;    R##_s = _FP_NANSIGN_##fs;&t;&t;&t;&t;&t;&bslash;&n;&t;    R##_c = FP_CLS_NAN; /* NAN */&t;&t;&t;&t;&bslash;&n;&t;    _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);&t;&t;&t;&bslash;&n;&t;    FP_SET_EXCEPTION(FP_EX_INVALID);&t;&t;&t;&t;&bslash;&n;    &t;  }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;  {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;    R##_s = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;    R##_c = FP_CLS_INF; /* sqrt(+inf) = +inf */&t;&t;&t;&bslash;&n;    &t;  }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;break;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    case FP_CLS_ZERO:&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;R##_s = X##_s;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;R##_c = FP_CLS_ZERO; /* sqrt(+-0) = +-0 */&t;&t;&t;&bslash;&n;&t;break;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    case FP_CLS_NORMAL:&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;R##_s = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        if (X##_s)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;          {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    R##_c = FP_CLS_NAN; /* sNAN */&t;&t;&t;&t;&bslash;&n;&t;    R##_s = _FP_NANSIGN_##fs;&t;&t;&t;&t;&t;&bslash;&n;&t;    _FP_FRAC_SET_##wc(R, _FP_NANFRAC_##fs);&t;&t;&t;&bslash;&n;&t;    FP_SET_EXCEPTION(FP_EX_INVALID);&t;&t;&t;&t;&bslash;&n;&t;    break;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;          }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    &t;R##_c = FP_CLS_NORMAL;&t;&t;&t;&t;&t;&t;&bslash;&n;        if (X##_e &amp; 1)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;          _FP_FRAC_SLL_##wc(X, 1);&t;&t;&t;&t;&t;&bslash;&n;        R##_e = X##_e &gt;&gt; 1;&t;&t;&t;&t;&t;&t;&bslash;&n;        _FP_FRAC_SET_##wc(S, _FP_ZEROFRAC_##wc);&t;&t;&t;&bslash;&n;        _FP_FRAC_SET_##wc(R, _FP_ZEROFRAC_##wc);&t;&t;&t;&bslash;&n;        q = _FP_OVERFLOW_##fs &gt;&gt; 1;&t;&t;&t;&t;&t;&bslash;&n;        _FP_SQRT_MEAT_##wc(R, S, T, X, q);&t;&t;&t;&t;&bslash;&n;    }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
multiline_comment|/*&n; * Convert from FP to integer&n; */
multiline_comment|/* RSIGNED can have following values:&n; * 0:  the number is required to be 0..(2^rsize)-1, if not, NV is set plus&n; *     the result is either 0 or (2^rsize)-1 depending on the sign in such case.&n; * 1:  the number is required to be -(2^(rsize-1))..(2^(rsize-1))-1, if not, NV is&n; *     set plus the result is either -(2^(rsize-1)) or (2^(rsize-1))-1 depending&n; *     on the sign in such case.&n; * 2:  the number is required to be -(2^(rsize-1))..(2^(rsize-1))-1, if not, NV is&n; *     set plus the result is truncated to fit into destination.&n; * -1: the number is required to be -(2^(rsize-1))..(2^rsize)-1, if not, NV is&n; *     set plus the result is either -(2^(rsize-1)) or (2^(rsize-1))-1 depending&n; *     on the sign in such case.&n; */
DECL|macro|_FP_TO_INT
mdefine_line|#define _FP_TO_INT(fs, wc, r, X, rsize, rsigned)&t;&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    switch (X##_c)&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      case FP_CLS_NORMAL:&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (X##_e &lt; 0)&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    FP_SET_EXCEPTION(FP_EX_INEXACT);&t;&t;&t;&t;&t;&bslash;&n;&t;  case FP_CLS_ZERO:&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    r = 0;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else if (X##_e &gt;= rsize - (rsigned &gt; 0 || X##_s)&t;&t;&t;&bslash;&n;&t;&t; || (!rsigned &amp;&amp; X##_s))&t;&t;&t;&t;&t;&bslash;&n;&t;  {&t;/* overflow */&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  case FP_CLS_NAN:                                                      &bslash;&n;&t;  case FP_CLS_INF:&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    if (rsigned == 2)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (X##_c != FP_CLS_NORMAL&t;&t;&t;&t;&t;&bslash;&n;&t;&t;    || X##_e &gt;= rsize - 1 + _FP_WFRACBITS_##fs)&t;&t;&t;&bslash;&n;&t;&t;  r = 0;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;  {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;    _FP_FRAC_SLL_##wc(X, (X##_e - _FP_WFRACBITS_##fs + 1));&t;&bslash;&n;&t;&t;    _FP_FRAC_ASSEMBLE_##wc(r, X, rsize);&t;&t;&t;&bslash;&n;&t;&t;  }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    else if (rsigned)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;r = 1;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;r &lt;&lt;= rsize - 1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;r -= 1 - X##_s;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;r = 0;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (X##_s)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;  r = ~r;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    FP_SET_EXCEPTION(FP_EX_INVALID);&t;&t;&t;&t;&t;&bslash;&n;&t;  }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    if (_FP_W_TYPE_SIZE*wc &lt; rsize)&t;&t;&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;_FP_FRAC_ASSEMBLE_##wc(r, X, rsize);&t;&t;&t;&t;&bslash;&n;&t;&t;r &lt;&lt;= X##_e - _FP_WFRACBITS_##fs;&t;&t;&t;&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (X##_e &gt;= _FP_WFRACBITS_##fs)&t;&t;&t;&t;&bslash;&n;&t;&t;  _FP_FRAC_SLL_##wc(X, (X##_e - _FP_WFRACBITS_##fs + 1));&t;&bslash;&n;&t;&t;else if (X##_e &lt; _FP_WFRACBITS_##fs - 1)&t;&t;&t;&bslash;&n;&t;&t;  {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;    _FP_FRAC_SRS_##wc(X, (_FP_WFRACBITS_##fs - X##_e - 2),&t;&bslash;&n;&t;&t;&t;&t;      _FP_WFRACBITS_##fs);&t;&t;&t;&bslash;&n;&t;&t;    if (_FP_FRAC_LOW_##wc(X) &amp; 1)&t;&t;&t;&t;&bslash;&n;&t;&t;      FP_SET_EXCEPTION(FP_EX_INEXACT);&t;&t;&t;&t;&bslash;&n;&t;&t;    _FP_FRAC_SRL_##wc(X, 1);&t;&t;&t;&t;&t;&bslash;&n;&t;&t;  }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;_FP_FRAC_ASSEMBLE_##wc(r, X, rsize);&t;&t;&t;&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    if (rsigned &amp;&amp; X##_s)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      r = -r;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;break;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
DECL|macro|_FP_TO_INT_ROUND
mdefine_line|#define _FP_TO_INT_ROUND(fs, wc, r, X, rsize, rsigned)&t;&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    r = 0;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    switch (X##_c)&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      case FP_CLS_NORMAL:&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (X##_e &gt;= _FP_FRACBITS_##fs - 1)&t;&t;&t;&t;&t;&bslash;&n;&t;  {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    if (X##_e &lt; rsize - 1 + _FP_WFRACBITS_##fs)&t;&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (X##_e &gt;= _FP_WFRACBITS_##fs - 1)&t;&t;&t;&t;&bslash;&n;&t;&t;  {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;    _FP_FRAC_ASSEMBLE_##wc(r, X, rsize);&t;&t;&t;&bslash;&n;&t;&t;    r &lt;&lt;= X##_e - _FP_WFRACBITS_##fs + 1;&t;&t;&t;&bslash;&n;&t;&t;  }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;  {&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;    _FP_FRAC_SRL_##wc(X, _FP_WORKBITS - X##_e&t;&t;&t;&bslash;&n;&t;&t;&t;&t;      + _FP_FRACBITS_##fs - 1);&t;&t;&t;&bslash;&n;&t;&t;    _FP_FRAC_ASSEMBLE_##wc(r, X, rsize);&t;&t;&t;&bslash;&n;&t;&t;  }&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    if (X##_e &lt;= -_FP_WORKBITS - 1)&t;&t;&t;&t;&t;&bslash;&n;&t;      _FP_FRAC_SET_##wc(X, _FP_MINFRAC_##wc);&t;&t;&t;&t;&bslash;&n;&t;    else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      _FP_FRAC_SRS_##wc(X, _FP_FRACBITS_##fs - 1 - X##_e,&t;&t;&bslash;&n;&t;&t;&t;&t;_FP_WFRACBITS_##fs);&t;&t;&t;&t;&bslash;&n;&t;    _FP_ROUND(wc, X);&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    _FP_FRAC_SRL_##wc(X, _FP_WORKBITS);&t;&t;&t;&t;&t;&bslash;&n;&t;    _FP_FRAC_ASSEMBLE_##wc(r, X, rsize);&t;&t;&t;&t;&bslash;&n;&t;  }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (rsigned &amp;&amp; X##_s)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  r = -r;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (X##_e &gt;= rsize - (rsigned &gt; 0 || X##_s)&t;&t;&t;&t;&bslash;&n;&t;    || (!rsigned &amp;&amp; X##_s))&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  {&t;/* overflow */&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  case FP_CLS_NAN:                                                      &bslash;&n;&t;  case FP_CLS_INF:&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    if (!rsigned)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;r = 0;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;if (X##_s)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;  r = ~r;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    else if (rsigned != 2)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;r = 1;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;r &lt;&lt;= rsize - 1;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;r -= 1 - X##_s;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;    FP_SET_EXCEPTION(FP_EX_INVALID);&t;&t;&t;&t;&t;&bslash;&n;&t;  }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;break;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      case FP_CLS_ZERO:&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        break;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
DECL|macro|_FP_FROM_INT
mdefine_line|#define _FP_FROM_INT(fs, wc, X, r, rsize, rtype)&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    if (r)&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;X##_c = FP_CLS_NORMAL;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if ((X##_s = (r &lt; 0)))&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  r = -r;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (rsize &lt;= _FP_W_TYPE_SIZE)&t;&t;&t;&t;&t;&bslash;&n;&t;  __FP_CLZ(X##_e, r);&t;&t;&t;&t;&t;&t;&bslash;&n;&t;else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  __FP_CLZ_2(X##_e, (_FP_W_TYPE)(r &gt;&gt; _FP_W_TYPE_SIZE), &t;&bslash;&n;&t;&t;     (_FP_W_TYPE)r);&t;&t;&t;&t;&t;&bslash;&n;&t;if (rsize &lt; _FP_W_TYPE_SIZE)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;X##_e -= (_FP_W_TYPE_SIZE - rsize);&t;&t;&t;&bslash;&n;&t;X##_e = rsize - X##_e - 1;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (_FP_FRACBITS_##fs &lt; rsize &amp;&amp; _FP_WFRACBITS_##fs &lt; X##_e)&t;&bslash;&n;&t;  __FP_FRAC_SRS_1(r, (X##_e - _FP_WFRACBITS_##fs), rsize);&t;&bslash;&n;&t;r &amp;= ~((rtype)1 &lt;&lt; X##_e);&t;&t;&t;&t;&t;&bslash;&n;&t;_FP_FRAC_DISASSEMBLE_##wc(X, ((unsigned rtype)r), rsize);&t;&bslash;&n;&t;_FP_FRAC_SLL_##wc(X, (_FP_WFRACBITS_##fs - X##_e - 1));&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    else&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;      {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;X##_c = FP_CLS_ZERO, X##_s = 0;&t;&t;&t;&t;&t;&bslash;&n;      }&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
DECL|macro|FP_CONV
mdefine_line|#define FP_CONV(dfs,sfs,dwc,swc,D,S)&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    _FP_FRAC_CONV_##dwc##_##swc(dfs, sfs, D, S);&t;&bslash;&n;    D##_e = S##_e;&t;&t;&t;&t;&t;&bslash;&n;    D##_c = S##_c;&t;&t;&t;&t;&t;&bslash;&n;    D##_s = S##_s;&t;&t;&t;&t;&t;&bslash;&n;  } while (0)
multiline_comment|/*&n; * Helper primitives.&n; */
multiline_comment|/* Count leading zeros in a word.  */
macro_line|#ifndef __FP_CLZ
macro_line|#if _FP_W_TYPE_SIZE &lt; 64
multiline_comment|/* this is just to shut the compiler up about shifts &gt; word length -- PMM 02/1998 */
DECL|macro|__FP_CLZ
mdefine_line|#define __FP_CLZ(r, x)&t;&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&bslash;&n;    _FP_W_TYPE _t = (x);&t;&t;&t;&bslash;&n;    r = _FP_W_TYPE_SIZE - 1;&t;&t;&t;&bslash;&n;    if (_t &gt; 0xffff) r -= 16;&t;&t;&t;&bslash;&n;    if (_t &gt; 0xffff) _t &gt;&gt;= 16;&t;&t;&t;&bslash;&n;    if (_t &gt; 0xff) r -= 8;&t;&t;&t;&bslash;&n;    if (_t &gt; 0xff) _t &gt;&gt;= 8;&t;&t;&t;&bslash;&n;    if (_t &amp; 0xf0) r -= 4;&t;&t;&t;&bslash;&n;    if (_t &amp; 0xf0) _t &gt;&gt;= 4;&t;&t;&t;&bslash;&n;    if (_t &amp; 0xc) r -= 2;&t;&t;&t;&bslash;&n;    if (_t &amp; 0xc) _t &gt;&gt;= 2;&t;&t;&t;&bslash;&n;    if (_t &amp; 0x2) r -= 1;&t;&t;&t;&bslash;&n;  } while (0)
macro_line|#else /* not _FP_W_TYPE_SIZE &lt; 64 */
DECL|macro|__FP_CLZ
mdefine_line|#define __FP_CLZ(r, x)&t;&t;&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&bslash;&n;    _FP_W_TYPE _t = (x);&t;&t;&t;&bslash;&n;    r = _FP_W_TYPE_SIZE - 1;&t;&t;&t;&bslash;&n;    if (_t &gt; 0xffffffff) r -= 32;&t;&t;&bslash;&n;    if (_t &gt; 0xffffffff) _t &gt;&gt;= 32;&t;&t;&bslash;&n;    if (_t &gt; 0xffff) r -= 16;&t;&t;&t;&bslash;&n;    if (_t &gt; 0xffff) _t &gt;&gt;= 16;&t;&t;&t;&bslash;&n;    if (_t &gt; 0xff) r -= 8;&t;&t;&t;&bslash;&n;    if (_t &gt; 0xff) _t &gt;&gt;= 8;&t;&t;&t;&bslash;&n;    if (_t &amp; 0xf0) r -= 4;&t;&t;&t;&bslash;&n;    if (_t &amp; 0xf0) _t &gt;&gt;= 4;&t;&t;&t;&bslash;&n;    if (_t &amp; 0xc) r -= 2;&t;&t;&t;&bslash;&n;    if (_t &amp; 0xc) _t &gt;&gt;= 2;&t;&t;&t;&bslash;&n;    if (_t &amp; 0x2) r -= 1;&t;&t;&t;&bslash;&n;  } while (0)
macro_line|#endif /* not _FP_W_TYPE_SIZE &lt; 64 */
macro_line|#endif /* ndef __FP_CLZ */
DECL|macro|_FP_DIV_HELP_imm
mdefine_line|#define _FP_DIV_HELP_imm(q, r, n, d)&t;&t;&bslash;&n;  do {&t;&t;&t;&t;&t;&t;&bslash;&n;    q = n / d, r = n % d;&t;&t;&t;&bslash;&n;  } while (0)
eof
