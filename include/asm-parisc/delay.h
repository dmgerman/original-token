macro_line|#ifndef _PARISC_DELAY_H
DECL|macro|_PARISC_DELAY_H
mdefine_line|#define _PARISC_DELAY_H
macro_line|#include &lt;asm/system.h&gt;    /* for mfctl() */
macro_line|#include &lt;asm/processor.h&gt; /* for boot_cpu_data */
multiline_comment|/*&n; * Copyright (C) 1993 Linus Torvalds&n; *&n; * Delay routines&n; */
r_extern
r_int
r_int
id|loops_per_sec
suffix:semicolon
DECL|function|__delay
r_static
id|__inline__
r_void
id|__delay
c_func
(paren
r_int
r_int
id|loops
)paren
(brace
id|asm
r_volatile
(paren
"&quot;"
dot
id|balignl
l_int|64
comma
l_int|0x34000034
id|addib
comma
id|UV
op_minus
l_int|1
comma
op_mod
l_int|0
comma
dot
id|nop
"&quot;"
suffix:colon
l_string|&quot;=r&quot;
(paren
id|loops
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|loops
)paren
)paren
suffix:semicolon
)brace
DECL|function|__cr16_delay
r_static
id|__inline__
r_void
id|__cr16_delay
c_func
(paren
r_int
r_int
id|clocks
)paren
(brace
r_int
r_int
id|start
suffix:semicolon
multiline_comment|/*&n;&t; * Note: Due to unsigned math, cr16 rollovers shouldn&squot;t be&n;&t; * a problem here. However, on 32 bit, we need to make sure&n;&t; * we don&squot;t pass in too big a value. The current default&n;&t; * value of MAX_UDELAY_MS should help prevent this.&n;&t; */
id|start
op_assign
id|mfctl
c_func
(paren
l_int|16
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|mfctl
c_func
(paren
l_int|16
)paren
op_minus
id|start
)paren
OL
id|clocks
)paren
suffix:semicolon
)brace
DECL|function|__udelay
r_static
id|__inline__
r_void
id|__udelay
c_func
(paren
r_int
r_int
id|usecs
)paren
(brace
id|__cr16_delay
c_func
(paren
id|usecs
op_star
(paren
(paren
r_int
r_int
)paren
id|boot_cpu_data.cpu_hz
op_div
l_int|1000000UL
)paren
)paren
suffix:semicolon
)brace
DECL|macro|udelay
mdefine_line|#define udelay(n) __udelay(n)
macro_line|#endif /* defined(_PARISC_DELAY_H) */
eof
