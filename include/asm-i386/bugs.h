multiline_comment|/*&n; *  include/asm-i386/bugs.h&n; *&n; *  Copyright (C) 1994  Linus Torvalds&n; *&n; *  Cyrix stuff, June 1998 by:&n; *&t;- Rafael R. Reilova (moved everything from head.S),&n; *        &lt;rreilova@ececs.uc.edu&gt;&n; *&t;- Channing Corn (tests &amp; fixes),&n; *&t;- Andrew D. Balsa (code cleanup).&n; */
multiline_comment|/*&n; * This is included by init/main.c to check for architecture-dependent bugs.&n; *&n; * Needs:&n; *&t;void check_bugs(void);&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/msr.h&gt;
DECL|function|no_halt
r_static
r_int
id|__init
id|no_halt
c_func
(paren
r_char
op_star
id|s
)paren
(brace
id|boot_cpu_data.hlt_works_ok
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;no-hlt&quot;
comma
id|no_halt
)paren
suffix:semicolon
DECL|function|mca_pentium
r_static
r_int
id|__init
id|mca_pentium
c_func
(paren
r_char
op_star
id|s
)paren
(brace
id|mca_pentium_flag
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;mca-pentium&quot;
comma
id|mca_pentium
)paren
suffix:semicolon
DECL|function|no_387
r_static
r_int
id|__init
id|no_387
c_func
(paren
r_char
op_star
id|s
)paren
(brace
id|boot_cpu_data.hard_math
op_assign
l_int|0
suffix:semicolon
id|write_cr0
c_func
(paren
l_int|0xE
op_or
id|read_cr0
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;no387&quot;
comma
id|no_387
)paren
suffix:semicolon
DECL|variable|fpu_error
r_static
r_char
id|__initdata
id|fpu_error
op_assign
l_int|0
suffix:semicolon
DECL|function|copro_timeout
r_static
r_void
id|__init
id|copro_timeout
c_func
(paren
r_void
)paren
(brace
id|fpu_error
op_assign
l_int|1
suffix:semicolon
id|timer_table
(braket
id|COPRO_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
id|HZ
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|COPRO_TIMER
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;387 failed: trying to reset&bslash;n&quot;
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGFPE
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
l_int|0xf1
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
l_int|0xf0
)paren
suffix:semicolon
)brace
DECL|variable|x
r_static
r_float
id|__initdata
id|x
op_assign
l_float|4195835.0
suffix:semicolon
DECL|variable|y
r_static
r_float
id|__initdata
id|y
op_assign
l_float|3145727.0
suffix:semicolon
DECL|function|check_fpu
r_static
r_void
id|__init
id|check_fpu
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|control_word
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|boot_cpu_data.hard_math
)paren
(brace
macro_line|#ifndef CONFIG_MATH_EMULATION
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;No coprocessor found and no math emulation present.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;Giving up.&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mca_pentium_flag
)paren
(brace
multiline_comment|/* The IBM Model 95 machines with pentiums lock up on&n;&t;&t; * fpu test, so we avoid it. All pentiums have inbuilt&n;&t;&t; * FPU and thus should use exception 16. We still do&n;&t;&t; * the FDIV test, although I doubt there where ever any&n;&t;&t; * MCA boxes built with non-FDIV-bug cpus.&n;&t;&t; */
id|__asm__
c_func
(paren
l_string|&quot;fninit&bslash;n&bslash;t&quot;
l_string|&quot;fldl %1&bslash;n&bslash;t&quot;
l_string|&quot;fdivl %2&bslash;n&bslash;t&quot;
l_string|&quot;fmull %2&bslash;n&bslash;t&quot;
l_string|&quot;fldl %1&bslash;n&bslash;t&quot;
l_string|&quot;fsubp %%st,%%st(1)&bslash;n&bslash;t&quot;
l_string|&quot;fistpl %0&bslash;n&bslash;t&quot;
l_string|&quot;fwait&bslash;n&bslash;t&quot;
l_string|&quot;fninit&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
op_star
op_amp
id|boot_cpu_data.fdiv_bug
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
op_star
op_amp
id|x
)paren
comma
l_string|&quot;m&quot;
(paren
op_star
op_amp
id|y
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;mca-pentium specified, avoiding FPU coupling test... &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|boot_cpu_data.fdiv_bug
)paren
id|printk
c_func
(paren
l_string|&quot;??? No FDIV bug? Lucky you...&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;detected FDIV bug though.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check if exception 16 works correctly.. This is truly evil&n;&t; * code: it disables the high 8 interrupts to make sure that&n;&t; * the irq13 doesn&squot;t happen. But as this will lead to a lockup&n;&t; * if no exception16 arrives, it depends on the fact that the&n;&t; * high 8 interrupts will be re-enabled by the next timer tick.&n;&t; * So the irq13 will happen eventually, but the exception 16&n;&t; * should get there first..&n;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Checking 386/387 coupling... &quot;
)paren
suffix:semicolon
id|timer_table
(braket
id|COPRO_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|2
suffix:semicolon
id|timer_table
(braket
id|COPRO_TIMER
)braket
dot
id|fn
op_assign
id|copro_timeout
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|COPRO_TIMER
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;clts ; fninit ; fnstcw %0 ; fwait&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
op_star
op_amp
id|control_word
)paren
)paren
suffix:semicolon
id|control_word
op_and_assign
l_int|0xffc0
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;fldcw %0 ; fwait&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
op_star
op_amp
id|control_word
)paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|inb_p
c_func
(paren
l_int|0x21
)paren
op_or
(paren
l_int|1
op_lshift
l_int|2
)paren
comma
l_int|0x21
)paren
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;fldz ; fld1 ; fdiv %st,%st(1) ; fwait&quot;
)paren
suffix:semicolon
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|COPRO_TIMER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fpu_error
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ignore_irq13
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;OK, FPU using old IRQ 13 error reporting&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|__asm__
c_func
(paren
l_string|&quot;fninit&bslash;n&bslash;t&quot;
l_string|&quot;fldl %1&bslash;n&bslash;t&quot;
l_string|&quot;fdivl %2&bslash;n&bslash;t&quot;
l_string|&quot;fmull %2&bslash;n&bslash;t&quot;
l_string|&quot;fldl %1&bslash;n&bslash;t&quot;
l_string|&quot;fsubp %%st,%%st(1)&bslash;n&bslash;t&quot;
l_string|&quot;fistpl %0&bslash;n&bslash;t&quot;
l_string|&quot;fwait&bslash;n&bslash;t&quot;
l_string|&quot;fninit&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
op_star
op_amp
id|boot_cpu_data.fdiv_bug
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
op_star
op_amp
id|x
)paren
comma
l_string|&quot;m&quot;
(paren
op_star
op_amp
id|y
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|boot_cpu_data.fdiv_bug
)paren
id|printk
c_func
(paren
l_string|&quot;OK, FPU using exception 16 error reporting.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;Hmm, FPU using exception 16 error reporting with FDIV bug.&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|check_hlt
r_static
r_void
id|__init
id|check_hlt
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Checking &squot;hlt&squot; instruction... &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|boot_cpu_data.hlt_works_ok
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;hlt ; hlt ; hlt ; hlt&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;OK.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Most 386 processors have a bug where a POPAD can lock the &n; *&t;machine even from user space.&n; */
DECL|function|check_popad
r_static
r_void
id|__init
id|check_popad
c_func
(paren
r_void
)paren
(brace
macro_line|#ifndef CONFIG_X86_POPAD_OK
r_int
id|res
comma
id|inp
op_assign
(paren
r_int
)paren
op_amp
id|res
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Checking for popad bug... &quot;
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;movl $12345678,%%eax; movl $0,%%edi; pusha; popa; movl (%%edx,%%edi),%%ecx &quot;
suffix:colon
l_string|&quot;=&amp;a&quot;
(paren
id|res
)paren
suffix:colon
l_string|&quot;d&quot;
(paren
id|inp
)paren
suffix:colon
l_string|&quot;ecx&quot;
comma
l_string|&quot;edi&quot;
)paren
suffix:semicolon
multiline_comment|/* If this fails, it means that any user program may lock the CPU hard. Too bad. */
r_if
c_cond
(paren
id|res
op_ne
l_int|12345678
)paren
id|printk
c_func
(paren
l_string|&quot;Buggy.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;OK.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *&t;B step AMD K6 before B 9730xxxx have hardware bugs that can cause&n; *&t;misexecution of code under Linux. Owners of such processors should&n; *&t;contact AMD for precise details and a CPU swap.&n; *&n; *&t;See&t;http://www.mygale.com/~poulot/k6bug.html&n; *&t;&t;http://www.amd.com/K6/k6docs/revgd.html&n; *&n; *&t;The following test is erm.. interesting. AMD neglected to up&n; *&t;the chip setting when fixing the bug but they also tweaked some&n; *&t;performance at the same time..&n; */
r_extern
r_void
id|vide
c_func
(paren
r_void
)paren
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;.align 4&bslash;nvide: ret&quot;
)paren
suffix:semicolon
DECL|function|check_amd_k6
r_static
r_void
id|__init
id|check_amd_k6
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|boot_cpu_data.x86_vendor
op_eq
id|X86_VENDOR_AMD
op_logical_and
id|boot_cpu_data.x86_model
op_eq
l_int|6
op_logical_and
id|boot_cpu_data.x86_mask
op_eq
l_int|1
)paren
(brace
r_int
id|n
suffix:semicolon
r_void
(paren
op_star
id|f_vide
)paren
(paren
r_void
)paren
suffix:semicolon
r_int
r_int
id|d
comma
id|d2
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;AMD K6 stepping B detected - &quot;
)paren
suffix:semicolon
DECL|macro|K6_BUG_LOOP
mdefine_line|#define K6_BUG_LOOP 1000000
multiline_comment|/*&n;&t;&t; * It looks like AMD fixed the 2.6.2 bug and improved indirect &n;&t;&t; * calls at the same time.&n;&t;&t; */
id|n
op_assign
id|K6_BUG_LOOP
suffix:semicolon
id|f_vide
op_assign
id|vide
suffix:semicolon
id|rdtscl
c_func
(paren
id|d
)paren
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
)paren
id|f_vide
c_func
(paren
)paren
suffix:semicolon
id|rdtscl
c_func
(paren
id|d2
)paren
suffix:semicolon
id|d
op_assign
id|d2
op_minus
id|d
suffix:semicolon
multiline_comment|/* Knock these two lines out if it debugs out ok */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;K6 BUG %ld %d (Report these if test report is incorrect)&bslash;n&quot;
comma
id|d
comma
l_int|20
op_star
id|K6_BUG_LOOP
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;AMD K6 stepping B detected - &quot;
)paren
suffix:semicolon
multiline_comment|/* -- cut here -- */
r_if
c_cond
(paren
id|d
OG
l_int|20
op_star
id|K6_BUG_LOOP
)paren
id|printk
c_func
(paren
l_string|&quot;system stability may be impaired when more than 32 MB are used.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;probably OK (after B9730xxxx).&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Please see http://www.mygale.com/~poulot/k6bug.html&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * All current models of Pentium and Pentium with MMX technology CPUs&n; * have the F0 0F bug, which lets nonpriviledged users lock up the system:&n; */
macro_line|#ifndef CONFIG_M686
r_extern
r_void
id|trap_init_f00f_bug
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|check_pentium_f00f
r_static
r_void
id|__init
id|check_pentium_f00f
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * Pentium and Pentium MMX&n;&t; */
id|boot_cpu_data.f00f_bug
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|boot_cpu_data.x86
op_eq
l_int|5
op_logical_and
id|boot_cpu_data.x86_vendor
op_eq
id|X86_VENDOR_INTEL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Intel Pentium with F0 0F bug - workaround enabled.&bslash;n&quot;
)paren
suffix:semicolon
id|boot_cpu_data.f00f_bug
op_assign
l_int|1
suffix:semicolon
id|trap_init_f00f_bug
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n; * Perform the Cyrix 5/2 test. A Cyrix won&squot;t change&n; * the flags, while other 486 chips will.&n; */
DECL|function|test_cyrix_52div
r_static
r_inline
r_int
id|test_cyrix_52div
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|test
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;sahf&bslash;n&bslash;t&quot;
multiline_comment|/* clear flags (%eax = 0x0005) */
l_string|&quot;div %b2&bslash;n&bslash;t&quot;
multiline_comment|/* divide 5 by 2 */
l_string|&quot;lahf&quot;
multiline_comment|/* store flags into %ah */
suffix:colon
l_string|&quot;=a&quot;
(paren
id|test
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
l_int|5
)paren
comma
l_string|&quot;q&quot;
(paren
l_int|2
)paren
suffix:colon
l_string|&quot;cc&quot;
)paren
suffix:semicolon
multiline_comment|/* AH is 0x02 on Cyrix after the divide.. */
r_return
(paren
r_int
r_char
)paren
(paren
id|test
op_rshift
l_int|8
)paren
op_eq
l_int|0x02
suffix:semicolon
)brace
multiline_comment|/*&n; * Fix cpuid problems with Cyrix CPU&squot;s:&n; *   -- on the Cx686(L) the cpuid is disabled on power up.&n; *   -- braindamaged BIOS disable cpuid on the Cx686MX.&n; */
r_extern
r_int
r_char
id|Cx86_dir0_msb
suffix:semicolon
multiline_comment|/* exported HACK from cyrix_model() */
DECL|function|check_cx686_cpuid
r_static
r_void
id|__init
id|check_cx686_cpuid
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|boot_cpu_data.cpuid_level
op_eq
op_minus
l_int|1
op_logical_and
(paren
(paren
id|Cx86_dir0_msb
op_eq
l_int|5
)paren
op_logical_or
(paren
id|Cx86_dir0_msb
op_eq
l_int|3
)paren
)paren
)paren
(brace
r_int
id|eax
comma
id|dummy
suffix:semicolon
r_int
r_char
id|ccr3
comma
id|ccr4
suffix:semicolon
id|__u32
id|old_cap
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ccr3
op_assign
id|getCx86
c_func
(paren
id|CX86_CCR3
)paren
suffix:semicolon
id|setCx86
c_func
(paren
id|CX86_CCR3
comma
(paren
id|ccr3
op_amp
l_int|0x0f
)paren
op_or
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* enable MAPEN  */
id|ccr4
op_assign
id|getCx86
c_func
(paren
id|CX86_CCR4
)paren
suffix:semicolon
id|setCx86
c_func
(paren
id|CX86_CCR4
comma
id|ccr4
op_or
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/* enable cpuid  */
id|setCx86
c_func
(paren
id|CX86_CCR3
comma
id|ccr3
)paren
suffix:semicolon
multiline_comment|/* disable MAPEN */
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* we have up to level 1 available on the Cx6x86(L|MX) */
id|boot_cpu_data.cpuid_level
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*  Need to preserve some externally computed capabilities  */
id|old_cap
op_assign
id|boot_cpu_data.x86_capability
op_amp
id|X86_FEATURE_MTRR
suffix:semicolon
id|cpuid
c_func
(paren
l_int|1
comma
op_amp
id|eax
comma
op_amp
id|dummy
comma
op_amp
id|dummy
comma
op_amp
id|boot_cpu_data.x86_capability
)paren
suffix:semicolon
id|boot_cpu_data.x86_capability
op_or_assign
id|old_cap
suffix:semicolon
id|boot_cpu_data.x86
op_assign
(paren
id|eax
op_rshift
l_int|8
)paren
op_amp
l_int|15
suffix:semicolon
multiline_comment|/*&n; &t;&t; * we already have a cooked step/rev number from DIR1&n;&t;&t; * so we don&squot;t use the cpuid-provided ones.&n;&t;&t; */
)brace
)brace
multiline_comment|/*&n; * Reset the slow-loop (SLOP) bit on the 686(L) which is set by some old&n; * BIOSes for compatability with DOS games.  This makes the udelay loop&n; * work correctly, and improves performance.&n; */
r_extern
r_void
id|calibrate_delay
c_func
(paren
r_void
)paren
id|__init
suffix:semicolon
DECL|function|check_cx686_slop
r_static
r_void
id|__init
id|check_cx686_slop
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|Cx86_dir0_msb
op_eq
l_int|3
)paren
(brace
r_int
r_char
id|ccr3
comma
id|ccr5
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ccr3
op_assign
id|getCx86
c_func
(paren
id|CX86_CCR3
)paren
suffix:semicolon
id|setCx86
c_func
(paren
id|CX86_CCR3
comma
(paren
id|ccr3
op_amp
l_int|0x0f
)paren
op_or
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* enable MAPEN  */
id|ccr5
op_assign
id|getCx86
c_func
(paren
id|CX86_CCR5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccr5
op_amp
l_int|2
)paren
id|setCx86
c_func
(paren
id|CX86_CCR5
comma
id|ccr5
op_amp
l_int|0xfd
)paren
suffix:semicolon
multiline_comment|/* reset SLOP */
id|setCx86
c_func
(paren
id|CX86_CCR3
comma
id|ccr3
)paren
suffix:semicolon
multiline_comment|/* disable MAPEN */
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccr5
op_amp
l_int|2
)paren
(brace
multiline_comment|/* possible wrong calibration done */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Recalibrating delay loop with SLOP bit reset&bslash;n&quot;
)paren
suffix:semicolon
id|calibrate_delay
c_func
(paren
)paren
suffix:semicolon
id|boot_cpu_data.loops_per_sec
op_assign
id|loops_per_sec
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Cyrix CPUs without cpuid or with cpuid not yet enabled can be detected&n; * by the fact that they preserve the flags across the division of 5/2.&n; * PII and PPro exhibit this behavior too, but they have cpuid available.&n; */
DECL|function|check_cyrix_cpu
r_static
r_void
id|__init
id|check_cyrix_cpu
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
(paren
id|boot_cpu_data.cpuid_level
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
id|boot_cpu_data.x86
op_eq
l_int|4
)paren
op_logical_and
id|test_cyrix_52div
c_func
(paren
)paren
)paren
(brace
id|strcpy
c_func
(paren
id|boot_cpu_data.x86_vendor_id
comma
l_string|&quot;CyrixInstead&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * In setup.c&squot;s cyrix_model() we have set the boot_cpu_data.coma_bug&n; * on certain processors that we know contain this bug and now we&n; * enable the workaround for it.&n; */
DECL|function|check_cyrix_coma
r_static
r_void
id|__init
id|check_cyrix_coma
c_func
(paren
r_void
)paren
(brace
)brace
multiline_comment|/*&n; * Check whether we are able to run this kernel safely on SMP.&n; *&n; * - In order to run on a i386, we need to be compiled for i386&n; *   (for due to lack of &quot;invlpg&quot; and working WP on a i386)&n; * - In order to run on anything without a TSC, we need to be&n; *   compiled for a i486.&n; * - In order to support the local APIC on a buggy Pentium machine,&n; *   we need to be compiled with CONFIG_X86_GOOD_APIC disabled,&n; *   which happens implicitly if compiled for a Pentium or lower&n; *   (unless an advanced selection of CPU features is used) as an&n; *   otherwise config implies a properly working local APIC without&n; *   the need to do extra reads from the APIC.&n;*/
DECL|function|check_config
r_static
r_void
id|__init
id|check_config
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n; * We&squot;d better not be a i386 if we&squot;re configured to use some&n; * i486+ only features! (WP works in supervisor mode and the&n; * new &quot;invlpg&quot; and &quot;bswap&quot; instructions)&n; */
macro_line|#if defined(CONFIG_X86_WP_WORKS_OK) || defined(CONFIG_X86_INVLPG) || defined(CONFIG_X86_BSWAP)
r_if
c_cond
(paren
id|boot_cpu_data.x86
op_eq
l_int|3
)paren
id|panic
c_func
(paren
l_string|&quot;Kernel requires i486+ for &squot;invlpg&squot; and other features&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * If we configured ourselves for a TSC, we&squot;d better have one!&n; */
macro_line|#ifdef CONFIG_X86_TSC
r_if
c_cond
(paren
op_logical_neg
id|cpu_has_tsc
)paren
id|panic
c_func
(paren
l_string|&quot;Kernel compiled for Pentium+, requires TSC feature!&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * If we configured ourselves for PGE, we&squot;d better have it.&n; */
macro_line|#ifdef CONFIG_X86_PGE
r_if
c_cond
(paren
op_logical_neg
id|cpu_has_pge
)paren
id|panic
c_func
(paren
l_string|&quot;Kernel compiled for PPro+, requires PGE feature!&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * If we were told we had a good local APIC, check for buggy Pentia,&n; * i.e. all B steppings and the C2 stepping of P54C when using their&n; * integrated APIC (see 11AP erratum in &quot;Pentium Processor&n; * Specification Update&quot;).&n; */
macro_line|#if defined(CONFIG_X86_LOCAL_APIC) &amp;&amp; defined(CONFIG_X86_GOOD_APIC)
r_if
c_cond
(paren
id|boot_cpu_data.x86_vendor
op_eq
id|X86_VENDOR_INTEL
op_logical_and
id|boot_cpu_data.x86_capability
op_amp
id|X86_FEATURE_APIC
op_logical_and
id|boot_cpu_data.x86
op_eq
l_int|5
op_logical_and
id|boot_cpu_data.x86_model
op_eq
l_int|2
op_logical_and
(paren
id|boot_cpu_data.x86_mask
OL
l_int|6
op_logical_or
id|boot_cpu_data.x86_mask
op_eq
l_int|11
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Kernel compiled for PPro+, assumes a local APIC without the read-before-write bug!&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|check_bugs
r_static
r_void
id|__init
id|check_bugs
c_func
(paren
r_void
)paren
(brace
id|check_cyrix_cpu
c_func
(paren
)paren
suffix:semicolon
id|identify_cpu
c_func
(paren
op_amp
id|boot_cpu_data
)paren
suffix:semicolon
id|check_cx686_cpuid
c_func
(paren
)paren
suffix:semicolon
id|check_cx686_slop
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifndef __SMP__
id|printk
c_func
(paren
l_string|&quot;CPU: &quot;
)paren
suffix:semicolon
id|print_cpu_info
c_func
(paren
op_amp
id|boot_cpu_data
)paren
suffix:semicolon
macro_line|#endif
id|check_config
c_func
(paren
)paren
suffix:semicolon
id|check_fpu
c_func
(paren
)paren
suffix:semicolon
id|check_hlt
c_func
(paren
)paren
suffix:semicolon
id|check_popad
c_func
(paren
)paren
suffix:semicolon
id|check_amd_k6
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_M686
id|check_pentium_f00f
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|check_cyrix_coma
c_func
(paren
)paren
suffix:semicolon
id|system_utsname.machine
(braket
l_int|1
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|boot_cpu_data.x86
suffix:semicolon
)brace
eof
