multiline_comment|/*&n; *  include/asm-i386/bugs.h&n; *&n; *  Copyright (C) 1994  Linus Torvalds&n; */
multiline_comment|/*&n; * This is included by init/main.c to check for architecture-dependent bugs.&n; *&n; * Needs:&n; *&t;void check_bugs(void);&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#ifdef CONFIG_MTRR
macro_line|#  include &lt;asm/mtrr.h&gt;
macro_line|#endif
DECL|macro|CONFIG_BUGi386
mdefine_line|#define CONFIG_BUGi386
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|no_halt
c_func
(paren
r_char
op_star
id|s
comma
r_int
op_star
id|ints
)paren
)paren
(brace
id|boot_cpu_data.hlt_works_ok
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|no_387
c_func
(paren
r_char
op_star
id|s
comma
r_int
op_star
id|ints
)paren
)paren
(brace
id|boot_cpu_data.hard_math
op_assign
l_int|0
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;movl %%cr0,%%eax&bslash;n&bslash;t&quot;
l_string|&quot;orl $0xE,%%eax&bslash;n&bslash;t&quot;
l_string|&quot;movl %%eax,%%cr0&bslash;n&bslash;t&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;ax&quot;
)paren
suffix:semicolon
)brace
DECL|variable|fpu_error
r_static
r_char
id|__initdata
id|fpu_error
op_assign
l_int|0
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|copro_timeout
c_func
(paren
r_void
)paren
)paren
(brace
id|fpu_error
op_assign
l_int|1
suffix:semicolon
id|timer_table
(braket
id|COPRO_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
l_int|100
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|COPRO_TIMER
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;387 failed: trying to reset&bslash;n&quot;
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGFPE
comma
id|last_task_used_math
comma
l_int|1
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
l_int|0xf1
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
l_int|0xf0
)paren
suffix:semicolon
)brace
DECL|variable|x
r_static
r_float
id|__initdata
id|x
op_assign
l_float|4195835.0
suffix:semicolon
DECL|variable|y
r_static
r_float
id|__initdata
id|y
op_assign
l_float|3145727.0
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|check_fpu
c_func
(paren
r_void
)paren
)paren
(brace
r_int
r_int
id|control_word
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|boot_cpu_data.hard_math
)paren
(brace
macro_line|#ifndef CONFIG_MATH_EMULATION
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;No coprocessor found and no math emulation present.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;Giving up.&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check if exception 16 works correctly.. This is truly evil&n;&t; * code: it disables the high 8 interrupts to make sure that&n;&t; * the irq13 doesn&squot;t happen. But as this will lead to a lockup&n;&t; * if no exception16 arrives, it depends on the fact that the&n;&t; * high 8 interrupts will be re-enabled by the next timer tick.&n;&t; * So the irq13 will happen eventually, but the exception 16&n;&t; * should get there first..&n;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Checking 386/387 coupling... &quot;
)paren
suffix:semicolon
id|timer_table
(braket
id|COPRO_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
l_int|50
suffix:semicolon
id|timer_table
(braket
id|COPRO_TIMER
)braket
dot
id|fn
op_assign
id|copro_timeout
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|COPRO_TIMER
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;clts ; fninit ; fnstcw %0 ; fwait&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
op_star
op_amp
id|control_word
)paren
)paren
suffix:semicolon
id|control_word
op_and_assign
l_int|0xffc0
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;fldcw %0 ; fwait&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
op_star
op_amp
id|control_word
)paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|inb_p
c_func
(paren
l_int|0x21
)paren
op_or
(paren
l_int|1
op_lshift
l_int|2
)paren
comma
l_int|0x21
)paren
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;fldz ; fld1 ; fdiv %st,%st(1) ; fwait&quot;
)paren
suffix:semicolon
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|COPRO_TIMER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fpu_error
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ignore_irq13
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;OK, FPU using old IRQ 13 error reporting&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|__asm__
c_func
(paren
l_string|&quot;fninit&bslash;n&bslash;t&quot;
l_string|&quot;fldl %1&bslash;n&bslash;t&quot;
l_string|&quot;fdivl %2&bslash;n&bslash;t&quot;
l_string|&quot;fmull %2&bslash;n&bslash;t&quot;
l_string|&quot;fldl %1&bslash;n&bslash;t&quot;
l_string|&quot;fsubp %%st,%%st(1)&bslash;n&bslash;t&quot;
l_string|&quot;fistpl %0&bslash;n&bslash;t&quot;
l_string|&quot;fwait&bslash;n&bslash;t&quot;
l_string|&quot;fninit&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
op_star
op_amp
id|boot_cpu_data.fdiv_bug
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
op_star
op_amp
id|x
)paren
comma
l_string|&quot;m&quot;
(paren
op_star
op_amp
id|y
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|boot_cpu_data.fdiv_bug
)paren
id|printk
c_func
(paren
l_string|&quot;OK, FPU using exception 16 error reporting.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;Hmm, FPU using exception 16 error reporting with FDIV bug.&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|check_hlt
c_func
(paren
r_void
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Checking &squot;hlt&squot; instruction... &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|boot_cpu_data.hlt_works_ok
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;disabled&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;hlt ; hlt ; hlt ; hlt&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;OK.&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|check_tlb
c_func
(paren
r_void
)paren
)paren
(brace
macro_line|#ifndef CONFIG_M386
multiline_comment|/*&n;&t; * The 386 chips don&squot;t support TLB finegrained invalidation.&n;&t; * They will fault when they hit an invlpg instruction.&n;&t; */
r_if
c_cond
(paren
id|boot_cpu_data.x86
op_eq
l_int|3
)paren
(brace
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;CPU is a 386 and this kernel was compiled for 486 or better.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Giving up.&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; *&t;Most 386 processors have a bug where a POPAD can lock the &n; *&t;machine even from user space.&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|check_popad
c_func
(paren
r_void
)paren
)paren
(brace
macro_line|#ifdef CONFIG_M386
r_int
id|res
comma
id|inp
op_assign
(paren
r_int
)paren
op_amp
id|res
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Checking for popad bug... &quot;
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;movl $12345678,%%eax; movl $0,%%edi; pusha; popa; movl (%%edx,%%edi),%%ecx &quot;
suffix:colon
l_string|&quot;=eax&quot;
(paren
id|res
)paren
suffix:colon
l_string|&quot;edx&quot;
(paren
id|inp
)paren
suffix:colon
l_string|&quot;eax&quot;
comma
l_string|&quot;ecx&quot;
comma
l_string|&quot;edx&quot;
comma
l_string|&quot;edi&quot;
)paren
suffix:semicolon
multiline_comment|/* If this fails, it means that any user program may lock the CPU hard. Too bad. */
r_if
c_cond
(paren
id|res
op_ne
l_int|12345678
)paren
id|printk
c_func
(paren
l_string|&quot;Buggy.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;OK.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *&t;B step AMD K6 before B 9730xxxx have hardware bugs that can cause&n; *&t;misexecution of code under Linux. Owners of such processors should&n; *&t;contact AMD for precise details and a CPU swap.&n; *&n; *&t;See&t;http://www.chorus.com/~poulot/k6bug.html&n; *&t;&t;http://www.amd.com/K6/k6docs/revgd.html&n; *&n; *&t;The following test is erm.. interesting. AMD neglected to up&n; *&t;the chip setting when fixing the bug but they also tweaked some&n; *&t;performance at the same time..&n; */
r_extern
r_void
id|vide
c_func
(paren
r_void
)paren
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;.align 4&bslash;nvide: ret&quot;
)paren
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|check_amd_k6
c_func
(paren
r_void
)paren
)paren
(brace
r_if
c_cond
(paren
id|boot_cpu_data.x86_vendor
op_eq
id|X86_VENDOR_AMD
op_logical_and
id|boot_cpu_data.x86_model
op_eq
l_int|6
op_logical_and
id|boot_cpu_data.x86_mask
op_eq
l_int|1
)paren
(brace
r_int
id|n
suffix:semicolon
r_void
(paren
op_star
id|f_vide
)paren
(paren
r_void
)paren
suffix:semicolon
r_int
r_int
id|d
comma
id|d2
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;AMD K6 stepping B detected - &quot;
)paren
suffix:semicolon
DECL|macro|K6_BUG_LOOP
mdefine_line|#define K6_BUG_LOOP 1000000
multiline_comment|/*&n;&t;&t; * It looks like AMD fixed the 2.6.2 bug and improved indirect &n;&t;&t; * calls at the same time.&n;&t;&t; */
id|n
op_assign
id|K6_BUG_LOOP
suffix:semicolon
id|f_vide
op_assign
id|vide
suffix:semicolon
id|__asm__
(paren
l_string|&quot;rdtsc&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|d
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
)paren
id|f_vide
c_func
(paren
)paren
suffix:semicolon
id|__asm__
(paren
l_string|&quot;rdtsc&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|d2
)paren
)paren
suffix:semicolon
id|d
op_assign
id|d2
op_minus
id|d
suffix:semicolon
multiline_comment|/* Knock these two lines out if it debugs out ok */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;K6 BUG %ld %d (Report these if test report is incorrect)&bslash;n&quot;
comma
id|d
comma
l_int|20
op_star
id|K6_BUG_LOOP
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;AMD K6 stepping B detected - &quot;
)paren
suffix:semicolon
multiline_comment|/* -- cut here -- */
r_if
c_cond
(paren
id|d
OG
l_int|20
op_star
id|K6_BUG_LOOP
)paren
id|printk
c_func
(paren
l_string|&quot;system stability may be impaired when more than 32 MB are used.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;probably OK (after B9730xxxx).&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Please see http://www.chorus.com/poulot/k6bug.html&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * All current models of Pentium and Pentium with MMX technology CPUs&n; * have the F0 0F bug, which lets nonpriviledged users lock up the system:&n; */
r_extern
r_void
id|trap_init_f00f_bug
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|check_pentium_f00f
c_func
(paren
r_void
)paren
)paren
(brace
multiline_comment|/*&n;&t; * Pentium and Pentium MMX&n;&t; */
id|boot_cpu_data.f00f_bug
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|boot_cpu_data.x86
op_eq
l_int|5
op_logical_and
id|boot_cpu_data.x86_vendor
op_eq
id|X86_VENDOR_INTEL
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Intel Pentium with F0 0F bug - workaround enabled.&bslash;n&quot;
)paren
suffix:semicolon
id|boot_cpu_data.f00f_bug
op_assign
l_int|1
suffix:semicolon
id|trap_init_f00f_bug
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|check_bugs
c_func
(paren
r_void
)paren
)paren
(brace
id|identify_cpu
c_func
(paren
op_amp
id|boot_cpu_data
)paren
suffix:semicolon
macro_line|#ifndef __SMP__
id|printk
c_func
(paren
l_string|&quot;CPU: &quot;
)paren
suffix:semicolon
id|print_cpu_info
c_func
(paren
op_amp
id|boot_cpu_data
)paren
suffix:semicolon
macro_line|#endif
id|check_tlb
c_func
(paren
)paren
suffix:semicolon
id|check_fpu
c_func
(paren
)paren
suffix:semicolon
id|check_hlt
c_func
(paren
)paren
suffix:semicolon
id|check_popad
c_func
(paren
)paren
suffix:semicolon
id|check_amd_k6
c_func
(paren
)paren
suffix:semicolon
id|check_pentium_f00f
c_func
(paren
)paren
suffix:semicolon
id|system_utsname.machine
(braket
l_int|1
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|boot_cpu_data.x86
suffix:semicolon
macro_line|#if !defined(__SMP__) &amp;&amp; defined(CONFIG_MTRR)
multiline_comment|/*  Must be done after other processors booted: at this point we are&n;&t;    called before SMP initialisation, so this is for the non-SMP case&n;&t;    only. The SMP case is handled in arch/i386/kernel/smp.c  */
id|mtrr_init
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
