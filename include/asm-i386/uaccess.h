macro_line|#ifndef __i386_UACCESS_H
DECL|macro|__i386_UACCESS_H
mdefine_line|#define __i386_UACCESS_H
multiline_comment|/*&n; * User space memory access functions&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
DECL|macro|VERIFY_READ
mdefine_line|#define VERIFY_READ 0
DECL|macro|VERIFY_WRITE
mdefine_line|#define VERIFY_WRITE 1
multiline_comment|/*&n; * The fs value determines whether argument validity checking should be&n; * performed or not.  If get_fs() == USER_DS, checking is performed, with&n; * get_fs() == KERNEL_DS, checking is bypassed.&n; * &n; * For historical reasons, these macros are grossly misnamed.&n; */
DECL|macro|get_fs
mdefine_line|#define get_fs()&t;(current-&gt;tss.segment)
DECL|macro|set_fs
mdefine_line|#define set_fs(x)&t;(current-&gt;tss.segment = (x))
DECL|macro|get_ds
mdefine_line|#define get_ds()&t;(KERNEL_DS)
DECL|macro|__user_ok
mdefine_line|#define __user_ok(addr,size) &bslash;&n;((size &lt;= 0xC0000000UL) &amp;&amp; (addr &lt;= 0xC0000000UL - size))
DECL|macro|__kernel_ok
mdefine_line|#define __kernel_ok &bslash;&n;(get_fs() == KERNEL_DS)
r_extern
r_int
id|__verify_write
c_func
(paren
r_const
r_void
op_star
comma
r_int
r_int
)paren
suffix:semicolon
macro_line|#if CPU &gt; 386
DECL|macro|__access_ok
mdefine_line|#define __access_ok(type,addr,size) &bslash;&n;(__kernel_ok || __user_ok(addr,size))
macro_line|#else
DECL|macro|__access_ok
mdefine_line|#define __access_ok(type,addr,size) &bslash;&n;(__kernel_ok || (__user_ok(addr,size) &amp;&amp; &bslash;&n;  ((type) == VERIFY_READ || wp_works_ok || __verify_write((void *)(addr),(size)))))
macro_line|#endif /* CPU */
DECL|macro|access_ok
mdefine_line|#define access_ok(type,addr,size) &bslash;&n;__access_ok((type),(unsigned long)(addr),(size))
multiline_comment|/*&n; * Uh, these should become the main single-value transfer routines..&n; * They automatically use the right size if we just have the right&n; * pointer type..&n; *&n; * This gets kind of ugly. We want to return _two_ values in &quot;get_user()&quot;&n; * and yet we don&squot;t want to do any pointers, because that is too much&n; * of a performance impact. Thus we have a few rather ugly macros here,&n; * and hide all the uglyness from the user.&n; *&n; * The &quot;__xxx&quot; versions of the user access functions are versions that&n; * do not verify the address space, that must have been done previously&n; * with a separate &quot;access_ok()&quot; call (this is used when we do multiple&n; * accesses to the same area of user memory).&n; */
DECL|macro|put_user
mdefine_line|#define put_user(x,ptr) &bslash;&n;__do_put_user((unsigned long)((__typeof__(*(ptr)))(x)),(ptr),(sizeof(*(ptr))))
DECL|macro|__put_user
mdefine_line|#define __put_user(x,ptr) &bslash;&n;__do_put_user_nocheck((unsigned long)((__typeof__(*(ptr)))(x)),(ptr),(sizeof(*(ptr))))
DECL|struct|__large_struct
DECL|member|buf
r_struct
id|__large_struct
(brace
r_int
r_int
id|buf
(braket
l_int|100
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|__m
mdefine_line|#define __m(x) (*(struct __large_struct *)(x))
DECL|macro|__put_user_asm
mdefine_line|#define __put_user_asm(x,addr,ret,bwl,reg,rtype) &bslash;&n;__asm__ __volatile__( &bslash;&n;&t;&quot;movl $1f,%0&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;incl %3&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;mov&quot; #bwl &quot; %&quot; reg &quot;1,%2&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;xorl %0,%0&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;decl %3&bslash;n1:&quot; &bslash;&n;:&quot;=&amp;d&quot; (ret) &bslash;&n;:#rtype (x), &quot;m&quot; (__m(addr)),&quot;m&quot; (current-&gt;tss.ex.count))
r_extern
r_int
id|__put_user_bad
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|__put_user_size
mdefine_line|#define __put_user_size(x,ptr,size,retval) &bslash;&n;switch (size) { &bslash;&n;case 1: __put_user_asm(x,ptr,retval,b,&quot;b&quot;,&quot;iq&quot;); break; &bslash;&n;case 2: __put_user_asm(x,ptr,retval,w,&quot;w&quot;,&quot;ir&quot;); break; &bslash;&n;case 4: __put_user_asm(x,ptr,retval,l,&quot;&quot;,&quot;ir&quot;); break; &bslash;&n;default: retval = __put_user_bad(); }
DECL|function|__do_put_user
r_static
r_inline
r_int
id|__do_put_user
c_func
(paren
r_int
r_int
id|x
comma
r_void
op_star
id|ptr
comma
r_int
id|size
)paren
(brace
r_int
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|ptr
comma
id|size
)paren
)paren
id|__put_user_size
c_func
(paren
id|x
comma
id|ptr
comma
id|size
comma
id|retval
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|macro|__do_put_user_nocheck
mdefine_line|#define __do_put_user_nocheck(x, ptr, size) &bslash;&n;({ int retval; __put_user_size(x,ptr,size,retval); retval; })
DECL|macro|get_user
mdefine_line|#define get_user(x,ptr) &bslash;&n;__do_get_user((x),(unsigned long)(ptr),sizeof(*(ptr)),__typeof__(*(ptr)))
DECL|macro|__get_user
mdefine_line|#define __get_user(x,ptr) &bslash;&n;__do_get_user_nocheck((x),(unsigned long)(ptr),sizeof(*(ptr)),__typeof__(*(ptr)))
DECL|macro|__do_get_user
mdefine_line|#define __do_get_user(x,ptr,size,type) ({ &bslash;&n;unsigned long __gu_addr = ptr; &bslash;&n;int __gu_ret = -EFAULT; &bslash;&n;unsigned long __gu_val = 0; &bslash;&n;if (access_ok(VERIFY_READ,__gu_addr,size)) { &bslash;&n;switch (size) { &bslash;&n;case 1: __do_get_user_8(__gu_val,__gu_addr,__gu_ret); break; &bslash;&n;case 2: __do_get_user_16(__gu_val,__gu_addr,__gu_ret); break; &bslash;&n;case 4: __do_get_user_32(__gu_val,__gu_addr,__gu_ret); break; &bslash;&n;default: __gu_ret = __do_get_user_bad(); break; &bslash;&n;} } x = (type) __gu_val; __gu_ret; })
DECL|macro|__do_get_user_nocheck
mdefine_line|#define __do_get_user_nocheck(x,ptr,size,type) ({ &bslash;&n;int __gu_ret; &bslash;&n;unsigned long __gu_val; &bslash;&n;switch (size) { &bslash;&n;case 1: __do_get_user_8(__gu_val,ptr,__gu_ret); break; &bslash;&n;case 2: __do_get_user_16(__gu_val,ptr,__gu_ret); break; &bslash;&n;case 4: __do_get_user_32(__gu_val,ptr,__gu_ret); break; &bslash;&n;default: __gu_ret = __do_get_user_bad(); __gu_val = 0; break; &bslash;&n;} x = (type) __gu_val; __gu_ret; })
DECL|macro|__do_get_user_asm
mdefine_line|#define __do_get_user_asm(x,addr,ret,bwl,reg,rtype) &bslash;&n;__asm__ __volatile__( &bslash;&n;&t;&quot;movl $1f,%0&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;incl %3&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;mov&quot; #bwl &quot; %2,%&quot; reg &quot;1&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;xorl %0,%0&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;decl %3&bslash;n1:&quot; &bslash;&n;:&quot;=&amp;d&quot; (ret), #rtype (x) &bslash;&n;:&quot;m&quot; (__m(addr)),&quot;m&quot; (current-&gt;tss.ex.count))
DECL|macro|__do_get_user_8
mdefine_line|#define __do_get_user_8(x,addr,ret) &bslash;&n;__do_get_user_asm(x,addr,ret,b,&quot;b&quot;,&quot;=&amp;q&quot;)
DECL|macro|__do_get_user_16
mdefine_line|#define __do_get_user_16(x,addr,ret) &bslash;&n;__do_get_user_asm(x,addr,ret,w,&quot;w&quot;,&quot;=&amp;r&quot;)
DECL|macro|__do_get_user_32
mdefine_line|#define __do_get_user_32(x,addr,ret) &bslash;&n;__do_get_user_asm(x,addr,ret,l,&quot;&quot;,&quot;=&amp;r&quot;)
r_extern
r_int
id|__do_get_user_bad
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|__copy_user
mdefine_line|#define __copy_user(to,from,size) &bslash;&n;__asm__ __volatile__( &bslash;&n;&t;&quot;shrl $2,%1&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movl $3f,%0&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;incl %3&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;rep; movsl&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;testl $2,%2&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;je 1f&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movsw&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;subl $2,%2&bslash;n&quot; &bslash;&n;&t;&quot;1:&bslash;t&quot; &bslash;&n;&t;&quot;testl $1,%2&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;je 2f&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movsb&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;decl %2&bslash;n&quot; &bslash;&n;&t;&quot;2:&bslash;t&quot; &bslash;&n;&t;&quot;decl %3&bslash;n&quot; &bslash;&n;&t;&quot;3:&bslash;tlea 0(%2,%1,4),%0&quot; &bslash;&n;&t;:&quot;=&amp;d&quot; (size) &bslash;&n;&t;:&quot;c&quot; (size), &quot;r&quot; (size &amp; 3), &quot;m&quot; (current-&gt;tss.ex), &bslash;&n;&t; &quot;D&quot; (to), &quot;S&quot; (from) &bslash;&n;&t;:&quot;cx&quot;,&quot;di&quot;,&quot;si&quot;,&quot;memory&quot;);
DECL|function|__constant_copy_user
r_static
r_inline
r_int
r_int
id|__constant_copy_user
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|result
suffix:semicolon
r_switch
c_cond
(paren
id|size
op_amp
l_int|3
)paren
(brace
r_default
suffix:colon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;movl $1f,%0&bslash;n&bslash;t&quot;
l_string|&quot;incl %1&bslash;n&bslash;t&quot;
l_string|&quot;rep ; movsl&bslash;n&bslash;t&quot;
l_string|&quot;decl %1&bslash;n&quot;
l_string|&quot;1:&bslash;tlea 0(,%%ecx,4),%0&quot;
suffix:colon
l_string|&quot;=&amp;d&quot;
(paren
id|result
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
id|current-&gt;tss.ex
)paren
comma
l_string|&quot;S&quot;
(paren
id|from
)paren
comma
l_string|&quot;D&quot;
(paren
id|to
)paren
comma
l_string|&quot;c&quot;
(paren
id|size
op_div
l_int|4
)paren
suffix:colon
l_string|&quot;cx&quot;
comma
l_string|&quot;di&quot;
comma
l_string|&quot;si&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;movl $1f,%0&bslash;n&bslash;t&quot;
l_string|&quot;incl %3&bslash;n&bslash;t&quot;
l_string|&quot;rep ; movsl&bslash;n&bslash;t&quot;
l_string|&quot;movsb&bslash;n&bslash;t&quot;
l_string|&quot;decl %1&bslash;n&bslash;t&quot;
l_string|&quot;decl %3&bslash;n&quot;
l_string|&quot;1:&bslash;tlea 0(%1,%%ecx,4),%0&quot;
suffix:colon
l_string|&quot;=&amp;d&quot;
(paren
id|result
)paren
suffix:colon
l_string|&quot;ab&quot;
(paren
l_int|1
)paren
comma
l_string|&quot;m&quot;
(paren
id|current-&gt;tss.ex
)paren
comma
l_string|&quot;S&quot;
(paren
id|from
)paren
comma
l_string|&quot;D&quot;
(paren
id|to
)paren
comma
l_string|&quot;c&quot;
(paren
id|size
op_div
l_int|4
)paren
suffix:colon
l_string|&quot;cx&quot;
comma
l_string|&quot;di&quot;
comma
l_string|&quot;si&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;movl $1f,%0&bslash;n&bslash;t&quot;
l_string|&quot;incl %2&bslash;n&bslash;t&quot;
l_string|&quot;rep ; movsl&bslash;n&bslash;t&quot;
l_string|&quot;movsw&bslash;n&bslash;t&quot;
l_string|&quot;subl $2,%1&bslash;n&bslash;t&quot;
l_string|&quot;decl %2&bslash;n&quot;
l_string|&quot;1:&bslash;tlea 0(%1,%%ecx,4),%0&quot;
suffix:colon
l_string|&quot;=&amp;d&quot;
(paren
id|result
)paren
suffix:colon
l_string|&quot;ab&quot;
(paren
l_int|2
)paren
comma
l_string|&quot;m&quot;
(paren
id|current-&gt;tss.ex
)paren
comma
l_string|&quot;S&quot;
(paren
id|from
)paren
comma
l_string|&quot;D&quot;
(paren
id|to
)paren
comma
l_string|&quot;c&quot;
(paren
id|size
op_div
l_int|4
)paren
suffix:colon
l_string|&quot;cx&quot;
comma
l_string|&quot;di&quot;
comma
l_string|&quot;si&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;movl $1f,%0&bslash;n&bslash;t&quot;
l_string|&quot;incl %2&bslash;n&bslash;t&quot;
l_string|&quot;rep ; movsl&bslash;n&bslash;t&quot;
l_string|&quot;movsw&bslash;n&bslash;t&quot;
l_string|&quot;subl $2,%1&bslash;n&bslash;t&quot;
l_string|&quot;movsb&bslash;n&bslash;t&quot;
l_string|&quot;decl %1&bslash;n&bslash;t&quot;
l_string|&quot;decl %2&bslash;n&quot;
l_string|&quot;1:&bslash;tlea 0(%1,%%ecx,4),%0&quot;
suffix:colon
l_string|&quot;=&amp;d&quot;
(paren
id|result
)paren
suffix:colon
l_string|&quot;ab&quot;
(paren
l_int|3
)paren
comma
l_string|&quot;m&quot;
(paren
id|current-&gt;tss.ex
)paren
comma
l_string|&quot;S&quot;
(paren
id|from
)paren
comma
l_string|&quot;D&quot;
(paren
id|to
)paren
comma
l_string|&quot;c&quot;
(paren
id|size
op_div
l_int|4
)paren
suffix:colon
l_string|&quot;cx&quot;
comma
l_string|&quot;di&quot;
comma
l_string|&quot;si&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|__generic_copy_to_user
r_static
r_inline
r_int
r_int
id|__generic_copy_to_user
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
r_int
id|n
)paren
(brace
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|to
comma
id|n
)paren
)paren
id|__copy_user
c_func
(paren
id|to
comma
id|from
comma
id|n
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|function|__constant_copy_to_user
r_static
r_inline
r_int
r_int
id|__constant_copy_to_user
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
r_int
id|n
)paren
(brace
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|to
comma
id|n
)paren
)paren
id|n
op_assign
id|__constant_copy_user
c_func
(paren
id|to
comma
id|from
comma
id|n
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|function|__generic_copy_from_user
r_static
r_inline
r_int
r_int
id|__generic_copy_from_user
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
r_int
id|n
)paren
(brace
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|from
comma
id|n
)paren
)paren
id|__copy_user
c_func
(paren
id|to
comma
id|from
comma
id|n
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|function|__constant_copy_from_user
r_static
r_inline
r_int
r_int
id|__constant_copy_from_user
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
r_int
id|n
)paren
(brace
r_if
c_cond
(paren
id|access_ok
c_func
(paren
id|VERIFY_READ
comma
id|from
comma
id|n
)paren
)paren
id|n
op_assign
id|__constant_copy_user
c_func
(paren
id|to
comma
id|from
comma
id|n
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|macro|copy_to_user
mdefine_line|#define copy_to_user(to,from,n) &bslash;&n;(__builtin_constant_p(n) ? &bslash;&n; __constant_copy_to_user((to),(from),(n)) : &bslash;&n; __generic_copy_to_user((to),(from),(n)))
DECL|macro|copy_from_user
mdefine_line|#define copy_from_user(to,from,n) &bslash;&n;(__builtin_constant_p(n) ? &bslash;&n; __constant_copy_from_user((to),(from),(n)) : &bslash;&n; __generic_copy_from_user((to),(from),(n)))
DECL|macro|__clear_user
mdefine_line|#define __clear_user(addr,size) &bslash;&n;__asm__ __volatile__( &bslash;&n;&t;&quot;movl $3f,%0&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;incl %2&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;rep; stosl&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;testl $2,%3&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;je 1f&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;stosw&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;subl $2,%3&bslash;n&quot; &bslash;&n;&t;&quot;1:&bslash;t&quot; &bslash;&n;&t;&quot;testl $1,%3&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;je 2f&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;stosb&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;decl %3&bslash;n&quot; &bslash;&n;&t;&quot;2:&bslash;t&quot; &bslash;&n;&t;&quot;decl %2&bslash;n&quot; &bslash;&n;&t;&quot;3:&bslash;tlea 0(%3,%1,4),%0&quot; &bslash;&n;&t;:&quot;=&amp;d&quot; (size) &bslash;&n;&t;:&quot;c&quot; (size &gt;&gt; 2), &quot;m&quot; (current-&gt;tss.ex), &quot;r&quot; (size &amp; 3), &bslash;&n;&t; &quot;D&quot; (addr), &quot;a&quot; (0) &bslash;&n;&t;:&quot;cx&quot;,&quot;di&quot;,&quot;memory&quot;);
DECL|macro|clear_user
mdefine_line|#define clear_user(addr,n) ({ &bslash;&n;void * __cl_addr = (addr); &bslash;&n;unsigned long __cl_size = (n); &bslash;&n;if (__cl_size &amp;&amp; __access_ok(VERIFY_WRITE, ((unsigned long)(__cl_addr)), __cl_size)) &bslash;&n;__clear_user(__cl_addr, __cl_size); &bslash;&n;__cl_size; })
DECL|macro|__strncpy_from_user
mdefine_line|#define __strncpy_from_user(dst,src,count,res) &bslash;&n;__asm__ __volatile__( &bslash;&n;&t;&quot;cld&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movl $3f,%0&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;incl %2&bslash;n&quot; &bslash;&n;&t;&quot;1:&bslash;tdecl %1&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;js 2f&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;lodsb&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;stosb&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;testb %%al,%%al&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;jne 1b&bslash;n&quot; &bslash;&n;&t;&quot;2:&bslash;t&quot; &bslash;&n;&t;&quot;incl %1&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;xorl %0,%0&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;decl %2&bslash;n&quot; &bslash;&n;&t;&quot;3:&quot; &bslash;&n;&t;:&quot;=&amp;d&quot; (res), &quot;=r&quot; (count) &bslash;&n;&t;:&quot;m&quot; (current-&gt;tss.ex), &quot;1&quot; (count), &quot;S&quot; (src),&quot;D&quot; (dst) &bslash;&n;&t;:&quot;si&quot;,&quot;di&quot;,&quot;ax&quot;,&quot;memory&quot;)
DECL|macro|strncpy_from_user
mdefine_line|#define strncpy_from_user(dest,src,count) ({ &bslash;&n;const void * __sc_src = (src); &bslash;&n;unsigned long __sc_count = (count); &bslash;&n;long __sc_res = -EFAULT; &bslash;&n;if (__access_ok(VERIFY_READ, ((unsigned long)(__sc_src)), __sc_count)) { &bslash;&n;&t;unsigned long __sc_residue = __sc_count; &bslash;&n;&t;__strncpy_from_user(dest,__sc_src,__sc_count,__sc_res); &bslash;&n;&t;if (!__sc_res) __sc_res = __sc_residue - __sc_count; &bslash;&n;} __sc_res; })
DECL|function|verify_area
r_extern
r_inline
r_int
id|verify_area
c_func
(paren
r_int
id|type
comma
r_const
r_void
op_star
id|addr
comma
r_int
r_int
id|size
)paren
(brace
r_return
id|access_ok
c_func
(paren
id|type
comma
id|addr
comma
id|size
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EFAULT
suffix:semicolon
)brace
macro_line|#endif /* __i386_UACCESS_H */
eof
