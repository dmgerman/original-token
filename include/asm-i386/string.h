macro_line|#ifndef _I386_STRING_H_
DECL|macro|_I386_STRING_H_
mdefine_line|#define _I386_STRING_H_
macro_line|#ifdef __KERNEL__
macro_line|#include &lt;linux/config.h&gt;
multiline_comment|/*&n; * On a 486 or Pentium, we are better off not using the&n; * byte string operations. But on a 386 or a PPro the&n; * byte string ops are faster than doing it by hand&n; * (MUCH faster on a Pentium).&n; *&n; * Also, the byte strings actually work correctly. Forget&n; * the i486 routines for now as they may be broken..&n; */
macro_line|#if FIXED_486_STRING &amp;&amp; defined(CONFIG_X86_USE_STRING_486)
macro_line|#include &lt;asm/string-486.h&gt;
macro_line|#else
multiline_comment|/*&n; * This string-include defines all string functions as inline&n; * functions. Use gcc. It also assumes ds=es=data space, this should be&n; * normal. Most of the string-functions are rather heavily hand-optimized,&n; * see especially strtok,strstr,str[c]spn. They should work, but are not&n; * very easy to understand. Everything is done entirely within the register&n; * set, making the functions fast and clean. String instructions have been&n; * used through-out, making for &quot;slightly&quot; unclear code :-)&n; *&n; *&t;&t;NO Copyright (C) 1991, 1992 Linus Torvalds,&n; *&t;&t;consider these trivial functions to be PD.&n; */
DECL|macro|__HAVE_ARCH_STRCPY
mdefine_line|#define __HAVE_ARCH_STRCPY
DECL|function|strcpy
r_static
r_inline
r_char
op_star
id|strcpy
c_func
(paren
r_char
op_star
id|dest
comma
r_const
r_char
op_star
id|src
)paren
(brace
r_int
id|d0
comma
id|d1
comma
id|d2
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&bslash;tlodsb&bslash;n&bslash;t&quot;
l_string|&quot;stosb&bslash;n&bslash;t&quot;
l_string|&quot;testb %%al,%%al&bslash;n&bslash;t&quot;
l_string|&quot;jne 1b&quot;
suffix:colon
l_string|&quot;=&amp;S&quot;
(paren
id|d0
)paren
comma
l_string|&quot;=&amp;D&quot;
(paren
id|d1
)paren
comma
l_string|&quot;=&amp;a&quot;
(paren
id|d2
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|src
)paren
comma
l_string|&quot;1&quot;
(paren
id|dest
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
DECL|macro|__HAVE_ARCH_STRNCPY
mdefine_line|#define __HAVE_ARCH_STRNCPY
DECL|function|strncpy
r_static
r_inline
r_char
op_star
id|strncpy
c_func
(paren
r_char
op_star
id|dest
comma
r_const
r_char
op_star
id|src
comma
r_int
id|count
)paren
(brace
r_int
id|d0
comma
id|d1
comma
id|d2
comma
id|d3
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&bslash;tdecl %2&bslash;n&bslash;t&quot;
l_string|&quot;js 2f&bslash;n&bslash;t&quot;
l_string|&quot;lodsb&bslash;n&bslash;t&quot;
l_string|&quot;stosb&bslash;n&bslash;t&quot;
l_string|&quot;testb %%al,%%al&bslash;n&bslash;t&quot;
l_string|&quot;jne 1b&bslash;n&bslash;t&quot;
l_string|&quot;rep&bslash;n&bslash;t&quot;
l_string|&quot;stosb&bslash;n&quot;
l_string|&quot;2:&quot;
suffix:colon
l_string|&quot;=&amp;S&quot;
(paren
id|d0
)paren
comma
l_string|&quot;=&amp;D&quot;
(paren
id|d1
)paren
comma
l_string|&quot;=&amp;c&quot;
(paren
id|d2
)paren
comma
l_string|&quot;=&amp;a&quot;
(paren
id|d3
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|src
)paren
comma
l_string|&quot;1&quot;
(paren
id|dest
)paren
comma
l_string|&quot;2&quot;
(paren
id|count
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
DECL|macro|__HAVE_ARCH_STRCAT
mdefine_line|#define __HAVE_ARCH_STRCAT
DECL|function|strcat
r_static
r_inline
r_char
op_star
id|strcat
c_func
(paren
r_char
op_star
id|dest
comma
r_const
r_char
op_star
id|src
)paren
(brace
r_int
id|d0
comma
id|d1
comma
id|d2
comma
id|d3
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;repne&bslash;n&bslash;t&quot;
l_string|&quot;scasb&bslash;n&bslash;t&quot;
l_string|&quot;decl %1&bslash;n&quot;
l_string|&quot;1:&bslash;tlodsb&bslash;n&bslash;t&quot;
l_string|&quot;stosb&bslash;n&bslash;t&quot;
l_string|&quot;testb %%al,%%al&bslash;n&bslash;t&quot;
l_string|&quot;jne 1b&quot;
suffix:colon
l_string|&quot;=&amp;S&quot;
(paren
id|d0
)paren
comma
l_string|&quot;=&amp;D&quot;
(paren
id|d1
)paren
comma
l_string|&quot;=&amp;a&quot;
(paren
id|d2
)paren
comma
l_string|&quot;=&amp;c&quot;
(paren
id|d3
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|src
)paren
comma
l_string|&quot;1&quot;
(paren
id|dest
)paren
comma
l_string|&quot;2&quot;
(paren
l_int|0
)paren
comma
l_string|&quot;3&quot;
(paren
l_int|0xffffffff
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
DECL|macro|__HAVE_ARCH_STRNCAT
mdefine_line|#define __HAVE_ARCH_STRNCAT
DECL|function|strncat
r_static
r_inline
r_char
op_star
id|strncat
c_func
(paren
r_char
op_star
id|dest
comma
r_const
r_char
op_star
id|src
comma
r_int
id|count
)paren
(brace
r_int
id|d0
comma
id|d1
comma
id|d2
comma
id|d3
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;repne&bslash;n&bslash;t&quot;
l_string|&quot;scasb&bslash;n&bslash;t&quot;
l_string|&quot;decl %1&bslash;n&bslash;t&quot;
l_string|&quot;movl %8,%3&bslash;n&quot;
l_string|&quot;1:&bslash;tdecl %3&bslash;n&bslash;t&quot;
l_string|&quot;js 2f&bslash;n&bslash;t&quot;
l_string|&quot;lodsb&bslash;n&bslash;t&quot;
l_string|&quot;stosb&bslash;n&bslash;t&quot;
l_string|&quot;testb %%al,%%al&bslash;n&bslash;t&quot;
l_string|&quot;jne 1b&bslash;n&quot;
l_string|&quot;2:&bslash;txorl %2,%2&bslash;n&bslash;t&quot;
l_string|&quot;stosb&quot;
suffix:colon
l_string|&quot;=&amp;S&quot;
(paren
id|d0
)paren
comma
l_string|&quot;=&amp;D&quot;
(paren
id|d1
)paren
comma
l_string|&quot;=&amp;a&quot;
(paren
id|d2
)paren
comma
l_string|&quot;=&amp;c&quot;
(paren
id|d3
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|src
)paren
comma
l_string|&quot;1&quot;
(paren
id|dest
)paren
comma
l_string|&quot;2&quot;
(paren
l_int|0
)paren
comma
l_string|&quot;3&quot;
(paren
l_int|0xffffffff
)paren
comma
l_string|&quot;g&quot;
(paren
id|count
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
DECL|macro|__HAVE_ARCH_STRCMP
mdefine_line|#define __HAVE_ARCH_STRCMP
DECL|function|strcmp
r_static
r_inline
r_int
id|strcmp
c_func
(paren
r_const
r_char
op_star
id|cs
comma
r_const
r_char
op_star
id|ct
)paren
(brace
r_int
id|d0
comma
id|d1
suffix:semicolon
r_register
r_int
id|__res
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&bslash;tlodsb&bslash;n&bslash;t&quot;
l_string|&quot;scasb&bslash;n&bslash;t&quot;
l_string|&quot;jne 2f&bslash;n&bslash;t&quot;
l_string|&quot;testb %%al,%%al&bslash;n&bslash;t&quot;
l_string|&quot;jne 1b&bslash;n&bslash;t&quot;
l_string|&quot;xorl %%eax,%%eax&bslash;n&bslash;t&quot;
l_string|&quot;jmp 3f&bslash;n&quot;
l_string|&quot;2:&bslash;tsbbl %%eax,%%eax&bslash;n&bslash;t&quot;
l_string|&quot;orb $1,%%al&bslash;n&quot;
l_string|&quot;3:&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|__res
)paren
comma
l_string|&quot;=&amp;S&quot;
(paren
id|d0
)paren
comma
l_string|&quot;=&amp;D&quot;
(paren
id|d1
)paren
suffix:colon
l_string|&quot;1&quot;
(paren
id|cs
)paren
comma
l_string|&quot;2&quot;
(paren
id|ct
)paren
)paren
suffix:semicolon
r_return
id|__res
suffix:semicolon
)brace
DECL|macro|__HAVE_ARCH_STRNCMP
mdefine_line|#define __HAVE_ARCH_STRNCMP
DECL|function|strncmp
r_static
r_inline
r_int
id|strncmp
c_func
(paren
r_const
r_char
op_star
id|cs
comma
r_const
r_char
op_star
id|ct
comma
r_int
id|count
)paren
(brace
r_register
r_int
id|__res
suffix:semicolon
r_int
id|d0
comma
id|d1
comma
id|d2
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&bslash;tdecl %3&bslash;n&bslash;t&quot;
l_string|&quot;js 2f&bslash;n&bslash;t&quot;
l_string|&quot;lodsb&bslash;n&bslash;t&quot;
l_string|&quot;scasb&bslash;n&bslash;t&quot;
l_string|&quot;jne 3f&bslash;n&bslash;t&quot;
l_string|&quot;testb %%al,%%al&bslash;n&bslash;t&quot;
l_string|&quot;jne 1b&bslash;n&quot;
l_string|&quot;2:&bslash;txorl %%eax,%%eax&bslash;n&bslash;t&quot;
l_string|&quot;jmp 4f&bslash;n&quot;
l_string|&quot;3:&bslash;tsbbl %%eax,%%eax&bslash;n&bslash;t&quot;
l_string|&quot;orb $1,%%al&bslash;n&quot;
l_string|&quot;4:&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|__res
)paren
comma
l_string|&quot;=&amp;S&quot;
(paren
id|d0
)paren
comma
l_string|&quot;=&amp;D&quot;
(paren
id|d1
)paren
comma
l_string|&quot;=&amp;c&quot;
(paren
id|d2
)paren
suffix:colon
l_string|&quot;1&quot;
(paren
id|cs
)paren
comma
l_string|&quot;2&quot;
(paren
id|ct
)paren
comma
l_string|&quot;3&quot;
(paren
id|count
)paren
)paren
suffix:semicolon
r_return
id|__res
suffix:semicolon
)brace
DECL|macro|__HAVE_ARCH_STRCHR
mdefine_line|#define __HAVE_ARCH_STRCHR
DECL|function|strchr
r_static
r_inline
r_char
op_star
id|strchr
c_func
(paren
r_const
r_char
op_star
id|s
comma
r_int
id|c
)paren
(brace
r_int
id|d0
suffix:semicolon
r_register
r_char
op_star
id|__res
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;movb %%al,%%ah&bslash;n&quot;
l_string|&quot;1:&bslash;tlodsb&bslash;n&bslash;t&quot;
l_string|&quot;cmpb %%ah,%%al&bslash;n&bslash;t&quot;
l_string|&quot;je 2f&bslash;n&bslash;t&quot;
l_string|&quot;testb %%al,%%al&bslash;n&bslash;t&quot;
l_string|&quot;jne 1b&bslash;n&bslash;t&quot;
l_string|&quot;movl $1,%1&bslash;n&quot;
l_string|&quot;2:&bslash;tmovl %1,%0&bslash;n&bslash;t&quot;
l_string|&quot;decl %0&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|__res
)paren
comma
l_string|&quot;=&amp;S&quot;
(paren
id|d0
)paren
suffix:colon
l_string|&quot;1&quot;
(paren
id|s
)paren
comma
l_string|&quot;0&quot;
(paren
id|c
)paren
)paren
suffix:semicolon
r_return
id|__res
suffix:semicolon
)brace
DECL|macro|__HAVE_ARCH_STRRCHR
mdefine_line|#define __HAVE_ARCH_STRRCHR
DECL|function|strrchr
r_static
r_inline
r_char
op_star
id|strrchr
c_func
(paren
r_const
r_char
op_star
id|s
comma
r_int
id|c
)paren
(brace
r_int
id|d0
comma
id|d1
suffix:semicolon
r_register
r_char
op_star
id|__res
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;movb %%al,%%ah&bslash;n&quot;
l_string|&quot;1:&bslash;tlodsb&bslash;n&bslash;t&quot;
l_string|&quot;cmpb %%ah,%%al&bslash;n&bslash;t&quot;
l_string|&quot;jne 2f&bslash;n&bslash;t&quot;
l_string|&quot;leal -1(%%esi),%0&bslash;n&quot;
l_string|&quot;2:&bslash;ttestb %%al,%%al&bslash;n&bslash;t&quot;
l_string|&quot;jne 1b&quot;
suffix:colon
l_string|&quot;=g&quot;
(paren
id|__res
)paren
comma
l_string|&quot;=&amp;S&quot;
(paren
id|d0
)paren
comma
l_string|&quot;=&amp;a&quot;
(paren
id|d1
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
l_int|0
)paren
comma
l_string|&quot;1&quot;
(paren
id|s
)paren
comma
l_string|&quot;2&quot;
(paren
id|c
)paren
)paren
suffix:semicolon
r_return
id|__res
suffix:semicolon
)brace
DECL|macro|__HAVE_ARCH_STRLEN
mdefine_line|#define __HAVE_ARCH_STRLEN
DECL|function|strlen
r_static
r_inline
r_int
id|strlen
c_func
(paren
r_const
r_char
op_star
id|s
)paren
(brace
r_int
id|d0
suffix:semicolon
r_register
r_int
id|__res
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;repne&bslash;n&bslash;t&quot;
l_string|&quot;scasb&bslash;n&bslash;t&quot;
l_string|&quot;notl %0&bslash;n&bslash;t&quot;
l_string|&quot;decl %0&quot;
suffix:colon
l_string|&quot;=c&quot;
(paren
id|__res
)paren
comma
l_string|&quot;=&amp;D&quot;
(paren
id|d0
)paren
suffix:colon
l_string|&quot;1&quot;
(paren
id|s
)paren
comma
l_string|&quot;a&quot;
(paren
l_int|0
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0xffffffff
)paren
)paren
suffix:semicolon
r_return
id|__res
suffix:semicolon
)brace
DECL|function|__memcpy
r_static
r_inline
r_void
op_star
id|__memcpy
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
id|n
)paren
(brace
r_int
id|d0
comma
id|d1
comma
id|d2
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rep ; movsl&bslash;n&bslash;t&quot;
l_string|&quot;testb $2,%b4&bslash;n&bslash;t&quot;
l_string|&quot;je 1f&bslash;n&bslash;t&quot;
l_string|&quot;movsw&bslash;n&quot;
l_string|&quot;1:&bslash;ttestb $1,%b4&bslash;n&bslash;t&quot;
l_string|&quot;je 2f&bslash;n&bslash;t&quot;
l_string|&quot;movsb&bslash;n&quot;
l_string|&quot;2:&quot;
suffix:colon
l_string|&quot;=&amp;c&quot;
(paren
id|d0
)paren
comma
l_string|&quot;=&amp;D&quot;
(paren
id|d1
)paren
comma
l_string|&quot;=&amp;S&quot;
(paren
id|d2
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|n
op_div
l_int|4
)paren
comma
l_string|&quot;q&quot;
(paren
id|n
)paren
comma
l_string|&quot;1&quot;
(paren
(paren
r_int
)paren
id|to
)paren
comma
l_string|&quot;2&quot;
(paren
(paren
r_int
)paren
id|from
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
(paren
id|to
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This looks horribly ugly, but the compiler can optimize it totally,&n; * as the count is constant.&n; */
DECL|function|__constant_memcpy
r_static
r_inline
r_void
op_star
id|__constant_memcpy
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
id|n
)paren
(brace
r_switch
c_cond
(paren
id|n
)paren
(brace
r_case
l_int|0
suffix:colon
r_return
id|to
suffix:semicolon
r_case
l_int|1
suffix:colon
op_star
(paren
r_int
r_char
op_star
)paren
id|to
op_assign
op_star
(paren
r_const
r_int
r_char
op_star
)paren
id|from
suffix:semicolon
r_return
id|to
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
(paren
r_int
r_int
op_star
)paren
id|to
op_assign
op_star
(paren
r_const
r_int
r_int
op_star
)paren
id|from
suffix:semicolon
r_return
id|to
suffix:semicolon
r_case
l_int|3
suffix:colon
op_star
(paren
r_int
r_int
op_star
)paren
id|to
op_assign
op_star
(paren
r_const
r_int
r_int
op_star
)paren
id|from
suffix:semicolon
op_star
(paren
l_int|2
op_plus
(paren
r_int
r_char
op_star
)paren
id|to
)paren
op_assign
op_star
(paren
l_int|2
op_plus
(paren
r_const
r_int
r_char
op_star
)paren
id|from
)paren
suffix:semicolon
r_return
id|to
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
(paren
r_int
r_int
op_star
)paren
id|to
op_assign
op_star
(paren
r_const
r_int
r_int
op_star
)paren
id|from
suffix:semicolon
r_return
id|to
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* for Ethernet addresses */
op_star
(paren
r_int
r_int
op_star
)paren
id|to
op_assign
op_star
(paren
r_const
r_int
r_int
op_star
)paren
id|from
suffix:semicolon
op_star
(paren
l_int|2
op_plus
(paren
r_int
r_int
op_star
)paren
id|to
)paren
op_assign
op_star
(paren
l_int|2
op_plus
(paren
r_const
r_int
r_int
op_star
)paren
id|from
)paren
suffix:semicolon
r_return
id|to
suffix:semicolon
r_case
l_int|8
suffix:colon
op_star
(paren
r_int
r_int
op_star
)paren
id|to
op_assign
op_star
(paren
r_const
r_int
r_int
op_star
)paren
id|from
suffix:semicolon
op_star
(paren
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|to
)paren
op_assign
op_star
(paren
l_int|1
op_plus
(paren
r_const
r_int
r_int
op_star
)paren
id|from
)paren
suffix:semicolon
r_return
id|to
suffix:semicolon
r_case
l_int|12
suffix:colon
op_star
(paren
r_int
r_int
op_star
)paren
id|to
op_assign
op_star
(paren
r_const
r_int
r_int
op_star
)paren
id|from
suffix:semicolon
op_star
(paren
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|to
)paren
op_assign
op_star
(paren
l_int|1
op_plus
(paren
r_const
r_int
r_int
op_star
)paren
id|from
)paren
suffix:semicolon
op_star
(paren
l_int|2
op_plus
(paren
r_int
r_int
op_star
)paren
id|to
)paren
op_assign
op_star
(paren
l_int|2
op_plus
(paren
r_const
r_int
r_int
op_star
)paren
id|from
)paren
suffix:semicolon
r_return
id|to
suffix:semicolon
r_case
l_int|16
suffix:colon
op_star
(paren
r_int
r_int
op_star
)paren
id|to
op_assign
op_star
(paren
r_const
r_int
r_int
op_star
)paren
id|from
suffix:semicolon
op_star
(paren
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|to
)paren
op_assign
op_star
(paren
l_int|1
op_plus
(paren
r_const
r_int
r_int
op_star
)paren
id|from
)paren
suffix:semicolon
op_star
(paren
l_int|2
op_plus
(paren
r_int
r_int
op_star
)paren
id|to
)paren
op_assign
op_star
(paren
l_int|2
op_plus
(paren
r_const
r_int
r_int
op_star
)paren
id|from
)paren
suffix:semicolon
op_star
(paren
l_int|3
op_plus
(paren
r_int
r_int
op_star
)paren
id|to
)paren
op_assign
op_star
(paren
l_int|3
op_plus
(paren
r_const
r_int
r_int
op_star
)paren
id|from
)paren
suffix:semicolon
r_return
id|to
suffix:semicolon
r_case
l_int|20
suffix:colon
op_star
(paren
r_int
r_int
op_star
)paren
id|to
op_assign
op_star
(paren
r_const
r_int
r_int
op_star
)paren
id|from
suffix:semicolon
op_star
(paren
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|to
)paren
op_assign
op_star
(paren
l_int|1
op_plus
(paren
r_const
r_int
r_int
op_star
)paren
id|from
)paren
suffix:semicolon
op_star
(paren
l_int|2
op_plus
(paren
r_int
r_int
op_star
)paren
id|to
)paren
op_assign
op_star
(paren
l_int|2
op_plus
(paren
r_const
r_int
r_int
op_star
)paren
id|from
)paren
suffix:semicolon
op_star
(paren
l_int|3
op_plus
(paren
r_int
r_int
op_star
)paren
id|to
)paren
op_assign
op_star
(paren
l_int|3
op_plus
(paren
r_const
r_int
r_int
op_star
)paren
id|from
)paren
suffix:semicolon
op_star
(paren
l_int|4
op_plus
(paren
r_int
r_int
op_star
)paren
id|to
)paren
op_assign
op_star
(paren
l_int|4
op_plus
(paren
r_const
r_int
r_int
op_star
)paren
id|from
)paren
suffix:semicolon
r_return
id|to
suffix:semicolon
)brace
DECL|macro|COMMON
mdefine_line|#define COMMON(x) &bslash;&n;__asm__ __volatile__( &bslash;&n;&t;&quot;rep ; movsl&quot; &bslash;&n;&t;x &bslash;&n;&t;: &quot;=&amp;c&quot; (d0), &quot;=&amp;D&quot; (d1), &quot;=&amp;S&quot; (d2) &bslash;&n;&t;: &quot;0&quot; (n/4),&quot;1&quot; ((long) to),&quot;2&quot; ((long) from) &bslash;&n;&t;: &quot;memory&quot;);
(brace
r_int
id|d0
comma
id|d1
comma
id|d2
suffix:semicolon
r_switch
c_cond
(paren
id|n
op_mod
l_int|4
)paren
(brace
r_case
l_int|0
suffix:colon
id|COMMON
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
id|to
suffix:semicolon
r_case
l_int|1
suffix:colon
id|COMMON
c_func
(paren
l_string|&quot;&bslash;n&bslash;tmovsb&quot;
)paren
suffix:semicolon
r_return
id|to
suffix:semicolon
r_case
l_int|2
suffix:colon
id|COMMON
c_func
(paren
l_string|&quot;&bslash;n&bslash;tmovsw&quot;
)paren
suffix:semicolon
r_return
id|to
suffix:semicolon
r_default
suffix:colon
id|COMMON
c_func
(paren
l_string|&quot;&bslash;n&bslash;tmovsw&bslash;n&bslash;tmovsb&quot;
)paren
suffix:semicolon
r_return
id|to
suffix:semicolon
)brace
)brace
DECL|macro|COMMON
macro_line|#undef COMMON
)brace
DECL|macro|__HAVE_ARCH_MEMCPY
mdefine_line|#define __HAVE_ARCH_MEMCPY
macro_line|#ifdef CONFIG_X86_USE_3DNOW
multiline_comment|/* All this just for in_interrupt() ... */
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/ptrace.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/mmx.h&gt;
multiline_comment|/*&n; *&t;This CPU favours 3DNow strongly (eg AMD Athlon)&n; */
DECL|function|__constant_memcpy3d
r_static
r_inline
r_void
op_star
id|__constant_memcpy3d
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
OL
l_int|512
op_logical_or
id|in_interrupt
c_func
(paren
)paren
)paren
(brace
r_return
id|__constant_memcpy
c_func
(paren
id|to
comma
id|from
comma
id|len
)paren
suffix:semicolon
)brace
r_return
id|_mmx_memcpy
c_func
(paren
id|to
comma
id|from
comma
id|len
)paren
suffix:semicolon
)brace
DECL|function|__memcpy3d
r_extern
id|__inline__
r_void
op_star
id|__memcpy3d
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
id|len
)paren
(brace
r_if
c_cond
(paren
id|len
OL
l_int|512
op_logical_or
id|in_interrupt
c_func
(paren
)paren
)paren
(brace
r_return
id|__memcpy
c_func
(paren
id|to
comma
id|from
comma
id|len
)paren
suffix:semicolon
)brace
r_return
id|_mmx_memcpy
c_func
(paren
id|to
comma
id|from
comma
id|len
)paren
suffix:semicolon
)brace
DECL|macro|memcpy
mdefine_line|#define memcpy(t, f, n) &bslash;&n;(__builtin_constant_p(n) ? &bslash;&n; __constant_memcpy3d((t),(f),(n)) : &bslash;&n; __memcpy3d((t),(f),(n)))
macro_line|#else
multiline_comment|/*&n; *&t;No 3D Now!&n; */
DECL|macro|memcpy
mdefine_line|#define memcpy(t, f, n) &bslash;&n;(__builtin_constant_p(n) ? &bslash;&n; __constant_memcpy((t),(f),(n)) : &bslash;&n; __memcpy((t),(f),(n)))
macro_line|#endif
multiline_comment|/*&n; * struct_cpy(x,y), copy structure *x into (matching structure) *y.&n; *&n; * We get link-time errors if the structure sizes do not match.&n; * There is no runtime overhead, it&squot;s all optimized away at&n; * compile time.&n; */
r_extern
r_void
id|__struct_cpy_bug
(paren
r_void
)paren
suffix:semicolon
DECL|macro|struct_cpy
mdefine_line|#define struct_cpy(x,y) &t;&t;&t;&bslash;&n;({&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (sizeof(*(x)) != sizeof(*(y))) &t;&bslash;&n;&t;&t;__struct_cpy_bug;&t;&t;&bslash;&n;&t;memcpy(x, y, sizeof(*(x)));&t;&t;&bslash;&n;})
DECL|macro|__HAVE_ARCH_MEMMOVE
mdefine_line|#define __HAVE_ARCH_MEMMOVE
DECL|function|memmove
r_static
r_inline
r_void
op_star
id|memmove
c_func
(paren
r_void
op_star
id|dest
comma
r_const
r_void
op_star
id|src
comma
r_int
id|n
)paren
(brace
r_int
id|d0
comma
id|d1
comma
id|d2
suffix:semicolon
r_if
c_cond
(paren
id|dest
OL
id|src
)paren
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rep&bslash;n&bslash;t&quot;
l_string|&quot;movsb&quot;
suffix:colon
l_string|&quot;=&amp;c&quot;
(paren
id|d0
)paren
comma
l_string|&quot;=&amp;S&quot;
(paren
id|d1
)paren
comma
l_string|&quot;=&amp;D&quot;
(paren
id|d2
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|n
)paren
comma
l_string|&quot;1&quot;
(paren
id|src
)paren
comma
l_string|&quot;2&quot;
(paren
id|dest
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_else
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;std&bslash;n&bslash;t&quot;
l_string|&quot;rep&bslash;n&bslash;t&quot;
l_string|&quot;movsb&bslash;n&bslash;t&quot;
l_string|&quot;cld&quot;
suffix:colon
l_string|&quot;=&amp;c&quot;
(paren
id|d0
)paren
comma
l_string|&quot;=&amp;S&quot;
(paren
id|d1
)paren
comma
l_string|&quot;=&amp;D&quot;
(paren
id|d2
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|n
)paren
comma
l_string|&quot;1&quot;
(paren
id|n
op_minus
l_int|1
op_plus
(paren
r_const
r_char
op_star
)paren
id|src
)paren
comma
l_string|&quot;2&quot;
(paren
id|n
op_minus
l_int|1
op_plus
(paren
r_char
op_star
)paren
id|dest
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
DECL|macro|memcmp
mdefine_line|#define memcmp __builtin_memcmp
DECL|macro|__HAVE_ARCH_MEMCHR
mdefine_line|#define __HAVE_ARCH_MEMCHR
DECL|function|memchr
r_static
r_inline
r_void
op_star
id|memchr
c_func
(paren
r_const
r_void
op_star
id|cs
comma
r_int
id|c
comma
r_int
id|count
)paren
(brace
r_int
id|d0
suffix:semicolon
r_register
r_void
op_star
id|__res
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
r_return
l_int|NULL
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;repne&bslash;n&bslash;t&quot;
l_string|&quot;scasb&bslash;n&bslash;t&quot;
l_string|&quot;je 1f&bslash;n&bslash;t&quot;
l_string|&quot;movl $1,%0&bslash;n&quot;
l_string|&quot;1:&bslash;tdecl %0&quot;
suffix:colon
l_string|&quot;=D&quot;
(paren
id|__res
)paren
comma
l_string|&quot;=&amp;c&quot;
(paren
id|d0
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
id|c
)paren
comma
l_string|&quot;0&quot;
(paren
id|cs
)paren
comma
l_string|&quot;1&quot;
(paren
id|count
)paren
)paren
suffix:semicolon
r_return
id|__res
suffix:semicolon
)brace
DECL|function|__memset_generic
r_static
r_inline
r_void
op_star
id|__memset_generic
c_func
(paren
r_void
op_star
id|s
comma
r_char
id|c
comma
r_int
id|count
)paren
(brace
r_int
id|d0
comma
id|d1
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rep&bslash;n&bslash;t&quot;
l_string|&quot;stosb&quot;
suffix:colon
l_string|&quot;=&amp;c&quot;
(paren
id|d0
)paren
comma
l_string|&quot;=&amp;D&quot;
(paren
id|d1
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
id|c
)paren
comma
l_string|&quot;1&quot;
(paren
id|s
)paren
comma
l_string|&quot;0&quot;
(paren
id|count
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|s
suffix:semicolon
)brace
multiline_comment|/* we might want to write optimized versions of these later */
DECL|macro|__constant_count_memset
mdefine_line|#define __constant_count_memset(s,c,count) __memset_generic((s),(c),(count))
multiline_comment|/*&n; * memset(x,0,y) is a reasonably common thing to do, so we want to fill&n; * things 32 bits at a time even when we don&squot;t know the size of the&n; * area at compile-time..&n; */
DECL|function|__constant_c_memset
r_static
r_inline
r_void
op_star
id|__constant_c_memset
c_func
(paren
r_void
op_star
id|s
comma
r_int
r_int
id|c
comma
r_int
id|count
)paren
(brace
r_int
id|d0
comma
id|d1
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;rep ; stosl&bslash;n&bslash;t&quot;
l_string|&quot;testb $2,%b3&bslash;n&bslash;t&quot;
l_string|&quot;je 1f&bslash;n&bslash;t&quot;
l_string|&quot;stosw&bslash;n&quot;
l_string|&quot;1:&bslash;ttestb $1,%b3&bslash;n&bslash;t&quot;
l_string|&quot;je 2f&bslash;n&bslash;t&quot;
l_string|&quot;stosb&bslash;n&quot;
l_string|&quot;2:&quot;
suffix:colon
l_string|&quot;=&amp;c&quot;
(paren
id|d0
)paren
comma
l_string|&quot;=&amp;D&quot;
(paren
id|d1
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
id|c
)paren
comma
l_string|&quot;q&quot;
(paren
id|count
)paren
comma
l_string|&quot;0&quot;
(paren
id|count
op_div
l_int|4
)paren
comma
l_string|&quot;1&quot;
(paren
(paren
r_int
)paren
id|s
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
(paren
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/* Added by Gertjan van Wingerde to make minix and sysv module work */
DECL|macro|__HAVE_ARCH_STRNLEN
mdefine_line|#define __HAVE_ARCH_STRNLEN
DECL|function|strnlen
r_static
r_inline
r_int
id|strnlen
c_func
(paren
r_const
r_char
op_star
id|s
comma
r_int
id|count
)paren
(brace
r_int
id|d0
suffix:semicolon
r_register
r_int
id|__res
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;movl %2,%0&bslash;n&bslash;t&quot;
l_string|&quot;jmp 2f&bslash;n&quot;
l_string|&quot;1:&bslash;tcmpb $0,(%0)&bslash;n&bslash;t&quot;
l_string|&quot;je 3f&bslash;n&bslash;t&quot;
l_string|&quot;incl %0&bslash;n&quot;
l_string|&quot;2:&bslash;tdecl %1&bslash;n&bslash;t&quot;
l_string|&quot;cmpl $-1,%1&bslash;n&bslash;t&quot;
l_string|&quot;jne 1b&bslash;n&quot;
l_string|&quot;3:&bslash;tsubl %2,%0&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|__res
)paren
comma
l_string|&quot;=&amp;d&quot;
(paren
id|d0
)paren
suffix:colon
l_string|&quot;c&quot;
(paren
id|s
)paren
comma
l_string|&quot;1&quot;
(paren
id|count
)paren
)paren
suffix:semicolon
r_return
id|__res
suffix:semicolon
)brace
multiline_comment|/* end of additional stuff */
DECL|macro|__HAVE_ARCH_STRSTR
mdefine_line|#define __HAVE_ARCH_STRSTR
DECL|function|strstr
r_static
r_inline
r_char
op_star
id|strstr
c_func
(paren
r_const
r_char
op_star
id|cs
comma
r_const
r_char
op_star
id|ct
)paren
(brace
r_int
id|d0
comma
id|d1
suffix:semicolon
r_register
r_char
op_star
id|__res
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;movl %6,%%edi&bslash;n&bslash;t&quot;
l_string|&quot;repne&bslash;n&bslash;t&quot;
l_string|&quot;scasb&bslash;n&bslash;t&quot;
l_string|&quot;notl %%ecx&bslash;n&bslash;t&quot;
l_string|&quot;decl %%ecx&bslash;n&bslash;t&quot;
multiline_comment|/* NOTE! This also sets Z if searchstring=&squot;&squot; */
l_string|&quot;movl %%ecx,%%edx&bslash;n&quot;
l_string|&quot;1:&bslash;tmovl %6,%%edi&bslash;n&bslash;t&quot;
l_string|&quot;movl %%esi,%%eax&bslash;n&bslash;t&quot;
l_string|&quot;movl %%edx,%%ecx&bslash;n&bslash;t&quot;
l_string|&quot;repe&bslash;n&bslash;t&quot;
l_string|&quot;cmpsb&bslash;n&bslash;t&quot;
l_string|&quot;je 2f&bslash;n&bslash;t&quot;
multiline_comment|/* also works for empty string, see above */
l_string|&quot;xchgl %%eax,%%esi&bslash;n&bslash;t&quot;
l_string|&quot;incl %%esi&bslash;n&bslash;t&quot;
l_string|&quot;cmpb $0,-1(%%eax)&bslash;n&bslash;t&quot;
l_string|&quot;jne 1b&bslash;n&bslash;t&quot;
l_string|&quot;xorl %%eax,%%eax&bslash;n&bslash;t&quot;
l_string|&quot;2:&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|__res
)paren
comma
l_string|&quot;=&amp;c&quot;
(paren
id|d0
)paren
comma
l_string|&quot;=&amp;S&quot;
(paren
id|d1
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
l_int|0
)paren
comma
l_string|&quot;1&quot;
(paren
l_int|0xffffffff
)paren
comma
l_string|&quot;2&quot;
(paren
id|cs
)paren
comma
l_string|&quot;g&quot;
(paren
id|ct
)paren
suffix:colon
l_string|&quot;dx&quot;
comma
l_string|&quot;di&quot;
)paren
suffix:semicolon
r_return
id|__res
suffix:semicolon
)brace
multiline_comment|/*&n; * This looks horribly ugly, but the compiler can optimize it totally,&n; * as we by now know that both pattern and count is constant..&n; */
DECL|function|__constant_c_and_count_memset
r_static
r_inline
r_void
op_star
id|__constant_c_and_count_memset
c_func
(paren
r_void
op_star
id|s
comma
r_int
r_int
id|pattern
comma
r_int
id|count
)paren
(brace
r_switch
c_cond
(paren
id|count
)paren
(brace
r_case
l_int|0
suffix:colon
r_return
id|s
suffix:semicolon
r_case
l_int|1
suffix:colon
op_star
(paren
r_int
r_char
op_star
)paren
id|s
op_assign
id|pattern
suffix:semicolon
r_return
id|s
suffix:semicolon
r_case
l_int|2
suffix:colon
op_star
(paren
r_int
r_int
op_star
)paren
id|s
op_assign
id|pattern
suffix:semicolon
r_return
id|s
suffix:semicolon
r_case
l_int|3
suffix:colon
op_star
(paren
r_int
r_int
op_star
)paren
id|s
op_assign
id|pattern
suffix:semicolon
op_star
(paren
l_int|2
op_plus
(paren
r_int
r_char
op_star
)paren
id|s
)paren
op_assign
id|pattern
suffix:semicolon
r_return
id|s
suffix:semicolon
r_case
l_int|4
suffix:colon
op_star
(paren
r_int
r_int
op_star
)paren
id|s
op_assign
id|pattern
suffix:semicolon
r_return
id|s
suffix:semicolon
)brace
DECL|macro|COMMON
mdefine_line|#define COMMON(x) &bslash;&n;__asm__  __volatile__( &bslash;&n;&t;&quot;rep ; stosl&quot; &bslash;&n;&t;x &bslash;&n;&t;: &quot;=&amp;c&quot; (d0), &quot;=&amp;D&quot; (d1) &bslash;&n;&t;: &quot;a&quot; (pattern),&quot;0&quot; (count/4),&quot;1&quot; ((long) s) &bslash;&n;&t;: &quot;memory&quot;)
(brace
r_int
id|d0
comma
id|d1
suffix:semicolon
r_switch
c_cond
(paren
id|count
op_mod
l_int|4
)paren
(brace
r_case
l_int|0
suffix:colon
id|COMMON
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
r_return
id|s
suffix:semicolon
r_case
l_int|1
suffix:colon
id|COMMON
c_func
(paren
l_string|&quot;&bslash;n&bslash;tstosb&quot;
)paren
suffix:semicolon
r_return
id|s
suffix:semicolon
r_case
l_int|2
suffix:colon
id|COMMON
c_func
(paren
l_string|&quot;&bslash;n&bslash;tstosw&quot;
)paren
suffix:semicolon
r_return
id|s
suffix:semicolon
r_default
suffix:colon
id|COMMON
c_func
(paren
l_string|&quot;&bslash;n&bslash;tstosw&bslash;n&bslash;tstosb&quot;
)paren
suffix:semicolon
r_return
id|s
suffix:semicolon
)brace
)brace
DECL|macro|COMMON
macro_line|#undef COMMON
)brace
DECL|macro|__constant_c_x_memset
mdefine_line|#define __constant_c_x_memset(s, c, count) &bslash;&n;(__builtin_constant_p(count) ? &bslash;&n; __constant_c_and_count_memset((s),(c),(count)) : &bslash;&n; __constant_c_memset((s),(c),(count)))
DECL|macro|__memset
mdefine_line|#define __memset(s, c, count) &bslash;&n;(__builtin_constant_p(count) ? &bslash;&n; __constant_count_memset((s),(c),(count)) : &bslash;&n; __memset_generic((s),(c),(count)))
DECL|macro|__HAVE_ARCH_MEMSET
mdefine_line|#define __HAVE_ARCH_MEMSET
DECL|macro|memset
mdefine_line|#define memset(s, c, count) &bslash;&n;(__builtin_constant_p(c) ? &bslash;&n; __constant_c_x_memset((s),(0x01010101UL*(unsigned char)(c)),(count)) : &bslash;&n; __memset((s),(c),(count)))
multiline_comment|/*&n; * find the first occurrence of byte &squot;c&squot;, or 1 past the area if none&n; */
DECL|macro|__HAVE_ARCH_MEMSCAN
mdefine_line|#define __HAVE_ARCH_MEMSCAN
DECL|function|memscan
r_static
r_inline
r_void
op_star
id|memscan
c_func
(paren
r_void
op_star
id|addr
comma
r_int
id|c
comma
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
r_return
id|addr
suffix:semicolon
id|__asm__
c_func
(paren
"&quot;"
id|repnz
suffix:semicolon
id|scasb
id|jnz
l_float|1f
id|dec
op_mod
op_mod
id|edi
l_int|1
suffix:colon
"&quot;"
suffix:colon
l_string|&quot;=D&quot;
(paren
id|addr
)paren
comma
l_string|&quot;=c&quot;
(paren
id|size
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|addr
)paren
comma
l_string|&quot;1&quot;
(paren
id|size
)paren
comma
l_string|&quot;a&quot;
(paren
id|c
)paren
)paren
suffix:semicolon
r_return
id|addr
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_X86_USE_STRING_486 */
macro_line|#endif /* __KERNEL__ */
macro_line|#endif
eof
