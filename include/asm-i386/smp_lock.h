macro_line|#ifndef __I386_SMPLOCK_H
DECL|macro|__I386_SMPLOCK_H
mdefine_line|#define __I386_SMPLOCK_H
macro_line|#ifndef __SMP__
DECL|macro|lock_kernel
mdefine_line|#define lock_kernel()&t;&t;do { } while(0)
DECL|macro|unlock_kernel
mdefine_line|#define unlock_kernel()&t;&t;do { } while(0)
DECL|typedef|spinlock_t
r_typedef
r_struct
(brace
)brace
id|spinlock_t
suffix:semicolon
DECL|macro|SPIN_LOCK_UNLOCKED
mdefine_line|#define SPIN_LOCK_UNLOCKED
DECL|macro|spin_lock_init
mdefine_line|#define spin_lock_init(lock)&t;do { } while(0)
DECL|macro|spin_lock
mdefine_line|#define spin_lock(lock)&t;&t;do { } while(0)
DECL|macro|spin_trylock
mdefine_line|#define spin_trylock(lock)&t;do { } while(0)
DECL|macro|spin_unlock
mdefine_line|#define spin_unlock(lock)&t;do { } while(0)
DECL|macro|spin_lock_cli
mdefine_line|#define spin_lock_cli(lock)&t;&t;&bslash;&n;({&t;unsigned long flags;&t;&t;&bslash;&n;&t;save_flags(flags); cli();&t;&bslash;&n;&t;return flags;&t;&t;&t;&bslash;&n;})
DECL|macro|spin_unlock_restore
mdefine_line|#define spin_unlock_restore(lock, flags)&t;restore_flags(flags)
macro_line|#else
macro_line|#include &lt;asm/pgtable.h&gt;
multiline_comment|/* Locking the kernel */
DECL|function|lock_kernel
r_extern
id|__inline__
r_void
id|lock_kernel
c_func
(paren
r_void
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|pushfl
id|cli
id|cmpl
"$"
l_int|0
comma
op_mod
l_int|0
id|jne
l_float|0f
id|movl
"$"
l_float|0f
comma
op_mod
op_mod
id|eax
id|jmp
id|__lock_kernel
l_int|0
suffix:colon
id|incl
op_mod
l_int|0
id|popfl
"&quot;"
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
id|current_set
(braket
id|cpu
)braket
op_member_access_from_pointer
id|lock_depth
)paren
comma
l_string|&quot;d&quot;
(paren
id|cpu
)paren
suffix:colon
l_string|&quot;ax&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|function|unlock_kernel
r_extern
id|__inline__
r_void
id|unlock_kernel
c_func
(paren
r_void
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
id|pushfl
id|cli
id|decl
op_mod
l_int|0
id|jnz
l_float|1f
id|movb
op_mod
l_int|1
comma
id|active_kernel_processor
id|lock
id|btrl
"$"
l_int|0
comma
id|kernel_flag
l_int|1
suffix:colon
id|popfl
"&quot;"
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;m&quot;
(paren
id|current-&gt;lock_depth
)paren
comma
l_string|&quot;i&quot;
(paren
id|NO_PROC_ID
)paren
suffix:colon
l_string|&quot;ax&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Simple spin lock operations.  There are two variants, one clears IRQ&squot;s&n; * on the local processor, one does not.&n; *&n; * We make no fairness assumptions. They have a cost.&n; *&n; *&t;NOT YET TESTED!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&n; */
DECL|typedef|spinlock_t
r_typedef
r_int
r_char
id|spinlock_t
suffix:semicolon
multiline_comment|/* Arse backwards is faster for us on Intel (trylock is a clock faster) */
DECL|macro|SPIN_LOCK_UNLOCKED
mdefine_line|#define SPIN_LOCK_UNLOCKED&t;1
DECL|function|__spinlock_waitfor
r_extern
id|__inline__
r_void
id|__spinlock_waitfor
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* Spin reading and let the MESI cache do the right stuff&n;&t;&t;   without us thrashing the bus */
r_while
c_loop
(paren
id|lock
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Not a race, the interrupt will pick up&n;&t;&t;&t; *&t;the exiting case that looks suspicious.&n;&t;&t;&t; *&t;(The test_bit is not locked so won&squot;t&n;&t;&t;&t; *&t; thrash the bus either).&n;&t;&t;&t; */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|cpu
comma
op_amp
id|smp_invalidate_needed
)paren
)paren
(brace
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|cpu
comma
op_amp
id|smp_invalidate_needed
)paren
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|clear_bit
c_func
(paren
l_int|0
comma
id|lock
)paren
)paren
(brace
suffix:semicolon
)brace
)brace
DECL|function|spin_lock_init
r_extern
id|__inline__
r_void
id|spin_lock_init
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
op_star
id|lock
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* We assume init does not need to be itself SMP safe */
)brace
DECL|function|spin_lock
r_extern
id|__inline__
r_void
id|spin_lock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
multiline_comment|/* Returns the old value. If we get 1 then we got the lock */
r_if
c_cond
(paren
id|clear_bit
c_func
(paren
l_int|0
comma
id|lock
)paren
)paren
(brace
id|__spinlock_waitfor
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
)brace
DECL|function|spin_trylock
r_extern
id|__inline__
r_int
id|spin_trylock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
r_return
id|clear_bit
c_func
(paren
l_int|0
comma
id|lock
)paren
suffix:semicolon
)brace
DECL|function|spin_unlock
r_extern
id|__inline__
r_void
id|spin_unlock
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
id|set_bit
c_func
(paren
l_int|0
comma
id|lock
)paren
suffix:semicolon
)brace
multiline_comment|/* These variants clear interrupts and return save_flags() style flags&n; * to the caller when acquiring a lock.  To release the lock you must&n; * pass the lock pointer as well as the flags returned from the acquisition&n; * routine when releasing the lock.&n; */
DECL|function|spin_lock_cli
r_extern
id|__inline__
r_int
r_int
id|spin_lock_cli
c_func
(paren
id|spinlock_t
op_star
id|lock
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|clear_bit
c_func
(paren
l_int|0
comma
id|lock
)paren
)paren
(brace
id|__spinlock_waitfor
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
r_return
id|flags
suffix:semicolon
)brace
DECL|function|spin_unlock_restore
r_extern
id|__inline__
r_void
id|spin_unlock_restore
c_func
(paren
id|spinlock_t
op_star
id|lock
comma
r_int
r_int
id|flags
)paren
(brace
id|set_bit
c_func
(paren
l_int|0
comma
id|lock
)paren
suffix:semicolon
multiline_comment|/* Locked operation to keep it serialized with&n;&t;&t;&t;&t;   the popfl */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif /* __SMP__ */
macro_line|#endif /* __I386_SMPLOCK_H */
eof
