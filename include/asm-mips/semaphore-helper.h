multiline_comment|/* $Id: semaphore-helper.h,v 1.6 1999/10/20 21:10:58 ralf Exp $&n; *&n; * SMP- and interrupt-safe semaphores helper functions.&n; *&n; * (C) Copyright 1996 Linus Torvalds&n; * (C) Copyright 1999 Andrea Arcangeli&n; * (C) Copyright 1999 Ralf Baechle&n; * (C) Copyright 1999 Silicon Graphics, Inc.&n; */
macro_line|#ifndef _ASM_SEMAPHORE_HELPER_H
DECL|macro|_ASM_SEMAPHORE_HELPER_H
mdefine_line|#define _ASM_SEMAPHORE_HELPER_H
macro_line|#include &lt;linux/config.h&gt;
multiline_comment|/*&n; * These two _must_ execute atomically wrt each other.&n; */
DECL|function|wake_one_more
r_static
r_inline
r_void
id|wake_one_more
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
suffix:semicolon
)brace
macro_line|#if !defined(CONFIG_CPU_HAS_LLSC)
multiline_comment|/*&n; * It doesn&squot;t make sense, IMHO, to endlessly turn interrupts off and on again.&n; * Do it once and that&squot;s it. ll/sc *has* it&squot;s advantages. HK&n; */
DECL|macro|read
mdefine_line|#define read(a) ((a)-&gt;counter)
DECL|macro|inc
mdefine_line|#define inc(a) (((a)-&gt;counter)++)
DECL|macro|dec
mdefine_line|#define dec(a) (((a)-&gt;counter)--)
DECL|function|waking_non_zero
r_static
r_inline
r_int
id|waking_non_zero
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
OG
l_int|0
)paren
(brace
id|dec
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|waking_non_zero_interruptible
r_static
r_inline
r_int
id|waking_non_zero_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
OG
l_int|0
)paren
(brace
id|dec
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|tsk
)paren
)paren
(brace
id|inc
c_func
(paren
op_amp
id|sem-&gt;count
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINTR
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|waking_non_zero_trylock
r_static
r_inline
r_int
id|waking_non_zero_trylock
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
op_le
l_int|0
)paren
id|inc
c_func
(paren
op_amp
id|sem-&gt;count
)paren
suffix:semicolon
r_else
(brace
id|dec
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#else /* CONFIG_CPU_HAS_LLSC */
r_static
r_inline
r_int
DECL|function|waking_non_zero
id|waking_non_zero
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
id|ret
comma
id|tmp
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&bslash;tll&bslash;t%1, %2&bslash;n&bslash;t&quot;
l_string|&quot;blez&bslash;t%1, 2f&bslash;n&bslash;t&quot;
l_string|&quot;subu&bslash;t%0, %1, 1&bslash;n&bslash;t&quot;
l_string|&quot;sc&bslash;t%0, %2&bslash;n&bslash;t&quot;
l_string|&quot;beqz&bslash;t%0, 1b&bslash;n&bslash;t&quot;
l_string|&quot;2:&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ret
)paren
comma
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
comma
l_string|&quot;=m&quot;
(paren
id|__atomic_fool_gcc
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * waking_non_zero_interruptible:&n; *&t;1&t;got the lock&n; *&t;0&t;go to sleep&n; *&t;-EINTR&t;interrupted&n; *&n; * We must undo the sem-&gt;count down_interruptible decrement&n; * simultaneously and atomicly with the sem-&gt;waking adjustment,&n; * otherwise we can race with wake_one_more.&n; *&n; * This is accomplished by doing a 64-bit ll/sc on the 2 32-bit words.&n; *&n; * This is crazy.  Normally it stricly forbidden to use 64-bit operations&n; * in the 32-bit MIPS kernel.  In this case it&squot;s however ok because if an&n; * interrupt has destroyed the upper half of registers sc will fail.&n; * Note also that this will not work for MIPS32 CPUS!&n; *&n; * Pseudocode:&n; *&n; * If(sem-&gt;waking &gt; 0) {&n; *&t;Decrement(sem-&gt;waking)&n; *&t;Return(SUCCESS)&n; * } else If(segnal_pending(tsk)) {&n; *&t;Increment(sem-&gt;count)&n; *&t;Return(-EINTR)&n; * } else {&n; *&t;Return(SLEEP)&n; * }&n; */
r_static
r_inline
r_int
DECL|function|waking_non_zero_interruptible
id|waking_non_zero_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_int
id|ret
comma
id|tmp
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
dot
id|set
id|push
dot
id|set
id|mips3
dot
id|set
id|noat
l_int|0
suffix:colon
id|lld
op_mod
l_int|1
comma
op_mod
l_int|2
id|li
op_mod
l_int|0
comma
l_int|0
id|sll
"$"
l_int|1
comma
op_mod
l_int|1
comma
l_int|0
id|blez
"$"
l_int|1
comma
l_float|1f
id|daddiu
op_mod
l_int|1
comma
op_mod
l_int|1
comma
op_minus
l_int|1
id|li
op_mod
l_int|0
comma
l_int|1
id|b
l_float|2f
l_int|1
suffix:colon
id|beqz
op_mod
l_int|3
comma
l_float|2f
id|li
op_mod
l_int|0
comma
op_mod
l_int|4
id|dli
"$"
l_int|1
comma
l_int|0x0000000100000000
id|daddu
op_mod
l_int|1
comma
op_mod
l_int|1
comma
"$"
l_int|1
l_int|2
suffix:colon
id|scd
op_mod
l_int|1
comma
op_mod
l_int|2
id|beqz
op_mod
l_int|1
comma
l_int|0
id|b
dot
id|set
id|pop
"&quot;"
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|ret
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
comma
l_string|&quot;=m&quot;
(paren
op_star
id|sem
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|signal_pending
c_func
(paren
id|tsk
)paren
)paren
comma
l_string|&quot;i&quot;
(paren
op_minus
id|EINTR
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * waking_non_zero_trylock is unused.  we do everything in &n; * down_trylock and let non-ll/sc hosts bounce around.&n; */
r_static
r_inline
r_int
DECL|function|waking_non_zero_trylock
id|waking_non_zero_trylock
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC
c_func
(paren
id|sem-&gt;__magic
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_CPU_HAS_LLSC */
macro_line|#endif /* _ASM_SEMAPHORE_HELPER_H */
eof
