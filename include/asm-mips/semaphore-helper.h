multiline_comment|/* $Id: semaphore-helper.h,v 1.3 1999/06/11 14:30:15 ralf Exp $&n; *&n; * SMP- and interrupt-safe semaphores helper functions.&n; *&n; * (C) Copyright 1996 Linus Torvalds&n; * (C) Copyright 1999 Andrea Arcangeli&n; * (C) Copyright 1999 Ralf Baechle&n; */
macro_line|#ifndef __ASM_MIPS_SEMAPHORE_HELPER_H
DECL|macro|__ASM_MIPS_SEMAPHORE_HELPER_H
mdefine_line|#define __ASM_MIPS_SEMAPHORE_HELPER_H
multiline_comment|/*&n; * These two _must_ execute atomically wrt each other.&n; */
DECL|function|wake_one_more
r_static
r_inline
r_void
id|wake_one_more
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|waking_non_zero
id|waking_non_zero
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
id|ret
comma
id|tmp
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&bslash;tll&bslash;t%1,%2&bslash;n&bslash;t&quot;
l_string|&quot;blez&bslash;t%1,2f&bslash;n&bslash;t&quot;
l_string|&quot;subu&bslash;t%0,%1,1&bslash;n&bslash;t&quot;
l_string|&quot;sc&bslash;t%0,%2&bslash;n&bslash;t&quot;
l_string|&quot;beqz&bslash;t%0,1b&bslash;n&bslash;t&quot;
l_string|&quot;2:&quot;
l_string|&quot;.text&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ret
)paren
comma
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
comma
l_string|&quot;=m&quot;
(paren
id|__atomic_fool_gcc
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * waking_non_zero_interruptible:&n; *&t;1&t;got the lock&n; *&t;0&t;go to sleep&n; *&t;-EINTR&t;interrupted&n; *&n; * We must undo the sem-&gt;count down_interruptible decrement&n; * simultaneously and atomicly with the sem-&gt;waking adjustment,&n; * otherwise we can race with wake_one_more.&n; *&n; * This is accomplished by doing a 64-bit ll/sc on the 2 32-bit words.&n; *&n; * This is crazy.  Normally it stricly forbidden to use 64-bit operation&n; * in the 32-bit MIPS kernel.  In this case it&squot;s however ok because if an&n; * interrupt has destroyed the upper half of registers sc will fail.&n; */
r_static
r_inline
r_int
DECL|function|waking_non_zero_interruptible
id|waking_non_zero_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
comma
r_struct
id|task_struct
op_star
id|tsk
)paren
(brace
r_int
id|ret
comma
id|tmp
suffix:semicolon
macro_line|#ifdef __MIPSEB__
id|__asm__
id|__volatile__
c_func
(paren
"&quot;"
dot
id|set
id|mips3
dot
id|set
id|push
dot
id|set
id|noat
l_int|0
suffix:colon
id|lld
op_mod
l_int|1
comma
op_mod
l_int|2
id|li
op_mod
l_int|0
comma
l_int|0
id|bltz
op_mod
l_int|1
comma
l_float|1f
id|dli
"$"
l_int|1
comma
l_int|0xffffffff00000000
id|daddu
op_mod
l_int|1
comma
"$"
l_int|1
id|li
op_mod
l_int|0
comma
l_int|1
id|b
l_float|2f
l_int|1
suffix:colon
id|beqz
op_mod
l_int|3
comma
l_float|1f
id|addiu
"$"
l_int|1
comma
op_mod
l_int|1
comma
l_int|1
id|dsll32
"$"
l_int|1
comma
"$"
l_int|1
comma
l_int|0
id|dsrl32
"$"
l_int|1
comma
"$"
l_int|1
comma
l_int|0
id|dsrl32
op_mod
l_int|1
comma
op_mod
l_int|1
comma
l_int|0
id|dsll32
op_mod
l_int|1
comma
op_mod
l_int|1
comma
l_int|0
op_logical_or
op_mod
l_int|1
comma
"$"
l_int|1
id|li
op_mod
l_int|0
comma
op_mod
l_int|4
id|b
l_float|2f
l_int|1
suffix:colon
id|scd
op_mod
l_int|1
comma
op_mod
l_int|2
l_int|2
suffix:colon
id|beqz
op_mod
l_int|1
comma
l_int|0
id|b
dot
id|set
id|pop
dot
id|set
id|mips0
"&quot;"
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|ret
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|tmp
)paren
comma
l_string|&quot;=m&quot;
(paren
op_star
id|sem
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|signal_pending
c_func
(paren
id|tsk
)paren
)paren
comma
l_string|&quot;i&quot;
(paren
op_minus
id|EINTR
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef __MIPSEL__
macro_line|#error &quot;FIXME: waking_non_zero_interruptible doesn&squot;t support little endian machines yet.&quot;
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * waking_non_zero_trylock:&n; *&t;1&t;failed to lock&n; *&t;0&t;got the lock&n; *&n; * XXX SMP ALERT&n; */
macro_line|#ifdef __SMP__
macro_line|#error FIXME, waking_non_zero_trylock is broken for SMP.
macro_line|#endif
DECL|function|waking_non_zero_trylock
r_static
r_inline
r_int
id|waking_non_zero_trylock
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
op_le
l_int|0
)paren
id|atomic_inc
c_func
(paren
op_amp
id|sem-&gt;count
)paren
suffix:semicolon
r_else
(brace
id|atomic_dec
c_func
(paren
op_amp
id|sem-&gt;waking
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif /* __ASM_MIPS_SEMAPHORE_HELPER_H */
eof
