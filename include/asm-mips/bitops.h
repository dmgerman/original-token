multiline_comment|/*&n; * include/asm-mips/bitops.h&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file &quot;COPYING&quot; in the main directory of this archive&n; * for more details.&n; *&n; * Copyright (c) 1994, 1995  Ralf Baechle&n; */
macro_line|#ifndef __ASM_MIPS_BITOPS_H
DECL|macro|__ASM_MIPS_BITOPS_H
mdefine_line|#define __ASM_MIPS_BITOPS_H
macro_line|#ifdef __R4000__
macro_line|#include &lt;asm/mipsregs.h&gt;
multiline_comment|/*&n; * The following functions will only work for the R4000!&n; */
DECL|function|set_bit
r_extern
id|__inline__
r_int
id|set_bit
c_func
(paren
r_int
id|nr
comma
r_void
op_star
id|addr
)paren
(brace
r_int
id|mask
comma
id|retval
comma
id|mw
suffix:semicolon
id|addr
op_add_assign
(paren
(paren
id|nr
op_rshift
l_int|3
)paren
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
id|mask
op_assign
l_int|1
op_lshift
(paren
id|nr
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_do
(brace
id|mw
op_assign
id|load_linked
c_func
(paren
id|addr
)paren
suffix:semicolon
id|retval
op_assign
(paren
id|mask
op_amp
id|mw
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|store_conditional
c_func
(paren
id|addr
comma
id|mw
op_or
id|mask
)paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|clear_bit
r_extern
id|__inline__
r_int
id|clear_bit
c_func
(paren
r_int
id|nr
comma
r_void
op_star
id|addr
)paren
(brace
r_int
id|mask
comma
id|retval
comma
id|mw
suffix:semicolon
id|addr
op_add_assign
(paren
(paren
id|nr
op_rshift
l_int|3
)paren
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
id|mask
op_assign
l_int|1
op_lshift
(paren
id|nr
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_do
(brace
id|mw
op_assign
id|load_linked
c_func
(paren
id|addr
)paren
suffix:semicolon
id|retval
op_assign
(paren
id|mask
op_amp
id|mw
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|store_conditional
c_func
(paren
id|addr
comma
id|mw
op_amp
op_complement
id|mask
)paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|change_bit
r_extern
id|__inline__
r_int
id|change_bit
c_func
(paren
r_int
id|nr
comma
r_void
op_star
id|addr
)paren
(brace
r_int
id|mask
comma
id|retval
comma
id|mw
suffix:semicolon
id|addr
op_add_assign
(paren
(paren
id|nr
op_rshift
l_int|3
)paren
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
id|mask
op_assign
l_int|1
op_lshift
(paren
id|nr
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_do
(brace
id|mw
op_assign
id|load_linked
c_func
(paren
id|addr
)paren
suffix:semicolon
id|retval
op_assign
(paren
id|mask
op_amp
id|mw
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|store_conditional
c_func
(paren
id|addr
comma
id|mw
op_xor
id|mask
)paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
macro_line|#else /* !defined(__R4000__) */
macro_line|#include &lt;asm/system.h&gt;
macro_line|#ifdef __KERNEL__
multiline_comment|/*&n; * Only disable interrupt for kernelmode stuff to keep some&n; * usermode stuff alive&n; */
DECL|macro|__flags
mdefine_line|#define __flags unsigned long flags
DECL|macro|__cli
mdefine_line|#define __cli() cli()
DECL|macro|__save_flags
mdefine_line|#define __save_flags(x) save_flags(x)
DECL|macro|__restore_flags
mdefine_line|#define __restore_flags(x) restore_flags(x)
macro_line|#endif /* __KERNEL__ */
DECL|function|set_bit
r_extern
id|__inline__
r_int
id|set_bit
c_func
(paren
r_int
id|nr
comma
r_void
op_star
id|addr
)paren
(brace
r_int
id|mask
comma
id|retval
suffix:semicolon
r_int
op_star
id|a
op_assign
id|addr
suffix:semicolon
id|__flags
suffix:semicolon
id|a
op_add_assign
id|nr
op_rshift
l_int|5
suffix:semicolon
id|mask
op_assign
l_int|1
op_lshift
(paren
id|nr
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
(paren
id|mask
op_amp
op_star
id|a
)paren
op_ne
l_int|0
suffix:semicolon
op_star
id|a
op_or_assign
id|mask
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|clear_bit
r_extern
id|__inline__
r_int
id|clear_bit
c_func
(paren
r_int
id|nr
comma
r_void
op_star
id|addr
)paren
(brace
r_int
id|mask
comma
id|retval
suffix:semicolon
r_int
op_star
id|a
op_assign
id|addr
suffix:semicolon
id|__flags
suffix:semicolon
id|a
op_add_assign
id|nr
op_rshift
l_int|5
suffix:semicolon
id|mask
op_assign
l_int|1
op_lshift
(paren
id|nr
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
(paren
id|mask
op_amp
op_star
id|a
)paren
op_ne
l_int|0
suffix:semicolon
op_star
id|a
op_and_assign
op_complement
id|mask
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|change_bit
r_extern
id|__inline__
r_int
id|change_bit
c_func
(paren
r_int
id|nr
comma
r_void
op_star
id|addr
)paren
(brace
r_int
id|mask
comma
id|retval
suffix:semicolon
r_int
op_star
id|a
op_assign
id|addr
suffix:semicolon
id|__flags
suffix:semicolon
id|a
op_add_assign
id|nr
op_rshift
l_int|5
suffix:semicolon
id|mask
op_assign
l_int|1
op_lshift
(paren
id|nr
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
(paren
id|mask
op_amp
op_star
id|a
)paren
op_ne
l_int|0
suffix:semicolon
op_star
id|a
op_xor_assign
id|mask
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|macro|__flags
macro_line|#undef __flags
DECL|macro|__cli
macro_line|#undef __cli()
DECL|macro|__save_flags
macro_line|#undef __save_flags(x)
DECL|macro|__restore_flags
macro_line|#undef __restore_flags(x)
macro_line|#endif /* !defined(__R4000__) */
DECL|function|test_bit
r_extern
id|__inline__
r_int
id|test_bit
c_func
(paren
r_int
id|nr
comma
r_const
r_void
op_star
id|addr
)paren
(brace
r_int
id|mask
suffix:semicolon
r_int
r_int
op_star
id|a
suffix:semicolon
id|a
op_assign
id|addr
suffix:semicolon
id|addr
op_add_assign
id|nr
op_rshift
l_int|5
suffix:semicolon
id|mask
op_assign
l_int|1
op_lshift
(paren
id|nr
op_amp
l_int|0x1f
)paren
suffix:semicolon
r_return
(paren
(paren
id|mask
op_amp
op_star
id|a
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|find_first_zero_bit
r_extern
id|__inline__
r_int
id|find_first_zero_bit
(paren
r_void
op_star
id|addr
comma
r_int
id|size
)paren
(brace
r_int
id|res
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
r_return
l_int|0
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;.set&bslash;tnoreorder&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tnoat&bslash;n&quot;
l_string|&quot;1:&bslash;tsubu&bslash;t$1,%2,%0&bslash;n&bslash;t&quot;
l_string|&quot;blez&bslash;t$1,2f&bslash;n&bslash;t&quot;
l_string|&quot;lw&bslash;t$1,(%4)&bslash;n&bslash;t&quot;
l_string|&quot;addiu&bslash;t%4,%4,4&bslash;n&bslash;t&quot;
l_string|&quot;beql&bslash;t%1,$1,1b&bslash;n&bslash;t&quot;
l_string|&quot;addiu&bslash;t%0,%0,32&bslash;n&bslash;t&quot;
l_string|&quot;li&bslash;t%1,1&bslash;n&quot;
l_string|&quot;1:&bslash;tand&bslash;t%4,$1,%1&bslash;n&bslash;t&quot;
l_string|&quot;beq&bslash;t$0,%4,2f&bslash;n&bslash;t&quot;
l_string|&quot;sll&bslash;t%1,%1,1&bslash;n&bslash;t&quot;
l_string|&quot;bne&bslash;t$0,%1,1b&bslash;n&bslash;t&quot;
l_string|&quot;add&bslash;t%0,%0,1&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tat&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;treorder&bslash;n&quot;
l_string|&quot;2:&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|res
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
(paren
r_int
r_int
)paren
l_int|0xffffffff
)paren
comma
l_string|&quot;r&quot;
(paren
id|size
)paren
comma
l_string|&quot;0&quot;
(paren
(paren
r_int
r_int
)paren
l_int|0
)paren
comma
l_string|&quot;r&quot;
(paren
id|addr
)paren
suffix:colon
l_string|&quot;$1&quot;
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|find_next_zero_bit
r_extern
id|__inline__
r_int
id|find_next_zero_bit
(paren
r_void
op_star
id|addr
comma
r_int
id|size
comma
r_int
id|offset
)paren
(brace
r_int
r_int
op_star
id|p
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
id|addr
)paren
op_plus
(paren
id|offset
op_rshift
l_int|5
)paren
suffix:semicolon
r_int
id|set
op_assign
l_int|0
comma
id|bit
op_assign
id|offset
op_amp
l_int|31
comma
id|res
suffix:semicolon
r_if
c_cond
(paren
id|bit
)paren
(brace
multiline_comment|/*&n;&t;&t; * Look for zero in first byte&n;&t;&t; */
id|__asm__
c_func
(paren
l_string|&quot;.set&bslash;tnoreorder&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tnoat&bslash;n&quot;
l_string|&quot;1:&bslash;tand&bslash;t$1,%2,%1&bslash;n&bslash;t&quot;
l_string|&quot;beq&bslash;t$0,$1,2f&bslash;n&bslash;t&quot;
l_string|&quot;sll&bslash;t%2,%2,1&bslash;n&bslash;t&quot;
l_string|&quot;bne&bslash;t$0,%2,1b&bslash;n&bslash;t&quot;
l_string|&quot;addiu&bslash;t%0,%0,1&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tat&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;treorder&bslash;n&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|set
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
op_star
id|p
op_rshift
id|bit
)paren
comma
l_string|&quot;r&quot;
(paren
l_int|1
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
suffix:colon
l_string|&quot;$1&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|set
OL
(paren
l_int|32
op_minus
id|bit
)paren
)paren
r_return
id|set
op_plus
id|offset
suffix:semicolon
id|set
op_assign
l_int|32
op_minus
id|bit
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * No zero yet, search remaining full bytes for a zero&n;&t; */
id|res
op_assign
id|find_first_zero_bit
(paren
id|p
comma
id|size
op_minus
l_int|32
op_star
(paren
id|p
op_minus
(paren
r_int
r_int
op_star
)paren
id|addr
)paren
)paren
suffix:semicolon
r_return
(paren
id|offset
op_plus
id|set
op_plus
id|res
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ffz = Find First Zero in word. Undefined if no zero exists,&n; * so code should check against ~0UL first..&n; */
DECL|function|ffz
r_extern
id|__inline__
r_int
r_int
id|ffz
c_func
(paren
r_int
r_int
id|word
)paren
(brace
r_int
r_int
id|__res
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|1
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;.set&bslash;tnoreorder&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tnoat&bslash;n&bslash;t&quot;
l_string|&quot;li&bslash;t%2,1&bslash;n&quot;
l_string|&quot;1:&bslash;tand&bslash;t$1,%2,%1&bslash;n&bslash;t&quot;
l_string|&quot;beq&bslash;t$0,$1,2f&bslash;n&bslash;t&quot;
l_string|&quot;sll&bslash;t%2,%2,1&bslash;n&bslash;t&quot;
l_string|&quot;bne&bslash;t$0,%2,1b&bslash;n&bslash;t&quot;
l_string|&quot;add&bslash;t%0,%0,1&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tat&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;treorder&bslash;n&quot;
l_string|&quot;2:&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|__res
)paren
comma
l_string|&quot;=r&quot;
(paren
id|word
)paren
comma
l_string|&quot;=r&quot;
(paren
id|mask
)paren
suffix:colon
l_string|&quot;1&quot;
(paren
op_complement
(paren
id|word
)paren
)paren
comma
l_string|&quot;2&quot;
(paren
id|mask
)paren
comma
l_string|&quot;0&quot;
(paren
l_int|0
)paren
suffix:colon
l_string|&quot;$1&quot;
)paren
suffix:semicolon
r_return
id|__res
suffix:semicolon
)brace
macro_line|#endif /* __ASM_MIPS_BITOPS_H */
eof
