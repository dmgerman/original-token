macro_line|#ifndef __ASM_MIPS_PGTABLE_H
DECL|macro|__ASM_MIPS_PGTABLE_H
mdefine_line|#define __ASM_MIPS_PGTABLE_H
macro_line|#ifndef __LANGUAGE_ASSEMBLY__
macro_line|#include &lt;linux/linkage.h&gt;
macro_line|#include &lt;asm/cachectl.h&gt;
multiline_comment|/*&n; * The Linux memory management assumes a three-level page table setup. In&n; * 32 bit mode we use that, but &quot;fold&quot; the mid level into the top-level page&n; * table, so that we physically have the same two-level page table as the&n; * i386 mmu expects. The 64 bit version uses a three level setup.&n; *&n; * This file contains the functions and defines necessary to modify and use&n; * the MIPS page table tree.  Note the frequent conversion between addresses&n; * in KSEG0 and KSEG1.&n; *&n; * This is required due to the cache aliasing problem of the R4xx0 series.&n; * Sometimes doing uncached accesses also to improve the cache performance&n; * slightly.  The R10000 caching mode &quot;uncached accelerated&quot; will help even&n; * further.&n; */
multiline_comment|/*&n; * TLB invalidation:&n; *&n; *  - invalidate() invalidates the current mm struct TLBs&n; *  - invalidate_all() invalidates all processes TLBs&n; *  - invalidate_mm(mm) invalidates the specified mm context TLB&squot;s&n; *  - invalidate_page(mm, vmaddr) invalidates one page&n; *  - invalidate_range(mm, start, end) invalidates a range of pages&n; *&n; * FIXME: MIPS has full control of all TLB activity in the CPU.  Though&n; * we just stick with complete flushing of TLBs for now.&n; */
r_extern
id|asmlinkage
r_void
id|tlbflush
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|invalidate
mdefine_line|#define invalidate()&t;({sys_cacheflush(0, ~0, BCACHE);tlbflush();})
DECL|macro|invalidate_all
mdefine_line|#define invalidate_all() invalidate()
DECL|macro|invalidate_mm
mdefine_line|#define invalidate_mm(mm_struct) &bslash;&n;do { if ((mm_struct) == current-&gt;mm) invalidate(); } while (0)
DECL|macro|invalidate_page
mdefine_line|#define invalidate_page(mm_struct,addr) &bslash;&n;do { if ((mm_struct) == current-&gt;mm) invalidate(); } while (0)
DECL|macro|invalidate_range
mdefine_line|#define invalidate_range(mm_struct,start,end) &bslash;&n;do { if ((mm_struct) == current-&gt;mm) invalidate(); } while (0)
multiline_comment|/*&n; * We need a special version of copy_page that can handle virtual caches.&n; * While we&squot;re at tweaking with caches we can use that to make it faster.&n; * The R10000&squot;s accelerated caching mode will further accelerate it.&n; */
r_extern
r_void
id|__copy_page
c_func
(paren
r_int
r_int
id|from
comma
r_int
r_int
id|to
)paren
suffix:semicolon
DECL|macro|copy_page
mdefine_line|#define copy_page(from,to) __copy_page((unsigned long)from, (unsigned long)to)
multiline_comment|/* Certain architectures need to do special things when pte&squot;s&n; * within a page table are directly modified.  Thus, the following&n; * hook is made available.&n; */
DECL|macro|set_pte
mdefine_line|#define set_pte(pteptr, pteval) ((*(pteptr)) = (pteval))
macro_line|#endif /* !defined (__LANGUAGE_ASSEMBLY__) */
multiline_comment|/* PMD_SHIFT determines the size of the area a second-level page table can map */
DECL|macro|PMD_SHIFT
mdefine_line|#define PMD_SHIFT&t;22
DECL|macro|PMD_SIZE
mdefine_line|#define PMD_SIZE&t;(1UL &lt;&lt; PMD_SHIFT)
DECL|macro|PMD_MASK
mdefine_line|#define PMD_MASK&t;(~(PMD_SIZE-1))
multiline_comment|/* PGDIR_SHIFT determines what a third-level page table entry can map */
DECL|macro|PGDIR_SHIFT
mdefine_line|#define PGDIR_SHIFT&t;22
DECL|macro|PGDIR_SIZE
mdefine_line|#define PGDIR_SIZE&t;(1UL &lt;&lt; PGDIR_SHIFT)
DECL|macro|PGDIR_MASK
mdefine_line|#define PGDIR_MASK&t;(~(PGDIR_SIZE-1))
multiline_comment|/*&n; * entries per page directory level: we use two-level, so&n; * we don&squot;t really have any PMD directory physically.&n; */
DECL|macro|PTRS_PER_PTE
mdefine_line|#define PTRS_PER_PTE&t;1024
DECL|macro|PTRS_PER_PMD
mdefine_line|#define PTRS_PER_PMD&t;1
DECL|macro|PTRS_PER_PGD
mdefine_line|#define PTRS_PER_PGD&t;1024
DECL|macro|VMALLOC_START
mdefine_line|#define VMALLOC_START     KSEG2
DECL|macro|VMALLOC_VMADDR
mdefine_line|#define VMALLOC_VMADDR(x) ((unsigned long)(x))
multiline_comment|/*&n; * Note that we shift the lower 32bits of each EntryLo[01] entry&n; * 6 bits to the left. That way we can convert the PFN into the&n; * physical address by a single &squot;and&squot; operation and gain 6 additional&n; * bits for storing information which isn&squot;t present in a normal&n; * MIPS page table.&n; * Since the Mips has choosen some quite missleading names for the&n; * valid and dirty bits they&squot;re defined here but only their synonyms&n; * will be used.&n; */
DECL|macro|_PAGE_PRESENT
mdefine_line|#define _PAGE_PRESENT               (1&lt;&lt;0)  /* implemented in software */
DECL|macro|_PAGE_COW
mdefine_line|#define _PAGE_COW                   (1&lt;&lt;1)  /* implemented in software */
DECL|macro|_PAGE_READ
mdefine_line|#define _PAGE_READ                  (1&lt;&lt;2)  /* implemented in software */
DECL|macro|_PAGE_WRITE
mdefine_line|#define _PAGE_WRITE                 (1&lt;&lt;3)  /* implemented in software */
DECL|macro|_PAGE_ACCESSED
mdefine_line|#define _PAGE_ACCESSED              (1&lt;&lt;4)  /* implemented in software */
DECL|macro|_PAGE_MODIFIED
mdefine_line|#define _PAGE_MODIFIED              (1&lt;&lt;5)  /* implemented in software */
DECL|macro|_PAGE_GLOBAL
mdefine_line|#define _PAGE_GLOBAL                (1&lt;&lt;6)
DECL|macro|_PAGE_VALID
mdefine_line|#define _PAGE_VALID                 (1&lt;&lt;7)
DECL|macro|_PAGE_SILENT_READ
mdefine_line|#define _PAGE_SILENT_READ           (1&lt;&lt;7)  /* synonym                 */
DECL|macro|_PAGE_DIRTY
mdefine_line|#define _PAGE_DIRTY                 (1&lt;&lt;8)  /* The MIPS dirty bit      */
DECL|macro|_PAGE_SILENT_WRITE
mdefine_line|#define _PAGE_SILENT_WRITE          (1&lt;&lt;8)
DECL|macro|_CACHE_CACHABLE_NO_WA
mdefine_line|#define _CACHE_CACHABLE_NO_WA       (0&lt;&lt;9)  /* R4600 only              */
DECL|macro|_CACHE_CACHABLE_WA
mdefine_line|#define _CACHE_CACHABLE_WA          (1&lt;&lt;9)  /* R4600 only              */
DECL|macro|_CACHE_UNCACHED
mdefine_line|#define _CACHE_UNCACHED             (2&lt;&lt;9)  /* R4[0246]00              */
DECL|macro|_CACHE_CACHABLE_NONCOHERENT
mdefine_line|#define _CACHE_CACHABLE_NONCOHERENT (3&lt;&lt;9)  /* R4[0246]00              */
DECL|macro|_CACHE_CACHABLE_CE
mdefine_line|#define _CACHE_CACHABLE_CE          (4&lt;&lt;9)  /* R4[04]00 only           */
DECL|macro|_CACHE_CACHABLE_COW
mdefine_line|#define _CACHE_CACHABLE_COW         (5&lt;&lt;9)  /* R4[04]00 only           */
DECL|macro|_CACHE_CACHABLE_CUW
mdefine_line|#define _CACHE_CACHABLE_CUW         (6&lt;&lt;9)  /* R4[04]00 only           */
DECL|macro|_CACHE_CACHABLE_ACCELERATED
mdefine_line|#define _CACHE_CACHABLE_ACCELERATED (7&lt;&lt;9)  /* R10000 only             */
DECL|macro|_CACHE_MASK
mdefine_line|#define _CACHE_MASK                 (7&lt;&lt;9)
DECL|macro|__READABLE
mdefine_line|#define __READABLE&t;(_PAGE_READ|_PAGE_SILENT_READ|_PAGE_ACCESSED)
DECL|macro|__WRITEABLE
mdefine_line|#define __WRITEABLE&t;(_PAGE_WRITE|_PAGE_SILENT_WRITE|_PAGE_MODIFIED)
DECL|macro|_PAGE_TABLE
mdefine_line|#define _PAGE_TABLE&t;(_PAGE_PRESENT | __READABLE | __WRITEABLE | &bslash;&n;&t;&t;&t;_PAGE_DIRTY | _CACHE_UNCACHED)
DECL|macro|_PAGE_CHG_MASK
mdefine_line|#define _PAGE_CHG_MASK  (PAGE_MASK | _PAGE_ACCESSED | _PAGE_DIRTY | _CACHE_MASK)
DECL|macro|PAGE_NONE
mdefine_line|#define PAGE_NONE&t;__pgprot(_PAGE_PRESENT | __READABLE | _CACHE_UNCACHED)
DECL|macro|PAGE_SHARED
mdefine_line|#define PAGE_SHARED     __pgprot(_PAGE_PRESENT | __READABLE | _PAGE_WRITE | &bslash;&n;&t;&t;&t;_PAGE_ACCESSED | _CACHE_CACHABLE_NONCOHERENT)
DECL|macro|PAGE_COPY
mdefine_line|#define PAGE_COPY       __pgprot(_PAGE_PRESENT | __READABLE | _PAGE_COW | &bslash;&n;&t;&t;&t;_CACHE_CACHABLE_NONCOHERENT)
DECL|macro|PAGE_READONLY
mdefine_line|#define PAGE_READONLY   __pgprot(_PAGE_PRESENT | __READABLE | &bslash;&n;&t;&t;&t;_CACHE_CACHABLE_NONCOHERENT)
DECL|macro|PAGE_KERNEL
mdefine_line|#define PAGE_KERNEL&t;__pgprot(_PAGE_PRESENT | __READABLE | __WRITEABLE | &bslash;&n;&t;&t;&t;_CACHE_CACHABLE_NONCOHERENT)
multiline_comment|/*&n; * MIPS can&squot;t do page protection for execute, and considers that the same like&n; * read. Also, write permissions imply read permissions. This is the closest&n; * we can get by reasonable means..&n; */
DECL|macro|__P000
mdefine_line|#define __P000&t;PAGE_NONE
DECL|macro|__P001
mdefine_line|#define __P001&t;PAGE_READONLY
DECL|macro|__P010
mdefine_line|#define __P010&t;PAGE_COPY
DECL|macro|__P011
mdefine_line|#define __P011&t;PAGE_COPY
DECL|macro|__P100
mdefine_line|#define __P100&t;PAGE_READONLY
DECL|macro|__P101
mdefine_line|#define __P101&t;PAGE_READONLY
DECL|macro|__P110
mdefine_line|#define __P110&t;PAGE_COPY
DECL|macro|__P111
mdefine_line|#define __P111&t;PAGE_COPY
DECL|macro|__S000
mdefine_line|#define __S000&t;PAGE_NONE
DECL|macro|__S001
mdefine_line|#define __S001&t;PAGE_READONLY
DECL|macro|__S010
mdefine_line|#define __S010&t;PAGE_SHARED
DECL|macro|__S011
mdefine_line|#define __S011&t;PAGE_SHARED
DECL|macro|__S100
mdefine_line|#define __S100&t;PAGE_READONLY
DECL|macro|__S101
mdefine_line|#define __S101&t;PAGE_READONLY
DECL|macro|__S110
mdefine_line|#define __S110&t;PAGE_SHARED
DECL|macro|__S111
mdefine_line|#define __S111&t;PAGE_SHARED
macro_line|#if !defined (__LANGUAGE_ASSEMBLY__)
multiline_comment|/* page table for 0-4MB for everybody */
r_extern
r_int
r_int
id|pg0
(braket
l_int|1024
)braket
suffix:semicolon
multiline_comment|/*&n; * BAD_PAGETABLE is used when we need a bogus page-table, while&n; * BAD_PAGE is used for a bogus page.&n; *&n; * ZERO_PAGE is a global shared page that is always zero: used&n; * for zero-mapped memory areas etc..&n; */
r_extern
id|pte_t
id|__bad_page
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
id|pte_t
op_star
id|__bad_pagetable
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
id|__zero_page
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|BAD_PAGETABLE
mdefine_line|#define BAD_PAGETABLE __bad_pagetable()
DECL|macro|BAD_PAGE
mdefine_line|#define BAD_PAGE __bad_page()
DECL|macro|ZERO_PAGE
mdefine_line|#define ZERO_PAGE __zero_page()
multiline_comment|/* number of bits that fit into a memory pointer */
DECL|macro|BITS_PER_PTR
mdefine_line|#define BITS_PER_PTR&t;&t;&t;(8*sizeof(unsigned long))
multiline_comment|/* to align the pointer to a pointer address */
DECL|macro|PTR_MASK
mdefine_line|#define PTR_MASK&t;&t;&t;(~(sizeof(void*)-1))
multiline_comment|/*&n; * sizeof(void*)==1&lt;&lt;SIZEOF_PTR_LOG2&n; */
macro_line|#if __mips == 3
DECL|macro|SIZEOF_PTR_LOG2
mdefine_line|#define SIZEOF_PTR_LOG2&t;&t;&t;3
macro_line|#else
DECL|macro|SIZEOF_PTR_LOG2
mdefine_line|#define SIZEOF_PTR_LOG2&t;&t;&t;2
macro_line|#endif
multiline_comment|/* to find an entry in a page-table */
DECL|macro|PAGE_PTR
mdefine_line|#define PAGE_PTR(address) &bslash;&n;((unsigned long)(address)&gt;&gt;(PAGE_SHIFT-SIZEOF_PTR_LOG2)&amp;PTR_MASK&amp;~PAGE_MASK)
multiline_comment|/* to set the page-dir */
DECL|macro|SET_PAGE_DIR
mdefine_line|#define SET_PAGE_DIR(tsk,pgdir) &bslash;&n;do { &bslash;&n;&t;(tsk)-&gt;tss.pg_dir = ((unsigned long) (pgdir)) - PT_OFFSET; &bslash;&n;&t;if ((tsk) == current) &bslash;&n;&t;{ &bslash;&n;&t;&t;void load_pgd(unsigned long pg_dir); &bslash;&n; &bslash;&n;&t;&t;load_pgd((tsk)-&gt;tss.pg_dir); &bslash;&n;&t;} &bslash;&n;} while (0)
r_extern
r_int
r_int
id|high_memory
suffix:semicolon
r_extern
id|pmd_t
id|invalid_pte_table
(braket
id|PAGE_SIZE
op_div
r_sizeof
(paren
id|pmd_t
)paren
)braket
suffix:semicolon
multiline_comment|/*&n; * Conversion functions: convert a page and protection to a page entry,&n; * and a page entry and page directory to the page they refer to.&n; */
DECL|function|pte_page
r_extern
r_inline
r_int
r_int
id|pte_page
c_func
(paren
id|pte_t
id|pte
)paren
(brace
r_return
id|PAGE_OFFSET
op_plus
(paren
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
)brace
DECL|function|pmd_page
r_extern
r_inline
r_int
r_int
id|pmd_page
c_func
(paren
id|pmd_t
id|pmd
)paren
(brace
r_return
id|PAGE_OFFSET
op_plus
(paren
id|pmd_val
c_func
(paren
id|pmd
)paren
op_amp
id|PAGE_MASK
)paren
suffix:semicolon
)brace
DECL|function|pmd_set
r_extern
r_inline
r_void
id|pmd_set
c_func
(paren
id|pmd_t
op_star
id|pmdp
comma
id|pte_t
op_star
id|ptep
)paren
(brace
id|pmd_val
c_func
(paren
op_star
id|pmdp
)paren
op_assign
id|_PAGE_TABLE
op_or
(paren
(paren
r_int
r_int
)paren
id|ptep
op_minus
id|PT_OFFSET
)paren
suffix:semicolon
)brace
DECL|function|pte_none
r_extern
r_inline
r_int
id|pte_none
c_func
(paren
id|pte_t
id|pte
)paren
(brace
r_return
op_logical_neg
id|pte_val
c_func
(paren
id|pte
)paren
suffix:semicolon
)brace
DECL|function|pte_present
r_extern
r_inline
r_int
id|pte_present
c_func
(paren
id|pte_t
id|pte
)paren
(brace
r_return
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_PRESENT
suffix:semicolon
)brace
DECL|function|pte_inuse
r_extern
r_inline
r_int
id|pte_inuse
c_func
(paren
id|pte_t
op_star
id|ptep
)paren
(brace
r_return
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|ptep
)paren
)braket
dot
id|reserved
op_logical_or
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|ptep
)paren
)braket
dot
id|count
op_ne
l_int|1
suffix:semicolon
)brace
DECL|function|pte_clear
r_extern
r_inline
r_void
id|pte_clear
c_func
(paren
id|pte_t
op_star
id|ptep
)paren
(brace
id|pte_val
c_func
(paren
op_star
id|ptep
)paren
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|pte_reuse
r_extern
r_inline
r_void
id|pte_reuse
c_func
(paren
id|pte_t
op_star
id|ptep
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|ptep
)paren
)braket
dot
id|reserved
)paren
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|ptep
)paren
)braket
dot
id|count
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Empty pgd/pmd entries point to the invalid_pte_table.&n; */
DECL|function|pmd_none
r_extern
r_inline
r_int
id|pmd_none
c_func
(paren
id|pmd_t
id|pmd
)paren
(brace
r_return
(paren
id|pmd_val
c_func
(paren
id|pmd
)paren
op_amp
id|PAGE_MASK
)paren
op_eq
(paren
(paren
r_int
r_int
)paren
id|invalid_pte_table
op_minus
id|PAGE_OFFSET
)paren
suffix:semicolon
)brace
DECL|function|pmd_bad
r_extern
r_inline
r_int
id|pmd_bad
c_func
(paren
id|pmd_t
id|pmd
)paren
(brace
r_return
(paren
id|pmd_val
c_func
(paren
id|pmd
)paren
op_amp
op_complement
id|PAGE_MASK
)paren
op_ne
id|_PAGE_TABLE
op_logical_or
id|pmd_page
c_func
(paren
id|pmd
)paren
OG
id|high_memory
op_logical_or
id|pmd_page
c_func
(paren
id|pmd
)paren
OL
id|PAGE_OFFSET
suffix:semicolon
)brace
DECL|function|pmd_present
r_extern
r_inline
r_int
id|pmd_present
c_func
(paren
id|pmd_t
id|pmd
)paren
(brace
r_return
id|pmd_val
c_func
(paren
id|pmd
)paren
op_amp
id|_PAGE_PRESENT
suffix:semicolon
)brace
DECL|function|pmd_inuse
r_extern
r_inline
r_int
id|pmd_inuse
c_func
(paren
id|pmd_t
op_star
id|pmdp
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pmd_clear
r_extern
r_inline
r_void
id|pmd_clear
c_func
(paren
id|pmd_t
op_star
id|pmdp
)paren
(brace
id|pmd_val
c_func
(paren
op_star
id|pmdp
)paren
op_assign
(paren
(paren
r_int
r_int
)paren
id|invalid_pte_table
op_minus
id|PAGE_OFFSET
)paren
suffix:semicolon
)brace
DECL|function|pmd_reuse
r_extern
r_inline
r_void
id|pmd_reuse
c_func
(paren
id|pmd_t
op_star
id|pmdp
)paren
(brace
)brace
multiline_comment|/*&n; * The &quot;pgd_xxx()&quot; functions here are trivial for a folded two-level&n; * setup: the pgd is never bad, and a pmd always exists (as it&squot;s folded&n; * into the pgd entry)&n; */
DECL|function|pgd_none
r_extern
r_inline
r_int
id|pgd_none
c_func
(paren
id|pgd_t
id|pgd
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pgd_bad
r_extern
r_inline
r_int
id|pgd_bad
c_func
(paren
id|pgd_t
id|pgd
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pgd_present
r_extern
r_inline
r_int
id|pgd_present
c_func
(paren
id|pgd_t
id|pgd
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|pgd_inuse
r_extern
r_inline
r_int
id|pgd_inuse
c_func
(paren
id|pgd_t
op_star
id|pgdp
)paren
(brace
r_return
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|pgdp
)paren
)braket
dot
id|reserved
suffix:semicolon
)brace
DECL|function|pgd_clear
r_extern
r_inline
r_void
id|pgd_clear
c_func
(paren
id|pgd_t
op_star
id|pgdp
)paren
(brace
)brace
multiline_comment|/*&n; * The following only work if pte_present() is true.&n; * Undefined behaviour if not..&n; */
DECL|function|pte_read
r_extern
r_inline
r_int
id|pte_read
c_func
(paren
id|pte_t
id|pte
)paren
(brace
r_return
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_READ
suffix:semicolon
)brace
DECL|function|pte_write
r_extern
r_inline
r_int
id|pte_write
c_func
(paren
id|pte_t
id|pte
)paren
(brace
r_return
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_WRITE
suffix:semicolon
)brace
DECL|function|pte_exec
r_extern
r_inline
r_int
id|pte_exec
c_func
(paren
id|pte_t
id|pte
)paren
(brace
r_return
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_READ
suffix:semicolon
)brace
DECL|function|pte_dirty
r_extern
r_inline
r_int
id|pte_dirty
c_func
(paren
id|pte_t
id|pte
)paren
(brace
r_return
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_MODIFIED
suffix:semicolon
)brace
DECL|function|pte_young
r_extern
r_inline
r_int
id|pte_young
c_func
(paren
id|pte_t
id|pte
)paren
(brace
r_return
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_ACCESSED
suffix:semicolon
)brace
DECL|function|pte_cow
r_extern
r_inline
r_int
id|pte_cow
c_func
(paren
id|pte_t
id|pte
)paren
(brace
r_return
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_COW
suffix:semicolon
)brace
DECL|function|pte_wrprotect
r_extern
r_inline
id|pte_t
id|pte_wrprotect
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_and_assign
op_complement
(paren
id|_PAGE_WRITE
op_or
id|_PAGE_SILENT_WRITE
)paren
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_rdprotect
r_extern
r_inline
id|pte_t
id|pte_rdprotect
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_and_assign
op_complement
(paren
id|_PAGE_READ
op_or
id|_PAGE_SILENT_READ
)paren
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_exprotect
r_extern
r_inline
id|pte_t
id|pte_exprotect
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_and_assign
op_complement
(paren
id|_PAGE_READ
op_or
id|_PAGE_SILENT_READ
)paren
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_mkclean
r_extern
r_inline
id|pte_t
id|pte_mkclean
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_and_assign
op_complement
(paren
id|_PAGE_MODIFIED
op_or
id|_PAGE_SILENT_WRITE
)paren
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_mkold
r_extern
r_inline
id|pte_t
id|pte_mkold
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_and_assign
op_complement
(paren
id|_PAGE_ACCESSED
op_or
id|_PAGE_SILENT_READ
op_or
id|_PAGE_SILENT_WRITE
)paren
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_uncow
r_extern
r_inline
id|pte_t
id|pte_uncow
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_and_assign
op_complement
id|_PAGE_COW
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_mkwrite
r_extern
r_inline
id|pte_t
id|pte_mkwrite
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_or_assign
id|_PAGE_WRITE
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_MODIFIED
)paren
id|pte_val
c_func
(paren
id|pte
)paren
op_or_assign
id|_PAGE_SILENT_WRITE
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_mkread
r_extern
r_inline
id|pte_t
id|pte_mkread
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_or_assign
id|_PAGE_READ
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_ACCESSED
)paren
id|pte_val
c_func
(paren
id|pte
)paren
op_or_assign
id|_PAGE_SILENT_READ
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_mkexec
r_extern
r_inline
id|pte_t
id|pte_mkexec
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_or_assign
id|_PAGE_READ
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_ACCESSED
)paren
id|pte_val
c_func
(paren
id|pte
)paren
op_or_assign
id|_PAGE_SILENT_READ
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_mkdirty
r_extern
r_inline
id|pte_t
id|pte_mkdirty
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_or_assign
id|_PAGE_MODIFIED
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_WRITE
)paren
id|pte_val
c_func
(paren
id|pte
)paren
op_or_assign
id|_PAGE_SILENT_WRITE
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_mkyoung
r_extern
r_inline
id|pte_t
id|pte_mkyoung
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_or_assign
id|_PAGE_ACCESSED
suffix:semicolon
r_if
c_cond
(paren
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_READ
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_or_assign
id|_PAGE_SILENT_READ
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
(paren
id|_PAGE_WRITE
op_or
id|_PAGE_MODIFIED
)paren
)paren
op_eq
(paren
id|_PAGE_WRITE
op_or
id|_PAGE_MODIFIED
)paren
)paren
id|pte_val
c_func
(paren
id|pte
)paren
op_or_assign
id|_PAGE_SILENT_WRITE
suffix:semicolon
)brace
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_mkcow
r_extern
r_inline
id|pte_t
id|pte_mkcow
c_func
(paren
id|pte_t
id|pte
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_or_assign
id|_PAGE_COW
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
multiline_comment|/*&n; * Conversion functions: convert a page and protection to a page entry,&n; * and a page entry and page directory to the page they refer to.&n; */
DECL|function|mk_pte
r_extern
r_inline
id|pte_t
id|mk_pte
c_func
(paren
r_int
r_int
id|page
comma
id|pgprot_t
id|pgprot
)paren
(brace
id|pte_t
id|pte
suffix:semicolon
id|pte_val
c_func
(paren
id|pte
)paren
op_assign
(paren
id|page
op_minus
id|PAGE_OFFSET
)paren
op_or
id|pgprot_val
c_func
(paren
id|pgprot
)paren
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
DECL|function|pte_modify
r_extern
r_inline
id|pte_t
id|pte_modify
c_func
(paren
id|pte_t
id|pte
comma
id|pgprot_t
id|newprot
)paren
(brace
id|pte_val
c_func
(paren
id|pte
)paren
op_assign
(paren
id|pte_val
c_func
(paren
id|pte
)paren
op_amp
id|_PAGE_CHG_MASK
)paren
op_or
id|pgprot_val
c_func
(paren
id|newprot
)paren
suffix:semicolon
r_return
id|pte
suffix:semicolon
)brace
multiline_comment|/* to find an entry in a page-table-directory */
DECL|function|pgd_offset
r_extern
r_inline
id|pgd_t
op_star
id|pgd_offset
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
comma
r_int
r_int
id|address
)paren
(brace
r_return
id|mm-&gt;pgd
op_plus
(paren
id|address
op_rshift
id|PGDIR_SHIFT
)paren
suffix:semicolon
)brace
multiline_comment|/* Find an entry in the second-level page table.. */
DECL|function|pmd_offset
r_extern
r_inline
id|pmd_t
op_star
id|pmd_offset
c_func
(paren
id|pgd_t
op_star
id|dir
comma
r_int
r_int
id|address
)paren
(brace
r_return
(paren
id|pmd_t
op_star
)paren
id|dir
suffix:semicolon
)brace
multiline_comment|/* Find an entry in the third-level page table.. */
DECL|function|pte_offset
r_extern
r_inline
id|pte_t
op_star
id|pte_offset
c_func
(paren
id|pmd_t
op_star
id|dir
comma
r_int
r_int
id|address
)paren
(brace
r_return
(paren
id|pte_t
op_star
)paren
(paren
id|pmd_page
c_func
(paren
op_star
id|dir
)paren
op_plus
(paren
id|PT_OFFSET
op_minus
id|PAGE_OFFSET
)paren
)paren
op_plus
(paren
(paren
id|address
op_rshift
id|PAGE_SHIFT
)paren
op_amp
(paren
id|PTRS_PER_PTE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate and free page tables. The xxx_kernel() versions are&n; * used to allocate a kernel page table - this turns on ASN bits&n; * if any, and marks the page tables reserved.&n; */
DECL|function|pte_free_kernel
r_extern
r_inline
r_void
id|pte_free_kernel
c_func
(paren
id|pte_t
op_star
id|pte
)paren
(brace
r_int
r_int
id|page
op_assign
(paren
r_int
r_int
)paren
id|pte
suffix:semicolon
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|pte
)paren
)braket
dot
id|reserved
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_return
suffix:semicolon
)brace
id|page
op_sub_assign
(paren
id|PT_OFFSET
op_minus
id|PAGE_OFFSET
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|function|pte_alloc_kernel
r_extern
r_inline
id|pte_t
op_star
id|pte_alloc_kernel
c_func
(paren
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|address
)paren
(brace
id|address
op_assign
(paren
id|address
op_rshift
id|PAGE_SHIFT
)paren
op_amp
(paren
id|PTRS_PER_PTE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
r_int
r_int
id|page
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
r_if
c_cond
(paren
id|page
)paren
(brace
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
dot
id|reserved
op_assign
l_int|1
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|page
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|sys_cacheflush
c_func
(paren
(paren
r_void
op_star
)paren
id|page
comma
id|PAGE_SIZE
comma
id|DCACHE
)paren
suffix:semicolon
id|sync_mem
c_func
(paren
)paren
suffix:semicolon
id|page
op_add_assign
(paren
id|PT_OFFSET
op_minus
id|PAGE_OFFSET
)paren
suffix:semicolon
id|pmd_set
c_func
(paren
id|pmd
comma
(paren
id|pte_t
op_star
)paren
id|page
)paren
suffix:semicolon
r_return
(paren
(paren
id|pte_t
op_star
)paren
id|page
)paren
op_plus
id|address
suffix:semicolon
)brace
id|pmd_set
c_func
(paren
id|pmd
comma
(paren
id|pte_t
op_star
)paren
id|BAD_PAGETABLE
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bad pmd in pte_alloc_kernel: %08lx&bslash;n&quot;
comma
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
)paren
suffix:semicolon
id|pmd_set
c_func
(paren
id|pmd
comma
(paren
id|pte_t
op_star
)paren
id|BAD_PAGETABLE
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
(paren
id|pte_t
op_star
)paren
(paren
id|pmd_page
c_func
(paren
op_star
id|pmd
)paren
op_plus
(paren
id|PT_OFFSET
op_minus
id|PAGE_OFFSET
)paren
)paren
op_plus
id|address
suffix:semicolon
)brace
multiline_comment|/*&n; * allocating and freeing a pmd is trivial: the 1-entry pmd is&n; * inside the pgd, so has no extra memory associated with it.&n; */
DECL|function|pmd_free_kernel
r_extern
r_inline
r_void
id|pmd_free_kernel
c_func
(paren
id|pmd_t
op_star
id|pmd
)paren
(brace
)brace
DECL|function|pmd_alloc_kernel
r_extern
r_inline
id|pmd_t
op_star
id|pmd_alloc_kernel
c_func
(paren
id|pgd_t
op_star
id|pgd
comma
r_int
r_int
id|address
)paren
(brace
r_return
(paren
id|pmd_t
op_star
)paren
id|pgd
suffix:semicolon
)brace
DECL|function|pte_free
r_extern
r_inline
r_void
id|pte_free
c_func
(paren
id|pte_t
op_star
id|pte
)paren
(brace
r_int
r_int
id|page
op_assign
(paren
r_int
r_int
)paren
id|pte
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_return
suffix:semicolon
)brace
id|page
op_sub_assign
(paren
id|PT_OFFSET
op_minus
id|PAGE_OFFSET
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
DECL|function|pte_alloc
r_extern
r_inline
id|pte_t
op_star
id|pte_alloc
c_func
(paren
id|pmd_t
op_star
id|pmd
comma
r_int
r_int
id|address
)paren
(brace
id|address
op_assign
(paren
id|address
op_rshift
id|PAGE_SHIFT
)paren
op_amp
(paren
id|PTRS_PER_PTE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
r_int
r_int
id|page
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmd_none
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
r_if
c_cond
(paren
id|page
)paren
(brace
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|page
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|sys_cacheflush
c_func
(paren
(paren
r_void
op_star
)paren
id|page
comma
id|PAGE_SIZE
comma
id|DCACHE
)paren
suffix:semicolon
id|sync_mem
c_func
(paren
)paren
suffix:semicolon
id|page
op_add_assign
(paren
id|PT_OFFSET
op_minus
id|PAGE_OFFSET
)paren
suffix:semicolon
id|pmd_set
c_func
(paren
id|pmd
comma
(paren
id|pte_t
op_star
)paren
id|page
)paren
suffix:semicolon
r_return
(paren
(paren
id|pte_t
op_star
)paren
id|page
)paren
op_plus
id|address
suffix:semicolon
)brace
id|pmd_set
c_func
(paren
id|pmd
comma
(paren
id|pte_t
op_star
)paren
id|BAD_PAGETABLE
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pmd_bad
c_func
(paren
op_star
id|pmd
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bad pmd in pte_alloc: %08lx&bslash;n&quot;
comma
id|pmd_val
c_func
(paren
op_star
id|pmd
)paren
)paren
suffix:semicolon
id|pmd_set
c_func
(paren
id|pmd
comma
(paren
id|pte_t
op_star
)paren
id|BAD_PAGETABLE
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
(paren
id|pte_t
op_star
)paren
(paren
id|pmd_page
c_func
(paren
op_star
id|pmd
)paren
op_plus
(paren
id|PT_OFFSET
op_minus
id|PAGE_OFFSET
)paren
)paren
op_plus
id|address
suffix:semicolon
)brace
multiline_comment|/*&n; * allocating and freeing a pmd is trivial: the 1-entry pmd is&n; * inside the pgd, so has no extra memory associated with it.&n; */
DECL|function|pmd_free
r_extern
r_inline
r_void
id|pmd_free
c_func
(paren
id|pmd_t
op_star
id|pmd
)paren
(brace
)brace
DECL|function|pmd_alloc
r_extern
r_inline
id|pmd_t
op_star
id|pmd_alloc
c_func
(paren
id|pgd_t
op_star
id|pgd
comma
r_int
r_int
id|address
)paren
(brace
r_return
(paren
id|pmd_t
op_star
)paren
id|pgd
suffix:semicolon
)brace
DECL|function|pgd_free
r_extern
r_inline
r_void
id|pgd_free
c_func
(paren
id|pgd_t
op_star
id|pgd
)paren
(brace
r_int
r_int
id|page
op_assign
(paren
r_int
r_int
)paren
id|pgd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_return
suffix:semicolon
)brace
id|page
op_sub_assign
(paren
id|PT_OFFSET
op_minus
id|PAGE_OFFSET
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize new page directory with pointers to invalid ptes&n; */
DECL|function|pgd_init
r_extern
r_inline
r_void
id|pgd_init
c_func
(paren
r_int
r_int
id|page
)paren
(brace
r_int
r_int
id|dummy1
comma
id|dummy2
suffix:semicolon
id|page
op_add_assign
(paren
id|PT_OFFSET
op_minus
id|PAGE_OFFSET
)paren
suffix:semicolon
macro_line|#if __mips &gt;= 3
multiline_comment|/*&n;&t; * Ich will Spass - ich geb Gas ich geb Gas...&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;.set&bslash;tnoreorder&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tnoat&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tmips3&bslash;n&bslash;t&quot;
l_string|&quot;dsll32&bslash;t$1,%2,0&bslash;n&bslash;t&quot;
l_string|&quot;dsrl32&bslash;t%2,$1,0&bslash;n&bslash;t&quot;
l_string|&quot;or&bslash;t%2,$1&bslash;n&quot;
l_string|&quot;1:&bslash;tsd&bslash;t%2,(%0)&bslash;n&bslash;t&quot;
l_string|&quot;subu&bslash;t%1,1&bslash;n&bslash;t&quot;
l_string|&quot;bnez&bslash;t%1,1b&bslash;n&bslash;t&quot;
l_string|&quot;addiu&bslash;t%0,8&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tmips0&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;tat&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;treorder&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|dummy1
)paren
comma
l_string|&quot;=r&quot;
(paren
id|dummy2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
(paren
(paren
r_int
r_int
)paren
id|invalid_pte_table
op_minus
id|PAGE_OFFSET
)paren
op_or
id|_PAGE_TABLE
)paren
comma
l_string|&quot;0&quot;
(paren
id|page
)paren
comma
l_string|&quot;1&quot;
(paren
id|PAGE_SIZE
op_div
(paren
r_sizeof
(paren
id|pmd_t
)paren
op_star
l_int|2
)paren
)paren
suffix:colon
l_string|&quot;$1&quot;
)paren
suffix:semicolon
macro_line|#else
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;.set&bslash;tnoreorder&bslash;n&quot;
l_string|&quot;1:&bslash;tsw&bslash;t%2,(%0)&bslash;n&bslash;t&quot;
l_string|&quot;subu&bslash;t%1,1&bslash;n&bslash;t&quot;
l_string|&quot;bnez&bslash;t%1,1b&bslash;n&bslash;t&quot;
l_string|&quot;addiu&bslash;t%0,4&bslash;n&bslash;t&quot;
l_string|&quot;.set&bslash;treorder&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|dummy1
)paren
comma
l_string|&quot;=r&quot;
(paren
id|dummy2
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
(paren
(paren
r_int
r_int
)paren
id|invalid_pte_table
op_minus
id|PAGE_OFFSET
)paren
op_or
id|_PAGE_TABLE
)paren
comma
l_string|&quot;0&quot;
(paren
id|page
)paren
comma
l_string|&quot;1&quot;
(paren
id|PAGE_SIZE
op_div
r_sizeof
(paren
id|pmd_t
)paren
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|pgd_alloc
r_extern
r_inline
id|pgd_t
op_star
id|pgd_alloc
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|sys_cacheflush
c_func
(paren
(paren
r_void
op_star
)paren
id|page
comma
id|PAGE_SIZE
comma
id|DCACHE
)paren
suffix:semicolon
id|sync_mem
c_func
(paren
)paren
suffix:semicolon
id|pgd_init
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
(paren
id|pgd_t
op_star
)paren
(paren
id|page
op_plus
(paren
id|PT_OFFSET
op_minus
id|PAGE_OFFSET
)paren
)paren
suffix:semicolon
)brace
r_extern
id|pgd_t
id|swapper_pg_dir
(braket
l_int|1024
)braket
suffix:semicolon
multiline_comment|/*&n; * MIPS doesn&squot;t need any external MMU info: the kernel page tables contain&n; * all the necessary information.  We use this hook though to load the&n; * TLB as early as possible with uptodate information avoiding unecessary&n; * exceptions.&n; */
r_extern
r_void
id|update_mmu_cache
c_func
(paren
r_struct
id|vm_area_struct
op_star
id|vma
comma
r_int
r_int
id|address
comma
id|pte_t
id|pte
)paren
suffix:semicolon
macro_line|#if __mips &gt;= 3
DECL|macro|SWP_TYPE
mdefine_line|#define SWP_TYPE(entry) (((entry) &gt;&gt; 32) &amp; 0xff)
DECL|macro|SWP_OFFSET
mdefine_line|#define SWP_OFFSET(entry) ((entry) &gt;&gt; 40)
DECL|macro|SWP_ENTRY
mdefine_line|#define SWP_ENTRY(type,offset) pte_val(mk_swap_pte((type),(offset)))
macro_line|#else
DECL|macro|SWP_TYPE
mdefine_line|#define SWP_TYPE(entry) (((entry) &gt;&gt; 1) &amp; 0x7f)
DECL|macro|SWP_OFFSET
mdefine_line|#define SWP_OFFSET(entry) ((entry) &gt;&gt; 8)
DECL|macro|SWP_ENTRY
mdefine_line|#define SWP_ENTRY(type,offset) (((type) &lt;&lt; 1) | ((offset) &lt;&lt; 8))
macro_line|#endif
macro_line|#endif /* !defined (__LANGUAGE_ASSEMBLY__) */
macro_line|#endif /* __ASM_MIPS_PGTABLE_H */
eof
