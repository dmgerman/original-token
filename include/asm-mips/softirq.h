macro_line|#ifndef __ASM_MIPS_SOFTIRQ_H
DECL|macro|__ASM_MIPS_SOFTIRQ_H
mdefine_line|#define __ASM_MIPS_SOFTIRQ_H
multiline_comment|/* The locking mechanism for base handlers, to prevent re-entrancy,&n; * is entirely private to an implementation, it should not be&n; * referenced at all outside of this file.&n; */
r_extern
id|atomic_t
id|__mips_bh_counter
suffix:semicolon
DECL|macro|get_active_bhs
mdefine_line|#define get_active_bhs()&t;(bh_mask &amp; bh_active)
DECL|function|clear_active_bhs
r_static
r_inline
r_void
id|clear_active_bhs
c_func
(paren
r_int
r_int
id|x
)paren
(brace
r_int
r_int
id|temp
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;1:&bslash;tll&bslash;t%0,%1&bslash;n&bslash;t&quot;
l_string|&quot;and&bslash;t%0,%2&bslash;n&bslash;t&quot;
l_string|&quot;sc&bslash;t%0,%1&bslash;n&bslash;t&quot;
l_string|&quot;beqz&bslash;t%0,1b&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|temp
)paren
comma
l_string|&quot;=m&quot;
(paren
id|bh_active
)paren
suffix:colon
l_string|&quot;Ir&quot;
(paren
id|x
)paren
comma
l_string|&quot;m&quot;
(paren
id|bh_active
)paren
)paren
suffix:semicolon
)brace
DECL|function|init_bh
r_extern
r_inline
r_void
id|init_bh
c_func
(paren
r_int
id|nr
comma
r_void
(paren
op_star
id|routine
)paren
(paren
r_void
)paren
)paren
(brace
id|bh_base
(braket
id|nr
)braket
op_assign
id|routine
suffix:semicolon
id|bh_mask_count
(braket
id|nr
)braket
op_assign
l_int|0
suffix:semicolon
id|bh_mask
op_or_assign
l_int|1
op_lshift
id|nr
suffix:semicolon
)brace
DECL|function|remove_bh
r_extern
r_inline
r_void
id|remove_bh
c_func
(paren
r_int
id|nr
)paren
(brace
id|bh_base
(braket
id|nr
)braket
op_assign
l_int|NULL
suffix:semicolon
id|bh_mask
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|nr
)paren
suffix:semicolon
)brace
DECL|function|mark_bh
r_extern
r_inline
r_void
id|mark_bh
c_func
(paren
r_int
id|nr
)paren
(brace
id|set_bit
c_func
(paren
id|nr
comma
op_amp
id|bh_active
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * These use a mask count to correctly handle&n; * nested disable/enable calls&n; */
DECL|function|disable_bh
r_extern
r_inline
r_void
id|disable_bh
c_func
(paren
r_int
id|nr
)paren
(brace
id|bh_mask
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|nr
)paren
suffix:semicolon
id|bh_mask_count
(braket
id|nr
)braket
op_increment
suffix:semicolon
)brace
DECL|function|enable_bh
r_extern
r_inline
r_void
id|enable_bh
c_func
(paren
r_int
id|nr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|bh_mask_count
(braket
id|nr
)braket
)paren
id|bh_mask
op_or_assign
l_int|1
op_lshift
id|nr
suffix:semicolon
)brace
multiline_comment|/*&n; * start_bh_atomic/end_bh_atomic also nest&n; * naturally by using a counter&n; */
DECL|function|start_bh_atomic
r_extern
r_inline
r_void
id|start_bh_atomic
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef __SMP__
id|atomic_inc
c_func
(paren
op_amp
id|__mips_bh_counter
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
id|atomic_inc
c_func
(paren
op_amp
id|__mips_bh_counter
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|end_bh_atomic
r_extern
r_inline
r_void
id|end_bh_atomic
c_func
(paren
r_void
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|__mips_bh_counter
)paren
suffix:semicolon
)brace
macro_line|#ifndef __SMP__
multiline_comment|/* These are for the irq&squot;s testing the lock */
DECL|macro|softirq_trylock
mdefine_line|#define softirq_trylock()&t;(atomic_read(&amp;__mips_bh_counter) ? &bslash;&n;&t;&t;&t;&t;0 : &bslash;&n;&t;&t;&t;&t;((atomic_set(&amp;__mips_bh_counter,1)),1))
DECL|macro|softirq_endlock
mdefine_line|#define softirq_endlock()&t;(atomic_set(&amp;__mips_bh_counter, 0))
macro_line|#else
macro_line|#error FIXME
macro_line|#endif /* __SMP__ */
macro_line|#endif /* __ASM_MIPS_SOFTIRQ_H */
eof
