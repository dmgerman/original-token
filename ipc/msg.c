multiline_comment|/*&n; * linux/ipc/msg.c&n; * Copyright (C) 1992 Krishna Balasubramanian &n; *&n; * Kerneld extensions by Bjorn Ekwall &lt;bj0rn@blox.se&gt; in May 1995&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/msg.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/kerneld.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
r_extern
r_int
id|ipcperms
(paren
r_struct
id|ipc_perm
op_star
id|ipcp
comma
r_int
id|msgflg
)paren
suffix:semicolon
r_static
r_void
id|freeque
(paren
r_int
id|id
)paren
suffix:semicolon
r_static
r_int
id|newque
(paren
id|key_t
id|key
comma
r_int
id|msgflg
)paren
suffix:semicolon
r_static
r_int
id|findkey
(paren
id|key_t
id|key
)paren
suffix:semicolon
DECL|variable|msgque
r_static
r_struct
id|msqid_ds
op_star
id|msgque
(braket
id|MSGMNI
)braket
suffix:semicolon
DECL|variable|msgbytes
r_static
r_int
id|msgbytes
op_assign
l_int|0
suffix:semicolon
DECL|variable|msghdrs
r_static
r_int
id|msghdrs
op_assign
l_int|0
suffix:semicolon
DECL|variable|msg_seq
r_static
r_int
r_int
id|msg_seq
op_assign
l_int|0
suffix:semicolon
DECL|variable|used_queues
r_static
r_int
id|used_queues
op_assign
l_int|0
suffix:semicolon
DECL|variable|max_msqid
r_static
r_int
id|max_msqid
op_assign
l_int|0
suffix:semicolon
DECL|variable|msg_lock
r_static
r_struct
id|wait_queue
op_star
id|msg_lock
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|kerneld_msqid
r_static
r_int
id|kerneld_msqid
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|macro|MAX_KERNELDS
mdefine_line|#define MAX_KERNELDS 20
DECL|variable|kerneld_arr
r_static
r_int
id|kerneld_arr
(braket
id|MAX_KERNELDS
)braket
suffix:semicolon
DECL|variable|n_kernelds
r_static
r_int
id|n_kernelds
op_assign
l_int|0
suffix:semicolon
DECL|function|msg_init
r_void
id|msg_init
(paren
r_void
)paren
(brace
r_int
id|id
suffix:semicolon
r_for
c_loop
(paren
id|id
op_assign
l_int|0
suffix:semicolon
id|id
OL
id|MSGMNI
suffix:semicolon
id|id
op_increment
)paren
id|msgque
(braket
id|id
)braket
op_assign
(paren
r_struct
id|msqid_ds
op_star
)paren
id|IPC_UNUSED
suffix:semicolon
id|msgbytes
op_assign
id|msghdrs
op_assign
id|msg_seq
op_assign
id|max_msqid
op_assign
id|used_queues
op_assign
l_int|0
suffix:semicolon
id|msg_lock
op_assign
l_int|NULL
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|real_msgsnd
r_static
r_int
id|real_msgsnd
(paren
r_int
id|msqid
comma
r_struct
id|msgbuf
op_star
id|msgp
comma
r_int
id|msgsz
comma
r_int
id|msgflg
)paren
(brace
r_int
id|id
comma
id|err
suffix:semicolon
r_struct
id|msqid_ds
op_star
id|msq
suffix:semicolon
r_struct
id|ipc_perm
op_star
id|ipcp
suffix:semicolon
r_struct
id|msg
op_star
id|msgh
suffix:semicolon
r_int
id|mtype
suffix:semicolon
r_if
c_cond
(paren
id|msgsz
OG
id|MSGMAX
op_logical_or
(paren
r_int
)paren
id|msgsz
OL
l_int|0
op_logical_or
id|msqid
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msgp
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t; * Calls from kernel level (IPC_KERNELD set)&n;&t; * have the message somewhere in kernel space already!&n;&t; */
r_if
c_cond
(paren
(paren
id|msgflg
op_amp
id|IPC_KERNELD
)paren
)paren
id|mtype
op_assign
id|msgp-&gt;mtype
suffix:semicolon
r_else
(brace
id|err
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
id|msgp-&gt;mtext
comma
id|msgsz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mtype
op_assign
id|get_user
(paren
op_amp
id|msgp-&gt;mtype
)paren
)paren
OL
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|id
op_assign
(paren
r_int
r_int
)paren
id|msqid
op_mod
id|MSGMNI
suffix:semicolon
id|msq
op_assign
id|msgque
(braket
id|id
)braket
suffix:semicolon
r_if
c_cond
(paren
id|msq
op_eq
id|IPC_UNUSED
op_logical_or
id|msq
op_eq
id|IPC_NOID
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ipcp
op_assign
op_amp
id|msq-&gt;msg_perm
suffix:semicolon
id|slept
suffix:colon
r_if
c_cond
(paren
id|msq-&gt;msg_perm.seq
op_ne
(paren
r_int
r_int
)paren
id|msqid
op_div
id|MSGMNI
)paren
r_return
op_minus
id|EIDRM
suffix:semicolon
multiline_comment|/*&n;&t; * Non-root processes may send to kerneld! &n;&t; * i.e. no permission check if called from the kernel&n;&t; * otoh we don&squot;t want user level non-root snoopers...&n;&t; */
r_if
c_cond
(paren
(paren
id|msgflg
op_amp
id|IPC_KERNELD
)paren
op_eq
l_int|0
)paren
r_if
c_cond
(paren
id|ipcperms
c_func
(paren
id|ipcp
comma
id|S_IWUGO
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|msgsz
op_plus
id|msq-&gt;msg_cbytes
OG
id|msq-&gt;msg_qbytes
)paren
(brace
multiline_comment|/* no space in queue */
r_if
c_cond
(paren
id|msgflg
op_amp
id|IPC_NOWAIT
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
r_if
c_cond
(paren
id|intr_count
)paren
(brace
multiline_comment|/* Very unlikely, but better safe than sorry... */
id|printk
c_func
(paren
l_string|&quot;Ouch, kerneld:msgsnd wants to sleep at interrupt!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|interruptible_sleep_on
(paren
op_amp
id|msq-&gt;wwait
)paren
suffix:semicolon
r_goto
id|slept
suffix:semicolon
)brace
multiline_comment|/* allocate message header and text space*/
id|msgh
op_assign
(paren
r_struct
id|msg
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
op_star
id|msgh
)paren
op_plus
id|msgsz
comma
(paren
id|intr_count
ques
c_cond
id|GFP_ATOMIC
suffix:colon
id|GFP_USER
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msgh
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|msgh-&gt;msg_spot
op_assign
(paren
r_char
op_star
)paren
(paren
id|msgh
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Calls from kernel level (IPC_KERNELD set)&n;&t; * have the message somewhere in kernel space already!&n;&t; */
r_if
c_cond
(paren
id|msgflg
op_amp
id|IPC_KERNELD
)paren
(brace
r_struct
id|kerneld_msg
op_star
id|kdmp
op_assign
(paren
r_struct
id|kerneld_msg
op_star
)paren
id|msgp
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Note that the kernel supplies a pointer&n;&t;&t; * but the user-level kerneld uses a char array...&n;&t;&t; */
id|memcpy
c_func
(paren
id|msgh-&gt;msg_spot
comma
(paren
r_char
op_star
)paren
(paren
op_amp
(paren
id|kdmp-&gt;id
)paren
)paren
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|msgh-&gt;msg_spot
op_plus
r_sizeof
(paren
r_int
)paren
comma
id|kdmp-&gt;text
comma
id|msgsz
op_minus
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
)brace
r_else
id|memcpy_fromfs
(paren
id|msgh-&gt;msg_spot
comma
id|msgp-&gt;mtext
comma
id|msgsz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msgque
(braket
id|id
)braket
op_eq
id|IPC_UNUSED
op_logical_or
id|msgque
(braket
id|id
)braket
op_eq
id|IPC_NOID
op_logical_or
id|msq-&gt;msg_perm.seq
op_ne
(paren
r_int
r_int
)paren
id|msqid
op_div
id|MSGMNI
)paren
(brace
id|kfree
c_func
(paren
id|msgh
)paren
suffix:semicolon
r_return
op_minus
id|EIDRM
suffix:semicolon
)brace
id|msgh-&gt;msg_next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msq-&gt;msg_first
)paren
id|msq-&gt;msg_first
op_assign
id|msq-&gt;msg_last
op_assign
id|msgh
suffix:semicolon
r_else
(brace
id|msq-&gt;msg_last-&gt;msg_next
op_assign
id|msgh
suffix:semicolon
id|msq-&gt;msg_last
op_assign
id|msgh
suffix:semicolon
)brace
id|msgh-&gt;msg_ts
op_assign
id|msgsz
suffix:semicolon
id|msgh-&gt;msg_type
op_assign
id|mtype
suffix:semicolon
id|msq-&gt;msg_cbytes
op_add_assign
id|msgsz
suffix:semicolon
id|msgbytes
op_add_assign
id|msgsz
suffix:semicolon
id|msghdrs
op_increment
suffix:semicolon
id|msq-&gt;msg_qnum
op_increment
suffix:semicolon
id|msq-&gt;msg_lspid
op_assign
id|current-&gt;pid
suffix:semicolon
id|msq-&gt;msg_stime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
id|msq-&gt;rwait
)paren
id|wake_up
(paren
op_amp
id|msq-&gt;rwait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Take care of missing kerneld, especially in case of multiple daemons&n; */
DECL|macro|KERNELD_TIMEOUT
mdefine_line|#define KERNELD_TIMEOUT 1 * (HZ)
DECL|macro|DROP_TIMER
mdefine_line|#define DROP_TIMER del_timer(&amp;kd_timer)
multiline_comment|/*#define DROP_TIMER if ((msgflg &amp; IPC_KERNELD) &amp;&amp; kd_timer.next &amp;&amp; kd_timer.prev) del_timer(&amp;kd_timer)*/
DECL|function|kd_timeout
r_static
r_void
id|kd_timeout
c_func
(paren
r_int
r_int
id|msgid
)paren
(brace
r_struct
id|msqid_ds
op_star
id|msq
suffix:semicolon
r_struct
id|msg
op_star
id|tmsg
suffix:semicolon
id|msq
op_assign
id|msgque
(braket
(paren
r_int
r_int
)paren
id|kerneld_msqid
op_mod
id|MSGMNI
)braket
suffix:semicolon
r_if
c_cond
(paren
id|msq
op_eq
id|IPC_NOID
op_logical_or
id|msq
op_eq
id|IPC_UNUSED
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|tmsg
op_assign
id|msq-&gt;msg_first
suffix:semicolon
id|tmsg
suffix:semicolon
id|tmsg
op_assign
id|tmsg-&gt;msg_next
)paren
r_if
c_cond
(paren
op_star
(paren
r_int
op_star
)paren
(paren
id|tmsg-&gt;msg_spot
)paren
op_eq
id|msgid
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|tmsg
)paren
(brace
multiline_comment|/* still there! */
r_struct
id|kerneld_msg
id|kmsp
op_assign
(brace
id|msgid
comma
op_minus
id|ENODEV
comma
l_string|&quot;&quot;
)brace
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ALERT
l_string|&quot;Ouch, kerneld timed out, message failed&bslash;n&quot;
)paren
suffix:semicolon
id|real_msgsnd
c_func
(paren
id|kerneld_msqid
comma
(paren
r_struct
id|msgbuf
op_star
)paren
op_amp
id|kmsp
comma
r_sizeof
(paren
r_int
)paren
comma
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|IPC_KERNELD
op_or
id|MSG_NOERROR
)paren
suffix:semicolon
)brace
)brace
DECL|function|real_msgrcv
r_static
r_int
id|real_msgrcv
(paren
r_int
id|msqid
comma
r_struct
id|msgbuf
op_star
id|msgp
comma
r_int
id|msgsz
comma
r_int
id|msgtyp
comma
r_int
id|msgflg
)paren
(brace
r_struct
id|timer_list
id|kd_timer
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_struct
id|msqid_ds
op_star
id|msq
suffix:semicolon
r_struct
id|ipc_perm
op_star
id|ipcp
suffix:semicolon
r_struct
id|msg
op_star
id|tmsg
comma
op_star
id|leastp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|msg
op_star
id|nmsg
op_assign
l_int|NULL
suffix:semicolon
r_int
id|id
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
id|msqid
OL
l_int|0
op_logical_or
(paren
r_int
)paren
id|msgsz
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msgp
op_logical_or
op_logical_neg
id|msgp-&gt;mtext
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t; * Calls from kernel level (IPC_KERNELD set)&n;&t; * wants the message put in kernel space!&n;&t; */
r_if
c_cond
(paren
(paren
id|msgflg
op_amp
id|IPC_KERNELD
)paren
op_eq
l_int|0
)paren
(brace
id|err
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
id|msgp-&gt;mtext
comma
id|msgsz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
)brace
id|id
op_assign
(paren
r_int
r_int
)paren
id|msqid
op_mod
id|MSGMNI
suffix:semicolon
id|msq
op_assign
id|msgque
(braket
id|id
)braket
suffix:semicolon
r_if
c_cond
(paren
id|msq
op_eq
id|IPC_NOID
op_logical_or
id|msq
op_eq
id|IPC_UNUSED
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ipcp
op_assign
op_amp
id|msq-&gt;msg_perm
suffix:semicolon
multiline_comment|/*&n;&t; * Start timer for missing kerneld&n;&t; */
r_if
c_cond
(paren
id|msgflg
op_amp
id|IPC_KERNELD
)paren
(brace
id|kd_timer.data
op_assign
(paren
r_int
r_int
)paren
id|msgtyp
suffix:semicolon
id|kd_timer.expires
op_assign
id|jiffies
op_plus
id|KERNELD_TIMEOUT
suffix:semicolon
id|kd_timer.function
op_assign
id|kd_timeout
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|kd_timer
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t; *  find message of correct type.&n;&t; *  msgtyp = 0 =&gt; get first.&n;&t; *  msgtyp &gt; 0 =&gt; get first message of matching type.&n;&t; *  msgtyp &lt; 0 =&gt; get message with least type must be &lt; abs(msgtype).  &n;&t; */
r_while
c_loop
(paren
op_logical_neg
id|nmsg
)paren
(brace
r_if
c_cond
(paren
id|msq-&gt;msg_perm.seq
op_ne
(paren
r_int
r_int
)paren
id|msqid
op_div
id|MSGMNI
)paren
(brace
id|DROP_TIMER
suffix:semicolon
r_return
op_minus
id|EIDRM
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|msgflg
op_amp
id|IPC_KERNELD
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Non-root processes may receive from kerneld! &n;&t;&t;&t; * i.e. no permission check if called from the kernel&n;&t;&t;&t; * otoh we don&squot;t want user level non-root snoopers...&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ipcperms
(paren
id|ipcp
comma
id|S_IRUGO
)paren
)paren
(brace
id|DROP_TIMER
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|msgtyp
op_eq
l_int|0
)paren
id|nmsg
op_assign
id|msq-&gt;msg_first
suffix:semicolon
r_else
r_if
c_cond
(paren
id|msgtyp
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|msgflg
op_amp
id|MSG_EXCEPT
)paren
(brace
r_for
c_loop
(paren
id|tmsg
op_assign
id|msq-&gt;msg_first
suffix:semicolon
id|tmsg
suffix:semicolon
id|tmsg
op_assign
id|tmsg-&gt;msg_next
)paren
r_if
c_cond
(paren
id|tmsg-&gt;msg_type
op_ne
id|msgtyp
)paren
r_break
suffix:semicolon
id|nmsg
op_assign
id|tmsg
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|tmsg
op_assign
id|msq-&gt;msg_first
suffix:semicolon
id|tmsg
suffix:semicolon
id|tmsg
op_assign
id|tmsg-&gt;msg_next
)paren
r_if
c_cond
(paren
id|tmsg-&gt;msg_type
op_eq
id|msgtyp
)paren
r_break
suffix:semicolon
id|nmsg
op_assign
id|tmsg
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|leastp
op_assign
id|tmsg
op_assign
id|msq-&gt;msg_first
suffix:semicolon
id|tmsg
suffix:semicolon
id|tmsg
op_assign
id|tmsg-&gt;msg_next
)paren
r_if
c_cond
(paren
id|tmsg-&gt;msg_type
OL
id|leastp-&gt;msg_type
)paren
id|leastp
op_assign
id|tmsg
suffix:semicolon
r_if
c_cond
(paren
id|leastp
op_logical_and
id|leastp-&gt;msg_type
op_le
op_minus
id|msgtyp
)paren
id|nmsg
op_assign
id|leastp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nmsg
)paren
(brace
multiline_comment|/* done finding a message */
id|DROP_TIMER
suffix:semicolon
r_if
c_cond
(paren
(paren
id|msgsz
OL
id|nmsg-&gt;msg_ts
)paren
op_logical_and
op_logical_neg
(paren
id|msgflg
op_amp
id|MSG_NOERROR
)paren
)paren
(brace
id|DROP_TIMER
suffix:semicolon
r_return
op_minus
id|E2BIG
suffix:semicolon
)brace
id|msgsz
op_assign
(paren
id|msgsz
OG
id|nmsg-&gt;msg_ts
)paren
ques
c_cond
id|nmsg-&gt;msg_ts
suffix:colon
id|msgsz
suffix:semicolon
r_if
c_cond
(paren
id|nmsg
op_eq
id|msq-&gt;msg_first
)paren
id|msq-&gt;msg_first
op_assign
id|nmsg-&gt;msg_next
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|tmsg
op_assign
id|msq-&gt;msg_first
suffix:semicolon
id|tmsg
suffix:semicolon
id|tmsg
op_assign
id|tmsg-&gt;msg_next
)paren
r_if
c_cond
(paren
id|tmsg-&gt;msg_next
op_eq
id|nmsg
)paren
r_break
suffix:semicolon
id|tmsg-&gt;msg_next
op_assign
id|nmsg-&gt;msg_next
suffix:semicolon
r_if
c_cond
(paren
id|nmsg
op_eq
id|msq-&gt;msg_last
)paren
id|msq-&gt;msg_last
op_assign
id|tmsg
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_decrement
id|msq-&gt;msg_qnum
)paren
)paren
id|msq-&gt;msg_last
op_assign
id|msq-&gt;msg_first
op_assign
l_int|NULL
suffix:semicolon
id|msq-&gt;msg_rtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|msq-&gt;msg_lrpid
op_assign
id|current-&gt;pid
suffix:semicolon
id|msgbytes
op_sub_assign
id|nmsg-&gt;msg_ts
suffix:semicolon
id|msghdrs
op_decrement
suffix:semicolon
id|msq-&gt;msg_cbytes
op_sub_assign
id|nmsg-&gt;msg_ts
suffix:semicolon
r_if
c_cond
(paren
id|msq-&gt;wwait
)paren
id|wake_up
(paren
op_amp
id|msq-&gt;wwait
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Calls from kernel level (IPC_KERNELD set)&n;&t;&t;&t; * wants the message copied to kernel space!&n;&t;&t;&t; */
r_if
c_cond
(paren
id|msgflg
op_amp
id|IPC_KERNELD
)paren
(brace
r_struct
id|kerneld_msg
op_star
id|kdmp
op_assign
(paren
r_struct
id|kerneld_msg
op_star
)paren
id|msgp
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
(paren
op_amp
(paren
id|kdmp-&gt;id
)paren
)paren
comma
id|nmsg-&gt;msg_spot
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Note that kdmp-&gt;text is a pointer&n;&t;&t;&t;&t; * when called from kernel space!&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|msgsz
OG
r_sizeof
(paren
r_int
)paren
)paren
op_logical_and
id|kdmp-&gt;text
)paren
id|memcpy
c_func
(paren
id|kdmp-&gt;text
comma
id|nmsg-&gt;msg_spot
op_plus
r_sizeof
(paren
r_int
)paren
comma
id|msgsz
op_minus
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|put_user
(paren
id|nmsg-&gt;msg_type
comma
op_amp
id|msgp-&gt;mtype
)paren
suffix:semicolon
id|memcpy_tofs
(paren
id|msgp-&gt;mtext
comma
id|nmsg-&gt;msg_spot
comma
id|msgsz
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|nmsg
)paren
suffix:semicolon
id|DROP_TIMER
suffix:semicolon
r_return
id|msgsz
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* did not find a message */
r_if
c_cond
(paren
id|msgflg
op_amp
id|IPC_NOWAIT
)paren
(brace
id|DROP_TIMER
suffix:semicolon
r_return
op_minus
id|ENOMSG
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|DROP_TIMER
suffix:semicolon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|intr_count
)paren
(brace
id|DROP_TIMER
suffix:semicolon
multiline_comment|/* Won&squot;t happen... */
id|printk
c_func
(paren
l_string|&quot;Ouch, kerneld:msgrcv wants to sleep at interrupt!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|interruptible_sleep_on
(paren
op_amp
id|msq-&gt;rwait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end while */
id|DROP_TIMER
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|sys_msgsnd
id|asmlinkage
r_int
id|sys_msgsnd
(paren
r_int
id|msqid
comma
r_struct
id|msgbuf
op_star
id|msgp
comma
r_int
id|msgsz
comma
r_int
id|msgflg
)paren
(brace
multiline_comment|/* IPC_KERNELD is used as a marker for kernel calls */
r_return
id|real_msgsnd
c_func
(paren
id|msqid
comma
id|msgp
comma
id|msgsz
comma
id|msgflg
op_amp
op_complement
id|IPC_KERNELD
)paren
suffix:semicolon
)brace
DECL|function|sys_msgrcv
id|asmlinkage
r_int
id|sys_msgrcv
(paren
r_int
id|msqid
comma
r_struct
id|msgbuf
op_star
id|msgp
comma
r_int
id|msgsz
comma
r_int
id|msgtyp
comma
r_int
id|msgflg
)paren
(brace
multiline_comment|/* IPC_KERNELD is used as a marker for kernel calls */
r_return
id|real_msgrcv
(paren
id|msqid
comma
id|msgp
comma
id|msgsz
comma
id|msgtyp
comma
id|msgflg
op_amp
op_complement
id|IPC_KERNELD
)paren
suffix:semicolon
)brace
DECL|function|findkey
r_static
r_int
id|findkey
(paren
id|key_t
id|key
)paren
(brace
r_int
id|id
suffix:semicolon
r_struct
id|msqid_ds
op_star
id|msq
suffix:semicolon
r_for
c_loop
(paren
id|id
op_assign
l_int|0
suffix:semicolon
id|id
op_le
id|max_msqid
suffix:semicolon
id|id
op_increment
)paren
(brace
r_while
c_loop
(paren
(paren
id|msq
op_assign
id|msgque
(braket
id|id
)braket
)paren
op_eq
id|IPC_NOID
)paren
id|interruptible_sleep_on
(paren
op_amp
id|msg_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msq
op_eq
id|IPC_UNUSED
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|key
op_eq
id|msq-&gt;msg_perm.key
)paren
r_return
id|id
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|newque
r_static
r_int
id|newque
(paren
id|key_t
id|key
comma
r_int
id|msgflg
)paren
(brace
r_int
id|id
suffix:semicolon
r_struct
id|msqid_ds
op_star
id|msq
suffix:semicolon
r_struct
id|ipc_perm
op_star
id|ipcp
suffix:semicolon
r_for
c_loop
(paren
id|id
op_assign
l_int|0
suffix:semicolon
id|id
OL
id|MSGMNI
suffix:semicolon
id|id
op_increment
)paren
r_if
c_cond
(paren
id|msgque
(braket
id|id
)braket
op_eq
id|IPC_UNUSED
)paren
(brace
id|msgque
(braket
id|id
)braket
op_assign
(paren
r_struct
id|msqid_ds
op_star
)paren
id|IPC_NOID
suffix:semicolon
r_goto
id|found
suffix:semicolon
)brace
r_return
op_minus
id|ENOSPC
suffix:semicolon
id|found
suffix:colon
id|msq
op_assign
(paren
r_struct
id|msqid_ds
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
op_star
id|msq
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|msq
)paren
(brace
id|msgque
(braket
id|id
)braket
op_assign
(paren
r_struct
id|msqid_ds
op_star
)paren
id|IPC_UNUSED
suffix:semicolon
r_if
c_cond
(paren
id|msg_lock
)paren
id|wake_up
(paren
op_amp
id|msg_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ipcp
op_assign
op_amp
id|msq-&gt;msg_perm
suffix:semicolon
id|ipcp-&gt;mode
op_assign
(paren
id|msgflg
op_amp
id|S_IRWXUGO
)paren
suffix:semicolon
id|ipcp-&gt;key
op_assign
id|key
suffix:semicolon
id|ipcp-&gt;cuid
op_assign
id|ipcp-&gt;uid
op_assign
id|current-&gt;euid
suffix:semicolon
id|ipcp-&gt;gid
op_assign
id|ipcp-&gt;cgid
op_assign
id|current-&gt;egid
suffix:semicolon
id|msq-&gt;msg_perm.seq
op_assign
id|msg_seq
suffix:semicolon
id|msq-&gt;msg_first
op_assign
id|msq-&gt;msg_last
op_assign
l_int|NULL
suffix:semicolon
id|msq-&gt;rwait
op_assign
id|msq-&gt;wwait
op_assign
l_int|NULL
suffix:semicolon
id|msq-&gt;msg_cbytes
op_assign
id|msq-&gt;msg_qnum
op_assign
l_int|0
suffix:semicolon
id|msq-&gt;msg_lspid
op_assign
id|msq-&gt;msg_lrpid
op_assign
l_int|0
suffix:semicolon
id|msq-&gt;msg_stime
op_assign
id|msq-&gt;msg_rtime
op_assign
l_int|0
suffix:semicolon
id|msq-&gt;msg_qbytes
op_assign
id|MSGMNB
suffix:semicolon
id|msq-&gt;msg_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
id|id
OG
id|max_msqid
)paren
id|max_msqid
op_assign
id|id
suffix:semicolon
id|msgque
(braket
id|id
)braket
op_assign
id|msq
suffix:semicolon
id|used_queues
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|msg_lock
)paren
id|wake_up
(paren
op_amp
id|msg_lock
)paren
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|msq-&gt;msg_perm.seq
op_star
id|MSGMNI
op_plus
id|id
suffix:semicolon
)brace
DECL|function|sys_msgget
id|asmlinkage
r_int
id|sys_msgget
(paren
id|key_t
id|key
comma
r_int
id|msgflg
)paren
(brace
r_int
id|id
suffix:semicolon
r_struct
id|msqid_ds
op_star
id|msq
suffix:semicolon
multiline_comment|/*&n;&t; * If the IPC_KERNELD flag is set, the key is forced to IPC_PRIVATE,&n;&t; * and a designated kerneld message queue is created/referred to&n;&t; */
r_if
c_cond
(paren
(paren
id|msgflg
op_amp
id|IPC_KERNELD
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|kerneld_msqid
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
id|kerneld_msqid
op_assign
id|newque
c_func
(paren
id|IPC_PRIVATE
comma
id|msgflg
op_amp
id|S_IRWXU
)paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_KERNELDS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|kerneld_arr
(braket
id|i
)braket
op_eq
l_int|0
)paren
(brace
id|kerneld_arr
(braket
id|i
)braket
op_assign
id|current-&gt;pid
suffix:semicolon
op_increment
id|n_kernelds
suffix:semicolon
r_return
id|kerneld_msqid
suffix:semicolon
)brace
)brace
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
multiline_comment|/* else it is a &quot;normal&quot; request */
r_if
c_cond
(paren
id|key
op_eq
id|IPC_PRIVATE
)paren
r_return
id|newque
c_func
(paren
id|key
comma
id|msgflg
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id
op_assign
id|findkey
(paren
id|key
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* key not used */
r_if
c_cond
(paren
op_logical_neg
(paren
id|msgflg
op_amp
id|IPC_CREAT
)paren
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_return
id|newque
c_func
(paren
id|key
comma
id|msgflg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msgflg
op_amp
id|IPC_CREAT
op_logical_and
id|msgflg
op_amp
id|IPC_EXCL
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
id|msq
op_assign
id|msgque
(braket
id|id
)braket
suffix:semicolon
r_if
c_cond
(paren
id|msq
op_eq
id|IPC_UNUSED
op_logical_or
id|msq
op_eq
id|IPC_NOID
)paren
r_return
op_minus
id|EIDRM
suffix:semicolon
r_if
c_cond
(paren
id|ipcperms
c_func
(paren
op_amp
id|msq-&gt;msg_perm
comma
id|msgflg
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|msq-&gt;msg_perm.seq
op_star
id|MSGMNI
op_plus
id|id
suffix:semicolon
)brace
DECL|function|freeque
r_static
r_void
id|freeque
(paren
r_int
id|id
)paren
(brace
r_struct
id|msqid_ds
op_star
id|msq
op_assign
id|msgque
(braket
id|id
)braket
suffix:semicolon
r_struct
id|msg
op_star
id|msgp
comma
op_star
id|msgh
suffix:semicolon
id|msq-&gt;msg_perm.seq
op_increment
suffix:semicolon
id|msg_seq
op_assign
(paren
id|msg_seq
op_plus
l_int|1
)paren
op_mod
(paren
(paren
r_int
)paren
(paren
l_int|1
op_lshift
l_int|31
)paren
op_div
id|MSGMNI
)paren
suffix:semicolon
multiline_comment|/* increment, but avoid overflow */
id|msgbytes
op_sub_assign
id|msq-&gt;msg_cbytes
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
id|max_msqid
)paren
r_while
c_loop
(paren
id|max_msqid
op_logical_and
(paren
id|msgque
(braket
op_decrement
id|max_msqid
)braket
op_eq
id|IPC_UNUSED
)paren
)paren
suffix:semicolon
id|msgque
(braket
id|id
)braket
op_assign
(paren
r_struct
id|msqid_ds
op_star
)paren
id|IPC_UNUSED
suffix:semicolon
id|used_queues
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|msq-&gt;rwait
op_logical_or
id|msq-&gt;wwait
)paren
(brace
r_if
c_cond
(paren
id|msq-&gt;rwait
)paren
id|wake_up
(paren
op_amp
id|msq-&gt;rwait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msq-&gt;wwait
)paren
id|wake_up
(paren
op_amp
id|msq-&gt;wwait
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|msgp
op_assign
id|msq-&gt;msg_first
suffix:semicolon
id|msgp
suffix:semicolon
id|msgp
op_assign
id|msgh
)paren
(brace
id|msgh
op_assign
id|msgp-&gt;msg_next
suffix:semicolon
id|msghdrs
op_decrement
suffix:semicolon
id|kfree
c_func
(paren
id|msgp
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|msq
)paren
suffix:semicolon
)brace
DECL|function|sys_msgctl
id|asmlinkage
r_int
id|sys_msgctl
(paren
r_int
id|msqid
comma
r_int
id|cmd
comma
r_struct
id|msqid_ds
op_star
id|buf
)paren
(brace
r_int
id|id
comma
id|err
suffix:semicolon
r_struct
id|msqid_ds
op_star
id|msq
suffix:semicolon
r_struct
id|msqid_ds
id|tbuf
suffix:semicolon
r_struct
id|ipc_perm
op_star
id|ipcp
suffix:semicolon
r_if
c_cond
(paren
id|msqid
OL
l_int|0
op_logical_or
id|cmd
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|IPC_INFO
suffix:colon
r_case
id|MSG_INFO
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
(brace
r_struct
id|msginfo
id|msginfo
suffix:semicolon
id|msginfo.msgmni
op_assign
id|MSGMNI
suffix:semicolon
id|msginfo.msgmax
op_assign
id|MSGMAX
suffix:semicolon
id|msginfo.msgmnb
op_assign
id|MSGMNB
suffix:semicolon
id|msginfo.msgmap
op_assign
id|MSGMAP
suffix:semicolon
id|msginfo.msgpool
op_assign
id|MSGPOOL
suffix:semicolon
id|msginfo.msgtql
op_assign
id|MSGTQL
suffix:semicolon
id|msginfo.msgssz
op_assign
id|MSGSSZ
suffix:semicolon
id|msginfo.msgseg
op_assign
id|MSGSEG
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|MSG_INFO
)paren
(brace
id|msginfo.msgpool
op_assign
id|used_queues
suffix:semicolon
id|msginfo.msgmap
op_assign
id|msghdrs
suffix:semicolon
id|msginfo.msgtql
op_assign
id|msgbytes
suffix:semicolon
)brace
id|err
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
id|buf
comma
r_sizeof
(paren
r_struct
id|msginfo
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|memcpy_tofs
(paren
id|buf
comma
op_amp
id|msginfo
comma
r_sizeof
(paren
r_struct
id|msginfo
)paren
)paren
suffix:semicolon
r_return
id|max_msqid
suffix:semicolon
)brace
r_case
id|MSG_STAT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
id|buf
comma
r_sizeof
(paren
op_star
id|buf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|msqid
OG
id|max_msqid
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|msq
op_assign
id|msgque
(braket
id|msqid
)braket
suffix:semicolon
r_if
c_cond
(paren
id|msq
op_eq
id|IPC_UNUSED
op_logical_or
id|msq
op_eq
id|IPC_NOID
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ipcperms
(paren
op_amp
id|msq-&gt;msg_perm
comma
id|S_IRUGO
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|id
op_assign
(paren
r_int
r_int
)paren
id|msq-&gt;msg_perm.seq
op_star
id|MSGMNI
op_plus
id|msqid
suffix:semicolon
id|tbuf.msg_perm
op_assign
id|msq-&gt;msg_perm
suffix:semicolon
id|tbuf.msg_stime
op_assign
id|msq-&gt;msg_stime
suffix:semicolon
id|tbuf.msg_rtime
op_assign
id|msq-&gt;msg_rtime
suffix:semicolon
id|tbuf.msg_ctime
op_assign
id|msq-&gt;msg_ctime
suffix:semicolon
id|tbuf.msg_cbytes
op_assign
id|msq-&gt;msg_cbytes
suffix:semicolon
id|tbuf.msg_qnum
op_assign
id|msq-&gt;msg_qnum
suffix:semicolon
id|tbuf.msg_qbytes
op_assign
id|msq-&gt;msg_qbytes
suffix:semicolon
id|tbuf.msg_lspid
op_assign
id|msq-&gt;msg_lspid
suffix:semicolon
id|tbuf.msg_lrpid
op_assign
id|msq-&gt;msg_lrpid
suffix:semicolon
id|memcpy_tofs
(paren
id|buf
comma
op_amp
id|tbuf
comma
r_sizeof
(paren
op_star
id|buf
)paren
)paren
suffix:semicolon
r_return
id|id
suffix:semicolon
r_case
id|IPC_SET
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
id|buf
comma
r_sizeof
(paren
op_star
id|buf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|tbuf
comma
id|buf
comma
r_sizeof
(paren
op_star
id|buf
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IPC_STAT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
id|buf
comma
r_sizeof
(paren
op_star
id|buf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
)brace
id|id
op_assign
(paren
r_int
r_int
)paren
id|msqid
op_mod
id|MSGMNI
suffix:semicolon
id|msq
op_assign
id|msgque
(braket
id|id
)braket
suffix:semicolon
r_if
c_cond
(paren
id|msq
op_eq
id|IPC_UNUSED
op_logical_or
id|msq
op_eq
id|IPC_NOID
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|msq-&gt;msg_perm.seq
op_ne
(paren
r_int
r_int
)paren
id|msqid
op_div
id|MSGMNI
)paren
r_return
op_minus
id|EIDRM
suffix:semicolon
id|ipcp
op_assign
op_amp
id|msq-&gt;msg_perm
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|IPC_STAT
suffix:colon
r_if
c_cond
(paren
id|ipcperms
(paren
id|ipcp
comma
id|S_IRUGO
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|tbuf.msg_perm
op_assign
id|msq-&gt;msg_perm
suffix:semicolon
id|tbuf.msg_stime
op_assign
id|msq-&gt;msg_stime
suffix:semicolon
id|tbuf.msg_rtime
op_assign
id|msq-&gt;msg_rtime
suffix:semicolon
id|tbuf.msg_ctime
op_assign
id|msq-&gt;msg_ctime
suffix:semicolon
id|tbuf.msg_cbytes
op_assign
id|msq-&gt;msg_cbytes
suffix:semicolon
id|tbuf.msg_qnum
op_assign
id|msq-&gt;msg_qnum
suffix:semicolon
id|tbuf.msg_qbytes
op_assign
id|msq-&gt;msg_qbytes
suffix:semicolon
id|tbuf.msg_lspid
op_assign
id|msq-&gt;msg_lspid
suffix:semicolon
id|tbuf.msg_lrpid
op_assign
id|msq-&gt;msg_lrpid
suffix:semicolon
id|memcpy_tofs
(paren
id|buf
comma
op_amp
id|tbuf
comma
r_sizeof
(paren
op_star
id|buf
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|IPC_SET
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
op_logical_and
id|current-&gt;euid
op_ne
id|ipcp-&gt;cuid
op_logical_and
id|current-&gt;euid
op_ne
id|ipcp-&gt;uid
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|tbuf.msg_qbytes
OG
id|MSGMNB
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|msq-&gt;msg_qbytes
op_assign
id|tbuf.msg_qbytes
suffix:semicolon
id|ipcp-&gt;uid
op_assign
id|tbuf.msg_perm.uid
suffix:semicolon
id|ipcp-&gt;gid
op_assign
id|tbuf.msg_perm.gid
suffix:semicolon
id|ipcp-&gt;mode
op_assign
(paren
id|ipcp-&gt;mode
op_amp
op_complement
id|S_IRWXUGO
)paren
op_or
(paren
id|S_IRWXUGO
op_amp
id|tbuf.msg_perm.mode
)paren
suffix:semicolon
id|msq-&gt;msg_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|IPC_RMID
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
op_logical_and
id|current-&gt;euid
op_ne
id|ipcp-&gt;cuid
op_logical_and
id|current-&gt;euid
op_ne
id|ipcp-&gt;uid
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/*&n;&t;&t; * There is only one kerneld message queue,&n;&t;&t; * mark it as non-existent&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|kerneld_msqid
op_ge
l_int|0
)paren
op_logical_and
(paren
id|msqid
op_eq
id|kerneld_msqid
)paren
)paren
id|kerneld_msqid
op_assign
op_minus
l_int|1
suffix:semicolon
id|freeque
(paren
id|id
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * We do perhaps need a &quot;flush&quot; for waiting processes,&n; * so that if they are terminated, a call from do_exit&n; * will minimize the possibility of orphaned received&n; * messages in the queue.  For now we just make sure&n; * that the queue is shut down whenever all kernelds have died.&n; */
DECL|function|kerneld_exit
r_void
id|kerneld_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|kerneld_msqid
op_eq
op_minus
l_int|1
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_KERNELDS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|kerneld_arr
(braket
id|i
)braket
op_eq
id|current-&gt;pid
)paren
(brace
id|kerneld_arr
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
op_decrement
id|n_kernelds
suffix:semicolon
r_if
c_cond
(paren
id|n_kernelds
op_eq
l_int|0
)paren
id|sys_msgctl
c_func
(paren
id|kerneld_msqid
comma
id|IPC_RMID
comma
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Kerneld internal message format/syntax:&n; *&n; * The message type from the kernel to kerneld is used to specify _what_&n; * function we want kerneld to perform. &n; *&n; * The &quot;normal&quot; message area is divided into a long, followed by a char array.&n; * The long is used to hold the sequence number of the request, which will&n; * be used as the return message type from kerneld back to the kernel.&n; * In the return message, the long will be used to store the exit status&n; * of the kerneld &quot;job&quot;, or task.&n; * The character array is used to pass parameters to kerneld and (optional)&n; * return information from kerneld back to the kernel.&n; * It is the responsibility of kerneld and the kernel level caller&n; * to set usable sizes on the parameter/return value array, since&n; * that information is _not_ included in the message format&n; */
multiline_comment|/*&n; * The basic kernel level entry point to kerneld.&n; *&t;msgtype should correspond to a task type for (a) kerneld&n; *&t;ret_size is the size of the (optional) return _value,&n; *&t;&t;OR-ed with KERNELD_WAIT if we want an answer&n; *&t;msgsize is the size (in bytes) of the message, not including&n; *&t;&t;the long that is always sent first in a kerneld message&n; *&t;text is the parameter for the kerneld specific task&n; *&t;ret_val is NULL or the kernel address where an expected answer&n; *&t;&t;from kerneld should be placed.&n; *&n; * See &lt;linux/kerneld.h&gt; for usage (inline convenience functions)&n; *&n; */
DECL|function|kerneld_send
r_int
id|kerneld_send
c_func
(paren
r_int
id|msgtype
comma
r_int
id|ret_size
comma
r_int
id|msgsz
comma
r_const
r_char
op_star
id|text
comma
r_const
r_char
op_star
id|ret_val
)paren
(brace
r_int
id|status
op_assign
op_minus
id|ENOSYS
suffix:semicolon
macro_line|#ifdef CONFIG_KERNELD
r_static
r_int
id|id
op_assign
id|KERNELD_MINSEQ
suffix:semicolon
r_struct
id|kerneld_msg
id|kmsp
op_assign
(brace
id|msgtype
comma
l_int|0
comma
(paren
r_char
op_star
)paren
id|text
)brace
suffix:semicolon
r_int
id|msgflg
op_assign
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|IPC_KERNELD
op_or
id|MSG_NOERROR
suffix:semicolon
r_if
c_cond
(paren
id|kerneld_msqid
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* Do not wait for an answer at interrupt-time! */
r_if
c_cond
(paren
id|intr_count
)paren
id|ret_size
op_and_assign
op_complement
id|KERNELD_WAIT
suffix:semicolon
id|msgsz
op_add_assign
r_sizeof
(paren
r_int
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_size
op_amp
id|KERNELD_WAIT
)paren
(brace
r_if
c_cond
(paren
op_increment
id|id
op_le
l_int|0
)paren
id|id
op_assign
id|KERNELD_MINSEQ
suffix:semicolon
id|kmsp.id
op_assign
id|id
suffix:semicolon
)brace
id|status
op_assign
id|real_msgsnd
c_func
(paren
id|kerneld_msqid
comma
(paren
r_struct
id|msgbuf
op_star
)paren
op_amp
id|kmsp
comma
id|msgsz
comma
id|msgflg
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_ge
l_int|0
)paren
op_logical_and
(paren
id|ret_size
op_amp
id|KERNELD_WAIT
)paren
)paren
(brace
id|ret_size
op_and_assign
op_complement
id|KERNELD_WAIT
suffix:semicolon
id|kmsp.text
op_assign
(paren
r_char
op_star
)paren
id|ret_val
suffix:semicolon
id|status
op_assign
id|real_msgrcv
c_func
(paren
id|kerneld_msqid
comma
(paren
r_struct
id|msgbuf
op_star
)paren
op_amp
id|kmsp
comma
r_sizeof
(paren
r_int
)paren
op_plus
(paren
(paren
id|ret_val
)paren
ques
c_cond
id|ret_size
suffix:colon
l_int|0
)paren
comma
id|kmsp.id
comma
id|msgflg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OG
l_int|0
)paren
multiline_comment|/* a valid answer contains at least a long */
id|status
op_assign
id|kmsp.id
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_KERNELD */
r_return
id|status
suffix:semicolon
)brace
eof
