multiline_comment|/*&n; * tkcond.c&n; *&n; * Eric Youngdale was the original author of xconfig.&n; * Michael Elizabeth Chastain (mec@shout.net) is the current maintainer.&n; *&n; * This file takes the tokenized statement list and transforms &squot;if ...&squot;&n; * statements.  For each simple statement, I find all of the &squot;if&squot; statements&n; * that enclose it, and attach the aggregate conditionals of those &squot;if&squot;&n; * statements to the cond list of the simple statement.&n; *&n; * 14 January 1999, Michael Elizabeth Chastain, &lt;mec@shout.net&gt;&n; * - Steam-clean this file.  I tested this by generating kconfig.tk for&n; *   every architecture and comparing it character-for-character against&n; *   the output of the old tkparse.&n; *&n; * 07 July 1999, Andrzej M. Krzysztofowicz &lt;ankry@mif.pg.gda.pl&gt;&n; * - kvariables removed; all variables are stored in a single table now&n; * - some elimination of options non-valid for current architecture&n; *   implemented.&n; * - negation (!) eliminated from conditions&n; *&n; * TO DO:&n; * - xconfig is at the end of its life cycle.  Contact &lt;mec@shout.net&gt; if&n; *   you are interested in working on the replacement.&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &quot;tkparse.h&quot;
multiline_comment|/*&n; * Mark variables which are defined anywhere.&n; */
DECL|function|mark_variables
r_static
r_void
id|mark_variables
c_func
(paren
r_struct
id|kconfig
op_star
id|scfg
)paren
(brace
r_struct
id|kconfig
op_star
id|cfg
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|max_varnum
suffix:semicolon
id|i
op_increment
)paren
id|vartable
(braket
id|i
)braket
dot
id|defined
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cfg-&gt;token
op_eq
id|token_bool
op_logical_or
id|cfg-&gt;token
op_eq
id|token_choice_item
op_logical_or
id|cfg-&gt;token
op_eq
id|token_define_bool
op_logical_or
id|cfg-&gt;token
op_eq
id|token_define_hex
op_logical_or
id|cfg-&gt;token
op_eq
id|token_define_int
op_logical_or
id|cfg-&gt;token
op_eq
id|token_define_string
op_logical_or
id|cfg-&gt;token
op_eq
id|token_define_tristate
op_logical_or
id|cfg-&gt;token
op_eq
id|token_dep_bool
op_logical_or
id|cfg-&gt;token
op_eq
id|token_dep_mbool
op_logical_or
id|cfg-&gt;token
op_eq
id|token_dep_tristate
op_logical_or
id|cfg-&gt;token
op_eq
id|token_hex
op_logical_or
id|cfg-&gt;token
op_eq
id|token_int
op_logical_or
id|cfg-&gt;token
op_eq
id|token_string
op_logical_or
id|cfg-&gt;token
op_eq
id|token_tristate
op_logical_or
id|cfg-&gt;token
op_eq
id|token_unset
)paren
(brace
r_if
c_cond
(paren
id|cfg-&gt;nameindex
OG
l_int|0
)paren
multiline_comment|/* paranoid */
(brace
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|defined
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|free_cond
r_static
r_void
id|free_cond
c_func
(paren
r_struct
id|condition
op_star
id|cond
)paren
(brace
r_struct
id|condition
op_star
id|tmp
comma
op_star
id|tmp1
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|cond
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp1
)paren
(brace
id|tmp1
op_assign
id|tmp-&gt;next
suffix:semicolon
id|free
c_func
(paren
(paren
r_void
op_star
)paren
id|tmp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Remove the bang operator from a condition to avoid priority problems.&n; * &quot;!&quot; has different priorities as &quot;test&quot; command argument and in &n; * a tk script.&n; */
DECL|function|remove_bang
r_static
r_struct
id|condition
op_star
id|remove_bang
c_func
(paren
r_struct
id|condition
op_star
id|condition
)paren
(brace
r_struct
id|condition
op_star
id|conda
comma
op_star
id|condb
comma
op_star
id|prev
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|conda
op_assign
id|condition
suffix:semicolon
id|conda
suffix:semicolon
id|conda
op_assign
id|conda-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|conda-&gt;op
op_eq
id|op_bang
op_logical_and
id|conda-&gt;next
op_logical_and
(paren
id|condb
op_assign
id|conda-&gt;next-&gt;next
)paren
)paren
(brace
r_if
c_cond
(paren
id|condb-&gt;op
op_eq
id|op_eq
op_logical_or
id|condb-&gt;op
op_eq
id|op_neq
)paren
(brace
id|condb-&gt;op
op_assign
(paren
id|condb-&gt;op
op_eq
id|op_eq
)paren
ques
c_cond
id|op_neq
suffix:colon
id|op_eq
suffix:semicolon
id|conda-&gt;op
op_assign
id|op_nuked
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
(brace
id|prev-&gt;next
op_assign
id|conda-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|condition
op_assign
id|conda-&gt;next
suffix:semicolon
)brace
id|conda-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|free_cond
c_func
(paren
id|conda
)paren
suffix:semicolon
id|conda
op_assign
id|condb
suffix:semicolon
)brace
)brace
id|prev
op_assign
id|conda
suffix:semicolon
)brace
r_return
id|condition
suffix:semicolon
)brace
multiline_comment|/*&n; * Make a new condition chain by joining the current condition stack with&n; * the &quot;&amp;&amp;&quot; operator for glue.&n; */
DECL|function|join_condition_stack
r_static
r_struct
id|condition
op_star
id|join_condition_stack
c_func
(paren
r_struct
id|condition
op_star
id|conditions
(braket
)braket
comma
r_int
id|depth
)paren
(brace
r_struct
id|condition
op_star
id|cond_list
suffix:semicolon
r_struct
id|condition
op_star
id|cond_last
suffix:semicolon
r_int
id|i
comma
id|is_first
op_assign
l_int|1
suffix:semicolon
id|cond_list
op_assign
id|cond_last
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|depth
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|conditions
(braket
id|i
)braket
op_member_access_from_pointer
id|op
op_eq
id|op_false
)paren
(brace
r_struct
id|condition
op_star
id|cnew
suffix:semicolon
multiline_comment|/* It is always false condition */
id|cnew
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|cnew
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cnew
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cnew
)paren
)paren
suffix:semicolon
id|cnew-&gt;op
op_assign
id|op_false
suffix:semicolon
id|cond_list
op_assign
id|cond_last
op_assign
id|cnew
suffix:semicolon
r_goto
id|join_done
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|depth
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|condition
op_star
id|cond
suffix:semicolon
r_struct
id|condition
op_star
id|cnew
suffix:semicolon
r_int
id|add_paren
suffix:semicolon
multiline_comment|/* omit always true conditions */
r_if
c_cond
(paren
id|conditions
(braket
id|i
)braket
op_member_access_from_pointer
id|op
op_eq
id|op_true
)paren
r_continue
suffix:semicolon
multiline_comment|/* if i have another condition, add an &squot;&amp;&amp;&squot; operator */
r_if
c_cond
(paren
op_logical_neg
id|is_first
)paren
(brace
id|cnew
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|cnew
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cnew
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cnew
)paren
)paren
suffix:semicolon
id|cnew-&gt;op
op_assign
id|op_and
suffix:semicolon
id|cond_last-&gt;next
op_assign
id|cnew
suffix:semicolon
id|cond_last
op_assign
id|cnew
suffix:semicolon
)brace
r_if
c_cond
(paren
id|conditions
(braket
id|i
)braket
op_member_access_from_pointer
id|op
op_ne
id|op_lparen
)paren
(brace
multiline_comment|/* add a &squot;(&squot; */
id|add_paren
op_assign
l_int|1
suffix:semicolon
id|cnew
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|cnew
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cnew
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cnew
)paren
)paren
suffix:semicolon
id|cnew-&gt;op
op_assign
id|op_lparen
suffix:semicolon
r_if
c_cond
(paren
id|cond_last
op_eq
l_int|NULL
)paren
(brace
id|cond_list
op_assign
id|cond_last
op_assign
id|cnew
suffix:semicolon
)brace
r_else
(brace
id|cond_last-&gt;next
op_assign
id|cnew
suffix:semicolon
id|cond_last
op_assign
id|cnew
suffix:semicolon
)brace
)brace
r_else
(brace
id|add_paren
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* duplicate the chain */
r_for
c_loop
(paren
id|cond
op_assign
id|conditions
(braket
id|i
)braket
suffix:semicolon
id|cond
op_ne
l_int|NULL
suffix:semicolon
id|cond
op_assign
id|cond-&gt;next
)paren
(brace
id|cnew
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|cnew
)paren
)paren
suffix:semicolon
id|cnew-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|cnew-&gt;op
op_assign
id|cond-&gt;op
suffix:semicolon
id|cnew-&gt;str
op_assign
id|cond-&gt;str
ques
c_cond
id|strdup
c_func
(paren
id|cond-&gt;str
)paren
suffix:colon
l_int|NULL
suffix:semicolon
id|cnew-&gt;nameindex
op_assign
id|cond-&gt;nameindex
suffix:semicolon
r_if
c_cond
(paren
id|cond_last
op_eq
l_int|NULL
)paren
(brace
id|cond_list
op_assign
id|cond_last
op_assign
id|cnew
suffix:semicolon
)brace
r_else
(brace
id|cond_last-&gt;next
op_assign
id|cnew
suffix:semicolon
id|cond_last
op_assign
id|cnew
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|add_paren
)paren
(brace
multiline_comment|/* add a &squot;)&squot; */
id|cnew
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|cnew
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cnew
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cnew
)paren
)paren
suffix:semicolon
id|cnew-&gt;op
op_assign
id|op_rparen
suffix:semicolon
id|cond_last-&gt;next
op_assign
id|cnew
suffix:semicolon
id|cond_last
op_assign
id|cnew
suffix:semicolon
)brace
id|is_first
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     * Remove duplicate conditions.&n;     */
(brace
r_struct
id|condition
op_star
id|cond1
comma
op_star
id|cond1b
comma
op_star
id|cond1c
comma
op_star
id|cond1d
comma
op_star
id|cond1e
comma
op_star
id|cond1f
suffix:semicolon
r_for
c_loop
(paren
id|cond1
op_assign
id|cond_list
suffix:semicolon
id|cond1
op_ne
l_int|NULL
suffix:semicolon
id|cond1
op_assign
id|cond1-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cond1-&gt;op
op_eq
id|op_lparen
)paren
(brace
id|cond1b
op_assign
id|cond1
op_member_access_from_pointer
id|next
suffix:semicolon
r_if
c_cond
(paren
id|cond1b
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|cond1c
op_assign
id|cond1b-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond1c
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|cond1d
op_assign
id|cond1c-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond1d
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|cond1e
op_assign
id|cond1d-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond1e
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|cond1f
op_assign
id|cond1e-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond1f
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|cond1b-&gt;op
op_eq
id|op_variable
op_logical_and
(paren
id|cond1c-&gt;op
op_eq
id|op_eq
op_logical_or
id|cond1c-&gt;op
op_eq
id|op_neq
)paren
op_logical_and
id|cond1d-&gt;op
op_eq
id|op_constant
op_logical_and
id|cond1e-&gt;op
op_eq
id|op_rparen
)paren
(brace
r_struct
id|condition
op_star
id|cond2
comma
op_star
id|cond2b
comma
op_star
id|cond2c
comma
op_star
id|cond2d
comma
op_star
id|cond2e
comma
op_star
id|cond2f
suffix:semicolon
r_for
c_loop
(paren
id|cond2
op_assign
id|cond1f-&gt;next
suffix:semicolon
id|cond2
op_ne
l_int|NULL
suffix:semicolon
id|cond2
op_assign
id|cond2-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cond2-&gt;op
op_eq
id|op_lparen
)paren
(brace
id|cond2b
op_assign
id|cond2
op_member_access_from_pointer
id|next
suffix:semicolon
r_if
c_cond
(paren
id|cond2b
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|cond2c
op_assign
id|cond2b-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond2c
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|cond2d
op_assign
id|cond2c-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond2d
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|cond2e
op_assign
id|cond2d-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond2e
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|cond2f
op_assign
id|cond2e-&gt;next
suffix:semicolon
multiline_comment|/* look for match */
r_if
c_cond
(paren
id|cond2b-&gt;op
op_eq
id|op_variable
op_logical_and
id|cond2b-&gt;nameindex
op_eq
id|cond1b-&gt;nameindex
op_logical_and
id|cond2c-&gt;op
op_eq
id|cond1c-&gt;op
op_logical_and
id|cond2d-&gt;op
op_eq
id|op_constant
op_logical_and
id|strcmp
c_func
(paren
id|cond2d-&gt;str
comma
id|cond1d-&gt;str
)paren
op_eq
l_int|0
op_logical_and
id|cond2e-&gt;op
op_eq
id|op_rparen
)paren
(brace
multiline_comment|/* one of these must be followed by &amp;&amp; */
r_if
c_cond
(paren
id|cond1f-&gt;op
op_eq
id|op_and
op_logical_or
(paren
id|cond2f
op_ne
l_int|NULL
op_logical_and
id|cond2f-&gt;op
op_eq
id|op_and
)paren
)paren
(brace
multiline_comment|/* nuke the first duplicate */
id|cond1
op_member_access_from_pointer
id|op
op_assign
id|op_nuked
suffix:semicolon
id|cond1b-&gt;op
op_assign
id|op_nuked
suffix:semicolon
id|cond1c-&gt;op
op_assign
id|op_nuked
suffix:semicolon
id|cond1d-&gt;op
op_assign
id|op_nuked
suffix:semicolon
id|cond1e-&gt;op
op_assign
id|op_nuked
suffix:semicolon
r_if
c_cond
(paren
id|cond1f-&gt;op
op_eq
id|op_and
)paren
id|cond1f-&gt;op
op_assign
id|op_nuked
suffix:semicolon
r_else
id|cond2f-&gt;op
op_assign
id|op_nuked
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
)brace
)brace
)brace
id|join_done
suffix:colon
r_return
id|cond_list
suffix:semicolon
)brace
DECL|variable|current_arch
r_static
r_char
op_star
id|current_arch
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * Eliminating conditions with ARCH = &lt;not current&gt;.&n; */
DECL|function|eliminate_other_arch
r_static
r_struct
id|condition
op_star
id|eliminate_other_arch
c_func
(paren
r_struct
id|condition
op_star
id|list
)paren
(brace
r_struct
id|condition
op_star
id|cond1a
op_assign
id|list
comma
op_star
id|cond1b
op_assign
l_int|NULL
comma
op_star
id|cond1c
op_assign
l_int|NULL
comma
op_star
id|cond1d
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|current_arch
op_eq
l_int|NULL
)paren
id|current_arch
op_assign
id|getenv
c_func
(paren
l_string|&quot;ARCH&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_arch
op_eq
l_int|NULL
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;error: ARCH undefined&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cond1a-&gt;op
op_eq
id|op_variable
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|vartable
(braket
id|cond1a-&gt;nameindex
)braket
dot
id|name
comma
l_string|&quot;ARCH&quot;
)paren
)paren
(brace
id|cond1b
op_assign
id|cond1a-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond1b
op_eq
l_int|NULL
)paren
r_goto
id|done
suffix:semicolon
id|cond1c
op_assign
id|cond1b-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond1c
op_eq
l_int|NULL
)paren
r_goto
id|done
suffix:semicolon
id|cond1d
op_assign
id|cond1c-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond1c-&gt;op
op_eq
id|op_constant
op_logical_and
id|cond1d
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|cond1b-&gt;op
op_eq
id|op_eq
op_logical_and
id|strcmp
c_func
(paren
id|cond1c-&gt;str
comma
id|current_arch
)paren
)paren
op_logical_or
(paren
id|cond1b-&gt;op
op_eq
id|op_neq
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|cond1c-&gt;str
comma
id|current_arch
)paren
)paren
)paren
(brace
multiline_comment|/* This is for another architecture */
id|cond1a-&gt;op
op_assign
id|op_false
suffix:semicolon
id|cond1a-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|free_cond
c_func
(paren
id|cond1b
)paren
suffix:semicolon
r_return
id|cond1a
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|cond1b-&gt;op
op_eq
id|op_neq
op_logical_and
id|strcmp
c_func
(paren
id|cond1c-&gt;str
comma
id|current_arch
)paren
)paren
op_logical_or
(paren
id|cond1b-&gt;op
op_eq
id|op_eq
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|cond1c-&gt;str
comma
id|current_arch
)paren
)paren
)paren
(brace
multiline_comment|/* This is for current architecture */
id|cond1a-&gt;op
op_assign
id|op_true
suffix:semicolon
id|cond1a-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|free_cond
c_func
(paren
id|cond1b
)paren
suffix:semicolon
r_return
id|cond1a
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|cond1c-&gt;op
op_eq
id|op_constant
op_logical_and
id|cond1d-&gt;op
op_eq
id|op_or
)paren
(brace
r_if
c_cond
(paren
(paren
id|cond1b-&gt;op
op_eq
id|op_eq
op_logical_and
id|strcmp
c_func
(paren
id|cond1c-&gt;str
comma
id|current_arch
)paren
)paren
op_logical_or
(paren
id|cond1b-&gt;op
op_eq
id|op_neq
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|cond1c-&gt;str
comma
id|current_arch
)paren
)paren
)paren
(brace
multiline_comment|/* This is for another architecture */
id|cond1b
op_assign
id|cond1d-&gt;next
suffix:semicolon
id|cond1d-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|free_cond
c_func
(paren
id|cond1a
)paren
suffix:semicolon
r_return
id|eliminate_other_arch
c_func
(paren
id|cond1b
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|cond1b-&gt;op
op_eq
id|op_neq
op_logical_and
id|strcmp
c_func
(paren
id|cond1c-&gt;str
comma
id|current_arch
)paren
)paren
op_logical_or
(paren
id|cond1b-&gt;op
op_eq
id|op_eq
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|cond1c-&gt;str
comma
id|current_arch
)paren
)paren
)paren
(brace
multiline_comment|/* This is for current architecture */
id|cond1a-&gt;op
op_assign
id|op_true
suffix:semicolon
id|cond1a-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|free_cond
c_func
(paren
id|cond1b
)paren
suffix:semicolon
r_return
id|cond1a
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|cond1c-&gt;op
op_eq
id|op_constant
op_logical_and
id|cond1d-&gt;op
op_eq
id|op_and
)paren
(brace
r_if
c_cond
(paren
(paren
id|cond1b-&gt;op
op_eq
id|op_eq
op_logical_and
id|strcmp
c_func
(paren
id|cond1c-&gt;str
comma
id|current_arch
)paren
)paren
op_logical_or
(paren
id|cond1b-&gt;op
op_eq
id|op_neq
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|cond1c-&gt;str
comma
id|current_arch
)paren
)paren
)paren
(brace
multiline_comment|/* This is for another architecture */
r_int
id|l_par
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|cond1c
op_assign
id|cond1d-&gt;next
suffix:semicolon
id|cond1c
suffix:semicolon
id|cond1c
op_assign
id|cond1c-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cond1c-&gt;op
op_eq
id|op_lparen
)paren
id|l_par
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cond1c-&gt;op
op_eq
id|op_rparen
)paren
id|l_par
op_decrement
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cond1c-&gt;op
op_eq
id|op_or
op_logical_and
id|l_par
op_eq
l_int|0
)paren
multiline_comment|/* Expression too complex - don&squot;t touch */
r_return
id|cond1a
suffix:semicolon
r_else
r_if
c_cond
(paren
id|l_par
OL
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;incorrect condition: programming error ?&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|cond1a-&gt;op
op_assign
id|op_false
suffix:semicolon
id|cond1a-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|free_cond
c_func
(paren
id|cond1b
)paren
suffix:semicolon
r_return
id|cond1a
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|cond1b-&gt;op
op_eq
id|op_neq
op_logical_and
id|strcmp
c_func
(paren
id|cond1c-&gt;str
comma
id|current_arch
)paren
)paren
op_logical_or
(paren
id|cond1b-&gt;op
op_eq
id|op_eq
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|cond1c-&gt;str
comma
id|current_arch
)paren
)paren
)paren
(brace
multiline_comment|/* This is for current architecture */
id|cond1b
op_assign
id|cond1d-&gt;next
suffix:semicolon
id|cond1d-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|free_cond
c_func
(paren
id|cond1a
)paren
suffix:semicolon
r_return
id|eliminate_other_arch
c_func
(paren
id|cond1b
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|cond1a-&gt;op
op_eq
id|op_variable
op_logical_and
op_logical_neg
id|vartable
(braket
id|cond1a-&gt;nameindex
)braket
dot
id|defined
)paren
(brace
id|cond1b
op_assign
id|cond1a-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond1b
op_eq
l_int|NULL
)paren
r_goto
id|done
suffix:semicolon
id|cond1c
op_assign
id|cond1b-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond1c
op_eq
l_int|NULL
)paren
r_goto
id|done
suffix:semicolon
id|cond1d
op_assign
id|cond1c-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond1c-&gt;op
op_eq
id|op_constant
op_logical_and
(paren
id|cond1d
op_eq
l_int|NULL
op_logical_or
id|cond1d-&gt;op
op_eq
id|op_and
)paren
)paren
multiline_comment|/*???*/
(brace
r_if
c_cond
(paren
id|cond1b-&gt;op
op_eq
id|op_eq
op_logical_and
id|strcmp
c_func
(paren
id|cond1c-&gt;str
comma
l_string|&quot;&quot;
)paren
)paren
(brace
id|cond1a-&gt;op
op_assign
id|op_false
suffix:semicolon
id|cond1a-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|free_cond
c_func
(paren
id|cond1b
)paren
suffix:semicolon
r_return
id|cond1a
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|cond1c-&gt;op
op_eq
id|op_constant
op_logical_and
id|cond1d-&gt;op
op_eq
id|op_or
)paren
(brace
r_if
c_cond
(paren
id|cond1b-&gt;op
op_eq
id|op_eq
op_logical_and
id|strcmp
c_func
(paren
id|cond1c-&gt;str
comma
l_string|&quot;&quot;
)paren
)paren
(brace
id|cond1b
op_assign
id|cond1d-&gt;next
suffix:semicolon
id|cond1d-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|free_cond
c_func
(paren
id|cond1a
)paren
suffix:semicolon
r_return
id|eliminate_other_arch
c_func
(paren
id|cond1b
)paren
suffix:semicolon
)brace
)brace
)brace
id|done
suffix:colon
r_return
id|list
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the main transformation function.&n; */
DECL|function|fix_conditionals
r_void
id|fix_conditionals
c_func
(paren
r_struct
id|kconfig
op_star
id|scfg
)paren
(brace
r_struct
id|kconfig
op_star
id|cfg
suffix:semicolon
multiline_comment|/*&n;     * Transform op_variable to op_kvariable.&n;     */
id|mark_variables
c_func
(paren
id|scfg
)paren
suffix:semicolon
multiline_comment|/*&n;     * Walk the statement list, maintaining a stack of current conditions.&n;     *   token_if      push its condition onto the stack.&n;     *   token_else    invert the condition on the top of the stack.&n;     *   token_endif   pop the stack.&n;     *&n;     * For a simple statement, create a condition chain by joining together&n;     * all of the conditions on the stack.&n;     */
(brace
r_struct
id|condition
op_star
id|cond_stack
(braket
l_int|32
)braket
suffix:semicolon
r_int
id|depth
op_assign
l_int|0
suffix:semicolon
r_struct
id|kconfig
op_star
id|prev
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_int
id|good
op_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|cfg-&gt;token
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|token_if
suffix:colon
id|cond_stack
(braket
id|depth
op_increment
)braket
op_assign
id|remove_bang
c_func
(paren
id|eliminate_other_arch
c_func
(paren
id|cfg-&gt;cond
)paren
)paren
suffix:semicolon
id|cfg-&gt;cond
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_else
suffix:colon
(brace
multiline_comment|/*&n;&t;&t;     * Invert the condition chain.&n;&t;&t;     *&n;&t;&t;     * Be careful to transfrom op_or to op_and1, not op_and.&n;&t;&t;     * I will need this later in the code that removes&n;&t;&t;     * duplicate conditions.&n;&t;&t;     */
r_struct
id|condition
op_star
id|cond
suffix:semicolon
r_for
c_loop
(paren
id|cond
op_assign
id|cond_stack
(braket
id|depth
op_minus
l_int|1
)braket
suffix:semicolon
id|cond
op_ne
l_int|NULL
suffix:semicolon
id|cond
op_assign
id|cond-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|cond-&gt;op
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|op_and
suffix:colon
id|cond-&gt;op
op_assign
id|op_or
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_or
suffix:colon
id|cond-&gt;op
op_assign
id|op_and1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_neq
suffix:colon
id|cond-&gt;op
op_assign
id|op_eq
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_eq
suffix:colon
id|cond-&gt;op
op_assign
id|op_neq
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_true
suffix:colon
id|cond-&gt;op
op_assign
id|op_false
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_false
suffix:colon
id|cond-&gt;op
op_assign
id|op_true
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_break
suffix:semicolon
r_case
id|token_fi
suffix:colon
op_decrement
id|depth
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_bool
suffix:colon
r_case
id|token_choice_item
suffix:colon
r_case
id|token_choice_header
suffix:colon
r_case
id|token_comment
suffix:colon
r_case
id|token_define_bool
suffix:colon
r_case
id|token_define_hex
suffix:colon
r_case
id|token_define_int
suffix:colon
r_case
id|token_define_string
suffix:colon
r_case
id|token_define_tristate
suffix:colon
r_case
id|token_endmenu
suffix:colon
r_case
id|token_hex
suffix:colon
r_case
id|token_int
suffix:colon
r_case
id|token_mainmenu_option
suffix:colon
r_case
id|token_string
suffix:colon
r_case
id|token_tristate
suffix:colon
r_case
id|token_unset
suffix:colon
id|cfg-&gt;cond
op_assign
id|join_condition_stack
c_func
(paren
id|cond_stack
comma
id|depth
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;cond
op_logical_and
id|cfg-&gt;cond-&gt;op
op_eq
id|op_false
)paren
(brace
id|good
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;next
op_assign
id|cfg-&gt;next
suffix:semicolon
r_else
id|scfg
op_assign
id|cfg-&gt;next
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|token_dep_bool
suffix:colon
r_case
id|token_dep_mbool
suffix:colon
r_case
id|token_dep_tristate
suffix:colon
multiline_comment|/*&n;&t;&t; * Same as the other simple statements, plus an additional&n;&t;&t; * condition for the dependency.&n;&t;&t; */
r_if
c_cond
(paren
id|cfg-&gt;cond
)paren
(brace
id|cond_stack
(braket
id|depth
)braket
op_assign
id|eliminate_other_arch
c_func
(paren
id|cfg-&gt;cond
)paren
suffix:semicolon
id|cfg-&gt;cond
op_assign
id|join_condition_stack
c_func
(paren
id|cond_stack
comma
id|depth
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|cfg-&gt;cond
op_assign
id|join_condition_stack
c_func
(paren
id|cond_stack
comma
id|depth
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cfg-&gt;cond
op_logical_and
id|cfg-&gt;cond-&gt;op
op_eq
id|op_false
)paren
(brace
id|good
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;next
op_assign
id|cfg-&gt;next
suffix:semicolon
r_else
id|scfg
op_assign
id|cfg-&gt;next
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|good
)paren
id|prev
op_assign
id|cfg
suffix:semicolon
)brace
)brace
)brace
macro_line|#if 0
r_void
id|dump_condition
c_func
(paren
r_struct
id|condition
op_star
id|list
)paren
(brace
r_struct
id|condition
op_star
id|tmp
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|list
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|tmp-&gt;op
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|op_variable
suffix:colon
id|printf
c_func
(paren
l_string|&quot; %s&quot;
comma
id|vartable
(braket
id|tmp-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_constant
suffix:colon
id|printf
c_func
(paren
l_string|&quot; %s&quot;
comma
id|tmp-&gt;str
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_eq
suffix:colon
id|printf
c_func
(paren
l_string|&quot; =&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_bang
suffix:colon
id|printf
c_func
(paren
l_string|&quot; !&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_neq
suffix:colon
id|printf
c_func
(paren
l_string|&quot; !=&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_and
suffix:colon
r_case
id|op_and1
suffix:colon
id|printf
c_func
(paren
l_string|&quot; -a&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_or
suffix:colon
id|printf
c_func
(paren
l_string|&quot; -o&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_true
suffix:colon
id|printf
c_func
(paren
l_string|&quot; TRUE&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_false
suffix:colon
id|printf
c_func
(paren
l_string|&quot; FALSE&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_lparen
suffix:colon
id|printf
c_func
(paren
l_string|&quot; (&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_rparen
suffix:colon
id|printf
c_func
(paren
l_string|&quot; )&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
