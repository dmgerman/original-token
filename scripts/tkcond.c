multiline_comment|/*&n; * tkcond.c&n; *&n; * Eric Youngdale was the original author of xconfig.&n; * Michael Elizabeth Chastain (mec@shout.net) is the current maintainer.&n; *&n; * This file takes the tokenized statement list and transforms &squot;if ...&squot;&n; * statements.  For each simple statement, I find all of the &squot;if&squot; statements&n; * that enclose it, and attach the aggregate conditionals of those &squot;if&squot;&n; * statements to the cond list of the simple statement.&n; *&n; * 14 January 1999, Michael Elizabeth Chastain, &lt;mec@shout.net&gt;&n; * - Steam-clean this file.  I tested this by generating kconfig.tk for&n; *   every architecture and comparing it character-for-character against&n; *   the output of the old tkparse.&n; *&n; * TO DO:&n; * - xconfig is at the end of its life cycle.  Contact &lt;mec@shout.net&gt; if&n; *   you are interested in working on the replacement.&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &quot;tkparse.h&quot;
multiline_comment|/*&n; * Transform op_variable to op_kvariable.&n; *&n; * This works, but it&squot;s gross, speed-wise.  It would benefit greatly&n; * from a simple hash table that maps names to cfg.&n; *&n; * Note well: this is actually better than the loop structure xconfig&n; * has been staggering along with for three years, which performs&n; * this whole procedure inside *another* loop on active conditionals.&n; */
DECL|function|transform_to_kvariable
r_void
id|transform_to_kvariable
c_func
(paren
r_struct
id|kconfig
op_star
id|scfg
)paren
(brace
r_struct
id|kconfig
op_star
id|cfg
suffix:semicolon
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_struct
id|condition
op_star
id|cond
suffix:semicolon
r_for
c_loop
(paren
id|cond
op_assign
id|cfg-&gt;cond
suffix:semicolon
id|cond
op_ne
l_int|NULL
suffix:semicolon
id|cond
op_assign
id|cond-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cond-&gt;op
op_eq
id|op_variable
)paren
(brace
multiline_comment|/* Here&squot;s where it gets DISGUSTING. */
r_struct
id|kconfig
op_star
id|cfg1
suffix:semicolon
r_for
c_loop
(paren
id|cfg1
op_assign
id|scfg
suffix:semicolon
id|cfg1
op_ne
l_int|NULL
suffix:semicolon
id|cfg1
op_assign
id|cfg1-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cfg1-&gt;token
op_eq
id|token_bool
op_logical_or
id|cfg1-&gt;token
op_eq
id|token_choice_item
op_logical_or
id|cfg1-&gt;token
op_eq
id|token_dep_tristate
op_logical_or
id|cfg1-&gt;token
op_eq
id|token_hex
op_logical_or
id|cfg1-&gt;token
op_eq
id|token_int
op_logical_or
id|cfg1-&gt;token
op_eq
id|token_string
op_logical_or
id|cfg1-&gt;token
op_eq
id|token_tristate
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cond-&gt;str
comma
id|cfg1-&gt;optionname
)paren
op_eq
l_int|0
)paren
(brace
id|cond-&gt;op
op_assign
id|op_kvariable
suffix:semicolon
id|cond-&gt;str
op_assign
l_int|NULL
suffix:semicolon
id|cond-&gt;cfg
op_assign
id|cfg1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#if 0
multiline_comment|/*&n;&t;     * Maybe someday this will be useful, but right now it&n;&t;     * gives a lot of false positives on files like&n;&t;     * drivers/video/Config.in that are meant for more&n;&t;     * than one architecture.  Turn it on if you want to play&n;&t;     * with it though; it does work.  -- mec&n;&t;     */
r_if
c_cond
(paren
id|cond-&gt;op
op_eq
id|op_variable
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cond-&gt;str
comma
l_string|&quot;ARCH&quot;
)paren
op_ne
l_int|0
op_logical_and
id|strcmp
c_func
(paren
id|cond-&gt;str
comma
l_string|&quot;CONSTANT_Y&quot;
)paren
op_ne
l_int|0
op_logical_and
id|strcmp
c_func
(paren
id|cond-&gt;str
comma
l_string|&quot;CONSTANT_M&quot;
)paren
op_ne
l_int|0
op_logical_and
id|strcmp
c_func
(paren
id|cond-&gt;str
comma
l_string|&quot;CONSTANT_N&quot;
)paren
op_ne
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;warning: $%s used but not defined&bslash;n&quot;
comma
id|cond-&gt;str
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
)brace
)brace
multiline_comment|/*&n; * Make a new condition chain by joining the current condition stack with&n; * the &quot;&amp;&amp;&quot; operator for glue.&n; */
DECL|function|join_condition_stack
r_struct
id|condition
op_star
id|join_condition_stack
c_func
(paren
r_struct
id|condition
op_star
id|conditions
(braket
)braket
comma
r_int
id|depth
)paren
(brace
r_struct
id|condition
op_star
id|cond_list
suffix:semicolon
r_struct
id|condition
op_star
id|cond_last
suffix:semicolon
r_int
id|i
suffix:semicolon
id|cond_list
op_assign
id|cond_last
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|depth
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|condition
op_star
id|cond
suffix:semicolon
r_struct
id|condition
op_star
id|cnew
suffix:semicolon
multiline_comment|/* add a &squot;(&squot; */
id|cnew
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|cnew
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cnew
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cnew
)paren
)paren
suffix:semicolon
id|cnew-&gt;op
op_assign
id|op_lparen
suffix:semicolon
r_if
c_cond
(paren
id|cond_last
op_eq
l_int|NULL
)paren
(brace
id|cond_list
op_assign
id|cond_last
op_assign
id|cnew
suffix:semicolon
)brace
r_else
(brace
id|cond_last-&gt;next
op_assign
id|cnew
suffix:semicolon
id|cond_last
op_assign
id|cnew
suffix:semicolon
)brace
multiline_comment|/* duplicate the chain */
r_for
c_loop
(paren
id|cond
op_assign
id|conditions
(braket
id|i
)braket
suffix:semicolon
id|cond
op_ne
l_int|NULL
suffix:semicolon
id|cond
op_assign
id|cond-&gt;next
)paren
(brace
id|cnew
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|cnew
)paren
)paren
suffix:semicolon
id|cnew-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|cnew-&gt;op
op_assign
id|cond-&gt;op
suffix:semicolon
id|cnew-&gt;str
op_assign
id|cond-&gt;str
ques
c_cond
id|strdup
c_func
(paren
id|cond-&gt;str
)paren
suffix:colon
l_int|NULL
suffix:semicolon
id|cnew-&gt;cfg
op_assign
id|cond-&gt;cfg
suffix:semicolon
id|cond_last-&gt;next
op_assign
id|cnew
suffix:semicolon
id|cond_last
op_assign
id|cnew
suffix:semicolon
)brace
multiline_comment|/* add a &squot;)&squot; */
id|cnew
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|cnew
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cnew
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cnew
)paren
)paren
suffix:semicolon
id|cnew-&gt;op
op_assign
id|op_rparen
suffix:semicolon
id|cond_last-&gt;next
op_assign
id|cnew
suffix:semicolon
id|cond_last
op_assign
id|cnew
suffix:semicolon
multiline_comment|/* if i have another condition, add an &squot;&amp;&amp;&squot; operator */
r_if
c_cond
(paren
id|i
OL
id|depth
op_minus
l_int|1
)paren
(brace
id|cnew
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|cnew
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cnew
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cnew
)paren
)paren
suffix:semicolon
id|cnew-&gt;op
op_assign
id|op_and
suffix:semicolon
id|cond_last-&gt;next
op_assign
id|cnew
suffix:semicolon
id|cond_last
op_assign
id|cnew
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * Remove duplicate conditions.&n;     */
(brace
r_struct
id|condition
op_star
id|cond1
comma
op_star
id|cond1b
comma
op_star
id|cond1c
comma
op_star
id|cond1d
comma
op_star
id|cond1e
comma
op_star
id|cond1f
suffix:semicolon
r_for
c_loop
(paren
id|cond1
op_assign
id|cond_list
suffix:semicolon
id|cond1
op_ne
l_int|NULL
suffix:semicolon
id|cond1
op_assign
id|cond1-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cond1-&gt;op
op_eq
id|op_lparen
)paren
(brace
id|cond1b
op_assign
id|cond1
op_member_access_from_pointer
id|next
suffix:semicolon
r_if
c_cond
(paren
id|cond1b
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|cond1c
op_assign
id|cond1b-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond1c
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|cond1d
op_assign
id|cond1c-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond1d
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|cond1e
op_assign
id|cond1d-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond1e
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|cond1f
op_assign
id|cond1e-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond1f
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|cond1b-&gt;op
op_eq
id|op_kvariable
op_logical_and
(paren
id|cond1c-&gt;op
op_eq
id|op_eq
op_logical_or
id|cond1c-&gt;op
op_eq
id|op_neq
)paren
op_logical_and
id|cond1d-&gt;op
op_eq
id|op_constant
op_logical_and
id|cond1e-&gt;op
op_eq
id|op_rparen
)paren
(brace
r_struct
id|condition
op_star
id|cond2
comma
op_star
id|cond2b
comma
op_star
id|cond2c
comma
op_star
id|cond2d
comma
op_star
id|cond2e
comma
op_star
id|cond2f
suffix:semicolon
r_for
c_loop
(paren
id|cond2
op_assign
id|cond1f-&gt;next
suffix:semicolon
id|cond2
op_ne
l_int|NULL
suffix:semicolon
id|cond2
op_assign
id|cond2-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cond2-&gt;op
op_eq
id|op_lparen
)paren
(brace
id|cond2b
op_assign
id|cond2
op_member_access_from_pointer
id|next
suffix:semicolon
r_if
c_cond
(paren
id|cond2b
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|cond2c
op_assign
id|cond2b-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond2c
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|cond2d
op_assign
id|cond2c-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond2d
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|cond2e
op_assign
id|cond2d-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|cond2e
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|cond2f
op_assign
id|cond2e-&gt;next
suffix:semicolon
multiline_comment|/* look for match */
r_if
c_cond
(paren
id|cond2b-&gt;op
op_eq
id|op_kvariable
op_logical_and
id|cond2b-&gt;cfg
op_eq
id|cond1b-&gt;cfg
op_logical_and
id|cond2c-&gt;op
op_eq
id|cond1c-&gt;op
op_logical_and
id|cond2d-&gt;op
op_eq
id|op_constant
op_logical_and
id|strcmp
c_func
(paren
id|cond2d-&gt;str
comma
id|cond1d-&gt;str
)paren
op_eq
l_int|0
op_logical_and
id|cond2e-&gt;op
op_eq
id|op_rparen
)paren
(brace
multiline_comment|/* one of these must be followed by &amp;&amp; */
r_if
c_cond
(paren
id|cond1f-&gt;op
op_eq
id|op_and
op_logical_or
(paren
id|cond2f
op_ne
l_int|NULL
op_logical_and
id|cond2f-&gt;op
op_eq
id|op_and
)paren
)paren
(brace
multiline_comment|/* nuke the first duplicate */
id|cond1
op_member_access_from_pointer
id|op
op_assign
id|op_nuked
suffix:semicolon
id|cond1b-&gt;op
op_assign
id|op_nuked
suffix:semicolon
id|cond1c-&gt;op
op_assign
id|op_nuked
suffix:semicolon
id|cond1d-&gt;op
op_assign
id|op_nuked
suffix:semicolon
id|cond1e-&gt;op
op_assign
id|op_nuked
suffix:semicolon
r_if
c_cond
(paren
id|cond1f-&gt;op
op_eq
id|op_and
)paren
id|cond1f-&gt;op
op_assign
id|op_nuked
suffix:semicolon
r_else
id|cond2f-&gt;op
op_assign
id|op_nuked
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
)brace
)brace
)brace
r_return
id|cond_list
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the main transformation function.&n; */
DECL|function|fix_conditionals
r_void
id|fix_conditionals
c_func
(paren
r_struct
id|kconfig
op_star
id|scfg
)paren
(brace
r_struct
id|kconfig
op_star
id|cfg
suffix:semicolon
multiline_comment|/*&n;     * Transform op_variable to op_kvariable.&n;     */
id|transform_to_kvariable
c_func
(paren
id|scfg
)paren
suffix:semicolon
multiline_comment|/*&n;     * Transform conditions that use variables from &quot;choice&quot; statements.&n;     * Choice values appear to the user as a collection of booleans, and the&n;     * script can test the individual booleans.  But internally, all I have is&n;     * the N-way value of an unnamed temporary for the whole statement.  So I&n;     * have to tranform &squot;&quot;$CONFIG_M386&quot; != &quot;y&quot;&squot;&n;     * into &squot;&quot;$tmpvar_N&quot; != &quot;CONFIG_M386&quot;&squot;.&n;     */
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_struct
id|condition
op_star
id|cond
suffix:semicolon
r_for
c_loop
(paren
id|cond
op_assign
id|cfg-&gt;cond
suffix:semicolon
id|cond
op_ne
l_int|NULL
suffix:semicolon
id|cond
op_assign
id|cond-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cond-&gt;op
op_eq
id|op_kvariable
op_logical_and
id|cond-&gt;cfg-&gt;token
op_eq
id|token_choice_item
)paren
(brace
multiline_comment|/*&n;&t;&t; * Look two more tokens down for the comparison token.&n;&t;&t; * It has to be &quot;y&quot; for this trick to work.&n;&t;&t; *&n;&t;&t; * If you get this error, don&squot;t even think about relaxing the&n;&t;&t; * strcmp test.  You will produce incorrect TK code.  Instead,&n;&t;&t; * look for the place in your Config.in script where you are&n;&t;&t; * comparing a &squot;choice&squot; variable to a value other than &squot;y&squot;,&n;&t;&t; * and rewrite the comparison to be &squot;= &quot;y&quot;&squot; or &squot;!= &quot;y&quot;&squot;.&n;&t;&t; */
r_struct
id|condition
op_star
id|cond2
op_assign
id|cond-&gt;next-&gt;next
suffix:semicolon
r_const
r_char
op_star
id|label
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cond2-&gt;str
comma
l_string|&quot;y&quot;
)paren
op_ne
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;tkparse choked in fix_choice_cond&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|label
op_assign
id|cond-&gt;cfg-&gt;label
suffix:semicolon
id|cond-&gt;cfg
op_assign
id|cond-&gt;cfg-&gt;cfg_parent
suffix:semicolon
id|cond2-&gt;str
op_assign
id|strdup
c_func
(paren
id|label
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;     * Walk the statement list, maintaining a stack of current conditions.&n;     *   token_if      push its condition onto the stack.&n;     *   token_else    invert the condition on the top of the stack.&n;     *   token_endif   pop the stack.&n;     *&n;     * For a simple statement, create a condition chain by joining together&n;     * all of the conditions on the stack.&n;     */
(brace
r_struct
id|condition
op_star
id|cond_stack
(braket
l_int|32
)braket
suffix:semicolon
r_int
id|depth
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|cfg-&gt;token
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|token_if
suffix:colon
id|cond_stack
(braket
id|depth
op_increment
)braket
op_assign
id|cfg-&gt;cond
suffix:semicolon
id|cfg-&gt;cond
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_else
suffix:colon
(brace
multiline_comment|/*&n;&t;&t;     * Invert the condition chain.&n;&t;&t;     *&n;&t;&t;     * Be careful to transfrom op_or to op_and1, not op_and.&n;&t;&t;     * I will need this later in the code that removes&n;&t;&t;     * duplicate conditions.&n;&t;&t;     */
r_struct
id|condition
op_star
id|cond
suffix:semicolon
r_for
c_loop
(paren
id|cond
op_assign
id|cond_stack
(braket
id|depth
op_minus
l_int|1
)braket
suffix:semicolon
id|cond
op_ne
l_int|NULL
suffix:semicolon
id|cond
op_assign
id|cond-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|cond-&gt;op
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|op_and
suffix:colon
id|cond-&gt;op
op_assign
id|op_or
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_or
suffix:colon
id|cond-&gt;op
op_assign
id|op_and1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_neq
suffix:colon
id|cond-&gt;op
op_assign
id|op_eq
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_eq
suffix:colon
id|cond-&gt;op
op_assign
id|op_neq
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_break
suffix:semicolon
r_case
id|token_fi
suffix:colon
op_decrement
id|depth
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_bool
suffix:colon
r_case
id|token_choice_item
suffix:colon
r_case
id|token_comment
suffix:colon
r_case
id|token_define_bool
suffix:colon
r_case
id|token_hex
suffix:colon
r_case
id|token_int
suffix:colon
r_case
id|token_mainmenu_option
suffix:colon
r_case
id|token_string
suffix:colon
r_case
id|token_tristate
suffix:colon
id|cfg-&gt;cond
op_assign
id|join_condition_stack
c_func
(paren
id|cond_stack
comma
id|depth
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_dep_tristate
suffix:colon
multiline_comment|/*&n;&t;&t; * Same as the other simple statements, plus an additional&n;&t;&t; * condition for the dependency.&n;&t;&t; */
id|cond_stack
(braket
id|depth
)braket
op_assign
id|cfg-&gt;cond
suffix:semicolon
id|cfg-&gt;cond
op_assign
id|join_condition_stack
c_func
(paren
id|cond_stack
comma
id|depth
op_plus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
eof
