multiline_comment|/* parser config.in&n; *&n; * Version 1.0&n; * Eric Youngdale&n; * 10/95&n; *&n; * The general idea here is that we want to parse a config.in file and &n; * from this, we generate a wish script which gives us effectively the&n; * same functionality that the original config.in script provided.&n; *&n; * This task is split roughly into 3 parts.  The first parse is the parse&n; * of the input file itself.  The second part is where we analyze the &n; * #ifdef clauses, and attach a linked list of tokens to each of the&n; * menu items.  In this way, each menu item has a complete list of&n; * dependencies that are used to enable/disable the options.&n; * The third part is to take the configuration database we have build,&n; * and build the actual wish script.&n; *&n; * This file contains the code to do the first parse of config.in.&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &quot;tkparse.h&quot;
DECL|variable|config
r_struct
id|kconfig
op_star
id|config
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|clast
r_struct
id|kconfig
op_star
id|clast
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|koption
r_struct
id|kconfig
op_star
id|koption
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|lineno
r_static
r_int
id|lineno
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Simple function just to skip over spaces and tabs in config.in.&n; */
DECL|function|skip_whitespace
r_static
r_char
op_star
id|skip_whitespace
c_func
(paren
r_char
op_star
id|pnt
)paren
(brace
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
(paren
op_star
id|pnt
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;&bslash;t&squot;
)paren
)paren
(brace
id|pnt
op_increment
suffix:semicolon
)brace
r_return
id|pnt
suffix:semicolon
)brace
multiline_comment|/*&n; * This function parses a conditional from a config.in (i.e. from an ifdef)&n; * and generates a linked list of tokens that describes the conditional.&n; */
DECL|function|parse_if
r_static
r_struct
id|condition
op_star
id|parse_if
c_func
(paren
r_char
op_star
id|pnt
)paren
(brace
r_char
op_star
id|opnt
suffix:semicolon
r_struct
id|condition
op_star
id|list
suffix:semicolon
r_struct
id|condition
op_star
id|last
suffix:semicolon
r_struct
id|condition
op_star
id|cpnt
suffix:semicolon
r_char
id|varname
(braket
l_int|64
)braket
suffix:semicolon
r_char
op_star
id|pnt1
suffix:semicolon
id|opnt
op_assign
id|pnt
suffix:semicolon
multiline_comment|/*&n;   * We need to find the various tokens, and build the linked list.&n;   */
id|pnt
op_assign
id|skip_whitespace
c_func
(paren
id|pnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pnt
op_ne
l_char|&squot;[&squot;
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|pnt
op_increment
suffix:semicolon
id|pnt
op_assign
id|skip_whitespace
c_func
(paren
id|pnt
)paren
suffix:semicolon
id|list
op_assign
id|last
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
op_star
id|pnt
op_ne
l_char|&squot;]&squot;
)paren
(brace
id|pnt
op_assign
id|skip_whitespace
c_func
(paren
id|pnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;]&squot;
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;     * Allocate memory for the token we are about to parse, and insert&n;     * it in the linked list.&n;     */
id|cpnt
op_assign
(paren
r_struct
id|condition
op_star
)paren
id|malloc
c_func
(paren
r_sizeof
(paren
r_struct
id|condition
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cpnt
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|condition
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last
op_eq
l_int|NULL
)paren
(brace
id|list
op_assign
id|last
op_assign
id|cpnt
suffix:semicolon
)brace
r_else
(brace
id|last-&gt;next
op_assign
id|cpnt
suffix:semicolon
id|last
op_assign
id|cpnt
suffix:semicolon
)brace
multiline_comment|/*&n;     * Determine what type of operation this token represents.&n;     */
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;-&squot;
op_logical_and
id|pnt
(braket
l_int|1
)braket
op_eq
l_char|&squot;a&squot;
)paren
(brace
id|cpnt-&gt;op
op_assign
id|op_and
suffix:semicolon
id|pnt
op_add_assign
l_int|2
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;!&squot;
op_logical_and
id|pnt
(braket
l_int|1
)braket
op_eq
l_char|&squot;=&squot;
)paren
(brace
id|cpnt-&gt;op
op_assign
id|op_neq
suffix:semicolon
id|pnt
op_add_assign
l_int|2
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;=&squot;
)paren
(brace
id|cpnt-&gt;op
op_assign
id|op_eq
suffix:semicolon
id|pnt
op_add_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;!&squot;
)paren
(brace
id|cpnt-&gt;op
op_assign
id|op_bang
suffix:semicolon
id|pnt
op_add_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pnt
op_ne
l_char|&squot;&quot;&squot;
)paren
(brace
r_goto
id|error
suffix:semicolon
)brace
multiline_comment|/* This cannot be right. */
id|pnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;$&squot;
)paren
(brace
id|cpnt-&gt;op
op_assign
id|op_variable
suffix:semicolon
id|pnt1
op_assign
id|varname
suffix:semicolon
id|pnt
op_increment
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
op_star
id|pnt
op_ne
l_char|&squot;&quot;&squot;
)paren
(brace
op_star
id|pnt1
op_increment
op_assign
op_star
id|pnt
op_increment
suffix:semicolon
)brace
op_star
id|pnt1
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|cpnt-&gt;variable
op_assign
id|strdup
c_func
(paren
id|varname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
id|pnt
op_increment
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
id|cpnt-&gt;op
op_assign
id|op_constant
suffix:semicolon
id|pnt1
op_assign
id|varname
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
op_star
id|pnt
op_ne
l_char|&squot;&quot;&squot;
)paren
(brace
op_star
id|pnt1
op_increment
op_assign
op_star
id|pnt
op_increment
suffix:semicolon
)brace
op_star
id|pnt1
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|cpnt-&gt;variable
op_assign
id|strdup
c_func
(paren
id|varname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
id|pnt
op_increment
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_return
id|list
suffix:semicolon
id|error
suffix:colon
id|printf
c_func
(paren
l_string|&quot;Bad if clause at line %d:%s&bslash;n&quot;
comma
id|lineno
comma
id|opnt
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * This function looks for a quoted string, from the input buffer, and&n; * returns a pointer to a copy of this string.  Any characters in&n; * the string that need to be &quot;quoted&quot; have a &squot;&bslash;&squot; character inserted&n; * in front - this way we can directly write these strings into&n; * wish scripts.&n; */
DECL|function|get_qstring
r_static
r_char
op_star
id|get_qstring
c_func
(paren
r_char
op_star
id|pnt
comma
r_char
op_star
op_star
id|labl
)paren
(brace
r_char
id|quotechar
suffix:semicolon
r_char
id|newlabel
(braket
l_int|1024
)braket
suffix:semicolon
r_char
op_star
id|pnt1
suffix:semicolon
r_char
op_star
id|pnt2
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
op_star
id|pnt
op_ne
l_char|&squot;&quot;&squot;
op_logical_and
op_star
id|pnt
op_ne
l_char|&squot;&bslash;&squot;&squot;
)paren
(brace
id|pnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
id|pnt
suffix:semicolon
id|quotechar
op_assign
op_star
id|pnt
op_increment
suffix:semicolon
id|pnt1
op_assign
id|newlabel
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
op_star
id|pnt
op_ne
id|quotechar
op_logical_and
id|pnt
(braket
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
multiline_comment|/*&n;       * Quote the character if we need to.&n;       */
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;&quot;&squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;&bslash;&squot;&squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;[&squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;]&squot;
)paren
(brace
op_star
id|pnt1
op_increment
op_assign
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
)brace
op_star
id|pnt1
op_increment
op_assign
op_star
id|pnt
op_increment
suffix:semicolon
)brace
op_star
id|pnt1
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|pnt2
op_assign
(paren
r_char
op_star
)paren
id|malloc
c_func
(paren
id|strlen
c_func
(paren
id|newlabel
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|pnt2
comma
id|newlabel
)paren
suffix:semicolon
op_star
id|labl
op_assign
id|pnt2
suffix:semicolon
multiline_comment|/*&n;   * Skip over last quote, and whitespace.&n;   */
id|pnt
op_increment
suffix:semicolon
id|pnt
op_assign
id|skip_whitespace
c_func
(paren
id|pnt
)paren
suffix:semicolon
r_return
id|pnt
suffix:semicolon
)brace
multiline_comment|/*&n; * This function grabs one text token from the input buffer&n; * and returns a pointer to a copy of just the identifier.&n; * This can be either a variable name (i.e. CONFIG_NET),&n; * or it could be the default value for the option.&n; */
DECL|function|get_string
r_static
r_char
op_star
id|get_string
c_func
(paren
r_char
op_star
id|pnt
comma
r_char
op_star
op_star
id|labl
)paren
(brace
r_char
id|quotechar
suffix:semicolon
r_char
id|newlabel
(braket
l_int|1024
)braket
suffix:semicolon
r_char
op_star
id|pnt1
suffix:semicolon
r_char
op_star
id|pnt2
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
id|pnt
suffix:semicolon
id|pnt1
op_assign
id|newlabel
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
op_star
id|pnt
op_ne
l_char|&squot; &squot;
op_logical_and
op_star
id|pnt
op_ne
l_char|&squot;&bslash;t&squot;
)paren
(brace
op_star
id|pnt1
op_increment
op_assign
op_star
id|pnt
op_increment
suffix:semicolon
)brace
op_star
id|pnt1
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|pnt2
op_assign
(paren
r_char
op_star
)paren
id|malloc
c_func
(paren
id|strlen
c_func
(paren
id|newlabel
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|pnt2
comma
id|newlabel
)paren
suffix:semicolon
op_star
id|labl
op_assign
id|pnt2
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pnt
)paren
(brace
id|pnt
op_increment
suffix:semicolon
)brace
r_return
id|pnt
suffix:semicolon
)brace
multiline_comment|/*&n; * Top level parse function.  Input pointer is one complete line from config.in&n; * and the result is that we create a token that describes this line&n; * and insert it into our linked list.&n; */
DECL|function|parse
r_int
id|parse
c_func
(paren
r_char
op_star
id|pnt
)paren
(brace
r_enum
id|token
id|tok
suffix:semicolon
r_struct
id|kconfig
op_star
id|kcfg
suffix:semicolon
multiline_comment|/*&n;   * Ignore comments and leading whitespace.&n;   */
id|pnt
op_assign
id|skip_whitespace
c_func
(paren
id|pnt
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
(paren
op_star
id|pnt
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;&bslash;t&squot;
)paren
)paren
(brace
id|pnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|pnt
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;#&squot;
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;   * Now categorize the next token.&n;   */
id|tok
op_assign
id|tok_unknown
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|pnt
comma
l_string|&quot;mainmenu_name&quot;
comma
l_int|13
)paren
op_eq
l_int|0
)paren
(brace
id|tok
op_assign
id|tok_menuname
suffix:semicolon
id|pnt
op_add_assign
l_int|13
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|pnt
comma
l_string|&quot;mainmenu_option&quot;
comma
l_int|15
)paren
op_eq
l_int|0
)paren
(brace
id|tok
op_assign
id|tok_menuoption
suffix:semicolon
id|pnt
op_add_assign
l_int|15
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|pnt
comma
l_string|&quot;comment&quot;
comma
l_int|7
)paren
op_eq
l_int|0
)paren
(brace
id|tok
op_assign
id|tok_comment
suffix:semicolon
id|pnt
op_add_assign
l_int|7
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|pnt
comma
l_string|&quot;bool&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
id|tok
op_assign
id|tok_bool
suffix:semicolon
id|pnt
op_add_assign
l_int|4
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|pnt
comma
l_string|&quot;tristate&quot;
comma
l_int|8
)paren
op_eq
l_int|0
)paren
(brace
id|tok
op_assign
id|tok_tristate
suffix:semicolon
id|pnt
op_add_assign
l_int|8
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|pnt
comma
l_string|&quot;dep_tristate&quot;
comma
l_int|12
)paren
op_eq
l_int|0
)paren
(brace
id|tok
op_assign
id|tok_dep_tristate
suffix:semicolon
id|pnt
op_add_assign
l_int|12
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|pnt
comma
l_string|&quot;int&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
id|tok
op_assign
id|tok_int
suffix:semicolon
id|pnt
op_add_assign
l_int|3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|pnt
comma
l_string|&quot;if&quot;
comma
l_int|2
)paren
op_eq
l_int|0
)paren
(brace
id|tok
op_assign
id|tok_if
suffix:semicolon
id|pnt
op_add_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|pnt
comma
l_string|&quot;else&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
id|tok
op_assign
id|tok_else
suffix:semicolon
id|pnt
op_add_assign
l_int|4
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|pnt
comma
l_string|&quot;fi&quot;
comma
l_int|2
)paren
op_eq
l_int|0
)paren
(brace
id|tok
op_assign
id|tok_fi
suffix:semicolon
id|pnt
op_add_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tok
op_eq
id|tok_unknown
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;unknown command=%s&bslash;n&quot;
comma
id|pnt
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;   * Allocate memory for this item, and attach it to the end of the linked&n;   * list.&n;   */
id|kcfg
op_assign
(paren
r_struct
id|kconfig
op_star
)paren
id|malloc
c_func
(paren
r_sizeof
(paren
r_struct
id|kconfig
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kcfg
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|kconfig
)paren
)paren
suffix:semicolon
id|kcfg-&gt;tok
op_assign
id|tok
suffix:semicolon
r_if
c_cond
(paren
id|clast
op_ne
l_int|NULL
)paren
(brace
id|clast-&gt;next
op_assign
id|kcfg
suffix:semicolon
id|clast
op_assign
id|kcfg
suffix:semicolon
)brace
r_else
(brace
id|clast
op_assign
id|config
op_assign
id|kcfg
suffix:semicolon
)brace
id|pnt
op_assign
id|skip_whitespace
c_func
(paren
id|pnt
)paren
suffix:semicolon
multiline_comment|/*&n;   * Now parse the remaining parts of the option, and attach the results&n;   * to the structure.&n;   */
r_switch
c_cond
(paren
id|tok
)paren
(brace
r_case
id|tok_menuname
suffix:colon
id|pnt
op_assign
id|get_qstring
c_func
(paren
id|pnt
comma
op_amp
id|kcfg-&gt;label
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_bool
suffix:colon
r_case
id|tok_tristate
suffix:colon
r_case
id|tok_int
suffix:colon
id|pnt
op_assign
id|get_qstring
c_func
(paren
id|pnt
comma
op_amp
id|kcfg-&gt;label
)paren
suffix:semicolon
id|pnt
op_assign
id|get_string
c_func
(paren
id|pnt
comma
op_amp
id|kcfg-&gt;optionname
)paren
suffix:semicolon
id|pnt
op_assign
id|get_string
c_func
(paren
id|pnt
comma
op_amp
id|kcfg-&gt;dflt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_dep_tristate
suffix:colon
id|pnt
op_assign
id|get_qstring
c_func
(paren
id|pnt
comma
op_amp
id|kcfg-&gt;label
)paren
suffix:semicolon
id|pnt
op_assign
id|get_string
c_func
(paren
id|pnt
comma
op_amp
id|kcfg-&gt;optionname
)paren
suffix:semicolon
id|pnt
op_assign
id|get_string
c_func
(paren
id|pnt
comma
op_amp
id|kcfg-&gt;dflt
)paren
suffix:semicolon
id|pnt
op_assign
id|skip_whitespace
c_func
(paren
id|pnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;$&squot;
)paren
(brace
id|pnt
op_increment
suffix:semicolon
)brace
id|pnt
op_assign
id|get_string
c_func
(paren
id|pnt
comma
op_amp
id|kcfg-&gt;depend.str
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_comment
suffix:colon
id|pnt
op_assign
id|get_qstring
c_func
(paren
id|pnt
comma
op_amp
id|kcfg-&gt;label
)paren
suffix:semicolon
r_if
c_cond
(paren
id|koption
op_ne
l_int|NULL
)paren
(brace
id|pnt
op_assign
id|get_qstring
c_func
(paren
id|pnt
comma
op_amp
id|kcfg-&gt;label
)paren
suffix:semicolon
id|koption-&gt;label
op_assign
id|kcfg-&gt;label
suffix:semicolon
id|koption
op_assign
l_int|NULL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|tok_menuoption
suffix:colon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|pnt
comma
l_string|&quot;next_comment&quot;
comma
l_int|12
)paren
op_eq
l_int|0
)paren
(brace
id|koption
op_assign
id|kcfg
suffix:semicolon
)brace
r_else
(brace
id|pnt
op_assign
id|get_qstring
c_func
(paren
id|pnt
comma
op_amp
id|kcfg-&gt;label
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|tok_else
suffix:colon
r_case
id|tok_fi
suffix:colon
r_break
suffix:semicolon
r_case
id|tok_if
suffix:colon
multiline_comment|/*&n;       * Conditionals are different.  For the first level parse, only&n;       * tok_if items have a -&gt;cond chain attached.&n;       */
id|kcfg-&gt;cond
op_assign
id|parse_if
c_func
(paren
id|pnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kcfg-&gt;cond
op_eq
l_int|NULL
)paren
(brace
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
m_exit
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Simple function to dump to the screen what the condition chain looks like.&n; */
DECL|function|dump_if
id|dump_if
c_func
(paren
r_struct
id|condition
op_star
id|cond
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cond
op_ne
l_int|NULL
)paren
(brace
r_switch
c_cond
(paren
id|cond-&gt;op
)paren
(brace
r_case
id|op_eq
suffix:colon
id|printf
c_func
(paren
l_string|&quot; = &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_bang
suffix:colon
id|printf
c_func
(paren
l_string|&quot; ! &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_neq
suffix:colon
id|printf
c_func
(paren
l_string|&quot; != &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_and
suffix:colon
id|printf
c_func
(paren
l_string|&quot; -a &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_lparen
suffix:colon
id|printf
c_func
(paren
l_string|&quot;(&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_rparen
suffix:colon
id|printf
c_func
(paren
l_string|&quot;)&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_variable
suffix:colon
id|printf
c_func
(paren
l_string|&quot;$%s&quot;
comma
id|cond-&gt;variable
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_constant
suffix:colon
id|printf
c_func
(paren
l_string|&quot;&squot;%s&squot;&quot;
comma
id|cond-&gt;variable
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cond
op_assign
id|cond-&gt;next
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|buffer
r_char
id|buffer
(braket
l_int|1024
)braket
suffix:semicolon
DECL|function|main
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
id|argv
(braket
)braket
)paren
(brace
r_char
op_star
id|pnt
suffix:semicolon
r_struct
id|kconfig
op_star
id|cfg
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;   * Loop over every input line, and parse it into the tables.&n;   */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|fgets
c_func
(paren
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
id|stdin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|feof
c_func
(paren
id|stdin
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;       * Strip the trailing return character.&n;       */
id|pnt
op_assign
id|buffer
op_plus
id|strlen
c_func
(paren
id|buffer
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
op_star
id|pnt
op_assign
l_int|0
suffix:semicolon
)brace
id|lineno
op_increment
suffix:semicolon
id|parse
c_func
(paren
id|buffer
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;   * Input file is now parsed.  Next we need to go through and attach&n;   * the correct conditions to each of the actual menu items and kill&n;   * the if/else/endif tokens from the list.  We also flag the menu items&n;   * that have other things that depend upon it&squot;s setting.&n;   */
id|fix_conditionals
c_func
(paren
id|config
)paren
suffix:semicolon
multiline_comment|/*&n;   * Finally, we generate the wish script.&n;   */
id|dump_tk_script
c_func
(paren
id|config
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;   * Now dump what we have so far.  This is only for debugging so that&n;   * we can display what we think we have in the list.&n;   */
r_for
c_loop
(paren
id|cfg
op_assign
id|config
suffix:semicolon
id|cfg
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
op_logical_and
id|cfg-&gt;tok
op_ne
id|tok_if
)paren
(brace
id|dump_if
c_func
(paren
id|cfg-&gt;cond
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cfg-&gt;tok
)paren
(brace
r_case
id|tok_menuname
suffix:colon
id|printf
c_func
(paren
l_string|&quot;main_menuname &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_bool
suffix:colon
id|printf
c_func
(paren
l_string|&quot;bool &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_tristate
suffix:colon
id|printf
c_func
(paren
l_string|&quot;tristate &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_dep_tristate
suffix:colon
id|printf
c_func
(paren
l_string|&quot;dep_tristate &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_int
suffix:colon
id|printf
c_func
(paren
l_string|&quot;int &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_comment
suffix:colon
id|printf
c_func
(paren
l_string|&quot;comment &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_menuoption
suffix:colon
id|printf
c_func
(paren
l_string|&quot;menuoption &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_else
suffix:colon
id|printf
c_func
(paren
l_string|&quot;else&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_fi
suffix:colon
id|printf
c_func
(paren
l_string|&quot;fi&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_if
suffix:colon
id|printf
c_func
(paren
l_string|&quot;if&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
r_switch
c_cond
(paren
id|cfg-&gt;tok
)paren
(brace
r_case
id|tok_menuoption
suffix:colon
r_case
id|tok_comment
suffix:colon
r_case
id|tok_menuname
suffix:colon
id|printf
c_func
(paren
l_string|&quot;%s&bslash;n&quot;
comma
id|cfg-&gt;label
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_bool
suffix:colon
r_case
id|tok_tristate
suffix:colon
r_case
id|tok_dep_tristate
suffix:colon
r_case
id|tok_int
suffix:colon
id|printf
c_func
(paren
l_string|&quot;%s %s %s&bslash;n&quot;
comma
id|cfg-&gt;label
comma
id|cfg-&gt;optionname
comma
id|cfg-&gt;dflt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_if
suffix:colon
id|dump_if
c_func
(paren
id|cfg-&gt;cond
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_nop
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
eof
