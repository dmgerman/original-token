multiline_comment|/*&n; * tkparse.c&n; *&n; * Eric Youngdale was the original author of xconfig.&n; * Michael Elizabeth Chastain (mec@shout.net) is the current maintainer.&n; *&n; * Parse a config.in file and translate it to a wish script.&n; * This task has three parts:&n; *&n; *   tkparse.c&t;tokenize the input&n; *   tkcond.c   transform &squot;if ...&squot; statements&n; *   tkgen.c    generate output&n; *&n; * Change History&n; *&n; * 7 January 1999, Michael Elizabeth Chastain, &lt;mec@shout.net&gt;&n; * - Teach dep_tristate about a few literals, such as:&n; *     dep_tristate &squot;foo&squot; CONFIG_FOO m&n; *   Also have it print an error message and exit on some parse failures.&n; *&n; * 14 January 1999, Michael Elizabeth Chastain, &lt;mec@shout.net&gt;&n; * - Don&squot;t fclose stdin.  Thanks to Tony Hoyle for nailing this one.&n; *&n; * 14 January 1999, Michael Elizabeth Chastain, &lt;mec@shout.net&gt;&n; * - Steam-clean this file.  I tested this by generating kconfig.tk for&n; *   every architecture and comparing it character-for-character against&n; *   the output of the old tkparse.&n; *&n; * 23 January 1999, Michael Elizabeth Chastain, &lt;mec@shout.net&gt;&n; * - Remove bug-compatible code.&n; *&n; * 07 July 1999, Andrzej M. Krzysztofowicz, &lt;ankry@mif.pg.gda.pl&gt;&n; * - Submenus implemented,&n; * - plenty of option updating/displaying fixes,&n; * - dep_bool, define_hex, define_int, define_string, define_tristate and&n; *   undef implemented,&n; * - dep_tristate fixed to support multiple dependencies,&n; * - handling of variables with an empty value implemented,&n; * - value checking for int and hex fields,&n; * - more checking during condition parsing; choice variables are treated as&n; *   all others now,&n; *&n; * TO DO:&n; * - xconfig is at the end of its life cycle.  Contact &lt;mec@shout.net&gt; if&n; *   you are interested in working on the replacement.&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &quot;tkparse.h&quot;
DECL|variable|config_list
r_static
r_struct
id|kconfig
op_star
id|config_list
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|config_last
r_static
r_struct
id|kconfig
op_star
id|config_last
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|current_file
r_static
r_const
r_char
op_star
id|current_file
op_assign
l_string|&quot;&lt;unknown file&gt;&quot;
suffix:semicolon
DECL|variable|lineno
r_static
r_int
id|lineno
op_assign
l_int|0
suffix:semicolon
r_static
r_void
id|do_source
c_func
(paren
r_const
r_char
op_star
)paren
suffix:semicolon
DECL|macro|strcmp
macro_line|#undef strcmp
DECL|function|my_strcmp
r_int
id|my_strcmp
c_func
(paren
r_const
r_char
op_star
id|s1
comma
r_const
r_char
op_star
id|s2
)paren
(brace
r_return
id|strcmp
c_func
(paren
id|s1
comma
id|s2
)paren
suffix:semicolon
)brace
DECL|macro|strcmp
mdefine_line|#define strcmp my_strcmp
multiline_comment|/*&n; * Report a syntax error.&n; */
DECL|function|syntax_error
r_static
r_void
id|syntax_error
c_func
(paren
r_const
r_char
op_star
id|msg
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: %d: %s&bslash;n&quot;
comma
id|current_file
comma
id|lineno
comma
id|msg
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find index of a specyfic variable in the symbol table.&n; * Create a new entry if it does not exist yet.&n; */
DECL|macro|VARTABLE_SIZE
mdefine_line|#define VARTABLE_SIZE 2048
DECL|variable|vartable
r_struct
id|variable
id|vartable
(braket
id|VARTABLE_SIZE
)braket
suffix:semicolon
DECL|variable|max_varnum
r_int
id|max_varnum
op_assign
l_int|0
suffix:semicolon
DECL|function|get_varnum
r_int
id|get_varnum
c_func
(paren
r_char
op_star
id|name
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|max_varnum
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|vartable
(braket
id|i
)braket
dot
id|name
comma
id|name
)paren
op_eq
l_int|0
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
id|max_varnum
OG
id|VARTABLE_SIZE
op_minus
l_int|1
)paren
id|syntax_error
c_func
(paren
l_string|&quot;Too many variables defined.&quot;
)paren
suffix:semicolon
id|vartable
(braket
op_increment
id|max_varnum
)braket
dot
id|name
op_assign
id|malloc
c_func
(paren
id|strlen
c_func
(paren
id|name
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|vartable
(braket
id|max_varnum
)braket
dot
id|name
comma
id|name
)paren
suffix:semicolon
r_return
id|max_varnum
suffix:semicolon
)brace
multiline_comment|/*&n; * Get a string.&n; */
DECL|function|get_string
r_static
r_const
r_char
op_star
id|get_string
c_func
(paren
r_const
r_char
op_star
id|pnt
comma
r_char
op_star
op_star
id|label
)paren
(brace
r_const
r_char
op_star
id|word
suffix:semicolon
id|word
op_assign
id|pnt
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;&bslash;t&squot;
)paren
r_break
suffix:semicolon
id|pnt
op_increment
suffix:semicolon
)brace
op_star
id|label
op_assign
id|malloc
c_func
(paren
id|pnt
op_minus
id|word
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_star
id|label
comma
id|word
comma
id|pnt
op_minus
id|word
)paren
suffix:semicolon
(paren
op_star
id|label
)paren
(braket
id|pnt
op_minus
id|word
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pnt
op_ne
l_char|&squot;&bslash;0&squot;
)paren
id|pnt
op_increment
suffix:semicolon
r_return
id|pnt
suffix:semicolon
)brace
multiline_comment|/*&n; * Get a quoted string.&n; * Insert a &squot;&bslash;&squot; before any characters that need quoting.&n; */
DECL|function|get_qstring
r_static
r_const
r_char
op_star
id|get_qstring
c_func
(paren
r_const
r_char
op_star
id|pnt
comma
r_char
op_star
op_star
id|label
)paren
(brace
r_char
id|quote_char
suffix:semicolon
r_char
id|newlabel
(braket
l_int|2048
)braket
suffix:semicolon
r_char
op_star
id|pnt1
suffix:semicolon
multiline_comment|/* advance to the open quote */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
id|pnt
suffix:semicolon
id|quote_char
op_assign
op_star
id|pnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|quote_char
op_eq
l_char|&squot;&quot;&squot;
op_logical_or
id|quote_char
op_eq
l_char|&squot;&bslash;&squot;&squot;
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* copy into an intermediate buffer */
id|pnt1
op_assign
id|newlabel
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;&bslash;0&squot;
)paren
id|syntax_error
c_func
(paren
l_string|&quot;unterminated quoted string&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pnt
op_eq
id|quote_char
op_logical_and
id|pnt
(braket
op_minus
l_int|1
)braket
op_ne
l_char|&squot;&bslash;&bslash;&squot;
)paren
r_break
suffix:semicolon
multiline_comment|/* copy the character, quoting if needed */
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;&quot;&squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;&bslash;&squot;&squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;[&squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;]&squot;
)paren
op_star
id|pnt1
op_increment
op_assign
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
op_star
id|pnt1
op_increment
op_assign
op_star
id|pnt
op_increment
suffix:semicolon
)brace
multiline_comment|/* copy the label into a permanent location */
op_star
id|pnt1
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
op_star
id|label
op_assign
(paren
r_char
op_star
)paren
id|malloc
c_func
(paren
id|pnt1
op_minus
id|newlabel
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_star
id|label
comma
id|newlabel
comma
id|pnt1
op_minus
id|newlabel
)paren
suffix:semicolon
multiline_comment|/* skip over last quote and next whitespace */
id|pnt
op_increment
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|pnt
op_increment
suffix:semicolon
r_return
id|pnt
suffix:semicolon
)brace
multiline_comment|/*&n; * Get a quoted or unquoted string. It is recognized by the first &n; * non-white character. &squot;&quot;&squot; and &squot;&quot;&squot; are not allowed inside the string.&n; */
DECL|function|get_qnqstring
r_static
r_const
r_char
op_star
id|get_qnqstring
c_func
(paren
r_const
r_char
op_star
id|pnt
comma
r_char
op_star
op_star
id|label
)paren
(brace
r_char
id|quote_char
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|pnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
id|pnt
suffix:semicolon
id|quote_char
op_assign
op_star
id|pnt
suffix:semicolon
r_if
c_cond
(paren
id|quote_char
op_eq
l_char|&squot;&quot;&squot;
op_logical_or
id|quote_char
op_eq
l_char|&squot;&bslash;&squot;&squot;
)paren
r_return
id|get_qstring
c_func
(paren
id|pnt
comma
id|label
)paren
suffix:semicolon
r_else
r_return
id|get_string
c_func
(paren
id|pnt
comma
id|label
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Tokenize an &squot;if&squot; statement condition.&n; */
DECL|function|tokenize_if
r_static
r_struct
id|condition
op_star
id|tokenize_if
c_func
(paren
r_const
r_char
op_star
id|pnt
)paren
(brace
r_struct
id|condition
op_star
id|list
suffix:semicolon
r_struct
id|condition
op_star
id|last
suffix:semicolon
r_struct
id|condition
op_star
id|prev
suffix:semicolon
multiline_comment|/* eat the open bracket */
r_while
c_loop
(paren
op_star
id|pnt
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|pnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pnt
op_ne
l_char|&squot;[&squot;
)paren
id|syntax_error
c_func
(paren
l_string|&quot;bad &squot;if&squot; condition&quot;
)paren
suffix:semicolon
id|pnt
op_increment
suffix:semicolon
id|list
op_assign
id|last
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|condition
op_star
id|cond
suffix:semicolon
multiline_comment|/* advance to the next token */
r_while
c_loop
(paren
op_star
id|pnt
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|pnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;&bslash;0&squot;
)paren
id|syntax_error
c_func
(paren
l_string|&quot;unterminated &squot;if&squot; condition&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;]&squot;
)paren
r_return
id|list
suffix:semicolon
multiline_comment|/* allocate a new token */
id|cond
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|cond
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cond
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cond
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last
op_eq
l_int|NULL
)paren
(brace
id|list
op_assign
id|last
op_assign
id|cond
suffix:semicolon
id|prev
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|prev
op_assign
id|last
suffix:semicolon
id|last-&gt;next
op_assign
id|cond
suffix:semicolon
id|last
op_assign
id|cond
suffix:semicolon
)brace
multiline_comment|/* determine the token value */
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;-&squot;
op_logical_and
id|pnt
(braket
l_int|1
)braket
op_eq
l_char|&squot;a&squot;
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prev
op_logical_or
(paren
id|prev-&gt;op
op_ne
id|op_variable
op_logical_and
id|prev-&gt;op
op_ne
id|op_constant
)paren
)paren
id|syntax_error
c_func
(paren
l_string|&quot;incorrect argument&quot;
)paren
suffix:semicolon
id|cond-&gt;op
op_assign
id|op_and
suffix:semicolon
id|pnt
op_add_assign
l_int|2
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;-&squot;
op_logical_and
id|pnt
(braket
l_int|1
)braket
op_eq
l_char|&squot;o&squot;
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prev
op_logical_or
(paren
id|prev-&gt;op
op_ne
id|op_variable
op_logical_and
id|prev-&gt;op
op_ne
id|op_constant
)paren
)paren
id|syntax_error
c_func
(paren
l_string|&quot;incorrect argument&quot;
)paren
suffix:semicolon
id|cond-&gt;op
op_assign
id|op_or
suffix:semicolon
id|pnt
op_add_assign
l_int|2
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;!&squot;
op_logical_and
id|pnt
(braket
l_int|1
)braket
op_eq
l_char|&squot;=&squot;
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prev
op_logical_or
(paren
id|prev-&gt;op
op_ne
id|op_variable
op_logical_and
id|prev-&gt;op
op_ne
id|op_constant
)paren
)paren
id|syntax_error
c_func
(paren
l_string|&quot;incorrect argument&quot;
)paren
suffix:semicolon
id|cond-&gt;op
op_assign
id|op_neq
suffix:semicolon
id|pnt
op_add_assign
l_int|2
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;=&squot;
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prev
op_logical_or
(paren
id|prev-&gt;op
op_ne
id|op_variable
op_logical_and
id|prev-&gt;op
op_ne
id|op_constant
)paren
)paren
id|syntax_error
c_func
(paren
l_string|&quot;incorrect argument&quot;
)paren
suffix:semicolon
id|cond-&gt;op
op_assign
id|op_eq
suffix:semicolon
id|pnt
op_add_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;!&squot;
)paren
(brace
r_if
c_cond
(paren
id|prev
op_logical_and
(paren
id|prev-&gt;op
op_ne
id|op_and
op_logical_and
id|prev-&gt;op
op_ne
id|op_or
op_logical_and
id|prev-&gt;op
op_ne
id|op_bang
)paren
)paren
id|syntax_error
c_func
(paren
l_string|&quot;incorrect argument&quot;
)paren
suffix:semicolon
id|cond-&gt;op
op_assign
id|op_bang
suffix:semicolon
id|pnt
op_add_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
r_const
r_char
op_star
id|word
suffix:semicolon
r_if
c_cond
(paren
id|prev
op_logical_and
(paren
id|prev-&gt;op
op_eq
id|op_variable
op_logical_or
id|prev-&gt;op
op_eq
id|op_constant
)paren
)paren
id|syntax_error
c_func
(paren
l_string|&quot;incorrect argument&quot;
)paren
suffix:semicolon
multiline_comment|/* advance to the word */
id|pnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;$&squot;
)paren
(brace
id|cond-&gt;op
op_assign
id|op_variable
suffix:semicolon
id|pnt
op_increment
suffix:semicolon
)brace
r_else
(brace
id|cond-&gt;op
op_assign
id|op_constant
suffix:semicolon
)brace
multiline_comment|/* find the end of the word */
id|word
op_assign
id|pnt
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;&bslash;0&squot;
)paren
id|syntax_error
c_func
(paren
l_string|&quot;unterminated double quote&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;&quot;&squot;
)paren
r_break
suffix:semicolon
id|pnt
op_increment
suffix:semicolon
)brace
multiline_comment|/* store a copy of this word */
(brace
r_char
op_star
id|str
op_assign
id|malloc
c_func
(paren
id|pnt
op_minus
id|word
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|str
comma
id|word
comma
id|pnt
op_minus
id|word
)paren
suffix:semicolon
id|str
(braket
id|pnt
op_minus
id|word
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|cond-&gt;op
op_eq
id|op_variable
)paren
(brace
id|cond-&gt;nameindex
op_assign
id|get_varnum
c_func
(paren
id|str
)paren
suffix:semicolon
id|free
c_func
(paren
id|str
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* op_constant */
(brace
id|cond-&gt;str
op_assign
id|str
suffix:semicolon
)brace
)brace
id|pnt
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* unknown token */
id|syntax_error
c_func
(paren
l_string|&quot;bad if condition&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Tokenize a choice list.  Choices appear as pairs of strings;&n; * note that I am parsing *inside* the double quotes.  Ugh.&n; */
DECL|function|tokenize_choices
r_static
r_const
r_char
op_star
id|tokenize_choices
c_func
(paren
r_struct
id|kconfig
op_star
id|cfg_choose
comma
r_const
r_char
op_star
id|pnt
)paren
(brace
r_int
id|default_checked
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|kconfig
op_star
id|cfg
suffix:semicolon
r_char
op_star
id|buffer
op_assign
id|malloc
c_func
(paren
l_int|64
)paren
suffix:semicolon
multiline_comment|/* skip whitespace */
r_while
c_loop
(paren
op_star
id|pnt
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|pnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
id|pnt
suffix:semicolon
multiline_comment|/* allocate a new kconfig line */
id|cfg
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|cfg
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cfg
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cfg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|config_last
op_eq
l_int|NULL
)paren
(brace
id|config_last
op_assign
id|config_list
op_assign
id|cfg
suffix:semicolon
)brace
r_else
(brace
id|config_last-&gt;next
op_assign
id|cfg
suffix:semicolon
id|config_last
op_assign
id|cfg
suffix:semicolon
)brace
multiline_comment|/* fill out the line */
id|cfg-&gt;token
op_assign
id|token_choice_item
suffix:semicolon
id|cfg-&gt;cfg_parent
op_assign
id|cfg_choose
suffix:semicolon
id|pnt
op_assign
id|get_string
c_func
(paren
id|pnt
comma
op_amp
id|cfg-&gt;label
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|default_checked
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|cfg-&gt;label
comma
id|cfg_choose-&gt;value
comma
id|strlen
c_func
(paren
id|cfg_choose-&gt;value
)paren
)paren
)paren
(brace
id|default_checked
op_assign
l_int|1
suffix:semicolon
id|free
c_func
(paren
id|cfg_choose-&gt;value
)paren
suffix:semicolon
id|cfg_choose-&gt;value
op_assign
id|cfg-&gt;label
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|pnt
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|pnt
op_increment
suffix:semicolon
id|pnt
op_assign
id|get_string
c_func
(paren
id|pnt
comma
op_amp
id|buffer
)paren
suffix:semicolon
id|cfg-&gt;nameindex
op_assign
id|get_varnum
c_func
(paren
id|buffer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|default_checked
)paren
id|syntax_error
c_func
(paren
l_string|&quot;bad &squot;choice&squot; default value&quot;
)paren
suffix:semicolon
r_return
id|pnt
suffix:semicolon
)brace
multiline_comment|/*&n; * Tokenize one line.&n; */
DECL|function|tokenize_line
r_static
r_void
id|tokenize_line
c_func
(paren
r_const
r_char
op_star
id|pnt
)paren
(brace
r_static
r_struct
id|kconfig
op_star
id|last_menuoption
op_assign
l_int|NULL
suffix:semicolon
r_enum
id|e_token
id|token
suffix:semicolon
r_struct
id|kconfig
op_star
id|cfg
suffix:semicolon
r_struct
id|dependency
op_star
op_star
id|dep_ptr
suffix:semicolon
r_char
op_star
id|buffer
op_assign
id|malloc
c_func
(paren
l_int|64
)paren
suffix:semicolon
multiline_comment|/* skip white space */
r_while
c_loop
(paren
op_star
id|pnt
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|pnt
op_increment
suffix:semicolon
multiline_comment|/*&n;     * categorize the next token&n;     */
DECL|macro|match_token
mdefine_line|#define match_token(t, s) &bslash;&n;    if (strncmp(pnt, s, strlen(s)) == 0) { token = t; pnt += strlen(s); break; }
id|token
op_assign
id|token_UNKNOWN
suffix:semicolon
r_switch
c_cond
(paren
op_star
id|pnt
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
l_char|&squot;#&squot;
suffix:colon
r_case
l_char|&squot;&bslash;0&squot;
suffix:colon
r_return
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
id|match_token
c_func
(paren
id|token_bool
comma
l_string|&quot;bool&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
id|match_token
c_func
(paren
id|token_choice_header
comma
l_string|&quot;choice&quot;
)paren
suffix:semicolon
id|match_token
c_func
(paren
id|token_comment
comma
l_string|&quot;comment&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
id|match_token
c_func
(paren
id|token_define_bool
comma
l_string|&quot;define_bool&quot;
)paren
suffix:semicolon
id|match_token
c_func
(paren
id|token_define_hex
comma
l_string|&quot;define_hex&quot;
)paren
suffix:semicolon
id|match_token
c_func
(paren
id|token_define_int
comma
l_string|&quot;define_int&quot;
)paren
suffix:semicolon
id|match_token
c_func
(paren
id|token_define_string
comma
l_string|&quot;define_string&quot;
)paren
suffix:semicolon
id|match_token
c_func
(paren
id|token_define_tristate
comma
l_string|&quot;define_tristate&quot;
)paren
suffix:semicolon
id|match_token
c_func
(paren
id|token_dep_bool
comma
l_string|&quot;dep_bool&quot;
)paren
suffix:semicolon
id|match_token
c_func
(paren
id|token_dep_mbool
comma
l_string|&quot;dep_mbool&quot;
)paren
suffix:semicolon
id|match_token
c_func
(paren
id|token_dep_tristate
comma
l_string|&quot;dep_tristate&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;e&squot;
suffix:colon
id|match_token
c_func
(paren
id|token_else
comma
l_string|&quot;else&quot;
)paren
suffix:semicolon
id|match_token
c_func
(paren
id|token_endmenu
comma
l_string|&quot;endmenu&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;f&squot;
suffix:colon
id|match_token
c_func
(paren
id|token_fi
comma
l_string|&quot;fi&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;h&squot;
suffix:colon
id|match_token
c_func
(paren
id|token_hex
comma
l_string|&quot;hex&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;i&squot;
suffix:colon
id|match_token
c_func
(paren
id|token_if
comma
l_string|&quot;if&quot;
)paren
suffix:semicolon
id|match_token
c_func
(paren
id|token_int
comma
l_string|&quot;int&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
id|match_token
c_func
(paren
id|token_mainmenu_name
comma
l_string|&quot;mainmenu_name&quot;
)paren
suffix:semicolon
id|match_token
c_func
(paren
id|token_mainmenu_option
comma
l_string|&quot;mainmenu_option&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
id|match_token
c_func
(paren
id|token_source
comma
l_string|&quot;source&quot;
)paren
suffix:semicolon
id|match_token
c_func
(paren
id|token_string
comma
l_string|&quot;string&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
id|match_token
c_func
(paren
id|token_then
comma
l_string|&quot;then&quot;
)paren
suffix:semicolon
id|match_token
c_func
(paren
id|token_tristate
comma
l_string|&quot;tristate&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;u&squot;
suffix:colon
id|match_token
c_func
(paren
id|token_unset
comma
l_string|&quot;unset&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
DECL|macro|match_token
macro_line|#undef match_token
r_if
c_cond
(paren
id|token
op_eq
id|token_source
)paren
(brace
r_while
c_loop
(paren
op_star
id|pnt
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|pnt
op_increment
suffix:semicolon
id|do_source
c_func
(paren
id|pnt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|token
op_eq
id|token_then
)paren
(brace
r_if
c_cond
(paren
id|config_last
op_ne
l_int|NULL
op_logical_and
id|config_last-&gt;token
op_eq
id|token_if
)paren
r_return
suffix:semicolon
id|syntax_error
c_func
(paren
l_string|&quot;bogus &squot;then&squot;&quot;
)paren
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|token
op_eq
id|token_unset
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Ignoring &squot;unset&squot; command&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|token
op_eq
id|token_UNKNOWN
)paren
id|syntax_error
c_func
(paren
l_string|&quot;unknown command&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     * Allocate an item.&n;     */
id|cfg
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|cfg
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cfg
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cfg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|config_last
op_eq
l_int|NULL
)paren
(brace
id|config_last
op_assign
id|config_list
op_assign
id|cfg
suffix:semicolon
)brace
r_else
(brace
id|config_last-&gt;next
op_assign
id|cfg
suffix:semicolon
id|config_last
op_assign
id|cfg
suffix:semicolon
)brace
multiline_comment|/*&n;     * Tokenize the arguments.&n;     */
r_while
c_loop
(paren
op_star
id|pnt
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|pnt
op_increment
suffix:semicolon
id|cfg-&gt;token
op_assign
id|token
suffix:semicolon
r_switch
c_cond
(paren
id|token
)paren
(brace
r_default
suffix:colon
id|syntax_error
c_func
(paren
l_string|&quot;unknown token&quot;
)paren
suffix:semicolon
r_case
id|token_bool
suffix:colon
r_case
id|token_tristate
suffix:colon
id|pnt
op_assign
id|get_qstring
(paren
id|pnt
comma
op_amp
id|cfg-&gt;label
)paren
suffix:semicolon
id|pnt
op_assign
id|get_string
(paren
id|pnt
comma
op_amp
id|buffer
)paren
suffix:semicolon
id|cfg-&gt;nameindex
op_assign
id|get_varnum
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_choice_header
suffix:colon
(brace
r_static
r_int
id|choose_number
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|choice_list
suffix:semicolon
id|pnt
op_assign
id|get_qstring
(paren
id|pnt
comma
op_amp
id|cfg-&gt;label
)paren
suffix:semicolon
id|pnt
op_assign
id|get_qstring
(paren
id|pnt
comma
op_amp
id|choice_list
)paren
suffix:semicolon
id|pnt
op_assign
id|get_string
(paren
id|pnt
comma
op_amp
id|cfg-&gt;value
)paren
suffix:semicolon
id|cfg-&gt;nameindex
op_assign
op_minus
(paren
id|choose_number
op_increment
)paren
suffix:semicolon
id|tokenize_choices
c_func
(paren
id|cfg
comma
id|choice_list
)paren
suffix:semicolon
id|free
c_func
(paren
id|choice_list
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|token_comment
suffix:colon
id|pnt
op_assign
id|get_qstring
c_func
(paren
id|pnt
comma
op_amp
id|cfg-&gt;label
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_menuoption
op_ne
l_int|NULL
)paren
(brace
id|pnt
op_assign
id|get_qstring
c_func
(paren
id|pnt
comma
op_amp
id|cfg-&gt;label
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;label
op_eq
l_int|NULL
)paren
id|syntax_error
c_func
(paren
l_string|&quot;missing comment text&quot;
)paren
suffix:semicolon
id|last_menuoption-&gt;label
op_assign
id|cfg-&gt;label
suffix:semicolon
id|last_menuoption
op_assign
l_int|NULL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|token_define_bool
suffix:colon
r_case
id|token_define_tristate
suffix:colon
id|pnt
op_assign
id|get_string
c_func
(paren
id|pnt
comma
op_amp
id|buffer
)paren
suffix:semicolon
id|cfg-&gt;nameindex
op_assign
id|get_varnum
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|pnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pnt
(braket
l_int|0
)braket
op_eq
l_char|&squot;Y&squot;
op_logical_or
id|pnt
(braket
l_int|0
)braket
op_eq
l_char|&squot;M&squot;
op_logical_or
id|pnt
(braket
l_int|0
)braket
op_eq
l_char|&squot;N&squot;
op_logical_or
id|pnt
(braket
l_int|0
)braket
op_eq
l_char|&squot;y&squot;
op_logical_or
id|pnt
(braket
l_int|0
)braket
op_eq
l_char|&squot;m&squot;
op_logical_or
id|pnt
(braket
l_int|0
)braket
op_eq
l_char|&squot;n&squot;
)paren
op_logical_and
(paren
id|pnt
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
id|pnt
(braket
l_int|1
)braket
op_eq
l_char|&squot; &squot;
op_logical_or
id|pnt
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;t&squot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;n&squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;N&squot;
)paren
id|cfg-&gt;value
op_assign
id|strdup
c_func
(paren
l_string|&quot;CONSTANT_N&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;y&squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;Y&squot;
)paren
id|cfg-&gt;value
op_assign
id|strdup
c_func
(paren
l_string|&quot;CONSTANT_Y&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;m&squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;M&squot;
)paren
id|cfg-&gt;value
op_assign
id|strdup
c_func
(paren
l_string|&quot;CONSTANT_M&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;$&squot;
)paren
(brace
id|pnt
op_increment
suffix:semicolon
id|pnt
op_assign
id|get_string
c_func
(paren
id|pnt
comma
op_amp
id|cfg-&gt;value
)paren
suffix:semicolon
)brace
r_else
(brace
id|syntax_error
c_func
(paren
l_string|&quot;unknown define_bool value&quot;
)paren
suffix:semicolon
)brace
id|get_varnum
c_func
(paren
id|cfg-&gt;value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_define_hex
suffix:colon
r_case
id|token_define_int
suffix:colon
id|pnt
op_assign
id|get_string
c_func
(paren
id|pnt
comma
op_amp
id|buffer
)paren
suffix:semicolon
id|cfg-&gt;nameindex
op_assign
id|get_varnum
c_func
(paren
id|buffer
)paren
suffix:semicolon
id|pnt
op_assign
id|get_string
c_func
(paren
id|pnt
comma
op_amp
id|cfg-&gt;value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_define_string
suffix:colon
id|pnt
op_assign
id|get_string
c_func
(paren
id|pnt
comma
op_amp
id|buffer
)paren
suffix:semicolon
id|cfg-&gt;nameindex
op_assign
id|get_varnum
c_func
(paren
id|buffer
)paren
suffix:semicolon
id|pnt
op_assign
id|get_qnqstring
c_func
(paren
id|pnt
comma
op_amp
id|cfg-&gt;value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;value
op_eq
l_int|NULL
)paren
id|syntax_error
c_func
(paren
l_string|&quot;missing value&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_dep_bool
suffix:colon
r_case
id|token_dep_mbool
suffix:colon
r_case
id|token_dep_tristate
suffix:colon
id|pnt
op_assign
id|get_qstring
(paren
id|pnt
comma
op_amp
id|cfg-&gt;label
)paren
suffix:semicolon
id|pnt
op_assign
id|get_string
(paren
id|pnt
comma
op_amp
id|buffer
)paren
suffix:semicolon
id|cfg-&gt;nameindex
op_assign
id|get_varnum
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|pnt
op_increment
suffix:semicolon
id|dep_ptr
op_assign
op_amp
(paren
id|cfg-&gt;depend
)paren
suffix:semicolon
r_do
(brace
op_star
id|dep_ptr
op_assign
(paren
r_struct
id|dependency
op_star
)paren
id|malloc
c_func
(paren
r_sizeof
(paren
r_struct
id|dependency
)paren
)paren
suffix:semicolon
(paren
op_star
id|dep_ptr
)paren
op_member_access_from_pointer
id|next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pnt
(braket
l_int|0
)braket
op_eq
l_char|&squot;Y&squot;
op_logical_or
id|pnt
(braket
l_int|0
)braket
op_eq
l_char|&squot;M&squot;
op_logical_or
id|pnt
(braket
l_int|0
)braket
op_eq
l_char|&squot;N&squot;
op_logical_or
id|pnt
(braket
l_int|0
)braket
op_eq
l_char|&squot;y&squot;
op_logical_or
id|pnt
(braket
l_int|0
)braket
op_eq
l_char|&squot;m&squot;
op_logical_or
id|pnt
(braket
l_int|0
)braket
op_eq
l_char|&squot;n&squot;
)paren
op_logical_and
(paren
id|pnt
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
id|pnt
(braket
l_int|1
)braket
op_eq
l_char|&squot; &squot;
op_logical_or
id|pnt
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;t&squot;
)paren
)paren
(brace
multiline_comment|/* dep_tristate &squot;foo&squot; CONFIG_FOO m */
r_if
c_cond
(paren
id|pnt
(braket
l_int|0
)braket
op_eq
l_char|&squot;Y&squot;
op_logical_or
id|pnt
(braket
l_int|0
)braket
op_eq
l_char|&squot;y&squot;
)paren
(paren
op_star
id|dep_ptr
)paren
op_member_access_from_pointer
id|name
op_assign
id|strdup
c_func
(paren
l_string|&quot;CONSTANT_Y&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pnt
(braket
l_int|0
)braket
op_eq
l_char|&squot;N&squot;
op_logical_or
id|pnt
(braket
l_int|0
)braket
op_eq
l_char|&squot;n&squot;
)paren
(paren
op_star
id|dep_ptr
)paren
op_member_access_from_pointer
id|name
op_assign
id|strdup
c_func
(paren
l_string|&quot;CONSTANT_N&quot;
)paren
suffix:semicolon
r_else
(paren
op_star
id|dep_ptr
)paren
op_member_access_from_pointer
id|name
op_assign
id|strdup
c_func
(paren
l_string|&quot;CONSTANT_M&quot;
)paren
suffix:semicolon
id|pnt
op_increment
suffix:semicolon
id|get_varnum
c_func
(paren
(paren
op_star
id|dep_ptr
)paren
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;$&squot;
)paren
(brace
id|pnt
op_increment
suffix:semicolon
id|pnt
op_assign
id|get_string
c_func
(paren
id|pnt
comma
op_amp
(paren
op_star
id|dep_ptr
)paren
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
id|get_varnum
c_func
(paren
(paren
op_star
id|dep_ptr
)paren
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
)brace
r_else
(brace
id|syntax_error
c_func
(paren
l_string|&quot;can&squot;t handle dep_bool/dep_mbool/dep_tristate condition&quot;
)paren
suffix:semicolon
)brace
id|dep_ptr
op_assign
op_amp
(paren
op_star
id|dep_ptr
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|pnt
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|pnt
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Create a conditional for this object&squot;s dependencies.&n;&t; */
(brace
r_char
id|fake_if
(braket
l_int|1024
)braket
suffix:semicolon
r_struct
id|dependency
op_star
id|dep
suffix:semicolon
r_struct
id|condition
op_star
op_star
id|cond_ptr
suffix:semicolon
r_int
id|first
op_assign
l_int|1
suffix:semicolon
id|cond_ptr
op_assign
op_amp
(paren
id|cfg-&gt;cond
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dep
op_assign
id|cfg-&gt;depend
suffix:semicolon
id|dep
suffix:semicolon
id|dep
op_assign
id|dep-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|token
op_eq
id|token_dep_tristate
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|dep-&gt;name
comma
l_string|&quot;CONSTANT_M&quot;
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|first
)paren
(brace
id|first
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
op_star
id|cond_ptr
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
r_struct
id|condition
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_star
id|cond_ptr
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|condition
)paren
)paren
suffix:semicolon
(paren
op_star
id|cond_ptr
)paren
op_member_access_from_pointer
id|op
op_assign
id|op_and
suffix:semicolon
id|cond_ptr
op_assign
op_amp
(paren
op_star
id|cond_ptr
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
op_star
id|cond_ptr
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
r_struct
id|condition
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_star
id|cond_ptr
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|condition
)paren
)paren
suffix:semicolon
(paren
op_star
id|cond_ptr
)paren
op_member_access_from_pointer
id|op
op_assign
id|op_lparen
suffix:semicolon
r_if
c_cond
(paren
id|token
op_eq
id|token_dep_bool
)paren
id|sprintf
c_func
(paren
id|fake_if
comma
l_string|&quot;[ &bslash;&quot;$%s&bslash;&quot; = &bslash;&quot;y&bslash;&quot; -o &bslash;&quot;$%s&bslash;&quot; = &bslash;&quot;&bslash;&quot; ]; then&quot;
comma
id|dep-&gt;name
comma
id|dep-&gt;name
)paren
suffix:semicolon
r_else
id|sprintf
c_func
(paren
id|fake_if
comma
l_string|&quot;[ &bslash;&quot;$%s&bslash;&quot; = &bslash;&quot;y&bslash;&quot; -o &bslash;&quot;$%s&bslash;&quot; = &bslash;&quot;m&bslash;&quot; -o &bslash;&quot;$%s&bslash;&quot; = &bslash;&quot;&bslash;&quot; ]; then&quot;
comma
id|dep-&gt;name
comma
id|dep-&gt;name
comma
id|dep-&gt;name
)paren
suffix:semicolon
(paren
op_star
id|cond_ptr
)paren
op_member_access_from_pointer
id|next
op_assign
id|tokenize_if
c_func
(paren
id|fake_if
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|cond_ptr
)paren
id|cond_ptr
op_assign
op_amp
(paren
op_star
id|cond_ptr
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
op_star
id|cond_ptr
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
r_struct
id|condition
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_star
id|cond_ptr
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|condition
)paren
)paren
suffix:semicolon
(paren
op_star
id|cond_ptr
)paren
op_member_access_from_pointer
id|op
op_assign
id|op_rparen
suffix:semicolon
id|cond_ptr
op_assign
op_amp
(paren
op_star
id|cond_ptr
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|token_else
suffix:colon
r_case
id|token_endmenu
suffix:colon
r_case
id|token_fi
suffix:colon
r_break
suffix:semicolon
r_case
id|token_hex
suffix:colon
r_case
id|token_int
suffix:colon
id|pnt
op_assign
id|get_qstring
(paren
id|pnt
comma
op_amp
id|cfg-&gt;label
)paren
suffix:semicolon
id|pnt
op_assign
id|get_string
(paren
id|pnt
comma
op_amp
id|buffer
)paren
suffix:semicolon
id|cfg-&gt;nameindex
op_assign
id|get_varnum
c_func
(paren
id|buffer
)paren
suffix:semicolon
id|pnt
op_assign
id|get_string
(paren
id|pnt
comma
op_amp
id|cfg-&gt;value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_string
suffix:colon
id|pnt
op_assign
id|get_qstring
(paren
id|pnt
comma
op_amp
id|cfg-&gt;label
)paren
suffix:semicolon
id|pnt
op_assign
id|get_string
(paren
id|pnt
comma
op_amp
id|buffer
)paren
suffix:semicolon
id|cfg-&gt;nameindex
op_assign
id|get_varnum
c_func
(paren
id|buffer
)paren
suffix:semicolon
id|pnt
op_assign
id|get_qnqstring
(paren
id|pnt
comma
op_amp
id|cfg-&gt;value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;value
op_eq
l_int|NULL
)paren
id|syntax_error
c_func
(paren
l_string|&quot;missing initial value&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_if
suffix:colon
id|cfg-&gt;cond
op_assign
id|tokenize_if
c_func
(paren
id|pnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_mainmenu_name
suffix:colon
id|pnt
op_assign
id|get_qstring
c_func
(paren
id|pnt
comma
op_amp
id|cfg-&gt;label
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_mainmenu_option
suffix:colon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|pnt
comma
l_string|&quot;next_comment&quot;
comma
l_int|12
)paren
op_eq
l_int|0
)paren
id|last_menuoption
op_assign
id|cfg
suffix:semicolon
r_else
id|pnt
op_assign
id|get_qstring
c_func
(paren
id|pnt
comma
op_amp
id|cfg-&gt;label
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_unset
suffix:colon
id|pnt
op_assign
id|get_string
c_func
(paren
id|pnt
comma
op_amp
id|buffer
)paren
suffix:semicolon
id|cfg-&gt;nameindex
op_assign
id|get_varnum
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|pnt
op_increment
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
)paren
(brace
id|cfg-&gt;next
op_assign
(paren
r_struct
id|kconfig
op_star
)paren
id|malloc
c_func
(paren
r_sizeof
(paren
r_struct
id|kconfig
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cfg-&gt;next
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|kconfig
)paren
)paren
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
suffix:semicolon
id|cfg-&gt;token
op_assign
id|token_unset
suffix:semicolon
id|pnt
op_assign
id|get_string
c_func
(paren
id|pnt
comma
op_amp
id|buffer
)paren
suffix:semicolon
id|cfg-&gt;nameindex
op_assign
id|get_varnum
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|pnt
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|pnt
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Implement the &quot;source&quot; command.&n; */
DECL|function|do_source
r_static
r_void
id|do_source
c_func
(paren
r_const
r_char
op_star
id|filename
)paren
(brace
r_char
id|buffer
(braket
l_int|2048
)braket
suffix:semicolon
id|FILE
op_star
id|infile
suffix:semicolon
r_const
r_char
op_star
id|old_file
suffix:semicolon
r_int
id|old_lineno
suffix:semicolon
r_int
id|offset
suffix:semicolon
multiline_comment|/* open the file */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|filename
comma
l_string|&quot;-&quot;
)paren
op_eq
l_int|0
)paren
id|infile
op_assign
id|stdin
suffix:semicolon
r_else
id|infile
op_assign
id|fopen
c_func
(paren
id|filename
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
multiline_comment|/* if that failed, try ../filename */
r_if
c_cond
(paren
id|infile
op_eq
l_int|NULL
)paren
(brace
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;../%s&quot;
comma
id|filename
)paren
suffix:semicolon
id|infile
op_assign
id|fopen
c_func
(paren
id|buffer
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|infile
op_eq
l_int|NULL
)paren
(brace
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;unable to open %s&quot;
comma
id|filename
)paren
suffix:semicolon
id|syntax_error
c_func
(paren
id|buffer
)paren
suffix:semicolon
)brace
multiline_comment|/* push the new file name and line number */
id|old_file
op_assign
id|current_file
suffix:semicolon
id|old_lineno
op_assign
id|lineno
suffix:semicolon
id|current_file
op_assign
id|filename
suffix:semicolon
id|lineno
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* read and process lines */
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
)paren
(brace
r_char
op_star
id|pnt
suffix:semicolon
multiline_comment|/* read a line */
id|fgets
c_func
(paren
id|buffer
op_plus
id|offset
comma
r_sizeof
(paren
id|buffer
)paren
op_minus
id|offset
comma
id|infile
)paren
suffix:semicolon
r_if
c_cond
(paren
id|feof
c_func
(paren
id|infile
)paren
)paren
r_break
suffix:semicolon
id|lineno
op_increment
suffix:semicolon
multiline_comment|/* strip the trailing return character */
id|pnt
op_assign
id|buffer
op_plus
id|strlen
c_func
(paren
id|buffer
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;&bslash;n&squot;
)paren
op_star
id|pnt
op_decrement
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* eat &bslash; NL pairs */
r_if
c_cond
(paren
op_star
id|pnt
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
id|offset
op_assign
id|pnt
op_minus
id|buffer
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* tokenize this line */
id|tokenize_line
c_func
(paren
id|buffer
)paren
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* that&squot;s all, folks */
r_if
c_cond
(paren
id|infile
op_ne
id|stdin
)paren
id|fclose
c_func
(paren
id|infile
)paren
suffix:semicolon
id|current_file
op_assign
id|old_file
suffix:semicolon
id|lineno
op_assign
id|old_lineno
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Main program.&n; */
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
id|argv
(braket
)braket
)paren
(brace
id|do_source
(paren
l_string|&quot;-&quot;
)paren
suffix:semicolon
id|fix_conditionals
(paren
id|config_list
)paren
suffix:semicolon
id|dump_tk_script
(paren
id|config_list
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
