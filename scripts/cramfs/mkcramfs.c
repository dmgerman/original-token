macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;sys/stat.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;sys/mman.h&gt;
macro_line|#include &lt;sys/fcntl.h&gt;
macro_line|#include &lt;dirent.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;assert.h&gt;
multiline_comment|/* zlib required.. */
macro_line|#include &lt;zlib.h&gt;
DECL|typedef|u8
r_typedef
r_int
r_char
id|u8
suffix:semicolon
DECL|typedef|u16
r_typedef
r_int
r_int
id|u16
suffix:semicolon
DECL|typedef|u32
r_typedef
r_int
r_int
id|u32
suffix:semicolon
macro_line|#include &quot;cramfs.h&quot;
DECL|variable|progname
r_static
r_const
r_char
op_star
id|progname
op_assign
l_string|&quot;mkcramfs&quot;
suffix:semicolon
multiline_comment|/* N.B. If you change the disk format of cramfs, please update fs/cramfs/README. */
DECL|function|usage
r_static
r_void
id|usage
c_func
(paren
r_void
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Usage: &squot;%s dirname outfile&squot;&bslash;n&quot;
l_string|&quot; where &lt;dirname&gt; is the root of the&bslash;n&quot;
l_string|&quot; filesystem to be compressed.&bslash;n&quot;
comma
id|progname
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If DO_HOLES is defined, then mkcramfs can create explicit holes in the&n; * data, which saves 26 bytes per hole (which is a lot smaller a saving than&n; * most filesystems).&n; *&n; * Note that kernels up to at least 2.3.39 don&squot;t support cramfs holes, which&n; * is why this defaults to undefined at the moment.&n; */
multiline_comment|/* #define DO_HOLES 1 */
DECL|macro|PAGE_CACHE_SIZE
mdefine_line|#define PAGE_CACHE_SIZE (4096)
multiline_comment|/* The kernel assumes PAGE_CACHE_SIZE as block size. */
DECL|variable|blksize
r_static
r_int
r_int
id|blksize
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
DECL|variable|warn_dev
DECL|variable|warn_gid
DECL|variable|warn_namelen
DECL|variable|warn_size
DECL|variable|warn_uid
r_static
r_int
id|warn_dev
comma
id|warn_gid
comma
id|warn_namelen
comma
id|warn_size
comma
id|warn_uid
suffix:semicolon
macro_line|#ifndef MIN
DECL|macro|MIN
macro_line|# define MIN(_a,_b) ((_a) &lt; (_b) ? (_a) : (_b))
macro_line|#endif
multiline_comment|/* In-core version of inode / directory entry. */
DECL|struct|entry
r_struct
id|entry
(brace
multiline_comment|/* stats */
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|mode
DECL|member|size
DECL|member|uid
DECL|member|gid
r_int
r_int
id|mode
comma
id|size
comma
id|uid
comma
id|gid
suffix:semicolon
multiline_comment|/* FS data */
DECL|member|uncompressed
r_void
op_star
id|uncompressed
suffix:semicolon
multiline_comment|/* points to other identical file */
DECL|member|same
r_struct
id|entry
op_star
id|same
suffix:semicolon
DECL|member|offset
r_int
r_int
id|offset
suffix:semicolon
multiline_comment|/* pointer to compressed data in archive */
DECL|member|dir_offset
r_int
r_int
id|dir_offset
suffix:semicolon
multiline_comment|/* Where in the archive is the directory entry? */
multiline_comment|/* organization */
DECL|member|child
r_struct
id|entry
op_star
id|child
suffix:semicolon
multiline_comment|/* null for non-directories and empty directories */
DECL|member|next
r_struct
id|entry
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Width of various bitfields in struct cramfs_inode.&n; * Used only to generate warnings.&n; */
DECL|macro|SIZE_WIDTH
mdefine_line|#define SIZE_WIDTH 24
DECL|macro|UID_WIDTH
mdefine_line|#define UID_WIDTH 16
DECL|macro|GID_WIDTH
mdefine_line|#define GID_WIDTH 8
DECL|macro|OFFSET_WIDTH
mdefine_line|#define OFFSET_WIDTH 26
multiline_comment|/*&n; * The longest file name component to allow for in the input directory tree.&n; * Ext2fs (and many others) allow up to 255 bytes.  A couple of filesystems&n; * allow longer (e.g. smbfs 1024), but there isn&squot;t much use in supporting&n; * &gt;255-byte names in the input directory tree given that such names get&n; * truncated to 255 bytes when written to cramfs.&n; */
DECL|macro|MAX_INPUT_NAMELEN
mdefine_line|#define MAX_INPUT_NAMELEN 255
DECL|function|find_identical_file
r_static
r_int
id|find_identical_file
c_func
(paren
r_struct
id|entry
op_star
id|orig
comma
r_struct
id|entry
op_star
id|newfile
)paren
(brace
r_if
c_cond
(paren
id|orig
op_eq
id|newfile
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|orig
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|orig-&gt;size
op_eq
id|newfile-&gt;size
op_logical_and
id|orig-&gt;uncompressed
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|orig-&gt;uncompressed
comma
id|newfile-&gt;uncompressed
comma
id|orig-&gt;size
)paren
)paren
(brace
id|newfile-&gt;same
op_assign
id|orig
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
id|find_identical_file
c_func
(paren
id|orig-&gt;child
comma
id|newfile
)paren
op_logical_or
id|find_identical_file
c_func
(paren
id|orig-&gt;next
comma
id|newfile
)paren
suffix:semicolon
)brace
DECL|function|eliminate_doubles
r_static
r_void
id|eliminate_doubles
c_func
(paren
r_struct
id|entry
op_star
id|root
comma
r_struct
id|entry
op_star
id|orig
)paren
(brace
r_if
c_cond
(paren
id|orig
)paren
(brace
r_if
c_cond
(paren
id|orig-&gt;size
op_logical_and
id|orig-&gt;uncompressed
)paren
(brace
id|find_identical_file
c_func
(paren
id|root
comma
id|orig
)paren
suffix:semicolon
)brace
id|eliminate_doubles
c_func
(paren
id|root
comma
id|orig-&gt;child
)paren
suffix:semicolon
id|eliminate_doubles
c_func
(paren
id|root
comma
id|orig-&gt;next
)paren
suffix:semicolon
)brace
)brace
DECL|function|parse_directory
r_static
r_int
r_int
id|parse_directory
c_func
(paren
r_struct
id|entry
op_star
id|root_entry
comma
r_const
r_char
op_star
id|name
comma
r_struct
id|entry
op_star
op_star
id|prev
comma
id|loff_t
op_star
id|fslen_ub
)paren
(brace
id|DIR
op_star
id|dir
suffix:semicolon
r_int
id|count
op_assign
l_int|0
comma
id|totalsize
op_assign
l_int|0
suffix:semicolon
r_struct
id|dirent
op_star
id|dirent
suffix:semicolon
r_char
op_star
id|path
comma
op_star
id|endpath
suffix:semicolon
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|dir
op_assign
id|opendir
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
(brace
id|perror
c_func
(paren
id|name
)paren
suffix:semicolon
m_exit
(paren
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* Set up the path. */
multiline_comment|/* TODO: Reuse the parent&squot;s buffer to save memcpy&squot;ing and duplication. */
id|path
op_assign
id|malloc
c_func
(paren
id|len
op_plus
l_int|1
op_plus
id|MAX_INPUT_NAMELEN
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|path
)paren
(brace
id|perror
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|path
comma
id|name
comma
id|len
)paren
suffix:semicolon
id|endpath
op_assign
id|path
op_plus
id|len
suffix:semicolon
op_star
id|endpath
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|endpath
op_increment
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dirent
op_assign
id|readdir
c_func
(paren
id|dir
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|entry
op_star
id|entry
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
id|namelen
suffix:semicolon
multiline_comment|/* Ignore &quot;.&quot; and &quot;..&quot; - we won&squot;t be adding them to the archive */
r_if
c_cond
(paren
id|dirent-&gt;d_name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
r_if
c_cond
(paren
id|dirent-&gt;d_name
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dirent-&gt;d_name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
r_if
c_cond
(paren
id|dirent-&gt;d_name
(braket
l_int|2
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_continue
suffix:semicolon
)brace
)brace
id|namelen
op_assign
id|strlen
c_func
(paren
id|dirent-&gt;d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|namelen
OG
id|MAX_INPUT_NAMELEN
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Very long (%u bytes) filename `%s&squot; found.&bslash;n&quot;
l_string|&quot; Please increase MAX_INPUT_NAMELEN in mkcramfs.c and recompile.  Exiting.&bslash;n&quot;
comma
id|namelen
comma
id|dirent-&gt;d_name
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|endpath
comma
id|dirent-&gt;d_name
comma
id|namelen
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|endpath
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|entry
op_assign
id|calloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|entry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
(brace
id|perror
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
m_exit
(paren
l_int|5
)paren
suffix:semicolon
)brace
id|entry-&gt;name
op_assign
id|strdup
c_func
(paren
id|dirent-&gt;d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;name
)paren
(brace
id|perror
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|namelen
OG
l_int|255
)paren
(brace
multiline_comment|/* Can&squot;t happen when reading from ext2fs. */
multiline_comment|/* TODO: we ought to avoid chopping in half&n;&t;&t;&t;   multi-byte UTF8 characters. */
id|entry-&gt;name
(braket
id|namelen
op_assign
l_int|255
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|warn_namelen
op_assign
l_int|1
suffix:semicolon
)brace
id|entry-&gt;mode
op_assign
id|st.st_mode
suffix:semicolon
id|entry-&gt;size
op_assign
id|st.st_size
suffix:semicolon
id|entry-&gt;uid
op_assign
id|st.st_uid
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;uid
op_ge
l_int|1
op_lshift
id|UID_WIDTH
)paren
id|warn_uid
op_assign
l_int|1
suffix:semicolon
id|entry-&gt;gid
op_assign
id|st.st_gid
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;gid
op_ge
l_int|1
op_lshift
id|GID_WIDTH
)paren
multiline_comment|/* TODO: We ought to replace with a default&n;                           gid instead of truncating; otherwise there&n;                           are security problems.  Maybe mode should&n;                           be &amp;= ~070.  Same goes for uid once Linux&n;                           supports &gt;16-bit uids. */
id|warn_gid
op_assign
l_int|1
suffix:semicolon
id|size
op_assign
r_sizeof
(paren
r_struct
id|cramfs_inode
)paren
op_plus
(paren
(paren
id|namelen
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
)paren
suffix:semicolon
op_star
id|fslen_ub
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|entry-&gt;size
op_assign
id|parse_directory
c_func
(paren
id|root_entry
comma
id|path
comma
op_amp
id|entry-&gt;child
comma
id|fslen_ub
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
multiline_comment|/* TODO: We ought to open files in do_compress, one&n;&t;&t;&t;   at a time, instead of amassing all these memory&n;&t;&t;&t;   maps during parse_directory (which don&squot;t get used&n;&t;&t;&t;   until do_compress anyway).  As it is, we tend to&n;&t;&t;&t;   get EMFILE errors (especially if mkcramfs is run&n;&t;&t;&t;   by non-root).&n;&n;&t;&t;&t;   While we&squot;re at it, do analagously for symlinks&n;&t;&t;&t;   (which would just save a little memory). */
r_int
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|path
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;size
)paren
(brace
r_if
c_cond
(paren
(paren
id|entry-&gt;size
op_ge
l_int|1
op_lshift
id|SIZE_WIDTH
)paren
)paren
(brace
id|warn_size
op_assign
l_int|1
suffix:semicolon
id|entry-&gt;size
op_assign
(paren
l_int|1
op_lshift
id|SIZE_WIDTH
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|entry-&gt;uncompressed
op_assign
id|mmap
c_func
(paren
l_int|NULL
comma
id|entry-&gt;size
comma
id|PROT_READ
comma
id|MAP_PRIVATE
comma
id|fd
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
(paren
r_int
)paren
(paren
r_int
)paren
id|entry-&gt;uncompressed
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;mmap&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|5
)paren
suffix:semicolon
)brace
)brace
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|entry-&gt;uncompressed
op_assign
id|malloc
c_func
(paren
id|entry-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;uncompressed
)paren
(brace
id|perror
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
m_exit
(paren
l_int|5
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|readlink
c_func
(paren
id|path
comma
id|entry-&gt;uncompressed
comma
id|entry-&gt;size
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|path
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_else
(brace
id|entry-&gt;size
op_assign
id|st.st_rdev
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;size
op_amp
op_minus
(paren
l_int|1
op_lshift
id|SIZE_WIDTH
)paren
)paren
id|warn_dev
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
op_logical_or
id|S_ISLNK
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
multiline_comment|/* block pointers &amp; data expansion allowance + data */
r_if
c_cond
(paren
id|entry-&gt;size
)paren
(brace
op_star
id|fslen_ub
op_add_assign
(paren
(paren
l_int|4
op_plus
l_int|26
)paren
op_star
(paren
(paren
id|entry-&gt;size
op_minus
l_int|1
)paren
op_div
id|blksize
op_plus
l_int|1
)paren
op_plus
id|MIN
c_func
(paren
id|entry-&gt;size
op_plus
l_int|3
comma
id|st.st_blocks
op_lshift
l_int|9
)paren
)paren
suffix:semicolon
)brace
r_else
op_star
id|fslen_ub
op_add_assign
id|MIN
c_func
(paren
id|entry-&gt;size
op_plus
l_int|3
comma
id|st.st_blocks
op_lshift
l_int|9
)paren
suffix:semicolon
)brace
multiline_comment|/* Link it into the list */
op_star
id|prev
op_assign
id|entry
suffix:semicolon
id|prev
op_assign
op_amp
id|entry-&gt;next
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|totalsize
op_add_assign
id|size
suffix:semicolon
)brace
id|closedir
c_func
(paren
id|dir
)paren
suffix:semicolon
id|free
c_func
(paren
id|path
)paren
suffix:semicolon
r_return
id|totalsize
suffix:semicolon
)brace
DECL|function|set_random
r_static
r_void
id|set_random
c_func
(paren
r_void
op_star
id|area
comma
r_int
id|size
)paren
(brace
r_int
id|fd
op_assign
id|open
c_func
(paren
l_string|&quot;/dev/random&quot;
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|read
c_func
(paren
id|fd
comma
id|area
comma
id|size
)paren
op_eq
id|size
)paren
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|area
comma
l_int|0x00
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/* Returns sizeof(struct cramfs_super), which includes the root inode. */
DECL|function|write_superblock
r_static
r_int
r_int
id|write_superblock
c_func
(paren
r_struct
id|entry
op_star
id|root
comma
r_char
op_star
id|base
)paren
(brace
r_struct
id|cramfs_super
op_star
id|super
op_assign
(paren
r_struct
id|cramfs_super
op_star
)paren
id|base
suffix:semicolon
r_int
r_int
id|offset
op_assign
r_sizeof
(paren
r_struct
id|cramfs_super
)paren
suffix:semicolon
id|super-&gt;magic
op_assign
id|CRAMFS_MAGIC
suffix:semicolon
id|super-&gt;flags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Note: 0x10000 is meaningless, which is a bug; but&n;&t;   super-&gt;size is never used anyway. */
id|super-&gt;size
op_assign
l_int|0x10000
suffix:semicolon
id|memcpy
c_func
(paren
id|super-&gt;signature
comma
id|CRAMFS_SIGNATURE
comma
r_sizeof
(paren
id|super-&gt;signature
)paren
)paren
suffix:semicolon
id|set_random
c_func
(paren
id|super-&gt;fsid
comma
r_sizeof
(paren
id|super-&gt;fsid
)paren
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|super-&gt;name
comma
l_string|&quot;Compressed&quot;
comma
r_sizeof
(paren
id|super-&gt;name
)paren
)paren
suffix:semicolon
id|super-&gt;root.mode
op_assign
id|root-&gt;mode
suffix:semicolon
id|super-&gt;root.uid
op_assign
id|root-&gt;uid
suffix:semicolon
id|super-&gt;root.gid
op_assign
id|root-&gt;gid
suffix:semicolon
id|super-&gt;root.size
op_assign
id|root-&gt;size
suffix:semicolon
id|super-&gt;root.offset
op_assign
id|offset
op_rshift
l_int|2
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
DECL|function|set_data_offset
r_static
r_void
id|set_data_offset
c_func
(paren
r_struct
id|entry
op_star
id|entry
comma
r_char
op_star
id|base
comma
r_int
r_int
id|offset
)paren
(brace
r_struct
id|cramfs_inode
op_star
id|inode
op_assign
(paren
r_struct
id|cramfs_inode
op_star
)paren
(paren
id|base
op_plus
id|entry-&gt;dir_offset
)paren
suffix:semicolon
m_assert
(paren
(paren
id|offset
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
(paren
l_int|1
op_lshift
(paren
l_int|2
op_plus
id|OFFSET_WIDTH
)paren
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;filesystem too big.  Exiting.&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|inode-&gt;offset
op_assign
(paren
id|offset
op_rshift
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We do a width-first printout of the directory&n; * entries, using a stack to remember the directories&n; * we&squot;ve seen.&n; */
DECL|macro|MAXENTRIES
mdefine_line|#define MAXENTRIES (100)
DECL|function|write_directory_structure
r_static
r_int
r_int
id|write_directory_structure
c_func
(paren
r_struct
id|entry
op_star
id|entry
comma
r_char
op_star
id|base
comma
r_int
r_int
id|offset
)paren
(brace
r_int
id|stack_entries
op_assign
l_int|0
suffix:semicolon
r_struct
id|entry
op_star
id|entry_stack
(braket
id|MAXENTRIES
)braket
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|dir_start
op_assign
id|stack_entries
suffix:semicolon
r_while
c_loop
(paren
id|entry
)paren
(brace
r_struct
id|cramfs_inode
op_star
id|inode
op_assign
(paren
r_struct
id|cramfs_inode
op_star
)paren
(paren
id|base
op_plus
id|offset
)paren
suffix:semicolon
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|entry-&gt;name
)paren
suffix:semicolon
id|entry-&gt;dir_offset
op_assign
id|offset
suffix:semicolon
id|inode-&gt;mode
op_assign
id|entry-&gt;mode
suffix:semicolon
id|inode-&gt;uid
op_assign
id|entry-&gt;uid
suffix:semicolon
id|inode-&gt;gid
op_assign
id|entry-&gt;gid
suffix:semicolon
id|inode-&gt;size
op_assign
id|entry-&gt;size
suffix:semicolon
id|inode-&gt;offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Non-empty directories, regfiles and symlinks will&n;&t;&t;&t;   write over inode-&gt;offset later. */
id|offset
op_add_assign
r_sizeof
(paren
r_struct
id|cramfs_inode
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|base
op_plus
id|offset
comma
id|entry-&gt;name
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Pad up the name to a 4-byte boundary */
r_while
c_loop
(paren
id|len
op_amp
l_int|3
)paren
(brace
op_star
(paren
id|base
op_plus
id|offset
op_plus
id|len
)paren
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|len
op_increment
suffix:semicolon
)brace
id|inode-&gt;namelen
op_assign
id|len
op_rshift
l_int|2
suffix:semicolon
id|offset
op_add_assign
id|len
suffix:semicolon
multiline_comment|/* TODO: this may get it wrong for chars &gt;= 0x80.&n;&t;&t;&t;   Most filesystems use UTF8 encoding for filenames,&n;&t;&t;&t;   whereas the console is a single-byte character&n;&t;&t;&t;   set like iso-latin-1. */
id|printf
c_func
(paren
l_string|&quot;  %s&bslash;n&quot;
comma
id|entry-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;child
)paren
(brace
r_if
c_cond
(paren
id|stack_entries
op_ge
id|MAXENTRIES
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Exceeded MAXENTRIES.  Raise this value in mkcramfs.c and recompile.  Exiting.&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|entry_stack
(braket
id|stack_entries
)braket
op_assign
id|entry
suffix:semicolon
id|stack_entries
op_increment
suffix:semicolon
)brace
id|entry
op_assign
id|entry-&gt;next
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Reverse the order the stack entries pushed during&n;                 * this directory, for a small optimization of disk&n;                 * access in the created fs.  This change makes things&n;                 * `ls -UR&squot; order.&n;&t;&t; */
(brace
r_struct
id|entry
op_star
op_star
id|lo
op_assign
id|entry_stack
op_plus
id|dir_start
suffix:semicolon
r_struct
id|entry
op_star
op_star
id|hi
op_assign
id|entry_stack
op_plus
id|stack_entries
suffix:semicolon
r_struct
id|entry
op_star
id|tmp
suffix:semicolon
r_while
c_loop
(paren
id|lo
OL
op_decrement
id|hi
)paren
(brace
id|tmp
op_assign
op_star
id|lo
suffix:semicolon
op_star
id|lo
op_increment
op_assign
op_star
id|hi
suffix:semicolon
op_star
id|hi
op_assign
id|tmp
suffix:semicolon
)brace
)brace
multiline_comment|/* Pop a subdirectory entry from the stack, and recurse. */
r_if
c_cond
(paren
op_logical_neg
id|stack_entries
)paren
r_break
suffix:semicolon
id|stack_entries
op_decrement
suffix:semicolon
id|entry
op_assign
id|entry_stack
(braket
id|stack_entries
)braket
suffix:semicolon
id|set_data_offset
c_func
(paren
id|entry
comma
id|base
comma
id|offset
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&squot;%s&squot;:&bslash;n&quot;
comma
id|entry-&gt;name
)paren
suffix:semicolon
id|entry
op_assign
id|entry-&gt;child
suffix:semicolon
)brace
r_return
id|offset
suffix:semicolon
)brace
macro_line|#ifdef DO_HOLES
multiline_comment|/*&n; * Returns non-zero iff the first LEN bytes from BEGIN are all NULs.&n; */
r_static
r_int
DECL|function|is_zero
id|is_zero
c_func
(paren
r_char
r_const
op_star
id|begin
comma
r_int
id|len
)paren
(brace
r_return
(paren
id|len
op_decrement
op_eq
l_int|0
op_logical_or
(paren
id|begin
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_and
(paren
id|len
op_decrement
op_eq
l_int|0
op_logical_or
(paren
id|begin
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_and
(paren
id|len
op_decrement
op_eq
l_int|0
op_logical_or
(paren
id|begin
(braket
l_int|2
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_and
(paren
id|len
op_decrement
op_eq
l_int|0
op_logical_or
(paren
id|begin
(braket
l_int|3
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_and
id|memcmp
c_func
(paren
id|begin
comma
id|begin
op_plus
l_int|4
comma
id|len
)paren
op_eq
l_int|0
)paren
)paren
)paren
)paren
)paren
)paren
)paren
)paren
suffix:semicolon
)brace
macro_line|#else /* !DO_HOLES */
DECL|macro|is_zero
macro_line|# define is_zero(_begin,_len) (0)  /* Never create holes. */
macro_line|#endif /* !DO_HOLES */
multiline_comment|/*&n; * One 4-byte pointer per block and then the actual blocked&n; * output. The first block does not need an offset pointer,&n; * as it will start immediately after the pointer block;&n; * so the i&squot;th pointer points to the end of the i&squot;th block&n; * (i.e. the start of the (i+1)&squot;th block or past EOF).&n; *&n; * Note that size &gt; 0, as a zero-sized file wouldn&squot;t ever&n; * have gotten here in the first place.&n; */
DECL|function|do_compress
r_static
r_int
r_int
id|do_compress
c_func
(paren
r_char
op_star
id|base
comma
r_int
r_int
id|offset
comma
r_char
r_const
op_star
id|name
comma
r_char
op_star
id|uncompressed
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|original_size
op_assign
id|size
suffix:semicolon
r_int
r_int
id|original_offset
op_assign
id|offset
suffix:semicolon
r_int
r_int
id|new_size
suffix:semicolon
r_int
r_int
id|blocks
op_assign
(paren
id|size
op_minus
l_int|1
)paren
op_div
id|blksize
op_plus
l_int|1
suffix:semicolon
r_int
r_int
id|curr
op_assign
id|offset
op_plus
l_int|4
op_star
id|blocks
suffix:semicolon
r_int
id|change
suffix:semicolon
r_do
(brace
r_int
r_int
id|len
op_assign
l_int|2
op_star
id|blksize
suffix:semicolon
r_int
r_int
id|input
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|input
OG
id|blksize
)paren
id|input
op_assign
id|blksize
suffix:semicolon
id|size
op_sub_assign
id|input
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_zero
(paren
id|uncompressed
comma
id|input
)paren
)paren
(brace
id|compress
c_func
(paren
id|base
op_plus
id|curr
comma
op_amp
id|len
comma
id|uncompressed
comma
id|input
)paren
suffix:semicolon
id|curr
op_add_assign
id|len
suffix:semicolon
)brace
id|uncompressed
op_add_assign
id|input
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|blksize
op_star
l_int|2
)paren
(brace
multiline_comment|/* (I don&squot;t think this can happen with zlib.) */
id|printf
c_func
(paren
l_string|&quot;AIEEE: block &bslash;&quot;compressed&bslash;&quot; to &gt; 2*blocklength (%ld)&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
op_star
(paren
id|u32
op_star
)paren
(paren
id|base
op_plus
id|offset
)paren
op_assign
id|curr
suffix:semicolon
id|offset
op_add_assign
l_int|4
suffix:semicolon
)brace
r_while
c_loop
(paren
id|size
)paren
suffix:semicolon
id|curr
op_assign
(paren
id|curr
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
suffix:semicolon
id|new_size
op_assign
id|curr
op_minus
id|original_offset
suffix:semicolon
multiline_comment|/* TODO: Arguably, original_size in these 2 lines should be&n;&t;   st_blocks * 512.  But if you say that then perhaps&n;&t;   administrative data should also be included in both. */
id|change
op_assign
id|new_size
op_minus
id|original_size
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%6.2f%% (%+d bytes)&bslash;t%s&bslash;n&quot;
comma
(paren
id|change
op_star
l_int|100
)paren
op_div
(paren
r_float
)paren
id|original_size
comma
id|change
comma
id|name
)paren
suffix:semicolon
r_return
id|curr
suffix:semicolon
)brace
multiline_comment|/*&n; * Traverse the entry tree, writing data for every item that has&n; * non-null entry-&gt;compressed (i.e. every symlink and non-empty&n; * regfile).&n; */
DECL|function|write_data
r_static
r_int
r_int
id|write_data
c_func
(paren
r_struct
id|entry
op_star
id|entry
comma
r_char
op_star
id|base
comma
r_int
r_int
id|offset
)paren
(brace
r_do
(brace
r_if
c_cond
(paren
id|entry-&gt;uncompressed
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;same
)paren
(brace
id|set_data_offset
c_func
(paren
id|entry
comma
id|base
comma
id|entry-&gt;same-&gt;offset
)paren
suffix:semicolon
id|entry-&gt;offset
op_assign
id|entry-&gt;same-&gt;offset
suffix:semicolon
)brace
r_else
(brace
id|set_data_offset
c_func
(paren
id|entry
comma
id|base
comma
id|offset
)paren
suffix:semicolon
id|entry-&gt;offset
op_assign
id|offset
suffix:semicolon
id|offset
op_assign
id|do_compress
c_func
(paren
id|base
comma
id|offset
comma
id|entry-&gt;name
comma
id|entry-&gt;uncompressed
comma
id|entry-&gt;size
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|entry-&gt;child
)paren
id|offset
op_assign
id|write_data
c_func
(paren
id|entry-&gt;child
comma
id|base
comma
id|offset
)paren
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|entry
)paren
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
multiline_comment|/*&n; * Maximum size fs you can create is roughly 256MB.  (The last file&squot;s&n; * data must begin within 256MB boundary but can extend beyond that.)&n; *&n; * Note that if you want it to fit in a ROM then you&squot;re limited to what the&n; * hardware and kernel can support (64MB?).&n; */
DECL|macro|MAXFSLEN
mdefine_line|#define MAXFSLEN ((((1 &lt;&lt; OFFSET_WIDTH) - 1) &lt;&lt; 2) /* offset */ &bslash;&n;&t;&t;  + (1 &lt;&lt; SIZE_WIDTH) - 1 /* filesize */ &bslash;&n;&t;&t;  + (1 &lt;&lt; SIZE_WIDTH) * 4 / PAGE_CACHE_SIZE /* block pointers */ )
multiline_comment|/*&n; * Usage:&n; *&n; *      mkcramfs directory-name outfile&n; *&n; * where &quot;directory-name&quot; is simply the root of the directory&n; * tree that we want to generate a compressed filesystem out&n; * of.&n; */
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_struct
id|entry
op_star
id|root_entry
suffix:semicolon
r_char
op_star
id|rom_image
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
id|ssize_t
id|written
suffix:semicolon
r_int
id|fd
suffix:semicolon
id|loff_t
id|fslen_ub
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* initial guess (upper-bound) of&n;&t;&t;&t;&t;required filesystem size */
r_char
r_const
op_star
id|dirname
suffix:semicolon
r_if
c_cond
(paren
id|argc
)paren
id|progname
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|argc
op_ne
l_int|3
)paren
id|usage
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
c_func
(paren
id|dirname
op_assign
id|argv
(braket
l_int|1
)braket
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|argv
(braket
l_int|1
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|fd
op_assign
id|open
c_func
(paren
id|argv
(braket
l_int|2
)braket
comma
id|O_WRONLY
op_or
id|O_CREAT
op_or
id|O_TRUNC
comma
l_int|0666
)paren
suffix:semicolon
id|root_entry
op_assign
id|calloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|entry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root_entry
)paren
(brace
id|perror
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
m_exit
(paren
l_int|5
)paren
suffix:semicolon
)brace
id|root_entry-&gt;mode
op_assign
id|st.st_mode
suffix:semicolon
id|root_entry-&gt;uid
op_assign
id|st.st_uid
suffix:semicolon
id|root_entry-&gt;gid
op_assign
id|st.st_gid
suffix:semicolon
id|root_entry-&gt;size
op_assign
id|parse_directory
c_func
(paren
id|root_entry
comma
id|argv
(braket
l_int|1
)braket
comma
op_amp
id|root_entry-&gt;child
comma
op_amp
id|fslen_ub
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fslen_ub
OG
id|MAXFSLEN
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;warning: guestimate of required size (upper bound) is %luMB, but maximum image size is %uMB.  We might die prematurely.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
id|fslen_ub
op_rshift
l_int|20
)paren
comma
id|MAXFSLEN
op_rshift
l_int|20
)paren
suffix:semicolon
id|fslen_ub
op_assign
id|MAXFSLEN
suffix:semicolon
)brace
multiline_comment|/* find duplicate files. TODO: uses the most inefficient algorithm&n;           possible. */
id|eliminate_doubles
c_func
(paren
id|root_entry
comma
id|root_entry
)paren
suffix:semicolon
multiline_comment|/* TODO: Why do we use a private/anonymous mapping here&n;           followed by a write below, instead of just a shared mapping&n;           and a couple of ftruncate calls?  Is it just to save us&n;           having to deal with removing the file afterwards?  If we&n;           really need this huge anonymous mapping, we ought to mmap&n;           in smaller chunks, so that the user doesn&squot;t need nn MB of&n;           RAM free.  If the reason is to be able to write to&n;           un-mmappable block devices, then we could try shared mmap&n;           and revert to anonymous mmap if the shared mmap fails. */
id|rom_image
op_assign
id|mmap
c_func
(paren
l_int|NULL
comma
id|fslen_ub
comma
id|PROT_READ
op_or
id|PROT_WRITE
comma
id|MAP_PRIVATE
op_or
id|MAP_ANONYMOUS
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
(paren
r_int
)paren
(paren
r_int
)paren
id|rom_image
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;ROM image map&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|offset
op_assign
id|write_superblock
c_func
(paren
id|root_entry
comma
id|rom_image
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Super block: %d bytes&bslash;n&quot;
comma
id|offset
)paren
suffix:semicolon
id|offset
op_assign
id|write_directory_structure
c_func
(paren
id|root_entry-&gt;child
comma
id|rom_image
comma
id|offset
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Directory data: %d bytes&bslash;n&quot;
comma
id|offset
)paren
suffix:semicolon
id|offset
op_assign
id|write_data
c_func
(paren
id|root_entry
comma
id|rom_image
comma
id|offset
)paren
suffix:semicolon
multiline_comment|/* We always write a multiple of blksize bytes, so that&n;           losetup works. */
id|offset
op_assign
(paren
(paren
id|offset
op_minus
l_int|1
)paren
op_or
(paren
id|blksize
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Everything: %d kilobytes&bslash;n&quot;
comma
id|offset
op_rshift
l_int|10
)paren
suffix:semicolon
id|written
op_assign
id|write
c_func
(paren
id|fd
comma
id|rom_image
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;rom image&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
op_ne
id|written
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;ROM image write failed (%d %d)&bslash;n&quot;
comma
id|written
comma
id|offset
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* (These warnings used to come at the start, but they scroll off the&n;           screen too quickly.) */
r_if
c_cond
(paren
id|warn_namelen
)paren
multiline_comment|/* (can&squot;t happen when reading from ext2fs) */
id|fprintf
c_func
(paren
id|stderr
comma
multiline_comment|/* bytes, not chars: think UTF8. */
l_string|&quot;warning: filenames truncated to 255 bytes.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|warn_size
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;warning: file sizes truncated to %luMB (minus 1 byte).&bslash;n&quot;
comma
l_int|1L
op_lshift
(paren
id|SIZE_WIDTH
op_minus
l_int|20
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|warn_uid
)paren
multiline_comment|/* (not possible with current Linux versions) */
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;warning: uids truncated to %u bits.  (This may be a security concern.)&bslash;n&quot;
comma
id|UID_WIDTH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|warn_gid
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;warning: gids truncated to %u bits.  (This may be a security concern.)&bslash;n&quot;
comma
id|GID_WIDTH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|warn_dev
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;WARNING: device numbers truncated to %u bits.  This almost certainly means&bslash;n&quot;
l_string|&quot;that some device files will be wrong.&bslash;n&quot;
comma
id|OFFSET_WIDTH
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
