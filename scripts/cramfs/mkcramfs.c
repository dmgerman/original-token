macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;sys/stat.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;sys/mman.h&gt;
macro_line|#include &lt;sys/fcntl.h&gt;
macro_line|#include &lt;dirent.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
multiline_comment|/* zlib required.. */
macro_line|#include &lt;zlib.h&gt;
DECL|typedef|u8
r_typedef
r_int
r_char
id|u8
suffix:semicolon
DECL|typedef|u16
r_typedef
r_int
r_int
id|u16
suffix:semicolon
DECL|typedef|u32
r_typedef
r_int
r_int
id|u32
suffix:semicolon
macro_line|#include &quot;cramfs.h&quot;
DECL|macro|PAGE_CACHE_SIZE
mdefine_line|#define PAGE_CACHE_SIZE (4096)
DECL|variable|progname
r_static
r_const
r_char
op_star
id|progname
op_assign
l_string|&quot;mkcramfs&quot;
suffix:semicolon
DECL|function|usage
r_void
id|usage
c_func
(paren
r_void
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Usage: &squot;%s dirname outfile&squot;&bslash;n&quot;
l_string|&quot; where &lt;dirname&gt; is the root of the&bslash;n&quot;
l_string|&quot; filesystem to be compressed.&bslash;n&quot;
comma
id|progname
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|struct|entry
r_struct
id|entry
(brace
multiline_comment|/* stats */
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|mode
DECL|member|size
DECL|member|uid
DECL|member|gid
r_int
r_int
id|mode
comma
id|size
comma
id|uid
comma
id|gid
suffix:semicolon
multiline_comment|/* FS data */
DECL|member|uncompressed
r_void
op_star
id|uncompressed
suffix:semicolon
DECL|member|dir_offset
r_int
r_int
id|dir_offset
suffix:semicolon
multiline_comment|/* Where in the archive is the directory entry? */
DECL|member|data_offset
r_int
r_int
id|data_offset
suffix:semicolon
multiline_comment|/* Where in the archive is the start of the data? */
multiline_comment|/* organization */
DECL|member|child
r_struct
id|entry
op_star
id|child
suffix:semicolon
DECL|member|next
r_struct
id|entry
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * We should mind about memory leaks and&n; * checking for out-of-memory.&n; *&n; * We don&squot;t.&n; */
DECL|function|parse_directory
r_static
r_int
r_int
id|parse_directory
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|entry
op_star
op_star
id|prev
)paren
(brace
id|DIR
op_star
id|dir
suffix:semicolon
r_int
id|count
op_assign
l_int|0
comma
id|totalsize
op_assign
l_int|0
suffix:semicolon
r_struct
id|dirent
op_star
id|dirent
suffix:semicolon
r_char
op_star
id|path
comma
op_star
id|endpath
suffix:semicolon
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|dir
op_assign
id|opendir
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
(brace
id|perror
c_func
(paren
id|name
)paren
suffix:semicolon
m_exit
(paren
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* Set up the path.. */
id|path
op_assign
id|malloc
c_func
(paren
l_int|4096
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|path
comma
id|name
comma
id|len
)paren
suffix:semicolon
id|endpath
op_assign
id|path
op_plus
id|len
suffix:semicolon
op_star
id|endpath
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|endpath
op_increment
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dirent
op_assign
id|readdir
c_func
(paren
id|dir
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|entry
op_star
id|entry
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
r_int
id|fd
comma
id|size
suffix:semicolon
multiline_comment|/* Ignore &quot;.&quot; and &quot;..&quot; - we won&squot;t be adding them to the archive */
r_if
c_cond
(paren
id|dirent-&gt;d_name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
r_if
c_cond
(paren
id|dirent-&gt;d_name
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dirent-&gt;d_name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
r_if
c_cond
(paren
id|dirent-&gt;d_name
(braket
l_int|2
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_continue
suffix:semicolon
)brace
)brace
id|strcpy
c_func
(paren
id|endpath
comma
id|dirent-&gt;d_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lstat
c_func
(paren
id|path
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|endpath
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|entry
op_assign
id|calloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|entry
)paren
)paren
suffix:semicolon
id|entry-&gt;name
op_assign
id|strdup
c_func
(paren
id|dirent-&gt;d_name
)paren
suffix:semicolon
id|entry-&gt;mode
op_assign
id|st.st_mode
suffix:semicolon
id|entry-&gt;size
op_assign
id|st.st_size
suffix:semicolon
id|entry-&gt;uid
op_assign
id|st.st_uid
suffix:semicolon
id|entry-&gt;gid
op_assign
id|st.st_gid
suffix:semicolon
id|size
op_assign
r_sizeof
(paren
r_struct
id|cramfs_inode
)paren
op_plus
(paren
op_complement
l_int|3
op_amp
(paren
id|strlen
c_func
(paren
id|entry-&gt;name
)paren
op_plus
l_int|3
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|entry-&gt;size
op_assign
id|parse_directory
c_func
(paren
id|path
comma
op_amp
id|entry-&gt;child
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
r_int
id|fd
op_assign
id|open
c_func
(paren
id|path
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|path
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;size
)paren
id|entry-&gt;uncompressed
op_assign
id|mmap
c_func
(paren
l_int|NULL
comma
id|st.st_size
comma
id|PROT_READ
comma
id|MAP_PRIVATE
comma
id|fd
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
(paren
r_int
)paren
(paren
r_int
)paren
id|entry-&gt;uncompressed
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;mmap&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|5
)paren
suffix:semicolon
)brace
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|st.st_mode
)paren
)paren
(brace
id|entry-&gt;uncompressed
op_assign
id|malloc
c_func
(paren
id|st.st_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|readlink
c_func
(paren
id|path
comma
id|entry-&gt;uncompressed
comma
id|st.st_size
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|path
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_else
(brace
id|entry-&gt;size
op_assign
id|st.st_rdev
suffix:semicolon
)brace
multiline_comment|/* Link it into the list */
op_star
id|prev
op_assign
id|entry
suffix:semicolon
id|prev
op_assign
op_amp
id|entry-&gt;next
suffix:semicolon
id|count
op_increment
suffix:semicolon
id|totalsize
op_add_assign
id|size
suffix:semicolon
)brace
id|closedir
c_func
(paren
id|dir
)paren
suffix:semicolon
id|free
c_func
(paren
id|path
)paren
suffix:semicolon
r_return
id|totalsize
suffix:semicolon
)brace
DECL|function|set_random
r_static
r_void
id|set_random
c_func
(paren
r_void
op_star
id|area
comma
r_int
id|size
)paren
(brace
r_int
id|fd
op_assign
id|open
c_func
(paren
l_string|&quot;/dev/random&quot;
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|read
c_func
(paren
id|fd
comma
id|area
comma
id|size
)paren
op_eq
id|size
)paren
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|area
comma
l_int|0x00
comma
id|size
)paren
suffix:semicolon
)brace
DECL|function|write_superblock
r_static
r_int
r_int
id|write_superblock
c_func
(paren
r_struct
id|entry
op_star
id|root
comma
r_char
op_star
id|base
)paren
(brace
r_struct
id|cramfs_super
op_star
id|super
op_assign
(paren
r_struct
id|cramfs_super
op_star
)paren
id|base
suffix:semicolon
r_int
r_int
id|offset
op_assign
r_sizeof
(paren
r_struct
id|cramfs_super
)paren
suffix:semicolon
id|super-&gt;magic
op_assign
id|CRAMFS_MAGIC
suffix:semicolon
id|super-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|super-&gt;size
op_assign
l_int|0x10000
suffix:semicolon
id|memcpy
c_func
(paren
id|super-&gt;signature
comma
id|CRAMFS_SIGNATURE
comma
r_sizeof
(paren
id|super-&gt;signature
)paren
)paren
suffix:semicolon
id|set_random
c_func
(paren
id|super-&gt;fsid
comma
r_sizeof
(paren
id|super-&gt;fsid
)paren
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|super-&gt;name
comma
l_string|&quot;Compressed&quot;
comma
r_sizeof
(paren
id|super-&gt;name
)paren
)paren
suffix:semicolon
id|super-&gt;root.mode
op_assign
id|root-&gt;mode
suffix:semicolon
id|super-&gt;root.uid
op_assign
id|root-&gt;uid
suffix:semicolon
id|super-&gt;root.gid
op_assign
id|root-&gt;gid
suffix:semicolon
id|super-&gt;root.size
op_assign
id|root-&gt;size
suffix:semicolon
id|super-&gt;root.offset
op_assign
id|offset
op_rshift
l_int|2
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
DECL|function|set_data_offset
r_static
r_void
id|set_data_offset
c_func
(paren
r_struct
id|entry
op_star
id|entry
comma
r_char
op_star
id|base
comma
r_int
r_int
id|offset
)paren
(brace
r_struct
id|cramfs_inode
op_star
id|inode
op_assign
(paren
r_struct
id|cramfs_inode
op_star
)paren
(paren
id|base
op_plus
id|entry-&gt;dir_offset
)paren
suffix:semicolon
id|inode-&gt;offset
op_assign
(paren
id|offset
op_rshift
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We do a width-first printout of the directory&n; * entries, using a stack to remember the directories&n; * we&squot;ve seen.&n; */
DECL|macro|MAXENTRIES
mdefine_line|#define MAXENTRIES (100)
DECL|variable|stack_entries
r_static
r_int
id|stack_entries
op_assign
l_int|0
suffix:semicolon
DECL|variable|entry_stack
r_static
r_struct
id|entry
op_star
id|entry_stack
(braket
id|MAXENTRIES
)braket
suffix:semicolon
DECL|function|write_directory_structure
r_static
r_int
r_int
id|write_directory_structure
c_func
(paren
r_struct
id|entry
op_star
id|entry
comma
r_char
op_star
id|base
comma
r_int
r_int
id|offset
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_while
c_loop
(paren
id|entry
)paren
(brace
r_struct
id|cramfs_inode
op_star
id|inode
op_assign
(paren
r_struct
id|cramfs_inode
op_star
)paren
(paren
id|base
op_plus
id|offset
)paren
suffix:semicolon
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|entry-&gt;name
)paren
suffix:semicolon
id|entry-&gt;dir_offset
op_assign
id|offset
suffix:semicolon
id|offset
op_add_assign
r_sizeof
(paren
r_struct
id|cramfs_inode
)paren
suffix:semicolon
id|inode-&gt;mode
op_assign
id|entry-&gt;mode
suffix:semicolon
id|inode-&gt;uid
op_assign
id|entry-&gt;uid
suffix:semicolon
id|inode-&gt;gid
op_assign
id|entry-&gt;gid
suffix:semicolon
id|inode-&gt;size
op_assign
id|entry-&gt;size
suffix:semicolon
id|inode-&gt;offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fill in later */
id|memcpy
c_func
(paren
id|base
op_plus
id|offset
comma
id|entry-&gt;name
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* Pad up the name to a 4-byte boundary */
r_while
c_loop
(paren
id|len
op_amp
l_int|3
)paren
(brace
op_star
(paren
id|base
op_plus
id|offset
op_plus
id|len
)paren
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|len
op_increment
suffix:semicolon
)brace
id|inode-&gt;namelen
op_assign
id|len
op_rshift
l_int|2
suffix:semicolon
id|offset
op_add_assign
id|len
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;  %s&bslash;n&quot;
comma
id|entry-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;child
)paren
(brace
id|entry_stack
(braket
id|stack_entries
)braket
op_assign
id|entry
suffix:semicolon
id|stack_entries
op_increment
suffix:semicolon
)brace
id|entry
op_assign
id|entry-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|stack_entries
)paren
r_break
suffix:semicolon
id|stack_entries
op_decrement
suffix:semicolon
id|entry
op_assign
id|entry_stack
(braket
id|stack_entries
)braket
suffix:semicolon
id|set_data_offset
c_func
(paren
id|entry
comma
id|base
comma
id|offset
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&squot;%s&squot;:&bslash;n&quot;
comma
id|entry-&gt;name
)paren
suffix:semicolon
id|entry
op_assign
id|entry-&gt;child
suffix:semicolon
)brace
r_return
id|offset
suffix:semicolon
)brace
multiline_comment|/*&n; * One 4-byte pointer per block and then the actual blocked&n; * output. The first block does not need an offset pointer,&n; * as it will start immediately after the pointer block.&n; *&n; * Note that size &gt; 0, as a zero-sized file wouldn&squot;t ever&n; * have gotten here in the first place.&n; */
DECL|function|do_compress
r_static
r_int
r_int
id|do_compress
c_func
(paren
r_char
op_star
id|base
comma
r_int
r_int
id|offset
comma
r_char
op_star
id|uncompressed
comma
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|original_size
op_assign
id|size
suffix:semicolon
r_int
r_int
id|original_offset
op_assign
id|offset
suffix:semicolon
r_int
r_int
id|new_size
suffix:semicolon
r_int
r_int
id|blocks
op_assign
(paren
id|size
op_minus
l_int|1
)paren
op_div
id|PAGE_CACHE_SIZE
op_plus
l_int|1
suffix:semicolon
r_int
r_int
id|curr
op_assign
id|offset
op_plus
l_int|4
op_star
id|blocks
suffix:semicolon
r_int
id|change
suffix:semicolon
r_do
(brace
r_int
r_int
id|input
op_assign
id|size
suffix:semicolon
r_int
r_int
id|len
op_assign
l_int|8192
suffix:semicolon
r_if
c_cond
(paren
id|input
OG
id|PAGE_CACHE_SIZE
)paren
id|input
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
id|compress
c_func
(paren
id|base
op_plus
id|curr
comma
op_amp
id|len
comma
id|uncompressed
comma
id|input
)paren
suffix:semicolon
id|uncompressed
op_add_assign
id|input
suffix:semicolon
id|size
op_sub_assign
id|input
suffix:semicolon
id|curr
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|PAGE_CACHE_SIZE
op_star
l_int|2
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;AIEEE: block expanded to &gt; 2*blocklength (%d)&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
op_star
(paren
id|u32
op_star
)paren
(paren
id|base
op_plus
id|offset
)paren
op_assign
id|curr
suffix:semicolon
id|offset
op_add_assign
l_int|4
suffix:semicolon
)brace
r_while
c_loop
(paren
id|size
)paren
suffix:semicolon
id|new_size
op_assign
id|curr
op_minus
id|original_offset
suffix:semicolon
id|change
op_assign
id|new_size
op_minus
id|original_size
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%4.2f %% (%d bytes)&bslash;n&quot;
comma
(paren
id|change
op_star
l_int|100
)paren
op_div
(paren
r_float
)paren
id|original_size
comma
id|change
)paren
suffix:semicolon
r_return
(paren
id|curr
op_plus
l_int|3
)paren
op_amp
op_complement
l_int|3
suffix:semicolon
)brace
DECL|function|write_data
r_static
r_int
r_int
id|write_data
c_func
(paren
r_struct
id|entry
op_star
id|entry
comma
r_char
op_star
id|base
comma
r_int
r_int
id|offset
)paren
(brace
r_do
(brace
r_if
c_cond
(paren
id|entry-&gt;uncompressed
)paren
(brace
id|set_data_offset
c_func
(paren
id|entry
comma
id|base
comma
id|offset
)paren
suffix:semicolon
id|offset
op_assign
id|do_compress
c_func
(paren
id|base
comma
id|offset
comma
id|entry-&gt;uncompressed
comma
id|entry-&gt;size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;child
)paren
id|offset
op_assign
id|write_data
c_func
(paren
id|entry-&gt;child
comma
id|base
comma
id|offset
)paren
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|entry
)paren
suffix:semicolon
r_return
id|offset
suffix:semicolon
)brace
multiline_comment|/* This is the maximum rom-image you can create */
DECL|macro|MAXROM
mdefine_line|#define MAXROM (64*1024*1024)
multiline_comment|/*&n; * Usage:&n; *&n; *      mkcramfs directory-name&n; *&n; * where &quot;directory-name&quot; is simply the root of the directory&n; * tree that we want to generate a compressed filesystem out&n; * of..&n; */
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
r_struct
id|stat
id|st
suffix:semicolon
r_struct
id|entry
op_star
id|root_entry
suffix:semicolon
r_char
op_star
id|rom_image
suffix:semicolon
r_int
r_int
id|offset
comma
id|written
suffix:semicolon
r_int
id|fd
suffix:semicolon
r_if
c_cond
(paren
id|argc
)paren
id|progname
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|argc
op_ne
l_int|3
)paren
id|usage
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
op_amp
id|st
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|argv
(braket
l_int|1
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|fd
op_assign
id|open
c_func
(paren
id|argv
(braket
l_int|2
)braket
comma
id|O_WRONLY
op_or
id|O_CREAT
op_or
id|O_TRUNC
comma
l_int|0666
)paren
suffix:semicolon
id|root_entry
op_assign
id|calloc
c_func
(paren
l_int|1
comma
r_sizeof
(paren
r_struct
id|entry
)paren
)paren
suffix:semicolon
id|root_entry-&gt;mode
op_assign
id|st.st_mode
suffix:semicolon
id|root_entry-&gt;uid
op_assign
id|st.st_uid
suffix:semicolon
id|root_entry-&gt;gid
op_assign
id|st.st_gid
suffix:semicolon
id|root_entry-&gt;name
op_assign
l_string|&quot;&quot;
suffix:semicolon
id|root_entry-&gt;size
op_assign
id|parse_directory
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
op_amp
id|root_entry-&gt;child
)paren
suffix:semicolon
id|rom_image
op_assign
id|mmap
c_func
(paren
l_int|NULL
comma
id|MAXROM
comma
id|PROT_READ
op_or
id|PROT_WRITE
comma
id|MAP_PRIVATE
op_or
id|MAP_ANONYMOUS
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
(paren
r_int
)paren
(paren
r_int
)paren
id|rom_image
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;ROM image map&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|offset
op_assign
id|write_superblock
c_func
(paren
id|root_entry
comma
id|rom_image
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Super block: %d bytes&bslash;n&quot;
comma
id|offset
)paren
suffix:semicolon
id|offset
op_assign
id|write_directory_structure
c_func
(paren
id|root_entry-&gt;child
comma
id|rom_image
comma
id|offset
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Directory data: %d bytes&bslash;n&quot;
comma
id|offset
)paren
suffix:semicolon
id|offset
op_assign
id|write_data
c_func
(paren
id|root_entry
comma
id|rom_image
comma
id|offset
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Everything: %d bytes&bslash;n&quot;
comma
id|offset
)paren
suffix:semicolon
id|written
op_assign
id|write
c_func
(paren
id|fd
comma
id|rom_image
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|written
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;rom image&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
op_ne
id|written
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;ROM image write failed (%d %d)&bslash;n&quot;
comma
id|written
comma
id|offset
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
