multiline_comment|/*&n;&t;symbol.c.&n;&n;&t;Symbol handling routines for ksymoops.&n;&n;&t;Copyright Keith Owens &lt;kaos@ocs.com.au&gt;.&n;&t;Released under the GNU Public Licence, Version 2.&n;&n;&t;Tue Nov  3 02:31:01 EST 1998&n;&t;Version 0.6&n;&t;Fix end of code calculation.&n;&n;&t;Wed Oct 28 13:47:23 EST 1998&n;&t;Version 0.4&n;&t;Split into separate sources.&n; */
macro_line|#include &quot;ksymoops.h&quot;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;malloc.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
multiline_comment|/* Initialise a symbol source */
DECL|function|ss_init
r_void
id|ss_init
c_func
(paren
id|SYMBOL_SET
op_star
id|ss
comma
r_const
r_char
op_star
id|msg
)paren
(brace
id|memset
c_func
(paren
id|ss
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
op_star
id|ss
)paren
)paren
suffix:semicolon
id|ss-&gt;source
op_assign
id|strdup
c_func
(paren
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ss-&gt;source
)paren
id|malloc_error
c_func
(paren
id|msg
)paren
suffix:semicolon
)brace
multiline_comment|/* Free dynamic data from a symbol source */
DECL|function|ss_free
r_void
id|ss_free
c_func
(paren
id|SYMBOL_SET
op_star
id|ss
)paren
(brace
r_int
id|i
suffix:semicolon
id|SYMBOL
op_star
id|s
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
id|ss-&gt;symbol
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ss-&gt;used
suffix:semicolon
op_increment
id|i
comma
op_increment
id|s
)paren
id|free
c_func
(paren
id|s-&gt;name
)paren
suffix:semicolon
id|free
c_func
(paren
id|ss-&gt;symbol
)paren
suffix:semicolon
id|free
c_func
(paren
id|ss-&gt;source
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ss
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
op_star
id|ss
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialise common symbol sets */
DECL|function|ss_init_common
r_void
id|ss_init_common
c_func
(paren
r_void
)paren
(brace
id|ss_init
c_func
(paren
op_amp
id|ss_Version
comma
l_string|&quot;Version_&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Find a symbol name in a symbol source.  Brute force ascending order search,&n; * no hashing.  If start is not NULL, it contains the starting point for the&n; * scan and is updated to point to the found entry.  If the entry is not found,&n; * return NULL with start pointing to the next highest entry.&n; * NOTE: Assumes that ss is sorted by name.&n; */
DECL|function|find_symbol_name
id|SYMBOL
op_star
id|find_symbol_name
c_func
(paren
r_const
id|SYMBOL_SET
op_star
id|ss
comma
r_const
r_char
op_star
id|symbol
comma
r_int
op_star
id|start
)paren
(brace
r_int
id|i
comma
id|l
suffix:semicolon
id|SYMBOL
op_star
id|s
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|start
ques
c_cond
op_star
id|start
suffix:colon
l_int|0
comma
id|s
op_assign
id|ss-&gt;symbol
op_plus
id|i
suffix:semicolon
id|i
OL
id|ss-&gt;used
suffix:semicolon
op_increment
id|i
comma
op_increment
id|s
)paren
(brace
r_if
c_cond
(paren
(paren
id|l
op_assign
id|strcmp
c_func
(paren
id|symbol
comma
id|s-&gt;name
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|start
)paren
op_star
id|start
op_assign
id|i
suffix:semicolon
r_return
id|s
suffix:semicolon
)brace
r_if
c_cond
(paren
id|l
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start
)paren
op_star
id|start
op_assign
id|i
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Find an address in a symbol source.  Brute force ascending order search, no&n; * hashing.  If start is not NULL, it contains the starting point for the scan&n; * and is updated to point to the found entry.  If the entry is not found,&n; * return NULL with start pointing to the next highest entry.&n; * NOTE: Assumes that ss is sorted by address.&n; */
DECL|function|find_symbol_address
r_static
id|SYMBOL
op_star
id|find_symbol_address
c_func
(paren
r_const
id|SYMBOL_SET
op_star
id|ss
comma
r_const
id|elf_addr_t
id|address
comma
r_int
op_star
id|start
)paren
(brace
r_int
id|i
suffix:semicolon
id|SYMBOL
op_star
id|s
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|start
ques
c_cond
op_star
id|start
suffix:colon
l_int|0
comma
id|s
op_assign
id|ss-&gt;symbol
op_plus
id|i
suffix:semicolon
id|i
OL
id|ss-&gt;used
suffix:semicolon
op_increment
id|i
comma
op_increment
id|s
)paren
(brace
r_if
c_cond
(paren
id|address
OG
id|s-&gt;address
)paren
r_continue
suffix:semicolon
r_else
r_if
c_cond
(paren
id|address
op_eq
id|s-&gt;address
)paren
(brace
r_if
c_cond
(paren
id|start
)paren
op_star
id|start
op_assign
id|i
suffix:semicolon
r_return
id|s
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start
)paren
op_star
id|start
op_assign
id|i
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Add a symbol to a symbol set, address in binary */
DECL|function|add_symbol_n
r_void
id|add_symbol_n
c_func
(paren
id|SYMBOL_SET
op_star
id|ss
comma
r_const
id|elf_addr_t
id|address
comma
r_const
r_char
id|type
comma
r_const
r_char
id|keep
comma
r_const
r_char
op_star
id|symbol
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
op_star
id|string
op_assign
l_int|NULL
suffix:semicolon
id|SYMBOL
op_star
id|s
suffix:semicolon
r_static
id|regex_t
id|re_symbol_ver
suffix:semicolon
r_static
id|regmatch_t
op_star
id|re_symbol_ver_pmatch
suffix:semicolon
r_static
r_const
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;add_symbol_n&quot;
suffix:semicolon
multiline_comment|/* Strip out any trailing symbol version _Rxxxxxxxx. */
id|re_compile
c_func
(paren
op_amp
id|re_symbol_ver
comma
l_string|&quot;^(.*)_R[0-9a-fA-F]{8,}$&quot;
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
comma
op_amp
id|re_symbol_ver_pmatch
)paren
suffix:semicolon
id|i
op_assign
id|regexec
c_func
(paren
op_amp
id|re_symbol_ver
comma
id|symbol
comma
id|re_symbol_ver.re_nsub
op_plus
l_int|1
comma
id|re_symbol_ver_pmatch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s regexec %d&bslash;n&quot;
comma
id|procname
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
id|re_strings
c_func
(paren
op_amp
id|re_symbol_ver
comma
id|symbol
comma
id|re_symbol_ver_pmatch
comma
op_amp
id|string
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s %s %s &squot;%c&squot; %d &squot;%s&squot;&bslash;n&quot;
comma
id|procname
comma
id|ss-&gt;source
comma
id|format_address
c_func
(paren
id|address
)paren
comma
id|type
comma
id|keep
comma
id|i
op_eq
l_int|0
ques
c_cond
id|string
(braket
l_int|1
)braket
suffix:colon
id|symbol
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss-&gt;used
OG
id|ss-&gt;alloc
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: fatal %s ss %s used (%d) &gt; alloc (%d)&bslash;n&quot;
comma
id|procname
comma
id|prefix
comma
id|ss-&gt;source
comma
id|ss-&gt;used
comma
id|ss-&gt;alloc
)paren
suffix:semicolon
m_exit
(paren
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ss-&gt;used
op_eq
id|ss-&gt;alloc
)paren
(brace
multiline_comment|/* increase by 20% or 10, whichever is larger, arbitrary */
r_int
id|newsize
op_assign
id|ss-&gt;alloc
op_star
l_int|120
op_div
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|newsize
OL
id|ss-&gt;alloc
op_plus
l_int|10
)paren
id|newsize
op_assign
id|ss-&gt;alloc
op_plus
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s increasing %s from %d to %d &quot;
l_string|&quot;entries&bslash;n&quot;
comma
id|procname
comma
id|ss-&gt;source
comma
id|ss-&gt;alloc
comma
id|newsize
)paren
suffix:semicolon
id|ss-&gt;symbol
op_assign
id|realloc
c_func
(paren
id|ss-&gt;symbol
comma
id|newsize
op_star
r_sizeof
(paren
op_star
(paren
id|ss-&gt;symbol
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ss-&gt;symbol
)paren
id|malloc_error
c_func
(paren
l_string|&quot;realloc ss&quot;
)paren
suffix:semicolon
id|ss-&gt;alloc
op_assign
id|newsize
suffix:semicolon
)brace
id|s
op_assign
id|ss-&gt;symbol
op_plus
id|ss-&gt;used
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|s-&gt;name
op_assign
id|string
(braket
l_int|1
)braket
suffix:semicolon
id|string
(braket
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* don&squot;t free this one */
)brace
r_else
(brace
id|s-&gt;name
op_assign
id|strdup
c_func
(paren
id|symbol
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;name
)paren
id|malloc_error
c_func
(paren
l_string|&quot;strdup symbol&quot;
)paren
suffix:semicolon
)brace
id|s-&gt;type
op_assign
id|type
suffix:semicolon
id|s-&gt;keep
op_assign
id|keep
suffix:semicolon
id|s-&gt;address
op_assign
id|address
suffix:semicolon
op_increment
id|ss-&gt;used
suffix:semicolon
id|re_strings_free
c_func
(paren
op_amp
id|re_symbol_ver
comma
op_amp
id|string
)paren
suffix:semicolon
)brace
multiline_comment|/* Add a symbol to a symbol set, address in character */
DECL|function|add_symbol
r_void
id|add_symbol
c_func
(paren
id|SYMBOL_SET
op_star
id|ss
comma
r_const
r_char
op_star
id|address
comma
r_const
r_char
id|type
comma
r_const
r_char
id|keep
comma
r_const
r_char
op_star
id|symbol
)paren
(brace
id|elf_addr_t
id|a
suffix:semicolon
r_static
r_char
r_const
id|procname
(braket
)braket
op_assign
l_string|&quot;add_symbol&quot;
suffix:semicolon
id|errno
op_assign
l_int|0
suffix:semicolon
id|a
op_assign
id|strtoul
c_func
(paren
id|address
comma
l_int|NULL
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errno
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: %s address &squot;%s&squot; is in error&quot;
comma
id|prefix
comma
id|procname
comma
id|address
)paren
suffix:semicolon
id|perror
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
op_increment
id|errors
suffix:semicolon
)brace
id|add_symbol_n
c_func
(paren
id|ss
comma
id|a
comma
id|type
comma
l_int|1
comma
id|symbol
)paren
suffix:semicolon
)brace
multiline_comment|/* Map an address to symbol, offset and length, address in binary */
DECL|function|map_address
r_char
op_star
id|map_address
c_func
(paren
r_const
id|SYMBOL_SET
op_star
id|ss
comma
r_const
id|elf_addr_t
id|address
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|l
suffix:semicolon
id|SYMBOL
op_star
id|s
suffix:semicolon
r_static
r_char
op_star
id|map
op_assign
l_int|NULL
suffix:semicolon
r_static
r_int
id|size
op_assign
l_int|0
suffix:semicolon
r_static
r_const
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;map_address_n&quot;
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|2
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s %s %s&bslash;n&quot;
comma
id|procname
comma
id|ss-&gt;source
comma
id|format_address
c_func
(paren
id|address
)paren
)paren
suffix:semicolon
id|s
op_assign
id|find_symbol_address
c_func
(paren
id|ss
comma
id|address
comma
op_amp
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s
op_logical_and
op_decrement
id|i
op_ge
l_int|0
)paren
id|s
op_assign
id|ss-&gt;symbol
op_plus
id|i
suffix:semicolon
multiline_comment|/* address is between s and s+1 */
multiline_comment|/* Extra map text is always &lt; 100 bytes */
r_if
c_cond
(paren
id|s
)paren
id|l
op_assign
id|strlen
c_func
(paren
id|s-&gt;name
)paren
op_plus
l_int|100
suffix:semicolon
r_else
id|l
op_assign
l_int|100
suffix:semicolon
r_if
c_cond
(paren
id|l
OG
id|size
)paren
(brace
id|map
op_assign
id|realloc
c_func
(paren
id|map
comma
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map
)paren
id|malloc_error
c_func
(paren
id|procname
)paren
suffix:semicolon
id|size
op_assign
id|l
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|s
)paren
(brace
r_if
c_cond
(paren
id|ss-&gt;used
op_eq
l_int|0
)paren
id|snprintf
c_func
(paren
id|map
comma
id|size
comma
l_string|&quot;No symbols available&quot;
)paren
suffix:semicolon
r_else
id|snprintf
c_func
(paren
id|map
comma
id|size
comma
l_string|&quot;Before first symbol&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|i
op_plus
l_int|1
)paren
op_ge
id|ss-&gt;used
)paren
(brace
multiline_comment|/* Somewhere past last symbol.  Length of last section of code&n;&t;&t; * is unknown, arbitrary cutoff at 32K.&n;&t;&t; */
id|elf_addr_t
id|offset
op_assign
id|address
op_minus
id|s-&gt;address
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
l_int|32768
)paren
id|snprintf
c_func
(paren
id|map
comma
id|size
comma
l_string|&quot;&lt;END_OF_CODE+%lx/????&gt;&quot;
comma
id|offset
)paren
suffix:semicolon
r_else
id|snprintf
c_func
(paren
id|map
comma
id|size
comma
l_string|&quot;&lt;%s+%lx/????&gt;&quot;
comma
id|s-&gt;name
comma
id|offset
)paren
suffix:semicolon
)brace
r_else
id|snprintf
c_func
(paren
id|map
comma
id|size
comma
l_string|&quot;&lt;%s+%lx/%lx&gt;&quot;
comma
id|s-&gt;name
comma
id|address
op_minus
id|s-&gt;address
comma
(paren
id|s
op_plus
l_int|1
)paren
op_member_access_from_pointer
id|address
op_minus
id|s-&gt;address
)paren
suffix:semicolon
r_return
id|map
suffix:semicolon
)brace
multiline_comment|/* After sorting, obsolete symbols are at the top.  Delete them. */
DECL|function|ss_compress
r_static
r_void
id|ss_compress
c_func
(paren
id|SYMBOL_SET
op_star
id|ss
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
id|SYMBOL
op_star
id|s
suffix:semicolon
r_static
r_const
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;ss_compress&quot;
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s on table %s, before %d &quot;
comma
id|procname
comma
id|ss-&gt;source
comma
id|ss-&gt;used
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|s
op_assign
id|ss-&gt;symbol
op_plus
id|i
suffix:semicolon
id|i
OL
id|ss-&gt;used
suffix:semicolon
op_increment
id|i
comma
op_increment
id|s
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;keep
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
id|i
suffix:semicolon
id|j
OL
id|ss-&gt;used
suffix:semicolon
op_increment
id|j
comma
op_increment
id|s
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;keep
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: fatal %s table %s is not &quot;
l_string|&quot;sorted&bslash;n&quot;
comma
id|prefix
comma
id|procname
comma
id|ss-&gt;source
)paren
suffix:semicolon
m_exit
(paren
l_int|2
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|j
op_assign
id|i
comma
id|s
op_assign
id|ss-&gt;symbol
op_plus
id|j
suffix:semicolon
id|j
OL
id|ss-&gt;used
suffix:semicolon
op_increment
id|j
comma
op_increment
id|s
)paren
id|free
c_func
(paren
id|s-&gt;name
)paren
suffix:semicolon
id|ss-&gt;used
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;after %d&bslash;n&quot;
comma
id|ss-&gt;used
)paren
suffix:semicolon
)brace
DECL|function|ss_compare_atn
r_static
r_int
id|ss_compare_atn
c_func
(paren
r_const
r_void
op_star
id|a
comma
r_const
r_void
op_star
id|b
)paren
(brace
id|SYMBOL
op_star
id|c
op_assign
(paren
id|SYMBOL
op_star
)paren
id|a
suffix:semicolon
id|SYMBOL
op_star
id|d
op_assign
(paren
id|SYMBOL
op_star
)paren
id|b
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* obsolete symbols to the top */
r_if
c_cond
(paren
id|c-&gt;keep
op_ne
id|d-&gt;keep
)paren
r_return
id|d-&gt;keep
op_minus
id|c-&gt;keep
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;address
OG
id|d-&gt;address
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;address
OL
id|d-&gt;address
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;type
OG
id|d-&gt;type
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;type
OL
id|d-&gt;type
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|strcmp
c_func
(paren
id|c-&gt;name
comma
id|d-&gt;name
)paren
)paren
)paren
r_return
id|i
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Sort a symbol set by address, type and name */
DECL|function|ss_sort_atn
r_void
id|ss_sort_atn
c_func
(paren
id|SYMBOL_SET
op_star
id|ss
)paren
(brace
r_if
c_cond
(paren
id|debug
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: sorting symbols for %s (atn)&bslash;n&quot;
comma
id|ss-&gt;source
)paren
suffix:semicolon
id|qsort
c_func
(paren
(paren
r_char
op_star
)paren
id|ss-&gt;symbol
comma
(paren
r_int
)paren
id|ss-&gt;used
comma
r_sizeof
(paren
op_star
(paren
id|ss-&gt;symbol
)paren
)paren
comma
id|ss_compare_atn
)paren
suffix:semicolon
id|ss_compress
c_func
(paren
id|ss
)paren
suffix:semicolon
)brace
DECL|function|ss_compare_na
r_static
r_int
id|ss_compare_na
c_func
(paren
r_const
r_void
op_star
id|a
comma
r_const
r_void
op_star
id|b
)paren
(brace
id|SYMBOL
op_star
id|c
op_assign
(paren
id|SYMBOL
op_star
)paren
id|a
suffix:semicolon
id|SYMBOL
op_star
id|d
op_assign
(paren
id|SYMBOL
op_star
)paren
id|b
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* obsolete symbols to the top */
r_if
c_cond
(paren
id|c-&gt;keep
op_ne
id|d-&gt;keep
)paren
r_return
id|d-&gt;keep
op_minus
id|c-&gt;keep
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|strcmp
c_func
(paren
id|c-&gt;name
comma
id|d-&gt;name
)paren
)paren
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;address
OG
id|d-&gt;address
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;address
OL
id|d-&gt;address
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Sort a symbol set by name and address, drop duplicates.  There should be&n; * no duplicates but I have seen duplicates in ksyms on 2.0.35.&n; */
DECL|function|ss_sort_na
r_void
id|ss_sort_na
c_func
(paren
id|SYMBOL_SET
op_star
id|ss
)paren
(brace
r_int
id|i
suffix:semicolon
id|SYMBOL
op_star
id|s
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: sorting symbols for %s (na)&bslash;n&quot;
comma
id|ss-&gt;source
)paren
suffix:semicolon
id|qsort
c_func
(paren
(paren
r_char
op_star
)paren
id|ss-&gt;symbol
comma
(paren
r_int
)paren
id|ss-&gt;used
comma
r_sizeof
(paren
op_star
(paren
id|ss-&gt;symbol
)paren
)paren
comma
id|ss_compare_na
)paren
suffix:semicolon
id|ss_compress
c_func
(paren
id|ss
)paren
suffix:semicolon
id|s
op_assign
id|ss-&gt;symbol
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ss-&gt;used
op_minus
l_int|1
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|s-&gt;name
comma
(paren
id|s
op_plus
l_int|1
)paren
op_member_access_from_pointer
id|name
)paren
op_eq
l_int|0
op_logical_and
id|s-&gt;address
op_eq
(paren
id|s
op_plus
l_int|1
)paren
op_member_access_from_pointer
id|address
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;type
op_ne
l_char|&squot; &squot;
)paren
(paren
id|s
op_plus
l_int|1
)paren
op_member_access_from_pointer
id|keep
op_assign
l_int|0
suffix:semicolon
r_else
id|s-&gt;keep
op_assign
l_int|0
suffix:semicolon
)brace
op_increment
id|s
suffix:semicolon
)brace
id|qsort
c_func
(paren
(paren
r_char
op_star
)paren
id|ss-&gt;symbol
comma
(paren
r_int
)paren
id|ss-&gt;used
comma
r_sizeof
(paren
op_star
(paren
id|ss-&gt;symbol
)paren
)paren
comma
id|ss_compare_na
)paren
suffix:semicolon
id|ss_compress
c_func
(paren
id|ss
)paren
suffix:semicolon
)brace
multiline_comment|/* Copy a symbol set, including all its strings */
DECL|function|ss_copy
id|SYMBOL_SET
op_star
id|ss_copy
c_func
(paren
r_const
id|SYMBOL_SET
op_star
id|ss
)paren
(brace
id|SYMBOL_SET
op_star
id|ssc
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: ss_copy %s&bslash;n&quot;
comma
id|ss-&gt;source
)paren
suffix:semicolon
id|ssc
op_assign
id|malloc
c_func
(paren
r_sizeof
(paren
op_star
id|ssc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ssc
)paren
id|malloc_error
c_func
(paren
l_string|&quot;copy ssc&quot;
)paren
suffix:semicolon
id|ss_init
c_func
(paren
id|ssc
comma
id|ss-&gt;source
)paren
suffix:semicolon
id|ssc-&gt;used
op_assign
id|ss-&gt;used
suffix:semicolon
id|ssc-&gt;alloc
op_assign
id|ss-&gt;used
suffix:semicolon
multiline_comment|/* shrink the copy */
id|ssc-&gt;symbol
op_assign
id|malloc
c_func
(paren
id|ssc-&gt;used
op_star
r_sizeof
(paren
op_star
(paren
id|ssc-&gt;symbol
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ssc-&gt;symbol
)paren
)paren
id|malloc_error
c_func
(paren
l_string|&quot;copy ssc symbols&quot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ssc-&gt;symbol
comma
id|ss-&gt;symbol
comma
id|ssc-&gt;used
op_star
r_sizeof
(paren
op_star
(paren
id|ssc-&gt;symbol
)paren
)paren
)paren
suffix:semicolon
r_return
id|ssc
suffix:semicolon
)brace
multiline_comment|/* Convert version number to major, minor string.  */
DECL|function|format_Version
r_static
r_const
r_char
op_star
id|format_Version
c_func
(paren
id|elf_addr_t
id|Version
)paren
(brace
r_static
r_char
id|string
(braket
l_int|12
)braket
suffix:semicolon
multiline_comment|/* 255.255.255&bslash;0 worst case */
id|snprintf
c_func
(paren
id|string
comma
r_sizeof
(paren
id|string
)paren
comma
l_string|&quot;%d.%d.%d&quot;
comma
(paren
id|Version
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
comma
(paren
id|Version
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
(paren
id|Version
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
id|string
suffix:semicolon
)brace
multiline_comment|/* Save version number.  The &quot;address&quot; is the version number, the &quot;symbol&quot; is&n; * the source of the version.&n; */
DECL|function|add_Version
r_void
id|add_Version
c_func
(paren
r_const
r_char
op_star
id|version
comma
r_const
r_char
op_star
id|source
)paren
(brace
r_static
r_char
r_const
id|procname
(braket
)braket
op_assign
l_string|&quot;add_Version&quot;
suffix:semicolon
r_int
id|i
op_assign
id|atoi
c_func
(paren
id|version
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s %s %s %s&bslash;n&quot;
comma
id|procname
comma
id|source
comma
id|version
comma
id|format_Version
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
id|add_symbol_n
c_func
(paren
op_amp
id|ss_Version
comma
id|i
comma
l_char|&squot;V&squot;
comma
l_int|1
comma
id|source
)paren
suffix:semicolon
)brace
multiline_comment|/* Extract Version_ number from a symbol set and save it.  */
DECL|function|extract_Version
r_void
id|extract_Version
c_func
(paren
id|SYMBOL_SET
op_star
id|ss
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|SYMBOL
op_star
id|s
suffix:semicolon
id|s
op_assign
id|find_symbol_name
c_func
(paren
id|ss
comma
l_string|&quot;Version_&quot;
comma
op_amp
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s
op_logical_and
id|i
OL
id|ss-&gt;used
)paren
id|s
op_assign
id|ss-&gt;symbol
op_plus
id|i
suffix:semicolon
multiline_comment|/* first symbol after &quot;Version_&quot; */
r_if
c_cond
(paren
op_logical_neg
id|s
op_logical_or
id|strncmp
c_func
(paren
id|s-&gt;name
comma
l_string|&quot;Version_&quot;
comma
l_int|8
)paren
)paren
r_return
suffix:semicolon
id|add_Version
c_func
(paren
id|s-&gt;name
op_plus
l_int|8
comma
id|ss-&gt;source
)paren
suffix:semicolon
)brace
multiline_comment|/* Compare all extracted Version numbers.  Silent unless there is a problem. */
DECL|function|compare_Version
r_void
id|compare_Version
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|SYMBOL
op_star
id|s
comma
op_star
id|s0
suffix:semicolon
r_static
r_int
id|prev_used
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ss_Version.used
)paren
r_return
suffix:semicolon
multiline_comment|/* Only check if the Version table has changed in size */
r_if
c_cond
(paren
id|prev_used
op_eq
id|ss_Version.used
)paren
r_return
suffix:semicolon
id|ss_sort_na
c_func
(paren
op_amp
id|ss_Version
)paren
suffix:semicolon
id|s0
op_assign
id|s
op_assign
id|ss_Version.symbol
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: Version %s&bslash;n&quot;
comma
id|format_Version
c_func
(paren
id|s0-&gt;address
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ss_Version.used
suffix:semicolon
op_increment
id|i
comma
op_increment
id|s
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;address
op_ne
id|s0-&gt;address
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Version mismatch error.  %s says %s, &quot;
comma
id|s0-&gt;name
comma
id|format_Version
c_func
(paren
id|s0-&gt;address
)paren
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s says %s.  Expect lots of address &quot;
l_string|&quot;mismatches.&bslash;n&quot;
comma
id|s-&gt;name
comma
id|format_Version
c_func
(paren
id|s-&gt;address
)paren
)paren
suffix:semicolon
op_increment
id|errors
suffix:semicolon
)brace
)brace
id|prev_used
op_assign
id|ss_Version.used
suffix:semicolon
)brace
eof
