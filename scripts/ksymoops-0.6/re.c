multiline_comment|/*&n;&t;re.c.&n;&n;&t;Regular expression processing for ksymoops.&n;&n;&t;Copyright Keith Owens &lt;kaos@ocs.com.au&gt;.&n;&t;Released under the GNU Public Licence, Version 2.&n;&n;&t;Tue Nov  3 02:31:01 EST 1998&n;&t;Version 0.6&n;&t;PPC trace addresses are not bracketed, add new re.&n;&n;&t;Wed Oct 28 13:47:23 EST 1998&n;&t;Version 0.4&n;&t;Split into separate sources.&n; */
macro_line|#include &quot;ksymoops.h&quot;
macro_line|#include &lt;malloc.h&gt;
macro_line|#include &lt;string.h&gt;
multiline_comment|/* Compile a regular expression */
DECL|function|re_compile
r_void
id|re_compile
c_func
(paren
id|regex_t
op_star
id|preg
comma
r_const
r_char
op_star
id|regex
comma
r_int
id|cflags
comma
id|regmatch_t
op_star
op_star
id|pmatch
)paren
(brace
r_int
id|i
comma
id|l
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_static
r_char
r_const
id|procname
(braket
)braket
op_assign
l_string|&quot;re_compile&quot;
suffix:semicolon
r_if
c_cond
(paren
id|preg-&gt;re_nsub
)paren
r_return
suffix:semicolon
multiline_comment|/* already compiled */
r_if
c_cond
(paren
id|debug
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s &squot;%s&squot;&quot;
comma
id|procname
comma
id|regex
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|regcomp
c_func
(paren
id|preg
comma
id|regex
comma
id|cflags
)paren
)paren
)paren
(brace
id|l
op_assign
id|regerror
c_func
(paren
id|i
comma
id|preg
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
op_increment
id|l
suffix:semicolon
multiline_comment|/* doc is ambiguous, be safe */
id|p
op_assign
id|malloc
c_func
(paren
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
id|malloc_error
c_func
(paren
l_string|&quot;regerror text&quot;
)paren
suffix:semicolon
id|regerror
c_func
(paren
id|i
comma
id|preg
comma
id|p
comma
id|l
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: fatal %s error on &squot;%s&squot; - %s&bslash;n&quot;
comma
id|prefix
comma
id|procname
comma
id|regex
comma
id|p
)paren
suffix:semicolon
m_exit
(paren
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot; %d sub expression(s)&bslash;n&quot;
comma
id|preg-&gt;re_nsub
)paren
suffix:semicolon
multiline_comment|/* [0] is entire match, [1] is first substring */
op_star
id|pmatch
op_assign
id|malloc
c_func
(paren
(paren
id|preg-&gt;re_nsub
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
op_star
id|pmatch
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|pmatch
)paren
id|malloc_error
c_func
(paren
l_string|&quot;pmatch&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Compile common regular expressions */
DECL|function|re_compile_common
r_void
id|re_compile_common
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* nm: address, type, symbol */
id|re_compile
c_func
(paren
op_amp
id|re_nm
comma
l_string|&quot;^([0-9a-fA-F]{4,}) +([^ ]) +([^ ]+)$&quot;
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
comma
op_amp
id|re_nm_pmatch
)paren
suffix:semicolon
multiline_comment|/* bracketed address preceded by optional white space */
id|re_compile
c_func
(paren
op_amp
id|re_bracketed_address
comma
l_string|&quot;^[ &bslash;t]*&quot;
id|BRACKETED_ADDRESS
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
comma
op_amp
id|re_bracketed_address_pmatch
)paren
suffix:semicolon
multiline_comment|/* unbracketed address preceded by optional white space */
id|re_compile
c_func
(paren
op_amp
id|re_unbracketed_address
comma
l_string|&quot;^[ &bslash;t*]*&quot;
id|UNBRACKETED_ADDRESS
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
comma
op_amp
id|re_unbracketed_address_pmatch
)paren
suffix:semicolon
)brace
multiline_comment|/* Split text into the matching re substrings - Perl is so much easier :).&n; * Each element of *string is set to a malloced copy of the substring or&n; * NULL if the substring did not match (undef).  A zero length substring match&n; * is represented by a zero length **string.&n; */
DECL|function|re_strings
r_void
id|re_strings
c_func
(paren
id|regex_t
op_star
id|preg
comma
r_const
r_char
op_star
id|text
comma
id|regmatch_t
op_star
id|pmatch
comma
r_char
op_star
op_star
op_star
id|string
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|string
)paren
(brace
op_star
id|string
op_assign
id|malloc
c_func
(paren
(paren
id|preg-&gt;re_nsub
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
op_star
id|string
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|string
)paren
id|malloc_error
c_func
(paren
l_string|&quot;re_strings base&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|preg-&gt;re_nsub
op_plus
l_int|1
suffix:semicolon
op_increment
id|i
)paren
(paren
op_star
id|string
)paren
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|preg-&gt;re_nsub
op_plus
l_int|1
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|debug
OG
l_int|4
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: re_string %d offsets %d %d&quot;
comma
id|i
comma
id|pmatch
(braket
id|i
)braket
dot
id|rm_so
comma
id|pmatch
(braket
id|i
)braket
dot
id|rm_eo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmatch
(braket
id|i
)braket
dot
id|rm_so
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* no match for this sub expression */
id|free
c_func
(paren
(paren
op_star
id|string
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
(paren
op_star
id|string
)paren
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|4
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot; (undef)&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|l
op_assign
id|pmatch
(braket
id|i
)braket
dot
id|rm_eo
op_minus
id|pmatch
(braket
id|i
)braket
dot
id|rm_so
op_plus
l_int|1
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
id|p
op_assign
id|malloc
c_func
(paren
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
id|malloc_error
c_func
(paren
l_string|&quot;re_strings&quot;
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|p
comma
id|text
op_plus
id|pmatch
(braket
id|i
)braket
dot
id|rm_so
comma
id|l
op_minus
l_int|1
)paren
suffix:semicolon
op_star
(paren
id|p
op_plus
id|l
op_minus
l_int|1
)paren
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
(paren
op_star
id|string
)paren
(braket
id|i
)braket
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|4
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot; &squot;%s&squot;&bslash;n&quot;
comma
id|p
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Free the matching re substrings */
DECL|function|re_strings_free
r_void
id|re_strings_free
c_func
(paren
r_const
id|regex_t
op_star
id|preg
comma
r_char
op_star
op_star
op_star
id|string
)paren
(brace
r_if
c_cond
(paren
op_star
id|string
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|preg-&gt;re_nsub
op_plus
l_int|1
suffix:semicolon
op_increment
id|i
)paren
id|free
c_func
(paren
(paren
op_star
id|string
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|free
c_func
(paren
op_star
id|string
)paren
suffix:semicolon
op_star
id|string
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* Check that there are enough strings for an re */
DECL|function|re_string_check
r_void
id|re_string_check
c_func
(paren
r_int
id|need
comma
r_int
id|available
comma
r_const
r_char
op_star
id|msg
)paren
(brace
r_if
c_cond
(paren
id|need
OG
id|available
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: fatal not enough re_strings in %s.  &quot;
l_string|&quot;Need %d, available %d&bslash;n&quot;
comma
id|prefix
comma
id|msg
comma
id|need
comma
id|available
)paren
suffix:semicolon
m_exit
(paren
l_int|2
)paren
suffix:semicolon
)brace
)brace
eof
