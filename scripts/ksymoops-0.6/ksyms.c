multiline_comment|/*&n;&t;ksyms.c.&n;&n;&t;Process ksyms for ksymoops.&n;&n;&t;Copyright Keith Owens &lt;kaos@ocs.com.au&gt;.&n;&t;Released under the GNU Public Licence, Version 2.&n;&n;&t;Tue Nov  3 02:31:01 EST 1998&n;&t;Version 0.6&n;&t;Read lsmod (/proc/modules).&n;&t;Move &quot;Using_Version&quot; copy to map.c.&n;&n;&t;Wed Oct 28 13:47:23 EST 1998&n;&t;Version 0.4&n;&t;Split into separate sources.&n; */
macro_line|#include &quot;ksymoops.h&quot;
macro_line|#include &lt;malloc.h&gt;
macro_line|#include &lt;string.h&gt;
multiline_comment|/* Scan one line from ksyms.  Split lines into the base symbols and the module&n; * symbols.  Separate ss for base and each module.&n; */
DECL|function|scan_ksyms_line
r_static
r_void
id|scan_ksyms_line
c_func
(paren
r_const
r_char
op_star
id|line
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
op_star
id|string
op_assign
l_int|NULL
suffix:semicolon
id|SYMBOL_SET
op_star
id|ssp
suffix:semicolon
r_static
r_char
op_star
id|prev_module
op_assign
l_int|NULL
suffix:semicolon
r_static
id|regex_t
id|re_ksyms
suffix:semicolon
r_static
id|regmatch_t
op_star
id|re_ksyms_pmatch
suffix:semicolon
r_static
r_char
r_const
id|procname
(braket
)braket
op_assign
l_string|&quot;scan_ksyms_line&quot;
suffix:semicolon
multiline_comment|/* ksyms: address, symbol, optional module */
id|re_compile
c_func
(paren
op_amp
id|re_ksyms
comma
l_string|&quot;^([0-9a-fA-F]{4,}) +([^ &bslash;t]+)([ &bslash;t]+&bslash;&bslash;[([^ ]+)&bslash;&bslash;])?$&quot;
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
comma
op_amp
id|re_ksyms_pmatch
)paren
suffix:semicolon
id|i
op_assign
id|regexec
c_func
(paren
op_amp
id|re_ksyms
comma
id|line
comma
id|re_ksyms.re_nsub
op_plus
l_int|1
comma
id|re_ksyms_pmatch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s regexec %d&bslash;n&quot;
comma
id|procname
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
suffix:semicolon
multiline_comment|/* string [1] - address, [2] - symbol, [3] - white space+module,&n;&t; * [4] - module.&n;&t; */
id|re_strings
c_func
(paren
op_amp
id|re_ksyms
comma
id|line
comma
id|re_ksyms_pmatch
comma
op_amp
id|string
)paren
suffix:semicolon
r_if
c_cond
(paren
id|string
(braket
l_int|4
)braket
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prev_module
op_logical_or
id|strcmp
c_func
(paren
id|prev_module
comma
id|string
(braket
l_int|4
)braket
)paren
)paren
(brace
multiline_comment|/* start of a new module in ksyms */
op_increment
id|ss_ksyms_modules
suffix:semicolon
id|ss_ksyms_module
op_assign
id|realloc
c_func
(paren
id|ss_ksyms_module
comma
id|ss_ksyms_modules
op_star
r_sizeof
(paren
op_star
id|ss_ksyms_module
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ss_ksyms_module
)paren
id|malloc_error
c_func
(paren
l_string|&quot;realloc ss_ksyms_module&quot;
)paren
suffix:semicolon
id|ssp
op_assign
id|ss_ksyms_module
op_plus
id|ss_ksyms_modules
op_minus
l_int|1
suffix:semicolon
id|ss_init
c_func
(paren
id|ssp
comma
id|string
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|prev_module
op_assign
id|strdup
c_func
(paren
id|string
(braket
l_int|4
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prev_module
)paren
id|malloc_error
c_func
(paren
l_string|&quot;strdup prev_module&quot;
)paren
suffix:semicolon
)brace
id|ssp
op_assign
id|ss_ksyms_module
op_plus
id|ss_ksyms_modules
op_minus
l_int|1
suffix:semicolon
)brace
r_else
id|ssp
op_assign
op_amp
id|ss_ksyms_base
suffix:semicolon
id|add_symbol
c_func
(paren
id|ssp
comma
id|string
(braket
l_int|1
)braket
comma
l_char|&squot; &squot;
comma
l_int|1
comma
id|string
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|re_strings_free
c_func
(paren
op_amp
id|re_ksyms
comma
op_amp
id|string
)paren
suffix:semicolon
)brace
multiline_comment|/* Read the symbols from ksyms.  */
DECL|function|read_ksyms
r_void
id|read_ksyms
c_func
(paren
r_const
r_char
op_star
id|ksyms
)paren
(brace
id|FILE
op_star
id|f
suffix:semicolon
r_char
op_star
id|line
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
comma
id|size
suffix:semicolon
r_static
r_char
r_const
id|procname
(braket
)braket
op_assign
l_string|&quot;read_ksyms&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ksyms
)paren
r_return
suffix:semicolon
id|ss_init
c_func
(paren
op_amp
id|ss_ksyms_base
comma
l_string|&quot;ksyms_base&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s %s&bslash;n&quot;
comma
id|procname
comma
id|ksyms
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|regular_file
c_func
(paren
id|ksyms
comma
id|procname
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|f
op_assign
id|fopen_local
c_func
(paren
id|ksyms
comma
l_string|&quot;r&quot;
comma
id|procname
)paren
)paren
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|fgets_local
c_func
(paren
op_amp
id|line
comma
op_amp
id|size
comma
id|f
comma
id|procname
)paren
)paren
id|scan_ksyms_line
c_func
(paren
id|line
)paren
suffix:semicolon
id|fclose_local
c_func
(paren
id|f
comma
id|procname
)paren
suffix:semicolon
id|free
c_func
(paren
id|line
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ss_ksyms_modules
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ss_sort_na
c_func
(paren
id|ss_ksyms_module
op_plus
id|i
)paren
suffix:semicolon
id|extract_Version
c_func
(paren
id|ss_ksyms_module
op_plus
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ss_ksyms_base.used
)paren
(brace
id|ss_sort_na
c_func
(paren
op_amp
id|ss_ksyms_base
)paren
suffix:semicolon
id|extract_Version
c_func
(paren
op_amp
id|ss_ksyms_base
)paren
suffix:semicolon
)brace
r_else
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Warning, no kernel symbols in ksyms, is %s a valid &quot;
l_string|&quot;ksyms file?&bslash;n&quot;
comma
id|ksyms
)paren
suffix:semicolon
op_increment
id|warnings
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ss_ksyms_modules
suffix:semicolon
op_increment
id|i
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s %s used %d out of %d entries&bslash;n&quot;
comma
id|procname
comma
id|ss_ksyms_module
(braket
id|i
)braket
dot
id|source
comma
id|ss_ksyms_module
(braket
id|i
)braket
dot
id|used
comma
id|ss_ksyms_module
(braket
id|i
)braket
dot
id|alloc
)paren
suffix:semicolon
)brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s %s used %d out of %d entries&bslash;n&quot;
comma
id|procname
comma
id|ss_ksyms_base.source
comma
id|ss_ksyms_base.used
comma
id|ss_ksyms_base.alloc
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Map each ksyms module entry to the corresponding object entry.  Tricky,&n; * see the comments in the docs about needing a unique symbol in each&n; * module.&n; */
DECL|function|map_ksym_to_module
r_static
r_void
id|map_ksym_to_module
c_func
(paren
id|SYMBOL_SET
op_star
id|ss
)paren
(brace
r_int
id|i
comma
id|j
comma
id|matches
suffix:semicolon
r_char
op_star
id|name
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ss-&gt;used
suffix:semicolon
op_increment
id|i
)paren
(brace
id|matches
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ss_objects
suffix:semicolon
op_increment
id|j
)paren
(brace
id|name
op_assign
(paren
id|ss-&gt;symbol
)paren
(braket
id|i
)braket
dot
id|name
suffix:semicolon
r_if
c_cond
(paren
id|find_symbol_name
c_func
(paren
id|ss_object
op_plus
id|j
comma
id|name
comma
l_int|NULL
)paren
)paren
(brace
op_increment
id|matches
suffix:semicolon
id|ss-&gt;related
op_assign
id|ss_object
op_plus
id|j
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|matches
op_eq
l_int|1
)paren
r_break
suffix:semicolon
multiline_comment|/* unique symbol over all objects */
id|ss-&gt;related
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* keep looking */
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ss-&gt;related
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Warning: cannot match loaded module %s to any &quot;
l_string|&quot;module object.  Trace may not be reliable.&bslash;n&quot;
comma
id|ss-&gt;source
)paren
suffix:semicolon
op_increment
id|warnings
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|debug
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: ksyms %s matches to %s based on unique &quot;
l_string|&quot;symbol %s&bslash;n&quot;
comma
id|ss-&gt;source
comma
id|ss-&gt;related-&gt;source
comma
id|name
)paren
suffix:semicolon
)brace
multiline_comment|/* Map all ksyms module entries to their corresponding objects */
DECL|function|map_ksyms_to_modules
r_void
id|map_ksyms_to_modules
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|SYMBOL_SET
op_star
id|ss
comma
op_star
id|ssc
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ss_ksyms_modules
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ss
op_assign
id|ss_ksyms_module
op_plus
id|i
suffix:semicolon
id|map_ksym_to_module
c_func
(paren
id|ss
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss-&gt;related
)paren
(brace
id|ssc
op_assign
id|adjust_object_offsets
c_func
(paren
id|ss
)paren
suffix:semicolon
id|compare_maps
c_func
(paren
id|ss
comma
id|ssc
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Read the modules from lsmod.  */
DECL|function|read_lsmod
r_void
id|read_lsmod
c_func
(paren
r_const
r_char
op_star
id|lsmod
)paren
(brace
id|FILE
op_star
id|f
suffix:semicolon
r_char
op_star
id|line
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
comma
id|size
suffix:semicolon
r_char
op_star
op_star
id|string
op_assign
l_int|NULL
suffix:semicolon
r_static
id|regex_t
id|re_lsmod
suffix:semicolon
r_static
id|regmatch_t
op_star
id|re_lsmod_pmatch
suffix:semicolon
r_static
r_char
r_const
id|procname
(braket
)braket
op_assign
l_string|&quot;read_lsmod&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lsmod
)paren
r_return
suffix:semicolon
id|ss_init
c_func
(paren
op_amp
id|ss_lsmod
comma
l_string|&quot;lsmod&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s %s&bslash;n&quot;
comma
id|procname
comma
id|lsmod
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|regular_file
c_func
(paren
id|lsmod
comma
id|procname
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|f
op_assign
id|fopen_local
c_func
(paren
id|lsmod
comma
l_string|&quot;r&quot;
comma
id|procname
)paren
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* lsmod: module, size, use count, optional used by */
id|re_compile
c_func
(paren
op_amp
id|re_lsmod
comma
l_string|&quot;^&quot;
l_string|&quot;[ &bslash;t]*([^ &bslash;t]+)&quot;
multiline_comment|/* 1 module */
l_string|&quot;[ &bslash;t]*([^ &bslash;t]+)&quot;
multiline_comment|/* 2 size */
l_string|&quot;[ &bslash;t]*([^ &bslash;t]+)&quot;
multiline_comment|/* 3 count */
l_string|&quot;[ &bslash;t]*(.*)&quot;
multiline_comment|/* 4 used by */
l_string|&quot;$&quot;
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
comma
op_amp
id|re_lsmod_pmatch
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fgets_local
c_func
(paren
op_amp
id|line
comma
op_amp
id|size
comma
id|f
comma
id|procname
)paren
)paren
(brace
id|i
op_assign
id|regexec
c_func
(paren
op_amp
id|re_lsmod
comma
id|line
comma
id|re_lsmod.re_nsub
op_plus
l_int|1
comma
id|re_lsmod_pmatch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s regexec %d&bslash;n&quot;
comma
id|procname
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_continue
suffix:semicolon
id|re_strings
c_func
(paren
op_amp
id|re_lsmod
comma
id|line
comma
id|re_lsmod_pmatch
comma
op_amp
id|string
)paren
suffix:semicolon
id|add_symbol
c_func
(paren
op_amp
id|ss_lsmod
comma
id|string
(braket
l_int|2
)braket
comma
l_char|&squot; &squot;
comma
l_int|1
comma
id|string
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|fclose_local
c_func
(paren
id|f
comma
id|procname
)paren
suffix:semicolon
id|free
c_func
(paren
id|line
)paren
suffix:semicolon
id|re_strings_free
c_func
(paren
op_amp
id|re_lsmod
comma
op_amp
id|string
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss_lsmod.used
)paren
id|ss_sort_na
c_func
(paren
op_amp
id|ss_lsmod
)paren
suffix:semicolon
r_else
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Warning, no symbols in lsmod, is %s a valid &quot;
l_string|&quot;lsmod file?&bslash;n&quot;
comma
id|lsmod
)paren
suffix:semicolon
op_increment
id|warnings
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s %s used %d out of %d entries&bslash;n&quot;
comma
id|procname
comma
id|ss_lsmod.source
comma
id|ss_lsmod.used
comma
id|ss_lsmod.alloc
)paren
suffix:semicolon
)brace
multiline_comment|/* Compare modules from ksyms against module list in lsmod and vice versa.&n; * There is one ss_ for each ksyms module and a single ss_lsmod to cross&n; * check.&n; */
DECL|function|compare_ksyms_lsmod
r_void
id|compare_ksyms_lsmod
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
id|SYMBOL_SET
op_star
id|ss
suffix:semicolon
id|SYMBOL
op_star
id|s
suffix:semicolon
r_static
r_char
r_const
id|procname
(braket
)braket
op_assign
l_string|&quot;compare_ksyms_lsmod&quot;
suffix:semicolon
id|s
op_assign
id|ss_lsmod.symbol
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ss_lsmod.used
suffix:semicolon
op_increment
id|i
comma
op_increment
id|s
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ss_ksyms_modules
suffix:semicolon
op_increment
id|j
)paren
(brace
id|ss
op_assign
id|ss_ksyms_module
op_plus
id|j
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|s-&gt;name
comma
id|ss-&gt;source
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
op_ge
id|ss_ksyms_modules
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Warning in %s, module %s is in lsmod but not &quot;
l_string|&quot;in ksyms, probably no symbols exported&bslash;n&quot;
comma
id|procname
comma
id|s-&gt;name
)paren
suffix:semicolon
op_increment
id|warnings
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ss_ksyms_modules
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ss
op_assign
id|ss_ksyms_module
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|find_symbol_name
c_func
(paren
op_amp
id|ss_lsmod
comma
id|ss-&gt;source
comma
l_int|NULL
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Error in %s, module %s is in ksyms but not &quot;
l_string|&quot;in lsmod&bslash;n&quot;
comma
id|procname
comma
id|ss-&gt;source
)paren
suffix:semicolon
op_increment
id|errors
suffix:semicolon
)brace
)brace
)brace
eof
