multiline_comment|/*&n;&t;object.c.&n;&n;&t;object handling routines for ksymoops.  Read modules, vmlinux, etc. &n;&n;&t;Copyright Keith Owens &lt;kaos@ocs.com.au&gt;.&n;&t;Released under the GNU Public Licence, Version 2.&n;&n;&t;Wed Oct 28 13:47:23 EST 1998&n;&t;Version 0.4&n;&t;Split into separate sources.&n; */
macro_line|#include &quot;ksymoops.h&quot;
macro_line|#include &lt;malloc.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;sys/stat.h&gt;
multiline_comment|/* Extract all symbols definitions from an object using nm */
DECL|function|read_nm_symbols
r_static
r_void
id|read_nm_symbols
c_func
(paren
id|SYMBOL_SET
op_star
id|ss
comma
r_const
r_char
op_star
id|file
)paren
(brace
id|FILE
op_star
id|f
suffix:semicolon
r_char
op_star
id|cmd
comma
op_star
id|line
op_assign
l_int|NULL
comma
op_star
op_star
id|string
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
comma
id|size
op_assign
l_int|0
suffix:semicolon
r_static
r_char
r_const
id|procname
(braket
)braket
op_assign
l_string|&quot;read_nm_symbols&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|regular_file
c_func
(paren
id|file
comma
id|procname
)paren
)paren
r_return
suffix:semicolon
id|cmd
op_assign
id|malloc
c_func
(paren
id|strlen
c_func
(paren
id|path_nm
)paren
op_plus
id|strlen
c_func
(paren
id|file
)paren
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
id|malloc_error
c_func
(paren
l_string|&quot;nm command&quot;
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|cmd
comma
id|path_nm
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|cmd
comma
l_string|&quot; &quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|cmd
comma
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s command &squot;%s&squot;&bslash;n&quot;
comma
id|procname
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|f
op_assign
id|popen_local
c_func
(paren
id|cmd
comma
id|procname
)paren
)paren
)paren
r_return
suffix:semicolon
id|free
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fgets_local
c_func
(paren
op_amp
id|line
comma
op_amp
id|size
comma
id|f
comma
id|procname
)paren
)paren
(brace
id|i
op_assign
id|regexec
c_func
(paren
op_amp
id|re_nm
comma
id|line
comma
id|re_nm.re_nsub
op_plus
l_int|1
comma
id|re_nm_pmatch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s regexec %d&bslash;n&quot;
comma
id|procname
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|re_strings
c_func
(paren
op_amp
id|re_nm
comma
id|line
comma
id|re_nm_pmatch
comma
op_amp
id|string
)paren
suffix:semicolon
id|add_symbol
c_func
(paren
id|ss
comma
id|string
(braket
l_int|1
)braket
comma
op_star
id|string
(braket
l_int|2
)braket
comma
l_int|1
comma
id|string
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
)brace
id|pclose_local
c_func
(paren
id|f
comma
id|procname
)paren
suffix:semicolon
id|re_strings_free
c_func
(paren
op_amp
id|re_nm
comma
op_amp
id|string
)paren
suffix:semicolon
id|free
c_func
(paren
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s %s used %d out of %d entries&bslash;n&quot;
comma
id|procname
comma
id|ss-&gt;source
comma
id|ss-&gt;used
comma
id|ss-&gt;alloc
)paren
suffix:semicolon
)brace
multiline_comment|/* Read the symbols from vmlinux */
DECL|function|read_vmlinux
r_void
id|read_vmlinux
c_func
(paren
r_const
r_char
op_star
id|vmlinux
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|vmlinux
)paren
r_return
suffix:semicolon
id|ss_init
c_func
(paren
op_amp
id|ss_vmlinux
comma
l_string|&quot;vmlinux&quot;
)paren
suffix:semicolon
id|read_nm_symbols
c_func
(paren
op_amp
id|ss_vmlinux
comma
id|vmlinux
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ss_vmlinux.used
)paren
(brace
id|ss_sort_na
c_func
(paren
op_amp
id|ss_vmlinux
)paren
suffix:semicolon
id|extract_Version
c_func
(paren
op_amp
id|ss_vmlinux
)paren
suffix:semicolon
)brace
r_else
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Warning, no kernel symbols in vmlinux, is %s a valid &quot;
l_string|&quot;vmlinux file?&bslash;n&quot;
comma
id|vmlinux
)paren
suffix:semicolon
op_increment
id|warnings
suffix:semicolon
)brace
)brace
multiline_comment|/* Read the symbols from one object (module) */
DECL|function|read_object
r_void
id|read_object
c_func
(paren
r_const
r_char
op_star
id|object
comma
r_int
id|i
)paren
(brace
id|ss_init
c_func
(paren
id|ss_object
op_plus
id|i
comma
id|object
)paren
suffix:semicolon
id|read_nm_symbols
c_func
(paren
id|ss_object
op_plus
id|i
comma
id|object
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ss_object
op_plus
id|i
)paren
op_member_access_from_pointer
id|used
)paren
(brace
id|ss_sort_na
c_func
(paren
id|ss_object
op_plus
id|i
)paren
suffix:semicolon
id|extract_Version
c_func
(paren
id|ss_object
op_plus
id|i
)paren
suffix:semicolon
)brace
r_else
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Warning, no symbols in %s&bslash;n&quot;
comma
id|object
)paren
suffix:semicolon
op_increment
id|warnings
suffix:semicolon
)brace
)brace
multiline_comment|/* Add a new entry to the list of objects */
DECL|function|add_ss_object
r_static
r_void
id|add_ss_object
c_func
(paren
r_const
r_char
op_star
id|file
)paren
(brace
op_increment
id|ss_objects
suffix:semicolon
id|ss_object
op_assign
id|realloc
c_func
(paren
id|ss_object
comma
id|ss_objects
op_star
r_sizeof
(paren
op_star
id|ss_object
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ss_object
)paren
id|malloc_error
c_func
(paren
l_string|&quot;realloc ss_object&quot;
)paren
suffix:semicolon
id|ss_init
c_func
(paren
id|ss_object
op_plus
id|ss_objects
op_minus
l_int|1
comma
id|file
)paren
suffix:semicolon
)brace
multiline_comment|/* Run a directory and its subdirectories, looking for *.o files */
DECL|function|find_objects
r_static
r_void
id|find_objects
c_func
(paren
r_const
r_char
op_star
id|dir
)paren
(brace
id|FILE
op_star
id|f
suffix:semicolon
r_char
op_star
id|cmd
comma
op_star
id|line
op_assign
l_int|NULL
suffix:semicolon
r_int
id|size
op_assign
l_int|0
comma
id|files
op_assign
l_int|0
suffix:semicolon
r_static
r_char
r_const
id|procname
(braket
)braket
op_assign
l_string|&quot;find_objects&quot;
suffix:semicolon
r_static
r_char
r_const
id|options
(braket
)braket
op_assign
l_string|&quot; -follow -name &squot;*.o&squot; -print&quot;
suffix:semicolon
id|cmd
op_assign
id|malloc
c_func
(paren
id|strlen
c_func
(paren
id|path_find
)paren
op_plus
l_int|1
op_plus
id|strlen
c_func
(paren
id|dir
)paren
op_plus
id|strlen
c_func
(paren
id|options
)paren
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
id|malloc_error
c_func
(paren
l_string|&quot;find command&quot;
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|cmd
comma
id|path_find
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|cmd
comma
l_string|&quot; &quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|cmd
comma
id|dir
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|cmd
comma
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s command &squot;%s&squot;&bslash;n&quot;
comma
id|procname
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|f
op_assign
id|popen_local
c_func
(paren
id|cmd
comma
id|procname
)paren
)paren
)paren
r_return
suffix:semicolon
id|free
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fgets_local
c_func
(paren
op_amp
id|line
comma
op_amp
id|size
comma
id|f
comma
id|procname
)paren
)paren
(brace
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s - %s&bslash;n&quot;
comma
id|procname
comma
id|line
)paren
suffix:semicolon
id|add_ss_object
c_func
(paren
id|line
)paren
suffix:semicolon
op_increment
id|files
suffix:semicolon
)brace
id|pclose_local
c_func
(paren
id|f
comma
id|procname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|files
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Warning: no *.o files in %s.  &quot;
l_string|&quot;Is %s a valid module directory?&bslash;n&quot;
comma
id|dir
comma
id|dir
)paren
suffix:semicolon
op_increment
id|warnings
suffix:semicolon
)brace
)brace
multiline_comment|/* Take the user supplied list of objects which can include directories.&n; * Expand directories into any *.o files.  The results are stored in&n; * ss_object, leaving the user supplied options untouched.&n; */
DECL|function|expand_objects
r_void
id|expand_objects
c_func
(paren
r_char
op_star
r_const
op_star
id|object
comma
r_int
id|objects
)paren
(brace
r_struct
id|stat
id|statbuf
suffix:semicolon
r_int
id|i
suffix:semicolon
r_const
r_char
op_star
id|file
suffix:semicolon
r_static
r_char
r_const
id|procname
(braket
)braket
op_assign
l_string|&quot;expand_objects&quot;
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|objects
suffix:semicolon
op_increment
id|i
)paren
(brace
id|file
op_assign
id|object
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s checking &squot;%s&squot; - &quot;
comma
id|procname
comma
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stat
c_func
(paren
id|file
comma
op_amp
id|statbuf
)paren
op_logical_and
id|S_ISDIR
c_func
(paren
id|statbuf.st_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;directory, expanding&bslash;n&quot;
)paren
suffix:semicolon
id|find_objects
c_func
(paren
id|file
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;not directory&bslash;n&quot;
)paren
suffix:semicolon
id|add_ss_object
c_func
(paren
id|file
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Map a symbol type to a section code. 0 - text, 1 - data, 2 - read only data,&n; * 3 - C (cannot relocate), 4 - the rest.&n; */
DECL|function|section
r_static
r_int
id|section
c_func
(paren
r_char
id|type
)paren
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
l_char|&squot;T&squot;
suffix:colon
r_case
l_char|&squot;t&squot;
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
l_char|&squot;D&squot;
suffix:colon
r_case
l_char|&squot;d&squot;
suffix:colon
r_return
l_int|1
suffix:semicolon
r_case
l_char|&squot;R&squot;
suffix:colon
r_case
l_char|&squot;r&squot;
suffix:colon
r_return
l_int|2
suffix:semicolon
r_case
l_char|&squot;C&squot;
suffix:colon
r_return
l_int|3
suffix:semicolon
r_default
suffix:colon
r_return
l_int|4
suffix:semicolon
)brace
)brace
multiline_comment|/* Given ksyms module data which has a related object, create a copy of the&n; * object data, adjusting the offsets to match where the module was loaded.&n; */
DECL|function|adjust_object_offsets
id|SYMBOL_SET
op_star
id|adjust_object_offsets
c_func
(paren
id|SYMBOL_SET
op_star
id|ss
)paren
(brace
r_int
id|i
suffix:semicolon
id|elf_addr_t
id|adjust
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|SYMBOL
op_star
id|sk
comma
op_star
id|so
suffix:semicolon
id|SYMBOL_SET
op_star
id|ssc
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: adjust_object_offsets %s&bslash;n&quot;
comma
id|ss-&gt;source
)paren
suffix:semicolon
id|ssc
op_assign
id|ss_copy
c_func
(paren
id|ss-&gt;related
)paren
suffix:semicolon
multiline_comment|/* For common symbols, calculate the adjustment */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ss-&gt;used
suffix:semicolon
op_increment
id|i
)paren
(brace
id|sk
op_assign
id|ss-&gt;symbol
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|so
op_assign
id|find_symbol_name
c_func
(paren
id|ssc
comma
id|sk-&gt;name
comma
l_int|NULL
)paren
)paren
)paren
id|adjust
(braket
id|section
c_func
(paren
id|so-&gt;type
)paren
)braket
op_assign
id|sk-&gt;address
op_minus
id|so-&gt;address
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ssc-&gt;used
suffix:semicolon
op_increment
id|i
)paren
(brace
id|so
op_assign
id|ssc-&gt;symbol
op_plus
id|i
suffix:semicolon
multiline_comment|/* Type C does not relocate well, silently ignore */
r_if
c_cond
(paren
id|so-&gt;type
op_ne
l_char|&squot;C&squot;
op_logical_and
id|adjust
(braket
id|section
c_func
(paren
id|so-&gt;type
)paren
)braket
)paren
id|so-&gt;address
op_add_assign
id|adjust
(braket
id|section
c_func
(paren
id|so-&gt;type
)paren
)braket
suffix:semicolon
r_else
id|so-&gt;keep
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* do not merge into final map */
)brace
id|ss-&gt;related
op_assign
id|ssc
suffix:semicolon
multiline_comment|/* map using adjusted copy */
r_return
id|ssc
suffix:semicolon
)brace
eof
