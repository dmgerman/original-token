multiline_comment|/*&n;&t;ksymoops.c.&n;&n;&t;Read a kernel Oops file and make the best stab at converting the code to&n;&t;instructions and mapping stack values to kernel symbols.&n;&n;&t;Copyright Keith Owens &lt;kaos@ocs.com.au&gt;.&n;&t;Released under the GNU Public Licence, Version 2.&n;*/
DECL|macro|VERSION
mdefine_line|#define VERSION &quot;0.6e&quot;
multiline_comment|/*&n;&n;&t;Tue Jan  5 19:26:02 EST 1999&n;&t;Version 0.6e&n;&t;Added to kernel.&n;&n;&t;Mon Jan  4 09:48:13 EST 1999&n;&t;Version 0.6d&n;&t;Add ARM support.&n;&n;&t;Thu Nov 26 16:37:46 EST 1998&n;&t;Version 0.6c&n;&t;Typo in oops_code.&n;&t;Add -c option.&n;&t;Add -1 option.&n;&t;Report if options were specified or defaulted.&n;&n;&t;Fri Nov  6 10:38:42 EST 1998&n;&t;Version 0.6b&n;&t;Remove false warnings when comparing ksyms and lsmod.&n;&n;&t;Tue Nov  3 23:33:04 EST 1998&n;&t;Version 0.6a&n;&t;Performance inprovements.&n;&n;&t;Tue Nov  3 02:31:01 EST 1998&n;&t;Version 0.6&n;&t;Read lsmod (/proc/modules).&n;&t;Ignore addresses 0-4095 when mapping address to symbol.&n;&t;Discard default objects if -o specified.&n;&t;Oops file must be regular.&n;&t;Add &quot;invalid operand&quot; to Oops_print.&n;&t;Move &quot;Using_Version&quot; copy to map.c.&n;&t;Add Makefile defaults for vmlinux, ksyms, objects, System.map, lsmod.&n;&t;Minor adjustment to re for ppc.&n;&t;Minor adjustment to re for objdump lines with &lt;_EIP+xxx&gt;.&n;&t;Convert from a.out to bfd, using same format as ksymoops.&n;&t;Added MIPS.&n;&t;PPC handling based on patches by &quot;Ryan Nielsen&quot; &lt;ran@krazynet.com&gt;&n;&n;&t;Wed Oct 28 23:14:55 EST 1998&n;&t;Version 0.5&n;&t;No longer read vmlinux by default, it only duplicates System.map.&n;&n;&t;Wed Oct 28 13:47:38 EST 1998&n;&t;Version 0.4&n;&t;Split into separate sources.&n;&n;&t;Mon Oct 26 00:01:47 EST 1998&n;&t;Version 0.3c&n;&t;Add alpha (arm) processing.&n;&n;&t;Mon Oct 26 00:01:47 EST 1998&n;&t;Version 0.3b&n;&t;Add sparc processing.&n;&t;Handle kernel symbol versions.&n;&n;&t;Fri Oct 23 13:11:20 EST 1998&n;&t;Version 0.3&n;&t;Add -follow to find command for people who use symlinks to modules.&n;&t;Add Version_ checking.&n;&n;&t;Thu Oct 22 22:28:30 EST 1998&n;&t;Version 0.2.&n;&t;Generalise text prefix handling.&n;&t;Handle messages on Code: line.&n;&t;Format addresses with leading zeroes.&n;&t;Minor bug fixes.&n;&n;&t;Wed Oct 21 23:28:48 EST 1998&n;&t;Version 0.1.  Rewrite from scratch in C.&n;&n;&t;CREDITS.&n;&t;Oops disassembly based on ksymoops.cc,&n;&t;  Copyright (C) 1995 Greg McGary &lt;gkm@magilla.cichlid.com&gt;&n;&t;m68k code based on ksymoops.cc changes by&n;&t;  Andreas Schwab &lt;schwab@issan.informatik.uni-dortmund.de&gt;&n; */
macro_line|#include &quot;ksymoops.h&quot;
macro_line|#include &lt;ctype.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;malloc.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;sys/utsname.h&gt;
DECL|variable|prefix
r_char
op_star
id|prefix
suffix:semicolon
DECL|variable|path_nm
r_char
op_star
id|path_nm
op_assign
l_string|&quot;/usr/bin/nm&quot;
suffix:semicolon
multiline_comment|/* env KSYMOOPS_NM */
DECL|variable|path_find
r_char
op_star
id|path_find
op_assign
l_string|&quot;/usr/bin/find&quot;
suffix:semicolon
multiline_comment|/* env KSYMOOPS_FIND */
DECL|variable|path_objdump
r_char
op_star
id|path_objdump
op_assign
l_string|&quot;/usr/bin/objdump&quot;
suffix:semicolon
multiline_comment|/* env KSYMOOPS_OBJDUMP */
DECL|variable|debug
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
DECL|variable|errors
r_int
id|errors
op_assign
l_int|0
suffix:semicolon
DECL|variable|warnings
r_int
id|warnings
op_assign
l_int|0
suffix:semicolon
DECL|variable|ss_vmlinux
id|SYMBOL_SET
id|ss_vmlinux
suffix:semicolon
DECL|variable|ss_ksyms_base
id|SYMBOL_SET
id|ss_ksyms_base
suffix:semicolon
DECL|variable|ss_ksyms_module
id|SYMBOL_SET
op_star
id|ss_ksyms_module
suffix:semicolon
DECL|variable|ss_ksyms_modules
r_int
id|ss_ksyms_modules
suffix:semicolon
DECL|variable|ss_lsmod
id|SYMBOL_SET
id|ss_lsmod
suffix:semicolon
DECL|variable|ss_object
id|SYMBOL_SET
op_star
id|ss_object
suffix:semicolon
DECL|variable|ss_objects
r_int
id|ss_objects
suffix:semicolon
DECL|variable|ss_system_map
id|SYMBOL_SET
id|ss_system_map
suffix:semicolon
DECL|variable|ss_merged
id|SYMBOL_SET
id|ss_merged
suffix:semicolon
multiline_comment|/* merged map with info from all sources */
DECL|variable|ss_Version
id|SYMBOL_SET
id|ss_Version
suffix:semicolon
multiline_comment|/* Version_ numbers where available */
multiline_comment|/* Regular expression stuff */
DECL|variable|re_nm
id|regex_t
id|re_nm
suffix:semicolon
DECL|variable|re_nm_pmatch
id|regmatch_t
op_star
id|re_nm_pmatch
suffix:semicolon
DECL|variable|re_bracketed_address
id|regex_t
id|re_bracketed_address
suffix:semicolon
DECL|variable|re_bracketed_address_pmatch
id|regmatch_t
op_star
id|re_bracketed_address_pmatch
suffix:semicolon
DECL|variable|re_unbracketed_address
id|regex_t
id|re_unbracketed_address
suffix:semicolon
DECL|variable|re_unbracketed_address_pmatch
id|regmatch_t
op_star
id|re_unbracketed_address_pmatch
suffix:semicolon
DECL|function|usage
r_static
r_void
id|usage
c_func
(paren
r_void
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Version &quot;
id|VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;usage: %s&bslash;n&quot;
comma
id|prefix
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;&bslash;t&bslash;t[-v vmlinux]&bslash;tWhere to read vmlinux&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t[-V]&bslash;t&bslash;tNo vmlinux is available&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t[-o object_dir]&bslash;tDirectory containing modules&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t[-O]&bslash;t&bslash;tNo modules is available&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t[-k ksyms]&bslash;tWhere to read ksyms&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t[-K]&bslash;t&bslash;tNo ksyms is available&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t[-l lsmod]&bslash;tWhere to read lsmod&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t[-L]&bslash;t&bslash;tNo lsmod is available&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t[-m system.map]&bslash;tWhere to read System.map&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t[-M]&bslash;t&bslash;tNo System.map is available&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t[-s save.map]&bslash;tSave consolidated map&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t[-d]&bslash;t&bslash;tIncrease debug level by 1&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t[-h]&bslash;t&bslash;tPrint help text&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t[-c code_bytes]&bslash;tHow many bytes in each unit of code&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t[-1]&bslash;t&bslash;tOne shot toggle (exit after first Oops)&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t&lt;Oops.file&bslash;tOops report to decode&bslash;n&quot;
l_string|&quot;&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;tAll flags can occur more than once.  With the exception &quot;
l_string|&quot;of -o&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;tand -d which are cumulative, the last occurrence of each &quot;
l_string|&quot;flag is&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;tused.  Note that &bslash;&quot;-v my.vmlinux -V&bslash;&quot; will be taken as &quot;
l_string|&quot;&bslash;&quot;No vmlinux&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;tavailable&bslash;&quot; but &bslash;&quot;-V -v my.vmlinux&bslash;&quot; will read &quot;
l_string|&quot;my.vmlinux.  You&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;twill be warned about such combinations.&bslash;n&quot;
l_string|&quot;&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;tEach occurrence of -d increases the debug level.&bslash;n&quot;
l_string|&quot;&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;tEach -o flag can refer to a directory or to a single &quot;
l_string|&quot;object&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;tfile.  If a directory is specified then all *.o files in &quot;
l_string|&quot;that&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;tdirectory and its subdirectories are assumed to be &quot;
l_string|&quot;modules.&bslash;n&quot;
l_string|&quot;&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;tIf any of the vmlinux, object_dir, ksyms or system.map &quot;
l_string|&quot;options&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;tcontain the string *r (*m, *n, *s) then it is replaced &quot;
l_string|&quot;at run&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;ttime by the current value of `uname -r` (-m, -n, -s).&bslash;n&quot;
l_string|&quot;&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;tThe defaults can be changed in the Makefile, current &quot;
l_string|&quot;defaults&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;tare&bslash;n&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t&bslash;t&quot;
macro_line|#ifdef DEF_VMLINUX
l_string|&quot;-v &quot;
id|DEF_LINUX
macro_line|#else
l_string|&quot;-V&quot;
macro_line|#endif
l_string|&quot;&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t&bslash;t&quot;
macro_line|#ifdef DEF_OBJECTS
l_string|&quot;-o &quot;
id|DEF_OBJECTS
macro_line|#else
l_string|&quot;-O&quot;
macro_line|#endif
l_string|&quot;&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t&bslash;t&quot;
macro_line|#ifdef DEF_KSYMS
l_string|&quot;-k &quot;
id|DEF_KSYMS
macro_line|#else
l_string|&quot;-K&quot;
macro_line|#endif
l_string|&quot;&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t&bslash;t&quot;
macro_line|#ifdef DEF_LSMOD
l_string|&quot;-l &quot;
id|DEF_LSMOD
macro_line|#else
l_string|&quot;-L&quot;
macro_line|#endif
l_string|&quot;&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t&bslash;t&quot;
macro_line|#ifdef DEF_MAP
l_string|&quot;-m &quot;
id|DEF_MAP
macro_line|#else
l_string|&quot;-M&quot;
macro_line|#endif
l_string|&quot;&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t&bslash;t-c %d&bslash;n&quot;
multiline_comment|/* DEF_CODE_BYTES */
l_string|&quot;&bslash;t&bslash;t&bslash;tOops report is read from stdin&bslash;n&quot;
l_string|&quot;&bslash;n&quot;
comma
id|DEF_CODE_BYTES
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if possibly conflicting options were specified */
DECL|function|multi_opt
r_static
r_void
id|multi_opt
c_func
(paren
r_int
id|specl
comma
r_int
id|specu
comma
r_char
id|type
comma
r_const
r_char
op_star
r_using
)paren
(brace
r_if
c_cond
(paren
id|specl
op_logical_and
id|specu
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Warning - you specified both -%c and -%c.  Using &squot;&quot;
comma
id|type
comma
id|toupper
c_func
(paren
id|type
)paren
)paren
suffix:semicolon
op_increment
id|warnings
suffix:semicolon
r_if
c_cond
(paren
r_using
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;-%c %s&quot;
comma
id|type
comma
r_using
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
l_char|&squot;o&squot;
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot; ...&quot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;&squot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;-%c&squot;&bslash;n&quot;
comma
id|toupper
c_func
(paren
id|type
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|specl
OG
l_int|1
op_logical_and
id|type
op_ne
l_char|&squot;o&squot;
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Warning - you specified -%c more than once.  &quot;
l_string|&quot;Using &squot;-%c %s&squot;&bslash;n&quot;
comma
id|type
comma
id|type
comma
r_using
)paren
suffix:semicolon
op_increment
id|warnings
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|specu
OG
l_int|1
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Warning - you specified -%c more than once.  &quot;
l_string|&quot;Second and subsequent &squot;-%c&squot; ignored&bslash;n&quot;
comma
id|toupper
c_func
(paren
id|type
)paren
comma
id|toupper
c_func
(paren
id|type
)paren
)paren
suffix:semicolon
op_increment
id|warnings
suffix:semicolon
)brace
)brace
multiline_comment|/* If a name contains *r (*m, *n, *s), replace with the current value of&n; * `uname -r` (-m, -n, -s).  Actually uses uname system call rather than the&n; * uname command but the result is the same.&n; */
DECL|function|convert_uname
r_static
r_void
id|convert_uname
c_func
(paren
r_char
op_star
op_star
id|name
)paren
(brace
r_char
op_star
id|p
comma
op_star
id|newname
comma
op_star
id|oldname
comma
op_star
id|replacement
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|free_oldname
op_assign
l_int|0
suffix:semicolon
r_static
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;convert_uname&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|name
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
(paren
id|p
op_assign
id|strchr
c_func
(paren
op_star
id|name
comma
l_char|&squot;*&squot;
)paren
)paren
)paren
(brace
r_struct
id|utsname
id|buf
suffix:semicolon
r_int
id|i
op_assign
id|uname
c_func
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s %s in&bslash;n&quot;
comma
id|procname
comma
op_star
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: uname failed, %s will not be processed&bslash;n&quot;
comma
id|prefix
comma
op_star
id|name
)paren
suffix:semicolon
id|perror
c_func
(paren
id|prefix
)paren
suffix:semicolon
op_increment
id|errors
suffix:semicolon
r_return
suffix:semicolon
)brace
r_switch
c_cond
(paren
op_star
(paren
id|p
op_plus
l_int|1
)paren
)paren
(brace
r_case
l_char|&squot;r&squot;
suffix:colon
id|replacement
op_assign
id|buf.release
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
id|replacement
op_assign
id|buf.machine
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
id|replacement
op_assign
id|buf.nodename
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
id|replacement
op_assign
id|buf.sysname
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: invalid replacement character &squot;*%c&squot; &quot;
l_string|&quot;in %s&bslash;n&quot;
comma
id|prefix
comma
op_star
(paren
id|p
op_plus
l_int|1
)paren
comma
op_star
id|name
)paren
suffix:semicolon
op_increment
id|errors
suffix:semicolon
r_return
suffix:semicolon
)brace
id|len
op_assign
id|strlen
c_func
(paren
op_star
id|name
)paren
op_minus
l_int|2
op_plus
id|strlen
c_func
(paren
id|replacement
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|newname
op_assign
id|malloc
c_func
(paren
id|len
)paren
)paren
)paren
id|malloc_error
c_func
(paren
id|procname
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|newname
comma
op_star
id|name
comma
(paren
id|p
op_minus
op_star
id|name
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|newname
op_plus
(paren
id|p
op_minus
op_star
id|name
)paren
comma
id|replacement
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|newname
op_plus
(paren
id|p
op_minus
op_star
id|name
)paren
op_plus
id|strlen
c_func
(paren
id|replacement
)paren
comma
id|p
op_plus
l_int|2
)paren
suffix:semicolon
id|p
op_assign
id|newname
op_plus
(paren
id|p
op_minus
op_star
id|name
)paren
op_plus
id|strlen
c_func
(paren
id|replacement
)paren
suffix:semicolon
multiline_comment|/* no rescan */
id|oldname
op_assign
op_star
id|name
suffix:semicolon
op_star
id|name
op_assign
id|newname
suffix:semicolon
r_if
c_cond
(paren
id|free_oldname
)paren
id|free
c_func
(paren
id|oldname
)paren
suffix:semicolon
id|free_oldname
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s %s out&bslash;n&quot;
comma
id|procname
comma
op_star
id|name
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Report if the option was specified or defaulted */
DECL|function|spec_or_default
r_static
r_void
id|spec_or_default
c_func
(paren
r_int
id|spec
comma
r_int
op_star
id|some_spec
)paren
(brace
r_if
c_cond
(paren
id|spec
)paren
(brace
id|printf
c_func
(paren
l_string|&quot; (specified)&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|some_spec
)paren
op_star
id|some_spec
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot; (default)&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Parse the options.  Verbose but what&squot;s new with getopt? */
DECL|function|parse
r_static
r_void
id|parse
c_func
(paren
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
comma
r_char
op_star
op_star
id|vmlinux
comma
r_char
op_star
op_star
op_star
id|object
comma
r_int
op_star
id|objects
comma
r_char
op_star
op_star
id|ksyms
comma
r_char
op_star
op_star
id|lsmod
comma
r_char
op_star
op_star
id|system_map
comma
r_char
op_star
op_star
id|save_system_map
comma
r_char
op_star
op_star
op_star
id|filename
comma
r_int
op_star
id|filecount
comma
r_int
op_star
id|spec_h
comma
r_int
op_star
id|code_bytes
comma
r_int
op_star
id|one_shot
)paren
(brace
r_int
id|spec_v
op_assign
l_int|0
comma
id|spec_V
op_assign
l_int|0
suffix:semicolon
r_int
id|spec_o
op_assign
l_int|0
comma
id|spec_O
op_assign
l_int|0
suffix:semicolon
r_int
id|spec_k
op_assign
l_int|0
comma
id|spec_K
op_assign
l_int|0
suffix:semicolon
r_int
id|spec_l
op_assign
l_int|0
comma
id|spec_L
op_assign
l_int|0
suffix:semicolon
r_int
id|spec_m
op_assign
l_int|0
comma
id|spec_M
op_assign
l_int|0
suffix:semicolon
r_int
id|spec_s
op_assign
l_int|0
suffix:semicolon
r_int
id|spec_c
op_assign
l_int|0
suffix:semicolon
r_int
id|c
comma
id|i
comma
id|some_spec
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
id|getopt
c_func
(paren
id|argc
comma
id|argv
comma
l_string|&quot;v:Vo:Ok:Kl:Lm:Ms:dhc:1&quot;
)paren
)paren
op_ne
id|EOF
)paren
(brace
r_if
c_cond
(paren
id|debug
op_logical_and
id|c
op_ne
l_char|&squot;d&squot;
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: getopt &squot;%c&squot; &squot;%s&squot;&bslash;n&quot;
comma
id|c
comma
id|optarg
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;v&squot;
suffix:colon
op_star
id|vmlinux
op_assign
id|optarg
suffix:semicolon
op_increment
id|spec_v
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;V&squot;
suffix:colon
op_star
id|vmlinux
op_assign
l_int|NULL
suffix:semicolon
op_increment
id|spec_V
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;o&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|spec_o
)paren
(brace
multiline_comment|/* First -o, discard default value(s) */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
op_star
id|objects
suffix:semicolon
op_increment
id|i
)paren
id|free
c_func
(paren
(paren
op_star
id|object
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|free
c_func
(paren
op_star
id|object
)paren
suffix:semicolon
op_star
id|object
op_assign
l_int|NULL
suffix:semicolon
op_star
id|objects
op_assign
l_int|0
suffix:semicolon
)brace
op_star
id|object
op_assign
id|realloc
c_func
(paren
op_star
id|object
comma
(paren
(paren
op_star
id|objects
)paren
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
op_star
id|object
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|object
)paren
id|malloc_error
c_func
(paren
l_string|&quot;object&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_assign
id|strdup
c_func
(paren
id|optarg
)paren
)paren
)paren
id|malloc_error
c_func
(paren
l_string|&quot;strdup -o&quot;
)paren
suffix:semicolon
r_else
(brace
(paren
op_star
id|object
)paren
(braket
(paren
op_star
id|objects
)paren
op_increment
)braket
op_assign
id|p
suffix:semicolon
op_increment
id|spec_o
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;O&squot;
suffix:colon
op_increment
id|spec_O
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
op_star
id|objects
suffix:semicolon
op_increment
id|i
)paren
id|free
c_func
(paren
(paren
op_star
id|object
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|free
c_func
(paren
op_star
id|object
)paren
suffix:semicolon
op_star
id|object
op_assign
l_int|NULL
suffix:semicolon
op_star
id|objects
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;k&squot;
suffix:colon
op_star
id|ksyms
op_assign
id|optarg
suffix:semicolon
op_increment
id|spec_k
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;K&squot;
suffix:colon
op_star
id|ksyms
op_assign
l_int|NULL
suffix:semicolon
op_increment
id|spec_K
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
op_star
id|lsmod
op_assign
id|optarg
suffix:semicolon
op_increment
id|spec_l
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;L&squot;
suffix:colon
op_star
id|lsmod
op_assign
l_int|NULL
suffix:semicolon
op_increment
id|spec_L
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
op_star
id|system_map
op_assign
id|optarg
suffix:semicolon
op_increment
id|spec_m
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;M&squot;
suffix:colon
op_star
id|system_map
op_assign
l_int|NULL
suffix:semicolon
op_increment
id|spec_M
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
op_star
id|save_system_map
op_assign
id|optarg
suffix:semicolon
op_increment
id|spec_s
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
op_increment
id|debug
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;h&squot;
suffix:colon
id|usage
c_func
(paren
)paren
suffix:semicolon
op_increment
op_star
id|spec_h
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
op_increment
id|spec_c
suffix:semicolon
id|errno
op_assign
l_int|0
suffix:semicolon
op_star
id|code_bytes
op_assign
id|strtoul
c_func
(paren
id|optarg
comma
op_amp
id|p
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Oops_code_values assumes that code_bytes is a&n;&t;&t;&t; * multiple of 2.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
op_star
id|optarg
op_logical_or
op_star
id|p
op_logical_or
id|errno
op_logical_or
(paren
op_star
id|code_bytes
op_ne
l_int|1
op_logical_and
op_star
id|code_bytes
op_ne
l_int|2
op_logical_and
op_star
id|code_bytes
op_ne
l_int|4
op_logical_and
op_star
id|code_bytes
op_ne
l_int|8
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s Invalid value for -c &squot;%s&squot;&bslash;n&quot;
comma
id|prefix
comma
id|optarg
)paren
suffix:semicolon
op_increment
id|errors
suffix:semicolon
r_if
c_cond
(paren
id|errno
)paren
id|perror
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
op_star
id|code_bytes
op_assign
id|DEF_CODE_BYTES
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;1&squot;
suffix:colon
op_star
id|one_shot
op_assign
op_logical_neg
op_star
id|one_shot
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;?&squot;
suffix:colon
id|usage
c_func
(paren
)paren
suffix:semicolon
m_exit
(paren
l_int|2
)paren
suffix:semicolon
)brace
)brace
op_star
id|filecount
op_assign
id|argc
op_minus
id|optind
suffix:semicolon
op_star
id|filename
op_assign
id|argv
op_plus
id|optind
suffix:semicolon
multiline_comment|/* Expand any requests for the current uname values */
id|convert_uname
c_func
(paren
id|vmlinux
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|objects
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
op_star
id|objects
suffix:semicolon
op_increment
id|i
)paren
id|convert_uname
c_func
(paren
op_star
id|object
op_plus
id|i
)paren
suffix:semicolon
)brace
id|convert_uname
c_func
(paren
id|ksyms
)paren
suffix:semicolon
id|convert_uname
c_func
(paren
id|lsmod
)paren
suffix:semicolon
id|convert_uname
c_func
(paren
id|system_map
)paren
suffix:semicolon
multiline_comment|/* Check for multiple options specified */
id|multi_opt
c_func
(paren
id|spec_v
comma
id|spec_V
comma
l_char|&squot;v&squot;
comma
op_star
id|vmlinux
)paren
suffix:semicolon
id|multi_opt
c_func
(paren
id|spec_o
comma
id|spec_O
comma
l_char|&squot;o&squot;
comma
op_star
id|object
ques
c_cond
op_star
op_star
id|object
suffix:colon
l_int|NULL
)paren
suffix:semicolon
id|multi_opt
c_func
(paren
id|spec_k
comma
id|spec_K
comma
l_char|&squot;k&squot;
comma
op_star
id|ksyms
)paren
suffix:semicolon
id|multi_opt
c_func
(paren
id|spec_l
comma
id|spec_L
comma
l_char|&squot;l&squot;
comma
op_star
id|lsmod
)paren
suffix:semicolon
id|multi_opt
c_func
(paren
id|spec_m
comma
id|spec_M
comma
l_char|&squot;m&squot;
comma
op_star
id|system_map
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Options used:&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|vmlinux
)paren
id|printf
c_func
(paren
l_string|&quot; -v %s&quot;
comma
op_star
id|vmlinux
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot; -V&quot;
)paren
suffix:semicolon
id|spec_or_default
c_func
(paren
id|spec_v
op_logical_or
id|spec_V
comma
op_amp
id|some_spec
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;             &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|objects
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
op_star
id|objects
suffix:semicolon
op_increment
id|i
)paren
id|printf
c_func
(paren
l_string|&quot; -o %s&quot;
comma
(paren
op_star
id|object
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot; -O&quot;
)paren
suffix:semicolon
id|spec_or_default
c_func
(paren
id|spec_o
op_logical_or
id|spec_O
comma
op_amp
id|some_spec
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;             &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ksyms
)paren
id|printf
c_func
(paren
l_string|&quot; -k %s&quot;
comma
op_star
id|ksyms
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot; -K&quot;
)paren
suffix:semicolon
id|spec_or_default
c_func
(paren
id|spec_k
op_logical_or
id|spec_K
comma
op_amp
id|some_spec
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;             &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|lsmod
)paren
id|printf
c_func
(paren
l_string|&quot; -l %s&quot;
comma
op_star
id|lsmod
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot; -L&quot;
)paren
suffix:semicolon
id|spec_or_default
c_func
(paren
id|spec_l
op_logical_or
id|spec_L
comma
op_amp
id|some_spec
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;             &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|system_map
)paren
id|printf
c_func
(paren
l_string|&quot; -m %s&quot;
comma
op_star
id|system_map
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot; -M&quot;
)paren
suffix:semicolon
id|spec_or_default
c_func
(paren
id|spec_m
op_logical_or
id|spec_M
comma
op_amp
id|some_spec
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;             &quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; -c %d&quot;
comma
op_star
id|code_bytes
)paren
suffix:semicolon
id|spec_or_default
c_func
(paren
id|spec_c
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|one_shot
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;             &quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot; -1&quot;
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|some_spec
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;You did not tell me where to find symbol information.  I will assume&bslash;n&quot;
l_string|&quot;that the log matches the kernel and modules that are running right now&bslash;n&quot;
l_string|&quot;and I&squot;ll use the default options above for symbol resolution.&bslash;n&quot;
l_string|&quot;If the current kernel and/or modules do not match the log, you can get&bslash;n&quot;
l_string|&quot;more accurate output by telling me the kernel version and where to find&bslash;n&quot;
l_string|&quot;map, modules, ksyms etc.  ksymoops -h explains the options.&bslash;n&quot;
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
op_increment
id|warnings
suffix:semicolon
)brace
)brace
multiline_comment|/* Read environment variables */
DECL|function|read_env
r_static
r_void
id|read_env
c_func
(paren
r_const
r_char
op_star
id|external
comma
r_char
op_star
op_star
id|internal
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p
op_assign
id|getenv
c_func
(paren
id|external
)paren
)paren
)paren
(brace
op_star
id|internal
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: env override %s=%s&bslash;n&quot;
comma
id|external
comma
op_star
id|internal
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|debug
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: env default %s=%s&bslash;n&quot;
comma
id|external
comma
op_star
id|internal
)paren
suffix:semicolon
)brace
)brace
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
r_char
op_star
id|vmlinux
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
op_star
id|object
op_assign
l_int|NULL
suffix:semicolon
r_int
id|objects
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|ksyms
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|lsmod
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|system_map
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|save_system_map
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
op_star
id|filename
suffix:semicolon
r_int
id|filecount
op_assign
l_int|0
suffix:semicolon
r_int
id|spec_h
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* -h was specified */
r_int
id|code_bytes
op_assign
id|DEF_CODE_BYTES
suffix:semicolon
r_int
id|one_shot
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|ret
suffix:semicolon
id|prefix
op_assign
op_star
id|argv
suffix:semicolon
id|setvbuf
c_func
(paren
id|stdout
comma
l_int|NULL
comma
id|_IONBF
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef DEF_VMLINUX
id|vmlinux
op_assign
id|DEF_LINUX
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEF_OBJECTS
(brace
r_char
op_star
id|p
suffix:semicolon
id|object
op_assign
id|realloc
c_func
(paren
id|object
comma
(paren
id|objects
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
op_star
id|object
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|object
)paren
id|malloc_error
c_func
(paren
l_string|&quot;DEF_OBJECTS&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_assign
id|strdup
c_func
(paren
id|DEF_OBJECTS
)paren
)paren
)paren
id|malloc_error
c_func
(paren
l_string|&quot;DEF_OBJECTS&quot;
)paren
suffix:semicolon
r_else
id|object
(braket
id|objects
op_increment
)braket
op_assign
id|p
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef DEF_KSYMS
id|ksyms
op_assign
id|DEF_KSYMS
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEF_LSMOD
id|lsmod
op_assign
id|DEF_LSMOD
suffix:semicolon
macro_line|#endif
macro_line|#ifdef DEF_MAP
id|system_map
op_assign
id|DEF_MAP
suffix:semicolon
macro_line|#endif
id|parse
c_func
(paren
id|argc
comma
id|argv
comma
op_amp
id|vmlinux
comma
op_amp
id|object
comma
op_amp
id|objects
comma
op_amp
id|ksyms
comma
op_amp
id|lsmod
comma
op_amp
id|system_map
comma
op_amp
id|save_system_map
comma
op_amp
id|filename
comma
op_amp
id|filecount
comma
op_amp
id|spec_h
comma
op_amp
id|code_bytes
comma
op_amp
id|one_shot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|spec_h
op_logical_and
id|filecount
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* just the help text */
r_if
c_cond
(paren
id|errors
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: level %d&bslash;n&quot;
comma
id|debug
)paren
suffix:semicolon
id|read_env
c_func
(paren
l_string|&quot;KSYMOOPS_NM&quot;
comma
op_amp
id|path_nm
)paren
suffix:semicolon
id|read_env
c_func
(paren
l_string|&quot;KSYMOOPS_FIND&quot;
comma
op_amp
id|path_find
)paren
suffix:semicolon
id|read_env
c_func
(paren
l_string|&quot;KSYMOOPS_OBJDUMP&quot;
comma
op_amp
id|path_objdump
)paren
suffix:semicolon
id|re_compile_common
c_func
(paren
)paren
suffix:semicolon
id|ss_init_common
c_func
(paren
)paren
suffix:semicolon
id|read_vmlinux
c_func
(paren
id|vmlinux
)paren
suffix:semicolon
id|read_ksyms
c_func
(paren
id|ksyms
)paren
suffix:semicolon
multiline_comment|/* No point in reading modules unless ksyms shows modules loaded */
r_if
c_cond
(paren
id|ss_ksyms_modules
)paren
(brace
id|expand_objects
c_func
(paren
id|object
comma
id|objects
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ss_objects
suffix:semicolon
op_increment
id|i
)paren
id|read_object
c_func
(paren
id|ss_object
(braket
id|i
)braket
dot
id|source
comma
id|i
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|objects
)paren
id|printf
c_func
(paren
l_string|&quot;No modules in ksyms, skipping objects&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* No point in reading lsmod without ksyms */
r_if
c_cond
(paren
id|ss_ksyms_modules
op_logical_or
id|ss_ksyms_base.used
)paren
id|read_lsmod
c_func
(paren
id|lsmod
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|lsmod
)paren
id|printf
c_func
(paren
l_string|&quot;No ksyms, skipping lsmod&bslash;n&quot;
)paren
suffix:semicolon
id|read_system_map
c_func
(paren
id|system_map
)paren
suffix:semicolon
id|merge_maps
c_func
(paren
id|save_system_map
)paren
suffix:semicolon
multiline_comment|/* After all that work, it is finally time to read the Oops report */
id|ret
op_assign
id|Oops_read
c_func
(paren
id|filecount
comma
id|filename
comma
id|code_bytes
comma
id|one_shot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|warnings
op_logical_or
id|errors
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|warnings
)paren
id|printf
c_func
(paren
l_string|&quot;%d warning%s &quot;
comma
id|warnings
comma
id|warnings
op_eq
l_int|1
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|warnings
op_logical_and
id|errors
)paren
id|printf
c_func
(paren
l_string|&quot;and &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errors
)paren
id|printf
c_func
(paren
l_string|&quot;%d error%s &quot;
comma
id|errors
comma
id|errors
op_eq
l_int|1
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;issued.  Results may not be reliable.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
eof
