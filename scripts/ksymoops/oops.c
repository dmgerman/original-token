multiline_comment|/*&n;&t;oops.c.&n;&n;&t;Oops processing for ksymoop.&n;&n;&t;Copyright Keith Owens &lt;kaos@ocs.com.au&gt;.&n;&t;Released under the GNU Public Licence, Version 2.&n;&t;&n;&t;Sun Jan  7 12:56:12 CET 1999&n;&t;Added SPARC64 support and some SPARC hacks by &quot;Jakub Jelinek&quot;&n;&t;&lt;jj@ultra.linux.cz&gt;&n;&n;&t;Mon Jan  4 08:47:55 EST 1999&n;&t;Version 0.6d&n;&t;Add ARM support.&n;&n;&t;Thu Nov 26 16:37:46 EST 1998&n;&t;Version 0.6c&n;&t;Typo in oops_code.&n;&t;Add -c option.&n;&n;&t;Tue Nov  3 23:33:04 EST 1998&n;&t;Version 0.6a&n;&t;Performance inprovements.&n;&n;&t;Tue Nov  3 02:31:01 EST 1998&n;&t;Version 0.6&n;&t;Oops file must be regular.&n;&t;Add &quot;invalid operand&quot; to Oops_print.&n;&t;Minor adjustment to re for ppc.&n;&t;Minor adjustment to re for objdump lines with &lt;_EIP+xxx&gt;.&n;&t;Convert from a.out to bfd, using same format as ksymoops.&n;&t;Added MIPS.&n;&t;PPC handling based on patches by &quot;Ryan Nielsen&quot; &lt;ran@krazynet.com&gt;&n;&n;&t;Wed Oct 28 13:47:23 EST 1998&n;&t;Version 0.4&n;&t;Split into seperate sources.&n; */
macro_line|#include &quot;ksymoops.h&quot;
macro_line|#include &lt;bfd.h&gt;
macro_line|#include &lt;ctype.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;malloc.h&gt;
macro_line|#include &lt;memory.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;unistd.h&gt;
DECL|enum|oops_arch
r_enum
id|oops_arch
(brace
DECL|enumerator|OOPS_NOARCH
id|OOPS_NOARCH
comma
DECL|enumerator|OOPS_I386
id|OOPS_I386
comma
DECL|enumerator|OOPS_SPARC
id|OOPS_SPARC
comma
DECL|enumerator|OOPS_SPARC64
id|OOPS_SPARC64
comma
DECL|enumerator|OOPS_ARM
id|OOPS_ARM
comma
DECL|enumerator|OOPS_ALPHA
id|OOPS_ALPHA
comma
DECL|enumerator|OOPS_MIPS
id|OOPS_MIPS
comma
DECL|enumerator|OOPS_PPC
id|OOPS_PPC
comma
DECL|enumerator|OOPS_M68K
id|OOPS_M68K
DECL|variable|oops_arch
)brace
id|oops_arch
suffix:semicolon
DECL|variable|eip_names
r_char
op_star
id|eip_names
(braket
)braket
op_assign
(brace
l_string|&quot;IP&quot;
comma
l_string|&quot;EIP&quot;
comma
l_string|&quot;PC&quot;
comma
l_string|&quot;PC&quot;
comma
l_string|&quot;PC&quot;
comma
l_string|&quot;PC&quot;
comma
l_string|&quot;PC&quot;
comma
l_string|&quot;NIP&quot;
comma
l_string|&quot;PC&quot;
)brace
suffix:semicolon
multiline_comment|/* Error detected by bfd */
DECL|function|Oops_bfd_perror
r_static
r_void
id|Oops_bfd_perror
c_func
(paren
r_const
r_char
op_star
id|msg
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Error &quot;
)paren
suffix:semicolon
id|bfd_perror
c_func
(paren
id|msg
)paren
suffix:semicolon
op_increment
id|errors
suffix:semicolon
)brace
multiline_comment|/* Safest way to get correct output bfd format is to copy ksymoops&squot; format. */
DECL|function|Oops_copy_bfd_format
r_static
r_int
id|Oops_copy_bfd_format
c_func
(paren
id|bfd
op_star
op_star
id|ibfd
comma
id|bfd
op_star
op_star
id|obfd
comma
id|asection
op_star
op_star
id|isec
comma
r_const
r_char
op_star
id|file
)paren
(brace
r_char
op_star
id|me
comma
op_star
op_star
id|matches
comma
op_star
op_star
id|match
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|obfd
op_assign
id|bfd_openw
c_func
(paren
id|file
comma
l_int|NULL
)paren
)paren
)paren
(brace
id|Oops_bfd_perror
c_func
(paren
id|file
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|me
op_assign
id|find_fullpath
c_func
(paren
id|prefix
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|me
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|ibfd
op_assign
id|bfd_openr
c_func
(paren
id|me
comma
l_int|NULL
)paren
)paren
)paren
(brace
id|Oops_bfd_perror
c_func
(paren
id|me
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|free
c_func
(paren
id|me
)paren
suffix:semicolon
multiline_comment|/* Who is Tommy? */
r_if
c_cond
(paren
op_logical_neg
id|bfd_check_format_matches
c_func
(paren
op_star
id|ibfd
comma
id|bfd_object
comma
op_amp
id|matches
)paren
)paren
(brace
id|Oops_bfd_perror
c_func
(paren
id|me
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bfd_get_error
c_func
(paren
)paren
op_eq
id|bfd_error_file_ambiguously_recognized
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Matching formats:&quot;
)paren
suffix:semicolon
id|match
op_assign
id|matches
suffix:semicolon
r_while
c_loop
(paren
op_star
id|match
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot; %s&quot;
comma
op_star
id|match
op_increment
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|free
c_func
(paren
id|matches
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|isec
op_assign
id|bfd_get_section_by_name
c_func
(paren
op_star
id|ibfd
comma
l_string|&quot;.text&quot;
)paren
)paren
)paren
(brace
id|Oops_bfd_perror
c_func
(paren
l_string|&quot;get_section&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|bfd_set_format
c_func
(paren
op_star
id|obfd
comma
id|bfd_object
)paren
suffix:semicolon
id|bfd_set_arch_mach
c_func
(paren
op_star
id|obfd
comma
id|bfd_get_arch
c_func
(paren
op_star
id|ibfd
)paren
comma
id|bfd_get_mach
c_func
(paren
op_star
id|ibfd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bfd_set_file_flags
c_func
(paren
op_star
id|obfd
comma
id|bfd_get_file_flags
c_func
(paren
op_star
id|ibfd
)paren
)paren
)paren
(brace
id|Oops_bfd_perror
c_func
(paren
l_string|&quot;set_file_flags&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Write the code values to a file using bfd. */
DECL|function|Oops_write_bfd_data
r_static
r_int
id|Oops_write_bfd_data
c_func
(paren
id|bfd
op_star
id|ibfd
comma
id|bfd
op_star
id|obfd
comma
id|asection
op_star
id|isec
comma
r_const
r_char
op_star
id|code
comma
r_int
id|size
)paren
(brace
id|asection
op_star
id|osec
suffix:semicolon
id|asymbol
op_star
id|osym
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bfd_set_start_address
c_func
(paren
id|obfd
comma
l_int|0
)paren
)paren
(brace
id|Oops_bfd_perror
c_func
(paren
l_string|&quot;set_start_address&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|osec
op_assign
id|bfd_make_section
c_func
(paren
id|obfd
comma
l_string|&quot;.text&quot;
)paren
)paren
)paren
(brace
id|Oops_bfd_perror
c_func
(paren
l_string|&quot;make_section&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bfd_set_section_flags
c_func
(paren
id|obfd
comma
id|osec
comma
id|bfd_get_section_flags
c_func
(paren
id|ibfd
comma
id|isec
)paren
)paren
)paren
(brace
id|Oops_bfd_perror
c_func
(paren
l_string|&quot;set_section_flags&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bfd_set_section_alignment
c_func
(paren
id|obfd
comma
id|osec
comma
id|bfd_get_section_alignment
c_func
(paren
id|ibfd
comma
id|isec
)paren
)paren
)paren
(brace
id|Oops_bfd_perror
c_func
(paren
l_string|&quot;set_section_alignment&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|osec-&gt;output_section
op_assign
id|osec
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|osym
op_assign
id|bfd_make_empty_symbol
c_func
(paren
id|obfd
)paren
)paren
)paren
(brace
id|Oops_bfd_perror
c_func
(paren
l_string|&quot;make_empty_symbol&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|osym-&gt;name
op_assign
l_string|&quot;_EIP&quot;
suffix:semicolon
id|osym-&gt;section
op_assign
id|osec
suffix:semicolon
id|osym-&gt;flags
op_assign
id|BSF_GLOBAL
suffix:semicolon
id|osym-&gt;value
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bfd_set_symtab
c_func
(paren
id|obfd
comma
op_amp
id|osym
comma
l_int|1
)paren
)paren
(brace
id|Oops_bfd_perror
c_func
(paren
l_string|&quot;set_symtab&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bfd_set_section_size
c_func
(paren
id|obfd
comma
id|osec
comma
id|size
)paren
)paren
(brace
id|Oops_bfd_perror
c_func
(paren
l_string|&quot;set_section_size&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bfd_set_section_vma
c_func
(paren
id|obfd
comma
id|osec
comma
l_int|0
)paren
)paren
(brace
id|Oops_bfd_perror
c_func
(paren
l_string|&quot;set_section_vma&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bfd_set_section_contents
c_func
(paren
id|obfd
comma
id|osec
comma
(paren
id|PTR
)paren
id|code
comma
l_int|0
comma
id|size
)paren
)paren
(brace
id|Oops_bfd_perror
c_func
(paren
l_string|&quot;set_section_contents&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bfd_close
c_func
(paren
id|obfd
)paren
)paren
(brace
id|Oops_bfd_perror
c_func
(paren
l_string|&quot;close(obfd)&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bfd_close
c_func
(paren
id|ibfd
)paren
)paren
(brace
id|Oops_bfd_perror
c_func
(paren
l_string|&quot;close(ibfd)&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Write the Oops code to a temporary file with suitable header and trailer. */
DECL|function|Oops_code_to_file
r_static
r_char
op_star
id|Oops_code_to_file
c_func
(paren
r_const
r_char
op_star
id|code
comma
r_int
id|size
)paren
(brace
r_char
op_star
id|file
suffix:semicolon
id|bfd
op_star
id|ibfd
comma
op_star
id|obfd
suffix:semicolon
id|asection
op_star
id|isec
suffix:semicolon
id|bfd_init
c_func
(paren
)paren
suffix:semicolon
id|file
op_assign
id|tmpnam
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Oops_copy_bfd_format
c_func
(paren
op_amp
id|ibfd
comma
op_amp
id|obfd
comma
op_amp
id|isec
comma
id|file
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Oops_write_bfd_data
c_func
(paren
id|ibfd
comma
id|obfd
comma
id|isec
comma
id|code
comma
id|size
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|file
suffix:semicolon
)brace
multiline_comment|/* Run objdump against the binary Oops code */
DECL|function|Oops_objdump
r_static
id|FILE
op_star
id|Oops_objdump
c_func
(paren
r_const
r_char
op_star
id|file
)paren
(brace
r_char
op_star
id|cmd
suffix:semicolon
id|FILE
op_star
id|f
suffix:semicolon
r_static
r_char
r_const
id|options
(braket
)braket
op_assign
l_string|&quot;-dhf &quot;
suffix:semicolon
r_static
r_char
r_const
id|procname
(braket
)braket
op_assign
l_string|&quot;Oops_objdump&quot;
suffix:semicolon
id|cmd
op_assign
id|malloc
c_func
(paren
id|strlen
c_func
(paren
id|path_objdump
)paren
op_plus
l_int|1
op_plus
l_int|13
op_plus
id|strlen
c_func
(paren
id|options
)paren
op_plus
id|strlen
c_func
(paren
id|file
)paren
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cmd
)paren
id|malloc_error
c_func
(paren
id|procname
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|cmd
comma
id|path_objdump
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|cmd
comma
l_string|&quot; &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oops_arch
op_eq
id|OOPS_SPARC64
)paren
id|strcat
c_func
(paren
id|cmd
comma
l_string|&quot;-m sparc:v9a &quot;
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|cmd
comma
id|options
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|cmd
comma
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s command &squot;%s&squot;&bslash;n&quot;
comma
id|procname
comma
id|cmd
)paren
suffix:semicolon
id|f
op_assign
id|popen_local
c_func
(paren
id|cmd
comma
id|procname
)paren
suffix:semicolon
id|free
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_return
id|f
suffix:semicolon
)brace
multiline_comment|/* Process one code line from objdump, ignore everything else */
DECL|function|Oops_decode_one
r_static
r_void
id|Oops_decode_one
c_func
(paren
id|SYMBOL_SET
op_star
id|ss
comma
r_const
r_char
op_star
id|line
comma
id|elf_addr_t
id|eip
comma
r_int
id|adjust
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
id|elf_addr_t
id|address
comma
id|eip_relative
suffix:semicolon
r_char
op_star
id|line2
comma
op_star
id|map
comma
op_star
op_star
id|string
op_assign
l_int|NULL
comma
op_star
id|p
suffix:semicolon
r_static
id|regex_t
id|re_Oops_objdump
suffix:semicolon
r_static
id|regmatch_t
op_star
id|re_Oops_objdump_pmatch
suffix:semicolon
r_static
r_char
r_const
id|procname
(braket
)braket
op_assign
l_string|&quot;Oops_decode_one&quot;
suffix:semicolon
multiline_comment|/* objdump output.  Optional whitespace, hex digits, optional&n;&t; * &squot; &lt;_EIP+offset&gt;&squot;, &squot;:&squot;.  The &squot;+offset&squot; after _EIP is also optional.&n;&t; * Older binutils output &squot;xxxxxxxx &lt;_EIP+offset&gt;:&squot;, newer versions do&n;&t; * &squot;00000000 &lt;_EIP&gt;:&squot; first followed by &squot;      xx:&squot; lines.&n;&t; *&n;&t; * Just to complicate things even more, objdump recognises jmp, call,&n;&t; * etc., converts the code to something like this :-&n;&t; * &quot;   f: e8 32 34 00 00  call   3446 &lt;_EIP+0x3446&gt;&quot;&n;&t; * Recognise this and append the eip adjusted address, followed by the&n;&t; * map_address text for that address.&n;&t; *&n;&t; * With any luck, objdump will take care of all such references which&n;&t; * makes this routine architecture insensitive.  No need to test for&n;&t; * i386 jmp, call or m68k swl etc.&n;&t; */
id|re_compile
c_func
(paren
op_amp
id|re_Oops_objdump
comma
l_string|&quot;^[ &bslash;t]*&quot;
l_string|&quot;([0-9a-fA-F]+)&quot;
multiline_comment|/* 1 */
l_string|&quot;( &lt;_EIP[^&gt;]*&gt;)?&quot;
multiline_comment|/* 2 */
l_string|&quot;:&quot;
l_string|&quot;(&quot;
multiline_comment|/* 3 */
l_string|&quot;.* +&quot;
l_string|&quot;(0?x?[0-9a-fA-F]+ +)&quot;
multiline_comment|/* 4 */
l_string|&quot;&lt;_EIP&bslash;&bslash;+0?x?([0-9a-fA-F]+)&gt;[ &bslash;t]*$&quot;
multiline_comment|/* 5 */
l_string|&quot;)?&quot;
l_string|&quot;.*&quot;
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
op_or
id|REG_ICASE
comma
op_amp
id|re_Oops_objdump_pmatch
)paren
suffix:semicolon
id|i
op_assign
id|regexec
c_func
(paren
op_amp
id|re_Oops_objdump
comma
id|line
comma
id|re_Oops_objdump.re_nsub
op_plus
l_int|1
comma
id|re_Oops_objdump_pmatch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s regexec %d&bslash;n&quot;
comma
id|procname
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
l_int|0
)paren
r_return
suffix:semicolon
id|re_strings
c_func
(paren
op_amp
id|re_Oops_objdump
comma
id|line
comma
id|re_Oops_objdump_pmatch
comma
op_amp
id|string
)paren
suffix:semicolon
id|errno
op_assign
l_int|0
suffix:semicolon
id|address
op_assign
id|strtoul
c_func
(paren
id|string
(braket
l_int|1
)braket
comma
l_int|NULL
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errno
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s Invalid hex value in objdump line, &quot;
l_string|&quot;treated as zero - &squot;%s&squot;&bslash;n&quot;
l_string|&quot;  objdump line &squot;%s&squot;&bslash;n&quot;
comma
id|procname
comma
id|string
(braket
l_int|1
)braket
comma
id|line
)paren
suffix:semicolon
id|perror
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
op_increment
id|errors
suffix:semicolon
id|address
op_assign
l_int|0
suffix:semicolon
)brace
id|address
op_add_assign
id|eip
op_plus
id|adjust
suffix:semicolon
r_if
c_cond
(paren
id|string
(braket
l_int|5
)braket
)paren
(brace
multiline_comment|/* EIP relative data to be adjusted */
id|errno
op_assign
l_int|0
suffix:semicolon
id|eip_relative
op_assign
id|strtoul
c_func
(paren
id|string
(braket
l_int|5
)braket
comma
l_int|NULL
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errno
)paren
(brace
macro_line|#if 0
multiline_comment|/* Try strtoull also, e.g. sparc binutils print &lt;_PC+0xfffffffffffffd58&gt; */
id|errno
op_assign
l_int|0
suffix:semicolon
id|eip_relative
op_assign
id|strtoull
c_func
(paren
id|string
(braket
l_int|5
)braket
comma
l_int|NULL
comma
l_int|16
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|errno
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s Invalid hex value in objdump line, &quot;
l_string|&quot;treated as zero - &squot;%s&squot;&bslash;n&quot;
l_string|&quot;  objdump line &squot;%s&squot;&bslash;n&quot;
comma
id|procname
comma
id|string
(braket
l_int|5
)braket
comma
id|line
)paren
suffix:semicolon
id|perror
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
op_increment
id|errors
suffix:semicolon
id|eip_relative
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|eip_relative
op_add_assign
id|eip
op_plus
id|adjust
suffix:semicolon
id|map
op_assign
id|map_address
c_func
(paren
op_amp
id|ss_merged
comma
id|eip_relative
)paren
suffix:semicolon
multiline_comment|/* new text is original line, eip_relative in hex, map text */
id|j
op_assign
id|strlen
c_func
(paren
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
id|string
(braket
l_int|4
)braket
)paren
id|j
op_assign
id|re_Oops_objdump_pmatch
(braket
l_int|4
)braket
dot
id|rm_so
suffix:semicolon
id|i
op_assign
id|j
op_plus
l_int|1
op_plus
l_int|2
op_star
r_sizeof
(paren
id|eip_relative
)paren
op_plus
l_int|1
op_plus
id|strlen
c_func
(paren
id|map
)paren
op_plus
l_int|1
suffix:semicolon
id|line2
op_assign
id|malloc
c_func
(paren
id|i
op_plus
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|line2
)paren
id|malloc_error
c_func
(paren
id|procname
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|line2
comma
id|i
comma
l_string|&quot;%.*s %s %s&quot;
comma
id|j
comma
id|line
comma
id|format_address
c_func
(paren
id|eip_relative
)paren
comma
id|map
)paren
suffix:semicolon
)brace
r_else
(brace
id|line2
op_assign
id|malloc
c_func
(paren
id|strlen
c_func
(paren
id|line
)paren
op_plus
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|line2
)paren
id|malloc_error
c_func
(paren
id|procname
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|line2
comma
id|line
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|oops_arch
op_ne
id|OOPS_I386
)paren
(brace
id|p
op_assign
id|line2
suffix:semicolon
r_while
c_loop
(paren
(paren
id|p
op_assign
id|strstr
c_func
(paren
id|p
comma
l_string|&quot;_EIP&quot;
)paren
)paren
)paren
(brace
r_int
id|l
op_assign
id|strlen
c_func
(paren
id|eip_names
(braket
id|oops_arch
)braket
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|p
op_plus
l_int|1
comma
id|eip_names
(braket
id|oops_arch
)braket
comma
id|l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
OL
l_int|3
)paren
id|strcpy
c_func
(paren
id|p
op_plus
l_int|1
op_plus
id|l
comma
id|p
op_plus
l_int|4
)paren
suffix:semicolon
id|p
op_add_assign
l_int|1
op_plus
id|l
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|address
op_eq
id|eip
)paren
id|strcat
c_func
(paren
id|line2
comma
l_string|&quot; &lt;===&quot;
)paren
suffix:semicolon
multiline_comment|/* This makes it easier to locate visually the&n;&t;&t;&t;&t;&t;&t;&t;   offending instruction */
id|add_symbol_n
c_func
(paren
id|ss
comma
id|address
comma
l_char|&squot;C&squot;
comma
l_int|1
comma
id|line2
)paren
suffix:semicolon
multiline_comment|/* as is */
id|free
c_func
(paren
id|line2
)paren
suffix:semicolon
id|re_strings_free
c_func
(paren
op_amp
id|re_Oops_objdump
comma
op_amp
id|string
)paren
suffix:semicolon
)brace
multiline_comment|/* Maximum number of code bytes to process.  It needs to be a multiple of 2 for&n; * code_byte (-c) swapping.  Sparc and alpha dump 36 bytes so use 64.&n; */
DECL|macro|CODE_SIZE
mdefine_line|#define CODE_SIZE 64
multiline_comment|/******************************************************************************/
multiline_comment|/*                     Start architecture sensitive code                      */
multiline_comment|/******************************************************************************/
multiline_comment|/* Extract the hex values from the Code: line and convert to binary */
DECL|function|Oops_code_values
r_static
r_int
id|Oops_code_values
c_func
(paren
r_const
r_int
r_char
op_star
id|code_text
comma
r_char
op_star
id|code
comma
r_int
op_star
id|adjust
comma
r_char
op_star
op_star
op_star
id|string
comma
r_int
id|string_max
comma
r_int
id|code_bytes
)paren
(brace
r_int
id|byte
op_assign
l_int|0
comma
id|i
comma
id|l
suffix:semicolon
r_int
r_int
id|c
suffix:semicolon
r_char
op_star
id|value
suffix:semicolon
r_const
r_char
op_star
id|p
suffix:semicolon
r_static
id|regex_t
id|re_Oops_code_value
suffix:semicolon
r_static
id|regmatch_t
op_star
id|re_Oops_code_value_pmatch
suffix:semicolon
r_static
r_const
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;Oops_code_values&quot;
suffix:semicolon
multiline_comment|/* Given by re_Oops_code: code_text is a message (e.g. &quot;general&n;&t; * protection&quot;) or one or more hex fields separated by space or tab.&n;&t; * Some architectures bracket the current instruction with &squot;&lt;&squot;&n;&t; * and &squot;&gt;&squot;, others use &squot;(&squot; and &squot;)&squot;.  The first character is&n;&t; * nonblank.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|isxdigit
c_func
(paren
op_star
id|code_text
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Warning, Code looks like message, not hex digits.  &quot;
l_string|&quot;No disassembly attempted.&bslash;n&quot;
)paren
suffix:semicolon
op_increment
id|warnings
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|memset
c_func
(paren
id|code
comma
l_char|&squot;&bslash;0&squot;
comma
id|CODE_SIZE
)paren
suffix:semicolon
id|p
op_assign
id|code_text
suffix:semicolon
op_star
id|adjust
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* EIP points to code byte 0 */
multiline_comment|/* Code values.  Hex values separated by white space.  On sparc, the&n;&t; * current instruction is bracketed in &squot;&lt;&squot; and &squot;&gt;&squot;.&n;&t; */
id|re_compile
c_func
(paren
op_amp
id|re_Oops_code_value
comma
l_string|&quot;^&quot;
l_string|&quot;([&lt;(]?)&quot;
multiline_comment|/* 1 */
l_string|&quot;([0-9a-fA-F]+)&quot;
multiline_comment|/* 2 */
l_string|&quot;[&gt;)]?&quot;
l_string|&quot;[ &bslash;t]*&quot;
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
op_or
id|REG_ICASE
comma
op_amp
id|re_Oops_code_value_pmatch
)paren
suffix:semicolon
id|re_string_check
c_func
(paren
id|re_Oops_code_value.re_nsub
op_plus
l_int|1
comma
id|string_max
comma
id|procname
)paren
suffix:semicolon
r_while
c_loop
(paren
id|regexec
c_func
(paren
op_amp
id|re_Oops_code_value
comma
id|p
comma
id|re_Oops_code_value.re_nsub
op_plus
l_int|1
comma
id|re_Oops_code_value_pmatch
comma
l_int|0
)paren
op_eq
l_int|0
)paren
(brace
id|re_strings
c_func
(paren
op_amp
id|re_Oops_code_value
comma
id|p
comma
id|re_Oops_code_value_pmatch
comma
id|string
)paren
suffix:semicolon
r_if
c_cond
(paren
id|byte
op_ge
id|CODE_SIZE
)paren
r_break
suffix:semicolon
id|errno
op_assign
l_int|0
suffix:semicolon
id|value
op_assign
(paren
op_star
id|string
)paren
(braket
l_int|2
)braket
suffix:semicolon
id|c
op_assign
id|strtoul
c_func
(paren
id|value
comma
l_int|NULL
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errno
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s Invalid hex value in code_value line, &quot;
l_string|&quot;treated as zero - &squot;%s&squot;&bslash;n&quot;
l_string|&quot;  code_value line &squot;%s&squot;&bslash;n&quot;
comma
id|procname
comma
id|value
comma
id|code_text
)paren
suffix:semicolon
id|perror
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
op_increment
id|errors
suffix:semicolon
id|c
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_star
id|string
)paren
(braket
l_int|1
)braket
op_logical_and
op_star
(paren
(paren
op_star
id|string
)paren
(braket
l_int|1
)braket
)paren
)paren
op_star
id|adjust
op_assign
op_minus
id|byte
suffix:semicolon
multiline_comment|/* this byte is EIP */
multiline_comment|/* i386 - 2 byte code, m68k - 4 byte, sparc - 8 byte.&n;&t;&t; * On some architectures Code: is a stream of bytes, on some it&n;&t;&t; * is a stream of shorts, on some it is a stream of ints.&n;&t;&t; * Consistent we&squot;re not!&n;&t;&t; */
id|l
op_assign
id|strlen
c_func
(paren
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
op_mod
l_int|2
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s invalid value 0x%s in Code line, not a &quot;
l_string|&quot;multiple of 2 digits, value ignored&bslash;n&quot;
comma
id|procname
comma
id|value
)paren
suffix:semicolon
op_increment
id|errors
suffix:semicolon
)brace
r_else
r_while
c_loop
(paren
id|l
)paren
(brace
r_if
c_cond
(paren
id|byte
op_ge
id|CODE_SIZE
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s Warning: extra values in Code &quot;
l_string|&quot;line, ignored - &squot;%s&squot;&bslash;n&quot;
comma
id|procname
comma
id|value
)paren
suffix:semicolon
op_increment
id|warnings
suffix:semicolon
r_break
suffix:semicolon
)brace
id|l
op_sub_assign
l_int|2
suffix:semicolon
id|code
(braket
id|byte
op_increment
)braket
op_assign
(paren
id|c
op_rshift
id|l
op_star
l_int|4
)paren
op_amp
l_int|0xff
suffix:semicolon
id|value
op_add_assign
l_int|2
suffix:semicolon
)brace
id|p
op_add_assign
id|re_Oops_code_value_pmatch
(braket
l_int|0
)braket
dot
id|rm_eo
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|p
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Warning garbage &squot;%s&squot; at end of code line ignored &quot;
l_string|&quot;by %s&bslash;n&quot;
comma
id|p
comma
id|procname
)paren
suffix:semicolon
op_increment
id|warnings
suffix:semicolon
)brace
multiline_comment|/* The code_bytes parameter says how many readable bytes form a single&n;&t; * code unit in machine terms.  -c 1 says that the text is already in&n;&t; * machine order, -c 2 (4, 8) says each chunk of 2 (4, 8) bytes must be&n;&t; * swapped to get back to machine order.  Which end is up?&n;&t; */
r_if
c_cond
(paren
id|code_bytes
op_ne
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|byte
op_mod
id|code_bytes
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Warning: the number of code bytes (%d) is not &quot;
l_string|&quot;a multiple of -c (%d)&bslash;n&quot;
l_string|&quot;Byte swapping may not give sensible results&bslash;n&quot;
comma
id|byte
comma
id|code_bytes
)paren
suffix:semicolon
op_increment
id|warnings
suffix:semicolon
)brace
r_for
c_loop
(paren
id|l
op_assign
l_int|0
suffix:semicolon
id|l
OL
id|byte
suffix:semicolon
id|l
op_add_assign
id|code_bytes
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|code_bytes
op_div
l_int|2
suffix:semicolon
op_increment
id|i
)paren
(brace
id|c
op_assign
id|code
(braket
id|l
op_plus
id|i
)braket
suffix:semicolon
id|code
(braket
id|l
op_plus
id|i
)braket
op_assign
id|code
(braket
id|l
op_plus
id|code_bytes
op_minus
id|i
op_minus
l_int|1
)braket
suffix:semicolon
id|code
(braket
id|l
op_plus
id|code_bytes
op_minus
id|i
op_minus
l_int|1
)braket
op_assign
id|c
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Look for the EIP: line, returns start of the relevant hex value */
DECL|function|Oops_eip
r_static
r_char
op_star
id|Oops_eip
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_char
op_star
op_star
op_star
id|string
comma
r_int
id|string_max
)paren
(brace
r_int
id|i
suffix:semicolon
r_static
id|regex_t
id|re_Oops_eip_sparc
suffix:semicolon
r_static
id|regmatch_t
op_star
id|re_Oops_eip_sparc_pmatch
suffix:semicolon
r_static
id|regex_t
id|re_Oops_eip_sparc64
suffix:semicolon
r_static
id|regmatch_t
op_star
id|re_Oops_eip_sparc64_pmatch
suffix:semicolon
r_static
id|regex_t
id|re_Oops_eip_ppc
suffix:semicolon
r_static
id|regmatch_t
op_star
id|re_Oops_eip_ppc_pmatch
suffix:semicolon
r_static
id|regex_t
id|re_Oops_eip_mips
suffix:semicolon
r_static
id|regmatch_t
op_star
id|re_Oops_eip_mips_pmatch
suffix:semicolon
r_static
id|regex_t
id|re_Oops_eip_other
suffix:semicolon
r_static
id|regmatch_t
op_star
id|re_Oops_eip_other_pmatch
suffix:semicolon
r_static
r_const
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;Oops_eip&quot;
suffix:semicolon
multiline_comment|/* Oops &squot;EIP:&squot; line for sparc, actually PSR followed by PC */
id|re_compile
c_func
(paren
op_amp
id|re_Oops_eip_sparc
comma
l_string|&quot;^PSR: [0-9a-fA-F]+ PC: &quot;
id|UNBRACKETED_ADDRESS
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
op_or
id|REG_ICASE
comma
op_amp
id|re_Oops_eip_sparc_pmatch
)paren
suffix:semicolon
id|i
op_assign
id|regexec
c_func
(paren
op_amp
id|re_Oops_eip_sparc
comma
id|line
comma
id|re_Oops_eip_sparc.re_nsub
op_plus
l_int|1
comma
id|re_Oops_eip_sparc_pmatch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s regexec sparc %d&bslash;n&quot;
comma
id|procname
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|re_string_check
c_func
(paren
id|re_Oops_eip_sparc.re_nsub
op_plus
l_int|1
comma
id|string_max
comma
id|procname
)paren
suffix:semicolon
id|re_strings
c_func
(paren
op_amp
id|re_Oops_eip_sparc
comma
id|line
comma
id|re_Oops_eip_sparc_pmatch
comma
id|string
)paren
suffix:semicolon
id|oops_arch
op_assign
id|OOPS_SPARC
suffix:semicolon
r_return
(paren
op_star
id|string
)paren
(braket
id|re_Oops_eip_sparc.re_nsub
)braket
suffix:semicolon
)brace
multiline_comment|/* Oops &squot;EIP:&squot; line for sparc64, actually TSTATE followed by TPC */
id|re_compile
c_func
(paren
op_amp
id|re_Oops_eip_sparc64
comma
l_string|&quot;^TSTATE: [0-9a-fA-F]{16} TPC: &quot;
id|UNBRACKETED_ADDRESS
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
op_or
id|REG_ICASE
comma
op_amp
id|re_Oops_eip_sparc64_pmatch
)paren
suffix:semicolon
id|re_string_check
c_func
(paren
id|re_Oops_eip_sparc64.re_nsub
op_plus
l_int|1
comma
id|string_max
comma
id|procname
)paren
suffix:semicolon
id|i
op_assign
id|regexec
c_func
(paren
op_amp
id|re_Oops_eip_sparc64
comma
id|line
comma
id|re_Oops_eip_sparc64.re_nsub
op_plus
l_int|1
comma
id|re_Oops_eip_sparc64_pmatch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s regexec sparc64 %d&bslash;n&quot;
comma
id|procname
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|re_strings
c_func
(paren
op_amp
id|re_Oops_eip_sparc64
comma
id|line
comma
id|re_Oops_eip_sparc64_pmatch
comma
id|string
)paren
suffix:semicolon
id|oops_arch
op_assign
id|OOPS_SPARC64
suffix:semicolon
r_return
(paren
op_star
id|string
)paren
(braket
id|re_Oops_eip_sparc64.re_nsub
)braket
suffix:semicolon
)brace
multiline_comment|/* Oops &squot;EIP:&squot; line for PPC, all over the place */
id|re_compile
c_func
(paren
op_amp
id|re_Oops_eip_ppc
comma
l_string|&quot;(&quot;
l_string|&quot;(kernel pc )&quot;
l_string|&quot;|(trap at PC: )&quot;
l_string|&quot;|(bad area pc )&quot;
l_string|&quot;|(NIP: )&quot;
l_string|&quot;)&quot;
id|UNBRACKETED_ADDRESS
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
op_or
id|REG_ICASE
comma
op_amp
id|re_Oops_eip_ppc_pmatch
)paren
suffix:semicolon
id|i
op_assign
id|regexec
c_func
(paren
op_amp
id|re_Oops_eip_ppc
comma
id|line
comma
id|re_Oops_eip_ppc.re_nsub
op_plus
l_int|1
comma
id|re_Oops_eip_ppc_pmatch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s regexec ppc %d&bslash;n&quot;
comma
id|procname
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|re_string_check
c_func
(paren
id|re_Oops_eip_ppc.re_nsub
op_plus
l_int|1
comma
id|string_max
comma
id|procname
)paren
suffix:semicolon
id|re_strings
c_func
(paren
op_amp
id|re_Oops_eip_ppc
comma
id|line
comma
id|re_Oops_eip_ppc_pmatch
comma
id|string
)paren
suffix:semicolon
id|oops_arch
op_assign
id|OOPS_PPC
suffix:semicolon
r_return
(paren
op_star
id|string
)paren
(braket
id|re_Oops_eip_ppc.re_nsub
)braket
suffix:semicolon
)brace
multiline_comment|/* Oops &squot;EIP:&squot; line for MIPS, epc, optional white space, &squot;:&squot;,&n;&t; * optional white space, unbracketed address.&n;&t; */
id|re_compile
c_func
(paren
op_amp
id|re_Oops_eip_mips
comma
l_string|&quot;^(epc[ &bslash;t]*:+[ &bslash;t]*)&quot;
id|UNBRACKETED_ADDRESS
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
op_or
id|REG_ICASE
comma
op_amp
id|re_Oops_eip_mips_pmatch
)paren
suffix:semicolon
id|i
op_assign
id|regexec
c_func
(paren
op_amp
id|re_Oops_eip_mips
comma
id|line
comma
id|re_Oops_eip_mips.re_nsub
op_plus
l_int|1
comma
id|re_Oops_eip_mips_pmatch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s regexec mips %d&bslash;n&quot;
comma
id|procname
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|re_string_check
c_func
(paren
id|re_Oops_eip_mips.re_nsub
op_plus
l_int|1
comma
id|string_max
comma
id|procname
)paren
suffix:semicolon
id|re_strings
c_func
(paren
op_amp
id|re_Oops_eip_mips
comma
id|line
comma
id|re_Oops_eip_mips_pmatch
comma
id|string
)paren
suffix:semicolon
id|oops_arch
op_assign
id|OOPS_MIPS
suffix:semicolon
r_return
(paren
op_star
id|string
)paren
(braket
id|re_Oops_eip_mips.re_nsub
)braket
suffix:semicolon
)brace
multiline_comment|/* Oops &squot;EIP:&squot; line for other architectures */
id|re_compile
c_func
(paren
op_amp
id|re_Oops_eip_other
comma
l_string|&quot;^(&quot;
multiline_comment|/* i386 */
l_string|&quot;(EIP:[ &bslash;t]+.*)&quot;
multiline_comment|/* m68k */
l_string|&quot;|(PC[ &bslash;t]*=[ &bslash;t]*)&quot;
multiline_comment|/* ARM */
l_string|&quot;|(pc *: *)&quot;
l_string|&quot;)&quot;
id|BRACKETED_ADDRESS
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
op_or
id|REG_ICASE
comma
op_amp
id|re_Oops_eip_other_pmatch
)paren
suffix:semicolon
id|i
op_assign
id|regexec
c_func
(paren
op_amp
id|re_Oops_eip_other
comma
id|line
comma
id|re_Oops_eip_other.re_nsub
op_plus
l_int|1
comma
id|re_Oops_eip_other_pmatch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s regexec other %d&bslash;n&quot;
comma
id|procname
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|re_string_check
c_func
(paren
id|re_Oops_eip_other.re_nsub
op_plus
l_int|1
comma
id|string_max
comma
id|procname
)paren
suffix:semicolon
id|re_strings
c_func
(paren
op_amp
id|re_Oops_eip_other
comma
id|line
comma
id|re_Oops_eip_other_pmatch
comma
id|string
)paren
suffix:semicolon
id|oops_arch
op_assign
id|OOPS_I386
suffix:semicolon
r_return
(paren
op_star
id|string
)paren
(braket
id|re_Oops_eip_other.re_nsub
)braket
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Set the eip from the EIP line */
DECL|function|Oops_set_eip
r_static
r_void
id|Oops_set_eip
c_func
(paren
r_const
r_char
op_star
id|value
comma
id|elf_addr_t
op_star
id|eip
comma
id|SYMBOL_SET
op_star
id|ss
)paren
(brace
r_static
r_const
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;Oops_set_eip&quot;
suffix:semicolon
r_char
id|buf
(braket
l_int|10
)braket
suffix:semicolon
id|errno
op_assign
l_int|0
suffix:semicolon
op_star
id|eip
op_assign
id|strtoul
c_func
(paren
id|value
comma
l_int|NULL
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errno
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s Invalid hex value in EIP line, ignored - &squot;%s&squot;&bslash;n&quot;
comma
id|procname
comma
id|value
)paren
suffix:semicolon
id|perror
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
op_increment
id|errors
suffix:semicolon
op_star
id|eip
op_assign
l_int|0
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;&gt;&gt;%s:&quot;
comma
id|eip_names
(braket
id|oops_arch
)braket
)paren
suffix:semicolon
id|add_symbol_n
c_func
(paren
id|ss
comma
op_star
id|eip
comma
l_char|&squot;E&squot;
comma
l_int|1
comma
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/* Look for the MIPS ra line, returns start of the relevant hex value */
DECL|function|Oops_ra
r_static
r_char
op_star
id|Oops_ra
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_char
op_star
op_star
op_star
id|string
comma
r_int
id|string_max
)paren
(brace
r_int
id|i
suffix:semicolon
r_static
id|regex_t
id|re_Oops_ra
suffix:semicolon
r_static
id|regmatch_t
op_star
id|re_Oops_ra_pmatch
suffix:semicolon
r_static
r_const
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;Oops_ra&quot;
suffix:semicolon
multiline_comment|/* Oops &squot;ra:&squot; line for MIPS, ra, optional white space, one or&n;&t; * more &squot;=&squot;, optional white space, unbracketed address.&n;&t; */
id|re_compile
c_func
(paren
op_amp
id|re_Oops_ra
comma
l_string|&quot;(ra[ &bslash;t]*=+[ &bslash;t]*)&quot;
id|UNBRACKETED_ADDRESS
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
op_or
id|REG_ICASE
comma
op_amp
id|re_Oops_ra_pmatch
)paren
suffix:semicolon
id|i
op_assign
id|regexec
c_func
(paren
op_amp
id|re_Oops_ra
comma
id|line
comma
id|re_Oops_ra.re_nsub
op_plus
l_int|1
comma
id|re_Oops_ra_pmatch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s regexec %d&bslash;n&quot;
comma
id|procname
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|re_string_check
c_func
(paren
id|re_Oops_ra.re_nsub
op_plus
l_int|1
comma
id|string_max
comma
id|procname
)paren
suffix:semicolon
id|re_strings
c_func
(paren
op_amp
id|re_Oops_ra
comma
id|line
comma
id|re_Oops_ra_pmatch
comma
id|string
)paren
suffix:semicolon
r_return
(paren
op_star
id|string
)paren
(braket
id|re_Oops_ra.re_nsub
)braket
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Set the MIPS ra from the ra line */
DECL|function|Oops_set_ra
r_static
r_void
id|Oops_set_ra
c_func
(paren
r_const
r_char
op_star
id|value
comma
id|SYMBOL_SET
op_star
id|ss
)paren
(brace
r_static
r_const
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;Oops_set_ra&quot;
suffix:semicolon
id|elf_addr_t
id|ra
suffix:semicolon
id|errno
op_assign
l_int|0
suffix:semicolon
id|ra
op_assign
id|strtoul
c_func
(paren
id|value
comma
l_int|NULL
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errno
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s Invalid hex value in ra line, ignored - &squot;%s&squot;&bslash;n&quot;
comma
id|procname
comma
id|value
)paren
suffix:semicolon
id|perror
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
op_increment
id|errors
suffix:semicolon
id|ra
op_assign
l_int|0
suffix:semicolon
)brace
id|add_symbol_n
c_func
(paren
id|ss
comma
id|ra
comma
l_char|&squot;R&squot;
comma
l_int|1
comma
l_string|&quot;&gt;&gt;RA :&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Look for the SPARC o7/i7 registers line, returns start of the relevant hex value */
DECL|function|Oops_oi7
r_static
r_char
op_star
id|Oops_oi7
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_char
op_star
op_star
op_star
id|string
comma
r_int
id|string_max
)paren
(brace
r_int
id|i
suffix:semicolon
r_static
id|regex_t
id|re_Oops_oi7
suffix:semicolon
r_static
id|regmatch_t
op_star
id|re_Oops_oi7_pmatch
suffix:semicolon
r_static
r_const
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;Oops_oi7&quot;
suffix:semicolon
id|re_compile
c_func
(paren
op_amp
id|re_Oops_oi7
comma
l_string|&quot;^[io][04]: [0-9a-fA-F iosp:]+ ([io]7|ret_pc): &quot;
id|UNBRACKETED_ADDRESS
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
op_or
id|REG_ICASE
comma
op_amp
id|re_Oops_oi7_pmatch
)paren
suffix:semicolon
id|re_string_check
c_func
(paren
id|re_Oops_oi7.re_nsub
op_plus
l_int|1
comma
id|string_max
comma
id|procname
)paren
suffix:semicolon
id|i
op_assign
id|regexec
c_func
(paren
op_amp
id|re_Oops_oi7
comma
id|line
comma
id|re_Oops_oi7.re_nsub
op_plus
l_int|1
comma
id|re_Oops_oi7_pmatch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s regexec %d&bslash;n&quot;
comma
id|procname
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|re_strings
c_func
(paren
op_amp
id|re_Oops_oi7
comma
id|line
comma
id|re_Oops_oi7_pmatch
comma
id|string
)paren
suffix:semicolon
r_return
(paren
op_star
id|string
)paren
(braket
id|re_Oops_oi7.re_nsub
)braket
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Set the SPARC o7/i7 from the oi7 line */
DECL|function|Oops_set_oi7
r_static
r_void
id|Oops_set_oi7
c_func
(paren
r_const
r_char
op_star
id|value
comma
r_char
op_star
op_star
op_star
id|string
comma
id|SYMBOL_SET
op_star
id|ss
)paren
(brace
r_static
r_const
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;Oops_set_oi7&quot;
suffix:semicolon
id|elf_addr_t
id|oi7
suffix:semicolon
r_int
id|o7
op_assign
l_int|1
suffix:semicolon
id|errno
op_assign
l_int|0
suffix:semicolon
id|oi7
op_assign
id|strtoul
c_func
(paren
id|value
comma
l_int|NULL
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|string
)paren
(braket
l_int|1
)braket
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
(paren
op_star
id|string
)paren
(braket
l_int|1
)braket
comma
l_string|&quot;i7&quot;
)paren
)paren
id|o7
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|errno
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s Invalid hex value in oi7 line, ignored - &squot;%s&squot;&bslash;n&quot;
comma
id|procname
comma
id|value
)paren
suffix:semicolon
id|perror
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
op_increment
id|errors
suffix:semicolon
id|oi7
op_assign
l_int|0
suffix:semicolon
)brace
id|add_symbol_n
c_func
(paren
id|ss
comma
id|oi7
comma
l_char|&squot;O&squot;
comma
l_int|1
comma
id|o7
ques
c_cond
l_string|&quot;&gt;&gt;O7:&quot;
suffix:colon
l_string|&quot;&gt;&gt;I7:&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Look for the SPARC register dump lines end */
DECL|function|Oops_sparc_regdump
r_static
r_int
id|Oops_sparc_regdump
c_func
(paren
r_const
r_char
op_star
id|line
)paren
(brace
r_int
id|i
suffix:semicolon
r_static
id|regex_t
id|re_Oops_sparc_regdump
suffix:semicolon
r_static
id|regmatch_t
op_star
id|re_Oops_sparc_regdump_pmatch
suffix:semicolon
r_static
r_const
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;Oops_sparc_regdump&quot;
suffix:semicolon
id|re_compile
c_func
(paren
op_amp
id|re_Oops_sparc_regdump
comma
l_string|&quot;^(i[04]: &quot;
l_string|&quot;|Instruction DUMP: &quot;
l_string|&quot;|Caller&bslash;&bslash;[&quot;
l_string|&quot;)&quot;
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
op_or
id|REG_ICASE
comma
op_amp
id|re_Oops_sparc_regdump_pmatch
)paren
suffix:semicolon
id|i
op_assign
id|regexec
c_func
(paren
op_amp
id|re_Oops_sparc_regdump
comma
id|line
comma
id|re_Oops_sparc_regdump.re_nsub
op_plus
l_int|1
comma
id|re_Oops_sparc_regdump_pmatch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s regexec %d&bslash;n&quot;
comma
id|procname
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Look for the Trace multilines :(.  Returns start of addresses. */
DECL|function|Oops_trace
r_static
r_const
r_char
op_star
id|Oops_trace
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_char
op_star
op_star
op_star
id|string
comma
r_int
id|string_max
)paren
(brace
r_int
id|i
suffix:semicolon
r_const
r_char
op_star
id|start
op_assign
l_int|NULL
suffix:semicolon
r_static
r_int
id|trace_line
op_assign
l_int|0
suffix:semicolon
r_static
id|regex_t
id|re_Oops_trace
suffix:semicolon
r_static
id|regmatch_t
op_star
id|re_Oops_trace_pmatch
suffix:semicolon
r_static
r_const
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;Oops_trace&quot;
suffix:semicolon
multiline_comment|/* ppc is different, not a bracketed address, just an address */
multiline_comment|/* ARM is different, two bracketed addresses on each line */
multiline_comment|/* Oops &squot;Trace&squot; lines */
id|re_compile
c_func
(paren
op_amp
id|re_Oops_trace
comma
l_string|&quot;^(&quot;
multiline_comment|/*  1 */
l_string|&quot;(Call Trace: )&quot;
multiline_comment|/*  2 */
multiline_comment|/* alpha */
l_string|&quot;|(Trace: )&quot;
multiline_comment|/*  3 */
multiline_comment|/* various */
l_string|&quot;|(&quot;
id|BRACKETED_ADDRESS
l_string|&quot;)&quot;
multiline_comment|/* 4,5*/
multiline_comment|/* ppc */
l_string|&quot;|(Call backtrace:)&quot;
multiline_comment|/*  6 */
multiline_comment|/* ppc */
l_string|&quot;|(&quot;
id|UNBRACKETED_ADDRESS
l_string|&quot;)&quot;
multiline_comment|/* 7,8*/
multiline_comment|/* ARM */
l_string|&quot;|(Function entered at (&quot;
id|BRACKETED_ADDRESS
l_string|&quot;))&quot;
multiline_comment|/* 9,10,11 */
multiline_comment|/* sparc */
multiline_comment|/* sparc64 */
l_string|&quot;|(Caller&bslash;&bslash;[&quot;
id|UNBRACKETED_ADDRESS
l_string|&quot;&bslash;&bslash;])&quot;
multiline_comment|/*12,13*/
l_string|&quot;)&quot;
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
op_or
id|REG_ICASE
comma
op_amp
id|re_Oops_trace_pmatch
)paren
suffix:semicolon
id|i
op_assign
id|regexec
c_func
(paren
op_amp
id|re_Oops_trace
comma
id|line
comma
id|re_Oops_trace.re_nsub
op_plus
l_int|1
comma
id|re_Oops_trace_pmatch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s regexec %d&bslash;n&quot;
comma
id|procname
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
DECL|macro|MATCHED
macro_line|#undef MATCHED
DECL|macro|MATCHED
mdefine_line|#define MATCHED(n) (re_Oops_trace_pmatch[n].rm_so != -1)
r_if
c_cond
(paren
id|MATCHED
c_func
(paren
l_int|2
)paren
op_logical_or
id|MATCHED
c_func
(paren
l_int|3
)paren
)paren
(brace
id|trace_line
op_assign
l_int|1
suffix:semicolon
id|start
op_assign
id|line
op_plus
id|re_Oops_trace_pmatch
(braket
l_int|0
)braket
dot
id|rm_eo
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|MATCHED
c_func
(paren
l_int|6
)paren
)paren
(brace
id|trace_line
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* ppc */
id|start
op_assign
id|line
op_plus
id|re_Oops_trace_pmatch
(braket
l_int|0
)braket
dot
id|rm_eo
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|trace_line
op_eq
l_int|1
op_logical_and
id|MATCHED
c_func
(paren
l_int|5
)paren
)paren
id|start
op_assign
id|line
op_plus
id|re_Oops_trace_pmatch
(braket
l_int|5
)braket
dot
id|rm_so
suffix:semicolon
r_else
r_if
c_cond
(paren
id|trace_line
op_eq
l_int|2
op_logical_and
id|MATCHED
c_func
(paren
l_int|8
)paren
)paren
multiline_comment|/* ppc */
id|start
op_assign
id|line
op_plus
id|re_Oops_trace_pmatch
(braket
l_int|8
)braket
dot
id|rm_so
suffix:semicolon
r_else
r_if
c_cond
(paren
id|MATCHED
c_func
(paren
l_int|10
)paren
)paren
(brace
id|trace_line
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* ARM */
id|start
op_assign
id|line
op_plus
id|re_Oops_trace_pmatch
(braket
l_int|10
)braket
dot
id|rm_so
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|MATCHED
c_func
(paren
l_int|12
)paren
)paren
(brace
id|trace_line
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* sparc, sparc64 */
id|start
op_assign
id|line
op_plus
id|re_Oops_trace_pmatch
(braket
l_int|13
)braket
dot
id|rm_so
suffix:semicolon
r_return
id|start
suffix:semicolon
)brace
r_else
id|trace_line
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|trace_line
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|trace_line
)paren
r_return
id|start
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Process a trace call line, extract addresses */
DECL|function|Oops_trace_line
r_static
r_void
id|Oops_trace_line
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_const
r_char
op_star
id|p
comma
id|SYMBOL_SET
op_star
id|ss
)paren
(brace
r_char
op_star
op_star
id|string
op_assign
l_int|NULL
suffix:semicolon
id|regex_t
op_star
id|pregex
suffix:semicolon
id|regmatch_t
op_star
id|pregmatch
suffix:semicolon
r_static
r_const
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;Oops_trace_line&quot;
suffix:semicolon
multiline_comment|/* ppc does not bracket its addresses */
r_if
c_cond
(paren
id|isxdigit
c_func
(paren
op_star
id|p
)paren
)paren
(brace
id|pregex
op_assign
op_amp
id|re_unbracketed_address
suffix:semicolon
id|pregmatch
op_assign
id|re_unbracketed_address_pmatch
suffix:semicolon
)brace
r_else
(brace
id|pregex
op_assign
op_amp
id|re_bracketed_address
suffix:semicolon
id|pregmatch
op_assign
id|re_bracketed_address_pmatch
suffix:semicolon
)brace
multiline_comment|/* Loop over [un]?bracketed addresses */
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|regexec
c_func
(paren
id|pregex
comma
id|p
comma
id|pregex-&gt;re_nsub
op_plus
l_int|1
comma
id|pregmatch
comma
l_int|0
)paren
op_eq
l_int|0
)paren
(brace
id|re_strings
c_func
(paren
id|pregex
comma
id|p
comma
id|pregmatch
comma
op_amp
id|string
)paren
suffix:semicolon
id|add_symbol
c_func
(paren
id|ss
comma
id|string
(braket
l_int|1
)braket
comma
l_char|&squot;T&squot;
comma
l_int|1
comma
l_string|&quot;Trace:&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|pregmatch
(braket
l_int|0
)braket
dot
id|rm_eo
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|p
comma
l_string|&quot;from &quot;
comma
l_int|5
)paren
op_eq
l_int|0
)paren
id|p
op_add_assign
l_int|5
suffix:semicolon
multiline_comment|/* ARM does &quot;address from address&quot; */
r_else
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|p
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;...&quot;
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Warning garbage &squot;%s&squot; at end of trace line ignored &quot;
l_string|&quot;by %s&bslash;n&quot;
comma
id|p
comma
id|procname
)paren
suffix:semicolon
op_increment
id|warnings
suffix:semicolon
)brace
id|re_strings_free
c_func
(paren
id|pregex
comma
op_amp
id|string
)paren
suffix:semicolon
)brace
multiline_comment|/* Do pattern matching to decide if the line should be printed.  When reading a&n; * syslog containing multiple Oops, you need the intermediate data (registers,&n; * tss etc.) to go with the decoded text.  Sets text to the start of the useful&n; * text, after any prefix.  Note that any leading white space is treated as part&n; * of the prefix, later routines do not see any indentation.&n; *&n; * Note: If a line is not printed, it will not be scanned for any other text.&n; */
DECL|function|Oops_print
r_static
r_int
id|Oops_print
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_const
r_char
op_star
op_star
id|text
comma
r_char
op_star
op_star
op_star
id|string
comma
r_int
id|string_max
)paren
(brace
r_int
id|i
comma
id|print
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|stack_line
op_assign
l_int|0
comma
id|trace_line
op_assign
l_int|0
suffix:semicolon
r_static
id|regex_t
id|re_Oops_prefix
suffix:semicolon
r_static
id|regmatch_t
op_star
id|re_Oops_prefix_pmatch
suffix:semicolon
r_static
id|regex_t
id|re_Oops_print_s
suffix:semicolon
r_static
id|regmatch_t
op_star
id|re_Oops_print_s_pmatch
suffix:semicolon
r_static
id|regex_t
id|re_Oops_print_a
suffix:semicolon
r_static
id|regmatch_t
op_star
id|re_Oops_print_a_pmatch
suffix:semicolon
r_static
r_const
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;Oops_print&quot;
suffix:semicolon
op_star
id|text
op_assign
id|line
suffix:semicolon
multiline_comment|/* Lines to be ignored.  For some reason the &quot;amuse the user&quot; print in&n;&t; * some die_if_kernel routines causes regexec to run very slowly.&n;&t; */
r_if
c_cond
(paren
id|strstr
c_func
(paren
op_star
id|text
comma
l_string|&quot;&bslash;&bslash;|/ ____ &bslash;&bslash;|/&quot;
)paren
op_logical_or
id|strstr
c_func
(paren
op_star
id|text
comma
l_string|&quot;&bslash;&quot;@&squot;/ ,. &bslash;&bslash;`@&bslash;&quot;&quot;
)paren
op_logical_or
id|strstr
c_func
(paren
op_star
id|text
comma
l_string|&quot;/_| &bslash;&bslash;__/ |_&bslash;&bslash;&quot;
)paren
op_logical_or
id|strstr
c_func
(paren
op_star
id|text
comma
l_string|&quot;   &bslash;&bslash;__U_/&quot;
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* print but avoid regexec */
multiline_comment|/* Prefixes to be ignored */
id|re_compile
c_func
(paren
op_amp
id|re_Oops_prefix
comma
l_string|&quot;^(&quot;
multiline_comment|/* start of line */
l_string|&quot;([^ ]{3} [ 0-9][0-9] [0-9]{2}:[0-9]{2}:[0-9]{2} &quot;
l_string|&quot;[^ ]+ kernel: +)&quot;
multiline_comment|/* syslogd */
l_string|&quot;|(&lt;[0-9]+&gt;)&quot;
multiline_comment|/* kmsg */
l_string|&quot;|([ &bslash;t]+)&quot;
multiline_comment|/* leading white space */
l_string|&quot;)+&quot;
multiline_comment|/* any prefixes, in any order */
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
op_or
id|REG_ICASE
comma
op_amp
id|re_Oops_prefix_pmatch
)paren
suffix:semicolon
id|i
op_assign
id|regexec
c_func
(paren
op_amp
id|re_Oops_prefix
comma
op_star
id|text
comma
id|re_Oops_prefix.re_nsub
op_plus
l_int|1
comma
id|re_Oops_prefix_pmatch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s regexec prefix %d&bslash;n&quot;
comma
id|procname
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
op_star
id|text
op_add_assign
id|re_Oops_prefix_pmatch
(braket
l_int|0
)braket
dot
id|rm_eo
suffix:semicolon
multiline_comment|/* step over prefix */
multiline_comment|/* Lots of possibilities.  Expand as required for all architectures.&n;&t; *&n;&t; * Trial and error shows that regex does not like a lot of sub patterns&n;&t; * that start with &quot;^&quot;.  So split the patterns into two groups, one set&n;&t; * must appear at the start of the line, the other set can appear&n;&t; * anywhere.&n;&t; */
multiline_comment|/* These patterns must appear at the start of the line, after stripping&n;&t; * the prefix above.&n;&t; *&n;&t; * The order below is required to handle multiline outupt.&n;&t; * string 2 is defined if the text is &squot;Stack from &squot;.&n;&t; * string 3 is defined if the text is &squot;Stack: &squot;.&n;&t; * string 4 is defined if the text might be a stack continuation.&n;&t; * string 5 is defined if the text is &squot;Call Trace: &squot;.&n;&t; * string 6 is defined if the text might be a trace continuation.&n;&t; * string 7 is the address part of the BRACKETED_ADDRESS.&n;&t; *&n;&t; * string 8 is defined if the text contains a version number.  No Oops&n;&t; * report contains this as of 2.1.125 but IMHO it should be added.  If&n;&t; * anybody wants to print a VERSION_nnnn line in their Oops, this code&n;&t; * is ready.&n;&t; *&n;&t; * string 9 is defined if the text is &squot;Trace: &squot; (alpha).&n;&t; * string 10 is defined if the text is &squot;Call backtrace:&squot; (ppc).&n;&t; */
id|re_compile
c_func
(paren
op_amp
id|re_Oops_print_s
comma
multiline_comment|/* arch type */
multiline_comment|/* Required order */
l_string|&quot;^(&quot;
multiline_comment|/*  1 */
multiline_comment|/* i386 */
l_string|&quot;(Stack: )&quot;
multiline_comment|/*  2 */
multiline_comment|/* m68k */
l_string|&quot;|(Stack from )&quot;
multiline_comment|/*  3 */
multiline_comment|/* various */
l_string|&quot;|([0-9a-fA-F]{4,})&quot;
multiline_comment|/*  4 */
multiline_comment|/* various */
l_string|&quot;|(Call Trace: )&quot;
multiline_comment|/*  5 */
multiline_comment|/* various */
l_string|&quot;|(&quot;
id|BRACKETED_ADDRESS
l_string|&quot;)&quot;
multiline_comment|/* 6,7*/
multiline_comment|/* various */
l_string|&quot;|(Version_[0-9]+)&quot;
multiline_comment|/*  8 */
multiline_comment|/* alpha */
l_string|&quot;|(Trace: )&quot;
multiline_comment|/*  9 */
multiline_comment|/* ppc */
l_string|&quot;|(Call backtrace:)&quot;
multiline_comment|/* 10 */
multiline_comment|/* order does not matter from here on */
multiline_comment|/* various */
l_string|&quot;|(Process .*stackpage=)&quot;
multiline_comment|/* various */
l_string|&quot;|(Call Trace:[ &bslash;t])&quot;
multiline_comment|/* various */
l_string|&quot;|(Code *:[ &bslash;t])&quot;
multiline_comment|/* various */
l_string|&quot;|(Kernel panic)&quot;
multiline_comment|/* various */
l_string|&quot;|(In swapper task)&quot;
multiline_comment|/* i386 2.0 */
l_string|&quot;|(Corrupted stack page)&quot;
multiline_comment|/* i386 */
l_string|&quot;|(invalid operand: )&quot;
multiline_comment|/* i386 */
l_string|&quot;|(Oops: )&quot;
multiline_comment|/* i386 */
l_string|&quot;|(Cpu: +[0-9])&quot;
multiline_comment|/* i386 */
l_string|&quot;|(current-&gt;tss)&quot;
multiline_comment|/* i386 */
l_string|&quot;|(&bslash;&bslash;*pde +=)&quot;
multiline_comment|/* i386 */
l_string|&quot;|(EIP: )&quot;
multiline_comment|/* i386 */
l_string|&quot;|(EFLAGS: )&quot;
multiline_comment|/* i386 */
l_string|&quot;|(eax: )&quot;
multiline_comment|/* i386 */
l_string|&quot;|(esi: )&quot;
multiline_comment|/* i386 */
l_string|&quot;|(ds: )&quot;
multiline_comment|/* m68k */
l_string|&quot;|(pc[:=])&quot;
multiline_comment|/* m68k */
l_string|&quot;|(68060 access)&quot;
multiline_comment|/* m68k */
l_string|&quot;|(Exception at )&quot;
multiline_comment|/* m68k */
l_string|&quot;|(d[04]: )&quot;
multiline_comment|/* m68k */
l_string|&quot;|(Frame format=)&quot;
multiline_comment|/* m68k */
l_string|&quot;|(wb [0-9] stat)&quot;
multiline_comment|/* m68k */
l_string|&quot;|(push data: )&quot;
multiline_comment|/* m68k */
l_string|&quot;|(baddr=)&quot;
multiline_comment|/* any other m68K lines to print? */
multiline_comment|/* alpha */
l_string|&quot;|(Bad unaligned kernel)&quot;
multiline_comment|/* alpha */
l_string|&quot;|(Forwarding unaligned exception)&quot;
multiline_comment|/* alpha */
l_string|&quot;|(: unhandled unaligned exception)&quot;
multiline_comment|/* alpha */
l_string|&quot;|(&lt;sc)&quot;
multiline_comment|/* alpha */
l_string|&quot;|(pc *=)&quot;
multiline_comment|/* alpha */
l_string|&quot;|(r[0-9]+ *=)&quot;
multiline_comment|/* alpha */
l_string|&quot;|(gp *=)&quot;
multiline_comment|/* any other alpha lines to print? */
multiline_comment|/* sparc */
l_string|&quot;|(tsk-&gt;)&quot;
multiline_comment|/* sparc */
l_string|&quot;|(PSR: )&quot;
multiline_comment|/* sparc */
l_string|&quot;|([goli][04]: )&quot;
multiline_comment|/* sparc */
l_string|&quot;|(Instruction DUMP: )&quot;
multiline_comment|/* sparc */
l_string|&quot;|(Caller&bslash;&bslash;[)&quot;
multiline_comment|/* any other sparc lines to print? */
multiline_comment|/* sparc64 */
l_string|&quot;|(TSTATE: )&quot;
multiline_comment|/* any other sparc64 lines to print? */
multiline_comment|/* ppc */
l_string|&quot;|(MSR: )&quot;
multiline_comment|/* ppc */
l_string|&quot;|(TASK = )&quot;
multiline_comment|/* ppc */
l_string|&quot;|(last math )&quot;
multiline_comment|/* ppc */
l_string|&quot;|(GPR[0-9]+: )&quot;
multiline_comment|/* any other ppc lines to print? */
multiline_comment|/* MIPS */
l_string|&quot;|(&bslash;&bslash;$[0-9 ]+:)&quot;
multiline_comment|/* MIPS */
l_string|&quot;|(epc )&quot;
multiline_comment|/* MIPS */
l_string|&quot;|(Status:)&quot;
multiline_comment|/* MIPS */
l_string|&quot;|(Cause :)&quot;
multiline_comment|/* any other MIPS lines to print? */
multiline_comment|/* ARM */
l_string|&quot;|(Backtrace:)&quot;
multiline_comment|/* ARM */
l_string|&quot;|(Function entered at)&quot;
multiline_comment|/* ARM */
l_string|&quot;|(&bslash;&bslash;*pgd =)&quot;
multiline_comment|/* ARM */
l_string|&quot;|(Internal error)&quot;
multiline_comment|/* ARM */
l_string|&quot;|(pc :)&quot;
multiline_comment|/* ARM */
l_string|&quot;|(sp :)&quot;
multiline_comment|/* ARM */
l_string|&quot;|(r[0-9][0-9 ]:)&quot;
multiline_comment|/* ARM */
l_string|&quot;|(Flags:)&quot;
multiline_comment|/* ARM */
l_string|&quot;|(Control:)&quot;
multiline_comment|/* any other ARM lines to print? */
l_string|&quot;)&quot;
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
op_or
id|REG_ICASE
comma
op_amp
id|re_Oops_print_s_pmatch
)paren
suffix:semicolon
id|i
op_assign
id|regexec
c_func
(paren
op_amp
id|re_Oops_print_s
comma
op_star
id|text
comma
id|re_Oops_print_s.re_nsub
op_plus
l_int|1
comma
id|re_Oops_print_s_pmatch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s regexec start %d&bslash;n&quot;
comma
id|procname
comma
id|i
)paren
suffix:semicolon
id|print
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
DECL|macro|MATCHED
macro_line|#undef MATCHED
DECL|macro|MATCHED
mdefine_line|#define MATCHED(n) (re_Oops_print_s_pmatch[n].rm_so != -1)
id|print
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Handle multiline messages, messy */
r_if
c_cond
(paren
op_logical_neg
id|MATCHED
c_func
(paren
l_int|2
)paren
op_logical_and
op_logical_neg
id|MATCHED
c_func
(paren
l_int|3
)paren
op_logical_and
op_logical_neg
id|MATCHED
c_func
(paren
l_int|4
)paren
)paren
id|stack_line
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|MATCHED
c_func
(paren
l_int|2
)paren
op_logical_or
id|MATCHED
c_func
(paren
l_int|3
)paren
)paren
id|stack_line
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|stack_line
op_logical_and
op_logical_neg
id|MATCHED
c_func
(paren
l_int|4
)paren
)paren
(brace
id|print
op_assign
l_int|0
suffix:semicolon
id|stack_line
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|MATCHED
c_func
(paren
l_int|5
)paren
op_logical_and
op_logical_neg
id|MATCHED
c_func
(paren
l_int|6
)paren
op_logical_and
op_logical_neg
id|MATCHED
c_func
(paren
l_int|9
)paren
op_logical_and
op_logical_neg
id|MATCHED
c_func
(paren
l_int|10
)paren
)paren
id|trace_line
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|MATCHED
c_func
(paren
l_int|5
)paren
op_logical_or
id|MATCHED
c_func
(paren
l_int|9
)paren
op_logical_or
id|MATCHED
c_func
(paren
l_int|10
)paren
)paren
id|trace_line
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|stack_line
op_logical_and
op_logical_neg
id|MATCHED
c_func
(paren
l_int|6
)paren
)paren
(brace
id|print
op_assign
l_int|0
suffix:semicolon
id|trace_line
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* delay splitting into strings until we really them */
r_if
c_cond
(paren
id|MATCHED
c_func
(paren
l_int|8
)paren
)paren
(brace
id|re_string_check
c_func
(paren
id|re_Oops_print_s.re_nsub
op_plus
l_int|1
comma
id|string_max
comma
id|procname
)paren
suffix:semicolon
id|re_strings
c_func
(paren
op_amp
id|re_Oops_print_s
comma
op_star
id|text
comma
id|re_Oops_print_s_pmatch
comma
id|string
)paren
suffix:semicolon
id|add_Version
c_func
(paren
(paren
op_star
id|string
)paren
(braket
l_int|8
)braket
op_plus
l_int|8
comma
l_string|&quot;Oops&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* These patterns can appear anywhere in the line, after stripping&n;&t; * the prefix above.&n;&t; */
id|re_compile
c_func
(paren
op_amp
id|re_Oops_print_a
comma
multiline_comment|/* arch type */
multiline_comment|/* various */
l_string|&quot;(Unable to handle kernel)&quot;
multiline_comment|/* various */
l_string|&quot;|(Aiee)&quot;
multiline_comment|/* anywhere in text is a bad sign (TM) */
multiline_comment|/* various */
l_string|&quot;|(die_if_kernel)&quot;
multiline_comment|/* ditto */
multiline_comment|/* alpha */
l_string|&quot;|(&bslash;&bslash;([0-9]&bslash;&bslash;): Oops )&quot;
multiline_comment|/* alpha */
l_string|&quot;|(: memory violation)&quot;
multiline_comment|/* alpha */
l_string|&quot;|(: Exception at)&quot;
multiline_comment|/* alpha */
l_string|&quot;|(: Arithmetic fault)&quot;
multiline_comment|/* alpha */
l_string|&quot;|(: Instruction fault)&quot;
multiline_comment|/* alpha */
l_string|&quot;|(: arithmetic trap)&quot;
multiline_comment|/* alpha */
l_string|&quot;|(: unaligned trap)&quot;
multiline_comment|/* sparc      die_if_kernel has no fixed text, identify by (pid): text.&n;&t; *            Somebody has been playful with the texts.&n;&t; *&n;&t; *            Alas adding this next pattern increases run time by 15% on&n;&t; *            its own!  It would be considerably faster if sparc had&n;&t; *            consistent error texts.&n;&t; */
multiline_comment|/* sparc */
l_string|&quot;|(&quot;
l_string|&quot;&bslash;&bslash;([0-9]+&bslash;&bslash;): &quot;
l_string|&quot;(&quot;
l_string|&quot;(Whee)&quot;
l_string|&quot;|(Oops)&quot;
l_string|&quot;|(Kernel)&quot;
l_string|&quot;|(Penguin)&quot;
l_string|&quot;|(Too many Penguin)&quot;
l_string|&quot;|(BOGUS)&quot;
l_string|&quot;)&quot;
l_string|&quot;)&quot;
multiline_comment|/* ppc */
l_string|&quot;|(kernel pc )&quot;
multiline_comment|/* ppc */
l_string|&quot;|(trap at PC: )&quot;
multiline_comment|/* ppc */
l_string|&quot;|(bad area pc )&quot;
multiline_comment|/* ppc */
l_string|&quot;|(NIP: )&quot;
multiline_comment|/* MIPS */
l_string|&quot;|( ra *=)&quot;
l_string|&quot;)&quot;
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
op_or
id|REG_ICASE
comma
op_amp
id|re_Oops_print_a_pmatch
)paren
suffix:semicolon
id|i
op_assign
id|regexec
c_func
(paren
op_amp
id|re_Oops_print_a
comma
op_star
id|text
comma
id|re_Oops_print_a.re_nsub
op_plus
l_int|1
comma
id|re_Oops_print_a_pmatch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s regexec anywhere %d&bslash;n&quot;
comma
id|procname
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
id|print
op_assign
l_int|1
suffix:semicolon
r_return
id|print
suffix:semicolon
)brace
multiline_comment|/* Look for the Code: line.  Returns start of the code bytes. */
DECL|function|Oops_code
r_static
r_const
r_char
op_star
id|Oops_code
c_func
(paren
r_const
r_char
op_star
id|line
comma
r_char
op_star
op_star
op_star
id|string
comma
r_int
id|string_max
)paren
(brace
r_int
id|i
suffix:semicolon
r_static
id|regex_t
id|re_Oops_code
suffix:semicolon
r_static
id|regmatch_t
op_star
id|re_Oops_code_pmatch
suffix:semicolon
r_static
r_const
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;Oops_code&quot;
suffix:semicolon
multiline_comment|/* Oops &squot;Code: &squot; hopefully followed by at least one hex code.  sparc&n;&t; * brackets the PC in &squot;&lt;&squot; and &squot;&gt;&squot;.  ARM brackets the PC in &squot;(&squot; and &squot;)&squot;.&n;&t; */
id|re_compile
c_func
(paren
op_amp
id|re_Oops_code
comma
l_string|&quot;^(&quot;
multiline_comment|/*  1 */
multiline_comment|/* sparc */
l_string|&quot;(Instruction DUMP)&quot;
multiline_comment|/*  2 */
multiline_comment|/* various */
l_string|&quot;|(Code *)&quot;
multiline_comment|/*  3 */
l_string|&quot;)&quot;
l_string|&quot;:[ &bslash;t]+&quot;
l_string|&quot;(&quot;
multiline_comment|/*  4 */
l_string|&quot;(general protection.*)&quot;
l_string|&quot;|(&lt;[0-9]+&gt;)&quot;
l_string|&quot;|(([&lt;(]?[0-9a-fA-F]+[&gt;)]?[ &bslash;t]+)+[&lt;(]?[0-9a-fA-F]+[&gt;)]?)&quot;
l_string|&quot;)&quot;
l_string|&quot;(.*)$&quot;
multiline_comment|/* trailing garbage */
comma
id|REG_NEWLINE
op_or
id|REG_EXTENDED
op_or
id|REG_ICASE
comma
op_amp
id|re_Oops_code_pmatch
)paren
suffix:semicolon
id|i
op_assign
id|regexec
c_func
(paren
op_amp
id|re_Oops_code
comma
id|line
comma
id|re_Oops_code.re_nsub
op_plus
l_int|1
comma
id|re_Oops_code_pmatch
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|3
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s regexec %d&bslash;n&quot;
comma
id|procname
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|re_string_check
c_func
(paren
id|re_Oops_code.re_nsub
op_plus
l_int|1
comma
id|string_max
comma
id|procname
)paren
suffix:semicolon
id|re_strings
c_func
(paren
op_amp
id|re_Oops_code
comma
id|line
comma
id|re_Oops_code_pmatch
comma
id|string
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|string
)paren
(braket
id|re_Oops_code.re_nsub
)braket
op_logical_and
op_star
(paren
(paren
op_star
id|string
)paren
(braket
id|re_Oops_code.re_nsub
)braket
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Warning: trailing garbage ignored on Code: &quot;
l_string|&quot;line&bslash;n&quot;
l_string|&quot;  Text: &squot;%s&squot;&bslash;n&quot;
l_string|&quot;  Garbage: &squot;%s&squot;&bslash;n&quot;
comma
id|line
comma
(paren
op_star
id|string
)paren
(braket
id|re_Oops_code.re_nsub
)braket
)paren
suffix:semicolon
op_increment
id|warnings
suffix:semicolon
)brace
r_return
(paren
op_star
id|string
)paren
(braket
l_int|4
)braket
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/******************************************************************************/
multiline_comment|/*                      End architecture sensitive code                       */
multiline_comment|/******************************************************************************/
multiline_comment|/* Decode the Oops Code: via objdump*/
DECL|function|Oops_decode
r_static
r_void
id|Oops_decode
c_func
(paren
r_const
r_int
r_char
op_star
id|code_text
comma
id|elf_addr_t
id|eip
comma
id|SYMBOL_SET
op_star
id|ss
comma
r_char
op_star
op_star
op_star
id|string
comma
r_int
id|string_max
comma
r_int
id|code_bytes
)paren
(brace
id|FILE
op_star
id|f
suffix:semicolon
r_char
op_star
id|file
comma
op_star
id|line
op_assign
l_int|NULL
comma
id|code
(braket
id|CODE_SIZE
)braket
suffix:semicolon
r_int
id|size
op_assign
l_int|0
comma
id|adjust
suffix:semicolon
r_static
r_char
r_const
id|procname
(braket
)braket
op_assign
l_string|&quot;Oops_decode&quot;
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s&bslash;n&quot;
comma
id|procname
)paren
suffix:semicolon
multiline_comment|/* text to binary */
r_if
c_cond
(paren
op_logical_neg
id|Oops_code_values
c_func
(paren
id|code_text
comma
id|code
comma
op_amp
id|adjust
comma
id|string
comma
id|string_max
comma
id|code_bytes
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* binary to same format as ksymoops */
r_if
c_cond
(paren
op_logical_neg
(paren
id|file
op_assign
id|Oops_code_to_file
c_func
(paren
id|code
comma
id|CODE_SIZE
)paren
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* objdump the pseudo object */
r_if
c_cond
(paren
op_logical_neg
(paren
id|f
op_assign
id|Oops_objdump
c_func
(paren
id|file
)paren
)paren
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|fgets_local
c_func
(paren
op_amp
id|line
comma
op_amp
id|size
comma
id|f
comma
id|procname
)paren
)paren
(brace
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s - %s&bslash;n&quot;
comma
id|procname
comma
id|line
)paren
suffix:semicolon
id|Oops_decode_one
c_func
(paren
id|ss
comma
id|line
comma
id|eip
comma
id|adjust
)paren
suffix:semicolon
)brace
id|pclose_local
c_func
(paren
id|f
comma
id|procname
)paren
suffix:semicolon
multiline_comment|/* opened in Oops_objdump */
id|free
c_func
(paren
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unlink
c_func
(paren
id|file
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s could not unlink %s&quot;
comma
id|prefix
comma
id|file
)paren
suffix:semicolon
id|perror
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Reached the end of an Oops report, format the extracted data. */
DECL|function|Oops_format
r_static
r_void
id|Oops_format
c_func
(paren
r_const
id|SYMBOL_SET
op_star
id|ss_format
)paren
(brace
r_int
id|i
suffix:semicolon
id|SYMBOL
op_star
id|s
suffix:semicolon
r_static
r_const
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;Oops_format&quot;
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s&bslash;n&quot;
comma
id|procname
)paren
suffix:semicolon
id|compare_Version
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Oops might have a version one day */
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|s
op_assign
id|ss_format-&gt;symbol
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ss_format-&gt;used
suffix:semicolon
op_increment
id|i
comma
op_increment
id|s
)paren
(brace
multiline_comment|/* For type C data, print Code:, address, map, &quot;name&quot; (actually&n;&t;&t; * the text of an objdump line).  For other types print name,&n;&t;&t; * address, map.&n;&t;&t; */
r_if
c_cond
(paren
id|s-&gt;type
op_eq
l_char|&squot;C&squot;
)paren
id|printf
c_func
(paren
l_string|&quot;Code:  %s %-30s %s&bslash;n&quot;
comma
id|format_address
c_func
(paren
id|s-&gt;address
)paren
comma
id|map_address
c_func
(paren
op_amp
id|ss_merged
comma
id|s-&gt;address
)paren
comma
id|s-&gt;name
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;%s %s %s&bslash;n&quot;
comma
id|s-&gt;name
comma
id|format_address
c_func
(paren
id|s-&gt;address
)paren
comma
id|map_address
c_func
(paren
op_amp
id|ss_merged
comma
id|s-&gt;address
)paren
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Select next Oops input file */
DECL|function|Oops_next_file
r_static
id|FILE
op_star
id|Oops_next_file
c_func
(paren
r_int
op_star
id|filecount
comma
r_char
op_star
r_const
op_star
op_star
id|filename
)paren
(brace
r_static
id|FILE
op_star
id|f
op_assign
l_int|NULL
suffix:semicolon
r_static
r_const
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;Oops_next_file&quot;
suffix:semicolon
r_static
r_int
id|first_file
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|first_file
)paren
(brace
id|f
op_assign
id|stdin
suffix:semicolon
id|first_file
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|filecount
)paren
(brace
r_if
c_cond
(paren
id|f
)paren
id|fclose_local
c_func
(paren
id|f
comma
id|procname
)paren
suffix:semicolon
id|f
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|regular_file
c_func
(paren
op_star
op_star
id|filename
comma
id|procname
)paren
)paren
id|f
op_assign
id|fopen_local
c_func
(paren
op_star
op_star
id|filename
comma
l_string|&quot;r&quot;
comma
id|procname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
(brace
r_if
c_cond
(paren
id|debug
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: reading Oops report &quot;
l_string|&quot;from %s&bslash;n&quot;
comma
op_star
op_star
id|filename
)paren
suffix:semicolon
)brace
op_increment
op_star
id|filename
suffix:semicolon
op_decrement
op_star
id|filecount
suffix:semicolon
r_if
c_cond
(paren
id|f
)paren
r_return
id|f
suffix:semicolon
)brace
r_return
id|f
suffix:semicolon
)brace
multiline_comment|/* Read the Oops report */
DECL|macro|MAX_STRINGS
mdefine_line|#define MAX_STRINGS 300&t;/* Maximum strings in any Oops re */
DECL|function|Oops_read
r_int
id|Oops_read
c_func
(paren
r_int
id|filecount
comma
r_char
op_star
r_const
op_star
id|filename
comma
r_int
id|code_bytes
comma
r_int
id|one_shot
)paren
(brace
r_char
op_star
id|line
op_assign
l_int|NULL
comma
op_star
op_star
id|string
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|start
comma
op_star
id|text
suffix:semicolon
r_int
id|i
comma
id|size
op_assign
l_int|0
comma
id|lineno
op_assign
l_int|0
comma
id|lastprint
op_assign
l_int|0
comma
id|print
op_assign
l_int|0
suffix:semicolon
id|elf_addr_t
id|eip
op_assign
l_int|0
suffix:semicolon
r_int
id|sparc_regdump
op_assign
l_int|0
suffix:semicolon
id|FILE
op_star
id|f
suffix:semicolon
id|SYMBOL_SET
id|ss_format
suffix:semicolon
r_static
r_const
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;Oops_read&quot;
suffix:semicolon
id|ss_init
c_func
(paren
op_amp
id|ss_format
comma
l_string|&quot;Oops log data&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filecount
op_logical_and
id|isatty
c_func
(paren
l_int|0
)paren
)paren
id|printf
c_func
(paren
l_string|&quot;Reading Oops report from the terminal&bslash;n&quot;
)paren
suffix:semicolon
id|string
op_assign
id|malloc
c_func
(paren
id|MAX_STRINGS
op_star
r_sizeof
(paren
op_star
id|string
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|string
)paren
id|malloc_error
c_func
(paren
id|procname
)paren
suffix:semicolon
id|memset
c_func
(paren
id|string
comma
l_char|&squot;&bslash;0&squot;
comma
id|MAX_STRINGS
op_star
r_sizeof
(paren
op_star
id|string
)paren
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|f
op_assign
id|Oops_next_file
c_func
(paren
op_amp
id|filecount
comma
op_amp
id|filename
)paren
)paren
)paren
r_continue
suffix:semicolon
r_while
c_loop
(paren
id|fgets_local
c_func
(paren
op_amp
id|line
comma
op_amp
id|size
comma
id|f
comma
id|procname
)paren
)paren
(brace
r_if
c_cond
(paren
id|debug
OG
l_int|2
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s - %s&bslash;n&quot;
comma
id|procname
comma
id|line
)paren
suffix:semicolon
op_increment
id|lineno
suffix:semicolon
id|print
op_assign
id|Oops_print
c_func
(paren
id|line
comma
op_amp
id|text
comma
op_amp
id|string
comma
id|MAX_STRINGS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Oops_sparc_regdump
(paren
id|text
)paren
)paren
(brace
id|sparc_regdump
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|oops_arch
op_eq
id|OOPS_SPARC
op_logical_or
id|oops_arch
op_eq
id|OOPS_SPARC64
)paren
op_logical_and
id|sparc_regdump
op_logical_and
id|ss_format.used
)paren
(brace
id|Oops_format
c_func
(paren
op_amp
id|ss_format
)paren
suffix:semicolon
id|ss_free
c_func
(paren
op_amp
id|ss_format
)paren
suffix:semicolon
)brace
id|sparc_regdump
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|print
)paren
(brace
id|puts
c_func
(paren
id|line
)paren
suffix:semicolon
id|lastprint
op_assign
id|lineno
suffix:semicolon
r_if
c_cond
(paren
(paren
id|start
op_assign
id|Oops_eip
c_func
(paren
id|text
comma
op_amp
id|string
comma
id|MAX_STRINGS
)paren
)paren
)paren
id|Oops_set_eip
c_func
(paren
id|start
comma
op_amp
id|eip
comma
op_amp
id|ss_format
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|start
op_assign
id|Oops_ra
c_func
(paren
id|text
comma
op_amp
id|string
comma
id|MAX_STRINGS
)paren
)paren
)paren
id|Oops_set_ra
c_func
(paren
id|start
comma
op_amp
id|ss_format
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|start
op_assign
id|Oops_oi7
c_func
(paren
id|text
comma
op_amp
id|string
comma
id|MAX_STRINGS
)paren
)paren
)paren
id|Oops_set_oi7
c_func
(paren
id|start
comma
op_amp
id|string
comma
op_amp
id|ss_format
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|start
op_assign
id|Oops_trace
c_func
(paren
id|text
comma
op_amp
id|string
comma
id|MAX_STRINGS
)paren
)paren
)paren
id|Oops_trace_line
c_func
(paren
id|text
comma
id|start
comma
op_amp
id|ss_format
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|start
op_assign
id|Oops_code
c_func
(paren
id|text
comma
op_amp
id|string
comma
id|MAX_STRINGS
)paren
)paren
)paren
(brace
id|Oops_decode
c_func
(paren
id|start
comma
id|eip
comma
op_amp
id|ss_format
comma
op_amp
id|string
comma
id|MAX_STRINGS
comma
id|code_bytes
)paren
suffix:semicolon
id|Oops_format
c_func
(paren
op_amp
id|ss_format
)paren
suffix:semicolon
id|ss_free
c_func
(paren
op_amp
id|ss_format
)paren
suffix:semicolon
r_if
c_cond
(paren
id|one_shot
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* More than 5 (arbitrary) lines which were not printed&n;&t;&t;&t; * and there is some saved data, assume we missed the&n;&t;&t;&t; * Code: line.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ss_format.used
op_logical_and
id|lineno
OG
id|lastprint
op_plus
l_int|5
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Warning, Code line not seen, dumping &quot;
l_string|&quot;what data is available&bslash;n&quot;
)paren
suffix:semicolon
op_increment
id|warnings
suffix:semicolon
id|Oops_format
c_func
(paren
op_amp
id|ss_format
)paren
suffix:semicolon
id|ss_free
c_func
(paren
op_amp
id|ss_format
)paren
suffix:semicolon
r_if
c_cond
(paren
id|one_shot
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ss_format.used
)paren
(brace
r_if
c_cond
(paren
(paren
id|oops_arch
op_ne
id|OOPS_SPARC
op_logical_and
id|oops_arch
op_ne
id|OOPS_SPARC64
)paren
op_logical_or
op_logical_neg
id|sparc_regdump
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Warning, Code line not seen, dumping &quot;
l_string|&quot;what data is available&bslash;n&quot;
)paren
suffix:semicolon
op_increment
id|warnings
suffix:semicolon
)brace
id|Oops_format
c_func
(paren
op_amp
id|ss_format
)paren
suffix:semicolon
id|ss_free
c_func
(paren
op_amp
id|ss_format
)paren
suffix:semicolon
r_if
c_cond
(paren
id|one_shot
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|filecount
op_ne
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|string
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
id|free
c_func
(paren
id|string
(braket
id|i
)braket
)paren
suffix:semicolon
id|string
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|free
c_func
(paren
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
id|one_shot
)paren
r_return
l_int|3
suffix:semicolon
multiline_comment|/* one shot mode, end of input, no data */
r_return
l_int|0
suffix:semicolon
)brace
eof
