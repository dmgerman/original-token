multiline_comment|/*&n;&t;misc.c.&n;&n;&t;Miscellaneous routines for ksymoops.&n;&n;&t;Copyright Keith Owens &lt;kaos@ocs.com.au&gt;.&n;&t;Released under the GNU Public Licence, Version 2.&n;&n;&t;Tue Nov  3 02:31:01 EST 1998&n;&t;Version 0.6&n;&t;Convert from a.out to bfd, using same format as ksymoops.&n;&n;&t;Wed Oct 28 13:47:23 EST 1998&n;&t;Version 0.4&n;&t;Split into separate sources.&n; */
macro_line|#include &quot;ksymoops.h&quot;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;unistd.h&gt;
DECL|function|malloc_error
r_void
id|malloc_error
c_func
(paren
r_const
r_char
op_star
id|msg
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: fatal malloc error for %s&bslash;n&quot;
comma
id|prefix
comma
id|msg
)paren
suffix:semicolon
m_exit
(paren
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* Format an address with the correct number of leading zeroes */
DECL|function|format_address
r_const
r_char
op_star
id|format_address
c_func
(paren
id|elf_addr_t
id|address
)paren
(brace
multiline_comment|/* Well oversized */
r_static
r_char
id|format
(braket
l_int|10
)braket
comma
id|text
(braket
l_int|200
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|format
)paren
id|snprintf
c_func
(paren
id|format
comma
r_sizeof
(paren
id|format
)paren
comma
l_string|&quot;%%0%dlx&quot;
comma
l_int|2
op_star
r_sizeof
(paren
id|address
)paren
)paren
suffix:semicolon
id|snprintf
c_func
(paren
id|text
comma
r_sizeof
(paren
id|text
)paren
comma
id|format
comma
id|address
)paren
suffix:semicolon
r_return
id|text
suffix:semicolon
)brace
multiline_comment|/* Find the full pathname of a program.  Code heavily based on&n; * glibc-2.0.5/posix/execvp.c.&n; */
DECL|function|find_fullpath
r_char
op_star
id|find_fullpath
c_func
(paren
r_const
r_char
op_star
id|program
)paren
(brace
r_char
op_star
id|fullpath
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|path
comma
op_star
id|p
suffix:semicolon
r_int
id|len
suffix:semicolon
r_static
r_const
r_char
id|procname
(braket
)braket
op_assign
l_string|&quot;find_fullpath&quot;
suffix:semicolon
multiline_comment|/* Don&squot;t search when it contains a slash.  */
r_if
c_cond
(paren
id|strchr
c_func
(paren
id|program
comma
l_char|&squot;/&squot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|fullpath
op_assign
id|strdup
c_func
(paren
id|program
)paren
)paren
)paren
id|malloc_error
c_func
(paren
id|procname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s %s&bslash;n&quot;
comma
id|procname
comma
id|fullpath
)paren
suffix:semicolon
r_return
id|fullpath
suffix:semicolon
)brace
id|path
op_assign
id|getenv
(paren
l_string|&quot;PATH&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|path
)paren
(brace
multiline_comment|/* There is no `PATH&squot; in the environment.  The default search&n;&t;&t;   path is the current directory followed by the path `confstr&squot;&n;&t;&t;   returns for `_CS_PATH&squot;.&n;&t;&t; */
id|len
op_assign
id|confstr
c_func
(paren
id|_CS_PATH
comma
(paren
r_char
op_star
)paren
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|path
op_assign
id|malloc
c_func
(paren
l_int|1
op_plus
id|len
)paren
)paren
)paren
id|malloc_error
c_func
(paren
id|procname
)paren
suffix:semicolon
id|path
(braket
l_int|0
)braket
op_assign
l_char|&squot;:&squot;
suffix:semicolon
id|confstr
c_func
(paren
id|_CS_PATH
comma
id|path
op_plus
l_int|1
comma
id|len
)paren
suffix:semicolon
)brace
id|len
op_assign
id|strlen
c_func
(paren
id|program
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|fullpath
op_assign
id|malloc
c_func
(paren
id|strlen
c_func
(paren
id|path
)paren
op_plus
id|len
)paren
)paren
)paren
id|malloc_error
c_func
(paren
id|procname
)paren
suffix:semicolon
id|p
op_assign
id|path
suffix:semicolon
r_do
(brace
id|path
op_assign
id|p
suffix:semicolon
id|p
op_assign
id|strchr
c_func
(paren
id|path
comma
l_char|&squot;:&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
id|p
op_assign
id|strchr
c_func
(paren
id|path
comma
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
multiline_comment|/* Two adjacent colons, or a colon at the beginning or the end&n;&t;&t; * of `PATH&squot; means to search the current directory.&n;&t;&t; */
r_if
c_cond
(paren
id|p
op_eq
id|path
)paren
id|memcpy
c_func
(paren
id|fullpath
comma
id|program
comma
id|len
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* Construct the pathname to try.  */
id|memcpy
c_func
(paren
id|fullpath
comma
id|path
comma
id|p
op_minus
id|path
)paren
suffix:semicolon
id|fullpath
(braket
id|p
op_minus
id|path
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|fullpath
(braket
(paren
id|p
op_minus
id|path
)paren
op_plus
l_int|1
)braket
comma
id|program
comma
id|len
)paren
suffix:semicolon
)brace
multiline_comment|/* If we have execute access, assume this is the program. */
r_if
c_cond
(paren
id|access
c_func
(paren
id|fullpath
comma
id|X_OK
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|debug
OG
l_int|1
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;DEBUG: %s %s&bslash;n&quot;
comma
id|procname
comma
id|fullpath
)paren
suffix:semicolon
r_return
id|fullpath
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_star
id|p
op_increment
op_ne
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Error: %s %s could not find executable %s&bslash;n&quot;
comma
id|prefix
comma
id|procname
comma
id|program
)paren
suffix:semicolon
op_increment
id|errors
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
eof
