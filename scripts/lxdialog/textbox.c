multiline_comment|/*&n; *  textbox.c -- implements the text box&n; *&n; *  ORIGINAL AUTHOR: Savio Lam (lam836@cs.cuhk.hk)&n; *  MODIFIED FOR LINUX KERNEL CONFIG BY: William Roadcap (roadcap@cfw.com)&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version 2&n; *  of the License, or (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &quot;dialog.h&quot;
r_static
r_void
id|back_lines
(paren
r_int
id|n
)paren
suffix:semicolon
r_static
r_void
id|print_page
(paren
id|WINDOW
op_star
id|win
comma
r_int
id|height
comma
r_int
id|width
)paren
suffix:semicolon
r_static
r_void
id|print_line
(paren
id|WINDOW
op_star
id|win
comma
r_int
id|row
comma
r_int
id|width
)paren
suffix:semicolon
r_static
r_char
op_star
id|get_line
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|print_position
(paren
id|WINDOW
op_star
id|win
comma
r_int
id|height
comma
r_int
id|width
)paren
suffix:semicolon
DECL|variable|hscroll
DECL|variable|fd
DECL|variable|file_size
DECL|variable|bytes_read
r_static
r_int
id|hscroll
op_assign
l_int|0
comma
id|fd
comma
id|file_size
comma
id|bytes_read
suffix:semicolon
DECL|variable|begin_reached
DECL|variable|end_reached
DECL|variable|page_length
r_static
r_int
id|begin_reached
op_assign
l_int|1
comma
id|end_reached
op_assign
l_int|0
comma
id|page_length
suffix:semicolon
DECL|variable|buf
DECL|variable|page
r_static
r_char
op_star
id|buf
comma
op_star
id|page
suffix:semicolon
multiline_comment|/*&n; * Display text from a file in a dialog box.&n; */
r_int
DECL|function|dialog_textbox
id|dialog_textbox
(paren
r_const
r_char
op_star
id|title
comma
r_const
r_char
op_star
id|file
comma
r_int
id|height
comma
r_int
id|width
)paren
(brace
r_int
id|i
comma
id|x
comma
id|y
comma
id|cur_x
comma
id|cur_y
comma
id|fpos
comma
id|key
op_assign
l_int|0
suffix:semicolon
r_int
id|passed_end
suffix:semicolon
r_char
id|search_term
(braket
id|MAX_LEN
op_plus
l_int|1
)braket
suffix:semicolon
id|WINDOW
op_star
id|dialog
comma
op_star
id|text
suffix:semicolon
id|search_term
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* no search term entered yet */
multiline_comment|/* Open input file for reading */
r_if
c_cond
(paren
(paren
id|fd
op_assign
id|open
(paren
id|file
comma
id|O_RDONLY
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nCan&squot;t open input file in dialog_textbox().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Get file size. Actually, &squot;file_size&squot; is the real file size - 1,&n;       since it&squot;s only the last byte offset from the beginning */
r_if
c_cond
(paren
(paren
id|file_size
op_assign
id|lseek
(paren
id|fd
comma
l_int|0
comma
id|SEEK_END
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError getting file size in dialog_textbox().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Restore file pointer to beginning of file after getting file size */
r_if
c_cond
(paren
id|lseek
(paren
id|fd
comma
l_int|0
comma
id|SEEK_SET
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError moving file pointer in dialog_textbox().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Allocate space for read buffer */
r_if
c_cond
(paren
(paren
id|buf
op_assign
id|malloc
(paren
id|BUF_SIZE
op_plus
l_int|1
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nCan&squot;t allocate memory in dialog_textbox().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bytes_read
op_assign
id|read
(paren
id|fd
comma
id|buf
comma
id|BUF_SIZE
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError reading file in dialog_textbox().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|buf
(braket
id|bytes_read
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* mark end of valid data */
id|page
op_assign
id|buf
suffix:semicolon
multiline_comment|/* page is pointer to start of page to be displayed */
multiline_comment|/* center dialog box on screen */
id|x
op_assign
(paren
id|COLS
op_minus
id|width
)paren
op_div
l_int|2
suffix:semicolon
id|y
op_assign
(paren
id|LINES
op_minus
id|height
)paren
op_div
l_int|2
suffix:semicolon
id|draw_shadow
(paren
id|stdscr
comma
id|y
comma
id|x
comma
id|height
comma
id|width
)paren
suffix:semicolon
id|dialog
op_assign
id|newwin
(paren
id|height
comma
id|width
comma
id|y
comma
id|x
)paren
suffix:semicolon
id|keypad
(paren
id|dialog
comma
id|TRUE
)paren
suffix:semicolon
multiline_comment|/* Create window for text region, used for scrolling text */
id|text
op_assign
id|subwin
(paren
id|dialog
comma
id|height
op_minus
l_int|4
comma
id|width
op_minus
l_int|2
comma
id|y
op_plus
l_int|1
comma
id|x
op_plus
l_int|1
)paren
suffix:semicolon
id|wattrset
(paren
id|text
comma
id|dialog_attr
)paren
suffix:semicolon
id|wbkgdset
(paren
id|text
comma
id|dialog_attr
op_amp
id|A_COLOR
)paren
suffix:semicolon
id|keypad
(paren
id|text
comma
id|TRUE
)paren
suffix:semicolon
multiline_comment|/* register the new window, along with its borders */
id|draw_box
(paren
id|dialog
comma
l_int|0
comma
l_int|0
comma
id|height
comma
id|width
comma
id|dialog_attr
comma
id|border_attr
)paren
suffix:semicolon
id|wattrset
(paren
id|dialog
comma
id|border_attr
)paren
suffix:semicolon
id|mvwaddch
(paren
id|dialog
comma
id|height
op_minus
l_int|3
comma
l_int|0
comma
id|ACS_LTEE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|width
op_minus
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|waddch
(paren
id|dialog
comma
id|ACS_HLINE
)paren
suffix:semicolon
id|wattrset
(paren
id|dialog
comma
id|dialog_attr
)paren
suffix:semicolon
id|wbkgdset
(paren
id|dialog
comma
id|dialog_attr
op_amp
id|A_COLOR
)paren
suffix:semicolon
id|waddch
(paren
id|dialog
comma
id|ACS_RTEE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|title
op_ne
l_int|NULL
op_logical_and
id|strlen
c_func
(paren
id|title
)paren
op_ge
id|width
op_minus
l_int|2
)paren
(brace
multiline_comment|/* truncate long title -- mec */
r_char
op_star
id|title2
op_assign
id|malloc
c_func
(paren
id|width
op_minus
l_int|2
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|title2
comma
id|title
comma
id|width
op_minus
l_int|2
)paren
suffix:semicolon
id|title2
(braket
id|width
op_minus
l_int|2
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|title
op_assign
id|title2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|title
op_ne
l_int|NULL
)paren
(brace
id|wattrset
(paren
id|dialog
comma
id|title_attr
)paren
suffix:semicolon
id|mvwaddch
(paren
id|dialog
comma
l_int|0
comma
(paren
id|width
op_minus
id|strlen
c_func
(paren
id|title
)paren
)paren
op_div
l_int|2
op_minus
l_int|1
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|waddstr
(paren
id|dialog
comma
(paren
r_char
op_star
)paren
id|title
)paren
suffix:semicolon
id|waddch
(paren
id|dialog
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
id|print_button
(paren
id|dialog
comma
l_string|&quot; Exit &quot;
comma
id|height
op_minus
l_int|2
comma
id|width
op_div
l_int|2
op_minus
l_int|4
comma
id|TRUE
)paren
suffix:semicolon
id|wnoutrefresh
(paren
id|dialog
)paren
suffix:semicolon
id|getyx
(paren
id|dialog
comma
id|cur_y
comma
id|cur_x
)paren
suffix:semicolon
multiline_comment|/* Save cursor position */
multiline_comment|/* Print first page of text */
id|attr_clear
(paren
id|text
comma
id|height
op_minus
l_int|4
comma
id|width
op_minus
l_int|2
comma
id|dialog_attr
)paren
suffix:semicolon
id|print_page
(paren
id|text
comma
id|height
op_minus
l_int|4
comma
id|width
op_minus
l_int|2
)paren
suffix:semicolon
id|print_position
(paren
id|dialog
comma
id|height
comma
id|width
)paren
suffix:semicolon
id|wmove
(paren
id|dialog
comma
id|cur_y
comma
id|cur_x
)paren
suffix:semicolon
multiline_comment|/* Restore cursor position */
id|wrefresh
(paren
id|dialog
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|key
op_ne
id|ESC
)paren
op_logical_and
(paren
id|key
op_ne
l_char|&squot;&bslash;n&squot;
)paren
)paren
(brace
id|key
op_assign
id|wgetch
(paren
id|dialog
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|key
)paren
(brace
r_case
l_char|&squot;E&squot;
suffix:colon
multiline_comment|/* Exit */
r_case
l_char|&squot;e&squot;
suffix:colon
r_case
l_char|&squot;X&squot;
suffix:colon
r_case
l_char|&squot;x&squot;
suffix:colon
id|delwin
(paren
id|dialog
)paren
suffix:semicolon
id|free
(paren
id|buf
)paren
suffix:semicolon
id|close
(paren
id|fd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
l_char|&squot;g&squot;
suffix:colon
multiline_comment|/* First page */
r_case
id|KEY_HOME
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|begin_reached
)paren
(brace
id|begin_reached
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* First page not in buffer? */
r_if
c_cond
(paren
(paren
id|fpos
op_assign
id|lseek
(paren
id|fd
comma
l_int|0
comma
id|SEEK_CUR
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError moving file pointer in dialog_textbox().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fpos
OG
id|bytes_read
)paren
(brace
multiline_comment|/* Yes, we have to read it in */
r_if
c_cond
(paren
id|lseek
(paren
id|fd
comma
l_int|0
comma
id|SEEK_SET
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError moving file pointer in &quot;
l_string|&quot;dialog_textbox().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bytes_read
op_assign
id|read
(paren
id|fd
comma
id|buf
comma
id|BUF_SIZE
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError reading file in dialog_textbox().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|buf
(braket
id|bytes_read
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
id|page
op_assign
id|buf
suffix:semicolon
id|print_page
(paren
id|text
comma
id|height
op_minus
l_int|4
comma
id|width
op_minus
l_int|2
)paren
suffix:semicolon
id|print_position
(paren
id|dialog
comma
id|height
comma
id|width
)paren
suffix:semicolon
id|wmove
(paren
id|dialog
comma
id|cur_y
comma
id|cur_x
)paren
suffix:semicolon
multiline_comment|/* Restore cursor position */
id|wrefresh
(paren
id|dialog
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;G&squot;
suffix:colon
multiline_comment|/* Last page */
r_case
id|KEY_END
suffix:colon
id|end_reached
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Last page not in buffer? */
r_if
c_cond
(paren
(paren
id|fpos
op_assign
id|lseek
(paren
id|fd
comma
l_int|0
comma
id|SEEK_CUR
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError moving file pointer in dialog_textbox().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fpos
OL
id|file_size
)paren
(brace
multiline_comment|/* Yes, we have to read it in */
r_if
c_cond
(paren
id|lseek
(paren
id|fd
comma
op_minus
id|BUF_SIZE
comma
id|SEEK_END
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError moving file pointer in dialog_textbox().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bytes_read
op_assign
id|read
(paren
id|fd
comma
id|buf
comma
id|BUF_SIZE
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError reading file in dialog_textbox().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|buf
(braket
id|bytes_read
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
id|page
op_assign
id|buf
op_plus
id|bytes_read
suffix:semicolon
id|back_lines
(paren
id|height
op_minus
l_int|4
)paren
suffix:semicolon
id|print_page
(paren
id|text
comma
id|height
op_minus
l_int|4
comma
id|width
op_minus
l_int|2
)paren
suffix:semicolon
id|print_position
(paren
id|dialog
comma
id|height
comma
id|width
)paren
suffix:semicolon
id|wmove
(paren
id|dialog
comma
id|cur_y
comma
id|cur_x
)paren
suffix:semicolon
multiline_comment|/* Restore cursor position */
id|wrefresh
(paren
id|dialog
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;K&squot;
suffix:colon
multiline_comment|/* Previous line */
r_case
l_char|&squot;k&squot;
suffix:colon
r_case
id|KEY_UP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|begin_reached
)paren
(brace
id|back_lines
(paren
id|page_length
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t call print_page() here but use scrolling to ensure&n;&t;&t;   faster screen update. However, &squot;end_reached&squot; and&n;&t;&t;   &squot;page_length&squot; should still be updated, and &squot;page&squot; should&n;&t;&t;   point to start of next page. This is done by calling&n;&t;&t;   get_line() in the following &squot;for&squot; loop. */
id|scrollok
(paren
id|text
comma
id|TRUE
)paren
suffix:semicolon
id|wscrl
(paren
id|text
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Scroll text region down one line */
id|scrollok
(paren
id|text
comma
id|FALSE
)paren
suffix:semicolon
id|page_length
op_assign
l_int|0
suffix:semicolon
id|passed_end
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|height
op_minus
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
multiline_comment|/* print first line of page */
id|print_line
(paren
id|text
comma
l_int|0
comma
id|width
op_minus
l_int|2
)paren
suffix:semicolon
id|wnoutrefresh
(paren
id|text
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Called to update &squot;end_reached&squot; and &squot;page&squot; */
id|get_line
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|passed_end
)paren
id|page_length
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|end_reached
op_logical_and
op_logical_neg
id|passed_end
)paren
id|passed_end
op_assign
l_int|1
suffix:semicolon
)brace
id|print_position
(paren
id|dialog
comma
id|height
comma
id|width
)paren
suffix:semicolon
id|wmove
(paren
id|dialog
comma
id|cur_y
comma
id|cur_x
)paren
suffix:semicolon
multiline_comment|/* Restore cursor position */
id|wrefresh
(paren
id|dialog
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_char|&squot;B&squot;
suffix:colon
multiline_comment|/* Previous page */
r_case
l_char|&squot;b&squot;
suffix:colon
r_case
id|KEY_PPAGE
suffix:colon
r_if
c_cond
(paren
id|begin_reached
)paren
r_break
suffix:semicolon
id|back_lines
(paren
id|page_length
op_plus
id|height
op_minus
l_int|4
)paren
suffix:semicolon
id|print_page
(paren
id|text
comma
id|height
op_minus
l_int|4
comma
id|width
op_minus
l_int|2
)paren
suffix:semicolon
id|print_position
(paren
id|dialog
comma
id|height
comma
id|width
)paren
suffix:semicolon
id|wmove
(paren
id|dialog
comma
id|cur_y
comma
id|cur_x
)paren
suffix:semicolon
id|wrefresh
(paren
id|dialog
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;J&squot;
suffix:colon
multiline_comment|/* Next line */
r_case
l_char|&squot;j&squot;
suffix:colon
r_case
id|KEY_DOWN
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|end_reached
)paren
(brace
id|begin_reached
op_assign
l_int|0
suffix:semicolon
id|scrollok
(paren
id|text
comma
id|TRUE
)paren
suffix:semicolon
id|scroll
(paren
id|text
)paren
suffix:semicolon
multiline_comment|/* Scroll text region up one line */
id|scrollok
(paren
id|text
comma
id|FALSE
)paren
suffix:semicolon
id|print_line
(paren
id|text
comma
id|height
op_minus
l_int|5
comma
id|width
op_minus
l_int|2
)paren
suffix:semicolon
id|wnoutrefresh
(paren
id|text
)paren
suffix:semicolon
id|print_position
(paren
id|dialog
comma
id|height
comma
id|width
)paren
suffix:semicolon
id|wmove
(paren
id|dialog
comma
id|cur_y
comma
id|cur_x
)paren
suffix:semicolon
multiline_comment|/* Restore cursor position */
id|wrefresh
(paren
id|dialog
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|KEY_NPAGE
suffix:colon
multiline_comment|/* Next page */
r_case
l_char|&squot; &squot;
suffix:colon
r_if
c_cond
(paren
id|end_reached
)paren
r_break
suffix:semicolon
id|begin_reached
op_assign
l_int|0
suffix:semicolon
id|print_page
(paren
id|text
comma
id|height
op_minus
l_int|4
comma
id|width
op_minus
l_int|2
)paren
suffix:semicolon
id|print_position
(paren
id|dialog
comma
id|height
comma
id|width
)paren
suffix:semicolon
id|wmove
(paren
id|dialog
comma
id|cur_y
comma
id|cur_x
)paren
suffix:semicolon
id|wrefresh
(paren
id|dialog
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;0&squot;
suffix:colon
multiline_comment|/* Beginning of line */
r_case
l_char|&squot;H&squot;
suffix:colon
multiline_comment|/* Scroll left */
r_case
l_char|&squot;h&squot;
suffix:colon
r_case
id|KEY_LEFT
suffix:colon
r_if
c_cond
(paren
id|hscroll
op_le
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|key
op_eq
l_char|&squot;0&squot;
)paren
id|hscroll
op_assign
l_int|0
suffix:semicolon
r_else
id|hscroll
op_decrement
suffix:semicolon
multiline_comment|/* Reprint current page to scroll horizontally */
id|back_lines
(paren
id|page_length
)paren
suffix:semicolon
id|print_page
(paren
id|text
comma
id|height
op_minus
l_int|4
comma
id|width
op_minus
l_int|2
)paren
suffix:semicolon
id|wmove
(paren
id|dialog
comma
id|cur_y
comma
id|cur_x
)paren
suffix:semicolon
id|wrefresh
(paren
id|dialog
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;L&squot;
suffix:colon
multiline_comment|/* Scroll right */
r_case
l_char|&squot;l&squot;
suffix:colon
r_case
id|KEY_RIGHT
suffix:colon
r_if
c_cond
(paren
id|hscroll
op_ge
id|MAX_LEN
)paren
r_break
suffix:semicolon
id|hscroll
op_increment
suffix:semicolon
multiline_comment|/* Reprint current page to scroll horizontally */
id|back_lines
(paren
id|page_length
)paren
suffix:semicolon
id|print_page
(paren
id|text
comma
id|height
op_minus
l_int|4
comma
id|width
op_minus
l_int|2
)paren
suffix:semicolon
id|wmove
(paren
id|dialog
comma
id|cur_y
comma
id|cur_x
)paren
suffix:semicolon
id|wrefresh
(paren
id|dialog
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ESC
suffix:colon
r_break
suffix:semicolon
)brace
)brace
id|delwin
(paren
id|dialog
)paren
suffix:semicolon
id|free
(paren
id|buf
)paren
suffix:semicolon
id|close
(paren
id|fd
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* ESC pressed */
)brace
multiline_comment|/*&n; * Go back &squot;n&squot; lines in text file. Called by dialog_textbox().&n; * &squot;page&squot; will be updated to point to the desired line in &squot;buf&squot;.&n; */
r_static
r_void
DECL|function|back_lines
id|back_lines
(paren
r_int
id|n
)paren
(brace
r_int
id|i
comma
id|fpos
suffix:semicolon
id|begin_reached
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We have to distinguish between end_reached and !end_reached&n;       since at end of file, the line is not ended by a &squot;&bslash;n&squot;.&n;       The code inside &squot;if&squot; basically does a &squot;--page&squot; to move one&n;       character backward so as to skip &squot;&bslash;n&squot; of the previous line */
r_if
c_cond
(paren
op_logical_neg
id|end_reached
)paren
(brace
multiline_comment|/* Either beginning of buffer or beginning of file reached? */
r_if
c_cond
(paren
id|page
op_eq
id|buf
)paren
(brace
r_if
c_cond
(paren
(paren
id|fpos
op_assign
id|lseek
(paren
id|fd
comma
l_int|0
comma
id|SEEK_CUR
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError moving file pointer in &quot;
l_string|&quot;back_lines().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fpos
OG
id|bytes_read
)paren
(brace
multiline_comment|/* Not beginning of file yet */
multiline_comment|/* We&squot;ve reached beginning of buffer, but not beginning of&n;&t;&t;   file yet, so read previous part of file into buffer.&n;&t;&t;   Note that we only move backward for BUF_SIZE/2 bytes,&n;&t;&t;   but not BUF_SIZE bytes to avoid re-reading again in&n;&t;&t;   print_page() later */
multiline_comment|/* Really possible to move backward BUF_SIZE/2 bytes? */
r_if
c_cond
(paren
id|fpos
OL
id|BUF_SIZE
op_div
l_int|2
op_plus
id|bytes_read
)paren
(brace
multiline_comment|/* No, move less then */
r_if
c_cond
(paren
id|lseek
(paren
id|fd
comma
l_int|0
comma
id|SEEK_SET
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError moving file pointer in &quot;
l_string|&quot;back_lines().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|page
op_assign
id|buf
op_plus
id|fpos
op_minus
id|bytes_read
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Move backward BUF_SIZE/2 bytes */
r_if
c_cond
(paren
id|lseek
(paren
id|fd
comma
op_minus
(paren
id|BUF_SIZE
op_div
l_int|2
op_plus
id|bytes_read
)paren
comma
id|SEEK_CUR
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError moving file pointer &quot;
l_string|&quot;in back_lines().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|page
op_assign
id|buf
op_plus
id|BUF_SIZE
op_div
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bytes_read
op_assign
id|read
(paren
id|fd
comma
id|buf
comma
id|BUF_SIZE
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError reading file in back_lines().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|buf
(braket
id|bytes_read
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Beginning of file reached */
id|begin_reached
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_star
(paren
op_decrement
id|page
)paren
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
multiline_comment|/* &squot;--page&squot; here */
multiline_comment|/* Something&squot;s wrong... */
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nInternal error in back_lines().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Go back &squot;n&squot; lines */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
r_do
(brace
r_if
c_cond
(paren
id|page
op_eq
id|buf
)paren
(brace
r_if
c_cond
(paren
(paren
id|fpos
op_assign
id|lseek
(paren
id|fd
comma
l_int|0
comma
id|SEEK_CUR
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError moving file pointer in back_lines().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fpos
OG
id|bytes_read
)paren
(brace
multiline_comment|/* Really possible to move backward BUF_SIZE/2 bytes? */
r_if
c_cond
(paren
id|fpos
OL
id|BUF_SIZE
op_div
l_int|2
op_plus
id|bytes_read
)paren
(brace
multiline_comment|/* No, move less then */
r_if
c_cond
(paren
id|lseek
(paren
id|fd
comma
l_int|0
comma
id|SEEK_SET
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError moving file pointer &quot;
l_string|&quot;in back_lines().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|page
op_assign
id|buf
op_plus
id|fpos
op_minus
id|bytes_read
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Move backward BUF_SIZE/2 bytes */
r_if
c_cond
(paren
id|lseek
(paren
id|fd
comma
op_minus
(paren
id|BUF_SIZE
op_div
l_int|2
op_plus
id|bytes_read
)paren
comma
id|SEEK_CUR
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError moving file pointer&quot;
l_string|&quot; in back_lines().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|page
op_assign
id|buf
op_plus
id|BUF_SIZE
op_div
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bytes_read
op_assign
id|read
(paren
id|fd
comma
id|buf
comma
id|BUF_SIZE
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError reading file in &quot;
l_string|&quot;back_lines().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|buf
(braket
id|bytes_read
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Beginning of file reached */
id|begin_reached
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
op_star
(paren
op_decrement
id|page
)paren
op_ne
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|page
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Print a new page of text. Called by dialog_textbox().&n; */
r_static
r_void
DECL|function|print_page
id|print_page
(paren
id|WINDOW
op_star
id|win
comma
r_int
id|height
comma
r_int
id|width
)paren
(brace
r_int
id|i
comma
id|passed_end
op_assign
l_int|0
suffix:semicolon
id|page_length
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|height
suffix:semicolon
id|i
op_increment
)paren
(brace
id|print_line
(paren
id|win
comma
id|i
comma
id|width
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|passed_end
)paren
id|page_length
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|end_reached
op_logical_and
op_logical_neg
id|passed_end
)paren
id|passed_end
op_assign
l_int|1
suffix:semicolon
)brace
id|wnoutrefresh
(paren
id|win
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Print a new line of text. Called by dialog_textbox() and print_page().&n; */
r_static
r_void
DECL|function|print_line
id|print_line
(paren
id|WINDOW
op_star
id|win
comma
r_int
id|row
comma
r_int
id|width
)paren
(brace
r_int
id|y
comma
id|x
suffix:semicolon
r_char
op_star
id|line
suffix:semicolon
id|line
op_assign
id|get_line
(paren
)paren
suffix:semicolon
id|line
op_add_assign
id|MIN
(paren
id|strlen
(paren
id|line
)paren
comma
id|hscroll
)paren
suffix:semicolon
multiline_comment|/* Scroll horizontally */
id|wmove
(paren
id|win
comma
id|row
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* move cursor to correct line */
id|waddch
(paren
id|win
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|waddnstr
(paren
id|win
comma
id|line
comma
id|MIN
(paren
id|strlen
(paren
id|line
)paren
comma
id|width
op_minus
l_int|2
)paren
)paren
suffix:semicolon
id|getyx
(paren
id|win
comma
id|y
comma
id|x
)paren
suffix:semicolon
multiline_comment|/* Clear &squot;residue&squot; of previous line */
macro_line|#if OLD_NCURSES
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|width
op_minus
id|x
suffix:semicolon
id|i
op_increment
)paren
id|waddch
(paren
id|win
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
)brace
macro_line|#else
id|wclrtoeol
c_func
(paren
id|win
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Return current line of text. Called by dialog_textbox() and print_line().&n; * &squot;page&squot; should point to start of current line before calling, and will be&n; * updated to point to start of next line.&n; */
r_static
r_char
op_star
DECL|function|get_line
id|get_line
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|fpos
suffix:semicolon
r_static
r_char
id|line
(braket
id|MAX_LEN
op_plus
l_int|1
)braket
suffix:semicolon
id|end_reached
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|page
op_ne
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
op_star
id|page
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
multiline_comment|/* Either end of file or end of buffer reached */
r_if
c_cond
(paren
(paren
id|fpos
op_assign
id|lseek
(paren
id|fd
comma
l_int|0
comma
id|SEEK_CUR
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError moving file pointer in &quot;
l_string|&quot;get_line().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fpos
OL
id|file_size
)paren
(brace
multiline_comment|/* Not end of file yet */
multiline_comment|/* We&squot;ve reached end of buffer, but not end of file yet,&n;&t;&t;   so read next part of file into buffer */
r_if
c_cond
(paren
(paren
id|bytes_read
op_assign
id|read
(paren
id|fd
comma
id|buf
comma
id|BUF_SIZE
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError reading file in get_line().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|buf
(braket
id|bytes_read
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|page
op_assign
id|buf
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|end_reached
)paren
id|end_reached
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|i
OL
id|MAX_LEN
)paren
id|line
(braket
id|i
op_increment
)braket
op_assign
op_star
(paren
id|page
op_increment
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* Truncate lines longer than MAX_LEN characters */
r_if
c_cond
(paren
id|i
op_eq
id|MAX_LEN
)paren
id|line
(braket
id|i
op_increment
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|page
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_le
id|MAX_LEN
)paren
id|line
(braket
id|i
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|end_reached
)paren
id|page
op_increment
suffix:semicolon
multiline_comment|/* move pass &squot;&bslash;n&squot; */
r_return
id|line
suffix:semicolon
)brace
multiline_comment|/*&n; * Print current position&n; */
r_static
r_void
DECL|function|print_position
id|print_position
(paren
id|WINDOW
op_star
id|win
comma
r_int
id|height
comma
r_int
id|width
)paren
(brace
r_int
id|fpos
comma
id|percent
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fpos
op_assign
id|lseek
(paren
id|fd
comma
l_int|0
comma
id|SEEK_CUR
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|endwin
(paren
)paren
suffix:semicolon
id|fprintf
(paren
id|stderr
comma
l_string|&quot;&bslash;nError moving file pointer in print_position().&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|wattrset
(paren
id|win
comma
id|position_indicator_attr
)paren
suffix:semicolon
id|wbkgdset
(paren
id|win
comma
id|position_indicator_attr
op_amp
id|A_COLOR
)paren
suffix:semicolon
id|percent
op_assign
op_logical_neg
id|file_size
ques
c_cond
l_int|100
suffix:colon
(paren
(paren
id|fpos
op_minus
id|bytes_read
op_plus
id|page
op_minus
id|buf
)paren
op_star
l_int|100
)paren
op_div
id|file_size
suffix:semicolon
id|wmove
(paren
id|win
comma
id|height
op_minus
l_int|3
comma
id|width
op_minus
l_int|9
)paren
suffix:semicolon
id|wprintw
(paren
id|win
comma
l_string|&quot;(%3d%%)&quot;
comma
id|percent
)paren
suffix:semicolon
)brace
eof
