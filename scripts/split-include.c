multiline_comment|/*&n; * split-include.c&n; *&n; * Copyright abandoned, Michael Chastain, &lt;mailto:mec@shout.net&gt;.&n; * This is a C version of syncdep.pl by Werner Almesberger.&n; *&n; * This program takes autoconf.h as input and outputs a directory full&n; * of one-line include files, merging onto the old values.&n; *&n; * Think of the configuration options as key-value pairs.  Then there&n; * are five cases:&n; *&n; *    key      old value   new value   action&n; *&n; *    KEY-1    VALUE-1     VALUE-1     leave file alone&n; *    KEY-2    VALUE-2A    VALUE-2B    write VALUE-2B into file&n; *    KEY-3    -           VALUE-3     write VALUE-3  into file&n; *    KEY-4    VALUE-4     -           write an empty file&n; *    KEY-5    (empty)     -           leave old empty file alone&n; */
macro_line|#include &lt;sys/stat.h&gt;
macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;ctype.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;fcntl.h&gt;
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;unistd.h&gt;
DECL|macro|ERROR_EXIT
mdefine_line|#define ERROR_EXIT(strExit)&t;&t;&t;&t;&t;&t;&bslash;&n;    {&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;const int errnoSave = errno;&t;&t;&t;&t;&t;&bslash;&n;&t;fprintf(stderr, &quot;%s: &quot;, str_my_name);&t;&t;&t;&t;&bslash;&n;&t;errno = errnoSave;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;perror((strExit));&t;&t;&t;&t;&t;&t;&bslash;&n;&t;exit(1);&t;&t;&t;&t;&t;&t;&t;&bslash;&n;    }
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_const
r_char
op_star
id|argv
(braket
)braket
)paren
(brace
r_const
r_char
op_star
id|str_my_name
suffix:semicolon
r_const
r_char
op_star
id|str_file_autoconf
suffix:semicolon
r_const
r_char
op_star
id|str_dir_config
suffix:semicolon
id|FILE
op_star
id|fp_config
suffix:semicolon
id|FILE
op_star
id|fp_target
suffix:semicolon
id|FILE
op_star
id|fp_find
suffix:semicolon
r_int
id|buffer_size
suffix:semicolon
r_char
op_star
id|line
suffix:semicolon
r_char
op_star
id|old_line
suffix:semicolon
r_char
op_star
id|list_target
suffix:semicolon
r_char
op_star
id|ptarget
suffix:semicolon
r_struct
id|stat
id|stat_buf
suffix:semicolon
multiline_comment|/* Check arg count. */
r_if
c_cond
(paren
id|argc
op_ne
l_int|3
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: wrong number of arguments.&bslash;n&quot;
comma
id|argv
(braket
l_int|0
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|str_my_name
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
id|str_file_autoconf
op_assign
id|argv
(braket
l_int|1
)braket
suffix:semicolon
id|str_dir_config
op_assign
id|argv
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Find a buffer size. */
r_if
c_cond
(paren
id|stat
c_func
(paren
id|str_file_autoconf
comma
op_amp
id|stat_buf
)paren
op_ne
l_int|0
)paren
id|ERROR_EXIT
c_func
(paren
id|str_file_autoconf
)paren
suffix:semicolon
id|buffer_size
op_assign
l_int|2
op_star
id|stat_buf.st_size
op_plus
l_int|4096
suffix:semicolon
multiline_comment|/* Allocate buffers. */
r_if
c_cond
(paren
(paren
id|line
op_assign
id|malloc
c_func
(paren
id|buffer_size
)paren
)paren
op_eq
l_int|NULL
op_logical_or
(paren
id|old_line
op_assign
id|malloc
c_func
(paren
id|buffer_size
)paren
)paren
op_eq
l_int|NULL
op_logical_or
(paren
id|list_target
op_assign
id|malloc
c_func
(paren
id|buffer_size
)paren
)paren
op_eq
l_int|NULL
)paren
id|ERROR_EXIT
c_func
(paren
id|str_file_autoconf
)paren
suffix:semicolon
multiline_comment|/* Open autoconfig file. */
r_if
c_cond
(paren
(paren
id|fp_config
op_assign
id|fopen
c_func
(paren
id|str_file_autoconf
comma
l_string|&quot;r&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
id|ERROR_EXIT
c_func
(paren
id|str_file_autoconf
)paren
suffix:semicolon
multiline_comment|/* Make output directory if needed. */
r_if
c_cond
(paren
id|stat
c_func
(paren
id|str_dir_config
comma
op_amp
id|stat_buf
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|mkdir
c_func
(paren
id|str_dir_config
comma
l_int|0755
)paren
op_ne
l_int|0
)paren
id|ERROR_EXIT
c_func
(paren
id|str_dir_config
)paren
suffix:semicolon
)brace
multiline_comment|/* Change to output directory. */
r_if
c_cond
(paren
id|chdir
c_func
(paren
id|str_dir_config
)paren
op_ne
l_int|0
)paren
id|ERROR_EXIT
c_func
(paren
id|str_dir_config
)paren
suffix:semicolon
multiline_comment|/* Put initial separator into target list. */
id|ptarget
op_assign
id|list_target
suffix:semicolon
op_star
id|ptarget
op_increment
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
multiline_comment|/* Read config lines. */
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|line
comma
id|buffer_size
comma
id|fp_config
)paren
)paren
(brace
r_const
r_char
op_star
id|str_config
suffix:semicolon
r_int
id|is_same
suffix:semicolon
r_int
id|itarget
suffix:semicolon
r_if
c_cond
(paren
id|line
(braket
l_int|0
)braket
op_ne
l_char|&squot;#&squot;
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|str_config
op_assign
id|strstr
c_func
(paren
id|line
comma
l_string|&quot;CONFIG_&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
multiline_comment|/* Make the output file name. */
id|str_config
op_add_assign
r_sizeof
(paren
l_string|&quot;CONFIG_&quot;
)paren
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|itarget
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|isspace
c_func
(paren
id|str_config
(braket
id|itarget
)braket
)paren
suffix:semicolon
id|itarget
op_increment
)paren
(brace
r_char
id|c
op_assign
id|str_config
(braket
id|itarget
)braket
suffix:semicolon
r_if
c_cond
(paren
id|isupper
c_func
(paren
id|c
)paren
)paren
id|c
op_assign
id|tolower
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;_&squot;
)paren
id|c
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|ptarget
(braket
id|itarget
)braket
op_assign
id|c
suffix:semicolon
)brace
id|ptarget
(braket
id|itarget
op_increment
)braket
op_assign
l_char|&squot;.&squot;
suffix:semicolon
id|ptarget
(braket
id|itarget
op_increment
)braket
op_assign
l_char|&squot;h&squot;
suffix:semicolon
id|ptarget
(braket
id|itarget
op_increment
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* Check for existing file. */
id|is_same
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fp_target
op_assign
id|fopen
c_func
(paren
id|ptarget
comma
l_string|&quot;r&quot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|fgets
c_func
(paren
id|old_line
comma
id|buffer_size
comma
id|fp_target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fclose
c_func
(paren
id|fp_target
)paren
op_ne
l_int|0
)paren
id|ERROR_EXIT
c_func
(paren
id|ptarget
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|line
comma
id|old_line
)paren
)paren
id|is_same
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_same
)paren
(brace
multiline_comment|/* Auto-create directories. */
r_int
id|islash
suffix:semicolon
r_for
c_loop
(paren
id|islash
op_assign
l_int|0
suffix:semicolon
id|islash
OL
id|itarget
suffix:semicolon
id|islash
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ptarget
(braket
id|islash
)braket
op_eq
l_char|&squot;/&squot;
)paren
(brace
id|ptarget
(braket
id|islash
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|stat
c_func
(paren
id|ptarget
comma
op_amp
id|stat_buf
)paren
op_ne
l_int|0
op_logical_and
id|mkdir
c_func
(paren
id|ptarget
comma
l_int|0755
)paren
op_ne
l_int|0
)paren
id|ERROR_EXIT
c_func
(paren
id|ptarget
)paren
suffix:semicolon
id|ptarget
(braket
id|islash
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
)brace
)brace
multiline_comment|/* Write the file. */
r_if
c_cond
(paren
(paren
id|fp_target
op_assign
id|fopen
c_func
(paren
id|ptarget
comma
l_string|&quot;w&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
id|ERROR_EXIT
c_func
(paren
id|ptarget
)paren
suffix:semicolon
id|fputs
c_func
(paren
id|line
comma
id|fp_target
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ferror
c_func
(paren
id|fp_target
)paren
op_logical_or
id|fclose
c_func
(paren
id|fp_target
)paren
op_ne
l_int|0
)paren
id|ERROR_EXIT
c_func
(paren
id|ptarget
)paren
suffix:semicolon
)brace
multiline_comment|/* Update target list */
id|ptarget
op_add_assign
id|itarget
suffix:semicolon
op_star
(paren
id|ptarget
op_minus
l_int|1
)paren
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
)brace
multiline_comment|/*&n;     * Close autoconfig file.&n;     * Terminate the target list.&n;     */
r_if
c_cond
(paren
id|fclose
c_func
(paren
id|fp_config
)paren
op_ne
l_int|0
)paren
id|ERROR_EXIT
c_func
(paren
id|str_file_autoconf
)paren
suffix:semicolon
op_star
id|ptarget
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/*&n;     * Fix up existing files which have no new value.&n;     * This is Case 4 and Case 5.&n;     *&n;     * I re-read the tree and filter it against list_target.&n;     * This is crude.  But it avoids data copies.  Also, list_target&n;     * is compact and contiguous, so it easily fits into cache.&n;     *&n;     * Notice that list_target contains strings separated by &bslash;n,&n;     * with a &bslash;n before the first string and after the last.&n;     * fgets gives the incoming names a terminating &bslash;n.&n;     * So by having an initial &bslash;n, strstr will find exact matches.&n;     */
id|fp_find
op_assign
id|popen
c_func
(paren
l_string|&quot;find * -type f -print&quot;
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fp_find
op_eq
l_int|0
)paren
id|ERROR_EXIT
c_func
(paren
l_string|&quot;find&quot;
)paren
suffix:semicolon
id|line
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|line
op_plus
l_int|1
comma
id|buffer_size
comma
id|fp_find
)paren
)paren
(brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|list_target
comma
id|line
)paren
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;     * This is an old file with no CONFIG_* flag in autoconf.h.&n;&t;     */
multiline_comment|/* First strip the &bslash;n. */
id|line
(braket
id|strlen
c_func
(paren
id|line
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* Grab size. */
r_if
c_cond
(paren
id|stat
c_func
(paren
id|line
op_plus
l_int|1
comma
op_amp
id|stat_buf
)paren
op_ne
l_int|0
)paren
id|ERROR_EXIT
c_func
(paren
id|line
)paren
suffix:semicolon
multiline_comment|/* If file is not empty, make it empty and give it a fresh date. */
r_if
c_cond
(paren
id|stat_buf.st_size
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|fp_target
op_assign
id|fopen
c_func
(paren
id|line
op_plus
l_int|1
comma
l_string|&quot;w&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
id|ERROR_EXIT
c_func
(paren
id|line
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fclose
c_func
(paren
id|fp_target
)paren
op_ne
l_int|0
)paren
id|ERROR_EXIT
c_func
(paren
id|line
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|pclose
c_func
(paren
id|fp_find
)paren
op_ne
l_int|0
)paren
id|ERROR_EXIT
c_func
(paren
l_string|&quot;find&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
