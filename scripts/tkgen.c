multiline_comment|/* Generate tk script based upon config.in&n; *&n; * Version 1.0&n; * Eric Youngdale&n; * 10/95&n; *&n; * 1996 01 04&n; * Avery Pennarun - Aesthetic improvements.&n; *&n; * 1996 01 24&n; * Avery Pennarun - Bugfixes and more aesthetics.&n; *&n; * 1996 03 08&n; * Avery Pennarun - The int and hex config.in commands work right.&n; *                - Choice buttons are more user-friendly.&n; *                - Disabling a text entry line greys it out properly.&n; *                - dep_tristate now works like in Configure. (not pretty)&n; *                - No warnings in gcc -Wall. (Fixed some &quot;interesting&quot; bugs.)&n; *                - Faster/prettier &quot;Help&quot; lookups.&n; *&n; * 1996 03 15&n; * Avery Pennarun - Added new sed script from Axel Boldt to make help even&n; *                  faster. (Actually awk is downright slow on some machines.)&n; *                - Fixed a bug I introduced into Choice dependencies.  Thanks&n; *                  to Robert Krawitz for pointing this out.&n; *&n; * 1996 03 16&n; * Avery Pennarun - basic &quot;do_make&quot; support added to let sound config work.&n; *&n; * 1996 03 25&n; *     Axel Boldt - Help now works on &quot;choice&quot; buttons.&n; *&n; * 1996 04 06&n; * Avery Pennarun - Improved sound config stuff. (I think it actually works&n; *                  now!)&n; *                - Window-resize-limits don&squot;t use ugly /usr/lib/tk4.0 hack.&n; *                - int/hex work with tk3 again. (The &quot;cget&quot; error.)&n; *                - Next/Prev buttons switch between menus.  I can&squot;t take&n; *                  much credit for this; the code was already there, but&n; *                  ifdef&squot;d out for some reason.  It flickers a lot, but&n; *                  I suspect there&squot;s no &quot;easy&quot; fix for that.&n; *                - Labels no longer highlight as you move the mouse over&n; *                  them (although you can still press them... oh well.)&n; *                - Got rid of the last of the literal color settings, to&n; *                  help out people with mono X-Windows systems. &n; *                  (Apparently there still are some out there!)&n; *                - Tabstops seem sensible now.&n; *&n; * 1996 04 14&n; * Avery Pennarun - Reduced flicker when creating windows, even with &quot;update&n; *                  idletasks&quot; hack.&n; *&n; * 1997 12 08&n; * Michael Chastain - Remove sound driver special cases.&n; *&n; * 1997 11 15&n; * Michael Chastain - For choice buttons, write values for all options,&n; *                    not just the single chosen one.  This is compatible&n; *                    with &squot;make config&squot; and &squot;make oldconfig&squot;, and is&n; *                    needed so smart-config dependencies work if the&n; *                    user switches from one configuration method to&n; *                    another.&n; *&n; * 1998 03 09&n; * Axel Boldt - Smaller layout of main menu - it&squot;s still too big for 800x600.&n; *            - Display help in text window to allow for cut and paste.&n; *            - Allow for empty lines in help texts.&n; *            - update_define should not set all variables unconditionally to&n; *              0: they may have been set to 1 elsewhere. CONFIG_NETLINK is&n; *              an example.&n; *&n; * 1999 01 04&n; * Michael Elizabeth Chastain &lt;mec@shout.net&gt;&n; * - Call clear_globalflags when writing out update_mainmenu.&n; *   This fixes the missing global/vfix lines for ARCH=alpha on 2.2.0-pre4.&n; *&n; * 8 January 1999, Michael Elizabeth Chastain &lt;mec@shout.net&gt;&n; * - Emit menus_per_column&n; *&n; * 14 January 1999, Michael Elizabeth Chastain &lt;mec@shout.net&gt;&n; * - Steam-clean this file.  I tested this by generating kconfig.tk for every&n; *   architecture and comparing it character-for-character against the output&n; *   of the old tkparse.&n; * - Fix flattening of nested menus.  The old code simply assigned items to&n; *   the most recent token_mainmenu_option, without paying attention to scope.&n; *   For example: &quot;menu-1 bool-a menu-2 bool-b endmenu bool-c bool-d endmenu&quot;.&n; *   The old code would put bool-a in menu-1, bool-b in menu-2, and bool-c&n; *   and bool-d in *menu-2*.  This hosed the nested submenus in&n; *   drives/net/Config.in and other places.&n; * - Fix menu line wraparound at 128 menus (some fool used a &squot;char&squot; for&n; *   a counter).&n; *&n; * 23 January 1999, Michael Elizabeth Chastain &lt;mec@shout.net&gt;&n; * - Remove bug-compatible code.&n; *&n; * 07 July 1999, Andrzej M. Krzysztofowicz &lt;ankry@mif.pg.gda.pl&gt;&n; * Some bugfixes, including&n; * - disabling &quot;m&quot; options when CONFIG_MODULES is set to &quot;n&quot; as well as &quot;y&quot;&n; *   option in dep_tristate when dependency is set to &quot;m&quot;,&n; * - deactivating choices which should not be available,&n; * - basic validation for int and hex introduced if the entered one is not &n; *   valid,&n; * - updates of all opened menus instead of the active only. I was afraid&n; *   that it would slow down updates, but I don&squot;t even see any speed difference&n; *   on my machine. If it slows you can still work with only a single menu&n; *   opened,&n; * - fixed error when focussing non-existent window (especially Help windows),&n; * Higher level submenus implemented.&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &quot;tkparse.h&quot;
multiline_comment|/*&n; * Total number of menus.&n; */
DECL|variable|tot_menu_num
r_static
r_int
id|tot_menu_num
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Pointers to mainmenu_option and endmenu of each menu.&n; */
DECL|variable|menu_first
r_struct
id|kconfig
op_star
id|menu_first
(braket
l_int|100
)braket
suffix:semicolon
DECL|variable|menu_last
r_struct
id|kconfig
op_star
id|menu_last
(braket
l_int|100
)braket
suffix:semicolon
multiline_comment|/*&n; * Generate portion of wish script for the beginning of a submenu.&n; * The guts get filled in with the various options.&n; */
DECL|function|start_proc
r_static
r_void
id|start_proc
c_func
(paren
r_char
op_star
id|label
comma
r_int
id|menu_num
comma
r_int
id|toplevel
)paren
(brace
r_if
c_cond
(paren
id|toplevel
)paren
id|printf
c_func
(paren
l_string|&quot;menu_option menu%d %d &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|menu_num
comma
id|menu_num
comma
id|label
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;proc menu%d {w title} {&bslash;n&quot;
comma
id|menu_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset oldFocus [focus]&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|menu_first
(braket
id|menu_num
)braket
op_member_access_from_pointer
id|menu_number
op_ne
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;tcatch {focus .menu%d}&bslash;n&quot;
comma
id|menu_first
(braket
id|menu_num
)braket
op_member_access_from_pointer
id|menu_number
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tcatch {destroy $w; unregister_active %d}&bslash;n&quot;
comma
id|menu_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;ttoplevel $w -class Dialog&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;twm withdraw $w&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tglobal active_menus&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset active_menus [lsort -integer [linsert $active_menus end %d]]&bslash;n&quot;
comma
id|menu_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tmessage $w.m -width 400 -aspect 300 -text &bslash;&bslash;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t&bslash;&quot;%s&bslash;&quot;  -relief raised&bslash;n&quot;
comma
id|label
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tpack $w.m -pady 10 -side top -padx 10&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;twm title $w &bslash;&quot;%s&bslash;&quot; &bslash;n&bslash;n&quot;
comma
id|label
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tbind $w &lt;Escape&gt; &bslash;&quot;catch {focus $oldFocus}; destroy $w; unregister_active %d; break&bslash;&quot;&bslash;n&quot;
comma
id|menu_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset nextscript &quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;&quot;catch {focus $oldFocus}; &quot;
)paren
suffix:semicolon
multiline_comment|/* &n;     * We are checking which windows should be destroyed and which are &n;     * common parrents with the next one. Remember that menu_num field&n;     * in mainmenu_option record reports number of its *parent* menu.&n;     */
r_if
c_cond
(paren
id|menu_num
OL
id|tot_menu_num
op_logical_and
id|menu_first
(braket
id|menu_num
op_plus
l_int|1
)braket
op_member_access_from_pointer
id|menu_number
op_ne
id|menu_num
)paren
(brace
r_int
id|to_destr
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;destroy $w; unregister_active %d; &quot;
comma
id|menu_num
)paren
suffix:semicolon
id|to_destr
op_assign
id|menu_first
(braket
id|menu_num
)braket
op_member_access_from_pointer
id|menu_number
suffix:semicolon
r_while
c_loop
(paren
id|to_destr
OG
l_int|0
op_logical_and
id|menu_first
(braket
id|menu_num
op_plus
l_int|1
)braket
op_member_access_from_pointer
id|menu_number
op_ne
id|to_destr
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;catch {destroy .menu%d}; unregister_active %d; &quot;
comma
id|to_destr
comma
id|to_destr
)paren
suffix:semicolon
id|to_destr
op_assign
id|menu_first
(braket
id|to_destr
)braket
op_member_access_from_pointer
id|menu_number
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;menu%d .menu%d &bslash;&bslash;&bslash;&quot;$title&bslash;&bslash;&bslash;&quot;&bslash;&quot;&bslash;n&quot;
comma
id|menu_num
op_plus
l_int|1
comma
id|menu_num
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;     * Attach the &quot;Prev&quot;, &quot;Next&quot; and &quot;OK&quot; buttons at the end of the window.&n;     */
id|printf
c_func
(paren
l_string|&quot;&bslash;tframe $w.f&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|toplevel
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;tbutton $w.f.back -text &bslash;&quot;Main Menu&bslash;&quot; &bslash;&bslash;&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;&bslash;tbutton $w.f.back -text &bslash;&quot;OK&bslash;&quot; &bslash;&bslash;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t-width 15 -command &bslash;&quot;catch {focus $oldFocus}; destroy $w; unregister_active %d&bslash;&quot;&bslash;n&quot;
comma
id|menu_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tbutton $w.f.next -text &bslash;&quot;Next&bslash;&quot; -underline 0&bslash;&bslash;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t-width 15 -command $nextscript&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|menu_num
op_eq
id|tot_menu_num
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;t$w.f.next configure -state disabled&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* &n;         *  this is a bit hackish but Alt-n must be rebound&n;         *  otherwise if the user press Alt-n on the last menu&n;         *  it will give him/her the next menu of one of the &n;         *  previous options&n;         */
id|printf
c_func
(paren
l_string|&quot;&bslash;tbind all &lt;Alt-n&gt; &bslash;&quot;puts &bslash;&bslash;&bslash;&quot;no more menus&bslash;&bslash;&bslash;&quot; &bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;         * I should be binding to $w not all - but if I do nehat I get the error &quot;unknown path&quot;&n;         */
id|printf
c_func
(paren
l_string|&quot;&bslash;tbind all &lt;Alt-n&gt; $nextscript&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tbutton $w.f.prev -text &bslash;&quot;Prev&bslash;&quot; -underline 0&bslash;&bslash;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t-width 15 -command &bslash;&quot;catch {focus $oldFocus}; destroy $w; unregister_active %d; menu%d .menu%d &bslash;&bslash;&bslash;&quot;$title&bslash;&bslash;&bslash;&quot;&bslash;&quot;&bslash;n&quot;
comma
id|menu_num
comma
id|menu_num
op_minus
l_int|1
comma
id|menu_num
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|menu_num
op_eq
l_int|1
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;t$w.f.prev configure -state disabled&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tbind $w &lt;Alt-p&gt; &bslash;&quot;catch {focus $oldFocus}; destroy $w; unregister_active %d; menu%d .menu%d &bslash;&bslash;&bslash;&quot;$title&bslash;&bslash;&bslash;&quot;;break&bslash;&quot;&bslash;n&quot;
comma
id|menu_num
comma
id|menu_num
op_minus
l_int|1
comma
id|menu_num
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tpack $w.f.back $w.f.next $w.f.prev -side left -expand on&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tpack $w.f -pady 10 -side bottom -anchor w -fill x&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     * Lines between canvas and other areas of the window.&n;     */
id|printf
c_func
(paren
l_string|&quot;&bslash;tframe $w.topline -relief ridge -borderwidth 2 -height 2&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tpack $w.topline -side top -fill x&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tframe $w.botline -relief ridge -borderwidth 2 -height 2&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tpack $w.botline -side bottom -fill x&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     * The &quot;config&quot; frame contains the canvas and a scrollbar.&n;     */
id|printf
c_func
(paren
l_string|&quot;&bslash;tframe $w.config&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tpack $w.config -fill y -expand on&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tscrollbar $w.config.vscroll -command &bslash;&quot;$w.config.canvas yview&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tpack $w.config.vscroll -side right -fill y&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     * The scrollable canvas itself, where the real work (and mess) gets done.&n;     */
id|printf
c_func
(paren
l_string|&quot;&bslash;tcanvas $w.config.canvas -height 1&bslash;&bslash;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t-relief flat -borderwidth 0 -yscrollcommand &bslash;&quot;$w.config.vscroll set&bslash;&quot; &bslash;&bslash;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t-width [expr [winfo screenwidth .] * 1 / 2] &bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tframe $w.config.f&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tbind $w &lt;Key-Down&gt; &bslash;&quot;$w.config.canvas yview scroll  1 unit;break;&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tbind $w &lt;Key-Up&gt; &bslash;&quot;$w.config.canvas yview scroll  -1 unit;break;&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tbind $w &lt;Key-Next&gt; &bslash;&quot;$w.config.canvas yview scroll  1 page;break;&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tbind $w &lt;Key-Prior&gt; &bslash;&quot;$w.config.canvas yview scroll  -1 page;break;&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tbind $w &lt;Key-Home&gt; &bslash;&quot;$w.config.canvas yview moveto 0;break;&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tbind $w &lt;Key-End&gt; &bslash;&quot;$w.config.canvas yview moveto 1 ;break;&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tpack $w.config.canvas -side right -fill y&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Each proc we create needs a global declaration for any global variables we&n; * use.  To minimize the size of the file, we set a flag each time we output&n; * a global declaration so we know whether we need to insert one for a&n; * given function or not.&n; */
DECL|function|clear_globalflags
r_static
r_void
id|clear_globalflags
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|max_varnum
suffix:semicolon
id|i
op_increment
)paren
id|vartable
(braket
id|i
)braket
dot
id|global_written
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Output a &quot;global&quot; line for a given variable.  Also include the&n; * call to &quot;vfix&quot;.  (If vfix is not needed, then it&squot;s fine to just printf&n; * a &quot;global&quot; line).&n; */
DECL|function|global
r_void
id|global
c_func
(paren
r_const
r_char
op_star
id|var
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tglobal %s&bslash;n&quot;
comma
id|var
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function walks the chain of conditions that we got from cond.c&n; * and creates a TCL conditional to enable/disable a given widget.&n; */
DECL|function|generate_if
r_void
id|generate_if
c_func
(paren
r_struct
id|kconfig
op_star
id|cfg
comma
r_struct
id|condition
op_star
id|ocond
comma
r_int
id|menu_num
comma
r_int
id|line_num
)paren
(brace
r_struct
id|condition
op_star
id|cond
suffix:semicolon
r_struct
id|dependency
op_star
id|tmp
suffix:semicolon
r_struct
id|kconfig
op_star
id|cfg1
suffix:semicolon
r_if
c_cond
(paren
id|line_num
op_ge
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|cfg-&gt;token
op_eq
id|token_define_bool
op_logical_or
id|cfg-&gt;token
op_eq
id|token_define_hex
op_logical_or
id|cfg-&gt;token
op_eq
id|token_define_int
op_logical_or
id|cfg-&gt;token
op_eq
id|token_define_string
op_logical_or
id|cfg-&gt;token
op_eq
id|token_define_tristate
op_logical_or
id|cfg-&gt;token
op_eq
id|token_unset
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;token
op_eq
id|token_comment
op_logical_and
id|line_num
op_eq
op_minus
l_int|1
)paren
r_return
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cfg-&gt;token
op_eq
id|token_string
op_logical_or
id|cfg-&gt;token
op_eq
id|token_mainmenu_option
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;     * First write any global declarations we need for this conditional.&n;     */
r_for
c_loop
(paren
id|cond
op_assign
id|ocond
suffix:semicolon
id|cond
op_ne
l_int|NULL
suffix:semicolon
id|cond
op_assign
id|cond-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|cond-&gt;op
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|op_variable
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|vartable
(braket
id|cond-&gt;nameindex
)braket
dot
id|global_written
)paren
(brace
id|vartable
(braket
id|cond-&gt;nameindex
)braket
dot
id|global_written
op_assign
l_int|1
suffix:semicolon
id|global
c_func
(paren
id|vartable
(braket
id|cond-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * Now write this option.&n;     */
r_if
c_cond
(paren
id|cfg-&gt;nameindex
OG
l_int|0
op_logical_and
op_logical_neg
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|global_written
)paren
(brace
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|global_written
op_assign
l_int|1
suffix:semicolon
id|global
c_func
(paren
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Generate the body of the conditional.&n;     */
id|printf
c_func
(paren
l_string|&quot;&bslash;tif {&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cond
op_assign
id|ocond
suffix:semicolon
id|cond
op_ne
l_int|NULL
suffix:semicolon
id|cond
op_assign
id|cond-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|cond-&gt;op
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|op_bang
suffix:colon
id|printf
c_func
(paren
l_string|&quot; ! &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_eq
suffix:colon
id|printf
c_func
(paren
l_string|&quot; == &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_neq
suffix:colon
id|printf
c_func
(paren
l_string|&quot; != &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_and
suffix:colon
id|printf
c_func
(paren
l_string|&quot; &amp;&amp; &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_and1
suffix:colon
id|printf
c_func
(paren
l_string|&quot; &amp;&amp; &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_or
suffix:colon
id|printf
c_func
(paren
l_string|&quot; || &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_lparen
suffix:colon
id|printf
c_func
(paren
l_string|&quot;(&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_rparen
suffix:colon
id|printf
c_func
(paren
l_string|&quot;)&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_variable
suffix:colon
id|printf
c_func
(paren
l_string|&quot;$%s&quot;
comma
id|vartable
(braket
id|cond-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_constant
suffix:colon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cond-&gt;str
comma
l_string|&quot;y&quot;
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;1&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cond-&gt;str
comma
l_string|&quot;n&quot;
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;0&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cond-&gt;str
comma
l_string|&quot;m&quot;
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;2&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cond-&gt;str
comma
l_string|&quot;&quot;
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;4&quot;
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;&bslash;&quot;%s&bslash;&quot;&quot;
comma
id|cond-&gt;str
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;} then {&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     * Generate a procedure call to write the value.&n;     * This code depends on procedures in header.tk.&n;     */
r_if
c_cond
(paren
id|line_num
op_ge
op_minus
l_int|1
)paren
(brace
r_int
id|modtoyes
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cfg-&gt;token
)paren
(brace
r_default
suffix:colon
id|printf
c_func
(paren
l_string|&quot; }&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_dep_mbool
suffix:colon
id|modtoyes
op_assign
l_int|1
suffix:semicolon
r_case
id|token_dep_bool
suffix:colon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|cfg-&gt;depend
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|vartable
(braket
id|get_varnum
c_func
(paren
id|tmp-&gt;name
)paren
)braket
dot
id|global_written
)paren
(brace
id|global
c_func
(paren
id|tmp-&gt;name
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tset tmpvar_dep [effective_dep [list&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|cfg-&gt;depend
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
id|printf
c_func
(paren
l_string|&quot; $%s&quot;
comma
id|tmp-&gt;name
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;]];set %s [sync_bool $%s $tmpvar_dep %d];&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|modtoyes
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;if {$tmpvar_dep != 1&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|modtoyes
)paren
id|printf
c_func
(paren
l_string|&quot; &amp;&amp; $tmpvar_dep != 2&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;} then {configure_entry .menu%d.config.f.x%d disabled {y};&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;} else {&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;configure_entry .menu%d.config.f.x%d normal {y};&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;}; &quot;
)paren
suffix:semicolon
r_case
id|token_bool
suffix:colon
r_if
c_cond
(paren
id|cfg-&gt;token
op_eq
id|token_bool
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;n&bslash;t&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;configure_entry .menu%d.config.f.x%d normal {n l&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;token
op_eq
id|token_bool
)paren
id|printf
c_func
(paren
l_string|&quot; y&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;} else {&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;configure_entry .menu%d.config.f.x%d disabled {y n l}}&bslash;n&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_choice_header
suffix:colon
id|printf
c_func
(paren
l_string|&quot;configure_entry .menu%d.config.f.x%d normal {x l}&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;} else {&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;configure_entry .menu%d.config.f.x%d disabled {x l}&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;}&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_choice_item
suffix:colon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Internal error on token_choice_item&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
r_case
id|token_dep_tristate
suffix:colon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|cfg-&gt;depend
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|vartable
(braket
id|get_varnum
c_func
(paren
id|tmp-&gt;name
)paren
)braket
dot
id|global_written
)paren
(brace
id|global
c_func
(paren
id|tmp-&gt;name
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tset tmpvar_dep [effective_dep [list&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|cfg-&gt;depend
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
id|printf
c_func
(paren
l_string|&quot; $%s&quot;
comma
id|tmp-&gt;name
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;]];set %s [sync_tristate $%s $tmpvar_dep];&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tif {$tmpvar_dep != 1} then {&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;configure_entry .menu%d.config.f.x%d disabled {y}&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;} else {&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;configure_entry .menu%d.config.f.x%d normal {y}&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;}; &quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;if {$tmpvar_dep == 0} then {&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;configure_entry .menu%d.config.f.x%d disabled {m}&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;} else {&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;configure_entry .menu%d.config.f.x%d normal {m}&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;}; &quot;
)paren
suffix:semicolon
r_case
id|token_tristate
suffix:colon
r_if
c_cond
(paren
id|cfg-&gt;token
op_eq
id|token_tristate
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&bslash;tconfigure_entry .menu%d.config.f.x%d normal {y}; &quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;if {($CONFIG_MODULES == 1)} then {&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;configure_entry .menu%d.config.f.x%d normal {m}} else {&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;configure_entry .menu%d.config.f.x%d disabled {m}}; &quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;configure_entry .menu%d.config.f.x%d normal {n l}&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Or in a bit to the variable - this causes all of the radiobuttons&n;&t; * to be deselected (i.e. not be red).&n;&t; */
id|printf
c_func
(paren
l_string|&quot;} else {&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;configure_entry .menu%d.config.f.x%d disabled {y n m l}}&bslash;n&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_hex
suffix:colon
r_case
id|token_int
suffix:colon
r_case
id|token_string
suffix:colon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.x configure -state normal -foreground [ cget .ref -foreground ]; &quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.l configure -state normal; &quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;} else {&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.x configure -state disabled -foreground [ cget .ref -disabledforeground ]; &quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.l configure -state disabled}&bslash;n&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_comment
suffix:colon
r_case
id|token_mainmenu_option
suffix:colon
r_if
c_cond
(paren
id|line_num
op_ge
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;configure_entry .menu%d.config.f.x%d normal {m}&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;} else {&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;configure_entry .menu%d.config.f.x%d disabled {m}}&bslash;n&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot;.f0.x%d configure -state normal } else { .f0.x%d configure -state disabled }&bslash;n&quot;
comma
id|menu_num
comma
id|menu_num
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
id|modtoyes
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cfg-&gt;token
)paren
(brace
r_default
suffix:colon
id|printf
c_func
(paren
l_string|&quot; }&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_dep_mbool
suffix:colon
id|modtoyes
op_assign
l_int|1
suffix:semicolon
r_case
id|token_dep_bool
suffix:colon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|cfg-&gt;depend
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|vartable
(braket
id|get_varnum
c_func
(paren
id|tmp-&gt;name
)paren
)braket
dot
id|global_written
)paren
(brace
id|global
c_func
(paren
id|tmp-&gt;name
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tset tmpvar_dep [effective_dep [list&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|cfg-&gt;depend
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
id|printf
c_func
(paren
l_string|&quot; $%s&quot;
comma
id|tmp-&gt;name
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;]];set %s [sync_bool $%s $tmpvar_dep %d];&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|modtoyes
)paren
suffix:semicolon
r_case
id|token_bool
suffix:colon
r_if
c_cond
(paren
id|cfg-&gt;token
op_eq
id|token_bool
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;n&bslash;t&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;set %s [expr $%s&amp;15]&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;} else {&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;set %s [expr $%s|16]}&bslash;n&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_choice_header
suffix:colon
id|printf
c_func
(paren
l_string|&quot;} else {&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cfg1
op_assign
id|cfg-&gt;next
suffix:semicolon
id|cfg1
op_ne
l_int|NULL
op_logical_and
id|cfg1-&gt;token
op_eq
id|token_choice_item
suffix:semicolon
id|cfg1
op_assign
id|cfg1-&gt;next
)paren
id|printf
c_func
(paren
l_string|&quot;set %s 4;&quot;
comma
id|vartable
(braket
id|cfg1-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;}&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_choice_item
suffix:colon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Internal error on token_choice_item&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
r_case
id|token_define_bool
suffix:colon
r_case
id|token_define_tristate
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|vartable
(braket
id|get_varnum
c_func
(paren
id|cfg-&gt;value
)paren
)braket
dot
id|global_written
)paren
(brace
id|global
c_func
(paren
id|cfg-&gt;value
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;set %s $%s }&bslash;n&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|cfg-&gt;value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_define_hex
suffix:colon
r_case
id|token_define_int
suffix:colon
id|printf
c_func
(paren
l_string|&quot;set %s %s }&bslash;n&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|cfg-&gt;value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_define_string
suffix:colon
id|printf
c_func
(paren
l_string|&quot;set %s &bslash;&quot;%s&bslash;&quot; }&bslash;n&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|cfg-&gt;value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_dep_tristate
suffix:colon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|cfg-&gt;depend
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|vartable
(braket
id|get_varnum
c_func
(paren
id|tmp-&gt;name
)paren
)braket
dot
id|global_written
)paren
(brace
id|global
c_func
(paren
id|tmp-&gt;name
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tset tmpvar_dep [effective_dep [list&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|cfg-&gt;depend
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
id|printf
c_func
(paren
l_string|&quot; $%s&quot;
comma
id|tmp-&gt;name
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;]]; set %s [sync_tristate $%s $tmpvar_dep]; &quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_case
id|token_tristate
suffix:colon
r_if
c_cond
(paren
id|cfg-&gt;token
op_eq
id|token_tristate
)paren
id|printf
c_func
(paren
l_string|&quot;if {($CONFIG_MODULES == 0) &amp;&amp; ($%s == 2)} then {set %s 1}; &quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Or in a bit to the variable - this causes all of the radiobuttons&n;&t; * to be deselected (i.e. not be red).&n;&t; */
id|printf
c_func
(paren
l_string|&quot;set %s [expr $%s&amp;15]&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;} else {&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the disable bit to enable the correct radiobutton.&n;&t; */
id|printf
c_func
(paren
l_string|&quot;set %s [expr $%s|16]}&bslash;n&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_hex
suffix:colon
r_case
id|token_int
suffix:colon
r_if
c_cond
(paren
id|cfg-&gt;value
op_logical_and
op_star
id|cfg-&gt;value
op_eq
l_char|&squot;$&squot;
)paren
(brace
r_int
id|index
op_assign
id|get_varnum
c_func
(paren
id|cfg-&gt;value
op_plus
l_int|1
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vartable
(braket
id|index
)braket
dot
id|global_written
)paren
(brace
id|global
c_func
(paren
id|vartable
(braket
id|index
)braket
dot
id|name
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;t&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cfg-&gt;token
op_eq
id|token_hex
)paren
id|printf
c_func
(paren
l_string|&quot;validate_hex &quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|cfg-&gt;token
op_eq
id|token_int
)paren
id|printf
c_func
(paren
l_string|&quot;validate_int &quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;%s &bslash;&quot;$%s&bslash;&quot; %s}&bslash;n&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|cfg-&gt;value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_unset
suffix:colon
id|printf
c_func
(paren
l_string|&quot;set %s 4}&bslash;n&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Generate a line that writes a variable to the output file.&n; */
DECL|function|generate_writeconfig
r_void
id|generate_writeconfig
c_func
(paren
r_struct
id|kconfig
op_star
id|cfg
)paren
(brace
r_struct
id|condition
op_star
id|cond
suffix:semicolon
r_struct
id|dependency
op_star
id|tmp
suffix:semicolon
r_int
id|depmod
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;     * Generate global declaration for this symbol.&n;     */
r_if
c_cond
(paren
id|cfg-&gt;token
op_ne
id|token_comment
)paren
(brace
r_if
c_cond
(paren
id|cfg-&gt;nameindex
OG
l_int|0
op_logical_and
op_logical_neg
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|global_written
)paren
(brace
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|global_written
op_assign
l_int|1
suffix:semicolon
id|global
c_func
(paren
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cfg-&gt;token
op_eq
id|token_define_tristate
op_logical_or
id|cfg-&gt;token
op_eq
id|token_define_bool
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|vartable
(braket
id|get_varnum
c_func
(paren
id|cfg-&gt;value
)paren
)braket
dot
id|global_written
)paren
(brace
id|vartable
(braket
id|get_varnum
c_func
(paren
id|cfg-&gt;value
)paren
)braket
dot
id|global_written
op_assign
l_int|1
suffix:semicolon
id|global
c_func
(paren
id|cfg-&gt;value
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|cfg-&gt;nameindex
op_le
l_int|0
op_logical_and
id|cfg-&gt;token
op_eq
id|token_choice_header
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tglobal tmpvar_%d&bslash;n&quot;
comma
op_minus
(paren
id|cfg-&gt;nameindex
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * Generate global declarations for the condition chain.&n;     */
r_for
c_loop
(paren
id|cond
op_assign
id|cfg-&gt;cond
suffix:semicolon
id|cond
op_ne
l_int|NULL
suffix:semicolon
id|cond
op_assign
id|cond-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|cond-&gt;op
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|op_variable
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|vartable
(braket
id|cond-&gt;nameindex
)braket
dot
id|global_written
)paren
(brace
id|vartable
(braket
id|cond-&gt;nameindex
)braket
dot
id|global_written
op_assign
l_int|1
suffix:semicolon
id|global
c_func
(paren
id|vartable
(braket
id|cond-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * Generate indentation.&n;     */
id|printf
c_func
(paren
l_string|&quot;&bslash;t&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     * Generate the conditional.&n;     */
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;if {&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cond
op_assign
id|cfg-&gt;cond
suffix:semicolon
id|cond
op_ne
l_int|NULL
suffix:semicolon
id|cond
op_assign
id|cond-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|cond-&gt;op
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|op_bang
suffix:colon
id|printf
c_func
(paren
l_string|&quot; ! &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_eq
suffix:colon
id|printf
c_func
(paren
l_string|&quot; == &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_neq
suffix:colon
id|printf
c_func
(paren
l_string|&quot; != &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_and
suffix:colon
id|printf
c_func
(paren
l_string|&quot; &amp;&amp; &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_and1
suffix:colon
id|printf
c_func
(paren
l_string|&quot; &amp;&amp; &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_or
suffix:colon
id|printf
c_func
(paren
l_string|&quot; || &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_lparen
suffix:colon
id|printf
c_func
(paren
l_string|&quot;(&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_rparen
suffix:colon
id|printf
c_func
(paren
l_string|&quot;)&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_variable
suffix:colon
id|printf
c_func
(paren
l_string|&quot;$%s&quot;
comma
id|vartable
(braket
id|cond-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_constant
suffix:colon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cond-&gt;str
comma
l_string|&quot;n&quot;
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;0&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cond-&gt;str
comma
l_string|&quot;y&quot;
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;1&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cond-&gt;str
comma
l_string|&quot;m&quot;
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;2&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cond-&gt;str
comma
l_string|&quot;&quot;
)paren
op_eq
l_int|0
)paren
id|printf
c_func
(paren
l_string|&quot;4&quot;
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;&bslash;&quot;%s&bslash;&quot;&quot;
comma
id|cond-&gt;str
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;} then {&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Generate a procedure call to write the value.&n;     * This code depends on the write_* procedures in header.tk.&n;     */
r_switch
c_cond
(paren
id|cfg-&gt;token
)paren
(brace
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
id|printf
c_func
(paren
l_string|&quot; }&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_bool
suffix:colon
r_case
id|token_tristate
suffix:colon
id|printf
c_func
(paren
l_string|&quot;write_tristate $cfg $autocfg %s $%s [list $notmod] 2&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
id|printf
c_func
(paren
l_string|&quot; }&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_choice_header
suffix:colon
multiline_comment|/*&n;&t; * This is funky code -- it fails if there were any conditionals.&n;&t; * Fortunately all the conditionals got stripped off somewhere&n;&t; * else.&n;&t; */
(brace
r_struct
id|kconfig
op_star
id|cfg1
suffix:semicolon
r_for
c_loop
(paren
id|cfg1
op_assign
id|cfg-&gt;next
suffix:semicolon
id|cfg1
op_ne
l_int|NULL
op_logical_and
id|cfg1-&gt;token
op_eq
id|token_choice_item
suffix:semicolon
id|cfg1
op_assign
id|cfg1-&gt;next
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&bslash;tif { $tmpvar_%d == &bslash;&quot;%s&bslash;&quot; } then { write_tristate $cfg $autocfg %s 1 [list $notmod] 2 } else { write_tristate $cfg $autocfg %s 0 [list $notmod] 2 }&quot;
comma
op_minus
(paren
id|cfg-&gt;nameindex
)paren
comma
id|cfg1-&gt;label
comma
id|vartable
(braket
id|cfg1-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg1-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
id|printf
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_choice_item
suffix:colon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Internal error on token_choice_item&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
r_case
id|token_comment
suffix:colon
id|printf
c_func
(paren
l_string|&quot;write_comment $cfg $autocfg &bslash;&quot;%s&bslash;&quot;&quot;
comma
id|cfg-&gt;label
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
id|printf
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_define_bool
suffix:colon
r_case
id|token_define_tristate
suffix:colon
r_if
c_cond
(paren
id|cfg-&gt;cond
op_eq
l_int|NULL
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;write_tristate $cfg $autocfg %s $%s [list $notmod] 2&bslash;n&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;write_tristate $cfg $autocfg %s $%s [list $notmod] 2 }&bslash;n&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|cfg-&gt;value
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|token_dep_mbool
suffix:colon
id|depmod
op_assign
l_int|1
suffix:semicolon
r_case
id|token_dep_bool
suffix:colon
r_case
id|token_dep_tristate
suffix:colon
id|printf
c_func
(paren
l_string|&quot;write_tristate $cfg $autocfg %s $%s [list&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|cfg-&gt;depend
suffix:semicolon
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
id|printf
c_func
(paren
l_string|&quot; $%s&quot;
comma
id|tmp-&gt;name
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;] %d&quot;
comma
id|depmod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
id|printf
c_func
(paren
l_string|&quot; }&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_define_hex
suffix:colon
id|printf
c_func
(paren
l_string|&quot;write_hex $cfg $autocfg %s %s $notmod&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|cfg-&gt;value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
id|printf
c_func
(paren
l_string|&quot; }&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_define_int
suffix:colon
id|printf
c_func
(paren
l_string|&quot;write_int $cfg $autocfg %s %s $notmod&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|cfg-&gt;value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
id|printf
c_func
(paren
l_string|&quot; }&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_define_string
suffix:colon
id|printf
c_func
(paren
l_string|&quot;write_string $cfg $autocfg %s &bslash;&quot;%s&bslash;&quot; $notmod&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|cfg-&gt;value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
id|printf
c_func
(paren
l_string|&quot; }&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_hex
suffix:colon
id|printf
c_func
(paren
l_string|&quot;write_hex $cfg $autocfg %s $%s $notmod&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
id|printf
c_func
(paren
l_string|&quot; }&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_int
suffix:colon
id|printf
c_func
(paren
l_string|&quot;write_int $cfg $autocfg %s $%s $notmod&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
id|printf
c_func
(paren
l_string|&quot; }&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_string
suffix:colon
id|printf
c_func
(paren
l_string|&quot;write_string $cfg $autocfg %s &bslash;&quot;$%s&bslash;&quot; $notmod&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
id|printf
c_func
(paren
l_string|&quot; }&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|generate_update_var
r_static
r_void
id|generate_update_var
c_func
(paren
r_struct
id|kconfig
op_star
id|scfg
comma
r_int
id|menu_num
)paren
(brace
r_struct
id|kconfig
op_star
id|cfg
suffix:semicolon
r_if
c_cond
(paren
id|menu_num
OG
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;proc update_define_menu%d {} {&bslash;n&quot;
comma
id|menu_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tupdate_define_mainmenu&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot;proc update_define_mainmenu {} {&bslash;n&quot;
)paren
suffix:semicolon
id|clear_globalflags
c_func
(paren
)paren
suffix:semicolon
id|global
c_func
(paren
l_string|&quot;CONFIG_MODULES&quot;
)paren
suffix:semicolon
id|vartable
(braket
id|get_varnum
c_func
(paren
l_string|&quot;CONFIG_MODULES&quot;
)paren
)braket
dot
id|global_written
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cfg-&gt;menu_number
op_eq
id|menu_num
op_logical_and
(paren
id|cfg-&gt;token
op_eq
id|token_define_bool
op_logical_or
id|cfg-&gt;token
op_eq
id|token_define_tristate
op_logical_or
id|cfg-&gt;token
op_eq
id|token_define_hex
op_logical_or
id|cfg-&gt;token
op_eq
id|token_define_int
op_logical_or
id|cfg-&gt;token
op_eq
id|token_define_string
op_logical_or
id|cfg-&gt;token
op_eq
id|token_unset
op_logical_or
id|cfg-&gt;token
op_eq
id|token_tristate
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|global_written
)paren
(brace
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|global_written
op_assign
l_int|1
suffix:semicolon
id|global
c_func
(paren
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
)brace
)brace
)brace
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_char
id|tmp
(braket
l_int|20
)braket
suffix:semicolon
r_struct
id|kconfig
op_star
id|cfg1
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;menu_number
op_eq
id|menu_num
)paren
(brace
r_switch
c_cond
(paren
id|cfg-&gt;token
)paren
(brace
r_default
suffix:colon
r_case
id|token_choice_item
suffix:colon
r_break
suffix:semicolon
r_case
id|token_choice_header
suffix:colon
id|sprintf
c_func
(paren
id|tmp
comma
l_string|&quot;tmpvar_%d&quot;
comma
op_minus
(paren
id|cfg-&gt;nameindex
)paren
)paren
suffix:semicolon
id|global
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cfg1
op_assign
id|cfg-&gt;next
suffix:semicolon
id|cfg1
op_ne
l_int|NULL
op_logical_and
id|cfg1-&gt;token
op_eq
id|token_choice_item
suffix:semicolon
id|cfg1
op_assign
id|cfg1-&gt;next
)paren
(brace
id|vartable
(braket
id|cfg1-&gt;nameindex
)braket
dot
id|global_written
op_assign
l_int|1
suffix:semicolon
id|global
c_func
(paren
id|vartable
(braket
id|cfg1-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tif {$tmpvar_%d == &bslash;&quot;%s&bslash;&quot;} then {set %s 1} else {set %s 0}&bslash;n&quot;
comma
op_minus
(paren
id|cfg-&gt;nameindex
)paren
comma
id|cfg1-&gt;label
comma
id|vartable
(braket
id|cfg1-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg1-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|token_bool
suffix:colon
r_case
id|token_define_bool
suffix:colon
r_case
id|token_define_tristate
suffix:colon
r_case
id|token_define_hex
suffix:colon
r_case
id|token_define_int
suffix:colon
r_case
id|token_define_string
suffix:colon
r_case
id|token_dep_bool
suffix:colon
r_case
id|token_dep_tristate
suffix:colon
r_case
id|token_dep_mbool
suffix:colon
r_case
id|token_int
suffix:colon
r_case
id|token_hex
suffix:colon
r_case
id|token_mainmenu_option
suffix:colon
r_case
id|token_tristate
suffix:colon
r_case
id|token_unset
suffix:colon
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
id|generate_if
c_func
(paren
id|cfg
comma
id|cfg-&gt;cond
comma
id|menu_num
comma
op_minus
l_int|2
)paren
suffix:semicolon
r_else
r_switch
c_cond
(paren
id|cfg-&gt;token
)paren
(brace
r_case
id|token_tristate
suffix:colon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&bslash;tif {($CONFIG_MODULES == 0)} then {if {($%s == 2)} then {set %s 1}}&bslash;n&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_define_bool
suffix:colon
r_case
id|token_define_tristate
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|vartable
(braket
id|get_varnum
c_func
(paren
id|cfg-&gt;value
)paren
)braket
dot
id|global_written
)paren
(brace
id|vartable
(braket
id|get_varnum
c_func
(paren
id|cfg-&gt;value
)paren
)braket
dot
id|global_written
op_assign
l_int|1
suffix:semicolon
id|global
c_func
(paren
id|cfg-&gt;value
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tset %s $%s&bslash;n&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|cfg-&gt;value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_define_hex
suffix:colon
r_case
id|token_define_int
suffix:colon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset %s %s&bslash;n&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|cfg-&gt;value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_define_string
suffix:colon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset %s &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|cfg-&gt;value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_unset
suffix:colon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset %s 4&bslash;n&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;}&bslash;n&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Generates the end of a menu procedure.&n; */
DECL|function|end_proc
r_static
r_void
id|end_proc
c_func
(paren
r_struct
id|kconfig
op_star
id|scfg
comma
r_int
id|menu_num
)paren
(brace
r_struct
id|kconfig
op_star
id|cfg
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tfocus $w&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tupdate_active&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tglobal winx; global winy&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|menu_first
(braket
id|menu_num
)braket
op_member_access_from_pointer
id|menu_number
op_ne
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tif {[winfo exists .menu%d] == 0} then &quot;
comma
id|menu_first
(braket
id|menu_num
)braket
op_member_access_from_pointer
id|menu_number
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;{menu%d .menu%d &bslash;&quot;%s&bslash;&quot;}&bslash;n&quot;
comma
id|menu_first
(braket
id|menu_num
)braket
op_member_access_from_pointer
id|menu_number
comma
id|menu_first
(braket
id|menu_num
)braket
op_member_access_from_pointer
id|menu_number
comma
id|menu_first
(braket
id|menu_first
(braket
id|menu_num
)braket
op_member_access_from_pointer
id|menu_number
)braket
op_member_access_from_pointer
id|label
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset winx [expr [winfo x .menu%d]+30]; set winy [expr [winfo y .menu%d]+30]&bslash;n&quot;
comma
id|menu_first
(braket
id|menu_num
)braket
op_member_access_from_pointer
id|menu_number
comma
id|menu_first
(braket
id|menu_num
)braket
op_member_access_from_pointer
id|menu_number
)paren
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot;&bslash;tset winx [expr [winfo x .]+30]; set winy [expr [winfo y .]+30]&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tif {[winfo exists $w]} then {wm geometry $w +$winx+$winy}&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     * Now that the whole window is in place, we need to wait for an &quot;update&quot;&n;     * so we can tell the canvas what its virtual size should be.&n;     *&n;     * Unfortunately, this causes some ugly screen-flashing because the whole&n;     * window is drawn, and then it is immediately resized.  It seems&n;     * unavoidable, though, since &quot;frame&quot; objects won&squot;t tell us their size&n;     * until after an update, and &quot;canvas&quot; objects can&squot;t automatically pack&n;     * around frames.  Sigh.&n;     */
id|printf
c_func
(paren
l_string|&quot;&bslash;tupdate idletasks&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tif {[winfo exists $w]} then  {$w.config.canvas create window 0 0 -anchor nw -window $w.config.f&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t$w.config.canvas configure &bslash;&bslash;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t-width [expr [winfo reqwidth $w.config.f] + 1]&bslash;&bslash;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t-scrollregion &bslash;&quot;-1 -1 [expr [winfo reqwidth $w.config.f] + 1] &bslash;&bslash;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t&bslash;t [expr [winfo reqheight $w.config.f] + 1]&bslash;&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     * If the whole canvas will fit in 3/4 of the screen height, do it;&n;     * otherwise, resize to around 1/2 the screen and let us scroll.&n;     */
id|printf
c_func
(paren
l_string|&quot;&bslash;tset winy [expr [winfo reqh $w] - [winfo reqh $w.config.canvas]]&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset scry [expr [winfo screenh $w] / 2]&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset maxy [expr [winfo screenh $w] * 3 / 4]&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset canvtotal [expr [winfo reqh $w.config.f] + 2]&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tif [expr $winy + $canvtotal &lt; $maxy] {&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t$w.config.canvas configure -height $canvtotal&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t} else {&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t$w.config.canvas configure -height [expr $scry - $winy]&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t}&bslash;n&bslash;t}&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     * Limit the min/max window size.  Height can vary, but not width,&n;     * because of the limitations of canvas and our laziness.&n;     */
id|printf
c_func
(paren
l_string|&quot;&bslash;tupdate idletasks&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tif {[winfo exists $w]} then {&bslash;n&bslash;twm maxsize $w [winfo width $w] [winfo screenheight $w]&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;twm minsize $w [winfo width $w] 100&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;twm deiconify $w&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;}&bslash;n}&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     * Now we generate the companion procedure for the menu we just&n;     * generated.  This procedure contains all of the code to&n;     * disable/enable widgets based upon the settings of the other&n;     * widgets, and will be called first when the window is mapped,&n;     * and each time one of the buttons in the window are clicked.&n;     */
id|printf
c_func
(paren
l_string|&quot;proc update_menu%d {} {&bslash;n&quot;
comma
id|menu_num
)paren
suffix:semicolon
multiline_comment|/*&n;     * Clear all of the booleans that are defined in this menu.&n;     */
id|clear_globalflags
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cfg-&gt;menu_number
op_eq
id|menu_num
op_logical_and
id|cfg-&gt;token
op_ne
id|token_mainmenu_option
op_logical_and
id|cfg-&gt;token
op_ne
id|token_choice_item
)paren
(brace
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cfg-&gt;token
op_eq
id|token_tristate
op_logical_or
id|cfg-&gt;token
op_eq
id|token_dep_tristate
)paren
op_logical_and
op_logical_neg
id|vartable
(braket
id|i
op_assign
id|get_varnum
c_func
(paren
l_string|&quot;CONFIG_MODULES&quot;
)paren
)braket
dot
id|global_written
)paren
(brace
id|global
c_func
(paren
l_string|&quot;CONFIG_MODULES&quot;
)paren
suffix:semicolon
id|vartable
(braket
id|i
)braket
dot
id|global_written
op_assign
l_int|1
suffix:semicolon
)brace
id|generate_if
c_func
(paren
id|cfg
comma
id|cfg-&gt;cond
comma
id|cfg-&gt;menu_number
comma
id|cfg-&gt;menu_line
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|cfg-&gt;token
op_eq
id|token_tristate
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|global_written
)paren
(brace
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|global_written
op_assign
l_int|1
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tglobal %s&bslash;n&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|vartable
(braket
id|i
op_assign
id|get_varnum
c_func
(paren
l_string|&quot;CONFIG_MODULES&quot;
)paren
)braket
dot
id|global_written
)paren
(brace
id|global
c_func
(paren
l_string|&quot;CONFIG_MODULES&quot;
)paren
suffix:semicolon
id|vartable
(braket
id|i
)braket
dot
id|global_written
op_assign
l_int|1
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&bslash;tif {($CONFIG_MODULES == 1)} then {configure_entry .menu%d.config.f.x%d normal {m}} else {configure_entry .menu%d.config.f.x%d disabled {m}}&bslash;n&quot;
comma
id|menu_num
comma
id|cfg-&gt;menu_line
comma
id|menu_num
comma
id|cfg-&gt;menu_line
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|cfg-&gt;token
op_eq
id|token_mainmenu_option
op_logical_and
id|cfg-&gt;menu_number
op_eq
id|menu_num
op_logical_and
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
(brace
id|generate_if
c_func
(paren
id|cfg
comma
id|cfg-&gt;cond
comma
id|menu_num
comma
id|cfg-&gt;menu_line
)paren
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;}&bslash;n&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|generate_update_var
c_func
(paren
id|scfg
comma
id|menu_num
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the top level function for generating the tk script.&n; */
DECL|function|dump_tk_script
r_void
id|dump_tk_script
c_func
(paren
r_struct
id|kconfig
op_star
id|scfg
)paren
(brace
r_int
id|menu_depth
suffix:semicolon
r_int
id|menu_num
(braket
l_int|64
)braket
suffix:semicolon
r_int
id|imenu
comma
id|i
suffix:semicolon
r_int
id|top_level_num
op_assign
l_int|0
suffix:semicolon
r_struct
id|kconfig
op_star
id|cfg
suffix:semicolon
r_struct
id|kconfig
op_star
id|cfg1
op_assign
l_int|NULL
suffix:semicolon
r_const
r_char
op_star
id|name
op_assign
l_string|&quot;No Name&quot;
suffix:semicolon
multiline_comment|/*&n;     * Mark begin and end of each menu so I can omit submenus when walking&n;     * over a parent menu.&n;     */
id|tot_menu_num
op_assign
l_int|0
suffix:semicolon
id|menu_depth
op_assign
l_int|0
suffix:semicolon
id|menu_num
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|cfg-&gt;token
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|token_mainmenu_name
suffix:colon
id|name
op_assign
id|cfg-&gt;label
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_mainmenu_option
suffix:colon
r_if
c_cond
(paren
op_increment
id|menu_depth
op_ge
l_int|64
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;menus too deep&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|tot_menu_num
op_ge
l_int|100
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;too many menus&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|menu_num
(braket
id|menu_depth
)braket
op_assign
id|tot_menu_num
suffix:semicolon
id|menu_first
(braket
id|tot_menu_num
)braket
op_assign
id|cfg
suffix:semicolon
id|menu_last
(braket
id|tot_menu_num
)braket
op_assign
id|cfg
suffix:semicolon
multiline_comment|/*&n;&t;     * Note, that menu_number is set to the number of parent &n;&t;     * (upper level) menu.&n;&t;     */
id|cfg-&gt;menu_number
op_assign
id|menu_num
(braket
id|menu_depth
op_minus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|menu_depth
op_eq
l_int|1
)paren
op_increment
id|top_level_num
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_endmenu
suffix:colon
id|menu_last
(braket
id|menu_num
(braket
id|menu_depth
)braket
)braket
op_assign
id|cfg
suffix:semicolon
multiline_comment|/* flatten menus with proper scoping */
r_if
c_cond
(paren
op_decrement
id|menu_depth
OL
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;unmatched endmenu&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|token_bool
suffix:colon
r_case
id|token_choice_header
suffix:colon
r_case
id|token_choice_item
suffix:colon
r_case
id|token_comment
suffix:colon
r_case
id|token_dep_bool
suffix:colon
r_case
id|token_dep_tristate
suffix:colon
r_case
id|token_dep_mbool
suffix:colon
r_case
id|token_hex
suffix:colon
r_case
id|token_int
suffix:colon
r_case
id|token_string
suffix:colon
r_case
id|token_tristate
suffix:colon
id|cfg-&gt;menu_number
op_assign
id|menu_num
(braket
id|menu_depth
)braket
suffix:semicolon
r_if
c_cond
(paren
id|menu_depth
op_eq
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;statement not in menu&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|token_define_bool
suffix:colon
r_case
id|token_define_hex
suffix:colon
r_case
id|token_define_int
suffix:colon
r_case
id|token_define_string
suffix:colon
r_case
id|token_define_tristate
suffix:colon
r_case
id|token_unset
suffix:colon
id|cfg-&gt;menu_number
op_assign
id|menu_num
(braket
id|menu_depth
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * Generate menus per column setting.&n;     * There are:&n;     *   four extra buttons for save/quit/load/store;&n;     *   one blank button&n;     *   add two to round up for division&n;     */
id|printf
c_func
(paren
l_string|&quot;set menus_per_column %d&bslash;n&quot;
comma
(paren
id|top_level_num
op_plus
l_int|4
op_plus
l_int|1
op_plus
l_int|2
)paren
op_div
l_int|3
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;set total_menus %d&bslash;n&bslash;n&quot;
comma
id|tot_menu_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;proc toplevel_menu {num} {&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|imenu
op_assign
l_int|1
suffix:semicolon
id|imenu
op_le
id|tot_menu_num
suffix:semicolon
op_increment
id|imenu
)paren
(brace
r_int
id|parent
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|menu_first
(braket
id|imenu
)braket
op_member_access_from_pointer
id|menu_number
op_eq
l_int|0
)paren
id|parent
op_assign
id|menu_first
(braket
id|imenu
)braket
op_member_access_from_pointer
id|menu_number
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;&bslash;tif {$num == %d} then {return %d}&bslash;n&quot;
comma
id|imenu
comma
id|menu_first
(braket
id|imenu
)braket
op_member_access_from_pointer
id|menu_number
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;treturn $num&bslash;n}&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     * Generate the menus.&n;     */
id|printf
c_func
(paren
l_string|&quot;mainmenu_name &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|imenu
op_assign
l_int|1
suffix:semicolon
id|imenu
op_le
id|tot_menu_num
suffix:semicolon
op_increment
id|imenu
)paren
(brace
r_int
id|menu_line
op_assign
l_int|0
suffix:semicolon
r_int
id|nr_submenu
op_assign
id|imenu
suffix:semicolon
r_int
id|menu_name_omitted
op_assign
l_int|0
suffix:semicolon
r_int
id|opt_count
op_assign
l_int|0
suffix:semicolon
id|clear_globalflags
c_func
(paren
)paren
suffix:semicolon
id|start_proc
c_func
(paren
id|menu_first
(braket
id|imenu
)braket
op_member_access_from_pointer
id|label
comma
id|imenu
comma
op_logical_neg
id|menu_first
(braket
id|imenu
)braket
op_member_access_from_pointer
id|menu_number
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cfg
op_assign
id|menu_first
(braket
id|imenu
)braket
op_member_access_from_pointer
id|next
suffix:semicolon
id|cfg
op_ne
l_int|NULL
op_logical_and
id|cfg
op_ne
id|menu_last
(braket
id|imenu
)braket
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|cfg-&gt;token
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|token_mainmenu_option
suffix:colon
r_while
c_loop
(paren
id|menu_first
(braket
op_increment
id|nr_submenu
)braket
op_member_access_from_pointer
id|menu_number
OG
id|imenu
)paren
suffix:semicolon
id|cfg-&gt;menu_line
op_assign
id|menu_line
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tsubmenu $w.config.f %d %d &bslash;&quot;%s&bslash;&quot; %d&bslash;n&quot;
comma
id|cfg-&gt;menu_number
comma
id|cfg-&gt;menu_line
comma
id|cfg-&gt;label
comma
id|nr_submenu
)paren
suffix:semicolon
id|cfg
op_assign
id|menu_last
(braket
id|nr_submenu
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_comment
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|cfg-&gt;menu_line
op_logical_and
op_logical_neg
id|menu_name_omitted
)paren
(brace
id|cfg-&gt;menu_line
op_assign
op_minus
l_int|1
suffix:semicolon
id|menu_name_omitted
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|menu_name_omitted
op_assign
l_int|1
suffix:semicolon
id|cfg-&gt;menu_line
op_assign
id|menu_line
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tcomment $w.config.f %d %d &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|cfg-&gt;menu_number
comma
id|cfg-&gt;menu_line
comma
id|cfg-&gt;label
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|token_bool
suffix:colon
id|cfg-&gt;menu_line
op_assign
id|menu_line
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tbool $w.config.f %d %d &bslash;&quot;%s&bslash;&quot; %s&bslash;n&quot;
comma
id|cfg-&gt;menu_number
comma
id|cfg-&gt;menu_line
comma
id|cfg-&gt;label
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_choice_header
suffix:colon
multiline_comment|/*&n;&t;&t; * I need the first token_choice_item to pick out the right&n;&t;&t; * help text from Documentation/Configure.help.&n;&t;&t; */
id|cfg-&gt;menu_line
op_assign
id|menu_line
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tglobal tmpvar_%d&bslash;n&quot;
comma
op_minus
(paren
id|cfg-&gt;nameindex
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tminimenu $w.config.f %d %d &bslash;&quot;%s&bslash;&quot; tmpvar_%d %s&bslash;n&quot;
comma
id|cfg-&gt;menu_number
comma
id|cfg-&gt;menu_line
comma
id|cfg-&gt;label
comma
op_minus
(paren
id|cfg-&gt;nameindex
)paren
comma
id|vartable
(braket
id|cfg-&gt;next-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tmenu $w.config.f.x%d.x.menu -tearoffcommand &bslash;&quot;menutitle &bslash;&bslash;&bslash;&quot;%s&bslash;&bslash;&bslash;&quot;&bslash;&quot;&bslash;n&quot;
comma
id|cfg-&gt;menu_line
comma
id|cfg-&gt;label
)paren
suffix:semicolon
id|cfg1
op_assign
id|cfg
suffix:semicolon
id|opt_count
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_choice_item
suffix:colon
multiline_comment|/* note: no menu line; uses choice header menu line */
id|printf
c_func
(paren
l_string|&quot;&bslash;t$w.config.f.x%d.x.menu add radiobutton -label &bslash;&quot;%s&bslash;&quot; -variable tmpvar_%d -value &bslash;&quot;%s&bslash;&quot; -command &bslash;&quot;update_active&bslash;&quot;&bslash;n&quot;
comma
id|cfg1-&gt;menu_line
comma
id|cfg-&gt;label
comma
op_minus
(paren
id|cfg1-&gt;nameindex
)paren
comma
id|cfg-&gt;label
)paren
suffix:semicolon
id|opt_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;next
op_logical_and
id|cfg-&gt;next-&gt;token
op_ne
id|token_choice_item
)paren
(brace
multiline_comment|/* last option in the menu */
id|printf
c_func
(paren
l_string|&quot;&bslash;tmenusplit $w $w.config.f.x%d.x.menu %d&bslash;n&quot;
comma
id|cfg1-&gt;menu_line
comma
id|opt_count
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|token_dep_bool
suffix:colon
r_case
id|token_dep_mbool
suffix:colon
id|cfg-&gt;menu_line
op_assign
id|menu_line
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tdep_bool $w.config.f %d %d &bslash;&quot;%s&bslash;&quot; %s&bslash;n&quot;
comma
id|cfg-&gt;menu_number
comma
id|cfg-&gt;menu_line
comma
id|cfg-&gt;label
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_dep_tristate
suffix:colon
id|cfg-&gt;menu_line
op_assign
id|menu_line
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tdep_tristate $w.config.f %d %d &bslash;&quot;%s&bslash;&quot; %s&bslash;n&quot;
comma
id|cfg-&gt;menu_number
comma
id|cfg-&gt;menu_line
comma
id|cfg-&gt;label
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_hex
suffix:colon
id|cfg-&gt;menu_line
op_assign
id|menu_line
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;thex $w.config.f %d %d &bslash;&quot;%s&bslash;&quot; %s&bslash;n&quot;
comma
id|cfg-&gt;menu_number
comma
id|cfg-&gt;menu_line
comma
id|cfg-&gt;label
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_int
suffix:colon
id|cfg-&gt;menu_line
op_assign
id|menu_line
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tint $w.config.f %d %d &bslash;&quot;%s&bslash;&quot; %s&bslash;n&quot;
comma
id|cfg-&gt;menu_number
comma
id|cfg-&gt;menu_line
comma
id|cfg-&gt;label
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_string
suffix:colon
id|cfg-&gt;menu_line
op_assign
id|menu_line
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tistring $w.config.f %d %d &bslash;&quot;%s&bslash;&quot; %s&bslash;n&quot;
comma
id|cfg-&gt;menu_number
comma
id|cfg-&gt;menu_line
comma
id|cfg-&gt;label
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_tristate
suffix:colon
id|cfg-&gt;menu_line
op_assign
id|menu_line
op_increment
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;ttristate $w.config.f %d %d &bslash;&quot;%s&bslash;&quot; %s&bslash;n&quot;
comma
id|cfg-&gt;menu_number
comma
id|cfg-&gt;menu_line
comma
id|cfg-&gt;label
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|end_proc
c_func
(paren
id|scfg
comma
id|imenu
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * The top level menu also needs an update function.  When we update a&n;     * submenu, we may need to disable one or more of the submenus on&n;     * the top level menu, and this procedure will ensure that things are&n;     * correct.&n;     */
id|clear_globalflags
c_func
(paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;proc update_mainmenu {}  {&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|imenu
op_assign
l_int|1
suffix:semicolon
id|imenu
op_le
id|tot_menu_num
suffix:semicolon
id|imenu
op_increment
)paren
(brace
r_if
c_cond
(paren
id|menu_first
(braket
id|imenu
)braket
op_member_access_from_pointer
id|cond
op_ne
l_int|NULL
op_logical_and
id|menu_first
(braket
id|imenu
)braket
op_member_access_from_pointer
id|menu_number
op_eq
l_int|0
)paren
id|generate_if
c_func
(paren
id|menu_first
(braket
id|imenu
)braket
comma
id|menu_first
(braket
id|imenu
)braket
op_member_access_from_pointer
id|cond
comma
id|imenu
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;}&bslash;n&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|clear_globalflags
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;     * Generate code to load the default settings into the variables.&n;     * The script in tail.tk will attempt to load .config,&n;     * which may override these settings, but that&squot;s OK.&n;     */
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|cfg-&gt;token
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|token_bool
suffix:colon
r_case
id|token_choice_item
suffix:colon
r_case
id|token_dep_bool
suffix:colon
r_case
id|token_dep_tristate
suffix:colon
r_case
id|token_dep_mbool
suffix:colon
r_case
id|token_tristate
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|global_written
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;set %s 0&bslash;n&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|global_written
op_assign
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|token_choice_header
suffix:colon
id|printf
c_func
(paren
l_string|&quot;set tmpvar_%d &bslash;&quot;(not set)&bslash;&quot;&bslash;n&quot;
comma
op_minus
(paren
id|cfg-&gt;nameindex
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|token_hex
suffix:colon
r_case
id|token_int
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|global_written
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;set %s %s&bslash;n&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|cfg-&gt;value
ques
c_cond
id|cfg-&gt;value
suffix:colon
l_string|&quot;0&quot;
)paren
suffix:semicolon
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|global_written
op_assign
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|token_string
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|global_written
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;set %s &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|name
comma
id|cfg-&gt;value
)paren
suffix:semicolon
id|vartable
(braket
id|cfg-&gt;nameindex
)braket
dot
id|global_written
op_assign
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * Define to an empty value all other variables (which are never defined)&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|max_varnum
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|vartable
(braket
id|i
)braket
dot
id|global_written
op_logical_and
id|strncmp
c_func
(paren
id|vartable
(braket
id|i
)braket
dot
id|name
comma
l_string|&quot;CONSTANT_&quot;
comma
l_int|9
)paren
)paren
id|printf
c_func
(paren
l_string|&quot;set %s 4&bslash;n&quot;
comma
id|vartable
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Generate a function to write all of the variables to a file.&n;     */
id|printf
c_func
(paren
l_string|&quot;proc writeconfig {file1 file2} {&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset cfg [open $file1 w]&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset autocfg [open $file2 w]&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset notmod 1&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset notset 0&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tputs $cfg &bslash;&quot;#&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tputs $cfg &bslash;&quot;# Automatically generated make config: don&squot;t edit&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tputs $cfg &bslash;&quot;#&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tputs $autocfg &bslash;&quot;/*&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tputs $autocfg &bslash;&quot; * Automatically generated C config: don&squot;t edit&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tputs $autocfg &bslash;&quot; */&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tputs $autocfg &bslash;&quot;#define AUTOCONF_INCLUDED&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|clear_globalflags
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|cfg-&gt;token
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
id|token_bool
suffix:colon
r_case
id|token_choice_header
suffix:colon
r_case
id|token_comment
suffix:colon
r_case
id|token_define_bool
suffix:colon
r_case
id|token_define_hex
suffix:colon
r_case
id|token_define_int
suffix:colon
r_case
id|token_define_string
suffix:colon
r_case
id|token_define_tristate
suffix:colon
r_case
id|token_dep_bool
suffix:colon
r_case
id|token_dep_tristate
suffix:colon
r_case
id|token_dep_mbool
suffix:colon
r_case
id|token_hex
suffix:colon
r_case
id|token_int
suffix:colon
r_case
id|token_string
suffix:colon
r_case
id|token_tristate
suffix:colon
id|generate_writeconfig
c_func
(paren
id|cfg
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tclose $cfg&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tclose $autocfg&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;}&bslash;n&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;     * Generate a simple function that updates the master choice&n;     * variable depending upon what values were loaded from a .config&n;     * file.  &n;     */
id|printf
c_func
(paren
l_string|&quot;proc clear_choices { } {&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cfg-&gt;token
op_eq
id|token_choice_header
)paren
(brace
r_for
c_loop
(paren
id|cfg1
op_assign
id|cfg-&gt;next
suffix:semicolon
id|cfg1
op_ne
l_int|NULL
op_logical_and
id|cfg1-&gt;token
op_eq
id|token_choice_item
suffix:semicolon
id|cfg1
op_assign
id|cfg1-&gt;next
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tglobal %s; set %s 0&bslash;n&quot;
comma
id|vartable
(braket
id|cfg1-&gt;nameindex
)braket
dot
id|name
comma
id|vartable
(braket
id|cfg1-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
)brace
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;}&bslash;n&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;proc update_choices { } {&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cfg-&gt;token
op_eq
id|token_choice_header
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tglobal tmpvar_%d&bslash;n&quot;
comma
op_minus
(paren
id|cfg-&gt;nameindex
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset tmpvar_%d &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
op_minus
(paren
id|cfg-&gt;nameindex
)paren
comma
id|cfg-&gt;value
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cfg1
op_assign
id|cfg-&gt;next
suffix:semicolon
id|cfg1
op_ne
l_int|NULL
op_logical_and
id|cfg1-&gt;token
op_eq
id|token_choice_item
suffix:semicolon
id|cfg1
op_assign
id|cfg1-&gt;next
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tglobal %s&bslash;n&quot;
comma
id|vartable
(braket
id|cfg1-&gt;nameindex
)braket
dot
id|name
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tif { $%s == 1 } then { set tmpvar_%d &bslash;&quot;%s&bslash;&quot; }&bslash;n&quot;
comma
id|vartable
(braket
id|cfg1-&gt;nameindex
)braket
dot
id|name
comma
op_minus
(paren
id|cfg-&gt;nameindex
)paren
comma
id|cfg1-&gt;label
)paren
suffix:semicolon
)brace
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;}&bslash;n&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|generate_update_var
c_func
(paren
id|scfg
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;     * That&squot;s it.  We are done.  The output of this file will have header.tk&n;     * prepended and tail.tk appended to create an executable wish script.&n;     */
)brace
eof
