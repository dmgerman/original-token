multiline_comment|/* Generate tk script based upon config.in&n; *&n; * Version 1.0&n; * Eric Youngdale&n; * 10/95&n; *&n; * 1996 01 04&n; * Avery Pennarun - Aesthetic improvements.&n; *&n; * 1996 01 24&n; * Avery Pennarun - Bugfixes and more aesthetics.&n; *&n; * 1996 03 08&n; * Avery Pennarun - The int and hex config.in commands work right.&n; *                - Choice buttons are more user-friendly.&n; *                - Disabling a text entry line greys it out properly.&n; *                - dep_tristate now works like in Configure. (not pretty)&n; *                - No warnings in gcc -Wall. (Fixed some &quot;interesting&quot; bugs.)&n; *                - Faster/prettier &quot;Help&quot; lookups.&n; *&n; * 1996 03 15&n; * Avery Pennarun - Added new sed script from Axel Boldt to make help even&n; *                  faster. (Actually awk is downright slow on some machines.)&n; *                - Fixed a bug I introduced into Choice dependencies.  Thanks&n; *                  to Robert Krawitz for pointing this out.&n; *&n; * 1996 03 16&n; * Avery Pennarun - basic &quot;do_make&quot; support added to let sound config work.&n; *&n; * 1996 03 25&n; *     Axel Boldt - Help now works on &quot;choice&quot; buttons.&n; *&n; * 1996 04 06&n; * Avery Pennarun - Improved sound config stuff. (I think it actually works&n; *                  now!)&n; *                - Window-resize-limits don&squot;t use ugly /usr/lib/tk4.0 hack.&n; *                - int/hex work with tk3 again. (The &quot;cget&quot; error.)&n; *                - Next/Prev buttons switch between menus.  I can&squot;t take&n; *                  much credit for this; the code was already there, but&n; *                  ifdef&squot;d out for some reason.  It flickers a lot, but&n; *                  I suspect there&squot;s no &quot;easy&quot; fix for that.&n; *                - Labels no longer highlight as you move the mouse over&n; *                  them (although you can still press them... oh well.)&n; *                - Got rid of the last of the literal color settings, to&n; *                  help out people with mono X-Windows systems. &n; *                  (Apparently there still are some out there!)&n; *                - Tabstops seem sensible now.&n; *&n; * 1996 04 14&n; * Avery Pennarun - Reduced flicker when creating windows, even with &quot;update&n; *                  idletasks&quot; hack.&n; *&n; * 1997 12 08&n; * Michael Chastain - Remove sound driver special cases.&n; *&n; * 1997 11 15&n; * Michael Chastain - For choice buttons, write values for all options,&n; *                    not just the single chosen one.  This is compatible&n; *                    with &squot;make config&squot; and &squot;make oldconfig&squot;, and is&n; *                    needed so smart-config dependencies work if the&n; *                    user switches from one configuration method to&n; *                    another.&n; *&n; * TO DO:&n; *   - clean up - there are useless ifdef&squot;s everywhere.&n; *   - better comments throughout - C code generating tcl is really cryptic.&n; *   - eliminate silly &quot;update idletasks&quot; hack to improve display speed and&n; *     reduce flicker.  But how?&n; *   - make canvas contents resize with the window (good luck).&n; *   - some way to make submenus inside of submenus (ie. Main-&gt;Networking-&gt;IP)&n; *           (perhaps a button where the description would be)&n; *   - make the main menu use the same tcl code as the submenus.&n; *   - make choice and int/hex input types line up vertically with&n; *           bool/tristate.&n; *   - general speedups - how?  The canvas seems to slow it down a lot.&n; *   - choice buttons should default to the first menu option, rather than a&n; *           blank.  Also look up the right variable when the help button&n; *           is pressed.&n; *   - clean up +/- 16 confusion for enabling/disabling variables; causes&n; *           (theoretical, at the moment) problems with dependencies.&n; *   &n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &quot;tkparse.h&quot;
macro_line|#ifndef TRUE
DECL|macro|TRUE
mdefine_line|#define TRUE (1)
macro_line|#endif
macro_line|#ifndef FALSE
DECL|macro|FALSE
mdefine_line|#define FALSE (0)
macro_line|#endif
multiline_comment|/*&n; * This is the total number of submenus that we have.&n; */
DECL|variable|tot_menu_num
r_static
r_int
id|tot_menu_num
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Generate portion of wish script for the beginning of a submenu.&n; * The guts get filled in with the various options.&n; */
DECL|function|start_proc
r_static
r_void
id|start_proc
c_func
(paren
r_char
op_star
id|label
comma
r_int
id|menu_num
comma
r_int
id|flag
)paren
(brace
r_if
c_cond
(paren
id|flag
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;menu_option menu%d %d &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|menu_num
comma
id|menu_num
comma
id|label
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;proc menu%d {w title} {&bslash;n&quot;
comma
id|menu_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tcatch {destroy $w}&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;ttoplevel $w -class Dialog&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;twm withdraw $w&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tmessage $w.m -width 400 -aspect 300 -text &bslash;&bslash;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t&bslash;t&bslash;&quot;%s&bslash;&quot;  -relief raised&bslash;n&quot;
comma
id|label
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tpack $w.m -pady 10 -side top -padx 10&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;twm title $w &bslash;&quot;%s&bslash;&quot; &bslash;n&bslash;n&quot;
comma
id|label
)paren
suffix:semicolon
multiline_comment|/*&n;   * Attach the &quot;Prev&quot;, &quot;Next&quot; and &quot;OK&quot; buttons at the end of the window.&n;   */
id|printf
c_func
(paren
l_string|&quot;&bslash;tset oldFocus [focus]&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tframe $w.f&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tbutton $w.f.back -text &bslash;&quot;Main Menu&bslash;&quot; &bslash;&bslash;&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t-width 15 -command &bslash;&quot;destroy $w; focus $oldFocus; update_mainmenu $w&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tbutton $w.f.next -text &bslash;&quot;Next&bslash;&quot; &bslash;&bslash;&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t-width 15 -command &bslash;&quot; destroy $w; focus $oldFocus;  menu%d .menu%d &bslash;&bslash;&bslash;&quot;$title&bslash;&bslash;&bslash;&quot;&bslash;&quot;&bslash;n&quot;
comma
id|menu_num
op_plus
l_int|1
comma
id|menu_num
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|menu_num
op_eq
id|tot_menu_num
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;t$w.f.next configure -state disabled&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tbutton $w.f.prev -text &bslash;&quot;Prev&bslash;&quot; &bslash;&bslash;&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t-width 15 -command &bslash;&quot; destroy $w; focus $oldFocus; menu%d .menu%d &bslash;&bslash;&bslash;&quot;$title&bslash;&bslash;&bslash;&quot;&bslash;&quot;&bslash;n&quot;
comma
id|menu_num
op_minus
l_int|1
comma
id|menu_num
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|1
op_eq
id|menu_num
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;t$w.f.prev configure -state disabled&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tpack $w.f.back $w.f.next $w.f.prev -side left -expand on&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tpack $w.f -pady 10 -side bottom -anchor w -fill x&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;   * Lines between canvas and other areas of the window.&n;   */
id|printf
c_func
(paren
l_string|&quot;&bslash;tframe $w.topline -relief ridge -borderwidth 2 -height 2&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tpack $w.topline -side top -fill x&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tframe $w.botline -relief ridge -borderwidth 2 -height 2&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tpack $w.botline -side bottom -fill x&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;   * The &quot;config&quot; frame contains the canvas and a scrollbar.&n;   */
id|printf
c_func
(paren
l_string|&quot;&bslash;tframe $w.config&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tpack $w.config -fill y -expand on&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tscrollbar $w.config.vscroll -command &bslash;&quot;$w.config.canvas yview&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tpack $w.config.vscroll -side right -fill y&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;   * The scrollable canvas itself, where the real work (and mess) gets done.&n;   */
id|printf
c_func
(paren
l_string|&quot;&bslash;tcanvas $w.config.canvas -height 1&bslash;&bslash;&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t-relief flat -borderwidth 0 -yscrollcommand &bslash;&quot;$w.config.vscroll set&bslash;&quot; &bslash;&bslash;&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t-width [expr [winfo screenwidth .] * 1 / 2] &bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tframe $w.config.f&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tpack $w.config.canvas -side right -fill y&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Each proc we create needs a global declaration for any global variables we&n; * use.  To minimize the size of the file, we set a flag each time we output&n; * a global declaration so we know whether we need to insert one for a&n; * given function or not.&n; */
DECL|function|clear_globalflags
r_void
id|clear_globalflags
c_func
(paren
r_struct
id|kconfig
op_star
id|cfg
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
id|cfg-&gt;flags
op_and_assign
op_complement
id|GLOBAL_WRITTEN
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Output a &quot;global&quot; line for a given variable.  Also include the&n; * call to &quot;vfix&quot;.  (If vfix is not needed, then it&squot;s fine to just printf&n; * a &quot;global&quot; line).&n; */
DECL|function|global
r_void
r_inline
id|global
c_func
(paren
r_char
op_star
id|var
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tglobal %s; vfix %s&bslash;n&quot;
comma
id|var
comma
id|var
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function walks the chain of conditions that we got from cond.c,&n; * and creates a wish conditional to enable/disable a given widget.&n; */
DECL|function|generate_if
r_void
id|generate_if
c_func
(paren
r_struct
id|kconfig
op_star
id|item
comma
r_struct
id|condition
op_star
id|cond
comma
r_int
id|menu_num
comma
r_int
id|line_num
)paren
(brace
r_struct
id|condition
op_star
id|ocond
suffix:semicolon
id|ocond
op_assign
id|cond
suffix:semicolon
multiline_comment|/*&n;   * First write any global declarations we need for this conditional.&n;   */
r_while
c_loop
(paren
id|cond
op_ne
l_int|NULL
)paren
(brace
r_switch
c_cond
(paren
id|cond-&gt;op
)paren
(brace
r_case
id|op_variable
suffix:colon
id|global
c_func
(paren
id|cond-&gt;variable.str
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_kvariable
suffix:colon
r_if
c_cond
(paren
id|cond-&gt;variable.cfg-&gt;flags
op_amp
id|GLOBAL_WRITTEN
)paren
(brace
r_break
suffix:semicolon
)brace
id|cond-&gt;variable.cfg-&gt;flags
op_or_assign
id|GLOBAL_WRITTEN
suffix:semicolon
id|global
c_func
(paren
id|cond-&gt;variable.cfg-&gt;optionname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|cond
op_assign
id|cond-&gt;next
suffix:semicolon
)brace
multiline_comment|/*&n;   * Now write this option.&n;   */
r_if
c_cond
(paren
(paren
id|item-&gt;flags
op_amp
id|GLOBAL_WRITTEN
)paren
op_eq
l_int|0
op_logical_and
(paren
id|item-&gt;optionname
op_ne
l_int|NULL
)paren
)paren
(brace
id|global
c_func
(paren
id|item-&gt;optionname
)paren
suffix:semicolon
id|item-&gt;flags
op_or_assign
id|GLOBAL_WRITTEN
suffix:semicolon
)brace
multiline_comment|/*&n;   * Now generate the body of the conditional.&n;   */
id|printf
c_func
(paren
l_string|&quot;&bslash;tif {&quot;
)paren
suffix:semicolon
id|cond
op_assign
id|ocond
suffix:semicolon
r_while
c_loop
(paren
id|cond
op_ne
l_int|NULL
)paren
(brace
r_switch
c_cond
(paren
id|cond-&gt;op
)paren
(brace
r_case
id|op_bang
suffix:colon
id|printf
c_func
(paren
l_string|&quot; ! &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_eq
suffix:colon
id|printf
c_func
(paren
l_string|&quot; == &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_neq
suffix:colon
id|printf
c_func
(paren
l_string|&quot; != &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_and
suffix:colon
r_case
id|op_and1
suffix:colon
id|printf
c_func
(paren
l_string|&quot; &amp;&amp; &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_or
suffix:colon
id|printf
c_func
(paren
l_string|&quot; || &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_lparen
suffix:colon
id|printf
c_func
(paren
l_string|&quot;(&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_rparen
suffix:colon
id|printf
c_func
(paren
l_string|&quot;)&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_variable
suffix:colon
id|printf
c_func
(paren
l_string|&quot;$%s&quot;
comma
id|cond-&gt;variable.str
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_kvariable
suffix:colon
id|printf
c_func
(paren
l_string|&quot;$%s&quot;
comma
id|cond-&gt;variable.cfg-&gt;optionname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_shellcmd
suffix:colon
id|printf
c_func
(paren
l_string|&quot;[exec %s]&quot;
comma
id|cond-&gt;variable.str
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_constant
suffix:colon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cond-&gt;variable.str
comma
l_string|&quot;y&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;1&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cond-&gt;variable.str
comma
l_string|&quot;n&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;0&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cond-&gt;variable.str
comma
l_string|&quot;m&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;2&quot;
)paren
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot;&bslash;&quot;%s&bslash;&quot;&quot;
comma
id|cond-&gt;variable.str
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|cond
op_assign
id|cond-&gt;next
suffix:semicolon
)brace
multiline_comment|/*&n;   * Now we generate what we do depending upon the value of the conditional.&n;   * Depending upon what the token type is, there are different things&n;   * we must do to enable/disable the given widget - this code needs to&n;   * be closely coordinated with the widget creation procedures in header.tk.&n;   */
r_switch
c_cond
(paren
id|item-&gt;tok
)paren
(brace
r_case
id|tok_define
suffix:colon
id|printf
c_func
(paren
l_string|&quot;} then { set %s %s } &bslash;n&quot;
comma
id|item-&gt;optionname
comma
id|item-&gt;value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_menuoption
suffix:colon
id|printf
c_func
(paren
l_string|&quot;} then { .f0.x%d configure -state normal } else { .f0.x%d configure -state disabled }&bslash;n&quot;
comma
id|menu_num
comma
id|menu_num
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_int
suffix:colon
r_case
id|tok_hex
suffix:colon
r_case
id|tok_string
suffix:colon
id|printf
c_func
(paren
l_string|&quot;} then { &quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.x configure -state normal -fore [ cget .ref -foreground ]; &quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.l configure -state normal; &quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;} else { &quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.x configure -state disabled -fore [ cget .ref -disabledforeground ];&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.l configure -state disabled;&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;}&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_bool
suffix:colon
macro_line|#ifdef BOOL_IS_BUTTON
multiline_comment|/*&n;       * If a bool is just a button, then use this definition.&n;       */
id|printf
c_func
(paren
l_string|&quot;} then { .menu%d.config.f.x%d configure -state normal } else { .menu%d.config.f.x%d configure -state disabled }&bslash;n&quot;
comma
id|menu_num
comma
id|line_num
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/*&n;       * If a bool is a radiobutton, then use this instead.&n;       */
id|printf
c_func
(paren
l_string|&quot;} then { &quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.y configure -state normal;&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.n configure -state normal;&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.l configure -state normal;&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;set %s [expr $%s&amp;15];&quot;
comma
id|item-&gt;optionname
comma
id|item-&gt;optionname
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;} else { &quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.y configure -state disabled;&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.n configure -state disabled;&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.l configure -state disabled;&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;set %s [expr $%s|16];&quot;
comma
id|item-&gt;optionname
comma
id|item-&gt;optionname
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;}&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|tok_tristate
suffix:colon
r_case
id|tok_dep_tristate
suffix:colon
id|printf
c_func
(paren
l_string|&quot;} then { &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|item-&gt;tok
op_eq
id|tok_dep_tristate
)paren
(brace
id|global
c_func
(paren
id|item-&gt;depend.str
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;if { $%s != 1 &amp;&amp; $%s != 0 } then {&quot;
comma
id|item-&gt;depend.str
comma
id|item-&gt;depend.str
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.y configure -state disabled;&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;} else {&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.y configure -state normal;&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;}; &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.y configure -state normal;&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.n configure -state normal;&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.m configure -state normal;&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.l configure -state normal;&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
multiline_comment|/*&n;       * Or in a bit to the variable - this causes all of the radiobuttons&n;       * to be deselected (i.e. not be red).&n;       */
id|printf
c_func
(paren
l_string|&quot;set %s [expr $%s&amp;15];&quot;
comma
id|item-&gt;optionname
comma
id|item-&gt;optionname
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;} else { &quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.y configure -state disabled;&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.n configure -state disabled;&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.m configure -state disabled;&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;.menu%d.config.f.x%d.l configure -state disabled;&quot;
comma
id|menu_num
comma
id|line_num
)paren
suffix:semicolon
multiline_comment|/*&n;       * Clear the disable bit - this causes the correct radiobutton&n;       * to appear selected (i.e. turn red).&n;       */
id|printf
c_func
(paren
l_string|&quot;set %s [expr $%s|16];&quot;
comma
id|item-&gt;optionname
comma
id|item-&gt;optionname
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;}&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_choose
suffix:colon
r_case
id|tok_choice
suffix:colon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Fixme&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|0
)paren
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Similar to generate_if, except we come here when generating an&n; * output file.  Thus instead of enabling/disabling a widget, we&n; * need to decide whether to write out a given configuration variable&n; * to the output file.&n; */
DECL|function|generate_if_for_outfile
r_void
id|generate_if_for_outfile
c_func
(paren
r_struct
id|kconfig
op_star
id|item
comma
r_struct
id|condition
op_star
id|cond
)paren
(brace
r_struct
id|condition
op_star
id|ocond
suffix:semicolon
multiline_comment|/*&n;   * First write any global declarations we need for this conditional.&n;   */
id|ocond
op_assign
id|cond
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|cond
op_ne
l_int|NULL
suffix:semicolon
id|cond
op_assign
id|cond-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|cond-&gt;op
)paren
(brace
r_case
id|op_variable
suffix:colon
id|global
c_func
(paren
id|cond-&gt;variable.str
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_kvariable
suffix:colon
r_if
c_cond
(paren
id|cond-&gt;variable.cfg-&gt;flags
op_amp
id|GLOBAL_WRITTEN
)paren
(brace
r_break
suffix:semicolon
)brace
id|cond-&gt;variable.cfg-&gt;flags
op_or_assign
id|GLOBAL_WRITTEN
suffix:semicolon
id|global
c_func
(paren
id|cond-&gt;variable.cfg-&gt;optionname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Now generate the body of the conditional.&n;   */
id|printf
c_func
(paren
l_string|&quot;&bslash;tif {&quot;
)paren
suffix:semicolon
id|cond
op_assign
id|ocond
suffix:semicolon
r_while
c_loop
(paren
id|cond
op_ne
l_int|NULL
)paren
(brace
r_switch
c_cond
(paren
id|cond-&gt;op
)paren
(brace
r_case
id|op_bang
suffix:colon
id|printf
c_func
(paren
l_string|&quot; ! &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_eq
suffix:colon
id|printf
c_func
(paren
l_string|&quot; == &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_neq
suffix:colon
id|printf
c_func
(paren
l_string|&quot; != &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_and
suffix:colon
r_case
id|op_and1
suffix:colon
id|printf
c_func
(paren
l_string|&quot; &amp;&amp; &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_or
suffix:colon
id|printf
c_func
(paren
l_string|&quot; || &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_lparen
suffix:colon
id|printf
c_func
(paren
l_string|&quot;(&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_rparen
suffix:colon
id|printf
c_func
(paren
l_string|&quot;)&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_variable
suffix:colon
id|printf
c_func
(paren
l_string|&quot;$%s&quot;
comma
id|cond-&gt;variable.str
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_shellcmd
suffix:colon
id|printf
c_func
(paren
l_string|&quot;[exec %s]&quot;
comma
id|cond-&gt;variable.str
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_kvariable
suffix:colon
id|printf
c_func
(paren
l_string|&quot;$%s&quot;
comma
id|cond-&gt;variable.cfg-&gt;optionname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|op_constant
suffix:colon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cond-&gt;variable.str
comma
l_string|&quot;y&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;1&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cond-&gt;variable.str
comma
l_string|&quot;n&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;0&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|cond-&gt;variable.str
comma
l_string|&quot;m&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;2&quot;
)paren
suffix:semicolon
)brace
r_else
id|printf
c_func
(paren
l_string|&quot;&bslash;&quot;%s&bslash;&quot;&quot;
comma
id|cond-&gt;variable.str
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|cond
op_assign
id|cond-&gt;next
suffix:semicolon
)brace
multiline_comment|/*&n;   * Now we generate what we do depending upon the value of the&n;   * conditional.  Depending upon what the token type is, there are&n;   * different things we must do write the value the given widget -&n;   * this code needs to be closely coordinated with the widget&n;   * creation procedures in header.tk.  &n;   */
r_switch
c_cond
(paren
id|item-&gt;tok
)paren
(brace
r_case
id|tok_define
suffix:colon
id|printf
c_func
(paren
l_string|&quot;} then {write_tristate $cfg $autocfg %s %s $notmod }&bslash;n&quot;
comma
id|item-&gt;optionname
comma
id|item-&gt;value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_comment
suffix:colon
id|printf
c_func
(paren
l_string|&quot;} then {write_comment $cfg $autocfg &bslash;&quot;%s&bslash;&quot;}&bslash;n&quot;
comma
id|item-&gt;label
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_dep_tristate
suffix:colon
id|printf
c_func
(paren
l_string|&quot;} then { write_tristate $cfg $autocfg %s $%s $%s } &bslash;n&quot;
comma
id|item-&gt;optionname
comma
id|item-&gt;optionname
comma
id|item-&gt;depend.str
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_tristate
suffix:colon
r_case
id|tok_bool
suffix:colon
id|printf
c_func
(paren
l_string|&quot;} then { write_tristate $cfg $autocfg %s $%s $notmod }&bslash;n&quot;
comma
id|item-&gt;optionname
comma
id|item-&gt;optionname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_int
suffix:colon
id|printf
c_func
(paren
l_string|&quot;} then { write_int $cfg $autocfg %s $%s $notmod }&bslash;n&quot;
comma
id|item-&gt;optionname
comma
id|item-&gt;optionname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_hex
suffix:colon
id|printf
c_func
(paren
l_string|&quot;} then { write_hex $cfg $autocfg %s $%s $notmod }&bslash;n&quot;
comma
id|item-&gt;optionname
comma
id|item-&gt;optionname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_string
suffix:colon
id|printf
c_func
(paren
l_string|&quot;} then { write_string $cfg $autocfg %s $%s $notmod }&bslash;n&quot;
comma
id|item-&gt;optionname
comma
id|item-&gt;optionname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_choose
suffix:colon
r_case
id|tok_choice
suffix:colon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Fixme&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|0
)paren
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Generates a fragment of wish script that closes out a submenu procedure.&n; */
DECL|function|end_proc
r_static
r_void
id|end_proc
c_func
(paren
r_int
id|menu_num
)paren
(brace
r_struct
id|kconfig
op_star
id|cfg
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tfocus $w&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tupdate_menu%d $w.config.f&bslash;n&quot;
comma
id|menu_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tglobal winx; global winy&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset winx [expr [winfo x .]+30]; set winy [expr [winfo y .]+30]&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;twm geometry $w +$winx+$winy&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;   * Now that the whole window is in place, we need to wait for an &quot;update&quot;&n;   * so we can tell the canvas what its virtual size should be.&n;   *&n;   * Unfortunately, this causes some ugly screen-flashing because the whole&n;   * window is drawn, and then it is immediately resized.  It seems&n;   * unavoidable, though, since &quot;frame&quot; objects won&squot;t tell us their size&n;   * until after an update, and &quot;canvas&quot; objects can&squot;t automatically pack&n;   * around frames.  Sigh.&n;   */
id|printf
c_func
(paren
l_string|&quot;&bslash;tupdate idletasks&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t$w.config.canvas create window 0 0 -anchor nw -window $w.config.f&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;t$w.config.canvas configure &bslash;&bslash;&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t-width [expr [winfo reqwidth $w.config.f] + 1]&bslash;&bslash;&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t-scrollregion &bslash;&quot;-1 -1 [expr [winfo reqwidth $w.config.f] + 1] &bslash;&bslash;&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t&bslash;t [expr [winfo reqheight $w.config.f] + 1]&bslash;&quot;&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;   * If the whole canvas will fit in 3/4 of the screen height, do it;&n;   * otherwise, resize to around 1/2 the screen and let us scroll.&n;   */
id|printf
c_func
(paren
l_string|&quot;&bslash;tset winy [expr [winfo reqh $w] - [winfo reqh $w.config.canvas]]&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset scry [expr [winfo screenh $w] / 2]&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset maxy [expr [winfo screenh $w] * 3 / 4]&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset canvtotal [expr [winfo reqh $w.config.f] + 2]&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tif [expr $winy + $canvtotal &lt; $maxy] {&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t$w.config.canvas configure -height $canvtotal&bslash;n&quot;
l_string|&quot;&bslash;t} else {&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;t$w.config.canvas configure -height [expr $scry - $winy]&bslash;n&quot;
l_string|&quot;&bslash;t}&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;   * Limit the min/max window size.  Height can vary, but not width,&n;   * because of the limitations of canvas and our laziness.&n;   */
id|printf
c_func
(paren
l_string|&quot;&bslash;tupdate idletasks&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;twm maxsize $w [winfo width $w] [winfo screenheight $w]&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;twm minsize $w [winfo width $w] 100&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;twm deiconify $w&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;}&bslash;n&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;   * Now we generate the companion procedure for the menu we just&n;   * generated.  This procedure contains all of the code to&n;   * disable/enable widgets based upon the settings of the other&n;   * widgets, and will be called first when the window is mapped,&n;   * and each time one of the buttons in the window are clicked.&n;   */
id|printf
c_func
(paren
l_string|&quot;proc update_menu%d {w}  {&bslash;n&quot;
comma
id|menu_num
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tupdate_define&bslash;n&quot;
)paren
suffix:semicolon
id|clear_globalflags
c_func
(paren
id|config
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cfg
op_assign
id|config
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
multiline_comment|/*&n;       * Skip items not for this menu, or ones having no conditions.&n;       */
r_if
c_cond
(paren
id|cfg-&gt;menu_number
op_ne
id|menu_num
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;tok
op_ne
id|tok_define
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;       * Clear all of the booleans that are defined in this menu.&n;       */
r_if
c_cond
(paren
(paren
id|cfg-&gt;flags
op_amp
id|GLOBAL_WRITTEN
)paren
op_eq
l_int|0
op_logical_and
(paren
id|cfg-&gt;optionname
op_ne
l_int|NULL
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tglobal %s&bslash;n&quot;
comma
id|cfg-&gt;optionname
)paren
suffix:semicolon
id|cfg-&gt;flags
op_or_assign
id|GLOBAL_WRITTEN
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset %s 0&bslash;n&quot;
comma
id|cfg-&gt;optionname
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|cfg
op_assign
id|config
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
multiline_comment|/*&n;       * Skip items not for this menu, or ones having no conditions.&n;       */
r_if
c_cond
(paren
id|cfg-&gt;menu_number
op_ne
id|menu_num
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;tok
op_eq
id|tok_menuoption
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
id|generate_if
c_func
(paren
id|cfg
comma
id|cfg-&gt;cond
comma
id|menu_num
comma
id|cfg-&gt;menu_line
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;   * If this token has no conditionals, check to see whether&n;&t;   * it is a tristate - if so, then generate the conditional&n;&t;   * to enable/disable the &quot;y&quot; button based upon the setting&n;&t;   * of the option it depends upon.&n;&t;   */
r_if
c_cond
(paren
id|cfg-&gt;tok
op_eq
id|tok_dep_tristate
)paren
(brace
id|global
c_func
(paren
id|cfg-&gt;depend.str
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tif {$%s != 1 &amp;&amp; $%s != 0 } then { .menu%d.config.f.x%d.y configure -state disabled } else { .menu%d.config.f.x%d.y configure -state normal}&bslash;n&quot;
comma
id|cfg-&gt;depend.str
comma
id|cfg-&gt;depend.str
comma
id|menu_num
comma
id|cfg-&gt;menu_line
comma
id|menu_num
comma
id|cfg-&gt;menu_line
)paren
suffix:semicolon
)brace
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;}&bslash;n&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function goes through and counts up the number of items in&n; * each submenu. If there are too many options, we need to split it&n; * into submenus.  This function just calculates how many submenus,&n; * and how many items go in each submenu.&n; */
DECL|function|find_menu_size
r_static
r_void
id|find_menu_size
c_func
(paren
r_struct
id|kconfig
op_star
id|cfg
comma
r_int
op_star
id|menu_max
comma
r_int
op_star
id|menu_maxlines
)paren
(brace
r_struct
id|kconfig
op_star
id|pnt
suffix:semicolon
r_int
id|tot
suffix:semicolon
multiline_comment|/*&n;   * First count up the number of options in this menu.&n;   */
id|tot
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|pnt
op_assign
id|cfg-&gt;next
suffix:semicolon
id|pnt
suffix:semicolon
id|pnt
op_assign
id|pnt-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|pnt-&gt;tok
op_eq
id|tok_menuoption
)paren
(brace
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|pnt-&gt;tok
)paren
(brace
r_case
id|tok_bool
suffix:colon
r_case
id|tok_tristate
suffix:colon
r_case
id|tok_dep_tristate
suffix:colon
r_case
id|tok_int
suffix:colon
r_case
id|tok_hex
suffix:colon
r_case
id|tok_string
suffix:colon
r_case
id|tok_choose
suffix:colon
id|tot
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_choice
suffix:colon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
op_star
id|menu_max
op_assign
id|cfg-&gt;menu_number
suffix:semicolon
op_star
id|menu_maxlines
op_assign
id|tot
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the top level function for generating the tk script.&n; */
DECL|function|dump_tk_script
r_void
id|dump_tk_script
c_func
(paren
r_struct
id|kconfig
op_star
id|scfg
)paren
(brace
r_int
id|menu_num
op_assign
l_int|0
suffix:semicolon
r_int
id|menu_max
op_assign
l_int|0
suffix:semicolon
r_int
id|menu_min
op_assign
l_int|0
suffix:semicolon
r_int
id|menu_line
op_assign
l_int|0
suffix:semicolon
r_int
id|menu_maxlines
op_assign
l_int|0
suffix:semicolon
r_struct
id|kconfig
op_star
id|cfg
suffix:semicolon
r_struct
id|kconfig
op_star
id|cfg1
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|menulabel
op_assign
l_string|&quot;tkgen error&quot;
suffix:semicolon
multiline_comment|/*&n;   * Start by assigning menu numbers, and submenu numbers.&n;   */
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|cfg-&gt;tok
)paren
(brace
r_case
id|tok_menuname
suffix:colon
r_break
suffix:semicolon
r_case
id|tok_menuoption
suffix:colon
multiline_comment|/*&n;&t;   * At the start of a new menu, calculate the number of items&n;&t;   * we will put into each submenu so we know when to bump the&n;&t;   * menu number. The submenus are really no different from a&n;&t;   * normal menu, but the top level buttons only access the first&n;&t;   * of the chain of menus, and the prev/next buttons are used&n;&t;   * access the submenus.&n;&t;   */
id|cfg-&gt;menu_number
op_assign
op_increment
id|menu_num
suffix:semicolon
id|find_menu_size
c_func
(paren
id|cfg
comma
op_amp
id|menu_max
comma
op_amp
id|menu_maxlines
)paren
suffix:semicolon
id|cfg-&gt;submenu_start
op_assign
id|menu_num
suffix:semicolon
id|cfg-&gt;submenu_end
op_assign
id|menu_max
suffix:semicolon
id|menu_line
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_bool
suffix:colon
r_case
id|tok_tristate
suffix:colon
r_case
id|tok_dep_tristate
suffix:colon
r_case
id|tok_int
suffix:colon
r_case
id|tok_hex
suffix:colon
r_case
id|tok_string
suffix:colon
r_case
id|tok_choose
suffix:colon
multiline_comment|/*&n;&t;   * If we have overfilled the menu, then go to the next one.&n;&t;   */
r_if
c_cond
(paren
id|menu_line
op_eq
id|menu_maxlines
)paren
(brace
id|menu_line
op_assign
l_int|0
suffix:semicolon
id|menu_num
op_increment
suffix:semicolon
)brace
id|cfg-&gt;menu_number
op_assign
id|menu_num
suffix:semicolon
id|cfg-&gt;submenu_start
op_assign
id|menu_min
suffix:semicolon
id|cfg-&gt;submenu_end
op_assign
id|menu_max
suffix:semicolon
id|cfg-&gt;menu_line
op_assign
id|menu_line
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_define
suffix:colon
id|cfg-&gt;menu_number
op_assign
op_minus
l_int|1
suffix:semicolon
r_case
id|tok_choice
suffix:colon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/*&n;   * Record this so we can set up the prev/next buttons correctly.&n;   */
id|tot_menu_num
op_assign
id|menu_num
suffix:semicolon
multiline_comment|/*&n;   * Now start generating the actual wish script that we will use.&n;   * We need to keep track of the menu numbers of the min/max menu&n;   * for a range of submenus so that we can correctly limit the&n;   * prev and next buttons so that they don&squot;t go over into some other&n;   * category.&n;   */
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|cfg-&gt;tok
)paren
(brace
r_case
id|tok_menuname
suffix:colon
id|printf
c_func
(paren
l_string|&quot;mainmenu_name &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|cfg-&gt;label
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_menuoption
suffix:colon
multiline_comment|/*&n;&t;   * We are at the start of a new menu. If we had one that&n;&t;   * we were working on before, close it out, and then generate&n;&t;   * the script to start the new one.&n;&t;   */
r_if
c_cond
(paren
id|cfg-&gt;menu_number
OG
l_int|1
)paren
(brace
id|end_proc
c_func
(paren
id|menu_num
)paren
suffix:semicolon
)brace
id|menulabel
op_assign
id|cfg-&gt;label
suffix:semicolon
id|start_proc
c_func
(paren
id|cfg-&gt;label
comma
id|cfg-&gt;menu_number
comma
id|TRUE
)paren
suffix:semicolon
id|menu_num
op_assign
id|cfg-&gt;menu_number
suffix:semicolon
id|menu_max
op_assign
id|cfg-&gt;submenu_end
suffix:semicolon
id|menu_min
op_assign
id|cfg-&gt;submenu_start
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_bool
suffix:colon
multiline_comment|/*&n;&t;   * If we reached the point where we need to switch over&n;&t;   * to the next submenu, then bump the menu number and generate&n;&t;   * the code to close out the old menu and start the new one.&n;&t;   */
r_if
c_cond
(paren
id|cfg-&gt;menu_number
op_ne
id|menu_num
)paren
(brace
id|end_proc
c_func
(paren
id|menu_num
)paren
suffix:semicolon
id|start_proc
c_func
(paren
id|menulabel
comma
id|cfg-&gt;menu_number
comma
id|FALSE
)paren
suffix:semicolon
id|menu_num
op_assign
id|cfg-&gt;menu_number
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tbool $w.config.f %d %d &bslash;&quot;%s&bslash;&quot; %s&bslash;n&quot;
comma
id|cfg-&gt;menu_number
comma
id|cfg-&gt;menu_line
comma
id|cfg-&gt;label
comma
id|cfg-&gt;optionname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_choice
suffix:colon
id|printf
c_func
(paren
l_string|&quot;&bslash;t$w.config.f.x%d.x.menu add radiobutton -label &bslash;&quot;%s&bslash;&quot; -variable %s -value &bslash;&quot;%s&bslash;&quot; -command &bslash;&quot;update_menu%d .menu%d.config.f&bslash;&quot;&bslash;n&quot;
comma
id|cfg1-&gt;menu_line
comma
id|cfg-&gt;label
comma
id|cfg1-&gt;optionname
comma
id|cfg-&gt;label
comma
id|cfg1-&gt;menu_number
comma
id|cfg1-&gt;menu_number
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_choose
suffix:colon
r_if
c_cond
(paren
id|cfg-&gt;menu_number
op_ne
id|menu_num
)paren
(brace
id|end_proc
c_func
(paren
id|menu_num
)paren
suffix:semicolon
id|start_proc
c_func
(paren
id|menulabel
comma
id|cfg-&gt;menu_number
comma
id|FALSE
)paren
suffix:semicolon
id|menu_num
op_assign
id|cfg-&gt;menu_number
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tglobal %s&bslash;n&quot;
comma
id|cfg-&gt;optionname
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tminimenu $w.config.f %d %d &bslash;&quot;%s&bslash;&quot; %s %s&bslash;n&quot;
comma
id|cfg-&gt;menu_number
comma
id|cfg-&gt;menu_line
comma
id|cfg-&gt;label
comma
id|cfg-&gt;optionname
comma
multiline_comment|/*&n;&t;  &t; * We rely on the fact that the first tok_choice corresponding&n;&t;  &t; * to the current tok_choose is cfg-&gt;next (compare parse() in&n;&t;  &t; * tkparse.c).  We need its name to pick out the right help&n;&t;  &t; * text from Configure.help.&n;&t;  &t; */
id|cfg-&gt;next-&gt;optionname
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tmenu $w.config.f.x%d.x.menu&bslash;n&quot;
comma
id|cfg-&gt;menu_line
)paren
suffix:semicolon
id|cfg1
op_assign
id|cfg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_tristate
suffix:colon
r_if
c_cond
(paren
id|cfg-&gt;menu_number
op_ne
id|menu_num
)paren
(brace
id|end_proc
c_func
(paren
id|menu_num
)paren
suffix:semicolon
id|start_proc
c_func
(paren
id|menulabel
comma
id|cfg-&gt;menu_number
comma
id|FALSE
)paren
suffix:semicolon
id|menu_num
op_assign
id|cfg-&gt;menu_number
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;ttristate $w.config.f %d %d &bslash;&quot;%s&bslash;&quot; %s&bslash;n&quot;
comma
id|cfg-&gt;menu_number
comma
id|cfg-&gt;menu_line
comma
id|cfg-&gt;label
comma
id|cfg-&gt;optionname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_dep_tristate
suffix:colon
r_if
c_cond
(paren
id|cfg-&gt;menu_number
op_ne
id|menu_num
)paren
(brace
id|end_proc
c_func
(paren
id|menu_num
)paren
suffix:semicolon
id|start_proc
c_func
(paren
id|menulabel
comma
id|cfg-&gt;menu_number
comma
id|FALSE
)paren
suffix:semicolon
id|menu_num
op_assign
id|cfg-&gt;menu_number
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tdep_tristate $w.config.f %d %d &bslash;&quot;%s&bslash;&quot; %s %s&bslash;n&quot;
comma
id|cfg-&gt;menu_number
comma
id|cfg-&gt;menu_line
comma
id|cfg-&gt;label
comma
id|cfg-&gt;optionname
comma
id|cfg-&gt;depend.str
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_int
suffix:colon
r_if
c_cond
(paren
id|cfg-&gt;menu_number
op_ne
id|menu_num
)paren
(brace
id|end_proc
c_func
(paren
id|menu_num
)paren
suffix:semicolon
id|start_proc
c_func
(paren
id|menulabel
comma
id|cfg-&gt;menu_number
comma
id|FALSE
)paren
suffix:semicolon
id|menu_num
op_assign
id|cfg-&gt;menu_number
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tint $w.config.f %d %d &bslash;&quot;%s&bslash;&quot; %s&bslash;n&quot;
comma
id|cfg-&gt;menu_number
comma
id|cfg-&gt;menu_line
comma
id|cfg-&gt;label
comma
id|cfg-&gt;optionname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_hex
suffix:colon
r_if
c_cond
(paren
id|cfg-&gt;menu_number
op_ne
id|menu_num
)paren
(brace
id|end_proc
c_func
(paren
id|menu_num
)paren
suffix:semicolon
id|start_proc
c_func
(paren
id|menulabel
comma
id|cfg-&gt;menu_number
comma
id|FALSE
)paren
suffix:semicolon
id|menu_num
op_assign
id|cfg-&gt;menu_number
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;thex $w.config.f %d %d &bslash;&quot;%s&bslash;&quot; %s&bslash;n&quot;
comma
id|cfg-&gt;menu_number
comma
id|cfg-&gt;menu_line
comma
id|cfg-&gt;label
comma
id|cfg-&gt;optionname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_string
suffix:colon
r_if
c_cond
(paren
id|cfg-&gt;menu_number
op_ne
id|menu_num
)paren
(brace
id|end_proc
c_func
(paren
id|menu_num
)paren
suffix:semicolon
id|start_proc
c_func
(paren
id|menulabel
comma
id|cfg-&gt;menu_number
comma
id|FALSE
)paren
suffix:semicolon
id|menu_num
op_assign
id|cfg-&gt;menu_number
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tistring $w.config.f %d %d &bslash;&quot;%s&bslash;&quot; %s&bslash;n&quot;
comma
id|cfg-&gt;menu_number
comma
id|cfg-&gt;menu_line
comma
id|cfg-&gt;label
comma
id|cfg-&gt;optionname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Generate the code to close out the last menu.&n;   */
id|end_proc
c_func
(paren
id|menu_num
)paren
suffix:semicolon
multiline_comment|/*&n;   * The top level menu also needs an update function.  When we exit a&n;   * submenu, we may need to disable one or more of the submenus on&n;   * the top level menu, and this procedure will ensure that things are&n;   * correct.&n;   */
id|printf
c_func
(paren
l_string|&quot;proc update_mainmenu {w}  {&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|cfg-&gt;tok
)paren
(brace
r_case
id|tok_menuoption
suffix:colon
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
id|generate_if
c_func
(paren
id|cfg
comma
id|cfg-&gt;cond
comma
id|cfg-&gt;menu_number
comma
id|cfg-&gt;menu_line
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;}&bslash;n&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;   * Generate some code to set the variables that are &quot;defined&quot;.&n;   */
r_for
c_loop
(paren
id|cfg
op_assign
id|config
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
multiline_comment|/*&n;       * Skip items not for this menu, or ones having no conditions.&n;       */
r_if
c_cond
(paren
id|cfg-&gt;tok
op_ne
id|tok_define
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
id|generate_if
c_func
(paren
id|cfg
comma
id|cfg-&gt;cond
comma
id|menu_num
comma
id|cfg-&gt;menu_line
)paren
suffix:semicolon
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;twrite_define %s %s&bslash;n&quot;
comma
id|cfg-&gt;optionname
comma
id|cfg-&gt;value
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;   * Now generate code to load the default settings into the variables.&n;   * Note that the script in tail.tk will attempt to load .config,&n;   * which may override these settings, but that&squot;s OK.&n;   */
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|cfg-&gt;tok
)paren
(brace
r_case
id|tok_bool
suffix:colon
r_case
id|tok_tristate
suffix:colon
r_case
id|tok_dep_tristate
suffix:colon
r_case
id|tok_choice
suffix:colon
id|printf
c_func
(paren
l_string|&quot;set %s 0&bslash;n&quot;
comma
id|cfg-&gt;optionname
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_int
suffix:colon
r_case
id|tok_hex
suffix:colon
r_case
id|tok_string
suffix:colon
id|printf
c_func
(paren
l_string|&quot;set %s %s&bslash;n&quot;
comma
id|cfg-&gt;optionname
comma
id|cfg-&gt;value
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|tok_choose
suffix:colon
id|printf
c_func
(paren
l_string|&quot;set %s &bslash;&quot;(not set)&bslash;&quot;&bslash;n&quot;
comma
id|cfg-&gt;optionname
)paren
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Next generate a function that can be called from the main menu that will&n;   * write all of the variables out.  This also serves double duty - we can&n;   * save configuration to a file using this.&n;   */
id|printf
c_func
(paren
l_string|&quot;proc writeconfig {file1 file2} {&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset cfg [open $file1 w]&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset autocfg [open $file2 w]&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset notmod 1&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tset notset 0&bslash;n&quot;
)paren
suffix:semicolon
id|clear_globalflags
c_func
(paren
id|config
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tputs $cfg &bslash;&quot;#&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tputs $cfg &bslash;&quot;# Automatically generated make config: don&squot;t edit&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tputs $cfg &bslash;&quot;#&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tputs $autocfg &bslash;&quot;/*&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tputs $autocfg &bslash;&quot; * Automatically generated C config: don&squot;t edit&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tputs $autocfg &bslash;&quot; */&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tputs $autocfg &bslash;&quot;#define AUTOCONF_INCLUDED&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_switch
c_cond
(paren
id|cfg-&gt;tok
)paren
(brace
r_case
id|tok_int
suffix:colon
r_case
id|tok_hex
suffix:colon
r_case
id|tok_string
suffix:colon
r_case
id|tok_bool
suffix:colon
r_case
id|tok_tristate
suffix:colon
r_case
id|tok_dep_tristate
suffix:colon
r_case
id|tok_define
suffix:colon
r_case
id|tok_choose
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cfg-&gt;flags
op_amp
id|GLOBAL_WRITTEN
)paren
)paren
(brace
id|cfg-&gt;flags
op_or_assign
id|GLOBAL_WRITTEN
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tglobal %s&bslash;n&quot;
comma
id|cfg-&gt;optionname
)paren
suffix:semicolon
)brace
multiline_comment|/* fall through */
r_case
id|tok_comment
suffix:colon
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
id|generate_if_for_outfile
c_func
(paren
id|cfg
comma
id|cfg-&gt;cond
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|cfg-&gt;tok
op_eq
id|tok_dep_tristate
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tif {$%s == 0 } then {&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;twrite_tristate $cfg $autocfg %s $notset $notmod&bslash;n&quot;
l_string|&quot;&bslash;t} else {&bslash;n&quot;
l_string|&quot;&bslash;t&bslash;twrite_tristate $cfg $autocfg %s $%s $%s&bslash;n&quot;
l_string|&quot;&bslash;t}&bslash;n&quot;
comma
id|cfg-&gt;depend.str
comma
id|cfg-&gt;optionname
comma
id|cfg-&gt;optionname
comma
id|cfg-&gt;optionname
comma
id|cfg-&gt;depend.str
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cfg-&gt;tok
op_eq
id|tok_comment
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;twrite_comment $cfg $autocfg &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|cfg-&gt;label
)paren
suffix:semicolon
)brace
macro_line|#if 0
r_else
r_if
c_cond
(paren
id|cfg-&gt;tok
op_eq
id|tok_define
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;twrite_define %s %s&bslash;n&quot;
comma
id|cfg-&gt;optionname
comma
id|cfg-&gt;value
)paren
suffix:semicolon
)brace
macro_line|#endif
r_else
r_if
c_cond
(paren
id|cfg-&gt;tok
op_eq
id|tok_choose
)paren
(brace
r_for
c_loop
(paren
id|cfg1
op_assign
id|cfg-&gt;next
suffix:semicolon
id|cfg1
op_ne
l_int|NULL
op_logical_and
id|cfg1-&gt;tok
op_eq
id|tok_choice
suffix:semicolon
id|cfg1
op_assign
id|cfg1-&gt;next
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tif { $%s == &bslash;&quot;%s&bslash;&quot; } then { write_tristate $cfg $autocfg %s 1 $notmod } else { write_tristate $cfg $autocfg %s 0 $notmod }&bslash;n&quot;
comma
id|cfg-&gt;optionname
comma
id|cfg1-&gt;label
comma
id|cfg1-&gt;optionname
comma
id|cfg1-&gt;optionname
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|cfg-&gt;tok
op_eq
id|tok_int
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;twrite_int $cfg $autocfg %s $%s $notmod&bslash;n&quot;
comma
id|cfg-&gt;optionname
comma
id|cfg-&gt;optionname
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cfg-&gt;tok
op_eq
id|tok_hex
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;twrite_hex $cfg $autocfg %s $%s $notmod&bslash;n&quot;
comma
id|cfg-&gt;optionname
comma
id|cfg-&gt;optionname
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cfg-&gt;tok
op_eq
id|tok_string
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;twrite_string $cfg $autocfg %s $%s $notmod&bslash;n&quot;
comma
id|cfg-&gt;optionname
comma
id|cfg-&gt;optionname
)paren
suffix:semicolon
)brace
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;twrite_tristate $cfg $autocfg %s $%s $notmod&bslash;n&quot;
comma
id|cfg-&gt;optionname
comma
id|cfg-&gt;optionname
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tclose $cfg&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tclose $autocfg&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;}&bslash;n&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;   * Finally write a simple function that updates the master choice&n;   * variable depending upon what values were loaded from a .config&n;   * file.  &n;   */
id|printf
c_func
(paren
l_string|&quot;proc clear_choices { } {&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cfg-&gt;tok
op_ne
id|tok_choose
)paren
(brace
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cfg1
op_assign
id|cfg-&gt;next
suffix:semicolon
id|cfg1
op_ne
l_int|NULL
op_logical_and
id|cfg1-&gt;tok
op_eq
id|tok_choice
suffix:semicolon
id|cfg1
op_assign
id|cfg1-&gt;next
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tglobal %s; set %s 0&bslash;n&quot;
comma
id|cfg1-&gt;optionname
comma
id|cfg1-&gt;optionname
)paren
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;}&bslash;n&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;proc update_choices { } {&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cfg-&gt;tok
op_ne
id|tok_choose
)paren
(brace
r_continue
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tglobal %s&bslash;n&quot;
comma
id|cfg-&gt;optionname
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cfg1
op_assign
id|cfg-&gt;next
suffix:semicolon
id|cfg1
op_ne
l_int|NULL
op_logical_and
id|cfg1-&gt;tok
op_eq
id|tok_choice
suffix:semicolon
id|cfg1
op_assign
id|cfg1-&gt;next
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tglobal %s&bslash;n&quot;
comma
id|cfg1-&gt;optionname
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;tif { $%s == 1 } then { set %s &bslash;&quot;%s&bslash;&quot; }&bslash;n&quot;
comma
id|cfg1-&gt;optionname
comma
id|cfg-&gt;optionname
comma
id|cfg1-&gt;label
)paren
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;}&bslash;n&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;proc update_define { } {&bslash;n&quot;
)paren
suffix:semicolon
id|clear_globalflags
c_func
(paren
id|config
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cfg-&gt;tok
op_ne
id|tok_define
)paren
(brace
r_continue
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tglobal %s; set %s 0&bslash;n&quot;
comma
id|cfg-&gt;optionname
comma
id|cfg-&gt;optionname
)paren
suffix:semicolon
id|cfg-&gt;flags
op_or_assign
id|GLOBAL_WRITTEN
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cfg
op_assign
id|scfg
suffix:semicolon
id|cfg
op_ne
l_int|NULL
suffix:semicolon
id|cfg
op_assign
id|cfg-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|cfg-&gt;tok
op_ne
id|tok_define
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cfg-&gt;cond
op_ne
l_int|NULL
)paren
id|generate_if
c_func
(paren
id|cfg
comma
id|cfg-&gt;cond
comma
op_minus
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_else
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;tset %s %s&bslash;n&quot;
comma
id|cfg-&gt;optionname
comma
id|cfg-&gt;value
)paren
suffix:semicolon
)brace
)brace
id|printf
c_func
(paren
l_string|&quot;}&bslash;n&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;   * That&squot;s it.  We are done.  The output of this file will have header.tk&n;   * prepended and tail.tk appended to create an executable wish script.&n;   */
)brace
eof
