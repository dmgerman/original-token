multiline_comment|/*&n; *  linux/fs/fcntl.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/string.h&gt;
r_extern
r_int
id|fcntl_getlk
c_func
(paren
r_int
r_int
comma
r_struct
id|flock
op_star
)paren
suffix:semicolon
r_extern
r_int
id|fcntl_setlk
c_func
(paren
r_int
r_int
comma
r_int
r_int
comma
r_struct
id|flock
op_star
)paren
suffix:semicolon
r_extern
r_int
id|sock_fcntl
(paren
r_struct
id|file
op_star
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
DECL|function|dupfd
r_static
r_int
id|dupfd
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|arg
)paren
(brace
r_if
c_cond
(paren
id|fd
op_ge
id|NR_OPEN
op_logical_or
op_logical_neg
id|current-&gt;files-&gt;fd
(braket
id|fd
)braket
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_ge
id|NR_OPEN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_while
c_loop
(paren
id|arg
OL
id|NR_OPEN
)paren
r_if
c_cond
(paren
id|current-&gt;files-&gt;fd
(braket
id|arg
)braket
)paren
id|arg
op_increment
suffix:semicolon
r_else
r_break
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_ge
id|NR_OPEN
)paren
r_return
op_minus
id|EMFILE
suffix:semicolon
id|FD_CLR
c_func
(paren
id|arg
comma
op_amp
id|current-&gt;files-&gt;close_on_exec
)paren
suffix:semicolon
(paren
id|current-&gt;files-&gt;fd
(braket
id|arg
)braket
op_assign
id|current-&gt;files-&gt;fd
(braket
id|fd
)braket
)paren
op_member_access_from_pointer
id|f_count
op_increment
suffix:semicolon
r_return
id|arg
suffix:semicolon
)brace
DECL|function|sys_dup2
id|asmlinkage
r_int
id|sys_dup2
c_func
(paren
r_int
r_int
id|oldfd
comma
r_int
r_int
id|newfd
)paren
(brace
r_if
c_cond
(paren
id|oldfd
op_ge
id|NR_OPEN
op_logical_or
op_logical_neg
id|current-&gt;files-&gt;fd
(braket
id|oldfd
)braket
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
r_if
c_cond
(paren
id|newfd
op_eq
id|oldfd
)paren
r_return
id|newfd
suffix:semicolon
multiline_comment|/*&n;&t; * errno&squot;s for dup2() are slightly different than for fcntl(F_DUPFD)&n;&t; * for historical reasons.&n;&t; */
r_if
c_cond
(paren
id|newfd
OG
id|NR_OPEN
)paren
multiline_comment|/* historical botch - should have been &gt;= */
r_return
op_minus
id|EBADF
suffix:semicolon
multiline_comment|/* dupfd() would return -EINVAL */
macro_line|#if 1
r_if
c_cond
(paren
id|newfd
op_eq
id|NR_OPEN
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
multiline_comment|/* dupfd() does return -EINVAL and that may&n;&t;&t;&t;&t; * even be the standard!  But that is too&n;&t;&t;&t;&t; * weird for now.&n;&t;&t;&t;&t; */
macro_line|#endif
id|sys_close
c_func
(paren
id|newfd
)paren
suffix:semicolon
r_return
id|dupfd
c_func
(paren
id|oldfd
comma
id|newfd
)paren
suffix:semicolon
)brace
DECL|function|sys_dup
id|asmlinkage
r_int
id|sys_dup
c_func
(paren
r_int
r_int
id|fildes
)paren
(brace
r_return
id|dupfd
c_func
(paren
id|fildes
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|sys_fcntl
id|asmlinkage
r_int
id|sys_fcntl
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|task_found
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fd
op_ge
id|NR_OPEN
op_logical_or
op_logical_neg
(paren
id|filp
op_assign
id|current-&gt;files-&gt;fd
(braket
id|fd
)braket
)paren
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|F_DUPFD
suffix:colon
r_return
id|dupfd
c_func
(paren
id|fd
comma
id|arg
)paren
suffix:semicolon
r_case
id|F_GETFD
suffix:colon
r_return
id|FD_ISSET
c_func
(paren
id|fd
comma
op_amp
id|current-&gt;files-&gt;close_on_exec
)paren
suffix:semicolon
r_case
id|F_SETFD
suffix:colon
r_if
c_cond
(paren
id|arg
op_amp
l_int|1
)paren
id|FD_SET
c_func
(paren
id|fd
comma
op_amp
id|current-&gt;files-&gt;close_on_exec
)paren
suffix:semicolon
r_else
id|FD_CLR
c_func
(paren
id|fd
comma
op_amp
id|current-&gt;files-&gt;close_on_exec
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|F_GETFL
suffix:colon
r_return
id|filp-&gt;f_flags
suffix:semicolon
r_case
id|F_SETFL
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * In the case of an append-only file, O_APPEND&n;&t;&t;&t; * cannot be cleared&n;&t;&t;&t; */
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|filp-&gt;f_inode
)paren
op_logical_and
op_logical_neg
(paren
id|arg
op_amp
id|O_APPEND
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg
op_amp
id|FASYNC
)paren
op_logical_and
op_logical_neg
(paren
id|filp-&gt;f_flags
op_amp
id|FASYNC
)paren
op_logical_and
id|filp-&gt;f_op-&gt;fasync
)paren
id|filp-&gt;f_op
op_member_access_from_pointer
id|fasync
c_func
(paren
id|filp-&gt;f_inode
comma
id|filp
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|arg
op_amp
id|FASYNC
)paren
op_logical_and
(paren
id|filp-&gt;f_flags
op_amp
id|FASYNC
)paren
op_logical_and
id|filp-&gt;f_op-&gt;fasync
)paren
id|filp-&gt;f_op
op_member_access_from_pointer
id|fasync
c_func
(paren
id|filp-&gt;f_inode
comma
id|filp
comma
l_int|0
)paren
suffix:semicolon
id|filp-&gt;f_flags
op_and_assign
op_complement
(paren
id|O_APPEND
op_or
id|O_NONBLOCK
op_or
id|FASYNC
)paren
suffix:semicolon
id|filp-&gt;f_flags
op_or_assign
id|arg
op_amp
(paren
id|O_APPEND
op_or
id|O_NONBLOCK
op_or
id|FASYNC
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|F_GETLK
suffix:colon
r_return
id|fcntl_getlk
c_func
(paren
id|fd
comma
(paren
r_struct
id|flock
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|F_SETLK
suffix:colon
r_return
id|fcntl_setlk
c_func
(paren
id|fd
comma
id|cmd
comma
(paren
r_struct
id|flock
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|F_SETLKW
suffix:colon
r_return
id|fcntl_setlk
c_func
(paren
id|fd
comma
id|cmd
comma
(paren
r_struct
id|flock
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|F_GETOWN
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * XXX If f_owner is a process group, the&n;&t;&t;&t; * negative return value will get converted&n;&t;&t;&t; * into an error.  Oops.  If we keep the the&n;&t;&t;&t; * current syscall conventions, the only way&n;&t;&t;&t; * to fix this will be in libc.&n;&t;&t;&t; */
r_return
id|filp-&gt;f_owner
suffix:semicolon
r_case
id|F_SETOWN
suffix:colon
multiline_comment|/*&n;&t;&t;&t; *&t;Add the security checks - AC. Without&n;&t;&t;&t; *&t;this there is a massive Linux security&n;&t;&t;&t; *&t;hole here - consider what happens if&n;&t;&t;&t; *&t;you do something like&n;&t;&t;&t; * &n;&t;&t;&t; *&t;&t;fcntl(0,F_SETOWN,some_root_process);&n;&t;&t;&t; *&t;&t;getchar();&n;&t;&t;&t; * &n;&t;&t;&t; *&t;and input a line!&n;&t;&t;&t; * &n;&t;&t;&t; * BTW: Don&squot;t try this for fun. Several Unix&n;&t;&t;&t; *&t;systems I tried this on fall for the&n;&t;&t;&t; *&t;trick!&n;&t;&t;&t; * &n;&t;&t;&t; * I had to fix this botch job as Linux&n;&t;&t;&t; *&t;kill_fasync asserts priv making it a&n;&t;&t;&t; *&t;free all user process killer!&n;&t;&t;&t; *&n;&t;&t;&t; * Changed to make the security checks more&n;&t;&t;&t; * liberal.  -- TYT&n;&t;&t;&t; */
r_if
c_cond
(paren
id|current-&gt;pgrp
op_eq
op_minus
id|arg
op_logical_or
id|current-&gt;pid
op_eq
id|arg
)paren
r_goto
id|fasync_ok
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
(paren
id|p-&gt;pid
op_eq
id|arg
)paren
op_logical_or
(paren
id|p-&gt;pid
op_eq
op_minus
id|arg
)paren
op_logical_or
(paren
id|p-&gt;pgrp
op_eq
op_minus
id|arg
)paren
)paren
(brace
id|task_found
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;session
op_ne
id|current-&gt;session
)paren
op_logical_and
(paren
id|p-&gt;uid
op_ne
id|current-&gt;uid
)paren
op_logical_and
(paren
id|p-&gt;euid
op_ne
id|current-&gt;euid
)paren
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|task_found
op_eq
l_int|0
)paren
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|fasync_ok
suffix:colon
id|filp-&gt;f_owner
op_assign
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|S_ISSOCK
(paren
id|filp-&gt;f_inode-&gt;i_mode
)paren
)paren
id|sock_fcntl
(paren
id|filp
comma
id|F_SETOWN
comma
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* sockets need a few special fcntls. */
r_if
c_cond
(paren
id|S_ISSOCK
(paren
id|filp-&gt;f_inode-&gt;i_mode
)paren
)paren
(brace
r_return
(paren
id|sock_fcntl
(paren
id|filp
comma
id|cmd
comma
id|arg
)paren
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|kill_fasync
r_void
id|kill_fasync
c_func
(paren
r_struct
id|fasync_struct
op_star
id|fa
comma
r_int
id|sig
)paren
(brace
r_while
c_loop
(paren
id|fa
)paren
(brace
r_if
c_cond
(paren
id|fa-&gt;magic
op_ne
id|FASYNC_MAGIC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;kill_fasync: bad magic number in &quot;
l_string|&quot;fasync_struct!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fa-&gt;fa_file-&gt;f_owner
OG
l_int|0
)paren
id|kill_proc
c_func
(paren
id|fa-&gt;fa_file-&gt;f_owner
comma
id|sig
comma
l_int|1
)paren
suffix:semicolon
r_else
id|kill_pg
c_func
(paren
op_minus
id|fa-&gt;fa_file-&gt;f_owner
comma
id|sig
comma
l_int|1
)paren
suffix:semicolon
id|fa
op_assign
id|fa-&gt;fa_next
suffix:semicolon
)brace
)brace
eof
