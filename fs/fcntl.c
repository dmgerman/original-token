multiline_comment|/*&n; *  linux/fs/fcntl.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
r_extern
r_int
id|sock_fcntl
(paren
r_struct
id|file
op_star
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
DECL|function|dupfd
r_static
r_inline
r_int
id|dupfd
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|files_struct
op_star
id|files
op_assign
id|current-&gt;files
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_ge
id|NR_OPEN
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EMFILE
suffix:semicolon
id|arg
op_assign
id|find_next_zero_bit
c_func
(paren
op_amp
id|files-&gt;open_fds
comma
id|NR_OPEN
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_ge
id|current-&gt;rlim
(braket
id|RLIMIT_NOFILE
)braket
dot
id|rlim_cur
)paren
r_goto
id|out_putf
suffix:semicolon
id|FD_SET
c_func
(paren
id|arg
comma
op_amp
id|files-&gt;open_fds
)paren
suffix:semicolon
id|FD_CLR
c_func
(paren
id|arg
comma
op_amp
id|files-&gt;close_on_exec
)paren
suffix:semicolon
id|fd_install
c_func
(paren
id|arg
comma
id|file
)paren
suffix:semicolon
id|error
op_assign
id|arg
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
id|out_putf
suffix:colon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|sys_dup2
id|asmlinkage
r_int
id|sys_dup2
c_func
(paren
r_int
r_int
id|oldfd
comma
r_int
r_int
id|newfd
)paren
(brace
r_int
id|err
op_assign
op_minus
id|EBADF
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fcheck
c_func
(paren
id|oldfd
)paren
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|newfd
suffix:semicolon
r_if
c_cond
(paren
id|newfd
op_eq
id|oldfd
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
op_minus
id|EBADF
suffix:semicolon
r_if
c_cond
(paren
id|newfd
op_ge
id|NR_OPEN
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* following POSIX.1 6.2.1 */
id|sys_close
c_func
(paren
id|newfd
)paren
suffix:semicolon
id|err
op_assign
id|dupfd
c_func
(paren
id|oldfd
comma
id|newfd
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sys_dup
id|asmlinkage
r_int
id|sys_dup
c_func
(paren
r_int
r_int
id|fildes
)paren
(brace
r_int
id|ret
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|dupfd
c_func
(paren
id|fildes
comma
l_int|0
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|SETFL_MASK
mdefine_line|#define SETFL_MASK (O_APPEND | O_NONBLOCK | O_NDELAY | FASYNC)
DECL|function|setfl
r_static
r_int
id|setfl
c_func
(paren
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
multiline_comment|/*&n;&t; * In the case of an append-only file, O_APPEND&n;&t; * cannot be cleared&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|arg
op_amp
id|O_APPEND
)paren
op_logical_and
id|IS_APPEND
c_func
(paren
id|inode
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* Did FASYNC state change? */
r_if
c_cond
(paren
(paren
id|arg
op_xor
id|filp-&gt;f_flags
)paren
op_amp
id|FASYNC
)paren
(brace
r_if
c_cond
(paren
id|filp-&gt;f_op
op_logical_and
id|filp-&gt;f_op-&gt;fasync
)paren
id|filp-&gt;f_op
op_member_access_from_pointer
id|fasync
c_func
(paren
id|fd
comma
id|filp
comma
(paren
id|arg
op_amp
id|FASYNC
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* required for strict SunOS emulation */
r_if
c_cond
(paren
id|O_NONBLOCK
op_ne
id|O_NDELAY
)paren
r_if
c_cond
(paren
id|arg
op_amp
id|O_NDELAY
)paren
id|arg
op_or_assign
id|O_NONBLOCK
suffix:semicolon
id|filp-&gt;f_flags
op_assign
(paren
id|arg
op_amp
id|SETFL_MASK
)paren
op_or
(paren
id|filp-&gt;f_flags
op_amp
op_complement
id|SETFL_MASK
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_fcntl
id|asmlinkage
r_int
id|sys_fcntl
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EBADF
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|filp
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|F_DUPFD
suffix:colon
id|err
op_assign
id|dupfd
c_func
(paren
id|fd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_GETFD
suffix:colon
id|err
op_assign
id|FD_ISSET
c_func
(paren
id|fd
comma
op_amp
id|current-&gt;files-&gt;close_on_exec
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_SETFD
suffix:colon
r_if
c_cond
(paren
id|arg
op_amp
l_int|1
)paren
id|FD_SET
c_func
(paren
id|fd
comma
op_amp
id|current-&gt;files-&gt;close_on_exec
)paren
suffix:semicolon
r_else
id|FD_CLR
c_func
(paren
id|fd
comma
op_amp
id|current-&gt;files-&gt;close_on_exec
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_GETFL
suffix:colon
id|err
op_assign
id|filp-&gt;f_flags
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_SETFL
suffix:colon
id|err
op_assign
id|setfl
c_func
(paren
id|fd
comma
id|filp
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_GETLK
suffix:colon
id|err
op_assign
id|fcntl_getlk
c_func
(paren
id|fd
comma
(paren
r_struct
id|flock
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_SETLK
suffix:colon
id|err
op_assign
id|fcntl_setlk
c_func
(paren
id|fd
comma
id|cmd
comma
(paren
r_struct
id|flock
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_SETLKW
suffix:colon
id|err
op_assign
id|fcntl_setlk
c_func
(paren
id|fd
comma
id|cmd
comma
(paren
r_struct
id|flock
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_GETOWN
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * XXX If f_owner is a process group, the&n;&t;&t;&t; * negative return value will get converted&n;&t;&t;&t; * into an error.  Oops.  If we keep the&n;&t;&t;&t; * current syscall conventions, the only way&n;&t;&t;&t; * to fix this will be in libc.&n;&t;&t;&t; */
id|err
op_assign
id|filp-&gt;f_owner.pid
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_SETOWN
suffix:colon
id|err
op_assign
l_int|0
suffix:semicolon
id|filp-&gt;f_owner.pid
op_assign
id|arg
suffix:semicolon
id|filp-&gt;f_owner.uid
op_assign
id|current-&gt;uid
suffix:semicolon
id|filp-&gt;f_owner.euid
op_assign
id|current-&gt;euid
suffix:semicolon
r_if
c_cond
(paren
id|S_ISSOCK
(paren
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_mode
)paren
)paren
id|err
op_assign
id|sock_fcntl
(paren
id|filp
comma
id|F_SETOWN
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_GETSIG
suffix:colon
id|err
op_assign
id|filp-&gt;f_owner.signum
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_SETSIG
suffix:colon
r_if
c_cond
(paren
id|arg
op_le
l_int|0
op_logical_or
id|arg
OG
id|_NSIG
)paren
(brace
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
id|filp-&gt;f_owner.signum
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* sockets need a few special fcntls. */
r_if
c_cond
(paren
id|S_ISSOCK
(paren
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_mode
)paren
)paren
id|err
op_assign
id|sock_fcntl
(paren
id|filp
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_else
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|send_sigio_to_task
r_static
r_void
id|send_sigio_to_task
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_struct
id|fown_struct
op_star
id|fown
comma
r_struct
id|fasync_struct
op_star
id|fa
)paren
(brace
r_if
c_cond
(paren
(paren
id|fown-&gt;euid
op_ne
l_int|0
)paren
op_logical_and
(paren
id|fown-&gt;euid
op_xor
id|p-&gt;suid
)paren
op_logical_and
(paren
id|fown-&gt;euid
op_xor
id|p-&gt;uid
)paren
op_logical_and
(paren
id|fown-&gt;uid
op_xor
id|p-&gt;suid
)paren
op_logical_and
(paren
id|fown-&gt;uid
op_xor
id|p-&gt;uid
)paren
)paren
r_return
suffix:semicolon
r_switch
c_cond
(paren
id|fown-&gt;signum
)paren
(brace
id|siginfo_t
id|si
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Queue a rt signal with the appropriate fd as its&n;&t;&t;&t;   value.  We use SI_SIGIO as the source, not &n;&t;&t;&t;   SI_KERNEL, since kernel signals always get &n;&t;&t;&t;   delivered even if we can&squot;t queue.  Failure to&n;&t;&t;&t;   queue in this case _should_ be reported; we fall&n;&t;&t;&t;   back to SIGIO in that case. --sct */
id|si.si_signo
op_assign
id|fown-&gt;signum
suffix:semicolon
id|si.si_errno
op_assign
l_int|0
suffix:semicolon
id|si.si_code
op_assign
id|SI_SIGIO
suffix:semicolon
id|si.si_pid
op_assign
id|fown-&gt;pid
suffix:semicolon
id|si.si_uid
op_assign
id|fown-&gt;uid
suffix:semicolon
id|si.si_fd
op_assign
id|fa-&gt;fa_fd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|send_sig_info
c_func
(paren
id|fown-&gt;signum
comma
op_amp
id|si
comma
id|p
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* fall-through: fall back on the old plain SIGIO signal */
r_case
l_int|0
suffix:colon
id|send_sig
c_func
(paren
id|SIGIO
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
DECL|function|send_sigio
r_static
r_void
id|send_sigio
c_func
(paren
r_struct
id|fown_struct
op_star
id|fown
comma
r_struct
id|fasync_struct
op_star
id|fa
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|pid
op_assign
id|fown-&gt;pid
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pid
OG
l_int|0
)paren
op_logical_and
(paren
id|p
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
)paren
)paren
(brace
id|send_sigio_to_task
c_func
(paren
id|p
comma
id|fown
comma
id|fa
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|for_each_task
c_func
(paren
id|p
)paren
(brace
r_int
id|match
op_assign
id|p-&gt;pid
suffix:semicolon
r_if
c_cond
(paren
id|pid
OL
l_int|0
)paren
id|match
op_assign
op_minus
id|p-&gt;pgrp
suffix:semicolon
r_if
c_cond
(paren
id|pid
op_ne
id|match
)paren
r_continue
suffix:semicolon
id|send_sigio_to_task
c_func
(paren
id|p
comma
id|fown
comma
id|fa
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
DECL|function|kill_fasync
r_void
id|kill_fasync
c_func
(paren
r_struct
id|fasync_struct
op_star
id|fa
comma
r_int
id|sig
)paren
(brace
r_while
c_loop
(paren
id|fa
)paren
(brace
r_struct
id|fown_struct
op_star
id|fown
suffix:semicolon
r_if
c_cond
(paren
id|fa-&gt;magic
op_ne
id|FASYNC_MAGIC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;kill_fasync: bad magic number in &quot;
l_string|&quot;fasync_struct!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|fown
op_assign
op_amp
id|fa-&gt;fa_file-&gt;f_owner
suffix:semicolon
r_if
c_cond
(paren
id|fown-&gt;pid
)paren
id|send_sigio
c_func
(paren
id|fown
comma
id|fa
)paren
suffix:semicolon
id|fa
op_assign
id|fa-&gt;fa_next
suffix:semicolon
)brace
)brace
eof
