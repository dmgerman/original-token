multiline_comment|/*&n; * linux/fs/hfs/dir.c&n; *&n; * Copyright (C) 1995-1997  Paul H. Hargrove&n; * This file may be distributed under the terms of the GNU Public License.&n; *&n; * This file contains directory-related functions independent of which&n; * scheme is being used to represent forks.&n; *&n; * Based on the minix file system code, (C) 1991, 1992 by Linus Torvalds&n; *&n; * &quot;XXX&quot; in a comment is a note to myself to consider changing something.&n; *&n; * In function preconditions the term &quot;valid&quot; applied to a pointer to&n; * a structure means that the pointer is non-NULL and the structure it&n; * points to has all fields initialized to consistent values.&n; */
macro_line|#include &quot;hfs.h&quot;
macro_line|#include &lt;linux/hfs_fs_sb.h&gt;
macro_line|#include &lt;linux/hfs_fs_i.h&gt;
macro_line|#include &lt;linux/hfs_fs.h&gt;
multiline_comment|/*================ File-local functions ================*/
multiline_comment|/*&n; * build_key()&n; *&n; * Build a key for a file by the given name in the given directory.&n; * If the name matches one of the reserved names returns 1 otherwise 0.&n; */
DECL|function|build_key
r_static
r_int
id|build_key
c_func
(paren
r_struct
id|hfs_cat_key
op_star
id|key
comma
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
r_struct
id|hfs_name
id|cname
suffix:semicolon
r_const
r_struct
id|hfs_name
op_star
id|reserved
suffix:semicolon
multiline_comment|/* mangle the name */
id|hfs_nameout
c_func
(paren
id|dir
comma
op_amp
id|cname
comma
id|name
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* check against reserved names */
id|reserved
op_assign
id|HFS_SB
c_func
(paren
id|dir-&gt;i_sb
)paren
op_member_access_from_pointer
id|s_reserved1
suffix:semicolon
r_while
c_loop
(paren
id|reserved-&gt;Len
)paren
(brace
r_if
c_cond
(paren
id|hfs_streq
c_func
(paren
id|reserved-&gt;Name
comma
id|reserved-&gt;Len
comma
id|cname.Name
comma
id|cname.Len
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
op_increment
id|reserved
suffix:semicolon
)brace
multiline_comment|/* check against the names reserved only in the root directory */
r_if
c_cond
(paren
id|HFS_I
c_func
(paren
id|dir
)paren
op_member_access_from_pointer
id|entry-&gt;cnid
op_eq
id|htonl
c_func
(paren
id|HFS_ROOT_CNID
)paren
)paren
(brace
id|reserved
op_assign
id|HFS_SB
c_func
(paren
id|dir-&gt;i_sb
)paren
op_member_access_from_pointer
id|s_reserved2
suffix:semicolon
r_while
c_loop
(paren
id|reserved-&gt;Len
)paren
(brace
r_if
c_cond
(paren
id|hfs_streq
c_func
(paren
id|reserved-&gt;Name
comma
id|reserved-&gt;Len
comma
id|cname.Name
comma
id|cname.Len
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
op_increment
id|reserved
suffix:semicolon
)brace
)brace
multiline_comment|/* build the key */
id|hfs_cat_build_key
c_func
(paren
id|HFS_I
c_func
(paren
id|dir
)paren
op_member_access_from_pointer
id|entry-&gt;cnid
comma
op_amp
id|cname
comma
id|key
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * update_dirs_plus()&n; *&n; * Update the fields &squot;i_size&squot;, &squot;i_nlink&squot;, &squot;i_ctime&squot;, &squot;i_mtime&squot; and&n; * &squot;i_version&squot; of the inodes associated with a directory that has&n; * had a file (&squot;is_dir&squot;==0) or directory (&squot;is_dir&squot;!=0) added to it.&n; */
DECL|function|update_dirs_plus
r_static
r_inline
r_void
id|update_dirs_plus
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|dir
comma
r_int
id|is_dir
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|dentry
op_star
id|de
op_assign
id|dir-&gt;sys_entry
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|de
)paren
(brace
r_struct
id|inode
op_star
id|tmp
op_assign
id|de-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|tmp-&gt;i_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_dir
op_logical_and
(paren
id|i
op_eq
id|HFS_ITYPE_TO_INT
c_func
(paren
id|HFS_ITYPE_NORM
)paren
)paren
)paren
(brace
multiline_comment|/* In &quot;normal&quot; directory only */
op_increment
(paren
id|tmp-&gt;i_nlink
)paren
suffix:semicolon
)brace
id|tmp-&gt;i_size
op_add_assign
id|HFS_I
c_func
(paren
id|tmp
)paren
op_member_access_from_pointer
id|dir_size
suffix:semicolon
id|tmp-&gt;i_version
op_assign
op_increment
id|event
suffix:semicolon
)brace
id|tmp-&gt;i_ctime
op_assign
id|tmp-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * update_dirs_minus()&n; *&n; * Update the fields &squot;i_size&squot;, &squot;i_nlink&squot;, &squot;i_ctime&squot;, &squot;i_mtime&squot; and&n; * &squot;i_version&squot; of the inodes associated with a directory that has&n; * had a file (&squot;is_dir&squot;==0) or directory (&squot;is_dir&squot;!=0) removed.&n; */
DECL|function|update_dirs_minus
r_static
r_inline
r_void
id|update_dirs_minus
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|dir
comma
r_int
id|is_dir
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
(brace
r_struct
id|dentry
op_star
id|de
op_assign
id|dir-&gt;sys_entry
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|de
)paren
(brace
r_struct
id|inode
op_star
id|tmp
op_assign
id|de-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|tmp-&gt;i_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_dir
op_logical_and
(paren
id|i
op_eq
id|HFS_ITYPE_TO_INT
c_func
(paren
id|HFS_ITYPE_NORM
)paren
)paren
)paren
(brace
multiline_comment|/* In &quot;normal&quot; directory only */
op_decrement
(paren
id|tmp-&gt;i_nlink
)paren
suffix:semicolon
)brace
id|tmp-&gt;i_size
op_sub_assign
id|HFS_I
c_func
(paren
id|tmp
)paren
op_member_access_from_pointer
id|dir_size
suffix:semicolon
id|tmp-&gt;i_version
op_assign
op_increment
id|event
suffix:semicolon
)brace
id|tmp-&gt;i_ctime
op_assign
id|tmp-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * mark_inodes_deleted()&n; *&n; * Update inodes associated with a deleted entry to reflect its deletion.&n; * Well, we really just drop the dentry.&n; *&n; * XXX: we should be using delete_inode for some of this stuff.&n; */
DECL|function|mark_inodes_deleted
r_static
r_inline
r_void
id|mark_inodes_deleted
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|dentry
op_star
id|de
suffix:semicolon
r_struct
id|inode
op_star
id|tmp
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|de
op_assign
id|entry-&gt;sys_entry
(braket
id|i
)braket
)paren
op_logical_and
(paren
id|dentry
op_ne
id|de
)paren
)paren
(brace
id|dget
c_func
(paren
id|de
)paren
suffix:semicolon
id|tmp
op_assign
id|de-&gt;d_inode
suffix:semicolon
id|tmp-&gt;i_nlink
op_assign
l_int|0
suffix:semicolon
id|tmp-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|d_delete
c_func
(paren
id|de
)paren
suffix:semicolon
id|dput
c_func
(paren
id|de
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*================ Global functions ================*/
multiline_comment|/*&n; * hfs_create()&n; *&n; * This is the create() entry in the inode_operations structure for&n; * regular HFS directories.  The purpose is to create a new file in&n; * a directory and return a corresponding inode, given the inode for&n; * the directory and the name (and its length) of the new file.&n; */
DECL|function|hfs_create
r_int
id|hfs_create
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|entry
op_assign
id|HFS_I
c_func
(paren
id|dir
)paren
op_member_access_from_pointer
id|entry
suffix:semicolon
r_struct
id|hfs_cat_entry
op_star
r_new
suffix:semicolon
r_struct
id|hfs_cat_key
id|key
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/* build the key, checking against reserved names */
r_if
c_cond
(paren
id|build_key
c_func
(paren
op_amp
id|key
comma
id|dir
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
)paren
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|hfs_cat_create
c_func
(paren
id|entry
comma
op_amp
id|key
comma
(paren
id|mode
op_amp
id|S_IWUSR
)paren
ques
c_cond
l_int|0
suffix:colon
id|HFS_FIL_LOCK
comma
id|HFS_SB
c_func
(paren
id|dir-&gt;i_sb
)paren
op_member_access_from_pointer
id|s_type
comma
id|HFS_SB
c_func
(paren
id|dir-&gt;i_sb
)paren
op_member_access_from_pointer
id|s_creator
comma
op_amp
r_new
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* create an inode for the new file. back out if we run&n;&t; * into trouble. */
r_new
op_member_access_from_pointer
id|count
op_increment
suffix:semicolon
multiline_comment|/* hfs_iget() eats one */
r_if
c_cond
(paren
op_logical_neg
(paren
id|inode
op_assign
id|hfs_iget
c_func
(paren
r_new
comma
id|HFS_I
c_func
(paren
id|dir
)paren
op_member_access_from_pointer
id|file_type
comma
id|dentry
)paren
)paren
)paren
(brace
id|hfs_cat_delete
c_func
(paren
id|entry
comma
r_new
comma
l_int|1
)paren
suffix:semicolon
id|hfs_cat_put
c_func
(paren
r_new
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|hfs_cat_put
c_func
(paren
r_new
)paren
suffix:semicolon
id|update_dirs_plus
c_func
(paren
id|entry
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* toss any relevant negative dentries */
r_if
c_cond
(paren
id|HFS_I
c_func
(paren
id|dir
)paren
op_member_access_from_pointer
id|d_drop_op
)paren
id|HFS_I
c_func
(paren
id|dir
)paren
op_member_access_from_pointer
id|d_drop_op
c_func
(paren
id|dentry
comma
id|HFS_I
c_func
(paren
id|dir
)paren
op_member_access_from_pointer
id|file_type
)paren
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_mkdir()&n; *&n; * This is the mkdir() entry in the inode_operations structure for&n; * regular HFS directories.  The purpose is to create a new directory&n; * in a directory, given the inode for the parent directory and the&n; * name (and its length) of the new directory.&n; */
DECL|function|hfs_mkdir
r_int
id|hfs_mkdir
c_func
(paren
r_struct
id|inode
op_star
id|parent
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|entry
op_assign
id|HFS_I
c_func
(paren
id|parent
)paren
op_member_access_from_pointer
id|entry
suffix:semicolon
r_struct
id|hfs_cat_entry
op_star
r_new
suffix:semicolon
r_struct
id|hfs_cat_key
id|key
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/* build the key, checking against reserved names */
r_if
c_cond
(paren
id|build_key
c_func
(paren
op_amp
id|key
comma
id|parent
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
)paren
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
multiline_comment|/* try to create the directory */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|hfs_cat_mkdir
c_func
(paren
id|entry
comma
op_amp
id|key
comma
op_amp
r_new
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* back out if we run into trouble */
r_new
op_member_access_from_pointer
id|count
op_increment
suffix:semicolon
multiline_comment|/* hfs_iget eats one */
r_if
c_cond
(paren
op_logical_neg
(paren
id|inode
op_assign
id|hfs_iget
c_func
(paren
r_new
comma
id|HFS_I
c_func
(paren
id|parent
)paren
op_member_access_from_pointer
id|file_type
comma
id|dentry
)paren
)paren
)paren
(brace
id|hfs_cat_delete
c_func
(paren
id|entry
comma
r_new
comma
l_int|1
)paren
suffix:semicolon
id|hfs_cat_put
c_func
(paren
r_new
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|hfs_cat_put
c_func
(paren
r_new
)paren
suffix:semicolon
id|update_dirs_plus
c_func
(paren
id|entry
comma
l_int|1
)paren
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_unlink()&n; *&n; * This is the unlink() entry in the inode_operations structure for&n; * regular HFS directories.  The purpose is to delete an existing&n; * file, given the inode for the parent directory and the name&n; * (and its length) of the existing file.&n; */
DECL|function|hfs_unlink
r_int
id|hfs_unlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|entry
op_assign
id|HFS_I
c_func
(paren
id|dir
)paren
op_member_access_from_pointer
id|entry
suffix:semicolon
r_struct
id|hfs_cat_entry
op_star
id|victim
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|hfs_cat_key
id|key
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|build_key
c_func
(paren
op_amp
id|key
comma
id|dir
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|victim
op_assign
id|hfs_cat_get
c_func
(paren
id|entry-&gt;mdb
comma
op_amp
id|key
)paren
)paren
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|victim-&gt;type
op_ne
id|HFS_CDR_FIL
)paren
r_goto
id|hfs_unlink_put
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|error
op_assign
id|hfs_cat_delete
c_func
(paren
id|entry
comma
id|victim
comma
l_int|1
)paren
)paren
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|mark_inodes_deleted
c_func
(paren
id|victim
comma
id|dentry
)paren
suffix:semicolon
id|inode-&gt;i_nlink
op_decrement
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
id|update_dirs_minus
c_func
(paren
id|entry
comma
l_int|0
)paren
suffix:semicolon
)brace
id|hfs_unlink_put
suffix:colon
id|hfs_cat_put
c_func
(paren
id|victim
)paren
suffix:semicolon
multiline_comment|/* Note that hfs_cat_put(NULL) is safe. */
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_rmdir()&n; *&n; * This is the rmdir() entry in the inode_operations structure for&n; * regular HFS directories.  The purpose is to delete an existing&n; * directory, given the inode for the parent directory and the name&n; * (and its length) of the existing directory.&n; */
DECL|function|hfs_rmdir
r_int
id|hfs_rmdir
c_func
(paren
r_struct
id|inode
op_star
id|parent
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|entry
op_assign
id|HFS_I
c_func
(paren
id|parent
)paren
op_member_access_from_pointer
id|entry
suffix:semicolon
r_struct
id|hfs_cat_entry
op_star
id|victim
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_struct
id|hfs_cat_key
id|key
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|build_key
c_func
(paren
op_amp
id|key
comma
id|parent
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|victim
op_assign
id|hfs_cat_get
c_func
(paren
id|entry-&gt;mdb
comma
op_amp
id|key
)paren
)paren
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|error
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
r_if
c_cond
(paren
id|victim-&gt;type
op_ne
id|HFS_CDR_DIR
)paren
r_goto
id|hfs_rmdir_put
suffix:semicolon
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|d_unhashed
c_func
(paren
id|dentry
)paren
)paren
r_goto
id|hfs_rmdir_put
suffix:semicolon
multiline_comment|/* we only have to worry about 2 and 3 for mount points */
r_if
c_cond
(paren
id|victim-&gt;sys_entry
(braket
l_int|2
)braket
op_logical_and
id|d_mountpoint
c_func
(paren
id|victim-&gt;sys_entry
(braket
l_int|2
)braket
)paren
)paren
r_goto
id|hfs_rmdir_put
suffix:semicolon
r_if
c_cond
(paren
id|victim-&gt;sys_entry
(braket
l_int|3
)braket
op_logical_and
id|d_mountpoint
c_func
(paren
id|victim-&gt;sys_entry
(braket
l_int|3
)braket
)paren
)paren
r_goto
id|hfs_rmdir_put
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|hfs_cat_delete
c_func
(paren
id|entry
comma
id|victim
comma
l_int|1
)paren
)paren
)paren
r_goto
id|hfs_rmdir_put
suffix:semicolon
id|mark_inodes_deleted
c_func
(paren
id|victim
comma
id|dentry
)paren
suffix:semicolon
id|inode-&gt;i_nlink
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
id|update_dirs_minus
c_func
(paren
id|entry
comma
l_int|1
)paren
suffix:semicolon
id|hfs_rmdir_put
suffix:colon
id|hfs_cat_put
c_func
(paren
id|victim
)paren
suffix:semicolon
multiline_comment|/* Note that hfs_cat_put(NULL) is safe. */
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_rename()&n; *&n; * This is the rename() entry in the inode_operations structure for&n; * regular HFS directories.  The purpose is to rename an existing&n; * file or directory, given the inode for the current directory and&n; * the name (and its length) of the existing file/directory and the&n; * inode for the new directory and the name (and its length) of the&n; * new file/directory.&n; * XXX: how do you handle must_be dir?&n; */
DECL|function|hfs_rename
r_int
id|hfs_rename
c_func
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_struct
id|dentry
op_star
id|new_dentry
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|old_parent
op_assign
id|HFS_I
c_func
(paren
id|old_dir
)paren
op_member_access_from_pointer
id|entry
suffix:semicolon
r_struct
id|hfs_cat_entry
op_star
id|new_parent
op_assign
id|HFS_I
c_func
(paren
id|new_dir
)paren
op_member_access_from_pointer
id|entry
suffix:semicolon
r_struct
id|hfs_cat_entry
op_star
id|victim
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|hfs_cat_entry
op_star
id|deleted
suffix:semicolon
r_struct
id|hfs_cat_key
id|key
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|build_key
c_func
(paren
op_amp
id|key
comma
id|old_dir
comma
id|old_dentry-&gt;d_name.name
comma
id|old_dentry-&gt;d_name.len
)paren
op_logical_or
(paren
id|HFS_ITYPE
c_func
(paren
id|old_dir-&gt;i_ino
)paren
op_ne
id|HFS_ITYPE
c_func
(paren
id|new_dir-&gt;i_ino
)paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|victim
op_assign
id|hfs_cat_get
c_func
(paren
id|old_parent-&gt;mdb
comma
op_amp
id|key
)paren
)paren
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|build_key
c_func
(paren
op_amp
id|key
comma
id|new_dir
comma
id|new_dentry-&gt;d_name.name
comma
id|new_dentry-&gt;d_name.len
)paren
)paren
r_goto
id|hfs_rename_put
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|error
op_assign
id|hfs_cat_move
c_func
(paren
id|old_parent
comma
id|new_parent
comma
id|victim
comma
op_amp
id|key
comma
op_amp
id|deleted
)paren
)paren
)paren
(brace
r_int
id|is_dir
op_assign
(paren
id|victim-&gt;type
op_eq
id|HFS_CDR_DIR
)paren
suffix:semicolon
multiline_comment|/* drop the old dentries */
id|mark_inodes_deleted
c_func
(paren
id|victim
comma
id|old_dentry
)paren
suffix:semicolon
id|update_dirs_minus
c_func
(paren
id|old_parent
comma
id|is_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|deleted
)paren
(brace
id|mark_inodes_deleted
c_func
(paren
id|deleted
comma
id|new_dentry
)paren
suffix:semicolon
id|hfs_cat_put
c_func
(paren
id|deleted
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* no existing inodes. just drop negative dentries */
r_if
c_cond
(paren
id|HFS_I
c_func
(paren
id|new_dir
)paren
op_member_access_from_pointer
id|d_drop_op
)paren
id|HFS_I
c_func
(paren
id|new_dir
)paren
op_member_access_from_pointer
id|d_drop_op
c_func
(paren
id|new_dentry
comma
id|HFS_I
c_func
(paren
id|new_dir
)paren
op_member_access_from_pointer
id|file_type
)paren
suffix:semicolon
id|update_dirs_plus
c_func
(paren
id|new_parent
comma
id|is_dir
)paren
suffix:semicolon
)brace
)brace
id|hfs_rename_put
suffix:colon
id|hfs_cat_put
c_func
(paren
id|victim
)paren
suffix:semicolon
multiline_comment|/* Note that hfs_cat_put(NULL) is safe. */
r_return
id|error
suffix:semicolon
)brace
eof
