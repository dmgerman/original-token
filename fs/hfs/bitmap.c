multiline_comment|/*&n; * linux/fs/hfs/bitmap.c&n; *&n; * Copyright (C) 1996-1997  Paul H. Hargrove&n; * This file may be distributed under the terms of the GNU Public License.&n; *&n; * Based on GPLed code Copyright (C) 1995  Michael Dreher&n; *&n; * This file contains the code to modify the volume bitmap:&n; * search/set/clear bits.&n; *&n; * &quot;XXX&quot; in a comment is a note to myself to consider changing something.&n; *&n; * In function preconditions the term &quot;valid&quot; applied to a pointer to&n; * a structure means that the pointer is non-NULL and the structure it&n; * points to has all fields initialized to consistent values.&n; */
macro_line|#include &quot;hfs.h&quot;
multiline_comment|/*================ Global functions ================*/
multiline_comment|/*&n; * hfs_vbm_count_free()&n; *&n; * Description:&n; *   Count the number of consecutive cleared bits in the bitmap blocks of&n; *   the hfs MDB starting at bit number &squot;start&squot;.  &squot;mdb&squot; had better&n; *   be locked or the indicated number of blocks may be no longer free,&n; *   when this functions returns!&n; * Input Variable(s):&n; *   struct hfs_mdb *mdb: Pointer to the hfs MDB&n; *   hfs_u16 start: bit number to start at&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   The number of consecutive cleared bits starting at bit &squot;start&squot;&n; * Preconditions:&n; *   &squot;mdb&squot; points to a &quot;valid&quot; (struct hfs_mdb).&n; * Postconditions:&n; *   NONE&n; */
DECL|function|hfs_vbm_count_free
id|hfs_u16
id|hfs_vbm_count_free
c_func
(paren
r_const
r_struct
id|hfs_mdb
op_star
id|mdb
comma
id|hfs_u16
id|start
)paren
(brace
id|hfs_u16
id|block_nr
suffix:semicolon
multiline_comment|/* index of the current bitmap block */
id|hfs_u16
id|bit_nr
suffix:semicolon
multiline_comment|/* index of the current bit in block */
id|hfs_u16
id|count
suffix:semicolon
multiline_comment|/* number of bits found so far */
id|hfs_u16
id|len
suffix:semicolon
multiline_comment|/* number of bits found in this block */
id|hfs_u16
id|max_block
suffix:semicolon
multiline_comment|/* index of last bitmap block */
id|hfs_u16
id|max_bits
suffix:semicolon
multiline_comment|/* index of last bit in block */
multiline_comment|/* is this a valid HFS MDB? */
r_if
c_cond
(paren
op_logical_neg
id|mdb
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|block_nr
op_assign
id|start
op_div
id|HFS_BM_BPB
suffix:semicolon
id|bit_nr
op_assign
id|start
op_mod
id|HFS_BM_BPB
suffix:semicolon
id|max_block
op_assign
(paren
id|mdb-&gt;fs_ablocks
op_plus
id|HFS_BM_BPB
op_minus
l_int|1
)paren
op_div
id|HFS_BM_BPB
op_minus
l_int|1
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|block_nr
op_le
id|max_block
)paren
(brace
r_if
c_cond
(paren
id|block_nr
op_ne
id|max_block
)paren
(brace
id|max_bits
op_assign
id|HFS_BM_BPB
suffix:semicolon
)brace
r_else
(brace
id|max_bits
op_assign
id|mdb-&gt;fs_ablocks
op_mod
id|HFS_BM_BPB
suffix:semicolon
)brace
id|len
op_assign
id|hfs_count_zero_bits
c_func
(paren
id|hfs_buffer_data
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
comma
id|max_bits
comma
id|bit_nr
)paren
suffix:semicolon
id|count
op_add_assign
id|len
suffix:semicolon
multiline_comment|/* see if we fell short of the end of this block */
r_if
c_cond
(paren
(paren
id|len
op_plus
id|bit_nr
)paren
OL
id|max_bits
)paren
(brace
r_break
suffix:semicolon
)brace
op_increment
id|block_nr
suffix:semicolon
id|bit_nr
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_vbm_search_free()&n; *&n; * Description:&n; *   Search for &squot;num_bits&squot; consecutive cleared bits in the bitmap blocks of&n; *   the hfs MDB. &squot;mdb&squot; had better be locked or the returned range&n; *   may be no longer free, when this functions returns!&n; *   XXX Currently the search starts from bit 0, but it should start with&n; *   the bit number stored in &squot;s_alloc_ptr&squot; of the MDB.&n; * Input Variable(s):&n; *   struct hfs_mdb *mdb: Pointer to the hfs MDB&n; *   hfs_u16 *num_bits: Pointer to the number of cleared bits&n; *     to search for&n; * Output Variable(s):&n; *   hfs_u16 *num_bits: The number of consecutive clear bits of the&n; *     returned range. If the bitmap is fragmented, this will be less than&n; *     requested and it will be zero, when the disk is full.&n; * Returns:&n; *   The number of the first bit of the range of cleared bits which has been&n; *   found. When &squot;num_bits&squot; is zero, this is invalid!&n; * Preconditions:&n; *   &squot;mdb&squot; points to a &quot;valid&quot; (struct hfs_mdb).&n; *   &squot;num_bits&squot; points to a variable of type (hfs_u16), which contains&n; *&t;the number of cleared bits to find.&n; * Postconditions:&n; *   &squot;num_bits&squot; is set to the length of the found sequence.&n; */
DECL|function|hfs_vbm_search_free
id|hfs_u16
id|hfs_vbm_search_free
c_func
(paren
r_const
r_struct
id|hfs_mdb
op_star
id|mdb
comma
id|hfs_u16
op_star
id|num_bits
)paren
(brace
id|hfs_u16
id|block_nr
suffix:semicolon
multiline_comment|/* index of the current bitmap block */
multiline_comment|/* position and length of current portion of a run */
id|hfs_u16
id|cur_pos
comma
id|cur_len
suffix:semicolon
multiline_comment|/* position and length of current complete run */
id|hfs_u16
id|pos
op_assign
l_int|0
comma
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* position and length of longest complete run */
id|hfs_u16
id|longest_pos
op_assign
l_int|0
comma
id|longest_len
op_assign
l_int|0
suffix:semicolon
r_void
op_star
id|bitmap
suffix:semicolon
multiline_comment|/* contents of the current bitmap block */
id|hfs_u16
id|max_block
suffix:semicolon
multiline_comment|/* upper limit of outer loop */
id|hfs_u16
id|max_bits
suffix:semicolon
multiline_comment|/* upper limit of inner loop */
multiline_comment|/* is this a valid HFS MDB? */
r_if
c_cond
(paren
op_logical_neg
id|mdb
)paren
(brace
op_star
id|num_bits
op_assign
l_int|0
suffix:semicolon
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_vbm_search_free: not a valid MDB&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* make sure we have actual work to perform */
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|num_bits
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|max_block
op_assign
(paren
id|mdb-&gt;fs_ablocks
op_plus
id|HFS_BM_BPB
op_minus
l_int|1
)paren
op_div
id|HFS_BM_BPB
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* search all bitmap blocks */
r_for
c_loop
(paren
id|block_nr
op_assign
l_int|0
suffix:semicolon
id|block_nr
op_le
id|max_block
suffix:semicolon
id|block_nr
op_increment
)paren
(brace
id|bitmap
op_assign
id|hfs_buffer_data
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block_nr
op_ne
id|max_block
)paren
(brace
id|max_bits
op_assign
id|HFS_BM_BPB
suffix:semicolon
)brace
r_else
(brace
id|max_bits
op_assign
id|mdb-&gt;fs_ablocks
op_mod
id|HFS_BM_BPB
suffix:semicolon
)brace
id|cur_pos
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|cur_len
op_assign
id|hfs_count_zero_bits
c_func
(paren
id|bitmap
comma
id|max_bits
comma
id|cur_pos
)paren
suffix:semicolon
id|len
op_add_assign
id|cur_len
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|longest_len
)paren
(brace
id|longest_pos
op_assign
id|pos
suffix:semicolon
id|longest_len
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
op_star
id|num_bits
)paren
(brace
r_goto
id|search_end
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|cur_pos
op_plus
id|cur_len
)paren
op_eq
id|max_bits
)paren
(brace
r_break
suffix:semicolon
multiline_comment|/* zeros may continue into next block */
)brace
multiline_comment|/* find start of next run of zeros */
id|cur_pos
op_assign
id|hfs_find_zero_bit
c_func
(paren
id|bitmap
comma
id|max_bits
comma
id|cur_pos
op_plus
id|cur_len
)paren
suffix:semicolon
id|pos
op_assign
id|cur_pos
op_plus
id|HFS_BM_BPB
op_star
id|block_nr
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|cur_pos
OL
id|max_bits
)paren
suffix:semicolon
)brace
id|search_end
suffix:colon
op_star
id|num_bits
op_assign
id|longest_len
suffix:semicolon
r_return
id|longest_pos
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_set_vbm_bits()&n; *&n; * Description:&n; *   Set the requested bits in the volume bitmap of the hfs filesystem&n; * Input Variable(s):&n; *   struct hfs_mdb *mdb: Pointer to the hfs MDB&n; *   hfs_u16 start: The offset of the first bit&n; *   hfs_u16 count: The number of bits&n; * Output Variable(s):&n; *   None&n; * Returns:&n; *    0: no error&n; *   -1: One of the bits was already set.  This is a strange&n; *&t; error and when it happens, the filesystem must be repaired!&n; *   -2: One or more of the bits are out of range of the bitmap.&n; *   -3: The &squot;s_magic&squot; field of the MDB does not match&n; * Preconditions:&n; *   &squot;mdb&squot; points to a &quot;valid&quot; (struct hfs_mdb).&n; * Postconditions:&n; *   Starting with bit number &squot;start&squot;, &squot;count&squot; bits in the volume bitmap&n; *   are set. The affected bitmap blocks are marked &quot;dirty&quot;, the free&n; *   block count of the MDB is updated and the MDB is marked dirty.&n; */
DECL|function|hfs_set_vbm_bits
r_int
id|hfs_set_vbm_bits
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
comma
id|hfs_u16
id|start
comma
id|hfs_u16
id|count
)paren
(brace
id|hfs_u16
id|block_nr
suffix:semicolon
multiline_comment|/* index of the current bitmap block */
id|hfs_u16
id|u32_nr
suffix:semicolon
multiline_comment|/* index of the current hfs_u32 in block */
id|hfs_u16
id|bit_nr
suffix:semicolon
multiline_comment|/* index of the current bit in hfs_u32 */
id|hfs_u16
id|left
op_assign
id|count
suffix:semicolon
multiline_comment|/* number of bits left to be set */
id|hfs_u32
op_star
id|bitmap
suffix:semicolon
multiline_comment|/* the current bitmap block&squot;s contents */
multiline_comment|/* is this a valid HFS MDB? */
r_if
c_cond
(paren
op_logical_neg
id|mdb
)paren
(brace
r_return
op_minus
l_int|3
suffix:semicolon
)brace
multiline_comment|/* is there any actual work to be done? */
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* are all of the bits in range? */
r_if
c_cond
(paren
(paren
id|start
op_plus
id|count
)paren
OG
id|mdb-&gt;fs_ablocks
)paren
(brace
r_return
op_minus
l_int|2
suffix:semicolon
)brace
id|block_nr
op_assign
id|start
op_div
id|HFS_BM_BPB
suffix:semicolon
id|u32_nr
op_assign
(paren
id|start
op_mod
id|HFS_BM_BPB
)paren
op_div
l_int|32
suffix:semicolon
id|bit_nr
op_assign
id|start
op_mod
l_int|32
suffix:semicolon
multiline_comment|/* bitmap is always on a 32-bit boundary */
id|bitmap
op_assign
(paren
id|hfs_u32
op_star
)paren
id|hfs_buffer_data
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
suffix:semicolon
multiline_comment|/* do any partial hfs_u32 at the start */
r_if
c_cond
(paren
id|bit_nr
op_ne
l_int|0
)paren
(brace
r_while
c_loop
(paren
(paren
id|bit_nr
OL
l_int|32
)paren
op_logical_and
id|left
)paren
(brace
r_if
c_cond
(paren
id|hfs_set_bit
c_func
(paren
id|bit_nr
comma
id|bitmap
op_plus
id|u32_nr
)paren
)paren
(brace
id|hfs_buffer_dirty
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
op_increment
id|bit_nr
suffix:semicolon
op_decrement
id|left
suffix:semicolon
)brace
id|bit_nr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* advance u32_nr and check for end of this block */
r_if
c_cond
(paren
op_increment
id|u32_nr
OG
l_int|127
)paren
(brace
id|u32_nr
op_assign
l_int|0
suffix:semicolon
id|hfs_buffer_dirty
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
suffix:semicolon
op_increment
id|block_nr
suffix:semicolon
multiline_comment|/* bitmap is always on a 32-bit boundary */
id|bitmap
op_assign
(paren
id|hfs_u32
op_star
)paren
id|hfs_buffer_data
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* do full hfs_u32s */
r_while
c_loop
(paren
id|left
OG
l_int|31
)paren
(brace
r_if
c_cond
(paren
id|bitmap
(braket
id|u32_nr
)braket
op_ne
(paren
(paren
id|hfs_u32
)paren
l_int|0
)paren
)paren
(brace
id|hfs_buffer_dirty
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|bitmap
(braket
id|u32_nr
)braket
op_assign
op_complement
(paren
(paren
id|hfs_u32
)paren
l_int|0
)paren
suffix:semicolon
id|left
op_sub_assign
l_int|32
suffix:semicolon
multiline_comment|/* advance u32_nr and check for end of this block */
r_if
c_cond
(paren
op_increment
id|u32_nr
OG
l_int|127
)paren
(brace
id|u32_nr
op_assign
l_int|0
suffix:semicolon
id|hfs_buffer_dirty
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
suffix:semicolon
op_increment
id|block_nr
suffix:semicolon
multiline_comment|/* bitmap is always on a 32-bit boundary */
id|bitmap
op_assign
(paren
id|hfs_u32
op_star
)paren
id|hfs_buffer_data
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* do any partial hfs_u32 at end */
r_while
c_loop
(paren
id|left
)paren
(brace
r_if
c_cond
(paren
id|hfs_set_bit
c_func
(paren
id|bit_nr
comma
id|bitmap
op_plus
id|u32_nr
)paren
)paren
(brace
id|hfs_buffer_dirty
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
op_increment
id|bit_nr
suffix:semicolon
op_decrement
id|left
suffix:semicolon
)brace
id|hfs_buffer_dirty
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
suffix:semicolon
id|mdb-&gt;free_ablocks
op_sub_assign
id|count
suffix:semicolon
multiline_comment|/* successful completion */
id|hfs_mdb_dirty
c_func
(paren
id|mdb-&gt;sys_mdb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_clear_vbm_bits()&n; *&n; * Description:&n; *   Clear the requested bits in the volume bitmap of the hfs filesystem&n; * Input Variable(s):&n; *   struct hfs_mdb *mdb: Pointer to the hfs MDB&n; *   hfs_u16 start: The offset of the first bit&n; *   hfs_u16 count: The number of bits&n; * Output Variable(s):&n; *   None&n; * Returns:&n; *    0: no error&n; *   -1: One of the bits was already clear.  This is a strange&n; *&t; error and when it happens, the filesystem must be repaired!&n; *   -2: One or more of the bits are out of range of the bitmap.&n; *   -3: The &squot;s_magic&squot; field of the MDB does not match&n; * Preconditions:&n; *   &squot;mdb&squot; points to a &quot;valid&quot; (struct hfs_mdb).&n; * Postconditions:&n; *   Starting with bit number &squot;start&squot;, &squot;count&squot; bits in the volume bitmap&n; *   are cleared. The affected bitmap blocks are marked &quot;dirty&quot;, the free&n; *   block count of the MDB is updated and the MDB is marked dirty.&n; */
DECL|function|hfs_clear_vbm_bits
r_int
id|hfs_clear_vbm_bits
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
comma
id|hfs_u16
id|start
comma
id|hfs_u16
id|count
)paren
(brace
id|hfs_u16
id|block_nr
suffix:semicolon
multiline_comment|/* index of the current bitmap block */
id|hfs_u16
id|u32_nr
suffix:semicolon
multiline_comment|/* index of the current hfs_u32 in block */
id|hfs_u16
id|bit_nr
suffix:semicolon
multiline_comment|/* index of the current bit in hfs_u32 */
id|hfs_u16
id|left
op_assign
id|count
suffix:semicolon
multiline_comment|/* number of bits left to be set */
id|hfs_u32
op_star
id|bitmap
suffix:semicolon
multiline_comment|/* the current bitmap block&squot;s contents */
multiline_comment|/* is this a valid HFS MDB? */
r_if
c_cond
(paren
op_logical_neg
id|mdb
)paren
(brace
r_return
op_minus
l_int|3
suffix:semicolon
)brace
multiline_comment|/* is there any actual work to be done? */
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* are all of the bits in range? */
r_if
c_cond
(paren
(paren
id|start
op_plus
id|count
)paren
OG
id|mdb-&gt;fs_ablocks
)paren
(brace
r_return
op_minus
l_int|2
suffix:semicolon
)brace
id|block_nr
op_assign
id|start
op_div
id|HFS_BM_BPB
suffix:semicolon
id|u32_nr
op_assign
(paren
id|start
op_mod
id|HFS_BM_BPB
)paren
op_div
l_int|32
suffix:semicolon
id|bit_nr
op_assign
id|start
op_mod
l_int|32
suffix:semicolon
multiline_comment|/* bitmap is always on a 32-bit boundary */
id|bitmap
op_assign
(paren
id|hfs_u32
op_star
)paren
id|hfs_buffer_data
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
suffix:semicolon
multiline_comment|/* do any partial hfs_u32 at the start */
r_if
c_cond
(paren
id|bit_nr
op_ne
l_int|0
)paren
(brace
r_while
c_loop
(paren
(paren
id|bit_nr
OL
l_int|32
)paren
op_logical_and
id|left
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hfs_clear_bit
c_func
(paren
id|bit_nr
comma
id|bitmap
op_plus
id|u32_nr
)paren
)paren
(brace
id|hfs_buffer_dirty
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
op_increment
id|bit_nr
suffix:semicolon
op_decrement
id|left
suffix:semicolon
)brace
id|bit_nr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* advance u32_nr and check for end of this block */
r_if
c_cond
(paren
op_increment
id|u32_nr
OG
l_int|127
)paren
(brace
id|u32_nr
op_assign
l_int|0
suffix:semicolon
id|hfs_buffer_dirty
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
suffix:semicolon
op_increment
id|block_nr
suffix:semicolon
multiline_comment|/* bitmap is always on a 32-bit boundary */
id|bitmap
op_assign
(paren
id|hfs_u32
op_star
)paren
id|hfs_buffer_data
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* do full hfs_u32s */
r_while
c_loop
(paren
id|left
OG
l_int|31
)paren
(brace
r_if
c_cond
(paren
id|bitmap
(braket
id|u32_nr
)braket
op_ne
op_complement
(paren
(paren
id|hfs_u32
)paren
l_int|0
)paren
)paren
(brace
id|hfs_buffer_dirty
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|bitmap
(braket
id|u32_nr
)braket
op_assign
(paren
(paren
id|hfs_u32
)paren
l_int|0
)paren
suffix:semicolon
id|left
op_sub_assign
l_int|32
suffix:semicolon
multiline_comment|/* advance u32_nr and check for end of this block */
r_if
c_cond
(paren
op_increment
id|u32_nr
OG
l_int|127
)paren
(brace
id|u32_nr
op_assign
l_int|0
suffix:semicolon
id|hfs_buffer_dirty
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
suffix:semicolon
op_increment
id|block_nr
suffix:semicolon
multiline_comment|/* bitmap is always on a 32-bit boundary */
id|bitmap
op_assign
(paren
id|hfs_u32
op_star
)paren
id|hfs_buffer_data
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* do any partial hfs_u32 at end */
r_while
c_loop
(paren
id|left
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|hfs_clear_bit
c_func
(paren
id|bit_nr
comma
id|bitmap
op_plus
id|u32_nr
)paren
)paren
(brace
id|hfs_buffer_dirty
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
op_increment
id|bit_nr
suffix:semicolon
op_decrement
id|left
suffix:semicolon
)brace
id|hfs_buffer_dirty
c_func
(paren
id|mdb-&gt;bitmap
(braket
id|block_nr
)braket
)paren
suffix:semicolon
id|mdb-&gt;free_ablocks
op_add_assign
id|count
suffix:semicolon
multiline_comment|/* successful completion */
id|hfs_mdb_dirty
c_func
(paren
id|mdb-&gt;sys_mdb
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
