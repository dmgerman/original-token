multiline_comment|/*&n; * linux/fs/hfs/catalog.c&n; *&n; * Copyright (C) 1995-1997  Paul H. Hargrove&n; * This file may be distributed under the terms of the GNU Public License.&n; *&n; * This file contains the functions related to the catalog B-tree.&n; *&n; * &quot;XXX&quot; in a comment is a note to myself to consider changing something.&n; *&n; * Cache code shamelessly stolen from &n; *     linux/fs/inode.c Copyright (C) 1991, 1992  Linus Torvalds&n; *     re-shamelessly stolen Copyright (C) 1997 Linus Torvalds&n; *&n; * In function preconditions the term &quot;valid&quot; applied to a pointer to&n; * a structure means that the pointer is non-NULL and the structure it&n; * points to has all fields initialized to consistent values.&n; *&n; * The code in this file initializes some structures by calling&n; * memset(&amp;foo, 0, sizeof(foo)).  This produces the desired behavior&n; * only due to the non-ANSI assumption that the machine representation&n; */
macro_line|#include &quot;hfs.h&quot;
multiline_comment|/*================ Variable-like macros ================*/
multiline_comment|/* Number of hash table slots */
DECL|macro|C_HASHBITS
mdefine_line|#define C_HASHBITS  10
DECL|macro|C_HASHSIZE
mdefine_line|#define C_HASHSIZE  (1UL &lt;&lt; C_HASHBITS)
DECL|macro|C_HASHMASK
mdefine_line|#define C_HASHMASK  (C_HASHSIZE - 1)
multiline_comment|/* Number of entries to fit in a single page on an i386.&n; * Actually, now it&squot;s used to increment the free entry pool. */
DECL|macro|CCACHE_INC
mdefine_line|#define CCACHE_INC (PAGE_SIZE/sizeof(struct hfs_cat_entry))
DECL|macro|CCACHE_MAX
mdefine_line|#define CCACHE_MAX (CCACHE_INC * 8)
multiline_comment|/*================ File-local data types ================*/
multiline_comment|/* The catalog record for a file */
r_typedef
r_struct
(brace
DECL|member|Flags
id|hfs_byte_t
id|Flags
suffix:semicolon
multiline_comment|/* Flags such as read-only */
DECL|member|Typ
id|hfs_byte_t
id|Typ
suffix:semicolon
multiline_comment|/* file version number = 0 */
DECL|member|UsrWds
id|hfs_finfo_t
id|UsrWds
suffix:semicolon
multiline_comment|/* data used by the Finder */
DECL|member|FlNum
id|hfs_lword_t
id|FlNum
suffix:semicolon
multiline_comment|/* The CNID */
DECL|member|StBlk
id|hfs_word_t
id|StBlk
suffix:semicolon
multiline_comment|/* obsolete */
DECL|member|LgLen
id|hfs_lword_t
id|LgLen
suffix:semicolon
multiline_comment|/* The logical EOF of the data fork*/
DECL|member|PyLen
id|hfs_lword_t
id|PyLen
suffix:semicolon
multiline_comment|/* The physical EOF of the data fork */
DECL|member|RStBlk
id|hfs_word_t
id|RStBlk
suffix:semicolon
multiline_comment|/* obsolete */
DECL|member|RLgLen
id|hfs_lword_t
id|RLgLen
suffix:semicolon
multiline_comment|/* The logical EOF of the rsrc fork */
DECL|member|RPyLen
id|hfs_lword_t
id|RPyLen
suffix:semicolon
multiline_comment|/* The physical EOF of the rsrc fork */
DECL|member|CrDat
id|hfs_lword_t
id|CrDat
suffix:semicolon
multiline_comment|/* The creation date */
DECL|member|MdDat
id|hfs_lword_t
id|MdDat
suffix:semicolon
multiline_comment|/* The modified date */
DECL|member|BkDat
id|hfs_lword_t
id|BkDat
suffix:semicolon
multiline_comment|/* The last backup date */
DECL|member|FndrInfo
id|hfs_fxinfo_t
id|FndrInfo
suffix:semicolon
multiline_comment|/* more data for the Finder */
DECL|member|ClpSize
id|hfs_word_t
id|ClpSize
suffix:semicolon
multiline_comment|/* number of bytes to allocate&n;&t;&t;&t;&t;&t;   when extending files */
DECL|member|ExtRec
id|hfs_byte_t
id|ExtRec
(braket
l_int|12
)braket
suffix:semicolon
multiline_comment|/* first extent record&n;&t;&t;&t;&t;&t;   for the data fork */
DECL|member|RExtRec
id|hfs_byte_t
id|RExtRec
(braket
l_int|12
)braket
suffix:semicolon
multiline_comment|/* first extent record&n;&t;&t;&t;&t;&t;   for the resource fork */
DECL|member|Resrv
id|hfs_lword_t
id|Resrv
suffix:semicolon
multiline_comment|/* reserved by Apple */
DECL|typedef|FIL_REC
)brace
id|__attribute__
c_func
(paren
(paren
id|packed
)paren
)paren
id|FIL_REC
suffix:semicolon
multiline_comment|/* the catalog record for a directory */
r_typedef
r_struct
(brace
DECL|member|Flags
id|hfs_word_t
id|Flags
suffix:semicolon
multiline_comment|/* flags */
DECL|member|Val
id|hfs_word_t
id|Val
suffix:semicolon
multiline_comment|/* Valence: number of files and&n;&t;&t;&t;&t;&t;   dirs in the directory */
DECL|member|DirID
id|hfs_lword_t
id|DirID
suffix:semicolon
multiline_comment|/* The CNID */
DECL|member|CrDat
id|hfs_lword_t
id|CrDat
suffix:semicolon
multiline_comment|/* The creation date */
DECL|member|MdDat
id|hfs_lword_t
id|MdDat
suffix:semicolon
multiline_comment|/* The modification date */
DECL|member|BkDat
id|hfs_lword_t
id|BkDat
suffix:semicolon
multiline_comment|/* The last backup date */
DECL|member|UsrInfo
id|hfs_dinfo_t
id|UsrInfo
suffix:semicolon
multiline_comment|/* data used by the Finder */
DECL|member|FndrInfo
id|hfs_dxinfo_t
id|FndrInfo
suffix:semicolon
multiline_comment|/* more data used by Finder */
DECL|member|Resrv
id|hfs_byte_t
id|Resrv
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* reserved by Apple */
DECL|typedef|DIR_REC
)brace
id|__attribute__
c_func
(paren
(paren
id|packed
)paren
)paren
id|DIR_REC
suffix:semicolon
multiline_comment|/* the catalog record for a thread */
r_typedef
r_struct
(brace
DECL|member|Reserv
id|hfs_byte_t
id|Reserv
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* reserved by Apple */
DECL|member|ParID
id|hfs_lword_t
id|ParID
suffix:semicolon
multiline_comment|/* CNID of parent directory */
DECL|member|CName
r_struct
id|hfs_name
id|CName
suffix:semicolon
multiline_comment|/* The name of this entry */
DECL|typedef|THD_REC
)brace
id|__attribute__
c_func
(paren
(paren
id|packed
)paren
)paren
id|THD_REC
suffix:semicolon
multiline_comment|/* A catalog tree record */
DECL|struct|hfs_cat_rec
r_struct
id|hfs_cat_rec
(brace
DECL|member|cdrType
id|hfs_byte_t
id|cdrType
suffix:semicolon
multiline_comment|/* The type of entry */
DECL|member|cdrResrv2
id|hfs_byte_t
id|cdrResrv2
suffix:semicolon
multiline_comment|/* padding */
r_union
(brace
DECL|member|fil
id|FIL_REC
id|fil
suffix:semicolon
DECL|member|dir
id|DIR_REC
id|dir
suffix:semicolon
DECL|member|thd
id|THD_REC
id|thd
suffix:semicolon
DECL|member|u
)brace
id|u
suffix:semicolon
)brace
id|__attribute__
c_func
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
multiline_comment|/*================ File-local variables ================*/
r_static
id|LIST_HEAD
c_func
(paren
id|entry_in_use
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|entry_unused
)paren
suffix:semicolon
DECL|variable|hash_table
r_static
r_struct
id|list_head
id|hash_table
(braket
id|C_HASHSIZE
)braket
suffix:semicolon
DECL|variable|entry_lock
id|spinlock_t
id|entry_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_static
r_struct
(brace
DECL|member|nr_entries
r_int
id|nr_entries
suffix:semicolon
DECL|member|nr_free_entries
r_int
id|nr_free_entries
suffix:semicolon
DECL|variable|entries_stat
)brace
id|entries_stat
suffix:semicolon
multiline_comment|/*================ File-local functions ================*/
multiline_comment|/*&n; * brec_to_id&n; *&n; * Get the CNID from a brec&n; */
DECL|function|brec_to_id
r_static
r_inline
id|hfs_u32
id|brec_to_id
c_func
(paren
r_struct
id|hfs_brec
op_star
id|brec
)paren
(brace
r_struct
id|hfs_cat_rec
op_star
id|rec
op_assign
id|brec-&gt;data
suffix:semicolon
r_return
id|hfs_get_nl
c_func
(paren
(paren
id|rec-&gt;cdrType
op_eq
id|HFS_CDR_FIL
)paren
ques
c_cond
id|rec-&gt;u.fil.FlNum
suffix:colon
id|rec-&gt;u.dir.DirID
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hashfn()&n; *&n; * hash an (struct mdb *) and a (struct hfs_cat_key *) to an integer.&n; */
DECL|function|hashfn
r_static
r_inline
r_int
r_int
id|hashfn
c_func
(paren
r_const
r_struct
id|hfs_mdb
op_star
id|mdb
comma
r_const
r_struct
id|hfs_cat_key
op_star
id|key
)paren
(brace
r_int
r_int
id|hash
suffix:semicolon
id|hash
op_assign
(paren
r_int
r_int
)paren
id|mdb
op_or
(paren
r_int
r_int
)paren
id|key-&gt;ParID
(braket
l_int|3
)braket
op_or
id|hfs_strhash
c_func
(paren
id|key-&gt;CName.Name
comma
id|key-&gt;CName.Len
)paren
suffix:semicolon
id|hash
op_assign
id|hash
op_xor
(paren
id|hash
op_rshift
id|C_HASHBITS
)paren
op_xor
(paren
id|hash
op_rshift
id|C_HASHBITS
op_star
l_int|2
)paren
suffix:semicolon
r_return
id|hash
op_amp
id|C_HASHMASK
suffix:semicolon
)brace
multiline_comment|/*&n; * hash()&n; *&n; * hash an (struct mdb *) and a (struct hfs_cat_key *)&n; * to a pointer to a slot in the hash table.&n; */
DECL|function|hash
r_static
r_inline
r_struct
id|list_head
op_star
id|hash
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
comma
r_const
r_struct
id|hfs_cat_key
op_star
id|key
)paren
(brace
r_return
id|hash_table
op_plus
id|hashfn
c_func
(paren
id|mdb
comma
id|key
)paren
suffix:semicolon
)brace
DECL|function|insert_hash
r_static
r_inline
r_void
id|insert_hash
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
r_struct
id|list_head
op_star
id|head
op_assign
id|hash
c_func
(paren
id|entry-&gt;mdb
comma
op_amp
id|entry-&gt;key
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|entry-&gt;hash
comma
id|head
)paren
suffix:semicolon
)brace
DECL|function|remove_hash
r_static
r_inline
r_void
id|remove_hash
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|entry-&gt;hash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|entry-&gt;hash
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * wait_on_entry()&n; *&n; * Sleep until a locked entry is unlocked.&n; */
DECL|function|wait_on_entry
r_static
r_inline
r_void
id|wait_on_entry
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
r_while
c_loop
(paren
(paren
id|entry-&gt;state
op_amp
id|HFS_LOCK
)paren
)paren
(brace
id|hfs_sleep_on
c_func
(paren
op_amp
id|entry-&gt;wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * lock_entry()&n; *&n; * Obtain an exclusive lock on an entry.&n; */
DECL|function|lock_entry
r_static
r_void
id|lock_entry
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
id|wait_on_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
id|entry-&gt;state
op_or_assign
id|HFS_LOCK
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * lock_entry()&n; *&n; * Relinquish an exclusive lock on an entry.&n; */
DECL|function|unlock_entry
r_static
r_void
id|unlock_entry
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
id|entry-&gt;state
op_and_assign
op_complement
id|HFS_LOCK
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
id|hfs_wake_up
c_func
(paren
op_amp
id|entry-&gt;wait
)paren
suffix:semicolon
)brace
multiline_comment|/* put entry on mdb dirty list. */
DECL|function|hfs_cat_mark_dirty
r_void
id|hfs_cat_mark_dirty
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
r_struct
id|hfs_mdb
op_star
id|mdb
op_assign
id|entry-&gt;mdb
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;state
op_amp
id|HFS_DIRTY
)paren
)paren
(brace
id|entry-&gt;state
op_or_assign
id|HFS_DIRTY
suffix:semicolon
multiline_comment|/* Only add valid (ie hashed) entries to the dirty list. */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|entry-&gt;hash
)paren
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|entry-&gt;list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|entry-&gt;list
comma
op_amp
id|mdb-&gt;entry_dirty
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* delete an entry and remove it from the hash table. */
DECL|function|delete_entry
r_static
r_void
id|delete_entry
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;state
op_amp
id|HFS_DELETED
)paren
)paren
(brace
id|entry-&gt;state
op_or_assign
id|HFS_DELETED
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|entry-&gt;hash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|entry-&gt;hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;type
op_eq
id|HFS_CDR_FIL
)paren
(brace
multiline_comment|/* free all extents */
id|entry-&gt;u.file.data_fork.lsize
op_assign
l_int|0
suffix:semicolon
id|hfs_extent_adj
c_func
(paren
op_amp
id|entry-&gt;u.file.data_fork
)paren
suffix:semicolon
id|entry-&gt;u.file.rsrc_fork.lsize
op_assign
l_int|0
suffix:semicolon
id|hfs_extent_adj
c_func
(paren
op_amp
id|entry-&gt;u.file.rsrc_fork
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|init_entry
r_static
r_inline
r_void
id|init_entry
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
id|memset
c_func
(paren
id|entry
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|entry
)paren
)paren
suffix:semicolon
id|hfs_init_waitqueue
c_func
(paren
op_amp
id|entry-&gt;wait
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|entry-&gt;hash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|entry-&gt;list
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_cat_alloc()&n; *&n; * Try to allocate another entry. &n; */
DECL|function|hfs_cat_alloc
r_static
r_inline
r_struct
id|hfs_cat_entry
op_star
id|hfs_cat_alloc
c_func
(paren
r_void
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|HFS_NEW
c_func
(paren
id|entry
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|init_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
id|entry
suffix:semicolon
)brace
multiline_comment|/* this gets called with the spinlock held. */
DECL|function|grow_entries
r_static
r_int
id|grow_entries
c_func
(paren
r_void
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|entry
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CCACHE_INC
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry
op_assign
id|hfs_cat_alloc
c_func
(paren
)paren
)paren
)paren
r_break
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|entry-&gt;list
comma
op_amp
id|entry_unused
)paren
suffix:semicolon
)brace
id|entries_stat.nr_entries
op_add_assign
id|i
suffix:semicolon
id|entries_stat.nr_free_entries
op_add_assign
id|i
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * __read_entry()&n; *&n; * Convert a (struct hfs_cat_rec) to a (struct hfs_cat_entry).&n; */
DECL|function|__read_entry
r_static
r_void
id|__read_entry
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
comma
r_const
r_struct
id|hfs_cat_rec
op_star
id|cat
)paren
(brace
id|entry-&gt;type
op_assign
id|cat-&gt;cdrType
suffix:semicolon
r_if
c_cond
(paren
id|cat-&gt;cdrType
op_eq
id|HFS_CDR_DIR
)paren
(brace
r_struct
id|hfs_dir
op_star
id|dir
op_assign
op_amp
id|entry-&gt;u.dir
suffix:semicolon
id|entry-&gt;cnid
op_assign
id|hfs_get_nl
c_func
(paren
id|cat-&gt;u.dir.DirID
)paren
suffix:semicolon
id|dir-&gt;magic
op_assign
id|HFS_DIR_MAGIC
suffix:semicolon
id|dir-&gt;flags
op_assign
id|hfs_get_ns
c_func
(paren
id|cat-&gt;u.dir.Flags
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|entry-&gt;info.dir.dinfo
comma
op_amp
id|cat-&gt;u.dir.UsrInfo
comma
l_int|16
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|entry-&gt;info.dir.dxinfo
comma
op_amp
id|cat-&gt;u.dir.FndrInfo
comma
l_int|16
)paren
suffix:semicolon
id|entry-&gt;create_date
op_assign
id|hfs_get_nl
c_func
(paren
id|cat-&gt;u.dir.CrDat
)paren
suffix:semicolon
id|entry-&gt;modify_date
op_assign
id|hfs_get_nl
c_func
(paren
id|cat-&gt;u.dir.MdDat
)paren
suffix:semicolon
id|entry-&gt;backup_date
op_assign
id|hfs_get_nl
c_func
(paren
id|cat-&gt;u.dir.BkDat
)paren
suffix:semicolon
id|dir-&gt;dirs
op_assign
id|dir-&gt;files
op_assign
l_int|0
suffix:semicolon
id|hfs_init_waitqueue
c_func
(paren
op_amp
id|dir-&gt;read_wait
)paren
suffix:semicolon
id|hfs_init_waitqueue
c_func
(paren
op_amp
id|dir-&gt;write_wait
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cat-&gt;cdrType
op_eq
id|HFS_CDR_FIL
)paren
(brace
r_struct
id|hfs_file
op_star
id|fil
op_assign
op_amp
id|entry-&gt;u.file
suffix:semicolon
id|entry-&gt;cnid
op_assign
id|hfs_get_nl
c_func
(paren
id|cat-&gt;u.fil.FlNum
)paren
suffix:semicolon
id|fil-&gt;magic
op_assign
id|HFS_FILE_MAGIC
suffix:semicolon
id|fil-&gt;data_fork.fork
op_assign
id|HFS_FK_DATA
suffix:semicolon
id|fil-&gt;data_fork.entry
op_assign
id|entry
suffix:semicolon
id|fil-&gt;data_fork.lsize
op_assign
id|hfs_get_hl
c_func
(paren
id|cat-&gt;u.fil.LgLen
)paren
suffix:semicolon
id|fil-&gt;data_fork.psize
op_assign
id|hfs_get_hl
c_func
(paren
id|cat-&gt;u.fil.PyLen
)paren
op_rshift
id|HFS_SECTOR_SIZE_BITS
suffix:semicolon
id|hfs_extent_in
c_func
(paren
op_amp
id|fil-&gt;data_fork
comma
id|cat-&gt;u.fil.ExtRec
)paren
suffix:semicolon
id|fil-&gt;rsrc_fork.fork
op_assign
id|HFS_FK_RSRC
suffix:semicolon
id|fil-&gt;rsrc_fork.entry
op_assign
id|entry
suffix:semicolon
id|fil-&gt;rsrc_fork.lsize
op_assign
id|hfs_get_hl
c_func
(paren
id|cat-&gt;u.fil.RLgLen
)paren
suffix:semicolon
id|fil-&gt;rsrc_fork.psize
op_assign
id|hfs_get_hl
c_func
(paren
id|cat-&gt;u.fil.RPyLen
)paren
op_rshift
id|HFS_SECTOR_SIZE_BITS
suffix:semicolon
id|hfs_extent_in
c_func
(paren
op_amp
id|fil-&gt;rsrc_fork
comma
id|cat-&gt;u.fil.RExtRec
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|entry-&gt;info.file.finfo
comma
op_amp
id|cat-&gt;u.fil.UsrWds
comma
l_int|16
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|entry-&gt;info.file.fxinfo
comma
op_amp
id|cat-&gt;u.fil.FndrInfo
comma
l_int|16
)paren
suffix:semicolon
id|entry-&gt;create_date
op_assign
id|hfs_get_nl
c_func
(paren
id|cat-&gt;u.fil.CrDat
)paren
suffix:semicolon
id|entry-&gt;modify_date
op_assign
id|hfs_get_nl
c_func
(paren
id|cat-&gt;u.fil.MdDat
)paren
suffix:semicolon
id|entry-&gt;backup_date
op_assign
id|hfs_get_nl
c_func
(paren
id|cat-&gt;u.fil.BkDat
)paren
suffix:semicolon
id|fil-&gt;clumpablks
op_assign
(paren
id|hfs_get_hs
c_func
(paren
id|cat-&gt;u.fil.ClpSize
)paren
op_div
id|entry-&gt;mdb-&gt;alloc_blksz
)paren
op_rshift
id|HFS_SECTOR_SIZE_BITS
suffix:semicolon
id|fil-&gt;flags
op_assign
id|cat-&gt;u.fil.Flags
suffix:semicolon
)brace
r_else
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_fs: entry is neither file nor directory!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * count_dir_entries()&n; *&n; * Count the number of files and directories in a given directory.&n; */
DECL|function|count_dir_entries
r_static
r_inline
r_void
id|count_dir_entries
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
comma
r_struct
id|hfs_brec
op_star
id|brec
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|hfs_u32
id|cnid
suffix:semicolon
id|hfs_u8
id|type
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hfs_cat_open
c_func
(paren
id|entry
comma
id|brec
)paren
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|error
op_assign
id|hfs_cat_next
c_func
(paren
id|entry
comma
id|brec
comma
l_int|1
comma
op_amp
id|cnid
comma
op_amp
id|type
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|type
op_eq
id|HFS_CDR_FIL
)paren
(brace
op_increment
id|entry-&gt;u.dir.files
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|HFS_CDR_DIR
)paren
(brace
op_increment
id|entry-&gt;u.dir.dirs
suffix:semicolon
)brace
)brace
multiline_comment|/* -ENOENT is normal termination */
)brace
r_if
c_cond
(paren
id|error
op_ne
op_minus
id|ENOENT
)paren
(brace
id|entry-&gt;cnid
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * read_entry()&n; *&n; * Convert a (struct hfs_brec) to a (struct hfs_cat_entry).&n; */
DECL|function|read_entry
r_static
r_inline
r_void
id|read_entry
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
comma
r_struct
id|hfs_brec
op_star
id|brec
)paren
(brace
r_int
id|need_count
suffix:semicolon
r_struct
id|hfs_cat_rec
op_star
id|rec
op_assign
id|brec-&gt;data
suffix:semicolon
id|__read_entry
c_func
(paren
id|entry
comma
id|rec
)paren
suffix:semicolon
id|need_count
op_assign
(paren
id|rec-&gt;cdrType
op_eq
id|HFS_CDR_DIR
)paren
op_logical_and
id|rec-&gt;u.dir.Val
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_count
)paren
(brace
id|count_dir_entries
c_func
(paren
id|entry
comma
id|brec
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * __write_entry()&n; *&n; * Convert a (struct hfs_cat_entry) to a (struct hfs_cat_rec).&n; */
DECL|function|__write_entry
r_static
r_void
id|__write_entry
c_func
(paren
r_const
r_struct
id|hfs_cat_entry
op_star
id|entry
comma
r_struct
id|hfs_cat_rec
op_star
id|cat
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;type
op_eq
id|HFS_CDR_DIR
)paren
(brace
r_const
r_struct
id|hfs_dir
op_star
id|dir
op_assign
op_amp
id|entry-&gt;u.dir
suffix:semicolon
id|hfs_put_ns
c_func
(paren
id|dir-&gt;flags
comma
id|cat-&gt;u.dir.Flags
)paren
suffix:semicolon
id|hfs_put_hs
c_func
(paren
id|dir-&gt;dirs
op_plus
id|dir-&gt;files
comma
id|cat-&gt;u.dir.Val
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|entry-&gt;cnid
comma
id|cat-&gt;u.dir.DirID
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|entry-&gt;create_date
comma
id|cat-&gt;u.dir.CrDat
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|entry-&gt;modify_date
comma
id|cat-&gt;u.dir.MdDat
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|entry-&gt;backup_date
comma
id|cat-&gt;u.dir.BkDat
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|cat-&gt;u.dir.UsrInfo
comma
op_amp
id|entry-&gt;info.dir.dinfo
comma
l_int|16
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|cat-&gt;u.dir.FndrInfo
comma
op_amp
id|entry-&gt;info.dir.dxinfo
comma
l_int|16
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry-&gt;type
op_eq
id|HFS_CDR_FIL
)paren
(brace
r_const
r_struct
id|hfs_file
op_star
id|fil
op_assign
op_amp
id|entry-&gt;u.file
suffix:semicolon
id|cat-&gt;u.fil.Flags
op_assign
id|fil-&gt;flags
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|entry-&gt;cnid
comma
id|cat-&gt;u.fil.FlNum
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|cat-&gt;u.fil.UsrWds
comma
op_amp
id|entry-&gt;info.file.finfo
comma
l_int|16
)paren
suffix:semicolon
id|hfs_put_hl
c_func
(paren
id|fil-&gt;data_fork.lsize
comma
id|cat-&gt;u.fil.LgLen
)paren
suffix:semicolon
id|hfs_put_hl
c_func
(paren
id|fil-&gt;data_fork.psize
op_lshift
id|HFS_SECTOR_SIZE_BITS
comma
id|cat-&gt;u.fil.PyLen
)paren
suffix:semicolon
id|hfs_put_hl
c_func
(paren
id|fil-&gt;rsrc_fork.lsize
comma
id|cat-&gt;u.fil.RLgLen
)paren
suffix:semicolon
id|hfs_put_hl
c_func
(paren
id|fil-&gt;rsrc_fork.psize
op_lshift
id|HFS_SECTOR_SIZE_BITS
comma
id|cat-&gt;u.fil.RPyLen
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|entry-&gt;create_date
comma
id|cat-&gt;u.fil.CrDat
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|entry-&gt;modify_date
comma
id|cat-&gt;u.fil.MdDat
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|entry-&gt;backup_date
comma
id|cat-&gt;u.fil.BkDat
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|cat-&gt;u.fil.FndrInfo
comma
op_amp
id|entry-&gt;info.file.fxinfo
comma
l_int|16
)paren
suffix:semicolon
id|hfs_put_hs
c_func
(paren
(paren
id|fil-&gt;clumpablks
op_star
id|entry-&gt;mdb-&gt;alloc_blksz
)paren
op_lshift
id|HFS_SECTOR_SIZE_BITS
comma
id|cat-&gt;u.fil.ClpSize
)paren
suffix:semicolon
id|hfs_extent_out
c_func
(paren
op_amp
id|fil-&gt;data_fork
comma
id|cat-&gt;u.fil.ExtRec
)paren
suffix:semicolon
id|hfs_extent_out
c_func
(paren
op_amp
id|fil-&gt;rsrc_fork
comma
id|cat-&gt;u.fil.RExtRec
)paren
suffix:semicolon
)brace
r_else
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;__write_entry: invalid entry&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * write_entry()&n; *&n; * Write a modified entry back to the catalog B-tree. this gets called&n; * with the entry locked.&n; */
DECL|function|write_entry
r_static
r_void
id|write_entry
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
r_struct
id|hfs_brec
id|brec
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;state
op_amp
id|HFS_DELETED
)paren
)paren
(brace
id|error
op_assign
id|hfs_bfind
c_func
(paren
op_amp
id|brec
comma
id|entry-&gt;mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|entry-&gt;key
)paren
comma
id|HFS_BFIND_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_if
c_cond
(paren
(paren
id|entry-&gt;state
op_amp
id|HFS_KEYDIRTY
)paren
)paren
(brace
multiline_comment|/* key may have changed case due to a rename */
id|entry-&gt;state
op_and_assign
op_complement
id|HFS_KEYDIRTY
suffix:semicolon
r_if
c_cond
(paren
id|brec.key-&gt;KeyLen
op_ne
id|entry-&gt;key.KeyLen
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_write_entry: key length &quot;
l_string|&quot;changed!&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|brec.key
comma
op_amp
id|entry-&gt;key
comma
id|entry-&gt;key.KeyLen
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|entry-&gt;cnid
op_ne
id|brec_to_id
c_func
(paren
op_amp
id|brec
)paren
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_write_entry: CNID &quot;
l_string|&quot;changed unexpectedly!&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|__write_entry
c_func
(paren
id|entry
comma
id|brec.data
)paren
suffix:semicolon
)brace
id|hfs_brec_relse
c_func
(paren
op_amp
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_write_entry: unable to write &quot;
l_string|&quot;entry %08x&bslash;n&quot;
comma
id|entry-&gt;cnid
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* this gets called with the spinlock held. */
DECL|function|find_entry
r_static
r_struct
id|hfs_cat_entry
op_star
id|find_entry
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
comma
r_const
r_struct
id|hfs_cat_key
op_star
id|key
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
comma
op_star
id|head
op_assign
id|hash
c_func
(paren
id|mdb
comma
id|key
)paren
suffix:semicolon
r_struct
id|hfs_cat_entry
op_star
id|entry
suffix:semicolon
id|tmp
op_assign
id|head
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
id|entry
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
id|head
)paren
r_break
suffix:semicolon
id|entry
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|hfs_cat_entry
comma
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;mdb
op_ne
id|mdb
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|hfs_cat_compare
c_func
(paren
op_amp
id|entry-&gt;key
comma
id|key
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|entry-&gt;count
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|entry
suffix:semicolon
)brace
multiline_comment|/* be careful. this gets called with the spinlock held. */
DECL|function|get_new_entry
r_static
r_struct
id|hfs_cat_entry
op_star
id|get_new_entry
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
comma
r_const
r_struct
id|hfs_cat_key
op_star
id|key
comma
r_const
r_int
id|read
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|entry
suffix:semicolon
r_struct
id|list_head
op_star
id|head
op_assign
id|hash
c_func
(paren
id|mdb
comma
id|key
)paren
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|add_new_entry
suffix:colon
id|tmp
op_assign
id|entry_unused.next
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_ne
op_amp
id|entry_unused
)paren
)paren
(brace
id|list_del
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|entries_stat.nr_free_entries
op_decrement
suffix:semicolon
id|entry
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|hfs_cat_entry
comma
id|list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|entry-&gt;list
comma
op_amp
id|entry_in_use
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|entry-&gt;hash
comma
id|head
)paren
suffix:semicolon
id|entry-&gt;mdb
op_assign
id|mdb
suffix:semicolon
id|entry-&gt;count
op_assign
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|entry-&gt;key
comma
id|key
comma
r_sizeof
(paren
op_star
id|key
)paren
)paren
suffix:semicolon
id|entry-&gt;state
op_assign
id|HFS_LOCK
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read
)paren
(brace
r_struct
id|hfs_brec
id|brec
suffix:semicolon
r_if
c_cond
(paren
id|hfs_bfind
c_func
(paren
op_amp
id|brec
comma
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
id|key
)paren
comma
id|HFS_BFIND_READ_EQ
)paren
)paren
(brace
multiline_comment|/* uh oh. we failed to read the record.&n;&t;&t;&t; * the entry doesn&squot;t actually exist. */
r_goto
id|read_fail
suffix:semicolon
)brace
id|read_entry
c_func
(paren
id|entry
comma
op_amp
id|brec
)paren
suffix:semicolon
multiline_comment|/* error */
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;cnid
)paren
(brace
r_goto
id|read_fail
suffix:semicolon
)brace
multiline_comment|/* we don&squot;t have to acquire a spinlock here or&n;&t;&t;    * below for the unlocking bits as we&squot;re the first&n;&t;&t;    * user of this entry. */
id|entry-&gt;state
op_and_assign
op_complement
id|HFS_LOCK
suffix:semicolon
id|hfs_wake_up
c_func
(paren
op_amp
id|entry-&gt;wait
)paren
suffix:semicolon
)brace
r_return
id|entry
suffix:semicolon
)brace
multiline_comment|/* try to allocate more entries. grow_entries() doesn&squot;t release&n;&t; * the spinlock. */
r_if
c_cond
(paren
id|grow_entries
c_func
(paren
)paren
)paren
r_goto
id|add_new_entry
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
id|read_fail
suffix:colon
multiline_comment|/* short-cut hfs_cat_put by doing everything here. */
id|spin_lock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|entry-&gt;hash
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|entry-&gt;list
)paren
suffix:semicolon
id|init_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|entry-&gt;list
comma
op_amp
id|entry_unused
)paren
suffix:semicolon
id|entries_stat.nr_free_entries
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * get_entry()&n; *&n; * Try to return an entry for the indicated file or directory.&n; * If (&squot;read&squot; == 0) then no attempt will be made to read it from disk&n; * and a locked, but uninitialized, entry is returned.&n; */
DECL|function|get_entry
r_static
r_struct
id|hfs_cat_entry
op_star
id|get_entry
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
comma
r_const
r_struct
id|hfs_cat_key
op_star
id|key
comma
r_const
r_int
id|read
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|entry
suffix:semicolon
macro_line|#if defined(DEBUG_CATALOG) || defined(DEBUG_ALL)
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_get_entry: mdb=%p key=%s read=%d&bslash;n&quot;
comma
id|mdb
comma
id|key-&gt;CName.Name
comma
id|read
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
id|entry
op_assign
id|find_entry
c_func
(paren
id|mdb
comma
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
(brace
r_return
id|get_new_entry
c_func
(paren
id|mdb
comma
id|key
comma
id|read
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
id|wait_on_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
id|entry
suffix:semicolon
)brace
multiline_comment|/* &n; * new_cnid()&n; *&n; * Allocate a CNID to use for a new file or directory.&n; */
DECL|function|new_cnid
r_static
r_inline
id|hfs_u32
id|new_cnid
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
)paren
(brace
multiline_comment|/* If the create succeeds then the mdb will get dirtied */
r_return
id|htonl
c_func
(paren
id|mdb-&gt;next_id
op_increment
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * update_dir()&n; *&n; * Update counts, times and dirt on a changed directory&n; */
DECL|function|update_dir
r_static
r_void
id|update_dir
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
comma
r_struct
id|hfs_cat_entry
op_star
id|dir
comma
r_int
id|is_dir
comma
r_int
id|count
)paren
(brace
multiline_comment|/* update counts */
r_if
c_cond
(paren
id|is_dir
)paren
(brace
id|mdb-&gt;dir_count
op_add_assign
id|count
suffix:semicolon
id|dir-&gt;u.dir.dirs
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;cnid
op_eq
id|htonl
c_func
(paren
id|HFS_ROOT_CNID
)paren
)paren
(brace
id|mdb-&gt;root_dirs
op_add_assign
id|count
suffix:semicolon
)brace
)brace
r_else
(brace
id|mdb-&gt;file_count
op_add_assign
id|count
suffix:semicolon
id|dir-&gt;u.dir.files
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;cnid
op_eq
id|htonl
c_func
(paren
id|HFS_ROOT_CNID
)paren
)paren
(brace
id|mdb-&gt;root_files
op_add_assign
id|count
suffix:semicolon
)brace
)brace
multiline_comment|/* update times and dirt */
id|dir-&gt;modify_date
op_assign
id|hfs_time
c_func
(paren
)paren
suffix:semicolon
id|hfs_cat_mark_dirty
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a writer to dir, excluding readers.&n; *&n; * XXX: this is wrong. it allows a move to occur when a directory&n; *      is being written to. &n; */
DECL|function|start_write
r_static
r_inline
r_void
id|start_write
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|dir
)paren
(brace
r_if
c_cond
(paren
id|dir-&gt;u.dir.readers
op_logical_or
id|waitqueue_active
c_func
(paren
op_amp
id|dir-&gt;u.dir.read_wait
)paren
)paren
(brace
id|hfs_sleep_on
c_func
(paren
op_amp
id|dir-&gt;u.dir.write_wait
)paren
suffix:semicolon
)brace
op_increment
id|dir-&gt;u.dir.writers
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a reader to dir, excluding writers.&n; */
DECL|function|start_read
r_static
r_inline
r_void
id|start_read
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|dir
)paren
(brace
r_if
c_cond
(paren
id|dir-&gt;u.dir.writers
op_logical_or
id|waitqueue_active
c_func
(paren
op_amp
id|dir-&gt;u.dir.write_wait
)paren
)paren
(brace
id|hfs_sleep_on
c_func
(paren
op_amp
id|dir-&gt;u.dir.read_wait
)paren
suffix:semicolon
)brace
op_increment
id|dir-&gt;u.dir.readers
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a writer from dir, possibly admitting readers.&n; */
DECL|function|end_write
r_static
r_inline
r_void
id|end_write
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|dir
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_decrement
id|dir-&gt;u.dir.writers
)paren
)paren
(brace
id|hfs_wake_up
c_func
(paren
op_amp
id|dir-&gt;u.dir.read_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Remove a reader from dir, possibly admitting writers.&n; */
DECL|function|end_read
r_static
r_inline
r_void
id|end_read
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|dir
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_decrement
id|dir-&gt;u.dir.readers
)paren
)paren
(brace
id|hfs_wake_up
c_func
(paren
op_amp
id|dir-&gt;u.dir.write_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * create_entry()&n; *&n; * Add a new file or directory to the catalog B-tree and&n; * return a (struct hfs_cat_entry) for it in &squot;*result&squot;.&n; */
DECL|function|create_entry
r_static
r_int
id|create_entry
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|parent
comma
r_struct
id|hfs_cat_key
op_star
id|key
comma
r_const
r_struct
id|hfs_cat_rec
op_star
id|record
comma
r_int
id|is_dir
comma
id|hfs_u32
id|cnid
comma
r_struct
id|hfs_cat_entry
op_star
op_star
id|result
)paren
(brace
r_struct
id|hfs_mdb
op_star
id|mdb
op_assign
id|parent-&gt;mdb
suffix:semicolon
r_struct
id|hfs_cat_entry
op_star
id|entry
suffix:semicolon
r_struct
id|hfs_cat_key
id|thd_key
suffix:semicolon
r_struct
id|hfs_cat_rec
id|thd_rec
suffix:semicolon
r_int
id|error
comma
id|has_thread
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* keep readers from getting confused by changing dir size */
id|start_write
c_func
(paren
id|parent
)paren
suffix:semicolon
multiline_comment|/* create a locked entry in the cache */
id|entry
op_assign
id|get_entry
c_func
(paren
id|mdb
comma
id|key
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
(brace
multiline_comment|/* The entry exists but can&squot;t be read */
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;cnid
)paren
(brace
multiline_comment|/* The (unlocked) entry exists in the cache */
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|bail2
suffix:semicolon
)brace
multiline_comment|/* limit directory valence to signed 16-bit integer */
r_if
c_cond
(paren
(paren
id|parent-&gt;u.dir.dirs
op_plus
id|parent-&gt;u.dir.files
)paren
op_ge
id|HFS_MAX_VALENCE
)paren
(brace
id|error
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_goto
id|bail1
suffix:semicolon
)brace
id|has_thread
op_assign
id|is_dir
op_logical_or
(paren
id|record-&gt;u.fil.Flags
op_amp
id|HFS_FIL_THD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_thread
)paren
(brace
multiline_comment|/* init some fields for the thread record */
id|memset
c_func
(paren
op_amp
id|thd_rec
comma
l_int|0
comma
r_sizeof
(paren
id|thd_rec
)paren
)paren
suffix:semicolon
id|thd_rec.cdrType
op_assign
id|is_dir
ques
c_cond
id|HFS_CDR_THD
suffix:colon
id|HFS_CDR_FTH
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|thd_rec.u.thd.ParID
comma
op_amp
id|key-&gt;ParID
comma
r_sizeof
(paren
id|hfs_u32
)paren
op_plus
r_sizeof
(paren
r_struct
id|hfs_name
)paren
)paren
suffix:semicolon
multiline_comment|/* insert the thread record */
id|hfs_cat_build_key
c_func
(paren
id|cnid
comma
l_int|NULL
comma
op_amp
id|thd_key
)paren
suffix:semicolon
id|error
op_assign
id|hfs_binsert
c_func
(paren
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|thd_key
)paren
comma
op_amp
id|thd_rec
comma
l_int|2
op_plus
r_sizeof
(paren
id|THD_REC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|bail1
suffix:semicolon
)brace
)brace
multiline_comment|/* insert the record */
id|error
op_assign
id|hfs_binsert
c_func
(paren
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
id|key
)paren
comma
id|record
comma
id|is_dir
ques
c_cond
l_int|2
op_plus
r_sizeof
(paren
id|DIR_REC
)paren
suffix:colon
l_int|2
op_plus
r_sizeof
(paren
id|FIL_REC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|has_thread
op_logical_and
(paren
id|error
op_ne
op_minus
id|EIO
)paren
)paren
(brace
multiline_comment|/* at least TRY to remove the thread record */
(paren
r_void
)paren
id|hfs_bdelete
c_func
(paren
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|thd_key
)paren
)paren
suffix:semicolon
)brace
r_goto
id|bail1
suffix:semicolon
)brace
multiline_comment|/* update the parent directory */
id|update_dir
c_func
(paren
id|mdb
comma
id|parent
comma
id|is_dir
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* complete the cache entry and return success */
id|__read_entry
c_func
(paren
id|entry
comma
id|record
)paren
suffix:semicolon
id|unlock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
op_star
id|result
op_assign
id|entry
suffix:semicolon
)brace
r_else
(brace
id|hfs_cat_put
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
r_goto
id|done
suffix:semicolon
id|bail1
suffix:colon
multiline_comment|/* entry really didn&squot;t exist, so we don&squot;t need to really delete it.&n;&t; * we do need to remove it from the hash, though. */
id|entry-&gt;state
op_or_assign
id|HFS_DELETED
suffix:semicolon
id|remove_hash
c_func
(paren
id|entry
)paren
suffix:semicolon
id|unlock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|bail2
suffix:colon
id|hfs_cat_put
c_func
(paren
id|entry
)paren
suffix:semicolon
id|done
suffix:colon
id|end_write
c_func
(paren
id|parent
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*================ Global functions ================*/
multiline_comment|/* &n; * hfs_cat_put()&n; *&n; * Release an entry we aren&squot;t using anymore.&n; *&n; * nothing in hfs_cat_put goes to sleep now except on the initial entry.  &n; */
DECL|function|hfs_cat_put
r_void
id|hfs_cat_put
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
r_if
c_cond
(paren
id|entry
)paren
(brace
id|wait_on_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
multiline_comment|/* just in case. this should never happen. */
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;count
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_cat_put: trying to free free entry: %p&bslash;n&quot;
comma
id|entry
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if defined(DEBUG_CATALOG) || defined(DEBUG_ALL)
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_cat_put: %p(%u) type=%d state=%lu&bslash;n&quot;
comma
id|entry
comma
id|entry-&gt;count
comma
id|entry-&gt;type
comma
id|entry-&gt;state
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|entry-&gt;count
)paren
(brace
r_if
c_cond
(paren
(paren
id|entry-&gt;state
op_amp
id|HFS_DELETED
)paren
)paren
r_goto
id|entry_deleted
suffix:semicolon
r_if
c_cond
(paren
(paren
id|entry-&gt;type
op_eq
id|HFS_CDR_FIL
)paren
)paren
(brace
multiline_comment|/* clear out any cached extents */
r_if
c_cond
(paren
id|entry-&gt;u.file.data_fork.first.next
)paren
(brace
id|hfs_extent_free
c_func
(paren
op_amp
id|entry-&gt;u.file.data_fork
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;u.file.rsrc_fork.first.next
)paren
(brace
id|hfs_extent_free
c_func
(paren
op_amp
id|entry-&gt;u.file.rsrc_fork
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* if we put a dirty entry, write it out. */
r_if
c_cond
(paren
(paren
id|entry-&gt;state
op_amp
id|HFS_DIRTY
)paren
)paren
(brace
id|entry-&gt;state
op_xor_assign
id|HFS_DIRTY
op_or
id|HFS_LOCK
suffix:semicolon
id|write_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|entry-&gt;state
op_and_assign
op_complement
id|HFS_LOCK
suffix:semicolon
)brace
id|list_del
c_func
(paren
op_amp
id|entry-&gt;hash
)paren
suffix:semicolon
id|entry_deleted
suffix:colon
multiline_comment|/* deleted entries have already been removed&n;&t;&t;&t; * from the hash list. */
id|list_del
c_func
(paren
op_amp
id|entry-&gt;list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entries_stat.nr_free_entries
OG
id|CCACHE_MAX
)paren
(brace
id|HFS_DELETE
c_func
(paren
id|entry
)paren
suffix:semicolon
id|entries_stat.nr_entries
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|init_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|entry-&gt;list
comma
op_amp
id|entry_unused
)paren
suffix:semicolon
id|entries_stat.nr_free_entries
op_increment
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * hfs_cat_get()&n; *&n; * Wrapper for get_entry() which always calls with (&squot;read&squot;==1).&n; * Used for access to get_entry() from outside this file.&n; */
DECL|function|hfs_cat_get
r_struct
id|hfs_cat_entry
op_star
id|hfs_cat_get
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
comma
r_const
r_struct
id|hfs_cat_key
op_star
id|key
)paren
(brace
r_return
id|get_entry
c_func
(paren
id|mdb
comma
id|key
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* invalidate all entries for a device */
DECL|function|invalidate_list
r_static
r_void
id|invalidate_list
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_struct
id|hfs_mdb
op_star
id|mdb
comma
r_struct
id|list_head
op_star
id|dispose
)paren
(brace
r_struct
id|list_head
op_star
id|next
suffix:semicolon
id|next
op_assign
id|head-&gt;next
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
op_assign
id|next
suffix:semicolon
r_struct
id|hfs_cat_entry
op_star
id|entry
suffix:semicolon
id|next
op_assign
id|next-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
id|head
)paren
r_break
suffix:semicolon
id|entry
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|hfs_cat_entry
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;mdb
op_ne
id|mdb
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;count
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|entry-&gt;hash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|entry-&gt;hash
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|entry-&gt;list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|entry-&gt;list
comma
id|dispose
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_fs: entry %p(%u) busy on removed device %s.&bslash;n&quot;
comma
id|entry
comma
id|entry-&gt;count
comma
id|hfs_mdb_name
c_func
(paren
id|entry-&gt;mdb-&gt;sys_mdb
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* delete entries from a list */
DECL|function|delete_list
r_static
r_void
id|delete_list
c_func
(paren
r_struct
id|list_head
op_star
id|head
)paren
(brace
r_struct
id|list_head
op_star
id|next
op_assign
id|head-&gt;next
suffix:semicolon
r_struct
id|hfs_cat_entry
op_star
id|entry
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
op_assign
id|next
suffix:semicolon
id|next
op_assign
id|next-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
id|head
)paren
(brace
r_break
suffix:semicolon
)brace
id|entry
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|hfs_cat_entry
comma
id|list
)paren
suffix:semicolon
id|HFS_DELETE
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * hfs_cat_invalidate()&n; *&n; * Called by hfs_mdb_put() to remove all the entries&n; * in the cache that are associated with a given MDB.&n; */
DECL|function|hfs_cat_invalidate
r_void
id|hfs_cat_invalidate
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
)paren
(brace
id|LIST_HEAD
c_func
(paren
id|throw_away
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
id|invalidate_list
c_func
(paren
op_amp
id|entry_in_use
comma
id|mdb
comma
op_amp
id|throw_away
)paren
suffix:semicolon
id|invalidate_list
c_func
(paren
op_amp
id|mdb-&gt;entry_dirty
comma
id|mdb
comma
op_amp
id|throw_away
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
id|delete_list
c_func
(paren
op_amp
id|throw_away
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_CATALOG) || defined(DEBUG_ALL)
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_cat_invalidate: free=%d total=%d&bslash;n&quot;
comma
id|entries_stat.nr_free_entries
comma
id|entries_stat.nr_entries
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * hfs_cat_commit()&n; *&n; * Called by hfs_mdb_commit() to write dirty entries to the disk buffers.&n; */
DECL|function|hfs_cat_commit
r_void
id|hfs_cat_commit
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
comma
op_star
id|head
op_assign
op_amp
id|mdb-&gt;entry_dirty
suffix:semicolon
r_struct
id|hfs_cat_entry
op_star
id|entry
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|head-&gt;prev
)paren
op_ne
id|head
)paren
(brace
id|entry
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|hfs_cat_entry
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|entry-&gt;state
op_amp
id|HFS_LOCK
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
id|wait_on_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|list_head
op_star
id|insert
op_assign
op_amp
id|entry_in_use
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;count
)paren
id|insert
op_assign
id|entry_in_use.prev
suffix:semicolon
multiline_comment|/* add to in_use list */
id|list_del
c_func
(paren
op_amp
id|entry-&gt;list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|entry-&gt;list
comma
id|insert
)paren
suffix:semicolon
multiline_comment|/* reset DIRTY, set LOCK */
id|entry-&gt;state
op_xor_assign
id|HFS_DIRTY
op_or
id|HFS_LOCK
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
id|write_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
id|entry-&gt;state
op_and_assign
op_complement
id|HFS_LOCK
suffix:semicolon
id|hfs_wake_up
c_func
(paren
op_amp
id|entry-&gt;wait
)paren
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_cat_free()&n; *&n; * Releases all the memory allocated in grow_entries().&n; * Must call hfs_cat_invalidate() on all MDBs before calling this.&n; * This only gets rid of the unused pool of entries. all the other&n; * entry references should have either been freed by cat_invalidate&n; * or moved onto the unused list.&n; */
DECL|function|hfs_cat_free
r_void
id|hfs_cat_free
c_func
(paren
r_void
)paren
(brace
id|delete_list
c_func
(paren
op_amp
id|entry_unused
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_cat_compare()&n; *&n; * Description:&n; *   This is the comparison function used for the catalog B-tree.  In&n; *   comparing catalog B-tree entries, the parent id is the most&n; *   significant field (compared as unsigned ints).  The name field is&n; *   the least significant (compared in &quot;Macintosh lexical order&quot;,&n; *   see hfs_strcmp() in string.c)&n; * Input Variable(s):&n; *   struct hfs_cat_key *key1: pointer to the first key to compare&n; *   struct hfs_cat_key *key2: pointer to the second key to compare&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   int: negative if key1&lt;key2, positive if key1&gt;key2, and 0 if key1==key2&n; * Preconditions:&n; *   key1 and key2 point to &quot;valid&quot; (struct hfs_cat_key)s.&n; * Postconditions:&n; *   This function has no side-effects&n; */
DECL|function|hfs_cat_compare
r_int
id|hfs_cat_compare
c_func
(paren
r_const
r_struct
id|hfs_cat_key
op_star
id|key1
comma
r_const
r_struct
id|hfs_cat_key
op_star
id|key2
)paren
(brace
r_int
r_int
id|parents
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|parents
op_assign
id|hfs_get_hl
c_func
(paren
id|key1-&gt;ParID
)paren
op_minus
id|hfs_get_hl
c_func
(paren
id|key2-&gt;ParID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parents
op_ne
l_int|0
)paren
(brace
id|retval
op_assign
(paren
r_int
)paren
id|parents
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|hfs_strcmp
c_func
(paren
id|key1-&gt;CName.Name
comma
id|key1-&gt;CName.Len
comma
id|key2-&gt;CName.Name
comma
id|key2-&gt;CName.Len
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_cat_build_key()&n; *&n; * Given the ID of the parent and the name build a search key.&n; */
DECL|function|hfs_cat_build_key
r_void
id|hfs_cat_build_key
c_func
(paren
id|hfs_u32
id|parent
comma
r_const
r_struct
id|hfs_name
op_star
id|cname
comma
r_struct
id|hfs_cat_key
op_star
id|key
)paren
(brace
id|hfs_put_nl
c_func
(paren
id|parent
comma
id|key-&gt;ParID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cname
)paren
(brace
id|key-&gt;KeyLen
op_assign
l_int|6
op_plus
id|cname-&gt;Len
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|key-&gt;CName
comma
id|cname
comma
r_sizeof
(paren
op_star
id|cname
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|key-&gt;KeyLen
op_assign
l_int|6
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|key-&gt;CName
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cname
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * hfs_cat_open()&n; *&n; * Given a directory on an HFS filesystem get its thread and&n; * lock the directory against insertions and deletions.&n; * Return 0 on success or an error code on failure.&n; */
DECL|function|hfs_cat_open
r_int
id|hfs_cat_open
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|dir
comma
r_struct
id|hfs_brec
op_star
id|brec
)paren
(brace
r_struct
id|hfs_cat_key
id|key
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;type
op_ne
id|HFS_CDR_DIR
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Block writers */
id|start_read
c_func
(paren
id|dir
)paren
suffix:semicolon
multiline_comment|/* Find the directory */
id|hfs_cat_build_key
c_func
(paren
id|dir-&gt;cnid
comma
l_int|NULL
comma
op_amp
id|key
)paren
suffix:semicolon
id|error
op_assign
id|hfs_bfind
c_func
(paren
id|brec
comma
id|dir-&gt;mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|key
)paren
comma
id|HFS_BFIND_READ_EQ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|end_read
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_cat_next()&n; *&n; * Given a catalog brec structure, replace it with the count&squot;th next brec&n; * in the same directory.&n; * Return an error code if there is a problem, 0 if OK.&n; * Note that an error code of -ENOENT means there are no more entries&n; * in this directory.&n; * The directory is &quot;closed&quot; on an error.&n; */
DECL|function|hfs_cat_next
r_int
id|hfs_cat_next
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|dir
comma
r_struct
id|hfs_brec
op_star
id|brec
comma
id|hfs_u16
id|count
comma
id|hfs_u32
op_star
id|cnid
comma
id|hfs_u8
op_star
id|type
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
op_logical_or
op_logical_neg
id|brec
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Get the count&squot;th next catalog tree entry */
id|error
op_assign
id|hfs_bsucc
c_func
(paren
id|brec
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_struct
id|hfs_cat_key
op_star
id|key
op_assign
(paren
r_struct
id|hfs_cat_key
op_star
)paren
id|brec-&gt;key
suffix:semicolon
r_if
c_cond
(paren
id|hfs_get_nl
c_func
(paren
id|key-&gt;ParID
)paren
op_ne
id|dir-&gt;cnid
)paren
(brace
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
op_star
id|type
op_assign
(paren
(paren
r_struct
id|hfs_cat_rec
op_star
)paren
id|brec-&gt;data
)paren
op_member_access_from_pointer
id|cdrType
suffix:semicolon
op_star
id|cnid
op_assign
id|brec_to_id
c_func
(paren
id|brec
)paren
suffix:semicolon
)brace
r_else
(brace
id|end_read
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_cat_close()&n; *&n; * Given a catalog brec structure, replace it with the count&squot;th next brec&n; * in the same directory.&n; * Return an error code if there is a problem, 0 if OK.&n; * Note that an error code of -ENOENT means there are no more entries&n; * in this directory.&n; */
DECL|function|hfs_cat_close
r_void
id|hfs_cat_close
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|dir
comma
r_struct
id|hfs_brec
op_star
id|brec
)paren
(brace
r_if
c_cond
(paren
id|dir
op_logical_and
id|brec
)paren
(brace
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
id|end_read
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * hfs_cat_parent()&n; *&n; * Given a catalog entry, return the entry for its parent.&n; * Uses catalog key for the entry to get its parent&squot;s ID&n; * and then uses the parent&squot;s thread record to locate the&n; * parent&squot;s actual catalog entry.&n; */
DECL|function|hfs_cat_parent
r_struct
id|hfs_cat_entry
op_star
id|hfs_cat_parent
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|retval
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|hfs_mdb
op_star
id|mdb
op_assign
id|entry-&gt;mdb
suffix:semicolon
r_struct
id|hfs_brec
id|brec
suffix:semicolon
r_struct
id|hfs_cat_key
id|key
suffix:semicolon
r_int
id|error
suffix:semicolon
id|lock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;state
op_amp
id|HFS_DELETED
)paren
)paren
(brace
id|hfs_cat_build_key
c_func
(paren
id|hfs_get_nl
c_func
(paren
id|entry-&gt;key.ParID
)paren
comma
l_int|NULL
comma
op_amp
id|key
)paren
suffix:semicolon
id|error
op_assign
id|hfs_bfind
c_func
(paren
op_amp
id|brec
comma
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|key
)paren
comma
id|HFS_BFIND_READ_EQ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
multiline_comment|/* convert thread record to key */
r_struct
id|hfs_cat_rec
op_star
id|rec
op_assign
id|brec.data
suffix:semicolon
id|key.KeyLen
op_assign
l_int|6
op_plus
id|rec-&gt;u.thd.CName.Len
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|key.ParID
comma
op_amp
id|rec-&gt;u.thd.ParID
comma
r_sizeof
(paren
id|hfs_u32
)paren
op_plus
r_sizeof
(paren
r_struct
id|hfs_name
)paren
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
op_amp
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
id|retval
op_assign
id|hfs_cat_get
c_func
(paren
id|mdb
comma
op_amp
id|key
)paren
suffix:semicolon
)brace
)brace
id|unlock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_cat_create()&n; *&n; * Create a new file with the indicated name in the indicated directory.&n; * The file will have the indicated flags, type and creator.&n; * If successful an (struct hfs_cat_entry) is returned in &squot;*result&squot;.&n; */
DECL|function|hfs_cat_create
r_int
id|hfs_cat_create
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|parent
comma
r_struct
id|hfs_cat_key
op_star
id|key
comma
id|hfs_u8
id|flags
comma
id|hfs_u32
id|type
comma
id|hfs_u32
id|creator
comma
r_struct
id|hfs_cat_entry
op_star
op_star
id|result
)paren
(brace
r_struct
id|hfs_cat_rec
id|record
suffix:semicolon
id|hfs_u32
id|id
op_assign
id|new_cnid
c_func
(paren
id|parent-&gt;mdb
)paren
suffix:semicolon
id|hfs_u32
id|mtime
op_assign
id|hfs_time
c_func
(paren
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_CATALOG) || defined(DEBUG_ALL)
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_cat_create: %p/%s flags=%d res=%p&bslash;n&quot;
comma
id|parent
comma
id|key-&gt;CName.Name
comma
id|flags
comma
id|result
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* init some fields for the file record */
id|memset
c_func
(paren
op_amp
id|record
comma
l_int|0
comma
r_sizeof
(paren
id|record
)paren
)paren
suffix:semicolon
id|record.cdrType
op_assign
id|HFS_CDR_FIL
suffix:semicolon
id|record.u.fil.Flags
op_assign
id|flags
op_or
id|HFS_FIL_USED
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|id
comma
id|record.u.fil.FlNum
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|mtime
comma
id|record.u.fil.CrDat
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|mtime
comma
id|record.u.fil.MdDat
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
l_int|0
comma
id|record.u.fil.BkDat
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|type
comma
id|record.u.fil.UsrWds.fdType
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|creator
comma
id|record.u.fil.UsrWds.fdCreator
)paren
suffix:semicolon
r_return
id|create_entry
c_func
(paren
id|parent
comma
id|key
comma
op_amp
id|record
comma
l_int|0
comma
id|id
comma
id|result
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_cat_mkdir()&n; *&n; * Create a new directory with the indicated name in the indicated directory.&n; * If successful an (struct hfs_cat_entry) is returned in &squot;*result&squot;.&n; */
DECL|function|hfs_cat_mkdir
r_int
id|hfs_cat_mkdir
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|parent
comma
r_struct
id|hfs_cat_key
op_star
id|key
comma
r_struct
id|hfs_cat_entry
op_star
op_star
id|result
)paren
(brace
r_struct
id|hfs_cat_rec
id|record
suffix:semicolon
id|hfs_u32
id|id
op_assign
id|new_cnid
c_func
(paren
id|parent-&gt;mdb
)paren
suffix:semicolon
id|hfs_u32
id|mtime
op_assign
id|hfs_time
c_func
(paren
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_CATALOG) || defined(DEBUG_ALL)
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_cat_mkdir: %p/%s res=%p&bslash;n&quot;
comma
id|parent
comma
id|key-&gt;CName.Name
comma
id|result
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* init some fields for the directory record */
id|memset
c_func
(paren
op_amp
id|record
comma
l_int|0
comma
r_sizeof
(paren
id|record
)paren
)paren
suffix:semicolon
id|record.cdrType
op_assign
id|HFS_CDR_DIR
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|id
comma
id|record.u.dir.DirID
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|mtime
comma
id|record.u.dir.CrDat
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|mtime
comma
id|record.u.dir.MdDat
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
l_int|0
comma
id|record.u.dir.BkDat
)paren
suffix:semicolon
id|hfs_put_hs
c_func
(paren
l_int|0xff
comma
id|record.u.dir.UsrInfo.frView
)paren
suffix:semicolon
r_return
id|create_entry
c_func
(paren
id|parent
comma
id|key
comma
op_amp
id|record
comma
l_int|1
comma
id|id
comma
id|result
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_cat_delete()&n; *&n; * Delete the indicated file or directory.&n; * The associated thread is also removed unless (&squot;with_thread&squot;==0).&n; */
DECL|function|hfs_cat_delete
r_int
id|hfs_cat_delete
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|parent
comma
r_struct
id|hfs_cat_entry
op_star
id|entry
comma
r_int
id|with_thread
)paren
(brace
r_struct
id|hfs_cat_key
id|key
suffix:semicolon
r_struct
id|hfs_mdb
op_star
id|mdb
op_assign
id|parent-&gt;mdb
suffix:semicolon
r_int
id|is_dir
comma
id|error
op_assign
l_int|0
suffix:semicolon
macro_line|#if defined(DEBUG_CATALOG) || defined(DEBUG_ALL)
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_cat_delete: %p/%p type=%d state=%lu, thread=%d&bslash;n&quot;
comma
id|parent
comma
id|entry
comma
id|entry-&gt;type
comma
id|entry-&gt;state
comma
id|with_thread
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|parent-&gt;mdb
op_ne
id|entry-&gt;mdb
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;type
op_eq
id|HFS_CDR_FIL
)paren
(brace
id|with_thread
op_assign
(paren
id|entry-&gt;u.file.flags
op_amp
id|HFS_FIL_THD
)paren
op_logical_and
id|with_thread
suffix:semicolon
id|is_dir
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|is_dir
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* keep readers from getting confused by changing dir size */
id|start_write
c_func
(paren
id|parent
)paren
suffix:semicolon
multiline_comment|/* don&squot;t delete a busy directory */
r_if
c_cond
(paren
id|entry-&gt;type
op_eq
id|HFS_CDR_DIR
)paren
(brace
id|start_read
c_func
(paren
id|entry
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOTEMPTY
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;u.dir.files
op_logical_or
id|entry-&gt;u.dir.dirs
)paren
r_goto
id|hfs_delete_end
suffix:semicolon
)brace
multiline_comment|/* try to delete the file or directory */
id|lock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|entry-&gt;state
op_amp
id|HFS_DELETED
)paren
)paren
(brace
multiline_comment|/* somebody beat us to it. */
r_goto
id|hfs_delete_unlock
suffix:semicolon
)brace
multiline_comment|/* delete the catalog record */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|hfs_bdelete
c_func
(paren
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|entry-&gt;key
)paren
)paren
)paren
)paren
(brace
r_goto
id|hfs_delete_unlock
suffix:semicolon
)brace
multiline_comment|/* Mark the entry deleted and remove it from the cache */
id|delete_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
multiline_comment|/* try to delete the thread entry if it exists */
r_if
c_cond
(paren
id|with_thread
)paren
(brace
id|hfs_cat_build_key
c_func
(paren
id|entry-&gt;cnid
comma
l_int|NULL
comma
op_amp
id|key
)paren
suffix:semicolon
(paren
r_void
)paren
id|hfs_bdelete
c_func
(paren
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|key
)paren
)paren
suffix:semicolon
)brace
id|update_dir
c_func
(paren
id|mdb
comma
id|parent
comma
id|is_dir
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|hfs_delete_unlock
suffix:colon
id|unlock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|hfs_delete_end
suffix:colon
r_if
c_cond
(paren
id|entry-&gt;type
op_eq
id|HFS_CDR_DIR
)paren
(brace
id|end_read
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
id|end_write
c_func
(paren
id|parent
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_cat_move()&n; *&n; * Rename a file or directory, possibly to a new directory.&n; * If the destination exists it is removed and a&n; * (struct hfs_cat_entry) for it is returned in &squot;*result&squot;.&n; */
DECL|function|hfs_cat_move
r_int
id|hfs_cat_move
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|old_dir
comma
r_struct
id|hfs_cat_entry
op_star
id|new_dir
comma
r_struct
id|hfs_cat_entry
op_star
id|entry
comma
r_struct
id|hfs_cat_key
op_star
id|new_key
comma
r_struct
id|hfs_cat_entry
op_star
op_star
id|removed
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|dest
suffix:semicolon
r_struct
id|hfs_mdb
op_star
id|mdb
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|is_dir
comma
id|has_thread
suffix:semicolon
r_if
c_cond
(paren
id|removed
)paren
(brace
op_star
id|removed
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* sanity checks */
r_if
c_cond
(paren
op_logical_neg
id|old_dir
op_logical_or
op_logical_neg
id|new_dir
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|mdb
op_assign
id|old_dir-&gt;mdb
suffix:semicolon
r_if
c_cond
(paren
id|mdb
op_ne
id|new_dir-&gt;mdb
)paren
(brace
r_return
op_minus
id|EXDEV
suffix:semicolon
)brace
multiline_comment|/* precompute a few things */
r_if
c_cond
(paren
id|entry-&gt;type
op_eq
id|HFS_CDR_DIR
)paren
(brace
id|is_dir
op_assign
l_int|1
suffix:semicolon
id|has_thread
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry-&gt;type
op_eq
id|HFS_CDR_FIL
)paren
(brace
id|is_dir
op_assign
l_int|0
suffix:semicolon
id|has_thread
op_assign
id|entry-&gt;u.file.flags
op_amp
id|HFS_FIL_THD
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mdb-&gt;rename_lock
)paren
(brace
id|hfs_sleep_on
c_func
(paren
op_amp
id|mdb-&gt;rename_wait
)paren
suffix:semicolon
)brace
id|spin_lock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
id|mdb-&gt;rename_lock
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* XXX: should be atomic_inc */
id|spin_unlock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
multiline_comment|/* keep readers from getting confused by changing dir size */
id|start_write
c_func
(paren
id|new_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_dir
op_ne
id|new_dir
)paren
(brace
id|start_write
c_func
(paren
id|old_dir
)paren
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t move a directory inside itself */
r_if
c_cond
(paren
id|is_dir
)paren
(brace
r_struct
id|hfs_cat_key
id|thd_key
suffix:semicolon
r_struct
id|hfs_brec
id|brec
suffix:semicolon
id|hfs_u32
id|id
op_assign
id|new_dir-&gt;cnid
suffix:semicolon
r_while
c_loop
(paren
id|id
op_ne
id|htonl
c_func
(paren
id|HFS_ROOT_CNID
)paren
)paren
(brace
r_if
c_cond
(paren
id|id
op_eq
id|entry-&gt;cnid
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
id|hfs_cat_build_key
c_func
(paren
id|id
comma
l_int|NULL
comma
op_amp
id|thd_key
)paren
suffix:semicolon
id|error
op_assign
id|hfs_bfind
c_func
(paren
op_amp
id|brec
comma
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|thd_key
)paren
comma
id|HFS_BFIND_READ_EQ
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
r_else
(brace
r_struct
id|hfs_cat_rec
op_star
id|rec
op_assign
id|brec.data
suffix:semicolon
id|id
op_assign
id|hfs_get_nl
c_func
(paren
id|rec-&gt;u.thd.ParID
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
op_amp
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
)brace
id|restart
suffix:colon
multiline_comment|/* see if the destination exists, getting it if it does */
id|dest
op_assign
id|hfs_cat_get
c_func
(paren
id|mdb
comma
id|new_key
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dest
)paren
(brace
multiline_comment|/* destination doesn&squot;t exist, so create it */
r_struct
id|hfs_cat_rec
id|new_record
suffix:semicolon
multiline_comment|/* create a locked entry in the cache */
id|dest
op_assign
id|get_entry
c_func
(paren
id|mdb
comma
id|new_key
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dest
)paren
(brace
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dest-&gt;cnid
)paren
(brace
multiline_comment|/* The (unlocked) entry exists in the cache */
r_goto
id|have_distinct
suffix:semicolon
)brace
multiline_comment|/* limit directory valence to signed 16-bit integer */
r_if
c_cond
(paren
(paren
id|new_dir-&gt;u.dir.dirs
op_plus
id|new_dir-&gt;u.dir.files
)paren
op_ge
id|HFS_MAX_VALENCE
)paren
(brace
id|error
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_goto
id|bail3
suffix:semicolon
)brace
multiline_comment|/* build the new record. make sure to zero out the&n;                   record. */
id|memset
c_func
(paren
op_amp
id|new_record
comma
l_int|0
comma
r_sizeof
(paren
id|new_record
)paren
)paren
suffix:semicolon
id|new_record.cdrType
op_assign
id|entry-&gt;type
suffix:semicolon
id|__write_entry
c_func
(paren
id|entry
comma
op_amp
id|new_record
)paren
suffix:semicolon
multiline_comment|/* insert the new record */
id|error
op_assign
id|hfs_binsert
c_func
(paren
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
id|new_key
)paren
comma
op_amp
id|new_record
comma
id|is_dir
ques
c_cond
l_int|2
op_plus
r_sizeof
(paren
id|DIR_REC
)paren
suffix:colon
l_int|2
op_plus
r_sizeof
(paren
id|FIL_REC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|EEXIST
)paren
(brace
id|delete_entry
c_func
(paren
id|dest
)paren
suffix:semicolon
id|unlock_entry
c_func
(paren
id|dest
)paren
suffix:semicolon
id|hfs_cat_put
c_func
(paren
id|dest
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|bail3
suffix:semicolon
)brace
multiline_comment|/* update the destination directory */
id|update_dir
c_func
(paren
id|mdb
comma
id|new_dir
comma
id|is_dir
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry
op_ne
id|dest
)paren
(brace
id|have_distinct
suffix:colon
multiline_comment|/* The destination exists and is not same as source */
id|lock_entry
c_func
(paren
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dest-&gt;state
op_amp
id|HFS_DELETED
)paren
)paren
(brace
id|unlock_entry
c_func
(paren
id|dest
)paren
suffix:semicolon
id|hfs_cat_put
c_func
(paren
id|dest
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dest-&gt;type
op_ne
id|entry-&gt;type
)paren
(brace
multiline_comment|/* can&squot;t move a file on top&n;&t;&t;&t;   of a dir nor vice versa. */
id|error
op_assign
id|is_dir
ques
c_cond
op_minus
id|ENOTDIR
suffix:colon
op_minus
id|EISDIR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_dir
op_logical_and
(paren
id|dest-&gt;u.dir.dirs
op_logical_or
id|dest-&gt;u.dir.files
)paren
)paren
(brace
multiline_comment|/* directory to replace is not empty */
id|error
op_assign
op_minus
id|ENOTEMPTY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|bail2
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* The destination exists but is same as source */
op_decrement
id|entry-&gt;count
suffix:semicolon
id|dest
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* lock the entry */
id|lock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|entry-&gt;state
op_amp
id|HFS_DELETED
)paren
)paren
(brace
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|bail1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dest
)paren
(brace
multiline_comment|/* remove the old entry */
id|error
op_assign
id|hfs_bdelete
c_func
(paren
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|entry-&gt;key
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/* We couldn&squot;t remove the entry for the&n;&t;&t;&t;   original file, so nothing has changed. */
r_goto
id|bail1
suffix:semicolon
)brace
id|update_dir
c_func
(paren
id|mdb
comma
id|old_dir
comma
id|is_dir
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* update the thread of the dir/file we&squot;re moving */
r_if
c_cond
(paren
id|has_thread
)paren
(brace
r_struct
id|hfs_cat_key
id|thd_key
suffix:semicolon
r_struct
id|hfs_brec
id|brec
suffix:semicolon
id|hfs_cat_build_key
c_func
(paren
id|entry-&gt;cnid
comma
l_int|NULL
comma
op_amp
id|thd_key
)paren
suffix:semicolon
id|error
op_assign
id|hfs_bfind
c_func
(paren
op_amp
id|brec
comma
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|thd_key
)paren
comma
id|HFS_BFIND_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|ENOENT
)paren
(brace
r_if
c_cond
(paren
id|is_dir
)paren
(brace
multiline_comment|/* directory w/o a thread! */
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We were lied to! */
id|entry-&gt;u.file.flags
op_and_assign
op_complement
id|HFS_FIL_THD
suffix:semicolon
id|hfs_cat_mark_dirty
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_struct
id|hfs_cat_rec
op_star
id|rec
op_assign
id|brec.data
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|rec-&gt;u.thd.ParID
comma
op_amp
id|new_key-&gt;ParID
comma
r_sizeof
(paren
id|hfs_u32
)paren
op_plus
r_sizeof
(paren
r_struct
id|hfs_name
)paren
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
op_amp
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|ENOENT
)paren
(brace
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|dest
)paren
(brace
multiline_comment|/* Nothing was changed */
id|unlock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Something went seriously wrong.&n;&t;&t;&t;   The dir/file has been deleted. */
multiline_comment|/* XXX try some recovery? */
id|delete_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_goto
id|bail1
suffix:semicolon
)brace
)brace
multiline_comment|/* TRY to remove the thread for the pre-existing entry */
r_if
c_cond
(paren
id|dest
op_logical_and
id|dest-&gt;cnid
op_logical_and
(paren
id|is_dir
op_logical_or
(paren
id|dest-&gt;u.file.flags
op_amp
id|HFS_FIL_THD
)paren
)paren
)paren
(brace
r_struct
id|hfs_cat_key
id|thd_key
suffix:semicolon
id|hfs_cat_build_key
c_func
(paren
id|dest-&gt;cnid
comma
l_int|NULL
comma
op_amp
id|thd_key
)paren
suffix:semicolon
(paren
r_void
)paren
id|hfs_bdelete
c_func
(paren
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|thd_key
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* update directories */
id|new_dir-&gt;modify_date
op_assign
id|hfs_time
c_func
(paren
)paren
suffix:semicolon
id|hfs_cat_mark_dirty
c_func
(paren
id|new_dir
)paren
suffix:semicolon
multiline_comment|/* update key */
id|remove_hash
c_func
(paren
id|entry
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|entry-&gt;key
comma
id|new_key
comma
r_sizeof
(paren
op_star
id|new_key
)paren
)paren
suffix:semicolon
multiline_comment|/* KEYDIRTY as case might differ */
id|entry-&gt;state
op_or_assign
id|HFS_KEYDIRTY
suffix:semicolon
id|insert_hash
c_func
(paren
id|entry
)paren
suffix:semicolon
id|hfs_cat_mark_dirty
c_func
(paren
id|entry
)paren
suffix:semicolon
id|unlock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
multiline_comment|/* delete any pre-existing or place-holder entry */
r_if
c_cond
(paren
id|dest
)paren
(brace
id|delete_entry
c_func
(paren
id|dest
)paren
suffix:semicolon
id|unlock_entry
c_func
(paren
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|removed
op_logical_and
id|dest-&gt;cnid
)paren
(brace
op_star
id|removed
op_assign
id|dest
suffix:semicolon
)brace
r_else
(brace
id|hfs_cat_put
c_func
(paren
id|dest
)paren
suffix:semicolon
)brace
)brace
r_goto
id|done
suffix:semicolon
id|bail1
suffix:colon
id|unlock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|bail2
suffix:colon
r_if
c_cond
(paren
id|dest
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dest-&gt;cnid
)paren
(brace
multiline_comment|/* TRY to remove the new entry */
(paren
r_void
)paren
id|hfs_bdelete
c_func
(paren
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
id|new_key
)paren
)paren
suffix:semicolon
id|update_dir
c_func
(paren
id|mdb
comma
id|new_dir
comma
id|is_dir
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|bail3
suffix:colon
id|delete_entry
c_func
(paren
id|dest
)paren
suffix:semicolon
)brace
id|unlock_entry
c_func
(paren
id|dest
)paren
suffix:semicolon
id|hfs_cat_put
c_func
(paren
id|dest
)paren
suffix:semicolon
)brace
id|done
suffix:colon
r_if
c_cond
(paren
id|new_dir
op_ne
id|old_dir
)paren
(brace
id|end_write
c_func
(paren
id|old_dir
)paren
suffix:semicolon
)brace
id|end_write
c_func
(paren
id|new_dir
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
id|mdb-&gt;rename_lock
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* XXX: should use atomic_dec */
id|hfs_wake_up
c_func
(paren
op_amp
id|mdb-&gt;rename_wait
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|entry_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize the hash tables&n; */
DECL|function|hfs_cat_init
r_void
id|hfs_cat_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|list_head
op_star
id|head
op_assign
id|hash_table
suffix:semicolon
id|i
op_assign
id|C_HASHSIZE
suffix:semicolon
r_do
(brace
id|INIT_LIST_HEAD
c_func
(paren
id|head
)paren
suffix:semicolon
id|head
op_increment
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
)paren
suffix:semicolon
)brace
eof
