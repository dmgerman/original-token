multiline_comment|/*&n; * linux/fs/hfs/catalog.c&n; *&n; * Copyright (C) 1995-1997  Paul H. Hargrove&n; * This file may be distributed under the terms of the GNU Public License.&n; *&n; * This file contains the functions related to the catalog B-tree.&n; *&n; * &quot;XXX&quot; in a comment is a note to myself to consider changing something.&n; *&n; * Cache code shamelessly stolen from &n; *     linux/fs/inode.c Copyright (C) 1991, 1992  Linus Torvalds&n; *&n; * In function preconditions the term &quot;valid&quot; applied to a pointer to&n; * a structure means that the pointer is non-NULL and the structure it&n; * points to has all fields initialized to consistent values.&n; *&n; * The code in this file initializes some structures by calling&n; * memset(&amp;foo, 0, sizeof(foo)).  This produces the desired behavior&n; * only due to the non-ANSI assumption that the machine representation&n; */
macro_line|#include &quot;hfs.h&quot;
multiline_comment|/*================ Variable-like macros ================*/
DECL|macro|NUM_FREE_ENTRIES
mdefine_line|#define NUM_FREE_ENTRIES 8
multiline_comment|/* Number of hash table slots */
DECL|macro|CCACHE_NR
mdefine_line|#define CCACHE_NR 128
multiline_comment|/* Max number of entries in memory */
DECL|macro|CCACHE_MAX
mdefine_line|#define CCACHE_MAX 1024
multiline_comment|/* Number of entries to fit in a single page on an i386 */
DECL|macro|CCACHE_INC
mdefine_line|#define CCACHE_INC ((4080-sizeof(void *))/sizeof(struct hfs_cat_entry))
multiline_comment|/*================ File-local data types ================*/
multiline_comment|/* The catalog record for a file */
r_typedef
r_struct
(brace
DECL|member|Flags
id|hfs_byte_t
id|Flags
suffix:semicolon
multiline_comment|/* Flags such as read-only */
DECL|member|Typ
id|hfs_byte_t
id|Typ
suffix:semicolon
multiline_comment|/* file version number = 0 */
DECL|member|UsrWds
id|hfs_finfo_t
id|UsrWds
suffix:semicolon
multiline_comment|/* data used by the Finder */
DECL|member|FlNum
id|hfs_lword_t
id|FlNum
suffix:semicolon
multiline_comment|/* The CNID */
DECL|member|StBlk
id|hfs_word_t
id|StBlk
suffix:semicolon
multiline_comment|/* obsolete */
DECL|member|LgLen
id|hfs_lword_t
id|LgLen
suffix:semicolon
multiline_comment|/* The logical EOF of the data fork*/
DECL|member|PyLen
id|hfs_lword_t
id|PyLen
suffix:semicolon
multiline_comment|/* The physical EOF of the data fork */
DECL|member|RStBlk
id|hfs_word_t
id|RStBlk
suffix:semicolon
multiline_comment|/* obsolete */
DECL|member|RLgLen
id|hfs_lword_t
id|RLgLen
suffix:semicolon
multiline_comment|/* The logical EOF of the rsrc fork */
DECL|member|RPyLen
id|hfs_lword_t
id|RPyLen
suffix:semicolon
multiline_comment|/* The physical EOF of the rsrc fork */
DECL|member|CrDat
id|hfs_lword_t
id|CrDat
suffix:semicolon
multiline_comment|/* The creation date */
DECL|member|MdDat
id|hfs_lword_t
id|MdDat
suffix:semicolon
multiline_comment|/* The modified date */
DECL|member|BkDat
id|hfs_lword_t
id|BkDat
suffix:semicolon
multiline_comment|/* The last backup date */
DECL|member|FndrInfo
id|hfs_fxinfo_t
id|FndrInfo
suffix:semicolon
multiline_comment|/* more data for the Finder */
DECL|member|ClpSize
id|hfs_word_t
id|ClpSize
suffix:semicolon
multiline_comment|/* number of bytes to allocate&n;&t;&t;&t;&t;&t;   when extending files */
DECL|member|ExtRec
id|hfs_byte_t
id|ExtRec
(braket
l_int|12
)braket
suffix:semicolon
multiline_comment|/* first extent record&n;&t;&t;&t;&t;&t;   for the data fork */
DECL|member|RExtRec
id|hfs_byte_t
id|RExtRec
(braket
l_int|12
)braket
suffix:semicolon
multiline_comment|/* first extent record&n;&t;&t;&t;&t;&t;   for the resource fork */
DECL|member|Resrv
id|hfs_lword_t
id|Resrv
suffix:semicolon
multiline_comment|/* reserved by Apple */
DECL|typedef|FIL_REC
)brace
id|FIL_REC
suffix:semicolon
multiline_comment|/* the catalog record for a directory */
r_typedef
r_struct
(brace
DECL|member|Flags
id|hfs_word_t
id|Flags
suffix:semicolon
multiline_comment|/* flags */
DECL|member|Val
id|hfs_word_t
id|Val
suffix:semicolon
multiline_comment|/* Valence: number of files and&n;&t;&t;&t;&t;&t;   dirs in the directory */
DECL|member|DirID
id|hfs_lword_t
id|DirID
suffix:semicolon
multiline_comment|/* The CNID */
DECL|member|CrDat
id|hfs_lword_t
id|CrDat
suffix:semicolon
multiline_comment|/* The creation date */
DECL|member|MdDat
id|hfs_lword_t
id|MdDat
suffix:semicolon
multiline_comment|/* The modification date */
DECL|member|BkDat
id|hfs_lword_t
id|BkDat
suffix:semicolon
multiline_comment|/* The last backup date */
DECL|member|UsrInfo
id|hfs_dinfo_t
id|UsrInfo
suffix:semicolon
multiline_comment|/* data used by the Finder */
DECL|member|FndrInfo
id|hfs_dxinfo_t
id|FndrInfo
suffix:semicolon
multiline_comment|/* more data used by Finder */
DECL|member|Resrv
id|hfs_byte_t
id|Resrv
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* reserved by Apple */
DECL|typedef|DIR_REC
)brace
id|DIR_REC
suffix:semicolon
multiline_comment|/* the catalog record for a thread */
r_typedef
r_struct
(brace
DECL|member|Reserv
id|hfs_byte_t
id|Reserv
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* reserved by Apple */
DECL|member|ParID
id|hfs_lword_t
id|ParID
suffix:semicolon
multiline_comment|/* CNID of parent directory */
DECL|member|CName
r_struct
id|hfs_name
id|CName
suffix:semicolon
multiline_comment|/* The name of this entry */
DECL|typedef|THD_REC
)brace
id|THD_REC
suffix:semicolon
multiline_comment|/* A catalog tree record */
DECL|struct|hfs_cat_rec
r_struct
id|hfs_cat_rec
(brace
DECL|member|cdrType
id|hfs_byte_t
id|cdrType
suffix:semicolon
multiline_comment|/* The type of entry */
DECL|member|cdrResrv2
id|hfs_byte_t
id|cdrResrv2
suffix:semicolon
multiline_comment|/* padding */
r_union
(brace
DECL|member|fil
id|FIL_REC
id|fil
suffix:semicolon
DECL|member|dir
id|DIR_REC
id|dir
suffix:semicolon
DECL|member|thd
id|THD_REC
id|thd
suffix:semicolon
DECL|member|u
)brace
id|u
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|hfs_cat_entry_ptr
r_typedef
r_struct
id|hfs_cat_entry
op_star
id|hfs_cat_entry_ptr
suffix:semicolon
DECL|struct|allocation_unit
r_struct
id|allocation_unit
(brace
DECL|member|next
r_struct
id|allocation_unit
op_star
id|next
suffix:semicolon
DECL|member|entries
r_struct
id|hfs_cat_entry
id|entries
(braket
id|CCACHE_INC
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*================ File-local variables ================*/
DECL|variable|hash_table
r_static
id|hfs_cat_entry_ptr
id|hash_table
(braket
id|CCACHE_NR
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|first_entry
r_static
r_struct
id|hfs_cat_entry
op_star
id|first_entry
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|entry_wait
r_static
id|hfs_wait_queue
id|entry_wait
suffix:semicolon
DECL|variable|nr_entries
DECL|variable|nr_free_entries
r_static
r_int
id|nr_entries
op_assign
l_int|0
comma
id|nr_free_entries
op_assign
l_int|0
suffix:semicolon
DECL|variable|allocation
r_static
r_struct
id|allocation_unit
op_star
id|allocation
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*================ File-local functions ================*/
multiline_comment|/*&n; * brec_to_id&n; *&n; * Get the CNID from a brec&n; */
DECL|function|brec_to_id
r_static
r_inline
id|hfs_u32
id|brec_to_id
c_func
(paren
r_struct
id|hfs_brec
op_star
id|brec
)paren
(brace
r_struct
id|hfs_cat_rec
op_star
id|rec
op_assign
id|brec-&gt;data
suffix:semicolon
r_return
id|hfs_get_nl
c_func
(paren
(paren
id|rec-&gt;cdrType
op_eq
id|HFS_CDR_FIL
)paren
ques
c_cond
id|rec-&gt;u.fil.FlNum
suffix:colon
id|rec-&gt;u.dir.DirID
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hashfn()&n; *&n; * hash an (struct mdb *) and a (struct hfs_cat_key *) to an integer.&n; */
DECL|function|hashfn
r_static
r_inline
r_int
r_int
id|hashfn
c_func
(paren
r_const
r_struct
id|hfs_mdb
op_star
id|mdb
comma
r_const
r_struct
id|hfs_cat_key
op_star
id|key
)paren
(brace
DECL|macro|LSB
mdefine_line|#define LSB(X) (((unsigned char *)(&amp;X))[3])
r_return
(paren
(paren
r_int
r_int
)paren
id|LSB
c_func
(paren
id|mdb-&gt;create_date
)paren
op_xor
(paren
r_int
r_int
)paren
id|key-&gt;ParID
(braket
l_int|3
)braket
op_xor
id|hfs_strhash
c_func
(paren
op_amp
id|key-&gt;CName
)paren
)paren
op_mod
id|CCACHE_NR
suffix:semicolon
DECL|macro|LSB
macro_line|#undef LSB
)brace
multiline_comment|/*&n; * hash()&n; *&n; * hash an (struct mdb *) and a (struct hfs_cat_key *)&n; * to a pointer to a slot in the hash table.&n; */
DECL|function|hash
r_static
r_inline
r_struct
id|hfs_cat_entry
op_star
op_star
id|hash
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
comma
r_const
r_struct
id|hfs_cat_key
op_star
id|key
)paren
(brace
r_return
id|hash_table
op_plus
id|hashfn
c_func
(paren
id|mdb
comma
id|key
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * insert_free()&n; *&n; * Add an entry to the front of the free list.&n; */
DECL|function|insert_free
r_static
r_inline
r_void
id|insert_free
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|prev
comma
op_star
id|next
op_assign
id|first_entry
suffix:semicolon
id|first_entry
op_assign
id|entry
suffix:semicolon
id|prev
op_assign
id|next-&gt;prev
suffix:semicolon
id|entry-&gt;next
op_assign
id|next
suffix:semicolon
id|entry-&gt;prev
op_assign
id|prev
suffix:semicolon
id|prev-&gt;next
op_assign
id|entry
suffix:semicolon
id|next-&gt;prev
op_assign
id|entry
suffix:semicolon
)brace
multiline_comment|/*&n; * remove_free()&n; *&n; * Remove an entry from the free list.&n; */
DECL|function|remove_free
r_static
r_inline
r_void
id|remove_free
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
r_if
c_cond
(paren
id|first_entry
op_eq
id|entry
)paren
(brace
id|first_entry
op_assign
id|first_entry-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;next
)paren
(brace
id|entry-&gt;next-&gt;prev
op_assign
id|entry-&gt;prev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;prev
)paren
(brace
id|entry-&gt;prev-&gt;next
op_assign
id|entry-&gt;next
suffix:semicolon
)brace
id|entry-&gt;next
op_assign
id|entry-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * insert_hash()&n; *&n; * Add an entry to the front of the appropriate hash list&n; */
DECL|function|insert_hash
r_static
r_void
id|insert_hash
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
op_star
id|h
suffix:semicolon
id|h
op_assign
id|hash
c_func
(paren
id|entry-&gt;mdb
comma
op_amp
id|entry-&gt;key
)paren
suffix:semicolon
id|entry-&gt;hash_next
op_assign
op_star
id|h
suffix:semicolon
id|entry-&gt;hash_prev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;hash_next
)paren
(brace
id|entry-&gt;hash_next-&gt;hash_prev
op_assign
id|entry
suffix:semicolon
)brace
op_star
id|h
op_assign
id|entry
suffix:semicolon
)brace
multiline_comment|/*&n; * remove_hash&n; *&n; * Remove an entry from its hash list (if any).&n; */
DECL|function|remove_hash
r_static
r_void
id|remove_hash
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
op_star
id|h
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;mdb
)paren
(brace
id|h
op_assign
id|hash
c_func
(paren
id|entry-&gt;mdb
comma
op_amp
id|entry-&gt;key
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|h
op_eq
id|entry
)paren
(brace
op_star
id|h
op_assign
id|entry-&gt;hash_next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;hash_next
)paren
(brace
id|entry-&gt;hash_next-&gt;hash_prev
op_assign
id|entry-&gt;hash_prev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;hash_prev
)paren
(brace
id|entry-&gt;hash_prev-&gt;hash_next
op_assign
id|entry-&gt;hash_next
suffix:semicolon
)brace
id|entry-&gt;hash_prev
op_assign
id|entry-&gt;hash_next
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * put_last_free()&n; *&n; * Move an entry to the end of the free list.&n; */
DECL|function|put_last_free
r_static
r_inline
r_void
id|put_last_free
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
id|remove_free
c_func
(paren
id|entry
)paren
suffix:semicolon
id|entry-&gt;prev
op_assign
id|first_entry-&gt;prev
suffix:semicolon
id|entry-&gt;prev-&gt;next
op_assign
id|entry
suffix:semicolon
id|entry-&gt;next
op_assign
id|first_entry
suffix:semicolon
id|entry-&gt;next-&gt;prev
op_assign
id|entry
suffix:semicolon
)brace
multiline_comment|/*&n; * grow_entries()&n; *&n; * Try to allocate more entries, adding them to the free list.&n; */
DECL|function|grow_entries
r_static
r_int
id|grow_entries
c_func
(paren
r_void
)paren
(brace
r_struct
id|allocation_unit
op_star
id|tmp
suffix:semicolon
r_struct
id|hfs_cat_entry
op_star
id|entry
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|HFS_NEW
c_func
(paren
id|tmp
)paren
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|tmp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|tmp
)paren
)paren
suffix:semicolon
id|tmp-&gt;next
op_assign
id|allocation
suffix:semicolon
id|allocation
op_assign
id|tmp
suffix:semicolon
id|entry
op_assign
id|tmp-&gt;entries
suffix:semicolon
id|i
op_assign
id|CCACHE_INC
suffix:semicolon
id|nr_entries
op_add_assign
id|i
suffix:semicolon
id|nr_free_entries
op_add_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|first_entry
)paren
(brace
id|entry-&gt;next
op_assign
id|entry-&gt;prev
op_assign
id|first_entry
op_assign
id|entry
op_increment
suffix:semicolon
op_decrement
id|i
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|CCACHE_INC
op_minus
l_int|1
suffix:semicolon
id|i
suffix:semicolon
op_decrement
id|i
)paren
(brace
id|insert_free
c_func
(paren
id|entry
op_increment
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * wait_on_entry()&n; *&n; * Sleep until a locked entry is unlocked.&n; */
DECL|function|wait_on_entry
r_static
r_inline
r_void
id|wait_on_entry
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
r_while
c_loop
(paren
id|entry-&gt;lock
)paren
(brace
id|hfs_sleep_on
c_func
(paren
op_amp
id|entry-&gt;wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * lock_entry()&n; *&n; * Obtain an exclusive lock on an entry.&n; */
DECL|function|lock_entry
r_static
r_void
id|lock_entry
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
id|wait_on_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|entry-&gt;lock
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * lock_entry()&n; *&n; * Relinquish an exclusive lock on an entry.&n; */
DECL|function|unlock_entry
r_static
r_void
id|unlock_entry
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
id|entry-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|hfs_wake_up
c_func
(paren
op_amp
id|entry-&gt;wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * clear_entry()&n; *&n; * Zero all the fields of an entry and place it on the free list.&n; */
DECL|function|clear_entry
r_static
r_void
id|clear_entry
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
id|wait_on_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|remove_hash
c_func
(paren
id|entry
)paren
suffix:semicolon
id|remove_free
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;count
)paren
(brace
id|nr_free_entries
op_increment
suffix:semicolon
)brace
multiline_comment|/* zero all but the wait queue */
id|memset
c_func
(paren
op_amp
id|entry-&gt;next
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|entry
)paren
op_minus
m_offsetof
(paren
r_struct
id|hfs_cat_entry
comma
id|next
)paren
)paren
suffix:semicolon
id|insert_free
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * __read_entry()&n; *&n; * Convert a (struct hfs_cat_rec) to a (struct hfs_cat_entry).&n; */
DECL|function|__read_entry
r_static
r_void
id|__read_entry
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
comma
r_const
r_struct
id|hfs_cat_rec
op_star
id|cat
)paren
(brace
id|entry-&gt;type
op_assign
id|cat-&gt;cdrType
suffix:semicolon
r_if
c_cond
(paren
id|cat-&gt;cdrType
op_eq
id|HFS_CDR_DIR
)paren
(brace
r_struct
id|hfs_dir
op_star
id|dir
op_assign
op_amp
id|entry-&gt;u.dir
suffix:semicolon
id|entry-&gt;cnid
op_assign
id|hfs_get_nl
c_func
(paren
id|cat-&gt;u.dir.DirID
)paren
suffix:semicolon
id|dir-&gt;magic
op_assign
id|HFS_DIR_MAGIC
suffix:semicolon
id|dir-&gt;flags
op_assign
id|hfs_get_ns
c_func
(paren
id|cat-&gt;u.dir.Flags
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|entry-&gt;info.dir.dinfo
comma
op_amp
id|cat-&gt;u.dir.UsrInfo
comma
l_int|16
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|entry-&gt;info.dir.dxinfo
comma
op_amp
id|cat-&gt;u.dir.FndrInfo
comma
l_int|16
)paren
suffix:semicolon
id|entry-&gt;create_date
op_assign
id|hfs_get_nl
c_func
(paren
id|cat-&gt;u.dir.CrDat
)paren
suffix:semicolon
id|entry-&gt;modify_date
op_assign
id|hfs_get_nl
c_func
(paren
id|cat-&gt;u.dir.MdDat
)paren
suffix:semicolon
id|entry-&gt;backup_date
op_assign
id|hfs_get_nl
c_func
(paren
id|cat-&gt;u.dir.BkDat
)paren
suffix:semicolon
id|dir-&gt;dirs
op_assign
id|dir-&gt;files
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cat-&gt;cdrType
op_eq
id|HFS_CDR_FIL
)paren
(brace
r_struct
id|hfs_file
op_star
id|fil
op_assign
op_amp
id|entry-&gt;u.file
suffix:semicolon
id|entry-&gt;cnid
op_assign
id|hfs_get_nl
c_func
(paren
id|cat-&gt;u.fil.FlNum
)paren
suffix:semicolon
id|fil-&gt;magic
op_assign
id|HFS_FILE_MAGIC
suffix:semicolon
id|fil-&gt;data_fork.fork
op_assign
id|HFS_FK_DATA
suffix:semicolon
id|fil-&gt;data_fork.entry
op_assign
id|entry
suffix:semicolon
id|fil-&gt;data_fork.lsize
op_assign
id|hfs_get_hl
c_func
(paren
id|cat-&gt;u.fil.LgLen
)paren
suffix:semicolon
id|fil-&gt;data_fork.psize
op_assign
id|hfs_get_hl
c_func
(paren
id|cat-&gt;u.fil.PyLen
)paren
op_rshift
id|HFS_SECTOR_SIZE_BITS
suffix:semicolon
id|hfs_extent_in
c_func
(paren
op_amp
id|fil-&gt;data_fork
comma
id|cat-&gt;u.fil.ExtRec
)paren
suffix:semicolon
id|fil-&gt;rsrc_fork.fork
op_assign
id|HFS_FK_RSRC
suffix:semicolon
id|fil-&gt;rsrc_fork.entry
op_assign
id|entry
suffix:semicolon
id|fil-&gt;rsrc_fork.lsize
op_assign
id|hfs_get_hl
c_func
(paren
id|cat-&gt;u.fil.RLgLen
)paren
suffix:semicolon
id|fil-&gt;rsrc_fork.psize
op_assign
id|hfs_get_hl
c_func
(paren
id|cat-&gt;u.fil.RPyLen
)paren
op_rshift
id|HFS_SECTOR_SIZE_BITS
suffix:semicolon
id|hfs_extent_in
c_func
(paren
op_amp
id|fil-&gt;rsrc_fork
comma
id|cat-&gt;u.fil.RExtRec
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|entry-&gt;info.file.finfo
comma
op_amp
id|cat-&gt;u.fil.UsrWds
comma
l_int|16
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|entry-&gt;info.file.fxinfo
comma
op_amp
id|cat-&gt;u.fil.FndrInfo
comma
l_int|16
)paren
suffix:semicolon
id|entry-&gt;create_date
op_assign
id|hfs_get_nl
c_func
(paren
id|cat-&gt;u.fil.CrDat
)paren
suffix:semicolon
id|entry-&gt;modify_date
op_assign
id|hfs_get_nl
c_func
(paren
id|cat-&gt;u.fil.MdDat
)paren
suffix:semicolon
id|entry-&gt;backup_date
op_assign
id|hfs_get_nl
c_func
(paren
id|cat-&gt;u.fil.BkDat
)paren
suffix:semicolon
id|fil-&gt;clumpablks
op_assign
(paren
id|hfs_get_hs
c_func
(paren
id|cat-&gt;u.fil.ClpSize
)paren
op_div
id|entry-&gt;mdb-&gt;alloc_blksz
)paren
op_rshift
id|HFS_SECTOR_SIZE_BITS
suffix:semicolon
id|fil-&gt;flags
op_assign
id|cat-&gt;u.fil.Flags
suffix:semicolon
)brace
r_else
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_fs: entry is neither file nor directory!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * count_dir_entries()&n; *&n; * Count the number of files and directories in a given directory.&n; */
DECL|function|count_dir_entries
r_static
r_inline
r_void
id|count_dir_entries
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
comma
r_struct
id|hfs_brec
op_star
id|brec
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|hfs_u32
id|cnid
suffix:semicolon
id|hfs_u8
id|type
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hfs_cat_open
c_func
(paren
id|entry
comma
id|brec
)paren
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|error
op_assign
id|hfs_cat_next
c_func
(paren
id|entry
comma
id|brec
comma
l_int|1
comma
op_amp
id|cnid
comma
op_amp
id|type
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|type
op_eq
id|HFS_CDR_FIL
)paren
(brace
op_increment
id|entry-&gt;u.dir.files
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|HFS_CDR_DIR
)paren
(brace
op_increment
id|entry-&gt;u.dir.dirs
suffix:semicolon
)brace
)brace
multiline_comment|/* -ENOENT is normal termination */
)brace
r_if
c_cond
(paren
id|error
op_ne
op_minus
id|ENOENT
)paren
(brace
id|entry-&gt;cnid
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * read_entry()&n; *&n; * Convert a (struct hfs_brec) to a (struct hfs_cat_entry).&n; */
DECL|function|read_entry
r_static
r_inline
r_void
id|read_entry
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
comma
r_struct
id|hfs_brec
op_star
id|brec
)paren
(brace
r_int
id|need_count
suffix:semicolon
r_struct
id|hfs_cat_rec
op_star
id|rec
op_assign
id|brec-&gt;data
suffix:semicolon
id|__read_entry
c_func
(paren
id|entry
comma
id|rec
)paren
suffix:semicolon
id|need_count
op_assign
(paren
id|rec-&gt;cdrType
op_eq
id|HFS_CDR_DIR
)paren
op_logical_and
id|rec-&gt;u.dir.Val
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_count
)paren
(brace
id|count_dir_entries
c_func
(paren
id|entry
comma
id|brec
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * __write_entry()&n; *&n; * Convert a (struct hfs_cat_entry) to a (struct hfs_cat_rec).&n; */
DECL|function|__write_entry
r_static
r_void
id|__write_entry
c_func
(paren
r_const
r_struct
id|hfs_cat_entry
op_star
id|entry
comma
r_struct
id|hfs_cat_rec
op_star
id|cat
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;type
op_eq
id|HFS_CDR_DIR
)paren
(brace
r_const
r_struct
id|hfs_dir
op_star
id|dir
op_assign
op_amp
id|entry-&gt;u.dir
suffix:semicolon
id|hfs_put_ns
c_func
(paren
id|dir-&gt;flags
comma
id|cat-&gt;u.dir.Flags
)paren
suffix:semicolon
id|hfs_put_hs
c_func
(paren
id|dir-&gt;dirs
op_plus
id|dir-&gt;files
comma
id|cat-&gt;u.dir.Val
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|entry-&gt;cnid
comma
id|cat-&gt;u.dir.DirID
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|entry-&gt;create_date
comma
id|cat-&gt;u.dir.CrDat
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|entry-&gt;modify_date
comma
id|cat-&gt;u.dir.MdDat
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|entry-&gt;backup_date
comma
id|cat-&gt;u.dir.BkDat
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|cat-&gt;u.dir.UsrInfo
comma
op_amp
id|entry-&gt;info.dir.dinfo
comma
l_int|16
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|cat-&gt;u.dir.FndrInfo
comma
op_amp
id|entry-&gt;info.dir.dxinfo
comma
l_int|16
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry-&gt;type
op_eq
id|HFS_CDR_FIL
)paren
(brace
r_const
r_struct
id|hfs_file
op_star
id|fil
op_assign
op_amp
id|entry-&gt;u.file
suffix:semicolon
id|cat-&gt;u.fil.Flags
op_assign
id|fil-&gt;flags
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|entry-&gt;cnid
comma
id|cat-&gt;u.fil.FlNum
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|cat-&gt;u.fil.UsrWds
comma
op_amp
id|entry-&gt;info.file.finfo
comma
l_int|16
)paren
suffix:semicolon
id|hfs_put_hl
c_func
(paren
id|fil-&gt;data_fork.lsize
comma
id|cat-&gt;u.fil.LgLen
)paren
suffix:semicolon
id|hfs_put_hl
c_func
(paren
id|fil-&gt;data_fork.psize
op_lshift
id|HFS_SECTOR_SIZE_BITS
comma
id|cat-&gt;u.fil.PyLen
)paren
suffix:semicolon
id|hfs_put_hl
c_func
(paren
id|fil-&gt;rsrc_fork.lsize
comma
id|cat-&gt;u.fil.RLgLen
)paren
suffix:semicolon
id|hfs_put_hl
c_func
(paren
id|fil-&gt;rsrc_fork.psize
op_lshift
id|HFS_SECTOR_SIZE_BITS
comma
id|cat-&gt;u.fil.RPyLen
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|entry-&gt;create_date
comma
id|cat-&gt;u.fil.CrDat
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|entry-&gt;modify_date
comma
id|cat-&gt;u.fil.MdDat
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|entry-&gt;backup_date
comma
id|cat-&gt;u.fil.BkDat
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|cat-&gt;u.fil.FndrInfo
comma
op_amp
id|entry-&gt;info.file.fxinfo
comma
l_int|16
)paren
suffix:semicolon
id|hfs_put_hs
c_func
(paren
(paren
id|fil-&gt;clumpablks
op_star
id|entry-&gt;mdb-&gt;alloc_blksz
)paren
op_lshift
id|HFS_SECTOR_SIZE_BITS
comma
id|cat-&gt;u.fil.ClpSize
)paren
suffix:semicolon
id|hfs_extent_out
c_func
(paren
op_amp
id|fil-&gt;data_fork
comma
id|cat-&gt;u.fil.ExtRec
)paren
suffix:semicolon
id|hfs_extent_out
c_func
(paren
op_amp
id|fil-&gt;rsrc_fork
comma
id|cat-&gt;u.fil.RExtRec
)paren
suffix:semicolon
)brace
r_else
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;__write_entry: invalid entry&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * write_entry()&n; *&n; * Write a modified entry back to the catalog B-tree.&n; */
DECL|function|write_entry
r_static
r_void
id|write_entry
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
r_struct
id|hfs_brec
id|brec
suffix:semicolon
r_int
id|error
suffix:semicolon
id|wait_on_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;dirt
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;deleted
)paren
(brace
id|entry-&gt;lock
op_assign
l_int|1
suffix:semicolon
id|error
op_assign
id|hfs_bfind
c_func
(paren
op_amp
id|brec
comma
id|entry-&gt;mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|entry-&gt;key
)paren
comma
id|HFS_BFIND_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;key_dirt
)paren
(brace
multiline_comment|/* key may have changed case due to a rename */
id|entry-&gt;key_dirt
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|brec.key-&gt;KeyLen
op_ne
id|entry-&gt;key.KeyLen
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_write_entry: key length &quot;
l_string|&quot;changed!&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|brec.key
comma
op_amp
id|entry-&gt;key
comma
id|entry-&gt;key.KeyLen
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|entry-&gt;cnid
op_ne
id|brec_to_id
c_func
(paren
op_amp
id|brec
)paren
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_write_entry: CNID &quot;
l_string|&quot;changed unexpectedly!&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|__write_entry
c_func
(paren
id|entry
comma
id|brec.data
)paren
suffix:semicolon
)brace
id|hfs_brec_relse
c_func
(paren
op_amp
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_write_entry: unable to write &quot;
l_string|&quot;entry %08x&bslash;n&quot;
comma
id|entry-&gt;cnid
)paren
suffix:semicolon
)brace
id|unlock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
id|entry-&gt;dirt
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; */
DECL|macro|CAN_UNUSE
mdefine_line|#define CAN_UNUSE(tmp) ((tmp)-&gt;count &lt; 3 &amp;&amp; !((tmp)-&gt;lock || (tmp)-&gt;dirt))
DECL|function|try_to_free_entries
r_static
r_inline
r_int
id|try_to_free_entries
c_func
(paren
r_const
r_int
id|goal
)paren
(brace
id|hfs_prune_entry
c_func
(paren
id|first_entry
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * get_empty_entry()&n; *&n; * Allocate an unused entry.&n; */
DECL|function|get_empty_entry
r_static
r_inline
r_struct
id|hfs_cat_entry
op_star
id|get_empty_entry
c_func
(paren
r_void
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|entry
comma
op_star
id|best
suffix:semicolon
r_int
id|i
comma
r_try
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nr_entries
OL
id|CCACHE_MAX
)paren
op_logical_and
(paren
id|nr_free_entries
op_le
(paren
id|nr_entries
op_rshift
l_int|1
)paren
)paren
)paren
(brace
id|grow_entries
c_func
(paren
)paren
suffix:semicolon
)brace
id|repeat
suffix:colon
id|entry
op_assign
id|first_entry
suffix:semicolon
id|best
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nr_entries
op_div
l_int|2
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
comma
id|entry
op_assign
id|entry-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;count
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|best
)paren
(brace
id|best
op_assign
id|entry
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;dirt
op_logical_and
op_logical_neg
id|entry-&gt;lock
)paren
(brace
id|best
op_assign
id|entry
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|best
op_logical_or
id|best-&gt;dirt
op_logical_or
id|best-&gt;lock
)paren
(brace
r_if
c_cond
(paren
id|nr_entries
OL
id|CCACHE_MAX
)paren
(brace
r_if
c_cond
(paren
id|grow_entries
c_func
(paren
)paren
op_eq
l_int|0
)paren
(brace
r_goto
id|repeat
suffix:semicolon
)brace
)brace
)brace
id|entry
op_assign
id|best
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
(brace
r_if
c_cond
(paren
r_try
op_increment
OL
l_int|4
op_logical_and
id|try_to_free_entries
c_func
(paren
id|NUM_FREE_ENTRIES
)paren
)paren
(brace
r_goto
id|repeat
suffix:semicolon
)brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_cat_get: No free entries&bslash;n&quot;
)paren
suffix:semicolon
id|hfs_sleep_on
c_func
(paren
op_amp
id|entry_wait
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;lock
)paren
(brace
id|wait_on_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;dirt
)paren
(brace
id|write_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;count
)paren
(brace
r_goto
id|repeat
suffix:semicolon
)brace
id|clear_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|entry-&gt;count
op_assign
l_int|1
suffix:semicolon
id|entry-&gt;dirt
op_assign
l_int|0
suffix:semicolon
id|entry-&gt;deleted
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* so it gets cleared if discarded */
id|nr_free_entries
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|nr_free_entries
OL
l_int|0
)paren
(brace
id|hfs_warn
(paren
l_string|&quot;hfs_get_empty_entry: bad free entry count.&bslash;n&quot;
)paren
suffix:semicolon
id|nr_free_entries
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|entry
suffix:semicolon
)brace
multiline_comment|/*&n; * get_entry()&n; *&n; * Try to return an entry for the indicated file or directory.&n; * If (&squot;read&squot; == 0) then no attempt will be made to read it from disk&n; * and a locked, but uninitialized, entry is returned.&n; */
DECL|function|get_entry
r_static
r_struct
id|hfs_cat_entry
op_star
id|get_entry
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
comma
r_const
r_struct
id|hfs_cat_key
op_star
id|key
comma
r_int
id|read
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
op_star
id|h
suffix:semicolon
r_struct
id|hfs_cat_entry
op_star
id|entry
suffix:semicolon
r_struct
id|hfs_cat_entry
op_star
id|empty
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|hfs_brec
id|brec
suffix:semicolon
id|h
op_assign
id|hash
c_func
(paren
id|mdb
comma
id|key
)paren
suffix:semicolon
id|repeat
suffix:colon
r_for
c_loop
(paren
id|entry
op_assign
op_star
id|h
suffix:semicolon
id|entry
suffix:semicolon
id|entry
op_assign
id|entry-&gt;hash_next
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;mdb
op_eq
id|mdb
op_logical_and
op_logical_neg
id|hfs_cat_compare
c_func
(paren
op_amp
id|entry-&gt;key
comma
id|key
)paren
)paren
(brace
r_goto
id|found_it
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|empty
)paren
(brace
id|empty
op_assign
id|get_empty_entry
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|empty
op_logical_and
id|read
op_logical_and
id|hfs_bfind
c_func
(paren
op_amp
id|brec
comma
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
id|key
)paren
comma
id|HFS_BFIND_READ_EQ
)paren
)paren
(brace
multiline_comment|/* If we get here then:&n;&t;&t;&t;&t;1) We got an empty entry.&n;&t;&t;&t;&t;2) We want to read the record.&n;&t;&t;&t;&t;3) We failed to find the record. */
id|hfs_cat_put
c_func
(paren
id|empty
)paren
suffix:semicolon
id|empty
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|empty
)paren
(brace
r_goto
id|repeat
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|entry
op_assign
id|empty
suffix:semicolon
id|entry-&gt;deleted
op_assign
l_int|0
suffix:semicolon
id|entry-&gt;mdb
op_assign
id|mdb
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|entry-&gt;key
comma
id|key
comma
r_sizeof
(paren
op_star
id|key
)paren
)paren
suffix:semicolon
id|put_last_free
c_func
(paren
id|entry
)paren
suffix:semicolon
id|insert_hash
c_func
(paren
id|entry
)paren
suffix:semicolon
id|entry-&gt;lock
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|read
)paren
(brace
multiline_comment|/* Return a locked but incomplete entry.  Note that the&n;&t;&t;   caller can tell it is incomplete since entry-&gt;cnid = 0. */
r_return
id|entry
suffix:semicolon
)brace
id|read_entry
c_func
(paren
id|entry
comma
op_amp
id|brec
)paren
suffix:semicolon
id|unlock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_goto
id|return_it
suffix:semicolon
id|found_it
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;count
)paren
(brace
id|nr_free_entries
op_decrement
suffix:semicolon
)brace
id|entry-&gt;count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|empty
)paren
(brace
r_if
c_cond
(paren
id|read
)paren
(brace
id|hfs_brec_relse
c_func
(paren
op_amp
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|hfs_cat_put
c_func
(paren
id|empty
)paren
suffix:semicolon
)brace
id|wait_on_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;deleted
)paren
(brace
multiline_comment|/* The entry was deleted while we slept */
id|hfs_cat_put
c_func
(paren
id|entry
)paren
suffix:semicolon
id|hfs_relinquish
c_func
(paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|return_it
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;cnid
)paren
(brace
multiline_comment|/* There was an error reading the entry */
id|hfs_cat_put
c_func
(paren
id|entry
)paren
suffix:semicolon
id|entry
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|entry
suffix:semicolon
)brace
multiline_comment|/* &n; * new_cnid()&n; *&n; * Allocate a CNID to use for a new file or directory.&n; */
DECL|function|new_cnid
r_static
r_inline
id|hfs_u32
id|new_cnid
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
)paren
(brace
multiline_comment|/* If the create succeeds then the mdb will get dirtied */
r_return
id|htonl
c_func
(paren
id|mdb-&gt;next_id
op_increment
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * update_dir()&n; *&n; * Update counts, times and dirt on a changed directory&n; */
DECL|function|update_dir
r_static
r_void
id|update_dir
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
comma
r_struct
id|hfs_cat_entry
op_star
id|dir
comma
r_int
id|is_dir
comma
r_int
id|count
)paren
(brace
multiline_comment|/* update counts */
r_if
c_cond
(paren
id|is_dir
)paren
(brace
id|mdb-&gt;dir_count
op_add_assign
id|count
suffix:semicolon
id|dir-&gt;u.dir.dirs
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;cnid
op_eq
id|htonl
c_func
(paren
id|HFS_ROOT_CNID
)paren
)paren
(brace
id|mdb-&gt;root_dirs
op_add_assign
id|count
suffix:semicolon
)brace
)brace
r_else
(brace
id|mdb-&gt;file_count
op_add_assign
id|count
suffix:semicolon
id|dir-&gt;u.dir.files
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;cnid
op_eq
id|htonl
c_func
(paren
id|HFS_ROOT_CNID
)paren
)paren
(brace
id|mdb-&gt;root_files
op_add_assign
id|count
suffix:semicolon
)brace
)brace
multiline_comment|/* update times and dirt */
id|dir-&gt;modify_date
op_assign
id|hfs_time
c_func
(paren
)paren
suffix:semicolon
id|dir-&gt;dirt
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a writer to dir, excluding readers.&n; */
DECL|function|start_write
r_static
r_inline
r_void
id|start_write
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|dir
)paren
(brace
r_if
c_cond
(paren
id|dir-&gt;u.dir.readers
op_logical_or
id|dir-&gt;u.dir.read_wait
)paren
(brace
id|hfs_sleep_on
c_func
(paren
op_amp
id|dir-&gt;u.dir.write_wait
)paren
suffix:semicolon
)brace
op_increment
id|dir-&gt;u.dir.writers
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a reader to dir, excluding writers.&n; */
DECL|function|start_read
r_static
r_inline
r_void
id|start_read
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|dir
)paren
(brace
r_if
c_cond
(paren
id|dir-&gt;u.dir.writers
op_logical_or
id|dir-&gt;u.dir.write_wait
)paren
(brace
id|hfs_sleep_on
c_func
(paren
op_amp
id|dir-&gt;u.dir.read_wait
)paren
suffix:semicolon
)brace
op_increment
id|dir-&gt;u.dir.readers
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a writer from dir, possibly admitting readers.&n; */
DECL|function|end_write
r_static
r_inline
r_void
id|end_write
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|dir
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_decrement
id|dir-&gt;u.dir.writers
)paren
)paren
(brace
id|hfs_wake_up
c_func
(paren
op_amp
id|dir-&gt;u.dir.read_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Remove a reader from dir, possibly admitting writers.&n; */
DECL|function|end_read
r_static
r_inline
r_void
id|end_read
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|dir
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_decrement
id|dir-&gt;u.dir.readers
)paren
)paren
(brace
id|hfs_wake_up
c_func
(paren
op_amp
id|dir-&gt;u.dir.write_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * create_entry()&n; *&n; * Add a new file or directory to the catalog B-tree and&n; * return a (struct hfs_cat_entry) for it in &squot;*result&squot;.&n; */
DECL|function|create_entry
r_static
r_int
id|create_entry
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|parent
comma
r_struct
id|hfs_cat_key
op_star
id|key
comma
r_const
r_struct
id|hfs_cat_rec
op_star
id|record
comma
r_int
id|is_dir
comma
id|hfs_u32
id|cnid
comma
r_struct
id|hfs_cat_entry
op_star
op_star
id|result
)paren
(brace
r_struct
id|hfs_mdb
op_star
id|mdb
op_assign
id|parent-&gt;mdb
suffix:semicolon
r_struct
id|hfs_cat_entry
op_star
id|entry
suffix:semicolon
r_struct
id|hfs_cat_key
id|thd_key
suffix:semicolon
r_struct
id|hfs_cat_rec
id|thd_rec
suffix:semicolon
r_int
id|error
comma
id|has_thread
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* keep readers from getting confused by changing dir size */
id|start_write
c_func
(paren
id|parent
)paren
suffix:semicolon
multiline_comment|/* create a locked entry in the cache */
id|entry
op_assign
id|get_entry
c_func
(paren
id|mdb
comma
id|key
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
(brace
multiline_comment|/* The entry exists but can&squot;t be read */
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;cnid
)paren
(brace
multiline_comment|/* The (unlocked) entry exists in the cache */
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|bail2
suffix:semicolon
)brace
multiline_comment|/* limit directory valence to signed 16-bit integer */
r_if
c_cond
(paren
(paren
id|parent-&gt;u.dir.dirs
op_plus
id|parent-&gt;u.dir.files
)paren
op_ge
id|HFS_MAX_VALENCE
)paren
(brace
id|error
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_goto
id|bail1
suffix:semicolon
)brace
id|has_thread
op_assign
id|is_dir
op_logical_or
(paren
id|record-&gt;u.fil.Flags
op_amp
id|HFS_FIL_THD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|has_thread
)paren
(brace
multiline_comment|/* init some fields for the thread record */
id|memset
c_func
(paren
op_amp
id|thd_rec
comma
l_int|0
comma
r_sizeof
(paren
id|thd_rec
)paren
)paren
suffix:semicolon
id|thd_rec.cdrType
op_assign
id|is_dir
ques
c_cond
id|HFS_CDR_THD
suffix:colon
id|HFS_CDR_FTH
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|thd_rec.u.thd.ParID
comma
op_amp
id|key-&gt;ParID
comma
r_sizeof
(paren
id|hfs_u32
)paren
op_plus
r_sizeof
(paren
r_struct
id|hfs_name
)paren
)paren
suffix:semicolon
multiline_comment|/* insert the thread record */
id|hfs_cat_build_key
c_func
(paren
id|cnid
comma
l_int|NULL
comma
op_amp
id|thd_key
)paren
suffix:semicolon
id|error
op_assign
id|hfs_binsert
c_func
(paren
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|thd_key
)paren
comma
op_amp
id|thd_rec
comma
l_int|2
op_plus
r_sizeof
(paren
id|THD_REC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|bail1
suffix:semicolon
)brace
)brace
multiline_comment|/* insert the record */
id|error
op_assign
id|hfs_binsert
c_func
(paren
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
id|key
)paren
comma
id|record
comma
id|is_dir
ques
c_cond
l_int|2
op_plus
r_sizeof
(paren
id|DIR_REC
)paren
suffix:colon
l_int|2
op_plus
r_sizeof
(paren
id|FIL_REC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
id|has_thread
op_logical_and
(paren
id|error
op_ne
op_minus
id|EIO
)paren
)paren
(brace
multiline_comment|/* at least TRY to remove the thread record */
(paren
r_void
)paren
id|hfs_bdelete
c_func
(paren
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|thd_key
)paren
)paren
suffix:semicolon
)brace
r_goto
id|bail1
suffix:semicolon
)brace
multiline_comment|/* update the parent directory */
id|update_dir
c_func
(paren
id|mdb
comma
id|parent
comma
id|is_dir
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* complete the cache entry and return success */
id|__read_entry
c_func
(paren
id|entry
comma
id|record
)paren
suffix:semicolon
id|unlock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
op_star
id|result
op_assign
id|entry
suffix:semicolon
)brace
r_else
(brace
id|hfs_cat_put
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
r_goto
id|done
suffix:semicolon
id|bail1
suffix:colon
id|entry-&gt;deleted
op_assign
l_int|1
suffix:semicolon
id|remove_hash
c_func
(paren
id|entry
)paren
suffix:semicolon
id|unlock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|bail2
suffix:colon
id|hfs_cat_put
c_func
(paren
id|entry
)paren
suffix:semicolon
id|done
suffix:colon
id|end_write
c_func
(paren
id|parent
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*================ Global functions ================*/
multiline_comment|/* &n; * hfs_cat_put()&n; *&n; * Release an entry we aren&squot;t using anymore.&n; *&n; * NOTE: We must be careful any time we sleep on a non-deleted&n; * entry that the entry is in a consistent state, since another&n; * process may get the entry while we sleep. That is why we&n; * &squot;goto repeat&squot; after each operation that might sleep.&n; */
DECL|function|hfs_cat_put
r_void
id|hfs_cat_put
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
(brace
r_return
suffix:semicolon
)brace
id|wait_on_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;count
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_cat_put: trying to free free entry&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|repeat
suffix:colon
r_if
c_cond
(paren
id|entry-&gt;count
OG
l_int|1
)paren
(brace
id|entry-&gt;count
op_decrement
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;cnid
)paren
(brace
id|clear_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;type
op_eq
id|HFS_CDR_FIL
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;deleted
)paren
(brace
multiline_comment|/* free all extents */
id|entry-&gt;u.file.data_fork.lsize
op_assign
l_int|0
suffix:semicolon
id|hfs_extent_adj
c_func
(paren
op_amp
id|entry-&gt;u.file.data_fork
)paren
suffix:semicolon
id|entry-&gt;u.file.rsrc_fork.lsize
op_assign
l_int|0
suffix:semicolon
id|hfs_extent_adj
c_func
(paren
op_amp
id|entry-&gt;u.file.rsrc_fork
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* clear out any cached extents */
r_if
c_cond
(paren
id|entry-&gt;u.file.data_fork.first.next
)paren
(brace
id|hfs_extent_free
c_func
(paren
op_amp
id|entry-&gt;u.file.data_fork
)paren
suffix:semicolon
id|wait_on_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;u.file.rsrc_fork.first.next
)paren
(brace
id|hfs_extent_free
c_func
(paren
op_amp
id|entry-&gt;u.file.rsrc_fork
)paren
suffix:semicolon
id|wait_on_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|entry-&gt;deleted
)paren
(brace
id|clear_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;dirt
)paren
(brace
id|write_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|entry-&gt;count
op_decrement
suffix:semicolon
id|nr_free_entries
op_increment
suffix:semicolon
multiline_comment|/* get_empty_entry() could be blocked waiting for more entries */
id|hfs_wake_up
c_func
(paren
op_amp
id|entry_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* &n; * hfs_cat_get()&n; *&n; * Wrapper for get_entry() which always calls with (&squot;read&squot;==1).&n; * Used for access to get_entry() from outside this file.&n; */
DECL|function|hfs_cat_get
r_struct
id|hfs_cat_entry
op_star
id|hfs_cat_get
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
comma
r_const
r_struct
id|hfs_cat_key
op_star
id|key
)paren
(brace
r_return
id|get_entry
c_func
(paren
id|mdb
comma
id|key
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * hfs_cat_invalidate()&n; *&n; * Called by hfs_mdb_put() to remove all the entries&n; * in the cache which are associated with a given MDB.&n; */
DECL|function|hfs_cat_invalidate
r_void
id|hfs_cat_invalidate
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|entry
comma
op_star
id|next
suffix:semicolon
r_int
id|i
suffix:semicolon
id|next
op_assign
id|first_entry
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nr_entries
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|entry
op_assign
id|next
suffix:semicolon
id|next
op_assign
id|entry-&gt;next
suffix:semicolon
multiline_comment|/* clear_entry() changes the queues.. */
r_if
c_cond
(paren
id|entry-&gt;mdb
op_ne
id|mdb
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;count
op_logical_or
id|entry-&gt;dirt
op_logical_or
id|entry-&gt;lock
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_fs: entry busy on removed device %s.&bslash;n&quot;
comma
id|hfs_mdb_name
c_func
(paren
id|entry-&gt;mdb-&gt;sys_mdb
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|clear_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * hfs_cat_commit()&n; *&n; * Called by hfs_mdb_commit() to write dirty entries to the disk buffers.&n; */
DECL|function|hfs_cat_commit
r_void
id|hfs_cat_commit
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|hfs_cat_entry
op_star
id|entry
suffix:semicolon
id|entry
op_assign
id|first_entry
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_entries
op_star
l_int|2
suffix:semicolon
id|i
op_increment
comma
id|entry
op_assign
id|entry-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|mdb
op_logical_and
id|entry-&gt;mdb
op_ne
id|mdb
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;cnid
op_logical_or
id|entry-&gt;deleted
)paren
(brace
r_continue
suffix:semicolon
)brace
id|wait_on_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;dirt
)paren
(brace
id|write_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * hfs_cat_free()&n; *&n; * Releases all the memory allocated in grow_entries().&n; * Must call hfs_cat_invalidate() on all MDBs before calling this.&n; */
DECL|function|hfs_cat_free
r_void
id|hfs_cat_free
c_func
(paren
r_void
)paren
(brace
r_struct
id|allocation_unit
op_star
id|tmp
suffix:semicolon
r_while
c_loop
(paren
id|allocation
)paren
(brace
id|tmp
op_assign
id|allocation-&gt;next
suffix:semicolon
id|HFS_DELETE
c_func
(paren
id|allocation
)paren
suffix:semicolon
id|allocation
op_assign
id|tmp
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * hfs_cat_compare()&n; *&n; * Description:&n; *   This is the comparison function used for the catalog B-tree.  In&n; *   comparing catalog B-tree entries, the parent id is the most&n; *   significant field (compared as unsigned ints).  The name field is&n; *   the least significant (compared in &quot;Macintosh lexical order&quot;,&n; *   see hfs_strcmp() in string.c)&n; * Input Variable(s):&n; *   struct hfs_cat_key *key1: pointer to the first key to compare&n; *   struct hfs_cat_key *key2: pointer to the second key to compare&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   int: negative if key1&lt;key2, positive if key1&gt;key2, and 0 if key1==key2&n; * Preconditions:&n; *   key1 and key2 point to &quot;valid&quot; (struct hfs_cat_key)s.&n; * Postconditions:&n; *   This function has no side-effects&n; */
DECL|function|hfs_cat_compare
r_int
id|hfs_cat_compare
c_func
(paren
r_const
r_struct
id|hfs_cat_key
op_star
id|key1
comma
r_const
r_struct
id|hfs_cat_key
op_star
id|key2
)paren
(brace
r_int
r_int
id|parents
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|parents
op_assign
id|hfs_get_hl
c_func
(paren
id|key1-&gt;ParID
)paren
op_minus
id|hfs_get_hl
c_func
(paren
id|key2-&gt;ParID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parents
op_ne
l_int|0
)paren
(brace
id|retval
op_assign
(paren
r_int
)paren
id|parents
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
id|hfs_strcmp
c_func
(paren
op_amp
id|key1-&gt;CName
comma
op_amp
id|key2-&gt;CName
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_cat_build_key()&n; *&n; * Given the ID of the parent and the name build a search key.&n; */
DECL|function|hfs_cat_build_key
r_void
id|hfs_cat_build_key
c_func
(paren
id|hfs_u32
id|parent
comma
r_const
r_struct
id|hfs_name
op_star
id|cname
comma
r_struct
id|hfs_cat_key
op_star
id|key
)paren
(brace
id|hfs_put_nl
c_func
(paren
id|parent
comma
id|key-&gt;ParID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cname
)paren
(brace
id|key-&gt;KeyLen
op_assign
l_int|6
op_plus
id|cname-&gt;Len
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|key-&gt;CName
comma
id|cname
comma
r_sizeof
(paren
op_star
id|cname
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|key-&gt;KeyLen
op_assign
l_int|6
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|key-&gt;CName
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cname
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * hfs_cat_open()&n; *&n; * Given a directory on an HFS filesystem get its thread and&n; * lock the directory against insertions and deletions.&n; * Return 0 on success or an error code on failure.&n; */
DECL|function|hfs_cat_open
r_int
id|hfs_cat_open
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|dir
comma
r_struct
id|hfs_brec
op_star
id|brec
)paren
(brace
r_struct
id|hfs_cat_key
id|key
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;type
op_ne
id|HFS_CDR_DIR
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Block writers */
id|start_read
c_func
(paren
id|dir
)paren
suffix:semicolon
multiline_comment|/* Find the directory */
id|hfs_cat_build_key
c_func
(paren
id|dir-&gt;cnid
comma
l_int|NULL
comma
op_amp
id|key
)paren
suffix:semicolon
id|error
op_assign
id|hfs_bfind
c_func
(paren
id|brec
comma
id|dir-&gt;mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|key
)paren
comma
id|HFS_BFIND_READ_EQ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|end_read
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_cat_next()&n; *&n; * Given a catalog brec structure, replace it with the count&squot;th next brec&n; * in the same directory.&n; * Return an error code if there is a problem, 0 if OK.&n; * Note that an error code of -ENOENT means there are no more entries&n; * in this directory.&n; * The directory is &quot;closed&quot; on an error.&n; */
DECL|function|hfs_cat_next
r_int
id|hfs_cat_next
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|dir
comma
r_struct
id|hfs_brec
op_star
id|brec
comma
id|hfs_u16
id|count
comma
id|hfs_u32
op_star
id|cnid
comma
id|hfs_u8
op_star
id|type
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
op_logical_or
op_logical_neg
id|brec
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Get the count&squot;th next catalog tree entry */
id|error
op_assign
id|hfs_bsucc
c_func
(paren
id|brec
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_struct
id|hfs_cat_key
op_star
id|key
op_assign
(paren
r_struct
id|hfs_cat_key
op_star
)paren
id|brec-&gt;key
suffix:semicolon
r_if
c_cond
(paren
id|hfs_get_nl
c_func
(paren
id|key-&gt;ParID
)paren
op_ne
id|dir-&gt;cnid
)paren
(brace
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
op_star
id|type
op_assign
(paren
(paren
r_struct
id|hfs_cat_rec
op_star
)paren
id|brec-&gt;data
)paren
op_member_access_from_pointer
id|cdrType
suffix:semicolon
op_star
id|cnid
op_assign
id|brec_to_id
c_func
(paren
id|brec
)paren
suffix:semicolon
)brace
r_else
(brace
id|end_read
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_cat_close()&n; *&n; * Given a catalog brec structure, replace it with the count&squot;th next brec&n; * in the same directory.&n; * Return an error code if there is a problem, 0 if OK.&n; * Note that an error code of -ENOENT means there are no more entries&n; * in this directory.&n; */
DECL|function|hfs_cat_close
r_void
id|hfs_cat_close
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|dir
comma
r_struct
id|hfs_brec
op_star
id|brec
)paren
(brace
r_if
c_cond
(paren
id|dir
op_logical_and
id|brec
)paren
(brace
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
id|end_read
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * hfs_cat_parent()&n; *&n; * Given a catalog entry, return the entry for its parent.&n; * Uses catalog key for the entry to get its parent&squot;s ID&n; * and then uses the parent&squot;s thread record to locate the&n; * parent&squot;s actual catalog entry.&n; */
DECL|function|hfs_cat_parent
r_struct
id|hfs_cat_entry
op_star
id|hfs_cat_parent
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|entry
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|retval
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|hfs_mdb
op_star
id|mdb
op_assign
id|entry-&gt;mdb
suffix:semicolon
r_struct
id|hfs_brec
id|brec
suffix:semicolon
r_struct
id|hfs_cat_key
id|key
suffix:semicolon
r_int
id|error
suffix:semicolon
id|lock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;deleted
)paren
(brace
id|hfs_cat_build_key
c_func
(paren
id|hfs_get_nl
c_func
(paren
id|entry-&gt;key.ParID
)paren
comma
l_int|NULL
comma
op_amp
id|key
)paren
suffix:semicolon
id|error
op_assign
id|hfs_bfind
c_func
(paren
op_amp
id|brec
comma
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|key
)paren
comma
id|HFS_BFIND_READ_EQ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
multiline_comment|/* convert thread record to key */
r_struct
id|hfs_cat_rec
op_star
id|rec
op_assign
id|brec.data
suffix:semicolon
id|key.KeyLen
op_assign
l_int|6
op_plus
id|rec-&gt;u.thd.CName.Len
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|key.ParID
comma
op_amp
id|rec-&gt;u.thd.ParID
comma
r_sizeof
(paren
id|hfs_u32
)paren
op_plus
r_sizeof
(paren
r_struct
id|hfs_name
)paren
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
op_amp
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
id|retval
op_assign
id|hfs_cat_get
c_func
(paren
id|mdb
comma
op_amp
id|key
)paren
suffix:semicolon
)brace
)brace
id|unlock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_cat_create()&n; *&n; * Create a new file with the indicated name in the indicated directory.&n; * The file will have the indicated flags, type and creator.&n; * If successful an (struct hfs_cat_entry) is returned in &squot;*result&squot;.&n; */
DECL|function|hfs_cat_create
r_int
id|hfs_cat_create
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|parent
comma
r_struct
id|hfs_cat_key
op_star
id|key
comma
id|hfs_u8
id|flags
comma
id|hfs_u32
id|type
comma
id|hfs_u32
id|creator
comma
r_struct
id|hfs_cat_entry
op_star
op_star
id|result
)paren
(brace
r_struct
id|hfs_cat_rec
id|record
suffix:semicolon
id|hfs_u32
id|id
op_assign
id|new_cnid
c_func
(paren
id|parent-&gt;mdb
)paren
suffix:semicolon
id|hfs_u32
id|mtime
op_assign
id|hfs_time
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* init some fields for the file record */
id|memset
c_func
(paren
op_amp
id|record
comma
l_int|0
comma
r_sizeof
(paren
id|record
)paren
)paren
suffix:semicolon
id|record.cdrType
op_assign
id|HFS_CDR_FIL
suffix:semicolon
id|record.u.fil.Flags
op_assign
id|flags
op_or
id|HFS_FIL_USED
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|id
comma
id|record.u.fil.FlNum
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|mtime
comma
id|record.u.fil.CrDat
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|mtime
comma
id|record.u.fil.MdDat
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
l_int|0
comma
id|record.u.fil.BkDat
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|type
comma
id|record.u.fil.UsrWds.fdType
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|creator
comma
id|record.u.fil.UsrWds.fdCreator
)paren
suffix:semicolon
r_return
id|create_entry
c_func
(paren
id|parent
comma
id|key
comma
op_amp
id|record
comma
l_int|0
comma
id|id
comma
id|result
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_cat_mkdir()&n; *&n; * Create a new directory with the indicated name in the indicated directory.&n; * If successful an (struct hfs_cat_entry) is returned in &squot;*result&squot;.&n; */
DECL|function|hfs_cat_mkdir
r_int
id|hfs_cat_mkdir
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|parent
comma
r_struct
id|hfs_cat_key
op_star
id|key
comma
r_struct
id|hfs_cat_entry
op_star
op_star
id|result
)paren
(brace
r_struct
id|hfs_cat_rec
id|record
suffix:semicolon
id|hfs_u32
id|id
op_assign
id|new_cnid
c_func
(paren
id|parent-&gt;mdb
)paren
suffix:semicolon
id|hfs_u32
id|mtime
op_assign
id|hfs_time
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* init some fields for the directory record */
id|memset
c_func
(paren
op_amp
id|record
comma
l_int|0
comma
r_sizeof
(paren
id|record
)paren
)paren
suffix:semicolon
id|record.cdrType
op_assign
id|HFS_CDR_DIR
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|id
comma
id|record.u.dir.DirID
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|mtime
comma
id|record.u.dir.CrDat
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|mtime
comma
id|record.u.dir.MdDat
)paren
suffix:semicolon
id|hfs_put_nl
c_func
(paren
l_int|0
comma
id|record.u.dir.BkDat
)paren
suffix:semicolon
id|hfs_put_hs
c_func
(paren
l_int|0xff
comma
id|record.u.dir.UsrInfo.frView
)paren
suffix:semicolon
r_return
id|create_entry
c_func
(paren
id|parent
comma
id|key
comma
op_amp
id|record
comma
l_int|1
comma
id|id
comma
id|result
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_cat_delete()&n; *&n; * Delete the indicated file or directory.&n; * The associated thread is also removed unless (&squot;with_thread&squot;==0).&n; */
DECL|function|hfs_cat_delete
r_int
id|hfs_cat_delete
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|parent
comma
r_struct
id|hfs_cat_entry
op_star
id|entry
comma
r_int
id|with_thread
)paren
(brace
r_struct
id|hfs_cat_key
id|key
suffix:semicolon
r_struct
id|hfs_mdb
op_star
id|mdb
op_assign
id|parent-&gt;mdb
suffix:semicolon
r_int
id|is_dir
comma
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|parent-&gt;mdb
op_ne
id|entry-&gt;mdb
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;type
op_eq
id|HFS_CDR_FIL
)paren
(brace
id|with_thread
op_assign
(paren
id|entry-&gt;u.file.flags
op_amp
id|HFS_FIL_THD
)paren
op_logical_and
id|with_thread
suffix:semicolon
id|is_dir
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|is_dir
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* keep readers from getting confused by changing dir size */
id|start_write
c_func
(paren
id|parent
)paren
suffix:semicolon
multiline_comment|/* don&squot;t delete a busy directory */
r_if
c_cond
(paren
id|entry-&gt;type
op_eq
id|HFS_CDR_DIR
)paren
(brace
id|start_read
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;u.dir.files
op_logical_or
id|entry-&gt;u.dir.dirs
)paren
(brace
id|error
op_assign
op_minus
id|ENOTEMPTY
suffix:semicolon
)brace
)brace
multiline_comment|/* try to delete the file or directory */
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|lock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;deleted
)paren
(brace
multiline_comment|/* somebody beat us to it */
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|hfs_bdelete
c_func
(paren
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|entry-&gt;key
)paren
)paren
suffix:semicolon
)brace
id|unlock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
multiline_comment|/* Mark the entry deleted and remove it from the cache */
id|entry-&gt;deleted
op_assign
l_int|1
suffix:semicolon
id|remove_hash
c_func
(paren
id|entry
)paren
suffix:semicolon
multiline_comment|/* try to delete the thread entry if it exists */
r_if
c_cond
(paren
id|with_thread
)paren
(brace
id|hfs_cat_build_key
c_func
(paren
id|entry-&gt;cnid
comma
l_int|NULL
comma
op_amp
id|key
)paren
suffix:semicolon
(paren
r_void
)paren
id|hfs_bdelete
c_func
(paren
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|key
)paren
)paren
suffix:semicolon
)brace
id|update_dir
c_func
(paren
id|mdb
comma
id|parent
comma
id|is_dir
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;type
op_eq
id|HFS_CDR_DIR
)paren
(brace
id|end_read
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
id|end_write
c_func
(paren
id|parent
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_cat_move()&n; *&n; * Rename a file or directory, possibly to a new directory.&n; * If the destination exists it is removed and a&n; * (struct hfs_cat_entry) for it is returned in &squot;*result&squot;.&n; */
DECL|function|hfs_cat_move
r_int
id|hfs_cat_move
c_func
(paren
r_struct
id|hfs_cat_entry
op_star
id|old_dir
comma
r_struct
id|hfs_cat_entry
op_star
id|new_dir
comma
r_struct
id|hfs_cat_entry
op_star
id|entry
comma
r_struct
id|hfs_cat_key
op_star
id|new_key
comma
r_struct
id|hfs_cat_entry
op_star
op_star
id|removed
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|dest
suffix:semicolon
r_struct
id|hfs_mdb
op_star
id|mdb
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|is_dir
comma
id|has_thread
suffix:semicolon
r_if
c_cond
(paren
id|removed
)paren
(brace
op_star
id|removed
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* sanity checks */
r_if
c_cond
(paren
op_logical_neg
id|old_dir
op_logical_or
op_logical_neg
id|new_dir
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|mdb
op_assign
id|old_dir-&gt;mdb
suffix:semicolon
r_if
c_cond
(paren
id|mdb
op_ne
id|new_dir-&gt;mdb
)paren
(brace
r_return
op_minus
id|EXDEV
suffix:semicolon
)brace
multiline_comment|/* precompute a few things */
r_if
c_cond
(paren
id|entry-&gt;type
op_eq
id|HFS_CDR_DIR
)paren
(brace
id|is_dir
op_assign
l_int|1
suffix:semicolon
id|has_thread
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry-&gt;type
op_eq
id|HFS_CDR_FIL
)paren
(brace
id|is_dir
op_assign
l_int|0
suffix:semicolon
id|has_thread
op_assign
id|entry-&gt;u.file.flags
op_amp
id|HFS_FIL_THD
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mdb-&gt;rename_lock
)paren
(brace
id|hfs_sleep_on
c_func
(paren
op_amp
id|mdb-&gt;rename_wait
)paren
suffix:semicolon
)brace
id|mdb-&gt;rename_lock
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* keep readers from getting confused by changing dir size */
id|start_write
c_func
(paren
id|new_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_dir
op_ne
id|new_dir
)paren
(brace
id|start_write
c_func
(paren
id|old_dir
)paren
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t move a directory inside itself */
r_if
c_cond
(paren
id|is_dir
)paren
(brace
r_struct
id|hfs_cat_key
id|thd_key
suffix:semicolon
r_struct
id|hfs_brec
id|brec
suffix:semicolon
id|hfs_u32
id|id
op_assign
id|new_dir-&gt;cnid
suffix:semicolon
r_while
c_loop
(paren
id|id
op_ne
id|htonl
c_func
(paren
id|HFS_ROOT_CNID
)paren
)paren
(brace
r_if
c_cond
(paren
id|id
op_eq
id|entry-&gt;cnid
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
id|hfs_cat_build_key
c_func
(paren
id|id
comma
l_int|NULL
comma
op_amp
id|thd_key
)paren
suffix:semicolon
id|error
op_assign
id|hfs_bfind
c_func
(paren
op_amp
id|brec
comma
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|thd_key
)paren
comma
id|HFS_BFIND_READ_EQ
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
r_else
(brace
r_struct
id|hfs_cat_rec
op_star
id|rec
op_assign
id|brec.data
suffix:semicolon
id|id
op_assign
id|hfs_get_nl
c_func
(paren
id|rec-&gt;u.thd.ParID
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
op_amp
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
)brace
id|restart
suffix:colon
multiline_comment|/* see if the destination exists, getting it if it does */
id|dest
op_assign
id|hfs_cat_get
c_func
(paren
id|mdb
comma
id|new_key
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dest
)paren
(brace
multiline_comment|/* destination doesn&squot;t exist, so create it */
r_struct
id|hfs_cat_rec
id|new_record
suffix:semicolon
multiline_comment|/* create a locked entry in the cache */
id|dest
op_assign
id|get_entry
c_func
(paren
id|mdb
comma
id|new_key
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dest
)paren
(brace
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dest-&gt;cnid
)paren
(brace
multiline_comment|/* The (unlocked) entry exists in the cache */
r_goto
id|have_distinct
suffix:semicolon
)brace
multiline_comment|/* limit directory valence to signed 16-bit integer */
r_if
c_cond
(paren
(paren
id|new_dir-&gt;u.dir.dirs
op_plus
id|new_dir-&gt;u.dir.files
)paren
op_ge
id|HFS_MAX_VALENCE
)paren
(brace
id|error
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_goto
id|bail3
suffix:semicolon
)brace
multiline_comment|/* build the new record */
id|new_record.cdrType
op_assign
id|entry-&gt;type
suffix:semicolon
id|__write_entry
c_func
(paren
id|entry
comma
op_amp
id|new_record
)paren
suffix:semicolon
multiline_comment|/* insert the new record */
id|error
op_assign
id|hfs_binsert
c_func
(paren
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
id|new_key
)paren
comma
op_amp
id|new_record
comma
id|is_dir
ques
c_cond
l_int|2
op_plus
r_sizeof
(paren
id|DIR_REC
)paren
suffix:colon
l_int|2
op_plus
r_sizeof
(paren
id|FIL_REC
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|EEXIST
)paren
(brace
id|dest-&gt;deleted
op_assign
l_int|1
suffix:semicolon
id|remove_hash
c_func
(paren
id|dest
)paren
suffix:semicolon
id|unlock_entry
c_func
(paren
id|dest
)paren
suffix:semicolon
id|hfs_cat_put
c_func
(paren
id|dest
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|bail3
suffix:semicolon
)brace
multiline_comment|/* update the destination directory */
id|update_dir
c_func
(paren
id|mdb
comma
id|new_dir
comma
id|is_dir
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry
op_ne
id|dest
)paren
(brace
id|have_distinct
suffix:colon
multiline_comment|/* The destination exists and is not same as source */
id|lock_entry
c_func
(paren
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dest-&gt;deleted
)paren
(brace
id|unlock_entry
c_func
(paren
id|dest
)paren
suffix:semicolon
id|hfs_cat_put
c_func
(paren
id|dest
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dest-&gt;type
op_ne
id|entry-&gt;type
)paren
(brace
multiline_comment|/* can&squot;t move a file on top&n;&t;&t;&t;   of a dir nor vice versa. */
id|error
op_assign
id|is_dir
ques
c_cond
op_minus
id|ENOTDIR
suffix:colon
op_minus
id|EISDIR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|is_dir
op_logical_and
(paren
id|dest-&gt;u.dir.dirs
op_logical_or
id|dest-&gt;u.dir.files
)paren
)paren
(brace
multiline_comment|/* directory to replace is not empty */
id|error
op_assign
op_minus
id|ENOTEMPTY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|bail2
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* The destination exists but is same as source */
multiline_comment|/*--entry-&gt;count;*/
id|hfs_cat_put
c_func
(paren
id|dest
)paren
suffix:semicolon
id|dest
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* lock the entry */
id|lock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;deleted
)paren
(brace
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|bail1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dest
)paren
(brace
multiline_comment|/* remove the old entry */
id|error
op_assign
id|hfs_bdelete
c_func
(paren
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|entry-&gt;key
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/* We couldn&squot;t remove the entry for the&n;&t;&t;&t;   original file, so nothing has changed. */
r_goto
id|bail1
suffix:semicolon
)brace
id|update_dir
c_func
(paren
id|mdb
comma
id|old_dir
comma
id|is_dir
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* update the thread of the dir/file we&squot;re moving */
r_if
c_cond
(paren
id|has_thread
)paren
(brace
r_struct
id|hfs_cat_key
id|thd_key
suffix:semicolon
r_struct
id|hfs_brec
id|brec
suffix:semicolon
id|hfs_cat_build_key
c_func
(paren
id|entry-&gt;cnid
comma
l_int|NULL
comma
op_amp
id|thd_key
)paren
suffix:semicolon
id|error
op_assign
id|hfs_bfind
c_func
(paren
op_amp
id|brec
comma
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|thd_key
)paren
comma
id|HFS_BFIND_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|ENOENT
)paren
(brace
r_if
c_cond
(paren
id|is_dir
)paren
(brace
multiline_comment|/* directory w/o a thread! */
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We were lied to! */
id|entry-&gt;u.file.flags
op_and_assign
op_complement
id|HFS_FIL_THD
suffix:semicolon
id|entry-&gt;dirt
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_struct
id|hfs_cat_rec
op_star
id|rec
op_assign
id|brec.data
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|rec-&gt;u.thd.ParID
comma
op_amp
id|new_key-&gt;ParID
comma
r_sizeof
(paren
id|hfs_u32
)paren
op_plus
r_sizeof
(paren
r_struct
id|hfs_name
)paren
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
op_amp
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|ENOENT
)paren
(brace
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|dest
)paren
(brace
multiline_comment|/* Nothing was changed */
id|unlock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Something went seriously wrong.&n;&t;&t;&t;   The dir/file has been deleted. */
multiline_comment|/* XXX try some recovery? */
id|entry-&gt;deleted
op_assign
l_int|1
suffix:semicolon
id|remove_hash
c_func
(paren
id|entry
)paren
suffix:semicolon
r_goto
id|bail1
suffix:semicolon
)brace
)brace
multiline_comment|/* TRY to remove the thread for the pre-existing entry */
r_if
c_cond
(paren
id|dest
op_logical_and
id|dest-&gt;cnid
op_logical_and
(paren
id|is_dir
op_logical_or
(paren
id|dest-&gt;u.file.flags
op_amp
id|HFS_FIL_THD
)paren
)paren
)paren
(brace
r_struct
id|hfs_cat_key
id|thd_key
suffix:semicolon
id|hfs_cat_build_key
c_func
(paren
id|dest-&gt;cnid
comma
l_int|NULL
comma
op_amp
id|thd_key
)paren
suffix:semicolon
(paren
r_void
)paren
id|hfs_bdelete
c_func
(paren
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|thd_key
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* update directories */
id|new_dir-&gt;modify_date
op_assign
id|hfs_time
c_func
(paren
)paren
suffix:semicolon
id|new_dir-&gt;dirt
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* update key */
id|remove_hash
c_func
(paren
id|entry
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|entry-&gt;key
comma
id|new_key
comma
r_sizeof
(paren
op_star
id|new_key
)paren
)paren
suffix:semicolon
id|entry-&gt;key_dirt
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Since case might differ */
id|entry-&gt;dirt
op_assign
l_int|1
suffix:semicolon
id|insert_hash
c_func
(paren
id|entry
)paren
suffix:semicolon
id|unlock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
multiline_comment|/* delete any pre-existing or place-holder entry */
r_if
c_cond
(paren
id|dest
)paren
(brace
id|dest-&gt;deleted
op_assign
l_int|1
suffix:semicolon
id|remove_hash
c_func
(paren
id|dest
)paren
suffix:semicolon
id|unlock_entry
c_func
(paren
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|removed
op_logical_and
id|dest-&gt;cnid
)paren
(brace
op_star
id|removed
op_assign
id|dest
suffix:semicolon
)brace
r_else
(brace
id|hfs_cat_put
c_func
(paren
id|dest
)paren
suffix:semicolon
)brace
)brace
r_goto
id|done
suffix:semicolon
id|bail1
suffix:colon
id|unlock_entry
c_func
(paren
id|entry
)paren
suffix:semicolon
id|bail2
suffix:colon
r_if
c_cond
(paren
id|dest
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dest-&gt;cnid
)paren
(brace
multiline_comment|/* TRY to remove the new entry */
(paren
r_void
)paren
id|hfs_bdelete
c_func
(paren
id|mdb-&gt;cat_tree
comma
id|HFS_BKEY
c_func
(paren
id|new_key
)paren
)paren
suffix:semicolon
id|update_dir
c_func
(paren
id|mdb
comma
id|new_dir
comma
id|is_dir
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|bail3
suffix:colon
id|dest-&gt;deleted
op_assign
l_int|1
suffix:semicolon
id|remove_hash
c_func
(paren
id|dest
)paren
suffix:semicolon
)brace
id|unlock_entry
c_func
(paren
id|dest
)paren
suffix:semicolon
id|hfs_cat_put
c_func
(paren
id|dest
)paren
suffix:semicolon
)brace
id|done
suffix:colon
r_if
c_cond
(paren
id|new_dir
op_ne
id|old_dir
)paren
(brace
id|end_write
c_func
(paren
id|old_dir
)paren
suffix:semicolon
)brace
id|end_write
c_func
(paren
id|new_dir
)paren
suffix:semicolon
id|mdb-&gt;rename_lock
op_assign
l_int|0
suffix:semicolon
id|hfs_wake_up
c_func
(paren
op_amp
id|mdb-&gt;rename_wait
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
eof
