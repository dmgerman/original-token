multiline_comment|/*&n; * linux/fs/hfs/brec.c&n; *&n; * Copyright (C) 1995-1997  Paul H. Hargrove&n; * This file may be distributed under the terms of the GNU Public License.&n; *&n; * This file contains the code to access records in a btree.&n; *&n; * &quot;XXX&quot; in a comment is a note to myself to consider changing something.&n; *&n; * In function preconditions the term &quot;valid&quot; applied to a pointer to&n; * a structure means that the pointer is non-NULL and the structure it&n; * points to has all fields initialized to consistent values.&n; */
macro_line|#include &quot;hfs_btree.h&quot;
multiline_comment|/*================ File-local functions ================*/
multiline_comment|/*&n; * first()&n; *&n; * returns HFS_BPATH_FIRST if elem-&gt;record == 1, 0 otherwise&n; */
DECL|function|first
r_static
r_inline
r_int
id|first
c_func
(paren
r_const
r_struct
id|hfs_belem
op_star
id|elem
)paren
(brace
r_return
(paren
id|elem-&gt;record
op_eq
l_int|1
)paren
ques
c_cond
id|HFS_BPATH_FIRST
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * overflow()&n; *&n; * return HFS_BPATH_OVERFLOW if the node has no room for an &n; * additional pointer record, 0 otherwise.&n; */
DECL|function|overflow
r_static
r_inline
r_int
id|overflow
c_func
(paren
r_const
r_struct
id|hfs_btree
op_star
id|tree
comma
r_const
r_struct
id|hfs_bnode
op_star
id|bnode
)paren
(brace
multiline_comment|/* there is some algebra involved in getting this form */
r_return
(paren
(paren
id|HFS_SECTOR_SIZE
op_minus
r_sizeof
(paren
id|hfs_u32
)paren
)paren
OL
(paren
id|bnode_end
c_func
(paren
id|bnode
)paren
op_plus
(paren
l_int|2
op_plus
id|bnode-&gt;ndNRecs
)paren
op_star
r_sizeof
(paren
id|hfs_u16
)paren
op_plus
id|ROUND
c_func
(paren
id|tree-&gt;bthKeyLen
op_plus
l_int|1
)paren
)paren
)paren
ques
c_cond
id|HFS_BPATH_OVERFLOW
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * underflow()&n; *&n; * return HFS_BPATH_UNDERFLOW if the node will be less that 1/2 full&n; * upon removal of a pointer record, 0 otherwise.&n; */
DECL|function|underflow
r_static
r_inline
r_int
id|underflow
c_func
(paren
r_const
r_struct
id|hfs_btree
op_star
id|tree
comma
r_const
r_struct
id|hfs_bnode
op_star
id|bnode
)paren
(brace
r_return
(paren
(paren
id|bnode-&gt;ndNRecs
op_star
r_sizeof
(paren
id|hfs_u16
)paren
op_plus
id|bnode_offset
c_func
(paren
id|bnode
comma
id|bnode-&gt;ndNRecs
)paren
)paren
OL
(paren
id|HFS_SECTOR_SIZE
op_minus
r_sizeof
(paren
r_struct
id|NodeDescriptor
)paren
)paren
op_div
l_int|2
)paren
ques
c_cond
id|HFS_BPATH_UNDERFLOW
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*================ Global functions ================*/
multiline_comment|/*&n; * hfs_brec_next()&n; *&n; * Description:&n; *   Obtain access to a child of an internal node in a B-tree.&n; * Input Variable(s):&n; *   struct hfs_brec *brec: pointer to the (struct hfs_brec) to&n; *    add an element to.&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   struct hfs_belem *: pointer to the new path element or NULL&n; * Preconditions:&n; *   &squot;brec&squot; points to a &quot;valid&quot; (struct hfs_brec), the last element of&n; *   which corresponds to a record in a bnode of type ndIndxNode and the&n; *   &squot;record&squot; field indicates the index record for the desired child.&n; * Postconditions:&n; *   If the call to hfs_bnode_find() fails then &squot;brec&squot; is released&n; *   and a NULL is returned.&n; *   Otherwise:&n; *    Any ancestors in &squot;brec&squot; that are not needed (as determined by the&n; *     &squot;keep_flags&squot; field of &squot;brec) are released from &squot;brec&squot;.&n; *    A new element is added to &squot;brec&squot; corresponding to the desired&n; *     child.&n; *    The child is obtained with the same &squot;lock_type&squot; field as its&n; *     parent.&n; *    The &squot;record&squot; field is initialized to the last record.&n; *    A pointer to the new path element is returned.&n; */
DECL|function|hfs_brec_next
r_struct
id|hfs_belem
op_star
id|hfs_brec_next
c_func
(paren
r_struct
id|hfs_brec
op_star
id|brec
)paren
(brace
r_struct
id|hfs_belem
op_star
id|elem
op_assign
id|brec-&gt;bottom
suffix:semicolon
id|hfs_u32
id|node
suffix:semicolon
r_int
id|lock_type
suffix:semicolon
multiline_comment|/* release unneeded ancestors */
id|elem-&gt;flags
op_assign
id|first
c_func
(paren
id|elem
)paren
op_or
id|overflow
c_func
(paren
id|brec-&gt;tree
comma
id|elem-&gt;bnr.bn
)paren
op_or
id|underflow
c_func
(paren
id|brec-&gt;tree
comma
id|elem-&gt;bnr.bn
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|brec-&gt;keep_flags
op_amp
id|elem-&gt;flags
)paren
)paren
(brace
id|hfs_brec_relse
c_func
(paren
id|brec
comma
id|brec-&gt;bottom
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|brec-&gt;bottom
op_minus
l_int|2
op_ge
id|brec-&gt;top
)paren
op_logical_and
op_logical_neg
(paren
id|elem-&gt;flags
op_amp
(paren
id|elem
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|flags
)paren
)paren
(brace
id|hfs_brec_relse
c_func
(paren
id|brec
comma
id|brec-&gt;bottom
op_minus
l_int|2
)paren
suffix:semicolon
)brace
id|node
op_assign
id|hfs_get_hl
c_func
(paren
id|belem_record
c_func
(paren
id|elem
)paren
)paren
suffix:semicolon
id|lock_type
op_assign
id|elem-&gt;bnr.lock_type
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node
op_logical_or
id|hfs_bnode_in_brec
c_func
(paren
id|node
comma
id|brec
)paren
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bfind: corrupt btree&bslash;n&quot;
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
op_increment
id|elem
suffix:semicolon
op_increment
id|brec-&gt;bottom
suffix:semicolon
id|elem-&gt;bnr
op_assign
id|hfs_bnode_find
c_func
(paren
id|brec-&gt;tree
comma
id|node
comma
id|lock_type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|elem-&gt;bnr.bn
)paren
(brace
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|elem-&gt;record
op_assign
id|elem-&gt;bnr.bn-&gt;ndNRecs
suffix:semicolon
r_return
id|elem
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_brec_lock()&n; *&n; * Description:&n; *   This function obtains HFS_LOCK_WRITE access to the bnode&n; *   containing this hfs_brec.&t;All descendents in the path from this&n; *   record to the leaf are given HFS_LOCK_WRITE access and all&n; *   ancestors in the path from the root to here are released.&n; * Input Variable(s):&n; *   struct hfs_brec *brec: pointer to the brec to obtain&n; *    HFS_LOCK_WRITE access to some of the nodes of.&n; *   struct hfs_belem *elem: the first node to lock or NULL for all&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   void&n; * Preconditions:&n; *   &squot;brec&squot; points to a &quot;valid&quot; (struct hfs_brec)&n; * Postconditions: &n; *   All nodes between the indicated node and the beginning of the path&n; *    are released.  hfs_bnode_lock() is called in turn on each node&n; *    from the indicated node to the leaf node of the path, with a&n; *    lock_type argument of HFS_LOCK_WRITE.  If one of those calls&n; *    results in deadlock, then this function will never return.&n; */
DECL|function|hfs_brec_lock
r_void
id|hfs_brec_lock
c_func
(paren
r_struct
id|hfs_brec
op_star
id|brec
comma
r_struct
id|hfs_belem
op_star
id|elem
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|elem
)paren
(brace
id|elem
op_assign
id|brec-&gt;top
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|elem
OG
id|brec-&gt;top
)paren
(brace
id|hfs_brec_relse
c_func
(paren
id|brec
comma
id|elem
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|elem
op_le
id|brec-&gt;bottom
)paren
(brace
id|hfs_bnode_lock
c_func
(paren
op_amp
id|elem-&gt;bnr
comma
id|HFS_LOCK_WRITE
)paren
suffix:semicolon
op_increment
id|elem
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * hfs_brec_init()&n; *&n; * Description:&n; *   Obtain access to the root node of a B-tree.&n; *   Note that this first must obtain access to the header node.&n; * Input Variable(s):&n; *   struct hfs_brec *brec: pointer to the (struct hfs_brec) to&n; *    initialize&n; *   struct hfs_btree *btree: pointer to the (struct hfs_btree)&n; *   int lock_type: the type of access to get to the nodes.&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   struct hfs_belem *: pointer to the root path element or NULL&n; * Preconditions:&n; *   &squot;brec&squot; points to a (struct hfs_brec).&n; *   &squot;tree&squot; points to a valid (struct hfs_btree).&n; * Postconditions:&n; *   If the two calls to brec_bnode_find() succeed then the return value&n; *   points to a (struct hfs_belem) which corresponds to the root node&n; *   of &squot;brec-&gt;tree&squot;.&n; *   Both the root and header nodes are obtained with the type of lock&n; *   given by (flags &amp; HFS_LOCK_MASK).&n; *   The fields &squot;record&squot; field of the root is set to its last record.&n; *   If the header node is not needed to complete the appropriate&n; *   operation (as determined by the &squot;keep_flags&squot; field of &squot;brec&squot;) then&n; *   it is released before this function returns.&n; *   If either call to brec_bnode_find() fails, NULL is returned and the&n; *   (struct hfs_brec) pointed to by &squot;brec&squot; is invalid.&n; */
DECL|function|hfs_brec_init
r_struct
id|hfs_belem
op_star
id|hfs_brec_init
c_func
(paren
r_struct
id|hfs_brec
op_star
id|brec
comma
r_struct
id|hfs_btree
op_star
id|tree
comma
r_int
id|flags
)paren
(brace
r_struct
id|hfs_belem
op_star
id|head
op_assign
op_amp
id|brec-&gt;elem
(braket
l_int|0
)braket
suffix:semicolon
r_struct
id|hfs_belem
op_star
id|root
op_assign
op_amp
id|brec-&gt;elem
(braket
l_int|1
)braket
suffix:semicolon
r_int
id|lock_type
op_assign
id|flags
op_amp
id|HFS_LOCK_MASK
suffix:semicolon
id|brec-&gt;tree
op_assign
id|tree
suffix:semicolon
id|head-&gt;bnr
op_assign
id|hfs_bnode_find
c_func
(paren
id|tree
comma
l_int|0
comma
id|lock_type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|head-&gt;bnr.bn
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|root-&gt;bnr
op_assign
id|hfs_bnode_find
c_func
(paren
id|tree
comma
id|tree-&gt;bthRoot
comma
id|lock_type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root-&gt;bnr.bn
)paren
(brace
id|hfs_bnode_relse
c_func
(paren
op_amp
id|head-&gt;bnr
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|root-&gt;record
op_assign
id|root-&gt;bnr.bn-&gt;ndNRecs
suffix:semicolon
id|brec-&gt;top
op_assign
id|head
suffix:semicolon
id|brec-&gt;bottom
op_assign
id|root
suffix:semicolon
id|brec-&gt;keep_flags
op_assign
id|flags
op_amp
id|HFS_BPATH_MASK
suffix:semicolon
multiline_comment|/* HFS_BPATH_FIRST not applicable for root */
multiline_comment|/* and HFS_BPATH_UNDERFLOW is different */
id|root-&gt;flags
op_assign
id|overflow
c_func
(paren
id|tree
comma
id|root-&gt;bnr.bn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root-&gt;record
OL
l_int|3
)paren
(brace
id|root-&gt;flags
op_or_assign
id|HFS_BPATH_UNDERFLOW
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|root-&gt;flags
op_amp
id|brec-&gt;keep_flags
)paren
)paren
(brace
id|hfs_brec_relse
c_func
(paren
id|brec
comma
id|head
)paren
suffix:semicolon
)brace
r_return
id|root
suffix:semicolon
)brace
eof
