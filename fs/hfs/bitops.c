multiline_comment|/*&n; * linux/fs/hfs/bitops.c&n; *&n; * Copyright (C) 1996  Paul H. Hargrove&n; * This file may be distributed under the terms of the GNU Public License.&n; *&n; * This file contains functions to handle bitmaps in &quot;left-to-right&quot;&n; * bit-order such that the MSB of a 32-bit big-endian word is bit 0.&n; * (This corresponds to bit 7 of a 32-bit little-endian word.)&n; *&n; * I have tested and confirmed that the results are identical on the&n; * Intel x86, PowerPC and DEC Alpha processors.&n; *&n; * &quot;XXX&quot; in a comment is a note to myself to consider changing something.&n; */
macro_line|#include &quot;hfs.h&quot;
multiline_comment|/*================ Global functions ================*/
multiline_comment|/*&n; * hfs_find_zero_bit()&n; *&n; * Description:&n; *  Given a block of memory, its length in bits, and a starting bit number,&n; *  determine the number of the first zero bits (in left-to-right ordering)&n; *  in that range.&n; *&n; *  Returns &gt;= &squot;size&squot; if no zero bits are found in the range.&n; *&n; *  Accesses memory in 32-bit aligned chunks of 32-bits and thus&n; *  may read beyond the &squot;size&squot;th bit.&n; */
DECL|function|hfs_find_zero_bit
id|hfs_u32
id|hfs_find_zero_bit
c_func
(paren
r_const
id|hfs_u32
op_star
id|start
comma
id|hfs_u32
id|size
comma
id|hfs_u32
id|offset
)paren
(brace
r_const
id|hfs_u32
op_star
id|end
op_assign
id|start
op_plus
(paren
(paren
id|size
op_plus
l_int|31
)paren
op_rshift
l_int|5
)paren
suffix:semicolon
r_const
id|hfs_u32
op_star
id|curr
op_assign
id|start
op_plus
(paren
id|offset
op_rshift
l_int|5
)paren
suffix:semicolon
r_int
id|bit
op_assign
id|offset
op_mod
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
id|size
)paren
(brace
multiline_comment|/* scan the first partial hfs_u32 for zero bits */
r_if
c_cond
(paren
id|bit
op_ne
l_int|0
)paren
(brace
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|hfs_test_bit
c_func
(paren
id|bit
comma
id|curr
)paren
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
op_increment
id|bit
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bit
OL
l_int|32
)paren
suffix:semicolon
id|bit
op_assign
l_int|0
suffix:semicolon
op_increment
id|curr
suffix:semicolon
)brace
multiline_comment|/* scan complete hfs_u32s for the first zero bit */
r_while
c_loop
(paren
id|curr
OL
id|end
)paren
(brace
r_if
c_cond
(paren
op_star
id|curr
op_eq
op_complement
(paren
(paren
id|hfs_u32
)paren
l_int|0
)paren
)paren
(brace
op_increment
id|curr
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
id|hfs_test_bit
c_func
(paren
id|bit
comma
id|curr
)paren
)paren
(brace
op_increment
id|bit
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|done
suffix:colon
id|bit
op_or_assign
(paren
id|curr
op_minus
id|start
)paren
op_lshift
l_int|5
suffix:semicolon
r_return
id|bit
suffix:semicolon
)brace
r_else
(brace
r_return
id|size
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * hfs_count_zero_bits()&n; *&n; * Description:&n; *  Given a block of memory, its length in bits, and a starting bit number,&n; *  determine the number of consecutive zero bits (in left-to-right ordering)&n; *  in that range.&n; *&n; *  Accesses memory in 32-bit aligned chunks of 32-bits and thus&n; *  may read beyond the &squot;size&squot;th bit.&n; */
DECL|function|hfs_count_zero_bits
id|hfs_u32
id|hfs_count_zero_bits
c_func
(paren
r_const
id|hfs_u32
op_star
id|start
comma
id|hfs_u32
id|size
comma
id|hfs_u32
id|offset
)paren
(brace
r_const
id|hfs_u32
op_star
id|end
op_assign
id|start
op_plus
(paren
(paren
id|size
op_plus
l_int|31
)paren
op_rshift
l_int|5
)paren
suffix:semicolon
r_const
id|hfs_u32
op_star
id|curr
op_assign
id|start
op_plus
(paren
id|offset
op_rshift
l_int|5
)paren
suffix:semicolon
r_int
id|bit
op_assign
id|offset
op_mod
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
id|size
)paren
(brace
multiline_comment|/* scan the first partial hfs_u32 for one bits */
r_if
c_cond
(paren
id|bit
op_ne
l_int|0
)paren
(brace
r_do
(brace
r_if
c_cond
(paren
id|hfs_test_bit
c_func
(paren
id|bit
comma
id|curr
)paren
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
op_increment
id|bit
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bit
OL
l_int|32
)paren
suffix:semicolon
id|bit
op_assign
l_int|0
suffix:semicolon
op_increment
id|curr
suffix:semicolon
)brace
multiline_comment|/* scan complete hfs_u32s for the first one bit */
r_while
c_loop
(paren
id|curr
OL
id|end
)paren
(brace
r_if
c_cond
(paren
op_star
id|curr
op_eq
(paren
(paren
id|hfs_u32
)paren
l_int|0
)paren
)paren
(brace
op_increment
id|curr
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
op_logical_neg
id|hfs_test_bit
c_func
(paren
id|bit
comma
id|curr
)paren
)paren
(brace
op_increment
id|bit
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|done
suffix:colon
id|bit
op_or_assign
(paren
id|curr
op_minus
id|start
)paren
op_lshift
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|bit
OG
id|size
)paren
(brace
id|bit
op_assign
id|size
suffix:semicolon
)brace
r_return
id|bit
op_minus
id|offset
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
eof
