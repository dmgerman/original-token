multiline_comment|/*&n; * linux/fs/hfs/binsert.c&n; *&n; * Copyright (C) 1995-1997  Paul H. Hargrove&n; * This file may be distributed under the terms of the GNU Public License.&n; *&n; * This file contains the code to insert records in a B-tree.&n; *&n; * &quot;XXX&quot; in a comment is a note to myself to consider changing something.&n; *&n; * In function preconditions the term &quot;valid&quot; applied to a pointer to&n; * a structure means that the pointer is non-NULL and the structure it&n; * points to has all fields initialized to consistent values.&n; */
macro_line|#include &quot;hfs_btree.h&quot;
multiline_comment|/*================ File-local functions ================*/
multiline_comment|/* btree locking functions */
DECL|function|hfs_btree_lock
r_static
r_inline
r_void
id|hfs_btree_lock
c_func
(paren
r_struct
id|hfs_btree
op_star
id|tree
)paren
(brace
r_while
c_loop
(paren
id|tree-&gt;lock
)paren
id|hfs_sleep_on
c_func
(paren
op_amp
id|tree-&gt;wait
)paren
suffix:semicolon
id|tree-&gt;lock
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|hfs_btree_unlock
r_static
r_inline
r_void
id|hfs_btree_unlock
c_func
(paren
r_struct
id|hfs_btree
op_star
id|tree
)paren
(brace
id|tree-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|hfs_wake_up
c_func
(paren
op_amp
id|tree-&gt;wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * binsert_nonfull()&n; *&n; * Description:&n; *   Inserts a record in a given bnode known to have sufficient space.&n; * Input Variable(s):&n; *   struct hfs_brec* brec: pointer to the brec for the insertion&n; *   struct hfs_belem* belem: the element in the search path to insert in&n; *   struct hfs_bkey* key: pointer to the key for the record to insert&n; *   void* data: pointer to the record to insert&n; *   hfs_u16 keysize: size of the key to insert&n; *   hfs_u16 datasize: size of the record to insert&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   NONE&n; * Preconditions:&n; *   &squot;brec&squot; points to a valid (struct hfs_brec).&n; *   &squot;belem&squot; points to a valid (struct hfs_belem) in &squot;brec&squot;, the node&n; *    of which has enough free space to insert &squot;key&squot; and &squot;data&squot;.&n; *   &squot;key&squot; is a pointer to a valid (struct hfs_bkey) of length &squot;keysize&squot;&n; *    which, in sorted order, belongs at the location indicated by &squot;brec&squot;.&n; *   &squot;data&squot; is non-NULL an points to appropriate data of length &squot;datasize&squot;&n; * Postconditions:&n; *   The record has been inserted in the position indicated by &squot;brec&squot;.&n; */
DECL|function|binsert_nonfull
r_static
r_void
id|binsert_nonfull
c_func
(paren
r_struct
id|hfs_brec
op_star
id|brec
comma
r_struct
id|hfs_belem
op_star
id|belem
comma
r_const
r_struct
id|hfs_bkey
op_star
id|key
comma
r_const
r_void
op_star
id|data
comma
id|hfs_u8
id|keysize
comma
id|hfs_u16
id|datasize
)paren
(brace
r_int
id|i
comma
id|rec
comma
id|nrecs
comma
id|size
comma
id|tomove
suffix:semicolon
id|hfs_u8
op_star
id|start
suffix:semicolon
r_struct
id|hfs_bnode
op_star
id|bnode
op_assign
id|belem-&gt;bnr.bn
suffix:semicolon
id|rec
op_assign
op_increment
(paren
id|belem-&gt;record
)paren
suffix:semicolon
id|size
op_assign
id|ROUND
c_func
(paren
id|keysize
op_plus
l_int|1
)paren
op_plus
id|datasize
suffix:semicolon
id|nrecs
op_assign
id|bnode-&gt;ndNRecs
op_plus
l_int|1
suffix:semicolon
id|tomove
op_assign
id|bnode_offset
c_func
(paren
id|bnode
comma
id|nrecs
)paren
op_minus
id|bnode_offset
c_func
(paren
id|bnode
comma
id|rec
)paren
suffix:semicolon
multiline_comment|/* adjust the record table */
r_for
c_loop
(paren
id|i
op_assign
id|nrecs
suffix:semicolon
id|i
op_ge
id|rec
suffix:semicolon
op_decrement
id|i
)paren
(brace
id|hfs_put_hs
c_func
(paren
id|bnode_offset
c_func
(paren
id|bnode
comma
id|i
)paren
op_plus
id|size
comma
id|RECTBL
c_func
(paren
id|bnode
comma
id|i
op_plus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* make room */
id|start
op_assign
id|bnode_key
c_func
(paren
id|bnode
comma
id|rec
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|start
op_plus
id|size
comma
id|start
comma
id|tomove
)paren
suffix:semicolon
multiline_comment|/* copy in the key and the data*/
op_star
id|start
op_assign
id|keysize
suffix:semicolon
id|keysize
op_assign
id|ROUND
c_func
(paren
id|keysize
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|start
op_plus
l_int|1
comma
(paren
id|hfs_u8
op_star
)paren
id|key
op_plus
l_int|1
comma
id|keysize
op_minus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|start
op_plus
id|keysize
comma
id|data
comma
id|datasize
)paren
suffix:semicolon
multiline_comment|/* update record count */
op_increment
id|bnode-&gt;ndNRecs
suffix:semicolon
)brace
multiline_comment|/*&n; * add_root()&n; *&n; * Description:&n; *   Adds a new root to a B*-tree, increasing its height.&n; * Input Variable(s):&n; *   struct hfs_btree *tree: the tree to add a new root to&n; *   struct hfs_bnode *left: the new root&squot;s first child or NULL&n; *   struct hfs_bnode *right: the new root&squot;s second child or NULL&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   void&n; * Preconditions:&n; *   &squot;tree&squot; points to a valid (struct hfs_btree).&n; *   &squot;left&squot; and &squot;right&squot; point to valid (struct hfs_bnode)s, which&n; *    resulted from splitting the old root node, or are both NULL&n; *    if there was no root node before.&n; * Postconditions:&n; *   Upon success a new root node is added to &squot;tree&squot; with either&n; *    two children (&squot;left&squot; and &squot;right&squot;) or none.&n; */
DECL|function|add_root
r_static
r_void
id|add_root
c_func
(paren
r_struct
id|hfs_btree
op_star
id|tree
comma
r_struct
id|hfs_bnode
op_star
id|left
comma
r_struct
id|hfs_bnode
op_star
id|right
)paren
(brace
r_struct
id|hfs_bnode_ref
id|bnr
suffix:semicolon
r_struct
id|hfs_bnode
op_star
id|root
suffix:semicolon
r_struct
id|hfs_bkey
op_star
id|key
suffix:semicolon
r_int
id|keylen
op_assign
id|tree-&gt;bthKeyLen
suffix:semicolon
r_if
c_cond
(paren
id|left
op_logical_and
op_logical_neg
id|right
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;add_root: LEFT but no RIGHT&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|bnr
op_assign
id|hfs_bnode_alloc
c_func
(paren
id|tree
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|root
op_assign
id|bnr.bn
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|root-&gt;sticky
op_assign
id|HFS_STICKY
suffix:semicolon
id|tree-&gt;root
op_assign
id|root
suffix:semicolon
id|tree-&gt;bthRoot
op_assign
id|root-&gt;node
suffix:semicolon
op_increment
id|tree-&gt;bthDepth
suffix:semicolon
id|root-&gt;ndNHeight
op_assign
id|tree-&gt;bthDepth
suffix:semicolon
id|root-&gt;ndFLink
op_assign
l_int|0
suffix:semicolon
id|root-&gt;ndBLink
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|left
)paren
(brace
multiline_comment|/* tree was empty */
id|root-&gt;ndType
op_assign
id|ndLeafNode
suffix:semicolon
id|root-&gt;ndNRecs
op_assign
l_int|0
suffix:semicolon
id|tree-&gt;bthFNode
op_assign
id|root-&gt;node
suffix:semicolon
id|tree-&gt;bthLNode
op_assign
id|root-&gt;node
suffix:semicolon
)brace
r_else
(brace
id|root-&gt;ndType
op_assign
id|ndIndxNode
suffix:semicolon
id|root-&gt;ndNRecs
op_assign
l_int|2
suffix:semicolon
id|hfs_put_hs
c_func
(paren
r_sizeof
(paren
r_struct
id|NodeDescriptor
)paren
op_plus
id|ROUND
c_func
(paren
l_int|1
op_plus
id|keylen
)paren
op_plus
r_sizeof
(paren
id|hfs_u32
)paren
comma
id|RECTBL
c_func
(paren
id|root
comma
l_int|2
)paren
)paren
suffix:semicolon
id|key
op_assign
id|bnode_key
c_func
(paren
id|root
comma
l_int|1
)paren
suffix:semicolon
id|key-&gt;KeyLen
op_assign
id|keylen
suffix:semicolon
id|memcpy
c_func
(paren
id|key-&gt;value
comma
(paren
(paren
r_struct
id|hfs_bkey
op_star
)paren
id|bnode_key
c_func
(paren
id|left
comma
l_int|1
)paren
)paren
op_member_access_from_pointer
id|value
comma
id|keylen
)paren
suffix:semicolon
id|hfs_put_hl
c_func
(paren
id|left-&gt;node
comma
id|bkey_record
c_func
(paren
id|key
)paren
)paren
suffix:semicolon
id|hfs_put_hs
c_func
(paren
r_sizeof
(paren
r_struct
id|NodeDescriptor
)paren
op_plus
l_int|2
op_star
id|ROUND
c_func
(paren
l_int|1
op_plus
id|keylen
)paren
op_plus
l_int|2
op_star
r_sizeof
(paren
id|hfs_u32
)paren
comma
id|RECTBL
c_func
(paren
id|root
comma
l_int|3
)paren
)paren
suffix:semicolon
id|key
op_assign
id|bnode_key
c_func
(paren
id|root
comma
l_int|2
)paren
suffix:semicolon
id|key-&gt;KeyLen
op_assign
id|keylen
suffix:semicolon
id|memcpy
c_func
(paren
id|key-&gt;value
comma
(paren
(paren
r_struct
id|hfs_bkey
op_star
)paren
id|bnode_key
c_func
(paren
id|right
comma
l_int|1
)paren
)paren
op_member_access_from_pointer
id|value
comma
id|keylen
)paren
suffix:semicolon
id|hfs_put_hl
c_func
(paren
id|right-&gt;node
comma
id|bkey_record
c_func
(paren
id|key
)paren
)paren
suffix:semicolon
multiline_comment|/* the former root (left) is now just a normal node */
id|left-&gt;sticky
op_assign
id|HFS_NOT_STICKY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|left-&gt;next
op_assign
id|bhash
c_func
(paren
id|tree
comma
id|left-&gt;node
)paren
)paren
)paren
(brace
id|left-&gt;next-&gt;prev
op_assign
id|left
suffix:semicolon
)brace
id|bhash
c_func
(paren
id|tree
comma
id|left-&gt;node
)paren
op_assign
id|left
suffix:semicolon
)brace
id|hfs_bnode_relse
c_func
(paren
op_amp
id|bnr
)paren
suffix:semicolon
id|tree-&gt;dirt
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * insert_empty_bnode()&n; *&n; * Description:&n; *   Adds an empty node to the right of &squot;left&squot;.&n; * Input Variable(s):&n; *   struct hfs_btree *tree: the tree to add a node to&n; *   struct hfs_bnode *left: the node to add a node after&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   struct hfs_bnode_ref *: reference to the new bnode.&n; * Preconditions:&n; *   &squot;tree&squot; points to a valid (struct hfs_btree) with at least 1 free node.&n; *   &squot;left&squot; points to a valid (struct hfs_bnode) belonging to &squot;tree&squot;.&n; * Postconditions:&n; *   If NULL is returned then &squot;tree&squot; and &squot;left&squot; are unchanged.&n; *   Otherwise a node with 0 records is inserted in the tree to the right&n; *   of the node &squot;left&squot;.  The &squot;ndFLink&squot; of &squot;left&squot; and the &squot;ndBLink&squot; of&n; *   the former right-neighbor of &squot;left&squot; (if one existed) point to the&n; *   new node.&t;If &squot;left&squot; had no right neighbor and is a leaf node the&n; *   the &squot;bthLNode&squot; of &squot;tree&squot; points to the new node.  The free-count and&n; *   bitmap for &squot;tree&squot; are kept current by hfs_bnode_alloc() which supplies&n; *   the required node.&n; */
DECL|function|insert_empty_bnode
r_static
r_struct
id|hfs_bnode_ref
id|insert_empty_bnode
c_func
(paren
r_struct
id|hfs_btree
op_star
id|tree
comma
r_struct
id|hfs_bnode
op_star
id|left
)paren
(brace
r_struct
id|hfs_bnode_ref
id|retval
suffix:semicolon
r_struct
id|hfs_bnode_ref
id|right
suffix:semicolon
id|retval
op_assign
id|hfs_bnode_alloc
c_func
(paren
id|tree
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval.bn
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_binsert: out of bnodes?.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|retval.bn-&gt;sticky
op_assign
id|HFS_NOT_STICKY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval.bn-&gt;next
op_assign
id|bhash
c_func
(paren
id|tree
comma
id|retval.bn-&gt;node
)paren
)paren
)paren
(brace
id|retval.bn-&gt;next-&gt;prev
op_assign
id|retval.bn
suffix:semicolon
)brace
id|bhash
c_func
(paren
id|tree
comma
id|retval.bn-&gt;node
)paren
op_assign
id|retval.bn
suffix:semicolon
r_if
c_cond
(paren
id|left-&gt;ndFLink
)paren
(brace
id|right
op_assign
id|hfs_bnode_find
c_func
(paren
id|tree
comma
id|left-&gt;ndFLink
comma
id|HFS_LOCK_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|right.bn
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_binsert: corrupt btree.&bslash;n&quot;
)paren
suffix:semicolon
id|hfs_bnode_bitop
c_func
(paren
id|tree
comma
id|retval.bn-&gt;node
comma
l_int|0
)paren
suffix:semicolon
id|hfs_bnode_relse
c_func
(paren
op_amp
id|retval
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|right.bn-&gt;ndBLink
op_assign
id|retval.bn-&gt;node
suffix:semicolon
id|hfs_bnode_relse
c_func
(paren
op_amp
id|right
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|left-&gt;ndType
op_eq
id|ndLeafNode
)paren
(brace
id|tree-&gt;bthLNode
op_assign
id|retval.bn-&gt;node
suffix:semicolon
id|tree-&gt;dirt
op_assign
l_int|1
suffix:semicolon
)brace
id|retval.bn-&gt;ndFLink
op_assign
id|left-&gt;ndFLink
suffix:semicolon
id|retval.bn-&gt;ndBLink
op_assign
id|left-&gt;node
suffix:semicolon
id|retval.bn-&gt;ndType
op_assign
id|left-&gt;ndType
suffix:semicolon
id|retval.bn-&gt;ndNHeight
op_assign
id|left-&gt;ndNHeight
suffix:semicolon
id|retval.bn-&gt;ndNRecs
op_assign
l_int|0
suffix:semicolon
id|left-&gt;ndFLink
op_assign
id|retval.bn-&gt;node
suffix:semicolon
id|done
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * split()&n; *&n; * Description:&n; *   Splits an over full node during insertion.&n; *   Picks the split point that results in the most-nearly equal&n; *   space usage in the new and old nodes.&n; * Input Variable(s):&n; *   struct hfs_belem *elem: the over full node.&n; *   int size: the number of bytes to be used by the new record and its key.&n; * Output Variable(s):&n; *   struct hfs_belem *elem: changed to indicate where the new record&n; *    should be inserted.&n; * Returns:&n; *   struct hfs_bnode_ref: reference to the new bnode.&n; * Preconditions:&n; *   &squot;elem&squot; points to a valid path element corresponding to the over full node.&n; *   &squot;size&squot; is positive.&n; * Postconditions:&n; *   The records in the node corresponding to &squot;elem&squot; are redistributed across&n; *   the old and new nodes so that after inserting the new record, the space&n; *   usage in these two nodes is as equal as possible.&n; *   &squot;elem&squot; is updated so that a call to binsert_nonfull() will insert the&n; *   new record in the correct location.&n; */
DECL|function|split
r_static
r_inline
r_struct
id|hfs_bnode_ref
id|split
c_func
(paren
r_struct
id|hfs_belem
op_star
id|elem
comma
r_int
id|size
)paren
(brace
r_struct
id|hfs_bnode
op_star
id|bnode
op_assign
id|elem-&gt;bnr.bn
suffix:semicolon
r_int
id|nrecs
comma
id|cutoff
comma
id|index
comma
id|tmp
comma
id|used
comma
id|in_right
suffix:semicolon
r_struct
id|hfs_bnode_ref
id|right
suffix:semicolon
id|right
op_assign
id|insert_empty_bnode
c_func
(paren
id|bnode-&gt;tree
comma
id|bnode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|right.bn
)paren
(brace
id|nrecs
op_assign
id|bnode-&gt;ndNRecs
suffix:semicolon
id|cutoff
op_assign
(paren
id|size
op_plus
id|bnode_end
c_func
(paren
id|bnode
)paren
op_minus
r_sizeof
(paren
r_struct
id|NodeDescriptor
)paren
op_plus
(paren
id|nrecs
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|hfs_u16
)paren
)paren
op_div
l_int|2
suffix:semicolon
id|used
op_assign
l_int|0
suffix:semicolon
id|in_right
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* note that this only works because records sizes are even */
r_for
c_loop
(paren
id|index
op_assign
l_int|1
suffix:semicolon
id|index
op_le
id|elem-&gt;record
suffix:semicolon
op_increment
id|index
)paren
(brace
id|tmp
op_assign
(paren
r_sizeof
(paren
id|hfs_u16
)paren
op_plus
id|bnode_rsize
c_func
(paren
id|bnode
comma
id|index
)paren
)paren
op_div
l_int|2
suffix:semicolon
id|used
op_add_assign
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|used
OG
id|cutoff
)paren
(brace
r_goto
id|found
suffix:semicolon
)brace
id|used
op_add_assign
id|tmp
suffix:semicolon
)brace
id|tmp
op_assign
(paren
id|size
op_plus
r_sizeof
(paren
id|hfs_u16
)paren
)paren
op_div
l_int|2
suffix:semicolon
id|used
op_add_assign
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|used
OG
id|cutoff
)paren
(brace
r_goto
id|found
suffix:semicolon
)brace
id|in_right
op_assign
l_int|0
suffix:semicolon
id|used
op_add_assign
id|tmp
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|index
op_le
id|nrecs
suffix:semicolon
op_increment
id|index
)paren
(brace
id|tmp
op_assign
(paren
r_sizeof
(paren
id|hfs_u16
)paren
op_plus
id|bnode_rsize
c_func
(paren
id|bnode
comma
id|index
)paren
)paren
op_div
l_int|2
suffix:semicolon
id|used
op_add_assign
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|used
OG
id|cutoff
)paren
(brace
r_goto
id|found
suffix:semicolon
)brace
id|used
op_add_assign
id|tmp
suffix:semicolon
)brace
multiline_comment|/* couldn&squot;t find the split point! */
id|hfs_bnode_relse
c_func
(paren
op_amp
id|right
)paren
suffix:semicolon
)brace
r_return
id|right
suffix:semicolon
id|found
suffix:colon
r_if
c_cond
(paren
id|in_right
)paren
(brace
id|elem-&gt;bnr
op_assign
id|right
suffix:semicolon
id|elem-&gt;record
op_sub_assign
id|index
op_minus
l_int|1
suffix:semicolon
)brace
id|hfs_bnode_shift_right
c_func
(paren
id|bnode
comma
id|right.bn
comma
id|index
)paren
suffix:semicolon
r_return
id|right
suffix:semicolon
)brace
multiline_comment|/*&n; * binsert()&n; *&n; * Description:&n; *   Inserts a record in a tree known to have enough room, even if the&n; *   insertion requires the splitting of nodes.&n; * Input Variable(s):&n; *    struct hfs_brec *brec: partial path to the node to insert in&n; *    const struct hfs_bkey *key: key for the new record&n; *    const void *data: data for the new record&n; *    hfs_u8 keysize: size of the key&n; *    hfs_u16 datasize: size of the data&n; *    int reserve: number of nodes reserved in case of splits&n; * Output Variable(s):&n; *    *brec = NULL&n; * Returns:&n; *    int: 0 on success, error code on failure&n; * Preconditions:&n; *    &squot;brec&squot; points to a valid (struct hfs_brec) corresponding to a&n; *     record in a leaf node, after which a record is to be inserted,&n; *     or to &quot;record 0&quot; of the leaf node if the record is to be inserted&n; *     before all existing records in the node.&t; The (struct hfs_brec)&n; *     includes all ancestors of the leaf node that are needed to&n; *     complete the insertion including the parents of any nodes that&n; *     will be split.&n; *    &squot;key&squot; points to a valid (struct hfs_bkey) which is appropriate&n; *     to this tree, and which belongs at the insertion point.&n; *    &squot;data&squot; points data appropriate for the indicated node.&n; *    &squot;keysize&squot; gives the size in bytes of the key.&n; *    &squot;datasize&squot; gives the size in bytes of the data.&n; *    &squot;reserve&squot; gives the number of nodes that have been reserved in the&n; *     tree to allow for splitting of nodes.&n; * Postconditions:&n; *    All &squot;reserve&squot;d nodes have been either used or released.&n; *    *brec = NULL&n; *    On success the key and data have been inserted at the indicated&n; *    location in the tree, all appropriate fields of the in-core data&n; *    structures have been changed and updated versions of the on-disk&n; *    data structures have been scheduled for write-back to disk.&n; *    On failure the B*-tree is probably invalid both on disk and in-core.&n; *&n; *    XXX: Some attempt at repair might be made in the event of failure,&n; *    or the fs should be remounted read-only so things don&squot;t get worse.&n; */
DECL|function|binsert
r_static
r_int
id|binsert
c_func
(paren
r_struct
id|hfs_brec
op_star
id|brec
comma
r_const
r_struct
id|hfs_bkey
op_star
id|key
comma
r_const
r_void
op_star
id|data
comma
id|hfs_u8
id|keysize
comma
id|hfs_u16
id|datasize
comma
r_int
id|reserve
)paren
(brace
r_struct
id|hfs_bnode_ref
id|left
comma
id|right
comma
id|other
suffix:semicolon
r_struct
id|hfs_btree
op_star
id|tree
op_assign
id|brec-&gt;tree
suffix:semicolon
r_struct
id|hfs_belem
op_star
id|belem
op_assign
id|brec-&gt;bottom
suffix:semicolon
r_int
id|tmpsize
op_assign
l_int|1
op_plus
id|tree-&gt;bthKeyLen
suffix:semicolon
r_struct
id|hfs_bkey
op_star
id|tmpkey
op_assign
id|hfs_malloc
c_func
(paren
id|tmpsize
)paren
suffix:semicolon
id|hfs_u32
id|node
suffix:semicolon
r_while
c_loop
(paren
(paren
id|belem
op_ge
id|brec-&gt;top
)paren
op_logical_and
(paren
id|belem-&gt;flags
op_amp
id|HFS_BPATH_OVERFLOW
)paren
)paren
(brace
id|left
op_assign
id|belem-&gt;bnr
suffix:semicolon
r_if
c_cond
(paren
id|left.bn-&gt;ndFLink
op_logical_and
id|hfs_bnode_in_brec
c_func
(paren
id|left.bn-&gt;ndFLink
comma
id|brec
)paren
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_binsert: corrupt btree&bslash;n&quot;
)paren
suffix:semicolon
id|tree-&gt;reserved
op_sub_assign
id|reserve
suffix:semicolon
id|hfs_free
c_func
(paren
id|tmpkey
comma
id|tmpsize
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|right
op_assign
id|split
c_func
(paren
id|belem
comma
id|ROUND
c_func
(paren
id|keysize
op_plus
l_int|1
)paren
op_plus
id|ROUND
c_func
(paren
id|datasize
)paren
)paren
suffix:semicolon
op_decrement
id|reserve
suffix:semicolon
op_decrement
id|tree-&gt;reserved
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|right.bn
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_binsert: unable to split node!&bslash;n&quot;
)paren
suffix:semicolon
id|tree-&gt;reserved
op_sub_assign
id|reserve
suffix:semicolon
id|hfs_free
c_func
(paren
id|tmpkey
comma
id|tmpsize
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
id|binsert_nonfull
c_func
(paren
id|brec
comma
id|belem
comma
id|key
comma
id|data
comma
id|keysize
comma
id|datasize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|belem-&gt;bnr.bn
op_eq
id|left.bn
)paren
(brace
id|other
op_assign
id|right
suffix:semicolon
r_if
c_cond
(paren
id|belem-&gt;record
op_eq
l_int|1
)paren
(brace
id|hfs_bnode_update_key
c_func
(paren
id|brec
comma
id|belem
comma
id|left.bn
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|other
op_assign
id|left
suffix:semicolon
)brace
r_if
c_cond
(paren
id|left.bn-&gt;node
op_eq
id|tree-&gt;root-&gt;node
)paren
(brace
id|add_root
c_func
(paren
id|tree
comma
id|left.bn
comma
id|right.bn
)paren
suffix:semicolon
id|hfs_bnode_relse
c_func
(paren
op_amp
id|other
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|data
op_assign
op_amp
id|node
suffix:semicolon
id|datasize
op_assign
r_sizeof
(paren
id|node
)paren
suffix:semicolon
id|node
op_assign
id|htonl
c_func
(paren
id|right.bn-&gt;node
)paren
suffix:semicolon
id|key
op_assign
id|tmpkey
suffix:semicolon
id|keysize
op_assign
id|tree-&gt;bthKeyLen
suffix:semicolon
id|memcpy
c_func
(paren
id|tmpkey
comma
id|bnode_key
c_func
(paren
id|right.bn
comma
l_int|1
)paren
comma
id|keysize
op_plus
l_int|1
)paren
suffix:semicolon
id|hfs_bnode_relse
c_func
(paren
op_amp
id|other
)paren
suffix:semicolon
op_decrement
id|belem
suffix:semicolon
)brace
r_if
c_cond
(paren
id|belem
OL
id|brec-&gt;top
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_binsert: Missing parent.&bslash;n&quot;
)paren
suffix:semicolon
id|tree-&gt;reserved
op_sub_assign
id|reserve
suffix:semicolon
id|hfs_free
c_func
(paren
id|tmpkey
comma
id|tmpsize
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|binsert_nonfull
c_func
(paren
id|brec
comma
id|belem
comma
id|key
comma
id|data
comma
id|keysize
comma
id|datasize
)paren
suffix:semicolon
id|done
suffix:colon
id|tree-&gt;reserved
op_sub_assign
id|reserve
suffix:semicolon
id|hfs_free
c_func
(paren
id|tmpkey
comma
id|tmpsize
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*================ Global functions ================*/
multiline_comment|/*&n; * hfs_binsert()&n; *&n; * Description:&n; *   This function inserts a new record into a b-tree.&n; * Input Variable(s):&n; *   struct hfs_btree *tree: pointer to the (struct hfs_btree) to insert in&n; *   struct hfs_bkey *key: pointer to the (struct hfs_bkey) to insert&n; *   void *data: pointer to the data to associate with &squot;key&squot; in the b-tree&n; *   unsigned int datasize: the size of the data&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   int: 0 on success, error code on failure&n; * Preconditions:&n; *   &squot;tree&squot; points to a valid (struct hfs_btree)&n; *   &squot;key&squot; points to a valid (struct hfs_bkey)&n; *   &squot;data&squot; points to valid memory of length &squot;datasize&squot;&n; * Postconditions:&n; *   If zero is returned then the record has been inserted in the&n; *    indicated location updating all in-core data structures and&n; *    scheduling all on-disk data structures for write-back.&n; */
DECL|function|hfs_binsert
r_int
id|hfs_binsert
c_func
(paren
r_struct
id|hfs_btree
op_star
id|tree
comma
r_const
r_struct
id|hfs_bkey
op_star
id|key
comma
r_const
r_void
op_star
id|data
comma
id|hfs_u16
id|datasize
)paren
(brace
r_struct
id|hfs_brec
id|brec
suffix:semicolon
r_struct
id|hfs_belem
op_star
id|belem
suffix:semicolon
r_int
id|err
comma
id|reserve
comma
id|retval
suffix:semicolon
id|hfs_u8
id|keysize
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tree
op_logical_or
(paren
id|tree-&gt;magic
op_ne
id|HFS_BTREE_MAGIC
)paren
op_logical_or
op_logical_neg
id|key
op_logical_or
op_logical_neg
id|data
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_binsert: invalid arguments.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|key-&gt;KeyLen
OG
id|tree-&gt;bthKeyLen
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_binsert: oversized key&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|restart
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tree-&gt;bthNRecs
)paren
(brace
multiline_comment|/* create the root bnode */
id|add_root
c_func
(paren
id|tree
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hfs_brec_init
c_func
(paren
op_amp
id|brec
comma
id|tree
comma
id|HFS_BFIND_INSERT
)paren
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_binsert: failed to create root.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
)brace
r_else
(brace
id|err
op_assign
id|hfs_bfind
c_func
(paren
op_amp
id|brec
comma
id|tree
comma
id|key
comma
id|HFS_BFIND_INSERT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_binsert: hfs_brec_find failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
(brace
id|hfs_brec_relse
c_func
(paren
op_amp
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
)brace
id|keysize
op_assign
id|key-&gt;KeyLen
suffix:semicolon
id|datasize
op_assign
id|ROUND
c_func
(paren
id|datasize
)paren
suffix:semicolon
id|belem
op_assign
id|brec.bottom
suffix:semicolon
id|belem-&gt;flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bnode_freespace
c_func
(paren
id|belem-&gt;bnr.bn
)paren
OL
(paren
r_sizeof
(paren
id|hfs_u16
)paren
op_plus
id|ROUND
c_func
(paren
id|keysize
op_plus
l_int|1
)paren
op_plus
id|datasize
)paren
)paren
(brace
id|belem-&gt;flags
op_or_assign
id|HFS_BPATH_OVERFLOW
suffix:semicolon
)brace
r_if
c_cond
(paren
id|belem-&gt;record
op_eq
l_int|0
)paren
(brace
id|belem-&gt;flags
op_or_assign
id|HFS_BPATH_FIRST
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|belem-&gt;flags
)paren
(brace
id|hfs_brec_lock
c_func
(paren
op_amp
id|brec
comma
id|brec.bottom
)paren
suffix:semicolon
id|reserve
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|reserve
op_assign
id|brec.bottom
op_minus
id|brec.top
suffix:semicolon
r_if
c_cond
(paren
id|brec.top
op_eq
l_int|0
)paren
(brace
op_increment
id|reserve
suffix:semicolon
)brace
multiline_comment|/* make certain we have enough nodes to proceed */
r_if
c_cond
(paren
(paren
id|tree-&gt;bthFree
op_minus
id|tree-&gt;reserved
)paren
OL
id|reserve
)paren
(brace
id|hfs_brec_relse
c_func
(paren
op_amp
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
id|hfs_btree_lock
c_func
(paren
id|tree
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tree-&gt;bthFree
op_minus
id|tree-&gt;reserved
)paren
OL
id|reserve
)paren
(brace
id|hfs_btree_extend
c_func
(paren
id|tree
)paren
suffix:semicolon
)brace
id|hfs_btree_unlock
c_func
(paren
id|tree
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tree-&gt;bthFree
op_minus
id|tree-&gt;reserved
)paren
OL
id|reserve
)paren
(brace
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_else
(brace
r_goto
id|restart
suffix:semicolon
)brace
)brace
id|tree-&gt;reserved
op_add_assign
id|reserve
suffix:semicolon
id|hfs_brec_lock
c_func
(paren
op_amp
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|retval
op_assign
id|binsert
c_func
(paren
op_amp
id|brec
comma
id|key
comma
id|data
comma
id|keysize
comma
id|datasize
comma
id|reserve
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
op_amp
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
(brace
op_increment
id|tree-&gt;bthNRecs
suffix:semicolon
id|tree-&gt;dirt
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
eof
