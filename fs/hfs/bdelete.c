multiline_comment|/*&n; * linux/fs/hfs/bdelete.c&n; *&n; * Copyright (C) 1995-1997  Paul H. Hargrove&n; * This file may be distributed under the terms of the GNU Public License.&n; *&n; * This file contains the code to delete records in a B-tree.&n; *&n; * &quot;XXX&quot; in a comment is a note to myself to consider changing something.&n; *&n; * In function preconditions the term &quot;valid&quot; applied to a pointer to&n; * a structure means that the pointer is non-NULL and the structure it&n; * points to has all fields initialized to consistent values.&n; */
macro_line|#include &quot;hfs_btree.h&quot;
multiline_comment|/*================ Variable-like macros ================*/
DECL|macro|FULL
mdefine_line|#define FULL (HFS_SECTOR_SIZE - sizeof(struct NodeDescriptor))
DECL|macro|NO_SPACE
mdefine_line|#define NO_SPACE (HFS_SECTOR_SIZE+1)
multiline_comment|/*================ File-local functions ================*/
multiline_comment|/*&n; * bdelete_nonempty()&n; *&n; * Description:&n; *   Deletes a record from a given bnode without regard to it becoming empty.&n; * Input Variable(s):&n; *   struct hfs_brec* brec: pointer to the brec for the deletion&n; *   struct hfs_belem* belem: which node in &squot;brec&squot; to delete from&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   void&n; * Preconditions:&n; *   &squot;brec&squot; points to a valid (struct hfs_brec).&n; *   &squot;belem&squot; points to a valid (struct hfs_belem) in &squot;brec&squot;.&n; * Postconditions:&n; *   The record has been inserted in the position indicated by &squot;brec&squot;.&n; */
DECL|function|bdelete_nonempty
r_static
r_void
id|bdelete_nonempty
c_func
(paren
r_struct
id|hfs_brec
op_star
id|brec
comma
r_struct
id|hfs_belem
op_star
id|belem
)paren
(brace
r_int
id|i
comma
id|rec
comma
id|nrecs
comma
id|tomove
suffix:semicolon
id|hfs_u16
id|size
suffix:semicolon
id|hfs_u8
op_star
id|start
suffix:semicolon
r_struct
id|hfs_bnode
op_star
id|bnode
op_assign
id|belem-&gt;bnr.bn
suffix:semicolon
id|rec
op_assign
id|belem-&gt;record
suffix:semicolon
id|nrecs
op_assign
id|bnode-&gt;ndNRecs
suffix:semicolon
id|size
op_assign
id|bnode_rsize
c_func
(paren
id|bnode
comma
id|rec
)paren
suffix:semicolon
id|tomove
op_assign
id|bnode_offset
c_func
(paren
id|bnode
comma
id|nrecs
op_plus
l_int|1
)paren
op_minus
id|bnode_offset
c_func
(paren
id|bnode
comma
id|rec
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* adjust the record table */
r_for
c_loop
(paren
id|i
op_assign
id|rec
op_plus
l_int|1
suffix:semicolon
id|i
op_le
id|nrecs
suffix:semicolon
op_increment
id|i
)paren
(brace
id|hfs_put_hs
c_func
(paren
id|bnode_offset
c_func
(paren
id|bnode
comma
id|i
op_plus
l_int|1
)paren
op_minus
id|size
comma
id|RECTBL
c_func
(paren
id|bnode
comma
id|i
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* move it down */
id|start
op_assign
id|bnode_key
c_func
(paren
id|bnode
comma
id|rec
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|start
comma
id|start
op_plus
id|size
comma
id|tomove
)paren
suffix:semicolon
multiline_comment|/* update record count */
op_decrement
id|bnode-&gt;ndNRecs
suffix:semicolon
)brace
multiline_comment|/*&n; * del_root()&n; *&n; * Description:&n; *   Delete the current root bnode.&n; * Input Variable(s):&n; *   struct hfs_bnode_ref *root: reference to the root bnode&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   int: 0 on success, error code on failure&n; * Preconditions:&n; *   &squot;root&squot; refers to the root bnode with HFS_LOCK_WRITE access.&n; *   None of &squot;root&squot;s children are held with HFS_LOCK_WRITE access.&n; * Postconditions:&n; *   The current &squot;root&squot; node is removed from the tree and the depth&n; *    of the tree is reduced by one.&n; *   If &squot;root&squot; is an index node with exactly one child, then that&n; *    child becomes the new root of the tree.&n; *   If &squot;root&squot; is an empty leaf node the tree becomes empty.&n; *   Upon return access to &squot;root&squot; is relinquished.&n; */
DECL|function|del_root
r_static
r_int
id|del_root
c_func
(paren
r_struct
id|hfs_bnode_ref
op_star
id|root
)paren
(brace
r_struct
id|hfs_btree
op_star
id|tree
op_assign
id|root-&gt;bn-&gt;tree
suffix:semicolon
r_struct
id|hfs_bnode_ref
id|child
suffix:semicolon
id|hfs_u32
id|node
suffix:semicolon
r_if
c_cond
(paren
id|root-&gt;bn-&gt;ndNRecs
OG
l_int|1
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|root-&gt;bn-&gt;ndNRecs
op_eq
l_int|0
)paren
(brace
multiline_comment|/* tree is empty */
id|tree-&gt;bthRoot
op_assign
l_int|0
suffix:semicolon
id|tree-&gt;root
op_assign
l_int|NULL
suffix:semicolon
id|tree-&gt;bthRoot
op_assign
l_int|0
suffix:semicolon
id|tree-&gt;bthFNode
op_assign
l_int|0
suffix:semicolon
id|tree-&gt;bthLNode
op_assign
l_int|0
suffix:semicolon
op_decrement
id|tree-&gt;bthDepth
suffix:semicolon
id|tree-&gt;dirt
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tree-&gt;bthDepth
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bdelete: empty tree with bthDepth=%d&bslash;n&quot;
comma
id|tree-&gt;bthDepth
)paren
suffix:semicolon
r_goto
id|bail
suffix:semicolon
)brace
r_return
id|hfs_bnode_free
c_func
(paren
id|root
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|root-&gt;bn-&gt;ndType
op_eq
id|ndIndxNode
)paren
(brace
multiline_comment|/* tree is non-empty */
id|node
op_assign
id|hfs_get_hl
c_func
(paren
id|bkey_record
c_func
(paren
id|bnode_datastart
c_func
(paren
id|root-&gt;bn
)paren
)paren
)paren
suffix:semicolon
id|child
op_assign
id|hfs_bnode_find
c_func
(paren
id|tree
comma
id|node
comma
id|HFS_LOCK_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|child.bn
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bdelete: can&squot;t read child node.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|bail
suffix:semicolon
)brace
id|child.bn-&gt;sticky
op_assign
id|HFS_STICKY
suffix:semicolon
r_if
c_cond
(paren
id|child.bn-&gt;next
)paren
(brace
id|child.bn-&gt;next-&gt;prev
op_assign
id|child.bn-&gt;prev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|child.bn-&gt;prev
)paren
(brace
id|child.bn-&gt;prev-&gt;next
op_assign
id|child.bn-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bhash
c_func
(paren
id|tree
comma
id|child.bn-&gt;node
)paren
op_eq
id|child.bn
)paren
(brace
id|bhash
c_func
(paren
id|tree
comma
id|child.bn-&gt;node
)paren
op_assign
id|child.bn-&gt;next
suffix:semicolon
)brace
id|child.bn-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|child.bn-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|tree-&gt;bthRoot
op_assign
id|child.bn-&gt;node
suffix:semicolon
id|tree-&gt;root
op_assign
id|child.bn
suffix:semicolon
multiline_comment|/* re-assign bthFNode and bthLNode if the new root is&n;                   a leaf node. */
r_if
c_cond
(paren
id|child.bn-&gt;ndType
op_eq
id|ndLeafNode
)paren
(brace
id|tree-&gt;bthFNode
op_assign
id|node
suffix:semicolon
id|tree-&gt;bthLNode
op_assign
id|node
suffix:semicolon
)brace
id|hfs_bnode_relse
c_func
(paren
op_amp
id|child
)paren
suffix:semicolon
id|tree-&gt;bthRoot
op_assign
id|node
suffix:semicolon
op_decrement
id|tree-&gt;bthDepth
suffix:semicolon
id|tree-&gt;dirt
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tree-&gt;bthDepth
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bdelete: non-empty tree with &quot;
l_string|&quot;bthDepth == 0&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|bail
suffix:semicolon
)brace
r_return
id|hfs_bnode_free
c_func
(paren
id|root
)paren
suffix:semicolon
multiline_comment|/* marks tree dirty */
)brace
id|hfs_bnode_relse
c_func
(paren
id|root
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|bail
suffix:colon
id|hfs_bnode_relse
c_func
(paren
id|root
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n; * delete_empty_bnode()&n; *&n; * Description:&n; *   Removes an empty non-root bnode from between &squot;left&squot; and &squot;right&squot;&n; * Input Variable(s):&n; *   hfs_u32 left_node: node number of &squot;left&squot; or zero if &squot;left&squot; is invalid&n; *   struct hfs_bnode_ref *left: reference to the left neighbor of the&n; *    bnode to remove, or invalid if no such neighbor exists.&n; *   struct hfs_bnode_ref *center: reference to the bnode to remove&n; *   hfs_u32 right_node: node number of &squot;right&squot; or zero if &squot;right&squot; is invalid&n; *   struct hfs_bnode_ref *right: reference to the right neighbor of the&n; *    bnode to remove, or invalid if no such neighbor exists.&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   void&n; * Preconditions:&n; *   &squot;left_node&squot; is as described above.&n; *   &squot;left&squot; points to a valid (struct hfs_bnode_ref) having HFS_LOCK_WRITE&n; *    access and referring to the left neighbor of &squot;center&squot; if such a&n; *    neighbor exists, or invalid if no such neighbor exists.&n; *   &squot;center&squot; points to a valid (struct hfs_bnode_ref) having HFS_LOCK_WRITE&n; *    access and referring to the bnode to delete.&n; *   &squot;right_node&squot; is as described above.&n; *   &squot;right&squot; points to a valid (struct hfs_bnode_ref) having HFS_LOCK_WRITE&n; *    access and referring to the right neighbor of &squot;center&squot; if such a&n; *    neighbor exists, or invalid if no such neighbor exists.&n; * Postconditions:&n; *   If &squot;left&squot; is valid its &squot;ndFLink&squot; field becomes &squot;right_node&squot;.&n; *   If &squot;right&squot; is valid its &squot;ndBLink&squot; field becomes &squot;left_node&squot;.&n; *   If &squot;center&squot; was the first leaf node then the tree&squot;s &squot;bthFNode&squot;&n; *    field becomes &squot;right_node&squot; &n; *   If &squot;center&squot; was the last leaf node then the tree&squot;s &squot;bthLNode&squot;&n; *    field becomes &squot;left_node&squot; &n; *   &squot;center&squot; is NOT freed and access to the nodes is NOT relinquished.&n; */
DECL|function|delete_empty_bnode
r_static
r_void
id|delete_empty_bnode
c_func
(paren
id|hfs_u32
id|left_node
comma
r_struct
id|hfs_bnode_ref
op_star
id|left
comma
r_struct
id|hfs_bnode_ref
op_star
id|center
comma
id|hfs_u32
id|right_node
comma
r_struct
id|hfs_bnode_ref
op_star
id|right
)paren
(brace
r_struct
id|hfs_bnode
op_star
id|bnode
op_assign
id|center-&gt;bn
suffix:semicolon
r_if
c_cond
(paren
id|left_node
)paren
(brace
id|left-&gt;bn-&gt;ndFLink
op_assign
id|right_node
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bnode-&gt;ndType
op_eq
id|ndLeafNode
)paren
(brace
id|bnode-&gt;tree-&gt;bthFNode
op_assign
id|right_node
suffix:semicolon
id|bnode-&gt;tree-&gt;dirt
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|right_node
)paren
(brace
id|right-&gt;bn-&gt;ndBLink
op_assign
id|left_node
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bnode-&gt;ndType
op_eq
id|ndLeafNode
)paren
(brace
id|bnode-&gt;tree-&gt;bthLNode
op_assign
id|left_node
suffix:semicolon
id|bnode-&gt;tree-&gt;dirt
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * balance()&n; *&n; * Description:&n; *   Attempt to equalize space usage in neighboring bnodes.&n; * Input Variable(s):&n; *   struct hfs_bnode *left: the left bnode.&n; *   struct hfs_bnode *right: the right bnode.&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   void&n; * Preconditions:&n; *   &squot;left&squot; and &squot;right&squot; point to valid (struct hfs_bnode)s obtained&n; *    with HFS_LOCK_WRITE access, and are neighbors.&n; * Postconditions:&n; *   Records are shifted either left or right to make the space usage&n; *   nearly equal.  When exact equality is not possible the break&n; *   point is chosen to reduce data movement.&n; *   The key corresponding to &squot;right&squot; in its parent is NOT updated.&n; */
DECL|function|balance
r_static
r_void
id|balance
c_func
(paren
r_struct
id|hfs_bnode
op_star
id|left
comma
r_struct
id|hfs_bnode
op_star
id|right
)paren
(brace
r_int
id|index
comma
id|left_free
comma
id|right_free
comma
id|half
suffix:semicolon
id|left_free
op_assign
id|bnode_freespace
c_func
(paren
id|left
)paren
suffix:semicolon
id|right_free
op_assign
id|bnode_freespace
c_func
(paren
id|right
)paren
suffix:semicolon
id|half
op_assign
(paren
id|left_free
op_plus
id|right_free
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|left_free
OL
id|right_free
)paren
(brace
multiline_comment|/* shift right to balance */
id|index
op_assign
id|left-&gt;ndNRecs
op_plus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|right_free
op_ge
id|half
)paren
(brace
op_decrement
id|index
suffix:semicolon
id|right_free
op_sub_assign
id|bnode_rsize
c_func
(paren
id|left
comma
id|index
)paren
op_plus
r_sizeof
(paren
id|hfs_u16
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|index
OL
id|left-&gt;ndNRecs
)paren
(brace
macro_line|#if defined(DEBUG_ALL) || defined(DEBUG_BALANCE)
id|hfs_warn
c_func
(paren
l_string|&quot;shifting %d of %d recs right to balance: &quot;
comma
id|left-&gt;ndNRecs
op_minus
id|index
comma
id|left-&gt;ndNRecs
)paren
suffix:semicolon
macro_line|#endif
id|hfs_bnode_shift_right
c_func
(paren
id|left
comma
id|right
comma
id|index
op_plus
l_int|1
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_ALL) || defined(DEBUG_BALANCE)
id|hfs_warn
c_func
(paren
l_string|&quot;%d,%d&bslash;n&quot;
comma
id|left-&gt;ndNRecs
comma
id|right-&gt;ndNRecs
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
(brace
multiline_comment|/* shift left to balance */
id|index
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|left_free
op_ge
id|half
)paren
(brace
op_increment
id|index
suffix:semicolon
id|left_free
op_sub_assign
id|bnode_rsize
c_func
(paren
id|right
comma
id|index
)paren
op_plus
r_sizeof
(paren
id|hfs_u16
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|index
OG
l_int|1
)paren
(brace
macro_line|#if defined(DEBUG_ALL) || defined(DEBUG_BALANCE)
id|hfs_warn
c_func
(paren
l_string|&quot;shifting %d of %d recs left to balance: &quot;
comma
id|index
op_minus
l_int|1
comma
id|right-&gt;ndNRecs
)paren
suffix:semicolon
macro_line|#endif
id|hfs_bnode_shift_left
c_func
(paren
id|left
comma
id|right
comma
id|index
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#if defined(DEBUG_ALL) || defined(DEBUG_BALANCE)
id|hfs_warn
c_func
(paren
l_string|&quot;%d,%d&bslash;n&quot;
comma
id|left-&gt;ndNRecs
comma
id|right-&gt;ndNRecs
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
multiline_comment|/*&n; * bdelete()&n; *&n; * Delete the given record from a B-tree.&n; */
DECL|function|bdelete
r_static
r_int
id|bdelete
c_func
(paren
r_struct
id|hfs_brec
op_star
id|brec
)paren
(brace
r_struct
id|hfs_btree
op_star
id|tree
op_assign
id|brec-&gt;tree
suffix:semicolon
r_struct
id|hfs_belem
op_star
id|belem
op_assign
id|brec-&gt;bottom
suffix:semicolon
r_struct
id|hfs_belem
op_star
id|parent
op_assign
(paren
id|belem
op_minus
l_int|1
)paren
suffix:semicolon
r_struct
id|hfs_bnode
op_star
id|bnode
suffix:semicolon
id|hfs_u32
id|left_node
comma
id|right_node
suffix:semicolon
r_struct
id|hfs_bnode_ref
id|left
comma
id|right
suffix:semicolon
r_int
id|left_space
comma
id|right_space
comma
id|min_space
suffix:semicolon
r_int
id|fix_right_key
suffix:semicolon
r_int
id|fix_key
suffix:semicolon
r_while
c_loop
(paren
(paren
id|belem
OG
id|brec-&gt;top
)paren
op_logical_and
(paren
id|belem-&gt;flags
op_amp
(paren
id|HFS_BPATH_UNDERFLOW
op_or
id|HFS_BPATH_FIRST
)paren
)paren
)paren
(brace
id|bnode
op_assign
id|belem-&gt;bnr.bn
suffix:semicolon
id|fix_key
op_assign
id|belem-&gt;flags
op_amp
id|HFS_BPATH_FIRST
suffix:semicolon
id|fix_right_key
op_assign
l_int|0
suffix:semicolon
id|bdelete_nonempty
c_func
(paren
id|brec
comma
id|belem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bnode-&gt;node
op_eq
id|tree-&gt;root-&gt;node
)paren
(brace
id|del_root
c_func
(paren
op_amp
id|belem-&gt;bnr
)paren
suffix:semicolon
op_decrement
id|brec-&gt;bottom
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* check for btree corruption which could lead to deadlock */
id|left_node
op_assign
id|bnode-&gt;ndBLink
suffix:semicolon
id|right_node
op_assign
id|bnode-&gt;ndFLink
suffix:semicolon
r_if
c_cond
(paren
(paren
id|left_node
op_logical_and
id|hfs_bnode_in_brec
c_func
(paren
id|left_node
comma
id|brec
)paren
)paren
op_logical_or
(paren
id|right_node
op_logical_and
id|hfs_bnode_in_brec
c_func
(paren
id|right_node
comma
id|brec
)paren
)paren
op_logical_or
(paren
id|left_node
op_eq
id|right_node
)paren
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bdelete: corrupt btree&bslash;n&quot;
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* grab the left neighbor if it exists */
r_if
c_cond
(paren
id|left_node
)paren
(brace
id|hfs_bnode_lock
c_func
(paren
op_amp
id|belem-&gt;bnr
comma
id|HFS_LOCK_RESRV
)paren
suffix:semicolon
id|left
op_assign
id|hfs_bnode_find
c_func
(paren
id|tree
comma
id|left_node
comma
id|HFS_LOCK_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|left.bn
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bdelete: unable to read left &quot;
l_string|&quot;neighbor.&bslash;n&quot;
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|hfs_bnode_lock
c_func
(paren
op_amp
id|belem-&gt;bnr
comma
id|HFS_LOCK_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent-&gt;record
op_ne
l_int|1
)paren
(brace
id|left_space
op_assign
id|bnode_freespace
c_func
(paren
id|left.bn
)paren
suffix:semicolon
)brace
r_else
(brace
id|left_space
op_assign
id|NO_SPACE
suffix:semicolon
)brace
)brace
r_else
(brace
id|left.bn
op_assign
l_int|NULL
suffix:semicolon
id|left_space
op_assign
id|NO_SPACE
suffix:semicolon
)brace
multiline_comment|/* grab the right neighbor if it exists */
r_if
c_cond
(paren
id|right_node
)paren
(brace
id|right
op_assign
id|hfs_bnode_find
c_func
(paren
id|tree
comma
id|right_node
comma
id|HFS_LOCK_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|right.bn
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bdelete: unable to read right &quot;
l_string|&quot;neighbor.&bslash;n&quot;
)paren
suffix:semicolon
id|hfs_bnode_relse
c_func
(paren
op_amp
id|left
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|parent-&gt;record
OL
id|parent-&gt;bnr.bn-&gt;ndNRecs
)paren
(brace
id|right_space
op_assign
id|bnode_freespace
c_func
(paren
id|right.bn
)paren
suffix:semicolon
)brace
r_else
(brace
id|right_space
op_assign
id|NO_SPACE
suffix:semicolon
)brace
)brace
r_else
(brace
id|right.bn
op_assign
l_int|NULL
suffix:semicolon
id|right_space
op_assign
id|NO_SPACE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|left_space
OL
id|right_space
)paren
(brace
id|min_space
op_assign
id|left_space
suffix:semicolon
)brace
r_else
(brace
id|min_space
op_assign
id|right_space
suffix:semicolon
)brace
r_if
c_cond
(paren
id|min_space
op_eq
id|NO_SPACE
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bdelete: no siblings?&bslash;n&quot;
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bnode-&gt;ndNRecs
op_eq
l_int|0
)paren
(brace
id|delete_empty_bnode
c_func
(paren
id|left_node
comma
op_amp
id|left
comma
op_amp
id|belem-&gt;bnr
comma
id|right_node
comma
op_amp
id|right
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|min_space
op_plus
id|bnode_freespace
c_func
(paren
id|bnode
)paren
op_ge
id|FULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|right_space
op_eq
id|NO_SPACE
)paren
op_logical_or
(paren
(paren
id|right_space
op_eq
id|min_space
)paren
op_logical_and
(paren
id|left_space
op_ne
id|NO_SPACE
)paren
)paren
)paren
(brace
id|hfs_bnode_shift_left
c_func
(paren
id|left.bn
comma
id|bnode
comma
id|bnode-&gt;ndNRecs
)paren
suffix:semicolon
)brace
r_else
(brace
id|hfs_bnode_shift_right
c_func
(paren
id|bnode
comma
id|right.bn
comma
l_int|1
)paren
suffix:semicolon
id|fix_right_key
op_assign
l_int|1
suffix:semicolon
)brace
id|delete_empty_bnode
c_func
(paren
id|left_node
comma
op_amp
id|left
comma
op_amp
id|belem-&gt;bnr
comma
id|right_node
comma
op_amp
id|right
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|min_space
op_eq
id|right_space
)paren
(brace
id|balance
c_func
(paren
id|bnode
comma
id|right.bn
)paren
suffix:semicolon
id|fix_right_key
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|balance
c_func
(paren
id|left.bn
comma
id|bnode
)paren
suffix:semicolon
id|fix_key
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fix_right_key
)paren
(brace
id|hfs_bnode_update_key
c_func
(paren
id|brec
comma
id|belem
comma
id|right.bn
comma
l_int|1
)paren
suffix:semicolon
)brace
id|hfs_bnode_relse
c_func
(paren
op_amp
id|left
)paren
suffix:semicolon
id|hfs_bnode_relse
c_func
(paren
op_amp
id|right
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bnode-&gt;ndNRecs
)paren
(brace
r_if
c_cond
(paren
id|fix_key
)paren
(brace
id|hfs_bnode_update_key
c_func
(paren
id|brec
comma
id|belem
comma
id|bnode
comma
l_int|0
)paren
suffix:semicolon
)brace
r_goto
id|done
suffix:semicolon
)brace
id|hfs_bnode_free
c_func
(paren
op_amp
id|belem-&gt;bnr
)paren
suffix:semicolon
op_decrement
id|brec-&gt;bottom
suffix:semicolon
id|belem
op_assign
id|parent
suffix:semicolon
op_decrement
id|parent
suffix:semicolon
)brace
r_if
c_cond
(paren
id|belem
OL
id|brec-&gt;top
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bdelete: Missing parent.&bslash;n&quot;
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|bdelete_nonempty
c_func
(paren
id|brec
comma
id|belem
)paren
suffix:semicolon
id|done
suffix:colon
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*================ Global functions ================*/
multiline_comment|/*&n; * hfs_bdelete()&n; *&n; * Delete the requested record from a B-tree.&n; */
DECL|function|hfs_bdelete
r_int
id|hfs_bdelete
c_func
(paren
r_struct
id|hfs_btree
op_star
id|tree
comma
r_const
r_struct
id|hfs_bkey
op_star
id|key
)paren
(brace
r_struct
id|hfs_belem
op_star
id|belem
suffix:semicolon
r_struct
id|hfs_bnode
op_star
id|bnode
suffix:semicolon
r_struct
id|hfs_brec
id|brec
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tree
op_logical_or
(paren
id|tree-&gt;magic
op_ne
id|HFS_BTREE_MAGIC
)paren
op_logical_or
op_logical_neg
id|key
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bdelete: invalid arguments.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|retval
op_assign
id|hfs_bfind
c_func
(paren
op_amp
id|brec
comma
id|tree
comma
id|key
comma
id|HFS_BFIND_DELETE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
(brace
id|belem
op_assign
id|brec.bottom
suffix:semicolon
id|bnode
op_assign
id|belem-&gt;bnr.bn
suffix:semicolon
id|belem-&gt;flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bnode-&gt;ndNRecs
op_star
r_sizeof
(paren
id|hfs_u16
)paren
op_plus
id|bnode_end
c_func
(paren
id|bnode
)paren
op_minus
id|bnode_rsize
c_func
(paren
id|bnode
comma
id|belem-&gt;record
)paren
)paren
OL
id|FULL
op_div
l_int|2
)paren
(brace
id|belem-&gt;flags
op_or_assign
id|HFS_BPATH_UNDERFLOW
suffix:semicolon
)brace
r_if
c_cond
(paren
id|belem-&gt;record
op_eq
l_int|1
)paren
(brace
id|belem-&gt;flags
op_or_assign
id|HFS_BPATH_FIRST
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|belem-&gt;flags
)paren
(brace
id|hfs_brec_lock
c_func
(paren
op_amp
id|brec
comma
id|brec.bottom
)paren
suffix:semicolon
)brace
r_else
(brace
id|hfs_brec_lock
c_func
(paren
op_amp
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|retval
op_assign
id|bdelete
c_func
(paren
op_amp
id|brec
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
(brace
op_decrement
id|brec.tree-&gt;bthNRecs
suffix:semicolon
id|brec.tree-&gt;dirt
op_assign
l_int|1
suffix:semicolon
)brace
id|hfs_brec_relse
c_func
(paren
op_amp
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
eof
