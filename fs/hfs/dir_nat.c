multiline_comment|/*&n; * linux/fs/hfs/dir_nat.c&n; *&n; * Copyright (C) 1995-1997  Paul H. Hargrove&n; * This file may be distributed under the terms of the GNU Public License.&n; *&n; * This file contains the inode_operations and file_operations&n; * structures for HFS directories.&n; *&n; * Based on the minix file system code, (C) 1991, 1992 by Linus Torvalds&n; *&n; * The source code distributions of Netatalk, versions 1.3.3b2 and&n; * 1.4b2, were used as a specification of the location and format of&n; * files used by Netatalk&squot;s afpd.  No code from Netatalk appears in&n; * hfs_fs.  hfs_fs is not a work ``derived&squot;&squot; from Netatalk in the&n; * sense of intellectual property law.&n; *&n; * &quot;XXX&quot; in a comment is a note to myself to consider changing something.&n; *&n; * In function preconditions the term &quot;valid&quot; applied to a pointer to&n; * a structure means that the pointer is non-NULL and the structure it&n; * points to has all fields initialized to consistent values.&n; */
macro_line|#include &quot;hfs.h&quot;
macro_line|#include &lt;linux/hfs_fs_sb.h&gt;
macro_line|#include &lt;linux/hfs_fs_i.h&gt;
macro_line|#include &lt;linux/hfs_fs.h&gt;
multiline_comment|/*================ Forward declarations ================*/
r_static
r_struct
id|dentry
op_star
id|nat_lookup
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|dentry
op_star
)paren
suffix:semicolon
r_static
r_int
id|nat_readdir
c_func
(paren
r_struct
id|file
op_star
comma
r_void
op_star
comma
id|filldir_t
)paren
suffix:semicolon
r_static
r_int
id|nat_rmdir
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|dentry
op_star
)paren
suffix:semicolon
r_static
r_int
id|nat_hdr_unlink
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|dentry
op_star
)paren
suffix:semicolon
r_static
r_int
id|nat_hdr_rename
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|dentry
op_star
comma
r_struct
id|inode
op_star
comma
r_struct
id|dentry
op_star
)paren
suffix:semicolon
multiline_comment|/*================ Global variables ================*/
DECL|macro|DOT_LEN
mdefine_line|#define DOT_LEN&t;&t;&t;1
DECL|macro|DOT_DOT_LEN
mdefine_line|#define DOT_DOT_LEN&t;&t;2
DECL|macro|DOT_APPLEDOUBLE_LEN
mdefine_line|#define DOT_APPLEDOUBLE_LEN&t;12
DECL|macro|DOT_PARENT_LEN
mdefine_line|#define DOT_PARENT_LEN&t;&t;7
DECL|macro|ROOTINFO_LEN
mdefine_line|#define ROOTINFO_LEN            8
DECL|variable|hfs_nat_reserved1
r_const
r_struct
id|hfs_name
id|hfs_nat_reserved1
(braket
)braket
op_assign
(brace
(brace
id|DOT_LEN
comma
l_string|&quot;.&quot;
)brace
comma
(brace
id|DOT_DOT_LEN
comma
l_string|&quot;..&quot;
)brace
comma
(brace
id|DOT_APPLEDOUBLE_LEN
comma
l_string|&quot;.AppleDouble&quot;
)brace
comma
(brace
id|DOT_PARENT_LEN
comma
l_string|&quot;.Parent&quot;
)brace
comma
(brace
l_int|0
comma
l_string|&quot;&quot;
)brace
comma
)brace
suffix:semicolon
DECL|variable|hfs_nat_reserved2
r_const
r_struct
id|hfs_name
id|hfs_nat_reserved2
(braket
)braket
op_assign
(brace
(brace
id|ROOTINFO_LEN
comma
l_string|&quot;RootInfo&quot;
)brace
comma
)brace
suffix:semicolon
DECL|macro|DOT
mdefine_line|#define DOT&t;&t;(&amp;hfs_nat_reserved1[0])
DECL|macro|DOT_DOT
mdefine_line|#define DOT_DOT&t;&t;(&amp;hfs_nat_reserved1[1])
DECL|macro|DOT_APPLEDOUBLE
mdefine_line|#define DOT_APPLEDOUBLE&t;(&amp;hfs_nat_reserved1[2])
DECL|macro|DOT_PARENT
mdefine_line|#define DOT_PARENT&t;(&amp;hfs_nat_reserved1[3])
DECL|macro|ROOTINFO
mdefine_line|#define ROOTINFO        (&amp;hfs_nat_reserved2[0])
DECL|variable|hfs_nat_dir_operations
r_struct
id|file_operations
id|hfs_nat_dir_operations
op_assign
(brace
id|read
suffix:colon
id|generic_read_dir
comma
id|readdir
suffix:colon
id|nat_readdir
comma
id|fsync
suffix:colon
id|file_fsync
comma
)brace
suffix:semicolon
DECL|variable|hfs_nat_ndir_inode_operations
r_struct
id|inode_operations
id|hfs_nat_ndir_inode_operations
op_assign
(brace
id|create
suffix:colon
id|hfs_create
comma
id|lookup
suffix:colon
id|nat_lookup
comma
id|unlink
suffix:colon
id|hfs_unlink
comma
id|mkdir
suffix:colon
id|hfs_mkdir
comma
id|rmdir
suffix:colon
id|nat_rmdir
comma
id|rename
suffix:colon
id|hfs_rename
comma
id|setattr
suffix:colon
id|hfs_notify_change
comma
)brace
suffix:semicolon
DECL|variable|hfs_nat_hdir_inode_operations
r_struct
id|inode_operations
id|hfs_nat_hdir_inode_operations
op_assign
(brace
id|create
suffix:colon
id|hfs_create
comma
id|lookup
suffix:colon
id|nat_lookup
comma
id|unlink
suffix:colon
id|nat_hdr_unlink
comma
id|rename
suffix:colon
id|nat_hdr_rename
comma
id|setattr
suffix:colon
id|hfs_notify_change
comma
)brace
suffix:semicolon
multiline_comment|/*================ File-local functions ================*/
multiline_comment|/*&n; * nat_lookup()&n; *&n; * This is the lookup() entry in the inode_operations structure for&n; * HFS directories in the Netatalk scheme.  The purpose is to generate&n; * the inode corresponding to an entry in a directory, given the inode&n; * for the directory and the name (and its length) of the entry.&n; */
DECL|function|nat_lookup
r_static
r_struct
id|dentry
op_star
id|nat_lookup
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
id|ino_t
id|dtype
suffix:semicolon
r_struct
id|hfs_name
id|cname
suffix:semicolon
r_struct
id|hfs_cat_entry
op_star
id|entry
suffix:semicolon
r_struct
id|hfs_cat_key
id|key
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
l_int|NULL
suffix:semicolon
id|dentry-&gt;d_op
op_assign
op_amp
id|hfs_dentry_operations
suffix:semicolon
id|entry
op_assign
id|HFS_I
c_func
(paren
id|dir
)paren
op_member_access_from_pointer
id|entry
suffix:semicolon
id|dtype
op_assign
id|HFS_ITYPE
c_func
(paren
id|dir-&gt;i_ino
)paren
suffix:semicolon
multiline_comment|/* Perform name-mangling */
id|hfs_nameout
c_func
(paren
id|dir
comma
op_amp
id|cname
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
)paren
suffix:semicolon
multiline_comment|/* no need to check for &quot;.&quot;  or &quot;..&quot; */
multiline_comment|/* Check for &quot;.AppleDouble&quot; if in a normal directory,&n;&t;   and for &quot;.Parent&quot; in &quot;.AppleDouble&quot;. */
r_if
c_cond
(paren
id|dtype
op_eq
id|HFS_NAT_NDIR
)paren
(brace
multiline_comment|/* Check for &quot;.AppleDouble&quot; */
r_if
c_cond
(paren
id|hfs_streq
c_func
(paren
id|cname.Name
comma
id|cname.Len
comma
id|DOT_APPLEDOUBLE-&gt;Name
comma
id|DOT_APPLEDOUBLE_LEN
)paren
)paren
(brace
op_increment
id|entry-&gt;count
suffix:semicolon
multiline_comment|/* __hfs_iget() eats one */
id|inode
op_assign
id|hfs_iget
c_func
(paren
id|entry
comma
id|HFS_NAT_HDIR
comma
id|dentry
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|dtype
op_eq
id|HFS_NAT_HDIR
)paren
(brace
r_if
c_cond
(paren
id|hfs_streq
c_func
(paren
id|cname.Name
comma
id|cname.Len
comma
id|DOT_PARENT-&gt;Name
comma
id|DOT_PARENT_LEN
)paren
)paren
(brace
op_increment
id|entry-&gt;count
suffix:semicolon
multiline_comment|/* __hfs_iget() eats one */
id|inode
op_assign
id|hfs_iget
c_func
(paren
id|entry
comma
id|HFS_NAT_HDR
comma
id|dentry
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|entry-&gt;cnid
op_eq
id|htonl
c_func
(paren
id|HFS_ROOT_CNID
)paren
)paren
op_logical_and
id|hfs_streq
c_func
(paren
id|cname.Name
comma
id|cname.Len
comma
id|ROOTINFO-&gt;Name
comma
id|ROOTINFO_LEN
)paren
)paren
(brace
op_increment
id|entry-&gt;count
suffix:semicolon
multiline_comment|/* __hfs_iget() eats one */
id|inode
op_assign
id|hfs_iget
c_func
(paren
id|entry
comma
id|HFS_NAT_HDR
comma
id|dentry
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
)brace
multiline_comment|/* Do an hfs_iget() on the mangled name. */
id|hfs_cat_build_key
c_func
(paren
id|entry-&gt;cnid
comma
op_amp
id|cname
comma
op_amp
id|key
)paren
suffix:semicolon
id|inode
op_assign
id|hfs_iget
c_func
(paren
id|hfs_cat_get
c_func
(paren
id|entry-&gt;mdb
comma
op_amp
id|key
)paren
comma
id|HFS_I
c_func
(paren
id|dir
)paren
op_member_access_from_pointer
id|file_type
comma
id|dentry
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t return a header file for a directory other than .Parent */
r_if
c_cond
(paren
id|inode
op_logical_and
(paren
id|dtype
op_eq
id|HFS_NAT_HDIR
)paren
op_logical_and
(paren
id|HFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|entry
op_ne
id|entry
)paren
op_logical_and
(paren
id|HFS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|entry-&gt;type
op_eq
id|HFS_CDR_DIR
)paren
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/* this does an hfs_cat_put */
id|inode
op_assign
l_int|NULL
suffix:semicolon
)brace
id|done
suffix:colon
id|d_add
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * nat_readdir()&n; *&n; * This is the readdir() entry in the file_operations structure for&n; * HFS directories in the netatalk scheme.  The purpose is to&n; * enumerate the entries in a directory, given the inode of the&n; * directory and a struct file which indicates the location in the&n; * directory.  The struct file is updated so that the next call with&n; * the same dir and filp will produce the next directory entry.&t; The&n; * entries are returned in dirent, which is &quot;filled-in&quot; by calling&n; * filldir().  This allows the same readdir() function be used for&n; * different dirent formats.  We try to read in as many entries as we&n; * can before filldir() refuses to take any more.&n; *&n; * Note that the Netatalk format doesn&squot;t have the problem with&n; * metadata for covered directories that exists in the other formats,&n; * since the metadata is contained within the directory.&n; */
DECL|function|nat_readdir
r_static
r_int
id|nat_readdir
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|dirent
comma
id|filldir_t
id|filldir
)paren
(brace
id|ino_t
id|type
suffix:semicolon
r_int
id|skip_dirs
suffix:semicolon
r_struct
id|hfs_brec
id|brec
suffix:semicolon
r_struct
id|hfs_cat_entry
op_star
id|entry
suffix:semicolon
r_struct
id|inode
op_star
id|dir
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|entry
op_assign
id|HFS_I
c_func
(paren
id|dir
)paren
op_member_access_from_pointer
id|entry
suffix:semicolon
id|type
op_assign
id|HFS_ITYPE
c_func
(paren
id|dir-&gt;i_ino
)paren
suffix:semicolon
id|skip_dirs
op_assign
(paren
id|type
op_eq
id|HFS_NAT_HDIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_pos
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Entry 0 is for &quot;.&quot; */
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|dirent
comma
id|DOT-&gt;Name
comma
id|DOT_LEN
comma
l_int|0
comma
id|dir-&gt;i_ino
comma
id|DT_DIR
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|filp-&gt;f_pos
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|filp-&gt;f_pos
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Entry 1 is for &quot;..&quot; */
id|hfs_u32
id|cnid
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|HFS_NAT_NDIR
)paren
(brace
id|cnid
op_assign
id|hfs_get_nl
c_func
(paren
id|entry-&gt;key.ParID
)paren
suffix:semicolon
)brace
r_else
(brace
id|cnid
op_assign
id|entry-&gt;cnid
suffix:semicolon
)brace
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|dirent
comma
id|DOT_DOT-&gt;Name
comma
id|DOT_DOT_LEN
comma
l_int|1
comma
id|ntohl
c_func
(paren
id|cnid
)paren
comma
id|DT_DIR
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|filp-&gt;f_pos
op_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|filp-&gt;f_pos
OL
(paren
id|dir-&gt;i_size
op_minus
l_int|2
)paren
)paren
(brace
id|hfs_u32
id|cnid
suffix:semicolon
id|hfs_u8
id|type
suffix:semicolon
r_if
c_cond
(paren
id|hfs_cat_open
c_func
(paren
id|entry
comma
op_amp
id|brec
)paren
op_logical_or
id|hfs_cat_next
c_func
(paren
id|entry
comma
op_amp
id|brec
comma
id|filp-&gt;f_pos
op_minus
l_int|2
comma
op_amp
id|cnid
comma
op_amp
id|type
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|filp-&gt;f_pos
OL
(paren
id|dir-&gt;i_size
op_minus
l_int|2
)paren
)paren
(brace
r_if
c_cond
(paren
id|hfs_cat_next
c_func
(paren
id|entry
comma
op_amp
id|brec
comma
l_int|1
comma
op_amp
id|cnid
comma
op_amp
id|type
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|skip_dirs
op_logical_or
(paren
id|type
op_ne
id|HFS_CDR_DIR
)paren
)paren
(brace
id|ino_t
id|ino
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_int
r_char
id|tmp_name
(braket
id|HFS_NAMEMAX
)braket
suffix:semicolon
id|ino
op_assign
id|ntohl
c_func
(paren
id|cnid
)paren
op_or
id|HFS_I
c_func
(paren
id|dir
)paren
op_member_access_from_pointer
id|file_type
suffix:semicolon
id|len
op_assign
id|hfs_namein
c_func
(paren
id|dir
comma
id|tmp_name
comma
op_amp
(paren
(paren
r_struct
id|hfs_cat_key
op_star
)paren
id|brec.key
)paren
op_member_access_from_pointer
id|CName
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|dirent
comma
id|tmp_name
comma
id|len
comma
id|filp-&gt;f_pos
comma
id|ino
comma
id|DT_UNKNOWN
)paren
)paren
(brace
id|hfs_cat_close
c_func
(paren
id|entry
comma
op_amp
id|brec
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
op_increment
id|filp-&gt;f_pos
suffix:semicolon
)brace
id|hfs_cat_close
c_func
(paren
id|entry
comma
op_amp
id|brec
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|filp-&gt;f_pos
op_eq
(paren
id|dir-&gt;i_size
op_minus
l_int|2
)paren
)paren
(brace
r_if
c_cond
(paren
id|type
op_eq
id|HFS_NAT_NDIR
)paren
(brace
multiline_comment|/* In normal dirs entry 2 is for &quot;.AppleDouble&quot; */
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|dirent
comma
id|DOT_APPLEDOUBLE-&gt;Name
comma
id|DOT_APPLEDOUBLE_LEN
comma
id|filp-&gt;f_pos
comma
id|ntohl
c_func
(paren
id|entry-&gt;cnid
)paren
op_or
id|HFS_NAT_HDIR
comma
id|DT_UNKNOWN
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|type
op_eq
id|HFS_NAT_HDIR
)paren
(brace
multiline_comment|/* In .AppleDouble entry 2 is for &quot;.Parent&quot; */
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|dirent
comma
id|DOT_PARENT-&gt;Name
comma
id|DOT_PARENT_LEN
comma
id|filp-&gt;f_pos
comma
id|ntohl
c_func
(paren
id|entry-&gt;cnid
)paren
op_or
id|HFS_NAT_HDR
comma
id|DT_UNKNOWN
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
op_increment
id|filp-&gt;f_pos
suffix:semicolon
)brace
r_if
c_cond
(paren
id|filp-&gt;f_pos
op_eq
(paren
id|dir-&gt;i_size
op_minus
l_int|1
)paren
)paren
(brace
multiline_comment|/* handle ROOT/.AppleDouble/RootInfo as the last entry. */
r_if
c_cond
(paren
(paren
id|entry-&gt;cnid
op_eq
id|htonl
c_func
(paren
id|HFS_ROOT_CNID
)paren
)paren
op_logical_and
(paren
id|type
op_eq
id|HFS_NAT_HDIR
)paren
)paren
(brace
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|dirent
comma
id|ROOTINFO-&gt;Name
comma
id|ROOTINFO_LEN
comma
id|filp-&gt;f_pos
comma
id|ntohl
c_func
(paren
id|entry-&gt;cnid
)paren
op_or
id|HFS_NAT_HDR
comma
id|DT_UNKNOWN
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
op_increment
id|filp-&gt;f_pos
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* due to the dcache caching negative dentries for non-existent files,&n; * we need to drop those entries when a file silently gets created.&n; * as far as i can tell, the calls that need to do this are the file&n; * related calls (create, rename, and mknod). the directory calls&n; * should be immune. the relevant calls in dir.c call drop_dentry &n; * upon successful completion. */
DECL|function|hfs_nat_drop_dentry
r_void
id|hfs_nat_drop_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_const
id|ino_t
id|type
)paren
(brace
r_struct
id|dentry
op_star
id|de
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|HFS_NAT_HDR
suffix:colon
multiline_comment|/* given .AppleDouble/name */
multiline_comment|/* look for name */
id|de
op_assign
id|hfs_lookup_dentry
c_func
(paren
id|dentry-&gt;d_parent-&gt;d_parent
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;d_inode
)paren
id|d_drop
c_func
(paren
id|de
)paren
suffix:semicolon
id|dput
c_func
(paren
id|de
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|HFS_NAT_DATA
suffix:colon
multiline_comment|/* given name */
multiline_comment|/* look for .AppleDouble/name */
id|hfs_drop_special
c_func
(paren
id|dentry-&gt;d_parent
comma
id|DOT_APPLEDOUBLE
comma
id|dentry
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * nat_rmdir()&n; *&n; * This is the rmdir() entry in the inode_operations structure for&n; * Netatalk directories.  The purpose is to delete an existing&n; * directory, given the inode for the parent directory and the name&n; * (and its length) of the existing directory.&n; *&n; * We handle .AppleDouble and call hfs_rmdir() for all other cases.&n; */
DECL|function|nat_rmdir
r_static
r_int
id|nat_rmdir
c_func
(paren
r_struct
id|inode
op_star
id|parent
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|entry
op_assign
id|HFS_I
c_func
(paren
id|parent
)paren
op_member_access_from_pointer
id|entry
suffix:semicolon
r_struct
id|hfs_name
id|cname
suffix:semicolon
r_int
id|error
suffix:semicolon
id|hfs_nameout
c_func
(paren
id|parent
comma
op_amp
id|cname
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hfs_streq
c_func
(paren
id|cname.Name
comma
id|cname.Len
comma
id|DOT_APPLEDOUBLE-&gt;Name
comma
id|DOT_APPLEDOUBLE_LEN
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|HFS_SB
c_func
(paren
id|parent-&gt;i_sb
)paren
op_member_access_from_pointer
id|s_afpd
)paren
(brace
multiline_comment|/* Not in AFPD compatibility mode */
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry-&gt;u.dir.files
op_logical_or
id|entry-&gt;u.dir.dirs
)paren
(brace
multiline_comment|/* AFPD compatible, but the directory is not empty */
id|error
op_assign
op_minus
id|ENOTEMPTY
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* AFPD compatible, so pretend to succeed */
id|error
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|error
op_assign
id|hfs_rmdir
c_func
(paren
id|parent
comma
id|dentry
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * nat_hdr_unlink()&n; *&n; * This is the unlink() entry in the inode_operations structure for&n; * Netatalk .AppleDouble directories.  The purpose is to delete an&n; * existing file, given the inode for the parent directory and the name&n; * (and its length) of the existing file.&n; *&n; * WE DON&squot;T ACTUALLY DELETE HEADER THE FILE.&n; * In non-afpd-compatible mode:&n; *   We return -EPERM.&n; * In afpd-compatible mode:&n; *   We return success if the file exists or is .Parent.&n; *   Otherwise we return -ENOENT.&n; */
DECL|function|nat_hdr_unlink
r_static
r_int
id|nat_hdr_unlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|entry
op_assign
id|HFS_I
c_func
(paren
id|dir
)paren
op_member_access_from_pointer
id|entry
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|HFS_SB
c_func
(paren
id|dir-&gt;i_sb
)paren
op_member_access_from_pointer
id|s_afpd
)paren
(brace
multiline_comment|/* Not in AFPD compatibility mode */
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_else
(brace
r_struct
id|hfs_name
id|cname
suffix:semicolon
id|hfs_nameout
c_func
(paren
id|dir
comma
op_amp
id|cname
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hfs_streq
c_func
(paren
id|cname.Name
comma
id|cname.Len
comma
id|DOT_PARENT-&gt;Name
comma
id|DOT_PARENT_LEN
)paren
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|victim
suffix:semicolon
r_struct
id|hfs_cat_key
id|key
suffix:semicolon
id|hfs_cat_build_key
c_func
(paren
id|entry-&gt;cnid
comma
op_amp
id|cname
comma
op_amp
id|key
)paren
suffix:semicolon
id|victim
op_assign
id|hfs_cat_get
c_func
(paren
id|entry-&gt;mdb
comma
op_amp
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|victim
)paren
(brace
multiline_comment|/* pretend to succeed */
id|hfs_cat_put
c_func
(paren
id|victim
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
)brace
)brace
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * nat_hdr_rename()&n; *&n; * This is the rename() entry in the inode_operations structure for&n; * Netatalk header directories.  The purpose is to rename an existing&n; * file given the inode for the current directory and the name &n; * (and its length) of the existing file and the inode for the new&n; * directory and the name (and its length) of the new file/directory.&n; *&n; * WE NEVER MOVE ANYTHING.&n; * In non-afpd-compatible mode:&n; *   We return -EPERM.&n; * In afpd-compatible mode:&n; *   If the source header doesn&squot;t exist, we return -ENOENT.&n; *   If the destination is not a header directory we return -EPERM.&n; *   We return success if the destination is also a header directory&n; *    and the header exists or is &quot;.Parent&quot;.&n; */
DECL|function|nat_hdr_rename
r_static
r_int
id|nat_hdr_rename
c_func
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_struct
id|dentry
op_star
id|new_dentry
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|entry
op_assign
id|HFS_I
c_func
(paren
id|old_dir
)paren
op_member_access_from_pointer
id|entry
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|HFS_SB
c_func
(paren
id|old_dir-&gt;i_sb
)paren
op_member_access_from_pointer
id|s_afpd
)paren
(brace
multiline_comment|/* Not in AFPD compatibility mode */
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_else
(brace
r_struct
id|hfs_name
id|cname
suffix:semicolon
id|hfs_nameout
c_func
(paren
id|old_dir
comma
op_amp
id|cname
comma
id|old_dentry-&gt;d_name.name
comma
id|old_dentry-&gt;d_name.len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hfs_streq
c_func
(paren
id|cname.Name
comma
id|cname.Len
comma
id|DOT_PARENT-&gt;Name
comma
id|DOT_PARENT_LEN
)paren
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|victim
suffix:semicolon
r_struct
id|hfs_cat_key
id|key
suffix:semicolon
id|hfs_cat_build_key
c_func
(paren
id|entry-&gt;cnid
comma
op_amp
id|cname
comma
op_amp
id|key
)paren
suffix:semicolon
id|victim
op_assign
id|hfs_cat_get
c_func
(paren
id|entry-&gt;mdb
comma
op_amp
id|key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|victim
)paren
(brace
multiline_comment|/* pretend to succeed */
id|hfs_cat_put
c_func
(paren
id|victim
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
(paren
id|HFS_ITYPE
c_func
(paren
id|new_dir-&gt;i_ino
)paren
op_ne
id|HFS_NAT_HDIR
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
r_return
id|error
suffix:semicolon
)brace
eof
