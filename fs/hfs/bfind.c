multiline_comment|/*&n; * linux/fs/hfs/bfind.c&n; *&n; * Copyright (C) 1995, 1996  Paul H. Hargrove&n; * This file may be distributed under the terms of the GNU Public License.&n; *&n; * This file contains the code to access records in a btree.&n; *&n; * &quot;XXX&quot; in a comment is a note to myself to consider changing something.&n; *&n; * In function preconditions the term &quot;valid&quot; applied to a pointer to&n; * a structure means that the pointer is non-NULL and the structure it&n; * points to has all fields initialized to consistent values.&n; */
macro_line|#include &quot;hfs_btree.h&quot;
multiline_comment|/*================ Global functions ================*/
multiline_comment|/*&n; * hfs_brec_relse()&n; *&n; * Description:&n; *   This function releases some of the nodes associated with a brec.&n; * Input Variable(s):&n; *   struct hfs_brec *brec: pointer to the brec to release some nodes from.&n; *   struct hfs_belem *elem: the last node to release or NULL for all&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   void&n; * Preconditions:&n; *   &squot;brec&squot; points to a &quot;valid&quot; (struct hfs_brec)&n; * Postconditions: &n; *   All nodes between the indicated node and the beginning of the path&n; *    are released.&n; */
DECL|function|hfs_brec_relse
r_void
id|hfs_brec_relse
c_func
(paren
r_struct
id|hfs_brec
op_star
id|brec
comma
r_struct
id|hfs_belem
op_star
id|elem
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|elem
)paren
(brace
id|elem
op_assign
id|brec-&gt;bottom
suffix:semicolon
)brace
r_while
c_loop
(paren
id|brec-&gt;top
op_le
id|elem
)paren
(brace
id|hfs_bnode_relse
c_func
(paren
op_amp
id|brec-&gt;top-&gt;bnr
)paren
suffix:semicolon
op_increment
id|brec-&gt;top
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * hfs_bfind()&n; *&n; * Description:&n; *   This function has sole responsibility for locating existing&n; *   records in a B-tree.  Given a B-tree and a key it locates the&n; *   &quot;greatest&quot; record &quot;less than or equal to&quot; the given key.  The&n; *   exact behavior is determined by the bits of the flags variable as&n; *   follows:&n; *     (&squot;flags&squot; &amp; HFS_LOCK_MASK):&n; *      The lock_type argument to be used when calling hfs_bnode_find().&n; *     HFS_BFIND_EXACT: only accept an exact match, otherwise take the&n; *&t;&quot;largest&quot; record less than &squot;target&squot; as a &quot;match&quot;&n; *     HFS_BFIND_LOCK: request HFS_LOCK_WRITE access to the node containing&n; *&t;the &quot;matching&quot; record when it is located&n; *     HFS_BPATH_FIRST: keep access to internal nodes when accessing their&n; *      first child.&n; *     HFS_BPATH_OVERFLOW: keep access to internal nodes when the accessed&n; *      child is too full to insert another pointer record.&n; *     HFS_BPATH_UNDERFLOW: keep access to internal nodes when the accessed&n; *      child is would be less than half full upon removing a pointer record.&n; * Input Variable(s):&n; *   struct hfs_brec *brec: pointer to the (struct hfs_brec) to hold&n; *    the search results.&n; *   struct hfs_bkey *target: pointer to the (struct hfs_bkey)&n; *    to search for&n; *   int flags: bitwise OR of flags which determine the function&squot;s behavior&n; * Output Variable(s):&n; *   &squot;brec&squot; contains the results of the search on success or is invalid&n; *    on failure.&n; * Returns:&n; *   int: 0 or 1 on success or an error code on failure:&n; *     -EINVAL: one of the input variables was NULL.&n; *     -ENOENT: tree is valid but empty or no &quot;matching&quot; record was located.&n; *&t; If the HFS_BFIND_EXACT bit of &squot;flags&squot; is not set then the case of no&n; *&t; matching record will give a &squot;brec&squot; with a &squot;record&squot; field of zero&n; *&t; rather than returning this error.&n; *     -EIO: an I/O operation or an assertion about the structure of a&n; *       valid B-tree failed indicating corruption of either the B-tree&n; *       structure on the disk or one of the in-core structures representing&n; *       the B-tree.&n; *&t; (This could also be returned if a kmalloc() call failed in a&n; *&t; subordinate routine that is intended to get the data from the&n; *&t; disk or the buffer cache.)&n; * Preconditions:&n; *   &squot;brec&squot; is NULL or points to a (struct hfs_brec) with a &squot;tree&squot; field&n; *    which points to a valid (struct hfs_btree).&n; *   &squot;target&squot; is NULL or points to a &quot;valid&quot; (struct hfs_bkey)&n; * Postconditions:&n; *   If &squot;brec&squot;, &squot;brec-&gt;tree&squot; or &squot;target&squot; is NULL then -EINVAL is returned.&n; *   If &squot;brec&squot;, &squot;brec-&gt;tree&squot; and &squot;target&squot; are non-NULL but the tree&n; *   is empty then -ENOENT is returned.&n; *   If &squot;brec&squot;, &squot;brec-&gt;tree&squot; and &squot;target&squot; are non-NULL but the call to&n; *   hfs_brec_init() fails then &squot;*brec&squot; is NULL and -EIO is returned.&n; *   If &squot;brec&squot;, &squot;brec-&gt;tree&squot; and &squot;target&squot; are non-NULL and the tree is&n; *   non-empty then the tree is searched as follows:&n; *    If any call to hfs_brec_next() fails or returns a node that is&n; *     neither an index node nor a leaf node then -EIO is returned to&n; *     indicate that the B-tree or buffer-cache are corrupted.&n; *    If every record in the tree is &quot;greater than&quot; the given key&n; *     and the HFS_BFIND_EXACT bit of &squot;flags&squot; is set then -ENOENT is returned.&n; *    If every record in the tree is &quot;greater than&quot; the given key&n; *     and the HFS_BFIND_EXACT bit of &squot;flags&squot; is clear then &squot;brec&squot; refers&n; *     to the first leaf node in the tree and has a &squot;record&squot; field of&n; *     zero, and 1 is returned.&n; *    If a &quot;matching&quot; record is located with key &quot;equal to&quot; &squot;target&squot;&n; *     then the return value is 0 and &squot;brec&squot; indicates the record.&n; *    If a &quot;matching&quot; record is located with key &quot;greater than&quot; &squot;target&squot;&n; *     then the behavior is determined as follows:&n; *&t;If the HFS_BFIND_EXACT bit of &squot;flags&squot; is not set then 1 is returned&n; *       and &squot;brec&squot; refers to the &quot;matching&quot; record.&n; *&t;If the HFS_BFIND_EXACT bit of &squot;flags&squot; is set then -ENOENT is returned.&n; *    If the return value is non-negative and the HFS_BFIND_LOCK bit of&n; *     &squot;flags&squot; is set then hfs_brec_lock() is called on the bottom element&n; *     of &squot;brec&squot; before returning.&n; */
DECL|function|hfs_bfind
r_int
id|hfs_bfind
c_func
(paren
r_struct
id|hfs_brec
op_star
id|brec
comma
r_struct
id|hfs_btree
op_star
id|tree
comma
r_const
r_struct
id|hfs_bkey
op_star
id|target
comma
r_int
id|flags
)paren
(brace
r_struct
id|hfs_belem
op_star
id|curr
suffix:semicolon
r_struct
id|hfs_bkey
op_star
id|key
suffix:semicolon
r_struct
id|hfs_bnode
op_star
id|bn
suffix:semicolon
r_int
id|result
comma
id|ntype
suffix:semicolon
multiline_comment|/* check for invalid arguments */
r_if
c_cond
(paren
op_logical_neg
id|brec
op_logical_or
(paren
id|tree-&gt;magic
op_ne
id|HFS_BTREE_MAGIC
)paren
op_logical_or
op_logical_neg
id|target
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* check for empty tree */
r_if
c_cond
(paren
op_logical_neg
id|tree-&gt;root
op_logical_or
op_logical_neg
id|tree-&gt;bthNRecs
)paren
(brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
multiline_comment|/* start search at root of tree */
r_if
c_cond
(paren
op_logical_neg
(paren
id|curr
op_assign
id|hfs_brec_init
c_func
(paren
id|brec
comma
id|tree
comma
id|flags
)paren
)paren
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* traverse the tree */
r_do
(brace
id|bn
op_assign
id|curr-&gt;bnr.bn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|curr-&gt;record
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bfind: empty bnode&bslash;n&quot;
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* reverse linear search yielding largest key &quot;less&n;&t;&t;   than or equal to&quot; &squot;target&squot;.&n;&t;&t;   It is questionable whether a binary search would be&n;&t;&t;   significantly faster */
r_do
(brace
id|key
op_assign
id|belem_key
c_func
(paren
id|curr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|key-&gt;KeyLen
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bfind: empty key&bslash;n&quot;
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|result
op_assign
(paren
id|tree-&gt;compare
)paren
(paren
id|target
comma
id|key
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|result
OL
l_int|0
)paren
op_logical_and
(paren
op_decrement
id|curr-&gt;record
)paren
)paren
suffix:semicolon
id|ntype
op_assign
id|bn-&gt;ndType
suffix:semicolon
multiline_comment|/* see if all keys &gt; target */
r_if
c_cond
(paren
op_logical_neg
id|curr-&gt;record
)paren
(brace
r_if
c_cond
(paren
id|bn-&gt;ndBLink
)paren
(brace
multiline_comment|/* at a node other than the left-most at a&n;&t;&t;&t;&t;   given level it means the parent had an&n;&t;&t;&t;&t;   incorrect key for this child */
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bfind: corrupted b-tree %d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|ntohl
c_func
(paren
id|tree-&gt;entry.cnid
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|HFS_BFIND_EXACT
)paren
(brace
multiline_comment|/* we&squot;re not going to find it */
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ntype
op_eq
id|ndIndxNode
)paren
(brace
multiline_comment|/* since we are at the left-most node at&n;&t;&t;&t;&t;   the current level and looking for the&n;&t;&t;&t;&t;   predecessor of &squot;target&squot; keep going down */
id|curr-&gt;record
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we&squot;re at first leaf so fall through */
)brace
)brace
multiline_comment|/* get next node if necessary */
r_if
c_cond
(paren
(paren
id|ntype
op_eq
id|ndIndxNode
)paren
op_logical_and
op_logical_neg
(paren
id|curr
op_assign
id|hfs_brec_next
c_func
(paren
id|brec
)paren
)paren
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|ntype
op_eq
id|ndIndxNode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|key-&gt;KeyLen
OG
id|tree-&gt;bthKeyLen
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bfind: oversized key&bslash;n&quot;
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ntype
op_ne
id|ndLeafNode
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bfind: invalid node type %02x in node %d of &quot;
l_string|&quot;btree %d&bslash;n&quot;
comma
id|bn-&gt;ndType
comma
id|bn-&gt;node
comma
(paren
r_int
)paren
id|ntohl
c_func
(paren
id|tree-&gt;entry.cnid
)paren
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|HFS_BFIND_EXACT
)paren
op_logical_and
id|result
)paren
(brace
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|HFS_BPATH_MASK
)paren
)paren
(brace
id|hfs_brec_relse
c_func
(paren
id|brec
comma
id|brec-&gt;bottom
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|HFS_BFIND_LOCK
)paren
(brace
id|hfs_brec_lock
c_func
(paren
id|brec
comma
id|brec-&gt;bottom
)paren
suffix:semicolon
)brace
id|brec-&gt;key
op_assign
id|brec_key
c_func
(paren
id|brec
)paren
suffix:semicolon
id|brec-&gt;data
op_assign
id|bkey_record
c_func
(paren
id|brec-&gt;key
)paren
suffix:semicolon
r_return
id|result
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_bsucc()&n; *&n; * Description:&n; *   This function overwrites &squot;*brec&squot; with its successor in the B-tree,&n; *   obtaining the same type of access.&n; * Input Variable(s):&n; *   struct hfs_brec *brec: address of the (struct hfs_brec) to overwrite&n; *    with its successor&n; * Output Variable(s):&n; *   struct hfs_brec *brec: address of the successor of the original&n; *    &squot;*brec&squot; or to invalid data&n; * Returns:&n; *   int: 0 on success, or one of -EINVAL, -EIO, or -EINVAL on failure&n; * Preconditions:&n; *   &squot;brec&squot; pointers to a &quot;valid&quot; (struct hfs_brec)&n; * Postconditions:&n; *   If the given &squot;*brec&squot; is not &quot;valid&quot; -EINVAL is returned and&n; *    &squot;*brec&squot; is unchanged.&n; *   If the given &squot;brec&squot; is &quot;valid&quot; but has no successor then -ENOENT&n; *    is returned and &squot;*brec&squot; is invalid.&n; *   If a call to hfs_bnode_find() is necessary to find the successor,&n; *    but fails then -EIO is returned and &squot;*brec&squot; is invalid.&n; *   If none of the three previous conditions prevents finding the&n; *    successor of &squot;*brec&squot;, then 0 is returned, and &squot;*brec&squot; is overwritten&n; *    with the (struct hfs_brec) for its successor.&n; *   In the cases when &squot;*brec&squot; is invalid, the old records is freed.&n; */
DECL|function|hfs_bsucc
r_int
id|hfs_bsucc
c_func
(paren
r_struct
id|hfs_brec
op_star
id|brec
comma
r_int
id|count
)paren
(brace
r_struct
id|hfs_belem
op_star
id|belem
suffix:semicolon
r_struct
id|hfs_bnode
op_star
id|bn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|brec
op_logical_or
op_logical_neg
(paren
id|belem
op_assign
id|brec-&gt;bottom
)paren
op_logical_or
(paren
id|belem
op_ne
id|brec-&gt;top
)paren
op_logical_or
op_logical_neg
(paren
id|bn
op_assign
id|belem-&gt;bnr.bn
)paren
op_logical_or
(paren
id|bn-&gt;magic
op_ne
id|HFS_BNODE_MAGIC
)paren
op_logical_or
op_logical_neg
id|bn-&gt;tree
op_logical_or
(paren
id|bn-&gt;tree-&gt;magic
op_ne
id|HFS_BTREE_MAGIC
)paren
op_logical_or
op_logical_neg
id|hfs_buffer_ok
c_func
(paren
id|bn-&gt;buf
)paren
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bsucc: invalid/corrupt arguments.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
)paren
(brace
r_int
id|left
op_assign
id|bn-&gt;ndNRecs
op_minus
id|belem-&gt;record
suffix:semicolon
r_if
c_cond
(paren
id|left
OL
id|count
)paren
(brace
r_struct
id|hfs_bnode_ref
id|old
suffix:semicolon
id|hfs_u32
id|node
suffix:semicolon
multiline_comment|/* Advance to next node */
r_if
c_cond
(paren
op_logical_neg
(paren
id|node
op_assign
id|bn-&gt;ndFLink
)paren
)paren
(brace
id|hfs_brec_relse
c_func
(paren
id|brec
comma
id|belem
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|node
op_eq
id|bn-&gt;node
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bsucc: corrupt btree&bslash;n&quot;
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
id|brec
comma
id|belem
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|old
op_assign
id|belem-&gt;bnr
suffix:semicolon
id|belem-&gt;bnr
op_assign
id|hfs_bnode_find
c_func
(paren
id|brec-&gt;tree
comma
id|node
comma
id|belem-&gt;bnr.lock_type
)paren
suffix:semicolon
id|hfs_bnode_relse
c_func
(paren
op_amp
id|old
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bn
op_assign
id|belem-&gt;bnr.bn
)paren
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|belem-&gt;record
op_assign
l_int|1
suffix:semicolon
id|count
op_sub_assign
(paren
id|left
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|belem-&gt;record
op_add_assign
id|count
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|brec-&gt;key
op_assign
id|belem_key
c_func
(paren
id|belem
)paren
suffix:semicolon
id|brec-&gt;data
op_assign
id|bkey_record
c_func
(paren
id|brec-&gt;key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|brec-&gt;key-&gt;KeyLen
OG
id|brec-&gt;tree-&gt;bthKeyLen
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bsucc: oversized key&bslash;n&quot;
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
