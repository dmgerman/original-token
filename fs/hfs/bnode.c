multiline_comment|/*&n; * linux/fs/hfs/bnode.c&n; *&n; * Copyright (C) 1995-1997  Paul H. Hargrove&n; * This file may be distributed under the terms of the GNU Public License.&n; *&n; * This file contains the code to access nodes in the B-tree structure.&n; *&n; * &quot;XXX&quot; in a comment is a note to myself to consider changing something.&n; *&n; * In function preconditions the term &quot;valid&quot; applied to a pointer to&n; * a structure means that the pointer is non-NULL and the structure it&n; * points to has all fields initialized to consistent values.&n; *&n; * The code in this file initializes some structures which contain&n; * pointers by calling memset(&amp;foo, 0, sizeof(foo)).&n; * This produces the desired behavior only due to the non-ANSI&n; * assumption that the machine representation of NULL is all zeros.&n; */
macro_line|#include &quot;hfs_btree.h&quot;
multiline_comment|/*================ File-local variables ================*/
multiline_comment|/* debugging statistics */
macro_line|#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
DECL|variable|bnode_count
r_int
id|bnode_count
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*================ Global functions ================*/
multiline_comment|/*&n; * hfs_bnode_delete()&n; *&n; * Description:&n; *   This function is called to remove a bnode from the cache and&n; *   release its resources.&n; * Input Variable(s):&n; *   struct hfs_bnode *bn: Pointer to the (struct hfs_bnode) to be&n; *   removed from the cache.&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   void&n; * Preconditions:&n; *   &squot;bn&squot; points to a &quot;valid&quot; (struct hfs_bnode).&n; * Postconditions:&n; *   The node &squot;bn&squot; is removed from the cache, its memory freed and its&n; *   buffer (if any) released.&n; */
DECL|function|hfs_bnode_delete
r_void
id|hfs_bnode_delete
c_func
(paren
r_struct
id|hfs_bnode
op_star
id|bn
)paren
(brace
macro_line|#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
op_decrement
id|bnode_count
suffix:semicolon
macro_line|#endif
multiline_comment|/* join neighbors */
r_if
c_cond
(paren
id|bn-&gt;next
)paren
(brace
id|bn-&gt;next-&gt;prev
op_assign
id|bn-&gt;prev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bn-&gt;prev
)paren
(brace
id|bn-&gt;prev-&gt;next
op_assign
id|bn-&gt;next
suffix:semicolon
)brace
multiline_comment|/* fix cache slot if necessary */
r_if
c_cond
(paren
id|bhash
c_func
(paren
id|bn-&gt;tree
comma
id|bn-&gt;node
)paren
op_eq
id|bn
)paren
(brace
id|bhash
c_func
(paren
id|bn-&gt;tree
comma
id|bn-&gt;node
)paren
op_assign
id|bn-&gt;next
suffix:semicolon
)brace
multiline_comment|/* release resources */
id|hfs_buffer_put
c_func
(paren
id|bn-&gt;buf
)paren
suffix:semicolon
multiline_comment|/* safe: checks for NULL argument */
id|HFS_DELETE
c_func
(paren
id|bn
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_bnode_read()&n; *&n; * Description: &n; *   This function creates a (struct hfs_bnode) and, if appropriate,&n; *   inserts it in the cache.&n; * Input Variable(s):&n; *   struct hfs_bnode *bnode: pointer to the new bnode.&n; *   struct hfs_btree *tree: pointer to the (struct hfs_btree)&n; *    containing the desired node&n; *   hfs_u32 node: the number of the desired node.&n; *   int sticky: the value to assign to the &squot;sticky&squot; field.&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   (struct hfs_bnode *) pointing to the newly created bnode or NULL.&n; * Preconditions:&n; *   &squot;bnode&squot; points to a &quot;valid&quot; (struct hfs_bnode).&n; *   &squot;tree&squot; points to a &quot;valid&quot; (struct hfs_btree).&n; *   &squot;node&squot; is an existing node number in the B-tree.&n; * Postconditions:&n; *   The following are true of &squot;bnode&squot; upon return:&n; *    The &squot;magic&squot; field is set to indicate a valid (struct hfs_bnode). &n; *    The &squot;sticky&squot;, &squot;tree&squot; and &squot;node&squot; fields are initialized to the&n; *    values of the of the corresponding arguments.&n; *    If the &squot;sticky&squot; argument is zero then the fields &squot;prev&squot; and&n; *    &squot;next&squot; are initialized by inserting the (struct hfs_bnode) in the&n; *    linked list of the appropriate cache slot; otherwise they are&n; *    initialized to NULL.&n; *    The data is read from disk (or buffer cache) and the &squot;buf&squot; field&n; *    points to the buffer for that data.&n; *    If no other processes tried to access this node while this&n; *    process was waiting on disk I/O (if necessary) then the&n; *    remaining fields are zero (&squot;count&squot;, &squot;resrv&squot;, &squot;lock&squot;) or NULL&n; *    (&squot;wqueue&squot;, &squot;rqueue&squot;) corresponding to no accesses.&n; *    If there were access attempts during I/O then they were blocked&n; *    until the I/O was complete, and the fields &squot;count&squot;, &squot;resrv&squot;,&n; *    &squot;lock&squot;, &squot;wqueue&squot; and &squot;rqueue&squot; reflect the results of unblocking&n; *    those processes when the I/O was completed.&n; */
DECL|function|hfs_bnode_read
r_void
id|hfs_bnode_read
c_func
(paren
r_struct
id|hfs_bnode
op_star
id|bnode
comma
r_struct
id|hfs_btree
op_star
id|tree
comma
id|hfs_u32
id|node
comma
r_int
id|sticky
)paren
(brace
r_struct
id|NodeDescriptor
op_star
id|nd
suffix:semicolon
r_int
id|block
comma
id|lcv
suffix:semicolon
id|hfs_u16
id|curr
comma
id|prev
comma
id|limit
suffix:semicolon
multiline_comment|/* Initialize the structure */
id|memset
c_func
(paren
id|bnode
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|bnode
)paren
)paren
suffix:semicolon
id|bnode-&gt;magic
op_assign
id|HFS_BNODE_MAGIC
suffix:semicolon
id|bnode-&gt;tree
op_assign
id|tree
suffix:semicolon
id|bnode-&gt;node
op_assign
id|node
suffix:semicolon
id|bnode-&gt;sticky
op_assign
id|sticky
suffix:semicolon
id|hfs_init_waitqueue
c_func
(paren
op_amp
id|bnode-&gt;rqueue
)paren
suffix:semicolon
id|hfs_init_waitqueue
c_func
(paren
op_amp
id|bnode-&gt;wqueue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sticky
op_eq
id|HFS_NOT_STICKY
)paren
(brace
multiline_comment|/* Insert it in the cache if appropriate */
r_if
c_cond
(paren
(paren
id|bnode-&gt;next
op_assign
id|bhash
c_func
(paren
id|tree
comma
id|node
)paren
)paren
)paren
(brace
id|bnode-&gt;next-&gt;prev
op_assign
id|bnode
suffix:semicolon
)brace
id|bhash
c_func
(paren
id|tree
comma
id|node
)paren
op_assign
id|bnode
suffix:semicolon
)brace
multiline_comment|/* Make the bnode look like it is being&n;&t;   modified so other processes will wait for&n;&t;   the I/O to complete */
id|bnode-&gt;count
op_assign
id|bnode-&gt;resrv
op_assign
id|bnode-&gt;lock
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Read in the node, possibly causing a schedule()&n;&t;   call.  If the I/O fails then emit a warning.&t; Each&n;&t;   process that was waiting on the bnode (including&n;&t;   the current one) will notice the failure and&n;&t;   hfs_bnode_relse() the node.&t;The last hfs_bnode_relse()&n;&t;   will call hfs_bnode_delete() and discard the bnode.&t;*/
id|block
op_assign
id|hfs_extent_map
c_func
(paren
op_amp
id|tree-&gt;entry.u.file.data_fork
comma
id|node
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|block
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bnode_read: bad node number 0x%08x&bslash;n&quot;
comma
id|node
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hfs_buffer_ok
c_func
(paren
id|bnode-&gt;buf
op_assign
id|hfs_buffer_get
c_func
(paren
id|tree-&gt;sys_mdb
comma
id|block
comma
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/* read in the NodeDescriptor */
id|nd
op_assign
(paren
r_struct
id|NodeDescriptor
op_star
)paren
id|hfs_buffer_data
c_func
(paren
id|bnode-&gt;buf
)paren
suffix:semicolon
id|bnode-&gt;ndFLink
op_assign
id|hfs_get_hl
c_func
(paren
id|nd-&gt;ndFLink
)paren
suffix:semicolon
id|bnode-&gt;ndBLink
op_assign
id|hfs_get_hl
c_func
(paren
id|nd-&gt;ndBLink
)paren
suffix:semicolon
id|bnode-&gt;ndType
op_assign
id|nd-&gt;ndType
suffix:semicolon
id|bnode-&gt;ndNHeight
op_assign
id|nd-&gt;ndNHeight
suffix:semicolon
id|bnode-&gt;ndNRecs
op_assign
id|hfs_get_hs
c_func
(paren
id|nd-&gt;ndNRecs
)paren
suffix:semicolon
multiline_comment|/* verify the integrity of the node */
id|prev
op_assign
r_sizeof
(paren
r_struct
id|NodeDescriptor
)paren
suffix:semicolon
id|limit
op_assign
id|HFS_SECTOR_SIZE
op_minus
r_sizeof
(paren
id|hfs_u16
)paren
op_star
(paren
id|bnode-&gt;ndNRecs
op_plus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|lcv
op_assign
l_int|1
suffix:semicolon
id|lcv
op_le
(paren
id|bnode-&gt;ndNRecs
op_plus
l_int|1
)paren
suffix:semicolon
op_increment
id|lcv
)paren
(brace
id|curr
op_assign
id|hfs_get_hs
c_func
(paren
id|RECTBL
c_func
(paren
id|bnode
comma
id|lcv
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|curr
OL
id|prev
)paren
op_logical_or
(paren
id|curr
OG
id|limit
)paren
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bnode_read: corrupt node &quot;
l_string|&quot;number 0x%08x&bslash;n&quot;
comma
id|node
)paren
suffix:semicolon
id|hfs_buffer_put
c_func
(paren
id|bnode-&gt;buf
)paren
suffix:semicolon
id|bnode-&gt;buf
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|prev
op_assign
id|curr
suffix:semicolon
)brace
)brace
multiline_comment|/* Undo our fakery with the lock state and&n;&t;   hfs_wake_up() anyone who we managed to trick */
op_decrement
id|bnode-&gt;count
suffix:semicolon
id|bnode-&gt;resrv
op_assign
id|bnode-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|hfs_wake_up
c_func
(paren
op_amp
id|bnode-&gt;rqueue
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_bnode_lock()&n; *&n; * Description:&n; *   This function does the locking of a bnode.&n; * Input Variable(s):&n; *   struct hfs_bnode *bn: pointer to the (struct hfs_bnode) to lock&n; *   int lock_type: the type of lock desired&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   void&n; * Preconditions:&n; *   &squot;bn&squot; points to a &quot;valid&quot; (struct hfs_bnode).&n; *   &squot;lock_type&squot; is a valid hfs_lock_t&n; * Postconditions:&n; *   The &squot;count&squot; field of &squot;bn&squot; is incremented by one.  If &squot;lock_type&squot;&n; *   is HFS_LOCK_RESRV the &squot;resrv&squot; field is also incremented.&n; */
DECL|function|hfs_bnode_lock
r_void
id|hfs_bnode_lock
c_func
(paren
r_struct
id|hfs_bnode_ref
op_star
id|bnr
comma
r_int
id|lock_type
)paren
(brace
r_struct
id|hfs_bnode
op_star
id|bn
op_assign
id|bnr-&gt;bn
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lock_type
op_eq
id|bnr-&gt;lock_type
)paren
op_logical_or
op_logical_neg
id|bn
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bnr-&gt;lock_type
op_eq
id|HFS_LOCK_WRITE
)paren
(brace
id|hfs_bnode_commit
c_func
(paren
id|bnr-&gt;bn
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|lock_type
)paren
(brace
r_default
suffix:colon
r_goto
id|bail
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HFS_LOCK_READ
suffix:colon
multiline_comment|/* We may not obtain read access if any process is&n;&t;&t;   currently modifying or waiting to modify this node.&n;&t;&t;   If we can&squot;t obtain access we wait on the rqueue&n;&t;&t;   wait queue to be woken up by the modifying process&n;&t;&t;   when it relinquishes its lock. */
r_switch
c_cond
(paren
id|bnr-&gt;lock_type
)paren
(brace
r_default
suffix:colon
r_goto
id|bail
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HFS_LOCK_NONE
suffix:colon
r_while
c_loop
(paren
id|bn-&gt;lock
op_logical_or
id|waitqueue_active
c_func
(paren
op_amp
id|bn-&gt;wqueue
)paren
)paren
(brace
id|hfs_sleep_on
c_func
(paren
op_amp
id|bn-&gt;rqueue
)paren
suffix:semicolon
)brace
op_increment
id|bn-&gt;count
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|HFS_LOCK_RESRV
suffix:colon
multiline_comment|/* We may not obtain a reservation (read access with&n;&t;&t;   an option to write later), if any process currently&n;&t;&t;   holds a reservation on this node.  That includes&n;&t;&t;   any process which is currently modifying this node.&n;&t;&t;   If we can&squot;t obtain access, then we wait on the&n;&t;&t;   rqueue wait queue to e woken up by the&n;&t;&t;   reservation-holder when it calls hfs_bnode_relse. */
r_switch
c_cond
(paren
id|bnr-&gt;lock_type
)paren
(brace
r_default
suffix:colon
r_goto
id|bail
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HFS_LOCK_NONE
suffix:colon
r_while
c_loop
(paren
id|bn-&gt;resrv
)paren
(brace
id|hfs_sleep_on
c_func
(paren
op_amp
id|bn-&gt;rqueue
)paren
suffix:semicolon
)brace
id|bn-&gt;resrv
op_assign
l_int|1
suffix:semicolon
op_increment
id|bn-&gt;count
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HFS_LOCK_WRITE
suffix:colon
id|bn-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|hfs_wake_up
c_func
(paren
op_amp
id|bn-&gt;rqueue
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|HFS_LOCK_WRITE
suffix:colon
r_switch
c_cond
(paren
id|bnr-&gt;lock_type
)paren
(brace
r_default
suffix:colon
r_goto
id|bail
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HFS_LOCK_NONE
suffix:colon
r_while
c_loop
(paren
id|bn-&gt;resrv
)paren
(brace
id|hfs_sleep_on
c_func
(paren
op_amp
id|bn-&gt;rqueue
)paren
suffix:semicolon
)brace
id|bn-&gt;resrv
op_assign
l_int|1
suffix:semicolon
op_increment
id|bn-&gt;count
suffix:semicolon
r_case
id|HFS_LOCK_RESRV
suffix:colon
r_while
c_loop
(paren
id|bn-&gt;count
OG
l_int|1
)paren
(brace
id|hfs_sleep_on
c_func
(paren
op_amp
id|bn-&gt;wqueue
)paren
suffix:semicolon
)brace
id|bn-&gt;lock
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|HFS_LOCK_NONE
suffix:colon
r_switch
c_cond
(paren
id|bnr-&gt;lock_type
)paren
(brace
r_default
suffix:colon
r_goto
id|bail
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HFS_LOCK_READ
suffix:colon
multiline_comment|/* This process was reading this node.&t;If&n;&t;&t;&t;   there is now exactly one other process using&n;&t;&t;&t;   the node then hfs_wake_up() a (potentially&n;&t;&t;&t;   nonexistent) waiting process.  Note that I&n;&t;&t;&t;   refer to &quot;a&quot; process since the reservation&n;&t;&t;&t;   system ensures that only one process can&n;&t;&t;&t;   get itself on the wait queue.  */
r_if
c_cond
(paren
id|bn-&gt;count
op_eq
l_int|2
)paren
(brace
id|hfs_wake_up
c_func
(paren
op_amp
id|bn-&gt;wqueue
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|HFS_LOCK_WRITE
suffix:colon
multiline_comment|/* This process was modifying this node.&n;&t;&t;&t;   Unlock the node and fall-through to the&n;&t;&t;&t;   HFS_LOCK_RESRV case, since a &squot;reservation&squot;&n;&t;&t;&t;   is a prerequisite for HFS_LOCK_WRITE.  */
id|bn-&gt;lock
op_assign
l_int|0
suffix:semicolon
r_case
id|HFS_LOCK_RESRV
suffix:colon
multiline_comment|/* This process had placed a &squot;reservation&squot; on&n;&t;&t;&t;   this node, indicating an intention to&n;&t;&t;&t;   possibly modify the node.  We can get to&n;&t;&t;&t;   this spot directly (if the &squot;reservation&squot;&n;&t;&t;&t;   not converted to a HFS_LOCK_WRITE), or by&n;&t;&t;&t;   falling through from the above case if the&n;&t;&t;&t;   reservation was converted.&n;&t;&t;&t;   Since HFS_LOCK_RESRV and HFS_LOCK_WRITE&n;&t;&t;&t;   both block processes that want access&n;&t;&t;&t;   (HFS_LOCK_RESRV blocks other processes that&n;&t;&t;&t;   want reservations but allow HFS_LOCK_READ&n;&t;&t;&t;   accesses, while HFS_LOCK_WRITE must have&n;&t;&t;&t;   exclusive access and thus blocks both&n;&t;&t;&t;   types) we hfs_wake_up() any processes that&n;&t;&t;&t;   might be waiting for access.&t; If multiple&n;&t;&t;&t;   processes are waiting for a reservation&n;&t;&t;&t;   then the magic of process scheduling will&n;&t;&t;&t;   settle the dispute. */
id|bn-&gt;resrv
op_assign
l_int|0
suffix:semicolon
id|hfs_wake_up
c_func
(paren
op_amp
id|bn-&gt;rqueue
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
op_decrement
id|bn-&gt;count
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bnr-&gt;lock_type
op_assign
id|lock_type
suffix:semicolon
r_return
suffix:semicolon
id|bail
suffix:colon
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bnode_lock: invalid lock change: %d-&gt;%d.&bslash;n&quot;
comma
id|bnr-&gt;lock_type
comma
id|lock_type
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_bnode_relse()&n; *&n; * Description:&n; *   This function is called when a process is done using a bnode.  If&n; *   the proper conditions are met then we call hfs_bnode_delete() to remove&n; *   it from the cache.&t; If it is not deleted then we update its state&n; *   to reflect one less process using it.&n; * Input Variable(s):&n; *   struct hfs_bnode *bn: pointer to the (struct hfs_bnode) to release.&n; *   int lock_type: The type of lock held by the process releasing this node.&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   void&n; * Preconditions:&n; *   &squot;bn&squot; is NULL or points to a &quot;valid&quot; (struct hfs_bnode).&n; * Postconditions:&n; *   If &squot;bn&squot; meets the appropriate conditions (see below) then it is&n; *   kept in the cache and all fields are set to consistent values&n; *   which reflect one less process using the node than upon entry.&n; *   If &squot;bn&squot; does not meet the conditions then it is deleted (see&n; *   hfs_bnode_delete() for postconditions).&n; *   In either case, if &squot;lock_type&squot; is HFS_LOCK_WRITE&n; *   then the corresponding buffer is dirtied.&n; */
DECL|function|hfs_bnode_relse
r_void
id|hfs_bnode_relse
c_func
(paren
r_struct
id|hfs_bnode_ref
op_star
id|bnr
)paren
(brace
r_struct
id|hfs_bnode
op_star
id|bn
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bnr
op_logical_or
op_logical_neg
(paren
id|bn
op_assign
id|bnr-&gt;bn
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* We update the lock state of the node if it is still in use&n;&t;   or if it is &quot;sticky&quot; (such as the B-tree head and root).&n;&t;   Otherwise we just delete it.&t; */
r_if
c_cond
(paren
(paren
id|bn-&gt;count
OG
l_int|1
)paren
op_logical_or
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|bn-&gt;rqueue
)paren
)paren
op_logical_or
(paren
id|bn-&gt;sticky
op_ne
id|HFS_NOT_STICKY
)paren
)paren
(brace
id|hfs_bnode_lock
c_func
(paren
id|bnr
comma
id|HFS_LOCK_NONE
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* dirty buffer if we (might) have modified it */
r_if
c_cond
(paren
id|bnr-&gt;lock_type
op_eq
id|HFS_LOCK_WRITE
)paren
(brace
id|hfs_bnode_commit
c_func
(paren
id|bn
)paren
suffix:semicolon
)brace
id|hfs_bnode_delete
c_func
(paren
id|bn
)paren
suffix:semicolon
id|bnr-&gt;lock_type
op_assign
id|HFS_LOCK_NONE
suffix:semicolon
)brace
id|bnr-&gt;bn
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_bnode_find()&n; *&n; * Description:&n; *   This function is called to obtain a bnode.  The cache is&n; *   searched for the node.  If it not found there it is added to&n; *   the cache by hfs_bnode_read().  There are two special cases node=0&n; *   (the header node) and node=&squot;tree&squot;-&gt;bthRoot (the root node), in&n; *   which the nodes are obtained from fields of &squot;tree&squot; without&n; *   consulting or modifying the cache.&n; * Input Variable(s):&n; *   struct hfs_tree *tree: pointer to the (struct hfs_btree) from&n; *    which to get a node.&n; *   int node: the node number to get from &squot;tree&squot;.&n; *   int lock_type: The kind of access (HFS_LOCK_READ, or&n; *    HFS_LOCK_RESRV) to obtain to the node&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   (struct hfs_bnode_ref) Reference to the requested node.&n; * Preconditions:&n; *   &squot;tree&squot; points to a &quot;valid&quot; (struct hfs_btree).&n; * Postconditions:&n; *   If &squot;node&squot; refers to a valid node in &squot;tree&squot; and &squot;lock_type&squot; has&n; *   one of the values listed above and no I/O errors occur then the&n; *   value returned refers to a valid (struct hfs_bnode) corresponding&n; *   to the requested node with the requested access type.  The node&n; *   is also added to the cache if not previously present and not the&n; *   root or header.&n; *   If the conditions given above are not met, the bnode in the&n; *   returned reference is NULL.&n; */
DECL|function|hfs_bnode_find
r_struct
id|hfs_bnode_ref
id|hfs_bnode_find
c_func
(paren
r_struct
id|hfs_btree
op_star
id|tree
comma
id|hfs_u32
id|node
comma
r_int
id|lock_type
)paren
(brace
r_struct
id|hfs_bnode
op_star
id|bn
suffix:semicolon
r_struct
id|hfs_bnode
op_star
id|empty
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|hfs_bnode_ref
id|bnr
suffix:semicolon
id|bnr.lock_type
op_assign
id|HFS_LOCK_NONE
suffix:semicolon
id|bnr.bn
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bnode_find: %c %d:%d&bslash;n&quot;
comma
id|lock_type
op_eq
id|HFS_LOCK_READ
ques
c_cond
l_char|&squot;R&squot;
suffix:colon
(paren
id|lock_type
op_eq
id|HFS_LOCK_RESRV
ques
c_cond
l_char|&squot;V&squot;
suffix:colon
l_char|&squot;W&squot;
)paren
comma
(paren
r_int
)paren
id|ntohl
c_func
(paren
id|tree-&gt;entry.cnid
)paren
comma
id|node
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* check special cases */
r_if
c_cond
(paren
op_logical_neg
id|node
)paren
(brace
id|bn
op_assign
op_amp
id|tree-&gt;head
suffix:semicolon
r_goto
id|return_it
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|node
op_eq
id|tree-&gt;bthRoot
)paren
(brace
id|bn
op_assign
id|tree-&gt;root
suffix:semicolon
r_goto
id|return_it
suffix:semicolon
)brace
id|restart
suffix:colon
multiline_comment|/* look for the node in the cache. */
id|bn
op_assign
id|bhash
c_func
(paren
id|tree
comma
id|node
)paren
suffix:semicolon
r_while
c_loop
(paren
id|bn
op_logical_and
(paren
id|bn-&gt;magic
op_eq
id|HFS_BNODE_MAGIC
)paren
)paren
(brace
r_if
c_cond
(paren
id|bn-&gt;node
op_eq
id|node
)paren
(brace
r_goto
id|found_it
suffix:semicolon
)brace
id|bn
op_assign
id|bn-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|empty
)paren
(brace
macro_line|#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
op_increment
id|bnode_count
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|HFS_NEW
c_func
(paren
id|empty
)paren
)paren
(brace
r_goto
id|restart
suffix:semicolon
)brace
r_return
id|bnr
suffix:semicolon
)brace
id|bn
op_assign
id|empty
suffix:semicolon
id|hfs_bnode_read
c_func
(paren
id|bn
comma
id|tree
comma
id|node
comma
id|HFS_NOT_STICKY
)paren
suffix:semicolon
r_goto
id|return_it
suffix:semicolon
id|found_it
suffix:colon
multiline_comment|/* check validity */
r_if
c_cond
(paren
id|bn-&gt;magic
op_ne
id|HFS_BNODE_MAGIC
)paren
(brace
multiline_comment|/* If we find a corrupt bnode then we return&n;&t;&t;   NULL.  However, we don&squot;t try to remove it&n;&t;&t;   from the cache or release its resources&n;&t;&t;   since we have no idea what kind of trouble&n;&t;&t;   we could get into that way. */
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bnode_find: bnode cache is corrupt.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|bnr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|empty
)paren
(brace
macro_line|#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
op_decrement
id|bnode_count
suffix:semicolon
macro_line|#endif
id|HFS_DELETE
c_func
(paren
id|empty
)paren
suffix:semicolon
)brace
id|return_it
suffix:colon
multiline_comment|/* Wait our turn */
id|bnr.bn
op_assign
id|bn
suffix:semicolon
id|hfs_bnode_lock
c_func
(paren
op_amp
id|bnr
comma
id|lock_type
)paren
suffix:semicolon
multiline_comment|/* Check for failure to read the node from disk */
r_if
c_cond
(paren
op_logical_neg
id|hfs_buffer_ok
c_func
(paren
id|bn-&gt;buf
)paren
)paren
(brace
id|hfs_bnode_relse
c_func
(paren
op_amp
id|bnr
)paren
suffix:semicolon
)brace
macro_line|#if defined(DEBUG_BNODES) || defined(DEBUG_ALL)
r_if
c_cond
(paren
op_logical_neg
id|bnr.bn
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bnode_find: failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bnode_find: use %d(%d) lvl %d [%d]&bslash;n&quot;
comma
id|bn-&gt;count
comma
id|bn-&gt;buf-&gt;b_count
comma
id|bn-&gt;ndNHeight
comma
id|bnode_count
)paren
suffix:semicolon
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_bnode_find: blnk %u flnk %u recs %u&bslash;n&quot;
comma
id|bn-&gt;ndBLink
comma
id|bn-&gt;ndFLink
comma
id|bn-&gt;ndNRecs
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|bnr
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_bnode_commit()&n; *&n; * Called to write a possibly dirty bnode back to disk.&n; */
DECL|function|hfs_bnode_commit
r_void
id|hfs_bnode_commit
c_func
(paren
r_struct
id|hfs_bnode
op_star
id|bn
)paren
(brace
r_if
c_cond
(paren
id|hfs_buffer_ok
c_func
(paren
id|bn-&gt;buf
)paren
)paren
(brace
r_struct
id|NodeDescriptor
op_star
id|nd
suffix:semicolon
id|nd
op_assign
(paren
r_struct
id|NodeDescriptor
op_star
)paren
id|hfs_buffer_data
c_func
(paren
id|bn-&gt;buf
)paren
suffix:semicolon
id|hfs_put_hl
c_func
(paren
id|bn-&gt;ndFLink
comma
id|nd-&gt;ndFLink
)paren
suffix:semicolon
id|hfs_put_hl
c_func
(paren
id|bn-&gt;ndBLink
comma
id|nd-&gt;ndBLink
)paren
suffix:semicolon
id|nd-&gt;ndType
op_assign
id|bn-&gt;ndType
suffix:semicolon
id|nd-&gt;ndNHeight
op_assign
id|bn-&gt;ndNHeight
suffix:semicolon
id|hfs_put_hs
c_func
(paren
id|bn-&gt;ndNRecs
comma
id|nd-&gt;ndNRecs
)paren
suffix:semicolon
id|hfs_buffer_dirty
c_func
(paren
id|bn-&gt;buf
)paren
suffix:semicolon
multiline_comment|/* increment write count */
id|hfs_mdb_dirty
c_func
(paren
id|bn-&gt;tree-&gt;sys_mdb
)paren
suffix:semicolon
)brace
)brace
eof
