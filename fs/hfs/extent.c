multiline_comment|/*&n; * linux/fs/hfs/extent.c&n; *&n; * Copyright (C) 1995-1997  Paul H. Hargrove&n; * This file may be distributed under the terms of the GNU Public License.&n; *&n; * This file contains the functions related to the extents B-tree.&n; *&n; * &quot;XXX&quot; in a comment is a note to myself to consider changing something.&n; *&n; * In function preconditions the term &quot;valid&quot; applied to a pointer to&n; * a structure means that the pointer is non-NULL and the structure it&n; * points to has all fields initialized to consistent values.&n; */
macro_line|#include &quot;hfs.h&quot;
multiline_comment|/*================ File-local data type ================*/
multiline_comment|/* An extent record on disk*/
DECL|struct|hfs_raw_extent
r_struct
id|hfs_raw_extent
(brace
DECL|member|block1
id|hfs_word_t
id|block1
suffix:semicolon
DECL|member|length1
id|hfs_word_t
id|length1
suffix:semicolon
DECL|member|block2
id|hfs_word_t
id|block2
suffix:semicolon
DECL|member|length2
id|hfs_word_t
id|length2
suffix:semicolon
DECL|member|block3
id|hfs_word_t
id|block3
suffix:semicolon
DECL|member|length3
id|hfs_word_t
id|length3
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*================ File-local functions ================*/
multiline_comment|/*&n; * build_key&n; */
DECL|function|build_key
r_static
r_inline
r_void
id|build_key
c_func
(paren
r_struct
id|hfs_ext_key
op_star
id|key
comma
r_const
r_struct
id|hfs_fork
op_star
id|fork
comma
id|hfs_u16
id|block
)paren
(brace
id|key-&gt;KeyLen
op_assign
l_int|7
suffix:semicolon
id|key-&gt;FkType
op_assign
id|fork-&gt;fork
suffix:semicolon
id|hfs_put_nl
c_func
(paren
id|fork-&gt;entry-&gt;cnid
comma
id|key-&gt;FNum
)paren
suffix:semicolon
id|hfs_put_hs
c_func
(paren
id|block
comma
id|key-&gt;FABN
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * lock_bitmap()&n; *&n; * Get an exclusive lock on the B-tree bitmap.&n; */
DECL|function|lock_bitmap
r_static
r_inline
r_void
id|lock_bitmap
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
)paren
(brace
r_while
c_loop
(paren
id|mdb-&gt;bitmap_lock
)paren
(brace
id|hfs_sleep_on
c_func
(paren
op_amp
id|mdb-&gt;bitmap_wait
)paren
suffix:semicolon
)brace
id|mdb-&gt;bitmap_lock
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * unlock_bitmap()&n; *&n; * Relinquish an exclusive lock on the B-tree bitmap.&n; */
DECL|function|unlock_bitmap
r_static
r_inline
r_void
id|unlock_bitmap
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
)paren
(brace
id|mdb-&gt;bitmap_lock
op_assign
l_int|0
suffix:semicolon
id|hfs_wake_up
c_func
(paren
op_amp
id|mdb-&gt;bitmap_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * dump_ext()&n; *&n; * prints the content of a extent for debugging purposes.&n; */
macro_line|#if defined(DEBUG_EXTENTS) || defined(DEBUG_ALL)
DECL|function|dump_ext
r_static
r_void
id|dump_ext
c_func
(paren
r_const
r_char
op_star
id|msg
comma
r_const
r_struct
id|hfs_extent
op_star
id|e
)paren
(brace
r_if
c_cond
(paren
id|e
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;%s (%d-%d) (%d-%d) (%d-%d)&bslash;n&quot;
comma
id|msg
comma
id|e-&gt;start
comma
id|e-&gt;start
op_plus
id|e-&gt;length
(braket
l_int|0
)braket
op_minus
l_int|1
comma
id|e-&gt;start
op_plus
id|e-&gt;length
(braket
l_int|0
)braket
comma
id|e-&gt;start
op_plus
id|e-&gt;length
(braket
l_int|0
)braket
op_plus
id|e-&gt;length
(braket
l_int|1
)braket
op_minus
l_int|1
comma
id|e-&gt;start
op_plus
id|e-&gt;length
(braket
l_int|0
)braket
op_plus
id|e-&gt;length
(braket
l_int|1
)braket
comma
id|e-&gt;end
)paren
suffix:semicolon
)brace
r_else
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;%s NULL&bslash;n&quot;
comma
id|msg
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
DECL|macro|dump_ext
mdefine_line|#define dump_ext(A,B) {}
macro_line|#endif
multiline_comment|/*&n; * read_extent()&n; * &n; * Initializes a (struct hfs_extent) from a (struct hfs_raw_extent) and&n; * the number of the starting block for the extent.&n; *&n; * Note that the callers must check that to,from != NULL&n; */
DECL|function|read_extent
r_static
r_void
id|read_extent
c_func
(paren
r_struct
id|hfs_extent
op_star
id|to
comma
r_const
r_struct
id|hfs_raw_extent
op_star
id|from
comma
id|hfs_u16
id|start
)paren
(brace
id|to-&gt;start
op_assign
id|start
suffix:semicolon
id|to-&gt;block
(braket
l_int|0
)braket
op_assign
id|hfs_get_hs
c_func
(paren
id|from-&gt;block1
)paren
suffix:semicolon
id|to-&gt;length
(braket
l_int|0
)braket
op_assign
id|hfs_get_hs
c_func
(paren
id|from-&gt;length1
)paren
suffix:semicolon
id|to-&gt;block
(braket
l_int|1
)braket
op_assign
id|hfs_get_hs
c_func
(paren
id|from-&gt;block2
)paren
suffix:semicolon
id|to-&gt;length
(braket
l_int|1
)braket
op_assign
id|hfs_get_hs
c_func
(paren
id|from-&gt;length2
)paren
suffix:semicolon
id|to-&gt;block
(braket
l_int|2
)braket
op_assign
id|hfs_get_hs
c_func
(paren
id|from-&gt;block3
)paren
suffix:semicolon
id|to-&gt;length
(braket
l_int|2
)braket
op_assign
id|hfs_get_hs
c_func
(paren
id|from-&gt;length3
)paren
suffix:semicolon
id|to-&gt;end
op_assign
id|start
op_plus
id|to-&gt;length
(braket
l_int|0
)braket
op_plus
id|to-&gt;length
(braket
l_int|1
)braket
op_plus
id|to-&gt;length
(braket
l_int|2
)braket
op_minus
l_int|1
suffix:semicolon
id|to-&gt;next
op_assign
id|to-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|to-&gt;count
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * write_extent()&n; * &n; * Initializes a (struct hfs_raw_extent) from a (struct hfs_extent).&n; *&n; * Note that the callers must check that to,from != NULL&n; */
DECL|function|write_extent
r_static
r_void
id|write_extent
c_func
(paren
r_struct
id|hfs_raw_extent
op_star
id|to
comma
r_const
r_struct
id|hfs_extent
op_star
id|from
)paren
(brace
id|hfs_put_hs
c_func
(paren
id|from-&gt;block
(braket
l_int|0
)braket
comma
id|to-&gt;block1
)paren
suffix:semicolon
id|hfs_put_hs
c_func
(paren
id|from-&gt;length
(braket
l_int|0
)braket
comma
id|to-&gt;length1
)paren
suffix:semicolon
id|hfs_put_hs
c_func
(paren
id|from-&gt;block
(braket
l_int|1
)braket
comma
id|to-&gt;block2
)paren
suffix:semicolon
id|hfs_put_hs
c_func
(paren
id|from-&gt;length
(braket
l_int|1
)braket
comma
id|to-&gt;length2
)paren
suffix:semicolon
id|hfs_put_hs
c_func
(paren
id|from-&gt;block
(braket
l_int|2
)braket
comma
id|to-&gt;block3
)paren
suffix:semicolon
id|hfs_put_hs
c_func
(paren
id|from-&gt;length
(braket
l_int|2
)braket
comma
id|to-&gt;length3
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * decode_extent()&n; *&n; * Given an extent record and allocation block offset into the file,&n; * return the number of the corresponding allocation block on disk,&n; * or -1 if the desired block is not mapped by the given extent.&n; *&n; * Note that callers must check that extent != NULL&n; */
DECL|function|decode_extent
r_static
r_int
id|decode_extent
c_func
(paren
r_const
r_struct
id|hfs_extent
op_star
id|extent
comma
r_int
id|block
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|extent
op_logical_or
(paren
id|block
OL
id|extent-&gt;start
)paren
op_logical_or
(paren
id|block
OG
id|extent-&gt;end
)paren
op_logical_or
(paren
id|extent-&gt;end
op_eq
(paren
id|hfs_u16
)paren
(paren
id|extent-&gt;start
op_minus
l_int|1
)paren
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|block
op_sub_assign
id|extent-&gt;start
suffix:semicolon
r_if
c_cond
(paren
id|block
OL
id|extent-&gt;length
(braket
l_int|0
)braket
)paren
(brace
r_return
id|block
op_plus
id|extent-&gt;block
(braket
l_int|0
)braket
suffix:semicolon
)brace
id|block
op_sub_assign
id|extent-&gt;length
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|block
OL
id|extent-&gt;length
(braket
l_int|1
)braket
)paren
(brace
r_return
id|block
op_plus
id|extent-&gt;block
(braket
l_int|1
)braket
suffix:semicolon
)brace
r_return
id|block
op_plus
id|extent-&gt;block
(braket
l_int|2
)braket
op_minus
id|extent-&gt;length
(braket
l_int|1
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * relse_ext()&n; *&n; * Reduce the reference count of an in-core extent record by one,&n; * removing it from memory if the count falls to zero.&n; */
DECL|function|relse_ext
r_static
r_void
id|relse_ext
c_func
(paren
r_struct
id|hfs_extent
op_star
id|ext
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|ext-&gt;count
op_logical_or
op_logical_neg
id|ext-&gt;start
)paren
(brace
r_return
suffix:semicolon
)brace
id|ext-&gt;prev-&gt;next
op_assign
id|ext-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|ext-&gt;next
)paren
(brace
id|ext-&gt;next-&gt;prev
op_assign
id|ext-&gt;prev
suffix:semicolon
)brace
id|HFS_DELETE
c_func
(paren
id|ext
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * set_cache()&n; * &n; * Changes the &squot;cache&squot; field of the fork.&n; */
DECL|function|set_cache
r_static
r_inline
r_void
id|set_cache
c_func
(paren
r_struct
id|hfs_fork
op_star
id|fork
comma
r_struct
id|hfs_extent
op_star
id|ext
)paren
(brace
r_struct
id|hfs_extent
op_star
id|tmp
op_assign
id|fork-&gt;cache
suffix:semicolon
op_increment
id|ext-&gt;count
suffix:semicolon
id|fork-&gt;cache
op_assign
id|ext
suffix:semicolon
id|relse_ext
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * find_ext()&n; *&n; * Given a pointer to a (struct hfs_file) and an allocation block&n; * number in the file, find the extent record containing that block.&n; * Returns a pointer to the extent record on success or NULL on failure.&n; * The &squot;cache&squot; field of &squot;fil&squot; also points to the extent so it has a&n; * reference count of at least 2.&n; *&n; * Callers must check that fil != NULL&n; */
DECL|function|find_ext
r_static
r_struct
id|hfs_extent
op_star
id|find_ext
c_func
(paren
r_struct
id|hfs_fork
op_star
id|fork
comma
r_int
id|alloc_block
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|entry
op_assign
id|fork-&gt;entry
suffix:semicolon
r_struct
id|hfs_btree
op_star
id|tr
op_assign
id|entry-&gt;mdb-&gt;ext_tree
suffix:semicolon
r_struct
id|hfs_ext_key
id|target
comma
op_star
id|key
suffix:semicolon
r_struct
id|hfs_brec
id|brec
suffix:semicolon
r_struct
id|hfs_extent
op_star
id|ext
comma
op_star
id|ptr
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|alloc_block
OL
l_int|0
)paren
(brace
id|ext
op_assign
op_amp
id|fork-&gt;first
suffix:semicolon
r_goto
id|found
suffix:semicolon
)brace
id|ext
op_assign
id|fork-&gt;cache
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ext
op_logical_or
(paren
id|alloc_block
OL
id|ext-&gt;start
)paren
)paren
(brace
id|ext
op_assign
op_amp
id|fork-&gt;first
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ext-&gt;next
op_logical_and
(paren
id|alloc_block
OG
id|ext-&gt;end
)paren
)paren
(brace
id|ext
op_assign
id|ext-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|alloc_block
op_le
id|ext-&gt;end
)paren
op_logical_and
(paren
id|alloc_block
op_ge
id|ext-&gt;start
)paren
)paren
(brace
r_goto
id|found
suffix:semicolon
)brace
multiline_comment|/* time to read more extents */
r_if
c_cond
(paren
op_logical_neg
id|HFS_NEW
c_func
(paren
id|ext
)paren
)paren
(brace
r_goto
id|bail3
suffix:semicolon
)brace
id|build_key
c_func
(paren
op_amp
id|target
comma
id|fork
comma
id|alloc_block
)paren
suffix:semicolon
id|tmp
op_assign
id|hfs_bfind
c_func
(paren
op_amp
id|brec
comma
id|tr
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|target
)paren
comma
id|HFS_BFIND_READ_LE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
(brace
r_goto
id|bail2
suffix:semicolon
)brace
id|key
op_assign
(paren
r_struct
id|hfs_ext_key
op_star
)paren
id|brec.key
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hfs_get_nl
c_func
(paren
id|key-&gt;FNum
)paren
op_ne
id|hfs_get_nl
c_func
(paren
id|target.FNum
)paren
)paren
op_logical_or
(paren
id|key-&gt;FkType
op_ne
id|fork-&gt;fork
)paren
)paren
(brace
r_goto
id|bail1
suffix:semicolon
)brace
id|read_extent
c_func
(paren
id|ext
comma
id|brec.data
comma
id|hfs_get_hs
c_func
(paren
id|key-&gt;FABN
)paren
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
op_amp
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|alloc_block
OG
id|ext-&gt;end
)paren
op_logical_and
(paren
id|alloc_block
OL
id|ext-&gt;start
)paren
)paren
(brace
multiline_comment|/* something strange happened */
r_goto
id|bail2
suffix:semicolon
)brace
id|ptr
op_assign
id|fork-&gt;cache
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
op_logical_or
(paren
id|alloc_block
OL
id|ptr-&gt;start
)paren
)paren
(brace
id|ptr
op_assign
op_amp
id|fork-&gt;first
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ptr-&gt;next
op_logical_and
(paren
id|alloc_block
OG
id|ptr-&gt;end
)paren
)paren
(brace
id|ptr
op_assign
id|ptr-&gt;next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ext-&gt;start
op_eq
id|ptr-&gt;start
)paren
(brace
multiline_comment|/* somebody beat us to it. */
id|HFS_DELETE
c_func
(paren
id|ext
)paren
suffix:semicolon
id|ext
op_assign
id|ptr
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ext-&gt;start
OL
id|ptr-&gt;start
)paren
(brace
multiline_comment|/* insert just before ptr */
id|ptr-&gt;prev-&gt;next
op_assign
id|ext
suffix:semicolon
id|ext-&gt;prev
op_assign
id|ptr-&gt;prev
suffix:semicolon
id|ext-&gt;next
op_assign
id|ptr
suffix:semicolon
id|ptr-&gt;prev
op_assign
id|ext
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* insert at end */
id|ptr-&gt;next
op_assign
id|ext
suffix:semicolon
id|ext-&gt;prev
op_assign
id|ptr
suffix:semicolon
)brace
id|found
suffix:colon
op_increment
id|ext-&gt;count
suffix:semicolon
multiline_comment|/* for return value */
id|set_cache
c_func
(paren
id|fork
comma
id|ext
)paren
suffix:semicolon
r_return
id|ext
suffix:semicolon
id|bail1
suffix:colon
id|hfs_brec_relse
c_func
(paren
op_amp
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
id|bail2
suffix:colon
id|HFS_DELETE
c_func
(paren
id|ext
)paren
suffix:semicolon
id|bail3
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * delete_extent()&n; *&n; * Description:&n; *   Deletes an extent record from a fork, reducing its physical length.&n; * Input Variable(s):&n; *   struct hfs_fork *fork: the fork&n; *   struct hfs_extent *ext: the current last extent for &squot;fork&squot;&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   void&n; * Preconditions:&n; *   &squot;fork&squot; points to a valid (struct hfs_fork)&n; *   &squot;ext&squot; point to a valid (struct hfs_extent) which is the last in &squot;fork&squot;&n; *    and which is not also the first extent in &squot;fork&squot;.&n; * Postconditions:&n; *   The extent record has been removed if possible, and a warning has been&n; *   printed otherwise.&n; */
DECL|function|delete_extent
r_static
r_void
id|delete_extent
c_func
(paren
r_struct
id|hfs_fork
op_star
id|fork
comma
r_struct
id|hfs_extent
op_star
id|ext
)paren
(brace
r_struct
id|hfs_mdb
op_star
id|mdb
op_assign
id|fork-&gt;entry-&gt;mdb
suffix:semicolon
r_struct
id|hfs_ext_key
id|key
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|fork-&gt;cache
op_eq
id|ext
)paren
(brace
id|set_cache
c_func
(paren
id|fork
comma
id|ext-&gt;prev
)paren
suffix:semicolon
)brace
id|ext-&gt;prev-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ext-&gt;count
op_ne
l_int|1
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_truncate: extent has count %d.&bslash;n&quot;
comma
id|ext-&gt;count
)paren
suffix:semicolon
)brace
id|lock_bitmap
c_func
(paren
id|mdb
)paren
suffix:semicolon
id|error
op_assign
id|hfs_clear_vbm_bits
c_func
(paren
id|mdb
comma
id|ext-&gt;block
(braket
l_int|2
)braket
comma
id|ext-&gt;length
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_truncate: error %d freeing blocks.&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
)brace
id|error
op_assign
id|hfs_clear_vbm_bits
c_func
(paren
id|mdb
comma
id|ext-&gt;block
(braket
l_int|1
)braket
comma
id|ext-&gt;length
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_truncate: error %d freeing blocks.&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
)brace
id|error
op_assign
id|hfs_clear_vbm_bits
c_func
(paren
id|mdb
comma
id|ext-&gt;block
(braket
l_int|0
)braket
comma
id|ext-&gt;length
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_truncate: error %d freeing blocks.&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
)brace
id|unlock_bitmap
c_func
(paren
id|mdb
)paren
suffix:semicolon
id|build_key
c_func
(paren
op_amp
id|key
comma
id|fork
comma
id|ext-&gt;start
)paren
suffix:semicolon
id|error
op_assign
id|hfs_bdelete
c_func
(paren
id|mdb-&gt;ext_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|key
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_truncate: error %d deleting an extent.&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
)brace
id|HFS_DELETE
c_func
(paren
id|ext
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * new_extent()&n; *&n; * Description:&n; *   Adds a new extent record to a fork, extending its physical length.&n; * Input Variable(s):&n; *   struct hfs_fork *fork: the fork to extend&n; *   struct hfs_extent *ext: the current last extent for &squot;fork&squot;&n; *   hfs_u16 ablock: the number of allocation blocks in &squot;fork&squot;.&n; *   hfs_u16 start: first allocation block to add to &squot;fork&squot;.&n; *   hfs_u16 len: the number of allocation blocks to add to &squot;fork&squot;.&n; *   hfs_u32 ablksz: number of sectors in an allocation block.&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   (struct hfs_extent *) the new extent or NULL&n; * Preconditions:&n; *   &squot;fork&squot; points to a valid (struct hfs_fork)&n; *   &squot;ext&squot; point to a valid (struct hfs_extent) which is the last in &squot;fork&squot;&n; *   &squot;ablock&squot;, &squot;start&squot;, &squot;len&squot; and &squot;ablksz&squot; are what they claim to be.&n; * Postconditions:&n; *   If NULL is returned then no changes have been made to &squot;fork&squot;.&n; *   If the return value is non-NULL that it is the extent that has been&n; *   added to &squot;fork&squot; both in memory and on disk.  The &squot;psize&squot; field of&n; *   &squot;fork&squot; has been updated to reflect the new physical size.&n; */
DECL|function|new_extent
r_static
r_struct
id|hfs_extent
op_star
id|new_extent
c_func
(paren
r_struct
id|hfs_fork
op_star
id|fork
comma
r_struct
id|hfs_extent
op_star
id|ext
comma
id|hfs_u16
id|ablock
comma
id|hfs_u16
id|start
comma
id|hfs_u16
id|len
comma
id|hfs_u16
id|ablksz
)paren
(brace
r_struct
id|hfs_raw_extent
id|raw
suffix:semicolon
r_struct
id|hfs_ext_key
id|key
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|fork-&gt;entry-&gt;cnid
op_eq
id|htonl
c_func
(paren
id|HFS_EXT_CNID
)paren
)paren
(brace
multiline_comment|/* Limit extents tree to the record in the MDB */
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|HFS_NEW
c_func
(paren
id|ext-&gt;next
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|ext-&gt;next-&gt;prev
op_assign
id|ext
suffix:semicolon
id|ext-&gt;next-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|ext
op_assign
id|ext-&gt;next
suffix:semicolon
id|relse_ext
c_func
(paren
id|ext-&gt;prev
)paren
suffix:semicolon
id|ext-&gt;start
op_assign
id|ablock
suffix:semicolon
id|ext-&gt;block
(braket
l_int|0
)braket
op_assign
id|start
suffix:semicolon
id|ext-&gt;length
(braket
l_int|0
)braket
op_assign
id|len
suffix:semicolon
id|ext-&gt;block
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|ext-&gt;length
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|ext-&gt;block
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|ext-&gt;length
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|ext-&gt;end
op_assign
id|ablock
op_plus
id|len
op_minus
l_int|1
suffix:semicolon
id|ext-&gt;count
op_assign
l_int|1
suffix:semicolon
id|write_extent
c_func
(paren
op_amp
id|raw
comma
id|ext
)paren
suffix:semicolon
id|build_key
c_func
(paren
op_amp
id|key
comma
id|fork
comma
id|ablock
)paren
suffix:semicolon
id|error
op_assign
id|hfs_binsert
c_func
(paren
id|fork-&gt;entry-&gt;mdb-&gt;ext_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|key
)paren
comma
op_amp
id|raw
comma
r_sizeof
(paren
id|raw
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ext-&gt;prev-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|HFS_DELETE
c_func
(paren
id|ext
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|set_cache
c_func
(paren
id|fork
comma
id|ext
)paren
suffix:semicolon
r_return
id|ext
suffix:semicolon
)brace
multiline_comment|/*&n; * update_ext()&n; *&n; * Given a (struct hfs_fork) write an extent record back to disk.&n; */
DECL|function|update_ext
r_static
r_void
id|update_ext
c_func
(paren
r_struct
id|hfs_fork
op_star
id|fork
comma
r_struct
id|hfs_extent
op_star
id|ext
)paren
(brace
r_struct
id|hfs_ext_key
id|target
suffix:semicolon
r_struct
id|hfs_brec
id|brec
suffix:semicolon
r_if
c_cond
(paren
id|ext-&gt;start
)paren
(brace
id|build_key
c_func
(paren
op_amp
id|target
comma
id|fork
comma
id|ext-&gt;start
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hfs_bfind
c_func
(paren
op_amp
id|brec
comma
id|fork-&gt;entry-&gt;mdb-&gt;ext_tree
comma
id|HFS_BKEY
c_func
(paren
op_amp
id|target
)paren
comma
id|HFS_BFIND_WRITE
)paren
)paren
(brace
id|write_extent
c_func
(paren
id|brec.data
comma
id|ext
)paren
suffix:semicolon
id|hfs_brec_relse
c_func
(paren
op_amp
id|brec
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * zero_blocks()&n; * &n; * Zeros-out &squot;num&squot; allocation blocks beginning with &squot;start&squot;.&n; */
DECL|function|zero_blocks
r_static
r_int
id|zero_blocks
c_func
(paren
r_struct
id|hfs_mdb
op_star
id|mdb
comma
r_int
id|start
comma
r_int
id|num
)paren
(brace
id|hfs_buffer
id|buf
suffix:semicolon
r_int
id|end
suffix:semicolon
r_int
id|j
suffix:semicolon
id|start
op_assign
id|mdb-&gt;fs_start
op_plus
id|start
op_star
id|mdb-&gt;alloc_blksz
suffix:semicolon
id|end
op_assign
id|start
op_plus
id|num
op_star
id|mdb-&gt;alloc_blksz
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|start
suffix:semicolon
id|j
OL
id|end
suffix:semicolon
op_increment
id|j
)paren
(brace
r_if
c_cond
(paren
id|hfs_buffer_ok
c_func
(paren
id|buf
op_assign
id|hfs_buffer_get
c_func
(paren
id|mdb-&gt;sys_mdb
comma
id|j
comma
l_int|0
)paren
)paren
)paren
(brace
id|memset
c_func
(paren
id|hfs_buffer_data
c_func
(paren
id|buf
)paren
comma
l_int|0
comma
id|HFS_SECTOR_SIZE
)paren
suffix:semicolon
id|hfs_buffer_dirty
c_func
(paren
id|buf
)paren
suffix:semicolon
id|hfs_buffer_put
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * shrink_fork()&n; *&n; * Try to remove enough allocation blocks from &squot;fork&squot;&n; * so that it is &squot;ablocks&squot; allocation blocks long. &n; */
DECL|function|shrink_fork
r_static
r_void
id|shrink_fork
c_func
(paren
r_struct
id|hfs_fork
op_star
id|fork
comma
r_int
id|ablocks
)paren
(brace
r_struct
id|hfs_mdb
op_star
id|mdb
op_assign
id|fork-&gt;entry-&gt;mdb
suffix:semicolon
r_struct
id|hfs_extent
op_star
id|ext
suffix:semicolon
r_int
id|i
comma
id|error
comma
id|next
comma
id|count
suffix:semicolon
id|hfs_u32
id|ablksz
op_assign
id|mdb-&gt;alloc_blksz
suffix:semicolon
id|next
op_assign
(paren
id|fork-&gt;psize
op_div
id|ablksz
)paren
op_minus
l_int|1
suffix:semicolon
id|ext
op_assign
id|find_ext
c_func
(paren
id|fork
comma
id|next
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ext
op_logical_and
id|ext-&gt;start
op_logical_and
(paren
id|ext-&gt;start
op_ge
id|ablocks
)paren
)paren
(brace
id|next
op_assign
id|ext-&gt;start
op_minus
l_int|1
suffix:semicolon
id|delete_extent
c_func
(paren
id|fork
comma
id|ext
)paren
suffix:semicolon
id|ext
op_assign
id|find_ext
c_func
(paren
id|fork
comma
id|next
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ext
)paren
(brace
id|fork-&gt;psize
op_assign
(paren
id|next
op_plus
l_int|1
)paren
op_star
id|ablksz
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|count
op_assign
id|next
op_plus
l_int|1
op_minus
id|ablocks
)paren
OG
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
(paren
id|i
op_ge
l_int|0
)paren
op_logical_and
op_logical_neg
id|ext-&gt;length
(braket
id|i
)braket
suffix:semicolon
op_decrement
id|i
)paren
(brace
)brace
suffix:semicolon
id|lock_bitmap
c_func
(paren
id|mdb
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
op_logical_and
(paren
id|ext-&gt;length
(braket
id|i
)braket
op_le
id|count
)paren
)paren
(brace
id|ext-&gt;end
op_sub_assign
id|ext-&gt;length
(braket
id|i
)braket
suffix:semicolon
id|count
op_sub_assign
id|ext-&gt;length
(braket
id|i
)braket
suffix:semicolon
id|error
op_assign
id|hfs_clear_vbm_bits
c_func
(paren
id|mdb
comma
id|ext-&gt;block
(braket
id|i
)braket
comma
id|ext-&gt;length
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_truncate: error %d freeing &quot;
l_string|&quot;blocks.&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
)brace
id|ext-&gt;block
(braket
id|i
)braket
op_assign
id|ext-&gt;length
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
op_decrement
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
)paren
(brace
id|ext-&gt;end
op_sub_assign
id|count
suffix:semicolon
id|ext-&gt;length
(braket
id|i
)braket
op_sub_assign
id|count
suffix:semicolon
id|error
op_assign
id|hfs_clear_vbm_bits
c_func
(paren
id|mdb
comma
id|ext-&gt;block
(braket
id|i
)braket
op_plus
id|ext-&gt;length
(braket
id|i
)braket
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_truncate: error %d freeing &quot;
l_string|&quot;blocks.&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
)brace
)brace
id|unlock_bitmap
c_func
(paren
id|mdb
)paren
suffix:semicolon
id|update_ext
c_func
(paren
id|fork
comma
id|ext
)paren
suffix:semicolon
)brace
id|fork-&gt;psize
op_assign
id|ablocks
op_star
id|ablksz
suffix:semicolon
)brace
multiline_comment|/*&n; * grow_fork()&n; *&n; * Try to add enough allocation blocks to &squot;fork&squot;&n; * so that it is &squot;ablock&squot; allocation blocks long. &n; */
DECL|function|grow_fork
r_static
r_int
id|grow_fork
c_func
(paren
r_struct
id|hfs_fork
op_star
id|fork
comma
r_int
id|ablocks
)paren
(brace
r_struct
id|hfs_cat_entry
op_star
id|entry
op_assign
id|fork-&gt;entry
suffix:semicolon
r_struct
id|hfs_mdb
op_star
id|mdb
op_assign
id|entry-&gt;mdb
suffix:semicolon
r_struct
id|hfs_extent
op_star
id|ext
suffix:semicolon
r_int
id|i
comma
id|start
comma
id|err
suffix:semicolon
id|hfs_u16
id|need
comma
id|len
op_assign
l_int|0
suffix:semicolon
id|hfs_u32
id|ablksz
op_assign
id|mdb-&gt;alloc_blksz
suffix:semicolon
id|hfs_u32
id|blocks
comma
id|clumpablks
suffix:semicolon
id|blocks
op_assign
id|fork-&gt;psize
suffix:semicolon
id|need
op_assign
id|ablocks
op_minus
id|blocks
op_div
id|ablksz
suffix:semicolon
r_if
c_cond
(paren
id|need
OL
l_int|1
)paren
(brace
multiline_comment|/* no need to grow the fork */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* round up to clumpsize */
r_if
c_cond
(paren
id|entry-&gt;u.file.clumpablks
)paren
(brace
id|clumpablks
op_assign
id|entry-&gt;u.file.clumpablks
suffix:semicolon
)brace
r_else
(brace
id|clumpablks
op_assign
id|mdb-&gt;clumpablks
suffix:semicolon
)brace
id|need
op_assign
(paren
(paren
id|need
op_plus
id|clumpablks
op_minus
l_int|1
)paren
op_div
id|clumpablks
)paren
op_star
id|clumpablks
suffix:semicolon
multiline_comment|/* find last extent record and try to extend it */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ext
op_assign
id|find_ext
c_func
(paren
id|fork
comma
id|blocks
op_div
id|ablksz
op_minus
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/* somehow we couldn&squot;t find the end of the file! */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* determine which is the last used extent in the record */
multiline_comment|/* then try to allocate the blocks immediately following it */
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
(paren
id|i
op_ge
l_int|0
)paren
op_logical_and
op_logical_neg
id|ext-&gt;length
(braket
id|i
)braket
suffix:semicolon
op_decrement
id|i
)paren
(brace
)brace
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
l_int|0
)paren
(brace
multiline_comment|/* try to extend the last extent */
id|start
op_assign
id|ext-&gt;block
(braket
id|i
)braket
op_plus
id|ext-&gt;length
(braket
id|i
)braket
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|lock_bitmap
c_func
(paren
id|mdb
)paren
suffix:semicolon
id|len
op_assign
id|hfs_vbm_count_free
c_func
(paren
id|mdb
comma
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
(brace
id|unlock_bitmap
c_func
(paren
id|mdb
)paren
suffix:semicolon
r_goto
id|more_extents
suffix:semicolon
)brace
r_if
c_cond
(paren
id|need
OL
id|len
)paren
(brace
id|len
op_assign
id|need
suffix:semicolon
)brace
id|err
op_assign
id|hfs_set_vbm_bits
c_func
(paren
id|mdb
comma
id|start
comma
id|len
)paren
suffix:semicolon
id|unlock_bitmap
c_func
(paren
id|mdb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|relse_ext
c_func
(paren
id|ext
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|zero_blocks
c_func
(paren
id|mdb
comma
id|start
comma
id|len
)paren
suffix:semicolon
id|ext-&gt;length
(braket
id|i
)braket
op_add_assign
id|len
suffix:semicolon
id|ext-&gt;end
op_add_assign
id|len
suffix:semicolon
id|blocks
op_assign
(paren
id|fork-&gt;psize
op_add_assign
id|len
op_star
id|ablksz
)paren
suffix:semicolon
id|need
op_sub_assign
id|len
suffix:semicolon
id|update_ext
c_func
(paren
id|fork
comma
id|ext
)paren
suffix:semicolon
)brace
id|more_extents
suffix:colon
multiline_comment|/* add some more extents */
r_while
c_loop
(paren
id|need
)paren
(brace
id|len
op_assign
id|need
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|lock_bitmap
c_func
(paren
id|mdb
)paren
suffix:semicolon
id|start
op_assign
id|hfs_vbm_search_free
c_func
(paren
id|mdb
comma
op_amp
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need
OL
id|len
)paren
(brace
id|len
op_assign
id|need
suffix:semicolon
)brace
id|err
op_assign
id|hfs_set_vbm_bits
c_func
(paren
id|mdb
comma
id|start
comma
id|len
)paren
suffix:semicolon
id|unlock_bitmap
c_func
(paren
id|mdb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_or
id|err
)paren
(brace
id|relse_ext
c_func
(paren
id|ext
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|zero_blocks
c_func
(paren
id|mdb
comma
id|start
comma
id|len
)paren
suffix:semicolon
multiline_comment|/* determine which is the first free extent in the record */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
l_int|3
)paren
op_logical_and
id|ext-&gt;length
(braket
id|i
)braket
suffix:semicolon
op_increment
id|i
)paren
(brace
)brace
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|3
)paren
(brace
id|ext-&gt;block
(braket
id|i
)braket
op_assign
id|start
suffix:semicolon
id|ext-&gt;length
(braket
id|i
)braket
op_assign
id|len
suffix:semicolon
id|ext-&gt;end
op_add_assign
id|len
suffix:semicolon
id|update_ext
c_func
(paren
id|fork
comma
id|ext
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ext
op_assign
id|new_extent
c_func
(paren
id|fork
comma
id|ext
comma
id|blocks
op_div
id|ablksz
comma
id|start
comma
id|len
comma
id|ablksz
)paren
)paren
)paren
(brace
id|lock_bitmap
c_func
(paren
id|mdb
)paren
suffix:semicolon
id|hfs_clear_vbm_bits
c_func
(paren
id|mdb
comma
id|start
comma
id|len
)paren
suffix:semicolon
id|unlock_bitmap
c_func
(paren
id|mdb
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|blocks
op_assign
(paren
id|fork-&gt;psize
op_add_assign
id|len
op_star
id|ablksz
)paren
suffix:semicolon
id|need
op_sub_assign
id|len
suffix:semicolon
)brace
id|set_cache
c_func
(paren
id|fork
comma
id|ext
)paren
suffix:semicolon
id|relse_ext
c_func
(paren
id|ext
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*================ Global functions ================*/
multiline_comment|/*&n; * hfs_ext_compare()&n; *&n; * Description:&n; *   This is the comparison function used for the extents B-tree.  In&n; *   comparing extent B-tree entries, the file id is the most&n; *   significant field (compared as unsigned ints); the fork type is&n; *   the second most significant field (compared as unsigned chars);&n; *   and the allocation block number field is the least significant&n; *   (compared as unsigned ints).&n; * Input Variable(s):&n; *   struct hfs_ext_key *key1: pointer to the first key to compare&n; *   struct hfs_ext_key *key2: pointer to the second key to compare&n; * Output Variable(s):&n; *   NONE&n; * Returns:&n; *   int: negative if key1&lt;key2, positive if key1&gt;key2, and 0 if key1==key2&n; * Preconditions:&n; *   key1 and key2 point to &quot;valid&quot; (struct hfs_ext_key)s.&n; * Postconditions:&n; *   This function has no side-effects */
DECL|function|hfs_ext_compare
r_int
id|hfs_ext_compare
c_func
(paren
r_const
r_struct
id|hfs_ext_key
op_star
id|key1
comma
r_const
r_struct
id|hfs_ext_key
op_star
id|key2
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|tmp
op_assign
id|hfs_get_hl
c_func
(paren
id|key1-&gt;FNum
)paren
op_minus
id|hfs_get_hl
c_func
(paren
id|key2-&gt;FNum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ne
l_int|0
)paren
(brace
id|retval
op_assign
(paren
r_int
)paren
id|tmp
suffix:semicolon
)brace
r_else
(brace
id|tmp
op_assign
(paren
r_int
r_char
)paren
id|key1-&gt;FkType
op_minus
(paren
r_int
r_char
)paren
id|key2-&gt;FkType
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ne
l_int|0
)paren
(brace
id|retval
op_assign
(paren
r_int
)paren
id|tmp
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
(paren
r_int
)paren
(paren
id|hfs_get_hs
c_func
(paren
id|key1-&gt;FABN
)paren
op_minus
id|hfs_get_hs
c_func
(paren
id|key2-&gt;FABN
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_extent_adj()&n; *&n; * Given an hfs_fork shrink or grow the fork to hold the&n; * forks logical size.&n; */
DECL|function|hfs_extent_adj
r_void
id|hfs_extent_adj
c_func
(paren
r_struct
id|hfs_fork
op_star
id|fork
)paren
(brace
r_if
c_cond
(paren
id|fork
)paren
(brace
id|hfs_u32
id|blks
comma
id|ablocks
comma
id|ablksz
suffix:semicolon
r_if
c_cond
(paren
id|fork-&gt;lsize
OG
id|HFS_FORK_MAX
)paren
(brace
id|fork-&gt;lsize
op_assign
id|HFS_FORK_MAX
suffix:semicolon
)brace
id|blks
op_assign
(paren
id|fork-&gt;lsize
op_plus
id|HFS_SECTOR_SIZE
op_minus
l_int|1
)paren
op_rshift
id|HFS_SECTOR_SIZE_BITS
suffix:semicolon
id|ablksz
op_assign
id|fork-&gt;entry-&gt;mdb-&gt;alloc_blksz
suffix:semicolon
id|ablocks
op_assign
(paren
id|blks
op_plus
id|ablksz
op_minus
l_int|1
)paren
op_div
id|ablksz
suffix:semicolon
r_if
c_cond
(paren
id|blks
OG
id|fork-&gt;psize
)paren
(brace
id|grow_fork
c_func
(paren
id|fork
comma
id|ablocks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blks
OG
id|fork-&gt;psize
)paren
(brace
id|fork-&gt;lsize
op_assign
id|fork-&gt;psize
op_rshift
id|HFS_SECTOR_SIZE_BITS
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|blks
OL
id|fork-&gt;psize
)paren
(brace
id|shrink_fork
c_func
(paren
id|fork
comma
id|ablocks
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * hfs_extent_map()&n; *&n; * Given an hfs_fork and a block number within the fork, return the&n; * number of the corresponding physical block on disk, or zero on&n; * error.&n; */
DECL|function|hfs_extent_map
r_int
id|hfs_extent_map
c_func
(paren
r_struct
id|hfs_fork
op_star
id|fork
comma
r_int
id|block
comma
r_int
id|create
)paren
(brace
r_int
id|ablksz
comma
id|ablock
comma
id|offset
comma
id|tmp
suffix:semicolon
r_struct
id|hfs_extent
op_star
id|ext
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fork
op_logical_or
op_logical_neg
id|fork-&gt;entry
op_logical_or
op_logical_neg
id|fork-&gt;entry-&gt;mdb
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if defined(DEBUG_EXTENTS) || defined(DEBUG_ALL)
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_extent_map: ablock %d of file %d, fork %d&bslash;n&quot;
comma
id|block
comma
id|fork-&gt;entry-&gt;cnid
comma
id|fork-&gt;fork
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|block
OL
l_int|0
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_extent_map: block &lt; 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|block
OG
(paren
id|HFS_FORK_MAX
op_rshift
id|HFS_SECTOR_SIZE_BITS
)paren
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_extent_map: block(0x%08x) &gt; big; cnid=%d &quot;
l_string|&quot;fork=%d&bslash;n&quot;
comma
id|block
comma
id|fork-&gt;entry-&gt;cnid
comma
id|fork-&gt;fork
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ablksz
op_assign
id|fork-&gt;entry-&gt;mdb-&gt;alloc_blksz
suffix:semicolon
id|offset
op_assign
id|fork-&gt;entry-&gt;mdb-&gt;fs_start
op_plus
(paren
id|block
op_mod
id|ablksz
)paren
suffix:semicolon
id|ablock
op_assign
id|block
op_div
id|ablksz
suffix:semicolon
r_if
c_cond
(paren
id|block
op_ge
id|fork-&gt;psize
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|create
op_logical_or
(paren
id|grow_fork
c_func
(paren
id|fork
comma
id|ablock
op_plus
l_int|1
)paren
OL
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if defined(DEBUG_EXTENTS) || defined(DEBUG_ALL)
id|hfs_warn
c_func
(paren
l_string|&quot;(lblock %d offset %d)&bslash;n&quot;
comma
id|ablock
comma
id|offset
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|ext
op_assign
id|find_ext
c_func
(paren
id|fork
comma
id|ablock
)paren
)paren
)paren
(brace
id|dump_ext
c_func
(paren
l_string|&quot;trying new: &quot;
comma
id|ext
)paren
suffix:semicolon
id|tmp
op_assign
id|decode_extent
c_func
(paren
id|ext
comma
id|ablock
)paren
suffix:semicolon
id|relse_ext
c_func
(paren
id|ext
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ge
l_int|0
)paren
(brace
r_return
id|tmp
op_star
id|ablksz
op_plus
id|offset
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * hfs_extent_out()&n; *&n; * Copy the first extent record from a (struct hfs_fork) to a (struct&n; * raw_extent), record (normally the one in the catalog entry).&n; */
DECL|function|hfs_extent_out
r_void
id|hfs_extent_out
c_func
(paren
r_const
r_struct
id|hfs_fork
op_star
id|fork
comma
id|hfs_byte_t
id|dummy
(braket
l_int|12
)braket
)paren
(brace
r_struct
id|hfs_raw_extent
op_star
id|ext
op_assign
(paren
r_struct
id|hfs_raw_extent
op_star
)paren
id|dummy
suffix:semicolon
r_if
c_cond
(paren
id|fork
op_logical_and
id|ext
)paren
(brace
id|write_extent
c_func
(paren
id|ext
comma
op_amp
id|fork-&gt;first
)paren
suffix:semicolon
id|dump_ext
c_func
(paren
l_string|&quot;extent out: &quot;
comma
op_amp
id|fork-&gt;first
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * hfs_extent_in()&n; *&n; * Copy an raw_extent to the &squot;first&squot; and &squot;cache&squot; fields of an hfs_fork.&n; */
DECL|function|hfs_extent_in
r_void
id|hfs_extent_in
c_func
(paren
r_struct
id|hfs_fork
op_star
id|fork
comma
r_const
id|hfs_byte_t
id|dummy
(braket
l_int|12
)braket
)paren
(brace
r_const
r_struct
id|hfs_raw_extent
op_star
id|ext
op_assign
(paren
r_const
r_struct
id|hfs_raw_extent
op_star
)paren
id|dummy
suffix:semicolon
r_if
c_cond
(paren
id|fork
op_logical_and
id|ext
)paren
(brace
id|read_extent
c_func
(paren
op_amp
id|fork-&gt;first
comma
id|ext
comma
l_int|0
)paren
suffix:semicolon
id|fork-&gt;cache
op_assign
op_amp
id|fork-&gt;first
suffix:semicolon
id|fork-&gt;first.count
op_assign
l_int|2
suffix:semicolon
id|dump_ext
c_func
(paren
l_string|&quot;extent in: &quot;
comma
op_amp
id|fork-&gt;first
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * hfs_extent_free()&n; *&n; * Removes from memory all extents associated with &squot;fil&squot;.&n; */
DECL|function|hfs_extent_free
r_void
id|hfs_extent_free
c_func
(paren
r_struct
id|hfs_fork
op_star
id|fork
)paren
(brace
r_if
c_cond
(paren
id|fork
)paren
(brace
id|set_cache
c_func
(paren
id|fork
comma
op_amp
id|fork-&gt;first
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fork-&gt;first.next
)paren
(brace
id|hfs_warn
c_func
(paren
l_string|&quot;hfs_extent_free: extents in use!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
eof
