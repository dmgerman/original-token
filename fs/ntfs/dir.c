multiline_comment|/*&n; *  dir.c&n; *&n; *  Copyright (C) 1995-1997, 1999 Martin von L&#xfffd;wis&n; *  Copyright (C) 1999 Steve Dodd&n; *  Copyright (C) 1999 Joseph Malicki&n; */
macro_line|#include &quot;ntfstypes.h&quot;
macro_line|#include &quot;struct.h&quot;
macro_line|#include &quot;dir.h&quot;
macro_line|#include &quot;macros.h&quot;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &quot;super.h&quot;
macro_line|#include &quot;inode.h&quot;
macro_line|#include &quot;attr.h&quot;
macro_line|#include &quot;support.h&quot;
macro_line|#include &quot;util.h&quot;
DECL|variable|I30
r_static
r_char
id|I30
(braket
)braket
op_assign
l_string|&quot;$I30&quot;
suffix:semicolon
multiline_comment|/* An index record should start with INDX, and the last word in each&n;   block should contain the check value. If it passes, the original&n;   values need to be restored */
DECL|function|ntfs_check_index_record
r_int
id|ntfs_check_index_record
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
r_char
op_star
id|record
)paren
(brace
r_return
id|ntfs_fixup_record
c_func
(paren
id|ino-&gt;vol
comma
id|record
comma
l_string|&quot;INDX&quot;
comma
id|ino-&gt;u.index.recordsize
)paren
suffix:semicolon
)brace
DECL|function|ntfs_is_top
r_static
r_inline
r_int
id|ntfs_is_top
c_func
(paren
id|ntfs_u64
id|stack
)paren
(brace
r_return
id|stack
op_eq
l_int|14
suffix:semicolon
)brace
DECL|function|ntfs_pop
r_static
r_int
id|ntfs_pop
c_func
(paren
id|ntfs_u64
op_star
id|stack
)paren
(brace
r_static
r_int
id|width
(braket
l_int|16
)braket
op_assign
initialization_block
suffix:semicolon
r_int
id|res
op_assign
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|width
(braket
op_star
id|stack
op_amp
l_int|15
)braket
)paren
(brace
r_case
l_int|1
suffix:colon
id|res
op_assign
(paren
r_int
)paren
(paren
(paren
op_star
id|stack
op_amp
l_int|15
)paren
op_rshift
l_int|1
)paren
suffix:semicolon
op_star
id|stack
op_rshift_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|res
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
op_star
id|stack
op_amp
l_int|63
)paren
op_rshift
l_int|2
)paren
op_plus
l_int|7
)paren
suffix:semicolon
op_star
id|stack
op_rshift_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|res
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
op_star
id|stack
op_amp
l_int|255
)paren
op_rshift
l_int|3
)paren
op_plus
l_int|23
)paren
suffix:semicolon
op_star
id|stack
op_rshift_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|res
op_assign
(paren
r_int
)paren
(paren
(paren
(paren
op_star
id|stack
op_amp
l_int|1023
)paren
op_rshift
l_int|4
)paren
op_plus
l_int|55
)paren
suffix:semicolon
op_star
id|stack
op_rshift_assign
l_int|10
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ntfs_error
c_func
(paren
l_string|&quot;Unknown encoding&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|function|ntfs_top
r_static
r_inline
r_int
r_int
id|ntfs_top
c_func
(paren
r_void
)paren
(brace
r_return
l_int|14
suffix:semicolon
)brace
DECL|function|ntfs_push
r_static
id|ntfs_u64
id|ntfs_push
c_func
(paren
id|ntfs_u64
id|stack
comma
r_int
id|i
)paren
(brace
r_if
c_cond
(paren
id|i
OL
l_int|7
)paren
(brace
r_return
(paren
id|stack
op_lshift
l_int|4
)paren
op_or
(paren
id|i
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
l_int|23
)paren
(brace
r_return
(paren
id|stack
op_lshift
l_int|6
)paren
op_or
(paren
(paren
id|i
op_minus
l_int|7
)paren
op_lshift
l_int|2
)paren
op_or
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
l_int|55
)paren
(brace
r_return
(paren
id|stack
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|i
op_minus
l_int|23
)paren
op_lshift
l_int|3
)paren
op_or
l_int|3
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
l_int|120
)paren
(brace
r_return
(paren
id|stack
op_lshift
l_int|10
)paren
op_or
(paren
(paren
id|i
op_minus
l_int|55
)paren
op_lshift
l_int|4
)paren
op_or
l_int|7
suffix:semicolon
)brace
id|ntfs_error
c_func
(paren
l_string|&quot;Too many entries&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_complement
(paren
(paren
id|ntfs_u64
)paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_void
id|ntfs_display_stack
c_func
(paren
id|ntfs_u64
id|stack
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|ntfs_is_top
c_func
(paren
id|stack
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%d &quot;
comma
id|ntfs_pop
c_func
(paren
op_amp
id|stack
)paren
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* True if the entry points to another block of entries */
DECL|function|ntfs_entry_has_subnodes
r_static
r_inline
r_int
id|ntfs_entry_has_subnodes
c_func
(paren
r_char
op_star
id|entry
)paren
(brace
r_return
(paren
r_int
)paren
id|NTFS_GETU8
c_func
(paren
id|entry
op_plus
l_int|12
)paren
op_amp
l_int|1
suffix:semicolon
)brace
multiline_comment|/* True if it is not the &squot;end of dir&squot; entry */
DECL|function|ntfs_entry_is_used
r_static
r_inline
r_int
id|ntfs_entry_is_used
c_func
(paren
r_char
op_star
id|entry
)paren
(brace
r_return
(paren
r_int
)paren
(paren
id|NTFS_GETU8
c_func
(paren
id|entry
op_plus
l_int|12
)paren
op_amp
l_int|2
)paren
op_eq
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_allocate_index_block
r_static
r_int
id|ntfs_allocate_index_block
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
)paren
(brace
id|ntfs_attribute
op_star
id|allocation
op_assign
l_int|0
comma
op_star
id|bitmap
op_assign
l_int|0
suffix:semicolon
r_int
id|error
comma
id|size
comma
id|i
comma
id|bit
suffix:semicolon
id|ntfs_u8
op_star
id|bmap
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|walk-&gt;dir-&gt;vol
suffix:semicolon
multiline_comment|/* check for allocation attribute */
id|allocation
op_assign
id|ntfs_find_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_index_allocation
comma
id|I30
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|allocation
)paren
(brace
id|ntfs_u8
id|bmp
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* create index allocation attribute */
id|error
op_assign
id|ntfs_create_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_index_allocation
comma
id|I30
comma
l_int|0
comma
l_int|0
comma
op_amp
id|allocation
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ntfs_bzero
c_func
(paren
id|bmp
comma
r_sizeof
(paren
id|bmp
)paren
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_create_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_bitmap
comma
id|I30
comma
id|bmp
comma
r_sizeof
(paren
id|bmp
)paren
comma
op_amp
id|bitmap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
)brace
r_else
(brace
id|bitmap
op_assign
id|ntfs_find_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_bitmap
comma
id|I30
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bitmap
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Directory w/o bitmap&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
id|size
op_assign
id|bitmap-&gt;size
suffix:semicolon
id|bmap
op_assign
id|ntfs_malloc
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bmap
)paren
(brace
r_return
id|ENOMEM
suffix:semicolon
)brace
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.param
op_assign
id|bmap
suffix:semicolon
id|io.size
op_assign
id|size
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_bitmap
comma
id|I30
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_free
c_func
(paren
id|bmap
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|io.size
op_ne
id|size
)paren
(brace
id|ntfs_free
c_func
(paren
id|bmap
)paren
suffix:semicolon
r_return
id|EIO
suffix:semicolon
)brace
multiline_comment|/* allocate a bit */
r_for
c_loop
(paren
id|i
op_assign
id|bit
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|bmap
(braket
id|i
)braket
op_eq
l_int|0xFF
)paren
(brace
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|bit
op_assign
l_int|0
suffix:semicolon
id|bit
OL
l_int|8
suffix:semicolon
id|bit
op_increment
)paren
r_if
c_cond
(paren
(paren
(paren
id|bmap
(braket
id|i
)braket
op_rshift
id|bit
)paren
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bit
op_ne
l_int|8
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
id|size
)paren
(brace
multiline_comment|/* FIXME: extend bitmap */
r_return
id|EOPNOTSUPP
suffix:semicolon
)brace
id|walk-&gt;newblock
op_assign
(paren
id|i
op_star
l_int|8
op_plus
id|bit
)paren
op_star
id|walk-&gt;dir-&gt;u.index.clusters_per_record
suffix:semicolon
id|bmap
(braket
id|i
)braket
op_or_assign
l_int|1
op_lshift
id|bit
suffix:semicolon
id|io.param
op_assign
id|bmap
suffix:semicolon
id|io.size
op_assign
id|size
suffix:semicolon
id|error
op_assign
id|ntfs_write_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_bitmap
comma
id|I30
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
id|io.size
op_ne
id|size
)paren
(brace
id|ntfs_free
c_func
(paren
id|bmap
)paren
suffix:semicolon
r_return
id|error
ques
c_cond
id|error
suffix:colon
id|EIO
suffix:semicolon
)brace
id|ntfs_free
c_func
(paren
id|bmap
)paren
suffix:semicolon
multiline_comment|/* check whether record is out of allocated range */
id|size
op_assign
id|allocation-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|walk-&gt;newblock
op_star
id|vol-&gt;clustersize
op_ge
id|size
)paren
(brace
multiline_comment|/* build index record */
r_int
id|s1
op_assign
id|walk-&gt;dir-&gt;u.index.recordsize
suffix:semicolon
r_int
id|nr_fix
op_assign
id|s1
op_div
id|vol-&gt;blocksize
op_plus
l_int|1
suffix:semicolon
r_int
id|hsize
suffix:semicolon
r_char
op_star
id|record
op_assign
id|ntfs_malloc
c_func
(paren
id|s1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|record
)paren
(brace
r_return
id|ENOMEM
suffix:semicolon
)brace
id|ntfs_bzero
c_func
(paren
id|record
comma
id|s1
)paren
suffix:semicolon
multiline_comment|/* magic */
id|ntfs_memcpy
c_func
(paren
id|record
comma
l_string|&quot;INDX&quot;
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* offset to fixups */
id|NTFS_PUTU16
c_func
(paren
id|record
op_plus
l_int|4
comma
l_int|0x28
)paren
suffix:semicolon
multiline_comment|/* number of fixups */
id|NTFS_PUTU16
c_func
(paren
id|record
op_plus
l_int|6
comma
id|nr_fix
)paren
suffix:semicolon
multiline_comment|/* FIXME: log file number */
multiline_comment|/* VCN of buffer */
id|NTFS_PUTU64
c_func
(paren
id|record
op_plus
l_int|0x10
comma
id|walk-&gt;newblock
)paren
suffix:semicolon
multiline_comment|/* header size. */
id|hsize
op_assign
l_int|0x10
op_plus
l_int|2
op_star
id|nr_fix
suffix:semicolon
id|hsize
op_assign
(paren
id|hsize
op_plus
l_int|7
)paren
op_amp
op_complement
l_int|7
suffix:semicolon
multiline_comment|/* Align. */
id|NTFS_PUTU16
c_func
(paren
id|record
op_plus
l_int|0x18
comma
id|hsize
)paren
suffix:semicolon
multiline_comment|/* total size of record */
id|NTFS_PUTU32
c_func
(paren
id|record
op_plus
l_int|0x20
comma
id|s1
op_minus
l_int|0x18
)paren
suffix:semicolon
multiline_comment|/* Writing the data will extend the attribute. */
id|io.param
op_assign
id|record
suffix:semicolon
id|io.size
op_assign
id|s1
suffix:semicolon
id|io.do_read
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|ntfs_readwrite_attr
c_func
(paren
id|walk-&gt;dir
comma
id|allocation
comma
id|size
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
id|io.size
op_ne
id|s1
)paren
(brace
id|ntfs_free
c_func
(paren
id|record
)paren
suffix:semicolon
r_return
id|error
ques
c_cond
id|error
suffix:colon
id|EIO
suffix:semicolon
)brace
id|ntfs_free
c_func
(paren
id|record
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Write an index block (root or allocation) back to storage.&n;   used is the total number of bytes in buf, including all headers. */
DECL|function|ntfs_index_writeback
r_static
r_int
id|ntfs_index_writeback
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
comma
id|ntfs_u8
op_star
id|buf
comma
r_int
id|block
comma
r_int
id|used
)paren
(brace
id|ntfs_io
id|io
suffix:semicolon
r_int
id|error
suffix:semicolon
id|ntfs_attribute
op_star
id|a
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|walk-&gt;dir-&gt;vol
suffix:semicolon
id|io.fn_put
op_assign
l_int|0
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|block
op_eq
op_minus
l_int|1
)paren
(brace
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0x14
comma
id|used
op_minus
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* 0x18 is a copy thereof */
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0x18
comma
id|used
op_minus
l_int|0x10
)paren
suffix:semicolon
id|io.size
op_assign
id|used
suffix:semicolon
id|error
op_assign
id|ntfs_write_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_index_root
comma
id|I30
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|io.size
op_ne
id|used
)paren
(brace
r_return
id|EIO
suffix:semicolon
)brace
multiline_comment|/* shrink if necessary */
id|a
op_assign
id|ntfs_find_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_index_root
comma
id|I30
)paren
suffix:semicolon
id|ntfs_resize_attr
c_func
(paren
id|walk-&gt;dir
comma
id|a
comma
id|used
)paren
suffix:semicolon
)brace
r_else
(brace
id|NTFS_PUTU16
c_func
(paren
id|buf
op_plus
l_int|0x1C
comma
id|used
op_minus
l_int|0x18
)paren
suffix:semicolon
id|ntfs_insert_fixups
c_func
(paren
id|buf
comma
id|vol-&gt;blocksize
)paren
suffix:semicolon
id|io.size
op_assign
id|walk-&gt;dir-&gt;u.index.recordsize
suffix:semicolon
id|error
op_assign
id|ntfs_write_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_index_allocation
comma
id|I30
comma
id|block
op_star
id|vol-&gt;clustersize
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|io.size
op_ne
id|walk-&gt;dir-&gt;u.index.recordsize
)paren
(brace
r_return
id|EIO
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_split_record
r_static
r_int
id|ntfs_split_record
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
comma
r_char
op_star
id|start
comma
r_int
id|bsize
comma
r_int
id|usize
)paren
(brace
r_char
op_star
id|entry
comma
op_star
id|prev
suffix:semicolon
id|ntfs_u8
op_star
id|newbuf
op_assign
l_int|0
comma
op_star
id|middle
op_assign
l_int|0
suffix:semicolon
r_int
id|error
comma
id|othersize
comma
id|mlen
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|walk-&gt;dir-&gt;vol
suffix:semicolon
r_int
id|oldblock
suffix:semicolon
id|error
op_assign
id|ntfs_allocate_index_block
c_func
(paren
id|walk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* This should not happen */
r_if
c_cond
(paren
id|walk-&gt;block
op_eq
op_minus
l_int|1
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Trying to split root&quot;
)paren
suffix:semicolon
r_return
id|EOPNOTSUPP
suffix:semicolon
)brace
id|entry
op_assign
id|start
op_plus
id|NTFS_GETU16
c_func
(paren
id|start
op_plus
l_int|0x18
)paren
op_plus
l_int|0x18
suffix:semicolon
r_for
c_loop
(paren
id|prev
op_assign
id|entry
suffix:semicolon
id|entry
op_minus
id|start
OL
id|usize
op_div
l_int|2
suffix:semicolon
id|entry
op_add_assign
id|NTFS_GETU16
c_func
(paren
id|entry
op_plus
l_int|8
)paren
)paren
(brace
id|prev
op_assign
id|entry
suffix:semicolon
)brace
id|newbuf
op_assign
id|ntfs_malloc
c_func
(paren
id|vol-&gt;index_recordsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newbuf
)paren
(brace
r_return
id|ENOMEM
suffix:semicolon
)brace
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.fn_get
op_assign
id|ntfs_get
suffix:semicolon
id|io.param
op_assign
id|newbuf
suffix:semicolon
id|io.size
op_assign
id|vol-&gt;index_recordsize
suffix:semicolon
multiline_comment|/* read in old header. FIXME: reading everything is overkill */
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|walk-&gt;dir
comma
id|vol-&gt;at_index_allocation
comma
id|I30
comma
id|walk-&gt;newblock
op_star
id|vol-&gt;clustersize
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|io.size
op_ne
id|vol-&gt;index_recordsize
)paren
(brace
id|error
op_assign
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* FIXME: adjust header */
multiline_comment|/* copy everything from entry to new block */
id|othersize
op_assign
id|usize
op_minus
(paren
id|entry
op_minus
id|start
)paren
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
id|newbuf
op_plus
id|NTFS_GETU16
c_func
(paren
id|newbuf
op_plus
l_int|0x18
)paren
op_plus
l_int|0x18
comma
id|entry
comma
id|othersize
)paren
suffix:semicolon
multiline_comment|/* Copy flags. */
id|NTFS_PUTU32
c_func
(paren
id|newbuf
op_plus
l_int|0x24
comma
id|NTFS_GETU32
c_func
(paren
id|start
op_plus
l_int|0x24
)paren
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_index_writeback
c_func
(paren
id|walk
comma
id|newbuf
comma
id|walk-&gt;newblock
comma
id|othersize
op_plus
id|NTFS_GETU16
c_func
(paren
id|newbuf
op_plus
l_int|0x18
)paren
op_plus
l_int|0x18
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* move prev to walk */
id|mlen
op_assign
id|NTFS_GETU16
c_func
(paren
id|prev
op_plus
l_int|0x8
)paren
suffix:semicolon
multiline_comment|/* Remember old child node. */
r_if
c_cond
(paren
id|ntfs_entry_has_subnodes
c_func
(paren
id|prev
)paren
)paren
(brace
id|oldblock
op_assign
id|NTFS_GETU32
c_func
(paren
id|prev
op_plus
id|mlen
op_minus
l_int|8
)paren
suffix:semicolon
)brace
r_else
id|oldblock
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* allow for pointer to subnode */
id|middle
op_assign
id|ntfs_malloc
c_func
(paren
id|ntfs_entry_has_subnodes
c_func
(paren
id|prev
)paren
ques
c_cond
id|mlen
suffix:colon
id|mlen
op_plus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|middle
)paren
(brace
id|error
op_assign
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|ntfs_memcpy
c_func
(paren
id|middle
comma
id|prev
comma
id|mlen
)paren
suffix:semicolon
multiline_comment|/* set has_subnodes flag */
id|NTFS_PUTU8
c_func
(paren
id|middle
op_plus
l_int|0xC
comma
id|NTFS_GETU8
c_func
(paren
id|middle
op_plus
l_int|0xC
)paren
op_or
l_int|1
)paren
suffix:semicolon
multiline_comment|/* middle entry points to block, parent entry will point to newblock */
id|NTFS_PUTU64
c_func
(paren
id|middle
op_plus
id|mlen
op_minus
l_int|8
comma
id|walk-&gt;block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|walk-&gt;new_entry
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;entry not reset&quot;
)paren
suffix:semicolon
)brace
id|walk-&gt;new_entry
op_assign
id|middle
suffix:semicolon
id|walk-&gt;u.flags
op_or_assign
id|ITERATE_SPLIT_DONE
suffix:semicolon
multiline_comment|/* Terminate old block. */
id|othersize
op_assign
id|usize
op_minus
(paren
id|prev
op_minus
id|start
)paren
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|prev
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|oldblock
op_eq
op_minus
l_int|1
)paren
(brace
id|NTFS_PUTU32
c_func
(paren
id|prev
op_plus
l_int|8
comma
l_int|0x10
)paren
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|prev
op_plus
l_int|0xC
comma
l_int|2
)paren
suffix:semicolon
id|othersize
op_add_assign
l_int|0x10
suffix:semicolon
)brace
r_else
(brace
id|NTFS_PUTU32
c_func
(paren
id|prev
op_plus
l_int|8
comma
l_int|0x18
)paren
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|prev
op_plus
l_int|0xC
comma
l_int|3
)paren
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|prev
op_plus
l_int|0x10
comma
id|oldblock
)paren
suffix:semicolon
id|othersize
op_add_assign
l_int|0x18
suffix:semicolon
)brace
multiline_comment|/* write back original block */
id|error
op_assign
id|ntfs_index_writeback
c_func
(paren
id|walk
comma
id|start
comma
id|walk-&gt;block
comma
id|othersize
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|newbuf
)paren
(brace
id|ntfs_free
c_func
(paren
id|newbuf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|middle
)paren
(brace
id|ntfs_free
c_func
(paren
id|middle
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|ntfs_dir_insert
r_static
r_int
id|ntfs_dir_insert
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
comma
r_char
op_star
id|start
comma
r_char
op_star
id|entry
)paren
(brace
r_int
id|blocksize
comma
id|usedsize
comma
id|error
comma
id|offset
suffix:semicolon
r_int
id|do_split
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
id|entry
op_minus
id|start
suffix:semicolon
r_if
c_cond
(paren
id|walk-&gt;block
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/*index root */
id|blocksize
op_assign
id|walk-&gt;dir-&gt;vol-&gt;mft_recordsize
suffix:semicolon
id|usedsize
op_assign
id|NTFS_GETU16
c_func
(paren
id|start
op_plus
l_int|0x14
)paren
op_plus
l_int|0x10
suffix:semicolon
)brace
r_else
(brace
id|blocksize
op_assign
id|walk-&gt;dir-&gt;u.index.recordsize
suffix:semicolon
id|usedsize
op_assign
id|NTFS_GETU16
c_func
(paren
id|start
op_plus
l_int|0x1C
)paren
op_plus
l_int|0x18
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usedsize
op_plus
id|walk-&gt;new_entry_size
OG
id|blocksize
)paren
(brace
r_char
op_star
id|s1
op_assign
id|ntfs_malloc
c_func
(paren
id|blocksize
op_plus
id|walk-&gt;new_entry_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s1
)paren
(brace
r_return
id|ENOMEM
suffix:semicolon
)brace
id|ntfs_memcpy
c_func
(paren
id|s1
comma
id|start
comma
id|usedsize
)paren
suffix:semicolon
id|do_split
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* adjust entry to s1 */
id|entry
op_assign
id|s1
op_plus
(paren
id|entry
op_minus
id|start
)paren
suffix:semicolon
id|start
op_assign
id|s1
suffix:semicolon
)brace
id|ntfs_memmove
c_func
(paren
id|entry
op_plus
id|walk-&gt;new_entry_size
comma
id|entry
comma
id|usedsize
op_minus
id|offset
)paren
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
id|entry
comma
id|walk-&gt;new_entry
comma
id|walk-&gt;new_entry_size
)paren
suffix:semicolon
id|usedsize
op_add_assign
id|walk-&gt;new_entry_size
suffix:semicolon
id|ntfs_free
c_func
(paren
id|walk-&gt;new_entry
)paren
suffix:semicolon
id|walk-&gt;new_entry
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|do_split
)paren
(brace
id|error
op_assign
id|ntfs_split_record
c_func
(paren
id|walk
comma
id|start
comma
id|blocksize
comma
id|usedsize
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|start
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|ntfs_index_writeback
c_func
(paren
id|walk
comma
id|start
comma
id|walk-&gt;block
comma
id|usedsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Try to split INDEX_ROOT attributes. Return E2BIG if nothing changed. */
r_int
DECL|function|ntfs_split_indexroot
id|ntfs_split_indexroot
c_func
(paren
id|ntfs_inode
op_star
id|ino
)paren
(brace
id|ntfs_attribute
op_star
id|ra
suffix:semicolon
id|ntfs_u8
op_star
id|root
op_assign
l_int|0
comma
op_star
id|index
op_assign
l_int|0
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
r_int
id|error
comma
id|off
comma
id|i
comma
id|bsize
comma
id|isize
suffix:semicolon
id|ntfs_iterate_s
id|walk
suffix:semicolon
id|ra
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_index_root
comma
id|I30
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ra
)paren
(brace
r_return
id|E2BIG
suffix:semicolon
)brace
id|bsize
op_assign
id|ino-&gt;vol-&gt;mft_recordsize
suffix:semicolon
id|root
op_assign
id|ntfs_malloc
c_func
(paren
id|bsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root
)paren
(brace
r_return
id|E2BIG
suffix:semicolon
)brace
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.param
op_assign
id|root
suffix:semicolon
id|io.size
op_assign
id|bsize
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_index_root
comma
id|I30
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|off
op_assign
l_int|0x20
suffix:semicolon
multiline_comment|/* Count number of entries. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|ntfs_entry_is_used
c_func
(paren
id|root
op_plus
id|off
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|off
op_add_assign
id|NTFS_GETU16
c_func
(paren
id|root
op_plus
id|off
op_plus
l_int|8
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_le
l_int|2
)paren
(brace
multiline_comment|/* We don&squot;t split small index roots. */
id|error
op_assign
id|E2BIG
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|index
op_assign
id|ntfs_malloc
c_func
(paren
id|ino-&gt;vol-&gt;index_recordsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|index
)paren
(brace
id|error
op_assign
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|walk.dir
op_assign
id|ino
suffix:semicolon
id|walk.block
op_assign
op_minus
l_int|1
suffix:semicolon
id|walk.result
op_assign
id|walk.new_entry
op_assign
l_int|0
suffix:semicolon
id|walk.name
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|ntfs_allocate_index_block
c_func
(paren
op_amp
id|walk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Write old root to new index block. */
id|io.param
op_assign
id|index
suffix:semicolon
id|io.size
op_assign
id|ino-&gt;vol-&gt;index_recordsize
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_index_allocation
comma
id|I30
comma
id|walk.newblock
op_star
id|ino-&gt;vol-&gt;clustersize
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|isize
op_assign
id|NTFS_GETU16
c_func
(paren
id|root
op_plus
l_int|0x18
)paren
op_minus
l_int|0x10
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
id|index
op_plus
id|NTFS_GETU16
c_func
(paren
id|index
op_plus
l_int|0x18
)paren
op_plus
l_int|0x18
comma
id|root
op_plus
l_int|0x20
comma
id|isize
)paren
suffix:semicolon
multiline_comment|/* Copy flags. */
id|NTFS_PUTU32
c_func
(paren
id|index
op_plus
l_int|0x24
comma
id|NTFS_GETU32
c_func
(paren
id|root
op_plus
l_int|0x1C
)paren
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_index_writeback
c_func
(paren
op_amp
id|walk
comma
id|index
comma
id|walk.newblock
comma
id|isize
op_plus
id|NTFS_GETU16
c_func
(paren
id|index
op_plus
l_int|0x18
)paren
op_plus
l_int|0x18
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Mark root as split. */
id|NTFS_PUTU32
c_func
(paren
id|root
op_plus
l_int|0x1C
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Truncate index root. */
id|NTFS_PUTU64
c_func
(paren
id|root
op_plus
l_int|0x20
comma
l_int|0
)paren
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|root
op_plus
l_int|0x28
comma
l_int|0x18
)paren
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|root
op_plus
l_int|0x2C
comma
l_int|3
)paren
suffix:semicolon
id|NTFS_PUTU64
c_func
(paren
id|root
op_plus
l_int|0x30
comma
id|walk.newblock
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_index_writeback
c_func
(paren
op_amp
id|walk
comma
id|root
comma
op_minus
l_int|1
comma
l_int|0x38
)paren
suffix:semicolon
id|out
suffix:colon
id|ntfs_free
c_func
(paren
id|root
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|index
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* The entry has been found. Copy the result in the caller&squot;s buffer */
DECL|function|ntfs_copyresult
r_static
r_int
id|ntfs_copyresult
c_func
(paren
r_char
op_star
id|dest
comma
r_char
op_star
id|source
)paren
(brace
r_int
id|length
op_assign
id|NTFS_GETU16
c_func
(paren
id|source
op_plus
l_int|8
)paren
suffix:semicolon
id|ntfs_memcpy
c_func
(paren
id|dest
comma
id|source
comma
id|length
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* use $UpCase some day */
DECL|function|ntfs_my_toupper
r_static
r_inline
r_int
r_int
id|ntfs_my_toupper
c_func
(paren
id|ntfs_volume
op_star
id|vol
comma
id|ntfs_u16
id|x
)paren
(brace
multiline_comment|/* we should read any pending rest of $UpCase here */
r_if
c_cond
(paren
id|x
op_ge
id|vol-&gt;upcase_length
)paren
(brace
r_return
id|x
suffix:semicolon
)brace
r_return
id|vol-&gt;upcase
(braket
id|x
)braket
suffix:semicolon
)brace
multiline_comment|/* everything passed in walk and entry */
DECL|function|ntfs_my_strcmp
r_static
r_int
id|ntfs_my_strcmp
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
comma
r_const
r_int
r_char
op_star
id|entry
)paren
(brace
r_int
id|lu
op_assign
op_star
(paren
id|entry
op_plus
l_int|0x50
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ntfs_u16
op_star
id|name
op_assign
(paren
id|ntfs_u16
op_star
)paren
(paren
id|entry
op_plus
l_int|0x52
)paren
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|walk-&gt;dir-&gt;vol
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|lu
op_logical_and
id|i
OL
id|walk-&gt;namelen
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ntfs_my_toupper
c_func
(paren
id|vol
comma
id|NTFS_GETU16
c_func
(paren
id|name
op_plus
id|i
)paren
)paren
op_ne
id|ntfs_my_toupper
c_func
(paren
id|vol
comma
id|NTFS_GETU16
c_func
(paren
id|walk-&gt;name
op_plus
id|i
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|lu
op_logical_and
id|i
op_eq
id|walk-&gt;namelen
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|lu
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|walk-&gt;namelen
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ntfs_my_toupper
c_func
(paren
id|vol
comma
id|NTFS_GETU16
c_func
(paren
id|name
op_plus
id|i
)paren
)paren
OL
id|ntfs_my_toupper
c_func
(paren
id|vol
comma
id|NTFS_GETU16
c_func
(paren
id|walk-&gt;name
op_plus
id|i
)paren
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Necessary forward declaration */
r_static
r_int
id|ntfs_getdir_iterate
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
comma
r_char
op_star
id|start
comma
r_char
op_star
id|entry
)paren
suffix:semicolon
multiline_comment|/* Parse a block of entries. Load the block, fix it up, and iterate&n;   over the entries. The block is given as virtual cluster number */
DECL|function|ntfs_getdir_record
r_static
r_int
id|ntfs_getdir_record
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
comma
r_int
id|block
)paren
(brace
r_int
id|length
op_assign
id|walk-&gt;dir-&gt;u.index.recordsize
suffix:semicolon
r_char
op_star
id|record
op_assign
(paren
r_char
op_star
)paren
id|ntfs_malloc
c_func
(paren
id|length
)paren
suffix:semicolon
r_char
op_star
id|offset
suffix:semicolon
r_int
id|retval
comma
id|error
suffix:semicolon
r_int
id|oldblock
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|record
)paren
(brace
r_return
id|ENOMEM
suffix:semicolon
)brace
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.param
op_assign
id|record
suffix:semicolon
id|io.size
op_assign
id|length
suffix:semicolon
multiline_comment|/* Read the block from the index allocation attribute */
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|walk-&gt;dir
comma
id|walk-&gt;dir-&gt;vol-&gt;at_index_allocation
comma
id|I30
comma
id|block
op_star
id|walk-&gt;dir-&gt;vol-&gt;clustersize
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
id|io.size
op_ne
id|length
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;read failed&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|record
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ntfs_check_index_record
c_func
(paren
id|walk-&gt;dir
comma
id|record
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;%x is not an index record&bslash;n&quot;
comma
id|block
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|record
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|offset
op_assign
id|record
op_plus
id|NTFS_GETU16
c_func
(paren
id|record
op_plus
l_int|0x18
)paren
op_plus
l_int|0x18
suffix:semicolon
id|oldblock
op_assign
id|walk-&gt;block
suffix:semicolon
id|walk-&gt;block
op_assign
id|block
suffix:semicolon
id|retval
op_assign
id|ntfs_getdir_iterate
c_func
(paren
id|walk
comma
id|record
comma
id|offset
)paren
suffix:semicolon
id|walk-&gt;block
op_assign
id|oldblock
suffix:semicolon
id|ntfs_free
c_func
(paren
id|record
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* go down to the next block of entries. These collate before&n;   the current entry */
DECL|function|ntfs_descend
r_static
r_int
id|ntfs_descend
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
comma
id|ntfs_u8
op_star
id|start
comma
id|ntfs_u8
op_star
id|entry
)paren
(brace
r_int
id|length
op_assign
id|NTFS_GETU16
c_func
(paren
id|entry
op_plus
l_int|8
)paren
suffix:semicolon
r_int
id|nextblock
op_assign
id|NTFS_GETU32
c_func
(paren
id|entry
op_plus
id|length
op_minus
l_int|8
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ntfs_entry_has_subnodes
c_func
(paren
id|entry
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;illegal ntfs_descend call&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|error
op_assign
id|ntfs_getdir_record
c_func
(paren
id|walk
comma
id|nextblock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|walk-&gt;type
op_eq
id|DIR_INSERT
op_logical_and
(paren
id|walk-&gt;u.flags
op_amp
id|ITERATE_SPLIT_DONE
)paren
)paren
(brace
multiline_comment|/* Split has occurred. Adjust entry, insert new_entry. */
id|NTFS_PUTU32
c_func
(paren
id|entry
op_plus
id|length
op_minus
l_int|8
comma
id|walk-&gt;newblock
)paren
suffix:semicolon
multiline_comment|/* Reset flags, as the current block might be split again. */
id|walk-&gt;u.flags
op_and_assign
op_complement
id|ITERATE_SPLIT_DONE
suffix:semicolon
id|error
op_assign
id|ntfs_dir_insert
c_func
(paren
id|walk
comma
id|start
comma
id|entry
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
r_static
r_int
DECL|function|ntfs_getdir_iterate_byposition
id|ntfs_getdir_iterate_byposition
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
comma
r_char
op_star
id|start
comma
r_char
op_star
id|entry
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|curpos
op_assign
l_int|0
comma
id|destpos
op_assign
l_int|0
suffix:semicolon
r_int
id|length
suffix:semicolon
r_if
c_cond
(paren
id|walk-&gt;u.pos
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ntfs_is_top
c_func
(paren
id|walk-&gt;u.pos
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|destpos
op_assign
id|ntfs_pop
c_func
(paren
op_amp
id|walk-&gt;u.pos
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|walk-&gt;u.pos
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ntfs_entry_has_subnodes
c_func
(paren
id|entry
)paren
)paren
(brace
id|ntfs_descend
c_func
(paren
id|walk
comma
id|start
comma
id|entry
)paren
suffix:semicolon
)brace
r_else
id|walk-&gt;u.pos
op_assign
id|ntfs_top
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ntfs_is_top
c_func
(paren
id|walk-&gt;u.pos
)paren
op_logical_and
op_logical_neg
id|ntfs_entry_is_used
c_func
(paren
id|entry
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|walk-&gt;u.pos
op_assign
id|ntfs_push
c_func
(paren
id|walk-&gt;u.pos
comma
id|curpos
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|curpos
op_eq
id|destpos
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ntfs_is_top
c_func
(paren
id|walk-&gt;u.pos
)paren
op_logical_and
id|ntfs_entry_has_subnodes
c_func
(paren
id|entry
)paren
)paren
(brace
id|retval
op_assign
id|ntfs_descend
c_func
(paren
id|walk
comma
id|start
comma
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|walk-&gt;u.pos
op_assign
id|ntfs_push
c_func
(paren
id|walk-&gt;u.pos
comma
id|curpos
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|ntfs_entry_is_used
c_func
(paren
id|entry
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|walk-&gt;u.pos
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ntfs_entry_is_used
c_func
(paren
id|entry
)paren
)paren
(brace
id|retval
op_assign
id|ntfs_copyresult
c_func
(paren
id|walk-&gt;result
comma
id|entry
)paren
suffix:semicolon
id|walk-&gt;u.pos
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|walk-&gt;u.pos
op_assign
id|ntfs_top
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|curpos
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ntfs_entry_is_used
c_func
(paren
id|entry
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|length
op_assign
id|NTFS_GETU16
c_func
(paren
id|entry
op_plus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|length
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;infinite loop&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|entry
op_add_assign
id|length
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Iterate over a list of entries, either from an index block, or from&n;   the index root. &n;   If searching BY_POSITION, pop the top index from the position. If the&n;   position stack is empty then, return the item at the index and set the&n;   position to the next entry. If the position stack is not empty, &n;   recursively proceed for subnodes. If the entry at the position is the&n;   &squot;end of dir&squot; entry, return &squot;not found&squot; and the empty stack.&n;   If searching BY_NAME, walk through the items until found or until&n;   one item is collated after the requested item. In the former case, return&n;   the result. In the latter case, recursively proceed to the subnodes.&n;   If &squot;end of dir&squot; is reached, the name is not in the directory */
DECL|function|ntfs_getdir_iterate
r_static
r_int
id|ntfs_getdir_iterate
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
comma
r_char
op_star
id|start
comma
r_char
op_star
id|entry
)paren
(brace
r_int
id|length
suffix:semicolon
r_int
id|cmp
suffix:semicolon
r_if
c_cond
(paren
id|walk-&gt;type
op_eq
id|BY_POSITION
)paren
(brace
r_return
id|ntfs_getdir_iterate_byposition
c_func
(paren
id|walk
comma
id|start
comma
id|entry
)paren
suffix:semicolon
)brace
r_do
(brace
multiline_comment|/* if the current entry is a real one, compare with the&n;&t;&t;   requested item. If the current entry is the last item,&n;&t;&t;   it is always larger than the requested item */
id|cmp
op_assign
id|ntfs_entry_is_used
c_func
(paren
id|entry
)paren
ques
c_cond
id|ntfs_my_strcmp
c_func
(paren
id|walk
comma
id|entry
)paren
suffix:colon
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|walk-&gt;type
)paren
(brace
r_case
id|BY_NAME
suffix:colon
r_switch
c_cond
(paren
id|cmp
)paren
(brace
r_case
op_minus
l_int|1
suffix:colon
r_return
id|ntfs_entry_has_subnodes
c_func
(paren
id|entry
)paren
ques
c_cond
id|ntfs_descend
c_func
(paren
id|walk
comma
id|start
comma
id|entry
)paren
suffix:colon
l_int|0
suffix:semicolon
r_case
l_int|0
suffix:colon
r_return
id|ntfs_copyresult
c_func
(paren
id|walk-&gt;result
comma
id|entry
)paren
suffix:semicolon
r_case
l_int|1
suffix:colon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DIR_INSERT
suffix:colon
r_switch
c_cond
(paren
id|cmp
)paren
(brace
r_case
op_minus
l_int|1
suffix:colon
r_return
id|ntfs_entry_has_subnodes
c_func
(paren
id|entry
)paren
ques
c_cond
id|ntfs_descend
c_func
(paren
id|walk
comma
id|start
comma
id|entry
)paren
suffix:colon
id|ntfs_dir_insert
c_func
(paren
id|walk
comma
id|start
comma
id|entry
)paren
suffix:semicolon
r_case
l_int|0
suffix:colon
r_return
id|EEXIST
suffix:semicolon
r_case
l_int|1
suffix:colon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|ntfs_error
c_func
(paren
l_string|&quot;TODO&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ntfs_entry_is_used
c_func
(paren
id|entry
)paren
)paren
r_break
suffix:semicolon
id|length
op_assign
id|NTFS_GETU16
c_func
(paren
id|entry
op_plus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|length
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;infinite loop&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|entry
op_add_assign
id|length
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&t;Tree walking is done using position numbers. The following numbers have&n;    a special meaning:&n;        0    start (.)&n;        -1   no more entries&n;        -2   ..&n;    All other numbers encode sequences of indices. The sequence a,b,c is &n;    encoded as &lt;stop&gt;&lt;c&gt;&lt;b&gt;&lt;a&gt;, where &lt;foo&gt; is the encoding of foo. The&n;    first few integers are encoded as follows:&n;        0:    0000    1:    0010    2:    0100    3:    0110&n;        4:    1000    5:    1010    6:    1100 stop:    1110&n;        7:  000001    8:  000101&t;9:  001001   10:  001101&n;    The least significant bits give the width of this encoding, the&n;    other bits encode the value, starting from the first value of the &n;    interval.&n;     tag     width  first value  last value&n;     0       3      0            6&n;     01      4      7            22&n;     011     5      23           54&n;     0111    6      55           119&n;     More values are hopefully not needed, as the file position has currently&n;     64 bits in total.&n;*/
multiline_comment|/* Find an entry in the directory. Return 0 if not found, otherwise copy&n;   the entry to the result buffer. */
DECL|function|ntfs_getdir
r_int
id|ntfs_getdir
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
)paren
(brace
r_int
id|length
op_assign
id|walk-&gt;dir-&gt;vol-&gt;mft_recordsize
suffix:semicolon
r_int
id|retval
comma
id|error
suffix:semicolon
multiline_comment|/* start at the index root.*/
r_char
op_star
id|root
op_assign
id|ntfs_malloc
c_func
(paren
id|length
)paren
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root
)paren
(brace
r_return
id|ENOMEM
suffix:semicolon
)brace
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.param
op_assign
id|root
suffix:semicolon
id|io.size
op_assign
id|length
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|walk-&gt;dir
comma
id|walk-&gt;dir-&gt;vol-&gt;at_index_root
comma
id|I30
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Not a directory&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|walk-&gt;block
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* FIXME: move these to walk */
id|walk-&gt;dir-&gt;u.index.recordsize
op_assign
id|NTFS_GETU32
c_func
(paren
id|root
op_plus
l_int|0x8
)paren
suffix:semicolon
id|walk-&gt;dir-&gt;u.index.clusters_per_record
op_assign
id|NTFS_GETU32
c_func
(paren
id|root
op_plus
l_int|0xC
)paren
suffix:semicolon
multiline_comment|/* FIXME: consistency check */
multiline_comment|/* skip header */
id|retval
op_assign
id|ntfs_getdir_iterate
c_func
(paren
id|walk
comma
id|root
comma
id|root
op_plus
l_int|0x20
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|root
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Find an entry in the directory by its position stack. Iteration starts&n;   if the stack is 0, in which case the position is set to the first item&n;   in the directory. If the position is nonzero, return the item at the&n;   position and change the position to the next item. The position is -1&n;   if there are no more items */
DECL|function|ntfs_getdir_byposition
r_int
id|ntfs_getdir_byposition
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
)paren
(brace
id|walk-&gt;type
op_assign
id|BY_POSITION
suffix:semicolon
r_return
id|ntfs_getdir
c_func
(paren
id|walk
)paren
suffix:semicolon
)brace
multiline_comment|/* Find an entry in the directory by its name. Return 0 if not found */
DECL|function|ntfs_getdir_byname
r_int
id|ntfs_getdir_byname
c_func
(paren
id|ntfs_iterate_s
op_star
id|walk
)paren
(brace
id|walk-&gt;type
op_assign
id|BY_NAME
suffix:semicolon
r_return
id|ntfs_getdir
c_func
(paren
id|walk
)paren
suffix:semicolon
)brace
DECL|function|ntfs_getdir_unsorted
r_int
id|ntfs_getdir_unsorted
c_func
(paren
id|ntfs_inode
op_star
id|ino
comma
id|ntfs_u32
op_star
id|p_high
comma
id|ntfs_u32
op_star
id|p_low
comma
r_int
(paren
op_star
id|cb
)paren
(paren
id|ntfs_u8
op_star
comma
r_void
op_star
)paren
comma
r_void
op_star
id|param
)paren
(brace
r_char
op_star
id|buf
op_assign
l_int|0
comma
op_star
id|entry
op_assign
l_int|0
suffix:semicolon
id|ntfs_io
id|io
suffix:semicolon
r_int
id|length
suffix:semicolon
r_int
id|block
suffix:semicolon
r_int
id|start
suffix:semicolon
id|ntfs_attribute
op_star
id|attr
suffix:semicolon
id|ntfs_volume
op_star
id|vol
op_assign
id|ino-&gt;vol
suffix:semicolon
r_int
id|byte
comma
id|bit
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ino
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;No inode passed to getdir_unsorted&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|vol
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;Inode %d has no volume&bslash;n&quot;
comma
id|ino-&gt;i_number
)paren
suffix:semicolon
r_return
id|EINVAL
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 1&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* are we still in the index root */
r_if
c_cond
(paren
op_star
id|p_high
op_eq
l_int|0
)paren
(brace
id|buf
op_assign
id|ntfs_malloc
c_func
(paren
id|length
op_assign
id|vol-&gt;mft_recordsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
r_return
id|ENOMEM
suffix:semicolon
)brace
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
id|length
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|ino
comma
id|vol-&gt;at_index_root
comma
id|I30
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|ino-&gt;u.index.recordsize
op_assign
id|NTFS_GETU32
c_func
(paren
id|buf
op_plus
l_int|0x8
)paren
suffix:semicolon
id|ino-&gt;u.index.clusters_per_record
op_assign
id|NTFS_GETU32
c_func
(paren
id|buf
op_plus
l_int|0xC
)paren
suffix:semicolon
id|entry
op_assign
id|buf
op_plus
l_int|0x20
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 2&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we are in an index record */
id|length
op_assign
id|ino-&gt;u.index.recordsize
suffix:semicolon
id|buf
op_assign
id|ntfs_malloc
c_func
(paren
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
r_return
id|ENOMEM
suffix:semicolon
)brace
id|io.fn_put
op_assign
id|ntfs_put
suffix:semicolon
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
id|length
suffix:semicolon
multiline_comment|/* 0 is index root, index allocation starts with 4 */
id|block
op_assign
op_star
id|p_high
op_minus
id|ino-&gt;u.index.clusters_per_record
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|ino
comma
id|vol-&gt;at_index_allocation
comma
id|I30
comma
id|block
op_star
id|vol-&gt;clustersize
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|io.size
op_ne
id|length
)paren
(brace
id|error
op_assign
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;read failed&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ntfs_check_index_record
c_func
(paren
id|ino
comma
id|buf
)paren
)paren
(brace
id|ntfs_error
c_func
(paren
l_string|&quot;%x is not an index record&bslash;n&quot;
comma
id|block
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|ENOTDIR
suffix:semicolon
)brace
id|entry
op_assign
id|buf
op_plus
id|NTFS_GETU16
c_func
(paren
id|buf
op_plus
l_int|0x18
)paren
op_plus
l_int|0x18
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 3&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* process the entries */
id|start
op_assign
op_star
id|p_low
suffix:semicolon
r_while
c_loop
(paren
id|ntfs_entry_is_used
c_func
(paren
id|entry
)paren
)paren
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 4&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
)paren
(brace
id|start
op_decrement
suffix:semicolon
)brace
multiline_comment|/* skip entries that were already processed */
r_else
(brace
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 5&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|cb
c_func
(paren
id|entry
comma
id|param
)paren
)paren
)paren
(brace
multiline_comment|/* the entry could not be processed */
r_break
suffix:semicolon
)brace
(paren
op_star
id|p_low
)paren
op_increment
suffix:semicolon
)brace
id|entry
op_add_assign
id|NTFS_GETU16
c_func
(paren
id|entry
op_plus
l_int|8
)paren
suffix:semicolon
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 6&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* caller did not process all entries */
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 7&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* we have to locate the next record */
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
id|buf
op_assign
l_int|0
suffix:semicolon
op_star
id|p_low
op_assign
l_int|0
suffix:semicolon
id|attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|vol-&gt;at_bitmap
comma
id|I30
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|attr
)paren
(brace
multiline_comment|/* directory does not have index allocation */
op_star
id|p_high
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
op_star
id|p_low
op_assign
l_int|0
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 8&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|buf
op_assign
id|ntfs_malloc
c_func
(paren
id|length
op_assign
id|attr-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
r_return
id|ENOMEM
suffix:semicolon
)brace
id|io.param
op_assign
id|buf
suffix:semicolon
id|io.size
op_assign
id|length
suffix:semicolon
id|error
op_assign
id|ntfs_read_attr
c_func
(paren
id|ino
comma
id|vol-&gt;at_bitmap
comma
id|I30
comma
l_int|0
comma
op_amp
id|io
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|io.size
op_ne
id|length
)paren
(brace
id|error
op_assign
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 9&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|EIO
suffix:semicolon
)brace
id|attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|vol-&gt;at_index_allocation
comma
id|I30
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_star
id|p_high
op_star
id|vol-&gt;clustersize
OG
id|attr-&gt;size
)paren
(brace
multiline_comment|/* no more index records */
op_star
id|p_high
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 10&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|p_high
op_add_assign
id|ino-&gt;u.index.clusters_per_record
suffix:semicolon
id|byte
op_assign
op_star
id|p_high
op_div
id|ino-&gt;u.index.clusters_per_record
op_minus
l_int|1
suffix:semicolon
id|bit
op_assign
l_int|1
op_lshift
(paren
id|byte
op_amp
l_int|7
)paren
suffix:semicolon
id|byte
op_assign
id|byte
op_rshift
l_int|3
suffix:semicolon
multiline_comment|/* this record is allocated */
r_if
c_cond
(paren
id|buf
(braket
id|byte
)braket
op_amp
id|bit
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|ntfs_debug
c_func
(paren
id|DEBUG_DIR3
comma
l_string|&quot;unsorted 11&bslash;n&quot;
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ntfs_dir_add
r_int
id|ntfs_dir_add
c_func
(paren
id|ntfs_inode
op_star
id|dir
comma
id|ntfs_inode
op_star
r_new
comma
id|ntfs_attribute
op_star
id|name
)paren
(brace
id|ntfs_iterate_s
id|walk
suffix:semicolon
r_int
id|nsize
comma
id|esize
suffix:semicolon
id|ntfs_u8
op_star
id|entry
comma
op_star
id|ndata
suffix:semicolon
r_int
id|error
suffix:semicolon
id|walk.type
op_assign
id|DIR_INSERT
suffix:semicolon
id|walk.dir
op_assign
id|dir
suffix:semicolon
id|walk.u.flags
op_assign
l_int|0
suffix:semicolon
id|nsize
op_assign
id|name-&gt;size
suffix:semicolon
id|ndata
op_assign
id|name-&gt;d.data
suffix:semicolon
id|walk.name
op_assign
(paren
id|ntfs_u16
op_star
)paren
(paren
id|ndata
op_plus
l_int|0x42
)paren
suffix:semicolon
id|walk.namelen
op_assign
id|NTFS_GETU8
c_func
(paren
id|ndata
op_plus
l_int|0x40
)paren
suffix:semicolon
id|walk.new_entry_size
op_assign
id|esize
op_assign
(paren
(paren
id|nsize
op_plus
l_int|0x18
)paren
op_div
l_int|8
)paren
op_star
l_int|8
suffix:semicolon
id|walk.new_entry
op_assign
id|entry
op_assign
id|ntfs_malloc
c_func
(paren
id|esize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
(brace
r_return
id|ENOMEM
suffix:semicolon
)brace
id|ntfs_bzero
c_func
(paren
id|entry
comma
id|esize
)paren
suffix:semicolon
id|NTFS_PUTINUM
c_func
(paren
id|entry
comma
r_new
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|entry
op_plus
l_int|0x8
comma
id|esize
)paren
suffix:semicolon
multiline_comment|/* size of entry */
id|NTFS_PUTU16
c_func
(paren
id|entry
op_plus
l_int|0xA
comma
id|nsize
)paren
suffix:semicolon
multiline_comment|/* size of original name attribute */
id|NTFS_PUTU32
c_func
(paren
id|entry
op_plus
l_int|0xC
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* FIXME: D-F? */
id|ntfs_memcpy
c_func
(paren
id|entry
op_plus
l_int|0x10
comma
id|ndata
comma
id|nsize
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_getdir
c_func
(paren
op_amp
id|walk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|walk.new_entry
)paren
(brace
id|ntfs_free
c_func
(paren
id|walk.new_entry
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
macro_line|#if 0
r_int
id|ntfs_dir_add1
c_func
(paren
id|ntfs_inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
id|ntfs_inode
op_star
id|ino
)paren
(brace
id|ntfs_iterate_s
id|walk
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|nsize
suffix:semicolon
r_char
op_star
id|entry
suffix:semicolon
id|ntfs_attribute
op_star
id|name_attr
suffix:semicolon
id|error
op_assign
id|ntfs_decodeuni
c_func
(paren
id|dir-&gt;vol
comma
id|name
comma
id|namelen
comma
op_amp
id|walk.name
comma
op_amp
id|walk.namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* FIXME: set flags */
id|walk.type
op_assign
id|DIR_INSERT
suffix:semicolon
id|walk.dir
op_assign
id|dir
suffix:semicolon
multiline_comment|/*walk.new=ino;*/
multiline_comment|/* prepare new entry */
multiline_comment|/* round up to a multiple of 8 */
id|walk.new_entry_size
op_assign
id|nsize
op_assign
(paren
(paren
l_int|0x52
op_plus
l_int|2
op_star
id|walk.namelen
op_plus
l_int|7
)paren
op_div
l_int|8
)paren
op_star
l_int|8
suffix:semicolon
id|walk.new_entry
op_assign
id|entry
op_assign
id|ntfs_malloc
c_func
(paren
id|nsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
(brace
r_return
id|ENOMEM
suffix:semicolon
)brace
id|ntfs_bzero
c_func
(paren
id|entry
comma
id|nsize
)paren
suffix:semicolon
id|NTFS_PUTINUM
c_func
(paren
id|entry
comma
id|ino
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|entry
op_plus
l_int|8
comma
id|nsize
)paren
suffix:semicolon
id|NTFS_PUTU16
c_func
(paren
id|entry
op_plus
l_int|0xA
comma
l_int|0x42
op_plus
l_int|2
op_star
id|namelen
)paren
suffix:semicolon
multiline_comment|/*FIXME: size of name attr*/
id|NTFS_PUTU32
c_func
(paren
id|entry
op_plus
l_int|0xC
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*FIXME: D-F? */
id|name_attr
op_assign
id|ntfs_find_attr
c_func
(paren
id|ino
comma
id|vol-&gt;at_file_name
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* FIXME:multiple names */
r_if
c_cond
(paren
op_logical_neg
id|name_attr
op_logical_or
op_logical_neg
id|name_attr-&gt;resident
)paren
(brace
r_return
id|EIDRM
suffix:semicolon
)brace
multiline_comment|/* directory, file stamps, sizes, filename */
id|ntfs_memcpy
c_func
(paren
id|entry
op_plus
l_int|0x10
comma
id|name_attr-&gt;d.data
comma
l_int|0x42
op_plus
l_int|2
op_star
id|namelen
)paren
suffix:semicolon
id|error
op_assign
id|ntfs_getdir
c_func
(paren
op_amp
id|walk
)paren
suffix:semicolon
id|ntfs_free
c_func
(paren
id|walk.name
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Fills out and creates an INDEX_ROOT attribute. */
r_int
DECL|function|ntfs_add_index_root
id|ntfs_add_index_root
(paren
id|ntfs_inode
op_star
id|ino
comma
r_int
id|type
)paren
(brace
id|ntfs_attribute
op_star
id|da
suffix:semicolon
id|ntfs_u8
id|data
(braket
l_int|0x30
)braket
suffix:semicolon
multiline_comment|/* 0x20 header, 0x10 last entry */
r_char
id|name
(braket
l_int|10
)braket
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|data
comma
id|type
)paren
suffix:semicolon
multiline_comment|/* ??? */
id|NTFS_PUTU32
c_func
(paren
id|data
op_plus
l_int|4
comma
l_int|1
)paren
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|data
op_plus
l_int|8
comma
id|ino-&gt;vol-&gt;index_recordsize
)paren
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|data
op_plus
l_int|0xC
comma
id|ino-&gt;vol-&gt;index_clusters_per_record
)paren
suffix:semicolon
multiline_comment|/* ??? */
id|NTFS_PUTU32
c_func
(paren
id|data
op_plus
l_int|0x10
comma
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* Size of entries, including header. */
id|NTFS_PUTU32
c_func
(paren
id|data
op_plus
l_int|0x14
comma
l_int|0x20
)paren
suffix:semicolon
id|NTFS_PUTU32
c_func
(paren
id|data
op_plus
l_int|0x18
comma
l_int|0x20
)paren
suffix:semicolon
multiline_comment|/* No index allocation, yet. */
id|NTFS_PUTU32
c_func
(paren
id|data
op_plus
l_int|0x1C
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* add last entry. */
multiline_comment|/* indexed MFT record. */
id|NTFS_PUTU64
c_func
(paren
id|data
op_plus
l_int|0x20
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* size of entry */
id|NTFS_PUTU32
c_func
(paren
id|data
op_plus
l_int|0x28
comma
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* flags: last entry, no child nodes. */
id|NTFS_PUTU32
c_func
(paren
id|data
op_plus
l_int|0x2C
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* compute name */
id|ntfs_indexname
c_func
(paren
id|name
comma
id|type
)paren
suffix:semicolon
r_return
id|ntfs_create_attr
c_func
(paren
id|ino
comma
id|ino-&gt;vol-&gt;at_index_root
comma
id|name
comma
id|data
comma
r_sizeof
(paren
id|data
)paren
comma
op_amp
id|da
)paren
suffix:semicolon
)brace
r_int
DECL|function|ntfs_mkdir
id|ntfs_mkdir
c_func
(paren
id|ntfs_inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
id|ntfs_inode
op_star
id|result
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
id|ntfs_alloc_inode
c_func
(paren
id|dir
comma
id|result
comma
id|name
comma
id|namelen
comma
id|NTFS_AFLAG_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|error
op_assign
id|ntfs_add_index_root
c_func
(paren
id|result
comma
l_int|0x30
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Set directory bit */
id|result-&gt;attr
(braket
l_int|0x16
)braket
op_or_assign
l_int|2
suffix:semicolon
id|error
op_assign
id|ntfs_update_inode
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|ntfs_update_inode
(paren
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Local variables:&n; * c-file-style: &quot;linux&quot;&n; * End:&n; */
eof
