multiline_comment|/* Generic part */
r_typedef
r_struct
(brace
DECL|member|p
id|block_t
op_star
id|p
suffix:semicolon
DECL|member|key
id|block_t
id|key
suffix:semicolon
DECL|member|bh
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
DECL|typedef|Indirect
)brace
id|Indirect
suffix:semicolon
DECL|function|add_chain
r_static
r_inline
r_void
id|add_chain
c_func
(paren
id|Indirect
op_star
id|p
comma
r_struct
id|buffer_head
op_star
id|bh
comma
id|block_t
op_star
id|v
)paren
(brace
id|p-&gt;key
op_assign
op_star
(paren
id|p-&gt;p
op_assign
id|v
)paren
suffix:semicolon
id|p-&gt;bh
op_assign
id|bh
suffix:semicolon
)brace
DECL|function|verify_chain
r_static
r_inline
r_int
id|verify_chain
c_func
(paren
id|Indirect
op_star
id|from
comma
id|Indirect
op_star
id|to
)paren
(brace
r_while
c_loop
(paren
id|from
op_le
id|to
op_logical_and
id|from-&gt;key
op_eq
op_star
id|from-&gt;p
)paren
id|from
op_increment
suffix:semicolon
r_return
(paren
id|from
OG
id|to
)paren
suffix:semicolon
)brace
DECL|function|block_end
r_static
r_inline
id|block_t
op_star
id|block_end
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_return
(paren
id|block_t
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|bh-&gt;b_data
op_plus
id|BLOCK_SIZE
)paren
suffix:semicolon
)brace
DECL|function|get_branch
r_static
r_inline
id|Indirect
op_star
id|get_branch
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|depth
comma
r_int
op_star
id|offsets
comma
id|Indirect
id|chain
(braket
id|DEPTH
)braket
comma
r_int
op_star
id|err
)paren
(brace
id|kdev_t
id|dev
op_assign
id|inode-&gt;i_dev
suffix:semicolon
id|Indirect
op_star
id|p
op_assign
id|chain
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
op_star
id|err
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* i_data is not going away, no lock needed */
id|add_chain
(paren
id|chain
comma
l_int|NULL
comma
id|i_data
c_func
(paren
id|inode
)paren
op_plus
op_star
id|offsets
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;key
)paren
r_goto
id|no_block
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|depth
)paren
(brace
id|bh
op_assign
id|bread
c_func
(paren
id|dev
comma
id|block_to_cpu
c_func
(paren
id|p-&gt;key
)paren
comma
id|BLOCK_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|failure
suffix:semicolon
multiline_comment|/* Reader: pointers */
r_if
c_cond
(paren
op_logical_neg
id|verify_chain
c_func
(paren
id|chain
comma
id|p
)paren
)paren
r_goto
id|changed
suffix:semicolon
id|add_chain
c_func
(paren
op_increment
id|p
comma
id|bh
comma
(paren
id|block_t
op_star
)paren
id|bh-&gt;b_data
op_plus
op_star
op_increment
id|offsets
)paren
suffix:semicolon
multiline_comment|/* Reader: end */
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;key
)paren
r_goto
id|no_block
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
id|changed
suffix:colon
op_star
id|err
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|no_block
suffix:semicolon
id|failure
suffix:colon
op_star
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|no_block
suffix:colon
r_return
id|p
suffix:semicolon
)brace
DECL|function|alloc_branch
r_static
r_int
id|alloc_branch
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|num
comma
r_int
op_star
id|offsets
comma
id|Indirect
op_star
id|branch
)paren
(brace
r_int
id|n
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|parent
op_assign
id|minix_new_block
c_func
(paren
id|inode
)paren
suffix:semicolon
id|branch
(braket
l_int|0
)braket
dot
id|key
op_assign
id|cpu_to_block
c_func
(paren
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent
)paren
r_for
c_loop
(paren
id|n
op_assign
l_int|1
suffix:semicolon
id|n
OL
id|num
suffix:semicolon
id|n
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
multiline_comment|/* Allocate the next block */
r_int
id|nr
op_assign
id|minix_new_block
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
r_break
suffix:semicolon
id|branch
(braket
id|n
)braket
dot
id|key
op_assign
id|cpu_to_block
c_func
(paren
id|nr
)paren
suffix:semicolon
id|bh
op_assign
id|getblk
c_func
(paren
id|inode-&gt;i_dev
comma
id|parent
comma
id|BLOCK_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|memset
c_func
(paren
id|bh-&gt;b_data
comma
l_int|0
comma
id|BLOCK_SIZE
)paren
suffix:semicolon
id|branch
(braket
id|n
)braket
dot
id|bh
op_assign
id|bh
suffix:semicolon
id|branch
(braket
id|n
)braket
dot
id|p
op_assign
(paren
id|block_t
op_star
)paren
id|bh-&gt;b_data
op_plus
id|offsets
(braket
id|n
)braket
suffix:semicolon
op_star
id|branch
(braket
id|n
)braket
dot
id|p
op_assign
id|branch
(braket
id|n
)braket
dot
id|key
suffix:semicolon
id|mark_buffer_uptodate
c_func
(paren
id|bh
comma
l_int|1
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|parent
op_assign
id|nr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
op_eq
id|num
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Allocation failed, free what we already allocated */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
id|bforget
c_func
(paren
id|branch
(braket
id|i
)braket
dot
id|bh
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
id|minix_free_block
c_func
(paren
id|inode
comma
id|block_to_cpu
c_func
(paren
id|branch
(braket
id|i
)braket
dot
id|key
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
DECL|function|splice_branch
r_static
r_inline
r_int
id|splice_branch
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|Indirect
id|chain
(braket
id|DEPTH
)braket
comma
id|Indirect
op_star
id|where
comma
r_int
id|num
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* Verify that place we are splicing to is still there and vacant */
multiline_comment|/* Writer: pointers */
r_if
c_cond
(paren
op_logical_neg
id|verify_chain
c_func
(paren
id|chain
comma
id|where
op_minus
l_int|1
)paren
op_logical_or
op_star
id|where-&gt;p
)paren
multiline_comment|/* Writer: end */
r_goto
id|changed
suffix:semicolon
multiline_comment|/* That&squot;s it */
op_star
id|where-&gt;p
op_assign
id|where-&gt;key
suffix:semicolon
multiline_comment|/* Writer: end */
multiline_comment|/* We are done with atomic stuff, now do the rest of housekeeping */
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
multiline_comment|/* had we spliced it onto indirect block? */
r_if
c_cond
(paren
id|where-&gt;bh
)paren
id|mark_buffer_dirty
c_func
(paren
id|where-&gt;bh
)paren
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|changed
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
id|bforget
c_func
(paren
id|where
(braket
id|i
)braket
dot
id|bh
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num
suffix:semicolon
id|i
op_increment
)paren
id|minix_free_block
c_func
(paren
id|inode
comma
id|block_to_cpu
c_func
(paren
id|where
(braket
id|i
)braket
dot
id|key
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
DECL|function|get_block
r_static
r_inline
r_int
id|get_block
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|block
comma
r_struct
id|buffer_head
op_star
id|bh_result
comma
r_int
id|create
)paren
(brace
r_int
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_int
id|offsets
(braket
id|DEPTH
)braket
suffix:semicolon
id|Indirect
id|chain
(braket
id|DEPTH
)braket
suffix:semicolon
id|Indirect
op_star
id|partial
suffix:semicolon
r_int
id|left
suffix:semicolon
r_int
id|depth
op_assign
id|block_to_path
c_func
(paren
id|inode
comma
id|block
comma
id|offsets
)paren
suffix:semicolon
r_if
c_cond
(paren
id|depth
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|reread
suffix:colon
id|partial
op_assign
id|get_branch
c_func
(paren
id|inode
comma
id|depth
comma
id|offsets
comma
id|chain
comma
op_amp
id|err
)paren
suffix:semicolon
multiline_comment|/* Simplest case - block found, no allocation needed */
r_if
c_cond
(paren
op_logical_neg
id|partial
)paren
(brace
id|got_it
suffix:colon
id|bh_result-&gt;b_dev
op_assign
id|inode-&gt;i_dev
suffix:semicolon
id|bh_result-&gt;b_blocknr
op_assign
id|block_to_cpu
c_func
(paren
id|chain
(braket
id|depth
op_minus
l_int|1
)braket
dot
id|key
)paren
suffix:semicolon
id|bh_result-&gt;b_state
op_or_assign
(paren
l_int|1UL
op_lshift
id|BH_Mapped
)paren
suffix:semicolon
multiline_comment|/* Clean up and exit */
id|partial
op_assign
id|chain
op_plus
id|depth
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* the whole chain */
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* Next simple case - plain lookup or failed read of indirect block */
r_if
c_cond
(paren
op_logical_neg
id|create
op_logical_or
id|err
op_eq
op_minus
id|EIO
)paren
(brace
id|cleanup
suffix:colon
r_while
c_loop
(paren
id|partial
OG
id|chain
)paren
(brace
id|brelse
c_func
(paren
id|partial-&gt;bh
)paren
suffix:semicolon
id|partial
op_decrement
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Indirect block might be removed by truncate while we were&n;&t; * reading it. Handling of that case (forget what we&squot;ve got and&n;&t; * reread) is taken out of the main path.&n;&t; */
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EAGAIN
)paren
r_goto
id|changed
suffix:semicolon
id|left
op_assign
(paren
id|chain
op_plus
id|depth
)paren
op_minus
id|partial
suffix:semicolon
id|err
op_assign
id|alloc_branch
c_func
(paren
id|inode
comma
id|left
comma
id|offsets
op_plus
(paren
id|partial
op_minus
id|chain
)paren
comma
id|partial
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|cleanup
suffix:semicolon
r_if
c_cond
(paren
id|splice_branch
c_func
(paren
id|inode
comma
id|chain
comma
id|partial
comma
id|left
)paren
OL
l_int|0
)paren
r_goto
id|changed
suffix:semicolon
id|bh_result-&gt;b_state
op_or_assign
(paren
l_int|1UL
op_lshift
id|BH_New
)paren
suffix:semicolon
r_goto
id|got_it
suffix:semicolon
id|changed
suffix:colon
r_while
c_loop
(paren
id|partial
OG
id|chain
)paren
(brace
id|bforget
c_func
(paren
id|partial-&gt;bh
)paren
suffix:semicolon
id|partial
op_decrement
suffix:semicolon
)brace
r_goto
id|reread
suffix:semicolon
)brace
DECL|function|all_zeroes
r_static
r_inline
r_int
id|all_zeroes
c_func
(paren
id|block_t
op_star
id|p
comma
id|block_t
op_star
id|q
)paren
(brace
r_while
c_loop
(paren
id|p
OL
id|q
)paren
r_if
c_cond
(paren
op_star
id|p
op_increment
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|find_shared
r_static
id|Indirect
op_star
id|find_shared
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|depth
comma
r_int
id|offsets
(braket
id|DEPTH
)braket
comma
id|Indirect
id|chain
(braket
id|DEPTH
)braket
comma
id|block_t
op_star
id|top
)paren
(brace
id|Indirect
op_star
id|partial
comma
op_star
id|p
suffix:semicolon
r_int
id|k
comma
id|err
suffix:semicolon
op_star
id|top
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
id|depth
suffix:semicolon
id|k
OG
l_int|1
op_logical_and
op_logical_neg
id|offsets
(braket
id|k
op_minus
l_int|1
)braket
suffix:semicolon
id|k
op_decrement
)paren
suffix:semicolon
id|partial
op_assign
id|get_branch
c_func
(paren
id|inode
comma
id|k
comma
id|offsets
comma
id|chain
comma
op_amp
id|err
)paren
suffix:semicolon
multiline_comment|/* Writer: pointers */
r_if
c_cond
(paren
op_logical_neg
id|partial
)paren
id|partial
op_assign
id|chain
op_plus
id|k
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|partial-&gt;key
op_logical_and
op_star
id|partial-&gt;p
)paren
multiline_comment|/* Writer: end */
r_goto
id|no_top
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|partial
suffix:semicolon
id|p
OG
id|chain
op_logical_and
id|all_zeroes
c_func
(paren
(paren
id|block_t
op_star
)paren
id|p-&gt;bh-&gt;b_data
comma
id|p-&gt;p
)paren
suffix:semicolon
id|p
op_decrement
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
id|chain
op_plus
id|k
op_minus
l_int|1
op_logical_and
id|p
OG
id|chain
)paren
(brace
id|p-&gt;p
op_decrement
suffix:semicolon
)brace
r_else
(brace
op_star
id|top
op_assign
op_star
id|p-&gt;p
suffix:semicolon
op_star
id|p-&gt;p
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Writer: end */
r_while
c_loop
(paren
id|partial
OG
id|p
)paren
(brace
id|brelse
c_func
(paren
id|partial-&gt;bh
)paren
suffix:semicolon
id|partial
op_decrement
suffix:semicolon
)brace
id|no_top
suffix:colon
r_return
id|partial
suffix:semicolon
)brace
DECL|function|free_data
r_static
r_inline
r_void
id|free_data
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|block_t
op_star
id|p
comma
id|block_t
op_star
id|q
)paren
(brace
r_int
r_int
id|nr
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|p
OL
id|q
suffix:semicolon
id|p
op_increment
)paren
(brace
id|nr
op_assign
id|block_to_cpu
c_func
(paren
op_star
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
)paren
(brace
op_star
id|p
op_assign
l_int|0
suffix:semicolon
id|minix_free_block
c_func
(paren
id|inode
comma
id|nr
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|free_branches
r_static
r_void
id|free_branches
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|block_t
op_star
id|p
comma
id|block_t
op_star
id|q
comma
r_int
id|depth
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
r_int
id|nr
suffix:semicolon
r_if
c_cond
(paren
id|depth
op_decrement
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|p
OL
id|q
suffix:semicolon
id|p
op_increment
)paren
(brace
id|nr
op_assign
id|block_to_cpu
c_func
(paren
op_star
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
r_continue
suffix:semicolon
op_star
id|p
op_assign
l_int|0
suffix:semicolon
id|bh
op_assign
id|bread
(paren
id|inode-&gt;i_dev
comma
id|nr
comma
id|BLOCK_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_continue
suffix:semicolon
id|free_branches
c_func
(paren
id|inode
comma
(paren
id|block_t
op_star
)paren
id|bh-&gt;b_data
comma
id|block_end
c_func
(paren
id|bh
)paren
comma
id|depth
)paren
suffix:semicolon
id|bforget
c_func
(paren
id|bh
)paren
suffix:semicolon
id|minix_free_block
c_func
(paren
id|inode
comma
id|nr
)paren
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
)brace
r_else
id|free_data
c_func
(paren
id|inode
comma
id|p
comma
id|q
)paren
suffix:semicolon
)brace
DECL|function|truncate
r_static
r_inline
r_void
id|truncate
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|block_t
op_star
id|idata
op_assign
id|i_data
c_func
(paren
id|inode
)paren
suffix:semicolon
r_int
id|offsets
(braket
id|DEPTH
)braket
suffix:semicolon
id|Indirect
id|chain
(braket
id|DEPTH
)braket
suffix:semicolon
id|Indirect
op_star
id|partial
suffix:semicolon
id|block_t
id|nr
op_assign
l_int|0
suffix:semicolon
r_int
id|n
suffix:semicolon
r_int
id|first_whole
suffix:semicolon
r_int
id|iblock
suffix:semicolon
id|iblock
op_assign
(paren
id|inode-&gt;i_size
op_plus
id|BLOCK_SIZE
op_minus
l_int|1
)paren
op_rshift
l_int|10
suffix:semicolon
id|block_truncate_page
c_func
(paren
id|inode-&gt;i_mapping
comma
id|inode-&gt;i_size
comma
id|get_block
)paren
suffix:semicolon
id|n
op_assign
id|block_to_path
c_func
(paren
id|inode
comma
id|iblock
comma
id|offsets
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|1
)paren
(brace
id|free_data
c_func
(paren
id|inode
comma
id|idata
op_plus
id|offsets
(braket
l_int|0
)braket
comma
id|idata
op_plus
id|DIRECT
)paren
suffix:semicolon
id|first_whole
op_assign
l_int|0
suffix:semicolon
r_goto
id|do_indirects
suffix:semicolon
)brace
id|first_whole
op_assign
id|offsets
(braket
l_int|0
)braket
op_plus
l_int|1
op_minus
id|DIRECT
suffix:semicolon
id|partial
op_assign
id|find_shared
c_func
(paren
id|inode
comma
id|n
comma
id|offsets
comma
id|chain
comma
op_amp
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr
)paren
(brace
r_if
c_cond
(paren
id|partial
op_eq
id|chain
)paren
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
r_else
id|mark_buffer_dirty
c_func
(paren
id|partial-&gt;bh
)paren
suffix:semicolon
id|free_branches
c_func
(paren
id|inode
comma
op_amp
id|nr
comma
op_amp
id|nr
op_plus
l_int|1
comma
(paren
id|chain
op_plus
id|n
op_minus
l_int|1
)paren
op_minus
id|partial
)paren
suffix:semicolon
)brace
multiline_comment|/* Clear the ends of indirect blocks on the shared branch */
r_while
c_loop
(paren
id|partial
OG
id|chain
)paren
(brace
id|free_branches
c_func
(paren
id|inode
comma
id|partial-&gt;p
op_plus
l_int|1
comma
id|block_end
c_func
(paren
id|partial-&gt;bh
)paren
comma
(paren
id|chain
op_plus
id|n
op_minus
l_int|1
)paren
op_minus
id|partial
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|partial-&gt;bh
)paren
suffix:semicolon
id|brelse
(paren
id|partial-&gt;bh
)paren
suffix:semicolon
id|partial
op_decrement
suffix:semicolon
)brace
id|do_indirects
suffix:colon
multiline_comment|/* Kill the remaining (whole) subtrees */
r_while
c_loop
(paren
id|first_whole
OL
id|DEPTH
op_minus
l_int|1
)paren
(brace
id|nr
op_assign
id|idata
(braket
id|DIRECT
op_plus
id|first_whole
)braket
suffix:semicolon
r_if
c_cond
(paren
id|nr
)paren
(brace
id|idata
(braket
id|DIRECT
op_plus
id|first_whole
)braket
op_assign
l_int|0
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
id|free_branches
c_func
(paren
id|inode
comma
op_amp
id|nr
comma
op_amp
id|nr
op_plus
l_int|1
comma
id|first_whole
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|first_whole
op_increment
suffix:semicolon
)brace
id|inode-&gt;i_mtime
op_assign
id|inode-&gt;i_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
DECL|function|sync_block
r_static
r_int
id|sync_block
(paren
r_struct
id|inode
op_star
id|inode
comma
id|block_t
id|block
comma
r_int
id|wait
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|block
)paren
r_return
l_int|0
suffix:semicolon
id|bh
op_assign
id|get_hash_table
c_func
(paren
id|inode-&gt;i_dev
comma
id|block_to_cpu
c_func
(paren
id|block
)paren
comma
id|BLOCK_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|wait
op_logical_and
id|buffer_req
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|wait
op_logical_or
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
op_logical_or
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sync_indirect
r_static
r_int
id|sync_indirect
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|block_t
id|iblock
comma
r_int
id|depth
comma
r_int
id|wait
)paren
(brace
r_struct
id|buffer_head
op_star
id|ind_bh
op_assign
l_int|NULL
suffix:semicolon
r_int
id|rc
comma
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iblock
)paren
r_return
l_int|0
suffix:semicolon
id|rc
op_assign
id|sync_block
(paren
id|inode
comma
id|iblock
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|ind_bh
op_assign
id|bread
c_func
(paren
id|inode-&gt;i_dev
comma
id|block_to_cpu
c_func
(paren
id|iblock
)paren
comma
id|BLOCK_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ind_bh
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|depth
)paren
(brace
id|block_t
op_star
id|p
op_assign
(paren
id|block_t
op_star
)paren
id|ind_bh-&gt;b_data
suffix:semicolon
id|block_t
op_star
id|end
op_assign
id|block_end
c_func
(paren
id|ind_bh
)paren
suffix:semicolon
r_while
c_loop
(paren
id|p
OL
id|end
)paren
(brace
id|rc
op_assign
id|sync_indirect
(paren
id|inode
comma
op_star
id|p
op_increment
comma
id|depth
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OG
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|err
op_assign
id|rc
suffix:semicolon
)brace
)brace
id|brelse
c_func
(paren
id|ind_bh
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sync_file
r_static
r_inline
r_int
id|sync_file
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
id|wait
comma
id|err
op_assign
l_int|0
comma
id|i
suffix:semicolon
id|block_t
op_star
id|idata
op_assign
id|i_data
c_func
(paren
id|inode
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
id|generic_buffer_fdatasync
c_func
(paren
id|inode
comma
l_int|0
comma
op_complement
l_int|0UL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|wait
op_assign
l_int|0
suffix:semicolon
id|wait
op_le
l_int|1
suffix:semicolon
id|wait
op_increment
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|DEPTH
suffix:semicolon
id|i
op_increment
)paren
id|err
op_or_assign
id|sync_indirect
c_func
(paren
id|inode
comma
id|idata
(braket
id|DIRECT
op_plus
id|i
op_minus
l_int|1
)braket
comma
id|i
comma
id|wait
)paren
suffix:semicolon
id|err
op_or_assign
id|minix_sync_inode
(paren
id|inode
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|err
OL
l_int|0
)paren
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
)brace
eof
