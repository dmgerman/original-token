multiline_comment|/* inflate.c -- zlib interface to inflate modules&n; * Copyright (C) 1995-1998 Mark Adler&n; * For conditions of distribution and use, see copyright notice in zlib.h &n; */
macro_line|#include &quot;zutil.h&quot;
macro_line|#include &quot;infblock.h&quot;
DECL|struct|inflate_blocks_state
DECL|member|dummy
r_struct
id|inflate_blocks_state
(brace
r_int
id|dummy
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* for buggy compilers */
r_typedef
r_enum
(brace
DECL|enumerator|METHOD
id|METHOD
comma
multiline_comment|/* waiting for method byte */
DECL|enumerator|FLAG
id|FLAG
comma
multiline_comment|/* waiting for flag byte */
DECL|enumerator|DICT4
id|DICT4
comma
multiline_comment|/* four dictionary check bytes to go */
DECL|enumerator|DICT3
id|DICT3
comma
multiline_comment|/* three dictionary check bytes to go */
DECL|enumerator|DICT2
id|DICT2
comma
multiline_comment|/* two dictionary check bytes to go */
DECL|enumerator|DICT1
id|DICT1
comma
multiline_comment|/* one dictionary check byte to go */
DECL|enumerator|DICT0
id|DICT0
comma
multiline_comment|/* waiting for inflateSetDictionary */
DECL|enumerator|BLOCKS
id|BLOCKS
comma
multiline_comment|/* decompressing blocks */
DECL|enumerator|CHECK4
id|CHECK4
comma
multiline_comment|/* four check bytes to go */
DECL|enumerator|CHECK3
id|CHECK3
comma
multiline_comment|/* three check bytes to go */
DECL|enumerator|CHECK2
id|CHECK2
comma
multiline_comment|/* two check bytes to go */
DECL|enumerator|CHECK1
id|CHECK1
comma
multiline_comment|/* one check byte to go */
DECL|enumerator|DONE
id|DONE
comma
multiline_comment|/* finished check, done */
DECL|enumerator|BAD
id|BAD
)brace
multiline_comment|/* got an error--stay here */
DECL|typedef|inflate_mode
id|inflate_mode
suffix:semicolon
multiline_comment|/* inflate private state */
DECL|struct|internal_state
r_struct
id|internal_state
(brace
multiline_comment|/* mode */
DECL|member|mode
id|inflate_mode
id|mode
suffix:semicolon
multiline_comment|/* current inflate mode */
multiline_comment|/* mode dependent information */
r_union
(brace
DECL|member|method
id|uInt
id|method
suffix:semicolon
multiline_comment|/* if FLAGS, method byte */
r_struct
(brace
DECL|member|was
id|uLong
id|was
suffix:semicolon
multiline_comment|/* computed check value */
DECL|member|need
id|uLong
id|need
suffix:semicolon
multiline_comment|/* stream check value */
DECL|member|check
)brace
id|check
suffix:semicolon
multiline_comment|/* if CHECK, check values to compare */
DECL|member|marker
id|uInt
id|marker
suffix:semicolon
multiline_comment|/* if BAD, inflateSync&squot;s marker bytes count */
DECL|member|sub
)brace
id|sub
suffix:semicolon
multiline_comment|/* submode */
multiline_comment|/* mode independent information */
DECL|member|nowrap
r_int
id|nowrap
suffix:semicolon
multiline_comment|/* flag for no wrapper */
DECL|member|wbits
id|uInt
id|wbits
suffix:semicolon
multiline_comment|/* log2(window size)  (8..15, defaults to 15) */
id|inflate_blocks_statef
DECL|member|blocks
op_star
id|blocks
suffix:semicolon
multiline_comment|/* current inflate_blocks state */
)brace
suffix:semicolon
DECL|function|cramfs_inflateReset
r_int
id|ZEXPORT
id|cramfs_inflateReset
c_func
(paren
id|z
)paren
id|z_streamp
id|z
suffix:semicolon
(brace
r_if
c_cond
(paren
id|z
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;state
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|z-&gt;total_in
op_assign
id|z-&gt;total_out
op_assign
l_int|0
suffix:semicolon
id|z-&gt;msg
op_assign
id|Z_NULL
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|z-&gt;state-&gt;nowrap
ques
c_cond
id|BLOCKS
suffix:colon
id|METHOD
suffix:semicolon
id|cramfs_inflate_blocks_reset
c_func
(paren
id|z-&gt;state-&gt;blocks
comma
id|z
comma
id|Z_NULL
)paren
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
DECL|function|cramfs_inflateEnd
r_int
id|ZEXPORT
id|cramfs_inflateEnd
c_func
(paren
id|z
)paren
id|z_streamp
id|z
suffix:semicolon
(brace
r_if
c_cond
(paren
id|z
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;state
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|z-&gt;state-&gt;blocks
op_ne
id|Z_NULL
)paren
id|cramfs_inflate_blocks_free
c_func
(paren
id|z-&gt;state-&gt;blocks
comma
id|z
)paren
suffix:semicolon
id|z-&gt;state
op_assign
id|Z_NULL
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
DECL|function|cramfs_inflateInit2_
r_int
id|ZEXPORT
id|cramfs_inflateInit2_
c_func
(paren
id|z
comma
id|w
comma
id|version
comma
id|stream_size
)paren
id|z_streamp
id|z
suffix:semicolon
r_int
id|w
suffix:semicolon
r_const
r_char
op_star
id|version
suffix:semicolon
r_int
id|stream_size
suffix:semicolon
(brace
r_static
r_struct
id|internal_state
id|internal_state
suffix:semicolon
r_if
c_cond
(paren
id|version
op_eq
id|Z_NULL
op_logical_or
id|version
(braket
l_int|0
)braket
op_ne
id|ZLIB_VERSION
(braket
l_int|0
)braket
op_logical_or
id|stream_size
op_ne
r_sizeof
(paren
id|z_stream
)paren
)paren
r_return
id|Z_VERSION_ERROR
suffix:semicolon
multiline_comment|/* initialize state */
r_if
c_cond
(paren
id|z
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|z-&gt;msg
op_assign
id|Z_NULL
suffix:semicolon
id|z-&gt;state
op_assign
op_amp
id|internal_state
suffix:semicolon
id|z-&gt;state-&gt;blocks
op_assign
id|Z_NULL
suffix:semicolon
multiline_comment|/* handle undocumented nowrap option (no zlib header or check) */
id|z-&gt;state-&gt;nowrap
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|w
OL
l_int|0
)paren
(brace
id|w
op_assign
op_minus
id|w
suffix:semicolon
id|z-&gt;state-&gt;nowrap
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* set window size */
r_if
c_cond
(paren
id|w
template_param
l_int|15
)paren
(brace
id|cramfs_inflateEnd
c_func
(paren
id|z
)paren
suffix:semicolon
r_return
id|Z_STREAM_ERROR
suffix:semicolon
)brace
id|z-&gt;state-&gt;wbits
op_assign
(paren
id|uInt
)paren
id|w
suffix:semicolon
multiline_comment|/* create inflate_blocks state */
r_if
c_cond
(paren
(paren
id|z-&gt;state-&gt;blocks
op_assign
id|cramfs_inflate_blocks_new
c_func
(paren
id|z
comma
id|z-&gt;state-&gt;nowrap
ques
c_cond
id|Z_NULL
suffix:colon
id|cramfs_adler32
comma
(paren
id|uInt
)paren
l_int|1
op_lshift
id|w
)paren
)paren
op_eq
id|Z_NULL
)paren
(brace
id|cramfs_inflateEnd
c_func
(paren
id|z
)paren
suffix:semicolon
r_return
id|Z_MEM_ERROR
suffix:semicolon
)brace
multiline_comment|/* reset state */
id|cramfs_inflateReset
c_func
(paren
id|z
)paren
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
DECL|function|cramfs_inflateInit_
r_int
id|ZEXPORT
id|cramfs_inflateInit_
c_func
(paren
id|z
comma
id|version
comma
id|stream_size
)paren
id|z_streamp
id|z
suffix:semicolon
r_const
r_char
op_star
id|version
suffix:semicolon
r_int
id|stream_size
suffix:semicolon
(brace
r_return
id|cramfs_inflateInit2_
c_func
(paren
id|z
comma
id|DEF_WBITS
comma
id|version
comma
id|stream_size
)paren
suffix:semicolon
)brace
DECL|macro|NEEDBYTE
mdefine_line|#define NEEDBYTE {if(z-&gt;avail_in==0)return r;r=f;}
DECL|macro|NEXTBYTE
mdefine_line|#define NEXTBYTE (z-&gt;avail_in--,z-&gt;total_in++,*z-&gt;next_in++)
DECL|function|cramfs_inflate
r_int
id|ZEXPORT
id|cramfs_inflate
c_func
(paren
id|z
comma
id|f
)paren
id|z_streamp
id|z
suffix:semicolon
r_int
id|f
suffix:semicolon
(brace
r_int
id|r
suffix:semicolon
id|uInt
id|b
suffix:semicolon
r_if
c_cond
(paren
id|z
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;state
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;next_in
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
id|f
op_assign
id|f
op_eq
id|Z_FINISH
ques
c_cond
id|Z_BUF_ERROR
suffix:colon
id|Z_OK
suffix:semicolon
id|r
op_assign
id|Z_BUF_ERROR
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
r_switch
c_cond
(paren
id|z-&gt;state-&gt;mode
)paren
(brace
r_case
id|METHOD
suffix:colon
id|NEEDBYTE
r_if
c_cond
(paren
(paren
(paren
id|z-&gt;state-&gt;sub.method
op_assign
id|NEXTBYTE
)paren
op_amp
l_int|0xf
)paren
op_ne
id|Z_DEFLATED
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;unknown compression method&quot;
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* can&squot;t try inflateSync */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|z-&gt;state-&gt;sub.method
op_rshift
l_int|4
)paren
op_plus
l_int|8
OG
id|z-&gt;state-&gt;wbits
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;invalid window size&quot;
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* can&squot;t try inflateSync */
r_break
suffix:semicolon
)brace
id|z-&gt;state-&gt;mode
op_assign
id|FLAG
suffix:semicolon
r_case
id|FLAG
suffix:colon
id|NEEDBYTE
id|b
op_assign
id|NEXTBYTE
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|z-&gt;state-&gt;sub.method
op_lshift
l_int|8
)paren
op_plus
id|b
)paren
op_mod
l_int|31
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;incorrect header check&quot;
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* can&squot;t try inflateSync */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|b
op_amp
id|PRESET_DICT
)paren
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BLOCKS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|z-&gt;state-&gt;mode
op_assign
id|DICT4
suffix:semicolon
r_case
id|DICT4
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_assign
(paren
id|uLong
)paren
id|NEXTBYTE
op_lshift
l_int|24
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|DICT3
suffix:semicolon
r_case
id|DICT3
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_add_assign
(paren
id|uLong
)paren
id|NEXTBYTE
op_lshift
l_int|16
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|DICT2
suffix:semicolon
r_case
id|DICT2
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_add_assign
(paren
id|uLong
)paren
id|NEXTBYTE
op_lshift
l_int|8
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|DICT1
suffix:semicolon
r_case
id|DICT1
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_add_assign
(paren
id|uLong
)paren
id|NEXTBYTE
suffix:semicolon
id|z-&gt;adler
op_assign
id|z-&gt;state-&gt;sub.check.need
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|DICT0
suffix:semicolon
r_return
id|Z_NEED_DICT
suffix:semicolon
r_case
id|DICT0
suffix:colon
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;need dictionary&quot;
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* can try inflateSync */
r_return
id|Z_STREAM_ERROR
suffix:semicolon
r_case
id|BLOCKS
suffix:colon
id|r
op_assign
id|cramfs_inflate_blocks
c_func
(paren
id|z-&gt;state-&gt;blocks
comma
id|z
comma
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
id|Z_DATA_ERROR
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* can try inflateSync */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r
op_eq
id|Z_OK
)paren
id|r
op_assign
id|f
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
id|Z_STREAM_END
)paren
r_return
id|r
suffix:semicolon
id|r
op_assign
id|f
suffix:semicolon
id|cramfs_inflate_blocks_reset
c_func
(paren
id|z-&gt;state-&gt;blocks
comma
id|z
comma
op_amp
id|z-&gt;state-&gt;sub.check.was
)paren
suffix:semicolon
r_if
c_cond
(paren
id|z-&gt;state-&gt;nowrap
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|DONE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|z-&gt;state-&gt;mode
op_assign
id|CHECK4
suffix:semicolon
r_case
id|CHECK4
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_assign
(paren
id|uLong
)paren
id|NEXTBYTE
op_lshift
l_int|24
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|CHECK3
suffix:semicolon
r_case
id|CHECK3
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_add_assign
(paren
id|uLong
)paren
id|NEXTBYTE
op_lshift
l_int|16
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|CHECK2
suffix:semicolon
r_case
id|CHECK2
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_add_assign
(paren
id|uLong
)paren
id|NEXTBYTE
op_lshift
l_int|8
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|CHECK1
suffix:semicolon
r_case
id|CHECK1
suffix:colon
id|NEEDBYTE
id|z-&gt;state-&gt;sub.check.need
op_add_assign
(paren
id|uLong
)paren
id|NEXTBYTE
suffix:semicolon
r_if
c_cond
(paren
id|z-&gt;state-&gt;sub.check.was
op_ne
id|z-&gt;state-&gt;sub.check.need
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;msg
op_assign
(paren
r_char
op_star
)paren
l_string|&quot;incorrect data check&quot;
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* can&squot;t try inflateSync */
r_break
suffix:semicolon
)brace
id|z-&gt;state-&gt;mode
op_assign
id|DONE
suffix:semicolon
r_case
id|DONE
suffix:colon
r_return
id|Z_STREAM_END
suffix:semicolon
r_case
id|BAD
suffix:colon
r_return
id|Z_DATA_ERROR
suffix:semicolon
r_default
suffix:colon
r_return
id|Z_STREAM_ERROR
suffix:semicolon
)brace
macro_line|#ifdef NEED_DUMMY_RETURN
r_return
id|Z_STREAM_ERROR
suffix:semicolon
multiline_comment|/* Some dumb compilers complain without this */
macro_line|#endif
)brace
DECL|function|cramfs_inflateSync
r_int
id|ZEXPORT
id|cramfs_inflateSync
c_func
(paren
id|z
)paren
id|z_streamp
id|z
suffix:semicolon
(brace
id|uInt
id|n
suffix:semicolon
multiline_comment|/* number of bytes to look at */
id|Bytef
op_star
id|p
suffix:semicolon
multiline_comment|/* pointer to bytes */
id|uInt
id|m
suffix:semicolon
multiline_comment|/* number of marker bytes found in a row */
id|uLong
id|r
comma
id|w
suffix:semicolon
multiline_comment|/* temporaries to save total_in and total_out */
multiline_comment|/* set up */
r_if
c_cond
(paren
id|z
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;state
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|z-&gt;state-&gt;mode
op_ne
id|BAD
)paren
(brace
id|z-&gt;state-&gt;mode
op_assign
id|BAD
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|n
op_assign
id|z-&gt;avail_in
)paren
op_eq
l_int|0
)paren
r_return
id|Z_BUF_ERROR
suffix:semicolon
id|p
op_assign
id|z-&gt;next_in
suffix:semicolon
id|m
op_assign
id|z-&gt;state-&gt;sub.marker
suffix:semicolon
multiline_comment|/* search */
r_while
c_loop
(paren
id|n
op_logical_and
id|m
OL
l_int|4
)paren
(brace
r_static
r_const
id|Byte
id|mark
(braket
l_int|4
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0xff
comma
l_int|0xff
)brace
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_eq
id|mark
(braket
id|m
)braket
)paren
id|m
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|p
)paren
id|m
op_assign
l_int|0
suffix:semicolon
r_else
id|m
op_assign
l_int|4
op_minus
id|m
suffix:semicolon
id|p
op_increment
comma
id|n
op_decrement
suffix:semicolon
)brace
multiline_comment|/* restore */
id|z-&gt;total_in
op_add_assign
id|p
op_minus
id|z-&gt;next_in
suffix:semicolon
id|z-&gt;next_in
op_assign
id|p
suffix:semicolon
id|z-&gt;avail_in
op_assign
id|n
suffix:semicolon
id|z-&gt;state-&gt;sub.marker
op_assign
id|m
suffix:semicolon
multiline_comment|/* return no joy or set up to restart on a new block */
r_if
c_cond
(paren
id|m
op_ne
l_int|4
)paren
r_return
id|Z_DATA_ERROR
suffix:semicolon
id|r
op_assign
id|z-&gt;total_in
suffix:semicolon
id|w
op_assign
id|z-&gt;total_out
suffix:semicolon
id|cramfs_inflateReset
c_func
(paren
id|z
)paren
suffix:semicolon
id|z-&gt;total_in
op_assign
id|r
suffix:semicolon
id|z-&gt;total_out
op_assign
id|w
suffix:semicolon
id|z-&gt;state-&gt;mode
op_assign
id|BLOCKS
suffix:semicolon
r_return
id|Z_OK
suffix:semicolon
)brace
multiline_comment|/* Returns true if inflate is currently at the end of a block generated&n; * by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP&n; * implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH&n; * but removes the length bytes of the resulting empty stored block. When&n; * decompressing, PPP checks that at the end of input packet, inflate is&n; * waiting for these length bytes.&n; */
DECL|function|cramfs_inflateSyncPoint
r_int
id|ZEXPORT
id|cramfs_inflateSyncPoint
c_func
(paren
id|z
)paren
id|z_streamp
id|z
suffix:semicolon
(brace
r_if
c_cond
(paren
id|z
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;state
op_eq
id|Z_NULL
op_logical_or
id|z-&gt;state-&gt;blocks
op_eq
id|Z_NULL
)paren
r_return
id|Z_STREAM_ERROR
suffix:semicolon
r_return
id|inflate_blocks_sync_point
c_func
(paren
id|z-&gt;state-&gt;blocks
)paren
suffix:semicolon
)brace
eof
