multiline_comment|/*&n; *  linux/fs/dcache.c&n; *&n; *  (C) Copyright 1994 Linus Torvalds&n; */
multiline_comment|/*&n; * The directory cache is a &quot;two-level&quot; cache, each level doing LRU on&n; * its entries.  Adding new entries puts them at the end of the LRU&n; * queue on the first-level cache, while the second-level cache is&n; * fed by any cache hits.&n; *&n; * The idea is that new additions (from readdir(), for example) will not&n; * flush the cache of entries that have really been used.&n; *&n; * There is a global hash-table over both caches that hashes the entries&n; * based on the directory inode number and device as well as on a&n; * string-hash computed over the name. &n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/string.h&gt;
multiline_comment|/*&n; * Don&squot;t bother caching long names.. They just take up space in the cache, and&n; * for a name cache you just want to cache the &quot;normal&quot; names anyway which tend&n; * to be short.&n; */
DECL|macro|DCACHE_NAME_LEN
mdefine_line|#define DCACHE_NAME_LEN&t;15
DECL|macro|DCACHE_SIZE
mdefine_line|#define DCACHE_SIZE 128
DECL|struct|hash_list
r_struct
id|hash_list
(brace
DECL|member|next
r_struct
id|dir_cache_entry
op_star
id|next
suffix:semicolon
DECL|member|prev
r_struct
id|dir_cache_entry
op_star
id|prev
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * The dir_cache_entry must be in this order: we do ugly things with the pointers&n; */
DECL|struct|dir_cache_entry
r_struct
id|dir_cache_entry
(brace
DECL|member|h
r_struct
id|hash_list
id|h
suffix:semicolon
DECL|member|dc_dev
id|kdev_t
id|dc_dev
suffix:semicolon
DECL|member|dir
r_int
r_int
id|dir
suffix:semicolon
DECL|member|version
r_int
r_int
id|version
suffix:semicolon
DECL|member|ino
r_int
r_int
id|ino
suffix:semicolon
DECL|member|name_len
r_int
r_char
id|name_len
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
id|DCACHE_NAME_LEN
)braket
suffix:semicolon
DECL|member|lru_head
r_struct
id|dir_cache_entry
op_star
op_star
id|lru_head
suffix:semicolon
DECL|member|next_lru
DECL|member|prev_lru
r_struct
id|dir_cache_entry
op_star
id|next_lru
comma
op_star
id|prev_lru
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|dcache_offset
mdefine_line|#define dcache_offset(x) ((unsigned long)&amp;((struct dir_cache_entry*)0)-&gt;x)
DECL|macro|dcache_datalen
mdefine_line|#define dcache_datalen (dcache_offset(lru_head) - dcache_offset(dc_dev))
DECL|macro|COPYDATA
mdefine_line|#define COPYDATA(de, newde) &bslash;&n;memcpy((void *) &amp;newde-&gt;dc_dev, (void *) &amp;de-&gt;dc_dev, dcache_datalen)
DECL|variable|level1_cache
r_static
r_struct
id|dir_cache_entry
id|level1_cache
(braket
id|DCACHE_SIZE
)braket
suffix:semicolon
DECL|variable|level2_cache
r_static
r_struct
id|dir_cache_entry
id|level2_cache
(braket
id|DCACHE_SIZE
)braket
suffix:semicolon
multiline_comment|/*&n; * The LRU-lists are doubly-linked circular lists, and do not change in size&n; * so these pointers always have something to point to (after _init)&n; */
DECL|variable|level1_head
r_static
r_struct
id|dir_cache_entry
op_star
id|level1_head
suffix:semicolon
DECL|variable|level2_head
r_static
r_struct
id|dir_cache_entry
op_star
id|level2_head
suffix:semicolon
multiline_comment|/*&n; * The hash-queues are also doubly-linked circular lists, but the head is&n; * itself on the doubly-linked list, not just a pointer to the first entry.&n; */
DECL|macro|DCACHE_HASH_QUEUES
mdefine_line|#define DCACHE_HASH_QUEUES 32
DECL|macro|hash_fn
mdefine_line|#define hash_fn(dev,dir,namehash) ((HASHDEV(dev) ^ (dir) ^ (namehash)) % DCACHE_HASH_QUEUES)
DECL|variable|hash_table
r_static
r_struct
id|hash_list
id|hash_table
(braket
id|DCACHE_HASH_QUEUES
)braket
suffix:semicolon
DECL|function|remove_lru
r_static
r_inline
r_void
id|remove_lru
c_func
(paren
r_struct
id|dir_cache_entry
op_star
id|de
)paren
(brace
r_struct
id|dir_cache_entry
op_star
id|next
op_assign
id|de-&gt;next_lru
suffix:semicolon
r_struct
id|dir_cache_entry
op_star
id|prev
op_assign
id|de-&gt;prev_lru
suffix:semicolon
id|next-&gt;prev_lru
op_assign
id|prev
suffix:semicolon
id|prev-&gt;next_lru
op_assign
id|next
suffix:semicolon
)brace
DECL|function|add_lru
r_static
r_inline
r_void
id|add_lru
c_func
(paren
r_struct
id|dir_cache_entry
op_star
id|de
comma
r_struct
id|dir_cache_entry
op_star
id|head
)paren
(brace
r_struct
id|dir_cache_entry
op_star
id|prev
op_assign
id|head-&gt;prev_lru
suffix:semicolon
id|de-&gt;next_lru
op_assign
id|head
suffix:semicolon
id|de-&gt;prev_lru
op_assign
id|prev
suffix:semicolon
id|prev-&gt;next_lru
op_assign
id|de
suffix:semicolon
id|head-&gt;prev_lru
op_assign
id|de
suffix:semicolon
)brace
DECL|function|update_lru
r_static
r_inline
r_void
id|update_lru
c_func
(paren
r_struct
id|dir_cache_entry
op_star
id|de
)paren
(brace
r_if
c_cond
(paren
id|de
op_eq
op_star
id|de-&gt;lru_head
)paren
op_star
id|de-&gt;lru_head
op_assign
id|de-&gt;next_lru
suffix:semicolon
r_else
(brace
id|remove_lru
c_func
(paren
id|de
)paren
suffix:semicolon
id|add_lru
c_func
(paren
id|de
comma
op_star
id|de-&gt;lru_head
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Stupid name&quot;hash&quot; algorithm. Write something better if you want to,&n; * but I doubt it matters that much&n; */
DECL|function|namehash
r_static
r_inline
r_int
r_int
id|namehash
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
r_return
id|len
op_plus
(paren
(paren
r_const
r_int
r_char
op_star
)paren
id|name
)paren
(braket
l_int|0
)braket
op_plus
(paren
(paren
r_const
r_int
r_char
op_star
)paren
id|name
)paren
(braket
id|len
op_minus
l_int|1
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * Hash queue manipulation. Look out for the casts..&n; */
DECL|function|remove_hash
r_static
r_inline
r_void
id|remove_hash
c_func
(paren
r_struct
id|dir_cache_entry
op_star
id|de
)paren
(brace
r_struct
id|dir_cache_entry
op_star
id|next
op_assign
id|de-&gt;h.next
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
(brace
r_struct
id|dir_cache_entry
op_star
id|prev
op_assign
id|de-&gt;h.prev
suffix:semicolon
id|next-&gt;h.prev
op_assign
id|prev
suffix:semicolon
id|prev-&gt;h.next
op_assign
id|next
suffix:semicolon
id|de-&gt;h.next
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|add_hash
r_static
r_inline
r_void
id|add_hash
c_func
(paren
r_struct
id|dir_cache_entry
op_star
id|de
comma
r_struct
id|hash_list
op_star
id|hash
)paren
(brace
r_struct
id|dir_cache_entry
op_star
id|next
op_assign
id|hash-&gt;next
suffix:semicolon
id|de-&gt;h.next
op_assign
id|next
suffix:semicolon
id|de-&gt;h.prev
op_assign
(paren
r_struct
id|dir_cache_entry
op_star
)paren
id|hash
suffix:semicolon
id|next-&gt;h.prev
op_assign
id|de
suffix:semicolon
id|hash-&gt;next
op_assign
id|de
suffix:semicolon
)brace
multiline_comment|/*&n; * Find a directory cache entry given all the necessary info.&n; */
DECL|function|find_entry
r_static
r_inline
r_struct
id|dir_cache_entry
op_star
id|find_entry
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
r_struct
id|hash_list
op_star
id|hash
)paren
(brace
r_struct
id|dir_cache_entry
op_star
id|de
op_assign
id|hash-&gt;next
suffix:semicolon
r_for
c_loop
(paren
id|de
op_assign
id|hash-&gt;next
suffix:semicolon
id|de
op_ne
(paren
r_struct
id|dir_cache_entry
op_star
)paren
id|hash
suffix:semicolon
id|de
op_assign
id|de-&gt;h.next
)paren
(brace
r_if
c_cond
(paren
id|de-&gt;dc_dev
op_ne
id|dir-&gt;i_dev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;dir
op_ne
id|dir-&gt;i_ino
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;version
op_ne
id|dir-&gt;i_version
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;name_len
op_ne
id|len
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|de-&gt;name
comma
id|name
comma
id|len
)paren
)paren
r_continue
suffix:semicolon
r_return
id|de
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Move a successfully used entry to level2. If already at level2,&n; * move it to the end of the LRU queue..&n; */
DECL|function|move_to_level2
r_static
r_inline
r_void
id|move_to_level2
c_func
(paren
r_struct
id|dir_cache_entry
op_star
id|old_de
comma
r_struct
id|hash_list
op_star
id|hash
)paren
(brace
r_struct
id|dir_cache_entry
op_star
id|de
suffix:semicolon
r_if
c_cond
(paren
id|old_de-&gt;lru_head
op_eq
op_amp
id|level2_head
)paren
(brace
id|update_lru
c_func
(paren
id|old_de
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|de
op_assign
id|level2_head
suffix:semicolon
id|level2_head
op_assign
id|de-&gt;next_lru
suffix:semicolon
id|remove_hash
c_func
(paren
id|de
)paren
suffix:semicolon
id|COPYDATA
c_func
(paren
id|old_de
comma
id|de
)paren
suffix:semicolon
id|add_hash
c_func
(paren
id|de
comma
id|hash
)paren
suffix:semicolon
)brace
DECL|function|dcache_lookup
r_int
id|dcache_lookup
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
r_int
r_int
op_star
id|ino
)paren
(brace
r_struct
id|hash_list
op_star
id|hash
suffix:semicolon
r_struct
id|dir_cache_entry
op_star
id|de
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|DCACHE_NAME_LEN
)paren
r_return
l_int|0
suffix:semicolon
id|hash
op_assign
id|hash_table
op_plus
id|hash_fn
c_func
(paren
id|dir-&gt;i_dev
comma
id|dir-&gt;i_ino
comma
id|namehash
c_func
(paren
id|name
comma
id|len
)paren
)paren
suffix:semicolon
id|de
op_assign
id|find_entry
c_func
(paren
id|dir
comma
id|name
comma
id|len
comma
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|ino
op_assign
id|de-&gt;ino
suffix:semicolon
id|move_to_level2
c_func
(paren
id|de
comma
id|hash
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|dcache_add
r_void
id|dcache_add
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
r_int
r_int
id|ino
)paren
(brace
r_struct
id|hash_list
op_star
id|hash
suffix:semicolon
r_struct
id|dir_cache_entry
op_star
id|de
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|DCACHE_NAME_LEN
)paren
r_return
suffix:semicolon
id|hash
op_assign
id|hash_table
op_plus
id|hash_fn
c_func
(paren
id|dir-&gt;i_dev
comma
id|dir-&gt;i_ino
comma
id|namehash
c_func
(paren
id|name
comma
id|len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|de
op_assign
id|find_entry
c_func
(paren
id|dir
comma
id|name
comma
id|len
comma
id|hash
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|de-&gt;ino
op_assign
id|ino
suffix:semicolon
id|update_lru
c_func
(paren
id|de
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|de
op_assign
id|level1_head
suffix:semicolon
id|level1_head
op_assign
id|de-&gt;next_lru
suffix:semicolon
id|remove_hash
c_func
(paren
id|de
)paren
suffix:semicolon
id|de-&gt;dc_dev
op_assign
id|dir-&gt;i_dev
suffix:semicolon
id|de-&gt;dir
op_assign
id|dir-&gt;i_ino
suffix:semicolon
id|de-&gt;version
op_assign
id|dir-&gt;i_version
suffix:semicolon
id|de-&gt;ino
op_assign
id|ino
suffix:semicolon
id|de-&gt;name_len
op_assign
id|len
suffix:semicolon
id|memcpy
c_func
(paren
id|de-&gt;name
comma
id|name
comma
id|len
)paren
suffix:semicolon
id|add_hash
c_func
(paren
id|de
comma
id|hash
)paren
suffix:semicolon
)brace
DECL|function|name_cache_init
r_int
r_int
id|name_cache_init
c_func
(paren
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|dir_cache_entry
op_star
id|p
suffix:semicolon
multiline_comment|/*&n;&t; * Init level1 LRU lists..&n;&t; */
id|p
op_assign
id|level1_cache
suffix:semicolon
r_do
(brace
id|p
(braket
l_int|1
)braket
dot
id|prev_lru
op_assign
id|p
suffix:semicolon
id|p
(braket
l_int|0
)braket
dot
id|next_lru
op_assign
id|p
op_plus
l_int|1
suffix:semicolon
id|p
(braket
l_int|0
)braket
dot
id|lru_head
op_assign
op_amp
id|level1_head
suffix:semicolon
)brace
r_while
c_loop
(paren
op_increment
id|p
OL
id|level1_cache
op_plus
id|DCACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|level1_cache
(braket
l_int|0
)braket
dot
id|prev_lru
op_assign
id|p
suffix:semicolon
id|p
(braket
l_int|0
)braket
dot
id|next_lru
op_assign
op_amp
id|level1_cache
(braket
l_int|0
)braket
suffix:semicolon
id|p
(braket
l_int|0
)braket
dot
id|lru_head
op_assign
op_amp
id|level1_head
suffix:semicolon
id|level1_head
op_assign
id|level1_cache
suffix:semicolon
multiline_comment|/*&n;&t; * Init level2 LRU lists..&n;&t; */
id|p
op_assign
id|level2_cache
suffix:semicolon
r_do
(brace
id|p
(braket
l_int|1
)braket
dot
id|prev_lru
op_assign
id|p
suffix:semicolon
id|p
(braket
l_int|0
)braket
dot
id|next_lru
op_assign
id|p
op_plus
l_int|1
suffix:semicolon
id|p
(braket
l_int|0
)braket
dot
id|lru_head
op_assign
op_amp
id|level2_head
suffix:semicolon
)brace
r_while
c_loop
(paren
op_increment
id|p
OL
id|level2_cache
op_plus
id|DCACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|level2_cache
(braket
l_int|0
)braket
dot
id|prev_lru
op_assign
id|p
suffix:semicolon
id|p
(braket
l_int|0
)braket
dot
id|next_lru
op_assign
op_amp
id|level2_cache
(braket
l_int|0
)braket
suffix:semicolon
id|p
(braket
l_int|0
)braket
dot
id|lru_head
op_assign
op_amp
id|level2_head
suffix:semicolon
id|level2_head
op_assign
id|level2_cache
suffix:semicolon
multiline_comment|/*&n;&t; * Empty hash queues..&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DCACHE_HASH_QUEUES
suffix:semicolon
id|i
op_increment
)paren
id|hash_table
(braket
id|i
)braket
dot
id|next
op_assign
id|hash_table
(braket
id|i
)braket
dot
id|next
op_assign
(paren
r_struct
id|dir_cache_entry
op_star
)paren
op_amp
id|hash_table
(braket
id|i
)braket
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
eof
