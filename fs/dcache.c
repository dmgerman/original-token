multiline_comment|/*&n; * fs/dcache.c&n; *&n; * Complete reimplementation&n; * (C) 1997 Thomas Schoebel-Theuer&n; */
multiline_comment|/* The new dcache is exclusively called from the VFS, not from&n; * the specific fs&squot;es any more. Despite having the same name as in the&n; * old code, it has less to do with it.&n; *&n; * It serves many purposes:&n; *&n; *  1) Any inode that has been retrieved with lookup() and is in use&n; *     (i_count&gt;0), has access to its full absolute path name, by going&n; *     to inode-&gt;i_dentry and then recursively following the entry-&gt;d_parent&n; *     chain. Use d_path() as predefined method for that.&n; *     You may find out the corresponding inode belonging to&n; *     a dentry by calling d_inode(). This can be used as an easy way for&n; *     determining .. and its absolute pathname, an old UNIX problem that&n; *     deserved a solution for a long time.&n; *     Note that hardlinked inodes may have multiple dentries assigned to&n; *     (via the d_next chain), reflecting multiple alias pathnames.&n; *&n; *  2) If not disabled by filesystem types specifying FS_NO_DCACHE,&n; *     the dentries of unused (aged) inodes are retained for speeding up&n; *     lookup()s, by allowing hashed inquiry starting from the dentry of&n; *     the parent directory.&n; *&n; *  3) It can remeber so-called &quot;negative entries&quot;, that is dentries for&n; *     pathnames that are known to *not* exist, so unneccessary repeated&n; *     lookup()s for non-existant names can be saved.&n; *&n; *  4) It provides a means for keeping deleted files (inode-&gt;i_nlink==0)&n; *     accessible in the so-called *basket*. Inodes in the basket have been&n; *     removed with unlink() while being in use (i_count&gt;0), so they would&n; *     normally use up space on the disk and be accessile through their&n; *     filedescriptor, but would not be accessible for lookup() any more.&n; *     The basket simply keeps such files in the dcache (for potential&n; *     dcache lookup) until they are either eventually removed completely,&n; *     or transferred to the second-level basket, the so-called *ibasket*.&n; *     The ibasket is implemented in the new inode code, on request of&n; *     filesystem types that have the flag FS_IBASKET set, and proliferates&n; *     the unlinked files when i_count has gone to zero, at least as long&n; *     as there is space on the disk and enough inodes remain available&n; *     and no umount() has started.&n; *&n; *  5) Preliminary dentries can be added by readdir(). While normal dentries&n; *     directly point to the inode via u.d_inode only the inode number is&n; *     known from readdir(), but not more. They can be converted to&n; *     normal dentries by using d_inode().&n; */
multiline_comment|/*&n; * Notes on the allocation strategy:&n; *&n; * The dcache is a full slave cache of the inodes. Whenever an inode&n; * is cleared, all the dentries associated with it will recursively&n; * disappear. dentries have no own reference counting; this has to&n; * be obeyed for SMP.&n; * If directories could go out of inode cache while&n; * successors are alive, this would interrupt the d_parent chain of&n; * the live successors. To prevent this without using zombies, all&n; * directories are thus prevented from __iput() as long as successors&n; * are alive.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/dalloc.h&gt;
macro_line|#include &lt;linux/dlists.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
multiline_comment|/* this should be removed after the beta phase */
multiline_comment|/* #define DEBUG */
multiline_comment|/*#undef DEBUG*/
multiline_comment|/* #define DEBUG_DDIR_COUNT */
DECL|macro|D_HASHSIZE
mdefine_line|#define D_HASHSIZE   64
multiline_comment|/* local flags for d_flag */
DECL|macro|D_DIR
mdefine_line|#define D_DIR          32
DECL|macro|D_HASHED
mdefine_line|#define D_HASHED       64
DECL|macro|D_ZOMBIE
mdefine_line|#define D_ZOMBIE      128
DECL|macro|D_PRELIMINARY
mdefine_line|#define D_PRELIMINARY 256
DECL|macro|D_INC_DDIR
mdefine_line|#define D_INC_DDIR    512
multiline_comment|/* local flags for d_del() */
DECL|macro|D_RECURSIVE
mdefine_line|#define D_RECURSIVE 4
DECL|macro|D_NO_FREE
mdefine_line|#define D_NO_FREE   8
multiline_comment|/* This is only used for directory dentries. Think of it as an extension&n; * of the dentry.&n; * It is defined as separate struct, so it uses up space only&n; * where necessary.&n; */
DECL|struct|ddir
r_struct
id|ddir
(brace
DECL|member|dd_hashtable
r_struct
id|dentry
op_star
id|dd_hashtable
(braket
id|D_HASHSIZE
)braket
suffix:semicolon
DECL|member|dd_neglist
r_struct
id|dentry
op_star
id|dd_neglist
suffix:semicolon
DECL|member|dd_basketlist
r_struct
id|dentry
op_star
id|dd_basketlist
suffix:semicolon
DECL|member|dd_zombielist
r_struct
id|dentry
op_star
id|dd_zombielist
suffix:semicolon
DECL|member|dd_alloced
r_int
r_int
id|dd_alloced
suffix:semicolon
multiline_comment|/* # d_alloc()ed, but not yet d_add()ed */
DECL|member|dd_hashed
r_int
r_int
id|dd_hashed
suffix:semicolon
multiline_comment|/* # of entries in hashtable */
DECL|member|dd_true_hashed
r_int
r_int
id|dd_true_hashed
suffix:semicolon
multiline_comment|/* # non-preliminaries in hashtable */
DECL|member|dd_negs
r_int
r_int
id|dd_negs
suffix:semicolon
multiline_comment|/* # of negative entries */
)brace
suffix:semicolon
id|DEF_INSERT
c_func
(paren
id|alias
comma
r_struct
id|dentry
comma
id|d_next
comma
id|d_prev
)paren
id|DEF_REMOVE
c_func
(paren
id|alias
comma
r_struct
id|dentry
comma
id|d_next
comma
id|d_prev
)paren
id|DEF_INSERT
c_func
(paren
id|hash
comma
r_struct
id|dentry
comma
id|d_hash_next
comma
id|d_hash_prev
)paren
id|DEF_REMOVE
c_func
(paren
id|hash
comma
r_struct
id|dentry
comma
id|d_hash_next
comma
id|d_hash_prev
)paren
id|DEF_INSERT
c_func
(paren
id|basket
comma
r_struct
id|dentry
comma
id|d_basket_next
comma
id|d_basket_prev
)paren
id|DEF_REMOVE
c_func
(paren
id|basket
comma
r_struct
id|dentry
comma
id|d_basket_next
comma
id|d_basket_prev
)paren
DECL|variable|the_root
r_struct
id|dentry
op_star
id|the_root
op_assign
l_int|NULL
suffix:semicolon
DECL|function|name_cache_init
r_int
r_int
id|name_cache_init
c_func
(paren
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
)paren
(brace
r_return
id|mem_start
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
multiline_comment|/* throw this away after the beta phase */
multiline_comment|/*************************************************************************/
r_extern
r_void
id|xcheck
c_func
(paren
r_char
op_star
id|txt
comma
r_struct
id|inode
op_star
id|p
)paren
suffix:semicolon
DECL|variable|x_alloc
r_static
r_int
id|x_alloc
op_assign
l_int|0
suffix:semicolon
DECL|variable|x_freed
r_static
r_int
id|x_freed
op_assign
l_int|0
suffix:semicolon
DECL|variable|x_free
r_static
r_int
id|x_free
op_assign
l_int|0
suffix:semicolon
DECL|variable|tst
r_static
r_void
op_star
id|tst
(braket
l_int|20000
)braket
suffix:semicolon
DECL|variable|cnt
r_static
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
DECL|function|ins
r_static
r_void
id|ins
c_func
(paren
r_void
op_star
id|ptr
)paren
(brace
r_extern
r_int
id|inodes_stat
suffix:semicolon
id|tst
(braket
id|cnt
op_increment
)braket
op_assign
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_mod
l_int|1000
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;------%d allocated: %d: %d %d %d&bslash;n&quot;
comma
id|inodes_stat
comma
id|cnt
comma
id|x_alloc
comma
id|x_freed
comma
id|x_free
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cnt
op_ge
l_int|20000
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;stop&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#if 0
r_static
r_inline
r_int
id|search
c_func
(paren
r_void
op_star
id|ptr
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|cnt
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
r_if
c_cond
(paren
id|tst
(braket
id|i
)braket
op_eq
id|ptr
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
mdefine_line|#define TST(n,x) if(search(x)&lt;0) printk(&quot;%s bad ptr %p line %d&bslash;n&quot;, n, x, __LINE__)
macro_line|#else
DECL|macro|TST
mdefine_line|#define TST(n,x) /*nothing*/
macro_line|#endif
DECL|function|LOG
r_void
id|LOG
c_func
(paren
r_char
op_star
id|txt
comma
r_struct
id|dentry
op_star
id|entry
)paren
(brace
r_static
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
(brace
id|TST
c_func
(paren
id|txt
comma
id|entry
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
)paren
(brace
id|count
op_decrement
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: entry=%p&bslash;n&quot;
comma
id|txt
comma
id|entry
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG_DDIR_COUNT
r_static
r_struct
id|ddir
op_star
id|d_dir
c_func
(paren
r_struct
id|dentry
op_star
id|entry
)paren
suffix:semicolon
DECL|function|recursive_test
r_void
id|recursive_test
c_func
(paren
r_struct
id|dentry
op_star
id|entry
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|ddir
op_star
id|ddir
op_assign
id|d_dir
c_func
(paren
id|entry
)paren
suffix:semicolon
r_int
id|sons
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ddir-&gt;dd_zombielist
)paren
(brace
id|sons
op_increment
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|D_HASHSIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|dentry
op_star
op_star
id|base
op_assign
op_amp
id|ddir-&gt;dd_hashtable
(braket
id|i
)braket
suffix:semicolon
r_struct
id|dentry
op_star
id|tmp
op_assign
op_star
id|base
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
r_do
(brace
id|TST
c_func
(paren
l_string|&quot;__clear&quot;
comma
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp-&gt;d_flag
op_amp
id|D_HASHED
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: dcache entry not hashed!&bslash;n&quot;
)paren
suffix:semicolon
id|printpath
c_func
(paren
op_star
id|base
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printpath
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp-&gt;d_flag
op_amp
id|D_PRELIMINARY
)paren
)paren
(brace
id|sons
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp-&gt;d_flag
op_amp
id|D_DIR
)paren
(brace
id|recursive_test
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|tmp
op_assign
id|tmp-&gt;d_hash_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_logical_and
id|tmp
op_ne
op_star
id|base
)paren
(brace
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|sons
op_logical_and
op_logical_neg
(paren
id|entry-&gt;d_flag
op_amp
id|D_PRELIMINARY
)paren
op_logical_and
id|entry-&gt;u.d_inode
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|entry-&gt;u.d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inode-&gt;i_status
op_amp
l_int|1
multiline_comment|/*ST_AGED*/
)paren
)paren
(brace
id|printpath
c_func
(paren
id|entry
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; is not aged!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inode-&gt;i_ddir_count
)paren
(brace
id|printpath
c_func
(paren
id|entry
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; has ddir_count blockage!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#else
DECL|macro|recursive_test
mdefine_line|#define recursive_test(e) /*nothing*/
macro_line|#endif
macro_line|#else
DECL|macro|TST
mdefine_line|#define TST(n,x) /*nothing*/
DECL|macro|LOG
mdefine_line|#define LOG(n,x) /*nothing*/
DECL|macro|xcheck
mdefine_line|#define xcheck(t,i) /*nothing*/
DECL|macro|recursive_test
mdefine_line|#define recursive_test(e) /*nothing*/
multiline_comment|/*****************************************************************************/
macro_line|#endif
DECL|function|printpath
r_void
id|printpath
c_func
(paren
r_struct
id|dentry
op_star
id|entry
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|IS_ROOT
c_func
(paren
id|entry
)paren
)paren
(brace
id|printpath
c_func
(paren
id|entry-&gt;d_parent
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;/%s&quot;
comma
id|entry-&gt;d_name.name
)paren
suffix:semicolon
)brace
DECL|function|has_sons
r_static
r_inline
r_int
id|has_sons
c_func
(paren
r_struct
id|ddir
op_star
id|ddir
)paren
(brace
r_return
(paren
(paren
id|ddir-&gt;dd_alloced
op_or
id|ddir-&gt;dd_hashed
)paren
op_logical_or
id|ddir-&gt;dd_neglist
op_logical_or
id|ddir-&gt;dd_basketlist
op_logical_or
id|ddir-&gt;dd_zombielist
)paren
suffix:semicolon
)brace
DECL|function|has_true_sons
r_static
r_inline
r_int
id|has_true_sons
c_func
(paren
r_struct
id|ddir
op_star
id|ddir
)paren
(brace
r_return
(paren
id|ddir-&gt;dd_alloced
op_or
id|ddir-&gt;dd_true_hashed
)paren
suffix:semicolon
)brace
multiline_comment|/* Only hold the i_ddir_count pseudo refcount when neccessary (i.e. when&n; * they have true_sons), to prevent keeping too much dir inodes in use.&n; */
DECL|function|inc_ddir
r_static
r_inline
r_void
id|inc_ddir
c_func
(paren
r_struct
id|dentry
op_star
id|entry
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;d_flag
op_amp
id|D_INC_DDIR
)paren
)paren
(brace
id|entry-&gt;d_flag
op_or_assign
id|D_INC_DDIR
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|inode-&gt;i_ddir_count
)paren
(brace
id|printpath
c_func
(paren
id|entry
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; ddir_count=%d&bslash;n&quot;
comma
id|inode-&gt;i_ddir_count
)paren
suffix:semicolon
)brace
macro_line|#endif
id|inode-&gt;i_ddir_count
op_increment
suffix:semicolon
id|_get_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
)brace
DECL|function|dec_ddir
r_static
r_inline
id|blocking
r_void
id|dec_ddir
c_func
(paren
r_struct
id|dentry
op_star
id|entry
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;d_flag
op_amp
id|D_INC_DDIR
)paren
(brace
id|entry-&gt;d_flag
op_and_assign
op_complement
id|D_INC_DDIR
suffix:semicolon
id|inode-&gt;i_ddir_count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_ddir_count
)paren
(brace
id|__iput
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Do not inline this many times. */
DECL|function|d_panic
r_static
r_void
id|d_panic
c_func
(paren
r_void
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;VFS: dcache directory corruption&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * IF this is a directory, the ddir has been allocated right&n; * after the dentry.&n; */
DECL|function|d_dir
r_static
r_inline
r_struct
id|ddir
op_star
id|d_dir
c_func
(paren
r_struct
id|dentry
op_star
id|entry
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;d_flag
op_amp
id|D_DIR
)paren
)paren
(brace
id|d_panic
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
(paren
r_struct
id|ddir
op_star
)paren
(paren
id|entry
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|macro|NAME_ALLOC_LEN
mdefine_line|#define NAME_ALLOC_LEN(len)&t;((len+16) &amp; ~15)
DECL|function|d_alloc
r_struct
id|dentry
op_star
id|d_alloc
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_int
id|len
comma
r_int
id|isdir
)paren
(brace
r_struct
id|dentry
op_star
id|res
suffix:semicolon
r_int
id|size
op_assign
r_sizeof
(paren
r_struct
id|dentry
)paren
suffix:semicolon
r_int
id|flag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|isdir
)paren
(brace
id|size
op_add_assign
r_sizeof
(paren
r_struct
id|ddir
)paren
suffix:semicolon
id|flag
op_assign
id|D_DIR
suffix:semicolon
)brace
id|res
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|res
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|res-&gt;d_flag
op_assign
id|flag
suffix:semicolon
id|res-&gt;d_name.name
op_assign
id|kmalloc
c_func
(paren
id|NAME_ALLOC_LEN
c_func
(paren
id|len
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res-&gt;d_name.name
)paren
(brace
id|kfree
c_func
(paren
id|res
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|res-&gt;d_name.len
op_assign
id|len
suffix:semicolon
id|res-&gt;d_parent
op_assign
id|parent
suffix:semicolon
r_if
c_cond
(paren
id|parent
)paren
(brace
r_struct
id|ddir
op_star
id|pdir
op_assign
id|d_dir
c_func
(paren
id|parent
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|pdir-&gt;dd_alloced
OG
l_int|1
op_logical_and
op_logical_neg
id|IS_ROOT
c_func
(paren
id|parent
)paren
)paren
(brace
id|printpath
c_func
(paren
id|parent
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; dd_alloced=%d&bslash;n&quot;
comma
id|pdir-&gt;dd_alloced
)paren
suffix:semicolon
)brace
macro_line|#endif
id|pdir-&gt;dd_alloced
op_increment
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|x_alloc
op_increment
suffix:semicolon
macro_line|#endif
r_return
id|res
suffix:semicolon
)brace
DECL|function|d_alloc_root
r_extern
id|blocking
r_struct
id|dentry
op_star
id|d_alloc_root
c_func
(paren
r_struct
id|inode
op_star
id|root_inode
)paren
(brace
r_struct
id|dentry
op_star
id|res
op_assign
id|the_root
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
id|d_del
c_func
(paren
id|res
comma
id|D_NO_CLEAR_INODE
)paren
suffix:semicolon
multiline_comment|/* invalidate everything beyond */
)brace
r_else
(brace
r_struct
id|ddir
op_star
id|ddir
suffix:semicolon
id|the_root
op_assign
id|res
op_assign
id|d_alloc
c_func
(paren
l_int|NULL
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|LOG
c_func
(paren
l_string|&quot;d_alloc_root&quot;
comma
id|res
)paren
suffix:semicolon
id|res-&gt;d_parent
op_assign
id|res
suffix:semicolon
id|res-&gt;d_name.name
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|ddir
op_assign
id|d_dir
c_func
(paren
id|res
)paren
suffix:semicolon
id|ddir-&gt;dd_alloced
op_assign
l_int|999
suffix:semicolon
multiline_comment|/* protect from deletion */
)brace
id|insert_alias
c_func
(paren
op_amp
id|root_inode-&gt;i_dentry
comma
id|res
)paren
suffix:semicolon
id|root_inode-&gt;i_dent_count
op_increment
suffix:semicolon
id|root_inode-&gt;i_ddir_count
op_increment
suffix:semicolon
id|res-&gt;u.d_inode
op_assign
id|root_inode
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|d_hash
r_static
r_inline
r_int
r_int
id|d_hash
c_func
(paren
r_char
id|first
comma
r_char
id|last
)paren
(brace
r_return
(paren
(paren
r_int
r_int
)paren
id|first
op_xor
(paren
(paren
r_int
r_int
)paren
id|last
op_lshift
l_int|4
)paren
)paren
op_amp
(paren
id|D_HASHSIZE
op_minus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|d_base_entry
r_static
r_inline
r_struct
id|dentry
op_star
op_star
id|d_base_entry
c_func
(paren
r_struct
id|ddir
op_star
id|pdir
comma
r_struct
id|dentry
op_star
id|entry
)paren
(brace
r_return
op_amp
id|pdir-&gt;dd_hashtable
(braket
id|d_hash
c_func
(paren
id|entry-&gt;d_name.name
(braket
l_int|0
)braket
comma
id|entry-&gt;d_name.name
(braket
id|entry-&gt;d_name.len
op_minus
l_int|1
)braket
)paren
)braket
suffix:semicolon
)brace
DECL|function|d_base_qstr
r_static
r_inline
r_struct
id|dentry
op_star
op_star
id|d_base_qstr
c_func
(paren
r_struct
id|ddir
op_star
id|pdir
comma
r_struct
id|qstr
op_star
id|s1
comma
r_struct
id|qstr
op_star
id|s2
)paren
(brace
r_int
r_int
id|hash
suffix:semicolon
r_if
c_cond
(paren
id|s2
op_logical_and
id|s2-&gt;len
)paren
(brace
id|hash
op_assign
id|d_hash
c_func
(paren
id|s1-&gt;name
(braket
l_int|0
)braket
comma
id|s2-&gt;name
(braket
id|s2-&gt;len
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|hash
op_assign
id|d_hash
c_func
(paren
id|s1-&gt;name
(braket
l_int|0
)braket
comma
id|s1-&gt;name
(braket
id|s1-&gt;len
op_minus
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_return
op_amp
id|pdir-&gt;dd_hashtable
(braket
id|hash
)braket
suffix:semicolon
)brace
DECL|function|_d_remove_from_parent
r_static
multiline_comment|/*inline*/
id|blocking
r_void
id|_d_remove_from_parent
c_func
(paren
r_struct
id|dentry
op_star
id|entry
comma
r_struct
id|ddir
op_star
id|pdir
comma
r_struct
id|inode
op_star
id|inode
comma
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;d_flag
op_amp
id|D_HASHED
)paren
(brace
r_struct
id|dentry
op_star
op_star
id|base
op_assign
id|d_base_entry
c_func
(paren
id|pdir
comma
id|entry
)paren
suffix:semicolon
id|remove_hash
c_func
(paren
id|base
comma
id|entry
)paren
suffix:semicolon
id|entry-&gt;d_flag
op_and_assign
op_complement
id|D_HASHED
suffix:semicolon
id|pdir-&gt;dd_hashed
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;d_flag
op_amp
id|D_PRELIMINARY
)paren
)paren
(brace
id|pdir-&gt;dd_true_hashed
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;d_next
op_logical_or
op_logical_neg
id|entry-&gt;d_prev
)paren
(brace
id|printpath
c_func
(paren
id|entry
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; flags=%x d_flag=%x negs=%d &quot;
l_string|&quot;hashed=%d&bslash;n&quot;
comma
id|flags
comma
id|entry-&gt;d_flag
comma
id|pdir-&gt;dd_negs
comma
id|pdir-&gt;dd_hashed
)paren
suffix:semicolon
)brace
macro_line|#endif
id|remove_alias
c_func
(paren
op_amp
id|pdir-&gt;dd_neglist
comma
id|entry
)paren
suffix:semicolon
id|pdir-&gt;dd_negs
op_decrement
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry-&gt;d_flag
op_amp
id|D_ZOMBIE
)paren
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_logical_neg
id|pdir-&gt;dd_alloced
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;dd_alloced is 0!&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|pdir-&gt;dd_alloced
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;d_flag
op_amp
id|D_BASKET
)paren
(brace
id|remove_basket
c_func
(paren
op_amp
id|pdir-&gt;dd_basketlist
comma
id|entry
)paren
suffix:semicolon
id|entry-&gt;d_flag
op_and_assign
op_complement
id|D_BASKET
suffix:semicolon
)brace
)brace
multiline_comment|/* Theoretically, zombies should never or extremely seldom appear,&n; * so this code is nearly superfluous.&n; * A way to get zombies is while using inodes (i_count&gt;0), unlink()&n; * them as well as rmdir() the parent dir =&gt; the parent dir becomes a zombie.&n; * Zombies are *not* in the hashtable, because somebody could re-creat()&n; * that filename in it&squot;s parent dir again.&n; * Besides coding errors during beta phase, when forcing an umount()&n; * (e.g. at shutdown time), inodes could be in use such that the parent&n; * dir is cleared, resulting also in zombies.&n; */
DECL|function|_d_handle_zombie
r_static
multiline_comment|/*inline*/
r_void
id|_d_handle_zombie
c_func
(paren
r_struct
id|dentry
op_star
id|entry
comma
r_struct
id|ddir
op_star
id|ddir
comma
r_struct
id|ddir
op_star
id|pdir
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;d_flag
op_amp
id|D_DIR
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;d_flag
op_amp
id|D_ZOMBIE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|has_sons
c_func
(paren
id|ddir
)paren
)paren
(brace
id|entry-&gt;d_flag
op_and_assign
op_complement
id|D_ZOMBIE
suffix:semicolon
id|remove_hash
c_func
(paren
op_amp
id|pdir-&gt;dd_zombielist
comma
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pdir-&gt;dd_zombielist
op_logical_and
(paren
id|entry-&gt;d_parent-&gt;d_flag
op_amp
id|D_ZOMBIE
)paren
)paren
(brace
id|d_del
c_func
(paren
id|entry-&gt;d_parent
comma
id|D_NORMAL
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|has_sons
c_func
(paren
id|ddir
)paren
)paren
(brace
id|entry-&gt;d_flag
op_or_assign
id|D_ZOMBIE
suffix:semicolon
id|insert_hash
c_func
(paren
op_amp
id|pdir-&gt;dd_zombielist
comma
id|entry
)paren
suffix:semicolon
multiline_comment|/* This condition is no longer a bug, with the removal&n;&t;&t;&t; * of recursive_clear() this happens naturally during&n;&t;&t;&t; * an unmount attempt of a filesystem which is busy.&n;&t;&t;&t; */
macro_line|#if 0
multiline_comment|/* Not sure when this message should show up... */
r_if
c_cond
(paren
op_logical_neg
id|IS_ROOT
c_func
(paren
id|entry
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: clearing dcache directory &quot;
l_string|&quot;with successors&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printpath
c_func
(paren
id|entry
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; d_flag=%x alloced=%d negs=%d hashed=%d &quot;
l_string|&quot;basket=%p zombies=%p&bslash;n&quot;
comma
id|entry-&gt;d_flag
comma
id|ddir-&gt;dd_alloced
comma
id|ddir-&gt;dd_negs
comma
id|ddir-&gt;dd_hashed
comma
id|ddir-&gt;dd_basketlist
comma
id|ddir-&gt;dd_zombielist
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif
)brace
)brace
)brace
DECL|function|_d_del
r_static
multiline_comment|/*inline*/
id|blocking
r_void
id|_d_del
c_func
(paren
r_struct
id|dentry
op_star
id|entry
comma
r_int
id|flags
)paren
(brace
r_struct
id|ddir
op_star
id|ddir
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|ddir
op_star
id|pdir
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|entry-&gt;d_flag
op_amp
id|D_PRELIMINARY
ques
c_cond
l_int|NULL
suffix:colon
id|entry-&gt;u.d_inode
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|inode
)paren
(brace
id|xcheck
c_func
(paren
l_string|&quot;_d_del&quot;
comma
id|inode
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;d_parent
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: dcache parent is NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pdir
op_assign
id|d_dir
c_func
(paren
id|entry-&gt;d_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ROOT
c_func
(paren
id|entry
)paren
)paren
(brace
id|_d_remove_from_parent
c_func
(paren
id|entry
comma
id|pdir
comma
id|inode
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* This may block, be careful! _d_remove_from_parent() is&n;&t; * thus called before.&n;&t; */
r_if
c_cond
(paren
id|entry-&gt;d_flag
op_amp
id|D_DIR
)paren
(brace
id|ddir
op_assign
id|d_dir
c_func
(paren
id|entry
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_ROOT
c_func
(paren
id|entry
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|D_NO_FREE
)paren
(brace
multiline_comment|/* Make it re-d_add()able */
id|pdir-&gt;dd_alloced
op_increment
suffix:semicolon
id|entry-&gt;d_flag
op_and_assign
id|D_DIR
suffix:semicolon
)brace
r_else
id|_d_handle_zombie
c_func
(paren
id|entry
comma
id|ddir
comma
id|pdir
)paren
suffix:semicolon
multiline_comment|/* This dec_ddir() must occur after zombie handling. */
r_if
c_cond
(paren
op_logical_neg
id|has_true_sons
c_func
(paren
id|pdir
)paren
)paren
(brace
id|dec_ddir
c_func
(paren
id|entry-&gt;d_parent
comma
id|entry-&gt;d_parent-&gt;u.d_inode
)paren
suffix:semicolon
)brace
id|entry-&gt;u.d_inode
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
id|remove_alias
c_func
(paren
op_amp
id|inode-&gt;i_dentry
comma
id|entry
)paren
suffix:semicolon
id|inode-&gt;i_dent_count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;d_flag
op_amp
id|D_DIR
)paren
id|dec_ddir
c_func
(paren
id|entry
comma
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|D_NO_CLEAR_INODE
)paren
op_logical_and
op_logical_neg
(paren
id|atomic_read
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
op_plus
id|inode-&gt;i_ddir_count
op_plus
id|inode-&gt;i_dent_count
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;#&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* This may block also. */
id|_clear_inode
c_func
(paren
id|inode
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|D_NO_FREE
)paren
op_logical_and
op_logical_neg
(paren
id|entry-&gt;d_flag
op_amp
id|D_ZOMBIE
)paren
)paren
(brace
id|kfree
c_func
(paren
id|entry-&gt;d_name.name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|entry
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|x_freed
op_increment
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef DEBUG
id|x_free
op_increment
suffix:semicolon
macro_line|#endif
)brace
DECL|function|d_del
id|blocking
r_void
id|d_del
c_func
(paren
r_struct
id|dentry
op_star
id|entry
comma
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
(brace
r_return
suffix:semicolon
)brace
id|LOG
c_func
(paren
l_string|&quot;d_clear&quot;
comma
id|entry
)paren
suffix:semicolon
id|_d_del
c_func
(paren
id|entry
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|__dlookup
r_static
r_inline
r_struct
id|dentry
op_star
id|__dlookup
c_func
(paren
r_struct
id|dentry
op_star
op_star
id|base
comma
r_struct
id|qstr
op_star
id|name
comma
r_struct
id|qstr
op_star
id|appendix
)paren
(brace
r_struct
id|dentry
op_star
id|tmp
op_assign
op_star
id|base
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_logical_and
id|name-&gt;len
)paren
(brace
r_int
id|totallen
op_assign
id|name-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|appendix
)paren
(brace
id|totallen
op_add_assign
id|appendix-&gt;len
suffix:semicolon
)brace
r_do
(brace
r_if
c_cond
(paren
id|tmp-&gt;d_name.len
op_eq
id|totallen
op_logical_and
op_logical_neg
(paren
id|tmp-&gt;d_flag
op_amp
id|D_DUPLICATE
)paren
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|tmp-&gt;d_name.name
comma
id|name-&gt;name
comma
id|name-&gt;len
)paren
op_logical_and
(paren
op_logical_neg
id|appendix
op_logical_or
op_logical_neg
id|strncmp
c_func
(paren
id|tmp-&gt;d_name.name
op_plus
id|name-&gt;len
comma
id|appendix-&gt;name
comma
id|appendix-&gt;len
)paren
)paren
)paren
(brace
r_return
id|tmp
suffix:semicolon
)brace
id|tmp
op_assign
id|tmp-&gt;d_hash_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
op_star
id|base
)paren
(brace
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|d_lookup
r_struct
id|dentry
op_star
id|d_lookup
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|qstr
op_star
id|name
comma
r_struct
id|qstr
op_star
id|appendix
)paren
(brace
r_if
c_cond
(paren
id|dir-&gt;i_dentry
)paren
(brace
r_struct
id|ddir
op_star
id|ddir
op_assign
id|d_dir
c_func
(paren
id|dir-&gt;i_dentry
)paren
suffix:semicolon
r_struct
id|dentry
op_star
op_star
id|base
op_assign
id|d_base_qstr
c_func
(paren
id|ddir
comma
id|name
comma
id|appendix
)paren
suffix:semicolon
r_return
id|__dlookup
c_func
(paren
id|base
comma
id|name
comma
id|appendix
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|_d_insert_to_parent
r_static
multiline_comment|/*inline*/
id|blocking
r_void
id|_d_insert_to_parent
c_func
(paren
r_struct
id|dentry
op_star
id|entry
comma
r_struct
id|ddir
op_star
id|pdir
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|qstr
op_star
id|ininame
comma
r_int
id|flags
)paren
(brace
r_struct
id|dentry
op_star
op_star
id|base
suffix:semicolon
r_struct
id|dentry
op_star
id|parent
op_assign
id|entry-&gt;d_parent
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_logical_neg
id|pdir-&gt;dd_alloced
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;dd_alloced is 0!&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|base
op_assign
id|d_base_qstr
c_func
(paren
id|pdir
comma
id|ininame
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
(paren
id|D_NOCHECKDUP
op_or
id|D_DUPLICATE
)paren
)paren
op_logical_and
id|__dlookup
c_func
(paren
id|base
comma
id|ininame
comma
l_int|NULL
)paren
)paren
(brace
id|d_del
c_func
(paren
id|entry
comma
id|D_NO_CLEAR_INODE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;d_flag
op_amp
id|D_HASHED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: dcache entry is already hashed&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|D_PRELIMINARY
)paren
)paren
(brace
id|pdir-&gt;dd_true_hashed
op_increment
suffix:semicolon
)brace
id|pdir-&gt;dd_hashed
op_increment
suffix:semicolon
id|insert_hash
c_func
(paren
id|base
comma
id|entry
)paren
suffix:semicolon
id|entry-&gt;d_flag
op_or_assign
id|D_HASHED
suffix:semicolon
id|pdir-&gt;dd_alloced
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|D_BASKET
)paren
(brace
id|insert_basket
c_func
(paren
op_amp
id|pdir-&gt;dd_basketlist
comma
id|entry
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|inode
op_logical_and
id|inode-&gt;i_dentry
op_logical_and
(paren
id|entry-&gt;d_flag
op_amp
id|D_DIR
)paren
)paren
(brace
r_struct
id|dentry
op_star
id|tmp
op_assign
id|inode-&gt;i_dentry
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Auweia inode=%p entry=%p (%p %p %s)&bslash;n&quot;
comma
id|inode
comma
id|entry
comma
id|parent-&gt;u.d_inode
comma
id|parent
comma
id|parent-&gt;d_name.name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;entry path=&quot;
)paren
suffix:semicolon
id|printpath
c_func
(paren
id|entry
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_do
(brace
id|TST
c_func
(paren
l_string|&quot;auweia&quot;
comma
id|tmp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;alias path=&quot;
)paren
suffix:semicolon
id|printpath
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;d_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|inode-&gt;i_dentry
)paren
(brace
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|has_true_sons
c_func
(paren
id|pdir
)paren
)paren
(brace
id|inc_ddir
c_func
(paren
id|parent
comma
id|parent-&gt;u.d_inode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|inode
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|D_PRELIMINARY
)paren
)paren
(brace
id|insert_alias
c_func
(paren
op_amp
id|pdir-&gt;dd_neglist
comma
id|entry
)paren
suffix:semicolon
id|pdir-&gt;dd_negs
op_increment
suffix:semicolon
multiline_comment|/* Don&squot;t allow the negative list to grow too much ... */
r_while
c_loop
(paren
id|pdir-&gt;dd_negs
OG
(paren
id|pdir-&gt;dd_true_hashed
op_rshift
l_int|1
)paren
op_plus
l_int|5
)paren
(brace
id|d_del
c_func
(paren
id|pdir-&gt;dd_neglist-&gt;d_prev
comma
id|D_REMOVE
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|d_add
id|blocking
r_void
id|d_add
c_func
(paren
r_struct
id|dentry
op_star
id|entry
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|qstr
op_star
id|ininame
comma
r_int
id|flags
)paren
(brace
r_struct
id|dentry
op_star
id|parent
op_assign
id|entry-&gt;d_parent
suffix:semicolon
r_struct
id|qstr
id|dummy
suffix:semicolon
r_struct
id|ddir
op_star
id|pdir
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|inode
)paren
(brace
id|xcheck
c_func
(paren
l_string|&quot;d_add&quot;
comma
id|inode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_ROOT
c_func
(paren
id|entry
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: d_add for root dentry &quot;
)paren
suffix:semicolon
id|printpath
c_func
(paren
id|entry
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; -&gt; &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ininame
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|ininame-&gt;name
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|parent
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;d_add with parent==NULL&quot;
)paren
suffix:semicolon
)brace
id|LOG
c_func
(paren
l_string|&quot;d_add&quot;
comma
id|entry
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ininame
)paren
(brace
r_if
c_cond
(paren
id|ininame-&gt;len
op_ne
id|entry-&gt;d_name.len
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: d_add with wrong string length&quot;
)paren
suffix:semicolon
id|entry-&gt;d_name.len
op_assign
id|ininame-&gt;len
suffix:semicolon
multiline_comment|/* kludge */
)brace
id|memcpy
c_func
(paren
id|entry-&gt;d_name.name
comma
id|ininame-&gt;name
comma
id|ininame-&gt;len
)paren
suffix:semicolon
id|entry-&gt;d_name.name
(braket
id|ininame-&gt;len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_else
(brace
id|dummy.name
op_assign
id|entry-&gt;d_name.name
suffix:semicolon
id|dummy.len
op_assign
id|entry-&gt;d_name.len
suffix:semicolon
id|ininame
op_assign
op_amp
id|dummy
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry-&gt;d_flag
op_amp
id|D_HASHED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: d_add of already added dcache entry&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|pdir
op_assign
id|d_dir
c_func
(paren
id|parent
)paren
suffix:semicolon
id|_d_insert_to_parent
c_func
(paren
id|entry
comma
id|pdir
comma
id|inode
comma
id|ininame
comma
id|flags
)paren
suffix:semicolon
id|entry-&gt;d_flag
op_or_assign
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|D_PRELIMINARY
)paren
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;d_flag
op_amp
id|D_DIR
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_dentry
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: creating dcache directory alias&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|insert_alias
c_func
(paren
op_amp
id|inode-&gt;i_dentry
comma
id|entry
)paren
suffix:semicolon
id|inode-&gt;i_dent_count
op_increment
suffix:semicolon
)brace
id|entry-&gt;u.d_inode
op_assign
id|inode
suffix:semicolon
)brace
DECL|function|d_entry
id|blocking
r_struct
id|dentry
op_star
id|d_entry
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_struct
id|qstr
op_star
id|name
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|ddir
op_star
id|pdir
op_assign
id|d_dir
c_func
(paren
id|parent
)paren
suffix:semicolon
r_struct
id|dentry
op_star
op_star
id|base
op_assign
id|d_base_qstr
c_func
(paren
id|pdir
comma
id|name
comma
l_int|NULL
)paren
suffix:semicolon
r_struct
id|dentry
op_star
id|found
op_assign
id|__dlookup
c_func
(paren
id|base
comma
id|name
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
(brace
r_int
id|isdir
op_assign
(paren
id|inode
op_logical_and
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
suffix:semicolon
id|found
op_assign
id|d_alloc
c_func
(paren
id|parent
comma
id|name-&gt;len
comma
id|isdir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|found
)paren
(brace
id|d_add
c_func
(paren
id|found
comma
id|inode
comma
id|name
comma
id|isdir
ques
c_cond
(paren
id|D_DIR
op_or
id|D_NOCHECKDUP
)paren
suffix:colon
id|D_NOCHECKDUP
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;VFS: problem with d_alloc&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|found
suffix:semicolon
)brace
DECL|function|d_entry_preliminary
id|blocking
r_void
id|d_entry_preliminary
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_struct
id|qstr
op_star
id|name
comma
r_int
r_int
id|ino
)paren
(brace
r_struct
id|ddir
op_star
id|pdir
op_assign
id|d_dir
c_func
(paren
id|parent
)paren
suffix:semicolon
r_struct
id|dentry
op_star
op_star
id|base
op_assign
id|d_base_qstr
c_func
(paren
id|pdir
comma
id|name
comma
l_int|NULL
)paren
suffix:semicolon
r_struct
id|dentry
op_star
id|found
op_assign
id|__dlookup
c_func
(paren
id|base
comma
id|name
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|found
op_logical_and
id|ino
)paren
(brace
r_struct
id|dentry
op_star
r_new
op_assign
id|d_alloc
c_func
(paren
id|parent
comma
id|name-&gt;len
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
)paren
(brace
id|d_add
c_func
(paren
r_new
comma
l_int|NULL
comma
id|name
comma
id|D_PRELIMINARY
op_or
id|D_NOCHECKDUP
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|u.d_ino
op_assign
id|ino
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;VFS: problem with d_alloc&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|alloc_new_name
r_static
r_inline
r_void
id|alloc_new_name
c_func
(paren
r_struct
id|dentry
op_star
id|entry
comma
r_int
id|len
)paren
(brace
r_int
id|alloc_len
op_assign
id|NAME_ALLOC_LEN
c_func
(paren
id|len
)paren
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_if
c_cond
(paren
id|alloc_len
op_eq
id|NAME_ALLOC_LEN
c_func
(paren
id|entry-&gt;d_name.len
)paren
)paren
r_return
suffix:semicolon
id|name
op_assign
id|kmalloc
c_func
(paren
id|alloc_len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
id|printk
c_func
(paren
l_string|&quot;out of memory for dcache&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|entry-&gt;d_name.name
)paren
suffix:semicolon
id|entry-&gt;d_name.name
op_assign
id|name
suffix:semicolon
)brace
DECL|function|d_remove_old_parent
r_static
r_inline
r_void
id|d_remove_old_parent
c_func
(paren
r_struct
id|dentry
op_star
id|entry
)paren
(brace
r_struct
id|ddir
op_star
id|pdir
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|pdir
op_assign
id|d_dir
c_func
(paren
id|entry-&gt;d_parent
)paren
suffix:semicolon
id|inode
op_assign
id|entry-&gt;u.d_inode
suffix:semicolon
id|_d_remove_from_parent
c_func
(paren
id|entry
comma
id|pdir
comma
id|inode
comma
id|D_NO_CLEAR_INODE
)paren
suffix:semicolon
)brace
DECL|function|d_add_new_parent
r_static
r_inline
r_void
id|d_add_new_parent
c_func
(paren
r_struct
id|dentry
op_star
id|entry
comma
r_struct
id|inode
op_star
id|new_parent
)paren
(brace
r_struct
id|ddir
op_star
id|pdir
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|pdir
op_assign
id|d_dir
c_func
(paren
id|entry-&gt;d_parent
op_assign
id|new_parent-&gt;i_dentry
)paren
suffix:semicolon
id|inode
op_assign
id|entry-&gt;u.d_inode
suffix:semicolon
id|_d_insert_to_parent
c_func
(paren
id|entry
comma
id|pdir
comma
id|inode
comma
op_amp
id|entry-&gt;d_name
comma
id|entry-&gt;d_flag
)paren
suffix:semicolon
)brace
DECL|function|d_move
id|blocking
r_void
id|d_move
c_func
(paren
r_struct
id|dentry
op_star
id|entry
comma
r_struct
id|inode
op_star
id|newdir
comma
r_struct
id|qstr
op_star
id|newname
comma
r_struct
id|qstr
op_star
id|newapp
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|len
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
(brace
r_return
suffix:semicolon
)brace
id|inode
op_assign
id|entry-&gt;u.d_inode
suffix:semicolon
id|flags
op_assign
id|entry-&gt;d_flag
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|D_PRELIMINARY
)paren
op_logical_or
op_logical_neg
id|inode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|D_PRELIMINARY
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: trying to move negative dcache entry&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|d_del
c_func
(paren
id|entry
comma
id|D_NO_CLEAR_INODE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;d_move %p &squot;%s&squot; -&gt; &squot;%s%s&squot; dent_count=%d&bslash;n&quot;
comma
id|inode
comma
id|entry-&gt;d_name.name
comma
id|newname-&gt;name
comma
id|newapp
ques
c_cond
id|newapp-&gt;name
suffix:colon
l_string|&quot;&quot;
comma
id|inode-&gt;i_dent_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|flags
op_amp
id|D_ZOMBIE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: moving zombie entry&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|d_remove_old_parent
c_func
(paren
id|entry
)paren
suffix:semicolon
id|len
op_assign
id|newname-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|newapp
)paren
(brace
id|len
op_add_assign
id|newapp-&gt;len
suffix:semicolon
id|flags
op_or_assign
id|D_BASKET
suffix:semicolon
)brace
r_else
id|flags
op_and_assign
op_complement
id|D_BASKET
suffix:semicolon
id|alloc_new_name
c_func
(paren
id|entry
comma
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|entry-&gt;d_name.name
comma
id|newname-&gt;name
comma
id|newname-&gt;len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newapp
)paren
(brace
id|memcpy
c_func
(paren
id|entry-&gt;d_name.name
op_plus
id|newname-&gt;len
comma
id|newapp-&gt;name
comma
id|newapp-&gt;len
)paren
suffix:semicolon
)brace
id|entry-&gt;d_name.name
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|entry-&gt;d_name.len
op_assign
id|len
suffix:semicolon
id|d_add_new_parent
c_func
(paren
id|entry
comma
id|newdir
)paren
suffix:semicolon
)brace
DECL|function|d_path
r_int
id|d_path
c_func
(paren
r_struct
id|dentry
op_star
id|entry
comma
r_struct
id|inode
op_star
id|chroot
comma
r_char
op_star
id|buf
)paren
(brace
r_if
c_cond
(paren
id|IS_ROOT
c_func
(paren
id|entry
)paren
op_logical_or
(paren
id|chroot
op_logical_and
id|entry-&gt;u.d_inode
op_eq
id|chroot
op_logical_and
op_logical_neg
(paren
id|entry-&gt;d_flag
op_amp
id|D_PRELIMINARY
)paren
)paren
)paren
(brace
op_star
id|buf
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_int
id|len
op_assign
id|d_path
c_func
(paren
id|entry-&gt;d_parent
comma
id|chroot
comma
id|buf
)paren
suffix:semicolon
id|buf
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|1
)paren
(brace
op_star
id|buf
op_increment
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|len
op_increment
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|buf
comma
id|entry-&gt;d_name.name
comma
id|entry-&gt;d_name.len
)paren
suffix:semicolon
r_return
id|len
op_plus
id|entry-&gt;d_name.len
suffix:semicolon
)brace
)brace
DECL|function|d_basket
r_struct
id|dentry
op_star
id|d_basket
c_func
(paren
r_struct
id|dentry
op_star
id|dir_entry
)paren
(brace
r_if
c_cond
(paren
id|dir_entry
op_logical_and
(paren
id|dir_entry-&gt;d_flag
op_amp
id|D_DIR
)paren
)paren
(brace
r_struct
id|ddir
op_star
id|ddir
op_assign
id|d_dir
c_func
(paren
id|dir_entry
)paren
suffix:semicolon
r_return
id|ddir-&gt;dd_basketlist
suffix:semicolon
)brace
r_else
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|d_isbasket
r_int
id|d_isbasket
c_func
(paren
r_struct
id|dentry
op_star
id|entry
)paren
(brace
r_return
id|entry-&gt;d_flag
op_amp
id|D_BASKET
suffix:semicolon
)brace
DECL|function|d_inode
id|blocking
r_struct
id|inode
op_star
id|d_inode
c_func
(paren
r_struct
id|dentry
op_star
op_star
id|changing_entry
)paren
(brace
r_struct
id|dentry
op_star
id|entry
op_assign
op_star
id|changing_entry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
macro_line|#ifdef CONFIG_DCACHE_PRELOAD
r_if
c_cond
(paren
id|entry-&gt;d_flag
op_amp
id|D_PRELIMINARY
)paren
(brace
r_struct
id|qstr
id|name
op_assign
(brace
id|entry-&gt;d_name.name
comma
id|entry-&gt;d_name.len
)brace
suffix:semicolon
r_struct
id|ddir
op_star
id|pdir
op_assign
id|d_dir
c_func
(paren
id|entry-&gt;d_parent
)paren
suffix:semicolon
r_struct
id|dentry
op_star
op_star
id|base
op_assign
id|d_base_qstr
c_func
(paren
id|pdir
comma
op_amp
id|name
comma
l_int|NULL
)paren
suffix:semicolon
r_struct
id|dentry
op_star
id|found
suffix:semicolon
r_int
r_int
id|ino
suffix:semicolon
r_struct
id|inode
op_star
id|dir
op_assign
id|entry-&gt;d_parent-&gt;u.d_inode
suffix:semicolon
id|TST
c_func
(paren
l_string|&quot;d_inode&quot;
comma
id|entry
)paren
suffix:semicolon
id|ino
op_assign
id|entry-&gt;u.d_ino
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
(brace
id|d_panic
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Prevent concurrent d_lookup()s or d_inode()s before&n;&t;&t; * giving up vfs_lock. This just removes from the parent,&n;&t;&t; * but does not deallocate it.&n;&t;&t; */
multiline_comment|/* !!!!!!! Aiee, here is an unresolved race if somebody&n;&t;&t; * unlink()s the inode during the iget(). The problem is&n;&t;&t; * that we need to synchronize externally. Proposed solution:&n;&t;&t; * put a rw_lock (read-mode) on the parent dir for each&n;&t;&t; * iget(), lookup() and so on, and a write-mode lock for&n;&t;&t; * everything that changes the dir (e.g. unlink()), and do&n;&t;&t; * this consistently everywhere in the generic VFS (not in&n;&t;&t; * the concrete filesystems). This should kill similar&n;&t;&t; * races everywhere, with a single clean concept.&n;&t;&t; * Later, the synchronization stuff can be cleaned out&n;&t;&t; * of the concrete fs&squot;es.&n;&t;&t; */
id|d_del
c_func
(paren
id|entry
comma
id|D_NO_CLEAR_INODE
op_or
id|D_NO_FREE
)paren
suffix:semicolon
id|vfs_unlock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* This circumvents the normal lookup() of pathnames.&n;&t;&t; * Therefore,  preliminary entries must not be used&n;&t;&t; * (see FS_NO_DCACHE and FS_NO_PRELIM) if the fs does not&n;&t;&t; * permit fetching *valid* inodes with plain iget().&n;&t;&t; */
id|inode
op_assign
id|__iget
c_func
(paren
id|dir-&gt;i_sb
comma
id|ino
comma
l_int|0
)paren
suffix:semicolon
id|vfs_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: preliminary dcache entry was invalid&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|changing_entry
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|xcheck
c_func
(paren
l_string|&quot;d_inode iget()&quot;
comma
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|found
op_assign
id|__dlookup
c_func
(paren
id|base
comma
op_amp
id|name
comma
l_int|NULL
)paren
)paren
)paren
(brace
id|d_del
c_func
(paren
id|entry
comma
id|D_NO_CLEAR_INODE
)paren
suffix:semicolon
op_star
id|changing_entry
op_assign
id|found
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
r_struct
id|dentry
op_star
r_new
op_assign
id|d_alloc
c_func
(paren
id|entry-&gt;d_parent
comma
id|entry-&gt;d_name.len
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
)paren
(brace
id|d_add
c_func
(paren
r_new
comma
id|inode
comma
op_amp
id|name
comma
id|D_DIR
)paren
suffix:semicolon
)brace
op_star
id|changing_entry
op_assign
r_new
suffix:semicolon
multiline_comment|/* Finally deallocate old entry. */
id|d_del
c_func
(paren
id|entry
comma
id|D_NO_CLEAR_INODE
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Re-insert to the parent, but now as normal dentry. */
id|d_add
c_func
(paren
id|entry
comma
id|inode
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|inode
suffix:semicolon
)brace
macro_line|#endif
id|inode
op_assign
id|entry-&gt;u.d_inode
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
macro_line|#ifdef DEBUG
id|xcheck
c_func
(paren
l_string|&quot;d_inode&quot;
comma
id|inode
)paren
suffix:semicolon
macro_line|#endif
id|iinc_zero
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_return
id|inode
suffix:semicolon
)brace
eof
