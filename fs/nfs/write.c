multiline_comment|/*&n; * linux/fs/nfs/write.c&n; *&n; * Writing file data over NFS.&n; *&n; * We do it like this: When a (user) process wishes to write data to an&n; * NFS file, a write request is allocated that contains the RPC task data&n; * plus some info on the page to be written, and added to the inode&squot;s&n; * write chain. If the process writes past the end of the page, an async&n; * RPC call to write the page is scheduled immediately; otherwise, the call&n; * is delayed for a few seconds.&n; *&n; * Just like readahead, no async I/O is performed if wsize &lt; PAGE_SIZE.&n; *&n; * Write requests are kept on the inode&squot;s writeback list. Each entry in&n; * that list references the page (portion) to be written. When the&n; * cache timeout has expired, the RPC task is woken up, and tries to&n; * lock the page. As soon as it manages to do so, the request is moved&n; * from the writeback list to the writelock list.&n; *&n; * Note: we must make sure never to confuse the inode passed in the&n; * write_page request with the one in page-&gt;inode. As far as I understand&n; * it, these are different when doing a swap-out.&n; *&n; * To understand everything that goes on here and in the NFS read code,&n; * one should be aware that a page is locked in exactly one of the following&n; * cases:&n; *&n; *  -&t;A write request is in progress.&n; *  -&t;A user process is in generic_file_write/nfs_update_page&n; *  -&t;A user process is in generic_file_read&n; *&n; * Also note that because of the way pages are invalidated in&n; * nfs_revalidate_inode, the following assertions hold:&n; *&n; *  -&t;If a page is dirty, there will be no read requests (a page will&n; *&t;not be re-read unless invalidated by nfs_revalidate_inode).&n; *  -&t;If the page is not uptodate, there will be no pending write&n; *&t;requests, and no process will be in nfs_update_page.&n; *&n; * FIXME: Interaction with the vmscan routines is not optimal yet.&n; * Either vmscan must be made nfs-savvy, or we need a different page&n; * reclaim concept that supports something like FS-independent&n; * buffer_heads with a b_ops-&gt; field.&n; *&n; * Copyright (C) 1996, 1997, Olaf Kirch &lt;okir@monad.swb.de&gt;&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/sunrpc/clnt.h&gt;
macro_line|#include &lt;linux/nfs_fs.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
DECL|macro|NFS_PARANOIA
mdefine_line|#define NFS_PARANOIA 1
DECL|macro|NFSDBG_FACILITY
mdefine_line|#define NFSDBG_FACILITY&t;&t;NFSDBG_PAGECACHE
r_static
r_void
id|nfs_wback_begin
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
suffix:semicolon
r_static
r_void
id|nfs_wback_result
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
suffix:semicolon
r_static
r_void
id|nfs_cancel_request
c_func
(paren
r_struct
id|nfs_wreq
op_star
id|req
)paren
suffix:semicolon
multiline_comment|/*&n; * Cache parameters&n; */
DECL|macro|NFS_WRITEBACK_DELAY
mdefine_line|#define NFS_WRITEBACK_DELAY&t;(10 * HZ)
DECL|macro|NFS_WRITEBACK_MAX
mdefine_line|#define NFS_WRITEBACK_MAX&t;64
multiline_comment|/*&n; * Limit number of delayed writes&n; */
DECL|variable|nr_write_requests
r_static
r_int
id|nr_write_requests
op_assign
l_int|0
suffix:semicolon
DECL|variable|write_queue
r_static
r_struct
id|rpc_wait_queue
id|write_queue
op_assign
id|RPC_INIT_WAITQ
c_func
(paren
l_string|&quot;write_chain&quot;
)paren
suffix:semicolon
multiline_comment|/* Hack for future NFS swap support */
macro_line|#ifndef IS_SWAPFILE
DECL|macro|IS_SWAPFILE
macro_line|# define IS_SWAPFILE(inode)&t;(0)
macro_line|#endif
multiline_comment|/*&n; * Write a page synchronously.&n; * Offset is the data offset within the page.&n; */
r_static
r_int
DECL|function|nfs_writepage_sync
id|nfs_writepage_sync
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|count
)paren
(brace
r_int
r_int
id|wsize
op_assign
id|NFS_SERVER
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|wsize
suffix:semicolon
r_int
id|result
comma
id|refresh
op_assign
l_int|0
comma
id|written
op_assign
l_int|0
suffix:semicolon
id|u8
op_star
id|buffer
suffix:semicolon
r_struct
id|nfs_fattr
id|fattr
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS:      nfs_writepage_sync(%s/%s %d@%ld)&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|count
comma
id|page-&gt;offset
op_plus
id|offset
)paren
suffix:semicolon
id|buffer
op_assign
(paren
id|u8
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|offset
suffix:semicolon
id|offset
op_add_assign
id|page-&gt;offset
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|count
OL
id|wsize
op_logical_and
op_logical_neg
id|IS_SWAPFILE
c_func
(paren
id|inode
)paren
)paren
id|wsize
op_assign
id|count
suffix:semicolon
id|result
op_assign
id|nfs_proc_write
c_func
(paren
id|NFS_DSERVER
c_func
(paren
id|dentry
)paren
comma
id|NFS_FH
c_func
(paren
id|dentry
)paren
comma
id|IS_SWAPFILE
c_func
(paren
id|inode
)paren
comma
id|offset
comma
id|wsize
comma
id|buffer
comma
op_amp
id|fattr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/* Must mark the page invalid after I/O error */
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|io_error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_ne
id|wsize
)paren
id|printk
c_func
(paren
l_string|&quot;NFS: short write, wsize=%u, result=%d&bslash;n&quot;
comma
id|wsize
comma
id|result
)paren
suffix:semicolon
id|refresh
op_assign
l_int|1
suffix:semicolon
id|buffer
op_add_assign
id|wsize
suffix:semicolon
id|offset
op_add_assign
id|wsize
suffix:semicolon
id|written
op_add_assign
id|wsize
suffix:semicolon
id|count
op_sub_assign
id|wsize
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we&squot;ve extended the file, update the inode&n;&t;&t; * now so we don&squot;t invalidate the cache.&n;&t;&t; */
r_if
c_cond
(paren
id|offset
OG
id|inode-&gt;i_size
)paren
id|inode-&gt;i_size
op_assign
id|offset
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
)paren
suffix:semicolon
id|io_error
suffix:colon
multiline_comment|/* Note: we don&squot;t refresh if the call failed (fattr invalid) */
r_if
c_cond
(paren
id|refresh
op_logical_and
id|result
op_ge
l_int|0
)paren
(brace
multiline_comment|/* See comments in nfs_wback_result */
multiline_comment|/* N.B. I don&squot;t think this is right -- sync writes in order */
r_if
c_cond
(paren
id|fattr.size
OL
id|inode-&gt;i_size
)paren
id|fattr.size
op_assign
id|inode-&gt;i_size
suffix:semicolon
r_if
c_cond
(paren
id|fattr.mtime.seconds
OL
id|inode-&gt;i_mtime
)paren
id|printk
c_func
(paren
l_string|&quot;nfs_writepage_sync: prior time??&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Solaris 2.5 server seems to send garbled&n;&t;&t; * fattrs occasionally */
r_if
c_cond
(paren
id|inode-&gt;i_ino
op_eq
id|fattr.fileid
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We expect the mtime value to change, and&n;&t;&t;&t; * don&squot;t want to invalidate the caches.&n;&t;&t;&t; */
id|inode-&gt;i_mtime
op_assign
id|fattr.mtime.seconds
suffix:semicolon
id|nfs_refresh_inode
c_func
(paren
id|inode
comma
op_amp
id|fattr
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;nfs_writepage_sync: inode %ld, got %u?&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|fattr.fileid
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|written
ques
c_cond
id|written
suffix:colon
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Append a writeback request to a list&n; */
r_static
r_inline
r_void
DECL|function|append_write_request
id|append_write_request
c_func
(paren
r_struct
id|nfs_wreq
op_star
op_star
id|q
comma
r_struct
id|nfs_wreq
op_star
id|wreq
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFS:      append_write_request(%p, %p)&bslash;n&quot;
comma
id|q
comma
id|wreq
)paren
suffix:semicolon
id|rpc_append_list
c_func
(paren
id|q
comma
id|wreq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a writeback request from a list&n; */
r_static
r_inline
r_void
DECL|function|remove_write_request
id|remove_write_request
c_func
(paren
r_struct
id|nfs_wreq
op_star
op_star
id|q
comma
r_struct
id|nfs_wreq
op_star
id|wreq
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFS:      remove_write_request(%p, %p)&bslash;n&quot;
comma
id|q
comma
id|wreq
)paren
suffix:semicolon
id|rpc_remove_list
c_func
(paren
id|q
comma
id|wreq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find a non-busy write request for a given page to&n; * try to combine with.&n; */
r_static
r_inline
r_struct
id|nfs_wreq
op_star
DECL|function|find_write_request
id|find_write_request
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|pid_t
id|pid
op_assign
id|current-&gt;pid
suffix:semicolon
r_struct
id|nfs_wreq
op_star
id|head
comma
op_star
id|req
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS:      find_write_request(%x/%ld, %p)&bslash;n&quot;
comma
id|inode-&gt;i_dev
comma
id|inode-&gt;i_ino
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|req
op_assign
id|head
op_assign
id|NFS_WRITEBACK
c_func
(paren
id|inode
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * We can&squot;t combine with canceled requests or&n;&t;&t; * requests that have already been started..&n;&t;&t; */
r_if
c_cond
(paren
id|req-&gt;wb_flags
op_amp
(paren
id|NFS_WRITE_CANCELLED
op_or
id|NFS_WRITE_INPROGRESS
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;wb_page
op_eq
id|page
op_logical_and
id|req-&gt;wb_pid
op_eq
id|pid
)paren
r_return
id|req
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Ehh, don&squot;t keep too many tasks queued..&n;&t;&t; */
id|rpc_wake_up_task
c_func
(paren
op_amp
id|req-&gt;wb_task
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|req
op_assign
id|WB_NEXT
c_func
(paren
id|req
)paren
)paren
op_ne
id|head
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Find and release all failed requests for this inode.&n; */
r_int
DECL|function|nfs_check_failed_request
id|nfs_check_failed_request
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
multiline_comment|/* FIXME! */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to merge adjacent write requests. This works only for requests&n; * issued by the same user.&n; */
r_static
r_inline
r_int
DECL|function|update_write_request
id|update_write_request
c_func
(paren
r_struct
id|nfs_wreq
op_star
id|req
comma
r_int
r_int
id|first
comma
r_int
r_int
id|bytes
)paren
(brace
r_int
r_int
id|rqfirst
op_assign
id|req-&gt;wb_offset
comma
id|rqlast
op_assign
id|rqfirst
op_plus
id|req-&gt;wb_bytes
comma
id|last
op_assign
id|first
op_plus
id|bytes
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;nfs:      trying to update write request %p&bslash;n&quot;
comma
id|req
)paren
suffix:semicolon
multiline_comment|/* not contiguous? */
r_if
c_cond
(paren
id|rqlast
OL
id|first
op_logical_or
id|last
OL
id|rqfirst
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|first
OL
id|rqfirst
)paren
id|rqfirst
op_assign
id|first
suffix:semicolon
r_if
c_cond
(paren
id|rqlast
OL
id|last
)paren
id|rqlast
op_assign
id|last
suffix:semicolon
id|req-&gt;wb_offset
op_assign
id|rqfirst
suffix:semicolon
id|req-&gt;wb_bytes
op_assign
id|rqlast
op_minus
id|rqfirst
suffix:semicolon
id|req-&gt;wb_count
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|nfs_wreq_cachep
r_static
id|kmem_cache_t
op_star
id|nfs_wreq_cachep
suffix:semicolon
DECL|function|nfs_init_wreqcache
r_int
id|nfs_init_wreqcache
c_func
(paren
r_void
)paren
(brace
id|nfs_wreq_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;nfs_wreq&quot;
comma
r_sizeof
(paren
r_struct
id|nfs_wreq
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nfs_wreq_cachep
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|free_write_request
id|free_write_request
c_func
(paren
r_struct
id|nfs_wreq
op_star
id|req
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|req-&gt;wb_count
)paren
id|kmem_cache_free
c_func
(paren
id|nfs_wreq_cachep
comma
id|req
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create and initialize a writeback request&n; */
r_static
r_inline
r_struct
id|nfs_wreq
op_star
DECL|function|create_write_request
id|create_write_request
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|bytes
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_struct
id|rpc_clnt
op_star
id|clnt
op_assign
id|NFS_CLIENT
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|nfs_wreq
op_star
id|wreq
suffix:semicolon
r_struct
id|rpc_task
op_star
id|task
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS:      create_write_request(%s/%s, %ld+%d)&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|page-&gt;offset
op_plus
id|offset
comma
id|bytes
)paren
suffix:semicolon
multiline_comment|/* FIXME: Enforce hard limit on number of concurrent writes? */
id|wreq
op_assign
id|kmem_cache_alloc
c_func
(paren
id|nfs_wreq_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wreq
)paren
r_goto
id|out_fail
suffix:semicolon
id|memset
c_func
(paren
id|wreq
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|wreq
)paren
)paren
suffix:semicolon
id|task
op_assign
op_amp
id|wreq-&gt;wb_task
suffix:semicolon
id|rpc_init_task
c_func
(paren
id|task
comma
id|clnt
comma
id|nfs_wback_result
comma
id|RPC_TASK_NFSWRITE
)paren
suffix:semicolon
id|task-&gt;tk_calldata
op_assign
id|wreq
suffix:semicolon
id|task-&gt;tk_action
op_assign
id|nfs_wback_begin
suffix:semicolon
id|rpcauth_lookupcred
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/* Obtain user creds */
r_if
c_cond
(paren
id|task-&gt;tk_status
OL
l_int|0
)paren
r_goto
id|out_req
suffix:semicolon
multiline_comment|/* Put the task on inode&squot;s writeback request list. */
id|get_file
c_func
(paren
id|file
)paren
suffix:semicolon
id|wreq-&gt;wb_file
op_assign
id|file
suffix:semicolon
id|wreq-&gt;wb_pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|wreq-&gt;wb_page
op_assign
id|page
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|wreq-&gt;wb_wait
)paren
suffix:semicolon
id|wreq-&gt;wb_offset
op_assign
id|offset
suffix:semicolon
id|wreq-&gt;wb_bytes
op_assign
id|bytes
suffix:semicolon
id|wreq-&gt;wb_count
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* One for the IO, one for us */
id|append_write_request
c_func
(paren
op_amp
id|NFS_WRITEBACK
c_func
(paren
id|inode
)paren
comma
id|wreq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_write_requests
op_increment
OG
id|NFS_WRITEBACK_MAX
op_star
l_int|3
op_div
l_int|4
)paren
id|rpc_wake_up_next
c_func
(paren
op_amp
id|write_queue
)paren
suffix:semicolon
r_return
id|wreq
suffix:semicolon
id|out_req
suffix:colon
id|rpc_release_task
c_func
(paren
id|task
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|nfs_wreq_cachep
comma
id|wreq
)paren
suffix:semicolon
id|out_fail
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Schedule a writeback RPC call.&n; * If the server is congested, don&squot;t add to our backlog of queued&n; * requests but call it synchronously.&n; * The function returns whether we should wait for the thing or not.&n; *&n; * FIXME: Here we could walk the inode&squot;s lock list to see whether the&n; * page we&squot;re currently writing to has been write-locked by the caller.&n; * If it is, we could schedule an async write request with a long&n; * delay in order to avoid writing back the page until the lock is&n; * released.&n; */
r_static
r_inline
r_int
DECL|function|schedule_write_request
id|schedule_write_request
c_func
(paren
r_struct
id|nfs_wreq
op_star
id|req
comma
r_int
id|sync
)paren
(brace
r_struct
id|rpc_task
op_star
id|task
op_assign
op_amp
id|req-&gt;wb_task
suffix:semicolon
r_struct
id|file
op_star
id|file
op_assign
id|req-&gt;wb_file
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|NFS_CONGESTED
c_func
(paren
id|inode
)paren
op_logical_or
id|nr_write_requests
op_ge
id|NFS_WRITEBACK_MAX
)paren
id|sync
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sync
)paren
(brace
id|sigset_t
id|oldmask
suffix:semicolon
r_struct
id|rpc_clnt
op_star
id|clnt
op_assign
id|NFS_CLIENT
c_func
(paren
id|inode
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS: %4d schedule_write_request (sync)&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
multiline_comment|/* Page is already locked */
id|rpc_clnt_sigmask
c_func
(paren
id|clnt
comma
op_amp
id|oldmask
)paren
suffix:semicolon
id|rpc_execute
c_func
(paren
id|task
)paren
suffix:semicolon
id|rpc_clnt_sigunmask
c_func
(paren
id|clnt
comma
op_amp
id|oldmask
)paren
suffix:semicolon
)brace
r_else
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFS: %4d schedule_write_request (async)&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|task-&gt;tk_flags
op_or_assign
id|RPC_TASK_ASYNC
suffix:semicolon
id|task-&gt;tk_timeout
op_assign
id|NFS_WRITEBACK_DELAY
suffix:semicolon
id|rpc_sleep_on
c_func
(paren
op_amp
id|write_queue
comma
id|task
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_return
id|sync
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for request to complete.&n; */
r_static
r_int
DECL|function|wait_on_write_request
id|wait_on_write_request
c_func
(paren
r_struct
id|nfs_wreq
op_star
id|req
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|req-&gt;wb_file
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_struct
id|rpc_clnt
op_star
id|clnt
op_assign
id|NFS_CLIENT
c_func
(paren
id|inode
)paren
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|sigset_t
id|oldmask
suffix:semicolon
r_int
id|retval
suffix:semicolon
multiline_comment|/* Make sure it&squot;s started.. */
r_if
c_cond
(paren
op_logical_neg
id|WB_INPROGRESS
c_func
(paren
id|req
)paren
)paren
id|rpc_wake_up_task
c_func
(paren
op_amp
id|req-&gt;wb_task
)paren
suffix:semicolon
id|rpc_clnt_sigmask
c_func
(paren
id|clnt
comma
op_amp
id|oldmask
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|req-&gt;wb_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;wb_flags
op_amp
id|NFS_WRITE_COMPLETE
)paren
r_break
suffix:semicolon
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_if
c_cond
(paren
id|signalled
c_func
(paren
)paren
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|req-&gt;wb_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|rpc_clnt_sigunmask
c_func
(paren
id|clnt
comma
op_amp
id|oldmask
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Write a page to the server. This will be used for NFS swapping only&n; * (for now), and we currently do this synchronously only.&n; */
r_int
DECL|function|nfs_writepage
id|nfs_writepage
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
r_return
id|nfs_writepage_sync
c_func
(paren
id|dentry
comma
id|dentry-&gt;d_inode
comma
id|page
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update and possibly write a cached page of an NFS file.&n; *&n; * XXX: Keep an eye on generic_file_read to make sure it doesn&squot;t do bad&n; * things with a page scheduled for an RPC call (e.g. invalidate it).&n; */
r_int
DECL|function|nfs_updatepage
id|nfs_updatepage
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_struct
id|nfs_wreq
op_star
id|req
suffix:semicolon
r_int
id|synchronous
op_assign
id|file-&gt;f_flags
op_amp
id|O_SYNC
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS:      nfs_updatepage(%s/%s %d@%ld)&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|count
comma
id|page-&gt;offset
op_plus
id|offset
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Try to find a corresponding request on the writeback queue.&n;&t; * If there is one, we can be sure that this request is not&n;&t; * yet being processed, because we hold a lock on the page.&n;&t; *&n;&t; * If the request was created by us, update it. Otherwise,&n;&t; * transfer the page lock and flush out the dirty page now.&n;&t; * After returning, generic_file_write will wait on the&n;&t; * page and retry the update.&n;&t; */
id|req
op_assign
id|find_write_request
c_func
(paren
id|inode
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
op_logical_and
id|req-&gt;wb_file
op_eq
id|file
op_logical_and
id|update_write_request
c_func
(paren
id|req
comma
id|offset
comma
id|count
)paren
)paren
r_goto
id|updated
suffix:semicolon
multiline_comment|/*&n;&t; * If wsize is smaller than page size, update and write&n;&t; * page synchronously.&n;&t; */
r_if
c_cond
(paren
id|NFS_SERVER
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|wsize
OL
id|PAGE_SIZE
)paren
r_return
id|nfs_writepage_sync
c_func
(paren
id|dentry
comma
id|inode
comma
id|page
comma
id|offset
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* Create the write request. */
id|req
op_assign
id|create_write_request
c_func
(paren
id|file
comma
id|page
comma
id|offset
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
r_return
op_minus
id|ENOBUFS
suffix:semicolon
multiline_comment|/*&n;&t; * Ok, there&squot;s another user of this page with the new request..&n;&t; * The IO completion will then free the page and the dentry.&n;&t; */
id|get_page
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/* Schedule request */
id|synchronous
op_assign
id|schedule_write_request
c_func
(paren
id|req
comma
id|synchronous
)paren
suffix:semicolon
id|updated
suffix:colon
r_if
c_cond
(paren
id|req-&gt;wb_bytes
op_eq
id|PAGE_SIZE
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|retval
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|synchronous
)paren
(brace
r_int
id|status
op_assign
id|wait_on_write_request
c_func
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
id|nfs_cancel_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|retval
op_assign
id|status
suffix:semicolon
)brace
r_else
(brace
id|status
op_assign
id|req-&gt;wb_status
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
id|retval
op_assign
id|status
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
id|free_write_request
c_func
(paren
id|req
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Cancel a write request. We always mark it cancelled,&n; * but if it&squot;s already in progress there&squot;s no point in&n; * calling rpc_exit, and we don&squot;t want to overwrite the&n; * tk_status field.&n; */
r_static
r_void
DECL|function|nfs_cancel_request
id|nfs_cancel_request
c_func
(paren
r_struct
id|nfs_wreq
op_star
id|req
)paren
(brace
id|req-&gt;wb_flags
op_or_assign
id|NFS_WRITE_CANCELLED
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|WB_INPROGRESS
c_func
(paren
id|req
)paren
)paren
(brace
id|rpc_exit
c_func
(paren
op_amp
id|req-&gt;wb_task
comma
l_int|0
)paren
suffix:semicolon
id|rpc_wake_up_task
c_func
(paren
op_amp
id|req-&gt;wb_task
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Cancel all writeback requests, both pending and in progress.&n; */
r_static
r_void
DECL|function|nfs_cancel_dirty
id|nfs_cancel_dirty
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|pid_t
id|pid
)paren
(brace
r_struct
id|nfs_wreq
op_star
id|head
comma
op_star
id|req
suffix:semicolon
id|req
op_assign
id|head
op_assign
id|NFS_WRITEBACK
c_func
(paren
id|inode
)paren
suffix:semicolon
r_while
c_loop
(paren
id|req
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|pid
op_eq
l_int|0
op_logical_or
id|req-&gt;wb_pid
op_eq
id|pid
)paren
id|nfs_cancel_request
c_func
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|req
op_assign
id|WB_NEXT
c_func
(paren
id|req
)paren
)paren
op_eq
id|head
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * If we&squot;re waiting on somebody else&squot;s request&n; * we need to increment the counter during the&n; * wait so that the request doesn&squot;t disappear&n; * from under us during the wait..&n; */
r_static
r_int
id|FASTCALL
c_func
(paren
id|wait_on_other_req
c_func
(paren
r_struct
id|nfs_wreq
op_star
)paren
)paren
suffix:semicolon
DECL|function|wait_on_other_req
r_static
r_int
id|wait_on_other_req
c_func
(paren
r_struct
id|nfs_wreq
op_star
id|req
)paren
(brace
r_int
id|retval
suffix:semicolon
id|req-&gt;wb_count
op_increment
suffix:semicolon
id|retval
op_assign
id|wait_on_write_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|free_write_request
c_func
(paren
id|req
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * This writes back a set of requests according to the condition.&n; *&n; * If this ever gets much more convoluted, use a fn pointer for&n; * the condition..&n; */
DECL|macro|NFS_WB
mdefine_line|#define NFS_WB(inode, cond) { int retval = 0 ; &bslash;&n;&t;do { &bslash;&n;&t;&t;struct nfs_wreq *req = NFS_WRITEBACK(inode); &bslash;&n;&t;&t;struct nfs_wreq *head = req; &bslash;&n;&t;&t;if (!req) break; &bslash;&n;&t;&t;for (;;) { &bslash;&n;&t;&t;&t;if (!(req-&gt;wb_flags &amp; NFS_WRITE_COMPLETE)) &bslash;&n;&t;&t;&t;&t;if (cond) break; &bslash;&n;&t;&t;&t;req = WB_NEXT(req); &bslash;&n;&t;&t;&t;if (req == head) goto out; &bslash;&n;&t;&t;} &bslash;&n;&t;&t;retval = wait_on_other_req(req); &bslash;&n;&t;} while (!retval); &bslash;&n;out:&t;return retval; &bslash;&n;}
r_int
DECL|function|nfs_wb_all
id|nfs_wb_all
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|NFS_WB
c_func
(paren
id|inode
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write back all requests on one page - we do this before reading it.&n; */
r_int
DECL|function|nfs_wb_page
id|nfs_wb_page
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
)paren
(brace
id|NFS_WB
c_func
(paren
id|inode
comma
id|req-&gt;wb_page
op_eq
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write back all pending writes from one file descriptor..&n; */
r_int
DECL|function|nfs_wb_file
id|nfs_wb_file
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|NFS_WB
c_func
(paren
id|inode
comma
id|req-&gt;wb_file
op_eq
id|file
)paren
suffix:semicolon
)brace
r_void
DECL|function|nfs_inval
id|nfs_inval
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|nfs_cancel_dirty
c_func
(paren
id|inode
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The following procedures make up the writeback finite state machinery:&n; *&n; * 1.&t;Try to lock the page if not yet locked by us,&n; *&t;set up the RPC call info, and pass to the call FSM.&n; */
r_static
r_void
DECL|function|nfs_wback_begin
id|nfs_wback_begin
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|nfs_wreq
op_star
id|req
op_assign
(paren
r_struct
id|nfs_wreq
op_star
)paren
id|task-&gt;tk_calldata
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|req-&gt;wb_page
suffix:semicolon
r_struct
id|file
op_star
id|file
op_assign
id|req-&gt;wb_file
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS: %4d nfs_wback_begin (%s/%s, status=%d flags=%x)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|task-&gt;tk_status
comma
id|req-&gt;wb_flags
)paren
suffix:semicolon
id|task-&gt;tk_status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Setup the task struct for a writeback call */
id|req-&gt;wb_flags
op_or_assign
id|NFS_WRITE_INPROGRESS
suffix:semicolon
id|req-&gt;wb_args.fh
op_assign
id|NFS_FH
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|req-&gt;wb_args.offset
op_assign
id|page-&gt;offset
op_plus
id|req-&gt;wb_offset
suffix:semicolon
id|req-&gt;wb_args.count
op_assign
id|req-&gt;wb_bytes
suffix:semicolon
id|req-&gt;wb_args.buffer
op_assign
(paren
r_void
op_star
)paren
(paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|req-&gt;wb_offset
)paren
suffix:semicolon
id|rpc_call_setup
c_func
(paren
id|task
comma
id|NFSPROC_WRITE
comma
op_amp
id|req-&gt;wb_args
comma
op_amp
id|req-&gt;wb_fattr
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * 2.&t;Collect the result&n; */
r_static
r_void
DECL|function|nfs_wback_result
id|nfs_wback_result
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|nfs_wreq
op_star
id|req
op_assign
(paren
r_struct
id|nfs_wreq
op_star
)paren
id|task-&gt;tk_calldata
suffix:semicolon
r_struct
id|file
op_star
id|file
op_assign
id|req-&gt;wb_file
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|req-&gt;wb_page
suffix:semicolon
r_int
id|status
op_assign
id|task-&gt;tk_status
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS: %4d nfs_wback_result (%s/%s, status=%d, flags=%x)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|status
comma
id|req-&gt;wb_flags
)paren
suffix:semicolon
multiline_comment|/* Set the WRITE_COMPLETE flag, but leave WRITE_INPROGRESS set */
id|req-&gt;wb_flags
op_or_assign
id|NFS_WRITE_COMPLETE
suffix:semicolon
id|req-&gt;wb_status
op_assign
id|status
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|req-&gt;wb_flags
op_or_assign
id|NFS_WRITE_INVALIDATE
suffix:semicolon
id|file-&gt;f_error
op_assign
id|status
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|WB_CANCELLED
c_func
(paren
id|req
)paren
)paren
(brace
r_struct
id|nfs_fattr
op_star
id|fattr
op_assign
op_amp
id|req-&gt;wb_fattr
suffix:semicolon
multiline_comment|/* Update attributes as result of writeback. &n;&t;&t; * Beware: when UDP replies arrive out of order, we&n;&t;&t; * may end up overwriting a previous, bigger file size.&n;&t;&t; *&n;&t;&t; * When the file size shrinks we cancel all pending&n;&t;&t; * writebacks. &n;&t;&t; */
r_if
c_cond
(paren
id|fattr-&gt;mtime.seconds
op_ge
id|inode-&gt;i_mtime
)paren
(brace
r_if
c_cond
(paren
id|fattr-&gt;size
OL
id|inode-&gt;i_size
)paren
id|fattr-&gt;size
op_assign
id|inode-&gt;i_size
suffix:semicolon
multiline_comment|/* possible Solaris 2.5 server bug workaround */
r_if
c_cond
(paren
id|inode-&gt;i_ino
op_eq
id|fattr-&gt;fileid
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We expect these values to change, and&n;&t;&t;&t;&t; * don&squot;t want to invalidate the caches.&n;&t;&t;&t;&t; */
id|inode-&gt;i_size
op_assign
id|fattr-&gt;size
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
id|fattr-&gt;mtime.seconds
suffix:semicolon
id|nfs_refresh_inode
c_func
(paren
id|inode
comma
id|fattr
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;nfs_wback_result: inode %ld, got %u?&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|fattr-&gt;fileid
)paren
suffix:semicolon
)brace
)brace
id|rpc_release_task
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|WB_INVALIDATE
c_func
(paren
id|req
)paren
)paren
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|remove_write_request
c_func
(paren
op_amp
id|NFS_WRITEBACK
c_func
(paren
id|inode
)paren
comma
id|req
)paren
suffix:semicolon
id|nr_write_requests
op_decrement
suffix:semicolon
id|fput
c_func
(paren
id|req-&gt;wb_file
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|req-&gt;wb_wait
)paren
suffix:semicolon
id|free_write_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
eof
