multiline_comment|/*&n; * linux/fs/nfs/write.c&n; *&n; * Writing file data over NFS.&n; *&n; * We do it like this: When a (user) process wishes to write data to an&n; * NFS file, a write request is allocated that contains the RPC task data&n; * plus some info on the page to be written, and added to the inode&squot;s&n; * write chain. If the process writes past the end of the page, an async&n; * RPC call to write the page is scheduled immediately; otherwise, the call&n; * is delayed for a few seconds.&n; *&n; * Just like readahead, no async I/O is performed if wsize &lt; PAGE_SIZE.&n; *&n; * Write requests are kept on the inode&squot;s writeback list. Each entry in&n; * that list references the page (portion) to be written. When the&n; * cache timeout has expired, the RPC task is woken up, and tries to&n; * lock the page. As soon as it manages to do so, the request is moved&n; * from the writeback list to the writelock list.&n; *&n; * Note: we must make sure never to confuse the inode passed in the&n; * write_page request with the one in page-&gt;inode. As far as I understand&n; * it, these are different when doing a swap-out.&n; *&n; * To understand everything that goes on here and in the NFS read code,&n; * one should be aware that a page is locked in exactly one of the following&n; * cases:&n; *&n; *  -&t;A write request is in progress.&n; *  -&t;A user process is in generic_file_write/nfs_update_page&n; *  -&t;A user process is in generic_file_read&n; *&n; * Also note that because of the way pages are invalidated in&n; * nfs_revalidate_inode, the following assertions hold:&n; *&n; *  -&t;If a page is dirty, there will be no read requests (a page will&n; *&t;not be re-read unless invalidated by nfs_revalidate_inode).&n; *  -&t;If the page is not uptodate, there will be no pending write&n; *&t;requests, and no process will be in nfs_update_page.&n; *&n; * FIXME: Interaction with the vmscan routines is not optimal yet.&n; * Either vmscan must be made nfs-savvy, or we need a different page&n; * reclaim concept that supports something like FS-independent&n; * buffer_heads with a b_ops-&gt; field.&n; *&n; * Copyright (C) 1996, 1997, Olaf Kirch &lt;okir@monad.swb.de&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/sunrpc/clnt.h&gt;
macro_line|#include &lt;linux/nfs_fs.h&gt;
macro_line|#include &lt;linux/nfs_mount.h&gt;
macro_line|#include &lt;linux/nfs_flushd.h&gt;
macro_line|#include &lt;linux/nfs_page.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
DECL|macro|NFS_PARANOIA
mdefine_line|#define NFS_PARANOIA 1
DECL|macro|NFSDBG_FACILITY
mdefine_line|#define NFSDBG_FACILITY&t;&t;NFSDBG_PAGECACHE
multiline_comment|/*&n; * Spinlock&n; */
DECL|variable|nfs_wreq_lock
id|spinlock_t
id|nfs_wreq_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|nfs_nr_requests
r_static
id|atomic_t
id|nfs_nr_requests
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n; * Local structures&n; *&n; * This is the struct where the WRITE/COMMIT arguments go.&n; */
DECL|struct|nfs_write_data
r_struct
id|nfs_write_data
(brace
DECL|member|task
r_struct
id|rpc_task
id|task
suffix:semicolon
DECL|member|inode
r_struct
id|inode
op_star
id|inode
suffix:semicolon
DECL|member|cred
r_struct
id|rpc_cred
op_star
id|cred
suffix:semicolon
DECL|member|args
r_struct
id|nfs_writeargs
id|args
suffix:semicolon
multiline_comment|/* argument struct */
DECL|member|res
r_struct
id|nfs_writeres
id|res
suffix:semicolon
multiline_comment|/* result struct */
DECL|member|fattr
r_struct
id|nfs_fattr
id|fattr
suffix:semicolon
DECL|member|verf
r_struct
id|nfs_writeverf
id|verf
suffix:semicolon
DECL|member|pages
r_struct
id|list_head
id|pages
suffix:semicolon
multiline_comment|/* Coalesced requests we wish to flush */
)brace
suffix:semicolon
multiline_comment|/*&n; * Local function declarations&n; */
r_static
r_struct
id|nfs_page
op_star
id|nfs_update_request
c_func
(paren
r_struct
id|file
op_star
comma
r_struct
id|inode
op_star
comma
r_struct
id|page
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|nfs_strategy
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
suffix:semicolon
r_static
r_void
id|nfs_writeback_done
c_func
(paren
r_struct
id|rpc_task
op_star
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NFS_V3
r_static
r_void
id|nfs_commit_done
c_func
(paren
r_struct
id|rpc_task
op_star
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Hack for future NFS swap support */
macro_line|#ifndef IS_SWAPFILE
DECL|macro|IS_SWAPFILE
macro_line|# define IS_SWAPFILE(inode)&t;(0)
macro_line|#endif
DECL|variable|nfs_page_cachep
r_static
id|kmem_cache_t
op_star
id|nfs_page_cachep
suffix:semicolon
DECL|variable|nfs_wdata_cachep
r_static
id|kmem_cache_t
op_star
id|nfs_wdata_cachep
suffix:semicolon
DECL|function|nfs_page_alloc
r_static
id|__inline__
r_struct
id|nfs_page
op_star
id|nfs_page_alloc
c_func
(paren
r_void
)paren
(brace
r_struct
id|nfs_page
op_star
id|p
suffix:semicolon
id|p
op_assign
id|kmem_cache_alloc
c_func
(paren
id|nfs_page_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|p
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|p-&gt;wb_hash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|p-&gt;wb_list
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|p-&gt;wb_wait
)paren
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
)brace
DECL|function|nfs_page_free
r_static
id|__inline__
r_void
id|nfs_page_free
c_func
(paren
r_struct
id|nfs_page
op_star
id|p
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|nfs_page_cachep
comma
id|p
)paren
suffix:semicolon
)brace
DECL|function|nfs_writedata_alloc
r_static
id|__inline__
r_struct
id|nfs_write_data
op_star
id|nfs_writedata_alloc
c_func
(paren
r_void
)paren
(brace
r_struct
id|nfs_write_data
op_star
id|p
suffix:semicolon
id|p
op_assign
id|kmem_cache_alloc
c_func
(paren
id|nfs_wdata_cachep
comma
id|SLAB_NFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|p
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|p-&gt;pages
)paren
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
)brace
DECL|function|nfs_writedata_free
r_static
id|__inline__
r_void
id|nfs_writedata_free
c_func
(paren
r_struct
id|nfs_write_data
op_star
id|p
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|nfs_wdata_cachep
comma
id|p
)paren
suffix:semicolon
)brace
DECL|function|nfs_writedata_release
r_static
r_void
id|nfs_writedata_release
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|nfs_write_data
op_star
id|wdata
op_assign
(paren
r_struct
id|nfs_write_data
op_star
)paren
id|task-&gt;tk_calldata
suffix:semicolon
id|nfs_writedata_free
c_func
(paren
id|wdata
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function will be used to simulate weak cache consistency&n; * under NFSv2 when the NFSv3 attribute patch is included.&n; * For the moment, we just call nfs_refresh_inode().&n; */
r_static
id|__inline__
r_int
DECL|function|nfs_write_attributes
id|nfs_write_attributes
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|nfs_fattr
op_star
id|fattr
)paren
(brace
r_if
c_cond
(paren
(paren
id|fattr-&gt;valid
op_amp
id|NFS_ATTR_FATTR
)paren
op_logical_and
op_logical_neg
(paren
id|fattr-&gt;valid
op_amp
id|NFS_ATTR_WCC
)paren
)paren
(brace
id|fattr-&gt;pre_size
op_assign
id|NFS_CACHE_ISIZE
c_func
(paren
id|inode
)paren
suffix:semicolon
id|fattr-&gt;pre_mtime
op_assign
id|NFS_CACHE_MTIME
c_func
(paren
id|inode
)paren
suffix:semicolon
id|fattr-&gt;pre_ctime
op_assign
id|NFS_CACHE_CTIME
c_func
(paren
id|inode
)paren
suffix:semicolon
id|fattr-&gt;valid
op_or_assign
id|NFS_ATTR_WCC
suffix:semicolon
)brace
r_return
id|nfs_refresh_inode
c_func
(paren
id|inode
comma
id|fattr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write a page synchronously.&n; * Offset is the data offset within the page.&n; */
r_static
r_int
DECL|function|nfs_writepage_sync
id|nfs_writepage_sync
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|rpc_cred
op_star
id|cred
op_assign
l_int|NULL
suffix:semicolon
id|loff_t
id|base
suffix:semicolon
r_int
r_int
id|wsize
op_assign
id|NFS_SERVER
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|wsize
suffix:semicolon
r_int
id|result
comma
id|refresh
op_assign
l_int|0
comma
id|written
op_assign
l_int|0
comma
id|flags
suffix:semicolon
id|u8
op_star
id|buffer
suffix:semicolon
r_struct
id|nfs_fattr
id|fattr
suffix:semicolon
r_struct
id|nfs_writeverf
id|verf
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
id|cred
op_assign
id|nfs_file_cred
c_func
(paren
id|file
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS:      nfs_writepage_sync(%x/%Ld %d@%Ld)&bslash;n&quot;
comma
id|inode-&gt;i_dev
comma
(paren
r_int
r_int
)paren
id|NFS_FILEID
c_func
(paren
id|inode
)paren
comma
id|count
comma
(paren
r_int
r_int
)paren
(paren
id|page_offset
c_func
(paren
id|page
)paren
op_plus
id|offset
)paren
)paren
suffix:semicolon
id|buffer
op_assign
id|kmap
c_func
(paren
id|page
)paren
op_plus
id|offset
suffix:semicolon
id|base
op_assign
id|page_offset
c_func
(paren
id|page
)paren
op_plus
id|offset
suffix:semicolon
id|flags
op_assign
(paren
(paren
id|IS_SWAPFILE
c_func
(paren
id|inode
)paren
)paren
ques
c_cond
id|NFS_RW_SWAP
suffix:colon
l_int|0
)paren
op_or
id|NFS_RW_SYNC
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|count
OL
id|wsize
op_logical_and
op_logical_neg
id|IS_SWAPFILE
c_func
(paren
id|inode
)paren
)paren
id|wsize
op_assign
id|count
suffix:semicolon
id|result
op_assign
id|NFS_PROTO
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|write
c_func
(paren
id|inode
comma
id|cred
comma
op_amp
id|fattr
comma
id|flags
comma
id|base
comma
id|wsize
comma
id|buffer
comma
op_amp
id|verf
)paren
suffix:semicolon
id|nfs_write_attributes
c_func
(paren
id|inode
comma
op_amp
id|fattr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/* Must mark the page invalid after I/O error */
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|io_error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_ne
id|wsize
)paren
id|printk
c_func
(paren
l_string|&quot;NFS: short write, wsize=%u, result=%d&bslash;n&quot;
comma
id|wsize
comma
id|result
)paren
suffix:semicolon
id|refresh
op_assign
l_int|1
suffix:semicolon
id|buffer
op_add_assign
id|wsize
suffix:semicolon
id|base
op_add_assign
id|wsize
suffix:semicolon
id|written
op_add_assign
id|wsize
suffix:semicolon
id|count
op_sub_assign
id|wsize
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we&squot;ve extended the file, update the inode&n;&t;&t; * now so we don&squot;t invalidate the cache.&n;&t;&t; */
r_if
c_cond
(paren
id|base
OG
id|inode-&gt;i_size
)paren
id|inode-&gt;i_size
op_assign
id|base
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageError
c_func
(paren
id|page
)paren
)paren
id|ClearPageError
c_func
(paren
id|page
)paren
suffix:semicolon
id|io_error
suffix:colon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|written
ques
c_cond
id|written
suffix:colon
id|result
suffix:semicolon
)brace
r_static
r_int
DECL|function|nfs_writepage_async
id|nfs_writepage_async
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
r_int
id|status
suffix:semicolon
id|req
op_assign
id|nfs_update_request
c_func
(paren
id|file
comma
id|inode
comma
id|page
comma
id|offset
comma
id|count
)paren
suffix:semicolon
id|status
op_assign
(paren
id|IS_ERR
c_func
(paren
id|req
)paren
)paren
ques
c_cond
id|PTR_ERR
c_func
(paren
id|req
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|nfs_release_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_strategy
c_func
(paren
id|inode
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * Write an mmapped page to the server.&n; */
r_int
DECL|function|nfs_writepage
id|nfs_writepage
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
r_int
id|end_index
suffix:semicolon
r_int
id|offset
op_assign
id|PAGE_CACHE_SIZE
suffix:semicolon
r_int
id|err
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mapping
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|end_index
op_assign
id|inode-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
multiline_comment|/* Ensure we&squot;ve flushed out any previous writes */
id|nfs_wb_page
c_func
(paren
id|inode
comma
id|page
)paren
suffix:semicolon
multiline_comment|/* easy case */
r_if
c_cond
(paren
id|page-&gt;index
OL
id|end_index
)paren
r_goto
id|do_it
suffix:semicolon
multiline_comment|/* things got complicated... */
id|offset
op_assign
id|inode-&gt;i_size
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* OK, are we completely out? */
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;index
op_ge
id|end_index
op_plus
l_int|1
op_logical_or
op_logical_neg
id|offset
)paren
r_goto
id|out
suffix:semicolon
id|do_it
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
op_logical_and
id|NFS_SERVER
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|rsize
op_ge
id|PAGE_CACHE_SIZE
)paren
(brace
id|err
op_assign
id|nfs_writepage_async
c_func
(paren
l_int|NULL
comma
id|inode
comma
id|page
comma
l_int|0
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ge
l_int|0
)paren
r_goto
id|out_ok
suffix:semicolon
)brace
id|err
op_assign
id|nfs_writepage_sync
c_func
(paren
l_int|NULL
comma
id|inode
comma
id|page
comma
l_int|0
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
id|offset
)paren
(brace
id|out_ok
suffix:colon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
id|out
suffix:colon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Check whether the file range we want to write to is locked by&n; * us.&n; */
r_static
r_int
DECL|function|region_locked
id|region_locked
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|nfs_page
op_star
id|req
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
id|loff_t
id|rqstart
comma
id|rqend
suffix:semicolon
multiline_comment|/* Don&squot;t optimize writes if we don&squot;t use NLM */
r_if
c_cond
(paren
id|NFS_SERVER
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|flags
op_amp
id|NFS_MOUNT_NONLM
)paren
r_return
l_int|0
suffix:semicolon
id|rqstart
op_assign
id|page_offset
c_func
(paren
id|req-&gt;wb_page
)paren
op_plus
id|req-&gt;wb_offset
suffix:semicolon
id|rqend
op_assign
id|rqstart
op_plus
id|req-&gt;wb_bytes
suffix:semicolon
r_for
c_loop
(paren
id|fl
op_assign
id|inode-&gt;i_flock
suffix:semicolon
id|fl
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_owner
op_eq
id|current-&gt;files
op_logical_and
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_POSIX
)paren
op_logical_and
id|fl-&gt;fl_type
op_eq
id|F_WRLCK
op_logical_and
id|fl-&gt;fl_start
op_le
id|rqstart
op_logical_and
id|rqend
op_le
id|fl-&gt;fl_end
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert a write request into an inode&n; */
r_static
r_inline
r_void
DECL|function|nfs_inode_add_request
id|nfs_inode_add_request
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|nfs_page
op_star
id|req
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|req-&gt;wb_hash
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NFS_WBACK_BUSY
c_func
(paren
id|req
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: unlocked request attempted hashed!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|inode-&gt;u.nfs_i.writeback
)paren
)paren
id|atomic_inc
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
suffix:semicolon
id|inode-&gt;u.nfs_i.npages
op_increment
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|req-&gt;wb_hash
comma
op_amp
id|inode-&gt;u.nfs_i.writeback
)paren
suffix:semicolon
id|req-&gt;wb_count
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert a write request into an inode&n; */
r_static
r_inline
r_void
DECL|function|nfs_inode_remove_request
id|nfs_inode_remove_request
c_func
(paren
r_struct
id|nfs_page
op_star
id|req
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|req-&gt;wb_hash
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|NFS_WBACK_BUSY
c_func
(paren
id|req
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: unlocked request attempted unhashed!&bslash;n&quot;
)paren
suffix:semicolon
id|inode
op_assign
id|req-&gt;wb_inode
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|req-&gt;wb_hash
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|req-&gt;wb_hash
)paren
suffix:semicolon
id|inode-&gt;u.nfs_i.npages
op_decrement
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inode-&gt;u.nfs_i.npages
op_eq
l_int|0
)paren
op_ne
id|list_empty
c_func
(paren
op_amp
id|inode-&gt;u.nfs_i.writeback
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: desynchronized value of nfs_i.npages.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|inode-&gt;u.nfs_i.writeback
)paren
)paren
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nfs_have_writebacks
c_func
(paren
id|inode
)paren
op_logical_and
op_logical_neg
id|nfs_have_read
c_func
(paren
id|inode
)paren
)paren
id|inode_remove_flushd
c_func
(paren
id|inode
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|nfs_release_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find a request&n; */
r_static
r_inline
r_struct
id|nfs_page
op_star
DECL|function|_nfs_find_request
id|_nfs_find_request
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|list_head
op_star
id|head
comma
op_star
id|next
suffix:semicolon
id|head
op_assign
op_amp
id|inode-&gt;u.nfs_i.writeback
suffix:semicolon
id|next
op_assign
id|head-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|next
op_ne
id|head
)paren
(brace
r_struct
id|nfs_page
op_star
id|req
op_assign
id|nfs_inode_wb_entry
c_func
(paren
id|next
)paren
suffix:semicolon
id|next
op_assign
id|next-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|page_index
c_func
(paren
id|req-&gt;wb_page
)paren
op_ne
id|page_index
c_func
(paren
id|page
)paren
)paren
r_continue
suffix:semicolon
id|req-&gt;wb_count
op_increment
suffix:semicolon
r_return
id|req
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_struct
id|nfs_page
op_star
DECL|function|nfs_find_request
id|nfs_find_request
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|req
op_assign
id|_nfs_find_request
c_func
(paren
id|inode
comma
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_return
id|req
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert a write request into a sorted list&n; */
DECL|function|nfs_list_add_request
r_void
id|nfs_list_add_request
c_func
(paren
r_struct
id|nfs_page
op_star
id|req
comma
r_struct
id|list_head
op_star
id|head
)paren
(brace
r_struct
id|list_head
op_star
id|prev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|req-&gt;wb_list
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: Add to list failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|NFS_WBACK_BUSY
c_func
(paren
id|req
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: unlocked request attempted added to list!&bslash;n&quot;
)paren
suffix:semicolon
id|prev
op_assign
id|head-&gt;prev
suffix:semicolon
r_while
c_loop
(paren
id|prev
op_ne
id|head
)paren
(brace
r_struct
id|nfs_page
op_star
id|p
op_assign
id|nfs_list_entry
c_func
(paren
id|prev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page_index
c_func
(paren
id|p-&gt;wb_page
)paren
OL
id|page_index
c_func
(paren
id|req-&gt;wb_page
)paren
)paren
r_break
suffix:semicolon
id|prev
op_assign
id|prev-&gt;prev
suffix:semicolon
)brace
id|list_add
c_func
(paren
op_amp
id|req-&gt;wb_list
comma
id|prev
)paren
suffix:semicolon
id|req-&gt;wb_list_head
op_assign
id|head
suffix:semicolon
)brace
multiline_comment|/*&n; * Insert a write request into an inode&n; */
DECL|function|nfs_list_remove_request
r_void
id|nfs_list_remove_request
c_func
(paren
r_struct
id|nfs_page
op_star
id|req
)paren
(brace
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|req-&gt;wb_list
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NFS_WBACK_BUSY
c_func
(paren
id|req
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: unlocked request attempted removed from list!&bslash;n&quot;
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|req-&gt;wb_list
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|req-&gt;wb_list
)paren
suffix:semicolon
id|req-&gt;wb_list_head
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a request to the inode&squot;s dirty list.&n; */
r_static
r_inline
r_void
DECL|function|nfs_mark_request_dirty
id|nfs_mark_request_dirty
c_func
(paren
r_struct
id|nfs_page
op_star
id|req
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|req-&gt;wb_inode
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|req-&gt;wb_list
)paren
)paren
(brace
id|nfs_list_add_request
c_func
(paren
id|req
comma
op_amp
id|inode-&gt;u.nfs_i.dirty
)paren
suffix:semicolon
id|inode-&gt;u.nfs_i.ndirty
op_increment
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * NB: the call to inode_schedule_scan() must lie outside the&n;&t; *     spinlock since it can run flushd().&n;&t; */
id|inode_schedule_scan
c_func
(paren
id|inode
comma
id|req-&gt;wb_timeout
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check if a request is dirty&n; */
r_static
r_inline
r_int
DECL|function|nfs_dirty_request
id|nfs_dirty_request
c_func
(paren
r_struct
id|nfs_page
op_star
id|req
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|req-&gt;wb_inode
suffix:semicolon
r_return
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|req-&gt;wb_list
)paren
op_logical_and
id|req-&gt;wb_list_head
op_eq
op_amp
id|inode-&gt;u.nfs_i.dirty
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NFS_V3
multiline_comment|/*&n; * Add a request to the inode&squot;s commit list.&n; */
r_static
r_inline
r_void
DECL|function|nfs_mark_request_commit
id|nfs_mark_request_commit
c_func
(paren
r_struct
id|nfs_page
op_star
id|req
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|req-&gt;wb_inode
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|req-&gt;wb_list
)paren
)paren
(brace
id|nfs_list_add_request
c_func
(paren
id|req
comma
op_amp
id|inode-&gt;u.nfs_i.commit
)paren
suffix:semicolon
id|inode-&gt;u.nfs_i.ncommit
op_increment
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * NB: the call to inode_schedule_scan() must lie outside the&n;&t; *     spinlock since it can run flushd().&n;&t; */
id|inode_schedule_scan
c_func
(paren
id|inode
comma
id|req-&gt;wb_timeout
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Create a write request.&n; * Page must be locked by the caller. This makes sure we never create&n; * two different requests for the same page, and avoids possible deadlock&n; * when we reach the hard limit on the number of dirty pages.&n; * It should be safe to sleep here.&n; */
DECL|function|nfs_create_request
r_struct
id|nfs_page
op_star
id|nfs_create_request
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|nfs_reqlist
op_star
id|cache
op_assign
id|NFS_REQUESTLIST
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|nfs_page
op_star
id|req
op_assign
l_int|NULL
suffix:semicolon
r_int
id|timeout
suffix:semicolon
multiline_comment|/* Deal with hard/soft limits.&n;&t; */
r_do
(brace
multiline_comment|/* If we&squot;re over the global soft limit, wake up all requests */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|nfs_nr_requests
)paren
op_ge
id|MAX_REQUEST_SOFT
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFS:      hit soft limit (%d requests)&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|nfs_nr_requests
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cache-&gt;task
)paren
id|nfs_reqlist_init
c_func
(paren
id|NFS_SERVER
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
id|nfs_wake_flushd
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* If we haven&squot;t reached the local hard limit yet,&n;&t;&t; * try to allocate the request struct */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|cache-&gt;nr_requests
)paren
OL
id|MAX_REQUEST_HARD
)paren
(brace
id|req
op_assign
id|nfs_page_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
op_ne
l_int|NULL
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* We&squot;re over the hard limit. Wait for better times */
id|dprintk
c_func
(paren
l_string|&quot;NFS:      create_request sleeping (total %d pid %d)&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|cache-&gt;nr_requests
)paren
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|timeout
op_assign
l_int|1
op_star
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|NFS_SERVER
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|flags
op_amp
id|NFS_MOUNT_INTR
)paren
(brace
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|cache-&gt;request_wait
comma
id|timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signalled
c_func
(paren
)paren
)paren
r_break
suffix:semicolon
)brace
r_else
id|sleep_on_timeout
c_func
(paren
op_amp
id|cache-&gt;request_wait
comma
id|timeout
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS:      create_request waking up (tot %d pid %d)&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|cache-&gt;nr_requests
)paren
comma
id|current-&gt;pid
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Initialize the request struct. Initially, we assume a&n;&t; * long write-back delay. This will be adjusted in&n;&t; * update_nfs_request below if the region is not locked. */
id|req-&gt;wb_page
op_assign
id|page
suffix:semicolon
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
id|req-&gt;wb_offset
op_assign
id|offset
suffix:semicolon
id|req-&gt;wb_bytes
op_assign
id|count
suffix:semicolon
id|req-&gt;wb_file
op_assign
id|file
suffix:semicolon
multiline_comment|/* If we have a struct file, use its cached credentials&n;&t; * else cache the current process&squot; credentials. */
r_if
c_cond
(paren
id|file
)paren
(brace
id|get_file
c_func
(paren
id|file
)paren
suffix:semicolon
id|req-&gt;wb_cred
op_assign
id|nfs_file_cred
c_func
(paren
id|file
)paren
suffix:semicolon
)brace
r_else
id|req-&gt;wb_cred
op_assign
id|rpcauth_lookupcred
c_func
(paren
id|NFS_CLIENT
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|cl_auth
comma
l_int|0
)paren
suffix:semicolon
id|req-&gt;wb_inode
op_assign
id|inode
suffix:semicolon
id|req-&gt;wb_count
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* register request&squot;s existence */
id|atomic_inc
c_func
(paren
op_amp
id|cache-&gt;nr_requests
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|nfs_nr_requests
)paren
suffix:semicolon
r_return
id|req
suffix:semicolon
)brace
multiline_comment|/*&n; * Release all resources associated with a write request after it&n; * has been committed to stable storage&n; *&n; * Note: Should always be called with the spinlock held!&n; */
r_void
DECL|function|nfs_release_request
id|nfs_release_request
c_func
(paren
r_struct
id|nfs_page
op_star
id|req
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|req-&gt;wb_inode
suffix:semicolon
r_struct
id|nfs_reqlist
op_star
id|cache
op_assign
id|NFS_REQUESTLIST
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|req-&gt;wb_page
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|req-&gt;wb_count
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|req-&gt;wb_list
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: Request released while still on a list!&bslash;n&quot;
)paren
suffix:semicolon
id|nfs_list_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|req-&gt;wb_hash
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: Request released while still hashed!&bslash;n&quot;
)paren
suffix:semicolon
id|nfs_inode_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|NFS_WBACK_BUSY
c_func
(paren
id|req
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: Request released while still locked!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Release struct file or cached credential */
r_if
c_cond
(paren
id|req-&gt;wb_file
)paren
id|fput
c_func
(paren
id|req-&gt;wb_file
)paren
suffix:semicolon
r_else
id|rpcauth_releasecred
c_func
(paren
id|NFS_CLIENT
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|cl_auth
comma
id|req-&gt;wb_cred
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|nfs_page_free
c_func
(paren
id|req
)paren
suffix:semicolon
multiline_comment|/* wake up anyone waiting to allocate a request */
id|atomic_dec
c_func
(paren
op_amp
id|cache-&gt;nr_requests
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|nfs_nr_requests
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|cache-&gt;request_wait
)paren
suffix:semicolon
macro_line|#ifdef NFS_PARANOIA
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|cache-&gt;nr_requests
)paren
OL
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|nfs_nr_requests
)paren
OL
l_int|0
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Wait for a request to complete.&n; *&n; * Interruptible by signals only if mounted with intr flag.&n; */
r_static
r_int
DECL|function|nfs_wait_on_request
id|nfs_wait_on_request
c_func
(paren
r_struct
id|nfs_page
op_star
id|req
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|req-&gt;wb_inode
suffix:semicolon
r_struct
id|rpc_clnt
op_star
id|clnt
op_assign
id|NFS_CLIENT
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NFS_WBACK_BUSY
c_func
(paren
id|req
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|nfs_wait_event
c_func
(paren
id|clnt
comma
id|req-&gt;wb_wait
comma
op_logical_neg
id|NFS_WBACK_BUSY
c_func
(paren
id|req
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for a request to complete.&n; *&n; * Interruptible by signals only if mounted with intr flag.&n; */
r_static
r_int
DECL|function|nfs_wait_on_requests
id|nfs_wait_on_requests
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|idx_start
comma
r_int
r_int
id|npages
)paren
(brace
r_struct
id|list_head
op_star
id|p
comma
op_star
id|head
suffix:semicolon
r_int
r_int
id|idx_end
suffix:semicolon
r_int
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|npages
op_eq
l_int|0
)paren
id|idx_end
op_assign
op_complement
l_int|0
suffix:semicolon
r_else
id|idx_end
op_assign
id|idx_start
op_plus
id|npages
op_minus
l_int|1
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|head
op_assign
op_amp
id|inode-&gt;u.nfs_i.writeback
suffix:semicolon
id|p
op_assign
id|head-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|p
op_ne
id|head
)paren
(brace
r_int
r_int
id|pg_idx
suffix:semicolon
r_struct
id|nfs_page
op_star
id|req
op_assign
id|nfs_inode_wb_entry
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|file
op_logical_and
id|req-&gt;wb_file
op_ne
id|file
)paren
r_continue
suffix:semicolon
id|pg_idx
op_assign
id|page_index
c_func
(paren
id|req-&gt;wb_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pg_idx
template_param
id|idx_end
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NFS_WBACK_BUSY
c_func
(paren
id|req
)paren
)paren
r_continue
suffix:semicolon
id|req-&gt;wb_count
op_increment
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|error
op_assign
id|nfs_wait_on_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_release_request
c_func
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_return
id|error
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|p
op_assign
id|head-&gt;next
suffix:semicolon
id|res
op_increment
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/*&n; * Scan cluster for dirty pages and send as many of them to the&n; * server as possible.&n; */
DECL|function|nfs_scan_list_timeout
r_int
id|nfs_scan_list_timeout
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_struct
id|list_head
op_star
id|dst
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
r_int
id|pages
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|head-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|p
op_ne
id|head
)paren
(brace
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|req-&gt;wb_timeout
comma
id|jiffies
)paren
)paren
(brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|NFS_NEXTSCAN
c_func
(paren
id|inode
)paren
comma
id|req-&gt;wb_timeout
)paren
)paren
id|NFS_NEXTSCAN
c_func
(paren
id|inode
)paren
op_assign
id|req-&gt;wb_timeout
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|nfs_lock_request
c_func
(paren
id|req
)paren
)paren
r_continue
suffix:semicolon
id|nfs_list_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_list_add_request
c_func
(paren
id|req
comma
id|dst
)paren
suffix:semicolon
id|pages
op_increment
suffix:semicolon
)brace
r_return
id|pages
suffix:semicolon
)brace
r_static
r_int
DECL|function|nfs_scan_dirty_timeout
id|nfs_scan_dirty_timeout
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|list_head
op_star
id|dst
)paren
(brace
r_int
id|pages
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|pages
op_assign
id|nfs_scan_list_timeout
c_func
(paren
op_amp
id|inode-&gt;u.nfs_i.dirty
comma
id|dst
comma
id|inode
)paren
suffix:semicolon
id|inode-&gt;u.nfs_i.ndirty
op_sub_assign
id|pages
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inode-&gt;u.nfs_i.ndirty
op_eq
l_int|0
)paren
op_ne
id|list_empty
c_func
(paren
op_amp
id|inode-&gt;u.nfs_i.dirty
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: desynchronized value of nfs_i.ndirty.&bslash;n&quot;
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_return
id|pages
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NFS_V3
r_static
r_int
DECL|function|nfs_scan_commit_timeout
id|nfs_scan_commit_timeout
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|list_head
op_star
id|dst
)paren
(brace
r_int
id|pages
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|pages
op_assign
id|nfs_scan_list_timeout
c_func
(paren
op_amp
id|inode-&gt;u.nfs_i.commit
comma
id|dst
comma
id|inode
)paren
suffix:semicolon
id|inode-&gt;u.nfs_i.ncommit
op_sub_assign
id|pages
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inode-&gt;u.nfs_i.ncommit
op_eq
l_int|0
)paren
op_ne
id|list_empty
c_func
(paren
op_amp
id|inode-&gt;u.nfs_i.commit
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: desynchronized value of nfs_i.ncommit.&bslash;n&quot;
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_return
id|pages
suffix:semicolon
)brace
macro_line|#endif
DECL|function|nfs_scan_list
r_int
id|nfs_scan_list
c_func
(paren
r_struct
id|list_head
op_star
id|src
comma
r_struct
id|list_head
op_star
id|dst
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|idx_start
comma
r_int
r_int
id|npages
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
r_int
r_int
id|idx_end
suffix:semicolon
r_int
id|res
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|npages
op_eq
l_int|0
)paren
id|idx_end
op_assign
op_complement
l_int|0
suffix:semicolon
r_else
id|idx_end
op_assign
id|idx_start
op_plus
id|npages
op_minus
l_int|1
suffix:semicolon
id|p
op_assign
id|src-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|p
op_ne
id|src
)paren
(brace
r_int
r_int
id|pg_idx
suffix:semicolon
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|file
op_logical_and
id|req-&gt;wb_file
op_ne
id|file
)paren
r_continue
suffix:semicolon
id|pg_idx
op_assign
id|page_index
c_func
(paren
id|req-&gt;wb_page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pg_idx
template_param
id|idx_end
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nfs_lock_request
c_func
(paren
id|req
)paren
)paren
r_continue
suffix:semicolon
id|nfs_list_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_list_add_request
c_func
(paren
id|req
comma
id|dst
)paren
suffix:semicolon
id|res
op_increment
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
r_static
r_int
DECL|function|nfs_scan_dirty
id|nfs_scan_dirty
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|list_head
op_star
id|dst
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|idx_start
comma
r_int
r_int
id|npages
)paren
(brace
r_int
id|res
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|res
op_assign
id|nfs_scan_list
c_func
(paren
op_amp
id|inode-&gt;u.nfs_i.dirty
comma
id|dst
comma
id|file
comma
id|idx_start
comma
id|npages
)paren
suffix:semicolon
id|inode-&gt;u.nfs_i.ndirty
op_sub_assign
id|res
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inode-&gt;u.nfs_i.ndirty
op_eq
l_int|0
)paren
op_ne
id|list_empty
c_func
(paren
op_amp
id|inode-&gt;u.nfs_i.dirty
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: desynchronized value of nfs_i.ndirty.&bslash;n&quot;
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NFS_V3
r_static
r_int
DECL|function|nfs_scan_commit
id|nfs_scan_commit
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|list_head
op_star
id|dst
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|idx_start
comma
r_int
r_int
id|npages
)paren
(brace
r_int
id|res
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|res
op_assign
id|nfs_scan_list
c_func
(paren
op_amp
id|inode-&gt;u.nfs_i.commit
comma
id|dst
comma
id|file
comma
id|idx_start
comma
id|npages
)paren
suffix:semicolon
id|inode-&gt;u.nfs_i.ncommit
op_sub_assign
id|res
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inode-&gt;u.nfs_i.ncommit
op_eq
l_int|0
)paren
op_ne
id|list_empty
c_func
(paren
op_amp
id|inode-&gt;u.nfs_i.commit
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: desynchronized value of nfs_i.ncommit.&bslash;n&quot;
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
macro_line|#endif
DECL|function|nfs_coalesce_requests
r_int
id|nfs_coalesce_requests
c_func
(paren
r_struct
id|list_head
op_star
id|src
comma
r_struct
id|list_head
op_star
id|dst
comma
r_int
r_int
id|maxpages
)paren
(brace
r_struct
id|nfs_page
op_star
id|req
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|pages
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|src
)paren
)paren
(brace
r_struct
id|nfs_page
op_star
id|prev
op_assign
id|req
suffix:semicolon
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|src-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;wb_file
op_ne
id|prev-&gt;wb_file
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|page_index
c_func
(paren
id|req-&gt;wb_page
)paren
op_ne
id|page_index
c_func
(paren
id|prev-&gt;wb_page
)paren
op_plus
l_int|1
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;wb_offset
op_ne
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|nfs_list_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_list_add_request
c_func
(paren
id|req
comma
id|dst
)paren
suffix:semicolon
id|pages
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;wb_offset
op_plus
id|req-&gt;wb_bytes
op_ne
id|PAGE_CACHE_SIZE
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|pages
op_ge
id|maxpages
)paren
r_break
suffix:semicolon
)brace
r_return
id|pages
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to update any existing write request, or create one if there is none.&n; * In order to match, the request&squot;s credentials must match those of&n; * the calling process.&n; *&n; * Note: Should always be called with the Page Lock held!&n; */
r_static
r_struct
id|nfs_page
op_star
DECL|function|nfs_update_request
id|nfs_update_request
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|bytes
)paren
(brace
r_struct
id|nfs_page
op_star
id|req
comma
op_star
r_new
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|rqend
comma
id|end
suffix:semicolon
id|end
op_assign
id|offset
op_plus
id|bytes
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Loop over all inode entries and see if we find&n;&t;&t; * A request for the page we wish to update&n;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|req
op_assign
id|_nfs_find_request
c_func
(paren
id|inode
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|nfs_lock_request
c_func
(paren
id|req
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|nfs_wait_on_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_release_request
c_func
(paren
id|req
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
)paren
id|nfs_release_request
c_func
(paren
r_new
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|req
op_assign
r_new
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
id|nfs_lock_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_inode_add_request
c_func
(paren
id|inode
comma
id|req
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
id|nfs_mark_request_dirty
c_func
(paren
id|req
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|nfs_wreq_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we&squot;re over the soft limit, flush out old requests&n;&t;&t; */
r_if
c_cond
(paren
id|inode-&gt;u.nfs_i.npages
op_ge
id|MAX_REQUEST_SOFT
)paren
id|nfs_wb_file
c_func
(paren
id|inode
comma
id|file
)paren
suffix:semicolon
r_new
op_assign
id|nfs_create_request
c_func
(paren
id|file
comma
id|inode
comma
id|page
comma
id|offset
comma
id|bytes
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
multiline_comment|/* If the region is locked, adjust the timeout */
r_if
c_cond
(paren
id|region_locked
c_func
(paren
id|inode
comma
r_new
)paren
)paren
r_new
op_member_access_from_pointer
id|wb_timeout
op_assign
id|jiffies
op_plus
id|NFS_WRITEBACK_LOCKDELAY
suffix:semicolon
r_else
r_new
op_member_access_from_pointer
id|wb_timeout
op_assign
id|jiffies
op_plus
id|NFS_WRITEBACK_DELAY
suffix:semicolon
)brace
multiline_comment|/* We have a request for our page.&n;&t; * If the creds don&squot;t match, or the&n;&t; * page addresses don&squot;t match,&n;&t; * tell the caller to wait on the conflicting&n;&t; * request.&n;&t; */
id|rqend
op_assign
id|req-&gt;wb_offset
op_plus
id|req-&gt;wb_bytes
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;wb_file
op_ne
id|file
op_logical_or
id|req-&gt;wb_page
op_ne
id|page
op_logical_or
op_logical_neg
id|nfs_dirty_request
c_func
(paren
id|req
)paren
op_logical_or
id|offset
OG
id|rqend
op_logical_or
id|end
OL
id|req-&gt;wb_offset
)paren
(brace
id|nfs_unlock_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_release_request
c_func
(paren
id|req
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EBUSY
)paren
suffix:semicolon
)brace
multiline_comment|/* Okay, the request matches. Update the region */
r_if
c_cond
(paren
id|offset
OL
id|req-&gt;wb_offset
)paren
(brace
id|req-&gt;wb_offset
op_assign
id|offset
suffix:semicolon
id|req-&gt;wb_bytes
op_assign
id|rqend
op_minus
id|req-&gt;wb_offset
suffix:semicolon
)brace
r_if
c_cond
(paren
id|end
OG
id|rqend
)paren
id|req-&gt;wb_bytes
op_assign
id|end
op_minus
id|req-&gt;wb_offset
suffix:semicolon
id|nfs_unlock_request
c_func
(paren
id|req
)paren
suffix:semicolon
r_return
id|req
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the strategy routine for NFS.&n; * It is called by nfs_updatepage whenever the user wrote up to the end&n; * of a page.&n; *&n; * We always try to submit a set of requests in parallel so that the&n; * server&squot;s write code can gather writes. This is mainly for the benefit&n; * of NFSv2.&n; *&n; * We never submit more requests than we think the remote can handle.&n; * For UDP sockets, we make sure we don&squot;t exceed the congestion window;&n; * for TCP, we limit the number of requests to 8.&n; *&n; * NFS_STRATEGY_PAGES gives the minimum number of requests for NFSv2 that&n; * should be sent out in one go. This is for the benefit of NFSv2 servers&n; * that perform write gathering.&n; *&n; * FIXME: Different servers may have different sweet spots.&n; * Record the average congestion window in server struct?&n; */
DECL|macro|NFS_STRATEGY_PAGES
mdefine_line|#define NFS_STRATEGY_PAGES      8
r_static
r_void
DECL|function|nfs_strategy
id|nfs_strategy
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
r_int
id|dirty
comma
id|wpages
suffix:semicolon
id|dirty
op_assign
id|inode-&gt;u.nfs_i.ndirty
suffix:semicolon
id|wpages
op_assign
id|NFS_SERVER
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|wpages
suffix:semicolon
macro_line|#ifdef CONFIG_NFS_V3
r_if
c_cond
(paren
id|NFS_PROTO
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|version
op_eq
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|dirty
op_ge
id|NFS_STRATEGY_PAGES
op_star
id|wpages
)paren
id|nfs_flush_file
c_func
(paren
id|inode
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dirty
op_ge
id|wpages
)paren
id|nfs_flush_file
c_func
(paren
id|inode
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;u.nfs_i.ncommit
OG
id|NFS_STRATEGY_PAGES
op_star
id|wpages
op_logical_and
id|atomic_read
c_func
(paren
op_amp
id|nfs_nr_requests
)paren
OG
id|MAX_REQUEST_SOFT
)paren
id|nfs_commit_file
c_func
(paren
id|inode
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
id|dirty
op_ge
id|NFS_STRATEGY_PAGES
op_star
id|wpages
)paren
id|nfs_flush_file
c_func
(paren
id|inode
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * If we&squot;re running out of free requests, flush out everything&n;&t; * in order to reduce memory useage...&n;&t; */
r_if
c_cond
(paren
id|inode-&gt;u.nfs_i.npages
OG
id|MAX_REQUEST_SOFT
)paren
id|nfs_wb_all
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_int
DECL|function|nfs_flush_incompatible
id|nfs_flush_incompatible
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Look for a request corresponding to this page. If there&n;&t; * is one, and it belongs to another file, we flush it out&n;&t; * before we try to copy anything into the page. Do this&n;&t; * due to the lack of an ACCESS-type call in NFSv2.&n;&t; * Also do the same if we find a request from an existing&n;&t; * dropped page.&n;&t; */
id|req
op_assign
id|nfs_find_request
c_func
(paren
id|inode
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;wb_file
op_ne
id|file
op_logical_or
id|req-&gt;wb_page
op_ne
id|page
)paren
id|status
op_assign
id|nfs_wb_page
c_func
(paren
id|inode
comma
id|page
)paren
suffix:semicolon
id|nfs_release_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
r_return
(paren
id|status
OL
l_int|0
)paren
ques
c_cond
id|status
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Update and possibly write a cached page of an NFS file.&n; *&n; * XXX: Keep an eye on generic_file_read to make sure it doesn&squot;t do bad&n; * things with a page scheduled for an RPC call (e.g. invalidate it).&n; */
r_int
DECL|function|nfs_updatepage
id|nfs_updatepage
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
r_int
id|synchronous
op_assign
id|file-&gt;f_flags
op_amp
id|O_SYNC
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS:      nfs_updatepage(%s/%s %d@%Ld)&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|count
comma
(paren
r_int
r_int
)paren
(paren
id|page_offset
c_func
(paren
id|page
)paren
op_plus
id|offset
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If wsize is smaller than page size, update and write&n;&t; * page synchronously.&n;&t; */
r_if
c_cond
(paren
id|NFS_SERVER
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|wsize
OL
id|PAGE_SIZE
)paren
r_return
id|nfs_writepage_sync
c_func
(paren
id|file
comma
id|inode
comma
id|page
comma
id|offset
comma
id|count
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Try to find an NFS request corresponding to this page&n;&t; * and update it.&n;&t; * If the existing request cannot be updated, we must flush&n;&t; * it out now.&n;&t; */
r_do
(brace
id|req
op_assign
id|nfs_update_request
c_func
(paren
id|file
comma
id|inode
comma
id|page
comma
id|offset
comma
id|count
)paren
suffix:semicolon
id|status
op_assign
(paren
id|IS_ERR
c_func
(paren
id|req
)paren
)paren
ques
c_cond
id|PTR_ERR
c_func
(paren
id|req
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
op_minus
id|EBUSY
)paren
r_break
suffix:semicolon
multiline_comment|/* Request could not be updated. Flush it out and try again */
id|status
op_assign
id|nfs_wb_page
c_func
(paren
id|inode
comma
id|page
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|status
op_ge
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;wb_bytes
op_eq
id|PAGE_CACHE_SIZE
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|synchronous
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
id|nfs_sync_file
c_func
(paren
id|inode
comma
id|file
comma
id|page_index
c_func
(paren
id|page
)paren
comma
l_int|1
comma
id|FLUSH_SYNC
op_or
id|FLUSH_STABLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
op_logical_or
(paren
id|error
op_assign
id|file-&gt;f_error
)paren
OL
l_int|0
)paren
id|status
op_assign
id|error
suffix:semicolon
id|file-&gt;f_error
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If we wrote past the end of the page.&n;&t;&t; * Call the strategy routine so it can send out a bunch&n;&t;&t; * of requests.&n;&t;&t; */
r_if
c_cond
(paren
id|req-&gt;wb_offset
op_eq
l_int|0
op_logical_and
id|req-&gt;wb_bytes
op_eq
id|PAGE_CACHE_SIZE
)paren
id|nfs_strategy
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
id|nfs_release_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|done
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;NFS:      nfs_updatepage returns %d (isize %Ld)&bslash;n&quot;
comma
id|status
comma
(paren
r_int
r_int
)paren
id|inode-&gt;i_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * Set up the argument/result storage required for the RPC call.&n; */
r_static
r_void
DECL|function|nfs_write_rpcsetup
id|nfs_write_rpcsetup
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_struct
id|nfs_write_data
op_star
id|data
)paren
(brace
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
r_struct
id|iovec
op_star
id|iov
suffix:semicolon
r_int
r_int
id|count
suffix:semicolon
multiline_comment|/* Set up the RPC argument and reply structs&n;&t; * NB: take care not to mess about with data-&gt;commit et al. */
id|iov
op_assign
id|data-&gt;args.iov
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
r_struct
id|nfs_page
op_star
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|head-&gt;next
)paren
suffix:semicolon
id|nfs_list_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_list_add_request
c_func
(paren
id|req
comma
op_amp
id|data-&gt;pages
)paren
suffix:semicolon
id|iov-&gt;iov_base
op_assign
id|kmap
c_func
(paren
id|req-&gt;wb_page
)paren
op_plus
id|req-&gt;wb_offset
suffix:semicolon
id|iov-&gt;iov_len
op_assign
id|req-&gt;wb_bytes
suffix:semicolon
id|count
op_add_assign
id|req-&gt;wb_bytes
suffix:semicolon
id|iov
op_increment
suffix:semicolon
id|data-&gt;args.nriov
op_increment
suffix:semicolon
)brace
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|data-&gt;pages.next
)paren
suffix:semicolon
id|data-&gt;inode
op_assign
id|req-&gt;wb_inode
suffix:semicolon
id|data-&gt;cred
op_assign
id|req-&gt;wb_cred
suffix:semicolon
id|data-&gt;args.fh
op_assign
id|NFS_FH
c_func
(paren
id|req-&gt;wb_inode
)paren
suffix:semicolon
id|data-&gt;args.offset
op_assign
id|page_offset
c_func
(paren
id|req-&gt;wb_page
)paren
op_plus
id|req-&gt;wb_offset
suffix:semicolon
id|data-&gt;args.count
op_assign
id|count
suffix:semicolon
id|data-&gt;res.fattr
op_assign
op_amp
id|data-&gt;fattr
suffix:semicolon
id|data-&gt;res.count
op_assign
id|count
suffix:semicolon
id|data-&gt;res.verf
op_assign
op_amp
id|data-&gt;verf
suffix:semicolon
)brace
multiline_comment|/*&n; * Create an RPC task for the given write request and kick it.&n; * The page must have been locked by the caller.&n; *&n; * It may happen that the page we&squot;re passed is not marked dirty.&n; * This is the case if nfs_updatepage detects a conflicting request&n; * that has been written but not committed.&n; */
r_static
r_int
DECL|function|nfs_flush_one
id|nfs_flush_one
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_struct
id|inode
op_star
id|inode
comma
r_int
id|how
)paren
(brace
r_struct
id|rpc_clnt
op_star
id|clnt
op_assign
id|NFS_CLIENT
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|nfs_write_data
op_star
id|data
suffix:semicolon
r_struct
id|rpc_task
op_star
id|task
suffix:semicolon
r_struct
id|rpc_message
id|msg
suffix:semicolon
r_int
id|flags
comma
id|async
op_assign
op_logical_neg
(paren
id|how
op_amp
id|FLUSH_SYNC
)paren
comma
id|stable
op_assign
(paren
id|how
op_amp
id|FLUSH_STABLE
)paren
suffix:semicolon
id|sigset_t
id|oldset
suffix:semicolon
id|data
op_assign
id|nfs_writedata_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_goto
id|out_bad
suffix:semicolon
id|task
op_assign
op_amp
id|data-&gt;task
suffix:semicolon
multiline_comment|/* Set the initial flags for the task.  */
id|flags
op_assign
(paren
id|async
)paren
ques
c_cond
id|RPC_TASK_ASYNC
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* Set up the argument struct */
id|nfs_write_rpcsetup
c_func
(paren
id|head
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stable
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;u.nfs_i.ncommit
)paren
id|data-&gt;args.stable
op_assign
id|NFS_FILE_SYNC
suffix:semicolon
r_else
id|data-&gt;args.stable
op_assign
id|NFS_DATA_SYNC
suffix:semicolon
)brace
r_else
id|data-&gt;args.stable
op_assign
id|NFS_UNSTABLE
suffix:semicolon
multiline_comment|/* Finalize the task. */
id|rpc_init_task
c_func
(paren
id|task
comma
id|clnt
comma
id|nfs_writeback_done
comma
id|flags
)paren
suffix:semicolon
id|task-&gt;tk_calldata
op_assign
id|data
suffix:semicolon
multiline_comment|/* Release requests */
id|task-&gt;tk_release
op_assign
id|nfs_writedata_release
suffix:semicolon
macro_line|#ifdef CONFIG_NFS_V3
id|msg.rpc_proc
op_assign
(paren
id|NFS_PROTO
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|version
op_eq
l_int|3
)paren
ques
c_cond
id|NFS3PROC_WRITE
suffix:colon
id|NFSPROC_WRITE
suffix:semicolon
macro_line|#else
id|msg.rpc_proc
op_assign
id|NFSPROC_WRITE
suffix:semicolon
macro_line|#endif
id|msg.rpc_argp
op_assign
op_amp
id|data-&gt;args
suffix:semicolon
id|msg.rpc_resp
op_assign
op_amp
id|data-&gt;res
suffix:semicolon
id|msg.rpc_cred
op_assign
id|data-&gt;cred
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS: %4d initiated write call (req %x/%Ld count %d nriov %d)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|inode-&gt;i_dev
comma
(paren
r_int
r_int
)paren
id|NFS_FILEID
c_func
(paren
id|inode
)paren
comma
id|data-&gt;args.count
comma
id|data-&gt;args.nriov
)paren
suffix:semicolon
id|rpc_clnt_sigmask
c_func
(paren
id|clnt
comma
op_amp
id|oldset
)paren
suffix:semicolon
id|rpc_call_setup
c_func
(paren
id|task
comma
op_amp
id|msg
comma
l_int|0
)paren
suffix:semicolon
id|rpc_execute
c_func
(paren
id|task
)paren
suffix:semicolon
id|rpc_clnt_sigunmask
c_func
(paren
id|clnt
comma
op_amp
id|oldset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_bad
suffix:colon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
r_struct
id|nfs_page
op_star
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|head-&gt;next
)paren
suffix:semicolon
id|nfs_list_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_mark_request_dirty
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_unlock_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_static
r_int
DECL|function|nfs_flush_list
id|nfs_flush_list
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|list_head
op_star
id|head
comma
r_int
id|how
)paren
(brace
id|LIST_HEAD
c_func
(paren
id|one_request
)paren
suffix:semicolon
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|pages
op_assign
l_int|0
comma
id|wpages
op_assign
id|NFS_SERVER
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|wpages
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
id|pages
op_add_assign
id|nfs_coalesce_requests
c_func
(paren
id|head
comma
op_amp
id|one_request
comma
id|wpages
)paren
suffix:semicolon
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|one_request.next
)paren
suffix:semicolon
id|error
op_assign
id|nfs_flush_one
c_func
(paren
op_amp
id|one_request
comma
id|req-&gt;wb_inode
comma
id|how
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
op_ge
l_int|0
)paren
r_return
id|pages
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|head-&gt;next
)paren
suffix:semicolon
id|nfs_list_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_mark_request_dirty
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_unlock_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called when the WRITE call is complete.&n; */
r_static
r_void
DECL|function|nfs_writeback_done
id|nfs_writeback_done
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|nfs_write_data
op_star
id|data
op_assign
(paren
r_struct
id|nfs_write_data
op_star
)paren
id|task-&gt;tk_calldata
suffix:semicolon
r_struct
id|nfs_writeargs
op_star
id|argp
op_assign
op_amp
id|data-&gt;args
suffix:semicolon
r_struct
id|nfs_writeres
op_star
id|resp
op_assign
op_amp
id|data-&gt;res
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|data-&gt;inode
suffix:semicolon
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS: %4d nfs_writeback_done (status %d)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|task-&gt;tk_status
)paren
suffix:semicolon
multiline_comment|/* We can&squot;t handle that yet but we check for it nevertheless */
r_if
c_cond
(paren
id|resp-&gt;count
OL
id|argp-&gt;count
op_logical_and
id|task-&gt;tk_status
op_ge
l_int|0
)paren
(brace
r_static
r_int
r_int
id|complain
suffix:semicolon
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|complain
comma
id|jiffies
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;NFS: Server wrote less than requested.&bslash;n&quot;
)paren
suffix:semicolon
id|complain
op_assign
id|jiffies
op_plus
l_int|300
op_star
id|HZ
suffix:semicolon
)brace
multiline_comment|/* Can&squot;t do anything about it right now except throw&n;&t;&t; * an error. */
id|task-&gt;tk_status
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NFS_V3
r_if
c_cond
(paren
id|resp-&gt;verf-&gt;committed
OL
id|argp-&gt;stable
op_logical_and
id|task-&gt;tk_status
op_ge
l_int|0
)paren
(brace
multiline_comment|/* We tried a write call, but the server did not&n;&t;&t; * commit data to stable storage even though we&n;&t;&t; * requested it.&n;&t;&t; * Note: There is a known bug in Tru64 &lt; 5.0 in which&n;&t;&t; *&t; the server reports NFS_DATA_SYNC, but performs&n;&t;&t; *&t; NFS_FILE_SYNC. We therefore implement this checking&n;&t;&t; *&t; as a dprintk() in order to avoid filling syslog.&n;&t;&t; */
r_static
r_int
r_int
id|complain
suffix:semicolon
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|complain
comma
id|jiffies
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFS: faulty NFSv3 server %s:&quot;
l_string|&quot; (committed = %d) != (stable = %d)&bslash;n&quot;
comma
id|NFS_SERVER
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|hostname
comma
id|resp-&gt;verf-&gt;committed
comma
id|argp-&gt;stable
)paren
suffix:semicolon
id|complain
op_assign
id|jiffies
op_plus
l_int|300
op_star
id|HZ
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Update attributes as result of writeback.&n;&t; * FIXME: There is an inherent race with invalidate_inode_pages and&n;&t; *&t;  writebacks since the page-&gt;count is kept &gt; 1 for as long&n;&t; *&t;  as the page has a write request pending.&n;&t; */
id|nfs_write_attributes
c_func
(paren
id|inode
comma
id|resp-&gt;fattr
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|data-&gt;pages
)paren
)paren
(brace
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|data-&gt;pages.next
)paren
suffix:semicolon
id|nfs_list_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|page
op_assign
id|req-&gt;wb_page
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS: write (%x/%Ld %d@%Ld)&quot;
comma
id|req-&gt;wb_inode-&gt;i_dev
comma
(paren
r_int
r_int
)paren
id|NFS_FILEID
c_func
(paren
id|req-&gt;wb_inode
)paren
comma
id|req-&gt;wb_bytes
comma
(paren
r_int
r_int
)paren
(paren
id|page_offset
c_func
(paren
id|page
)paren
op_plus
id|req-&gt;wb_offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_status
OL
l_int|0
)paren
(brace
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;wb_file
)paren
id|req-&gt;wb_file-&gt;f_error
op_assign
id|task-&gt;tk_status
suffix:semicolon
id|nfs_inode_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;, error = %d&bslash;n&quot;
comma
id|task-&gt;tk_status
)paren
suffix:semicolon
r_goto
id|next
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NFS_V3
r_if
c_cond
(paren
id|resp-&gt;verf-&gt;committed
op_ne
id|NFS_UNSTABLE
)paren
(brace
id|nfs_inode_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot; OK&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|next
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|req-&gt;wb_verf
comma
id|resp-&gt;verf
comma
r_sizeof
(paren
id|req-&gt;wb_verf
)paren
)paren
suffix:semicolon
id|req-&gt;wb_timeout
op_assign
id|jiffies
op_plus
id|NFS_COMMIT_DELAY
suffix:semicolon
id|nfs_mark_request_commit
c_func
(paren
id|req
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot; marked for commit&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|nfs_inode_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
macro_line|#endif
id|next
suffix:colon
id|nfs_unlock_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_NFS_V3
multiline_comment|/*&n; * Set up the argument/result storage required for the RPC call.&n; */
r_static
r_void
DECL|function|nfs_commit_rpcsetup
id|nfs_commit_rpcsetup
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_struct
id|nfs_write_data
op_star
id|data
)paren
(brace
r_struct
id|nfs_page
op_star
id|first
comma
op_star
id|last
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|loff_t
id|start
comma
id|end
comma
id|len
suffix:semicolon
multiline_comment|/* Set up the RPC argument and reply structs&n;&t; * NB: take care not to mess about with data-&gt;commit et al. */
id|list_splice
c_func
(paren
id|head
comma
op_amp
id|data-&gt;pages
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
id|head
)paren
suffix:semicolon
id|first
op_assign
id|nfs_list_entry
c_func
(paren
id|data-&gt;pages.next
)paren
suffix:semicolon
id|last
op_assign
id|nfs_list_entry
c_func
(paren
id|data-&gt;pages.prev
)paren
suffix:semicolon
id|inode
op_assign
id|first-&gt;wb_inode
suffix:semicolon
multiline_comment|/*&n;&t; * Determine the offset range of requests in the COMMIT call.&n;&t; * We rely on the fact that data-&gt;pages is an ordered list...&n;&t; */
id|start
op_assign
id|page_offset
c_func
(paren
id|first-&gt;wb_page
)paren
op_plus
id|first-&gt;wb_offset
suffix:semicolon
id|end
op_assign
id|page_offset
c_func
(paren
id|last-&gt;wb_page
)paren
op_plus
(paren
id|last-&gt;wb_offset
op_plus
id|last-&gt;wb_bytes
)paren
suffix:semicolon
id|len
op_assign
id|end
op_minus
id|start
suffix:semicolon
multiline_comment|/* If &squot;len&squot; is not a 32-bit quantity, pass &squot;0&squot; in the COMMIT call */
r_if
c_cond
(paren
id|end
op_ge
id|inode-&gt;i_size
op_logical_or
id|len
template_param
(paren
op_complement
(paren
(paren
id|u32
)paren
l_int|0
)paren
op_rshift
l_int|1
)paren
)paren
id|len
op_assign
l_int|0
suffix:semicolon
id|data-&gt;inode
op_assign
id|inode
suffix:semicolon
id|data-&gt;cred
op_assign
id|first-&gt;wb_cred
suffix:semicolon
id|data-&gt;args.fh
op_assign
id|NFS_FH
c_func
(paren
id|inode
)paren
suffix:semicolon
id|data-&gt;args.offset
op_assign
id|start
suffix:semicolon
id|data-&gt;res.count
op_assign
id|data-&gt;args.count
op_assign
(paren
id|u32
)paren
id|len
suffix:semicolon
id|data-&gt;res.fattr
op_assign
op_amp
id|data-&gt;fattr
suffix:semicolon
id|data-&gt;res.verf
op_assign
op_amp
id|data-&gt;verf
suffix:semicolon
)brace
multiline_comment|/*&n; * Commit dirty pages&n; */
r_static
r_int
DECL|function|nfs_commit_list
id|nfs_commit_list
c_func
(paren
r_struct
id|list_head
op_star
id|head
comma
r_int
id|how
)paren
(brace
r_struct
id|rpc_message
id|msg
suffix:semicolon
r_struct
id|rpc_clnt
op_star
id|clnt
suffix:semicolon
r_struct
id|nfs_write_data
op_star
id|data
suffix:semicolon
r_struct
id|rpc_task
op_star
id|task
suffix:semicolon
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
r_int
id|flags
comma
id|async
op_assign
op_logical_neg
(paren
id|how
op_amp
id|FLUSH_SYNC
)paren
suffix:semicolon
id|sigset_t
id|oldset
suffix:semicolon
id|data
op_assign
id|nfs_writedata_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_goto
id|out_bad
suffix:semicolon
id|task
op_assign
op_amp
id|data-&gt;task
suffix:semicolon
id|flags
op_assign
(paren
id|async
)paren
ques
c_cond
id|RPC_TASK_ASYNC
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* Set up the argument struct */
id|nfs_commit_rpcsetup
c_func
(paren
id|head
comma
id|data
)paren
suffix:semicolon
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|data-&gt;pages.next
)paren
suffix:semicolon
id|clnt
op_assign
id|NFS_CLIENT
c_func
(paren
id|req-&gt;wb_inode
)paren
suffix:semicolon
id|rpc_init_task
c_func
(paren
id|task
comma
id|clnt
comma
id|nfs_commit_done
comma
id|flags
)paren
suffix:semicolon
id|task-&gt;tk_calldata
op_assign
id|data
suffix:semicolon
multiline_comment|/* Release requests */
id|task-&gt;tk_release
op_assign
id|nfs_writedata_release
suffix:semicolon
id|msg.rpc_proc
op_assign
id|NFS3PROC_COMMIT
suffix:semicolon
id|msg.rpc_argp
op_assign
op_amp
id|data-&gt;args
suffix:semicolon
id|msg.rpc_resp
op_assign
op_amp
id|data-&gt;res
suffix:semicolon
id|msg.rpc_cred
op_assign
id|data-&gt;cred
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS: %4d initiated commit call&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|rpc_clnt_sigmask
c_func
(paren
id|clnt
comma
op_amp
id|oldset
)paren
suffix:semicolon
id|rpc_call_setup
c_func
(paren
id|task
comma
op_amp
id|msg
comma
l_int|0
)paren
suffix:semicolon
id|rpc_execute
c_func
(paren
id|task
)paren
suffix:semicolon
id|rpc_clnt_sigunmask
c_func
(paren
id|clnt
comma
op_amp
id|oldset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_bad
suffix:colon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|head-&gt;next
)paren
suffix:semicolon
id|nfs_list_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_mark_request_commit
c_func
(paren
id|req
)paren
suffix:semicolon
id|nfs_unlock_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n; * COMMIT call returned&n; */
r_static
r_void
DECL|function|nfs_commit_done
id|nfs_commit_done
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|nfs_write_data
op_star
id|data
op_assign
(paren
r_struct
id|nfs_write_data
op_star
)paren
id|task-&gt;tk_calldata
suffix:semicolon
r_struct
id|nfs_writeres
op_star
id|resp
op_assign
op_amp
id|data-&gt;res
suffix:semicolon
r_struct
id|nfs_page
op_star
id|req
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|data-&gt;inode
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS: %4d nfs_commit_done (status %d)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|task-&gt;tk_status
)paren
suffix:semicolon
id|nfs_write_attributes
c_func
(paren
id|inode
comma
id|resp-&gt;fattr
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|data-&gt;pages
)paren
)paren
(brace
id|req
op_assign
id|nfs_list_entry
c_func
(paren
id|data-&gt;pages.next
)paren
suffix:semicolon
id|nfs_list_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS: commit (%x/%Ld %d@%Ld)&quot;
comma
id|req-&gt;wb_inode-&gt;i_dev
comma
(paren
r_int
r_int
)paren
id|NFS_FILEID
c_func
(paren
id|req-&gt;wb_inode
)paren
comma
id|req-&gt;wb_bytes
comma
(paren
r_int
r_int
)paren
(paren
id|page_offset
c_func
(paren
id|req-&gt;wb_page
)paren
op_plus
id|req-&gt;wb_offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|task-&gt;tk_status
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;wb_file
)paren
id|req-&gt;wb_file-&gt;f_error
op_assign
id|task-&gt;tk_status
suffix:semicolon
id|nfs_inode_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;, error = %d&bslash;n&quot;
comma
id|task-&gt;tk_status
)paren
suffix:semicolon
r_goto
id|next
suffix:semicolon
)brace
multiline_comment|/* Okay, COMMIT succeeded, apparently. Check the verifier&n;&t;&t; * returned by the server against all stored verfs. */
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|req-&gt;wb_verf.verifier
comma
id|data-&gt;verf.verifier
comma
r_sizeof
(paren
id|data-&gt;verf.verifier
)paren
)paren
)paren
(brace
multiline_comment|/* We have a match */
id|nfs_inode_remove_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot; OK&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|next
suffix:semicolon
)brace
multiline_comment|/* We have a mismatch. Write the page again */
id|dprintk
c_func
(paren
l_string|&quot; mismatch&bslash;n&quot;
)paren
suffix:semicolon
id|nfs_mark_request_dirty
c_func
(paren
id|req
)paren
suffix:semicolon
id|next
suffix:colon
id|nfs_unlock_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|function|nfs_flush_file
r_int
id|nfs_flush_file
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|idx_start
comma
r_int
r_int
id|npages
comma
r_int
id|how
)paren
(brace
id|LIST_HEAD
c_func
(paren
id|head
)paren
suffix:semicolon
r_int
id|res
comma
id|error
op_assign
l_int|0
suffix:semicolon
id|res
op_assign
id|nfs_scan_dirty
c_func
(paren
id|inode
comma
op_amp
id|head
comma
id|file
comma
id|idx_start
comma
id|npages
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
id|error
op_assign
id|nfs_flush_list
c_func
(paren
id|inode
comma
op_amp
id|head
comma
id|how
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_return
id|error
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|nfs_flush_timeout
r_int
id|nfs_flush_timeout
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|how
)paren
(brace
id|LIST_HEAD
c_func
(paren
id|head
)paren
suffix:semicolon
r_int
id|pages
comma
id|error
op_assign
l_int|0
suffix:semicolon
id|pages
op_assign
id|nfs_scan_dirty_timeout
c_func
(paren
id|inode
comma
op_amp
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pages
)paren
id|error
op_assign
id|nfs_flush_list
c_func
(paren
id|inode
comma
op_amp
id|head
comma
id|how
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_return
id|error
suffix:semicolon
r_return
id|pages
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NFS_V3
DECL|function|nfs_commit_file
r_int
id|nfs_commit_file
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|idx_start
comma
r_int
r_int
id|npages
comma
r_int
id|how
)paren
(brace
id|LIST_HEAD
c_func
(paren
id|head
)paren
suffix:semicolon
r_int
id|res
comma
id|error
op_assign
l_int|0
suffix:semicolon
id|res
op_assign
id|nfs_scan_commit
c_func
(paren
id|inode
comma
op_amp
id|head
comma
id|file
comma
id|idx_start
comma
id|npages
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
id|error
op_assign
id|nfs_commit_list
c_func
(paren
op_amp
id|head
comma
id|how
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_return
id|error
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|nfs_commit_timeout
r_int
id|nfs_commit_timeout
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|how
)paren
(brace
id|LIST_HEAD
c_func
(paren
id|head
)paren
suffix:semicolon
r_int
id|pages
comma
id|error
op_assign
l_int|0
suffix:semicolon
id|pages
op_assign
id|nfs_scan_commit_timeout
c_func
(paren
id|inode
comma
op_amp
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pages
)paren
(brace
id|pages
op_add_assign
id|nfs_scan_commit
c_func
(paren
id|inode
comma
op_amp
id|head
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|nfs_commit_list
c_func
(paren
op_amp
id|head
comma
id|how
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_return
id|error
suffix:semicolon
r_return
id|pages
suffix:semicolon
)brace
macro_line|#endif
DECL|function|nfs_sync_file
r_int
id|nfs_sync_file
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|idx_start
comma
r_int
r_int
id|npages
comma
r_int
id|how
)paren
(brace
r_int
id|error
comma
id|wait
suffix:semicolon
id|wait
op_assign
id|how
op_amp
id|FLUSH_WAIT
suffix:semicolon
id|how
op_and_assign
op_complement
id|FLUSH_WAIT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
op_logical_and
id|file
)paren
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_do
(brace
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
id|error
op_assign
id|nfs_wait_on_requests
c_func
(paren
id|inode
comma
id|file
comma
id|idx_start
comma
id|npages
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
id|error
op_assign
id|nfs_flush_file
c_func
(paren
id|inode
comma
id|file
comma
id|idx_start
comma
id|npages
comma
id|how
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NFS_V3
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
id|error
op_assign
id|nfs_commit_file
c_func
(paren
id|inode
comma
id|file
comma
id|idx_start
comma
id|npages
comma
id|how
)paren
suffix:semicolon
macro_line|#endif
)brace
r_while
c_loop
(paren
id|error
OG
l_int|0
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|nfs_init_nfspagecache
r_int
id|nfs_init_nfspagecache
c_func
(paren
r_void
)paren
(brace
id|nfs_page_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;nfs_page&quot;
comma
r_sizeof
(paren
r_struct
id|nfs_page
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nfs_page_cachep
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|nfs_wdata_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;nfs_write_data&quot;
comma
r_sizeof
(paren
r_struct
id|nfs_write_data
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nfs_wdata_cachep
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nfs_destroy_nfspagecache
r_void
id|nfs_destroy_nfspagecache
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|kmem_cache_destroy
c_func
(paren
id|nfs_page_cachep
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;nfs_page: not all structures were freed&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kmem_cache_destroy
c_func
(paren
id|nfs_wdata_cachep
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;nfs_write_data: not all structures were freed&bslash;n&quot;
)paren
suffix:semicolon
)brace
eof
