multiline_comment|/*&n; * linux/fs/nfs/write.c&n; *&n; * Writing file data over NFS.&n; *&n; * We do it like this: When a (user) process wishes to write data to an&n; * NFS file, a write request is allocated that contains the RPC task data&n; * plus some info on the page to be written, and added to the inode&squot;s&n; * write chain. If the process writes past the end of the page, an async&n; * RPC call to write the page is scheduled immediately; otherwise, the call&n; * is delayed for a few seconds.&n; *&n; * Just like readahead, no async I/O is performed if wsize &lt; PAGE_SIZE.&n; *&n; * Write requests are kept on the inode&squot;s writeback list. Each entry in&n; * that list references the page (portion) to be written. When the&n; * cache timeout has expired, the RPC task is woken up, and tries to&n; * lock the page. As soon as it manages to do so, the request is moved&n; * from the writeback list to the writelock list.&n; *&n; * Note: we must make sure never to confuse the inode passed in the&n; * write_page request with the one in page-&gt;inode. As far as I understant&n; * it, these are different when doing a swap-out.&n; *&n; * To understand everything that goes one here and in the nfs read code,&n; * one should be aware that a page is locked in exactly one of the following&n; * cases:&n; *&n; *  -&t;A write request is in progress.&n; *  -&t;A user process is in generic_file_write/nfs_update_page&n; *  -&t;A user process is in generic_file_read&n; *&n; * Also note that because of the way pages are invalidated in&n; * nfs_revalidate_inode, the following assertions hold:&n; *&n; *  -&t;If a page is dirty, there will be no read requests (a page will&n; *&t;not be re-read unless invalidated by nfs_revalidate_inode).&n; *  -&t;If the page is not uptodate, there will be no pending write&n; *&t;requests, and no process will be in nfs_update_page.&n; *&n; * FIXME: Interaction with the vmscan routines is not optimal yet.&n; * Either vmscan must be made nfs-savvy, or we need a different page&n; * reclaim concept that supports something like FS-independent&n; * buffer_heads with a b_ops-&gt; field.&n; *&n; * Copyright (C) 1996, 1997, Olaf Kirch &lt;okir@monad.swb.de&gt;&n; */
DECL|macro|NFS_NEED_XDR_TYPES
mdefine_line|#define NFS_NEED_XDR_TYPES
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/sunrpc/clnt.h&gt;
macro_line|#include &lt;linux/nfs_fs.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/*&n; * NOTE! We must NOT default to soft-mounting: that breaks too many&n; * programs that depend on POSIX behaviour of uninterruptible reads&n; * and writes.&n; *&n; * Until we have a per-mount soft/hard mount policy that we can honour&n; * we must default to hard mounting!&n; */
DECL|macro|IS_SOFT
mdefine_line|#define IS_SOFT 0
DECL|macro|NFS_PARANOIA
mdefine_line|#define NFS_PARANOIA 1
DECL|macro|NFSDBG_FACILITY
mdefine_line|#define NFSDBG_FACILITY&t;&t;NFSDBG_PAGECACHE
r_static
r_void
id|nfs_wback_lock
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
suffix:semicolon
r_static
r_void
id|nfs_wback_result
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
suffix:semicolon
multiline_comment|/*&n; * Cache parameters&n; */
DECL|macro|NFS_WRITEBACK_DELAY
mdefine_line|#define NFS_WRITEBACK_DELAY&t;(10 * HZ)
DECL|macro|NFS_WRITEBACK_MAX
mdefine_line|#define NFS_WRITEBACK_MAX&t;64
multiline_comment|/*&n; * Limit number of delayed writes&n; */
DECL|variable|nr_write_requests
r_static
r_int
id|nr_write_requests
op_assign
l_int|0
suffix:semicolon
DECL|variable|nr_failed_requests
r_static
r_int
id|nr_failed_requests
op_assign
l_int|0
suffix:semicolon
DECL|variable|write_queue
r_static
r_struct
id|rpc_wait_queue
id|write_queue
op_assign
id|RPC_INIT_WAITQ
c_func
(paren
l_string|&quot;write_chain&quot;
)paren
suffix:semicolon
DECL|variable|nfs_failed_requests
r_struct
id|nfs_wreq
op_star
id|nfs_failed_requests
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Hack for future NFS swap support */
macro_line|#ifndef IS_SWAPFILE
DECL|macro|IS_SWAPFILE
macro_line|# define IS_SWAPFILE(inode)&t;(0)
macro_line|#endif
multiline_comment|/*&n; * Unlock a page after writing it&n; */
r_static
r_inline
r_void
DECL|function|nfs_unlock_page
id|nfs_unlock_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFS:      unlock %ld&bslash;n&quot;
comma
id|page-&gt;offset
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|PG_locked
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|page-&gt;wait
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NFS_SWAP
multiline_comment|/* async swap-out support */
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|PG_decr_after
comma
op_amp
id|page-&gt;flags
)paren
)paren
id|atomic_dec
c_func
(paren
op_amp
id|page-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|PG_swap_unlock_after
comma
op_amp
id|page-&gt;flags
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * We&squot;re doing a swap, so check that this page is&n;&t;&t; * swap-cached and do the necessary cleanup. &n;&t;&t; */
id|swap_after_unlock_page
c_func
(paren
id|page-&gt;offset
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * Transfer a page lock to a write request waiting for it.&n; */
r_static
r_inline
r_void
DECL|function|transfer_page_lock
id|transfer_page_lock
c_func
(paren
r_struct
id|nfs_wreq
op_star
id|req
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFS:      transfer_page_lock&bslash;n&quot;
)paren
suffix:semicolon
id|req-&gt;wb_flags
op_and_assign
op_complement
id|NFS_WRITE_WANTLOCK
suffix:semicolon
id|req-&gt;wb_flags
op_or_assign
id|NFS_WRITE_LOCKED
suffix:semicolon
id|rpc_wake_up_task
c_func
(paren
op_amp
id|req-&gt;wb_task
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS:      wake up task %d (flags %x)&bslash;n&quot;
comma
id|req-&gt;wb_task.tk_pid
comma
id|req-&gt;wb_flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write a page synchronously.&n; * Offset is the data offset within the page.&n; */
r_static
r_int
DECL|function|nfs_writepage_sync
id|nfs_writepage_sync
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|count
)paren
(brace
r_int
r_int
id|wsize
op_assign
id|NFS_SERVER
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|wsize
suffix:semicolon
r_int
id|result
comma
id|refresh
op_assign
l_int|0
comma
id|written
op_assign
l_int|0
suffix:semicolon
id|u8
op_star
id|buffer
suffix:semicolon
r_struct
id|nfs_fattr
id|fattr
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS:      nfs_writepage_sync(%s/%s %d@%ld)&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|count
comma
id|page-&gt;offset
op_plus
id|offset
)paren
suffix:semicolon
id|buffer
op_assign
(paren
id|u8
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|offset
suffix:semicolon
id|offset
op_add_assign
id|page-&gt;offset
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|count
OL
id|wsize
op_logical_and
op_logical_neg
id|IS_SWAPFILE
c_func
(paren
id|inode
)paren
)paren
id|wsize
op_assign
id|count
suffix:semicolon
id|result
op_assign
id|nfs_proc_write
c_func
(paren
id|NFS_DSERVER
c_func
(paren
id|dentry
)paren
comma
id|NFS_FH
c_func
(paren
id|dentry
)paren
comma
id|IS_SWAPFILE
c_func
(paren
id|inode
)paren
comma
id|offset
comma
id|wsize
comma
id|buffer
comma
op_amp
id|fattr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/* Must mark the page invalid after I/O error */
id|clear_bit
c_func
(paren
id|PG_uptodate
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
r_goto
id|io_error
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_ne
id|wsize
)paren
id|printk
c_func
(paren
l_string|&quot;NFS: short write, wsize=%u, result=%d&bslash;n&quot;
comma
id|wsize
comma
id|result
)paren
suffix:semicolon
id|refresh
op_assign
l_int|1
suffix:semicolon
id|buffer
op_add_assign
id|wsize
suffix:semicolon
id|offset
op_add_assign
id|wsize
suffix:semicolon
id|written
op_add_assign
id|wsize
suffix:semicolon
id|count
op_sub_assign
id|wsize
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we&squot;ve extended the file, update the inode&n;&t;&t; * now so we don&squot;t invalidate the cache.&n;&t;&t; */
r_if
c_cond
(paren
id|offset
OG
id|inode-&gt;i_size
)paren
id|inode-&gt;i_size
op_assign
id|offset
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
)paren
suffix:semicolon
id|io_error
suffix:colon
multiline_comment|/* Note: we don&squot;t refresh if the call failed (fattr invalid) */
r_if
c_cond
(paren
id|refresh
op_logical_and
id|result
op_ge
l_int|0
)paren
(brace
multiline_comment|/* See comments in nfs_wback_result */
multiline_comment|/* N.B. I don&squot;t think this is right -- sync writes in order */
r_if
c_cond
(paren
id|fattr.size
OL
id|inode-&gt;i_size
)paren
id|fattr.size
op_assign
id|inode-&gt;i_size
suffix:semicolon
r_if
c_cond
(paren
id|fattr.mtime.seconds
OL
id|inode-&gt;i_mtime
)paren
id|printk
c_func
(paren
l_string|&quot;nfs_writepage_sync: prior time??&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Solaris 2.5 server seems to send garbled&n;&t;&t; * fattrs occasionally */
r_if
c_cond
(paren
id|inode-&gt;i_ino
op_eq
id|fattr.fileid
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We expect the mtime value to change, and&n;&t;&t;&t; * don&squot;t want to invalidate the caches.&n;&t;&t;&t; */
id|inode-&gt;i_mtime
op_assign
id|fattr.mtime.seconds
suffix:semicolon
id|nfs_refresh_inode
c_func
(paren
id|inode
comma
op_amp
id|fattr
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;nfs_writepage_sync: inode %ld, got %u?&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|fattr.fileid
)paren
suffix:semicolon
)brace
id|nfs_unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|written
ques
c_cond
id|written
suffix:colon
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Append a writeback request to a list&n; */
r_static
r_inline
r_void
DECL|function|append_write_request
id|append_write_request
c_func
(paren
r_struct
id|nfs_wreq
op_star
op_star
id|q
comma
r_struct
id|nfs_wreq
op_star
id|wreq
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFS:      append_write_request(%p, %p)&bslash;n&quot;
comma
id|q
comma
id|wreq
)paren
suffix:semicolon
id|rpc_append_list
c_func
(paren
id|q
comma
id|wreq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a writeback request from a list&n; */
r_static
r_inline
r_void
DECL|function|remove_write_request
id|remove_write_request
c_func
(paren
r_struct
id|nfs_wreq
op_star
op_star
id|q
comma
r_struct
id|nfs_wreq
op_star
id|wreq
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFS:      remove_write_request(%p, %p)&bslash;n&quot;
comma
id|q
comma
id|wreq
)paren
suffix:semicolon
id|rpc_remove_list
c_func
(paren
id|q
comma
id|wreq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find a write request for a given page&n; */
r_static
r_inline
r_struct
id|nfs_wreq
op_star
DECL|function|find_write_request
id|find_write_request
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|nfs_wreq
op_star
id|head
comma
op_star
id|req
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS:      find_write_request(%x/%ld, %p)&bslash;n&quot;
comma
id|inode-&gt;i_dev
comma
id|inode-&gt;i_ino
comma
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|req
op_assign
id|head
op_assign
id|NFS_WRITEBACK
c_func
(paren
id|inode
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|req-&gt;wb_page
op_eq
id|page
)paren
r_return
id|req
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|req
op_assign
id|WB_NEXT
c_func
(paren
id|req
)paren
)paren
op_ne
id|head
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Find any requests for the specified dentry.&n; */
r_int
DECL|function|nfs_find_dentry_request
id|nfs_find_dentry_request
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|nfs_wreq
op_star
id|head
comma
op_star
id|req
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
id|req
op_assign
id|head
op_assign
id|NFS_WRITEBACK
c_func
(paren
id|inode
)paren
suffix:semicolon
r_while
c_loop
(paren
id|req
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;wb_dentry
op_eq
id|dentry
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|req
op_assign
id|WB_NEXT
c_func
(paren
id|req
)paren
)paren
op_eq
id|head
)paren
r_break
suffix:semicolon
)brace
r_return
id|found
suffix:semicolon
)brace
multiline_comment|/*&n; * Find a failed write request by pid&n; */
r_static
r_struct
id|nfs_wreq
op_star
DECL|function|find_failed_request
id|find_failed_request
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|pid_t
id|pid
)paren
(brace
r_struct
id|nfs_wreq
op_star
id|head
comma
op_star
id|req
suffix:semicolon
id|req
op_assign
id|head
op_assign
id|nfs_failed_requests
suffix:semicolon
r_while
c_loop
(paren
id|req
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;wb_inode
op_eq
id|inode
op_logical_and
(paren
id|pid
op_eq
l_int|0
op_logical_or
id|req-&gt;wb_pid
op_eq
id|pid
)paren
)paren
r_return
id|req
suffix:semicolon
r_if
c_cond
(paren
(paren
id|req
op_assign
id|WB_NEXT
c_func
(paren
id|req
)paren
)paren
op_eq
id|head
)paren
r_break
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a request to the failed list.&n; */
r_static
r_void
DECL|function|append_failed_request
id|append_failed_request
c_func
(paren
r_struct
id|nfs_wreq
op_star
id|req
)paren
(brace
r_static
r_int
id|old_max
op_assign
l_int|16
suffix:semicolon
id|append_write_request
c_func
(paren
op_amp
id|nfs_failed_requests
comma
id|req
)paren
suffix:semicolon
id|nr_failed_requests
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|nr_failed_requests
op_ge
id|old_max
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFS: %d failed requests&bslash;n&quot;
comma
id|nr_failed_requests
)paren
suffix:semicolon
id|old_max
op_assign
id|old_max
op_lshift
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Remove a request from the failed list and free it.&n; */
r_static
r_void
DECL|function|remove_failed_request
id|remove_failed_request
c_func
(paren
r_struct
id|nfs_wreq
op_star
id|req
)paren
(brace
id|remove_write_request
c_func
(paren
op_amp
id|nfs_failed_requests
comma
id|req
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|req
)paren
suffix:semicolon
id|nr_failed_requests
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n; * Find and release all failed requests for this inode.&n; */
r_int
DECL|function|nfs_check_failed_request
id|nfs_check_failed_request
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|nfs_wreq
op_star
id|req
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|req
op_assign
id|find_failed_request
c_func
(paren
id|inode
comma
l_int|0
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|remove_failed_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
r_return
id|found
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to merge adjacent write requests. This works only for requests&n; * issued by the same user.&n; */
r_static
r_inline
r_int
DECL|function|update_write_request
id|update_write_request
c_func
(paren
r_struct
id|nfs_wreq
op_star
id|req
comma
r_int
r_int
id|first
comma
r_int
r_int
id|bytes
)paren
(brace
r_int
r_int
id|rqfirst
op_assign
id|req-&gt;wb_offset
comma
id|rqlast
op_assign
id|rqfirst
op_plus
id|req-&gt;wb_bytes
comma
id|last
op_assign
id|first
op_plus
id|bytes
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;nfs:      trying to update write request %p&bslash;n&quot;
comma
id|req
)paren
suffix:semicolon
multiline_comment|/* Check the credentials associated with this write request.&n;&t; * If the buffer is owned by the same user, we can happily&n;&t; * add our data without risking server permission problems.&n;&t; * Note that I&squot;m not messing around with RPC root override creds&n;&t; * here, because they&squot;re used by swap requests only which&n;&t; * always write out full pages. */
r_if
c_cond
(paren
op_logical_neg
id|rpcauth_matchcred
c_func
(paren
op_amp
id|req-&gt;wb_task
comma
id|req-&gt;wb_task.tk_cred
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFS:      update failed (cred mismatch)&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|first
OL
id|rqfirst
)paren
id|rqfirst
op_assign
id|first
suffix:semicolon
r_if
c_cond
(paren
id|rqlast
OL
id|last
)paren
id|rqlast
op_assign
id|last
suffix:semicolon
id|req-&gt;wb_offset
op_assign
id|rqfirst
suffix:semicolon
id|req-&gt;wb_bytes
op_assign
id|rqlast
op_minus
id|rqfirst
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Create and initialize a writeback request&n; */
r_static
r_inline
r_struct
id|nfs_wreq
op_star
DECL|function|create_write_request
id|create_write_request
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|bytes
)paren
(brace
r_struct
id|nfs_wreq
op_star
id|wreq
suffix:semicolon
r_struct
id|rpc_clnt
op_star
id|clnt
op_assign
id|NFS_CLIENT
c_func
(paren
id|inode
)paren
suffix:semicolon
r_struct
id|rpc_task
op_star
id|task
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS:      create_write_request(%s/%s, %ld+%d)&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|page-&gt;offset
op_plus
id|offset
comma
id|bytes
)paren
suffix:semicolon
multiline_comment|/* FIXME: Enforce hard limit on number of concurrent writes? */
id|wreq
op_assign
(paren
r_struct
id|nfs_wreq
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|wreq
)paren
comma
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wreq
)paren
r_goto
id|out_fail
suffix:semicolon
id|memset
c_func
(paren
id|wreq
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|wreq
)paren
)paren
suffix:semicolon
id|task
op_assign
op_amp
id|wreq-&gt;wb_task
suffix:semicolon
id|rpc_init_task
c_func
(paren
id|task
comma
id|clnt
comma
id|nfs_wback_result
comma
id|RPC_TASK_NFSWRITE
)paren
suffix:semicolon
id|task-&gt;tk_calldata
op_assign
id|wreq
suffix:semicolon
id|task-&gt;tk_action
op_assign
id|nfs_wback_lock
suffix:semicolon
id|rpcauth_lookupcred
c_func
(paren
id|task
)paren
suffix:semicolon
multiline_comment|/* Obtain user creds */
r_if
c_cond
(paren
id|task-&gt;tk_status
OL
l_int|0
)paren
r_goto
id|out_req
suffix:semicolon
multiline_comment|/* Put the task on inode&squot;s writeback request list. */
id|wreq-&gt;wb_dentry
op_assign
id|dentry
suffix:semicolon
id|wreq-&gt;wb_inode
op_assign
id|inode
suffix:semicolon
id|wreq-&gt;wb_pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|wreq-&gt;wb_page
op_assign
id|page
suffix:semicolon
id|wreq-&gt;wb_offset
op_assign
id|offset
suffix:semicolon
id|wreq-&gt;wb_bytes
op_assign
id|bytes
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|page-&gt;count
)paren
suffix:semicolon
id|append_write_request
c_func
(paren
op_amp
id|NFS_WRITEBACK
c_func
(paren
id|inode
)paren
comma
id|wreq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_write_requests
op_increment
OG
id|NFS_WRITEBACK_MAX
op_star
l_int|3
op_div
l_int|4
)paren
id|rpc_wake_up_next
c_func
(paren
op_amp
id|write_queue
)paren
suffix:semicolon
r_return
id|wreq
suffix:semicolon
id|out_req
suffix:colon
id|rpc_release_task
c_func
(paren
id|task
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|wreq
)paren
suffix:semicolon
id|out_fail
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Schedule a writeback RPC call.&n; * If the server is congested, don&squot;t add to our backlog of queued&n; * requests but call it synchronously.&n; * The function returns true if the page has been unlocked as the&n; * consequence of a synchronous write call.&n; *&n; * FIXME: Here we could walk the inode&squot;s lock list to see whether the&n; * page we&squot;re currently writing to has been write-locked by the caller.&n; * If it is, we could schedule an async write request with a long&n; * delay in order to avoid writing back the page until the lock is&n; * released.&n; */
r_static
r_inline
r_int
DECL|function|schedule_write_request
id|schedule_write_request
c_func
(paren
r_struct
id|nfs_wreq
op_star
id|req
comma
r_int
id|sync
)paren
(brace
r_struct
id|rpc_task
op_star
id|task
op_assign
op_amp
id|req-&gt;wb_task
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|req-&gt;wb_inode
suffix:semicolon
r_if
c_cond
(paren
id|NFS_CONGESTED
c_func
(paren
id|inode
)paren
op_logical_or
id|nr_write_requests
op_ge
id|NFS_WRITEBACK_MAX
)paren
id|sync
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sync
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFS: %4d schedule_write_request (sync)&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
multiline_comment|/* Page is already locked */
id|req-&gt;wb_flags
op_or_assign
id|NFS_WRITE_LOCKED
suffix:semicolon
id|rpc_execute
c_func
(paren
id|task
)paren
suffix:semicolon
)brace
r_else
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFS: %4d schedule_write_request (async)&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|task-&gt;tk_flags
op_or_assign
id|RPC_TASK_ASYNC
suffix:semicolon
id|task-&gt;tk_timeout
op_assign
id|NFS_WRITEBACK_DELAY
suffix:semicolon
id|rpc_sleep_on
c_func
(paren
op_amp
id|write_queue
comma
id|task
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_return
id|sync
op_eq
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for request to complete&n; * This is almost a copy of __wait_on_page&n; */
r_static
r_inline
r_int
DECL|function|wait_on_write_request
id|wait_on_write_request
c_func
(paren
r_struct
id|nfs_wreq
op_star
id|req
)paren
(brace
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|req-&gt;wb_page
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|page-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|page-&gt;count
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|current-&gt;state
op_assign
id|IS_SOFT
ques
c_cond
id|TASK_INTERRUPTIBLE
suffix:colon
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
r_break
suffix:semicolon
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_if
c_cond
(paren
id|IS_SOFT
op_logical_and
id|signalled
c_func
(paren
)paren
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|page-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
multiline_comment|/* N.B. page may have been unused, so we must use free_page() */
id|free_page
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Write a page to the server. This will be used for NFS swapping only&n; * (for now), and we currently do this synchronously only.&n; */
r_int
DECL|function|nfs_writepage
id|nfs_writepage
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_return
id|nfs_writepage_sync
c_func
(paren
id|dentry
comma
id|dentry-&gt;d_inode
comma
id|page
comma
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update and possibly write a cached page of an NFS file.&n; *&n; * XXX: Keep an eye on generic_file_read to make sure it doesn&squot;t do bad&n; * things with a page scheduled for an RPC call (e.g. invalidate it).&n; */
r_int
DECL|function|nfs_updatepage
id|nfs_updatepage
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|page
op_star
id|page
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|count
comma
r_int
id|sync
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|u8
op_star
id|page_addr
op_assign
(paren
id|u8
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
r_struct
id|nfs_wreq
op_star
id|req
suffix:semicolon
r_int
id|status
op_assign
l_int|0
comma
id|page_locked
op_assign
l_int|1
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS:      nfs_updatepage(%s/%s %d@%ld, sync=%d)&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|count
comma
id|page-&gt;offset
op_plus
id|offset
comma
id|sync
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|PG_locked
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Try to find a corresponding request on the writeback queue.&n;&t; * If there is one, we can be sure that this request is not&n;&t; * yet being processed, because we hold a lock on the page.&n;&t; *&n;&t; * If the request was created by us, update it. Otherwise,&n;&t; * transfer the page lock and flush out the dirty page now.&n;&t; * After returning, generic_file_write will wait on the&n;&t; * page and retry the update.&n;&t; */
r_if
c_cond
(paren
(paren
id|req
op_assign
id|find_write_request
c_func
(paren
id|inode
comma
id|page
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|update_write_request
c_func
(paren
id|req
comma
id|offset
comma
id|count
)paren
)paren
(brace
multiline_comment|/* N.B. check for a fault here and cancel the req */
id|copy_from_user
c_func
(paren
id|page_addr
op_plus
id|offset
comma
id|buffer
comma
id|count
)paren
suffix:semicolon
r_goto
id|updated
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;NFS:      wake up conflicting write request.&bslash;n&quot;
)paren
suffix:semicolon
id|transfer_page_lock
c_func
(paren
id|req
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Copy data to page buffer. */
id|status
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|page_addr
op_plus
id|offset
comma
id|buffer
comma
id|count
)paren
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/* If wsize is smaller than page size, update and write&n;&t; * page synchronously.&n;&t; */
r_if
c_cond
(paren
id|NFS_SERVER
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|wsize
OL
id|PAGE_SIZE
)paren
r_return
id|nfs_writepage_sync
c_func
(paren
id|dentry
comma
id|inode
comma
id|page
comma
id|offset
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* Create the write request. */
id|status
op_assign
op_minus
id|ENOBUFS
suffix:semicolon
id|req
op_assign
id|create_write_request
c_func
(paren
id|dentry
comma
id|inode
comma
id|page
comma
id|offset
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/* Schedule request */
id|page_locked
op_assign
id|schedule_write_request
c_func
(paren
id|req
comma
id|sync
)paren
suffix:semicolon
id|updated
suffix:colon
multiline_comment|/*&n;&t; * If we wrote up to the end of the chunk, transmit request now.&n;&t; * We should be a bit more intelligent about detecting whether a&n;&t; * process accesses the file sequentially or not.&n;&t; */
r_if
c_cond
(paren
id|page_locked
op_logical_and
(paren
id|offset
op_plus
id|count
op_ge
id|PAGE_SIZE
op_logical_or
id|sync
)paren
)paren
id|req-&gt;wb_flags
op_or_assign
id|NFS_WRITE_WANTLOCK
suffix:semicolon
multiline_comment|/* If the page was written synchronously, return any error that&n;&t; * may have happened; otherwise return the write count. */
r_if
c_cond
(paren
id|page_locked
op_logical_or
(paren
id|status
op_assign
id|nfs_write_error
c_func
(paren
id|inode
)paren
)paren
op_ge
l_int|0
)paren
id|status
op_assign
id|count
suffix:semicolon
id|done
suffix:colon
multiline_comment|/* Unlock page and wake up anyone sleeping on it */
r_if
c_cond
(paren
id|page_locked
)paren
(brace
r_if
c_cond
(paren
id|req
op_logical_and
id|WB_WANTLOCK
c_func
(paren
id|req
)paren
)paren
(brace
id|transfer_page_lock
c_func
(paren
id|req
)paren
suffix:semicolon
multiline_comment|/* rpc_execute(&amp;req-&gt;wb_task); */
r_if
c_cond
(paren
id|sync
)paren
(brace
multiline_comment|/* N.B. if signalled, result not ready? */
id|wait_on_write_request
c_func
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|count
op_assign
id|nfs_write_error
c_func
(paren
id|inode
)paren
)paren
OL
l_int|0
)paren
id|status
op_assign
id|count
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NFS: %s/%s write failed, clearing bit&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|PG_uptodate
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
)brace
id|nfs_unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
)brace
id|dprintk
c_func
(paren
l_string|&quot;NFS:      nfs_updatepage returns %d (isize %ld)&bslash;n&quot;
comma
id|status
comma
id|inode-&gt;i_size
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush out a dirty page.&n; */
r_static
r_void
DECL|function|nfs_flush_request
id|nfs_flush_request
c_func
(paren
r_struct
id|nfs_wreq
op_star
id|req
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
id|req-&gt;wb_page
suffix:semicolon
macro_line|#ifdef NFS_DEBUG_VERBOSE
r_if
c_cond
(paren
id|req-&gt;wb_inode
op_ne
id|page-&gt;inode
)paren
id|printk
c_func
(paren
l_string|&quot;NFS: inode %ld no longer has page %p&bslash;n&quot;
comma
id|req-&gt;wb_inode-&gt;i_ino
comma
id|page
)paren
suffix:semicolon
macro_line|#endif
id|dprintk
c_func
(paren
l_string|&quot;NFS:      nfs_flush_request(%s/%s, @%ld)&bslash;n&quot;
comma
id|req-&gt;wb_dentry-&gt;d_parent-&gt;d_name.name
comma
id|req-&gt;wb_dentry-&gt;d_name.name
comma
id|page-&gt;offset
)paren
suffix:semicolon
id|req-&gt;wb_flags
op_or_assign
id|NFS_WRITE_WANTLOCK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|PG_locked
comma
op_amp
id|page-&gt;flags
)paren
)paren
(brace
id|transfer_page_lock
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;NFS oops in %s: can&squot;t lock page!&bslash;n&quot;
comma
id|__FUNCTION__
)paren
suffix:semicolon
id|rpc_wake_up_task
c_func
(paren
op_amp
id|req-&gt;wb_task
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Flush writeback requests. See nfs_flush_dirty_pages for details.&n; */
r_static
r_struct
id|nfs_wreq
op_star
DECL|function|nfs_flush_pages
id|nfs_flush_pages
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|pid_t
id|pid
comma
id|off_t
id|offset
comma
id|off_t
id|len
comma
r_int
id|invalidate
)paren
(brace
r_struct
id|nfs_wreq
op_star
id|head
comma
op_star
id|req
comma
op_star
id|last
op_assign
l_int|NULL
suffix:semicolon
id|off_t
id|rqoffset
comma
id|rqend
comma
id|end
suffix:semicolon
id|end
op_assign
id|len
ques
c_cond
id|offset
op_plus
id|len
suffix:colon
l_int|0x7fffffffUL
suffix:semicolon
id|req
op_assign
id|head
op_assign
id|NFS_WRITEBACK
c_func
(paren
id|inode
)paren
suffix:semicolon
r_while
c_loop
(paren
id|req
op_ne
l_int|NULL
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFS: %4d nfs_flush inspect %x/%ld @%ld fl %x&bslash;n&quot;
comma
id|req-&gt;wb_task.tk_pid
comma
id|req-&gt;wb_inode-&gt;i_dev
comma
id|req-&gt;wb_inode-&gt;i_ino
comma
id|req-&gt;wb_page-&gt;offset
comma
id|req-&gt;wb_flags
)paren
suffix:semicolon
id|rqoffset
op_assign
id|req-&gt;wb_page-&gt;offset
op_plus
id|req-&gt;wb_offset
suffix:semicolon
id|rqend
op_assign
id|rqoffset
op_plus
id|req-&gt;wb_bytes
suffix:semicolon
r_if
c_cond
(paren
id|rqoffset
OL
id|end
op_logical_and
id|offset
OL
id|rqend
op_logical_and
(paren
id|pid
op_eq
l_int|0
op_logical_or
id|req-&gt;wb_pid
op_eq
id|pid
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|WB_INPROGRESS
c_func
(paren
id|req
)paren
op_logical_and
op_logical_neg
id|WB_HAVELOCK
c_func
(paren
id|req
)paren
)paren
(brace
macro_line|#ifdef NFS_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;nfs_flush: flushing inode=%ld, %d @ %lu&bslash;n&quot;
comma
id|req-&gt;wb_inode-&gt;i_ino
comma
id|req-&gt;wb_bytes
comma
id|rqoffset
)paren
suffix:semicolon
macro_line|#endif
id|nfs_flush_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
id|last
op_assign
id|req
suffix:semicolon
)brace
r_if
c_cond
(paren
id|invalidate
)paren
id|req-&gt;wb_flags
op_or_assign
id|NFS_WRITE_INVALIDATE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|req
op_assign
id|WB_NEXT
c_func
(paren
id|req
)paren
)paren
op_eq
id|head
)paren
r_break
suffix:semicolon
)brace
r_return
id|last
suffix:semicolon
)brace
multiline_comment|/*&n; * Cancel all writeback requests, both pending and in progress.&n; *&n; * N.B. This doesn&squot;t seem to wake up the tasks -- are we sure&n; * they will eventually complete? Also, this could overwrite a&n; * failed status code from an already-completed task.&n; */
r_static
r_void
DECL|function|nfs_cancel_dirty
id|nfs_cancel_dirty
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|pid_t
id|pid
)paren
(brace
r_struct
id|nfs_wreq
op_star
id|head
comma
op_star
id|req
suffix:semicolon
id|req
op_assign
id|head
op_assign
id|NFS_WRITEBACK
c_func
(paren
id|inode
)paren
suffix:semicolon
r_while
c_loop
(paren
id|req
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* N.B. check for task already finished? */
r_if
c_cond
(paren
id|pid
op_eq
l_int|0
op_logical_or
id|req-&gt;wb_pid
op_eq
id|pid
)paren
(brace
id|req-&gt;wb_flags
op_or_assign
id|NFS_WRITE_CANCELLED
suffix:semicolon
id|rpc_exit
c_func
(paren
op_amp
id|req-&gt;wb_task
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|req
op_assign
id|WB_NEXT
c_func
(paren
id|req
)paren
)paren
op_eq
id|head
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Flush out all dirty pages belonging to a certain user process and&n; * maybe wait for the RPC calls to complete.&n; *&n; * Another purpose of this function is sync()ing a file range before a&n; * write lock is released. This is what offset and length are for, even if&n; * this isn&squot;t used by the nlm module yet.&n; */
r_int
DECL|function|nfs_flush_dirty_pages
id|nfs_flush_dirty_pages
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|pid_t
id|pid
comma
id|off_t
id|offset
comma
id|off_t
id|len
)paren
(brace
r_struct
id|nfs_wreq
op_star
id|last
op_assign
l_int|NULL
suffix:semicolon
r_int
id|result
op_assign
l_int|0
comma
id|cancel
op_assign
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS:      flush_dirty_pages(%x/%ld for pid %d %ld/%ld)&bslash;n&quot;
comma
id|inode-&gt;i_dev
comma
id|inode-&gt;i_ino
comma
id|current-&gt;pid
comma
id|offset
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_SOFT
op_logical_and
id|signalled
c_func
(paren
)paren
)paren
(brace
id|nfs_cancel_dirty
c_func
(paren
id|inode
comma
id|pid
)paren
suffix:semicolon
id|cancel
op_assign
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|IS_SOFT
op_logical_and
id|signalled
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cancel
)paren
id|nfs_cancel_dirty
c_func
(paren
id|inode
comma
id|pid
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Flush all pending writes for the pid and file region */
id|last
op_assign
id|nfs_flush_pages
c_func
(paren
id|inode
comma
id|pid
comma
id|offset
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
id|wait_on_write_request
c_func
(paren
id|last
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush out any pending write requests and flag that they be discarded&n; * after the write is complete.&n; *&n; * This function is called from nfs_refresh_inode just before it calls&n; * invalidate_inode_pages. After nfs_flush_pages returns, we can be sure&n; * that all dirty pages are locked, so that invalidate_inode_pages does&n; * not throw away any dirty pages.&n; */
r_void
DECL|function|nfs_invalidate_pages
id|nfs_invalidate_pages
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFS:      nfs_invalidate_pages(%x/%ld)&bslash;n&quot;
comma
id|inode-&gt;i_dev
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
id|nfs_flush_pages
c_func
(paren
id|inode
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Cancel any pending write requests after a given offset&n; * (called from nfs_notify_change).&n; */
r_int
DECL|function|nfs_truncate_dirty_pages
id|nfs_truncate_dirty_pages
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|offset
)paren
(brace
r_struct
id|nfs_wreq
op_star
id|req
comma
op_star
id|head
suffix:semicolon
r_int
r_int
id|rqoffset
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS:      truncate_dirty_pages(%x/%ld, %ld)&bslash;n&quot;
comma
id|inode-&gt;i_dev
comma
id|inode-&gt;i_ino
comma
id|offset
)paren
suffix:semicolon
id|req
op_assign
id|head
op_assign
id|NFS_WRITEBACK
c_func
(paren
id|inode
)paren
suffix:semicolon
r_while
c_loop
(paren
id|req
op_ne
l_int|NULL
)paren
(brace
id|rqoffset
op_assign
id|req-&gt;wb_page-&gt;offset
op_plus
id|req-&gt;wb_offset
suffix:semicolon
r_if
c_cond
(paren
id|rqoffset
op_ge
id|offset
)paren
(brace
id|req-&gt;wb_flags
op_or_assign
id|NFS_WRITE_CANCELLED
suffix:semicolon
id|rpc_exit
c_func
(paren
op_amp
id|req-&gt;wb_task
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rqoffset
op_plus
id|req-&gt;wb_bytes
op_ge
id|offset
)paren
(brace
id|req-&gt;wb_bytes
op_assign
id|offset
op_minus
id|rqoffset
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|req
op_assign
id|WB_NEXT
c_func
(paren
id|req
)paren
)paren
op_eq
id|head
)paren
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Check if a previous write operation returned an error&n; */
r_int
DECL|function|nfs_check_error
id|nfs_check_error
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|nfs_wreq
op_star
id|req
suffix:semicolon
r_int
id|status
op_assign
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;nfs:      checking for write error inode %04x/%ld&bslash;n&quot;
comma
id|inode-&gt;i_dev
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
id|req
op_assign
id|find_failed_request
c_func
(paren
id|inode
comma
id|current-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;nfs: write error %d inode %04x/%ld&bslash;n&quot;
comma
id|req-&gt;wb_task.tk_status
comma
id|inode-&gt;i_dev
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
id|status
op_assign
id|req-&gt;wb_task.tk_status
suffix:semicolon
id|remove_failed_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * The following procedures make up the writeback finite state machinery:&n; *&n; * 1.&t;Try to lock the page if not yet locked by us,&n; *&t;set up the RPC call info, and pass to the call FSM.&n; */
r_static
r_void
DECL|function|nfs_wback_lock
id|nfs_wback_lock
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|nfs_wreq
op_star
id|req
op_assign
(paren
r_struct
id|nfs_wreq
op_star
)paren
id|task-&gt;tk_calldata
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|req-&gt;wb_page
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
op_assign
id|req-&gt;wb_dentry
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS: %4d nfs_wback_lock (%s/%s, status=%d flags=%x)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|task-&gt;tk_status
comma
id|req-&gt;wb_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|WB_HAVELOCK
c_func
(paren
id|req
)paren
)paren
id|req-&gt;wb_flags
op_or_assign
id|NFS_WRITE_WANTLOCK
suffix:semicolon
r_if
c_cond
(paren
id|WB_WANTLOCK
c_func
(paren
id|req
)paren
op_logical_and
id|test_and_set_bit
c_func
(paren
id|PG_locked
comma
op_amp
id|page-&gt;flags
)paren
)paren
r_goto
id|out_locked
suffix:semicolon
id|req-&gt;wb_flags
op_and_assign
op_complement
id|NFS_WRITE_WANTLOCK
suffix:semicolon
id|req-&gt;wb_flags
op_or_assign
id|NFS_WRITE_LOCKED
suffix:semicolon
id|task-&gt;tk_status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;wb_args
op_eq
l_int|0
)paren
(brace
r_int
id|size
op_assign
r_sizeof
(paren
r_struct
id|nfs_writeargs
)paren
op_plus
r_sizeof
(paren
r_struct
id|nfs_fattr
)paren
suffix:semicolon
r_void
op_star
id|ptr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ptr
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_goto
id|out_no_args
suffix:semicolon
id|req-&gt;wb_args
op_assign
(paren
r_struct
id|nfs_writeargs
op_star
)paren
id|ptr
suffix:semicolon
id|req-&gt;wb_fattr
op_assign
(paren
r_struct
id|nfs_fattr
op_star
)paren
(paren
id|req-&gt;wb_args
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Setup the task struct for a writeback call */
id|req-&gt;wb_args-&gt;fh
op_assign
id|NFS_FH
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|req-&gt;wb_args-&gt;offset
op_assign
id|page-&gt;offset
op_plus
id|req-&gt;wb_offset
suffix:semicolon
id|req-&gt;wb_args-&gt;count
op_assign
id|req-&gt;wb_bytes
suffix:semicolon
id|req-&gt;wb_args-&gt;buffer
op_assign
(paren
r_void
op_star
)paren
(paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|req-&gt;wb_offset
)paren
suffix:semicolon
id|rpc_call_setup
c_func
(paren
id|task
comma
id|NFSPROC_WRITE
comma
id|req-&gt;wb_args
comma
id|req-&gt;wb_fattr
comma
l_int|0
)paren
suffix:semicolon
id|req-&gt;wb_flags
op_or_assign
id|NFS_WRITE_INPROGRESS
suffix:semicolon
r_return
suffix:semicolon
id|out_locked
suffix:colon
id|printk
c_func
(paren
l_string|&quot;NFS: page already locked in writeback_lock!&bslash;n&quot;
)paren
suffix:semicolon
id|task-&gt;tk_timeout
op_assign
l_int|2
op_star
id|HZ
suffix:semicolon
id|rpc_sleep_on
c_func
(paren
op_amp
id|write_queue
comma
id|task
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_return
suffix:semicolon
id|out_no_args
suffix:colon
id|printk
c_func
(paren
l_string|&quot;NFS: can&squot;t alloc args, sleeping&bslash;n&quot;
)paren
suffix:semicolon
id|task-&gt;tk_timeout
op_assign
id|HZ
suffix:semicolon
id|rpc_sleep_on
c_func
(paren
op_amp
id|write_queue
comma
id|task
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * 2.&t;Collect the result&n; */
r_static
r_void
DECL|function|nfs_wback_result
id|nfs_wback_result
c_func
(paren
r_struct
id|rpc_task
op_star
id|task
)paren
(brace
r_struct
id|nfs_wreq
op_star
id|req
op_assign
(paren
r_struct
id|nfs_wreq
op_star
)paren
id|task-&gt;tk_calldata
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|req-&gt;wb_inode
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|req-&gt;wb_page
suffix:semicolon
r_int
id|status
op_assign
id|task-&gt;tk_status
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;NFS: %4d nfs_wback_result (%s/%s, status=%d, flags=%x)&bslash;n&quot;
comma
id|task-&gt;tk_pid
comma
id|req-&gt;wb_dentry-&gt;d_parent-&gt;d_name.name
comma
id|req-&gt;wb_dentry-&gt;d_name.name
comma
id|status
comma
id|req-&gt;wb_flags
)paren
suffix:semicolon
multiline_comment|/* Set the WRITE_COMPLETE flag, but leave INPROGRESS set */
id|req-&gt;wb_flags
op_or_assign
id|NFS_WRITE_COMPLETE
suffix:semicolon
r_if
c_cond
(paren
id|status
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * An error occurred. Report the error back to the&n;&t;&t; * application by adding the request to the failed&n;&t;&t; * requests list.&n;&t;&t; */
r_if
c_cond
(paren
id|find_failed_request
c_func
(paren
id|inode
comma
id|req-&gt;wb_pid
)paren
)paren
id|status
op_assign
l_int|0
suffix:semicolon
id|clear_bit
c_func
(paren
id|PG_uptodate
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|WB_CANCELLED
c_func
(paren
id|req
)paren
)paren
(brace
r_struct
id|nfs_fattr
op_star
id|fattr
op_assign
id|req-&gt;wb_fattr
suffix:semicolon
multiline_comment|/* Update attributes as result of writeback. &n;&t;&t; * Beware: when UDP replies arrive out of order, we&n;&t;&t; * may end up overwriting a previous, bigger file size.&n;&t;&t; */
r_if
c_cond
(paren
id|fattr-&gt;mtime.seconds
op_ge
id|inode-&gt;i_mtime
)paren
(brace
r_if
c_cond
(paren
id|fattr-&gt;size
OL
id|inode-&gt;i_size
)paren
id|fattr-&gt;size
op_assign
id|inode-&gt;i_size
suffix:semicolon
multiline_comment|/* possible Solaris 2.5 server bug workaround */
r_if
c_cond
(paren
id|inode-&gt;i_ino
op_eq
id|fattr-&gt;fileid
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We expect these values to change, and&n;&t;&t;&t;&t; * don&squot;t want to invalidate the caches.&n;&t;&t;&t;&t; */
id|inode-&gt;i_size
op_assign
id|fattr-&gt;size
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
id|fattr-&gt;mtime.seconds
suffix:semicolon
id|nfs_refresh_inode
c_func
(paren
id|inode
comma
id|fattr
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;nfs_wback_result: inode %ld, got %u?&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|fattr-&gt;fileid
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * This call might block, so we defer removing the request&n;&t; * from the inode&squot;s writeback list.&n;&t; */
id|rpc_release_task
c_func
(paren
id|task
)paren
suffix:semicolon
r_if
c_cond
(paren
id|WB_INVALIDATE
c_func
(paren
id|req
)paren
)paren
id|clear_bit
c_func
(paren
id|PG_uptodate
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|WB_HAVELOCK
c_func
(paren
id|req
)paren
)paren
id|nfs_unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;wb_args
)paren
(brace
id|kfree
c_func
(paren
id|req-&gt;wb_args
)paren
suffix:semicolon
id|req-&gt;wb_args
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now it&squot;s safe to remove the request from the inode&squot;s &n;&t; * writeback list and wake up any tasks sleeping on it.&n;&t; * If the request failed, add it to the failed list.&n;&t; */
id|remove_write_request
c_func
(paren
op_amp
id|NFS_WRITEBACK
c_func
(paren
id|inode
)paren
comma
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ge
l_int|0
)paren
id|kfree
c_func
(paren
id|req
)paren
suffix:semicolon
r_else
(brace
id|dprintk
c_func
(paren
l_string|&quot;NFS: %4d saving write failure code&bslash;n&quot;
comma
id|task-&gt;tk_pid
)paren
suffix:semicolon
id|append_failed_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
id|free_page
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
)paren
suffix:semicolon
id|nr_write_requests
op_decrement
suffix:semicolon
)brace
eof
