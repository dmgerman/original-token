multiline_comment|/*&n; *  linux/fs/nfs/nfsroot.c -- version 2.3&n; *&n; *  Copyright (C) 1995, 1996  Gero Kuhlmann &lt;gero@gkminix.han.de&gt;&n; *&n; *  For parts of this file:&n; *  Copyright (C) 1996  Martin Mares &lt;mj@k332.feld.cvut.cz&gt;&n; *&n; *  Allow an NFS filesystem to be mounted as root. The way this works is:&n; *     (1) Determine the local IP address via RARP or BOOTP or from the&n; *         kernel command line.&n; *     (2) Handle RPC negotiation with the system which replied to RARP or&n; *         was reported as a boot server by BOOTP or manually.&n; *     (3) The actual mounting is done later, when init() is running.&n; *&n; *&n; *&t;Changes:&n; *&n; *&t;Alan Cox&t;:&t;Removed get_address name clash with FPU.&n; *&t;Alan Cox&t;:&t;Reformatted a bit.&n; *&t;Gero Kuhlmann&t;:&t;Code cleanup&n; *&t;Michael Rausch  :&t;Fixed recognition of an incoming RARP answer.&n; *&t;Martin Mares&t;: (2.0)&t;Auto-configuration via BOOTP supported.&n; *&t;Martin Mares&t;:&t;Manual selection of interface &amp; BOOTP/RARP.&n; *&t;Martin Mares&t;:&t;Using network routes instead of host routes,&n; *&t;&t;&t;&t;allowing the default configuration to be used&n; *&t;&t;&t;&t;for normal operation of the host.&n; *&t;Martin Mares&t;:&t;Randomized timer with exponential backoff&n; *&t;&t;&t;&t;installed to minimize network congestion.&n; *&t;Martin Mares&t;:&t;Code cleanup.&n; *&t;Martin Mares&t;: (2.1)&t;BOOTP and RARP made configuration options.&n; *&t;Martin Mares&t;:&t;Server hostname generation fixed.&n; *&t;Gerd Knorr&t;:&t;Fixed wired inode handling&n; *&t;Martin Mares&t;: (2.2)&t;&quot;0.0.0.0&quot; addresses from command line ignored.&n; *&t;Martin Mares&t;:&t;RARP replies not tested for server address.&n; *&t;Gero Kuhlmann&t;: (2.3) Some bug fixes and code cleanup again (please&n; *&t;&t;&t;&t;send me your new patches _before_ bothering&n; *&t;&t;&t;&t;Linus so that I don&squot; always have to cleanup&n; *&t;&t;&t;&t;_afterwards_ - thanks)&n; *&t;Gero Kuhlmann&t;:&t;Last changes of Martin Mares undone.&n; *&t;Gero Kuhlmann&t;: &t;RARP replies are tested for specified server&n; *&t;&t;&t;&t;again. However, it&squot;s now possible to have&n; *&t;&t;&t;&t;different RARP and NFS servers.&n; *&t;Gero Kuhlmann&t;:&t;&quot;0.0.0.0&quot; addresses from command line are&n; *&t;&t;&t;&t;now mapped to INADDR_NONE.&n; *&t;Gero Kuhlmann&t;:&t;Fixed a bug which prevented BOOTP path name&n; *&t;&t;&t;&t;from being used (thanks to Leo Spiekman)&n; *&t;Andy Walker&t;:&t;Allow to specify the NFS server in nfs_root&n; *&t;&t;&t;&t;without giving a path name&n; *&t;Swen Th=FCmmler&t;:&t;Allow to specify the NFS options in nfs_root&n; *&t;&t;&t;&t;without giving a path name. Fix BOOTP request&n; *&t;&t;&t;&t;for domainname (domainname is NIS domain, not&n; *&t;&t;&t;&t;DNS domain!). Skip dummy devices for BOOTP.&n; *&t;Jacek Zapala&t;:&t;Fixed a bug which prevented server-ip address&n; *&t;&t;&t;&t;from nfsroot parameter from being used.&n; *&n; */
multiline_comment|/* Define this to allow debugging output */
DECL|macro|NFSROOT_DEBUG
macro_line|#undef NFSROOT_DEBUG
DECL|macro|NFSROOT_BOOTP_DEBUG
macro_line|#undef NFSROOT_BOOTP_DEBUG
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;asm/param.h&gt;
macro_line|#include &lt;linux/utsname.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/if.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#ifdef CONFIG_AX25
macro_line|#include &lt;net/ax25.h&gt;&t;/* For AX25_P_IP */
macro_line|#endif
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/route.h&gt;
macro_line|#include &lt;linux/nfs.h&gt;
macro_line|#include &lt;linux/nfs_fs.h&gt;
macro_line|#include &lt;linux/nfs_mount.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;net/sock.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
multiline_comment|/* Range of privileged ports */
DECL|macro|STARTPORT
mdefine_line|#define STARTPORT&t;600
DECL|macro|ENDPORT
mdefine_line|#define ENDPORT&t;&t;1023
DECL|macro|NPORTS
mdefine_line|#define NPORTS&t;&t;(ENDPORT - STARTPORT + 1)
multiline_comment|/* Define the timeout for waiting for a RARP/BOOTP reply */
DECL|macro|CONF_BASE_TIMEOUT
mdefine_line|#define CONF_BASE_TIMEOUT&t;(HZ*5)&t;/* Initial timeout: 5 seconds */
DECL|macro|CONF_RETRIES
mdefine_line|#define CONF_RETRIES&t; &t;10&t;/* 10 retries */
DECL|macro|CONF_TIMEOUT_RANDOM
mdefine_line|#define CONF_TIMEOUT_RANDOM&t;(HZ)&t;/* Maximum amount of randomization */
DECL|macro|CONF_TIMEOUT_MULT
mdefine_line|#define CONF_TIMEOUT_MULT&t;*5/4&t;/* Speed of timeout growth */
DECL|macro|CONF_TIMEOUT_MAX
mdefine_line|#define CONF_TIMEOUT_MAX&t;(HZ*30)&t;/* Maximum allowed timeout */
multiline_comment|/* List of open devices */
DECL|struct|open_dev
r_struct
id|open_dev
(brace
DECL|member|dev
r_struct
id|device
op_star
id|dev
suffix:semicolon
DECL|member|old_flags
r_int
r_int
id|old_flags
suffix:semicolon
DECL|member|next
r_struct
id|open_dev
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|open_base
r_static
r_struct
id|open_dev
op_star
id|open_base
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* IP configuration */
DECL|variable|root_dev
r_static
r_struct
id|device
op_star
id|root_dev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Device selected for booting */
DECL|variable|user_dev_name
r_static
r_char
id|user_dev_name
(braket
id|IFNAMSIZ
)braket
suffix:semicolon
multiline_comment|/* Name of user-selected boot device */
DECL|variable|myaddr
r_static
r_struct
id|sockaddr_in
id|myaddr
suffix:semicolon
multiline_comment|/* My IP address */
DECL|variable|server
r_static
r_struct
id|sockaddr_in
id|server
suffix:semicolon
multiline_comment|/* Server IP address */
DECL|variable|gateway
r_static
r_struct
id|sockaddr_in
id|gateway
suffix:semicolon
multiline_comment|/* Gateway IP address */
DECL|variable|netmask
r_static
r_struct
id|sockaddr_in
id|netmask
suffix:semicolon
multiline_comment|/* Netmask for local subnet */
multiline_comment|/* BOOTP/RARP variables */
DECL|variable|bootp_flag
r_static
r_int
id|bootp_flag
suffix:semicolon
multiline_comment|/* User said: Use BOOTP! */
DECL|variable|rarp_flag
r_static
r_int
id|rarp_flag
suffix:semicolon
multiline_comment|/* User said: Use RARP! */
DECL|variable|bootp_dev_count
r_static
r_int
id|bootp_dev_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Number of devices allowing BOOTP */
DECL|variable|rarp_dev_count
r_static
r_int
id|rarp_dev_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Number of devices allowing RARP */
DECL|variable|rarp_serv
r_static
r_struct
id|sockaddr_in
id|rarp_serv
suffix:semicolon
multiline_comment|/* IP address of RARP server */
macro_line|#if defined(CONFIG_RNFS_BOOTP) || defined(CONFIG_RNFS_RARP)
DECL|macro|CONFIG_RNFS_DYNAMIC
mdefine_line|#define CONFIG_RNFS_DYNAMIC&t;&t;/* Enable dynamic IP config */
DECL|variable|pkt_arrived
r_static
r_volatile
r_int
id|pkt_arrived
suffix:semicolon
multiline_comment|/* BOOTP/RARP packet detected */
DECL|macro|ARRIVED_BOOTP
mdefine_line|#define ARRIVED_BOOTP&t;1
DECL|macro|ARRIVED_RARP
mdefine_line|#define ARRIVED_RARP&t;2
macro_line|#endif
multiline_comment|/* NFS-related data */
DECL|variable|nfs_data
r_static
r_struct
id|nfs_mount_data
id|nfs_data
suffix:semicolon
multiline_comment|/* NFS mount info */
DECL|variable|nfs_path
r_static
r_char
id|nfs_path
(braket
id|NFS_MAXPATHLEN
)braket
op_assign
l_string|&quot;&quot;
suffix:semicolon
multiline_comment|/* Name of directory to mount */
DECL|variable|nfs_port
r_static
r_int
id|nfs_port
suffix:semicolon
multiline_comment|/* Port to connect to for NFS */
multiline_comment|/* Yes, we use sys_socket, but there&squot;s no include file for it */
r_extern
id|asmlinkage
r_int
id|sys_socket
c_func
(paren
r_int
id|family
comma
r_int
id|type
comma
r_int
id|protocol
)paren
suffix:semicolon
multiline_comment|/***************************************************************************&n;&n;&t;&t;&t;Device Handling Subroutines&n;&n; ***************************************************************************/
multiline_comment|/*&n; * Setup and initialize all network devices. If there is a user-preferred&n; * interface, ignore all other interfaces.&n; */
DECL|function|root_dev_open
r_static
r_int
id|root_dev_open
c_func
(paren
r_void
)paren
(brace
r_struct
id|open_dev
op_star
id|openp
comma
op_star
op_star
id|last
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_int
r_int
id|old_flags
suffix:semicolon
id|last
op_assign
op_amp
id|open_base
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;type
OL
id|ARPHRD_SLIP
op_logical_and
id|dev-&gt;family
op_eq
id|AF_INET
op_logical_and
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
(paren
id|IFF_LOOPBACK
op_or
id|IFF_POINTOPOINT
)paren
)paren
op_logical_and
(paren
l_int|0
op_ne
id|strncmp
c_func
(paren
id|dev-&gt;name
comma
l_string|&quot;dummy&quot;
comma
l_int|5
)paren
)paren
op_logical_and
(paren
op_logical_neg
id|user_dev_name
(braket
l_int|0
)braket
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|dev-&gt;name
comma
id|user_dev_name
)paren
)paren
)paren
(brace
multiline_comment|/* First up the interface */
id|old_flags
op_assign
id|dev-&gt;flags
suffix:semicolon
id|dev-&gt;flags
op_assign
id|IFF_UP
op_or
id|IFF_BROADCAST
op_or
id|IFF_RUNNING
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|old_flags
op_amp
id|IFF_UP
)paren
op_logical_and
id|dev_open
c_func
(paren
id|dev
)paren
)paren
(brace
id|dev-&gt;flags
op_assign
id|old_flags
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|openp
op_assign
(paren
r_struct
id|open_dev
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|open_dev
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|openp
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|openp-&gt;dev
op_assign
id|dev
suffix:semicolon
id|openp-&gt;old_flags
op_assign
id|old_flags
suffix:semicolon
op_star
id|last
op_assign
id|openp
suffix:semicolon
id|last
op_assign
op_amp
id|openp-&gt;next
suffix:semicolon
id|bootp_dev_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_NOARP
)paren
)paren
id|rarp_dev_count
op_increment
suffix:semicolon
macro_line|#ifdef NFSROOT_DEBUG
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Root-NFS: Opened %s&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
op_star
id|last
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bootp_dev_count
op_logical_and
op_logical_neg
id|rarp_dev_count
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Root-NFS: Unable to open at least one network device&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Restore the state of all devices. However, keep the root device open&n; *  for the upcoming mount.&n; */
DECL|function|root_dev_close
r_static
r_void
id|root_dev_close
c_func
(paren
r_void
)paren
(brace
r_struct
id|open_dev
op_star
id|openp
suffix:semicolon
r_struct
id|open_dev
op_star
id|nextp
suffix:semicolon
id|openp
op_assign
id|open_base
suffix:semicolon
r_while
c_loop
(paren
id|openp
op_ne
l_int|NULL
)paren
(brace
id|nextp
op_assign
id|openp-&gt;next
suffix:semicolon
id|openp-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|openp-&gt;dev
op_ne
id|root_dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|openp-&gt;old_flags
op_amp
id|IFF_UP
)paren
)paren
id|dev_close
c_func
(paren
id|openp-&gt;dev
)paren
suffix:semicolon
id|openp-&gt;dev-&gt;flags
op_assign
id|openp-&gt;old_flags
suffix:semicolon
)brace
id|kfree_s
c_func
(paren
id|openp
comma
r_sizeof
(paren
r_struct
id|open_dev
)paren
)paren
suffix:semicolon
id|openp
op_assign
id|nextp
suffix:semicolon
)brace
)brace
multiline_comment|/***************************************************************************&n;&n;&t;&t;&t;      RARP Subroutines&n;&n; ***************************************************************************/
macro_line|#ifdef CONFIG_RNFS_RARP
r_extern
r_void
id|arp_send
c_func
(paren
r_int
id|type
comma
r_int
id|ptype
comma
r_int
r_int
id|target_ip
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|src_ip
comma
r_int
r_char
op_star
id|dest_hw
comma
r_int
r_char
op_star
id|src_hw
comma
r_int
r_char
op_star
id|target_hw
)paren
suffix:semicolon
r_static
r_int
id|root_rarp_recv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|packet_type
op_star
id|pt
)paren
suffix:semicolon
DECL|variable|rarp_packet_type
r_static
r_struct
id|packet_type
id|rarp_packet_type
op_assign
(brace
l_int|0
comma
multiline_comment|/* Should be: __constant_htons(ETH_P_RARP)&n;&t;&t;&t;&t; * - but this _doesn&squot;t_ come out constant! */
l_int|NULL
comma
multiline_comment|/* Listen to all devices */
id|root_rarp_recv
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n; *  Register the packet type for RARP&n; */
DECL|function|root_rarp_open
r_static
r_void
id|root_rarp_open
c_func
(paren
r_void
)paren
(brace
id|rarp_packet_type.type
op_assign
id|htons
c_func
(paren
id|ETH_P_RARP
)paren
suffix:semicolon
id|dev_add_pack
c_func
(paren
op_amp
id|rarp_packet_type
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Deregister the RARP packet type&n; */
DECL|function|root_rarp_close
r_static
r_void
id|root_rarp_close
c_func
(paren
r_void
)paren
(brace
id|rarp_packet_type.type
op_assign
id|htons
c_func
(paren
id|ETH_P_RARP
)paren
suffix:semicolon
id|dev_remove_pack
c_func
(paren
op_amp
id|rarp_packet_type
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Receive RARP packets.&n; */
DECL|function|root_rarp_recv
r_static
r_int
id|root_rarp_recv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|arphdr
op_star
id|rarp
op_assign
(paren
r_struct
id|arphdr
op_star
)paren
id|skb-&gt;h.raw
suffix:semicolon
r_int
r_char
op_star
id|rarp_ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|rarp
op_plus
l_int|1
)paren
suffix:semicolon
r_int
r_int
id|sip
comma
id|tip
suffix:semicolon
r_int
r_char
op_star
id|sha
comma
op_star
id|tha
suffix:semicolon
multiline_comment|/* s for &quot;source&quot;, t for &quot;target&quot; */
multiline_comment|/* If this test doesn&squot;t pass, it&squot;s not IP, or we should ignore it anyway */
r_if
c_cond
(paren
id|rarp-&gt;ar_hln
op_ne
id|dev-&gt;addr_len
op_logical_or
id|dev-&gt;type
op_ne
id|ntohs
c_func
(paren
id|rarp-&gt;ar_hrd
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If it&squot;s not a RARP reply, delete it. */
r_if
c_cond
(paren
id|rarp-&gt;ar_op
op_ne
id|htons
c_func
(paren
id|ARPOP_RREPLY
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If it&squot;s not ethernet or AX25, delete it. */
r_if
c_cond
(paren
(paren
id|rarp-&gt;ar_pro
op_ne
id|htons
c_func
(paren
id|ETH_P_IP
)paren
op_logical_and
id|dev-&gt;type
op_ne
id|ARPHRD_AX25
)paren
op_logical_or
macro_line|#ifdef CONFIG_AX25
(paren
id|rarp-&gt;ar_pro
op_ne
id|htons
c_func
(paren
id|AX25_P_IP
)paren
op_logical_and
id|dev-&gt;type
op_eq
id|ARPHRD_AX25
)paren
op_logical_or
macro_line|#endif
id|rarp-&gt;ar_pln
op_ne
l_int|4
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Extract variable width fields */
id|sha
op_assign
id|rarp_ptr
suffix:semicolon
id|rarp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|sip
comma
id|rarp_ptr
comma
l_int|4
)paren
suffix:semicolon
id|rarp_ptr
op_add_assign
l_int|4
suffix:semicolon
id|tha
op_assign
id|rarp_ptr
suffix:semicolon
id|rarp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|tip
comma
id|rarp_ptr
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Discard packets which are not meant for us. */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|tha
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;addr_len
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Discard packets which are not from specified server. */
r_if
c_cond
(paren
id|rarp_flag
op_logical_and
op_logical_neg
id|bootp_flag
op_logical_and
id|rarp_serv.sin_addr.s_addr
op_ne
id|INADDR_NONE
op_logical_and
id|rarp_serv.sin_addr.s_addr
op_ne
id|sip
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The packet is what we were looking for. Setup the global&n;&t; * variables.&n;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_arrived
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pkt_arrived
op_assign
id|ARRIVED_RARP
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|root_dev
op_assign
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|myaddr.sin_addr.s_addr
op_eq
id|INADDR_NONE
)paren
(brace
id|myaddr.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
id|myaddr.sin_addr.s_addr
op_assign
id|tip
suffix:semicolon
)brace
r_if
c_cond
(paren
id|server.sin_addr.s_addr
op_eq
id|INADDR_NONE
)paren
(brace
id|server.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
id|server.sin_addr.s_addr
op_assign
id|sip
suffix:semicolon
)brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Send RARP request packet over all devices which allow RARP.&n; */
DECL|function|root_rarp_send
r_static
r_void
id|root_rarp_send
c_func
(paren
r_void
)paren
(brace
r_struct
id|open_dev
op_star
id|openp
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_int
id|num
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|openp
op_assign
id|open_base
suffix:semicolon
id|openp
op_ne
l_int|NULL
suffix:semicolon
id|openp
op_assign
id|openp-&gt;next
)paren
(brace
id|dev
op_assign
id|openp-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_NOARP
)paren
)paren
(brace
id|arp_send
c_func
(paren
id|ARPOP_RREQUEST
comma
id|ETH_P_RARP
comma
l_int|0
comma
id|dev
comma
l_int|0
comma
l_int|NULL
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;dev_addr
)paren
suffix:semicolon
id|num
op_increment
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/***************************************************************************&n;&n;&t;&t;&t;     BOOTP Subroutines&n;&n; ***************************************************************************/
macro_line|#ifdef CONFIG_RNFS_BOOTP
DECL|variable|bootp_dev
r_static
r_struct
id|device
op_star
id|bootp_dev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Device selected as best BOOTP target */
DECL|variable|bootp_xmit_fd
r_static
r_int
id|bootp_xmit_fd
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Socket descriptor for transmit */
DECL|variable|bootp_xmit_sock
r_static
r_struct
id|socket
op_star
id|bootp_xmit_sock
suffix:semicolon
multiline_comment|/* The socket itself */
DECL|variable|bootp_recv_fd
r_static
r_int
id|bootp_recv_fd
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Socket descriptor for receive */
DECL|variable|bootp_recv_sock
r_static
r_struct
id|socket
op_star
id|bootp_recv_sock
suffix:semicolon
multiline_comment|/* The socket itself */
DECL|struct|bootp_pkt
r_struct
id|bootp_pkt
(brace
multiline_comment|/* BOOTP packet format */
DECL|member|op
id|u8
id|op
suffix:semicolon
multiline_comment|/* 1=request, 2=reply */
DECL|member|htype
id|u8
id|htype
suffix:semicolon
multiline_comment|/* HW address type */
DECL|member|hlen
id|u8
id|hlen
suffix:semicolon
multiline_comment|/* HW address length */
DECL|member|hops
id|u8
id|hops
suffix:semicolon
multiline_comment|/* Used only by gateways */
DECL|member|xid
id|u32
id|xid
suffix:semicolon
multiline_comment|/* Transaction ID */
DECL|member|secs
id|u16
id|secs
suffix:semicolon
multiline_comment|/* Seconds since we started */
DECL|member|flags
id|u16
id|flags
suffix:semicolon
multiline_comment|/* Just what is says */
DECL|member|client_ip
id|u32
id|client_ip
suffix:semicolon
multiline_comment|/* Client&squot;s IP address if known */
DECL|member|your_ip
id|u32
id|your_ip
suffix:semicolon
multiline_comment|/* Assigned IP address */
DECL|member|server_ip
id|u32
id|server_ip
suffix:semicolon
multiline_comment|/* Server&squot;s IP address */
DECL|member|relay_ip
id|u32
id|relay_ip
suffix:semicolon
multiline_comment|/* IP address of BOOTP relay */
DECL|member|hw_addr
id|u8
id|hw_addr
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Client&squot;s HW address */
DECL|member|serv_name
id|u8
id|serv_name
(braket
l_int|64
)braket
suffix:semicolon
multiline_comment|/* Server host name */
DECL|member|boot_file
id|u8
id|boot_file
(braket
l_int|128
)braket
suffix:semicolon
multiline_comment|/* Name of boot file */
DECL|member|vendor_area
id|u8
id|vendor_area
(braket
l_int|128
)braket
suffix:semicolon
multiline_comment|/* Area for extensions */
)brace
suffix:semicolon
DECL|macro|BOOTP_REQUEST
mdefine_line|#define BOOTP_REQUEST 1
DECL|macro|BOOTP_REPLY
mdefine_line|#define BOOTP_REPLY 2
DECL|variable|xmit_bootp
r_static
r_struct
id|bootp_pkt
op_star
id|xmit_bootp
suffix:semicolon
multiline_comment|/* Packet being transmitted */
DECL|variable|recv_bootp
r_static
r_struct
id|bootp_pkt
op_star
id|recv_bootp
suffix:semicolon
multiline_comment|/* Packet being received */
DECL|variable|bootp_have_route
r_static
r_int
id|bootp_have_route
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* BOOTP route installed */
multiline_comment|/*&n; *  Free BOOTP packet buffers&n; */
DECL|function|root_free_bootp
r_static
r_void
id|root_free_bootp
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|xmit_bootp
)paren
(brace
id|kfree_s
c_func
(paren
id|xmit_bootp
comma
r_sizeof
(paren
r_struct
id|bootp_pkt
)paren
)paren
suffix:semicolon
id|xmit_bootp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|recv_bootp
)paren
(brace
id|kfree_s
c_func
(paren
id|recv_bootp
comma
r_sizeof
(paren
r_struct
id|bootp_pkt
)paren
)paren
suffix:semicolon
id|recv_bootp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  Allocate memory for BOOTP packet buffers&n; */
DECL|function|root_alloc_bootp
r_static
r_inline
r_int
id|root_alloc_bootp
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|xmit_bootp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|bootp_pkt
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_logical_or
op_logical_neg
(paren
id|recv_bootp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|bootp_pkt
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BOOTP: Out of memory!&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Create default route for BOOTP sending&n; */
DECL|function|root_add_bootp_route
r_static
r_int
id|root_add_bootp_route
c_func
(paren
r_void
)paren
(brace
r_struct
id|rtentry
id|route
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|route
comma
l_int|0
comma
r_sizeof
(paren
id|route
)paren
)paren
suffix:semicolon
id|route.rt_dev
op_assign
id|bootp_dev-&gt;name
suffix:semicolon
id|route.rt_mss
op_assign
id|bootp_dev-&gt;mtu
suffix:semicolon
id|route.rt_flags
op_assign
id|RTF_UP
suffix:semicolon
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
(paren
id|route.rt_dst
)paren
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
op_assign
l_int|0
suffix:semicolon
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
(paren
id|route.rt_dst
)paren
)paren
op_member_access_from_pointer
id|sin_family
op_assign
id|AF_INET
suffix:semicolon
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
(paren
id|route.rt_genmask
)paren
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
op_assign
l_int|0
suffix:semicolon
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
(paren
id|route.rt_genmask
)paren
)paren
op_member_access_from_pointer
id|sin_family
op_assign
id|AF_INET
suffix:semicolon
r_if
c_cond
(paren
id|ip_rt_new
c_func
(paren
op_amp
id|route
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;BOOTP: Adding of route failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|bootp_have_route
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Delete default route for BOOTP sending&n; */
DECL|function|root_del_bootp_route
r_static
r_int
id|root_del_bootp_route
c_func
(paren
r_void
)paren
(brace
r_struct
id|rtentry
id|route
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bootp_have_route
)paren
r_return
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|route
comma
l_int|0
comma
r_sizeof
(paren
id|route
)paren
)paren
suffix:semicolon
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
(paren
id|route.rt_dst
)paren
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
op_assign
l_int|0
suffix:semicolon
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
(paren
id|route.rt_genmask
)paren
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ip_rt_kill
c_func
(paren
op_amp
id|route
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;BOOTP: Deleting of route failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|bootp_have_route
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Open UDP socket.&n; */
DECL|function|root_open_udp_sock
r_static
r_int
id|root_open_udp_sock
c_func
(paren
r_int
op_star
id|fd
comma
r_struct
id|socket
op_star
op_star
id|sock
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
op_star
id|fd
op_assign
id|sys_socket
c_func
(paren
id|AF_INET
comma
id|SOCK_DGRAM
comma
id|IPPROTO_UDP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|fd
op_ge
l_int|0
)paren
(brace
id|file
op_assign
id|current-&gt;files-&gt;fd
(braket
op_star
id|fd
)braket
suffix:semicolon
id|inode
op_assign
id|file-&gt;f_inode
suffix:semicolon
op_star
id|sock
op_assign
op_amp
id|inode-&gt;u.socket_i
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;BOOTP: Cannot open UDP socket!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *  Connect UDP socket.&n; */
DECL|function|root_connect_udp_sock
r_static
r_int
id|root_connect_udp_sock
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
id|u32
id|addr
comma
id|u16
id|port
)paren
(brace
r_struct
id|sockaddr_in
id|sa
suffix:semicolon
r_int
id|result
suffix:semicolon
id|sa.sin_family
op_assign
id|AF_INET
suffix:semicolon
id|sa.sin_addr.s_addr
op_assign
id|htonl
c_func
(paren
id|addr
)paren
suffix:semicolon
id|sa.sin_port
op_assign
id|htons
c_func
(paren
id|port
)paren
suffix:semicolon
id|result
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|connect
c_func
(paren
id|sock
comma
(paren
r_struct
id|sockaddr
op_star
)paren
op_amp
id|sa
comma
r_sizeof
(paren
id|sa
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;BOOTP: connect() failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Bind UDP socket.&n; */
DECL|function|root_bind_udp_sock
r_static
r_int
id|root_bind_udp_sock
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
id|u32
id|addr
comma
id|u16
id|port
)paren
(brace
r_struct
id|sockaddr_in
id|sa
suffix:semicolon
r_int
id|result
suffix:semicolon
id|sa.sin_family
op_assign
id|AF_INET
suffix:semicolon
id|sa.sin_addr.s_addr
op_assign
id|htonl
c_func
(paren
id|addr
)paren
suffix:semicolon
id|sa.sin_port
op_assign
id|htons
c_func
(paren
id|port
)paren
suffix:semicolon
id|result
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|bind
c_func
(paren
id|sock
comma
(paren
r_struct
id|sockaddr
op_star
)paren
op_amp
id|sa
comma
r_sizeof
(paren
id|sa
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;BOOTP: bind() failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Send UDP packet.&n; */
DECL|function|root_send_udp
r_static
r_inline
r_int
id|root_send_udp
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
id|u32
id|oldfs
suffix:semicolon
r_int
id|result
suffix:semicolon
r_struct
id|msghdr
id|msg
suffix:semicolon
r_struct
id|iovec
id|iov
suffix:semicolon
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|get_ds
c_func
(paren
)paren
)paren
suffix:semicolon
id|iov.iov_base
op_assign
id|buf
suffix:semicolon
id|iov.iov_len
op_assign
id|size
suffix:semicolon
id|msg.msg_name
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_iov
op_assign
op_amp
id|iov
suffix:semicolon
id|msg.msg_iovlen
op_assign
l_int|1
suffix:semicolon
id|msg.msg_control
op_assign
l_int|NULL
suffix:semicolon
id|result
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|sendmsg
c_func
(paren
id|sock
comma
op_amp
id|msg
comma
id|size
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
r_return
(paren
id|result
op_ne
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Try to receive UDP packet.&n; */
DECL|function|root_recv_udp
r_static
r_inline
r_int
id|root_recv_udp
c_func
(paren
r_struct
id|socket
op_star
id|sock
comma
r_void
op_star
id|buf
comma
r_int
id|size
)paren
(brace
id|u32
id|oldfs
suffix:semicolon
r_int
id|result
suffix:semicolon
r_struct
id|msghdr
id|msg
suffix:semicolon
r_struct
id|iovec
id|iov
suffix:semicolon
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|get_ds
c_func
(paren
)paren
)paren
suffix:semicolon
id|iov.iov_base
op_assign
id|buf
suffix:semicolon
id|iov.iov_len
op_assign
id|size
suffix:semicolon
id|msg.msg_name
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_iov
op_assign
op_amp
id|iov
suffix:semicolon
id|msg.msg_iovlen
op_assign
l_int|1
suffix:semicolon
id|msg.msg_control
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_namelen
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|recvmsg
c_func
(paren
id|sock
comma
op_amp
id|msg
comma
id|size
comma
id|O_NONBLOCK
comma
l_int|0
comma
op_amp
id|msg.msg_namelen
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; *  Initialize BOOTP extension fields in the request.&n; */
DECL|function|root_bootp_init_ext
r_static
r_void
id|root_bootp_init_ext
c_func
(paren
id|u8
op_star
id|e
)paren
(brace
op_star
id|e
op_increment
op_assign
l_int|99
suffix:semicolon
multiline_comment|/* RFC1048 Magic Cookie */
op_star
id|e
op_increment
op_assign
l_int|130
suffix:semicolon
op_star
id|e
op_increment
op_assign
l_int|83
suffix:semicolon
op_star
id|e
op_increment
op_assign
l_int|99
suffix:semicolon
op_star
id|e
op_increment
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Subnet mask request */
op_star
id|e
op_increment
op_assign
l_int|4
suffix:semicolon
id|e
op_add_assign
l_int|4
suffix:semicolon
op_star
id|e
op_increment
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* Default gateway request */
op_star
id|e
op_increment
op_assign
l_int|4
suffix:semicolon
id|e
op_add_assign
l_int|4
suffix:semicolon
op_star
id|e
op_increment
op_assign
l_int|12
suffix:semicolon
multiline_comment|/* Host name request */
op_star
id|e
op_increment
op_assign
l_int|32
suffix:semicolon
id|e
op_add_assign
l_int|32
suffix:semicolon
op_star
id|e
op_increment
op_assign
l_int|40
suffix:semicolon
multiline_comment|/* NIS Domain name request */
op_star
id|e
op_increment
op_assign
l_int|32
suffix:semicolon
id|e
op_add_assign
l_int|32
suffix:semicolon
op_star
id|e
op_increment
op_assign
l_int|17
suffix:semicolon
multiline_comment|/* Boot path */
op_star
id|e
op_increment
op_assign
l_int|32
suffix:semicolon
id|e
op_add_assign
l_int|32
suffix:semicolon
op_star
id|e
op_assign
l_int|255
suffix:semicolon
multiline_comment|/* End of the list */
)brace
multiline_comment|/*&n; *  Deinitialize the BOOTP mechanism.&n; */
DECL|function|root_bootp_close
r_static
r_void
id|root_bootp_close
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|bootp_xmit_fd
op_ne
op_minus
l_int|1
)paren
id|sys_close
c_func
(paren
id|bootp_xmit_fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bootp_recv_fd
op_ne
op_minus
l_int|1
)paren
id|sys_close
c_func
(paren
id|bootp_recv_fd
)paren
suffix:semicolon
id|root_del_bootp_route
c_func
(paren
)paren
suffix:semicolon
id|root_free_bootp
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Initialize the BOOTP mechanism.&n; */
DECL|function|root_bootp_open
r_static
r_int
id|root_bootp_open
c_func
(paren
r_void
)paren
(brace
r_struct
id|open_dev
op_star
id|openp
suffix:semicolon
r_struct
id|device
op_star
id|dev
comma
op_star
id|best_dev
suffix:semicolon
multiline_comment|/*&n;&t; * Select the best interface for BOOTP. We try to select a first&n;&t; * Ethernet-like interface. It&squot;s shame I know no simple way how to send&n;&t; * BOOTP&squot;s to all interfaces, but it doesn&squot;t apply to usual diskless&n;&t; * stations as they don&squot;t have multiple interfaces.&n;&t; */
id|best_dev
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|openp
op_assign
id|open_base
suffix:semicolon
id|openp
op_ne
l_int|NULL
suffix:semicolon
id|openp
op_assign
id|openp-&gt;next
)paren
(brace
id|dev
op_assign
id|openp-&gt;dev
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;flags
op_amp
id|IFF_BROADCAST
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|best_dev
op_logical_or
(paren
(paren
id|best_dev-&gt;flags
op_amp
id|IFF_NOARP
)paren
op_logical_and
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
id|IFF_NOARP
)paren
)paren
)paren
id|best_dev
op_assign
id|dev
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|best_dev
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;BOOTP: This cannot happen!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|bootp_dev
op_assign
id|best_dev
suffix:semicolon
multiline_comment|/* Allocate memory for BOOTP packets */
r_if
c_cond
(paren
id|root_alloc_bootp
c_func
(paren
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Construct BOOTP request */
id|memset
c_func
(paren
id|xmit_bootp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|bootp_pkt
)paren
)paren
suffix:semicolon
id|xmit_bootp-&gt;op
op_assign
id|BOOTP_REQUEST
suffix:semicolon
id|get_random_bytes
c_func
(paren
op_amp
id|xmit_bootp-&gt;xid
comma
r_sizeof
(paren
id|xmit_bootp-&gt;xid
)paren
)paren
suffix:semicolon
id|xmit_bootp-&gt;htype
op_assign
id|best_dev-&gt;type
suffix:semicolon
id|xmit_bootp-&gt;hlen
op_assign
id|best_dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
id|xmit_bootp-&gt;hw_addr
comma
id|best_dev-&gt;dev_addr
comma
id|best_dev-&gt;addr_len
)paren
suffix:semicolon
id|root_bootp_init_ext
c_func
(paren
id|xmit_bootp-&gt;vendor_area
)paren
suffix:semicolon
macro_line|#ifdef NFSROOT_BOOTP_DEBUG
(brace
r_int
id|x
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;BOOTP: XID=%08x, DE=%s, HT=%02x, HL=%02x, HA=&quot;
comma
id|xmit_bootp-&gt;xid
comma
id|best_dev-&gt;name
comma
id|xmit_bootp-&gt;htype
comma
id|xmit_bootp-&gt;hlen
)paren
suffix:semicolon
r_for
c_loop
(paren
id|x
op_assign
l_int|0
suffix:semicolon
id|x
OL
id|xmit_bootp-&gt;hlen
suffix:semicolon
id|x
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x&quot;
comma
id|xmit_bootp-&gt;hw_addr
(braket
id|x
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Create default route to that interface */
r_if
c_cond
(paren
id|root_add_bootp_route
c_func
(paren
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Open the sockets */
r_if
c_cond
(paren
id|root_open_udp_sock
c_func
(paren
op_amp
id|bootp_xmit_fd
comma
op_amp
id|bootp_xmit_sock
)paren
op_logical_or
id|root_open_udp_sock
c_func
(paren
op_amp
id|bootp_recv_fd
comma
op_amp
id|bootp_recv_sock
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Bind/connect the sockets */
(paren
(paren
r_struct
id|sock
op_star
)paren
id|bootp_xmit_sock-&gt;data
)paren
op_member_access_from_pointer
id|broadcast
op_assign
l_int|1
suffix:semicolon
(paren
(paren
r_struct
id|sock
op_star
)paren
id|bootp_xmit_sock-&gt;data
)paren
op_member_access_from_pointer
id|reuse
op_assign
l_int|1
suffix:semicolon
(paren
(paren
r_struct
id|sock
op_star
)paren
id|bootp_recv_sock-&gt;data
)paren
op_member_access_from_pointer
id|reuse
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|root_bind_udp_sock
c_func
(paren
id|bootp_recv_sock
comma
id|INADDR_ANY
comma
l_int|68
)paren
op_logical_or
id|root_bind_udp_sock
c_func
(paren
id|bootp_xmit_sock
comma
id|INADDR_ANY
comma
l_int|68
)paren
op_logical_or
id|root_connect_udp_sock
c_func
(paren
id|bootp_xmit_sock
comma
id|INADDR_BROADCAST
comma
l_int|67
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Send BOOTP request.&n; */
DECL|function|root_bootp_send
r_static
r_int
id|root_bootp_send
c_func
(paren
id|u32
id|jiffies
)paren
(brace
id|xmit_bootp-&gt;secs
op_assign
id|htons
c_func
(paren
id|jiffies
op_div
id|HZ
)paren
suffix:semicolon
r_return
id|root_send_udp
c_func
(paren
id|bootp_xmit_sock
comma
id|xmit_bootp
comma
r_sizeof
(paren
r_struct
id|bootp_pkt
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Copy BOOTP-supplied string if not already set.&n; */
DECL|function|root_bootp_string
r_static
r_int
id|root_bootp_string
c_func
(paren
r_char
op_star
id|dest
comma
r_char
op_star
id|src
comma
r_int
id|len
comma
r_int
id|max
)paren
(brace
r_if
c_cond
(paren
op_star
id|dest
op_logical_or
op_logical_neg
id|len
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|max
op_minus
l_int|1
)paren
id|len
op_assign
id|max
op_minus
l_int|1
suffix:semicolon
id|strncpy
c_func
(paren
id|dest
comma
id|src
comma
id|len
)paren
suffix:semicolon
id|dest
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *  Process BOOTP extension.&n; */
DECL|function|root_do_bootp_ext
r_static
r_void
id|root_do_bootp_ext
c_func
(paren
id|u8
op_star
id|ext
)paren
(brace
macro_line|#ifdef NFSROOT_BOOTP_DEBUG
id|u8
op_star
id|c
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;BOOTP: Got extension %02x&quot;
comma
op_star
id|ext
)paren
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
id|ext
op_plus
l_int|2
suffix:semicolon
id|c
OL
id|ext
op_plus
l_int|2
op_plus
id|ext
(braket
l_int|1
)braket
suffix:semicolon
id|c
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
op_star
id|c
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
op_star
id|ext
op_increment
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* Subnet mask */
r_if
c_cond
(paren
id|netmask.sin_addr.s_addr
op_eq
id|INADDR_NONE
)paren
id|memcpy
c_func
(paren
op_amp
id|netmask.sin_addr.s_addr
comma
id|ext
op_plus
l_int|1
comma
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* Default gateway */
r_if
c_cond
(paren
id|gateway.sin_addr.s_addr
op_eq
id|INADDR_NONE
)paren
id|memcpy
c_func
(paren
op_amp
id|gateway.sin_addr.s_addr
comma
id|ext
op_plus
l_int|1
comma
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
multiline_comment|/* Host name */
id|root_bootp_string
c_func
(paren
id|system_utsname.nodename
comma
id|ext
op_plus
l_int|1
comma
op_star
id|ext
comma
id|__NEW_UTS_LEN
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|40
suffix:colon
multiline_comment|/* NIS Domain name */
id|root_bootp_string
c_func
(paren
id|system_utsname.domainname
comma
id|ext
op_plus
l_int|1
comma
op_star
id|ext
comma
id|__NEW_UTS_LEN
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|17
suffix:colon
multiline_comment|/* Root path */
id|root_bootp_string
c_func
(paren
id|nfs_path
comma
id|ext
op_plus
l_int|1
comma
op_star
id|ext
comma
id|NFS_MAXPATHLEN
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  Receive BOOTP request.&n; */
DECL|function|root_bootp_recv
r_static
r_void
id|root_bootp_recv
c_func
(paren
r_void
)paren
(brace
r_int
id|len
suffix:semicolon
id|u8
op_star
id|ext
comma
op_star
id|end
comma
op_star
id|opt
suffix:semicolon
id|len
op_assign
id|root_recv_udp
c_func
(paren
id|bootp_recv_sock
comma
id|recv_bootp
comma
r_sizeof
(paren
r_struct
id|bootp_pkt
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* Check consistency of incoming packet */
r_if
c_cond
(paren
id|len
OL
l_int|300
op_logical_or
multiline_comment|/* See RFC 1542:2.1 */
id|recv_bootp-&gt;op
op_ne
id|BOOTP_REPLY
op_logical_or
id|recv_bootp-&gt;htype
op_ne
id|xmit_bootp-&gt;htype
op_logical_or
id|recv_bootp-&gt;hlen
op_ne
id|xmit_bootp-&gt;hlen
op_logical_or
id|recv_bootp-&gt;xid
op_ne
id|xmit_bootp-&gt;xid
)paren
(brace
macro_line|#ifdef NFSROOT_BOOTP_DEBUG
id|printk
c_func
(paren
l_string|&quot;?&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* Record BOOTP packet arrival in the global variables */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pkt_arrived
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pkt_arrived
op_assign
id|ARRIVED_BOOTP
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|root_dev
op_assign
id|bootp_dev
suffix:semicolon
multiline_comment|/* Extract basic fields */
id|myaddr.sin_addr.s_addr
op_assign
id|recv_bootp-&gt;your_ip
suffix:semicolon
r_if
c_cond
(paren
id|server.sin_addr.s_addr
op_eq
id|INADDR_NONE
)paren
id|server.sin_addr.s_addr
op_assign
id|recv_bootp-&gt;server_ip
suffix:semicolon
multiline_comment|/* Parse extensions */
r_if
c_cond
(paren
id|recv_bootp-&gt;vendor_area
(braket
l_int|0
)braket
op_eq
l_int|99
op_logical_and
multiline_comment|/* Check magic cookie */
id|recv_bootp-&gt;vendor_area
(braket
l_int|1
)braket
op_eq
l_int|130
op_logical_and
id|recv_bootp-&gt;vendor_area
(braket
l_int|2
)braket
op_eq
l_int|83
op_logical_and
id|recv_bootp-&gt;vendor_area
(braket
l_int|3
)braket
op_eq
l_int|99
)paren
(brace
id|ext
op_assign
op_amp
id|recv_bootp-&gt;vendor_area
(braket
l_int|4
)braket
suffix:semicolon
id|end
op_assign
(paren
id|u8
op_star
)paren
id|recv_bootp
op_plus
id|len
suffix:semicolon
r_while
c_loop
(paren
id|ext
OL
id|end
op_logical_and
op_star
id|ext
op_ne
l_int|255
)paren
(brace
r_if
c_cond
(paren
op_star
id|ext
op_eq
l_int|0
)paren
multiline_comment|/* Padding */
id|ext
op_increment
suffix:semicolon
r_else
(brace
id|opt
op_assign
id|ext
suffix:semicolon
id|ext
op_add_assign
id|ext
(braket
l_int|1
)braket
op_plus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|ext
op_le
id|end
)paren
id|root_do_bootp_ext
c_func
(paren
id|opt
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/***************************************************************************&n;&n;&t;&t;&t;Dynamic configuration of IP.&n;&n; ***************************************************************************/
macro_line|#ifdef CONFIG_RNFS_DYNAMIC
multiline_comment|/*&n; *  Determine client and server IP numbers and appropriate device by using&n; *  the RARP and BOOTP protocols.&n; */
DECL|function|root_auto_config
r_static
r_int
id|root_auto_config
c_func
(paren
r_void
)paren
(brace
r_int
id|retries
suffix:semicolon
r_int
r_int
id|timeout
comma
id|jiff
suffix:semicolon
r_int
r_int
id|start_jiffies
suffix:semicolon
multiline_comment|/*&n;&t; * If neither BOOTP nor RARP was selected, return with an error. This&n;&t; * routine gets only called when some pieces of information are mis-&n;&t; * sing, and without BOOTP and RARP we are not able to get that in-&n;&t; * formation.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|bootp_flag
op_logical_and
op_logical_neg
id|rarp_flag
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Root-NFS: Neither RARP nor BOOTP selected.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_RNFS_BOOTP
r_if
c_cond
(paren
id|bootp_flag
op_logical_and
op_logical_neg
id|bootp_dev_count
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Root-NFS: No suitable device for BOOTP found.&bslash;n&quot;
)paren
suffix:semicolon
id|bootp_flag
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#else
id|bootp_flag
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_RNFS_RARP
r_if
c_cond
(paren
id|rarp_flag
op_logical_and
op_logical_neg
id|rarp_dev_count
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Root-NFS: No suitable device for RARP found.&bslash;n&quot;
)paren
suffix:semicolon
id|rarp_flag
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#else
id|rarp_flag
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|bootp_flag
op_logical_and
op_logical_neg
id|rarp_flag
)paren
multiline_comment|/* Error message already printed */
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Setup RARP and BOOTP protocols&n;&t; */
macro_line|#ifdef CONFIG_RNFS_RARP
r_if
c_cond
(paren
id|rarp_flag
)paren
id|root_rarp_open
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_RNFS_BOOTP
r_if
c_cond
(paren
id|bootp_flag
op_logical_and
id|root_bootp_open
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
id|root_bootp_close
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Send requests and wait, until we get an answer. This loop&n;&t; * seems to be a terrible waste of CPU time, but actually there is&n;&t; * only one process running at all, so we don&squot;t need to use any&n;&t; * scheduler functions.&n;&t; * [Actually we could now, but the nothing else running note still &n;&t; *  applies.. - AC]&n;&t; */
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Sending %s%s%s requests...&quot;
comma
id|bootp_flag
ques
c_cond
l_string|&quot;BOOTP&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|bootp_flag
op_logical_and
id|rarp_flag
ques
c_cond
l_string|&quot; and &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|rarp_flag
ques
c_cond
l_string|&quot;RARP&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|start_jiffies
op_assign
id|jiffies
suffix:semicolon
id|retries
op_assign
id|CONF_RETRIES
suffix:semicolon
id|get_random_bytes
c_func
(paren
op_amp
id|timeout
comma
r_sizeof
(paren
id|timeout
)paren
)paren
suffix:semicolon
id|timeout
op_assign
id|CONF_BASE_TIMEOUT
op_plus
(paren
id|timeout
op_mod
(paren
r_int
)paren
id|CONF_TIMEOUT_RANDOM
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
macro_line|#ifdef CONFIG_RNFS_BOOTP
r_if
c_cond
(paren
id|bootp_flag
op_logical_and
id|root_bootp_send
c_func
(paren
id|jiffies
op_minus
id|start_jiffies
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; BOOTP failed!&bslash;n&quot;
)paren
suffix:semicolon
id|root_bootp_close
c_func
(paren
)paren
suffix:semicolon
id|bootp_flag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rarp_flag
)paren
r_break
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_RNFS_RARP
r_if
c_cond
(paren
id|rarp_flag
)paren
id|root_rarp_send
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
id|jiff
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|jiff
op_logical_and
op_logical_neg
id|pkt_arrived
)paren
macro_line|#ifdef CONFIG_RNFS_BOOTP
id|root_bootp_recv
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|pkt_arrived
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|retries
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; timed out!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|timeout
op_assign
id|timeout
id|CONF_TIMEOUT_MULT
suffix:semicolon
r_if
c_cond
(paren
id|timeout
OG
id|CONF_TIMEOUT_MAX
)paren
id|timeout
op_assign
id|CONF_TIMEOUT_MAX
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_RNFS_RARP
r_if
c_cond
(paren
id|rarp_flag
)paren
id|root_rarp_close
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_RNFS_BOOTP
r_if
c_cond
(paren
id|bootp_flag
)paren
id|root_bootp_close
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|pkt_arrived
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; OK&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Root-NFS: Got %s answer from %s, &quot;
comma
(paren
id|pkt_arrived
op_eq
id|ARRIVED_BOOTP
)paren
ques
c_cond
l_string|&quot;BOOTP&quot;
suffix:colon
l_string|&quot;RARP&quot;
comma
id|in_ntoa
c_func
(paren
id|server.sin_addr.s_addr
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;my address is %s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|myaddr.sin_addr.s_addr
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/***************************************************************************&n;&n;&t;&t;&t;     Parsing of options&n;&n; ***************************************************************************/
multiline_comment|/*&n; *  The following integer options are recognized&n; */
DECL|struct|nfs_int_opts
r_static
r_struct
id|nfs_int_opts
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|val
r_int
op_star
id|val
suffix:semicolon
DECL|variable|root_int_opts
)brace
id|root_int_opts
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;port&quot;
comma
op_amp
id|nfs_port
)brace
comma
(brace
l_string|&quot;rsize&quot;
comma
op_amp
id|nfs_data.rsize
)brace
comma
(brace
l_string|&quot;wsize&quot;
comma
op_amp
id|nfs_data.wsize
)brace
comma
(brace
l_string|&quot;timeo&quot;
comma
op_amp
id|nfs_data.timeo
)brace
comma
(brace
l_string|&quot;retrans&quot;
comma
op_amp
id|nfs_data.retrans
)brace
comma
(brace
l_string|&quot;acregmin&quot;
comma
op_amp
id|nfs_data.acregmin
)brace
comma
(brace
l_string|&quot;acregmax&quot;
comma
op_amp
id|nfs_data.acregmax
)brace
comma
(brace
l_string|&quot;acdirmin&quot;
comma
op_amp
id|nfs_data.acdirmin
)brace
comma
(brace
l_string|&quot;acdirmax&quot;
comma
op_amp
id|nfs_data.acdirmax
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; *  And now the flag options&n; */
DECL|struct|nfs_bool_opts
r_static
r_struct
id|nfs_bool_opts
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|and_mask
r_int
id|and_mask
suffix:semicolon
DECL|member|or_mask
r_int
id|or_mask
suffix:semicolon
DECL|variable|root_bool_opts
)brace
id|root_bool_opts
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;soft&quot;
comma
op_complement
id|NFS_MOUNT_SOFT
comma
id|NFS_MOUNT_SOFT
)brace
comma
(brace
l_string|&quot;hard&quot;
comma
op_complement
id|NFS_MOUNT_SOFT
comma
l_int|0
)brace
comma
(brace
l_string|&quot;intr&quot;
comma
op_complement
id|NFS_MOUNT_INTR
comma
id|NFS_MOUNT_INTR
)brace
comma
(brace
l_string|&quot;nointr&quot;
comma
op_complement
id|NFS_MOUNT_INTR
comma
l_int|0
)brace
comma
(brace
l_string|&quot;posix&quot;
comma
op_complement
id|NFS_MOUNT_POSIX
comma
id|NFS_MOUNT_POSIX
)brace
comma
(brace
l_string|&quot;noposix&quot;
comma
op_complement
id|NFS_MOUNT_POSIX
comma
l_int|0
)brace
comma
(brace
l_string|&quot;cto&quot;
comma
op_complement
id|NFS_MOUNT_NOCTO
comma
l_int|0
)brace
comma
(brace
l_string|&quot;nocto&quot;
comma
op_complement
id|NFS_MOUNT_NOCTO
comma
id|NFS_MOUNT_NOCTO
)brace
comma
(brace
l_string|&quot;ac&quot;
comma
op_complement
id|NFS_MOUNT_NOAC
comma
l_int|0
)brace
comma
(brace
l_string|&quot;noac&quot;
comma
op_complement
id|NFS_MOUNT_NOAC
comma
id|NFS_MOUNT_NOAC
)brace
comma
(brace
l_int|NULL
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; *  Prepare the NFS data structure and parse any options. This tries to&n; *  set as many values in the nfs_data structure as known right now.&n; */
DECL|function|root_nfs_name
r_static
r_int
id|root_nfs_name
c_func
(paren
r_char
op_star
id|name
)paren
(brace
r_char
id|buf
(braket
id|NFS_MAXPATHLEN
)braket
suffix:semicolon
r_char
op_star
id|cp
comma
op_star
id|cq
comma
op_star
id|options
comma
op_star
id|val
suffix:semicolon
r_int
id|octets
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* It is possible to override the server IP number here */
id|cp
op_assign
id|cq
op_assign
id|name
suffix:semicolon
r_while
c_loop
(paren
id|octets
OL
l_int|4
)paren
(brace
r_while
c_loop
(paren
op_star
id|cp
op_ge
l_char|&squot;0&squot;
op_logical_and
op_star
id|cp
op_le
l_char|&squot;9&squot;
)paren
id|cp
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cp
op_eq
id|cq
op_logical_or
id|cp
op_minus
id|cq
OG
l_int|3
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_star
id|cp
op_eq
l_char|&squot;.&squot;
op_logical_or
id|octets
op_eq
l_int|3
)paren
id|octets
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|octets
OL
l_int|4
)paren
id|cp
op_increment
suffix:semicolon
id|cq
op_assign
id|cp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|octets
op_eq
l_int|4
op_logical_and
(paren
op_star
id|cp
op_eq
l_char|&squot;:&squot;
op_logical_or
op_star
id|cp
op_eq
l_char|&squot;&bslash;0&squot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_star
id|cp
op_eq
l_char|&squot;:&squot;
)paren
op_star
id|cp
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|server.sin_addr.s_addr
op_assign
id|in_aton
c_func
(paren
id|name
)paren
suffix:semicolon
id|name
op_assign
id|cp
suffix:semicolon
)brace
multiline_comment|/* Clear the nfs_data structure and setup the server hostname */
id|memset
c_func
(paren
op_amp
id|nfs_data
comma
l_int|0
comma
r_sizeof
(paren
id|nfs_data
)paren
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|nfs_data.hostname
comma
id|in_ntoa
c_func
(paren
id|server.sin_addr.s_addr
)paren
comma
r_sizeof
(paren
id|nfs_data.hostname
)paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Set the name of the directory to mount */
r_if
c_cond
(paren
id|nfs_path
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_or
id|strncmp
c_func
(paren
id|name
comma
l_string|&quot;default&quot;
comma
l_int|7
)paren
)paren
id|strncpy
c_func
(paren
id|buf
comma
id|name
comma
id|NFS_MAXPATHLEN
)paren
suffix:semicolon
r_else
id|strncpy
c_func
(paren
id|buf
comma
id|nfs_path
comma
id|NFS_MAXPATHLEN
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|options
op_assign
id|strchr
c_func
(paren
id|buf
comma
l_char|&squot;,&squot;
)paren
)paren
)paren
op_star
id|options
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|buf
comma
l_string|&quot;default&quot;
)paren
)paren
id|strcpy
c_func
(paren
id|buf
comma
id|NFS_ROOT
)paren
suffix:semicolon
id|cp
op_assign
id|in_ntoa
c_func
(paren
id|myaddr.sin_addr.s_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|buf
)paren
op_plus
id|strlen
c_func
(paren
id|cp
)paren
OG
id|NFS_MAXPATHLEN
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Root-NFS: Pathname for remote directory too long.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* update nfs_path with path from nfsroot=... command line parameter */
r_if
c_cond
(paren
op_star
id|buf
)paren
id|sprintf
c_func
(paren
id|nfs_path
comma
id|buf
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/* Set some default values */
id|nfs_port
op_assign
op_minus
l_int|1
suffix:semicolon
id|nfs_data.version
op_assign
id|NFS_MOUNT_VERSION
suffix:semicolon
id|nfs_data.flags
op_assign
l_int|0
suffix:semicolon
id|nfs_data.rsize
op_assign
id|NFS_DEF_FILE_IO_BUFFER_SIZE
suffix:semicolon
id|nfs_data.wsize
op_assign
id|NFS_DEF_FILE_IO_BUFFER_SIZE
suffix:semicolon
id|nfs_data.timeo
op_assign
l_int|7
suffix:semicolon
id|nfs_data.retrans
op_assign
l_int|3
suffix:semicolon
id|nfs_data.acregmin
op_assign
l_int|3
suffix:semicolon
id|nfs_data.acregmax
op_assign
l_int|60
suffix:semicolon
id|nfs_data.acdirmin
op_assign
l_int|30
suffix:semicolon
id|nfs_data.acdirmax
op_assign
l_int|60
suffix:semicolon
multiline_comment|/* Process any options */
r_if
c_cond
(paren
id|options
)paren
(brace
id|cp
op_assign
id|strtok
c_func
(paren
id|options
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cp
)paren
(brace
r_if
c_cond
(paren
(paren
id|val
op_assign
id|strchr
c_func
(paren
id|cp
comma
l_char|&squot;=&squot;
)paren
)paren
)paren
(brace
r_struct
id|nfs_int_opts
op_star
id|opts
op_assign
id|root_int_opts
suffix:semicolon
op_star
id|val
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_while
c_loop
(paren
id|opts-&gt;name
op_logical_and
id|strcmp
c_func
(paren
id|opts-&gt;name
comma
id|cp
)paren
)paren
id|opts
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|opts-&gt;name
)paren
op_star
(paren
id|opts-&gt;val
)paren
op_assign
(paren
r_int
)paren
id|simple_strtoul
c_func
(paren
id|val
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|nfs_bool_opts
op_star
id|opts
op_assign
id|root_bool_opts
suffix:semicolon
r_while
c_loop
(paren
id|opts-&gt;name
op_logical_and
id|strcmp
c_func
(paren
id|opts-&gt;name
comma
id|cp
)paren
)paren
id|opts
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|opts-&gt;name
)paren
(brace
id|nfs_data.flags
op_and_assign
id|opts-&gt;and_mask
suffix:semicolon
id|nfs_data.flags
op_or_assign
id|opts-&gt;or_mask
suffix:semicolon
)brace
)brace
id|cp
op_assign
id|strtok
c_func
(paren
l_int|NULL
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Tell the user what&squot;s going on.&n; */
macro_line|#ifdef NFSROOT_DEBUG
DECL|function|root_nfs_print
r_static
r_void
id|root_nfs_print
c_func
(paren
r_void
)paren
(brace
DECL|macro|IN_NTOA
mdefine_line|#define IN_NTOA(x) (((x) == INADDR_NONE) ? &quot;none&quot; : in_ntoa(x))
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Root-NFS: IP config: dev=%s, &quot;
comma
id|root_dev
ques
c_cond
id|root_dev-&gt;name
suffix:colon
l_string|&quot;none&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;local=%s, &quot;
comma
id|IN_NTOA
c_func
(paren
id|myaddr.sin_addr.s_addr
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;server=%s, &quot;
comma
id|IN_NTOA
c_func
(paren
id|server.sin_addr.s_addr
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;gw=%s, &quot;
comma
id|IN_NTOA
c_func
(paren
id|gateway.sin_addr.s_addr
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;mask=%s, &quot;
comma
id|IN_NTOA
c_func
(paren
id|netmask.sin_addr.s_addr
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;host=%s, domain=%s&bslash;n&quot;
comma
id|system_utsname.nodename
(braket
l_int|0
)braket
ques
c_cond
id|system_utsname.nodename
suffix:colon
l_string|&quot;none&quot;
comma
id|system_utsname.domainname
(braket
l_int|0
)braket
ques
c_cond
id|system_utsname.domainname
suffix:colon
l_string|&quot;none&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Root-NFS: Mounting %s on server %s as root&bslash;n&quot;
comma
id|nfs_path
comma
id|nfs_data.hostname
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Root-NFS:     rsize = %d, wsize = %d, timeo = %d, retrans = %d&bslash;n&quot;
comma
id|nfs_data.rsize
comma
id|nfs_data.wsize
comma
id|nfs_data.timeo
comma
id|nfs_data.retrans
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Root-NFS:     acreg (min,max) = (%d,%d), acdir (min,max) = (%d,%d)&bslash;n&quot;
comma
id|nfs_data.acregmin
comma
id|nfs_data.acregmax
comma
id|nfs_data.acdirmin
comma
id|nfs_data.acdirmax
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Root-NFS:     port = %d, flags = %08x&bslash;n&quot;
comma
id|nfs_port
comma
id|nfs_data.flags
)paren
suffix:semicolon
DECL|macro|IN_NTOA
macro_line|#undef IN_NTOA
)brace
macro_line|#endif
multiline_comment|/*&n; *  Decode any IP configuration options in the &quot;nfsaddrs&quot; kernel command&n; *  line parameter. It consists of option fields separated by colons in&n; *  the following order:&n; *&n; *  &lt;client-ip&gt;:&lt;server-ip&gt;:&lt;gw-ip&gt;:&lt;netmask&gt;:&lt;host name&gt;:&lt;device&gt;:&lt;bootp|rarp&gt;&n; *&n; *  Any of the fields can be empty which means to use a default value:&n; *&t;&lt;client-ip&gt;&t;- address given by BOOTP or RARP&n; *&t;&lt;server-ip&gt;&t;- address of host returning BOOTP or RARP packet&n; *&t;&lt;gw-ip&gt;&t;&t;- none, or the address returned by BOOTP&n; *&t;&lt;netmask&gt;&t;- automatically determined from &lt;client-ip&gt;, or the&n; *&t;&t;&t;  one returned by BOOTP&n; *&t;&lt;host name&gt;&t;- &lt;client-ip&gt; in ASCII notation, or the name returned&n; *&t;&t;&t;  by BOOTP&n; *&t;&lt;device&gt;&t;- use all available devices for RARP and the first&n; *&t;&t;&t;  one for BOOTP&n; *&t;&lt;bootp|rarp&gt;&t;- use both protocols to determine my own address&n; */
DECL|function|root_nfs_addrs
r_static
r_void
id|root_nfs_addrs
c_func
(paren
r_char
op_star
id|addrs
)paren
(brace
r_char
op_star
id|cp
comma
op_star
id|ip
comma
op_star
id|dp
suffix:semicolon
r_int
id|num
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear all addresses and strings */
id|myaddr.sin_family
op_assign
id|server.sin_family
op_assign
id|rarp_serv.sin_family
op_assign
id|gateway.sin_family
op_assign
id|netmask.sin_family
op_assign
id|AF_INET
suffix:semicolon
id|myaddr.sin_addr.s_addr
op_assign
id|server.sin_addr.s_addr
op_assign
id|rarp_serv.sin_addr.s_addr
op_assign
id|gateway.sin_addr.s_addr
op_assign
id|netmask.sin_addr.s_addr
op_assign
id|INADDR_NONE
suffix:semicolon
id|system_utsname.nodename
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|system_utsname.domainname
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|user_dev_name
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|bootp_flag
op_assign
id|rarp_flag
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* The following is just a shortcut for automatic IP configuration */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|addrs
comma
l_string|&quot;bootp&quot;
)paren
)paren
(brace
id|rarp_flag
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|addrs
comma
l_string|&quot;rarp&quot;
)paren
)paren
(brace
id|bootp_flag
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|addrs
comma
l_string|&quot;both&quot;
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Parse the whole string */
id|ip
op_assign
id|addrs
suffix:semicolon
r_while
c_loop
(paren
id|ip
op_logical_and
op_star
id|ip
)paren
(brace
r_if
c_cond
(paren
(paren
id|cp
op_assign
id|strchr
c_func
(paren
id|ip
comma
l_char|&squot;:&squot;
)paren
)paren
)paren
op_star
id|cp
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|ip
)paren
OG
l_int|0
)paren
(brace
macro_line|#ifdef NFSROOT_DEBUG
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Root-NFS: Config string num %d is &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|num
comma
id|ip
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|num
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
(paren
id|myaddr.sin_addr.s_addr
op_assign
id|in_aton
c_func
(paren
id|ip
)paren
)paren
op_eq
id|INADDR_ANY
)paren
id|myaddr.sin_addr.s_addr
op_assign
id|INADDR_NONE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
(paren
id|server.sin_addr.s_addr
op_assign
id|in_aton
c_func
(paren
id|ip
)paren
)paren
op_eq
id|INADDR_ANY
)paren
id|server.sin_addr.s_addr
op_assign
id|INADDR_NONE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
(paren
id|gateway.sin_addr.s_addr
op_assign
id|in_aton
c_func
(paren
id|ip
)paren
)paren
op_eq
id|INADDR_ANY
)paren
id|gateway.sin_addr.s_addr
op_assign
id|INADDR_NONE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
(paren
id|netmask.sin_addr.s_addr
op_assign
id|in_aton
c_func
(paren
id|ip
)paren
)paren
op_eq
id|INADDR_ANY
)paren
id|netmask.sin_addr.s_addr
op_assign
id|INADDR_NONE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_if
c_cond
(paren
(paren
id|dp
op_assign
id|strchr
c_func
(paren
id|ip
comma
l_char|&squot;.&squot;
)paren
)paren
)paren
(brace
op_star
id|dp
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|strncpy
c_func
(paren
id|system_utsname.domainname
comma
id|dp
comma
id|__NEW_UTS_LEN
)paren
suffix:semicolon
id|system_utsname.domainname
(braket
id|__NEW_UTS_LEN
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
id|strncpy
c_func
(paren
id|system_utsname.nodename
comma
id|ip
comma
id|__NEW_UTS_LEN
)paren
suffix:semicolon
id|system_utsname.nodename
(braket
id|__NEW_UTS_LEN
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|strncpy
c_func
(paren
id|user_dev_name
comma
id|ip
comma
id|IFNAMSIZ
)paren
suffix:semicolon
id|user_dev_name
(braket
id|IFNAMSIZ
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|ip
comma
l_string|&quot;rarp&quot;
)paren
)paren
id|bootp_flag
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|ip
comma
l_string|&quot;bootp&quot;
)paren
)paren
id|rarp_flag
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ip
comma
l_string|&quot;both&quot;
)paren
)paren
id|bootp_flag
op_assign
id|rarp_flag
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
id|ip
op_assign
id|cp
suffix:semicolon
id|num
op_increment
suffix:semicolon
)brace
id|rarp_serv
op_assign
id|server
suffix:semicolon
)brace
multiline_comment|/*&n; *  Set the interface address and configure a route to the server.&n; */
DECL|function|root_nfs_setup
r_static
r_int
id|root_nfs_setup
c_func
(paren
r_void
)paren
(brace
r_struct
id|rtentry
id|route
suffix:semicolon
multiline_comment|/* Set the default system name in case none was previously found */
r_if
c_cond
(paren
op_logical_neg
id|system_utsname.nodename
(braket
l_int|0
)braket
)paren
(brace
id|strncpy
c_func
(paren
id|system_utsname.nodename
comma
id|in_ntoa
c_func
(paren
id|myaddr.sin_addr.s_addr
)paren
comma
id|__NEW_UTS_LEN
)paren
suffix:semicolon
id|system_utsname.nodename
(braket
id|__NEW_UTS_LEN
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
multiline_comment|/* Set the correct netmask */
r_if
c_cond
(paren
id|netmask.sin_addr.s_addr
op_eq
id|INADDR_NONE
)paren
id|netmask.sin_addr.s_addr
op_assign
id|ip_get_mask
c_func
(paren
id|myaddr.sin_addr.s_addr
)paren
suffix:semicolon
multiline_comment|/* Setup the device correctly */
id|root_dev-&gt;family
op_assign
id|myaddr.sin_family
suffix:semicolon
id|root_dev-&gt;pa_addr
op_assign
id|myaddr.sin_addr.s_addr
suffix:semicolon
id|root_dev-&gt;pa_mask
op_assign
id|netmask.sin_addr.s_addr
suffix:semicolon
id|root_dev-&gt;pa_brdaddr
op_assign
id|root_dev-&gt;pa_addr
op_or
op_complement
id|root_dev-&gt;pa_mask
suffix:semicolon
id|root_dev-&gt;pa_dstaddr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Now add a route to the server. If there is no gateway given,&n;&t; * the server is on the same subnet, so we establish only a route to&n;&t; * the local network. Otherwise we create a route to the gateway (the&n;&t; * same local network router as in the former case) and then setup a&n;&t; * gatewayed default route. Note that this gives sufficient network&n;&t; * setup even for full system operation in all common cases.&n;&t; */
id|memset
c_func
(paren
op_amp
id|route
comma
l_int|0
comma
r_sizeof
(paren
id|route
)paren
)paren
suffix:semicolon
multiline_comment|/* Local subnet route */
id|route.rt_dev
op_assign
id|root_dev-&gt;name
suffix:semicolon
id|route.rt_mss
op_assign
id|root_dev-&gt;mtu
suffix:semicolon
id|route.rt_flags
op_assign
id|RTF_UP
suffix:semicolon
op_star
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
(paren
id|route.rt_dst
)paren
)paren
op_assign
id|myaddr
suffix:semicolon
(paren
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
(paren
id|route.rt_dst
)paren
)paren
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
op_and_assign
id|netmask.sin_addr.s_addr
suffix:semicolon
op_star
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
(paren
id|route.rt_genmask
)paren
)paren
op_assign
id|netmask
suffix:semicolon
r_if
c_cond
(paren
id|ip_rt_new
c_func
(paren
op_amp
id|route
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Root-NFS: Adding of local route failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gateway.sin_addr.s_addr
op_ne
id|INADDR_NONE
)paren
(brace
multiline_comment|/* Default route */
(paren
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
(paren
id|route.rt_dst
)paren
)paren
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
op_assign
id|INADDR_ANY
suffix:semicolon
(paren
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
(paren
id|route.rt_genmask
)paren
)paren
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
op_assign
id|INADDR_ANY
suffix:semicolon
op_star
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
(paren
id|route.rt_gateway
)paren
)paren
op_assign
id|gateway
suffix:semicolon
id|route.rt_flags
op_or_assign
id|RTF_GATEWAY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|gateway.sin_addr.s_addr
op_xor
id|myaddr.sin_addr.s_addr
)paren
op_amp
id|netmask.sin_addr.s_addr
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Root-NFS: Gateway not on local network!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ip_rt_new
c_func
(paren
op_amp
id|route
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Root-NFS: Adding of default route failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|server.sin_addr.s_addr
op_xor
id|myaddr.sin_addr.s_addr
)paren
op_amp
id|netmask.sin_addr.s_addr
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Root-NFS: Boot server not on local network and no default gateway configured!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Get the necessary IP addresses and prepare for mounting the required&n; *  NFS filesystem.&n; */
DECL|function|nfs_root_init
r_int
id|nfs_root_init
c_func
(paren
r_char
op_star
id|nfsname
comma
r_char
op_star
id|nfsaddrs
)paren
(brace
multiline_comment|/*&n;&t; * Decode IP addresses and other configuration info contained&n;&t; * in the nfsaddrs string (which came from the kernel command&n;&t; * line).&n;&t; */
id|root_nfs_addrs
c_func
(paren
id|nfsaddrs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup all network devices&n;&t; */
r_if
c_cond
(paren
id|root_dev_open
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * If the config information is insufficient (e.g., our IP address or&n;&t; * IP address of the boot server is missing or we have multiple network&n;&t; * interfaces and no default was set), use BOOTP or RARP to get the&n;&t; * missing values.&n;&t; *&n;&t; * Note that we don&squot;t try to set up correct routes for multiple&n;&t; * interfaces (could be solved by trying icmp echo requests), because&n;&t; * it&squot;s only necessary in the rare case of multiple ethernet devices&n;&t; * in the (diskless) system and if the server is on another subnet.&n;&t; * If only one interface is installed, the routing is obvious.&n;&t; */
r_if
c_cond
(paren
(paren
id|myaddr.sin_addr.s_addr
op_eq
id|INADDR_NONE
op_logical_or
id|server.sin_addr.s_addr
op_eq
id|INADDR_NONE
op_logical_or
(paren
id|open_base
op_ne
l_int|NULL
op_logical_and
id|open_base-&gt;next
op_ne
l_int|NULL
)paren
)paren
macro_line|#ifdef CONFIG_RNFS_DYNAMIC
op_logical_and
id|root_auto_config
c_func
(paren
)paren
OL
l_int|0
macro_line|#endif
)paren
(brace
id|root_dev_close
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|root_dev
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|open_base
op_ne
l_int|NULL
op_logical_and
id|open_base-&gt;next
op_eq
l_int|NULL
)paren
(brace
id|root_dev
op_assign
id|open_base-&gt;dev
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Root-NFS: Multiple devices and no server&bslash;n&quot;
)paren
suffix:semicolon
id|root_dev_close
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Close all network devices except the device which connects to&n;&t; * server&n;&t; */
id|root_dev_close
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Decode the root directory path name and NFS options from&n;&t; * the kernel command line. This has to go here in order to&n;&t; * be able to use the client IP address for the remote root&n;&t; * directory (necessary for pure RARP booting).&n;&t; */
r_if
c_cond
(paren
id|root_nfs_name
c_func
(paren
id|nfsname
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Setup devices and routes. The server directory is actually&n;&t; * mounted after init() has been started.&n;&t; */
r_if
c_cond
(paren
id|root_nfs_setup
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef NFSROOT_DEBUG
id|root_nfs_print
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n;&n;&t;       Routines to actually mount the root directory&n;&n; ***************************************************************************/
DECL|variable|nfs_file
r_static
r_struct
id|file
op_star
id|nfs_file
suffix:semicolon
multiline_comment|/* File descriptor pointing to inode */
DECL|variable|nfs_sock_inode
r_static
r_struct
id|inode
op_star
id|nfs_sock_inode
suffix:semicolon
multiline_comment|/* Inode containing socket */
DECL|variable|rpc_packet
r_static
r_int
op_star
id|rpc_packet
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* RPC packet */
multiline_comment|/*&n; *  Open a UDP socket.&n; */
DECL|function|root_nfs_open
r_static
r_int
id|root_nfs_open
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Open the socket */
r_if
c_cond
(paren
(paren
id|nfs_data.fd
op_assign
id|sys_socket
c_func
(paren
id|AF_INET
comma
id|SOCK_DGRAM
comma
id|IPPROTO_UDP
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Root-NFS: Cannot open UDP socket for NFS!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|nfs_file
op_assign
id|current-&gt;files-&gt;fd
(braket
id|nfs_data.fd
)braket
suffix:semicolon
id|nfs_sock_inode
op_assign
id|nfs_file-&gt;f_inode
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Close the UDP file descriptor. If nfs_read_super is successful, it&n; *  increases the reference count, so we can simply close the file, and&n; *  the socket keeps open.&n; */
DECL|function|root_nfs_close
r_static
r_void
id|root_nfs_close
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * The following close doesn&squot;t touch the server structure, which&n;&t; * now contains a file pointer pointing into nowhere. The system&n;&t; * _should_ crash as soon as someone tries to select on the root&n;&t; * filesystem. Haven&squot;t tried it yet - we can still change it back&n;&t; * to the old way of keeping a static copy of all important data&n;&t; * structures, including their pointers. At least this should be&n;&t; * checked out _carefully_ before going into a public release&n;&t; * kernel.  -  GK&n;&t; */
id|sys_close
c_func
(paren
id|nfs_data.fd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Find a suitable listening port and bind to it&n; */
DECL|function|root_nfs_bind
r_static
r_int
id|root_nfs_bind
c_func
(paren
r_void
)paren
(brace
r_int
id|res
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|port
op_assign
id|STARTPORT
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|sin
op_assign
op_amp
id|myaddr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|nfs_sock_inode-&gt;u.socket_i.ops-&gt;bind
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NPORTS
op_logical_and
id|res
OL
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sin-&gt;sin_port
op_assign
id|htons
c_func
(paren
id|port
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port
OG
id|ENDPORT
)paren
(brace
id|port
op_assign
id|STARTPORT
suffix:semicolon
)brace
id|res
op_assign
id|nfs_sock_inode-&gt;u.socket_i.ops
op_member_access_from_pointer
id|bind
c_func
(paren
op_amp
id|nfs_sock_inode-&gt;u.socket_i
comma
(paren
r_struct
id|sockaddr
op_star
)paren
id|sin
comma
r_sizeof
(paren
r_struct
id|sockaddr_in
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|res
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Root-NFS: Cannot find a suitable listening port&bslash;n&quot;
)paren
suffix:semicolon
id|root_nfs_close
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef NFSROOT_DEBUG
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Root-NFS: Binding to listening port %d&bslash;n&quot;
comma
id|port
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Send an RPC request and wait for the answer&n; */
DECL|function|root_nfs_call
r_static
r_int
op_star
id|root_nfs_call
c_func
(paren
r_int
op_star
id|end
)paren
(brace
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_int
id|dummylen
suffix:semicolon
r_static
r_struct
id|nfs_server
id|s
op_assign
(brace
l_int|0
comma
multiline_comment|/* struct file *&t; */
l_int|0
comma
multiline_comment|/* struct rsock *&t; */
(brace
l_int|0
comma
l_string|&quot;&quot;
comma
)brace
comma
multiline_comment|/* toaddr&t;&t; */
l_int|0
comma
multiline_comment|/* lock&t;&t;&t; */
l_int|NULL
comma
multiline_comment|/* wait queue&t;&t; */
id|NFS_MOUNT_SOFT
comma
multiline_comment|/* flags&t;&t; */
l_int|0
comma
l_int|0
comma
multiline_comment|/* rsize, wsize&t;&t; */
l_int|0
comma
multiline_comment|/* timeo&t;&t; */
l_int|0
comma
multiline_comment|/* retrans&t;&t; */
l_int|3
op_star
id|HZ
comma
l_int|60
op_star
id|HZ
comma
l_int|30
op_star
id|HZ
comma
l_int|60
op_star
id|HZ
comma
l_string|&quot;&bslash;0&quot;
)brace
suffix:semicolon
id|s.file
op_assign
id|nfs_file
suffix:semicolon
id|sock
op_assign
op_amp
(paren
(paren
id|nfs_file-&gt;f_inode
)paren
op_member_access_from_pointer
id|u.socket_i
)paren
suffix:semicolon
multiline_comment|/* Extract the other end of the socket into s-&gt;toaddr */
id|sock-&gt;ops
op_member_access_from_pointer
id|getname
c_func
(paren
id|sock
comma
op_amp
(paren
id|s.toaddr
)paren
comma
op_amp
id|dummylen
comma
l_int|1
)paren
suffix:semicolon
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|s.toaddr
)paren
op_member_access_from_pointer
id|sin_port
op_assign
id|server.sin_port
suffix:semicolon
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|s.toaddr
)paren
op_member_access_from_pointer
id|sin_family
op_assign
id|server.sin_family
suffix:semicolon
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|s.toaddr
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
op_assign
id|server.sin_addr.s_addr
suffix:semicolon
id|s.rsock
op_assign
id|rpc_makesock
c_func
(paren
id|nfs_file
)paren
suffix:semicolon
id|s.flags
op_assign
id|nfs_data.flags
suffix:semicolon
id|s.rsize
op_assign
id|nfs_data.rsize
suffix:semicolon
id|s.wsize
op_assign
id|nfs_data.wsize
suffix:semicolon
id|s.timeo
op_assign
id|nfs_data.timeo
op_star
id|HZ
op_div
l_int|10
suffix:semicolon
id|s.retrans
op_assign
id|nfs_data.retrans
suffix:semicolon
id|strcpy
c_func
(paren
id|s.hostname
comma
id|nfs_data.hostname
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First connect the UDP socket to a server port, then send the&n;&t; * packet out, and finally check whether the answer is OK.&n;&t; */
r_if
c_cond
(paren
id|nfs_sock_inode-&gt;u.socket_i.ops-&gt;connect
op_logical_and
id|nfs_sock_inode-&gt;u.socket_i.ops
op_member_access_from_pointer
id|connect
c_func
(paren
op_amp
id|nfs_sock_inode-&gt;u.socket_i
comma
(paren
r_struct
id|sockaddr
op_star
)paren
op_amp
id|server
comma
r_sizeof
(paren
r_struct
id|sockaddr_in
)paren
comma
id|nfs_file-&gt;f_flags
)paren
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|nfs_rpc_call
c_func
(paren
op_amp
id|s
comma
id|rpc_packet
comma
id|end
comma
id|nfs_data.wsize
)paren
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|rpc_verify
c_func
(paren
id|rpc_packet
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Create an RPC packet header&n; */
DECL|function|root_nfs_header
r_static
r_int
op_star
id|root_nfs_header
c_func
(paren
r_int
id|proc
comma
r_int
id|program
comma
r_int
id|version
)paren
(brace
r_int
id|groups
(braket
)braket
op_assign
(brace
l_int|0
comma
id|NOGROUP
)brace
suffix:semicolon
r_if
c_cond
(paren
id|rpc_packet
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|rpc_packet
op_assign
id|kmalloc
c_func
(paren
id|nfs_data.wsize
op_plus
l_int|1024
comma
id|GFP_NFS
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Root-NFS: Cannot allocate UDP buffer&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|rpc_header
c_func
(paren
id|rpc_packet
comma
id|proc
comma
id|program
comma
id|version
comma
l_int|0
comma
l_int|0
comma
id|groups
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Query server portmapper for the port of a daemon program&n; */
DECL|function|root_nfs_get_port
r_static
r_int
id|root_nfs_get_port
c_func
(paren
r_int
id|program
comma
r_int
id|version
)paren
(brace
r_int
op_star
id|p
suffix:semicolon
multiline_comment|/* Prepare header for portmap request */
id|server.sin_port
op_assign
id|htons
c_func
(paren
id|NFS_PMAP_PORT
)paren
suffix:semicolon
id|p
op_assign
id|root_nfs_header
c_func
(paren
id|NFS_PMAP_PROC
comma
id|NFS_PMAP_PROGRAM
comma
id|NFS_PMAP_VERSION
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Set arguments for portmapper */
op_star
id|p
op_increment
op_assign
id|htonl
c_func
(paren
id|program
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|htonl
c_func
(paren
id|version
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|htonl
c_func
(paren
id|IPPROTO_UDP
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Send request to server portmapper */
r_if
c_cond
(paren
(paren
id|p
op_assign
id|root_nfs_call
c_func
(paren
id|p
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
id|ntohl
c_func
(paren
op_star
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  Get portnumbers for mountd and nfsd from server&n; */
DECL|function|root_nfs_ports
r_static
r_int
id|root_nfs_ports
c_func
(paren
r_void
)paren
(brace
r_int
id|port
suffix:semicolon
r_if
c_cond
(paren
id|nfs_port
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|port
op_assign
id|root_nfs_get_port
c_func
(paren
id|NFS_NFS_PROGRAM
comma
id|NFS_NFS_VERSION
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Root-NFS: Unable to get nfsd port number from server, using default&bslash;n&quot;
)paren
suffix:semicolon
id|port
op_assign
id|NFS_NFS_PORT
suffix:semicolon
)brace
id|nfs_port
op_assign
id|port
suffix:semicolon
macro_line|#ifdef NFSROOT_DEBUG
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Root-NFS: Portmapper on server returned %d as nfsd port&bslash;n&quot;
comma
id|port
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
(paren
id|port
op_assign
id|root_nfs_get_port
c_func
(paren
id|NFS_MOUNT_PROGRAM
comma
id|NFS_MOUNT_VERSION
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Root-NFS: Unable to get mountd port number from server, using default&bslash;n&quot;
)paren
suffix:semicolon
id|port
op_assign
id|NFS_MOUNT_PORT
suffix:semicolon
)brace
id|server.sin_port
op_assign
id|htons
c_func
(paren
id|port
)paren
suffix:semicolon
macro_line|#ifdef NFSROOT_DEBUG
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Root-NFS: Portmapper on server returned %d as mountd port&bslash;n&quot;
comma
id|port
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Get a file handle from the server for the directory which is to be&n; *  mounted&n; */
DECL|function|root_nfs_get_handle
r_static
r_int
id|root_nfs_get_handle
c_func
(paren
r_void
)paren
(brace
r_int
id|len
comma
id|status
comma
op_star
id|p
suffix:semicolon
multiline_comment|/* Prepare header for mountd request */
id|p
op_assign
id|root_nfs_header
c_func
(paren
id|NFS_MOUNT_PROC
comma
id|NFS_MOUNT_PROGRAM
comma
id|NFS_MOUNT_VERSION
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|root_nfs_close
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Set arguments for mountd */
id|len
op_assign
id|strlen
c_func
(paren
id|nfs_path
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|htonl
c_func
(paren
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|p
comma
id|nfs_path
comma
id|len
)paren
suffix:semicolon
id|len
op_assign
(paren
id|len
op_plus
l_int|3
)paren
op_rshift
l_int|2
suffix:semicolon
id|p
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|p
op_add_assign
id|len
suffix:semicolon
multiline_comment|/* Send request to server mountd */
r_if
c_cond
(paren
(paren
id|p
op_assign
id|root_nfs_call
c_func
(paren
id|p
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|root_nfs_close
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|status
op_assign
id|ntohl
c_func
(paren
op_star
id|p
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
(brace
id|nfs_data.root
op_assign
op_star
(paren
(paren
r_struct
id|nfs_fh
op_star
)paren
id|p
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Root-NFS: Got file handle for %s via RPC&bslash;n&quot;
comma
id|nfs_path
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Root-NFS: Server returned error %d while mounting %s&bslash;n&quot;
comma
id|status
comma
id|nfs_path
)paren
suffix:semicolon
id|root_nfs_close
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Now actually mount the given directory&n; */
DECL|function|root_nfs_do_mount
r_static
r_int
id|root_nfs_do_mount
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
multiline_comment|/* First connect to the nfsd port on the server */
id|server.sin_port
op_assign
id|htons
c_func
(paren
id|nfs_port
)paren
suffix:semicolon
id|nfs_data.addr
op_assign
id|server
suffix:semicolon
r_if
c_cond
(paren
id|nfs_sock_inode-&gt;u.socket_i.ops-&gt;connect
op_logical_and
id|nfs_sock_inode-&gt;u.socket_i.ops
op_member_access_from_pointer
id|connect
c_func
(paren
op_amp
id|nfs_sock_inode-&gt;u.socket_i
comma
(paren
r_struct
id|sockaddr
op_star
)paren
op_amp
id|server
comma
r_sizeof
(paren
r_struct
id|sockaddr_in
)paren
comma
id|nfs_file-&gt;f_flags
)paren
OL
l_int|0
)paren
(brace
id|root_nfs_close
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Now (finally ;-)) read the super block for mounting */
r_if
c_cond
(paren
id|nfs_read_super
c_func
(paren
id|sb
comma
op_amp
id|nfs_data
comma
l_int|1
)paren
op_eq
l_int|NULL
)paren
(brace
id|root_nfs_close
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Get the NFS port numbers and file handle, and then read the super-&n; *  block for mounting.&n; */
DECL|function|nfs_root_mount
r_int
id|nfs_root_mount
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_if
c_cond
(paren
id|root_nfs_open
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|root_nfs_bind
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|root_nfs_ports
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|root_nfs_get_handle
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|root_nfs_do_mount
c_func
(paren
id|sb
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|root_nfs_close
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
