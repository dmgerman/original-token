multiline_comment|/*&n; *  linux/fs/nfs/nfsroot.c&n; *&n; *  Copyright (C) 1995  Gero Kuhlmann &lt;gero@gkminix.han.de&gt;&n; *&n; *  Allow an NFS filesystem to be mounted as root. The way this works&n; *  is to first determine the local IP address via RARP. Then handle&n; *  the RPC negotiation with the system which replied to the RARP. The&n; *  actual mounting is done later, when init() is running.&n; *&n; * &t;Changes:&n; *&n; *&t;Alan Cox&t;:&t;Removed get_address name clash with FPU.&n; *&t;Alan Cox&t;:&t;Reformatted a bit.&n; *&n; *&t;TODO:&n; *&t;&t;Support bootp and dhcp as well as rarp.&n; */
multiline_comment|/* Define this to allow debugging output */
DECL|macro|NFSROOT_DEBUG
mdefine_line|#define NFSROOT_DEBUG 1
multiline_comment|/* Define the timeout for waiting for a RARP reply */
DECL|macro|RARP_TIMEOUT
mdefine_line|#define RARP_TIMEOUT&t;30&t;/* 30 seconds */
DECL|macro|RARP_RETRIES
mdefine_line|#define RARP_RETRIES&t; 5&t;/* 5 retries */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;asm/param.h&gt;
macro_line|#include &lt;linux/utsname.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/if.h&gt;
macro_line|#include &lt;linux/inet.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/if_arp.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#ifdef CONFIG_AX25
macro_line|#include &lt;net/ax25.h&gt;&t;/* For AX25_P_IP */
macro_line|#endif
macro_line|#include &lt;linux/skbuff.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/route.h&gt;
macro_line|#include &lt;net/route.h&gt;
macro_line|#include &lt;linux/nfs.h&gt;
macro_line|#include &lt;linux/nfs_fs.h&gt;
macro_line|#include &lt;linux/nfs_mount.h&gt;
DECL|macro|IPPORT_RESERVED
mdefine_line|#define IPPORT_RESERVED 1024
multiline_comment|/* Range of privileged ports */
DECL|macro|STARTPORT
mdefine_line|#define STARTPORT 600
DECL|macro|ENDPORT
mdefine_line|#define ENDPORT (IPPORT_RESERVED - 1)
DECL|macro|NPORTS
mdefine_line|#define NPORTS&t;(ENDPORT - STARTPORT + 1)
DECL|struct|open_dev
r_struct
id|open_dev
(brace
DECL|member|dev
r_struct
id|device
op_star
id|dev
suffix:semicolon
DECL|member|old_flags
r_int
r_int
id|old_flags
suffix:semicolon
DECL|member|next
r_struct
id|open_dev
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|open_base
r_static
r_struct
id|open_dev
op_star
id|open_base
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|root_dev
r_static
r_struct
id|device
op_star
id|root_dev
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|myaddr
r_static
r_struct
id|sockaddr_in
id|myaddr
suffix:semicolon
multiline_comment|/* My IP address */
DECL|variable|server
r_static
r_struct
id|sockaddr_in
id|server
suffix:semicolon
multiline_comment|/* Server IP address */
DECL|variable|nfs_data
r_static
r_struct
id|nfs_mount_data
id|nfs_data
suffix:semicolon
multiline_comment|/* NFS mount info */
DECL|variable|nfs_path
r_static
r_char
id|nfs_path
(braket
id|NFS_MAXPATHLEN
)braket
suffix:semicolon
multiline_comment|/* Name of directory to mount */
DECL|variable|nfs_port
r_static
r_int
id|nfs_port
suffix:semicolon
multiline_comment|/* Port to connect to for NFS service */
multiline_comment|/***************************************************************************&n;&n;&t;&t;&t;RARP Subroutines&n;&n; ***************************************************************************/
r_extern
r_void
id|arp_send
c_func
(paren
r_int
id|type
comma
r_int
id|ptype
comma
r_int
r_int
id|target_ip
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|src_ip
comma
r_int
r_char
op_star
id|dest_hw
comma
r_int
r_char
op_star
id|src_hw
comma
r_int
r_char
op_star
id|target_hw
)paren
suffix:semicolon
r_static
r_int
id|root_rarp_recv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|packet_type
op_star
id|pt
)paren
suffix:semicolon
DECL|variable|rarp_packet_type
r_static
r_struct
id|packet_type
id|rarp_packet_type
op_assign
(brace
l_int|0
comma
multiline_comment|/* Should be: __constant_htons(ETH_P_RARP) - but this _doesn&squot;t_ come out constant! */
l_int|NULL
comma
multiline_comment|/* Listen to all devices */
id|root_rarp_recv
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n; *  For receiving rarp packets a packet type has to be registered. Also&n; *  initialize all devices for usage by RARP.&n; */
DECL|function|root_rarp_open
r_static
r_int
id|root_rarp_open
c_func
(paren
r_void
)paren
(brace
r_struct
id|open_dev
op_star
id|openp
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
r_int
r_int
id|old_flags
suffix:semicolon
r_int
id|num
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Register the packet type &n;&t; */
id|rarp_packet_type.type
op_assign
id|htons
c_func
(paren
id|ETH_P_RARP
)paren
suffix:semicolon
id|dev_add_pack
c_func
(paren
op_amp
id|rarp_packet_type
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Open all devices which allow RARP &n;&t; */
r_for
c_loop
(paren
id|dev
op_assign
id|dev_base
comma
id|num
op_assign
l_int|0
suffix:semicolon
id|dev
op_ne
l_int|NULL
suffix:semicolon
id|dev
op_assign
id|dev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;type
OL
id|ARPHRD_SLIP
op_logical_and
id|dev-&gt;family
op_eq
id|AF_INET
op_logical_and
op_logical_neg
(paren
id|dev-&gt;flags
op_amp
(paren
id|IFF_LOOPBACK
op_or
id|IFF_POINTOPOINT
op_or
id|IFF_NOARP
)paren
)paren
)paren
(brace
multiline_comment|/* First up the interface */
id|old_flags
op_assign
id|dev-&gt;flags
suffix:semicolon
id|dev-&gt;flags
op_assign
id|IFF_UP
op_or
id|IFF_BROADCAST
op_or
id|IFF_RUNNING
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|old_flags
op_amp
id|IFF_UP
)paren
op_logical_and
id|dev_open
c_func
(paren
id|dev
)paren
)paren
(brace
id|dev-&gt;flags
op_assign
id|old_flags
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|openp
op_assign
(paren
r_struct
id|open_dev
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|open_dev
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|openp
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|openp-&gt;dev
op_assign
id|dev
suffix:semicolon
id|openp-&gt;old_flags
op_assign
id|old_flags
suffix:semicolon
id|openp-&gt;next
op_assign
id|open_base
suffix:semicolon
id|open_base
op_assign
id|openp
suffix:semicolon
id|num
op_increment
suffix:semicolon
)brace
)brace
r_return
id|num
suffix:semicolon
)brace
multiline_comment|/*&n; *  Remove the packet type again when all rarp packets have been received&n; *  and restore the state of the device. However, keep the root device&n; *  open for the upcoming mount.&n; */
DECL|function|root_rarp_close
r_static
r_void
id|root_rarp_close
c_func
(paren
r_void
)paren
(brace
r_struct
id|open_dev
op_star
id|openp
suffix:semicolon
r_struct
id|open_dev
op_star
id|nextp
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Deregister the packet type &n;&t; */
id|rarp_packet_type.type
op_assign
id|htons
c_func
(paren
id|ETH_P_RARP
)paren
suffix:semicolon
id|dev_remove_pack
c_func
(paren
op_amp
id|rarp_packet_type
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Deactivate all previously opened devices except that one which is&n;&t; *&t;able to connect to a suitable server&n;&t; */
id|openp
op_assign
id|open_base
suffix:semicolon
r_while
c_loop
(paren
id|openp
op_ne
l_int|NULL
)paren
(brace
id|nextp
op_assign
id|openp-&gt;next
suffix:semicolon
id|openp-&gt;next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|openp-&gt;dev
op_ne
id|root_dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|openp-&gt;old_flags
op_amp
id|IFF_UP
)paren
)paren
id|dev_close
c_func
(paren
id|openp-&gt;dev
)paren
suffix:semicolon
id|openp-&gt;dev-&gt;flags
op_assign
id|openp-&gt;old_flags
suffix:semicolon
)brace
id|kfree_s
c_func
(paren
id|openp
comma
r_sizeof
(paren
r_struct
id|open_dev
)paren
)paren
suffix:semicolon
id|openp
op_assign
id|nextp
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Receive RARP packets.&n; */
DECL|function|root_rarp_recv
r_static
r_int
id|root_rarp_recv
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|device
op_star
id|dev
comma
r_struct
id|packet_type
op_star
id|pt
)paren
(brace
r_struct
id|arphdr
op_star
id|rarp
op_assign
(paren
r_struct
id|arphdr
op_star
)paren
id|skb-&gt;h.raw
suffix:semicolon
r_int
r_char
op_star
id|rarp_ptr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|rarp
op_plus
l_int|1
)paren
suffix:semicolon
r_int
r_int
id|sip
comma
id|tip
suffix:semicolon
r_int
r_char
op_star
id|sha
comma
op_star
id|tha
suffix:semicolon
multiline_comment|/* s for &quot;source&quot;, t for &quot;target&quot; */
multiline_comment|/*&n;&t; *&t;If this test doesn&squot;t pass, its not IP, or we should ignore it anyway &n;&t; */
r_if
c_cond
(paren
id|rarp-&gt;ar_hln
op_ne
id|dev-&gt;addr_len
op_logical_or
id|dev-&gt;type
op_ne
id|ntohs
c_func
(paren
id|rarp-&gt;ar_hrd
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;If it&squot;s not a RARP reply, delete it. &n;&t; */
r_if
c_cond
(paren
id|rarp-&gt;ar_op
op_ne
id|htons
c_func
(paren
id|ARPOP_RREPLY
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;If it&squot;s not ethernet or AX25, delete it. &n;&t; */
r_if
c_cond
(paren
(paren
id|rarp-&gt;ar_pro
op_ne
id|htons
c_func
(paren
id|ETH_P_IP
)paren
op_logical_and
id|dev-&gt;type
op_ne
id|ARPHRD_AX25
)paren
op_logical_or
macro_line|#ifdef CONFIG_AX25
(paren
id|rarp-&gt;ar_pro
op_ne
id|htons
c_func
(paren
id|AX25_P_IP
)paren
op_logical_and
id|dev-&gt;type
op_eq
id|ARPHRD_AX25
)paren
op_logical_or
macro_line|#endif
id|rarp-&gt;ar_pln
op_ne
l_int|4
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Extract variable width fields &n;&t; */
id|sha
op_assign
id|rarp_ptr
suffix:semicolon
id|rarp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|sip
comma
id|rarp_ptr
comma
l_int|4
)paren
suffix:semicolon
id|rarp_ptr
op_add_assign
l_int|4
suffix:semicolon
id|tha
op_assign
id|rarp_ptr
suffix:semicolon
id|rarp_ptr
op_add_assign
id|dev-&gt;addr_len
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|tip
comma
id|rarp_ptr
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Discard packets which are not meant for us. &n;&t; */
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|tha
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;addr_len
)paren
)paren
(brace
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;The packet is what we were looking for. Setup the global variables. &n;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root_dev
op_ne
l_int|NULL
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|root_dev
op_assign
id|dev
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|myaddr.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
id|myaddr.sin_addr.s_addr
op_assign
id|tip
suffix:semicolon
id|server.sin_family
op_assign
id|dev-&gt;family
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|server.sin_addr.s_addr
)paren
id|server.sin_addr.s_addr
op_assign
id|sip
suffix:semicolon
id|kfree_skb
c_func
(paren
id|skb
comma
id|FREE_READ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send RARP request packet over all devices which allow RARP.&n; */
DECL|function|root_rarp_send
r_static
r_void
id|root_rarp_send
c_func
(paren
r_void
)paren
(brace
r_struct
id|open_dev
op_star
id|openp
suffix:semicolon
r_struct
id|device
op_star
id|dev
suffix:semicolon
macro_line|#ifdef NFSROOT_DEBUG
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;NFS: Sending RARP request...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|openp
op_assign
id|open_base
suffix:semicolon
id|openp
op_ne
l_int|NULL
suffix:semicolon
id|openp
op_assign
id|openp-&gt;next
)paren
(brace
id|dev
op_assign
id|openp-&gt;dev
suffix:semicolon
id|arp_send
c_func
(paren
id|ARPOP_RREQUEST
comma
id|ETH_P_RARP
comma
l_int|0
comma
id|dev
comma
l_int|0
comma
l_int|NULL
comma
id|dev-&gt;dev_addr
comma
id|dev-&gt;dev_addr
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Determine client and server IP numbers and appropriate device by using&n; *&t;the RARP protocol.&n; */
DECL|function|do_rarp
r_static
r_int
id|do_rarp
c_func
(paren
r_void
)paren
(brace
r_int
id|retries
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
multiline_comment|/* &n;&t; *&t;Open all devices and setup RARP protocol &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|root_rarp_open
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: No network device found to send RARP request to&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Send RARP request and wait, until we get an answer. This loop seems&n;&t; *&t;to be a terrible waste of cpu time, but actually there is no process&n;&t; *&t;running at all, so we don&squot;t need to use any scheduler functions.&n;&t; *&t;[Actually we could now, but the nothing else running note still &n;&t; *&t; applies.. - AC]&n;&t; */
r_for
c_loop
(paren
id|retries
op_assign
l_int|0
suffix:semicolon
id|retries
OL
id|RARP_RETRIES
op_logical_and
id|root_dev
op_eq
l_int|NULL
suffix:semicolon
id|retries
op_increment
)paren
(brace
id|root_rarp_send
c_func
(paren
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
(paren
id|RARP_TIMEOUT
op_star
id|HZ
)paren
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|timeout
op_logical_and
id|root_dev
op_eq
l_int|NULL
)paren
suffix:semicolon
suffix:semicolon
)brace
r_if
c_cond
(paren
id|root_dev
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: Timed out while waiting for RARP answer&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|root_rarp_close
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;NFS: &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Got RARP answer from %s, &quot;
comma
id|in_ntoa
c_func
(paren
id|server.sin_addr.s_addr
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;my address is %s&bslash;n&quot;
comma
id|in_ntoa
c_func
(paren
id|myaddr.sin_addr.s_addr
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n;&n;&t;&t;&t;Routines to setup NFS&n;&n; ***************************************************************************/
r_extern
r_void
id|ip_rt_add
c_func
(paren
r_int
id|flags
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|mask
comma
r_int
r_int
id|gw
comma
r_struct
id|device
op_star
id|dev
comma
r_int
r_int
id|mss
comma
r_int
r_int
id|window
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;The following integer options are recognized&n; */
DECL|struct|nfs_int_opts
r_static
r_struct
id|nfs_int_opts
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|val
r_int
op_star
id|val
suffix:semicolon
DECL|variable|root_int_opts
)brace
id|root_int_opts
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;port&quot;
comma
op_amp
id|nfs_port
)brace
comma
(brace
l_string|&quot;rsize&quot;
comma
op_amp
id|nfs_data.rsize
)brace
comma
(brace
l_string|&quot;wsize&quot;
comma
op_amp
id|nfs_data.wsize
)brace
comma
(brace
l_string|&quot;timeo&quot;
comma
op_amp
id|nfs_data.timeo
)brace
comma
(brace
l_string|&quot;retrans&quot;
comma
op_amp
id|nfs_data.retrans
)brace
comma
(brace
l_string|&quot;acregmin&quot;
comma
op_amp
id|nfs_data.acregmin
)brace
comma
(brace
l_string|&quot;acregmax&quot;
comma
op_amp
id|nfs_data.acregmax
)brace
comma
(brace
l_string|&quot;acdirmin&quot;
comma
op_amp
id|nfs_data.acdirmin
)brace
comma
(brace
l_string|&quot;acdirmax&quot;
comma
op_amp
id|nfs_data.acdirmax
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;And now the flag options &n; */
DECL|struct|nfs_bool_opts
r_static
r_struct
id|nfs_bool_opts
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|and_mask
r_int
id|and_mask
suffix:semicolon
DECL|member|or_mask
r_int
id|or_mask
suffix:semicolon
DECL|variable|root_bool_opts
)brace
id|root_bool_opts
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;soft&quot;
comma
op_complement
id|NFS_MOUNT_SOFT
comma
id|NFS_MOUNT_SOFT
)brace
comma
(brace
l_string|&quot;hard&quot;
comma
op_complement
id|NFS_MOUNT_SOFT
comma
l_int|0
)brace
comma
(brace
l_string|&quot;intr&quot;
comma
op_complement
id|NFS_MOUNT_INTR
comma
id|NFS_MOUNT_INTR
)brace
comma
(brace
l_string|&quot;nointr&quot;
comma
op_complement
id|NFS_MOUNT_INTR
comma
l_int|0
)brace
comma
(brace
l_string|&quot;posix&quot;
comma
op_complement
id|NFS_MOUNT_POSIX
comma
id|NFS_MOUNT_POSIX
)brace
comma
(brace
l_string|&quot;noposix&quot;
comma
op_complement
id|NFS_MOUNT_POSIX
comma
l_int|0
)brace
comma
(brace
l_string|&quot;cto&quot;
comma
op_complement
id|NFS_MOUNT_NOCTO
comma
l_int|0
)brace
comma
(brace
l_string|&quot;nocto&quot;
comma
op_complement
id|NFS_MOUNT_NOCTO
comma
id|NFS_MOUNT_NOCTO
)brace
comma
(brace
l_string|&quot;ac&quot;
comma
op_complement
id|NFS_MOUNT_NOAC
comma
l_int|0
)brace
comma
(brace
l_string|&quot;noac&quot;
comma
op_complement
id|NFS_MOUNT_NOAC
comma
id|NFS_MOUNT_NOAC
)brace
comma
(brace
l_int|NULL
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|function|nfs_get_address
r_static
r_int
r_int
id|nfs_get_address
(paren
r_char
op_star
op_star
id|str
)paren
(brace
r_int
r_int
id|l
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_int
id|i
suffix:semicolon
id|l
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|l
op_lshift_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
op_star
op_star
id|str
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|val
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
op_star
id|str
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
op_star
op_star
id|str
op_ne
l_char|&squot;.&squot;
op_logical_and
op_star
op_star
id|str
op_ne
l_char|&squot;:&squot;
)paren
(brace
id|val
op_mul_assign
l_int|10
suffix:semicolon
id|val
op_add_assign
op_star
op_star
id|str
op_minus
l_char|&squot;0&squot;
suffix:semicolon
(paren
op_star
id|str
)paren
op_increment
suffix:semicolon
)brace
id|l
op_or_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
op_star
op_star
id|str
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(paren
op_star
id|str
)paren
op_increment
suffix:semicolon
)brace
)brace
r_return
id|htonl
c_func
(paren
id|l
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Prepare the NFS data structure and parse any options&n; */
DECL|function|root_nfs_parse
r_static
r_int
id|root_nfs_parse
c_func
(paren
r_char
op_star
id|name
)paren
(brace
r_char
id|buf
(braket
id|NFS_MAXPATHLEN
)braket
suffix:semicolon
r_char
op_star
id|cp
comma
op_star
id|options
comma
op_star
id|val
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Get the host ip number &n;&t; */
r_if
c_cond
(paren
op_star
id|name
op_ge
l_char|&squot;0&squot;
op_logical_and
op_star
id|name
op_le
l_char|&squot;9&squot;
)paren
(brace
id|server.sin_addr.s_addr
op_assign
id|nfs_get_address
(paren
op_amp
id|name
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Setup the server hostname &n;&t; */
id|cp
op_assign
id|in_ntoa
c_func
(paren
id|server.sin_addr.s_addr
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|nfs_data.hostname
comma
id|cp
comma
l_int|255
)paren
suffix:semicolon
id|nfs_data.addr
op_assign
id|server
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Set the name of the directory to mount &n;&t; */
id|cp
op_assign
id|in_ntoa
c_func
(paren
id|myaddr.sin_addr.s_addr
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|buf
comma
id|name
comma
l_int|255
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|options
op_assign
id|strchr
c_func
(paren
id|buf
comma
l_char|&squot;,&squot;
)paren
)paren
)paren
op_star
id|options
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|buf
)paren
op_plus
id|strlen
c_func
(paren
id|cp
)paren
OG
id|NFS_MAXPATHLEN
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: Pathname for remote directory too long&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|nfs_path
comma
id|buf
comma
id|cp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Set some default values &n;&t; */
id|nfs_port
op_assign
op_minus
l_int|1
suffix:semicolon
id|nfs_data.version
op_assign
id|NFS_MOUNT_VERSION
suffix:semicolon
id|nfs_data.flags
op_assign
l_int|0
suffix:semicolon
id|nfs_data.rsize
op_assign
id|NFS_DEF_FILE_IO_BUFFER_SIZE
suffix:semicolon
id|nfs_data.wsize
op_assign
id|NFS_DEF_FILE_IO_BUFFER_SIZE
suffix:semicolon
id|nfs_data.timeo
op_assign
l_int|7
suffix:semicolon
id|nfs_data.retrans
op_assign
l_int|3
suffix:semicolon
id|nfs_data.acregmin
op_assign
l_int|3
suffix:semicolon
id|nfs_data.acregmax
op_assign
l_int|60
suffix:semicolon
id|nfs_data.acdirmin
op_assign
l_int|30
suffix:semicolon
id|nfs_data.acdirmax
op_assign
l_int|60
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Process any options&n;&t; */
r_if
c_cond
(paren
id|options
)paren
(brace
id|cp
op_assign
id|strtok
c_func
(paren
id|options
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cp
)paren
(brace
r_if
c_cond
(paren
(paren
id|val
op_assign
id|strchr
c_func
(paren
id|cp
comma
l_char|&squot;=&squot;
)paren
)paren
)paren
(brace
r_struct
id|nfs_int_opts
op_star
id|opts
op_assign
id|root_int_opts
suffix:semicolon
op_star
id|val
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_while
c_loop
(paren
id|opts-&gt;name
op_logical_and
id|strcmp
c_func
(paren
id|opts-&gt;name
comma
id|cp
)paren
)paren
id|opts
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|opts-&gt;name
)paren
op_star
(paren
id|opts-&gt;val
)paren
op_assign
(paren
r_int
)paren
id|simple_strtoul
c_func
(paren
id|val
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|nfs_bool_opts
op_star
id|opts
op_assign
id|root_bool_opts
suffix:semicolon
r_while
c_loop
(paren
id|opts-&gt;name
op_logical_and
id|strcmp
c_func
(paren
id|opts-&gt;name
comma
id|cp
)paren
)paren
id|opts
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|opts-&gt;name
)paren
(brace
id|nfs_data.flags
op_and_assign
id|opts-&gt;and_mask
suffix:semicolon
id|nfs_data.flags
op_or_assign
id|opts-&gt;or_mask
suffix:semicolon
)brace
)brace
id|cp
op_assign
id|strtok
c_func
(paren
l_int|NULL
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Tell the user what&squot;s going on.&n; */
DECL|function|root_nfs_print
r_static
r_void
id|root_nfs_print
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef NFSROOT_DEBUG
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;NFS: Mounting %s on server %s as root&bslash;n&quot;
comma
id|nfs_path
comma
id|nfs_data.hostname
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;NFS:     rsize = %d, wsize = %d, timeo = %d, retrans = %d&bslash;n&quot;
comma
id|nfs_data.rsize
comma
id|nfs_data.wsize
comma
id|nfs_data.timeo
comma
id|nfs_data.retrans
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;NFS:     acreg (min,max) = (%d,%d), acdir (min,max) = (%d,%d)&bslash;n&quot;
comma
id|nfs_data.acregmin
comma
id|nfs_data.acregmax
comma
id|nfs_data.acdirmin
comma
id|nfs_data.acdirmax
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;NFS:     port = %d, flags = %08x&bslash;n&quot;
comma
id|nfs_port
comma
id|nfs_data.flags
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Set the interface address and configure a route to the server.&n; */
DECL|function|root_nfs_setup
r_static
r_void
id|root_nfs_setup
c_func
(paren
r_void
)paren
(brace
r_struct
id|rtentry
id|server_route
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|sin
suffix:semicolon
multiline_comment|/* &n;&t; *&t;Setup the device correctly&n;&t; */
id|root_dev-&gt;family
op_assign
id|myaddr.sin_family
suffix:semicolon
id|root_dev-&gt;pa_addr
op_assign
id|myaddr.sin_addr.s_addr
suffix:semicolon
id|root_dev-&gt;pa_mask
op_assign
id|ip_get_mask
c_func
(paren
id|myaddr.sin_addr.s_addr
)paren
suffix:semicolon
id|root_dev-&gt;pa_brdaddr
op_assign
id|root_dev-&gt;pa_addr
op_or
op_complement
id|root_dev-&gt;pa_mask
suffix:semicolon
id|root_dev-&gt;pa_dstaddr
op_assign
l_int|0
suffix:semicolon
id|sin
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|server_route.rt_dst
suffix:semicolon
op_star
id|sin
op_assign
id|server
suffix:semicolon
id|sin
op_assign
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|server_route.rt_genmask
suffix:semicolon
id|sin-&gt;sin_family
op_assign
id|AF_INET
suffix:semicolon
id|sin-&gt;sin_addr.s_addr
op_assign
id|root_dev-&gt;pa_mask
suffix:semicolon
id|server_route.rt_dev
op_assign
l_int|NULL
suffix:semicolon
id|server_route.rt_flags
op_assign
id|RTF_HOST
op_or
id|RTF_UP
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now add a route to the server&n;&t; */
r_if
c_cond
(paren
id|ip_rt_new
c_func
(paren
op_amp
id|server_route
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to add NFS server route.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Get the necessary IP addresses and prepare for mounting the required&n; *&t;NFS filesystem.&n; */
DECL|function|nfs_root_init
r_int
id|nfs_root_init
c_func
(paren
r_char
op_star
id|nfsname
)paren
(brace
multiline_comment|/*&n;&t; *&t;Initialize network device and get local and server IP address &n;&t; */
r_if
c_cond
(paren
id|do_rarp
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Initialize the global variables necessary for NFS. The server&n;&t; *&t;directory is actually mounted after init() has been started.&n;&t; */
r_if
c_cond
(paren
id|root_nfs_parse
c_func
(paren
id|nfsname
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|root_nfs_print
c_func
(paren
)paren
suffix:semicolon
id|root_nfs_setup
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n;&n;&t;&t;Routines to actually mount the root directory&n;&n; ***************************************************************************/
DECL|variable|nfs_file
r_static
r_struct
id|file
id|nfs_file
suffix:semicolon
multiline_comment|/* File descriptor containing socket */
DECL|variable|nfs_inode
r_static
r_struct
id|inode
id|nfs_inode
suffix:semicolon
multiline_comment|/* Inode containing socket */
DECL|variable|rpc_packet
r_static
r_int
op_star
id|rpc_packet
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* RPC packet */
r_extern
id|asmlinkage
r_int
id|sys_socketcall
c_func
(paren
r_int
id|call
comma
r_int
r_int
op_star
id|args
)paren
suffix:semicolon
r_extern
r_struct
id|socket
op_star
id|socki_lookup
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Open a UDP socket.&n; */
DECL|function|root_nfs_open
r_static
r_int
id|root_nfs_open
c_func
(paren
r_void
)paren
(brace
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_int
r_int
id|opt
(braket
)braket
op_assign
(brace
id|AF_INET
comma
id|SOCK_DGRAM
comma
id|IPPROTO_UDP
)brace
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Open the socket &n;&t; */
r_if
c_cond
(paren
(paren
id|nfs_data.fd
op_assign
id|sys_socketcall
c_func
(paren
id|SYS_SOCKET
comma
id|opt
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: Cannot open UDP socket&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&t;&n;&t; *&t;Copy the file and inode data area so that we can remove the&n;&t; *&t;file lateron without killing the socket. After all this the&n;&t; *&t;closing routine just needs to remove the file pointer from&n;&t; *&t;the init-task descriptor.&n;&t; */
id|filp
op_assign
id|current-&gt;files-&gt;fd
(braket
id|nfs_data.fd
)braket
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|nfs_file
comma
id|filp
comma
r_sizeof
(paren
r_struct
id|file
)paren
)paren
suffix:semicolon
id|nfs_file.f_next
op_assign
id|nfs_file.f_prev
op_assign
l_int|NULL
suffix:semicolon
id|current-&gt;files-&gt;fd
(braket
id|nfs_data.fd
)braket
op_assign
op_amp
id|nfs_file
suffix:semicolon
id|filp-&gt;f_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Free the file descriptor */
id|memcpy
c_func
(paren
op_amp
id|nfs_inode
comma
id|nfs_file.f_inode
comma
r_sizeof
(paren
r_struct
id|inode
)paren
)paren
suffix:semicolon
id|nfs_inode.i_hash_next
op_assign
id|nfs_inode.i_hash_prev
op_assign
l_int|NULL
suffix:semicolon
id|nfs_inode.i_next
op_assign
id|nfs_inode.i_prev
op_assign
l_int|NULL
suffix:semicolon
id|clear_inode
c_func
(paren
id|nfs_file.f_inode
)paren
suffix:semicolon
id|nfs_file.f_inode
op_assign
op_amp
id|nfs_inode
suffix:semicolon
id|nfs_inode.u.socket_i.inode
op_assign
op_amp
id|nfs_inode
suffix:semicolon
id|nfs_file.private_data
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Close the UDP file descriptor. The main part of preserving the socket&n; *&t;has already been done after opening it. Now we have to remove the&n; *&t;file descriptor from the init task.&n; */
DECL|function|root_nfs_close
r_static
r_void
id|root_nfs_close
c_func
(paren
r_int
id|close_all
)paren
(brace
multiline_comment|/*&n;&t; *&t;Remove the file from the list of open files &n;&t; */
id|current-&gt;files-&gt;fd
(braket
id|nfs_data.fd
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;files-&gt;count
OG
l_int|0
)paren
id|current-&gt;files-&gt;count
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Clear memory use by the RPC packet &n;&t; */
r_if
c_cond
(paren
id|rpc_packet
op_ne
l_int|NULL
)paren
id|kfree_s
c_func
(paren
id|rpc_packet
comma
id|nfs_data.wsize
op_plus
l_int|1024
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;In case of an error we also have to close the socket again (sigh)&n;&t; */
r_if
c_cond
(paren
id|close_all
)paren
(brace
id|nfs_inode.u.socket_i.inode
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* The inode is already cleared */
r_if
c_cond
(paren
id|nfs_file.f_op-&gt;release
)paren
id|nfs_file.f_op
op_member_access_from_pointer
id|release
c_func
(paren
op_amp
id|nfs_inode
comma
op_amp
id|nfs_file
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Find a suitable listening port and bind to it&n; */
DECL|function|root_nfs_bind
r_static
r_int
id|root_nfs_bind
c_func
(paren
r_void
)paren
(brace
r_int
id|res
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|port
op_assign
id|STARTPORT
suffix:semicolon
r_struct
id|sockaddr_in
op_star
id|sin
op_assign
op_amp
id|myaddr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|nfs_inode.u.socket_i.ops-&gt;bind
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NPORTS
op_logical_and
id|res
OL
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sin-&gt;sin_port
op_assign
id|htons
c_func
(paren
id|port
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port
OG
id|ENDPORT
)paren
(brace
id|port
op_assign
id|STARTPORT
suffix:semicolon
)brace
id|res
op_assign
id|nfs_inode.u.socket_i.ops
op_member_access_from_pointer
id|bind
c_func
(paren
op_amp
id|nfs_inode.u.socket_i
comma
(paren
r_struct
id|sockaddr
op_star
)paren
id|sin
comma
r_sizeof
(paren
r_struct
id|sockaddr_in
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|res
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: Cannot find a suitable listening port&bslash;n&quot;
)paren
suffix:semicolon
id|root_nfs_close
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef NFSROOT_DEBUG
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;NFS: Binding to listening port %d&bslash;n&quot;
comma
id|port
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Send an RPC request and wait for the answer&n; */
DECL|function|root_nfs_call
r_static
r_int
op_star
id|root_nfs_call
c_func
(paren
r_int
op_star
id|end
)paren
(brace
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|socket
op_star
id|sock
suffix:semicolon
r_int
id|dummylen
suffix:semicolon
r_static
r_struct
id|nfs_server
id|s
op_assign
(brace
op_amp
id|nfs_file
comma
multiline_comment|/* struct file * */
l_int|0
comma
multiline_comment|/* struct rsock * */
(brace
l_int|0
comma
l_string|&quot;&quot;
comma
)brace
comma
multiline_comment|/* toaddr */
l_int|0
comma
multiline_comment|/* lock */
l_int|NULL
comma
multiline_comment|/* wait queue */
id|NFS_MOUNT_SOFT
comma
multiline_comment|/* flags - this seems a ___BAD___ default - AC */
l_int|0
comma
l_int|0
comma
multiline_comment|/* rsize, wsize */
l_int|0
comma
multiline_comment|/* timeo */
l_int|0
comma
multiline_comment|/* retrans */
l_int|3
op_star
id|HZ
comma
l_int|60
op_star
id|HZ
comma
l_int|30
op_star
id|HZ
comma
l_int|60
op_star
id|HZ
comma
l_string|&quot;&bslash;0&quot;
)brace
suffix:semicolon
id|filp
op_assign
op_amp
id|nfs_file
suffix:semicolon
id|sock
op_assign
op_amp
(paren
(paren
id|filp-&gt;f_inode
)paren
op_member_access_from_pointer
id|u.socket_i
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;extract the other end of the socket into server-&gt;toaddr &n;&t; */
id|sock-&gt;ops
op_member_access_from_pointer
id|getname
c_func
(paren
id|sock
comma
op_amp
(paren
id|s.toaddr
)paren
comma
op_amp
id|dummylen
comma
l_int|1
)paren
suffix:semicolon
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|s.toaddr
)paren
op_member_access_from_pointer
id|sin_port
op_assign
id|server.sin_port
suffix:semicolon
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|s.toaddr
)paren
op_member_access_from_pointer
id|sin_family
op_assign
id|server.sin_family
suffix:semicolon
(paren
(paren
r_struct
id|sockaddr_in
op_star
)paren
op_amp
id|s.toaddr
)paren
op_member_access_from_pointer
id|sin_addr.s_addr
op_assign
id|server.sin_addr.s_addr
suffix:semicolon
id|s.rsock
op_assign
id|rpc_makesock
c_func
(paren
id|filp
)paren
suffix:semicolon
id|s.flags
op_assign
id|nfs_data.flags
suffix:semicolon
id|s.rsize
op_assign
id|nfs_data.rsize
suffix:semicolon
id|s.wsize
op_assign
id|nfs_data.wsize
suffix:semicolon
id|s.timeo
op_assign
id|nfs_data.timeo
op_star
id|HZ
op_div
l_int|10
suffix:semicolon
id|s.retrans
op_assign
id|nfs_data.retrans
suffix:semicolon
id|strcpy
c_func
(paren
id|s.hostname
comma
id|nfs_data.hostname
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;First connect the UDP socket to a server port, then send the packet&n;&t; *&t;out, and finally check wether the answer is OK.&n;&t; */
r_if
c_cond
(paren
id|nfs_inode.u.socket_i.ops-&gt;connect
op_logical_and
id|nfs_inode.u.socket_i.ops
op_member_access_from_pointer
id|connect
c_func
(paren
op_amp
id|nfs_inode.u.socket_i
comma
(paren
r_struct
id|sockaddr
op_star
)paren
op_amp
id|server
comma
r_sizeof
(paren
r_struct
id|sockaddr_in
)paren
comma
id|nfs_file.f_flags
)paren
OL
l_int|0
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nfs_rpc_call
c_func
(paren
op_amp
id|s
comma
id|rpc_packet
comma
id|end
comma
id|nfs_data.wsize
)paren
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|rpc_verify
c_func
(paren
id|rpc_packet
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Create an RPC packet header&n; */
DECL|function|root_nfs_header
r_static
r_int
op_star
id|root_nfs_header
c_func
(paren
r_int
id|proc
comma
r_int
id|program
comma
r_int
id|version
)paren
(brace
r_int
id|groups
(braket
)braket
op_assign
(brace
l_int|0
comma
id|NOGROUP
)brace
suffix:semicolon
r_if
c_cond
(paren
id|rpc_packet
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|rpc_packet
op_assign
id|kmalloc
c_func
(paren
id|nfs_data.wsize
op_plus
l_int|1024
comma
id|GFP_NFS
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: Cannot allocate UDP buffer&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
id|strcpy
c_func
(paren
id|system_utsname.nodename
comma
id|in_ntoa
c_func
(paren
id|myaddr.sin_addr.s_addr
)paren
)paren
suffix:semicolon
r_return
id|rpc_header
c_func
(paren
id|rpc_packet
comma
id|proc
comma
id|program
comma
id|version
comma
l_int|0
comma
l_int|0
comma
id|groups
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Query server portmapper for the port of a daemon program&n; */
DECL|function|root_nfs_get_port
r_static
r_int
id|root_nfs_get_port
c_func
(paren
r_int
id|program
comma
r_int
id|version
)paren
(brace
r_int
op_star
id|p
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Prepare header for portmap request&n;&t; */
id|server.sin_port
op_assign
id|htons
c_func
(paren
id|NFS_PMAP_PORT
)paren
suffix:semicolon
id|p
op_assign
id|root_nfs_header
c_func
(paren
id|NFS_PMAP_PROC
comma
id|NFS_PMAP_PROGRAM
comma
id|NFS_PMAP_VERSION
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Set arguments for portmapper&n;&t; */
op_star
id|p
op_increment
op_assign
id|htonl
c_func
(paren
id|program
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|htonl
c_func
(paren
id|version
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|htonl
c_func
(paren
id|IPPROTO_UDP
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Send request to server portmapper&n;&t; */
r_if
c_cond
(paren
(paren
id|p
op_assign
id|root_nfs_call
c_func
(paren
id|p
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
id|ntohl
c_func
(paren
op_star
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get portnumbers for mountd and nfsd from server&n; */
DECL|function|root_nfs_ports
r_static
r_int
id|root_nfs_ports
c_func
(paren
r_void
)paren
(brace
r_int
id|port
suffix:semicolon
r_if
c_cond
(paren
id|nfs_port
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|port
op_assign
id|root_nfs_get_port
c_func
(paren
id|NFS_NFS_PROGRAM
comma
id|NFS_NFS_VERSION
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: Unable to get nfsd port number from server, using default&bslash;n&quot;
)paren
suffix:semicolon
id|port
op_assign
id|NFS_NFS_PORT
suffix:semicolon
)brace
id|nfs_port
op_assign
id|port
suffix:semicolon
macro_line|#ifdef NFSROOT_DEBUG
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;NFS: Portmapper on server returned %d as nfsd port&bslash;n&quot;
comma
id|port
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
(paren
id|port
op_assign
id|root_nfs_get_port
c_func
(paren
id|NFS_MOUNT_PROGRAM
comma
id|NFS_MOUNT_VERSION
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: Unable to get mountd port number from server, using default&bslash;n&quot;
)paren
suffix:semicolon
id|port
op_assign
id|NFS_MOUNT_PORT
suffix:semicolon
)brace
id|server.sin_port
op_assign
id|htons
c_func
(paren
id|port
)paren
suffix:semicolon
macro_line|#ifdef NFSROOT_DEBUG
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;NFS: Portmapper on server returned %d as mountd port&bslash;n&quot;
comma
id|port
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get a file handle from the server for the directory which is to be mounted&n; */
DECL|function|root_nfs_get_handle
r_static
r_int
id|root_nfs_get_handle
c_func
(paren
r_void
)paren
(brace
r_int
id|len
comma
id|status
comma
op_star
id|p
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Prepare header for mountd request &n;&t; */
id|p
op_assign
id|root_nfs_header
c_func
(paren
id|NFS_MOUNT_PROC
comma
id|NFS_MOUNT_PROGRAM
comma
id|NFS_MOUNT_VERSION
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|root_nfs_close
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Set arguments for mountd&n;&t; */
id|len
op_assign
id|strlen
c_func
(paren
id|nfs_path
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|htonl
c_func
(paren
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|p
comma
id|nfs_path
comma
id|len
)paren
suffix:semicolon
id|len
op_assign
(paren
id|len
op_plus
l_int|3
)paren
op_rshift
l_int|2
suffix:semicolon
id|p
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|p
op_add_assign
id|len
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Send request to server portmapper &n;&t; */
r_if
c_cond
(paren
(paren
id|p
op_assign
id|root_nfs_call
c_func
(paren
id|p
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|root_nfs_close
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|status
op_assign
id|ntohl
c_func
(paren
op_star
id|p
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
l_int|0
)paren
(brace
id|nfs_data.root
op_assign
op_star
(paren
(paren
r_struct
id|nfs_fh
op_star
)paren
id|p
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;NFS: Server returned error %d while mounting %s&bslash;n&quot;
comma
id|status
comma
id|nfs_path
)paren
suffix:semicolon
id|root_nfs_close
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Now actually mount the given directory&n; */
DECL|function|root_nfs_do_mount
r_static
r_int
id|root_nfs_do_mount
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
multiline_comment|/*&n;&t; *&t;First connect to the nfsd port on the server &n;&t; */
id|server.sin_port
op_assign
id|htons
c_func
(paren
id|nfs_port
)paren
suffix:semicolon
id|nfs_data.addr
op_assign
id|server
suffix:semicolon
r_if
c_cond
(paren
id|nfs_inode.u.socket_i.ops-&gt;connect
op_logical_and
id|nfs_inode.u.socket_i.ops
op_member_access_from_pointer
id|connect
c_func
(paren
op_amp
id|nfs_inode.u.socket_i
comma
(paren
r_struct
id|sockaddr
op_star
)paren
op_amp
id|server
comma
r_sizeof
(paren
r_struct
id|sockaddr_in
)paren
comma
id|nfs_file.f_flags
)paren
OL
l_int|0
)paren
(brace
id|root_nfs_close
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Now (finally ;-)) read the super block for mounting&n;&t; */
r_if
c_cond
(paren
id|nfs_read_super
c_func
(paren
id|sb
comma
op_amp
id|nfs_data
comma
l_int|1
)paren
op_eq
l_int|NULL
)paren
(brace
id|root_nfs_close
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get the NFS port numbers and file handle, and then read the super-&n; *&t;block for mounting.&n; */
DECL|function|nfs_root_mount
r_int
id|nfs_root_mount
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_if
c_cond
(paren
id|root_nfs_open
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|root_nfs_bind
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|root_nfs_ports
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|root_nfs_get_handle
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|root_nfs_do_mount
c_func
(paren
id|sb
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|root_nfs_close
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
