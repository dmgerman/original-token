multiline_comment|/*&n; *  linux/fs/nfs/rpcsock.c&n; *&n; *  This is a generic RPC call interface for datagram sockets that is able&n; *  to place several concurrent RPC requests at the same time. It works like&n; *  this:&n; *&n; *  -&t;When a process places a call, it allocates a request slot if&n; *&t;one is available. Otherwise, it sleeps on the backlog queue.&n; *  -&t;The first process on the receive queue waits for the next RPC reply,&n; *&t;and peeks at the XID. If it finds a matching request, it receives&n; *&t;the datagram on behalf of that process and wakes it up. Otherwise,&n; *&t;the datagram is discarded.&n; *  -&t;If the process having received the datagram was the first one on&n; *&t;the receive queue, it wakes up the next one to listen for replies.&n; *  -&t;It then removes itself from the request queue. If there are more&n; *&t;callers waiting on the backlog queue, they are woken up, too.&n; *&n; *  Copyright (C) 1995, Olaf Kirch &lt;okir@monad.swb.de&gt;&n; */
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/nfs_fs.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/rpcsock.h&gt;
DECL|macro|msleep
mdefine_line|#define msleep(sec)&t;{ current-&gt;timeout = sec * HZ / 1000; &bslash;&n;&t;&t;&t;  current-&gt;state = TASK_INTERRUPTIBLE; &bslash;&n;&t;&t;&t;  schedule(); &bslash;&n;&t;&t;&t;}
DECL|macro|dprintk
mdefine_line|#define dprintk&t;&t;if (0) printk
r_static
r_inline
r_void
DECL|function|rpc_insque
id|rpc_insque
c_func
(paren
r_struct
id|rpc_sock
op_star
id|rsock
comma
r_struct
id|rpc_wait
op_star
id|slot
)paren
(brace
r_struct
id|rpc_wait
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_assign
id|rsock-&gt;tail
)paren
op_ne
l_int|NULL
)paren
(brace
id|tmp-&gt;next
op_assign
id|slot
suffix:semicolon
)brace
r_else
(brace
id|rsock-&gt;head
op_assign
id|slot
suffix:semicolon
)brace
id|rsock-&gt;tail
op_assign
id|slot
suffix:semicolon
id|slot-&gt;prev
op_assign
id|tmp
suffix:semicolon
id|slot-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: inserted %08lx into queue.&bslash;n&quot;
comma
(paren
r_int
)paren
id|slot
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: head = %08lx, tail = %08lx.&bslash;n&quot;
comma
(paren
r_int
)paren
id|rsock-&gt;head
comma
(paren
r_int
)paren
id|rsock-&gt;tail
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|rpc_remque
id|rpc_remque
c_func
(paren
r_struct
id|rpc_sock
op_star
id|rsock
comma
r_struct
id|rpc_wait
op_star
id|slot
)paren
(brace
r_struct
id|rpc_wait
op_star
id|prev
op_assign
id|slot-&gt;prev
comma
op_star
id|next
op_assign
id|slot-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|prev
op_ne
l_int|NULL
)paren
id|prev-&gt;next
op_assign
id|next
suffix:semicolon
r_else
id|rsock-&gt;head
op_assign
id|next
suffix:semicolon
r_if
c_cond
(paren
id|next
op_ne
l_int|NULL
)paren
id|next-&gt;prev
op_assign
id|prev
suffix:semicolon
r_else
id|rsock-&gt;tail
op_assign
id|prev
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: removed %08lx from queue.&bslash;n&quot;
comma
(paren
r_int
)paren
id|slot
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: head = %08lx, tail = %08lx.&bslash;n&quot;
comma
(paren
r_int
)paren
id|rsock-&gt;head
comma
(paren
r_int
)paren
id|rsock-&gt;tail
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|rpc_sendto
id|rpc_sendto
c_func
(paren
r_struct
id|rpc_sock
op_star
id|rsock
comma
r_const
r_int
op_star
id|buf
comma
r_int
id|len
comma
r_struct
id|sockaddr
op_star
id|sap
comma
r_int
id|salen
)paren
(brace
r_struct
id|socket
op_star
id|sock
op_assign
id|rsock-&gt;sock
suffix:semicolon
r_int
r_int
id|oldfs
suffix:semicolon
r_int
id|result
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: sending %d bytes (buf %08lx)&bslash;n&quot;
comma
id|len
comma
(paren
r_int
)paren
id|buf
)paren
suffix:semicolon
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|get_ds
c_func
(paren
)paren
)paren
suffix:semicolon
id|result
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|sendto
c_func
(paren
id|sock
comma
id|buf
comma
id|len
comma
l_int|0
comma
l_int|0
comma
id|sap
comma
id|salen
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: result = %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * This code is slightly complicated. Since the networking code does not&n; * honor the current-&gt;timeout value, we have to select on the socket.&n; */
r_static
r_inline
r_int
DECL|function|rpc_select
id|rpc_select
c_func
(paren
r_struct
id|rpc_sock
op_star
id|rsock
)paren
(brace
r_struct
id|select_table_entry
id|entry
suffix:semicolon
r_struct
id|file
op_star
id|file
op_assign
id|rsock-&gt;file
suffix:semicolon
id|select_table
id|wait_table
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: selecting on socket...&bslash;n&quot;
)paren
suffix:semicolon
id|wait_table.nr
op_assign
l_int|0
suffix:semicolon
id|wait_table.entry
op_assign
op_amp
id|entry
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_op
op_member_access_from_pointer
id|select
c_func
(paren
id|file-&gt;f_inode
comma
id|file
comma
id|SEL_IN
comma
op_amp
id|wait_table
)paren
op_logical_and
op_logical_neg
id|file-&gt;f_op
op_member_access_from_pointer
id|select
c_func
(paren
id|file-&gt;f_inode
comma
id|file
comma
id|SEL_IN
comma
l_int|NULL
)paren
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|entry.wait_address
comma
op_amp
id|entry.wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;timeout
op_eq
l_int|0
)paren
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|wait_table.nr
)paren
id|remove_wait_queue
c_func
(paren
id|entry.wait_address
comma
op_amp
id|entry.wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: ...Okay, there appears to be some data.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|rpc_recvfrom
id|rpc_recvfrom
c_func
(paren
r_struct
id|rpc_sock
op_star
id|rsock
comma
r_int
op_star
id|buf
comma
r_int
id|len
comma
r_struct
id|sockaddr
op_star
id|sap
comma
r_int
id|salen
comma
r_int
id|flags
)paren
(brace
r_struct
id|socket
op_star
id|sock
op_assign
id|rsock-&gt;sock
suffix:semicolon
r_struct
id|sockaddr
id|sa
suffix:semicolon
r_int
id|alen
op_assign
r_sizeof
(paren
id|sa
)paren
suffix:semicolon
r_int
r_int
id|oldfs
suffix:semicolon
r_int
id|result
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: receiving %d bytes max (buf %08lx)&bslash;n&quot;
comma
id|len
comma
(paren
r_int
)paren
id|buf
)paren
suffix:semicolon
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|get_ds
c_func
(paren
)paren
)paren
suffix:semicolon
id|result
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|recvfrom
c_func
(paren
id|sock
comma
id|buf
comma
id|len
comma
l_int|1
comma
id|flags
comma
op_amp
id|sa
comma
op_amp
id|alen
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: result = %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|alen
op_ne
id|salen
op_logical_or
id|memcmp
c_func
(paren
op_amp
id|sa
comma
id|sap
comma
id|alen
)paren
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: reply address mismatch... rejected.&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
macro_line|#endif
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Place the actual RPC call.&n; */
r_static
r_int
DECL|function|rpc_call_one
id|rpc_call_one
c_func
(paren
r_struct
id|rpc_sock
op_star
id|rsock
comma
r_struct
id|rpc_wait
op_star
id|slot
comma
r_struct
id|sockaddr
op_star
id|sap
comma
r_int
id|salen
comma
r_const
r_int
op_star
id|sndbuf
comma
r_int
id|slen
comma
r_int
op_star
id|rcvbuf
comma
r_int
id|rlen
)paren
(brace
r_struct
id|rpc_wait
op_star
id|rovr
op_assign
l_int|NULL
suffix:semicolon
r_int
id|result
suffix:semicolon
id|u32
id|xid
suffix:semicolon
r_int
id|safe
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: placing one call, rsock = %08lx, slot = %08lx, &quot;
l_string|&quot;sap = %08lx, salen = %d, &quot;
l_string|&quot;sndbuf = %08lx, slen = %d, rcvbuf = %08lx, rlen = %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|rsock
comma
(paren
r_int
)paren
id|slot
comma
(paren
r_int
)paren
id|sap
comma
id|salen
comma
(paren
r_int
)paren
id|sndbuf
comma
id|slen
comma
(paren
r_int
)paren
id|rcvbuf
comma
id|rlen
)paren
suffix:semicolon
id|result
op_assign
id|rpc_sendto
c_func
(paren
id|rsock
comma
id|sndbuf
comma
id|slen
comma
id|sap
comma
id|salen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
r_do
(brace
multiline_comment|/* We are not the receiver. Wait on the side lines. */
r_if
c_cond
(paren
id|rsock-&gt;head
op_ne
id|slot
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|slot-&gt;wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slot-&gt;gotit
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;timeout
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|rsock-&gt;shutdown
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC: aborting call due to shutdown.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
multiline_comment|/* wait for data to arrive */
id|result
op_assign
id|rpc_select
c_func
(paren
id|rsock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC: select error = %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|result
op_assign
id|rpc_recvfrom
c_func
(paren
id|rsock
comma
(paren
r_int
op_star
)paren
op_amp
id|xid
comma
r_sizeof
(paren
id|xid
)paren
comma
id|sap
comma
id|salen
comma
id|MSG_PEEK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
r_switch
c_cond
(paren
op_minus
id|result
)paren
(brace
r_case
id|EAGAIN
suffix:colon
r_case
id|ECONNREFUSED
suffix:colon
r_continue
suffix:semicolon
r_default
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;rpc_call: recv error = %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_case
id|ERESTARTSYS
suffix:colon
r_return
id|result
suffix:semicolon
)brace
)brace
multiline_comment|/* Look for the caller */
id|safe
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|rovr
op_assign
id|rsock-&gt;head
suffix:semicolon
id|rovr
suffix:semicolon
id|rovr
op_assign
id|rovr-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|safe
op_increment
OG
id|NRREQS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC: loop in request Q!!&bslash;n&quot;
)paren
suffix:semicolon
id|rovr
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rovr-&gt;xid
op_eq
id|xid
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rovr
op_logical_or
id|rovr-&gt;gotit
)paren
(brace
multiline_comment|/* bad XID or duplicate reply, discard dgram */
id|dprintk
c_func
(paren
l_string|&quot;RPC: bad XID or duplicate reply.&bslash;n&quot;
)paren
suffix:semicolon
id|rpc_recvfrom
c_func
(paren
id|rsock
comma
(paren
r_int
op_star
)paren
op_amp
id|xid
comma
r_sizeof
(paren
id|xid
)paren
comma
id|sap
comma
id|salen
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|rovr-&gt;gotit
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Now receive the reply */
id|result
op_assign
id|rpc_recvfrom
c_func
(paren
id|rsock
comma
id|rovr-&gt;buf
comma
id|rovr-&gt;len
comma
id|sap
comma
id|salen
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* If this is not for ourselves, wake up the caller */
r_if
c_cond
(paren
id|rovr
op_ne
id|slot
)paren
id|wake_up
c_func
(paren
op_amp
id|rovr-&gt;wait
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|rovr
op_ne
id|slot
)paren
suffix:semicolon
multiline_comment|/* This is somewhat tricky. We rely on the fact that we are able to&n;&t; * remove ourselves from the queues before the next reader is scheduled,&n;&t; * otherwise it would find that we&squot;re still at the head of the queue&n;&t; * and go to sleep again.&n;&t; */
r_if
c_cond
(paren
id|rsock-&gt;head
op_eq
id|slot
op_logical_and
id|slot-&gt;next
op_ne
l_int|NULL
)paren
id|wake_up
c_func
(paren
op_amp
id|slot-&gt;next-&gt;wait
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Generic RPC call routine. This handles retries and timeouts etc pp&n; */
r_int
DECL|function|rpc_call
id|rpc_call
c_func
(paren
r_struct
id|rpc_sock
op_star
id|rsock
comma
r_struct
id|sockaddr
op_star
id|sap
comma
r_int
id|addrlen
comma
r_const
r_int
op_star
id|sndbuf
comma
r_int
id|slen
comma
r_int
op_star
id|rcvbuf
comma
r_int
id|rlen
comma
r_struct
id|rpc_timeout
op_star
id|strategy
comma
r_int
id|flag
)paren
(brace
r_struct
id|rpc_wait
op_star
id|slot
suffix:semicolon
r_int
id|result
comma
id|retries
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
id|timeout
op_assign
id|strategy-&gt;init_timeout
suffix:semicolon
id|retries
op_assign
l_int|0
suffix:semicolon
id|slot
op_assign
l_int|NULL
suffix:semicolon
r_do
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC call TP1&bslash;n&quot;
)paren
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_eq
l_int|NULL
)paren
(brace
r_while
c_loop
(paren
(paren
id|slot
op_assign
id|rsock-&gt;free
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|ENOBUFS
suffix:semicolon
)brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|rsock-&gt;backlog
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;timeout
op_eq
l_int|0
)paren
(brace
id|result
op_assign
op_minus
id|ETIMEDOUT
suffix:semicolon
r_goto
id|timedout
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rsock-&gt;shutdown
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC: aborting call due to shutdown.&bslash;n&quot;
)paren
suffix:semicolon
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|dprintk
c_func
(paren
l_string|&quot;RPC call TP2&bslash;n&quot;
)paren
suffix:semicolon
id|slot-&gt;gotit
op_assign
l_int|0
suffix:semicolon
id|slot-&gt;xid
op_assign
op_star
(paren
id|u32
op_star
)paren
id|sndbuf
suffix:semicolon
id|slot-&gt;buf
op_assign
id|rcvbuf
suffix:semicolon
id|slot-&gt;len
op_assign
id|rlen
suffix:semicolon
id|rsock-&gt;free
op_assign
id|slot-&gt;next
suffix:semicolon
id|rpc_insque
c_func
(paren
id|rsock
comma
id|slot
)paren
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;RPC call TP3&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|rpc_call_one
c_func
(paren
id|rsock
comma
id|slot
comma
id|sap
comma
id|addrlen
comma
id|sndbuf
comma
id|slen
comma
id|rcvbuf
comma
id|rlen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
op_minus
id|ETIMEDOUT
)paren
r_break
suffix:semicolon
id|timedout
suffix:colon
id|dprintk
c_func
(paren
l_string|&quot;RPC call TP4&bslash;n&quot;
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: rpc_call_one returned timeout.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strategy-&gt;exponential
)paren
id|timeout
op_lshift_assign
l_int|1
suffix:semicolon
r_else
id|timeout
op_add_assign
id|strategy-&gt;increment
suffix:semicolon
r_if
c_cond
(paren
id|strategy-&gt;max_timeout
op_logical_and
id|timeout
op_ge
id|strategy-&gt;max_timeout
)paren
id|timeout
op_assign
id|strategy-&gt;max_timeout
suffix:semicolon
r_if
c_cond
(paren
id|strategy-&gt;retries
op_logical_and
op_increment
id|retries
op_ge
id|strategy-&gt;retries
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC call TP5&bslash;n&quot;
)paren
suffix:semicolon
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_ne
l_int|NULL
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;RPC call TP6&bslash;n&quot;
)paren
suffix:semicolon
id|rpc_remque
c_func
(paren
id|rsock
comma
id|slot
)paren
suffix:semicolon
id|slot-&gt;next
op_assign
id|rsock-&gt;free
suffix:semicolon
id|rsock-&gt;free
op_assign
id|slot
suffix:semicolon
multiline_comment|/* wake up tasks that haven&squot;t sent anything yet. (Waking&n;&t;&t; * up the first one on the wait queue would be enough) */
r_if
c_cond
(paren
id|rsock-&gt;backlog
)paren
id|wake_up
c_func
(paren
op_amp
id|rsock-&gt;backlog
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rsock-&gt;shutdown
)paren
id|wake_up
c_func
(paren
op_amp
id|rsock-&gt;shutwait
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_struct
id|rpc_sock
op_star
DECL|function|rpc_makesock
id|rpc_makesock
c_func
(paren
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|rpc_sock
op_star
id|rsock
suffix:semicolon
r_struct
id|rpc_wait
op_star
id|slot
suffix:semicolon
r_int
id|i
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;RPC: make RPC socket...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rsock
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|rpc_sock
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|rsock
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|rsock
)paren
)paren
suffix:semicolon
multiline_comment|/* Nnnngh! */
id|rsock-&gt;sock
op_assign
op_amp
id|file-&gt;f_inode-&gt;u.socket_i
suffix:semicolon
id|rsock-&gt;file
op_assign
id|file
suffix:semicolon
id|rsock-&gt;free
op_assign
id|rsock-&gt;waiting
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|slot
op_assign
id|rsock-&gt;waiting
suffix:semicolon
id|i
OL
id|NRREQS
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
comma
id|slot
op_increment
)paren
id|slot-&gt;next
op_assign
id|slot
op_plus
l_int|1
suffix:semicolon
id|slot-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* --- taken care of by memset above ---&n;&t;rsock-&gt;backlog = NULL;&n;&t;rsock-&gt;head = rsock-&gt;tail = NULL;&n;&n;&t;rsock-&gt;shutwait = NULL;&n;&t;rsock-&gt;shutdown = 0;&n;&t; */
id|dprintk
c_func
(paren
l_string|&quot;RPC: made socket %08lx&quot;
comma
(paren
r_int
)paren
id|rsock
)paren
suffix:semicolon
r_return
id|rsock
suffix:semicolon
)brace
r_int
DECL|function|rpc_closesock
id|rpc_closesock
c_func
(paren
r_struct
id|rpc_sock
op_star
id|rsock
)paren
(brace
r_int
r_int
id|t0
op_assign
id|jiffies
suffix:semicolon
id|rsock-&gt;shutdown
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|rsock-&gt;head
op_logical_or
id|rsock-&gt;backlog
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|rsock-&gt;shutwait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
macro_line|#if 1
r_if
c_cond
(paren
id|t0
op_logical_and
id|t0
op_minus
id|jiffies
OG
l_int|60
op_star
id|HZ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RPC: hanging in rpc_closesock.&bslash;n&quot;
)paren
suffix:semicolon
id|t0
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
)brace
id|kfree
c_func
(paren
id|rsock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
