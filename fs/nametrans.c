multiline_comment|/*&n; * $Id: nametrans.c,v 1.2 1997/06/04 23:45:44 davem Exp $&n; *&n; * linux/fs/nametrans.c - context-dependend filename suffixes.&n; * Copyright (C) 1997, Thomas Schoebel-Theuer,&n; * &lt;schoebel@informatik.uni-stuttgart.de&gt;.&n; *&n; * translates names of the form &quot;filename#host=myhost#&quot; to &quot;filename&quot;&n; * as if both names were hardlinked to the same file.&n; * benefit: diskless clients can mount the / filesystem of the&n; * server if /etc/fstab (and other config files) are organized using&n; * context suffixes.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/utsname.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/nametrans.h&gt;
DECL|variable|nametrans_txt
r_char
id|nametrans_txt
(braket
id|MAX_DEFAULT_TRANSLEN
)braket
op_assign
l_string|&quot;&quot;
suffix:semicolon
DECL|variable|global_trans
r_static
r_struct
id|translations
op_star
id|global_trans
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|default_trans
r_static
r_int
id|default_trans
op_assign
l_int|1
suffix:semicolon
DECL|variable|version
r_static
r_const
r_char
id|version
(braket
)braket
op_assign
l_string|&quot;revision: 2.3 &lt;schoebel@informatik.uni-stuttgart.de&gt;&quot;
suffix:semicolon
DECL|variable|translations_dirty
r_int
id|translations_dirty
op_assign
l_int|1
suffix:semicolon
DECL|variable|transl_names
r_static
r_char
op_star
id|transl_names
(braket
)braket
op_assign
(brace
macro_line|#ifdef CONFIG_TR_NODENAME
l_string|&quot;host=&quot;
comma
id|system_utsname.nodename
comma
macro_line|#endif
macro_line|#ifdef CONFIG_TR_KERNNAME
l_string|&quot;kname=&quot;
comma
id|CONFIG_KERNNAME
comma
macro_line|#endif
macro_line|#ifdef CONFIG_TR_KERNTYPE
l_string|&quot;ktype=&quot;
comma
id|CONFIG_KERNTYPE
comma
macro_line|#endif
macro_line|#ifdef CONFIG_TR_MACHINE
l_string|&quot;machine=&quot;
comma
id|system_utsname.machine
comma
macro_line|#endif
macro_line|#ifdef CONFIG_TR_SYSNAME
l_string|&quot;system=&quot;
comma
id|system_utsname.sysname
comma
macro_line|#endif
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* Convert and do syntax checking. */
DECL|function|convert
r_static
r_void
id|convert
c_func
(paren
r_char
op_star
id|txt
comma
r_struct
id|translations
op_star
id|res
)paren
(brace
r_char
op_star
id|tmp
op_assign
id|txt
suffix:semicolon
r_char
op_star
id|space
op_assign
(paren
r_char
op_star
)paren
id|res
op_plus
r_sizeof
(paren
r_struct
id|translations
)paren
suffix:semicolon
id|res-&gt;count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|tmp
)paren
(brace
r_struct
id|qstr
op_star
id|name
op_assign
op_amp
id|res-&gt;name
(braket
id|res-&gt;count
)braket
suffix:semicolon
r_struct
id|qstr
op_star
id|c_name
op_assign
op_amp
id|res-&gt;c_name
(braket
id|res-&gt;count
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
r_char
op_star
id|p
op_assign
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_increment
op_ne
l_char|&squot;#&squot;
)paren
(brace
r_goto
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|p
op_logical_and
op_star
id|p
op_ne
l_char|&squot;=&squot;
op_logical_and
op_star
id|p
op_ne
l_char|&squot;:&squot;
)paren
(brace
id|p
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|p
op_ne
l_char|&squot;=&squot;
)paren
(brace
r_goto
id|next
suffix:semicolon
)brace
id|p
op_increment
suffix:semicolon
id|len
op_assign
(paren
r_int
r_int
)paren
id|p
op_minus
(paren
r_int
r_int
)paren
id|tmp
suffix:semicolon
id|c_name-&gt;name
op_assign
id|space
suffix:semicolon
id|memcpy
c_func
(paren
id|space
comma
id|tmp
comma
id|len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|space
op_plus
id|len
comma
l_string|&quot;CREATE#&quot;
comma
l_int|8
)paren
suffix:semicolon
id|c_name-&gt;len
op_assign
id|len
op_plus
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|c_name-&gt;len
op_ge
id|MAX_TRANS_SUFFIX
)paren
(brace
r_goto
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|p
op_logical_and
op_star
id|p
op_ne
l_char|&squot;#&squot;
op_logical_and
op_star
id|p
op_ne
l_char|&squot;:&squot;
)paren
(brace
id|p
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|p
op_ne
l_char|&squot;#&squot;
)paren
(brace
r_goto
id|next
suffix:semicolon
)brace
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_ne
l_char|&squot;:&squot;
op_logical_and
op_star
id|p
)paren
(brace
r_goto
id|next
suffix:semicolon
)brace
id|space
op_add_assign
id|len
op_plus
l_int|8
suffix:semicolon
id|name-&gt;len
op_assign
id|len
op_assign
(paren
r_int
r_int
)paren
id|p
op_minus
(paren
r_int
r_int
)paren
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|MAX_TRANS_SUFFIX
)paren
(brace
r_goto
id|next
suffix:semicolon
)brace
id|name-&gt;name
op_assign
id|space
suffix:semicolon
id|memcpy
c_func
(paren
id|space
comma
id|tmp
comma
id|len
)paren
suffix:semicolon
id|space
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|space
op_add_assign
id|len
op_plus
l_int|1
suffix:semicolon
id|res-&gt;count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|res-&gt;count
op_ge
id|MAX_TRANSLATIONS
op_logical_or
(paren
r_int
r_int
)paren
id|space
op_minus
(paren
r_int
r_int
)paren
id|res
op_ge
id|PAGE_SIZE
op_minus
l_int|2
op_star
id|MAX_TRANS_SUFFIX
)paren
(brace
r_return
suffix:semicolon
)brace
id|next
suffix:colon
r_while
c_loop
(paren
op_star
id|p
op_logical_and
op_star
id|p
op_increment
op_ne
l_char|&squot;:&squot;
)paren
(brace
suffix:semicolon
)brace
id|tmp
op_assign
id|p
suffix:semicolon
)brace
)brace
DECL|function|trans_to_string
r_static
r_inline
r_void
id|trans_to_string
c_func
(paren
r_struct
id|translations
op_star
id|trans
comma
r_char
op_star
id|buf
comma
r_int
id|maxlen
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|trans-&gt;count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|len
op_assign
id|trans-&gt;name
(braket
id|i
)braket
dot
id|len
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
id|maxlen
)paren
(brace
id|memcpy
c_func
(paren
id|buf
comma
id|trans-&gt;name
(braket
id|i
)braket
dot
id|name
comma
id|len
)paren
suffix:semicolon
id|buf
op_add_assign
id|len
suffix:semicolon
id|maxlen
op_sub_assign
id|len
suffix:semicolon
op_star
id|buf
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
id|maxlen
op_decrement
suffix:semicolon
)brace
)brace
id|buf
op_decrement
suffix:semicolon
op_star
id|buf
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
DECL|function|default_nametrans
r_static
r_inline
r_void
id|default_nametrans
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_char
op_star
id|res
op_assign
id|buf
suffix:semicolon
r_char
op_star
op_star
id|entry
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
id|transl_names
suffix:semicolon
op_star
id|entry
suffix:semicolon
id|entry
op_increment
)paren
(brace
op_star
id|res
op_increment
op_assign
l_char|&squot;#&squot;
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
op_star
id|entry
suffix:semicolon
op_star
id|ptr
suffix:semicolon
id|ptr
op_increment
)paren
(brace
op_star
id|res
op_increment
op_assign
op_star
id|ptr
suffix:semicolon
)brace
id|entry
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|ptr
op_assign
op_star
id|entry
suffix:semicolon
op_star
id|ptr
suffix:semicolon
id|ptr
op_increment
)paren
(brace
op_star
id|res
op_increment
op_assign
op_star
id|ptr
suffix:semicolon
)brace
op_star
id|res
op_increment
op_assign
l_char|&squot;#&squot;
suffix:semicolon
op_star
id|res
op_increment
op_assign
l_char|&squot;:&squot;
suffix:semicolon
)brace
id|res
op_decrement
suffix:semicolon
op_star
id|res
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
DECL|function|nametrans_setup
r_void
id|nametrans_setup
c_func
(paren
r_char
op_star
id|line
)paren
(brace
r_if
c_cond
(paren
id|line
)paren
(brace
id|default_trans
op_assign
(paren
op_logical_neg
id|line
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|global_trans
)paren
(brace
multiline_comment|/* This can happen at boot time, and there is no chance&n;&t;&t;&t; * to allocate memory at this early stage.&n;&t;&t;&t; */
id|strncpy
c_func
(paren
id|nametrans_txt
comma
id|line
comma
id|MAX_DEFAULT_TRANSLEN
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|default_trans
)paren
(brace
id|default_nametrans
c_func
(paren
id|nametrans_txt
)paren
suffix:semicolon
id|line
op_assign
id|nametrans_txt
suffix:semicolon
)brace
id|convert
c_func
(paren
id|line
comma
id|global_trans
)paren
suffix:semicolon
multiline_comment|/* Show what really was recognized after parsing... */
id|trans_to_string
c_func
(paren
id|global_trans
comma
id|nametrans_txt
comma
id|MAX_DEFAULT_TRANSLEN
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* If the _first_ environment variable is &quot;NAMETRANS&quot;, return&n; * a pointer to the list of appendices.&n; * You can set the first environment variable using&n; * &squot;env - NAMETRANS=... &quot;`env`&quot; command ...&squot;&n; */
DECL|function|env_transl
r_char
op_star
id|env_transl
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|env
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|current
op_logical_and
id|current-&gt;mm
op_logical_and
(paren
id|env
op_assign
(paren
r_char
op_star
)paren
id|current-&gt;mm-&gt;env_start
)paren
op_logical_and
op_logical_neg
id|segment_eq
c_func
(paren
id|get_ds
c_func
(paren
)paren
comma
id|get_fs
c_func
(paren
)paren
)paren
op_logical_and
id|current-&gt;mm-&gt;env_end
op_ge
id|current-&gt;mm-&gt;env_start
op_plus
l_int|10
op_logical_and
op_logical_neg
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|env
comma
l_int|10
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
r_char
id|c
suffix:semicolon
id|get_user
c_func
(paren
id|c
comma
id|env
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
l_string|&quot;NAMETRANS=&quot;
(braket
id|i
)braket
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|env
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If name has the correct suffix &quot;#keyword=correct_context#&quot;,&n; * return position of the suffix, else 0.&n; */
DECL|function|testname
r_char
op_star
id|testname
c_func
(paren
r_int
id|restricted
comma
r_char
op_star
id|name
)paren
(brace
r_char
op_star
id|ptr
op_assign
id|name
suffix:semicolon
r_char
op_star
id|cut
suffix:semicolon
r_char
op_star
id|env
suffix:semicolon
r_struct
id|translations
op_star
id|trans
suffix:semicolon
r_int
id|i
comma
id|len
suffix:semicolon
r_char
id|c
comma
id|tmp
suffix:semicolon
id|env
op_assign
id|env_transl
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_TRANS_RESTRICT
r_if
c_cond
(paren
op_logical_neg
id|env
op_logical_and
id|restricted
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
macro_line|#else
(paren
r_void
)paren
id|restricted
suffix:semicolon
multiline_comment|/* inhibit parameter usage warning */
macro_line|#endif
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|c
comma
id|ptr
)paren
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c
op_logical_and
id|c
op_ne
l_char|&squot;#&squot;
)paren
(brace
id|ptr
op_increment
suffix:semicolon
id|__get_user
c_func
(paren
id|c
comma
id|ptr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
id|cut
op_assign
id|ptr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|c
comma
id|ptr
)paren
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c
op_logical_and
id|c
op_ne
l_char|&squot;#&squot;
)paren
(brace
id|ptr
op_increment
suffix:semicolon
id|get_user
c_func
(paren
id|c
comma
id|ptr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
id|get_user
c_func
(paren
id|tmp
comma
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
id|trans
op_assign
id|get_translations
c_func
(paren
id|env
)paren
suffix:semicolon
id|len
op_assign
(paren
r_int
r_int
)paren
id|ptr
op_minus
(paren
r_int
r_int
)paren
id|cut
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|trans-&gt;count
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|trans-&gt;name
(braket
id|i
)braket
dot
id|len
op_eq
id|len
)paren
(brace
r_const
r_char
op_star
id|p1
op_assign
id|cut
suffix:semicolon
r_const
r_char
op_star
id|p2
op_assign
id|trans-&gt;name
(braket
id|i
)braket
dot
id|name
suffix:semicolon
id|get_user
c_func
(paren
id|c
comma
id|p1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|c
op_logical_and
id|c
op_eq
op_star
id|p2
op_increment
)paren
(brace
id|p1
op_increment
suffix:semicolon
id|get_user
c_func
(paren
id|c
comma
id|p1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
r_return
id|cut
suffix:semicolon
)brace
)brace
id|done
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|check_dirty
r_static
r_inline
r_void
id|check_dirty
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|translations_dirty
op_logical_and
id|default_trans
)paren
(brace
id|nametrans_setup
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
id|translations_dirty
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|get_translations
r_struct
id|translations
op_star
id|get_translations
c_func
(paren
r_char
op_star
id|env
)paren
(brace
r_struct
id|translations
op_star
id|res
suffix:semicolon
r_if
c_cond
(paren
id|env
)paren
(brace
r_char
op_star
id|env_txt
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
id|strncpy_from_user
c_func
(paren
id|env_txt
comma
id|env
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|res
op_assign
(paren
r_struct
id|translations
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
id|convert
c_func
(paren
id|env_txt
comma
id|res
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|env_txt
)paren
suffix:semicolon
)brace
r_else
(brace
id|check_dirty
c_func
(paren
)paren
suffix:semicolon
id|res
op_assign
id|global_trans
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|function|nametrans_dostring
r_int
id|nametrans_dostring
c_func
(paren
id|ctl_table
op_star
id|table
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|lenp
)paren
(brace
r_int
id|res
suffix:semicolon
id|check_dirty
c_func
(paren
)paren
suffix:semicolon
id|res
op_assign
id|proc_dostring
c_func
(paren
id|table
comma
id|write
comma
id|filp
comma
id|buffer
comma
id|lenp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
op_logical_and
id|write
)paren
(brace
id|nametrans_setup
c_func
(paren
id|nametrans_txt
)paren
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|function|nametrans_string
r_int
id|nametrans_string
c_func
(paren
id|ctl_table
op_star
id|table
comma
r_int
op_star
id|name
comma
r_int
id|nlen
comma
r_void
op_star
id|oldval
comma
r_int
op_star
id|oldlenp
comma
r_void
op_star
id|newval
comma
r_int
id|newlen
comma
r_void
op_star
op_star
id|context
)paren
(brace
r_int
id|res
suffix:semicolon
id|check_dirty
c_func
(paren
)paren
suffix:semicolon
id|res
op_assign
id|sysctl_string
c_func
(paren
id|table
comma
id|name
comma
id|nlen
comma
id|oldval
comma
id|oldlenp
comma
id|newval
comma
id|newlen
comma
id|context
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|res
op_logical_and
id|newval
op_logical_and
id|newlen
)paren
(brace
id|nametrans_setup
c_func
(paren
id|nametrans_txt
)paren
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|function|init_nametrans
r_void
id|init_nametrans
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|global_trans
)paren
(brace
id|global_trans
op_assign
(paren
r_struct
id|translations
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|global_trans
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;NAMETRANS: No free memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|nametrans_setup
c_func
(paren
id|nametrans_txt
)paren
suffix:semicolon
multiline_comment|/* Notify user for the default/supplied translations.&n;&t; * Extremely useful for finding translation problems.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;Nametrans %s&bslash;nNametrans %s: %s&bslash;n&quot;
comma
id|version
comma
id|default_trans
ques
c_cond
l_string|&quot;default translations&quot;
suffix:colon
l_string|&quot;external parameter&quot;
comma
id|nametrans_txt
)paren
suffix:semicolon
)brace
eof
