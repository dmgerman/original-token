multiline_comment|/*&n; *  linux/fs/locks.c&n; *&n; *  Provide support for fcntl()&squot;s F_GETLK, F_SETLK, and F_SETLKW calls.&n; *  Doug Evans (dje@spiff.uucp), August 07, 1992&n; *&n; *  Deadlock detection added.&n; *  FIXME: one thing isn&squot;t handled yet:&n; *&t;- mandatory locks (requires lots of changes elsewhere)&n; *  Kelly Carmichael (kelly@[142.24.8.65]), September 17, 1994.&n; *&n; *  Miscellaneous edits, and a total rewrite of posix_lock_file() code.&n; *  Kai Petzke (wpp@marie.physik.tu-berlin.de), 1994&n; *  &n; *  Converted file_lock_table to a linked list from an array, which eliminates&n; *  the limits on how many active file locks are open.&n; *  Chad Page (pageone@netcom.com), November 27, 1994&n; * &n; *  Removed dependency on file descriptors. dup()&squot;ed file descriptors now&n; *  get the same locks as the original file descriptors, and a close() on&n; *  any file descriptor removes ALL the locks on the file for the current&n; *  process. Since locks still depend on the process id, locks are inherited&n; *  after an exec() but not after a fork(). This agrees with POSIX, and both&n; *  BSD and SVR4 practice.&n; *  Andy Walker (andy@lysaker.kvaerner.no), February 14, 1995&n; *&n; *  Scrapped free list which is redundant now that we allocate locks&n; *  dynamically with kmalloc()/kfree().&n; *  Andy Walker (andy@lysaker.kvaerner.no), February 21, 1995&n; *&n; *  Implemented two lock personalities - FL_FLOCK and FL_POSIX.&n; *&n; *  FL_POSIX locks are created with calls to fcntl() and lockf() through the&n; *  fcntl() system call. They have the semantics described above.&n; *&n; *  FL_FLOCK locks are created with calls to flock(), through the flock()&n; *  system call, which is new. Old C libraries implement flock() via fcntl()&n; *  and will continue to use the old, broken implementation.&n; *&n; *  FL_FLOCK locks follow the 4.4 BSD flock() semantics. They are associated&n; *  with a file pointer (filp). As a result they can be shared by a parent&n; *  process and its children after a fork(). They are removed when the last&n; *  file descriptor referring to the file pointer is closed (unless explicitly&n; *  unlocked). &n; *&n; *  FL_FLOCK locks never deadlock, an existing lock is always removed before&n; *  upgrading from shared to exclusive (or vice versa). When this happens&n; *  any processes blocked by the current lock are woken up and allowed to&n; *  run before the new lock is applied.&n; *  Andy Walker (andy@lysaker.kvaerner.no), June 09, 1995&n; *&n; *  Removed some race conditions in flock_lock_file(), marked other possible&n; *  races. Just grep for FIXME to see them. &n; *  Dmitry Gorodchanin (begemot@bgm.rosprint.net), February 09, 1996.&n; *&n; *  Addressed Dmitry&squot;s concerns. Deadlock checking no longer recursive.&n; *  Lock allocation changed to GFP_ATOMIC as we can&squot;t afford to sleep&n; *  once we&squot;ve checked for blocking and deadlocking.&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 03, 1996.&n; *&n; *  Initial implementation of mandatory locks. SunOS turned out to be&n; *  a rotten model, so I implemented the &quot;obvious&quot; semantics.&n; *  See &squot;linux/Documentation/mandatory.txt&squot; for details.&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 06, 1996.&n; *&n; *  Don&squot;t allow mandatory locks on mmap()&squot;ed files. Added simple functions to&n; *  check if a file has mandatory locks, used by mmap(), open() and creat() to&n; *  see if system call should be rejected. Ref. HP-UX/SunOS/Solaris Reference&n; *  Manual, Section 2.&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 09, 1996.&n; *&n; *  Tidied up block list handling. Added &squot;/proc/locks&squot; interface.&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 24, 1996.&n; *&n; *  Fixed deadlock condition for pathological code that mixes calls to&n; *  flock() and fcntl().&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 29, 1996.&n; *&n; *  Allow only one type of locking scheme (FL_POSIX or FL_FLOCK) to be in use&n; *  for a given file at a time. Changed the CONFIG_LOCK_MANDATORY scheme to&n; *  guarantee sensible behaviour in the case where file system modules might&n; *  be compiled with different options than the kernel itself.&n; *  Andy Walker (andy@lysaker.kvaerner.no), May 15, 1996.&n; *&n; *  Added a couple of missing wake_up() calls. Thanks to Thomas Meckel&n; *  (Thomas.Meckel@mni.fh-giessen.de) for spotting this.&n; *  Andy Walker (andy@lysaker.kvaerner.no), May 15, 1996.&n; *&n; *  Changed FL_POSIX locks to use the block list in the same way as FL_FLOCK&n; *  locks. Changed process synchronisation to avoid dereferencing locks that&n; *  have already been freed.&n; *  Andy Walker (andy@lysaker.kvaerner.no), Sep 21, 1996.&n; *&n; *  Made the block list a circular list to minimise searching in the list.&n; *  Andy Walker (andy@lysaker.kvaerner.no), Sep 25, 1996.&n; *&n; *  Made mandatory locking a mount option. Default is not to allow mandatory&n; *  locking.&n; *  Andy Walker (andy@lysaker.kvaerner.no), Oct 04, 1996.&n; *&n; *  Some adaptations for NFS support.&n; *  Olaf Kirch (okir@monad.swb.de), Dec 1996,&n; *&n; *  Fixed /proc/locks interface so that we can&squot;t overrun the buffer we are handed.&n; *  Andy Walker (andy@lysaker.kvaerner.no), May 12, 1997.&n; */
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|OFFSET_MAX
mdefine_line|#define OFFSET_MAX&t;((off_t)0x7fffffff)&t;/* FIXME: move elsewhere? */
r_static
r_int
id|flock_make_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
comma
r_int
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_int
id|posix_make_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
comma
r_struct
id|flock
op_star
id|l
)paren
suffix:semicolon
r_static
r_int
id|flock_locks_conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
suffix:semicolon
r_static
r_int
id|posix_locks_conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
suffix:semicolon
r_static
r_int
id|locks_conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
suffix:semicolon
r_static
r_int
id|flock_lock_file
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|caller
comma
r_int
r_int
id|wait
)paren
suffix:semicolon
r_static
r_int
id|posix_locks_deadlock
c_func
(paren
r_struct
id|file_lock
op_star
id|caller
comma
r_struct
id|file_lock
op_star
id|blocker
)paren
suffix:semicolon
r_static
r_struct
id|file_lock
op_star
id|locks_alloc_lock
c_func
(paren
r_struct
id|file_lock
op_star
id|fl
)paren
suffix:semicolon
r_static
r_void
id|locks_insert_lock
c_func
(paren
r_struct
id|file_lock
op_star
op_star
id|pos
comma
r_struct
id|file_lock
op_star
id|fl
)paren
suffix:semicolon
r_static
r_void
id|locks_delete_lock
c_func
(paren
r_struct
id|file_lock
op_star
op_star
id|thisfl_p
comma
r_int
r_int
id|wait
)paren
suffix:semicolon
r_static
r_char
op_star
id|lock_get_status
c_func
(paren
r_struct
id|file_lock
op_star
id|fl
comma
r_int
id|id
comma
r_char
op_star
id|pfx
)paren
suffix:semicolon
r_static
r_void
id|locks_insert_block
c_func
(paren
r_struct
id|file_lock
op_star
id|blocker
comma
r_struct
id|file_lock
op_star
id|waiter
)paren
suffix:semicolon
r_static
r_void
id|locks_delete_block
c_func
(paren
r_struct
id|file_lock
op_star
id|blocker
comma
r_struct
id|file_lock
op_star
id|waiter
)paren
suffix:semicolon
r_static
r_void
id|locks_wake_up_blocks
c_func
(paren
r_struct
id|file_lock
op_star
id|blocker
comma
r_int
r_int
id|wait
)paren
suffix:semicolon
DECL|variable|file_lock_table
r_struct
id|file_lock
op_star
id|file_lock_table
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Free lock not inserted in any queue.&n; */
DECL|function|locks_free_lock
r_static
r_inline
r_void
id|locks_free_lock
c_func
(paren
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|fl-&gt;fl_wait
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Aarggh: attempting to free lock with active wait queue - shoot Andy&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_nextblock
op_ne
l_int|NULL
op_logical_or
id|fl-&gt;fl_prevblock
op_ne
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;Aarggh: attempting to free lock with active block list - shoot Andy&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fl
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check if two locks overlap each other.&n; */
DECL|function|locks_overlap
r_static
r_inline
r_int
id|locks_overlap
c_func
(paren
r_struct
id|file_lock
op_star
id|fl1
comma
r_struct
id|file_lock
op_star
id|fl2
)paren
(brace
r_return
(paren
(paren
id|fl1-&gt;fl_end
op_ge
id|fl2-&gt;fl_start
)paren
op_logical_and
(paren
id|fl2-&gt;fl_end
op_ge
id|fl1-&gt;fl_start
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Check whether two locks have the same owner&n; */
r_static
r_inline
r_int
DECL|function|locks_same_owner
id|locks_same_owner
c_func
(paren
r_struct
id|file_lock
op_star
id|fl1
comma
r_struct
id|file_lock
op_star
id|fl2
)paren
(brace
r_return
(paren
id|fl1-&gt;fl_owner
op_eq
id|fl2-&gt;fl_owner
)paren
op_logical_and
(paren
id|fl1-&gt;fl_pid
op_eq
id|fl2-&gt;fl_pid
)paren
suffix:semicolon
)brace
multiline_comment|/* Insert waiter into blocker&squot;s block list.&n; * We use a circular list so that processes can be easily woken up in&n; * the order they blocked. The documentation doesn&squot;t require this but&n; * it seems seems like the reasonable thing to do.&n; */
DECL|function|locks_insert_block
r_static
r_void
id|locks_insert_block
c_func
(paren
r_struct
id|file_lock
op_star
id|blocker
comma
r_struct
id|file_lock
op_star
id|waiter
)paren
(brace
r_struct
id|file_lock
op_star
id|prevblock
suffix:semicolon
r_if
c_cond
(paren
id|blocker-&gt;fl_prevblock
op_eq
l_int|NULL
)paren
multiline_comment|/* No previous waiters - list is empty */
id|prevblock
op_assign
id|blocker
suffix:semicolon
r_else
multiline_comment|/* Previous waiters exist - add to end of list */
id|prevblock
op_assign
id|blocker-&gt;fl_prevblock
suffix:semicolon
id|prevblock-&gt;fl_nextblock
op_assign
id|waiter
suffix:semicolon
id|blocker-&gt;fl_prevblock
op_assign
id|waiter
suffix:semicolon
id|waiter-&gt;fl_nextblock
op_assign
id|blocker
suffix:semicolon
id|waiter-&gt;fl_prevblock
op_assign
id|prevblock
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Remove waiter from blocker&squot;s block list.&n; * When blocker ends up pointing to itself then the list is empty.&n; */
DECL|function|locks_delete_block
r_static
r_void
id|locks_delete_block
c_func
(paren
r_struct
id|file_lock
op_star
id|blocker
comma
r_struct
id|file_lock
op_star
id|waiter
)paren
(brace
r_struct
id|file_lock
op_star
id|nextblock
suffix:semicolon
r_struct
id|file_lock
op_star
id|prevblock
suffix:semicolon
id|nextblock
op_assign
id|waiter-&gt;fl_nextblock
suffix:semicolon
id|prevblock
op_assign
id|waiter-&gt;fl_prevblock
suffix:semicolon
r_if
c_cond
(paren
id|nextblock
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|nextblock-&gt;fl_prevblock
op_assign
id|prevblock
suffix:semicolon
id|prevblock-&gt;fl_nextblock
op_assign
id|nextblock
suffix:semicolon
id|waiter-&gt;fl_prevblock
op_assign
id|waiter-&gt;fl_nextblock
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|blocker-&gt;fl_nextblock
op_eq
id|blocker
)paren
multiline_comment|/* No more locks on blocker&squot;s blocked list */
id|blocker-&gt;fl_prevblock
op_assign
id|blocker-&gt;fl_nextblock
op_assign
l_int|NULL
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* The following two are for the benefit of lockd.&n; */
r_void
DECL|function|posix_block_lock
id|posix_block_lock
c_func
(paren
r_struct
id|file_lock
op_star
id|blocker
comma
r_struct
id|file_lock
op_star
id|waiter
)paren
(brace
id|locks_insert_block
c_func
(paren
id|blocker
comma
id|waiter
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_void
DECL|function|posix_unblock_lock
id|posix_unblock_lock
c_func
(paren
r_struct
id|file_lock
op_star
id|waiter
)paren
(brace
r_if
c_cond
(paren
id|waiter-&gt;fl_prevblock
)paren
id|locks_delete_block
c_func
(paren
id|waiter-&gt;fl_prevblock
comma
id|waiter
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Wake up processes blocked waiting for blocker.&n; * If told to wait then schedule the processes until the block list&n; * is empty, otherwise empty the block list ourselves.&n; */
DECL|function|locks_wake_up_blocks
r_static
r_void
id|locks_wake_up_blocks
c_func
(paren
r_struct
id|file_lock
op_star
id|blocker
comma
r_int
r_int
id|wait
)paren
(brace
r_struct
id|file_lock
op_star
id|waiter
suffix:semicolon
r_while
c_loop
(paren
(paren
id|waiter
op_assign
id|blocker-&gt;fl_nextblock
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|waiter-&gt;fl_notify
)paren
id|waiter
op_member_access_from_pointer
id|fl_notify
c_func
(paren
id|waiter
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|waiter-&gt;fl_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
multiline_comment|/* Let the blocked process remove waiter from the&n;&t;&t;&t; * block list when it gets scheduled.&n;&t;&t;&t; */
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_else
multiline_comment|/* Remove waiter from the block list, because by the&n;&t;&t;&t; * time it wakes up blocker won&squot;t exist any more.&n;&t;&t;&t; */
id|locks_delete_block
c_func
(paren
id|blocker
comma
id|waiter
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* flock() system call entry point. Apply a FL_FLOCK style lock to&n; * an open file descriptor.&n; */
DECL|function|sys_flock
id|asmlinkage
r_int
id|sys_flock
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
)paren
(brace
r_struct
id|file_lock
id|file_lock
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fd
op_ge
id|NR_OPEN
)paren
op_logical_or
op_logical_neg
(paren
id|filp
op_assign
id|current-&gt;files-&gt;fd
(braket
id|fd
)braket
)paren
)paren
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|flock_make_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
comma
id|cmd
)paren
)paren
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|file_lock.fl_type
op_ne
id|F_UNLCK
)paren
op_logical_and
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
l_int|3
)paren
)paren
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
r_else
id|error
op_assign
id|flock_lock_file
c_func
(paren
id|filp
comma
op_amp
id|file_lock
comma
(paren
id|cmd
op_amp
(paren
id|LOCK_UN
op_or
id|LOCK_NB
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
multiline_comment|/* Report the first existing lock that would conflict with l.&n; * This implements the F_GETLK command of fcntl().&n; */
DECL|function|fcntl_getlk
r_int
id|fcntl_getlk
c_func
(paren
r_int
r_int
id|fd
comma
r_struct
id|flock
op_star
id|l
)paren
(brace
r_struct
id|flock
id|flock
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|file_lock
op_star
id|fl
comma
id|file_lock
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fd
op_ge
id|NR_OPEN
)paren
op_logical_or
op_logical_neg
(paren
id|filp
op_assign
id|current-&gt;files-&gt;fd
(braket
id|fd
)braket
)paren
)paren
r_return
(paren
op_minus
id|EBADF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|flock
comma
id|l
comma
r_sizeof
(paren
id|flock
)paren
)paren
)paren
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flock.l_type
op_ne
id|F_RDLCK
)paren
op_logical_and
(paren
id|flock.l_type
op_ne
id|F_WRLCK
)paren
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp-&gt;f_inode
op_logical_or
op_logical_neg
id|posix_make_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
comma
op_amp
id|flock
)paren
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_op-&gt;lock
)paren
(brace
id|error
op_assign
id|filp-&gt;f_op
op_member_access_from_pointer
id|lock
c_func
(paren
id|filp-&gt;f_inode
comma
id|filp
comma
id|F_GETLK
comma
op_amp
id|file_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
id|fl
op_assign
op_amp
id|file_lock
suffix:semicolon
)brace
r_else
(brace
id|fl
op_assign
id|posix_test_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fl
op_ne
l_int|NULL
)paren
(brace
id|flock.l_pid
op_assign
id|fl-&gt;fl_pid
suffix:semicolon
id|flock.l_start
op_assign
id|fl-&gt;fl_start
suffix:semicolon
id|flock.l_len
op_assign
id|fl-&gt;fl_end
op_eq
id|OFFSET_MAX
ques
c_cond
l_int|0
suffix:colon
id|fl-&gt;fl_end
op_minus
id|fl-&gt;fl_start
op_plus
l_int|1
suffix:semicolon
id|flock.l_whence
op_assign
l_int|0
suffix:semicolon
id|flock.l_type
op_assign
id|fl-&gt;fl_type
suffix:semicolon
r_return
(paren
id|copy_to_user
c_func
(paren
id|l
comma
op_amp
id|flock
comma
r_sizeof
(paren
id|flock
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|flock.l_type
op_assign
id|F_UNLCK
suffix:semicolon
)brace
r_return
(paren
id|copy_to_user
c_func
(paren
id|l
comma
op_amp
id|flock
comma
r_sizeof
(paren
id|flock
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Apply the lock described by l to an open file descriptor.&n; * This implements both the F_SETLK and F_SETLKW commands of fcntl().&n; */
DECL|function|fcntl_setlk
r_int
id|fcntl_setlk
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
comma
r_struct
id|flock
op_star
id|l
)paren
(brace
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|file_lock
id|file_lock
suffix:semicolon
r_struct
id|flock
id|flock
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/* Get arguments and validate them ...&n;&t; */
r_if
c_cond
(paren
(paren
id|fd
op_ge
id|NR_OPEN
)paren
op_logical_or
op_logical_neg
(paren
id|filp
op_assign
id|current-&gt;files-&gt;fd
(braket
id|fd
)braket
)paren
)paren
r_return
(paren
op_minus
id|EBADF
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inode
op_assign
id|filp-&gt;f_inode
)paren
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t allow mandatory locks on files that may be memory mapped&n;&t; * and shared.&n;&t; */
r_if
c_cond
(paren
id|IS_MANDLOCK
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_ISGID
op_or
id|S_IXGRP
)paren
)paren
op_eq
id|S_ISGID
op_logical_and
id|inode-&gt;i_mmap
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
id|inode-&gt;i_mmap
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_MAYSHARE
)paren
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next_share
suffix:semicolon
)brace
r_while
c_loop
(paren
id|vma
op_ne
id|inode-&gt;i_mmap
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|flock
comma
id|l
comma
r_sizeof
(paren
id|flock
)paren
)paren
)paren
r_return
(paren
op_minus
id|EFAULT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|posix_make_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
comma
op_amp
id|flock
)paren
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|flock.l_type
)paren
(brace
r_case
id|F_RDLCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
l_int|1
)paren
)paren
r_return
(paren
op_minus
id|EBADF
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_WRLCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
l_int|2
)paren
)paren
r_return
(paren
op_minus
id|EBADF
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_UNLCK
suffix:colon
r_break
suffix:semicolon
r_case
id|F_SHLCK
suffix:colon
r_case
id|F_EXLCK
suffix:colon
macro_line|#ifdef __sparc__
multiline_comment|/* warn a bit for now, but don&squot;t overdo it */
(brace
r_static
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
(brace
id|count
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;fcntl_setlk() called by process %d (%s) with broken flock() emulation&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|current-&gt;comm
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
l_int|3
)paren
)paren
r_return
(paren
op_minus
id|EBADF
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|filp-&gt;f_op-&gt;lock
op_ne
l_int|NULL
)paren
(brace
id|error
op_assign
id|filp-&gt;f_op
op_member_access_from_pointer
id|lock
c_func
(paren
id|filp-&gt;f_inode
comma
id|filp
comma
id|cmd
comma
op_amp
id|file_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
r_return
(paren
id|posix_lock_file
c_func
(paren
id|filp
comma
op_amp
id|file_lock
comma
id|cmd
op_eq
id|F_SETLKW
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This function is called when the file is closed.&n; */
DECL|function|locks_remove_locks
r_void
id|locks_remove_locks
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|file_lock
id|file_lock
comma
op_star
id|fl
suffix:semicolon
r_struct
id|file_lock
op_star
op_star
id|before
suffix:semicolon
multiline_comment|/* For POSIX locks we free all locks on this file for the given task.&n;&t; * For FLOCK we only free locks on this *open* file if it is the last&n;&t; * close on that file.&n;&t; */
id|before
op_assign
op_amp
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
r_while
c_loop
(paren
(paren
id|fl
op_assign
op_star
id|before
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_POSIX
)paren
op_logical_and
(paren
id|fl-&gt;fl_owner
op_eq
id|task
)paren
)paren
op_logical_or
(paren
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_FLOCK
)paren
op_logical_and
(paren
id|fl-&gt;fl_file
op_eq
id|filp
)paren
op_logical_and
(paren
id|filp-&gt;f_count
op_eq
l_int|1
)paren
)paren
)paren
(brace
id|file_lock
op_assign
op_star
id|fl
suffix:semicolon
id|locks_delete_lock
c_func
(paren
id|before
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_op-&gt;lock
)paren
(brace
id|file_lock.fl_type
op_assign
id|F_UNLCK
suffix:semicolon
id|filp-&gt;f_op
op_member_access_from_pointer
id|lock
c_func
(paren
id|filp-&gt;f_inode
comma
id|filp
comma
id|F_SETLK
comma
op_amp
id|file_lock
)paren
suffix:semicolon
multiline_comment|/* List may have changed: */
id|before
op_assign
op_amp
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
)brace
)brace
r_else
(brace
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
r_struct
id|file_lock
op_star
DECL|function|posix_test_lock
id|posix_test_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
r_struct
id|file_lock
op_star
id|cfl
suffix:semicolon
r_for
c_loop
(paren
id|cfl
op_assign
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
id|cfl
suffix:semicolon
id|cfl
op_assign
id|cfl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|cfl-&gt;fl_flags
op_amp
id|FL_POSIX
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|posix_locks_conflict
c_func
(paren
id|cfl
comma
id|fl
)paren
)paren
r_break
suffix:semicolon
)brace
r_return
(paren
id|cfl
)paren
suffix:semicolon
)brace
DECL|function|locks_verify_locked
r_int
id|locks_verify_locked
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
multiline_comment|/* Candidates for mandatory locking have the setgid bit set&n;&t; * but no group execute bit -  an otherwise meaningless combination.&n;&t; */
r_if
c_cond
(paren
id|IS_MANDLOCK
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_ISGID
op_or
id|S_IXGRP
)paren
)paren
op_eq
id|S_ISGID
)paren
r_return
(paren
id|locks_mandatory_locked
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|locks_verify_area
r_int
id|locks_verify_area
c_func
(paren
r_int
id|read_write
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|count
)paren
(brace
multiline_comment|/* Candidates for mandatory locking have the setgid bit set&n;&t; * but no group execute bit -  an otherwise meaningless combination.&n;&t; */
r_if
c_cond
(paren
id|IS_MANDLOCK
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_ISGID
op_or
id|S_IXGRP
)paren
)paren
op_eq
id|S_ISGID
)paren
r_return
(paren
id|locks_mandatory_area
c_func
(paren
id|read_write
comma
id|inode
comma
id|filp
comma
id|offset
comma
id|count
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|locks_mandatory_locked
r_int
id|locks_mandatory_locked
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
multiline_comment|/* Search the lock list for this inode for any POSIX locks.&n;&t; */
r_for
c_loop
(paren
id|fl
op_assign
id|inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_POSIX
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_owner
op_ne
id|current
)paren
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|locks_mandatory_area
r_int
id|locks_mandatory_area
c_func
(paren
r_int
id|read_write
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_struct
id|file_lock
id|tfl
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tfl
comma
l_int|0
comma
r_sizeof
(paren
id|tfl
)paren
)paren
suffix:semicolon
id|tfl.fl_file
op_assign
id|filp
suffix:semicolon
id|tfl.fl_flags
op_assign
id|FL_POSIX
op_or
id|FL_ACCESS
suffix:semicolon
id|tfl.fl_owner
op_assign
id|current
suffix:semicolon
id|tfl.fl_pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|tfl.fl_type
op_assign
(paren
id|read_write
op_eq
id|FLOCK_VERIFY_WRITE
)paren
ques
c_cond
id|F_WRLCK
suffix:colon
id|F_RDLCK
suffix:semicolon
id|tfl.fl_start
op_assign
id|offset
suffix:semicolon
id|tfl.fl_end
op_assign
id|offset
op_plus
id|count
op_minus
l_int|1
suffix:semicolon
id|repeat
suffix:colon
multiline_comment|/* Search the lock list for this inode for locks that conflict with&n;&t; * the proposed read/write.&n;&t; */
r_for
c_loop
(paren
id|fl
op_assign
id|inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_POSIX
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Block for writes against a &quot;read&quot; lock,&n;&t;&t; * and both reads and writes against a &quot;write&quot; lock.&n;&t;&t; */
r_if
c_cond
(paren
id|posix_locks_conflict
c_func
(paren
id|fl
comma
op_amp
id|tfl
)paren
)paren
(brace
r_if
c_cond
(paren
id|filp
op_logical_and
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
)paren
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
r_return
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|posix_locks_deadlock
c_func
(paren
op_amp
id|tfl
comma
id|fl
)paren
)paren
r_return
(paren
op_minus
id|EDEADLK
)paren
suffix:semicolon
id|locks_insert_block
c_func
(paren
id|fl
comma
op_amp
id|tfl
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|tfl.fl_wait
)paren
suffix:semicolon
id|locks_delete_block
c_func
(paren
id|fl
comma
op_amp
id|tfl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
r_return
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
multiline_comment|/* If we&squot;ve been sleeping someone might have&n;&t;&t;&t; * changed the permissions behind our back.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_ISGID
op_or
id|S_IXGRP
)paren
)paren
op_ne
id|S_ISGID
)paren
r_break
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Verify a &quot;struct flock&quot; and copy it to a &quot;struct file_lock&quot; as a POSIX&n; * style lock.&n; */
DECL|function|posix_make_lock
r_static
r_int
id|posix_make_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
comma
r_struct
id|flock
op_star
id|l
)paren
(brace
id|off_t
id|start
suffix:semicolon
id|memset
c_func
(paren
id|fl
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|fl
)paren
)paren
suffix:semicolon
id|fl-&gt;fl_flags
op_assign
id|FL_POSIX
suffix:semicolon
r_switch
c_cond
(paren
id|l-&gt;l_type
)paren
(brace
r_case
id|F_RDLCK
suffix:colon
r_case
id|F_WRLCK
suffix:colon
r_case
id|F_UNLCK
suffix:colon
id|fl-&gt;fl_type
op_assign
id|l-&gt;l_type
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|l-&gt;l_whence
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/*SEEK_SET*/
id|start
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/*SEEK_CUR*/
id|start
op_assign
id|filp-&gt;f_pos
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/*SEEK_END*/
id|start
op_assign
id|filp-&gt;f_inode-&gt;i_size
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|start
op_add_assign
id|l-&gt;l_start
)paren
OL
l_int|0
)paren
op_logical_or
(paren
id|l-&gt;l_len
OL
l_int|0
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|fl-&gt;fl_start
op_assign
id|start
suffix:semicolon
multiline_comment|/* we record the absolute position */
r_if
c_cond
(paren
(paren
id|l-&gt;l_len
op_eq
l_int|0
)paren
op_logical_or
(paren
(paren
id|fl-&gt;fl_end
op_assign
id|start
op_plus
id|l-&gt;l_len
op_minus
l_int|1
)paren
OL
l_int|0
)paren
)paren
id|fl-&gt;fl_end
op_assign
id|OFFSET_MAX
suffix:semicolon
id|fl-&gt;fl_file
op_assign
id|filp
suffix:semicolon
id|fl-&gt;fl_owner
op_assign
id|current
suffix:semicolon
id|fl-&gt;fl_pid
op_assign
id|current-&gt;pid
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Verify a call to flock() and fill in a file_lock structure with&n; * an appropriate FLOCK lock.&n; */
DECL|function|flock_make_lock
r_static
r_int
id|flock_make_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
comma
r_int
r_int
id|cmd
)paren
(brace
id|memset
c_func
(paren
id|fl
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|fl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp-&gt;f_inode
)paren
multiline_comment|/* just in case */
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
op_amp
op_complement
id|LOCK_NB
)paren
(brace
r_case
id|LOCK_SH
suffix:colon
id|fl-&gt;fl_type
op_assign
id|F_RDLCK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LOCK_EX
suffix:colon
id|fl-&gt;fl_type
op_assign
id|F_WRLCK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LOCK_UN
suffix:colon
id|fl-&gt;fl_type
op_assign
id|F_UNLCK
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|fl-&gt;fl_flags
op_assign
id|FL_FLOCK
suffix:semicolon
id|fl-&gt;fl_start
op_assign
l_int|0
suffix:semicolon
id|fl-&gt;fl_end
op_assign
id|OFFSET_MAX
suffix:semicolon
id|fl-&gt;fl_file
op_assign
id|filp
suffix:semicolon
id|fl-&gt;fl_owner
op_assign
l_int|NULL
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Determine if lock sys_fl blocks lock caller_fl. POSIX specific&n; * checking before calling the locks_conflict().&n; */
DECL|function|posix_locks_conflict
r_static
r_int
id|posix_locks_conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
(brace
multiline_comment|/* POSIX locks owned by the same process do not conflict with&n;&t; * each other.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sys_fl-&gt;fl_flags
op_amp
id|FL_POSIX
)paren
op_logical_or
id|locks_same_owner
c_func
(paren
id|caller_fl
comma
id|sys_fl
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|locks_conflict
c_func
(paren
id|caller_fl
comma
id|sys_fl
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Determine if lock sys_fl blocks lock caller_fl. FLOCK specific&n; * checking before calling the locks_conflict().&n; */
DECL|function|flock_locks_conflict
r_static
r_int
id|flock_locks_conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
(brace
multiline_comment|/* FLOCK locks referring to the same filp do not conflict with&n;&t; * each other.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sys_fl-&gt;fl_flags
op_amp
id|FL_FLOCK
)paren
op_logical_or
(paren
id|caller_fl-&gt;fl_file
op_eq
id|sys_fl-&gt;fl_file
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|locks_conflict
c_func
(paren
id|caller_fl
comma
id|sys_fl
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Determine if lock sys_fl blocks lock caller_fl. Common functionality&n; * checks for overlapping locks and shared/exclusive status.&n; */
DECL|function|locks_conflict
r_static
r_int
id|locks_conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|locks_overlap
c_func
(paren
id|caller_fl
comma
id|sys_fl
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|caller_fl-&gt;fl_type
)paren
(brace
r_case
id|F_RDLCK
suffix:colon
r_return
(paren
id|sys_fl-&gt;fl_type
op_eq
id|F_WRLCK
)paren
suffix:semicolon
r_case
id|F_WRLCK
suffix:colon
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;locks_conflict(): impossible lock type - %d&bslash;n&quot;
comma
id|caller_fl-&gt;fl_type
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* This should never happen */
)brace
multiline_comment|/* This function tests for deadlock condition before putting a process to&n; * sleep. The detection scheme is no longer recursive. Recursive was neat,&n; * but dangerous - we risked stack corruption if the lock data was bad, or&n; * if the recursion was too deep for any other reason.&n; *&n; * We rely on the fact that a task can only be on one lock&squot;s wait queue&n; * at a time. When we find blocked_task on a wait queue we can re-search&n; * with blocked_task equal to that queue&squot;s owner, until either blocked_task&n; * isn&squot;t found, or blocked_task is found on a queue owned by my_task.&n; *&n; * Note: the above assumption may not be true when handling lock requests&n; * from a broken NFS client. But broken NFS clients have a lot more to&n; * worry about than proper deadlock detection anyway... --okir&n; */
DECL|function|posix_locks_deadlock
r_static
r_int
id|posix_locks_deadlock
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|block_fl
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_struct
id|file_lock
op_star
id|bfl
suffix:semicolon
r_void
op_star
id|caller_owner
comma
op_star
id|blocked_owner
suffix:semicolon
r_int
r_int
id|caller_pid
comma
id|blocked_pid
suffix:semicolon
id|caller_owner
op_assign
id|caller_fl-&gt;fl_owner
suffix:semicolon
id|caller_pid
op_assign
id|caller_fl-&gt;fl_pid
suffix:semicolon
id|blocked_owner
op_assign
id|block_fl-&gt;fl_owner
suffix:semicolon
id|blocked_pid
op_assign
id|block_fl-&gt;fl_pid
suffix:semicolon
id|next_task
suffix:colon
r_if
c_cond
(paren
id|caller_owner
op_eq
id|blocked_owner
op_logical_and
id|caller_pid
op_eq
id|blocked_pid
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|fl
op_assign
id|file_lock_table
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_nextlink
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_owner
op_eq
l_int|NULL
op_logical_or
id|fl-&gt;fl_nextblock
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|bfl
op_assign
id|fl-&gt;fl_nextblock
suffix:semicolon
id|bfl
op_ne
id|fl
suffix:semicolon
id|bfl
op_assign
id|bfl-&gt;fl_nextblock
)paren
(brace
r_if
c_cond
(paren
id|bfl-&gt;fl_owner
op_eq
id|blocked_owner
op_logical_and
id|bfl-&gt;fl_pid
op_eq
id|blocked_pid
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_owner
op_eq
id|caller_owner
op_logical_and
id|fl-&gt;fl_pid
op_eq
id|caller_pid
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|blocked_owner
op_assign
id|fl-&gt;fl_owner
suffix:semicolon
id|blocked_pid
op_assign
id|fl-&gt;fl_pid
suffix:semicolon
r_goto
id|next_task
suffix:semicolon
)brace
)brace
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Try to create a FLOCK lock on filp. We always insert new FLOCK locks at&n; * the head of the list, but that&squot;s secret knowledge known only to the next&n; * two functions.&n; */
DECL|function|flock_lock_file
r_static
r_int
id|flock_lock_file
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|caller
comma
r_int
r_int
id|wait
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_struct
id|file_lock
op_star
id|new_fl
suffix:semicolon
r_struct
id|file_lock
op_star
op_star
id|before
suffix:semicolon
r_int
id|change
op_assign
l_int|0
suffix:semicolon
id|before
op_assign
op_amp
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|fl
op_assign
op_star
id|before
)paren
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_FLOCK
)paren
)paren
(brace
r_if
c_cond
(paren
id|caller-&gt;fl_file
op_eq
id|fl-&gt;fl_file
)paren
(brace
r_if
c_cond
(paren
id|caller-&gt;fl_type
op_eq
id|fl-&gt;fl_type
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|change
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
)brace
multiline_comment|/* change means that we are changing the type of an existing lock, or&n;&t; * or else unlocking it.&n;&t; */
r_if
c_cond
(paren
id|change
)paren
id|locks_delete_lock
c_func
(paren
id|before
comma
id|caller-&gt;fl_type
op_ne
id|F_UNLCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|caller-&gt;fl_type
op_eq
id|F_UNLCK
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|new_fl
op_assign
id|locks_alloc_lock
c_func
(paren
id|caller
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
(paren
op_minus
id|ENOLCK
)paren
suffix:semicolon
id|repeat
suffix:colon
r_for
c_loop
(paren
id|fl
op_assign
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
(paren
id|fl
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_FLOCK
)paren
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|flock_locks_conflict
c_func
(paren
id|new_fl
comma
id|fl
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
(brace
id|locks_free_lock
c_func
(paren
id|new_fl
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
multiline_comment|/* Note: new_fl is not in any queue at this&n;&t;&t;&t; * point, so we must use locks_free_lock()&n;&t;&t;&t; * instead of locks_delete_lock()&n;&t;&t;&t; * &t;Dmitry Gorodchanin 09/02/96.&n;&t;&t;&t; */
id|locks_free_lock
c_func
(paren
id|new_fl
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
)brace
id|locks_insert_block
c_func
(paren
id|fl
comma
id|new_fl
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|new_fl-&gt;fl_wait
)paren
suffix:semicolon
id|locks_delete_block
c_func
(paren
id|fl
comma
id|new_fl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
multiline_comment|/* Awakened by a signal. Free the new&n;&t;&t;&t; * lock and return an error.&n;&t;&t;&t; */
id|locks_free_lock
c_func
(paren
id|new_fl
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
)brace
r_goto
id|repeat
suffix:semicolon
)brace
id|locks_insert_lock
c_func
(paren
op_amp
id|filp-&gt;f_inode-&gt;i_flock
comma
id|new_fl
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Add a POSIX style lock to a file.&n; * We merge adjacent locks whenever possible. POSIX locks are sorted by owner&n; * task, then by starting address&n; *&n; * Kai Petzke writes:&n; * To make freeing a lock much faster, we keep a pointer to the lock before the&n; * actual one. But the real gain of the new coding was, that lock_it() and&n; * unlock_it() became one function.&n; *&n; * To all purists: Yes, I use a few goto&squot;s. Just pass on to the next function.&n; */
DECL|function|posix_lock_file
r_int
id|posix_lock_file
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|caller
comma
r_int
r_int
id|wait
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_struct
id|file_lock
op_star
id|new_fl
suffix:semicolon
r_struct
id|file_lock
op_star
id|left
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|file_lock
op_star
id|right
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|file_lock
op_star
op_star
id|before
suffix:semicolon
r_int
id|added
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|caller-&gt;fl_type
op_ne
id|F_UNLCK
)paren
(brace
id|repeat
suffix:colon
r_for
c_loop
(paren
id|fl
op_assign
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_POSIX
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|posix_locks_conflict
c_func
(paren
id|caller
comma
id|fl
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
r_return
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|posix_locks_deadlock
c_func
(paren
id|caller
comma
id|fl
)paren
)paren
r_return
(paren
op_minus
id|EDEADLK
)paren
suffix:semicolon
id|locks_insert_block
c_func
(paren
id|fl
comma
id|caller
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|caller-&gt;fl_wait
)paren
suffix:semicolon
id|locks_delete_block
c_func
(paren
id|fl
comma
id|caller
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
r_return
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
multiline_comment|/* Find the first old lock with the same owner as the new lock.&n;&t; */
id|before
op_assign
op_amp
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
multiline_comment|/* First skip locks owned by other processes.&n;&t; */
r_while
c_loop
(paren
(paren
id|fl
op_assign
op_star
id|before
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_POSIX
)paren
op_logical_or
op_logical_neg
id|locks_same_owner
c_func
(paren
id|caller
comma
id|fl
)paren
)paren
)paren
(brace
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
)brace
multiline_comment|/* Process locks with this owner.&n;&t; */
r_while
c_loop
(paren
(paren
id|fl
op_assign
op_star
id|before
)paren
op_logical_and
id|locks_same_owner
c_func
(paren
id|caller
comma
id|fl
)paren
)paren
(brace
multiline_comment|/* Detect adjacent or overlapping regions (if same lock type)&n;&t;&t; */
r_if
c_cond
(paren
id|caller-&gt;fl_type
op_eq
id|fl-&gt;fl_type
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_end
OL
id|caller-&gt;fl_start
op_minus
l_int|1
)paren
r_goto
id|next_lock
suffix:semicolon
multiline_comment|/* If the next lock in the list has entirely bigger&n;&t;&t;&t; * addresses than the new one, insert the lock here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fl-&gt;fl_start
OG
id|caller-&gt;fl_end
op_plus
l_int|1
)paren
r_break
suffix:semicolon
multiline_comment|/* If we come here, the new and old lock are of the&n;&t;&t;&t; * same type and adjacent or overlapping. Make one&n;&t;&t;&t; * lock yielding from the lower start address of both&n;&t;&t;&t; * locks to the higher end address.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fl-&gt;fl_start
OG
id|caller-&gt;fl_start
)paren
id|fl-&gt;fl_start
op_assign
id|caller-&gt;fl_start
suffix:semicolon
r_else
id|caller-&gt;fl_start
op_assign
id|fl-&gt;fl_start
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_end
OL
id|caller-&gt;fl_end
)paren
id|fl-&gt;fl_end
op_assign
id|caller-&gt;fl_end
suffix:semicolon
r_else
id|caller-&gt;fl_end
op_assign
id|fl-&gt;fl_end
suffix:semicolon
r_if
c_cond
(paren
id|added
)paren
(brace
id|locks_delete_lock
c_func
(paren
id|before
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|caller
op_assign
id|fl
suffix:semicolon
id|added
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Processing for different lock types is a bit&n;&t;&t;&t; * more complex.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fl-&gt;fl_end
OL
id|caller-&gt;fl_start
)paren
r_goto
id|next_lock
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_start
OG
id|caller-&gt;fl_end
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|caller-&gt;fl_type
op_eq
id|F_UNLCK
)paren
id|added
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_start
OL
id|caller-&gt;fl_start
)paren
id|left
op_assign
id|fl
suffix:semicolon
multiline_comment|/* If the next lock in the list has a higher end&n;&t;&t;&t; * address than the new one, insert the new one here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fl-&gt;fl_end
OG
id|caller-&gt;fl_end
)paren
(brace
id|right
op_assign
id|fl
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fl-&gt;fl_start
op_ge
id|caller-&gt;fl_start
)paren
(brace
multiline_comment|/* The new lock completely replaces an old&n;&t;&t;&t;&t; * one (This may happen several times).&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|added
)paren
(brace
id|locks_delete_lock
c_func
(paren
id|before
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Replace the old lock with the new one.&n;&t;&t;&t;&t; * Wake up anybody waiting for the old one,&n;&t;&t;&t;&t; * as the change in lock type might satisfy&n;&t;&t;&t;&t; * their needs.&n;&t;&t;&t;&t; */
id|locks_wake_up_blocks
c_func
(paren
id|fl
comma
l_int|0
)paren
suffix:semicolon
id|fl-&gt;fl_start
op_assign
id|caller-&gt;fl_start
suffix:semicolon
id|fl-&gt;fl_end
op_assign
id|caller-&gt;fl_end
suffix:semicolon
id|fl-&gt;fl_type
op_assign
id|caller-&gt;fl_type
suffix:semicolon
id|fl-&gt;fl_u
op_assign
id|caller-&gt;fl_u
suffix:semicolon
id|caller
op_assign
id|fl
suffix:semicolon
id|added
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Go on to next lock.&n;&t;&t; */
id|next_lock
suffix:colon
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|added
)paren
(brace
r_if
c_cond
(paren
id|caller-&gt;fl_type
op_eq
id|F_UNLCK
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|new_fl
op_assign
id|locks_alloc_lock
c_func
(paren
id|caller
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
(paren
op_minus
id|ENOLCK
)paren
suffix:semicolon
id|locks_insert_lock
c_func
(paren
id|before
comma
id|new_fl
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|right
)paren
(brace
r_if
c_cond
(paren
id|left
op_eq
id|right
)paren
(brace
multiline_comment|/* The new lock breaks the old one in two pieces, so we&n;&t;&t;&t; * have to allocate one more lock (in this case, even&n;&t;&t;&t; * F_UNLCK may fail!).&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|left
op_assign
id|locks_alloc_lock
c_func
(paren
id|right
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|added
)paren
id|locks_delete_lock
c_func
(paren
id|before
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENOLCK
)paren
suffix:semicolon
)brace
id|locks_insert_lock
c_func
(paren
id|before
comma
id|left
)paren
suffix:semicolon
)brace
id|right-&gt;fl_start
op_assign
id|caller-&gt;fl_end
op_plus
l_int|1
suffix:semicolon
id|locks_wake_up_blocks
c_func
(paren
id|right
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|left
)paren
(brace
id|left-&gt;fl_end
op_assign
id|caller-&gt;fl_start
op_minus
l_int|1
suffix:semicolon
id|locks_wake_up_blocks
c_func
(paren
id|left
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Allocate new lock.&n; * Initialize its fields from fl. The lock is not inserted into any&n; * lists until locks_insert_lock() or locks_insert_block() are called.&n; */
DECL|function|locks_alloc_lock
r_static
r_struct
id|file_lock
op_star
id|locks_alloc_lock
c_func
(paren
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
r_struct
id|file_lock
op_star
id|tmp
suffix:semicolon
multiline_comment|/* Okay, let&squot;s make a new file_lock structure... */
r_if
c_cond
(paren
(paren
id|tmp
op_assign
(paren
r_struct
id|file_lock
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|file_lock
)paren
comma
id|GFP_ATOMIC
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
(paren
id|tmp
)paren
suffix:semicolon
id|memset
c_func
(paren
id|tmp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|tmp
)paren
)paren
suffix:semicolon
id|tmp-&gt;fl_flags
op_assign
id|fl-&gt;fl_flags
suffix:semicolon
id|tmp-&gt;fl_owner
op_assign
id|fl-&gt;fl_owner
suffix:semicolon
id|tmp-&gt;fl_pid
op_assign
id|fl-&gt;fl_pid
suffix:semicolon
id|tmp-&gt;fl_file
op_assign
id|fl-&gt;fl_file
suffix:semicolon
id|tmp-&gt;fl_type
op_assign
id|fl-&gt;fl_type
suffix:semicolon
id|tmp-&gt;fl_start
op_assign
id|fl-&gt;fl_start
suffix:semicolon
id|tmp-&gt;fl_end
op_assign
id|fl-&gt;fl_end
suffix:semicolon
id|tmp-&gt;fl_notify
op_assign
id|fl-&gt;fl_notify
suffix:semicolon
id|tmp-&gt;fl_u
op_assign
id|fl-&gt;fl_u
suffix:semicolon
r_return
(paren
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/* Insert file lock fl into an inode&squot;s lock list at the position indicated&n; * by pos. At the same time add the lock to the global file lock list.&n; */
DECL|function|locks_insert_lock
r_static
r_void
id|locks_insert_lock
c_func
(paren
r_struct
id|file_lock
op_star
op_star
id|pos
comma
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
id|fl-&gt;fl_nextlink
op_assign
id|file_lock_table
suffix:semicolon
id|fl-&gt;fl_prevlink
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|file_lock_table
op_ne
l_int|NULL
)paren
id|file_lock_table-&gt;fl_prevlink
op_assign
id|fl
suffix:semicolon
id|file_lock_table
op_assign
id|fl
suffix:semicolon
id|fl-&gt;fl_next
op_assign
op_star
id|pos
suffix:semicolon
multiline_comment|/* insert into file&squot;s list */
op_star
id|pos
op_assign
id|fl
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Delete a lock and free it.&n; * First remove our lock from the active lock lists. Then call&n; * locks_wake_up_blocks() to wake up processes that are blocked&n; * waiting for this lock. Finally free the lock structure.&n; */
DECL|function|locks_delete_lock
r_static
r_void
id|locks_delete_lock
c_func
(paren
r_struct
id|file_lock
op_star
op_star
id|thisfl_p
comma
r_int
r_int
id|wait
)paren
(brace
r_struct
id|file_lock
op_star
id|thisfl
suffix:semicolon
r_struct
id|file_lock
op_star
id|prevfl
suffix:semicolon
r_struct
id|file_lock
op_star
id|nextfl
suffix:semicolon
id|thisfl
op_assign
op_star
id|thisfl_p
suffix:semicolon
op_star
id|thisfl_p
op_assign
id|thisfl-&gt;fl_next
suffix:semicolon
id|prevfl
op_assign
id|thisfl-&gt;fl_prevlink
suffix:semicolon
id|nextfl
op_assign
id|thisfl-&gt;fl_nextlink
suffix:semicolon
r_if
c_cond
(paren
id|nextfl
op_ne
l_int|NULL
)paren
id|nextfl-&gt;fl_prevlink
op_assign
id|prevfl
suffix:semicolon
r_if
c_cond
(paren
id|prevfl
op_ne
l_int|NULL
)paren
id|prevfl-&gt;fl_nextlink
op_assign
id|nextfl
suffix:semicolon
r_else
id|file_lock_table
op_assign
id|nextfl
suffix:semicolon
id|locks_wake_up_blocks
c_func
(paren
id|thisfl
comma
id|wait
)paren
suffix:semicolon
id|locks_free_lock
c_func
(paren
id|thisfl
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|lock_get_status
r_static
r_char
op_star
id|lock_get_status
c_func
(paren
r_struct
id|file_lock
op_star
id|fl
comma
r_int
id|id
comma
r_char
op_star
id|pfx
)paren
(brace
r_static
r_char
id|temp
(braket
l_int|129
)braket
suffix:semicolon
r_char
op_star
id|p
op_assign
id|temp
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|inode
op_assign
id|fl-&gt;fl_file-&gt;f_inode
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%d:%s &quot;
comma
id|id
comma
id|pfx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_POSIX
)paren
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%6s %s &quot;
comma
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_ACCESS
)paren
ques
c_cond
l_string|&quot;ACCESS&quot;
suffix:colon
l_string|&quot;POSIX &quot;
comma
(paren
id|IS_MANDLOCK
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_IXGRP
op_or
id|S_ISGID
)paren
)paren
op_eq
id|S_ISGID
)paren
ques
c_cond
l_string|&quot;MANDATORY&quot;
suffix:colon
l_string|&quot;ADVISORY &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;FLOCK  ADVISORY  &quot;
)paren
suffix:semicolon
)brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%s &quot;
comma
(paren
id|fl-&gt;fl_type
op_eq
id|F_RDLCK
)paren
ques
c_cond
l_string|&quot;READ &quot;
suffix:colon
l_string|&quot;WRITE&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%d %s:%ld %ld %ld &quot;
comma
id|fl-&gt;fl_pid
comma
id|kdevname
c_func
(paren
id|inode-&gt;i_dev
)paren
comma
id|inode-&gt;i_ino
comma
id|fl-&gt;fl_start
comma
id|fl-&gt;fl_end
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%08lx %08lx %08lx %08lx %08lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|fl
comma
(paren
r_int
)paren
id|fl-&gt;fl_prevlink
comma
(paren
r_int
)paren
id|fl-&gt;fl_nextlink
comma
(paren
r_int
)paren
id|fl-&gt;fl_next
comma
(paren
r_int
)paren
id|fl-&gt;fl_nextblock
)paren
suffix:semicolon
r_return
(paren
id|temp
)paren
suffix:semicolon
)brace
DECL|function|copy_lock_status
r_static
r_inline
r_int
id|copy_lock_status
c_func
(paren
r_char
op_star
id|p
comma
r_char
op_star
op_star
id|q
comma
id|off_t
id|pos
comma
r_int
id|len
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|pos
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|i
op_ge
id|length
)paren
(brace
id|i
op_assign
id|len
op_plus
id|length
op_minus
id|i
suffix:semicolon
id|memcpy
c_func
(paren
op_star
id|q
comma
id|p
comma
id|i
)paren
suffix:semicolon
op_star
id|q
op_add_assign
id|i
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
id|len
)paren
(brace
id|p
op_add_assign
id|len
op_minus
id|i
suffix:semicolon
)brace
r_else
id|i
op_assign
id|len
suffix:semicolon
id|memcpy
c_func
(paren
op_star
id|q
comma
id|p
comma
id|i
)paren
suffix:semicolon
op_star
id|q
op_add_assign
id|i
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|get_locks_status
r_int
id|get_locks_status
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_struct
id|file_lock
op_star
id|bfl
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_char
op_star
id|q
op_assign
id|buffer
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|len
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|fl
op_assign
id|file_lock_table
comma
id|i
op_assign
l_int|1
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_nextlink
comma
id|i
op_increment
)paren
(brace
id|p
op_assign
id|lock_get_status
c_func
(paren
id|fl
comma
id|i
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|p
)paren
suffix:semicolon
id|pos
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_lock_status
c_func
(paren
id|p
comma
op_amp
id|q
comma
id|pos
comma
id|len
comma
id|offset
comma
id|length
)paren
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bfl
op_assign
id|fl-&gt;fl_nextblock
)paren
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
r_do
(brace
id|p
op_assign
id|lock_get_status
c_func
(paren
id|bfl
comma
id|i
comma
l_string|&quot; -&gt;&quot;
)paren
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|p
)paren
suffix:semicolon
id|pos
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_lock_status
c_func
(paren
id|p
comma
op_amp
id|q
comma
id|pos
comma
id|len
comma
id|offset
comma
id|length
)paren
)paren
r_goto
id|done
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|bfl
op_assign
id|bfl-&gt;fl_nextblock
)paren
op_ne
id|fl
)paren
suffix:semicolon
)brace
id|done
suffix:colon
r_if
c_cond
(paren
id|q
op_ne
id|buffer
)paren
op_star
id|start
op_assign
id|buffer
suffix:semicolon
r_return
(paren
id|q
op_minus
id|buffer
)paren
suffix:semicolon
)brace
eof
