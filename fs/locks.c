multiline_comment|/*&n; *  linux/fs/locks.c&n; *&n; *  Provide support for fcntl()&squot;s F_GETLK, F_SETLK, and F_SETLKW calls.&n; *  Doug Evans, 92Aug07, dje@sspiff.uucp.&n; *&n; * FIXME: two things aren&squot;t handled yet:&n; *&t;- deadlock detection/avoidance (of dubious merit, but since it&squot;s in&n; *&t;  the definition, I guess it should be provided eventually)&n; *&t;- mandatory locks (requires lots of changes elsewhere)&n; */
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
DECL|macro|OFFSET_MAX
mdefine_line|#define OFFSET_MAX&t;0x7fffffff&t;/* FIXME: move elsewhere? */
r_static
r_int
id|copy_flock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
comma
r_struct
id|flock
op_star
id|l
)paren
suffix:semicolon
r_static
r_int
id|conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
suffix:semicolon
r_static
r_int
id|overlap
c_func
(paren
r_struct
id|file_lock
op_star
id|fl1
comma
r_struct
id|file_lock
op_star
id|fl2
)paren
suffix:semicolon
r_static
r_int
id|lock_it
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|caller
)paren
suffix:semicolon
r_static
r_int
id|unlock_it
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|caller
)paren
suffix:semicolon
r_static
r_struct
id|file_lock
op_star
id|alloc_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
r_template
)paren
suffix:semicolon
r_static
r_void
id|free_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
)paren
suffix:semicolon
DECL|variable|file_lock_table
r_static
r_struct
id|file_lock
id|file_lock_table
(braket
id|NR_FILE_LOCKS
)braket
suffix:semicolon
DECL|variable|file_lock_free_list
r_static
r_struct
id|file_lock
op_star
id|file_lock_free_list
suffix:semicolon
multiline_comment|/*&n; * Called at boot time to initialize the lock table ...&n; */
DECL|function|fcntl_init_locks
r_void
id|fcntl_init_locks
c_func
(paren
r_void
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_for
c_loop
(paren
id|fl
op_assign
op_amp
id|file_lock_table
(braket
l_int|0
)braket
suffix:semicolon
id|fl
OL
id|file_lock_table
op_plus
id|NR_FILE_LOCKS
op_minus
l_int|1
suffix:semicolon
id|fl
op_increment
)paren
(brace
id|fl-&gt;fl_next
op_assign
id|fl
op_plus
l_int|1
suffix:semicolon
id|fl-&gt;fl_owner
op_assign
l_int|NULL
suffix:semicolon
)brace
id|file_lock_table
(braket
id|NR_FILE_LOCKS
op_minus
l_int|1
)braket
dot
id|fl_next
op_assign
l_int|NULL
suffix:semicolon
id|file_lock_table
(braket
id|NR_FILE_LOCKS
op_minus
l_int|1
)braket
dot
id|fl_owner
op_assign
l_int|NULL
suffix:semicolon
id|file_lock_free_list
op_assign
op_amp
id|file_lock_table
(braket
l_int|0
)braket
suffix:semicolon
)brace
DECL|function|fcntl_getlk
r_int
id|fcntl_getlk
c_func
(paren
r_int
r_int
id|fd
comma
r_struct
id|flock
op_star
id|l
)paren
(brace
r_struct
id|flock
id|flock
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|file_lock
op_star
id|fl
comma
id|file_lock
suffix:semicolon
r_if
c_cond
(paren
id|fd
op_ge
id|NR_OPEN
op_logical_or
op_logical_neg
(paren
id|filp
op_assign
id|current-&gt;filp
(braket
id|fd
)braket
)paren
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
id|verify_area
c_func
(paren
id|l
comma
r_sizeof
(paren
op_star
id|l
)paren
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|flock
comma
id|l
comma
r_sizeof
(paren
id|flock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flock.l_type
op_eq
id|F_UNLCK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_flock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
comma
op_amp
id|flock
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|fl
op_assign
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
id|conflict
c_func
(paren
op_amp
id|file_lock
comma
id|fl
)paren
)paren
(brace
id|flock.l_pid
op_assign
id|fl-&gt;fl_owner-&gt;pid
suffix:semicolon
id|flock.l_start
op_assign
id|fl-&gt;fl_start
suffix:semicolon
id|flock.l_len
op_assign
id|fl-&gt;fl_end
op_eq
id|OFFSET_MAX
ques
c_cond
l_int|0
suffix:colon
id|fl-&gt;fl_end
op_minus
id|fl-&gt;fl_start
op_plus
l_int|1
suffix:semicolon
id|flock.l_whence
op_assign
id|fl-&gt;fl_whence
suffix:semicolon
id|flock.l_type
op_assign
id|fl-&gt;fl_type
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|l
comma
op_amp
id|flock
comma
r_sizeof
(paren
id|flock
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|flock.l_type
op_assign
id|F_UNLCK
suffix:semicolon
multiline_comment|/* no conflict found */
id|memcpy_tofs
c_func
(paren
id|l
comma
op_amp
id|flock
comma
r_sizeof
(paren
id|flock
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function implements both F_SETLK and F_SETLKW.&n; */
DECL|function|fcntl_setlk
r_int
id|fcntl_setlk
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
comma
r_struct
id|flock
op_star
id|l
)paren
(brace
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|file_lock
op_star
id|fl
comma
id|file_lock
suffix:semicolon
r_struct
id|flock
id|flock
suffix:semicolon
multiline_comment|/*&n;&t; * Get arguments and validate them ...&n;&t; */
r_if
c_cond
(paren
id|fd
op_ge
id|NR_OPEN
op_logical_or
op_logical_neg
(paren
id|filp
op_assign
id|current-&gt;filp
(braket
id|fd
)braket
)paren
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
id|verify_area
c_func
(paren
id|l
comma
r_sizeof
(paren
op_star
id|l
)paren
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|flock
comma
id|l
comma
r_sizeof
(paren
id|flock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_flock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
comma
op_amp
id|flock
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|file_lock.fl_type
)paren
(brace
r_case
id|F_RDLCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
l_int|1
)paren
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_WRLCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
l_int|2
)paren
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_SHLCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
l_int|3
)paren
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
id|file_lock.fl_type
op_assign
id|F_RDLCK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_EXLCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
l_int|3
)paren
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
id|file_lock.fl_type
op_assign
id|F_WRLCK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_UNLCK
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * F_UNLCK needs to be handled differently ...&n;&t; */
r_if
c_cond
(paren
id|file_lock.fl_type
op_eq
id|F_UNLCK
)paren
r_return
id|unlock_it
c_func
(paren
id|filp
comma
op_amp
id|file_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Scan for a conflicting lock ...&n;&t; */
id|repeat
suffix:colon
r_for
c_loop
(paren
id|fl
op_assign
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|conflict
c_func
(paren
op_amp
id|file_lock
comma
id|fl
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * File is locked by another process. If this is F_SETLKW&n;&t;&t; * wait for the lock to be released.&n;&t;&t; * FIXME: We need to check for deadlocks here.&n;&t;&t; */
r_if
c_cond
(paren
id|cmd
op_eq
id|F_SETLKW
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|fl-&gt;fl_wait
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Lock doesn&squot;t conflict with any other lock ...&n;&t; */
r_return
id|lock_it
c_func
(paren
id|filp
comma
op_amp
id|file_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called when the file is closed.&n; */
DECL|function|fcntl_remove_locks
r_void
id|fcntl_remove_locks
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
comma
op_star
id|next
suffix:semicolon
r_for
c_loop
(paren
id|fl
op_assign
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;&t;&t; * If this one is freed, {fl_next} gets clobbered when the&n;&t;&t; * entry is moved to the free list, so grab it now ...&n;&t;&t; */
id|next
op_assign
id|fl-&gt;fl_next
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_owner
op_eq
id|task
)paren
id|free_lock
c_func
(paren
id|filp
comma
id|fl
)paren
suffix:semicolon
id|fl
op_assign
id|next
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Verify a &quot;struct flock&quot; and copy it to a &quot;struct file_lock&quot; ...&n; * Result is a boolean indicating success.&n; */
DECL|function|copy_flock
r_static
r_int
id|copy_flock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
comma
r_struct
id|flock
op_star
id|l
)paren
(brace
id|off_t
id|start
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp-&gt;f_inode
)paren
multiline_comment|/* just in case */
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|filp-&gt;f_inode-&gt;i_mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|l-&gt;l_type
op_ne
id|F_UNLCK
op_logical_and
id|l-&gt;l_type
op_ne
id|F_RDLCK
op_logical_and
id|l-&gt;l_type
op_ne
id|F_WRLCK
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|l-&gt;l_whence
)paren
(brace
r_case
l_int|0
multiline_comment|/*SEEK_SET*/
suffix:colon
id|start
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
multiline_comment|/*SEEK_CUR*/
suffix:colon
id|start
op_assign
id|filp-&gt;f_pos
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
multiline_comment|/*SEEK_END*/
suffix:colon
id|start
op_assign
id|filp-&gt;f_inode-&gt;i_size
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|start
op_add_assign
id|l-&gt;l_start
)paren
OL
l_int|0
op_logical_or
id|l-&gt;l_len
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|fl-&gt;fl_type
op_assign
id|l-&gt;l_type
suffix:semicolon
id|fl-&gt;fl_start
op_assign
id|start
suffix:semicolon
multiline_comment|/* we record the absolute position */
id|fl-&gt;fl_whence
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FIXME: do we record {l_start} as passed? */
r_if
c_cond
(paren
id|l-&gt;l_len
op_eq
l_int|0
op_logical_or
(paren
id|fl-&gt;fl_end
op_assign
id|start
op_plus
id|l-&gt;l_len
op_minus
l_int|1
)paren
OL
l_int|0
)paren
id|fl-&gt;fl_end
op_assign
id|OFFSET_MAX
suffix:semicolon
id|fl-&gt;fl_owner
op_assign
id|current
suffix:semicolon
id|fl-&gt;fl_wait
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* just for cleanliness */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Determine if lock {sys_fl} blocks lock {caller_fl} ...&n; */
DECL|function|conflict
r_static
r_int
id|conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
(brace
r_if
c_cond
(paren
id|caller_fl-&gt;fl_owner
op_eq
id|sys_fl-&gt;fl_owner
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|overlap
c_func
(paren
id|caller_fl
comma
id|sys_fl
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|caller_fl-&gt;fl_type
)paren
(brace
r_case
id|F_RDLCK
suffix:colon
r_return
id|sys_fl-&gt;fl_type
op_ne
id|F_RDLCK
suffix:semicolon
r_case
id|F_WRLCK
suffix:colon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* overlapping region not owned by caller */
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* shouldn&squot;t get here, but just in case */
)brace
DECL|function|overlap
r_static
r_int
id|overlap
c_func
(paren
r_struct
id|file_lock
op_star
id|fl1
comma
r_struct
id|file_lock
op_star
id|fl2
)paren
(brace
r_if
c_cond
(paren
id|fl1-&gt;fl_start
op_le
id|fl2-&gt;fl_start
)paren
(brace
r_return
id|fl1-&gt;fl_end
op_ge
id|fl2-&gt;fl_start
suffix:semicolon
)brace
r_else
(brace
r_return
id|fl2-&gt;fl_end
op_ge
id|fl1-&gt;fl_start
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Add a lock to a file ...&n; * Result is 0 for success or -ENOLCK.&n; *&n; * We try to be real clever here and always minimize the number of table&n; * entries we use. For example we merge adjacent locks whenever possible. This&n; * consumes a bit of cpu and code space, is it really worth it? Beats me.&n; *&n; * I&squot;ve tried to keep the following as small and simple as possible. If you can&n; * make it smaller or simpler, please do. /dje 92Aug11&n; *&n; * WARNING: We assume the lock doesn&squot;t conflict with any other lock.&n; */
DECL|function|lock_it
r_static
r_int
id|lock_it
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|caller
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
comma
op_star
r_new
suffix:semicolon
multiline_comment|/*&n;&t; * It&squot;s easier if we allocate a slot for the lock first, and then&n;&t; * release it later if we have to (IE: if it can be merged with&n;&t; * another). This way the for() loop always knows that {caller} is an&n;&t; * existing entry. This will cause the routine to fail unnecessarily&n;&t; * in rare cases, but perfection can be pushed too far. :-)&n;&t; */
r_if
c_cond
(paren
(paren
id|caller
op_assign
id|alloc_lock
c_func
(paren
id|filp
comma
id|caller
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOLCK
suffix:semicolon
multiline_comment|/*&n;&t; * First scan to see if we are changing/augmenting an existing lock ...&n;&t; */
r_for
c_loop
(paren
id|fl
op_assign
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
id|caller-&gt;fl_owner
op_ne
id|fl-&gt;fl_owner
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|caller
op_eq
id|fl
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|overlap
c_func
(paren
id|caller
comma
id|fl
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Detect adjacent regions (if same lock type) ...&n;&t;&t;&t; */
r_if
c_cond
(paren
id|caller-&gt;fl_type
op_ne
id|fl-&gt;fl_type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|caller-&gt;fl_end
op_plus
l_int|1
op_eq
id|fl-&gt;fl_start
)paren
(brace
id|fl-&gt;fl_start
op_assign
id|caller-&gt;fl_start
suffix:semicolon
id|free_lock
c_func
(paren
id|filp
comma
id|caller
)paren
suffix:semicolon
id|caller
op_assign
id|fl
suffix:semicolon
multiline_comment|/* must continue, may overlap others now */
)brace
r_else
r_if
c_cond
(paren
id|caller-&gt;fl_start
op_minus
l_int|1
op_eq
id|fl-&gt;fl_end
)paren
(brace
id|fl-&gt;fl_end
op_assign
id|caller-&gt;fl_end
suffix:semicolon
id|free_lock
c_func
(paren
id|filp
comma
id|caller
)paren
suffix:semicolon
id|caller
op_assign
id|fl
suffix:semicolon
multiline_comment|/* must continue, may overlap others now */
)brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We&squot;ve found an overlapping region. Is it a change of lock&n;&t;&t; * type, or are we changing the size of the locked space?&n;&t;&t; */
r_if
c_cond
(paren
id|caller-&gt;fl_type
op_ne
id|fl-&gt;fl_type
)paren
(brace
r_if
c_cond
(paren
id|caller-&gt;fl_start
OG
id|fl-&gt;fl_start
op_logical_and
id|caller-&gt;fl_end
OL
id|fl-&gt;fl_end
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The new lock splits the old one in two ...&n;&t;&t;&t;&t; * {fl} is the bottom piece, {caller} is the&n;&t;&t;&t;&t; * new lock, and {new} is the top piece.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
r_new
op_assign
id|alloc_lock
c_func
(paren
id|filp
comma
id|fl
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|free_lock
c_func
(paren
id|filp
comma
id|caller
)paren
suffix:semicolon
r_return
op_minus
id|ENOLCK
suffix:semicolon
)brace
id|fl-&gt;fl_end
op_assign
id|caller-&gt;fl_start
op_minus
l_int|1
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_start
op_assign
id|caller-&gt;fl_end
op_plus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|caller-&gt;fl_start
op_le
id|fl-&gt;fl_start
op_logical_and
id|caller-&gt;fl_end
op_ge
id|fl-&gt;fl_end
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The new lock completely replaces old one ...&n;&t;&t;&t;&t; */
id|free_lock
c_func
(paren
id|filp
comma
id|fl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|caller-&gt;fl_end
OL
id|fl-&gt;fl_end
)paren
(brace
id|fl-&gt;fl_start
op_assign
id|caller-&gt;fl_end
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* must continue, may be more overlaps */
)brace
r_else
r_if
c_cond
(paren
id|caller-&gt;fl_start
OG
id|fl-&gt;fl_start
)paren
(brace
id|fl-&gt;fl_end
op_assign
id|caller-&gt;fl_start
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* must continue, may be more overlaps */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;lock_it: program bug: unanticipated overlap&bslash;n&quot;
)paren
suffix:semicolon
id|free_lock
c_func
(paren
id|filp
comma
id|caller
)paren
suffix:semicolon
r_return
op_minus
id|ENOLCK
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* The new lock augments an existing lock ... */
r_int
id|grew
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|caller-&gt;fl_start
OL
id|fl-&gt;fl_start
)paren
(brace
id|fl-&gt;fl_start
op_assign
id|caller-&gt;fl_start
suffix:semicolon
id|grew
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|caller-&gt;fl_end
OG
id|fl-&gt;fl_end
)paren
(brace
id|fl-&gt;fl_end
op_assign
id|caller-&gt;fl_end
suffix:semicolon
id|grew
op_assign
l_int|1
suffix:semicolon
)brace
id|free_lock
c_func
(paren
id|filp
comma
id|caller
)paren
suffix:semicolon
id|caller
op_assign
id|fl
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|grew
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* must continue, may be more overlaps */
)brace
)brace
multiline_comment|/*&n;&t; * New lock doesn&squot;t overlap any regions ...&n;&t; * alloc_lock() has already been called, so we&squot;re done!&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Handle F_UNLCK ...&n; * Result is 0 for success, or -EINVAL or -ENOLCK.&n; * ENOLCK can happen when a lock is split into two.&n; */
DECL|function|unlock_it
r_static
r_int
id|unlock_it
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|caller
)paren
(brace
r_int
id|one_unlocked
op_assign
l_int|0
suffix:semicolon
r_struct
id|file_lock
op_star
id|fl
comma
op_star
id|next
suffix:semicolon
r_for
c_loop
(paren
id|fl
op_assign
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|caller-&gt;fl_owner
op_ne
id|fl-&gt;fl_owner
op_logical_or
op_logical_neg
id|overlap
c_func
(paren
id|caller
comma
id|fl
)paren
)paren
(brace
id|fl
op_assign
id|fl-&gt;fl_next
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|one_unlocked
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|caller-&gt;fl_start
OG
id|fl-&gt;fl_start
op_logical_and
id|caller-&gt;fl_end
OL
id|fl-&gt;fl_end
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Lock is split in two ...&n;&t;&t;&t; * {fl} is the bottom piece, {next} is the top piece.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|next
op_assign
id|alloc_lock
c_func
(paren
id|filp
comma
id|fl
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOLCK
suffix:semicolon
id|fl-&gt;fl_end
op_assign
id|caller-&gt;fl_start
op_minus
l_int|1
suffix:semicolon
id|next-&gt;fl_start
op_assign
id|caller-&gt;fl_end
op_plus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * At this point we know there is an overlap and we know the&n;&t;&t; * lock isn&squot;t split into two ...&n;&t;&t; *&n;&t;&t; * Unless the lock table is broken, entries will not overlap.&n;&t;&t; * IE: User X won&squot;t have an entry locking bytes 1-3 and another&n;&t;&t; * entry locking bytes 3-5. Therefore, if the area being&n;&t;&t; * unlocked is a subset of the total area, we don&squot;t need to&n;&t;&t; * traverse any more of the list. The code is a tad more&n;&t;&t; * complicated by this optimization. Perhaps it&squot;s not worth it.&n;&t;&t; *&n;&t;&t; * WARNING: We assume free_lock() does not alter&n;&t;&t; *&t;{fl_start, fl_end}.&n;&t;&t; *&n;&t;&t; * {fl_next} gets clobbered when the entry is moved to&n;&t;&t; * the free list, so grab it now ...&n;&t;&t; */
id|next
op_assign
id|fl-&gt;fl_next
suffix:semicolon
r_if
c_cond
(paren
id|caller-&gt;fl_start
op_le
id|fl-&gt;fl_start
op_logical_and
id|caller-&gt;fl_end
op_ge
id|fl-&gt;fl_end
)paren
(brace
id|free_lock
c_func
(paren
id|filp
comma
id|fl
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|caller-&gt;fl_start
OG
id|fl-&gt;fl_start
)paren
(brace
id|fl-&gt;fl_end
op_assign
id|caller-&gt;fl_start
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* caller-&gt;fl_end &lt; fl-&gt;fl_end */
id|fl-&gt;fl_start
op_assign
id|caller-&gt;fl_end
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|caller-&gt;fl_start
op_ge
id|fl-&gt;fl_start
op_logical_and
id|caller-&gt;fl_end
op_le
id|fl-&gt;fl_end
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* no more to be found */
id|fl
op_assign
id|next
suffix:semicolon
multiline_comment|/* must continue, there may be more to unlock */
)brace
r_return
id|one_unlocked
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|alloc_lock
r_static
r_struct
id|file_lock
op_star
id|alloc_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
r_template
)paren
(brace
r_struct
id|file_lock
op_star
r_new
suffix:semicolon
r_if
c_cond
(paren
id|file_lock_free_list
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* no available entry */
r_if
c_cond
(paren
id|file_lock_free_list-&gt;fl_owner
op_ne
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;alloc_lock: broken free list&bslash;n&quot;
)paren
suffix:semicolon
r_new
op_assign
id|file_lock_free_list
suffix:semicolon
multiline_comment|/* remove from free list */
id|file_lock_free_list
op_assign
id|file_lock_free_list-&gt;fl_next
suffix:semicolon
op_star
r_new
op_assign
op_star
r_template
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_next
op_assign
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
multiline_comment|/* insert into file&squot;s list */
id|filp-&gt;f_inode-&gt;i_flock
op_assign
r_new
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_owner
op_assign
id|current
suffix:semicolon
multiline_comment|/* FIXME: needed? */
r_new
op_member_access_from_pointer
id|fl_wait
op_assign
l_int|NULL
suffix:semicolon
r_return
r_new
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a lock to the free list ...&n; *&n; * WARNING: We must not alter {fl_start, fl_end}. See unlock_it().&n; */
DECL|function|free_lock
r_static
r_void
id|free_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
r_struct
id|file_lock
op_star
op_star
id|fl_p
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_owner
op_eq
l_int|NULL
)paren
multiline_comment|/* sanity check */
id|panic
c_func
(paren
l_string|&quot;free_lock: broken lock list&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We only use a singly linked list to save some memory space&n;&t; * (the only place we&squot;d use a doubly linked list is here).&n;&t; */
r_for
c_loop
(paren
id|fl_p
op_assign
op_amp
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
op_star
id|fl_p
op_ne
l_int|NULL
suffix:semicolon
id|fl_p
op_assign
op_amp
(paren
op_star
id|fl_p
)paren
op_member_access_from_pointer
id|fl_next
)paren
(brace
r_if
c_cond
(paren
op_star
id|fl_p
op_eq
id|fl
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|fl_p
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;free_lock: lock is not in file&squot;s lock list&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|fl_p
op_assign
(paren
op_star
id|fl_p
)paren
op_member_access_from_pointer
id|fl_next
suffix:semicolon
)brace
id|fl-&gt;fl_next
op_assign
id|file_lock_free_list
suffix:semicolon
multiline_comment|/* add to free list */
id|file_lock_free_list
op_assign
id|fl
suffix:semicolon
id|fl-&gt;fl_owner
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* for sanity checks */
id|wake_up
c_func
(paren
op_amp
id|fl-&gt;fl_wait
)paren
suffix:semicolon
)brace
eof
