DECL|macro|MSNFS
mdefine_line|#define MSNFS&t;/* HACK HACK */
multiline_comment|/*&n; *  linux/fs/locks.c&n; *&n; *  Provide support for fcntl()&squot;s F_GETLK, F_SETLK, and F_SETLKW calls.&n; *  Doug Evans (dje@spiff.uucp), August 07, 1992&n; *&n; *  Deadlock detection added.&n; *  FIXME: one thing isn&squot;t handled yet:&n; *&t;- mandatory locks (requires lots of changes elsewhere)&n; *  Kelly Carmichael (kelly@[142.24.8.65]), September 17, 1994.&n; *&n; *  Miscellaneous edits, and a total rewrite of posix_lock_file() code.&n; *  Kai Petzke (wpp@marie.physik.tu-berlin.de), 1994&n; *  &n; *  Converted file_lock_table to a linked list from an array, which eliminates&n; *  the limits on how many active file locks are open.&n; *  Chad Page (pageone@netcom.com), November 27, 1994&n; * &n; *  Removed dependency on file descriptors. dup()&squot;ed file descriptors now&n; *  get the same locks as the original file descriptors, and a close() on&n; *  any file descriptor removes ALL the locks on the file for the current&n; *  process. Since locks still depend on the process id, locks are inherited&n; *  after an exec() but not after a fork(). This agrees with POSIX, and both&n; *  BSD and SVR4 practice.&n; *  Andy Walker (andy@lysaker.kvaerner.no), February 14, 1995&n; *&n; *  Scrapped free list which is redundant now that we allocate locks&n; *  dynamically with kmalloc()/kfree().&n; *  Andy Walker (andy@lysaker.kvaerner.no), February 21, 1995&n; *&n; *  Implemented two lock personalities - FL_FLOCK and FL_POSIX.&n; *&n; *  FL_POSIX locks are created with calls to fcntl() and lockf() through the&n; *  fcntl() system call. They have the semantics described above.&n; *&n; *  FL_FLOCK locks are created with calls to flock(), through the flock()&n; *  system call, which is new. Old C libraries implement flock() via fcntl()&n; *  and will continue to use the old, broken implementation.&n; *&n; *  FL_FLOCK locks follow the 4.4 BSD flock() semantics. They are associated&n; *  with a file pointer (filp). As a result they can be shared by a parent&n; *  process and its children after a fork(). They are removed when the last&n; *  file descriptor referring to the file pointer is closed (unless explicitly&n; *  unlocked). &n; *&n; *  FL_FLOCK locks never deadlock, an existing lock is always removed before&n; *  upgrading from shared to exclusive (or vice versa). When this happens&n; *  any processes blocked by the current lock are woken up and allowed to&n; *  run before the new lock is applied.&n; *  Andy Walker (andy@lysaker.kvaerner.no), June 09, 1995&n; *&n; *  Removed some race conditions in flock_lock_file(), marked other possible&n; *  races. Just grep for FIXME to see them. &n; *  Dmitry Gorodchanin (pgmdsg@ibi.com), February 09, 1996.&n; *&n; *  Addressed Dmitry&squot;s concerns. Deadlock checking no longer recursive.&n; *  Lock allocation changed to GFP_ATOMIC as we can&squot;t afford to sleep&n; *  once we&squot;ve checked for blocking and deadlocking.&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 03, 1996.&n; *&n; *  Initial implementation of mandatory locks. SunOS turned out to be&n; *  a rotten model, so I implemented the &quot;obvious&quot; semantics.&n; *  See &squot;linux/Documentation/mandatory.txt&squot; for details.&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 06, 1996.&n; *&n; *  Don&squot;t allow mandatory locks on mmap()&squot;ed files. Added simple functions to&n; *  check if a file has mandatory locks, used by mmap(), open() and creat() to&n; *  see if system call should be rejected. Ref. HP-UX/SunOS/Solaris Reference&n; *  Manual, Section 2.&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 09, 1996.&n; *&n; *  Tidied up block list handling. Added &squot;/proc/locks&squot; interface.&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 24, 1996.&n; *&n; *  Fixed deadlock condition for pathological code that mixes calls to&n; *  flock() and fcntl().&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 29, 1996.&n; *&n; *  Allow only one type of locking scheme (FL_POSIX or FL_FLOCK) to be in use&n; *  for a given file at a time. Changed the CONFIG_LOCK_MANDATORY scheme to&n; *  guarantee sensible behaviour in the case where file system modules might&n; *  be compiled with different options than the kernel itself.&n; *  Andy Walker (andy@lysaker.kvaerner.no), May 15, 1996.&n; *&n; *  Added a couple of missing wake_up() calls. Thanks to Thomas Meckel&n; *  (Thomas.Meckel@mni.fh-giessen.de) for spotting this.&n; *  Andy Walker (andy@lysaker.kvaerner.no), May 15, 1996.&n; *&n; *  Changed FL_POSIX locks to use the block list in the same way as FL_FLOCK&n; *  locks. Changed process synchronisation to avoid dereferencing locks that&n; *  have already been freed.&n; *  Andy Walker (andy@lysaker.kvaerner.no), Sep 21, 1996.&n; *&n; *  Made the block list a circular list to minimise searching in the list.&n; *  Andy Walker (andy@lysaker.kvaerner.no), Sep 25, 1996.&n; *&n; *  Made mandatory locking a mount option. Default is not to allow mandatory&n; *  locking.&n; *  Andy Walker (andy@lysaker.kvaerner.no), Oct 04, 1996.&n; *&n; *  Some adaptations for NFS support.&n; *  Olaf Kirch (okir@monad.swb.de), Dec 1996,&n; *&n; *  Fixed /proc/locks interface so that we can&squot;t overrun the buffer we are handed.&n; *  Andy Walker (andy@lysaker.kvaerner.no), May 12, 1997.&n; *&n; *  Use slab allocator instead of kmalloc/kfree.&n; *  Use generic list implementation from &lt;linux/list.h&gt;.&n; *  Sped up posix_locks_deadlock by only considering blocked locks.&n; *  Matthew Wilcox &lt;willy@thepuffingroup.com&gt;, March, 2000.&n; *&n; *  Leases and LOCK_MAND&n; *  Matthew Wilcox &lt;willy@linuxcare.com&gt;, June, 2000.&n; *  Stephen Rothwell &lt;sfr@linuxcare.com&gt;, June, 2000.&n; */
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/capability.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|variable|leases_enable
r_int
id|leases_enable
op_assign
l_int|1
suffix:semicolon
DECL|variable|lease_break_time
r_int
id|lease_break_time
op_assign
l_int|45
suffix:semicolon
DECL|variable|file_lock_list
id|LIST_HEAD
c_func
(paren
id|file_lock_list
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|blocked_list
)paren
suffix:semicolon
DECL|variable|filelock_cache
r_static
id|kmem_cache_t
op_star
id|filelock_cache
suffix:semicolon
multiline_comment|/* Allocate an empty lock structure. */
DECL|function|locks_alloc_lock
r_static
r_struct
id|file_lock
op_star
id|locks_alloc_lock
c_func
(paren
r_int
id|account
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_if
c_cond
(paren
id|account
op_logical_and
id|current-&gt;locks
op_ge
id|current-&gt;rlim
(braket
id|RLIMIT_LOCKS
)braket
dot
id|rlim_cur
)paren
r_return
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|kmem_cache_alloc
c_func
(paren
id|filelock_cache
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fl
)paren
id|current-&gt;locks
op_increment
suffix:semicolon
r_return
id|fl
suffix:semicolon
)brace
multiline_comment|/* Free a lock which is not in use. */
DECL|function|locks_free_lock
r_static
r_inline
r_void
id|locks_free_lock
c_func
(paren
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
r_if
c_cond
(paren
id|fl
op_eq
l_int|NULL
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|current-&gt;locks
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|fl-&gt;fl_wait
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Attempting to free lock with active wait queue&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|fl-&gt;fl_block
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Attempting to free lock with active block list&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|fl-&gt;fl_link
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Attempting to free lock on active lock list&quot;
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|filelock_cache
comma
id|fl
)paren
suffix:semicolon
)brace
DECL|function|locks_init_lock
r_void
id|locks_init_lock
c_func
(paren
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|fl-&gt;fl_link
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|fl-&gt;fl_block
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|fl-&gt;fl_wait
)paren
suffix:semicolon
id|fl-&gt;fl_next
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_fasync
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_owner
op_assign
l_int|0
suffix:semicolon
id|fl-&gt;fl_pid
op_assign
l_int|0
suffix:semicolon
id|fl-&gt;fl_file
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_flags
op_assign
l_int|0
suffix:semicolon
id|fl-&gt;fl_type
op_assign
l_int|0
suffix:semicolon
id|fl-&gt;fl_start
op_assign
id|fl-&gt;fl_end
op_assign
l_int|0
suffix:semicolon
id|fl-&gt;fl_notify
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_insert
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_remove
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialises the fields of the file lock which are invariant for&n; * free file_locks.&n; */
DECL|function|init_once
r_static
r_void
id|init_once
c_func
(paren
r_void
op_star
id|foo
comma
id|kmem_cache_t
op_star
id|cache
comma
r_int
r_int
id|flags
)paren
(brace
r_struct
id|file_lock
op_star
id|lock
op_assign
(paren
r_struct
id|file_lock
op_star
)paren
id|foo
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
(paren
id|SLAB_CTOR_VERIFY
op_or
id|SLAB_CTOR_CONSTRUCTOR
)paren
)paren
op_ne
id|SLAB_CTOR_CONSTRUCTOR
)paren
r_return
suffix:semicolon
id|locks_init_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize a new lock from an existing file_lock structure.&n; */
DECL|function|locks_copy_lock
r_void
id|locks_copy_lock
c_func
(paren
r_struct
id|file_lock
op_star
r_new
comma
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
r_new
op_member_access_from_pointer
id|fl_owner
op_assign
id|fl-&gt;fl_owner
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_pid
op_assign
id|fl-&gt;fl_pid
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_file
op_assign
id|fl-&gt;fl_file
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_flags
op_assign
id|fl-&gt;fl_flags
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_type
op_assign
id|fl-&gt;fl_type
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_start
op_assign
id|fl-&gt;fl_start
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_end
op_assign
id|fl-&gt;fl_end
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_notify
op_assign
id|fl-&gt;fl_notify
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_insert
op_assign
id|fl-&gt;fl_insert
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_remove
op_assign
id|fl-&gt;fl_remove
suffix:semicolon
r_new
op_member_access_from_pointer
id|fl_u
op_assign
id|fl-&gt;fl_u
suffix:semicolon
)brace
multiline_comment|/* Fill in a file_lock structure with an appropriate FLOCK lock. */
DECL|function|flock_make_lock
r_static
r_struct
id|file_lock
op_star
id|flock_make_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|type
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
op_assign
id|locks_alloc_lock
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fl
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_owner
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_file
op_assign
id|filp
suffix:semicolon
id|fl-&gt;fl_pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|fl-&gt;fl_flags
op_assign
id|FL_FLOCK
suffix:semicolon
id|fl-&gt;fl_type
op_assign
id|type
suffix:semicolon
id|fl-&gt;fl_start
op_assign
l_int|0
suffix:semicolon
id|fl-&gt;fl_end
op_assign
id|OFFSET_MAX
suffix:semicolon
id|fl-&gt;fl_notify
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_insert
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_remove
op_assign
l_int|NULL
suffix:semicolon
r_return
id|fl
suffix:semicolon
)brace
DECL|function|assign_type
r_static
r_int
id|assign_type
c_func
(paren
r_struct
id|file_lock
op_star
id|fl
comma
r_int
id|type
)paren
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|F_RDLCK
suffix:colon
r_case
id|F_WRLCK
suffix:colon
r_case
id|F_UNLCK
suffix:colon
id|fl-&gt;fl_type
op_assign
id|type
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Verify a &quot;struct flock&quot; and copy it to a &quot;struct file_lock&quot; as a POSIX&n; * style lock.&n; */
DECL|function|flock_to_posix_lock
r_static
r_int
id|flock_to_posix_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
comma
r_struct
id|flock
op_star
id|l
)paren
(brace
id|loff_t
id|start
suffix:semicolon
r_switch
c_cond
(paren
id|l-&gt;l_whence
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/*SEEK_SET*/
id|start
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/*SEEK_CUR*/
id|start
op_assign
id|filp-&gt;f_pos
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/*SEEK_END*/
id|start
op_assign
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_size
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|start
op_add_assign
id|l-&gt;l_start
)paren
OL
l_int|0
)paren
op_logical_or
(paren
id|l-&gt;l_len
OL
l_int|0
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|fl-&gt;fl_end
op_assign
id|start
op_plus
id|l-&gt;l_len
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|l-&gt;l_len
OG
l_int|0
op_logical_and
id|fl-&gt;fl_end
OL
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_end
OG
id|OFFT_OFFSET_MAX
)paren
r_return
l_int|0
suffix:semicolon
id|fl-&gt;fl_start
op_assign
id|start
suffix:semicolon
multiline_comment|/* we record the absolute position */
r_if
c_cond
(paren
id|l-&gt;l_len
op_eq
l_int|0
)paren
id|fl-&gt;fl_end
op_assign
id|OFFSET_MAX
suffix:semicolon
id|fl-&gt;fl_owner
op_assign
id|current-&gt;files
suffix:semicolon
id|fl-&gt;fl_pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|fl-&gt;fl_file
op_assign
id|filp
suffix:semicolon
id|fl-&gt;fl_flags
op_assign
id|FL_POSIX
suffix:semicolon
id|fl-&gt;fl_notify
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_insert
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_remove
op_assign
l_int|NULL
suffix:semicolon
r_return
(paren
id|assign_type
c_func
(paren
id|fl
comma
id|l-&gt;l_type
)paren
op_eq
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#if BITS_PER_LONG == 32
DECL|function|flock64_to_posix_lock
r_static
r_int
id|flock64_to_posix_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
comma
r_struct
id|flock64
op_star
id|l
)paren
(brace
id|loff_t
id|start
suffix:semicolon
r_switch
c_cond
(paren
id|l-&gt;l_whence
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/*SEEK_SET*/
id|start
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/*SEEK_CUR*/
id|start
op_assign
id|filp-&gt;f_pos
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/*SEEK_END*/
id|start
op_assign
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_size
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|start
op_add_assign
id|l-&gt;l_start
)paren
OL
l_int|0
)paren
op_logical_or
(paren
id|l-&gt;l_len
OL
l_int|0
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|fl-&gt;fl_end
op_assign
id|start
op_plus
id|l-&gt;l_len
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|l-&gt;l_len
OG
l_int|0
op_logical_and
id|fl-&gt;fl_end
OL
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|fl-&gt;fl_start
op_assign
id|start
suffix:semicolon
multiline_comment|/* we record the absolute position */
r_if
c_cond
(paren
id|l-&gt;l_len
op_eq
l_int|0
)paren
id|fl-&gt;fl_end
op_assign
id|OFFSET_MAX
suffix:semicolon
id|fl-&gt;fl_owner
op_assign
id|current-&gt;files
suffix:semicolon
id|fl-&gt;fl_pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|fl-&gt;fl_file
op_assign
id|filp
suffix:semicolon
id|fl-&gt;fl_flags
op_assign
id|FL_POSIX
suffix:semicolon
id|fl-&gt;fl_notify
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_insert
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_remove
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|l-&gt;l_type
)paren
(brace
r_case
id|F_RDLCK
suffix:colon
r_case
id|F_WRLCK
suffix:colon
r_case
id|F_UNLCK
suffix:colon
id|fl-&gt;fl_type
op_assign
id|l-&gt;l_type
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Allocate a file_lock initialised to this type of lease */
DECL|function|lease_alloc
r_static
r_int
id|lease_alloc
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_int
id|type
comma
r_struct
id|file_lock
op_star
op_star
id|flp
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
op_assign
id|locks_alloc_lock
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fl
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|fl-&gt;fl_owner
op_assign
id|current-&gt;files
suffix:semicolon
id|fl-&gt;fl_pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|fl-&gt;fl_file
op_assign
id|filp
suffix:semicolon
id|fl-&gt;fl_flags
op_assign
id|FL_LEASE
suffix:semicolon
r_if
c_cond
(paren
id|assign_type
c_func
(paren
id|fl
comma
id|type
)paren
op_ne
l_int|0
)paren
(brace
id|locks_free_lock
c_func
(paren
id|fl
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|fl-&gt;fl_start
op_assign
l_int|0
suffix:semicolon
id|fl-&gt;fl_end
op_assign
id|OFFSET_MAX
suffix:semicolon
id|fl-&gt;fl_notify
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_insert
op_assign
l_int|NULL
suffix:semicolon
id|fl-&gt;fl_remove
op_assign
l_int|NULL
suffix:semicolon
op_star
id|flp
op_assign
id|fl
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Check if two locks overlap each other.&n; */
DECL|function|locks_overlap
r_static
r_inline
r_int
id|locks_overlap
c_func
(paren
r_struct
id|file_lock
op_star
id|fl1
comma
r_struct
id|file_lock
op_star
id|fl2
)paren
(brace
r_return
(paren
(paren
id|fl1-&gt;fl_end
op_ge
id|fl2-&gt;fl_start
)paren
op_logical_and
(paren
id|fl2-&gt;fl_end
op_ge
id|fl1-&gt;fl_start
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check whether two locks have the same owner&n; * N.B. Do we need the test on PID as well as owner?&n; * (Clone tasks should be considered as one &quot;owner&quot;.)&n; */
r_static
r_inline
r_int
DECL|function|locks_same_owner
id|locks_same_owner
c_func
(paren
r_struct
id|file_lock
op_star
id|fl1
comma
r_struct
id|file_lock
op_star
id|fl2
)paren
(brace
r_return
(paren
id|fl1-&gt;fl_owner
op_eq
id|fl2-&gt;fl_owner
)paren
op_logical_and
(paren
id|fl1-&gt;fl_pid
op_eq
id|fl2-&gt;fl_pid
)paren
suffix:semicolon
)brace
multiline_comment|/* Remove waiter from blocker&squot;s block list.&n; * When blocker ends up pointing to itself then the list is empty.&n; */
DECL|function|locks_delete_block
r_static
r_void
id|locks_delete_block
c_func
(paren
r_struct
id|file_lock
op_star
id|waiter
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|waiter-&gt;fl_block
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|waiter-&gt;fl_block
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|waiter-&gt;fl_link
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|waiter-&gt;fl_link
)paren
suffix:semicolon
id|waiter-&gt;fl_next
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Insert waiter into blocker&squot;s block list.&n; * We use a circular list so that processes can be easily woken up in&n; * the order they blocked. The documentation doesn&squot;t require this but&n; * it seems like the reasonable thing to do.&n; */
DECL|function|locks_insert_block
r_static
r_void
id|locks_insert_block
c_func
(paren
r_struct
id|file_lock
op_star
id|blocker
comma
r_struct
id|file_lock
op_star
id|waiter
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|waiter-&gt;fl_block
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;locks_insert_block: removing duplicated lock &quot;
l_string|&quot;(pid=%d %Ld-%Ld type=%d)&bslash;n&quot;
comma
id|waiter-&gt;fl_pid
comma
id|waiter-&gt;fl_start
comma
id|waiter-&gt;fl_end
comma
id|waiter-&gt;fl_type
)paren
suffix:semicolon
id|locks_delete_block
c_func
(paren
id|waiter
)paren
suffix:semicolon
)brace
id|list_add_tail
c_func
(paren
op_amp
id|waiter-&gt;fl_block
comma
op_amp
id|blocker-&gt;fl_block
)paren
suffix:semicolon
id|waiter-&gt;fl_next
op_assign
id|blocker
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|waiter-&gt;fl_link
comma
op_amp
id|blocked_list
)paren
suffix:semicolon
)brace
r_static
r_inline
DECL|function|locks_notify_blocked
r_void
id|locks_notify_blocked
c_func
(paren
r_struct
id|file_lock
op_star
id|waiter
)paren
(brace
r_if
c_cond
(paren
id|waiter-&gt;fl_notify
)paren
id|waiter
op_member_access_from_pointer
id|fl_notify
c_func
(paren
id|waiter
)paren
suffix:semicolon
r_else
id|wake_up
c_func
(paren
op_amp
id|waiter-&gt;fl_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* Wake up processes blocked waiting for blocker.&n; * If told to wait then schedule the processes until the block list&n; * is empty, otherwise empty the block list ourselves.&n; */
DECL|function|locks_wake_up_blocks
r_static
r_void
id|locks_wake_up_blocks
c_func
(paren
r_struct
id|file_lock
op_star
id|blocker
comma
r_int
r_int
id|wait
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|blocker-&gt;fl_block
)paren
)paren
(brace
r_struct
id|file_lock
op_star
id|waiter
op_assign
id|list_entry
c_func
(paren
id|blocker-&gt;fl_block.next
comma
r_struct
id|file_lock
comma
id|fl_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
(brace
id|locks_notify_blocked
c_func
(paren
id|waiter
)paren
suffix:semicolon
multiline_comment|/* Let the blocked process remove waiter from the&n;&t;&t;&t; * block list when it gets scheduled.&n;&t;&t;&t; */
id|current-&gt;policy
op_or_assign
id|SCHED_YIELD
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Remove waiter from the block list, because by the&n;&t;&t;&t; * time it wakes up blocker won&squot;t exist any more.&n;&t;&t;&t; */
id|locks_delete_block
c_func
(paren
id|waiter
)paren
suffix:semicolon
id|locks_notify_blocked
c_func
(paren
id|waiter
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Insert file lock fl into an inode&squot;s lock list at the position indicated&n; * by pos. At the same time add the lock to the global file lock list.&n; */
DECL|function|locks_insert_lock
r_static
r_void
id|locks_insert_lock
c_func
(paren
r_struct
id|file_lock
op_star
op_star
id|pos
comma
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|fl-&gt;fl_link
comma
op_amp
id|file_lock_list
)paren
suffix:semicolon
multiline_comment|/* insert into file&squot;s list */
id|fl-&gt;fl_next
op_assign
op_star
id|pos
suffix:semicolon
op_star
id|pos
op_assign
id|fl
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_insert
)paren
id|fl
op_member_access_from_pointer
id|fl_insert
c_func
(paren
id|fl
)paren
suffix:semicolon
)brace
multiline_comment|/* Delete a lock and then free it.&n; * Remove our lock from the lock lists, wake up processes that are blocked&n; * waiting for this lock, notify the FS that the lock has been cleared and&n; * finally free the lock.&n; */
DECL|function|locks_delete_lock
r_static
r_void
id|locks_delete_lock
c_func
(paren
r_struct
id|file_lock
op_star
op_star
id|thisfl_p
comma
r_int
r_int
id|wait
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
op_assign
op_star
id|thisfl_p
suffix:semicolon
op_star
id|thisfl_p
op_assign
id|fl-&gt;fl_next
suffix:semicolon
id|fl-&gt;fl_next
op_assign
l_int|NULL
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|fl-&gt;fl_link
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|fl-&gt;fl_link
)paren
suffix:semicolon
id|fasync_helper
c_func
(paren
l_int|0
comma
id|fl-&gt;fl_file
comma
l_int|0
comma
op_amp
id|fl-&gt;fl_fasync
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_fasync
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;locks_delete_lock: fasync == %p&bslash;n&quot;
comma
id|fl-&gt;fl_fasync
)paren
suffix:semicolon
id|fl-&gt;fl_fasync
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fl-&gt;fl_remove
)paren
id|fl
op_member_access_from_pointer
id|fl_remove
c_func
(paren
id|fl
)paren
suffix:semicolon
id|locks_wake_up_blocks
c_func
(paren
id|fl
comma
id|wait
)paren
suffix:semicolon
id|locks_free_lock
c_func
(paren
id|fl
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Call back client filesystem in order to get it to unregister a lock,&n; * then delete lock. Essentially useful only in locks_remove_*().&n; * Note: this must be called with the semaphore already held!&n; */
DECL|function|locks_unlock_delete
r_static
r_inline
r_void
id|locks_unlock_delete
c_func
(paren
r_struct
id|file_lock
op_star
op_star
id|thisfl_p
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
op_assign
op_star
id|thisfl_p
suffix:semicolon
r_int
(paren
op_star
id|lock
)paren
(paren
r_struct
id|file
op_star
comma
r_int
comma
r_struct
id|file_lock
op_star
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_file-&gt;f_op
op_logical_and
(paren
id|lock
op_assign
id|fl-&gt;fl_file-&gt;f_op-&gt;lock
)paren
op_ne
l_int|NULL
)paren
(brace
id|fl-&gt;fl_type
op_assign
id|F_UNLCK
suffix:semicolon
id|lock
c_func
(paren
id|fl-&gt;fl_file
comma
id|F_SETLK
comma
id|fl
)paren
suffix:semicolon
)brace
id|locks_delete_lock
c_func
(paren
id|thisfl_p
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Determine if lock sys_fl blocks lock caller_fl. Common functionality&n; * checks for shared/exclusive status of overlapping locks.&n; */
DECL|function|locks_conflict
r_static
r_int
id|locks_conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
(brace
r_switch
c_cond
(paren
id|caller_fl-&gt;fl_type
)paren
(brace
r_case
id|F_RDLCK
suffix:colon
r_return
(paren
id|sys_fl-&gt;fl_type
op_eq
id|F_WRLCK
)paren
suffix:semicolon
r_case
id|F_WRLCK
suffix:colon
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;locks_conflict(): impossible lock type - %d&bslash;n&quot;
comma
id|caller_fl-&gt;fl_type
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* This should never happen */
)brace
multiline_comment|/* Determine if lock sys_fl blocks lock caller_fl. POSIX specific&n; * checking before calling the locks_conflict().&n; */
DECL|function|posix_locks_conflict
r_static
r_int
id|posix_locks_conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
(brace
multiline_comment|/* POSIX locks owned by the same process do not conflict with&n;&t; * each other.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sys_fl-&gt;fl_flags
op_amp
id|FL_POSIX
)paren
op_logical_or
id|locks_same_owner
c_func
(paren
id|caller_fl
comma
id|sys_fl
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Check whether they overlap */
r_if
c_cond
(paren
op_logical_neg
id|locks_overlap
c_func
(paren
id|caller_fl
comma
id|sys_fl
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
id|locks_conflict
c_func
(paren
id|caller_fl
comma
id|sys_fl
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Determine if lock sys_fl blocks lock caller_fl. FLOCK specific&n; * checking before calling the locks_conflict().&n; */
DECL|function|flock_locks_conflict
r_static
r_int
id|flock_locks_conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
(brace
multiline_comment|/* FLOCK locks referring to the same filp do not conflict with&n;&t; * each other.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|sys_fl-&gt;fl_flags
op_amp
id|FL_FLOCK
)paren
op_logical_or
(paren
id|caller_fl-&gt;fl_file
op_eq
id|sys_fl-&gt;fl_file
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef MSNFS
r_if
c_cond
(paren
(paren
id|caller_fl-&gt;fl_type
op_amp
id|LOCK_MAND
)paren
op_logical_or
(paren
id|sys_fl-&gt;fl_type
op_amp
id|LOCK_MAND
)paren
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#endif
r_return
(paren
id|locks_conflict
c_func
(paren
id|caller_fl
comma
id|sys_fl
)paren
)paren
suffix:semicolon
)brace
DECL|function|interruptible_sleep_on_locked
r_static
r_int
id|interruptible_sleep_on_locked
c_func
(paren
id|wait_queue_head_t
op_star
id|fl_wait
comma
r_int
id|timeout
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|fl_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
op_eq
l_int|0
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_else
id|result
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
id|result
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|fl_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|locks_block_on
r_static
r_int
id|locks_block_on
c_func
(paren
r_struct
id|file_lock
op_star
id|blocker
comma
r_struct
id|file_lock
op_star
id|waiter
)paren
(brace
r_int
id|result
suffix:semicolon
id|locks_insert_block
c_func
(paren
id|blocker
comma
id|waiter
)paren
suffix:semicolon
id|result
op_assign
id|interruptible_sleep_on_locked
c_func
(paren
op_amp
id|waiter-&gt;fl_wait
comma
l_int|0
)paren
suffix:semicolon
id|locks_delete_block
c_func
(paren
id|waiter
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|locks_block_on_timeout
r_static
r_int
id|locks_block_on_timeout
c_func
(paren
r_struct
id|file_lock
op_star
id|blocker
comma
r_struct
id|file_lock
op_star
id|waiter
comma
r_int
id|time
)paren
(brace
r_int
id|result
suffix:semicolon
id|locks_insert_block
c_func
(paren
id|blocker
comma
id|waiter
)paren
suffix:semicolon
id|result
op_assign
id|interruptible_sleep_on_locked
c_func
(paren
op_amp
id|waiter-&gt;fl_wait
comma
id|time
)paren
suffix:semicolon
id|locks_delete_block
c_func
(paren
id|waiter
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_struct
id|file_lock
op_star
DECL|function|posix_test_lock
id|posix_test_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
r_struct
id|file_lock
op_star
id|cfl
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cfl
op_assign
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_flock
suffix:semicolon
id|cfl
suffix:semicolon
id|cfl
op_assign
id|cfl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|cfl-&gt;fl_flags
op_amp
id|FL_POSIX
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|posix_locks_conflict
c_func
(paren
id|cfl
comma
id|fl
)paren
)paren
r_break
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|cfl
)paren
suffix:semicolon
)brace
multiline_comment|/* This function tests for deadlock condition before putting a process to&n; * sleep. The detection scheme is no longer recursive. Recursive was neat,&n; * but dangerous - we risked stack corruption if the lock data was bad, or&n; * if the recursion was too deep for any other reason.&n; *&n; * We rely on the fact that a task can only be on one lock&squot;s wait queue&n; * at a time. When we find blocked_task on a wait queue we can re-search&n; * with blocked_task equal to that queue&squot;s owner, until either blocked_task&n; * isn&squot;t found, or blocked_task is found on a queue owned by my_task.&n; *&n; * Note: the above assumption may not be true when handling lock requests&n; * from a broken NFS client. But broken NFS clients have a lot more to&n; * worry about than proper deadlock detection anyway... --okir&n; */
DECL|function|posix_locks_deadlock
r_static
r_int
id|posix_locks_deadlock
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|block_fl
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|fl_owner_t
id|caller_owner
comma
id|blocked_owner
suffix:semicolon
r_int
r_int
id|caller_pid
comma
id|blocked_pid
suffix:semicolon
id|caller_owner
op_assign
id|caller_fl-&gt;fl_owner
suffix:semicolon
id|caller_pid
op_assign
id|caller_fl-&gt;fl_pid
suffix:semicolon
id|blocked_owner
op_assign
id|block_fl-&gt;fl_owner
suffix:semicolon
id|blocked_pid
op_assign
id|block_fl-&gt;fl_pid
suffix:semicolon
id|next_task
suffix:colon
r_if
c_cond
(paren
id|caller_owner
op_eq
id|blocked_owner
op_logical_and
id|caller_pid
op_eq
id|blocked_pid
)paren
r_return
l_int|1
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|blocked_list
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|file_lock
comma
id|fl_link
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fl-&gt;fl_owner
op_eq
id|blocked_owner
)paren
op_logical_and
(paren
id|fl-&gt;fl_pid
op_eq
id|blocked_pid
)paren
)paren
(brace
id|fl
op_assign
id|fl-&gt;fl_next
suffix:semicolon
id|blocked_owner
op_assign
id|fl-&gt;fl_owner
suffix:semicolon
id|blocked_pid
op_assign
id|fl-&gt;fl_pid
suffix:semicolon
r_goto
id|next_task
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|locks_mandatory_locked
r_int
id|locks_mandatory_locked
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|fl_owner_t
id|owner
op_assign
id|current-&gt;files
suffix:semicolon
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
multiline_comment|/*&n;&t; * Search the lock list for this inode for any POSIX locks.&n;&t; */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|fl
op_assign
id|inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_POSIX
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_owner
op_ne
id|owner
)paren
r_break
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|fl
ques
c_cond
op_minus
id|EAGAIN
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|locks_mandatory_area
r_int
id|locks_mandatory_area
c_func
(paren
r_int
id|read_write
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
id|loff_t
id|offset
comma
r_int
id|count
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_struct
id|file_lock
op_star
id|new_fl
op_assign
id|locks_alloc_lock
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
id|new_fl-&gt;fl_owner
op_assign
id|current-&gt;files
suffix:semicolon
id|new_fl-&gt;fl_pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|new_fl-&gt;fl_file
op_assign
id|filp
suffix:semicolon
id|new_fl-&gt;fl_flags
op_assign
id|FL_POSIX
op_or
id|FL_ACCESS
suffix:semicolon
id|new_fl-&gt;fl_type
op_assign
(paren
id|read_write
op_eq
id|FLOCK_VERIFY_WRITE
)paren
ques
c_cond
id|F_WRLCK
suffix:colon
id|F_RDLCK
suffix:semicolon
id|new_fl-&gt;fl_start
op_assign
id|offset
suffix:semicolon
id|new_fl-&gt;fl_end
op_assign
id|offset
op_plus
id|count
op_minus
l_int|1
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|repeat
suffix:colon
multiline_comment|/* Search the lock list for this inode for locks that conflict with&n;&t; * the proposed read/write.&n;&t; */
r_for
c_loop
(paren
id|fl
op_assign
id|inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_POSIX
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_start
OG
id|new_fl-&gt;fl_end
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|posix_locks_conflict
c_func
(paren
id|new_fl
comma
id|fl
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|filp
op_logical_and
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
)paren
r_break
suffix:semicolon
id|error
op_assign
op_minus
id|EDEADLK
suffix:semicolon
r_if
c_cond
(paren
id|posix_locks_deadlock
c_func
(paren
id|new_fl
comma
id|fl
)paren
)paren
r_break
suffix:semicolon
id|error
op_assign
id|locks_block_on
c_func
(paren
id|fl
comma
id|new_fl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If we&squot;ve been sleeping someone might have&n;&t;&t;&t; * changed the permissions behind our back.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_ISGID
op_or
id|S_IXGRP
)paren
)paren
op_ne
id|S_ISGID
)paren
r_break
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
id|locks_free_lock
c_func
(paren
id|new_fl
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Try to create a FLOCK lock on filp. We always insert new FLOCK locks&n; * at the head of the list, but that&squot;s secret knowledge known only to&n; * flock_lock_file and posix_lock_file.&n; */
DECL|function|flock_lock_file
r_static
r_int
id|flock_lock_file
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|lock_type
comma
r_int
r_int
id|wait
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_struct
id|file_lock
op_star
id|new_fl
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|file_lock
op_star
op_star
id|before
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_int
id|error
comma
id|change
suffix:semicolon
r_int
id|unlock
op_assign
(paren
id|lock_type
op_eq
id|F_UNLCK
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we need a new lock, get it in advance to avoid races.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|unlock
)paren
(brace
id|error
op_assign
op_minus
id|ENOLCK
suffix:semicolon
id|new_fl
op_assign
id|flock_make_lock
c_func
(paren
id|filp
comma
id|lock_type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_fl
)paren
r_return
id|error
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
id|search
suffix:colon
id|change
op_assign
l_int|0
suffix:semicolon
id|before
op_assign
op_amp
id|inode-&gt;i_flock
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|fl
op_assign
op_star
id|before
)paren
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_FLOCK
)paren
)paren
(brace
r_if
c_cond
(paren
id|filp
op_eq
id|fl-&gt;fl_file
)paren
(brace
r_if
c_cond
(paren
id|lock_type
op_eq
id|fl-&gt;fl_type
)paren
r_goto
id|out
suffix:semicolon
id|change
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
)brace
multiline_comment|/* change means that we are changing the type of an existing lock,&n;&t; * or else unlocking it.&n;&t; */
r_if
c_cond
(paren
id|change
)paren
(brace
multiline_comment|/* N.B. What if the wait argument is false? */
id|locks_delete_lock
c_func
(paren
id|before
comma
op_logical_neg
id|unlock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we waited, another lock may have been added ...&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|unlock
)paren
r_goto
id|search
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unlock
)paren
r_goto
id|out
suffix:semicolon
id|repeat
suffix:colon
r_for
c_loop
(paren
id|fl
op_assign
id|inode-&gt;i_flock
suffix:semicolon
(paren
id|fl
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_FLOCK
)paren
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|flock_locks_conflict
c_func
(paren
id|new_fl
comma
id|fl
)paren
)paren
r_continue
suffix:semicolon
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|locks_block_on
c_func
(paren
id|fl
comma
id|new_fl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|locks_insert_lock
c_func
(paren
op_amp
id|inode-&gt;i_flock
comma
id|new_fl
)paren
suffix:semicolon
id|new_fl
op_assign
l_int|NULL
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|new_fl
)paren
id|locks_free_lock
c_func
(paren
id|new_fl
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;posix_lock_file:&n; *&t;@filp: The file to apply the lock to&n; *&t;@caller: The lock to be applied&n; *&t;@wait: 1 to retry automatically, 0 to return -EAGAIN&n; *&n; * Add a POSIX style lock to a file.&n; * We merge adjacent locks whenever possible. POSIX locks are sorted by owner&n; * task, then by starting address&n; *&n; * Kai Petzke writes:&n; * To make freeing a lock much faster, we keep a pointer to the lock before the&n; * actual one. But the real gain of the new coding was, that lock_it() and&n; * unlock_it() became one function.&n; *&n; * To all purists: Yes, I use a few goto&squot;s. Just pass on to the next function.&n; */
DECL|function|posix_lock_file
r_int
id|posix_lock_file
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|caller
comma
r_int
r_int
id|wait
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_struct
id|file_lock
op_star
id|new_fl
comma
op_star
id|new_fl2
suffix:semicolon
r_struct
id|file_lock
op_star
id|left
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|file_lock
op_star
id|right
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|file_lock
op_star
op_star
id|before
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_int
id|error
comma
id|added
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * We may need two file_lock structures for this operation,&n;&t; * so we get them in advance to avoid races.&n;&t; */
id|new_fl
op_assign
id|locks_alloc_lock
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|new_fl2
op_assign
id|locks_alloc_lock
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOLCK
suffix:semicolon
multiline_comment|/* &quot;no luck&quot; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|new_fl
op_logical_and
id|new_fl2
)paren
)paren
r_goto
id|out
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|caller-&gt;fl_type
op_ne
id|F_UNLCK
)paren
(brace
id|repeat
suffix:colon
r_for
c_loop
(paren
id|fl
op_assign
id|inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_POSIX
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|posix_locks_conflict
c_func
(paren
id|caller
comma
id|fl
)paren
)paren
r_continue
suffix:semicolon
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EDEADLK
suffix:semicolon
r_if
c_cond
(paren
id|posix_locks_deadlock
c_func
(paren
id|caller
comma
id|fl
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|locks_block_on
c_func
(paren
id|fl
comma
id|caller
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * We&squot;ve allocated the new locks in advance, so there are no&n;&t; * errors possible (and no blocking operations) from here on.&n;&t; * &n;&t; * Find the first old lock with the same owner as the new lock.&n;&t; */
id|before
op_assign
op_amp
id|inode-&gt;i_flock
suffix:semicolon
multiline_comment|/* First skip locks owned by other processes.&n;&t; */
r_while
c_loop
(paren
(paren
id|fl
op_assign
op_star
id|before
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_POSIX
)paren
op_logical_or
op_logical_neg
id|locks_same_owner
c_func
(paren
id|caller
comma
id|fl
)paren
)paren
)paren
(brace
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
)brace
multiline_comment|/* Process locks with this owner.&n;&t; */
r_while
c_loop
(paren
(paren
id|fl
op_assign
op_star
id|before
)paren
op_logical_and
id|locks_same_owner
c_func
(paren
id|caller
comma
id|fl
)paren
)paren
(brace
multiline_comment|/* Detect adjacent or overlapping regions (if same lock type)&n;&t;&t; */
r_if
c_cond
(paren
id|caller-&gt;fl_type
op_eq
id|fl-&gt;fl_type
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_end
OL
id|caller-&gt;fl_start
op_minus
l_int|1
)paren
r_goto
id|next_lock
suffix:semicolon
multiline_comment|/* If the next lock in the list has entirely bigger&n;&t;&t;&t; * addresses than the new one, insert the lock here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fl-&gt;fl_start
OG
id|caller-&gt;fl_end
op_plus
l_int|1
)paren
r_break
suffix:semicolon
multiline_comment|/* If we come here, the new and old lock are of the&n;&t;&t;&t; * same type and adjacent or overlapping. Make one&n;&t;&t;&t; * lock yielding from the lower start address of both&n;&t;&t;&t; * locks to the higher end address.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fl-&gt;fl_start
OG
id|caller-&gt;fl_start
)paren
id|fl-&gt;fl_start
op_assign
id|caller-&gt;fl_start
suffix:semicolon
r_else
id|caller-&gt;fl_start
op_assign
id|fl-&gt;fl_start
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_end
OL
id|caller-&gt;fl_end
)paren
id|fl-&gt;fl_end
op_assign
id|caller-&gt;fl_end
suffix:semicolon
r_else
id|caller-&gt;fl_end
op_assign
id|fl-&gt;fl_end
suffix:semicolon
r_if
c_cond
(paren
id|added
)paren
(brace
id|locks_delete_lock
c_func
(paren
id|before
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|caller
op_assign
id|fl
suffix:semicolon
id|added
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Processing for different lock types is a bit&n;&t;&t;&t; * more complex.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fl-&gt;fl_end
OL
id|caller-&gt;fl_start
)paren
r_goto
id|next_lock
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_start
OG
id|caller-&gt;fl_end
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|caller-&gt;fl_type
op_eq
id|F_UNLCK
)paren
id|added
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_start
OL
id|caller-&gt;fl_start
)paren
id|left
op_assign
id|fl
suffix:semicolon
multiline_comment|/* If the next lock in the list has a higher end&n;&t;&t;&t; * address than the new one, insert the new one here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fl-&gt;fl_end
OG
id|caller-&gt;fl_end
)paren
(brace
id|right
op_assign
id|fl
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fl-&gt;fl_start
op_ge
id|caller-&gt;fl_start
)paren
(brace
multiline_comment|/* The new lock completely replaces an old&n;&t;&t;&t;&t; * one (This may happen several times).&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|added
)paren
(brace
id|locks_delete_lock
c_func
(paren
id|before
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Replace the old lock with the new one.&n;&t;&t;&t;&t; * Wake up anybody waiting for the old one,&n;&t;&t;&t;&t; * as the change in lock type might satisfy&n;&t;&t;&t;&t; * their needs.&n;&t;&t;&t;&t; */
id|locks_wake_up_blocks
c_func
(paren
id|fl
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* This cannot schedule()! */
id|fl-&gt;fl_start
op_assign
id|caller-&gt;fl_start
suffix:semicolon
id|fl-&gt;fl_end
op_assign
id|caller-&gt;fl_end
suffix:semicolon
id|fl-&gt;fl_type
op_assign
id|caller-&gt;fl_type
suffix:semicolon
id|fl-&gt;fl_u
op_assign
id|caller-&gt;fl_u
suffix:semicolon
id|caller
op_assign
id|fl
suffix:semicolon
id|added
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Go on to next lock.&n;&t;&t; */
id|next_lock
suffix:colon
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|added
)paren
(brace
r_if
c_cond
(paren
id|caller-&gt;fl_type
op_eq
id|F_UNLCK
)paren
r_goto
id|out
suffix:semicolon
id|locks_copy_lock
c_func
(paren
id|new_fl
comma
id|caller
)paren
suffix:semicolon
id|locks_insert_lock
c_func
(paren
id|before
comma
id|new_fl
)paren
suffix:semicolon
id|new_fl
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|right
)paren
(brace
r_if
c_cond
(paren
id|left
op_eq
id|right
)paren
(brace
multiline_comment|/* The new lock breaks the old one in two pieces,&n;&t;&t;&t; * so we have to use the second new lock.&n;&t;&t;&t; */
id|left
op_assign
id|new_fl2
suffix:semicolon
id|new_fl2
op_assign
l_int|NULL
suffix:semicolon
id|locks_copy_lock
c_func
(paren
id|left
comma
id|right
)paren
suffix:semicolon
id|locks_insert_lock
c_func
(paren
id|before
comma
id|left
)paren
suffix:semicolon
)brace
id|right-&gt;fl_start
op_assign
id|caller-&gt;fl_end
op_plus
l_int|1
suffix:semicolon
id|locks_wake_up_blocks
c_func
(paren
id|right
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|left
)paren
(brace
id|left-&gt;fl_end
op_assign
id|caller-&gt;fl_start
op_minus
l_int|1
suffix:semicolon
id|locks_wake_up_blocks
c_func
(paren
id|left
comma
l_int|0
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Free any unused locks.&n;&t; */
r_if
c_cond
(paren
id|new_fl
)paren
id|locks_free_lock
c_func
(paren
id|new_fl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_fl2
)paren
id|locks_free_lock
c_func
(paren
id|new_fl2
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|flock_translate_cmd
r_static
r_inline
r_int
id|flock_translate_cmd
c_func
(paren
r_int
id|cmd
)paren
(brace
macro_line|#ifdef MSNFS
r_if
c_cond
(paren
id|cmd
op_amp
id|LOCK_MAND
)paren
r_return
id|cmd
op_amp
(paren
id|LOCK_MAND
op_or
id|LOCK_RW
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|cmd
op_amp
op_complement
id|LOCK_NB
)paren
(brace
r_case
id|LOCK_SH
suffix:colon
r_return
id|F_RDLCK
suffix:semicolon
r_case
id|LOCK_EX
suffix:colon
r_return
id|F_WRLCK
suffix:semicolon
r_case
id|LOCK_UN
suffix:colon
r_return
id|F_UNLCK
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;__get_lease&t;-&t;revoke all outstanding leases on file&n; *&t;@inode: the inode of the file to return&n; *&t;@mode: the open mode (read or write)&n; *&n; *&t;get_lease (inlined for speed) has checked there already&n; *&t;is a lease on this file.  Leases are broken on a call to open()&n; *&t;or truncate().  This function can sleep unless you&n; *&t;specified %O_NONBLOCK to your open().&n; */
DECL|function|__get_lease
r_int
id|__get_lease
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|mode
)paren
(brace
r_int
id|error
op_assign
l_int|0
comma
id|future
suffix:semicolon
r_struct
id|file_lock
op_star
id|new_fl
comma
op_star
id|flock
suffix:semicolon
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_int
id|alloc_err
suffix:semicolon
id|alloc_err
op_assign
id|lease_alloc
c_func
(paren
l_int|NULL
comma
l_int|0
comma
op_amp
id|new_fl
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|flock
op_assign
id|inode-&gt;i_flock
suffix:semicolon
r_if
c_cond
(paren
id|flock-&gt;fl_type
op_amp
id|F_INPROGRESS
)paren
(brace
r_if
c_cond
(paren
(paren
id|mode
op_amp
id|O_NONBLOCK
)paren
op_logical_or
(paren
id|flock-&gt;fl_owner
op_eq
id|current-&gt;files
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EWOULDBLOCK
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|alloc_err
op_ne
l_int|0
)paren
(brace
id|error
op_assign
id|alloc_err
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_do
(brace
id|error
op_assign
id|locks_block_on
c_func
(paren
id|flock
comma
id|new_fl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|flock
op_assign
id|inode-&gt;i_flock
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|flock
op_logical_and
(paren
id|flock-&gt;fl_flags
op_amp
id|FL_LEASE
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
r_while
c_loop
(paren
id|flock-&gt;fl_type
op_amp
id|F_INPROGRESS
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode
op_amp
id|FMODE_WRITE
)paren
(brace
multiline_comment|/* If we want write access, we have to revoke any lease. */
id|future
op_assign
id|F_UNLCK
op_or
id|F_INPROGRESS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flock-&gt;fl_type
op_amp
id|F_WRLCK
)paren
(brace
multiline_comment|/* Downgrade the exclusive lease to a read-only lease. */
id|future
op_assign
id|F_RDLCK
op_or
id|F_INPROGRESS
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* the existing lease was read-only, so we can read too. */
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|alloc_err
op_logical_and
(paren
id|flock-&gt;fl_owner
op_ne
id|current-&gt;files
)paren
)paren
(brace
id|error
op_assign
id|alloc_err
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|fl
op_assign
id|flock
suffix:semicolon
r_do
(brace
id|fl-&gt;fl_type
op_assign
id|future
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|fl
op_ne
l_int|NULL
op_logical_and
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_LEASE
)paren
)paren
suffix:semicolon
id|kill_fasync
c_func
(paren
op_amp
id|flock-&gt;fl_fasync
comma
id|SIGIO
comma
id|POLL_MSG
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode
op_amp
id|O_NONBLOCK
)paren
op_logical_or
(paren
id|flock-&gt;fl_owner
op_eq
id|current-&gt;files
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EWOULDBLOCK
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lease_break_time
OG
l_int|0
)paren
id|error
op_assign
id|lease_break_time
op_star
id|HZ
suffix:semicolon
r_else
id|error
op_assign
l_int|0
suffix:semicolon
id|restart
suffix:colon
id|error
op_assign
id|locks_block_on_timeout
c_func
(paren
id|flock
comma
id|new_fl
comma
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We timed out.  Unilaterally break the lease. */
id|locks_delete_lock
c_func
(paren
op_amp
id|inode-&gt;i_flock
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;lease timed out&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|error
OG
l_int|0
)paren
(brace
id|flock
op_assign
id|inode-&gt;i_flock
suffix:semicolon
r_if
c_cond
(paren
id|flock
op_logical_and
(paren
id|flock-&gt;fl_flags
op_amp
id|FL_LEASE
)paren
)paren
r_goto
id|restart
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|alloc_err
)paren
id|locks_free_lock
c_func
(paren
id|new_fl
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;lease_get_mtime&n; *&t;@inode: the inode&n; *&n; * This is to force NFS clients to flush their caches for files with&n; * exclusive leases.  The justification is that if someone has an&n; * exclusive lease, then they could be modifiying it.&n; */
DECL|function|lease_get_mtime
id|time_t
id|lease_get_mtime
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|file_lock
op_star
id|flock
op_assign
id|inode-&gt;i_flock
suffix:semicolon
r_if
c_cond
(paren
id|flock
op_logical_and
(paren
id|flock-&gt;fl_flags
op_amp
id|FL_LEASE
)paren
op_logical_and
(paren
id|flock-&gt;fl_type
op_amp
id|F_WRLCK
)paren
)paren
r_return
id|CURRENT_TIME
suffix:semicolon
r_return
id|inode-&gt;i_mtime
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;fcntl_getlease - Enquire what lease is currently active&n; *&t;@filp: the file&n; *&n; *&t;The value returned by this function will be one of&n; *&n; *&t;%F_RDLCK to indicate a read-only (type II) lease is held.&n; *&n; *&t;%F_WRLCK to indicate an exclusive lease is held.&n; *&n; *&t;XXX: sfr &amp; i disagree over whether F_INPROGRESS&n; *&t;should be returned to userspace.&n; */
DECL|function|fcntl_getlease
r_int
id|fcntl_getlease
c_func
(paren
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
id|fl
op_assign
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_flock
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fl
op_eq
l_int|NULL
)paren
op_logical_or
(paren
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_LEASE
)paren
op_eq
l_int|0
)paren
)paren
r_return
id|F_UNLCK
suffix:semicolon
r_return
id|fl-&gt;fl_type
op_amp
op_complement
id|F_INPROGRESS
suffix:semicolon
)brace
multiline_comment|/* We already had a lease on this file; just change its type */
DECL|function|lease_modify
r_static
r_int
id|lease_modify
c_func
(paren
r_struct
id|file_lock
op_star
op_star
id|before
comma
r_int
id|arg
comma
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
op_assign
op_star
id|before
suffix:semicolon
r_int
id|error
op_assign
id|assign_type
c_func
(paren
id|fl
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|locks_wake_up_blocks
c_func
(paren
id|fl
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_eq
id|F_UNLCK
)paren
(brace
id|filp-&gt;f_owner.pid
op_assign
l_int|0
suffix:semicolon
id|filp-&gt;f_owner.uid
op_assign
l_int|0
suffix:semicolon
id|filp-&gt;f_owner.euid
op_assign
l_int|0
suffix:semicolon
id|filp-&gt;f_owner.signum
op_assign
l_int|0
suffix:semicolon
id|locks_delete_lock
c_func
(paren
id|before
comma
l_int|0
)paren
suffix:semicolon
id|fasync_helper
c_func
(paren
id|fd
comma
id|filp
comma
l_int|0
comma
op_amp
id|fl-&gt;fl_fasync
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;fcntl_setlease&t;-&t;sets a lease on an open file&n; *&t;@fd: open file descriptor&n; *&t;@filp: file pointer&n; *&t;@arg: type of lease to obtain&n; *&n; *&t;Call this fcntl to establish a lease on the file.&n; *&t;Note that you also need to call %F_SETSIG to&n; *&t;receive a signal when the lease is broken.&n; */
DECL|function|fcntl_setlease
r_int
id|fcntl_setlease
c_func
(paren
r_int
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|arg
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
comma
op_star
op_star
id|before
comma
op_star
op_star
id|my_before
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|error
comma
id|rdlease_count
op_assign
l_int|0
comma
id|wrlease_count
op_assign
l_int|0
suffix:semicolon
id|dentry
op_assign
id|filp-&gt;f_dentry
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current-&gt;fsuid
op_ne
id|inode-&gt;i_uid
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_LEASE
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: What about F_RDLCK and files open for writing?&n;&t; */
r_if
c_cond
(paren
(paren
id|arg
op_eq
id|F_WRLCK
)paren
op_logical_and
(paren
(paren
id|atomic_read
c_func
(paren
op_amp
id|dentry-&gt;d_count
)paren
OG
l_int|1
)paren
op_logical_or
(paren
id|atomic_read
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
OG
l_int|1
)paren
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|before
op_assign
op_amp
id|inode-&gt;i_flock
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|fl
op_assign
op_star
id|before
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_flags
op_ne
id|FL_LEASE
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_file
op_eq
id|filp
)paren
id|my_before
op_assign
id|before
suffix:semicolon
r_else
r_if
c_cond
(paren
id|fl-&gt;fl_type
op_amp
id|F_WRLCK
)paren
id|wrlease_count
op_increment
suffix:semicolon
r_else
id|rdlease_count
op_increment
suffix:semicolon
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|arg
op_eq
id|F_RDLCK
op_logical_and
(paren
id|wrlease_count
OG
l_int|0
)paren
)paren
op_logical_or
(paren
id|arg
op_eq
id|F_WRLCK
op_logical_and
(paren
(paren
id|rdlease_count
op_plus
id|wrlease_count
)paren
OG
l_int|0
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|my_before
op_ne
l_int|NULL
)paren
(brace
id|error
op_assign
id|lease_modify
c_func
(paren
id|my_before
comma
id|arg
comma
id|fd
comma
id|filp
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
op_eq
id|F_UNLCK
)paren
(brace
id|error
op_assign
l_int|0
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|leases_enable
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|error
op_assign
id|lease_alloc
c_func
(paren
id|filp
comma
id|arg
comma
op_amp
id|fl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out_unlock
suffix:semicolon
id|error
op_assign
id|fasync_helper
c_func
(paren
id|fd
comma
id|filp
comma
l_int|1
comma
op_amp
id|fl-&gt;fl_fasync
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
id|locks_free_lock
c_func
(paren
id|fl
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|fl-&gt;fl_next
op_assign
op_star
id|before
suffix:semicolon
op_star
id|before
op_assign
id|fl
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|fl-&gt;fl_link
comma
op_amp
id|file_lock_list
)paren
suffix:semicolon
id|filp-&gt;f_owner.pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|filp-&gt;f_owner.uid
op_assign
id|current-&gt;uid
suffix:semicolon
id|filp-&gt;f_owner.euid
op_assign
id|current-&gt;euid
suffix:semicolon
id|out_unlock
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;sys_flock: - flock() system call.&n; *&t;@fd: the file descriptor to lock.&n; *&t;@cmd: the type of lock to apply.&n; *&n; *&t;Apply a %FL_FLOCK style lock to an open file descriptor.&n; *&t;The @cmd can be one of&n; *&n; *&t;%LOCK_SH -- a shared lock.&n; *&n; *&t;%LOCK_EX -- an exclusive lock.&n; *&n; *&t;%LOCK_UN -- remove an existing lock.&n; *&n; *&t;%LOCK_MAND -- a `mandatory&squot; flock.  This exists to emulate Windows Share Modes.&n; *&n; *&t;%LOCK_MAND can be combined with %LOCK_READ or %LOCK_WRITE to allow other&n; *&t;processes read and write access respectively.&n; */
DECL|function|sys_flock
id|asmlinkage
r_int
id|sys_flock
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
)paren
(brace
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_int
id|error
comma
id|type
suffix:semicolon
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|filp
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|flock_translate_cmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_goto
id|out_putf
suffix:semicolon
id|type
op_assign
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
r_if
c_cond
(paren
(paren
id|type
op_ne
id|F_UNLCK
)paren
macro_line|#ifdef MSNFS
op_logical_and
op_logical_neg
(paren
id|type
op_amp
id|LOCK_MAND
)paren
macro_line|#endif
op_logical_and
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
l_int|3
)paren
)paren
r_goto
id|out_putf
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|flock_lock_file
c_func
(paren
id|filp
comma
id|type
comma
(paren
id|cmd
op_amp
(paren
id|LOCK_UN
op_or
id|LOCK_NB
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|out_putf
suffix:colon
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Report the first existing lock that would conflict with l.&n; * This implements the F_GETLK command of fcntl().&n; */
DECL|function|fcntl_getlk
r_int
id|fcntl_getlk
c_func
(paren
r_int
r_int
id|fd
comma
r_struct
id|flock
op_star
id|l
)paren
(brace
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|file_lock
op_star
id|fl
comma
id|file_lock
suffix:semicolon
r_struct
id|flock
id|flock
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|flock
comma
id|l
comma
r_sizeof
(paren
id|flock
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flock.l_type
op_ne
id|F_RDLCK
)paren
op_logical_and
(paren
id|flock.l_type
op_ne
id|F_WRLCK
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|filp
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flock_to_posix_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
comma
op_amp
id|flock
)paren
)paren
r_goto
id|out_putf
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_op
op_logical_and
id|filp-&gt;f_op-&gt;lock
)paren
(brace
id|error
op_assign
id|filp-&gt;f_op
op_member_access_from_pointer
id|lock
c_func
(paren
id|filp
comma
id|F_GETLK
comma
op_amp
id|file_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_goto
id|out_putf
suffix:semicolon
r_else
r_if
c_cond
(paren
id|error
op_eq
id|LOCK_USE_CLNT
)paren
multiline_comment|/* Bypass for NFS with no locking - 2.0.36 compat */
id|fl
op_assign
id|posix_test_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
)paren
suffix:semicolon
r_else
id|fl
op_assign
(paren
id|file_lock.fl_type
op_eq
id|F_UNLCK
ques
c_cond
l_int|NULL
suffix:colon
op_amp
id|file_lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|fl
op_assign
id|posix_test_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
)paren
suffix:semicolon
)brace
id|flock.l_type
op_assign
id|F_UNLCK
suffix:semicolon
r_if
c_cond
(paren
id|fl
op_ne
l_int|NULL
)paren
(brace
id|flock.l_pid
op_assign
id|fl-&gt;fl_pid
suffix:semicolon
macro_line|#if BITS_PER_LONG == 32
multiline_comment|/*&n;&t;&t; * Make sure we can represent the posix lock via&n;&t;&t; * legacy 32bit flock.&n;&t;&t; */
id|error
op_assign
op_minus
id|EOVERFLOW
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_start
OG
id|OFFT_OFFSET_MAX
)paren
r_goto
id|out_putf
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fl-&gt;fl_end
op_ne
id|OFFSET_MAX
)paren
op_logical_and
(paren
id|fl-&gt;fl_end
OG
id|OFFT_OFFSET_MAX
)paren
)paren
r_goto
id|out_putf
suffix:semicolon
macro_line|#endif
id|flock.l_start
op_assign
id|fl-&gt;fl_start
suffix:semicolon
id|flock.l_len
op_assign
id|fl-&gt;fl_end
op_eq
id|OFFSET_MAX
ques
c_cond
l_int|0
suffix:colon
id|fl-&gt;fl_end
op_minus
id|fl-&gt;fl_start
op_plus
l_int|1
suffix:semicolon
id|flock.l_whence
op_assign
l_int|0
suffix:semicolon
id|flock.l_type
op_assign
id|fl-&gt;fl_type
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_to_user
c_func
(paren
id|l
comma
op_amp
id|flock
comma
r_sizeof
(paren
id|flock
)paren
)paren
)paren
id|error
op_assign
l_int|0
suffix:semicolon
id|out_putf
suffix:colon
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Apply the lock described by l to an open file descriptor.&n; * This implements both the F_SETLK and F_SETLKW commands of fcntl().&n; */
DECL|function|fcntl_setlk
r_int
id|fcntl_setlk
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
comma
r_struct
id|flock
op_star
id|l
)paren
(brace
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|file_lock
op_star
id|file_lock
op_assign
id|locks_alloc_lock
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_struct
id|flock
id|flock
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * This might block, so we do it before checking the inode.&n;&t; */
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|flock
comma
id|l
comma
r_sizeof
(paren
id|flock
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Get arguments and validate them ...&n;&t; */
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|filp
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
multiline_comment|/* Don&squot;t allow mandatory locks on files that may be memory mapped&n;&t; * and shared.&n;&t; */
r_if
c_cond
(paren
id|IS_MANDLOCK
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_ISGID
op_or
id|S_IXGRP
)paren
)paren
op_eq
id|S_ISGID
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
r_if
c_cond
(paren
id|mapping-&gt;i_mmap_shared
op_ne
l_int|NULL
)paren
(brace
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out_putf
suffix:semicolon
)brace
)brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flock_to_posix_lock
c_func
(paren
id|filp
comma
id|file_lock
comma
op_amp
id|flock
)paren
)paren
r_goto
id|out_putf
suffix:semicolon
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
r_switch
c_cond
(paren
id|flock.l_type
)paren
(brace
r_case
id|F_RDLCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_goto
id|out_putf
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_WRLCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_goto
id|out_putf
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_UNLCK
suffix:colon
r_break
suffix:semicolon
r_case
id|F_SHLCK
suffix:colon
r_case
id|F_EXLCK
suffix:colon
macro_line|#ifdef __sparc__
multiline_comment|/* warn a bit for now, but don&squot;t overdo it */
(brace
r_static
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
(brace
id|count
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;fcntl_setlk() called by process %d (%s) with broken flock() emulation&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|current-&gt;comm
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
l_int|3
)paren
)paren
r_goto
id|out_putf
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_putf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|filp-&gt;f_op
op_logical_and
id|filp-&gt;f_op-&gt;lock
op_ne
l_int|NULL
)paren
(brace
id|error
op_assign
id|filp-&gt;f_op
op_member_access_from_pointer
id|lock
c_func
(paren
id|filp
comma
id|cmd
comma
id|file_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_goto
id|out_putf
suffix:semicolon
)brace
id|error
op_assign
id|posix_lock_file
c_func
(paren
id|filp
comma
id|file_lock
comma
id|cmd
op_eq
id|F_SETLKW
)paren
suffix:semicolon
id|out_putf
suffix:colon
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
id|out
suffix:colon
id|locks_free_lock
c_func
(paren
id|file_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
macro_line|#if BITS_PER_LONG == 32
multiline_comment|/* Report the first existing lock that would conflict with l.&n; * This implements the F_GETLK command of fcntl().&n; */
DECL|function|fcntl_getlk64
r_int
id|fcntl_getlk64
c_func
(paren
r_int
r_int
id|fd
comma
r_struct
id|flock64
op_star
id|l
)paren
(brace
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|file_lock
op_star
id|fl
comma
id|file_lock
suffix:semicolon
r_struct
id|flock64
id|flock
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|flock
comma
id|l
comma
r_sizeof
(paren
id|flock
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flock.l_type
op_ne
id|F_RDLCK
)paren
op_logical_and
(paren
id|flock.l_type
op_ne
id|F_WRLCK
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|filp
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flock64_to_posix_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
comma
op_amp
id|flock
)paren
)paren
r_goto
id|out_putf
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_op
op_logical_and
id|filp-&gt;f_op-&gt;lock
)paren
(brace
id|error
op_assign
id|filp-&gt;f_op
op_member_access_from_pointer
id|lock
c_func
(paren
id|filp
comma
id|F_GETLK
comma
op_amp
id|file_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_goto
id|out_putf
suffix:semicolon
r_else
r_if
c_cond
(paren
id|error
op_eq
id|LOCK_USE_CLNT
)paren
multiline_comment|/* Bypass for NFS with no locking - 2.0.36 compat */
id|fl
op_assign
id|posix_test_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
)paren
suffix:semicolon
r_else
id|fl
op_assign
(paren
id|file_lock.fl_type
op_eq
id|F_UNLCK
ques
c_cond
l_int|NULL
suffix:colon
op_amp
id|file_lock
)paren
suffix:semicolon
)brace
r_else
(brace
id|fl
op_assign
id|posix_test_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
)paren
suffix:semicolon
)brace
id|flock.l_type
op_assign
id|F_UNLCK
suffix:semicolon
r_if
c_cond
(paren
id|fl
op_ne
l_int|NULL
)paren
(brace
id|flock.l_pid
op_assign
id|fl-&gt;fl_pid
suffix:semicolon
id|flock.l_start
op_assign
id|fl-&gt;fl_start
suffix:semicolon
id|flock.l_len
op_assign
id|fl-&gt;fl_end
op_eq
id|OFFSET_MAX
ques
c_cond
l_int|0
suffix:colon
id|fl-&gt;fl_end
op_minus
id|fl-&gt;fl_start
op_plus
l_int|1
suffix:semicolon
id|flock.l_whence
op_assign
l_int|0
suffix:semicolon
id|flock.l_type
op_assign
id|fl-&gt;fl_type
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_to_user
c_func
(paren
id|l
comma
op_amp
id|flock
comma
r_sizeof
(paren
id|flock
)paren
)paren
)paren
id|error
op_assign
l_int|0
suffix:semicolon
id|out_putf
suffix:colon
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Apply the lock described by l to an open file descriptor.&n; * This implements both the F_SETLK and F_SETLKW commands of fcntl().&n; */
DECL|function|fcntl_setlk64
r_int
id|fcntl_setlk64
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
comma
r_struct
id|flock64
op_star
id|l
)paren
(brace
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|file_lock
op_star
id|file_lock
op_assign
id|locks_alloc_lock
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_struct
id|flock64
id|flock
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * This might block, so we do it before checking the inode.&n;&t; */
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|flock
comma
id|l
comma
r_sizeof
(paren
id|flock
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Get arguments and validate them ...&n;&t; */
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
id|filp
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
multiline_comment|/* Don&squot;t allow mandatory locks on files that may be memory mapped&n;&t; * and shared.&n;&t; */
r_if
c_cond
(paren
id|IS_MANDLOCK
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_ISGID
op_or
id|S_IXGRP
)paren
)paren
op_eq
id|S_ISGID
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
r_if
c_cond
(paren
id|mapping-&gt;i_mmap_shared
op_ne
l_int|NULL
)paren
(brace
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out_putf
suffix:semicolon
)brace
)brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flock64_to_posix_lock
c_func
(paren
id|filp
comma
id|file_lock
comma
op_amp
id|flock
)paren
)paren
r_goto
id|out_putf
suffix:semicolon
id|error
op_assign
op_minus
id|EBADF
suffix:semicolon
r_switch
c_cond
(paren
id|flock.l_type
)paren
(brace
r_case
id|F_RDLCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_goto
id|out_putf
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_WRLCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_goto
id|out_putf
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_UNLCK
suffix:colon
r_break
suffix:semicolon
r_case
id|F_SHLCK
suffix:colon
r_case
id|F_EXLCK
suffix:colon
r_default
suffix:colon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out_putf
suffix:semicolon
)brace
r_if
c_cond
(paren
id|filp-&gt;f_op
op_logical_and
id|filp-&gt;f_op-&gt;lock
op_ne
l_int|NULL
)paren
(brace
id|error
op_assign
id|filp-&gt;f_op
op_member_access_from_pointer
id|lock
c_func
(paren
id|filp
comma
id|cmd
comma
id|file_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_goto
id|out_putf
suffix:semicolon
)brace
id|error
op_assign
id|posix_lock_file
c_func
(paren
id|filp
comma
id|file_lock
comma
id|cmd
op_eq
id|F_SETLKW64
)paren
suffix:semicolon
id|out_putf
suffix:colon
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
id|out
suffix:colon
id|locks_free_lock
c_func
(paren
id|file_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
macro_line|#endif /* BITS_PER_LONG == 32 */
multiline_comment|/*&n; * This function is called when the file is being removed&n; * from the task&squot;s fd array.&n; */
DECL|function|locks_remove_posix
r_void
id|locks_remove_posix
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
id|fl_owner_t
id|owner
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_struct
id|file_lock
op_star
op_star
id|before
suffix:semicolon
multiline_comment|/*&n;&t; * For POSIX locks we free all locks on this file for the given task.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_flock
)paren
(brace
multiline_comment|/*&n;&t;&t; * Notice that something might be grabbing a lock right now.&n;&t;&t; * Consider it as a race won by us - event is async, so even if&n;&t;&t; * we miss the lock added we can trivially consider it as added&n;&t;&t; * after we went through this call.&n;&t;&t; */
r_return
suffix:semicolon
)brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|before
op_assign
op_amp
id|inode-&gt;i_flock
suffix:semicolon
r_while
c_loop
(paren
(paren
id|fl
op_assign
op_star
id|before
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_POSIX
)paren
op_logical_and
id|fl-&gt;fl_owner
op_eq
id|owner
)paren
(brace
id|locks_unlock_delete
c_func
(paren
id|before
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is called on the last close of an open file.&n; */
DECL|function|locks_remove_flock
r_void
id|locks_remove_flock
c_func
(paren
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_struct
id|file_lock
op_star
op_star
id|before
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_flock
)paren
r_return
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|before
op_assign
op_amp
id|inode-&gt;i_flock
suffix:semicolon
r_while
c_loop
(paren
(paren
id|fl
op_assign
op_star
id|before
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|fl-&gt;fl_flags
op_amp
(paren
id|FL_FLOCK
op_or
id|FL_LEASE
)paren
)paren
op_logical_and
(paren
id|fl-&gt;fl_file
op_eq
id|filp
)paren
)paren
(brace
id|locks_delete_lock
c_func
(paren
id|before
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;posix_block_lock - blocks waiting for a file lock&n; *&t;@blocker: the lock which is blocking&n; *&t;@waiter: the lock which conflicts and has to wait&n; *&n; * lockd needs to block waiting for locks.&n; */
r_void
DECL|function|posix_block_lock
id|posix_block_lock
c_func
(paren
r_struct
id|file_lock
op_star
id|blocker
comma
r_struct
id|file_lock
op_star
id|waiter
)paren
(brace
id|locks_insert_block
c_func
(paren
id|blocker
comma
id|waiter
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;posix_unblock_lock - stop waiting for a file lock&n; *&t;@waiter: the lock which was waiting&n; *&n; *&t;lockd needs to block waiting for locks.&n; */
r_void
DECL|function|posix_unblock_lock
id|posix_unblock_lock
c_func
(paren
r_struct
id|file_lock
op_star
id|waiter
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|waiter-&gt;fl_block
)paren
)paren
id|locks_delete_block
c_func
(paren
id|waiter
)paren
suffix:semicolon
)brace
DECL|function|lock_get_status
r_static
r_void
id|lock_get_status
c_func
(paren
r_char
op_star
id|out
comma
r_struct
id|file_lock
op_star
id|fl
comma
r_int
id|id
comma
r_char
op_star
id|pfx
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_file
op_ne
l_int|NULL
)paren
id|inode
op_assign
id|fl-&gt;fl_file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%d:%s &quot;
comma
id|id
comma
id|pfx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_POSIX
)paren
(brace
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%6s %s &quot;
comma
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_ACCESS
)paren
ques
c_cond
l_string|&quot;ACCESS&quot;
suffix:colon
l_string|&quot;POSIX &quot;
comma
(paren
id|inode
op_eq
l_int|NULL
)paren
ques
c_cond
l_string|&quot;*NOINODE*&quot;
suffix:colon
(paren
id|IS_MANDLOCK
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_IXGRP
op_or
id|S_ISGID
)paren
)paren
op_eq
id|S_ISGID
)paren
ques
c_cond
l_string|&quot;MANDATORY&quot;
suffix:colon
l_string|&quot;ADVISORY &quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_FLOCK
)paren
(brace
macro_line|#ifdef MSNFS
r_if
c_cond
(paren
id|fl-&gt;fl_type
op_amp
id|LOCK_MAND
)paren
(brace
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;FLOCK  MSNFS     &quot;
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;FLOCK  ADVISORY  &quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|fl-&gt;fl_flags
op_amp
id|FL_LEASE
)paren
(brace
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;LEASE  MANDATORY &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;UNKNOWN UNKNOWN  &quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef MSNFS
r_if
c_cond
(paren
id|fl-&gt;fl_type
op_amp
id|LOCK_MAND
)paren
(brace
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%s &quot;
comma
(paren
id|fl-&gt;fl_type
op_amp
id|LOCK_READ
)paren
ques
c_cond
(paren
id|fl-&gt;fl_type
op_amp
id|LOCK_WRITE
)paren
ques
c_cond
l_string|&quot;RW   &quot;
suffix:colon
l_string|&quot;READ &quot;
suffix:colon
(paren
id|fl-&gt;fl_type
op_amp
id|LOCK_WRITE
)paren
ques
c_cond
l_string|&quot;WRITE&quot;
suffix:colon
l_string|&quot;NONE &quot;
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%s &quot;
comma
(paren
id|fl-&gt;fl_type
op_amp
id|F_WRLCK
)paren
ques
c_cond
l_string|&quot;WRITE&quot;
suffix:colon
l_string|&quot;READ &quot;
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%d %s:%ld &quot;
comma
id|fl-&gt;fl_pid
comma
id|inode
ques
c_cond
id|kdevname
c_func
(paren
id|inode-&gt;i_dev
)paren
suffix:colon
l_string|&quot;&lt;none&gt;&quot;
comma
id|inode
ques
c_cond
id|inode-&gt;i_ino
suffix:colon
l_int|0
)paren
suffix:semicolon
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%Ld &quot;
comma
id|fl-&gt;fl_start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_end
op_eq
id|OFFSET_MAX
)paren
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;EOF &quot;
)paren
suffix:semicolon
r_else
id|out
op_add_assign
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%Ld &quot;
comma
id|fl-&gt;fl_end
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|out
comma
l_string|&quot;%08lx %08lx %08lx %08lx %08lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|fl
comma
(paren
r_int
)paren
id|fl-&gt;fl_link.prev
comma
(paren
r_int
)paren
id|fl-&gt;fl_link.next
comma
(paren
r_int
)paren
id|fl-&gt;fl_next
comma
(paren
r_int
)paren
id|fl-&gt;fl_block.next
)paren
suffix:semicolon
)brace
DECL|function|move_lock_status
r_static
r_void
id|move_lock_status
c_func
(paren
r_char
op_star
op_star
id|p
comma
id|off_t
op_star
id|pos
comma
id|off_t
id|offset
)paren
(brace
r_int
id|len
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
op_star
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pos
op_ge
id|offset
)paren
(brace
multiline_comment|/* the complete line is valid */
op_star
id|p
op_add_assign
id|len
suffix:semicolon
op_star
id|pos
op_add_assign
id|len
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pos
op_plus
id|len
OG
id|offset
)paren
(brace
multiline_comment|/* use the second part of the line */
r_int
id|i
op_assign
id|offset
op_minus
op_star
id|pos
suffix:semicolon
id|memmove
c_func
(paren
op_star
id|p
comma
op_star
id|p
op_plus
id|i
comma
id|len
op_minus
id|i
)paren
suffix:semicolon
op_star
id|p
op_add_assign
id|len
op_minus
id|i
suffix:semicolon
op_star
id|pos
op_add_assign
id|len
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* discard the complete line */
op_star
id|pos
op_add_assign
id|len
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;get_locks_status&t;-&t;reports lock usage in /proc/locks&n; *&t;@buffer: address in userspace to write into&n; *&t;@start: ?&n; *&t;@offset: how far we are through the buffer&n; *&t;@length: how much to read&n; */
DECL|function|get_locks_status
r_int
id|get_locks_status
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_char
op_star
id|q
op_assign
id|buffer
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|file_lock_list
)paren
(brace
r_struct
id|list_head
op_star
id|btmp
suffix:semicolon
r_struct
id|file_lock
op_star
id|fl
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|file_lock
comma
id|fl_link
)paren
suffix:semicolon
id|lock_get_status
c_func
(paren
id|q
comma
id|fl
comma
op_increment
id|i
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
id|move_lock_status
c_func
(paren
op_amp
id|q
comma
op_amp
id|pos
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|offset
op_plus
id|length
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
id|list_for_each
c_func
(paren
id|btmp
comma
op_amp
id|fl-&gt;fl_block
)paren
(brace
r_struct
id|file_lock
op_star
id|bfl
op_assign
id|list_entry
c_func
(paren
id|btmp
comma
r_struct
id|file_lock
comma
id|fl_block
)paren
suffix:semicolon
id|lock_get_status
c_func
(paren
id|q
comma
id|bfl
comma
id|i
comma
l_string|&quot; -&gt;&quot;
)paren
suffix:semicolon
id|move_lock_status
c_func
(paren
op_amp
id|q
comma
op_amp
id|pos
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|offset
op_plus
id|length
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
)brace
)brace
id|done
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|q
op_minus
id|buffer
OL
id|length
)paren
(brace
r_return
(paren
id|q
op_minus
id|buffer
)paren
suffix:semicolon
)brace
r_return
id|length
suffix:semicolon
)brace
macro_line|#ifdef MSNFS
multiline_comment|/**&n; *&t;lock_may_read - checks that the region is free of locks&n; *&t;@inode: the inode that is being read&n; *&t;@start: the first byte to read&n; *&t;@len: the number of bytes to read&n; *&n; *&t;Emulates Windows locking requirements.  Whole-file&n; *&t;mandatory locks (share modes) can prohibit a read and&n; *&t;byte-range POSIX locks can prohibit a read if they overlap.&n; *&n; *&t;N.B. this function is only ever called&n; *&t;from knfsd and ownership of locks is never checked.&n; */
DECL|function|lock_may_read
r_int
id|lock_may_read
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
id|start
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_int
id|result
op_assign
l_int|1
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|fl
op_assign
id|inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_flags
op_eq
id|FL_POSIX
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_type
op_eq
id|F_RDLCK
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fl-&gt;fl_end
OL
id|start
)paren
op_logical_or
(paren
id|fl-&gt;fl_start
OG
(paren
id|start
op_plus
id|len
)paren
)paren
)paren
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|fl-&gt;fl_flags
op_eq
id|FL_FLOCK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|fl-&gt;fl_type
op_amp
id|LOCK_MAND
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_type
op_amp
id|LOCK_READ
)paren
r_continue
suffix:semicolon
)brace
r_else
r_continue
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;lock_may_write - checks that the region is free of locks&n; *&t;@inode: the inode that is being written&n; *&t;@start: the first byte to write&n; *&t;@len: the number of bytes to write&n; *&n; *&t;Emulates Windows locking requirements.  Whole-file&n; *&t;mandatory locks (share modes) can prohibit a write and&n; *&t;byte-range POSIX locks can prohibit a write if they overlap.&n; *&n; *&t;N.B. this function is only ever called&n; *&t;from knfsd and ownership of locks is never checked.&n; */
DECL|function|lock_may_write
r_int
id|lock_may_write
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
id|start
comma
r_int
r_int
id|len
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_int
id|result
op_assign
l_int|1
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|fl
op_assign
id|inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_flags
op_eq
id|FL_POSIX
)paren
(brace
r_if
c_cond
(paren
(paren
id|fl-&gt;fl_end
OL
id|start
)paren
op_logical_or
(paren
id|fl-&gt;fl_start
OG
(paren
id|start
op_plus
id|len
)paren
)paren
)paren
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|fl-&gt;fl_flags
op_eq
id|FL_FLOCK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|fl-&gt;fl_type
op_amp
id|LOCK_MAND
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_type
op_amp
id|LOCK_WRITE
)paren
r_continue
suffix:semicolon
)brace
r_else
r_continue
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
macro_line|#endif
DECL|function|filelock_init
r_static
r_int
id|__init
id|filelock_init
c_func
(paren
r_void
)paren
(brace
id|filelock_cache
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;file lock cache&quot;
comma
r_sizeof
(paren
r_struct
id|file_lock
)paren
comma
l_int|0
comma
l_int|0
comma
id|init_once
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filelock_cache
)paren
id|panic
c_func
(paren
l_string|&quot;cannot create file lock slab cache&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|module_init
c_func
(paren
id|filelock_init
)paren
eof
