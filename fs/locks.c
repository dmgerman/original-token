multiline_comment|/*&n; *  linux/fs/locks.c&n; *&n; *  Provide support for fcntl()&squot;s F_GETLK, F_SETLK, and F_SETLKW calls.&n; *  Doug Evans (dje@spiff.uucp), August 07, 1992&n; *&n; *  Deadlock detection added.&n; *  FIXME: one thing isn&squot;t handled yet:&n; *&t;- mandatory locks (requires lots of changes elsewhere)&n; *  Kelly Carmichael (kelly@[142.24.8.65]), September 17, 1994.&n; *&n; *  Miscellaneous edits, and a total rewrite of posix_lock_file() code.&n; *  Kai Petzke (wpp@marie.physik.tu-berlin.de), 1994&n; *  &n; *  Converted file_lock_table to a linked list from an array, which eliminates&n; *  the limits on how many active file locks are open.&n; *  Chad Page (pageone@netcom.com), November 27, 1994&n; * &n; *  Removed dependency on file descriptors. dup()&squot;ed file descriptors now&n; *  get the same locks as the original file descriptors, and a close() on&n; *  any file descriptor removes ALL the locks on the file for the current&n; *  process. Since locks still depend on the process id, locks are inherited&n; *  after an exec() but not after a fork(). This agrees with POSIX, and both&n; *  BSD and SVR4 practice.&n; *  Andy Walker (andy@lysaker.kvaerner.no), February 14, 1995&n; *&n; *  Scrapped free list which is redundant now that we allocate locks&n; *  dynamically with kmalloc()/kfree().&n; *  Andy Walker (andy@lysaker.kvaerner.no), February 21, 1995&n; *&n; *  Implemented two lock personalities - F_FLOCK and F_POSIX.&n; *&n; *  F_POSIX locks are created with calls to fcntl() and lockf() through the&n; *  fcntl() system call. They have the semantics described above.&n; *&n; *  F_FLOCK locks are created with calls to flock(), through the flock()&n; *  system call, which is new. Old C libraries implement flock() via fcntl()&n; *  and will continue to use the old, broken implementation.&n; *&n; *  F_FLOCK locks follow the 4.4 BSD flock() semantics. They are associated&n; *  with a file pointer (filp). As a result they can be shared by a parent&n; *  process and its children after a fork(). They are removed when the last&n; *  file descriptor referring to the file pointer is closed (unless explicitly&n; *  unlocked). &n; *&n; *  F_FLOCK locks never deadlock, an existing lock is always removed before&n; *  upgrading from shared to exclusive (or vice versa). When this happens&n; *  any processes blocked by the current lock are woken up and allowed to&n; *  run before the new lock is applied.&n; *  Andy Walker (andy@lysaker.kvaerner.no), June 09, 1995&n; *&n; *  Removed some race conditions in flock_lock_file(), marked other possible&n; *  races. Just grep for FIXME to see them. &n; *  Dmitry Gorodchanin (begemot@bgm.rosprint.net), February 09, 1996.&n; *&n; *  Addressed Dmitry&squot;s concerns. Deadlock checking no longer recursive.&n; *  Lock allocation changed to GFP_ATOMIC as we can&squot;t afford to sleep&n; *  once we&squot;ve checked for blocking and deadlocking.&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 03, 1996.&n; *&n; *  Initial implementation of mandatory locks. SunOS turned out to be&n; *  a rotten model, so I implemented the &quot;obvious&quot; semantics.&n; *  See &squot;linux/Documentation/mandatory.txt&squot; for details.&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 06, 1996.&n; *&n; *  Don&squot;t allow mandatory locks on mmap()&squot;ed files. Added simple functions to&n; *  check if a file has mandatory locks, used by mmap(), open() and creat() to&n; *  see if system call should be rejected. Ref. HP-UX/SunOS/Solaris Reference&n; *  Manual, Section 2.&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 09, 1996.&n; *&n; *  Tidied up block list handling. Added &squot;/proc/locks&squot; interface.&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 24, 1996.&n; *&n; *  Fixed deadlock condition for pathological code that mixes calls to&n; *  flock() and fcntl().&n; *  Andy Walker (andy@lysaker.kvaerner.no), April 29, 1996.&n; */
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
DECL|macro|OFFSET_MAX
mdefine_line|#define OFFSET_MAX&t;((off_t)0x7fffffff)&t;/* FIXME: move elsewhere? */
r_static
r_int
id|flock_make_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
comma
r_int
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_int
id|posix_make_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
comma
r_struct
id|flock
op_star
id|l
)paren
suffix:semicolon
r_static
r_int
id|flock_locks_conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
suffix:semicolon
r_static
r_int
id|posix_locks_conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
suffix:semicolon
r_static
r_int
id|locks_conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
suffix:semicolon
r_static
r_int
id|flock_lock_file
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|caller
comma
r_int
r_int
id|wait
)paren
suffix:semicolon
r_static
r_int
id|posix_lock_file
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|caller
comma
r_int
r_int
id|wait
)paren
suffix:semicolon
r_static
r_int
id|locks_deadlock
c_func
(paren
r_struct
id|task_struct
op_star
id|my_task
comma
r_struct
id|task_struct
op_star
id|blocked_task
)paren
suffix:semicolon
r_static
r_int
id|locks_overlap
c_func
(paren
r_struct
id|file_lock
op_star
id|fl1
comma
r_struct
id|file_lock
op_star
id|fl2
)paren
suffix:semicolon
r_static
r_struct
id|file_lock
op_star
id|locks_alloc_lock
c_func
(paren
r_struct
id|file_lock
op_star
id|fl
)paren
suffix:semicolon
r_static
r_void
id|locks_insert_lock
c_func
(paren
r_struct
id|file_lock
op_star
op_star
id|pos
comma
r_struct
id|file_lock
op_star
id|fl
)paren
suffix:semicolon
r_static
r_void
id|locks_delete_lock
c_func
(paren
r_struct
id|file_lock
op_star
op_star
id|fl
comma
r_int
r_int
id|wait
)paren
suffix:semicolon
r_static
r_char
op_star
id|lock_get_status
c_func
(paren
r_struct
id|file_lock
op_star
id|fl
comma
r_char
op_star
id|p
comma
r_int
id|id
comma
r_char
op_star
id|pfx
)paren
suffix:semicolon
DECL|variable|file_lock_table
r_static
r_struct
id|file_lock
op_star
id|file_lock_table
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Free lock not inserted in any queue */
DECL|function|locks_free_lock
r_static
r_inline
r_void
id|locks_free_lock
c_func
(paren
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
id|kfree
c_func
(paren
id|fl
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Add lock fl to the blocked list pointed to by block.&n; * We search to the end of the existing list and insert the the new&n; * struct. This ensures processes will be woken up in the order they&n; * blocked.&n; * NOTE: nowhere does the documentation insist that processes be woken&n; * up in this order, but it seems like the reasonable thing to do.&n; * If the blocked list gets long then this search could get expensive,&n; * in which case we could consider waking the processes up in reverse&n; * order, or making the blocked list a doubly linked circular list.&n; * &n; * This functions are called only from one place (flock_lock_file)&n; * so they are inlined now. -- Dmitry Gorodchanin 02/09/96.&n; */
DECL|function|locks_insert_block
r_static
r_inline
r_void
id|locks_insert_block
c_func
(paren
r_struct
id|file_lock
op_star
id|bfl
comma
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
r_while
c_loop
(paren
id|bfl-&gt;fl_block
op_ne
l_int|NULL
)paren
(brace
id|bfl
op_assign
id|bfl-&gt;fl_block
suffix:semicolon
)brace
id|bfl-&gt;fl_block
op_assign
id|fl
suffix:semicolon
id|fl-&gt;fl_block
op_assign
l_int|NULL
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|locks_delete_block
r_static
r_inline
r_void
id|locks_delete_block
c_func
(paren
r_struct
id|file_lock
op_star
id|bfl
comma
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
r_struct
id|file_lock
op_star
id|tfl
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tfl
op_assign
id|bfl-&gt;fl_block
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|tfl
op_eq
id|fl
)paren
(brace
id|bfl-&gt;fl_block
op_assign
id|fl-&gt;fl_block
suffix:semicolon
id|fl-&gt;fl_block
op_assign
l_int|NULL
suffix:semicolon
r_return
suffix:semicolon
)brace
id|bfl
op_assign
id|tfl
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* flock() system call entry point. Apply a FLOCK style lock to&n; * an open file descriptor.&n; */
DECL|function|sys_flock
id|asmlinkage
r_int
id|sys_flock
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
)paren
(brace
r_struct
id|file_lock
id|file_lock
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fd
op_ge
id|NR_OPEN
)paren
op_logical_or
op_logical_neg
(paren
id|filp
op_assign
id|current-&gt;files-&gt;fd
(braket
id|fd
)braket
)paren
)paren
r_return
(paren
op_minus
id|EBADF
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flock_make_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
comma
id|cmd
)paren
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|file_lock.fl_type
op_ne
id|F_UNLCK
)paren
op_logical_and
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
l_int|3
)paren
)paren
r_return
(paren
op_minus
id|EBADF
)paren
suffix:semicolon
r_return
(paren
id|flock_lock_file
c_func
(paren
id|filp
comma
op_amp
id|file_lock
comma
id|cmd
op_amp
id|LOCK_UN
ques
c_cond
l_int|0
suffix:colon
id|cmd
op_amp
id|LOCK_NB
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Report the first existing lock that would conflict with l.&n; * This implements the F_GETLK command of fcntl().&n; */
DECL|function|fcntl_getlk
r_int
id|fcntl_getlk
c_func
(paren
r_int
r_int
id|fd
comma
r_struct
id|flock
op_star
id|l
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|flock
id|flock
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|file_lock
op_star
id|fl
comma
id|file_lock
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fd
op_ge
id|NR_OPEN
)paren
op_logical_or
op_logical_neg
(paren
id|filp
op_assign
id|current-&gt;files-&gt;fd
(braket
id|fd
)braket
)paren
)paren
r_return
(paren
op_minus
id|EBADF
)paren
suffix:semicolon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|l
comma
r_sizeof
(paren
op_star
id|l
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|flock
comma
id|l
comma
r_sizeof
(paren
id|flock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flock.l_type
op_eq
id|F_UNLCK
)paren
op_logical_or
(paren
id|flock.l_type
op_eq
id|F_EXLCK
)paren
op_logical_or
(paren
id|flock.l_type
op_eq
id|F_SHLCK
)paren
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp-&gt;f_inode
op_logical_or
op_logical_neg
id|posix_make_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
comma
op_amp
id|flock
)paren
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|fl
op_assign
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
id|posix_locks_conflict
c_func
(paren
op_amp
id|file_lock
comma
id|fl
)paren
)paren
(brace
id|flock.l_pid
op_assign
id|fl-&gt;fl_owner-&gt;pid
suffix:semicolon
id|flock.l_start
op_assign
id|fl-&gt;fl_start
suffix:semicolon
id|flock.l_len
op_assign
id|fl-&gt;fl_end
op_eq
id|OFFSET_MAX
ques
c_cond
l_int|0
suffix:colon
id|fl-&gt;fl_end
op_minus
id|fl-&gt;fl_start
op_plus
l_int|1
suffix:semicolon
id|flock.l_whence
op_assign
l_int|0
suffix:semicolon
id|flock.l_type
op_assign
id|fl-&gt;fl_type
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|l
comma
op_amp
id|flock
comma
r_sizeof
(paren
id|flock
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|flock.l_type
op_assign
id|F_UNLCK
suffix:semicolon
multiline_comment|/* no conflict found */
id|memcpy_tofs
c_func
(paren
id|l
comma
op_amp
id|flock
comma
r_sizeof
(paren
id|flock
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Apply the lock described by l to an open file descriptor.&n; * This implements both the F_SETLK and F_SETLKW commands of fcntl().&n; * It also emulates flock() in a pretty broken way for older C&n; * libraries.&n; */
DECL|function|fcntl_setlk
r_int
id|fcntl_setlk
c_func
(paren
r_int
r_int
id|fd
comma
r_int
r_int
id|cmd
comma
r_struct
id|flock
op_star
id|l
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|file_lock
id|file_lock
suffix:semicolon
r_struct
id|flock
id|flock
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
multiline_comment|/*&n;&t; * Get arguments and validate them ...&n;&t; */
r_if
c_cond
(paren
(paren
id|fd
op_ge
id|NR_OPEN
)paren
op_logical_or
op_logical_neg
(paren
id|filp
op_assign
id|current-&gt;files-&gt;fd
(braket
id|fd
)braket
)paren
)paren
r_return
(paren
op_minus
id|EBADF
)paren
suffix:semicolon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|l
comma
r_sizeof
(paren
op_star
id|l
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
(paren
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inode
op_assign
id|filp-&gt;f_inode
)paren
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t allow mandatory locks on files that may be memory mapped&n;&t; * and shared.&n;&t; */
r_if
c_cond
(paren
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_ISGID
op_or
id|S_IXGRP
)paren
)paren
op_eq
id|S_ISGID
op_logical_and
id|inode-&gt;i_mmap
)paren
(brace
r_struct
id|vm_area_struct
op_star
id|vma
op_assign
id|inode-&gt;i_mmap
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|vma-&gt;vm_flags
op_amp
id|VM_MAYSHARE
)paren
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
id|vma
op_assign
id|vma-&gt;vm_next_share
suffix:semicolon
)brace
r_while
c_loop
(paren
id|vma
op_ne
id|inode-&gt;i_mmap
)paren
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|flock
comma
id|l
comma
r_sizeof
(paren
id|flock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|posix_make_lock
c_func
(paren
id|filp
comma
op_amp
id|file_lock
comma
op_amp
id|flock
)paren
)paren
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|flock.l_type
)paren
(brace
r_case
id|F_RDLCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
l_int|1
)paren
)paren
r_return
(paren
op_minus
id|EBADF
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_WRLCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
l_int|2
)paren
)paren
r_return
(paren
op_minus
id|EBADF
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_SHLCK
suffix:colon
r_case
id|F_EXLCK
suffix:colon
macro_line|#if 1
multiline_comment|/* warn a bit for now, but don&squot;t overdo it */
(brace
r_static
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|5
)paren
(brace
id|count
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;fcntl_setlk() called by process %d with broken flock() emulation&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|filp-&gt;f_mode
op_amp
l_int|3
)paren
)paren
r_return
(paren
op_minus
id|EBADF
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_UNLCK
suffix:colon
r_break
suffix:semicolon
)brace
r_return
(paren
id|posix_lock_file
c_func
(paren
id|filp
comma
op_amp
id|file_lock
comma
id|cmd
op_eq
id|F_SETLKW
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This function is called when the file is closed.&n; */
DECL|function|locks_remove_locks
r_void
id|locks_remove_locks
c_func
(paren
r_struct
id|task_struct
op_star
id|task
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_struct
id|file_lock
op_star
op_star
id|before
suffix:semicolon
multiline_comment|/* For POSIX locks we free all locks on this file for the given task.&n;&t; * For FLOCK we only free locks on this *open* file if it is the last&n;&t; * close on that file.&n;&t; */
id|before
op_assign
op_amp
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
r_while
c_loop
(paren
(paren
id|fl
op_assign
op_star
id|before
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|fl-&gt;fl_flags
op_amp
id|F_POSIX
)paren
op_logical_and
(paren
id|fl-&gt;fl_owner
op_eq
id|task
)paren
)paren
op_logical_or
(paren
(paren
id|fl-&gt;fl_flags
op_amp
id|F_FLOCK
)paren
op_logical_and
(paren
id|fl-&gt;fl_file
op_eq
id|filp
)paren
op_logical_and
(paren
id|filp-&gt;f_count
op_eq
l_int|1
)paren
)paren
)paren
id|locks_delete_lock
c_func
(paren
id|before
comma
l_int|0
)paren
suffix:semicolon
r_else
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|locks_verify_locked
r_int
id|locks_verify_locked
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
multiline_comment|/* Candidates for mandatory locking have the setgid bit set&n;&t; * but no group execute bit -  an otherwise meaningless combination.&n;&t; */
r_if
c_cond
(paren
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_ISGID
op_or
id|S_IXGRP
)paren
)paren
op_eq
id|S_ISGID
)paren
r_return
(paren
id|locks_mandatory_locked
c_func
(paren
id|inode
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|locks_mandatory_locked
r_int
id|locks_mandatory_locked
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
multiline_comment|/* Search the lock list for this inode for any POSIX locks.&n;&t; */
r_for
c_loop
(paren
id|fl
op_assign
id|inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
(paren
id|fl-&gt;fl_flags
op_amp
id|F_POSIX
)paren
op_logical_and
(paren
id|fl-&gt;fl_owner
op_ne
id|current
)paren
)paren
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|locks_verify_area
r_int
id|locks_verify_area
c_func
(paren
r_int
id|read_write
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|count
)paren
(brace
multiline_comment|/* Candidates for mandatory locking have the setgid bit set&n;&t; * but no group execute bit -  an otherwise meaningless combination.&n;&t; */
r_if
c_cond
(paren
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_ISGID
op_or
id|S_IXGRP
)paren
)paren
op_eq
id|S_ISGID
)paren
r_return
(paren
id|locks_mandatory_area
c_func
(paren
id|read_write
comma
id|inode
comma
id|filp
comma
id|offset
comma
id|count
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|locks_mandatory_area
r_int
id|locks_mandatory_area
c_func
(paren
r_int
id|read_write
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|offset
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
id|repeat
suffix:colon
multiline_comment|/*&n;&t; * Search the lock list for this inode for locks that conflict with&n;&t; * the proposed read/write.&n;&t; */
r_for
c_loop
(paren
id|fl
op_assign
id|inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
(paren
id|fl-&gt;fl_flags
op_amp
id|F_FLOCK
)paren
op_logical_or
(paren
(paren
id|fl-&gt;fl_flags
op_amp
id|F_POSIX
)paren
op_logical_and
(paren
id|fl-&gt;fl_owner
op_eq
id|current
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_end
OL
id|offset
op_logical_or
id|fl-&gt;fl_start
op_ge
id|offset
op_plus
id|count
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Block for writes against a &quot;read&quot; lock, and both reads and&n;&t;&t; * writes against a &quot;write&quot; lock.&n;&t;&t; */
r_if
c_cond
(paren
id|read_write
op_eq
id|FLOCK_VERIFY_WRITE
op_logical_or
id|fl-&gt;fl_type
op_eq
id|F_WRLCK
)paren
(brace
r_if
c_cond
(paren
id|filp
op_logical_and
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
)paren
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
r_return
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|locks_deadlock
c_func
(paren
id|current
comma
id|fl-&gt;fl_owner
)paren
)paren
r_return
(paren
op_minus
id|EDEADLOCK
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|fl-&gt;fl_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
r_return
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If we&squot;ve been sleeping someone might have changed&n;&t;&t;&t; * the permissions behind our back.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_ISGID
op_or
id|S_IXGRP
)paren
)paren
op_ne
id|S_ISGID
)paren
r_break
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Verify a &quot;struct flock&quot; and copy it to a &quot;struct file_lock&quot; as a POSIX&n; * style lock.&n; */
DECL|function|posix_make_lock
r_static
r_int
id|posix_make_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
comma
r_struct
id|flock
op_star
id|l
)paren
(brace
id|off_t
id|start
suffix:semicolon
id|fl-&gt;fl_flags
op_assign
id|F_POSIX
suffix:semicolon
r_switch
c_cond
(paren
id|l-&gt;l_type
)paren
(brace
r_case
id|F_RDLCK
suffix:colon
r_case
id|F_WRLCK
suffix:colon
r_case
id|F_UNLCK
suffix:colon
id|fl-&gt;fl_type
op_assign
id|l-&gt;l_type
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_SHLCK
suffix:colon
id|fl-&gt;fl_type
op_assign
id|F_RDLCK
suffix:semicolon
id|fl-&gt;fl_flags
op_or_assign
id|F_BROKEN
suffix:semicolon
r_break
suffix:semicolon
r_case
id|F_EXLCK
suffix:colon
id|fl-&gt;fl_type
op_assign
id|F_WRLCK
suffix:semicolon
id|fl-&gt;fl_flags
op_or_assign
id|F_BROKEN
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|l-&gt;l_whence
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/*SEEK_SET*/
id|start
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/*SEEK_CUR*/
id|start
op_assign
id|filp-&gt;f_pos
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/*SEEK_END*/
id|start
op_assign
id|filp-&gt;f_inode-&gt;i_size
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|start
op_add_assign
id|l-&gt;l_start
)paren
OL
l_int|0
)paren
op_logical_or
(paren
id|l-&gt;l_len
OL
l_int|0
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|fl-&gt;fl_start
op_assign
id|start
suffix:semicolon
multiline_comment|/* we record the absolute position */
r_if
c_cond
(paren
(paren
id|l-&gt;l_len
op_eq
l_int|0
)paren
op_logical_or
(paren
(paren
id|fl-&gt;fl_end
op_assign
id|start
op_plus
id|l-&gt;l_len
op_minus
l_int|1
)paren
OL
l_int|0
)paren
)paren
id|fl-&gt;fl_end
op_assign
id|OFFSET_MAX
suffix:semicolon
id|fl-&gt;fl_file
op_assign
id|filp
suffix:semicolon
id|fl-&gt;fl_owner
op_assign
id|current
suffix:semicolon
id|fl-&gt;fl_wait
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* just for cleanliness */
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Verify a call to flock() and fill in a file_lock structure with&n; * an appropriate FLOCK lock.&n; */
DECL|function|flock_make_lock
r_static
r_int
id|flock_make_lock
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|fl
comma
r_int
r_int
id|cmd
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|filp-&gt;f_inode
)paren
multiline_comment|/* just in case */
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
op_amp
op_complement
id|LOCK_NB
)paren
(brace
r_case
id|LOCK_SH
suffix:colon
id|fl-&gt;fl_type
op_assign
id|F_RDLCK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LOCK_EX
suffix:colon
id|fl-&gt;fl_type
op_assign
id|F_WRLCK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LOCK_UN
suffix:colon
id|fl-&gt;fl_type
op_assign
id|F_UNLCK
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|fl-&gt;fl_flags
op_assign
id|F_FLOCK
suffix:semicolon
id|fl-&gt;fl_start
op_assign
l_int|0
suffix:semicolon
id|fl-&gt;fl_end
op_assign
id|OFFSET_MAX
suffix:semicolon
id|fl-&gt;fl_file
op_assign
id|filp
suffix:semicolon
id|fl-&gt;fl_owner
op_assign
id|current
suffix:semicolon
id|fl-&gt;fl_wait
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* just for cleanliness */
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Determine if lock sys_fl blocks lock caller_fl. POSIX specific&n; * checking before calling the locks_conflict().&n; */
DECL|function|posix_locks_conflict
r_static
r_int
id|posix_locks_conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
(brace
multiline_comment|/* POSIX locks owned by the same process do not conflict with&n;&t; * each other.&n;&t; */
r_if
c_cond
(paren
(paren
id|sys_fl-&gt;fl_flags
op_amp
id|F_POSIX
)paren
op_logical_and
(paren
id|caller_fl-&gt;fl_owner
op_eq
id|sys_fl-&gt;fl_owner
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|locks_conflict
c_func
(paren
id|caller_fl
comma
id|sys_fl
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Determine if lock sys_fl blocks lock caller_fl. FLOCK specific&n; * checking before calling the locks_conflict().&n; */
DECL|function|flock_locks_conflict
r_static
r_int
id|flock_locks_conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
(brace
multiline_comment|/* FLOCK locks referring to the same filp do not conflict with&n;&t; * each other.&n;&t; */
r_if
c_cond
(paren
(paren
id|sys_fl-&gt;fl_flags
op_amp
id|F_FLOCK
)paren
op_logical_and
(paren
id|caller_fl-&gt;fl_file
op_eq
id|sys_fl-&gt;fl_file
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|locks_conflict
c_func
(paren
id|caller_fl
comma
id|sys_fl
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Determine if lock sys_fl blocks lock caller_fl. Common functionality&n; * checks for overlapping locks and shared/exclusive status.&n; */
DECL|function|locks_conflict
r_static
r_int
id|locks_conflict
c_func
(paren
r_struct
id|file_lock
op_star
id|caller_fl
comma
r_struct
id|file_lock
op_star
id|sys_fl
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|locks_overlap
c_func
(paren
id|caller_fl
comma
id|sys_fl
)paren
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|caller_fl-&gt;fl_type
)paren
(brace
r_case
id|F_RDLCK
suffix:colon
r_return
(paren
id|sys_fl-&gt;fl_type
op_eq
id|F_WRLCK
)paren
suffix:semicolon
r_case
id|F_WRLCK
suffix:colon
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;locks_conflict(): impossible lock type - %d&bslash;n&quot;
comma
id|caller_fl-&gt;fl_type
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* This should never happen */
)brace
multiline_comment|/* Check if two locks overlap each other.&n; */
DECL|function|locks_overlap
r_static
r_int
id|locks_overlap
c_func
(paren
r_struct
id|file_lock
op_star
id|fl1
comma
r_struct
id|file_lock
op_star
id|fl2
)paren
(brace
r_return
(paren
(paren
id|fl1-&gt;fl_end
op_ge
id|fl2-&gt;fl_start
)paren
op_logical_and
(paren
id|fl2-&gt;fl_end
op_ge
id|fl1-&gt;fl_start
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This function tests for deadlock condition before putting a process to&n; * sleep. The detection scheme is no longer recursive. Recursive was neat,&n; * but dangerous - we risked stack corruption if the lock data was bad, or&n; * if the recursion was too deep for any other reason.&n; *&n; * We rely on the fact that a task can only be on one lock&squot;s wait queue&n; * at a time. When we find blocked_task on a wait queue we can re-search&n; * with blocked_task equal to that queue&squot;s owner, until either blocked_task&n; * isn&squot;t found, or blocked_task is found on a queue owned by my_task.&n; */
DECL|function|locks_deadlock
r_static
r_int
id|locks_deadlock
c_func
(paren
r_struct
id|task_struct
op_star
id|my_task
comma
r_struct
id|task_struct
op_star
id|blocked_task
)paren
(brace
r_struct
id|wait_queue
op_star
id|dlock_wait
suffix:semicolon
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
id|next_task
suffix:colon
r_if
c_cond
(paren
id|my_task
op_eq
id|blocked_task
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|fl
op_assign
id|file_lock_table
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_nextlink
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_owner
op_eq
l_int|NULL
op_logical_or
id|fl-&gt;fl_wait
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|dlock_wait
op_assign
id|fl-&gt;fl_wait
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|dlock_wait-&gt;task
op_eq
id|blocked_task
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_owner
op_eq
id|my_task
)paren
(brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|blocked_task
op_assign
id|fl-&gt;fl_owner
suffix:semicolon
r_goto
id|next_task
suffix:semicolon
)brace
id|dlock_wait
op_assign
id|dlock_wait-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dlock_wait
op_ne
id|fl-&gt;fl_wait
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Try to create a FLOCK lock on filp. We rely on FLOCK locks being sorted&n; * first in an inode&squot;s lock list, and always insert new locks at the head&n; * of the list.&n; */
DECL|function|flock_lock_file
r_static
r_int
id|flock_lock_file
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|caller
comma
r_int
r_int
id|wait
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_struct
id|file_lock
op_star
id|new_fl
suffix:semicolon
r_struct
id|file_lock
op_star
op_star
id|before
suffix:semicolon
r_int
id|change
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This a compact little algorithm based on us always placing FLOCK&n;&t; * locks at the front of the list.&n;&t; */
id|before
op_assign
op_amp
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
r_while
c_loop
(paren
(paren
id|fl
op_assign
op_star
id|before
)paren
op_logical_and
(paren
id|fl-&gt;fl_flags
op_amp
id|F_FLOCK
)paren
)paren
(brace
r_if
c_cond
(paren
id|caller-&gt;fl_file
op_eq
id|fl-&gt;fl_file
)paren
(brace
r_if
c_cond
(paren
id|caller-&gt;fl_type
op_eq
id|fl-&gt;fl_type
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|change
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
)brace
multiline_comment|/* change means that we are changing the type of an existing lock, or&n;&t; * or else unlocking it.&n;&t; */
r_if
c_cond
(paren
id|change
)paren
id|locks_delete_lock
c_func
(paren
id|before
comma
id|caller-&gt;fl_type
op_ne
id|F_UNLCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|caller-&gt;fl_type
op_eq
id|F_UNLCK
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|new_fl
op_assign
id|locks_alloc_lock
c_func
(paren
id|caller
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
(paren
op_minus
id|ENOLCK
)paren
suffix:semicolon
id|repeat
suffix:colon
r_for
c_loop
(paren
id|fl
op_assign
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|flock_locks_conflict
c_func
(paren
id|new_fl
comma
id|fl
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
multiline_comment|/* Note: new_fl is not in any queue at this&n;&t;&t;&t;&t; * point, so we must use locks_free_lock()&n;&t;&t;&t;&t; * instead of locks_delete_lock()&n;&t;&t;&t;&t; * &t;Dmitry Gorodchanin 09/02/96.&n;&t;&t;&t;&t; */
id|locks_free_lock
c_func
(paren
id|new_fl
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
)brace
multiline_comment|/* Try to avoid deadlocks due to pathological programs that&n;&t;&t;&t; * mix calls to flock() and fcntl(). Return EAGAIN, because&n;&t;&t;&t; * EDEADLOCK isn&squot;t a documented return value for flock().&n;&t;&t;&t; */
r_if
c_cond
(paren
id|locks_deadlock
c_func
(paren
id|new_fl-&gt;fl_owner
comma
id|fl-&gt;fl_owner
)paren
)paren
(brace
id|locks_free_lock
c_func
(paren
id|new_fl
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
)brace
id|locks_insert_block
c_func
(paren
id|fl
comma
id|new_fl
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|new_fl-&gt;fl_wait
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|new_fl-&gt;fl_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
multiline_comment|/* If we are here, than we were awakened&n;&t;&t;&t;&t; * by a signal, so new_fl is still in the&n;&t;&t;&t;&t; * block queue of fl. We need to remove &n;&t;&t;&t;&t; * new_fl and then free it.&n;&t;&t;&t;&t; * &t;Dmitry Gorodchanin 09/02/96.&n;&t;&t;&t;&t; */
id|locks_delete_block
c_func
(paren
id|fl
comma
id|new_fl
)paren
suffix:semicolon
id|locks_free_lock
c_func
(paren
id|new_fl
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
)brace
r_goto
id|repeat
suffix:semicolon
)brace
id|locks_free_lock
c_func
(paren
id|new_fl
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
)brace
id|locks_insert_lock
c_func
(paren
op_amp
id|filp-&gt;f_inode-&gt;i_flock
comma
id|new_fl
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Add a POSIX style lock to a file.&n; * We merge adjacent locks whenever possible. POSIX locks come after FLOCK&n; * locks in the list and are sorted by owner task, then by starting address&n; *&n; * Kai Petzke writes:&n; * To make freeing a lock much faster, we keep a pointer to the lock before the&n; * actual one. But the real gain of the new coding was, that lock_it() and&n; * unlock_it() became one function.&n; *&n; * To all purists: Yes, I use a few goto&squot;s. Just pass on to the next function.&n; */
DECL|function|posix_lock_file
r_static
r_int
id|posix_lock_file
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|file_lock
op_star
id|caller
comma
r_int
r_int
id|wait
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_struct
id|file_lock
op_star
id|new_fl
suffix:semicolon
r_struct
id|file_lock
op_star
id|left
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|file_lock
op_star
id|right
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|file_lock
op_star
op_star
id|before
suffix:semicolon
r_int
id|added
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|caller-&gt;fl_type
op_ne
id|F_UNLCK
)paren
(brace
id|repeat
suffix:colon
r_for
c_loop
(paren
id|fl
op_assign
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|posix_locks_conflict
c_func
(paren
id|caller
comma
id|fl
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
r_return
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|locks_deadlock
c_func
(paren
id|caller-&gt;fl_owner
comma
id|fl-&gt;fl_owner
)paren
)paren
r_return
(paren
op_minus
id|EDEADLOCK
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|fl-&gt;fl_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
r_return
(paren
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_return
(paren
op_minus
id|EAGAIN
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Find the first old lock with the same owner as the new lock.&n;&t; */
id|before
op_assign
op_amp
id|filp-&gt;f_inode-&gt;i_flock
suffix:semicolon
multiline_comment|/* First skip FLOCK locks and locks owned by other processes.&n;&t; */
r_while
c_loop
(paren
(paren
id|fl
op_assign
op_star
id|before
)paren
op_logical_and
(paren
(paren
id|fl-&gt;fl_flags
op_amp
id|F_FLOCK
)paren
op_logical_or
(paren
id|caller-&gt;fl_owner
op_ne
id|fl-&gt;fl_owner
)paren
)paren
)paren
(brace
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
)brace
multiline_comment|/* Process locks with this owner.&n;&t; */
r_while
c_loop
(paren
(paren
id|fl
op_assign
op_star
id|before
)paren
op_logical_and
(paren
id|caller-&gt;fl_owner
op_eq
id|fl-&gt;fl_owner
)paren
)paren
(brace
multiline_comment|/* Detect adjacent or overlapping regions (if same lock type)&n;&t;&t; */
r_if
c_cond
(paren
id|caller-&gt;fl_type
op_eq
id|fl-&gt;fl_type
)paren
(brace
r_if
c_cond
(paren
id|fl-&gt;fl_end
OL
id|caller-&gt;fl_start
op_minus
l_int|1
)paren
r_goto
id|next_lock
suffix:semicolon
multiline_comment|/* If the next lock in the list has entirely bigger&n;&t;&t;&t; * addresses than the new one, insert the lock here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fl-&gt;fl_start
OG
id|caller-&gt;fl_end
op_plus
l_int|1
)paren
r_break
suffix:semicolon
multiline_comment|/* If we come here, the new and old lock are of the&n;&t;&t;&t; * same type and adjacent or overlapping. Make one&n;&t;&t;&t; * lock yielding from the lower start address of both&n;&t;&t;&t; * locks to the higher end address.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fl-&gt;fl_start
OG
id|caller-&gt;fl_start
)paren
id|fl-&gt;fl_start
op_assign
id|caller-&gt;fl_start
suffix:semicolon
r_else
id|caller-&gt;fl_start
op_assign
id|fl-&gt;fl_start
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_end
OL
id|caller-&gt;fl_end
)paren
id|fl-&gt;fl_end
op_assign
id|caller-&gt;fl_end
suffix:semicolon
r_else
id|caller-&gt;fl_end
op_assign
id|fl-&gt;fl_end
suffix:semicolon
r_if
c_cond
(paren
id|added
)paren
(brace
id|locks_delete_lock
c_func
(paren
id|before
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|caller
op_assign
id|fl
suffix:semicolon
id|added
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Processing for different lock types is a bit&n;&t;&t;&t; * more complex.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fl-&gt;fl_end
OL
id|caller-&gt;fl_start
)paren
r_goto
id|next_lock
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_start
OG
id|caller-&gt;fl_end
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|caller-&gt;fl_type
op_eq
id|F_UNLCK
)paren
id|added
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_start
OL
id|caller-&gt;fl_start
)paren
id|left
op_assign
id|fl
suffix:semicolon
multiline_comment|/* If the next lock in the list has a higher end&n;&t;&t;&t; * address than the new one, insert the new one here.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fl-&gt;fl_end
OG
id|caller-&gt;fl_end
)paren
(brace
id|right
op_assign
id|fl
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fl-&gt;fl_start
op_ge
id|caller-&gt;fl_start
)paren
(brace
multiline_comment|/* The new lock completely replaces an old&n;&t;&t;&t;&t; * one (This may happen several times).&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|added
)paren
(brace
id|locks_delete_lock
c_func
(paren
id|before
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Replace the old lock with the new one.&n;&t;&t;&t;&t; * Wake up anybody waiting for the old one,&n;&t;&t;&t;&t; * as the change in lock type might satisfy&n;&t;&t;&t;&t; * their needs.&n;&t;&t;&t;&t; */
id|wake_up
c_func
(paren
op_amp
id|fl-&gt;fl_wait
)paren
suffix:semicolon
id|fl-&gt;fl_start
op_assign
id|caller-&gt;fl_start
suffix:semicolon
id|fl-&gt;fl_end
op_assign
id|caller-&gt;fl_end
suffix:semicolon
id|fl-&gt;fl_type
op_assign
id|caller-&gt;fl_type
suffix:semicolon
id|caller
op_assign
id|fl
suffix:semicolon
id|added
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Go on to next lock.&n;&t;&t; */
id|next_lock
suffix:colon
id|before
op_assign
op_amp
id|fl-&gt;fl_next
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|added
)paren
(brace
r_if
c_cond
(paren
id|caller-&gt;fl_type
op_eq
id|F_UNLCK
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|new_fl
op_assign
id|locks_alloc_lock
c_func
(paren
id|caller
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
(paren
op_minus
id|ENOLCK
)paren
suffix:semicolon
id|locks_insert_lock
c_func
(paren
id|before
comma
id|new_fl
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|right
)paren
(brace
r_if
c_cond
(paren
id|left
op_eq
id|right
)paren
(brace
multiline_comment|/* The new lock breaks the old one in two pieces, so we&n;&t;&t;&t; * have to allocate one more lock (in this case, even&n;&t;&t;&t; * F_UNLCK may fail!).&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|left
op_assign
id|locks_alloc_lock
c_func
(paren
id|right
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|added
)paren
id|locks_delete_lock
c_func
(paren
id|before
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENOLCK
)paren
suffix:semicolon
)brace
id|locks_insert_lock
c_func
(paren
id|before
comma
id|left
)paren
suffix:semicolon
)brace
id|right-&gt;fl_start
op_assign
id|caller-&gt;fl_end
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|left
)paren
id|left-&gt;fl_end
op_assign
id|caller-&gt;fl_start
op_minus
l_int|1
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Allocate memory for a new lock and initialize its fields from&n; * fl. The lock is not inserted into any lists until locks_insert_lock()&n; * or locks_insert_block() are called.&n; */
DECL|function|locks_alloc_lock
r_static
r_struct
id|file_lock
op_star
id|locks_alloc_lock
c_func
(paren
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
r_struct
id|file_lock
op_star
id|tmp
suffix:semicolon
multiline_comment|/* Okay, let&squot;s make a new file_lock structure... */
r_if
c_cond
(paren
(paren
id|tmp
op_assign
(paren
r_struct
id|file_lock
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|file_lock
)paren
comma
id|GFP_ATOMIC
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
(paren
id|tmp
)paren
suffix:semicolon
id|tmp-&gt;fl_nextlink
op_assign
l_int|NULL
suffix:semicolon
id|tmp-&gt;fl_prevlink
op_assign
l_int|NULL
suffix:semicolon
id|tmp-&gt;fl_next
op_assign
l_int|NULL
suffix:semicolon
id|tmp-&gt;fl_block
op_assign
l_int|NULL
suffix:semicolon
id|tmp-&gt;fl_flags
op_assign
id|fl-&gt;fl_flags
suffix:semicolon
id|tmp-&gt;fl_owner
op_assign
id|fl-&gt;fl_owner
suffix:semicolon
id|tmp-&gt;fl_file
op_assign
id|fl-&gt;fl_file
suffix:semicolon
id|tmp-&gt;fl_wait
op_assign
l_int|NULL
suffix:semicolon
id|tmp-&gt;fl_type
op_assign
id|fl-&gt;fl_type
suffix:semicolon
id|tmp-&gt;fl_start
op_assign
id|fl-&gt;fl_start
suffix:semicolon
id|tmp-&gt;fl_end
op_assign
id|fl-&gt;fl_end
suffix:semicolon
r_return
(paren
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/* Insert file lock fl into an inode&squot;s lock list at the position indicated&n; * by pos. At the same time add the lock to the global file lock list.&n; */
DECL|function|locks_insert_lock
r_static
r_void
id|locks_insert_lock
c_func
(paren
r_struct
id|file_lock
op_star
op_star
id|pos
comma
r_struct
id|file_lock
op_star
id|fl
)paren
(brace
id|fl-&gt;fl_nextlink
op_assign
id|file_lock_table
suffix:semicolon
id|fl-&gt;fl_prevlink
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|file_lock_table
op_ne
l_int|NULL
)paren
id|file_lock_table-&gt;fl_prevlink
op_assign
id|fl
suffix:semicolon
id|file_lock_table
op_assign
id|fl
suffix:semicolon
id|fl-&gt;fl_next
op_assign
op_star
id|pos
suffix:semicolon
multiline_comment|/* insert into file&squot;s list */
op_star
id|pos
op_assign
id|fl
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Delete a lock and free it.&n; * First remove our lock from the lock lists. Then remove all the blocked&n; * locks from our blocked list, waking up the processes that own them. If&n; * told to wait, then sleep on each of these lock&squot;s wait queues. Each&n; * blocked process will wake up and immediately wake up its own wait queue&n; * allowing us to be scheduled again. Lastly, wake up our own wait queue&n; * before freeing the file_lock structure.&n; */
DECL|function|locks_delete_lock
r_static
r_void
id|locks_delete_lock
c_func
(paren
r_struct
id|file_lock
op_star
op_star
id|fl_p
comma
r_int
r_int
id|wait
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_struct
id|file_lock
op_star
id|pfl
suffix:semicolon
r_struct
id|file_lock
op_star
id|nfl
suffix:semicolon
id|fl
op_assign
op_star
id|fl_p
suffix:semicolon
op_star
id|fl_p
op_assign
id|fl-&gt;fl_next
suffix:semicolon
id|pfl
op_assign
id|fl-&gt;fl_prevlink
suffix:semicolon
id|nfl
op_assign
id|fl-&gt;fl_nextlink
suffix:semicolon
r_if
c_cond
(paren
id|nfl
op_ne
l_int|NULL
)paren
id|nfl-&gt;fl_prevlink
op_assign
id|pfl
suffix:semicolon
r_if
c_cond
(paren
id|pfl
op_ne
l_int|NULL
)paren
id|pfl-&gt;fl_nextlink
op_assign
id|nfl
suffix:semicolon
r_else
id|file_lock_table
op_assign
id|nfl
suffix:semicolon
r_while
c_loop
(paren
(paren
id|nfl
op_assign
id|fl-&gt;fl_block
)paren
op_ne
l_int|NULL
)paren
(brace
id|fl-&gt;fl_block
op_assign
id|nfl-&gt;fl_block
suffix:semicolon
id|nfl-&gt;fl_block
op_assign
l_int|NULL
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|nfl-&gt;fl_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
id|sleep_on
c_func
(paren
op_amp
id|nfl-&gt;fl_wait
)paren
suffix:semicolon
)brace
id|wake_up
c_func
(paren
op_amp
id|fl-&gt;fl_wait
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fl
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|lock_get_status
r_static
r_char
op_star
id|lock_get_status
c_func
(paren
r_struct
id|file_lock
op_star
id|fl
comma
r_char
op_star
id|p
comma
r_int
id|id
comma
r_char
op_star
id|pfx
)paren
(brace
r_struct
id|wait_queue
op_star
id|wt
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%d:%s &quot;
comma
id|id
comma
id|pfx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fl-&gt;fl_flags
op_amp
id|F_POSIX
)paren
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%s %s &quot;
comma
(paren
id|fl-&gt;fl_flags
op_amp
id|F_BROKEN
)paren
ques
c_cond
l_string|&quot;BROKEN&quot;
suffix:colon
l_string|&quot;POSIX &quot;
comma
(paren
(paren
id|fl-&gt;fl_file-&gt;f_inode-&gt;i_mode
op_amp
(paren
id|S_IXGRP
op_or
id|S_ISGID
)paren
)paren
op_eq
id|S_ISGID
)paren
ques
c_cond
l_string|&quot;MANDATORY&quot;
suffix:colon
l_string|&quot;ADVISORY &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;FLOCK  ADVISORY  &quot;
)paren
suffix:semicolon
)brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%s &quot;
comma
(paren
id|fl-&gt;fl_type
op_eq
id|F_RDLCK
)paren
ques
c_cond
l_string|&quot;READ &quot;
suffix:colon
l_string|&quot;WRITE&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%d %04x:%ld %ld %ld &quot;
comma
id|fl-&gt;fl_owner-&gt;pid
comma
id|fl-&gt;fl_file-&gt;f_inode-&gt;i_dev
comma
id|fl-&gt;fl_file-&gt;f_inode-&gt;i_ino
comma
id|fl-&gt;fl_start
comma
id|fl-&gt;fl_end
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%08lx %08lx %08lx %08lx %08lx&bslash;n%d:%s&quot;
comma
(paren
r_int
)paren
id|fl
comma
(paren
r_int
)paren
id|fl-&gt;fl_prevlink
comma
(paren
r_int
)paren
id|fl-&gt;fl_nextlink
comma
(paren
r_int
)paren
id|fl-&gt;fl_next
comma
(paren
r_int
)paren
id|fl-&gt;fl_block
comma
id|id
comma
id|pfx
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|wt
op_assign
id|fl-&gt;fl_wait
)paren
op_ne
l_int|NULL
)paren
(brace
r_do
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; %d&quot;
comma
id|wt-&gt;task-&gt;pid
)paren
suffix:semicolon
id|wt
op_assign
id|wt-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|wt
op_ne
id|fl-&gt;fl_wait
)paren
suffix:semicolon
)brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|p
)paren
suffix:semicolon
)brace
DECL|function|get_locks_status
r_int
id|get_locks_status
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
suffix:semicolon
r_struct
id|file_lock
op_star
id|bfl
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
id|p
op_assign
id|buf
suffix:semicolon
r_for
c_loop
(paren
id|fl
op_assign
id|file_lock_table
comma
id|i
op_assign
l_int|1
suffix:semicolon
id|fl
op_ne
l_int|NULL
suffix:semicolon
id|fl
op_assign
id|fl-&gt;fl_nextlink
comma
id|i
op_increment
)paren
(brace
id|p
op_assign
id|lock_get_status
c_func
(paren
id|fl
comma
id|p
comma
id|i
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bfl
op_assign
id|fl
suffix:semicolon
id|bfl-&gt;fl_block
op_ne
l_int|NULL
suffix:semicolon
id|bfl
op_assign
id|bfl-&gt;fl_block
)paren
id|p
op_assign
id|lock_get_status
c_func
(paren
id|bfl-&gt;fl_block
comma
id|p
comma
id|i
comma
l_string|&quot; -&gt;&quot;
)paren
suffix:semicolon
)brace
r_return
(paren
id|p
op_minus
id|buf
)paren
suffix:semicolon
)brace
eof
