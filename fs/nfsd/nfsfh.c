multiline_comment|/*&n; * linux/fs/nfsd/nfsfh.c&n; *&n; * NFS server filehandle treatment.&n; *&n; * Copyright (C) 1995, 1996 Olaf Kirch &lt;okir@monad.swb.de&gt;&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/dcache.h&gt;
macro_line|#include &lt;linux/sunrpc/svc.h&gt;
macro_line|#include &lt;linux/nfsd/nfsd.h&gt;
DECL|macro|NFSDDBG_FACILITY
mdefine_line|#define NFSDDBG_FACILITY&t;&t;NFSDDBG_FH
DECL|macro|NFSD_PARANOIA
mdefine_line|#define NFSD_PARANOIA 1
multiline_comment|/* #define NFSD_DEBUG_VERBOSE 1 */
r_extern
r_int
r_int
id|num_physpages
suffix:semicolon
DECL|macro|NFSD_FILE_CACHE
mdefine_line|#define NFSD_FILE_CACHE 0
DECL|macro|NFSD_DIR_CACHE
mdefine_line|#define NFSD_DIR_CACHE  1
DECL|struct|fh_entry
r_struct
id|fh_entry
(brace
DECL|member|dentry
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
DECL|member|reftime
r_int
r_int
id|reftime
suffix:semicolon
DECL|member|ino
id|ino_t
id|ino
suffix:semicolon
DECL|member|dev
id|dev_t
id|dev
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|NFSD_MAXFH
mdefine_line|#define NFSD_MAXFH PAGE_SIZE/sizeof(struct fh_entry)
DECL|variable|filetable
r_static
r_struct
id|fh_entry
id|filetable
(braket
id|NFSD_MAXFH
)braket
suffix:semicolon
DECL|variable|dirstable
r_static
r_struct
id|fh_entry
id|dirstable
(braket
id|NFSD_MAXFH
)braket
suffix:semicolon
DECL|variable|nfsd_nr_verified
r_static
r_int
id|nfsd_nr_verified
op_assign
l_int|0
suffix:semicolon
DECL|variable|nfsd_nr_put
r_static
r_int
id|nfsd_nr_put
op_assign
l_int|0
suffix:semicolon
DECL|variable|nfsd_next_expire
r_static
r_int
r_int
id|nfsd_next_expire
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|add_to_fhcache
c_func
(paren
r_struct
id|dentry
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|nfsd_d_validate
c_func
(paren
r_struct
id|dentry
op_star
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|fixup_head
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|path_inuse
)paren
suffix:semicolon
DECL|variable|nfsd_nr_paths
r_static
r_int
id|nfsd_nr_paths
op_assign
l_int|0
suffix:semicolon
DECL|macro|NFSD_MAX_PATHS
mdefine_line|#define NFSD_MAX_PATHS 500
DECL|struct|nfsd_fixup
r_struct
id|nfsd_fixup
(brace
DECL|member|lru
r_struct
id|list_head
id|lru
suffix:semicolon
DECL|member|dentry
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
DECL|member|reftime
r_int
r_int
id|reftime
suffix:semicolon
DECL|member|ino
id|ino_t
id|ino
suffix:semicolon
DECL|member|dev
id|dev_t
id|dev
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|nfsd_path
r_struct
id|nfsd_path
(brace
DECL|member|lru
r_struct
id|list_head
id|lru
suffix:semicolon
DECL|member|reftime
r_int
r_int
id|reftime
suffix:semicolon
DECL|member|users
r_int
id|users
suffix:semicolon
DECL|member|ino
id|ino_t
id|ino
suffix:semicolon
DECL|member|dev
id|dev_t
id|dev
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
l_int|1
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Copy a dentry&squot;s path into the specified buffer.&n; */
DECL|function|copy_path
r_static
r_int
id|copy_path
c_func
(paren
r_char
op_star
id|buffer
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|namelen
)paren
(brace
r_char
op_star
id|p
comma
op_star
id|b
op_assign
id|buffer
suffix:semicolon
r_int
id|result
op_assign
l_int|0
comma
id|totlen
op_assign
l_int|0
comma
id|len
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|dentry
op_star
id|parent
suffix:semicolon
id|dentry
op_assign
id|dentry-&gt;d_covers
suffix:semicolon
id|parent
op_assign
id|dentry-&gt;d_parent
suffix:semicolon
id|len
op_assign
id|dentry-&gt;d_name.len
suffix:semicolon
id|p
op_assign
(paren
r_char
op_star
)paren
id|dentry-&gt;d_name.name
op_plus
id|len
suffix:semicolon
id|totlen
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|totlen
OG
id|namelen
)paren
r_goto
id|out
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
op_star
id|b
op_increment
op_assign
op_star
(paren
op_decrement
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
op_eq
id|parent
)paren
r_break
suffix:semicolon
id|dentry
op_assign
id|parent
suffix:semicolon
id|totlen
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|totlen
OG
id|namelen
)paren
r_goto
id|out
suffix:semicolon
op_star
id|b
op_increment
op_assign
l_char|&squot;/&squot;
suffix:semicolon
)brace
op_star
id|b
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Now reverse in place ...&n;&t; */
id|p
op_assign
id|buffer
suffix:semicolon
r_while
c_loop
(paren
id|p
OL
id|b
)paren
(brace
r_char
id|c
op_assign
op_star
(paren
op_decrement
id|b
)paren
suffix:semicolon
op_star
id|b
op_assign
op_star
id|p
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|c
suffix:semicolon
)brace
id|result
op_assign
l_int|1
suffix:semicolon
id|out
suffix:colon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a dentry&squot;s path to the path cache.&n; */
DECL|function|add_to_path_cache
r_static
r_int
id|add_to_path_cache
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_struct
id|dentry
op_star
id|this
suffix:semicolon
r_struct
id|nfsd_path
op_star
r_new
suffix:semicolon
r_int
id|len
comma
id|result
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef NFSD_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;add_to_path_cache: cacheing %s/%s&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Get the length of the full pathname.&n;&t; */
id|restart
suffix:colon
id|len
op_assign
l_int|0
suffix:semicolon
id|this
op_assign
id|dentry
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|dentry
op_star
id|parent
suffix:semicolon
id|this
op_assign
id|this-&gt;d_covers
suffix:semicolon
id|parent
op_assign
id|this-&gt;d_parent
suffix:semicolon
id|len
op_add_assign
id|this-&gt;d_name.len
suffix:semicolon
r_if
c_cond
(paren
id|this
op_eq
id|parent
)paren
r_break
suffix:semicolon
id|this
op_assign
id|parent
suffix:semicolon
id|len
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocate a structure to hold the path.&n;&t; */
r_new
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|nfsd_path
)paren
op_plus
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
)paren
(brace
r_new
op_member_access_from_pointer
id|users
op_assign
l_int|0
suffix:semicolon
r_new
op_member_access_from_pointer
id|reftime
op_assign
id|jiffies
suffix:semicolon
r_new
op_member_access_from_pointer
id|ino
op_assign
id|inode-&gt;i_ino
suffix:semicolon
r_new
op_member_access_from_pointer
id|dev
op_assign
id|inode-&gt;i_dev
suffix:semicolon
id|result
op_assign
id|copy_path
c_func
(paren
r_new
op_member_access_from_pointer
id|name
comma
id|dentry
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
r_goto
id|retry
suffix:semicolon
id|list_add
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|lru
comma
op_amp
id|path_inuse
)paren
suffix:semicolon
id|nfsd_nr_paths
op_increment
suffix:semicolon
macro_line|#ifdef NFSD_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;add_to_path_cache: added %s, paths=%d&bslash;n&quot;
comma
r_new
op_member_access_from_pointer
id|name
comma
id|nfsd_nr_paths
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
id|result
suffix:semicolon
multiline_comment|/*&n;&t; * If the dentry&squot;s path length changed, just try again ...&n;&t; */
id|retry
suffix:colon
id|kfree
c_func
(paren
r_new
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;add_to_path_cache: path length changed, retrying&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
multiline_comment|/*&n; * Search for a path entry for the specified (dev, inode).&n; */
DECL|function|get_path_entry
r_struct
id|nfsd_path
op_star
id|get_path_entry
c_func
(paren
id|dev_t
id|dev
comma
id|ino_t
id|ino
)paren
(brace
r_struct
id|nfsd_path
op_star
id|pe
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|path_inuse.next
suffix:semicolon
id|tmp
op_ne
op_amp
id|path_inuse
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
(brace
id|pe
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|nfsd_path
comma
id|lru
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pe-&gt;ino
op_ne
id|ino
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pe-&gt;dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
id|list_del
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|list_add
c_func
(paren
id|tmp
comma
op_amp
id|path_inuse
)paren
suffix:semicolon
id|pe-&gt;users
op_increment
suffix:semicolon
id|pe-&gt;reftime
op_assign
id|jiffies
suffix:semicolon
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;get_path_entry: found %s for %s/%ld&bslash;n&quot;
comma
id|pe-&gt;name
comma
id|kdevname
c_func
(paren
id|dev
)paren
comma
id|ino
)paren
suffix:semicolon
macro_line|#endif
r_return
id|pe
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|put_path
r_static
r_void
id|put_path
c_func
(paren
r_struct
id|nfsd_path
op_star
id|pe
)paren
(brace
id|pe-&gt;users
op_decrement
suffix:semicolon
)brace
DECL|function|free_path_entry
r_static
r_void
id|free_path_entry
c_func
(paren
r_struct
id|nfsd_path
op_star
id|pe
)paren
(brace
r_if
c_cond
(paren
id|pe-&gt;users
)paren
id|printk
c_func
(paren
l_string|&quot;free_path_entry: %s in use, users=%d&bslash;n&quot;
comma
id|pe-&gt;name
comma
id|pe-&gt;users
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|pe-&gt;lru
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pe
)paren
suffix:semicolon
id|nfsd_nr_paths
op_decrement
suffix:semicolon
)brace
DECL|struct|nfsd_getdents_callback
r_struct
id|nfsd_getdents_callback
(brace
DECL|member|dirent
r_struct
id|nfsd_dirent
op_star
id|dirent
suffix:semicolon
DECL|member|found
r_int
id|found
suffix:semicolon
DECL|member|checked
r_int
id|checked
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|nfsd_dirent
r_struct
id|nfsd_dirent
(brace
DECL|member|ino
id|ino_t
id|ino
suffix:semicolon
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
l_int|256
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * A custom filldir function to search for the specified inode.&n; */
DECL|function|filldir_ino
r_static
r_int
id|filldir_ino
c_func
(paren
r_void
op_star
id|__buf
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
id|off_t
id|pos
comma
id|ino_t
id|ino
)paren
(brace
r_struct
id|nfsd_getdents_callback
op_star
id|buf
op_assign
id|__buf
suffix:semicolon
r_struct
id|nfsd_dirent
op_star
id|dirent
op_assign
id|buf-&gt;dirent
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;checked
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ino
op_eq
id|dirent-&gt;ino
)paren
(brace
id|buf-&gt;found
op_assign
l_int|1
suffix:semicolon
id|dirent-&gt;len
op_assign
id|len
suffix:semicolon
id|memcpy
c_func
(paren
id|dirent-&gt;name
comma
id|name
comma
id|len
)paren
suffix:semicolon
id|dirent-&gt;name
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Search a directory for the specified inode number.&n; */
DECL|function|search_dir
r_static
r_int
id|search_dir
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
id|ino_t
id|ino
comma
r_struct
id|nfsd_dirent
op_star
id|dirent
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|parent-&gt;d_inode
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|file
id|file
suffix:semicolon
r_struct
id|nfsd_getdents_callback
id|buffer
suffix:semicolon
id|error
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
op_logical_or
op_logical_neg
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_op
op_logical_or
op_logical_neg
id|inode-&gt;i_op-&gt;default_file_ops
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Open the directory ...&n;&t; */
id|error
op_assign
id|init_private_file
c_func
(paren
op_amp
id|file
comma
id|parent
comma
id|FMODE_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file.f_op-&gt;readdir
)paren
r_goto
id|out_close
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the callback buffer.&n;&t; */
id|dirent-&gt;ino
op_assign
id|ino
suffix:semicolon
id|buffer.dirent
op_assign
id|dirent
suffix:semicolon
id|buffer.found
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|buffer.checked
op_assign
l_int|0
suffix:semicolon
id|error
op_assign
id|file.f_op
op_member_access_from_pointer
id|readdir
c_func
(paren
op_amp
id|file
comma
op_amp
id|buffer
comma
id|filldir_ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_break
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buffer.found
)paren
(brace
macro_line|#ifdef NFSD_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;search_dir: found %s&bslash;n&quot;
comma
id|dirent-&gt;name
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer.checked
)paren
r_break
suffix:semicolon
)brace
id|out_close
suffix:colon
r_if
c_cond
(paren
id|file.f_op-&gt;release
)paren
id|file.f_op
op_member_access_from_pointer
id|release
c_func
(paren
id|inode
comma
op_amp
id|file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Find an entry in the cache matching the given dentry pointer.&n; */
DECL|function|find_fhe
r_static
r_struct
id|fh_entry
op_star
id|find_fhe
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|cache
comma
r_struct
id|fh_entry
op_star
op_star
id|empty
)paren
(brace
r_struct
id|fh_entry
op_star
id|fhe
suffix:semicolon
r_int
id|i
comma
id|found
op_assign
(paren
id|empty
op_eq
l_int|NULL
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|fhe
op_assign
(paren
id|cache
op_eq
id|NFSD_FILE_CACHE
)paren
ques
c_cond
op_amp
id|filetable
(braket
l_int|0
)braket
suffix:colon
op_amp
id|dirstable
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NFSD_MAXFH
suffix:semicolon
id|i
op_increment
comma
id|fhe
op_increment
)paren
(brace
r_if
c_cond
(paren
id|fhe-&gt;dentry
op_eq
id|dentry
)paren
(brace
id|fhe-&gt;reftime
op_assign
id|jiffies
suffix:semicolon
r_return
id|fhe
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
op_logical_and
op_logical_neg
id|fhe-&gt;dentry
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
op_star
id|empty
op_assign
id|fhe
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Expire a cache entry.&n; */
DECL|function|expire_fhe
r_static
r_void
id|expire_fhe
c_func
(paren
r_struct
id|fh_entry
op_star
id|empty
comma
r_int
id|cache
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|empty-&gt;dentry
suffix:semicolon
macro_line|#ifdef NFSD_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;expire_fhe: expiring %s/%s, d_count=%d, ino=%ld&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_count
comma
id|empty-&gt;ino
)paren
suffix:semicolon
macro_line|#endif
id|empty-&gt;dentry
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* no dentry */
multiline_comment|/*&n;&t; * Add the parent to the dir cache before releasing the dentry.&n;&t; */
r_if
c_cond
(paren
id|dentry
op_ne
id|dentry-&gt;d_parent
)paren
(brace
r_struct
id|dentry
op_star
id|parent
op_assign
id|dget
c_func
(paren
id|dentry-&gt;d_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_to_fhcache
c_func
(paren
id|parent
comma
id|NFSD_DIR_CACHE
)paren
)paren
id|nfsd_nr_verified
op_increment
suffix:semicolon
r_else
id|dput
c_func
(paren
id|parent
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we&squot;re expiring a directory, copy its path.&n;&t; */
r_if
c_cond
(paren
id|cache
op_eq
id|NFSD_DIR_CACHE
)paren
(brace
id|add_to_path_cache
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|nfsd_nr_put
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Look for an empty slot, or select one to expire.&n; */
DECL|function|expire_slot
r_static
r_void
id|expire_slot
c_func
(paren
r_int
id|cache
)paren
(brace
r_struct
id|fh_entry
op_star
id|fhe
comma
op_star
id|empty
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|oldest
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
id|fhe
op_assign
(paren
id|cache
op_eq
id|NFSD_FILE_CACHE
)paren
ques
c_cond
op_amp
id|filetable
(braket
l_int|0
)braket
suffix:colon
op_amp
id|dirstable
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NFSD_MAXFH
suffix:semicolon
id|i
op_increment
comma
id|fhe
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fhe-&gt;dentry
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|fhe-&gt;reftime
OL
id|oldest
)paren
(brace
id|oldest
op_assign
id|fhe-&gt;reftime
suffix:semicolon
id|empty
op_assign
id|fhe
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|empty
)paren
id|expire_fhe
c_func
(paren
id|empty
comma
id|cache
)paren
suffix:semicolon
id|out
suffix:colon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Expire any cache entries older than a certain age.&n; */
DECL|function|expire_old
r_static
r_void
id|expire_old
c_func
(paren
r_int
id|cache
comma
r_int
id|age
)paren
(brace
r_struct
id|fh_entry
op_star
id|fhe
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef NFSD_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;expire_old: expiring %s older than %d&bslash;n&quot;
comma
(paren
id|cache
op_eq
id|NFSD_FILE_CACHE
)paren
ques
c_cond
l_string|&quot;file&quot;
suffix:colon
l_string|&quot;dir&quot;
comma
id|age
)paren
suffix:semicolon
macro_line|#endif
id|fhe
op_assign
(paren
id|cache
op_eq
id|NFSD_FILE_CACHE
)paren
ques
c_cond
op_amp
id|filetable
(braket
l_int|0
)braket
suffix:colon
op_amp
id|dirstable
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NFSD_MAXFH
suffix:semicolon
id|i
op_increment
comma
id|fhe
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fhe-&gt;dentry
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|fhe-&gt;reftime
)paren
OG
id|age
)paren
id|expire_fhe
c_func
(paren
id|fhe
comma
id|cache
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Trim the path cache ...&n;&t; */
r_while
c_loop
(paren
id|nfsd_nr_paths
OG
id|NFSD_MAX_PATHS
)paren
(brace
r_struct
id|nfsd_path
op_star
id|pe
suffix:semicolon
id|pe
op_assign
id|list_entry
c_func
(paren
id|path_inuse.prev
comma
r_struct
id|nfsd_path
comma
id|lru
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pe-&gt;users
)paren
r_break
suffix:semicolon
id|free_path_entry
c_func
(paren
id|pe
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Add a dentry to the file or dir cache.&n; *&n; * Note: As NFS filehandles must have an inode, we don&squot;t accept&n; * negative dentries.&n; */
DECL|function|add_to_fhcache
r_static
r_int
id|add_to_fhcache
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|cache
)paren
(brace
r_struct
id|fh_entry
op_star
id|fhe
comma
op_star
id|empty
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;add_to_fhcache: %s/%s rejected, no inode!&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
id|repeat
suffix:colon
id|fhe
op_assign
id|find_fhe
c_func
(paren
id|dentry
comma
id|cache
comma
op_amp
id|empty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fhe
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Not found ... make a new entry.&n;&t; */
r_if
c_cond
(paren
id|empty
)paren
(brace
id|empty-&gt;dentry
op_assign
id|dentry
suffix:semicolon
id|empty-&gt;reftime
op_assign
id|jiffies
suffix:semicolon
id|empty-&gt;ino
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|empty-&gt;dev
op_assign
id|inode-&gt;i_dev
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|expire_slot
c_func
(paren
id|cache
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/*&n; * Find an entry in the dir cache for the specified inode number.&n; */
DECL|function|find_fhe_by_ino
r_static
r_struct
id|fh_entry
op_star
id|find_fhe_by_ino
c_func
(paren
id|dev_t
id|dev
comma
id|ino_t
id|ino
)paren
(brace
r_struct
id|fh_entry
op_star
id|fhe
op_assign
op_amp
id|dirstable
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NFSD_MAXFH
suffix:semicolon
id|i
op_increment
comma
id|fhe
op_increment
)paren
(brace
r_if
c_cond
(paren
id|fhe-&gt;ino
op_eq
id|ino
op_logical_and
id|fhe-&gt;dev
op_eq
id|dev
)paren
(brace
id|fhe-&gt;reftime
op_assign
id|jiffies
suffix:semicolon
r_return
id|fhe
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the (directory) dentry with the specified (dev, inode) number.&n; * Note: this leaves the dentry in the cache.&n; */
DECL|function|find_dentry_by_ino
r_static
r_struct
id|dentry
op_star
id|find_dentry_by_ino
c_func
(paren
id|dev_t
id|dev
comma
id|ino_t
id|ino
)paren
(brace
r_struct
id|fh_entry
op_star
id|fhe
suffix:semicolon
r_struct
id|nfsd_path
op_star
id|pe
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
macro_line|#ifdef NFSD_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;find_dentry_by_ino: looking for inode %ld&bslash;n&quot;
comma
id|ino
)paren
suffix:semicolon
macro_line|#endif
id|fhe
op_assign
id|find_fhe_by_ino
c_func
(paren
id|dev
comma
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fhe
)paren
(brace
id|dentry
op_assign
id|dget
c_func
(paren
id|fhe-&gt;dentry
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Search the path cache ...&n;&t; */
id|dentry
op_assign
l_int|NULL
suffix:semicolon
id|pe
op_assign
id|get_path_entry
c_func
(paren
id|dev
comma
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pe
)paren
(brace
r_struct
id|dentry
op_star
id|res
suffix:semicolon
id|res
op_assign
id|lookup_dentry
c_func
(paren
id|pe-&gt;name
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|res
)paren
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|res-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_logical_and
id|inode-&gt;i_ino
op_eq
id|ino
op_logical_and
id|inode-&gt;i_dev
op_eq
id|dev
)paren
(brace
id|dentry
op_assign
id|res
suffix:semicolon
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;find_dentry_by_ino: found %s/%s, ino=%ld&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|ino
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|add_to_fhcache
c_func
(paren
id|dentry
comma
id|NFSD_DIR_CACHE
)paren
)paren
(brace
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|nfsd_nr_verified
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
id|dput
c_func
(paren
id|res
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;find_dentry_by_ino: %s lookup failed&bslash;n&quot;
comma
id|pe-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
id|put_path
c_func
(paren
id|pe
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|dentry
suffix:semicolon
)brace
multiline_comment|/*&n; * Look for an entry in the file cache matching the dentry pointer,&n; * and verify that the (dev, inode) numbers are correct. If found,&n; * the entry is removed from the cache.&n; */
DECL|function|find_dentry_in_fhcache
r_static
r_struct
id|dentry
op_star
id|find_dentry_in_fhcache
c_func
(paren
r_struct
id|knfs_fh
op_star
id|fh
)paren
(brace
r_struct
id|fh_entry
op_star
id|fhe
suffix:semicolon
id|fhe
op_assign
id|find_fhe
c_func
(paren
id|fh-&gt;fh_dcookie
comma
id|NFSD_FILE_CACHE
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fhe
)paren
(brace
r_struct
id|dentry
op_star
id|parent
comma
op_star
id|dentry
op_assign
id|fhe-&gt;dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;find_dentry_in_fhcache: %s/%s has no inode!&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inode-&gt;i_ino
op_ne
id|fh-&gt;fh_ino
op_logical_or
id|inode-&gt;i_dev
op_ne
id|fh-&gt;fh_dev
)paren
(brace
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;find_dentry_in_fhcache: %s/%s mismatch, ino=%ld, fh_ino=%ld&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|inode-&gt;i_ino
comma
id|fh-&gt;fh_ino
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|out
suffix:semicolon
)brace
id|fhe-&gt;dentry
op_assign
l_int|NULL
suffix:semicolon
id|fhe-&gt;ino
op_assign
l_int|0
suffix:semicolon
id|fhe-&gt;dev
op_assign
l_int|0
suffix:semicolon
id|nfsd_nr_put
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure the parent is in the dir cache ...&n;&t;&t; */
id|parent
op_assign
id|dget
c_func
(paren
id|dentry-&gt;d_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_to_fhcache
c_func
(paren
id|parent
comma
id|NFSD_DIR_CACHE
)paren
)paren
id|nfsd_nr_verified
op_increment
suffix:semicolon
r_else
id|dput
c_func
(paren
id|parent
)paren
suffix:semicolon
r_return
id|dentry
suffix:semicolon
)brace
id|out
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Look for an entry in the parent directory with the specified&n; * inode number.&n; */
DECL|function|lookup_by_inode
r_static
r_struct
id|dentry
op_star
id|lookup_by_inode
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
id|ino_t
id|ino
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|nfsd_dirent
id|dirent
suffix:semicolon
multiline_comment|/*&n;&t; * Search the directory for the inode number.&n;&t; */
id|error
op_assign
id|search_dir
c_func
(paren
id|parent
comma
id|ino
comma
op_amp
id|dirent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;lookup_by_inode: ino %ld not found in %s&bslash;n&quot;
comma
id|ino
comma
id|parent-&gt;d_name.name
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|no_entry
suffix:semicolon
)brace
id|dentry
op_assign
id|lookup_dentry
c_func
(paren
id|dirent.name
comma
id|dget
c_func
(paren
id|parent
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
(brace
r_if
c_cond
(paren
id|dentry-&gt;d_inode
op_logical_and
id|dentry-&gt;d_inode-&gt;i_ino
op_eq
id|ino
)paren
r_goto
id|out
suffix:semicolon
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;lookup_by_inode: %s/%s inode mismatch??&bslash;n&quot;
comma
id|parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
macro_line|#endif
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;lookup_by_inode: %s lookup failed, error=%ld&bslash;n&quot;
comma
id|dirent.name
comma
id|PTR_ERR
c_func
(paren
id|dentry
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
id|no_entry
suffix:colon
id|dentry
op_assign
l_int|NULL
suffix:semicolon
id|out
suffix:colon
r_return
id|dentry
suffix:semicolon
)brace
multiline_comment|/*&n; * The is the basic lookup mechanism for turning an NFS filehandle &n; * into a dentry. There are several levels to the search:&n; * (1) Look for the dentry pointer the short-term fhcache,&n; *     and verify that it has the correct inode number.&n; *&n; * (2) Try to validate the dentry pointer in the filehandle,&n; *     and verify that it has the correct inode number.&n; *&n; * (3) Search for the parent dentry in the dir cache, and then&n; *     look for the name matching the inode number.&n; *&n; * (4) The most general case ... search the whole volume for the inode.&n; *&n; * If successful, we return a dentry with the use count incremented.&n; */
r_static
r_struct
id|dentry
op_star
DECL|function|find_fh_dentry
id|find_fh_dentry
c_func
(paren
r_struct
id|knfs_fh
op_star
id|fh
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
comma
op_star
id|parent
suffix:semicolon
multiline_comment|/*&n;&t; * Stage 1: Look for the dentry in the short-term fhcache.&n;&t; */
id|dentry
op_assign
id|find_dentry_in_fhcache
c_func
(paren
id|fh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
)paren
(brace
macro_line|#ifdef NFSD_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;find_fh_dentry: found %s/%s, d_count=%d, ino=%ld&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_count
comma
id|fh-&gt;fh_ino
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Stage 2: Attempt to validate the dentry in the filehandle.&n;&t; */
id|dentry
op_assign
id|fh-&gt;fh_dcookie
suffix:semicolon
r_if
c_cond
(paren
id|nfsd_d_validate
c_func
(paren
id|dentry
)paren
)paren
(brace
r_struct
id|inode
op_star
id|dir
op_assign
id|dentry-&gt;d_parent-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;i_ino
op_eq
id|fh-&gt;fh_dirino
op_logical_and
id|dir-&gt;i_dev
op_eq
id|fh-&gt;fh_dev
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * NFS filehandles must always have an inode,&n;&t;&t;&t; * so we won&squot;t accept a negative dentry.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;find_fh_dentry: %s/%s negative, can&squot;t match %ld&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|fh-&gt;fh_ino
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_ino
op_eq
id|fh-&gt;fh_ino
op_logical_and
id|inode-&gt;i_dev
op_eq
id|fh-&gt;fh_dev
)paren
(brace
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
macro_line|#ifdef NFSD_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;find_fh_dentry: validated %s/%s, ino=%ld&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;find_fh_dentry: %s/%s mismatch, ino=%ld, fh_ino=%ld&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|inode-&gt;i_ino
comma
id|fh-&gt;fh_ino
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
(brace
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;find_fh_dentry: %s/%s mismatch, parent ino=%ld, dirino=%ld&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|dir-&gt;i_ino
comma
id|fh-&gt;fh_dirino
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/*&n;&t; * Stage 3: Look for the parent dentry in the fhcache ...&n;&t; */
id|parent
op_assign
id|find_dentry_by_ino
c_func
(paren
id|fh-&gt;fh_dev
comma
id|fh-&gt;fh_dirino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent
)paren
(brace
multiline_comment|/*&n;&t;&t; * ... then search for the inode in the parent directory.&n;&t;&t; */
id|dentry
op_assign
id|lookup_by_inode
c_func
(paren
id|parent
comma
id|fh-&gt;fh_ino
)paren
suffix:semicolon
id|dput
c_func
(paren
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
)paren
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Stage 4: Search the whole volume.&n;&t; */
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;find_fh_dentry: %s, %ld/%ld not found -- need full search!&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|fh-&gt;fh_dev
)paren
comma
id|fh-&gt;fh_dirino
comma
id|fh-&gt;fh_ino
)paren
suffix:semicolon
macro_line|#endif
id|dentry
op_assign
l_int|NULL
suffix:semicolon
id|out
suffix:colon
multiline_comment|/*&n;&t; * Perform any needed housekeeping ...&n;&t; * N.B. move this into one of the daemons ...&n;&t; */
r_if
c_cond
(paren
id|jiffies
op_ge
id|nfsd_next_expire
)paren
(brace
id|expire_old
c_func
(paren
id|NFSD_FILE_CACHE
comma
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
id|expire_old
c_func
(paren
id|NFSD_DIR_CACHE
comma
l_int|60
op_star
id|HZ
)paren
suffix:semicolon
id|nfsd_next_expire
op_assign
id|jiffies
op_plus
l_int|5
op_star
id|HZ
suffix:semicolon
)brace
r_return
id|dentry
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform sanity checks on the dentry in a client&squot;s file handle.&n; *&n; * Note that the filehandle dentry may need to be freed even after&n; * an error return.&n; */
id|u32
DECL|function|fh_verify
id|fh_verify
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_int
id|type
comma
r_int
id|access
)paren
(brace
r_struct
id|svc_export
op_star
id|exp
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|knfs_fh
op_star
id|fh
op_assign
op_amp
id|fhp-&gt;fh_handle
suffix:semicolon
id|u32
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fhp-&gt;fh_dverified
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;nfsd: fh_lookup(exp %x/%ld fh %p)&bslash;n&quot;
comma
id|fh-&gt;fh_xdev
comma
id|fh-&gt;fh_xino
comma
id|fh-&gt;fh_dcookie
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Look up the export entry.&n;&t; * N.B. We need to lock this while in use ...&n;&t; */
id|error
op_assign
id|nfserr_stale
suffix:semicolon
id|exp
op_assign
id|exp_get
c_func
(paren
id|rqstp-&gt;rq_client
comma
id|fh-&gt;fh_xdev
comma
id|fh-&gt;fh_xino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|exp
)paren
multiline_comment|/* export entry revoked */
r_goto
id|out
suffix:semicolon
multiline_comment|/* Check if the request originated from a secure port. */
id|error
op_assign
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rqstp-&gt;rq_secure
op_logical_and
id|EX_SECURE
c_func
(paren
id|exp
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;nfsd: request from insecure port (%08lx:%d)!&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|rqstp-&gt;rq_addr.sin_addr.s_addr
)paren
comma
id|ntohs
c_func
(paren
id|rqstp-&gt;rq_addr.sin_port
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Set user creds if we haven&squot;t done so already. */
id|nfsd_setuser
c_func
(paren
id|rqstp
comma
id|exp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Look up the dentry using the NFS fh.&n;&t; */
id|error
op_assign
id|nfserr_stale
suffix:semicolon
id|dentry
op_assign
id|find_fh_dentry
c_func
(paren
id|fh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Note: it&squot;s possible that the returned dentry won&squot;t be the&n;&t; * one in the filehandle.  We can correct the FH for our use,&n;&t; * but unfortunately the client will keep sending the broken&n;&t; * one.  Hopefully the lookup will keep patching things up..&n;&t; */
id|fhp-&gt;fh_dentry
op_assign
id|dentry
suffix:semicolon
id|fhp-&gt;fh_export
op_assign
id|exp
suffix:semicolon
id|fhp-&gt;fh_dverified
op_assign
l_int|1
suffix:semicolon
id|nfsd_nr_verified
op_increment
suffix:semicolon
multiline_comment|/* Type check. The correct error return for type mismatches&n;&t; * does not seem to be generally agreed upon. SunOS seems to&n;&t; * use EISDIR if file isn&squot;t S_IFREG; a comment in the NFSv3&n;&t; * spec says this is incorrect (implementation notes for the&n;&t; * write call).&n;&t; */
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|type
OG
l_int|0
op_logical_and
(paren
id|inode-&gt;i_mode
op_amp
id|S_IFMT
)paren
op_ne
id|type
)paren
(brace
id|error
op_assign
(paren
id|type
op_eq
id|S_IFDIR
)paren
ques
c_cond
id|nfserr_notdir
suffix:colon
id|nfserr_isdir
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
OL
l_int|0
op_logical_and
(paren
id|inode-&gt;i_mode
op_amp
id|S_IFMT
)paren
op_eq
op_minus
id|type
)paren
(brace
id|error
op_assign
(paren
id|type
op_eq
op_minus
id|S_IFDIR
)paren
ques
c_cond
id|nfserr_notdir
suffix:colon
id|nfserr_isdir
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Finally, check access permissions. */
id|error
op_assign
id|nfsd_permission
c_func
(paren
id|fhp-&gt;fh_export
comma
id|dentry
comma
id|access
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Compose a filehandle for an NFS reply.&n; *&n; * Note that when first composed, the dentry may not yet have&n; * an inode.  In this case a call to fh_update should be made&n; * before the fh goes out on the wire ...&n; */
r_void
DECL|function|fh_compose
id|fh_compose
c_func
(paren
r_struct
id|svc_fh
op_star
id|fhp
comma
r_struct
id|svc_export
op_star
id|exp
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;nfsd: fh_compose(exp %x/%ld dentry %p)&bslash;n&quot;
comma
id|exp-&gt;ex_dev
comma
id|exp-&gt;ex_ino
comma
id|dentry
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * N.B. We shouldn&squot;t need to init the fh -- the call to fh_compose&n;&t; * may not be done on error paths, but the cleanup must call fh_put.&n;&t; * Fix this soon!&n;&t; */
id|fh_init
c_func
(paren
id|fhp
)paren
suffix:semicolon
id|fhp-&gt;fh_handle.fh_dcookie
op_assign
id|dentry
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
id|fhp-&gt;fh_handle.fh_ino
op_assign
id|inode-&gt;i_ino
suffix:semicolon
)brace
id|fhp-&gt;fh_handle.fh_dirino
op_assign
id|dentry-&gt;d_parent-&gt;d_inode-&gt;i_ino
suffix:semicolon
id|fhp-&gt;fh_handle.fh_dev
op_assign
id|dentry-&gt;d_parent-&gt;d_inode-&gt;i_dev
suffix:semicolon
id|fhp-&gt;fh_handle.fh_xdev
op_assign
id|exp-&gt;ex_dev
suffix:semicolon
id|fhp-&gt;fh_handle.fh_xino
op_assign
id|exp-&gt;ex_ino
suffix:semicolon
id|fhp-&gt;fh_dentry
op_assign
id|dentry
suffix:semicolon
multiline_comment|/* our internal copy */
id|fhp-&gt;fh_export
op_assign
id|exp
suffix:semicolon
multiline_comment|/* We stuck it there, we know it&squot;s good. */
id|fhp-&gt;fh_dverified
op_assign
l_int|1
suffix:semicolon
id|nfsd_nr_verified
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Update filehandle information after changing a dentry.&n; */
r_void
DECL|function|fh_update
id|fh_update
c_func
(paren
r_struct
id|svc_fh
op_star
id|fhp
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fhp-&gt;fh_dverified
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fh_update: fh not verified!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fh_update: %s/%s still negative!&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|fhp-&gt;fh_handle.fh_ino
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|out
suffix:colon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Release a filehandle.  If the filehandle carries a dentry count,&n; * we add the dentry to the short-term cache rather than release it.&n; */
r_void
DECL|function|fh_put
id|fh_put
c_func
(paren
r_struct
id|svc_fh
op_star
id|fhp
)paren
(brace
r_if
c_cond
(paren
id|fhp-&gt;fh_dverified
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|fh_unlock
c_func
(paren
id|fhp
)paren
suffix:semicolon
id|fhp-&gt;fh_dverified
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_count
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fh_put: %s/%s has d_count 0!&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_inode
op_logical_or
op_logical_neg
id|add_to_fhcache
c_func
(paren
id|dentry
comma
l_int|0
)paren
)paren
(brace
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|nfsd_nr_put
op_increment
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Verify that the FH dentry is still a valid dentry pointer.&n; * After making some preliminary checks, we ask VFS to verify&n; * that it is indeed a dentry.&n; */
DECL|function|nfsd_d_validate
r_static
r_int
id|nfsd_d_validate
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
r_int
id|dent_addr
op_assign
(paren
r_int
r_int
)paren
id|dentry
suffix:semicolon
r_int
r_int
id|min_addr
op_assign
id|PAGE_OFFSET
suffix:semicolon
r_int
r_int
id|max_addr
op_assign
id|min_addr
op_plus
(paren
id|num_physpages
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
r_int
r_int
id|align_mask
op_assign
l_int|0x1F
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_int
id|valid
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dent_addr
OL
id|min_addr
)paren
r_goto
id|bad_addr
suffix:semicolon
r_if
c_cond
(paren
id|dent_addr
OG
id|max_addr
op_minus
r_sizeof
(paren
r_struct
id|dentry
)paren
)paren
r_goto
id|bad_addr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dent_addr
op_amp
op_complement
id|align_mask
)paren
op_ne
id|dent_addr
)paren
r_goto
id|bad_addr
suffix:semicolon
multiline_comment|/*&n;&t; * Looks safe enough to dereference ...&n;&t; */
id|len
op_assign
id|dentry-&gt;d_name.len
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|NFS_MAXNAMLEN
)paren
r_goto
id|bad_length
suffix:semicolon
id|valid
op_assign
id|d_validate
c_func
(paren
id|dentry
comma
id|dentry-&gt;d_parent
comma
id|dentry-&gt;d_name.hash
comma
id|len
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|valid
suffix:semicolon
id|bad_addr
suffix:colon
id|printk
c_func
(paren
l_string|&quot;nfsd_d_validate: invalid address %lx&bslash;n&quot;
comma
id|dent_addr
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_length
suffix:colon
id|printk
c_func
(paren
l_string|&quot;nfsd_d_validate: invalid length %d&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Free the dentry and path caches.&n; */
DECL|function|nfsd_fh_free
r_void
id|nfsd_fh_free
c_func
(paren
r_void
)paren
(brace
r_struct
id|fh_entry
op_star
id|fhe
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_int
id|i
comma
id|pass
op_assign
l_int|2
suffix:semicolon
id|fhe
op_assign
op_amp
id|filetable
(braket
l_int|0
)braket
suffix:semicolon
r_while
c_loop
(paren
id|pass
op_decrement
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NFSD_MAXFH
suffix:semicolon
id|i
op_increment
comma
id|fhe
op_increment
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|fhe-&gt;dentry
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_continue
suffix:semicolon
id|fhe-&gt;dentry
op_assign
l_int|NULL
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|nfsd_nr_put
op_increment
suffix:semicolon
)brace
id|fhe
op_assign
op_amp
id|dirstable
(braket
l_int|0
)braket
suffix:semicolon
)brace
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|path_inuse.next
)paren
op_ne
op_amp
id|path_inuse
)paren
(brace
r_struct
id|nfsd_path
op_star
id|pe
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|nfsd_path
comma
id|lru
)paren
suffix:semicolon
id|free_path_entry
c_func
(paren
id|pe
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;nfsd_fh_free: %d paths freed&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;nfsd_fh_free: verified %d, put %d&bslash;n&quot;
comma
id|nfsd_nr_verified
comma
id|nfsd_nr_put
)paren
suffix:semicolon
)brace
r_void
DECL|function|nfsd_fh_init
id|nfsd_fh_init
c_func
(paren
r_void
)paren
(brace
id|memset
c_func
(paren
id|filetable
comma
l_int|0
comma
id|NFSD_MAXFH
op_star
r_sizeof
(paren
r_struct
id|fh_entry
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dirstable
comma
l_int|0
comma
id|NFSD_MAXFH
op_star
r_sizeof
(paren
r_struct
id|fh_entry
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|path_inuse
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;nfsd_init: initialized fhcache, entries=%lu&bslash;n&quot;
comma
id|NFSD_MAXFH
)paren
suffix:semicolon
)brace
eof
