multiline_comment|/*&n; * linux/fs/nfsd/nfsfh.c&n; *&n; * NFS server file handle treatment.&n; *&n; * Copyright (C) 1995, 1996 Olaf Kirch &lt;okir@monad.swb.de&gt;&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/dcache.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;linux/sunrpc/svc.h&gt;
macro_line|#include &lt;linux/nfsd/nfsd.h&gt;
DECL|macro|NFSDDBG_FACILITY
mdefine_line|#define NFSDDBG_FACILITY&t;&t;NFSDDBG_FH
DECL|macro|NFSD_PARANOIA
mdefine_line|#define NFSD_PARANOIA 1
multiline_comment|/* #define NFSD_DEBUG_VERBOSE 1 */
r_extern
r_int
r_int
id|max_mapnr
suffix:semicolon
DECL|macro|NFSD_FILE_CACHE
mdefine_line|#define NFSD_FILE_CACHE 0
DECL|macro|NFSD_DIR_CACHE
mdefine_line|#define NFSD_DIR_CACHE  1
DECL|struct|fh_entry
r_struct
id|fh_entry
(brace
DECL|member|dentry
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
DECL|member|reftime
r_int
r_int
id|reftime
suffix:semicolon
DECL|member|ino
id|ino_t
id|ino
suffix:semicolon
DECL|member|dev
id|kdev_t
id|dev
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|NFSD_MAXFH
mdefine_line|#define NFSD_MAXFH PAGE_SIZE/sizeof(struct fh_entry)
DECL|variable|filetable
r_static
r_struct
id|fh_entry
id|filetable
(braket
id|NFSD_MAXFH
)braket
suffix:semicolon
DECL|variable|dirstable
r_static
r_struct
id|fh_entry
id|dirstable
(braket
id|NFSD_MAXFH
)braket
suffix:semicolon
DECL|variable|nfsd_nr_verified
r_static
r_int
id|nfsd_nr_verified
op_assign
l_int|0
suffix:semicolon
DECL|variable|nfsd_nr_put
r_static
r_int
id|nfsd_nr_put
op_assign
l_int|0
suffix:semicolon
DECL|variable|nfsd_next_expire
r_static
r_int
r_int
id|nfsd_next_expire
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|add_to_fhcache
c_func
(paren
r_struct
id|dentry
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|nfsd_d_validate
c_func
(paren
r_struct
id|dentry
op_star
)paren
suffix:semicolon
r_struct
id|dentry
op_star
id|lookup_inode
c_func
(paren
id|kdev_t
comma
id|ino_t
comma
id|ino_t
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|fixup_head
)paren
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|path_inuse
)paren
suffix:semicolon
DECL|variable|nfsd_nr_fixups
r_static
r_int
id|nfsd_nr_fixups
op_assign
l_int|0
suffix:semicolon
DECL|variable|nfsd_nr_paths
r_static
r_int
id|nfsd_nr_paths
op_assign
l_int|0
suffix:semicolon
DECL|macro|NFSD_MAX_PATHS
mdefine_line|#define NFSD_MAX_PATHS 500
DECL|macro|NFSD_MAX_FIXUPAGE
mdefine_line|#define NFSD_MAX_FIXUPAGE 60*HZ
DECL|struct|nfsd_fixup
r_struct
id|nfsd_fixup
(brace
DECL|member|lru
r_struct
id|list_head
id|lru
suffix:semicolon
DECL|member|dir
id|ino_t
id|dir
suffix:semicolon
DECL|member|ino
id|ino_t
id|ino
suffix:semicolon
DECL|member|dev
id|kdev_t
id|dev
suffix:semicolon
DECL|member|dentry
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
DECL|member|reftime
r_int
r_int
id|reftime
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|nfsd_path
r_struct
id|nfsd_path
(brace
DECL|member|lru
r_struct
id|list_head
id|lru
suffix:semicolon
DECL|member|reftime
r_int
r_int
id|reftime
suffix:semicolon
DECL|member|users
r_int
id|users
suffix:semicolon
DECL|member|ino
id|ino_t
id|ino
suffix:semicolon
DECL|member|dev
id|kdev_t
id|dev
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
l_int|1
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|function|find_cached_lookup
r_static
r_struct
id|nfsd_fixup
op_star
id|find_cached_lookup
c_func
(paren
id|kdev_t
id|dev
comma
id|ino_t
id|dir
comma
id|ino_t
id|ino
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
op_assign
id|fixup_head.next
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|tmp
op_ne
op_amp
id|fixup_head
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
(brace
r_struct
id|nfsd_fixup
op_star
id|fp
suffix:semicolon
id|fp
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|nfsd_fixup
comma
id|lru
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fp-&gt;ino
op_ne
id|ino
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|fp-&gt;dir
op_ne
id|dir
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|fp-&gt;dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
id|list_del
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|list_add
c_func
(paren
id|tmp
comma
op_amp
id|fixup_head
)paren
suffix:semicolon
id|fp-&gt;reftime
op_assign
id|jiffies
suffix:semicolon
r_return
id|fp
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Save the dentry pointer from a successful lookup.&n; */
DECL|function|add_to_lookup_cache
r_static
r_void
id|add_to_lookup_cache
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|knfs_fh
op_star
id|fh
)paren
(brace
r_struct
id|nfsd_fixup
op_star
id|fp
suffix:semicolon
id|fp
op_assign
id|find_cached_lookup
c_func
(paren
id|u32_to_kdev_t
c_func
(paren
id|fh-&gt;fh_dev
)paren
comma
id|u32_to_ino_t
c_func
(paren
id|fh-&gt;fh_dirino
)paren
comma
id|u32_to_ino_t
c_func
(paren
id|fh-&gt;fh_ino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fp
)paren
(brace
id|fp-&gt;dentry
op_assign
id|dentry
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Add a new entry. The small race here is unimportant:&n;&t; * if another task adds the same lookup, both entries&n;&t; * will be consistent.&n;&t; */
id|fp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|nfsd_fixup
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fp
)paren
(brace
id|fp-&gt;dir
op_assign
id|u32_to_kdev_t
c_func
(paren
id|fh-&gt;fh_dirino
)paren
suffix:semicolon
id|fp-&gt;ino
op_assign
id|u32_to_ino_t
c_func
(paren
id|fh-&gt;fh_ino
)paren
suffix:semicolon
id|fp-&gt;dev
op_assign
id|u32_to_ino_t
c_func
(paren
id|fh-&gt;fh_dev
)paren
suffix:semicolon
id|fp-&gt;dentry
op_assign
id|dentry
suffix:semicolon
id|fp-&gt;reftime
op_assign
id|jiffies
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|fp-&gt;lru
comma
op_amp
id|fixup_head
)paren
suffix:semicolon
id|nfsd_nr_fixups
op_increment
suffix:semicolon
)brace
)brace
DECL|function|free_fixup_entry
r_static
r_void
id|free_fixup_entry
c_func
(paren
r_struct
id|nfsd_fixup
op_star
id|fp
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|fp-&gt;lru
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fp
)paren
suffix:semicolon
id|nfsd_nr_fixups
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy a dentry&squot;s path into the specified buffer.&n; */
DECL|function|copy_path
r_static
r_int
id|copy_path
c_func
(paren
r_char
op_star
id|buffer
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|namelen
)paren
(brace
r_char
op_star
id|p
comma
op_star
id|b
op_assign
id|buffer
suffix:semicolon
r_int
id|result
op_assign
l_int|0
comma
id|totlen
op_assign
l_int|0
comma
id|len
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|dentry
op_star
id|parent
suffix:semicolon
id|dentry
op_assign
id|dentry-&gt;d_covers
suffix:semicolon
id|parent
op_assign
id|dentry-&gt;d_parent
suffix:semicolon
id|len
op_assign
id|dentry-&gt;d_name.len
suffix:semicolon
id|p
op_assign
(paren
r_char
op_star
)paren
id|dentry-&gt;d_name.name
op_plus
id|len
suffix:semicolon
id|totlen
op_add_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|totlen
OG
id|namelen
)paren
r_goto
id|out
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
op_star
id|b
op_increment
op_assign
op_star
(paren
op_decrement
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
op_eq
id|parent
)paren
r_break
suffix:semicolon
id|dentry
op_assign
id|parent
suffix:semicolon
id|totlen
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|totlen
OG
id|namelen
)paren
r_goto
id|out
suffix:semicolon
op_star
id|b
op_increment
op_assign
l_char|&squot;/&squot;
suffix:semicolon
)brace
op_star
id|b
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Now reverse in place ...&n;&t; */
id|p
op_assign
id|buffer
suffix:semicolon
r_while
c_loop
(paren
id|p
OL
id|b
)paren
(brace
r_char
id|c
op_assign
op_star
(paren
op_decrement
id|b
)paren
suffix:semicolon
op_star
id|b
op_assign
op_star
id|p
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|c
suffix:semicolon
)brace
id|result
op_assign
l_int|1
suffix:semicolon
id|out
suffix:colon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a dentry&squot;s path to the path cache.&n; */
DECL|function|add_to_path_cache
r_static
r_int
id|add_to_path_cache
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_struct
id|dentry
op_star
id|this
suffix:semicolon
r_struct
id|nfsd_path
op_star
r_new
suffix:semicolon
r_int
id|len
comma
id|result
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef NFSD_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;add_to_path_cache: caching %s/%s&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Get the length of the full pathname.&n;&t; */
id|restart
suffix:colon
id|len
op_assign
l_int|0
suffix:semicolon
id|this
op_assign
id|dentry
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|dentry
op_star
id|parent
suffix:semicolon
id|this
op_assign
id|this-&gt;d_covers
suffix:semicolon
id|parent
op_assign
id|this-&gt;d_parent
suffix:semicolon
id|len
op_add_assign
id|this-&gt;d_name.len
suffix:semicolon
r_if
c_cond
(paren
id|this
op_eq
id|parent
)paren
r_break
suffix:semicolon
id|this
op_assign
id|parent
suffix:semicolon
id|len
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocate a structure to hold the path.&n;&t; */
r_new
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|nfsd_path
)paren
op_plus
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
)paren
(brace
r_new
op_member_access_from_pointer
id|users
op_assign
l_int|0
suffix:semicolon
r_new
op_member_access_from_pointer
id|reftime
op_assign
id|jiffies
suffix:semicolon
r_new
op_member_access_from_pointer
id|ino
op_assign
id|inode-&gt;i_ino
suffix:semicolon
r_new
op_member_access_from_pointer
id|dev
op_assign
id|inode-&gt;i_dev
suffix:semicolon
id|result
op_assign
id|copy_path
c_func
(paren
r_new
op_member_access_from_pointer
id|name
comma
id|dentry
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
r_goto
id|retry
suffix:semicolon
id|list_add
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|lru
comma
op_amp
id|path_inuse
)paren
suffix:semicolon
id|nfsd_nr_paths
op_increment
suffix:semicolon
macro_line|#ifdef NFSD_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;add_to_path_cache: added %s, paths=%d&bslash;n&quot;
comma
r_new
op_member_access_from_pointer
id|name
comma
id|nfsd_nr_paths
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
id|result
suffix:semicolon
multiline_comment|/*&n;&t; * If the dentry&squot;s path length changed, just try again.&n;&t; */
id|retry
suffix:colon
id|kfree
c_func
(paren
r_new
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;add_to_path_cache: path length changed, retrying&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
multiline_comment|/*&n; * Search for a path entry for the specified (dev, inode).&n; */
DECL|function|get_path_entry
r_static
r_struct
id|nfsd_path
op_star
id|get_path_entry
c_func
(paren
id|kdev_t
id|dev
comma
id|ino_t
id|ino
)paren
(brace
r_struct
id|nfsd_path
op_star
id|pe
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|path_inuse.next
suffix:semicolon
id|tmp
op_ne
op_amp
id|path_inuse
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
(brace
id|pe
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|nfsd_path
comma
id|lru
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pe-&gt;ino
op_ne
id|ino
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pe-&gt;dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
id|list_del
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|list_add
c_func
(paren
id|tmp
comma
op_amp
id|path_inuse
)paren
suffix:semicolon
id|pe-&gt;users
op_increment
suffix:semicolon
id|pe-&gt;reftime
op_assign
id|jiffies
suffix:semicolon
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;get_path_entry: found %s for %s/%ld&bslash;n&quot;
comma
id|pe-&gt;name
comma
id|kdevname
c_func
(paren
id|dev
)paren
comma
id|ino
)paren
suffix:semicolon
macro_line|#endif
r_return
id|pe
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|put_path
r_static
r_void
id|put_path
c_func
(paren
r_struct
id|nfsd_path
op_star
id|pe
)paren
(brace
id|pe-&gt;users
op_decrement
suffix:semicolon
)brace
DECL|function|free_path_entry
r_static
r_void
id|free_path_entry
c_func
(paren
r_struct
id|nfsd_path
op_star
id|pe
)paren
(brace
r_if
c_cond
(paren
id|pe-&gt;users
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;free_path_entry: %s in use, users=%d&bslash;n&quot;
comma
id|pe-&gt;name
comma
id|pe-&gt;users
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|pe-&gt;lru
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|pe
)paren
suffix:semicolon
id|nfsd_nr_paths
op_decrement
suffix:semicolon
)brace
DECL|struct|nfsd_getdents_callback
r_struct
id|nfsd_getdents_callback
(brace
DECL|member|dirent
r_struct
id|nfsd_dirent
op_star
id|dirent
suffix:semicolon
DECL|member|dirino
id|ino_t
id|dirino
suffix:semicolon
multiline_comment|/* parent inode number */
DECL|member|found
r_int
id|found
suffix:semicolon
multiline_comment|/* dirent inode matched? */
DECL|member|sequence
r_int
id|sequence
suffix:semicolon
multiline_comment|/* sequence counter */
)brace
suffix:semicolon
DECL|struct|nfsd_dirent
r_struct
id|nfsd_dirent
(brace
DECL|member|ino
id|ino_t
id|ino
suffix:semicolon
multiline_comment|/* preset to desired entry */
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
l_int|256
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * A rather strange filldir function to capture the inode number&n; * for the second entry (the parent inode) and the name matching&n; * the specified inode number.&n; */
DECL|function|filldir_one
r_static
r_int
id|filldir_one
c_func
(paren
r_void
op_star
id|__buf
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
id|off_t
id|pos
comma
id|ino_t
id|ino
)paren
(brace
r_struct
id|nfsd_getdents_callback
op_star
id|buf
op_assign
id|__buf
suffix:semicolon
r_struct
id|nfsd_dirent
op_star
id|dirent
op_assign
id|buf-&gt;dirent
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;sequence
op_increment
suffix:semicolon
macro_line|#ifdef NFSD_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;filldir_one: seq=%d, ino=%ld, name=%s&bslash;n&quot;
comma
id|buf-&gt;sequence
comma
id|ino
comma
id|name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|buf-&gt;sequence
op_eq
l_int|2
)paren
(brace
id|buf-&gt;dirino
op_assign
id|ino
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dirent-&gt;ino
op_eq
id|ino
)paren
(brace
id|dirent-&gt;len
op_assign
id|len
suffix:semicolon
id|memcpy
c_func
(paren
id|dirent-&gt;name
comma
id|name
comma
id|len
)paren
suffix:semicolon
id|dirent-&gt;name
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;found
op_assign
l_int|1
suffix:semicolon
id|result
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Read a directory and return the parent inode number and the name&n; * of the specified entry. The dirent must be initialized with the&n; * inode number of the desired entry.&n; */
DECL|function|get_parent_ino
r_static
r_int
id|get_parent_ino
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|nfsd_dirent
op_star
id|dirent
)paren
(brace
r_struct
id|inode
op_star
id|dir
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|file
id|file
suffix:semicolon
r_struct
id|nfsd_getdents_callback
id|buffer
suffix:semicolon
id|error
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
op_logical_or
op_logical_neg
id|S_ISDIR
c_func
(paren
id|dir-&gt;i_mode
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;default_file_ops
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Open the directory ...&n;&t; */
id|error
op_assign
id|init_private_file
c_func
(paren
op_amp
id|file
comma
id|dentry
comma
id|FMODE_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file.f_op-&gt;readdir
)paren
r_goto
id|out_close
suffix:semicolon
id|buffer.dirent
op_assign
id|dirent
suffix:semicolon
id|buffer.dirino
op_assign
l_int|0
suffix:semicolon
id|buffer.found
op_assign
l_int|0
suffix:semicolon
id|buffer.sequence
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|old_seq
op_assign
id|buffer.sequence
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
id|error
op_assign
id|file.f_op
op_member_access_from_pointer
id|readdir
c_func
(paren
op_amp
id|file
comma
op_amp
id|buffer
comma
id|filldir_one
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_break
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buffer.found
)paren
r_break
suffix:semicolon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|old_seq
op_eq
id|buffer.sequence
)paren
r_break
suffix:semicolon
)brace
id|dirent-&gt;ino
op_assign
id|buffer.dirino
suffix:semicolon
id|out_close
suffix:colon
r_if
c_cond
(paren
id|file.f_op-&gt;release
)paren
id|file.f_op
op_member_access_from_pointer
id|release
c_func
(paren
id|dir
comma
op_amp
id|file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up a dentry given inode and parent inode numbers.&n; *&n; * This relies on the ability of a Unix-like filesystem to return&n; * the parent inode of a directory as the &quot;..&quot; (second) entry.&n; *&n; * This could be further optimized if we had an efficient way of&n; * searching for a dentry given the inode: as we walk up the tree,&n; * it&squot;s likely that a dentry exists before we reach the root.&n; */
DECL|function|lookup_inode
r_struct
id|dentry
op_star
id|lookup_inode
c_func
(paren
id|kdev_t
id|dev
comma
id|ino_t
id|dirino
comma
id|ino_t
id|ino
)paren
(brace
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
r_struct
id|dentry
op_star
id|root
comma
op_star
id|dentry
comma
op_star
id|result
suffix:semicolon
r_struct
id|inode
op_star
id|dir
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_int
r_int
id|page
suffix:semicolon
id|ino_t
id|root_ino
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|nfsd_dirent
id|dirent
suffix:semicolon
id|result
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|page
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Get the root dentry for the device.&n;&t; */
id|result
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOENT
)paren
suffix:semicolon
id|sb
op_assign
id|get_super
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb
)paren
r_goto
id|out_page
suffix:semicolon
id|result
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOSYS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb-&gt;s_op-&gt;read_inode
)paren
multiline_comment|/* No working iget(), e.g. FAT */
r_goto
id|out_page
suffix:semicolon
id|root
op_assign
id|dget
c_func
(paren
id|sb-&gt;s_root
)paren
suffix:semicolon
id|root_ino
op_assign
id|root-&gt;d_inode-&gt;i_ino
suffix:semicolon
multiline_comment|/* usually 2 */
id|name
op_assign
(paren
r_char
op_star
)paren
id|page
op_plus
id|PAGE_SIZE
suffix:semicolon
op_star
(paren
op_decrement
id|name
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Walk up the tree to construct the name string.&n;&t; * When we reach the root inode, look up the name&n;&t; * relative to the root dentry.&n;&t; */
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|ino
op_eq
id|root_ino
)paren
(brace
r_if
c_cond
(paren
op_star
id|name
op_eq
l_char|&squot;/&squot;
)paren
id|name
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Note: this dput()s the root dentry.&n;&t;&t;&t; */
id|result
op_assign
id|lookup_dentry
c_func
(paren
id|name
comma
id|root
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|result
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOENT
)paren
suffix:semicolon
id|dir
op_assign
id|iget
c_func
(paren
id|sb
comma
id|dirino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
r_goto
id|out_root
suffix:semicolon
id|dentry
op_assign
id|d_alloc_root
c_func
(paren
id|dir
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_goto
id|out_iput
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get the name for this inode and the next parent inode.&n;&t;&t; */
id|dirent.ino
op_assign
id|ino
suffix:semicolon
id|error
op_assign
id|get_parent_ino
c_func
(paren
id|dentry
comma
op_amp
id|dirent
)paren
suffix:semicolon
id|result
op_assign
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out_root
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Prepend the name to the buffer.&n;&t;&t; */
id|result
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENAMETOOLONG
)paren
suffix:semicolon
id|name
op_sub_assign
(paren
id|dirent.len
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|name
op_le
id|page
)paren
r_goto
id|out_root
suffix:semicolon
id|memcpy
c_func
(paren
id|name
op_plus
l_int|1
comma
id|dirent.name
comma
id|dirent.len
)paren
suffix:semicolon
op_star
id|name
op_assign
l_char|&squot;/&squot;
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure we can&squot;t get caught in a loop ...&n;&t;&t; */
r_if
c_cond
(paren
id|dirino
op_eq
id|dirent.ino
op_logical_and
id|dirino
op_ne
id|root_ino
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;lookup_inode: looping?? (ino=%ld, path=%s)&bslash;n&quot;
comma
id|dirino
comma
id|name
)paren
suffix:semicolon
r_goto
id|out_root
suffix:semicolon
)brace
id|ino
op_assign
id|dirino
suffix:semicolon
id|dirino
op_assign
id|dirent.ino
suffix:semicolon
)brace
id|out_page
suffix:colon
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|result
suffix:semicolon
multiline_comment|/*&n;&t; * Error exits ...&n;&t; */
id|out_iput
suffix:colon
id|result
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|iput
c_func
(paren
id|dir
)paren
suffix:semicolon
id|out_root
suffix:colon
id|dput
c_func
(paren
id|root
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Find an entry in the cache matching the given dentry pointer.&n; */
DECL|function|find_fhe
r_static
r_struct
id|fh_entry
op_star
id|find_fhe
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|cache
comma
r_struct
id|fh_entry
op_star
op_star
id|empty
)paren
(brace
r_struct
id|fh_entry
op_star
id|fhe
suffix:semicolon
r_int
id|i
comma
id|found
op_assign
(paren
id|empty
op_eq
l_int|NULL
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_goto
id|out
suffix:semicolon
id|fhe
op_assign
(paren
id|cache
op_eq
id|NFSD_FILE_CACHE
)paren
ques
c_cond
op_amp
id|filetable
(braket
l_int|0
)braket
suffix:colon
op_amp
id|dirstable
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NFSD_MAXFH
suffix:semicolon
id|i
op_increment
comma
id|fhe
op_increment
)paren
(brace
r_if
c_cond
(paren
id|fhe-&gt;dentry
op_eq
id|dentry
)paren
(brace
id|fhe-&gt;reftime
op_assign
id|jiffies
suffix:semicolon
r_return
id|fhe
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|found
op_logical_and
op_logical_neg
id|fhe-&gt;dentry
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
op_star
id|empty
op_assign
id|fhe
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Expire a cache entry.&n; */
DECL|function|expire_fhe
r_static
r_void
id|expire_fhe
c_func
(paren
r_struct
id|fh_entry
op_star
id|empty
comma
r_int
id|cache
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|empty-&gt;dentry
suffix:semicolon
macro_line|#ifdef NFSD_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;expire_fhe: expiring %s/%s, d_count=%d, ino=%ld&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_count
comma
id|empty-&gt;ino
)paren
suffix:semicolon
macro_line|#endif
id|empty-&gt;dentry
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* no dentry */
multiline_comment|/*&n;&t; * Add the parent to the dir cache before releasing the dentry,&n;&t; * and check whether to save a copy of the dentry&squot;s path.&n;&t; */
r_if
c_cond
(paren
id|dentry
op_ne
id|dentry-&gt;d_parent
)paren
(brace
r_struct
id|dentry
op_star
id|parent
op_assign
id|dget
c_func
(paren
id|dentry-&gt;d_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_to_fhcache
c_func
(paren
id|parent
comma
id|NFSD_DIR_CACHE
)paren
)paren
id|nfsd_nr_verified
op_increment
suffix:semicolon
r_else
id|dput
c_func
(paren
id|parent
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we&squot;re expiring a directory, copy its path.&n;&t;&t; */
r_if
c_cond
(paren
id|cache
op_eq
id|NFSD_DIR_CACHE
)paren
(brace
id|add_to_path_cache
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
)brace
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|nfsd_nr_put
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Look for an empty slot, or select one to expire.&n; */
DECL|function|expire_slot
r_static
r_void
id|expire_slot
c_func
(paren
r_int
id|cache
)paren
(brace
r_struct
id|fh_entry
op_star
id|fhe
comma
op_star
id|empty
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|oldest
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
id|fhe
op_assign
(paren
id|cache
op_eq
id|NFSD_FILE_CACHE
)paren
ques
c_cond
op_amp
id|filetable
(braket
l_int|0
)braket
suffix:colon
op_amp
id|dirstable
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NFSD_MAXFH
suffix:semicolon
id|i
op_increment
comma
id|fhe
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fhe-&gt;dentry
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|fhe-&gt;reftime
OL
id|oldest
)paren
(brace
id|oldest
op_assign
id|fhe-&gt;reftime
suffix:semicolon
id|empty
op_assign
id|fhe
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|empty
)paren
id|expire_fhe
c_func
(paren
id|empty
comma
id|cache
)paren
suffix:semicolon
id|out
suffix:colon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Expire any cache entries older than a certain age.&n; */
DECL|function|expire_old
r_static
r_void
id|expire_old
c_func
(paren
r_int
id|cache
comma
r_int
id|age
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_struct
id|fh_entry
op_star
id|fhe
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef NFSD_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;expire_old: expiring %s older than %d&bslash;n&quot;
comma
(paren
id|cache
op_eq
id|NFSD_FILE_CACHE
)paren
ques
c_cond
l_string|&quot;file&quot;
suffix:colon
l_string|&quot;dir&quot;
comma
id|age
)paren
suffix:semicolon
macro_line|#endif
id|fhe
op_assign
(paren
id|cache
op_eq
id|NFSD_FILE_CACHE
)paren
ques
c_cond
op_amp
id|filetable
(braket
l_int|0
)braket
suffix:colon
op_amp
id|dirstable
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NFSD_MAXFH
suffix:semicolon
id|i
op_increment
comma
id|fhe
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fhe-&gt;dentry
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|fhe-&gt;reftime
)paren
OG
id|age
)paren
id|expire_fhe
c_func
(paren
id|fhe
comma
id|cache
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Remove old entries from the patch-up cache.&n;&t; */
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|fixup_head.prev
)paren
op_ne
op_amp
id|fixup_head
)paren
(brace
r_struct
id|nfsd_fixup
op_star
id|fp
suffix:semicolon
id|fp
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|nfsd_fixup
comma
id|lru
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|fp-&gt;reftime
)paren
OL
id|NFSD_MAX_FIXUPAGE
)paren
r_break
suffix:semicolon
id|free_fixup_entry
c_func
(paren
id|fp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Trim the path cache ...&n;&t; */
r_while
c_loop
(paren
id|nfsd_nr_paths
OG
id|NFSD_MAX_PATHS
)paren
(brace
r_struct
id|nfsd_path
op_star
id|pe
suffix:semicolon
id|pe
op_assign
id|list_entry
c_func
(paren
id|path_inuse.prev
comma
r_struct
id|nfsd_path
comma
id|lru
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pe-&gt;users
)paren
r_break
suffix:semicolon
id|free_path_entry
c_func
(paren
id|pe
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Add a dentry to the file or dir cache.&n; *&n; * Note: As NFS file handles must have an inode, we don&squot;t accept&n; * negative dentries.&n; */
DECL|function|add_to_fhcache
r_static
r_int
id|add_to_fhcache
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|cache
)paren
(brace
r_struct
id|fh_entry
op_star
id|fhe
comma
op_star
id|empty
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;add_to_fhcache: %s/%s rejected, no inode!&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
id|repeat
suffix:colon
id|fhe
op_assign
id|find_fhe
c_func
(paren
id|dentry
comma
id|cache
comma
op_amp
id|empty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fhe
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Not found ... make a new entry.&n;&t; */
r_if
c_cond
(paren
id|empty
)paren
(brace
id|empty-&gt;dentry
op_assign
id|dentry
suffix:semicolon
id|empty-&gt;reftime
op_assign
id|jiffies
suffix:semicolon
id|empty-&gt;ino
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|empty-&gt;dev
op_assign
id|inode-&gt;i_dev
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|expire_slot
c_func
(paren
id|cache
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/*&n; * Find an entry in the dir cache for the specified inode number.&n; */
DECL|function|find_fhe_by_ino
r_static
r_struct
id|fh_entry
op_star
id|find_fhe_by_ino
c_func
(paren
id|kdev_t
id|dev
comma
id|ino_t
id|ino
)paren
(brace
r_struct
id|fh_entry
op_star
id|fhe
op_assign
op_amp
id|dirstable
(braket
l_int|0
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NFSD_MAXFH
suffix:semicolon
id|i
op_increment
comma
id|fhe
op_increment
)paren
(brace
r_if
c_cond
(paren
id|fhe-&gt;ino
op_eq
id|ino
op_logical_and
id|fhe-&gt;dev
op_eq
id|dev
)paren
(brace
id|fhe-&gt;reftime
op_assign
id|jiffies
suffix:semicolon
r_return
id|fhe
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the (directory) dentry with the specified (dev, inode) number.&n; * Note: this leaves the dentry in the cache.&n; */
DECL|function|find_dentry_by_ino
r_static
r_struct
id|dentry
op_star
id|find_dentry_by_ino
c_func
(paren
id|kdev_t
id|dev
comma
id|ino_t
id|ino
)paren
(brace
r_struct
id|fh_entry
op_star
id|fhe
suffix:semicolon
r_struct
id|nfsd_path
op_star
id|pe
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
macro_line|#ifdef NFSD_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;find_dentry_by_ino: looking for inode %ld&bslash;n&quot;
comma
id|ino
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Special case: inode number 2 is the root inode,&n;&t; * so we can use the root dentry for the device.&n;&t; */
r_if
c_cond
(paren
id|ino
op_eq
l_int|2
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|get_super
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb
)paren
(brace
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;find_dentry_by_ino: getting root dentry for %s&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|sb-&gt;s_root
)paren
(brace
id|dentry
op_assign
id|dget
c_func
(paren
id|sb-&gt;s_root
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;find_dentry_by_ino: %s has no root??&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Search the dentry cache ...&n;&t; */
id|fhe
op_assign
id|find_fhe_by_ino
c_func
(paren
id|dev
comma
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fhe
)paren
(brace
id|dentry
op_assign
id|dget
c_func
(paren
id|fhe-&gt;dentry
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Search the path cache ...&n;&t; */
id|dentry
op_assign
l_int|NULL
suffix:semicolon
id|pe
op_assign
id|get_path_entry
c_func
(paren
id|dev
comma
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pe
)paren
(brace
r_struct
id|dentry
op_star
id|res
suffix:semicolon
id|res
op_assign
id|lookup_dentry
c_func
(paren
id|pe-&gt;name
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|res
)paren
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|res-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_logical_and
id|inode-&gt;i_ino
op_eq
id|ino
op_logical_and
id|inode-&gt;i_dev
op_eq
id|dev
)paren
(brace
id|dentry
op_assign
id|res
suffix:semicolon
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;find_dentry_by_ino: found %s/%s, ino=%ld&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|ino
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|add_to_fhcache
c_func
(paren
id|dentry
comma
id|NFSD_DIR_CACHE
)paren
)paren
(brace
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|nfsd_nr_verified
op_increment
suffix:semicolon
)brace
)brace
r_else
(brace
id|dput
c_func
(paren
id|res
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;find_dentry_by_ino: %s lookup failed&bslash;n&quot;
comma
id|pe-&gt;name
)paren
suffix:semicolon
macro_line|#endif
)brace
id|put_path
c_func
(paren
id|pe
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|dentry
suffix:semicolon
)brace
multiline_comment|/*&n; * Look for an entry in the file cache matching the dentry pointer,&n; * and verify that the (dev, inode) numbers are correct. If found,&n; * the entry is removed from the cache.&n; */
DECL|function|find_dentry_in_fhcache
r_static
r_struct
id|dentry
op_star
id|find_dentry_in_fhcache
c_func
(paren
r_struct
id|knfs_fh
op_star
id|fh
)paren
(brace
r_struct
id|fh_entry
op_star
id|fhe
suffix:semicolon
id|fhe
op_assign
id|find_fhe
c_func
(paren
id|fh-&gt;fh_dcookie
comma
id|NFSD_FILE_CACHE
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fhe
)paren
(brace
r_struct
id|dentry
op_star
id|parent
comma
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|dentry
op_assign
id|fhe-&gt;dentry
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;find_dentry_in_fhcache: %s/%s has no inode!&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inode-&gt;i_ino
op_ne
id|u32_to_ino_t
c_func
(paren
id|fh-&gt;fh_ino
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_dev
op_ne
id|u32_to_kdev_t
c_func
(paren
id|fh-&gt;fh_dev
)paren
)paren
r_goto
id|out
suffix:semicolon
id|fhe-&gt;dentry
op_assign
l_int|NULL
suffix:semicolon
id|fhe-&gt;ino
op_assign
l_int|0
suffix:semicolon
id|fhe-&gt;dev
op_assign
l_int|0
suffix:semicolon
id|nfsd_nr_put
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure the parent is in the dir cache ...&n;&t;&t; */
id|parent
op_assign
id|dget
c_func
(paren
id|dentry-&gt;d_parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|add_to_fhcache
c_func
(paren
id|parent
comma
id|NFSD_DIR_CACHE
)paren
)paren
id|nfsd_nr_verified
op_increment
suffix:semicolon
r_else
id|dput
c_func
(paren
id|parent
)paren
suffix:semicolon
r_return
id|dentry
suffix:semicolon
)brace
id|out
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Look for an entry in the parent directory with the specified&n; * inode number.&n; */
DECL|function|lookup_by_inode
r_static
r_struct
id|dentry
op_star
id|lookup_by_inode
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
id|ino_t
id|ino
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|nfsd_dirent
id|dirent
suffix:semicolon
multiline_comment|/*&n;&t; * Search the directory for the inode number.&n;&t; */
id|dirent.ino
op_assign
id|ino
suffix:semicolon
id|error
op_assign
id|get_parent_ino
c_func
(paren
id|parent
comma
op_amp
id|dirent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;lookup_by_inode: ino %ld not found in %s&bslash;n&quot;
comma
id|ino
comma
id|parent-&gt;d_name.name
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|no_entry
suffix:semicolon
)brace
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;lookup_by_inode: found %s&bslash;n&quot;
comma
id|dirent.name
)paren
suffix:semicolon
macro_line|#endif
id|dentry
op_assign
id|lookup_dentry
c_func
(paren
id|dirent.name
comma
id|dget
c_func
(paren
id|parent
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
(brace
r_if
c_cond
(paren
id|dentry-&gt;d_inode
op_logical_and
id|dentry-&gt;d_inode-&gt;i_ino
op_eq
id|ino
)paren
r_goto
id|out
suffix:semicolon
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;lookup_by_inode: %s/%s inode mismatch??&bslash;n&quot;
comma
id|parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
macro_line|#endif
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;lookup_by_inode: %s lookup failed, error=%ld&bslash;n&quot;
comma
id|dirent.name
comma
id|PTR_ERR
c_func
(paren
id|dentry
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
id|no_entry
suffix:colon
id|dentry
op_assign
l_int|NULL
suffix:semicolon
id|out
suffix:colon
r_return
id|dentry
suffix:semicolon
)brace
multiline_comment|/*&n; * Search the fix-up list for a dentry from a prior lookup.&n; */
DECL|function|nfsd_cached_lookup
r_static
r_struct
id|dentry
op_star
id|nfsd_cached_lookup
c_func
(paren
r_struct
id|knfs_fh
op_star
id|fh
)paren
(brace
r_struct
id|nfsd_fixup
op_star
id|fp
suffix:semicolon
id|fp
op_assign
id|find_cached_lookup
c_func
(paren
id|u32_to_kdev_t
c_func
(paren
id|fh-&gt;fh_dev
)paren
comma
id|u32_to_ino_t
c_func
(paren
id|fh-&gt;fh_dirino
)paren
comma
id|u32_to_ino_t
c_func
(paren
id|fh-&gt;fh_ino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fp
)paren
r_return
id|fp-&gt;dentry
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_void
DECL|function|expire_all
id|expire_all
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|nfsd_next_expire
)paren
)paren
(brace
id|expire_old
c_func
(paren
id|NFSD_FILE_CACHE
comma
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
id|expire_old
c_func
(paren
id|NFSD_DIR_CACHE
comma
l_int|60
op_star
id|HZ
)paren
suffix:semicolon
id|nfsd_next_expire
op_assign
id|jiffies
op_plus
l_int|5
op_star
id|HZ
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Free cache after unlink/rmdir.&n; */
r_void
DECL|function|expire_by_dentry
id|expire_by_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|fh_entry
op_star
id|fhe
suffix:semicolon
id|fhe
op_assign
id|find_fhe
c_func
(paren
id|dentry
comma
id|NFSD_FILE_CACHE
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fhe
)paren
(brace
id|expire_fhe
c_func
(paren
id|fhe
comma
id|NFSD_FILE_CACHE
)paren
suffix:semicolon
)brace
id|fhe
op_assign
id|find_fhe
c_func
(paren
id|dentry
comma
id|NFSD_DIR_CACHE
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fhe
)paren
(brace
id|expire_fhe
c_func
(paren
id|fhe
comma
id|NFSD_DIR_CACHE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The is the basic lookup mechanism for turning an NFS file handle &n; * into a dentry. There are several levels to the search:&n; * (1) Look for the dentry pointer the short-term fhcache,&n; *     and verify that it has the correct inode number.&n; *&n; * (2) Try to validate the dentry pointer in the file handle,&n; *     and verify that it has the correct inode number. If this&n; *     fails, check for a cached lookup in the fix-up list and&n; *     repeat step (2) using the new dentry pointer.&n; *&n; * (3) Look up the dentry by using the inode and parent inode numbers&n; *     to build the name string. This should succeed for any Unix-like&n; *     filesystem.&n; *&n; * (4) Search for the parent dentry in the dir cache, and then&n; *     look for the name matching the inode number.&n; *&n; * (5) The most general case ... search the whole volume for the inode.&n; *&n; * If successful, we return a dentry with the use count incremented.&n; *&n; * Note: steps (4) and (5) above are probably unnecessary now that (3)&n; * is working. Remove the code once this is verified ...&n; */
r_static
r_struct
id|dentry
op_star
DECL|function|find_fh_dentry
id|find_fh_dentry
c_func
(paren
r_struct
id|knfs_fh
op_star
id|fh
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
comma
op_star
id|parent
suffix:semicolon
r_int
id|looked_up
op_assign
l_int|0
comma
id|retry
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Stage 1: Look for the dentry in the short-term fhcache.&n;&t; */
id|dentry
op_assign
id|find_dentry_in_fhcache
c_func
(paren
id|fh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
)paren
(brace
id|nfsdstats.fh_cached
op_increment
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Stage 2: Attempt to validate the dentry in the file handle.&n;&t; */
id|dentry
op_assign
id|fh-&gt;fh_dcookie
suffix:semicolon
id|recheck
suffix:colon
r_if
c_cond
(paren
id|nfsd_d_validate
c_func
(paren
id|dentry
)paren
)paren
(brace
r_struct
id|inode
op_star
id|dir
op_assign
id|dentry-&gt;d_parent-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;i_ino
op_eq
id|u32_to_ino_t
c_func
(paren
id|fh-&gt;fh_dirino
)paren
op_logical_and
id|dir-&gt;i_dev
op_eq
id|u32_to_kdev_t
c_func
(paren
id|fh-&gt;fh_dev
)paren
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * NFS file handles must always have an inode,&n;&t;&t;&t; * so we won&squot;t accept a negative dentry.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|inode
op_logical_and
id|inode-&gt;i_ino
op_eq
id|u32_to_ino_t
c_func
(paren
id|fh-&gt;fh_ino
)paren
)paren
(brace
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
macro_line|#ifdef NFSD_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;find_fh_dentry: validated %s/%s, ino=%ld&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|retry
)paren
id|nfsdstats.fh_valid
op_increment
suffix:semicolon
r_else
(brace
id|nfsdstats.fh_fixup
op_increment
suffix:semicolon
macro_line|#ifdef NFSD_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;find_fh_dentry: retried validation successful&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_goto
id|out
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Before proceeding to a lookup, check whether we cached a&n;&t; * prior lookup. If so, try to validate that dentry ...&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|retry
op_logical_and
(paren
id|dentry
op_assign
id|nfsd_cached_lookup
c_func
(paren
id|fh
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|retry
op_assign
l_int|1
suffix:semicolon
r_goto
id|recheck
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Stage 3: Look up the dentry based on the inode and parent inode&n;&t; * numbers. This should work for all Unix-like filesystems.&n;&t; */
id|looked_up
op_assign
l_int|1
suffix:semicolon
id|dentry
op_assign
id|lookup_inode
c_func
(paren
id|u32_to_kdev_t
c_func
(paren
id|fh-&gt;fh_dev
)paren
comma
id|u32_to_ino_t
c_func
(paren
id|fh-&gt;fh_dirino
)paren
comma
id|u32_to_ino_t
c_func
(paren
id|fh-&gt;fh_ino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
macro_line|#ifdef NFSD_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;find_fh_dentry: looked up %s/%s&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|inode
op_logical_and
id|inode-&gt;i_ino
op_eq
id|u32_to_ino_t
c_func
(paren
id|fh-&gt;fh_ino
)paren
)paren
(brace
id|nfsdstats.fh_lookup
op_increment
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;find_fh_dentry: %s/%s lookup mismatch!&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
macro_line|#endif
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Stage 4: Look for the parent dentry in the fhcache ...&n;&t; */
id|parent
op_assign
id|find_dentry_by_ino
c_func
(paren
id|u32_to_kdev_t
c_func
(paren
id|fh-&gt;fh_dev
)paren
comma
id|u32_to_ino_t
c_func
(paren
id|fh-&gt;fh_dirino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent
)paren
(brace
multiline_comment|/*&n;&t;&t; * ... then search for the inode in the parent directory.&n;&t;&t; */
id|dentry
op_assign
id|lookup_by_inode
c_func
(paren
id|parent
comma
id|u32_to_ino_t
c_func
(paren
id|fh-&gt;fh_ino
)paren
)paren
suffix:semicolon
id|dput
c_func
(paren
id|parent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
)paren
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Stage 5: Search the whole volume.&n;&t; */
macro_line|#ifdef NFSD_PARANOIA
id|printk
c_func
(paren
l_string|&quot;find_fh_dentry: %s, %u/%u not found -- need full search!&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|u32_to_kdev_t
c_func
(paren
id|fh-&gt;fh_dev
)paren
)paren
comma
id|fh-&gt;fh_dirino
comma
id|fh-&gt;fh_ino
)paren
suffix:semicolon
macro_line|#endif
id|dentry
op_assign
l_int|NULL
suffix:semicolon
id|nfsdstats.fh_stale
op_increment
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|looked_up
op_logical_and
id|dentry
)paren
(brace
id|add_to_lookup_cache
c_func
(paren
id|dentry
comma
id|fh
)paren
suffix:semicolon
)brace
id|expire_all
c_func
(paren
)paren
suffix:semicolon
r_return
id|dentry
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform sanity checks on the dentry in a client&squot;s file handle.&n; *&n; * Note that the file handle dentry may need to be freed even after&n; * an error return.&n; */
id|u32
DECL|function|fh_verify
id|fh_verify
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_int
id|type
comma
r_int
id|access
)paren
(brace
r_struct
id|knfs_fh
op_star
id|fh
op_assign
op_amp
id|fhp-&gt;fh_handle
suffix:semicolon
r_struct
id|svc_export
op_star
id|exp
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|u32
id|error
op_assign
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;nfsd: fh_verify(exp %x/%u cookie %p)&bslash;n&quot;
comma
id|fh-&gt;fh_xdev
comma
id|fh-&gt;fh_xino
comma
id|fh-&gt;fh_dcookie
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fhp-&gt;fh_dverified
)paren
r_goto
id|check_type
suffix:semicolon
multiline_comment|/*&n;&t; * Look up the export entry.&n;&t; */
id|error
op_assign
id|nfserr_stale
suffix:semicolon
id|exp
op_assign
id|exp_get
c_func
(paren
id|rqstp-&gt;rq_client
comma
id|u32_to_kdev_t
c_func
(paren
id|fh-&gt;fh_xdev
)paren
comma
id|u32_to_ino_t
c_func
(paren
id|fh-&gt;fh_xino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|exp
)paren
multiline_comment|/* export entry revoked */
r_goto
id|out
suffix:semicolon
multiline_comment|/* Check if the request originated from a secure port. */
id|error
op_assign
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rqstp-&gt;rq_secure
op_logical_and
id|EX_SECURE
c_func
(paren
id|exp
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;nfsd: request from insecure port (%08lx:%d)!&bslash;n&quot;
comma
id|ntohl
c_func
(paren
id|rqstp-&gt;rq_addr.sin_addr.s_addr
)paren
comma
id|ntohs
c_func
(paren
id|rqstp-&gt;rq_addr.sin_port
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Set user creds if we haven&squot;t done so already. */
id|nfsd_setuser
c_func
(paren
id|rqstp
comma
id|exp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Look up the dentry using the NFS file handle.&n;&t; */
id|error
op_assign
id|nfserr_noent
suffix:semicolon
id|dentry
op_assign
id|find_fh_dentry
c_func
(paren
id|fh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Note:  it&squot;s possible the returned dentry won&squot;t be the one in the&n;&t; * file handle.  We can correct the file handle for our use, but&n;&t; * unfortunately the client will keep sending the broken one.  Let&squot;s&n;&t; * hope the lookup will keep patching things up.&n;&t; */
id|fhp-&gt;fh_dentry
op_assign
id|dentry
suffix:semicolon
id|fhp-&gt;fh_export
op_assign
id|exp
suffix:semicolon
id|fhp-&gt;fh_dverified
op_assign
l_int|1
suffix:semicolon
id|nfsd_nr_verified
op_increment
suffix:semicolon
multiline_comment|/* Type check. The correct error return for type mismatches&n;&t; * does not seem to be generally agreed upon. SunOS seems to&n;&t; * use EISDIR if file isn&squot;t S_IFREG; a comment in the NFSv3&n;&t; * spec says this is incorrect (implementation notes for the&n;&t; * write call).&n;&t; */
id|check_type
suffix:colon
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|exp
op_assign
id|fhp-&gt;fh_export
suffix:semicolon
r_if
c_cond
(paren
id|type
OG
l_int|0
op_logical_and
(paren
id|inode-&gt;i_mode
op_amp
id|S_IFMT
)paren
op_ne
id|type
)paren
(brace
id|error
op_assign
(paren
id|type
op_eq
id|S_IFDIR
)paren
ques
c_cond
id|nfserr_notdir
suffix:colon
id|nfserr_isdir
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
OL
l_int|0
op_logical_and
(paren
id|inode-&gt;i_mode
op_amp
id|S_IFMT
)paren
op_eq
op_minus
id|type
)paren
(brace
id|error
op_assign
(paren
id|type
op_eq
op_minus
id|S_IFDIR
)paren
ques
c_cond
id|nfserr_notdir
suffix:colon
id|nfserr_isdir
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Security: Check that the export is valid for dentry &lt;gam3@acm.org&gt;&n;&t; */
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fh-&gt;fh_dev
op_ne
id|fh-&gt;fh_xdev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fh_verify: Security: export on other device&quot;
l_string|&quot; (%d, %d).&bslash;n&quot;
comma
id|fh-&gt;fh_dev
comma
id|fh-&gt;fh_xdev
)paren
suffix:semicolon
id|error
op_assign
id|nfserr_stale
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|exp-&gt;ex_dentry
op_ne
id|dentry
)paren
(brace
r_struct
id|dentry
op_star
id|tdentry
op_assign
id|dentry
suffix:semicolon
r_do
(brace
id|tdentry
op_assign
id|tdentry-&gt;d_parent
suffix:semicolon
r_if
c_cond
(paren
id|exp-&gt;ex_dentry
op_eq
id|tdentry
)paren
r_break
suffix:semicolon
multiline_comment|/* executable only by root and we can&squot;t be root */
r_if
c_cond
(paren
id|current-&gt;fsuid
op_logical_and
op_logical_neg
(paren
id|tdentry-&gt;d_inode-&gt;i_uid
op_logical_and
(paren
id|tdentry-&gt;d_inode-&gt;i_mode
op_amp
id|S_IXUSR
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|tdentry-&gt;d_inode-&gt;i_gid
op_logical_and
(paren
id|tdentry-&gt;d_inode-&gt;i_mode
op_amp
id|S_IXGRP
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|tdentry-&gt;d_inode-&gt;i_mode
op_amp
id|S_IXOTH
)paren
op_logical_and
(paren
id|exp-&gt;ex_flags
op_amp
id|NFSEXP_ROOTSQUASH
)paren
)paren
(brace
id|error
op_assign
id|nfserr_stale
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;fh_verify: no root_squashed access.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|tdentry
op_ne
id|tdentry-&gt;d_parent
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exp-&gt;ex_dentry
op_ne
id|tdentry
)paren
(brace
id|error
op_assign
id|nfserr_stale
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;nfsd Security: %s/%s bad export.&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/* Finally, check access permissions. */
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|nfsd_permission
c_func
(paren
id|exp
comma
id|dentry
comma
id|access
)paren
suffix:semicolon
)brace
macro_line|#ifdef NFSD_PARANOIA
r_if
c_cond
(paren
id|error
)paren
id|printk
c_func
(paren
l_string|&quot;fh_verify: %s/%s permission failure, acc=%x, error=%d&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|access
comma
(paren
id|error
op_rshift
l_int|24
)paren
)paren
suffix:semicolon
macro_line|#endif
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Compose a file handle for an NFS reply.&n; *&n; * Note that when first composed, the dentry may not yet have&n; * an inode.  In this case a call to fh_update should be made&n; * before the fh goes out on the wire ...&n; */
r_void
DECL|function|fh_compose
id|fh_compose
c_func
(paren
r_struct
id|svc_fh
op_star
id|fhp
comma
r_struct
id|svc_export
op_star
id|exp
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_struct
id|dentry
op_star
id|parent
op_assign
id|dentry-&gt;d_parent
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;nfsd: fh_compose(exp %x/%ld %s/%s, ino=%ld)&bslash;n&quot;
comma
id|exp-&gt;ex_dev
comma
id|exp-&gt;ex_ino
comma
id|parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
(paren
id|inode
ques
c_cond
id|inode-&gt;i_ino
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * N.B. We shouldn&squot;t need to init the fh -- the call to fh_compose&n;&t; * may not be done on error paths, but the cleanup must call fh_put.&n;&t; * Fix this soon!&n;&t; */
r_if
c_cond
(paren
id|fhp-&gt;fh_dverified
op_logical_or
id|fhp-&gt;fh_locked
op_logical_or
id|fhp-&gt;fh_dentry
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;fh_compose: fh %s/%s not initialized!&bslash;n&quot;
comma
id|parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
)brace
id|fh_init
c_func
(paren
id|fhp
)paren
suffix:semicolon
id|fhp-&gt;fh_handle.fh_dcookie
op_assign
id|dentry
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
id|fhp-&gt;fh_handle.fh_ino
op_assign
id|ino_t_to_u32
c_func
(paren
id|inode-&gt;i_ino
)paren
suffix:semicolon
)brace
id|fhp-&gt;fh_handle.fh_dirino
op_assign
id|ino_t_to_u32
c_func
(paren
id|parent-&gt;d_inode-&gt;i_ino
)paren
suffix:semicolon
id|fhp-&gt;fh_handle.fh_dev
op_assign
id|kdev_t_to_u32
c_func
(paren
id|parent-&gt;d_inode-&gt;i_dev
)paren
suffix:semicolon
id|fhp-&gt;fh_handle.fh_xdev
op_assign
id|kdev_t_to_u32
c_func
(paren
id|exp-&gt;ex_dev
)paren
suffix:semicolon
id|fhp-&gt;fh_handle.fh_xino
op_assign
id|ino_t_to_u32
c_func
(paren
id|exp-&gt;ex_ino
)paren
suffix:semicolon
id|fhp-&gt;fh_dentry
op_assign
id|dentry
suffix:semicolon
multiline_comment|/* our internal copy */
id|fhp-&gt;fh_export
op_assign
id|exp
suffix:semicolon
multiline_comment|/* We stuck it there, we know it&squot;s good. */
id|fhp-&gt;fh_dverified
op_assign
l_int|1
suffix:semicolon
id|nfsd_nr_verified
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Update file handle information after changing a dentry.&n; */
r_void
DECL|function|fh_update
id|fh_update
c_func
(paren
r_struct
id|svc_fh
op_star
id|fhp
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fhp-&gt;fh_dverified
)paren
r_goto
id|out_bad
suffix:semicolon
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|out_negative
suffix:semicolon
id|fhp-&gt;fh_handle.fh_ino
op_assign
id|ino_t_to_u32
c_func
(paren
id|inode-&gt;i_ino
)paren
suffix:semicolon
id|out
suffix:colon
r_return
suffix:semicolon
id|out_bad
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;fh_update: fh not verified!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|out_negative
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;fh_update: %s/%s still negative!&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Release a file handle.  If the file handle carries a dentry count,&n; * we add the dentry to the short-term cache rather than release it.&n; */
r_void
DECL|function|fh_put
id|fh_put
c_func
(paren
r_struct
id|svc_fh
op_star
id|fhp
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
r_if
c_cond
(paren
id|fhp-&gt;fh_dverified
)paren
(brace
id|fh_unlock
c_func
(paren
id|fhp
)paren
suffix:semicolon
id|fhp-&gt;fh_dverified
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_count
)paren
r_goto
id|out_bad
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_inode
op_logical_or
op_logical_neg
id|add_to_fhcache
c_func
(paren
id|dentry
comma
l_int|0
)paren
)paren
(brace
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|nfsd_nr_put
op_increment
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
id|out_bad
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;fh_put: %s/%s has d_count 0!&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Verify that the FH dentry is still a valid dentry pointer.&n; * After making some preliminary checks, we ask VFS to verify&n; * that it is indeed a dentry.&n; */
DECL|function|nfsd_d_validate
r_static
r_int
id|nfsd_d_validate
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
r_int
id|dent_addr
op_assign
(paren
r_int
r_int
)paren
id|dentry
suffix:semicolon
r_int
r_int
id|min_addr
op_assign
id|PAGE_OFFSET
suffix:semicolon
r_int
r_int
id|max_addr
op_assign
id|min_addr
op_plus
(paren
id|max_mapnr
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
r_int
r_int
id|align_mask
op_assign
l_int|0x0F
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_int
id|valid
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dent_addr
OL
id|min_addr
)paren
r_goto
id|bad_addr
suffix:semicolon
r_if
c_cond
(paren
id|dent_addr
OG
id|max_addr
op_minus
r_sizeof
(paren
r_struct
id|dentry
)paren
)paren
r_goto
id|bad_addr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dent_addr
op_amp
op_complement
id|align_mask
)paren
op_ne
id|dent_addr
)paren
r_goto
id|bad_align
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kern_addr_valid
c_func
(paren
id|dent_addr
)paren
)paren
r_goto
id|bad_addr
suffix:semicolon
multiline_comment|/*&n;&t; * Looks safe enough to dereference ...&n;&t; */
id|len
op_assign
id|dentry-&gt;d_name.len
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|NFS_MAXNAMLEN
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Note: d_validate doesn&squot;t dereference the parent pointer ...&n;&t; * just combines it with the name hash to find the hash chain.&n;&t; */
id|valid
op_assign
id|d_validate
c_func
(paren
id|dentry
comma
id|dentry-&gt;d_parent
comma
id|dentry-&gt;d_name.hash
comma
id|len
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|valid
suffix:semicolon
id|bad_addr
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;nfsd_d_validate: invalid address %lx&bslash;n&quot;
comma
id|dent_addr
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_align
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;nfsd_d_validate: unaligned address %lx&bslash;n&quot;
comma
id|dent_addr
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush any cached dentries for the specified device&n; * or for all devices.&n; *&n; * This is called when revoking the last export for a&n; * device, so that it can be unmounted cleanly.&n; */
DECL|function|nfsd_fh_flush
r_void
id|nfsd_fh_flush
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_struct
id|fh_entry
op_star
id|fhe
suffix:semicolon
r_int
id|i
comma
id|pass
op_assign
l_int|2
suffix:semicolon
id|fhe
op_assign
op_amp
id|filetable
(braket
l_int|0
)braket
suffix:semicolon
r_while
c_loop
(paren
id|pass
op_decrement
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NFSD_MAXFH
suffix:semicolon
id|i
op_increment
comma
id|fhe
op_increment
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|fhe-&gt;dentry
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_logical_and
id|dentry-&gt;d_inode-&gt;i_dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
id|fhe-&gt;dentry
op_assign
l_int|NULL
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|nfsd_nr_put
op_increment
suffix:semicolon
)brace
id|fhe
op_assign
op_amp
id|dirstable
(braket
l_int|0
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Free the dentry and path caches.&n; */
DECL|function|nfsd_fh_free
r_void
id|nfsd_fh_free
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Flush dentries for all devices */
id|nfsd_fh_flush
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * N.B. write a destructor for these lists ...&n;&t; */
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|fixup_head.next
)paren
op_ne
op_amp
id|fixup_head
)paren
(brace
r_struct
id|nfsd_fixup
op_star
id|fp
suffix:semicolon
id|fp
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|nfsd_fixup
comma
id|lru
)paren
suffix:semicolon
id|free_fixup_entry
c_func
(paren
id|fp
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;nfsd_fh_free: %d fixups freed&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|path_inuse.next
)paren
op_ne
op_amp
id|path_inuse
)paren
(brace
r_struct
id|nfsd_path
op_star
id|pe
suffix:semicolon
id|pe
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|nfsd_path
comma
id|lru
)paren
suffix:semicolon
id|free_path_entry
c_func
(paren
id|pe
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;nfsd_fh_free: %d paths freed&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;nfsd_fh_free: verified %d, put %d&bslash;n&quot;
comma
id|nfsd_nr_verified
comma
id|nfsd_nr_put
)paren
suffix:semicolon
)brace
DECL|function|nfsd_fh_init
r_void
id|nfsd_fh_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Sanity check */
r_extern
r_void
id|__my_nfsfh_is_too_big
c_func
(paren
r_void
)paren
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|nfs_fhbase
)paren
OG
l_int|32
)paren
id|__my_nfsfh_is_too_big
c_func
(paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|filetable
comma
l_int|0
comma
id|NFSD_MAXFH
op_star
r_sizeof
(paren
r_struct
id|fh_entry
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dirstable
comma
l_int|0
comma
id|NFSD_MAXFH
op_star
r_sizeof
(paren
r_struct
id|fh_entry
)paren
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|path_inuse
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|fixup_head
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;nfsd_init: initialized fhcache, entries=%lu&bslash;n&quot;
comma
id|NFSD_MAXFH
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Display a warning if the ino_t is larger than 32 bits.&n;&t; */
r_if
c_cond
(paren
r_sizeof
(paren
id|ino_t
)paren
OG
r_sizeof
(paren
id|__u32
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;NFSD: ino_t is %d bytes, using lower 4 bytes&bslash;n&quot;
comma
r_sizeof
(paren
id|ino_t
)paren
)paren
suffix:semicolon
)brace
eof
