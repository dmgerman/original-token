multiline_comment|/*&n; * linux/fs/nfsd/vfs.c&n; *&n; * File operations used by nfsd. Some of these have been ripped from&n; * other parts of the kernel because they weren&squot;t in ksyms.c, others&n; * are partial duplicates with added or changed functionality.&n; *&n; * Note that several functions lock the inode upon which they want&n; * to act, most notably those that create directory entries. The&n; * unlock operation can take place either by calling fh_unlock within&n; * the function directly, or at a later time in fh_put(). So if you&n; * notice code paths that apparently fail to unlock the inode, don&squot;t&n; * worry--they have been taken care of.&n; *&n; * Copyright (C) 1995, 1996, 1997 Olaf Kirch &lt;okir@monad.swb.de&gt;&n; */
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/ext2_fs.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;netinet/in.h&gt;
macro_line|#include &lt;linux/sunrpc/svc.h&gt;
macro_line|#include &lt;linux/nfsd/nfsd.h&gt;
macro_line|#if LINUX_VERSION_CODE &gt;= 0x020100
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#endif
DECL|macro|NFSDDBG_FACILITY
mdefine_line|#define NFSDDBG_FACILITY&t;&t;NFSDDBG_FILEOP
multiline_comment|/* Symbol not exported */
r_static
r_struct
id|super_block
op_star
id|get_super
c_func
(paren
id|dev_t
id|dev
)paren
suffix:semicolon
multiline_comment|/* Open mode for nfsd_open */
DECL|macro|OPEN_READ
mdefine_line|#define OPEN_READ&t;0
DECL|macro|OPEN_WRITE
mdefine_line|#define OPEN_WRITE&t;1
multiline_comment|/* Hack until we have a macro check for mandatory locks. */
macro_line|#ifndef IS_ISMNDLK
DECL|macro|IS_ISMNDLK
mdefine_line|#define IS_ISMNDLK(i)&t;(((i)-&gt;i_mode &amp; (S_ISGID|S_ISVTX)) == S_ISGID)
macro_line|#endif
multiline_comment|/* Check for dir entries &squot;.&squot; and &squot;..&squot; */
DECL|macro|isdotent
mdefine_line|#define isdotent(n, l)&t;(l &lt; 3 &amp;&amp; n[0] == &squot;.&squot; &amp;&amp; (l == 1 || n[1] == &squot;.&squot;))
multiline_comment|/*&n; * This is a cache of readahead params that help us choose the proper&n; * readahead strategy. Initially, we set all readahead parameters to 0&n; * and let the VFS handle things.&n; * If you increase the number of cached files very much, you&squot;ll need to&n; * add a hash table here.&n; */
DECL|struct|raparms
r_struct
id|raparms
(brace
DECL|member|p_next
r_struct
id|raparms
op_star
id|p_next
suffix:semicolon
DECL|member|p_count
r_int
r_int
id|p_count
suffix:semicolon
DECL|member|p_dev
id|dev_t
id|p_dev
suffix:semicolon
DECL|member|p_ino
id|ino_t
id|p_ino
suffix:semicolon
DECL|member|p_reada
r_int
r_int
id|p_reada
comma
DECL|member|p_ramax
id|p_ramax
comma
DECL|member|p_raend
id|p_raend
comma
DECL|member|p_ralen
id|p_ralen
comma
DECL|member|p_rawin
id|p_rawin
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|FILECACHE_MAX
mdefine_line|#define FILECACHE_MAX&t;&t;(2 * NFSD_MAXSERVS)
DECL|variable|raparms
r_static
r_struct
id|raparms
id|raparms
(braket
id|FILECACHE_MAX
)braket
suffix:semicolon
DECL|variable|raparm_cache
r_static
r_struct
id|raparms
op_star
id|raparm_cache
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Deny access to certain file systems&n; */
r_static
r_inline
r_int
DECL|function|fs_off_limits
id|fs_off_limits
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_return
op_logical_neg
id|sb
op_logical_or
id|sb-&gt;s_magic
op_eq
id|NFS_SUPER_MAGIC
op_logical_or
id|sb-&gt;s_magic
op_eq
id|PROC_SUPER_MAGIC
suffix:semicolon
)brace
multiline_comment|/*&n; * Check whether directory is a mount point&n; */
r_static
r_inline
r_int
DECL|function|nfsd_iscovered
id|nfsd_iscovered
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_return
id|inode-&gt;i_mount
op_ne
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up one component of a pathname.&n; */
r_int
DECL|function|nfsd_lookup
id|nfsd_lookup
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
r_struct
id|svc_fh
op_star
id|resfh
)paren
(brace
r_struct
id|svc_export
op_star
id|exp
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
r_struct
id|inode
op_star
id|dirp
comma
op_star
id|inode
suffix:semicolon
r_int
id|perm
comma
id|err
comma
id|dotdot
op_assign
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;nfsd: nfsd_lookup(fh %x/%ld, %s)&bslash;n&quot;
comma
id|SVCFH_DEV
c_func
(paren
id|fhp
)paren
comma
id|SVCFH_INO
c_func
(paren
id|fhp
)paren
comma
id|name
)paren
suffix:semicolon
multiline_comment|/* Obtain inode and export */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|fh_lookup
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFDIR
comma
id|MAY_NOP
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|dirp
op_assign
id|fhp-&gt;fh_inode
suffix:semicolon
id|exp
op_assign
id|fhp-&gt;fh_export
suffix:semicolon
multiline_comment|/* check permissions before traversing mount-points */
id|perm
op_assign
id|nfsd_permission
c_func
(paren
id|exp
comma
id|dirp
comma
id|MAY_EXEC
)paren
suffix:semicolon
id|dotdot
op_assign
(paren
id|len
op_eq
l_int|2
op_logical_and
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
id|name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dotdot
)paren
(brace
r_if
c_cond
(paren
id|dirp
op_eq
id|current-&gt;fs-&gt;root
)paren
(brace
id|dirp-&gt;i_count
op_increment
suffix:semicolon
op_star
id|resfh
op_assign
op_star
id|fhp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dirp-&gt;i_dev
op_eq
id|exp-&gt;ex_dev
op_logical_and
id|dirp-&gt;i_ino
op_eq
id|exp-&gt;ex_ino
)paren
(brace
id|dirp-&gt;i_count
op_increment
suffix:semicolon
op_star
id|resfh
op_assign
op_star
id|fhp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|len
op_eq
l_int|1
op_logical_and
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|fs_off_limits
c_func
(paren
id|dirp-&gt;i_sb
)paren
)paren
(brace
multiline_comment|/* No lookups on NFS mounts and procfs */
r_return
id|nfserr_noent
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|nfsd_iscovered
c_func
(paren
id|dirp
)paren
)paren
(brace
multiline_comment|/* broken NFS client */
r_return
id|nfserr_acces
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dirp-&gt;i_op
op_logical_or
op_logical_neg
id|dirp-&gt;i_op-&gt;lookup
)paren
r_return
id|nfserr_notdir
suffix:semicolon
r_if
c_cond
(paren
id|perm
op_ne
l_int|0
)paren
r_return
id|perm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
(brace
id|dirp-&gt;i_count
op_increment
suffix:semicolon
op_star
id|resfh
op_assign
op_star
id|fhp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dirp-&gt;i_count
op_increment
suffix:semicolon
multiline_comment|/* lookup eats the dirp inode */
id|err
op_assign
id|dirp-&gt;i_op
op_member_access_from_pointer
id|lookup
c_func
(paren
id|dirp
comma
id|name
comma
id|len
comma
op_amp
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
multiline_comment|/* Note that lookup() has already done a call to iget() so that&n;&t; * the inode returned never refers to an inode covered by a mount.&n;&t; * When this has happened, return the covered inode.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|dotdot
op_logical_and
(paren
id|sb
op_assign
id|inode-&gt;i_sb
)paren
op_logical_and
(paren
id|inode
op_eq
id|sb-&gt;s_mounted
)paren
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
id|inode
op_assign
id|sb-&gt;s_covered
suffix:semicolon
id|inode-&gt;i_count
op_increment
suffix:semicolon
)brace
id|fh_compose
c_func
(paren
id|resfh
comma
id|exp
comma
id|inode
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Set various file attributes.&n; */
r_int
DECL|function|nfsd_setattr
id|nfsd_setattr
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_struct
id|iattr
op_star
id|iap
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|accmode
op_assign
id|MAY_SATTR
suffix:semicolon
r_int
id|ftype
op_assign
l_int|0
suffix:semicolon
r_int
id|imode
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|iap-&gt;ia_valid
op_amp
(paren
id|ATTR_ATIME
op_or
id|ATTR_MTIME
op_or
id|ATTR_SIZE
)paren
)paren
id|accmode
op_or_assign
id|MAY_WRITE
suffix:semicolon
r_if
c_cond
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_SIZE
)paren
id|ftype
op_assign
id|S_IFREG
suffix:semicolon
multiline_comment|/* Get inode */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|fh_lookup
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|ftype
comma
id|accmode
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|fh_lock
c_func
(paren
id|fhp
)paren
suffix:semicolon
multiline_comment|/* lock inode */
id|inode
op_assign
id|fhp-&gt;fh_inode
suffix:semicolon
multiline_comment|/* The size case is special... */
r_if
c_cond
(paren
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_SIZE
)paren
op_logical_and
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|iap-&gt;ia_size
OL
id|inode-&gt;i_size
)paren
(brace
id|err
op_assign
id|nfsd_permission
c_func
(paren
id|fhp-&gt;fh_export
comma
id|inode
comma
id|MAY_TRUNC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|get_write_access
c_func
(paren
id|inode
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
id|inode-&gt;i_size
op_assign
id|iap-&gt;ia_size
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_op
op_logical_and
id|inode-&gt;i_op-&gt;truncate
)paren
id|inode-&gt;i_op
op_member_access_from_pointer
id|truncate
c_func
(paren
id|inode
)paren
suffix:semicolon
id|inode-&gt;i_dirt
op_assign
l_int|1
suffix:semicolon
id|put_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
id|iap-&gt;ia_valid
op_and_assign
id|ATTR_SIZE
suffix:semicolon
id|iap-&gt;ia_valid
op_or_assign
id|ATTR_MTIME
suffix:semicolon
id|iap-&gt;ia_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
)brace
id|imode
op_assign
id|inode-&gt;i_mode
suffix:semicolon
r_if
c_cond
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_MODE
)paren
(brace
id|iap-&gt;ia_mode
op_and_assign
id|S_IALLUGO
suffix:semicolon
id|imode
op_assign
id|iap-&gt;ia_mode
op_or_assign
(paren
id|imode
op_amp
op_complement
id|S_IALLUGO
)paren
suffix:semicolon
)brace
multiline_comment|/* Revoke setuid/setgid bit on chown/chgrp */
r_if
c_cond
(paren
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_UID
)paren
op_logical_and
(paren
id|imode
op_amp
id|S_ISUID
)paren
op_logical_and
id|iap-&gt;ia_uid
op_ne
id|inode-&gt;i_uid
)paren
(brace
id|iap-&gt;ia_valid
op_or_assign
id|ATTR_MODE
suffix:semicolon
id|iap-&gt;ia_mode
op_assign
id|imode
op_and_assign
op_complement
id|S_ISUID
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_GID
)paren
op_logical_and
(paren
id|imode
op_amp
id|S_ISGID
)paren
op_logical_and
id|iap-&gt;ia_gid
op_ne
id|inode-&gt;i_gid
)paren
(brace
id|iap-&gt;ia_valid
op_or_assign
id|ATTR_MODE
suffix:semicolon
id|iap-&gt;ia_mode
op_assign
id|imode
op_and_assign
op_complement
id|S_ISGID
suffix:semicolon
)brace
multiline_comment|/* Change the attributes. */
r_if
c_cond
(paren
id|iap-&gt;ia_valid
)paren
(brace
id|iap-&gt;ia_valid
op_or_assign
id|ATTR_CTIME
suffix:semicolon
id|iap-&gt;ia_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|err
op_assign
id|nfsd_notify_change
c_func
(paren
id|inode
comma
id|iap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|EX_ISSYNC
c_func
(paren
id|fhp-&gt;fh_export
)paren
)paren
id|nfsd_write_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Open an existing file or directory.&n; * The wflag argument indicates write access.&n; */
r_int
DECL|function|nfsd_open
id|nfsd_open
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_int
id|type
comma
r_int
id|wflag
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|access
comma
id|err
suffix:semicolon
id|access
op_assign
id|wflag
ques
c_cond
id|MAY_WRITE
suffix:colon
id|MAY_READ
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|fh_lookup
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|type
comma
id|access
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|inode
op_assign
id|fhp-&gt;fh_inode
suffix:semicolon
multiline_comment|/* Disallow access to files with the append-only bit set or&n;&t; * with mandatory locking enabled */
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|inode
)paren
op_logical_or
id|IS_ISMNDLK
c_func
(paren
id|inode
)paren
)paren
r_return
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_op
op_logical_or
op_logical_neg
id|inode-&gt;i_op-&gt;default_file_ops
)paren
r_return
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
id|wflag
op_logical_and
(paren
id|err
op_assign
id|get_write_access
c_func
(paren
id|inode
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
id|memset
c_func
(paren
id|filp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|filp
)paren
)paren
suffix:semicolon
id|filp-&gt;f_op
op_assign
id|inode-&gt;i_op-&gt;default_file_ops
suffix:semicolon
id|filp-&gt;f_count
op_assign
l_int|1
suffix:semicolon
id|filp-&gt;f_flags
op_assign
id|wflag
ques
c_cond
id|O_WRONLY
suffix:colon
id|O_RDONLY
suffix:semicolon
id|filp-&gt;f_mode
op_assign
id|wflag
ques
c_cond
id|FMODE_WRITE
suffix:colon
id|FMODE_READ
suffix:semicolon
id|filp-&gt;f_inode
op_assign
id|inode
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_op-&gt;open
)paren
(brace
id|err
op_assign
id|filp-&gt;f_op
op_member_access_from_pointer
id|open
c_func
(paren
id|inode
comma
id|filp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_if
c_cond
(paren
id|wflag
)paren
id|put_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
id|filp-&gt;f_count
op_decrement
suffix:semicolon
r_return
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
)brace
)brace
id|inode-&gt;i_count
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Close a file.&n; */
r_void
DECL|function|nfsd_close
id|nfsd_close
c_func
(paren
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|inode
op_assign
id|filp-&gt;f_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_count
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;nfsd: inode count == 0!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_op
op_logical_and
id|filp-&gt;f_op-&gt;release
)paren
id|filp-&gt;f_op
op_member_access_from_pointer
id|release
c_func
(paren
id|inode
comma
id|filp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
id|put_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Sync a file&n; */
r_void
DECL|function|nfsd_sync
id|nfsd_sync
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|filp-&gt;f_op
op_member_access_from_pointer
id|fsync
c_func
(paren
id|inode
comma
id|filp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Obtain the readahead parameters for the given file&n; */
r_static
r_inline
r_struct
id|raparms
op_star
DECL|function|nfsd_get_raparms
id|nfsd_get_raparms
c_func
(paren
id|dev_t
id|dev
comma
id|ino_t
id|ino
)paren
(brace
r_struct
id|raparms
op_star
id|ra
comma
op_star
op_star
id|rap
comma
op_star
op_star
id|frap
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|rap
op_assign
op_amp
id|raparm_cache
suffix:semicolon
(paren
id|ra
op_assign
op_star
id|rap
)paren
suffix:semicolon
id|rap
op_assign
op_amp
id|ra-&gt;p_next
)paren
(brace
r_if
c_cond
(paren
id|ra-&gt;p_dev
op_ne
id|dev
op_logical_or
id|ra-&gt;p_ino
op_ne
id|ino
)paren
(brace
r_if
c_cond
(paren
id|ra-&gt;p_count
op_eq
l_int|0
)paren
id|frap
op_assign
id|rap
suffix:semicolon
)brace
r_else
r_goto
id|found
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|frap
)paren
r_return
l_int|NULL
suffix:semicolon
id|rap
op_assign
id|frap
suffix:semicolon
id|ra
op_assign
op_star
id|frap
suffix:semicolon
id|memset
c_func
(paren
id|ra
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ra
)paren
)paren
suffix:semicolon
id|found
suffix:colon
r_if
c_cond
(paren
id|rap
op_ne
op_amp
id|raparm_cache
)paren
(brace
op_star
id|rap
op_assign
id|ra-&gt;p_next
suffix:semicolon
id|ra-&gt;p_next
op_assign
id|raparm_cache
suffix:semicolon
id|raparm_cache
op_assign
id|ra
suffix:semicolon
)brace
id|ra-&gt;p_count
op_increment
suffix:semicolon
r_return
id|ra
suffix:semicolon
)brace
multiline_comment|/*&n; * Read data from a file. count must contain the requested read count&n; * on entry. On return, *count contains the number of bytes actually read.&n; */
r_int
DECL|function|nfsd_read
id|nfsd_read
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
id|loff_t
id|offset
comma
r_char
op_star
id|buf
comma
r_int
r_int
op_star
id|count
)paren
(brace
r_struct
id|raparms
op_star
id|ra
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|file
id|file
suffix:semicolon
r_int
r_int
id|oldfs
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|nfsd_open
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFREG
comma
id|OPEN_READ
comma
op_amp
id|file
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|inode
op_assign
id|file.f_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file.f_op-&gt;read
)paren
(brace
id|nfsd_close
c_func
(paren
op_amp
id|file
)paren
suffix:semicolon
r_return
id|nfserr_perm
suffix:semicolon
)brace
multiline_comment|/* Get readahead parameters */
r_if
c_cond
(paren
(paren
id|ra
op_assign
id|nfsd_get_raparms
c_func
(paren
id|inode-&gt;i_dev
comma
id|inode-&gt;i_ino
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|file.f_reada
op_assign
id|ra-&gt;p_reada
suffix:semicolon
id|file.f_ramax
op_assign
id|ra-&gt;p_ramax
suffix:semicolon
id|file.f_raend
op_assign
id|ra-&gt;p_raend
suffix:semicolon
id|file.f_ralen
op_assign
id|ra-&gt;p_ralen
suffix:semicolon
id|file.f_rawin
op_assign
id|ra-&gt;p_rawin
suffix:semicolon
)brace
id|file.f_pos
op_assign
id|offset
suffix:semicolon
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|err
op_assign
id|file.f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|file.f_inode
comma
op_amp
id|file
comma
id|buf
comma
op_star
id|count
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
multiline_comment|/* Write back readahead params */
r_if
c_cond
(paren
id|ra
op_ne
l_int|NULL
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;nfsd: raparms %ld %ld %ld %ld %ld&bslash;n&quot;
comma
id|file.f_reada
comma
id|file.f_ramax
comma
id|file.f_raend
comma
id|file.f_ralen
comma
id|file.f_rawin
)paren
suffix:semicolon
id|ra-&gt;p_reada
op_assign
id|file.f_reada
suffix:semicolon
id|ra-&gt;p_ramax
op_assign
id|file.f_ramax
suffix:semicolon
id|ra-&gt;p_raend
op_assign
id|file.f_raend
suffix:semicolon
id|ra-&gt;p_ralen
op_assign
id|file.f_ralen
suffix:semicolon
id|ra-&gt;p_rawin
op_assign
id|file.f_rawin
suffix:semicolon
id|ra-&gt;p_count
op_sub_assign
l_int|1
suffix:semicolon
)brace
id|nfsd_close
c_func
(paren
op_amp
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
op_star
id|count
op_assign
id|err
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Write data to a file.&n; * The stable flag requests synchronous writes.&n; */
r_int
DECL|function|nfsd_write
id|nfsd_write
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
id|loff_t
id|offset
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|cnt
comma
r_int
id|stable
)paren
(brace
r_struct
id|svc_export
op_star
id|exp
suffix:semicolon
r_struct
id|file
id|file
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
r_int
id|oldfs
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cnt
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|nfsd_open
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFREG
comma
id|OPEN_WRITE
comma
op_amp
id|file
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file.f_op-&gt;write
)paren
(brace
id|nfsd_close
c_func
(paren
op_amp
id|file
)paren
suffix:semicolon
r_return
id|nfserr_perm
suffix:semicolon
)brace
id|inode
op_assign
id|fhp-&gt;fh_inode
suffix:semicolon
id|exp
op_assign
id|fhp-&gt;fh_export
suffix:semicolon
multiline_comment|/*&n;&t; * Request sync writes if&n;&t; *  -&t;the sync export option has been set, or&n;&t; *  -&t;the client requested O_SYNC behavior (NFSv3 feature).&n;&t; * When gathered writes have been configured for this volume,&n;&t; * flushing the data to disk is handled separately below.&n;&t; */
r_if
c_cond
(paren
(paren
id|stable
op_logical_or
(paren
id|stable
op_assign
id|EX_ISSYNC
c_func
(paren
id|exp
)paren
)paren
)paren
op_logical_and
op_logical_neg
id|EX_WGATHER
c_func
(paren
id|exp
)paren
)paren
id|file.f_flags
op_or_assign
id|O_SYNC
suffix:semicolon
id|fh_lock
c_func
(paren
id|fhp
)paren
suffix:semicolon
multiline_comment|/* lock inode */
id|file.f_pos
op_assign
id|offset
suffix:semicolon
multiline_comment|/* set write offset */
multiline_comment|/* Write the data. */
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|err
op_assign
id|file.f_op
op_member_access_from_pointer
id|write
c_func
(paren
id|inode
comma
op_amp
id|file
comma
id|buf
comma
id|cnt
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
multiline_comment|/* clear setuid/setgid flag after write */
r_if
c_cond
(paren
id|err
op_ge
l_int|0
op_logical_and
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_ISUID
op_or
id|S_ISGID
)paren
)paren
)paren
(brace
r_struct
id|iattr
id|ia
suffix:semicolon
id|ia.ia_valid
op_assign
id|ATTR_MODE
suffix:semicolon
id|ia.ia_mode
op_assign
id|inode-&gt;i_mode
op_amp
op_complement
(paren
id|S_ISUID
op_or
id|S_ISGID
)paren
suffix:semicolon
id|nfsd_notify_change
c_func
(paren
id|inode
comma
op_amp
id|ia
)paren
suffix:semicolon
)brace
id|fh_unlock
c_func
(paren
id|fhp
)paren
suffix:semicolon
multiline_comment|/* unlock inode */
r_if
c_cond
(paren
id|err
op_ge
l_int|0
op_logical_and
id|stable
)paren
(brace
r_static
r_int
r_int
id|last_ino
op_assign
l_int|0
suffix:semicolon
r_static
id|kdev_t
id|last_dev
op_assign
id|NODEV
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Gathered writes: If another process is currently&n;&t;&t; * writing to the file, there&squot;s a high chance&n;&t;&t; * this is another nfsd (triggered by a bulk write&n;&t;&t; * from a client&squot;s biod). Rather than syncing the&n;&t;&t; * file with each write request, we sleep for 10 msec.&n;&t;&t; *&n;&t;&t; * I don&squot;t know if this roughly approximates&n;&t;&t; * C. Juszak&squot;s idea of gathered writes, but it&squot;s a&n;&t;&t; * nice and simple solution (IMHO), and it seems to&n;&t;&t; * work:-)&n;&t;&t; */
r_if
c_cond
(paren
id|EX_WGATHER
c_func
(paren
id|exp
)paren
op_logical_and
(paren
id|inode-&gt;i_writecount
OG
l_int|1
op_logical_or
(paren
id|last_ino
op_eq
id|inode-&gt;i_ino
op_logical_and
id|last_dev
op_eq
id|inode-&gt;i_dev
)paren
)paren
)paren
(brace
macro_line|#if 0
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
l_int|10
op_star
id|HZ
op_div
l_int|1000
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|inode-&gt;i_wait
)paren
suffix:semicolon
macro_line|#else
id|dprintk
c_func
(paren
l_string|&quot;nfsd: write defer %d&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|need_resched
op_assign
l_int|1
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|100
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;nfsd: write resume %d&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|inode-&gt;i_dirt
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;nfsd: write sync %d&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|nfsd_sync
c_func
(paren
id|inode
comma
op_amp
id|file
)paren
suffix:semicolon
id|nfsd_write_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
id|wake_up
c_func
(paren
op_amp
id|inode-&gt;i_wait
)paren
suffix:semicolon
id|last_ino
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|last_dev
op_assign
id|inode-&gt;i_dev
suffix:semicolon
)brace
id|nfsd_close
c_func
(paren
op_amp
id|file
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;nfsd: write complete&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|err
OL
l_int|0
)paren
ques
c_cond
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a file (regular, directory, device, fifo).&n; * UNIX sockets not yet implemented.&n; */
r_int
DECL|function|nfsd_create
id|nfsd_create
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_char
op_star
id|fname
comma
r_int
id|flen
comma
r_struct
id|iattr
op_star
id|iap
comma
r_int
id|type
comma
id|dev_t
id|rdev
comma
r_struct
id|svc_fh
op_star
id|resfhp
)paren
(brace
r_struct
id|inode
op_star
id|dirp
comma
op_star
id|inode
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flen
)paren
r_return
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_MODE
)paren
)paren
id|iap-&gt;ia_mode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|fh_lookup
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFDIR
comma
id|MAY_CREATE
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|fh_lock
c_func
(paren
id|fhp
)paren
suffix:semicolon
multiline_comment|/* lock directory */
id|dirp
op_assign
id|fhp-&gt;fh_inode
suffix:semicolon
id|dirp-&gt;i_count
op_increment
suffix:semicolon
multiline_comment|/* dirop eats the inode */
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|S_IFREG
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|dirp-&gt;i_op
op_logical_or
op_logical_neg
id|dirp-&gt;i_op-&gt;create
)paren
r_return
id|nfserr_perm
suffix:semicolon
id|err
op_assign
id|dirp-&gt;i_op
op_member_access_from_pointer
id|create
c_func
(paren
id|dirp
comma
id|fname
comma
id|flen
comma
id|iap-&gt;ia_mode
comma
op_amp
id|inode
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFDIR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|dirp-&gt;i_op
op_logical_or
op_logical_neg
id|dirp-&gt;i_op-&gt;mkdir
)paren
r_return
id|nfserr_perm
suffix:semicolon
id|err
op_assign
id|dirp-&gt;i_op
op_member_access_from_pointer
id|mkdir
c_func
(paren
id|dirp
comma
id|fname
comma
id|flen
comma
id|iap-&gt;ia_mode
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFCHR
suffix:colon
r_case
id|S_IFBLK
suffix:colon
r_case
id|S_IFIFO
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|dirp-&gt;i_op
op_logical_or
op_logical_neg
id|dirp-&gt;i_op-&gt;mknod
)paren
r_return
id|nfserr_perm
suffix:semicolon
id|err
op_assign
id|dirp-&gt;i_op
op_member_access_from_pointer
id|mknod
c_func
(paren
id|dirp
comma
id|fname
comma
id|flen
comma
id|iap-&gt;ia_mode
comma
id|rdev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|iput
c_func
(paren
id|dirp
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EACCES
suffix:semicolon
)brace
id|fh_unlock
c_func
(paren
id|fhp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the VFS call doesn&squot;t return the inode, look it up now.&n;&t; */
r_if
c_cond
(paren
id|inode
op_eq
l_int|NULL
)paren
(brace
id|dirp-&gt;i_count
op_increment
suffix:semicolon
id|err
op_assign
id|dirp-&gt;i_op
op_member_access_from_pointer
id|lookup
c_func
(paren
id|dirp
comma
id|fname
comma
id|flen
comma
op_amp
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
op_minus
id|nfserrno
c_func
(paren
id|err
)paren
suffix:semicolon
multiline_comment|/* Huh?! */
)brace
r_if
c_cond
(paren
id|EX_ISSYNC
c_func
(paren
id|fhp-&gt;fh_export
)paren
)paren
id|nfsd_write_inode
c_func
(paren
id|dirp
)paren
suffix:semicolon
multiline_comment|/* Assemble the file handle for the newly created file */
id|fh_compose
c_func
(paren
id|resfhp
comma
id|fhp-&gt;fh_export
comma
id|inode
)paren
suffix:semicolon
multiline_comment|/* Set file attributes. Mode has already been set and&n;&t; * setting uid/gid works only for root. Irix appears to&n;&t; * send along the gid when it tries to implement setgid&n;&t; * directories via NFS.&n;&t; */
r_if
c_cond
(paren
(paren
id|iap-&gt;ia_valid
op_and_assign
(paren
id|ATTR_UID
op_or
id|ATTR_GID
op_or
id|ATTR_MODE
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|nfsd_setattr
c_func
(paren
id|rqstp
comma
id|resfhp
comma
id|iap
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|fh_put
c_func
(paren
id|resfhp
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Truncate a file.&n; * The calling routines must make sure to update the ctime&n; * field and call notify_change.&n; */
r_int
DECL|function|nfsd_truncate
id|nfsd_truncate
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_int
r_int
id|size
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|fh_lookup
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFREG
comma
id|MAY_WRITE
op_or
id|MAY_TRUNC
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|fh_lock
c_func
(paren
id|fhp
)paren
suffix:semicolon
multiline_comment|/* lock inode if not yet locked */
id|inode
op_assign
id|fhp-&gt;fh_inode
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|get_write_access
c_func
(paren
id|inode
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
id|inode-&gt;i_size
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_op
op_logical_and
id|inode-&gt;i_op-&gt;truncate
)paren
id|inode-&gt;i_op
op_member_access_from_pointer
id|truncate
c_func
(paren
id|inode
)paren
suffix:semicolon
id|inode-&gt;i_dirt
op_assign
l_int|1
suffix:semicolon
id|put_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
id|fh_unlock
c_func
(paren
id|fhp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read a symlink. On entry, *lenp must contain the maximum path length that&n; * fits into the buffer. On return, it contains the true length.&n; */
r_int
DECL|function|nfsd_readlink
id|nfsd_readlink
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_char
op_star
id|buf
comma
r_int
op_star
id|lenp
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
r_int
id|oldfs
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|fh_lookup
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFLNK
comma
id|MAY_READ
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|inode
op_assign
id|fhp-&gt;fh_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_op
op_logical_or
op_logical_neg
id|inode-&gt;i_op-&gt;readlink
)paren
r_return
id|nfserr_io
suffix:semicolon
id|inode-&gt;i_count
op_increment
suffix:semicolon
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|err
op_assign
id|inode-&gt;i_op
op_member_access_from_pointer
id|readlink
c_func
(paren
id|inode
comma
id|buf
comma
op_star
id|lenp
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
op_star
id|lenp
op_assign
id|err
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a symlink and look up its inode&n; */
r_int
DECL|function|nfsd_symlink
id|nfsd_symlink
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_char
op_star
id|fname
comma
r_int
id|flen
comma
r_char
op_star
id|path
comma
r_int
id|plen
comma
r_struct
id|svc_fh
op_star
id|resfhp
)paren
(brace
r_struct
id|inode
op_star
id|dirp
comma
op_star
id|inode
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flen
op_logical_or
op_logical_neg
id|plen
)paren
r_return
id|nfserr_noent
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|fh_lookup
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFDIR
comma
id|MAY_CREATE
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|dirp
op_assign
id|fhp-&gt;fh_inode
suffix:semicolon
r_if
c_cond
(paren
id|nfsd_iscovered
c_func
(paren
id|dirp
)paren
)paren
r_return
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dirp-&gt;i_op
op_logical_or
op_logical_neg
id|dirp-&gt;i_op-&gt;symlink
)paren
r_return
id|nfserr_perm
suffix:semicolon
id|fh_lock
c_func
(paren
id|fhp
)paren
suffix:semicolon
multiline_comment|/* lock inode */
id|dirp-&gt;i_count
op_increment
suffix:semicolon
id|err
op_assign
id|dirp-&gt;i_op
op_member_access_from_pointer
id|symlink
c_func
(paren
id|dirp
comma
id|fname
comma
id|flen
comma
id|path
)paren
suffix:semicolon
id|fh_unlock
c_func
(paren
id|fhp
)paren
suffix:semicolon
multiline_comment|/* unlock inode */
r_if
c_cond
(paren
id|err
)paren
r_return
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|EX_ISSYNC
c_func
(paren
id|fhp-&gt;fh_export
)paren
)paren
id|nfsd_write_inode
c_func
(paren
id|dirp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Okay, now look up the inode of the new symlink.&n;&t; */
id|dirp-&gt;i_count
op_increment
suffix:semicolon
multiline_comment|/* lookup eats the dirp inode */
id|err
op_assign
id|dirp-&gt;i_op
op_member_access_from_pointer
id|lookup
c_func
(paren
id|dirp
comma
id|fname
comma
id|flen
comma
op_amp
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
id|fh_compose
c_func
(paren
id|resfhp
comma
id|fhp-&gt;fh_export
comma
id|inode
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a hardlink&n; */
r_int
DECL|function|nfsd_link
id|nfsd_link
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|ffhp
comma
r_char
op_star
id|fname
comma
r_int
id|len
comma
r_struct
id|svc_fh
op_star
id|tfhp
)paren
(brace
r_struct
id|inode
op_star
id|dirp
comma
op_star
id|dest
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|fh_lookup
c_func
(paren
id|rqstp
comma
id|ffhp
comma
id|S_IFDIR
comma
id|MAY_CREATE
)paren
op_ne
l_int|0
)paren
op_logical_or
(paren
id|err
op_assign
id|fh_lookup
c_func
(paren
id|rqstp
comma
id|tfhp
comma
id|S_IFREG
comma
id|MAY_NOP
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|dirp
op_assign
id|ffhp-&gt;fh_inode
suffix:semicolon
id|dest
op_assign
id|tfhp-&gt;fh_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_return
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
id|nfsd_iscovered
c_func
(paren
id|dirp
)paren
)paren
r_return
id|nfserr_acces
suffix:semicolon
r_if
c_cond
(paren
id|dirp-&gt;i_dev
op_ne
id|dest-&gt;i_dev
)paren
r_return
id|nfserr_acces
suffix:semicolon
multiline_comment|/* FIXME: nxdev for NFSv3 */
r_if
c_cond
(paren
id|IS_IMMUTABLE
c_func
(paren
id|dest
)paren
multiline_comment|/* || IS_APPEND(dest) */
)paren
r_return
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dirp-&gt;i_op
op_logical_or
op_logical_neg
id|dirp-&gt;i_op-&gt;link
)paren
r_return
id|nfserr_perm
suffix:semicolon
id|fh_lock
c_func
(paren
id|ffhp
)paren
suffix:semicolon
multiline_comment|/* lock directory inode */
id|dirp-&gt;i_count
op_increment
suffix:semicolon
id|err
op_assign
id|dirp-&gt;i_op
op_member_access_from_pointer
id|link
c_func
(paren
id|dest
comma
id|dirp
comma
id|fname
comma
id|len
)paren
suffix:semicolon
id|fh_unlock
c_func
(paren
id|ffhp
)paren
suffix:semicolon
multiline_comment|/* unlock inode */
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|EX_ISSYNC
c_func
(paren
id|ffhp-&gt;fh_export
)paren
)paren
(brace
id|nfsd_write_inode
c_func
(paren
id|dirp
)paren
suffix:semicolon
id|nfsd_write_inode
c_func
(paren
id|dest
)paren
suffix:semicolon
)brace
r_return
id|err
ques
c_cond
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Rename a file&n; */
r_int
DECL|function|nfsd_rename
id|nfsd_rename
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|ffhp
comma
r_char
op_star
id|fname
comma
r_int
id|flen
comma
r_struct
id|svc_fh
op_star
id|tfhp
comma
r_char
op_star
id|tname
comma
r_int
id|tlen
)paren
(brace
r_struct
id|inode
op_star
id|fdir
comma
op_star
id|tdir
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|fh_lookup
c_func
(paren
id|rqstp
comma
id|ffhp
comma
id|S_IFDIR
comma
id|MAY_REMOVE
)paren
op_ne
l_int|0
)paren
op_logical_or
(paren
id|err
op_assign
id|fh_lookup
c_func
(paren
id|rqstp
comma
id|tfhp
comma
id|S_IFDIR
comma
id|MAY_CREATE
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|fdir
op_assign
id|ffhp-&gt;fh_inode
suffix:semicolon
id|tdir
op_assign
id|tfhp-&gt;fh_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flen
op_logical_or
(paren
id|fname
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
(paren
id|flen
op_eq
l_int|1
op_logical_or
(paren
id|flen
op_eq
l_int|2
op_logical_and
id|fname
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
)paren
)paren
op_logical_or
op_logical_neg
id|tlen
op_logical_or
(paren
id|tname
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
(paren
id|tlen
op_eq
l_int|1
op_logical_or
(paren
id|tlen
op_eq
l_int|2
op_logical_and
id|tname
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
)paren
)paren
)paren
r_return
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
id|fdir-&gt;i_dev
op_ne
id|tdir-&gt;i_dev
)paren
r_return
id|nfserr_acces
suffix:semicolon
multiline_comment|/* nfserr_nxdev */
r_if
c_cond
(paren
op_logical_neg
id|fdir-&gt;i_op
op_logical_or
op_logical_neg
id|fdir-&gt;i_op-&gt;rename
)paren
r_return
id|nfserr_perm
suffix:semicolon
id|fh_lock
c_func
(paren
id|tfhp
)paren
suffix:semicolon
multiline_comment|/* lock destination directory */
id|tdir-&gt;i_count
op_increment
suffix:semicolon
id|fdir-&gt;i_count
op_increment
suffix:semicolon
id|err
op_assign
id|fdir-&gt;i_op
op_member_access_from_pointer
id|rename
c_func
(paren
id|fdir
comma
id|fname
comma
id|flen
comma
id|tdir
comma
id|tname
comma
id|tlen
comma
l_int|0
)paren
suffix:semicolon
id|fh_unlock
c_func
(paren
id|tfhp
)paren
suffix:semicolon
multiline_comment|/* unlock inode */
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|EX_ISSYNC
c_func
(paren
id|tfhp-&gt;fh_export
)paren
)paren
(brace
id|nfsd_write_inode
c_func
(paren
id|fdir
)paren
suffix:semicolon
id|nfsd_write_inode
c_func
(paren
id|tdir
)paren
suffix:semicolon
)brace
r_return
id|err
ques
c_cond
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Unlink a file or directory&n; */
r_int
DECL|function|nfsd_unlink
id|nfsd_unlink
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_int
id|type
comma
r_char
op_star
id|fname
comma
r_int
id|flen
)paren
(brace
r_struct
id|inode
op_star
id|dirp
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flen
op_logical_or
id|isdotent
c_func
(paren
id|fname
comma
id|flen
)paren
)paren
r_return
id|nfserr_acces
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|fh_lookup
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFDIR
comma
id|MAY_REMOVE
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|fh_lock
c_func
(paren
id|fhp
)paren
suffix:semicolon
multiline_comment|/* lock inode */
id|dirp
op_assign
id|fhp-&gt;fh_inode
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|S_IFDIR
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dirp-&gt;i_op
op_logical_or
op_logical_neg
id|dirp-&gt;i_op-&gt;rmdir
)paren
r_return
id|nfserr_notdir
suffix:semicolon
id|dirp-&gt;i_count
op_increment
suffix:semicolon
id|err
op_assign
id|dirp-&gt;i_op
op_member_access_from_pointer
id|rmdir
c_func
(paren
id|dirp
comma
id|fname
comma
id|flen
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* other than S_IFDIR */
r_if
c_cond
(paren
op_logical_neg
id|dirp-&gt;i_op
op_logical_or
op_logical_neg
id|dirp-&gt;i_op-&gt;unlink
)paren
r_return
id|nfserr_perm
suffix:semicolon
id|dirp-&gt;i_count
op_increment
suffix:semicolon
id|err
op_assign
id|dirp-&gt;i_op
op_member_access_from_pointer
id|unlink
c_func
(paren
id|dirp
comma
id|fname
comma
id|flen
)paren
suffix:semicolon
)brace
id|fh_unlock
c_func
(paren
id|fhp
)paren
suffix:semicolon
multiline_comment|/* unlock inode */
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|EX_ISSYNC
c_func
(paren
id|fhp-&gt;fh_export
)paren
)paren
id|nfsd_write_inode
c_func
(paren
id|dirp
)paren
suffix:semicolon
r_return
id|err
ques
c_cond
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read entries from a directory.&n; */
r_int
DECL|function|nfsd_readdir
id|nfsd_readdir
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
id|loff_t
id|offset
comma
id|encode_dent_fn
id|func
comma
id|u32
op_star
id|buffer
comma
r_int
op_star
id|countp
)paren
(brace
r_struct
id|readdir_cd
id|cd
suffix:semicolon
r_struct
id|file
id|file
suffix:semicolon
id|u32
op_star
id|p
suffix:semicolon
r_int
id|oldlen
comma
id|eof
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
op_complement
(paren
id|u32
)paren
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|nfsd_open
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFDIR
comma
id|OPEN_READ
comma
op_amp
id|file
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file.f_op-&gt;readdir
)paren
(brace
id|nfsd_close
c_func
(paren
op_amp
id|file
)paren
suffix:semicolon
r_return
id|nfserr_notdir
suffix:semicolon
)brace
id|file.f_pos
op_assign
id|offset
suffix:semicolon
multiline_comment|/* Set up the readdir context */
id|memset
c_func
(paren
op_amp
id|cd
comma
l_int|0
comma
r_sizeof
(paren
id|cd
)paren
)paren
suffix:semicolon
id|cd.rqstp
op_assign
id|rqstp
suffix:semicolon
id|cd.buffer
op_assign
id|buffer
suffix:semicolon
id|cd.buflen
op_assign
op_star
id|countp
op_rshift
l_int|2
suffix:semicolon
multiline_comment|/*&n;&t; * Read the directory entries. This silly loop is necessary because&n;&t; * readdir() is not guaranteed to fill up the entire buffer, but&n;&t; * may choose to do less.&n;&t; */
r_do
(brace
id|oldlen
op_assign
id|cd.buflen
suffix:semicolon
multiline_comment|/*&n;&t;&t;dprintk(&quot;nfsd: f_op-&gt;readdir(%x/%ld @ %d) buflen = %d (%d)&bslash;n&quot;,&n;&t;&t;&t;file.f_inode-&gt;i_dev, file.f_inode-&gt;i_ino,&n;&t;&t;&t;(int) file.f_pos, (int) oldlen, (int) cd.buflen);&n;&t;&t; */
id|err
op_assign
id|file.f_op
op_member_access_from_pointer
id|readdir
c_func
(paren
id|file.f_inode
comma
op_amp
id|file
comma
op_amp
id|cd
comma
(paren
id|filldir_t
)paren
id|func
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|nfsd_close
c_func
(paren
op_amp
id|file
)paren
suffix:semicolon
r_return
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|oldlen
op_eq
id|cd.buflen
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|oldlen
op_ne
id|cd.buflen
op_logical_and
op_logical_neg
id|cd.eob
)paren
suffix:semicolon
multiline_comment|/* If we didn&squot;t fill the buffer completely, we&squot;re at EOF */
id|eof
op_assign
op_logical_neg
id|cd.eob
suffix:semicolon
multiline_comment|/* Hewlett Packard ignores the eof flag on READDIR. Some&n;&t; * fs-specific readdir implementations seem to reset f_pos to 0&n;&t; * at EOF however, causing an endless loop. */
r_if
c_cond
(paren
id|cd.offset
op_logical_and
op_logical_neg
id|eof
)paren
op_star
id|cd.offset
op_assign
id|htonl
c_func
(paren
id|file.f_pos
)paren
suffix:semicolon
multiline_comment|/* Close the file */
id|nfsd_close
c_func
(paren
op_amp
id|file
)paren
suffix:semicolon
id|p
op_assign
id|cd.buffer
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no more entries */
op_star
id|p
op_increment
op_assign
id|htonl
c_func
(paren
id|eof
)paren
suffix:semicolon
multiline_comment|/* end of directory */
op_star
id|countp
op_assign
(paren
id|caddr_t
)paren
id|p
op_minus
(paren
id|caddr_t
)paren
id|buffer
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;nfsd: readdir result %d bytes, eof %d offset %ld&bslash;n&quot;
comma
op_star
id|countp
comma
id|eof
comma
id|cd.offset
ques
c_cond
id|ntohl
c_func
(paren
op_star
id|cd.offset
)paren
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get file system stats&n; */
r_int
DECL|function|nfsd_statfs
id|nfsd_statfs
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_struct
id|statfs
op_star
id|stat
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
r_int
r_int
id|oldfs
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|fh_lookup
c_func
(paren
id|rqstp
comma
id|fhp
comma
l_int|0
comma
id|MAY_NOP
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|inode
op_assign
id|fhp-&gt;fh_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sb
op_assign
id|inode-&gt;i_sb
)paren
op_logical_or
op_logical_neg
id|sb-&gt;s_op-&gt;statfs
)paren
r_return
id|nfserr_io
suffix:semicolon
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|sb-&gt;s_op
op_member_access_from_pointer
id|statfs
c_func
(paren
id|sb
comma
id|stat
comma
r_sizeof
(paren
op_star
id|stat
)paren
)paren
suffix:semicolon
id|set_fs
(paren
id|oldfs
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Check for a user&squot;s access permissions to this inode.&n; */
r_int
DECL|function|nfsd_permission
id|nfsd_permission
c_func
(paren
r_struct
id|svc_export
op_star
id|exp
comma
r_struct
id|inode
op_star
id|inode
comma
r_int
id|acc
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|acc
op_eq
id|MAY_NOP
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;dprintk(&quot;nfsd: permission 0x%x%s%s%s%s%s mode 0%o%s%s%s&bslash;n&quot;,&n;&t;&t;acc,&n;&t;&t;(acc &amp; MAY_READ)?&t;&quot; read&quot;  : &quot;&quot;,&n;&t;&t;(acc &amp; MAY_WRITE)?&t;&quot; write&quot; : &quot;&quot;,&n;&t;&t;(acc &amp; MAY_EXEC)?&t;&quot; exec&quot;  : &quot;&quot;,&n;&t;&t;(acc &amp; MAY_SATTR)?&t;&quot; sattr&quot; : &quot;&quot;,&n;&t;&t;(acc &amp; MAY_TRUNC)?&t;&quot; trunc&quot; : &quot;&quot;,&n;&t;&t;inode-&gt;i_mode,&n;&t;&t;IS_IMMUTABLE(inode)?&t;&quot; immut&quot; : &quot;&quot;,&n;&t;&t;IS_APPEND(inode)?&t;&quot; append&quot; : &quot;&quot;,&n;&t;&t;IS_RDONLY(inode)?&t;&quot; ro&quot; : &quot;&quot;);&n;&t;dprintk(&quot;      owner %d/%d user %d/%d&bslash;n&quot;,&n;&t;&t;inode-&gt;i_uid, inode-&gt;i_gid, current-&gt;fsuid, current-&gt;fsgid);&n;&t; */
r_if
c_cond
(paren
id|acc
op_amp
(paren
id|MAY_WRITE
op_or
id|MAY_SATTR
op_or
id|MAY_TRUNC
)paren
)paren
(brace
r_if
c_cond
(paren
id|EX_RDONLY
c_func
(paren
id|exp
)paren
op_logical_or
id|IS_RDONLY
c_func
(paren
id|inode
)paren
)paren
r_return
id|nfserr_rofs
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
id|nfsd_iscovered
c_func
(paren
id|inode
)paren
)paren
r_return
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
multiline_comment|/* (acc &amp; MAY_WRITE) &amp;&amp; */
id|IS_IMMUTABLE
c_func
(paren
id|inode
)paren
)paren
r_return
id|nfserr_perm
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|acc
op_amp
id|MAY_TRUNC
)paren
op_logical_and
id|IS_APPEND
c_func
(paren
id|inode
)paren
)paren
r_return
id|nfserr_perm
suffix:semicolon
multiline_comment|/*&n;&t; * The file owner always gets access permission. This is to make&n;&t; * file access work even when the client has done a fchmod(fd, 0).&n;&t; *&n;&t; * However, `cp foo bar&squot; should fail nevertheless when bar is&n;&t; * readonly. A sensible way to do this might be to reject all&n;&t; * attempts to truncate a read-only file, because a creat() call&n;&t; * always implies file truncation.&n;&t; */
r_if
c_cond
(paren
id|inode-&gt;i_uid
op_eq
id|current-&gt;fsuid
multiline_comment|/* &amp;&amp; !(acc &amp; MAY_TRUNC) */
)paren
r_return
l_int|0
suffix:semicolon
id|err
op_assign
id|permission
c_func
(paren
id|inode
comma
id|acc
op_amp
(paren
id|MAY_READ
op_or
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
)paren
suffix:semicolon
multiline_comment|/* Allow read access to binaries even when mode 111 */
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EPERM
op_logical_and
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
id|acc
op_eq
id|MAY_READ
)paren
id|err
op_assign
id|permission
c_func
(paren
id|inode
comma
id|MAY_EXEC
)paren
suffix:semicolon
r_return
id|err
ques
c_cond
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up the inode for a given FH.&n; */
r_struct
id|inode
op_star
DECL|function|nfsd_iget
id|nfsd_iget
c_func
(paren
id|dev_t
id|dev
comma
id|ino_t
id|ino
)paren
(brace
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sb
op_assign
id|get_super
c_func
(paren
id|dev
)paren
)paren
op_logical_or
id|fs_off_limits
c_func
(paren
id|sb
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|__iget
c_func
(paren
id|sb
comma
id|ino
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Write the inode if dirty (copy of fs/inode.c:write_inode)&n; */
r_void
DECL|function|nfsd_write_inode
id|nfsd_write_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|inode-&gt;i_sb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_dirt
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|inode-&gt;i_lock
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|inode-&gt;i_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_dirt
)paren
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|sb
op_logical_or
op_logical_neg
id|sb-&gt;s_op
op_logical_or
op_logical_neg
id|sb-&gt;s_op-&gt;write_inode
)paren
(brace
id|inode-&gt;i_dirt
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|inode-&gt;i_lock
op_assign
l_int|1
suffix:semicolon
id|sb-&gt;s_op
op_member_access_from_pointer
id|write_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|inode-&gt;i_lock
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|inode-&gt;i_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up the root inode of the parent fs.&n; * We have to go through iget in order to allow for wait_on_inode.&n; */
r_int
DECL|function|nfsd_parentdev
id|nfsd_parentdev
c_func
(paren
id|dev_t
op_star
id|devp
)paren
(brace
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sb
op_assign
id|get_super
c_func
(paren
op_star
id|devp
)paren
)paren
op_logical_or
op_logical_neg
id|sb-&gt;s_covered
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|devp
op_eq
id|sb-&gt;s_covered-&gt;i_dev
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|devp
op_assign
id|sb-&gt;s_covered-&gt;i_dev
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Duplicated here from fs/super.c because it&squot;s not exported */
r_static
r_struct
id|super_block
op_star
DECL|function|get_super
id|get_super
c_func
(paren
id|dev_t
id|dev
)paren
(brace
r_struct
id|super_block
op_star
id|s
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
l_int|NULL
suffix:semicolon
id|s
op_assign
l_int|0
op_plus
id|super_blocks
suffix:semicolon
r_while
c_loop
(paren
id|s
OL
id|NR_SUPER
op_plus
id|super_blocks
)paren
r_if
c_cond
(paren
id|s-&gt;s_dev
op_eq
id|dev
)paren
(brace
id|wait_on_super
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;s_dev
op_eq
id|dev
)paren
r_return
id|s
suffix:semicolon
id|s
op_assign
l_int|0
op_plus
id|super_blocks
suffix:semicolon
)brace
r_else
id|s
op_increment
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a copy from fs/inode.c because it wasn&squot;t exported.&n; */
r_int
DECL|function|nfsd_notify_change
id|nfsd_notify_change
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|iattr
op_star
id|attr
)paren
(brace
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_sb
op_logical_and
id|inode-&gt;i_sb-&gt;s_op
op_logical_and
id|inode-&gt;i_sb-&gt;s_op-&gt;notify_change
)paren
r_return
id|inode-&gt;i_sb-&gt;s_op
op_member_access_from_pointer
id|notify_change
c_func
(paren
id|inode
comma
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|retval
op_assign
id|inode_change_ok
c_func
(paren
id|inode
comma
id|attr
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|retval
suffix:semicolon
id|inode_setattr
c_func
(paren
id|inode
comma
id|attr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize readahead param cache&n; */
r_void
DECL|function|nfsd_racache_init
id|nfsd_racache_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|raparm_cache
)paren
r_return
suffix:semicolon
id|memset
c_func
(paren
id|raparms
comma
l_int|0
comma
r_sizeof
(paren
id|raparms
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FILECACHE_MAX
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|raparms
(braket
id|i
)braket
dot
id|p_next
op_assign
id|raparms
op_plus
id|i
op_plus
l_int|1
suffix:semicolon
)brace
id|raparm_cache
op_assign
id|raparms
suffix:semicolon
)brace
eof
