DECL|macro|MSNFS
mdefine_line|#define MSNFS&t;/* HACK HACK */
multiline_comment|/*&n; * linux/fs/nfsd/vfs.c&n; *&n; * File operations used by nfsd. Some of these have been ripped from&n; * other parts of the kernel because they weren&squot;t in ksyms.c, others&n; * are partial duplicates with added or changed functionality.&n; *&n; * Note that several functions dget() the dentry upon which they want&n; * to act, most notably those that create directory entries. Response&n; * dentry&squot;s are dput()&squot;d if necessary in the release callback.&n; * So if you notice code paths that apparently fail to dput() the&n; * dentry, don&squot;t worry--they have been taken care of.&n; *&n; * Copyright (C) 1995-1999 Olaf Kirch &lt;okir@monad.swb.de&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/ext2_fs.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/in.h&gt;
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sunrpc/svc.h&gt;
macro_line|#include &lt;linux/nfsd/nfsd.h&gt;
macro_line|#ifdef CONFIG_NFSD_V3
macro_line|#include &lt;linux/nfs3.h&gt;
macro_line|#include &lt;linux/nfsd/xdr3.h&gt;
macro_line|#endif /* CONFIG_NFSD_V3 */
macro_line|#include &lt;linux/nfsd/nfsfh.h&gt;
macro_line|#include &lt;linux/quotaops.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|NFSDDBG_FACILITY
mdefine_line|#define NFSDDBG_FACILITY&t;&t;NFSDDBG_FILEOP
DECL|macro|NFSD_PARANOIA
mdefine_line|#define NFSD_PARANOIA
multiline_comment|/* We must ignore files (but only files) which might have mandatory&n; * locks on them because there is no way to know if the accesser has&n; * the lock.&n; */
DECL|macro|IS_ISMNDLK
mdefine_line|#define IS_ISMNDLK(i)&t;(S_ISREG((i)-&gt;i_mode) &amp;&amp; MANDATORY_LOCK(i))
multiline_comment|/*&n; * This is a cache of readahead params that help us choose the proper&n; * readahead strategy. Initially, we set all readahead parameters to 0&n; * and let the VFS handle things.&n; * If you increase the number of cached files very much, you&squot;ll need to&n; * add a hash table here.&n; */
DECL|struct|raparms
r_struct
id|raparms
(brace
DECL|member|p_next
r_struct
id|raparms
op_star
id|p_next
suffix:semicolon
DECL|member|p_count
r_int
r_int
id|p_count
suffix:semicolon
DECL|member|p_ino
id|ino_t
id|p_ino
suffix:semicolon
DECL|member|p_dev
id|dev_t
id|p_dev
suffix:semicolon
DECL|member|p_reada
r_int
r_int
id|p_reada
comma
DECL|member|p_ramax
id|p_ramax
comma
DECL|member|p_raend
id|p_raend
comma
DECL|member|p_ralen
id|p_ralen
comma
DECL|member|p_rawin
id|p_rawin
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|raparml
r_static
r_struct
id|raparms
op_star
id|raparml
suffix:semicolon
DECL|variable|raparm_cache
r_static
r_struct
id|raparms
op_star
id|raparm_cache
suffix:semicolon
multiline_comment|/*&n; * Look up one component of a pathname.&n; * N.B. After this call _both_ fhp and resfh need an fh_put&n; *&n; * If the lookup would cross a mountpoint, and the mounted filesystem&n; * is exported to the client with NFSEXP_CROSSMNT, then the lookup is&n; * accepted as it stands and the mounted directory is&n; * returned. Otherwise the covered directory is returned.&n; * NOTE: this mountpoint crossing is not supported properly by all&n; *   clients and is explicitly disallowed for NFSv3&n; *      NeilBrown &lt;neilb@cse.unsw.edu.au&gt;&n; */
r_int
DECL|function|nfsd_lookup
id|nfsd_lookup
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
r_struct
id|svc_fh
op_star
id|resfh
)paren
(brace
r_struct
id|svc_export
op_star
id|exp
suffix:semicolon
r_struct
id|dentry
op_star
id|dparent
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_int
id|err
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;nfsd: nfsd_lookup(fh %s, %s)&bslash;n&quot;
comma
id|SVCFH_fmt
c_func
(paren
id|fhp
)paren
comma
id|name
)paren
suffix:semicolon
multiline_comment|/* Obtain dentry and export. */
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFDIR
comma
id|MAY_EXEC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|dparent
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|exp
op_assign
id|fhp-&gt;fh_export
suffix:semicolon
id|err
op_assign
id|nfserr_acces
suffix:semicolon
multiline_comment|/* Lookup the name, but don&squot;t follow links */
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;.&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|dentry
op_assign
id|dget
c_func
(paren
id|dparent
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;..&quot;
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* checking mountpoint crossing is very different when stepping up */
r_if
c_cond
(paren
id|dparent
op_eq
id|exp-&gt;ex_dentry
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|EX_CROSSMNT
c_func
(paren
id|exp
)paren
)paren
id|dentry
op_assign
id|dget
c_func
(paren
id|dparent
)paren
suffix:semicolon
multiline_comment|/* .. == . just like at / */
r_else
(brace
r_struct
id|svc_export
op_star
id|exp2
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|dentry
op_star
id|dp
suffix:semicolon
r_struct
id|vfsmount
op_star
id|mnt
op_assign
id|mntget
c_func
(paren
id|exp-&gt;ex_mnt
)paren
suffix:semicolon
id|dentry
op_assign
id|dget
c_func
(paren
id|dparent
)paren
suffix:semicolon
r_while
c_loop
(paren
id|follow_up
c_func
(paren
op_amp
id|mnt
comma
op_amp
id|dentry
)paren
)paren
(brace
suffix:semicolon
)brace
id|dp
op_assign
id|dget
c_func
(paren
id|dentry-&gt;d_parent
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|dentry
op_assign
id|dp
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|exp2
op_eq
l_int|NULL
op_logical_and
id|dp-&gt;d_parent
op_ne
id|dp
suffix:semicolon
id|dp
op_assign
id|dp-&gt;d_parent
)paren
id|exp2
op_assign
id|exp_get
c_func
(paren
id|exp-&gt;ex_client
comma
id|dp-&gt;d_inode-&gt;i_dev
comma
id|dp-&gt;d_inode-&gt;i_ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exp2
op_eq
l_int|NULL
)paren
(brace
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|dentry
op_assign
id|dget
c_func
(paren
id|dparent
)paren
suffix:semicolon
)brace
r_else
(brace
id|exp
op_assign
id|exp2
suffix:semicolon
)brace
id|mntput
c_func
(paren
id|mnt
)paren
suffix:semicolon
)brace
)brace
r_else
id|dentry
op_assign
id|dget
c_func
(paren
id|dparent-&gt;d_parent
)paren
suffix:semicolon
)brace
r_else
(brace
id|fh_lock
c_func
(paren
id|fhp
)paren
suffix:semicolon
id|dentry
op_assign
id|lookup_one
c_func
(paren
id|name
comma
id|dparent
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
r_goto
id|out_nfserr
suffix:semicolon
multiline_comment|/*&n;&t;&t; * check if we have crossed a mount point ...&n;&t;&t; */
r_if
c_cond
(paren
id|d_mountpoint
c_func
(paren
id|dentry
)paren
)paren
(brace
r_struct
id|svc_export
op_star
id|exp2
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|vfsmount
op_star
id|mnt
op_assign
id|mntget
c_func
(paren
id|exp-&gt;ex_mnt
)paren
suffix:semicolon
r_struct
id|dentry
op_star
id|mounts
op_assign
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_while
c_loop
(paren
id|follow_down
c_func
(paren
op_amp
id|mnt
comma
op_amp
id|mounts
)paren
op_logical_and
id|d_mountpoint
c_func
(paren
id|mounts
)paren
)paren
suffix:semicolon
id|exp2
op_assign
id|exp_get
c_func
(paren
id|rqstp-&gt;rq_client
comma
id|mounts-&gt;d_inode-&gt;i_dev
comma
id|mounts-&gt;d_inode-&gt;i_ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exp2
op_logical_and
id|EX_CROSSMNT
c_func
(paren
id|exp2
)paren
)paren
(brace
multiline_comment|/* successfully crossed mount point */
id|exp
op_assign
id|exp2
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|dentry
op_assign
id|mounts
suffix:semicolon
)brace
r_else
id|dput
c_func
(paren
id|mounts
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|mnt
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Note: we compose the file handle now, but as the&n;&t; * dentry may be negative, it may need to be updated.&n;&t; */
id|err
op_assign
id|fh_compose
c_func
(paren
id|resfh
comma
id|exp
comma
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
op_logical_neg
id|dentry-&gt;d_inode
)paren
id|err
op_assign
id|nfserr_noent
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out_nfserr
suffix:colon
id|err
op_assign
id|nfserrno
c_func
(paren
id|err
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Set various file attributes.&n; * N.B. After this call fhp needs an fh_put&n; */
r_int
DECL|function|nfsd_setattr
id|nfsd_setattr
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_struct
id|iattr
op_star
id|iap
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|accmode
op_assign
id|MAY_SATTR
suffix:semicolon
r_int
id|ftype
op_assign
l_int|0
suffix:semicolon
r_int
id|imode
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
id|size_change
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|iap-&gt;ia_valid
op_amp
(paren
id|ATTR_ATIME
op_or
id|ATTR_MTIME
op_or
id|ATTR_SIZE
)paren
)paren
id|accmode
op_or_assign
id|MAY_WRITE
op_or
id|MAY_OWNER_OVERRIDE
suffix:semicolon
r_if
c_cond
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_SIZE
)paren
id|ftype
op_assign
id|S_IFREG
suffix:semicolon
multiline_comment|/* Get inode */
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|ftype
comma
id|accmode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_or
op_logical_neg
id|iap-&gt;ia_valid
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|err
op_assign
id|inode_change_ok
c_func
(paren
id|inode
comma
id|iap
)paren
suffix:semicolon
multiline_comment|/* could be a &quot;touch&quot; (utimes) request where the user is not the owner but does&n;&t; * have write permission. In this case the user should be allowed to set&n;&t; * both times to the current time.  We could just assume any such SETATTR&n;&t; * is intended to set the times to &quot;now&quot;, but we do a couple of simple tests&n;&t; * to increase our confidence.&n;&t; */
DECL|macro|BOTH_TIME_SET
mdefine_line|#define BOTH_TIME_SET (ATTR_ATIME_SET | ATTR_MTIME_SET)
DECL|macro|MAX_TOUCH_TIME_ERROR
mdefine_line|#define&t;MAX_TOUCH_TIME_ERROR (30*60)
r_if
c_cond
(paren
id|err
op_logical_and
(paren
id|iap-&gt;ia_valid
op_amp
id|BOTH_TIME_SET
)paren
op_eq
id|BOTH_TIME_SET
op_logical_and
id|iap-&gt;ia_mtime
op_eq
id|iap-&gt;ia_ctime
)paren
(brace
multiline_comment|/* looks good.  now just make sure time is in the right ballpark.&n;&t;     * solaris, at least, doesn&squot;t seem to care what the time request is&n;&t;     */
id|time_t
id|delta
op_assign
id|iap-&gt;ia_atime
op_minus
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
id|delta
OL
l_int|0
)paren
id|delta
op_assign
op_minus
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|delta
OL
id|MAX_TOUCH_TIME_ERROR
)paren
(brace
multiline_comment|/* turn off ATTR_[AM]TIME_SET but leave ATTR_[AM]TIME&n;&t;&t; * this will cause notify_change to set these times to &quot;now&quot;&n;&t;&t; */
id|iap-&gt;ia_valid
op_and_assign
op_complement
id|BOTH_TIME_SET
suffix:semicolon
id|err
op_assign
id|inode_change_ok
c_func
(paren
id|inode
comma
id|iap
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_nfserr
suffix:semicolon
multiline_comment|/* The size case is special. It changes the file as well as the attributes.  */
r_if
c_cond
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_SIZE
)paren
(brace
r_if
c_cond
(paren
id|iap-&gt;ia_size
OL
id|inode-&gt;i_size
)paren
(brace
id|err
op_assign
id|nfsd_permission
c_func
(paren
id|fhp-&gt;fh_export
comma
id|dentry
comma
id|MAY_TRUNC
op_or
id|MAY_OWNER_OVERRIDE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we are changing the size of the file, then&n;&t;&t; * we need to break all leases.&n;&t;&t; */
id|err
op_assign
id|get_lease
c_func
(paren
id|inode
comma
id|FMODE_WRITE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_nfserr
suffix:semicolon
id|err
op_assign
id|get_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_nfserr
suffix:semicolon
id|err
op_assign
id|locks_verify_truncate
c_func
(paren
id|inode
comma
l_int|NULL
comma
id|iap-&gt;ia_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|put_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
r_goto
id|out_nfserr
suffix:semicolon
)brace
id|DQUOT_INIT
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
id|imode
op_assign
id|inode-&gt;i_mode
suffix:semicolon
r_if
c_cond
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_MODE
)paren
(brace
id|iap-&gt;ia_mode
op_and_assign
id|S_IALLUGO
suffix:semicolon
id|imode
op_assign
id|iap-&gt;ia_mode
op_or_assign
(paren
id|imode
op_amp
op_complement
id|S_IALLUGO
)paren
suffix:semicolon
)brace
multiline_comment|/* Revoke setuid/setgid bit on chown/chgrp */
r_if
c_cond
(paren
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_UID
)paren
op_logical_and
(paren
id|imode
op_amp
id|S_ISUID
)paren
op_logical_and
id|iap-&gt;ia_uid
op_ne
id|inode-&gt;i_uid
)paren
(brace
id|iap-&gt;ia_valid
op_or_assign
id|ATTR_MODE
suffix:semicolon
id|iap-&gt;ia_mode
op_assign
id|imode
op_and_assign
op_complement
id|S_ISUID
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_GID
)paren
op_logical_and
(paren
id|imode
op_amp
id|S_ISGID
)paren
op_logical_and
id|iap-&gt;ia_gid
op_ne
id|inode-&gt;i_gid
)paren
(brace
id|iap-&gt;ia_valid
op_or_assign
id|ATTR_MODE
suffix:semicolon
id|iap-&gt;ia_mode
op_assign
id|imode
op_and_assign
op_complement
id|S_ISGID
suffix:semicolon
)brace
multiline_comment|/* Change the attributes. */
id|iap-&gt;ia_valid
op_or_assign
id|ATTR_CTIME
suffix:semicolon
macro_line|#ifdef CONFIG_QUOTA
multiline_comment|/* DQUOT_TRANSFER needs both ia_uid and ia_gid defined */
r_if
c_cond
(paren
id|iap-&gt;ia_valid
op_amp
(paren
id|ATTR_UID
op_or
id|ATTR_GID
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_UID
)paren
)paren
id|iap-&gt;ia_uid
op_assign
id|inode-&gt;i_uid
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_GID
)paren
)paren
id|iap-&gt;ia_gid
op_assign
id|inode-&gt;i_gid
suffix:semicolon
id|iap-&gt;ia_valid
op_or_assign
id|ATTR_UID
op_or
id|ATTR_GID
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_QUOTA */
r_if
c_cond
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_SIZE
)paren
(brace
id|fh_lock
c_func
(paren
id|fhp
)paren
suffix:semicolon
id|size_change
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_QUOTA
r_if
c_cond
(paren
id|iap-&gt;ia_valid
op_amp
(paren
id|ATTR_UID
op_or
id|ATTR_GID
)paren
)paren
id|err
op_assign
id|DQUOT_TRANSFER
c_func
(paren
id|dentry
comma
id|iap
)paren
suffix:semicolon
r_else
macro_line|#endif
id|err
op_assign
id|notify_change
c_func
(paren
id|dentry
comma
id|iap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size_change
)paren
(brace
id|fh_unlock
c_func
(paren
id|fhp
)paren
suffix:semicolon
id|put_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_nfserr
suffix:semicolon
r_if
c_cond
(paren
id|EX_ISSYNC
c_func
(paren
id|fhp-&gt;fh_export
)paren
)paren
id|write_inode_now
c_func
(paren
id|inode
comma
l_int|1
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out_nfserr
suffix:colon
id|err
op_assign
id|nfserrno
c_func
(paren
id|err
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NFSD_V3
multiline_comment|/*&n; * Check server access rights to a file system object&n; */
DECL|struct|accessmap
r_struct
id|accessmap
(brace
DECL|member|access
id|u32
id|access
suffix:semicolon
DECL|member|how
r_int
id|how
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|nfs3_regaccess
r_static
r_struct
id|accessmap
id|nfs3_regaccess
(braket
)braket
op_assign
(brace
(brace
id|NFS3_ACCESS_READ
comma
id|MAY_READ
)brace
comma
(brace
id|NFS3_ACCESS_EXECUTE
comma
id|MAY_EXEC
)brace
comma
(brace
id|NFS3_ACCESS_MODIFY
comma
id|MAY_WRITE
op_or
id|MAY_TRUNC
)brace
comma
(brace
id|NFS3_ACCESS_EXTEND
comma
id|MAY_WRITE
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|nfs3_diraccess
r_static
r_struct
id|accessmap
id|nfs3_diraccess
(braket
)braket
op_assign
(brace
(brace
id|NFS3_ACCESS_READ
comma
id|MAY_READ
)brace
comma
(brace
id|NFS3_ACCESS_LOOKUP
comma
id|MAY_EXEC
)brace
comma
(brace
id|NFS3_ACCESS_MODIFY
comma
id|MAY_EXEC
op_or
id|MAY_WRITE
op_or
id|MAY_TRUNC
)brace
comma
(brace
id|NFS3_ACCESS_EXTEND
comma
id|MAY_EXEC
op_or
id|MAY_WRITE
)brace
comma
(brace
id|NFS3_ACCESS_DELETE
comma
id|MAY_REMOVE
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|nfs3_anyaccess
r_static
r_struct
id|accessmap
id|nfs3_anyaccess
(braket
)braket
op_assign
(brace
multiline_comment|/* Some clients - Solaris 2.6 at least, make an access call&n;&t; * to the server to check for access for things like /dev/null&n;&t; * (which really, the server doesn&squot;t care about).  So&n;&t; * We provide simple access checking for them, looking&n;&t; * mainly at mode bits&n;&t; */
(brace
id|NFS3_ACCESS_READ
comma
id|MAY_READ
)brace
comma
(brace
id|NFS3_ACCESS_EXECUTE
comma
id|MAY_EXEC
)brace
comma
(brace
id|NFS3_ACCESS_MODIFY
comma
id|MAY_WRITE
)brace
comma
(brace
id|NFS3_ACCESS_EXTEND
comma
id|MAY_WRITE
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
r_int
DECL|function|nfsd_access
id|nfsd_access
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
id|u32
op_star
id|access
)paren
(brace
r_struct
id|accessmap
op_star
id|map
suffix:semicolon
r_struct
id|svc_export
op_star
id|export
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|u32
id|query
comma
id|result
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|error
suffix:semicolon
id|error
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|fhp
comma
l_int|0
comma
id|MAY_NOP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|export
op_assign
id|fhp-&gt;fh_export
suffix:semicolon
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|dentry-&gt;d_inode-&gt;i_mode
)paren
)paren
id|map
op_assign
id|nfs3_regaccess
suffix:semicolon
r_else
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|dentry-&gt;d_inode-&gt;i_mode
)paren
)paren
id|map
op_assign
id|nfs3_diraccess
suffix:semicolon
r_else
id|map
op_assign
id|nfs3_anyaccess
suffix:semicolon
id|query
op_assign
op_star
id|access
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|map-&gt;access
suffix:semicolon
id|map
op_increment
)paren
(brace
r_if
c_cond
(paren
id|map-&gt;access
op_amp
id|query
)paren
(brace
r_int
r_int
id|err2
suffix:semicolon
id|err2
op_assign
id|nfsd_permission
c_func
(paren
id|export
comma
id|dentry
comma
id|map-&gt;how
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|err2
)paren
(brace
r_case
id|nfs_ok
suffix:colon
id|result
op_or_assign
id|map-&gt;access
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* the following error codes just mean the access was not allowed,&n;&t;&t;&t; * rather than an error occurred */
r_case
id|nfserr_rofs
suffix:colon
r_case
id|nfserr_acces
suffix:colon
r_case
id|nfserr_perm
suffix:colon
multiline_comment|/* simply don&squot;t &quot;or&quot; in the access bit. */
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
id|err2
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
)brace
op_star
id|access
op_assign
id|result
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_NFSD_V3 */
multiline_comment|/*&n; * Open an existing file or directory.&n; * The access argument indicates the type of open (read/write/lock)&n; * N.B. After this call fhp needs an fh_put&n; */
r_int
DECL|function|nfsd_open
id|nfsd_open
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_int
id|type
comma
r_int
id|access
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/* If we get here, then the client has already done an &quot;open&quot;, and (hopefully)&n;&t; * checked permission - so allow OWNER_OVERRIDE in case a chmod has now revoked&n;&t; * permission */
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|type
comma
id|access
op_or
id|MAY_OWNER_OVERRIDE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
multiline_comment|/* Disallow access to files with the append-only bit set or&n;&t; * with mandatory locking enabled&n;&t; */
id|err
op_assign
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|inode
)paren
op_logical_or
id|IS_ISMNDLK
c_func
(paren
id|inode
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_fop
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Check to see if there are any leases on this file.&n;&t; * This may block while leases are broken.&n;&t; */
id|err
op_assign
id|get_lease
c_func
(paren
id|inode
comma
(paren
id|access
op_amp
id|MAY_WRITE
)paren
ques
c_cond
id|FMODE_WRITE
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_nfserr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|access
op_amp
id|MAY_WRITE
)paren
op_logical_and
(paren
id|err
op_assign
id|get_write_access
c_func
(paren
id|inode
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|out_nfserr
suffix:semicolon
id|memset
c_func
(paren
id|filp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|filp
)paren
)paren
suffix:semicolon
id|filp-&gt;f_op
op_assign
id|fops_get
c_func
(paren
id|inode-&gt;i_fop
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|filp-&gt;f_count
comma
l_int|1
)paren
suffix:semicolon
id|filp-&gt;f_dentry
op_assign
id|dentry
suffix:semicolon
r_if
c_cond
(paren
id|access
op_amp
id|MAY_WRITE
)paren
(brace
id|filp-&gt;f_flags
op_assign
id|O_WRONLY
op_or
id|O_LARGEFILE
suffix:semicolon
id|filp-&gt;f_mode
op_assign
id|FMODE_WRITE
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_else
(brace
id|filp-&gt;f_flags
op_assign
id|O_RDONLY
op_or
id|O_LARGEFILE
suffix:semicolon
id|filp-&gt;f_mode
op_assign
id|FMODE_READ
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_op
op_logical_and
id|filp-&gt;f_op-&gt;open
)paren
(brace
id|err
op_assign
id|filp-&gt;f_op
op_member_access_from_pointer
id|open
c_func
(paren
id|inode
comma
id|filp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|fops_put
c_func
(paren
id|filp-&gt;f_op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|access
op_amp
id|MAY_WRITE
)paren
id|put_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/* I nearly added put_filp() call here, but this filp&n;&t;&t;&t; * is really on callers stack frame. -DaveM&n;&t;&t;&t; */
id|atomic_dec
c_func
(paren
op_amp
id|filp-&gt;f_count
)paren
suffix:semicolon
)brace
)brace
id|out_nfserr
suffix:colon
r_if
c_cond
(paren
id|err
)paren
id|err
op_assign
id|nfserrno
c_func
(paren
id|err
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Close a file.&n; */
r_void
DECL|function|nfsd_close
id|nfsd_close
c_func
(paren
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|filp-&gt;f_dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_op
op_logical_and
id|filp-&gt;f_op-&gt;release
)paren
id|filp-&gt;f_op
op_member_access_from_pointer
id|release
c_func
(paren
id|inode
comma
id|filp
)paren
suffix:semicolon
id|fops_put
c_func
(paren
id|filp-&gt;f_op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
id|put_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Sync a file&n; * As this calls fsync (not fdatasync) there is no need for a write_inode&n; * after it.&n; */
r_void
DECL|function|nfsd_sync
id|nfsd_sync
c_func
(paren
r_struct
id|file
op_star
id|filp
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;nfsd: sync file %s&bslash;n&quot;
comma
id|filp-&gt;f_dentry-&gt;d_name.name
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|filp-&gt;f_op
op_member_access_from_pointer
id|fsync
c_func
(paren
id|filp
comma
id|filp-&gt;f_dentry
comma
l_int|0
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
)brace
r_void
DECL|function|nfsd_sync_dir
id|nfsd_sync_dir
c_func
(paren
r_struct
id|dentry
op_star
id|dp
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dp-&gt;d_inode
suffix:semicolon
r_int
(paren
op_star
id|fsync
)paren
(paren
r_struct
id|file
op_star
comma
r_struct
id|dentry
op_star
comma
r_int
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_fop
op_logical_and
(paren
id|fsync
op_assign
id|inode-&gt;i_fop-&gt;fsync
)paren
)paren
(brace
id|fsync
c_func
(paren
l_int|NULL
comma
id|dp
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Obtain the readahead parameters for the file&n; * specified by (dev, ino).&n; */
r_static
r_inline
r_struct
id|raparms
op_star
DECL|function|nfsd_get_raparms
id|nfsd_get_raparms
c_func
(paren
id|dev_t
id|dev
comma
id|ino_t
id|ino
)paren
(brace
r_struct
id|raparms
op_star
id|ra
comma
op_star
op_star
id|rap
comma
op_star
op_star
id|frap
op_assign
l_int|NULL
suffix:semicolon
r_int
id|depth
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|rap
op_assign
op_amp
id|raparm_cache
suffix:semicolon
(paren
id|ra
op_assign
op_star
id|rap
)paren
suffix:semicolon
id|rap
op_assign
op_amp
id|ra-&gt;p_next
)paren
(brace
r_if
c_cond
(paren
id|ra-&gt;p_ino
op_eq
id|ino
op_logical_and
id|ra-&gt;p_dev
op_eq
id|dev
)paren
r_goto
id|found
suffix:semicolon
id|depth
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ra-&gt;p_count
op_eq
l_int|0
)paren
id|frap
op_assign
id|rap
suffix:semicolon
)brace
id|depth
op_assign
id|nfsdstats.ra_size
op_star
l_int|11
op_div
l_int|10
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|frap
)paren
r_return
l_int|NULL
suffix:semicolon
id|rap
op_assign
id|frap
suffix:semicolon
id|ra
op_assign
op_star
id|frap
suffix:semicolon
id|memset
c_func
(paren
id|ra
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ra
)paren
)paren
suffix:semicolon
id|ra-&gt;p_dev
op_assign
id|dev
suffix:semicolon
id|ra-&gt;p_ino
op_assign
id|ino
suffix:semicolon
id|found
suffix:colon
r_if
c_cond
(paren
id|rap
op_ne
op_amp
id|raparm_cache
)paren
(brace
op_star
id|rap
op_assign
id|ra-&gt;p_next
suffix:semicolon
id|ra-&gt;p_next
op_assign
id|raparm_cache
suffix:semicolon
id|raparm_cache
op_assign
id|ra
suffix:semicolon
)brace
id|ra-&gt;p_count
op_increment
suffix:semicolon
id|nfsdstats.ra_depth
(braket
id|depth
op_star
l_int|10
op_div
id|nfsdstats.ra_size
)braket
op_increment
suffix:semicolon
r_return
id|ra
suffix:semicolon
)brace
multiline_comment|/*&n; * Read data from a file. count must contain the requested read count&n; * on entry. On return, *count contains the number of bytes actually read.&n; * N.B. After this call fhp needs an fh_put&n; */
r_int
DECL|function|nfsd_read
id|nfsd_read
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
id|loff_t
id|offset
comma
r_char
op_star
id|buf
comma
r_int
r_int
op_star
id|count
)paren
(brace
r_struct
id|raparms
op_star
id|ra
suffix:semicolon
id|mm_segment_t
id|oldfs
suffix:semicolon
r_int
id|err
suffix:semicolon
r_struct
id|file
id|file
suffix:semicolon
id|err
op_assign
id|nfsd_open
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFREG
comma
id|MAY_READ
comma
op_amp
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file.f_op-&gt;read
)paren
r_goto
id|out_close
suffix:semicolon
macro_line|#ifdef MSNFS
r_if
c_cond
(paren
(paren
id|fhp-&gt;fh_export-&gt;ex_flags
op_amp
id|NFSEXP_MSNFS
)paren
op_logical_and
(paren
op_logical_neg
id|lock_may_read
c_func
(paren
id|file.f_dentry-&gt;d_inode
comma
id|offset
comma
op_star
id|count
)paren
)paren
)paren
r_goto
id|out_close
suffix:semicolon
macro_line|#endif
multiline_comment|/* Get readahead parameters */
id|ra
op_assign
id|nfsd_get_raparms
c_func
(paren
id|fhp-&gt;fh_export-&gt;ex_dev
comma
id|fhp-&gt;fh_dentry-&gt;d_inode-&gt;i_ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ra
)paren
(brace
id|file.f_reada
op_assign
id|ra-&gt;p_reada
suffix:semicolon
id|file.f_ramax
op_assign
id|ra-&gt;p_ramax
suffix:semicolon
id|file.f_raend
op_assign
id|ra-&gt;p_raend
suffix:semicolon
id|file.f_ralen
op_assign
id|ra-&gt;p_ralen
suffix:semicolon
id|file.f_rawin
op_assign
id|ra-&gt;p_rawin
suffix:semicolon
)brace
id|file.f_pos
op_assign
id|offset
suffix:semicolon
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|err
op_assign
id|file.f_op
op_member_access_from_pointer
id|read
c_func
(paren
op_amp
id|file
comma
id|buf
comma
op_star
id|count
comma
op_amp
id|file.f_pos
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
multiline_comment|/* Write back readahead params */
r_if
c_cond
(paren
id|ra
op_ne
l_int|NULL
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;nfsd: raparms %ld %ld %ld %ld %ld&bslash;n&quot;
comma
id|file.f_reada
comma
id|file.f_ramax
comma
id|file.f_raend
comma
id|file.f_ralen
comma
id|file.f_rawin
)paren
suffix:semicolon
id|ra-&gt;p_reada
op_assign
id|file.f_reada
suffix:semicolon
id|ra-&gt;p_ramax
op_assign
id|file.f_ramax
suffix:semicolon
id|ra-&gt;p_raend
op_assign
id|file.f_raend
suffix:semicolon
id|ra-&gt;p_ralen
op_assign
id|file.f_ralen
suffix:semicolon
id|ra-&gt;p_rawin
op_assign
id|file.f_rawin
suffix:semicolon
id|ra-&gt;p_count
op_sub_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
op_ge
l_int|0
)paren
(brace
id|nfsdstats.io_read
op_add_assign
id|err
suffix:semicolon
op_star
id|count
op_assign
id|err
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|err
op_assign
id|nfserrno
c_func
(paren
id|err
)paren
suffix:semicolon
id|out_close
suffix:colon
id|nfsd_close
c_func
(paren
op_amp
id|file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Write data to a file.&n; * The stable flag requests synchronous writes.&n; * N.B. After this call fhp needs an fh_put&n; */
r_int
DECL|function|nfsd_write
id|nfsd_write
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
id|loff_t
id|offset
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|cnt
comma
r_int
op_star
id|stablep
)paren
(brace
r_struct
id|svc_export
op_star
id|exp
suffix:semicolon
r_struct
id|file
id|file
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|mm_segment_t
id|oldfs
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|stable
op_assign
op_star
id|stablep
suffix:semicolon
id|err
op_assign
id|nfsd_open
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFREG
comma
id|MAY_WRITE
comma
op_amp
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cnt
)paren
r_goto
id|out_close
suffix:semicolon
id|err
op_assign
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file.f_op-&gt;write
)paren
r_goto
id|out_close
suffix:semicolon
macro_line|#ifdef MSNFS
r_if
c_cond
(paren
(paren
id|fhp-&gt;fh_export-&gt;ex_flags
op_amp
id|NFSEXP_MSNFS
)paren
op_logical_and
(paren
op_logical_neg
id|lock_may_write
c_func
(paren
id|file.f_dentry-&gt;d_inode
comma
id|offset
comma
id|cnt
)paren
)paren
)paren
r_goto
id|out_close
suffix:semicolon
macro_line|#endif
id|dentry
op_assign
id|file.f_dentry
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|exp
op_assign
id|fhp-&gt;fh_export
suffix:semicolon
multiline_comment|/*&n;&t; * Request sync writes if&n;&t; *  -&t;the sync export option has been set, or&n;&t; *  -&t;the client requested O_SYNC behavior (NFSv3 feature).&n;&t; *  -   The file system doesn&squot;t support fsync().&n;&t; * When gathered writes have been configured for this volume,&n;&t; * flushing the data to disk is handled separately below.&n;&t; */
r_if
c_cond
(paren
id|file.f_op-&gt;fsync
op_eq
l_int|0
)paren
(brace
multiline_comment|/* COMMIT3 cannot work */
id|stable
op_assign
l_int|2
suffix:semicolon
op_star
id|stablep
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* FILE_SYNC */
)brace
r_if
c_cond
(paren
op_logical_neg
id|EX_ISSYNC
c_func
(paren
id|exp
)paren
)paren
id|stable
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|stable
op_logical_and
op_logical_neg
id|EX_WGATHER
c_func
(paren
id|exp
)paren
)paren
id|file.f_flags
op_or_assign
id|O_SYNC
suffix:semicolon
id|file.f_pos
op_assign
id|offset
suffix:semicolon
multiline_comment|/* set write offset */
multiline_comment|/* Write the data. */
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|err
op_assign
id|file.f_op
op_member_access_from_pointer
id|write
c_func
(paren
op_amp
id|file
comma
id|buf
comma
id|cnt
comma
op_amp
id|file.f_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ge
l_int|0
)paren
id|nfsdstats.io_write
op_add_assign
id|cnt
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
multiline_comment|/* clear setuid/setgid flag after write */
r_if
c_cond
(paren
id|err
op_ge
l_int|0
op_logical_and
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_ISUID
op_or
id|S_ISGID
)paren
)paren
)paren
(brace
r_struct
id|iattr
id|ia
suffix:semicolon
id|ia.ia_valid
op_assign
id|ATTR_MODE
suffix:semicolon
id|ia.ia_mode
op_assign
id|inode-&gt;i_mode
op_amp
op_complement
(paren
id|S_ISUID
op_or
id|S_ISGID
)paren
suffix:semicolon
id|notify_change
c_func
(paren
id|dentry
comma
op_amp
id|ia
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
op_ge
l_int|0
op_logical_and
id|stable
)paren
(brace
r_static
r_int
r_int
id|last_ino
suffix:semicolon
r_static
id|kdev_t
id|last_dev
op_assign
id|NODEV
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Gathered writes: If another process is currently&n;&t;&t; * writing to the file, there&squot;s a high chance&n;&t;&t; * this is another nfsd (triggered by a bulk write&n;&t;&t; * from a client&squot;s biod). Rather than syncing the&n;&t;&t; * file with each write request, we sleep for 10 msec.&n;&t;&t; *&n;&t;&t; * I don&squot;t know if this roughly approximates&n;&t;&t; * C. Juszak&squot;s idea of gathered writes, but it&squot;s a&n;&t;&t; * nice and simple solution (IMHO), and it seems to&n;&t;&t; * work:-)&n;&t;&t; */
r_if
c_cond
(paren
id|EX_WGATHER
c_func
(paren
id|exp
)paren
op_logical_and
(paren
id|atomic_read
c_func
(paren
op_amp
id|inode-&gt;i_writecount
)paren
OG
l_int|1
op_logical_or
(paren
id|last_ino
op_eq
id|inode-&gt;i_ino
op_logical_and
id|last_dev
op_eq
id|inode-&gt;i_dev
)paren
)paren
)paren
(brace
macro_line|#if 0
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|inode-&gt;i_wait
comma
l_int|10
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
macro_line|#else
id|dprintk
c_func
(paren
l_string|&quot;nfsd: write defer %d&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
multiline_comment|/* FIXME: Olaf commented this out [gam3] */
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
(paren
id|HZ
op_plus
l_int|99
)paren
op_div
l_int|100
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;nfsd: write resume %d&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|inode-&gt;i_state
op_amp
id|I_DIRTY
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;nfsd: write sync %d&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|nfsd_sync
c_func
(paren
op_amp
id|file
)paren
suffix:semicolon
)brace
macro_line|#if 0
id|wake_up
c_func
(paren
op_amp
id|inode-&gt;i_wait
)paren
suffix:semicolon
macro_line|#endif
id|last_ino
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|last_dev
op_assign
id|inode-&gt;i_dev
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;nfsd: write complete err=%d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ge
l_int|0
)paren
id|err
op_assign
l_int|0
suffix:semicolon
r_else
id|err
op_assign
id|nfserrno
c_func
(paren
id|err
)paren
suffix:semicolon
id|out_close
suffix:colon
id|nfsd_close
c_func
(paren
op_amp
id|file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NFSD_V3
multiline_comment|/*&n; * Commit all pending writes to stable storage.&n; * Strictly speaking, we could sync just the indicated file region here,&n; * but there&squot;s currently no way we can ask the VFS to do so.&n; *&n; * Unfortunately we cannot lock the file to make sure we return full WCC&n; * data to the client, as locking happens lower down in the filesystem.&n; */
r_int
DECL|function|nfsd_commit
id|nfsd_commit
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
id|off_t
id|offset
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|file
id|file
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|nfsd_open
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFREG
comma
id|MAY_WRITE
comma
op_amp
id|file
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|EX_ISSYNC
c_func
(paren
id|fhp-&gt;fh_export
)paren
)paren
(brace
r_if
c_cond
(paren
id|file.f_op
op_logical_and
id|file.f_op-&gt;fsync
)paren
(brace
id|nfsd_sync
c_func
(paren
op_amp
id|file
)paren
suffix:semicolon
)brace
r_else
(brace
id|err
op_assign
id|nfserr_notsupp
suffix:semicolon
)brace
)brace
id|nfsd_close
c_func
(paren
op_amp
id|file
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_NFSD_V3 */
multiline_comment|/*&n; * Create a file (regular, directory, device, fifo); UNIX sockets &n; * not yet implemented.&n; * If the response fh has been verified, the parent directory should&n; * already be locked. Note that the parent directory is left locked.&n; *&n; * N.B. Every call to nfsd_create needs an fh_put for _both_ fhp and resfhp&n; */
r_int
DECL|function|nfsd_create
id|nfsd_create
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_char
op_star
id|fname
comma
r_int
id|flen
comma
r_struct
id|iattr
op_star
id|iap
comma
r_int
id|type
comma
id|dev_t
id|rdev
comma
r_struct
id|svc_fh
op_star
id|resfhp
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
comma
op_star
id|dchild
suffix:semicolon
r_struct
id|inode
op_star
id|dirp
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flen
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|nfserr_exist
suffix:semicolon
r_if
c_cond
(paren
id|isdotent
c_func
(paren
id|fname
comma
id|flen
)paren
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFDIR
comma
id|MAY_CREATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|dirp
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|err
op_assign
id|nfserr_notdir
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dirp-&gt;i_op
op_logical_or
op_logical_neg
id|dirp-&gt;i_op-&gt;lookup
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check whether the response file handle has been verified yet.&n;&t; * If it has, the parent directory should already be locked.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|resfhp-&gt;fh_dentry
)paren
(brace
multiline_comment|/* called from nfsd_proc_mkdir, or possibly nfsd3_proc_create */
id|fh_lock
c_func
(paren
id|fhp
)paren
suffix:semicolon
id|dchild
op_assign
id|lookup_one
c_func
(paren
id|fname
comma
id|dentry
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|dchild
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dchild
)paren
)paren
r_goto
id|out_nfserr
suffix:semicolon
id|err
op_assign
id|fh_compose
c_func
(paren
id|resfhp
comma
id|fhp-&gt;fh_export
comma
id|dchild
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* called from nfsd_proc_create */
id|dchild
op_assign
id|resfhp-&gt;fh_dentry
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fhp-&gt;fh_locked
)paren
(brace
multiline_comment|/* not actually possible */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;nfsd_create: parent %s/%s not locked!&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Make sure the child dentry is still negative ...&n;&t; */
id|err
op_assign
id|nfserr_exist
suffix:semicolon
r_if
c_cond
(paren
id|dchild-&gt;d_inode
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;nfsd_create: dentry %s/%s not negative!&bslash;n&quot;
comma
id|dentry-&gt;d_name.name
comma
id|dchild-&gt;d_name.name
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_MODE
)paren
)paren
id|iap-&gt;ia_mode
op_assign
l_int|0
suffix:semicolon
id|iap-&gt;ia_mode
op_assign
(paren
id|iap-&gt;ia_mode
op_amp
id|S_IALLUGO
)paren
op_or
id|type
suffix:semicolon
multiline_comment|/*&n;&t; * Get the dir op function pointer.&n;&t; */
id|err
op_assign
id|nfserr_perm
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|S_IFREG
suffix:colon
id|err
op_assign
id|vfs_create
c_func
(paren
id|dirp
comma
id|dchild
comma
id|iap-&gt;ia_mode
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFDIR
suffix:colon
id|err
op_assign
id|vfs_mkdir
c_func
(paren
id|dirp
comma
id|dchild
comma
id|iap-&gt;ia_mode
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFCHR
suffix:colon
r_case
id|S_IFBLK
suffix:colon
r_case
id|S_IFIFO
suffix:colon
r_case
id|S_IFSOCK
suffix:colon
id|err
op_assign
id|vfs_mknod
c_func
(paren
id|dirp
comma
id|dchild
comma
id|iap-&gt;ia_mode
comma
id|rdev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;nfsd: bad file type %o in nfsd_create&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_nfserr
suffix:semicolon
r_if
c_cond
(paren
id|EX_ISSYNC
c_func
(paren
id|fhp-&gt;fh_export
)paren
)paren
(brace
id|nfsd_sync_dir
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|write_inode_now
c_func
(paren
id|dchild-&gt;d_inode
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Set file attributes. Mode has already been set and&n;&t; * setting uid/gid works only for root. Irix appears to&n;&t; * send along the gid when it tries to implement setgid&n;&t; * directories via NFS.&n;&t; */
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iap-&gt;ia_valid
op_and_assign
op_complement
(paren
id|ATTR_UID
op_or
id|ATTR_GID
op_or
id|ATTR_MODE
)paren
)paren
op_ne
l_int|0
)paren
id|err
op_assign
id|nfsd_setattr
c_func
(paren
id|rqstp
comma
id|resfhp
comma
id|iap
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update the file handle to get the new inode info.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|err
op_assign
id|fh_update
c_func
(paren
id|resfhp
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out_nfserr
suffix:colon
id|err
op_assign
id|nfserrno
c_func
(paren
id|err
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_NFSD_V3
multiline_comment|/*&n; * NFSv3 version of nfsd_create&n; */
r_int
DECL|function|nfsd_create_v3
id|nfsd_create_v3
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_char
op_star
id|fname
comma
r_int
id|flen
comma
r_struct
id|iattr
op_star
id|iap
comma
r_struct
id|svc_fh
op_star
id|resfhp
comma
r_int
id|createmode
comma
id|u32
op_star
id|verifier
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
comma
op_star
id|dchild
suffix:semicolon
r_struct
id|inode
op_star
id|dirp
suffix:semicolon
r_int
id|err
suffix:semicolon
id|__u32
id|v_mtime
op_assign
l_int|0
comma
id|v_atime
op_assign
l_int|0
suffix:semicolon
r_int
id|v_mode
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flen
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|nfserr_exist
suffix:semicolon
r_if
c_cond
(paren
id|isdotent
c_func
(paren
id|fname
comma
id|flen
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_MODE
)paren
)paren
id|iap-&gt;ia_mode
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFDIR
comma
id|MAY_CREATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|dirp
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
multiline_comment|/* Get all the sanity checks out of the way before&n;&t; * we lock the parent. */
id|err
op_assign
id|nfserr_notdir
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dirp-&gt;i_op
op_logical_or
op_logical_neg
id|dirp-&gt;i_op-&gt;lookup
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|fh_lock
c_func
(paren
id|fhp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Compose the response file handle.&n;&t; */
id|dchild
op_assign
id|lookup_one
c_func
(paren
id|fname
comma
id|dentry
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|dchild
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dchild
)paren
)paren
r_goto
id|out_nfserr
suffix:semicolon
id|err
op_assign
id|fh_compose
c_func
(paren
id|resfhp
comma
id|fhp-&gt;fh_export
comma
id|dchild
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|createmode
op_eq
id|NFS3_CREATE_EXCLUSIVE
)paren
(brace
multiline_comment|/* while the verifier would fit in mtime+atime,&n;&t;&t; * solaris7 gets confused (bugid 4218508) if these have&n;&t;&t; * the high bit set, so we use the mode as well&n;&t;&t; */
id|v_mtime
op_assign
id|verifier
(braket
l_int|0
)braket
op_amp
l_int|0x7fffffff
suffix:semicolon
id|v_atime
op_assign
id|verifier
(braket
l_int|1
)braket
op_amp
l_int|0x7fffffff
suffix:semicolon
id|v_mode
op_assign
id|S_IFREG
op_or
(paren
(paren
id|verifier
(braket
l_int|0
)braket
op_amp
l_int|0x80000000
)paren
op_rshift
(paren
l_int|32
op_minus
l_int|7
)paren
)paren
multiline_comment|/* u+x */
op_or
(paren
(paren
id|verifier
(braket
l_int|1
)braket
op_amp
l_int|0x80000000
)paren
op_rshift
(paren
l_int|32
op_minus
l_int|9
)paren
)paren
multiline_comment|/* u+r */
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dchild-&gt;d_inode
)paren
(brace
id|err
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|createmode
)paren
(brace
r_case
id|NFS3_CREATE_UNCHECKED
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|dchild-&gt;d_inode-&gt;i_mode
)paren
)paren
id|err
op_assign
id|nfserr_exist
suffix:semicolon
r_else
(brace
id|iap-&gt;ia_valid
op_and_assign
id|ATTR_SIZE
suffix:semicolon
r_goto
id|set_attr
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|NFS3_CREATE_EXCLUSIVE
suffix:colon
r_if
c_cond
(paren
id|dchild-&gt;d_inode-&gt;i_mtime
op_eq
id|v_mtime
op_logical_and
id|dchild-&gt;d_inode-&gt;i_atime
op_eq
id|v_atime
op_logical_and
id|dchild-&gt;d_inode-&gt;i_mode
op_eq
id|v_mode
op_logical_and
id|dchild-&gt;d_inode-&gt;i_size
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* fallthru */
r_case
id|NFS3_CREATE_GUARDED
suffix:colon
id|err
op_assign
id|nfserr_exist
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
id|err
op_assign
id|vfs_create
c_func
(paren
id|dirp
comma
id|dchild
comma
id|iap-&gt;ia_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_nfserr
suffix:semicolon
r_if
c_cond
(paren
id|EX_ISSYNC
c_func
(paren
id|fhp-&gt;fh_export
)paren
)paren
(brace
id|nfsd_sync_dir
c_func
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/* setattr will sync the child (or not) */
)brace
multiline_comment|/*&n;&t; * Update the filehandle to get the new inode info.&n;&t; */
id|err
op_assign
id|fh_update
c_func
(paren
id|resfhp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|createmode
op_eq
id|NFS3_CREATE_EXCLUSIVE
)paren
(brace
multiline_comment|/* Cram the verifier into atime/mtime/mode */
id|iap-&gt;ia_valid
op_assign
id|ATTR_MTIME
op_or
id|ATTR_ATIME
op_or
id|ATTR_MTIME_SET
op_or
id|ATTR_ATIME_SET
op_or
id|ATTR_MODE
suffix:semicolon
id|iap-&gt;ia_mtime
op_assign
id|v_mtime
suffix:semicolon
id|iap-&gt;ia_atime
op_assign
id|v_atime
suffix:semicolon
id|iap-&gt;ia_mode
op_assign
id|v_mode
suffix:semicolon
)brace
multiline_comment|/* Set file attributes.&n;&t; * Mode has already been set but we might need to reset it&n;&t; * for CREATE_EXCLUSIVE&n;&t; * Irix appears to send along the gid when it tries to&n;&t; * implement setgid directories via NFS. Clear out all that cruft.&n;&t; */
id|set_attr
suffix:colon
r_if
c_cond
(paren
(paren
id|iap-&gt;ia_valid
op_and_assign
op_complement
(paren
id|ATTR_UID
op_or
id|ATTR_GID
)paren
)paren
op_ne
l_int|0
)paren
id|err
op_assign
id|nfsd_setattr
c_func
(paren
id|rqstp
comma
id|resfhp
comma
id|iap
)paren
suffix:semicolon
id|out
suffix:colon
id|fh_unlock
c_func
(paren
id|fhp
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
id|out_nfserr
suffix:colon
id|err
op_assign
id|nfserrno
c_func
(paren
id|err
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_NFSD_V3 */
multiline_comment|/*&n; * Read a symlink. On entry, *lenp must contain the maximum path length that&n; * fits into the buffer. On return, it contains the true length.&n; * N.B. After this call fhp needs an fh_put&n; */
r_int
DECL|function|nfsd_readlink
id|nfsd_readlink
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_char
op_star
id|buf
comma
r_int
op_star
id|lenp
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|mm_segment_t
id|oldfs
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFLNK
comma
id|MAY_NOP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|err
op_assign
id|nfserr_inval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_op
op_logical_or
op_logical_neg
id|inode-&gt;i_op-&gt;readlink
)paren
r_goto
id|out
suffix:semicolon
id|UPDATE_ATIME
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/* N.B. Why does this call need a get_fs()??&n;&t; * Remove the set_fs and watch the fireworks:-) --okir&n;&t; */
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|err
op_assign
id|inode-&gt;i_op
op_member_access_from_pointer
id|readlink
c_func
(paren
id|dentry
comma
id|buf
comma
op_star
id|lenp
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_nfserr
suffix:semicolon
op_star
id|lenp
op_assign
id|err
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out_nfserr
suffix:colon
id|err
op_assign
id|nfserrno
c_func
(paren
id|err
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a symlink and look up its inode&n; * N.B. After this call _both_ fhp and resfhp need an fh_put&n; */
r_int
DECL|function|nfsd_symlink
id|nfsd_symlink
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_char
op_star
id|fname
comma
r_int
id|flen
comma
r_char
op_star
id|path
comma
r_int
id|plen
comma
r_struct
id|svc_fh
op_star
id|resfhp
comma
r_struct
id|iattr
op_star
id|iap
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
comma
op_star
id|dnew
suffix:semicolon
r_int
id|err
comma
id|cerr
suffix:semicolon
id|err
op_assign
id|nfserr_noent
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flen
op_logical_or
op_logical_neg
id|plen
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|nfserr_exist
suffix:semicolon
r_if
c_cond
(paren
id|isdotent
c_func
(paren
id|fname
comma
id|flen
)paren
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFDIR
comma
id|MAY_CREATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|fh_lock
c_func
(paren
id|fhp
)paren
suffix:semicolon
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|dnew
op_assign
id|lookup_one
c_func
(paren
id|fname
comma
id|dentry
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|dnew
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dnew
)paren
)paren
r_goto
id|out_nfserr
suffix:semicolon
id|err
op_assign
id|vfs_symlink
c_func
(paren
id|dentry-&gt;d_inode
comma
id|dnew
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
r_if
c_cond
(paren
id|EX_ISSYNC
c_func
(paren
id|fhp-&gt;fh_export
)paren
)paren
id|nfsd_sync_dir
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iap
)paren
(brace
id|iap-&gt;ia_valid
op_and_assign
id|ATTR_MODE
multiline_comment|/* ~(ATTR_MODE|ATTR_UID|ATTR_GID)*/
suffix:semicolon
r_if
c_cond
(paren
id|iap-&gt;ia_valid
)paren
(brace
id|iap-&gt;ia_valid
op_or_assign
id|ATTR_CTIME
suffix:semicolon
id|iap-&gt;ia_mode
op_assign
(paren
id|iap-&gt;ia_mode
op_amp
id|S_IALLUGO
)paren
op_or
id|S_IFLNK
suffix:semicolon
id|err
op_assign
id|notify_change
c_func
(paren
id|dnew
comma
id|iap
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|EX_ISSYNC
c_func
(paren
id|fhp-&gt;fh_export
)paren
)paren
id|write_inode_now
c_func
(paren
id|dentry-&gt;d_inode
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
id|err
op_assign
id|nfserrno
c_func
(paren
id|err
)paren
suffix:semicolon
id|fh_unlock
c_func
(paren
id|fhp
)paren
suffix:semicolon
multiline_comment|/* Compose the fh so the dentry will be freed ... */
id|cerr
op_assign
id|fh_compose
c_func
(paren
id|resfhp
comma
id|fhp-&gt;fh_export
comma
id|dnew
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
id|err
op_assign
id|cerr
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out_nfserr
suffix:colon
id|err
op_assign
id|nfserrno
c_func
(paren
id|err
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a hardlink&n; * N.B. After this call _both_ ffhp and tfhp need an fh_put&n; */
r_int
DECL|function|nfsd_link
id|nfsd_link
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|ffhp
comma
r_char
op_star
id|fname
comma
r_int
id|len
comma
r_struct
id|svc_fh
op_star
id|tfhp
)paren
(brace
r_struct
id|dentry
op_star
id|ddir
comma
op_star
id|dnew
comma
op_star
id|dold
suffix:semicolon
r_struct
id|inode
op_star
id|dirp
comma
op_star
id|dest
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|ffhp
comma
id|S_IFDIR
comma
id|MAY_CREATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|tfhp
comma
op_minus
id|S_IFDIR
comma
id|MAY_NOP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|nfserr_exist
suffix:semicolon
r_if
c_cond
(paren
id|isdotent
c_func
(paren
id|fname
comma
id|len
)paren
)paren
r_goto
id|out
suffix:semicolon
id|fh_lock
c_func
(paren
id|ffhp
)paren
suffix:semicolon
id|ddir
op_assign
id|ffhp-&gt;fh_dentry
suffix:semicolon
id|dirp
op_assign
id|ddir-&gt;d_inode
suffix:semicolon
id|dnew
op_assign
id|lookup_one
c_func
(paren
id|fname
comma
id|ddir
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|dnew
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dnew
)paren
)paren
r_goto
id|out_nfserr
suffix:semicolon
id|dold
op_assign
id|tfhp-&gt;fh_dentry
suffix:semicolon
id|dest
op_assign
id|dold-&gt;d_inode
suffix:semicolon
id|err
op_assign
id|vfs_link
c_func
(paren
id|dold
comma
id|dirp
comma
id|dnew
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
r_if
c_cond
(paren
id|EX_ISSYNC
c_func
(paren
id|ffhp-&gt;fh_export
)paren
)paren
(brace
id|nfsd_sync_dir
c_func
(paren
id|ddir
)paren
suffix:semicolon
id|write_inode_now
c_func
(paren
id|dest
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EXDEV
op_logical_and
id|rqstp-&gt;rq_vers
op_eq
l_int|2
)paren
id|err
op_assign
id|nfserr_acces
suffix:semicolon
r_else
id|err
op_assign
id|nfserrno
c_func
(paren
id|err
)paren
suffix:semicolon
)brace
id|fh_unlock
c_func
(paren
id|ffhp
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dnew
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out_nfserr
suffix:colon
id|err
op_assign
id|nfserrno
c_func
(paren
id|err
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Rename a file&n; * N.B. After this call _both_ ffhp and tfhp need an fh_put&n; */
r_int
DECL|function|nfsd_rename
id|nfsd_rename
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|ffhp
comma
r_char
op_star
id|fname
comma
r_int
id|flen
comma
r_struct
id|svc_fh
op_star
id|tfhp
comma
r_char
op_star
id|tname
comma
r_int
id|tlen
)paren
(brace
r_struct
id|dentry
op_star
id|fdentry
comma
op_star
id|tdentry
comma
op_star
id|odentry
comma
op_star
id|ndentry
suffix:semicolon
r_struct
id|inode
op_star
id|fdir
comma
op_star
id|tdir
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|ffhp
comma
id|S_IFDIR
comma
id|MAY_REMOVE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|tfhp
comma
id|S_IFDIR
comma
id|MAY_CREATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|fdentry
op_assign
id|ffhp-&gt;fh_dentry
suffix:semicolon
id|fdir
op_assign
id|fdentry-&gt;d_inode
suffix:semicolon
id|tdentry
op_assign
id|tfhp-&gt;fh_dentry
suffix:semicolon
id|tdir
op_assign
id|tdentry-&gt;d_inode
suffix:semicolon
id|err
op_assign
(paren
id|rqstp-&gt;rq_vers
op_eq
l_int|2
)paren
ques
c_cond
id|nfserr_acces
suffix:colon
id|nfserr_xdev
suffix:semicolon
r_if
c_cond
(paren
id|fdir-&gt;i_dev
op_ne
id|tdir-&gt;i_dev
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flen
op_logical_or
id|isdotent
c_func
(paren
id|fname
comma
id|flen
)paren
op_logical_or
op_logical_neg
id|tlen
op_logical_or
id|isdotent
c_func
(paren
id|tname
comma
id|tlen
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* cannot use fh_lock as we need deadlock protective ordering&n;&t; * so do it by hand */
id|double_down
c_func
(paren
op_amp
id|tdir-&gt;i_sem
comma
op_amp
id|fdir-&gt;i_sem
)paren
suffix:semicolon
id|ffhp-&gt;fh_locked
op_assign
id|tfhp-&gt;fh_locked
op_assign
l_int|1
suffix:semicolon
id|fill_pre_wcc
c_func
(paren
id|ffhp
)paren
suffix:semicolon
id|fill_pre_wcc
c_func
(paren
id|tfhp
)paren
suffix:semicolon
id|odentry
op_assign
id|lookup_one
c_func
(paren
id|fname
comma
id|fdentry
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|odentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|odentry
)paren
)paren
r_goto
id|out_nfserr
suffix:semicolon
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|odentry-&gt;d_inode
)paren
r_goto
id|out_dput_old
suffix:semicolon
id|ndentry
op_assign
id|lookup_one
c_func
(paren
id|tname
comma
id|tdentry
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|ndentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ndentry
)paren
)paren
r_goto
id|out_dput_old
suffix:semicolon
macro_line|#ifdef MSNFS
r_if
c_cond
(paren
(paren
id|ffhp-&gt;fh_export-&gt;ex_flags
op_amp
id|NFSEXP_MSNFS
)paren
op_logical_and
(paren
(paren
id|atomic_read
c_func
(paren
op_amp
id|odentry-&gt;d_count
)paren
OG
l_int|1
)paren
op_logical_or
(paren
id|atomic_read
c_func
(paren
op_amp
id|ndentry-&gt;d_count
)paren
OG
l_int|1
)paren
)paren
)paren
(brace
id|err
op_assign
id|nfserr_perm
suffix:semicolon
)brace
r_else
macro_line|#endif
id|err
op_assign
id|vfs_rename
c_func
(paren
id|fdir
comma
id|odentry
comma
id|tdir
comma
id|ndentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|EX_ISSYNC
c_func
(paren
id|tfhp-&gt;fh_export
)paren
)paren
(brace
id|nfsd_sync_dir
c_func
(paren
id|tdentry
)paren
suffix:semicolon
id|nfsd_sync_dir
c_func
(paren
id|fdentry
)paren
suffix:semicolon
)brace
id|dput
c_func
(paren
id|ndentry
)paren
suffix:semicolon
id|out_dput_old
suffix:colon
id|dput
c_func
(paren
id|odentry
)paren
suffix:semicolon
id|out_nfserr
suffix:colon
r_if
c_cond
(paren
id|err
)paren
id|err
op_assign
id|nfserrno
c_func
(paren
id|err
)paren
suffix:semicolon
multiline_comment|/* we cannot reply on fh_unlock on the two filehandles,&n;&t; * as that would do the wrong thing if the two directories&n;&t; * were the same, so again we do it by hand&n;&t; */
id|fill_post_wcc
c_func
(paren
id|ffhp
)paren
suffix:semicolon
id|fill_post_wcc
c_func
(paren
id|tfhp
)paren
suffix:semicolon
id|double_up
c_func
(paren
op_amp
id|tdir-&gt;i_sem
comma
op_amp
id|fdir-&gt;i_sem
)paren
suffix:semicolon
id|ffhp-&gt;fh_locked
op_assign
id|tfhp-&gt;fh_locked
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Unlink a file or directory&n; * N.B. After this call fhp needs an fh_put&n; */
r_int
DECL|function|nfsd_unlink
id|nfsd_unlink
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_int
id|type
comma
r_char
op_star
id|fname
comma
r_int
id|flen
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
comma
op_star
id|rdentry
suffix:semicolon
r_struct
id|inode
op_star
id|dirp
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|nfserr_acces
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flen
op_logical_or
id|isdotent
c_func
(paren
id|fname
comma
id|flen
)paren
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFDIR
comma
id|MAY_REMOVE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|fh_lock
c_func
(paren
id|fhp
)paren
suffix:semicolon
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|dirp
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|rdentry
op_assign
id|lookup_one
c_func
(paren
id|fname
comma
id|dentry
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|rdentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|rdentry
)paren
)paren
r_goto
id|out_nfserr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdentry-&gt;d_inode
)paren
(brace
id|dput
c_func
(paren
id|rdentry
)paren
suffix:semicolon
id|err
op_assign
id|nfserr_noent
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_ne
id|S_IFDIR
)paren
(brace
multiline_comment|/* It&squot;s UNLINK */
macro_line|#ifdef MSNFS
r_if
c_cond
(paren
(paren
id|fhp-&gt;fh_export-&gt;ex_flags
op_amp
id|NFSEXP_MSNFS
)paren
op_logical_and
(paren
id|atomic_read
c_func
(paren
op_amp
id|rdentry-&gt;d_count
)paren
OG
l_int|1
)paren
)paren
(brace
id|err
op_assign
id|nfserr_perm
suffix:semicolon
)brace
r_else
macro_line|#endif
id|err
op_assign
id|vfs_unlink
c_func
(paren
id|dirp
comma
id|rdentry
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* It&squot;s RMDIR */
id|err
op_assign
id|vfs_rmdir
c_func
(paren
id|dirp
comma
id|rdentry
)paren
suffix:semicolon
)brace
id|dput
c_func
(paren
id|rdentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_nfserr
suffix:semicolon
r_if
c_cond
(paren
id|EX_ISSYNC
c_func
(paren
id|fhp-&gt;fh_export
)paren
)paren
id|nfsd_sync_dir
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out_nfserr
suffix:colon
id|err
op_assign
id|nfserrno
c_func
(paren
id|err
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Read entries from a directory.&n; * The verifier is an NFSv3 thing we ignore for now.&n; */
r_int
DECL|function|nfsd_readdir
id|nfsd_readdir
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
id|loff_t
id|offset
comma
id|encode_dent_fn
id|func
comma
id|u32
op_star
id|buffer
comma
r_int
op_star
id|countp
comma
id|u32
op_star
id|verf
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|u32
op_star
id|p
suffix:semicolon
r_int
id|oldlen
comma
id|eof
comma
id|err
suffix:semicolon
r_struct
id|file
id|file
suffix:semicolon
r_struct
id|readdir_cd
id|cd
suffix:semicolon
id|err
op_assign
id|nfsd_open
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFDIR
comma
id|MAY_READ
comma
op_amp
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
op_complement
(paren
id|u32
)paren
l_int|0
)paren
r_goto
id|out_close
suffix:semicolon
id|err
op_assign
id|nfserr_notdir
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file.f_op-&gt;readdir
)paren
r_goto
id|out_close
suffix:semicolon
id|file.f_pos
op_assign
id|offset
suffix:semicolon
multiline_comment|/* Set up the readdir context */
id|memset
c_func
(paren
op_amp
id|cd
comma
l_int|0
comma
r_sizeof
(paren
id|cd
)paren
)paren
suffix:semicolon
id|cd.rqstp
op_assign
id|rqstp
suffix:semicolon
id|cd.buffer
op_assign
id|buffer
suffix:semicolon
id|cd.buflen
op_assign
op_star
id|countp
suffix:semicolon
multiline_comment|/* count of words */
id|cd.dirfh
op_assign
id|fhp
suffix:semicolon
multiline_comment|/*&n;&t; * Read the directory entries. This silly loop is necessary because&n;&t; * readdir() is not guaranteed to fill up the entire buffer, but&n;&t; * may choose to do less.&n;&t; */
id|inode
op_assign
id|file.f_dentry-&gt;d_inode
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|oldlen
op_assign
id|cd.buflen
suffix:semicolon
multiline_comment|/*&n;&t;&t;dprintk(&quot;nfsd: f_op-&gt;readdir(%x/%ld @ %d) buflen = %d (%d)&bslash;n&quot;,&n;&t;&t;&t;file.f_inode-&gt;i_dev, file.f_inode-&gt;i_ino,&n;&t;&t;&t;(int) file.f_pos, (int) oldlen, (int) cd.buflen);&n;&t;&t; */
id|err
op_assign
id|file.f_op
op_member_access_from_pointer
id|readdir
c_func
(paren
op_amp
id|file
comma
op_amp
id|cd
comma
(paren
id|filldir_t
)paren
id|func
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_nfserr
suffix:semicolon
r_if
c_cond
(paren
id|oldlen
op_eq
id|cd.buflen
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|cd.eob
)paren
r_break
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
multiline_comment|/* If we didn&squot;t fill the buffer completely, we&squot;re at EOF */
id|eof
op_assign
op_logical_neg
id|cd.eob
suffix:semicolon
r_if
c_cond
(paren
id|cd.offset
)paren
(brace
r_if
c_cond
(paren
id|rqstp-&gt;rq_vers
op_eq
l_int|3
)paren
(paren
r_void
)paren
id|xdr_encode_hyper
c_func
(paren
id|cd.offset
comma
id|file.f_pos
)paren
suffix:semicolon
r_else
op_star
id|cd.offset
op_assign
id|htonl
c_func
(paren
id|file.f_pos
)paren
suffix:semicolon
)brace
id|p
op_assign
id|cd.buffer
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no more entries */
op_star
id|p
op_increment
op_assign
id|htonl
c_func
(paren
id|eof
)paren
suffix:semicolon
multiline_comment|/* end of directory */
op_star
id|countp
op_assign
(paren
id|caddr_t
)paren
id|p
op_minus
(paren
id|caddr_t
)paren
id|buffer
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;nfsd: readdir result %d bytes, eof %d offset %d&bslash;n&quot;
comma
op_star
id|countp
comma
id|eof
comma
id|cd.offset
ques
c_cond
id|ntohl
c_func
(paren
op_star
id|cd.offset
)paren
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|out_close
suffix:colon
id|nfsd_close
c_func
(paren
op_amp
id|file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out_nfserr
suffix:colon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|err
op_assign
id|nfserrno
c_func
(paren
id|err
)paren
suffix:semicolon
r_goto
id|out_close
suffix:semicolon
)brace
multiline_comment|/*&n; * Get file system stats&n; * N.B. After this call fhp needs an fh_put&n; */
r_int
DECL|function|nfsd_statfs
id|nfsd_statfs
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_struct
id|statfs
op_star
id|stat
)paren
(brace
r_int
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|fhp
comma
l_int|0
comma
id|MAY_NOP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|vfs_statfs
c_func
(paren
id|fhp-&gt;fh_dentry-&gt;d_inode-&gt;i_sb
comma
id|stat
)paren
)paren
id|err
op_assign
id|nfserr_io
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Check for a user&squot;s access permissions to this inode.&n; */
r_int
DECL|function|nfsd_permission
id|nfsd_permission
c_func
(paren
r_struct
id|svc_export
op_star
id|exp
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|acc
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|acc
op_eq
id|MAY_NOP
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#if 0
id|dprintk
c_func
(paren
l_string|&quot;nfsd: permission 0x%x%s%s%s%s%s%s%s mode 0%o%s%s%s&bslash;n&quot;
comma
id|acc
comma
(paren
id|acc
op_amp
id|MAY_READ
)paren
ques
c_cond
l_string|&quot; read&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|acc
op_amp
id|MAY_WRITE
)paren
ques
c_cond
l_string|&quot; write&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|acc
op_amp
id|MAY_EXEC
)paren
ques
c_cond
l_string|&quot; exec&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|acc
op_amp
id|MAY_SATTR
)paren
ques
c_cond
l_string|&quot; sattr&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|acc
op_amp
id|MAY_TRUNC
)paren
ques
c_cond
l_string|&quot; trunc&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|acc
op_amp
id|MAY_LOCK
)paren
ques
c_cond
l_string|&quot; lock&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|acc
op_amp
id|MAY_OWNER_OVERRIDE
)paren
ques
c_cond
l_string|&quot; owneroverride&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|inode-&gt;i_mode
comma
id|IS_IMMUTABLE
c_func
(paren
id|inode
)paren
ques
c_cond
l_string|&quot; immut&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|IS_APPEND
c_func
(paren
id|inode
)paren
ques
c_cond
l_string|&quot; append&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|IS_RDONLY
c_func
(paren
id|inode
)paren
ques
c_cond
l_string|&quot; ro&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;      owner %d/%d user %d/%d&bslash;n&quot;
comma
id|inode-&gt;i_uid
comma
id|inode-&gt;i_gid
comma
id|current-&gt;fsuid
comma
id|current-&gt;fsgid
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* only care about readonly exports for files and&n;&t; * directories. links don&squot;t have meaningful write access,&n;&t; * and all else is local to the client&n;&t; */
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_if
c_cond
(paren
id|acc
op_amp
(paren
id|MAY_WRITE
op_or
id|MAY_SATTR
op_or
id|MAY_TRUNC
)paren
)paren
(brace
r_if
c_cond
(paren
id|EX_RDONLY
c_func
(paren
id|exp
)paren
op_logical_or
id|IS_RDONLY
c_func
(paren
id|inode
)paren
)paren
r_return
id|nfserr_rofs
suffix:semicolon
r_if
c_cond
(paren
multiline_comment|/* (acc &amp; MAY_WRITE) &amp;&amp; */
id|IS_IMMUTABLE
c_func
(paren
id|inode
)paren
)paren
r_return
id|nfserr_perm
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|acc
op_amp
id|MAY_TRUNC
)paren
op_logical_and
id|IS_APPEND
c_func
(paren
id|inode
)paren
)paren
r_return
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
id|acc
op_amp
id|MAY_LOCK
)paren
(brace
multiline_comment|/* If we cannot rely on authentication in NLM requests,&n;&t;&t; * just allow locks, otherwise require read permission, or&n;&t;&t; * ownership&n;&t;&t; */
r_if
c_cond
(paren
id|exp-&gt;ex_flags
op_amp
id|NFSEXP_NOAUTHNLM
)paren
r_return
l_int|0
suffix:semicolon
r_else
id|acc
op_assign
id|MAY_READ
op_or
id|MAY_OWNER_OVERRIDE
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The file owner always gets access permission for accesses that&n;&t; * would normally be checked at open time. This is to make&n;&t; * file access work even when the client has done a fchmod(fd, 0).&n;&t; *&n;&t; * However, `cp foo bar&squot; should fail nevertheless when bar is&n;&t; * readonly. A sensible way to do this might be to reject all&n;&t; * attempts to truncate a read-only file, because a creat() call&n;&t; * always implies file truncation.&n;&t; * ... but this isn&squot;t really fair.  A process may reasonably call&n;&t; * ftruncate on an open file descriptor on a file with perm 000.&n;&t; * We must trust the client to do permission checking - using &quot;ACCESS&quot;&n;&t; * with NFSv3.&n;&t; */
r_if
c_cond
(paren
(paren
id|acc
op_amp
id|MAY_OWNER_OVERRIDE
)paren
op_logical_and
id|inode-&gt;i_uid
op_eq
id|current-&gt;fsuid
)paren
r_return
l_int|0
suffix:semicolon
id|acc
op_and_assign
op_complement
id|MAY_OWNER_OVERRIDE
suffix:semicolon
multiline_comment|/* This bit is no longer needed,&n;                                        and gets in the way later */
id|err
op_assign
id|permission
c_func
(paren
id|inode
comma
id|acc
op_amp
(paren
id|MAY_READ
op_or
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
)paren
suffix:semicolon
multiline_comment|/* Allow read access to binaries even when mode 111 */
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EACCES
op_logical_and
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
id|acc
op_eq
id|MAY_READ
)paren
id|err
op_assign
id|permission
c_func
(paren
id|inode
comma
id|MAY_EXEC
)paren
suffix:semicolon
r_return
id|err
ques
c_cond
id|nfserrno
c_func
(paren
id|err
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|nfsd_racache_shutdown
id|nfsd_racache_shutdown
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|raparm_cache
)paren
r_return
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;nfsd: freeing readahead buffers.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|raparml
)paren
suffix:semicolon
id|raparm_cache
op_assign
id|raparml
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize readahead param cache&n; */
r_int
DECL|function|nfsd_racache_init
id|nfsd_racache_init
c_func
(paren
r_int
id|cache_size
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|raparm_cache
)paren
r_return
l_int|0
suffix:semicolon
id|raparml
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|raparms
)paren
op_star
id|cache_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raparml
op_ne
l_int|NULL
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;nfsd: allocating %d readahead buffers.&bslash;n&quot;
comma
id|cache_size
)paren
suffix:semicolon
id|memset
c_func
(paren
id|raparml
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|raparms
)paren
op_star
id|cache_size
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cache_size
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|raparml
(braket
id|i
)braket
dot
id|p_next
op_assign
id|raparml
op_plus
id|i
op_plus
l_int|1
suffix:semicolon
)brace
id|raparm_cache
op_assign
id|raparml
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;nfsd: Could not allocate memory read-ahead cache.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|nfsdstats.ra_size
op_assign
id|cache_size
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
