multiline_comment|/*&n; * linux/fs/nfsd/vfs.c&n; *&n; * File operations used by nfsd. Some of these have been ripped from&n; * other parts of the kernel because they weren&squot;t in ksyms.c, others&n; * are partial duplicates with added or changed functionality.&n; *&n; * Note that several functions dget() the dentry upon which they want&n; * to act, most notably those that create directory entries. Response&n; * dentry&squot;s are dput()&squot;d if necessary in the release callback.&n; * So if you notice code paths that apparently fail to dput() the&n; * dentry, don&squot;t worry--they have been taken care of.&n; *&n; * Copyright (C) 1995-1999 Olaf Kirch &lt;okir@monad.swb.de&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/ext2_fs.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/sunrpc/svc.h&gt;
macro_line|#include &lt;linux/nfsd/nfsd.h&gt;
macro_line|#include &lt;linux/nfsd/nfsfh.h&gt;
macro_line|#include &lt;linux/quotaops.h&gt;
macro_line|#if LINUX_VERSION_CODE &gt;= 0x020100
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#endif
DECL|macro|NFSDDBG_FACILITY
mdefine_line|#define NFSDDBG_FACILITY&t;&t;NFSDDBG_FILEOP
DECL|macro|NFSD_PARANOIA
mdefine_line|#define NFSD_PARANOIA
multiline_comment|/* Open mode for nfsd_open */
DECL|macro|OPEN_READ
mdefine_line|#define OPEN_READ&t;0
DECL|macro|OPEN_WRITE
mdefine_line|#define OPEN_WRITE&t;1
multiline_comment|/* Hack until we have a macro check for mandatory locks. */
macro_line|#ifndef IS_ISMNDLK
DECL|macro|IS_ISMNDLK
mdefine_line|#define IS_ISMNDLK(i)&t;(((i)-&gt;i_mode &amp; (S_ISGID|S_IXGRP)) == S_ISGID)
macro_line|#endif
multiline_comment|/* Check for dir entries &squot;.&squot; and &squot;..&squot; */
DECL|macro|isdotent
mdefine_line|#define isdotent(n, l)&t;(l &lt; 3 &amp;&amp; n[0] == &squot;.&squot; &amp;&amp; (l == 1 || n[1] == &squot;.&squot;))
multiline_comment|/*&n; * This is a cache of readahead params that help us choose the proper&n; * readahead strategy. Initially, we set all readahead parameters to 0&n; * and let the VFS handle things.&n; * If you increase the number of cached files very much, you&squot;ll need to&n; * add a hash table here.&n; */
DECL|struct|raparms
r_struct
id|raparms
(brace
DECL|member|p_next
r_struct
id|raparms
op_star
id|p_next
suffix:semicolon
DECL|member|p_count
r_int
r_int
id|p_count
suffix:semicolon
DECL|member|p_ino
id|ino_t
id|p_ino
suffix:semicolon
DECL|member|p_dev
id|dev_t
id|p_dev
suffix:semicolon
DECL|member|p_reada
r_int
r_int
id|p_reada
comma
DECL|member|p_ramax
id|p_ramax
comma
DECL|member|p_raend
id|p_raend
comma
DECL|member|p_ralen
id|p_ralen
comma
DECL|member|p_rawin
id|p_rawin
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|nfsd_nservers
r_int
id|nfsd_nservers
op_assign
l_int|0
suffix:semicolon
DECL|macro|FILECACHE_MAX
mdefine_line|#define FILECACHE_MAX&t;&t;(2 * nfsd_nservers) 
DECL|variable|raparml
r_static
r_struct
id|raparms
op_star
id|raparml
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|raparm_cache
r_static
r_struct
id|raparms
op_star
id|raparm_cache
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * Lock a parent directory following the VFS locking protocol.&n; */
r_int
DECL|function|fh_lock_parent
id|fh_lock_parent
c_func
(paren
r_struct
id|svc_fh
op_star
id|parent_fh
comma
r_struct
id|dentry
op_star
id|dchild
)paren
(brace
r_int
id|nfserr
op_assign
l_int|0
suffix:semicolon
id|fh_lock
c_func
(paren
id|parent_fh
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure the parent-&gt;child relationship still holds,&n;&t; * and that the child is still hashed.&n;&t; */
r_if
c_cond
(paren
id|dchild-&gt;d_parent
op_ne
id|parent_fh-&gt;fh_dentry
)paren
r_goto
id|out_not_parent
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|dchild-&gt;d_hash
)paren
)paren
r_goto
id|out_not_hashed
suffix:semicolon
id|out
suffix:colon
r_return
id|nfserr
suffix:semicolon
id|out_not_parent
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;fh_lock_parent: %s/%s parent changed&bslash;n&quot;
comma
id|dchild-&gt;d_parent-&gt;d_name.name
comma
id|dchild-&gt;d_name.name
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
id|out_not_hashed
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;fh_lock_parent: %s/%s unhashed&bslash;n&quot;
comma
id|dchild-&gt;d_parent-&gt;d_name.name
comma
id|dchild-&gt;d_name.name
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|nfserr
op_assign
id|nfserr_noent
suffix:semicolon
id|fh_unlock
c_func
(paren
id|parent_fh
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Deny access to certain file systems&n; */
r_static
r_inline
r_int
DECL|function|fs_off_limits
id|fs_off_limits
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_return
op_logical_neg
id|sb
op_logical_or
id|sb-&gt;s_magic
op_eq
id|NFS_SUPER_MAGIC
op_logical_or
id|sb-&gt;s_magic
op_eq
id|PROC_SUPER_MAGIC
suffix:semicolon
)brace
multiline_comment|/*&n; * Check whether directory is a mount point, but it is all right if&n; * this is precisely the local mount point being exported.&n; */
r_static
r_inline
r_int
DECL|function|nfsd_iscovered
id|nfsd_iscovered
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|svc_export
op_star
id|exp
)paren
(brace
r_return
(paren
id|dentry
op_ne
id|dentry-&gt;d_covers
op_logical_and
id|dentry
op_ne
id|exp-&gt;ex_dentry
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Look up one component of a pathname.&n; * N.B. After this call _both_ fhp and resfh need an fh_put&n; */
r_int
DECL|function|nfsd_lookup
id|nfsd_lookup
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
r_struct
id|svc_fh
op_star
id|resfh
)paren
(brace
r_struct
id|svc_export
op_star
id|exp
suffix:semicolon
r_struct
id|dentry
op_star
id|dparent
comma
op_star
id|dchild
suffix:semicolon
r_int
id|err
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;nfsd: nfsd_lookup(fh %p, %s)&bslash;n&quot;
comma
id|SVCFH_DENTRY
c_func
(paren
id|fhp
)paren
comma
id|name
)paren
suffix:semicolon
multiline_comment|/* Obtain dentry and export. */
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFDIR
comma
id|MAY_EXEC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|dparent
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|exp
op_assign
id|fhp-&gt;fh_export
suffix:semicolon
macro_line|#if 0
id|err
op_assign
id|nfsd_permission
c_func
(paren
id|exp
comma
id|dparent
comma
id|MAY_EXEC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
macro_line|#endif
id|err
op_assign
id|nfserr_noent
suffix:semicolon
r_if
c_cond
(paren
id|fs_off_limits
c_func
(paren
id|dparent-&gt;d_sb
)paren
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|nfserr_acces
suffix:semicolon
r_if
c_cond
(paren
id|nfsd_iscovered
c_func
(paren
id|dparent
comma
id|exp
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Lookup the name, but don&squot;t follow links */
id|dchild
op_assign
id|lookup_dentry
c_func
(paren
id|name
comma
id|dget
c_func
(paren
id|dparent
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dchild
)paren
)paren
r_goto
id|out_nfserr
suffix:semicolon
multiline_comment|/*&n;&t; * check if we have crossed a mount point ...&n;&t; */
r_if
c_cond
(paren
id|dchild-&gt;d_sb
op_ne
id|dparent-&gt;d_sb
)paren
(brace
r_struct
id|dentry
op_star
id|tdentry
suffix:semicolon
id|tdentry
op_assign
id|dchild-&gt;d_covers
suffix:semicolon
r_if
c_cond
(paren
id|tdentry
op_eq
id|dchild
)paren
r_goto
id|out_dput
suffix:semicolon
id|dput
c_func
(paren
id|dchild
)paren
suffix:semicolon
id|dchild
op_assign
id|dget
c_func
(paren
id|tdentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dchild-&gt;d_sb
op_ne
id|dparent-&gt;d_sb
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;nfsd_lookup: %s/%s crossed mount point!&bslash;n&quot;
comma
id|dparent-&gt;d_name.name
comma
id|dchild-&gt;d_name.name
)paren
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Note: we compose the file handle now, but as the&n;&t; * dentry may be negative, it may need to be updated.&n;&t; */
id|fh_compose
c_func
(paren
id|resfh
comma
id|exp
comma
id|dchild
)paren
suffix:semicolon
id|err
op_assign
id|nfserr_noent
suffix:semicolon
r_if
c_cond
(paren
id|dchild-&gt;d_inode
)paren
id|err
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out_nfserr
suffix:colon
id|err
op_assign
id|nfserrno
c_func
(paren
op_minus
id|PTR_ERR
c_func
(paren
id|dchild
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|out_dput
suffix:colon
id|dput
c_func
(paren
id|dchild
)paren
suffix:semicolon
id|err
op_assign
id|nfserr_acces
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Set various file attributes.&n; * N.B. After this call fhp needs an fh_put&n; */
r_int
DECL|function|nfsd_setattr
id|nfsd_setattr
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_struct
id|iattr
op_star
id|iap
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|accmode
op_assign
id|MAY_SATTR
suffix:semicolon
r_int
id|ftype
op_assign
l_int|0
suffix:semicolon
r_int
id|imode
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|iap-&gt;ia_valid
op_amp
(paren
id|ATTR_ATIME
op_or
id|ATTR_MTIME
op_or
id|ATTR_SIZE
)paren
)paren
id|accmode
op_or_assign
id|MAY_WRITE
suffix:semicolon
r_if
c_cond
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_SIZE
)paren
id|ftype
op_assign
id|S_IFREG
suffix:semicolon
multiline_comment|/* Get inode */
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|ftype
comma
id|accmode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|err
op_assign
id|inode_change_ok
c_func
(paren
id|inode
comma
id|iap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_nfserr
suffix:semicolon
multiline_comment|/* The size case is special... */
r_if
c_cond
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_SIZE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;nfsd_setattr: size change??&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iap-&gt;ia_size
OL
id|inode-&gt;i_size
)paren
(brace
id|err
op_assign
id|nfsd_permission
c_func
(paren
id|fhp-&gt;fh_export
comma
id|dentry
comma
id|MAY_TRUNC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
)brace
id|err
op_assign
id|get_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_nfserr
suffix:semicolon
multiline_comment|/* N.B. Should we update the inode cache here? */
id|inode-&gt;i_size
op_assign
id|iap-&gt;ia_size
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_op
op_logical_and
id|inode-&gt;i_op-&gt;truncate
)paren
id|inode-&gt;i_op
op_member_access_from_pointer
id|truncate
c_func
(paren
id|inode
)paren
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
id|put_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
id|iap-&gt;ia_valid
op_and_assign
op_complement
id|ATTR_SIZE
suffix:semicolon
id|iap-&gt;ia_valid
op_or_assign
id|ATTR_MTIME
suffix:semicolon
id|iap-&gt;ia_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
)brace
id|imode
op_assign
id|inode-&gt;i_mode
suffix:semicolon
r_if
c_cond
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_MODE
)paren
(brace
id|iap-&gt;ia_mode
op_and_assign
id|S_IALLUGO
suffix:semicolon
id|imode
op_assign
id|iap-&gt;ia_mode
op_or_assign
(paren
id|imode
op_amp
op_complement
id|S_IALLUGO
)paren
suffix:semicolon
)brace
multiline_comment|/* Revoke setuid/setgid bit on chown/chgrp */
r_if
c_cond
(paren
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_UID
)paren
op_logical_and
(paren
id|imode
op_amp
id|S_ISUID
)paren
op_logical_and
id|iap-&gt;ia_uid
op_ne
id|inode-&gt;i_uid
)paren
(brace
id|iap-&gt;ia_valid
op_or_assign
id|ATTR_MODE
suffix:semicolon
id|iap-&gt;ia_mode
op_assign
id|imode
op_and_assign
op_complement
id|S_ISUID
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_GID
)paren
op_logical_and
(paren
id|imode
op_amp
id|S_ISGID
)paren
op_logical_and
id|iap-&gt;ia_gid
op_ne
id|inode-&gt;i_gid
)paren
(brace
id|iap-&gt;ia_valid
op_or_assign
id|ATTR_MODE
suffix:semicolon
id|iap-&gt;ia_mode
op_assign
id|imode
op_and_assign
op_complement
id|S_ISGID
suffix:semicolon
)brace
multiline_comment|/* Change the attributes. */
r_if
c_cond
(paren
id|iap-&gt;ia_valid
)paren
(brace
id|kernel_cap_t
id|saved_cap
op_assign
l_int|0
suffix:semicolon
id|iap-&gt;ia_valid
op_or_assign
id|ATTR_CTIME
suffix:semicolon
id|iap-&gt;ia_ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;fsuid
op_ne
l_int|0
)paren
(brace
id|saved_cap
op_assign
id|current-&gt;cap_effective
suffix:semicolon
id|cap_clear
c_func
(paren
id|current-&gt;cap_effective
)paren
suffix:semicolon
)brace
id|err
op_assign
id|notify_change
c_func
(paren
id|dentry
comma
id|iap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;fsuid
op_ne
l_int|0
)paren
id|current-&gt;cap_effective
op_assign
id|saved_cap
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_nfserr
suffix:semicolon
r_if
c_cond
(paren
id|EX_ISSYNC
c_func
(paren
id|fhp-&gt;fh_export
)paren
)paren
id|write_inode_now
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out_nfserr
suffix:colon
id|err
op_assign
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Open an existing file or directory.&n; * The wflag argument indicates write access.&n; * N.B. After this call fhp needs an fh_put&n; */
r_int
DECL|function|nfsd_open
id|nfsd_open
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_int
id|type
comma
r_int
id|wflag
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|access
comma
id|err
suffix:semicolon
id|access
op_assign
id|wflag
ques
c_cond
id|MAY_WRITE
suffix:colon
id|MAY_READ
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|type
comma
id|access
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
multiline_comment|/* Disallow access to files with the append-only bit set or&n;&t; * with mandatory locking enabled&n;&t; */
id|err
op_assign
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|inode
)paren
op_logical_or
id|IS_ISMNDLK
c_func
(paren
id|inode
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_op
op_logical_or
op_logical_neg
id|inode-&gt;i_op-&gt;default_file_ops
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|wflag
op_logical_and
(paren
id|err
op_assign
id|get_write_access
c_func
(paren
id|inode
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|out_nfserr
suffix:semicolon
id|memset
c_func
(paren
id|filp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|filp
)paren
)paren
suffix:semicolon
id|filp-&gt;f_op
op_assign
id|inode-&gt;i_op-&gt;default_file_ops
suffix:semicolon
id|filp-&gt;f_count
op_assign
l_int|1
suffix:semicolon
id|filp-&gt;f_flags
op_assign
id|wflag
ques
c_cond
id|O_WRONLY
suffix:colon
id|O_RDONLY
suffix:semicolon
id|filp-&gt;f_mode
op_assign
id|wflag
ques
c_cond
id|FMODE_WRITE
suffix:colon
id|FMODE_READ
suffix:semicolon
id|filp-&gt;f_dentry
op_assign
id|dentry
suffix:semicolon
r_if
c_cond
(paren
id|wflag
)paren
id|DQUOT_INIT
c_func
(paren
id|inode
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_op
op_logical_and
id|filp-&gt;f_op-&gt;open
)paren
(brace
id|err
op_assign
id|filp-&gt;f_op
op_member_access_from_pointer
id|open
c_func
(paren
id|inode
comma
id|filp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_if
c_cond
(paren
id|wflag
)paren
id|put_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/* I nearly added put_filp() call here, but this filp&n;&t;&t;&t; * is really on callers stack frame. -DaveM&n;&t;&t;&t; */
id|filp-&gt;f_count
op_decrement
suffix:semicolon
)brace
)brace
id|out_nfserr
suffix:colon
r_if
c_cond
(paren
id|err
)paren
id|err
op_assign
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Close a file.&n; */
r_void
DECL|function|nfsd_close
id|nfsd_close
c_func
(paren
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|filp-&gt;f_dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_count
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;nfsd: inode count == 0!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_count
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;nfsd: wheee, %s/%s d_count == 0!&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_op
op_logical_and
id|filp-&gt;f_op-&gt;release
)paren
id|filp-&gt;f_op
op_member_access_from_pointer
id|release
c_func
(paren
id|inode
comma
id|filp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|put_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
id|DQUOT_DROP
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Sync a file&n; */
r_void
DECL|function|nfsd_sync
id|nfsd_sync
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|filp-&gt;f_op
op_member_access_from_pointer
id|fsync
c_func
(paren
id|filp
comma
id|filp-&gt;f_dentry
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Obtain the readahead parameters for the file&n; * specified by (dev, ino).&n; */
r_static
r_inline
r_struct
id|raparms
op_star
DECL|function|nfsd_get_raparms
id|nfsd_get_raparms
c_func
(paren
id|dev_t
id|dev
comma
id|ino_t
id|ino
)paren
(brace
r_struct
id|raparms
op_star
id|ra
comma
op_star
op_star
id|rap
comma
op_star
op_star
id|frap
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|rap
op_assign
op_amp
id|raparm_cache
suffix:semicolon
(paren
id|ra
op_assign
op_star
id|rap
)paren
suffix:semicolon
id|rap
op_assign
op_amp
id|ra-&gt;p_next
)paren
(brace
r_if
c_cond
(paren
id|ra-&gt;p_ino
op_eq
id|ino
op_logical_and
id|ra-&gt;p_dev
op_eq
id|dev
)paren
r_goto
id|found
suffix:semicolon
r_if
c_cond
(paren
id|ra-&gt;p_count
op_eq
l_int|0
)paren
id|frap
op_assign
id|rap
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|frap
)paren
r_return
l_int|NULL
suffix:semicolon
id|rap
op_assign
id|frap
suffix:semicolon
id|ra
op_assign
op_star
id|frap
suffix:semicolon
id|memset
c_func
(paren
id|ra
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ra
)paren
)paren
suffix:semicolon
id|ra-&gt;p_dev
op_assign
id|dev
suffix:semicolon
id|ra-&gt;p_ino
op_assign
id|ino
suffix:semicolon
id|found
suffix:colon
r_if
c_cond
(paren
id|rap
op_ne
op_amp
id|raparm_cache
)paren
(brace
op_star
id|rap
op_assign
id|ra-&gt;p_next
suffix:semicolon
id|ra-&gt;p_next
op_assign
id|raparm_cache
suffix:semicolon
id|raparm_cache
op_assign
id|ra
suffix:semicolon
)brace
id|ra-&gt;p_count
op_increment
suffix:semicolon
r_return
id|ra
suffix:semicolon
)brace
multiline_comment|/*&n; * Read data from a file. count must contain the requested read count&n; * on entry. On return, *count contains the number of bytes actually read.&n; * N.B. After this call fhp needs an fh_put&n; */
r_int
DECL|function|nfsd_read
id|nfsd_read
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
id|loff_t
id|offset
comma
r_char
op_star
id|buf
comma
r_int
r_int
op_star
id|count
)paren
(brace
r_struct
id|raparms
op_star
id|ra
suffix:semicolon
id|mm_segment_t
id|oldfs
suffix:semicolon
r_int
id|err
suffix:semicolon
r_struct
id|file
id|file
suffix:semicolon
id|err
op_assign
id|nfsd_open
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFREG
comma
id|OPEN_READ
comma
op_amp
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file.f_op-&gt;read
)paren
r_goto
id|out_close
suffix:semicolon
multiline_comment|/* Get readahead parameters */
id|ra
op_assign
id|nfsd_get_raparms
c_func
(paren
id|fhp-&gt;fh_handle.fh_dev
comma
id|fhp-&gt;fh_handle.fh_ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ra
)paren
(brace
id|file.f_reada
op_assign
id|ra-&gt;p_reada
suffix:semicolon
id|file.f_ramax
op_assign
id|ra-&gt;p_ramax
suffix:semicolon
id|file.f_raend
op_assign
id|ra-&gt;p_raend
suffix:semicolon
id|file.f_ralen
op_assign
id|ra-&gt;p_ralen
suffix:semicolon
id|file.f_rawin
op_assign
id|ra-&gt;p_rawin
suffix:semicolon
)brace
id|file.f_pos
op_assign
id|offset
suffix:semicolon
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|err
op_assign
id|file.f_op
op_member_access_from_pointer
id|read
c_func
(paren
op_amp
id|file
comma
id|buf
comma
op_star
id|count
comma
op_amp
id|file.f_pos
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
multiline_comment|/* Write back readahead params */
r_if
c_cond
(paren
id|ra
op_ne
l_int|NULL
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;nfsd: raparms %ld %ld %ld %ld %ld&bslash;n&quot;
comma
id|file.f_reada
comma
id|file.f_ramax
comma
id|file.f_raend
comma
id|file.f_ralen
comma
id|file.f_rawin
)paren
suffix:semicolon
id|ra-&gt;p_reada
op_assign
id|file.f_reada
suffix:semicolon
id|ra-&gt;p_ramax
op_assign
id|file.f_ramax
suffix:semicolon
id|ra-&gt;p_raend
op_assign
id|file.f_raend
suffix:semicolon
id|ra-&gt;p_ralen
op_assign
id|file.f_ralen
suffix:semicolon
id|ra-&gt;p_rawin
op_assign
id|file.f_rawin
suffix:semicolon
id|ra-&gt;p_count
op_sub_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
op_ge
l_int|0
)paren
(brace
op_star
id|count
op_assign
id|err
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|err
op_assign
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
id|out_close
suffix:colon
id|nfsd_close
c_func
(paren
op_amp
id|file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Write data to a file.&n; * The stable flag requests synchronous writes.&n; * N.B. After this call fhp needs an fh_put&n; */
r_int
DECL|function|nfsd_write
id|nfsd_write
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
id|loff_t
id|offset
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|cnt
comma
r_int
id|stable
)paren
(brace
r_struct
id|svc_export
op_star
id|exp
suffix:semicolon
r_struct
id|file
id|file
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|mm_segment_t
id|oldfs
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_QUOTA
id|uid_t
id|saved_euid
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|cnt
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|nfsd_open
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFREG
comma
id|OPEN_WRITE
comma
op_amp
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file.f_op-&gt;write
)paren
r_goto
id|out_close
suffix:semicolon
id|dentry
op_assign
id|file.f_dentry
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|exp
op_assign
id|fhp-&gt;fh_export
suffix:semicolon
multiline_comment|/*&n;&t; * Request sync writes if&n;&t; *  -&t;the sync export option has been set, or&n;&t; *  -&t;the client requested O_SYNC behavior (NFSv3 feature).&n;&t; * When gathered writes have been configured for this volume,&n;&t; * flushing the data to disk is handled separately below.&n;&t; */
r_if
c_cond
(paren
(paren
id|stable
op_logical_or
(paren
id|stable
op_assign
id|EX_ISSYNC
c_func
(paren
id|exp
)paren
)paren
)paren
op_logical_and
op_logical_neg
id|EX_WGATHER
c_func
(paren
id|exp
)paren
)paren
id|file.f_flags
op_or_assign
id|O_SYNC
suffix:semicolon
id|fh_lock
c_func
(paren
id|fhp
)paren
suffix:semicolon
multiline_comment|/* lock inode */
id|file.f_pos
op_assign
id|offset
suffix:semicolon
multiline_comment|/* set write offset */
multiline_comment|/* Write the data. */
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_QUOTA
multiline_comment|/* This is for disk quota. */
id|saved_euid
op_assign
id|current-&gt;euid
suffix:semicolon
id|current-&gt;euid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|err
op_assign
id|file.f_op
op_member_access_from_pointer
id|write
c_func
(paren
op_amp
id|file
comma
id|buf
comma
id|cnt
comma
op_amp
id|file.f_pos
)paren
suffix:semicolon
id|current-&gt;euid
op_assign
id|saved_euid
suffix:semicolon
macro_line|#else
id|err
op_assign
id|file.f_op
op_member_access_from_pointer
id|write
c_func
(paren
op_amp
id|file
comma
id|buf
comma
id|cnt
comma
op_amp
id|file.f_pos
)paren
suffix:semicolon
macro_line|#endif
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
multiline_comment|/* clear setuid/setgid flag after write */
r_if
c_cond
(paren
id|err
op_ge
l_int|0
op_logical_and
(paren
id|inode-&gt;i_mode
op_amp
(paren
id|S_ISUID
op_or
id|S_ISGID
)paren
)paren
)paren
(brace
r_struct
id|iattr
id|ia
suffix:semicolon
id|kernel_cap_t
id|saved_cap
suffix:semicolon
id|ia.ia_valid
op_assign
id|ATTR_MODE
suffix:semicolon
id|ia.ia_mode
op_assign
id|inode-&gt;i_mode
op_amp
op_complement
(paren
id|S_ISUID
op_or
id|S_ISGID
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;fsuid
op_ne
l_int|0
)paren
(brace
id|saved_cap
op_assign
id|current-&gt;cap_effective
suffix:semicolon
id|cap_clear
c_func
(paren
id|current-&gt;cap_effective
)paren
suffix:semicolon
)brace
id|notify_change
c_func
(paren
id|dentry
comma
op_amp
id|ia
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;fsuid
op_ne
l_int|0
)paren
id|current-&gt;cap_effective
op_assign
id|saved_cap
suffix:semicolon
)brace
id|fh_unlock
c_func
(paren
id|fhp
)paren
suffix:semicolon
multiline_comment|/* unlock inode */
r_if
c_cond
(paren
id|err
op_ge
l_int|0
op_logical_and
id|stable
)paren
(brace
r_static
r_int
r_int
id|last_ino
op_assign
l_int|0
suffix:semicolon
r_static
id|kdev_t
id|last_dev
op_assign
id|NODEV
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Gathered writes: If another process is currently&n;&t;&t; * writing to the file, there&squot;s a high chance&n;&t;&t; * this is another nfsd (triggered by a bulk write&n;&t;&t; * from a client&squot;s biod). Rather than syncing the&n;&t;&t; * file with each write request, we sleep for 10 msec.&n;&t;&t; *&n;&t;&t; * I don&squot;t know if this roughly approximates&n;&t;&t; * C. Juszak&squot;s idea of gathered writes, but it&squot;s a&n;&t;&t; * nice and simple solution (IMHO), and it seems to&n;&t;&t; * work:-)&n;&t;&t; */
r_if
c_cond
(paren
id|EX_WGATHER
c_func
(paren
id|exp
)paren
op_logical_and
(paren
id|inode-&gt;i_writecount
OG
l_int|1
op_logical_or
(paren
id|last_ino
op_eq
id|inode-&gt;i_ino
op_logical_and
id|last_dev
op_eq
id|inode-&gt;i_dev
)paren
)paren
)paren
(brace
macro_line|#if 0
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|inode-&gt;i_wait
comma
l_int|10
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
macro_line|#else
id|dprintk
c_func
(paren
l_string|&quot;nfsd: write defer %d&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
(paren
id|HZ
op_plus
l_int|99
)paren
op_div
l_int|100
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;nfsd: write resume %d&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|inode-&gt;i_state
op_amp
id|I_DIRTY
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;nfsd: write sync %d&bslash;n&quot;
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|nfsd_sync
c_func
(paren
id|inode
comma
op_amp
id|file
)paren
suffix:semicolon
id|write_inode_now
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
id|wake_up
c_func
(paren
op_amp
id|inode-&gt;i_wait
)paren
suffix:semicolon
id|last_ino
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|last_dev
op_assign
id|inode-&gt;i_dev
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;nfsd: write complete&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ge
l_int|0
)paren
id|err
op_assign
l_int|0
suffix:semicolon
r_else
id|err
op_assign
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
id|out_close
suffix:colon
id|nfsd_close
c_func
(paren
op_amp
id|file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a file (regular, directory, device, fifo); UNIX sockets &n; * not yet implemented.&n; * If the response fh has been verified, the parent directory should&n; * already be locked. Note that the parent directory is left locked.&n; *&n; * N.B. Every call to nfsd_create needs an fh_put for _both_ fhp and resfhp&n; */
r_int
DECL|function|nfsd_create
id|nfsd_create
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_char
op_star
id|fname
comma
r_int
id|flen
comma
r_struct
id|iattr
op_star
id|iap
comma
r_int
id|type
comma
id|dev_t
id|rdev
comma
r_struct
id|svc_fh
op_star
id|resfhp
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
comma
op_star
id|dchild
suffix:semicolon
r_struct
id|inode
op_star
id|dirp
suffix:semicolon
id|nfsd_dirop_t
id|opfunc
op_assign
l_int|NULL
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flen
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFDIR
comma
id|MAY_CREATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|dirp
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|err
op_assign
id|nfserr_notdir
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dirp-&gt;i_op
op_logical_or
op_logical_neg
id|dirp-&gt;i_op-&gt;lookup
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check whether the response file handle has been verified yet.&n;&t; * If it has, the parent directory should already be locked.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|resfhp-&gt;fh_dverified
)paren
(brace
id|dchild
op_assign
id|lookup_dentry
c_func
(paren
id|fname
comma
id|dget
c_func
(paren
id|dentry
)paren
comma
l_int|0
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|dchild
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dchild
)paren
)paren
r_goto
id|out_nfserr
suffix:semicolon
id|fh_compose
c_func
(paren
id|resfhp
comma
id|fhp-&gt;fh_export
comma
id|dchild
)paren
suffix:semicolon
multiline_comment|/* Lock the parent and check for errors ... */
id|err
op_assign
id|fh_lock_parent
c_func
(paren
id|fhp
comma
id|dchild
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
(brace
id|dchild
op_assign
id|resfhp-&gt;fh_dentry
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fhp-&gt;fh_locked
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;nfsd_create: parent %s/%s not locked!&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Make sure the child dentry is still negative ...&n;&t; */
id|err
op_assign
id|nfserr_exist
suffix:semicolon
r_if
c_cond
(paren
id|dchild-&gt;d_inode
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;nfsd_create: dentry %s/%s not negative!&bslash;n&quot;
comma
id|dentry-&gt;d_name.name
comma
id|dchild-&gt;d_name.name
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get the dir op function pointer.&n;&t; */
id|err
op_assign
id|nfserr_perm
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|S_IFREG
suffix:colon
id|opfunc
op_assign
(paren
id|nfsd_dirop_t
)paren
id|dirp-&gt;i_op-&gt;create
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFDIR
suffix:colon
id|opfunc
op_assign
(paren
id|nfsd_dirop_t
)paren
id|dirp-&gt;i_op-&gt;mkdir
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFCHR
suffix:colon
r_case
id|S_IFBLK
suffix:colon
multiline_comment|/* The client is _NOT_ required to do security enforcement */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_case
id|S_IFIFO
suffix:colon
r_case
id|S_IFSOCK
suffix:colon
id|opfunc
op_assign
id|dirp-&gt;i_op-&gt;mknod
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|opfunc
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|iap-&gt;ia_valid
op_amp
id|ATTR_MODE
)paren
)paren
id|iap-&gt;ia_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Call the dir op function to create the object.&n;&t; */
id|DQUOT_INIT
c_func
(paren
id|dirp
)paren
suffix:semicolon
id|err
op_assign
id|opfunc
c_func
(paren
id|dirp
comma
id|dchild
comma
id|iap-&gt;ia_mode
comma
id|rdev
)paren
suffix:semicolon
id|DQUOT_DROP
c_func
(paren
id|dirp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_nfserr
suffix:semicolon
r_if
c_cond
(paren
id|EX_ISSYNC
c_func
(paren
id|fhp-&gt;fh_export
)paren
)paren
id|write_inode_now
c_func
(paren
id|dirp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update the file handle to get the new inode info.&n;&t; */
id|fh_update
c_func
(paren
id|resfhp
)paren
suffix:semicolon
multiline_comment|/* Set file attributes. Mode has already been set and&n;&t; * setting uid/gid works only for root. Irix appears to&n;&t; * send along the gid when it tries to implement setgid&n;&t; * directories via NFS.&n;&t; */
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iap-&gt;ia_valid
op_and_assign
op_complement
(paren
id|ATTR_UID
op_or
id|ATTR_GID
op_or
id|ATTR_MODE
)paren
)paren
op_ne
l_int|0
)paren
id|err
op_assign
id|nfsd_setattr
c_func
(paren
id|rqstp
comma
id|resfhp
comma
id|iap
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out_nfserr
suffix:colon
id|err
op_assign
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Truncate a file.&n; * The calling routines must make sure to update the ctime&n; * field and call notify_change.&n; *&n; * XXX Nobody calls this thing? -DaveM&n; * N.B. After this call fhp needs an fh_put&n; */
r_int
DECL|function|nfsd_truncate
id|nfsd_truncate
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_int
r_int
id|size
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|iattr
id|newattrs
suffix:semicolon
r_int
id|err
suffix:semicolon
id|kernel_cap_t
id|saved_cap
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFREG
comma
id|MAY_WRITE
op_or
id|MAY_TRUNC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|err
op_assign
id|get_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_nfserr
suffix:semicolon
multiline_comment|/* Things look sane, lock and do it. */
id|fh_lock
c_func
(paren
id|fhp
)paren
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|inode
)paren
suffix:semicolon
id|newattrs.ia_size
op_assign
id|size
suffix:semicolon
id|newattrs.ia_valid
op_assign
id|ATTR_SIZE
op_or
id|ATTR_CTIME
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;fsuid
op_ne
l_int|0
)paren
(brace
id|saved_cap
op_assign
id|current-&gt;cap_effective
suffix:semicolon
id|cap_clear
c_func
(paren
id|current-&gt;cap_effective
)paren
suffix:semicolon
)brace
id|err
op_assign
id|notify_change
c_func
(paren
id|dentry
comma
op_amp
id|newattrs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;fsuid
op_ne
l_int|0
)paren
id|current-&gt;cap_effective
op_assign
id|saved_cap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|vmtruncate
c_func
(paren
id|inode
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_op
op_logical_and
id|inode-&gt;i_op-&gt;truncate
)paren
id|inode-&gt;i_op
op_member_access_from_pointer
id|truncate
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
id|put_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
id|DQUOT_DROP
c_func
(paren
id|inode
)paren
suffix:semicolon
id|fh_unlock
c_func
(paren
id|fhp
)paren
suffix:semicolon
id|out_nfserr
suffix:colon
r_if
c_cond
(paren
id|err
)paren
id|err
op_assign
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Read a symlink. On entry, *lenp must contain the maximum path length that&n; * fits into the buffer. On return, it contains the true length.&n; * N.B. After this call fhp needs an fh_put&n; */
r_int
DECL|function|nfsd_readlink
id|nfsd_readlink
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_char
op_star
id|buf
comma
r_int
op_star
id|lenp
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|mm_segment_t
id|oldfs
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFLNK
comma
id|MAY_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|err
op_assign
id|nfserr_inval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_op
op_logical_or
op_logical_neg
id|inode-&gt;i_op-&gt;readlink
)paren
r_goto
id|out
suffix:semicolon
id|UPDATE_ATIME
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/* N.B. Why does this call need a get_fs()?? */
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|err
op_assign
id|inode-&gt;i_op
op_member_access_from_pointer
id|readlink
c_func
(paren
id|dentry
comma
id|buf
comma
op_star
id|lenp
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|oldfs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_nfserr
suffix:semicolon
op_star
id|lenp
op_assign
id|err
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out_nfserr
suffix:colon
id|err
op_assign
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a symlink and look up its inode&n; * N.B. After this call _both_ fhp and resfhp need an fh_put&n; */
r_int
DECL|function|nfsd_symlink
id|nfsd_symlink
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_char
op_star
id|fname
comma
r_int
id|flen
comma
r_char
op_star
id|path
comma
r_int
id|plen
comma
r_struct
id|svc_fh
op_star
id|resfhp
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
comma
op_star
id|dnew
suffix:semicolon
r_struct
id|inode
op_star
id|dirp
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|nfserr_noent
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flen
op_logical_or
op_logical_neg
id|plen
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFDIR
comma
id|MAY_CREATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|err
op_assign
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
id|nfsd_iscovered
c_func
(paren
id|dentry
comma
id|fhp-&gt;fh_export
)paren
)paren
r_goto
id|out
suffix:semicolon
id|dirp
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dirp-&gt;i_op
op_logical_or
op_logical_neg
id|dirp-&gt;i_op-&gt;symlink
)paren
r_goto
id|out
suffix:semicolon
id|dnew
op_assign
id|lookup_dentry
c_func
(paren
id|fname
comma
id|dget
c_func
(paren
id|dentry
)paren
comma
l_int|0
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|dnew
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dnew
)paren
)paren
r_goto
id|out_nfserr
suffix:semicolon
multiline_comment|/*&n;&t; * Lock the parent before checking for existence&n;&t; */
id|err
op_assign
id|fh_lock_parent
c_func
(paren
id|fhp
comma
id|dnew
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_compose
suffix:semicolon
id|err
op_assign
id|nfserr_exist
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dnew-&gt;d_inode
)paren
(brace
id|DQUOT_INIT
c_func
(paren
id|dirp
)paren
suffix:semicolon
id|err
op_assign
id|dirp-&gt;i_op
op_member_access_from_pointer
id|symlink
c_func
(paren
id|dirp
comma
id|dnew
comma
id|path
)paren
suffix:semicolon
id|DQUOT_DROP
c_func
(paren
id|dirp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
r_if
c_cond
(paren
id|EX_ISSYNC
c_func
(paren
id|fhp-&gt;fh_export
)paren
)paren
id|write_inode_now
c_func
(paren
id|dirp
)paren
suffix:semicolon
)brace
r_else
id|err
op_assign
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
)brace
id|fh_unlock
c_func
(paren
id|fhp
)paren
suffix:semicolon
multiline_comment|/* Compose the fh so the dentry will be freed ... */
id|out_compose
suffix:colon
id|fh_compose
c_func
(paren
id|resfhp
comma
id|fhp-&gt;fh_export
comma
id|dnew
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out_nfserr
suffix:colon
id|err
op_assign
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a hardlink&n; * N.B. After this call _both_ ffhp and tfhp need an fh_put&n; */
r_int
DECL|function|nfsd_link
id|nfsd_link
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|ffhp
comma
r_char
op_star
id|fname
comma
r_int
id|len
comma
r_struct
id|svc_fh
op_star
id|tfhp
)paren
(brace
r_struct
id|dentry
op_star
id|ddir
comma
op_star
id|dnew
comma
op_star
id|dold
suffix:semicolon
r_struct
id|inode
op_star
id|dirp
comma
op_star
id|dest
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|ffhp
comma
id|S_IFDIR
comma
id|MAY_CREATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|tfhp
comma
id|S_IFREG
comma
id|MAY_NOP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
)paren
r_goto
id|out
suffix:semicolon
id|ddir
op_assign
id|ffhp-&gt;fh_dentry
suffix:semicolon
id|dirp
op_assign
id|ddir-&gt;d_inode
suffix:semicolon
id|dnew
op_assign
id|lookup_dentry
c_func
(paren
id|fname
comma
id|dget
c_func
(paren
id|ddir
)paren
comma
l_int|0
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|dnew
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dnew
)paren
)paren
r_goto
id|out_nfserr
suffix:semicolon
multiline_comment|/*&n;&t; * Lock the parent before checking for existence&n;&t; */
id|err
op_assign
id|fh_lock_parent
c_func
(paren
id|ffhp
comma
id|dnew
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_dput
suffix:semicolon
id|err
op_assign
id|nfserr_exist
suffix:semicolon
r_if
c_cond
(paren
id|dnew-&gt;d_inode
)paren
r_goto
id|out_unlock
suffix:semicolon
id|dold
op_assign
id|tfhp-&gt;fh_dentry
suffix:semicolon
id|dest
op_assign
id|dold-&gt;d_inode
suffix:semicolon
id|err
op_assign
id|nfserr_acces
suffix:semicolon
r_if
c_cond
(paren
id|nfsd_iscovered
c_func
(paren
id|ddir
comma
id|ffhp-&gt;fh_export
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/* FIXME: nxdev for NFSv3 */
r_if
c_cond
(paren
id|dirp-&gt;i_dev
op_ne
id|dest-&gt;i_dev
)paren
r_goto
id|out_unlock
suffix:semicolon
id|err
op_assign
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
id|IS_IMMUTABLE
c_func
(paren
id|dest
)paren
op_logical_or
id|IS_APPEND
c_func
(paren
id|dest
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dirp-&gt;i_op
op_logical_or
op_logical_neg
id|dirp-&gt;i_op-&gt;link
)paren
r_goto
id|out_unlock
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|dirp
)paren
suffix:semicolon
id|err
op_assign
id|dirp-&gt;i_op
op_member_access_from_pointer
id|link
c_func
(paren
id|dold
comma
id|dirp
comma
id|dnew
)paren
suffix:semicolon
id|DQUOT_DROP
c_func
(paren
id|dirp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
r_if
c_cond
(paren
id|EX_ISSYNC
c_func
(paren
id|ffhp-&gt;fh_export
)paren
)paren
(brace
id|write_inode_now
c_func
(paren
id|dirp
)paren
suffix:semicolon
id|write_inode_now
c_func
(paren
id|dest
)paren
suffix:semicolon
)brace
)brace
r_else
id|err
op_assign
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|fh_unlock
c_func
(paren
id|ffhp
)paren
suffix:semicolon
id|out_dput
suffix:colon
id|dput
c_func
(paren
id|dnew
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out_nfserr
suffix:colon
id|err
op_assign
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * We need to do a check-parent every time&n; * after we have locked the parent - to verify&n; * that the parent is still our parent and&n; * that we are still hashed onto it..&n; *&n; * This is requied in case two processes race&n; * on removing (or moving) the same entry: the&n; * parent lock will serialize them, but the&n; * other process will be too late..&n; */
DECL|macro|check_parent
mdefine_line|#define check_parent(dir, dentry) &bslash;&n;&t;((dir) == (dentry)-&gt;d_parent-&gt;d_inode &amp;&amp; !list_empty(&amp;dentry-&gt;d_hash))
multiline_comment|/*&n; * This follows the model of double_lock() in the VFS.&n; */
DECL|function|nfsd_double_down
r_static
r_inline
r_void
id|nfsd_double_down
c_func
(paren
r_struct
id|semaphore
op_star
id|s1
comma
r_struct
id|semaphore
op_star
id|s2
)paren
(brace
r_if
c_cond
(paren
id|s1
op_ne
id|s2
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|s1
OG
(paren
r_int
r_int
)paren
id|s2
)paren
(brace
r_struct
id|semaphore
op_star
id|tmp
op_assign
id|s1
suffix:semicolon
id|s1
op_assign
id|s2
suffix:semicolon
id|s2
op_assign
id|tmp
suffix:semicolon
)brace
id|down
c_func
(paren
id|s1
)paren
suffix:semicolon
)brace
id|down
c_func
(paren
id|s2
)paren
suffix:semicolon
)brace
DECL|function|nfsd_double_up
r_static
r_inline
r_void
id|nfsd_double_up
c_func
(paren
r_struct
id|semaphore
op_star
id|s1
comma
r_struct
id|semaphore
op_star
id|s2
)paren
(brace
id|up
c_func
(paren
id|s1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s1
op_ne
id|s2
)paren
id|up
c_func
(paren
id|s2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Rename a file&n; * N.B. After this call _both_ ffhp and tfhp need an fh_put&n; */
r_int
DECL|function|nfsd_rename
id|nfsd_rename
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|ffhp
comma
r_char
op_star
id|fname
comma
r_int
id|flen
comma
r_struct
id|svc_fh
op_star
id|tfhp
comma
r_char
op_star
id|tname
comma
r_int
id|tlen
)paren
(brace
r_struct
id|dentry
op_star
id|fdentry
comma
op_star
id|tdentry
comma
op_star
id|odentry
comma
op_star
id|ndentry
suffix:semicolon
r_struct
id|inode
op_star
id|fdir
comma
op_star
id|tdir
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|ffhp
comma
id|S_IFDIR
comma
id|MAY_REMOVE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|tfhp
comma
id|S_IFDIR
comma
id|MAY_CREATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|fdentry
op_assign
id|ffhp-&gt;fh_dentry
suffix:semicolon
id|fdir
op_assign
id|fdentry-&gt;d_inode
suffix:semicolon
id|tdentry
op_assign
id|tfhp-&gt;fh_dentry
suffix:semicolon
id|tdir
op_assign
id|tdentry-&gt;d_inode
suffix:semicolon
multiline_comment|/* N.B. We shouldn&squot;t need this ... dentry layer handles it */
id|err
op_assign
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flen
op_logical_or
(paren
id|fname
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
(paren
id|flen
op_eq
l_int|1
op_logical_or
(paren
id|flen
op_eq
l_int|2
op_logical_and
id|fname
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
)paren
)paren
op_logical_or
op_logical_neg
id|tlen
op_logical_or
(paren
id|tname
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
(paren
id|tlen
op_eq
l_int|1
op_logical_or
(paren
id|tlen
op_eq
l_int|2
op_logical_and
id|tname
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|odentry
op_assign
id|lookup_dentry
c_func
(paren
id|fname
comma
id|dget
c_func
(paren
id|fdentry
)paren
comma
l_int|0
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|odentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|odentry
)paren
)paren
r_goto
id|out_nfserr
suffix:semicolon
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|odentry-&gt;d_inode
)paren
r_goto
id|out_dput_old
suffix:semicolon
id|ndentry
op_assign
id|lookup_dentry
c_func
(paren
id|tname
comma
id|dget
c_func
(paren
id|tdentry
)paren
comma
l_int|0
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|ndentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ndentry
)paren
)paren
r_goto
id|out_dput_old
suffix:semicolon
multiline_comment|/*&n;&t; * Lock the parent directories.&n;&t; */
id|nfsd_double_down
c_func
(paren
op_amp
id|tdir-&gt;i_sem
comma
op_amp
id|fdir-&gt;i_sem
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
multiline_comment|/* GAM3 check for parent changes after locking. */
r_if
c_cond
(paren
id|check_parent
c_func
(paren
id|fdir
comma
id|odentry
)paren
op_logical_and
id|check_parent
c_func
(paren
id|tdir
comma
id|ndentry
)paren
)paren
(brace
id|err
op_assign
id|vfs_rename
c_func
(paren
id|fdir
comma
id|odentry
comma
id|tdir
comma
id|ndentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
op_logical_and
id|EX_ISSYNC
c_func
(paren
id|tfhp-&gt;fh_export
)paren
)paren
(brace
id|write_inode_now
c_func
(paren
id|fdir
)paren
suffix:semicolon
id|write_inode_now
c_func
(paren
id|tdir
)paren
suffix:semicolon
)brace
)brace
r_else
id|dprintk
c_func
(paren
l_string|&quot;nfsd: Caught race in nfsd_rename&quot;
)paren
suffix:semicolon
id|DQUOT_DROP
c_func
(paren
id|fdir
)paren
suffix:semicolon
id|DQUOT_DROP
c_func
(paren
id|tdir
)paren
suffix:semicolon
id|nfsd_double_up
c_func
(paren
op_amp
id|tdir-&gt;i_sem
comma
op_amp
id|fdir-&gt;i_sem
)paren
suffix:semicolon
id|dput
c_func
(paren
id|ndentry
)paren
suffix:semicolon
id|out_dput_old
suffix:colon
id|dput
c_func
(paren
id|odentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_nfserr
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out_nfserr
suffix:colon
id|err
op_assign
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Unlink a file or directory&n; * N.B. After this call fhp needs an fh_put&n; */
r_int
DECL|function|nfsd_unlink
id|nfsd_unlink
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_int
id|type
comma
r_char
op_star
id|fname
comma
r_int
id|flen
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
comma
op_star
id|rdentry
suffix:semicolon
r_struct
id|inode
op_star
id|dirp
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/* N.B. We shouldn&squot;t need this test ... handled by dentry layer */
id|err
op_assign
id|nfserr_acces
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flen
op_logical_or
id|isdotent
c_func
(paren
id|fname
comma
id|flen
)paren
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFDIR
comma
id|MAY_REMOVE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|dirp
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|rdentry
op_assign
id|lookup_dentry
c_func
(paren
id|fname
comma
id|dget
c_func
(paren
id|dentry
)paren
comma
l_int|0
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|rdentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|rdentry
)paren
)paren
r_goto
id|out_nfserr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdentry-&gt;d_inode
)paren
(brace
id|dput
c_func
(paren
id|rdentry
)paren
suffix:semicolon
id|err
op_assign
id|nfserr_noent
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|expire_by_dentry
c_func
(paren
id|rdentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
id|S_IFDIR
)paren
(brace
multiline_comment|/* It&squot;s UNLINK */
id|err
op_assign
id|fh_lock_parent
c_func
(paren
id|fhp
comma
id|rdentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|vfs_unlink
c_func
(paren
id|dirp
comma
id|rdentry
)paren
suffix:semicolon
id|DQUOT_DROP
c_func
(paren
id|dirp
)paren
suffix:semicolon
id|fh_unlock
c_func
(paren
id|fhp
)paren
suffix:semicolon
id|dput
c_func
(paren
id|rdentry
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* It&squot;s RMDIR */
multiline_comment|/* See comments in fs/namei.c:do_rmdir */
id|rdentry-&gt;d_count
op_increment
suffix:semicolon
id|nfsd_double_down
c_func
(paren
op_amp
id|dirp-&gt;i_sem
comma
op_amp
id|rdentry-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fhp-&gt;fh_pre_mtime
)paren
id|fhp-&gt;fh_pre_mtime
op_assign
id|dirp-&gt;i_mtime
suffix:semicolon
id|fhp-&gt;fh_locked
op_assign
l_int|1
suffix:semicolon
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|check_parent
c_func
(paren
id|dirp
comma
id|rdentry
)paren
)paren
id|err
op_assign
id|vfs_rmdir
c_func
(paren
id|dirp
comma
id|rdentry
)paren
suffix:semicolon
id|rdentry-&gt;d_count
op_decrement
suffix:semicolon
id|DQUOT_DROP
c_func
(paren
id|dirp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fhp-&gt;fh_post_version
)paren
id|fhp-&gt;fh_post_version
op_assign
id|dirp-&gt;i_version
suffix:semicolon
id|fhp-&gt;fh_locked
op_assign
l_int|0
suffix:semicolon
id|nfsd_double_up
c_func
(paren
op_amp
id|dirp-&gt;i_sem
comma
op_amp
id|rdentry-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|dput
c_func
(paren
id|rdentry
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_nfserr
suffix:semicolon
r_if
c_cond
(paren
id|EX_ISSYNC
c_func
(paren
id|fhp-&gt;fh_export
)paren
)paren
id|write_inode_now
c_func
(paren
id|dirp
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out_nfserr
suffix:colon
id|err
op_assign
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Read entries from a directory.&n; */
r_int
DECL|function|nfsd_readdir
id|nfsd_readdir
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
id|loff_t
id|offset
comma
id|encode_dent_fn
id|func
comma
id|u32
op_star
id|buffer
comma
r_int
op_star
id|countp
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|u32
op_star
id|p
suffix:semicolon
r_int
id|oldlen
comma
id|eof
comma
id|err
suffix:semicolon
r_struct
id|file
id|file
suffix:semicolon
r_struct
id|readdir_cd
id|cd
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
op_complement
(paren
id|u32
)paren
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|nfsd_open
c_func
(paren
id|rqstp
comma
id|fhp
comma
id|S_IFDIR
comma
id|OPEN_READ
comma
op_amp
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|nfserr_notdir
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file.f_op-&gt;readdir
)paren
r_goto
id|out_close
suffix:semicolon
id|file.f_pos
op_assign
id|offset
suffix:semicolon
multiline_comment|/* Set up the readdir context */
id|memset
c_func
(paren
op_amp
id|cd
comma
l_int|0
comma
r_sizeof
(paren
id|cd
)paren
)paren
suffix:semicolon
id|cd.rqstp
op_assign
id|rqstp
suffix:semicolon
id|cd.buffer
op_assign
id|buffer
suffix:semicolon
id|cd.buflen
op_assign
op_star
id|countp
suffix:semicolon
multiline_comment|/* count of words */
multiline_comment|/*&n;&t; * Read the directory entries. This silly loop is necessary because&n;&t; * readdir() is not guaranteed to fill up the entire buffer, but&n;&t; * may choose to do less.&n;&t; */
id|inode
op_assign
id|file.f_dentry-&gt;d_inode
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|oldlen
op_assign
id|cd.buflen
suffix:semicolon
multiline_comment|/*&n;&t;&t;dprintk(&quot;nfsd: f_op-&gt;readdir(%x/%ld @ %d) buflen = %d (%d)&bslash;n&quot;,&n;&t;&t;&t;file.f_inode-&gt;i_dev, file.f_inode-&gt;i_ino,&n;&t;&t;&t;(int) file.f_pos, (int) oldlen, (int) cd.buflen);&n;&t;&t; */
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|err
op_assign
id|file.f_op
op_member_access_from_pointer
id|readdir
c_func
(paren
op_amp
id|file
comma
op_amp
id|cd
comma
(paren
id|filldir_t
)paren
id|func
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out_nfserr
suffix:semicolon
r_if
c_cond
(paren
id|oldlen
op_eq
id|cd.buflen
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|cd.eob
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* If we didn&squot;t fill the buffer completely, we&squot;re at EOF */
id|eof
op_assign
op_logical_neg
id|cd.eob
suffix:semicolon
r_if
c_cond
(paren
id|cd.offset
)paren
op_star
id|cd.offset
op_assign
id|htonl
c_func
(paren
id|file.f_pos
)paren
suffix:semicolon
id|p
op_assign
id|cd.buffer
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no more entries */
op_star
id|p
op_increment
op_assign
id|htonl
c_func
(paren
id|eof
)paren
suffix:semicolon
multiline_comment|/* end of directory */
op_star
id|countp
op_assign
(paren
id|caddr_t
)paren
id|p
op_minus
(paren
id|caddr_t
)paren
id|buffer
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;nfsd: readdir result %d bytes, eof %d offset %ld&bslash;n&quot;
comma
op_star
id|countp
comma
id|eof
comma
id|cd.offset
ques
c_cond
id|ntohl
c_func
(paren
op_star
id|cd.offset
)paren
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|out_close
suffix:colon
id|nfsd_close
c_func
(paren
op_amp
id|file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
id|out_nfserr
suffix:colon
id|err
op_assign
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:semicolon
r_goto
id|out_close
suffix:semicolon
)brace
multiline_comment|/*&n; * Get file system stats&n; * N.B. After this call fhp needs an fh_put&n; */
r_int
DECL|function|nfsd_statfs
id|nfsd_statfs
c_func
(paren
r_struct
id|svc_rqst
op_star
id|rqstp
comma
r_struct
id|svc_fh
op_star
id|fhp
comma
r_struct
id|statfs
op_star
id|stat
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
id|mm_segment_t
id|oldfs
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
id|fh_verify
c_func
(paren
id|rqstp
comma
id|fhp
comma
l_int|0
comma
id|MAY_NOP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|fhp-&gt;fh_dentry
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|err
op_assign
id|nfserr_io
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sb
op_assign
id|inode-&gt;i_sb
)paren
op_logical_or
op_logical_neg
id|sb-&gt;s_op-&gt;statfs
)paren
r_goto
id|out
suffix:semicolon
id|oldfs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|sb-&gt;s_op
op_member_access_from_pointer
id|statfs
c_func
(paren
id|sb
comma
id|stat
comma
r_sizeof
(paren
op_star
id|stat
)paren
)paren
suffix:semicolon
id|set_fs
(paren
id|oldfs
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Check for a user&squot;s access permissions to this inode.&n; */
r_int
DECL|function|nfsd_permission
id|nfsd_permission
c_func
(paren
r_struct
id|svc_export
op_star
id|exp
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|acc
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_int
id|err
suffix:semicolon
id|kernel_cap_t
id|saved_cap
suffix:semicolon
r_if
c_cond
(paren
id|acc
op_eq
id|MAY_NOP
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#if 0
id|dprintk
c_func
(paren
l_string|&quot;nfsd: permission 0x%x%s%s%s%s%s mode 0%o%s%s%s&bslash;n&quot;
comma
id|acc
comma
(paren
id|acc
op_amp
id|MAY_READ
)paren
ques
c_cond
l_string|&quot; read&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|acc
op_amp
id|MAY_WRITE
)paren
ques
c_cond
l_string|&quot; write&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|acc
op_amp
id|MAY_EXEC
)paren
ques
c_cond
l_string|&quot; exec&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|acc
op_amp
id|MAY_SATTR
)paren
ques
c_cond
l_string|&quot; sattr&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|acc
op_amp
id|MAY_TRUNC
)paren
ques
c_cond
l_string|&quot; trunc&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|inode-&gt;i_mode
comma
id|IS_IMMUTABLE
c_func
(paren
id|inode
)paren
ques
c_cond
l_string|&quot; immut&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|IS_APPEND
c_func
(paren
id|inode
)paren
ques
c_cond
l_string|&quot; append&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|IS_RDONLY
c_func
(paren
id|inode
)paren
ques
c_cond
l_string|&quot; ro&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;      owner %d/%d user %d/%d&bslash;n&quot;
comma
id|inode-&gt;i_uid
comma
id|inode-&gt;i_gid
comma
id|current-&gt;fsuid
comma
id|current-&gt;fsgid
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifndef CONFIG_NFSD_SUN
r_if
c_cond
(paren
id|dentry-&gt;d_mounts
op_ne
id|dentry
)paren
(brace
r_return
id|nfserr_perm
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|acc
op_amp
(paren
id|MAY_WRITE
op_or
id|MAY_SATTR
op_or
id|MAY_TRUNC
)paren
)paren
(brace
r_if
c_cond
(paren
id|EX_RDONLY
c_func
(paren
id|exp
)paren
op_logical_or
id|IS_RDONLY
c_func
(paren
id|inode
)paren
)paren
r_return
id|nfserr_rofs
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
id|nfsd_iscovered
c_func
(paren
id|dentry
comma
id|exp
)paren
)paren
r_return
id|nfserr_perm
suffix:semicolon
r_if
c_cond
(paren
multiline_comment|/* (acc &amp; MAY_WRITE) &amp;&amp; */
id|IS_IMMUTABLE
c_func
(paren
id|inode
)paren
)paren
r_return
id|nfserr_perm
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|acc
op_amp
id|MAY_TRUNC
)paren
op_logical_and
id|IS_APPEND
c_func
(paren
id|inode
)paren
)paren
r_return
id|nfserr_perm
suffix:semicolon
multiline_comment|/*&n;&t; * The file owner always gets access permission. This is to make&n;&t; * file access work even when the client has done a fchmod(fd, 0).&n;&t; *&n;&t; * However, `cp foo bar&squot; should fail nevertheless when bar is&n;&t; * readonly. A sensible way to do this might be to reject all&n;&t; * attempts to truncate a read-only file, because a creat() call&n;&t; * always implies file truncation.&n;&t; */
r_if
c_cond
(paren
id|inode-&gt;i_uid
op_eq
id|current-&gt;fsuid
multiline_comment|/* &amp;&amp; !(acc &amp; MAY_TRUNC) */
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;fsuid
op_ne
l_int|0
)paren
(brace
id|saved_cap
op_assign
id|current-&gt;cap_effective
suffix:semicolon
id|cap_clear
c_func
(paren
id|current-&gt;cap_effective
)paren
suffix:semicolon
)brace
id|err
op_assign
id|permission
c_func
(paren
id|inode
comma
id|acc
op_amp
(paren
id|MAY_READ
op_or
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
)paren
suffix:semicolon
multiline_comment|/* Allow read access to binaries even when mode 111 */
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EACCES
op_logical_and
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
id|acc
op_eq
id|MAY_READ
)paren
id|err
op_assign
id|permission
c_func
(paren
id|inode
comma
id|MAY_EXEC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;fsuid
op_ne
l_int|0
)paren
id|current-&gt;cap_effective
op_assign
id|saved_cap
suffix:semicolon
r_return
id|err
ques
c_cond
id|nfserrno
c_func
(paren
op_minus
id|err
)paren
suffix:colon
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|nfsd_racache_shutdown
id|nfsd_racache_shutdown
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|raparm_cache
)paren
r_return
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;nfsd: freeing %d readahead buffers.&bslash;n&quot;
comma
id|FILECACHE_MAX
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|raparml
)paren
suffix:semicolon
id|nfsd_nservers
op_assign
l_int|0
suffix:semicolon
id|raparm_cache
op_assign
id|raparml
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize readahead param cache&n; */
r_void
DECL|function|nfsd_racache_init
id|nfsd_racache_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|raparm_cache
)paren
r_return
suffix:semicolon
id|raparml
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|raparms
)paren
op_star
id|FILECACHE_MAX
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raparml
op_ne
l_int|NULL
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;nfsd: allocating %d readahead buffers.&bslash;n&quot;
comma
id|FILECACHE_MAX
)paren
suffix:semicolon
id|memset
c_func
(paren
id|raparml
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|raparms
)paren
op_star
id|FILECACHE_MAX
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FILECACHE_MAX
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|raparml
(braket
id|i
)braket
dot
id|p_next
op_assign
id|raparml
op_plus
id|i
op_plus
l_int|1
suffix:semicolon
)brace
id|raparm_cache
op_assign
id|raparml
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;nfsd: Could not allocate memory read-ahead cache.&bslash;n&quot;
)paren
suffix:semicolon
id|nfsd_nservers
op_assign
l_int|0
suffix:semicolon
)brace
)brace
eof
