multiline_comment|/*&n; * linux/fs/lockd/clntlock.c&n; *&n; * Lock handling for the client side NLM implementation&n; *&n; * Copyright (C) 1996, Olaf Kirch &lt;okir@monad.swb.de&gt;&n; */
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/nfs_fs.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/sunrpc/clnt.h&gt;
macro_line|#include &lt;linux/sunrpc/svc.h&gt;
macro_line|#include &lt;linux/lockd/lockd.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
DECL|macro|NLMDBG_FACILITY
mdefine_line|#define NLMDBG_FACILITY&t;&t;NLMDBG_CIENT
multiline_comment|/*&n; * Local function prototypes&n; */
r_static
r_int
id|reclaimer
c_func
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
multiline_comment|/*&n; * The following functions handle blocking and granting from the&n; * client perspective.&n; */
multiline_comment|/*&n; * This is the representation of a blocked client lock.&n; */
DECL|struct|nlm_wait
r_struct
id|nlm_wait
(brace
DECL|member|b_next
r_struct
id|nlm_wait
op_star
id|b_next
suffix:semicolon
multiline_comment|/* linked list */
DECL|member|b_wait
id|wait_queue_head_t
id|b_wait
suffix:semicolon
multiline_comment|/* where to wait on */
DECL|member|b_host
r_struct
id|nlm_host
op_star
id|b_host
suffix:semicolon
DECL|member|b_lock
r_struct
id|file_lock
op_star
id|b_lock
suffix:semicolon
multiline_comment|/* local file lock */
DECL|member|b_reclaim
r_int
r_int
id|b_reclaim
suffix:semicolon
multiline_comment|/* got to reclaim lock */
DECL|member|b_status
id|u32
id|b_status
suffix:semicolon
multiline_comment|/* grant callback status */
)brace
suffix:semicolon
DECL|variable|nlm_blocked
r_static
r_struct
id|nlm_wait
op_star
id|nlm_blocked
suffix:semicolon
multiline_comment|/*&n; * Block on a lock&n; */
r_int
DECL|function|nlmclnt_block
id|nlmclnt_block
c_func
(paren
r_struct
id|nlm_host
op_star
id|host
comma
r_struct
id|file_lock
op_star
id|fl
comma
id|u32
op_star
id|statp
)paren
(brace
r_struct
id|nlm_wait
id|block
comma
op_star
op_star
id|head
suffix:semicolon
r_int
id|err
suffix:semicolon
id|u32
id|pstate
suffix:semicolon
id|block.b_host
op_assign
id|host
suffix:semicolon
id|block.b_lock
op_assign
id|fl
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|block.b_wait
)paren
suffix:semicolon
id|block.b_status
op_assign
id|NLM_LCK_BLOCKED
suffix:semicolon
id|block.b_next
op_assign
id|nlm_blocked
suffix:semicolon
id|nlm_blocked
op_assign
op_amp
id|block
suffix:semicolon
multiline_comment|/* Remember pseudo nsm state */
id|pstate
op_assign
id|host-&gt;h_state
suffix:semicolon
multiline_comment|/* Go to sleep waiting for GRANT callback. Some servers seem&n;&t; * to lose callbacks, however, so we&squot;re going to poll from&n;&t; * time to time just to make sure.&n;&t; *&n;&t; * For now, the retry frequency is pretty high; normally &n;&t; * a 1 minute timeout would do. See the comment before&n;&t; * nlmclnt_lock for an explanation.&n;&t; */
id|sleep_on_timeout
c_func
(paren
op_amp
id|block.b_wait
comma
l_int|30
op_star
id|HZ
)paren
suffix:semicolon
r_for
c_loop
(paren
id|head
op_assign
op_amp
id|nlm_blocked
suffix:semicolon
op_star
id|head
suffix:semicolon
id|head
op_assign
op_amp
(paren
op_star
id|head
)paren
op_member_access_from_pointer
id|b_next
)paren
(brace
r_if
c_cond
(paren
op_star
id|head
op_eq
op_amp
id|block
)paren
(brace
op_star
id|head
op_assign
id|block.b_next
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|signalled
c_func
(paren
)paren
)paren
(brace
op_star
id|statp
op_assign
id|block.b_status
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Okay, we were interrupted. Cancel the pending request&n;&t; * unless the server has rebooted.&n;&t; */
r_if
c_cond
(paren
id|pstate
op_eq
id|host-&gt;h_state
op_logical_and
(paren
id|err
op_assign
id|nlmclnt_cancel
c_func
(paren
id|host
comma
id|fl
)paren
)paren
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;lockd: CANCEL call failed (errno %d)&bslash;n&quot;
comma
op_minus
id|err
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
multiline_comment|/*&n; * The server lockd has called us back to tell us the lock was granted&n; */
id|u32
DECL|function|nlmclnt_grant
id|nlmclnt_grant
c_func
(paren
r_struct
id|nlm_lock
op_star
id|lock
)paren
(brace
r_struct
id|nlm_wait
op_star
id|block
suffix:semicolon
multiline_comment|/*&n;&t; * Look up blocked request based on arguments. &n;&t; * Warning: must not use cookie to match it!&n;&t; */
r_for
c_loop
(paren
id|block
op_assign
id|nlm_blocked
suffix:semicolon
id|block
suffix:semicolon
id|block
op_assign
id|block-&gt;b_next
)paren
(brace
r_if
c_cond
(paren
id|nlm_compare_locks
c_func
(paren
id|block-&gt;b_lock
comma
op_amp
id|lock-&gt;fl
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Ooops, no blocked request found. */
r_if
c_cond
(paren
id|block
op_eq
l_int|NULL
)paren
r_return
id|nlm_lck_denied
suffix:semicolon
multiline_comment|/* Alright, we found the lock. Set the return status and&n;&t; * wake up the caller.&n;&t; */
id|block-&gt;b_status
op_assign
id|NLM_LCK_GRANTED
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|block-&gt;b_wait
)paren
suffix:semicolon
r_return
id|nlm_granted
suffix:semicolon
)brace
multiline_comment|/*&n; * The following procedures deal with the recovery of locks after a&n; * server crash.&n; */
multiline_comment|/*&n; * Reclaim all locks on server host. We do this by spawning a separate&n; * reclaimer thread.&n; * FIXME: should bump MOD_USE_COUNT while reclaiming&n; */
r_void
DECL|function|nlmclnt_recovery
id|nlmclnt_recovery
c_func
(paren
r_struct
id|nlm_host
op_star
id|host
comma
id|u32
id|newstate
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|host-&gt;h_reclaiming
op_increment
)paren
(brace
r_if
c_cond
(paren
id|host-&gt;h_nsmstate
op_eq
id|newstate
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;lockd: Uh-oh! Interfering reclaims for host %s&quot;
comma
id|host-&gt;h_name
)paren
suffix:semicolon
id|host-&gt;h_monitored
op_assign
l_int|0
suffix:semicolon
id|host-&gt;h_nsmstate
op_assign
id|newstate
suffix:semicolon
id|host-&gt;h_state
op_increment
suffix:semicolon
id|nlm_release_host
c_func
(paren
id|host
)paren
suffix:semicolon
)brace
r_else
(brace
id|host-&gt;h_monitored
op_assign
l_int|0
suffix:semicolon
id|host-&gt;h_nsmstate
op_assign
id|newstate
suffix:semicolon
id|host-&gt;h_state
op_increment
suffix:semicolon
id|nlm_get_host
c_func
(paren
id|host
)paren
suffix:semicolon
id|kernel_thread
c_func
(paren
id|reclaimer
comma
id|host
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|reclaimer
id|reclaimer
c_func
(paren
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|nlm_host
op_star
id|host
op_assign
(paren
r_struct
id|nlm_host
op_star
)paren
id|ptr
suffix:semicolon
r_struct
id|nlm_wait
op_star
id|block
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
multiline_comment|/* This one ensures that our parent doesn&squot;t terminate while the&n;&t; * reclaim is in progress */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|lockd_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* First, reclaim all locks that have been granted previously. */
id|restart
suffix:colon
id|tmp
op_assign
id|file_lock_list.next
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
op_amp
id|file_lock_list
)paren
(brace
r_struct
id|file_lock
op_star
id|fl
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|file_lock
comma
id|fl_link
)paren
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|fl-&gt;fl_file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_sb-&gt;s_magic
op_eq
id|NFS_SUPER_MAGIC
op_logical_and
id|nlm_cmp_addr
c_func
(paren
id|NFS_ADDR
c_func
(paren
id|inode
)paren
comma
op_amp
id|host-&gt;h_addr
)paren
op_logical_and
id|fl-&gt;fl_u.nfs_fl.state
op_ne
id|host-&gt;h_state
op_logical_and
(paren
id|fl-&gt;fl_u.nfs_fl.flags
op_amp
id|NFS_LCK_GRANTED
)paren
)paren
(brace
id|fl-&gt;fl_u.nfs_fl.flags
op_and_assign
op_complement
id|NFS_LCK_GRANTED
suffix:semicolon
id|nlmclnt_reclaim
c_func
(paren
id|host
comma
id|fl
)paren
suffix:semicolon
multiline_comment|/* This sleeps */
r_goto
id|restart
suffix:semicolon
)brace
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
id|host-&gt;h_reclaiming
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|host-&gt;h_gracewait
)paren
suffix:semicolon
multiline_comment|/* Now, wake up all processes that sleep on a blocked lock */
r_for
c_loop
(paren
id|block
op_assign
id|nlm_blocked
suffix:semicolon
id|block
suffix:semicolon
id|block
op_assign
id|block-&gt;b_next
)paren
(brace
r_if
c_cond
(paren
id|block-&gt;b_host
op_eq
id|host
)paren
(brace
id|block-&gt;b_status
op_assign
id|NLM_LCK_DENIED_GRACE_PERIOD
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|block-&gt;b_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Release host handle after use */
id|nlm_release_host
c_func
(paren
id|host
)paren
suffix:semicolon
id|lockd_down
c_func
(paren
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
