multiline_comment|/*&n; *  linux/fs/umsdos/inode.c&n; *&n; *      Written 1993 by Jacques Gelinas&n; *      Inspired from linux/fs/msdos/... by Werner Almesberger&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/msdos_fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/umsdos_fs.h&gt;
macro_line|#include &lt;linux/list.h&gt;
r_extern
r_struct
id|inode_operations
id|umsdos_rdir_inode_operations
suffix:semicolon
DECL|variable|pseudo_root
r_struct
id|inode
op_star
id|pseudo_root
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Useful to simulate the pseudo DOS */
multiline_comment|/* directory. See UMSDOS_readdir_x() */
multiline_comment|/*&n; * returns inode-&gt;i_dentry&n; *&n; */
DECL|function|geti_dentry
r_inline
r_struct
id|dentry
op_star
id|geti_dentry
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|dentry
op_star
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;geti_dentry: ERROR: inode is NULL!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inode-&gt;i_dentry.next
op_eq
id|inode-&gt;i_dentry.next-&gt;next
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;geti_dentry: WARNING: inode does not have an dentry. returning NULL.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|ret
op_assign
id|list_entry
(paren
id|inode-&gt;i_dentry.next
comma
r_struct
id|dentry
comma
id|d_alias
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|ret
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_WARNING
l_string|&quot;geti_dentry: checking dentry... it is ERR(%ld) !&bslash;n&quot;
comma
id|PTR_ERR
c_func
(paren
id|ret
)paren
)paren
)paren
suffix:semicolon
)brace
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;geti_dentry : inode %lu: i_dentry is %p&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * makes inode-&gt;i_count++&n; *&n; */
DECL|function|inc_count
r_inline
r_void
id|inc_count
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|inode-&gt;i_count
op_increment
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;inc_count: inode %lu incremented count to %d&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|inode-&gt;i_count
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * makes empty filp&n; *&n; */
DECL|function|fill_new_filp
r_void
id|fill_new_filp
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;/mn/ fill_new_filp: filling empty filp at %p&bslash;n&quot;
comma
id|filp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
)paren
id|Printk
(paren
(paren
l_string|&quot;     dentry=%.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
r_else
id|Printk
(paren
(paren
l_string|&quot;     dentry is NULL ! you must fill it later...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|memset
(paren
id|filp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|file
)paren
)paren
suffix:semicolon
id|filp-&gt;f_pos
op_assign
l_int|0
suffix:semicolon
id|filp-&gt;f_reada
op_assign
l_int|1
suffix:semicolon
id|filp-&gt;f_flags
op_assign
id|O_RDWR
suffix:semicolon
id|filp-&gt;f_dentry
op_assign
id|dentry
suffix:semicolon
id|filp-&gt;f_op
op_assign
op_amp
id|umsdos_file_operations
suffix:semicolon
multiline_comment|/* /mn/ - we have to fill it with SOMETHING */
)brace
macro_line|#if UMS_DEBUG
multiline_comment|/*&n; * check a superblock&n; */
DECL|function|check_sb
r_void
id|check_sb
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_const
r_char
id|c
)paren
(brace
r_if
c_cond
(paren
id|sb
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (has %c_sb=%d, %d)&quot;
comma
id|c
comma
id|MAJOR
(paren
id|sb-&gt;s_dev
)paren
comma
id|MINOR
(paren
id|sb-&gt;s_dev
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
l_string|&quot; (%c_sb is NULL)&quot;
comma
id|c
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * check an inode&n; */
DECL|function|check_inode
r_void
id|check_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
id|inode
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*   inode is %lu (i_count=%d)&quot;
comma
id|inode-&gt;i_ino
comma
id|inode-&gt;i_count
)paren
)paren
suffix:semicolon
id|check_sb
(paren
id|inode-&gt;i_sb
comma
l_char|&squot;i&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_dentry.next
)paren
(brace
multiline_comment|/* FIXME: does this work ? */
id|Printk
(paren
(paren
l_string|&quot; (has i_dentry)&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
l_string|&quot; (NO i_dentry)&quot;
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
l_int|NULL
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is NULL)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
op_amp
id|umsdos_dir_inode_operations
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is umsdos_dir_inode_operations)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
op_amp
id|umsdos_file_inode_operations
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is umsdos_file_inode_operations)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
op_amp
id|umsdos_file_inode_operations_no_bmap
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is umsdos_file_inode_operations_no_bmap)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
op_amp
id|umsdos_file_inode_operations_readpage
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is umsdos_file_inode_operations_readpage)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
op_amp
id|umsdos_rdir_inode_operations
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is umsdos_rdir_inode_operations)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
op_amp
id|umsdos_symlink_inode_operations
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is umsdos_symlink_inode_operations)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is UNKNOWN: %p)&bslash;n&quot;
comma
id|inode-&gt;i_op
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*   inode is NULL&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * checks all inode-&gt;i_dentry&n; *&n; */
DECL|function|checkd_inode
r_void
id|checkd_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|dentry
op_star
id|ret
suffix:semicolon
r_struct
id|list_head
op_star
id|cur
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;checkd_inode: inode is NULL!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;checkd_inode:  inode %lu&bslash;n&quot;
comma
id|inode-&gt;i_ino
)paren
)paren
suffix:semicolon
id|cur
op_assign
id|inode-&gt;i_dentry.next
suffix:semicolon
r_while
c_loop
(paren
id|count
op_increment
OL
l_int|10
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;1...&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cur
)paren
(brace
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;checkd_inode: *** NULL reached. exit.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|PRINTK
(paren
(paren
l_string|&quot;2...&quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|list_entry
(paren
id|cur
comma
r_struct
id|dentry
comma
id|d_alias
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;3...&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
id|cur-&gt;next
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;checkd_inode: *** cur=cur-&gt;next: normal exit.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|PRINTK
(paren
(paren
l_string|&quot;4...&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;checkd_inode: *** ret dentry is NULL. exit.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|PRINTK
(paren
(paren
l_string|&quot;5... (ret=%p)...&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;5.1.. (ret-&gt;d_dname=%p)...&quot;
comma
op_amp
(paren
id|ret-&gt;d_name
)paren
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;5.1.1. (ret-&gt;d_dname.len=%d)...&quot;
comma
(paren
r_int
)paren
id|ret-&gt;d_name.len
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;5.1.2. (ret-&gt;d_dname.name=%c)...&quot;
comma
id|ret-&gt;d_name.name
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;checkd_inode:   i_dentry is %.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|ret-&gt;d_name.len
comma
id|ret-&gt;d_name.name
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;6...&quot;
)paren
)paren
suffix:semicolon
id|cur
op_assign
id|cur-&gt;next
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;7...&quot;
)paren
)paren
suffix:semicolon
macro_line|#if 1
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;checkd_inode: *** finished after count 1 (operator forced)&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif&t;&t;
)brace
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;checkd_inode: *** OVER LIMIT (loop?) !&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * internal part of check_dentry. does the real job.&n; *&n; */
DECL|function|check_dent_int
r_void
id|check_dent_int
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|parent
)paren
(brace
r_if
c_cond
(paren
id|parent
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*  parent(%d) dentry: %.*s&bslash;n&quot;
comma
id|parent
comma
(paren
r_int
)paren
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*  checking dentry: %.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
)brace
id|check_inode
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*   d_count=%d&quot;
comma
id|dentry-&gt;d_count
)paren
)paren
suffix:semicolon
id|check_sb
(paren
id|dentry-&gt;d_sb
comma
l_char|&squot;d&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_op
op_eq
l_int|NULL
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (d_op is NULL)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
l_string|&quot; (d_op is UNKNOWN: %p)&bslash;n&quot;
comma
id|dentry-&gt;d_op
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * checks dentry with full traceback to root and prints info. Limited to 10 recursive depths to avoid infinite loops.&n; *&n; */
DECL|function|check_dentry_path
r_void
id|check_dentry_path
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|desc
)paren
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*** check_dentry_path: %.60s&bslash;n&quot;
comma
id|desc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*** checking dentry... it is NULL !&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*** checking dentry... it is ERR(%ld) !&bslash;n&quot;
comma
id|PTR_ERR
c_func
(paren
id|dentry
)paren
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dentry
op_logical_and
id|count
OL
l_int|10
)paren
(brace
id|check_dent_int
(paren
id|dentry
comma
id|count
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
op_eq
id|dentry-&gt;d_parent
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*** end checking dentry (root reached ok)&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dentry
op_assign
id|dentry-&gt;d_parent
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_ge
l_int|10
)paren
(brace
multiline_comment|/* if infinite loop detected */
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;*** WARNING ! INFINITE LOOP ! check_dentry_path aborted !&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
(brace
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;*** WARNING ! found NULL dentry ! check_dentry_path aborted !&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
DECL|function|check_sb
r_void
id|check_sb
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_const
r_char
id|c
)paren
(brace
)brace
suffix:semicolon
DECL|function|check_inode
r_void
id|check_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
)brace
suffix:semicolon
DECL|function|checkd_inode
r_void
id|checkd_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
)brace
suffix:semicolon
DECL|function|check_dentry_path
r_void
id|check_dentry_path
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|desc
)paren
(brace
)brace
suffix:semicolon
macro_line|#endif&t;/* UMS_DEBUG */
multiline_comment|/*&n; * makes dentry. for name name with length len.&n; * if inode is not NULL, puts it also.&n; */
DECL|function|creat_dentry
r_struct
id|dentry
op_star
id|creat_dentry
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_int
id|len
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|dentry
op_star
id|parent
)paren
(brace
multiline_comment|/* FIXME /mn/: parent is not passed many times... if it is not, dentry should be destroyed before someone else gets to use it */
r_struct
id|dentry
op_star
id|ret
suffix:semicolon
r_struct
id|qstr
id|qname
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;creat_dentry: creating dentry with inode=%lu for %.*s&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|len
comma
id|name
)paren
)paren
suffix:semicolon
r_else
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;creat_dentry: creating empty dentry for %.*s&bslash;n&quot;
comma
id|len
comma
id|name
)paren
)paren
suffix:semicolon
id|qname.name
op_assign
id|name
suffix:semicolon
id|qname.len
op_assign
id|len
suffix:semicolon
macro_line|#if 1
macro_line|#warning is full_name_hash OK for normal filenames? And for MSDOSFS accessed EMD files?
id|qname.hash
op_assign
id|full_name_hash
(paren
id|name
comma
id|len
)paren
suffix:semicolon
macro_line|#else
id|qname.hash
op_assign
l_int|0
suffix:semicolon
macro_line|#endif&t;
id|ret
op_assign
id|d_alloc
(paren
id|parent
comma
op_amp
id|qname
)paren
suffix:semicolon
multiline_comment|/* create new dentry */
id|ret-&gt;d_inode
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|parent
)paren
(brace
macro_line|#if 0
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;creat_dentry: cloning parent d_op !&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ret-&gt;d_op
op_assign
id|parent-&gt;d_op
suffix:semicolon
macro_line|#else
id|ret-&gt;d_op
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif&t;&t;
)brace
r_else
(brace
id|ret-&gt;d_parent
op_assign
id|ret
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_WARNING
l_string|&quot;creat_dentry: WARNING: NO parent! faking root! beware !&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret-&gt;d_sb
)paren
id|ret-&gt;d_sb
op_assign
id|inode-&gt;i_sb
suffix:semicolon
multiline_comment|/* try to fill it in if available. If available in parent-&gt;d_sb, d_alloc will add it automatically */
id|d_add
(paren
id|ret
comma
id|inode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ret-&gt;d_sb
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;creat_dentry: ERROR: NO d_sb !&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ret-&gt;d_sb-&gt;s_dev
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;creat_dentry: WARNING: NO s_dev. Ugh. !&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * removes temporary dentry created by creat_dentry&n; * it must have d_count of 1, and associated inode i_count of 1&n; * to be completely cleared.&n; *&n; */
DECL|function|kill_dentry
r_void
id|kill_dentry
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_if
c_cond
(paren
id|dentry
)paren
(brace
id|check_dentry_path
(paren
id|dentry
comma
l_string|&quot;KILL_DENTRY B4&quot;
)paren
suffix:semicolon
multiline_comment|/* this idea for killing dentry (d_drop/dput pair) from NFS code. dcache.c code&amp;comments seems to agree */
macro_line|#if 0
id|d_drop
(paren
id|dentry
)paren
suffix:semicolon
id|dput
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/* we are done with it */
macro_line|#endif&t;&t;
id|check_dentry_path
(paren
id|dentry
comma
l_string|&quot;KILL_DENTRY AFT&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
l_string|&quot;kill_dentry: dentry is NULL ?!&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;kill_dentry: exiting...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * finishes work with dentry&n; * it must have d_count of 1, and associated inode i_count of 1&n; * to be completely cleared.&n; *&n; * Currently, this is same as kill_dentry, but this may (will) change.&n; * kill_dentry will eventualy be killed (he who lives by the sword, dies&n; * by the sword :-) when all faked dentries are nuked out...&n; *&n; */
DECL|function|fin_dentry
r_void
id|fin_dentry
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_if
c_cond
(paren
id|dentry
)paren
(brace
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_WARNING
l_string|&quot;fin_dentry: dentry is IS_ERR (%ld)?!&bslash;n&quot;
comma
id|PTR_ERR
(paren
id|dentry
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* this idea for killing dentry (d_drop/dput pair) from NFS code. dcache.c code&amp;comments seems to agree */
id|d_drop
(paren
id|dentry
)paren
suffix:semicolon
id|dput
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/* we are done with it */
)brace
)brace
r_else
(brace
id|Printk
(paren
(paren
id|KERN_WARNING
l_string|&quot;fin_dentry: dentry is NULL ?!&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;fin_dentry: exiting...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|UMSDOS_put_inode
r_void
id|UMSDOS_put_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;put inode %p (%lu) owner %lu pos %lu dir %lu count=%d&bslash;n&quot;
comma
id|inode
comma
id|inode-&gt;i_ino
comma
id|inode-&gt;u.umsdos_i.i_emd_owner
comma
id|inode-&gt;u.umsdos_i.pos
comma
id|inode-&gt;u.umsdos_i.i_emd_dir
comma
id|inode-&gt;i_count
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_logical_and
id|pseudo_root
op_logical_and
id|inode
op_eq
id|pseudo_root
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;Umsdos: Oops releasing pseudo_root. Notify jacques@solucorp.qc.ca&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|fat_put_inode
(paren
id|inode
)paren
suffix:semicolon
)brace
DECL|function|UMSDOS_put_super
r_void
id|UMSDOS_put_super
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS_put_super: entering&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|check_dentry_path
(paren
id|sb-&gt;s_root
comma
l_string|&quot;put_super: START&quot;
)paren
suffix:semicolon
id|msdos_put_super
(paren
id|sb
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/*&n; * Call msdos_lookup, but set back the original msdos function table.&n; * Return 0 if OK, or a negative error code if not.&n; */
DECL|function|umsdos_real_lookup
r_int
id|umsdos_real_lookup
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
multiline_comment|/* Will hold inode of the file, if successful */
(brace
r_int
id|ret
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_real_lookup: looking for %.*s /&quot;
comma
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
id|inc_count
(paren
id|dir
)paren
suffix:semicolon
id|ret
op_assign
id|msdos_lookup
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
id|dentry-&gt;d_op
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* FIXME: Not needed? - if it was good once for MSDOS, it will be good any other time also. I hope :) */
id|iput
(paren
id|dir
)paren
suffix:semicolon
multiline_comment|/* pair to inc_count(dir) above */
id|PRINTK
(paren
(paren
l_string|&quot;/ returned %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Complete the setup of an directory inode.&n; * First, it completes the function pointers, then&n; * it locates the EMD file. If the EMD is there, then plug the&n; * umsdos function table. If not, use the msdos one.&n; *&n; * {i,d}_counts are untouched by this function.&n; */
DECL|function|umsdos_setup_dir_inode
r_void
id|umsdos_setup_dir_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|inode-&gt;u.umsdos_i.i_emd_dir
op_assign
l_int|0
suffix:semicolon
(brace
r_struct
id|inode
op_star
id|emd_dir
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_setup_dir_inode: Entering for inode=%lu&bslash;n&quot;
comma
id|inode-&gt;i_ino
)paren
)paren
suffix:semicolon
id|check_inode
(paren
id|inode
)paren
suffix:semicolon
id|emd_dir
op_assign
id|umsdos_emd_dir_lookup
(paren
id|inode
comma
l_int|0
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_setup_dir_inode: umsdos_emd_dir_lookup for inode=%lu returned %p&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|emd_dir
)paren
)paren
suffix:semicolon
id|check_inode
(paren
id|inode
)paren
suffix:semicolon
id|check_inode
(paren
id|emd_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|emd_dir
op_eq
l_int|NULL
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_setup_dir_inode /mn/: Setting up rdir_inode_ops --&gt; eg. NOT using EMD.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_rdir_inode_operations
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_setup_dir_inode /mn/: Setting up dir_inode_ops --&gt; eg. using EMD.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_dir_inode_operations
suffix:semicolon
id|iput
(paren
id|emd_dir
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Add some info into an inode so it can find its owner quickly&n; */
DECL|function|umsdos_set_dirinfo
r_void
id|umsdos_set_dirinfo
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|inode
op_star
id|dir
comma
id|off_t
id|f_pos
)paren
(brace
r_struct
id|inode
op_star
id|emd_owner
suffix:semicolon
multiline_comment|/* FIXME, I don&squot;t have a clue on this one - /mn/ Hmmm?  OK? */
multiline_comment|/*    Printk ((KERN_WARNING &quot;umsdos_set_dirinfo: /mn/ FIXME: no clue. inode=%lu dir=%lu&bslash;n&quot;, inode-&gt;i_ino, dir-&gt;i_ino)); */
id|emd_owner
op_assign
id|umsdos_emd_dir_lookup
(paren
id|dir
comma
l_int|1
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_set_dirinfo: emd_owner is %lu for dir %lu&bslash;n&quot;
comma
id|emd_owner-&gt;i_ino
comma
id|dir-&gt;i_ino
)paren
)paren
suffix:semicolon
id|inode-&gt;u.umsdos_i.i_dir_owner
op_assign
id|dir-&gt;i_ino
suffix:semicolon
id|inode-&gt;u.umsdos_i.i_emd_owner
op_assign
id|emd_owner-&gt;i_ino
suffix:semicolon
multiline_comment|/* iput (emd_owner); / * FIXME? */
id|inode-&gt;u.umsdos_i.pos
op_assign
id|f_pos
suffix:semicolon
)brace
multiline_comment|/*&n; * Tells if an Umsdos inode has been &quot;patched&quot; once.&n; * Return != 0 if so.&n; */
DECL|function|umsdos_isinit
r_int
id|umsdos_isinit
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
macro_line|#if&t;1
r_return
id|inode-&gt;u.umsdos_i.i_emd_owner
op_ne
l_int|0
suffix:semicolon
macro_line|#elif 0
r_return
id|inode-&gt;i_atime
op_ne
l_int|0
suffix:semicolon
macro_line|#else
r_return
id|atomic_read
(paren
op_amp
id|inode-&gt;i_count
)paren
OG
l_int|1
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Connect the proper tables in the inode and add some info.&n; * i_counts is not changed.&n; */
DECL|function|umsdos_patch_inode
r_void
id|umsdos_patch_inode
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|inode
op_star
id|dir
comma
multiline_comment|/* May be NULL */
id|off_t
id|f_pos
)paren
(brace
multiline_comment|/*&n;&t; * This function is called very early to setup the inode, somewhat&n;&t; * too early (called by UMSDOS_read_inode). At this point, we can&squot;t&n;&t; * do too much, such as lookup up EMD files and so on. This causes&n;&t; * confusion in the kernel. This is why some initialisation&n;&t; * will be done when dir != NULL only.&n;&t; * &n;&t; * UMSDOS do run piggy back on top of msdos fs. It looks like something&n;&t; * is missing in the VFS to accommodate stacked fs. Still unclear what&n;&t; * (quite honestly).&n;&t; * &n;&t; * Well, maybe one! A new entry &quot;may_unmount&quot; which would allow&n;&t; * the stacked fs to allocate some inode permanently and release&n;&t; * them at the end. Doing that now introduce a problem. unmount&n;&t; * always fail because some inodes are in use.&n;&t; */
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;Entering umsdos_patch_inode for inode=%lu&bslash;n&quot;
comma
id|inode-&gt;i_ino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|umsdos_isinit
(paren
id|inode
)paren
)paren
(brace
id|inode-&gt;u.umsdos_i.i_emd_dir
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|MSDOS_SB
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|cvf_format
)paren
(brace
r_if
c_cond
(paren
id|MSDOS_SB
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|cvf_format-&gt;flags
op_amp
id|CVF_USE_READPAGE
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: setting i_op = umsdos_file_inode_operations_readpage&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_file_inode_operations_readpage
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: setting i_op = umsdos_file_inode_operations_no_bmap&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_file_inode_operations_no_bmap
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|inode-&gt;i_op-&gt;bmap
op_ne
l_int|NULL
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: setting i_op = umsdos_file_inode_operations&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_file_inode_operations
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: setting i_op = umsdos_file_inode_operations_no_bmap&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_file_inode_operations_no_bmap
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|dir
op_ne
l_int|NULL
)paren
(brace
id|umsdos_setup_dir_inode
(paren
id|inode
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/:  setting i_op = umsdos_symlink_inode_operations&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_symlink_inode_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISCHR
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/:  setting i_op = chrdev_inode_operations&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|chrdev_inode_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISBLK
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/:  setting i_op = blkdev_inode_operations&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|blkdev_inode_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISFIFO
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: uhm, init_fifo&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|init_fifo
(paren
id|inode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dir
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* #Specification: inode / umsdos info&n;&t;&t;&t; * The first time an inode is seen (inode-&gt;i_count == 1),&n;&t;&t;&t; * the inode number of the EMD file which control this inode&n;&t;&t;&t; * is tagged to this inode. It allows operation such&n;&t;&t;&t; * as notify_change to be handled.&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * This is done last because it also control the&n;&t;&t;&t; * status of umsdos_isinit()&n;&t;&t;&t; */
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: here we go: calling umsdos_set_dirinfo (%p,%p,%lu)&bslash;n&quot;
comma
id|inode
comma
id|dir
comma
id|f_pos
)paren
)paren
suffix:semicolon
id|umsdos_set_dirinfo
(paren
id|inode
comma
id|dir
comma
id|f_pos
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|dir
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * Test to see if the info is maintained.&n;&t;&t; * This should be removed when the file system will be proven.&n;&t;&t; */
multiline_comment|/* FIXME, again, not a clue */
r_struct
id|inode
op_star
id|emd_owner
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_WARNING
l_string|&quot;umsdos_patch_inode: /mn/ Warning: untested emd_owner thingy...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|emd_owner
op_assign
id|umsdos_emd_dir_lookup
(paren
id|dir
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* iput (emd_owner); / * FIXME? */
r_if
c_cond
(paren
id|emd_owner-&gt;i_ino
op_ne
id|inode-&gt;u.umsdos_i.i_emd_owner
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: *** EMD_OWNER ??? *** ino = %ld %ld &lt;&gt; %ld &quot;
comma
id|inode-&gt;i_ino
comma
id|emd_owner-&gt;i_ino
comma
id|inode-&gt;u.umsdos_i.i_emd_owner
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Get the inode of the directory which owns this inode.&n; * Return 0 if OK, -EIO if error.&n; */
DECL|function|umsdos_get_dirowner
r_int
id|umsdos_get_dirowner
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|inode
op_star
op_star
id|result
)paren
multiline_comment|/* Hold NULL if any error */
(brace
multiline_comment|/* else, the inode of the directory */
r_int
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_int
r_int
id|ino
op_assign
id|inode-&gt;u.umsdos_i.i_dir_owner
suffix:semicolon
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ino
op_eq
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: umsdos_get_dirowner ino == 0&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|inode
op_star
id|dir
op_assign
op_star
id|result
op_assign
id|iget
(paren
id|inode-&gt;i_sb
comma
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_ne
l_int|NULL
)paren
(brace
id|umsdos_patch_inode
(paren
id|dir
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* iput (dir);&t;/ * FIXME: /mn/ added this. Is it OK? */
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Load an inode from disk.&n; */
DECL|function|UMSDOS_read_inode
r_void
id|UMSDOS_read_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS_read_inode %p ino = %lu &quot;
comma
id|inode
comma
id|inode-&gt;i_ino
)paren
)paren
suffix:semicolon
id|msdos_read_inode
(paren
id|inode
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;ino after msdos_read_inode= %lu i_count=%d&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|inode-&gt;i_count
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
(paren
id|inode-&gt;u.umsdos_i.u.dir_info.creating
op_ne
l_int|0
op_logical_or
id|inode-&gt;u.umsdos_i.u.dir_info.looking
op_ne
l_int|0
op_logical_or
id|waitqueue_active
(paren
op_amp
id|inode-&gt;u.umsdos_i.u.dir_info.p
)paren
)paren
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;read inode %d %d %p&bslash;n&quot;
comma
id|inode-&gt;u.umsdos_i.u.dir_info.creating
comma
id|inode-&gt;u.umsdos_i.u.dir_info.looking
comma
id|inode-&gt;u.umsdos_i.u.dir_info.p
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* #Specification: Inode / post initialisation&n;&t; * To completely initialise an inode, we need access to the owner&n;&t; * directory, so we can locate more info in the EMD file. This is&n;&t; * not available the first time the inode is access, we use&n;&t; * a value in the inode to tell if it has been finally initialised.&n;&t; * &n;&t; * At first, we have tried testing i_count but it was causing&n;&t; * problem. It is possible that two or more process use the&n;&t; * newly accessed inode. While the first one block during&n;&t; * the initialisation (probably while reading the EMD file), the&n;&t; * others believe all is well because i_count &gt; 1. They go banana&n;&t; * with a broken inode. See umsdos_lookup_patch and umsdos_patch_inode.&n;&t; */
id|umsdos_patch_inode
(paren
id|inode
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|internal_notify_change
r_int
id|internal_notify_change
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|iattr
op_star
id|attr
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|inode
op_star
id|root
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS_notify_change: entering&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|inode_change_ok
(paren
id|inode
comma
id|attr
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_nlink
OG
l_int|0
)paren
(brace
multiline_comment|/* #Specification: notify_change / i_nlink &gt; 0&n;&t;&t; * notify change is only done for inode with nlink &gt; 0. An inode&n;&t;&t; * with nlink == 0 is no longer associated with any entry in&n;&t;&t; * the EMD file, so there is nothing to update.&n;&t;&t; */
r_int
r_int
id|i_emd_owner
op_assign
id|inode-&gt;u.umsdos_i.i_emd_owner
suffix:semicolon
id|root
op_assign
id|iget
(paren
id|inode-&gt;i_sb
comma
id|UMSDOS_ROOT_INO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_eq
id|root
)paren
(brace
multiline_comment|/* #Specification: root inode / attributes&n;&t;&t;&t; * I don&squot;t know yet how this should work. Normally&n;&t;&t;&t; * the attributes (permissions bits, owner, times) of&n;&t;&t;&t; * a directory are stored in the EMD file of its parent.&n;&t;&t;&t; * &n;&t;&t;&t; * One thing we could do is store the attributes of the root&n;&t;&t;&t; * inode in its own EMD file. A simple entry named &quot;.&quot; could&n;&t;&t;&t; * be used for this special case. It would be read once&n;&t;&t;&t; * when the file system is mounted and update in&n;&t;&t;&t; * UMSDOS_notify_change() (right here).&n;&t;&t;&t; * &n;&t;&t;&t; * I am not sure of the behavior of the root inode for&n;&t;&t;&t; * a real Unix file system. For now, this is a nop.&n;&t;&t;&t; */
)brace
r_else
r_if
c_cond
(paren
id|i_emd_owner
op_ne
l_int|0xffffffff
op_logical_and
id|i_emd_owner
op_ne
l_int|0
)paren
(brace
multiline_comment|/* This inode is not a EMD file nor an inode used internally&n;&t;&t;&t; * by MSDOS, so we can update its status.&n;&t;&t;&t; * See emd.c&n;&t;&t;&t; */
r_struct
id|inode
op_star
id|emd_owner
suffix:semicolon
id|emd_owner
op_assign
id|iget
(paren
id|inode-&gt;i_sb
comma
id|i_emd_owner
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;notify change %p &quot;
comma
id|inode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|emd_owner
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: emd_owner = NULL ???&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_else
(brace
r_struct
id|file
id|filp
suffix:semicolon
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
r_struct
id|dentry
op_star
id|emd_dentry
suffix:semicolon
id|emd_dentry
op_assign
id|geti_dentry
(paren
id|emd_owner
)paren
suffix:semicolon
multiline_comment|/* FIXME? */
id|fill_new_filp
(paren
op_amp
id|filp
comma
id|emd_dentry
)paren
suffix:semicolon
id|filp.f_pos
op_assign
id|inode-&gt;u.umsdos_i.pos
suffix:semicolon
id|filp.f_reada
op_assign
l_int|0
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;pos = %Lu &quot;
comma
id|filp.f_pos
)paren
)paren
suffix:semicolon
multiline_comment|/* Read only the start of the entry since we don&squot;t touch */
multiline_comment|/* the name */
id|ret
op_assign
id|umsdos_emd_dir_read
(paren
op_amp
id|filp
comma
(paren
r_char
op_star
)paren
op_amp
id|entry
comma
id|UMSDOS_REC_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_UID
)paren
id|entry.uid
op_assign
id|attr-&gt;ia_uid
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_GID
)paren
id|entry.gid
op_assign
id|attr-&gt;ia_gid
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_MODE
)paren
id|entry.mode
op_assign
id|attr-&gt;ia_mode
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_ATIME
)paren
id|entry.atime
op_assign
id|attr-&gt;ia_atime
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_MTIME
)paren
id|entry.mtime
op_assign
id|attr-&gt;ia_mtime
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_CTIME
)paren
id|entry.ctime
op_assign
id|attr-&gt;ia_ctime
suffix:semicolon
id|entry.nlink
op_assign
id|inode-&gt;i_nlink
suffix:semicolon
id|filp.f_pos
op_assign
id|inode-&gt;u.umsdos_i.pos
suffix:semicolon
id|ret
op_assign
id|umsdos_emd_dir_write
(paren
op_amp
id|filp
comma
(paren
r_char
op_star
)paren
op_amp
id|entry
comma
id|UMSDOS_REC_SIZE
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;notify pos %lu ret %d nlink %d &quot;
comma
id|inode-&gt;u.umsdos_i.pos
comma
id|ret
comma
id|entry.nlink
)paren
)paren
suffix:semicolon
multiline_comment|/* #Specification: notify_change / msdos fs&n;&t;&t;&t;&t;&t; * notify_change operation are done only on the&n;&t;&t;&t;&t;&t; * EMD file. The msdos fs is not even called.&n;&t;&t;&t;&t;&t; */
)brace
multiline_comment|/* iput (emd_owner);&t;/ * FIXME? /mn/ */
)brace
id|Printk
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* iput (root);&t;/ * FIXME - /mn/ This is should be OK. */
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|inode_setattr
(paren
id|inode
comma
id|attr
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|UMSDOS_notify_change
r_int
id|UMSDOS_notify_change
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|iattr
op_star
id|attr
)paren
(brace
r_return
id|internal_notify_change
(paren
id|dentry-&gt;d_inode
comma
id|attr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update the disk with the inode content&n; */
DECL|function|UMSDOS_write_inode
r_void
id|UMSDOS_write_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|iattr
id|newattrs
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;UMSDOS_write_inode emd %d (FIXME: missing notify_change)&bslash;n&quot;
comma
id|inode-&gt;u.umsdos_i.i_emd_owner
)paren
)paren
suffix:semicolon
id|fat_write_inode
(paren
id|inode
)paren
suffix:semicolon
id|newattrs.ia_mtime
op_assign
id|inode-&gt;i_mtime
suffix:semicolon
id|newattrs.ia_atime
op_assign
id|inode-&gt;i_atime
suffix:semicolon
id|newattrs.ia_ctime
op_assign
id|inode-&gt;i_ctime
suffix:semicolon
id|newattrs.ia_valid
op_assign
id|ATTR_MTIME
op_or
id|ATTR_ATIME
op_or
id|ATTR_CTIME
suffix:semicolon
multiline_comment|/*&n;&t; * UMSDOS_notify_change is convenient to call here&n;&t; * to update the EMD entry associated with this inode.&n;&t; * But it has the side effect to re&quot;dirt&quot; the inode.&n;&t; */
multiline_comment|/*      &n; * internal_notify_change (inode, &amp;newattrs);&n; * inode-&gt;i_state &amp;= ~I_DIRTY; / * FIXME: this doesn&squot;t work.  We need to remove ourselves from list on dirty inodes. /mn/ */
)brace
multiline_comment|/* #Specification: function name / convention&n; * A simple convention for function names has been used in&n; * the UMSDOS filesystem. First, all functions use the prefix&n; * umsdos_ to avoid name clashes with other parts of the kernel.&n; * &n; * Standard VFS entry points use the prefix UMSDOS (upper case)&n; * so it&squot;s easier to tell them apart.&n; * N.B. (FIXME) PTW, the order and contents of this struct changed.&n; */
DECL|variable|umsdos_sops
r_static
r_struct
id|super_operations
id|umsdos_sops
op_assign
(brace
id|UMSDOS_read_inode
comma
multiline_comment|/* read_inode */
id|UMSDOS_write_inode
comma
multiline_comment|/* write_inode */
id|UMSDOS_put_inode
comma
multiline_comment|/* put_inode */
id|fat_delete_inode
comma
multiline_comment|/* delete_inode */
id|UMSDOS_notify_change
comma
multiline_comment|/* notify_change */
id|UMSDOS_put_super
comma
multiline_comment|/* put_super */
l_int|NULL
comma
multiline_comment|/* write_super */
id|fat_statfs
comma
multiline_comment|/* statfs */
l_int|NULL
multiline_comment|/* remount_fs */
)brace
suffix:semicolon
multiline_comment|/*&n; * Read the super block of an Extended MS-DOS FS.&n; */
DECL|function|UMSDOS_read_super
r_struct
id|super_block
op_star
id|UMSDOS_read_super
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_void
op_star
id|data
comma
r_int
id|silent
)paren
(brace
multiline_comment|/* #Specification: mount / options&n;&t; * Umsdos run on top of msdos. Currently, it supports no&n;&t; * mount option, but happily pass all option received to&n;&t; * the msdos driver. I am not sure if all msdos mount option&n;&t; * make sense with Umsdos. Here are at least those who&n;&t; * are useful.&n;&t; * uid=&n;&t; * gid=&n;&t; * &n;&t; * These options affect the operation of umsdos in directories&n;&t; * which do not have an EMD file. They behave like normal&n;&t; * msdos directory, with all limitation of msdos.&n;&t; */
r_struct
id|super_block
op_star
id|res
suffix:semicolon
r_struct
id|inode
op_star
id|pseudo
op_assign
l_int|NULL
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS /mn/: starting UMSDOS_read_super&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS /mn/: sb = %p&bslash;n&quot;
comma
id|sb
)paren
)paren
suffix:semicolon
id|MSDOS_SB
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|options.isvfat
op_assign
l_int|0
suffix:semicolon
id|res
op_assign
id|msdos_read_super
(paren
id|sb
comma
id|data
comma
id|silent
)paren
suffix:semicolon
id|sb-&gt;s_op
op_assign
op_amp
id|umsdos_sops
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS /mn/: res = %p&bslash;n&quot;
comma
id|res
)paren
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;UMSDOS dentry-WIP-Beta 0.82-7 (compatibility level %d.%d, fast msdos)&bslash;n&quot;
comma
id|UMSDOS_VERSION
comma
id|UMSDOS_RELEASE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
l_int|NULL
)paren
(brace
id|sb-&gt;s_dev
op_assign
l_int|0
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS: msdos_read_super failed ! mount aborted.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|MSDOS_SB
(paren
id|res
)paren
op_member_access_from_pointer
id|options.dotsOK
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* disable hidden==dotfile */
macro_line|#if 1
id|res-&gt;s_root-&gt;d_op
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* FIXME:?? clear d_op on root so it will not be inherited */
macro_line|#endif&t;
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos /mn/: here goes the iget ROOT_INO&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&t;pseudo = iget (res, UMSDOS_ROOT_INO);&t;// we probably could do it as below (and remove iput() below), but we want use_count to go up. Do we ? :) */
id|pseudo
op_assign
id|res-&gt;s_root-&gt;d_inode
suffix:semicolon
multiline_comment|/* msdos_read_super already did iget() it */
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_read_super pseudo=%p&bslash;n&quot;
comma
id|pseudo
)paren
)paren
suffix:semicolon
id|umsdos_setup_dir_inode
(paren
id|pseudo
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_setup_dir_inode passed. pseudo i_count=%d&bslash;n&quot;
comma
id|pseudo-&gt;i_count
)paren
)paren
suffix:semicolon
multiline_comment|/* if (s == super_blocks){ FIXME, super_blocks no longer exported */
r_if
c_cond
(paren
id|pseudo
)paren
(brace
macro_line|#if 0&t;/* FIXME URGENT: disable pseudo root-for the moment of testing. re-enable this before release ! */
multiline_comment|/* #Specification: pseudo root / mount&n;&t;&t; * When a umsdos fs is mounted, a special handling is done&n;&t;&t; * if it is the root partition. We check for the presence&n;&t;&t; * of the file /linux/etc/init or /linux/etc/rc or&n;&t;&t; * /linux/sbin/init. If one is there, we do a chroot(&quot;/linux&quot;).&n;&t;&t; * &n;&t;&t; * We check both because (see init/main.c) the kernel&n;&t;&t; * try to exec init at different place and if it fails&n;&t;&t; * it tries /bin/sh /etc/rc. To be consistent with&n;&t;&t; * init/main.c, many more test would have to be done&n;&t;&t; * to locate init. Any complain ?&n;&t;&t; * &n;&t;&t; * The chroot is done manually in init/main.c but the&n;&t;&t; * info (the inode) is located at mount time and store&n;&t;&t; * in a global variable (pseudo_root) which is used at&n;&t;&t; * different place in the umsdos driver. There is no&n;&t;&t; * need to store this variable elsewhere because it&n;&t;&t; * will always be one, not one per mount.&n;&t;&t; * &n;&t;&t; * This feature allows the installation&n;&t;&t; * of a linux system within a DOS system in a subdirectory.&n;&t;&t; * &n;&t;&t; * A user may install its linux stuff in c:&bslash;linux&n;&t;&t; * avoiding any clash with existing DOS file and subdirectory.&n;&t;&t; * When linux boots, it hides this fact, showing a normal&n;&t;&t; * root directory with /etc /bin /tmp ...&n;&t;&t; * &n;&t;&t; * The word &quot;linux&quot; is hardcoded in /usr/include/linux/umsdos_fs.h&n;&t;&t; * in the macro UMSDOS_PSDROOT_NAME.&n;&t;&t; */
r_struct
id|dentry
op_star
id|root
comma
op_star
id|etc
comma
op_star
id|etc_rc
comma
op_star
id|sbin
comma
op_star
id|init
op_assign
l_int|NULL
suffix:semicolon
id|root
op_assign
id|creat_dentry
(paren
id|UMSDOS_PSDROOT_NAME
comma
id|strlen
(paren
id|UMSDOS_PSDROOT_NAME
)paren
comma
l_int|NULL
comma
id|res-&gt;s_root
)paren
suffix:semicolon
id|sbin
op_assign
id|creat_dentry
(paren
l_string|&quot;sbin&quot;
comma
l_int|4
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* FIXME: should last NULL be root or res-&gt;s_root ?  Not NULL in any case.. */
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;Mounting root&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_real_lookup
(paren
id|pseudo
comma
id|root
)paren
op_eq
l_int|0
op_logical_and
(paren
id|root-&gt;d_inode
op_ne
l_int|NULL
)paren
op_logical_and
id|S_ISDIR
(paren
id|root-&gt;d_inode-&gt;i_mode
)paren
)paren
(brace
r_int
id|pseudo_ok
op_assign
l_int|0
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;/%s is there&bslash;n&quot;
comma
id|UMSDOS_PSDROOT_NAME
)paren
)paren
suffix:semicolon
id|etc
op_assign
id|creat_dentry
(paren
l_string|&quot;etc&quot;
comma
l_int|3
comma
l_int|NULL
comma
id|root
)paren
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_real_lookup
(paren
id|pseudo
comma
id|etc
)paren
op_eq
l_int|0
op_logical_and
id|S_ISDIR
(paren
id|etc-&gt;d_inode-&gt;i_mode
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;/%s/etc is there&bslash;n&quot;
comma
id|UMSDOS_PSDROOT_NAME
)paren
)paren
suffix:semicolon
id|init
op_assign
id|creat_dentry
(paren
l_string|&quot;init&quot;
comma
l_int|4
comma
l_int|NULL
comma
id|etc
)paren
suffix:semicolon
id|etc_rc
op_assign
id|creat_dentry
(paren
l_string|&quot;rc&quot;
comma
l_int|2
comma
l_int|NULL
comma
id|etc
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|umsdos_real_lookup
(paren
id|pseudo
comma
id|init
)paren
op_eq
l_int|0
op_logical_and
id|S_ISREG
(paren
id|init-&gt;d_inode-&gt;i_mode
)paren
)paren
op_logical_or
(paren
id|umsdos_real_lookup
(paren
id|pseudo
comma
id|etc_rc
)paren
op_eq
l_int|0
op_logical_and
id|S_ISREG
(paren
id|etc_rc-&gt;d_inode-&gt;i_mode
)paren
)paren
)paren
(brace
id|pseudo_ok
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* iput (pseudo); iput (pseudo);&t;/ * because msdos_real_lookup does inc_count (pseudo) */
multiline_comment|/* FIXME !!!!!! */
multiline_comment|/* iput(init); */
multiline_comment|/* iput(rc); */
)brace
r_if
c_cond
(paren
op_logical_neg
id|pseudo_ok
multiline_comment|/* &amp;&amp; umsdos_real_lookup (pseudo, &quot;sbin&quot;, 4, sbin)==0 */
op_logical_and
id|umsdos_real_lookup
(paren
id|pseudo
comma
id|sbin
)paren
op_eq
l_int|0
op_logical_and
id|S_ISDIR
(paren
id|sbin-&gt;d_inode-&gt;i_mode
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;/%s/sbin is there&bslash;n&quot;
comma
id|UMSDOS_PSDROOT_NAME
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_real_lookup
(paren
id|pseudo
comma
id|init
)paren
op_eq
l_int|0
op_logical_and
id|S_ISREG
(paren
id|init-&gt;d_inode-&gt;i_mode
)paren
)paren
(brace
id|pseudo_ok
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*iput (pseudo);*/
multiline_comment|/* FIXME !!! &n;&t;&t;&t;&t; * iput (init); */
)brace
r_if
c_cond
(paren
id|pseudo_ok
)paren
(brace
id|umsdos_setup_dir_inode
(paren
id|pseudo
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_INFO
l_string|&quot;Activating pseudo root /%s&bslash;n&quot;
comma
id|UMSDOS_PSDROOT_NAME
)paren
)paren
suffix:semicolon
id|pseudo_root
op_assign
id|pseudo
suffix:semicolon
id|inc_count
(paren
id|pseudo
)paren
suffix:semicolon
id|pseudo
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* FIXME &n;&t;&t;&t; * &n;&t;&t;&t; * iput (sbin);&n;&t;&t;&t; * iput (etc);&n;&t;&t;&t; */
)brace
macro_line|#endif&t;
multiline_comment|/*iput (pseudo); // iget was removed... so this no longer needed ? */
)brace
macro_line|#if 1
macro_line|#warning UMSDOS: using ugly mount kludge only if necessary (DEBUG)
r_if
c_cond
(paren
id|res-&gt;s_root-&gt;d_count
op_ne
l_int|1
)paren
(brace
multiline_comment|/* if it is not 1, mount will fail with -EBUSY! */
id|printk
(paren
id|KERN_ERR
l_string|&quot;UMSDOS: mount kludge activated: root d_count was %d !&bslash;n&quot;
comma
id|res-&gt;s_root-&gt;d_count
)paren
suffix:semicolon
id|res-&gt;s_root-&gt;d_count
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif&t;
id|check_dentry_path
(paren
id|res-&gt;s_root
comma
l_string|&quot;ROOT dentry check&quot;
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_read_super /mn/: (pseudo=%lu, i_count=%d) returning %p&bslash;n&quot;
comma
id|pseudo-&gt;i_ino
comma
id|pseudo-&gt;i_count
comma
id|res
)paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|variable|umsdos_fs_type
r_static
r_struct
id|file_system_type
id|umsdos_fs_type
op_assign
(brace
l_string|&quot;umsdos&quot;
comma
id|FS_REQUIRES_DEV
comma
id|UMSDOS_read_super
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
(paren
r_int
id|init_umsdos_fs
(paren
r_void
)paren
)paren
(brace
r_return
id|register_filesystem
(paren
op_amp
id|umsdos_fs_type
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|EXPORT_NO_SYMBOLS
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
(paren
r_void
)paren
(brace
r_return
id|init_umsdos_fs
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
(paren
r_void
)paren
(brace
id|unregister_filesystem
(paren
op_amp
id|umsdos_fs_type
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
