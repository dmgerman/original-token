multiline_comment|/*&n; *  linux/fs/umsdos/inode.c&n; *&n; *      Written 1993 by Jacques Gelinas&n; *      Inspired from linux/fs/msdos/... by Werner Almesberger&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/msdos_fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/umsdos_fs.h&gt;
macro_line|#include &lt;linux/list.h&gt;
r_extern
r_struct
id|inode_operations
id|umsdos_rdir_inode_operations
suffix:semicolon
DECL|variable|pseudo_root
r_struct
id|inode
op_star
id|pseudo_root
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Useful to simulate the pseudo DOS */
multiline_comment|/* directory. See UMSDOS_readdir_x() */
multiline_comment|/* #Specification: convention / PRINTK Printk and printk&n; * Here is the convention for the use of printk inside fs/umsdos&n; * &n; * printk carry important message (error or status).&n; * Printk is for debugging (it is a macro defined at the beginning of&n; * most source.&n; * PRINTK is a nulled Printk macro.&n; * &n; * This convention makes the source easier to read, and Printk easier&n; * to shut off.&n; */
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x)
DECL|macro|Printk
mdefine_line|#define Printk(x) printk x
multiline_comment|/*&n; * makes return inode-&gt;i_dentry&n; *&n; */
DECL|function|geti_dentry
r_inline
r_struct
id|dentry
op_star
id|geti_dentry
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|dentry
op_star
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;geti_dentry: inode is NULL!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|ret
op_assign
id|list_entry
(paren
id|inode-&gt;i_dentry.next
comma
r_struct
id|dentry
comma
id|d_alias
)paren
suffix:semicolon
multiline_comment|/* FIXME: does this really work ? :) */
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;geti_dentry : inode %lu: i_dentry is %p&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * makes inode-&gt;i_count++&n; *&n; */
DECL|function|inc_count
r_inline
r_void
id|inc_count
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|inode-&gt;i_count
op_increment
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;inc_count: inode %lu incremented count to %d&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|inode-&gt;i_count
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * makes empty filp&n; *&n; */
DECL|function|fill_new_filp
r_void
id|fill_new_filp
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;/mn/ fill_new_filp: filling empty filp at %p&bslash;n&quot;
comma
id|filp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
)paren
id|Printk
(paren
(paren
l_string|&quot;     dentry=%.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
r_else
id|Printk
(paren
(paren
l_string|&quot;     dentry is NULL ! you must fill it later...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|memset
(paren
id|filp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|file
)paren
)paren
suffix:semicolon
id|filp-&gt;f_pos
op_assign
l_int|0
suffix:semicolon
id|filp-&gt;f_reada
op_assign
l_int|1
suffix:semicolon
id|filp-&gt;f_flags
op_assign
id|O_RDWR
suffix:semicolon
id|filp-&gt;f_dentry
op_assign
id|dentry
suffix:semicolon
id|filp-&gt;f_op
op_assign
op_amp
id|umsdos_file_operations
suffix:semicolon
multiline_comment|/* /mn/ - we have to fill it with SOMETHING */
)brace
multiline_comment|/*&n; * check a superblock&n; */
DECL|function|check_sb
r_void
id|check_sb
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_const
r_char
id|c
)paren
(brace
r_if
c_cond
(paren
id|sb
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (has %c_sb=%d, %d)&quot;
comma
id|c
comma
id|MAJOR
(paren
id|sb-&gt;s_dev
)paren
comma
id|MINOR
(paren
id|sb-&gt;s_dev
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
l_string|&quot; (%c_sb is NULL)&quot;
comma
id|c
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * check an inode&n; */
DECL|function|check_inode
r_void
id|check_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
id|inode
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*   inode is %lu (i_count=%d)&quot;
comma
id|inode-&gt;i_ino
comma
id|inode-&gt;i_count
)paren
)paren
suffix:semicolon
id|check_sb
(paren
id|inode-&gt;i_sb
comma
l_char|&squot;i&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_dentry.next
)paren
(brace
multiline_comment|/* FIXME: does this work ? */
id|Printk
(paren
(paren
l_string|&quot; (has i_dentry)&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
l_string|&quot; (NO i_dentry)&quot;
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
l_int|NULL
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is NULL)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
op_amp
id|umsdos_dir_inode_operations
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is umsdos_dir_inode_operations)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
op_amp
id|umsdos_file_inode_operations
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is umsdos_file_inode_operations)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
op_amp
id|umsdos_file_inode_operations_no_bmap
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is umsdos_file_inode_operations_no_bmap)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
op_amp
id|umsdos_file_inode_operations_readpage
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is umsdos_file_inode_operations_readpage)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
op_amp
id|umsdos_rdir_inode_operations
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is umsdos_rdir_inode_operations)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
op_amp
id|umsdos_symlink_inode_operations
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is umsdos_symlink_inode_operations)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is UNKNOWN: %p)&bslash;n&quot;
comma
id|inode-&gt;i_op
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*   inode is NULL&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * internal part of check_dentry. does the real job.&n; *&n; */
DECL|function|check_dent_int
r_void
id|check_dent_int
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|parent
)paren
(brace
r_if
c_cond
(paren
id|parent
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*  parent dentry: %.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;n*** checking dentry: %.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
)brace
id|check_inode
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*   d_count=%d&quot;
comma
id|dentry-&gt;d_count
)paren
)paren
suffix:semicolon
id|check_sb
(paren
id|dentry-&gt;d_sb
comma
l_char|&squot;d&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_op
op_eq
l_int|NULL
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (d_op is NULL)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
l_string|&quot; (d_op is UNKNOWN: %p)&bslash;n&quot;
comma
id|dentry-&gt;d_op
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * checks dentry and prints info&n; *&n; */
DECL|function|check_dentry
r_void
id|check_dentry
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;&bslash;n*** checking dentry... it is NULL !&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|check_dent_int
(paren
id|dentry
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_parent
)paren
(brace
id|check_dent_int
(paren
id|dentry-&gt;d_parent
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*   has no parent.&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*** end checking dentry&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * makes dentry. for name name with length len. /mn/&n; * if inode is not NULL, puts it also.&n; *&n; */
DECL|function|creat_dentry
r_struct
id|dentry
op_star
id|creat_dentry
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_int
id|len
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|dentry
op_star
id|parent
)paren
(brace
multiline_comment|/* FIXME /mn/: parent is not passed many times... if it is not, dentry should be destroyed before someone else gets to use it */
r_struct
id|dentry
op_star
id|ret
suffix:semicolon
r_struct
id|qstr
id|qname
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;/mn/ creat_dentry: creating dentry with inode=%lu for %.*s&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|len
comma
id|name
)paren
)paren
suffix:semicolon
r_else
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;/mn/ creat_dentry: creating empty dentry for %.*s&bslash;n&quot;
comma
id|len
comma
id|name
)paren
)paren
suffix:semicolon
id|qname.name
op_assign
id|name
suffix:semicolon
id|qname.len
op_assign
id|len
suffix:semicolon
id|qname.hash
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|d_alloc
(paren
id|parent
comma
op_amp
id|qname
)paren
suffix:semicolon
multiline_comment|/* create new dentry */
id|ret-&gt;d_inode
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent
)paren
(brace
id|ret-&gt;d_parent
op_assign
id|ret
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_WARNING
l_string|&quot;creat_dentry: WARNING: NO parent! faking! beware !&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inode
)paren
(brace
id|ret-&gt;d_sb
op_assign
id|inode-&gt;i_sb
suffix:semicolon
multiline_comment|/* try to fill it in if avalaible. If avalaible in parent-&gt;d_sb, d_alloc will add it automatically */
id|d_add
(paren
id|ret
comma
id|inode
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * removes temporary dentry created by creat_dentry&n; *&n; */
DECL|function|kill_dentry
r_void
id|kill_dentry
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_if
c_cond
(paren
id|dentry
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;/mn/ kill_dentry: kill_dentry %.*s :&quot;
comma
(paren
r_int
)paren
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
id|Printk
(paren
(paren
l_string|&quot;inode=%lu (i_count=%d)&bslash;n&quot;
comma
id|dentry-&gt;d_inode-&gt;i_ino
comma
id|dentry-&gt;d_inode-&gt;i_count
)paren
)paren
suffix:semicolon
r_else
id|Printk
(paren
(paren
l_string|&quot;inode is NULL&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: is this ok ?! /mn/ */
multiline_comment|/* d_drop (dentry); */
multiline_comment|/* d_invalidate (dentry); */
multiline_comment|/*dput (dentry); */
multiline_comment|/*d_delete (dentry) */
)brace
r_else
(brace
id|Printk
(paren
(paren
l_string|&quot;/mn/ kill_dentry: dentry is NULL ?!&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;/mn/ kill_dentry: exiting...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|UMSDOS_put_inode
r_void
id|UMSDOS_put_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;put inode %p (%lu) owner %lu pos %lu dir %lu count=%d&bslash;n&quot;
comma
id|inode
comma
id|inode-&gt;i_ino
comma
id|inode-&gt;u.umsdos_i.i_emd_owner
comma
id|inode-&gt;u.umsdos_i.pos
comma
id|inode-&gt;u.umsdos_i.i_emd_dir
comma
id|inode-&gt;i_count
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_logical_and
id|pseudo_root
op_logical_and
id|inode
op_eq
id|pseudo_root
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;Umsdos: Oops releasing pseudo_root. Notify jacques@solucorp.qc.ca&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|fat_put_inode
(paren
id|inode
)paren
suffix:semicolon
)brace
DECL|function|UMSDOS_put_super
r_void
id|UMSDOS_put_super
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS_put_super: entering&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|msdos_put_super
(paren
id|sb
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/*&n; * Call msdos_lookup, but set back the original msdos function table.&n; * Return 0 if ok, or a negative error code if not.&n; */
DECL|function|umsdos_real_lookup
r_int
id|umsdos_real_lookup
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
multiline_comment|/* Will hold inode of the file, if successful */
r_int
id|ret
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_real_lookup: looking for %s /&quot;
comma
id|dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
id|inc_count
(paren
id|dir
)paren
suffix:semicolon
multiline_comment|/* should be here ? Causes all kind of missing iput()&squot;s all around, but panics w/o it /mn/ */
id|ret
op_assign
id|msdos_lookup
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;/ returned %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Complete the setup of an directory inode.&n; * First, it completes the function pointers, then&n; * it locates the EMD file. If the EMD is there, then plug the&n; * umsdos function table. If not, use the msdos one.&n; */
DECL|function|umsdos_setup_dir_inode
r_void
id|umsdos_setup_dir_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|inode-&gt;u.umsdos_i.i_emd_dir
op_assign
l_int|0
suffix:semicolon
(brace
r_struct
id|inode
op_star
id|emd_dir
suffix:semicolon
id|emd_dir
op_assign
id|umsdos_emd_dir_lookup
(paren
id|inode
comma
l_int|0
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_setup_dir_inode: umsdos_emd_dir_lookup for inode=%p returned %p&bslash;n&quot;
comma
id|inode
comma
id|emd_dir
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|emd_dir
op_eq
l_int|NULL
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_setup_dir_inode /mn/: Setting up rdir_inode_ops --&gt; eg. NOT using EMD.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_rdir_inode_operations
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_setup_dir_inode /mn/: Setting up dir_inode_ops --&gt; eg. using EMD.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_dir_inode_operations
suffix:semicolon
)brace
id|iput
(paren
id|emd_dir
)paren
suffix:semicolon
multiline_comment|/* FIXME? OK? */
)brace
)brace
multiline_comment|/*&n; * Add some info into an inode so it can find its owner quickly&n; */
DECL|function|umsdos_set_dirinfo
r_void
id|umsdos_set_dirinfo
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|inode
op_star
id|dir
comma
id|off_t
id|f_pos
)paren
(brace
r_struct
id|inode
op_star
id|emd_owner
suffix:semicolon
multiline_comment|/* FIXME, I don&squot;t have a clue on this one - /mn/ hmmm ? ok ? */
multiline_comment|/*    Printk ((KERN_WARNING &quot;umsdos_set_dirinfo: /mn/ FIXME: no clue. inode=%lu dir=%lu&bslash;n&quot;, inode-&gt;i_ino, dir-&gt;i_ino)); */
id|emd_owner
op_assign
id|umsdos_emd_dir_lookup
(paren
id|dir
comma
l_int|1
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_set_dirinfo: emd_owner is %lu for dir %lu&bslash;n&quot;
comma
id|emd_owner-&gt;i_ino
comma
id|dir-&gt;i_ino
)paren
)paren
suffix:semicolon
id|inode-&gt;u.umsdos_i.i_dir_owner
op_assign
id|dir-&gt;i_ino
suffix:semicolon
id|inode-&gt;u.umsdos_i.i_emd_owner
op_assign
id|emd_owner-&gt;i_ino
suffix:semicolon
id|iput
(paren
id|emd_owner
)paren
suffix:semicolon
multiline_comment|/* FIXME? */
id|inode-&gt;u.umsdos_i.pos
op_assign
id|f_pos
suffix:semicolon
)brace
multiline_comment|/*&n; * Tells if an Umsdos inode has been &quot;patched&quot; once.&n; * Return != 0 if so.&n; */
DECL|function|umsdos_isinit
r_int
id|umsdos_isinit
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
macro_line|#if&t;1
r_return
id|inode-&gt;u.umsdos_i.i_emd_owner
op_ne
l_int|0
suffix:semicolon
macro_line|#elif 0
r_return
id|inode-&gt;i_atime
op_ne
l_int|0
suffix:semicolon
macro_line|#else
r_return
id|atomic_read
(paren
op_amp
id|inode-&gt;i_count
)paren
OG
l_int|1
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Connect the proper tables in the inode and add some info.&n; */
DECL|function|umsdos_patch_inode
r_void
id|umsdos_patch_inode
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|inode
op_star
id|dir
comma
multiline_comment|/* May be NULL */
id|off_t
id|f_pos
)paren
(brace
multiline_comment|/*&n;&t; * This function is called very early to setup the inode, somewhat&n;&t; * too early (called by UMSDOS_read_inode). At this point, we can&squot;t&n;&t; * do to much, such as lookup up EMD files and so on. This causes&n;&t; * confusion in the kernel. This is why some initialisation&n;&t; * will be done when dir != NULL only.&n;&t; * &n;&t; * UMSDOS do run piggy back on top of msdos fs. It looks like something&n;&t; * is missing in the VFS to accommodate stacked fs. Still unclear what&n;&t; * (quite honestly).&n;&t; * &n;&t; * Well, maybe one! A new entry &quot;may_unmount&quot; which would allow&n;&t; * the stacked fs to allocate some inode permanently and release&n;&t; * them at the end. Doing that now introduce a problem. unmount&n;&t; * always fail because some inodes are in use.&n;&t; */
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;Entering umsdos_patch_inode for inode=%lu&bslash;n&quot;
comma
id|inode-&gt;i_ino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|umsdos_isinit
(paren
id|inode
)paren
)paren
(brace
id|inode-&gt;u.umsdos_i.i_emd_dir
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|MSDOS_SB
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|cvf_format
)paren
(brace
r_if
c_cond
(paren
id|MSDOS_SB
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|cvf_format-&gt;flags
op_amp
id|CVF_USE_READPAGE
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: seting i_op = umsdos_file_inode_operations_readpage&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_file_inode_operations_readpage
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: seting i_op = umsdos_file_inode_operations_no_bmap&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_file_inode_operations_no_bmap
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|inode-&gt;i_op-&gt;bmap
op_ne
l_int|NULL
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: seting i_op = umsdos_file_inode_operations&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_file_inode_operations
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: seting i_op = umsdos_file_inode_operations_no_bmap&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_file_inode_operations_no_bmap
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|dir
op_ne
l_int|NULL
)paren
(brace
id|umsdos_setup_dir_inode
(paren
id|inode
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: seting i_op = umsdos_symlink_inode_operations&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_symlink_inode_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISCHR
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: seting i_op = chrdev_inode_operations&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|chrdev_inode_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISBLK
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: seting i_op = blkdev_inode_operations&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|blkdev_inode_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISFIFO
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: uhm, init_fifo&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|init_fifo
(paren
id|inode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dir
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* #Specification: inode / umsdos info&n;&t;&t;&t; * The first time an inode is seen (inode-&gt;i_count == 1),&n;&t;&t;&t; * the inode number of the EMD file which control this inode&n;&t;&t;&t; * is tagged to this inode. It allows operation such&n;&t;&t;&t; * as notify_change to be handled.&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * This is done last because it also control the&n;&t;&t;&t; * status of umsdos_isinit()&n;&t;&t;&t; */
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: here we go: calling umsdos_set_dirinfo (%p,%p,%lu)&bslash;n&quot;
comma
id|inode
comma
id|dir
comma
id|f_pos
)paren
)paren
suffix:semicolon
id|umsdos_set_dirinfo
(paren
id|inode
comma
id|dir
comma
id|f_pos
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|dir
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; * Test to see if the info is maintained.&n;&t;&t; * This should be removed when the file system will be proven.&n;&t;&t; */
multiline_comment|/* FIXME, again, not a clue */
r_struct
id|inode
op_star
id|emd_owner
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_WARNING
l_string|&quot;umsdos_patch_inode: /mn/ Warning: untested emd_owner thingy...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|emd_owner
op_assign
id|umsdos_emd_dir_lookup
(paren
id|dir
comma
l_int|1
)paren
suffix:semicolon
id|iput
(paren
id|emd_owner
)paren
suffix:semicolon
multiline_comment|/* FIXME? */
r_if
c_cond
(paren
id|emd_owner-&gt;i_ino
op_ne
id|inode-&gt;u.umsdos_i.i_emd_owner
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: *** EMD_OWNER ??? *** ino = %ld %ld &lt;&gt; %ld &quot;
comma
id|inode-&gt;i_ino
comma
id|emd_owner-&gt;i_ino
comma
id|inode-&gt;u.umsdos_i.i_emd_owner
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Get the inode of the directory which owns this inode.&n; * Return 0 if ok, -EIO if error.&n; */
DECL|function|umsdos_get_dirowner
r_int
id|umsdos_get_dirowner
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|inode
op_star
op_star
id|result
)paren
(brace
multiline_comment|/* Hold NULL if any error */
multiline_comment|/* else, the inode of the directory */
r_int
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_int
r_int
id|ino
op_assign
id|inode-&gt;u.umsdos_i.i_dir_owner
suffix:semicolon
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ino
op_eq
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: umsdos_get_dirowner ino == 0&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|inode
op_star
id|dir
op_assign
op_star
id|result
op_assign
id|iget
(paren
id|inode-&gt;i_sb
comma
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_ne
l_int|NULL
)paren
(brace
id|umsdos_patch_inode
(paren
id|dir
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* iput (dir);&t;/ * FIXME: /mn/ added this. Is it ok ? */
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Load an inode from disk.&n; */
DECL|function|UMSDOS_read_inode
r_void
id|UMSDOS_read_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS_read_inode %p ino = %lu &quot;
comma
id|inode
comma
id|inode-&gt;i_ino
)paren
)paren
suffix:semicolon
id|msdos_read_inode
(paren
id|inode
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;ino after msdos_read_inode= %lu i_count=%d&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|inode-&gt;i_count
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
(paren
id|inode-&gt;u.umsdos_i.u.dir_info.creating
op_ne
l_int|0
op_logical_or
id|inode-&gt;u.umsdos_i.u.dir_info.looking
op_ne
l_int|0
op_logical_or
id|waitqueue_active
(paren
op_amp
id|inode-&gt;u.umsdos_i.u.dir_info.p
)paren
)paren
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;read inode %d %d %p&bslash;n&quot;
comma
id|inode-&gt;u.umsdos_i.u.dir_info.creating
comma
id|inode-&gt;u.umsdos_i.u.dir_info.looking
comma
id|inode-&gt;u.umsdos_i.u.dir_info.p
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* #Specification: Inode / post initialisation&n;&t; * To completely initialise an inode, we need access to the owner&n;&t; * directory, so we can locate more info in the EMD file. This is&n;&t; * not available the first time the inode is access, we use&n;&t; * a value in the inode to tell if it has been finally initialised.&n;&t; * &n;&t; * At first, we have tried testing i_count but it was causing&n;&t; * problem. It is possible that two or more process use the&n;&t; * newly accessed inode. While the first one block during&n;&t; * the initialisation (probably while reading the EMD file), the&n;&t; * others believe all is well because i_count &gt; 1. They go banana&n;&t; * with a broken inode. See umsdos_lookup_patch and umsdos_patch_inode.&n;&t; */
id|umsdos_patch_inode
(paren
id|inode
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|internal_notify_change
r_int
id|internal_notify_change
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|iattr
op_star
id|attr
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|inode
op_star
id|root
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS_notify_change: entering&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|inode_change_ok
(paren
id|inode
comma
id|attr
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_nlink
OG
l_int|0
)paren
(brace
multiline_comment|/* #Specification: notify_change / i_nlink &gt; 0&n;&t;&t; * notify change is only done for inode with nlink &gt; 0. An inode&n;&t;&t; * with nlink == 0 is no longer associated with any entry in&n;&t;&t; * the EMD file, so there is nothing to update.&n;&t;&t; */
r_int
r_int
id|i_emd_owner
op_assign
id|inode-&gt;u.umsdos_i.i_emd_owner
suffix:semicolon
id|root
op_assign
id|iget
(paren
id|inode-&gt;i_sb
comma
id|UMSDOS_ROOT_INO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_eq
id|root
)paren
(brace
multiline_comment|/* #Specification: root inode / attributes&n;&t;&t;&t; * I don&squot;t know yet how this should work. Normally&n;&t;&t;&t; * the attributes (permissions bits, owner, times) of&n;&t;&t;&t; * a directory are stored in the EMD file of its parent.&n;&t;&t;&t; * &n;&t;&t;&t; * One thing we could do is store the attributes of the root&n;&t;&t;&t; * inode in its own EMD file. A simple entry named &quot;.&quot; could&n;&t;&t;&t; * be used for this special case. It would be read once&n;&t;&t;&t; * when the file system is mounted and update in&n;&t;&t;&t; * UMSDOS_notify_change() (right here).&n;&t;&t;&t; * &n;&t;&t;&t; * I am not sure of the behavior of the root inode for&n;&t;&t;&t; * a real UNIX file system. For now, this is a nop.&n;&t;&t;&t; */
)brace
r_else
r_if
c_cond
(paren
id|i_emd_owner
op_ne
l_int|0xffffffff
op_logical_and
id|i_emd_owner
op_ne
l_int|0
)paren
(brace
multiline_comment|/* This inode is not a EMD file nor an inode used internally&n;&t;&t;&t; * by MSDOS, so we can update its status.&n;&t;&t;&t; * See emd.c&n;&t;&t;&t; */
r_struct
id|inode
op_star
id|emd_owner
suffix:semicolon
id|emd_owner
op_assign
id|iget
(paren
id|inode-&gt;i_sb
comma
id|i_emd_owner
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;notify change %p &quot;
comma
id|inode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|emd_owner
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: emd_owner = NULL ???&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_else
(brace
r_struct
id|file
id|filp
suffix:semicolon
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
r_struct
id|dentry
op_star
id|emd_dentry
suffix:semicolon
id|loff_t
id|offs
suffix:semicolon
id|emd_dentry
op_assign
id|creat_dentry
(paren
l_string|&quot;notify_emd&quot;
comma
l_int|10
comma
id|emd_owner
comma
l_int|NULL
)paren
suffix:semicolon
id|fill_new_filp
(paren
op_amp
id|filp
comma
id|emd_dentry
)paren
suffix:semicolon
id|filp.f_pos
op_assign
id|inode-&gt;u.umsdos_i.pos
suffix:semicolon
id|filp.f_reada
op_assign
l_int|0
suffix:semicolon
id|offs
op_assign
id|filp.f_pos
suffix:semicolon
multiline_comment|/* FIXME: /mn/ is this ok ? */
id|Printk
(paren
(paren
l_string|&quot;pos = %Lu &quot;
comma
id|filp.f_pos
)paren
)paren
suffix:semicolon
multiline_comment|/* Read only the start of the entry since we don&squot;t touch */
multiline_comment|/* the name */
id|ret
op_assign
id|umsdos_emd_dir_read
(paren
id|emd_owner
comma
op_amp
id|filp
comma
(paren
r_char
op_star
)paren
op_amp
id|entry
comma
id|UMSDOS_REC_SIZE
comma
op_amp
id|offs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_UID
)paren
id|entry.uid
op_assign
id|attr-&gt;ia_uid
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_GID
)paren
id|entry.gid
op_assign
id|attr-&gt;ia_gid
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_MODE
)paren
id|entry.mode
op_assign
id|attr-&gt;ia_mode
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_ATIME
)paren
id|entry.atime
op_assign
id|attr-&gt;ia_atime
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_MTIME
)paren
id|entry.mtime
op_assign
id|attr-&gt;ia_mtime
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_CTIME
)paren
id|entry.ctime
op_assign
id|attr-&gt;ia_ctime
suffix:semicolon
id|entry.nlink
op_assign
id|inode-&gt;i_nlink
suffix:semicolon
id|filp.f_pos
op_assign
id|inode-&gt;u.umsdos_i.pos
suffix:semicolon
id|offs
op_assign
id|filp.f_pos
suffix:semicolon
multiline_comment|/* FIXME: /mn/ is this ok ? */
id|ret
op_assign
id|umsdos_emd_dir_write
(paren
id|emd_owner
comma
op_amp
id|filp
comma
(paren
r_char
op_star
)paren
op_amp
id|entry
comma
id|UMSDOS_REC_SIZE
comma
op_amp
id|offs
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;notify pos %lu ret %d nlink %d &quot;
comma
id|inode-&gt;u.umsdos_i.pos
comma
id|ret
comma
id|entry.nlink
)paren
)paren
suffix:semicolon
multiline_comment|/* #Specification: notify_change / msdos fs&n;&t;&t;&t;&t;&t; * notify_change operation are done only on the&n;&t;&t;&t;&t;&t; * EMD file. The msdos fs is not even called.&n;&t;&t;&t;&t;&t; */
)brace
id|iput
(paren
id|emd_owner
)paren
suffix:semicolon
multiline_comment|/* FIXME? /mn/ */
)brace
id|Printk
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|iput
(paren
id|root
)paren
suffix:semicolon
multiline_comment|/* FIXME - /mn/ this is hopefully ok */
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|inode_setattr
(paren
id|inode
comma
id|attr
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|UMSDOS_notify_change
r_int
id|UMSDOS_notify_change
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|iattr
op_star
id|attr
)paren
(brace
r_return
id|internal_notify_change
(paren
id|dentry-&gt;d_inode
comma
id|attr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Update the disk with the inode content&n; */
DECL|function|UMSDOS_write_inode
r_void
id|UMSDOS_write_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|iattr
id|newattrs
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;UMSDOS_write_inode emd %d (FIXME: missing notify_change)&bslash;n&quot;
comma
id|inode-&gt;u.umsdos_i.i_emd_owner
)paren
)paren
suffix:semicolon
id|fat_write_inode
(paren
id|inode
)paren
suffix:semicolon
id|newattrs.ia_mtime
op_assign
id|inode-&gt;i_mtime
suffix:semicolon
id|newattrs.ia_atime
op_assign
id|inode-&gt;i_atime
suffix:semicolon
id|newattrs.ia_ctime
op_assign
id|inode-&gt;i_ctime
suffix:semicolon
id|newattrs.ia_valid
op_assign
id|ATTR_MTIME
op_or
id|ATTR_ATIME
op_or
id|ATTR_CTIME
suffix:semicolon
multiline_comment|/*&n;&t; * UMSDOS_notify_change is convenient to call here&n;&t; * to update the EMD entry associated with this inode.&n;&t; * But it has the side effect to re&quot;dirt&quot; the inode.&n;&t; */
multiline_comment|/*      &n; * internal_notify_change (inode, &amp;newattrs);&n; * inode-&gt;i_state &amp;= ~I_DIRTY; / * FIXME: this doesn&squot;t work... we need to remove ourselfs from list on dirty inodes /mn/ */
)brace
multiline_comment|/* #Specification: function name / convention&n; * A simple convention for function name has been used in&n; * the UMSDOS file system. First all function use the prefix&n; * umsdos_ to avoid name clash with other part of the kernel.&n; * &n; * And standard VFS entry point use the prefix UMSDOS (upper case)&n; * so it&squot;s easier to tell them apart.&n; * N.B. (FIXME) PTW, the order and contents of this struct changed&n; */
DECL|variable|umsdos_sops
r_static
r_struct
id|super_operations
id|umsdos_sops
op_assign
(brace
id|UMSDOS_read_inode
comma
multiline_comment|/* read_inode */
id|UMSDOS_write_inode
comma
multiline_comment|/* write_inode */
id|UMSDOS_put_inode
comma
multiline_comment|/* put_inode */
id|fat_delete_inode
comma
multiline_comment|/* delete_inode */
id|UMSDOS_notify_change
comma
multiline_comment|/* notify_change */
id|UMSDOS_put_super
comma
multiline_comment|/* put_super */
l_int|NULL
comma
multiline_comment|/* write_super */
id|fat_statfs
comma
multiline_comment|/* statfs */
l_int|NULL
multiline_comment|/* remount_fs */
)brace
suffix:semicolon
multiline_comment|/*&n; * Read the super block of an Extended MS-DOS FS.&n; */
DECL|function|UMSDOS_read_super
r_struct
id|super_block
op_star
id|UMSDOS_read_super
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_void
op_star
id|data
comma
r_int
id|silent
)paren
(brace
multiline_comment|/* #Specification: mount / options&n;&t; * Umsdos run on top of msdos. Currently, it supports no&n;&t; * mount option, but happily pass all option received to&n;&t; * the msdos driver. I am not sure if all msdos mount option&n;&t; * make sense with Umsdos. Here are at least those who&n;&t; * are useful.&n;&t; * uid=&n;&t; * gid=&n;&t; * &n;&t; * These options affect the operation of umsdos in directories&n;&t; * which do not have an EMD file. They behave like normal&n;&t; * msdos directory, with all limitation of msdos.&n;&t; */
r_struct
id|super_block
op_star
id|res
suffix:semicolon
r_struct
id|inode
op_star
id|pseudo
op_assign
l_int|NULL
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS /mn/: starting UMSDOS_read_super&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS /mn/: sb = %p&bslash;n&quot;
comma
id|sb
)paren
)paren
suffix:semicolon
id|res
op_assign
id|msdos_read_super
(paren
id|sb
comma
id|data
comma
id|silent
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS /mn/: res = %p&bslash;n&quot;
comma
id|res
)paren
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;UMSDOS dentry-WIP-Beta 0.82-4 (compatibility level %d.%d, fast msdos)&bslash;n&quot;
comma
id|UMSDOS_VERSION
comma
id|UMSDOS_RELEASE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
l_int|NULL
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|MSDOS_SB
(paren
id|res
)paren
op_member_access_from_pointer
id|options.dotsOK
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* disable hidden==dotfile */
id|res-&gt;s_op
op_assign
op_amp
id|umsdos_sops
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos /mn/: here goes the iget ROOT_INO&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|pseudo
op_assign
id|iget
(paren
id|res
comma
id|UMSDOS_ROOT_INO
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_read_super %p&bslash;n&quot;
comma
id|pseudo
)paren
)paren
suffix:semicolon
id|umsdos_setup_dir_inode
(paren
id|pseudo
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_setup_dir_inode passed. pseudo i_count=%d&bslash;n&quot;
comma
id|pseudo-&gt;i_count
)paren
)paren
suffix:semicolon
multiline_comment|/* if (s == super_blocks){ FIXME, super_blocks no longer exported */
r_if
c_cond
(paren
id|pseudo
)paren
(brace
multiline_comment|/* #Specification: pseudo root / mount&n;&t;&t; * When a umsdos fs is mounted, a special handling is done&n;&t;&t; * if it is the root partition. We check for the presence&n;&t;&t; * of the file /linux/etc/init or /linux/etc/rc or&n;&t;&t; * /linux/sbin/init. If one is there, we do a chroot(&quot;/linux&quot;).&n;&t;&t; * &n;&t;&t; * We check both because (see init/main.c) the kernel&n;&t;&t; * try to exec init at different place and if it fails&n;&t;&t; * it tries /bin/sh /etc/rc. To be consistent with&n;&t;&t; * init/main.c, many more test would have to be done&n;&t;&t; * to locate init. Any complain ?&n;&t;&t; * &n;&t;&t; * The chroot is done manually in init/main.c but the&n;&t;&t; * info (the inode) is located at mount time and store&n;&t;&t; * in a global variable (pseudo_root) which is used at&n;&t;&t; * different place in the umsdos driver. There is no&n;&t;&t; * need to store this variable elsewhere because it&n;&t;&t; * will always be one, not one per mount.&n;&t;&t; * &n;&t;&t; * This feature allows the installation&n;&t;&t; * of a linux system within a DOS system in a subdirectory.&n;&t;&t; * &n;&t;&t; * A user may install its linux stuff in c:&bslash;linux&n;&t;&t; * avoiding any clash with existing DOS file and subdirectory.&n;&t;&t; * When linux boots, it hides this fact, showing a normal&n;&t;&t; * root directory with /etc /bin /tmp ...&n;&t;&t; * &n;&t;&t; * The word &quot;linux&quot; is hardcoded in /usr/include/linux/umsdos_fs.h&n;&t;&t; * in the macro UMSDOS_PSDROOT_NAME.&n;&t;&t; */
r_struct
id|dentry
op_star
id|root
comma
op_star
id|etc
comma
op_star
id|etc_rc
comma
op_star
id|sbin
comma
op_star
id|init
op_assign
l_int|NULL
suffix:semicolon
id|root
op_assign
id|creat_dentry
(paren
id|UMSDOS_PSDROOT_NAME
comma
id|strlen
(paren
id|UMSDOS_PSDROOT_NAME
)paren
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|sbin
op_assign
id|creat_dentry
(paren
l_string|&quot;sbin&quot;
comma
l_int|4
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;Mounting root&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_real_lookup
(paren
id|pseudo
comma
id|root
)paren
op_eq
l_int|0
op_logical_and
(paren
id|root-&gt;d_inode
op_ne
l_int|NULL
)paren
op_logical_and
id|S_ISDIR
(paren
id|root-&gt;d_inode-&gt;i_mode
)paren
)paren
(brace
r_int
id|pseudo_ok
op_assign
l_int|0
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;/%s is there&bslash;n&quot;
comma
id|UMSDOS_PSDROOT_NAME
)paren
)paren
suffix:semicolon
id|etc
op_assign
id|creat_dentry
(paren
l_string|&quot;etc&quot;
comma
l_int|3
comma
l_int|NULL
comma
id|root
)paren
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_real_lookup
(paren
id|pseudo
comma
id|etc
)paren
op_eq
l_int|0
op_logical_and
id|S_ISDIR
(paren
id|etc-&gt;d_inode-&gt;i_mode
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;/%s/etc is there&bslash;n&quot;
comma
id|UMSDOS_PSDROOT_NAME
)paren
)paren
suffix:semicolon
id|init
op_assign
id|creat_dentry
(paren
l_string|&quot;init&quot;
comma
l_int|4
comma
l_int|NULL
comma
id|etc
)paren
suffix:semicolon
id|etc_rc
op_assign
id|creat_dentry
(paren
l_string|&quot;rc&quot;
comma
l_int|2
comma
l_int|NULL
comma
id|etc
)paren
suffix:semicolon
multiline_comment|/* if ((umsdos_real_lookup (etc,&quot;init&quot;,4,init)==0 */
r_if
c_cond
(paren
(paren
id|umsdos_real_lookup
(paren
id|pseudo
comma
id|init
)paren
op_eq
l_int|0
op_logical_and
id|S_ISREG
(paren
id|init-&gt;d_inode-&gt;i_mode
)paren
)paren
multiline_comment|/*       || (umsdos_real_lookup (etc,&quot;rc&quot;,2,&amp;rc)==0 */
op_logical_or
(paren
id|umsdos_real_lookup
(paren
id|pseudo
comma
id|etc_rc
)paren
op_eq
l_int|0
op_logical_and
id|S_ISREG
(paren
id|etc_rc-&gt;d_inode-&gt;i_mode
)paren
)paren
)paren
(brace
id|pseudo_ok
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* FIXME !!!!!! */
multiline_comment|/* iput(init); */
multiline_comment|/* iput(rc); */
)brace
r_if
c_cond
(paren
op_logical_neg
id|pseudo_ok
multiline_comment|/* &amp;&amp; umsdos_real_lookup (pseudo, &quot;sbin&quot;, 4, sbin)==0 */
op_logical_and
id|umsdos_real_lookup
(paren
id|pseudo
comma
id|sbin
)paren
op_eq
l_int|0
op_logical_and
id|S_ISDIR
(paren
id|sbin-&gt;d_inode-&gt;i_mode
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;/%s/sbin is there&bslash;n&quot;
comma
id|UMSDOS_PSDROOT_NAME
)paren
)paren
suffix:semicolon
multiline_comment|/* if (umsdos_real_lookup (sbin,&quot;init&quot;,4,init)==0 */
r_if
c_cond
(paren
id|umsdos_real_lookup
(paren
id|pseudo
comma
id|init
)paren
op_eq
l_int|0
op_logical_and
id|S_ISREG
(paren
id|init-&gt;d_inode-&gt;i_mode
)paren
)paren
(brace
id|pseudo_ok
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* FIXME !!! &n;&t;&t;&t;&t; * iput (init); */
)brace
r_if
c_cond
(paren
id|pseudo_ok
)paren
(brace
id|umsdos_setup_dir_inode
(paren
id|pseudo
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_INFO
l_string|&quot;Activating pseudo root /%s&bslash;n&quot;
comma
id|UMSDOS_PSDROOT_NAME
)paren
)paren
suffix:semicolon
id|pseudo_root
op_assign
id|pseudo
suffix:semicolon
id|inc_count
(paren
id|pseudo
)paren
suffix:semicolon
id|pseudo
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* FIXME &n;&t;&t;&t; * &n;&t;&t;&t; * iput (sbin);&n;&t;&t;&t; * iput (etc);&n;&t;&t;&t; */
)brace
id|iput
(paren
id|pseudo
)paren
suffix:semicolon
)brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_read_super /mn/: (pseudo=%lu, i_count=%d) returning %p&bslash;n&quot;
comma
id|pseudo-&gt;i_ino
comma
id|pseudo-&gt;i_count
comma
id|res
)paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|variable|umsdos_fs_type
r_static
r_struct
id|file_system_type
id|umsdos_fs_type
op_assign
(brace
l_string|&quot;umsdos&quot;
comma
id|FS_REQUIRES_DEV
comma
id|UMSDOS_read_super
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
(paren
r_int
id|init_umsdos_fs
(paren
r_void
)paren
)paren
(brace
r_return
id|register_filesystem
(paren
op_amp
id|umsdos_fs_type
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|EXPORT_NO_SYMBOLS
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
(paren
r_void
)paren
(brace
r_return
id|init_umsdos_fs
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
(paren
r_void
)paren
(brace
id|unregister_filesystem
(paren
op_amp
id|umsdos_fs_type
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
