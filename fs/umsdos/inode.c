multiline_comment|/*&n; *  linux/fs/umsdos/inode.c&n; *&n; *&t;Written 1993 by Jacques Gelinas &n; *&t;Inspired from linux/fs/msdos/... by Werner Almesberger&n; *&n; */
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/msdos_fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/umsdos_fs.h&gt;
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &quot;../../tools/version.h&quot;
macro_line|#endif
DECL|variable|pseudo_root
r_struct
id|inode
op_star
id|pseudo_root
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Useful to simulate the pseudo DOS */
multiline_comment|/* directory. See UMSDOS_readdir_x() */
multiline_comment|/* #Specification: convention / PRINTK Printk and printk&n;&t;Here is the convention for the use of printk inside fs/umsdos&n;&n;&t;printk carry important message (error or status).&n;&t;Printk is for debugging (it is a macro defined at the beginning of&n;&t;&t;   most source.&n;&t;PRINTK is a nulled Printk macro.&n;&n;&t;This convention makes the source easier to read, and Printk easier&n;&t;to shut off.&n;*/
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x)
DECL|macro|Printk
mdefine_line|#define Printk(x) printk x
DECL|function|UMSDOS_put_inode
r_void
id|UMSDOS_put_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;put inode %x owner %x pos %d dir %x&bslash;n&quot;
comma
id|inode
comma
id|inode-&gt;u.umsdos_i.i_emd_owner
comma
id|inode-&gt;u.umsdos_i.pos
comma
id|inode-&gt;u.umsdos_i.i_emd_dir
)paren
)paren
suffix:semicolon
id|msdos_put_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
DECL|function|UMSDOS_put_super
r_void
id|UMSDOS_put_super
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
id|msdos_put_super
c_func
(paren
id|sb
)paren
suffix:semicolon
macro_line|#ifdef MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
)brace
DECL|function|UMSDOS_statfs
r_void
id|UMSDOS_statfs
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|statfs
op_star
id|buf
)paren
(brace
id|msdos_statfs
c_func
(paren
id|sb
comma
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Call msdos_lookup, but set back the original msdos function table.&n;&t;Return 0 if ok, or a negative error code if not.&n;*/
DECL|function|umsdos_real_lookup
r_int
id|umsdos_real_lookup
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
r_struct
id|inode
op_star
op_star
id|result
)paren
multiline_comment|/* Will hold inode of the file, if successful */
(brace
r_int
id|ret
suffix:semicolon
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|msdos_lookup
(paren
id|dir
comma
id|name
comma
id|len
comma
id|result
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Complete the setup of an directory inode.&n;&t;First, it completes the function pointers, then&n;&t;it locates the EMD file. If the EMD is there, then plug the&n;&t;umsdos function table. If not, use the msdos one.&n;*/
DECL|function|umsdos_setup_dir_inode
r_void
id|umsdos_setup_dir_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|inode-&gt;u.umsdos_i.i_emd_dir
op_assign
l_int|0
suffix:semicolon
(brace
r_struct
id|inode
op_star
id|emd_dir
op_assign
id|umsdos_emd_dir_lookup
(paren
id|inode
comma
l_int|0
)paren
suffix:semicolon
r_extern
r_struct
id|inode_operations
id|umsdos_rdir_inode_operations
suffix:semicolon
id|inode-&gt;i_op
op_assign
id|emd_dir
op_ne
l_int|NULL
ques
c_cond
op_amp
id|umsdos_dir_inode_operations
suffix:colon
op_amp
id|umsdos_rdir_inode_operations
suffix:semicolon
id|iput
(paren
id|emd_dir
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;Add some info into an inode so it can find its owner quickly&n;*/
DECL|function|umsdos_set_dirinfo
r_void
id|umsdos_set_dirinfo
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|inode
op_star
id|dir
comma
id|off_t
id|f_pos
)paren
(brace
r_struct
id|inode
op_star
id|emd_owner
op_assign
id|umsdos_emd_dir_lookup
c_func
(paren
id|dir
comma
l_int|1
)paren
suffix:semicolon
id|inode-&gt;u.umsdos_i.i_dir_owner
op_assign
id|dir-&gt;i_ino
suffix:semicolon
id|inode-&gt;u.umsdos_i.i_emd_owner
op_assign
id|emd_owner-&gt;i_ino
suffix:semicolon
id|iput
(paren
id|emd_owner
)paren
suffix:semicolon
id|inode-&gt;u.umsdos_i.pos
op_assign
id|f_pos
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Tells if an Umsdos inode has been &quot;patched&quot; once.&n;&t;Return != 0 if so.&n;*/
DECL|function|umsdos_isinit
r_int
id|umsdos_isinit
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
macro_line|#if&t;1
r_return
id|inode-&gt;u.umsdos_i.i_emd_owner
op_ne
l_int|0
suffix:semicolon
macro_line|#elif 0
r_return
id|inode-&gt;i_atime
op_ne
l_int|0
suffix:semicolon
macro_line|#else
r_return
id|inode-&gt;i_count
OG
l_int|1
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t;Connect the proper tables in the inode and add some info.&n;*/
DECL|function|umsdos_patch_inode
r_void
id|umsdos_patch_inode
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|inode
op_star
id|dir
comma
multiline_comment|/* May be NULL */
id|off_t
id|f_pos
)paren
(brace
multiline_comment|/*&n;&t;&t;This function is called very early to setup the inode, somewhat&n;&t;&t;too early (called by UMSDOS_read_inode). At this point, we can&squot;t&n;&t;&t;do to much, such as lookup up EMD files and so on. This causes&n;&t;&t;confusion in the kernel. This is why some initialisation&n;&t;&t;will be done when dir != NULL only.&n;&n;&t;&t;UMSDOS do run piggy back on top of msdos fs. It looks like something&n;&t;&t;is missing in the VFS to accommodate stacked fs. Still unclear what&n;&t;&t;(quite honestly).&n;&n;&t;&t;Well, maybe one! A new entry &quot;may_unmount&quot; which would allow&n;&t;&t;the stacked fs to allocate some inode permanently and release&n;&t;&t;them at the end. Doing that now introduce a problem. unmount&n;&t;&t;always fail because some inodes are in use.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|umsdos_isinit
c_func
(paren
id|inode
)paren
)paren
(brace
id|inode-&gt;u.umsdos_i.i_emd_dir
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
r_static
r_char
id|is_init
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_init
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;I don&squot;t want to change the msdos file system code&n;&t;&t;&t;&t;&t;so I get the address of some subroutine dynamically&n;&t;&t;&t;&t;&t;once.&n;&t;&t;&t;&t;*/
id|umsdos_file_inode_operations.bmap
op_assign
id|inode-&gt;i_op-&gt;bmap
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_file_inode_operations
suffix:semicolon
id|is_init
op_assign
l_int|1
suffix:semicolon
)brace
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_file_inode_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|dir
op_ne
l_int|NULL
)paren
(brace
id|umsdos_setup_dir_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_symlink_inode_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|chrdev_inode_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|blkdev_inode_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISFIFO
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|init_fifo
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dir
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* #Specification: inode / umsdos info&n;&t;&t;&t;&t;The first time an inode is seen (inode-&gt;i_count == 1),&n;&t;&t;&t;&t;the inode number of the EMD file which control this inode&n;&t;&t;&t;&t;is tagged to this inode. It allows operation such&n;&t;&t;&t;&t;as notify_change to be handled.&n;&t;&t;&t;*/
multiline_comment|/*&n;&t;&t;&t;&t;This is done last because it also control the&n;&t;&t;&t;&t;status of umsdos_isinit()&n;&t;&t;&t;*/
id|umsdos_set_dirinfo
(paren
id|inode
comma
id|dir
comma
id|f_pos
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|dir
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;Test to see if the info is maintained.&n;&t;&t;&t;This should be removed when the file system will be proven.&n;&t;&t;*/
r_struct
id|inode
op_star
id|emd_owner
op_assign
id|umsdos_emd_dir_lookup
c_func
(paren
id|dir
comma
l_int|1
)paren
suffix:semicolon
id|iput
(paren
id|emd_owner
)paren
suffix:semicolon
r_if
c_cond
(paren
id|emd_owner-&gt;i_ino
op_ne
id|inode-&gt;u.umsdos_i.i_emd_owner
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: *** EMD_OWNER ??? *** ino = %ld %ld &lt;&gt; %ld &quot;
comma
id|inode-&gt;i_ino
comma
id|emd_owner-&gt;i_ino
comma
id|inode-&gt;u.umsdos_i.i_emd_owner
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;Get the inode of the directory which owns this inode.&n;&t;Return 0 if ok, -EIO if error.&n;*/
DECL|function|umsdos_get_dirowner
r_int
id|umsdos_get_dirowner
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|inode
op_star
op_star
id|result
)paren
multiline_comment|/* Hold NULL if any error */
multiline_comment|/* else, the inode of the directory */
(brace
r_int
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_int
r_int
id|ino
op_assign
id|inode-&gt;u.umsdos_i.i_dir_owner
suffix:semicolon
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ino
op_eq
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: umsdos_get_dirowner ino == 0&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|inode
op_star
id|dir
op_assign
op_star
id|result
op_assign
id|iget
c_func
(paren
id|inode-&gt;i_sb
comma
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_ne
l_int|NULL
)paren
(brace
id|umsdos_patch_inode
(paren
id|dir
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Load an inode from disk.&n;*/
DECL|function|UMSDOS_read_inode
r_void
id|UMSDOS_read_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;read inode %x ino = %d &quot;
comma
id|inode
comma
id|inode-&gt;i_ino
)paren
)paren
suffix:semicolon
id|msdos_read_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;ino = %d %d&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|inode-&gt;i_count
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
(paren
id|inode-&gt;u.umsdos_i.u.dir_info.creating
op_ne
l_int|0
op_logical_or
id|inode-&gt;u.umsdos_i.u.dir_info.looking
op_ne
l_int|0
op_logical_or
id|inode-&gt;u.umsdos_i.u.dir_info.p
op_ne
l_int|NULL
)paren
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;read inode %d %d %p&bslash;n&quot;
comma
id|inode-&gt;u.umsdos_i.u.dir_info.creating
comma
id|inode-&gt;u.umsdos_i.u.dir_info.looking
comma
id|inode-&gt;u.umsdos_i.u.dir_info.p
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* #Specification: Inode / post initialisation&n;&t;&t;To completely initialise an inode, we need access to the owner&n;&t;&t;directory, so we can locate more info in the EMD file. This is&n;&t;&t;not available the first time the inode is access, we use&n;&t;&t;a value in the inode to tell if it has been finally initialised.&n;&n;&t;&t;At first, we have tried testing i_count but it was causing&n;&t;&t;problem. It is possible that two or more process use the&n;&t;&t;newly accessed inode. While the first one block during&n;&t;&t;the initialisation (probably while reading the EMD file), the&n;&t;&t;others believe all is well because i_count &gt; 1. They go banana&n;&t;&t;with a broken inode. See umsdos_lookup_patch and umsdos_patch_inode.&n;&t;*/
id|umsdos_patch_inode
c_func
(paren
id|inode
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Update the disk with the inode content&n;*/
DECL|function|UMSDOS_write_inode
r_void
id|UMSDOS_write_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|iattr
id|newattrs
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;UMSDOS_write_inode emd %d&bslash;n&quot;
comma
id|inode-&gt;u.umsdos_i.i_emd_owner
)paren
)paren
suffix:semicolon
id|msdos_write_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|newattrs.ia_mtime
op_assign
id|inode-&gt;i_mtime
suffix:semicolon
id|newattrs.ia_atime
op_assign
id|inode-&gt;i_atime
suffix:semicolon
id|newattrs.ia_ctime
op_assign
id|inode-&gt;i_ctime
suffix:semicolon
id|newattrs.ia_valid
op_assign
id|ATTR_MTIME
op_or
id|ATTR_ATIME
op_or
id|ATTR_CTIME
suffix:semicolon
multiline_comment|/*&n;&t;&t;UMSDOS_notify_change is convenient to call here&n;&t;&t;to update the EMD entry associated with this inode.&n;&t;&t;But it has the side effect to re&quot;dirt&quot; the inode.&n;&t;*/
id|UMSDOS_notify_change
(paren
id|inode
comma
op_amp
id|newattrs
)paren
suffix:semicolon
id|inode-&gt;i_dirt
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|UMSDOS_notify_change
r_int
id|UMSDOS_notify_change
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|iattr
op_star
id|attr
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|inode_change_ok
c_func
(paren
id|inode
comma
id|attr
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_nlink
OG
l_int|0
)paren
(brace
multiline_comment|/* #Specification: notify_change / i_nlink &gt; 0&n;&t;&t;&t;notify change is only done for inode with nlink &gt; 0. An inode&n;&t;&t;&t;with nlink == 0 is no longer associated with any entry in&n;&t;&t;&t;the EMD file, so there is nothing to update.&n;&t;&t;*/
r_int
r_int
id|i_emd_owner
op_assign
id|inode-&gt;u.umsdos_i.i_emd_owner
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_eq
id|inode-&gt;i_sb-&gt;s_mounted
)paren
(brace
multiline_comment|/* #Specification: root inode / attributes&n;&t;&t;&t;&t;I don&squot;t know yet how this should work. Normally&n;&t;&t;&t;&t;the attributes (permissions bits, owner, times) of&n;&t;&t;&t;&t;a directory are stored in the EMD file of its parent.&n;&n;&t;&t;&t;&t;One thing we could do is store the attributes of the root&n;&t;&t;&t;&t;inode in its own EMD file. A simple entry named &quot;.&quot; could&n;&t;&t;&t;&t;be used for this special case. It would be read once&n;&t;&t;&t;&t;when the file system is mounted and update in&n;&t;&t;&t;&t;UMSDOS_notify_change() (right here).&n;&n;&t;&t;&t;&t;I am not sure of the behavior of the root inode for&n;&t;&t;&t;&t;a real UNIX file system. For now, this is a nop.&n;&t;&t;&t;*/
)brace
r_else
r_if
c_cond
(paren
id|i_emd_owner
op_ne
l_int|0xffffffff
op_logical_and
id|i_emd_owner
op_ne
l_int|0
)paren
(brace
multiline_comment|/* This inode is not a EMD file nor an inode used internally&n;&t;&t;&t;&t;by MSDOS, so we can update its status.&n;&t;&t;&t;&t;See emd.c&n;&t;&t;&t;*/
r_struct
id|inode
op_star
id|emd_owner
op_assign
id|iget
(paren
id|inode-&gt;i_sb
comma
id|i_emd_owner
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;notify change %p &quot;
comma
id|inode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|emd_owner
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: emd_owner = NULL ???&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_else
(brace
r_struct
id|file
id|filp
suffix:semicolon
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
id|filp.f_pos
op_assign
id|inode-&gt;u.umsdos_i.pos
suffix:semicolon
id|filp.f_reada
op_assign
l_int|0
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;pos = %d &quot;
comma
id|filp.f_pos
)paren
)paren
suffix:semicolon
multiline_comment|/* Read only the start of the entry since we don&squot;t touch */
multiline_comment|/* the name */
id|ret
op_assign
id|umsdos_emd_dir_read
(paren
id|emd_owner
comma
op_amp
id|filp
comma
(paren
r_char
op_star
)paren
op_amp
id|entry
comma
id|UMSDOS_REC_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_UID
)paren
id|entry.uid
op_assign
id|attr-&gt;ia_uid
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_GID
)paren
id|entry.gid
op_assign
id|attr-&gt;ia_gid
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_MODE
)paren
id|entry.mode
op_assign
id|attr-&gt;ia_mode
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_ATIME
)paren
id|entry.atime
op_assign
id|attr-&gt;ia_atime
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_MTIME
)paren
id|entry.mtime
op_assign
id|attr-&gt;ia_mtime
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_CTIME
)paren
id|entry.ctime
op_assign
id|attr-&gt;ia_ctime
suffix:semicolon
id|entry.nlink
op_assign
id|inode-&gt;i_nlink
suffix:semicolon
id|filp.f_pos
op_assign
id|inode-&gt;u.umsdos_i.pos
suffix:semicolon
id|ret
op_assign
id|umsdos_emd_dir_write
(paren
id|emd_owner
comma
op_amp
id|filp
comma
(paren
r_char
op_star
)paren
op_amp
id|entry
comma
id|UMSDOS_REC_SIZE
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;notify pos %d ret %d nlink %d &quot;
comma
id|inode-&gt;u.umsdos_i.pos
comma
id|ret
comma
id|entry.nlink
)paren
)paren
suffix:semicolon
multiline_comment|/* #Specification: notify_change / msdos fs&n;&t;&t;&t;&t;&t;&t;notify_change operation are done only on the&n;&t;&t;&t;&t;&t;&t;EMD file. The msdos fs is not even called.&n;&t;&t;&t;&t;&t;*/
)brace
id|iput
(paren
id|emd_owner
)paren
suffix:semicolon
)brace
id|PRINTK
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|inode_setattr
c_func
(paren
id|inode
comma
id|attr
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* #Specification: function name / convention&n;&t;A simple convention for function name has been used in&n;&t;the UMSDOS file system. First all function use the prefix&n;&t;umsdos_ to avoid name clash with other part of the kernel.&n;&n;&t;And standard VFS entry point use the prefix UMSDOS (upper case)&n;&t;so it&squot;s easier to tell them apart.&n;*/
DECL|variable|umsdos_sops
r_static
r_struct
id|super_operations
id|umsdos_sops
op_assign
(brace
id|UMSDOS_read_inode
comma
id|UMSDOS_notify_change
comma
id|UMSDOS_write_inode
comma
id|UMSDOS_put_inode
comma
id|UMSDOS_put_super
comma
l_int|NULL
comma
multiline_comment|/* added in 0.96c */
id|UMSDOS_statfs
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n;&t;Read the super block of an Extended MS-DOS FS.&n;*/
DECL|function|UMSDOS_read_super
r_struct
id|super_block
op_star
id|UMSDOS_read_super
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_void
op_star
id|data
comma
r_int
id|silent
)paren
(brace
multiline_comment|/* #Specification: mount / options&n;&t;&t;Umsdos run on top of msdos. Currently, it supports no&n;&t;&t;mount option, but happily pass all option received to&n;&t;&t;the msdos driver. I am not sure if all msdos mount option&n;&t;&t;make sense with Umsdos. Here are at least those who&n;&t;&t;are useful.&n;&t;&t;&t;uid=&n;&t;&t;&t;gid=&n;&n;&t;&t;These options affect the operation of umsdos in directories&n;&t;&t;which do not have an EMD file. They behave like normal&n;&t;&t;msdos directory, with all limitation of msdos.&n;&t;*/
r_struct
id|super_block
op_star
id|sb
op_assign
id|msdos_read_super
c_func
(paren
id|s
comma
id|data
comma
id|silent
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;UMSDOS Alpha 0.5a (compatibility level %d.%d, fast msdos)&bslash;n&quot;
comma
id|UMSDOS_VERSION
comma
id|UMSDOS_RELEASE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb
op_ne
l_int|NULL
)paren
(brace
id|sb-&gt;s_op
op_assign
op_amp
id|umsdos_sops
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;umsdos_read_super %p&bslash;n&quot;
comma
id|sb-&gt;s_mounted
)paren
)paren
suffix:semicolon
id|umsdos_setup_dir_inode
(paren
id|sb-&gt;s_mounted
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;End umsdos_read_super&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_eq
id|super_blocks
)paren
(brace
multiline_comment|/* #Specification: pseudo root / mount&n;&t;&t;&t;&t;When a umsdos fs is mounted, a special handling is done&n;&t;&t;&t;&t;if it is the root partition. We check for the presence&n;&t;&t;&t;&t;of the file /linux/etc/init or /linux/etc/rc.&n;&t;&t;&t;&t;If one is there, we do a chroot(&quot;/linux&quot;).&n;&n;&t;&t;&t;&t;We check both because (see init/main.c) the kernel&n;&t;&t;&t;&t;try to exec init at different place and if it fails&n;&t;&t;&t;&t;it tries /bin/sh /etc/rc. To be consistent with&n;&t;&t;&t;&t;init/main.c, many more test would have to be done&n;&t;&t;&t;&t;to locate init. Any complain ?&n;&n;&t;&t;&t;&t;The chroot is done manually in init/main.c but the&n;&t;&t;&t;&t;info (the inode) is located at mount time and store&n;&t;&t;&t;&t;in a global variable (pseudo_root) which is used at&n;&t;&t;&t;&t;different place in the umsdos driver. There is no&n;&t;&t;&t;&t;need to store this variable elsewhere because it&n;&t;&t;&t;&t;will always be one, not one per mount.&n;&n;&t;&t;&t;&t;This feature allows the installation&n;&t;&t;&t;&t;of a linux system within a DOS system in a subdirectory.&n;&t;&n;&t;&t;&t;&t;A user may install its linux stuff in c:&bslash;linux&n;&t;&t;&t;&t;avoiding any clash with existing DOS file and subdirectory.&n;&t;&t;&t;&t;When linux boots, it hides this fact, showing a normal&n;&t;&t;&t;&t;root directory with /etc /bin /tmp ...&n;&n;&t;&t;&t;&t;The word &quot;linux&quot; is hardcoded in /usr/include/linux/umsdos_fs.h&n;&t;&t;&t;&t;in the macro UMSDOS_PSDROOT_NAME.&n;&t;&t;&t;*/
r_struct
id|inode
op_star
id|pseudo
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;Mounting root&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_real_lookup
(paren
id|sb-&gt;s_mounted
comma
id|UMSDOS_PSDROOT_NAME
comma
id|UMSDOS_PSDROOT_LEN
comma
op_amp
id|pseudo
)paren
op_eq
l_int|0
op_logical_and
id|S_ISDIR
c_func
(paren
id|pseudo-&gt;i_mode
)paren
)paren
(brace
r_struct
id|inode
op_star
id|etc
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|rc
op_assign
l_int|NULL
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;/%s is there&bslash;n&quot;
comma
id|UMSDOS_PSDROOT_NAME
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_real_lookup
(paren
id|pseudo
comma
l_string|&quot;etc&quot;
comma
l_int|3
comma
op_amp
id|etc
)paren
op_eq
l_int|0
op_logical_and
id|S_ISDIR
c_func
(paren
id|etc-&gt;i_mode
)paren
)paren
(brace
r_struct
id|inode
op_star
id|init
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;/%s/etc is there&bslash;n&quot;
comma
id|UMSDOS_PSDROOT_NAME
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|umsdos_real_lookup
(paren
id|etc
comma
l_string|&quot;init&quot;
comma
l_int|4
comma
op_amp
id|init
)paren
op_eq
l_int|0
op_logical_and
id|S_ISREG
c_func
(paren
id|init-&gt;i_mode
)paren
)paren
op_logical_or
(paren
id|umsdos_real_lookup
(paren
id|etc
comma
l_string|&quot;rc&quot;
comma
l_int|2
comma
op_amp
id|rc
)paren
op_eq
l_int|0
op_logical_and
id|S_ISREG
c_func
(paren
id|rc-&gt;i_mode
)paren
)paren
)paren
(brace
id|umsdos_setup_dir_inode
(paren
id|pseudo
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;Activating pseudo root /%s&bslash;n&quot;
comma
id|UMSDOS_PSDROOT_NAME
)paren
)paren
suffix:semicolon
id|pseudo_root
op_assign
id|pseudo
suffix:semicolon
id|pseudo-&gt;i_count
op_increment
suffix:semicolon
id|pseudo
op_assign
l_int|NULL
suffix:semicolon
)brace
id|iput
(paren
id|init
)paren
suffix:semicolon
id|iput
(paren
id|rc
)paren
suffix:semicolon
)brace
id|iput
(paren
id|etc
)paren
suffix:semicolon
)brace
id|iput
(paren
id|pseudo
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif
)brace
r_return
id|sb
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|kernel_version
r_char
id|kernel_version
(braket
)braket
op_assign
id|UTS_RELEASE
suffix:semicolon
DECL|variable|umsdos_fs_type
r_static
r_struct
id|file_system_type
id|umsdos_fs_type
op_assign
(brace
id|UMSDOS_read_super
comma
l_string|&quot;umsdos&quot;
comma
l_int|1
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
id|register_filesystem
c_func
(paren
op_amp
id|umsdos_fs_type
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|MOD_IN_USE
)paren
id|printk
c_func
(paren
l_string|&quot;Umsdos: file system in use, remove delayed&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|unregister_filesystem
c_func
(paren
op_amp
id|umsdos_fs_type
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
eof
