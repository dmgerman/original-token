multiline_comment|/*&n; *  linux/fs/umsdos/inode.c&n; *&n; *&t;Written 1993 by Jacques Gelinas&n; *&t;Inspired from linux/fs/msdos/... by Werner Almesberger&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/msdos_fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/umsdos_fs.h&gt;
DECL|variable|pseudo_root
r_struct
id|inode
op_star
id|pseudo_root
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Useful to simulate the pseudo DOS */
multiline_comment|/* directory. See UMSDOS_readdir_x() */
multiline_comment|/* #Specification: convention / PRINTK Printk and printk&n;   Here is the convention for the use of printk inside fs/umsdos&n;   &n;   printk carry important message (error or status).&n;   Printk is for debugging (it is a macro defined at the beginning of&n;   most source.&n;   PRINTK is a nulled Printk macro.&n;   &n;   This convention makes the source easier to read, and Printk easier&n;   to shut off.&n;*/
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x)
DECL|macro|Printk
mdefine_line|#define Printk(x) printk x
DECL|function|UMSDOS_put_inode
r_void
id|UMSDOS_put_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;put inode %p (%lu) owner %lu pos %lu dir %lu&bslash;n&quot;
comma
id|inode
comma
id|inode-&gt;i_ino
comma
id|inode-&gt;u.umsdos_i.i_emd_owner
comma
id|inode-&gt;u.umsdos_i.pos
comma
id|inode-&gt;u.umsdos_i.i_emd_dir
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_logical_and
id|pseudo_root
op_logical_and
id|inode
op_eq
id|pseudo_root
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;Umsdos: Oops releasing pseudo_root. Notify jacques@solucorp.qc.ca&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#if 1
id|fat_put_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
macro_line|#else  
id|Printk
(paren
(paren
id|KERN_WARNING
l_string|&quot;UMSDOS_put_inode: skipping ! FIXME /mn/&bslash;n&quot;
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|UMSDOS_put_super
r_void
id|UMSDOS_put_super
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS_put_super: entering&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|msdos_put_super
c_func
(paren
id|sb
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/*&n;  Call msdos_lookup, but set back the original msdos function table.&n;  Return 0 if ok, or a negative error code if not.&n;*/
DECL|function|umsdos_real_lookup
r_int
id|umsdos_real_lookup
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
multiline_comment|/* Will hold inode of the file, if successful */
(brace
r_int
id|ret
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_real_lookup /mn/: looking for %s /&quot;
comma
id|dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
id|dir-&gt;i_count
op_increment
suffix:semicolon
multiline_comment|/* /mn/ what is this and why ? locking? */
id|ret
op_assign
id|msdos_lookup
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;/ returned %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;  Complete the setup of an directory inode.&n;  First, it completes the function pointers, then&n;  it locates the EMD file. If the EMD is there, then plug the&n;  umsdos function table. If not, use the msdos one.&n;*/
DECL|function|umsdos_setup_dir_inode
r_void
id|umsdos_setup_dir_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|inode-&gt;u.umsdos_i.i_emd_dir
op_assign
l_int|0
suffix:semicolon
(brace
r_struct
id|inode
op_star
id|emd_dir
op_assign
l_int|NULL
suffix:semicolon
r_extern
r_struct
id|inode_operations
id|umsdos_rdir_inode_operations
suffix:semicolon
id|emd_dir
op_assign
id|umsdos_emd_dir_lookup
(paren
id|inode
comma
l_int|0
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_setup_dir_inode: umsdos_emd_dir_lookup for inode=%p returned %p&bslash;n&quot;
comma
id|inode
comma
id|emd_dir
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|emd_dir
op_eq
l_int|NULL
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_setup_dir_inode /mn/: Setting up dir_inode_ops --&gt; eg. NOT using EMD.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_rdir_inode_operations
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_setup_dir_inode /mn/: Setting up rdir_inode_ops --&gt; eg. using EMD.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_dir_inode_operations
suffix:semicolon
)brace
multiline_comment|/*    iput (emd_dir); FIXME /mn/ ! */
)brace
)brace
multiline_comment|/*&n;&t;Add some info into an inode so it can find its owner quickly&n;*/
DECL|function|umsdos_set_dirinfo
r_void
id|umsdos_set_dirinfo
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|inode
op_star
id|dir
comma
id|off_t
id|f_pos
)paren
(brace
r_struct
id|inode
op_star
id|emd_owner
suffix:semicolon
multiline_comment|/* FIXME, I don&squot;t have a clue on this one - /mn/ hmmm ? ok ? */
multiline_comment|/*    Printk ((KERN_WARNING &quot;umsdos_set_dirinfo: /mn/ FIXME: no clue. inode=%lu dir=%lu&bslash;n&quot;, inode-&gt;i_ino, dir-&gt;i_ino));*/
id|emd_owner
op_assign
id|umsdos_emd_dir_lookup
c_func
(paren
id|dir
comma
l_int|1
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_set_dirinfo: emd_owner is %lu for dir %lu&bslash;n&quot;
comma
id|emd_owner-&gt;i_ino
comma
id|dir-&gt;i_ino
)paren
)paren
suffix:semicolon
id|inode-&gt;u.umsdos_i.i_dir_owner
op_assign
id|dir-&gt;i_ino
suffix:semicolon
id|inode-&gt;u.umsdos_i.i_emd_owner
op_assign
id|emd_owner-&gt;i_ino
suffix:semicolon
multiline_comment|/* iput (emd_owner); FIXME */
id|inode-&gt;u.umsdos_i.pos
op_assign
id|f_pos
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Tells if an Umsdos inode has been &quot;patched&quot; once.&n;&t;Return != 0 if so.&n;*/
DECL|function|umsdos_isinit
r_int
id|umsdos_isinit
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
macro_line|#if&t;1
r_return
id|inode-&gt;u.umsdos_i.i_emd_owner
op_ne
l_int|0
suffix:semicolon
macro_line|#elif 0
r_return
id|inode-&gt;i_atime
op_ne
l_int|0
suffix:semicolon
macro_line|#else
r_return
id|atomic_read
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
OG
l_int|1
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;  Connect the proper tables in the inode and add some info.&n;*/
DECL|function|umsdos_patch_inode
r_void
id|umsdos_patch_inode
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|inode
op_star
id|dir
comma
multiline_comment|/* May be NULL */
id|off_t
id|f_pos
)paren
(brace
multiline_comment|/*&n;    This function is called very early to setup the inode, somewhat&n;    too early (called by UMSDOS_read_inode). At this point, we can&squot;t&n;    do to much, such as lookup up EMD files and so on. This causes&n;    confusion in the kernel. This is why some initialisation&n;    will be done when dir != NULL only.&n;    &n;    UMSDOS do run piggy back on top of msdos fs. It looks like something&n;    is missing in the VFS to accommodate stacked fs. Still unclear what&n;    (quite honestly).&n;    &n;    Well, maybe one! A new entry &quot;may_unmount&quot; which would allow&n;    the stacked fs to allocate some inode permanently and release&n;    them at the end. Doing that now introduce a problem. unmount&n;    always fail because some inodes are in use.&n;  */
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;Entering umsdos_patch_inode for inode=%lu&bslash;n&quot;
comma
id|inode-&gt;i_ino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|umsdos_isinit
c_func
(paren
id|inode
)paren
)paren
(brace
id|inode-&gt;u.umsdos_i.i_emd_dir
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|MSDOS_SB
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|cvf_format
)paren
(brace
r_if
c_cond
(paren
id|MSDOS_SB
c_func
(paren
id|inode-&gt;i_sb
)paren
op_member_access_from_pointer
id|cvf_format-&gt;flags
op_amp
id|CVF_USE_READPAGE
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: seting i_op = umsdos_file_inode_operations_readpage&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_file_inode_operations_readpage
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: seting i_op = umsdos_file_inode_operations_no_bmap&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_file_inode_operations_no_bmap
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|inode-&gt;i_op-&gt;bmap
op_ne
l_int|NULL
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: seting i_op = umsdos_file_inode_operations&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_file_inode_operations
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: seting i_op = umsdos_file_inode_operations_no_bmap&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_file_inode_operations_no_bmap
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|dir
op_ne
l_int|NULL
)paren
(brace
id|umsdos_setup_dir_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: seting i_op = umsdos_symlink_inode_operations&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|umsdos_symlink_inode_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: seting i_op = chrdev_inode_operations&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|chrdev_inode_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: seting i_op = blkdev_inode_operations&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|blkdev_inode_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISFIFO
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: uhm, init_fifo&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|init_fifo
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dir
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* #Specification: inode / umsdos info&n;&t; The first time an inode is seen (inode-&gt;i_count == 1),&n;&t; the inode number of the EMD file which control this inode&n;&t; is tagged to this inode. It allows operation such&n;&t; as notify_change to be handled.&n;      */
multiline_comment|/*&n;&t;This is done last because it also control the&n;&t;status of umsdos_isinit()&n;      */
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_patch_inode /mn/: here we go: calling umsdos_set_dirinfo (%p,%p,%lu)&bslash;n&quot;
comma
id|inode
comma
id|dir
comma
id|f_pos
)paren
)paren
suffix:semicolon
id|umsdos_set_dirinfo
(paren
id|inode
comma
id|dir
comma
id|f_pos
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|dir
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;      Test to see if the info is maintained.&n;      This should be removed when the file system will be proven.&n;    */
multiline_comment|/* FIXME, again, not a clue */
r_struct
id|inode
op_star
id|emd_owner
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_WARNING
l_string|&quot;umsdos_patch_inode: /mn/ Warning: untested emd_owner thingy...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|emd_owner
op_assign
id|umsdos_emd_dir_lookup
c_func
(paren
id|dir
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* iput (emd_owner); FIXME */
r_if
c_cond
(paren
id|emd_owner-&gt;i_ino
op_ne
id|inode-&gt;u.umsdos_i.i_emd_owner
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: *** EMD_OWNER ??? *** ino = %ld %ld &lt;&gt; %ld &quot;
comma
id|inode-&gt;i_ino
comma
id|emd_owner-&gt;i_ino
comma
id|inode-&gt;u.umsdos_i.i_emd_owner
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;  Get the inode of the directory which owns this inode.&n;  Return 0 if ok, -EIO if error.&n;*/
DECL|function|umsdos_get_dirowner
r_int
id|umsdos_get_dirowner
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|inode
op_star
op_star
id|result
)paren
multiline_comment|/* Hold NULL if any error */
multiline_comment|/* else, the inode of the directory */
(brace
r_int
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_int
r_int
id|ino
op_assign
id|inode-&gt;u.umsdos_i.i_dir_owner
suffix:semicolon
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ino
op_eq
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: umsdos_get_dirowner ino == 0&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|inode
op_star
id|dir
op_assign
op_star
id|result
op_assign
id|iget
c_func
(paren
id|inode-&gt;i_sb
comma
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_ne
l_int|NULL
)paren
(brace
id|umsdos_patch_inode
(paren
id|dir
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Load an inode from disk.&n;*/
DECL|function|UMSDOS_read_inode
r_void
id|UMSDOS_read_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS_read_inode %p ino = %lu &quot;
comma
id|inode
comma
id|inode-&gt;i_ino
)paren
)paren
suffix:semicolon
id|msdos_read_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;ino after msdos_read_inode= %lu&bslash;n&quot;
comma
id|inode-&gt;i_ino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
(paren
id|inode-&gt;u.umsdos_i.u.dir_info.creating
op_ne
l_int|0
op_logical_or
id|inode-&gt;u.umsdos_i.u.dir_info.looking
op_ne
l_int|0
op_logical_or
id|waitqueue_active
c_func
(paren
op_amp
id|inode-&gt;u.umsdos_i.u.dir_info.p
)paren
)paren
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;read inode %d %d %p&bslash;n&quot;
comma
id|inode-&gt;u.umsdos_i.u.dir_info.creating
comma
id|inode-&gt;u.umsdos_i.u.dir_info.looking
comma
id|inode-&gt;u.umsdos_i.u.dir_info.p
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* #Specification: Inode / post initialisation&n;&t;&t;To completely initialise an inode, we need access to the owner&n;&t;&t;directory, so we can locate more info in the EMD file. This is&n;&t;&t;not available the first time the inode is access, we use&n;&t;&t;a value in the inode to tell if it has been finally initialised.&n;&n;&t;&t;At first, we have tried testing i_count but it was causing&n;&t;&t;problem. It is possible that two or more process use the&n;&t;&t;newly accessed inode. While the first one block during&n;&t;&t;the initialisation (probably while reading the EMD file), the&n;&t;&t;others believe all is well because i_count &gt; 1. They go banana&n;&t;&t;with a broken inode. See umsdos_lookup_patch and umsdos_patch_inode.&n;&t;*/
id|umsdos_patch_inode
c_func
(paren
id|inode
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Update the disk with the inode content&n;*/
DECL|function|UMSDOS_write_inode
r_void
id|UMSDOS_write_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|iattr
id|newattrs
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;UMSDOS_write_inode emd %d (FIXME: missing notify_change)&bslash;n&quot;
comma
id|inode-&gt;u.umsdos_i.i_emd_owner
)paren
)paren
suffix:semicolon
id|fat_write_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|newattrs.ia_mtime
op_assign
id|inode-&gt;i_mtime
suffix:semicolon
id|newattrs.ia_atime
op_assign
id|inode-&gt;i_atime
suffix:semicolon
id|newattrs.ia_ctime
op_assign
id|inode-&gt;i_ctime
suffix:semicolon
id|newattrs.ia_valid
op_assign
id|ATTR_MTIME
op_or
id|ATTR_ATIME
op_or
id|ATTR_CTIME
suffix:semicolon
multiline_comment|/*&n;&t;&t;UMSDOS_notify_change is convenient to call here&n;&t;&t;to update the EMD entry associated with this inode.&n;&t;&t;But it has the side effect to re&quot;dirt&quot; the inode.&n;&t;*/
multiline_comment|/* FIXME, notify_change now takes a dentry, not an&n;&t;   inode so, the emd update needs to be done here&n;&t;UMSDOS_notify_change (inode, &amp;newattrs);&n;&t;*/
multiline_comment|/* FIXME inode-&gt;i_dirt = 0; */
)brace
DECL|function|internal_notify_change
r_int
id|internal_notify_change
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|iattr
op_star
id|attr
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS_notify_change: entering&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|inode_change_ok
c_func
(paren
id|inode
comma
id|attr
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_nlink
OG
l_int|0
)paren
(brace
multiline_comment|/* #Specification: notify_change / i_nlink &gt; 0&n;       notify change is only done for inode with nlink &gt; 0. An inode&n;       with nlink == 0 is no longer associated with any entry in&n;       the EMD file, so there is nothing to update.&n;    */
r_int
r_int
id|i_emd_owner
op_assign
id|inode-&gt;u.umsdos_i.i_emd_owner
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_eq
id|iget
c_func
(paren
id|inode-&gt;i_sb
comma
id|UMSDOS_ROOT_INO
)paren
)paren
(brace
multiline_comment|/* #Specification: root inode / attributes&n;&t; I don&squot;t know yet how this should work. Normally&n;&t; the attributes (permissions bits, owner, times) of&n;&t; a directory are stored in the EMD file of its parent.&n;&t; &n;&t; One thing we could do is store the attributes of the root&n;&t; inode in its own EMD file. A simple entry named &quot;.&quot; could&n;&t; be used for this special case. It would be read once&n;&t; when the file system is mounted and update in&n;&t; UMSDOS_notify_change() (right here).&n;&t; &n;&t; I am not sure of the behavior of the root inode for&n;&t; a real UNIX file system. For now, this is a nop.&n;      */
)brace
r_else
r_if
c_cond
(paren
id|i_emd_owner
op_ne
l_int|0xffffffff
op_logical_and
id|i_emd_owner
op_ne
l_int|0
)paren
(brace
multiline_comment|/* This inode is not a EMD file nor an inode used internally&n;&t; by MSDOS, so we can update its status.&n;&t; See emd.c&n;      */
r_struct
id|inode
op_star
id|emd_owner
op_assign
id|iget
(paren
id|inode-&gt;i_sb
comma
id|i_emd_owner
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;notify change %p &quot;
comma
id|inode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|emd_owner
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: emd_owner = NULL ???&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_else
(brace
r_struct
id|file
id|filp
suffix:semicolon
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
r_struct
id|dentry
op_star
id|emd_dentry
suffix:semicolon
id|loff_t
id|offs
suffix:semicolon
id|emd_dentry
op_assign
id|creat_dentry
(paren
l_string|&quot;notify_emd&quot;
comma
l_int|10
comma
id|emd_owner
comma
l_int|NULL
)paren
suffix:semicolon
id|fill_new_filp
(paren
op_amp
id|filp
comma
id|emd_dentry
)paren
suffix:semicolon
id|filp.f_pos
op_assign
id|inode-&gt;u.umsdos_i.pos
suffix:semicolon
id|filp.f_reada
op_assign
l_int|0
suffix:semicolon
id|offs
op_assign
id|filp.f_pos
suffix:semicolon
multiline_comment|/* FIXME: /mn/ is this ok ? */
id|Printk
(paren
(paren
l_string|&quot;pos = %Lu &quot;
comma
id|filp.f_pos
)paren
)paren
suffix:semicolon
multiline_comment|/* Read only the start of the entry since we don&squot;t touch */
multiline_comment|/* the name */
id|ret
op_assign
id|umsdos_emd_dir_read
(paren
id|emd_owner
comma
op_amp
id|filp
comma
(paren
r_char
op_star
)paren
op_amp
id|entry
comma
id|UMSDOS_REC_SIZE
comma
op_amp
id|offs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_UID
)paren
id|entry.uid
op_assign
id|attr-&gt;ia_uid
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_GID
)paren
id|entry.gid
op_assign
id|attr-&gt;ia_gid
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_MODE
)paren
id|entry.mode
op_assign
id|attr-&gt;ia_mode
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_ATIME
)paren
id|entry.atime
op_assign
id|attr-&gt;ia_atime
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_MTIME
)paren
id|entry.mtime
op_assign
id|attr-&gt;ia_mtime
suffix:semicolon
r_if
c_cond
(paren
id|attr-&gt;ia_valid
op_amp
id|ATTR_CTIME
)paren
id|entry.ctime
op_assign
id|attr-&gt;ia_ctime
suffix:semicolon
id|entry.nlink
op_assign
id|inode-&gt;i_nlink
suffix:semicolon
id|filp.f_pos
op_assign
id|inode-&gt;u.umsdos_i.pos
suffix:semicolon
id|offs
op_assign
id|filp.f_pos
suffix:semicolon
multiline_comment|/* FIXME: /mn/ is this ok ? */
id|ret
op_assign
id|umsdos_emd_dir_write
(paren
id|emd_owner
comma
op_amp
id|filp
comma
(paren
r_char
op_star
)paren
op_amp
id|entry
comma
id|UMSDOS_REC_SIZE
comma
op_amp
id|offs
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;notify pos %lu ret %d nlink %d &quot;
comma
id|inode-&gt;u.umsdos_i.pos
comma
id|ret
comma
id|entry.nlink
)paren
)paren
suffix:semicolon
multiline_comment|/* #Specification: notify_change / msdos fs&n;&t;     notify_change operation are done only on the&n;&t;     EMD file. The msdos fs is not even called.&n;&t;  */
)brace
multiline_comment|/* iput (emd_owner); FIXME */
)brace
id|Printk
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|inode_setattr
c_func
(paren
id|inode
comma
id|attr
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|UMSDOS_notify_change
r_int
id|UMSDOS_notify_change
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|iattr
op_star
id|attr
)paren
(brace
r_return
id|internal_notify_change
(paren
id|dentry-&gt;d_inode
comma
id|attr
)paren
suffix:semicolon
)brace
multiline_comment|/* #Specification: function name / convention&n;   A simple convention for function name has been used in&n;   the UMSDOS file system. First all function use the prefix&n;   umsdos_ to avoid name clash with other part of the kernel.&n;   &n;   And standard VFS entry point use the prefix UMSDOS (upper case)&n;   so it&squot;s easier to tell them apart.&n;   N.B. (FIXME) PTW, the order and contents of this struct changed&n;*/
DECL|variable|umsdos_sops
r_static
r_struct
id|super_operations
id|umsdos_sops
op_assign
(brace
id|UMSDOS_read_inode
comma
multiline_comment|/* read_inode */
id|UMSDOS_write_inode
comma
multiline_comment|/* write_inode */
id|UMSDOS_put_inode
comma
multiline_comment|/* put_inode */
l_int|NULL
comma
multiline_comment|/* delete_inode */
id|UMSDOS_notify_change
comma
multiline_comment|/* notify_change */
id|UMSDOS_put_super
comma
multiline_comment|/* put_super */
l_int|NULL
comma
multiline_comment|/* write_super */
id|fat_statfs
comma
multiline_comment|/* statfs */
l_int|NULL
multiline_comment|/* remount_fs*/
)brace
suffix:semicolon
multiline_comment|/*&n;  Read the super block of an Extended MS-DOS FS.&n;*/
DECL|function|UMSDOS_read_super
r_struct
id|super_block
op_star
id|UMSDOS_read_super
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_void
op_star
id|data
comma
r_int
id|silent
)paren
(brace
multiline_comment|/* #Specification: mount / options&n;     Umsdos run on top of msdos. Currently, it supports no&n;     mount option, but happily pass all option received to&n;     the msdos driver. I am not sure if all msdos mount option&n;     make sense with Umsdos. Here are at least those who&n;     are useful.&n;     uid=&n;     gid=&n;     &n;     These options affect the operation of umsdos in directories&n;     which do not have an EMD file. They behave like normal&n;     msdos directory, with all limitation of msdos.&n;  */
r_struct
id|super_block
op_star
id|res
suffix:semicolon
r_struct
id|inode
op_star
id|pseudo
op_assign
l_int|NULL
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS /mn/: starting UMSDOS_read_super&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS /mn/: sb = %p&bslash;n&quot;
comma
id|sb
)paren
)paren
suffix:semicolon
id|res
op_assign
id|msdos_read_super
c_func
(paren
id|sb
comma
id|data
comma
id|silent
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS /mn/: res = %p&bslash;n&quot;
comma
id|res
)paren
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;UMSDOS dentry-WIP-Beta 0.82-3 (compatibility level %d.%d, fast msdos)&bslash;n&quot;
comma
id|UMSDOS_VERSION
comma
id|UMSDOS_RELEASE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
l_int|NULL
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|MSDOS_SB
c_func
(paren
id|res
)paren
op_member_access_from_pointer
id|options.dotsOK
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* disable hidden==dotfile */
id|res-&gt;s_op
op_assign
op_amp
id|umsdos_sops
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos /mn/: here goes the iget ROOT_INO&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|pseudo
op_assign
id|iget
c_func
(paren
id|res
comma
id|UMSDOS_ROOT_INO
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_read_super %p&bslash;n&quot;
comma
id|pseudo
)paren
)paren
suffix:semicolon
id|umsdos_setup_dir_inode
(paren
id|pseudo
)paren
suffix:semicolon
macro_line|#if 0&t;/* disabled /mn/ test FIXME */    
multiline_comment|/* if (s == super_blocks){ FIXME, super_blocks no longer exported */
r_if
c_cond
(paren
id|pseudo
)paren
(brace
multiline_comment|/* #Specification: pseudo root / mount&n;&t; When a umsdos fs is mounted, a special handling is done&n;&t; if it is the root partition. We check for the presence&n;&t; of the file /linux/etc/init or /linux/etc/rc or&n;&t; /linux/sbin/init. If one is there, we do a chroot(&quot;/linux&quot;).&n;&t; &n;&t; We check both because (see init/main.c) the kernel&n;&t; try to exec init at different place and if it fails&n;&t; it tries /bin/sh /etc/rc. To be consistent with&n;&t; init/main.c, many more test would have to be done&n;&t; to locate init. Any complain ?&n;&t; &n;&t; The chroot is done manually in init/main.c but the&n;&t; info (the inode) is located at mount time and store&n;&t; in a global variable (pseudo_root) which is used at&n;&t; different place in the umsdos driver. There is no&n;&t; need to store this variable elsewhere because it&n;&t; will always be one, not one per mount.&n;&t; &n;&t; This feature allows the installation&n;&t; of a linux system within a DOS system in a subdirectory.&n;&t; &n;&t; A user may install its linux stuff in c:&bslash;linux&n;&t; avoiding any clash with existing DOS file and subdirectory.&n;&t; When linux boots, it hides this fact, showing a normal&n;&t; root directory with /etc /bin /tmp ...&n;&t; &n;&t; The word &quot;linux&quot; is hardcoded in /usr/include/linux/umsdos_fs.h&n;&t; in the macro UMSDOS_PSDROOT_NAME.&n;      */
r_struct
id|dentry
op_star
id|root
comma
op_star
id|etc
comma
op_star
id|etc_rc
comma
op_star
id|init
comma
op_star
id|sbin
suffix:semicolon
id|root
op_assign
id|creat_dentry
(paren
id|UMSDOS_PSDROOT_NAME
comma
id|strlen
c_func
(paren
id|UMSDOS_PSDROOT_NAME
)paren
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|sbin
op_assign
id|creat_dentry
(paren
l_string|&quot;sbin&quot;
comma
l_int|4
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;Mounting root&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_real_lookup
(paren
id|pseudo
comma
id|root
)paren
op_eq
l_int|0
op_logical_and
(paren
id|root-&gt;d_inode
op_ne
l_int|NULL
)paren
op_logical_and
id|S_ISDIR
c_func
(paren
id|root-&gt;d_inode-&gt;i_mode
)paren
)paren
(brace
r_int
id|pseudo_ok
op_assign
l_int|0
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;/%s is there&bslash;n&quot;
comma
id|UMSDOS_PSDROOT_NAME
)paren
)paren
suffix:semicolon
id|etc
op_assign
id|creat_dentry
(paren
l_string|&quot;etc&quot;
comma
l_int|3
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* if (umsdos_real_lookup (pseudo,&quot;etc&quot;,3,etc)==0 */
r_if
c_cond
(paren
id|umsdos_real_lookup
c_func
(paren
id|pseudo
comma
id|etc
)paren
op_eq
l_int|0
op_logical_and
id|S_ISDIR
c_func
(paren
id|etc-&gt;d_inode-&gt;i_mode
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;/%s/etc is there&bslash;n&quot;
comma
id|UMSDOS_PSDROOT_NAME
)paren
)paren
suffix:semicolon
id|init
op_assign
id|creat_dentry
(paren
l_string|&quot;init&quot;
comma
l_int|4
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|etc_rc
op_assign
id|creat_dentry
(paren
l_string|&quot;rc&quot;
comma
l_int|2
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* if ((umsdos_real_lookup (etc,&quot;init&quot;,4,init)==0*/
r_if
c_cond
(paren
(paren
id|umsdos_real_lookup
c_func
(paren
id|pseudo
comma
id|init
)paren
op_eq
l_int|0
op_logical_and
id|S_ISREG
c_func
(paren
id|init-&gt;d_inode-&gt;i_mode
)paren
)paren
multiline_comment|/*&t;|| (umsdos_real_lookup (etc,&quot;rc&quot;,2,&amp;rc)==0*/
op_logical_or
(paren
id|umsdos_real_lookup
c_func
(paren
id|pseudo
comma
id|etc_rc
)paren
op_eq
l_int|0
op_logical_and
id|S_ISREG
c_func
(paren
id|etc_rc-&gt;d_inode-&gt;i_mode
)paren
)paren
)paren
(brace
id|pseudo_ok
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* FIXME !!!!!! */
multiline_comment|/* iput(init); */
multiline_comment|/* iput(rc); */
)brace
r_if
c_cond
(paren
op_logical_neg
id|pseudo_ok
multiline_comment|/* &amp;&amp; umsdos_real_lookup (pseudo, &quot;sbin&quot;, 4, sbin)==0*/
op_logical_and
id|umsdos_real_lookup
c_func
(paren
id|pseudo
comma
id|sbin
)paren
op_eq
l_int|0
op_logical_and
id|S_ISDIR
c_func
(paren
id|sbin-&gt;d_inode-&gt;i_mode
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;/%s/sbin is there&bslash;n&quot;
comma
id|UMSDOS_PSDROOT_NAME
)paren
)paren
suffix:semicolon
multiline_comment|/* if (umsdos_real_lookup (sbin,&quot;init&quot;,4,init)==0 */
r_if
c_cond
(paren
id|umsdos_real_lookup
c_func
(paren
id|pseudo
comma
id|init
)paren
op_eq
l_int|0
op_logical_and
id|S_ISREG
c_func
(paren
id|init-&gt;d_inode-&gt;i_mode
)paren
)paren
(brace
id|pseudo_ok
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* FIXME !!! &n;&t;     iput (init); */
)brace
r_if
c_cond
(paren
id|pseudo_ok
)paren
(brace
id|umsdos_setup_dir_inode
(paren
id|pseudo
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_INFO
l_string|&quot;Activating pseudo root /%s&bslash;n&quot;
comma
id|UMSDOS_PSDROOT_NAME
)paren
)paren
suffix:semicolon
id|pseudo_root
op_assign
id|pseudo
suffix:semicolon
id|pseudo-&gt;i_count
op_increment
suffix:semicolon
id|pseudo
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* FIXME &n;&t;&n;&t;iput (sbin);&n;&t;iput (etc);&n;&t;*/
)brace
id|Printk
(paren
(paren
id|KERN_WARNING
l_string|&quot;umsdos_read_super /mn/: Pseudo should be iput-ed here...&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* iput (pseudo); / * FIXME */
)brace
macro_line|#endif /* disabled */
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_read_super /mn/: returning %p&bslash;n&quot;
comma
id|res
)paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|variable|umsdos_fs_type
r_static
r_struct
id|file_system_type
id|umsdos_fs_type
op_assign
(brace
l_string|&quot;umsdos&quot;
comma
id|FS_REQUIRES_DEV
comma
id|UMSDOS_read_super
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_int
id|init_umsdos_fs
c_func
(paren
r_void
)paren
)paren
(brace
r_return
id|register_filesystem
c_func
(paren
op_amp
id|umsdos_fs_type
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|EXPORT_NO_SYMBOLS
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|init_umsdos_fs
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|unregister_filesystem
c_func
(paren
op_amp
id|umsdos_fs_type
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
