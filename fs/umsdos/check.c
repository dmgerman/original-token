multiline_comment|/*&n; * linux/fs/umsdos/check.c&n; *&n; * Sanity-checking code&n; */
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#ifdef CHECK_PAGE_TABLES
DECL|function|check_one_table
r_static
r_int
id|check_one_table
(paren
r_struct
id|pde
op_star
id|page_dir
)paren
(brace
r_if
c_cond
(paren
id|pgd_none
(paren
op_star
id|page_dir
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pgd_bad
(paren
op_star
id|page_dir
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function checks all page tables of &quot;current&quot;&n; */
DECL|function|check_page_tables
r_void
id|check_page_tables
(paren
r_void
)paren
(brace
r_struct
id|pgd
op_star
id|pg_dir
suffix:semicolon
r_static
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|stack_level
op_assign
(paren
r_int
)paren
(paren
op_amp
id|pg_dir
)paren
op_minus
id|current-&gt;kernel_stack_page
suffix:semicolon
r_if
c_cond
(paren
id|stack_level
OL
l_int|1500
)paren
id|printk
(paren
l_string|&quot;** %d ** &quot;
comma
id|stack_level
)paren
suffix:semicolon
id|pg_dir
op_assign
id|PAGE_DIR_OFFSET
(paren
id|current
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PTRS_PER_PAGE
suffix:semicolon
id|i
op_increment
comma
id|page_dir
op_increment
)paren
(brace
r_int
id|notok
op_assign
id|check_one_table
(paren
id|page_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|notok
)paren
(brace
id|err
op_increment
suffix:semicolon
id|printk
(paren
l_string|&quot;|%d:%08lx| &quot;
comma
id|i
comma
id|page_dir-&gt;pgd
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|err
)paren
id|printk
(paren
l_string|&quot;&bslash;nError MM %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#if UMS_DEBUG
multiline_comment|/*&n; * check a superblock&n; */
DECL|function|check_sb
r_void
id|check_sb
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_const
r_char
id|c
)paren
(brace
r_if
c_cond
(paren
id|sb
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (has %c_sb=%d, %d)&quot;
comma
id|c
comma
id|MAJOR
(paren
id|sb-&gt;s_dev
)paren
comma
id|MINOR
(paren
id|sb-&gt;s_dev
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
l_string|&quot; (%c_sb is NULL)&quot;
comma
id|c
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * check an inode&n; */
DECL|function|check_inode
r_void
id|check_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
id|inode
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*   inode is %lu (i_count=%d)&quot;
comma
id|inode-&gt;i_ino
comma
id|inode-&gt;i_count
)paren
)paren
suffix:semicolon
id|check_sb
(paren
id|inode-&gt;i_sb
comma
l_char|&squot;i&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_dentry.next
)paren
(brace
multiline_comment|/* FIXME: does this work ? */
id|Printk
(paren
(paren
l_string|&quot; (has i_dentry)&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
l_string|&quot; (NO i_dentry)&quot;
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
l_int|NULL
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is NULL)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
op_amp
id|umsdos_dir_inode_operations
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is umsdos_dir_inode_operations)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
op_amp
id|umsdos_file_inode_operations
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is umsdos_file_inode_operations)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
op_amp
id|umsdos_file_inode_operations_no_bmap
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is umsdos_file_inode_operations_no_bmap)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
op_amp
id|umsdos_file_inode_operations_readpage
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is umsdos_file_inode_operations_readpage)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
op_amp
id|umsdos_rdir_inode_operations
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is umsdos_rdir_inode_operations)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|inode-&gt;i_op
op_eq
op_amp
id|umsdos_symlink_inode_operations
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is umsdos_symlink_inode_operations)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
l_string|&quot; (i_op is UNKNOWN: %p)&bslash;n&quot;
comma
id|inode-&gt;i_op
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*   inode is NULL&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * checks all inode-&gt;i_dentry&n; *&n; */
DECL|function|checkd_inode
r_void
id|checkd_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|dentry
op_star
id|ret
suffix:semicolon
r_struct
id|list_head
op_star
id|cur
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;checkd_inode: inode is NULL!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;checkd_inode:  inode %lu&bslash;n&quot;
comma
id|inode-&gt;i_ino
)paren
)paren
suffix:semicolon
id|cur
op_assign
id|inode-&gt;i_dentry.next
suffix:semicolon
r_while
c_loop
(paren
id|count
op_increment
OL
l_int|10
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;1...&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cur
)paren
(brace
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;checkd_inode: *** NULL reached. exit.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|PRINTK
(paren
(paren
l_string|&quot;2...&quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|list_entry
(paren
id|cur
comma
r_struct
id|dentry
comma
id|d_alias
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;3...&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_eq
id|cur-&gt;next
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;checkd_inode: *** cur=cur-&gt;next: normal exit.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|PRINTK
(paren
(paren
l_string|&quot;4...&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;checkd_inode: *** ret dentry is NULL. exit.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|PRINTK
(paren
(paren
l_string|&quot;5... (ret=%p)...&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;5.1.. (ret-&gt;d_dname=%p)...&quot;
comma
op_amp
(paren
id|ret-&gt;d_name
)paren
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;5.1.1. (ret-&gt;d_dname.len=%d)...&quot;
comma
(paren
r_int
)paren
id|ret-&gt;d_name.len
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;5.1.2. (ret-&gt;d_dname.name=%c)...&quot;
comma
id|ret-&gt;d_name.name
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;checkd_inode:   i_dentry is %.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|ret-&gt;d_name.len
comma
id|ret-&gt;d_name.name
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;6...&quot;
)paren
)paren
suffix:semicolon
id|cur
op_assign
id|cur-&gt;next
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;7...&quot;
)paren
)paren
suffix:semicolon
macro_line|#if 1
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;checkd_inode: *** finished after count 1 (operator forced)&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif&t;&t;
)brace
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;checkd_inode: *** OVER LIMIT (loop?) !&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * internal part of check_dentry. does the real job.&n; *&n; */
DECL|function|check_dent_int
r_void
id|check_dent_int
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|parent
)paren
(brace
r_if
c_cond
(paren
id|parent
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*  parent(%d) dentry: %.*s&bslash;n&quot;
comma
id|parent
comma
(paren
r_int
)paren
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*  checking dentry: %.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
)brace
id|check_inode
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*   d_count=%d&quot;
comma
id|dentry-&gt;d_count
)paren
)paren
suffix:semicolon
id|check_sb
(paren
id|dentry-&gt;d_sb
comma
l_char|&squot;d&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_op
op_eq
l_int|NULL
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; (d_op is NULL)&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
l_string|&quot; (d_op is UNKNOWN: %p)&bslash;n&quot;
comma
id|dentry-&gt;d_op
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * checks dentry with full traceback to root and prints info. Limited to 10 recursive depths to avoid infinite loops.&n; *&n; */
DECL|function|check_dentry_path
r_void
id|check_dentry_path
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|desc
)paren
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*** check_dentry_path: %.60s&bslash;n&quot;
comma
id|desc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*** checking dentry... it is NULL !&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*** checking dentry... it is ERR(%ld) !&bslash;n&quot;
comma
id|PTR_ERR
c_func
(paren
id|dentry
)paren
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dentry
op_logical_and
id|count
OL
l_int|10
)paren
(brace
id|check_dent_int
(paren
id|dentry
comma
id|count
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
op_eq
id|dentry-&gt;d_parent
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;*** end checking dentry (root reached ok)&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dentry
op_assign
id|dentry-&gt;d_parent
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_ge
l_int|10
)paren
(brace
multiline_comment|/* if infinite loop detected */
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;*** WARNING ! INFINITE LOOP ! check_dentry_path aborted !&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
(brace
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;*** WARNING ! NULL dentry ! check_dentry_path aborted !&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
DECL|function|check_sb
r_void
id|check_sb
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_const
r_char
id|c
)paren
(brace
)brace
suffix:semicolon
DECL|function|check_inode
r_void
id|check_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
)brace
suffix:semicolon
DECL|function|checkd_inode
r_void
id|checkd_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
)brace
suffix:semicolon
DECL|function|check_dentry_path
r_void
id|check_dentry_path
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|desc
)paren
(brace
)brace
suffix:semicolon
macro_line|#endif&t;/* UMS_DEBUG */
eof
