multiline_comment|/*&n; *  linux/fs/umsdos/namei.c&n; *&n; *&t;Written 1993 by Jacques Gelinas &n; *&t;Inspired from linux/fs/msdos/... by Werner Almesberger&n; *&n; * Maintain and access the --linux alternate directory file.&n;*/
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/msdos_fs.h&gt;
macro_line|#include &lt;linux/umsdos_fs.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x)
DECL|macro|Printk
mdefine_line|#define Printk(x)&t;printk x
macro_line|#if 1
multiline_comment|/*&n;&t;Wait for creation exclusivity.&n;&t;Return 0 if the dir was already available.&n;&t;Return 1 if a wait was necessary.&n;&t;&t;When 1 is return, it means a wait was done. It does not&n;&t;&t;mean the directory is available.&n;*/
DECL|function|umsdos_waitcreate
r_static
r_int
id|umsdos_waitcreate
c_func
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.u.dir_info.creating
op_logical_and
id|dir-&gt;u.umsdos_i.u.dir_info.pid
op_ne
id|current-&gt;pid
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|dir-&gt;u.umsdos_i.u.dir_info.p
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Wait for any lookup process to finish&n;*/
DECL|function|umsdos_waitlookup
r_static
r_void
id|umsdos_waitlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
r_while
c_loop
(paren
id|dir-&gt;u.umsdos_i.u.dir_info.looking
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|dir-&gt;u.umsdos_i.u.dir_info.p
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;Lock all other process out of this directory.&n;*/
DECL|function|umsdos_lockcreate
r_void
id|umsdos_lockcreate
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
multiline_comment|/* #Specification: file creation / not atomic&n;&t;&t;File creation is a two step process. First we create (allocate)&n;&t;&t;an entry in the EMD file and then (using the entry offset) we&n;&t;&t;build a unique name for MSDOS. We create this name in the msdos&n;&t;&t;space.&n;&n;&t;&t;We have to use semaphore (sleep_on/wake_up) to prevent lookup&n;&t;&t;into a directory when we create a file or directory and to&n;&t;&t;prevent creation while a lookup is going on. Since many lookup&n;&t;&t;may happen at the same time, the semaphore is a counter.&n;&n;&t;&t;Only one creation is allowed at the same time. This protection&n;&t;&t;may not be necessary. The problem arise mainly when a lookup&n;&t;&t;or a readdir is done while a file is partially created. The&n;&t;&t;lookup process see that as a &quot;normal&quot; problem and silently&n;&t;&t;erase the file from the EMD file. Normal because a file&n;&t;&t;may be erased during a MSDOS session, but not removed from&n;&t;&t;the EMD file.&n;&n;&t;&t;The locking is done on a directory per directory basis. Each&n;&t;&t;directory inode has its wait_queue.&n;&n;&t;&t;For some operation like hard link, things even get worse. Many&n;&t;&t;creation must occur at once (atomic). To simplify the design&n;&t;&t;a process is allowed to recursively lock the directory for&n;&t;&t;creation. The pid of the locking process is kept along with&n;&t;&t;a counter so a second level of locking is granted or not.&n;&t;*/
multiline_comment|/*&n;&t;&t;Wait for any creation process to finish except&n;&t;&t;if we (the process) own the lock&n;&t;*/
r_while
c_loop
(paren
id|umsdos_waitcreate
c_func
(paren
id|dir
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|dir-&gt;u.umsdos_i.u.dir_info.creating
op_increment
suffix:semicolon
id|dir-&gt;u.umsdos_i.u.dir_info.pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|umsdos_waitlookup
(paren
id|dir
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Lock all other process out of those two directories.&n;*/
DECL|function|umsdos_lockcreate2
r_static
r_void
id|umsdos_lockcreate2
(paren
r_struct
id|inode
op_star
id|dir1
comma
r_struct
id|inode
op_star
id|dir2
)paren
(brace
multiline_comment|/*&n;&t;&t;We must check that both directory are available before&n;&t;&t;locking anyone of them. This is to avoid some deadlock.&n;&t;&t;Thanks to dglaude@is1.vub.ac.be (GLAUDE DAVID) for pointing&n;&t;&t;this to me.&n;&t;*/
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|umsdos_waitcreate
c_func
(paren
id|dir1
)paren
op_eq
l_int|0
op_logical_and
id|umsdos_waitcreate
c_func
(paren
id|dir2
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We own both now */
id|dir1-&gt;u.umsdos_i.u.dir_info.creating
op_increment
suffix:semicolon
id|dir1-&gt;u.umsdos_i.u.dir_info.pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|dir2-&gt;u.umsdos_i.u.dir_info.creating
op_increment
suffix:semicolon
id|dir2-&gt;u.umsdos_i.u.dir_info.pid
op_assign
id|current-&gt;pid
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|umsdos_waitlookup
c_func
(paren
id|dir1
)paren
suffix:semicolon
id|umsdos_waitlookup
c_func
(paren
id|dir2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Wait until creation is finish in this directory.&n;*/
DECL|function|umsdos_startlookup
r_void
id|umsdos_startlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
r_while
c_loop
(paren
id|umsdos_waitcreate
(paren
id|dir
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|dir-&gt;u.umsdos_i.u.dir_info.looking
op_increment
suffix:semicolon
)brace
r_void
id|check_page_tables
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n;&t;Unlock the directory.&n;*/
DECL|function|umsdos_unlockcreate
r_void
id|umsdos_unlockcreate
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
id|dir-&gt;u.umsdos_i.u.dir_info.creating
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.u.dir_info.creating
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: dir-&gt;u.umsdos_i.u.dir_info.creating &lt; 0: %d&quot;
comma
id|dir-&gt;u.umsdos_i.u.dir_info.creating
)paren
suffix:semicolon
)brace
id|wake_up
(paren
op_amp
id|dir-&gt;u.umsdos_i.u.dir_info.p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Tell directory lookup is over.&n;*/
DECL|function|umsdos_endlookup
r_void
id|umsdos_endlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
id|dir-&gt;u.umsdos_i.u.dir_info.looking
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.u.dir_info.looking
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: dir-&gt;u.umsdos_i.u.dir_info.looking &lt; 0: %d&quot;
comma
id|dir-&gt;u.umsdos_i.u.dir_info.looking
)paren
suffix:semicolon
)brace
id|wake_up
(paren
op_amp
id|dir-&gt;u.umsdos_i.u.dir_info.p
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|umsdos_lockcreate
r_static
r_void
id|umsdos_lockcreate
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
)brace
DECL|function|umsdos_lockcreate2
r_static
r_void
id|umsdos_lockcreate2
(paren
r_struct
id|inode
op_star
id|dir1
comma
r_struct
id|inode
op_star
id|dir2
)paren
(brace
)brace
DECL|function|umsdos_startlookup
r_void
id|umsdos_startlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
)brace
DECL|function|umsdos_unlockcreate
r_static
r_void
id|umsdos_unlockcreate
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
)brace
DECL|function|umsdos_endlookup
r_void
id|umsdos_endlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
)brace
macro_line|#endif
DECL|function|umsdos_nevercreat
r_static
r_int
id|umsdos_nevercreat
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
multiline_comment|/* Name of the file to add */
r_int
id|len
comma
r_int
id|errcod
)paren
multiline_comment|/* Length of the name */
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_is_pseudodos
c_func
(paren
id|dir
comma
id|name
comma
id|len
)paren
)paren
(brace
multiline_comment|/* #Specification: pseudo root / any file creation /DOS&n;&t;&t;&t;The pseudo sub-directory /DOS can&squot;t be created!&n;&t;&t;&t;EEXIST is returned.&n;&n;&t;&t;&t;The pseudo sub-directory /DOS can&squot;t be removed!&n;&t;&t;&t;EPERM is returned.&n;&t;&t;*/
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
id|ret
op_assign
id|errcod
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
(paren
id|len
op_eq
l_int|1
op_logical_or
(paren
id|len
op_eq
l_int|2
op_logical_and
id|name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
)paren
)paren
(brace
multiline_comment|/* #Specification: create / . and ..&n;&t;&t;&t;If one try to creates . or .., it always fail and return&n;&t;&t;&t;EEXIST.&n;&n;&t;&t;&t;If one try to delete . or .., it always fail and return&n;&t;&t;&t;EPERM.&n;&n;&t;&t;&t;This should be test at the VFS layer level to avoid&n;&t;&t;&t;duplicating this in all file systems. Any comments ?&n;&t;&t;*/
id|ret
op_assign
id|errcod
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Add a new file (ordinary or special) into the alternate directory.&n;&t;The file is added to the real MSDOS directory. If successful, it&n;&t;is then added to the EDM file.&n;&n;&t;Return the status of the operation. 0 mean success.&n;*/
DECL|function|umsdos_create_any
r_static
r_int
id|umsdos_create_any
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
multiline_comment|/* Name of the file to add */
r_int
id|len
comma
multiline_comment|/* Length of the name */
r_int
id|mode
comma
multiline_comment|/* Permission bit + file type ??? */
r_int
id|rdev
comma
multiline_comment|/* major, minor or 0 for ordinary file */
multiline_comment|/* and symlinks */
r_char
id|flags
comma
r_struct
id|inode
op_star
op_star
id|result
)paren
multiline_comment|/* Will hold the inode of the newly created */
multiline_comment|/* file */
(brace
r_int
id|ret
op_assign
id|umsdos_nevercreat
c_func
(paren
id|dir
comma
id|name
comma
id|len
comma
op_minus
id|EEXIST
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|ret
op_assign
id|umsdos_parse
(paren
id|name
comma
id|len
comma
op_amp
id|info
)paren
suffix:semicolon
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|info.entry.mode
op_assign
id|mode
suffix:semicolon
id|info.entry.rdev
op_assign
id|rdev
suffix:semicolon
id|info.entry.flags
op_assign
id|flags
suffix:semicolon
id|info.entry.uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|info.entry.gid
op_assign
(paren
id|dir-&gt;i_mode
op_amp
id|S_ISGID
)paren
ques
c_cond
id|dir-&gt;i_gid
suffix:colon
id|current-&gt;fsgid
suffix:semicolon
id|info.entry.ctime
op_assign
id|info.entry.atime
op_assign
id|info.entry.mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|info.entry.nlink
op_assign
l_int|1
suffix:semicolon
id|umsdos_lockcreate
c_func
(paren
id|dir
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_newentry
(paren
id|dir
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|msdos_create
(paren
id|dir
comma
id|info.fake.fname
comma
id|info.fake.len
comma
id|S_IFREG
op_or
l_int|0777
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
op_star
id|result
suffix:semicolon
id|umsdos_lookup_patch
(paren
id|dir
comma
id|inode
comma
op_amp
id|info.entry
comma
id|info.f_pos
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;inode %p[%d] &quot;
comma
id|inode
comma
id|inode-&gt;i_count
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;Creation OK: [%d] %s %d pos %d&bslash;n&quot;
comma
id|dir-&gt;i_ino
comma
id|info.fake.fname
comma
id|current-&gt;pid
comma
id|info.f_pos
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* #Specification: create / file exist in DOS&n;&t;&t;&t;&t;&t;&t;Here is a situation. Trying to create a file with&n;&t;&t;&t;&t;&t;&t;UMSDOS. The file is unknown to UMSDOS but already&n;&t;&t;&t;&t;&t;&t;exist in the DOS directory.&n;&n;&t;&t;&t;&t;&t;&t;Here is what we are NOT doing:&n;&n;&t;&t;&t;&t;&t;&t;We could silently assume that everything is fine&n;&t;&t;&t;&t;&t;&t;and allows the creation to succeed.&n;&n;&t;&t;&t;&t;&t;&t;It is possible not all files in the partition&n;&t;&t;&t;&t;&t;&t;are mean to be visible from linux. By trying to create&n;&t;&t;&t;&t;&t;&t;those file in some directory, one user may get access&n;&t;&t;&t;&t;&t;&t;to those file without proper permissions. Looks like&n;&t;&t;&t;&t;&t;&t;a security hole to me. Off course sharing a file system&n;&t;&t;&t;&t;&t;&t;with DOS is some kind of security hole :-)&n;&n;&t;&t;&t;&t;&t;&t;So ?&n;&n;&t;&t;&t;&t;&t;&t;We return EEXIST in this case.&n;&t;&t;&t;&t;&t;&t;The same is true for directory creation.&n;&t;&t;&t;&t;&t;*/
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EEXIST
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: out of sync, Creation error [%ld], &quot;
l_string|&quot;deleting %s %d %d pos %ld&bslash;n&quot;
comma
id|dir-&gt;i_ino
comma
id|info.fake.fname
comma
op_minus
id|ret
comma
id|current-&gt;pid
comma
id|info.f_pos
)paren
suffix:semicolon
)brace
id|umsdos_delentry
(paren
id|dir
comma
op_amp
id|info
comma
l_int|0
)paren
suffix:semicolon
)brace
id|PRINTK
(paren
(paren
l_string|&quot;umsdos_create %s ret = %d pos %d&bslash;n&quot;
comma
id|info.fake.fname
comma
id|ret
comma
id|info.f_pos
)paren
)paren
suffix:semicolon
)brace
id|umsdos_unlockcreate
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
)brace
id|iput
(paren
id|dir
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Initialise the new_entry from the old for a rename operation.&n;&t;(Only useful for umsdos_rename_f() below).&n;*/
DECL|function|umsdos_ren_init
r_static
r_void
id|umsdos_ren_init
c_func
(paren
r_struct
id|umsdos_info
op_star
id|new_info
comma
r_struct
id|umsdos_info
op_star
id|old_info
comma
r_int
id|flags
)paren
multiline_comment|/* 0 == copy flags from old_name */
multiline_comment|/* != 0, this is the value of flags */
(brace
id|new_info-&gt;entry.mode
op_assign
id|old_info-&gt;entry.mode
suffix:semicolon
id|new_info-&gt;entry.rdev
op_assign
id|old_info-&gt;entry.rdev
suffix:semicolon
id|new_info-&gt;entry.uid
op_assign
id|old_info-&gt;entry.uid
suffix:semicolon
id|new_info-&gt;entry.gid
op_assign
id|old_info-&gt;entry.gid
suffix:semicolon
id|new_info-&gt;entry.ctime
op_assign
id|old_info-&gt;entry.ctime
suffix:semicolon
id|new_info-&gt;entry.atime
op_assign
id|old_info-&gt;entry.atime
suffix:semicolon
id|new_info-&gt;entry.mtime
op_assign
id|old_info-&gt;entry.mtime
suffix:semicolon
id|new_info-&gt;entry.flags
op_assign
id|flags
ques
c_cond
id|flags
suffix:colon
id|old_info-&gt;entry.flags
suffix:semicolon
id|new_info-&gt;entry.nlink
op_assign
id|old_info-&gt;entry.nlink
suffix:semicolon
)brace
DECL|macro|chkstk
mdefine_line|#define chkstk() &bslash;&n;&t;if (STACK_MAGIC != *(unsigned long *)current-&gt;kernel_stack_page){&bslash;&n;&t;&t;printk(KERN_ALERT &quot;UMSDOS: %s magic %x != %lx ligne %d&bslash;n&quot; &bslash;&n;&t;&t;, current-&gt;comm,STACK_MAGIC &bslash;&n;&t;&t;,*(unsigned long *)current-&gt;kernel_stack_page &bslash;&n;&t;&t;,__LINE__); &bslash;&n;&t;}
multiline_comment|/*&n;&t;Rename a file (move) in the file system.&n;*/
DECL|function|umsdos_rename_f
r_static
r_int
id|umsdos_rename_f
c_func
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_const
r_char
op_star
id|old_name
comma
r_int
id|old_len
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_const
r_char
op_star
id|new_name
comma
r_int
id|new_len
comma
r_int
id|flags
)paren
multiline_comment|/* 0 == copy flags from old_name */
multiline_comment|/* != 0, this is the value of flags */
(brace
r_int
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_struct
id|umsdos_info
id|old_info
suffix:semicolon
r_int
id|old_ret
op_assign
id|umsdos_parse
(paren
id|old_name
comma
id|old_len
comma
op_amp
id|old_info
)paren
suffix:semicolon
r_struct
id|umsdos_info
id|new_info
suffix:semicolon
r_int
id|new_ret
op_assign
id|umsdos_parse
(paren
id|new_name
comma
id|new_len
comma
op_amp
id|new_info
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;umsdos_rename %d %d &quot;
comma
id|old_ret
comma
id|new_ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_ret
op_eq
l_int|0
op_logical_and
id|new_ret
op_eq
l_int|0
)paren
(brace
id|umsdos_lockcreate2
c_func
(paren
id|old_dir
comma
id|new_dir
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;old findentry &quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_findentry
c_func
(paren
id|old_dir
comma
op_amp
id|old_info
comma
l_int|0
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;ret %d &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/* check sticky bit on old_dir */
r_if
c_cond
(paren
op_logical_neg
(paren
id|old_dir-&gt;i_mode
op_amp
id|S_ISVTX
)paren
op_logical_or
id|fsuser
c_func
(paren
)paren
op_logical_or
id|current-&gt;fsuid
op_eq
id|old_info.entry.uid
op_logical_or
id|current-&gt;fsuid
op_eq
id|old_dir-&gt;i_uid
)paren
(brace
multiline_comment|/* Does new_name already exist? */
id|PRINTK
c_func
(paren
(paren
l_string|&quot;new findentry &quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_findentry
c_func
(paren
id|new_dir
comma
op_amp
id|new_info
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
op_logical_or
multiline_comment|/* if destination file exists, are we allowed to replace it ? */
op_logical_neg
(paren
id|new_dir-&gt;i_mode
op_amp
id|S_ISVTX
)paren
op_logical_or
id|fsuser
c_func
(paren
)paren
op_logical_or
id|current-&gt;fsuid
op_eq
id|new_info.entry.uid
op_logical_or
id|current-&gt;fsuid
op_eq
id|new_dir-&gt;i_uid
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;new newentry &quot;
)paren
)paren
suffix:semicolon
id|umsdos_ren_init
c_func
(paren
op_amp
id|new_info
comma
op_amp
id|old_info
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_newentry
(paren
id|new_dir
comma
op_amp
id|new_info
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;ret %d %d &quot;
comma
id|ret
comma
id|new_info.fake.len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;msdos_rename &quot;
)paren
)paren
suffix:semicolon
id|old_dir-&gt;i_count
op_increment
suffix:semicolon
id|new_dir-&gt;i_count
op_increment
suffix:semicolon
multiline_comment|/* Both inode are needed later */
id|ret
op_assign
id|msdos_rename
(paren
id|old_dir
comma
id|old_info.fake.fname
comma
id|old_info.fake.len
comma
id|new_dir
comma
id|new_info.fake.fname
comma
id|new_info.fake.len
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;after m_rename ret %d &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|umsdos_delentry
(paren
id|new_dir
comma
op_amp
id|new_info
comma
id|S_ISDIR
c_func
(paren
id|new_info.entry.mode
)paren
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
id|umsdos_delentry
(paren
id|old_dir
comma
op_amp
id|old_info
comma
id|S_ISDIR
c_func
(paren
id|old_info.entry.mode
)paren
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;&t;&t;   This UMSDOS_lookup does not look very useful.&n;&t;&t;&t;&t;&t;&t;&t;&t;   It makes sure that the inode of the file will&n;&t;&t;&t;&t;&t;&t;&t;&t;   be correctly setup (umsdos_patch_inode()) in&n;&t;&t;&t;&t;&t;&t;&t;&t;   case it is already in use.&n;&t;&t;&t;&t;&t;&t;&t;&t;   &n;&t;&t;&t;&t;&t;&t;&t;&t;   Not very efficient ...&n;&t;&t;&t;&t;&t;&t;&t;&t;   */
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|new_dir-&gt;i_count
op_increment
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;rename lookup len %d %d -- &quot;
comma
id|new_len
comma
id|new_info.entry.flags
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|UMSDOS_lookup
(paren
id|new_dir
comma
id|new_name
comma
id|new_len
comma
op_amp
id|inode
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: partial rename for file %s&bslash;n&quot;
comma
id|new_info.entry.name
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;   Update f_pos so notify_change will succeed&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;   if the file was already in use.&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;   */
id|umsdos_set_dirinfo
(paren
id|inode
comma
id|new_dir
comma
id|new_info.f_pos
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
id|iput
(paren
id|inode
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* sticky bit set on new_dir */
id|PRINTK
c_func
(paren
(paren
l_string|&quot;sticky set on new &quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* sticky bit set on old_dir */
id|PRINTK
c_func
(paren
(paren
l_string|&quot;sticky set on old &quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
id|umsdos_unlockcreate
c_func
(paren
id|old_dir
)paren
suffix:semicolon
id|umsdos_unlockcreate
c_func
(paren
id|new_dir
)paren
suffix:semicolon
)brace
id|iput
(paren
id|old_dir
)paren
suffix:semicolon
id|iput
(paren
id|new_dir
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Setup un Symbolic link or a (pseudo) hard link&n;&t;Return a negative error code or 0 if ok.&n;*/
DECL|function|umsdos_symlink_x
r_static
r_int
id|umsdos_symlink_x
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
r_const
r_char
op_star
id|symname
comma
multiline_comment|/* name will point to this path */
r_int
id|mode
comma
r_char
id|flags
)paren
(brace
multiline_comment|/* #Specification: symbolic links / strategy&n;&t;&t;A symbolic link is simply a file which hold a path. It is&n;&t;&t;implemented as a normal MSDOS file (not very space efficient :-()&n;&n;&t;&t;I see 2 different way to do it. One is to place the link data&n;&t;&t;in unused entry of the EMD file. The other is to have a separate&n;&t;&t;file dedicated to hold all symbolic links data.&n;&n;&t;&t;Lets go for simplicity...&n;&t;*/
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|dir-&gt;i_count
op_increment
suffix:semicolon
multiline_comment|/* We keep the inode in case we need it */
multiline_comment|/* later */
id|ret
op_assign
id|umsdos_create_any
(paren
id|dir
comma
id|name
comma
id|len
comma
id|mode
comma
l_int|0
comma
id|flags
comma
op_amp
id|inode
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;umsdos_symlink ret %d &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|symname
)paren
suffix:semicolon
r_struct
id|file
id|filp
suffix:semicolon
id|filp.f_pos
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Make the inode acceptable to MSDOS */
id|ret
op_assign
id|umsdos_file_write_kmem
(paren
id|inode
comma
op_amp
id|filp
comma
id|symname
comma
id|len
)paren
suffix:semicolon
id|iput
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ret
op_ne
id|len
)paren
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
id|printk
(paren
l_string|&quot;UMSDOS: &quot;
l_string|&quot;Can&squot;t write symbolic link data&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|UMSDOS_unlink
(paren
id|dir
comma
id|name
comma
id|len
)paren
suffix:semicolon
id|dir
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|iput
(paren
id|dir
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Setup un Symbolic link.&n;&t;Return a negative error code or 0 if ok.&n;*/
DECL|function|UMSDOS_symlink
r_int
id|UMSDOS_symlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
r_const
r_char
op_star
id|symname
)paren
multiline_comment|/* name will point to this path */
(brace
r_return
id|umsdos_symlink_x
(paren
id|dir
comma
id|name
comma
id|len
comma
id|symname
comma
id|S_IFLNK
op_or
l_int|0777
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Add a link to an inode in a directory&n;*/
DECL|function|UMSDOS_link
r_int
id|UMSDOS_link
(paren
r_struct
id|inode
op_star
id|oldinode
comma
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
multiline_comment|/* #Specification: hard link / strategy&n;&t;&t;Well ... hard link are difficult to implement on top of an&n;&t;&t;MsDOS fat file system. Unlike UNIX file systems, there are no&n;&t;&t;inode. A directory entry hold the functionality of the inode&n;&t;&t;and the entry.&n;&n;&t;&t;We will used the same strategy as a normal Unix file system&n;&t;&t;(with inode) except we will do it symbolically (using paths).&n;&n;&t;&t;Because anything can happen during a DOS session (defragment,&n;&t;&t;directory sorting, etc...), we can&squot;t rely on MsDOS pseudo&n;&t;&t;inode number to record the link. For this reason, the link&n;&t;&t;will be done using hidden symbolic links. The following&n;&t;&t;scenario illustrate how it work.&n;&t;&t;&n;&t;&t;Given a file /foo/file&n;&n;&t;&t;#&n;&t;&t;&t;ln /foo/file /tmp/file2&n;&n;&t;&t;&t;become internally&n;&n;&t;&t;&t;mv /foo/file /foo/-LINK1&n;&t;&t;&t;ln -s /foo/-LINK1 /foo/file&n;&t;&t;&t;ln -s /foo/-LINK1 /tmp/file2&n;&t;&t;#&n;&n;&t;&t;Using this strategy, we can operate on /foo/file or /foo/file2.&n;&t;&t;We can remove one and keep the other, like a normal Unix hard link.&n;&t;&t;We can rename /foo/file or /tmp/file2 independently.&n;&t;&t;&t;&n;&t;&t;The entry -LINK1 will be hidden. It will hold a link count.&n;&t;&t;When all link are erased, the hidden file is erased too.&n;&t;*/
multiline_comment|/* #Specification: weakness / hard link&n;&t;&t;The strategy for hard link introduces a side effect that&n;&t;&t;may or may not be acceptable. Here is the sequence&n;&n;&t;&t;#&n;&t;&t;mkdir subdir1&n;&t;&t;touch subdir1/file&n;&t;&t;mkdir subdir2&n;&t;&t;ln    subdir1/file subdir2/file&n;&t;&t;rm    subdir1/file&n;&t;&t;rmdir subdir1&n;&t;&t;rmdir: subdir1: Directory not empty&n;&t;&t;#&n;&n;&t;&t;This happen because there is an invisible file (--link) in&n;&t;&t;subdir1 which is referenced by subdir2/file.&n;&n;&t;&t;Any idea ?&n;&t;*/
multiline_comment|/* #Specification: weakness / hard link / rename directory&n;&t;&t;Another weakness of hard link come from the fact that&n;&t;&t;it is based on hidden symbolic links. Here is an example.&n;&n;&t;&t;#&n;&t;&t;mkdir /subdir1&n;&t;&t;touch /subdir1/file&n;&t;&t;mkdir /subdir2&n;&t;&t;ln    /subdir1/file subdir2/file&n;&t;&t;mv    /subdir1 subdir3&n;&t;&t;ls -l /subdir2/file&n;&t;&t;#&n;&n;&t;&t;Since /subdir2/file is a hidden symbolic link&n;&t;&t;to /subdir1/..hlinkNNN, accessing it will fail since&n;&t;&t;/subdir1 does not exist anymore (has been renamed).&n;&t;*/
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|oldinode-&gt;i_mode
)paren
)paren
(brace
multiline_comment|/* #Specification: hard link / directory&n;&t;&t;&t;A hard link can&squot;t be made on a directory. EPERM is returned&n;&t;&t;&t;in this case.&n;&t;&t;*/
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|umsdos_nevercreat
c_func
(paren
id|dir
comma
id|name
comma
id|len
comma
op_minus
id|EPERM
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_struct
id|inode
op_star
id|olddir
suffix:semicolon
id|ret
op_assign
id|umsdos_get_dirowner
c_func
(paren
id|oldinode
comma
op_amp
id|olddir
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;umsdos_link dir_owner = %d -&gt; %p [%d] &quot;
comma
id|oldinode-&gt;u.umsdos_i.i_dir_owner
comma
id|olddir
comma
id|olddir-&gt;i_count
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
id|umsdos_lockcreate2
c_func
(paren
id|dir
comma
id|olddir
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_inode2entry
(paren
id|olddir
comma
id|oldinode
comma
op_amp
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;umsdos_link :%s: ino %d flags %d &quot;
comma
id|entry.name
comma
id|oldinode-&gt;i_ino
comma
id|entry.flags
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry.flags
op_amp
id|UMSDOS_HIDDEN
)paren
)paren
(brace
multiline_comment|/* #Specification: hard link / first hard link&n;&t;&t;&t;&t;&t;&t;The first time a hard link is done on a file, this&n;&t;&t;&t;&t;&t;&t;file must be renamed and hidden. Then an internal&n;&t;&t;&t;&t;&t;&t;symbolic link must be done on the hidden file.&n;&n;&t;&t;&t;&t;&t;&t;The second link is done after on this hidden file.&n;&n;&t;&t;&t;&t;&t;&t;It is expected that the Linux MSDOS file system&n;&t;&t;&t;&t;&t;&t;keeps the same pseudo inode when a rename operation&n;&t;&t;&t;&t;&t;&t;is done on a file in the same directory.&n;&t;&t;&t;&t;&t;*/
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|ret
op_assign
id|umsdos_newhidden
(paren
id|olddir
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|olddir-&gt;i_count
op_add_assign
l_int|2
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;olddir[%d] &quot;
comma
id|olddir-&gt;i_count
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_rename_f
(paren
id|olddir
comma
id|entry.name
comma
id|entry.name_len
comma
id|olddir
comma
id|info.entry.name
comma
id|info.entry.name_len
comma
id|UMSDOS_HIDDEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_char
op_star
id|path
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|PATH_MAX
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|path
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
id|PRINTK
(paren
(paren
l_string|&quot;olddir[%d] &quot;
comma
id|olddir-&gt;i_count
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_locate_path
(paren
id|oldinode
comma
id|path
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;olddir[%d] &quot;
comma
id|olddir-&gt;i_count
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|olddir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|umsdos_symlink_x
(paren
id|olddir
comma
id|entry.name
comma
id|entry.name_len
comma
id|path
comma
id|S_IFREG
op_or
l_int|0777
comma
id|UMSDOS_HLINK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|umsdos_symlink_x
(paren
id|dir
comma
id|name
comma
id|len
comma
id|path
comma
id|S_IFREG
op_or
l_int|0777
comma
id|UMSDOS_HLINK
)paren
suffix:semicolon
)brace
)brace
id|kfree
(paren
id|path
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
r_char
op_star
id|path
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|PATH_MAX
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|path
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
id|umsdos_locate_path
(paren
id|oldinode
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|umsdos_symlink_x
(paren
id|dir
comma
id|name
comma
id|len
comma
id|path
comma
id|S_IFREG
op_or
l_int|0777
comma
id|UMSDOS_HLINK
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|path
)paren
suffix:semicolon
)brace
)brace
)brace
id|umsdos_unlockcreate
c_func
(paren
id|olddir
)paren
suffix:semicolon
id|umsdos_unlockcreate
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
id|iput
(paren
id|olddir
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|iattr
id|newattrs
suffix:semicolon
id|oldinode-&gt;i_nlink
op_increment
suffix:semicolon
id|newattrs.ia_valid
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|UMSDOS_notify_change
c_func
(paren
id|oldinode
comma
op_amp
id|newattrs
)paren
suffix:semicolon
)brace
id|iput
(paren
id|oldinode
)paren
suffix:semicolon
id|iput
(paren
id|dir
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;umsdos_link %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Add a new file into the alternate directory.&n;&t;The file is added to the real MSDOS directory. If successful, it&n;&t;is then added to the EDM file.&n;&n;&t;Return the status of the operation. 0 mean success.&n;*/
DECL|function|UMSDOS_create
r_int
id|UMSDOS_create
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
multiline_comment|/* Name of the file to add */
r_int
id|len
comma
multiline_comment|/* Length of the name */
r_int
id|mode
comma
multiline_comment|/* Permission bit + file type ??? */
r_struct
id|inode
op_star
op_star
id|result
)paren
multiline_comment|/* Will hold the inode of the newly created */
multiline_comment|/* file */
(brace
r_return
id|umsdos_create_any
(paren
id|dir
comma
id|name
comma
id|len
comma
id|mode
comma
l_int|0
comma
l_int|0
comma
id|result
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Add a sub-directory in a directory&n;*/
DECL|function|UMSDOS_mkdir
r_int
id|UMSDOS_mkdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
r_int
id|mode
)paren
(brace
r_int
id|ret
op_assign
id|umsdos_nevercreat
c_func
(paren
id|dir
comma
id|name
comma
id|len
comma
op_minus
id|EEXIST
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|ret
op_assign
id|umsdos_parse
(paren
id|name
comma
id|len
comma
op_amp
id|info
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;umsdos_mkdir %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|info.entry.mode
op_assign
id|mode
op_or
id|S_IFDIR
suffix:semicolon
id|info.entry.rdev
op_assign
l_int|0
suffix:semicolon
id|info.entry.uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|info.entry.gid
op_assign
(paren
id|dir-&gt;i_mode
op_amp
id|S_ISGID
)paren
ques
c_cond
id|dir-&gt;i_gid
suffix:colon
id|current-&gt;fsgid
suffix:semicolon
id|info.entry.ctime
op_assign
id|info.entry.atime
op_assign
id|info.entry.mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|info.entry.flags
op_assign
l_int|0
suffix:semicolon
id|umsdos_lockcreate
c_func
(paren
id|dir
)paren
suffix:semicolon
id|info.entry.nlink
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
id|umsdos_newentry
(paren
id|dir
comma
op_amp
id|info
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;newentry %d &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|msdos_mkdir
(paren
id|dir
comma
id|info.fake.fname
comma
id|info.fake.len
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|umsdos_delentry
(paren
id|dir
comma
op_amp
id|info
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* #Specification: mkdir / Directory already exist in DOS&n;&t;&t;&t;&t;&t;&t;We do the same thing as for file creation.&n;&t;&t;&t;&t;&t;&t;For all user it is an error.&n;&t;&t;&t;&t;&t;*/
)brace
r_else
(brace
multiline_comment|/* #Specification: mkdir / umsdos directory / create EMD&n;&t;&t;&t;&t;&t;&t;When we created a new sub-directory in a UMSDOS&n;&t;&t;&t;&t;&t;&t;directory (one with full UMSDOS semantic), we&n;&t;&t;&t;&t;&t;&t;create immediately an EMD file in the new&n;&t;&t;&t;&t;&t;&t;sub-directory so it inherit UMSDOS semantic.&n;&t;&t;&t;&t;&t;*/
r_struct
id|inode
op_star
id|subdir
suffix:semicolon
id|ret
op_assign
id|umsdos_real_lookup
(paren
id|dir
comma
id|info.fake.fname
comma
id|info.fake.len
comma
op_amp
id|subdir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|inode
op_star
id|result
suffix:semicolon
id|ret
op_assign
id|msdos_create
(paren
id|subdir
comma
id|UMSDOS_EMD_FILE
comma
id|UMSDOS_EMD_NAMELEN
comma
id|S_IFREG
op_or
l_int|0777
comma
op_amp
id|result
)paren
suffix:semicolon
id|subdir
op_assign
l_int|NULL
suffix:semicolon
id|iput
(paren
id|result
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: Can&squot;t create empty --linux-.---&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|iput
(paren
id|subdir
)paren
suffix:semicolon
)brace
)brace
id|umsdos_unlockcreate
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
)brace
id|PRINTK
(paren
(paren
l_string|&quot;umsdos_mkdir %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
id|iput
(paren
id|dir
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Add a new device special file into a directory.&n;*/
DECL|function|UMSDOS_mknod
r_int
id|UMSDOS_mknod
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
r_int
id|mode
comma
r_int
id|rdev
)paren
(brace
multiline_comment|/* #Specification: Special files / strategy&n;&t;&t;Device special file, pipes, etc ... are created like normal&n;&t;&t;file in the msdos file system. Of course they remain empty.&n;&n;&t;&t;One strategy was to create those files only in the EMD file&n;&t;&t;since they were not important for MSDOS. The problem with&n;&t;&t;that, is that there were not getting inode number allocated.&n;&t;&t;The MSDOS filesystems is playing a nice game to fake inode&n;&t;&t;number, so why not use it.&n;&n;&t;&t;The absence of inode number compatible with those allocated&n;&t;&t;for ordinary files was causing major trouble with hard link&n;&t;&t;in particular and other parts of the kernel I guess.&n;&t;*/
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|ret
op_assign
id|umsdos_create_any
(paren
id|dir
comma
id|name
comma
id|len
comma
id|mode
comma
id|rdev
comma
l_int|0
comma
op_amp
id|inode
)paren
suffix:semicolon
id|iput
(paren
id|inode
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Remove a sub-directory.&n;*/
DECL|function|UMSDOS_rmdir
r_int
id|UMSDOS_rmdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
multiline_comment|/* #Specification: style / iput strategy&n;&t;&t;In the UMSDOS project, I am trying to apply a single&n;&t;&t;programming style regarding inode management. Many&n;&t;&t;entry point are receiving an inode to act on, and must&n;&t;&t;do an iput() as soon as they are finished with&n;&t;&t;the inode.&n;&n;&t;&t;For simple case, there is no problem. When you introduce&n;&t;&t;error checking, you end up with many iput placed around the&n;&t;&t;code.&n;&n;&t;&t;The coding style I use all around is one where I am trying&n;&t;&t;to provide independent flow logic (I don&squot;t know how to&n;&t;&t;name this). With this style, code is easier to understand&n;&t;&t;but you rapidly get iput() all around. Here is an exemple&n;&t;&t;of what I am trying to avoid.&n;&n;&t;&t;#&n;&t;&t;if (a){&n;&t;&t;&t;...&n;&t;&t;&t;if(b){&n;&t;&t;&t;&t;...&n;&t;&t;&t;}&n;&t;&t;&t;...&n;&t;&t;&t;if (c){&n;&t;&t;&t;&t;// Complex state. Was b true ? &n;&t;&t;&t;&t;...&n;&t;&t;&t;}&n;&t;&t;&t;...&n;&t;&t;}&n;&t;&t;// Weird state&n;&t;&t;if (d){&n;&t;&t;&t;// ...&n;&t;&t;}&n;&t;&t;// Was iput finally done ?&n;&t;&t;return status;&n;&t;&t;#&n;&n;&t;&t;Here is the style I am using. Still sometime I do the&n;&t;&t;first when things are very simple (or very complicated :-( )&n;&n;&t;&t;#&n;&t;&t;if (a){&n;&t;&t;&t;if (b){&n;&t;&t;&t;&t;...&n;&t;&t;&t;}else if (c){&n;&t;&t;&t;&t;// A single state gets here&n;&t;&t;&t;}&n;&t;&t;}else if (d){&n;&t;&t;&t;...&n;&t;&t;}&n;&t;&t;return status;&n;&t;&t;#&n;&n;&t;&t;Again, while this help clarifying the code, I often get a lot&n;&t;&t;of iput(), unlike the first style, where I can place few &n;&t;&t;&quot;strategic&quot; iput(). &quot;strategic&quot; also mean, more difficult&n;&t;&t;to place.&n;&n;&t;&t;So here is the style I will be using from now on in this project.&n;&t;&t;There is always an iput() at the end of a function (which has&n;&t;&t;to do an iput()). One iput by inode. There is also one iput()&n;&t;&t;at the places where a successful operation is achieved. This&n;&t;&t;iput() is often done by a sub-function (often from the msdos&n;&t;&t;file system). So I get one too many iput() ? At the place&n;&t;&t;where an iput() is done, the inode is simply nulled, disabling&n;&t;&t;the last one.&n;&n;&t;&t;#&n;&t;&t;if (a){&n;&t;&t;&t;if (b){&n;&t;&t;&t;&t;...&n;&t;&t;&t;}else if (c){&n;&t;&t;&t;&t;msdos_rmdir(dir,...);&n;&t;&t;&t;&t;dir = NULL;&n;&t;&t;&t;}&n;&t;&t;}else if (d){&n;&t;&t;&t;...&n;&t;&t;}&n;&t;&t;iput (dir);&n;&t;&t;return status;&n;&t;&t;#&n;&n;&t;&t;Note that the umsdos_lockcreate() and umsdos_unlockcreate() function&n;&t;&t;pair goes against this practice of &quot;forgetting&quot; the inode as soon&n;&t;&t;as possible.&n;&t;*/
r_int
id|ret
op_assign
id|umsdos_nevercreat
c_func
(paren
id|dir
comma
id|name
comma
id|len
comma
op_minus
id|EPERM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|inode
op_star
id|sdir
suffix:semicolon
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|UMSDOS_lookup
(paren
id|dir
comma
id|name
comma
id|len
comma
op_amp
id|sdir
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;rmdir lookup %d &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_int
id|empty
suffix:semicolon
id|umsdos_lockcreate
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdir-&gt;i_count
OG
l_int|1
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|empty
op_assign
id|umsdos_isempty
(paren
id|sdir
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;isempty %d i_count %d &quot;
comma
id|empty
comma
id|sdir-&gt;i_count
)paren
)paren
suffix:semicolon
multiline_comment|/* check sticky bit */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dir-&gt;i_mode
op_amp
id|S_ISVTX
)paren
op_logical_or
id|fsuser
c_func
(paren
)paren
op_logical_or
id|current-&gt;fsuid
op_eq
id|sdir-&gt;i_uid
op_logical_or
id|current-&gt;fsuid
op_eq
id|dir-&gt;i_uid
)paren
(brace
r_if
c_cond
(paren
id|empty
op_eq
l_int|1
)paren
(brace
multiline_comment|/* We have to removed the EMD file */
id|ret
op_assign
id|msdos_unlink
c_func
(paren
id|sdir
comma
id|UMSDOS_EMD_FILE
comma
id|UMSDOS_EMD_NAMELEN
)paren
suffix:semicolon
id|sdir
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* sdir must be free before msdos_rmdir() */
id|iput
(paren
id|sdir
)paren
suffix:semicolon
id|sdir
op_assign
l_int|NULL
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;isempty ret %d nlink %d &quot;
comma
id|ret
comma
id|dir-&gt;i_nlink
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|umsdos_parse
(paren
id|name
comma
id|len
comma
op_amp
id|info
)paren
suffix:semicolon
multiline_comment|/* The findentry is there only to complete */
multiline_comment|/* the mangling */
id|umsdos_findentry
(paren
id|dir
comma
op_amp
id|info
comma
l_int|2
)paren
suffix:semicolon
id|ret
op_assign
id|msdos_rmdir
(paren
id|dir
comma
id|info.fake.fname
comma
id|info.fake.len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|umsdos_delentry
(paren
id|dir
comma
op_amp
id|info
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* sticky bit set and we don&squot;t have permission */
id|PRINTK
c_func
(paren
(paren
l_string|&quot;sticky set &quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;The subdirectory is not empty, so leave it there&n;&t;&t;&t;&t;*/
id|ret
op_assign
op_minus
id|ENOTEMPTY
suffix:semicolon
)brace
id|iput
c_func
(paren
id|sdir
)paren
suffix:semicolon
id|umsdos_unlockcreate
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
)brace
id|iput
(paren
id|dir
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;umsdos_rmdir %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Remove a file from the directory.&n;*/
DECL|function|UMSDOS_unlink
r_int
id|UMSDOS_unlink
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
r_int
id|ret
op_assign
id|umsdos_nevercreat
c_func
(paren
id|dir
comma
id|name
comma
id|len
comma
op_minus
id|EPERM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|ret
op_assign
id|umsdos_parse
(paren
id|name
comma
id|len
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|umsdos_lockcreate
c_func
(paren
id|dir
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_findentry
c_func
(paren
id|dir
comma
op_amp
id|info
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;UMSDOS_unlink %s &quot;
comma
id|info.fake.fname
)paren
)paren
suffix:semicolon
multiline_comment|/* check sticky bit */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dir-&gt;i_mode
op_amp
id|S_ISVTX
)paren
op_logical_or
id|fsuser
c_func
(paren
)paren
op_logical_or
id|current-&gt;fsuid
op_eq
id|info.entry.uid
op_logical_or
id|current-&gt;fsuid
op_eq
id|dir-&gt;i_uid
)paren
(brace
r_if
c_cond
(paren
id|info.entry.flags
op_amp
id|UMSDOS_HLINK
)paren
(brace
multiline_comment|/* #Specification: hard link / deleting a link&n;&t;&t;&t;&t;&t;&t;   When we deletes a file, and this file is a link&n;&t;&t;&t;&t;&t;&t;   we must subtract 1 to the nlink field of the&n;&t;&t;&t;&t;&t;&t;   hidden link.&n;&t;&t;&t;&t;&t;&t;   &n;&t;&t;&t;&t;&t;&t;   If the count goes to 0, we delete this hidden&n;&t;&t;&t;&t;&t;&t;   link too.&n;&t;&t;&t;&t;&t;&t;   */
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;   First, get the inode of the hidden link&n;&t;&t;&t;&t;&t;&t;   using the standard lookup function.&n;&t;&t;&t;&t;&t;&t;   */
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|UMSDOS_lookup
(paren
id|dir
comma
id|name
comma
id|len
comma
op_amp
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;unlink nlink = %d &quot;
comma
id|inode-&gt;i_nlink
)paren
)paren
suffix:semicolon
id|inode-&gt;i_nlink
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_nlink
op_eq
l_int|0
)paren
(brace
r_struct
id|inode
op_star
id|hdir
op_assign
id|iget
c_func
(paren
id|inode-&gt;i_sb
comma
id|inode-&gt;u.umsdos_i.i_dir_owner
)paren
suffix:semicolon
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
id|ret
op_assign
id|umsdos_inode2entry
(paren
id|hdir
comma
id|inode
comma
op_amp
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|UMSDOS_unlink
(paren
id|hdir
comma
id|entry.name
comma
id|entry.name_len
)paren
suffix:semicolon
)brace
r_else
(brace
id|iput
(paren
id|hdir
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_struct
id|iattr
id|newattrs
suffix:semicolon
id|newattrs.ia_valid
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|UMSDOS_notify_change
(paren
id|inode
comma
op_amp
id|newattrs
)paren
suffix:semicolon
)brace
id|iput
(paren
id|inode
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|umsdos_delentry
(paren
id|dir
comma
op_amp
id|info
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;Avant msdos_unlink %s &quot;
comma
id|info.fake.fname
)paren
)paren
suffix:semicolon
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|msdos_unlink_umsdos
(paren
id|dir
comma
id|info.fake.fname
comma
id|info.fake.len
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;msdos_unlink %s %o ret %d &quot;
comma
id|info.fake.fname
comma
id|info.entry.mode
comma
id|ret
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* sticky bit set and we&squot;ve not got permission */
id|PRINTK
c_func
(paren
(paren
l_string|&quot;sticky set &quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
id|umsdos_unlockcreate
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
)brace
id|iput
(paren
id|dir
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;umsdos_unlink %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Rename a file (move) in the file system.&n;*/
DECL|function|UMSDOS_rename
r_int
id|UMSDOS_rename
c_func
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_const
r_char
op_star
id|old_name
comma
r_int
id|old_len
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_const
r_char
op_star
id|new_name
comma
r_int
id|new_len
)paren
(brace
multiline_comment|/* #Specification: weakness / rename&n;&t;&t;There is a case where UMSDOS rename has a different behavior&n;&t;&t;than normal UNIX file system. Renaming an open file across&n;&t;&t;directory boundary does not work. Renaming an open file within&n;&t;&t;a directory does work however.&n;&n;&t;&t;The problem (not sure) is in the linux VFS msdos driver.&n;&t;&t;I believe this is not a bug but a design feature, because&n;&t;&t;an inode number represent some sort of directory address&n;&t;&t;in the MSDOS directory structure. So moving the file into&n;&t;&t;another directory does not preserve the inode number.&n;&t;*/
r_int
id|ret
op_assign
id|umsdos_nevercreat
c_func
(paren
id|new_dir
comma
id|new_name
comma
id|new_len
comma
op_minus
id|EEXIST
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/* umsdos_rename_f eat the inode and we may need those later */
id|old_dir-&gt;i_count
op_increment
suffix:semicolon
id|new_dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|umsdos_rename_f
(paren
id|old_dir
comma
id|old_name
comma
id|old_len
comma
id|new_dir
comma
id|new_name
comma
id|new_len
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EEXIST
)paren
(brace
multiline_comment|/* #Specification: rename / new name exist&n;&t;&t;&t;        If the destination name already exist, it will&n;&t;&t;&t;&t;silently be removed. EXT2 does it this way&n;&t;&t;&t;&t;and this is the spec of SUNOS. So does UMSDOS.&n;&n;&t;&t;&t;&t;If the destination is an empty directory it will&n;&t;&t;&t;&t;also be removed.&n;&t;&t;&t;*/
multiline_comment|/* #Specification: rename / new name exist / possible flaw&n;&t;&t;&t;&t;The code to handle the deletion of the target (file&n;&t;&t;&t;&t;and directory) use to be in umsdos_rename_f, surrounded&n;&t;&t;&t;&t;by proper directory locking. This was insuring that only&n;&t;&t;&t;&t;one process could achieve a rename (modification) operation&n;&t;&t;&t;&t;in the source and destination directory. This was also&n;&t;&t;&t;&t;insuring the operation was &quot;atomic&quot;.&n;&n;&t;&t;&t;&t;This has been changed because this was creating a kernel&n;&t;&t;&t;&t;stack overflow (stack is only 4k in the kernel). To avoid&n;&t;&t;&t;&t;the code doing the deletion of the target (if exist) has&n;&t;&t;&t;&t;been moved to a upper layer. umsdos_rename_f is tried&n;&t;&t;&t;&t;once and if it fails with EEXIST, the target is removed&n;&t;&t;&t;&t;and umsdos_rename_f is done again.&n;&n;&t;&t;&t;&t;This makes the code cleaner and (not sure) solve a&n;&t;&t;&t;&t;deadlock problem one tester was experiencing.&n;&n;&t;&t;&t;&t;The point is to mention that possibly, the semantic of&n;&t;&t;&t;&t;&quot;rename&quot; may be wrong. Anyone dare to check that :-)&n;&t;&t;&t;&t;Be aware that IF it is wrong, to produce the problem you&n;&t;&t;&t;&t;will need two process trying to rename a file to the&n;&t;&t;&t;&t;same target at the same time. Again, I am not sure it&n;&t;&t;&t;&t;is a problem at all.&n;&t;&t;&t;*/
multiline_comment|/* This is not super efficient but should work */
id|new_dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|UMSDOS_unlink
(paren
id|new_dir
comma
id|new_name
comma
id|new_len
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;rename unlink ret %d %d -- &quot;
comma
id|ret
comma
id|new_len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EISDIR
)paren
(brace
id|new_dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|UMSDOS_rmdir
(paren
id|new_dir
comma
id|new_name
comma
id|new_len
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;rename rmdir ret %d -- &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|umsdos_rename_f
(paren
id|old_dir
comma
id|old_name
comma
id|old_len
comma
id|new_dir
comma
id|new_name
comma
id|new_len
comma
l_int|0
)paren
suffix:semicolon
id|new_dir
op_assign
id|old_dir
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
id|iput
(paren
id|new_dir
)paren
suffix:semicolon
id|iput
(paren
id|old_dir
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
