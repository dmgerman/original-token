multiline_comment|/*&n; *  linux/fs/umsdos/namei.c&n; *&n; *      Written 1993 by Jacques Gelinas &n; *      Inspired from linux/fs/msdos/... by Werner Almesberger&n; *&n; * Maintain and access the --linux alternate directory file.&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/msdos_fs.h&gt;
macro_line|#include &lt;linux/umsdos_fs.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#if 1
multiline_comment|/*&n; * Wait for creation exclusivity.&n; * Return 0 if the dir was already available.&n; * Return 1 if a wait was necessary.&n; * When 1 is return, it means a wait was done. It does not&n; * mean the directory is available.&n; */
DECL|function|umsdos_waitcreate
r_static
r_int
id|umsdos_waitcreate
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.u.dir_info.creating
op_logical_and
id|dir-&gt;u.umsdos_i.u.dir_info.pid
op_ne
id|current-&gt;pid
)paren
(brace
id|sleep_on
(paren
op_amp
id|dir-&gt;u.umsdos_i.u.dir_info.p
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for any lookup process to finish&n; */
DECL|function|umsdos_waitlookup
r_static
r_void
id|umsdos_waitlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
r_while
c_loop
(paren
id|dir-&gt;u.umsdos_i.u.dir_info.looking
)paren
(brace
id|sleep_on
(paren
op_amp
id|dir-&gt;u.umsdos_i.u.dir_info.p
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Lock all other process out of this directory.&n; */
multiline_comment|/* #Specification: file creation / not atomic&n; * File creation is a two step process. First we create (allocate)&n; * an entry in the EMD file and then (using the entry offset) we&n; * build a unique name for MSDOS. We create this name in the msdos&n; * space.&n; * &n; * We have to use semaphore (sleep_on/wake_up) to prevent lookup&n; * into a directory when we create a file or directory and to&n; * prevent creation while a lookup is going on. Since many lookup&n; * may happen at the same time, the semaphore is a counter.&n; * &n; * Only one creation is allowed at the same time. This protection&n; * may not be necessary. The problem arise mainly when a lookup&n; * or a readdir is done while a file is partially created. The&n; * lookup process see that as a &quot;normal&quot; problem and silently&n; * erase the file from the EMD file. Normal because a file&n; * may be erased during a MSDOS session, but not removed from&n; * the EMD file.&n; * &n; * The locking is done on a directory per directory basis. Each&n; * directory inode has its wait_queue.&n; * &n; * For some operation like hard link, things even get worse. Many&n; * creation must occur at once (atomic). To simplify the design&n; * a process is allowed to recursively lock the directory for&n; * creation. The pid of the locking process is kept along with&n; * a counter so a second level of locking is granted or not.&n; */
DECL|function|umsdos_lockcreate
r_void
id|umsdos_lockcreate
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
multiline_comment|/*&n;&t; * Wait for any creation process to finish except&n;&t; * if we (the process) own the lock&n;&t; */
r_while
c_loop
(paren
id|umsdos_waitcreate
(paren
id|dir
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|dir-&gt;u.umsdos_i.u.dir_info.creating
op_increment
suffix:semicolon
id|dir-&gt;u.umsdos_i.u.dir_info.pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|umsdos_waitlookup
(paren
id|dir
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Lock all other process out of those two directories.&n; */
DECL|function|umsdos_lockcreate2
r_static
r_void
id|umsdos_lockcreate2
(paren
r_struct
id|inode
op_star
id|dir1
comma
r_struct
id|inode
op_star
id|dir2
)paren
(brace
multiline_comment|/*&n;&t; * We must check that both directory are available before&n;&t; * locking anyone of them. This is to avoid some deadlock.&n;&t; * Thanks to dglaude@is1.vub.ac.be (GLAUDE DAVID) for pointing&n;&t; * this to me.&n;&t; */
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|umsdos_waitcreate
(paren
id|dir1
)paren
op_eq
l_int|0
op_logical_and
id|umsdos_waitcreate
(paren
id|dir2
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We own both now */
id|dir1-&gt;u.umsdos_i.u.dir_info.creating
op_increment
suffix:semicolon
id|dir1-&gt;u.umsdos_i.u.dir_info.pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|dir2-&gt;u.umsdos_i.u.dir_info.creating
op_increment
suffix:semicolon
id|dir2-&gt;u.umsdos_i.u.dir_info.pid
op_assign
id|current-&gt;pid
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|umsdos_waitlookup
(paren
id|dir1
)paren
suffix:semicolon
id|umsdos_waitlookup
(paren
id|dir2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait until creation is finish in this directory.&n; */
DECL|function|umsdos_startlookup
r_void
id|umsdos_startlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
r_while
c_loop
(paren
id|umsdos_waitcreate
(paren
id|dir
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|dir-&gt;u.umsdos_i.u.dir_info.looking
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Unlock the directory.&n; */
DECL|function|umsdos_unlockcreate
r_void
id|umsdos_unlockcreate
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
id|dir-&gt;u.umsdos_i.u.dir_info.creating
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.u.dir_info.creating
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: dir-&gt;u.umsdos_i.u.dir_info.creating &lt; 0: %d&quot;
comma
id|dir-&gt;u.umsdos_i.u.dir_info.creating
)paren
suffix:semicolon
)brace
id|wake_up
(paren
op_amp
id|dir-&gt;u.umsdos_i.u.dir_info.p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Tell directory lookup is over.&n; */
DECL|function|umsdos_endlookup
r_void
id|umsdos_endlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
id|dir-&gt;u.umsdos_i.u.dir_info.looking
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.u.dir_info.looking
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: dir-&gt;u.umsdos_i.u.dir_info.looking &lt; 0: %d&quot;
comma
id|dir-&gt;u.umsdos_i.u.dir_info.looking
)paren
suffix:semicolon
)brace
id|wake_up
(paren
op_amp
id|dir-&gt;u.umsdos_i.u.dir_info.p
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|umsdos_lockcreate
r_static
r_void
id|umsdos_lockcreate
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
)brace
DECL|function|umsdos_lockcreate2
r_static
r_void
id|umsdos_lockcreate2
(paren
r_struct
id|inode
op_star
id|dir1
comma
r_struct
id|inode
op_star
id|dir2
)paren
(brace
)brace
DECL|function|umsdos_startlookup
r_void
id|umsdos_startlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
)brace
DECL|function|umsdos_unlockcreate
r_static
r_void
id|umsdos_unlockcreate
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
)brace
DECL|function|umsdos_endlookup
r_void
id|umsdos_endlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
)brace
macro_line|#endif
multiline_comment|/*&n; * Check whether we can delete from the directory.&n; */
DECL|function|is_sticky
r_static
r_int
id|is_sticky
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_int
id|uid
)paren
(brace
r_return
op_logical_neg
(paren
(paren
id|dir-&gt;i_mode
op_amp
id|S_ISVTX
)paren
op_eq
l_int|0
op_logical_or
id|capable
(paren
id|CAP_FOWNER
)paren
op_logical_or
id|current-&gt;fsuid
op_eq
id|uid
op_logical_or
id|current-&gt;fsuid
op_eq
id|dir-&gt;i_uid
)paren
suffix:semicolon
)brace
DECL|function|umsdos_nevercreat
r_static
r_int
id|umsdos_nevercreat
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|errcod
)paren
(brace
r_const
r_char
op_star
id|name
op_assign
id|dentry-&gt;d_name.name
suffix:semicolon
r_int
id|len
op_assign
id|dentry-&gt;d_name.len
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_is_pseudodos
(paren
id|dir
comma
id|dentry
)paren
)paren
(brace
multiline_comment|/* #Specification: pseudo root / any file creation /DOS&n;&t;&t; * The pseudo sub-directory /DOS can&squot;t be created!&n;&t;&t; * EEXIST is returned.&n;&t;&t; * &n;&t;&t; * The pseudo sub-directory /DOS can&squot;t be removed!&n;&t;&t; * EPERM is returned.&n;&t;&t; */
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
id|ret
op_assign
id|errcod
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
(paren
id|len
op_eq
l_int|1
op_logical_or
(paren
id|len
op_eq
l_int|2
op_logical_and
id|name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
)paren
)paren
(brace
multiline_comment|/* #Specification: create / . and ..&n;&t;&t; * If one try to creates . or .., it always fail and return&n;&t;&t; * EEXIST.&n;&t;&t; * &n;&t;&t; * If one try to delete . or .., it always fail and return&n;&t;&t; * EPERM.&n;&t;&t; * &n;&t;&t; * This should be test at the VFS layer level to avoid&n;&t;&t; * duplicating this in all file systems. Any comments ?&n;&t;&t; */
id|ret
op_assign
id|errcod
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a new file (ordinary or special) into the alternate directory.&n; * The file is added to the real MSDOS directory. If successful, it&n; * is then added to the EMD file.&n; * &n; * Return the status of the operation. 0 mean success.&n; *&n; * #Specification: create / file exist in DOS&n; * Here is a situation. Trying to create a file with&n; * UMSDOS. The file is unknown to UMSDOS but already&n; * exists in the DOS directory.&n; * &n; * Here is what we are NOT doing:&n; * &n; * We could silently assume that everything is fine&n; * and allows the creation to succeed.&n; * &n; * It is possible not all files in the partition&n; * are meant to be visible from linux. By trying to create&n; * those file in some directory, one user may get access&n; * to those file without proper permissions. Looks like&n; * a security hole to me. Off course sharing a file system&n; * with DOS is some kind of security hole :-)&n; * &n; * So ?&n; * &n; * We return EEXIST in this case.&n; * The same is true for directory creation.&n; */
DECL|function|umsdos_create_any
r_static
r_int
id|umsdos_create_any
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
comma
r_int
id|rdev
comma
r_char
id|flags
)paren
(brace
r_struct
id|dentry
op_star
id|fake
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_struct
id|umsdos_info
id|info
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
id|printk
c_func
(paren
l_string|&quot;umsdos_create_any: %s/%s not negative!&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_create_any /mn/: create %.*s in dir=%lu - nevercreat=/&quot;
comma
(paren
r_int
)paren
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
comma
id|dir-&gt;i_ino
)paren
)paren
suffix:semicolon
id|check_dentry_path
(paren
id|dentry
comma
l_string|&quot;umsdos_create_any&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_nevercreat
(paren
id|dir
comma
id|dentry
comma
op_minus
id|EEXIST
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;%d/&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|ret
op_assign
id|umsdos_parse
(paren
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|info.entry.mode
op_assign
id|mode
suffix:semicolon
id|info.entry.rdev
op_assign
id|rdev
suffix:semicolon
id|info.entry.flags
op_assign
id|flags
suffix:semicolon
id|info.entry.uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|info.entry.gid
op_assign
(paren
id|dir-&gt;i_mode
op_amp
id|S_ISGID
)paren
ques
c_cond
id|dir-&gt;i_gid
suffix:colon
id|current-&gt;fsgid
suffix:semicolon
id|info.entry.ctime
op_assign
id|info.entry.atime
op_assign
id|info.entry.mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|info.entry.nlink
op_assign
l_int|1
suffix:semicolon
id|umsdos_lockcreate
(paren
id|dir
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_newentry
(paren
id|dentry-&gt;d_parent
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/* create short name dentry */
id|fake
op_assign
id|umsdos_lookup_dentry
c_func
(paren
id|dentry-&gt;d_parent
comma
id|info.fake.fname
comma
id|info.fake.len
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|fake
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|fake
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/* should not exist yet ... */
id|ret
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|fake-&gt;d_inode
)paren
r_goto
id|out_remove
suffix:semicolon
id|ret
op_assign
id|msdos_create
(paren
id|dir
comma
id|fake
comma
id|S_IFREG
op_or
l_int|0777
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_remove
suffix:semicolon
id|inode
op_assign
id|fake-&gt;d_inode
suffix:semicolon
id|umsdos_lookup_patch_new
c_func
(paren
id|fake
comma
op_amp
id|info.entry
comma
id|info.f_pos
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;inode %p[%lu], count=%d &quot;
comma
id|inode
comma
id|inode-&gt;i_ino
comma
id|inode-&gt;i_count
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;Creation OK: [dir %lu] %.*s pid=%d pos %ld&bslash;n&quot;
comma
id|dir-&gt;i_ino
comma
id|info.fake.len
comma
id|info.fake.fname
comma
id|current-&gt;pid
comma
id|info.f_pos
)paren
)paren
suffix:semicolon
id|check_dentry_path
(paren
id|dentry
comma
l_string|&quot;umsdos_create_any: BEG dentry&quot;
)paren
suffix:semicolon
id|check_dentry_path
(paren
id|fake
comma
l_string|&quot;umsdos_create_any: BEG fake&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Note! The long and short name might be the same,&n;&t; * so check first before doing the instantiate ...&n;&t; */
r_if
c_cond
(paren
id|dentry
op_ne
id|fake
)paren
(brace
multiline_comment|/* long name also gets inode info */
id|inode-&gt;i_count
op_increment
suffix:semicolon
id|d_instantiate
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
)brace
id|check_dentry_path
(paren
id|dentry
comma
l_string|&quot;umsdos_create_any: END dentry&quot;
)paren
suffix:semicolon
id|check_dentry_path
(paren
id|fake
comma
l_string|&quot;umsdos_create_any: END fake&quot;
)paren
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
id|out_remove
suffix:colon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EEXIST
)paren
id|printk
c_func
(paren
l_string|&quot;UMSDOS: out of sync, error [%ld], deleting %.*s %d %d pos %ld&bslash;n&quot;
comma
id|dir-&gt;i_ino
comma
id|info.fake.len
comma
id|info.fake.fname
comma
op_minus
id|ret
comma
id|current-&gt;pid
comma
id|info.f_pos
)paren
suffix:semicolon
id|umsdos_delentry
(paren
id|dentry-&gt;d_parent
comma
op_amp
id|info
comma
l_int|0
)paren
suffix:semicolon
id|out_dput
suffix:colon
id|Printk
(paren
(paren
l_string|&quot;umsdos_create %.*s ret = %d pos %ld&bslash;n&quot;
comma
id|info.fake.len
comma
id|info.fake.fname
comma
id|ret
comma
id|info.f_pos
)paren
)paren
suffix:semicolon
multiline_comment|/* N.B. any value in keeping short name dentries? */
r_if
c_cond
(paren
id|dentry
op_ne
id|fake
)paren
id|d_drop
c_func
(paren
id|fake
)paren
suffix:semicolon
id|dput
c_func
(paren
id|fake
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|umsdos_unlockcreate
(paren
id|dir
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialise the new_entry from the old for a rename operation.&n; * (Only useful for umsdos_rename_f() below).&n; */
DECL|function|umsdos_ren_init
r_static
r_void
id|umsdos_ren_init
(paren
r_struct
id|umsdos_info
op_star
id|new_info
comma
r_struct
id|umsdos_info
op_star
id|old_info
comma
r_int
id|flags
)paren
(brace
multiline_comment|/* != 0, this is the value of flags */
id|new_info-&gt;entry.mode
op_assign
id|old_info-&gt;entry.mode
suffix:semicolon
id|new_info-&gt;entry.rdev
op_assign
id|old_info-&gt;entry.rdev
suffix:semicolon
id|new_info-&gt;entry.uid
op_assign
id|old_info-&gt;entry.uid
suffix:semicolon
id|new_info-&gt;entry.gid
op_assign
id|old_info-&gt;entry.gid
suffix:semicolon
id|new_info-&gt;entry.ctime
op_assign
id|old_info-&gt;entry.ctime
suffix:semicolon
id|new_info-&gt;entry.atime
op_assign
id|old_info-&gt;entry.atime
suffix:semicolon
id|new_info-&gt;entry.mtime
op_assign
id|old_info-&gt;entry.mtime
suffix:semicolon
id|new_info-&gt;entry.flags
op_assign
id|flags
ques
c_cond
id|flags
suffix:colon
id|old_info-&gt;entry.flags
suffix:semicolon
id|new_info-&gt;entry.nlink
op_assign
id|old_info-&gt;entry.nlink
suffix:semicolon
)brace
DECL|macro|chkstk
mdefine_line|#define chkstk() &bslash;&n;if (STACK_MAGIC != *(unsigned long *)current-&gt;kernel_stack_page){&bslash;&n;    printk(KERN_ALERT &quot;UMSDOS: %s magic %x != %lx ligne %d&bslash;n&quot; &bslash;&n;&t;   , current-&gt;comm,STACK_MAGIC &bslash;&n;&t;   ,*(unsigned long *)current-&gt;kernel_stack_page &bslash;&n;&t;   ,__LINE__); &bslash;&n;}
DECL|macro|chkstk
macro_line|#undef chkstk
DECL|macro|chkstk
mdefine_line|#define chkstk() do { } while (0);
multiline_comment|/*&n; * Rename a file (move) in the file system.&n; */
DECL|function|umsdos_rename_f
r_static
r_int
id|umsdos_rename_f
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_struct
id|dentry
op_star
id|new_dentry
comma
r_int
id|flags
)paren
(brace
r_int
id|old_ret
comma
id|new_ret
suffix:semicolon
r_struct
id|dentry
op_star
id|old
comma
op_star
r_new
comma
op_star
id|dret
suffix:semicolon
r_struct
id|inode
op_star
id|oldid
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_struct
id|umsdos_info
id|old_info
suffix:semicolon
r_struct
id|umsdos_info
id|new_info
suffix:semicolon
id|old_ret
op_assign
id|umsdos_parse
(paren
id|old_dentry-&gt;d_name.name
comma
id|old_dentry-&gt;d_name.len
comma
op_amp
id|old_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_ret
)paren
r_goto
id|out
suffix:semicolon
id|new_ret
op_assign
id|umsdos_parse
(paren
id|new_dentry-&gt;d_name.name
comma
id|new_dentry-&gt;d_name.len
comma
op_amp
id|new_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_ret
)paren
r_goto
id|out
suffix:semicolon
id|check_dentry_path
(paren
id|old_dentry
comma
l_string|&quot;umsdos_rename_f OLD&quot;
)paren
suffix:semicolon
id|check_dentry_path
(paren
id|new_dentry
comma
l_string|&quot;umsdos_rename_f OLD&quot;
)paren
suffix:semicolon
id|chkstk
(paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_rename %d %d &quot;
comma
id|old_ret
comma
id|new_ret
)paren
)paren
suffix:semicolon
id|umsdos_lockcreate2
(paren
id|old_dir
comma
id|new_dir
)paren
suffix:semicolon
id|chkstk
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_findentry
c_func
(paren
id|old_dentry-&gt;d_parent
comma
op_amp
id|old_info
comma
l_int|0
)paren
suffix:semicolon
id|chkstk
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;ret %d &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* check sticky bit on old_dir */
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|is_sticky
c_func
(paren
id|old_dir
comma
id|old_info.entry.uid
)paren
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;sticky set on old &quot;
)paren
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* Does new_name already exist? */
id|new_ret
op_assign
id|umsdos_findentry
c_func
(paren
id|new_dentry-&gt;d_parent
comma
op_amp
id|new_info
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* if destination file exists, are we allowed to replace it ? */
r_if
c_cond
(paren
id|new_ret
op_eq
l_int|0
op_logical_and
id|is_sticky
c_func
(paren
id|new_dir
comma
id|new_info.entry.uid
)paren
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;sticky set on new &quot;
)paren
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|Printk
(paren
(paren
l_string|&quot;new newentry &quot;
)paren
)paren
suffix:semicolon
id|umsdos_ren_init
(paren
op_amp
id|new_info
comma
op_amp
id|old_info
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_newentry
(paren
id|new_dentry-&gt;d_parent
comma
op_amp
id|new_info
)paren
suffix:semicolon
id|chkstk
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;ret %d %d &quot;
comma
id|ret
comma
id|new_info.fake.len
)paren
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|dret
op_assign
id|umsdos_lookup_dentry
c_func
(paren
id|old_dentry-&gt;d_parent
comma
id|old_info.fake.fname
comma
id|old_info.fake.len
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|dret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dret
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
macro_line|#if 0
multiline_comment|/* This is the same as dret */
id|oldid
op_assign
id|dret-&gt;d_inode
suffix:semicolon
id|old
op_assign
id|creat_dentry
(paren
id|old_info.fake.fname
comma
id|old_info.fake.len
comma
id|oldid
comma
id|old_dentry-&gt;d_parent
)paren
suffix:semicolon
macro_line|#endif
id|old
op_assign
id|dret
suffix:semicolon
r_new
op_assign
id|umsdos_lookup_dentry
c_func
(paren
id|new_dentry-&gt;d_parent
comma
id|new_info.fake.fname
comma
id|new_info.fake.len
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
r_new
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
r_new
)paren
)paren
r_goto
id|out_dput
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;msdos_rename &quot;
)paren
)paren
suffix:semicolon
id|check_dentry_path
(paren
id|old
comma
l_string|&quot;umsdos_rename_f OLD2&quot;
)paren
suffix:semicolon
id|check_dentry_path
(paren
r_new
comma
l_string|&quot;umsdos_rename_f NEW2&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|msdos_rename
(paren
id|old_dir
comma
id|old
comma
id|new_dir
comma
r_new
)paren
suffix:semicolon
id|chkstk
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;after m_rename ret %d &quot;
comma
id|ret
)paren
suffix:semicolon
multiline_comment|/* dput(old); */
id|dput
c_func
(paren
r_new
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|umsdos_delentry
(paren
id|new_dentry-&gt;d_parent
comma
op_amp
id|new_info
comma
id|S_ISDIR
(paren
id|new_info.entry.mode
)paren
)paren
suffix:semicolon
id|chkstk
(paren
)paren
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
id|ret
op_assign
id|umsdos_delentry
(paren
id|old_dentry-&gt;d_parent
comma
op_amp
id|old_info
comma
id|S_ISDIR
(paren
id|old_info.entry.mode
)paren
)paren
suffix:semicolon
id|chkstk
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_dput
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t; * Update f_pos so notify_change will succeed&n;&t; * if the file was already in use.&n;&t; */
id|umsdos_set_dirinfo
(paren
id|new_dentry-&gt;d_inode
comma
id|new_dir
comma
id|new_info.f_pos
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|old_dentry
op_eq
id|dret
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;umsdos_rename_f: old dentries match -- skipping d_move&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
id|d_move
(paren
id|old_dentry
comma
id|new_dentry
)paren
suffix:semicolon
id|out_dput
suffix:colon
id|dput
c_func
(paren
id|dret
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_rename_f: unlocking dirs...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|umsdos_unlockcreate
(paren
id|old_dir
)paren
suffix:semicolon
id|umsdos_unlockcreate
(paren
id|new_dir
)paren
suffix:semicolon
id|out
suffix:colon
id|check_dentry_path
(paren
id|old_dentry
comma
l_string|&quot;umsdos_rename_f OLD3&quot;
)paren
suffix:semicolon
id|check_dentry_path
(paren
id|new_dentry
comma
l_string|&quot;umsdos_rename_f NEW3&quot;
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot; _ret=%d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Setup a Symbolic link or a (pseudo) hard link&n; * Return a negative error code or 0 if OK.&n; */
multiline_comment|/* #Specification: symbolic links / strategy&n; * A symbolic link is simply a file which hold a path. It is&n; * implemented as a normal MSDOS file (not very space efficient :-()&n; * &n; * I see 2 different way to do it. One is to place the link data&n; * in unused entry of the EMD file. The other is to have a separate&n; * file dedicated to hold all symbolic links data.&n; * &n; * Let&squot;s go for simplicity...&n; */
DECL|function|umsdos_symlink_x
r_static
r_int
id|umsdos_symlink_x
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|symname
comma
r_int
id|mode
comma
r_char
id|flags
)paren
(brace
r_int
id|ret
comma
id|len
suffix:semicolon
r_struct
id|file
id|filp
suffix:semicolon
id|ret
op_assign
id|umsdos_create_any
(paren
id|dir
comma
id|dentry
comma
id|mode
comma
l_int|0
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;umsdos_symlink ret %d &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|len
op_assign
id|strlen
(paren
id|symname
)paren
suffix:semicolon
id|fill_new_filp
(paren
op_amp
id|filp
comma
id|dentry
)paren
suffix:semicolon
id|filp.f_pos
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Make the inode acceptable to MSDOS FIXME */
id|Printk
(paren
(paren
id|KERN_WARNING
l_string|&quot;   symname=%s ; dentry name=%.*s (ino=%lu)&bslash;n&quot;
comma
id|symname
comma
(paren
r_int
)paren
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_inode-&gt;i_ino
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_file_write_kmem_real
(paren
op_amp
id|filp
comma
id|symname
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ret
op_ne
id|len
)paren
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
id|printk
(paren
l_string|&quot;UMSDOS: &quot;
l_string|&quot;Can&squot;t write symbolic link data&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|UMSDOS_unlink
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|Printk
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Setup a Symbolic link.&n; * Return a negative error code or 0 if OK.&n; */
DECL|function|UMSDOS_symlink
r_int
id|UMSDOS_symlink
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|symname
)paren
(brace
r_return
id|umsdos_symlink_x
(paren
id|dir
comma
id|dentry
comma
id|symname
comma
id|S_IFLNK
op_or
l_int|0777
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a link to an inode in a directory&n; */
DECL|function|UMSDOS_link
r_int
id|UMSDOS_link
(paren
r_struct
id|dentry
op_star
id|olddentry
comma
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|oldinode
op_assign
id|olddentry-&gt;d_inode
suffix:semicolon
r_struct
id|inode
op_star
id|olddir
suffix:semicolon
r_char
op_star
id|path
suffix:semicolon
r_struct
id|dentry
op_star
id|temp
suffix:semicolon
r_int
r_int
id|buffer
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|oldinode-&gt;i_mode
)paren
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
id|umsdos_nevercreat
(paren
id|dir
comma
id|dentry
comma
op_minus
id|EPERM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|buffer
op_assign
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
r_goto
id|out
suffix:semicolon
id|olddir
op_assign
id|olddentry-&gt;d_parent-&gt;d_inode
suffix:semicolon
id|umsdos_lockcreate2
(paren
id|dir
comma
id|olddir
)paren
suffix:semicolon
multiline_comment|/* get the entry for the old name */
id|ret
op_assign
id|umsdos_dentry_to_entry
c_func
(paren
id|olddentry
comma
op_amp
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_unlock
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_link :%.*s: ino %lu flags %d &quot;
comma
id|entry.name_len
comma
id|entry.name
comma
id|oldinode-&gt;i_ino
comma
id|entry.flags
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry.flags
op_amp
id|UMSDOS_HIDDEN
)paren
)paren
(brace
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|ret
op_assign
id|umsdos_newhidden
(paren
id|olddentry-&gt;d_parent
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_unlock
suffix:semicolon
id|ret
op_assign
id|umsdos_rename_f
(paren
id|olddentry-&gt;d_inode
comma
id|olddentry
comma
id|dir
comma
id|dentry
comma
id|UMSDOS_HIDDEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_unlock
suffix:semicolon
id|path
op_assign
id|d_path
c_func
(paren
id|olddentry
comma
(paren
r_char
op_star
)paren
id|buffer
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|path
)paren
r_goto
id|out_unlock
suffix:semicolon
id|temp
op_assign
id|umsdos_lookup_dentry
c_func
(paren
id|olddentry-&gt;d_parent
comma
id|entry.name
comma
id|entry.name_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|temp
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|ret
op_assign
id|umsdos_symlink_x
(paren
id|olddir
comma
id|temp
comma
id|path
comma
id|S_IFREG
op_or
l_int|0777
comma
id|UMSDOS_HLINK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|umsdos_symlink_x
(paren
id|dir
comma
id|dentry
comma
id|path
comma
id|S_IFREG
op_or
l_int|0777
comma
id|UMSDOS_HLINK
)paren
suffix:semicolon
)brace
id|dput
c_func
(paren
id|temp
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|path
op_assign
id|d_path
c_func
(paren
id|olddentry
comma
(paren
r_char
op_star
)paren
id|buffer
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|path
)paren
(brace
id|ret
op_assign
id|umsdos_symlink_x
(paren
id|dir
comma
id|dentry
comma
id|path
comma
id|S_IFREG
op_or
l_int|0777
comma
id|UMSDOS_HLINK
)paren
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|umsdos_unlockcreate
(paren
id|olddir
)paren
suffix:semicolon
id|umsdos_unlockcreate
(paren
id|dir
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|buffer
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|iattr
id|newattrs
suffix:semicolon
id|oldinode-&gt;i_nlink
op_increment
suffix:semicolon
id|newattrs.ia_valid
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|UMSDOS_notify_change
(paren
id|olddentry
comma
op_amp
id|newattrs
)paren
suffix:semicolon
)brace
id|Printk
(paren
(paren
l_string|&quot;umsdos_link %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a new file into the alternate directory.&n; * The file is added to the real MSDOS directory. If successful, it&n; * is then added to the EMD file.&n; * &n; * Return the status of the operation. 0 mean success.&n; */
DECL|function|UMSDOS_create
r_int
id|UMSDOS_create
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_int
id|ret
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;UMSDOS_create: entering&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|check_dentry_path
(paren
id|dentry
comma
l_string|&quot;UMSDOS_create START&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_create_any
(paren
id|dir
comma
id|dentry
comma
id|mode
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|check_dentry_path
(paren
id|dentry
comma
l_string|&quot;UMSDOS_create END&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a sub-directory in a directory&n; */
multiline_comment|/* #Specification: mkdir / Directory already exist in DOS&n; * We do the same thing as for file creation.&n; * For all user it is an error.&n; */
multiline_comment|/* #Specification: mkdir / umsdos directory / create EMD&n; * When we created a new sub-directory in a UMSDOS&n; * directory (one with full UMSDOS semantics), we&n; * create immediately an EMD file in the new&n; * sub-directory so it inherits UMSDOS semantics.&n; */
DECL|function|UMSDOS_mkdir
r_int
id|UMSDOS_mkdir
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_struct
id|dentry
op_star
id|temp
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|ret
comma
id|err
suffix:semicolon
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|ret
op_assign
id|umsdos_nevercreat
(paren
id|dir
comma
id|dentry
comma
op_minus
id|EEXIST
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
id|umsdos_parse
(paren
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;umsdos_mkdir %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|umsdos_lockcreate
(paren
id|dir
)paren
suffix:semicolon
id|info.entry.mode
op_assign
id|mode
op_or
id|S_IFDIR
suffix:semicolon
id|info.entry.rdev
op_assign
l_int|0
suffix:semicolon
id|info.entry.uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|info.entry.gid
op_assign
(paren
id|dir-&gt;i_mode
op_amp
id|S_ISGID
)paren
ques
c_cond
id|dir-&gt;i_gid
suffix:colon
id|current-&gt;fsgid
suffix:semicolon
id|info.entry.ctime
op_assign
id|info.entry.atime
op_assign
id|info.entry.mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|info.entry.flags
op_assign
l_int|0
suffix:semicolon
id|info.entry.nlink
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
id|umsdos_newentry
(paren
id|dentry-&gt;d_parent
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;newentry %d &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* lookup the short name dentry */
id|temp
op_assign
id|umsdos_lookup_dentry
c_func
(paren
id|dentry-&gt;d_parent
comma
id|info.fake.fname
comma
id|info.fake.len
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|temp
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/* Make sure the short name doesn&squot;t exist */
id|ret
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|temp-&gt;d_inode
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;umsdos_mkdir: short name %s/%s exists&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|info.fake.fname
)paren
suffix:semicolon
r_goto
id|out_remove
suffix:semicolon
)brace
id|ret
op_assign
id|msdos_mkdir
(paren
id|dir
comma
id|temp
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_remove
suffix:semicolon
id|inode
op_assign
id|temp-&gt;d_inode
suffix:semicolon
id|umsdos_lookup_patch_new
c_func
(paren
id|temp
comma
op_amp
id|info.entry
comma
id|info.f_pos
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Note! The long and short name might be the same,&n;&t; * so check first before doing the instantiate ...&n;&t; */
r_if
c_cond
(paren
id|dentry
op_ne
id|temp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_inode
)paren
(brace
id|inode-&gt;i_count
op_increment
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;umsdos_mkdir: not negative??&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;umsdos_mkdir: dentries match, skipping inst&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* create the EMD file */
id|err
op_assign
id|umsdos_make_emd
c_func
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * set up the dir so it is promoted to EMD,&n;&t; * with the EMD file invisible inside it.&n;&t; */
id|umsdos_setup_dir
c_func
(paren
id|temp
)paren
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
id|out_remove
suffix:colon
id|umsdos_delentry
(paren
id|dentry-&gt;d_parent
comma
op_amp
id|info
comma
l_int|1
)paren
suffix:semicolon
id|out_dput
suffix:colon
multiline_comment|/* kill off the short name dentry */
r_if
c_cond
(paren
id|temp
op_ne
id|dentry
)paren
id|d_drop
c_func
(paren
id|temp
)paren
suffix:semicolon
id|dput
c_func
(paren
id|temp
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|umsdos_unlockcreate
(paren
id|dir
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_mkdir %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a new device special file into a directory.&n; *&n; * #Specification: Special files / strategy&n; * Device special file, pipes, etc ... are created like normal&n; * file in the msdos file system. Of course they remain empty.&n; * &n; * One strategy was to create those files only in the EMD file&n; * since they were not important for MSDOS. The problem with&n; * that, is that there were not getting inode number allocated.&n; * The MSDOS filesystems is playing a nice game to fake inode&n; * number, so why not use it.&n; * &n; * The absence of inode number compatible with those allocated&n; * for ordinary files was causing major trouble with hard link&n; * in particular and other parts of the kernel I guess.&n; */
DECL|function|UMSDOS_mknod
r_int
id|UMSDOS_mknod
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
comma
r_int
id|rdev
)paren
(brace
r_int
id|ret
suffix:semicolon
id|check_dentry_path
(paren
id|dentry
comma
l_string|&quot;UMSDOS_mknod START&quot;
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_create_any
(paren
id|dir
comma
id|dentry
comma
id|mode
comma
id|rdev
comma
l_int|0
)paren
suffix:semicolon
id|check_dentry_path
(paren
id|dentry
comma
l_string|&quot;UMSDOS_mknod END&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a sub-directory.&n; */
DECL|function|UMSDOS_rmdir
r_int
id|UMSDOS_rmdir
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|dentry
op_star
id|temp
suffix:semicolon
r_int
id|ret
comma
id|err
comma
id|empty
suffix:semicolon
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|ret
op_assign
id|umsdos_nevercreat
(paren
id|dir
comma
id|dentry
comma
op_minus
id|EPERM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
macro_line|#if 0&t;/* no need for lookup ... we have a dentry ... */
id|ret
op_assign
id|umsdos_lookup_x
(paren
id|dir
comma
id|dentry
comma
l_int|0
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;rmdir lookup %d &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
macro_line|#endif
id|umsdos_lockcreate
(paren
id|dir
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_count
OG
l_int|1
)paren
(brace
id|shrink_dcache_parent
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_count
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;umsdos_rmdir: %s/%s busy&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
)brace
multiline_comment|/* check whether the EMD is empty */
id|empty
op_assign
id|umsdos_isempty
(paren
id|dentry
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOTEMPTY
suffix:semicolon
r_if
c_cond
(paren
id|empty
op_eq
l_int|0
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/* Have to remove the EMD file? */
r_if
c_cond
(paren
id|empty
op_eq
l_int|1
)paren
(brace
r_struct
id|dentry
op_star
id|demd
suffix:semicolon
multiline_comment|/* check sticky bit */
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|is_sticky
c_func
(paren
id|dir
comma
id|dentry-&gt;d_inode-&gt;i_uid
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;umsdos_rmdir: %s/%s is sticky&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|ENOTEMPTY
suffix:semicolon
multiline_comment|/* see if there&squot;s an EMD file ... */
id|demd
op_assign
id|umsdos_get_emd_dentry
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|demd
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;umsdos_rmdir: got EMD dentry %s/%s, inode=%p&bslash;n&quot;
comma
id|demd-&gt;d_parent-&gt;d_name.name
comma
id|demd-&gt;d_name.name
comma
id|demd-&gt;d_inode
)paren
suffix:semicolon
id|err
op_assign
id|msdos_unlink
(paren
id|dentry-&gt;d_inode
comma
id|demd
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;UMSDOS_rmdir: unlinking empty EMD err=%d&quot;
comma
id|err
)paren
)paren
suffix:semicolon
id|dput
c_func
(paren
id|demd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out_unlock
suffix:semicolon
)brace
id|umsdos_parse
(paren
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
op_amp
id|info
)paren
suffix:semicolon
multiline_comment|/* Call findentry to complete the mangling */
id|umsdos_findentry
(paren
id|dentry-&gt;d_parent
comma
op_amp
id|info
comma
l_int|2
)paren
suffix:semicolon
id|temp
op_assign
id|umsdos_lookup_dentry
c_func
(paren
id|dentry-&gt;d_parent
comma
id|info.fake.fname
comma
id|info.fake.len
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|temp
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/*&n;&t; * If the short name matches the dentry, dput() it now.&n;&t; */
r_if
c_cond
(paren
id|temp
op_eq
id|dentry
)paren
(brace
id|dput
c_func
(paren
id|temp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;umsdos_rmdir: %s/%s, short matches long&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Attempt to remove the msdos name.&n;&t; */
id|ret
op_assign
id|msdos_rmdir
(paren
id|dir
comma
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_logical_and
id|ret
op_ne
op_minus
id|ENOENT
)paren
r_goto
id|out_dput
suffix:semicolon
multiline_comment|/* OK so far ... remove the name from the EMD */
id|ret
op_assign
id|umsdos_delentry
(paren
id|dentry-&gt;d_parent
comma
op_amp
id|info
comma
l_int|1
)paren
suffix:semicolon
id|out_dput
suffix:colon
multiline_comment|/* dput() temp if we didn&squot;t do it above */
r_if
c_cond
(paren
id|temp
op_ne
id|dentry
)paren
(brace
id|d_drop
c_func
(paren
id|temp
)paren
suffix:semicolon
id|dput
c_func
(paren
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|d_delete
(paren
id|dentry
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;umsdos_rmdir: %s/%s, short=%s dput&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|info.fake.fname
)paren
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|umsdos_unlockcreate
(paren
id|dir
)paren
suffix:semicolon
id|out
suffix:colon
id|Printk
(paren
(paren
l_string|&quot;umsdos_rmdir %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a file from the directory.&n; *&n; * #Specification: hard link / deleting a link&n; * When we delete a file, and this file is a link&n; * we must subtract 1 to the nlink field of the&n; * hidden link.&n; * &n; * If the count goes to 0, we delete this hidden&n; * link too.&n; */
DECL|function|UMSDOS_unlink
r_int
id|UMSDOS_unlink
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|dentry
op_star
id|temp
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;UMSDOS_unlink: entering %s/%s&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_nevercreat
(paren
id|dir
comma
id|dentry
comma
op_minus
id|EPERM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
id|umsdos_parse
(paren
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|umsdos_lockcreate
(paren
id|dir
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_findentry
(paren
id|dentry-&gt;d_parent
comma
op_amp
id|info
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;UMSDOS_unlink: findentry returned %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|Printk
(paren
(paren
l_string|&quot;UMSDOS_unlink %.*s &quot;
comma
id|info.fake.len
comma
id|info.fake.fname
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* check sticky bit */
r_if
c_cond
(paren
id|is_sticky
c_func
(paren
id|dir
comma
id|info.entry.uid
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;umsdos_unlink: %s/%s is sticky&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info.entry.flags
op_amp
id|UMSDOS_HLINK
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;UMSDOS_unlink: hard link %s/%s, fake=%s&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|info.fake.fname
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * First, get the inode of the hidden link&n;&t;&t; * using the standard lookup function.&n;&t;&t; */
id|ret
op_assign
id|umsdos_lookup_x
(paren
id|dir
comma
id|dentry
comma
l_int|0
)paren
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_unlock
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;unlink nlink = %d &quot;
comma
id|inode-&gt;i_nlink
)paren
)paren
suffix:semicolon
id|inode-&gt;i_nlink
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_nlink
op_eq
l_int|0
)paren
(brace
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
id|ret
op_assign
id|umsdos_dentry_to_entry
(paren
id|dentry
comma
op_amp
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|UMSDOS_unlink
(paren
id|dentry-&gt;d_parent-&gt;d_inode
comma
id|dentry
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_struct
id|iattr
id|newattrs
suffix:semicolon
id|newattrs.ia_valid
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|UMSDOS_notify_change
(paren
id|dentry
comma
op_amp
id|newattrs
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/* get the short name dentry */
id|temp
op_assign
id|umsdos_lookup_dentry
c_func
(paren
id|dentry-&gt;d_parent
comma
id|info.fake.fname
comma
id|info.fake.len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|temp
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/*&n;&t; * If the short name matches the long,&n;&t; * dput() it now so it&squot;s not busy.&n;&t; */
r_if
c_cond
(paren
id|temp
op_eq
id|dentry
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;UMSDOS_unlink: %s/%s, short matches long&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
id|dput
c_func
(paren
id|temp
)paren
suffix:semicolon
)brace
id|ret
op_assign
id|umsdos_delentry
(paren
id|dentry-&gt;d_parent
comma
op_amp
id|info
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_logical_and
id|ret
op_ne
op_minus
id|ENOENT
)paren
r_goto
id|out_dput
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;UMSDOS: Before msdos_unlink %.*s &quot;
comma
id|info.fake.len
comma
id|info.fake.fname
)paren
suffix:semicolon
id|ret
op_assign
id|msdos_unlink_umsdos
(paren
id|dir
comma
id|temp
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;msdos_unlink %.*s %o ret %d &quot;
comma
id|info.fake.len
comma
id|info.fake.fname
comma
id|info.entry.mode
comma
id|ret
)paren
)paren
suffix:semicolon
multiline_comment|/* dput() temp if we didn&squot;t do it above */
id|out_dput
suffix:colon
r_if
c_cond
(paren
id|temp
op_ne
id|dentry
)paren
(brace
id|d_drop
c_func
(paren
id|temp
)paren
suffix:semicolon
id|dput
c_func
(paren
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|d_delete
(paren
id|dentry
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;umsdos_unlink: %s/%s, short=%s dput&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|info.fake.fname
)paren
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|umsdos_unlockcreate
(paren
id|dir
)paren
suffix:semicolon
id|out
suffix:colon
id|Printk
(paren
(paren
l_string|&quot;umsdos_unlink %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Rename (move) a file.&n; */
DECL|function|UMSDOS_rename
r_int
id|UMSDOS_rename
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_struct
id|dentry
op_star
id|new_dentry
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|umsdos_nevercreat
(paren
id|new_dir
comma
id|new_dentry
comma
op_minus
id|EEXIST
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
id|umsdos_rename_f
c_func
(paren
id|old_dir
comma
id|old_dentry
comma
id|new_dir
comma
id|new_dentry
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|EEXIST
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* This is not terribly efficient but should work. */
id|ret
op_assign
id|UMSDOS_unlink
(paren
id|new_dir
comma
id|new_dentry
)paren
suffix:semicolon
id|chkstk
(paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;rename unlink ret %d -- &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EISDIR
)paren
(brace
id|ret
op_assign
id|UMSDOS_rmdir
(paren
id|new_dir
comma
id|new_dentry
)paren
suffix:semicolon
id|chkstk
(paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;rename rmdir ret %d -- &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* this time the rename should work ... */
id|ret
op_assign
id|umsdos_rename_f
(paren
id|old_dir
comma
id|old_dentry
comma
id|new_dir
comma
id|new_dentry
comma
l_int|0
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
eof
