multiline_comment|/*&n; *  linux/fs/umsdos/namei.c&n; *&n; *&t;Written 1993 by Jacques Gelinas &n; *&t;Inspired from linux/fs/msdos/... by Werner Almesberger&n; *&n; * Maintain and access the --linux alternate directory file.&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/msdos_fs.h&gt;
macro_line|#include &lt;linux/umsdos_fs.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x)
DECL|macro|Printk
mdefine_line|#define Printk(x)&t;printk x
macro_line|#if 1
multiline_comment|/*&n;&t;Wait for creation exclusivity.&n;&t;Return 0 if the dir was already available.&n;&t;Return 1 if a wait was necessary.&n;&t;&t;When 1 is return, it means a wait was done. It does not&n;&t;&t;mean the directory is available.&n;*/
DECL|function|umsdos_waitcreate
r_static
r_int
id|umsdos_waitcreate
c_func
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.u.dir_info.creating
op_logical_and
id|dir-&gt;u.umsdos_i.u.dir_info.pid
op_ne
id|current-&gt;pid
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|dir-&gt;u.umsdos_i.u.dir_info.p
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Wait for any lookup process to finish&n;*/
DECL|function|umsdos_waitlookup
r_static
r_void
id|umsdos_waitlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
r_while
c_loop
(paren
id|dir-&gt;u.umsdos_i.u.dir_info.looking
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|dir-&gt;u.umsdos_i.u.dir_info.p
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;Lock all other process out of this directory.&n;*/
DECL|function|umsdos_lockcreate
r_void
id|umsdos_lockcreate
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
multiline_comment|/* #Specification: file creation / not atomic&n;     File creation is a two step process. First we create (allocate)&n;     an entry in the EMD file and then (using the entry offset) we&n;     build a unique name for MSDOS. We create this name in the msdos&n;     space.&n;     &n;     We have to use semaphore (sleep_on/wake_up) to prevent lookup&n;     into a directory when we create a file or directory and to&n;     prevent creation while a lookup is going on. Since many lookup&n;     may happen at the same time, the semaphore is a counter.&n;&n;     Only one creation is allowed at the same time. This protection&n;     may not be necessary. The problem arise mainly when a lookup&n;     or a readdir is done while a file is partially created. The&n;     lookup process see that as a &quot;normal&quot; problem and silently&n;     erase the file from the EMD file. Normal because a file&n;     may be erased during a MSDOS session, but not removed from&n;     the EMD file.&n;     &n;     The locking is done on a directory per directory basis. Each&n;     directory inode has its wait_queue.&n;     &n;     For some operation like hard link, things even get worse. Many&n;     creation must occur at once (atomic). To simplify the design&n;     a process is allowed to recursively lock the directory for&n;     creation. The pid of the locking process is kept along with&n;     a counter so a second level of locking is granted or not.&n;  */
multiline_comment|/*&n;    Wait for any creation process to finish except&n;    if we (the process) own the lock&n;  */
r_while
c_loop
(paren
id|umsdos_waitcreate
c_func
(paren
id|dir
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|dir-&gt;u.umsdos_i.u.dir_info.creating
op_increment
suffix:semicolon
id|dir-&gt;u.umsdos_i.u.dir_info.pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|umsdos_waitlookup
(paren
id|dir
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Lock all other process out of those two directories.&n;*/
DECL|function|umsdos_lockcreate2
r_static
r_void
id|umsdos_lockcreate2
(paren
r_struct
id|inode
op_star
id|dir1
comma
r_struct
id|inode
op_star
id|dir2
)paren
(brace
multiline_comment|/*&n;    We must check that both directory are available before&n;    locking anyone of them. This is to avoid some deadlock.&n;    Thanks to dglaude@is1.vub.ac.be (GLAUDE DAVID) for pointing&n;    this to me.&n;  */
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|umsdos_waitcreate
c_func
(paren
id|dir1
)paren
op_eq
l_int|0
op_logical_and
id|umsdos_waitcreate
c_func
(paren
id|dir2
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We own both now */
id|dir1-&gt;u.umsdos_i.u.dir_info.creating
op_increment
suffix:semicolon
id|dir1-&gt;u.umsdos_i.u.dir_info.pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|dir2-&gt;u.umsdos_i.u.dir_info.creating
op_increment
suffix:semicolon
id|dir2-&gt;u.umsdos_i.u.dir_info.pid
op_assign
id|current-&gt;pid
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|umsdos_waitlookup
c_func
(paren
id|dir1
)paren
suffix:semicolon
id|umsdos_waitlookup
c_func
(paren
id|dir2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Wait until creation is finish in this directory.&n;*/
DECL|function|umsdos_startlookup
r_void
id|umsdos_startlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
r_while
c_loop
(paren
id|umsdos_waitcreate
(paren
id|dir
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|dir-&gt;u.umsdos_i.u.dir_info.looking
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Unlock the directory.&n;*/
DECL|function|umsdos_unlockcreate
r_void
id|umsdos_unlockcreate
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
id|dir-&gt;u.umsdos_i.u.dir_info.creating
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.u.dir_info.creating
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: dir-&gt;u.umsdos_i.u.dir_info.creating &lt; 0: %d&quot;
comma
id|dir-&gt;u.umsdos_i.u.dir_info.creating
)paren
suffix:semicolon
)brace
id|wake_up
(paren
op_amp
id|dir-&gt;u.umsdos_i.u.dir_info.p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Tell directory lookup is over.&n;*/
DECL|function|umsdos_endlookup
r_void
id|umsdos_endlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
id|dir-&gt;u.umsdos_i.u.dir_info.looking
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.u.dir_info.looking
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: dir-&gt;u.umsdos_i.u.dir_info.looking &lt; 0: %d&quot;
comma
id|dir-&gt;u.umsdos_i.u.dir_info.looking
)paren
suffix:semicolon
)brace
id|wake_up
(paren
op_amp
id|dir-&gt;u.umsdos_i.u.dir_info.p
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|umsdos_lockcreate
r_static
r_void
id|umsdos_lockcreate
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
)brace
DECL|function|umsdos_lockcreate2
r_static
r_void
id|umsdos_lockcreate2
(paren
r_struct
id|inode
op_star
id|dir1
comma
r_struct
id|inode
op_star
id|dir2
)paren
(brace
)brace
DECL|function|umsdos_startlookup
r_void
id|umsdos_startlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
)brace
DECL|function|umsdos_unlockcreate
r_static
r_void
id|umsdos_unlockcreate
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
)brace
DECL|function|umsdos_endlookup
r_void
id|umsdos_endlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
)brace
macro_line|#endif
DECL|function|umsdos_nevercreat
r_static
r_int
id|umsdos_nevercreat
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|errcod
)paren
multiline_comment|/* Length of the name */
(brace
r_const
r_char
op_star
id|name
op_assign
id|dentry-&gt;d_name.name
suffix:semicolon
r_int
id|len
op_assign
id|dentry-&gt;d_name.len
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_is_pseudodos
c_func
(paren
id|dir
comma
id|dentry
)paren
)paren
(brace
multiline_comment|/* #Specification: pseudo root / any file creation /DOS&n;       The pseudo sub-directory /DOS can&squot;t be created!&n;       EEXIST is returned.&n;       &n;       The pseudo sub-directory /DOS can&squot;t be removed!&n;       EPERM is returned.&n;    */
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
id|ret
op_assign
id|errcod
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
(paren
id|len
op_eq
l_int|1
op_logical_or
(paren
id|len
op_eq
l_int|2
op_logical_and
id|name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
)paren
)paren
(brace
multiline_comment|/* #Specification: create / . and ..&n;       If one try to creates . or .., it always fail and return&n;       EEXIST.&n;       &n;       If one try to delete . or .., it always fail and return&n;       EPERM.&n;       &n;       This should be test at the VFS layer level to avoid&n;       duplicating this in all file systems. Any comments ?&n;    */
id|ret
op_assign
id|errcod
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;  Add a new file (ordinary or special) into the alternate directory.&n;  The file is added to the real MSDOS directory. If successful, it&n;  is then added to the EDM file.&n;  &n;  Return the status of the operation. 0 mean success.&n;*/
DECL|function|umsdos_create_any
r_static
r_int
id|umsdos_create_any
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
multiline_comment|/* name/length etc*/
r_int
id|mode
comma
multiline_comment|/* Permission bit + file type ??? */
r_int
id|rdev
comma
multiline_comment|/* major, minor or 0 for ordinary file */
multiline_comment|/* and symlinks */
r_char
id|flags
)paren
multiline_comment|/* Will hold the inode of the newly created */
multiline_comment|/* file */
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|dentry
op_star
id|fake
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_create_any /mn/: create %.*s in dir=%lu - nevercreat=/&quot;
comma
(paren
r_int
)paren
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
comma
id|dir-&gt;i_ino
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_nevercreat
c_func
(paren
id|dir
comma
id|dentry
comma
op_minus
id|EEXIST
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;%d/&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|ret
op_assign
id|umsdos_parse
c_func
(paren
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|info.entry.mode
op_assign
id|mode
suffix:semicolon
id|info.entry.rdev
op_assign
id|rdev
suffix:semicolon
id|info.entry.flags
op_assign
id|flags
suffix:semicolon
id|info.entry.uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|info.entry.gid
op_assign
(paren
id|dir-&gt;i_mode
op_amp
id|S_ISGID
)paren
ques
c_cond
id|dir-&gt;i_gid
suffix:colon
id|current-&gt;fsgid
suffix:semicolon
id|info.entry.ctime
op_assign
id|info.entry.atime
op_assign
id|info.entry.mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|info.entry.nlink
op_assign
l_int|1
suffix:semicolon
id|umsdos_lockcreate
c_func
(paren
id|dir
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_newentry
(paren
id|dir
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|fake
op_assign
id|creat_dentry
(paren
id|info.fake.fname
comma
id|info.fake.len
comma
l_int|NULL
comma
id|dentry-&gt;d_parent
)paren
suffix:semicolon
multiline_comment|/* create short name dentry */
id|ret
op_assign
id|msdos_create
(paren
id|dir
comma
id|fake
comma
id|S_IFREG
op_or
l_int|0777
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|fake-&gt;d_inode
suffix:semicolon
id|umsdos_lookup_patch
(paren
id|dir
comma
id|inode
comma
op_amp
id|info.entry
comma
id|info.f_pos
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;inode %p[%lu], count=%d &quot;
comma
id|inode
comma
id|inode-&gt;i_ino
comma
id|inode-&gt;i_count
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;Creation OK: [dir %lu] %.*s pid=%d pos %ld&bslash;n&quot;
comma
id|dir-&gt;i_ino
comma
id|info.fake.len
comma
id|info.fake.fname
comma
id|current-&gt;pid
comma
id|info.f_pos
)paren
)paren
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
multiline_comment|/* long name also gets inode info */
)brace
r_else
(brace
multiline_comment|/* #Specification: create / file exist in DOS&n;&t;     Here is a situation. Trying to create a file with&n;&t;     UMSDOS. The file is unknown to UMSDOS but already&n;&t;     exist in the DOS directory.&n;&t;     &n;&t;     Here is what we are NOT doing:&n;&t;     &n;&t;     We could silently assume that everything is fine&n;&t;     and allows the creation to succeed.&n;&t;     &n;&t;     It is possible not all files in the partition&n;&t;     are mean to be visible from linux. By trying to create&n;&t;     those file in some directory, one user may get access&n;&t;     to those file without proper permissions. Looks like&n;&t;     a security hole to me. Off course sharing a file system&n;&t;     with DOS is some kind of security hole :-)&n;&t;     &n;&t;     So ?&n;&t;     &n;&t;     We return EEXIST in this case.&n;&t;     The same is true for directory creation.&n;&t;  */
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EEXIST
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: out of sync, Creation error [%ld], &quot;
l_string|&quot;deleting %.*s %d %d pos %ld&bslash;n&quot;
comma
id|dir-&gt;i_ino
comma
id|info.fake.len
comma
id|info.fake.fname
comma
op_minus
id|ret
comma
id|current-&gt;pid
comma
id|info.f_pos
)paren
suffix:semicolon
)brace
id|umsdos_delentry
(paren
id|dir
comma
op_amp
id|info
comma
l_int|0
)paren
suffix:semicolon
)brace
id|Printk
(paren
(paren
l_string|&quot;umsdos_create %.*s ret = %d pos %ld&bslash;n&quot;
comma
id|info.fake.len
comma
id|info.fake.fname
comma
id|ret
comma
id|info.f_pos
)paren
)paren
suffix:semicolon
)brace
id|umsdos_unlockcreate
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* d_add(dentry,dir); /mn/ FIXME: msdos_create already did this for short name ! */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Initialise the new_entry from the old for a rename operation.&n;&t;(Only useful for umsdos_rename_f() below).&n;*/
DECL|function|umsdos_ren_init
r_static
r_void
id|umsdos_ren_init
c_func
(paren
r_struct
id|umsdos_info
op_star
id|new_info
comma
r_struct
id|umsdos_info
op_star
id|old_info
comma
r_int
id|flags
)paren
multiline_comment|/* 0 == copy flags from old_name */
multiline_comment|/* != 0, this is the value of flags */
(brace
id|new_info-&gt;entry.mode
op_assign
id|old_info-&gt;entry.mode
suffix:semicolon
id|new_info-&gt;entry.rdev
op_assign
id|old_info-&gt;entry.rdev
suffix:semicolon
id|new_info-&gt;entry.uid
op_assign
id|old_info-&gt;entry.uid
suffix:semicolon
id|new_info-&gt;entry.gid
op_assign
id|old_info-&gt;entry.gid
suffix:semicolon
id|new_info-&gt;entry.ctime
op_assign
id|old_info-&gt;entry.ctime
suffix:semicolon
id|new_info-&gt;entry.atime
op_assign
id|old_info-&gt;entry.atime
suffix:semicolon
id|new_info-&gt;entry.mtime
op_assign
id|old_info-&gt;entry.mtime
suffix:semicolon
id|new_info-&gt;entry.flags
op_assign
id|flags
ques
c_cond
id|flags
suffix:colon
id|old_info-&gt;entry.flags
suffix:semicolon
id|new_info-&gt;entry.nlink
op_assign
id|old_info-&gt;entry.nlink
suffix:semicolon
)brace
DECL|macro|chkstk
mdefine_line|#define chkstk() &bslash;&n;if (STACK_MAGIC != *(unsigned long *)current-&gt;kernel_stack_page){&bslash;&n;    printk(KERN_ALERT &quot;UMSDOS: %s magic %x != %lx ligne %d&bslash;n&quot; &bslash;&n;&t;   , current-&gt;comm,STACK_MAGIC &bslash;&n;&t;   ,*(unsigned long *)current-&gt;kernel_stack_page &bslash;&n;&t;   ,__LINE__); &bslash;&n;}
DECL|macro|chkstk
macro_line|#undef chkstk
DECL|macro|chkstk
mdefine_line|#define chkstk() do { } while (0)
multiline_comment|/*&n;&t;Rename a file (move) in the file system.&n;*/
DECL|function|umsdos_rename_f
r_static
r_int
id|umsdos_rename_f
c_func
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_struct
id|dentry
op_star
id|new_dentry
comma
r_int
id|flags
)paren
multiline_comment|/* 0 == copy flags from old_name */
multiline_comment|/* != 0, this is the value of flags */
(brace
r_int
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_struct
id|umsdos_info
id|old_info
suffix:semicolon
r_int
id|old_ret
op_assign
id|umsdos_parse
(paren
id|old_dentry-&gt;d_name.name
comma
id|old_dentry-&gt;d_name.len
comma
op_amp
id|old_info
)paren
suffix:semicolon
r_struct
id|umsdos_info
id|new_info
suffix:semicolon
r_int
id|new_ret
op_assign
id|umsdos_parse
(paren
id|new_dentry-&gt;d_name.name
comma
id|new_dentry-&gt;d_name.len
comma
op_amp
id|new_info
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_rename %d %d &quot;
comma
id|old_ret
comma
id|new_ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_ret
op_eq
l_int|0
op_logical_and
id|new_ret
op_eq
l_int|0
)paren
(brace
id|umsdos_lockcreate2
c_func
(paren
id|old_dir
comma
id|new_dir
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;old findentry &quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_findentry
c_func
(paren
id|old_dir
comma
op_amp
id|old_info
comma
l_int|0
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;ret %d &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/* check sticky bit on old_dir */
r_if
c_cond
(paren
op_logical_neg
(paren
id|old_dir-&gt;i_mode
op_amp
id|S_ISVTX
)paren
op_logical_or
id|capable
c_func
(paren
id|CAP_FOWNER
)paren
op_logical_or
id|current-&gt;fsuid
op_eq
id|old_info.entry.uid
op_logical_or
id|current-&gt;fsuid
op_eq
id|old_dir-&gt;i_uid
)paren
(brace
multiline_comment|/* Does new_name already exist? */
id|PRINTK
c_func
(paren
(paren
l_string|&quot;new findentry &quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_findentry
c_func
(paren
id|new_dir
comma
op_amp
id|new_info
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
op_logical_or
multiline_comment|/* if destination file exists, are we allowed to replace it ? */
op_logical_neg
(paren
id|new_dir-&gt;i_mode
op_amp
id|S_ISVTX
)paren
op_logical_or
id|capable
c_func
(paren
id|CAP_FOWNER
)paren
op_logical_or
id|current-&gt;fsuid
op_eq
id|new_info.entry.uid
op_logical_or
id|current-&gt;fsuid
op_eq
id|new_dir-&gt;i_uid
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;new newentry &quot;
)paren
)paren
suffix:semicolon
id|umsdos_ren_init
c_func
(paren
op_amp
id|new_info
comma
op_amp
id|old_info
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_newentry
(paren
id|new_dir
comma
op_amp
id|new_info
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;ret %d %d &quot;
comma
id|ret
comma
id|new_info.fake.len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|dentry
op_star
id|old
comma
op_star
r_new
suffix:semicolon
id|old
op_assign
id|creat_dentry
(paren
id|old_info.fake.fname
comma
id|old_info.fake.len
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_new
op_assign
id|creat_dentry
(paren
id|new_info.fake.fname
comma
id|new_info.fake.len
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;msdos_rename &quot;
)paren
)paren
suffix:semicolon
id|old_dir-&gt;i_count
op_increment
suffix:semicolon
id|new_dir-&gt;i_count
op_increment
suffix:semicolon
multiline_comment|/* Both inode are needed later */
id|ret
op_assign
id|msdos_rename
(paren
id|old_dir
comma
id|old
comma
id|new_dir
comma
r_new
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;after m_rename ret %d &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|umsdos_delentry
(paren
id|new_dir
comma
op_amp
id|new_info
comma
id|S_ISDIR
c_func
(paren
id|new_info.entry.mode
)paren
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
id|umsdos_delentry
(paren
id|old_dir
comma
op_amp
id|old_info
comma
id|S_ISDIR
c_func
(paren
id|old_info.entry.mode
)paren
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;  This umsdos_lookup_x does not look very useful.&n;&t;&t;  It makes sure that the inode of the file will&n;&t;&t;  be correctly setup (umsdos_patch_inode()) in&n;&t;&t;  case it is already in use.&n;&t;&t;  &n;&t;&t;  Not very efficient ...&n;&t;&t;*/
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|new_dir-&gt;i_count
op_increment
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;rename lookup len %d %d -- &quot;
comma
id|new_len
comma
id|new_info.entry.flags
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_lookup_x
(paren
id|new_dir
comma
id|new_dentry
comma
l_int|0
)paren
suffix:semicolon
id|inode
op_assign
id|new_dentry-&gt;d_inode
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: partial rename for file %.*s&bslash;n&quot;
comma
id|new_info.entry.name_len
comma
id|new_info.entry.name
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;    Update f_pos so notify_change will succeed&n;&t;&t;    if the file was already in use.&n;&t;&t;  */
id|umsdos_set_dirinfo
(paren
id|inode
comma
id|new_dir
comma
id|new_info.f_pos
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* iput (inode); FIXME */
)brace
)brace
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* sticky bit set on new_dir */
id|Printk
c_func
(paren
(paren
l_string|&quot;sticky set on new &quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* sticky bit set on old_dir */
id|Printk
c_func
(paren
(paren
l_string|&quot;sticky set on old &quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
id|umsdos_unlockcreate
c_func
(paren
id|old_dir
)paren
suffix:semicolon
id|umsdos_unlockcreate
c_func
(paren
id|new_dir
)paren
suffix:semicolon
)brace
id|d_move
c_func
(paren
id|old_dentry
comma
id|new_dentry
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Setup un Symbolic link or a (pseudo) hard link&n;&t;Return a negative error code or 0 if ok.&n;*/
DECL|function|umsdos_symlink_x
r_static
r_int
id|umsdos_symlink_x
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|symname
comma
multiline_comment|/* name will point to this path */
r_int
id|mode
comma
r_char
id|flags
)paren
(brace
multiline_comment|/* #Specification: symbolic links / strategy&n;     A symbolic link is simply a file which hold a path. It is&n;     implemented as a normal MSDOS file (not very space efficient :-()&n;     &n;     I see 2 different way to do it. One is to place the link data&n;     in unused entry of the EMD file. The other is to have a separate&n;     file dedicated to hold all symbolic links data.&n;     &n;     Let&squot;s go for simplicity...&n;  */
r_int
id|ret
suffix:semicolon
id|dir-&gt;i_count
op_increment
suffix:semicolon
multiline_comment|/* We keep the inode in case we need it */
multiline_comment|/* later */
id|ret
op_assign
id|umsdos_create_any
(paren
id|dir
comma
id|dentry
comma
id|mode
comma
l_int|0
comma
id|flags
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_symlink ret %d &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_int
id|len
op_assign
id|strlen
c_func
(paren
id|symname
)paren
suffix:semicolon
r_struct
id|file
id|filp
suffix:semicolon
id|loff_t
id|myofs
op_assign
l_int|0
suffix:semicolon
id|fill_new_filp
(paren
op_amp
id|filp
comma
id|dentry
)paren
suffix:semicolon
multiline_comment|/* Make the inode acceptable to MSDOS FIXME */
id|Printk
(paren
(paren
id|KERN_WARNING
l_string|&quot;umsdos_symlink_x: /mn/ Is this ok?&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_WARNING
l_string|&quot;   symname=%s ; dentry name=%.*s (ino=%lu)&bslash;n&quot;
comma
id|symname
comma
(paren
r_int
)paren
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_inode-&gt;i_ino
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_file_write_kmem_real
(paren
op_amp
id|filp
comma
id|symname
comma
id|len
comma
op_amp
id|myofs
)paren
suffix:semicolon
multiline_comment|/* dput(dentry); ?? where did this come from FIXME */
r_if
c_cond
(paren
id|ret
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ret
op_ne
id|len
)paren
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
id|printk
(paren
l_string|&quot;UMSDOS: &quot;
l_string|&quot;Can&squot;t write symbolic link data&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|UMSDOS_unlink
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
id|dir
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* d_instantiate(dentry,dir);   //already done in umsdos_create_any */
id|Printk
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;  Setup un Symbolic link.&n;  Return a negative error code or 0 if ok.&n;*/
DECL|function|UMSDOS_symlink
r_int
id|UMSDOS_symlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|symname
)paren
(brace
r_return
id|umsdos_symlink_x
(paren
id|dir
comma
id|dentry
comma
id|symname
comma
id|S_IFLNK
op_or
l_int|0777
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  Add a link to an inode in a directory&n;*/
DECL|function|UMSDOS_link
r_int
id|UMSDOS_link
(paren
r_struct
id|dentry
op_star
id|olddentry
comma
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|oldinode
op_assign
id|olddentry-&gt;d_inode
suffix:semicolon
multiline_comment|/* #Specification: hard link / strategy&n;     Well ... hard link are difficult to implement on top of an&n;     MsDOS fat file system. Unlike UNIX file systems, there are no&n;     inode. A directory entry hold the functionality of the inode&n;     and the entry.&n;     &n;     We will used the same strategy as a normal Unix file system&n;     (with inode) except we will do it symbolically (using paths).&n;     &n;     Because anything can happen during a DOS session (defragment,&n;     directory sorting, etc...), we can&squot;t rely on MsDOS pseudo&n;     inode number to record the link. For this reason, the link&n;     will be done using hidden symbolic links. The following&n;     scenario illustrate how it work.&n;     &n;     Given a file /foo/file&n;     &n;     #&n;     ln /foo/file /tmp/file2&n;     &n;     become internally&n;     &n;     mv /foo/file /foo/-LINK1&n;     ln -s /foo/-LINK1 /foo/file&n;     ln -s /foo/-LINK1 /tmp/file2&n;     #&n;     &n;     Using this strategy, we can operate on /foo/file or /foo/file2.&n;     We can remove one and keep the other, like a normal Unix hard link.&n;     We can rename /foo/file or /tmp/file2 independently.&n;     &n;     The entry -LINK1 will be hidden. It will hold a link count.&n;     When all link are erased, the hidden file is erased too.&n;  */
multiline_comment|/* #Specification: weakness / hard link&n;     The strategy for hard link introduces a side effect that&n;     may or may not be acceptable. Here is the sequence&n;     &n;     #&n;     mkdir subdir1&n;     touch subdir1/file&n;     mkdir subdir2&n;     ln    subdir1/file subdir2/file&n;     rm    subdir1/file&n;     rmdir subdir1&n;     rmdir: subdir1: Directory not empty&n;     #&n;     &n;     This happen because there is an invisible file (--link) in&n;     subdir1 which is referenced by subdir2/file.&n;     &n;     Any idea ?&n;  */
multiline_comment|/* #Specification: weakness / hard link / rename directory&n;     Another weakness of hard link come from the fact that&n;     it is based on hidden symbolic links. Here is an example.&n;     &n;     #&n;     mkdir /subdir1&n;     touch /subdir1/file&n;     mkdir /subdir2&n;     ln    /subdir1/file subdir2/file&n;     mv    /subdir1 subdir3&n;     ls -l /subdir2/file&n;     #&n;     &n;     Since /subdir2/file is a hidden symbolic link&n;     to /subdir1/..hlinkNNN, accessing it will fail since&n;     /subdir1 does not exist anymore (has been renamed).&n;  */
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|oldinode-&gt;i_mode
)paren
)paren
(brace
multiline_comment|/* #Specification: hard link / directory&n;       A hard link can&squot;t be made on a directory. EPERM is returned&n;       in this case.&n;    */
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|umsdos_nevercreat
c_func
(paren
id|dir
comma
id|dentry
comma
op_minus
id|EPERM
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_struct
id|inode
op_star
id|olddir
suffix:semicolon
id|ret
op_assign
id|umsdos_get_dirowner
c_func
(paren
id|oldinode
comma
op_amp
id|olddir
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_link dir_owner = %lu -&gt; %p [%d] &quot;
comma
id|oldinode-&gt;u.umsdos_i.i_dir_owner
comma
id|olddir
comma
id|olddir-&gt;i_count
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
id|umsdos_lockcreate2
c_func
(paren
id|dir
comma
id|olddir
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_inode2entry
(paren
id|olddir
comma
id|oldinode
comma
op_amp
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;umsdos_link :%.*s: ino %lu flags %d &quot;
comma
id|entry.name_len
comma
id|entry.name
comma
id|oldinode-&gt;i_ino
comma
id|entry.flags
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|entry.flags
op_amp
id|UMSDOS_HIDDEN
)paren
)paren
(brace
multiline_comment|/* #Specification: hard link / first hard link&n;&t;     The first time a hard link is done on a file, this&n;&t;     file must be renamed and hidden. Then an internal&n;&t;     symbolic link must be done on the hidden file.&n;&t;     &n;&t;     The second link is done after on this hidden file.&n;&t;     &n;&t;     It is expected that the Linux MSDOS file system&n;&t;     keeps the same pseudo inode when a rename operation&n;&t;     is done on a file in the same directory.&n;&t;  */
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|ret
op_assign
id|umsdos_newhidden
(paren
id|olddir
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;olddir[%d] &quot;
comma
id|olddir-&gt;i_count
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_rename_f
c_func
(paren
id|olddentry-&gt;d_inode
comma
id|olddentry
comma
id|dir
comma
id|dentry
comma
id|UMSDOS_HIDDEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_char
op_star
id|path
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|PATH_MAX
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|path
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
r_struct
id|dentry
op_star
id|temp
suffix:semicolon
id|temp
op_assign
id|creat_dentry
(paren
id|entry.name
comma
id|entry.name_len
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;olddir[%d] &quot;
comma
id|olddir-&gt;i_count
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_locate_path
(paren
id|oldinode
comma
id|path
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;olddir[%d] &quot;
comma
id|olddir-&gt;i_count
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|olddir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|umsdos_symlink_x
(paren
id|olddir
comma
id|temp
comma
id|path
comma
id|S_IFREG
op_or
l_int|0777
comma
id|UMSDOS_HLINK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|umsdos_symlink_x
(paren
id|dir
comma
id|dentry
comma
id|path
comma
id|S_IFREG
op_or
l_int|0777
comma
id|UMSDOS_HLINK
)paren
suffix:semicolon
)brace
)brace
id|kfree
(paren
id|path
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
r_char
op_star
id|path
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|PATH_MAX
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|path
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
id|umsdos_locate_path
(paren
id|oldinode
comma
id|path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|umsdos_symlink_x
(paren
id|dir
comma
id|dentry
comma
id|path
comma
id|S_IFREG
op_or
l_int|0777
comma
id|UMSDOS_HLINK
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|path
)paren
suffix:semicolon
)brace
)brace
)brace
id|umsdos_unlockcreate
c_func
(paren
id|olddir
)paren
suffix:semicolon
id|umsdos_unlockcreate
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
multiline_comment|/* iput (olddir); FIXME */
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|iattr
id|newattrs
suffix:semicolon
id|oldinode-&gt;i_nlink
op_increment
suffix:semicolon
id|newattrs.ia_valid
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|UMSDOS_notify_change
c_func
(paren
id|olddentry
comma
op_amp
id|newattrs
)paren
suffix:semicolon
)brace
multiline_comment|/*  dput (olddentry);&n;  dput (dentry); FIXME.... */
id|Printk
(paren
(paren
l_string|&quot;umsdos_link %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;  Add a new file into the alternate directory.&n;  The file is added to the real MSDOS directory. If successful, it&n;  is then added to the EDM file.&n;  &n;  Return the status of the operation. 0 mean success.&n;*/
DECL|function|UMSDOS_create
r_int
id|UMSDOS_create
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
multiline_comment|/* Permission bit + file type ??? */
)paren
multiline_comment|/* Will hold the inode of the newly created */
multiline_comment|/* file */
(brace
r_return
id|umsdos_create_any
(paren
id|dir
comma
id|dentry
comma
id|mode
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Add a sub-directory in a directory&n;*/
DECL|function|UMSDOS_mkdir
r_int
id|UMSDOS_mkdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_int
id|ret
op_assign
id|umsdos_nevercreat
c_func
(paren
id|dir
comma
id|dentry
comma
op_minus
id|EEXIST
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|ret
op_assign
id|umsdos_parse
(paren
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
op_amp
id|info
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_mkdir %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|info.entry.mode
op_assign
id|mode
op_or
id|S_IFDIR
suffix:semicolon
id|info.entry.rdev
op_assign
l_int|0
suffix:semicolon
id|info.entry.uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|info.entry.gid
op_assign
(paren
id|dir-&gt;i_mode
op_amp
id|S_ISGID
)paren
ques
c_cond
id|dir-&gt;i_gid
suffix:colon
id|current-&gt;fsgid
suffix:semicolon
id|info.entry.ctime
op_assign
id|info.entry.atime
op_assign
id|info.entry.mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|info.entry.flags
op_assign
l_int|0
suffix:semicolon
id|umsdos_lockcreate
c_func
(paren
id|dir
)paren
suffix:semicolon
id|info.entry.nlink
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
id|umsdos_newentry
(paren
id|dir
comma
op_amp
id|info
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;newentry %d &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|dentry
op_star
id|temp
comma
op_star
id|tdir
suffix:semicolon
id|tdir
op_assign
id|creat_dentry
(paren
l_string|&quot;mkd-dir&quot;
comma
l_int|7
comma
id|dir
comma
l_int|NULL
)paren
suffix:semicolon
id|temp
op_assign
id|creat_dentry
(paren
id|info.fake.fname
comma
id|info.fake.len
comma
l_int|NULL
comma
id|tdir
)paren
suffix:semicolon
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|msdos_mkdir
(paren
id|dir
comma
id|temp
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|umsdos_delentry
(paren
id|dir
comma
op_amp
id|info
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* #Specification: mkdir / Directory already exist in DOS&n;&t;     We do the same thing as for file creation.&n;&t;     For all user it is an error.&n;&t;  */
)brace
r_else
(brace
multiline_comment|/* #Specification: mkdir / umsdos directory / create EMD&n;&t;     When we created a new sub-directory in a UMSDOS&n;&t;     directory (one with full UMSDOS semantic), we&n;&t;     create immediately an EMD file in the new&n;&t;     sub-directory so it inherit UMSDOS semantic.&n;&t;  */
r_struct
id|inode
op_star
id|subdir
suffix:semicolon
id|ret
op_assign
id|compat_umsdos_real_lookup
(paren
id|dir
comma
id|info.fake.fname
comma
id|info.fake.len
comma
op_amp
id|subdir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|dentry
op_star
id|tdentry
comma
op_star
id|tdsub
suffix:semicolon
id|tdsub
op_assign
id|creat_dentry
(paren
l_string|&quot;mkd-emd&quot;
comma
l_int|7
comma
id|subdir
comma
l_int|NULL
)paren
suffix:semicolon
id|tdentry
op_assign
id|creat_dentry
(paren
id|UMSDOS_EMD_FILE
comma
id|UMSDOS_EMD_NAMELEN
comma
l_int|NULL
comma
id|tdsub
)paren
suffix:semicolon
id|ret
op_assign
id|msdos_create
(paren
id|subdir
comma
id|tdentry
comma
id|S_IFREG
op_or
l_int|0777
)paren
suffix:semicolon
id|kill_dentry
(paren
id|tdentry
)paren
suffix:semicolon
multiline_comment|/* we don&squot;t want empty EMD file to be visible ! too bad kill_dentry does nothing at the moment :-)  FIXME */
id|kill_dentry
(paren
id|tdsub
)paren
suffix:semicolon
id|umsdos_setup_dir_inode
(paren
id|subdir
)paren
suffix:semicolon
multiline_comment|/* this should setup dir so it is promoted to EMD, and EMD file is not visible inside it */
id|subdir
op_assign
l_int|NULL
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|temp-&gt;d_inode
)paren
suffix:semicolon
multiline_comment|/* iput (result); FIXME */
)brace
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: Can&squot;t create empty --linux-.---&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* iput (subdir); FIXME */
)brace
)brace
id|umsdos_unlockcreate
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
)brace
id|Printk
(paren
(paren
l_string|&quot;umsdos_mkdir %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
multiline_comment|/* dput (dentry); / * FIXME /mn/ */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Add a new device special file into a directory.&n;*/
DECL|function|UMSDOS_mknod
r_int
id|UMSDOS_mknod
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
comma
r_int
id|rdev
)paren
(brace
multiline_comment|/* #Specification: Special files / strategy&n;     Device special file, pipes, etc ... are created like normal&n;     file in the msdos file system. Of course they remain empty.&n;     &n;     One strategy was to create those files only in the EMD file&n;     since they were not important for MSDOS. The problem with&n;     that, is that there were not getting inode number allocated.&n;     The MSDOS filesystems is playing a nice game to fake inode&n;     number, so why not use it.&n;     &n;     The absence of inode number compatible with those allocated&n;     for ordinary files was causing major trouble with hard link&n;     in particular and other parts of the kernel I guess.&n;  */
r_int
id|ret
op_assign
id|umsdos_create_any
(paren
id|dir
comma
id|dentry
comma
id|mode
comma
id|rdev
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* dput(dentry); / * /mn/ FIXME! */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;  Remove a sub-directory.&n;*/
DECL|function|UMSDOS_rmdir
r_int
id|UMSDOS_rmdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
multiline_comment|/* #Specification: style / iput strategy&n;     In the UMSDOS project, I am trying to apply a single&n;     programming style regarding inode management. Many&n;     entry point are receiving an inode to act on, and must&n;     do an iput() as soon as they are finished with&n;     the inode.&n;     &n;     For simple case, there is no problem. When you introduce&n;     error checking, you end up with many iput placed around the&n;     code.&n;     &n;     The coding style I use all around is one where I am trying&n;     to provide independent flow logic (I don&squot;t know how to&n;     name this). With this style, code is easier to understand&n;     but you rapidly get iput() all around. Here is an exemple&n;     of what I am trying to avoid.&n;     &n;     #&n;     if (a){&n;     ...&n;     if(b){&n;     ...&n;     }&n;     ...&n;     if (c){&n;     // Complex state. Was b true ? &n;     ...&n;     }&n;     ...&n;     }&n;     // Weird state&n;     if (d){&n;     // ...&n;     }&n;     // Was iput finally done ?&n;     return status;&n;     #&n;     &n;     Here is the style I am using. Still sometime I do the&n;     first when things are very simple (or very complicated :-( )&n;     &n;     #&n;     if (a){&n;     if (b){&n;     ...&n;     }else if (c){&n;     // A single state gets here&n;     }&n;     }else if (d){&n;     ...&n;     }&n;     return status;&n;     #&n;     &n;     Again, while this help clarifying the code, I often get a lot&n;     of iput(), unlike the first style, where I can place few &n;     &quot;strategic&quot; iput(). &quot;strategic&quot; also mean, more difficult&n;     to place.&n;     &n;     So here is the style I will be using from now on in this project.&n;     There is always an iput() at the end of a function (which has&n;     to do an iput()). One iput by inode. There is also one iput()&n;     at the places where a successful operation is achieved. This&n;     iput() is often done by a sub-function (often from the msdos&n;     file system). So I get one too many iput() ? At the place&n;     where an iput() is done, the inode is simply nulled, disabling&n;     the last one.&n;     &n;     #&n;     if (a){&n;     if (b){&n;     ...&n;     }else if (c){&n;     msdos_rmdir(dir,...);&n;     dir = NULL;&n;     }&n;     }else if (d){&n;     ...&n;     }&n;     iput (dir);&n;     return status;&n;     #&n;     &n;     Note that the umsdos_lockcreate() and umsdos_unlockcreate() function&n;     pair goes against this practice of &quot;forgetting&quot; the inode as soon&n;     as possible.&n;  */
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|umsdos_nevercreat
c_func
(paren
id|dir
comma
id|dentry
comma
op_minus
id|EPERM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_volatile
r_struct
id|inode
op_star
id|sdir
suffix:semicolon
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|umsdos_lookup_x
(paren
id|dir
comma
id|dentry
comma
l_int|0
)paren
suffix:semicolon
id|sdir
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;rmdir lookup %d &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_int
id|empty
suffix:semicolon
id|umsdos_lockcreate
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sdir-&gt;i_count
OG
l_int|1
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; /mn/ rmdir: FIXME EBUSY: hmmm, i_count is %d &gt; 1&bslash;n&quot;
comma
id|sdir-&gt;i_count
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|empty
op_assign
id|umsdos_isempty
(paren
id|sdir
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_struct
id|dentry
op_star
id|tdentry
comma
op_star
id|tedir
suffix:semicolon
id|tedir
op_assign
id|creat_dentry
(paren
l_string|&quot;emd-rmd&quot;
comma
l_int|7
comma
id|dir
comma
l_int|NULL
)paren
suffix:semicolon
id|tdentry
op_assign
id|creat_dentry
(paren
id|UMSDOS_EMD_FILE
comma
id|UMSDOS_EMD_NAMELEN
comma
l_int|NULL
comma
id|tedir
)paren
suffix:semicolon
id|umsdos_real_lookup
(paren
id|dir
comma
id|tdentry
)paren
suffix:semicolon
multiline_comment|/* fill inode part */
id|Printk
(paren
(paren
l_string|&quot;isempty %d i_count %d &quot;
comma
id|empty
comma
id|sdir-&gt;i_count
)paren
)paren
suffix:semicolon
multiline_comment|/* check sticky bit */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dir-&gt;i_mode
op_amp
id|S_ISVTX
)paren
op_logical_or
id|capable
c_func
(paren
id|CAP_FOWNER
)paren
op_logical_or
id|current-&gt;fsuid
op_eq
id|sdir-&gt;i_uid
op_logical_or
id|current-&gt;fsuid
op_eq
id|dir-&gt;i_uid
)paren
(brace
r_if
c_cond
(paren
id|empty
op_eq
l_int|1
)paren
(brace
multiline_comment|/* We have to remove the EMD file */
id|ret
op_assign
id|msdos_unlink
(paren
id|sdir
comma
id|tdentry
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;UMSDOS_rmdir: unlinking empty EMD ret=%d&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
id|sdir
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* sdir must be free before msdos_rmdir() */
multiline_comment|/* iput (sdir); FIXME */
id|sdir
op_assign
l_int|NULL
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;isempty ret %d nlink %d &quot;
comma
id|ret
comma
id|dir-&gt;i_nlink
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|umsdos_info
id|info
suffix:semicolon
r_struct
id|dentry
op_star
id|temp
comma
op_star
id|tdir
suffix:semicolon
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|umsdos_parse
(paren
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
op_amp
id|info
)paren
suffix:semicolon
multiline_comment|/* The findentry is there only to complete */
multiline_comment|/* the mangling */
id|umsdos_findentry
(paren
id|dir
comma
op_amp
id|info
comma
l_int|2
)paren
suffix:semicolon
id|tdir
op_assign
id|creat_dentry
(paren
l_string|&quot;dir-rmd&quot;
comma
l_int|7
comma
id|dir
comma
l_int|NULL
)paren
suffix:semicolon
id|temp
op_assign
id|creat_dentry
(paren
id|info.fake.fname
comma
id|info.fake.len
comma
l_int|NULL
comma
id|tdir
)paren
suffix:semicolon
id|umsdos_real_lookup
(paren
id|dir
comma
id|temp
)paren
suffix:semicolon
multiline_comment|/* fill inode part */
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;  rmdir start dir=%lu, dir-&gt;sb=%p&bslash;n&quot;
comma
id|dir-&gt;i_ino
comma
id|dir-&gt;i_sb
)paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: /mn/ debug only */
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;    dentry=%.*s d_count=%d ino=%lu&bslash;n&quot;
comma
(paren
r_int
)paren
id|temp-&gt;d_name.len
comma
id|temp-&gt;d_name.name
comma
id|temp-&gt;d_count
comma
id|temp-&gt;d_inode-&gt;i_ino
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;    d_parent=%.*s d_count=%d ino=%lu&bslash;n&quot;
comma
(paren
r_int
)paren
id|temp-&gt;d_parent-&gt;d_name.len
comma
id|temp-&gt;d_parent-&gt;d_name.name
comma
id|temp-&gt;d_parent-&gt;d_count
comma
id|temp-&gt;d_parent-&gt;d_inode-&gt;i_ino
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|msdos_rmdir
(paren
id|dir
comma
id|temp
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;  rmdir passed %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: /mn/ debug only */
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;  rmdir end dir=%lu, dir-&gt;sb=%p&bslash;n&quot;
comma
id|dir-&gt;i_ino
comma
id|dir-&gt;i_sb
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;    dentry=%.*s d_count=%d ino=%p&bslash;n&quot;
comma
(paren
r_int
)paren
id|temp-&gt;d_name.len
comma
id|temp-&gt;d_name.name
comma
id|temp-&gt;d_count
comma
id|temp-&gt;d_inode
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;    d_parent=%.*s d_count=%d ino=%lu&bslash;n&quot;
comma
(paren
r_int
)paren
id|temp-&gt;d_parent-&gt;d_name.len
comma
id|temp-&gt;d_parent-&gt;d_name.name
comma
id|temp-&gt;d_parent-&gt;d_count
comma
id|temp-&gt;d_parent-&gt;d_inode-&gt;i_ino
)paren
)paren
suffix:semicolon
id|kill_dentry
(paren
id|tdir
)paren
suffix:semicolon
id|kill_dentry
(paren
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|umsdos_delentry
(paren
id|dir
comma
op_amp
id|info
comma
l_int|1
)paren
suffix:semicolon
id|d_delete
(paren
id|dentry
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* sticky bit set and we don&squot;t have permission */
id|Printk
c_func
(paren
(paren
l_string|&quot;sticky set &quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;  The subdirectory is not empty, so leave it there&n;&t;*/
id|ret
op_assign
op_minus
id|ENOTEMPTY
suffix:semicolon
)brace
multiline_comment|/* iput(sdir); FIXME */
id|umsdos_unlockcreate
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*  dput(dentry); FIXME /mn/ */
id|Printk
(paren
(paren
l_string|&quot;umsdos_rmdir %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;  Remove a file from the directory.&n;*/
DECL|function|UMSDOS_unlink
r_int
id|UMSDOS_unlink
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
id|ret
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot; *** UMSDOS_unlink entering /mn/ *** &bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_nevercreat
c_func
(paren
id|dir
comma
id|dentry
comma
op_minus
id|EPERM
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;UMSDOS_unlink /mn/: nevercreat=%d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|ret
op_assign
id|umsdos_parse
(paren
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|umsdos_lockcreate
c_func
(paren
id|dir
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_findentry
c_func
(paren
id|dir
comma
op_amp
id|info
comma
l_int|1
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;UMSDOS_unlink: findentry returned %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;UMSDOS_unlink %.*s &quot;
comma
id|info.fake.len
comma
id|info.fake.fname
)paren
)paren
suffix:semicolon
multiline_comment|/* check sticky bit */
r_if
c_cond
(paren
op_logical_neg
(paren
id|dir-&gt;i_mode
op_amp
id|S_ISVTX
)paren
op_logical_or
id|capable
c_func
(paren
id|CAP_FOWNER
)paren
op_logical_or
id|current-&gt;fsuid
op_eq
id|info.entry.uid
op_logical_or
id|current-&gt;fsuid
op_eq
id|dir-&gt;i_uid
)paren
(brace
r_if
c_cond
(paren
id|info.entry.flags
op_amp
id|UMSDOS_HLINK
)paren
(brace
multiline_comment|/* #Specification: hard link / deleting a link&n;&t;       When we deletes a file, and this file is a link&n;&t;       we must subtract 1 to the nlink field of the&n;&t;       hidden link.&n;&t;       &n;&t;       If the count goes to 0, we delete this hidden&n;&t;       link too.&n;&t;    */
multiline_comment|/*&n;&t;      First, get the inode of the hidden link&n;&t;      using the standard lookup function.&n;&t;    */
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|umsdos_lookup_x
(paren
id|dir
comma
id|dentry
comma
l_int|0
)paren
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;unlink nlink = %d &quot;
comma
id|inode-&gt;i_nlink
)paren
)paren
suffix:semicolon
id|inode-&gt;i_nlink
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_nlink
op_eq
l_int|0
)paren
(brace
r_struct
id|inode
op_star
id|hdir
op_assign
id|iget
c_func
(paren
id|inode-&gt;i_sb
comma
id|inode-&gt;u.umsdos_i.i_dir_owner
)paren
suffix:semicolon
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
id|ret
op_assign
id|umsdos_inode2entry
(paren
id|hdir
comma
id|inode
comma
op_amp
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|UMSDOS_unlink
(paren
id|hdir
comma
id|dentry
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* iput (hdir); FIXME */
)brace
)brace
r_else
(brace
r_struct
id|iattr
id|newattrs
suffix:semicolon
id|newattrs.ia_valid
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|UMSDOS_notify_change
(paren
id|dentry
comma
op_amp
id|newattrs
)paren
suffix:semicolon
)brace
multiline_comment|/* iput (inode); FIXME */
)brace
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|umsdos_delentry
(paren
id|dir
comma
op_amp
id|info
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|dentry
op_star
id|temp
comma
op_star
id|tdir
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;Avant msdos_unlink %.*s &quot;
comma
id|info.fake.len
comma
id|info.fake.fname
)paren
)paren
suffix:semicolon
id|dir-&gt;i_count
op_increment
suffix:semicolon
multiline_comment|/* FIXME /mn/ is this needed anymore now that msdos_unlink locks dir using d_parent ? */
id|tdir
op_assign
id|creat_dentry
(paren
l_string|&quot;dir-del&quot;
comma
l_int|7
comma
id|dir
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* FIXME /mn/: do we need iget(dir-&gt;i_ino) or would dir itself suffice ? */
id|temp
op_assign
id|creat_dentry
(paren
id|info.fake.fname
comma
id|info.fake.len
comma
l_int|NULL
comma
id|tdir
)paren
suffix:semicolon
id|umsdos_real_lookup
(paren
id|dir
comma
id|temp
)paren
suffix:semicolon
multiline_comment|/* fill inode part */
id|ret
op_assign
id|msdos_unlink_umsdos
(paren
id|dir
comma
id|temp
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;msdos_unlink %.*s %o ret %d &quot;
comma
id|info.fake.len
comma
id|info.fake.fname
comma
id|info.entry.mode
comma
id|ret
)paren
)paren
suffix:semicolon
id|d_delete
(paren
id|dentry
)paren
suffix:semicolon
id|kill_dentry
(paren
id|tdir
)paren
suffix:semicolon
id|kill_dentry
(paren
id|temp
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* sticky bit set and we&squot;ve not got permission */
id|Printk
c_func
(paren
(paren
l_string|&quot;sticky set &quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
id|umsdos_unlockcreate
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* dput(dentry); FIXME: shouldn&squot;t this be done in msdos_unlink ? */
id|Printk
(paren
(paren
l_string|&quot;umsdos_unlink %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Rename a file (move) in the file system.&n;*/
DECL|function|UMSDOS_rename
r_int
id|UMSDOS_rename
c_func
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_struct
id|dentry
op_star
id|new_dentry
)paren
(brace
multiline_comment|/* #Specification: weakness / rename&n;     There is a case where UMSDOS rename has a different behavior&n;     than normal UNIX file system. Renaming an open file across&n;     directory boundary does not work. Renaming an open file within&n;     a directory does work however.&n;     &n;     The problem (not sure) is in the linux VFS msdos driver.&n;     I believe this is not a bug but a design feature, because&n;     an inode number represent some sort of directory address&n;     in the MSDOS directory structure. So moving the file into&n;     another directory does not preserve the inode number.&n;  */
r_int
id|ret
op_assign
id|umsdos_nevercreat
c_func
(paren
id|new_dir
comma
id|new_dentry
comma
op_minus
id|EEXIST
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/* umsdos_rename_f eat the inode and we may need those later */
id|old_dir-&gt;i_count
op_increment
suffix:semicolon
id|new_dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|umsdos_rename_f
(paren
id|old_dir
comma
id|old_dentry
comma
id|new_dir
comma
id|new_dentry
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EEXIST
)paren
(brace
multiline_comment|/* #Specification: rename / new name exist&n;&t; If the destination name already exist, it will&n;&t; silently be removed. EXT2 does it this way&n;&t; and this is the spec of SUNOS. So does UMSDOS.&n;&t; &n;&t; If the destination is an empty directory it will&n;&t; also be removed.&n;      */
multiline_comment|/* #Specification: rename / new name exist / possible flaw&n;&t; The code to handle the deletion of the target (file&n;&t; and directory) use to be in umsdos_rename_f, surrounded&n;&t; by proper directory locking. This was insuring that only&n;&t; one process could achieve a rename (modification) operation&n;&t; in the source and destination directory. This was also&n;&t; insuring the operation was &quot;atomic&quot;.&n;&t; &n;&t; This has been changed because this was creating a kernel&n;&t; stack overflow (stack is only 4k in the kernel). To avoid&n;&t; the code doing the deletion of the target (if exist) has&n;&t; been moved to a upper layer. umsdos_rename_f is tried&n;&t; once and if it fails with EEXIST, the target is removed&n;&t; and umsdos_rename_f is done again.&n;&t; &n;&t; This makes the code cleaner and (not sure) solve a&n;&t; deadlock problem one tester was experiencing.&n;&t; &n;&t; The point is to mention that possibly, the semantic of&n;&t; &quot;rename&quot; may be wrong. Anyone dare to check that :-)&n;&t; Be aware that IF it is wrong, to produce the problem you&n;&t; will need two process trying to rename a file to the&n;&t; same target at the same time. Again, I am not sure it&n;&t; is a problem at all.&n;      */
multiline_comment|/* This is not super efficient but should work */
id|new_dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|UMSDOS_unlink
(paren
id|new_dir
comma
id|new_dentry
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;rename unlink ret %d -- &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EISDIR
)paren
(brace
id|new_dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
id|UMSDOS_rmdir
(paren
id|new_dir
comma
id|new_dentry
)paren
suffix:semicolon
id|chkstk
c_func
(paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;rename rmdir ret %d -- &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|umsdos_rename_f
c_func
(paren
id|old_dir
comma
id|old_dentry
comma
id|new_dir
comma
id|new_dentry
comma
l_int|0
)paren
suffix:semicolon
id|new_dir
op_assign
id|old_dir
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;  dput (new_dentry);&n;  dput (old_dentry); FIXME /mn/ */
r_return
id|ret
suffix:semicolon
)brace
eof
