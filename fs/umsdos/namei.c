multiline_comment|/*&n; *  linux/fs/umsdos/namei.c&n; *&n; *      Written 1993 by Jacques Gelinas &n; *      Inspired from linux/fs/msdos/... by Werner Almesberger&n; *&n; * Maintain and access the --linux alternate directory file.&n; */
multiline_comment|/*&n;  * You are in the maze of twisted functions - half of them shouldn&squot;t&n;  * be here...&n;  */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/msdos_fs.h&gt;
macro_line|#include &lt;linux/umsdos_fs.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
DECL|macro|UMSDOS_DIR_LOCK
mdefine_line|#define UMSDOS_DIR_LOCK
macro_line|#ifdef UMSDOS_DIR_LOCK
DECL|function|u_sleep_on
r_static
r_inline
r_void
id|u_sleep_on
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
id|sleep_on
(paren
op_amp
id|dir-&gt;u.umsdos_i.dir_info.p
)paren
suffix:semicolon
)brace
DECL|function|u_wake_up
r_static
r_inline
r_void
id|u_wake_up
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
id|wake_up
(paren
op_amp
id|dir-&gt;u.umsdos_i.dir_info.p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for creation exclusivity.&n; * Return 0 if the dir was already available.&n; * Return 1 if a wait was necessary.&n; * When 1 is return, it means a wait was done. It does not&n; * mean the directory is available.&n; */
DECL|function|umsdos_waitcreate
r_static
r_int
id|umsdos_waitcreate
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.dir_info.creating
op_logical_and
id|dir-&gt;u.umsdos_i.dir_info.pid
op_ne
id|current-&gt;pid
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;creating &amp;&amp; dir_info.pid=%lu, current-&gt;pid=%u&bslash;n&quot;
comma
id|dir-&gt;u.umsdos_i.dir_info.pid
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
id|u_sleep_on
(paren
id|dir
)paren
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for any lookup process to finish&n; */
DECL|function|umsdos_waitlookup
r_static
r_void
id|umsdos_waitlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
r_while
c_loop
(paren
id|dir-&gt;u.umsdos_i.dir_info.looking
)paren
(brace
id|u_sleep_on
(paren
id|dir
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Lock all other process out of this directory.&n; */
multiline_comment|/* #Specification: file creation / not atomic&n; * File creation is a two step process. First we create (allocate)&n; * an entry in the EMD file and then (using the entry offset) we&n; * build a unique name for MSDOS. We create this name in the msdos&n; * space.&n; * &n; * We have to use semaphore (sleep_on/wake_up) to prevent lookup&n; * into a directory when we create a file or directory and to&n; * prevent creation while a lookup is going on. Since many lookup&n; * may happen at the same time, the semaphore is a counter.&n; * &n; * Only one creation is allowed at the same time. This protection&n; * may not be necessary. The problem arise mainly when a lookup&n; * or a readdir is done while a file is partially created. The&n; * lookup process see that as a &quot;normal&quot; problem and silently&n; * erase the file from the EMD file. Normal because a file&n; * may be erased during a MSDOS session, but not removed from&n; * the EMD file.&n; * &n; * The locking is done on a directory per directory basis. Each&n; * directory inode has its wait_queue.&n; * &n; * For some operation like hard link, things even get worse. Many&n; * creation must occur at once (atomic). To simplify the design&n; * a process is allowed to recursively lock the directory for&n; * creation. The pid of the locking process is kept along with&n; * a counter so a second level of locking is granted or not.&n; */
DECL|function|umsdos_lockcreate
r_void
id|umsdos_lockcreate
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
multiline_comment|/*&n;&t; * Wait for any creation process to finish except&n;&t; * if we (the process) own the lock&n;&t; */
r_while
c_loop
(paren
id|umsdos_waitcreate
(paren
id|dir
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|dir-&gt;u.umsdos_i.dir_info.creating
op_increment
suffix:semicolon
id|dir-&gt;u.umsdos_i.dir_info.pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|umsdos_waitlookup
(paren
id|dir
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Lock all other process out of those two directories.&n; */
DECL|function|umsdos_lockcreate2
r_static
r_void
id|umsdos_lockcreate2
(paren
r_struct
id|inode
op_star
id|dir1
comma
r_struct
id|inode
op_star
id|dir2
)paren
(brace
multiline_comment|/*&n;&t; * We must check that both directory are available before&n;&t; * locking anyone of them. This is to avoid some deadlock.&n;&t; * Thanks to dglaude@is1.vub.ac.be (GLAUDE DAVID) for pointing&n;&t; * this to me.&n;&t; */
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|umsdos_waitcreate
(paren
id|dir1
)paren
op_eq
l_int|0
op_logical_and
id|umsdos_waitcreate
(paren
id|dir2
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We own both now */
id|dir1-&gt;u.umsdos_i.dir_info.creating
op_increment
suffix:semicolon
id|dir1-&gt;u.umsdos_i.dir_info.pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|dir2-&gt;u.umsdos_i.dir_info.creating
op_increment
suffix:semicolon
id|dir2-&gt;u.umsdos_i.dir_info.pid
op_assign
id|current-&gt;pid
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|umsdos_waitlookup
(paren
id|dir1
)paren
suffix:semicolon
id|umsdos_waitlookup
(paren
id|dir2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait until creation is finish in this directory.&n; */
DECL|function|umsdos_startlookup
r_void
id|umsdos_startlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
r_while
c_loop
(paren
id|umsdos_waitcreate
(paren
id|dir
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|dir-&gt;u.umsdos_i.dir_info.looking
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; * Unlock the directory.&n; */
DECL|function|umsdos_unlockcreate
r_void
id|umsdos_unlockcreate
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
id|dir-&gt;u.umsdos_i.dir_info.creating
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.dir_info.creating
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: dir-&gt;u.umsdos_i.dir_info.creating &lt; 0: %d&quot;
comma
id|dir-&gt;u.umsdos_i.dir_info.creating
)paren
suffix:semicolon
)brace
id|u_wake_up
(paren
id|dir
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Tell directory lookup is over.&n; */
DECL|function|umsdos_endlookup
r_void
id|umsdos_endlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
id|dir-&gt;u.umsdos_i.dir_info.looking
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.dir_info.looking
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: dir-&gt;u.umsdos_i.dir_info.looking &lt; 0: %d&quot;
comma
id|dir-&gt;u.umsdos_i.dir_info.looking
)paren
suffix:semicolon
)brace
id|u_wake_up
(paren
id|dir
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|umsdos_lockcreate
r_static
r_void
id|umsdos_lockcreate
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
)brace
DECL|function|umsdos_lockcreate2
r_static
r_void
id|umsdos_lockcreate2
(paren
r_struct
id|inode
op_star
id|dir1
comma
r_struct
id|inode
op_star
id|dir2
)paren
(brace
)brace
DECL|function|umsdos_startlookup
r_void
id|umsdos_startlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
)brace
DECL|function|umsdos_unlockcreate
r_static
r_void
id|umsdos_unlockcreate
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
)brace
DECL|function|umsdos_endlookup
r_void
id|umsdos_endlookup
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
)brace
macro_line|#endif
DECL|function|umsdos_nevercreat
r_static
r_int
id|umsdos_nevercreat
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|errcod
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_is_pseudodos
(paren
id|dir
comma
id|dentry
)paren
)paren
(brace
multiline_comment|/* #Specification: pseudo root / any file creation /DOS&n;&t;&t; * The pseudo sub-directory /DOS can&squot;t be created!&n;&t;&t; * EEXIST is returned.&n;&t;&t; * &n;&t;&t; * The pseudo sub-directory /DOS can&squot;t be removed!&n;&t;&t; * EPERM is returned.&n;&t;&t; */
id|ret
op_assign
id|errcod
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a new file (ordinary or special) into the alternate directory.&n; * The file is added to the real MSDOS directory. If successful, it&n; * is then added to the EMD file.&n; * &n; * Return the status of the operation. 0 mean success.&n; *&n; * #Specification: create / file exists in DOS&n; * Here is a situation: we are trying to create a file with&n; * UMSDOS. The file is unknown to UMSDOS but already&n; * exists in the DOS directory.&n; * &n; * Here is what we are NOT doing:&n; * &n; * We could silently assume that everything is fine&n; * and allows the creation to succeed.&n; * &n; * It is possible not all files in the partition&n; * are meant to be visible from linux. By trying to create&n; * those file in some directory, one user may get access&n; * to those file without proper permissions. Looks like&n; * a security hole to me. Off course sharing a file system&n; * with DOS is some kind of security hole :-)&n; * &n; * So ?&n; * &n; * We return EEXIST in this case.&n; * The same is true for directory creation.&n; */
DECL|function|umsdos_create_any
r_static
r_int
id|umsdos_create_any
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
comma
r_int
id|rdev
comma
r_char
id|flags
)paren
(brace
r_struct
id|dentry
op_star
id|fake
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|ret
op_assign
id|umsdos_nevercreat
(paren
id|dir
comma
id|dentry
comma
op_minus
id|EEXIST
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
id|umsdos_parse
(paren
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|info.entry.mode
op_assign
id|mode
suffix:semicolon
id|info.entry.rdev
op_assign
id|rdev
suffix:semicolon
id|info.entry.flags
op_assign
id|flags
suffix:semicolon
id|info.entry.uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|info.entry.gid
op_assign
(paren
id|dir-&gt;i_mode
op_amp
id|S_ISGID
)paren
ques
c_cond
id|dir-&gt;i_gid
suffix:colon
id|current-&gt;fsgid
suffix:semicolon
id|info.entry.ctime
op_assign
id|info.entry.atime
op_assign
id|info.entry.mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|info.entry.nlink
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
id|umsdos_newentry
(paren
id|dentry-&gt;d_parent
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* do a real lookup to get the short name dentry */
id|fake
op_assign
id|umsdos_covered
c_func
(paren
id|dentry-&gt;d_parent
comma
id|info.fake.fname
comma
id|info.fake.len
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|fake
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|fake
)paren
)paren
r_goto
id|out_remove
suffix:semicolon
multiline_comment|/* should not exist yet ... */
id|ret
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|fake-&gt;d_inode
)paren
r_goto
id|out_remove_dput
suffix:semicolon
id|ret
op_assign
id|msdos_create
(paren
id|dir
comma
id|fake
comma
id|S_IFREG
op_or
l_int|0777
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_remove_dput
suffix:semicolon
id|inode
op_assign
id|fake-&gt;d_inode
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
suffix:semicolon
id|d_instantiate
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|dput
c_func
(paren
id|fake
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;umsdos_create_any: %s/%s, ino=%ld, icount=%d??&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|inode-&gt;i_ino
comma
id|atomic_read
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
)paren
suffix:semicolon
)brace
id|umsdos_lookup_patch_new
c_func
(paren
id|dentry
comma
op_amp
id|info
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
multiline_comment|/* Creation failed ... remove the EMD entry */
id|out_remove_dput
suffix:colon
id|dput
c_func
(paren
id|fake
)paren
suffix:semicolon
id|out_remove
suffix:colon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EEXIST
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;UMSDOS: out of sync, deleting %s/%s&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|info.fake.fname
)paren
suffix:semicolon
id|umsdos_delentry
(paren
id|dentry-&gt;d_parent
comma
op_amp
id|info
comma
id|S_ISDIR
(paren
id|info.entry.mode
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a new file into the alternate directory.&n; * The file is added to the real MSDOS directory. If successful, it&n; * is then added to the EMD file.&n; * &n; * Return the status of the operation. 0 mean success.&n; */
DECL|function|UMSDOS_create
r_int
id|UMSDOS_create
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_return
id|umsdos_create_any
(paren
id|dir
comma
id|dentry
comma
id|mode
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialise the new_entry from the old for a rename operation.&n; * (Only useful for umsdos_rename_f() below).&n; */
DECL|function|umsdos_ren_init
r_static
r_void
id|umsdos_ren_init
(paren
r_struct
id|umsdos_info
op_star
id|new_info
comma
r_struct
id|umsdos_info
op_star
id|old_info
)paren
(brace
id|new_info-&gt;entry.mode
op_assign
id|old_info-&gt;entry.mode
suffix:semicolon
id|new_info-&gt;entry.rdev
op_assign
id|old_info-&gt;entry.rdev
suffix:semicolon
id|new_info-&gt;entry.uid
op_assign
id|old_info-&gt;entry.uid
suffix:semicolon
id|new_info-&gt;entry.gid
op_assign
id|old_info-&gt;entry.gid
suffix:semicolon
id|new_info-&gt;entry.ctime
op_assign
id|old_info-&gt;entry.ctime
suffix:semicolon
id|new_info-&gt;entry.atime
op_assign
id|old_info-&gt;entry.atime
suffix:semicolon
id|new_info-&gt;entry.mtime
op_assign
id|old_info-&gt;entry.mtime
suffix:semicolon
id|new_info-&gt;entry.flags
op_assign
id|old_info-&gt;entry.flags
suffix:semicolon
id|new_info-&gt;entry.nlink
op_assign
id|old_info-&gt;entry.nlink
suffix:semicolon
)brace
multiline_comment|/*&n; * Rename a file (move) in the file system.&n; */
DECL|function|umsdos_rename_f
r_static
r_int
id|umsdos_rename_f
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_struct
id|dentry
op_star
id|new_dentry
comma
r_int
id|flags
)paren
(brace
r_struct
id|inode
op_star
id|old_inode
op_assign
id|old_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|dentry
op_star
id|old
comma
op_star
r_new
comma
op_star
id|old_emd
suffix:semicolon
r_int
id|err
comma
id|ret
suffix:semicolon
r_struct
id|umsdos_info
id|old_info
suffix:semicolon
r_struct
id|umsdos_info
id|new_info
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
id|err
op_assign
id|umsdos_parse
(paren
id|old_dentry-&gt;d_name.name
comma
id|old_dentry-&gt;d_name.len
comma
op_amp
id|old_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|umsdos_parse
(paren
id|new_dentry-&gt;d_name.name
comma
id|new_dentry-&gt;d_name.len
comma
op_amp
id|new_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* Get the EMD dentry for the old parent */
id|old_emd
op_assign
id|umsdos_get_emd_dentry
c_func
(paren
id|old_dentry-&gt;d_parent
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|old_emd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|old_emd
)paren
)paren
r_goto
id|out
suffix:semicolon
id|umsdos_lockcreate2
(paren
id|old_dir
comma
id|new_dir
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_findentry
c_func
(paren
id|old_emd-&gt;d_parent
comma
op_amp
id|old_info
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_unlock
suffix:semicolon
id|err
op_assign
id|umsdos_findentry
c_func
(paren
id|new_dentry-&gt;d_parent
comma
op_amp
id|new_info
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
(brace
multiline_comment|/* check whether it _really_ exists ... */
id|ret
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|new_dentry-&gt;d_inode
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/* bogus lookup? complain and fix up the EMD ... */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;umsdos_rename_f: entry %s/%s exists, inode NULL??&bslash;n&quot;
comma
id|new_dentry-&gt;d_parent-&gt;d_name.name
comma
id|new_info.entry.name
)paren
suffix:semicolon
id|err
op_assign
id|umsdos_delentry
c_func
(paren
id|new_dentry-&gt;d_parent
comma
op_amp
id|new_info
comma
id|S_ISDIR
c_func
(paren
id|new_info.entry.mode
)paren
)paren
suffix:semicolon
)brace
id|umsdos_ren_init
(paren
op_amp
id|new_info
comma
op_amp
id|old_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
)paren
id|new_info.entry.flags
op_assign
id|flags
suffix:semicolon
id|ret
op_assign
id|umsdos_newentry
(paren
id|new_dentry-&gt;d_parent
comma
op_amp
id|new_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/* If we&squot;re moving a hardlink, drop it first */
r_if
c_cond
(paren
id|old_info.entry.flags
op_amp
id|UMSDOS_HLINK
)paren
(brace
id|d_drop
c_func
(paren
id|old_dentry
)paren
suffix:semicolon
)brace
id|old
op_assign
id|umsdos_covered
c_func
(paren
id|old_dentry-&gt;d_parent
comma
id|old_info.fake.fname
comma
id|old_info.fake.len
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|old
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|old
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/* make sure it&squot;s the same inode! */
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|old-&gt;d_inode
op_ne
id|old_inode
)paren
r_goto
id|out_dput
suffix:semicolon
r_new
op_assign
id|umsdos_covered
c_func
(paren
id|new_dentry-&gt;d_parent
comma
id|new_info.fake.fname
comma
id|new_info.fake.len
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
r_new
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
r_new
)paren
)paren
r_goto
id|out_dput
suffix:semicolon
multiline_comment|/* Do the msdos-level rename */
id|ret
op_assign
id|msdos_rename
(paren
id|old_dir
comma
id|old
comma
id|new_dir
comma
r_new
)paren
suffix:semicolon
id|dput
c_func
(paren
r_new
)paren
suffix:semicolon
multiline_comment|/* If the rename failed, remove the new EMD entry */
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|umsdos_delentry
(paren
id|new_dentry-&gt;d_parent
comma
op_amp
id|new_info
comma
id|S_ISDIR
(paren
id|new_info.entry.mode
)paren
)paren
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Rename successful ... remove the old name from the EMD.&n;&t; * Note that we use the EMD parent here, as the old dentry&n;&t; * may have moved to a new parent ...&n;&t; */
id|err
op_assign
id|umsdos_delentry
(paren
id|old_emd-&gt;d_parent
comma
op_amp
id|old_info
comma
id|S_ISDIR
(paren
id|old_info.entry.mode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
multiline_comment|/* Failed? Complain a bit, but don&squot;t fail the operation */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;umsdos_rename_f: delentry %s/%s failed, error=%d&bslash;n&quot;
comma
id|old_emd-&gt;d_parent-&gt;d_name.name
comma
id|old_info.entry.name
comma
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Update f_pos so notify_change will succeed&n;&t; * if the file was already in use.&n;&t; */
id|umsdos_set_dirinfo_new
c_func
(paren
id|old_dentry
comma
id|new_info.f_pos
)paren
suffix:semicolon
multiline_comment|/* dput() the dentry if we haven&squot;t already */
id|out_dput
suffix:colon
id|dput
c_func
(paren
id|old
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|dput
c_func
(paren
id|old_emd
)paren
suffix:semicolon
id|umsdos_unlockcreate
(paren
id|old_dir
)paren
suffix:semicolon
id|umsdos_unlockcreate
(paren
id|new_dir
)paren
suffix:semicolon
id|out
suffix:colon
id|Printk
(paren
(paren
l_string|&quot; _ret=%d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Setup a Symbolic link or a (pseudo) hard link&n; * Return a negative error code or 0 if OK.&n; */
multiline_comment|/* #Specification: symbolic links / strategy&n; * A symbolic link is simply a file which holds a path. It is&n; * implemented as a normal MSDOS file (not very space efficient :-()&n; * &n; * I see two different ways to do this: One is to place the link data&n; * in unused entries of the EMD file; the other is to have a separate&n; * file dedicated to hold all symbolic links data.&n; * &n; * Let&squot;s go for simplicity...&n; */
multiline_comment|/*&n; * AV. Should be called with dir-&gt;i_sem down.&n; */
DECL|function|umsdos_symlink_x
r_static
r_int
id|umsdos_symlink_x
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|symname
comma
r_int
id|mode
comma
r_char
id|flags
)paren
(brace
r_int
id|ret
comma
id|len
suffix:semicolon
id|ret
op_assign
id|umsdos_create_any
(paren
id|dir
comma
id|dentry
comma
id|mode
comma
l_int|0
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;umsdos_symlink: create failed, ret=%d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|len
op_assign
id|strlen
(paren
id|symname
)paren
suffix:semicolon
id|ret
op_assign
id|block_symlink
c_func
(paren
id|dentry-&gt;d_inode
comma
id|symname
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
r_goto
id|out_unlink
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
id|out_unlink
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;umsdos_symlink: write failed, unlinking&bslash;n&quot;
)paren
suffix:semicolon
id|UMSDOS_unlink
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
id|d_drop
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Setup a Symbolic link.&n; * Return a negative error code or 0 if OK.&n; */
DECL|function|UMSDOS_symlink
r_int
id|UMSDOS_symlink
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|symname
)paren
(brace
r_return
id|umsdos_symlink_x
(paren
id|dir
comma
id|dentry
comma
id|symname
comma
id|S_IFLNK
op_or
l_int|0777
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a link to an inode in a directory&n; */
DECL|function|UMSDOS_link
r_int
id|UMSDOS_link
(paren
r_struct
id|dentry
op_star
id|olddentry
comma
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|oldinode
op_assign
id|olddentry-&gt;d_inode
suffix:semicolon
r_struct
id|inode
op_star
id|olddir
op_assign
id|olddentry-&gt;d_parent-&gt;d_inode
suffix:semicolon
r_struct
id|dentry
op_star
id|temp
suffix:semicolon
r_char
op_star
id|path
suffix:semicolon
r_int
r_int
id|buffer
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_struct
id|umsdos_info
id|old_info
suffix:semicolon
r_struct
id|umsdos_info
id|hid_info
suffix:semicolon
macro_line|#ifdef UMSDOS_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;umsdos_link: new %s%s -&gt; %s/%s&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|olddentry-&gt;d_parent-&gt;d_name.name
comma
id|olddentry-&gt;d_name.name
)paren
suffix:semicolon
macro_line|#endif
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|oldinode-&gt;i_mode
)paren
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
id|umsdos_nevercreat
(paren
id|dir
comma
id|dentry
comma
op_minus
id|EPERM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|buffer
op_assign
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Lock the link parent if it&squot;s not the same directory.&n;&t; */
id|ret
op_assign
op_minus
id|EDEADLOCK
suffix:semicolon
r_if
c_cond
(paren
id|olddir
op_ne
id|dir
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|olddir-&gt;i_sem.count
)paren
OL
l_int|1
)paren
r_goto
id|out_free
suffix:semicolon
id|down
c_func
(paren
op_amp
id|olddir-&gt;i_sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Parse the name and get the visible directory entry.&n;&t; */
id|ret
op_assign
id|umsdos_parse
(paren
id|olddentry-&gt;d_name.name
comma
id|olddentry-&gt;d_name.len
comma
op_amp
id|old_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_unlock
suffix:semicolon
id|ret
op_assign
id|umsdos_findentry
(paren
id|olddentry-&gt;d_parent
comma
op_amp
id|old_info
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;UMSDOS_link: %s/%s not in EMD, ret=%d&bslash;n&quot;
comma
id|olddentry-&gt;d_parent-&gt;d_name.name
comma
id|olddentry-&gt;d_name.name
comma
id|ret
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the visible dentry is a pseudo-hardlink, the original&n;&t; * file must be already hidden.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|old_info.entry.flags
op_amp
id|UMSDOS_HLINK
)paren
)paren
(brace
r_int
id|err
suffix:semicolon
multiline_comment|/* create a hidden link name */
id|ret
op_assign
id|umsdos_newhidden
(paren
id|olddentry-&gt;d_parent
comma
op_amp
id|hid_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;umsdos_link: can&squot;t make hidden %s/%s, ret=%d&bslash;n&quot;
comma
id|olddentry-&gt;d_parent-&gt;d_name.name
comma
id|hid_info.entry.name
comma
id|ret
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Make a dentry and rename the original file ...&n;&t;&t; */
id|temp
op_assign
id|umsdos_lookup_dentry
c_func
(paren
id|olddentry-&gt;d_parent
comma
id|hid_info.entry.name
comma
id|hid_info.entry.name_len
comma
l_int|0
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|temp
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;umsdos_link: lookup %s/%s failed, ret=%d&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|hid_info.entry.name
comma
id|ret
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* rename the link to the hidden location ... */
id|ret
op_assign
id|umsdos_rename_f
c_func
(paren
id|olddir
comma
id|olddentry
comma
id|olddir
comma
id|temp
comma
id|UMSDOS_HIDDEN
)paren
suffix:semicolon
id|d_move
c_func
(paren
id|olddentry
comma
id|temp
)paren
suffix:semicolon
id|dput
c_func
(paren
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;umsdos_link: rename to %s/%s failed, ret=%d&bslash;n&quot;
comma
id|temp-&gt;d_parent-&gt;d_name.name
comma
id|temp-&gt;d_name.name
comma
id|ret
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* mark the inode as a hardlink */
id|oldinode-&gt;u.umsdos_i.i_is_hlink
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Capture the path to the hidden link.&n;&t;&t; */
id|path
op_assign
id|umsdos_d_path
c_func
(paren
id|olddentry
comma
(paren
r_char
op_star
)paren
id|buffer
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|Printk
c_func
(paren
(paren
l_string|&quot;umsdos_link: hidden link path=%s&bslash;n&quot;
comma
id|path
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Recreate a dentry for the original name and symlink it,&n;&t;&t; * then symlink the new dentry. Don&squot;t give up if one fails,&n;&t;&t; * or we&squot;ll lose the file completely!&n;&t;&t; *&n;&t;&t; * Note: this counts as the &quot;original&quot; reference, so we &n;&t;&t; * don&squot;t increment i_nlink for this one.&n;&t;&t; */
id|temp
op_assign
id|umsdos_lookup_dentry
c_func
(paren
id|olddentry-&gt;d_parent
comma
id|old_info.entry.name
comma
id|old_info.entry.name_len
comma
l_int|0
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|temp
)paren
)paren
(brace
id|ret
op_assign
id|umsdos_symlink_x
(paren
id|olddir
comma
id|temp
comma
id|path
comma
id|S_IFREG
op_or
l_int|0777
comma
id|UMSDOS_HLINK
)paren
suffix:semicolon
id|dput
c_func
(paren
id|temp
)paren
suffix:semicolon
)brace
multiline_comment|/* This symlink increments i_nlink (see below.) */
id|err
op_assign
id|umsdos_symlink_x
(paren
id|dir
comma
id|dentry
comma
id|path
comma
id|S_IFREG
op_or
l_int|0777
comma
id|UMSDOS_HLINK
)paren
suffix:semicolon
multiline_comment|/* fold the two errors */
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|err
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/* creation failed ... remove the link entry */
id|cleanup
suffix:colon
id|printk
c_func
(paren
l_string|&quot;umsdos_link: link failed, ret=%d, removing %s/%s&bslash;n&quot;
comma
id|ret
comma
id|olddentry-&gt;d_parent-&gt;d_name.name
comma
id|hid_info.entry.name
)paren
suffix:semicolon
id|err
op_assign
id|umsdos_delentry
c_func
(paren
id|olddentry-&gt;d_parent
comma
op_amp
id|hid_info
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|Printk
c_func
(paren
(paren
l_string|&quot;UMSDOS_link: %s/%s already hidden&bslash;n&quot;
comma
id|olddentry-&gt;d_parent-&gt;d_name.name
comma
id|olddentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The original file is already hidden, and we need to get &n;&t; * the dentry for its real name, not the visible name.&n;&t; * N.B. make sure it&squot;s the hidden inode ...&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|oldinode-&gt;u.umsdos_i.i_is_hlink
)paren
id|printk
c_func
(paren
l_string|&quot;UMSDOS_link: %s/%s hidden, ino=%ld not hlink??&bslash;n&quot;
comma
id|olddentry-&gt;d_parent-&gt;d_name.name
comma
id|olddentry-&gt;d_name.name
comma
id|oldinode-&gt;i_ino
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * In order to get the correct (real) inode, we just drop&n;&t; * the original dentry.&n;&t; */
id|d_drop
c_func
(paren
id|olddentry
)paren
suffix:semicolon
id|Printk
c_func
(paren
(paren
l_string|&quot;UMSDOS_link: hard link %s/%s, fake=%s&bslash;n&quot;
comma
id|olddentry-&gt;d_parent-&gt;d_name.name
comma
id|olddentry-&gt;d_name.name
comma
id|old_info.fake.fname
)paren
)paren
suffix:semicolon
multiline_comment|/* Do a real lookup to get the short name dentry */
id|temp
op_assign
id|umsdos_covered
c_func
(paren
id|olddentry-&gt;d_parent
comma
id|old_info.fake.fname
comma
id|old_info.fake.len
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|temp
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/* now resolve the link ... */
id|temp
op_assign
id|umsdos_solve_hlink
c_func
(paren
id|temp
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|temp
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|path
op_assign
id|umsdos_d_path
c_func
(paren
id|temp
comma
(paren
r_char
op_star
)paren
id|buffer
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|dput
c_func
(paren
id|temp
)paren
suffix:semicolon
id|Printk
c_func
(paren
(paren
l_string|&quot;umsdos_link: %s/%s already hidden, path=%s&bslash;n&quot;
comma
id|olddentry-&gt;d_parent-&gt;d_name.name
comma
id|olddentry-&gt;d_name.name
comma
id|path
)paren
)paren
suffix:semicolon
multiline_comment|/* finally we can symlink it ... */
id|ret
op_assign
id|umsdos_symlink_x
(paren
id|dir
comma
id|dentry
comma
id|path
comma
id|S_IFREG
op_or
l_int|0777
comma
id|UMSDOS_HLINK
)paren
suffix:semicolon
id|out_unlock
suffix:colon
multiline_comment|/* remain locked for the call to notify_change ... */
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|iattr
id|newattrs
suffix:semicolon
macro_line|#ifdef UMSDOS_PARANOIA
r_if
c_cond
(paren
op_logical_neg
id|oldinode-&gt;u.umsdos_i.i_is_hlink
)paren
id|printk
c_func
(paren
l_string|&quot;UMSDOS_link: %s/%s, ino=%ld, not marked as hlink!&bslash;n&quot;
comma
id|olddentry-&gt;d_parent-&gt;d_name.name
comma
id|olddentry-&gt;d_name.name
comma
id|oldinode-&gt;i_ino
)paren
suffix:semicolon
macro_line|#endif
id|oldinode-&gt;i_nlink
op_increment
suffix:semicolon
id|Printk
c_func
(paren
(paren
l_string|&quot;UMSDOS_link: linked %s/%s, ino=%ld, nlink=%d&bslash;n&quot;
comma
id|olddentry-&gt;d_parent-&gt;d_name.name
comma
id|olddentry-&gt;d_name.name
comma
id|oldinode-&gt;i_ino
comma
id|oldinode-&gt;i_nlink
)paren
)paren
suffix:semicolon
id|newattrs.ia_valid
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|umsdos_notify_change_locked
c_func
(paren
id|olddentry
comma
op_amp
id|newattrs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|mark_inode_dirty
c_func
(paren
id|olddentry-&gt;d_inode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|olddir
op_ne
id|dir
)paren
id|up
c_func
(paren
op_amp
id|olddir-&gt;i_sem
)paren
suffix:semicolon
id|out_free
suffix:colon
id|free_page
c_func
(paren
id|buffer
)paren
suffix:semicolon
id|out
suffix:colon
id|Printk
(paren
(paren
l_string|&quot;umsdos_link %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a sub-directory in a directory&n; */
multiline_comment|/* #Specification: mkdir / Directory already exist in DOS&n; * We do the same thing as for file creation.&n; * For all user it is an error.&n; */
multiline_comment|/* #Specification: mkdir / umsdos directory / create EMD&n; * When we created a new sub-directory in a UMSDOS&n; * directory (one with full UMSDOS semantics), we&n; * create immediately an EMD file in the new&n; * sub-directory so it inherits UMSDOS semantics.&n; */
DECL|function|UMSDOS_mkdir
r_int
id|UMSDOS_mkdir
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_struct
id|dentry
op_star
id|temp
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|ret
comma
id|err
suffix:semicolon
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|ret
op_assign
id|umsdos_nevercreat
(paren
id|dir
comma
id|dentry
comma
op_minus
id|EEXIST
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
id|umsdos_parse
(paren
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|info.entry.mode
op_assign
id|mode
op_or
id|S_IFDIR
suffix:semicolon
id|info.entry.rdev
op_assign
l_int|0
suffix:semicolon
id|info.entry.uid
op_assign
id|current-&gt;fsuid
suffix:semicolon
id|info.entry.gid
op_assign
(paren
id|dir-&gt;i_mode
op_amp
id|S_ISGID
)paren
ques
c_cond
id|dir-&gt;i_gid
suffix:colon
id|current-&gt;fsgid
suffix:semicolon
id|info.entry.ctime
op_assign
id|info.entry.atime
op_assign
id|info.entry.mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|info.entry.flags
op_assign
l_int|0
suffix:semicolon
id|info.entry.nlink
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
id|umsdos_newentry
(paren
id|dentry-&gt;d_parent
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* lookup the short name dentry */
id|temp
op_assign
id|umsdos_covered
c_func
(paren
id|dentry-&gt;d_parent
comma
id|info.fake.fname
comma
id|info.fake.len
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|temp
)paren
)paren
r_goto
id|out_remove
suffix:semicolon
multiline_comment|/* Make sure the short name doesn&squot;t exist */
id|ret
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|temp-&gt;d_inode
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;umsdos_mkdir: short name %s/%s exists&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|info.fake.fname
)paren
suffix:semicolon
r_goto
id|out_remove_dput
suffix:semicolon
)brace
id|ret
op_assign
id|msdos_mkdir
(paren
id|dir
comma
id|temp
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_remove_dput
suffix:semicolon
multiline_comment|/*&n;&t; * Lock the inode to protect the EMD creation ...&n;&t; */
id|inode
op_assign
id|temp-&gt;d_inode
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
multiline_comment|/* N.B. this should have an option to create the EMD ... */
id|umsdos_lookup_patch_new
c_func
(paren
id|dentry
comma
op_amp
id|info
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Create the EMD file, and set up the dir so it is&n;&t; * promoted to EMD with the EMD file invisible.&n;&t; *&n;&t; * N.B. error return if EMD fails?&n;&t; */
id|err
op_assign
id|umsdos_make_emd
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|umsdos_setup_dir
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|dput
c_func
(paren
id|temp
)paren
suffix:semicolon
id|out
suffix:colon
id|Printk
c_func
(paren
(paren
l_string|&quot;umsdos_mkdir: %s/%s, ret=%d&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
multiline_comment|/* an error occurred ... remove EMD entry. */
id|out_remove_dput
suffix:colon
id|dput
c_func
(paren
id|temp
)paren
suffix:semicolon
id|out_remove
suffix:colon
id|umsdos_delentry
(paren
id|dentry-&gt;d_parent
comma
op_amp
id|info
comma
l_int|1
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a new device special file into a directory.&n; *&n; * #Specification: Special files / strategy&n; * Device special file, pipes, etc ... are created like normal&n; * file in the msdos file system. Of course they remain empty.&n; * &n; * One strategy was to create those files only in the EMD file&n; * since they were not important for MSDOS. The problem with&n; * that, is that there were not getting inode number allocated.&n; * The MSDOS filesystems is playing a nice game to fake inode&n; * number, so why not use it.&n; * &n; * The absence of inode number compatible with those allocated&n; * for ordinary files was causing major trouble with hard link&n; * in particular and other parts of the kernel I guess.&n; */
DECL|function|UMSDOS_mknod
r_int
id|UMSDOS_mknod
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
comma
r_int
id|rdev
)paren
(brace
r_return
id|umsdos_create_any
(paren
id|dir
comma
id|dentry
comma
id|mode
comma
id|rdev
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a sub-directory.&n; */
DECL|function|UMSDOS_rmdir
r_int
id|UMSDOS_rmdir
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|dentry
op_star
id|temp
suffix:semicolon
r_int
id|ret
comma
id|err
comma
id|empty
suffix:semicolon
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|ret
op_assign
id|umsdos_nevercreat
(paren
id|dir
comma
id|dentry
comma
op_minus
id|EPERM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|d_unhashed
c_func
(paren
id|dentry
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* check whether the EMD is empty */
id|ret
op_assign
op_minus
id|ENOTEMPTY
suffix:semicolon
id|empty
op_assign
id|umsdos_isempty
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/* Have to remove the EMD file? */
r_if
c_cond
(paren
id|empty
op_eq
l_int|1
)paren
(brace
r_struct
id|dentry
op_star
id|demd
suffix:semicolon
id|demd
op_assign
id|umsdos_get_emd_dentry
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|demd
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|demd-&gt;d_inode
)paren
id|err
op_assign
id|msdos_unlink
(paren
id|dentry-&gt;d_inode
comma
id|demd
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;UMSDOS_rmdir: unlinking empty EMD err=%d&quot;
comma
id|err
)paren
)paren
suffix:semicolon
macro_line|#ifdef UMSDOS_PARANOIA
r_if
c_cond
(paren
id|err
)paren
id|printk
c_func
(paren
l_string|&quot;umsdos_rmdir: EMD %s/%s unlink failed, err=%d&bslash;n&quot;
comma
id|demd-&gt;d_parent-&gt;d_name.name
comma
id|demd-&gt;d_name.name
comma
id|err
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|d_delete
c_func
(paren
id|demd
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|dput
c_func
(paren
id|demd
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|empty
op_eq
l_int|2
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|umsdos_parse
(paren
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
op_amp
id|info
)paren
suffix:semicolon
multiline_comment|/* Call findentry to complete the mangling */
id|umsdos_findentry
(paren
id|dentry-&gt;d_parent
comma
op_amp
id|info
comma
l_int|2
)paren
suffix:semicolon
id|temp
op_assign
id|umsdos_covered
c_func
(paren
id|dentry-&gt;d_parent
comma
id|info.fake.fname
comma
id|info.fake.len
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|temp
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Attempt to remove the msdos name.&n;&t; */
id|ret
op_assign
id|msdos_rmdir
(paren
id|dir
comma
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_logical_and
id|ret
op_ne
op_minus
id|ENOENT
)paren
r_goto
id|out_dput
suffix:semicolon
id|d_delete
c_func
(paren
id|temp
)paren
suffix:semicolon
multiline_comment|/* OK so far ... remove the name from the EMD */
id|ret
op_assign
id|umsdos_delentry
(paren
id|dentry-&gt;d_parent
comma
op_amp
id|info
comma
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef UMSDOS_PARANOIA
r_if
c_cond
(paren
id|ret
)paren
id|printk
c_func
(paren
l_string|&quot;umsdos_rmdir: delentry %s failed, ret=%d&bslash;n&quot;
comma
id|info.entry.name
comma
id|ret
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* dput() temp if we didn&squot;t do it above */
id|out_dput
suffix:colon
id|dput
c_func
(paren
id|temp
)paren
suffix:semicolon
id|out
suffix:colon
id|Printk
(paren
(paren
l_string|&quot;umsdos_rmdir %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove a file from the directory.&n; *&n; * #Specification: hard link / deleting a link&n; * When we delete a file and this file is a link,&n; * we must subtract 1 from the nlink field of the&n; * hidden link.&n; * &n; * If the count goes to 0, we delete this hidden&n; * link too.&n; */
DECL|function|UMSDOS_unlink
r_int
id|UMSDOS_unlink
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|dentry
op_star
id|temp
comma
op_star
id|link
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|Printk
c_func
(paren
(paren
l_string|&quot;UMSDOS_unlink: entering %s/%s&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_nevercreat
(paren
id|dir
comma
id|dentry
comma
op_minus
id|EPERM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
id|umsdos_parse
(paren
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|umsdos_lockcreate
(paren
id|dir
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_findentry
(paren
id|dentry-&gt;d_parent
comma
op_amp
id|info
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;UMSDOS_unlink: %s/%s not in EMD, ret=%d&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|ret
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
id|Printk
(paren
(paren
l_string|&quot;UMSDOS_unlink %.*s &quot;
comma
id|info.fake.len
comma
id|info.fake.fname
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Note! If this is a hardlink and the names are aliased,&n;&t; * the short-name lookup will return the hardlink dentry.&n;&t; * In order to get the correct (real) inode, we just drop&n;&t; * the original dentry.&n;&t; */
r_if
c_cond
(paren
id|info.entry.flags
op_amp
id|UMSDOS_HLINK
)paren
(brace
id|d_drop
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
multiline_comment|/* Do a real lookup to get the short name dentry */
id|temp
op_assign
id|umsdos_covered
c_func
(paren
id|dentry-&gt;d_parent
comma
id|info.fake.fname
comma
id|info.fake.len
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|temp
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
multiline_comment|/*&n;&t; * Resolve hardlinks now, but defer processing until later.&n;&t; */
r_if
c_cond
(paren
id|info.entry.flags
op_amp
id|UMSDOS_HLINK
)paren
(brace
id|link
op_assign
id|umsdos_solve_hlink
c_func
(paren
id|dget
c_func
(paren
id|temp
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Delete the EMD entry */
id|ret
op_assign
id|umsdos_delentry
(paren
id|dentry-&gt;d_parent
comma
op_amp
id|info
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_logical_and
id|ret
op_ne
op_minus
id|ENOENT
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;UMSDOS_unlink: delentry %s, error=%d&bslash;n&quot;
comma
id|info.entry.name
comma
id|ret
)paren
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
id|ret
op_assign
id|msdos_unlink
c_func
(paren
id|dir
comma
id|temp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|d_delete
c_func
(paren
id|temp
)paren
suffix:semicolon
macro_line|#ifdef UMSDOS_PARANOIA
r_if
c_cond
(paren
id|ret
)paren
id|printk
c_func
(paren
l_string|&quot;umsdos_unlink: %s/%s unlink failed, ret=%d&bslash;n&quot;
comma
id|temp-&gt;d_parent-&gt;d_name.name
comma
id|temp-&gt;d_name.name
comma
id|ret
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* dput() temp if we didn&squot;t do it above */
id|out_dput
suffix:colon
id|dput
c_func
(paren
id|temp
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|umsdos_unlockcreate
(paren
id|dir
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now check for deferred handling of a hardlink.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|link
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|link
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;umsdos_unlink: failed to resolve %s/%s&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|link
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|Printk
c_func
(paren
(paren
l_string|&quot;umsdos_unlink: link %s/%s deferred, pending ret=%d&bslash;n&quot;
comma
id|link-&gt;d_parent-&gt;d_name.name
comma
id|link-&gt;d_name.name
comma
id|ret
)paren
)paren
suffix:semicolon
multiline_comment|/* already have an error? */
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out_cleanup
suffix:semicolon
multiline_comment|/* make sure the link exists ... */
id|inode
op_assign
id|link-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;umsdos_unlink: hard link not found&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_cleanup
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If this was the last linked reference, delete it now.&n;&t; *&n;&t; * N.B. Deadlock problem? We should be holding the lock&n;&t; * for the hardlink&squot;s parent, but another process might&n;&t; * be holding that lock waiting for us to finish ...&n;&t; */
r_if
c_cond
(paren
id|inode-&gt;i_nlink
op_le
l_int|1
)paren
(brace
id|ret
op_assign
id|UMSDOS_unlink
(paren
id|link-&gt;d_parent-&gt;d_inode
comma
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;umsdos_unlink: link removal failed, ret=%d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
)brace
r_else
id|d_delete
c_func
(paren
id|link
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|iattr
id|newattrs
suffix:semicolon
id|inode-&gt;i_nlink
op_decrement
suffix:semicolon
id|newattrs.ia_valid
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|umsdos_notify_change_locked
c_func
(paren
id|link
comma
op_amp
id|newattrs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|mark_inode_dirty
c_func
(paren
id|link-&gt;d_inode
)paren
suffix:semicolon
)brace
id|out_cleanup
suffix:colon
id|d_drop
c_func
(paren
id|link
)paren
suffix:semicolon
id|dput
c_func
(paren
id|link
)paren
suffix:semicolon
id|out
suffix:colon
id|Printk
(paren
(paren
l_string|&quot;umsdos_unlink %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Rename (move) a file.&n; */
DECL|function|UMSDOS_rename
r_int
id|UMSDOS_rename
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_struct
id|dentry
op_star
id|new_dentry
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|umsdos_nevercreat
(paren
id|new_dir
comma
id|new_dentry
comma
op_minus
id|EEXIST
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the target already exists, delete it first.&n;&t;&t; */
r_if
c_cond
(paren
id|new_dentry-&gt;d_inode
)paren
(brace
id|dget
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|old_dentry-&gt;d_inode-&gt;i_mode
)paren
)paren
id|ret
op_assign
id|UMSDOS_rmdir
(paren
id|new_dir
comma
id|new_dentry
)paren
suffix:semicolon
r_else
id|ret
op_assign
id|UMSDOS_unlink
(paren
id|new_dir
comma
id|new_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|d_drop
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
id|dput
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
)brace
id|ret
op_assign
id|umsdos_rename_f
c_func
(paren
id|old_dir
comma
id|old_dentry
comma
id|new_dir
comma
id|new_dentry
comma
l_int|0
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
