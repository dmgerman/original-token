multiline_comment|/*&n; *  linux/fs/umsdos/dir.c&n; *&n; *  Written 1993 by Jacques Gelinas&n; *      Inspired from linux/fs/msdos/... : Werner Almesberger&n; *&n; *  Extended MS-DOS directory handling functions&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/msdos_fs.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/limits.h&gt;
macro_line|#include &lt;linux/umsdos_fs.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
DECL|macro|UMSDOS_SPECIAL_DIRFPOS
mdefine_line|#define UMSDOS_SPECIAL_DIRFPOS&t;3
r_extern
r_struct
id|dentry
op_star
id|saved_root
suffix:semicolon
r_extern
r_struct
id|inode
op_star
id|pseudo_root
suffix:semicolon
multiline_comment|/* #define UMSDOS_DEBUG_VERBOSE 1 */
multiline_comment|/*&n; * Dentry operations routines&n; */
multiline_comment|/* nothing for now ... */
DECL|function|umsdos_dentry_validate
r_static
r_int
id|umsdos_dentry_validate
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|flags
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* for now, drop everything to force lookups ... */
multiline_comment|/* ITYM s/everything/&amp; positive/... */
DECL|function|umsdos_dentry_dput
r_static
r_int
id|umsdos_dentry_dput
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|umsdos_dentry_operations
r_struct
id|dentry_operations
id|umsdos_dentry_operations
op_assign
(brace
id|d_revalidate
suffix:colon
id|umsdos_dentry_validate
comma
id|d_delete
suffix:colon
id|umsdos_dentry_dput
comma
)brace
suffix:semicolon
DECL|struct|UMSDOS_DIR_ONCE
r_struct
id|UMSDOS_DIR_ONCE
(brace
DECL|member|dirbuf
r_void
op_star
id|dirbuf
suffix:semicolon
DECL|member|filldir
id|filldir_t
id|filldir
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|stop
r_int
id|stop
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Record a single entry the first call.&n; * Return -EINVAL the next one.&n; * NOTE: filldir DOES NOT use a dentry&n; */
DECL|function|umsdos_dir_once
r_static
r_int
id|umsdos_dir_once
(paren
r_void
op_star
id|buf
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
id|off_t
id|offset
comma
id|ino_t
id|ino
comma
r_int
id|type
)paren
(brace
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_struct
id|UMSDOS_DIR_ONCE
op_star
id|d
op_assign
(paren
r_struct
id|UMSDOS_DIR_ONCE
op_star
)paren
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;count
op_eq
l_int|0
)paren
(brace
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;dir_once :%.*s: offset %Ld&bslash;n&quot;
comma
id|len
comma
id|name
comma
id|offset
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|d-&gt;filldir
(paren
id|d-&gt;dirbuf
comma
id|name
comma
id|len
comma
id|offset
comma
id|ino
comma
id|DT_UNKNOWN
)paren
suffix:semicolon
id|d-&gt;stop
op_assign
id|ret
OL
l_int|0
suffix:semicolon
id|d-&gt;count
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Read count directory entries from directory filp&n; * Return a negative value from linux/errno.h.&n; * Return &gt; 0 if success (the number of bytes written by filldir).&n; * &n; * This function is used by the normal readdir VFS entry point,&n; * and in order to get the directory entry from a file&squot;s dentry.&n; * See umsdos_dentry_to_entry() below.&n; */
DECL|function|umsdos_readdir_x
r_static
r_int
id|umsdos_readdir_x
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|dirbuf
comma
r_struct
id|umsdos_dirent
op_star
id|u_entry
comma
id|filldir_t
id|filldir
)paren
(brace
r_struct
id|dentry
op_star
id|demd
suffix:semicolon
id|off_t
id|start_fpos
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|loff_t
id|pos
suffix:semicolon
id|umsdos_startlookup
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_pos
op_eq
id|UMSDOS_SPECIAL_DIRFPOS
op_logical_and
id|dir
op_eq
id|pseudo_root
)paren
(brace
multiline_comment|/*&n;&t;&t; * We don&squot;t need to simulate this pseudo directory&n;&t;&t; * when umsdos_readdir_x is called for internal operation&n;&t;&t; * of umsdos. This is why dirent_in_fs is tested&n;&t;&t; */
multiline_comment|/* #Specification: pseudo root / directory /DOS&n;&t;&t; * When umsdos operates in pseudo root mode (C:&bslash;linux is the&n;&t;&t; * linux root), it simulate a directory /DOS which points to&n;&t;&t; * the real root of the file system.&n;&t;&t; */
id|Printk
(paren
(paren
id|KERN_WARNING
l_string|&quot;umsdos_readdir_x: pseudo_root thing UMSDOS_SPECIAL_DIRFPOS&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filldir
(paren
id|dirbuf
comma
l_string|&quot;DOS&quot;
comma
l_int|3
comma
id|UMSDOS_SPECIAL_DIRFPOS
comma
id|UMSDOS_ROOT_INO
comma
id|DT_DIR
)paren
op_eq
l_int|0
)paren
(brace
id|filp-&gt;f_pos
op_increment
suffix:semicolon
)brace
r_goto
id|out_end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|filp-&gt;f_pos
OL
l_int|2
op_logical_or
(paren
id|dir-&gt;i_ino
op_ne
id|UMSDOS_ROOT_INO
op_logical_and
id|filp-&gt;f_pos
op_eq
l_int|32
)paren
)paren
(brace
r_int
id|last_f_pos
op_assign
id|filp-&gt;f_pos
suffix:semicolon
r_struct
id|UMSDOS_DIR_ONCE
id|bufk
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_readdir_x: . or .. /mn/?&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|bufk.dirbuf
op_assign
id|dirbuf
suffix:semicolon
id|bufk.filldir
op_assign
id|filldir
suffix:semicolon
id|bufk.count
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|fat_readdir
(paren
id|filp
comma
op_amp
id|bufk
comma
id|umsdos_dir_once
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_f_pos
OG
l_int|0
op_logical_and
id|filp-&gt;f_pos
OG
id|last_f_pos
)paren
id|filp-&gt;f_pos
op_assign
id|UMSDOS_SPECIAL_DIRFPOS
suffix:semicolon
r_if
c_cond
(paren
id|u_entry
op_ne
l_int|NULL
)paren
id|u_entry-&gt;flags
op_assign
l_int|0
suffix:semicolon
r_goto
id|out_end
suffix:semicolon
)brace
id|Printk
(paren
(paren
l_string|&quot;umsdos_readdir_x: normal file /mn/?&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* get the EMD dentry */
id|demd
op_assign
id|umsdos_get_emd_dentry
c_func
(paren
id|filp-&gt;f_dentry
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|demd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|demd
)paren
)paren
r_goto
id|out_end
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|demd-&gt;d_inode
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;umsdos_readir_x: EMD file %s/%s not found&bslash;n&quot;
comma
id|demd-&gt;d_parent-&gt;d_name.name
comma
id|demd-&gt;d_name.name
)paren
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
id|pos
op_assign
id|filp-&gt;f_pos
suffix:semicolon
id|start_fpos
op_assign
id|filp-&gt;f_pos
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_le
id|UMSDOS_SPECIAL_DIRFPOS
op_plus
l_int|1
)paren
id|pos
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|pos
OL
id|demd-&gt;d_inode-&gt;i_size
)paren
(brace
id|off_t
id|cur_f_pos
op_assign
id|pos
suffix:semicolon
r_struct
id|dentry
op_star
id|dret
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_emd_dir_readentry
(paren
id|demd
comma
op_amp
id|pos
comma
op_amp
id|entry
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|entry.name_len
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
macro_line|#ifdef UMSDOS_DEBUG_VERBOSE
r_if
c_cond
(paren
id|entry.flags
op_amp
id|UMSDOS_HLINK
)paren
id|printk
c_func
(paren
l_string|&quot;umsdos_readdir_x: %s/%s is hardlink&bslash;n&quot;
comma
id|filp-&gt;f_dentry-&gt;d_name.name
comma
id|entry.name
)paren
suffix:semicolon
macro_line|#endif
id|umsdos_parse
(paren
id|entry.name
comma
id|entry.name_len
comma
op_amp
id|info
)paren
suffix:semicolon
id|info.f_pos
op_assign
id|cur_f_pos
suffix:semicolon
id|umsdos_manglename
(paren
op_amp
id|info
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Do a real lookup on the short name.&n;&t;&t; */
id|dret
op_assign
id|umsdos_covered
c_func
(paren
id|filp-&gt;f_dentry
comma
id|info.fake.fname
comma
id|info.fake.len
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|dret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dret
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the file wasn&squot;t found, remove it from the EMD.&n;&t;&t; */
id|inode
op_assign
id|dret-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|remove_name
suffix:semicolon
macro_line|#ifdef UMSDOS_DEBUG_VERBOSE
r_if
c_cond
(paren
id|inode-&gt;u.umsdos_i.i_is_hlink
)paren
id|printk
c_func
(paren
l_string|&quot;umsdos_readdir_x: %s/%s already resolved, ino=%ld&bslash;n&quot;
comma
id|dret-&gt;d_parent-&gt;d_name.name
comma
id|dret-&gt;d_name.name
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
macro_line|#endif
id|Printk
(paren
(paren
l_string|&quot;Found %s/%s, ino=%ld, flags=%x&bslash;n&quot;
comma
id|dret-&gt;d_parent-&gt;d_name.name
comma
id|info.fake.fname
comma
id|dret-&gt;d_inode-&gt;i_ino
comma
id|entry.flags
)paren
)paren
suffix:semicolon
multiline_comment|/* check whether to resolve a hard-link */
r_if
c_cond
(paren
(paren
id|entry.flags
op_amp
id|UMSDOS_HLINK
)paren
op_logical_and
op_logical_neg
id|inode-&gt;u.umsdos_i.i_is_hlink
)paren
(brace
id|dret
op_assign
id|umsdos_solve_hlink
(paren
id|dret
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|dret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dret
)paren
)paren
r_break
suffix:semicolon
id|inode
op_assign
id|dret-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;umsdos_readdir_x: %s/%s negative after link&bslash;n&quot;
comma
id|dret-&gt;d_parent-&gt;d_name.name
comma
id|dret-&gt;d_name.name
)paren
suffix:semicolon
r_goto
id|clean_up
suffix:semicolon
)brace
)brace
multiline_comment|/* #Specification:  pseudo root / reading real root&n;&t;&t; * The pseudo root (/linux) is logically&n;&t;&t; * erased from the real root.  This means that&n;&t;&t; * ls /DOS, won&squot;t show &quot;linux&quot;. This avoids&n;&t;&t; * infinite recursion (/DOS/linux/DOS/linux/...) while&n;&t;&t; * walking the file system.&n;&t;&t; */
r_if
c_cond
(paren
id|inode
op_ne
id|pseudo_root
op_logical_and
op_logical_neg
(paren
id|entry.flags
op_amp
id|UMSDOS_HIDDEN
)paren
)paren
(brace
r_if
c_cond
(paren
id|filldir
(paren
id|dirbuf
comma
id|entry.name
comma
id|entry.name_len
comma
id|cur_f_pos
comma
id|inode-&gt;i_ino
comma
id|DT_UNKNOWN
)paren
OL
l_int|0
)paren
(brace
id|pos
op_assign
id|cur_f_pos
suffix:semicolon
)brace
id|Printk
c_func
(paren
(paren
l_string|&quot;umsdos_readdir_x: got %s/%s, ino=%ld&bslash;n&quot;
comma
id|dret-&gt;d_parent-&gt;d_name.name
comma
id|dret-&gt;d_name.name
comma
id|inode-&gt;i_ino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|u_entry
op_ne
l_int|NULL
)paren
op_star
id|u_entry
op_assign
id|entry
suffix:semicolon
id|dput
c_func
(paren
id|dret
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|clean_up
suffix:colon
id|dput
c_func
(paren
id|dret
)paren
suffix:semicolon
r_continue
suffix:semicolon
id|remove_name
suffix:colon
multiline_comment|/* #Specification:  umsdos / readdir / not in MSDOS&n;&t;&t; * During a readdir operation, if the file is not&n;&t;&t; * in the MS-DOS directory any more, the entry is&n;&t;&t; * removed from the EMD file silently.&n;&t;&t; */
macro_line|#ifdef UMSDOS_PARANOIA
id|printk
c_func
(paren
l_string|&quot;umsdos_readdir_x: %s/%s out of sync, erasing&bslash;n&quot;
comma
id|filp-&gt;f_dentry-&gt;d_name.name
comma
id|info.entry.name
)paren
suffix:semicolon
macro_line|#endif
id|ret
op_assign
id|umsdos_delentry
c_func
(paren
id|filp-&gt;f_dentry
comma
op_amp
id|info
comma
id|S_ISDIR
c_func
(paren
id|info.entry.mode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;umsdos_readdir_x: delentry %s, err=%d&bslash;n&quot;
comma
id|info.entry.name
comma
id|ret
)paren
suffix:semicolon
r_goto
id|clean_up
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the fillbuf has failed, f_pos is back to 0.&n;&t; * To avoid getting back into the . and .. state&n;&t; * (see comments at the beginning), we put back&n;&t; * the special offset.&n;&t; */
id|filp-&gt;f_pos
op_assign
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_pos
op_eq
l_int|0
)paren
id|filp-&gt;f_pos
op_assign
id|start_fpos
suffix:semicolon
id|out_dput
suffix:colon
id|dput
c_func
(paren
id|demd
)paren
suffix:semicolon
id|out_end
suffix:colon
id|umsdos_endlookup
(paren
id|dir
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;read dir %p pos %Ld ret %d&bslash;n&quot;
comma
id|dir
comma
id|filp-&gt;f_pos
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Read count directory entries from directory filp.&n; * Return a negative value from linux/errno.h.&n; * Return 0 or positive if successful.&n; */
DECL|function|UMSDOS_readdir
r_static
r_int
id|UMSDOS_readdir
(paren
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|dirbuf
comma
id|filldir_t
id|filldir
)paren
(brace
r_struct
id|inode
op_star
id|dir
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
comma
id|count
op_assign
l_int|0
suffix:semicolon
r_struct
id|UMSDOS_DIR_ONCE
id|bufk
suffix:semicolon
id|bufk.dirbuf
op_assign
id|dirbuf
suffix:semicolon
id|bufk.filldir
op_assign
id|filldir
suffix:semicolon
id|bufk.stop
op_assign
l_int|0
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;UMSDOS_readdir in&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ret
op_eq
l_int|0
op_logical_and
id|bufk.stop
op_eq
l_int|0
)paren
(brace
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
id|bufk.count
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|umsdos_readdir_x
(paren
id|dir
comma
id|filp
comma
op_amp
id|bufk
comma
op_amp
id|entry
comma
id|umsdos_dir_once
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bufk.count
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|count
op_add_assign
id|bufk.count
suffix:semicolon
)brace
id|Printk
(paren
(paren
l_string|&quot;UMSDOS_readdir out %d count %d pos %Ld&bslash;n&quot;
comma
id|ret
comma
id|count
comma
id|filp-&gt;f_pos
)paren
)paren
suffix:semicolon
r_return
id|count
ques
c_cond
suffix:colon
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Complete the inode content with info from the EMD file.&n; *&n; * This function modifies the state of a dir inode.  It decides&n; * whether the dir is a UMSDOS or DOS directory.  This is done&n; * deeper in umsdos_patch_inode() called at the end of this function.&n; * &n; * Because it is does disk access, umsdos_patch_inode() may block.&n; * At the same time, another process may get here to initialise&n; * the same directory inode. There are three cases.&n; * &n; * 1) The inode is already initialised.  We do nothing.&n; * 2) The inode is not initialised.  We lock access and do it.&n; * 3) Like 2 but another process has locked the inode, so we try&n; * to lock it and check right afterward check whether&n; * initialisation is still needed.&n; * &n; * &n; * Thanks to the &quot;mem&quot; option of the kernel command line, it was&n; * possible to consistently reproduce this problem by limiting&n; * my memory to 4 MB and running X.&n; *&n; * Do this only if the inode is freshly read, because we will lose&n; * the current (updated) content.&n; *&n; * A lookup of a mount point directory yield the inode into&n; * the other fs, so we don&squot;t care about initialising it. iget()&n; * does this automatically.&n; */
DECL|function|umsdos_lookup_patch_new
r_void
id|umsdos_lookup_patch_new
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|umsdos_info
op_star
id|info
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_struct
id|umsdos_dirent
op_star
id|entry
op_assign
op_amp
id|info-&gt;entry
suffix:semicolon
multiline_comment|/*&n;&t; * This part of the initialization depends only on i_patched.&n;&t; */
r_if
c_cond
(paren
id|inode-&gt;u.umsdos_i.i_patched
)paren
r_goto
id|out
suffix:semicolon
id|inode-&gt;u.umsdos_i.i_patched
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|S_ISREG
(paren
id|entry-&gt;mode
)paren
)paren
id|entry-&gt;mtime
op_assign
id|inode-&gt;i_mtime
suffix:semicolon
id|inode-&gt;i_mode
op_assign
id|entry-&gt;mode
suffix:semicolon
id|inode-&gt;i_rdev
op_assign
id|to_kdev_t
(paren
id|entry-&gt;rdev
)paren
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|entry-&gt;atime
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|entry-&gt;ctime
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
id|entry-&gt;mtime
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|entry-&gt;uid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|entry-&gt;gid
suffix:semicolon
multiline_comment|/* #Specification: umsdos / i_nlink&n;&t; * The nlink field of an inode is maintained by the MSDOS file system&n;&t; * for directory and by UMSDOS for other files.  The logic is that&n;&t; * MSDOS is already figuring out what to do for directories and&n;&t; * does nothing for other files.  For MSDOS, there are no hard links&n;&t; * so all file carry nlink==1.  UMSDOS use some info in the&n;&t; * EMD file to plug the correct value.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
(paren
id|entry-&gt;mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;nlink
OG
l_int|0
)paren
(brace
id|inode-&gt;i_nlink
op_assign
id|entry-&gt;nlink
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;UMSDOS:  lookup_patch entry-&gt;nlink &lt; 1 ???&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * The mode may have changed, so patch the inode again.&n;&t; */
id|umsdos_patch_dentry_inode
c_func
(paren
id|dentry
comma
id|info-&gt;f_pos
)paren
suffix:semicolon
id|umsdos_set_dirinfo_new
c_func
(paren
id|dentry
comma
id|info-&gt;f_pos
)paren
suffix:semicolon
id|out
suffix:colon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Return != 0 if an entry is the pseudo DOS entry in the pseudo root.&n; */
DECL|function|umsdos_is_pseudodos
r_int
id|umsdos_is_pseudodos
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
multiline_comment|/* #Specification: pseudo root / DOS hard coded&n;&t; * The pseudo sub-directory DOS in the pseudo root is hard coded.&n;&t; * The name is DOS. This is done this way to help standardised&n;&t; * the umsdos layout. The idea is that from now on /DOS is&n;&t; * a reserved path and nobody will think of using such a path&n;&t; * for a package.&n;&t; */
r_return
id|dir
op_eq
id|pseudo_root
op_logical_and
id|dentry-&gt;d_name.len
op_eq
l_int|3
op_logical_and
id|dentry-&gt;d_name.name
(braket
l_int|0
)braket
op_eq
l_char|&squot;D&squot;
op_logical_and
id|dentry-&gt;d_name.name
(braket
l_int|1
)braket
op_eq
l_char|&squot;O&squot;
op_logical_and
id|dentry-&gt;d_name.name
(braket
l_int|2
)braket
op_eq
l_char|&squot;S&squot;
suffix:semicolon
)brace
multiline_comment|/*&n; * Check whether a file exists in the current directory.&n; * Return 0 if OK, negative error code if not (ex: -ENOENT).&n; *&n; * fills dentry-&gt;d_inode with found inode, and increments its count.&n; * if not found, return -ENOENT.&n; */
multiline_comment|/* #Specification: umsdos / lookup&n; * A lookup for a file is done in two steps.  First, we&n; * locate the file in the EMD file.  If not present, we&n; * return an error code (-ENOENT).  If it is there, we&n; * repeat the operation on the msdos file system. If&n; * this fails, it means that the file system is not in&n; * sync with the EMD file.   We silently remove this&n; * entry from the EMD file, and return ENOENT.&n; */
DECL|function|umsdos_lookup_x
r_struct
id|dentry
op_star
id|umsdos_lookup_x
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|nopseudo
)paren
(brace
r_struct
id|dentry
op_star
id|dret
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_struct
id|umsdos_info
id|info
suffix:semicolon
macro_line|#ifdef UMSDOS_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;umsdos_lookup_x: looking for %s/%s&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
macro_line|#endif
id|umsdos_startlookup
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_is_pseudodos
(paren
id|dir
comma
id|dentry
)paren
)paren
(brace
multiline_comment|/* #Specification: pseudo root / lookup(DOS)&n;&t;&t; * A lookup of DOS in the pseudo root will always succeed&n;&t;&t; * and return the inode of the real root.&n;&t;&t; */
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_lookup_x: following /DOS&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|inode
op_assign
id|saved_root-&gt;d_inode
suffix:semicolon
r_goto
id|out_add
suffix:semicolon
)brace
id|ret
op_assign
id|umsdos_parse
(paren
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;umsdos_lookup_x: %s/%s parse failed, ret=%d&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|ret
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|ret
op_assign
id|umsdos_findentry
(paren
id|dentry-&gt;d_parent
comma
op_amp
id|info
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|ENOENT
)paren
id|printk
c_func
(paren
l_string|&quot;umsdos_lookup_x: %s/%s findentry failed, ret=%d&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|ret
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|Printk
(paren
(paren
l_string|&quot;lookup %.*s pos %lu ret %d len %d &quot;
comma
id|info.fake.len
comma
id|info.fake.fname
comma
id|info.f_pos
comma
id|ret
comma
id|info.fake.len
)paren
)paren
suffix:semicolon
multiline_comment|/* do a real lookup to get the short name ... */
id|dret
op_assign
id|umsdos_covered
c_func
(paren
id|dentry-&gt;d_parent
comma
id|info.fake.fname
comma
id|info.fake.len
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|dret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dret
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;umsdos_lookup_x: %s/%s real lookup failed, ret=%d&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|ret
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|inode
op_assign
id|dret-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|out_remove
suffix:semicolon
id|umsdos_lookup_patch_new
c_func
(paren
id|dret
comma
op_amp
id|info
)paren
suffix:semicolon
macro_line|#ifdef UMSDOS_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;umsdos_lookup_x: found %s/%s, ino=%ld&bslash;n&quot;
comma
id|dret-&gt;d_parent-&gt;d_name.name
comma
id|dret-&gt;d_name.name
comma
id|dret-&gt;d_inode-&gt;i_ino
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Check for a hard link */
r_if
c_cond
(paren
(paren
id|info.entry.flags
op_amp
id|UMSDOS_HLINK
)paren
op_logical_and
op_logical_neg
id|inode-&gt;u.umsdos_i.i_is_hlink
)paren
(brace
id|dret
op_assign
id|umsdos_solve_hlink
(paren
id|dret
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|dret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dret
)paren
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|inode
op_assign
id|dret-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;umsdos_lookup_x: %s/%s negative after link&bslash;n&quot;
comma
id|dret-&gt;d_parent-&gt;d_name.name
comma
id|dret-&gt;d_name.name
)paren
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|inode
op_eq
id|pseudo_root
op_logical_and
op_logical_neg
id|nopseudo
)paren
(brace
multiline_comment|/* #Specification: pseudo root / dir lookup&n;&t;&t; * For the same reason as readdir, a lookup in /DOS for&n;&t;&t; * the pseudo root directory (linux) will fail.&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * This has to be allowed for resolving hard links&n;&t;&t; * which are recorded independently of the pseudo-root&n;&t;&t; * mode.&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;umsdos_lookup_x: skipping DOS/linux&bslash;n&quot;
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We&squot;ve found it OK.  Now hash the dentry with the inode.&n;&t; */
id|out_add
suffix:colon
id|atomic_inc
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
suffix:semicolon
id|d_add
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|dentry-&gt;d_op
op_assign
op_amp
id|umsdos_dentry_operations
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|out_dput
suffix:colon
r_if
c_cond
(paren
id|dret
op_logical_and
id|dret
op_ne
id|dentry
)paren
id|d_drop
c_func
(paren
id|dret
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dret
)paren
suffix:semicolon
id|out
suffix:colon
id|umsdos_endlookup
(paren
id|dir
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|ret
)paren
suffix:semicolon
id|out_remove
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;UMSDOS:  entry %s/%s out of sync, erased&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
id|umsdos_delentry
(paren
id|dentry-&gt;d_parent
comma
op_amp
id|info
comma
id|S_ISDIR
(paren
id|info.entry.mode
)paren
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
multiline_comment|/*&n; * Check whether a file exists in the current directory.&n; * Return 0 if OK, negative error code if not (ex: -ENOENT).&n; * &n; * Called by VFS; should fill dentry-&gt;d_inode via d_add.&n; */
DECL|function|UMSDOS_lookup
r_struct
id|dentry
op_star
id|UMSDOS_lookup
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|dentry
op_star
id|ret
suffix:semicolon
id|ret
op_assign
id|umsdos_lookup_x
(paren
id|dir
comma
id|dentry
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Create negative dentry if not found. */
r_if
c_cond
(paren
id|ret
op_eq
id|ERR_PTR
c_func
(paren
op_minus
id|ENOENT
)paren
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;UMSDOS_lookup: converting -ENOENT to negative&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|d_add
(paren
id|dentry
comma
l_int|NULL
)paren
suffix:semicolon
id|dentry-&gt;d_op
op_assign
op_amp
id|umsdos_dentry_operations
suffix:semicolon
id|ret
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|umsdos_covered
r_struct
id|dentry
op_star
id|umsdos_covered
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
r_struct
id|dentry
op_star
id|result
comma
op_star
id|dentry
suffix:semicolon
r_struct
id|qstr
id|qstr
suffix:semicolon
id|qstr.name
op_assign
id|name
suffix:semicolon
id|qstr.len
op_assign
id|len
suffix:semicolon
id|qstr.hash
op_assign
id|full_name_hash
c_func
(paren
id|name
comma
id|len
)paren
suffix:semicolon
id|result
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|dentry
op_assign
id|d_alloc
c_func
(paren
id|parent
comma
op_amp
id|qstr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
)paren
(brace
multiline_comment|/* XXXXXXXXXXXXXXXXXXX Race alert! */
id|result
op_assign
id|UMSDOS_rlookup
c_func
(paren
id|parent-&gt;d_inode
comma
id|dentry
)paren
suffix:semicolon
id|d_drop
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_goto
id|out_fail
suffix:semicolon
r_return
id|dentry
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|result
suffix:semicolon
id|out_fail
suffix:colon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Lookup or create a dentry from within the filesystem.&n; *&n; * We need to use this instead of lookup_dentry, as the &n; * directory semaphore lock is already held.&n; */
DECL|function|umsdos_lookup_dentry
r_struct
id|dentry
op_star
id|umsdos_lookup_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_char
op_star
id|name
comma
r_int
id|len
comma
r_int
id|real
)paren
(brace
r_struct
id|dentry
op_star
id|result
comma
op_star
id|dentry
suffix:semicolon
r_struct
id|qstr
id|qstr
suffix:semicolon
id|qstr.name
op_assign
id|name
suffix:semicolon
id|qstr.len
op_assign
id|len
suffix:semicolon
id|qstr.hash
op_assign
id|full_name_hash
c_func
(paren
id|name
comma
id|len
)paren
suffix:semicolon
id|result
op_assign
id|d_lookup
c_func
(paren
id|parent
comma
op_amp
id|qstr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
id|result
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|dentry
op_assign
id|d_alloc
c_func
(paren
id|parent
comma
op_amp
id|qstr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
)paren
(brace
id|result
op_assign
id|real
ques
c_cond
id|UMSDOS_rlookup
c_func
(paren
id|parent-&gt;d_inode
comma
id|dentry
)paren
suffix:colon
id|UMSDOS_lookup
c_func
(paren
id|parent-&gt;d_inode
comma
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_goto
id|out_fail
suffix:semicolon
r_return
id|dentry
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
id|result
suffix:semicolon
id|out_fail
suffix:colon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Return a path relative to our root.&n; */
DECL|function|umsdos_d_path
r_char
op_star
id|umsdos_d_path
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_struct
id|dentry
op_star
id|old_root
suffix:semicolon
r_char
op_star
id|path
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
id|old_root
op_assign
id|dget
c_func
(paren
id|current-&gt;fs-&gt;root
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|path
op_assign
id|__d_path
c_func
(paren
id|dentry
comma
l_int|NULL
comma
id|dentry-&gt;d_sb-&gt;s_root
comma
l_int|NULL
comma
id|buffer
comma
id|len
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|path
op_eq
l_char|&squot;/&squot;
)paren
id|path
op_increment
suffix:semicolon
multiline_comment|/* skip leading &squot;/&squot; */
r_if
c_cond
(paren
id|old_root-&gt;d_inode
op_eq
id|pseudo_root
)paren
(brace
op_star
(paren
id|path
op_minus
l_int|1
)paren
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|path
op_sub_assign
(paren
id|UMSDOS_PSDROOT_LEN
op_plus
l_int|1
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|path
comma
id|UMSDOS_PSDROOT_NAME
comma
id|UMSDOS_PSDROOT_LEN
)paren
suffix:semicolon
)brace
id|dput
c_func
(paren
id|old_root
)paren
suffix:semicolon
r_return
id|path
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the dentry which points to a pseudo-hardlink.&n; *&n; * it should try to find file it points to&n; * if file is found, return new dentry/inode&n; * The resolved inode will have i_is_hlink set.&n; *&n; * Note: the original dentry is always dput(), even if an error occurs.&n; */
DECL|function|umsdos_solve_hlink
r_struct
id|dentry
op_star
id|umsdos_solve_hlink
(paren
r_struct
id|dentry
op_star
id|hlink
)paren
(brace
multiline_comment|/* root is our root for resolving pseudo-hardlink */
r_struct
id|dentry
op_star
id|base
op_assign
id|hlink-&gt;d_sb-&gt;s_root
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry_dst
suffix:semicolon
r_char
op_star
id|path
comma
op_star
id|pt
suffix:semicolon
r_int
id|len
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|hlink-&gt;d_inode-&gt;i_mapping
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|page
op_assign
id|read_cache_page
c_func
(paren
id|mapping
comma
l_int|0
comma
(paren
id|filler_t
op_star
)paren
id|mapping-&gt;a_ops-&gt;readpage
comma
l_int|NULL
)paren
suffix:semicolon
id|dentry_dst
op_assign
(paren
r_struct
id|dentry
op_star
)paren
id|page
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
r_goto
id|out
suffix:semicolon
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|async_fail
suffix:semicolon
id|dentry_dst
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|path
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
(paren
id|PATH_MAX
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|path
op_eq
l_int|NULL
)paren
r_goto
id|out_release
suffix:semicolon
id|memcpy
c_func
(paren
id|path
comma
id|kmap
c_func
(paren
id|page
)paren
comma
id|hlink-&gt;d_inode-&gt;i_size
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|len
op_assign
id|hlink-&gt;d_inode-&gt;i_size
suffix:semicolon
multiline_comment|/* start at root dentry */
id|dentry_dst
op_assign
id|dget
c_func
(paren
id|base
)paren
suffix:semicolon
id|path
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|pt
op_assign
id|path
suffix:semicolon
r_if
c_cond
(paren
op_star
id|path
op_eq
l_char|&squot;/&squot;
)paren
id|pt
op_increment
suffix:semicolon
multiline_comment|/* skip leading &squot;/&squot; */
r_if
c_cond
(paren
id|base-&gt;d_inode
op_eq
id|pseudo_root
)paren
id|pt
op_add_assign
(paren
id|UMSDOS_PSDROOT_LEN
op_plus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|dentry
op_star
id|dir
op_assign
id|dentry_dst
comma
op_star
id|demd
suffix:semicolon
r_char
op_star
id|start
op_assign
id|pt
suffix:semicolon
r_int
id|real
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pt
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
op_star
id|pt
op_ne
l_char|&squot;/&squot;
)paren
id|pt
op_increment
suffix:semicolon
id|len
op_assign
(paren
r_int
)paren
(paren
id|pt
op_minus
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pt
op_eq
l_char|&squot;/&squot;
)paren
op_star
id|pt
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|real
op_assign
l_int|1
suffix:semicolon
id|demd
op_assign
id|umsdos_get_emd_dentry
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|demd
)paren
)paren
(brace
r_if
c_cond
(paren
id|demd-&gt;d_inode
)paren
id|real
op_assign
l_int|0
suffix:semicolon
id|dput
c_func
(paren
id|demd
)paren
suffix:semicolon
)brace
macro_line|#ifdef UMSDOS_DEBUG_VERBOSE
id|printk
(paren
l_string|&quot;umsdos_solve_hlink: dir %s/%s, name=%s, real=%d&bslash;n&quot;
comma
id|dir-&gt;d_parent-&gt;d_name.name
comma
id|dir-&gt;d_name.name
comma
id|start
comma
id|real
)paren
suffix:semicolon
macro_line|#endif
id|dentry_dst
op_assign
id|umsdos_lookup_dentry
c_func
(paren
id|dir
comma
id|start
comma
id|len
comma
id|real
)paren
suffix:semicolon
multiline_comment|/* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX */
r_if
c_cond
(paren
id|real
)paren
id|d_drop
c_func
(paren
id|dir
)paren
suffix:semicolon
id|dput
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry_dst
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* not found? stop search ... */
r_if
c_cond
(paren
op_logical_neg
id|dentry_dst-&gt;d_inode
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|pt
op_eq
l_char|&squot;&bslash;0&squot;
)paren
multiline_comment|/* we&squot;re finished! */
r_break
suffix:semicolon
)brace
multiline_comment|/* end while */
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|dentry_dst
)paren
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry_dst-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
id|inode-&gt;u.umsdos_i.i_is_hlink
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef UMSDOS_DEBUG_VERBOSE
id|printk
(paren
l_string|&quot;umsdos_solve_hlink: resolved link %s/%s, ino=%ld&bslash;n&quot;
comma
id|dentry_dst-&gt;d_parent-&gt;d_name.name
comma
id|dentry_dst-&gt;d_name.name
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
macro_line|#ifdef UMSDOS_DEBUG_VERBOSE
id|printk
(paren
l_string|&quot;umsdos_solve_hlink: resolved link %s/%s negative!&bslash;n&quot;
comma
id|dentry_dst-&gt;d_parent-&gt;d_name.name
comma
id|dentry_dst-&gt;d_name.name
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;umsdos_solve_hlink: err=%ld&bslash;n&quot;
comma
id|PTR_ERR
c_func
(paren
id|dentry_dst
)paren
)paren
suffix:semicolon
id|kfree
(paren
id|path
)paren
suffix:semicolon
id|out
suffix:colon
id|dput
c_func
(paren
id|hlink
)paren
suffix:semicolon
multiline_comment|/* original hlink no longer needed */
r_return
id|dentry_dst
suffix:semicolon
id|async_fail
suffix:colon
id|dentry_dst
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
id|out_release
suffix:colon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|variable|umsdos_dir_operations
r_struct
id|file_operations
id|umsdos_dir_operations
op_assign
(brace
id|read
suffix:colon
id|generic_read_dir
comma
id|readdir
suffix:colon
id|UMSDOS_readdir
comma
id|ioctl
suffix:colon
id|UMSDOS_ioctl_dir
comma
)brace
suffix:semicolon
DECL|variable|umsdos_dir_inode_operations
r_struct
id|inode_operations
id|umsdos_dir_inode_operations
op_assign
(brace
id|create
suffix:colon
id|UMSDOS_create
comma
id|lookup
suffix:colon
id|UMSDOS_lookup
comma
id|link
suffix:colon
id|UMSDOS_link
comma
id|unlink
suffix:colon
id|UMSDOS_unlink
comma
id|symlink
suffix:colon
id|UMSDOS_symlink
comma
id|mkdir
suffix:colon
id|UMSDOS_mkdir
comma
id|rmdir
suffix:colon
id|UMSDOS_rmdir
comma
id|mknod
suffix:colon
id|UMSDOS_mknod
comma
id|rename
suffix:colon
id|UMSDOS_rename
comma
id|setattr
suffix:colon
id|UMSDOS_notify_change
comma
)brace
suffix:semicolon
eof
