multiline_comment|/*&n; *  linux/fs/umsdos/dir.c&n; *&n; *  Written 1993 by Jacques Gelinas&n; *&t;Inspired from linux/fs/msdos/... : Werner Almesberger&n; *&n; *  Extended MS-DOS directory handling functions&n; */
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/msdos_fs.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/limits.h&gt;
macro_line|#include &lt;linux/umsdos_fs.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x)
DECL|macro|Printk
mdefine_line|#define Printk(x) printk x
DECL|macro|UMSDOS_SPECIAL_DIRFPOS
mdefine_line|#define UMSDOS_SPECIAL_DIRFPOS&t;3
r_extern
r_struct
id|inode
op_star
id|pseudo_root
suffix:semicolon
multiline_comment|/*&n;&t;So  grep *  doesn&squot;t complain in the presence of directories.&n;*/
DECL|function|UMSDOS_dir_read
r_int
id|UMSDOS_dir_read
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_return
op_minus
id|EISDIR
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Read count directory entries from directory filp&n;&t;Return a negative value from linux/errno.h.&n;&t;Return &gt; 0 if success (the length of the file name).&n;&n;&t;This function is used by the normal readdir VFS entry point and by&n;&t;some function who try to find out info on a file from a pure MSDOS&n;&t;inode. See umsdos_locate_ancestor() below.&n;*/
DECL|function|umsdos_readdir_x
r_static
r_int
id|umsdos_readdir_x
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
multiline_comment|/* Point to a description of the super block */
r_struct
id|file
op_star
id|filp
comma
multiline_comment|/* Point to a directory which is read */
r_struct
id|dirent
op_star
id|dirent
comma
multiline_comment|/* Will hold count directory entry */
r_int
id|dirent_in_fs
comma
multiline_comment|/* dirent point in user&squot;s space ? */
r_int
id|count
comma
r_struct
id|umsdos_dirent
op_star
id|u_entry
comma
multiline_comment|/* Optional umsdos entry */
r_int
id|follow_hlink
comma
id|off_t
op_star
id|pt_f_pos
)paren
multiline_comment|/* will hold the offset of the entry in EMD */
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|umsdos_startlookup
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_pos
op_eq
id|UMSDOS_SPECIAL_DIRFPOS
op_logical_and
id|dir
op_eq
id|pseudo_root
op_logical_and
id|dirent_in_fs
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;We don&squot;t need to simulate this pseudo directory&n;&t;&t;&t;when umsdos_readdir_x is called for internal operation&n;&t;&t;&t;of umsdos. This is why dirent_in_fs is tested&n;&t;&t;*/
multiline_comment|/* #Specification: pseudo root / directory /DOS&n;&t;&t;&t;When umsdos operates in pseudo root mode (C:&bslash;linux is the&n;&t;&t;&t;linux root), it simulate a directory /DOS which points to&n;&t;&t;&t;the real root of the file system.&n;&t;&t;*/
id|put_fs_long
c_func
(paren
id|dir-&gt;i_sb-&gt;s_mounted-&gt;i_ino
comma
op_amp
id|dirent-&gt;d_ino
)paren
suffix:semicolon
id|memcpy_tofs
(paren
id|dirent-&gt;d_name
comma
l_string|&quot;DOS&quot;
comma
l_int|3
)paren
suffix:semicolon
id|put_fs_byte
c_func
(paren
l_int|0
comma
id|dirent-&gt;d_name
op_plus
l_int|3
)paren
suffix:semicolon
id|put_fs_word
(paren
l_int|3
comma
op_amp
id|dirent-&gt;d_reclen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|u_entry
op_ne
l_int|NULL
)paren
id|u_entry-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|3
suffix:semicolon
id|filp-&gt;f_pos
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|filp-&gt;f_pos
OL
l_int|2
op_logical_or
(paren
id|dir
op_ne
id|dir-&gt;i_sb-&gt;s_mounted
op_logical_and
id|filp-&gt;f_pos
op_eq
l_int|32
)paren
)paren
(brace
multiline_comment|/* #Specification: readdir / . and ..&n;&t;&t;&t;The msdos filesystem manage the . and .. entry properly&n;&t;&t;&t;so the EMD file won&squot;t hold any info about it.&n;&n;&t;&t;&t;In readdir, we assume that for the root directory&n;&t;&t;&t;the read position will be 0 for &quot;.&quot;, 1 for &quot;..&quot;. For&n;&t;&t;&t;a non root directory, the read position will be 0 for &quot;.&quot;&n;&t;&t;&t;and 32 for &quot;..&quot;.&n;&t;&t;*/
multiline_comment|/*&n;&t;&t;&t;This is a trick used by the msdos file system (fs/msdos/dir.c)&n;&t;&t;&t;to manage . and .. for the root directory of a file system.&n;&t;&t;&t;Since there is no such entry in the root, fs/msdos/dir.c&n;&t;&t;&t;use the following:&n;&n;&t;&t;&t;if f_pos == 0, return &quot;.&quot;.&n;&t;&t;&t;if f_pos == 1, return &quot;..&quot;.&n;&n;&t;&t;&t;So let msdos handle it&n;&n;&t;&t;&t;Since umsdos entries are much larger, we share the same f_pos.&n;&t;&t;&t;if f_pos is 0 or 1 or 32, we are clearly looking at . and&n;&t;&t;&t;..&n;&n;&t;&t;&t;As soon as we get f_pos == 2 or f_pos == 64, then back to&n;&t;&t;&t;0, but this time we are reading the EMD file.&n;&n;&t;&t;&t;Well, not so true. The problem, is that UMSDOS_REC_SIZE is&n;&t;&t;&t;also 64, so as soon as we read the first record in the&n;&t;&t;&t;EMD, we are back at offset 64. So we set the offset&n;&t;&t;&t;to UMSDOS_SPECIAL_DIRFPOS(3) as soon as we have read the&n;&t;&t;&t;.. entry from msdos.&n;&t;&t;*/
id|ret
op_assign
id|msdos_readdir
c_func
(paren
id|dir
comma
id|filp
comma
id|dirent
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_pos
op_eq
l_int|64
)paren
id|filp-&gt;f_pos
op_assign
id|UMSDOS_SPECIAL_DIRFPOS
suffix:semicolon
r_if
c_cond
(paren
id|u_entry
op_ne
l_int|NULL
)paren
id|u_entry-&gt;flags
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_struct
id|inode
op_star
id|emd_dir
op_assign
id|umsdos_emd_dir_lookup
c_func
(paren
id|dir
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|emd_dir
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|filp-&gt;f_pos
op_le
id|UMSDOS_SPECIAL_DIRFPOS
op_plus
l_int|1
)paren
id|filp-&gt;f_pos
op_assign
l_int|0
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;f_pos %ld i_size %d&bslash;n&quot;
comma
id|filp-&gt;f_pos
comma
id|emd_dir-&gt;i_size
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|filp-&gt;f_pos
OL
id|emd_dir-&gt;i_size
)paren
(brace
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
id|off_t
id|cur_f_pos
op_assign
id|filp-&gt;f_pos
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_emd_dir_readentry
(paren
id|emd_dir
comma
id|filp
comma
op_amp
id|entry
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry.name_len
op_ne
l_int|0
)paren
(brace
multiline_comment|/* #Specification: umsdos / readdir&n;&t;&t;&t;&t;&t;&t;umsdos_readdir() should fill a struct dirent with&n;&t;&t;&t;&t;&t;&t;an inode number. The cheap way to get it is to&n;&t;&t;&t;&t;&t;&t;do a lookup in the MSDOS directory for each&n;&t;&t;&t;&t;&t;&t;entry processed by the readdir() function.&n;&t;&t;&t;&t;&t;&t;This is not very efficient, but very simple. The&n;&t;&t;&t;&t;&t;&t;other way around is to maintain a copy of the inode&n;&t;&t;&t;&t;&t;&t;number in the EMD file. This is a problem because&n;&t;&t;&t;&t;&t;&t;this has to be maintained in sync using tricks.&n;&t;&t;&t;&t;&t;&t;Remember that MSDOS (the OS) does not update the&n;&t;&t;&t;&t;&t;&t;modification time (mtime) of a directory. There is&n;&t;&t;&t;&t;&t;&t;no easy way to tell that a directory was modified&n;&t;&t;&t;&t;&t;&t;during a DOS session and synchronise the EMD file.&n;&n;&t;&t;&t;&t;&t;&t;Suggestion welcome.&n;&n;&t;&t;&t;&t;&t;&t;So the easy way is used!&n;&t;&t;&t;&t;&t;*/
r_struct
id|umsdos_info
id|info
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|lret
suffix:semicolon
id|umsdos_parse
(paren
id|entry.name
comma
id|entry.name_len
comma
op_amp
id|info
)paren
suffix:semicolon
id|info.f_pos
op_assign
id|cur_f_pos
suffix:semicolon
op_star
id|pt_f_pos
op_assign
id|cur_f_pos
suffix:semicolon
id|umsdos_manglename
(paren
op_amp
id|info
)paren
suffix:semicolon
id|lret
op_assign
id|umsdos_real_lookup
(paren
id|dir
comma
id|info.fake.fname
comma
id|info.fake.len
comma
op_amp
id|inode
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;Cherche inode de %s lret %d flags %d&bslash;n&quot;
comma
id|info.fake.fname
comma
id|lret
comma
id|entry.flags
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lret
op_eq
l_int|0
op_logical_and
(paren
id|entry.flags
op_amp
id|UMSDOS_HLINK
)paren
op_logical_and
id|follow_hlink
)paren
(brace
r_struct
id|inode
op_star
id|rinode
suffix:semicolon
id|lret
op_assign
id|umsdos_hlink2inode
(paren
id|inode
comma
op_amp
id|rinode
)paren
suffix:semicolon
id|inode
op_assign
id|rinode
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lret
op_eq
l_int|0
)paren
(brace
multiline_comment|/* #Specification: pseudo root / reading real root&n;&t;&t;&t;&t;&t;&t;&t;The pseudo root (/linux) is logically&n;&t;&t;&t;&t;&t;&t;&t;erased from the real root. This mean that&n;&t;&t;&t;&t;&t;&t;&t;ls /DOS, won&squot;t show &quot;linux&quot;. This avoids&n;&t;&t;&t;&t;&t;&t;&t;infinite recursion /DOS/linux/DOS/linux while&n;&t;&t;&t;&t;&t;&t;&t;walking the file system.&n;&t;&t;&t;&t;&t;&t;*/
r_if
c_cond
(paren
id|inode
op_ne
id|pseudo_root
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;Trouve ino %d &quot;
comma
id|inode-&gt;i_ino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dirent_in_fs
)paren
(brace
id|put_fs_long
c_func
(paren
id|inode-&gt;i_ino
comma
op_amp
id|dirent-&gt;d_ino
)paren
suffix:semicolon
id|memcpy_tofs
(paren
id|dirent-&gt;d_name
comma
id|entry.name
comma
id|entry.name_len
)paren
suffix:semicolon
id|put_fs_byte
c_func
(paren
l_int|0
comma
id|dirent-&gt;d_name
op_plus
id|entry.name_len
)paren
suffix:semicolon
id|put_fs_word
(paren
id|entry.name_len
comma
op_amp
id|dirent-&gt;d_reclen
)paren
suffix:semicolon
multiline_comment|/* In this case, the caller only needs */
multiline_comment|/* flags */
r_if
c_cond
(paren
id|u_entry
op_ne
l_int|NULL
)paren
(brace
id|u_entry-&gt;flags
op_assign
id|entry.flags
suffix:semicolon
)brace
)brace
r_else
(brace
id|dirent-&gt;d_ino
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|memcpy
(paren
id|dirent-&gt;d_name
comma
id|entry.name
comma
id|entry.name_len
)paren
suffix:semicolon
id|dirent-&gt;d_name
(braket
id|entry.name_len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|dirent-&gt;d_reclen
op_assign
id|entry.name_len
suffix:semicolon
r_if
c_cond
(paren
id|u_entry
op_ne
l_int|NULL
)paren
op_star
id|u_entry
op_assign
id|entry
suffix:semicolon
)brace
id|ret
op_assign
id|entry.name_len
suffix:semicolon
id|iput
(paren
id|inode
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|iput
(paren
id|inode
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* #Specification: umsdos / readdir / not in MSDOS&n;&t;&t;&t;&t;&t;&t;&t;During a readdir operation, if the file is not&n;&t;&t;&t;&t;&t;&t;&t;in the MSDOS directory anymore, the entry is&n;&t;&t;&t;&t;&t;&t;&t;removed from the EMD file silently.&n;&t;&t;&t;&t;&t;&t;*/
id|ret
op_assign
id|umsdos_writeentry
(paren
id|dir
comma
id|emd_dir
comma
op_amp
id|info
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
id|iput
c_func
(paren
id|emd_dir
)paren
suffix:semicolon
)brace
)brace
id|umsdos_endlookup
c_func
(paren
id|dir
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;read dir %p pos %d ret %d&bslash;n&quot;
comma
id|dir
comma
id|filp-&gt;f_pos
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Read count directory entries from directory filp&n;&t;Return a negative value from linux/errno.h.&n;&t;Return &gt; 0 if success (the length of the file name).&n;*/
DECL|function|UMSDOS_readdir
r_static
r_int
id|UMSDOS_readdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
multiline_comment|/* Point to a description of the super block */
r_struct
id|file
op_star
id|filp
comma
multiline_comment|/* Point to a directory which is read */
r_struct
id|dirent
op_star
id|dirent
comma
multiline_comment|/* Will hold count directory entry */
r_int
id|count
)paren
(brace
r_int
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
id|off_t
id|f_pos
suffix:semicolon
id|ret
op_assign
id|umsdos_readdir_x
(paren
id|dir
comma
id|filp
comma
id|dirent
comma
l_int|1
comma
id|count
comma
op_amp
id|entry
comma
l_int|1
comma
op_amp
id|f_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_le
l_int|0
op_logical_or
op_logical_neg
(paren
id|entry.flags
op_amp
id|UMSDOS_HIDDEN
)paren
)paren
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Complete the inode content with info from the EMD file&n;*/
DECL|function|umsdos_lookup_patch
r_void
id|umsdos_lookup_patch
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|umsdos_dirent
op_star
id|entry
comma
id|off_t
id|emd_pos
)paren
(brace
multiline_comment|/*&n;&t;&t;This function modify the state of a dir inode. It decides&n;&t;&t;if the dir is a umsdos dir or a dos dir. This is done&n;&t;&t;deeper in umsdos_patch_inode() called at the end of this function.&n;&n;&t;&t;umsdos_patch_inode() may block because it is doing disk access.&n;&t;&t;At the same time, another process may get here to initialise&n;&t;&t;the same dir inode. There is 3 cases.&n;&n;&t;&t;1-The inode is already initialised. We do nothing.&n;&t;&t;2-The inode is not initialised. We lock access and do it.&n;&t;&t;3-Like 2 but another process has lock the inode, so we try&n;&t;&t;  to lock it and right after check if initialisation is still&n;&t;&t;  needed.&n;&n;&n;&t;&t;Thanks to the mem option of the kernel command line, it was&n;&t;&t;possible to consistently reproduce this problem by limiting&n;&t;&t;my mem to 4 meg and running X.&n;&t;*/
multiline_comment|/*&n;&t;&t;Do this only if the inode is freshly read, because we will lose&n;&t;&t;the current (updated) content.&n;&t;*/
multiline_comment|/*&n;&t;&t;A lookup of a mount point directory yield the inode into&n;&t;&t;the other fs, so we don&squot;t care about initialising it. iget()&n;&t;&t;does this automatically.&n;&t;*/
r_if
c_cond
(paren
id|inode-&gt;i_sb
op_eq
id|dir-&gt;i_sb
op_logical_and
op_logical_neg
id|umsdos_isinit
c_func
(paren
id|inode
)paren
)paren
(brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
id|umsdos_lockcreate
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|umsdos_isinit
c_func
(paren
id|inode
)paren
)paren
(brace
multiline_comment|/* #Specification: umsdos / lookup / inode info&n;&t;&t;&t;&t;After successfully reading an inode from the MSDOS&n;&t;&t;&t;&t;filesystem, we use the EMD file to complete it.&n;&t;&t;&t;&t;We update the following field.&n;&n;&t;&t;&t;&t;uid, gid, atime, ctime, mtime, mode.&n;&n;&t;&t;&t;&t;We rely on MSDOS for mtime. If the file&n;&t;&t;&t;&t;was modified during an MSDOS session, at least&n;&t;&t;&t;&t;mtime will be meaningful. We do this only for regular&n;&t;&t;&t;&t;file.&n;&t;&t;&t;&t;&n;&t;&t;&t;&t;We don&squot;t rely on MSDOS for mtime for directory because&n;&t;&t;&t;&t;the MSDOS directory date is creation time (strange&n;&t;&t;&t;&t;MSDOS behavior) which fit nowhere in the three UNIX&n;&t;&t;&t;&t;time stamp.&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|entry-&gt;mode
)paren
)paren
id|entry-&gt;mtime
op_assign
id|inode-&gt;i_mtime
suffix:semicolon
id|inode-&gt;i_mode
op_assign
id|entry-&gt;mode
suffix:semicolon
id|inode-&gt;i_rdev
op_assign
id|entry-&gt;rdev
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|entry-&gt;atime
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|entry-&gt;ctime
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
id|entry-&gt;mtime
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|entry-&gt;uid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|entry-&gt;gid
suffix:semicolon
multiline_comment|/* #Specification: umsdos / i_nlink&n;&t;&t;&t;&t;The nlink field of an inode is maintain by the MSDOS file system&n;&t;&t;&t;&t;for directory and by UMSDOS for other file. The logic is that&n;&t;&t;&t;&t;MSDOS is already figuring out what to do for directories and&n;&t;&t;&t;&t;does nothing for other files. For MSDOS, there are no hard link&n;&t;&t;&t;&t;so all file carry nlink==1. UMSDOS use some info in the&n;&t;&t;&t;&t;EMD file to plug the correct value.&n;&t;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|entry-&gt;mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;nlink
OG
l_int|0
)paren
(brace
id|inode-&gt;i_nlink
op_assign
id|entry-&gt;nlink
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;UMSDOS: lookup_patch entry-&gt;nlink &lt; 1 ???&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|umsdos_patch_inode
c_func
(paren
id|inode
comma
id|dir
comma
id|emd_pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
id|umsdos_unlockcreate
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;u.umsdos_i.i_emd_owner
op_eq
l_int|0
)paren
id|printk
(paren
l_string|&quot;emd_owner still 0 ???&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;Locate entry of an inode in a directory.&n;&t;Return 0 or a negative error code.&n;&n;&t;Normally, this function must succeed. It means a strange corruption&n;&t;in the file system if not.&n;*/
DECL|function|umsdos_inode2entry
r_int
id|umsdos_inode2entry
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|umsdos_dirent
op_star
id|entry
)paren
multiline_comment|/* Will hold the entry */
(brace
r_int
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_eq
id|pseudo_root
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;Quick way to find the name.&n;&t;&t;&t;Also umsdos_readdir_x won&squot;t show /linux anyway&n;&t;&t;*/
id|memcpy
(paren
id|entry-&gt;name
comma
id|UMSDOS_PSDROOT_NAME
comma
id|UMSDOS_PSDROOT_LEN
op_plus
l_int|1
)paren
suffix:semicolon
id|entry-&gt;name_len
op_assign
id|UMSDOS_PSDROOT_LEN
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_struct
id|inode
op_star
id|emddir
op_assign
id|umsdos_emd_dir_lookup
c_func
(paren
id|dir
comma
l_int|0
)paren
suffix:semicolon
id|iput
(paren
id|emddir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|emddir
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* This is a DOS directory */
r_struct
id|file
id|filp
suffix:semicolon
id|filp.f_reada
op_assign
l_int|1
suffix:semicolon
id|filp.f_pos
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|dirent
id|dirent
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_readdir_kmem
(paren
id|dir
comma
op_amp
id|filp
comma
op_amp
id|dirent
comma
l_int|1
)paren
op_le
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: can&squot;t locate inode %ld in DOS directory???&bslash;n&quot;
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dirent.d_ino
op_eq
id|inode-&gt;i_ino
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|memcpy
(paren
id|entry-&gt;name
comma
id|dirent.d_name
comma
id|dirent.d_reclen
)paren
suffix:semicolon
id|entry-&gt;name
(braket
id|dirent.d_reclen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|entry-&gt;name_len
op_assign
id|dirent.d_reclen
suffix:semicolon
id|inode-&gt;u.umsdos_i.i_dir_owner
op_assign
id|dir-&gt;i_ino
suffix:semicolon
id|inode-&gt;u.umsdos_i.i_emd_owner
op_assign
l_int|0
suffix:semicolon
id|umsdos_setup_dir_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* skip . and .. see umsdos_readdir_x() */
r_struct
id|file
id|filp
suffix:semicolon
id|filp.f_reada
op_assign
l_int|1
suffix:semicolon
id|filp.f_pos
op_assign
id|UMSDOS_SPECIAL_DIRFPOS
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|dirent
id|dirent
suffix:semicolon
id|off_t
id|f_pos
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_readdir_x
c_func
(paren
id|dir
comma
op_amp
id|filp
comma
op_amp
id|dirent
comma
l_int|0
comma
l_int|1
comma
id|entry
comma
l_int|0
comma
op_amp
id|f_pos
)paren
op_le
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: can&squot;t locate inode %ld in EMD file???&bslash;n&quot;
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dirent.d_ino
op_eq
id|inode-&gt;i_ino
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|umsdos_lookup_patch
(paren
id|dir
comma
id|inode
comma
id|entry
comma
id|f_pos
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Locate the parent of a directory and the info on that directory&n;&t;Return 0 or a negative error code.&n;*/
DECL|function|umsdos_locate_ancestor
r_static
r_int
id|umsdos_locate_ancestor
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|inode
op_star
op_star
id|result
comma
r_struct
id|umsdos_dirent
op_star
id|entry
)paren
(brace
r_int
id|ret
suffix:semicolon
id|umsdos_patch_inode
(paren
id|dir
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_real_lookup
(paren
id|dir
comma
l_string|&quot;..&quot;
comma
l_int|2
comma
id|result
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;result %d %x &quot;
comma
id|ret
comma
op_star
id|result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|inode
op_star
id|adir
op_assign
op_star
id|result
suffix:semicolon
id|ret
op_assign
id|umsdos_inode2entry
(paren
id|adir
comma
id|dir
comma
id|entry
)paren
suffix:semicolon
)brace
id|PRINTK
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Build the path name of an inode (relative to the file system.&n;&t;This function is need to set (pseudo) hard link.&n;&n;&t;It uses the same strategy as the standard getcwd().&n;*/
DECL|function|umsdos_locate_path
r_int
id|umsdos_locate_path
(paren
r_struct
id|inode
op_star
id|inode
comma
r_char
op_star
id|path
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|inode
op_star
id|dir
op_assign
id|inode
suffix:semicolon
r_char
op_star
id|bpath
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|PATH_MAX
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bpath
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
r_char
op_star
id|ptbpath
op_assign
id|bpath
op_plus
id|PATH_MAX
op_minus
l_int|1
suffix:semicolon
op_star
id|ptbpath
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;locate_path mode %x &quot;
comma
id|inode-&gt;i_mode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|ret
op_assign
id|umsdos_get_dirowner
(paren
id|inode
comma
op_amp
id|dir
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;locate_path ret %d &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|umsdos_inode2entry
(paren
id|dir
comma
id|inode
comma
op_amp
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ptbpath
op_sub_assign
id|entry.name_len
suffix:semicolon
id|memcpy
(paren
id|ptbpath
comma
id|entry.name
comma
id|entry.name_len
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;ptbpath :%s: &quot;
comma
id|ptbpath
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|dir-&gt;i_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|dir
op_ne
id|dir-&gt;i_sb-&gt;s_mounted
)paren
(brace
r_struct
id|inode
op_star
id|adir
suffix:semicolon
id|ret
op_assign
id|umsdos_locate_ancestor
(paren
id|dir
comma
op_amp
id|adir
comma
op_amp
id|entry
)paren
suffix:semicolon
id|iput
(paren
id|dir
)paren
suffix:semicolon
id|dir
op_assign
l_int|NULL
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;ancestor %d &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
op_star
op_decrement
id|ptbpath
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|ptbpath
op_sub_assign
id|entry.name_len
suffix:semicolon
id|memcpy
(paren
id|ptbpath
comma
id|entry.name
comma
id|entry.name_len
)paren
suffix:semicolon
id|dir
op_assign
id|adir
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;ptbpath :%s: &quot;
comma
id|ptbpath
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
id|strcpy
(paren
id|path
comma
id|ptbpath
)paren
suffix:semicolon
id|kfree
(paren
id|bpath
)paren
suffix:semicolon
)brace
id|PRINTK
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|iput
(paren
id|dir
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Return != 0 if an entry is the pseudo DOS entry in the pseudo root.&n;*/
DECL|function|umsdos_is_pseudodos
r_int
id|umsdos_is_pseudodos
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
multiline_comment|/* #Specification: pseudo root / DOS hard coded&n;&t;&t;The pseudo sub-directory DOS in the pseudo root is hard coded.&n;&t;&t;The name is DOS. This is done this way to help standardised&n;&t;&t;the umsdos layout. The idea is that from now on /DOS is&n;&t;&t;a reserved path and nobody will think of using such a path&n;&t;&t;for a package.&n;&t;*/
r_return
id|dir
op_eq
id|pseudo_root
op_logical_and
id|len
op_eq
l_int|3
op_logical_and
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;D&squot;
op_logical_and
id|name
(braket
l_int|1
)braket
op_eq
l_char|&squot;O&squot;
op_logical_and
id|name
(braket
l_int|2
)braket
op_eq
l_char|&squot;S&squot;
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Check if a file exist in the current directory.&n;&t;Return 0 if ok, negative error code if not (ex: -ENOENT).&n;*/
DECL|function|umsdos_lookup_x
r_static
r_int
id|umsdos_lookup_x
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
r_struct
id|inode
op_star
op_star
id|result
comma
multiline_comment|/* Will hold inode of the file, if successful */
r_int
id|nopseudo
)paren
multiline_comment|/* Don&squot;t care about pseudo root mode */
(brace
r_int
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
id|umsdos_startlookup
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|1
op_logical_and
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
op_star
id|result
op_assign
id|dir
suffix:semicolon
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|len
op_eq
l_int|2
op_logical_and
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
id|name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
r_if
c_cond
(paren
id|pseudo_root
op_ne
l_int|NULL
op_logical_and
id|dir
op_eq
id|pseudo_root-&gt;i_sb-&gt;s_mounted
)paren
(brace
multiline_comment|/* #Specification: pseudo root / .. in real root&n;&t;&t;&t;&t;Whenever a lookup is those in the real root for&n;&t;&t;&t;&t;the directory .., and pseudo root is active, the&n;&t;&t;&t;&t;pseudo root is returned.&n;&t;&t;&t;*/
id|ret
op_assign
l_int|0
suffix:semicolon
op_star
id|result
op_assign
id|pseudo_root
suffix:semicolon
id|pseudo_root-&gt;i_count
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* #Specification: locating .. / strategy&n;&t;&t;&t;&t;We use the msdos filesystem to locate the parent directory.&n;&t;&t;&t;&t;But it is more complicated than that.&n;&t;&t;&t;&t;&n;&t;&t;&t;&t;We have to step back even further to&n;&t;&t;&t;&t;get the parent of the parent, so we can get the EMD&n;&t;&t;&t;&t;of the parent of the parent. Using the EMD file, we can&n;&t;&t;&t;&t;locate all the info on the parent, such a permissions&n;&t;&t;&t;&t;and owner.&n;&t;&t;&t;*/
id|ret
op_assign
id|umsdos_real_lookup
(paren
id|dir
comma
l_string|&quot;..&quot;
comma
l_int|2
comma
id|result
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;ancestor ret %d dir %p *result %p &quot;
comma
id|ret
comma
id|dir
comma
op_star
id|result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
op_logical_and
op_star
id|result
op_ne
id|dir-&gt;i_sb-&gt;s_mounted
op_logical_and
op_star
id|result
op_ne
id|pseudo_root
)paren
(brace
r_struct
id|inode
op_star
id|aadir
suffix:semicolon
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
id|ret
op_assign
id|umsdos_locate_ancestor
(paren
op_star
id|result
comma
op_amp
id|aadir
comma
op_amp
id|entry
)paren
suffix:semicolon
id|iput
(paren
id|aadir
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|umsdos_is_pseudodos
c_func
(paren
id|dir
comma
id|name
comma
id|len
)paren
)paren
(brace
multiline_comment|/* #Specification: pseudo root / lookup(DOS)&n;&t;&t;&t;A lookup of DOS in the pseudo root will always succeed&n;&t;&t;&t;and return the inode of the real root.&n;&t;&t;*/
op_star
id|result
op_assign
id|dir-&gt;i_sb-&gt;s_mounted
suffix:semicolon
(paren
op_star
id|result
)paren
op_member_access_from_pointer
id|i_count
op_increment
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|ret
op_assign
id|umsdos_parse
(paren
id|name
comma
id|len
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|umsdos_findentry
(paren
id|dir
comma
op_amp
id|info
comma
l_int|0
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;lookup %s pos %d ret %d len %d &quot;
comma
id|info.fake.fname
comma
id|info.f_pos
comma
id|ret
comma
id|info.fake.len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/* #Specification: umsdos / lookup&n;&t;&t;&t;&t;A lookup for a file is done in two step. First, we locate&n;&t;&t;&t;&t;the file in the EMD file. If not present, we return&n;&t;&t;&t;&t;an error code (-ENOENT). If it is there, we repeat the&n;&t;&t;&t;&t;operation on the msdos file system. If this fails, it means&n;&t;&t;&t;&t;that the file system is not in sync with the emd file.&n;&t;&t;&t;&t;We silently remove this entry from the emd file,&n;&t;&t;&t;&t;and return ENOENT.&n;&t;&t;&t;*/
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|ret
op_assign
id|umsdos_real_lookup
(paren
id|dir
comma
id|info.fake.fname
comma
id|info.fake.len
comma
id|result
)paren
suffix:semicolon
id|inode
op_assign
op_star
id|result
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: Erase entry %s, out of sync with MsDOS&bslash;n&quot;
comma
id|info.fake.fname
)paren
suffix:semicolon
id|umsdos_delentry
(paren
id|dir
comma
op_amp
id|info
comma
id|S_ISDIR
c_func
(paren
id|info.entry.mode
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|umsdos_lookup_patch
(paren
id|dir
comma
id|inode
comma
op_amp
id|info.entry
comma
id|info.f_pos
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;lookup ino %d flags %d&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|info.entry.flags
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info.entry.flags
op_amp
id|UMSDOS_HLINK
)paren
(brace
id|ret
op_assign
id|umsdos_hlink2inode
(paren
id|inode
comma
id|result
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|result
op_eq
id|pseudo_root
op_logical_and
op_logical_neg
id|nopseudo
)paren
(brace
multiline_comment|/* #Specification: pseudo root / dir lookup&n;&t;&t;&t;&t;&t;&t;For the same reason as readdir, a lookup in /DOS for&n;&t;&t;&t;&t;&t;&t;the pseudo root directory (linux) will fail.&n;&t;&t;&t;&t;&t;*/
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;This has to be allowed for resolving hard link&n;&t;&t;&t;&t;&t;&t;which are recorded independently of the pseudo-root&n;&t;&t;&t;&t;&t;&t;mode.&n;&t;&t;&t;&t;&t;*/
id|iput
(paren
id|pseudo_root
)paren
suffix:semicolon
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
)brace
)brace
)brace
)brace
id|umsdos_endlookup
c_func
(paren
id|dir
)paren
suffix:semicolon
id|iput
(paren
id|dir
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Check if a file exist in the current directory.&n;&t;Return 0 if ok, negative error code if not (ex: -ENOENT).&n;*/
DECL|function|UMSDOS_lookup
r_int
id|UMSDOS_lookup
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
r_struct
id|inode
op_star
op_star
id|result
)paren
multiline_comment|/* Will hold inode of the file, if successful */
(brace
r_return
id|umsdos_lookup_x
c_func
(paren
id|dir
comma
id|name
comma
id|len
comma
id|result
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Locate the inode pointed by a (pseudo) hard link&n;&t;Return 0 if ok, a negative error code if not.&n;*/
DECL|function|umsdos_hlink2inode
r_int
id|umsdos_hlink2inode
(paren
r_struct
id|inode
op_star
id|hlink
comma
r_struct
id|inode
op_star
op_star
id|result
)paren
(brace
r_int
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_char
op_star
id|path
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|PATH_MAX
comma
id|GFP_KERNEL
)paren
suffix:semicolon
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|path
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|iput
(paren
id|hlink
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|file
id|filp
suffix:semicolon
id|filp.f_reada
op_assign
l_int|1
suffix:semicolon
id|filp.f_pos
op_assign
l_int|0
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;hlink2inode &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_file_read_kmem
(paren
id|hlink
comma
op_amp
id|filp
comma
id|path
comma
id|hlink-&gt;i_size
)paren
op_eq
id|hlink-&gt;i_size
)paren
(brace
r_struct
id|inode
op_star
id|dir
suffix:semicolon
r_char
op_star
id|pt
op_assign
id|path
suffix:semicolon
id|dir
op_assign
id|hlink-&gt;i_sb-&gt;s_mounted
suffix:semicolon
id|path
(braket
id|hlink-&gt;i_size
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|iput
(paren
id|hlink
)paren
suffix:semicolon
id|dir-&gt;i_count
op_increment
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_char
op_star
id|start
op_assign
id|pt
suffix:semicolon
r_int
id|len
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pt
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
op_star
id|pt
op_ne
l_char|&squot;/&squot;
)paren
id|pt
op_increment
suffix:semicolon
id|len
op_assign
(paren
r_int
)paren
(paren
id|pt
op_minus
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pt
op_eq
l_char|&squot;/&squot;
)paren
op_star
id|pt
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.i_emd_dir
op_eq
l_int|0
)paren
(brace
multiline_comment|/* This is a DOS directory */
id|ret
op_assign
id|msdos_lookup
c_func
(paren
id|dir
comma
id|start
comma
id|len
comma
id|result
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
id|umsdos_lookup_x
c_func
(paren
id|dir
comma
id|start
comma
id|len
comma
id|result
comma
l_int|1
)paren
suffix:semicolon
)brace
id|PRINTK
(paren
(paren
l_string|&quot;h2n lookup :%s: -&gt; %d &quot;
comma
id|start
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
op_logical_and
op_star
id|pt
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|dir
op_assign
op_star
id|result
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|iput
(paren
id|hlink
)paren
suffix:semicolon
)brace
id|PRINTK
(paren
(paren
l_string|&quot;hlink2inode ret = %d %p -&gt; %p&bslash;n&quot;
comma
id|ret
comma
id|hlink
comma
op_star
id|result
)paren
)paren
suffix:semicolon
id|kfree
(paren
id|path
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|umsdos_dir_operations
r_static
r_struct
id|file_operations
id|umsdos_dir_operations
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|UMSDOS_dir_read
comma
multiline_comment|/* read */
l_int|NULL
comma
multiline_comment|/* write - bad */
id|UMSDOS_readdir
comma
multiline_comment|/* readdir */
l_int|NULL
comma
multiline_comment|/* select - default */
id|UMSDOS_ioctl_dir
comma
multiline_comment|/* ioctl - default */
l_int|NULL
comma
multiline_comment|/* mmap */
l_int|NULL
comma
multiline_comment|/* no special open code */
l_int|NULL
comma
multiline_comment|/* no special release code */
l_int|NULL
multiline_comment|/* fsync */
)brace
suffix:semicolon
DECL|variable|umsdos_dir_inode_operations
r_struct
id|inode_operations
id|umsdos_dir_inode_operations
op_assign
(brace
op_amp
id|umsdos_dir_operations
comma
multiline_comment|/* default directory file-ops */
id|UMSDOS_create
comma
multiline_comment|/* create */
id|UMSDOS_lookup
comma
multiline_comment|/* lookup */
id|UMSDOS_link
comma
multiline_comment|/* link */
id|UMSDOS_unlink
comma
multiline_comment|/* unlink */
id|UMSDOS_symlink
comma
multiline_comment|/* symlink */
id|UMSDOS_mkdir
comma
multiline_comment|/* mkdir */
id|UMSDOS_rmdir
comma
multiline_comment|/* rmdir */
id|UMSDOS_mknod
comma
multiline_comment|/* mknod */
id|UMSDOS_rename
comma
multiline_comment|/* rename */
l_int|NULL
comma
multiline_comment|/* readlink */
l_int|NULL
comma
multiline_comment|/* follow_link */
l_int|NULL
comma
multiline_comment|/* bmap */
l_int|NULL
comma
multiline_comment|/* truncate */
l_int|NULL
multiline_comment|/* permission */
)brace
suffix:semicolon
eof
