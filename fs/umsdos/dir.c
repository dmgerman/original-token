multiline_comment|/*&n; *  linux/fs/umsdos/dir.c&n; *&n; *  Written 1993 by Jacques Gelinas&n; *&t;Inspired from linux/fs/msdos/... : Werner Almesberger&n; *&n; *  Extended MS-DOS directory handling functions&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/msdos_fs.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/limits.h&gt;
macro_line|#include &lt;linux/umsdos_fs.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x)
DECL|macro|Printk
mdefine_line|#define Printk(x) printk x
DECL|macro|UMSDOS_SPECIAL_DIRFPOS
mdefine_line|#define UMSDOS_SPECIAL_DIRFPOS&t;3
r_extern
r_struct
id|inode
op_star
id|pseudo_root
suffix:semicolon
multiline_comment|/* P.T.Waltenberg&n;   I&squot;ve retained this to facilitate the lookup of some of the hard-wired files/directories UMSDOS&n;   uses. It&squot;s easier to do once than hack all the other instances. Probably safer as well&n;*/
DECL|function|compat_umsdos_real_lookup
r_int
id|compat_umsdos_real_lookup
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
r_struct
id|inode
op_star
op_star
id|inode
)paren
(brace
r_int
id|rv
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|dentry
op_assign
id|creat_dentry
(paren
id|name
comma
id|len
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|rv
op_assign
id|umsdos_real_lookup
c_func
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|kill_dentry
(paren
id|dentry
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|compat_msdos_create
r_int
id|compat_msdos_create
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
r_int
id|mode
comma
r_struct
id|inode
op_star
op_star
id|inode
)paren
(brace
r_int
id|rv
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|dentry
op_assign
id|creat_dentry
(paren
id|name
comma
id|len
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|rv
op_assign
id|msdos_create
c_func
(paren
id|dir
comma
id|dentry
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_ne
l_int|NULL
)paren
(brace
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
)brace
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/*&n;&t;So  grep *  doesn&squot;t complain in the presence of directories.&n;*/
DECL|function|UMSDOS_dir_read
r_int
id|UMSDOS_dir_read
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buff
comma
r_int
id|size
comma
id|loff_t
op_star
id|count
)paren
(brace
r_return
op_minus
id|EISDIR
suffix:semicolon
)brace
DECL|struct|UMSDOS_DIR_ONCE
r_struct
id|UMSDOS_DIR_ONCE
(brace
DECL|member|dirbuf
r_void
op_star
id|dirbuf
suffix:semicolon
DECL|member|filldir
id|filldir_t
id|filldir
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|stop
r_int
id|stop
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;Record a single entry the first call.&n;&t;Return -EINVAL the next one.&n;&t;NOTE: filldir DOES NOT use a dentry&n;*/
DECL|function|umsdos_dir_once
r_static
r_int
id|umsdos_dir_once
c_func
(paren
r_void
op_star
id|buf
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
id|off_t
id|offset
comma
id|ino_t
id|ino
)paren
(brace
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_struct
id|UMSDOS_DIR_ONCE
op_star
id|d
op_assign
(paren
r_struct
id|UMSDOS_DIR_ONCE
op_star
)paren
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;count
op_eq
l_int|0
)paren
(brace
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;dir_once :%.*s: offset %Ld&bslash;n&quot;
comma
id|dentry-&gt;d_len
comma
id|dentry-&gt;d_name
comma
id|offset
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|d-&gt;filldir
(paren
id|d-&gt;dirbuf
comma
id|name
comma
id|len
comma
id|offset
comma
id|ino
)paren
suffix:semicolon
id|d-&gt;stop
op_assign
id|ret
OL
l_int|0
suffix:semicolon
id|d-&gt;count
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;  Read count directory entries from directory filp&n;  Return a negative value from linux/errno.h.&n;  Return &gt; 0 if success (The amount of byte written by filldir).&n;  &n;  This function is used by the normal readdir VFS entry point and by&n;  some function who try to find out info on a file from a pure MSDOS&n;  inode. See umsdos_locate_ancestor() below.&n;*/
DECL|function|umsdos_readdir_x
r_static
r_int
id|umsdos_readdir_x
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
multiline_comment|/* Point to a description of the super block */
r_struct
id|file
op_star
id|filp
comma
multiline_comment|/* Point to a directory which is read */
r_void
op_star
id|dirbuf
comma
multiline_comment|/* Will hold count directory entry */
multiline_comment|/* but filled by the filldir function */
r_int
id|internal_read
comma
multiline_comment|/* Called for internal purpose */
r_struct
id|umsdos_dirent
op_star
id|u_entry
comma
multiline_comment|/* Optional umsdos entry */
r_int
id|follow_hlink
comma
id|filldir_t
id|filldir
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|inode
op_star
id|root_inode
suffix:semicolon
id|root_inode
op_assign
id|iget
c_func
(paren
id|dir-&gt;i_sb
comma
id|UMSDOS_ROOT_INO
)paren
suffix:semicolon
id|umsdos_startlookup
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_pos
op_eq
id|UMSDOS_SPECIAL_DIRFPOS
op_logical_and
id|pseudo_root
op_logical_and
id|dir
op_eq
id|pseudo_root
op_logical_and
op_logical_neg
id|internal_read
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;umsdos_readdir_x: what UMSDOS_SPECIAL_DIRFPOS /mn/?&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;      We don&squot;t need to simulate this pseudo directory&n;      when umsdos_readdir_x is called for internal operation&n;      of umsdos. This is why dirent_in_fs is tested&n;    */
multiline_comment|/* #Specification: pseudo root / directory /DOS&n;       When umsdos operates in pseudo root mode (C:&bslash;linux is the&n;       linux root), it simulate a directory /DOS which points to&n;       the real root of the file system.&n;    */
r_if
c_cond
(paren
id|filldir
(paren
id|dirbuf
comma
l_string|&quot;DOS&quot;
comma
l_int|3
comma
id|UMSDOS_SPECIAL_DIRFPOS
comma
id|UMSDOS_ROOT_INO
)paren
op_eq
l_int|0
)paren
(brace
id|filp-&gt;f_pos
op_increment
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|filp-&gt;f_pos
OL
l_int|2
op_logical_or
(paren
id|dir
op_ne
id|root_inode
op_logical_and
id|filp-&gt;f_pos
op_eq
l_int|32
)paren
)paren
(brace
multiline_comment|/* #Specification: readdir / . and ..&n;       The msdos filesystem manage the . and .. entry properly&n;       so the EMD file won&squot;t hold any info about it.&n;       &n;       In readdir, we assume that for the root directory&n;       the read position will be 0 for &quot;.&quot;, 1 for &quot;..&quot;. For&n;       a non root directory, the read position will be 0 for &quot;.&quot;&n;       and 32 for &quot;..&quot;.&n;    */
multiline_comment|/*&n;      This is a trick used by the msdos file system (fs/msdos/dir.c)&n;      to manage . and .. for the root directory of a file system.&n;      Since there is no such entry in the root, fs/msdos/dir.c&n;      use the following:&n;      &n;      if f_pos == 0, return &quot;.&quot;.&n;      if f_pos == 1, return &quot;..&quot;.&n;      &n;      So let msdos handle it&n;      &n;      Since umsdos entries are much larger, we share the same f_pos.&n;      if f_pos is 0 or 1 or 32, we are clearly looking at . and&n;      ..&n;      &n;      As soon as we get f_pos == 2 or f_pos == 64, then back to&n;      0, but this time we are reading the EMD file.&n;      &n;      Well, not so true. The problem, is that UMSDOS_REC_SIZE is&n;      also 64, so as soon as we read the first record in the&n;      EMD, we are back at offset 64. So we set the offset&n;      to UMSDOS_SPECIAL_DIRFPOS(3) as soon as we have read the&n;      .. entry from msdos.&n;      &n;      Now (linux 1.3), umsdos_readdir can read more than one&n;      entry even if we limit (umsdos_dir_once) to only one:&n;      It skips over hidden file. So we switch to&n;      UMSDOS_SPECIAL_DIRFPOS as soon as we have read successfully&n;      the .. entry.&n;    */
r_int
id|last_f_pos
op_assign
id|filp-&gt;f_pos
suffix:semicolon
r_struct
id|UMSDOS_DIR_ONCE
id|bufk
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_readdir_x: . or .. /mn/?&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|bufk.dirbuf
op_assign
id|dirbuf
suffix:semicolon
id|bufk.filldir
op_assign
id|filldir
suffix:semicolon
id|bufk.count
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|fat_readdir
c_func
(paren
id|filp
comma
op_amp
id|bufk
comma
id|umsdos_dir_once
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_f_pos
OG
l_int|0
op_logical_and
id|filp-&gt;f_pos
OG
id|last_f_pos
)paren
id|filp-&gt;f_pos
op_assign
id|UMSDOS_SPECIAL_DIRFPOS
suffix:semicolon
r_if
c_cond
(paren
id|u_entry
op_ne
l_int|NULL
)paren
id|u_entry-&gt;flags
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_struct
id|inode
op_star
id|emd_dir
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_readdir_x: normal file /mn/?&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|emd_dir
op_assign
id|umsdos_emd_dir_lookup
c_func
(paren
id|dir
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|emd_dir
op_ne
l_int|NULL
)paren
(brace
id|off_t
id|start_fpos
op_assign
id|filp-&gt;f_pos
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_readdir_x: emd_dir-&gt;i_ino=%ld&bslash;n&quot;
comma
id|emd_dir-&gt;i_ino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_pos
op_le
id|UMSDOS_SPECIAL_DIRFPOS
op_plus
l_int|1
)paren
id|filp-&gt;f_pos
op_assign
l_int|0
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;f_pos %Ld i_size %ld&bslash;n&quot;
comma
id|filp-&gt;f_pos
comma
id|emd_dir-&gt;i_size
)paren
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|filp-&gt;f_pos
OL
id|emd_dir-&gt;i_size
)paren
(brace
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
id|off_t
id|cur_f_pos
op_assign
id|filp-&gt;f_pos
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_emd_dir_readentry
(paren
id|emd_dir
comma
id|filp
comma
op_amp
id|entry
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry.name_len
op_ne
l_int|0
)paren
(brace
multiline_comment|/* #Specification: umsdos / readdir&n;&t;     umsdos_readdir() should fill a struct dirent with&n;&t;     an inode number. The cheap way to get it is to&n;&t;     do a lookup in the MSDOS directory for each&n;&t;     entry processed by the readdir() function.&n;&t;     This is not very efficient, but very simple. The&n;&t;     other way around is to maintain a copy of the inode&n;&t;     number in the EMD file. This is a problem because&n;&t;     this has to be maintained in sync using tricks.&n;&t;     Remember that MSDOS (the OS) does not update the&n;&t;     modification time (mtime) of a directory. There is&n;&t;     no easy way to tell that a directory was modified&n;&t;     during a DOS session and synchronise the EMD file.&n;&t;     &n;&t;     Suggestion welcome.&n;&t;     &n;&t;     So the easy way is used!&n;&t;  */
r_struct
id|umsdos_info
id|info
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|lret
suffix:semicolon
id|umsdos_parse
(paren
id|entry.name
comma
id|entry.name_len
comma
op_amp
id|info
)paren
suffix:semicolon
id|info.f_pos
op_assign
id|cur_f_pos
suffix:semicolon
id|umsdos_manglename
(paren
op_amp
id|info
)paren
suffix:semicolon
multiline_comment|/* FIXME, fake a dentry --&gt; /mn/ fixed ? */
id|lret
op_assign
id|compat_umsdos_real_lookup
(paren
id|dir
comma
id|info.fake.fname
comma
id|info.fake.len
comma
op_amp
id|inode
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;Cherche inode de %s lret %d flags %d&bslash;n&quot;
comma
id|info.fake.fname
comma
id|lret
comma
id|entry.flags
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lret
op_eq
l_int|0
op_logical_and
(paren
id|entry.flags
op_amp
id|UMSDOS_HLINK
)paren
op_logical_and
id|follow_hlink
)paren
(brace
r_struct
id|inode
op_star
id|rinode
suffix:semicolon
id|lret
op_assign
id|umsdos_hlink2inode
(paren
id|inode
comma
op_amp
id|rinode
)paren
suffix:semicolon
id|inode
op_assign
id|rinode
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lret
op_eq
l_int|0
)paren
(brace
multiline_comment|/* #Specification: pseudo root / reading real root&n;&t;       The pseudo root (/linux) is logically&n;&t;       erased from the real root. This mean that&n;&t;       ls /DOS, won&squot;t show &quot;linux&quot;. This avoids&n;&t;       infinite recursion /DOS/linux/DOS/linux while&n;&t;       walking the file system.&n;&t;    */
r_if
c_cond
(paren
id|inode
op_ne
id|pseudo_root
op_logical_and
(paren
id|internal_read
op_logical_or
op_logical_neg
(paren
id|entry.flags
op_amp
id|UMSDOS_HIDDEN
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|filldir
(paren
id|dirbuf
comma
id|entry.name
comma
id|entry.name_len
comma
id|cur_f_pos
comma
id|inode-&gt;i_ino
)paren
OL
l_int|0
)paren
(brace
id|filp-&gt;f_pos
op_assign
id|cur_f_pos
suffix:semicolon
)brace
id|Printk
(paren
(paren
l_string|&quot;Trouve ino %ld &quot;
comma
id|inode-&gt;i_ino
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|u_entry
op_ne
l_int|NULL
)paren
op_star
id|u_entry
op_assign
id|entry
suffix:semicolon
multiline_comment|/* iput (inode); FIXME */
r_break
suffix:semicolon
)brace
multiline_comment|/* iput (inode); FIXME */
)brace
r_else
(brace
multiline_comment|/* #Specification: umsdos / readdir / not in MSDOS&n;&t;       During a readdir operation, if the file is not&n;&t;       in the MSDOS directory anymore, the entry is&n;&t;       removed from the EMD file silently.&n;&t;    */
id|Printk
(paren
(paren
l_string|&quot;&squot;Silently&squot; removing EMD for file&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_writeentry
(paren
id|dir
comma
id|emd_dir
comma
op_amp
id|info
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n;&t;If the fillbuf has failed, f_pos is back to 0.&n;&t;To avoid getting back into the . and .. state&n;&t;(see comments at the beginning), we put back&n;&t;the special offset.&n;      */
r_if
c_cond
(paren
id|filp-&gt;f_pos
op_eq
l_int|0
)paren
id|filp-&gt;f_pos
op_assign
id|start_fpos
suffix:semicolon
multiline_comment|/* iput(emd_dir); FIXME */
)brace
)brace
id|umsdos_endlookup
c_func
(paren
id|dir
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;read dir %p pos %Ld ret %d&bslash;n&quot;
comma
id|dir
comma
id|filp-&gt;f_pos
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;  Read count directory entries from directory filp&n;  Return a negative value from linux/errno.h.&n;  Return 0 or positive if successful&n;*/
DECL|function|UMSDOS_readdir
r_static
r_int
id|UMSDOS_readdir
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
multiline_comment|/* Point to a directory which is read */
r_void
op_star
id|dirbuf
comma
multiline_comment|/* Will hold directory entries  */
id|filldir_t
id|filldir
)paren
(brace
r_struct
id|inode
op_star
id|dir
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_struct
id|UMSDOS_DIR_ONCE
id|bufk
suffix:semicolon
id|bufk.dirbuf
op_assign
id|dirbuf
suffix:semicolon
id|bufk.filldir
op_assign
id|filldir
suffix:semicolon
id|bufk.stop
op_assign
l_int|0
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;UMSDOS_readdir in&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ret
op_eq
l_int|0
op_logical_and
id|bufk.stop
op_eq
l_int|0
)paren
(brace
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
id|bufk.count
op_assign
l_int|0
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;UMSDOS_readdir: calling _x (%p,%p,%p,%d,%p,%d,%p)&bslash;n&quot;
comma
id|dir
comma
id|filp
comma
op_amp
id|bufk
comma
l_int|0
comma
op_amp
id|entry
comma
l_int|1
comma
id|umsdos_dir_once
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_readdir_x
(paren
id|dir
comma
id|filp
comma
op_amp
id|bufk
comma
l_int|0
comma
op_amp
id|entry
comma
l_int|1
comma
id|umsdos_dir_once
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bufk.count
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|count
op_add_assign
id|bufk.count
suffix:semicolon
)brace
id|Printk
(paren
(paren
l_string|&quot;UMSDOS_readdir out %d count %d pos %Ld&bslash;n&quot;
comma
id|ret
comma
id|count
comma
id|filp-&gt;f_pos
)paren
)paren
suffix:semicolon
r_return
id|count
ques
c_cond
suffix:colon
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;  Complete the inode content with info from the EMD file&n;*/
DECL|function|umsdos_lookup_patch
r_void
id|umsdos_lookup_patch
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|umsdos_dirent
op_star
id|entry
comma
id|off_t
id|emd_pos
)paren
(brace
multiline_comment|/*&n;    This function modify the state of a dir inode. It decides&n;    if the dir is a umsdos dir or a dos dir. This is done&n;    deeper in umsdos_patch_inode() called at the end of this function.&n;    &n;    umsdos_patch_inode() may block because it is doing disk access.&n;    At the same time, another process may get here to initialise&n;    the same dir inode. There is 3 cases.&n;    &n;    1-The inode is already initialised. We do nothing.&n;    2-The inode is not initialised. We lock access and do it.&n;    3-Like 2 but another process has lock the inode, so we try&n;    to lock it and right after check if initialisation is still&n;    needed.&n;    &n;    &n;    Thanks to the mem option of the kernel command line, it was&n;    possible to consistently reproduce this problem by limiting&n;    my mem to 4 meg and running X.&n;  */
multiline_comment|/*&n;    Do this only if the inode is freshly read, because we will lose&n;    the current (updated) content.&n;  */
multiline_comment|/*&n;    A lookup of a mount point directory yield the inode into&n;    the other fs, so we don&squot;t care about initialising it. iget()&n;    does this automatically.&n;  */
r_if
c_cond
(paren
id|inode-&gt;i_sb
op_eq
id|dir-&gt;i_sb
op_logical_and
op_logical_neg
id|umsdos_isinit
c_func
(paren
id|inode
)paren
)paren
(brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
id|umsdos_lockcreate
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|umsdos_isinit
c_func
(paren
id|inode
)paren
)paren
(brace
multiline_comment|/* #Specification: umsdos / lookup / inode info&n;&t; After successfully reading an inode from the MSDOS&n;&t; filesystem, we use the EMD file to complete it.&n;&t; We update the following field.&n;&t; &n;&t; uid, gid, atime, ctime, mtime, mode.&n;&t; &n;&t; We rely on MSDOS for mtime. If the file&n;&t; was modified during an MSDOS session, at least&n;&t; mtime will be meaningful. We do this only for regular&n;&t; file.&n;&t; &n;&t; We don&squot;t rely on MSDOS for mtime for directory because&n;&t; the MSDOS directory date is creation time (strange&n;&t; MSDOS behavior) which fit nowhere in the three UNIX&n;&t; time stamp.&n;      */
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|entry-&gt;mode
)paren
)paren
id|entry-&gt;mtime
op_assign
id|inode-&gt;i_mtime
suffix:semicolon
id|inode-&gt;i_mode
op_assign
id|entry-&gt;mode
suffix:semicolon
id|inode-&gt;i_rdev
op_assign
id|to_kdev_t
c_func
(paren
id|entry-&gt;rdev
)paren
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|entry-&gt;atime
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|entry-&gt;ctime
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
id|entry-&gt;mtime
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|entry-&gt;uid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|entry-&gt;gid
suffix:semicolon
multiline_comment|/* #Specification: umsdos / conversion mode&n;&t; The msdos fs can do some inline conversion&n;&t; of the data of a file. It can translate&n;&t; silently from MsDOS text file format to Unix&n;&t; one (crlf -&gt; lf) while reading, and the reverse&n;&t; while writing. This is activated using the mount&n;&t; option conv=....&n;&t; &n;&t; This is not useful for Linux file in promoted&n;&t; directory. It can even be harmful. For this&n;&t; reason, the binary (no conversion) mode is&n;&t; always activated.&n;      */
multiline_comment|/* #Specification: umsdos / conversion mode / todo&n;&t; A flag could be added to file and directories&n;&t; forcing an automatic conversion mode (as&n;&t; done with the msdos fs).&n;&t; &n;&t; This flag could be setup on a directory basis&n;&t; (instead of file) and all file in it would&n;&t; logically inherited. If the conversion mode&n;&t; is active (conv=) then the i_binary flag would&n;&t; be left untouched in those directories.&n;&t; &n;&t; It was proposed that the sticky bit was used&n;&t; to set this. The problem is that new file would&n;&t; be written incorrectly. The other problem is that&n;&t; the sticky bit has a meaning for directories. So&n;&t; another bit should be used (there is some space&n;&t; in the EMD file for it) and a special utilities&n;&t; would be used to assign the flag to a directory).&n;&t; I don&squot;t think it is useful to assign this flag&n;&t; on a single file.&n;      */
id|MSDOS_I
c_func
(paren
id|inode
)paren
op_member_access_from_pointer
id|i_binary
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* #Specification: umsdos / i_nlink&n;&t; The nlink field of an inode is maintain by the MSDOS file system&n;&t; for directory and by UMSDOS for other file. The logic is that&n;&t; MSDOS is already figuring out what to do for directories and&n;&t; does nothing for other files. For MSDOS, there are no hard link&n;&t; so all file carry nlink==1. UMSDOS use some info in the&n;&t; EMD file to plug the correct value.&n;      */
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|entry-&gt;mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|entry-&gt;nlink
OG
l_int|0
)paren
(brace
id|inode-&gt;i_nlink
op_assign
id|entry-&gt;nlink
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;UMSDOS: lookup_patch entry-&gt;nlink &lt; 1 ???&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|umsdos_patch_inode
c_func
(paren
id|inode
comma
id|dir
comma
id|emd_pos
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
id|umsdos_unlockcreate
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;u.umsdos_i.i_emd_owner
op_eq
l_int|0
)paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;emd_owner still 0 ???&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|struct|UMSDOS_DIRENT_K
r_struct
id|UMSDOS_DIRENT_K
(brace
DECL|member|f_pos
id|off_t
id|f_pos
suffix:semicolon
multiline_comment|/* will hold the offset of the entry in EMD */
DECL|member|ino
id|ino_t
id|ino
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;  Just to record the offset of one entry.&n;*/
DECL|function|umsdos_filldir_k
r_static
r_int
id|umsdos_filldir_k
c_func
(paren
r_void
op_star
id|buf
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
id|off_t
id|offset
comma
id|ino_t
id|ino
)paren
(brace
r_struct
id|UMSDOS_DIRENT_K
op_star
id|d
op_assign
(paren
r_struct
id|UMSDOS_DIRENT_K
op_star
)paren
id|buf
suffix:semicolon
id|d-&gt;f_pos
op_assign
id|offset
suffix:semicolon
id|d-&gt;ino
op_assign
id|ino
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|struct|UMSDOS_DIR_SEARCH
r_struct
id|UMSDOS_DIR_SEARCH
(brace
DECL|member|entry
r_struct
id|umsdos_dirent
op_star
id|entry
suffix:semicolon
DECL|member|found
r_int
id|found
suffix:semicolon
DECL|member|search_ino
id|ino_t
id|search_ino
suffix:semicolon
)brace
suffix:semicolon
DECL|function|umsdos_dir_search
r_static
r_int
id|umsdos_dir_search
(paren
r_void
op_star
id|buf
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
id|off_t
id|offset
comma
id|ino_t
id|ino
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|UMSDOS_DIR_SEARCH
op_star
id|d
op_assign
(paren
r_struct
id|UMSDOS_DIR_SEARCH
op_star
)paren
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;search_ino
op_eq
id|ino
)paren
(brace
id|d-&gt;found
op_assign
l_int|1
suffix:semicolon
id|memcpy
(paren
id|d-&gt;entry-&gt;name
comma
id|name
comma
id|len
)paren
suffix:semicolon
id|d-&gt;entry-&gt;name
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|d-&gt;entry-&gt;name_len
op_assign
id|len
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* So fat_readdir will terminate */
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;  Locate entry of an inode in a directory.&n;  Return 0 or a negative error code.&n;  &n;  Normally, this function must succeed. It means a strange corruption&n;  in the file system if not.&n;*/
DECL|function|umsdos_inode2entry
r_int
id|umsdos_inode2entry
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|umsdos_dirent
op_star
id|entry
)paren
multiline_comment|/* Will hold the entry */
(brace
r_int
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|pseudo_root
op_logical_and
id|inode
op_eq
id|pseudo_root
)paren
(brace
multiline_comment|/*&n;      Quick way to find the name.&n;      Also umsdos_readdir_x won&squot;t show /linux anyway&n;    */
id|memcpy
(paren
id|entry-&gt;name
comma
id|UMSDOS_PSDROOT_NAME
comma
id|UMSDOS_PSDROOT_LEN
op_plus
l_int|1
)paren
suffix:semicolon
id|entry-&gt;name_len
op_assign
id|UMSDOS_PSDROOT_LEN
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_struct
id|inode
op_star
id|emddir
op_assign
id|umsdos_emd_dir_lookup
c_func
(paren
id|dir
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* iput (emddir); FIXME */
r_if
c_cond
(paren
id|emddir
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* This is a DOS directory */
r_struct
id|UMSDOS_DIR_SEARCH
id|bufk
suffix:semicolon
r_struct
id|file
id|filp
suffix:semicolon
id|fill_new_filp
(paren
op_amp
id|filp
comma
l_int|NULL
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;umsdos_inode2entry emddir==NULL: WARNING: Known filp problem. segfaulting :) /mn/&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|filp.f_reada
op_assign
l_int|1
suffix:semicolon
id|filp.f_pos
op_assign
l_int|0
suffix:semicolon
id|bufk.entry
op_assign
id|entry
suffix:semicolon
id|bufk.search_ino
op_assign
id|inode-&gt;i_ino
suffix:semicolon
id|fat_readdir
(paren
op_amp
id|filp
comma
op_amp
id|bufk
comma
id|umsdos_dir_search
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bufk.found
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;u.umsdos_i.i_dir_owner
op_assign
id|dir-&gt;i_ino
suffix:semicolon
id|inode-&gt;u.umsdos_i.i_emd_owner
op_assign
l_int|0
suffix:semicolon
id|umsdos_setup_dir_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* skip . and .. see umsdos_readdir_x() */
r_struct
id|file
id|filp
suffix:semicolon
id|fill_new_filp
(paren
op_amp
id|filp
comma
l_int|NULL
)paren
suffix:semicolon
id|filp.f_reada
op_assign
l_int|1
suffix:semicolon
id|filp.f_pos
op_assign
id|UMSDOS_SPECIAL_DIRFPOS
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;umsdos_inode2entry skip./..: WARNING: Known filp problem. segfaulting :) /mn/&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|UMSDOS_DIRENT_K
id|bufk
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_readdir_x
c_func
(paren
id|dir
comma
op_amp
id|filp
comma
op_amp
id|bufk
comma
l_int|1
comma
id|entry
comma
l_int|0
comma
id|umsdos_filldir_k
)paren
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: can&squot;t locate inode %ld in EMD file???&bslash;n&quot;
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bufk.ino
op_eq
id|inode-&gt;i_ino
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
id|umsdos_lookup_patch
(paren
id|dir
comma
id|inode
comma
id|entry
comma
id|bufk.f_pos
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;  Locate the parent of a directory and the info on that directory&n;  Return 0 or a negative error code.&n;*/
DECL|function|umsdos_locate_ancestor
r_static
r_int
id|umsdos_locate_ancestor
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|inode
op_star
op_star
id|result
comma
r_struct
id|umsdos_dirent
op_star
id|entry
)paren
(brace
r_int
id|ret
suffix:semicolon
id|umsdos_patch_inode
(paren
id|dir
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* FIXME */
id|ret
op_assign
id|compat_umsdos_real_lookup
(paren
id|dir
comma
l_string|&quot;..&quot;
comma
l_int|2
comma
id|result
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;result %d %p &quot;
comma
id|ret
comma
op_star
id|result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|inode
op_star
id|adir
op_assign
op_star
id|result
suffix:semicolon
id|ret
op_assign
id|umsdos_inode2entry
(paren
id|adir
comma
id|dir
comma
id|entry
)paren
suffix:semicolon
)brace
id|Printk
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;  Build the path name of an inode (relative to the file system.&n;  This function is need to set (pseudo) hard link.&n;  &n;  It uses the same strategy as the standard getcwd().&n;*/
DECL|function|umsdos_locate_path
r_int
id|umsdos_locate_path
(paren
r_struct
id|inode
op_star
id|inode
comma
r_char
op_star
id|path
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|inode
op_star
id|dir
op_assign
id|inode
suffix:semicolon
r_struct
id|inode
op_star
id|root_inode
suffix:semicolon
r_char
op_star
id|bpath
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|PATH_MAX
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|root_inode
op_assign
id|iget
c_func
(paren
id|inode-&gt;i_sb
comma
id|UMSDOS_ROOT_INO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bpath
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
r_char
op_star
id|ptbpath
op_assign
id|bpath
op_plus
id|PATH_MAX
op_minus
l_int|1
suffix:semicolon
op_star
id|ptbpath
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;locate_path mode %x &quot;
comma
id|inode-&gt;i_mode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|ret
op_assign
id|umsdos_get_dirowner
(paren
id|inode
comma
op_amp
id|dir
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;locate_path ret %d &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
id|umsdos_inode2entry
(paren
id|dir
comma
id|inode
comma
op_amp
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ptbpath
op_sub_assign
id|entry.name_len
suffix:semicolon
id|memcpy
(paren
id|ptbpath
comma
id|entry.name
comma
id|entry.name_len
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;ptbpath :%.*s: &quot;
comma
id|entry.name_len
comma
id|ptbpath
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|dir-&gt;i_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|dir
op_ne
id|root_inode
)paren
(brace
r_struct
id|inode
op_star
id|adir
suffix:semicolon
id|ret
op_assign
id|umsdos_locate_ancestor
(paren
id|dir
comma
op_amp
id|adir
comma
op_amp
id|entry
)paren
suffix:semicolon
multiline_comment|/* iput (dir); FIXME */
id|dir
op_assign
l_int|NULL
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;ancestor %d &quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
op_star
op_decrement
id|ptbpath
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|ptbpath
op_sub_assign
id|entry.name_len
suffix:semicolon
id|memcpy
(paren
id|ptbpath
comma
id|entry.name
comma
id|entry.name_len
)paren
suffix:semicolon
id|dir
op_assign
id|adir
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;ptbpath :%.*s: &quot;
comma
id|entry.name_len
comma
id|ptbpath
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
id|strcpy
(paren
id|path
comma
id|ptbpath
)paren
suffix:semicolon
id|kfree
(paren
id|bpath
)paren
suffix:semicolon
)brace
id|Printk
(paren
(paren
l_string|&quot;&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* iput (dir); FIXME */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Return != 0 if an entry is the pseudo DOS entry in the pseudo root.&n;*/
DECL|function|umsdos_is_pseudodos
r_int
id|umsdos_is_pseudodos
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
multiline_comment|/* #Specification: pseudo root / DOS hard coded&n;     The pseudo sub-directory DOS in the pseudo root is hard coded.&n;     The name is DOS. This is done this way to help standardised&n;     the umsdos layout. The idea is that from now on /DOS is&n;     a reserved path and nobody will think of using such a path&n;     for a package.&n;  */
r_return
id|pseudo_root
op_logical_and
id|dir
op_eq
id|pseudo_root
op_logical_and
id|dentry-&gt;d_name.len
op_eq
l_int|3
op_logical_and
id|dentry-&gt;d_name.name
(braket
l_int|0
)braket
op_eq
l_char|&squot;D&squot;
op_logical_and
id|dentry-&gt;d_name.name
(braket
l_int|1
)braket
op_eq
l_char|&squot;O&squot;
op_logical_and
id|dentry-&gt;d_name.name
(braket
l_int|2
)braket
op_eq
l_char|&squot;S&squot;
suffix:semicolon
)brace
multiline_comment|/*&n;  Check if a file exist in the current directory.&n;  Return 0 if ok, negative error code if not (ex: -ENOENT).&n;*/
DECL|function|umsdos_lookup_x
r_int
id|umsdos_lookup_x
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|nopseudo
)paren
multiline_comment|/* Don&squot;t care about pseudo root mode */
(brace
r_int
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_struct
id|inode
op_star
id|root_inode
suffix:semicolon
r_struct
id|inode
op_star
id|pseudo_root_inode
op_assign
l_int|NULL
suffix:semicolon
r_int
id|len
op_assign
id|dentry-&gt;d_name.len
suffix:semicolon
r_const
r_char
op_star
id|name
op_assign
id|dentry-&gt;d_name.name
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_lookup_x: /mn/ name=%.*s, dir=%lu, d_parent=%p&bslash;n&quot;
comma
(paren
r_int
)paren
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
comma
id|dir-&gt;i_ino
comma
id|dentry-&gt;d_parent
)paren
)paren
suffix:semicolon
multiline_comment|/* FIXME /mn/ debug only */
r_if
c_cond
(paren
id|dentry-&gt;d_parent
)paren
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;   d_parent is %.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|dentry-&gt;d_parent-&gt;d_name.len
comma
id|dentry-&gt;d_parent-&gt;d_name.name
)paren
)paren
suffix:semicolon
multiline_comment|/* FIXME : delme /mn/ */
id|root_inode
op_assign
id|iget
c_func
(paren
id|dir-&gt;i_sb
comma
id|UMSDOS_ROOT_INO
)paren
suffix:semicolon
multiline_comment|/*&t;pseudo_root_inode = iget( ... ) ? */
id|dentry-&gt;d_inode
op_assign
l_int|NULL
suffix:semicolon
id|umsdos_startlookup
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_eq
l_int|1
op_logical_and
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
id|d_add
(paren
id|dentry
comma
id|dir
)paren
suffix:semicolon
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|len
op_eq
l_int|2
op_logical_and
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
id|name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
r_if
c_cond
(paren
id|pseudo_root
op_logical_and
id|dir
op_eq
id|pseudo_root_inode
)paren
(brace
multiline_comment|/* #Specification: pseudo root / .. in real root&n;&t; Whenever a lookup is those in the real root for&n;&t; the directory .., and pseudo root is active, the&n;&t; pseudo root is returned.&n;      */
id|ret
op_assign
l_int|0
suffix:semicolon
id|d_add
(paren
id|dentry
comma
id|pseudo_root
)paren
suffix:semicolon
id|pseudo_root-&gt;i_count
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* #Specification: locating .. / strategy&n;&t; We use the msdos filesystem to locate the parent directory.&n;&t; But it is more complicated than that.&n;&t; &n;&t; We have to step back even further to&n;&t; get the parent of the parent, so we can get the EMD&n;&t; of the parent of the parent. Using the EMD file, we can&n;&t; locate all the info on the parent, such a permissions&n;&t; and owner.&n;      */
id|ret
op_assign
id|compat_umsdos_real_lookup
(paren
id|dir
comma
l_string|&quot;..&quot;
comma
l_int|2
comma
op_amp
id|dentry-&gt;d_inode
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;ancestor ret %d dir %p *result %p &quot;
comma
id|ret
comma
id|dir
comma
id|dentry-&gt;d_inode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
op_logical_and
id|dentry-&gt;d_inode
op_ne
id|root_inode
op_logical_and
id|dentry-&gt;d_inode
op_ne
id|pseudo_root
)paren
(brace
r_struct
id|inode
op_star
id|aadir
suffix:semicolon
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
id|ret
op_assign
id|umsdos_locate_ancestor
(paren
id|dentry-&gt;d_inode
comma
op_amp
id|aadir
comma
op_amp
id|entry
)paren
suffix:semicolon
multiline_comment|/* iput (aadir); FIXME */
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|umsdos_is_pseudodos
c_func
(paren
id|dir
comma
id|dentry
)paren
)paren
(brace
multiline_comment|/* #Specification: pseudo root / lookup(DOS)&n;       A lookup of DOS in the pseudo root will always succeed&n;       and return the inode of the real root.&n;    */
id|d_add
(paren
id|dentry
comma
id|root_inode
)paren
suffix:semicolon
(paren
id|dentry-&gt;d_inode
)paren
op_member_access_from_pointer
id|i_count
op_increment
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_struct
id|umsdos_info
id|info
suffix:semicolon
id|ret
op_assign
id|umsdos_parse
(paren
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
op_amp
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|ret
op_assign
id|umsdos_findentry
(paren
id|dir
comma
op_amp
id|info
comma
l_int|0
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;lookup %.*s pos %lu ret %d len %d &quot;
comma
id|info.fake.len
comma
id|info.fake.fname
comma
id|info.f_pos
comma
id|ret
comma
id|info.fake.len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/* #Specification: umsdos / lookup&n;&t; A lookup for a file is done in two step. First, we locate&n;&t; the file in the EMD file. If not present, we return&n;&t; an error code (-ENOENT). If it is there, we repeat the&n;&t; operation on the msdos file system. If this fails, it means&n;&t; that the file system is not in sync with the emd file.&n;&t; We silently remove this entry from the emd file,&n;&t; and return ENOENT.&n;      */
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|ret
op_assign
id|compat_umsdos_real_lookup
(paren
id|dir
comma
id|info.fake.fname
comma
id|info.fake.len
comma
op_amp
id|inode
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_lookup_x: compat_umsdos_real_lookup for %.*s returned %d with inode=%p&bslash;n&quot;
comma
id|info.fake.len
comma
id|info.fake.fname
comma
id|ret
comma
id|inode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;UMSDOS: Erase entry %.*s, out of sync with MsDOS&bslash;n&quot;
comma
id|info.fake.len
comma
id|info.fake.fname
)paren
suffix:semicolon
id|umsdos_delentry
(paren
id|dir
comma
op_amp
id|info
comma
id|S_ISDIR
c_func
(paren
id|info.entry.mode
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_lookup_x /mn/ debug: ino=%li&bslash;n&quot;
comma
id|inode-&gt;i_ino
)paren
)paren
suffix:semicolon
multiline_comment|/* we&squot;ve found it. now get inode and put it in dentry. Is this ok /mn/ ? */
id|d_add
(paren
id|dentry
comma
id|iget
c_func
(paren
id|dir-&gt;i_sb
comma
id|inode-&gt;i_ino
)paren
)paren
suffix:semicolon
id|umsdos_lookup_patch
(paren
id|dir
comma
id|inode
comma
op_amp
id|info.entry
comma
id|info.f_pos
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;lookup ino %ld flags %d&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|info.entry.flags
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info.entry.flags
op_amp
id|UMSDOS_HLINK
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_lookup_x: here goes HLINK&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_hlink2inode
(paren
id|inode
comma
op_amp
id|dentry-&gt;d_inode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pseudo_root
op_logical_and
id|dentry-&gt;d_inode
op_eq
id|pseudo_root
op_logical_and
op_logical_neg
id|nopseudo
)paren
(brace
multiline_comment|/* #Specification: pseudo root / dir lookup&n;&t;     For the same reason as readdir, a lookup in /DOS for&n;&t;     the pseudo root directory (linux) will fail.&n;&t;  */
multiline_comment|/*&n;&t;    This has to be allowed for resolving hard link&n;&t;    which are recorded independently of the pseudo-root&n;&t;    mode.&n;&t;  */
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;umsdos_lookup_x: warning: untested /mn/ Pseudo_root thingy&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* iput (pseudo_root); FIXME */
id|dentry-&gt;d_inode
op_assign
l_int|NULL
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
)brace
)brace
)brace
)brace
id|umsdos_endlookup
c_func
(paren
id|dir
)paren
suffix:semicolon
multiline_comment|/* iput (dir); FIXME */
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_lookup_x: returning %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;  Check if a file exist in the current directory.&n;  Return 0 if ok, negative error code if not (ex: -ENOENT).&n;  &n;  &n;*/
DECL|function|UMSDOS_lookup
r_int
id|UMSDOS_lookup
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|umsdos_lookup_x
c_func
(paren
id|dir
comma
id|dentry
comma
l_int|0
)paren
suffix:semicolon
macro_line|#if 1
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ENOENT
)paren
(brace
id|Printk
(paren
(paren
id|KERN_INFO
l_string|&quot;UMSDOS_lookup: converting -ENOENT to negative dentry !&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|d_add
(paren
id|dentry
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* create negative dentry if not found */
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;  Locate the inode pointed by a (pseudo) hard link&n;  Return 0 if ok, a negative error code if not.&n;*/
DECL|function|umsdos_hlink2inode
r_int
id|umsdos_hlink2inode
(paren
r_struct
id|inode
op_star
id|hlink
comma
r_struct
id|inode
op_star
op_star
id|result
)paren
(brace
r_struct
id|inode
op_star
id|root_inode
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry_src
comma
op_star
id|dentry_dst
suffix:semicolon
r_char
op_star
id|path
suffix:semicolon
macro_line|#if 0  &t;/* FIXME: DELME */
id|Printk
(paren
(paren
l_string|&quot;FIXME: just test. hlink2inode returning -ENOENT&bslash;n /mn/&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
multiline_comment|/* /mn/ FIXME just for test */
macro_line|#endif
id|path
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|PATH_MAX
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|root_inode
op_assign
id|iget
c_func
(paren
id|hlink-&gt;i_sb
comma
id|UMSDOS_ROOT_INO
)paren
suffix:semicolon
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|path
op_eq
l_int|NULL
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/* iput (hlink); FIXME */
)brace
r_else
(brace
r_struct
id|file
id|filp
suffix:semicolon
id|loff_t
id|offs
op_assign
l_int|0
suffix:semicolon
id|fill_new_filp
(paren
op_amp
id|filp
comma
l_int|NULL
)paren
suffix:semicolon
id|dentry_src
op_assign
id|creat_dentry
(paren
l_string|&quot;hlink-mn&quot;
comma
l_int|8
comma
id|hlink
comma
l_int|NULL
)paren
suffix:semicolon
id|memset
(paren
op_amp
id|filp
comma
l_int|0
comma
r_sizeof
(paren
id|filp
)paren
)paren
suffix:semicolon
id|filp.f_pos
op_assign
l_int|0
suffix:semicolon
id|filp.f_reada
op_assign
l_int|1
suffix:semicolon
id|filp.f_flags
op_assign
id|O_RDONLY
suffix:semicolon
id|filp.f_dentry
op_assign
id|dentry_src
suffix:semicolon
id|filp.f_op
op_assign
op_amp
id|umsdos_file_operations
suffix:semicolon
multiline_comment|/* /mn/ - we have to fill it with dummy values so we won&squot;t segfault */
id|Printk
(paren
(paren
l_string|&quot;hlink2inode &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_file_read_kmem
(paren
id|hlink
comma
op_amp
id|filp
comma
id|path
comma
id|hlink-&gt;i_size
comma
op_amp
id|offs
)paren
op_eq
id|hlink-&gt;i_size
)paren
(brace
r_struct
id|inode
op_star
id|dir
suffix:semicolon
r_char
op_star
id|pt
op_assign
id|path
suffix:semicolon
id|dir
op_assign
id|root_inode
suffix:semicolon
id|path
(braket
id|hlink-&gt;i_size
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/*&t;iput (hlink); / * FIXME! /mn/ */
id|dir-&gt;i_count
op_increment
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_char
op_star
id|start
op_assign
id|pt
suffix:semicolon
r_int
id|len
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pt
op_ne
l_char|&squot;&bslash;0&squot;
op_logical_and
op_star
id|pt
op_ne
l_char|&squot;/&squot;
)paren
id|pt
op_increment
suffix:semicolon
id|len
op_assign
(paren
r_int
)paren
(paren
id|pt
op_minus
id|start
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|pt
op_eq
l_char|&squot;/&squot;
)paren
op_star
id|pt
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* FIXME. /mn/ fixed ? */
id|dentry_dst
op_assign
id|creat_dentry
(paren
id|start
comma
id|len
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.i_emd_dir
op_eq
l_int|0
)paren
(brace
multiline_comment|/* This is a DOS directory */
id|Printk
(paren
(paren
l_string|&quot;hlink2inode /mn/: doing umsdos_rlookup_x on %.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|dentry_dst-&gt;d_name.len
comma
id|dentry_dst-&gt;d_name.name
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_rlookup_x
c_func
(paren
id|dir
comma
id|dentry_dst
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|Printk
(paren
(paren
l_string|&quot;hlink2inode /mn/: doing umsdos_lookup_x on %.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|dentry_dst-&gt;d_name.len
comma
id|dentry_dst-&gt;d_name.name
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_lookup_x
c_func
(paren
id|dir
comma
id|dentry_dst
comma
l_int|1
)paren
suffix:semicolon
)brace
id|Printk
(paren
(paren
l_string|&quot;  returned %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
op_star
id|result
op_assign
id|dentry_dst-&gt;d_inode
suffix:semicolon
multiline_comment|/* /mn/ ok ? */
id|Printk
(paren
(paren
l_string|&quot;h2n lookup :%s: -&gt; %d &quot;
comma
id|start
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
op_logical_and
op_star
id|pt
op_ne
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|dir
op_assign
op_star
id|result
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|Printk
(paren
(paren
l_string|&quot;umsdos_hlink2inode: all those iput&squot;s() frighten me /mn/. Whatabout dput() ? FIXME!&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* iput (hlink); / * FIXME */
)brace
id|Printk
(paren
(paren
l_string|&quot;hlink2inode ret = %d %p -&gt; %p&bslash;n&quot;
comma
id|ret
comma
id|hlink
comma
op_star
id|result
)paren
)paren
suffix:semicolon
id|kfree
(paren
id|path
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|variable|umsdos_dir_operations
r_static
r_struct
id|file_operations
id|umsdos_dir_operations
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|UMSDOS_dir_read
comma
multiline_comment|/* read */
l_int|NULL
comma
multiline_comment|/* write - bad */
id|UMSDOS_readdir
comma
multiline_comment|/* readdir */
l_int|NULL
comma
multiline_comment|/* poll - default */
id|UMSDOS_ioctl_dir
comma
multiline_comment|/* ioctl - default */
l_int|NULL
comma
multiline_comment|/* mmap */
l_int|NULL
comma
multiline_comment|/* no special open code */
l_int|NULL
comma
multiline_comment|/* no special release code */
l_int|NULL
multiline_comment|/* fsync */
multiline_comment|/* in original NULL. changed to file_fsync. FIXME? /mn/ */
)brace
suffix:semicolon
DECL|variable|umsdos_dir_inode_operations
r_struct
id|inode_operations
id|umsdos_dir_inode_operations
op_assign
(brace
op_amp
id|umsdos_dir_operations
comma
multiline_comment|/* default directory file-ops */
id|UMSDOS_create
comma
multiline_comment|/* create */
id|UMSDOS_lookup
comma
multiline_comment|/* lookup */
id|UMSDOS_link
comma
multiline_comment|/* link */
id|UMSDOS_unlink
comma
multiline_comment|/* unlink */
id|UMSDOS_symlink
comma
multiline_comment|/* symlink */
id|UMSDOS_mkdir
comma
multiline_comment|/* mkdir */
id|UMSDOS_rmdir
comma
multiline_comment|/* rmdir */
id|UMSDOS_mknod
comma
multiline_comment|/* mknod */
id|UMSDOS_rename
comma
multiline_comment|/* rename */
l_int|NULL
comma
multiline_comment|/* readlink */
l_int|NULL
comma
multiline_comment|/* followlink */
id|generic_readpage
comma
multiline_comment|/* readpage */
multiline_comment|/* in original NULL. changed to generic_readpage. FIXME? /mn/ */
l_int|NULL
comma
multiline_comment|/* writepage */
id|fat_bmap
comma
multiline_comment|/* bmap */
multiline_comment|/* in original NULL. changed to fat_bmap. FIXME? /mn/ */
l_int|NULL
comma
multiline_comment|/* truncate */
l_int|NULL
comma
multiline_comment|/* permission */
l_int|NULL
comma
multiline_comment|/* smap */
l_int|NULL
comma
multiline_comment|/* updatepage */
l_int|NULL
comma
multiline_comment|/* revalidate */
)brace
suffix:semicolon
eof
