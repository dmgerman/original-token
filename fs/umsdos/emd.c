multiline_comment|/*&n; *  linux/fs/umsdos/emd.c&n; *&n; *  Written 1993 by Jacques Gelinas&n; *&n; *  Extended MS-DOS directory handling functions&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/msdos_fs.h&gt;
macro_line|#include &lt;linux/umsdos_fs.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x)
DECL|macro|Printk
mdefine_line|#define Printk(x) printk x
multiline_comment|/*&n;&t;Read a file into kernel space memory&n;*/
DECL|function|umsdos_file_read_kmem
r_int
id|umsdos_file_read_kmem
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|count
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|ret
op_assign
id|fat_file_read
c_func
(paren
id|inode
comma
id|filp
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|set_fs
(paren
id|old_fs
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Write to a file from kernel space&n;*/
DECL|function|umsdos_file_write_kmem
r_int
id|umsdos_file_write_kmem
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|count
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|ret
op_assign
id|fat_file_write
c_func
(paren
id|inode
comma
id|filp
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|set_fs
(paren
id|old_fs
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Write a block of bytes into one EMD file.&n;&t;The block of data is NOT in user space.&n;&n;&t;Return 0 if ok, a negative error code if not.&n;*/
DECL|function|umsdos_emd_dir_write
r_int
id|umsdos_emd_dir_write
(paren
r_struct
id|inode
op_star
id|emd_dir
comma
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
multiline_comment|/* buffer in kernel memory, not in user space */
r_int
r_int
id|count
)paren
(brace
r_int
id|written
suffix:semicolon
macro_line|#ifdef __BIG_ENDIAN
r_struct
id|umsdos_dirent
op_star
id|d
op_assign
(paren
r_struct
id|umsdos_dirent
op_star
)paren
id|buf
suffix:semicolon
macro_line|#endif
id|filp-&gt;f_flags
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef __BIG_ENDIAN&t;
id|d-&gt;nlink
op_assign
id|cpu_to_le16
(paren
id|d-&gt;nlink
)paren
suffix:semicolon
id|d-&gt;uid
op_assign
id|cpu_to_le16
(paren
id|d-&gt;uid
)paren
suffix:semicolon
id|d-&gt;gid
op_assign
id|cpu_to_le16
(paren
id|d-&gt;gid
)paren
suffix:semicolon
id|d-&gt;atime
op_assign
id|cpu_to_le32
(paren
id|d-&gt;atime
)paren
suffix:semicolon
id|d-&gt;mtime
op_assign
id|cpu_to_le32
(paren
id|d-&gt;mtime
)paren
suffix:semicolon
id|d-&gt;ctime
op_assign
id|cpu_to_le32
(paren
id|d-&gt;ctime
)paren
suffix:semicolon
id|d-&gt;rdev
op_assign
id|cpu_to_le16
(paren
id|d-&gt;rdev
)paren
suffix:semicolon
id|d-&gt;mode
op_assign
id|cpu_to_le16
(paren
id|d-&gt;mode
)paren
suffix:semicolon
macro_line|#endif&t;
id|written
op_assign
id|umsdos_file_write_kmem
(paren
id|emd_dir
comma
id|filp
comma
id|buf
comma
id|count
)paren
suffix:semicolon
macro_line|#ifdef __BIG_ENDIAN&t;
id|d-&gt;nlink
op_assign
id|le16_to_cpu
(paren
id|d-&gt;nlink
)paren
suffix:semicolon
id|d-&gt;uid
op_assign
id|le16_to_cpu
(paren
id|d-&gt;uid
)paren
suffix:semicolon
id|d-&gt;gid
op_assign
id|le16_to_cpu
(paren
id|d-&gt;gid
)paren
suffix:semicolon
id|d-&gt;atime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;atime
)paren
suffix:semicolon
id|d-&gt;mtime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;mtime
)paren
suffix:semicolon
id|d-&gt;ctime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;ctime
)paren
suffix:semicolon
id|d-&gt;rdev
op_assign
id|le16_to_cpu
(paren
id|d-&gt;rdev
)paren
suffix:semicolon
id|d-&gt;mode
op_assign
id|le16_to_cpu
(paren
id|d-&gt;mode
)paren
suffix:semicolon
macro_line|#endif&t;
r_return
id|written
op_ne
id|count
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Read a block of bytes from one EMD file.&n;&t;The block of data is NOT in user space.&n;&t;Return 0 if ok, -EIO if any error.&n;*/
DECL|function|umsdos_emd_dir_read
r_int
id|umsdos_emd_dir_read
(paren
r_struct
id|inode
op_star
id|emd_dir
comma
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
multiline_comment|/* buffer in kernel memory, not in user space */
r_int
r_int
id|count
)paren
(brace
r_int
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|sizeread
suffix:semicolon
macro_line|#ifdef __BIG_ENDIAN
r_struct
id|umsdos_dirent
op_star
id|d
op_assign
(paren
r_struct
id|umsdos_dirent
op_star
)paren
id|buf
suffix:semicolon
macro_line|#endif
id|filp-&gt;f_flags
op_assign
l_int|0
suffix:semicolon
id|sizeread
op_assign
id|umsdos_file_read_kmem
(paren
id|emd_dir
comma
id|filp
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sizeread
op_ne
id|count
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: problem with EMD file. Can&squot;t read pos = %Ld (%d != %ld)&bslash;n&quot;
comma
id|filp-&gt;f_pos
comma
id|sizeread
comma
id|count
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#ifdef __BIG_ENDIAN&t;
id|d-&gt;nlink
op_assign
id|le16_to_cpu
(paren
id|d-&gt;nlink
)paren
suffix:semicolon
id|d-&gt;uid
op_assign
id|le16_to_cpu
(paren
id|d-&gt;uid
)paren
suffix:semicolon
id|d-&gt;gid
op_assign
id|le16_to_cpu
(paren
id|d-&gt;gid
)paren
suffix:semicolon
id|d-&gt;atime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;atime
)paren
suffix:semicolon
id|d-&gt;mtime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;mtime
)paren
suffix:semicolon
id|d-&gt;ctime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;ctime
)paren
suffix:semicolon
id|d-&gt;rdev
op_assign
id|le16_to_cpu
(paren
id|d-&gt;rdev
)paren
suffix:semicolon
id|d-&gt;mode
op_assign
id|le16_to_cpu
(paren
id|d-&gt;mode
)paren
suffix:semicolon
macro_line|#endif&t;
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Locate the EMD file in a directory and optionally, creates it.&n;&n;&t;Return NULL if error. If ok, dir-&gt;u.umsdos_i.emd_inode &n;*/
DECL|function|umsdos_emd_dir_lookup
r_struct
id|inode
op_star
id|umsdos_emd_dir_lookup
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_int
id|creat
)paren
(brace
r_struct
id|inode
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.i_emd_dir
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
id|iget
(paren
id|dir-&gt;i_sb
comma
id|dir-&gt;u.umsdos_i.i_emd_dir
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;deja trouve %d %x [%d] &quot;
comma
id|dir-&gt;u.umsdos_i.i_emd_dir
comma
id|ret
comma
id|ret-&gt;i_count
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|umsdos_real_lookup
(paren
id|dir
comma
id|UMSDOS_EMD_FILE
comma
id|UMSDOS_EMD_NAMELEN
comma
op_amp
id|ret
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;emd_dir_lookup &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
(brace
id|PRINTK
(paren
(paren
l_string|&quot;Find --linux &quot;
)paren
)paren
suffix:semicolon
id|dir-&gt;u.umsdos_i.i_emd_dir
op_assign
id|ret-&gt;i_ino
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|creat
)paren
(brace
r_int
id|code
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;avant create &quot;
)paren
)paren
suffix:semicolon
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|code
op_assign
id|msdos_create
(paren
id|dir
comma
id|UMSDOS_EMD_FILE
comma
id|UMSDOS_EMD_NAMELEN
comma
id|S_IFREG
op_or
l_int|0777
comma
op_amp
id|ret
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;Creat EMD code %d ret %x &quot;
comma
id|code
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
(brace
id|dir-&gt;u.umsdos_i.i_emd_dir
op_assign
id|ret-&gt;i_ino
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;UMSDOS: Can&squot;t create EMD file&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Disable UMSDOS_notify_change() for EMD file */
id|ret-&gt;u.umsdos_i.i_emd_owner
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Read an entry from the EMD file.&n;&t;Support variable length record.&n;&t;Return -EIO if error, 0 if ok.&n;*/
DECL|function|umsdos_emd_dir_readentry
r_int
id|umsdos_emd_dir_readentry
(paren
r_struct
id|inode
op_star
id|emd_dir
comma
r_struct
id|file
op_star
id|filp
comma
r_struct
id|umsdos_dirent
op_star
id|entry
)paren
(brace
r_int
id|ret
op_assign
id|umsdos_emd_dir_read
c_func
(paren
id|emd_dir
comma
id|filp
comma
(paren
r_char
op_star
)paren
id|entry
comma
id|UMSDOS_REC_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Variable size record. Maybe, we have to read some more */
r_int
id|recsize
op_assign
id|umsdos_evalrecsize
(paren
id|entry-&gt;name_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|recsize
OG
id|UMSDOS_REC_SIZE
)paren
(brace
id|ret
op_assign
id|umsdos_emd_dir_read
c_func
(paren
id|emd_dir
comma
id|filp
comma
(paren
(paren
r_char
op_star
)paren
id|entry
)paren
op_plus
id|UMSDOS_REC_SIZE
comma
id|recsize
op_minus
id|UMSDOS_REC_SIZE
)paren
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Write an entry in the EMD file.&n;&t;Return 0 if ok, -EIO if some error.&n;*/
DECL|function|umsdos_writeentry
r_int
id|umsdos_writeentry
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|inode
op_star
id|emd_dir
comma
r_struct
id|umsdos_info
op_star
id|info
comma
r_int
id|free_entry
)paren
multiline_comment|/* This entry is deleted, so Write all 0&squot;s */
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|file
id|filp
suffix:semicolon
r_struct
id|umsdos_dirent
op_star
id|entry
op_assign
op_amp
id|info-&gt;entry
suffix:semicolon
r_struct
id|umsdos_dirent
id|entry0
suffix:semicolon
r_if
c_cond
(paren
id|free_entry
)paren
(brace
multiline_comment|/* #Specification: EMD file / empty entries&n;&t;&t;&t;Unused entry in the EMD file are identify&n;&t;&t;&t;by the name_len field equal to 0. However to&n;&t;&t;&t;help future extension (or bug correction :-( ),&n;&t;&t;&t;empty entries are filled with 0.&n;&t;&t;*/
id|memset
(paren
op_amp
id|entry0
comma
l_int|0
comma
r_sizeof
(paren
id|entry0
)paren
)paren
suffix:semicolon
id|entry
op_assign
op_amp
id|entry0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry-&gt;name_len
OG
l_int|0
)paren
(brace
id|memset
(paren
id|entry-&gt;name
op_plus
id|entry-&gt;name_len
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|entry-&gt;name
)paren
op_minus
id|entry-&gt;name_len
)paren
suffix:semicolon
multiline_comment|/* #Specification: EMD file / spare bytes&n;&t;&t;&t;10 bytes are unused in each record of the EMD. They&n;&t;&t;&t;are set to 0 all the time. So it will be possible&n;&t;&t;&t;to do new stuff and rely on the state of those&n;&t;&t;&t;bytes in old EMD file around.&n;&t;&t;*/
id|memset
(paren
id|entry-&gt;spare
comma
l_int|0
comma
r_sizeof
(paren
id|entry-&gt;spare
)paren
)paren
suffix:semicolon
)brace
id|filp.f_pos
op_assign
id|info-&gt;f_pos
suffix:semicolon
id|filp.f_reada
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|umsdos_emd_dir_write
c_func
(paren
id|emd_dir
comma
op_amp
id|filp
comma
(paren
r_char
op_star
)paren
id|entry
comma
id|info-&gt;recsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: problem with EMD file. Can&squot;t write&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|dir-&gt;i_ctime
op_assign
id|dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|dir-&gt;i_dirt
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|CHUNK_SIZE
mdefine_line|#define CHUNK_SIZE (8*UMSDOS_REC_SIZE)
DECL|struct|find_buffer
r_struct
id|find_buffer
(brace
DECL|member|buffer
r_char
id|buffer
(braket
id|CHUNK_SIZE
)braket
suffix:semicolon
DECL|member|pos
r_int
id|pos
suffix:semicolon
multiline_comment|/* read offset in buffer */
DECL|member|size
r_int
id|size
suffix:semicolon
multiline_comment|/* Current size of buffer */
DECL|member|filp
r_struct
id|file
id|filp
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;Fill the read buffer and take care of the byte remaining inside.&n;&t;Unread bytes are simply move to the beginning.&n;&n;&t;Return -ENOENT if EOF, 0 if ok, a negative error code if any problem.&n;*/
DECL|function|umsdos_fillbuf
r_static
r_int
id|umsdos_fillbuf
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|find_buffer
op_star
id|buf
)paren
(brace
r_int
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_int
id|mustmove
op_assign
id|buf-&gt;size
op_minus
id|buf-&gt;pos
suffix:semicolon
r_int
id|mustread
suffix:semicolon
r_int
id|remain
suffix:semicolon
r_if
c_cond
(paren
id|mustmove
OG
l_int|0
)paren
(brace
id|memcpy
(paren
id|buf-&gt;buffer
comma
id|buf-&gt;buffer
op_plus
id|buf-&gt;pos
comma
id|mustmove
)paren
suffix:semicolon
)brace
id|buf-&gt;pos
op_assign
l_int|0
suffix:semicolon
id|mustread
op_assign
id|CHUNK_SIZE
op_minus
id|mustmove
suffix:semicolon
id|remain
op_assign
id|inode-&gt;i_size
op_minus
id|buf-&gt;filp.f_pos
suffix:semicolon
r_if
c_cond
(paren
id|remain
OL
id|mustread
)paren
id|mustread
op_assign
id|remain
suffix:semicolon
r_if
c_cond
(paren
id|mustread
OG
l_int|0
)paren
(brace
id|ret
op_assign
id|umsdos_emd_dir_read
(paren
id|inode
comma
op_amp
id|buf-&gt;filp
comma
id|buf-&gt;buffer
op_plus
id|mustmove
comma
id|mustread
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|buf-&gt;size
op_assign
id|mustmove
op_plus
id|mustread
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mustmove
)paren
(brace
id|buf-&gt;size
op_assign
id|mustmove
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;General search, locate a name in the EMD file or an empty slot to&n;&t;store it. if info-&gt;entry.name_len == 0, search the first empty&n;&t;slot (of the proper size).&n;&n;&t;Caller must do iput on *pt_emd_dir.&n;&n;&t;Return 0 if found, -ENOENT if not found, another error code if&n;&t;other problem.&n;&n;&t;So this routine is used to either find an existing entry or to&n;&t;create a new one, while making sure it is a new one. After you&n;&t;get -ENOENT, you make sure the entry is stuffed correctly and&n;&t;call umsdos_writeentry().&n;&n;&t;To delete an entry, you find it, zero out the entry (memset)&n;&t;and call umsdos_writeentry().&n;&n;&t;All this to say that umsdos_writeentry must be call after this&n;&t;function since it rely on the f_pos field of info.&n;*/
DECL|function|umsdos_find
r_static
r_int
id|umsdos_find
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|umsdos_info
op_star
id|info
comma
multiline_comment|/* Hold name and name_len */
multiline_comment|/* Will hold the entry found */
r_struct
id|inode
op_star
op_star
id|pt_emd_dir
)paren
multiline_comment|/* Will hold the emd_dir inode */
multiline_comment|/* or NULL if not found */
(brace
multiline_comment|/* #Specification: EMD file structure&n;&t;&t;The EMD file uses a fairly simple layout. It is made of records&n;&t;&t;(UMSDOS_REC_SIZE == 64). When a name can&squot;t be written is a single&n;&t;&t;record, multiple contiguous record are allocated.&n;&t;*/
r_int
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_struct
id|inode
op_star
id|emd_dir
op_assign
id|umsdos_emd_dir_lookup
c_func
(paren
id|dir
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|emd_dir
op_ne
l_int|NULL
)paren
(brace
r_struct
id|umsdos_dirent
op_star
id|entry
op_assign
op_amp
id|info-&gt;entry
suffix:semicolon
r_int
id|recsize
op_assign
id|info-&gt;recsize
suffix:semicolon
r_struct
(brace
id|off_t
id|posok
suffix:semicolon
multiline_comment|/* Position available to store the entry */
r_int
id|found
suffix:semicolon
multiline_comment|/* A valid empty position has been found */
id|off_t
id|one
suffix:semicolon
multiline_comment|/* One empty position -&gt; maybe &lt;- large enough */
r_int
id|onesize
suffix:semicolon
multiline_comment|/* size of empty region starting at one */
)brace
id|empty
suffix:semicolon
multiline_comment|/* Read several entries at a time to speed up the search */
r_struct
id|find_buffer
id|buf
suffix:semicolon
id|buf.pos
op_assign
l_int|0
suffix:semicolon
id|buf.size
op_assign
l_int|0
suffix:semicolon
id|buf.filp.f_pos
op_assign
l_int|0
suffix:semicolon
id|buf.filp.f_reada
op_assign
l_int|1
suffix:semicolon
id|empty.found
op_assign
l_int|0
suffix:semicolon
id|empty.posok
op_assign
id|emd_dir-&gt;i_size
suffix:semicolon
id|empty.onesize
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|umsdos_dirent
op_star
id|rentry
op_assign
(paren
r_struct
id|umsdos_dirent
op_star
)paren
(paren
id|buf.buffer
op_plus
id|buf.pos
)paren
suffix:semicolon
r_int
id|file_pos
op_assign
id|buf.filp.f_pos
op_minus
id|buf.size
op_plus
id|buf.pos
suffix:semicolon
r_if
c_cond
(paren
id|buf.pos
op_eq
id|buf.size
)paren
(brace
id|ret
op_assign
id|umsdos_fillbuf
(paren
id|emd_dir
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
multiline_comment|/* Not found, so note where it can be added */
id|info-&gt;f_pos
op_assign
id|empty.posok
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|rentry-&gt;name_len
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We are looking for an empty section at least */
multiline_comment|/* recsize large */
r_if
c_cond
(paren
id|entry-&gt;name_len
op_eq
l_int|0
)paren
(brace
id|info-&gt;f_pos
op_assign
id|file_pos
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|empty.found
)paren
(brace
r_if
c_cond
(paren
id|empty.onesize
op_eq
l_int|0
)paren
(brace
multiline_comment|/* This is the first empty record of a section */
id|empty.one
op_assign
id|file_pos
suffix:semicolon
)brace
multiline_comment|/* grow the empty section */
id|empty.onesize
op_add_assign
id|UMSDOS_REC_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|empty.onesize
op_eq
id|recsize
)paren
(brace
multiline_comment|/* here is a large enough section */
id|empty.posok
op_assign
id|empty.one
suffix:semicolon
id|empty.found
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|buf.pos
op_add_assign
id|UMSDOS_REC_SIZE
suffix:semicolon
)brace
r_else
(brace
r_int
id|entry_size
op_assign
id|umsdos_evalrecsize
c_func
(paren
id|rentry-&gt;name_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf.pos
op_plus
id|entry_size
OG
id|buf.size
)paren
(brace
id|ret
op_assign
id|umsdos_fillbuf
(paren
id|emd_dir
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
multiline_comment|/* Not found, so note where it can be added */
id|info-&gt;f_pos
op_assign
id|empty.posok
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|empty.onesize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the free slot search */
r_if
c_cond
(paren
id|entry-&gt;name_len
op_eq
id|rentry-&gt;name_len
op_logical_and
id|memcmp
c_func
(paren
id|entry-&gt;name
comma
id|rentry-&gt;name
comma
id|rentry-&gt;name_len
)paren
op_eq
l_int|0
)paren
(brace
id|info-&gt;f_pos
op_assign
id|file_pos
suffix:semicolon
op_star
id|entry
op_assign
op_star
id|rentry
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|buf.pos
op_add_assign
id|entry_size
suffix:semicolon
)brace
)brace
)brace
)brace
id|umsdos_manglename
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
op_star
id|pt_emd_dir
op_assign
id|emd_dir
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Add a new entry in the emd file&n;&t;Return 0 if ok or a negative error code.&n;&t;Return -EEXIST if the entry already exist.&n;&n;&t;Complete the information missing in info.&n;*/
DECL|function|umsdos_newentry
r_int
id|umsdos_newentry
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|umsdos_info
op_star
id|info
)paren
(brace
r_struct
id|inode
op_star
id|emd_dir
suffix:semicolon
r_int
id|ret
op_assign
id|umsdos_find
(paren
id|dir
comma
id|info
comma
op_amp
id|emd_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EEXIST
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ENOENT
)paren
(brace
id|ret
op_assign
id|umsdos_writeentry
c_func
(paren
id|dir
comma
id|emd_dir
comma
id|info
comma
l_int|0
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
l_string|&quot;umsdos_newentry EDM ret = %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
)brace
id|iput
(paren
id|emd_dir
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Create a new hidden link.&n;&t;Return 0 if ok, an error code if not.&n;*/
DECL|function|umsdos_newhidden
r_int
id|umsdos_newhidden
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|umsdos_info
op_star
id|info
)paren
(brace
r_struct
id|inode
op_star
id|emd_dir
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|umsdos_parse
(paren
l_string|&quot;..LINK&quot;
comma
l_int|6
comma
id|info
)paren
suffix:semicolon
id|info-&gt;entry.name_len
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|umsdos_find
(paren
id|dir
comma
id|info
comma
op_amp
id|emd_dir
)paren
suffix:semicolon
id|iput
(paren
id|emd_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ENOENT
op_logical_or
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/* #Specification: hard link / hidden name&n;&t;&t;&t;When a hard link is created, the original file is renamed&n;&t;&t;&t;to a hidden name. The name is &quot;..LINKNNN&quot; where NNN is a&n;&t;&t;&t;number define from the entry offset in the EMD file.&n;&t;&t;*/
id|info-&gt;entry.name_len
op_assign
id|sprintf
(paren
id|info-&gt;entry.name
comma
l_string|&quot;..LINK%ld&quot;
comma
id|info-&gt;f_pos
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Remove an entry from the emd file&n;&t;Return 0 if ok, a negative error code otherwise.&n;&n;&t;Complete the information missing in info.&n;*/
DECL|function|umsdos_delentry
r_int
id|umsdos_delentry
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|umsdos_info
op_star
id|info
comma
r_int
id|isdir
)paren
(brace
r_struct
id|inode
op_star
id|emd_dir
suffix:semicolon
r_int
id|ret
op_assign
id|umsdos_find
(paren
id|dir
comma
id|info
comma
op_amp
id|emd_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;entry.name_len
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|isdir
op_ne
l_int|0
)paren
op_ne
(paren
id|S_ISDIR
c_func
(paren
id|info-&gt;entry.mode
)paren
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|info-&gt;entry.mode
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EISDIR
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
)brace
)brace
r_else
(brace
id|ret
op_assign
id|umsdos_writeentry
c_func
(paren
id|dir
comma
id|emd_dir
comma
id|info
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
id|iput
c_func
(paren
id|emd_dir
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Verify is a EMD directory is empty.&n;&t;Return 0 if not empty&n;&t;&t;   1 if empty&n;&t;&t;   2 if empty, no EMD file.&n;*/
DECL|function|umsdos_isempty
r_int
id|umsdos_isempty
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
r_int
id|ret
op_assign
l_int|2
suffix:semicolon
r_struct
id|inode
op_star
id|emd_dir
op_assign
id|umsdos_emd_dir_lookup
c_func
(paren
id|dir
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* If the EMD file does not exist, it is certainly empty :-) */
r_if
c_cond
(paren
id|emd_dir
op_ne
l_int|NULL
)paren
(brace
r_struct
id|file
id|filp
suffix:semicolon
multiline_comment|/* Find an empty slot */
id|filp.f_pos
op_assign
l_int|0
suffix:semicolon
id|filp.f_reada
op_assign
l_int|1
suffix:semicolon
id|filp.f_flags
op_assign
id|O_RDONLY
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|filp.f_pos
OL
id|emd_dir-&gt;i_size
)paren
(brace
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_emd_dir_readentry
c_func
(paren
id|emd_dir
comma
op_amp
id|filp
comma
op_amp
id|entry
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry.name_len
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|iput
(paren
id|emd_dir
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Locate an entry in a EMD directory.&n;&t;Return 0 if ok, errcod if not, generally -ENOENT.&n;*/
DECL|function|umsdos_findentry
r_int
id|umsdos_findentry
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|umsdos_info
op_star
id|info
comma
r_int
id|expect
)paren
multiline_comment|/* 0: anything */
multiline_comment|/* 1: file */
multiline_comment|/* 2: directory */
(brace
r_struct
id|inode
op_star
id|emd_dir
suffix:semicolon
r_int
id|ret
op_assign
id|umsdos_find
(paren
id|dir
comma
id|info
comma
op_amp
id|emd_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|expect
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|info-&gt;entry.mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|expect
op_ne
l_int|2
)paren
id|ret
op_assign
op_minus
id|EISDIR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|expect
op_eq
l_int|2
)paren
(brace
id|ret
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
)brace
)brace
)brace
id|iput
(paren
id|emd_dir
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
