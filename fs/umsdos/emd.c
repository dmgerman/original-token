multiline_comment|/*&n; *  linux/fs/umsdos/emd.c&n; *&n; *  Written 1993 by Jacques Gelinas&n; *&n; *  Extended MS-DOS directory handling functions&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/msdos_fs.h&gt;
macro_line|#include &lt;linux/umsdos_fs.h&gt;
macro_line|#include &lt;linux/dcache.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
multiline_comment|/*&n; *    Read a file into kernel space memory&n; *      returns how many bytes read (from fat_file_read)&n; */
DECL|function|umsdos_file_read_kmem
id|ssize_t
id|umsdos_file_read_kmem
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
id|ssize_t
id|ret
suffix:semicolon
id|mm_segment_t
id|old_fs
op_assign
id|get_fs
(paren
)paren
suffix:semicolon
id|set_fs
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|MSDOS_I
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
op_member_access_from_pointer
id|i_binary
op_assign
l_int|2
suffix:semicolon
id|ret
op_assign
id|fat_file_read
(paren
id|filp
comma
id|buf
comma
id|count
comma
op_amp
id|filp-&gt;f_pos
)paren
suffix:semicolon
id|set_fs
(paren
id|old_fs
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *    Write to file from kernel space. &n; *      Does the real job, assumes all structures are initialized!&n; */
DECL|function|umsdos_file_write_kmem_real
id|ssize_t
id|umsdos_file_write_kmem_real
(paren
r_struct
id|file
op_star
id|filp
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
id|mm_segment_t
id|old_fs
op_assign
id|get_fs
(paren
)paren
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
multiline_comment|/* note: i_binary=2 is for CVF-FAT. We put it here, instead of&n;&t; * umsdos_file_write_kmem, since it is also wise not to compress&n;&t; * symlinks (in the unlikely event that they are &gt; 512 bytes and&n;&t; * can be compressed.&n;&t; * FIXME: should we set it when reading symlinks too?&n;&t; */
id|MSDOS_I
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
op_member_access_from_pointer
id|i_binary
op_assign
l_int|2
suffix:semicolon
id|set_fs
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|ret
op_assign
id|fat_file_write
(paren
id|filp
comma
id|buf
comma
id|count
comma
op_amp
id|filp-&gt;f_pos
)paren
suffix:semicolon
id|set_fs
(paren
id|old_fs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;umsdos_file_write: ret=%d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
macro_line|#ifdef UMSDOS_PARANOIA
r_if
c_cond
(paren
id|ret
op_ne
id|count
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;umsdos_file_write: count=%u, ret=%u&bslash;n&quot;
comma
id|count
comma
id|ret
)paren
suffix:semicolon
macro_line|#endif
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *    Write to a file from kernel space.&n; */
DECL|function|umsdos_file_write_kmem
id|ssize_t
id|umsdos_file_write_kmem
(paren
r_struct
id|file
op_star
id|filp
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
id|ssize_t
id|ret
suffix:semicolon
id|ret
op_assign
id|umsdos_file_write_kmem_real
(paren
id|filp
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Write a block of bytes into one EMD file.&n; * The block of data is NOT in user space.&n; * &n; * Return 0 if OK, a negative error code if not.&n; *&n; * Note: buffer is in kernel memory, not in user space.&n; */
DECL|function|umsdos_emd_dir_write
id|ssize_t
id|umsdos_emd_dir_write
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|written
suffix:semicolon
macro_line|#ifdef __BIG_ENDIAN
r_struct
id|umsdos_dirent
op_star
id|d
op_assign
(paren
r_struct
id|umsdos_dirent
op_star
)paren
id|buf
suffix:semicolon
id|d-&gt;nlink
op_assign
id|cpu_to_le16
(paren
id|d-&gt;nlink
)paren
suffix:semicolon
id|d-&gt;uid
op_assign
id|cpu_to_le16
(paren
id|d-&gt;uid
)paren
suffix:semicolon
id|d-&gt;gid
op_assign
id|cpu_to_le16
(paren
id|d-&gt;gid
)paren
suffix:semicolon
id|d-&gt;atime
op_assign
id|cpu_to_le32
(paren
id|d-&gt;atime
)paren
suffix:semicolon
id|d-&gt;mtime
op_assign
id|cpu_to_le32
(paren
id|d-&gt;mtime
)paren
suffix:semicolon
id|d-&gt;ctime
op_assign
id|cpu_to_le32
(paren
id|d-&gt;ctime
)paren
suffix:semicolon
id|d-&gt;rdev
op_assign
id|cpu_to_le16
(paren
id|d-&gt;rdev
)paren
suffix:semicolon
id|d-&gt;mode
op_assign
id|cpu_to_le16
(paren
id|d-&gt;mode
)paren
suffix:semicolon
macro_line|#endif
id|filp-&gt;f_flags
op_assign
l_int|0
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_emd_dir_write /mn/: calling write_kmem with %p, %p, %d, %Ld&bslash;n&quot;
comma
id|filp
comma
id|buf
comma
id|count
comma
id|filp-&gt;f_pos
)paren
)paren
suffix:semicolon
id|written
op_assign
id|umsdos_file_write_kmem
(paren
id|filp
comma
id|buf
comma
id|count
)paren
suffix:semicolon
macro_line|#ifdef __BIG_ENDIAN
id|d-&gt;nlink
op_assign
id|le16_to_cpu
(paren
id|d-&gt;nlink
)paren
suffix:semicolon
id|d-&gt;uid
op_assign
id|le16_to_cpu
(paren
id|d-&gt;uid
)paren
suffix:semicolon
id|d-&gt;gid
op_assign
id|le16_to_cpu
(paren
id|d-&gt;gid
)paren
suffix:semicolon
id|d-&gt;atime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;atime
)paren
suffix:semicolon
id|d-&gt;mtime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;mtime
)paren
suffix:semicolon
id|d-&gt;ctime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;ctime
)paren
suffix:semicolon
id|d-&gt;rdev
op_assign
id|le16_to_cpu
(paren
id|d-&gt;rdev
)paren
suffix:semicolon
id|d-&gt;mode
op_assign
id|le16_to_cpu
(paren
id|d-&gt;mode
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef UMSDOS_PARANOIA
r_if
c_cond
(paren
id|written
op_ne
id|count
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;umsdos_emd_dir_write: ERROR: written (%d) != count (%d)&bslash;n&quot;
comma
id|written
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|written
op_ne
id|count
)paren
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *      Read a block of bytes from one EMD file.&n; *      The block of data is NOT in user space.&n; *      Return 0 if OK, -EIO if any error.&n; */
multiline_comment|/* buffer in kernel memory, not in user space */
DECL|function|umsdos_emd_dir_read
id|ssize_t
id|umsdos_emd_dir_read
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
id|ssize_t
id|sizeread
comma
id|ret
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef __BIG_ENDIAN
r_struct
id|umsdos_dirent
op_star
id|d
op_assign
(paren
r_struct
id|umsdos_dirent
op_star
)paren
id|buf
suffix:semicolon
macro_line|#endif
id|filp-&gt;f_flags
op_assign
l_int|0
suffix:semicolon
id|sizeread
op_assign
id|umsdos_file_read_kmem
(paren
id|filp
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sizeread
op_ne
id|count
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;UMSDOS: EMD problem, pos=%Ld, count=%d, read=%d&bslash;n&quot;
comma
id|filp-&gt;f_pos
comma
id|count
comma
id|sizeread
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#ifdef __BIG_ENDIAN
id|d-&gt;nlink
op_assign
id|le16_to_cpu
(paren
id|d-&gt;nlink
)paren
suffix:semicolon
id|d-&gt;uid
op_assign
id|le16_to_cpu
(paren
id|d-&gt;uid
)paren
suffix:semicolon
id|d-&gt;gid
op_assign
id|le16_to_cpu
(paren
id|d-&gt;gid
)paren
suffix:semicolon
id|d-&gt;atime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;atime
)paren
suffix:semicolon
id|d-&gt;mtime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;mtime
)paren
suffix:semicolon
id|d-&gt;ctime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;ctime
)paren
suffix:semicolon
id|d-&gt;rdev
op_assign
id|le16_to_cpu
(paren
id|d-&gt;rdev
)paren
suffix:semicolon
id|d-&gt;mode
op_assign
id|le16_to_cpu
(paren
id|d-&gt;mode
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Create the EMD dentry for a directory.&n; */
DECL|function|umsdos_get_emd_dentry
r_struct
id|dentry
op_star
id|umsdos_get_emd_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|parent
)paren
(brace
r_struct
id|dentry
op_star
id|demd
suffix:semicolon
id|demd
op_assign
id|umsdos_lookup_dentry
c_func
(paren
id|parent
comma
id|UMSDOS_EMD_FILE
comma
id|UMSDOS_EMD_NAMELEN
comma
l_int|1
)paren
suffix:semicolon
r_return
id|demd
suffix:semicolon
)brace
multiline_comment|/*&n; * Check whether a directory has an EMD file.&n; */
DECL|function|umsdos_have_emd
r_int
id|umsdos_have_emd
c_func
(paren
r_struct
id|dentry
op_star
id|dir
)paren
(brace
r_struct
id|dentry
op_star
id|demd
op_assign
id|umsdos_get_emd_dentry
(paren
id|dir
)paren
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|demd
)paren
)paren
(brace
r_if
c_cond
(paren
id|demd-&gt;d_inode
)paren
id|found
op_assign
l_int|1
suffix:semicolon
id|dput
c_func
(paren
id|demd
)paren
suffix:semicolon
)brace
r_return
id|found
suffix:semicolon
)brace
multiline_comment|/*&n; * Create the EMD file for a directory if it doesn&squot;t&n; * already exist. Returns 0 or an error code.&n; */
DECL|function|umsdos_make_emd
r_int
id|umsdos_make_emd
c_func
(paren
r_struct
id|dentry
op_star
id|parent
)paren
(brace
r_struct
id|dentry
op_star
id|demd
op_assign
id|umsdos_get_emd_dentry
c_func
(paren
id|parent
)paren
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|demd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|demd
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;umsdos_make_emd: can&squot;t get dentry in %s, err=%d&bslash;n&quot;
comma
id|parent-&gt;d_name.name
comma
id|err
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* already created? */
id|err
op_assign
l_int|0
suffix:semicolon
id|inode
op_assign
id|demd-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
r_goto
id|out_set
suffix:semicolon
id|Printk
c_func
(paren
(paren
l_string|&quot;umsdos_make_emd: creating EMD %s/%s&bslash;n&quot;
comma
id|parent-&gt;d_name.name
comma
id|demd-&gt;d_name.name
)paren
)paren
suffix:semicolon
id|err
op_assign
id|msdos_create
c_func
(paren
id|parent-&gt;d_inode
comma
id|demd
comma
id|S_IFREG
op_or
l_int|0777
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;UMSDOS: create %s/%s failed, err=%d&bslash;n&quot;
comma
id|parent-&gt;d_name.name
comma
id|demd-&gt;d_name.name
comma
id|err
)paren
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
id|inode
op_assign
id|demd-&gt;d_inode
suffix:semicolon
id|out_set
suffix:colon
id|parent-&gt;d_inode-&gt;u.umsdos_i.i_emd_dir
op_assign
id|inode-&gt;i_ino
suffix:semicolon
multiline_comment|/* Disable UMSDOS_notify_change() for EMD file */
id|inode-&gt;u.umsdos_i.i_emd_owner
op_assign
l_int|0xffffffff
suffix:semicolon
id|out_dput
suffix:colon
id|dput
c_func
(paren
id|demd
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Locate the EMD file in a directory.&n; * &n; * Return NULL if error, dir-&gt;u.umsdos_i.emd_inode if OK. &n; * Caller must iput() returned inode when finished with it!&n; * Note: deprecated; get rid of this soon!&n; */
DECL|function|umsdos_emd_dir_lookup
r_struct
id|inode
op_star
id|umsdos_emd_dir_lookup
(paren
r_struct
id|inode
op_star
id|dir
comma
r_int
id|creat
)paren
(brace
r_struct
id|inode
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|dentry
op_star
id|d_dir
op_assign
l_int|NULL
comma
op_star
id|dlook
op_assign
l_int|NULL
suffix:semicolon
r_int
id|rv
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;Entering umsdos_emd_dir_lookup&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
(brace
id|printk
(paren
id|KERN_CRIT
l_string|&quot;umsdos_emd_dir_lookup: FATAL, dir=NULL!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|check_inode
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.i_emd_dir
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
id|iget
(paren
id|dir-&gt;i_sb
comma
id|dir-&gt;u.umsdos_i.i_emd_dir
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_emd_dir_lookup: deja trouve %ld %p&bslash;n&quot;
comma
id|dir-&gt;u.umsdos_i.i_emd_dir
comma
id|ret
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos /mn/: Looking for %.*s -&quot;
comma
id|UMSDOS_EMD_NAMELEN
comma
id|UMSDOS_EMD_FILE
)paren
)paren
suffix:semicolon
id|d_dir
op_assign
id|geti_dentry
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|d_dir
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;UMSDOS: flaky i_dentry hack failed&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|dlook
op_assign
id|creat_dentry
(paren
id|UMSDOS_EMD_FILE
comma
id|UMSDOS_EMD_NAMELEN
comma
l_int|NULL
comma
id|d_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dlook
)paren
r_goto
id|out
suffix:semicolon
id|rv
op_assign
id|msdos_lookup
(paren
id|dir
comma
id|dlook
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;-returned %d&bslash;n&quot;
comma
id|rv
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_INFO
l_string|&quot;emd_dir_lookup &quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|dlook-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;Found --linux &quot;
)paren
)paren
suffix:semicolon
id|dir-&gt;u.umsdos_i.i_emd_dir
op_assign
id|ret-&gt;i_ino
suffix:semicolon
id|ret-&gt;i_count
op_increment
suffix:semicolon
multiline_comment|/* we&squot;ll need the inode */
id|check_inode
(paren
id|ret
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|creat
)paren
(brace
r_int
id|code
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot; * ERROR * /mn/: creat not yet implemented? not fixed? &quot;
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;avant create &quot;
)paren
)paren
suffix:semicolon
id|check_inode
(paren
id|ret
)paren
suffix:semicolon
id|code
op_assign
id|compat_msdos_create
(paren
id|dir
comma
id|UMSDOS_EMD_FILE
comma
id|UMSDOS_EMD_NAMELEN
comma
id|S_IFREG
op_or
l_int|0777
comma
op_amp
id|ret
)paren
suffix:semicolon
id|check_inode
(paren
id|ret
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;Creat EMD code %d ret %p &quot;
comma
id|code
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; ino=%lu&quot;
comma
id|ret-&gt;i_ino
)paren
)paren
suffix:semicolon
id|dir-&gt;u.umsdos_i.i_emd_dir
op_assign
id|ret-&gt;i_ino
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;UMSDOS: Can&squot;t create EMD file&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|dput
c_func
(paren
id|dlook
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Disable UMSDOS_notify_change() for EMD file */
id|ret-&gt;u.umsdos_i.i_emd_owner
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
id|out
suffix:colon
macro_line|#if UMS_DEBUG
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_emd_dir_lookup returning %p /mn/&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot; returning ino=%lu&bslash;n&quot;
comma
id|ret-&gt;i_ino
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Read an entry from the EMD file.&n; * Support variable length record.&n; * Return -EIO if error, 0 if OK.&n; *&n; * does not change {d,i}_count&n; */
DECL|function|umsdos_emd_dir_readentry
r_int
id|umsdos_emd_dir_readentry
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|umsdos_dirent
op_star
id|entry
)paren
(brace
r_int
id|ret
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_emd_dir_readentry /mn/: entering.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_emd_dir_read
(paren
id|filp
comma
(paren
r_char
op_star
)paren
id|entry
comma
id|UMSDOS_REC_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/* if no error */
multiline_comment|/* Variable size record. Maybe, we have to read some more */
r_int
id|recsize
op_assign
id|umsdos_evalrecsize
(paren
id|entry-&gt;name_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|recsize
OG
id|UMSDOS_REC_SIZE
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_emd_dir_readentry /mn/: %d &gt; %d!&bslash;n&quot;
comma
id|recsize
comma
id|UMSDOS_REC_SIZE
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_emd_dir_read
(paren
id|filp
comma
(paren
(paren
r_char
op_star
)paren
id|entry
)paren
op_plus
id|UMSDOS_REC_SIZE
comma
id|recsize
op_minus
id|UMSDOS_REC_SIZE
)paren
suffix:semicolon
)brace
)brace
id|Printk
(paren
(paren
l_string|&quot;umsdos_emd_dir_readentry /mn/: ret=%d.&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_logical_and
id|ret
op_eq
l_int|0
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;umsdos_emd_dir_readentry /mn/: returning len=%d,name=%.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|entry-&gt;name_len
comma
(paren
r_int
)paren
id|entry-&gt;name_len
comma
id|entry-&gt;name
)paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Write an entry in the EMD file.&n; * Return 0 if OK, -EIO if some error.&n; */
DECL|function|umsdos_writeentry
r_static
r_int
id|umsdos_writeentry
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_struct
id|umsdos_info
op_star
id|info
comma
r_int
id|free_entry
)paren
(brace
r_struct
id|inode
op_star
id|dir
op_assign
id|parent-&gt;d_inode
suffix:semicolon
r_struct
id|umsdos_dirent
op_star
id|entry
op_assign
op_amp
id|info-&gt;entry
suffix:semicolon
r_struct
id|dentry
op_star
id|emd_dentry
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_struct
id|umsdos_dirent
id|entry0
suffix:semicolon
r_struct
id|file
id|filp
suffix:semicolon
id|emd_dentry
op_assign
id|umsdos_get_emd_dentry
c_func
(paren
id|parent
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|emd_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|emd_dentry
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* make sure there&squot;s an EMD file */
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|emd_dentry-&gt;d_inode
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;umsdos_writeentry: no EMD file in %s/%s&bslash;n&quot;
comma
id|parent-&gt;d_parent-&gt;d_name.name
comma
id|parent-&gt;d_name.name
)paren
suffix:semicolon
r_goto
id|out_dput
suffix:semicolon
)brace
r_if
c_cond
(paren
id|free_entry
)paren
(brace
multiline_comment|/* #Specification: EMD file / empty entries&n;&t;&t; * Unused entries in the EMD file are identified&n;&t;&t; * by the name_len field equal to 0. However to&n;&t;&t; * help future extension (or bug correction :-( ),&n;&t;&t; * empty entries are filled with 0.&n;&t;&t; */
id|memset
(paren
op_amp
id|entry0
comma
l_int|0
comma
r_sizeof
(paren
id|entry0
)paren
)paren
suffix:semicolon
id|entry
op_assign
op_amp
id|entry0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry-&gt;name_len
OG
l_int|0
)paren
(brace
id|memset
(paren
id|entry-&gt;name
op_plus
id|entry-&gt;name_len
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|entry-&gt;name
)paren
op_minus
id|entry-&gt;name_len
)paren
suffix:semicolon
multiline_comment|/* #Specification: EMD file / spare bytes&n;&t;&t; * 10 bytes are unused in each record of the EMD. They&n;&t;&t; * are set to 0 all the time, so it will be possible&n;&t;&t; * to do new stuff and rely on the state of those&n;&t;&t; * bytes in old EMD files.&n;&t;&t; */
id|memset
(paren
id|entry-&gt;spare
comma
l_int|0
comma
r_sizeof
(paren
id|entry-&gt;spare
)paren
)paren
suffix:semicolon
)brace
id|fill_new_filp
(paren
op_amp
id|filp
comma
id|emd_dentry
)paren
suffix:semicolon
id|filp.f_pos
op_assign
id|info-&gt;f_pos
suffix:semicolon
id|filp.f_reada
op_assign
l_int|0
suffix:semicolon
id|filp.f_flags
op_assign
id|O_RDWR
suffix:semicolon
multiline_comment|/* write the entry and update the parent timestamps */
id|ret
op_assign
id|umsdos_emd_dir_write
(paren
op_amp
id|filp
comma
(paren
r_char
op_star
)paren
id|entry
comma
id|info-&gt;recsize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|dir-&gt;i_ctime
op_assign
id|dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
r_else
id|printk
(paren
l_string|&quot;UMSDOS:  problem with EMD file:  can&squot;t write&bslash;n&quot;
)paren
suffix:semicolon
id|out_dput
suffix:colon
id|dput
c_func
(paren
id|emd_dentry
)paren
suffix:semicolon
id|out
suffix:colon
id|Printk
(paren
(paren
l_string|&quot;umsdos_writeentry /mn/: returning %d...&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|CHUNK_SIZE
mdefine_line|#define CHUNK_SIZE (8*UMSDOS_REC_SIZE)
DECL|struct|find_buffer
r_struct
id|find_buffer
(brace
DECL|member|buffer
r_char
id|buffer
(braket
id|CHUNK_SIZE
)braket
suffix:semicolon
DECL|member|pos
r_int
id|pos
suffix:semicolon
multiline_comment|/* read offset in buffer */
DECL|member|size
r_int
id|size
suffix:semicolon
multiline_comment|/* Current size of buffer */
DECL|member|filp
r_struct
id|file
id|filp
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Fill the read buffer and take care of the bytes remaining inside.&n; * Unread bytes are simply moved to the beginning.&n; * &n; * Return -ENOENT if EOF, 0 if OK, a negative error code if any problem.&n; */
DECL|function|umsdos_fillbuf
r_static
r_int
id|umsdos_fillbuf
(paren
r_struct
id|find_buffer
op_star
id|buf
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|buf-&gt;filp.f_dentry-&gt;d_inode
suffix:semicolon
r_int
id|mustmove
op_assign
id|buf-&gt;size
op_minus
id|buf-&gt;pos
suffix:semicolon
r_int
id|mustread
comma
id|remain
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|mustmove
OG
l_int|0
)paren
(brace
id|memcpy
(paren
id|buf-&gt;buffer
comma
id|buf-&gt;buffer
op_plus
id|buf-&gt;pos
comma
id|mustmove
)paren
suffix:semicolon
)brace
id|buf-&gt;pos
op_assign
l_int|0
suffix:semicolon
id|mustread
op_assign
id|CHUNK_SIZE
op_minus
id|mustmove
suffix:semicolon
id|remain
op_assign
id|inode-&gt;i_size
op_minus
id|buf-&gt;filp.f_pos
suffix:semicolon
r_if
c_cond
(paren
id|remain
OL
id|mustread
)paren
id|mustread
op_assign
id|remain
suffix:semicolon
r_if
c_cond
(paren
id|mustread
OG
l_int|0
)paren
(brace
id|ret
op_assign
id|umsdos_emd_dir_read
(paren
op_amp
id|buf-&gt;filp
comma
id|buf-&gt;buffer
op_plus
id|mustmove
comma
id|mustread
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|buf-&gt;size
op_assign
id|mustmove
op_plus
id|mustread
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mustmove
)paren
(brace
id|buf-&gt;size
op_assign
id|mustmove
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * General search, locate a name in the EMD file or an empty slot to&n; * store it. if info-&gt;entry.name_len == 0, search the first empty&n; * slot (of the proper size).&n; * &n; * Return 0 if found, -ENOENT if not found, another error code if&n; * other problem.&n; * &n; * So this routine is used to either find an existing entry or to&n; * create a new one, while making sure it is a new one. After you&n; * get -ENOENT, you make sure the entry is stuffed correctly and&n; * call umsdos_writeentry().&n; * &n; * To delete an entry, you find it, zero out the entry (memset)&n; * and call umsdos_writeentry().&n; * &n; * All this to say that umsdos_writeentry must be called after this&n; * function since it relies on the f_pos field of info.&n; *&n; */
multiline_comment|/* #Specification: EMD file structure&n; * The EMD file uses a fairly simple layout.  It is made of records&n; * (UMSDOS_REC_SIZE == 64).  When a name can&squot;t be written in a single&n; * record, multiple contiguous records are allocated.&n; */
DECL|function|umsdos_find
r_static
r_int
id|umsdos_find
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_struct
id|umsdos_info
op_star
id|info
)paren
(brace
r_struct
id|umsdos_dirent
op_star
id|entry
op_assign
op_amp
id|info-&gt;entry
suffix:semicolon
r_int
id|recsize
op_assign
id|info-&gt;recsize
suffix:semicolon
r_struct
id|dentry
op_star
id|demd
suffix:semicolon
r_struct
id|inode
op_star
id|emd_dir
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_struct
id|find_buffer
id|buf
suffix:semicolon
r_struct
(brace
id|off_t
id|posok
suffix:semicolon
multiline_comment|/* Position available to store the entry */
r_int
id|found
suffix:semicolon
multiline_comment|/* A valid empty position has been found. */
id|off_t
id|one
suffix:semicolon
multiline_comment|/* One empty position -&gt; maybe &lt;- large enough */
r_int
id|onesize
suffix:semicolon
multiline_comment|/* size of empty region starting at one */
)brace
id|empty
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_find: locating %s in %s/%s&bslash;n&quot;
comma
id|entry-&gt;name
comma
id|parent-&gt;d_parent-&gt;d_name.name
comma
id|parent-&gt;d_name.name
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Lookup the EMD file in the parent directory.&n;&t; */
id|demd
op_assign
id|umsdos_get_emd_dentry
c_func
(paren
id|parent
)paren
suffix:semicolon
id|ret
op_assign
id|PTR_ERR
c_func
(paren
id|demd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|demd
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* make sure there&squot;s an EMD file ... */
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|emd_dir
op_assign
id|demd-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|emd_dir
)paren
r_goto
id|out_dput
suffix:semicolon
id|Printk
c_func
(paren
(paren
l_string|&quot;umsdos_find: found EMD file %s/%s, ino=%p&bslash;n&quot;
comma
id|demd-&gt;d_parent-&gt;d_name.name
comma
id|demd-&gt;d_name.name
comma
id|emd_dir
)paren
)paren
suffix:semicolon
id|fill_new_filp
(paren
op_amp
id|buf.filp
comma
id|demd
)paren
suffix:semicolon
id|buf.pos
op_assign
l_int|0
suffix:semicolon
id|buf.size
op_assign
l_int|0
suffix:semicolon
id|empty.found
op_assign
l_int|0
suffix:semicolon
id|empty.posok
op_assign
id|emd_dir-&gt;i_size
suffix:semicolon
id|empty.onesize
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|umsdos_dirent
op_star
id|rentry
op_assign
(paren
r_struct
id|umsdos_dirent
op_star
)paren
(paren
id|buf.buffer
op_plus
id|buf.pos
)paren
suffix:semicolon
r_int
id|file_pos
op_assign
id|buf.filp.f_pos
op_minus
id|buf.size
op_plus
id|buf.pos
suffix:semicolon
r_if
c_cond
(paren
id|buf.pos
op_eq
id|buf.size
)paren
(brace
id|ret
op_assign
id|umsdos_fillbuf
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
multiline_comment|/* Not found, so note where it can be added */
id|info-&gt;f_pos
op_assign
id|empty.posok
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|rentry-&gt;name_len
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We are looking for an empty section at least */
multiline_comment|/* as large as recsize. */
r_if
c_cond
(paren
id|entry-&gt;name_len
op_eq
l_int|0
)paren
(brace
id|info-&gt;f_pos
op_assign
id|file_pos
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|empty.found
)paren
(brace
r_if
c_cond
(paren
id|empty.onesize
op_eq
l_int|0
)paren
(brace
multiline_comment|/* This is the first empty record of a section. */
id|empty.one
op_assign
id|file_pos
suffix:semicolon
)brace
multiline_comment|/* grow the empty section */
id|empty.onesize
op_add_assign
id|UMSDOS_REC_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|empty.onesize
op_eq
id|recsize
)paren
(brace
multiline_comment|/* Here is a large enough section. */
id|empty.posok
op_assign
id|empty.one
suffix:semicolon
id|empty.found
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|buf.pos
op_add_assign
id|UMSDOS_REC_SIZE
suffix:semicolon
)brace
r_else
(brace
r_int
id|entry_size
op_assign
id|umsdos_evalrecsize
(paren
id|rentry-&gt;name_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf.pos
op_plus
id|entry_size
OG
id|buf.size
)paren
(brace
id|ret
op_assign
id|umsdos_fillbuf
(paren
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
multiline_comment|/* Not found, so note where it can be added */
id|info-&gt;f_pos
op_assign
id|empty.posok
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|empty.onesize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the free slot search. */
r_if
c_cond
(paren
id|entry-&gt;name_len
op_eq
id|rentry-&gt;name_len
op_logical_and
id|memcmp
(paren
id|entry-&gt;name
comma
id|rentry-&gt;name
comma
id|rentry-&gt;name_len
)paren
op_eq
l_int|0
)paren
(brace
id|info-&gt;f_pos
op_assign
id|file_pos
suffix:semicolon
op_star
id|entry
op_assign
op_star
id|rentry
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|buf.pos
op_add_assign
id|entry_size
suffix:semicolon
)brace
)brace
)brace
)brace
id|Printk
c_func
(paren
(paren
l_string|&quot;umsdos_find: ready to mangle %s, len=%d, pos=%ld&bslash;n&quot;
comma
id|entry-&gt;name
comma
id|entry-&gt;name_len
comma
(paren
r_int
)paren
id|info-&gt;f_pos
)paren
)paren
suffix:semicolon
id|umsdos_manglename
(paren
id|info
)paren
suffix:semicolon
id|out_dput
suffix:colon
id|dput
c_func
(paren
id|demd
)paren
suffix:semicolon
id|out
suffix:colon
id|Printk
(paren
(paren
l_string|&quot;umsdos_find: returning %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a new entry in the EMD file.&n; * Return 0 if OK or a negative error code.&n; * Return -EEXIST if the entry already exists.&n; *&n; * Complete the information missing in info.&n; * &n; * N.B. What if the EMD file doesn&squot;t exist?&n; */
DECL|function|umsdos_newentry
r_int
id|umsdos_newentry
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_struct
id|umsdos_info
op_star
id|info
)paren
(brace
r_int
id|err
comma
id|ret
op_assign
op_minus
id|EEXIST
suffix:semicolon
id|err
op_assign
id|umsdos_find
(paren
id|parent
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_logical_and
id|err
op_eq
op_minus
id|ENOENT
)paren
(brace
id|ret
op_assign
id|umsdos_writeentry
(paren
id|parent
comma
id|info
comma
l_int|0
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_writeentry EMD ret = %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a new hidden link.&n; * Return 0 if OK, an error code if not.&n; */
multiline_comment|/* #Specification: hard link / hidden name&n; * When a hard link is created, the original file is renamed&n; * to a hidden name. The name is &quot;..LINKNNN&quot; where NNN is a&n; * number define from the entry offset in the EMD file.&n; */
DECL|function|umsdos_newhidden
r_int
id|umsdos_newhidden
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_struct
id|umsdos_info
op_star
id|info
)paren
(brace
r_int
id|ret
suffix:semicolon
id|umsdos_parse
(paren
l_string|&quot;..LINK&quot;
comma
l_int|6
comma
id|info
)paren
suffix:semicolon
id|info-&gt;entry.name_len
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|umsdos_find
(paren
id|parent
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ENOENT
op_logical_or
id|ret
op_eq
l_int|0
)paren
(brace
id|info-&gt;entry.name_len
op_assign
id|sprintf
(paren
id|info-&gt;entry.name
comma
l_string|&quot;..LINK%ld&quot;
comma
id|info-&gt;f_pos
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove an entry from the EMD file.&n; * Return 0 if OK, a negative error code otherwise.&n; * &n; * Complete the information missing in info.&n; */
DECL|function|umsdos_delentry
r_int
id|umsdos_delentry
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_struct
id|umsdos_info
op_star
id|info
comma
r_int
id|isdir
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|umsdos_find
(paren
id|parent
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;entry.name_len
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
(paren
id|isdir
op_ne
l_int|0
)paren
op_ne
(paren
id|S_ISDIR
(paren
id|info-&gt;entry.mode
)paren
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|info-&gt;entry.mode
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EISDIR
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
id|ret
op_assign
id|umsdos_writeentry
(paren
id|parent
comma
id|info
comma
l_int|1
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Verify that an EMD directory is empty.&n; * Return: &n; * 0 if not empty,&n; * 1 if empty (except for EMD file),&n; * 2 if empty or no EMD file.&n; */
DECL|function|umsdos_isempty
r_int
id|umsdos_isempty
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|dentry
op_star
id|demd
suffix:semicolon
r_int
id|ret
op_assign
l_int|2
suffix:semicolon
r_struct
id|file
id|filp
suffix:semicolon
id|demd
op_assign
id|umsdos_get_emd_dentry
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|demd
)paren
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* If the EMD file does not exist, it is certainly empty. :-) */
r_if
c_cond
(paren
op_logical_neg
id|demd-&gt;d_inode
)paren
r_goto
id|out_dput
suffix:semicolon
id|fill_new_filp
(paren
op_amp
id|filp
comma
id|demd
)paren
suffix:semicolon
id|filp.f_flags
op_assign
id|O_RDONLY
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|filp.f_pos
OL
id|demd-&gt;d_inode-&gt;i_size
)paren
(brace
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_emd_dir_readentry
(paren
op_amp
id|filp
comma
op_amp
id|entry
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|entry.name_len
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|out_dput
suffix:colon
id|dput
c_func
(paren
id|demd
)paren
suffix:semicolon
id|out
suffix:colon
id|Printk
c_func
(paren
(paren
l_string|&quot;umsdos_isempty: checked %s/%s, empty=%d&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Locate an entry in a EMD directory.&n; * Return 0 if OK, error code if not, generally -ENOENT.&n; *&n; * expect argument:&n; * &t;0: anything&n; * &t;1: file&n; * &t;2: directory&n; */
DECL|function|umsdos_findentry
r_int
id|umsdos_findentry
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_struct
id|umsdos_info
op_star
id|info
comma
r_int
id|expect
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|umsdos_find
(paren
id|parent
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
r_switch
c_cond
(paren
id|expect
)paren
(brace
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|info-&gt;entry.mode
)paren
)paren
id|ret
op_assign
op_minus
id|EISDIR
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
(paren
id|info-&gt;entry.mode
)paren
)paren
id|ret
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
)brace
id|out
suffix:colon
id|Printk
(paren
(paren
l_string|&quot;umsdos_findentry: returning %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
