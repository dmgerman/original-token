multiline_comment|/*&n; *  linux/fs/umsdos/emd.c&n; *&n; *  Written 1993 by Jacques Gelinas&n; *&n; *  Extended MS-DOS directory handling functions&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/msdos_fs.h&gt;
macro_line|#include &lt;linux/umsdos_fs.h&gt;
macro_line|#include &lt;linux/dcache.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x)
DECL|macro|Printk
mdefine_line|#define Printk(x) printk x
multiline_comment|/*&n; * makes empty filp&n; *&n; */
DECL|function|fill_new_filp
r_void
id|fill_new_filp
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;/mn/ fill_new_filp: filling empty filp at %p&bslash;n&quot;
comma
id|filp
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
)paren
id|Printk
(paren
(paren
l_string|&quot;     dentry=%.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
r_else
id|Printk
(paren
(paren
l_string|&quot;     dentry is NULL ! you must fill it later...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|memset
(paren
id|filp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|file
)paren
)paren
suffix:semicolon
id|filp-&gt;f_pos
op_assign
l_int|0
suffix:semicolon
id|filp-&gt;f_reada
op_assign
l_int|1
suffix:semicolon
id|filp-&gt;f_flags
op_assign
id|O_RDWR
suffix:semicolon
id|filp-&gt;f_dentry
op_assign
id|dentry
suffix:semicolon
id|filp-&gt;f_op
op_assign
op_amp
id|umsdos_file_operations
suffix:semicolon
multiline_comment|/* /mn/ - we have to fill it with SOMETHING */
)brace
multiline_comment|/*&n; * makes dentry. for name name with length len. /mn/&n; * if inode is not NULL, puts it also.&n; *&n; */
DECL|function|creat_dentry
r_struct
id|dentry
op_star
id|creat_dentry
(paren
r_const
r_char
op_star
id|name
comma
r_const
r_int
id|len
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|dentry
op_star
id|ret
comma
op_star
id|parent
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* FIXME /mn/: whatis parent ?? */
r_struct
id|qstr
id|qname
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;/mn/ creat_dentry: creating dentry with inode=%lu for %.*s&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|len
comma
id|name
)paren
)paren
suffix:semicolon
r_else
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;/mn/ creat_dentry: creating empty dentry for %.*s&bslash;n&quot;
comma
id|len
comma
id|name
)paren
)paren
suffix:semicolon
id|qname.name
op_assign
id|name
suffix:semicolon
id|qname.len
op_assign
id|len
suffix:semicolon
id|qname.hash
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|d_alloc
(paren
id|parent
comma
op_amp
id|qname
)paren
suffix:semicolon
multiline_comment|/* create new dentry */
id|ret-&gt;d_inode
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
id|d_add
(paren
id|ret
comma
id|inode
)paren
suffix:semicolon
multiline_comment|/*    ret-&gt;d_inode = inode; /mn/ FIXME this was old, replaced by d_add, delete this ! */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * removes temporary dentry created by creat_dentry&n; *&n; */
DECL|function|kill_dentry
r_void
id|kill_dentry
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_if
c_cond
(paren
id|dentry
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;/mn/ kill_dentry: kill_dentry %.*s :&quot;
comma
(paren
r_int
)paren
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
id|Printk
(paren
(paren
l_string|&quot;inode=%lu&bslash;n&quot;
comma
id|dentry-&gt;d_inode-&gt;i_ino
)paren
)paren
suffix:semicolon
r_else
id|Printk
(paren
(paren
l_string|&quot;inode is NULL&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: is this ok ?! /mn/ */
multiline_comment|/* d_invalidate (dentry); */
multiline_comment|/*dput (dentry);*/
)brace
r_else
(brace
id|Printk
(paren
(paren
l_string|&quot;/mn/ kill_dentry: dentry is NULL ?!&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;/mn/ kill_dentry: exiting...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Read a file into kernel space memory&n; *&t;returns how many bytes read (from fat_file_read)&n; */
DECL|function|umsdos_file_read_kmem
id|ssize_t
id|umsdos_file_read_kmem
(paren
r_struct
id|inode
op_star
id|emd_dir
comma
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|offs
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|dentry
op_star
id|old_dentry
suffix:semicolon
id|mm_segment_t
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|old_dentry
op_assign
id|filp-&gt;f_dentry
suffix:semicolon
multiline_comment|/* save it */
id|filp-&gt;f_dentry
op_assign
id|creat_dentry
(paren
id|UMSDOS_EMD_FILE
comma
id|UMSDOS_EMD_NAMELEN
comma
id|emd_dir
)paren
suffix:semicolon
op_star
id|offs
op_assign
id|filp-&gt;f_pos
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_file_read_kmem /mn/: Checkin: filp=%p, buf=%p, size=%d, offs=%p&bslash;n&quot;
comma
id|filp
comma
id|buf
comma
id|count
comma
id|offs
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  using emd=%ld&bslash;n&quot;
comma
id|emd_dir-&gt;i_ino
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  inode=%lu, i_size=%lu&bslash;n&quot;
comma
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_ino
comma
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_size
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  ofs=%ld&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
op_star
id|offs
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  f_pos=%Lu&bslash;n&quot;
comma
id|filp-&gt;f_pos
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  name=%.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|filp-&gt;f_dentry-&gt;d_name.len
comma
id|filp-&gt;f_dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  i_binary(sb)=%d&bslash;n&quot;
comma
id|MSDOS_I
c_func
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
op_member_access_from_pointer
id|i_binary
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  f_count=%d, f_flags=%d&bslash;n&quot;
comma
id|filp-&gt;f_count
comma
id|filp-&gt;f_flags
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  f_owner=%d&bslash;n&quot;
comma
id|filp-&gt;f_owner.uid
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  f_version=%ld&bslash;n&quot;
comma
id|filp-&gt;f_version
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  f_reada=%ld, f_ramax=%ld, f_raend=%ld, f_ralen=%ld, f_rawin=%ld&bslash;n&quot;
comma
id|filp-&gt;f_reada
comma
id|filp-&gt;f_ramax
comma
id|filp-&gt;f_raend
comma
id|filp-&gt;f_ralen
comma
id|filp-&gt;f_rawin
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|fat_file_read
c_func
(paren
id|filp
comma
id|buf
comma
id|count
comma
id|offs
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;fat_file_read returned with %d!&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
id|filp-&gt;f_pos
op_assign
op_star
id|offs
suffix:semicolon
multiline_comment|/* we needed *filp only for this? grrrr... /mn/ */
multiline_comment|/* FIXME: I have no idea what f_pos is used for. It seems to be used this way before offs was introduced.&n;    &t;&t;&t;&t;   this probably needs fixing /mn/ */
id|filp-&gt;f_dentry
op_assign
id|old_dentry
suffix:semicolon
multiline_comment|/* restore orig. dentry (it is dentry of file we need info about. Dunno why it gets passed to us&n;    &t;&t;&t;&t;&t;&t;   since we have no use for it, expect to store totally unrelated data of offset of EMD_FILE&n;    &t;&t;&t;&t;&t;&t;   end not directory in it. But what the hell now... fat_file_read requires it also, but prolly expects&n;    &t;&t;&t;&t;&t;&t;   it to be file* of EMD not file we want to read EMD entry about... ugh. complicated to explain :) /mn/ */
multiline_comment|/* FIXME: we probably need to destroy originl filp-&gt;f_dentry first ? Do we ? And how ? this way we leave all sorts of dentries, inodes etc. lying around */
multiline_comment|/* Also FIXME: all the same problems in umsdos_file_write_kmem */
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (ret) using emd=%lu&bslash;n&quot;
comma
id|emd_dir-&gt;i_ino
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (ret) inode=%lu, i_size=%lu&bslash;n&quot;
comma
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_ino
comma
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_size
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (ret) ofs=%Lu&bslash;n&quot;
comma
op_star
id|offs
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (ret) f_pos=%Lu&bslash;n&quot;
comma
id|filp-&gt;f_pos
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (ret) name=%.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|filp-&gt;f_dentry-&gt;d_name.len
comma
id|filp-&gt;f_dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (ret) i_binary(sb)=%d&bslash;n&quot;
comma
id|MSDOS_I
c_func
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
op_member_access_from_pointer
id|i_binary
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (ret) f_count=%d, f_flags=%d&bslash;n&quot;
comma
id|filp-&gt;f_count
comma
id|filp-&gt;f_flags
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (ret) f_owner=%d&bslash;n&quot;
comma
id|filp-&gt;f_owner.uid
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (ret) f_version=%ld&bslash;n&quot;
comma
id|filp-&gt;f_version
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (ret) f_reada=%ld, f_ramax=%ld, f_raend=%ld, f_ralen=%ld, f_rawin=%ld&bslash;n&quot;
comma
id|filp-&gt;f_reada
comma
id|filp-&gt;f_ramax
comma
id|filp-&gt;f_raend
comma
id|filp-&gt;f_ralen
comma
id|filp-&gt;f_rawin
)paren
)paren
suffix:semicolon
macro_line|#if 0
(brace
r_struct
id|umsdos_dirent
op_star
id|mydirent
op_assign
id|buf
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (DDD) uid=%d&bslash;n&quot;
comma
id|mydirent-&gt;uid
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (DDD) gid=%d&bslash;n&quot;
comma
id|mydirent-&gt;gid
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (DDD) name=&gt;%.20s&lt;&bslash;n&quot;
comma
id|mydirent-&gt;name
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif  
id|set_fs
(paren
id|old_fs
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Write to file from kernel space. &n; *&t;Does the real job, assumes all structures are initialized !&n; */
DECL|function|umsdos_file_write_kmem_real
id|ssize_t
id|umsdos_file_write_kmem_real
(paren
r_struct
id|file
op_star
id|filp
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|offs
)paren
(brace
id|ssize_t
id|ret
suffix:semicolon
id|mm_segment_t
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;umsdos_file_write_kmem /mn/: Checkin: filp=%p, buf=%p, size=%d, offs=%p&bslash;n&quot;
comma
id|filp
comma
id|buf
comma
id|count
comma
id|offs
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;  struct dentry=%p&bslash;n&quot;
comma
id|filp-&gt;f_dentry
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;  struct inode=%p&bslash;n&quot;
comma
id|filp-&gt;f_dentry-&gt;d_inode
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;  inode=%lu, i_size=%lu&bslash;n&quot;
comma
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_ino
comma
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_size
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;  ofs=%ld&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
op_star
id|offs
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;  f_pos=%Lu&bslash;n&quot;
comma
id|filp-&gt;f_pos
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;  name=%.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|filp-&gt;f_dentry-&gt;d_name.len
comma
id|filp-&gt;f_dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;  i_binary(sb)=%d&bslash;n&quot;
comma
id|MSDOS_I
c_func
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
op_member_access_from_pointer
id|i_binary
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;  f_count=%d, f_flags=%d&bslash;n&quot;
comma
id|filp-&gt;f_count
comma
id|filp-&gt;f_flags
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;  f_owner=%d&bslash;n&quot;
comma
id|filp-&gt;f_owner.uid
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;  f_version=%ld&bslash;n&quot;
comma
id|filp-&gt;f_version
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;  f_reada=%ld, f_ramax=%ld, f_raend=%ld, f_ralen=%ld, f_rawin=%ld&bslash;n&quot;
comma
id|filp-&gt;f_reada
comma
id|filp-&gt;f_ramax
comma
id|filp-&gt;f_raend
comma
id|filp-&gt;f_ralen
comma
id|filp-&gt;f_rawin
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|fat_file_write
(paren
id|filp
comma
id|buf
comma
id|count
comma
id|offs
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_ERR
l_string|&quot;fat_file_write returned with %ld!&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
id|set_fs
(paren
id|old_fs
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Write to a file from kernel space&n; */
DECL|function|umsdos_file_write_kmem
id|ssize_t
id|umsdos_file_write_kmem
(paren
r_struct
id|inode
op_star
id|emd_dir
comma
r_struct
id|file
op_star
id|filp
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|offs
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|dentry
op_star
id|old_dentry
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot; STARTED WRITE_KMEM /mn/&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;  using emd=%ld&bslash;n&quot;
comma
id|emd_dir-&gt;i_ino
)paren
)paren
suffix:semicolon
id|old_dentry
op_assign
id|filp-&gt;f_dentry
suffix:semicolon
multiline_comment|/* save it */
id|filp-&gt;f_dentry
op_assign
id|creat_dentry
(paren
id|UMSDOS_EMD_FILE
comma
id|UMSDOS_EMD_NAMELEN
comma
id|emd_dir
)paren
suffix:semicolon
op_star
id|offs
op_assign
id|filp-&gt;f_pos
suffix:semicolon
multiline_comment|/* FIXME, in read_kmem also: offs is not used so why pass it ?!!! /mn/ */
id|ret
op_assign
id|umsdos_file_write_kmem_real
(paren
id|filp
comma
id|buf
comma
id|count
comma
id|offs
)paren
suffix:semicolon
id|filp-&gt;f_pos
op_assign
op_star
id|offs
suffix:semicolon
id|filp-&gt;f_dentry
op_assign
id|old_dentry
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Write a block of bytes into one EMD file.&n;&t;The block of data is NOT in user space.&n;&n;&t;Return 0 if ok, a negative error code if not.&n;*/
DECL|function|umsdos_emd_dir_write
id|ssize_t
id|umsdos_emd_dir_write
(paren
r_struct
id|inode
op_star
id|emd_dir
comma
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
multiline_comment|/* buffer in kernel memory, not in user space */
r_int
id|count
comma
id|loff_t
op_star
id|offs
)paren
(brace
r_int
id|written
suffix:semicolon
id|loff_t
id|myofs
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef __BIG_ENDIAN
r_struct
id|umsdos_dirent
op_star
id|d
op_assign
(paren
r_struct
id|umsdos_dirent
op_star
)paren
id|buf
suffix:semicolon
macro_line|#endif
id|filp-&gt;f_flags
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef __BIG_ENDIAN&t;
id|d-&gt;nlink
op_assign
id|cpu_to_le16
(paren
id|d-&gt;nlink
)paren
suffix:semicolon
id|d-&gt;uid
op_assign
id|cpu_to_le16
(paren
id|d-&gt;uid
)paren
suffix:semicolon
id|d-&gt;gid
op_assign
id|cpu_to_le16
(paren
id|d-&gt;gid
)paren
suffix:semicolon
id|d-&gt;atime
op_assign
id|cpu_to_le32
(paren
id|d-&gt;atime
)paren
suffix:semicolon
id|d-&gt;mtime
op_assign
id|cpu_to_le32
(paren
id|d-&gt;mtime
)paren
suffix:semicolon
id|d-&gt;ctime
op_assign
id|cpu_to_le32
(paren
id|d-&gt;ctime
)paren
suffix:semicolon
id|d-&gt;rdev
op_assign
id|cpu_to_le16
(paren
id|d-&gt;rdev
)paren
suffix:semicolon
id|d-&gt;mode
op_assign
id|cpu_to_le16
(paren
id|d-&gt;mode
)paren
suffix:semicolon
macro_line|#endif&t;
r_if
c_cond
(paren
id|offs
)paren
id|myofs
op_assign
op_star
id|offs
suffix:semicolon
multiline_comment|/* if offs is not NULL, read it */
id|Printk
(paren
(paren
l_string|&quot;umsdos_emd_dir_write /mn/: calling write_kmem with %p, %p, %p, %d, %Ld&bslash;n&quot;
comma
id|emd_dir
comma
id|filp
comma
id|buf
comma
id|count
comma
id|myofs
)paren
)paren
suffix:semicolon
id|written
op_assign
id|umsdos_file_write_kmem
(paren
id|emd_dir
comma
id|filp
comma
id|buf
comma
id|count
comma
op_amp
id|myofs
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_emd_dir_write /mn/: write_kmem returned&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offs
)paren
op_star
id|offs
op_assign
id|myofs
suffix:semicolon
multiline_comment|/* if offs is not NULL, store myofs there */
macro_line|#ifdef __BIG_ENDIAN&t;
id|d-&gt;nlink
op_assign
id|le16_to_cpu
(paren
id|d-&gt;nlink
)paren
suffix:semicolon
id|d-&gt;uid
op_assign
id|le16_to_cpu
(paren
id|d-&gt;uid
)paren
suffix:semicolon
id|d-&gt;gid
op_assign
id|le16_to_cpu
(paren
id|d-&gt;gid
)paren
suffix:semicolon
id|d-&gt;atime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;atime
)paren
suffix:semicolon
id|d-&gt;mtime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;mtime
)paren
suffix:semicolon
id|d-&gt;ctime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;ctime
)paren
suffix:semicolon
id|d-&gt;rdev
op_assign
id|le16_to_cpu
(paren
id|d-&gt;rdev
)paren
suffix:semicolon
id|d-&gt;mode
op_assign
id|le16_to_cpu
(paren
id|d-&gt;mode
)paren
suffix:semicolon
macro_line|#endif&t;
macro_line|#ifdef 1
r_if
c_cond
(paren
id|written
op_ne
id|count
)paren
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;umsdos_emd_dir_write: ERROR: written (%d) != count (%d)&bslash;n&quot;
comma
id|written
comma
id|count
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|written
op_ne
id|count
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Read a block of bytes from one EMD file.&n; *&t;The block of data is NOT in user space.&n; *&t;Return 0 if ok, -EIO if any error.&n; */
DECL|function|umsdos_emd_dir_read
id|ssize_t
id|umsdos_emd_dir_read
(paren
r_struct
id|inode
op_star
id|emd_dir
comma
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
multiline_comment|/* buffer in kernel memory, not in user space */
r_int
id|count
comma
id|loff_t
op_star
id|offs
)paren
(brace
id|loff_t
id|myofs
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|sizeread
suffix:semicolon
macro_line|#ifdef __BIG_ENDIAN
r_struct
id|umsdos_dirent
op_star
id|d
op_assign
(paren
r_struct
id|umsdos_dirent
op_star
)paren
id|buf
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|offs
)paren
id|myofs
op_assign
op_star
id|offs
suffix:semicolon
multiline_comment|/* if offs is not NULL, read it */
id|filp-&gt;f_flags
op_assign
l_int|0
suffix:semicolon
id|sizeread
op_assign
id|umsdos_file_read_kmem
(paren
id|emd_dir
comma
id|filp
comma
id|buf
comma
id|count
comma
op_amp
id|myofs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sizeread
op_ne
id|count
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: problem with EMD file. Can&squot;t read pos = %Ld (%d != %d)&bslash;n&quot;
comma
id|filp-&gt;f_pos
comma
id|sizeread
comma
id|count
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#ifdef __BIG_ENDIAN&t;
id|d-&gt;nlink
op_assign
id|le16_to_cpu
(paren
id|d-&gt;nlink
)paren
suffix:semicolon
id|d-&gt;uid
op_assign
id|le16_to_cpu
(paren
id|d-&gt;uid
)paren
suffix:semicolon
id|d-&gt;gid
op_assign
id|le16_to_cpu
(paren
id|d-&gt;gid
)paren
suffix:semicolon
id|d-&gt;atime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;atime
)paren
suffix:semicolon
id|d-&gt;mtime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;mtime
)paren
suffix:semicolon
id|d-&gt;ctime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;ctime
)paren
suffix:semicolon
id|d-&gt;rdev
op_assign
id|le16_to_cpu
(paren
id|d-&gt;rdev
)paren
suffix:semicolon
id|d-&gt;mode
op_assign
id|le16_to_cpu
(paren
id|d-&gt;mode
)paren
suffix:semicolon
macro_line|#endif&t;
r_if
c_cond
(paren
id|offs
)paren
op_star
id|offs
op_assign
id|myofs
suffix:semicolon
multiline_comment|/* if offs is not NULL, store myofs there */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Locate the EMD file in a directory .&n;&n;&t;Return NULL if error. If ok, dir-&gt;u.umsdos_i.emd_inode &n;*/
DECL|function|umsdos_emd_dir_lookup
r_struct
id|inode
op_star
id|umsdos_emd_dir_lookup
(paren
r_struct
id|inode
op_star
id|dir
comma
r_int
id|creat
)paren
(brace
r_struct
id|inode
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_int
id|res
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;Entering umsdos_emd_dir_lookup&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.i_emd_dir
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
id|iget
(paren
id|dir-&gt;i_sb
comma
id|dir-&gt;u.umsdos_i.i_emd_dir
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_emd_dir_lookup: deja trouve %ld %p&bslash;n&quot;
comma
id|dir-&gt;u.umsdos_i.i_emd_dir
comma
id|ret
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos /mn/: Looking for %.*s -&quot;
comma
id|UMSDOS_EMD_NAMELEN
comma
id|UMSDOS_EMD_FILE
)paren
)paren
suffix:semicolon
id|res
op_assign
id|compat_umsdos_real_lookup
(paren
id|dir
comma
id|UMSDOS_EMD_FILE
comma
id|UMSDOS_EMD_NAMELEN
comma
op_amp
id|ret
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;-returned %d&bslash;n&quot;
comma
id|res
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_INFO
l_string|&quot;emd_dir_lookup &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;Found --linux &quot;
)paren
)paren
suffix:semicolon
id|dir-&gt;u.umsdos_i.i_emd_dir
op_assign
id|ret-&gt;i_ino
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|creat
)paren
(brace
r_int
id|code
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot; * ERROR * /mn/: creat not yet implemented!!!!&quot;
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;avant create &quot;
)paren
)paren
suffix:semicolon
id|dir-&gt;i_count
op_increment
suffix:semicolon
id|code
op_assign
id|compat_msdos_create
(paren
id|dir
comma
id|UMSDOS_EMD_FILE
comma
id|UMSDOS_EMD_NAMELEN
comma
id|S_IFREG
op_or
l_int|0777
comma
op_amp
id|ret
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_WARNING
l_string|&quot;Creat EMD code %d ret %p &quot;
comma
id|code
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
(brace
id|dir-&gt;u.umsdos_i.i_emd_dir
op_assign
id|ret-&gt;i_ino
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;UMSDOS: Can&squot;t create EMD file&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Disable UMSDOS_notify_change() for EMD file */
id|ret-&gt;u.umsdos_i.i_emd_owner
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
)brace
macro_line|#if 0
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_emd_dir_lookup returning %p /mn/&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot; debug : returning ino=%lu&bslash;n&quot;
comma
id|ret-&gt;i_ino
)paren
)paren
suffix:semicolon
macro_line|#endif    
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;creates an EMD file&n;&n;&t;Return NULL if error. If ok, dir-&gt;u.umsdos_i.emd_inode &n;*/
DECL|function|umsdos_emd_dir_create
r_struct
id|inode
op_star
id|umsdos_emd_dir_create
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_struct
id|inode
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.i_emd_dir
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
id|iget
(paren
id|dir-&gt;i_sb
comma
id|dir-&gt;u.umsdos_i.i_emd_dir
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;deja trouve %lu %p&quot;
comma
id|dir-&gt;u.umsdos_i.i_emd_dir
comma
id|ret
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|code
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;avant create &quot;
)paren
)paren
suffix:semicolon
id|dir-&gt;i_count
op_increment
suffix:semicolon
multiline_comment|/*&t;&t;&t;&n;&t;       code = msdos_create (dir,UMSDOS_EMD_FILE,UMSDOS_EMD_NAMELEN&n;&t;       ,S_IFREG|0777,&amp;ret);&n;&t;       &n;&t;       FIXME, I think I need a new dentry here&n;&t;    */
id|code
op_assign
id|compat_msdos_create
(paren
id|dir
comma
id|UMSDOS_EMD_FILE
comma
id|UMSDOS_EMD_NAMELEN
comma
id|S_IFREG
op_or
l_int|0777
comma
op_amp
id|ret
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;Creat EMD code %d ret %p &quot;
comma
id|code
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
(brace
id|dir-&gt;u.umsdos_i.i_emd_dir
op_assign
id|ret-&gt;i_ino
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;UMSDOS: Can&squot;t create EMD file&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Disable UMSDOS_notify_change() for EMD file */
id|ret-&gt;u.umsdos_i.i_emd_owner
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Read an entry from the EMD file.&n;&t;Support variable length record.&n;&t;Return -EIO if error, 0 if ok.&n;*/
DECL|function|umsdos_emd_dir_readentry
r_int
id|umsdos_emd_dir_readentry
(paren
r_struct
id|inode
op_star
id|emd_dir
comma
r_struct
id|file
op_star
id|filp
comma
r_struct
id|umsdos_dirent
op_star
id|entry
)paren
(brace
r_int
id|ret
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_emd_dir_readentry /mn/: entering.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_emd_dir_readentry /mn/: trying to lookup %.*s (ino=%lu) using EMD %lu&bslash;n&quot;
comma
(paren
r_int
)paren
id|filp-&gt;f_dentry-&gt;d_name.len
comma
id|filp-&gt;f_dentry-&gt;d_name.name
comma
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_ino
comma
id|emd_dir-&gt;i_ino
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_emd_dir_read
c_func
(paren
id|emd_dir
comma
id|filp
comma
(paren
r_char
op_star
)paren
id|entry
comma
id|UMSDOS_REC_SIZE
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/* note /mn/: is this wrong? ret is allways 0 or -EIO. but who knows. It used to work this way... */
multiline_comment|/* Variable size record. Maybe, we have to read some more */
r_int
id|recsize
op_assign
id|umsdos_evalrecsize
(paren
id|entry-&gt;name_len
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_emd_dir_readentry /mn/: FIXME if %d &gt; %d?&bslash;n&quot;
comma
id|recsize
comma
id|UMSDOS_REC_SIZE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|recsize
OG
id|UMSDOS_REC_SIZE
)paren
(brace
id|ret
op_assign
id|umsdos_emd_dir_read
c_func
(paren
id|emd_dir
comma
id|filp
comma
(paren
(paren
r_char
op_star
)paren
id|entry
)paren
op_plus
id|UMSDOS_REC_SIZE
comma
id|recsize
op_minus
id|UMSDOS_REC_SIZE
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
id|Printk
(paren
(paren
l_string|&quot;umsdos_emd_dir_readentry /mn/: returning %d.&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Write an entry in the EMD file.&n;&t;Return 0 if ok, -EIO if some error.&n;*/
DECL|function|umsdos_writeentry
r_int
id|umsdos_writeentry
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|inode
op_star
id|emd_dir
comma
r_struct
id|umsdos_info
op_star
id|info
comma
r_int
id|free_entry
)paren
multiline_comment|/* This entry is deleted, so Write all 0&squot;s */
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|dentry
op_star
id|emd_dentry
suffix:semicolon
r_struct
id|file
id|filp
suffix:semicolon
r_struct
id|umsdos_dirent
op_star
id|entry
op_assign
op_amp
id|info-&gt;entry
suffix:semicolon
r_struct
id|umsdos_dirent
id|entry0
suffix:semicolon
id|fill_new_filp
(paren
op_amp
id|filp
comma
l_int|NULL
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_writeentry /mn/: entering...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|emd_dentry
op_assign
id|creat_dentry
(paren
l_string|&quot;wremd_mn&quot;
comma
l_int|8
comma
id|emd_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free_entry
)paren
(brace
multiline_comment|/* #Specification: EMD file / empty entries&n;&t;&t;&t;Unused entry in the EMD file are identify&n;&t;&t;&t;by the name_len field equal to 0. However to&n;&t;&t;&t;help future extension (or bug correction :-( ),&n;&t;&t;&t;empty entries are filled with 0.&n;&t;&t;*/
id|memset
(paren
op_amp
id|entry0
comma
l_int|0
comma
r_sizeof
(paren
id|entry0
)paren
)paren
suffix:semicolon
id|entry
op_assign
op_amp
id|entry0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry-&gt;name_len
OG
l_int|0
)paren
(brace
id|memset
(paren
id|entry-&gt;name
op_plus
id|entry-&gt;name_len
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|entry-&gt;name
)paren
op_minus
id|entry-&gt;name_len
)paren
suffix:semicolon
multiline_comment|/* #Specification: EMD file / spare bytes&n;&t;&t;&t;10 bytes are unused in each record of the EMD. They&n;&t;&t;&t;are set to 0 all the time. So it will be possible&n;&t;&t;&t;to do new stuff and rely on the state of those&n;&t;&t;&t;bytes in old EMD file around.&n;&t;&t;*/
id|memset
(paren
id|entry-&gt;spare
comma
l_int|0
comma
r_sizeof
(paren
id|entry-&gt;spare
)paren
)paren
suffix:semicolon
)brace
id|Printk
(paren
(paren
l_string|&quot;umsdos_writeentry /mn/: if passed...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
id|printk
(paren
id|KERN_ERR
l_string|&quot;umsdosfs: /mn/ info is empty ! ooops...&bslash;n&quot;
)paren
suffix:semicolon
id|filp.f_pos
op_assign
id|info-&gt;f_pos
suffix:semicolon
id|filp.f_reada
op_assign
l_int|0
suffix:semicolon
id|filp.f_flags
op_assign
id|O_RDWR
suffix:semicolon
id|filp.f_dentry
op_assign
id|emd_dentry
suffix:semicolon
id|filp.f_op
op_assign
op_amp
id|umsdos_file_operations
suffix:semicolon
multiline_comment|/* /mn/ - we have to fill it with dummy values so we won&squot;t segfault */
id|ret
op_assign
id|umsdos_emd_dir_write
(paren
id|emd_dir
comma
op_amp
id|filp
comma
(paren
r_char
op_star
)paren
id|entry
comma
id|info-&gt;recsize
comma
l_int|NULL
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;emd_dir_write returned with %d!&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS: problem with EMD file. Can&squot;t write&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|dir-&gt;i_ctime
op_assign
id|dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
multiline_comment|/* dir-&gt;i_dirt = 1; FIXME iput/dput ??? */
)brace
id|Printk
(paren
(paren
l_string|&quot;umsdos_writeentry /mn/: returning %d...&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|CHUNK_SIZE
mdefine_line|#define CHUNK_SIZE (8*UMSDOS_REC_SIZE)
DECL|struct|find_buffer
r_struct
id|find_buffer
(brace
DECL|member|buffer
r_char
id|buffer
(braket
id|CHUNK_SIZE
)braket
suffix:semicolon
DECL|member|pos
r_int
id|pos
suffix:semicolon
multiline_comment|/* read offset in buffer */
DECL|member|size
r_int
id|size
suffix:semicolon
multiline_comment|/* Current size of buffer */
DECL|member|filp
r_struct
id|file
id|filp
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;Fill the read buffer and take care of the byte remaining inside.&n;&t;Unread bytes are simply move to the beginning.&n;&n;&t;Return -ENOENT if EOF, 0 if ok, a negative error code if any problem.&n;*/
DECL|function|umsdos_fillbuf
r_static
r_int
id|umsdos_fillbuf
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|find_buffer
op_star
id|buf
)paren
(brace
r_int
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_int
id|mustmove
op_assign
id|buf-&gt;size
op_minus
id|buf-&gt;pos
suffix:semicolon
r_int
id|mustread
suffix:semicolon
r_int
id|remain
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;Entering umsdos_fillbuf, for inode %lu, buf=%p&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|buf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mustmove
OG
l_int|0
)paren
(brace
id|memcpy
(paren
id|buf-&gt;buffer
comma
id|buf-&gt;buffer
op_plus
id|buf-&gt;pos
comma
id|mustmove
)paren
suffix:semicolon
)brace
id|buf-&gt;pos
op_assign
l_int|0
suffix:semicolon
id|mustread
op_assign
id|CHUNK_SIZE
op_minus
id|mustmove
suffix:semicolon
id|remain
op_assign
id|inode-&gt;i_size
op_minus
id|buf-&gt;filp.f_pos
suffix:semicolon
r_if
c_cond
(paren
id|remain
OL
id|mustread
)paren
id|mustread
op_assign
id|remain
suffix:semicolon
r_if
c_cond
(paren
id|mustread
OG
l_int|0
)paren
(brace
id|ret
op_assign
id|umsdos_emd_dir_read
(paren
id|inode
comma
op_amp
id|buf-&gt;filp
comma
id|buf-&gt;buffer
op_plus
id|mustmove
comma
id|mustread
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|buf-&gt;size
op_assign
id|mustmove
op_plus
id|mustread
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mustmove
)paren
(brace
id|buf-&gt;size
op_assign
id|mustmove
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;General search, locate a name in the EMD file or an empty slot to&n;&t;store it. if info-&gt;entry.name_len == 0, search the first empty&n;&t;slot (of the proper size).&n;&n;&t;Caller must do iput on *pt_emd_dir.&n;&n;&t;Return 0 if found, -ENOENT if not found, another error code if&n;&t;other problem.&n;&n;&t;So this routine is used to either find an existing entry or to&n;&t;create a new one, while making sure it is a new one. After you&n;&t;get -ENOENT, you make sure the entry is stuffed correctly and&n;&t;call umsdos_writeentry().&n;&n;&t;To delete an entry, you find it, zero out the entry (memset)&n;&t;and call umsdos_writeentry().&n;&n;&t;All this to say that umsdos_writeentry must be call after this&n;&t;function since it rely on the f_pos field of info.&n;*/
DECL|function|umsdos_find
r_static
r_int
id|umsdos_find
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|umsdos_info
op_star
id|info
comma
multiline_comment|/* Hold name and name_len */
multiline_comment|/* Will hold the entry found */
r_struct
id|inode
op_star
op_star
id|pt_emd_dir
)paren
multiline_comment|/* Will hold the emd_dir inode */
multiline_comment|/* or NULL if not found */
(brace
multiline_comment|/* #Specification: EMD file structure&n;&t;&t;The EMD file uses a fairly simple layout. It is made of records&n;&t;&t;(UMSDOS_REC_SIZE == 64). When a name can&squot;t be written is a single&n;&t;&t;record, multiple contiguous record are allocated.&n;&t;*/
r_int
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_struct
id|inode
op_star
id|emd_dir
suffix:semicolon
r_struct
id|umsdos_dirent
op_star
id|entry
op_assign
op_amp
id|info-&gt;entry
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_find: locating %.*s in dir %lu&bslash;n&quot;
comma
id|entry-&gt;name_len
comma
id|entry-&gt;name
comma
id|dir-&gt;i_ino
)paren
)paren
suffix:semicolon
id|emd_dir
op_assign
id|umsdos_emd_dir_lookup
(paren
id|dir
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|emd_dir
op_ne
l_int|NULL
)paren
(brace
r_int
id|recsize
op_assign
id|info-&gt;recsize
suffix:semicolon
r_struct
(brace
id|off_t
id|posok
suffix:semicolon
multiline_comment|/* Position available to store the entry */
r_int
id|found
suffix:semicolon
multiline_comment|/* A valid empty position has been found */
id|off_t
id|one
suffix:semicolon
multiline_comment|/* One empty position -&gt; maybe &lt;- large enough */
r_int
id|onesize
suffix:semicolon
multiline_comment|/* size of empty region starting at one */
)brace
id|empty
suffix:semicolon
multiline_comment|/* Read several entries at a time to speed up the search */
r_struct
id|find_buffer
id|buf
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|memset
(paren
op_amp
id|buf.filp
comma
l_int|0
comma
r_sizeof
(paren
id|buf.filp
)paren
)paren
suffix:semicolon
id|dentry
op_assign
id|creat_dentry
(paren
l_string|&quot;umsfind-mn&quot;
comma
l_int|10
comma
id|emd_dir
)paren
suffix:semicolon
id|fill_new_filp
(paren
op_amp
id|buf.filp
comma
id|dentry
)paren
suffix:semicolon
id|buf.pos
op_assign
l_int|0
suffix:semicolon
id|buf.size
op_assign
l_int|0
suffix:semicolon
id|empty.found
op_assign
l_int|0
suffix:semicolon
id|empty.posok
op_assign
id|emd_dir-&gt;i_size
suffix:semicolon
id|empty.onesize
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|umsdos_dirent
op_star
id|rentry
op_assign
(paren
r_struct
id|umsdos_dirent
op_star
)paren
(paren
id|buf.buffer
op_plus
id|buf.pos
)paren
suffix:semicolon
r_int
id|file_pos
op_assign
id|buf.filp.f_pos
op_minus
id|buf.size
op_plus
id|buf.pos
suffix:semicolon
r_if
c_cond
(paren
id|buf.pos
op_eq
id|buf.size
)paren
(brace
id|ret
op_assign
id|umsdos_fillbuf
(paren
id|emd_dir
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
multiline_comment|/* Not found, so note where it can be added */
id|info-&gt;f_pos
op_assign
id|empty.posok
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|rentry-&gt;name_len
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We are looking for an empty section at least */
multiline_comment|/* recsize large */
r_if
c_cond
(paren
id|entry-&gt;name_len
op_eq
l_int|0
)paren
(brace
id|info-&gt;f_pos
op_assign
id|file_pos
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|empty.found
)paren
(brace
r_if
c_cond
(paren
id|empty.onesize
op_eq
l_int|0
)paren
(brace
multiline_comment|/* This is the first empty record of a section */
id|empty.one
op_assign
id|file_pos
suffix:semicolon
)brace
multiline_comment|/* grow the empty section */
id|empty.onesize
op_add_assign
id|UMSDOS_REC_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|empty.onesize
op_eq
id|recsize
)paren
(brace
multiline_comment|/* here is a large enough section */
id|empty.posok
op_assign
id|empty.one
suffix:semicolon
id|empty.found
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|buf.pos
op_add_assign
id|UMSDOS_REC_SIZE
suffix:semicolon
)brace
r_else
(brace
r_int
id|entry_size
op_assign
id|umsdos_evalrecsize
c_func
(paren
id|rentry-&gt;name_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf.pos
op_plus
id|entry_size
OG
id|buf.size
)paren
(brace
id|ret
op_assign
id|umsdos_fillbuf
(paren
id|emd_dir
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
multiline_comment|/* Not found, so note where it can be added */
id|info-&gt;f_pos
op_assign
id|empty.posok
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|empty.onesize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the free slot search */
r_if
c_cond
(paren
id|entry-&gt;name_len
op_eq
id|rentry-&gt;name_len
op_logical_and
id|memcmp
c_func
(paren
id|entry-&gt;name
comma
id|rentry-&gt;name
comma
id|rentry-&gt;name_len
)paren
op_eq
l_int|0
)paren
(brace
id|info-&gt;f_pos
op_assign
id|file_pos
suffix:semicolon
op_star
id|entry
op_assign
op_star
id|rentry
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|buf.pos
op_add_assign
id|entry_size
suffix:semicolon
)brace
)brace
)brace
)brace
id|umsdos_manglename
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
op_star
id|pt_emd_dir
op_assign
id|emd_dir
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_find: returning %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Add a new entry in the emd file&n;&t;Return 0 if ok or a negative error code.&n;&t;Return -EEXIST if the entry already exist.&n;&n;&t;Complete the information missing in info.&n;*/
DECL|function|umsdos_newentry
r_int
id|umsdos_newentry
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|umsdos_info
op_star
id|info
)paren
(brace
r_struct
id|inode
op_star
id|emd_dir
suffix:semicolon
r_int
id|ret
op_assign
id|umsdos_find
(paren
id|dir
comma
id|info
comma
op_amp
id|emd_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EEXIST
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ENOENT
)paren
(brace
id|ret
op_assign
id|umsdos_writeentry
c_func
(paren
id|dir
comma
id|emd_dir
comma
id|info
comma
l_int|0
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_newentry EMD ret = %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
)brace
id|iput
(paren
id|emd_dir
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Create a new hidden link.&n;&t;Return 0 if ok, an error code if not.&n;*/
DECL|function|umsdos_newhidden
r_int
id|umsdos_newhidden
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|umsdos_info
op_star
id|info
)paren
(brace
r_struct
id|inode
op_star
id|emd_dir
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|umsdos_parse
(paren
l_string|&quot;..LINK&quot;
comma
l_int|6
comma
id|info
)paren
suffix:semicolon
id|info-&gt;entry.name_len
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|umsdos_find
(paren
id|dir
comma
id|info
comma
op_amp
id|emd_dir
)paren
suffix:semicolon
id|iput
(paren
id|emd_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ENOENT
op_logical_or
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/* #Specification: hard link / hidden name&n;&t;&t;&t;When a hard link is created, the original file is renamed&n;&t;&t;&t;to a hidden name. The name is &quot;..LINKNNN&quot; where NNN is a&n;&t;&t;&t;number define from the entry offset in the EMD file.&n;&t;&t;*/
id|info-&gt;entry.name_len
op_assign
id|sprintf
(paren
id|info-&gt;entry.name
comma
l_string|&quot;..LINK%ld&quot;
comma
id|info-&gt;f_pos
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Remove an entry from the emd file&n;&t;Return 0 if ok, a negative error code otherwise.&n;&n;&t;Complete the information missing in info.&n;*/
DECL|function|umsdos_delentry
r_int
id|umsdos_delentry
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|umsdos_info
op_star
id|info
comma
r_int
id|isdir
)paren
(brace
r_struct
id|inode
op_star
id|emd_dir
suffix:semicolon
r_int
id|ret
op_assign
id|umsdos_find
(paren
id|dir
comma
id|info
comma
op_amp
id|emd_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;entry.name_len
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|isdir
op_ne
l_int|0
)paren
op_ne
(paren
id|S_ISDIR
c_func
(paren
id|info-&gt;entry.mode
)paren
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|info-&gt;entry.mode
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EISDIR
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
)brace
)brace
r_else
(brace
id|ret
op_assign
id|umsdos_writeentry
c_func
(paren
id|dir
comma
id|emd_dir
comma
id|info
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
id|iput
c_func
(paren
id|emd_dir
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Verify is a EMD directory is empty.&n;&t;Return 0 if not empty&n;&t;&t;   1 if empty&n;&t;&t;   2 if empty, no EMD file.&n;*/
DECL|function|umsdos_isempty
r_int
id|umsdos_isempty
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_int
id|ret
op_assign
l_int|2
suffix:semicolon
r_struct
id|inode
op_star
id|emd_dir
op_assign
id|umsdos_emd_dir_lookup
c_func
(paren
id|dir
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* If the EMD file does not exist, it is certainly empty :-) */
r_if
c_cond
(paren
id|emd_dir
op_ne
l_int|NULL
)paren
(brace
r_struct
id|file
id|filp
suffix:semicolon
id|fill_new_filp
(paren
op_amp
id|filp
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Find an empty slot */
id|memset
(paren
op_amp
id|filp
comma
l_int|0
comma
r_sizeof
(paren
id|filp
)paren
)paren
suffix:semicolon
id|dentry
op_assign
id|creat_dentry
(paren
l_string|&quot;isempty-mn&quot;
comma
l_int|10
comma
id|dir
)paren
suffix:semicolon
id|filp.f_pos
op_assign
l_int|0
suffix:semicolon
id|filp.f_reada
op_assign
l_int|1
suffix:semicolon
id|filp.f_flags
op_assign
id|O_RDONLY
suffix:semicolon
id|filp.f_dentry
op_assign
id|dentry
suffix:semicolon
id|filp.f_op
op_assign
op_amp
id|umsdos_file_operations
suffix:semicolon
multiline_comment|/* /mn/ - we have to fill it with dummy values so we won&squot;t segfault */
id|ret
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|filp.f_pos
OL
id|emd_dir-&gt;i_size
)paren
(brace
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_emd_dir_readentry
c_func
(paren
id|emd_dir
comma
op_amp
id|filp
comma
op_amp
id|entry
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry.name_len
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|iput
(paren
id|emd_dir
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Locate an entry in a EMD directory.&n;&t;Return 0 if ok, errcod if not, generally -ENOENT.&n;*/
DECL|function|umsdos_findentry
r_int
id|umsdos_findentry
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|umsdos_info
op_star
id|info
comma
r_int
id|expect
)paren
multiline_comment|/* 0: anything */
multiline_comment|/* 1: file */
multiline_comment|/* 2: directory */
(brace
r_struct
id|inode
op_star
id|emd_dir
suffix:semicolon
r_int
id|ret
op_assign
id|umsdos_find
(paren
id|dir
comma
id|info
comma
op_amp
id|emd_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|expect
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|info-&gt;entry.mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|expect
op_ne
l_int|2
)paren
id|ret
op_assign
op_minus
id|EISDIR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|expect
op_eq
l_int|2
)paren
(brace
id|ret
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
)brace
)brace
)brace
id|iput
(paren
id|emd_dir
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_findentry: returning %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
