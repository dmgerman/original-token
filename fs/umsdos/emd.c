multiline_comment|/*&n; *  linux/fs/umsdos/emd.c&n; *&n; *  Written 1993 by Jacques Gelinas&n; *&n; *  Extended MS-DOS directory handling functions&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/msdos_fs.h&gt;
macro_line|#include &lt;linux/umsdos_fs.h&gt;
macro_line|#include &lt;linux/dcache.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
multiline_comment|/*&n; *    Read a file into kernel space memory&n; *      returns how many bytes read (from fat_file_read)&n; */
DECL|function|umsdos_file_read_kmem
id|ssize_t
id|umsdos_file_read_kmem
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|ret
suffix:semicolon
id|mm_segment_t
id|old_fs
op_assign
id|get_fs
(paren
)paren
suffix:semicolon
id|set_fs
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_file_read_kmem /mn/: Checkin: filp=%p, buf=%p, size=%d&bslash;n&quot;
comma
id|filp
comma
id|buf
comma
id|count
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  inode=%lu, i_size=%lu&bslash;n&quot;
comma
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_ino
comma
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_size
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  f_pos=%Lu&bslash;n&quot;
comma
id|filp-&gt;f_pos
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  name=%.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|filp-&gt;f_dentry-&gt;d_name.len
comma
id|filp-&gt;f_dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  i_binary(sb)=%d&bslash;n&quot;
comma
id|MSDOS_I
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
op_member_access_from_pointer
id|i_binary
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  f_count=%d, f_flags=%d&bslash;n&quot;
comma
id|filp-&gt;f_count
comma
id|filp-&gt;f_flags
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  f_owner=%d&bslash;n&quot;
comma
id|filp-&gt;f_owner.uid
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  f_version=%ld&bslash;n&quot;
comma
id|filp-&gt;f_version
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  f_reada=%ld, f_ramax=%ld, f_raend=%ld, f_ralen=%ld, f_rawin=%ld&bslash;n&quot;
comma
id|filp-&gt;f_reada
comma
id|filp-&gt;f_ramax
comma
id|filp-&gt;f_raend
comma
id|filp-&gt;f_ralen
comma
id|filp-&gt;f_rawin
)paren
)paren
suffix:semicolon
id|MSDOS_I
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
op_member_access_from_pointer
id|i_binary
op_assign
l_int|2
suffix:semicolon
id|ret
op_assign
id|fat_file_read
(paren
id|filp
comma
id|buf
comma
id|count
comma
op_amp
id|filp-&gt;f_pos
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;fat_file_read returned with %d!&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (ret) inode=%lu, i_size=%lu&bslash;n&quot;
comma
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_ino
comma
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_size
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (ret) f_pos=%Lu&bslash;n&quot;
comma
id|filp-&gt;f_pos
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (ret) name=%.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|filp-&gt;f_dentry-&gt;d_name.len
comma
id|filp-&gt;f_dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (ret) i_binary(sb)=%d&bslash;n&quot;
comma
id|MSDOS_I
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
op_member_access_from_pointer
id|i_binary
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (ret) f_count=%d, f_flags=%d&bslash;n&quot;
comma
id|filp-&gt;f_count
comma
id|filp-&gt;f_flags
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (ret) f_owner=%d&bslash;n&quot;
comma
id|filp-&gt;f_owner.uid
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (ret) f_version=%ld&bslash;n&quot;
comma
id|filp-&gt;f_version
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (ret) f_reada=%ld, f_ramax=%ld, f_raend=%ld, f_ralen=%ld, f_rawin=%ld&bslash;n&quot;
comma
id|filp-&gt;f_reada
comma
id|filp-&gt;f_ramax
comma
id|filp-&gt;f_raend
comma
id|filp-&gt;f_ralen
comma
id|filp-&gt;f_rawin
)paren
)paren
suffix:semicolon
macro_line|#if 0
(brace
r_struct
id|umsdos_dirent
op_star
id|mydirent
op_assign
id|buf
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (DDD) uid=%d&bslash;n&quot;
comma
id|mydirent-&gt;uid
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (DDD) gid=%d&bslash;n&quot;
comma
id|mydirent-&gt;gid
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  (DDD) name=&gt;%.20s&lt;&bslash;n&quot;
comma
id|mydirent-&gt;name
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|set_fs
(paren
id|old_fs
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *    Write to file from kernel space. &n; *      Does the real job, assumes all structures are initialized!&n; */
DECL|function|umsdos_file_write_kmem_real
id|ssize_t
id|umsdos_file_write_kmem_real
(paren
r_struct
id|file
op_star
id|filp
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
id|ssize_t
id|ret
suffix:semicolon
id|mm_segment_t
id|old_fs
op_assign
id|get_fs
(paren
)paren
suffix:semicolon
id|set_fs
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_file_write_kmem /mn/: Checkin: filp=%p, buf=%p, size=%d&bslash;n&quot;
comma
id|filp
comma
id|buf
comma
id|count
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  struct dentry=%p&bslash;n&quot;
comma
id|filp-&gt;f_dentry
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  struct inode=%p&bslash;n&quot;
comma
id|filp-&gt;f_dentry-&gt;d_inode
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  inode=%lu, i_size=%lu&bslash;n&quot;
comma
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_ino
comma
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_size
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  f_pos=%Lu&bslash;n&quot;
comma
id|filp-&gt;f_pos
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  name=%.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|filp-&gt;f_dentry-&gt;d_name.len
comma
id|filp-&gt;f_dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  i_binary(sb)=%d&bslash;n&quot;
comma
id|MSDOS_I
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
op_member_access_from_pointer
id|i_binary
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  f_count=%d, f_flags=%d&bslash;n&quot;
comma
id|filp-&gt;f_count
comma
id|filp-&gt;f_flags
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  f_owner=%d&bslash;n&quot;
comma
id|filp-&gt;f_owner.uid
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  f_version=%ld&bslash;n&quot;
comma
id|filp-&gt;f_version
)paren
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;  f_reada=%ld, f_ramax=%ld, f_raend=%ld, f_ralen=%ld, f_rawin=%ld&bslash;n&quot;
comma
id|filp-&gt;f_reada
comma
id|filp-&gt;f_ramax
comma
id|filp-&gt;f_raend
comma
id|filp-&gt;f_ralen
comma
id|filp-&gt;f_rawin
)paren
)paren
suffix:semicolon
multiline_comment|/* note: i_binary=2 is for CVF-FAT. We put it here, instead of&n;&t; * umsdos_file_write_kmem, since it is also wise not to compress symlinks&n;&t; * (in the unlikely event that they are &gt; 512 bytes and can be compressed &n;&t; * FIXME: should we set it when reading symlinks too? */
id|MSDOS_I
(paren
id|filp-&gt;f_dentry-&gt;d_inode
)paren
op_member_access_from_pointer
id|i_binary
op_assign
l_int|2
suffix:semicolon
id|ret
op_assign
id|fat_file_write
(paren
id|filp
comma
id|buf
comma
id|count
comma
op_amp
id|filp-&gt;f_pos
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;fat_file_write returned with %ld!&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|ret
)paren
)paren
suffix:semicolon
id|set_fs
(paren
id|old_fs
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *    Write to a file from kernel space.&n; */
DECL|function|umsdos_file_write_kmem
id|ssize_t
id|umsdos_file_write_kmem
(paren
r_struct
id|file
op_star
id|filp
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|ret
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot; STARTED WRITE_KMEM /mn/&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_file_write_kmem_real
(paren
id|filp
comma
id|buf
comma
id|count
)paren
suffix:semicolon
macro_line|#warning Should d_drop be here ?
macro_line|#if 0
id|d_drop
(paren
id|filp-&gt;f_dentry
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Write a block of bytes into one EMD file.&n; * The block of data is NOT in user space.&n; * &n; * Return 0 if OK, a negative error code if not.&n; */
DECL|function|umsdos_emd_dir_write
id|ssize_t
id|umsdos_emd_dir_write
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
multiline_comment|/* buffer in kernel memory, not in user space */
r_int
id|count
)paren
(brace
r_int
id|written
suffix:semicolon
macro_line|#ifdef __BIG_ENDIAN
r_struct
id|umsdos_dirent
op_star
id|d
op_assign
(paren
r_struct
id|umsdos_dirent
op_star
)paren
id|buf
suffix:semicolon
id|d-&gt;nlink
op_assign
id|cpu_to_le16
(paren
id|d-&gt;nlink
)paren
suffix:semicolon
id|d-&gt;uid
op_assign
id|cpu_to_le16
(paren
id|d-&gt;uid
)paren
suffix:semicolon
id|d-&gt;gid
op_assign
id|cpu_to_le16
(paren
id|d-&gt;gid
)paren
suffix:semicolon
id|d-&gt;atime
op_assign
id|cpu_to_le32
(paren
id|d-&gt;atime
)paren
suffix:semicolon
id|d-&gt;mtime
op_assign
id|cpu_to_le32
(paren
id|d-&gt;mtime
)paren
suffix:semicolon
id|d-&gt;ctime
op_assign
id|cpu_to_le32
(paren
id|d-&gt;ctime
)paren
suffix:semicolon
id|d-&gt;rdev
op_assign
id|cpu_to_le16
(paren
id|d-&gt;rdev
)paren
suffix:semicolon
id|d-&gt;mode
op_assign
id|cpu_to_le16
(paren
id|d-&gt;mode
)paren
suffix:semicolon
macro_line|#endif
id|filp-&gt;f_flags
op_assign
l_int|0
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_emd_dir_write /mn/: calling write_kmem with %p, %p, %d, %Ld&bslash;n&quot;
comma
id|filp
comma
id|buf
comma
id|count
comma
id|filp-&gt;f_pos
)paren
)paren
suffix:semicolon
id|written
op_assign
id|umsdos_file_write_kmem
(paren
id|filp
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_emd_dir_write /mn/: write_kmem returned&bslash;n&quot;
)paren
)paren
suffix:semicolon
macro_line|#ifdef __BIG_ENDIAN
id|d-&gt;nlink
op_assign
id|le16_to_cpu
(paren
id|d-&gt;nlink
)paren
suffix:semicolon
id|d-&gt;uid
op_assign
id|le16_to_cpu
(paren
id|d-&gt;uid
)paren
suffix:semicolon
id|d-&gt;gid
op_assign
id|le16_to_cpu
(paren
id|d-&gt;gid
)paren
suffix:semicolon
id|d-&gt;atime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;atime
)paren
suffix:semicolon
id|d-&gt;mtime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;mtime
)paren
suffix:semicolon
id|d-&gt;ctime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;ctime
)paren
suffix:semicolon
id|d-&gt;rdev
op_assign
id|le16_to_cpu
(paren
id|d-&gt;rdev
)paren
suffix:semicolon
id|d-&gt;mode
op_assign
id|le16_to_cpu
(paren
id|d-&gt;mode
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if UMS_DEBUG
r_if
c_cond
(paren
id|written
op_ne
id|count
)paren
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;umsdos_emd_dir_write: ERROR: written (%d) != count (%d)&bslash;n&quot;
comma
id|written
comma
id|count
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|written
op_ne
id|count
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *      Read a block of bytes from one EMD file.&n; *      The block of data is NOT in user space.&n; *      Return 0 if OK, -EIO if any error.&n; */
DECL|function|umsdos_emd_dir_read
id|ssize_t
id|umsdos_emd_dir_read
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
multiline_comment|/* buffer in kernel memory, not in user space */
r_int
id|count
)paren
(brace
r_int
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|sizeread
suffix:semicolon
macro_line|#ifdef __BIG_ENDIAN
r_struct
id|umsdos_dirent
op_star
id|d
op_assign
(paren
r_struct
id|umsdos_dirent
op_star
)paren
id|buf
suffix:semicolon
macro_line|#endif
id|filp-&gt;f_flags
op_assign
l_int|0
suffix:semicolon
id|sizeread
op_assign
id|umsdos_file_read_kmem
(paren
id|filp
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sizeread
op_ne
id|count
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS:  problem with EMD file:  can&squot;t read pos = %Ld (%d != %d)&bslash;n&quot;
comma
id|filp-&gt;f_pos
comma
id|sizeread
comma
id|count
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#ifdef __BIG_ENDIAN
id|d-&gt;nlink
op_assign
id|le16_to_cpu
(paren
id|d-&gt;nlink
)paren
suffix:semicolon
id|d-&gt;uid
op_assign
id|le16_to_cpu
(paren
id|d-&gt;uid
)paren
suffix:semicolon
id|d-&gt;gid
op_assign
id|le16_to_cpu
(paren
id|d-&gt;gid
)paren
suffix:semicolon
id|d-&gt;atime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;atime
)paren
suffix:semicolon
id|d-&gt;mtime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;mtime
)paren
suffix:semicolon
id|d-&gt;ctime
op_assign
id|le32_to_cpu
(paren
id|d-&gt;ctime
)paren
suffix:semicolon
id|d-&gt;rdev
op_assign
id|le16_to_cpu
(paren
id|d-&gt;rdev
)paren
suffix:semicolon
id|d-&gt;mode
op_assign
id|le16_to_cpu
(paren
id|d-&gt;mode
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * this checks weather filp points to directory or file,&n; * and if directory, it assumes that it has not yet been&n; * converted to point to EMD_FILE, and fixes it&n; *&n; * calling code should save old filp-&gt;f_dentry, call fix_emd_filp&n; * and if it succeeds (return code 0), do fin_dentry (filp-&gt;f_dentry)&n; * when it is over. It should also restore old filp-&gt;f_dentry.&n; *&n; */
DECL|function|fix_emd_filp
r_int
id|fix_emd_filp
(paren
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|inode
op_star
id|dir
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|inode
op_star
id|emd_dir
suffix:semicolon
multiline_comment|/* is current file (which should be EMD or directory) EMD? */
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.i_emd_owner
op_eq
l_int|0xffffffff
)paren
(brace
id|dget
(paren
id|filp-&gt;f_dentry
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_WARNING
l_string|&quot;&bslash;nfix_emd_filp: EMD already done (should not be !)&bslash;n&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* it is not, we need to make it so */
id|emd_dir
op_assign
id|umsdos_emd_dir_lookup
(paren
id|dir
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|emd_dir
op_eq
l_int|NULL
)paren
(brace
id|Printk
(paren
(paren
id|KERN_ERR
l_string|&quot;&bslash;nfix_emd_filp: EMD not found (should never happen)!!!&bslash;n&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|99
suffix:semicolon
)brace
id|filp-&gt;f_dentry
op_assign
id|creat_dentry
(paren
id|UMSDOS_EMD_FILE
comma
id|UMSDOS_EMD_NAMELEN
comma
id|emd_dir
comma
id|filp-&gt;f_dentry
)paren
suffix:semicolon
multiline_comment|/* filp-&gt;f_dentry is dir containing EMD file, so it IS the parent dentry... */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Locate the EMD file in a directory.&n; * &n; * Return NULL if error, dir-&gt;u.umsdos_i.emd_inode if OK. &n; * caller must iput() returned inode when finished with it!&n; */
DECL|function|umsdos_emd_dir_lookup
r_struct
id|inode
op_star
id|umsdos_emd_dir_lookup
(paren
r_struct
id|inode
op_star
id|dir
comma
r_int
id|creat
)paren
(brace
r_struct
id|inode
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|dentry
op_star
id|d_dir
op_assign
l_int|NULL
comma
op_star
id|dlook
op_assign
l_int|NULL
suffix:semicolon
r_int
id|rv
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;Entering umsdos_emd_dir_lookup&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
id|printk
(paren
id|KERN_CRIT
l_string|&quot;umsdos FATAL: should never happen: dir=NULL!&bslash;n&quot;
)paren
suffix:semicolon
id|check_inode
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.i_emd_dir
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
id|iget
(paren
id|dir-&gt;i_sb
comma
id|dir-&gt;u.umsdos_i.i_emd_dir
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_emd_dir_lookup: deja trouve %ld %p&bslash;n&quot;
comma
id|dir-&gt;u.umsdos_i.i_emd_dir
comma
id|ret
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos /mn/: Looking for %.*s -&quot;
comma
id|UMSDOS_EMD_NAMELEN
comma
id|UMSDOS_EMD_FILE
)paren
)paren
suffix:semicolon
id|d_dir
op_assign
id|geti_dentry
(paren
id|dir
)paren
suffix:semicolon
id|dlook
op_assign
id|creat_dentry
(paren
id|UMSDOS_EMD_FILE
comma
id|UMSDOS_EMD_NAMELEN
comma
l_int|NULL
comma
id|d_dir
)paren
suffix:semicolon
id|rv
op_assign
id|umsdos_real_lookup
(paren
id|dir
comma
id|dlook
)paren
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;-returned %d&bslash;n&quot;
comma
id|rv
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_INFO
l_string|&quot;emd_dir_lookup &quot;
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|dlook-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;Found --linux &quot;
)paren
)paren
suffix:semicolon
id|dir-&gt;u.umsdos_i.i_emd_dir
op_assign
id|ret-&gt;i_ino
suffix:semicolon
id|inc_count
(paren
id|ret
)paren
suffix:semicolon
multiline_comment|/* we&squot;ll need the inode */
id|fin_dentry
(paren
id|dlook
)paren
suffix:semicolon
multiline_comment|/* but not dentry */
id|check_inode
(paren
id|ret
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|creat
)paren
(brace
r_int
id|code
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot; * ERROR * /mn/: creat not yet implemented? not fixed? &quot;
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;avant create &quot;
)paren
)paren
suffix:semicolon
id|inc_count
(paren
id|dir
)paren
suffix:semicolon
id|check_inode
(paren
id|ret
)paren
suffix:semicolon
id|code
op_assign
id|compat_msdos_create
(paren
id|dir
comma
id|UMSDOS_EMD_FILE
comma
id|UMSDOS_EMD_NAMELEN
comma
id|S_IFREG
op_or
l_int|0777
comma
op_amp
id|ret
)paren
suffix:semicolon
id|check_inode
(paren
id|ret
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;Creat EMD code %d ret %p &quot;
comma
id|code
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot; ino=%lu&quot;
comma
id|ret-&gt;i_ino
)paren
)paren
suffix:semicolon
id|dir-&gt;u.umsdos_i.i_emd_dir
op_assign
id|ret-&gt;i_ino
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;UMSDOS: Can&squot;t create EMD file&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Disable UMSDOS_notify_change() for EMD file */
multiline_comment|/* inc_count (ret); // we need to return with incremented inode. FIXME: didn&squot;t umsdos_real_lookup already did that? and compat_msdos_create ? */
id|ret-&gt;u.umsdos_i.i_emd_owner
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
)brace
macro_line|#if UMS_DEBUG
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_emd_dir_lookup returning %p /mn/&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot; returning ino=%lu&bslash;n&quot;
comma
id|ret-&gt;i_ino
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * creates an EMD file&n; * &n; * Return NULL if error, dir-&gt;u.umsdos_i.emd_inode if OK. &n; */
DECL|function|umsdos_emd_dir_create
r_struct
id|inode
op_star
id|umsdos_emd_dir_create
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_struct
id|inode
op_star
id|ret
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.umsdos_i.i_emd_dir
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
id|iget
(paren
id|dir-&gt;i_sb
comma
id|dir-&gt;u.umsdos_i.i_emd_dir
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;deja trouve %lu %p&quot;
comma
id|dir-&gt;u.umsdos_i.i_emd_dir
comma
id|ret
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|code
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;avant create &quot;
)paren
)paren
suffix:semicolon
id|inc_count
(paren
id|dir
)paren
suffix:semicolon
id|code
op_assign
id|compat_msdos_create
(paren
id|dir
comma
id|UMSDOS_EMD_FILE
comma
id|UMSDOS_EMD_NAMELEN
comma
id|S_IFREG
op_or
l_int|0777
comma
op_amp
id|ret
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;Creat EMD code %d ret %p &quot;
comma
id|code
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
(brace
id|dir-&gt;u.umsdos_i.i_emd_dir
op_assign
id|ret-&gt;i_ino
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;UMSDOS: Can&squot;t create EMD file&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ret
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Disable UMSDOS_notify_change() for EMD file */
id|ret-&gt;u.umsdos_i.i_emd_owner
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Read an entry from the EMD file.&n; * Support variable length record.&n; * Return -EIO if error, 0 if OK.&n; *&n; * does not change {d,i}_count&n; */
DECL|function|umsdos_emd_dir_readentry
r_int
id|umsdos_emd_dir_readentry
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|umsdos_dirent
op_star
id|entry
)paren
(brace
r_int
id|ret
suffix:semicolon
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_emd_dir_readentry /mn/: entering.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_emd_dir_readentry /mn/: reading EMD %.*s (ino=%lu) at pos=%d&bslash;n&quot;
comma
(paren
r_int
)paren
id|filp-&gt;f_dentry-&gt;d_name.len
comma
id|filp-&gt;f_dentry-&gt;d_name.name
comma
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_ino
comma
(paren
r_int
)paren
id|filp-&gt;f_pos
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_emd_dir_read
(paren
id|filp
comma
(paren
r_char
op_star
)paren
id|entry
comma
id|UMSDOS_REC_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/* if no error */
multiline_comment|/* Variable size record. Maybe, we have to read some more */
r_int
id|recsize
op_assign
id|umsdos_evalrecsize
(paren
id|entry-&gt;name_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|recsize
OG
id|UMSDOS_REC_SIZE
)paren
(brace
id|Printk
(paren
(paren
id|KERN_DEBUG
l_string|&quot;umsdos_emd_dir_readentry /mn/: %d &gt; %d!&bslash;n&quot;
comma
id|recsize
comma
id|UMSDOS_REC_SIZE
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|umsdos_emd_dir_read
(paren
id|filp
comma
(paren
(paren
r_char
op_star
)paren
id|entry
)paren
op_plus
id|UMSDOS_REC_SIZE
comma
id|recsize
op_minus
id|UMSDOS_REC_SIZE
)paren
suffix:semicolon
)brace
)brace
id|Printk
(paren
(paren
l_string|&quot;umsdos_emd_dir_readentry /mn/: ret=%d.&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_logical_and
id|ret
op_eq
l_int|0
)paren
(brace
id|Printk
(paren
(paren
l_string|&quot;umsdos_emd_dir_readentry /mn/: returning len=%d,name=%.*s&bslash;n&quot;
comma
(paren
r_int
)paren
id|entry-&gt;name_len
comma
(paren
r_int
)paren
id|entry-&gt;name_len
comma
id|entry-&gt;name
)paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Write an entry in the EMD file.&n; * Return 0 if OK, -EIO if some error.&n; */
DECL|function|umsdos_writeentry
r_int
id|umsdos_writeentry
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|inode
op_star
id|emd_dir
comma
r_struct
id|umsdos_info
op_star
id|info
comma
r_int
id|free_entry
)paren
(brace
multiline_comment|/* This entry is deleted, so write all 0&squot;s. */
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|dentry
op_star
id|emd_dentry
suffix:semicolon
r_struct
id|file
id|filp
suffix:semicolon
r_struct
id|umsdos_dirent
op_star
id|entry
op_assign
op_amp
id|info-&gt;entry
suffix:semicolon
r_struct
id|umsdos_dirent
id|entry0
suffix:semicolon
id|fill_new_filp
(paren
op_amp
id|filp
comma
l_int|NULL
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_writeentry /mn/: entering...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|emd_dentry
op_assign
id|geti_dentry
(paren
id|emd_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free_entry
)paren
(brace
multiline_comment|/* #Specification: EMD file / empty entries&n;&t;&t; * Unused entry in the EMD file are identified&n;&t;&t; * by the name_len field equal to 0. However to&n;&t;&t; * help future extension (or bug correction :-( ),&n;&t;&t; * empty entries are filled with 0.&n;&t;&t; */
id|memset
(paren
op_amp
id|entry0
comma
l_int|0
comma
r_sizeof
(paren
id|entry0
)paren
)paren
suffix:semicolon
id|entry
op_assign
op_amp
id|entry0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry-&gt;name_len
OG
l_int|0
)paren
(brace
id|memset
(paren
id|entry-&gt;name
op_plus
id|entry-&gt;name_len
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|entry-&gt;name
)paren
op_minus
id|entry-&gt;name_len
)paren
suffix:semicolon
multiline_comment|/* #Specification: EMD file / spare bytes&n;&t;&t; * 10 bytes are unused in each record of the EMD. They&n;&t;&t; * are set to 0 all the time, so it will be possible&n;&t;&t; * to do new stuff and rely on the state of those&n;&t;&t; * bytes in old EMD files.&n;&t;&t; */
id|memset
(paren
id|entry-&gt;spare
comma
l_int|0
comma
r_sizeof
(paren
id|entry-&gt;spare
)paren
)paren
suffix:semicolon
)brace
id|Printk
(paren
(paren
l_string|&quot;umsdos_writeentry /mn/: if passed...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
id|printk
(paren
id|KERN_ERR
l_string|&quot;UMSDOS:  /mn/ info is empty!  Oops!&bslash;n&quot;
)paren
suffix:semicolon
id|filp.f_pos
op_assign
id|info-&gt;f_pos
suffix:semicolon
id|filp.f_reada
op_assign
l_int|0
suffix:semicolon
id|filp.f_flags
op_assign
id|O_RDWR
suffix:semicolon
id|filp.f_dentry
op_assign
id|emd_dentry
suffix:semicolon
id|filp.f_op
op_assign
op_amp
id|umsdos_file_operations
suffix:semicolon
multiline_comment|/* /mn/ - We have to fill it with dummy values so we won&squot;t segfault. */
id|ret
op_assign
id|umsdos_emd_dir_write
(paren
op_amp
id|filp
comma
(paren
r_char
op_star
)paren
id|entry
comma
id|info-&gt;recsize
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;emd_dir_write returned with %d!&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;UMSDOS:  problem with EMD file:  can&squot;t write&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|dir-&gt;i_ctime
op_assign
id|dir-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
multiline_comment|/* dir-&gt;i_dirt = 1; FIXME iput/dput ??? */
)brace
id|Printk
(paren
(paren
l_string|&quot;umsdos_writeentry /mn/: returning %d...&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|macro|CHUNK_SIZE
mdefine_line|#define CHUNK_SIZE (8*UMSDOS_REC_SIZE)
DECL|struct|find_buffer
r_struct
id|find_buffer
(brace
DECL|member|buffer
r_char
id|buffer
(braket
id|CHUNK_SIZE
)braket
suffix:semicolon
DECL|member|pos
r_int
id|pos
suffix:semicolon
multiline_comment|/* read offset in buffer */
DECL|member|size
r_int
id|size
suffix:semicolon
multiline_comment|/* Current size of buffer */
DECL|member|filp
r_struct
id|file
id|filp
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Fill the read buffer and take care of the byte remaining inside.&n; * Unread bytes are simply move to the beginning.&n; * &n; * Return -ENOENT if EOF, 0 if OK, a negative error code if any problem.&n; */
DECL|function|umsdos_fillbuf
r_static
r_int
id|umsdos_fillbuf
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|find_buffer
op_star
id|buf
)paren
(brace
r_int
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_int
id|mustmove
op_assign
id|buf-&gt;size
op_minus
id|buf-&gt;pos
suffix:semicolon
r_int
id|mustread
suffix:semicolon
r_int
id|remain
suffix:semicolon
r_struct
id|inode
op_star
id|old_ino
suffix:semicolon
id|PRINTK
(paren
(paren
id|KERN_DEBUG
l_string|&quot;Entering umsdos_fillbuf, for inode %lu, buf=%p&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|buf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mustmove
OG
l_int|0
)paren
(brace
id|memcpy
(paren
id|buf-&gt;buffer
comma
id|buf-&gt;buffer
op_plus
id|buf-&gt;pos
comma
id|mustmove
)paren
suffix:semicolon
)brace
id|buf-&gt;pos
op_assign
l_int|0
suffix:semicolon
id|mustread
op_assign
id|CHUNK_SIZE
op_minus
id|mustmove
suffix:semicolon
id|remain
op_assign
id|inode-&gt;i_size
op_minus
id|buf-&gt;filp.f_pos
suffix:semicolon
r_if
c_cond
(paren
id|remain
OL
id|mustread
)paren
id|mustread
op_assign
id|remain
suffix:semicolon
r_if
c_cond
(paren
id|mustread
OG
l_int|0
)paren
(brace
id|old_ino
op_assign
id|buf-&gt;filp.f_dentry-&gt;d_inode
suffix:semicolon
multiline_comment|/* FIXME: do we need to save/restore it ? */
id|buf-&gt;filp.f_dentry-&gt;d_inode
op_assign
id|inode
suffix:semicolon
id|ret
op_assign
id|umsdos_emd_dir_read
(paren
op_amp
id|buf-&gt;filp
comma
id|buf-&gt;buffer
op_plus
id|mustmove
comma
id|mustread
)paren
suffix:semicolon
id|buf-&gt;filp.f_dentry-&gt;d_inode
op_assign
id|old_ino
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|buf-&gt;size
op_assign
id|mustmove
op_plus
id|mustread
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mustmove
)paren
(brace
id|buf-&gt;size
op_assign
id|mustmove
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * General search, locate a name in the EMD file or an empty slot to&n; * store it. if info-&gt;entry.name_len == 0, search the first empty&n; * slot (of the proper size).&n; * &n; * Caller must do iput on *pt_emd_dir.&n; * &n; * Return 0 if found, -ENOENT if not found, another error code if&n; * other problem.&n; * &n; * So this routine is used to either find an existing entry or to&n; * create a new one, while making sure it is a new one. After you&n; * get -ENOENT, you make sure the entry is stuffed correctly and&n; * call umsdos_writeentry().&n; * &n; * To delete an entry, you find it, zero out the entry (memset)&n; * and call umsdos_writeentry().&n; * &n; * All this to say that umsdos_writeentry must be call after this&n; * function since it rely on the f_pos field of info.&n; *&n; * calling code is expected to iput() returned *pt_emd_dir&n; *&n; */
DECL|function|umsdos_find
r_static
r_int
id|umsdos_find
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|umsdos_info
op_star
id|info
comma
multiline_comment|/* Hold name and name_len */
multiline_comment|/* Will hold the entry found */
r_struct
id|inode
op_star
op_star
id|pt_emd_dir
)paren
multiline_comment|/* Will hold the emd_dir inode or NULL if not found */
(brace
multiline_comment|/* #Specification: EMD file structure&n;&t; * The EMD file uses a fairly simple layout.  It is made of records&n;&t; * (UMSDOS_REC_SIZE == 64).  When a name can&squot;t be written in a single&n;&t; * record, multiple contiguous records are allocated.&n;&t; */
r_int
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_struct
id|inode
op_star
id|emd_dir
suffix:semicolon
r_struct
id|umsdos_dirent
op_star
id|entry
op_assign
op_amp
id|info-&gt;entry
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_find: locating %.*s in dir %lu&bslash;n&quot;
comma
id|entry-&gt;name_len
comma
id|entry-&gt;name
comma
id|dir-&gt;i_ino
)paren
)paren
suffix:semicolon
id|check_inode
(paren
id|dir
)paren
suffix:semicolon
id|emd_dir
op_assign
id|umsdos_emd_dir_lookup
(paren
id|dir
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|emd_dir
op_ne
l_int|NULL
)paren
(brace
r_int
id|recsize
op_assign
id|info-&gt;recsize
suffix:semicolon
r_struct
(brace
id|off_t
id|posok
suffix:semicolon
multiline_comment|/* Position available to store the entry */
r_int
id|found
suffix:semicolon
multiline_comment|/* A valid empty position has been found. */
id|off_t
id|one
suffix:semicolon
multiline_comment|/* One empty position -&gt; maybe &lt;- large enough */
r_int
id|onesize
suffix:semicolon
multiline_comment|/* size of empty region starting at one */
)brace
id|empty
suffix:semicolon
multiline_comment|/* Read several entries at a time to speed up the search. */
r_struct
id|find_buffer
id|buf
suffix:semicolon
r_struct
id|dentry
op_star
id|demd
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_find: check emd_dir...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|check_inode
(paren
id|emd_dir
)paren
suffix:semicolon
macro_line|#if 0&t;&t;/* FIXME! not needed. but there are count wraps. somewhere before umsdos_find there should be inc_count/iput pair around umsdos_find call.... */
id|inc_count
(paren
id|emd_dir
)paren
suffix:semicolon
multiline_comment|/* since we are going to fin_dentry, and need emd_dir afterwards -- caling code will iput() it */
macro_line|#endif&t;&t;
id|demd
op_assign
id|geti_dentry
(paren
id|emd_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|demd
)paren
(brace
id|dget
(paren
id|demd
)paren
suffix:semicolon
multiline_comment|/* because we&squot;ll have to dput it */
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * We don&squot;t have dentry alias for this inode. Too bad.&n;&t;&t;&t; * So we&squot;ll fake something (as best as we can).&n;&t;&t;&t; * (maybe we should do it in any case just to keep it simple?)&n;&t;&t;&t; *&n;&t;&t;&t; * Note that this is legal for EMD file, since in some places&n;&t;&t;&t; * we keep inode, but discard dentry (since we would have no way&n;&t;&t;&t; * to discard it later). Yes, this probably should be fixed somehow,&n;&t;&t;&t; * it is just that I don&squot;t have idea how right now, and I&squot;ve spent&n;&t;&t;&t; * quite some time to track it down why it dies here. Maybe new emd_dir_lookup&n;&t;&t;&t; * which returns dentry ? hmmmm... FIXME...&n;&t;&t;&t; *&n;&t;&t;&t; */
id|Printk
(paren
(paren
id|KERN_WARNING
l_string|&quot;umsdos_find: inode has no alias for EMD inode, fake it&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|demd
op_assign
id|creat_dentry
(paren
l_string|&quot;@emd_find@&quot;
comma
l_int|10
comma
id|emd_dir
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|check_dentry_path
(paren
id|demd
comma
l_string|&quot; EMD_DIR_DENTRY umsdos_find&quot;
)paren
suffix:semicolon
id|fill_new_filp
(paren
op_amp
id|buf.filp
comma
id|demd
)paren
suffix:semicolon
id|buf.pos
op_assign
l_int|0
suffix:semicolon
id|buf.size
op_assign
l_int|0
suffix:semicolon
id|empty.found
op_assign
l_int|0
suffix:semicolon
id|empty.posok
op_assign
id|emd_dir-&gt;i_size
suffix:semicolon
id|empty.onesize
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|umsdos_dirent
op_star
id|rentry
op_assign
(paren
r_struct
id|umsdos_dirent
op_star
)paren
(paren
id|buf.buffer
op_plus
id|buf.pos
)paren
suffix:semicolon
r_int
id|file_pos
op_assign
id|buf.filp.f_pos
op_minus
id|buf.size
op_plus
id|buf.pos
suffix:semicolon
r_if
c_cond
(paren
id|buf.pos
op_eq
id|buf.size
)paren
(brace
id|ret
op_assign
id|umsdos_fillbuf
(paren
id|emd_dir
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
multiline_comment|/* Not found, so note where it can be added */
id|info-&gt;f_pos
op_assign
id|empty.posok
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|rentry-&gt;name_len
op_eq
l_int|0
)paren
(brace
multiline_comment|/* We are looking for an empty section at least */
multiline_comment|/* as large as recsize. */
r_if
c_cond
(paren
id|entry-&gt;name_len
op_eq
l_int|0
)paren
(brace
id|info-&gt;f_pos
op_assign
id|file_pos
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|empty.found
)paren
(brace
r_if
c_cond
(paren
id|empty.onesize
op_eq
l_int|0
)paren
(brace
multiline_comment|/* This is the first empty record of a section. */
id|empty.one
op_assign
id|file_pos
suffix:semicolon
)brace
multiline_comment|/* grow the empty section */
id|empty.onesize
op_add_assign
id|UMSDOS_REC_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|empty.onesize
op_eq
id|recsize
)paren
(brace
multiline_comment|/* Here is a large enough section. */
id|empty.posok
op_assign
id|empty.one
suffix:semicolon
id|empty.found
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|buf.pos
op_add_assign
id|UMSDOS_REC_SIZE
suffix:semicolon
)brace
r_else
(brace
r_int
id|entry_size
op_assign
id|umsdos_evalrecsize
(paren
id|rentry-&gt;name_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf.pos
op_plus
id|entry_size
OG
id|buf.size
)paren
(brace
id|ret
op_assign
id|umsdos_fillbuf
(paren
id|emd_dir
comma
op_amp
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
multiline_comment|/* Not found, so note where it can be added */
id|info-&gt;f_pos
op_assign
id|empty.posok
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|empty.onesize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the free slot search. */
r_if
c_cond
(paren
id|entry-&gt;name_len
op_eq
id|rentry-&gt;name_len
op_logical_and
id|memcmp
(paren
id|entry-&gt;name
comma
id|rentry-&gt;name
comma
id|rentry-&gt;name_len
)paren
op_eq
l_int|0
)paren
(brace
id|info-&gt;f_pos
op_assign
id|file_pos
suffix:semicolon
op_star
id|entry
op_assign
op_star
id|rentry
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|buf.pos
op_add_assign
id|entry_size
suffix:semicolon
)brace
)brace
)brace
)brace
id|umsdos_manglename
(paren
id|info
)paren
suffix:semicolon
id|fin_dentry
(paren
id|demd
)paren
suffix:semicolon
)brace
op_star
id|pt_emd_dir
op_assign
id|emd_dir
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_find: returning %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a new entry in the EMD file.&n; * Return 0 if OK or a negative error code.&n; * Return -EEXIST if the entry already exists.&n; * &n; * Complete the information missing in info.&n; */
DECL|function|umsdos_newentry
r_int
id|umsdos_newentry
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|umsdos_info
op_star
id|info
)paren
(brace
r_struct
id|inode
op_star
id|emd_dir
suffix:semicolon
r_int
id|ret
op_assign
id|umsdos_find
(paren
id|dir
comma
id|info
comma
op_amp
id|emd_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EEXIST
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ENOENT
)paren
(brace
id|ret
op_assign
id|umsdos_writeentry
(paren
id|dir
comma
id|emd_dir
comma
id|info
comma
l_int|0
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_writeentry EMD ret = %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
)brace
id|iput
(paren
id|emd_dir
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a new hidden link.&n; * Return 0 if OK, an error code if not.&n; */
DECL|function|umsdos_newhidden
r_int
id|umsdos_newhidden
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|umsdos_info
op_star
id|info
)paren
(brace
r_struct
id|inode
op_star
id|emd_dir
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|umsdos_parse
(paren
l_string|&quot;..LINK&quot;
comma
l_int|6
comma
id|info
)paren
suffix:semicolon
id|info-&gt;entry.name_len
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|umsdos_find
(paren
id|dir
comma
id|info
comma
op_amp
id|emd_dir
)paren
suffix:semicolon
id|iput
(paren
id|emd_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|ENOENT
op_logical_or
id|ret
op_eq
l_int|0
)paren
(brace
multiline_comment|/* #Specification: hard link / hidden name&n;&t;&t; * When a hard link is created, the original file is renamed&n;&t;&t; * to a hidden name. The name is &quot;..LINKNNN&quot; where NNN is a&n;&t;&t; * number define from the entry offset in the EMD file.&n;&t;&t; */
id|info-&gt;entry.name_len
op_assign
id|sprintf
(paren
id|info-&gt;entry.name
comma
l_string|&quot;..LINK%ld&quot;
comma
id|info-&gt;f_pos
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove an entry from the EMD file.&n; * Return 0 if OK, a negative error code otherwise.&n; * &n; * Complete the information missing in info.&n; */
DECL|function|umsdos_delentry
r_int
id|umsdos_delentry
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|umsdos_info
op_star
id|info
comma
r_int
id|isdir
)paren
(brace
r_struct
id|inode
op_star
id|emd_dir
suffix:semicolon
r_int
id|ret
op_assign
id|umsdos_find
(paren
id|dir
comma
id|info
comma
op_amp
id|emd_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;entry.name_len
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|isdir
op_ne
l_int|0
)paren
op_ne
(paren
id|S_ISDIR
(paren
id|info-&gt;entry.mode
)paren
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|info-&gt;entry.mode
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EISDIR
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
)brace
)brace
r_else
(brace
id|ret
op_assign
id|umsdos_writeentry
(paren
id|dir
comma
id|emd_dir
comma
id|info
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
id|iput
(paren
id|emd_dir
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Verify that a EMD directory is empty. Return &n; * 0 if not empty,&n; * 1 if empty,&n; * 2 if empty or no EMD file.&n; */
DECL|function|umsdos_isempty
r_int
id|umsdos_isempty
(paren
r_struct
id|inode
op_star
id|dir
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
comma
op_star
id|d_dir
suffix:semicolon
r_int
id|ret
op_assign
l_int|2
suffix:semicolon
r_struct
id|inode
op_star
id|emd_dir
op_assign
id|umsdos_emd_dir_lookup
(paren
id|dir
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* If the EMD file does not exist, it is certainly empty. :-) */
r_if
c_cond
(paren
id|emd_dir
op_ne
l_int|NULL
)paren
(brace
r_struct
id|file
id|filp
suffix:semicolon
id|d_dir
op_assign
id|geti_dentry
(paren
id|dir
)paren
suffix:semicolon
id|dentry
op_assign
id|creat_dentry
(paren
id|UMSDOS_EMD_FILE
comma
id|UMSDOS_EMD_NAMELEN
comma
id|emd_dir
comma
id|d_dir
)paren
suffix:semicolon
id|check_dentry_path
(paren
id|dentry
comma
l_string|&quot;umsdos_isempty BEGIN&quot;
)paren
suffix:semicolon
id|fill_new_filp
(paren
op_amp
id|filp
comma
id|dentry
)paren
suffix:semicolon
id|filp.f_pos
op_assign
l_int|0
suffix:semicolon
id|filp.f_flags
op_assign
id|O_RDONLY
suffix:semicolon
id|ret
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|filp.f_pos
OL
id|emd_dir-&gt;i_size
)paren
(brace
r_struct
id|umsdos_dirent
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|umsdos_emd_dir_readentry
(paren
op_amp
id|filp
comma
op_amp
id|entry
)paren
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry.name_len
op_ne
l_int|0
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|fin_dentry
(paren
id|dentry
)paren
suffix:semicolon
id|check_dentry_path
(paren
id|dentry
comma
l_string|&quot;umsdos_isempty END&quot;
)paren
suffix:semicolon
id|iput
(paren
id|emd_dir
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Locate an entry in a EMD directory.&n; * Return 0 if OK, error code if not, generally -ENOENT.&n; *&n; * does not change i_count&n; */
DECL|function|umsdos_findentry
r_int
id|umsdos_findentry
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|umsdos_info
op_star
id|info
comma
r_int
id|expect
)paren
multiline_comment|/* 0: anything */
multiline_comment|/* 1: file */
multiline_comment|/* 2: directory */
(brace
r_struct
id|inode
op_star
id|emd_dir
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
op_assign
id|umsdos_find
(paren
id|dir
comma
id|info
comma
op_amp
id|emd_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|expect
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|info-&gt;entry.mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|expect
op_ne
l_int|2
)paren
id|ret
op_assign
op_minus
id|EISDIR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|expect
op_eq
l_int|2
)paren
(brace
id|ret
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
)brace
)brace
)brace
id|iput
(paren
id|emd_dir
)paren
suffix:semicolon
id|Printk
(paren
(paren
l_string|&quot;umsdos_findentry: returning %d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
