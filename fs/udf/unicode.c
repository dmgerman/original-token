multiline_comment|/*&n; * unicode.c&n; *&n; * PURPOSE&n; *&t;Routines for converting between UTF-8 and OSTA Compressed Unicode.&n; *      Also handles filename mangling&n; *&n; * DESCRIPTION&n; *&t;OSTA Compressed Unicode is explained in the OSTA UDF specification.&n; *&t;&t;http://www.osta.org/&n; *&t;UTF-8 is explained in the IETF RFC XXXX.&n; *&t;&t;ftp://ftp.internic.net/rfc/rfcxxxx.txt&n; *&n; * CONTACTS&n; *&t;E-mail regarding any portion of the Linux UDF file system should be&n; *&t;directed to the development team&squot;s mailing list (run by majordomo):&n; *&t;&t;linux_udf@hootie.lvld.hp.com&n; *&n; * COPYRIGHT&n; *&t;This file is distributed under the terms of the GNU General Public&n; *&t;License (GPL). Copies of the GPL can be obtained from:&n; *&t;&t;ftp://prep.ai.mit.edu/pub/gnu/GPL&n; *&t;Each contributing author retains all rights to their own work.&n; */
macro_line|#ifdef __KERNEL__
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;&t;/* for memset */
macro_line|#include &lt;linux/udf_fs.h&gt;
macro_line|#else
macro_line|#include &lt;string.h&gt;
macro_line|#endif
macro_line|#include &quot;udfdecl.h&quot;
DECL|function|udf_ustr_to_dchars
r_int
id|udf_ustr_to_dchars
c_func
(paren
id|Uint8
op_star
id|dest
comma
r_const
r_struct
id|ustr
op_star
id|src
comma
r_int
id|strlen
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|dest
)paren
op_logical_or
(paren
op_logical_neg
id|src
)paren
op_logical_or
(paren
op_logical_neg
id|strlen
)paren
op_logical_or
(paren
id|src-&gt;u_len
OG
id|strlen
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
id|dest
op_plus
l_int|1
comma
id|src-&gt;u_name
comma
id|src-&gt;u_len
)paren
suffix:semicolon
id|dest
(braket
l_int|0
)braket
op_assign
id|src-&gt;u_cmpID
suffix:semicolon
r_return
id|src-&gt;u_len
op_plus
l_int|1
suffix:semicolon
)brace
DECL|function|udf_ustr_to_char
r_int
id|udf_ustr_to_char
c_func
(paren
id|Uint8
op_star
id|dest
comma
r_const
r_struct
id|ustr
op_star
id|src
comma
r_int
id|strlen
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|dest
)paren
op_logical_or
(paren
op_logical_neg
id|src
)paren
op_logical_or
(paren
op_logical_neg
id|strlen
)paren
op_logical_or
(paren
id|src-&gt;u_len
op_ge
id|strlen
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
id|dest
comma
id|src-&gt;u_name
comma
id|src-&gt;u_len
)paren
suffix:semicolon
r_return
id|src-&gt;u_len
suffix:semicolon
)brace
DECL|function|udf_ustr_to_dstring
r_int
id|udf_ustr_to_dstring
c_func
(paren
id|dstring
op_star
id|dest
comma
r_const
r_struct
id|ustr
op_star
id|src
comma
r_int
id|dlength
)paren
(brace
r_if
c_cond
(paren
id|udf_ustr_to_dchars
c_func
(paren
id|dest
comma
id|src
comma
id|dlength
op_minus
l_int|1
)paren
)paren
(brace
id|dest
(braket
id|dlength
op_minus
l_int|1
)braket
op_assign
id|src-&gt;u_len
op_plus
l_int|1
suffix:semicolon
r_return
id|dlength
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|udf_dchars_to_ustr
r_int
id|udf_dchars_to_ustr
c_func
(paren
r_struct
id|ustr
op_star
id|dest
comma
r_const
id|Uint8
op_star
id|src
comma
r_int
id|strlen
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|dest
)paren
op_logical_or
(paren
op_logical_neg
id|src
)paren
op_logical_or
(paren
op_logical_neg
id|strlen
)paren
op_logical_or
(paren
id|strlen
OG
id|UDF_NAME_LEN
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|dest
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ustr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dest-&gt;u_name
comma
id|src
op_plus
l_int|1
comma
id|strlen
op_minus
l_int|1
)paren
suffix:semicolon
id|dest-&gt;u_cmpID
op_assign
id|src
(braket
l_int|0
)braket
suffix:semicolon
id|dest-&gt;u_len
op_assign
id|strlen
op_minus
l_int|1
suffix:semicolon
r_return
id|strlen
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|udf_char_to_ustr
r_int
id|udf_char_to_ustr
c_func
(paren
r_struct
id|ustr
op_star
id|dest
comma
r_const
id|Uint8
op_star
id|src
comma
r_int
id|strlen
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|dest
)paren
op_logical_or
(paren
op_logical_neg
id|src
)paren
op_logical_or
(paren
op_logical_neg
id|strlen
)paren
op_logical_or
(paren
id|strlen
op_ge
id|UDF_NAME_LEN
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|dest
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ustr
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dest-&gt;u_name
comma
id|src
comma
id|strlen
)paren
suffix:semicolon
id|dest-&gt;u_cmpID
op_assign
l_int|0x08
suffix:semicolon
id|dest-&gt;u_len
op_assign
id|strlen
suffix:semicolon
r_return
id|strlen
suffix:semicolon
)brace
DECL|function|udf_dstring_to_ustr
r_int
id|udf_dstring_to_ustr
c_func
(paren
r_struct
id|ustr
op_star
id|dest
comma
r_const
id|dstring
op_star
id|src
comma
r_int
id|dlength
)paren
(brace
r_if
c_cond
(paren
id|dlength
op_logical_and
id|udf_dchars_to_ustr
c_func
(paren
id|dest
comma
id|src
comma
id|src
(braket
id|dlength
op_minus
l_int|1
)braket
)paren
)paren
r_return
id|dlength
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * udf_build_ustr&n; */
DECL|function|udf_build_ustr
r_int
id|udf_build_ustr
c_func
(paren
r_struct
id|ustr
op_star
id|dest
comma
id|dstring
op_star
id|ptr
comma
r_int
id|size
)paren
(brace
r_int
id|usesize
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|dest
)paren
op_logical_or
(paren
op_logical_neg
id|ptr
)paren
op_logical_or
(paren
op_logical_neg
id|size
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|dest
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ustr
)paren
)paren
suffix:semicolon
id|usesize
op_assign
(paren
id|size
OG
id|UDF_NAME_LEN
)paren
ques
c_cond
id|UDF_NAME_LEN
suffix:colon
id|size
suffix:semicolon
id|dest-&gt;u_cmpID
op_assign
id|ptr
(braket
l_int|0
)braket
suffix:semicolon
id|dest-&gt;u_len
op_assign
id|ptr
(braket
id|size
op_minus
l_int|1
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|dest-&gt;u_name
comma
id|ptr
op_plus
l_int|1
comma
id|usesize
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * udf_build_ustr_exact&n; */
DECL|function|udf_build_ustr_exact
r_int
id|udf_build_ustr_exact
c_func
(paren
r_struct
id|ustr
op_star
id|dest
comma
id|dstring
op_star
id|ptr
comma
r_int
id|exactsize
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|dest
)paren
op_logical_or
(paren
op_logical_neg
id|ptr
)paren
op_logical_or
(paren
op_logical_neg
id|exactsize
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|dest
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ustr
)paren
)paren
suffix:semicolon
id|dest-&gt;u_cmpID
op_assign
id|ptr
(braket
l_int|0
)braket
suffix:semicolon
id|dest-&gt;u_len
op_assign
id|exactsize
op_minus
l_int|1
suffix:semicolon
id|memcpy
c_func
(paren
id|dest-&gt;u_name
comma
id|ptr
op_plus
l_int|1
comma
id|exactsize
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * udf_ocu_to_udf8&n; *&n; * PURPOSE&n; *&t;Convert OSTA Compressed Unicode to the UTF-8 equivalent.&n; *&n; * DESCRIPTION&n; *&t;This routine is only called by udf_filldir().&n; *&n; * PRE-CONDITIONS&n; *&t;utf&t;&t;&t;Pointer to UTF-8 output buffer.&n; *&t;ocu&t;&t;&t;Pointer to OSTA Compressed Unicode input buffer&n; *&t;&t;&t;&t;of size UDF_NAME_LEN bytes.&n; * &t;&t;&t;&t;both of type &quot;struct ustr *&quot;&n; *&n; * POST-CONDITIONS&n; *&t;&lt;return&gt;&t;&t;Zero on success.&n; *&n; * HISTORY&n; *&t;November 12, 1997 - Andrew E. Mileski&n; *&t;Written, tested, and released.&n; */
DECL|function|udf_CS0toUTF8
r_int
id|udf_CS0toUTF8
c_func
(paren
r_struct
id|ustr
op_star
id|utf_o
comma
r_struct
id|ustr
op_star
id|ocu_i
)paren
(brace
id|Uint8
op_star
id|ocu
suffix:semicolon
id|Uint32
id|c
suffix:semicolon
id|Uint8
id|cmp_id
comma
id|ocu_len
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ocu
op_assign
id|ocu_i-&gt;u_name
suffix:semicolon
id|ocu_len
op_assign
id|ocu_i-&gt;u_len
suffix:semicolon
id|cmp_id
op_assign
id|ocu_i-&gt;u_cmpID
suffix:semicolon
id|utf_o-&gt;u_len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ocu_len
op_eq
l_int|0
)paren
(brace
id|memset
c_func
(paren
id|utf_o
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|ustr
)paren
)paren
suffix:semicolon
id|utf_o-&gt;u_cmpID
op_assign
l_int|0
suffix:semicolon
id|utf_o-&gt;u_len
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cmp_id
op_ne
l_int|8
)paren
op_logical_and
(paren
id|cmp_id
op_ne
l_int|16
)paren
)paren
(brace
macro_line|#ifdef __KERNEL__
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;udf: unknown compression code (%d) stri=%s&bslash;n&quot;
comma
id|cmp_id
comma
id|ocu_i-&gt;u_name
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|ocu_len
)paren
op_logical_and
(paren
id|utf_o-&gt;u_len
op_le
(paren
id|UDF_NAME_LEN
op_minus
l_int|3
)paren
)paren
suffix:semicolon
)paren
(brace
multiline_comment|/* Expand OSTA compressed Unicode to Unicode */
id|c
op_assign
id|ocu
(braket
id|i
op_increment
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cmp_id
op_eq
l_int|16
)paren
id|c
op_assign
(paren
id|c
op_lshift
l_int|8
)paren
op_or
id|ocu
(braket
id|i
op_increment
)braket
suffix:semicolon
multiline_comment|/* Compress Unicode to UTF-8 */
r_if
c_cond
(paren
id|c
OL
l_int|0x80U
)paren
id|utf_o-&gt;u_name
(braket
id|utf_o-&gt;u_len
op_increment
)braket
op_assign
(paren
id|Uint8
)paren
id|c
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
OL
l_int|0x800U
)paren
(brace
id|utf_o-&gt;u_name
(braket
id|utf_o-&gt;u_len
op_increment
)braket
op_assign
(paren
id|Uint8
)paren
(paren
l_int|0xc0
op_or
(paren
id|c
op_rshift
l_int|6
)paren
)paren
suffix:semicolon
id|utf_o-&gt;u_name
(braket
id|utf_o-&gt;u_len
op_increment
)braket
op_assign
(paren
id|Uint8
)paren
(paren
l_int|0x80
op_or
(paren
id|c
op_amp
l_int|0x3f
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|utf_o-&gt;u_name
(braket
id|utf_o-&gt;u_len
op_increment
)braket
op_assign
(paren
id|Uint8
)paren
(paren
l_int|0xe0
op_or
(paren
id|c
op_rshift
l_int|12
)paren
)paren
suffix:semicolon
id|utf_o-&gt;u_name
(braket
id|utf_o-&gt;u_len
op_increment
)braket
op_assign
(paren
id|Uint8
)paren
(paren
l_int|0x80
op_or
(paren
(paren
id|c
op_rshift
l_int|6
)paren
op_amp
l_int|0x3f
)paren
)paren
suffix:semicolon
id|utf_o-&gt;u_name
(braket
id|utf_o-&gt;u_len
op_increment
)braket
op_assign
(paren
id|Uint8
)paren
(paren
l_int|0x80
op_or
(paren
id|c
op_amp
l_int|0x3f
)paren
)paren
suffix:semicolon
)brace
)brace
id|utf_o-&gt;u_cmpID
op_assign
l_int|8
suffix:semicolon
id|utf_o-&gt;u_hash
op_assign
l_int|0L
suffix:semicolon
id|utf_o-&gt;padding
op_assign
l_int|0
suffix:semicolon
r_return
id|utf_o-&gt;u_len
suffix:semicolon
)brace
multiline_comment|/*&n; *&n; * udf_utf8_to_ocu&n; *&n; * PURPOSE&n; *&t;Convert UTF-8 to the OSTA Compressed Unicode equivalent.&n; *&n; * DESCRIPTION&n; *&t;This routine is only called by udf_lookup().&n; *&n; * PRE-CONDITIONS&n; *&t;ocu&t;&t;&t;Pointer to OSTA Compressed Unicode output&n; *&t;&t;&t;&t;buffer of size UDF_NAME_LEN bytes.&n; *&t;utf&t;&t;&t;Pointer to UTF-8 input buffer.&n; *&t;utf_len&t;&t;&t;Length of UTF-8 input buffer in bytes.&n; *&n; * POST-CONDITIONS&n; *&t;&lt;return&gt;&t;&t;Zero on success.&n; *&n; * HISTORY&n; *&t;November 12, 1997 - Andrew E. Mileski&n; *&t;Written, tested, and released.&n; */
DECL|function|udf_UTF8toCS0
r_int
id|udf_UTF8toCS0
c_func
(paren
id|dstring
op_star
id|ocu
comma
r_struct
id|ustr
op_star
id|utf
comma
r_int
id|length
)paren
(brace
r_int
id|c
comma
id|i
comma
id|max_val
comma
id|utf_char
suffix:semicolon
r_int
id|utf_cnt
suffix:semicolon
r_int
id|u_len
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|ocu
comma
l_int|0
comma
r_sizeof
(paren
id|dstring
)paren
op_star
id|length
)paren
suffix:semicolon
id|ocu
(braket
l_int|0
)braket
op_assign
l_int|8
suffix:semicolon
id|max_val
op_assign
l_int|0xffU
suffix:semicolon
id|try_again
suffix:colon
id|utf_char
op_assign
l_int|0U
suffix:semicolon
id|utf_cnt
op_assign
l_int|0U
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0U
suffix:semicolon
id|i
OL
id|utf-&gt;u_len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|c
op_assign
(paren
id|Uint8
)paren
id|utf-&gt;u_name
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Complete a multi-byte UTF-8 character */
r_if
c_cond
(paren
id|utf_cnt
)paren
(brace
id|utf_char
op_assign
(paren
id|utf_char
op_lshift
l_int|6
)paren
op_or
(paren
id|c
op_amp
l_int|0x3fU
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|utf_cnt
)paren
r_continue
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Check for a multi-byte UTF-8 character */
r_if
c_cond
(paren
id|c
op_amp
l_int|0x80U
)paren
(brace
multiline_comment|/* Start a multi-byte UTF-8 character */
r_if
c_cond
(paren
(paren
id|c
op_amp
l_int|0xe0U
)paren
op_eq
l_int|0xc0U
)paren
(brace
id|utf_char
op_assign
id|c
op_amp
l_int|0x1fU
suffix:semicolon
id|utf_cnt
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|c
op_amp
l_int|0xf0U
)paren
op_eq
l_int|0xe0U
)paren
(brace
id|utf_char
op_assign
id|c
op_amp
l_int|0x0fU
suffix:semicolon
id|utf_cnt
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|c
op_amp
l_int|0xf8U
)paren
op_eq
l_int|0xf0U
)paren
(brace
id|utf_char
op_assign
id|c
op_amp
l_int|0x07U
suffix:semicolon
id|utf_cnt
op_assign
l_int|3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|c
op_amp
l_int|0xfcU
)paren
op_eq
l_int|0xf8U
)paren
(brace
id|utf_char
op_assign
id|c
op_amp
l_int|0x03U
suffix:semicolon
id|utf_cnt
op_assign
l_int|4
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|c
op_amp
l_int|0xfeU
)paren
op_eq
l_int|0xfcU
)paren
(brace
id|utf_char
op_assign
id|c
op_amp
l_int|0x01U
suffix:semicolon
id|utf_cnt
op_assign
l_int|5
suffix:semicolon
)brace
r_else
r_goto
id|error_out
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
multiline_comment|/* Single byte UTF-8 character (most common) */
id|utf_char
op_assign
id|c
suffix:semicolon
)brace
multiline_comment|/* Choose no compression if necessary */
r_if
c_cond
(paren
id|utf_char
OG
id|max_val
)paren
(brace
r_if
c_cond
(paren
l_int|0xffU
op_eq
id|max_val
)paren
(brace
id|max_val
op_assign
l_int|0xffffU
suffix:semicolon
id|ocu
(braket
l_int|0
)braket
op_assign
(paren
id|Uint8
)paren
l_int|0x10U
suffix:semicolon
r_goto
id|try_again
suffix:semicolon
)brace
r_goto
id|error_out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|max_val
op_eq
l_int|0xffffU
)paren
(brace
id|ocu
(braket
op_increment
id|u_len
)braket
op_assign
(paren
id|Uint8
)paren
(paren
id|utf_char
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
id|ocu
(braket
op_increment
id|u_len
)braket
op_assign
(paren
id|Uint8
)paren
(paren
id|utf_char
op_amp
l_int|0xffU
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|utf_cnt
)paren
(brace
id|error_out
suffix:colon
macro_line|#ifdef __KERNEL__
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;udf: bad UTF-8 character&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
id|ocu
(braket
id|length
op_minus
l_int|1
)braket
op_assign
(paren
id|Uint8
)paren
id|u_len
op_plus
l_int|1
suffix:semicolon
r_return
id|u_len
op_plus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef __KERNEL__
DECL|function|udf_get_filename
r_int
id|udf_get_filename
c_func
(paren
id|Uint8
op_star
id|sname
comma
id|Uint8
op_star
id|dname
comma
r_int
id|flen
)paren
(brace
r_struct
id|ustr
id|filename
comma
id|unifilename
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|udf_build_ustr_exact
c_func
(paren
op_amp
id|unifilename
comma
id|sname
comma
id|flen
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|udf_CS0toUTF8
c_func
(paren
op_amp
id|filename
comma
op_amp
id|unifilename
)paren
)paren
(brace
id|udf_debug
c_func
(paren
l_string|&quot;Failed in udf_get_filename: sname = %s&bslash;n&quot;
comma
id|sname
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|len
op_assign
id|udf_translate_to_linux
c_func
(paren
id|dname
comma
id|filename.u_name
comma
id|filename.u_len
comma
id|unifilename.u_name
comma
id|unifilename.u_len
)paren
)paren
)paren
(brace
r_return
id|len
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|macro|ILLEGAL_CHAR_MARK
mdefine_line|#define ILLEGAL_CHAR_MARK&t;&squot;_&squot;
DECL|macro|EXT_MARK
mdefine_line|#define EXT_MARK&t;&t;&t;&squot;.&squot;
DECL|macro|CRC_MARK
mdefine_line|#define CRC_MARK&t;&t;&t;&squot;#&squot;
DECL|macro|EXT_SIZE
mdefine_line|#define EXT_SIZE&t;&t;&t;5
DECL|function|udf_translate_to_linux
r_int
id|udf_translate_to_linux
c_func
(paren
id|Uint8
op_star
id|newName
comma
id|Uint8
op_star
id|udfName
comma
r_int
id|udfLen
comma
id|Uint8
op_star
id|fidName
comma
r_int
id|fidNameLen
)paren
(brace
r_int
id|index
comma
id|newIndex
op_assign
l_int|0
comma
id|needsCRC
op_assign
l_int|0
suffix:semicolon
r_int
id|extIndex
op_assign
l_int|0
comma
id|newExtIndex
op_assign
l_int|0
comma
id|hasExt
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|valueCRC
suffix:semicolon
id|Uint8
id|curr
suffix:semicolon
r_const
id|Uint8
id|hexChar
(braket
)braket
op_assign
l_string|&quot;0123456789ABCDEF&quot;
suffix:semicolon
r_if
c_cond
(paren
id|udfName
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
(paren
id|udfLen
op_eq
l_int|1
op_logical_or
(paren
id|udfLen
op_eq
l_int|2
op_logical_and
id|udfName
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
)paren
)paren
(brace
id|needsCRC
op_assign
l_int|1
suffix:semicolon
id|newIndex
op_assign
id|udfLen
suffix:semicolon
id|memcpy
c_func
(paren
id|newName
comma
id|udfName
comma
id|udfLen
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|udfLen
suffix:semicolon
id|index
op_increment
)paren
(brace
id|curr
op_assign
id|udfName
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|curr
op_eq
l_char|&squot;/&squot;
op_logical_or
id|curr
op_eq
l_int|0
)paren
(brace
id|needsCRC
op_assign
l_int|1
suffix:semicolon
id|curr
op_assign
id|ILLEGAL_CHAR_MARK
suffix:semicolon
r_while
c_loop
(paren
id|index
op_plus
l_int|1
OL
id|udfLen
op_logical_and
(paren
id|udfName
(braket
id|index
op_plus
l_int|1
)braket
op_eq
l_char|&squot;/&squot;
op_logical_or
id|udfName
(braket
id|index
op_plus
l_int|1
)braket
op_eq
l_int|0
)paren
)paren
id|index
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|curr
op_eq
id|EXT_MARK
op_logical_and
(paren
id|udfLen
op_minus
id|index
op_minus
l_int|1
)paren
op_le
id|EXT_SIZE
)paren
(brace
r_if
c_cond
(paren
id|udfLen
op_eq
id|index
op_plus
l_int|1
)paren
id|hasExt
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|hasExt
op_assign
l_int|1
suffix:semicolon
id|extIndex
op_assign
id|index
suffix:semicolon
id|newExtIndex
op_assign
id|newIndex
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|newIndex
OL
l_int|256
)paren
id|newName
(braket
id|newIndex
op_increment
)braket
op_assign
id|curr
suffix:semicolon
r_else
id|needsCRC
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|needsCRC
)paren
(brace
id|Uint8
id|ext
(braket
id|EXT_SIZE
)braket
suffix:semicolon
r_int
id|localExtIndex
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hasExt
)paren
(brace
r_int
id|maxFilenameLen
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|EXT_SIZE
op_logical_and
id|extIndex
op_plus
id|index
op_plus
l_int|1
OL
id|udfLen
suffix:semicolon
id|index
op_increment
)paren
(brace
id|curr
op_assign
id|udfName
(braket
id|extIndex
op_plus
id|index
op_plus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|curr
op_eq
l_char|&squot;/&squot;
op_logical_or
id|curr
op_eq
l_int|0
)paren
(brace
id|needsCRC
op_assign
l_int|1
suffix:semicolon
id|curr
op_assign
id|ILLEGAL_CHAR_MARK
suffix:semicolon
r_while
c_loop
(paren
id|extIndex
op_plus
id|index
op_plus
l_int|2
OL
id|udfLen
op_logical_and
(paren
id|index
op_plus
l_int|1
OL
id|EXT_SIZE
op_logical_and
(paren
id|udfName
(braket
id|extIndex
op_plus
id|index
op_plus
l_int|2
)braket
op_eq
l_char|&squot;/&squot;
op_logical_or
id|udfName
(braket
id|extIndex
op_plus
id|index
op_plus
l_int|2
)braket
op_eq
l_int|0
)paren
)paren
)paren
(brace
id|index
op_increment
suffix:semicolon
)brace
)brace
id|ext
(braket
id|localExtIndex
op_increment
)braket
op_assign
id|curr
suffix:semicolon
)brace
id|maxFilenameLen
op_assign
l_int|250
op_minus
id|localExtIndex
suffix:semicolon
r_if
c_cond
(paren
id|newIndex
OG
id|maxFilenameLen
)paren
id|newIndex
op_assign
id|maxFilenameLen
suffix:semicolon
r_else
id|newIndex
op_assign
id|newExtIndex
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|newIndex
OG
l_int|250
)paren
id|newIndex
op_assign
l_int|250
suffix:semicolon
id|newName
(braket
id|newIndex
op_increment
)braket
op_assign
id|CRC_MARK
suffix:semicolon
id|valueCRC
op_assign
id|udf_crc
c_func
(paren
id|fidName
comma
id|fidNameLen
comma
l_int|0
)paren
suffix:semicolon
id|newName
(braket
id|newIndex
op_increment
)braket
op_assign
id|hexChar
(braket
(paren
id|valueCRC
op_amp
l_int|0xf000
)paren
op_rshift
l_int|12
)braket
suffix:semicolon
id|newName
(braket
id|newIndex
op_increment
)braket
op_assign
id|hexChar
(braket
(paren
id|valueCRC
op_amp
l_int|0x0f00
)paren
op_rshift
l_int|8
)braket
suffix:semicolon
id|newName
(braket
id|newIndex
op_increment
)braket
op_assign
id|hexChar
(braket
(paren
id|valueCRC
op_amp
l_int|0x00f0
)paren
op_rshift
l_int|4
)braket
suffix:semicolon
id|newName
(braket
id|newIndex
op_increment
)braket
op_assign
id|hexChar
(braket
(paren
id|valueCRC
op_amp
l_int|0x000f
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hasExt
)paren
(brace
id|newName
(braket
id|newIndex
op_increment
)braket
op_assign
id|EXT_MARK
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|localExtIndex
suffix:semicolon
id|index
op_increment
)paren
id|newName
(braket
id|newIndex
op_increment
)braket
op_assign
id|ext
(braket
id|index
)braket
suffix:semicolon
)brace
)brace
r_return
id|newIndex
suffix:semicolon
)brace
eof
