multiline_comment|/* Copyright (C) 1993, 1994, 1995, 1996, 1997 Free Software Foundation, Inc.&n;   This file is part of the GNU C Library.&n;   Contributed by Paul Eggert (eggert@twinsun.com).&n;&n;   The GNU C Library is free software; you can redistribute it and/or&n;   modify it under the terms of the GNU Library General Public License as&n;   published by the Free Software Foundation; either version 2 of the&n;   License, or (at your option) any later version.&n;&n;   The GNU C Library is distributed in the hope that it will be useful,&n;   but WITHOUT ANY WARRANTY; without even the implied warranty of&n;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n;   Library General Public License for more details.&n;&n;   You should have received a copy of the GNU Library General Public&n;   License along with the GNU C Library; see the file COPYING.LIB.  If not,&n;   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,&n;   Boston, MA 02111-1307, USA.  */
multiline_comment|/*&n; * dgb 10/2/98: ripped this from glibc source to help convert timestamps to unix time &n; *     10/4/98: added new table-based lookup after seeing how ugly the gnu code is&n; */
multiline_comment|/* Assume that leap seconds are possible, unless told otherwise.&n;   If the host has a `zic&squot; command with a `-L leapsecondfilename&squot; option,&n;   then it supports leap seconds; otherwise it probably doesn&squot;t.  */
macro_line|#ifndef LEAP_SECONDS_POSSIBLE
DECL|macro|LEAP_SECONDS_POSSIBLE
mdefine_line|#define LEAP_SECONDS_POSSIBLE 1
macro_line|#endif
macro_line|#if defined(__linux__) &amp;&amp; defined(__KERNEL__)
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#else
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;sys/types.h&gt;
macro_line|#endif
macro_line|#include &quot;udfdecl.h&quot;
macro_line|#ifndef CHAR_BIT
DECL|macro|CHAR_BIT
mdefine_line|#define CHAR_BIT 8
macro_line|#endif
macro_line|#ifndef INT_MIN
DECL|macro|INT_MIN
mdefine_line|#define INT_MIN (~0 &lt;&lt; (sizeof (int) * CHAR_BIT - 1))
macro_line|#endif
macro_line|#ifndef INT_MAX
DECL|macro|INT_MAX
mdefine_line|#define INT_MAX (~0 - INT_MIN)
macro_line|#endif
macro_line|#ifndef TIME_T_MIN
DECL|macro|TIME_T_MIN
mdefine_line|#define TIME_T_MIN (0 &lt; (time_t) -1 ? (time_t) 0 &bslash;&n;&t;&t;    : ~ (time_t) 0 &lt;&lt; (sizeof (time_t) * CHAR_BIT - 1))
macro_line|#endif
macro_line|#ifndef TIME_T_MAX
DECL|macro|TIME_T_MAX
mdefine_line|#define TIME_T_MAX (~ (time_t) 0 - TIME_T_MIN)
macro_line|#endif
DECL|macro|TM_YEAR_BASE
mdefine_line|#define TM_YEAR_BASE 1900
DECL|macro|EPOCH_YEAR
mdefine_line|#define EPOCH_YEAR 1970
macro_line|#ifndef __isleap
multiline_comment|/* Nonzero if YEAR is a leap year (every 4 years,&n;   except every 100th isn&squot;t, and every 400th is).  */
DECL|macro|__isleap
mdefine_line|#define&t;__isleap(year)&t;&bslash;&n;  ((year) % 4 == 0 &amp;&amp; ((year) % 100 != 0 || (year) % 400 == 0))
macro_line|#endif
multiline_comment|/* How many days come before each month (0-12).  */
DECL|variable|__mon_yday
r_const
r_int
r_int
r_int
id|__mon_yday
(braket
l_int|2
)braket
(braket
l_int|13
)braket
op_assign
(brace
multiline_comment|/* Normal years.  */
(brace
l_int|0
comma
l_int|31
comma
l_int|59
comma
l_int|90
comma
l_int|120
comma
l_int|151
comma
l_int|181
comma
l_int|212
comma
l_int|243
comma
l_int|273
comma
l_int|304
comma
l_int|334
comma
l_int|365
)brace
comma
multiline_comment|/* Leap years.  */
(brace
l_int|0
comma
l_int|31
comma
l_int|60
comma
l_int|91
comma
l_int|121
comma
l_int|152
comma
l_int|182
comma
l_int|213
comma
l_int|244
comma
l_int|274
comma
l_int|305
comma
l_int|335
comma
l_int|366
)brace
)brace
suffix:semicolon
id|time_t
id|udf_converttime
(paren
r_struct
id|ktm
op_star
)paren
suffix:semicolon
macro_line|#ifndef USE_GNU_MKTIME_METHOD
DECL|macro|MAX_YEAR_SECONDS
mdefine_line|#define MAX_YEAR_SECONDS&t;68
DECL|variable|year_seconds
id|time_t
id|year_seconds
(braket
id|MAX_YEAR_SECONDS
)braket
op_assign
(brace
l_int|0
comma
multiline_comment|/*1971:*/
l_int|31554000
comma
multiline_comment|/*1972:*/
l_int|63090000
comma
multiline_comment|/*1973:*/
l_int|94712400
comma
multiline_comment|/*1974:*/
l_int|126248400
comma
multiline_comment|/*1975:*/
l_int|157784400
comma
multiline_comment|/*1976:*/
l_int|189320400
comma
multiline_comment|/*1977:*/
l_int|220942800
comma
multiline_comment|/*1978:*/
l_int|252478800
comma
multiline_comment|/*1979:*/
l_int|284014800
comma
multiline_comment|/*1980:*/
l_int|315550800
comma
multiline_comment|/*1981:*/
l_int|347173200
comma
multiline_comment|/*1982:*/
l_int|378709200
comma
multiline_comment|/*1983:*/
l_int|410245200
comma
multiline_comment|/*1984:*/
l_int|441781200
comma
multiline_comment|/*1985:*/
l_int|473403600
comma
multiline_comment|/*1986:*/
l_int|504939600
comma
multiline_comment|/*1987:*/
l_int|536475600
comma
multiline_comment|/*1988:*/
l_int|568011600
comma
multiline_comment|/*1989:*/
l_int|599634000
comma
multiline_comment|/*1990:*/
l_int|631170000
comma
multiline_comment|/*1991:*/
l_int|662706000
comma
multiline_comment|/*1992:*/
l_int|694242000
comma
multiline_comment|/*1993:*/
l_int|725864400
comma
multiline_comment|/*1994:*/
l_int|757400400
comma
multiline_comment|/*1995:*/
l_int|788936400
comma
multiline_comment|/*1996:*/
l_int|820472400
comma
multiline_comment|/*1997:*/
l_int|852094800
comma
multiline_comment|/*1998:*/
l_int|883630800
comma
multiline_comment|/*1999:*/
l_int|915166800
comma
multiline_comment|/*2000:*/
l_int|946702800
comma
multiline_comment|/*2001:*/
l_int|978325200
comma
multiline_comment|/*2002:*/
l_int|1009861200
comma
multiline_comment|/*2003:*/
l_int|1041397200
comma
multiline_comment|/*2004:*/
l_int|1072933200
comma
multiline_comment|/*2005:*/
l_int|1104555600
comma
multiline_comment|/*2006:*/
l_int|1136091600
comma
multiline_comment|/*2007:*/
l_int|1167627600
comma
multiline_comment|/*2008:*/
l_int|1199163600
comma
multiline_comment|/*2009:*/
l_int|1230786000
comma
multiline_comment|/*2010:*/
l_int|1262322000
comma
multiline_comment|/*2011:*/
l_int|1293858000
comma
multiline_comment|/*2012:*/
l_int|1325394000
comma
multiline_comment|/*2013:*/
l_int|1357016400
comma
multiline_comment|/*2014:*/
l_int|1388552400
comma
multiline_comment|/*2015:*/
l_int|1420088400
comma
multiline_comment|/*2016:*/
l_int|1451624400
comma
multiline_comment|/*2017:*/
l_int|1483246800
comma
multiline_comment|/*2018:*/
l_int|1514782800
comma
multiline_comment|/*2019:*/
l_int|1546318800
comma
multiline_comment|/*2020:*/
l_int|1577854800
comma
multiline_comment|/*2021:*/
l_int|1609477200
comma
multiline_comment|/*2022:*/
l_int|1641013200
comma
multiline_comment|/*2023:*/
l_int|1672549200
comma
multiline_comment|/*2024:*/
l_int|1704085200
comma
multiline_comment|/*2025:*/
l_int|1735707600
comma
multiline_comment|/*2026:*/
l_int|1767243600
comma
multiline_comment|/*2027:*/
l_int|1798779600
comma
multiline_comment|/*2028:*/
l_int|1830315600
comma
multiline_comment|/*2029:*/
l_int|1861938000
comma
multiline_comment|/*2030:*/
l_int|1893474000
comma
multiline_comment|/*2031:*/
l_int|1925010000
comma
multiline_comment|/*2032:*/
l_int|1956546000
comma
multiline_comment|/*2033:*/
l_int|1988168400
comma
multiline_comment|/*2034:*/
l_int|2019704400
comma
multiline_comment|/*2035:*/
l_int|2051240400
comma
multiline_comment|/*2036:*/
l_int|2082776400
comma
multiline_comment|/*2037:*/
l_int|2114398800
)brace
suffix:semicolon
DECL|function|udf_converttime
id|time_t
id|udf_converttime
(paren
r_struct
id|ktm
op_star
id|tm
)paren
(brace
id|time_t
id|r
suffix:semicolon
r_int
id|yday
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tm
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tm-&gt;tm_year
op_plus
id|TM_YEAR_BASE
OL
id|EPOCH_YEAR
)paren
op_logical_or
(paren
id|tm-&gt;tm_year
op_plus
id|TM_YEAR_BASE
OG
id|EPOCH_YEAR
op_plus
id|MAX_YEAR_SECONDS
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|r
op_assign
id|year_seconds
(braket
id|tm-&gt;tm_year
op_minus
l_int|70
)braket
suffix:semicolon
id|yday
op_assign
(paren
(paren
id|__mon_yday
(braket
id|__isleap
(paren
id|tm-&gt;tm_year
op_plus
id|TM_YEAR_BASE
)paren
)braket
(braket
id|tm-&gt;tm_mon
op_minus
l_int|1
)braket
)paren
op_plus
id|tm-&gt;tm_mday
op_minus
l_int|1
)paren
suffix:semicolon
id|r
op_add_assign
(paren
(paren
(paren
id|yday
op_star
l_int|24
)paren
op_plus
(paren
id|tm-&gt;tm_hour
op_minus
l_int|1
)paren
)paren
op_star
l_int|60
op_plus
id|tm-&gt;tm_min
)paren
op_star
l_int|60
op_plus
id|tm-&gt;tm_sec
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
macro_line|#ifdef __KERNEL__
r_extern
r_struct
id|timezone
id|sys_tz
suffix:semicolon
DECL|macro|SECS_PER_HOUR
mdefine_line|#define SECS_PER_HOUR   (60 * 60)
DECL|macro|SECS_PER_DAY
mdefine_line|#define SECS_PER_DAY    (SECS_PER_HOUR * 24)
id|timestamp
op_star
DECL|function|udf_time_to_stamp
id|udf_time_to_stamp
c_func
(paren
id|timestamp
op_star
id|dest
comma
id|time_t
id|tv_sec
comma
r_int
id|tv_usec
)paren
(brace
r_int
r_int
id|days
comma
id|rem
comma
id|y
suffix:semicolon
r_const
r_int
r_int
r_int
op_star
id|ip
suffix:semicolon
r_int
id|offset
op_assign
(paren
op_minus
id|sys_tz.tz_minuteswest
op_plus
(paren
id|sys_tz.tz_dsttime
ques
c_cond
l_int|60
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dest
)paren
r_return
l_int|NULL
suffix:semicolon
id|dest-&gt;typeAndTimezone
op_assign
l_int|0x1000
op_or
(paren
id|offset
op_amp
l_int|0x0FFF
)paren
suffix:semicolon
id|tv_sec
op_add_assign
id|offset
op_star
l_int|60
suffix:semicolon
id|days
op_assign
id|tv_sec
op_div
id|SECS_PER_DAY
suffix:semicolon
id|rem
op_assign
id|tv_sec
op_mod
id|SECS_PER_DAY
suffix:semicolon
id|dest-&gt;hour
op_assign
id|rem
op_div
id|SECS_PER_HOUR
suffix:semicolon
id|rem
op_mod_assign
id|SECS_PER_HOUR
suffix:semicolon
id|dest-&gt;minute
op_assign
id|rem
op_div
l_int|60
suffix:semicolon
id|dest-&gt;second
op_assign
id|rem
op_mod
l_int|60
suffix:semicolon
id|y
op_assign
l_int|1970
suffix:semicolon
DECL|macro|DIV
mdefine_line|#define DIV(a,b) ((a) / (b) - ((a) % (b) &lt; 0))
DECL|macro|LEAPS_THRU_END_OF
mdefine_line|#define LEAPS_THRU_END_OF(y) (DIV (y, 4) - DIV (y, 100) + DIV (y, 400))
r_while
c_loop
(paren
id|days
OL
l_int|0
op_logical_or
id|days
op_ge
(paren
id|__isleap
c_func
(paren
id|y
)paren
ques
c_cond
l_int|366
suffix:colon
l_int|365
)paren
)paren
(brace
r_int
r_int
id|yg
op_assign
id|y
op_plus
id|days
op_div
l_int|365
op_minus
(paren
id|days
op_mod
l_int|365
OL
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Adjust DAYS and Y to match the guessed year.  */
id|days
op_sub_assign
(paren
(paren
id|yg
op_minus
id|y
)paren
op_star
l_int|365
op_plus
id|LEAPS_THRU_END_OF
(paren
id|yg
op_minus
l_int|1
)paren
op_minus
id|LEAPS_THRU_END_OF
(paren
id|y
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|y
op_assign
id|yg
suffix:semicolon
)brace
id|dest-&gt;year
op_assign
id|y
suffix:semicolon
id|ip
op_assign
id|__mon_yday
(braket
id|__isleap
c_func
(paren
id|y
)paren
)braket
suffix:semicolon
r_for
c_loop
(paren
id|y
op_assign
l_int|11
suffix:semicolon
id|days
OL
(paren
r_int
r_int
)paren
id|ip
(braket
id|y
)braket
suffix:semicolon
op_decrement
id|y
)paren
r_continue
suffix:semicolon
id|days
op_sub_assign
id|ip
(braket
id|y
)braket
suffix:semicolon
id|dest-&gt;month
op_assign
id|y
op_plus
l_int|1
suffix:semicolon
id|dest-&gt;day
op_assign
id|days
op_plus
l_int|1
suffix:semicolon
id|dest-&gt;centiseconds
op_assign
id|tv_usec
op_div
l_int|10000
suffix:semicolon
id|dest-&gt;hundredsOfMicroseconds
op_assign
(paren
id|tv_usec
op_minus
id|dest-&gt;centiseconds
op_star
l_int|10000
)paren
op_div
l_int|100
suffix:semicolon
id|dest-&gt;microseconds
op_assign
(paren
id|tv_usec
op_minus
id|dest-&gt;centiseconds
op_star
l_int|10000
op_minus
id|dest-&gt;hundredsOfMicroseconds
op_star
l_int|100
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
macro_line|#endif
macro_line|#else
r_static
id|time_t
id|ydhms_tm_diff
(paren
r_int
comma
r_int
comma
r_int
comma
r_int
comma
r_int
comma
r_const
r_struct
id|ktm
op_star
)paren
suffix:semicolon
multiline_comment|/* Yield the difference between (YEAR-YDAY HOUR:MIN:SEC) and (*TP),&n;   measured in seconds, ignoring leap seconds.&n;   YEAR uses the same numbering as TM-&gt;tm_year.&n;   All values are in range, except possibly YEAR.&n;   If overflow occurs, yield the low order bits of the correct answer.  */
r_static
id|time_t
DECL|function|ydhms_tm_diff
id|ydhms_tm_diff
(paren
r_int
id|year
comma
r_int
id|yday
comma
r_int
id|hour
comma
r_int
id|min
comma
r_int
id|sec
comma
r_const
r_struct
id|ktm
op_star
id|tp
)paren
(brace
id|time_t
id|result
suffix:semicolon
multiline_comment|/* Compute intervening leap days correctly even if year is negative.&n;     Take care to avoid int overflow.  time_t overflow is OK, since&n;     only the low order bits of the correct time_t answer are needed.&n;     Don&squot;t convert to time_t until after all divisions are done, since&n;     time_t might be unsigned.  */
r_int
id|a4
op_assign
(paren
id|year
op_rshift
l_int|2
)paren
op_plus
(paren
id|TM_YEAR_BASE
op_rshift
l_int|2
)paren
op_minus
op_logical_neg
(paren
id|year
op_amp
l_int|3
)paren
suffix:semicolon
r_int
id|b4
op_assign
(paren
id|tp-&gt;tm_year
op_rshift
l_int|2
)paren
op_plus
(paren
id|TM_YEAR_BASE
op_rshift
l_int|2
)paren
op_minus
op_logical_neg
(paren
id|tp-&gt;tm_year
op_amp
l_int|3
)paren
suffix:semicolon
r_int
id|a100
op_assign
id|a4
op_div
l_int|25
op_minus
(paren
id|a4
op_mod
l_int|25
OL
l_int|0
)paren
suffix:semicolon
r_int
id|b100
op_assign
id|b4
op_div
l_int|25
op_minus
(paren
id|b4
op_mod
l_int|25
OL
l_int|0
)paren
suffix:semicolon
r_int
id|a400
op_assign
id|a100
op_rshift
l_int|2
suffix:semicolon
r_int
id|b400
op_assign
id|b100
op_rshift
l_int|2
suffix:semicolon
r_int
id|intervening_leap_days
op_assign
(paren
id|a4
op_minus
id|b4
)paren
op_minus
(paren
id|a100
op_minus
id|b100
)paren
op_plus
(paren
id|a400
op_minus
id|b400
)paren
suffix:semicolon
id|time_t
id|years
op_assign
id|year
op_minus
(paren
id|time_t
)paren
id|tp-&gt;tm_year
suffix:semicolon
id|time_t
id|days
op_assign
(paren
l_int|365
op_star
id|years
op_plus
id|intervening_leap_days
)paren
suffix:semicolon
id|result
op_assign
(paren
l_int|60
op_star
(paren
l_int|60
op_star
(paren
l_int|24
op_star
id|days
op_plus
(paren
id|hour
op_minus
id|tp-&gt;tm_hour
)paren
)paren
op_plus
(paren
id|min
op_minus
id|tp-&gt;tm_min
)paren
)paren
op_plus
(paren
id|sec
op_minus
id|tp-&gt;tm_sec
)paren
)paren
suffix:semicolon
macro_line|#ifdef __KERNEL__
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;udf: ydhms_tm_diff(%d,%d,%d,%d,%d,) returning %ld&bslash;n&quot;
comma
id|year
comma
id|yday
comma
id|hour
comma
id|min
comma
id|sec
comma
id|result
)paren
suffix:semicolon
macro_line|#endif
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* Convert *TP to a time_t value, inverting&n;   the monotonic and mostly-unit-linear conversion function CONVERT.&n;   Use *OFFSET to keep track of a guess at the offset of the result,&n;   compared to what the result would be for UTC without leap seconds.&n;   If *OFFSET&squot;s guess is correct, only one CONVERT call is needed.  */
id|time_t
DECL|function|udf_converttime
id|udf_converttime
(paren
r_struct
id|ktm
op_star
id|tp
)paren
(brace
id|time_t
id|t
comma
id|dt
comma
id|t0
suffix:semicolon
r_struct
id|ktm
id|tm
suffix:semicolon
multiline_comment|/* The maximum number of probes (calls to CONVERT) should be enough&n;     to handle any combinations of time zone rule changes, solar time,&n;     and leap seconds.  Posix.1 prohibits leap seconds, but some hosts&n;     have them anyway.  */
r_int
id|remaining_probes
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* Time requested.  Copy it in case CONVERT modifies *TP; this can&n;     occur if TP is localtime&squot;s returned value and CONVERT is localtime.  */
r_int
id|sec
op_assign
id|tp-&gt;tm_sec
suffix:semicolon
r_int
id|min
op_assign
id|tp-&gt;tm_min
suffix:semicolon
r_int
id|hour
op_assign
id|tp-&gt;tm_hour
suffix:semicolon
r_int
id|mday
op_assign
id|tp-&gt;tm_mday
suffix:semicolon
r_int
id|mon
op_assign
id|tp-&gt;tm_mon
suffix:semicolon
r_int
id|year_requested
op_assign
id|tp-&gt;tm_year
suffix:semicolon
r_int
id|isdst
op_assign
id|tp-&gt;tm_isdst
suffix:semicolon
multiline_comment|/* Ensure that mon is in range, and set year accordingly.  */
r_int
id|mon_remainder
op_assign
id|mon
op_mod
l_int|12
suffix:semicolon
r_int
id|negative_mon_remainder
op_assign
id|mon_remainder
OL
l_int|0
suffix:semicolon
r_int
id|mon_years
op_assign
id|mon
op_div
l_int|12
op_minus
id|negative_mon_remainder
suffix:semicolon
r_int
id|year
op_assign
id|year_requested
op_plus
id|mon_years
suffix:semicolon
multiline_comment|/* The other values need not be in range:&n;     the remaining code handles minor overflows correctly,&n;     assuming int and time_t arithmetic wraps around.&n;     Major overflows are caught at the end.  */
multiline_comment|/* Calculate day of year from year, month, and day of month.&n;     The result need not be in range.  */
r_int
id|yday
op_assign
(paren
(paren
id|__mon_yday
(braket
id|__isleap
(paren
id|year
op_plus
id|TM_YEAR_BASE
)paren
)braket
(braket
id|mon_remainder
op_plus
l_int|12
op_star
id|negative_mon_remainder
)braket
)paren
op_plus
id|mday
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#if LEAP_SECONDS_POSSIBLE
multiline_comment|/* Handle out-of-range seconds specially,&n;     since ydhms_tm_diff assumes every minute has 60 seconds.  */
r_int
id|sec_requested
op_assign
id|sec
suffix:semicolon
r_if
c_cond
(paren
id|sec
OL
l_int|0
)paren
id|sec
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
l_int|59
OL
id|sec
)paren
id|sec
op_assign
l_int|59
suffix:semicolon
macro_line|#endif
multiline_comment|/* Invert CONVERT by probing.  First assume the same offset as last time.&n;     Then repeatedly use the error to improve the guess.  */
id|tm.tm_year
op_assign
id|EPOCH_YEAR
op_minus
id|TM_YEAR_BASE
suffix:semicolon
id|tm.tm_hour
op_assign
id|tm.tm_min
op_assign
id|tm.tm_sec
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;  t0 = ydhms_tm_diff (year, yday, hour, min, sec, &amp;tm);&n;&n;  for (t = t0; &n;       (dt = ydhms_tm_diff (year, yday, hour, min, sec, &amp;tm));&n;       t += dt)&n;    if (--remaining_probes == 0)&n;      return -1;&n;  */
multiline_comment|/* Check whether tm.tm_isdst has the requested value, if any.  */
r_if
c_cond
(paren
l_int|0
op_le
id|isdst
op_logical_and
l_int|0
op_le
id|tm.tm_isdst
)paren
(brace
r_int
id|dst_diff
op_assign
(paren
id|isdst
op_ne
l_int|0
)paren
op_minus
(paren
id|tm.tm_isdst
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dst_diff
)paren
(brace
multiline_comment|/* Move two hours in the direction indicated by the disagreement,&n;&t;     probe some more, and switch to a new time if found.&n;&t;     The largest known fallback due to daylight savings is two hours:&n;&t;     once, in Newfoundland, 1988-10-30 02:00 -&gt; 00:00.  */
id|time_t
id|ot
op_assign
id|t
op_minus
l_int|2
op_star
l_int|60
op_star
l_int|60
op_star
id|dst_diff
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|remaining_probes
op_ne
l_int|0
)paren
(brace
r_struct
id|ktm
id|otm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dt
op_assign
id|ydhms_tm_diff
(paren
id|year
comma
id|yday
comma
id|hour
comma
id|min
comma
id|sec
comma
op_amp
id|otm
)paren
)paren
)paren
(brace
id|t
op_assign
id|ot
suffix:semicolon
id|tm
op_assign
id|otm
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ot
op_add_assign
id|dt
)paren
op_eq
id|t
)paren
r_break
suffix:semicolon
multiline_comment|/* Avoid a redundant probe.  */
)brace
)brace
)brace
macro_line|#if LEAP_SECONDS_POSSIBLE
r_if
c_cond
(paren
id|sec_requested
op_ne
id|tm.tm_sec
)paren
(brace
multiline_comment|/* Adjust time to reflect the tm_sec requested, not the normalized value.&n;&t; Also, repair any damage from a false match due to a leap second.  */
id|t
op_add_assign
id|sec_requested
op_minus
id|sec
op_plus
(paren
id|sec
op_eq
l_int|0
op_logical_and
id|tm.tm_sec
op_eq
l_int|60
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|TIME_T_MAX
op_div
id|INT_MAX
op_div
l_int|366
op_div
l_int|24
op_div
l_int|60
op_div
l_int|60
OL
l_int|3
)paren
(brace
multiline_comment|/* time_t isn&squot;t large enough to rule out overflows in ydhms_tm_diff,&n;&t; so check for major overflows.  A gross check suffices,&n;&t; since if t has overflowed, it is off by a multiple of&n;&t; TIME_T_MAX - TIME_T_MIN + 1.  So ignore any component of&n;&t; the difference that is bounded by a small value.  */
r_float
id|dyear
op_assign
(paren
r_float
)paren
id|year_requested
op_plus
id|mon_years
op_minus
id|tm.tm_year
suffix:semicolon
r_float
id|dday
op_assign
l_int|366
op_star
id|dyear
op_plus
id|mday
suffix:semicolon
r_float
id|dsec
op_assign
l_int|60
op_star
(paren
l_int|60
op_star
(paren
l_int|24
op_star
id|dday
op_plus
id|hour
)paren
op_plus
id|min
)paren
op_plus
id|sec_requested
suffix:semicolon
r_if
c_cond
(paren
id|TIME_T_MAX
op_div
l_int|3
op_minus
id|TIME_T_MIN
op_div
l_int|3
OL
(paren
id|dsec
OL
l_int|0
ques
c_cond
op_minus
id|dsec
suffix:colon
id|dsec
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
op_star
id|tp
op_assign
id|tm
suffix:semicolon
macro_line|#ifdef __KERNEL__
id|udf_debug
c_func
(paren
l_string|&quot;returning %ld&bslash;n&quot;
comma
id|t
)paren
suffix:semicolon
macro_line|#endif
r_return
id|t
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef INCLUDE_PRINT_KTM
r_static
r_void
DECL|function|print_ktm
id|print_ktm
(paren
r_struct
id|ktm
op_star
id|tp
)paren
(brace
macro_line|#ifdef __KERNEL__
id|udf_debug
(paren
macro_line|#else
id|printf
c_func
(paren
macro_line|#endif
l_string|&quot;%04d-%02d-%02d %02d:%02d:%02d isdst %d&quot;
comma
id|tp-&gt;tm_year
op_plus
id|TM_YEAR_BASE
comma
id|tp-&gt;tm_mon
op_plus
l_int|1
comma
id|tp-&gt;tm_mday
comma
id|tp-&gt;tm_hour
comma
id|tp-&gt;tm_min
comma
id|tp-&gt;tm_sec
comma
id|tp-&gt;tm_isdst
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* EOF */
eof
