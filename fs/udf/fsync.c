multiline_comment|/*&n; * fsync.c&n; *&n; * PURPOSE&n; *  Fsync handling routines for the OSTA-UDF(tm) filesystem.&n; *&n; * CONTACTS&n; *  E-mail regarding any portion of the Linux UDF file system should be&n; *  directed to the development team mailing list (run by majordomo):&n; *      linux_udf@hootie.lvld.hp.com&n; *&n; * COPYRIGHT&n; *  This file is distributed under the terms of the GNU General Public&n; *  License (GPL). Copies of the GPL can be obtained from:&n; *      ftp://prep.ai.mit.edu/pub/gnu/GPL&n; *  Each contributing author retains all rights to their own work.&n; *&n; *  (C) 1999-2000 Ben Fennema&n; *  (C) 1999-2000 Stelias Computing Inc&n; *&n; * HISTORY&n; *&n; *  05/22/99 blf  Created.&n; */
macro_line|#include &quot;udfdecl.h&quot;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/udf_fs.h&gt;
macro_line|#include &quot;udf_i.h&quot;
DECL|function|sync_extent_block
r_static
r_int
id|sync_extent_block
(paren
r_struct
id|inode
op_star
id|inode
comma
id|Uint32
id|block
comma
r_int
id|wait
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|block
)paren
r_return
l_int|0
suffix:semicolon
id|bh
op_assign
id|get_hash_table
(paren
id|inode-&gt;i_dev
comma
id|block
comma
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|wait
op_logical_and
id|buffer_req
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* There can be a parallell read(2) that started read-I/O&n;&t;&t;   on the buffer so we can&squot;t assume that there&squot;s been&n;&t;&t;   an I/O error without first waiting I/O completation. */
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|brelse
(paren
id|bh
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|wait
op_logical_or
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
op_logical_or
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
r_if
c_cond
(paren
id|wait
)paren
multiline_comment|/* when we return from fsync all the blocks&n;&t;&t;&t;   must be _just_ stored on disk */
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|brelse
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ll_rw_block
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sync_all_extents
r_static
r_int
id|sync_all_extents
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|wait
)paren
(brace
id|lb_addr
id|bloc
comma
id|eloc
suffix:semicolon
id|Uint32
id|extoffset
comma
id|lextoffset
comma
id|elen
comma
id|offset
comma
id|block
suffix:semicolon
r_int
id|err
op_assign
l_int|0
comma
id|etype
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|etype
op_assign
id|inode_bmap
c_func
(paren
id|inode
comma
l_int|0
comma
op_amp
id|bloc
comma
op_amp
id|extoffset
comma
op_amp
id|eloc
comma
op_amp
id|elen
comma
op_amp
id|offset
comma
op_amp
id|bh
)paren
)paren
op_ne
op_minus
l_int|1
)paren
(brace
id|block
op_assign
id|udf_get_lb_pblock
c_func
(paren
id|inode-&gt;i_sb
comma
id|bloc
comma
l_int|0
)paren
suffix:semicolon
id|err
op_or_assign
id|sync_extent_block
c_func
(paren
id|inode
comma
id|block
comma
id|wait
)paren
suffix:semicolon
id|lextoffset
op_assign
id|extoffset
suffix:semicolon
r_while
c_loop
(paren
(paren
id|etype
op_assign
id|udf_next_aext
c_func
(paren
id|inode
comma
op_amp
id|bloc
comma
op_amp
id|extoffset
comma
op_amp
id|eloc
comma
op_amp
id|elen
comma
op_amp
id|bh
comma
l_int|1
)paren
)paren
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|lextoffset
OG
id|extoffset
)paren
(brace
id|block
op_assign
id|udf_get_lb_pblock
c_func
(paren
id|inode-&gt;i_sb
comma
id|bloc
comma
l_int|0
)paren
suffix:semicolon
id|err
op_or_assign
id|sync_extent_block
c_func
(paren
id|inode
comma
id|block
comma
id|wait
)paren
suffix:semicolon
)brace
id|lextoffset
op_assign
id|extoffset
suffix:semicolon
)brace
)brace
id|udf_release_data
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;File may be NULL when we are called. Perhaps we shouldn&squot;t&n; *&t;even pass file to fsync ?&n; */
DECL|function|udf_sync_file
r_int
id|udf_sync_file
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|datasync
)paren
(brace
r_int
id|wait
comma
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
op_logical_neg
(paren
id|inode-&gt;i_blocks
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Don&squot;t sync fast links! or ICB_FLAG_AD_IN_ICB&n;&t;&t; */
r_goto
id|skip
suffix:semicolon
)brace
id|err
op_assign
id|generic_buffer_fdatasync
c_func
(paren
id|inode
comma
l_int|0
comma
op_complement
l_int|0UL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|wait
op_assign
l_int|0
suffix:semicolon
id|wait
op_le
l_int|1
suffix:semicolon
id|wait
op_increment
)paren
(brace
id|err
op_or_assign
id|sync_all_extents
(paren
id|inode
comma
id|wait
)paren
suffix:semicolon
)brace
id|skip
suffix:colon
id|err
op_or_assign
id|udf_sync_inode
(paren
id|inode
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
)brace
eof
