multiline_comment|/*&n; * Cache operations for Coda.&n; * Original version: (C) 1996 Peter Braam &n; * Rewritten for Linux 2.1: (C) 1997 Carnegie Mellon University&n; *&n; * Carnegie Mellon encourages users of this code to contribute improvements&n; * to the Coda project. Contact Peter Braam &lt;coda@cs.cmu.edu&gt;.&n; */
multiline_comment|/*&n; * This module contains the routines to implement the CFS name cache. The&n; * purpose of this cache is to reduce the cost of translating pathnames &n; * into Vice FIDs. Each entry in the cache contains the name of the file,&n; * the vnode (FID) of the parent directory, and the cred structure of the&n; * user accessing the file.&n; *&n; * The first time a file is accessed, it is looked up by the local Venus&n; * which first insures that the user has access to the file. In addition&n; * we are guaranteed that Venus will invalidate any name cache entries in&n; * case the user no longer should be able to access the file. For these&n; * reasons we do not need to keep access list information as well as a&n; * cred structure for each entry.&n; *&n; * The table can be accessed through the routines cnc_init(), cnc_enter(),&n; * cnc_lookup(), cnc_rmfidcred(), cnc_rmfid(), cnc_rmcred(), and cnc_purge().&n; * There are several other routines which aid in the implementation of the&n; * hash table.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/coda.h&gt;
macro_line|#include &lt;linux/coda_linux.h&gt;
macro_line|#include &lt;linux/coda_cnode.h&gt;
macro_line|#include &lt;linux/coda_namecache.h&gt;
DECL|variable|cfsnc_use
r_int
id|cfsnc_use
suffix:semicolon
r_static
r_struct
id|cfscache
op_star
id|cfsnc_find
c_func
(paren
r_struct
id|cnode
op_star
id|dcp
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_int
id|hash
)paren
suffix:semicolon
r_static
r_void
id|cfsnc_remove
c_func
(paren
r_struct
id|cfscache
op_star
id|cncp
)paren
suffix:semicolon
r_static
r_inline
r_int
id|nchash
c_func
(paren
r_const
r_char
op_star
comma
r_int
comma
r_struct
id|cnode
op_star
)paren
suffix:semicolon
r_static
r_inline
r_int
id|ncmatch
c_func
(paren
r_struct
id|cfscache
op_star
comma
r_const
r_char
op_star
comma
r_int
comma
r_struct
id|cnode
op_star
)paren
suffix:semicolon
r_static
r_inline
r_void
id|hashins
c_func
(paren
r_struct
id|cfscache
op_star
id|a
comma
r_struct
id|cfscache
op_star
id|pred
)paren
suffix:semicolon
r_static
r_inline
r_void
id|hashrem
c_func
(paren
r_struct
id|cfscache
op_star
id|a
)paren
suffix:semicolon
r_static
r_inline
r_void
id|hashnull
c_func
(paren
r_struct
id|cfscache
op_star
)paren
suffix:semicolon
r_static
r_inline
r_void
id|lrurem
c_func
(paren
r_struct
id|cfscache
op_star
id|a
)paren
suffix:semicolon
r_static
r_inline
r_void
id|lruins
c_func
(paren
r_struct
id|cfscache
op_star
id|a
comma
r_struct
id|cfscache
op_star
id|pred
)paren
suffix:semicolon
r_static
r_void
id|cfsnc_gather_stats
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* externals */
r_extern
r_int
id|coda_fideq
c_func
(paren
id|ViceFid
op_star
id|fid1
comma
id|ViceFid
op_star
id|fid2
)paren
suffix:semicolon
r_extern
r_int
id|coda_debug
suffix:semicolon
r_extern
r_int
id|coda_print_entry
suffix:semicolon
r_extern
r_struct
id|super_block
op_star
id|coda_super_block
suffix:semicolon
multiline_comment|/* &n; * Declaration of the name cache data structure.&n; */
DECL|variable|cfsnc_use
r_int
id|cfsnc_use
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Indicate use of CFS Name Cache */
DECL|variable|cfsnc_size
r_int
id|cfsnc_size
op_assign
id|CFSNC_CACHESIZE
suffix:semicolon
multiline_comment|/* size of the cache */
DECL|variable|cfsnc_hashsize
r_int
id|cfsnc_hashsize
op_assign
id|CFSNC_HASHSIZE
suffix:semicolon
multiline_comment|/* size of the primary hash */
DECL|variable|cfsnc_flushme
r_int
id|cfsnc_flushme
op_assign
l_int|0
suffix:semicolon
DECL|variable|cfsnc_procsize
r_int
id|cfsnc_procsize
op_assign
l_int|0
suffix:semicolon
DECL|variable|cfsnc_force
r_static
r_int
id|cfsnc_force
op_assign
l_int|0
suffix:semicolon
DECL|struct|cfshash
r_struct
id|cfshash
(brace
DECL|member|hash_next
DECL|member|hash_prev
r_struct
id|cfscache
op_star
id|hash_next
comma
op_star
id|hash_prev
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|cfslruhead
r_struct
id|cfslruhead
(brace
DECL|member|dummy1
DECL|member|dummy2
r_struct
id|cfscache
op_star
id|dummy1
comma
op_star
id|dummy2
suffix:semicolon
DECL|member|lru_next
DECL|member|lru_prev
r_struct
id|cfscache
op_star
id|lru_next
comma
op_star
id|lru_prev
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|cfsncheap
r_struct
id|cfscache
op_star
id|cfsncheap
suffix:semicolon
multiline_comment|/* pointer to the cache entries */
DECL|variable|cfsnchash
r_struct
id|cfshash
op_star
id|cfsnchash
suffix:semicolon
multiline_comment|/* hash table of cfscache pointers */
DECL|variable|cfsnc_lru
r_struct
id|cfslruhead
id|cfsnc_lru
suffix:semicolon
multiline_comment|/* head of lru chain; prev = lru */
DECL|variable|cfsnc_stat
r_struct
id|cfsnc_statistics
id|cfsnc_stat
suffix:semicolon
multiline_comment|/* Keep various stats */
DECL|macro|TOTAL_CACHE_SIZE
mdefine_line|#define TOTAL_CACHE_SIZE &t;(sizeof(struct cfscache) * cfsnc_size)
DECL|macro|TOTAL_HASH_SIZE
mdefine_line|#define TOTAL_HASH_SIZE &t;(sizeof(struct cfshash)  * cfsnc_hashsize)
DECL|variable|cfsnc_initialized
r_int
id|cfsnc_initialized
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initially the cache has not been initialized */
multiline_comment|/* &n; * for testing purposes&n; */
DECL|variable|cfsnc_debug
r_int
id|cfsnc_debug
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Auxillary routines -- shouldn&squot;t be entry points&n; */
multiline_comment|/*&n; * Hash function for the primary hash.&n; * First try -- (first + last letters + length + (int)cp) mod size&n; * 2nd try -- same, except dir fid.vnode instead of cp&n; */
r_static
r_inline
r_int
DECL|function|nchash
id|nchash
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_struct
id|cnode
op_star
id|cp
)paren
(brace
r_return
(paren
(paren
id|name
(braket
l_int|0
)braket
op_plus
id|name
(braket
id|namelen
op_minus
l_int|1
)braket
op_plus
id|namelen
op_plus
(paren
r_int
)paren
(paren
id|cp
)paren
)paren
op_amp
(paren
id|cfsnc_hashsize
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* matching function */
DECL|function|ncmatch
r_static
r_inline
r_int
id|ncmatch
c_func
(paren
r_struct
id|cfscache
op_star
id|cp
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_struct
id|cnode
op_star
id|dcp
)paren
(brace
r_return
(paren
(paren
id|namelen
op_eq
id|cp-&gt;namelen
)paren
op_logical_and
(paren
id|dcp
op_eq
id|cp-&gt;dcp
)paren
op_logical_and
(paren
id|memcmp
c_func
(paren
id|cp-&gt;name
comma
id|name
comma
id|namelen
)paren
op_eq
l_int|0
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* insert  a  behind  pred */
DECL|function|hashins
r_static
r_inline
r_void
id|hashins
c_func
(paren
r_struct
id|cfscache
op_star
id|a
comma
r_struct
id|cfscache
op_star
id|pred
)paren
(brace
id|a-&gt;hash_next
op_assign
id|pred-&gt;hash_next
suffix:semicolon
id|pred-&gt;hash_next-&gt;hash_prev
op_assign
id|a
suffix:semicolon
id|pred-&gt;hash_next
op_assign
id|a
suffix:semicolon
id|a-&gt;hash_prev
op_assign
id|pred
suffix:semicolon
)brace
DECL|function|hashrem
r_static
r_inline
r_void
id|hashrem
c_func
(paren
r_struct
id|cfscache
op_star
id|a
)paren
(brace
id|a-&gt;hash_prev-&gt;hash_next
op_assign
id|a-&gt;hash_next
suffix:semicolon
id|a-&gt;hash_next-&gt;hash_prev
op_assign
id|a-&gt;hash_prev
suffix:semicolon
)brace
DECL|function|hashnull
r_static
r_inline
r_void
id|hashnull
c_func
(paren
r_struct
id|cfscache
op_star
id|elem
)paren
(brace
id|elem-&gt;hash_next
op_assign
id|elem
suffix:semicolon
id|elem-&gt;hash_prev
op_assign
id|elem
suffix:semicolon
)brace
DECL|function|lrurem
r_static
r_inline
r_void
id|lrurem
c_func
(paren
r_struct
id|cfscache
op_star
id|a
)paren
(brace
id|a-&gt;lru_prev-&gt;lru_next
op_assign
id|a-&gt;lru_next
suffix:semicolon
id|a-&gt;lru_next-&gt;lru_prev
op_assign
id|a-&gt;lru_prev
suffix:semicolon
)brace
DECL|function|lruins
r_static
r_inline
r_void
id|lruins
c_func
(paren
r_struct
id|cfscache
op_star
id|a
comma
r_struct
id|cfscache
op_star
id|pred
)paren
(brace
id|pred-&gt;lru_next-&gt;lru_prev
op_assign
id|a
suffix:semicolon
id|a-&gt;lru_next
op_assign
id|pred-&gt;lru_next
suffix:semicolon
id|a-&gt;lru_prev
op_assign
id|pred
suffix:semicolon
id|pred-&gt;lru_next
op_assign
id|a
suffix:semicolon
)brace
r_static
r_struct
id|cfscache
op_star
DECL|function|cfsnc_find
id|cfsnc_find
c_func
(paren
r_struct
id|cnode
op_star
id|dcp
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_int
id|hash
)paren
(brace
multiline_comment|/* &n;&t; * hash to find the appropriate bucket, look through the chain&n;&t; * for the right entry &n;&t; */
r_register
r_struct
id|cfscache
op_star
id|cncp
suffix:semicolon
r_int
id|count
op_assign
l_int|1
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;dcp 0x%x, name %s, len %d, hash %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|dcp
comma
id|name
comma
id|namelen
comma
id|hash
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cncp
op_assign
id|cfsnchash
(braket
id|hash
)braket
dot
id|hash_next
suffix:semicolon
id|cncp
op_ne
(paren
r_struct
id|cfscache
op_star
)paren
op_amp
id|cfsnchash
(braket
id|hash
)braket
suffix:semicolon
id|cncp
op_assign
id|cncp-&gt;hash_next
comma
id|count
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ncmatch
c_func
(paren
id|cncp
comma
id|name
comma
id|namelen
comma
id|dcp
)paren
)paren
(brace
id|cfsnc_stat.Search_len
op_add_assign
id|count
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;dcp 0x%x,found.&bslash;n&quot;
comma
(paren
r_int
)paren
id|dcp
)paren
suffix:semicolon
r_return
id|cncp
suffix:semicolon
)brace
)brace
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;dcp 0x%x,not found.&bslash;n&quot;
comma
(paren
r_int
)paren
id|dcp
)paren
suffix:semicolon
r_return
(paren
r_struct
id|cfscache
op_star
)paren
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|cfsnc_remove
id|cfsnc_remove
c_func
(paren
r_struct
id|cfscache
op_star
id|cncp
)paren
(brace
multiline_comment|/* &n;&t; * remove an entry -- VN_RELE(cncp-&gt;dcp, cp), crfree(cred),&n;&t; * remove it from it&squot;s hash chain, and&n;&t; * place it at the head of the lru list.&n;&t; */
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;remove %s from parent %lx.%lx.%lx&bslash;n&quot;
comma
id|cncp-&gt;name
comma
(paren
id|cncp-&gt;dcp
)paren
op_member_access_from_pointer
id|c_fid.Volume
comma
(paren
id|cncp-&gt;dcp
)paren
op_member_access_from_pointer
id|c_fid.Vnode
comma
(paren
id|cncp-&gt;dcp
)paren
op_member_access_from_pointer
id|c_fid.Unique
)paren
suffix:semicolon
id|hashrem
c_func
(paren
id|cncp
)paren
suffix:semicolon
id|hashnull
c_func
(paren
id|cncp
)paren
suffix:semicolon
multiline_comment|/* have it be a null chain */
multiline_comment|/* VN_RELE(CTOV(cncp-&gt;dcp));  */
id|iput
c_func
(paren
id|CTOI
c_func
(paren
id|cncp-&gt;cp
)paren
)paren
suffix:semicolon
multiline_comment|/* crfree(cncp-&gt;cred);  */
id|memset
c_func
(paren
id|DATA_PART
c_func
(paren
id|cncp
)paren
comma
l_int|0
comma
id|DATA_SIZE
)paren
suffix:semicolon
id|cncp-&gt;cp
op_assign
l_int|NULL
suffix:semicolon
id|cncp-&gt;dcp
op_assign
(paren
r_struct
id|cnode
op_star
)paren
l_int|0
suffix:semicolon
multiline_comment|/* Put the null entry just after the least-recently-used entry */
id|lrurem
c_func
(paren
id|cncp
)paren
suffix:semicolon
id|lruins
c_func
(paren
id|cncp
comma
id|cfsnc_lru.lru_prev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Entry points for the CFS Name Cache&n; */
multiline_comment|/*  &n; * Initialize the cache, the LRU structure and the Hash structure(s)&n; */
r_void
DECL|function|cfsnc_init
id|cfsnc_init
c_func
(paren
r_void
)paren
(brace
r_register
r_int
id|i
suffix:semicolon
multiline_comment|/* zero the statistics structure */
id|cfsnc_procsize
op_assign
l_int|10000
op_star
id|cfsnc_hashsize
op_plus
id|cfsnc_size
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|cfsnc_stat
comma
l_int|0
comma
(paren
r_sizeof
(paren
r_struct
id|cfsnc_statistics
)paren
)paren
)paren
suffix:semicolon
id|CODA_ALLOC
c_func
(paren
id|cfsncheap
comma
r_struct
id|cfscache
op_star
comma
id|TOTAL_CACHE_SIZE
)paren
suffix:semicolon
id|CODA_ALLOC
c_func
(paren
id|cfsnchash
comma
r_struct
id|cfshash
op_star
comma
id|TOTAL_HASH_SIZE
)paren
suffix:semicolon
id|cfsnc_lru.lru_next
op_assign
id|cfsnc_lru.lru_prev
op_assign
(paren
r_struct
id|cfscache
op_star
)paren
op_amp
id|cfsnc_lru
suffix:semicolon
multiline_comment|/* initialize the heap */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cfsnc_size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lruins
c_func
(paren
op_amp
id|cfsncheap
(braket
id|i
)braket
comma
(paren
r_struct
id|cfscache
op_star
)paren
op_amp
id|cfsnc_lru
)paren
suffix:semicolon
id|hashnull
c_func
(paren
op_amp
id|cfsncheap
(braket
id|i
)braket
)paren
suffix:semicolon
id|cfsncheap
(braket
id|i
)braket
dot
id|cp
op_assign
id|cfsncheap
(braket
id|i
)braket
dot
id|dcp
op_assign
(paren
r_struct
id|cnode
op_star
)paren
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cfsnc_hashsize
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* initialize the hashtable */
id|hashnull
c_func
(paren
(paren
r_struct
id|cfscache
op_star
)paren
op_amp
id|cfsnchash
(braket
id|i
)braket
)paren
suffix:semicolon
id|cfsnchash
(braket
id|i
)braket
dot
id|length
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* bucket length */
)brace
id|cfsnc_initialized
op_assign
l_int|1
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;cfsnc_initialized is now 1.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Enter a new (dir cnode, name) pair into the cache, updating the&n; * LRU and Hash as needed.&n; */
r_void
DECL|function|cfsnc_enter
id|cfsnc_enter
c_func
(paren
r_struct
id|cnode
op_star
id|dcp
comma
r_register
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_struct
id|cnode
op_star
id|cp
)paren
(brace
r_register
r_struct
id|cfscache
op_star
id|cncp
suffix:semicolon
r_register
r_int
id|hash
suffix:semicolon
r_if
c_cond
(paren
id|cfsnc_use
op_eq
l_int|0
)paren
multiline_comment|/* Cache is off */
r_return
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;dcp 0x%x cp 0x%x name %s, ind 0x%x &bslash;n&quot;
comma
(paren
r_int
)paren
id|dcp
comma
(paren
r_int
)paren
id|cp
comma
id|name
comma
(paren
r_int
)paren
id|cp-&gt;c_vnode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|namelen
OG
id|CFSNC_NAMELEN
)paren
(brace
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;long name enter %s&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|cfsnc_stat.long_name_enters
op_increment
suffix:semicolon
multiline_comment|/* record stats */
r_return
suffix:semicolon
)brace
id|hash
op_assign
id|nchash
c_func
(paren
id|name
comma
id|namelen
comma
id|dcp
)paren
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;Calling find with name %s, dcp %d, hash %d&bslash;n&quot;
comma
id|name
comma
(paren
r_int
)paren
id|dcp
comma
(paren
r_int
)paren
id|hash
)paren
suffix:semicolon
id|cncp
op_assign
id|cfsnc_find
c_func
(paren
id|dcp
comma
id|name
comma
id|namelen
comma
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cncp
op_ne
(paren
r_struct
id|cfscache
op_star
)paren
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cfsnc_enter: Duplicate cache entry; tell Peter.&bslash;n&quot;
)paren
suffix:semicolon
id|cfsnc_stat.dbl_enters
op_increment
suffix:semicolon
multiline_comment|/* duplicate entry */
r_return
suffix:semicolon
)brace
id|cfsnc_stat.enters
op_increment
suffix:semicolon
multiline_comment|/* record the enters statistic */
multiline_comment|/* Grab the lru element in the lru chain */
id|cncp
op_assign
id|cfsnc_lru.lru_prev
suffix:semicolon
id|lrurem
c_func
(paren
id|cncp
)paren
suffix:semicolon
multiline_comment|/* remove it from the lists */
multiline_comment|/* if cncp is on hash list remove it */
r_if
c_cond
(paren
id|cncp-&gt;dcp
op_ne
(paren
r_struct
id|cnode
op_star
)paren
l_int|0
)paren
(brace
multiline_comment|/* We have to decrement the appropriate hash bucket length&n;&t;   here, so we have to find the hash bucket */
id|cfsnchash
(braket
id|nchash
c_func
(paren
id|cncp-&gt;name
comma
id|cncp-&gt;namelen
comma
id|cncp-&gt;dcp
)paren
)braket
dot
id|length
op_decrement
suffix:semicolon
id|cfsnc_stat.lru_rm
op_increment
suffix:semicolon
multiline_comment|/* zapped a valid entry */
id|hashrem
c_func
(paren
id|cncp
)paren
suffix:semicolon
id|iput
c_func
(paren
id|CTOI
c_func
(paren
id|cncp-&gt;cp
)paren
)paren
suffix:semicolon
multiline_comment|/* VN_RELE(CTOV(cncp-&gt;dcp));  */
multiline_comment|/* crfree(cncp-&gt;cred); */
)brace
multiline_comment|/*&n;     * Put a hold on the current vnodes and fill in the cache entry.&n;     */
id|iget
c_func
(paren
(paren
id|CTOI
c_func
(paren
id|cp
)paren
)paren
op_member_access_from_pointer
id|i_sb
comma
id|CTOI
c_func
(paren
id|cp
)paren
op_member_access_from_pointer
id|i_ino
)paren
suffix:semicolon
multiline_comment|/* VN_HOLD(CTOV(dcp)); */
multiline_comment|/* XXXX crhold(cred); */
id|cncp-&gt;dcp
op_assign
id|dcp
suffix:semicolon
id|cncp-&gt;cp
op_assign
id|cp
suffix:semicolon
id|cncp-&gt;namelen
op_assign
id|namelen
suffix:semicolon
multiline_comment|/* cncp-&gt;cred = cred; */
id|memcpy
c_func
(paren
id|cncp-&gt;name
comma
id|name
comma
(paren
r_int
)paren
id|namelen
)paren
suffix:semicolon
multiline_comment|/* Insert into the lru and hash chains. */
id|lruins
c_func
(paren
id|cncp
comma
(paren
r_struct
id|cfscache
op_star
)paren
op_amp
id|cfsnc_lru
)paren
suffix:semicolon
id|hashins
c_func
(paren
id|cncp
comma
(paren
r_struct
id|cfscache
op_star
)paren
op_amp
id|cfsnchash
(braket
id|hash
)braket
)paren
suffix:semicolon
id|cfsnchash
(braket
id|hash
)braket
dot
id|length
op_increment
suffix:semicolon
multiline_comment|/* Used for tuning */
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;Entering:&bslash;n&quot;
)paren
suffix:semicolon
id|coda_print_ce
c_func
(paren
id|cncp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the (dir cnode, name) pair in the cache, if it&squot;s cred&n; * matches the input, return it, otherwise return 0&n; */
r_struct
id|cnode
op_star
DECL|function|cfsnc_lookup
id|cfsnc_lookup
c_func
(paren
r_struct
id|cnode
op_star
id|dcp
comma
r_register
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
)paren
(brace
r_register
r_int
id|hash
suffix:semicolon
r_register
r_struct
id|cfscache
op_star
id|cncp
suffix:semicolon
multiline_comment|/* this should go into a callback funcntion for /proc/sys&n;           don&squot;t know how at the moment? */
r_if
c_cond
(paren
id|cfsnc_flushme
op_eq
l_int|1
)paren
(brace
id|cfsnc_flush
c_func
(paren
)paren
suffix:semicolon
id|cfsnc_flushme
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cfsnc_procsize
op_ne
l_int|10000
op_star
id|cfsnc_hashsize
op_plus
id|cfsnc_size
)paren
(brace
r_int
id|hsh
op_assign
id|cfsnc_procsize
op_div
l_int|10000
suffix:semicolon
r_int
id|siz
op_assign
id|cfsnc_procsize
op_mod
l_int|10000
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hsh
OG
l_int|1
)paren
op_logical_and
(paren
id|siz
OG
l_int|2
)paren
)paren
(brace
id|rc
op_assign
id|cfsnc_resize
c_func
(paren
id|hsh
comma
id|siz
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Coda:cache size (hash,size) (%d,%d)&bslash;n&quot;
comma
id|hsh
comma
id|siz
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Coda: cache resize failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|cfsnc_use
op_eq
l_int|0
)paren
multiline_comment|/* Cache is off */
r_return
(paren
r_struct
id|cnode
op_star
)paren
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|namelen
OG
id|CFSNC_NAMELEN
)paren
(brace
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;long name lookup %s&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|cfsnc_stat.long_name_lookups
op_increment
suffix:semicolon
multiline_comment|/* record stats */
r_return
(paren
r_struct
id|cnode
op_star
)paren
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Use the hash function to locate the starting point,&n;&t;   then the search routine to go down the list looking for&n;&t;   the correct cred.&n; &t; */
id|hash
op_assign
id|nchash
c_func
(paren
id|name
comma
id|namelen
comma
id|dcp
)paren
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;Calling find with name %s, dcp %d, hash %d&bslash;n&quot;
comma
id|name
comma
(paren
r_int
)paren
id|dcp
comma
(paren
r_int
)paren
id|hash
)paren
suffix:semicolon
id|cncp
op_assign
id|cfsnc_find
c_func
(paren
id|dcp
comma
id|name
comma
id|namelen
comma
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cncp
op_eq
(paren
r_struct
id|cfscache
op_star
)paren
l_int|0
)paren
(brace
id|cfsnc_stat.misses
op_increment
suffix:semicolon
multiline_comment|/* record miss */
r_return
(paren
r_struct
id|cnode
op_star
)paren
l_int|0
suffix:semicolon
)brace
id|cfsnc_stat.hits
op_increment
suffix:semicolon
multiline_comment|/* put this entry at the mru end of the LRU */
id|lrurem
c_func
(paren
id|cncp
)paren
suffix:semicolon
id|lruins
c_func
(paren
id|cncp
comma
(paren
r_struct
id|cfscache
op_star
)paren
op_amp
id|cfsnc_lru
)paren
suffix:semicolon
multiline_comment|/* move it to the front of the hash chain */
multiline_comment|/* don&squot;t need to change the hash bucket length */
id|hashrem
c_func
(paren
id|cncp
)paren
suffix:semicolon
id|hashins
c_func
(paren
id|cncp
comma
(paren
r_struct
id|cfscache
op_star
)paren
op_amp
id|cfsnchash
(braket
id|hash
)braket
)paren
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;lookup: dcp 0x%x, name %s,  cp 0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|dcp
comma
id|name
comma
(paren
r_int
)paren
id|cncp-&gt;cp
)paren
suffix:semicolon
r_return
id|cncp-&gt;cp
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove all entries with a parent which has the input fid.&n; */
r_void
DECL|function|cfsnc_zapParentfid
id|cfsnc_zapParentfid
c_func
(paren
id|ViceFid
op_star
id|fid
)paren
(brace
multiline_comment|/* To get to a specific fid, we might either have another hashing&n;&t;   function or do a sequential search through the cache for the&n;&t;   appropriate entries. The later may be acceptable since I don&squot;t&n;&t;   think callbacks or whatever Case 1 covers are frequent occurences.&n;&t; */
r_register
r_struct
id|cfscache
op_star
id|cncp
comma
op_star
id|ncncp
suffix:semicolon
r_register
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|cfsnc_use
op_eq
l_int|0
)paren
multiline_comment|/* Cache is off */
r_return
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot; fid 0x%lx, 0x%lx, 0x%lx &bslash;n&quot;
comma
id|fid-&gt;Volume
comma
id|fid-&gt;Vnode
comma
id|fid-&gt;Unique
)paren
suffix:semicolon
id|cfsnc_stat.zapPfids
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cfsnc_hashsize
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Need to save the hash_next pointer in case we remove the&n;&t;&t; * entry. remove causes hash_next to point to itself.&n;&t;&t; */
r_for
c_loop
(paren
id|cncp
op_assign
id|cfsnchash
(braket
id|i
)braket
dot
id|hash_next
suffix:semicolon
id|cncp
op_ne
(paren
r_struct
id|cfscache
op_star
)paren
op_amp
id|cfsnchash
(braket
id|i
)braket
suffix:semicolon
id|cncp
op_assign
id|ncncp
)paren
(brace
id|ncncp
op_assign
id|cncp-&gt;hash_next
suffix:semicolon
r_if
c_cond
(paren
id|coda_fideq
c_func
(paren
op_amp
id|cncp-&gt;dcp-&gt;c_fid
comma
id|fid
)paren
)paren
(brace
id|cfsnchash
(braket
id|i
)braket
dot
id|length
op_decrement
suffix:semicolon
multiline_comment|/* Used for tuning */
id|cfsnc_remove
c_func
(paren
id|cncp
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * Remove all entries which have the same fid as the input&n; */
r_void
DECL|function|cfsnc_zapfid
id|cfsnc_zapfid
c_func
(paren
id|ViceFid
op_star
id|fid
)paren
(brace
multiline_comment|/* See comment for zapParentfid. This routine will be used&n;&t;   if attributes are being cached. &n;&t; */
r_register
r_struct
id|cfscache
op_star
id|cncp
comma
op_star
id|ncncp
suffix:semicolon
r_register
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|cfsnc_use
op_eq
l_int|0
)paren
multiline_comment|/* Cache is off */
r_return
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;Zapfid: fid 0x%lx, 0x%lx, 0x%lx &bslash;n&quot;
comma
id|fid-&gt;Volume
comma
id|fid-&gt;Vnode
comma
id|fid-&gt;Unique
)paren
suffix:semicolon
id|cfsnc_stat.zapFids
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cfsnc_hashsize
suffix:semicolon
id|i
op_increment
)paren
(brace
r_for
c_loop
(paren
id|cncp
op_assign
id|cfsnchash
(braket
id|i
)braket
dot
id|hash_next
suffix:semicolon
id|cncp
op_ne
(paren
r_struct
id|cfscache
op_star
)paren
op_amp
id|cfsnchash
(braket
id|i
)braket
suffix:semicolon
id|cncp
op_assign
id|ncncp
)paren
(brace
id|ncncp
op_assign
id|cncp-&gt;hash_next
suffix:semicolon
r_if
c_cond
(paren
id|coda_fideq
c_func
(paren
op_amp
(paren
id|cncp-&gt;cp-&gt;c_fid
)paren
comma
id|fid
)paren
)paren
(brace
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;Found cncp: name %s&bslash;n&quot;
comma
id|cncp-&gt;name
)paren
suffix:semicolon
id|cfsnchash
(braket
id|i
)braket
dot
id|length
op_decrement
suffix:semicolon
multiline_comment|/* Used for tuning */
id|cfsnc_remove
c_func
(paren
id|cncp
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * Remove all entries which have the (dir vnode, name) pair&n; */
r_void
DECL|function|cfsnc_zapfile
id|cfsnc_zapfile
c_func
(paren
r_struct
id|cnode
op_star
id|dcp
comma
r_register
r_const
r_char
op_star
id|name
comma
r_int
id|length
)paren
(brace
multiline_comment|/* use the hash function to locate the file, then zap all&n; &t;   entries of it regardless of the cred.&n;&t; */
r_register
r_struct
id|cfscache
op_star
id|cncp
suffix:semicolon
r_int
id|hash
suffix:semicolon
r_if
c_cond
(paren
id|cfsnc_use
op_eq
l_int|0
)paren
multiline_comment|/* Cache is off */
r_return
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;Zapfile: dcp 0x%x name %s &bslash;n&quot;
comma
(paren
r_int
)paren
id|dcp
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|length
OG
id|CFSNC_NAMELEN
)paren
(brace
id|cfsnc_stat.long_remove
op_increment
suffix:semicolon
multiline_comment|/* record stats */
r_return
suffix:semicolon
)brace
id|cfsnc_stat.zapFile
op_increment
suffix:semicolon
id|hash
op_assign
id|nchash
c_func
(paren
id|name
comma
id|length
comma
id|dcp
)paren
suffix:semicolon
multiline_comment|/* remove entries: remember they might exist for more than a &n;       single cred */
r_while
c_loop
(paren
(paren
id|cncp
op_assign
id|cfsnc_find
c_func
(paren
id|dcp
comma
id|name
comma
id|length
comma
id|hash
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|cfsnchash
(braket
id|hash
)braket
dot
id|length
op_decrement
suffix:semicolon
id|cfsnc_remove
c_func
(paren
id|cncp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Remove all the entries for a particular user. Used when tokens expire.&n; * A user is determined by his/her effective user id (id_uid).&n; */
r_void
DECL|function|cfsnc_purge_user
id|cfsnc_purge_user
c_func
(paren
r_struct
id|CodaCred
op_star
id|cred
)paren
(brace
multiline_comment|/* I think the best approach is to go through the entire cache&n;&t;   via HASH or whatever and zap all entries which match the&n;&t;   input cred. Or just flush the whole cache.&n;&t;   It might be best to go through on basis of LRU since cache&n;&t;   will almost always be full and LRU is more straightforward.&n;&t; */
r_register
r_struct
id|cfscache
op_star
id|cncp
suffix:semicolon
r_int
id|hash
suffix:semicolon
r_if
c_cond
(paren
id|cfsnc_use
op_eq
l_int|0
)paren
multiline_comment|/* Cache is off */
r_return
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;ZapDude: uid %ld&bslash;n&quot;
comma
id|cred-&gt;cr_uid
)paren
suffix:semicolon
id|cfsnc_stat.zapUsers
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|cncp
op_assign
id|cfsnc_lru.lru_next
suffix:semicolon
id|cncp
op_ne
(paren
r_struct
id|cfscache
op_star
)paren
op_amp
id|cfsnc_lru
suffix:semicolon
id|cncp
op_assign
id|cncp-&gt;lru_next
)paren
(brace
r_if
c_cond
(paren
(paren
id|CFSNC_VALID
c_func
(paren
id|cncp
)paren
)paren
op_logical_and
(paren
(paren
id|cncp-&gt;cred
)paren
op_member_access_from_pointer
id|cr_uid
op_eq
id|cred-&gt;cr_uid
)paren
)paren
(brace
multiline_comment|/* Seems really ugly, but we have to decrement the appropriate&n;&t;&t;&t;   hash bucket length here, so we have to find the hash bucket&n;&t;&t;&t;   */
id|hash
op_assign
id|nchash
c_func
(paren
id|cncp-&gt;name
comma
id|cncp-&gt;namelen
comma
id|cncp-&gt;dcp
)paren
suffix:semicolon
id|cfsnchash
(braket
id|hash
)braket
dot
id|length
op_decrement
suffix:semicolon
multiline_comment|/* For performance tuning */
id|cfsnc_remove
c_func
(paren
id|cncp
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Flush the entire name cache. In response to a flush of the Venus cache.&n; */
r_void
DECL|function|cfsnc_flush
id|cfsnc_flush
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* One option is to deallocate the current name cache and&n;&t;   call init to start again. Or just deallocate, then rebuild.&n;&t;   Or again, we could just go through the array and zero the &n;&t;   appropriate fields. &n;&t; */
multiline_comment|/* &n;&t; * Go through the whole lru chain and kill everything as we go.&n;&t; * I don&squot;t use remove since that would rebuild the lru chain&n;&t; * as it went and that seemed unneccesary.&n;&t; */
r_register
r_struct
id|cfscache
op_star
id|cncp
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cfsnc_use
op_eq
l_int|0
op_logical_or
id|cfsnc_initialized
op_eq
l_int|0
)paren
op_logical_and
(paren
id|cfsnc_force
op_eq
l_int|0
)paren
)paren
r_return
suffix:semicolon
id|cfsnc_stat.Flushes
op_increment
suffix:semicolon
r_for
c_loop
(paren
id|cncp
op_assign
id|cfsnc_lru.lru_next
suffix:semicolon
id|cncp
op_ne
(paren
r_struct
id|cfscache
op_star
)paren
op_amp
id|cfsnc_lru
suffix:semicolon
id|cncp
op_assign
id|cncp-&gt;lru_next
)paren
(brace
r_if
c_cond
(paren
id|cncp-&gt;cp
)paren
(brace
id|hashrem
c_func
(paren
id|cncp
)paren
suffix:semicolon
multiline_comment|/* only zero valid nodes */
id|hashnull
c_func
(paren
id|cncp
)paren
suffix:semicolon
id|iput
c_func
(paren
id|CTOI
c_func
(paren
id|cncp-&gt;cp
)paren
)paren
suffix:semicolon
multiline_comment|/* crfree(cncp-&gt;cred);  */
id|memset
c_func
(paren
id|DATA_PART
c_func
(paren
id|cncp
)paren
comma
l_int|0
comma
id|DATA_SIZE
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cfsnc_hashsize
suffix:semicolon
id|i
op_increment
)paren
id|cfsnchash
(braket
id|i
)braket
dot
id|length
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine replaces a ViceFid in the name cache with another.&n; * It is added to allow Venus during reintegration to replace &n; * locally allocated temp fids while disconnected with global fids &n; * even when the reference count on those fids are not zero.&n; */
r_void
DECL|function|cfsnc_replace
id|cfsnc_replace
c_func
(paren
id|ViceFid
op_star
id|f1
comma
id|ViceFid
op_star
id|f2
)paren
(brace
multiline_comment|/* &n;&t; * Replace f1 with f2 throughout the name cache&n;&t; */
r_int
id|hash
suffix:semicolon
r_register
r_struct
id|cfscache
op_star
id|cncp
suffix:semicolon
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;cfsnc_replace fid_1 = (%lx.%lx.%lx) and fid_2 = (%lx.%lx.%lx)&bslash;n&quot;
comma
id|f1-&gt;Volume
comma
id|f1-&gt;Vnode
comma
id|f1-&gt;Unique
comma
id|f2-&gt;Volume
comma
id|f2-&gt;Vnode
comma
id|f2-&gt;Unique
)paren
suffix:semicolon
r_for
c_loop
(paren
id|hash
op_assign
l_int|0
suffix:semicolon
id|hash
OL
id|cfsnc_hashsize
suffix:semicolon
id|hash
op_increment
)paren
(brace
r_for
c_loop
(paren
id|cncp
op_assign
id|cfsnchash
(braket
id|hash
)braket
dot
id|hash_next
suffix:semicolon
id|cncp
op_ne
(paren
r_struct
id|cfscache
op_star
)paren
op_amp
id|cfsnchash
(braket
id|hash
)braket
suffix:semicolon
id|cncp
op_assign
id|cncp-&gt;hash_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
op_amp
id|cncp-&gt;cp-&gt;c_fid
comma
id|f1
comma
r_sizeof
(paren
id|ViceFid
)paren
)paren
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|cncp-&gt;cp-&gt;c_fid
comma
id|f2
comma
r_sizeof
(paren
id|ViceFid
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* no need to check cncp-&gt;dcp now */
)brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
op_amp
id|cncp-&gt;dcp-&gt;c_fid
comma
id|f1
comma
r_sizeof
(paren
id|ViceFid
)paren
)paren
)paren
id|memcpy
c_func
(paren
op_amp
id|cncp-&gt;dcp-&gt;c_fid
comma
id|f2
comma
r_sizeof
(paren
id|ViceFid
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Debugging routines&n; */
multiline_comment|/* &n; * This routine should print out all the hash chains to the console.&n; */
r_void
DECL|function|print_cfsnc
id|print_cfsnc
c_func
(paren
r_void
)paren
(brace
r_int
id|hash
suffix:semicolon
r_register
r_struct
id|cfscache
op_star
id|cncp
suffix:semicolon
r_for
c_loop
(paren
id|hash
op_assign
l_int|0
suffix:semicolon
id|hash
OL
id|cfsnc_hashsize
suffix:semicolon
id|hash
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nhash %d&bslash;n&quot;
comma
id|hash
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cncp
op_assign
id|cfsnchash
(braket
id|hash
)braket
dot
id|hash_next
suffix:semicolon
id|cncp
op_ne
(paren
r_struct
id|cfscache
op_star
)paren
op_amp
id|cfsnchash
(braket
id|hash
)braket
suffix:semicolon
id|cncp
op_assign
id|cncp-&gt;hash_next
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cp 0x%x dcp 0x%x cred 0x%x name %s ino %d count %d dev %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|cncp-&gt;cp
comma
(paren
r_int
)paren
id|cncp-&gt;dcp
comma
(paren
r_int
)paren
id|cncp-&gt;cred
comma
id|cncp-&gt;name
comma
id|CTOI
c_func
(paren
id|cncp-&gt;cp
)paren
op_member_access_from_pointer
id|i_count
comma
id|CTOI
c_func
(paren
id|cncp-&gt;cp
)paren
op_member_access_from_pointer
id|i_count
comma
id|CTOI
c_func
(paren
id|cncp-&gt;cp
)paren
op_member_access_from_pointer
id|i_dev
)paren
suffix:semicolon
)brace
)brace
)brace
r_int
DECL|function|cfsnc_get_info
id|cfsnc_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|dummy
)paren
(brace
r_int
id|hash
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
suffix:semicolon
r_struct
id|cfscache
op_star
id|cncp
suffix:semicolon
r_char
id|tmpbuf
(braket
l_int|80
)braket
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
l_int|80
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%-79s&bslash;n&quot;
comma
l_string|&quot;hash  len   volume    vnode   unique             name        ino       pino ct&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfsnc_initialized
)paren
(brace
op_star
id|start
op_assign
id|buffer
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
id|pos
op_assign
l_int|80
suffix:semicolon
r_for
c_loop
(paren
id|hash
op_assign
l_int|0
suffix:semicolon
id|hash
OL
id|cfsnc_hashsize
suffix:semicolon
id|hash
op_increment
)paren
(brace
r_for
c_loop
(paren
id|cncp
op_assign
id|cfsnchash
(braket
id|hash
)braket
dot
id|hash_next
suffix:semicolon
id|cncp
op_ne
(paren
r_struct
id|cfscache
op_star
)paren
op_amp
id|cfsnchash
(braket
id|hash
)braket
suffix:semicolon
id|cncp
op_assign
id|cncp-&gt;hash_next
)paren
(brace
id|pos
op_add_assign
l_int|80
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
r_continue
suffix:semicolon
id|sprintf
c_func
(paren
id|tmpbuf
comma
l_string|&quot;%4d  %3d %8x %8x %8x %16s %10ld %10ld %2d&quot;
comma
id|hash
comma
id|cfsnchash
(braket
id|hash
)braket
dot
id|length
comma
(paren
r_int
)paren
id|cncp-&gt;cp-&gt;c_fid.Volume
comma
(paren
r_int
)paren
id|cncp-&gt;cp-&gt;c_fid.Vnode
comma
(paren
r_int
)paren
id|cncp-&gt;cp-&gt;c_fid.Unique
comma
id|cncp-&gt;name
comma
id|CTOI
c_func
(paren
id|cncp-&gt;cp
)paren
op_member_access_from_pointer
id|i_ino
comma
id|CTOI
c_func
(paren
id|cncp-&gt;dcp
)paren
op_member_access_from_pointer
id|i_ino
comma
id|CTOI
c_func
(paren
id|cncp-&gt;cp
)paren
op_member_access_from_pointer
id|i_count
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;%-79s&bslash;n&quot;
comma
id|tmpbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ge
id|length
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|len
op_ge
id|length
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|begin
op_assign
id|len
op_minus
(paren
id|pos
op_minus
id|offset
)paren
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|begin
suffix:semicolon
id|len
op_sub_assign
id|begin
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
r_int
DECL|function|cfsnc_nc_info
id|cfsnc_nc_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
id|dummy
)paren
(brace
r_int
id|len
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
suffix:semicolon
id|cfsnc_gather_stats
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* this works as long as we are below 1024 characters! */
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;Coda minicache statistics&bslash;n&bslash;n&quot;
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;cfsnc_hits : %d&bslash;n&quot;
comma
id|cfsnc_stat.hits
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;cfsnc_misses : %d&bslash;n&quot;
comma
id|cfsnc_stat.misses
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;cfsnc_enters : %d&bslash;n&quot;
comma
id|cfsnc_stat.enters
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;cfsnc_dbl_enters : %d&bslash;n&quot;
comma
id|cfsnc_stat.dbl_enters
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;cfsnc_long_name_enters : %d&bslash;n&quot;
comma
id|cfsnc_stat.long_name_enters
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;cfsnc_long_name_lookups : %d&bslash;n&quot;
comma
id|cfsnc_stat.long_name_lookups
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;cfsnc_long_remove : %d&bslash;n&quot;
comma
id|cfsnc_stat.long_remove
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;cfsnc_lru_rm : %d&bslash;n&quot;
comma
id|cfsnc_stat.lru_rm
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;cfsnc_zapPfids : %d&bslash;n&quot;
comma
id|cfsnc_stat.zapPfids
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;cfsnc_zapFids : %d&bslash;n&quot;
comma
id|cfsnc_stat.zapFids
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;cfsnc_zapFile : %d&bslash;n&quot;
comma
id|cfsnc_stat.zapFile
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;cfsnc_zapUsers : %d&bslash;n&quot;
comma
id|cfsnc_stat.zapUsers
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;cfsnc_Flushes : %d&bslash;n&quot;
comma
id|cfsnc_stat.Flushes
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;cfsnc_SumLen : %d&bslash;n&quot;
comma
id|cfsnc_stat.Sum_bucket_len
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;cfsnc_Sum2Len : %d&bslash;n&quot;
comma
id|cfsnc_stat.Sum2_bucket_len
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;cfsnc_# 0 len : %d&bslash;n&quot;
comma
id|cfsnc_stat.Num_zero_len
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;cfsnc_MaxLen : %d&bslash;n&quot;
comma
id|cfsnc_stat.Max_bucket_len
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;cfsnc_SearchLen : %d&bslash;n&quot;
comma
id|cfsnc_stat.Search_len
)paren
suffix:semicolon
id|begin
op_assign
id|offset
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|begin
suffix:semicolon
id|len
op_sub_assign
id|begin
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
(brace
id|len
op_assign
id|length
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_void
DECL|function|coda_print_ce
id|coda_print_ce
c_func
(paren
r_struct
id|cfscache
op_star
id|ce
)paren
(brace
id|CDEBUG
c_func
(paren
id|D_CACHE
comma
l_string|&quot;cp 0x%x, dcp 0x%x, name %s, inod 0x%x, ino %d, count %d, dev %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|ce-&gt;cp
comma
(paren
r_int
)paren
id|ce-&gt;dcp
comma
id|ce-&gt;name
comma
(paren
r_int
)paren
id|CTOI
c_func
(paren
id|ce-&gt;cp
)paren
comma
(paren
r_int
)paren
id|CTOI
c_func
(paren
id|ce-&gt;cp
)paren
op_member_access_from_pointer
id|i_ino
comma
id|CTOI
c_func
(paren
id|ce-&gt;cp
)paren
op_member_access_from_pointer
id|i_count
comma
id|CTOI
c_func
(paren
id|ce-&gt;cp
)paren
op_member_access_from_pointer
id|i_dev
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|cfsnc_gather_stats
id|cfsnc_gather_stats
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|max
op_assign
l_int|0
comma
id|sum
op_assign
l_int|0
comma
id|temp
comma
id|zeros
op_assign
l_int|0
comma
id|ave
comma
id|n
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cfsnc_hashsize
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cfsnchash
(braket
id|i
)braket
dot
id|length
)paren
(brace
id|sum
op_add_assign
id|cfsnchash
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
r_else
(brace
id|zeros
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cfsnchash
(braket
id|i
)braket
dot
id|length
OG
id|max
)paren
id|max
op_assign
id|cfsnchash
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
multiline_comment|/*&n; * When computing the Arithmetic mean, only count slots which &n; * are not empty in the distribution.&n; */
id|cfsnc_stat.Sum_bucket_len
op_assign
id|sum
suffix:semicolon
id|cfsnc_stat.Num_zero_len
op_assign
id|zeros
suffix:semicolon
id|cfsnc_stat.Max_bucket_len
op_assign
id|max
suffix:semicolon
r_if
c_cond
(paren
(paren
id|n
op_assign
id|cfsnc_hashsize
op_minus
id|zeros
)paren
OG
l_int|0
)paren
id|ave
op_assign
id|sum
op_div
id|n
suffix:semicolon
r_else
id|ave
op_assign
l_int|0
suffix:semicolon
id|sum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cfsnc_hashsize
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cfsnchash
(braket
id|i
)braket
dot
id|length
)paren
(brace
id|temp
op_assign
id|cfsnchash
(braket
id|i
)braket
dot
id|length
op_minus
id|ave
suffix:semicolon
id|sum
op_add_assign
id|temp
op_star
id|temp
suffix:semicolon
)brace
)brace
id|cfsnc_stat.Sum2_bucket_len
op_assign
id|sum
suffix:semicolon
)brace
multiline_comment|/*&n; * The purpose of this routine is to allow the hash and cache sizes to be&n; * changed dynamically. This should only be used in controlled environments,&n; * it makes no effort to lock other users from accessing the cache while it&n; * is in an improper state (except by turning the cache off).&n; */
r_int
DECL|function|cfsnc_resize
id|cfsnc_resize
c_func
(paren
r_int
id|hashsize
comma
r_int
id|heapsize
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cfsnc_use
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hashsize
op_mod
l_int|2
)paren
op_logical_or
(paren
id|heapsize
op_mod
l_int|2
)paren
)paren
(brace
multiline_comment|/* Illegal hash or cache sizes */
r_return
id|EINVAL
suffix:semicolon
)brace
id|cfsnc_use
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Turn the cache off */
id|cfsnc_force
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* otherwise we can&squot;t flush */
id|cfsnc_flush
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* free any cnodes in the cache */
id|cfsnc_force
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* WARNING: free must happen *before* size is reset */
id|CODA_FREE
c_func
(paren
id|cfsncheap
comma
id|TOTAL_CACHE_SIZE
)paren
suffix:semicolon
id|CODA_FREE
c_func
(paren
id|cfsnchash
comma
id|TOTAL_HASH_SIZE
)paren
suffix:semicolon
id|cfsnc_hashsize
op_assign
id|hashsize
suffix:semicolon
id|cfsnc_size
op_assign
id|heapsize
suffix:semicolon
id|cfsnc_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Set up a cache with the new size */
id|cfsnc_use
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Turn the cache back on */
r_return
l_int|0
suffix:semicolon
)brace
eof
