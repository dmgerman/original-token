multiline_comment|/*&n; *  linux/fs/namei.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; * Some corrections by tytso.&n; */
multiline_comment|/* [Feb 1997 T. Schoebel-Theuer] Complete rewrite of the pathname&n; * lookup logic.&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/namei.h&gt;
multiline_comment|/* This can be removed after the beta phase. */
DECL|macro|CACHE_SUPERVISE
mdefine_line|#define CACHE_SUPERVISE&t;/* debug the correctness of dcache entries */
DECL|macro|DEBUG
macro_line|#undef DEBUG&t;&t;/* some other debugging */
DECL|macro|ACC_MODE
mdefine_line|#define ACC_MODE(x) (&quot;&bslash;000&bslash;004&bslash;002&bslash;006&quot;[(x)&amp;O_ACCMODE])
multiline_comment|/* [Feb-1997 T. Schoebel-Theuer]&n; * Fundamental changes in the pathname lookup mechanisms (namei)&n; * were necessary because of omirr.  The reason is that omirr needs&n; * to know the _real_ pathname, not the user-supplied one, in case&n; * of symlinks (and also when transname replacements occur).&n; *&n; * The new code replaces the old recursive symlink resolution with&n; * an iterative one (in case of non-nested symlink chains).  It does&n; * this by looking up the symlink name from the particular filesystem,&n; * and then follows this name as if it were a user-supplied one.  This&n; * is done solely in the VFS level, such that &lt;fs&gt;_follow_link() is not&n; * used any more and could be removed in future.  As a side effect,&n; * dir_namei(), _namei() and follow_link() are now replaced with a single&n; * function lookup_dentry() that can handle all the special cases of the former&n; * code.&n; *&n; * With the new dcache, the pathname is stored at each inode, at least as&n; * long as the refcount of the inode is positive.  As a side effect, the&n; * size of the dcache depends on the inode cache and thus is dynamic.&n; */
multiline_comment|/* [24-Feb-97 T. Schoebel-Theuer] Side effects caused by new implementation:&n; * New symlink semantics: when open() is called with flags O_CREAT | O_EXCL&n; * and the name already exists in form of a symlink, try to create the new&n; * name indicated by the symlink. The old code always complained that the&n; * name already exists, due to not following the symlink even if its target&n; * is non-existant.  The new semantics affects also mknod() and link() when&n; * the name is a symlink pointing to a non-existant name.&n; *&n; * I don&squot;t know which semantics is the right one, since I have no access&n; * to standards. But I found by trial that HP-UX 9.0 has the full &quot;new&quot;&n; * semantics implemented, while SunOS 4.1.1 and Solaris (SunOS 5.4) have the&n; * &quot;old&quot; one. Personally, I think the new semantics is much more logical.&n; * Note that &quot;ln old new&quot; where &quot;new&quot; is a symlink pointing to a non-existing&n; * file does succeed in both HP-UX and SunOs, but not in Solaris&n; * and in the old Linux semantics.&n; */
DECL|variable|quicklist
r_static
r_char
op_star
id|quicklist
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|quickcount
r_static
r_int
id|quickcount
op_assign
l_int|0
suffix:semicolon
DECL|variable|quicklock
r_struct
id|semaphore
id|quicklock
op_assign
id|MUTEX
suffix:semicolon
multiline_comment|/* Tuning: increase locality by reusing same pages again...&n; * if quicklist becomes too long on low memory machines, either a limit&n; * should be added or after a number of cycles some pages should&n; * be released again ...&n; */
DECL|function|get_page
r_static
r_inline
r_char
op_star
id|get_page
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|res
suffix:semicolon
id|down
c_func
(paren
op_amp
id|quicklock
)paren
suffix:semicolon
id|res
op_assign
id|quicklist
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
macro_line|#ifdef DEBUG
r_char
op_star
id|tmp
op_assign
id|res
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|quickcount
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
op_star
(paren
r_char
op_star
op_star
)paren
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp
)paren
id|printk
c_func
(paren
l_string|&quot;bad quicklist %x&bslash;n&quot;
comma
(paren
r_int
)paren
id|tmp
)paren
suffix:semicolon
macro_line|#endif
id|quicklist
op_assign
op_star
(paren
r_char
op_star
op_star
)paren
id|res
suffix:semicolon
id|quickcount
op_decrement
suffix:semicolon
)brace
r_else
id|res
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|quicklock
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|putname
r_inline
r_void
id|putname
c_func
(paren
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
id|name
)paren
(brace
id|down
c_func
(paren
op_amp
id|quicklock
)paren
suffix:semicolon
op_star
(paren
r_char
op_star
op_star
)paren
id|name
op_assign
id|quicklist
suffix:semicolon
id|quicklist
op_assign
id|name
suffix:semicolon
id|quickcount
op_increment
suffix:semicolon
id|up
c_func
(paren
op_amp
id|quicklock
)paren
suffix:semicolon
)brace
multiline_comment|/* if a quicklist limit is necessary to introduce, call&n;&t; * free_page((unsigned long) name);&n;&t; */
)brace
multiline_comment|/* In order to reduce some races, while at the same time doing additional&n; * checking and hopefully speeding things up, we copy filenames to the&n; * kernel data space before using them..&n; *&n; * POSIX.1 2.4: an empty pathname is invalid (ENOENT).&n; */
DECL|function|do_getname
r_static
r_inline
r_int
id|do_getname
c_func
(paren
r_const
r_char
op_star
id|filename
comma
r_char
op_star
id|page
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
r_int
id|len
op_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|filename
op_ge
id|TASK_SIZE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|segment_eq
c_func
(paren
id|get_fs
c_func
(paren
)paren
comma
id|KERNEL_DS
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|TASK_SIZE
op_minus
(paren
r_int
r_int
)paren
id|filename
OL
id|PAGE_SIZE
)paren
id|len
op_assign
id|TASK_SIZE
op_minus
(paren
r_int
r_int
)paren
id|filename
suffix:semicolon
id|retval
op_assign
id|strncpy_from_user
c_func
(paren
(paren
r_char
op_star
)paren
id|page
comma
id|filename
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|retval
OL
id|len
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|ENAMETOOLONG
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|getname
r_char
op_star
id|getname
c_func
(paren
r_const
r_char
op_star
id|filename
)paren
(brace
r_char
op_star
id|tmp
comma
op_star
id|result
suffix:semicolon
id|result
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|tmp
op_assign
id|get_page
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
r_int
id|retval
op_assign
id|do_getname
c_func
(paren
id|filename
comma
id|tmp
)paren
suffix:semicolon
id|result
op_assign
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|result
op_assign
id|ERR_PTR
c_func
(paren
id|retval
)paren
suffix:semicolon
)brace
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;permission()&n; *&n; * is used to check for read/write/execute permissions on a file.&n; * We use &quot;fsuid&quot; for this, letting us set arbitrary permissions&n; * for filesystem access without changing the &quot;normal&quot; uids which&n; * are used for other things..&n; */
DECL|function|permission
r_int
id|permission
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|mask
)paren
(brace
r_int
id|mode
op_assign
id|inode-&gt;i_mode
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_op
op_logical_and
id|inode-&gt;i_op-&gt;permission
)paren
r_return
id|inode-&gt;i_op
op_member_access_from_pointer
id|permission
c_func
(paren
id|inode
comma
id|mask
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|mask
op_amp
id|S_IWOTH
)paren
op_logical_and
id|IS_RDONLY
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|S_ISREG
c_func
(paren
id|mode
)paren
op_logical_or
id|S_ISDIR
c_func
(paren
id|mode
)paren
op_logical_or
id|S_ISLNK
c_func
(paren
id|mode
)paren
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
multiline_comment|/* Nobody gets write access to a read-only fs */
r_else
r_if
c_cond
(paren
(paren
id|mask
op_amp
id|S_IWOTH
)paren
op_logical_and
id|IS_IMMUTABLE
c_func
(paren
id|inode
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* Nobody gets write access to an immutable file */
r_else
r_if
c_cond
(paren
id|current-&gt;fsuid
op_eq
id|inode-&gt;i_uid
)paren
id|mode
op_rshift_assign
l_int|6
suffix:semicolon
r_else
r_if
c_cond
(paren
id|in_group_p
c_func
(paren
id|inode-&gt;i_gid
)paren
)paren
id|mode
op_rshift_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|mode
op_amp
id|mask
op_amp
l_int|0007
)paren
op_eq
id|mask
)paren
op_logical_or
id|fsuser
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
multiline_comment|/*&n; * get_write_access() gets write permission for a file.&n; * put_write_access() releases this write permission.&n; * This is used for regular files.&n; * We cannot support write (and maybe mmap read-write shared) accesses and&n; * MAP_DENYWRITE mmappings simultaneously. The i_writecount field of an inode&n; * can have the following values:&n; * 0: no writers, no VM_DENYWRITE mappings&n; * &lt; 0: (-i_writecount) vm_area_structs with VM_DENYWRITE set exist&n; * &gt; 0: (i_writecount) users are writing to the file.&n; */
DECL|function|get_write_access
r_int
id|get_write_access
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_writecount
OL
l_int|0
)paren
r_return
op_minus
id|ETXTBSY
suffix:semicolon
id|inode-&gt;i_writecount
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|put_write_access
r_void
id|put_write_access
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|inode-&gt;i_writecount
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called when everything else fails, and we actually have&n; * to go to the low-level filesystem to find out what we should do..&n; *&n; * We get the directory semaphore, and after getting that we also&n; * make sure that nobody added the entry to the dcache in the meantime..&n; */
DECL|function|real_lookup
r_static
r_struct
id|dentry
op_star
id|real_lookup
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_struct
id|qstr
op_star
id|name
)paren
(brace
r_struct
id|dentry
op_star
id|result
suffix:semicolon
r_struct
id|inode
op_star
id|dir
op_assign
id|parent-&gt;d_inode
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
id|result
op_assign
id|d_lookup
c_func
(paren
id|parent
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|d_alloc
c_func
(paren
id|parent
comma
id|name
)paren
suffix:semicolon
id|result
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
)paren
(brace
r_int
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|lookup
c_func
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
id|result
op_assign
id|dentry
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|result
op_assign
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
)brace
)brace
id|up
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Internal lookup() using the new generic dcache.&n; *&n; * Note the revalidation: we have to drop the dcache&n; * lock when we revalidate, so we need to update the&n; * counts around it.&n; */
DECL|function|cached_lookup
r_static
r_struct
id|dentry
op_star
id|cached_lookup
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_struct
id|qstr
op_star
id|name
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|d_lookup
c_func
(paren
id|parent
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
op_logical_and
id|dentry-&gt;d_op
op_logical_and
id|dentry-&gt;d_op-&gt;d_revalidate
)paren
(brace
r_int
id|validated
comma
(paren
op_star
id|revalidate
)paren
(paren
r_struct
id|dentry
op_star
)paren
op_assign
id|dentry-&gt;d_op-&gt;d_revalidate
suffix:semicolon
id|validated
op_assign
id|revalidate
c_func
(paren
id|dentry
)paren
op_logical_or
id|d_invalidate
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|validated
)paren
(brace
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|dentry
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|dentry
suffix:semicolon
)brace
multiline_comment|/*&n; * &quot;.&quot; and &quot;..&quot; are special - &quot;..&quot; especially so because it has to be able&n; * to know about the current root directory and parent relationships&n; */
DECL|function|reserved_lookup
r_static
r_struct
id|dentry
op_star
id|reserved_lookup
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_struct
id|qstr
op_star
id|name
)paren
(brace
r_struct
id|dentry
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|name-&gt;name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
r_switch
c_cond
(paren
id|name-&gt;len
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|name-&gt;name
(braket
l_int|1
)braket
op_ne
l_char|&squot;.&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_ne
id|current-&gt;fs-&gt;root
)paren
id|parent
op_assign
id|parent-&gt;d_covers-&gt;d_parent
suffix:semicolon
multiline_comment|/* fallthrough */
r_case
l_int|1
suffix:colon
id|result
op_assign
id|parent
suffix:semicolon
)brace
)brace
r_return
id|dget
c_func
(paren
id|result
)paren
suffix:semicolon
)brace
DECL|function|do_follow_link
r_static
r_struct
id|dentry
op_star
id|do_follow_link
c_func
(paren
r_struct
id|dentry
op_star
id|base
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_logical_and
id|inode-&gt;i_op
op_logical_and
id|inode-&gt;i_op-&gt;follow_link
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;link_count
OL
l_int|5
)paren
(brace
r_struct
id|dentry
op_star
id|result
suffix:semicolon
id|current-&gt;link_count
op_increment
suffix:semicolon
multiline_comment|/* This eats the base */
id|result
op_assign
id|inode-&gt;i_op
op_member_access_from_pointer
id|follow_link
c_func
(paren
id|inode
comma
id|base
)paren
suffix:semicolon
id|current-&gt;link_count
op_decrement
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|dentry
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ELOOP
)paren
suffix:semicolon
)brace
id|dput
c_func
(paren
id|base
)paren
suffix:semicolon
r_return
id|dentry
suffix:semicolon
)brace
DECL|function|follow_mount
r_static
r_inline
r_struct
id|dentry
op_star
id|follow_mount
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|dentry
op_star
id|mnt
op_assign
id|dentry-&gt;d_mounts
suffix:semicolon
r_if
c_cond
(paren
id|mnt
op_ne
id|dentry
)paren
(brace
id|dget
c_func
(paren
id|mnt
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|dentry
op_assign
id|mnt
suffix:semicolon
)brace
r_return
id|dentry
suffix:semicolon
)brace
multiline_comment|/*&n; * Name resolution.&n; *&n; * This is the basic name resolution function, turning a pathname&n; * into the final dentry.&n; */
DECL|function|lookup_dentry
r_struct
id|dentry
op_star
id|lookup_dentry
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|dentry
op_star
id|base
comma
r_int
id|follow_link
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_if
c_cond
(paren
op_star
id|name
op_eq
l_char|&squot;/&squot;
)paren
(brace
r_if
c_cond
(paren
id|base
)paren
id|dput
c_func
(paren
id|base
)paren
suffix:semicolon
id|base
op_assign
id|dget
c_func
(paren
id|current-&gt;fs-&gt;root
)paren
suffix:semicolon
r_do
(brace
id|name
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|name
op_eq
l_char|&squot;/&squot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
(brace
id|base
op_assign
id|dget
c_func
(paren
id|current-&gt;fs-&gt;pwd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|name
)paren
r_goto
id|return_base
suffix:semicolon
multiline_comment|/* At this point we know we have a real path component. */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|len
comma
id|err
suffix:semicolon
r_int
r_int
id|hash
suffix:semicolon
r_struct
id|qstr
id|this
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_char
id|c
comma
id|follow
suffix:semicolon
id|dentry
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOENT
)paren
suffix:semicolon
id|inode
op_assign
id|base-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_break
suffix:semicolon
id|dentry
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOTDIR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_op
op_logical_or
op_logical_neg
id|inode-&gt;i_op-&gt;lookup
)paren
r_break
suffix:semicolon
id|err
op_assign
id|permission
c_func
(paren
id|inode
comma
id|MAY_EXEC
)paren
suffix:semicolon
id|dentry
op_assign
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_break
suffix:semicolon
id|this.name
op_assign
id|name
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
id|c
op_assign
op_star
id|name
suffix:semicolon
id|hash
op_assign
id|init_name_hash
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
id|len
op_increment
suffix:semicolon
id|name
op_increment
suffix:semicolon
id|hash
op_assign
id|partial_name_hash
c_func
(paren
id|c
comma
id|hash
)paren
suffix:semicolon
id|c
op_assign
op_star
id|name
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c
op_logical_and
(paren
id|c
op_ne
l_char|&squot;/&squot;
)paren
)paren
suffix:semicolon
id|this.len
op_assign
id|len
suffix:semicolon
id|this.hash
op_assign
id|end_name_hash
c_func
(paren
id|hash
)paren
suffix:semicolon
multiline_comment|/* remove trailing slashes? */
id|follow
op_assign
id|follow_link
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
(brace
id|follow
op_or_assign
id|c
suffix:semicolon
r_do
(brace
id|c
op_assign
op_star
op_increment
id|name
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c
op_eq
l_char|&squot;/&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * See if the low-level filesystem might want&n;&t;&t; * to use its own hash..&n;&t;&t; */
r_if
c_cond
(paren
id|base-&gt;d_op
op_logical_and
id|base-&gt;d_op-&gt;d_hash
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
id|base-&gt;d_op
op_member_access_from_pointer
id|d_hash
c_func
(paren
id|base
comma
op_amp
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
id|dentry
op_assign
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* This does the actual lookups.. */
id|dentry
op_assign
id|reserved_lookup
c_func
(paren
id|base
comma
op_amp
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
(brace
id|dentry
op_assign
id|cached_lookup
c_func
(paren
id|base
comma
op_amp
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
(brace
id|dentry
op_assign
id|real_lookup
c_func
(paren
id|base
comma
op_amp
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Check mountpoints.. */
id|dentry
op_assign
id|follow_mount
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|follow
)paren
r_break
suffix:semicolon
id|base
op_assign
id|do_follow_link
c_func
(paren
id|base
comma
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_logical_and
op_logical_neg
id|IS_ERR
c_func
(paren
id|base
)paren
)paren
r_continue
suffix:semicolon
id|return_base
suffix:colon
r_return
id|base
suffix:semicolon
)brace
id|dput
c_func
(paren
id|base
)paren
suffix:semicolon
r_return
id|dentry
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;namei()&n; *&n; * is used by most simple commands to get the inode of a specified name.&n; * Open, link etc use their own routines, but this is enough for things&n; * like &squot;chmod&squot; etc.&n; *&n; * namei exists in two versions: namei/lnamei. The only difference is&n; * that namei follows links, while lnamei does not.&n; */
DECL|function|__namei
r_struct
id|dentry
op_star
id|__namei
c_func
(paren
r_const
r_char
op_star
id|pathname
comma
r_int
id|follow_link
)paren
(brace
r_char
op_star
id|name
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|check_dcache_memory
c_func
(paren
)paren
suffix:semicolon
id|name
op_assign
id|getname
c_func
(paren
id|pathname
)paren
suffix:semicolon
id|dentry
op_assign
(paren
r_struct
id|dentry
op_star
)paren
id|name
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|name
)paren
)paren
(brace
id|dentry
op_assign
id|lookup_dentry
c_func
(paren
id|name
comma
l_int|NULL
comma
id|follow_link
)paren
suffix:semicolon
id|putname
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_inode
)paren
(brace
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|dentry
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOENT
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
id|dentry
suffix:semicolon
)brace
DECL|function|get_parent
r_static
r_inline
r_struct
id|dentry
op_star
id|get_parent
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_return
id|dget
c_func
(paren
id|dentry-&gt;d_parent
)paren
suffix:semicolon
)brace
DECL|function|unlock_dir
r_static
r_inline
r_void
id|unlock_dir
c_func
(paren
r_struct
id|dentry
op_star
id|dir
)paren
(brace
id|up
c_func
(paren
op_amp
id|dir-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Locking the parent is needed to:&n; *  - serialize directory operations&n; *  - make sure the parent doesn&squot;t change from&n; *    under us in the middle of an operation.&n; *&n; * NOTE! Right now we&squot;d rather use a &quot;struct inode&quot;&n; * for this, but as I expect things to move toward&n; * using dentries instead for most things it is&n; * probably better to start with the conceptually&n; * better interface of relying on a path of dentries.&n; */
DECL|function|lock_parent
r_static
r_inline
r_struct
id|dentry
op_star
id|lock_parent
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|dentry
op_star
id|dir
op_assign
id|dget
c_func
(paren
id|dentry-&gt;d_parent
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
multiline_comment|/* Un-hashed or moved?  Punt if so.. */
r_if
c_cond
(paren
id|dir
op_ne
id|dentry-&gt;d_parent
op_logical_or
id|list_empty
c_func
(paren
op_amp
id|dentry-&gt;d_hash
)paren
)paren
(brace
r_if
c_cond
(paren
id|dir
op_ne
id|dentry
)paren
(brace
id|unlock_dir
c_func
(paren
id|dir
)paren
suffix:semicolon
id|dir
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOENT
)paren
suffix:semicolon
)brace
)brace
r_return
id|dir
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;open_namei()&n; *&n; * namei for open - this is in fact almost the whole open-routine.&n; *&n; * Note that the low bits of &quot;flag&quot; aren&squot;t the same as in the open&n; * system call - they are 00 - no permissions needed&n; *&t;&t;&t;  01 - read permission needed&n; *&t;&t;&t;  10 - write permission needed&n; *&t;&t;&t;  11 - read/write permissions needed&n; * which is a lot more logical, and also allows the &quot;no perm&quot; needed&n; * for symlinks (where the permissions are checked later).&n; */
DECL|function|open_namei
r_struct
id|dentry
op_star
id|open_namei
c_func
(paren
r_const
r_char
op_star
id|pathname
comma
r_int
id|flag
comma
r_int
id|mode
)paren
(brace
r_int
id|acc_mode
comma
id|error
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|check_dcache_memory
c_func
(paren
)paren
suffix:semicolon
id|mode
op_and_assign
id|S_IALLUGO
op_amp
op_complement
id|current-&gt;fs-&gt;umask
suffix:semicolon
id|mode
op_or_assign
id|S_IFREG
suffix:semicolon
id|dentry
op_assign
id|lookup_dentry
c_func
(paren
id|pathname
comma
l_int|NULL
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
r_return
id|dentry
suffix:semicolon
id|acc_mode
op_assign
id|ACC_MODE
c_func
(paren
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|O_CREAT
)paren
(brace
r_struct
id|dentry
op_star
id|dir
suffix:semicolon
id|dir
op_assign
id|lock_parent
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dir
)paren
)paren
r_goto
m_exit
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The existence test must be done _after_ getting the directory&n;&t;&t; * semaphore - the dentry might otherwise change.&n;&t;&t; */
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
(brace
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|O_EXCL
)paren
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|dir-&gt;d_inode
)paren
)paren
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;d_inode-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;d_inode-&gt;i_op-&gt;create
)paren
id|error
op_assign
op_minus
id|EACCES
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|error
op_assign
id|permission
c_func
(paren
id|dir-&gt;d_inode
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|dir-&gt;d_inode-&gt;i_sb
op_logical_and
id|dir-&gt;d_inode-&gt;i_sb-&gt;dq_op
)paren
id|dir-&gt;d_inode-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|dir-&gt;d_inode
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;d_inode-&gt;i_op
op_member_access_from_pointer
id|create
c_func
(paren
id|dir-&gt;d_inode
comma
id|dentry
comma
id|mode
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t check for write permission, don&squot;t truncate */
id|acc_mode
op_assign
l_int|0
suffix:semicolon
id|flag
op_and_assign
op_complement
id|O_TRUNC
suffix:semicolon
)brace
id|unlock_dir
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
m_exit
suffix:semicolon
id|error
op_assign
op_minus
id|EISDIR
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
(paren
id|flag
op_amp
id|FMODE_WRITE
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|error
op_assign
id|permission
c_func
(paren
id|inode
comma
id|acc_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
multiline_comment|/*&n;&t; * FIFO&squot;s, sockets and device files are special: they don&squot;t&n;&t; * actually live on the filesystem itself, and as such you&n;&t; * can write to them even if the filesystem is read-only.&n;&t; */
r_if
c_cond
(paren
id|S_ISFIFO
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISSOCK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|flag
op_and_assign
op_complement
id|O_TRUNC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISCHR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|IS_NODEV
c_func
(paren
id|inode
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|flag
op_and_assign
op_complement
id|O_TRUNC
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|flag
op_amp
l_int|2
)paren
)paren
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * An append-only file must be opened in append mode for writing.&n;&t; */
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|inode
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|FMODE_WRITE
)paren
op_logical_and
op_logical_neg
(paren
id|flag
op_amp
id|O_APPEND
)paren
)paren
r_goto
m_exit
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|O_TRUNC
)paren
r_goto
m_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flag
op_amp
id|O_TRUNC
)paren
(brace
id|error
op_assign
id|get_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Refuse to truncate files with mandatory locks held on them.&n;&t;&t; */
id|error
op_assign
id|locks_verify_locked
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_sb
op_logical_and
id|inode-&gt;i_sb-&gt;dq_op
)paren
id|inode-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|inode
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|do_truncate
c_func
(paren
id|inode
comma
l_int|0
)paren
suffix:semicolon
)brace
id|put_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flag
op_amp
id|FMODE_WRITE
)paren
r_if
c_cond
(paren
id|inode-&gt;i_sb
op_logical_and
id|inode-&gt;i_sb-&gt;dq_op
)paren
id|inode-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|inode
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_return
id|dentry
suffix:semicolon
m_exit
suffix:colon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
DECL|function|do_mknod
r_struct
id|dentry
op_star
id|do_mknod
c_func
(paren
r_const
r_char
op_star
id|filename
comma
r_int
id|mode
comma
id|dev_t
id|dev
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|dentry
op_star
id|dir
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
comma
op_star
id|retval
suffix:semicolon
id|mode
op_and_assign
op_complement
id|current-&gt;fs-&gt;umask
suffix:semicolon
id|dentry
op_assign
id|lookup_dentry
c_func
(paren
id|filename
comma
l_int|NULL
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
r_return
id|dentry
suffix:semicolon
id|dir
op_assign
id|lock_parent
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|retval
op_assign
id|dir
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dir
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|retval
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EEXIST
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
r_goto
id|exit_lock
suffix:semicolon
id|retval
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EROFS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|dir-&gt;d_inode
)paren
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
id|permission
c_func
(paren
id|dir-&gt;d_inode
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
suffix:semicolon
id|retval
op_assign
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_lock
suffix:semicolon
id|retval
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EPERM
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;d_inode-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;d_inode-&gt;i_op-&gt;mknod
)paren
r_goto
id|exit_lock
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;d_inode-&gt;i_sb
op_logical_and
id|dir-&gt;d_inode-&gt;i_sb-&gt;dq_op
)paren
id|dir-&gt;d_inode-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|dir-&gt;d_inode
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;d_inode-&gt;i_op
op_member_access_from_pointer
id|mknod
c_func
(paren
id|dir-&gt;d_inode
comma
id|dentry
comma
id|mode
comma
id|dev
)paren
suffix:semicolon
id|retval
op_assign
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|retval
op_assign
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|unlock_dir
c_func
(paren
id|dir
)paren
suffix:semicolon
m_exit
suffix:colon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|sys_mknod
id|asmlinkage
r_int
id|sys_mknod
c_func
(paren
r_const
r_char
op_star
id|filename
comma
r_int
id|mode
comma
id|dev_t
id|dev
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
op_logical_or
(paren
op_logical_neg
id|S_ISFIFO
c_func
(paren
id|mode
)paren
op_logical_and
op_logical_neg
id|fsuser
c_func
(paren
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|mode
op_amp
id|S_IFMT
)paren
(brace
r_case
l_int|0
suffix:colon
id|mode
op_or_assign
id|S_IFREG
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFREG
suffix:colon
r_case
id|S_IFCHR
suffix:colon
r_case
id|S_IFBLK
suffix:colon
r_case
id|S_IFIFO
suffix:colon
r_case
id|S_IFSOCK
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|out
suffix:semicolon
)brace
id|tmp
op_assign
id|getname
c_func
(paren
id|filename
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|tmp
)paren
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|do_mknod
c_func
(paren
id|tmp
comma
id|mode
comma
id|dev
)paren
suffix:semicolon
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
(brace
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Look out: this function may change a normal dentry&n; * into a directory dentry (different size)..&n; */
DECL|function|do_mkdir
r_static
r_inline
r_int
id|do_mkdir
c_func
(paren
r_const
r_char
op_star
id|pathname
comma
r_int
id|mode
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|dentry
op_star
id|dir
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|dentry
op_assign
id|lookup_dentry
c_func
(paren
id|pathname
comma
l_int|NULL
comma
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|dir
op_assign
id|lock_parent
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dir
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|dir-&gt;d_inode
)paren
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
id|permission
c_func
(paren
id|dir-&gt;d_inode
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;d_inode-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;d_inode-&gt;i_op-&gt;mkdir
)paren
r_goto
id|exit_lock
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;d_inode-&gt;i_sb
op_logical_and
id|dir-&gt;d_inode-&gt;i_sb-&gt;dq_op
)paren
id|dir-&gt;d_inode-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|dir-&gt;d_inode
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|mode
op_and_assign
l_int|0777
op_amp
op_complement
id|current-&gt;fs-&gt;umask
suffix:semicolon
id|error
op_assign
id|dir-&gt;d_inode-&gt;i_op
op_member_access_from_pointer
id|mkdir
c_func
(paren
id|dir-&gt;d_inode
comma
id|dentry
comma
id|mode
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|unlock_dir
c_func
(paren
id|dir
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_mkdir
id|asmlinkage
r_int
id|sys_mkdir
c_func
(paren
r_const
r_char
op_star
id|pathname
comma
r_int
id|mode
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|tmp
op_assign
id|getname
c_func
(paren
id|pathname
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|tmp
)paren
)paren
(brace
id|error
op_assign
id|do_mkdir
c_func
(paren
id|tmp
comma
id|mode
)paren
suffix:semicolon
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_rmdir
r_static
r_inline
r_int
id|do_rmdir
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|dentry
op_star
id|dir
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|dentry
op_assign
id|lookup_dentry
c_func
(paren
id|name
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|dir
op_assign
id|lock_parent
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dir
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_inode
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|dir-&gt;d_inode
)paren
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
id|permission
c_func
(paren
id|dir-&gt;d_inode
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_lock
suffix:semicolon
multiline_comment|/*&n;&t; * A subdirectory cannot be removed from an append-only directory.&n;&t; */
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|dir-&gt;d_inode
)paren
)paren
r_goto
id|exit_lock
suffix:semicolon
multiline_comment|/* Disallow removals of mountpoints. */
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|dentry
op_eq
id|dir
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;d_inode-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;d_inode-&gt;i_op-&gt;rmdir
)paren
r_goto
id|exit_lock
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;d_inode-&gt;i_sb
op_logical_and
id|dir-&gt;d_inode-&gt;i_sb-&gt;dq_op
)paren
id|dir-&gt;d_inode-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|dir-&gt;d_inode
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;d_inode-&gt;i_op
op_member_access_from_pointer
id|rmdir
c_func
(paren
id|dir-&gt;d_inode
comma
id|dentry
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|unlock_dir
c_func
(paren
id|dir
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_rmdir
id|asmlinkage
r_int
id|sys_rmdir
c_func
(paren
r_const
r_char
op_star
id|pathname
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|tmp
op_assign
id|getname
c_func
(paren
id|pathname
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|tmp
)paren
)paren
(brace
id|error
op_assign
id|do_rmdir
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_unlink
r_static
r_inline
r_int
id|do_unlink
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|dentry
op_star
id|dir
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|dentry
op_assign
id|lookup_dentry
c_func
(paren
id|name
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|dir
op_assign
id|lock_parent
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dir
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_inode
)paren
r_goto
id|exit_lock
suffix:semicolon
multiline_comment|/* Mount point? */
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|dentry
op_eq
id|dir
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|dir-&gt;d_inode
)paren
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
id|permission
c_func
(paren
id|dir-&gt;d_inode
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_lock
suffix:semicolon
multiline_comment|/*&n;&t; * A file cannot be removed from an append-only directory.&n;&t; */
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|dir-&gt;d_inode
)paren
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;d_inode-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;d_inode-&gt;i_op-&gt;unlink
)paren
r_goto
id|exit_lock
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;d_inode-&gt;i_sb
op_logical_and
id|dir-&gt;d_inode-&gt;i_sb-&gt;dq_op
)paren
id|dir-&gt;d_inode-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|dir-&gt;d_inode
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;d_inode-&gt;i_op
op_member_access_from_pointer
id|unlink
c_func
(paren
id|dir-&gt;d_inode
comma
id|dentry
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|unlock_dir
c_func
(paren
id|dir
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_unlink
id|asmlinkage
r_int
id|sys_unlink
c_func
(paren
r_const
r_char
op_star
id|pathname
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|tmp
op_assign
id|getname
c_func
(paren
id|pathname
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|tmp
)paren
)paren
(brace
id|error
op_assign
id|do_unlink
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_symlink
r_static
r_inline
r_int
id|do_symlink
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|dentry
op_star
id|dir
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|dentry
op_assign
id|lookup_dentry
c_func
(paren
id|newname
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|dir
op_assign
id|lock_parent
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dir
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|dir-&gt;d_inode
)paren
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
id|permission
c_func
(paren
id|dir-&gt;d_inode
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;d_inode-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;d_inode-&gt;i_op-&gt;symlink
)paren
r_goto
id|exit_lock
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;d_inode-&gt;i_sb
op_logical_and
id|dir-&gt;d_inode-&gt;i_sb-&gt;dq_op
)paren
id|dir-&gt;d_inode-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|dir-&gt;d_inode
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;d_inode-&gt;i_op
op_member_access_from_pointer
id|symlink
c_func
(paren
id|dir-&gt;d_inode
comma
id|dentry
comma
id|oldname
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|unlock_dir
c_func
(paren
id|dir
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_symlink
id|asmlinkage
r_int
id|sys_symlink
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|from
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|from
op_assign
id|getname
c_func
(paren
id|oldname
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|from
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|from
)paren
)paren
(brace
r_char
op_star
id|to
suffix:semicolon
id|to
op_assign
id|getname
c_func
(paren
id|newname
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|to
)paren
)paren
(brace
id|error
op_assign
id|do_symlink
c_func
(paren
id|from
comma
id|to
)paren
suffix:semicolon
id|putname
c_func
(paren
id|to
)paren
suffix:semicolon
)brace
id|putname
c_func
(paren
id|from
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_link
r_static
r_inline
r_int
id|do_link
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_struct
id|dentry
op_star
id|old_dentry
comma
op_star
id|new_dentry
comma
op_star
id|dir
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|error
suffix:semicolon
id|old_dentry
op_assign
id|lookup_dentry
c_func
(paren
id|oldname
comma
l_int|NULL
comma
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|old_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|old_dentry
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|new_dentry
op_assign
id|lookup_dentry
c_func
(paren
id|newname
comma
l_int|NULL
comma
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|new_dentry
)paren
)paren
r_goto
id|exit_old
suffix:semicolon
id|dir
op_assign
id|lock_parent
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dir
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|inode
op_assign
id|old_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|new_dentry-&gt;d_inode
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|dir-&gt;d_inode
)paren
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EXDEV
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;d_inode-&gt;i_dev
op_ne
id|inode-&gt;i_dev
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
id|permission
c_func
(paren
id|dir-&gt;d_inode
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_lock
suffix:semicolon
multiline_comment|/*&n;&t; * A link to an append-only or immutable file cannot be created.&n;&t; */
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|inode
)paren
op_logical_or
id|IS_IMMUTABLE
c_func
(paren
id|inode
)paren
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;d_inode-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;d_inode-&gt;i_op-&gt;link
)paren
r_goto
id|exit_lock
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;d_inode-&gt;i_sb
op_logical_and
id|dir-&gt;d_inode-&gt;i_sb-&gt;dq_op
)paren
id|dir-&gt;d_inode-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|dir-&gt;d_inode
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;d_inode-&gt;i_op
op_member_access_from_pointer
id|link
c_func
(paren
id|inode
comma
id|dir-&gt;d_inode
comma
id|new_dentry
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|unlock_dir
c_func
(paren
id|dir
)paren
suffix:semicolon
id|dput
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
id|exit_old
suffix:colon
id|dput
c_func
(paren
id|old_dentry
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_link
id|asmlinkage
r_int
id|sys_link
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|from
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|from
op_assign
id|getname
c_func
(paren
id|oldname
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|from
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|from
)paren
)paren
(brace
r_char
op_star
id|to
suffix:semicolon
id|to
op_assign
id|getname
c_func
(paren
id|newname
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|to
)paren
)paren
(brace
id|error
op_assign
id|do_link
c_func
(paren
id|from
comma
id|to
)paren
suffix:semicolon
id|putname
c_func
(paren
id|to
)paren
suffix:semicolon
)brace
id|putname
c_func
(paren
id|from
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Whee.. Deadlock country. Happily there is only one VFS&n; * operation that does this..&n; */
DECL|function|double_lock
r_static
r_inline
r_void
id|double_lock
c_func
(paren
r_struct
id|dentry
op_star
id|d1
comma
r_struct
id|dentry
op_star
id|d2
)paren
(brace
r_struct
id|semaphore
op_star
id|s1
op_assign
op_amp
id|d1-&gt;d_inode-&gt;i_sem
suffix:semicolon
r_struct
id|semaphore
op_star
id|s2
op_assign
op_amp
id|d2-&gt;d_inode-&gt;i_sem
suffix:semicolon
r_if
c_cond
(paren
id|s1
op_ne
id|s2
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|s1
OL
(paren
r_int
r_int
)paren
id|s2
)paren
(brace
r_struct
id|semaphore
op_star
id|tmp
op_assign
id|s2
suffix:semicolon
id|s2
op_assign
id|s1
suffix:semicolon
id|s1
op_assign
id|tmp
suffix:semicolon
)brace
id|down
c_func
(paren
id|s1
)paren
suffix:semicolon
)brace
id|down
c_func
(paren
id|s2
)paren
suffix:semicolon
)brace
DECL|function|double_unlock
r_static
r_inline
r_void
id|double_unlock
c_func
(paren
r_struct
id|dentry
op_star
id|d1
comma
r_struct
id|dentry
op_star
id|d2
)paren
(brace
r_struct
id|semaphore
op_star
id|s1
op_assign
op_amp
id|d1-&gt;d_inode-&gt;i_sem
suffix:semicolon
r_struct
id|semaphore
op_star
id|s2
op_assign
op_amp
id|d2-&gt;d_inode-&gt;i_sem
suffix:semicolon
id|up
c_func
(paren
id|s1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s1
op_ne
id|s2
)paren
id|up
c_func
(paren
id|s2
)paren
suffix:semicolon
id|dput
c_func
(paren
id|d1
)paren
suffix:semicolon
id|dput
c_func
(paren
id|d2
)paren
suffix:semicolon
)brace
DECL|function|do_rename
r_static
r_inline
r_int
id|do_rename
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|dentry
op_star
id|old_dir
comma
op_star
id|new_dir
suffix:semicolon
r_struct
id|dentry
op_star
id|old_dentry
comma
op_star
id|new_dentry
suffix:semicolon
id|old_dentry
op_assign
id|lookup_dentry
c_func
(paren
id|oldname
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|old_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|old_dentry
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|new_dentry
op_assign
id|lookup_dentry
c_func
(paren
id|newname
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|new_dentry
)paren
)paren
r_goto
id|exit_old
suffix:semicolon
id|new_dir
op_assign
id|get_parent
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
id|old_dir
op_assign
id|get_parent
c_func
(paren
id|old_dentry
)paren
suffix:semicolon
id|double_lock
c_func
(paren
id|new_dir
comma
id|old_dir
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old_dentry-&gt;d_inode
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
id|permission
c_func
(paren
id|old_dir-&gt;d_inode
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
id|permission
c_func
(paren
id|new_dir-&gt;d_inode
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_lock
suffix:semicolon
multiline_comment|/* Disallow moves of mountpoints. */
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|old_dir
op_eq
id|old_dentry
op_logical_or
id|new_dir
op_eq
id|new_dentry
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EXDEV
suffix:semicolon
r_if
c_cond
(paren
id|new_dir-&gt;d_inode-&gt;i_dev
op_ne
id|old_dir-&gt;d_inode-&gt;i_dev
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|new_dir-&gt;d_inode
)paren
op_logical_or
id|IS_RDONLY
c_func
(paren
id|old_dir-&gt;d_inode
)paren
)paren
r_goto
id|exit_lock
suffix:semicolon
multiline_comment|/*&n;&t; * A file cannot be removed from an append-only directory.&n;&t; */
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|old_dir-&gt;d_inode
)paren
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old_dir-&gt;d_inode-&gt;i_op
op_logical_or
op_logical_neg
id|old_dir-&gt;d_inode-&gt;i_op-&gt;rename
)paren
r_goto
id|exit_lock
suffix:semicolon
r_if
c_cond
(paren
id|new_dir-&gt;d_inode-&gt;i_sb
op_logical_and
id|new_dir-&gt;d_inode-&gt;i_sb-&gt;dq_op
)paren
id|new_dir-&gt;d_inode-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|new_dir-&gt;d_inode
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|old_dir-&gt;d_inode-&gt;i_op
op_member_access_from_pointer
id|rename
c_func
(paren
id|old_dir-&gt;d_inode
comma
id|old_dentry
comma
id|new_dir-&gt;d_inode
comma
id|new_dentry
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|double_unlock
c_func
(paren
id|new_dir
comma
id|old_dir
)paren
suffix:semicolon
id|dput
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
id|exit_old
suffix:colon
id|dput
c_func
(paren
id|old_dentry
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_rename
id|asmlinkage
r_int
id|sys_rename
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|from
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|from
op_assign
id|getname
c_func
(paren
id|oldname
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|from
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|from
)paren
)paren
(brace
r_char
op_star
id|to
suffix:semicolon
id|to
op_assign
id|getname
c_func
(paren
id|newname
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|to
)paren
)paren
(brace
id|error
op_assign
id|do_rename
c_func
(paren
id|from
comma
id|to
)paren
suffix:semicolon
id|putname
c_func
(paren
id|to
)paren
suffix:semicolon
)brace
id|putname
c_func
(paren
id|from
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
eof
