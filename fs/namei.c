multiline_comment|/*&n; *  linux/fs/namei.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; * Some corrections by tytso.&n; */
multiline_comment|/* [Feb 1997 T. Schoebel-Theuer] Complete rewrite of the pathname&n; * lookup logic.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/dalloc.h&gt;
macro_line|#include &lt;linux/nametrans.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/omirr.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/namei.h&gt;
multiline_comment|/* This can be removed after the beta phase. */
DECL|macro|CACHE_SUPERVISE
mdefine_line|#define CACHE_SUPERVISE&t;/* debug the correctness of dcache entries */
DECL|macro|DEBUG
macro_line|#undef DEBUG&t;&t;/* some other debugging */
multiline_comment|/* local flags for __namei() */
DECL|macro|NAM_SEMLOCK
mdefine_line|#define NAM_SEMLOCK        8 /* set a semlock on the last dir */
DECL|macro|NAM_TRANSCREATE
mdefine_line|#define NAM_TRANSCREATE   16 /* last component may be created, try &quot;=CREATE#&quot; suffix*/
DECL|macro|NAM_NO_TRAILSLASH
mdefine_line|#define NAM_NO_TRAILSLASH 32 /* disallow trailing slashes by returning EISDIR */
DECL|macro|ACC_MODE
mdefine_line|#define ACC_MODE(x) (&quot;&bslash;000&bslash;004&bslash;002&bslash;006&quot;[(x)&amp;O_ACCMODE])
multiline_comment|/* [Feb-1997 T. Schoebel-Theuer]&n; * Fundamental changes in the pathname lookup mechanisms (namei)&n; * were necessary because of omirr.  The reason is that omirr needs&n; * to know the _real_ pathname, not the user-supplied one, in case&n; * of symlinks (and also when transname replacements occur).&n; *&n; * The new code replaces the old recursive symlink resolution with&n; * an iterative one (in case of non-nested symlink chains).  It does&n; * this by looking up the symlink name from the particular filesystem,&n; * and then follows this name as if it were a user-supplied one.  This&n; * is done solely in the VFS level, such that &lt;fs&gt;_follow_link() is not&n; * used any more and could be removed in future.  As a side effect,&n; * dir_namei(), _namei() and follow_link() are now replaced with a single&n; * function __namei() that can handle all the special cases of the former&n; * code.&n; *&n; * With the new dcache, the pathname is stored at each inode, at least as&n; * long as the refcount of the inode is positive.  As a side effect, the&n; * size of the dcache depends on the inode cache and thus is dynamic.&n; */
multiline_comment|/* [24-Feb-97 T. Schoebel-Theuer] Side effects caused by new implementation:&n; * New symlink semantics: when open() is called with flags O_CREAT | O_EXCL&n; * and the name already exists in form of a symlink, try to create the new&n; * name indicated by the symlink. The old code always complained that the&n; * name already exists, due to not following the symlink even if its target&n; * is non-existant.  The new semantics affects also mknod() and link() when&n; * the name is a symlink pointing to a non-existant name.&n; *&n; * I don&squot;t know which semantics is the right one, since I have no access&n; * to standards. But I found by trial that HP-UX 9.0 has the full &quot;new&quot;&n; * semantics implemented, while SunOS 4.1.1 and Solaris (SunOS 5.4) have the&n; * &quot;old&quot; one. Personally, I think the new semantics is much more logical.&n; * Note that &quot;ln old new&quot; where &quot;new&quot; is a symlink pointing to a non-existing&n; * file does succeed in both HP-UX and SunOs, but not in Solaris&n; * and in the old Linux semantics.&n; */
DECL|variable|quicklist
r_static
r_char
op_star
id|quicklist
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|quickcount
r_static
r_int
id|quickcount
op_assign
l_int|0
suffix:semicolon
DECL|variable|quicklock
r_struct
id|semaphore
id|quicklock
op_assign
id|MUTEX
suffix:semicolon
multiline_comment|/* Tuning: increase locality by reusing same pages again...&n; * if quicklist becomes too long on low memory machines, either a limit&n; * should be added or after a number of cycles some pages should&n; * be released again ...&n; */
DECL|function|get_page
r_static
r_inline
r_char
op_star
id|get_page
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|res
suffix:semicolon
id|down
c_func
(paren
op_amp
id|quicklock
)paren
suffix:semicolon
id|res
op_assign
id|quicklist
suffix:semicolon
r_if
c_cond
(paren
id|res
)paren
(brace
macro_line|#ifdef DEBUG
r_char
op_star
id|tmp
op_assign
id|res
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|quickcount
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
op_star
(paren
r_char
op_star
op_star
)paren
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bad quicklist %x&bslash;n&quot;
comma
(paren
r_int
)paren
id|tmp
)paren
suffix:semicolon
)brace
macro_line|#endif
id|quicklist
op_assign
op_star
(paren
r_char
op_star
op_star
)paren
id|res
suffix:semicolon
id|quickcount
op_decrement
suffix:semicolon
)brace
r_else
id|res
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|quicklock
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|putname
r_inline
r_void
id|putname
c_func
(paren
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
id|name
)paren
(brace
id|down
c_func
(paren
op_amp
id|quicklock
)paren
suffix:semicolon
op_star
(paren
r_char
op_star
op_star
)paren
id|name
op_assign
id|quicklist
suffix:semicolon
id|quicklist
op_assign
id|name
suffix:semicolon
id|quickcount
op_increment
suffix:semicolon
id|up
c_func
(paren
op_amp
id|quicklock
)paren
suffix:semicolon
)brace
multiline_comment|/* if a quicklist limit is necessary to introduce, call&n;&t; * free_page((unsigned long) name);&n;&t; */
)brace
multiline_comment|/* In order to reduce some races, while at the same time doing additional&n; * checking and hopefully speeding things up, we copy filenames to the&n; * kernel data space before using them..&n; *&n; * POSIX.1 2.4: an empty pathname is invalid (ENOENT).&n; */
DECL|function|do_getname
r_static
r_inline
r_int
id|do_getname
c_func
(paren
r_const
r_char
op_star
id|filename
comma
r_char
op_star
id|page
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
r_int
id|len
op_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|filename
op_ge
id|TASK_SIZE
)paren
(brace
r_if
c_cond
(paren
id|get_fs
c_func
(paren
)paren
op_ne
id|KERNEL_DS
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|TASK_SIZE
op_minus
(paren
r_int
r_int
)paren
id|filename
OL
id|PAGE_SIZE
)paren
id|len
op_assign
id|TASK_SIZE
op_minus
(paren
r_int
r_int
)paren
id|filename
suffix:semicolon
id|retval
op_assign
id|strncpy_from_user
c_func
(paren
(paren
r_char
op_star
)paren
id|page
comma
id|filename
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|retval
OL
id|len
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|ENAMETOOLONG
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|getname
r_int
id|getname
c_func
(paren
r_const
r_char
op_star
id|filename
comma
r_char
op_star
op_star
id|result
)paren
(brace
r_char
op_star
id|tmp
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|tmp
op_assign
id|get_page
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|retval
op_assign
id|do_getname
c_func
(paren
id|filename
comma
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_else
op_star
id|result
op_assign
id|tmp
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;permission()&n; *&n; * is used to check for read/write/execute permissions on a file.&n; * We use &quot;fsuid&quot; for this, letting us set arbitrary permissions&n; * for filesystem access without changing the &quot;normal&quot; uids which&n; * are used for other things..&n; */
DECL|function|permission
r_int
id|permission
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|mask
)paren
(brace
r_int
id|mode
op_assign
id|inode-&gt;i_mode
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_op
op_logical_and
id|inode-&gt;i_op-&gt;permission
)paren
r_return
id|inode-&gt;i_op
op_member_access_from_pointer
id|permission
c_func
(paren
id|inode
comma
id|mask
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|mask
op_amp
id|S_IWOTH
)paren
op_logical_and
id|IS_RDONLY
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|S_ISREG
c_func
(paren
id|mode
)paren
op_logical_or
id|S_ISDIR
c_func
(paren
id|mode
)paren
op_logical_or
id|S_ISLNK
c_func
(paren
id|mode
)paren
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
multiline_comment|/* Nobody gets write access to a read-only fs */
r_else
r_if
c_cond
(paren
(paren
id|mask
op_amp
id|S_IWOTH
)paren
op_logical_and
id|IS_IMMUTABLE
c_func
(paren
id|inode
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* Nobody gets write access to an immutable file */
r_else
r_if
c_cond
(paren
id|current-&gt;fsuid
op_eq
id|inode-&gt;i_uid
)paren
id|mode
op_rshift_assign
l_int|6
suffix:semicolon
r_else
r_if
c_cond
(paren
id|in_group_p
c_func
(paren
id|inode-&gt;i_gid
)paren
)paren
id|mode
op_rshift_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|mode
op_amp
id|mask
op_amp
l_int|0007
)paren
op_eq
id|mask
)paren
op_logical_or
id|fsuser
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
multiline_comment|/*&n; * get_write_access() gets write permission for a file.&n; * put_write_access() releases this write permission.&n; * This is used for regular files.&n; * We cannot support write (and maybe mmap read-write shared) accesses and&n; * MAP_DENYWRITE mmappings simultaneously. The i_writecount field of an inode&n; * can have the following values:&n; * 0: no writers, no VM_DENYWRITE mappings&n; * &lt; 0: (-i_writecount) vm_area_structs with VM_DENYWRITE set exist&n; * &gt; 0: (i_writecount) users are writing to the file.&n; */
DECL|function|get_write_access
r_int
id|get_write_access
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_writecount
OL
l_int|0
)paren
r_return
op_minus
id|ETXTBSY
suffix:semicolon
id|inode-&gt;i_writecount
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|put_write_access
r_void
id|put_write_access
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|inode-&gt;i_writecount
op_decrement
suffix:semicolon
)brace
DECL|function|concat
r_static
multiline_comment|/*inline */
r_int
id|concat
c_func
(paren
r_struct
id|qstr
op_star
id|name
comma
r_struct
id|qstr
op_star
id|appendix
comma
r_char
op_star
id|buf
)paren
(brace
r_int
id|totallen
op_assign
id|name-&gt;len
suffix:semicolon
r_if
c_cond
(paren
id|name-&gt;len
OG
id|MAX_TRANS_FILELEN
op_logical_or
id|appendix-&gt;len
OG
id|MAX_TRANS_SUFFIX
)paren
(brace
r_return
op_minus
id|ENAMETOOLONG
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|buf
comma
id|name-&gt;name
comma
id|name-&gt;len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|buf
op_plus
id|name-&gt;len
comma
id|appendix-&gt;name
comma
id|appendix-&gt;len
)paren
suffix:semicolon
id|totallen
op_add_assign
id|appendix-&gt;len
suffix:semicolon
id|buf
(braket
id|totallen
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
id|totallen
suffix:semicolon
)brace
multiline_comment|/* Internal lookup() using the new generic dcache.&n; * buf must only be supplied if appendix!=NULL.&n; */
DECL|function|cached_lookup
r_static
r_int
id|cached_lookup
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|qstr
op_star
id|name
comma
r_struct
id|qstr
op_star
id|appendix
comma
r_char
op_star
id|buf
comma
r_struct
id|qstr
op_star
id|res_name
comma
r_struct
id|dentry
op_star
op_star
id|res_entry
comma
r_struct
id|inode
op_star
op_star
id|result
)paren
(brace
r_struct
id|qstr
id|tmp
op_assign
(brace
id|name-&gt;name
comma
id|name-&gt;len
)brace
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|dentry
op_star
id|cached
suffix:semicolon
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|name-&gt;len
op_ge
id|D_MAXLEN
)paren
(brace
r_return
op_minus
id|ENAMETOOLONG
suffix:semicolon
)brace
id|vfs_lock
c_func
(paren
)paren
suffix:semicolon
id|cached
op_assign
id|d_lookup
c_func
(paren
id|dir
comma
id|name
comma
id|appendix
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cached
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|cached-&gt;u.d_inode
op_logical_and
(paren
id|inode
op_assign
id|d_inode
c_func
(paren
op_amp
id|cached
)paren
)paren
)paren
(brace
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|appendix
op_logical_and
id|res_name
)paren
(brace
id|tmp.len
op_assign
id|error
op_assign
id|concat
c_func
(paren
id|name
comma
id|appendix
comma
id|buf
)paren
suffix:semicolon
id|tmp.name
op_assign
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|error
OG
l_int|0
)paren
(brace
id|error
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
)brace
id|vfs_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res_entry
)paren
(brace
op_star
id|res_entry
op_assign
id|cached
suffix:semicolon
)brace
multiline_comment|/* Since we are bypassing the iget() mechanism, we have to&n;&t;&t; * fabricate the act of crossing any mount points.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|inode
op_logical_and
id|inode-&gt;i_mount
)paren
(brace
r_do
(brace
r_struct
id|inode
op_star
id|mnti
op_assign
id|inode-&gt;i_mount
suffix:semicolon
id|iinc
c_func
(paren
id|mnti
)paren
suffix:semicolon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
id|inode
op_assign
id|mnti
suffix:semicolon
)brace
r_while
c_loop
(paren
id|inode-&gt;i_mount
)paren
(brace
suffix:semicolon
)brace
)brace
op_star
id|result
op_assign
id|inode
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_else
id|vfs_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|appendix
)paren
(brace
id|tmp.len
op_assign
id|error
op_assign
id|concat
c_func
(paren
id|name
comma
id|appendix
comma
id|buf
)paren
suffix:semicolon
id|tmp.name
op_assign
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
)brace
id|atomic_inc
c_func
(paren
op_amp
id|dir-&gt;i_count
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|lookup
c_func
(paren
id|dir
comma
id|tmp.name
comma
id|tmp.len
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;i_dentry
op_logical_and
id|tmp.len
op_logical_and
(paren
op_logical_neg
id|error
op_logical_or
(paren
id|error
op_eq
op_minus
id|ENOENT
op_logical_and
(paren
op_logical_neg
id|dir-&gt;i_sb
op_logical_or
op_logical_neg
id|dir-&gt;i_sb-&gt;s_type
op_logical_or
op_logical_neg
(paren
id|dir-&gt;i_sb-&gt;s_type-&gt;fs_flags
op_amp
id|FS_NO_DCACHE
)paren
)paren
)paren
)paren
)paren
(brace
r_struct
id|dentry
op_star
id|res
suffix:semicolon
id|vfs_lock
c_func
(paren
)paren
suffix:semicolon
id|res
op_assign
id|d_entry
c_func
(paren
id|dir-&gt;i_dentry
comma
op_amp
id|tmp
comma
id|error
ques
c_cond
l_int|NULL
suffix:colon
op_star
id|result
)paren
suffix:semicolon
id|vfs_unlock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res_entry
)paren
(brace
op_star
id|res_entry
op_assign
id|res
suffix:semicolon
)brace
)brace
id|done
suffix:colon
r_if
c_cond
(paren
id|res_name
)paren
(brace
r_if
c_cond
(paren
id|error
)paren
(brace
id|res_name-&gt;name
op_assign
id|name-&gt;name
suffix:semicolon
id|res_name-&gt;len
op_assign
id|name-&gt;len
suffix:semicolon
)brace
r_else
(brace
id|res_name-&gt;name
op_assign
id|tmp.name
suffix:semicolon
id|res_name-&gt;len
op_assign
id|tmp.len
suffix:semicolon
)brace
)brace
r_return
id|error
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_TRANS_NAMES
multiline_comment|/* If a normal filename is seen, try to determine whether a&n; * &quot;#keyword=context#&quot; file exists and return the new filename.&n; * If the name is to be created (create_mode), check whether a&n; * &quot;#keyword=CREATE&quot; name exists and optionally return the corresponding&n; * context name even if it didn&squot;t exist before.&n; */
DECL|function|check_suffixes
r_static
r_int
id|check_suffixes
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|qstr
op_star
id|name
comma
r_int
id|create_mode
comma
r_char
op_star
id|buf
comma
r_struct
id|qstr
op_star
id|res_name
comma
r_struct
id|dentry
op_star
op_star
id|res_entry
comma
r_struct
id|inode
op_star
op_star
id|result
)paren
(brace
r_struct
id|translations
op_star
id|trans
suffix:semicolon
r_char
op_star
id|env
suffix:semicolon
r_struct
id|qstr
op_star
id|suffixes
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;buf==NULL&quot;
)paren
suffix:semicolon
)brace
id|env
op_assign
id|env_transl
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_TRANS_RESTRICT
r_if
c_cond
(paren
op_logical_neg
id|env
op_logical_and
id|dir-&gt;i_gid
op_ne
id|CONFIG_TRANS_GID
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
macro_line|#endif
id|trans
op_assign
id|get_translations
c_func
(paren
id|env
)paren
suffix:semicolon
id|suffixes
op_assign
id|create_mode
ques
c_cond
id|trans-&gt;c_name
suffix:colon
id|trans-&gt;name
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|trans-&gt;count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|error
op_assign
id|cached_lookup
c_func
(paren
id|dir
comma
id|name
comma
op_amp
id|suffixes
(braket
id|i
)braket
comma
id|buf
comma
id|res_name
comma
id|res_entry
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_if
c_cond
(paren
id|res_name
op_logical_and
id|create_mode
)paren
(brace
multiline_comment|/* buf == res_name-&gt;name, but is writable */
id|memcpy
c_func
(paren
id|buf
op_plus
id|name-&gt;len
comma
id|trans-&gt;name
(braket
id|i
)braket
dot
id|name
comma
id|trans-&gt;name
(braket
id|i
)braket
dot
id|len
)paren
suffix:semicolon
id|res_name-&gt;len
op_assign
id|name-&gt;len
op_plus
id|trans-&gt;name
(braket
id|i
)braket
dot
id|len
suffix:semicolon
id|buf
(braket
id|res_name-&gt;len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|env
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|trans
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Any operations involving reserved names at the VFS level should go here. */
DECL|function|reserved_lookup
r_static
multiline_comment|/*inline*/
r_int
id|reserved_lookup
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|qstr
op_star
id|name
comma
r_int
id|create_mode
comma
r_char
op_star
id|buf
comma
r_struct
id|inode
op_star
op_star
id|result
)paren
(brace
r_int
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|name-&gt;name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
r_if
c_cond
(paren
id|name-&gt;len
op_eq
l_int|1
)paren
(brace
op_star
id|result
op_assign
id|dir
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|name-&gt;len
op_eq
l_int|2
op_logical_and
id|name-&gt;name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
r_if
c_cond
(paren
id|dir
op_eq
id|current-&gt;fs-&gt;root
)paren
(brace
op_star
id|result
op_assign
id|dir
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dir-&gt;i_dentry
)paren
(brace
id|error
op_assign
l_int|0
suffix:semicolon
op_star
id|result
op_assign
id|dir-&gt;i_dentry-&gt;d_parent-&gt;u.d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|result
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;dcache parent directory is lost&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ESTALE
suffix:semicolon
multiline_comment|/* random error */
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
(paren
op_star
id|result
)paren
op_member_access_from_pointer
id|i_count
)paren
suffix:semicolon
)brace
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* In difference to the former version, lookup() no longer eats the dir. */
DECL|function|lookup
r_static
multiline_comment|/*inline*/
r_int
id|lookup
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|qstr
op_star
id|name
comma
r_int
id|create_mode
comma
r_char
op_star
id|buf
comma
r_struct
id|qstr
op_star
id|res_name
comma
r_struct
id|dentry
op_star
op_star
id|res_entry
comma
r_struct
id|inode
op_star
op_star
id|result
)paren
(brace
r_int
id|perm
suffix:semicolon
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
id|perm
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/* Check permissions before traversing mount-points. */
id|perm
op_assign
id|permission
c_func
(paren
id|dir
comma
id|MAY_EXEC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|perm
)paren
r_goto
id|done
suffix:semicolon
id|perm
op_assign
id|reserved_lookup
c_func
(paren
id|dir
comma
id|name
comma
id|create_mode
comma
id|buf
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
(brace
r_if
c_cond
(paren
id|res_name
)paren
(brace
id|res_name-&gt;name
op_assign
id|name-&gt;name
suffix:semicolon
id|res_name-&gt;len
op_assign
id|name-&gt;len
suffix:semicolon
)brace
r_goto
id|done
suffix:semicolon
)brace
id|perm
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;lookup
)paren
r_goto
id|done
suffix:semicolon
macro_line|#ifdef CONFIG_TRANS_NAMES /* try suffixes */
id|perm
op_assign
id|check_suffixes
c_func
(paren
id|dir
comma
id|name
comma
l_int|0
comma
id|buf
comma
id|res_name
comma
id|res_entry
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|perm
)paren
(brace
multiline_comment|/* try original name */
macro_line|#endif
id|perm
op_assign
id|cached_lookup
c_func
(paren
id|dir
comma
id|name
comma
l_int|NULL
comma
id|buf
comma
id|res_name
comma
id|res_entry
comma
id|result
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_TRANS_NAMES
r_if
c_cond
(paren
id|perm
op_eq
op_minus
id|ENOENT
op_logical_and
id|create_mode
)paren
(brace
multiline_comment|/* try the =CREATE# suffix */
r_struct
id|inode
op_star
id|dummy
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_suffixes
c_func
(paren
id|dir
comma
id|name
comma
l_int|1
comma
id|buf
comma
id|res_name
comma
l_int|NULL
comma
op_amp
id|dummy
)paren
)paren
(brace
id|iput
c_func
(paren
id|dummy
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|done
suffix:colon
r_return
id|perm
suffix:semicolon
)brace
multiline_comment|/* [8-Feb-97 T. Schoebel-Theuer] follow_link() modified for generic operation&n; * on the VFS layer: first call &lt;fs&gt;_readlink() and then open_namei().&n; * All &lt;fs&gt;_follow_link() are not used any more and may be eliminated&n; * (by Linus; I refrained in order to not break other patches).&n; * Single exeption is procfs, where proc_follow_link() is used&n; * internally (and perhaps should be rewritten).&n; * Note: [partly obsolete] I removed parameters flag and mode, since now&n; * __namei() is called instead of open_namei(). In the old semantics,&n; * the _last_ instance of open_namei() did the real create() if O_CREAT was&n; * set and the name existed already in form of a symlink. This has been&n; * simplified now, and also the semantics when combined with O_EXCL has changed.&n; ****************************************************************************&n; * [13-Feb-97] Complete rewrite -&gt; functionality of reading symlinks factored&n; * out into _read_link(). The above notes remain valid in principle.&n; */
DECL|function|_read_link
r_static
multiline_comment|/*inline*/
r_int
id|_read_link
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_char
op_star
op_star
id|linkname
comma
r_int
id|loopcount
)paren
(brace
r_int
r_int
id|old_fs
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_op
op_logical_or
op_logical_neg
id|inode-&gt;i_op-&gt;readlink
)paren
r_goto
id|done
suffix:semicolon
id|error
op_assign
op_minus
id|ELOOP
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;link_count
op_plus
id|loopcount
OG
l_int|10
)paren
r_goto
id|done
suffix:semicolon
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|linkname
op_logical_and
op_logical_neg
(paren
op_star
id|linkname
op_assign
id|get_page
c_func
(paren
)paren
)paren
)paren
(brace
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DO_UPDATE_ATIME
c_func
(paren
id|inode
)paren
)paren
(brace
id|inode-&gt;i_atime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|inode-&gt;i_dirt
op_assign
l_int|1
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
suffix:semicolon
id|old_fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|error
op_assign
id|inode-&gt;i_op
op_member_access_from_pointer
id|readlink
c_func
(paren
id|inode
comma
op_star
id|linkname
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|old_fs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
multiline_comment|/* ? or other error code ? */
)brace
r_else
r_if
c_cond
(paren
id|error
OG
l_int|0
)paren
(brace
(paren
op_star
id|linkname
)paren
(braket
id|error
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
id|done
suffix:colon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* [13-Feb-97 T. Schoebel-Theuer] complete rewrite:&n; * merged dir_name(), _namei() and follow_link() into one new routine&n; * that obeys all the special cases hidden in the old routines in a&n; * (hopefully) systematic way:&n; * parameter retrieve_mode is bitwise or&squot;ed of the ST_* flags.&n; * if res_inode is a NULL pointer, dont try to retrieve the last component&n; * at all. Parameters with prefix last_ are used only if res_inode is&n; * non-NULL and refer to the last component of the path only.&n; */
DECL|function|__namei
r_int
id|__namei
c_func
(paren
r_int
id|retrieve_mode
comma
r_const
r_char
op_star
id|name
comma
r_struct
id|inode
op_star
id|base
comma
r_char
op_star
id|buf
comma
r_struct
id|inode
op_star
op_star
id|res_dir
comma
r_struct
id|inode
op_star
op_star
id|res_inode
comma
r_struct
id|qstr
op_star
id|last_name
comma
r_struct
id|dentry
op_star
op_star
id|last_entry
comma
r_int
op_star
id|last_error
)paren
(brace
r_char
id|c
suffix:semicolon
r_struct
id|qstr
id|this
suffix:semicolon
r_char
op_star
id|linkname
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|oldlinkname
op_assign
l_int|NULL
suffix:semicolon
r_int
id|trail_flag
op_assign
l_int|0
suffix:semicolon
r_int
id|loopcount
op_assign
l_int|0
suffix:semicolon
r_int
id|error
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|last_name
)paren
(brace
id|last_name-&gt;name
op_assign
l_string|&quot;(Uninitialized)&quot;
suffix:semicolon
id|last_name-&gt;len
op_assign
l_int|15
suffix:semicolon
)brace
macro_line|#endif
id|again
suffix:colon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|this.name
op_assign
id|name
suffix:semicolon
r_if
c_cond
(paren
id|this.name
(braket
l_int|0
)braket
op_eq
l_char|&squot;/&squot;
)paren
(brace
r_if
c_cond
(paren
id|base
)paren
(brace
id|iput
c_func
(paren
id|base
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|__prefix_namei
c_func
(paren
id|retrieve_mode
comma
id|this.name
comma
id|base
comma
id|buf
comma
id|res_dir
comma
id|res_inode
comma
id|last_name
comma
id|last_entry
comma
id|last_error
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|base
op_assign
id|current-&gt;fs-&gt;root
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|base-&gt;i_count
)paren
suffix:semicolon
id|this.name
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
(brace
id|base
op_assign
id|current-&gt;fs-&gt;pwd
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|base-&gt;i_count
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_const
r_char
op_star
id|tmp
op_assign
id|this.name
suffix:semicolon
r_int
id|len
suffix:semicolon
r_for
c_loop
(paren
id|len
op_assign
l_int|0
suffix:semicolon
(paren
id|c
op_assign
op_star
id|tmp
op_increment
)paren
op_logical_and
(paren
id|c
op_ne
l_char|&squot;/&squot;
)paren
suffix:semicolon
id|len
op_increment
)paren
(brace
suffix:semicolon
)brace
id|this.len
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
id|tmp
)paren
op_eq
l_char|&squot;/&squot;
)paren
(brace
multiline_comment|/* remove embedded/trailing slashes */
id|tmp
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
id|trail_flag
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|retrieve_mode
op_amp
id|NAM_NO_TRAILSLASH
)paren
(brace
id|error
op_assign
op_minus
id|EISDIR
suffix:semicolon
r_goto
id|alldone
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|base-&gt;i_count
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;vor lookup this=%s tmp=%s&bslash;n&quot;
comma
id|this.name
comma
id|tmp
)paren
suffix:semicolon
)brace
macro_line|#endif
id|error
op_assign
id|lookup
c_func
(paren
id|base
comma
op_amp
id|this
comma
l_int|0
comma
id|buf
comma
l_int|NULL
comma
l_int|NULL
comma
op_amp
id|inode
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|base-&gt;i_count
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;nach lookup this=%s tmp=%s&bslash;n&quot;
comma
id|this.name
comma
id|tmp
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|error
)paren
r_goto
id|alldone
suffix:semicolon
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|error
op_assign
id|_read_link
c_func
(paren
id|inode
comma
op_amp
id|linkname
comma
id|loopcount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|alldone
suffix:semicolon
)brace
id|current-&gt;link_count
op_increment
suffix:semicolon
id|error
op_assign
id|__namei
c_func
(paren
(paren
id|retrieve_mode
op_amp
op_complement
(paren
id|NAM_SEMLOCK
op_or
id|NAM_TRANSCREATE
op_or
id|NAM_NO_TRAILSLASH
)paren
)paren
op_or
id|NAM_FOLLOW_LINK
comma
id|linkname
comma
id|base
comma
id|buf
comma
op_amp
id|base
comma
op_amp
id|inode
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|current-&gt;link_count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|alldone
suffix:semicolon
)brace
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|base-&gt;i_count
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;this=%s tmp=%s&bslash;n&quot;
comma
id|this.name
comma
id|tmp
)paren
suffix:semicolon
)brace
macro_line|#endif
id|this.name
op_assign
id|tmp
suffix:semicolon
id|iput
c_func
(paren
id|base
)paren
suffix:semicolon
id|base
op_assign
id|inode
suffix:semicolon
)brace
r_if
c_cond
(paren
id|res_inode
)paren
(brace
r_if
c_cond
(paren
id|retrieve_mode
op_amp
id|NAM_SEMLOCK
)paren
(brace
id|down
c_func
(paren
op_amp
id|base-&gt;i_sem
)paren
suffix:semicolon
)brace
id|error
op_assign
id|lookup
c_func
(paren
id|base
comma
op_amp
id|this
comma
id|retrieve_mode
op_amp
id|NAM_TRANSCREATE
comma
id|buf
comma
id|last_name
comma
id|last_entry
comma
id|res_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|S_ISLNK
c_func
(paren
(paren
op_star
id|res_inode
)paren
op_member_access_from_pointer
id|i_mode
)paren
op_logical_and
(paren
(paren
id|retrieve_mode
op_amp
id|NAM_FOLLOW_LINK
)paren
op_logical_or
(paren
id|trail_flag
op_logical_and
(paren
id|retrieve_mode
op_amp
id|NAM_FOLLOW_TRAILSLASH
)paren
)paren
)paren
)paren
(brace
r_char
op_star
id|tmp
suffix:semicolon
id|error
op_assign
id|_read_link
c_func
(paren
op_star
id|res_inode
comma
op_amp
id|linkname
comma
id|loopcount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
r_goto
id|lastdone
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retrieve_mode
op_amp
id|NAM_SEMLOCK
)paren
(brace
id|up
c_func
(paren
op_amp
id|base-&gt;i_sem
)paren
suffix:semicolon
)brace
multiline_comment|/* exchange pages */
id|name
op_assign
id|tmp
op_assign
id|linkname
suffix:semicolon
id|linkname
op_assign
id|oldlinkname
suffix:semicolon
id|oldlinkname
op_assign
id|tmp
suffix:semicolon
id|loopcount
op_increment
suffix:semicolon
r_goto
id|again
suffix:semicolon
multiline_comment|/* Tail recursion elimination &quot;by hand&quot;,&n;&t;&t;&t;&t;     * uses less dynamic memory.&n;&t;&t;&t;&t;     */
multiline_comment|/* Note that trail_flag is not reset, so it&n;&t;&t;&t; * does not matter in a symlink chain where a&n;&t;&t;&t; * trailing slash indicates a directory endpoint.&n;&t;&t;&t; */
)brace
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|trail_flag
op_logical_and
op_logical_neg
id|S_ISDIR
c_func
(paren
(paren
op_star
id|res_inode
)paren
op_member_access_from_pointer
id|i_mode
)paren
)paren
(brace
id|iput
c_func
(paren
op_star
id|res_inode
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
)brace
id|lastdone
suffix:colon
r_if
c_cond
(paren
id|last_error
)paren
(brace
op_star
id|last_error
op_assign
id|error
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|alldone
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|res_dir
)paren
(brace
op_star
id|res_dir
op_assign
id|base
suffix:semicolon
)brace
r_else
id|iput
c_func
(paren
id|base
)paren
suffix:semicolon
id|putname
c_func
(paren
id|linkname
)paren
suffix:semicolon
id|putname
c_func
(paren
id|oldlinkname
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;namei()&n; *&n; * is used by most simple commands to get the inode of a specified name.&n; * Open, link etc use their own routines, but this is enough for things&n; * like &squot;chmod&squot; etc.&n; */
multiline_comment|/* [Feb 1997 T.Schoebel-Theuer] lnamei() completely removed; can be&n; * simulated when calling with retrieve_mode==NAM_FOLLOW_TRAILSLASH.&n; */
DECL|function|namei
r_int
id|namei
c_func
(paren
r_int
id|retrieve_mode
comma
r_const
r_char
op_star
id|pathname
comma
r_struct
id|inode
op_star
op_star
id|res_inode
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
id|error
op_assign
id|getname
c_func
(paren
id|pathname
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_char
id|buf
(braket
id|MAX_TRANS_FILELEN
op_plus
id|MAX_TRANS_SUFFIX
op_plus
l_int|2
)braket
suffix:semicolon
id|error
op_assign
id|__namei
c_func
(paren
id|retrieve_mode
comma
id|tmp
comma
l_int|NULL
comma
id|buf
comma
l_int|NULL
comma
id|res_inode
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;open_namei()&n; *&n; * namei for open - this is in fact almost the whole open-routine.&n; *&n; * Note that the low bits of &quot;flag&quot; aren&squot;t the same as in the open&n; * system call - they are 00 - no permissions needed&n; *&t;&t;&t;  01 - read permission needed&n; *&t;&t;&t;  10 - write permission needed&n; *&t;&t;&t;  11 - read/write permissions needed&n; * which is a lot more logical, and also allows the &quot;no perm&quot; needed&n; * for symlinks (where the permissions are checked later).&n; */
DECL|function|open_namei
r_int
id|open_namei
c_func
(paren
r_const
r_char
op_star
id|pathname
comma
r_int
id|flag
comma
r_int
id|mode
comma
r_struct
id|inode
op_star
op_star
id|res_inode
comma
r_struct
id|inode
op_star
id|base
)paren
(brace
r_char
id|buf
(braket
id|MAX_TRANS_FILELEN
op_plus
id|MAX_TRANS_SUFFIX
op_plus
l_int|2
)braket
suffix:semicolon
r_struct
id|qstr
id|last
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|lasterror
suffix:semicolon
r_struct
id|inode
op_star
id|dir
comma
op_star
id|inode
suffix:semicolon
r_int
id|namei_mode
suffix:semicolon
id|mode
op_and_assign
id|S_IALLUGO
op_amp
op_complement
id|current-&gt;fs-&gt;umask
suffix:semicolon
id|mode
op_or_assign
id|S_IFREG
suffix:semicolon
id|namei_mode
op_assign
id|NAM_FOLLOW_LINK
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|O_CREAT
)paren
(brace
id|namei_mode
op_or_assign
id|NAM_SEMLOCK
op_or
id|NAM_TRANSCREATE
op_or
id|NAM_NO_TRAILSLASH
suffix:semicolon
)brace
id|error
op_assign
id|__namei
c_func
(paren
id|namei_mode
comma
id|pathname
comma
id|base
comma
id|buf
comma
op_amp
id|dir
comma
op_amp
id|inode
comma
op_amp
id|last
comma
l_int|NULL
comma
op_amp
id|lasterror
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
id|error
op_assign
id|lasterror
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|O_CREAT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_if
c_cond
(paren
id|flag
op_amp
id|O_EXCL
)paren
(brace
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|dir
)paren
)paren
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;create
)paren
id|error
op_assign
op_minus
id|EACCES
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|error
op_assign
id|permission
c_func
(paren
id|dir
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
)paren
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/* error is already set! */
r_else
(brace
id|d_del
c_func
(paren
id|d_lookup
c_func
(paren
id|dir
comma
op_amp
id|last
comma
l_int|NULL
)paren
comma
id|D_REMOVE
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|dir-&gt;i_count
)paren
suffix:semicolon
multiline_comment|/* create eats the dir */
r_if
c_cond
(paren
id|dir-&gt;i_sb
op_logical_and
id|dir-&gt;i_sb-&gt;dq_op
)paren
id|dir-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|dir
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|create
c_func
(paren
id|dir
comma
id|last.name
comma
id|last.len
comma
id|mode
comma
id|res_inode
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_OMIRR
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|omirr_print
c_func
(paren
id|dir-&gt;i_dentry
comma
l_int|NULL
comma
op_amp
id|last
comma
l_string|&quot; c %ld %d &quot;
comma
id|CURRENT_TIME
comma
id|mode
)paren
suffix:semicolon
)brace
macro_line|#endif
id|up
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
r_goto
id|exit_dir
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_inode
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
(paren
id|flag
op_amp
l_int|2
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EISDIR
suffix:semicolon
r_goto
id|exit_inode
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|permission
c_func
(paren
id|inode
comma
id|ACC_MODE
c_func
(paren
id|flag
)paren
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_goto
id|exit_inode
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISFIFO
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISSOCK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * 2-Feb-1995 Bruce Perens &lt;Bruce@Pixar.com&gt;&n;&t;&t; * Allow opens of Unix domain sockets and FIFOs for write on&n;&t;&t; * read-only filesystems. Their data does not live on the disk.&n;&t;&t; *&n;&t;&t; * If there was something like IS_NODEV(inode) for&n;&t;&t; * pipes and/or sockets I&squot;d check it here.&n;&t;&t; */
id|flag
op_and_assign
op_complement
id|O_TRUNC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISCHR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|IS_NODEV
c_func
(paren
id|inode
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EACCES
suffix:semicolon
r_goto
id|exit_inode
suffix:semicolon
)brace
id|flag
op_and_assign
op_complement
id|O_TRUNC
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|flag
op_amp
l_int|2
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_goto
id|exit_inode
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * An append-only file must be opened in append mode for writing.&n;&t; */
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|inode
)paren
op_logical_and
(paren
(paren
id|flag
op_amp
id|FMODE_WRITE
)paren
op_logical_and
op_logical_neg
(paren
id|flag
op_amp
id|O_APPEND
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|exit_inode
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flag
op_amp
id|O_TRUNC
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|get_write_access
c_func
(paren
id|inode
)paren
)paren
)paren
r_goto
id|exit_inode
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Refuse to truncate files with mandatory locks held on them.&n;&t;&t; */
id|error
op_assign
id|locks_verify_locked
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_inode
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_sb
op_logical_and
id|inode-&gt;i_sb-&gt;dq_op
)paren
id|inode-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|inode
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|do_truncate
c_func
(paren
id|inode
comma
l_int|0
)paren
suffix:semicolon
id|put_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flag
op_amp
id|FMODE_WRITE
)paren
r_if
c_cond
(paren
id|inode-&gt;i_sb
op_logical_and
id|inode-&gt;i_sb-&gt;dq_op
)paren
id|inode-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|inode
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|exit_inode
suffix:colon
r_if
c_cond
(paren
id|error
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|lasterror
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
)brace
r_else
op_star
id|res_inode
op_assign
id|inode
suffix:semicolon
id|exit_dir
suffix:colon
id|iput
c_func
(paren
id|dir
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_mknod
r_int
id|do_mknod
c_func
(paren
r_const
r_char
op_star
id|filename
comma
r_int
id|mode
comma
id|dev_t
id|dev
)paren
(brace
r_char
id|buf
(braket
id|MAX_TRANS_FILELEN
op_plus
id|MAX_TRANS_SUFFIX
op_plus
l_int|2
)braket
suffix:semicolon
r_struct
id|qstr
id|last
suffix:semicolon
r_int
id|error
comma
id|lasterror
suffix:semicolon
r_struct
id|inode
op_star
id|dir
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|mode
op_and_assign
op_complement
id|current-&gt;fs-&gt;umask
suffix:semicolon
id|error
op_assign
id|__namei
c_func
(paren
id|NAM_FOLLOW_LINK
op_or
id|NAM_TRANSCREATE
op_or
id|NAM_NO_TRAILSLASH
comma
id|filename
comma
l_int|NULL
comma
id|buf
comma
op_amp
id|dir
comma
op_amp
id|inode
comma
op_amp
id|last
comma
l_int|NULL
comma
op_amp
id|lasterror
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lasterror
)paren
(brace
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|exit_inode
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|last.len
)paren
(brace
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|exit_inode
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|dir
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_goto
id|exit_inode
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|permission
c_func
(paren
id|dir
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|exit_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;mknod
)paren
(brace
id|error
op_assign
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* instead of EPERM, what does Posix say? */
r_goto
id|exit_inode
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|dir-&gt;i_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;i_sb
op_logical_and
id|dir-&gt;i_sb-&gt;dq_op
)paren
id|dir-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|dir
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
id|d_del
c_func
(paren
id|d_lookup
c_func
(paren
id|dir
comma
op_amp
id|last
comma
l_int|NULL
)paren
comma
id|D_REMOVE
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|mknod
c_func
(paren
id|dir
comma
id|last.name
comma
id|last.len
comma
id|mode
comma
id|dev
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_OMIRR
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|omirr_print
c_func
(paren
id|dir-&gt;i_dentry
comma
l_int|NULL
comma
op_amp
id|last
comma
l_string|&quot; n %ld %d %d &quot;
comma
id|CURRENT_TIME
comma
id|mode
comma
id|dev
)paren
suffix:semicolon
)brace
macro_line|#endif
id|up
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
id|exit_inode
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|lasterror
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
id|iput
c_func
(paren
id|dir
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_mknod
id|asmlinkage
r_int
id|sys_mknod
c_func
(paren
r_const
r_char
op_star
id|filename
comma
r_int
id|mode
comma
id|dev_t
id|dev
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
op_logical_or
(paren
op_logical_neg
id|S_ISFIFO
c_func
(paren
id|mode
)paren
op_logical_and
op_logical_neg
id|fsuser
c_func
(paren
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|mode
op_amp
id|S_IFMT
)paren
(brace
r_case
l_int|0
suffix:colon
id|mode
op_or_assign
id|S_IFREG
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFREG
suffix:colon
r_case
id|S_IFCHR
suffix:colon
r_case
id|S_IFBLK
suffix:colon
r_case
id|S_IFIFO
suffix:colon
r_case
id|S_IFSOCK
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_goto
id|out
suffix:semicolon
)brace
id|error
op_assign
id|getname
c_func
(paren
id|filename
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|do_mknod
c_func
(paren
id|tmp
comma
id|mode
comma
id|dev
)paren
suffix:semicolon
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* [Feb-97 T. Schoebel-Theuer] remove_trailing_slashes() is now obsolete,&n; * its functionality is handled by observing trailing slashes in __namei().&n; */
DECL|function|do_mkdir
r_static
r_inline
r_int
id|do_mkdir
c_func
(paren
r_const
r_char
op_star
id|pathname
comma
r_int
id|mode
)paren
(brace
r_char
id|buf
(braket
id|MAX_TRANS_FILELEN
op_plus
id|MAX_TRANS_SUFFIX
op_plus
l_int|2
)braket
suffix:semicolon
r_struct
id|qstr
id|last
suffix:semicolon
r_int
id|error
comma
id|lasterror
suffix:semicolon
r_struct
id|inode
op_star
id|dir
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|mode
op_and_assign
l_int|0777
op_amp
op_complement
id|current-&gt;fs-&gt;umask
suffix:semicolon
id|error
op_assign
id|__namei
c_func
(paren
id|NAM_FOLLOW_LINK
op_or
id|NAM_TRANSCREATE
comma
id|pathname
comma
l_int|NULL
comma
id|buf
comma
op_amp
id|dir
comma
op_amp
id|inode
comma
op_amp
id|last
comma
l_int|NULL
comma
op_amp
id|lasterror
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lasterror
)paren
(brace
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|exit_inode
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|last.len
)paren
(brace
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|exit_inode
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|dir
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_goto
id|exit_inode
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|permission
c_func
(paren
id|dir
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|exit_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;mkdir
)paren
(brace
id|error
op_assign
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* instead of EPERM, what does Posix say? */
r_goto
id|exit_inode
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|dir-&gt;i_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;i_sb
op_logical_and
id|dir-&gt;i_sb-&gt;dq_op
)paren
id|dir-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|dir
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
id|d_del
c_func
(paren
id|d_lookup
c_func
(paren
id|dir
comma
op_amp
id|last
comma
l_int|NULL
)paren
comma
id|D_REMOVE
)paren
suffix:semicolon
id|mode
op_and_assign
l_int|01777
op_amp
op_complement
id|current-&gt;fs-&gt;umask
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|mkdir
c_func
(paren
id|dir
comma
id|last.name
comma
id|last.len
comma
id|mode
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_OMIRR
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|omirr_print
c_func
(paren
id|dir-&gt;i_dentry
comma
l_int|NULL
comma
op_amp
id|last
comma
l_string|&quot; d %ld %d &quot;
comma
id|CURRENT_TIME
comma
id|mode
)paren
suffix:semicolon
)brace
macro_line|#endif
id|up
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
id|exit_inode
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|lasterror
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
id|iput
c_func
(paren
id|dir
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_mkdir
id|asmlinkage
r_int
id|sys_mkdir
c_func
(paren
r_const
r_char
op_star
id|pathname
comma
r_int
id|mode
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|getname
c_func
(paren
id|pathname
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|do_mkdir
c_func
(paren
id|tmp
comma
id|mode
)paren
suffix:semicolon
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
macro_line|#if 0 /* We need a &quot;deletefs&quot;, someone please write it.  -DaveM */
multiline_comment|/* Perhaps this could be moved out into a new file. */
r_static
r_void
id|basket_name
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|entry
)paren
(brace
r_char
id|prefix
(braket
l_int|32
)braket
suffix:semicolon
r_struct
id|qstr
id|prename
op_assign
(brace
id|prefix
comma
l_int|14
)brace
suffix:semicolon
r_struct
id|qstr
id|entname
op_assign
(brace
id|entry-&gt;d_name.name
comma
id|entry-&gt;d_name.len
)brace
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|dentry
op_star
id|old
op_assign
id|entry
suffix:semicolon
multiline_comment|/* dummy */
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
op_logical_or
op_logical_neg
(paren
id|inode
op_assign
id|d_inode
c_func
(paren
op_amp
id|entry
)paren
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
OG
l_int|2
)paren
(brace
r_extern
r_void
id|printpath
c_func
(paren
r_struct
id|dentry
op_star
id|entry
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Caution: in use &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_dentry
)paren
(brace
id|printpath
c_func
(paren
id|inode-&gt;i_dentry
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; i_nlink=%d i_count=%d i_ddir_count=%d i_dent_count=%d&bslash;n&quot;
comma
id|inode-&gt;i_nlink
comma
id|atomic_read
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
comma
id|inode-&gt;i_ddir_count
comma
id|inode-&gt;i_dent_count
)paren
suffix:semicolon
)brace
macro_line|#endif
id|vfs_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|old
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|prefix
comma
l_string|&quot;.deleted-%04d.&quot;
comma
id|i
)paren
suffix:semicolon
id|old
op_assign
id|d_lookup
c_func
(paren
id|dir
comma
op_amp
id|prename
comma
op_amp
id|entname
)paren
suffix:semicolon
)brace
id|d_move
c_func
(paren
id|entry
comma
id|dir
comma
op_amp
id|prename
comma
op_amp
id|entname
)paren
suffix:semicolon
id|vfs_unlock
c_func
(paren
)paren
suffix:semicolon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|do_rmdir
r_static
r_inline
r_int
id|do_rmdir
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_char
id|buf
(braket
id|MAX_TRANS_FILELEN
op_plus
id|MAX_TRANS_SUFFIX
op_plus
l_int|2
)braket
suffix:semicolon
r_struct
id|qstr
id|last
suffix:semicolon
r_struct
id|dentry
op_star
id|lastent
op_assign
l_int|NULL
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|inode
op_star
id|dir
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
multiline_comment|/* [T.Schoebel-Theuer] I&squot;m not sure which flags to use here.&n;&t; *  Try the following on different platforms:&n;&t; * [0] rm -rf test test2&n;&t; * [1] ln -s test2 test&n;&t; * [2] mkdir test  || mkdir test2&n;&t; * [3] rmdir test  &amp;&amp; mkdir test2&n;&t; * [4] rmdir test/&n;&t; * Now the rusults:&n;&t; * cmd  |   HP-UX   |  SunOS   |  Solaris | Old Linux | New Linux |&n;&t; * ----------------------------------------------------------------&n;&t; * [2]  |   (OK)    |  EEXIST  |  EEXIST  |  EEXIST   |  (OK)&n;&t; * [3]  |  ENOTDIR  |  ENOTDIR |  ENOTDIR |  ENOTDIR  |  ENOTDIR&n;&t; * [4]  |   (OK)    |  EINVAL  |  ENOTDIR |  ENOTDIR  |  (OK)&n;&t; * So I implemented the HP-UX semantics. If this is not right&n;&t; * for Posix compliancy, change the flags accordingly. If Posix&n;&t; * let the question open, I&squot;d suggest to stay at the new semantics.&n;&t; * I&squot;d even make case [3] work by adding 2 to the flags parameter&n;&t; * if Posix tolerates that.&n;&t; */
id|error
op_assign
id|__namei
c_func
(paren
id|NAM_FOLLOW_TRAILSLASH
comma
id|name
comma
l_int|NULL
comma
id|buf
comma
op_amp
id|dir
comma
op_amp
id|inode
comma
op_amp
id|last
comma
op_amp
id|lastent
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|dir
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_goto
id|exit_dir
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|permission
c_func
(paren
id|dir
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|exit_dir
suffix:semicolon
multiline_comment|/*&n;&t; * A subdirectory cannot be removed from an append-only directory.&n;&t; */
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|dir
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|exit_dir
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;rmdir
)paren
(brace
id|error
op_assign
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* was EPERM */
r_goto
id|exit_dir
suffix:semicolon
)brace
multiline_comment|/* Disallow removals of mountpoints. */
r_if
c_cond
(paren
id|inode-&gt;i_mount
)paren
(brace
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|exit_dir
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dir-&gt;i_sb
op_logical_and
id|dir-&gt;i_sb-&gt;dq_op
)paren
id|dir-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|dir
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|lastent
op_logical_and
id|d_isbasket
c_func
(paren
id|lastent
)paren
)paren
(brace
id|d_del
c_func
(paren
id|lastent
comma
id|D_REMOVE
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_goto
id|exit_lock
suffix:semicolon
)brace
macro_line|#endif
id|atomic_inc
c_func
(paren
op_amp
id|dir-&gt;i_count
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|rmdir
c_func
(paren
id|dir
comma
id|last.name
comma
id|last.len
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_OMIRR
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|omirr_print
c_func
(paren
id|lastent
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot; r %ld &quot;
comma
id|CURRENT_TIME
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|lastent
)paren
(brace
id|basket_name
c_func
(paren
id|dir
comma
id|lastent
)paren
suffix:semicolon
)brace
id|exit_lock
suffix:colon
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|lastent
)paren
(brace
id|d_del
c_func
(paren
id|lastent
comma
id|D_REMOVE
)paren
suffix:semicolon
)brace
macro_line|#endif
id|up
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
id|exit_dir
suffix:colon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
id|iput
c_func
(paren
id|dir
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_rmdir
id|asmlinkage
r_int
id|sys_rmdir
c_func
(paren
r_const
r_char
op_star
id|pathname
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|getname
c_func
(paren
id|pathname
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|do_rmdir
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_unlink
r_static
r_inline
r_int
id|do_unlink
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_char
id|buf
(braket
id|MAX_TRANS_FILELEN
op_plus
id|MAX_TRANS_SUFFIX
op_plus
l_int|2
)braket
suffix:semicolon
r_struct
id|qstr
id|last
suffix:semicolon
r_struct
id|dentry
op_star
id|lastent
op_assign
l_int|NULL
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|inode
op_star
id|dir
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
multiline_comment|/* HP-UX shows a strange behaviour:&n;&t; * touch y; ln -s y x; rm x/&n;&t; * this succeeds and removes the file y, not the symlink x!&n;&t; * Solaris and old Linux remove the symlink instead, and&n;&t; * old SunOS complains ENOTDIR.&n;&t; * I chose the SunOS behaviour (by not using NAM_FOLLOW_TRAILSLASH),&n;&t; * but I&squot;m not shure whether I should.&n;&t; * The current code generally prohibits using trailing slashes with&n;&t; * non-directories if the name already exists, but not if&n;&t; * it is to be newly created. &n;&t; * Perhaps this should be further strengthened (by introducing&n;&t; * an additional flag bit indicating whether trailing slashes are&n;&t; * allowed) to get it as consistant as possible, but I don&squot;t know&n;&t; * what Posix says.&n;&t; */
id|error
op_assign
id|__namei
c_func
(paren
id|NAM_NO_TRAILSLASH
comma
id|name
comma
l_int|NULL
comma
id|buf
comma
op_amp
id|dir
comma
op_amp
id|inode
comma
op_amp
id|last
comma
op_amp
id|lastent
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|dir
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_goto
id|exit_dir
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|permission
c_func
(paren
id|dir
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|exit_dir
suffix:semicolon
multiline_comment|/*&n;&t; * A file cannot be removed from an append-only directory.&n;&t; */
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|dir
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|exit_dir
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;unlink
)paren
(brace
id|error
op_assign
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* was EPERM */
r_goto
id|exit_dir
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dir-&gt;i_sb
op_logical_and
id|dir-&gt;i_sb-&gt;dq_op
)paren
id|dir-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|dir
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
OG
l_int|1
)paren
(brace
r_extern
r_void
id|printpath
c_func
(paren
r_struct
id|dentry
op_star
id|entry
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Fire &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lastent
)paren
(brace
id|printpath
c_func
(paren
id|lastent
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; i_nlink=%d i_count=%d i_ddir_count=%d i_dent_count=%d&bslash;n&quot;
comma
id|inode-&gt;i_nlink
comma
id|atomic_read
c_func
(paren
op_amp
id|inode-&gt;i_count
)paren
comma
id|inode-&gt;i_ddir_count
comma
id|inode-&gt;i_dent_count
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if 0
r_if
c_cond
(paren
id|lastent
op_logical_and
id|d_isbasket
c_func
(paren
id|lastent
)paren
)paren
(brace
id|d_del
c_func
(paren
id|lastent
comma
id|D_REMOVE
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_goto
id|exit_lock
suffix:semicolon
)brace
macro_line|#endif
id|atomic_inc
c_func
(paren
op_amp
id|dir-&gt;i_count
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|unlink
c_func
(paren
id|dir
comma
id|last.name
comma
id|last.len
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_OMIRR
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|omirr_print
c_func
(paren
id|lastent
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot; u %ld &quot;
comma
id|CURRENT_TIME
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|lastent
)paren
(brace
id|basket_name
c_func
(paren
id|dir
comma
id|lastent
)paren
suffix:semicolon
)brace
id|exit_lock
suffix:colon
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|lastent
)paren
(brace
id|d_del
c_func
(paren
id|lastent
comma
id|D_REMOVE
)paren
suffix:semicolon
)brace
macro_line|#endif
id|up
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
id|exit_dir
suffix:colon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
id|iput
c_func
(paren
id|dir
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_unlink
id|asmlinkage
r_int
id|sys_unlink
c_func
(paren
r_const
r_char
op_star
id|pathname
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|getname
c_func
(paren
id|pathname
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|do_unlink
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_symlink
r_static
r_inline
r_int
id|do_symlink
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_char
id|buf
(braket
id|MAX_TRANS_FILELEN
op_plus
id|MAX_TRANS_SUFFIX
op_plus
l_int|2
)braket
suffix:semicolon
r_struct
id|qstr
id|last
suffix:semicolon
r_int
id|error
comma
id|lasterror
suffix:semicolon
r_struct
id|inode
op_star
id|dir
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
multiline_comment|/* The following works on HP-UX and Solaris, by producing&n;&t; * a symlink chain:&n;&t; * rm -rf ? ; mkdir z ; ln -s z y ; ln -s y x/&n;&t; * Under old SunOS, the following occurs:&n;&t; * ln: x/: No such file or directory&n;&t; * Under old Linux, very strange things occur:&n;&t; * ln: cannot create symbolic link `x//y&squot; to `y&squot;: No such file or directory&n;&t; * This is very probably a bug, but may be caused by the ln program&n;&t; * when checking for a directory target.&n;&t; *&n;&t; * I&squot;m not shure whether to add NAM_NO_TRAILSLASH to inhibit trailing&n;&t; * slashes in the target generally.&n;&t; */
id|error
op_assign
id|__namei
c_func
(paren
id|NAM_TRANSCREATE
comma
id|newname
comma
l_int|NULL
comma
id|buf
comma
op_amp
id|dir
comma
op_amp
id|inode
comma
op_amp
id|last
comma
l_int|NULL
comma
op_amp
id|lasterror
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lasterror
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|exit_dir
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|last.len
)paren
(brace
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|exit_dir
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|dir
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_goto
id|exit_dir
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|permission
c_func
(paren
id|dir
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|exit_dir
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;symlink
)paren
(brace
id|error
op_assign
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* was EPERM */
r_goto
id|exit_dir
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|dir-&gt;i_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;i_sb
op_logical_and
id|dir-&gt;i_sb-&gt;dq_op
)paren
id|dir-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|dir
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
id|d_del
c_func
(paren
id|d_lookup
c_func
(paren
id|dir
comma
op_amp
id|last
comma
l_int|NULL
)paren
comma
id|D_REMOVE
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|symlink
c_func
(paren
id|dir
comma
id|last.name
comma
id|last.len
comma
id|oldname
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_OMIRR
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|omirr_print
c_func
(paren
id|dir-&gt;i_dentry
comma
l_int|NULL
comma
op_amp
id|last
comma
l_string|&quot; s %ld %s&bslash;0&quot;
comma
id|CURRENT_TIME
comma
id|oldname
)paren
suffix:semicolon
)brace
macro_line|#endif
id|up
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
id|exit_dir
suffix:colon
id|iput
c_func
(paren
id|dir
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_symlink
id|asmlinkage
r_int
id|sys_symlink
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|from
comma
op_star
id|to
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|getname
c_func
(paren
id|oldname
comma
op_amp
id|from
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|getname
c_func
(paren
id|newname
comma
op_amp
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|do_symlink
c_func
(paren
id|from
comma
id|to
)paren
suffix:semicolon
id|putname
c_func
(paren
id|to
)paren
suffix:semicolon
)brace
id|putname
c_func
(paren
id|from
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_link
r_static
r_inline
r_int
id|do_link
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_char
id|oldbuf
(braket
id|MAX_TRANS_FILELEN
op_plus
id|MAX_TRANS_SUFFIX
op_plus
l_int|2
)braket
suffix:semicolon
r_char
id|newbuf
(braket
id|MAX_TRANS_FILELEN
op_plus
id|MAX_TRANS_SUFFIX
op_plus
l_int|2
)braket
suffix:semicolon
r_struct
id|qstr
id|oldlast
suffix:semicolon
r_struct
id|qstr
id|newlast
suffix:semicolon
r_struct
id|dentry
op_star
id|oldent
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|oldinode
suffix:semicolon
r_struct
id|inode
op_star
id|newinode
suffix:semicolon
r_struct
id|inode
op_star
id|newdir
suffix:semicolon
r_int
id|error
comma
id|lasterror
suffix:semicolon
id|error
op_assign
id|__namei
c_func
(paren
id|NAM_FOLLOW_LINK
op_or
id|NAM_NO_TRAILSLASH
comma
id|oldname
comma
l_int|NULL
comma
id|oldbuf
comma
l_int|NULL
comma
op_amp
id|oldinode
comma
op_amp
id|oldlast
comma
op_amp
id|oldent
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
id|error
op_assign
id|__namei
c_func
(paren
id|NAM_FOLLOW_LINK
op_or
id|NAM_TRANSCREATE
comma
id|newname
comma
l_int|NULL
comma
id|newbuf
comma
op_amp
id|newdir
comma
op_amp
id|newinode
comma
op_amp
id|newlast
comma
l_int|NULL
comma
op_amp
id|lasterror
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|old_exit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lasterror
)paren
(brace
id|iput
c_func
(paren
id|newinode
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|new_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|newlast.len
)paren
(brace
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|new_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|newdir
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_goto
id|new_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newdir-&gt;i_dev
op_ne
id|oldinode-&gt;i_dev
)paren
(brace
id|error
op_assign
op_minus
id|EXDEV
suffix:semicolon
r_goto
id|new_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|permission
c_func
(paren
id|newdir
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|new_exit
suffix:semicolon
multiline_comment|/*&n;&t; * A link to an append-only or immutable file cannot be created.&n;&t; */
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|oldinode
)paren
op_logical_or
id|IS_IMMUTABLE
c_func
(paren
id|oldinode
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|new_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|newdir-&gt;i_op
op_logical_or
op_logical_neg
id|newdir-&gt;i_op-&gt;link
)paren
(brace
id|error
op_assign
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* was EPERM */
r_goto
id|new_exit
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|oldinode-&gt;i_count
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|newdir-&gt;i_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newdir-&gt;i_sb
op_logical_and
id|newdir-&gt;i_sb-&gt;dq_op
)paren
id|newdir-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|newdir
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|newdir-&gt;i_sem
)paren
suffix:semicolon
id|d_del
c_func
(paren
id|d_lookup
c_func
(paren
id|newdir
comma
op_amp
id|newlast
comma
l_int|NULL
)paren
comma
id|D_REMOVE
)paren
suffix:semicolon
id|error
op_assign
id|newdir-&gt;i_op
op_member_access_from_pointer
id|link
c_func
(paren
id|oldinode
comma
id|newdir
comma
id|newlast.name
comma
id|newlast.len
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_OMIRR
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|omirr_print
c_func
(paren
id|oldent
comma
id|newdir-&gt;i_dentry
comma
op_amp
id|newlast
comma
l_string|&quot; l %ld &quot;
comma
id|CURRENT_TIME
)paren
suffix:semicolon
)brace
macro_line|#endif
id|up
c_func
(paren
op_amp
id|newdir-&gt;i_sem
)paren
suffix:semicolon
id|new_exit
suffix:colon
id|iput
c_func
(paren
id|newdir
)paren
suffix:semicolon
id|old_exit
suffix:colon
id|iput
c_func
(paren
id|oldinode
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_link
id|asmlinkage
r_int
id|sys_link
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|from
comma
op_star
id|to
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|getname
c_func
(paren
id|oldname
comma
op_amp
id|from
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|getname
c_func
(paren
id|newname
comma
op_amp
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|do_link
c_func
(paren
id|from
comma
id|to
)paren
suffix:semicolon
id|putname
c_func
(paren
id|to
)paren
suffix:semicolon
)brace
id|putname
c_func
(paren
id|from
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_rename
r_static
r_inline
r_int
id|do_rename
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_char
id|oldbuf
(braket
id|MAX_TRANS_FILELEN
op_plus
id|MAX_TRANS_SUFFIX
op_plus
l_int|2
)braket
suffix:semicolon
r_struct
id|qstr
id|oldlast
suffix:semicolon
r_char
id|newbuf
(braket
id|MAX_TRANS_FILELEN
op_plus
id|MAX_TRANS_SUFFIX
op_plus
l_int|2
)braket
suffix:semicolon
r_struct
id|qstr
id|newlast
suffix:semicolon
r_struct
id|dentry
op_star
id|oldent
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|inode
op_star
id|olddir
comma
op_star
id|newdir
suffix:semicolon
r_struct
id|inode
op_star
id|oldinode
comma
op_star
id|newinode
suffix:semicolon
r_int
id|error
comma
id|newlasterror
suffix:semicolon
id|error
op_assign
id|__namei
c_func
(paren
id|NAM_FOLLOW_TRAILSLASH
comma
id|oldname
comma
l_int|NULL
comma
id|oldbuf
comma
op_amp
id|olddir
comma
op_amp
id|oldinode
comma
op_amp
id|oldlast
comma
op_amp
id|oldent
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|permission
c_func
(paren
id|olddir
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|old_exit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|oldlast.len
op_logical_or
(paren
id|oldlast.name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
(paren
id|oldlast.len
op_eq
l_int|1
op_logical_or
(paren
id|oldlast.name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
id|oldlast.len
op_eq
l_int|2
)paren
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|old_exit
suffix:semicolon
)brace
multiline_comment|/* Disallow moves of mountpoints. */
r_if
c_cond
(paren
id|oldinode-&gt;i_mount
)paren
(brace
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|old_exit
suffix:semicolon
)brace
id|error
op_assign
id|__namei
c_func
(paren
id|NAM_FOLLOW_LINK
op_or
id|NAM_TRANSCREATE
comma
id|newname
comma
l_int|NULL
comma
id|newbuf
comma
op_amp
id|newdir
comma
op_amp
id|newinode
comma
op_amp
id|newlast
comma
l_int|NULL
comma
op_amp
id|newlasterror
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|old_exit
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|permission
c_func
(paren
id|newdir
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|new_exit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newlast.len
op_logical_or
(paren
id|newlast.name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
(paren
id|newlast.len
op_eq
l_int|1
op_logical_or
(paren
id|newlast.name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
id|newlast.len
op_eq
l_int|2
)paren
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|new_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newdir-&gt;i_dev
op_ne
id|olddir-&gt;i_dev
)paren
(brace
id|error
op_assign
op_minus
id|EXDEV
suffix:semicolon
r_goto
id|new_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|newdir
)paren
op_logical_or
id|IS_RDONLY
c_func
(paren
id|olddir
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_goto
id|new_exit
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * A file cannot be removed from an append-only directory.&n;&t; */
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|olddir
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|new_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|olddir-&gt;i_op
op_logical_or
op_logical_neg
id|olddir-&gt;i_op-&gt;rename
)paren
(brace
id|error
op_assign
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* was EPERM */
r_goto
id|new_exit
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_TRANS_NAMES
multiline_comment|/* if oldname has been translated, but newname not (and&n;&t; * has not already a suffix), take over the suffix from oldname.&n;&t; */
r_if
c_cond
(paren
id|oldlast.name
op_eq
id|oldbuf
op_logical_and
id|newlast.name
op_ne
id|newbuf
op_logical_and
id|newlast.name
(braket
id|newlast.len
op_minus
l_int|1
)braket
op_ne
l_char|&squot;#&squot;
)paren
(brace
r_int
id|i
op_assign
id|oldlast.len
op_minus
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|i
OG
l_int|0
op_logical_and
id|oldlast.name
(braket
id|i
)braket
op_ne
l_char|&squot;#&squot;
)paren
id|i
op_decrement
suffix:semicolon
id|memcpy
c_func
(paren
id|newbuf
comma
id|newlast.name
comma
id|newlast.len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|newbuf
op_plus
id|newlast.len
comma
id|oldlast.name
op_plus
id|i
comma
id|oldlast.len
op_minus
id|i
)paren
suffix:semicolon
id|newlast.len
op_add_assign
id|oldlast.len
op_minus
id|i
suffix:semicolon
id|newlast.name
op_assign
id|newbuf
suffix:semicolon
)brace
macro_line|#endif
id|atomic_inc
c_func
(paren
op_amp
id|olddir-&gt;i_count
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|newdir-&gt;i_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newdir-&gt;i_sb
op_logical_and
id|newdir-&gt;i_sb-&gt;dq_op
)paren
id|newdir-&gt;i_sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|newdir
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|newdir-&gt;i_sem
)paren
suffix:semicolon
id|error
op_assign
id|olddir-&gt;i_op
op_member_access_from_pointer
id|rename
c_func
(paren
id|olddir
comma
id|oldlast.name
comma
id|oldlast.len
comma
id|newdir
comma
id|newlast.name
comma
id|newlast.len
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_OMIRR
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|omirr_print
c_func
(paren
id|oldent
comma
id|newdir-&gt;i_dentry
comma
op_amp
id|newlast
comma
l_string|&quot; m %ld &quot;
comma
id|CURRENT_TIME
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|d_del
c_func
(paren
id|d_lookup
c_func
(paren
id|newdir
comma
op_amp
id|newlast
comma
l_int|NULL
)paren
comma
id|D_REMOVE
)paren
suffix:semicolon
id|d_move
c_func
(paren
id|d_lookup
c_func
(paren
id|olddir
comma
op_amp
id|oldlast
comma
l_int|NULL
)paren
comma
id|newdir
comma
op_amp
id|newlast
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|newdir-&gt;i_sem
)paren
suffix:semicolon
id|new_exit
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|newlasterror
)paren
(brace
id|iput
c_func
(paren
id|newinode
)paren
suffix:semicolon
)brace
id|iput
c_func
(paren
id|newdir
)paren
suffix:semicolon
id|old_exit
suffix:colon
id|iput
c_func
(paren
id|oldinode
)paren
suffix:semicolon
id|iput
c_func
(paren
id|olddir
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_rename
id|asmlinkage
r_int
id|sys_rename
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|from
comma
op_star
id|to
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|getname
c_func
(paren
id|oldname
comma
op_amp
id|from
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|getname
c_func
(paren
id|newname
comma
op_amp
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|do_rename
c_func
(paren
id|from
comma
id|to
)paren
suffix:semicolon
id|putname
c_func
(paren
id|to
)paren
suffix:semicolon
)brace
id|putname
c_func
(paren
id|from
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
eof
