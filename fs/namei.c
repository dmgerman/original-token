multiline_comment|/*&n; *  linux/fs/namei.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; * Some corrections by tytso.&n; */
multiline_comment|/* [Feb 1997 T. Schoebel-Theuer] Complete rewrite of the pathname&n; * lookup logic.&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/quotaops.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/dcache.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/namei.h&gt;
multiline_comment|/* This can be removed after the beta phase. */
DECL|macro|CACHE_SUPERVISE
mdefine_line|#define CACHE_SUPERVISE&t;/* debug the correctness of dcache entries */
DECL|macro|DEBUG
macro_line|#undef DEBUG&t;&t;/* some other debugging */
DECL|macro|ACC_MODE
mdefine_line|#define ACC_MODE(x) (&quot;&bslash;000&bslash;004&bslash;002&bslash;006&quot;[(x)&amp;O_ACCMODE])
multiline_comment|/* [Feb-1997 T. Schoebel-Theuer]&n; * Fundamental changes in the pathname lookup mechanisms (namei)&n; * were necessary because of omirr.  The reason is that omirr needs&n; * to know the _real_ pathname, not the user-supplied one, in case&n; * of symlinks (and also when transname replacements occur).&n; *&n; * The new code replaces the old recursive symlink resolution with&n; * an iterative one (in case of non-nested symlink chains).  It does&n; * this with calls to &lt;fs&gt;_follow_link().&n; * As a side effect, dir_namei(), _namei() and follow_link() are now &n; * replaced with a single function lookup_dentry() that can handle all &n; * the special cases of the former code.&n; *&n; * With the new dcache, the pathname is stored at each inode, at least as&n; * long as the refcount of the inode is positive.  As a side effect, the&n; * size of the dcache depends on the inode cache and thus is dynamic.&n; *&n; * [29-Apr-1998 C. Scott Ananian] Updated above description of symlink&n; * resolution to correspond with current state of the code.&n; *&n; * Note that the symlink resolution is not *completely* iterative.&n; * There is still a significant amount of tail- and mid- recursion in&n; * the algorithm.  Also, note that &lt;fs&gt;_readlink() is not used in&n; * lookup_dentry(): lookup_dentry() on the result of &lt;fs&gt;_readlink()&n; * may return different results than &lt;fs&gt;_follow_link().  Many virtual&n; * filesystems (including /proc) exhibit this behavior.&n; */
multiline_comment|/* [24-Feb-97 T. Schoebel-Theuer] Side effects caused by new implementation:&n; * New symlink semantics: when open() is called with flags O_CREAT | O_EXCL&n; * and the name already exists in form of a symlink, try to create the new&n; * name indicated by the symlink. The old code always complained that the&n; * name already exists, due to not following the symlink even if its target&n; * is nonexistent.  The new semantics affects also mknod() and link() when&n; * the name is a symlink pointing to a non-existant name.&n; *&n; * I don&squot;t know which semantics is the right one, since I have no access&n; * to standards. But I found by trial that HP-UX 9.0 has the full &quot;new&quot;&n; * semantics implemented, while SunOS 4.1.1 and Solaris (SunOS 5.4) have the&n; * &quot;old&quot; one. Personally, I think the new semantics is much more logical.&n; * Note that &quot;ln old new&quot; where &quot;new&quot; is a symlink pointing to a non-existing&n; * file does succeed in both HP-UX and SunOs, but not in Solaris&n; * and in the old Linux semantics.&n; */
multiline_comment|/* [16-Dec-97 Kevin Buhr] For security reasons, we change some symlink&n; * semantics.  See the comments in &quot;open_namei&quot; and &quot;do_link&quot; below.&n; *&n; * [10-Sep-98 Alan Modra] Another symlink change.&n; */
multiline_comment|/* In order to reduce some races, while at the same time doing additional&n; * checking and hopefully speeding things up, we copy filenames to the&n; * kernel data space before using them..&n; *&n; * POSIX.1 2.4: an empty pathname is invalid (ENOENT).&n; */
DECL|function|do_getname
r_static
r_inline
r_int
id|do_getname
c_func
(paren
r_const
r_char
op_star
id|filename
comma
r_char
op_star
id|page
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
r_int
id|len
op_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|filename
op_ge
id|TASK_SIZE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|segment_eq
c_func
(paren
id|get_fs
c_func
(paren
)paren
comma
id|KERNEL_DS
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|TASK_SIZE
op_minus
(paren
r_int
r_int
)paren
id|filename
OL
id|PAGE_SIZE
)paren
id|len
op_assign
id|TASK_SIZE
op_minus
(paren
r_int
r_int
)paren
id|filename
suffix:semicolon
id|retval
op_assign
id|strncpy_from_user
c_func
(paren
(paren
r_char
op_star
)paren
id|page
comma
id|filename
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|retval
OL
id|len
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|ENAMETOOLONG
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|getname
r_char
op_star
id|getname
c_func
(paren
r_const
r_char
op_star
id|filename
)paren
(brace
r_char
op_star
id|tmp
comma
op_star
id|result
suffix:semicolon
id|result
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|tmp
op_assign
id|__getname
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
r_int
id|retval
op_assign
id|do_getname
c_func
(paren
id|filename
comma
id|tmp
)paren
suffix:semicolon
id|result
op_assign
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|result
op_assign
id|ERR_PTR
c_func
(paren
id|retval
)paren
suffix:semicolon
)brace
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;permission()&n; *&n; * is used to check for read/write/execute permissions on a file.&n; * We use &quot;fsuid&quot; for this, letting us set arbitrary permissions&n; * for filesystem access without changing the &quot;normal&quot; uids which&n; * are used for other things..&n; */
DECL|function|permission
r_int
id|permission
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|mask
)paren
(brace
r_int
id|mode
op_assign
id|inode-&gt;i_mode
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_op
op_logical_and
id|inode-&gt;i_op-&gt;permission
)paren
r_return
id|inode-&gt;i_op
op_member_access_from_pointer
id|permission
c_func
(paren
id|inode
comma
id|mask
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|mask
op_amp
id|S_IWOTH
)paren
op_logical_and
id|IS_RDONLY
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|S_ISREG
c_func
(paren
id|mode
)paren
op_logical_or
id|S_ISDIR
c_func
(paren
id|mode
)paren
op_logical_or
id|S_ISLNK
c_func
(paren
id|mode
)paren
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
multiline_comment|/* Nobody gets write access to a read-only fs */
r_else
r_if
c_cond
(paren
(paren
id|mask
op_amp
id|S_IWOTH
)paren
op_logical_and
id|IS_IMMUTABLE
c_func
(paren
id|inode
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* Nobody gets write access to an immutable file */
r_else
r_if
c_cond
(paren
id|current-&gt;fsuid
op_eq
id|inode-&gt;i_uid
)paren
id|mode
op_rshift_assign
l_int|6
suffix:semicolon
r_else
r_if
c_cond
(paren
id|in_group_p
c_func
(paren
id|inode-&gt;i_gid
)paren
)paren
id|mode
op_rshift_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|mode
op_amp
id|mask
op_amp
id|S_IRWXO
)paren
op_eq
id|mask
)paren
op_logical_or
id|capable
c_func
(paren
id|CAP_DAC_OVERRIDE
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* read and search access */
r_if
c_cond
(paren
(paren
id|mask
op_eq
id|S_IROTH
)paren
op_logical_or
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
op_logical_and
op_logical_neg
(paren
id|mask
op_amp
op_complement
(paren
id|S_IROTH
op_or
id|S_IXOTH
)paren
)paren
)paren
)paren
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_DAC_READ_SEARCH
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
multiline_comment|/*&n; * get_write_access() gets write permission for a file.&n; * put_write_access() releases this write permission.&n; * This is used for regular files.&n; * We cannot support write (and maybe mmap read-write shared) accesses and&n; * MAP_DENYWRITE mmappings simultaneously. The i_writecount field of an inode&n; * can have the following values:&n; * 0: no writers, no VM_DENYWRITE mappings&n; * &lt; 0: (-i_writecount) vm_area_structs with VM_DENYWRITE set exist&n; * &gt; 0: (i_writecount) users are writing to the file.&n; *&n; * WARNING: as soon as we will move get_write_access(), do_mmap() or&n; * prepare_binfmt() out of the big lock we will need a spinlock protecting&n; * the checks in all 3. For the time being it is not needed.&n; */
DECL|function|get_write_access
r_int
id|get_write_access
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|inode-&gt;i_writecount
)paren
OL
l_int|0
)paren
r_return
op_minus
id|ETXTBSY
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|inode-&gt;i_writecount
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|put_write_access
r_void
id|put_write_access
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|inode-&gt;i_writecount
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * &quot;.&quot; and &quot;..&quot; are special - &quot;..&quot; especially so because it has to be able&n; * to know about the current root directory and parent relationships&n; */
DECL|function|reserved_lookup
r_static
r_struct
id|dentry
op_star
id|reserved_lookup
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_struct
id|qstr
op_star
id|name
)paren
(brace
r_struct
id|dentry
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|name-&gt;name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
r_switch
c_cond
(paren
id|name-&gt;len
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|name-&gt;name
(braket
l_int|1
)braket
op_ne
l_char|&squot;.&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_ne
id|current-&gt;fs-&gt;root
)paren
id|parent
op_assign
id|parent-&gt;d_covers-&gt;d_parent
suffix:semicolon
multiline_comment|/* fallthrough */
r_case
l_int|1
suffix:colon
id|result
op_assign
id|parent
suffix:semicolon
)brace
)brace
r_return
id|dget
c_func
(paren
id|result
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Internal lookup() using the new generic dcache.&n; */
DECL|function|cached_lookup
r_static
r_struct
id|dentry
op_star
id|cached_lookup
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_struct
id|qstr
op_star
id|name
comma
r_int
id|flags
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|d_lookup
c_func
(paren
id|parent
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
op_logical_and
id|dentry-&gt;d_op
op_logical_and
id|dentry-&gt;d_op-&gt;d_revalidate
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_op
op_member_access_from_pointer
id|d_revalidate
c_func
(paren
id|dentry
comma
id|flags
)paren
op_logical_and
op_logical_neg
id|d_invalidate
c_func
(paren
id|dentry
)paren
)paren
(brace
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|dentry
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|dentry
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called when everything else fails, and we actually have&n; * to go to the low-level filesystem to find out what we should do..&n; *&n; * We get the directory semaphore, and after getting that we also&n; * make sure that nobody added the entry to the dcache in the meantime..&n; */
DECL|function|real_lookup
r_static
r_struct
id|dentry
op_star
id|real_lookup
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_struct
id|qstr
op_star
id|name
comma
r_int
id|flags
)paren
(brace
r_struct
id|dentry
op_star
id|result
suffix:semicolon
r_struct
id|inode
op_star
id|dir
op_assign
id|parent-&gt;d_inode
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First re-do the cached lookup just in case it was created&n;&t; * while we waited for the directory semaphore..&n;&t; *&n;&t; * FIXME! This could use version numbering or similar to&n;&t; * avoid unnecessary cache lookups.&n;&t; */
id|result
op_assign
id|d_lookup
c_func
(paren
id|parent
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|d_alloc
c_func
(paren
id|parent
comma
id|name
)paren
suffix:semicolon
id|result
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
)paren
(brace
id|result
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|lookup
c_func
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_else
id|result
op_assign
id|dentry
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Uhhuh! Nasty case: the cache was re-populated while&n;&t; * we waited on the semaphore. Need to revalidate, but&n;&t; * we&squot;re going to return this entry regardless (same&n;&t; * as if it was busy).&n;&t; */
id|up
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result-&gt;d_op
op_logical_and
id|result-&gt;d_op-&gt;d_revalidate
)paren
id|result-&gt;d_op
op_member_access_from_pointer
id|d_revalidate
c_func
(paren
id|result
comma
id|flags
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|do_follow_link
r_static
r_struct
id|dentry
op_star
id|do_follow_link
c_func
(paren
r_struct
id|dentry
op_star
id|base
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
r_int
id|follow
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
(paren
id|follow
op_amp
id|LOOKUP_FOLLOW
)paren
op_logical_and
id|inode
op_logical_and
id|inode-&gt;i_op
op_logical_and
id|inode-&gt;i_op-&gt;follow_link
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;link_count
OL
l_int|32
)paren
(brace
r_struct
id|dentry
op_star
id|result
suffix:semicolon
id|current-&gt;link_count
op_increment
suffix:semicolon
multiline_comment|/* This eats the base */
id|result
op_assign
id|inode-&gt;i_op
op_member_access_from_pointer
id|follow_link
c_func
(paren
id|dentry
comma
id|base
comma
id|follow
)paren
suffix:semicolon
id|current-&gt;link_count
op_decrement
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|dentry
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ELOOP
)paren
suffix:semicolon
)brace
id|dput
c_func
(paren
id|base
)paren
suffix:semicolon
r_return
id|dentry
suffix:semicolon
)brace
DECL|function|follow_mount
r_static
r_inline
r_struct
id|dentry
op_star
id|follow_mount
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|dentry
op_star
id|mnt
op_assign
id|dentry-&gt;d_mounts
suffix:semicolon
r_if
c_cond
(paren
id|mnt
op_ne
id|dentry
)paren
(brace
id|dget
c_func
(paren
id|mnt
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|dentry
op_assign
id|mnt
suffix:semicolon
)brace
r_return
id|dentry
suffix:semicolon
)brace
multiline_comment|/*&n; * Name resolution.&n; *&n; * This is the basic name resolution function, turning a pathname&n; * into the final dentry.&n; */
DECL|function|lookup_dentry
r_struct
id|dentry
op_star
id|lookup_dentry
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|dentry
op_star
id|base
comma
r_int
r_int
id|lookup_flags
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_if
c_cond
(paren
op_star
id|name
op_eq
l_char|&squot;/&squot;
)paren
(brace
r_if
c_cond
(paren
id|base
)paren
id|dput
c_func
(paren
id|base
)paren
suffix:semicolon
r_do
(brace
id|name
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|name
op_eq
l_char|&squot;/&squot;
)paren
suffix:semicolon
id|__prefix_lookup_dentry
c_func
(paren
id|name
comma
id|lookup_flags
)paren
suffix:semicolon
id|base
op_assign
id|dget
c_func
(paren
id|current-&gt;fs-&gt;root
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|base
)paren
(brace
id|base
op_assign
id|dget
c_func
(paren
id|current-&gt;fs-&gt;pwd
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|name
)paren
r_goto
id|return_base
suffix:semicolon
id|inode
op_assign
id|base-&gt;d_inode
suffix:semicolon
id|lookup_flags
op_and_assign
id|LOOKUP_FOLLOW
op_or
id|LOOKUP_DIRECTORY
op_or
id|LOOKUP_SLASHOK
suffix:semicolon
multiline_comment|/* At this point we know we have a real path component. */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
r_int
id|hash
suffix:semicolon
r_struct
id|qstr
id|this
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|c
suffix:semicolon
id|err
op_assign
id|permission
c_func
(paren
id|inode
comma
id|MAY_EXEC
)paren
suffix:semicolon
id|dentry
op_assign
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_break
suffix:semicolon
id|this.name
op_assign
id|name
suffix:semicolon
id|c
op_assign
op_star
(paren
r_const
r_int
r_char
op_star
)paren
id|name
suffix:semicolon
id|hash
op_assign
id|init_name_hash
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
id|name
op_increment
suffix:semicolon
id|hash
op_assign
id|partial_name_hash
c_func
(paren
id|c
comma
id|hash
)paren
suffix:semicolon
id|c
op_assign
op_star
(paren
r_const
r_int
r_char
op_star
)paren
id|name
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c
op_logical_and
(paren
id|c
op_ne
l_char|&squot;/&squot;
)paren
)paren
suffix:semicolon
id|this.len
op_assign
id|name
op_minus
(paren
r_const
r_char
op_star
)paren
id|this.name
suffix:semicolon
id|this.hash
op_assign
id|end_name_hash
c_func
(paren
id|hash
)paren
suffix:semicolon
multiline_comment|/* remove trailing slashes? */
id|flags
op_assign
id|lookup_flags
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
(brace
r_char
id|tmp
suffix:semicolon
id|flags
op_or_assign
id|LOOKUP_FOLLOW
op_or
id|LOOKUP_DIRECTORY
suffix:semicolon
r_do
(brace
id|tmp
op_assign
op_star
op_increment
id|name
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_eq
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
id|flags
op_or_assign
id|LOOKUP_CONTINUE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * See if the low-level filesystem might want&n;&t;&t; * to use its own hash..&n;&t;&t; */
r_if
c_cond
(paren
id|base-&gt;d_op
op_logical_and
id|base-&gt;d_op-&gt;d_hash
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
id|base-&gt;d_op
op_member_access_from_pointer
id|d_hash
c_func
(paren
id|base
comma
op_amp
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
(brace
id|dentry
op_assign
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* This does the actual lookups.. */
id|dentry
op_assign
id|reserved_lookup
c_func
(paren
id|base
comma
op_amp
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
(brace
id|dentry
op_assign
id|cached_lookup
c_func
(paren
id|base
comma
op_amp
id|this
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
(brace
id|dentry
op_assign
id|real_lookup
c_func
(paren
id|base
comma
op_amp
id|this
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Check mountpoints.. */
id|dentry
op_assign
id|follow_mount
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
id|base
op_assign
id|do_follow_link
c_func
(paren
id|base
comma
id|dentry
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|base
)paren
)paren
r_goto
id|return_base
suffix:semicolon
id|inode
op_assign
id|base-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|LOOKUP_DIRECTORY
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|no_inode
suffix:semicolon
id|dentry
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOTDIR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_op
op_logical_or
op_logical_neg
id|inode-&gt;i_op-&gt;lookup
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|LOOKUP_CONTINUE
)paren
r_continue
suffix:semicolon
)brace
id|return_base
suffix:colon
r_return
id|base
suffix:semicolon
multiline_comment|/*&n; * The case of a nonexisting file is special.&n; *&n; * In the middle of a pathname lookup (ie when&n; * LOOKUP_CONTINUE is set), it&squot;s an obvious&n; * error and returns ENOENT.&n; *&n; * At the end of a pathname lookup it&squot;s legal,&n; * and we return a negative dentry. However, we&n; * get here only if there were trailing slashes,&n; * which is legal only if we know it&squot;s supposed&n; * to be a directory (ie &quot;mkdir&quot;). Thus the&n; * LOOKUP_SLASHOK flag.&n; */
id|no_inode
suffix:colon
id|dentry
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOENT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|LOOKUP_CONTINUE
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|LOOKUP_SLASHOK
)paren
r_goto
id|return_base
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dput
c_func
(paren
id|base
)paren
suffix:semicolon
r_return
id|dentry
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;namei()&n; *&n; * is used by most simple commands to get the inode of a specified name.&n; * Open, link etc use their own routines, but this is enough for things&n; * like &squot;chmod&squot; etc.&n; *&n; * namei exists in two versions: namei/lnamei. The only difference is&n; * that namei follows links, while lnamei does not.&n; */
DECL|function|__namei
r_struct
id|dentry
op_star
id|__namei
c_func
(paren
r_const
r_char
op_star
id|pathname
comma
r_int
r_int
id|lookup_flags
)paren
(brace
r_char
op_star
id|name
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|name
op_assign
id|getname
c_func
(paren
id|pathname
)paren
suffix:semicolon
id|dentry
op_assign
(paren
r_struct
id|dentry
op_star
)paren
id|name
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|name
)paren
)paren
(brace
id|dentry
op_assign
id|lookup_dentry
c_func
(paren
id|name
comma
l_int|NULL
comma
id|lookup_flags
)paren
suffix:semicolon
id|putname
c_func
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_inode
)paren
(brace
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|dentry
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOENT
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
id|dentry
suffix:semicolon
)brace
multiline_comment|/*&n; * It&squot;s inline, so penalty for filesystems that don&squot;t use sticky bit is&n; * minimal.&n; */
DECL|function|check_sticky
r_static
r_inline
r_int
id|check_sticky
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dir-&gt;i_mode
op_amp
id|S_ISVTX
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_uid
op_eq
id|current-&gt;fsuid
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;i_uid
op_eq
id|current-&gt;fsuid
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_logical_neg
id|capable
c_func
(paren
id|CAP_FOWNER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Check whether we can remove a link victim from directory dir, check&n; *  whether the type of victim is right.&n; *  1. We can&squot;t do it if dir is read-only (done in permission())&n; *  2. We should have write and exec permissions on dir&n; *  3. We can&squot;t remove anything from append-only dir&n; *  4. We can&squot;t do anything with immutable dir (done in permission())&n; *  5. If the sticky bit on dir is set we should either&n; *&t;a. be owner of dir, or&n; *&t;b. be owner of victim, or&n; *&t;c. have CAP_FOWNER capability&n; *  6. If the victim is append-only or immutable we can&squot;t do antyhing with&n; *     links pointing to it.&n; *  7. If we were asked to remove a directory and victim isn&squot;t one - ENOTDIR.&n; *  8. If we were asked to remove a non-directory and victim isn&squot;t one - EISDIR.&n; *  9. We can&squot;t remove a root or mountpoint.&n; */
DECL|function|may_delete
r_static
r_inline
r_int
id|may_delete
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|victim
comma
r_int
id|isdir
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|victim-&gt;d_inode
op_logical_or
id|victim-&gt;d_parent-&gt;d_inode
op_ne
id|dir
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|error
op_assign
id|permission
c_func
(paren
id|dir
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|dir
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|check_sticky
c_func
(paren
id|dir
comma
id|victim-&gt;d_inode
)paren
op_logical_or
id|IS_APPEND
c_func
(paren
id|victim-&gt;d_inode
)paren
op_logical_or
id|IS_IMMUTABLE
c_func
(paren
id|victim-&gt;d_inode
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|isdir
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|victim-&gt;d_inode-&gt;i_mode
)paren
)paren
r_return
op_minus
id|ENOTDIR
suffix:semicolon
r_if
c_cond
(paren
id|IS_ROOT
c_func
(paren
id|victim
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|victim-&gt;d_mounts
op_ne
id|victim-&gt;d_covers
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|victim-&gt;d_inode-&gt;i_mode
)paren
)paren
r_return
op_minus
id|EISDIR
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&t;Check whether we can create an object with dentry child in directory&n; *  dir.&n; *  1. We can&squot;t do it if child already exists (open has special treatment for&n; *     this case, but since we are inlined it&squot;s OK)&n; *  2. We can&squot;t do it if dir is read-only (done in permission())&n; *  3. We should have write and exec permissions on dir&n; *  4. We can&squot;t do it if dir is immutable (done in permission())&n; */
DECL|function|may_create
r_static
r_inline
r_int
id|may_create
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|child
)paren
(brace
r_if
c_cond
(paren
id|child-&gt;d_inode
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
r_return
id|permission
c_func
(paren
id|dir
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Special case: O_CREAT|O_EXCL implies O_NOFOLLOW for security&n; * reasons.&n; *&n; * O_DIRECTORY translates into forcing a directory lookup.&n; */
DECL|function|lookup_flags
r_static
r_inline
r_int
id|lookup_flags
c_func
(paren
r_int
r_int
id|f
)paren
(brace
r_int
r_int
id|retval
op_assign
id|LOOKUP_FOLLOW
suffix:semicolon
r_if
c_cond
(paren
id|f
op_amp
id|O_NOFOLLOW
)paren
id|retval
op_and_assign
op_complement
id|LOOKUP_FOLLOW
suffix:semicolon
r_if
c_cond
(paren
(paren
id|f
op_amp
(paren
id|O_CREAT
op_or
id|O_EXCL
)paren
)paren
op_eq
(paren
id|O_CREAT
op_or
id|O_EXCL
)paren
)paren
id|retval
op_and_assign
op_complement
id|LOOKUP_FOLLOW
suffix:semicolon
r_if
c_cond
(paren
id|f
op_amp
id|O_DIRECTORY
)paren
id|retval
op_or_assign
id|LOOKUP_DIRECTORY
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|vfs_create
r_int
id|vfs_create
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_int
id|error
suffix:semicolon
id|mode
op_and_assign
id|S_IALLUGO
op_amp
op_complement
id|current-&gt;fs-&gt;umask
suffix:semicolon
id|mode
op_or_assign
id|S_IFREG
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
id|error
op_assign
id|may_create
c_func
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* shouldn&squot;t it be ENOSYS? */
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;create
)paren
r_goto
id|exit_lock
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|dir
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|create
c_func
(paren
id|dir
comma
id|dentry
comma
id|mode
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|up
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;open_namei()&n; *&n; * namei for open - this is in fact almost the whole open-routine.&n; *&n; * Note that the low bits of &quot;flag&quot; aren&squot;t the same as in the open&n; * system call - they are 00 - no permissions needed&n; *&t;&t;&t;  01 - read permission needed&n; *&t;&t;&t;  10 - write permission needed&n; *&t;&t;&t;  11 - read/write permissions needed&n; * which is a lot more logical, and also allows the &quot;no perm&quot; needed&n; * for symlinks (where the permissions are checked later).&n; */
DECL|function|open_namei
r_struct
id|dentry
op_star
id|open_namei
c_func
(paren
r_const
r_char
op_star
id|pathname
comma
r_int
id|flag
comma
r_int
id|mode
)paren
(brace
r_int
id|acc_mode
comma
id|error
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|dentry
op_assign
id|lookup_dentry
c_func
(paren
id|pathname
comma
l_int|NULL
comma
id|lookup_flags
c_func
(paren
id|flag
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
r_return
id|dentry
suffix:semicolon
id|acc_mode
op_assign
id|ACC_MODE
c_func
(paren
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|O_CREAT
)paren
(brace
r_struct
id|dentry
op_star
id|dir
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flag
op_amp
id|O_EXCL
)paren
)paren
r_goto
id|nocreate
suffix:semicolon
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
id|dir
op_assign
id|lock_parent
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_parent
c_func
(paren
id|dir
comma
id|dentry
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Really nasty race happened. What&squot;s the &n;&t;&t;&t; * right error code? We had a dentry, but&n;&t;&t;&t; * before we could use it it was removed&n;&t;&t;&t; * by somebody else. We could just re-try&n;&t;&t;&t; * everything, I guess.&n;&t;&t;&t; *&n;&t;&t;&t; * ENOENT is definitely wrong.&n;&t;&t;&t; */
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|unlock_dir
c_func
(paren
id|dir
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Somebody might have created the file while we&n;&t;&t; * waited for the directory lock.. So we have to&n;&t;&t; * re-do the existence test.&n;&t;&t; */
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
(brace
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|O_EXCL
)paren
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
id|vfs_create
c_func
(paren
id|dir-&gt;d_inode
comma
id|dentry
comma
id|mode
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t check for write permission, don&squot;t truncate */
id|acc_mode
op_assign
l_int|0
suffix:semicolon
id|flag
op_and_assign
op_complement
id|O_TRUNC
suffix:semicolon
)brace
id|unlock_dir
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
)brace
id|nocreate
suffix:colon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
m_exit
suffix:semicolon
id|error
op_assign
op_minus
id|ELOOP
suffix:semicolon
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|error
op_assign
op_minus
id|EISDIR
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
(paren
id|flag
op_amp
id|FMODE_WRITE
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|error
op_assign
id|permission
c_func
(paren
id|inode
comma
id|acc_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
multiline_comment|/*&n;&t; * FIFO&squot;s, sockets and device files are special: they don&squot;t&n;&t; * actually live on the filesystem itself, and as such you&n;&t; * can write to them even if the filesystem is read-only.&n;&t; */
r_if
c_cond
(paren
id|S_ISFIFO
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISSOCK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|flag
op_and_assign
op_complement
id|O_TRUNC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISCHR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|IS_NODEV
c_func
(paren
id|inode
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|flag
op_and_assign
op_complement
id|O_TRUNC
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|flag
op_amp
l_int|2
)paren
)paren
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * An append-only file must be opened in append mode for writing.&n;&t; */
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|inode
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|FMODE_WRITE
)paren
op_logical_and
op_logical_neg
(paren
id|flag
op_amp
id|O_APPEND
)paren
)paren
r_goto
m_exit
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|O_TRUNC
)paren
r_goto
m_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flag
op_amp
id|O_TRUNC
)paren
(brace
id|error
op_assign
id|get_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Refuse to truncate files with mandatory locks held on them.&n;&t;&t; */
id|error
op_assign
id|locks_verify_locked
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|DQUOT_INIT
c_func
(paren
id|inode
)paren
suffix:semicolon
id|error
op_assign
id|do_truncate
c_func
(paren
id|dentry
comma
l_int|0
)paren
suffix:semicolon
)brace
id|put_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flag
op_amp
id|FMODE_WRITE
)paren
id|DQUOT_INIT
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
id|dentry
suffix:semicolon
m_exit
suffix:colon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
)brace
DECL|function|vfs_mknod
r_int
id|vfs_mknod
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
comma
id|dev_t
id|dev
)paren
(brace
r_int
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
id|mode
op_and_assign
op_complement
id|current-&gt;fs-&gt;umask
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|S_ISCHR
c_func
(paren
id|mode
)paren
op_logical_or
id|S_ISBLK
c_func
(paren
id|mode
)paren
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_MKNOD
)paren
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
id|may_create
c_func
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;mknod
)paren
r_goto
id|exit_lock
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|dir
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|mknod
c_func
(paren
id|dir
comma
id|dentry
comma
id|mode
comma
id|dev
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|up
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_mknod
r_struct
id|dentry
op_star
id|do_mknod
c_func
(paren
r_const
r_char
op_star
id|filename
comma
r_int
id|mode
comma
id|dev_t
id|dev
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|dentry
op_star
id|dir
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
comma
op_star
id|retval
suffix:semicolon
id|dentry
op_assign
id|lookup_dentry
c_func
(paren
id|filename
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
r_return
id|dentry
suffix:semicolon
id|dir
op_assign
id|lock_parent
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_parent
c_func
(paren
id|dir
comma
id|dentry
)paren
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
id|vfs_mknod
c_func
(paren
id|dir-&gt;d_inode
comma
id|dentry
comma
id|mode
comma
id|dev
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|retval
op_assign
id|ERR_PTR
c_func
(paren
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|retval
op_assign
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|unlock_dir
c_func
(paren
id|dir
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|sys_mknod
id|asmlinkage
r_int
id|sys_mknod
c_func
(paren
r_const
r_char
op_star
id|filename
comma
r_int
id|mode
comma
id|dev_t
id|dev
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
comma
op_star
id|dir
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|tmp
op_assign
id|getname
c_func
(paren
id|filename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|tmp
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|dentry
op_assign
id|lookup_dentry
c_func
(paren
id|tmp
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
r_goto
id|out
suffix:semicolon
id|dir
op_assign
id|lock_parent
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_parent
c_func
(paren
id|dir
comma
id|dentry
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
r_switch
c_cond
(paren
id|mode
op_amp
id|S_IFMT
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
id|S_IFREG
suffix:colon
id|error
op_assign
id|vfs_create
c_func
(paren
id|dir-&gt;d_inode
comma
id|dentry
comma
id|mode
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFCHR
suffix:colon
r_case
id|S_IFBLK
suffix:colon
r_case
id|S_IFIFO
suffix:colon
r_case
id|S_IFSOCK
suffix:colon
id|error
op_assign
id|vfs_mknod
c_func
(paren
id|dir-&gt;d_inode
comma
id|dentry
comma
id|mode
comma
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFDIR
suffix:colon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|unlock_dir
c_func
(paren
id|dir
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|vfs_mkdir
r_int
id|vfs_mkdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_int
id|error
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
id|error
op_assign
id|may_create
c_func
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;mkdir
)paren
r_goto
id|exit_lock
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|dir
)paren
suffix:semicolon
id|mode
op_and_assign
(paren
id|S_IRWXUGO
op_or
id|S_ISVTX
)paren
op_amp
op_complement
id|current-&gt;fs-&gt;umask
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|mkdir
c_func
(paren
id|dir
comma
id|dentry
comma
id|mode
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|up
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_mkdir
r_static
r_inline
r_int
id|do_mkdir
c_func
(paren
r_const
r_char
op_star
id|pathname
comma
r_int
id|mode
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|dentry
op_star
id|dir
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|dentry
op_assign
id|lookup_dentry
c_func
(paren
id|pathname
comma
l_int|NULL
comma
id|LOOKUP_SLASHOK
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
r_goto
m_exit
suffix:semicolon
multiline_comment|/*&n;&t; * EEXIST is kind of a strange error code to&n;&t; * return, but basically if the dentry was moved&n;&t; * or unlinked while we locked the parent, we&n;&t; * do know that it _did_ exist before, and as&n;&t; * such it makes perfect sense.. In contrast,&n;&t; * ENOENT doesn&squot;t make sense for mkdir.&n;&t; */
id|dir
op_assign
id|lock_parent
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_parent
c_func
(paren
id|dir
comma
id|dentry
)paren
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
id|vfs_mkdir
c_func
(paren
id|dir-&gt;d_inode
comma
id|dentry
comma
id|mode
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|unlock_dir
c_func
(paren
id|dir
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_mkdir
id|asmlinkage
r_int
id|sys_mkdir
c_func
(paren
r_const
r_char
op_star
id|pathname
comma
r_int
id|mode
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
id|tmp
op_assign
id|getname
c_func
(paren
id|pathname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|tmp
)paren
)paren
(brace
r_return
id|PTR_ERR
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|do_mkdir
c_func
(paren
id|tmp
comma
id|mode
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * We try to drop the dentry early: we should have&n; * a usage count of 2 if we&squot;re the only user of this&n; * dentry, and if that is true (possibly after pruning&n; * the dcache), then we drop the dentry now.&n; *&n; * A low-level filesystem can, if it choses, legally&n; * do a&n; *&n; *&t;if (!d_unhashed(dentry))&n; *&t;&t;return -EBUSY;&n; *&n; * if it cannot handle the case of removing a directory&n; * that is still in use by something else..&n; */
DECL|function|d_unhash
r_static
r_void
id|d_unhash
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|dentry-&gt;d_count
)paren
(brace
r_default
suffix:colon
id|shrink_dcache_parent
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_count
op_ne
l_int|2
)paren
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|d_drop
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
)brace
DECL|function|vfs_rmdir
r_int
id|vfs_rmdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
id|may_delete
c_func
(paren
id|dir
comma
id|dentry
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;rmdir
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|dir
)paren
suffix:semicolon
id|double_down
c_func
(paren
op_amp
id|dir-&gt;i_zombie
comma
op_amp
id|dentry-&gt;d_inode-&gt;i_zombie
)paren
suffix:semicolon
id|d_unhash
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|rmdir
c_func
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
id|double_up
c_func
(paren
op_amp
id|dir-&gt;i_zombie
comma
op_amp
id|dentry-&gt;d_inode-&gt;i_zombie
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_rmdir
r_static
r_inline
r_int
id|do_rmdir
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|dentry
op_star
id|dir
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|dentry
op_assign
id|lookup_dentry
c_func
(paren
id|name
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|dir
op_assign
id|lock_parent
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|check_parent
c_func
(paren
id|dir
comma
id|dentry
)paren
)paren
id|error
op_assign
id|vfs_rmdir
c_func
(paren
id|dir-&gt;d_inode
comma
id|dentry
)paren
suffix:semicolon
id|unlock_dir
c_func
(paren
id|dir
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_rmdir
id|asmlinkage
r_int
id|sys_rmdir
c_func
(paren
r_const
r_char
op_star
id|pathname
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
id|tmp
op_assign
id|getname
c_func
(paren
id|pathname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|tmp
)paren
)paren
(brace
r_return
id|PTR_ERR
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|do_rmdir
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|vfs_unlink
r_int
id|vfs_unlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
id|error
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
id|error
op_assign
id|may_delete
c_func
(paren
id|dir
comma
id|dentry
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;i_op
op_logical_and
id|dir-&gt;i_op-&gt;unlink
)paren
(brace
id|DQUOT_INIT
c_func
(paren
id|dir
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|unlink
c_func
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
)brace
)brace
id|up
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_unlink
r_int
id|do_unlink
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|dentry
op_star
id|dir
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|dentry
op_assign
id|lookup_dentry
c_func
(paren
id|name
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|dir
op_assign
id|lock_parent
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|check_parent
c_func
(paren
id|dir
comma
id|dentry
)paren
)paren
id|error
op_assign
id|vfs_unlink
c_func
(paren
id|dir-&gt;d_inode
comma
id|dentry
)paren
suffix:semicolon
id|unlock_dir
c_func
(paren
id|dir
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_unlink
id|asmlinkage
r_int
id|sys_unlink
c_func
(paren
r_const
r_char
op_star
id|pathname
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
id|tmp
op_assign
id|getname
c_func
(paren
id|pathname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|tmp
)paren
)paren
(brace
r_return
id|PTR_ERR
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|do_unlink
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|vfs_symlink
r_int
id|vfs_symlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|oldname
)paren
(brace
r_int
id|error
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
id|error
op_assign
id|may_create
c_func
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;symlink
)paren
r_goto
id|exit_lock
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|dir
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|symlink
c_func
(paren
id|dir
comma
id|dentry
comma
id|oldname
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|up
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_symlink
r_static
r_inline
r_int
id|do_symlink
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|dentry
op_star
id|dir
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|dentry
op_assign
id|lookup_dentry
c_func
(paren
id|newname
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|dir
op_assign
id|lock_parent
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_parent
c_func
(paren
id|dir
comma
id|dentry
)paren
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
id|vfs_symlink
c_func
(paren
id|dir-&gt;d_inode
comma
id|dentry
comma
id|oldname
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|unlock_dir
c_func
(paren
id|dir
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_symlink
id|asmlinkage
r_int
id|sys_symlink
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|from
suffix:semicolon
r_char
op_star
id|to
suffix:semicolon
id|from
op_assign
id|getname
c_func
(paren
id|oldname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|from
)paren
)paren
(brace
r_return
id|PTR_ERR
c_func
(paren
id|from
)paren
suffix:semicolon
)brace
id|to
op_assign
id|getname
c_func
(paren
id|newname
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|to
)paren
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|do_symlink
c_func
(paren
id|from
comma
id|to
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|putname
c_func
(paren
id|to
)paren
suffix:semicolon
)brace
id|putname
c_func
(paren
id|from
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|vfs_link
r_int
id|vfs_link
c_func
(paren
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|new_dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|error
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|inode
op_assign
id|old_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
id|may_create
c_func
(paren
id|dir
comma
id|new_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EXDEV
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;i_dev
op_ne
id|inode-&gt;i_dev
)paren
r_goto
id|exit_lock
suffix:semicolon
multiline_comment|/*&n;&t; * A link to an append-only or immutable file cannot be created.&n;&t; */
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|inode
)paren
op_logical_or
id|IS_IMMUTABLE
c_func
(paren
id|inode
)paren
)paren
r_goto
id|exit_lock
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;link
)paren
r_goto
id|exit_lock
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|dir
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|link
c_func
(paren
id|old_dentry
comma
id|dir
comma
id|new_dentry
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|up
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_link
r_static
r_inline
r_int
id|do_link
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_struct
id|dentry
op_star
id|old_dentry
comma
op_star
id|new_dentry
comma
op_star
id|dir
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * Hardlinks are often used in delicate situations.  We avoid&n;&t; * security-related surprises by not following symlinks on the&n;&t; * newname.  --KAB&n;&t; *&n;&t; * We don&squot;t follow them on the oldname either to be compatible&n;&t; * with linux 2.0, and to avoid hard-linking to directories&n;&t; * and other special files.  --ADM&n;&t; */
id|old_dentry
op_assign
id|lookup_dentry
c_func
(paren
id|oldname
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|old_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|old_dentry
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|new_dentry
op_assign
id|lookup_dentry
c_func
(paren
id|newname
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|new_dentry
)paren
)paren
r_goto
id|exit_old
suffix:semicolon
id|dir
op_assign
id|lock_parent
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_parent
c_func
(paren
id|dir
comma
id|new_dentry
)paren
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
id|vfs_link
c_func
(paren
id|old_dentry
comma
id|dir-&gt;d_inode
comma
id|new_dentry
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|unlock_dir
c_func
(paren
id|dir
)paren
suffix:semicolon
id|dput
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
id|exit_old
suffix:colon
id|dput
c_func
(paren
id|old_dentry
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_link
id|asmlinkage
r_int
id|sys_link
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|from
suffix:semicolon
r_char
op_star
id|to
suffix:semicolon
id|from
op_assign
id|getname
c_func
(paren
id|oldname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|from
)paren
)paren
(brace
r_return
id|PTR_ERR
c_func
(paren
id|from
)paren
suffix:semicolon
)brace
id|to
op_assign
id|getname
c_func
(paren
id|newname
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|to
)paren
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|do_link
c_func
(paren
id|from
comma
id|to
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|putname
c_func
(paren
id|to
)paren
suffix:semicolon
)brace
id|putname
c_func
(paren
id|from
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * The worst of all namespace operations - renaming directory. &quot;Perverted&quot;&n; * doesn&squot;t even start to describe it. Somebody in UCB had a heck of a trip...&n; * Problems:&n; *&t;a) we can get into loop creation. Check is done in is_subdir().&n; *&t;b) race potential - two innocent renames can create a loop together.&n; *&t;   That&squot;s where 4.4 screws up. Current fix: serialization on&n; *&t;   sb-&gt;s_vfs_rename_sem. We might be more accurate, but that&squot;s another&n; *&t;   story.&n; *&t;c) we have to lock _three_ objects - parents and victim (if it exists).&n; *&t;   And that - after we got -&gt;i_sem on parents (until then we don&squot;t know&n; *&t;   whether the target exists at all, let alone whether it is a directory&n; *&t;   or not). Solution: -&gt;i_zombie. Taken only after -&gt;i_sem. Always taken&n; *&t;   on link creation/removal of any kind. And taken (without -&gt;i_sem) on&n; *&t;   directory that will be removed (both in rmdir() and here).&n; *&t;d) some filesystems don&squot;t support opened-but-unlinked directories,&n; *&t;   either because of layout or because they are not ready to deal with&n; *&t;   all cases correctly. The latter will be fixed (taking this sort of&n; *&t;   stuff into VFS), but the former is not going away. Solution: the same&n; *&t;   trick as in rmdir().&n; *&t;e) conversion from fhandle to dentry may come in the wrong moment - when&n; *&t;   we are removing the target. Solution: we will have to grab -&gt;i_zombie&n; *&t;   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on&n; *&t;   -&gt;i_sem on parents, which works but leads to some truely excessive&n; *&t;   locking].&n; */
DECL|function|vfs_rename_dir
r_int
id|vfs_rename_dir
c_func
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_struct
id|dentry
op_star
id|new_dentry
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|inode
op_star
id|target
suffix:semicolon
r_if
c_cond
(paren
id|old_dentry-&gt;d_inode
op_eq
id|new_dentry-&gt;d_inode
)paren
r_return
l_int|0
suffix:semicolon
id|error
op_assign
id|may_delete
c_func
(paren
id|old_dir
comma
id|old_dentry
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|new_dir-&gt;i_dev
op_ne
id|old_dir-&gt;i_dev
)paren
r_return
op_minus
id|EXDEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_dentry-&gt;d_inode
)paren
id|error
op_assign
id|may_create
c_func
(paren
id|new_dir
comma
id|new_dentry
)paren
suffix:semicolon
r_else
id|error
op_assign
id|may_delete
c_func
(paren
id|new_dir
comma
id|new_dentry
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old_dir-&gt;i_op
op_logical_or
op_logical_neg
id|old_dir-&gt;i_op-&gt;rename
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/*&n;&t; * If we are going to change the parent - check write permissions,&n;&t; * we&squot;ll need to flip &squot;..&squot;.&n;&t; */
r_if
c_cond
(paren
id|new_dir
op_ne
id|old_dir
)paren
(brace
id|error
op_assign
id|permission
c_func
(paren
id|old_dentry-&gt;d_inode
comma
id|MAY_WRITE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|old_dir
)paren
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|new_dir
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|old_dir-&gt;i_sb-&gt;s_vfs_rename_sem
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|is_subdir
c_func
(paren
id|new_dentry
comma
id|old_dentry
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|target
op_assign
id|new_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|target
)paren
(brace
multiline_comment|/* Hastur! Hastur! Hastur! */
id|triple_down
c_func
(paren
op_amp
id|old_dir-&gt;i_zombie
comma
op_amp
id|new_dir-&gt;i_zombie
comma
op_amp
id|target-&gt;i_zombie
)paren
suffix:semicolon
id|d_unhash
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
)brace
r_else
id|double_down
c_func
(paren
op_amp
id|old_dir-&gt;i_zombie
comma
op_amp
id|new_dir-&gt;i_zombie
)paren
suffix:semicolon
id|error
op_assign
id|old_dir-&gt;i_op
op_member_access_from_pointer
id|rename
c_func
(paren
id|old_dir
comma
id|old_dentry
comma
id|new_dir
comma
id|new_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
)paren
(brace
id|triple_up
c_func
(paren
op_amp
id|old_dir-&gt;i_zombie
comma
op_amp
id|new_dir-&gt;i_zombie
comma
op_amp
id|target-&gt;i_zombie
)paren
suffix:semicolon
id|d_rehash
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
id|dput
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
)brace
r_else
id|double_up
c_func
(paren
op_amp
id|old_dir-&gt;i_zombie
comma
op_amp
id|new_dir-&gt;i_zombie
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|d_move
c_func
(paren
id|old_dentry
comma
id|new_dentry
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|up
c_func
(paren
op_amp
id|old_dir-&gt;i_sb-&gt;s_vfs_rename_sem
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|vfs_rename_other
r_int
id|vfs_rename_other
c_func
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_struct
id|dentry
op_star
id|new_dentry
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|old_dentry-&gt;d_inode
op_eq
id|new_dentry-&gt;d_inode
)paren
r_return
l_int|0
suffix:semicolon
id|error
op_assign
id|may_delete
c_func
(paren
id|old_dir
comma
id|old_dentry
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|new_dir-&gt;i_dev
op_ne
id|old_dir-&gt;i_dev
)paren
r_return
op_minus
id|EXDEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_dentry-&gt;d_inode
)paren
id|error
op_assign
id|may_create
c_func
(paren
id|new_dir
comma
id|new_dentry
)paren
suffix:semicolon
r_else
id|error
op_assign
id|may_delete
c_func
(paren
id|new_dir
comma
id|new_dentry
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old_dir-&gt;i_op
op_logical_or
op_logical_neg
id|old_dir-&gt;i_op-&gt;rename
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|old_dir
)paren
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|new_dir
)paren
suffix:semicolon
id|double_down
c_func
(paren
op_amp
id|old_dir-&gt;i_zombie
comma
op_amp
id|new_dir-&gt;i_zombie
)paren
suffix:semicolon
id|error
op_assign
id|old_dir-&gt;i_op
op_member_access_from_pointer
id|rename
c_func
(paren
id|old_dir
comma
id|old_dentry
comma
id|new_dir
comma
id|new_dentry
)paren
suffix:semicolon
id|double_up
c_func
(paren
op_amp
id|old_dir-&gt;i_zombie
comma
op_amp
id|new_dir-&gt;i_zombie
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* The following d_move() should become unconditional */
r_if
c_cond
(paren
op_logical_neg
(paren
id|old_dir-&gt;i_sb-&gt;s_flags
op_amp
id|MS_ODD_RENAME
)paren
)paren
(brace
id|d_move
c_func
(paren
id|old_dentry
comma
id|new_dentry
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vfs_rename
r_int
id|vfs_rename
c_func
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_struct
id|dentry
op_star
id|new_dentry
)paren
(brace
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|old_dentry-&gt;d_inode-&gt;i_mode
)paren
)paren
r_return
id|vfs_rename_dir
c_func
(paren
id|old_dir
comma
id|old_dentry
comma
id|new_dir
comma
id|new_dentry
)paren
suffix:semicolon
r_else
r_return
id|vfs_rename_other
c_func
(paren
id|old_dir
comma
id|old_dentry
comma
id|new_dir
comma
id|new_dentry
)paren
suffix:semicolon
)brace
DECL|function|do_rename
r_static
r_inline
r_int
id|do_rename
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|dentry
op_star
id|old_dir
comma
op_star
id|new_dir
suffix:semicolon
r_struct
id|dentry
op_star
id|old_dentry
comma
op_star
id|new_dentry
suffix:semicolon
id|old_dentry
op_assign
id|lookup_dentry
c_func
(paren
id|oldname
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|old_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|old_dentry
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old_dentry-&gt;d_inode
)paren
r_goto
id|exit_old
suffix:semicolon
(brace
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|old_dentry-&gt;d_inode-&gt;i_mode
)paren
)paren
id|flags
op_assign
id|LOOKUP_SLASHOK
suffix:semicolon
id|new_dentry
op_assign
id|lookup_dentry
c_func
(paren
id|newname
comma
l_int|NULL
comma
id|flags
)paren
suffix:semicolon
)brace
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|new_dentry
)paren
)paren
r_goto
id|exit_old
suffix:semicolon
id|new_dir
op_assign
id|get_parent
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
id|old_dir
op_assign
id|get_parent
c_func
(paren
id|old_dentry
)paren
suffix:semicolon
id|double_lock
c_func
(paren
id|new_dir
comma
id|old_dir
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|check_parent
c_func
(paren
id|old_dir
comma
id|old_dentry
)paren
op_logical_and
id|check_parent
c_func
(paren
id|new_dir
comma
id|new_dentry
)paren
)paren
id|error
op_assign
id|vfs_rename
c_func
(paren
id|old_dir-&gt;d_inode
comma
id|old_dentry
comma
id|new_dir-&gt;d_inode
comma
id|new_dentry
)paren
suffix:semicolon
id|double_unlock
c_func
(paren
id|new_dir
comma
id|old_dir
)paren
suffix:semicolon
id|dput
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
id|exit_old
suffix:colon
id|dput
c_func
(paren
id|old_dentry
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_rename
id|asmlinkage
r_int
id|sys_rename
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|from
suffix:semicolon
r_char
op_star
id|to
suffix:semicolon
id|from
op_assign
id|getname
c_func
(paren
id|oldname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|from
)paren
)paren
(brace
r_return
id|PTR_ERR
c_func
(paren
id|from
)paren
suffix:semicolon
)brace
id|to
op_assign
id|getname
c_func
(paren
id|newname
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|to
)paren
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|do_rename
c_func
(paren
id|from
comma
id|to
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|putname
c_func
(paren
id|to
)paren
suffix:semicolon
)brace
id|putname
c_func
(paren
id|from
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|vfs_readlink
r_int
id|vfs_readlink
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_char
op_star
id|buffer
comma
r_int
id|buflen
comma
r_const
r_char
op_star
id|link
)paren
(brace
id|u32
id|len
suffix:semicolon
id|len
op_assign
id|PTR_ERR
c_func
(paren
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|link
)paren
)paren
r_goto
id|out
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|buflen
)paren
id|len
op_assign
id|buflen
suffix:semicolon
id|copy_to_user
c_func
(paren
id|buffer
comma
id|link
comma
id|len
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|len
suffix:semicolon
)brace
r_static
r_inline
r_struct
id|dentry
op_star
DECL|function|__vfs_follow_link
id|__vfs_follow_link
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|dentry
op_star
id|base
comma
r_int
id|follow
comma
r_const
r_char
op_star
id|link
)paren
(brace
r_struct
id|dentry
op_star
id|result
suffix:semicolon
id|UPDATE_ATIME
c_func
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|link
)paren
)paren
r_goto
id|fail
suffix:semicolon
id|result
op_assign
id|lookup_dentry
c_func
(paren
id|link
comma
id|base
comma
id|follow
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
id|fail
suffix:colon
id|dput
c_func
(paren
id|base
)paren
suffix:semicolon
r_return
(paren
r_struct
id|dentry
op_star
)paren
id|link
suffix:semicolon
)brace
r_struct
id|dentry
op_star
DECL|function|vfs_follow_link
id|vfs_follow_link
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|dentry
op_star
id|base
comma
r_int
r_int
id|follow
comma
r_const
r_char
op_star
id|link
)paren
(brace
r_return
id|__vfs_follow_link
c_func
(paren
id|dentry
comma
id|base
comma
id|follow
comma
id|link
)paren
suffix:semicolon
)brace
multiline_comment|/* get the link contents into pagecache */
DECL|function|page_getlink
r_static
r_char
op_star
id|page_getlink
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|page
op_star
op_star
id|ppage
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|dentry-&gt;d_inode-&gt;i_mapping
suffix:semicolon
id|page
op_assign
id|read_cache_page
c_func
(paren
id|mapping
comma
l_int|0
comma
(paren
id|filler_t
op_star
)paren
id|mapping-&gt;a_ops-&gt;readpage
comma
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
r_goto
id|sync_fail
suffix:semicolon
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|async_fail
suffix:semicolon
op_star
id|ppage
op_assign
id|page
suffix:semicolon
r_return
(paren
r_char
op_star
)paren
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|async_fail
suffix:colon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
id|sync_fail
suffix:colon
r_return
(paren
r_char
op_star
)paren
id|page
suffix:semicolon
)brace
DECL|function|page_readlink
r_int
id|page_readlink
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_char
op_star
id|buffer
comma
r_int
id|buflen
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|s
op_assign
id|page_getlink
c_func
(paren
id|dentry
comma
op_amp
id|page
)paren
suffix:semicolon
r_int
id|res
op_assign
id|vfs_readlink
c_func
(paren
id|dentry
comma
id|buffer
comma
id|buflen
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
r_struct
id|dentry
op_star
DECL|function|page_follow_link
id|page_follow_link
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|dentry
op_star
id|base
comma
r_int
r_int
id|follow
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|s
op_assign
id|page_getlink
c_func
(paren
id|dentry
comma
op_amp
id|page
)paren
suffix:semicolon
r_struct
id|dentry
op_star
id|res
op_assign
id|__vfs_follow_link
c_func
(paren
id|dentry
comma
id|base
comma
id|follow
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|variable|page_symlink_inode_operations
r_struct
id|inode_operations
id|page_symlink_inode_operations
op_assign
(brace
id|readlink
suffix:colon
id|page_readlink
comma
id|follow_link
suffix:colon
id|page_follow_link
comma
)brace
suffix:semicolon
eof
