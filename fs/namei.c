multiline_comment|/*&n; *  linux/fs/namei.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; * Some corrections by tytso.&n; */
multiline_comment|/* [Feb 1997 T. Schoebel-Theuer] Complete rewrite of the pathname&n; * lookup logic.&n; */
multiline_comment|/* [Feb-Apr 2000, AV] Rewrite to the new namespace architecture.&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/quotaops.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/dcache.h&gt;
macro_line|#include &lt;linux/dnotify.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/page.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/namei.h&gt;
DECL|macro|ACC_MODE
mdefine_line|#define ACC_MODE(x) (&quot;&bslash;000&bslash;004&bslash;002&bslash;006&quot;[(x)&amp;O_ACCMODE])
multiline_comment|/* [Feb-1997 T. Schoebel-Theuer]&n; * Fundamental changes in the pathname lookup mechanisms (namei)&n; * were necessary because of omirr.  The reason is that omirr needs&n; * to know the _real_ pathname, not the user-supplied one, in case&n; * of symlinks (and also when transname replacements occur).&n; *&n; * The new code replaces the old recursive symlink resolution with&n; * an iterative one (in case of non-nested symlink chains).  It does&n; * this with calls to &lt;fs&gt;_follow_link().&n; * As a side effect, dir_namei(), _namei() and follow_link() are now &n; * replaced with a single function lookup_dentry() that can handle all &n; * the special cases of the former code.&n; *&n; * With the new dcache, the pathname is stored at each inode, at least as&n; * long as the refcount of the inode is positive.  As a side effect, the&n; * size of the dcache depends on the inode cache and thus is dynamic.&n; *&n; * [29-Apr-1998 C. Scott Ananian] Updated above description of symlink&n; * resolution to correspond with current state of the code.&n; *&n; * Note that the symlink resolution is not *completely* iterative.&n; * There is still a significant amount of tail- and mid- recursion in&n; * the algorithm.  Also, note that &lt;fs&gt;_readlink() is not used in&n; * lookup_dentry(): lookup_dentry() on the result of &lt;fs&gt;_readlink()&n; * may return different results than &lt;fs&gt;_follow_link().  Many virtual&n; * filesystems (including /proc) exhibit this behavior.&n; */
multiline_comment|/* [24-Feb-97 T. Schoebel-Theuer] Side effects caused by new implementation:&n; * New symlink semantics: when open() is called with flags O_CREAT | O_EXCL&n; * and the name already exists in form of a symlink, try to create the new&n; * name indicated by the symlink. The old code always complained that the&n; * name already exists, due to not following the symlink even if its target&n; * is nonexistent.  The new semantics affects also mknod() and link() when&n; * the name is a symlink pointing to a non-existant name.&n; *&n; * I don&squot;t know which semantics is the right one, since I have no access&n; * to standards. But I found by trial that HP-UX 9.0 has the full &quot;new&quot;&n; * semantics implemented, while SunOS 4.1.1 and Solaris (SunOS 5.4) have the&n; * &quot;old&quot; one. Personally, I think the new semantics is much more logical.&n; * Note that &quot;ln old new&quot; where &quot;new&quot; is a symlink pointing to a non-existing&n; * file does succeed in both HP-UX and SunOs, but not in Solaris&n; * and in the old Linux semantics.&n; */
multiline_comment|/* [16-Dec-97 Kevin Buhr] For security reasons, we change some symlink&n; * semantics.  See the comments in &quot;open_namei&quot; and &quot;do_link&quot; below.&n; *&n; * [10-Sep-98 Alan Modra] Another symlink change.&n; */
multiline_comment|/* [Feb-Apr 2000 AV] Complete rewrite. Rules for symlinks:&n; *&t;inside the path - always follow.&n; *&t;in the last component in creation/removal/renaming - never follow.&n; *&t;if LOOKUP_FOLLOW passed - follow.&n; *&t;if the pathname has trailing slashes - follow.&n; *&t;otherwise - don&squot;t follow.&n; * (applied in that order).&n; *&n; * [Jun 2000 AV] Inconsistent behaviour of open() in case if flags==O_CREAT&n; * restored for 2.4. This is the last surviving part of old 4.2BSD bug.&n; * During the 2.4 we need to fix the userland stuff depending on it -&n; * hopefully we will be able to get rid of that wart in 2.5. So far only&n; * XEmacs seems to be relying on it...&n; */
multiline_comment|/* In order to reduce some races, while at the same time doing additional&n; * checking and hopefully speeding things up, we copy filenames to the&n; * kernel data space before using them..&n; *&n; * POSIX.1 2.4: an empty pathname is invalid (ENOENT).&n; */
DECL|function|do_getname
r_static
r_inline
r_int
id|do_getname
c_func
(paren
r_const
r_char
op_star
id|filename
comma
r_char
op_star
id|page
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
r_int
id|len
op_assign
id|PATH_MAX
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|filename
op_ge
id|TASK_SIZE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|segment_eq
c_func
(paren
id|get_fs
c_func
(paren
)paren
comma
id|KERNEL_DS
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|TASK_SIZE
op_minus
(paren
r_int
r_int
)paren
id|filename
OL
id|PAGE_SIZE
)paren
id|len
op_assign
id|TASK_SIZE
op_minus
(paren
r_int
r_int
)paren
id|filename
suffix:semicolon
id|retval
op_assign
id|strncpy_from_user
c_func
(paren
(paren
r_char
op_star
)paren
id|page
comma
id|filename
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|retval
OL
id|len
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|ENAMETOOLONG
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|getname
r_char
op_star
id|getname
c_func
(paren
r_const
r_char
op_star
id|filename
)paren
(brace
r_char
op_star
id|tmp
comma
op_star
id|result
suffix:semicolon
id|result
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
id|tmp
op_assign
id|__getname
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
r_int
id|retval
op_assign
id|do_getname
c_func
(paren
id|filename
comma
id|tmp
)paren
suffix:semicolon
id|result
op_assign
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|result
op_assign
id|ERR_PTR
c_func
(paren
id|retval
)paren
suffix:semicolon
)brace
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;permission()&n; *&n; * is used to check for read/write/execute permissions on a file.&n; * We use &quot;fsuid&quot; for this, letting us set arbitrary permissions&n; * for filesystem access without changing the &quot;normal&quot; uids which&n; * are used for other things..&n; */
DECL|function|vfs_permission
r_int
id|vfs_permission
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|mask
)paren
(brace
r_int
id|mode
op_assign
id|inode-&gt;i_mode
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mask
op_amp
id|S_IWOTH
)paren
op_logical_and
id|IS_RDONLY
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|S_ISREG
c_func
(paren
id|mode
)paren
op_logical_or
id|S_ISDIR
c_func
(paren
id|mode
)paren
op_logical_or
id|S_ISLNK
c_func
(paren
id|mode
)paren
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
multiline_comment|/* Nobody gets write access to a read-only fs */
r_if
c_cond
(paren
(paren
id|mask
op_amp
id|S_IWOTH
)paren
op_logical_and
id|IS_IMMUTABLE
c_func
(paren
id|inode
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* Nobody gets write access to an immutable file */
r_if
c_cond
(paren
id|current-&gt;fsuid
op_eq
id|inode-&gt;i_uid
)paren
id|mode
op_rshift_assign
l_int|6
suffix:semicolon
r_else
r_if
c_cond
(paren
id|in_group_p
c_func
(paren
id|inode-&gt;i_gid
)paren
)paren
id|mode
op_rshift_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|mode
op_amp
id|mask
op_amp
id|S_IRWXO
)paren
op_eq
id|mask
)paren
op_logical_or
id|capable
c_func
(paren
id|CAP_DAC_OVERRIDE
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* read and search access */
r_if
c_cond
(paren
(paren
id|mask
op_eq
id|S_IROTH
)paren
op_logical_or
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
op_logical_neg
(paren
id|mask
op_amp
op_complement
(paren
id|S_IROTH
op_or
id|S_IXOTH
)paren
)paren
)paren
)paren
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_DAC_READ_SEARCH
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
DECL|function|permission
r_int
id|permission
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|mask
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_op
op_logical_and
id|inode-&gt;i_op-&gt;permission
)paren
(brace
r_int
id|retval
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
id|inode-&gt;i_op
op_member_access_from_pointer
id|permission
c_func
(paren
id|inode
comma
id|mask
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_return
id|vfs_permission
c_func
(paren
id|inode
comma
id|mask
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * get_write_access() gets write permission for a file.&n; * put_write_access() releases this write permission.&n; * This is used for regular files.&n; * We cannot support write (and maybe mmap read-write shared) accesses and&n; * MAP_DENYWRITE mmappings simultaneously. The i_writecount field of an inode&n; * can have the following values:&n; * 0: no writers, no VM_DENYWRITE mappings&n; * &lt; 0: (-i_writecount) vm_area_structs with VM_DENYWRITE set exist&n; * &gt; 0: (i_writecount) users are writing to the file.&n; *&n; * Normally we operate on that counter with atomic_{inc,dec} and it&squot;s safe&n; * except for the cases where we don&squot;t hold i_writecount yet. Then we need to&n; * use {get,deny}_write_access() - these functions check the sign and refuse&n; * to do the change if sign is wrong. Exclusion between them is provided by&n; * spinlock (arbitration_lock) and I&squot;ll rip the second arsehole to the first&n; * who will try to move it in struct inode - just leave it here.&n; */
DECL|variable|arbitration_lock
r_static
id|spinlock_t
id|arbitration_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|get_write_access
r_int
id|get_write_access
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|arbitration_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|inode-&gt;i_writecount
)paren
OL
l_int|0
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|arbitration_lock
)paren
suffix:semicolon
r_return
op_minus
id|ETXTBSY
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|inode-&gt;i_writecount
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|arbitration_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|deny_write_access
r_int
id|deny_write_access
c_func
(paren
r_struct
id|file
op_star
id|file
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|arbitration_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_writecount
)paren
OG
l_int|0
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|arbitration_lock
)paren
suffix:semicolon
r_return
op_minus
id|ETXTBSY
suffix:semicolon
)brace
id|atomic_dec
c_func
(paren
op_amp
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_writecount
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|arbitration_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|path_release
r_void
id|path_release
c_func
(paren
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
id|dput
c_func
(paren
id|nd-&gt;dentry
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|nd-&gt;mnt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Internal lookup() using the new generic dcache.&n; * SMP-safe&n; */
DECL|function|cached_lookup
r_static
r_struct
id|dentry
op_star
id|cached_lookup
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_struct
id|qstr
op_star
id|name
comma
r_int
id|flags
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|d_lookup
c_func
(paren
id|parent
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
op_logical_and
id|dentry-&gt;d_op
op_logical_and
id|dentry-&gt;d_op-&gt;d_revalidate
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_op
op_member_access_from_pointer
id|d_revalidate
c_func
(paren
id|dentry
comma
id|flags
)paren
op_logical_and
op_logical_neg
id|d_invalidate
c_func
(paren
id|dentry
)paren
)paren
(brace
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|dentry
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_return
id|dentry
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called when everything else fails, and we actually have&n; * to go to the low-level filesystem to find out what we should do..&n; *&n; * We get the directory semaphore, and after getting that we also&n; * make sure that nobody added the entry to the dcache in the meantime..&n; * SMP-safe&n; */
DECL|function|real_lookup
r_static
r_struct
id|dentry
op_star
id|real_lookup
c_func
(paren
r_struct
id|dentry
op_star
id|parent
comma
r_struct
id|qstr
op_star
id|name
comma
r_int
id|flags
)paren
(brace
r_struct
id|dentry
op_star
id|result
suffix:semicolon
r_struct
id|inode
op_star
id|dir
op_assign
id|parent-&gt;d_inode
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First re-do the cached lookup just in case it was created&n;&t; * while we waited for the directory semaphore..&n;&t; *&n;&t; * FIXME! This could use version numbering or similar to&n;&t; * avoid unnecessary cache lookups.&n;&t; */
id|result
op_assign
id|d_lookup
c_func
(paren
id|parent
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|d_alloc
c_func
(paren
id|parent
comma
id|name
)paren
suffix:semicolon
id|result
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|result
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|lookup
c_func
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_else
id|result
op_assign
id|dentry
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Uhhuh! Nasty case: the cache was re-populated while&n;&t; * we waited on the semaphore. Need to revalidate.&n;&t; */
id|up
c_func
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result-&gt;d_op
op_logical_and
id|result-&gt;d_op-&gt;d_revalidate
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|result-&gt;d_op
op_member_access_from_pointer
id|d_revalidate
c_func
(paren
id|result
comma
id|flags
)paren
op_logical_and
op_logical_neg
id|d_invalidate
c_func
(paren
id|result
)paren
)paren
(brace
id|dput
c_func
(paren
id|result
)paren
suffix:semicolon
id|result
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOENT
)paren
suffix:semicolon
)brace
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|do_follow_link
r_static
r_inline
r_int
id|do_follow_link
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;link_count
op_ge
l_int|8
)paren
r_goto
id|loop
suffix:semicolon
id|current-&gt;link_count
op_increment
suffix:semicolon
id|UPDATE_ATIME
c_func
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
id|err
op_assign
id|dentry-&gt;d_inode-&gt;i_op
op_member_access_from_pointer
id|follow_link
c_func
(paren
id|dentry
comma
id|nd
)paren
suffix:semicolon
id|current-&gt;link_count
op_decrement
suffix:semicolon
r_return
id|err
suffix:semicolon
id|loop
suffix:colon
id|path_release
c_func
(paren
id|nd
)paren
suffix:semicolon
r_return
op_minus
id|ELOOP
suffix:semicolon
)brace
DECL|function|__follow_up
r_static
r_inline
r_int
id|__follow_up
c_func
(paren
r_struct
id|vfsmount
op_star
op_star
id|mnt
comma
r_struct
id|dentry
op_star
op_star
id|base
)paren
(brace
r_struct
id|vfsmount
op_star
id|parent
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|parent
op_assign
(paren
op_star
id|mnt
)paren
op_member_access_from_pointer
id|mnt_parent
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_eq
op_star
id|mnt
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|mntget
c_func
(paren
id|parent
)paren
suffix:semicolon
id|dentry
op_assign
id|dget
c_func
(paren
(paren
op_star
id|mnt
)paren
op_member_access_from_pointer
id|mnt_mountpoint
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|dput
c_func
(paren
op_star
id|base
)paren
suffix:semicolon
op_star
id|base
op_assign
id|dentry
suffix:semicolon
id|mntput
c_func
(paren
op_star
id|mnt
)paren
suffix:semicolon
op_star
id|mnt
op_assign
id|parent
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|follow_up
r_int
id|follow_up
c_func
(paren
r_struct
id|vfsmount
op_star
op_star
id|mnt
comma
r_struct
id|dentry
op_star
op_star
id|dentry
)paren
(brace
r_return
id|__follow_up
c_func
(paren
id|mnt
comma
id|dentry
)paren
suffix:semicolon
)brace
DECL|function|__follow_down
r_static
r_inline
r_int
id|__follow_down
c_func
(paren
r_struct
id|vfsmount
op_star
op_star
id|mnt
comma
r_struct
id|dentry
op_star
op_star
id|dentry
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|p
op_assign
(paren
op_star
id|dentry
)paren
op_member_access_from_pointer
id|d_vfsmnt.next
suffix:semicolon
r_while
c_loop
(paren
id|p
op_ne
op_amp
(paren
op_star
id|dentry
)paren
op_member_access_from_pointer
id|d_vfsmnt
)paren
(brace
r_struct
id|vfsmount
op_star
id|tmp
suffix:semicolon
id|tmp
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|vfsmount
comma
id|mnt_clash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;mnt_parent
op_eq
op_star
id|mnt
)paren
(brace
op_star
id|mnt
op_assign
id|mntget
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|tmp-&gt;mnt_parent
)paren
suffix:semicolon
multiline_comment|/* tmp holds the mountpoint, so... */
id|dput
c_func
(paren
op_star
id|dentry
)paren
suffix:semicolon
op_star
id|dentry
op_assign
id|dget
c_func
(paren
id|tmp-&gt;mnt_root
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|p
op_assign
id|p-&gt;next
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|follow_down
r_int
id|follow_down
c_func
(paren
r_struct
id|vfsmount
op_star
op_star
id|mnt
comma
r_struct
id|dentry
op_star
op_star
id|dentry
)paren
(brace
r_return
id|__follow_down
c_func
(paren
id|mnt
comma
id|dentry
)paren
suffix:semicolon
)brace
DECL|function|follow_dotdot
r_static
r_inline
r_void
id|follow_dotdot
c_func
(paren
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|vfsmount
op_star
id|parent
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nd-&gt;dentry
op_eq
id|current-&gt;fs-&gt;root
op_logical_and
id|nd-&gt;mnt
op_eq
id|current-&gt;fs-&gt;rootmnt
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nd-&gt;dentry
op_ne
id|nd-&gt;mnt-&gt;mnt_root
)paren
(brace
id|dentry
op_assign
id|dget
c_func
(paren
id|nd-&gt;dentry-&gt;d_parent
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|dput
c_func
(paren
id|nd-&gt;dentry
)paren
suffix:semicolon
id|nd-&gt;dentry
op_assign
id|dentry
suffix:semicolon
r_break
suffix:semicolon
)brace
id|parent
op_assign
id|nd-&gt;mnt-&gt;mnt_parent
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_eq
id|nd-&gt;mnt
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|mntget
c_func
(paren
id|parent
)paren
suffix:semicolon
id|dentry
op_assign
id|dget
c_func
(paren
id|nd-&gt;mnt-&gt;mnt_mountpoint
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|dput
c_func
(paren
id|nd-&gt;dentry
)paren
suffix:semicolon
id|nd-&gt;dentry
op_assign
id|dentry
suffix:semicolon
id|mntput
c_func
(paren
id|nd-&gt;mnt
)paren
suffix:semicolon
id|nd-&gt;mnt
op_assign
id|parent
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Name resolution.&n; *&n; * This is the basic name resolution function, turning a pathname&n; * into the final dentry.&n; *&n; * We expect &squot;base&squot; to be positive and a directory.&n; */
DECL|function|path_walk
r_int
id|path_walk
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|err
suffix:semicolon
r_int
r_int
id|lookup_flags
op_assign
id|nd-&gt;flags
suffix:semicolon
r_while
c_loop
(paren
op_star
id|name
op_eq
l_char|&squot;/&squot;
)paren
id|name
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|name
)paren
r_goto
id|return_base
suffix:semicolon
id|inode
op_assign
id|nd-&gt;dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;link_count
)paren
id|lookup_flags
op_assign
id|LOOKUP_FOLLOW
suffix:semicolon
multiline_comment|/* At this point we know we have a real path component. */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
r_int
id|hash
suffix:semicolon
r_struct
id|qstr
id|this
suffix:semicolon
r_int
r_int
id|c
suffix:semicolon
id|err
op_assign
id|permission
c_func
(paren
id|inode
comma
id|MAY_EXEC
)paren
suffix:semicolon
id|dentry
op_assign
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_break
suffix:semicolon
id|this.name
op_assign
id|name
suffix:semicolon
id|c
op_assign
op_star
(paren
r_const
r_int
r_char
op_star
)paren
id|name
suffix:semicolon
id|hash
op_assign
id|init_name_hash
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
id|name
op_increment
suffix:semicolon
id|hash
op_assign
id|partial_name_hash
c_func
(paren
id|c
comma
id|hash
)paren
suffix:semicolon
id|c
op_assign
op_star
(paren
r_const
r_int
r_char
op_star
)paren
id|name
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c
op_logical_and
(paren
id|c
op_ne
l_char|&squot;/&squot;
)paren
)paren
suffix:semicolon
id|this.len
op_assign
id|name
op_minus
(paren
r_const
r_char
op_star
)paren
id|this.name
suffix:semicolon
id|this.hash
op_assign
id|end_name_hash
c_func
(paren
id|hash
)paren
suffix:semicolon
multiline_comment|/* remove trailing slashes? */
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_goto
id|last_component
suffix:semicolon
r_while
c_loop
(paren
op_star
op_increment
id|name
op_eq
l_char|&squot;/&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|name
)paren
r_goto
id|last_with_slashes
suffix:semicolon
multiline_comment|/*&n;&t;&t; * &quot;.&quot; and &quot;..&quot; are special - &quot;..&quot; especially so because it has&n;&t;&t; * to be able to know about the current root directory and&n;&t;&t; * parent relationships.&n;&t;&t; */
r_if
c_cond
(paren
id|this.name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
r_switch
c_cond
(paren
id|this.len
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|this.name
(braket
l_int|1
)braket
op_ne
l_char|&squot;.&squot;
)paren
r_break
suffix:semicolon
id|follow_dotdot
c_func
(paren
id|nd
)paren
suffix:semicolon
id|inode
op_assign
id|nd-&gt;dentry-&gt;d_inode
suffix:semicolon
multiline_comment|/* fallthrough */
r_case
l_int|1
suffix:colon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * See if the low-level filesystem might want&n;&t;&t; * to use its own hash..&n;&t;&t; */
r_if
c_cond
(paren
id|nd-&gt;dentry-&gt;d_op
op_logical_and
id|nd-&gt;dentry-&gt;d_op-&gt;d_hash
)paren
(brace
id|err
op_assign
id|nd-&gt;dentry-&gt;d_op
op_member_access_from_pointer
id|d_hash
c_func
(paren
id|nd-&gt;dentry
comma
op_amp
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* This does the actual lookups.. */
id|dentry
op_assign
id|cached_lookup
c_func
(paren
id|nd-&gt;dentry
comma
op_amp
id|this
comma
id|LOOKUP_CONTINUE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
(brace
id|dentry
op_assign
id|real_lookup
c_func
(paren
id|nd-&gt;dentry
comma
op_amp
id|this
comma
id|LOOKUP_CONTINUE
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* Check mountpoints.. */
r_while
c_loop
(paren
id|d_mountpoint
c_func
(paren
id|dentry
)paren
op_logical_and
id|__follow_down
c_func
(paren
op_amp
id|nd-&gt;mnt
comma
op_amp
id|dentry
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|out_dput
suffix:semicolon
id|err
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_op
)paren
r_goto
id|out_dput
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_op-&gt;follow_link
)paren
(brace
id|err
op_assign
id|do_follow_link
c_func
(paren
id|dentry
comma
id|nd
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|return_err
suffix:semicolon
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|inode
op_assign
id|nd-&gt;dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_break
suffix:semicolon
id|err
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_op
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
id|dput
c_func
(paren
id|nd-&gt;dentry
)paren
suffix:semicolon
id|nd-&gt;dentry
op_assign
id|dentry
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_op-&gt;lookup
)paren
r_break
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* here ends the main loop */
id|last_with_slashes
suffix:colon
id|lookup_flags
op_or_assign
id|LOOKUP_FOLLOW
op_or
id|LOOKUP_DIRECTORY
suffix:semicolon
id|last_component
suffix:colon
r_if
c_cond
(paren
id|lookup_flags
op_amp
id|LOOKUP_PARENT
)paren
r_goto
id|lookup_parent
suffix:semicolon
r_if
c_cond
(paren
id|this.name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
)paren
r_switch
c_cond
(paren
id|this.len
)paren
(brace
r_default
suffix:colon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|this.name
(braket
l_int|1
)braket
op_ne
l_char|&squot;.&squot;
)paren
r_break
suffix:semicolon
id|follow_dotdot
c_func
(paren
id|nd
)paren
suffix:semicolon
id|inode
op_assign
id|nd-&gt;dentry-&gt;d_inode
suffix:semicolon
multiline_comment|/* fallthrough */
r_case
l_int|1
suffix:colon
r_goto
id|return_base
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nd-&gt;dentry-&gt;d_op
op_logical_and
id|nd-&gt;dentry-&gt;d_op-&gt;d_hash
)paren
(brace
id|err
op_assign
id|nd-&gt;dentry-&gt;d_op
op_member_access_from_pointer
id|d_hash
c_func
(paren
id|nd-&gt;dentry
comma
op_amp
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|dentry
op_assign
id|cached_lookup
c_func
(paren
id|nd-&gt;dentry
comma
op_amp
id|this
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
(brace
id|dentry
op_assign
id|real_lookup
c_func
(paren
id|nd-&gt;dentry
comma
op_amp
id|this
comma
l_int|0
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|d_mountpoint
c_func
(paren
id|dentry
)paren
op_logical_and
id|__follow_down
c_func
(paren
op_amp
id|nd-&gt;mnt
comma
op_amp
id|dentry
)paren
)paren
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lookup_flags
op_amp
id|LOOKUP_FOLLOW
)paren
op_logical_and
id|inode
op_logical_and
id|inode-&gt;i_op
op_logical_and
id|inode-&gt;i_op-&gt;follow_link
)paren
(brace
id|err
op_assign
id|do_follow_link
c_func
(paren
id|dentry
comma
id|nd
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|return_err
suffix:semicolon
id|inode
op_assign
id|nd-&gt;dentry-&gt;d_inode
suffix:semicolon
)brace
r_else
(brace
id|dput
c_func
(paren
id|nd-&gt;dentry
)paren
suffix:semicolon
id|nd-&gt;dentry
op_assign
id|dentry
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|no_inode
suffix:semicolon
r_if
c_cond
(paren
id|lookup_flags
op_amp
id|LOOKUP_DIRECTORY
)paren
(brace
id|err
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_op
op_logical_or
op_logical_neg
id|inode-&gt;i_op-&gt;lookup
)paren
r_break
suffix:semicolon
)brace
r_goto
id|return_base
suffix:semicolon
id|no_inode
suffix:colon
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|lookup_flags
op_amp
(paren
id|LOOKUP_POSITIVE
op_or
id|LOOKUP_DIRECTORY
)paren
)paren
r_break
suffix:semicolon
r_goto
id|return_base
suffix:semicolon
id|lookup_parent
suffix:colon
id|nd-&gt;last
op_assign
id|this
suffix:semicolon
id|nd-&gt;last_type
op_assign
id|LAST_NORM
suffix:semicolon
r_if
c_cond
(paren
id|this.name
(braket
l_int|0
)braket
op_ne
l_char|&squot;.&squot;
)paren
r_goto
id|return_base
suffix:semicolon
r_if
c_cond
(paren
id|this.len
op_eq
l_int|1
)paren
id|nd-&gt;last_type
op_assign
id|LAST_DOT
suffix:semicolon
r_else
r_if
c_cond
(paren
id|this.len
op_eq
l_int|2
op_logical_and
id|this.name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
id|nd-&gt;last_type
op_assign
id|LAST_DOTDOT
suffix:semicolon
id|return_base
suffix:colon
r_return
l_int|0
suffix:semicolon
id|out_dput
suffix:colon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|path_release
c_func
(paren
id|nd
)paren
suffix:semicolon
id|return_err
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* SMP-safe */
multiline_comment|/* returns 1 if everything is done */
DECL|function|__emul_lookup_dentry
r_static
r_int
id|__emul_lookup_dentry
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_if
c_cond
(paren
id|path_walk
c_func
(paren
id|name
comma
id|nd
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nd-&gt;dentry-&gt;d_inode
)paren
(brace
r_struct
id|nameidata
id|nd_root
suffix:semicolon
id|nd_root.last_type
op_assign
id|LAST_ROOT
suffix:semicolon
id|nd_root.flags
op_assign
id|nd-&gt;flags
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
id|nd_root.mnt
op_assign
id|mntget
c_func
(paren
id|current-&gt;fs-&gt;rootmnt
)paren
suffix:semicolon
id|nd_root.dentry
op_assign
id|dget
c_func
(paren
id|current-&gt;fs-&gt;root
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|path_walk
c_func
(paren
id|name
comma
op_amp
id|nd_root
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|nd_root.dentry-&gt;d_inode
)paren
(brace
id|path_release
c_func
(paren
id|nd
)paren
suffix:semicolon
id|nd-&gt;dentry
op_assign
id|nd_root.dentry
suffix:semicolon
id|nd-&gt;mnt
op_assign
id|nd_root.mnt
suffix:semicolon
id|nd-&gt;last
op_assign
id|nd_root.last
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|path_release
c_func
(paren
op_amp
id|nd_root
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|set_fs_altroot
r_void
id|set_fs_altroot
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|emul
op_assign
id|__emul_prefix
c_func
(paren
)paren
suffix:semicolon
r_struct
id|nameidata
id|nd
suffix:semicolon
r_struct
id|vfsmount
op_star
id|mnt
op_assign
l_int|NULL
comma
op_star
id|oldmnt
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
op_assign
l_int|NULL
comma
op_star
id|olddentry
suffix:semicolon
r_if
c_cond
(paren
id|emul
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
id|nd.mnt
op_assign
id|mntget
c_func
(paren
id|current-&gt;fs-&gt;rootmnt
)paren
suffix:semicolon
id|nd.dentry
op_assign
id|dget
c_func
(paren
id|current-&gt;fs-&gt;root
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
id|nd.flags
op_assign
id|LOOKUP_FOLLOW
op_or
id|LOOKUP_DIRECTORY
op_or
id|LOOKUP_POSITIVE
suffix:semicolon
r_if
c_cond
(paren
id|path_walk
c_func
(paren
id|emul
comma
op_amp
id|nd
)paren
op_eq
l_int|0
)paren
(brace
id|mnt
op_assign
id|nd.mnt
suffix:semicolon
id|dentry
op_assign
id|nd.dentry
suffix:semicolon
)brace
)brace
id|write_lock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
id|oldmnt
op_assign
id|current-&gt;fs-&gt;altrootmnt
suffix:semicolon
id|olddentry
op_assign
id|current-&gt;fs-&gt;altroot
suffix:semicolon
id|current-&gt;fs-&gt;altrootmnt
op_assign
id|mnt
suffix:semicolon
id|current-&gt;fs-&gt;altroot
op_assign
id|dentry
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|olddentry
)paren
(brace
id|dput
c_func
(paren
id|olddentry
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|oldmnt
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* SMP-safe */
r_static
r_inline
r_int
DECL|function|walk_init_root
id|walk_init_root
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
id|read_lock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;fs-&gt;altroot
op_logical_and
op_logical_neg
(paren
id|nd-&gt;flags
op_amp
id|LOOKUP_NOALT
)paren
)paren
(brace
id|nd-&gt;mnt
op_assign
id|mntget
c_func
(paren
id|current-&gt;fs-&gt;altrootmnt
)paren
suffix:semicolon
id|nd-&gt;dentry
op_assign
id|dget
c_func
(paren
id|current-&gt;fs-&gt;altroot
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|__emul_lookup_dentry
c_func
(paren
id|name
comma
id|nd
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
)brace
id|nd-&gt;mnt
op_assign
id|mntget
c_func
(paren
id|current-&gt;fs-&gt;rootmnt
)paren
suffix:semicolon
id|nd-&gt;dentry
op_assign
id|dget
c_func
(paren
id|current-&gt;fs-&gt;root
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* SMP-safe */
DECL|function|path_init
r_int
id|path_init
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|flags
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
id|nd-&gt;last_type
op_assign
id|LAST_ROOT
suffix:semicolon
multiline_comment|/* if there are only slashes... */
id|nd-&gt;flags
op_assign
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_star
id|name
op_eq
l_char|&squot;/&squot;
)paren
r_return
id|walk_init_root
c_func
(paren
id|name
comma
id|nd
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
id|nd-&gt;mnt
op_assign
id|mntget
c_func
(paren
id|current-&gt;fs-&gt;pwdmnt
)paren
suffix:semicolon
id|nd-&gt;dentry
op_assign
id|dget
c_func
(paren
id|current-&gt;fs-&gt;pwd
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|current-&gt;fs-&gt;lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Restricted form of lookup. Doesn&squot;t follow links, single-component only,&n; * needs parent already locked. Doesn&squot;t follow mounts.&n; * SMP-safe.&n; */
DECL|function|lookup_hash
r_struct
id|dentry
op_star
id|lookup_hash
c_func
(paren
r_struct
id|qstr
op_star
id|name
comma
r_struct
id|dentry
op_star
id|base
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|err
suffix:semicolon
id|inode
op_assign
id|base-&gt;d_inode
suffix:semicolon
id|err
op_assign
id|permission
c_func
(paren
id|inode
comma
id|MAY_EXEC
)paren
suffix:semicolon
id|dentry
op_assign
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * See if the low-level filesystem might want&n;&t; * to use its own hash..&n;&t; */
r_if
c_cond
(paren
id|base-&gt;d_op
op_logical_and
id|base-&gt;d_op-&gt;d_hash
)paren
(brace
id|err
op_assign
id|base-&gt;d_op
op_member_access_from_pointer
id|d_hash
c_func
(paren
id|base
comma
id|name
)paren
suffix:semicolon
id|dentry
op_assign
id|ERR_PTR
c_func
(paren
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
)brace
id|dentry
op_assign
id|cached_lookup
c_func
(paren
id|base
comma
id|name
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
(brace
r_struct
id|dentry
op_star
r_new
op_assign
id|d_alloc
c_func
(paren
id|base
comma
id|name
)paren
suffix:semicolon
id|dentry
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_goto
id|out
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|dentry
op_assign
id|inode-&gt;i_op
op_member_access_from_pointer
id|lookup
c_func
(paren
id|inode
comma
r_new
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
id|dentry
op_assign
r_new
suffix:semicolon
r_else
id|dput
c_func
(paren
r_new
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|dentry
suffix:semicolon
)brace
multiline_comment|/* SMP-safe */
DECL|function|lookup_one
r_struct
id|dentry
op_star
id|lookup_one
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_struct
id|dentry
op_star
id|base
)paren
(brace
r_int
r_int
id|hash
suffix:semicolon
r_struct
id|qstr
id|this
suffix:semicolon
r_int
r_int
id|c
suffix:semicolon
id|this.name
op_assign
id|name
suffix:semicolon
id|c
op_assign
op_star
(paren
r_const
r_int
r_char
op_star
)paren
id|name
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_goto
id|access
suffix:semicolon
id|hash
op_assign
id|init_name_hash
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
id|name
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;/&squot;
)paren
r_goto
id|access
suffix:semicolon
id|hash
op_assign
id|partial_name_hash
c_func
(paren
id|c
comma
id|hash
)paren
suffix:semicolon
id|c
op_assign
op_star
(paren
r_const
r_int
r_char
op_star
)paren
id|name
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c
)paren
suffix:semicolon
id|this.len
op_assign
id|name
op_minus
(paren
r_const
r_char
op_star
)paren
id|this.name
suffix:semicolon
id|this.hash
op_assign
id|end_name_hash
c_func
(paren
id|hash
)paren
suffix:semicolon
r_return
id|lookup_hash
c_func
(paren
op_amp
id|this
comma
id|base
)paren
suffix:semicolon
id|access
suffix:colon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EACCES
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;namei()&n; *&n; * is used by most simple commands to get the inode of a specified name.&n; * Open, link etc use their own routines, but this is enough for things&n; * like &squot;chmod&squot; etc.&n; *&n; * namei exists in two versions: namei/lnamei. The only difference is&n; * that namei follows links, while lnamei does not.&n; * SMP-safe&n; */
DECL|function|__user_walk
r_int
id|__user_walk
c_func
(paren
r_const
r_char
op_star
id|name
comma
r_int
id|flags
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_char
op_star
id|tmp
suffix:semicolon
r_int
id|err
suffix:semicolon
id|tmp
op_assign
id|getname
c_func
(paren
id|name
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|tmp
)paren
)paren
(brace
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|path_init
c_func
(paren
id|tmp
comma
id|flags
comma
id|nd
)paren
)paren
id|err
op_assign
id|path_walk
c_func
(paren
id|tmp
comma
id|nd
)paren
suffix:semicolon
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * It&squot;s inline, so penalty for filesystems that don&squot;t use sticky bit is&n; * minimal.&n; */
DECL|function|check_sticky
r_static
r_inline
r_int
id|check_sticky
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|dir-&gt;i_mode
op_amp
id|S_ISVTX
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_uid
op_eq
id|current-&gt;fsuid
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;i_uid
op_eq
id|current-&gt;fsuid
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_logical_neg
id|capable
c_func
(paren
id|CAP_FOWNER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Check whether we can remove a link victim from directory dir, check&n; *  whether the type of victim is right.&n; *  1. We can&squot;t do it if dir is read-only (done in permission())&n; *  2. We should have write and exec permissions on dir&n; *  3. We can&squot;t remove anything from append-only dir&n; *  4. We can&squot;t do anything with immutable dir (done in permission())&n; *  5. If the sticky bit on dir is set we should either&n; *&t;a. be owner of dir, or&n; *&t;b. be owner of victim, or&n; *&t;c. have CAP_FOWNER capability&n; *  6. If the victim is append-only or immutable we can&squot;t do antyhing with&n; *     links pointing to it.&n; *  7. If we were asked to remove a directory and victim isn&squot;t one - ENOTDIR.&n; *  8. If we were asked to remove a non-directory and victim isn&squot;t one - EISDIR.&n; *  9. We can&squot;t remove a root or mountpoint.&n; */
DECL|function|may_delete
r_static
r_inline
r_int
id|may_delete
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|victim
comma
r_int
id|isdir
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|victim-&gt;d_inode
op_logical_or
id|victim-&gt;d_parent-&gt;d_inode
op_ne
id|dir
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|error
op_assign
id|permission
c_func
(paren
id|dir
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|dir
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|check_sticky
c_func
(paren
id|dir
comma
id|victim-&gt;d_inode
)paren
op_logical_or
id|IS_APPEND
c_func
(paren
id|victim-&gt;d_inode
)paren
op_logical_or
id|IS_IMMUTABLE
c_func
(paren
id|victim-&gt;d_inode
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|isdir
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|victim-&gt;d_inode-&gt;i_mode
)paren
)paren
r_return
op_minus
id|ENOTDIR
suffix:semicolon
r_if
c_cond
(paren
id|IS_ROOT
c_func
(paren
id|victim
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|victim-&gt;d_inode-&gt;i_mode
)paren
)paren
r_return
op_minus
id|EISDIR
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&t;Check whether we can create an object with dentry child in directory&n; *  dir.&n; *  1. We can&squot;t do it if child already exists (open has special treatment for&n; *     this case, but since we are inlined it&squot;s OK)&n; *  2. We can&squot;t do it if dir is read-only (done in permission())&n; *  3. We should have write and exec permissions on dir&n; *  4. We can&squot;t do it if dir is immutable (done in permission())&n; */
DECL|function|may_create
r_static
r_inline
r_int
id|may_create
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|child
)paren
(brace
r_if
c_cond
(paren
id|child-&gt;d_inode
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|IS_DEADDIR
c_func
(paren
id|dir
)paren
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_return
id|permission
c_func
(paren
id|dir
comma
id|MAY_WRITE
op_or
id|MAY_EXEC
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Special case: O_CREAT|O_EXCL implies O_NOFOLLOW for security&n; * reasons.&n; *&n; * O_DIRECTORY translates into forcing a directory lookup.&n; */
DECL|function|lookup_flags
r_static
r_inline
r_int
id|lookup_flags
c_func
(paren
r_int
r_int
id|f
)paren
(brace
r_int
r_int
id|retval
op_assign
id|LOOKUP_FOLLOW
suffix:semicolon
r_if
c_cond
(paren
id|f
op_amp
id|O_NOFOLLOW
)paren
id|retval
op_and_assign
op_complement
id|LOOKUP_FOLLOW
suffix:semicolon
r_if
c_cond
(paren
(paren
id|f
op_amp
(paren
id|O_CREAT
op_or
id|O_EXCL
)paren
)paren
op_eq
(paren
id|O_CREAT
op_or
id|O_EXCL
)paren
)paren
id|retval
op_and_assign
op_complement
id|LOOKUP_FOLLOW
suffix:semicolon
r_if
c_cond
(paren
id|f
op_amp
id|O_DIRECTORY
)paren
id|retval
op_or_assign
id|LOOKUP_DIRECTORY
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|vfs_create
r_int
id|vfs_create
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_int
id|error
suffix:semicolon
id|mode
op_and_assign
id|S_IALLUGO
op_amp
op_complement
id|current-&gt;fs-&gt;umask
suffix:semicolon
id|mode
op_or_assign
id|S_IFREG
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
id|error
op_assign
id|may_create
c_func
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* shouldn&squot;t it be ENOSYS? */
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;create
)paren
r_goto
id|exit_lock
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|dir
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|create
c_func
(paren
id|dir
comma
id|dentry
comma
id|mode
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|up
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|inode_dir_notify
c_func
(paren
id|dir
comma
id|DN_CREATE
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;open_namei()&n; *&n; * namei for open - this is in fact almost the whole open-routine.&n; *&n; * Note that the low bits of &quot;flag&quot; aren&squot;t the same as in the open&n; * system call - they are 00 - no permissions needed&n; *&t;&t;&t;  01 - read permission needed&n; *&t;&t;&t;  10 - write permission needed&n; *&t;&t;&t;  11 - read/write permissions needed&n; * which is a lot more logical, and also allows the &quot;no perm&quot; needed&n; * for symlinks (where the permissions are checked later).&n; * SMP-safe&n; */
DECL|function|open_namei
r_int
id|open_namei
c_func
(paren
r_const
r_char
op_star
id|pathname
comma
r_int
id|flag
comma
r_int
id|mode
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_int
id|acc_mode
comma
id|error
op_assign
l_int|0
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|dentry
op_star
id|dir
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|acc_mode
op_assign
id|ACC_MODE
c_func
(paren
id|flag
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The simplest case - just a plain lookup.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|flag
op_amp
id|O_CREAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|path_init
c_func
(paren
id|pathname
comma
id|lookup_flags
c_func
(paren
id|flag
)paren
comma
id|nd
)paren
)paren
id|error
op_assign
id|path_walk
c_func
(paren
id|pathname
comma
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|dentry
op_assign
id|nd-&gt;dentry
suffix:semicolon
r_goto
id|ok
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Create - we need to know the parent.&n;&t; */
r_if
c_cond
(paren
id|path_init
c_func
(paren
id|pathname
comma
id|LOOKUP_PARENT
comma
id|nd
)paren
)paren
id|error
op_assign
id|path_walk
c_func
(paren
id|pathname
comma
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/*&n;&t; * We have the parent and last component. First of all, check&n;&t; * that we are not asked to creat(2) an obvious directory - that&n;&t; * will not do.&n;&t; */
id|error
op_assign
op_minus
id|EISDIR
suffix:semicolon
r_if
c_cond
(paren
id|nd-&gt;last_type
op_ne
id|LAST_NORM
op_logical_or
id|nd-&gt;last.name
(braket
id|nd-&gt;last.len
)braket
)paren
r_goto
m_exit
suffix:semicolon
id|dir
op_assign
id|nd-&gt;dentry
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|dentry
op_assign
id|lookup_hash
c_func
(paren
op_amp
id|nd-&gt;last
comma
id|nd-&gt;dentry
)paren
suffix:semicolon
id|do_last
suffix:colon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|dir-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/* Negative dentry, just create the file */
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_inode
)paren
(brace
id|error
op_assign
id|vfs_create
c_func
(paren
id|dir-&gt;d_inode
comma
id|dentry
comma
id|mode
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dir-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|dput
c_func
(paren
id|nd-&gt;dentry
)paren
suffix:semicolon
id|nd-&gt;dentry
op_assign
id|dentry
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
multiline_comment|/* Don&squot;t check for write permission, don&squot;t truncate */
id|acc_mode
op_assign
l_int|0
suffix:semicolon
id|flag
op_and_assign
op_complement
id|O_TRUNC
suffix:semicolon
r_goto
id|ok
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * It already exists.&n;&t; */
id|up
c_func
(paren
op_amp
id|dir-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|O_EXCL
)paren
r_goto
id|exit_dput
suffix:semicolon
r_if
c_cond
(paren
id|d_mountpoint
c_func
(paren
id|dentry
)paren
)paren
(brace
id|error
op_assign
op_minus
id|ELOOP
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|O_NOFOLLOW
)paren
r_goto
id|exit_dput
suffix:semicolon
r_do
id|__follow_down
c_func
(paren
op_amp
id|nd-&gt;mnt
comma
op_amp
id|dentry
)paren
suffix:semicolon
r_while
c_loop
(paren
id|d_mountpoint
c_func
(paren
id|dentry
)paren
)paren
(brace
suffix:semicolon
)brace
)brace
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_inode
)paren
r_goto
id|exit_dput
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_inode-&gt;i_op
op_logical_and
id|dentry-&gt;d_inode-&gt;i_op-&gt;follow_link
)paren
r_goto
id|do_link
suffix:semicolon
id|dput
c_func
(paren
id|nd-&gt;dentry
)paren
suffix:semicolon
id|nd-&gt;dentry
op_assign
id|dentry
suffix:semicolon
id|error
op_assign
op_minus
id|EISDIR
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_inode
op_logical_and
id|S_ISDIR
c_func
(paren
id|dentry-&gt;d_inode-&gt;i_mode
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|ok
suffix:colon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
m_exit
suffix:semicolon
id|error
op_assign
op_minus
id|ELOOP
suffix:semicolon
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|error
op_assign
op_minus
id|EISDIR
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
(paren
id|flag
op_amp
id|FMODE_WRITE
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|error
op_assign
id|permission
c_func
(paren
id|inode
comma
id|acc_mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
multiline_comment|/*&n;&t; * FIFO&squot;s, sockets and device files are special: they don&squot;t&n;&t; * actually live on the filesystem itself, and as such you&n;&t; * can write to them even if the filesystem is read-only.&n;&t; */
r_if
c_cond
(paren
id|S_ISFIFO
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISSOCK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|flag
op_and_assign
op_complement
id|O_TRUNC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISCHR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|IS_NODEV
c_func
(paren
id|inode
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|flag
op_and_assign
op_complement
id|O_TRUNC
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
id|IS_RDONLY
c_func
(paren
id|inode
)paren
op_logical_and
(paren
id|flag
op_amp
l_int|2
)paren
)paren
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * An append-only file must be opened in append mode for writing.&n;&t; */
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|inode
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|FMODE_WRITE
)paren
op_logical_and
op_logical_neg
(paren
id|flag
op_amp
id|O_APPEND
)paren
)paren
r_goto
m_exit
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|O_TRUNC
)paren
r_goto
m_exit
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Ensure there are no outstanding leases on the file.&n;&t; */
id|error
op_assign
id|get_lease
c_func
(paren
id|inode
comma
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|O_TRUNC
)paren
(brace
id|error
op_assign
id|get_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Refuse to truncate files with mandatory locks held on them.&n;&t;&t; */
id|error
op_assign
id|locks_verify_locked
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|DQUOT_INIT
c_func
(paren
id|inode
)paren
suffix:semicolon
id|error
op_assign
id|do_truncate
c_func
(paren
id|dentry
comma
l_int|0
)paren
suffix:semicolon
)brace
id|put_write_access
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flag
op_amp
id|FMODE_WRITE
)paren
id|DQUOT_INIT
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|exit_dput
suffix:colon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
m_exit
suffix:colon
id|path_release
c_func
(paren
id|nd
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
id|do_link
suffix:colon
id|error
op_assign
op_minus
id|ELOOP
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|O_NOFOLLOW
)paren
r_goto
id|exit_dput
suffix:semicolon
multiline_comment|/*&n;&t; * This is subtle. Instead of calling do_follow_link() we do the&n;&t; * thing by hands. The reason is that this way we have zero link_count&n;&t; * and path_walk() (called from -&gt;follow_link) honoring LOOKUP_PARENT.&n;&t; * After that we have the parent and last component, i.e.&n;&t; * we are in the same situation as after the first path_walk().&n;&t; * Well, almost - if the last component is normal we get its copy&n;&t; * stored in nd-&gt;last.name and we will have to putname() it when we&n;&t; * are done. Procfs-like symlinks just set LAST_BIND.&n;&t; */
id|UPDATE_ATIME
c_func
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
id|error
op_assign
id|dentry-&gt;d_inode-&gt;i_op
op_member_access_from_pointer
id|follow_link
c_func
(paren
id|dentry
comma
id|nd
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|nd-&gt;last_type
op_eq
id|LAST_BIND
)paren
(brace
id|dentry
op_assign
id|nd-&gt;dentry
suffix:semicolon
r_goto
id|ok
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EISDIR
suffix:semicolon
r_if
c_cond
(paren
id|nd-&gt;last_type
op_ne
id|LAST_NORM
)paren
r_goto
m_exit
suffix:semicolon
r_if
c_cond
(paren
id|nd-&gt;last.name
(braket
id|nd-&gt;last.len
)braket
)paren
(brace
id|putname
c_func
(paren
id|nd-&gt;last.name
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_increment
op_eq
l_int|32
)paren
(brace
id|dentry
op_assign
id|nd-&gt;dentry
suffix:semicolon
id|putname
c_func
(paren
id|nd-&gt;last.name
)paren
suffix:semicolon
r_goto
id|ok
suffix:semicolon
)brace
id|dir
op_assign
id|nd-&gt;dentry
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|dentry
op_assign
id|lookup_hash
c_func
(paren
op_amp
id|nd-&gt;last
comma
id|nd-&gt;dentry
)paren
suffix:semicolon
id|putname
c_func
(paren
id|nd-&gt;last.name
)paren
suffix:semicolon
r_goto
id|do_last
suffix:semicolon
)brace
multiline_comment|/* SMP-safe */
DECL|function|lookup_create
r_static
r_struct
id|dentry
op_star
id|lookup_create
c_func
(paren
r_struct
id|nameidata
op_star
id|nd
comma
r_int
id|is_dir
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|down
c_func
(paren
op_amp
id|nd-&gt;dentry-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|dentry
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|EEXIST
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nd-&gt;last_type
op_ne
id|LAST_NORM
)paren
r_goto
id|fail
suffix:semicolon
id|dentry
op_assign
id|lookup_hash
c_func
(paren
op_amp
id|nd-&gt;last
comma
id|nd-&gt;dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_dir
op_logical_and
id|nd-&gt;last.name
(braket
id|nd-&gt;last.len
)braket
op_logical_and
op_logical_neg
id|dentry-&gt;d_inode
)paren
r_goto
id|enoent
suffix:semicolon
r_return
id|dentry
suffix:semicolon
id|enoent
suffix:colon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|dentry
op_assign
id|ERR_PTR
c_func
(paren
op_minus
id|ENOENT
)paren
suffix:semicolon
id|fail
suffix:colon
r_return
id|dentry
suffix:semicolon
)brace
DECL|function|vfs_mknod
r_int
id|vfs_mknod
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
comma
id|dev_t
id|dev
)paren
(brace
r_int
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
id|mode
op_and_assign
op_complement
id|current-&gt;fs-&gt;umask
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|S_ISCHR
c_func
(paren
id|mode
)paren
op_logical_or
id|S_ISBLK
c_func
(paren
id|mode
)paren
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_MKNOD
)paren
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
id|may_create
c_func
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;mknod
)paren
r_goto
id|exit_lock
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|dir
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|mknod
c_func
(paren
id|dir
comma
id|dentry
comma
id|mode
comma
id|dev
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|up
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|inode_dir_notify
c_func
(paren
id|dir
comma
id|DN_CREATE
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_mknod
id|asmlinkage
r_int
id|sys_mknod
c_func
(paren
r_const
r_char
op_star
id|filename
comma
r_int
id|mode
comma
id|dev_t
id|dev
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|nameidata
id|nd
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|mode
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|tmp
op_assign
id|getname
c_func
(paren
id|filename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|tmp
)paren
)paren
r_return
id|PTR_ERR
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|path_init
c_func
(paren
id|tmp
comma
id|LOOKUP_PARENT
comma
op_amp
id|nd
)paren
)paren
id|error
op_assign
id|path_walk
c_func
(paren
id|tmp
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|lookup_create
c_func
(paren
op_amp
id|nd
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
(brace
r_switch
c_cond
(paren
id|mode
op_amp
id|S_IFMT
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
id|S_IFREG
suffix:colon
id|error
op_assign
id|vfs_create
c_func
(paren
id|nd.dentry-&gt;d_inode
comma
id|dentry
comma
id|mode
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFCHR
suffix:colon
r_case
id|S_IFBLK
suffix:colon
r_case
id|S_IFIFO
suffix:colon
r_case
id|S_IFSOCK
suffix:colon
id|error
op_assign
id|vfs_mknod
c_func
(paren
id|nd.dentry-&gt;d_inode
comma
id|dentry
comma
id|mode
comma
id|dev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|S_IFDIR
suffix:colon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|nd.dentry-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
id|out
suffix:colon
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|vfs_mkdir
r_int
id|vfs_mkdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_int
id|error
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
id|error
op_assign
id|may_create
c_func
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;mkdir
)paren
r_goto
id|exit_lock
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|dir
)paren
suffix:semicolon
id|mode
op_and_assign
(paren
id|S_IRWXUGO
op_or
id|S_ISVTX
)paren
op_amp
op_complement
id|current-&gt;fs-&gt;umask
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|mkdir
c_func
(paren
id|dir
comma
id|dentry
comma
id|mode
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|up
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|inode_dir_notify
c_func
(paren
id|dir
comma
id|DN_CREATE
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_mkdir
id|asmlinkage
r_int
id|sys_mkdir
c_func
(paren
r_const
r_char
op_star
id|pathname
comma
r_int
id|mode
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
id|tmp
op_assign
id|getname
c_func
(paren
id|pathname
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|tmp
)paren
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|nameidata
id|nd
suffix:semicolon
r_if
c_cond
(paren
id|path_init
c_func
(paren
id|tmp
comma
id|LOOKUP_PARENT
comma
op_amp
id|nd
)paren
)paren
id|error
op_assign
id|path_walk
c_func
(paren
id|tmp
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|lookup_create
c_func
(paren
op_amp
id|nd
comma
l_int|1
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
(brace
id|error
op_assign
id|vfs_mkdir
c_func
(paren
id|nd.dentry-&gt;d_inode
comma
id|dentry
comma
id|mode
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|nd.dentry-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
id|out
suffix:colon
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * We try to drop the dentry early: we should have&n; * a usage count of 2 if we&squot;re the only user of this&n; * dentry, and if that is true (possibly after pruning&n; * the dcache), then we drop the dentry now.&n; *&n; * A low-level filesystem can, if it choses, legally&n; * do a&n; *&n; *&t;if (!d_unhashed(dentry))&n; *&t;&t;return -EBUSY;&n; *&n; * if it cannot handle the case of removing a directory&n; * that is still in use by something else..&n; */
DECL|function|d_unhash
r_static
r_void
id|d_unhash
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
id|dget
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|dentry-&gt;d_count
)paren
)paren
(brace
r_default
suffix:colon
id|shrink_dcache_parent
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|dentry-&gt;d_count
)paren
op_ne
l_int|2
)paren
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|d_drop
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
)brace
DECL|function|vfs_rmdir
r_int
id|vfs_rmdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
id|may_delete
c_func
(paren
id|dir
comma
id|dentry
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;rmdir
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|dir
)paren
suffix:semicolon
id|double_down
c_func
(paren
op_amp
id|dir-&gt;i_zombie
comma
op_amp
id|dentry-&gt;d_inode-&gt;i_zombie
)paren
suffix:semicolon
id|d_unhash
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_DEADDIR
c_func
(paren
id|dir
)paren
)paren
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_else
r_if
c_cond
(paren
id|d_mountpoint
c_func
(paren
id|dentry
)paren
)paren
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_else
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|rmdir
c_func
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|dentry-&gt;d_inode-&gt;i_flags
op_or_assign
id|S_DEAD
suffix:semicolon
)brace
id|double_up
c_func
(paren
op_amp
id|dir-&gt;i_zombie
comma
op_amp
id|dentry-&gt;d_inode-&gt;i_zombie
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|inode_dir_notify
c_func
(paren
id|dir
comma
id|DN_DELETE
)paren
suffix:semicolon
id|d_delete
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_rmdir
id|asmlinkage
r_int
id|sys_rmdir
c_func
(paren
r_const
r_char
op_star
id|pathname
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|nameidata
id|nd
suffix:semicolon
id|name
op_assign
id|getname
c_func
(paren
id|pathname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|name
)paren
)paren
(brace
r_return
id|PTR_ERR
c_func
(paren
id|name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|path_init
c_func
(paren
id|name
comma
id|LOOKUP_PARENT
comma
op_amp
id|nd
)paren
)paren
id|error
op_assign
id|path_walk
c_func
(paren
id|name
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
r_switch
c_cond
(paren
id|nd.last_type
)paren
(brace
r_case
id|LAST_DOTDOT
suffix:colon
id|error
op_assign
op_minus
id|ENOTEMPTY
suffix:semicolon
r_goto
id|exit1
suffix:semicolon
r_case
id|LAST_DOT
suffix:colon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|exit1
suffix:semicolon
r_case
id|LAST_ROOT
suffix:colon
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|exit1
suffix:semicolon
)brace
id|down
c_func
(paren
op_amp
id|nd.dentry-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|dentry
op_assign
id|lookup_hash
c_func
(paren
op_amp
id|nd.last
comma
id|nd.dentry
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
(brace
id|error
op_assign
id|vfs_rmdir
c_func
(paren
id|nd.dentry-&gt;d_inode
comma
id|dentry
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|nd.dentry-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|exit1
suffix:colon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
m_exit
suffix:colon
id|putname
c_func
(paren
id|name
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|vfs_unlink
r_int
id|vfs_unlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
id|error
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
id|error
op_assign
id|may_delete
c_func
(paren
id|dir
comma
id|dentry
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;i_op
op_logical_and
id|dir-&gt;i_op-&gt;unlink
)paren
(brace
id|DQUOT_INIT
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d_mountpoint
c_func
(paren
id|dentry
)paren
)paren
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_else
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|unlink
c_func
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|d_delete
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
)brace
)brace
id|up
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|inode_dir_notify
c_func
(paren
id|dir
comma
id|DN_DELETE
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_unlink
id|asmlinkage
r_int
id|sys_unlink
c_func
(paren
r_const
r_char
op_star
id|pathname
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|nameidata
id|nd
suffix:semicolon
id|name
op_assign
id|getname
c_func
(paren
id|pathname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|name
)paren
)paren
(brace
r_return
id|PTR_ERR
c_func
(paren
id|name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|path_init
c_func
(paren
id|name
comma
id|LOOKUP_PARENT
comma
op_amp
id|nd
)paren
)paren
id|error
op_assign
id|path_walk
c_func
(paren
id|name
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
id|error
op_assign
op_minus
id|EISDIR
suffix:semicolon
r_if
c_cond
(paren
id|nd.last_type
op_ne
id|LAST_NORM
)paren
r_goto
id|exit1
suffix:semicolon
id|down
c_func
(paren
op_amp
id|nd.dentry-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|dentry
op_assign
id|lookup_hash
c_func
(paren
op_amp
id|nd.last
comma
id|nd.dentry
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
(brace
multiline_comment|/* Why not before? Because we want correct error value */
r_if
c_cond
(paren
id|nd.last.name
(braket
id|nd.last.len
)braket
)paren
r_goto
id|slashes
suffix:semicolon
id|error
op_assign
id|vfs_unlink
c_func
(paren
id|nd.dentry-&gt;d_inode
comma
id|dentry
)paren
suffix:semicolon
id|exit2
suffix:colon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|nd.dentry-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|exit1
suffix:colon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
m_exit
suffix:colon
id|putname
c_func
(paren
id|name
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
id|slashes
suffix:colon
id|error
op_assign
op_logical_neg
id|dentry-&gt;d_inode
ques
c_cond
op_minus
id|ENOENT
suffix:colon
id|S_ISDIR
c_func
(paren
id|dentry-&gt;d_inode-&gt;i_mode
)paren
ques
c_cond
op_minus
id|EISDIR
suffix:colon
op_minus
id|ENOTDIR
suffix:semicolon
r_goto
id|exit2
suffix:semicolon
)brace
DECL|function|vfs_symlink
r_int
id|vfs_symlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|oldname
)paren
(brace
r_int
id|error
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
id|error
op_assign
id|may_create
c_func
(paren
id|dir
comma
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;symlink
)paren
r_goto
id|exit_lock
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|dir
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|symlink
c_func
(paren
id|dir
comma
id|dentry
comma
id|oldname
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|up
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|inode_dir_notify
c_func
(paren
id|dir
comma
id|DN_CREATE
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_symlink
id|asmlinkage
r_int
id|sys_symlink
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|from
suffix:semicolon
r_char
op_star
id|to
suffix:semicolon
id|from
op_assign
id|getname
c_func
(paren
id|oldname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|from
)paren
)paren
(brace
r_return
id|PTR_ERR
c_func
(paren
id|from
)paren
suffix:semicolon
)brace
id|to
op_assign
id|getname
c_func
(paren
id|newname
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|to
)paren
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|nameidata
id|nd
suffix:semicolon
r_if
c_cond
(paren
id|path_init
c_func
(paren
id|to
comma
id|LOOKUP_PARENT
comma
op_amp
id|nd
)paren
)paren
id|error
op_assign
id|path_walk
c_func
(paren
id|to
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|lookup_create
c_func
(paren
op_amp
id|nd
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|dentry
)paren
)paren
(brace
id|error
op_assign
id|vfs_symlink
c_func
(paren
id|nd.dentry-&gt;d_inode
comma
id|dentry
comma
id|from
)paren
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|nd.dentry-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
id|out
suffix:colon
id|putname
c_func
(paren
id|to
)paren
suffix:semicolon
)brace
id|putname
c_func
(paren
id|from
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|vfs_link
r_int
id|vfs_link
c_func
(paren
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|new_dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|error
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
id|inode
op_assign
id|old_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
id|may_create
c_func
(paren
id|dir
comma
id|new_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EXDEV
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;i_dev
op_ne
id|inode-&gt;i_dev
)paren
r_goto
id|exit_lock
suffix:semicolon
multiline_comment|/*&n;&t; * A link to an append-only or immutable file cannot be created.&n;&t; */
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|IS_APPEND
c_func
(paren
id|inode
)paren
op_logical_or
id|IS_IMMUTABLE
c_func
(paren
id|inode
)paren
)paren
r_goto
id|exit_lock
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;i_op
op_logical_or
op_logical_neg
id|dir-&gt;i_op-&gt;link
)paren
r_goto
id|exit_lock
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|dir
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|dir-&gt;i_op
op_member_access_from_pointer
id|link
c_func
(paren
id|old_dentry
comma
id|dir
comma
id|new_dentry
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|exit_lock
suffix:colon
id|up
c_func
(paren
op_amp
id|dir-&gt;i_zombie
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|inode_dir_notify
c_func
(paren
id|dir
comma
id|DN_CREATE
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Hardlinks are often used in delicate situations.  We avoid&n; * security-related surprises by not following symlinks on the&n; * newname.  --KAB&n; *&n; * We don&squot;t follow them on the oldname either to be compatible&n; * with linux 2.0, and to avoid hard-linking to directories&n; * and other special files.  --ADM&n; */
DECL|function|sys_link
id|asmlinkage
r_int
id|sys_link
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|from
suffix:semicolon
r_char
op_star
id|to
suffix:semicolon
id|from
op_assign
id|getname
c_func
(paren
id|oldname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|from
)paren
)paren
(brace
r_return
id|PTR_ERR
c_func
(paren
id|from
)paren
suffix:semicolon
)brace
id|to
op_assign
id|getname
c_func
(paren
id|newname
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|to
)paren
)paren
(brace
r_struct
id|dentry
op_star
id|new_dentry
suffix:semicolon
r_struct
id|nameidata
id|nd
comma
id|old_nd
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|path_init
c_func
(paren
id|from
comma
id|LOOKUP_POSITIVE
comma
op_amp
id|old_nd
)paren
)paren
id|error
op_assign
id|path_walk
c_func
(paren
id|from
comma
op_amp
id|old_nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
r_if
c_cond
(paren
id|path_init
c_func
(paren
id|to
comma
id|LOOKUP_PARENT
comma
op_amp
id|nd
)paren
)paren
id|error
op_assign
id|path_walk
c_func
(paren
id|to
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EXDEV
suffix:semicolon
r_if
c_cond
(paren
id|old_nd.mnt
op_ne
id|nd.mnt
)paren
r_goto
id|out_release
suffix:semicolon
id|new_dentry
op_assign
id|lookup_create
c_func
(paren
op_amp
id|nd
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|new_dentry
)paren
)paren
(brace
id|error
op_assign
id|vfs_link
c_func
(paren
id|old_nd.dentry
comma
id|nd.dentry-&gt;d_inode
comma
id|new_dentry
)paren
suffix:semicolon
id|dput
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|nd.dentry-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|out_release
suffix:colon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
id|out
suffix:colon
id|path_release
c_func
(paren
op_amp
id|old_nd
)paren
suffix:semicolon
m_exit
suffix:colon
id|putname
c_func
(paren
id|to
)paren
suffix:semicolon
)brace
id|putname
c_func
(paren
id|from
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * The worst of all namespace operations - renaming directory. &quot;Perverted&quot;&n; * doesn&squot;t even start to describe it. Somebody in UCB had a heck of a trip...&n; * Problems:&n; *&t;a) we can get into loop creation. Check is done in is_subdir().&n; *&t;b) race potential - two innocent renames can create a loop together.&n; *&t;   That&squot;s where 4.4 screws up. Current fix: serialization on&n; *&t;   sb-&gt;s_vfs_rename_sem. We might be more accurate, but that&squot;s another&n; *&t;   story.&n; *&t;c) we have to lock _three_ objects - parents and victim (if it exists).&n; *&t;   And that - after we got -&gt;i_sem on parents (until then we don&squot;t know&n; *&t;   whether the target exists at all, let alone whether it is a directory&n; *&t;   or not). Solution: -&gt;i_zombie. Taken only after -&gt;i_sem. Always taken&n; *&t;   on link creation/removal of any kind. And taken (without -&gt;i_sem) on&n; *&t;   directory that will be removed (both in rmdir() and here).&n; *&t;d) some filesystems don&squot;t support opened-but-unlinked directories,&n; *&t;   either because of layout or because they are not ready to deal with&n; *&t;   all cases correctly. The latter will be fixed (taking this sort of&n; *&t;   stuff into VFS), but the former is not going away. Solution: the same&n; *&t;   trick as in rmdir().&n; *&t;e) conversion from fhandle to dentry may come in the wrong moment - when&n; *&t;   we are removing the target. Solution: we will have to grab -&gt;i_zombie&n; *&t;   in the fhandle_to_dentry code. [FIXME - current nfsfh.c relies on&n; *&t;   -&gt;i_sem on parents, which works but leads to some truely excessive&n; *&t;   locking].&n; */
DECL|function|vfs_rename_dir
r_int
id|vfs_rename_dir
c_func
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_struct
id|dentry
op_star
id|new_dentry
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|inode
op_star
id|target
suffix:semicolon
r_if
c_cond
(paren
id|old_dentry-&gt;d_inode
op_eq
id|new_dentry-&gt;d_inode
)paren
r_return
l_int|0
suffix:semicolon
id|error
op_assign
id|may_delete
c_func
(paren
id|old_dir
comma
id|old_dentry
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|new_dir-&gt;i_dev
op_ne
id|old_dir-&gt;i_dev
)paren
r_return
op_minus
id|EXDEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_dentry-&gt;d_inode
)paren
id|error
op_assign
id|may_create
c_func
(paren
id|new_dir
comma
id|new_dentry
)paren
suffix:semicolon
r_else
id|error
op_assign
id|may_delete
c_func
(paren
id|new_dir
comma
id|new_dentry
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old_dir-&gt;i_op
op_logical_or
op_logical_neg
id|old_dir-&gt;i_op-&gt;rename
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/*&n;&t; * If we are going to change the parent - check write permissions,&n;&t; * we&squot;ll need to flip &squot;..&squot;.&n;&t; */
r_if
c_cond
(paren
id|new_dir
op_ne
id|old_dir
)paren
(brace
id|error
op_assign
id|permission
c_func
(paren
id|old_dentry-&gt;d_inode
comma
id|MAY_WRITE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|old_dir
)paren
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|new_dir
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|old_dir-&gt;i_sb-&gt;s_vfs_rename_sem
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|is_subdir
c_func
(paren
id|new_dentry
comma
id|old_dentry
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|target
op_assign
id|new_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|target
)paren
(brace
multiline_comment|/* Hastur! Hastur! Hastur! */
id|triple_down
c_func
(paren
op_amp
id|old_dir-&gt;i_zombie
comma
op_amp
id|new_dir-&gt;i_zombie
comma
op_amp
id|target-&gt;i_zombie
)paren
suffix:semicolon
id|d_unhash
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
)brace
r_else
id|double_down
c_func
(paren
op_amp
id|old_dir-&gt;i_zombie
comma
op_amp
id|new_dir-&gt;i_zombie
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_DEADDIR
c_func
(paren
id|old_dir
)paren
op_logical_or
id|IS_DEADDIR
c_func
(paren
id|new_dir
)paren
)paren
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_else
r_if
c_cond
(paren
id|d_mountpoint
c_func
(paren
id|old_dentry
)paren
op_logical_or
id|d_mountpoint
c_func
(paren
id|new_dentry
)paren
)paren
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_else
id|error
op_assign
id|old_dir-&gt;i_op
op_member_access_from_pointer
id|rename
c_func
(paren
id|old_dir
comma
id|old_dentry
comma
id|new_dir
comma
id|new_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|target-&gt;i_flags
op_or_assign
id|S_DEAD
suffix:semicolon
id|triple_up
c_func
(paren
op_amp
id|old_dir-&gt;i_zombie
comma
op_amp
id|new_dir-&gt;i_zombie
comma
op_amp
id|target-&gt;i_zombie
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d_unhashed
c_func
(paren
id|new_dentry
)paren
)paren
id|d_rehash
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
id|dput
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
)brace
r_else
id|double_up
c_func
(paren
op_amp
id|old_dir-&gt;i_zombie
comma
op_amp
id|new_dir-&gt;i_zombie
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|d_move
c_func
(paren
id|old_dentry
comma
id|new_dentry
)paren
suffix:semicolon
id|out_unlock
suffix:colon
id|up
c_func
(paren
op_amp
id|old_dir-&gt;i_sb-&gt;s_vfs_rename_sem
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|vfs_rename_other
r_int
id|vfs_rename_other
c_func
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_struct
id|dentry
op_star
id|new_dentry
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|old_dentry-&gt;d_inode
op_eq
id|new_dentry-&gt;d_inode
)paren
r_return
l_int|0
suffix:semicolon
id|error
op_assign
id|may_delete
c_func
(paren
id|old_dir
comma
id|old_dentry
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|new_dir-&gt;i_dev
op_ne
id|old_dir-&gt;i_dev
)paren
r_return
op_minus
id|EXDEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_dentry-&gt;d_inode
)paren
id|error
op_assign
id|may_create
c_func
(paren
id|new_dir
comma
id|new_dentry
)paren
suffix:semicolon
r_else
id|error
op_assign
id|may_delete
c_func
(paren
id|new_dir
comma
id|new_dentry
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old_dir-&gt;i_op
op_logical_or
op_logical_neg
id|old_dir-&gt;i_op-&gt;rename
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|old_dir
)paren
suffix:semicolon
id|DQUOT_INIT
c_func
(paren
id|new_dir
)paren
suffix:semicolon
id|double_down
c_func
(paren
op_amp
id|old_dir-&gt;i_zombie
comma
op_amp
id|new_dir-&gt;i_zombie
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d_mountpoint
c_func
(paren
id|old_dentry
)paren
op_logical_or
id|d_mountpoint
c_func
(paren
id|new_dentry
)paren
)paren
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_else
id|error
op_assign
id|old_dir-&gt;i_op
op_member_access_from_pointer
id|rename
c_func
(paren
id|old_dir
comma
id|old_dentry
comma
id|new_dir
comma
id|new_dentry
)paren
suffix:semicolon
id|double_up
c_func
(paren
op_amp
id|old_dir-&gt;i_zombie
comma
op_amp
id|new_dir-&gt;i_zombie
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* The following d_move() should become unconditional */
r_if
c_cond
(paren
op_logical_neg
(paren
id|old_dir-&gt;i_sb-&gt;s_type-&gt;fs_flags
op_amp
id|FS_ODD_RENAME
)paren
)paren
(brace
id|d_move
c_func
(paren
id|old_dentry
comma
id|new_dentry
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vfs_rename
r_int
id|vfs_rename
c_func
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_struct
id|dentry
op_star
id|new_dentry
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|old_dentry-&gt;d_inode-&gt;i_mode
)paren
)paren
id|error
op_assign
id|vfs_rename_dir
c_func
(paren
id|old_dir
comma
id|old_dentry
comma
id|new_dir
comma
id|new_dentry
)paren
suffix:semicolon
r_else
id|error
op_assign
id|vfs_rename_other
c_func
(paren
id|old_dir
comma
id|old_dentry
comma
id|new_dir
comma
id|new_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_if
c_cond
(paren
id|old_dir
op_eq
id|new_dir
)paren
id|inode_dir_notify
c_func
(paren
id|old_dir
comma
id|DN_RENAME
)paren
suffix:semicolon
r_else
(brace
id|inode_dir_notify
c_func
(paren
id|old_dir
comma
id|DN_DELETE
)paren
suffix:semicolon
id|inode_dir_notify
c_func
(paren
id|new_dir
comma
id|DN_CREATE
)paren
suffix:semicolon
)brace
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_rename
r_static
r_inline
r_int
id|do_rename
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_struct
id|dentry
op_star
id|old_dir
comma
op_star
id|new_dir
suffix:semicolon
r_struct
id|dentry
op_star
id|old_dentry
comma
op_star
id|new_dentry
suffix:semicolon
r_struct
id|nameidata
id|oldnd
comma
id|newnd
suffix:semicolon
r_if
c_cond
(paren
id|path_init
c_func
(paren
id|oldname
comma
id|LOOKUP_PARENT
comma
op_amp
id|oldnd
)paren
)paren
id|error
op_assign
id|path_walk
c_func
(paren
id|oldname
comma
op_amp
id|oldnd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
m_exit
suffix:semicolon
r_if
c_cond
(paren
id|path_init
c_func
(paren
id|newname
comma
id|LOOKUP_PARENT
comma
op_amp
id|newnd
)paren
)paren
id|error
op_assign
id|path_walk
c_func
(paren
id|newname
comma
op_amp
id|newnd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|exit1
suffix:semicolon
id|error
op_assign
op_minus
id|EXDEV
suffix:semicolon
r_if
c_cond
(paren
id|oldnd.mnt
op_ne
id|newnd.mnt
)paren
r_goto
id|exit2
suffix:semicolon
id|old_dir
op_assign
id|oldnd.dentry
suffix:semicolon
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|oldnd.last_type
op_ne
id|LAST_NORM
)paren
r_goto
id|exit2
suffix:semicolon
id|new_dir
op_assign
id|newnd.dentry
suffix:semicolon
r_if
c_cond
(paren
id|newnd.last_type
op_ne
id|LAST_NORM
)paren
r_goto
id|exit2
suffix:semicolon
id|double_lock
c_func
(paren
id|new_dir
comma
id|old_dir
)paren
suffix:semicolon
id|old_dentry
op_assign
id|lookup_hash
c_func
(paren
op_amp
id|oldnd.last
comma
id|old_dir
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|old_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|old_dentry
)paren
)paren
r_goto
id|exit3
suffix:semicolon
multiline_comment|/* source must exist */
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|old_dentry-&gt;d_inode
)paren
r_goto
id|exit4
suffix:semicolon
multiline_comment|/* unless the source is a directory trailing slashes give -ENOTDIR */
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|old_dentry-&gt;d_inode-&gt;i_mode
)paren
)paren
(brace
id|error
op_assign
op_minus
id|ENOTDIR
suffix:semicolon
r_if
c_cond
(paren
id|oldnd.last.name
(braket
id|oldnd.last.len
)braket
)paren
r_goto
id|exit4
suffix:semicolon
r_if
c_cond
(paren
id|newnd.last.name
(braket
id|newnd.last.len
)braket
)paren
r_goto
id|exit4
suffix:semicolon
)brace
id|new_dentry
op_assign
id|lookup_hash
c_func
(paren
op_amp
id|newnd.last
comma
id|new_dir
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|new_dentry
)paren
)paren
r_goto
id|exit4
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|vfs_rename
c_func
(paren
id|old_dir-&gt;d_inode
comma
id|old_dentry
comma
id|new_dir-&gt;d_inode
comma
id|new_dentry
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|dput
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
id|exit4
suffix:colon
id|dput
c_func
(paren
id|old_dentry
)paren
suffix:semicolon
id|exit3
suffix:colon
id|double_up
c_func
(paren
op_amp
id|new_dir-&gt;d_inode-&gt;i_sem
comma
op_amp
id|old_dir-&gt;d_inode-&gt;i_sem
)paren
suffix:semicolon
id|exit2
suffix:colon
id|path_release
c_func
(paren
op_amp
id|newnd
)paren
suffix:semicolon
id|exit1
suffix:colon
id|path_release
c_func
(paren
op_amp
id|oldnd
)paren
suffix:semicolon
m_exit
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_rename
id|asmlinkage
r_int
id|sys_rename
c_func
(paren
r_const
r_char
op_star
id|oldname
comma
r_const
r_char
op_star
id|newname
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|from
suffix:semicolon
r_char
op_star
id|to
suffix:semicolon
id|from
op_assign
id|getname
c_func
(paren
id|oldname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|from
)paren
)paren
(brace
r_return
id|PTR_ERR
c_func
(paren
id|from
)paren
suffix:semicolon
)brace
id|to
op_assign
id|getname
c_func
(paren
id|newname
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
c_func
(paren
id|to
)paren
)paren
(brace
id|error
op_assign
id|do_rename
c_func
(paren
id|from
comma
id|to
)paren
suffix:semicolon
id|putname
c_func
(paren
id|to
)paren
suffix:semicolon
)brace
id|putname
c_func
(paren
id|from
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|vfs_readlink
r_int
id|vfs_readlink
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_char
op_star
id|buffer
comma
r_int
id|buflen
comma
r_const
r_char
op_star
id|link
)paren
(brace
r_int
id|len
suffix:semicolon
id|len
op_assign
id|PTR_ERR
c_func
(paren
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|link
)paren
)paren
r_goto
id|out
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
(paren
r_int
)paren
id|buflen
)paren
id|len
op_assign
id|buflen
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buffer
comma
id|link
comma
id|len
)paren
)paren
id|len
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|out
suffix:colon
r_return
id|len
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|__vfs_follow_link
id|__vfs_follow_link
c_func
(paren
r_struct
id|nameidata
op_star
id|nd
comma
r_const
r_char
op_star
id|link
)paren
(brace
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|link
)paren
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
op_star
id|link
op_eq
l_char|&squot;/&squot;
)paren
(brace
id|path_release
c_func
(paren
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|walk_init_root
c_func
(paren
id|link
comma
id|nd
)paren
)paren
multiline_comment|/* weird __emul_prefix() stuff did it */
r_goto
id|out
suffix:semicolon
)brace
id|res
op_assign
id|path_walk
c_func
(paren
id|link
comma
id|nd
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|current-&gt;link_count
op_logical_or
id|res
op_logical_or
id|nd-&gt;last_type
op_ne
id|LAST_NORM
)paren
r_return
id|res
suffix:semicolon
multiline_comment|/*&n;&t; * If it is an iterative symlinks resolution in open_namei() we&n;&t; * have to copy the last component. And all that crap because of&n;&t; * bloody create() on broken symlinks. Furrfu...&n;&t; */
id|name
op_assign
id|__getname
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|name
)paren
)paren
r_goto
id|fail_name
suffix:semicolon
id|strcpy
c_func
(paren
id|name
comma
id|nd-&gt;last.name
)paren
suffix:semicolon
id|nd-&gt;last.name
op_assign
id|name
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail_name
suffix:colon
id|link
op_assign
id|name
suffix:semicolon
id|fail
suffix:colon
id|path_release
c_func
(paren
id|nd
)paren
suffix:semicolon
r_return
id|PTR_ERR
c_func
(paren
id|link
)paren
suffix:semicolon
)brace
DECL|function|vfs_follow_link
r_int
id|vfs_follow_link
c_func
(paren
r_struct
id|nameidata
op_star
id|nd
comma
r_const
r_char
op_star
id|link
)paren
(brace
r_return
id|__vfs_follow_link
c_func
(paren
id|nd
comma
id|link
)paren
suffix:semicolon
)brace
multiline_comment|/* get the link contents into pagecache */
DECL|function|page_getlink
r_static
r_char
op_star
id|page_getlink
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|page
op_star
op_star
id|ppage
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|address_space
op_star
id|mapping
op_assign
id|dentry-&gt;d_inode-&gt;i_mapping
suffix:semicolon
id|page
op_assign
id|read_cache_page
c_func
(paren
id|mapping
comma
l_int|0
comma
(paren
id|filler_t
op_star
)paren
id|mapping-&gt;a_ops-&gt;readpage
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
r_goto
id|sync_fail
suffix:semicolon
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
r_goto
id|async_fail
suffix:semicolon
op_star
id|ppage
op_assign
id|page
suffix:semicolon
r_return
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|async_fail
suffix:colon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EIO
)paren
suffix:semicolon
id|sync_fail
suffix:colon
r_return
(paren
r_char
op_star
)paren
id|page
suffix:semicolon
)brace
DECL|function|page_readlink
r_int
id|page_readlink
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_char
op_star
id|buffer
comma
r_int
id|buflen
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|s
op_assign
id|page_getlink
c_func
(paren
id|dentry
comma
op_amp
id|page
)paren
suffix:semicolon
r_int
id|res
op_assign
id|vfs_readlink
c_func
(paren
id|dentry
comma
id|buffer
comma
id|buflen
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|function|page_follow_link
r_int
id|page_follow_link
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_struct
id|page
op_star
id|page
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|s
op_assign
id|page_getlink
c_func
(paren
id|dentry
comma
op_amp
id|page
)paren
suffix:semicolon
r_int
id|res
op_assign
id|__vfs_follow_link
c_func
(paren
id|nd
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page
)paren
(brace
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
DECL|variable|page_symlink_inode_operations
r_struct
id|inode_operations
id|page_symlink_inode_operations
op_assign
(brace
id|readlink
suffix:colon
id|page_readlink
comma
id|follow_link
suffix:colon
id|page_follow_link
comma
)brace
suffix:semicolon
eof
