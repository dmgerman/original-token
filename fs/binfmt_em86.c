multiline_comment|/*&n; *  linux/fs/binfmt_em86.c&n; *&n; *  Based on linux/fs/binfmt_script.c&n; *  Copyright (C) 1996  Martin von L&#xfffd;wis&n; *  original #!-checking implemented by tytso.&n; *&n; *  em86 changes Copyright (C) 1997  Jim Paradis&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/binfmts.h&gt;
macro_line|#include &lt;linux/elf.h&gt;
DECL|macro|EM86_INTERP
mdefine_line|#define EM86_INTERP&t;&quot;/usr/bin/em86&quot;
DECL|macro|EM86_I_NAME
mdefine_line|#define EM86_I_NAME&t;&quot;em86&quot;
DECL|function|do_load_em86
r_static
r_int
id|do_load_em86
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_char
op_star
id|cp
comma
op_star
id|interp
comma
op_star
id|i_name
comma
op_star
id|i_arg
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_struct
id|elfhdr
id|elf_ex
suffix:semicolon
multiline_comment|/* Make sure this is a Linux/Intel ELF executable... */
id|elf_ex
op_assign
op_star
(paren
(paren
r_struct
id|elfhdr
op_star
)paren
id|bprm-&gt;buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|elf_ex.e_ident
(braket
l_int|0
)braket
op_ne
l_int|0x7f
op_logical_or
id|strncmp
c_func
(paren
op_amp
id|elf_ex.e_ident
(braket
l_int|1
)braket
comma
l_string|&quot;ELF&quot;
comma
l_int|3
)paren
op_ne
l_int|0
)paren
(brace
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
multiline_comment|/* First of all, some simple consistency checks */
r_if
c_cond
(paren
(paren
id|elf_ex.e_type
op_ne
id|ET_EXEC
op_logical_and
id|elf_ex.e_type
op_ne
id|ET_DYN
)paren
op_logical_or
(paren
op_logical_neg
(paren
(paren
id|elf_ex.e_machine
op_eq
id|EM_386
)paren
op_logical_or
(paren
id|elf_ex.e_machine
op_eq
id|EM_486
)paren
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|bprm-&gt;inode-&gt;i_op
op_logical_or
op_logical_neg
id|bprm-&gt;inode-&gt;i_op-&gt;default_file_ops
op_logical_or
op_logical_neg
id|bprm-&gt;inode-&gt;i_op-&gt;default_file_ops-&gt;mmap
)paren
)paren
(brace
r_return
op_minus
id|ENOEXEC
suffix:semicolon
)brace
id|bprm-&gt;sh_bang
op_increment
suffix:semicolon
multiline_comment|/* Well, the bang-shell is implicit... */
id|iput
c_func
(paren
id|bprm-&gt;inode
)paren
suffix:semicolon
id|bprm-&gt;dont_iput
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Unlike in the script case, we don&squot;t have to do any hairy&n;&t; * parsing to find our interpreter... it&squot;s hardcoded!&n;&t; */
id|interp
op_assign
id|EM86_INTERP
suffix:semicolon
id|i_name
op_assign
id|EM86_I_NAME
suffix:semicolon
id|i_arg
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* We reserve the right to add an arg later */
multiline_comment|/*&n;&t; * Splice in (1) the interpreter&squot;s name for argv[0]&n;&t; *           (2) (optional) argument to interpreter&n;&t; *           (3) filename of emulated file (replace argv[0])&n;&t; *&n;&t; * This is done in reverse order, because of how the&n;&t; * user environment and arguments are stored.&n;&t; */
id|remove_arg_zero
c_func
(paren
id|bprm
)paren
suffix:semicolon
id|bprm-&gt;p
op_assign
id|copy_strings
c_func
(paren
l_int|1
comma
op_amp
id|bprm-&gt;filename
comma
id|bprm-&gt;page
comma
id|bprm-&gt;p
comma
l_int|2
)paren
suffix:semicolon
id|bprm-&gt;argc
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|i_arg
)paren
(brace
id|bprm-&gt;p
op_assign
id|copy_strings
c_func
(paren
l_int|1
comma
op_amp
id|i_arg
comma
id|bprm-&gt;page
comma
id|bprm-&gt;p
comma
l_int|2
)paren
suffix:semicolon
id|bprm-&gt;argc
op_increment
suffix:semicolon
)brace
id|bprm-&gt;p
op_assign
id|copy_strings
c_func
(paren
l_int|1
comma
op_amp
id|i_name
comma
id|bprm-&gt;page
comma
id|bprm-&gt;p
comma
l_int|2
)paren
suffix:semicolon
id|bprm-&gt;argc
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bprm-&gt;p
)paren
r_return
op_minus
id|E2BIG
suffix:semicolon
multiline_comment|/*&n;&t; * OK, now restart the process with the interpreter&squot;s inode.&n;&t; * Note that we use open_namei() as the name is now in kernel&n;&t; * space, and we don&squot;t need to copy it.&n;&t; */
id|retval
op_assign
id|open_namei
c_func
(paren
id|interp
comma
l_int|0
comma
l_int|0
comma
op_amp
id|bprm-&gt;inode
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|bprm-&gt;dont_iput
op_assign
l_int|0
suffix:semicolon
id|retval
op_assign
id|prepare_binprm
c_func
(paren
id|bprm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
r_return
id|retval
suffix:semicolon
)brace
r_return
id|search_binary_handler
c_func
(paren
id|bprm
comma
id|regs
)paren
suffix:semicolon
)brace
DECL|function|load_em86
r_static
r_int
id|load_em86
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|retval
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|retval
op_assign
id|do_load_em86
c_func
(paren
id|bprm
comma
id|regs
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|em86_format
r_struct
id|linux_binfmt
id|em86_format
op_assign
(brace
macro_line|#ifndef MODULE
l_int|NULL
comma
l_int|0
comma
id|load_em86
comma
l_int|NULL
comma
l_int|NULL
macro_line|#else
l_int|NULL
comma
op_amp
id|mod_use_count_
comma
id|load_em86
comma
l_int|NULL
comma
l_int|NULL
macro_line|#endif
)brace
suffix:semicolon
DECL|function|init_em86_binfmt
r_int
id|init_em86_binfmt
c_func
(paren
r_void
)paren
(brace
r_return
id|register_binfmt
c_func
(paren
op_amp
id|em86_format
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|init_em86_binfmt
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|unregister_binfmt
c_func
(paren
op_amp
id|em86_format
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
