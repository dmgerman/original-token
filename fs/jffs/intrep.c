multiline_comment|/*&n; * JFFS -- Journaling Flash File System, Linux implementation.&n; *&n; * Copyright (C) 1999, 2000  Axis Communications, Inc.&n; *&n; * Created by Finn Hakansson &lt;finn@axis.com&gt;.&n; *&n; * This is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * - Based on Id: intrep.c,v 1.71 2000/10/27 16:51:29 dwmw2 Exp&n; * - With the ctype() changes from v1.77.&n; *&n; * Ported to Linux 2.3.x and MTD:&n; * Copyright (C) 2000  Alexander Larsson (alex@cendio.se), Cendio Systems AB&n; *&n; */
multiline_comment|/* This file contains the code for the internal structure of the&n;   Journaling Flash File System, JFFS.  */
multiline_comment|/*&n; * Todo list:&n; *&n; * memcpy_to_flash() and memcpy_from_flash() functions.&n; *&n; * Implementation of hard links.&n; *&n; * Organize the source code in a better way. Against the VFS we could&n; * have jffs_ext.c, and against the block device jffs_int.c.&n; * A better file-internal organization too.&n; *&n; * A better checksum algorithm.&n; *&n; * Consider endianness stuff. ntohl() etc.&n; *&n; * Are we handling the atime, mtime, ctime members of the inode right?&n; *&n; * Remove some duplicated code. Take a look at jffs_write_node() and&n; * jffs_rewrite_data() for instance.&n; *&n; * Implement more meaning of the nlink member in various data structures.&n; * nlink could be used in conjunction with hard links for instance.&n; *&n; * Better memory management. Allocate data structures in larger chunks&n; * if possible.&n; *&n; * If too much meta data is stored, a garbage collect should be issued.&n; * We have experienced problems with too much meta data with for instance&n; * log files.&n; *&n; * Improve the calls to jffs_ioctl(). We would like to retrieve more&n; * information to be able to debug (or to supervise) JFFS during run-time.&n; *&n; */
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/jffs.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &quot;intrep.h&quot;
macro_line|#include &quot;jffs_fm.h&quot;
macro_line|#if defined(JFFS_MEMORY_DEBUG) &amp;&amp; JFFS_MEMORY_DEBUG
DECL|variable|no_jffs_file
r_int
id|no_jffs_file
op_assign
l_int|0
suffix:semicolon
DECL|variable|no_jffs_node
r_int
id|no_jffs_node
op_assign
l_int|0
suffix:semicolon
DECL|variable|no_jffs_control
r_int
id|no_jffs_control
op_assign
l_int|0
suffix:semicolon
DECL|variable|no_jffs_raw_inode
r_int
id|no_jffs_raw_inode
op_assign
l_int|0
suffix:semicolon
DECL|variable|no_jffs_node_ref
r_int
id|no_jffs_node_ref
op_assign
l_int|0
suffix:semicolon
DECL|variable|no_jffs_fm
r_int
id|no_jffs_fm
op_assign
l_int|0
suffix:semicolon
DECL|variable|no_jffs_fmcontrol
r_int
id|no_jffs_fmcontrol
op_assign
l_int|0
suffix:semicolon
DECL|variable|no_hash
r_int
id|no_hash
op_assign
l_int|0
suffix:semicolon
DECL|variable|no_name
r_int
id|no_name
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_static
r_int
id|jffs_scan_flash
c_func
(paren
r_struct
id|jffs_control
op_star
id|c
)paren
suffix:semicolon
r_static
r_int
id|jffs_update_file
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
comma
r_struct
id|jffs_node
op_star
id|node
)paren
suffix:semicolon
r_static
id|__u8
id|flash_read_u8
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
)paren
suffix:semicolon
macro_line|#if 1
r_static
r_void
DECL|function|jffs_hexdump
id|jffs_hexdump
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|pos
comma
r_int
id|size
)paren
(brace
r_char
id|line
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|j
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%ld:&quot;
comma
(paren
r_int
)paren
id|pos
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|16
suffix:semicolon
id|j
op_increment
)paren
(brace
id|line
(braket
id|j
)braket
op_assign
id|flash_read_u8
c_func
(paren
id|mtd
comma
id|pos
op_increment
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|j
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_amp
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %.2x&quot;
comma
id|line
(braket
id|i
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%.2x&quot;
comma
id|line
(braket
id|i
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Print empty space */
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_amp
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;   &quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;  &quot;
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;  &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|j
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|isgraph
c_func
(paren
id|line
(braket
id|i
)braket
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|line
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|size
op_sub_assign
l_int|16
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|macro|flash_safe_acquire
mdefine_line|#define flash_safe_acquire(arg)
DECL|macro|flash_safe_release
mdefine_line|#define flash_safe_release(arg)
r_static
r_int
DECL|function|flash_safe_read
id|flash_safe_read
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
id|u_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|retlen
suffix:semicolon
r_int
id|res
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;flash_safe_read(%p, %08x, %p, %08x)&bslash;n&quot;
comma
id|mtd
comma
id|from
comma
id|buf
comma
id|count
)paren
)paren
suffix:semicolon
id|res
op_assign
id|MTD_READ
c_func
(paren
id|mtd
comma
id|from
comma
id|count
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retlen
op_ne
id|count
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Didn&squot;t read all bytes in flash_safe_read(). Returned %d&bslash;n&quot;
comma
id|res
)paren
suffix:semicolon
)brace
r_return
id|res
ques
c_cond
id|res
suffix:colon
id|retlen
suffix:semicolon
)brace
r_static
id|__u32
DECL|function|flash_read_u32
id|flash_read_u32
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
)paren
(brace
r_int
id|retlen
suffix:semicolon
id|__u32
id|ret
suffix:semicolon
r_int
id|res
suffix:semicolon
id|res
op_assign
id|MTD_READ
c_func
(paren
id|mtd
comma
id|from
comma
l_int|4
comma
op_amp
id|retlen
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retlen
op_ne
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Didn&squot;t read all bytes in flash_read_u32(). Returned %d&bslash;n&quot;
comma
id|res
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
id|__u8
DECL|function|flash_read_u8
id|flash_read_u8
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
)paren
(brace
r_int
id|retlen
suffix:semicolon
id|__u8
id|ret
suffix:semicolon
r_int
id|res
suffix:semicolon
id|res
op_assign
id|MTD_READ
c_func
(paren
id|mtd
comma
id|from
comma
l_int|1
comma
op_amp
id|retlen
comma
op_amp
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retlen
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Didn&squot;t read a byte in flash_read_u8(). Returned %d&bslash;n&quot;
comma
id|res
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|flash_safe_write
id|flash_safe_write
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|retlen
suffix:semicolon
r_int
id|res
suffix:semicolon
id|res
op_assign
id|MTD_WRITE
c_func
(paren
id|mtd
comma
id|to
comma
id|count
comma
op_amp
id|retlen
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retlen
op_ne
id|count
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Didn&squot;t write all bytes in flash_safe_write(). Returned %d&bslash;n&quot;
comma
id|res
)paren
suffix:semicolon
)brace
r_return
id|res
ques
c_cond
id|res
suffix:colon
id|retlen
suffix:semicolon
)brace
r_static
r_int
DECL|function|flash_memset
id|flash_memset
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_const
id|u_char
id|c
comma
r_int
id|size
)paren
(brace
r_static
r_int
r_char
id|pattern
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* fill up pattern */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pattern
(braket
id|i
)braket
op_assign
id|c
suffix:semicolon
)brace
multiline_comment|/* write as many 16-byte chunks as we can */
r_while
c_loop
(paren
id|size
op_ge
l_int|16
)paren
(brace
id|flash_safe_write
c_func
(paren
id|mtd
comma
id|to
comma
id|pattern
comma
l_int|16
)paren
suffix:semicolon
id|size
op_sub_assign
l_int|16
suffix:semicolon
id|to
op_add_assign
l_int|16
suffix:semicolon
)brace
multiline_comment|/* and the rest */
r_if
c_cond
(paren
id|size
)paren
(brace
id|flash_safe_write
c_func
(paren
id|mtd
comma
id|to
comma
id|pattern
comma
id|size
)paren
suffix:semicolon
)brace
r_return
id|size
suffix:semicolon
)brace
r_static
r_void
DECL|function|intrep_erase_callback
id|intrep_erase_callback
c_func
(paren
r_struct
id|erase_info
op_star
id|done
)paren
(brace
id|wait_queue_head_t
op_star
id|wait_q
suffix:semicolon
id|wait_q
op_assign
(paren
id|wait_queue_head_t
op_star
)paren
id|done-&gt;priv
suffix:semicolon
id|wake_up
c_func
(paren
id|wait_q
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|flash_erase_region
id|flash_erase_region
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|start
comma
r_int
id|size
)paren
(brace
r_struct
id|erase_info
op_star
id|erase
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|wait_queue_head_t
id|wait_q
suffix:semicolon
id|erase
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|erase_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|erase
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|wait_q
)paren
suffix:semicolon
id|erase-&gt;mtd
op_assign
id|mtd
suffix:semicolon
id|erase-&gt;callback
op_assign
id|intrep_erase_callback
suffix:semicolon
id|erase-&gt;addr
op_assign
id|start
suffix:semicolon
id|erase-&gt;len
op_assign
id|size
suffix:semicolon
id|erase-&gt;priv
op_assign
(paren
id|u_long
)paren
op_amp
id|wait_q
suffix:semicolon
multiline_comment|/* FIXME: Use TASK_INTERRUPTIBLE and deal with being interrupted */
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|wait_q
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MTD_ERASE
c_func
(paren
id|mtd
comma
id|erase
)paren
OL
l_int|0
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|wait_q
comma
op_amp
id|wait
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|erase
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;flash: erase of region [0x%lx, 0x%lx] &quot;
l_string|&quot;totally failed&bslash;n&quot;
comma
(paren
r_int
)paren
id|start
comma
(paren
r_int
)paren
id|start
op_plus
id|size
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Wait for flash to finish. */
id|remove_wait_queue
c_func
(paren
op_amp
id|wait_q
comma
op_amp
id|wait
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|erase
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_inline
r_int
DECL|function|jffs_min
id|jffs_min
c_func
(paren
r_int
id|a
comma
r_int
id|b
)paren
(brace
r_return
(paren
id|a
OL
id|b
ques
c_cond
id|a
suffix:colon
id|b
)paren
suffix:semicolon
)brace
r_inline
r_int
DECL|function|jffs_max
id|jffs_max
c_func
(paren
r_int
id|a
comma
r_int
id|b
)paren
(brace
r_return
(paren
id|a
OG
id|b
ques
c_cond
id|a
suffix:colon
id|b
)paren
suffix:semicolon
)brace
multiline_comment|/* This routine calculates checksums in JFFS.  */
id|__u32
DECL|function|jffs_checksum
id|jffs_checksum
c_func
(paren
r_const
r_void
op_star
id|data
comma
r_int
id|size
)paren
(brace
id|__u32
id|sum
op_assign
l_int|0
suffix:semicolon
id|__u8
op_star
id|ptr
op_assign
(paren
id|__u8
op_star
)paren
id|data
suffix:semicolon
r_while
c_loop
(paren
id|size
op_decrement
OG
l_int|0
)paren
(brace
id|sum
op_add_assign
op_star
id|ptr
op_increment
suffix:semicolon
)brace
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;, result: 0x%08x&bslash;n&quot;
comma
id|sum
)paren
)paren
suffix:semicolon
r_return
id|sum
suffix:semicolon
)brace
id|__u32
DECL|function|jffs_checksum_flash
id|jffs_checksum_flash
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|start
comma
r_int
id|size
)paren
(brace
id|__u32
id|sum
op_assign
l_int|0
suffix:semicolon
id|loff_t
id|ptr
op_assign
id|start
suffix:semicolon
id|__u8
op_star
id|read_buf
suffix:semicolon
r_int
id|i
comma
id|length
suffix:semicolon
multiline_comment|/* Allocate read buffer */
id|read_buf
op_assign
(paren
id|__u8
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|__u8
)paren
op_star
l_int|4096
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* Loop until checksum done */
r_while
c_loop
(paren
id|size
)paren
(brace
multiline_comment|/* Get amount of data to read */
r_if
c_cond
(paren
id|size
OL
l_int|4096
)paren
id|length
op_assign
id|size
suffix:semicolon
r_else
id|length
op_assign
l_int|4096
suffix:semicolon
multiline_comment|/* Perform flash read */
id|D3
c_func
(paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs_checksum_flash&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|flash_safe_read
c_func
(paren
id|mtd
comma
id|ptr
comma
op_amp
id|read_buf
(braket
l_int|0
)braket
comma
id|length
)paren
suffix:semicolon
multiline_comment|/* Compute checksum */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|length
suffix:semicolon
id|i
op_increment
)paren
id|sum
op_add_assign
id|read_buf
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Update pointer and size */
id|size
op_sub_assign
id|length
suffix:semicolon
id|ptr
op_add_assign
id|length
suffix:semicolon
)brace
multiline_comment|/* Free read buffer */
id|kfree
(paren
id|read_buf
)paren
suffix:semicolon
multiline_comment|/* Return result */
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;checksum result: 0x%08x&bslash;n&quot;
comma
id|sum
)paren
)paren
suffix:semicolon
r_return
id|sum
suffix:semicolon
)brace
DECL|function|jffs_fm_write_lock
r_static
id|__inline__
r_void
id|jffs_fm_write_lock
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
)paren
(brace
singleline_comment|//&t;down(&amp;fmc-&gt;wlock);
)brace
DECL|function|jffs_fm_write_unlock
r_static
id|__inline__
r_void
id|jffs_fm_write_unlock
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
)paren
(brace
singleline_comment|//&t;up(&amp;fmc-&gt;wlock);
)brace
multiline_comment|/* Create and initialize a new struct jffs_file.  */
r_static
r_struct
id|jffs_file
op_star
DECL|function|jffs_create_file
id|jffs_create_file
c_func
(paren
r_struct
id|jffs_control
op_star
id|c
comma
r_const
r_struct
id|jffs_raw_inode
op_star
id|raw_inode
)paren
(brace
r_struct
id|jffs_file
op_star
id|f
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|f
op_assign
(paren
r_struct
id|jffs_file
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs_file
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_create_file(): Failed!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DJM
c_func
(paren
id|no_jffs_file
op_increment
)paren
suffix:semicolon
id|memset
c_func
(paren
id|f
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|jffs_file
)paren
)paren
suffix:semicolon
id|f-&gt;ino
op_assign
id|raw_inode-&gt;ino
suffix:semicolon
id|f-&gt;pino
op_assign
id|raw_inode-&gt;pino
suffix:semicolon
id|f-&gt;nlink
op_assign
id|raw_inode-&gt;nlink
suffix:semicolon
id|f-&gt;deleted
op_assign
id|raw_inode-&gt;deleted
suffix:semicolon
id|f-&gt;c
op_assign
id|c
suffix:semicolon
r_return
id|f
suffix:semicolon
)brace
multiline_comment|/* Build a control block for the file system.  */
r_static
r_struct
id|jffs_control
op_star
DECL|function|jffs_create_control
id|jffs_create_control
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_struct
id|jffs_control
op_star
id|c
suffix:semicolon
r_register
r_int
id|s
op_assign
r_sizeof
(paren
r_struct
id|jffs_control
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
id|D
c_func
(paren
r_char
op_star
id|t
op_assign
l_int|0
)paren
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_create_control()&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|c
op_assign
(paren
r_struct
id|jffs_control
op_star
)paren
id|kmalloc
c_func
(paren
id|s
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
r_goto
id|fail_control
suffix:semicolon
)brace
id|DJM
c_func
(paren
id|no_jffs_control
op_increment
)paren
suffix:semicolon
id|c-&gt;root
op_assign
l_int|0
suffix:semicolon
id|c-&gt;gc_task
op_assign
l_int|0
suffix:semicolon
id|c-&gt;hash_len
op_assign
id|JFFS_HASH_SIZE
suffix:semicolon
id|s
op_assign
r_sizeof
(paren
r_struct
id|list_head
)paren
op_star
id|c-&gt;hash_len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|c-&gt;hash
op_assign
(paren
r_struct
id|list_head
op_star
)paren
id|kmalloc
c_func
(paren
id|s
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
r_goto
id|fail_hash
suffix:semicolon
)brace
id|DJM
c_func
(paren
id|no_hash
op_increment
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|c-&gt;hash_len
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|c-&gt;hash
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|c-&gt;fmc
op_assign
id|jffs_build_begin
c_func
(paren
id|c
comma
id|dev
)paren
)paren
)paren
(brace
r_goto
id|fail_fminit
suffix:semicolon
)brace
id|c-&gt;next_ino
op_assign
id|JFFS_MIN_INO
op_plus
l_int|1
suffix:semicolon
id|c-&gt;delete_list
op_assign
(paren
r_struct
id|jffs_delete_list
op_star
)paren
l_int|0
suffix:semicolon
r_return
id|c
suffix:semicolon
id|fail_fminit
suffix:colon
id|D
c_func
(paren
id|t
op_assign
l_string|&quot;c-&gt;fmc&quot;
)paren
suffix:semicolon
id|fail_hash
suffix:colon
id|kfree
c_func
(paren
id|c
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_control
op_decrement
)paren
suffix:semicolon
id|D
c_func
(paren
id|t
op_assign
id|t
ques
c_cond
id|t
suffix:colon
l_string|&quot;c-&gt;hash&quot;
)paren
suffix:semicolon
id|fail_control
suffix:colon
id|D
c_func
(paren
id|t
op_assign
id|t
ques
c_cond
id|t
suffix:colon
l_string|&quot;control&quot;
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_create_control(): Allocation failed: (%s)&bslash;n&quot;
comma
id|t
)paren
)paren
suffix:semicolon
r_return
(paren
r_struct
id|jffs_control
op_star
)paren
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Clean up all data structures associated with the file system.  */
r_void
DECL|function|jffs_cleanup_control
id|jffs_cleanup_control
c_func
(paren
r_struct
id|jffs_control
op_star
id|c
)paren
(brace
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_cleanup_control()&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_cleanup_control(): c == NULL !!!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c-&gt;delete_list
)paren
(brace
r_struct
id|jffs_delete_list
op_star
id|delete_list_element
suffix:semicolon
id|delete_list_element
op_assign
id|c-&gt;delete_list
suffix:semicolon
id|c-&gt;delete_list
op_assign
id|c-&gt;delete_list-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|delete_list_element
)paren
suffix:semicolon
)brace
multiline_comment|/* Free all files and nodes.  */
r_if
c_cond
(paren
id|c-&gt;hash
)paren
(brace
id|jffs_foreach_file
c_func
(paren
id|c
comma
id|jffs_free_node_list
)paren
suffix:semicolon
id|jffs_foreach_file
c_func
(paren
id|c
comma
id|jffs_free_file
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|c-&gt;hash
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_hash
op_decrement
)paren
suffix:semicolon
)brace
id|jffs_cleanup_fmcontrol
c_func
(paren
id|c-&gt;fmc
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|c
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_control
op_decrement
)paren
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_cleanup_control(): Leaving...&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This function adds a virtual root node to the in-RAM representation.&n;   Called by jffs_build_fs().  */
r_static
r_int
DECL|function|jffs_add_virtual_root
id|jffs_add_virtual_root
c_func
(paren
r_struct
id|jffs_control
op_star
id|c
)paren
(brace
r_struct
id|jffs_file
op_star
id|root
suffix:semicolon
r_struct
id|jffs_node
op_star
id|node
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_add_virtual_root(): &quot;
l_string|&quot;Creating a virtual root directory.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|root
op_assign
(paren
r_struct
id|jffs_file
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs_file
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|DJM
c_func
(paren
id|no_jffs_file
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|node
op_assign
(paren
r_struct
id|jffs_node
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs_node
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|kfree
c_func
(paren
id|root
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_file
op_decrement
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|DJM
c_func
(paren
id|no_jffs_node
op_increment
)paren
suffix:semicolon
id|memset
c_func
(paren
id|node
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|jffs_node
)paren
)paren
suffix:semicolon
id|node-&gt;ino
op_assign
id|JFFS_MIN_INO
suffix:semicolon
id|memset
c_func
(paren
id|root
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|jffs_file
)paren
)paren
suffix:semicolon
id|root-&gt;ino
op_assign
id|JFFS_MIN_INO
suffix:semicolon
id|root-&gt;mode
op_assign
id|S_IFDIR
op_or
id|S_IRWXU
op_or
id|S_IRGRP
op_or
id|S_IXGRP
op_or
id|S_IROTH
op_or
id|S_IXOTH
suffix:semicolon
id|root-&gt;atime
op_assign
id|root-&gt;mtime
op_assign
id|root-&gt;ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|root-&gt;nlink
op_assign
l_int|1
suffix:semicolon
id|root-&gt;c
op_assign
id|c
suffix:semicolon
id|root-&gt;version_head
op_assign
id|root-&gt;version_tail
op_assign
id|node
suffix:semicolon
id|jffs_insert_file_into_hash
c_func
(paren
id|root
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is where the file system is built and initialized.  */
r_int
DECL|function|jffs_build_fs
id|jffs_build_fs
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_struct
id|jffs_control
op_star
id|c
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_build_fs()&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|c
op_assign
id|jffs_create_control
c_func
(paren
id|sb-&gt;s_dev
)paren
)paren
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|c-&gt;building_fs
op_assign
l_int|1
suffix:semicolon
id|c-&gt;sb
op_assign
id|sb
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|jffs_scan_flash
c_func
(paren
id|c
)paren
)paren
OL
l_int|0
)paren
(brace
r_goto
id|jffs_build_fs_fail
suffix:semicolon
)brace
multiline_comment|/* Add a virtual root node if no one exists.  */
r_if
c_cond
(paren
op_logical_neg
id|jffs_find_file
c_func
(paren
id|c
comma
id|JFFS_MIN_INO
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|jffs_add_virtual_root
c_func
(paren
id|c
)paren
)paren
OL
l_int|0
)paren
(brace
r_goto
id|jffs_build_fs_fail
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|c-&gt;delete_list
)paren
(brace
r_struct
id|jffs_file
op_star
id|f
suffix:semicolon
r_struct
id|jffs_delete_list
op_star
id|delete_list_element
suffix:semicolon
r_if
c_cond
(paren
(paren
id|f
op_assign
id|jffs_find_file
c_func
(paren
id|c
comma
id|c-&gt;delete_list-&gt;ino
)paren
)paren
)paren
(brace
id|f-&gt;deleted
op_assign
l_int|1
suffix:semicolon
)brace
id|delete_list_element
op_assign
id|c-&gt;delete_list
suffix:semicolon
id|c-&gt;delete_list
op_assign
id|c-&gt;delete_list-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|delete_list_element
)paren
suffix:semicolon
)brace
multiline_comment|/* Remove deleted nodes.  */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|jffs_foreach_file
c_func
(paren
id|c
comma
id|jffs_possibly_delete_file
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;JFFS: Failed to remove deleted nodes.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|jffs_build_fs_fail
suffix:semicolon
)brace
multiline_comment|/* Remove redundant nodes.  (We are not interested in the&n;&t;   return value in this case.)  */
id|jffs_foreach_file
c_func
(paren
id|c
comma
id|jffs_remove_redundant_nodes
)paren
suffix:semicolon
multiline_comment|/* Try to build a tree from all the nodes.  */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|jffs_foreach_file
c_func
(paren
id|c
comma
id|jffs_insert_file_into_tree
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;JFFS: Failed to build tree.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|jffs_build_fs_fail
suffix:semicolon
)brace
multiline_comment|/* Compute the sizes of all files in the filesystem.  Adjust if&n;&t;   necessary.  */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|jffs_foreach_file
c_func
(paren
id|c
comma
id|jffs_build_file
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;JFFS: Failed to build file system.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|jffs_build_fs_fail
suffix:semicolon
)brace
id|sb-&gt;u.generic_sbp
op_assign
(paren
r_void
op_star
)paren
id|c
suffix:semicolon
id|c-&gt;building_fs
op_assign
l_int|0
suffix:semicolon
id|D1
c_func
(paren
id|jffs_print_hash_table
c_func
(paren
id|c
)paren
)paren
suffix:semicolon
id|D1
c_func
(paren
id|jffs_print_tree
c_func
(paren
id|c-&gt;root
comma
l_int|0
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|jffs_build_fs_fail
suffix:colon
id|jffs_cleanup_control
c_func
(paren
id|c
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* jffs_build_fs()  */
multiline_comment|/* Scan the whole flash memory in order to find all nodes in the&n;   file systems.  */
r_static
r_int
DECL|function|jffs_scan_flash
id|jffs_scan_flash
c_func
(paren
r_struct
id|jffs_control
op_star
id|c
)paren
(brace
r_char
id|name
(braket
id|JFFS_MAX_NAME_LEN
op_plus
l_int|2
)braket
suffix:semicolon
r_struct
id|jffs_raw_inode
id|raw_inode
suffix:semicolon
r_struct
id|jffs_node
op_star
id|node
op_assign
l_int|0
suffix:semicolon
r_struct
id|jffs_fmcontrol
op_star
id|fmc
op_assign
id|c-&gt;fmc
suffix:semicolon
id|__u32
id|checksum
suffix:semicolon
id|__u8
id|tmp_accurate
suffix:semicolon
id|__u16
id|tmp_chksum
suffix:semicolon
id|__u32
id|deleted_file
suffix:semicolon
id|loff_t
id|pos
op_assign
id|fmc-&gt;flash_start
suffix:semicolon
id|loff_t
id|start
suffix:semicolon
id|loff_t
id|end
op_assign
id|fmc-&gt;flash_start
op_plus
id|fmc-&gt;flash_size
suffix:semicolon
id|__u8
op_star
id|read_buf
suffix:semicolon
r_int
id|i
comma
id|len
comma
id|retlen
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_scan_flash(): start pos = 0x%lx, end = 0x%lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|pos
comma
(paren
r_int
)paren
id|end
)paren
)paren
suffix:semicolon
id|flash_safe_acquire
c_func
(paren
id|fmc-&gt;mtd
)paren
suffix:semicolon
multiline_comment|/* Allocate read buffer */
id|read_buf
op_assign
(paren
id|__u8
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|__u8
)paren
op_star
l_int|4096
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* Start the scan.  */
r_while
c_loop
(paren
id|pos
OL
id|end
)paren
(brace
id|deleted_file
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Remember the position from where we started this scan.  */
id|start
op_assign
id|pos
suffix:semicolon
r_switch
c_cond
(paren
id|flash_read_u32
c_func
(paren
id|fmc-&gt;mtd
comma
id|pos
)paren
)paren
(brace
r_case
id|JFFS_EMPTY_BITMASK
suffix:colon
multiline_comment|/* We have found 0xff at this position.  We have to&n;&t;&t;&t;   scan the rest of the flash till the end or till&n;&t;&t;&t;   something else than 0xff is found.  */
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_scan_flash(): 0xff at pos 0x%lx.&bslash;n&quot;
comma
(paren
r_int
)paren
id|pos
)paren
)paren
suffix:semicolon
id|len
op_assign
id|end
op_minus
id|pos
OL
l_int|4096
ques
c_cond
id|end
op_minus
id|pos
suffix:colon
l_int|4096
suffix:semicolon
id|retlen
op_assign
id|flash_safe_read
c_func
(paren
id|fmc-&gt;mtd
comma
id|pos
comma
op_amp
id|read_buf
(braket
l_int|0
)braket
comma
id|len
)paren
suffix:semicolon
id|retlen
op_and_assign
op_complement
l_int|3
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|retlen
suffix:semicolon
id|i
op_add_assign
l_int|4
comma
id|pos
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
(paren
id|__u32
op_star
)paren
op_amp
id|read_buf
(braket
id|i
)braket
)paren
op_ne
id|JFFS_EMPTY_BITMASK
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
id|retlen
)paren
r_continue
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_scan_flash(): 0xff ended at &quot;
l_string|&quot;pos 0x%lx.&bslash;n&quot;
comma
(paren
r_int
)paren
id|pos
)paren
)paren
suffix:semicolon
multiline_comment|/* If some free space ends in the middle of a sector,&n;&t;&t;&t;&t;treat it as dirty rather than clean.&n;&t;&t;&t;   This is to handle the case where one thread &n;&t;&t;&t;   allocated space for a node, but didn&squot;t get to&n;&t;&t;&t;   actually _write_ it before power was lost, leaving&n;&t;&t;&t;   a gap in the log. Shifting all node writes into&n;&t;&t;&t;   a single kernel thread will fix the original problem.&n;&t;&t;&t;*/
r_if
c_cond
(paren
(paren
id|__u32
)paren
id|pos
op_mod
id|fmc-&gt;sector_size
)paren
(brace
multiline_comment|/* If there was free space in previous &n;&t;&t;&t;&t;   sectors, don&squot;t mark that dirty too - &n;&t;&t;&t;&t;   only from the beginning of this sector&n;&t;&t;&t;&t;   (or from start) &n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
id|start
OL
(paren
id|pos
op_amp
op_complement
(paren
id|fmc-&gt;sector_size
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;Reducing start to 0x%x from 0x%x&bslash;n&quot;
comma
id|pos
op_amp
op_complement
(paren
id|fmc-&gt;sector_size
op_minus
l_int|1
)paren
comma
id|start
)paren
)paren
suffix:semicolon
id|start
op_assign
id|pos
op_amp
op_complement
(paren
id|fmc-&gt;sector_size
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;Dirty space: 0x%x for 0x%x bytes&bslash;n&quot;
comma
id|start
comma
(paren
id|pos
op_minus
id|start
)paren
)paren
)paren
suffix:semicolon
id|jffs_fmalloced
c_func
(paren
id|fmc
comma
(paren
id|__u32
)paren
id|start
comma
(paren
id|__u32
)paren
(paren
id|pos
op_minus
id|start
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
r_case
id|JFFS_DIRTY_BITMASK
suffix:colon
multiline_comment|/* We have found 0x00 at this position.  Scan as far&n;&t;&t;&t;   as possible to find out how much is dirty.  */
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_scan_flash(): 0x00 at pos 0x%lx.&bslash;n&quot;
comma
(paren
r_int
)paren
id|pos
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|pos
OL
id|end
op_logical_and
id|JFFS_DIRTY_BITMASK
op_eq
id|flash_read_u32
c_func
(paren
id|fmc-&gt;mtd
comma
id|pos
)paren
suffix:semicolon
id|pos
op_add_assign
l_int|4
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_scan_flash(): 0x00 ended at &quot;
l_string|&quot;pos 0x%lx.&bslash;n&quot;
comma
(paren
r_int
)paren
id|pos
)paren
)paren
suffix:semicolon
id|jffs_fmalloced
c_func
(paren
id|fmc
comma
(paren
id|__u32
)paren
id|start
comma
(paren
id|__u32
)paren
(paren
id|pos
op_minus
id|start
)paren
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|JFFS_MAGIC_BITMASK
suffix:colon
multiline_comment|/* We have probably found a new raw inode.  */
r_break
suffix:semicolon
r_default
suffix:colon
id|bad_inode
suffix:colon
multiline_comment|/* We&squot;re f*cked.  This is not solved yet.  We have&n;&t;&t;&t;   to scan for the magic pattern.  */
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;*************** Dirty flash memory or &quot;
l_string|&quot;bad inode: &quot;
l_string|&quot;hexdump(pos = 0x%lx, len = 128):&bslash;n&quot;
comma
(paren
r_int
)paren
id|pos
)paren
)paren
suffix:semicolon
id|D1
c_func
(paren
id|jffs_hexdump
c_func
(paren
id|fmc-&gt;mtd
comma
id|pos
comma
l_int|128
)paren
)paren
suffix:semicolon
id|cont_dirty
suffix:colon
r_for
c_loop
(paren
id|pos
op_add_assign
l_int|4
suffix:semicolon
id|pos
OL
id|end
suffix:semicolon
id|pos
op_add_assign
l_int|4
)paren
(brace
r_switch
c_cond
(paren
id|flash_read_u32
c_func
(paren
id|fmc-&gt;mtd
comma
id|pos
)paren
)paren
(brace
r_case
id|JFFS_MAGIC_BITMASK
suffix:colon
id|jffs_fmalloced
c_func
(paren
id|fmc
comma
(paren
id|__u32
)paren
id|start
comma
(paren
id|__u32
)paren
(paren
id|pos
op_minus
id|start
)paren
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|cont_scan
suffix:semicolon
r_case
id|JFFS_EMPTY_BITMASK
suffix:colon
multiline_comment|/* First, mark as dirty the region&n;&t;&t;&t;&t;&t;   which really does contain crap. */
id|jffs_fmalloced
c_func
(paren
id|fmc
comma
(paren
id|__u32
)paren
id|start
comma
(paren
id|__u32
)paren
(paren
id|pos
op_minus
id|start
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Then, scan the region which looks free.&n;&t;&t;&t;&t;&t;   Depending on how large it is, we may&n;&t;&t;&t;&t;&t;   mark it dirty too.&n;&t;&t;&t;&t;&t;*/
id|start
op_assign
id|pos
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|pos
OL
id|end
suffix:semicolon
id|pos
op_add_assign
l_int|4
)paren
(brace
r_switch
c_cond
(paren
id|flash_read_u32
c_func
(paren
id|fmc-&gt;mtd
comma
id|pos
)paren
)paren
(brace
r_case
id|JFFS_MAGIC_BITMASK
suffix:colon
r_if
c_cond
(paren
id|pos
op_minus
id|start
OL
id|fmc-&gt;max_chunk_size
)paren
(brace
multiline_comment|/* Not much free space. Mark it dirty. */
id|jffs_fmalloced
c_func
(paren
id|fmc
comma
(paren
id|__u32
)paren
id|start
comma
(paren
id|__u32
)paren
id|pos
op_minus
id|start
comma
l_int|0
)paren
suffix:semicolon
)brace
r_goto
id|cont_scan
suffix:semicolon
r_case
id|JFFS_EMPTY_BITMASK
suffix:colon
multiline_comment|/* More empty space */
r_continue
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* i.e. more dirt */
r_if
c_cond
(paren
id|pos
op_minus
id|start
OL
id|fmc-&gt;max_chunk_size
)paren
(brace
multiline_comment|/* There wasn&squot;t much before the dirt&n;&t;&t;&t;&t;&t;&t;&t;&t;   started again. Just mark it all dirty&n;&t;&t;&t;&t;&t;&t;&t;&t;*/
r_goto
id|cont_dirty
suffix:semicolon
)brace
multiline_comment|/* There was quite a lot of free space. Leave it&n;&t;&t;&t;&t;&t;&t;&t;   free.&n;&t;&t;&t;&t;&t;&t;&t;*/
r_goto
id|cont_scan
suffix:semicolon
)brace
)brace
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
id|cont_scan
suffix:colon
r_continue
suffix:semicolon
)brace
multiline_comment|/* We have found the beginning of an inode.  Create a&n;&t;&t;   node for it unless there already is one available.  */
r_if
c_cond
(paren
op_logical_neg
id|node
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|node
op_assign
(paren
r_struct
id|jffs_node
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs_node
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
multiline_comment|/* Free read buffer */
id|kfree
(paren
id|read_buf
)paren
suffix:semicolon
multiline_comment|/* Release the flash device */
id|flash_safe_release
c_func
(paren
id|fmc-&gt;mtd
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|DJM
c_func
(paren
id|no_jffs_node
op_increment
)paren
suffix:semicolon
)brace
multiline_comment|/* Read the next raw inode.  */
id|flash_safe_read
c_func
(paren
id|fmc-&gt;mtd
comma
id|pos
comma
(paren
id|u_char
op_star
)paren
op_amp
id|raw_inode
comma
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
)paren
suffix:semicolon
multiline_comment|/* When we compute the checksum for the inode, we never&n;&t;&t;   count the &squot;accurate&squot; or the &squot;checksum&squot; fields.  */
id|tmp_accurate
op_assign
id|raw_inode.accurate
suffix:semicolon
id|tmp_chksum
op_assign
id|raw_inode.chksum
suffix:semicolon
id|raw_inode.accurate
op_assign
l_int|0
suffix:semicolon
id|raw_inode.chksum
op_assign
l_int|0
suffix:semicolon
id|checksum
op_assign
id|jffs_checksum
c_func
(paren
op_amp
id|raw_inode
comma
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
)paren
suffix:semicolon
id|raw_inode.accurate
op_assign
id|tmp_accurate
suffix:semicolon
id|raw_inode.chksum
op_assign
id|tmp_chksum
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;*** We have found this raw inode at pos 0x%lx &quot;
l_string|&quot;on the flash:&bslash;n&quot;
comma
(paren
r_int
)paren
id|pos
)paren
)paren
suffix:semicolon
id|D3
c_func
(paren
id|jffs_print_raw_inode
c_func
(paren
op_amp
id|raw_inode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|checksum
op_ne
id|raw_inode.chksum
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_scan_flash(): Bad checksum: &quot;
l_string|&quot;checksum = %u, &quot;
l_string|&quot;raw_inode.chksum = %u&bslash;n&quot;
comma
id|checksum
comma
id|raw_inode.chksum
)paren
)paren
suffix:semicolon
id|pos
op_add_assign
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
suffix:semicolon
id|jffs_fmalloced
c_func
(paren
id|fmc
comma
(paren
id|__u32
)paren
id|start
comma
(paren
id|__u32
)paren
(paren
id|pos
op_minus
id|start
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Reuse this unused struct jffs_node.  */
r_continue
suffix:semicolon
)brace
multiline_comment|/* Check the raw inode read so far.  Start with the&n;&t;&t;   maximum length of the filename.  */
r_if
c_cond
(paren
id|raw_inode.nsize
OG
id|JFFS_MAX_NAME_LEN
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs_scan_flash: Found a &quot;
l_string|&quot;JFFS node with name too large&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|bad_inode
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raw_inode.rename
op_logical_and
id|raw_inode.dsize
op_ne
r_sizeof
(paren
id|__u32
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs_scan_flash: Found a &quot;
l_string|&quot;rename node with dsize %u.&bslash;n&quot;
comma
id|raw_inode.dsize
)paren
suffix:semicolon
id|jffs_print_raw_inode
c_func
(paren
op_amp
id|raw_inode
)paren
suffix:semicolon
r_goto
id|bad_inode
suffix:semicolon
)brace
multiline_comment|/* The node&squot;s data segment should not exceed a&n;&t;&t;   certain length.  */
r_if
c_cond
(paren
id|raw_inode.dsize
OG
id|fmc-&gt;max_chunk_size
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs_scan_flash: Found a &quot;
l_string|&quot;JFFS node with dsize (0x%x) &gt; max_chunk_size (0x%x)&bslash;n&quot;
comma
id|raw_inode.dsize
comma
id|fmc-&gt;max_chunk_size
)paren
suffix:semicolon
r_goto
id|bad_inode
suffix:semicolon
)brace
id|pos
op_add_assign
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
suffix:semicolon
multiline_comment|/* This shouldn&squot;t be necessary because a node that&n;&t;&t;   violates the flash boundaries shouldn&squot;t be written&n;&t;&t;   in the first place. */
r_if
c_cond
(paren
id|pos
op_ge
id|end
)paren
(brace
r_goto
id|check_node
suffix:semicolon
)brace
multiline_comment|/* Read the name.  */
op_star
id|name
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|raw_inode.nsize
)paren
(brace
id|flash_safe_read
c_func
(paren
id|fmc-&gt;mtd
comma
id|pos
comma
id|name
comma
id|raw_inode.nsize
)paren
suffix:semicolon
id|name
(braket
id|raw_inode.nsize
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|pos
op_add_assign
id|raw_inode.nsize
op_plus
id|JFFS_GET_PAD_BYTES
c_func
(paren
id|raw_inode.nsize
)paren
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;name == &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|name
)paren
)paren
suffix:semicolon
id|checksum
op_assign
id|jffs_checksum
c_func
(paren
id|name
comma
id|raw_inode.nsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|checksum
op_ne
id|raw_inode.nchksum
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_scan_flash(): Bad checksum: &quot;
l_string|&quot;checksum = %u, &quot;
l_string|&quot;raw_inode.nchksum = %u&bslash;n&quot;
comma
id|checksum
comma
id|raw_inode.nchksum
)paren
)paren
suffix:semicolon
id|jffs_fmalloced
c_func
(paren
id|fmc
comma
(paren
id|__u32
)paren
id|start
comma
(paren
id|__u32
)paren
(paren
id|pos
op_minus
id|start
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Reuse this unused struct jffs_node.  */
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
op_ge
id|end
)paren
(brace
r_goto
id|check_node
suffix:semicolon
)brace
)brace
multiline_comment|/* Read the data, if it exists, in order to be sure it&n;&t;&t;   matches the checksum.  */
r_if
c_cond
(paren
id|raw_inode.dsize
)paren
(brace
r_if
c_cond
(paren
id|raw_inode.rename
)paren
(brace
id|deleted_file
op_assign
id|flash_read_u32
c_func
(paren
id|fmc-&gt;mtd
comma
id|pos
)paren
suffix:semicolon
)brace
id|checksum
op_assign
id|jffs_checksum_flash
c_func
(paren
id|fmc-&gt;mtd
comma
id|pos
comma
id|raw_inode.dsize
)paren
suffix:semicolon
id|pos
op_add_assign
id|raw_inode.dsize
op_plus
id|JFFS_GET_PAD_BYTES
c_func
(paren
id|raw_inode.dsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|checksum
op_ne
id|raw_inode.dchksum
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_scan_flash(): Bad checksum: &quot;
l_string|&quot;checksum = %u, &quot;
l_string|&quot;raw_inode.dchksum = %u&bslash;n&quot;
comma
id|checksum
comma
id|raw_inode.dchksum
)paren
)paren
suffix:semicolon
id|jffs_fmalloced
c_func
(paren
id|fmc
comma
(paren
id|__u32
)paren
id|start
comma
(paren
id|__u32
)paren
(paren
id|pos
op_minus
id|start
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Reuse this unused struct jffs_node.  */
r_continue
suffix:semicolon
)brace
)brace
id|check_node
suffix:colon
multiline_comment|/* Remember the highest inode number in the whole file&n;&t;&t;   system.  This information will be used when assigning&n;&t;&t;   new files new inode numbers.  */
r_if
c_cond
(paren
id|c-&gt;next_ino
op_le
id|raw_inode.ino
)paren
(brace
id|c-&gt;next_ino
op_assign
id|raw_inode.ino
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raw_inode.accurate
)paren
(brace
r_int
id|err
suffix:semicolon
id|node-&gt;data_offset
op_assign
id|raw_inode.offset
suffix:semicolon
id|node-&gt;data_size
op_assign
id|raw_inode.dsize
suffix:semicolon
id|node-&gt;removed_size
op_assign
id|raw_inode.rsize
suffix:semicolon
multiline_comment|/* Compute the offset to the actual data in the&n;&t;&t;&t;   on-flash node.  */
id|node-&gt;fm_offset
op_assign
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
op_plus
id|raw_inode.nsize
op_plus
id|JFFS_GET_PAD_BYTES
c_func
(paren
id|raw_inode.nsize
)paren
suffix:semicolon
id|node-&gt;fm
op_assign
id|jffs_fmalloced
c_func
(paren
id|fmc
comma
(paren
id|__u32
)paren
id|start
comma
(paren
id|__u32
)paren
(paren
id|pos
op_minus
id|start
)paren
comma
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node-&gt;fm
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_scan_flash(): !node-&gt;fm&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|node
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_node
op_decrement
)paren
suffix:semicolon
multiline_comment|/* Free read buffer */
id|kfree
(paren
id|read_buf
)paren
suffix:semicolon
multiline_comment|/* Release the flash device */
id|flash_safe_release
c_func
(paren
id|fmc-&gt;mtd
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|jffs_insert_node
c_func
(paren
id|c
comma
l_int|0
comma
op_amp
id|raw_inode
comma
id|name
comma
id|node
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;JFFS: Failed to handle raw inode. &quot;
l_string|&quot;(err = %d)&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raw_inode.rename
)paren
(brace
r_struct
id|jffs_delete_list
op_star
id|dl
op_assign
(paren
r_struct
id|jffs_delete_list
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs_delete_list
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dl
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_scan_flash: !dl&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|node
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_node
op_decrement
)paren
suffix:semicolon
multiline_comment|/* Release the flash device */
id|flash_safe_release
c_func
(paren
id|fmc-&gt;flash_part
)paren
suffix:semicolon
multiline_comment|/* Free read buffer */
id|kfree
(paren
id|read_buf
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|dl-&gt;ino
op_assign
id|deleted_file
suffix:semicolon
id|dl-&gt;next
op_assign
id|c-&gt;delete_list
suffix:semicolon
id|c-&gt;delete_list
op_assign
id|dl
suffix:semicolon
id|node-&gt;data_size
op_assign
l_int|0
suffix:semicolon
)brace
id|D3
c_func
(paren
id|jffs_print_node
c_func
(paren
id|node
)paren
)paren
suffix:semicolon
id|node
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Don&squot;t free the node!  */
)brace
r_else
(brace
id|jffs_fmalloced
c_func
(paren
id|fmc
comma
(paren
id|__u32
)paren
id|start
comma
(paren
id|__u32
)paren
(paren
id|pos
op_minus
id|start
)paren
comma
l_int|0
)paren
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_scan_flash(): Just found an obsolete &quot;
l_string|&quot;raw_inode. Continuing the scan...&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Reuse this unused struct jffs_node.  */
)brace
)brace
r_if
c_cond
(paren
id|node
)paren
(brace
id|kfree
c_func
(paren
id|node
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_node
op_decrement
)paren
suffix:semicolon
)brace
id|jffs_build_end
c_func
(paren
id|fmc
)paren
suffix:semicolon
multiline_comment|/* Free read buffer */
id|kfree
(paren
id|read_buf
)paren
suffix:semicolon
multiline_comment|/* Return happy */
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_scan_flash(): Leaving...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|flash_safe_release
c_func
(paren
id|fmc-&gt;mtd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* jffs_scan_flash()  */
multiline_comment|/* Insert any kind of node into the file system.  Take care of data&n;   insertions and deletions.  Also remove redundant information. The&n;   memory allocated for the `name&squot; is regarded as &quot;given away&quot; in the&n;   caller&squot;s perspective.  */
r_int
DECL|function|jffs_insert_node
id|jffs_insert_node
c_func
(paren
r_struct
id|jffs_control
op_star
id|c
comma
r_struct
id|jffs_file
op_star
id|f
comma
r_const
r_struct
id|jffs_raw_inode
op_star
id|raw_inode
comma
r_const
r_char
op_star
id|name
comma
r_struct
id|jffs_node
op_star
id|node
)paren
(brace
r_int
id|update_name
op_assign
l_int|0
suffix:semicolon
r_int
id|insert_into_tree
op_assign
l_int|0
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_insert_node(): ino = %u, version = %u, &quot;
l_string|&quot;name = &bslash;&quot;%s&bslash;&quot;, deleted = %d&bslash;n&quot;
comma
id|raw_inode-&gt;ino
comma
id|raw_inode-&gt;version
comma
(paren
(paren
id|name
op_logical_and
op_star
id|name
)paren
ques
c_cond
id|name
suffix:colon
l_string|&quot;&quot;
)paren
comma
id|raw_inode-&gt;deleted
)paren
)paren
suffix:semicolon
multiline_comment|/* If there doesn&squot;t exist an associated jffs_file, then&n;&t;   create, initialize and insert one into the file system.  */
r_if
c_cond
(paren
op_logical_neg
id|f
op_logical_and
op_logical_neg
(paren
id|f
op_assign
id|jffs_find_file
c_func
(paren
id|c
comma
id|raw_inode-&gt;ino
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|f
op_assign
id|jffs_create_file
c_func
(paren
id|c
comma
id|raw_inode
)paren
)paren
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|jffs_insert_file_into_hash
c_func
(paren
id|f
)paren
suffix:semicolon
id|insert_into_tree
op_assign
l_int|1
suffix:semicolon
)brace
id|node-&gt;ino
op_assign
id|raw_inode-&gt;ino
suffix:semicolon
id|node-&gt;version
op_assign
id|raw_inode-&gt;version
suffix:semicolon
id|node-&gt;data_size
op_assign
id|raw_inode-&gt;dsize
suffix:semicolon
id|node-&gt;fm_offset
op_assign
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
op_plus
id|raw_inode-&gt;nsize
op_plus
id|JFFS_GET_PAD_BYTES
c_func
(paren
id|raw_inode-&gt;nsize
)paren
suffix:semicolon
id|node-&gt;name_size
op_assign
id|raw_inode-&gt;nsize
suffix:semicolon
multiline_comment|/* Now insert the node at the correct position into the file&squot;s&n;&t;   version list.  */
r_if
c_cond
(paren
op_logical_neg
id|f-&gt;version_head
)paren
(brace
multiline_comment|/* This is the first node.  */
id|f-&gt;version_head
op_assign
id|node
suffix:semicolon
id|f-&gt;version_tail
op_assign
id|node
suffix:semicolon
id|node-&gt;version_prev
op_assign
l_int|0
suffix:semicolon
id|node-&gt;version_next
op_assign
l_int|0
suffix:semicolon
id|f-&gt;highest_version
op_assign
id|node-&gt;version
suffix:semicolon
id|update_name
op_assign
l_int|1
suffix:semicolon
id|f-&gt;mode
op_assign
id|raw_inode-&gt;mode
suffix:semicolon
id|f-&gt;uid
op_assign
id|raw_inode-&gt;uid
suffix:semicolon
id|f-&gt;gid
op_assign
id|raw_inode-&gt;gid
suffix:semicolon
id|f-&gt;atime
op_assign
id|raw_inode-&gt;atime
suffix:semicolon
id|f-&gt;mtime
op_assign
id|raw_inode-&gt;mtime
suffix:semicolon
id|f-&gt;ctime
op_assign
id|raw_inode-&gt;ctime
suffix:semicolon
id|f-&gt;deleted
op_assign
id|raw_inode-&gt;deleted
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|f-&gt;highest_version
OL
id|node-&gt;version
)paren
op_logical_or
(paren
id|node-&gt;version
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* Insert at the end of the list.  I.e. this node is the&n;&t;&t;   oldest one so far.  */
id|node-&gt;version_prev
op_assign
id|f-&gt;version_tail
suffix:semicolon
id|node-&gt;version_next
op_assign
l_int|0
suffix:semicolon
id|f-&gt;version_tail-&gt;version_next
op_assign
id|node
suffix:semicolon
id|f-&gt;version_tail
op_assign
id|node
suffix:semicolon
id|f-&gt;highest_version
op_assign
id|node-&gt;version
suffix:semicolon
id|update_name
op_assign
l_int|1
suffix:semicolon
id|f-&gt;pino
op_assign
id|raw_inode-&gt;pino
suffix:semicolon
id|f-&gt;mode
op_assign
id|raw_inode-&gt;mode
suffix:semicolon
id|f-&gt;uid
op_assign
id|raw_inode-&gt;uid
suffix:semicolon
id|f-&gt;gid
op_assign
id|raw_inode-&gt;gid
suffix:semicolon
id|f-&gt;atime
op_assign
id|raw_inode-&gt;atime
suffix:semicolon
id|f-&gt;mtime
op_assign
id|raw_inode-&gt;mtime
suffix:semicolon
id|f-&gt;ctime
op_assign
id|raw_inode-&gt;ctime
suffix:semicolon
id|f-&gt;deleted
op_assign
id|raw_inode-&gt;deleted
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|f-&gt;version_head-&gt;version
OG
id|node-&gt;version
)paren
(brace
multiline_comment|/* Insert at the bottom of the list.  */
id|node-&gt;version_prev
op_assign
l_int|0
suffix:semicolon
id|node-&gt;version_next
op_assign
id|f-&gt;version_head
suffix:semicolon
id|f-&gt;version_head-&gt;version_prev
op_assign
id|node
suffix:semicolon
id|f-&gt;version_head
op_assign
id|node
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f-&gt;name
)paren
(brace
id|update_name
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raw_inode-&gt;deleted
)paren
(brace
id|f-&gt;deleted
op_assign
id|raw_inode-&gt;deleted
suffix:semicolon
)brace
)brace
r_else
(brace
r_struct
id|jffs_node
op_star
id|n
suffix:semicolon
r_int
id|newer_name
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Search for the insertion position starting from&n;&t;&t;   the tail (newest node).  */
r_for
c_loop
(paren
id|n
op_assign
id|f-&gt;version_tail
suffix:semicolon
id|n
suffix:semicolon
id|n
op_assign
id|n-&gt;version_prev
)paren
(brace
r_if
c_cond
(paren
id|n-&gt;version
OL
id|node-&gt;version
)paren
(brace
id|node-&gt;version_prev
op_assign
id|n
suffix:semicolon
id|node-&gt;version_next
op_assign
id|n-&gt;version_next
suffix:semicolon
id|node-&gt;version_next-&gt;version_prev
op_assign
id|node
suffix:semicolon
id|n-&gt;version_next
op_assign
id|node
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newer_name
)paren
(brace
id|update_name
op_assign
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n-&gt;name_size
)paren
(brace
id|newer_name
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Perhaps update the name.  */
r_if
c_cond
(paren
id|raw_inode-&gt;nsize
op_logical_and
id|update_name
op_logical_and
id|name
op_logical_and
op_star
id|name
op_logical_and
(paren
id|name
op_ne
id|f-&gt;name
)paren
)paren
(brace
r_if
c_cond
(paren
id|f-&gt;name
)paren
(brace
id|kfree
c_func
(paren
id|f-&gt;name
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_name
op_decrement
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|f-&gt;name
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|raw_inode-&gt;nsize
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|DJM
c_func
(paren
id|no_name
op_increment
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|f-&gt;name
comma
id|name
comma
id|raw_inode-&gt;nsize
)paren
suffix:semicolon
id|f-&gt;name
(braket
id|raw_inode-&gt;nsize
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|f-&gt;nsize
op_assign
id|raw_inode-&gt;nsize
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_insert_node(): Updated the name of &quot;
l_string|&quot;the file to &bslash;&quot;%s&bslash;&quot;.&bslash;n&quot;
comma
id|name
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;building_fs
)paren
(brace
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_insert_node(): ---------------------------&quot;
l_string|&quot;------------------------------------------- 1&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|insert_into_tree
)paren
(brace
id|jffs_insert_file_into_tree
c_func
(paren
id|f
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|f-&gt;deleted
)paren
(brace
multiline_comment|/* Mark all versions of the node as obsolete.  */
id|jffs_possibly_delete_file
c_func
(paren
id|f
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|node-&gt;data_size
op_logical_or
id|node-&gt;removed_size
)paren
(brace
id|jffs_update_file
c_func
(paren
id|f
comma
id|node
)paren
suffix:semicolon
)brace
id|jffs_remove_redundant_nodes
c_func
(paren
id|f
)paren
suffix:semicolon
)brace
id|jffs_garbage_collect_trigger
c_func
(paren
id|c
)paren
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_insert_node(): ---------------------------&quot;
l_string|&quot;------------------------------------------- 2&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* jffs_insert_node()  */
multiline_comment|/* Unlink a jffs_node from the version list it is in.  */
r_static
r_inline
r_void
DECL|function|jffs_unlink_node_from_version_list
id|jffs_unlink_node_from_version_list
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
comma
r_struct
id|jffs_node
op_star
id|node
)paren
(brace
r_if
c_cond
(paren
id|node-&gt;version_prev
)paren
(brace
id|node-&gt;version_prev-&gt;version_next
op_assign
id|node-&gt;version_next
suffix:semicolon
)brace
r_else
(brace
id|f-&gt;version_head
op_assign
id|node-&gt;version_next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|node-&gt;version_next
)paren
(brace
id|node-&gt;version_next-&gt;version_prev
op_assign
id|node-&gt;version_prev
suffix:semicolon
)brace
r_else
(brace
id|f-&gt;version_tail
op_assign
id|node-&gt;version_prev
suffix:semicolon
)brace
)brace
multiline_comment|/* Unlink a jffs_node from the range list it is in.  */
r_static
r_inline
r_void
DECL|function|jffs_unlink_node_from_range_list
id|jffs_unlink_node_from_range_list
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
comma
r_struct
id|jffs_node
op_star
id|node
)paren
(brace
r_if
c_cond
(paren
id|node-&gt;range_prev
)paren
(brace
id|node-&gt;range_prev-&gt;range_next
op_assign
id|node-&gt;range_next
suffix:semicolon
)brace
r_else
(brace
id|f-&gt;range_head
op_assign
id|node-&gt;range_next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|node-&gt;range_next
)paren
(brace
id|node-&gt;range_next-&gt;range_prev
op_assign
id|node-&gt;range_prev
suffix:semicolon
)brace
r_else
(brace
id|f-&gt;range_tail
op_assign
id|node-&gt;range_prev
suffix:semicolon
)brace
)brace
multiline_comment|/* Function used by jffs_remove_redundant_nodes() below.  This function&n;   classifies what kind of information a node adds to a file.  */
r_static
r_inline
id|__u8
DECL|function|jffs_classify_node
id|jffs_classify_node
c_func
(paren
r_struct
id|jffs_node
op_star
id|node
)paren
(brace
id|__u8
id|mod_type
op_assign
id|JFFS_MODIFY_INODE
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;name_size
)paren
(brace
id|mod_type
op_or_assign
id|JFFS_MODIFY_NAME
suffix:semicolon
)brace
r_if
c_cond
(paren
id|node-&gt;data_size
op_logical_or
id|node-&gt;removed_size
)paren
(brace
id|mod_type
op_or_assign
id|JFFS_MODIFY_DATA
suffix:semicolon
)brace
r_return
id|mod_type
suffix:semicolon
)brace
multiline_comment|/* Remove redundant nodes from a file.  Mark the on-flash memory&n;   as dirty.  */
r_int
DECL|function|jffs_remove_redundant_nodes
id|jffs_remove_redundant_nodes
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
)paren
(brace
r_struct
id|jffs_node
op_star
id|newest_node
suffix:semicolon
r_struct
id|jffs_node
op_star
id|cur
suffix:semicolon
r_struct
id|jffs_node
op_star
id|prev
suffix:semicolon
id|__u8
id|newest_type
suffix:semicolon
id|__u8
id|mod_type
suffix:semicolon
id|__u8
id|node_with_name_later
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|newest_node
op_assign
id|f-&gt;version_tail
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* What does the `newest_node&squot; modify?  */
id|newest_type
op_assign
id|jffs_classify_node
c_func
(paren
id|newest_node
)paren
suffix:semicolon
id|node_with_name_later
op_assign
id|newest_type
op_amp
id|JFFS_MODIFY_NAME
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_remove_redundant_nodes(): ino: %u, name: &bslash;&quot;%s&bslash;&quot;, &quot;
l_string|&quot;newest_type: %u&bslash;n&quot;
comma
id|f-&gt;ino
comma
(paren
id|f-&gt;name
ques
c_cond
id|f-&gt;name
suffix:colon
l_string|&quot;&quot;
)paren
comma
id|newest_type
)paren
)paren
suffix:semicolon
multiline_comment|/* Traverse the file&squot;s nodes and determine which of them that are&n;&t;   superfluous.  Yeah, this might look very complex at first&n;&t;   glance but it is actually very simple.  */
r_for
c_loop
(paren
id|cur
op_assign
id|newest_node-&gt;version_prev
suffix:semicolon
id|cur
suffix:semicolon
id|cur
op_assign
id|prev
)paren
(brace
id|prev
op_assign
id|cur-&gt;version_prev
suffix:semicolon
id|mod_type
op_assign
id|jffs_classify_node
c_func
(paren
id|cur
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mod_type
op_le
id|JFFS_MODIFY_INODE
)paren
op_logical_or
(paren
(paren
id|newest_type
op_amp
id|JFFS_MODIFY_NAME
)paren
op_logical_and
(paren
id|mod_type
op_le
(paren
id|JFFS_MODIFY_INODE
op_plus
id|JFFS_MODIFY_NAME
)paren
)paren
)paren
op_logical_or
(paren
id|cur-&gt;data_size
op_eq
l_int|0
op_logical_and
id|cur-&gt;removed_size
op_logical_and
op_logical_neg
id|cur-&gt;version_prev
op_logical_and
id|node_with_name_later
)paren
)paren
(brace
multiline_comment|/* Yes, this node is redundant. Remove it.  */
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_remove_redundant_nodes(): &quot;
l_string|&quot;Removing node: ino: %u, version: %u, &quot;
l_string|&quot;mod_type: %u&bslash;n&quot;
comma
id|cur-&gt;ino
comma
id|cur-&gt;version
comma
id|mod_type
)paren
)paren
suffix:semicolon
id|jffs_unlink_node_from_version_list
c_func
(paren
id|f
comma
id|cur
)paren
suffix:semicolon
id|jffs_fmfree
c_func
(paren
id|f-&gt;c-&gt;fmc
comma
id|cur-&gt;fm
comma
id|cur
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|cur
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_node
op_decrement
)paren
suffix:semicolon
)brace
r_else
(brace
id|node_with_name_later
op_or_assign
(paren
id|mod_type
op_amp
id|JFFS_MODIFY_NAME
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Insert a file into the hash table.  */
r_int
DECL|function|jffs_insert_file_into_hash
id|jffs_insert_file_into_hash
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
)paren
(brace
r_int
id|i
op_assign
id|f-&gt;ino
op_mod
id|f-&gt;c-&gt;hash_len
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_insert_file_into_hash(): f-&gt;ino: %u&bslash;n&quot;
comma
id|f-&gt;ino
)paren
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|f-&gt;hash
comma
op_amp
id|f-&gt;c-&gt;hash
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Insert a file into the file system tree.  */
r_int
DECL|function|jffs_insert_file_into_tree
id|jffs_insert_file_into_tree
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
)paren
(brace
r_struct
id|jffs_file
op_star
id|parent
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_insert_file_into_tree(): name: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
(paren
id|f-&gt;name
ques
c_cond
id|f-&gt;name
suffix:colon
l_string|&quot;&quot;
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|parent
op_assign
id|jffs_find_file
c_func
(paren
id|f-&gt;c
comma
id|f-&gt;pino
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|f-&gt;pino
op_eq
l_int|0
)paren
(brace
id|f-&gt;c-&gt;root
op_assign
id|f
suffix:semicolon
id|f-&gt;parent
op_assign
l_int|0
suffix:semicolon
id|f-&gt;sibling_prev
op_assign
l_int|0
suffix:semicolon
id|f-&gt;sibling_next
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_insert_file_into_tree(): Found &quot;
l_string|&quot;inode with no parent and pino == %u&bslash;n&quot;
comma
id|f-&gt;pino
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|f-&gt;parent
op_assign
id|parent
suffix:semicolon
id|f-&gt;sibling_next
op_assign
id|parent-&gt;children
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;sibling_next
)paren
(brace
id|f-&gt;sibling_next-&gt;sibling_prev
op_assign
id|f
suffix:semicolon
)brace
id|f-&gt;sibling_prev
op_assign
l_int|0
suffix:semicolon
id|parent-&gt;children
op_assign
id|f
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Remove a file from the hash table.  */
r_int
DECL|function|jffs_unlink_file_from_hash
id|jffs_unlink_file_from_hash
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
)paren
(brace
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_unlink_file_from_hash(): f: 0x%p, &quot;
l_string|&quot;ino %u&bslash;n&quot;
comma
id|f
comma
id|f-&gt;ino
)paren
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|f-&gt;hash
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Just remove the file from the parent&squot;s children.  Don&squot;t free&n;   any memory.  */
r_int
DECL|function|jffs_unlink_file_from_tree
id|jffs_unlink_file_from_tree
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
)paren
(brace
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_unlink_file_from_tree(): ino: %d, pino: %d, name: &quot;
l_string|&quot;&bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|f-&gt;ino
comma
id|f-&gt;pino
comma
(paren
id|f-&gt;name
ques
c_cond
id|f-&gt;name
suffix:colon
l_string|&quot;&quot;
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;sibling_prev
)paren
(brace
id|f-&gt;sibling_prev-&gt;sibling_next
op_assign
id|f-&gt;sibling_next
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|f-&gt;parent
)paren
(brace
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;f-&gt;parent=%p&bslash;n&quot;
comma
id|f-&gt;parent
)paren
)paren
suffix:semicolon
id|f-&gt;parent-&gt;children
op_assign
id|f-&gt;sibling_next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|f-&gt;sibling_next
)paren
(brace
id|f-&gt;sibling_next-&gt;sibling_prev
op_assign
id|f-&gt;sibling_prev
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Find a file with its inode number.  */
r_struct
id|jffs_file
op_star
DECL|function|jffs_find_file
id|jffs_find_file
c_func
(paren
r_struct
id|jffs_control
op_star
id|c
comma
id|__u32
id|ino
)paren
(brace
r_struct
id|jffs_file
op_star
id|f
suffix:semicolon
r_int
id|i
op_assign
id|ino
op_mod
id|c-&gt;hash_len
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_find_file(): ino: %u&bslash;n&quot;
comma
id|ino
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|c-&gt;hash
(braket
id|i
)braket
dot
id|next
suffix:semicolon
id|tmp
op_ne
op_amp
id|c-&gt;hash
(braket
id|i
)braket
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
(brace
id|f
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|jffs_file
comma
id|hash
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ino
op_ne
id|f-&gt;ino
)paren
r_continue
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_find_file(): Found file with ino &quot;
l_string|&quot;%u. (name: &bslash;&quot;%s&bslash;&quot;)&bslash;n&quot;
comma
id|ino
comma
(paren
id|f-&gt;name
ques
c_cond
id|f-&gt;name
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
)paren
suffix:semicolon
r_return
id|f
suffix:semicolon
)brace
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_find_file(): Didn&squot;t find file &quot;
l_string|&quot;with ino %u.&bslash;n&quot;
comma
id|ino
)paren
suffix:semicolon
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Find a file in a directory.  We are comparing the names.  */
r_struct
id|jffs_file
op_star
DECL|function|jffs_find_child
id|jffs_find_child
c_func
(paren
r_struct
id|jffs_file
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
r_struct
id|jffs_file
op_star
id|f
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_find_child()&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|f
op_assign
id|dir-&gt;children
suffix:semicolon
id|f
suffix:semicolon
id|f
op_assign
id|f-&gt;sibling_next
)paren
(brace
r_if
c_cond
(paren
id|f-&gt;name
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|f-&gt;name
comma
id|name
comma
id|len
)paren
op_logical_and
id|f-&gt;name
(braket
id|len
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|D3
c_func
(paren
r_if
(paren
id|f
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;jffs_find_child(): Found &bslash;&quot;%s&bslash;&quot;.&bslash;n&quot;
comma
id|f-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
r_char
op_star
id|copy
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|len
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
(paren
id|copy
)paren
(brace
id|memcpy
c_func
(paren
id|copy
comma
id|name
comma
id|len
)paren
suffix:semicolon
id|copy
(braket
id|len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;jffs_find_child(): Didn&squot;t find the file &bslash;&quot;%s&bslash;&quot;.&bslash;n&quot;
comma
(paren
id|copy
ques
c_cond
id|copy
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
r_if
(paren
id|copy
)paren
(brace
id|kfree
c_func
(paren
id|copy
)paren
suffix:semicolon
)brace
)brace
)paren
suffix:semicolon
r_return
id|f
suffix:semicolon
)brace
multiline_comment|/* Write a raw inode that takes up a certain amount of space in the flash&n;   memory.  At the end of the flash device, there is often space that is&n;   impossible to use.  At these times we want to mark this space as not&n;   used.  In the cases when the amount of space is greater or equal than&n;   a struct jffs_raw_inode, we write a &quot;dummy node&quot; that takes up this&n;   space.  The space after the raw inode, if it exists, is left as it is.&n;   Since this space after the raw inode contains JFFS_EMPTY_BITMASK bytes,&n;   we can compute the checksum of it; we don&squot;t have to manipulate it any&n;   further.&n;&n;   If the space left on the device is less than the size of a struct&n;   jffs_raw_inode, this space is filled with JFFS_DIRTY_BITMASK bytes.&n;   No raw inode is written this time.  */
r_static
r_int
DECL|function|jffs_write_dummy_node
id|jffs_write_dummy_node
c_func
(paren
r_struct
id|jffs_control
op_star
id|c
comma
r_struct
id|jffs_fm
op_star
id|dirty_fm
)paren
(brace
r_struct
id|jffs_fmcontrol
op_star
id|fmc
op_assign
id|c-&gt;fmc
suffix:semicolon
r_int
id|err
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_write_dummy_node(): dirty_fm-&gt;offset = 0x%08x, &quot;
l_string|&quot;dirty_fm-&gt;size = %u&bslash;n&quot;
comma
id|dirty_fm-&gt;offset
comma
id|dirty_fm-&gt;size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dirty_fm-&gt;size
op_ge
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
)paren
(brace
r_struct
id|jffs_raw_inode
id|raw_inode
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|raw_inode
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
)paren
suffix:semicolon
id|raw_inode.magic
op_assign
id|JFFS_MAGIC_BITMASK
suffix:semicolon
id|raw_inode.dsize
op_assign
id|dirty_fm-&gt;size
op_minus
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
suffix:semicolon
id|raw_inode.dchksum
op_assign
id|raw_inode.dsize
op_star
l_int|0xff
suffix:semicolon
id|raw_inode.chksum
op_assign
id|jffs_checksum
c_func
(paren
op_amp
id|raw_inode
comma
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|flash_safe_write
c_func
(paren
id|fmc-&gt;mtd
comma
id|dirty_fm-&gt;offset
comma
(paren
id|u_char
op_star
)paren
op_amp
id|raw_inode
comma
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;JFFS: jffs_write_dummy_node: &quot;
l_string|&quot;flash_safe_write failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
r_else
(brace
id|flash_safe_acquire
c_func
(paren
id|fmc-&gt;mtd
)paren
suffix:semicolon
id|flash_memset
c_func
(paren
id|fmc-&gt;mtd
comma
id|dirty_fm-&gt;offset
comma
l_int|0
comma
id|dirty_fm-&gt;size
)paren
suffix:semicolon
id|flash_safe_release
c_func
(paren
id|fmc-&gt;mtd
)paren
suffix:semicolon
)brace
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_write_dummy_node(): Leaving...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Write a raw inode, possibly its name and possibly some data.  */
r_int
DECL|function|jffs_write_node
id|jffs_write_node
c_func
(paren
r_struct
id|jffs_control
op_star
id|c
comma
r_struct
id|jffs_node
op_star
id|node
comma
r_struct
id|jffs_raw_inode
op_star
id|raw_inode
comma
r_const
r_char
op_star
id|name
comma
r_const
r_int
r_char
op_star
id|data
comma
r_int
id|recoverable
comma
r_struct
id|jffs_file
op_star
id|f
)paren
(brace
r_struct
id|jffs_fmcontrol
op_star
id|fmc
op_assign
id|c-&gt;fmc
suffix:semicolon
r_struct
id|jffs_fm
op_star
id|fm
op_assign
l_int|NULL
suffix:semicolon
id|__u32
id|pos
suffix:semicolon
r_int
id|err
suffix:semicolon
id|__u32
id|slack
op_assign
l_int|0
suffix:semicolon
id|__u32
id|total_name_size
op_assign
id|raw_inode-&gt;nsize
op_plus
id|JFFS_GET_PAD_BYTES
c_func
(paren
id|raw_inode-&gt;nsize
)paren
suffix:semicolon
id|__u32
id|total_data_size
op_assign
id|raw_inode-&gt;dsize
op_plus
id|JFFS_GET_PAD_BYTES
c_func
(paren
id|raw_inode-&gt;dsize
)paren
suffix:semicolon
id|__u32
id|total_size
op_assign
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
op_plus
id|total_name_size
op_plus
id|total_data_size
suffix:semicolon
multiline_comment|/* If this node isn&squot;t something that will eventually let&n;&t;   GC free even more space, then don&squot;t allow it unless&n;&t;   there&squot;s at least max_chunk_size space still available&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|recoverable
)paren
id|slack
op_assign
id|fmc-&gt;max_chunk_size
suffix:semicolon
multiline_comment|/* Fire the retrorockets and shoot the fruiton torpedoes, sir!  */
id|ASSERT
c_func
(paren
r_if
(paren
op_logical_neg
id|node
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;jffs_write_node(): node == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
r_if
(paren
id|raw_inode
op_logical_and
id|raw_inode-&gt;nsize
op_logical_and
op_logical_neg
id|name
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;*** jffs_write_node(): nsize = %u but name == NULL&bslash;n&quot;
comma
id|raw_inode-&gt;nsize
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_write_node(): filename = &bslash;&quot;%s&bslash;&quot;, ino = %u, &quot;
l_string|&quot;total_size = %u&bslash;n&quot;
comma
(paren
id|name
ques
c_cond
id|name
suffix:colon
l_string|&quot;&quot;
)paren
comma
id|raw_inode-&gt;ino
comma
id|total_size
)paren
)paren
suffix:semicolon
id|jffs_fm_write_lock
c_func
(paren
id|fmc
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|fm
)paren
(brace
multiline_comment|/* Deadlocks suck. */
r_while
c_loop
(paren
id|fmc-&gt;free_size
OL
id|fmc-&gt;min_free_size
op_plus
id|total_size
op_plus
id|slack
)paren
(brace
id|jffs_fm_write_unlock
c_func
(paren
id|fmc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|JFFS_ENOUGH_SPACE
c_func
(paren
id|c
comma
id|total_size
op_plus
id|slack
)paren
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
id|jffs_fm_write_lock
c_func
(paren
id|fmc
)paren
suffix:semicolon
)brace
multiline_comment|/* First try to allocate some flash memory.  */
id|err
op_assign
id|jffs_fmalloc
c_func
(paren
id|fmc
comma
id|total_size
comma
id|node
comma
op_amp
id|fm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|ENOSPC
)paren
(brace
multiline_comment|/* Just out of space. GC and try again */
r_if
c_cond
(paren
id|fmc-&gt;dirty_size
OL
id|fmc-&gt;sector_size
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_write_node(): jffs_fmalloc(0x%p, %u) &quot;
l_string|&quot;failed, no dirty space to GC&bslash;n&quot;
comma
id|fmc
comma
id|total_size
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;jffs_write_node(): Calling jffs_garbage_collect_now()&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|jffs_fm_write_unlock
c_func
(paren
id|fmc
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|jffs_garbage_collect_now
c_func
(paren
id|c
)paren
)paren
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_write_node(): jffs_garbage_collect_now() failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|jffs_fm_write_lock
c_func
(paren
id|fmc
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
(brace
id|jffs_fm_write_unlock
c_func
(paren
id|fmc
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_write_node(): jffs_fmalloc(0x%p, %u) &quot;
l_string|&quot;failed!&bslash;n&quot;
comma
id|fmc
comma
id|total_size
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|fm-&gt;nodes
)paren
(brace
multiline_comment|/* The jffs_fm struct that we got is not good enough.&n;&t;&t;&t;   Make that space dirty and try again  */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|jffs_write_dummy_node
c_func
(paren
id|c
comma
id|fm
)paren
)paren
OL
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|fm
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_fm
op_decrement
)paren
suffix:semicolon
id|jffs_fm_write_unlock
c_func
(paren
id|fmc
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_write_node(): &quot;
l_string|&quot;jffs_write_dummy_node(): Failed!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|fm
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* while(!fm) */
id|node-&gt;fm
op_assign
id|fm
suffix:semicolon
id|ASSERT
c_func
(paren
r_if
(paren
id|fm-&gt;nodes
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;jffs_write_node(): fm-&gt;nodes == 0&bslash;n&quot;
)paren
suffix:semicolon
)brace
)paren
suffix:semicolon
id|pos
op_assign
id|node-&gt;fm-&gt;offset
suffix:semicolon
multiline_comment|/* Increment the version number here. We can&squot;t let the caller&n;&t;   set it beforehand, because we might have had to do GC on a node&n;&t;   of this file - and we&squot;d end up reusing version numbers.&n;&t;*/
r_if
c_cond
(paren
id|f
)paren
(brace
id|raw_inode-&gt;version
op_assign
id|f-&gt;highest_version
op_plus
l_int|1
suffix:semicolon
id|D1
c_func
(paren
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;jffs_write_node(): setting version of %s to %d&bslash;n&quot;
comma
id|f-&gt;name
comma
id|raw_inode-&gt;version
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Compute the checksum for the data and name chunks.  */
id|raw_inode-&gt;dchksum
op_assign
id|jffs_checksum
c_func
(paren
id|data
comma
id|raw_inode-&gt;dsize
)paren
suffix:semicolon
id|raw_inode-&gt;nchksum
op_assign
id|jffs_checksum
c_func
(paren
id|name
comma
id|raw_inode-&gt;nsize
)paren
suffix:semicolon
multiline_comment|/* The checksum is calculated without the chksum and accurate&n;&t;   fields so set them to zero first.  */
id|raw_inode-&gt;accurate
op_assign
l_int|0
suffix:semicolon
id|raw_inode-&gt;chksum
op_assign
l_int|0
suffix:semicolon
id|raw_inode-&gt;chksum
op_assign
id|jffs_checksum
c_func
(paren
id|raw_inode
comma
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
)paren
suffix:semicolon
id|raw_inode-&gt;accurate
op_assign
l_int|0xff
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_write_node(): About to write this raw inode to the &quot;
l_string|&quot;flash at pos 0x%lx:&bslash;n&quot;
comma
(paren
r_int
)paren
id|pos
)paren
)paren
suffix:semicolon
id|D3
c_func
(paren
id|jffs_print_raw_inode
c_func
(paren
id|raw_inode
)paren
)paren
suffix:semicolon
multiline_comment|/* Step 1: Write the raw jffs inode to the flash.  */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|flash_safe_write
c_func
(paren
id|fmc-&gt;mtd
comma
id|pos
comma
(paren
id|u_char
op_star
)paren
id|raw_inode
comma
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
)paren
)paren
OL
l_int|0
)paren
(brace
id|jffs_fmfree_partly
c_func
(paren
id|fmc
comma
id|fm
comma
id|total_name_size
op_plus
id|total_data_size
)paren
suffix:semicolon
id|jffs_fm_write_unlock
c_func
(paren
id|fmc
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;JFFS: jffs_write_node: Failed to write &quot;
l_string|&quot;raw_inode.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|pos
op_add_assign
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
suffix:semicolon
multiline_comment|/* Step 2: Write the name, if there is any.  */
r_if
c_cond
(paren
id|raw_inode-&gt;nsize
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|flash_safe_write
c_func
(paren
id|fmc-&gt;mtd
comma
id|pos
comma
(paren
id|u_char
op_star
)paren
id|name
comma
id|raw_inode-&gt;nsize
)paren
)paren
OL
l_int|0
)paren
(brace
id|jffs_fmfree_partly
c_func
(paren
id|fmc
comma
id|fm
comma
id|total_data_size
)paren
suffix:semicolon
id|jffs_fm_write_unlock
c_func
(paren
id|fmc
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;JFFS: jffs_write_node: Failed to &quot;
l_string|&quot;write the name.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|pos
op_add_assign
id|total_name_size
suffix:semicolon
)brace
multiline_comment|/* Step 3: Append the actual data, if any.  */
r_if
c_cond
(paren
id|raw_inode-&gt;dsize
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|flash_safe_write
c_func
(paren
id|fmc-&gt;mtd
comma
id|pos
comma
id|data
comma
id|raw_inode-&gt;dsize
)paren
)paren
OL
l_int|0
)paren
(brace
id|jffs_fmfree_partly
c_func
(paren
id|fmc
comma
id|fm
comma
l_int|0
)paren
suffix:semicolon
id|jffs_fm_write_unlock
c_func
(paren
id|fmc
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;JFFS: jffs_write_node: Failed to &quot;
l_string|&quot;write the data.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
)brace
id|jffs_fm_write_unlock
c_func
(paren
id|fmc
)paren
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_write_node(): Leaving...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|raw_inode-&gt;dsize
suffix:semicolon
)brace
multiline_comment|/* jffs_write_node()  */
multiline_comment|/* Read data from the node and write it to the buffer.  &squot;node_offset&squot;&n;   is how much we have read from this particular node before and which&n;   shouldn&squot;t be read again.  &squot;max_size&squot; is how much space there is in&n;   the buffer.  */
r_static
r_int
DECL|function|jffs_get_node_data
id|jffs_get_node_data
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
comma
r_struct
id|jffs_node
op_star
id|node
comma
r_int
r_char
op_star
id|buf
comma
id|__u32
id|node_offset
comma
id|__u32
id|max_size
comma
id|kdev_t
id|dev
)paren
(brace
r_struct
id|jffs_fmcontrol
op_star
id|fmc
op_assign
id|f-&gt;c-&gt;fmc
suffix:semicolon
id|__u32
id|pos
op_assign
id|node-&gt;fm-&gt;offset
op_plus
id|node-&gt;fm_offset
op_plus
id|node_offset
suffix:semicolon
id|__u32
id|avail
op_assign
id|node-&gt;data_size
op_minus
id|node_offset
suffix:semicolon
id|__u32
id|r
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  jffs_get_node_data(): file: &bslash;&quot;%s&bslash;&quot;, ino: %u, &quot;
l_string|&quot;version: %u, node_offset: %u&bslash;n&quot;
comma
id|f-&gt;name
comma
id|node-&gt;ino
comma
id|node-&gt;version
comma
id|node_offset
)paren
)paren
suffix:semicolon
id|r
op_assign
id|jffs_min
c_func
(paren
id|avail
comma
id|max_size
)paren
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;jffs_get_node_data&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|flash_safe_read
c_func
(paren
id|fmc-&gt;mtd
comma
id|pos
comma
id|buf
comma
id|r
)paren
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  jffs_get_node_data(): Read %u byte%s.&bslash;n&quot;
comma
id|r
comma
(paren
id|r
op_eq
l_int|1
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
)paren
)paren
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/* Read data from the file&squot;s nodes.  Write the data to the buffer&n;   &squot;buf&squot;.  &squot;read_offset&squot; tells how much data we should skip.  */
r_int
DECL|function|jffs_read_data
id|jffs_read_data
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
comma
r_int
r_char
op_star
id|buf
comma
id|__u32
id|read_offset
comma
id|__u32
id|size
)paren
(brace
r_struct
id|jffs_node
op_star
id|node
suffix:semicolon
id|__u32
id|read_data
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Total amount of read data.  */
id|__u32
id|node_offset
op_assign
l_int|0
suffix:semicolon
id|__u32
id|pos
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Number of bytes traversed.  */
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_read_data(): file = &bslash;&quot;%s&bslash;&quot;, read_offset = %d, &quot;
l_string|&quot;size = %u&bslash;n&quot;
comma
(paren
id|f-&gt;name
ques
c_cond
id|f-&gt;name
suffix:colon
l_string|&quot;&quot;
)paren
comma
id|read_offset
comma
id|size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_offset
op_ge
id|f-&gt;size
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  f-&gt;size: %d&bslash;n&quot;
comma
id|f-&gt;size
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* First find the node to read data from.  */
id|node
op_assign
id|f-&gt;range_head
suffix:semicolon
r_while
c_loop
(paren
id|pos
op_le
id|read_offset
)paren
(brace
id|node_offset
op_assign
id|read_offset
op_minus
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|node_offset
op_ge
id|node-&gt;data_size
)paren
(brace
id|pos
op_add_assign
id|node-&gt;data_size
suffix:semicolon
id|node
op_assign
id|node-&gt;range_next
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* &quot;Cats are living proof that not everything in nature&n;&t;   has to be useful.&quot;&n;&t;   - Garrison Keilor (&squot;97)  */
multiline_comment|/* Fill the buffer.  */
r_while
c_loop
(paren
id|node
op_logical_and
(paren
id|read_data
OL
id|size
)paren
)paren
(brace
r_int
id|r
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node-&gt;fm
)paren
(brace
multiline_comment|/* This node does not refer to real data.  */
id|r
op_assign
id|jffs_min
c_func
(paren
id|size
op_minus
id|read_data
comma
id|node-&gt;data_size
op_minus
id|node_offset
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|buf
(braket
id|read_data
)braket
comma
l_int|0
comma
id|r
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|r
op_assign
id|jffs_get_node_data
c_func
(paren
id|f
comma
id|node
comma
op_amp
id|buf
(braket
id|read_data
)braket
comma
id|node_offset
comma
id|size
op_minus
id|read_data
comma
id|f-&gt;c-&gt;sb-&gt;s_dev
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
id|r
suffix:semicolon
)brace
id|read_data
op_add_assign
id|r
suffix:semicolon
id|node_offset
op_assign
l_int|0
suffix:semicolon
id|node
op_assign
id|node-&gt;range_next
suffix:semicolon
)brace
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  jffs_read_data(): Read %u bytes.&bslash;n&quot;
comma
id|read_data
)paren
)paren
suffix:semicolon
r_return
id|read_data
suffix:semicolon
)brace
multiline_comment|/* Used for traversing all nodes in the hash table.  */
r_int
DECL|function|jffs_foreach_file
id|jffs_foreach_file
c_func
(paren
r_struct
id|jffs_control
op_star
id|c
comma
r_int
(paren
op_star
id|func
)paren
(paren
r_struct
id|jffs_file
op_star
)paren
)paren
(brace
r_int
id|pos
suffix:semicolon
r_int
id|r
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|pos
op_assign
l_int|0
suffix:semicolon
id|pos
OL
id|c-&gt;hash_len
suffix:semicolon
id|pos
op_increment
)paren
(brace
r_struct
id|list_head
op_star
id|p
comma
op_star
id|next
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|c-&gt;hash
(braket
id|pos
)braket
dot
id|next
suffix:semicolon
id|p
op_ne
op_amp
id|c-&gt;hash
(braket
id|pos
)braket
suffix:semicolon
id|p
op_assign
id|next
)paren
(brace
multiline_comment|/* We need a reference to the next file in the&n;&t;&t;&t;   list because `func&squot; might remove the current&n;&t;&t;&t;   file `f&squot;.  */
id|next
op_assign
id|p-&gt;next
suffix:semicolon
id|r
op_assign
id|func
c_func
(paren
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|jffs_file
comma
id|hash
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
r_return
id|r
suffix:semicolon
id|result
op_add_assign
id|r
suffix:semicolon
)brace
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* Free all nodes associated with a file.  */
r_int
DECL|function|jffs_free_node_list
id|jffs_free_node_list
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
)paren
(brace
r_struct
id|jffs_node
op_star
id|node
suffix:semicolon
r_struct
id|jffs_node
op_star
id|p
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_free_node_list(): f #%u, &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|f-&gt;ino
comma
(paren
id|f-&gt;name
ques
c_cond
id|f-&gt;name
suffix:colon
l_string|&quot;&quot;
)paren
)paren
)paren
suffix:semicolon
id|node
op_assign
id|f-&gt;version_head
suffix:semicolon
r_while
c_loop
(paren
id|node
)paren
(brace
id|p
op_assign
id|node
suffix:semicolon
id|node
op_assign
id|node-&gt;version_next
suffix:semicolon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_node
op_decrement
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Free a file and its name.  */
r_int
DECL|function|jffs_free_file
id|jffs_free_file
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
)paren
(brace
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_free_file: f #%u, &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|f-&gt;ino
comma
(paren
id|f-&gt;name
ques
c_cond
id|f-&gt;name
suffix:colon
l_string|&quot;&quot;
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;name
)paren
(brace
id|kfree
c_func
(paren
id|f-&gt;name
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_name
op_decrement
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|f
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_file
op_decrement
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* See if a file is deleted. If so, mark that file&squot;s nodes as obsolete.  */
r_int
DECL|function|jffs_possibly_delete_file
id|jffs_possibly_delete_file
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
)paren
(brace
r_struct
id|jffs_node
op_star
id|n
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_possibly_delete_file(): ino: %u&bslash;n&quot;
comma
id|f-&gt;ino
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
r_if
(paren
op_logical_neg
id|f
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;jffs_possibly_delete_file(): f == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)paren
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;deleted
)paren
(brace
multiline_comment|/* First try to remove all older versions.  Commence with&n;&t;&t;   the oldest node.  */
r_for
c_loop
(paren
id|n
op_assign
id|f-&gt;version_head
suffix:semicolon
id|n
suffix:semicolon
id|n
op_assign
id|n-&gt;version_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|n-&gt;fm
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|jffs_fmfree
c_func
(paren
id|f-&gt;c-&gt;fmc
comma
id|n-&gt;fm
comma
id|n
)paren
OL
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Unlink the file from the filesystem.  */
r_if
c_cond
(paren
op_logical_neg
id|f-&gt;c-&gt;building_fs
)paren
(brace
id|jffs_unlink_file_from_tree
c_func
(paren
id|f
)paren
suffix:semicolon
)brace
id|jffs_unlink_file_from_hash
c_func
(paren
id|f
)paren
suffix:semicolon
id|jffs_free_node_list
c_func
(paren
id|f
)paren
suffix:semicolon
id|jffs_free_file
c_func
(paren
id|f
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Used in conjunction with jffs_foreach_file() to count the number&n;   of files in the file system.  */
r_int
DECL|function|jffs_file_count
id|jffs_file_count
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Build up a file&squot;s range list from scratch by going through the&n;   version list.  */
r_int
DECL|function|jffs_build_file
id|jffs_build_file
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
)paren
(brace
r_struct
id|jffs_node
op_star
id|n
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_build_file(): ino: %u, name: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|f-&gt;ino
comma
(paren
id|f-&gt;name
ques
c_cond
id|f-&gt;name
suffix:colon
l_string|&quot;&quot;
)paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|f-&gt;version_head
suffix:semicolon
id|n
suffix:semicolon
id|n
op_assign
id|n-&gt;version_next
)paren
(brace
id|jffs_update_file
c_func
(paren
id|f
comma
id|n
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Remove an amount of data from a file. If this amount of data is&n;   zero, that could mean that a node should be split in two parts.&n;   We remove or change the appropriate nodes in the lists.&n;&n;   Starting offset of area to be removed is node-&gt;data_offset,&n;   and the length of the area is in node-&gt;removed_size.   */
r_static
r_int
DECL|function|jffs_delete_data
id|jffs_delete_data
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
comma
r_struct
id|jffs_node
op_star
id|node
)paren
(brace
r_struct
id|jffs_node
op_star
id|n
suffix:semicolon
id|__u32
id|offset
op_assign
id|node-&gt;data_offset
suffix:semicolon
id|__u32
id|remove_size
op_assign
id|node-&gt;removed_size
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_delete_data(): offset = %u, remove_size = %u&bslash;n&quot;
comma
id|offset
comma
id|remove_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remove_size
op_eq
l_int|0
op_logical_and
id|f-&gt;range_tail
op_logical_and
id|f-&gt;range_tail-&gt;data_offset
op_plus
id|f-&gt;range_tail-&gt;data_size
op_eq
id|offset
)paren
(brace
multiline_comment|/* A simple append; nothing to remove or no node to split.  */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Find the node where we should begin the removal.  */
r_for
c_loop
(paren
id|n
op_assign
id|f-&gt;range_head
suffix:semicolon
id|n
suffix:semicolon
id|n
op_assign
id|n-&gt;range_next
)paren
(brace
r_if
c_cond
(paren
id|n-&gt;data_offset
op_plus
id|n-&gt;data_size
OG
id|offset
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
(brace
multiline_comment|/* If there&squot;s no data in the file there&squot;s no data to&n;&t;&t;   remove either.  */
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n-&gt;data_offset
OG
id|offset
)paren
(brace
multiline_comment|/* XXX: Not implemented yet.  */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;JFFS: An unexpected situation &quot;
l_string|&quot;occurred in jffs_delete_data.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|n-&gt;data_offset
OL
id|offset
)paren
(brace
multiline_comment|/* See if the node has to be split into two parts.  */
r_if
c_cond
(paren
id|n-&gt;data_offset
op_plus
id|n-&gt;data_size
OG
id|offset
op_plus
id|remove_size
)paren
(brace
multiline_comment|/* Do the split.  */
r_struct
id|jffs_node
op_star
id|new_node
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_delete_data(): Split node with &quot;
l_string|&quot;version number %u.&bslash;n&quot;
comma
id|n-&gt;version
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|new_node
op_assign
(paren
r_struct
id|jffs_node
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs_node
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_delete_data(): -ENOMEM&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|DJM
c_func
(paren
id|no_jffs_node
op_increment
)paren
suffix:semicolon
id|new_node-&gt;ino
op_assign
id|n-&gt;ino
suffix:semicolon
id|new_node-&gt;version
op_assign
id|n-&gt;version
suffix:semicolon
id|new_node-&gt;data_offset
op_assign
id|offset
suffix:semicolon
id|new_node-&gt;data_size
op_assign
id|n-&gt;data_size
op_minus
(paren
id|remove_size
op_plus
(paren
id|offset
op_minus
id|n-&gt;data_offset
)paren
)paren
suffix:semicolon
id|new_node-&gt;fm_offset
op_assign
id|n-&gt;fm_offset
op_plus
(paren
id|remove_size
op_plus
(paren
id|offset
op_minus
id|n-&gt;data_offset
)paren
)paren
suffix:semicolon
id|new_node-&gt;name_size
op_assign
id|n-&gt;name_size
suffix:semicolon
id|new_node-&gt;fm
op_assign
id|n-&gt;fm
suffix:semicolon
id|new_node-&gt;version_prev
op_assign
id|n
suffix:semicolon
id|new_node-&gt;version_next
op_assign
id|n-&gt;version_next
suffix:semicolon
r_if
c_cond
(paren
id|new_node-&gt;version_next
)paren
(brace
id|new_node-&gt;version_next-&gt;version_prev
op_assign
id|new_node
suffix:semicolon
)brace
r_else
(brace
id|f-&gt;version_tail
op_assign
id|new_node
suffix:semicolon
)brace
id|n-&gt;version_next
op_assign
id|new_node
suffix:semicolon
id|new_node-&gt;range_prev
op_assign
id|n
suffix:semicolon
id|new_node-&gt;range_next
op_assign
id|n-&gt;range_next
suffix:semicolon
r_if
c_cond
(paren
id|new_node-&gt;range_next
)paren
(brace
id|new_node-&gt;range_next-&gt;range_prev
op_assign
id|new_node
suffix:semicolon
)brace
r_else
(brace
id|f-&gt;range_tail
op_assign
id|new_node
suffix:semicolon
)brace
multiline_comment|/* A very interesting can of worms.  */
id|n-&gt;range_next
op_assign
id|new_node
suffix:semicolon
id|n-&gt;data_size
op_assign
id|offset
op_minus
id|n-&gt;data_offset
suffix:semicolon
r_if
c_cond
(paren
id|new_node-&gt;fm
)paren
id|jffs_add_node
c_func
(paren
id|new_node
)paren
suffix:semicolon
r_else
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs_delete_data(): Splitting an empty node (file hold).&bslash;n!&quot;
)paren
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;FIXME: Did dwmw2 do the right thing here?&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
id|n
op_assign
id|new_node-&gt;range_next
suffix:semicolon
id|remove_size
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No.  No need to split the node.  Just remove&n;&t;&t;&t;   the end of the node.  */
r_int
id|r
op_assign
id|jffs_min
c_func
(paren
id|n-&gt;data_offset
op_plus
id|n-&gt;data_size
op_minus
id|offset
comma
id|remove_size
)paren
suffix:semicolon
id|n-&gt;data_size
op_sub_assign
id|r
suffix:semicolon
id|remove_size
op_sub_assign
id|r
suffix:semicolon
id|n
op_assign
id|n-&gt;range_next
suffix:semicolon
)brace
)brace
multiline_comment|/* Remove as many nodes as necessary.  */
r_while
c_loop
(paren
id|n
op_logical_and
id|remove_size
)paren
(brace
r_if
c_cond
(paren
id|n-&gt;data_size
op_le
id|remove_size
)paren
(brace
r_struct
id|jffs_node
op_star
id|p
op_assign
id|n
suffix:semicolon
id|remove_size
op_sub_assign
id|n-&gt;data_size
suffix:semicolon
id|n
op_assign
id|n-&gt;range_next
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_delete_data(): Removing node: &quot;
l_string|&quot;ino: %u, version: %u%s&bslash;n&quot;
comma
id|p-&gt;ino
comma
id|p-&gt;version
comma
(paren
id|p-&gt;fm
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; (virtual)&quot;
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;fm
)paren
(brace
id|jffs_fmfree
c_func
(paren
id|f-&gt;c-&gt;fmc
comma
id|p-&gt;fm
comma
id|p
)paren
suffix:semicolon
)brace
id|jffs_unlink_node_from_range_list
c_func
(paren
id|f
comma
id|p
)paren
suffix:semicolon
id|jffs_unlink_node_from_version_list
c_func
(paren
id|f
comma
id|p
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_node
op_decrement
)paren
suffix:semicolon
)brace
r_else
(brace
id|n-&gt;data_size
op_sub_assign
id|remove_size
suffix:semicolon
id|n-&gt;fm_offset
op_add_assign
id|remove_size
suffix:semicolon
id|n-&gt;data_offset
op_sub_assign
(paren
id|node-&gt;removed_size
op_minus
id|remove_size
)paren
suffix:semicolon
id|n
op_assign
id|n-&gt;range_next
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Adjust the following nodes&squot; information about offsets etc.  */
r_while
c_loop
(paren
id|n
op_logical_and
id|node-&gt;removed_size
)paren
(brace
id|n-&gt;data_offset
op_sub_assign
id|node-&gt;removed_size
suffix:semicolon
id|n
op_assign
id|n-&gt;range_next
suffix:semicolon
)brace
r_if
c_cond
(paren
id|node-&gt;removed_size
OG
(paren
id|f-&gt;size
op_minus
id|node-&gt;data_offset
)paren
)paren
(brace
multiline_comment|/* It&squot;s possible that the removed_size is in fact&n;&t;&t; * greater than the amount of data we actually thought&n;&t;&t; * were present in the first place - some of the nodes &n;&t;&t; * which this node originally obsoleted may already have&n;&t;&t; * been deleted from the flash by subsequent garbage &n;&t;&t; * collection.&n;&t;&t; *&n;&t;&t; * If this is the case, don&squot;t let f-&gt;size go negative.&n;&t;&t; * Bad things would happen :)&n;&t;&t; */
id|f-&gt;size
op_assign
id|node-&gt;data_offset
suffix:semicolon
)brace
r_else
(brace
id|f-&gt;size
op_sub_assign
id|node-&gt;removed_size
suffix:semicolon
)brace
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_delete_data(): f-&gt;size = %d&bslash;n&quot;
comma
id|f-&gt;size
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* jffs_delete_data()  */
multiline_comment|/* Insert some data into a file.  Prior to the call to this function,&n;   jffs_delete_data should be called.  */
r_static
r_int
DECL|function|jffs_insert_data
id|jffs_insert_data
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
comma
r_struct
id|jffs_node
op_star
id|node
)paren
(brace
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_insert_data(): node-&gt;data_offset = %u, &quot;
l_string|&quot;node-&gt;data_size = %u, f-&gt;size = %u&bslash;n&quot;
comma
id|node-&gt;data_offset
comma
id|node-&gt;data_size
comma
id|f-&gt;size
)paren
)paren
suffix:semicolon
multiline_comment|/* Find the position where we should insert data.  */
id|retry
suffix:colon
r_if
c_cond
(paren
id|node-&gt;data_offset
op_eq
id|f-&gt;size
)paren
(brace
multiline_comment|/* A simple append.  This is the most common operation.  */
id|node-&gt;range_next
op_assign
l_int|0
suffix:semicolon
id|node-&gt;range_prev
op_assign
id|f-&gt;range_tail
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;range_prev
)paren
(brace
id|node-&gt;range_prev-&gt;range_next
op_assign
id|node
suffix:semicolon
)brace
id|f-&gt;range_tail
op_assign
id|node
suffix:semicolon
id|f-&gt;size
op_add_assign
id|node-&gt;data_size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f-&gt;range_head
)paren
(brace
id|f-&gt;range_head
op_assign
id|node
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|node-&gt;data_offset
OL
id|f-&gt;size
)paren
(brace
multiline_comment|/* Trying to insert data into the middle of the file.  This&n;&t;&t;   means no problem because jffs_delete_data() has already&n;&t;&t;   prepared the range list for us.  */
r_struct
id|jffs_node
op_star
id|n
suffix:semicolon
multiline_comment|/* Find the correct place for the insertion and then insert&n;&t;&t;   the node.  */
r_for
c_loop
(paren
id|n
op_assign
id|f-&gt;range_head
suffix:semicolon
id|n
suffix:semicolon
id|n
op_assign
id|n-&gt;range_next
)paren
(brace
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;Cool stuff&squot;s happening!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n-&gt;data_offset
op_eq
id|node-&gt;data_offset
)paren
(brace
id|node-&gt;range_prev
op_assign
id|n-&gt;range_prev
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;range_prev
)paren
(brace
id|node-&gt;range_prev-&gt;range_next
op_assign
id|node
suffix:semicolon
)brace
r_else
(brace
id|f-&gt;range_head
op_assign
id|node
suffix:semicolon
)brace
id|node-&gt;range_next
op_assign
id|n
suffix:semicolon
id|n-&gt;range_prev
op_assign
id|node
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
r_else
r_if
(paren
id|n-&gt;data_offset
op_plus
id|n-&gt;data_size
OG
id|node-&gt;data_offset
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;jffs_insert_data(): &quot;
l_string|&quot;Couldn&squot;t find a place to insert &quot;
l_string|&quot;the data!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)paren
suffix:semicolon
)brace
multiline_comment|/* Adjust later nodes&squot; offsets etc.  */
id|n
op_assign
id|node-&gt;range_next
suffix:semicolon
r_while
c_loop
(paren
id|n
)paren
(brace
id|n-&gt;data_offset
op_add_assign
id|node-&gt;data_size
suffix:semicolon
id|n
op_assign
id|n-&gt;range_next
suffix:semicolon
)brace
id|f-&gt;size
op_add_assign
id|node-&gt;data_size
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|node-&gt;data_offset
OG
id|f-&gt;size
)paren
(brace
multiline_comment|/* Okay.  This is tricky.  This means that we want to insert&n;&t;&t;   data at a place that is beyond the limits of the file as&n;&t;&t;   it is constructed right now.  This is actually a common&n;&t;&t;   event that for instance could occur during the mounting&n;&t;&t;   of the file system if a large file have been truncated,&n;&t;&t;   rewritten and then only partially garbage collected.  */
r_struct
id|jffs_node
op_star
id|n
suffix:semicolon
multiline_comment|/* We need a place holder for the data that is missing in&n;&t;&t;   front of this insertion.  This &quot;virtual node&quot; will not&n;&t;&t;   be associated with any space on the flash device.  */
r_struct
id|jffs_node
op_star
id|virtual_node
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|virtual_node
op_assign
(paren
r_struct
id|jffs_node
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs_node
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_insert_data: Inserting a virtual node.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  node-&gt;data_offset = %u&bslash;n&quot;
comma
id|node-&gt;data_offset
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  f-&gt;size = %u&bslash;n&quot;
comma
id|f-&gt;size
)paren
)paren
suffix:semicolon
id|virtual_node-&gt;ino
op_assign
id|node-&gt;ino
suffix:semicolon
id|virtual_node-&gt;version
op_assign
id|node-&gt;version
suffix:semicolon
id|virtual_node-&gt;removed_size
op_assign
l_int|0
suffix:semicolon
id|virtual_node-&gt;fm_offset
op_assign
l_int|0
suffix:semicolon
id|virtual_node-&gt;name_size
op_assign
l_int|0
suffix:semicolon
id|virtual_node-&gt;fm
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This is a virtual data holder.  */
id|virtual_node-&gt;version_prev
op_assign
l_int|0
suffix:semicolon
id|virtual_node-&gt;version_next
op_assign
l_int|0
suffix:semicolon
id|virtual_node-&gt;range_next
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Are there any data at all in the file yet?  */
r_if
c_cond
(paren
id|f-&gt;range_head
)paren
(brace
id|virtual_node-&gt;data_offset
op_assign
id|f-&gt;range_tail-&gt;data_offset
op_plus
id|f-&gt;range_tail-&gt;data_size
suffix:semicolon
id|virtual_node-&gt;data_size
op_assign
id|node-&gt;data_offset
op_minus
id|virtual_node-&gt;data_offset
suffix:semicolon
id|virtual_node-&gt;range_prev
op_assign
id|f-&gt;range_tail
suffix:semicolon
id|f-&gt;range_tail-&gt;range_next
op_assign
id|virtual_node
suffix:semicolon
)brace
r_else
(brace
id|virtual_node-&gt;data_offset
op_assign
l_int|0
suffix:semicolon
id|virtual_node-&gt;data_size
op_assign
id|node-&gt;data_offset
suffix:semicolon
id|virtual_node-&gt;range_prev
op_assign
l_int|0
suffix:semicolon
id|f-&gt;range_head
op_assign
id|virtual_node
suffix:semicolon
)brace
id|f-&gt;range_tail
op_assign
id|virtual_node
suffix:semicolon
id|f-&gt;size
op_add_assign
id|virtual_node-&gt;data_size
suffix:semicolon
multiline_comment|/* Insert this virtual node in the version list as well.  */
r_for
c_loop
(paren
id|n
op_assign
id|f-&gt;version_head
suffix:semicolon
id|n
suffix:semicolon
id|n
op_assign
id|n-&gt;version_next
)paren
(brace
r_if
c_cond
(paren
id|n-&gt;version
op_eq
id|virtual_node-&gt;version
)paren
(brace
id|virtual_node-&gt;version_prev
op_assign
id|n-&gt;version_prev
suffix:semicolon
id|n-&gt;version_prev
op_assign
id|virtual_node
suffix:semicolon
r_if
c_cond
(paren
id|virtual_node-&gt;version_prev
)paren
(brace
id|virtual_node-&gt;version_prev
op_member_access_from_pointer
id|version_next
op_assign
id|virtual_node
suffix:semicolon
)brace
r_else
(brace
id|f-&gt;version_head
op_assign
id|virtual_node
suffix:semicolon
)brace
id|virtual_node-&gt;version_next
op_assign
id|n
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|D
c_func
(paren
id|jffs_print_node
c_func
(paren
id|virtual_node
)paren
)paren
suffix:semicolon
multiline_comment|/* Make a new try to insert the node.  */
r_goto
id|retry
suffix:semicolon
)brace
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_insert_data(): f-&gt;size = %d&bslash;n&quot;
comma
id|f-&gt;size
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* A new node (with data) has been added to the file and now the range&n;   list has to be modified.  */
r_static
r_int
DECL|function|jffs_update_file
id|jffs_update_file
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
comma
r_struct
id|jffs_node
op_star
id|node
)paren
(brace
r_int
id|err
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_update_file(): ino: %u, version: %u&bslash;n&quot;
comma
id|f-&gt;ino
comma
id|node-&gt;version
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|node-&gt;data_size
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|node-&gt;removed_size
op_eq
l_int|0
)paren
(brace
multiline_comment|/* data_offset == X  */
multiline_comment|/* data_size == 0  */
multiline_comment|/* remove_size == 0  */
)brace
r_else
(brace
multiline_comment|/* data_offset == X  */
multiline_comment|/* data_size == 0  */
multiline_comment|/* remove_size != 0  */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|jffs_delete_data
c_func
(paren
id|f
comma
id|node
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* data_offset == X  */
multiline_comment|/* data_size != 0  */
multiline_comment|/* remove_size == Y  */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|jffs_delete_data
c_func
(paren
id|f
comma
id|node
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|jffs_insert_data
c_func
(paren
id|f
comma
id|node
)paren
)paren
OL
l_int|0
)paren
(brace
r_return
id|err
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Print the contents of a node.  */
r_void
DECL|function|jffs_print_node
id|jffs_print_node
c_func
(paren
r_struct
id|jffs_node
op_star
id|n
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_node: 0x%p&bslash;n&quot;
comma
id|n
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;{&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* version  */&bslash;n&quot;
comma
id|n-&gt;version
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* data_offset  */&bslash;n&quot;
comma
id|n-&gt;data_offset
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* data_size  */&bslash;n&quot;
comma
id|n-&gt;data_size
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* removed_size  */&bslash;n&quot;
comma
id|n-&gt;removed_size
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* fm_offset  */&bslash;n&quot;
comma
id|n-&gt;fm_offset
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%02x,       /* name_size  */&bslash;n&quot;
comma
id|n-&gt;name_size
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* fm,  fm-&gt;offset: %u  */&bslash;n&quot;
comma
id|n-&gt;fm
comma
(paren
id|n-&gt;fm
ques
c_cond
id|n-&gt;fm-&gt;offset
suffix:colon
l_int|0
)paren
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* version_prev  */&bslash;n&quot;
comma
id|n-&gt;version_prev
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* version_next  */&bslash;n&quot;
comma
id|n-&gt;version_next
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* range_prev  */&bslash;n&quot;
comma
id|n-&gt;range_prev
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* range_next  */&bslash;n&quot;
comma
id|n-&gt;range_next
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;}&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Print the contents of a raw inode.  */
r_void
DECL|function|jffs_print_raw_inode
id|jffs_print_raw_inode
c_func
(paren
r_struct
id|jffs_raw_inode
op_star
id|raw_inode
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_raw_inode: inode number: %u&bslash;n&quot;
comma
id|raw_inode-&gt;ino
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;{&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* magic  */&bslash;n&quot;
comma
id|raw_inode-&gt;magic
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* ino  */&bslash;n&quot;
comma
id|raw_inode-&gt;ino
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* pino  */&bslash;n&quot;
comma
id|raw_inode-&gt;pino
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* version  */&bslash;n&quot;
comma
id|raw_inode-&gt;version
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* mode  */&bslash;n&quot;
comma
id|raw_inode-&gt;mode
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%04x,     /* uid  */&bslash;n&quot;
comma
id|raw_inode-&gt;uid
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%04x,     /* gid  */&bslash;n&quot;
comma
id|raw_inode-&gt;gid
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* atime  */&bslash;n&quot;
comma
id|raw_inode-&gt;atime
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* mtime  */&bslash;n&quot;
comma
id|raw_inode-&gt;mtime
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* ctime  */&bslash;n&quot;
comma
id|raw_inode-&gt;ctime
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* offset  */&bslash;n&quot;
comma
id|raw_inode-&gt;offset
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* dsize  */&bslash;n&quot;
comma
id|raw_inode-&gt;dsize
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* rsize  */&bslash;n&quot;
comma
id|raw_inode-&gt;rsize
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%02x,       /* nsize  */&bslash;n&quot;
comma
id|raw_inode-&gt;nsize
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%02x,       /* nlink  */&bslash;n&quot;
comma
id|raw_inode-&gt;nlink
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%02x,       /* spare  */&bslash;n&quot;
comma
id|raw_inode-&gt;spare
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        %u,          /* rename  */&bslash;n&quot;
comma
id|raw_inode-&gt;rename
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        %u,          /* deleted  */&bslash;n&quot;
comma
id|raw_inode-&gt;deleted
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%02x,       /* accurate  */&bslash;n&quot;
comma
id|raw_inode-&gt;accurate
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* dchksum  */&bslash;n&quot;
comma
id|raw_inode-&gt;dchksum
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%04x,     /* nchksum  */&bslash;n&quot;
comma
id|raw_inode-&gt;nchksum
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%04x,     /* chksum  */&bslash;n&quot;
comma
id|raw_inode-&gt;chksum
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;}&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Print the contents of a file.  */
r_int
DECL|function|jffs_print_file
id|jffs_print_file
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
)paren
(brace
id|D
c_func
(paren
r_int
id|i
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_file: 0x%p&bslash;n&quot;
comma
id|f
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;{&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* ino  */&bslash;n&quot;
comma
id|f-&gt;ino
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* pino  */&bslash;n&quot;
comma
id|f-&gt;pino
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* mode  */&bslash;n&quot;
comma
id|f-&gt;mode
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%04x,     /* uid  */&bslash;n&quot;
comma
id|f-&gt;uid
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%04x,     /* gid  */&bslash;n&quot;
comma
id|f-&gt;gid
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* atime  */&bslash;n&quot;
comma
id|f-&gt;atime
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* mtime  */&bslash;n&quot;
comma
id|f-&gt;mtime
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* ctime  */&bslash;n&quot;
comma
id|f-&gt;ctime
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%02x,       /* nsize  */&bslash;n&quot;
comma
id|f-&gt;nsize
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%02x,       /* nlink  */&bslash;n&quot;
comma
id|f-&gt;nlink
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%02x,       /* deleted  */&bslash;n&quot;
comma
id|f-&gt;deleted
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        &bslash;&quot;%s&bslash;&quot;, &quot;
comma
(paren
id|f-&gt;name
ques
c_cond
id|f-&gt;name
suffix:colon
l_string|&quot;&quot;
)paren
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
r_for
(paren
id|i
op_assign
id|strlen
c_func
(paren
id|f-&gt;name
ques
c_cond
id|f-&gt;name
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;/* name  */&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* size  */&bslash;n&quot;
comma
id|f-&gt;size
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* highest_version  */&bslash;n&quot;
comma
id|f-&gt;highest_version
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* c  */&bslash;n&quot;
comma
id|f-&gt;c
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* parent  */&bslash;n&quot;
comma
id|f-&gt;parent
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* children  */&bslash;n&quot;
comma
id|f-&gt;children
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* sibling_prev  */&bslash;n&quot;
comma
id|f-&gt;sibling_prev
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* sibling_next  */&bslash;n&quot;
comma
id|f-&gt;sibling_next
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* hash_prev  */&bslash;n&quot;
comma
id|f-&gt;hash.prev
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* hash_next  */&bslash;n&quot;
comma
id|f-&gt;hash.next
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* range_head  */&bslash;n&quot;
comma
id|f-&gt;range_head
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* range_tail  */&bslash;n&quot;
comma
id|f-&gt;range_tail
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* version_head  */&bslash;n&quot;
comma
id|f-&gt;version_head
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* version_tail  */&bslash;n&quot;
comma
id|f-&gt;version_tail
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;}&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|jffs_print_hash_table
id|jffs_print_hash_table
c_func
(paren
r_struct
id|jffs_control
op_star
id|c
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;JFFS: Dumping the file system&squot;s hash table...&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|c-&gt;hash_len
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|c-&gt;hash
(braket
id|i
)braket
dot
id|next
suffix:semicolon
id|p
op_ne
op_amp
id|c-&gt;hash
(braket
id|i
)braket
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_struct
id|jffs_file
op_star
id|f
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|jffs_file
comma
id|hash
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;*** c-&gt;hash[%u]: &bslash;&quot;%s&bslash;&quot; &quot;
l_string|&quot;(ino: %u, pino: %u)&bslash;n&quot;
comma
id|i
comma
(paren
id|f-&gt;name
ques
c_cond
id|f-&gt;name
suffix:colon
l_string|&quot;&quot;
)paren
comma
id|f-&gt;ino
comma
id|f-&gt;pino
)paren
suffix:semicolon
)brace
)brace
)brace
r_void
DECL|function|jffs_print_tree
id|jffs_print_tree
c_func
(paren
r_struct
id|jffs_file
op_star
id|first_file
comma
r_int
id|indent
)paren
(brace
r_struct
id|jffs_file
op_star
id|f
suffix:semicolon
r_char
op_star
id|space
suffix:semicolon
r_int
id|dir
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|first_file
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|space
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|indent
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;jffs_print_tree(): Out of memory!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|space
comma
l_char|&squot; &squot;
comma
id|indent
)paren
suffix:semicolon
id|space
(braket
id|indent
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
id|f
op_assign
id|first_file
suffix:semicolon
id|f
suffix:semicolon
id|f
op_assign
id|f-&gt;sibling_next
)paren
(brace
id|dir
op_assign
id|S_ISDIR
c_func
(paren
id|f-&gt;mode
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s%s%s (ino: %u, highest_version: %u, size: %u)&bslash;n&quot;
comma
id|space
comma
(paren
id|f-&gt;name
ques
c_cond
id|f-&gt;name
suffix:colon
l_string|&quot;&quot;
)paren
comma
(paren
id|dir
ques
c_cond
l_string|&quot;/&quot;
suffix:colon
l_string|&quot;&quot;
)paren
comma
id|f-&gt;ino
comma
id|f-&gt;highest_version
comma
id|f-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
)paren
(brace
id|jffs_print_tree
c_func
(paren
id|f-&gt;children
comma
id|indent
op_plus
l_int|2
)paren
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|space
)paren
suffix:semicolon
)brace
macro_line|#if defined(JFFS_MEMORY_DEBUG) &amp;&amp; JFFS_MEMORY_DEBUG
r_void
DECL|function|jffs_print_memory_allocation_statistics
id|jffs_print_memory_allocation_statistics
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|printout
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;________ Memory printout #%ld ________&bslash;n&quot;
comma
op_increment
id|printout
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;no_jffs_file = %ld&bslash;n&quot;
comma
id|no_jffs_file
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;no_jffs_node = %ld&bslash;n&quot;
comma
id|no_jffs_node
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;no_jffs_control = %ld&bslash;n&quot;
comma
id|no_jffs_control
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;no_jffs_raw_inode = %ld&bslash;n&quot;
comma
id|no_jffs_raw_inode
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;no_jffs_node_ref = %ld&bslash;n&quot;
comma
id|no_jffs_node_ref
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;no_jffs_fm = %ld&bslash;n&quot;
comma
id|no_jffs_fm
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;no_jffs_fmcontrol = %ld&bslash;n&quot;
comma
id|no_jffs_fmcontrol
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;no_hash = %ld&bslash;n&quot;
comma
id|no_hash
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;no_name = %ld&bslash;n&quot;
comma
id|no_name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Rewrite `size&squot; bytes, and begin at `node&squot;.  */
r_int
DECL|function|jffs_rewrite_data
id|jffs_rewrite_data
c_func
(paren
r_struct
id|jffs_file
op_star
id|f
comma
r_struct
id|jffs_node
op_star
id|node
comma
r_int
id|size
)paren
(brace
r_struct
id|jffs_control
op_star
id|c
op_assign
id|f-&gt;c
suffix:semicolon
r_struct
id|jffs_fmcontrol
op_star
id|fmc
op_assign
id|c-&gt;fmc
suffix:semicolon
r_struct
id|jffs_raw_inode
id|raw_inode
suffix:semicolon
r_struct
id|jffs_node
op_star
id|new_node
suffix:semicolon
r_struct
id|jffs_fm
op_star
id|fm
suffix:semicolon
id|__u32
id|pos
suffix:semicolon
id|__u32
id|pos_dchksum
suffix:semicolon
id|__u32
id|total_name_size
suffix:semicolon
id|__u32
id|total_data_size
suffix:semicolon
id|__u32
id|total_size
suffix:semicolon
r_int
id|err
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;***jffs_rewrite_data(): node: %u, name: &bslash;&quot;%s&bslash;&quot;, size: %u&bslash;n&quot;
comma
id|f-&gt;ino
comma
(paren
id|f-&gt;name
ques
c_cond
id|f-&gt;name
suffix:colon
l_string|&quot;(null)&quot;
)paren
comma
id|size
)paren
)paren
suffix:semicolon
multiline_comment|/* Create and initialize the new node.  */
r_if
c_cond
(paren
op_logical_neg
(paren
id|new_node
op_assign
(paren
r_struct
id|jffs_node
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs_node
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_rewrite_data(): &quot;
l_string|&quot;Failed to allocate node.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|DJM
c_func
(paren
id|no_jffs_node
op_increment
)paren
suffix:semicolon
id|new_node-&gt;data_offset
op_assign
id|node-&gt;data_offset
suffix:semicolon
id|new_node-&gt;removed_size
op_assign
id|size
suffix:semicolon
id|total_name_size
op_assign
id|JFFS_PAD
c_func
(paren
id|f-&gt;nsize
)paren
suffix:semicolon
id|total_data_size
op_assign
id|JFFS_PAD
c_func
(paren
id|size
)paren
suffix:semicolon
id|total_size
op_assign
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
op_plus
id|total_name_size
op_plus
id|total_data_size
suffix:semicolon
id|new_node-&gt;fm_offset
op_assign
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
op_plus
id|total_name_size
suffix:semicolon
id|jffs_fm_write_lock
c_func
(paren
id|fmc
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|jffs_fmalloc
c_func
(paren
id|fmc
comma
id|total_size
comma
id|new_node
comma
op_amp
id|fm
)paren
)paren
OL
l_int|0
)paren
(brace
id|DJM
c_func
(paren
id|no_jffs_node
op_decrement
)paren
suffix:semicolon
id|jffs_fm_write_unlock
c_func
(paren
id|fmc
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_rewrite_data(): Failed to allocate fm.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|new_node
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|fm-&gt;nodes
)paren
(brace
multiline_comment|/* The jffs_fm struct that we got is not big enough.  */
multiline_comment|/* This should never happen, because we deal with this case&n;&t;&t;   in jffs_garbage_collect_next().*/
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs_rewrite_data(): Allocated node is too small (%d bytes of %d)&bslash;n&quot;
comma
id|fm-&gt;size
comma
id|total_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|jffs_write_dummy_node
c_func
(paren
id|c
comma
id|fm
)paren
)paren
OL
l_int|0
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_rewrite_data(): &quot;
l_string|&quot;jffs_write_dummy_node() Failed!&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|err
op_assign
op_minus
id|ENOSPC
suffix:semicolon
)brace
id|DJM
c_func
(paren
id|no_jffs_fm
op_decrement
)paren
suffix:semicolon
id|jffs_fm_write_unlock
c_func
(paren
id|fmc
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fm
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|new_node-&gt;fm
op_assign
id|fm
suffix:semicolon
multiline_comment|/* Initialize the raw inode.  */
id|raw_inode.magic
op_assign
id|JFFS_MAGIC_BITMASK
suffix:semicolon
id|raw_inode.ino
op_assign
id|f-&gt;ino
suffix:semicolon
id|raw_inode.pino
op_assign
id|f-&gt;pino
suffix:semicolon
id|raw_inode.version
op_assign
id|f-&gt;highest_version
op_plus
l_int|1
suffix:semicolon
id|raw_inode.mode
op_assign
id|f-&gt;mode
suffix:semicolon
id|raw_inode.uid
op_assign
id|f-&gt;uid
suffix:semicolon
id|raw_inode.gid
op_assign
id|f-&gt;gid
suffix:semicolon
id|raw_inode.atime
op_assign
id|f-&gt;atime
suffix:semicolon
id|raw_inode.mtime
op_assign
id|f-&gt;mtime
suffix:semicolon
id|raw_inode.ctime
op_assign
id|f-&gt;ctime
suffix:semicolon
id|raw_inode.offset
op_assign
id|node-&gt;data_offset
suffix:semicolon
id|raw_inode.dsize
op_assign
id|size
suffix:semicolon
id|raw_inode.rsize
op_assign
id|size
suffix:semicolon
id|raw_inode.nsize
op_assign
id|f-&gt;nsize
suffix:semicolon
id|raw_inode.nlink
op_assign
id|f-&gt;nlink
suffix:semicolon
id|raw_inode.spare
op_assign
l_int|0
suffix:semicolon
id|raw_inode.rename
op_assign
l_int|0
suffix:semicolon
id|raw_inode.deleted
op_assign
l_int|0
suffix:semicolon
id|raw_inode.accurate
op_assign
l_int|0xff
suffix:semicolon
id|raw_inode.dchksum
op_assign
l_int|0
suffix:semicolon
id|raw_inode.nchksum
op_assign
l_int|0
suffix:semicolon
id|pos
op_assign
id|new_node-&gt;fm-&gt;offset
suffix:semicolon
id|pos_dchksum
op_assign
id|pos
op_plus
id|JFFS_RAW_INODE_DCHKSUM_OFFSET
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_rewrite_data(): Writing this raw inode &quot;
l_string|&quot;to pos 0x%ul.&bslash;n&quot;
comma
id|pos
)paren
)paren
suffix:semicolon
id|D3
c_func
(paren
id|jffs_print_raw_inode
c_func
(paren
op_amp
id|raw_inode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|flash_safe_write
c_func
(paren
id|fmc-&gt;mtd
comma
id|pos
comma
(paren
id|u_char
op_star
)paren
op_amp
id|raw_inode
comma
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
op_minus
r_sizeof
(paren
id|__u32
)paren
op_minus
r_sizeof
(paren
id|__u16
)paren
op_minus
r_sizeof
(paren
id|__u16
)paren
)paren
)paren
OL
l_int|0
)paren
(brace
id|jffs_fmfree_partly
c_func
(paren
id|fmc
comma
id|fm
comma
id|total_name_size
op_plus
id|total_data_size
)paren
suffix:semicolon
id|jffs_fm_write_unlock
c_func
(paren
id|fmc
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;JFFS: jffs_rewrite_data: Write error during &quot;
l_string|&quot;rewrite. (raw inode)&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|pos
op_add_assign
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
suffix:semicolon
multiline_comment|/* Write the name to the flash memory.  */
r_if
c_cond
(paren
id|f-&gt;nsize
)paren
(brace
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_rewrite_data(): Writing name &bslash;&quot;%s&bslash;&quot; to &quot;
l_string|&quot;pos 0x%ul.&bslash;n&quot;
comma
id|f-&gt;name
comma
(paren
r_int
)paren
id|pos
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|flash_safe_write
c_func
(paren
id|fmc-&gt;mtd
comma
id|pos
comma
(paren
id|u_char
op_star
)paren
id|f-&gt;name
comma
id|f-&gt;nsize
)paren
)paren
OL
l_int|0
)paren
(brace
id|jffs_fmfree_partly
c_func
(paren
id|fmc
comma
id|fm
comma
id|total_data_size
)paren
suffix:semicolon
id|jffs_fm_write_unlock
c_func
(paren
id|fmc
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;JFFS: jffs_rewrite_data: Write &quot;
l_string|&quot;error during rewrite. (name)&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|pos
op_add_assign
id|total_name_size
suffix:semicolon
id|raw_inode.nchksum
op_assign
id|jffs_checksum
c_func
(paren
id|f-&gt;name
comma
id|f-&gt;nsize
)paren
suffix:semicolon
)brace
multiline_comment|/* Write the data.  */
r_if
c_cond
(paren
id|size
)paren
(brace
r_int
id|r
suffix:semicolon
r_int
r_char
op_star
id|page
suffix:semicolon
id|__u32
id|offset
op_assign
id|node-&gt;data_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_assign
(paren
r_int
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|jffs_fmfree_partly
c_func
(paren
id|fmc
comma
id|fm
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|size
)paren
(brace
id|__u32
id|s
op_assign
id|jffs_min
c_func
(paren
id|size
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_assign
id|jffs_read_data
c_func
(paren
id|f
comma
(paren
r_char
op_star
)paren
id|page
comma
id|offset
comma
id|s
)paren
)paren
OL
id|s
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|page
)paren
suffix:semicolon
id|jffs_fmfree_partly
c_func
(paren
id|fmc
comma
id|fm
comma
l_int|0
)paren
suffix:semicolon
id|jffs_fm_write_unlock
c_func
(paren
id|fmc
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;JFFS: jffs_rewrite_data: &quot;
l_string|&quot;jffs_read_data() &quot;
l_string|&quot;failed! (r = %d)&bslash;n&quot;
comma
id|r
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|flash_safe_write
c_func
(paren
id|fmc-&gt;mtd
comma
id|pos
comma
id|page
comma
id|r
)paren
)paren
OL
l_int|0
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|page
)paren
suffix:semicolon
id|jffs_fmfree_partly
c_func
(paren
id|fmc
comma
id|fm
comma
l_int|0
)paren
suffix:semicolon
id|jffs_fm_write_unlock
c_func
(paren
id|fmc
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;JFFS: jffs_rewrite_data: &quot;
l_string|&quot;Write error during rewrite. &quot;
l_string|&quot;(data)&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|pos
op_add_assign
id|r
suffix:semicolon
id|size
op_sub_assign
id|r
suffix:semicolon
id|offset
op_add_assign
id|r
suffix:semicolon
id|raw_inode.dchksum
op_add_assign
id|jffs_checksum
c_func
(paren
id|page
comma
id|r
)paren
suffix:semicolon
)brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|page
)paren
suffix:semicolon
)brace
id|raw_inode.accurate
op_assign
l_int|0
suffix:semicolon
id|raw_inode.chksum
op_assign
id|jffs_checksum
c_func
(paren
op_amp
id|raw_inode
comma
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
op_minus
r_sizeof
(paren
id|__u16
)paren
)paren
suffix:semicolon
multiline_comment|/* Add the checksum.  */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|flash_safe_write
c_func
(paren
id|fmc-&gt;mtd
comma
id|pos_dchksum
comma
op_amp
(paren
(paren
id|u_char
op_star
)paren
op_amp
id|raw_inode
)paren
(braket
id|JFFS_RAW_INODE_DCHKSUM_OFFSET
)braket
comma
r_sizeof
(paren
id|__u32
)paren
op_plus
r_sizeof
(paren
id|__u16
)paren
op_plus
r_sizeof
(paren
id|__u16
)paren
)paren
)paren
OL
l_int|0
)paren
(brace
id|jffs_fmfree_partly
c_func
(paren
id|fmc
comma
id|fm
comma
l_int|0
)paren
suffix:semicolon
id|jffs_fm_write_unlock
c_func
(paren
id|fmc
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;JFFS: jffs_rewrite_data: Write error during &quot;
l_string|&quot;rewrite. (checksum)&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Now make the file system aware of the newly written node.  */
id|jffs_insert_node
c_func
(paren
id|c
comma
id|f
comma
op_amp
id|raw_inode
comma
id|f-&gt;name
comma
id|new_node
)paren
suffix:semicolon
id|jffs_fm_write_unlock
c_func
(paren
id|fmc
)paren
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_rewrite_data(): Leaving...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* jffs_rewrite_data()  */
multiline_comment|/* jffs_garbage_collect_next implements one step in the garbage collect&n;   process and is often called multiple times at each occasion of a&n;   garbage collect.  */
r_int
DECL|function|jffs_garbage_collect_next
id|jffs_garbage_collect_next
c_func
(paren
r_struct
id|jffs_control
op_star
id|c
)paren
(brace
r_struct
id|jffs_fmcontrol
op_star
id|fmc
op_assign
id|c-&gt;fmc
suffix:semicolon
r_struct
id|jffs_node
op_star
id|node
suffix:semicolon
r_struct
id|jffs_file
op_star
id|f
suffix:semicolon
r_int
id|size
comma
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|data_size
suffix:semicolon
r_int
id|total_name_size
suffix:semicolon
id|__u32
id|extra_available
suffix:semicolon
id|__u32
id|space_needed
suffix:semicolon
id|__u32
id|free_chunk_size1
op_assign
id|jffs_free_size1
c_func
(paren
id|fmc
)paren
suffix:semicolon
id|D2
c_func
(paren
id|__u32
id|free_chunk_size2
op_assign
id|jffs_free_size2
c_func
(paren
id|fmc
)paren
)paren
suffix:semicolon
multiline_comment|/* Get the oldest node in the flash.  */
id|node
op_assign
id|jffs_get_oldest_node
c_func
(paren
id|fmc
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
r_if
(paren
op_logical_neg
id|node
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;JFFS: jffs_garbage_collect_next: &quot;
l_string|&quot;No oldest node found!&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|jffs_garbage_collect_next_end
suffix:semicolon
)brace
)paren
suffix:semicolon
multiline_comment|/* Find its corresponding file too.  */
id|f
op_assign
id|jffs_find_file
c_func
(paren
id|c
comma
id|node-&gt;ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;JFFS: jffs_garbage_collect_next: &quot;
l_string|&quot;No file to garbage collect! &quot;
l_string|&quot;(ino = 0x%08x)&bslash;n&quot;
comma
id|node-&gt;ino
)paren
suffix:semicolon
multiline_comment|/* FIXME: Free the offending node and recover. */
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|jffs_garbage_collect_next_end
suffix:semicolon
)brace
multiline_comment|/* We always write out the name. Theoretically, we don&squot;t need&n;&t;   to, but for now it&squot;s easier - because otherwise we&squot;d have&n;&t;   to keep track of how many times the current name exists on&n;&t;   the flash and make sure it never reaches zero.&n;&n;&t;   The current approach means that would be possible to cause&n;&t;   the GC to end up eating its tail by writing lots of nodes&n;&t;   with no name for it to garbage-collect. Hence the change in&n;&t;   inode.c to write names with _every_ node.&n;&n;&t;   It sucks, but it _should_ work.&n;&t;*/
id|total_name_size
op_assign
id|JFFS_PAD
c_func
(paren
id|f-&gt;nsize
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_garbage_collect_next(): &bslash;&quot;%s&bslash;&quot;, &quot;
l_string|&quot;ino: %u, version: %u, location 0x%x, dsize %u&bslash;n&quot;
comma
(paren
id|f-&gt;name
ques
c_cond
id|f-&gt;name
suffix:colon
l_string|&quot;&quot;
)paren
comma
id|node-&gt;ino
comma
id|node-&gt;version
comma
id|node-&gt;fm-&gt;offset
comma
id|node-&gt;data_size
)paren
)paren
suffix:semicolon
multiline_comment|/* Compute how many data it&squot;s possible to rewrite at the moment.  */
id|data_size
op_assign
id|f-&gt;size
op_minus
id|node-&gt;data_offset
suffix:semicolon
multiline_comment|/* And from that, the total size of the chunk we want to write */
id|size
op_assign
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
op_plus
id|total_name_size
op_plus
id|data_size
op_plus
id|JFFS_GET_PAD_BYTES
c_func
(paren
id|data_size
)paren
suffix:semicolon
multiline_comment|/* If that&squot;s more than max_chunk_size, reduce it accordingly */
r_if
c_cond
(paren
id|size
OG
id|fmc-&gt;max_chunk_size
)paren
(brace
id|size
op_assign
id|fmc-&gt;max_chunk_size
suffix:semicolon
id|data_size
op_assign
id|size
op_minus
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
op_minus
id|total_name_size
suffix:semicolon
)brace
multiline_comment|/* If we&squot;re asking to take up more space than free_chunk_size1&n;&t;   but we _could_ fit in it, shrink accordingly.&n;&t;*/
r_if
c_cond
(paren
id|size
OG
id|free_chunk_size1
)paren
(brace
r_if
c_cond
(paren
id|free_chunk_size1
OL
(paren
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
op_plus
id|total_name_size
op_plus
id|BLOCK_SIZE
)paren
)paren
(brace
multiline_comment|/* The space left is too small to be of any&n;&t;&t;&t;   use really.  */
r_struct
id|jffs_fm
op_star
id|dirty_fm
op_assign
id|jffs_fmalloced
c_func
(paren
id|fmc
comma
id|fmc-&gt;tail-&gt;offset
op_plus
id|fmc-&gt;tail-&gt;size
comma
id|free_chunk_size1
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dirty_fm
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;JFFS: &quot;
l_string|&quot;jffs_garbage_collect_next: &quot;
l_string|&quot;Failed to allocate `dirty&squot; &quot;
l_string|&quot;flash memory!&bslash;n&quot;
)paren
suffix:semicolon
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|jffs_garbage_collect_next_end
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;Dirtying end of flash - too small&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|jffs_write_dummy_node
c_func
(paren
id|c
comma
id|dirty_fm
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_goto
id|jffs_garbage_collect_next_end
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;Reducing size of new node from %d to %d to avoid &quot;
l_string|&quot; exceeding free_chunk_size1&bslash;n&quot;
comma
id|size
comma
id|free_chunk_size1
)paren
)paren
suffix:semicolon
id|size
op_assign
id|free_chunk_size1
suffix:semicolon
id|data_size
op_assign
id|size
op_minus
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
op_minus
id|total_name_size
suffix:semicolon
)brace
multiline_comment|/* Calculate the amount of space needed to hold the nodes&n;&t;   which are remaining in the tail */
id|space_needed
op_assign
id|fmc-&gt;min_free_size
op_minus
(paren
id|node-&gt;fm-&gt;offset
op_mod
id|fmc-&gt;sector_size
)paren
suffix:semicolon
multiline_comment|/* From that, calculate how much &squot;extra&squot; space we can use to&n;&t;   increase the size of the node we&squot;re writing from the size&n;&t;   of the node we&squot;re obsoleting&n;&t;*/
r_if
c_cond
(paren
id|space_needed
OG
id|fmc-&gt;free_size
)paren
(brace
multiline_comment|/* If we&squot;ve gone below min_free_size for some reason,&n;&t;&t;   don&squot;t fuck up. This is why we have &n;&t;&t;   min_free_size &gt; sector_size. Whinge about it though,&n;&t;&t;   just so I can convince myself my maths is right.&n;&t;&t;*/
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs_garbage_collect_next(): &quot;
l_string|&quot;space_needed %d exceeded free_size %d&bslash;n&quot;
comma
id|space_needed
comma
id|fmc-&gt;free_size
)paren
)paren
suffix:semicolon
id|extra_available
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|extra_available
op_assign
id|fmc-&gt;free_size
op_minus
id|space_needed
suffix:semicolon
)brace
multiline_comment|/* Check that we don&squot;t use up any more &squot;extra&squot; space than&n;&t;   what&squot;s available */
r_if
c_cond
(paren
id|size
OG
id|JFFS_PAD
c_func
(paren
id|node-&gt;data_size
)paren
op_plus
id|total_name_size
op_plus
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
op_plus
id|extra_available
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;Reducing size of new node from %d to %ld to avoid &quot;
l_string|&quot;catching our tail&bslash;n&quot;
comma
id|size
comma
id|JFFS_PAD
c_func
(paren
id|node-&gt;data_size
)paren
op_plus
id|JFFS_PAD
c_func
(paren
id|node-&gt;name_size
)paren
op_plus
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
op_plus
id|extra_available
)paren
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;space_needed = %d, extra_available = %d&bslash;n&quot;
comma
id|space_needed
comma
id|extra_available
)paren
)paren
suffix:semicolon
id|size
op_assign
id|JFFS_PAD
c_func
(paren
id|node-&gt;data_size
)paren
op_plus
id|total_name_size
op_plus
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
op_plus
id|extra_available
suffix:semicolon
id|data_size
op_assign
id|size
op_minus
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
op_minus
id|total_name_size
suffix:semicolon
)brace
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  total_name_size: %u&bslash;n&quot;
comma
id|total_name_size
)paren
)paren
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  data_size: %u&bslash;n&quot;
comma
id|data_size
)paren
)paren
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  size: %u&bslash;n&quot;
comma
id|size
)paren
)paren
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  f-&gt;nsize: %u&bslash;n&quot;
comma
id|f-&gt;nsize
)paren
)paren
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  f-&gt;size: %u&bslash;n&quot;
comma
id|f-&gt;size
)paren
)paren
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  node-&gt;data_offset: %u&bslash;n&quot;
comma
id|node-&gt;data_offset
)paren
)paren
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  free_chunk_size1: %u&bslash;n&quot;
comma
id|free_chunk_size1
)paren
)paren
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  free_chunk_size2: %u&bslash;n&quot;
comma
id|free_chunk_size2
)paren
)paren
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  node-&gt;fm-&gt;offset: 0x%08x&bslash;n&quot;
comma
id|node-&gt;fm-&gt;offset
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|jffs_rewrite_data
c_func
(paren
id|f
comma
id|node
comma
id|data_size
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs_rewrite_data() failed: %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|jffs_garbage_collect_next_end
suffix:colon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_garbage_collect_next: Leaving...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* jffs_garbage_collect_next */
multiline_comment|/* If an obsolete node is partly going to be erased due to garbage&n;   collection, the part that isn&squot;t going to be erased must be filled&n;   with zeroes so that the scan of the flash will work smoothly next&n;   time.  (The data in the file could for instance be a JFFS image&n;   which could cause enormous confusion during a scan of the flash&n;   device if we didn&squot;t do this.)&n;     There are two phases in this procedure: First, the clearing of&n;   the name and data parts of the node. Second, possibly also clearing&n;   a part of the raw inode as well.  If the box is power cycled during&n;   the first phase, only the checksum of this node-to-be-cleared-at-&n;   the-end will be wrong.  If the box is power cycled during, or after,&n;   the clearing of the raw inode, the information like the length of&n;   the name and data parts are zeroed.  The next time the box is&n;   powered up, the scanning algorithm manages this faulty data too&n;   because:&n;&n;   - The checksum is invalid and thus the raw inode must be discarded&n;     in any case.&n;   - If the lengths of the data part or the name part are zeroed, the&n;     scanning just continues after the raw inode.  But after the inode&n;     the scanning procedure just finds zeroes which is the same as&n;     dirt.&n;&n;   So, in the end, this could never fail. :-)  Even if it does fail,&n;   the scanning algorithm should manage that too.  */
r_static
r_int
DECL|function|jffs_clear_end_of_node
id|jffs_clear_end_of_node
c_func
(paren
r_struct
id|jffs_control
op_star
id|c
comma
id|__u32
id|erase_size
)paren
(brace
r_struct
id|jffs_fm
op_star
id|fm
suffix:semicolon
r_struct
id|jffs_fmcontrol
op_star
id|fmc
op_assign
id|c-&gt;fmc
suffix:semicolon
id|__u32
id|zero_offset
suffix:semicolon
id|__u32
id|zero_size
suffix:semicolon
id|__u32
id|zero_offset_data
suffix:semicolon
id|__u32
id|zero_size_data
suffix:semicolon
id|__u32
id|cutting_raw_inode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|fm
op_assign
id|jffs_cut_node
c_func
(paren
id|fmc
comma
id|erase_size
)paren
)paren
)paren
(brace
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_clear_end_of_node(): fm == NULL&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Where and how much shall we clear?  */
id|zero_offset
op_assign
id|fmc-&gt;head-&gt;offset
op_plus
id|erase_size
suffix:semicolon
id|zero_size
op_assign
id|fm-&gt;offset
op_plus
id|fm-&gt;size
op_minus
id|zero_offset
suffix:semicolon
multiline_comment|/* Do we have to clear the raw_inode explicitly?  */
r_if
c_cond
(paren
id|fm-&gt;size
op_minus
id|zero_size
OL
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
)paren
(brace
id|cutting_raw_inode
op_assign
r_sizeof
(paren
r_struct
id|jffs_raw_inode
)paren
op_minus
(paren
id|fm-&gt;size
op_minus
id|zero_size
)paren
suffix:semicolon
)brace
multiline_comment|/* First, clear the name and data fields.  */
id|zero_offset_data
op_assign
id|zero_offset
op_plus
id|cutting_raw_inode
suffix:semicolon
id|zero_size_data
op_assign
id|zero_size
op_minus
id|cutting_raw_inode
suffix:semicolon
id|flash_safe_acquire
c_func
(paren
id|fmc-&gt;mtd
)paren
suffix:semicolon
id|flash_memset
c_func
(paren
id|fmc-&gt;mtd
comma
id|zero_offset_data
comma
l_int|0
comma
id|zero_size_data
)paren
suffix:semicolon
id|flash_safe_release
c_func
(paren
id|fmc-&gt;mtd
)paren
suffix:semicolon
multiline_comment|/* Should we clear a part of the raw inode?  */
r_if
c_cond
(paren
id|cutting_raw_inode
)paren
(brace
multiline_comment|/* I guess it is ok to clear the raw inode in this order.  */
id|flash_safe_acquire
c_func
(paren
id|fmc-&gt;mtd
)paren
suffix:semicolon
id|flash_memset
c_func
(paren
id|fmc-&gt;mtd
comma
id|zero_offset
comma
l_int|0
comma
id|cutting_raw_inode
)paren
suffix:semicolon
id|flash_safe_release
c_func
(paren
id|fmc-&gt;mtd
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* jffs_clear_end_of_node()  */
multiline_comment|/* Try to erase as much as possible of the dirt in the flash memory.  */
r_int
DECL|function|jffs_try_to_erase
id|jffs_try_to_erase
c_func
(paren
r_struct
id|jffs_control
op_star
id|c
)paren
(brace
r_struct
id|jffs_fmcontrol
op_star
id|fmc
op_assign
id|c-&gt;fmc
suffix:semicolon
r_int
id|erase_size
suffix:semicolon
r_int
id|err
suffix:semicolon
id|__u32
id|offset
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_try_to_erase()&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|erase_size
op_assign
id|jffs_erasable_size
c_func
(paren
id|fmc
)paren
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_try_to_erase(): erase_size = %ld&bslash;n&quot;
comma
id|erase_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|erase_size
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|erase_size
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;JFFS: jffs_try_to_erase: &quot;
l_string|&quot;jffs_erasable_size returned %ld.&bslash;n&quot;
comma
id|erase_size
)paren
suffix:semicolon
r_return
id|erase_size
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|jffs_clear_end_of_node
c_func
(paren
id|c
comma
id|erase_size
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;JFFS: jffs_try_to_erase: &quot;
l_string|&quot;Clearing of node failed.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|offset
op_assign
id|fmc-&gt;head-&gt;offset
op_minus
id|fmc-&gt;flash_start
suffix:semicolon
multiline_comment|/* Now, let&squot;s try to do the erase.  */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|flash_erase_region
c_func
(paren
id|fmc-&gt;mtd
comma
id|offset
comma
id|erase_size
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;JFFS: Erase of flash failed. &quot;
l_string|&quot;offset = %u, erase_size = %ld&bslash;n&quot;
comma
id|offset
comma
id|erase_size
)paren
suffix:semicolon
multiline_comment|/* XXX: Here we should allocate this area as dirty&n;&t;&t;   with jffs_fmalloced or something similar.  Now&n;&t;&t;   we just report the error.  */
r_return
id|err
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* Check if the erased sectors really got erased.  */
(brace
id|__u32
id|pos
suffix:semicolon
id|__u32
id|end
suffix:semicolon
id|pos
op_assign
(paren
id|__u32
)paren
id|flash_get_direct_pointer
c_func
(paren
id|c-&gt;sb-&gt;s_dev
comma
id|offset
)paren
suffix:semicolon
id|end
op_assign
id|pos
op_plus
id|erase_size
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;JFFS: Checking erased sector(s)...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|flash_safe_acquire
c_func
(paren
id|fmc-&gt;mtd
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|pos
OL
id|end
suffix:semicolon
id|pos
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
id|__u32
op_star
)paren
id|pos
op_ne
id|JFFS_EMPTY_BITMASK
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;JFFS: Erase failed! pos = 0x%lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|pos
)paren
suffix:semicolon
id|jffs_hexdump
c_func
(paren
id|fmc-&gt;mtd
comma
id|pos
comma
id|jffs_min
c_func
(paren
l_int|256
comma
id|end
op_minus
id|pos
)paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|flash_safe_release
c_func
(paren
id|fmc-&gt;mtd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;JFFS: Erase succeeded.&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* XXX: Here we should allocate the memory&n;&t;&t;&t;   with jffs_fmalloced() in order to prevent&n;&t;&t;&t;   JFFS from using this area accidentally.  */
r_return
id|err
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* Update the flash memory data structures.  */
id|jffs_sync_erase
c_func
(paren
id|fmc
comma
id|erase_size
)paren
suffix:semicolon
r_return
id|erase_size
suffix:semicolon
)brace
multiline_comment|/* There are different criteria that should trigger a garbage collect:&n;&n;   1. There is too much dirt in the memory.&n;   2. The free space is becoming small.&n;   3. There are many versions of a node.&n;&n;   The garbage collect should always be done in a manner that guarantees&n;   that future garbage collects cannot be locked.  E.g. Rewritten chunks&n;   should not be too large (span more than one sector in the flash memory&n;   for exemple).  Of course there is a limit on how intelligent this garbage&n;   collection can be.  */
r_int
DECL|function|jffs_garbage_collect_now
id|jffs_garbage_collect_now
c_func
(paren
r_struct
id|jffs_control
op_star
id|c
)paren
(brace
r_struct
id|jffs_fmcontrol
op_star
id|fmc
op_assign
id|c-&gt;fmc
suffix:semicolon
r_int
id|erased
op_assign
l_int|0
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|D1
c_func
(paren
r_int
id|i
op_assign
l_int|1
)paren
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;***jffs_garbage_collect_now(): fmc-&gt;dirty_size = %u, fmc-&gt;free_size = 0x%x&bslash;n, fcs1=0x%x, fcs2=0x%x&quot;
comma
id|fmc-&gt;dirty_size
comma
id|fmc-&gt;free_size
comma
id|jffs_free_size1
c_func
(paren
id|fmc
)paren
comma
id|jffs_free_size2
c_func
(paren
id|fmc
)paren
)paren
)paren
suffix:semicolon
id|D2
c_func
(paren
id|jffs_print_fmcontrol
c_func
(paren
id|fmc
)paren
)paren
suffix:semicolon
singleline_comment|//&t;down(&amp;fmc-&gt;gclock);
multiline_comment|/* If it is possible to garbage collect, do so.  */
r_while
c_loop
(paren
id|erased
op_eq
l_int|0
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;***jffs_garbage_collect_now(): round #%u, &quot;
l_string|&quot;fmc-&gt;dirty_size = %u&bslash;n&quot;
comma
id|i
op_increment
comma
id|fmc-&gt;dirty_size
)paren
)paren
suffix:semicolon
id|D2
c_func
(paren
id|jffs_print_fmcontrol
c_func
(paren
id|fmc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|erased
op_assign
id|jffs_try_to_erase
c_func
(paren
id|c
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;JFFS: Error in &quot;
l_string|&quot;garbage collector.&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|erased
suffix:semicolon
r_goto
id|gc_end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|erased
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|fmc-&gt;free_size
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Argh */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;jffs_garbage_collect_now(): free_size == 0. This is BAD.&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fmc-&gt;dirty_size
OL
id|fmc-&gt;sector_size
)paren
(brace
multiline_comment|/* Actually, we _may_ have been able to free some, &n;&t;&t;&t; * if there are many overlapping nodes which aren&squot;t&n;&t;&t;&t; * actually marked dirty because they still have&n;&t;&t;&t; * some valid data in each.&n;&t;&t;&t; */
id|result
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Let&squot;s dare to make a garbage collect.  */
r_if
c_cond
(paren
(paren
id|result
op_assign
id|jffs_garbage_collect_next
c_func
(paren
id|c
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;JFFS: Something &quot;
l_string|&quot;has gone seriously wrong &quot;
l_string|&quot;with a garbage collect.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|gc_end
suffix:semicolon
)brace
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;   jffs_garbage_collect_now(): erased: %ld&bslash;n&quot;
comma
id|erased
)paren
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|jffs_print_memory_allocation_statistics
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
id|gc_end
suffix:colon
singleline_comment|//&t;up(&amp;fmc-&gt;gclock);
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;   jffs_garbage_collect_now(): Leaving...&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|D1
c_func
(paren
r_if
(paren
id|erased
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;jffs_g_c_now(): erased = %ld&bslash;n&quot;
comma
id|erased
)paren
suffix:semicolon
id|jffs_print_fmcontrol
c_func
(paren
id|fmc
)paren
suffix:semicolon
)brace
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|erased
op_logical_and
op_logical_neg
id|result
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* jffs_garbage_collect_now() */
multiline_comment|/* Determine if it is reasonable to start garbage collection.&n;   We start a gc pass if either:&n;   - The number of free bytes &lt; MIN_FREE_BYTES &amp;&amp; at least one&n;     block is dirty, OR&n;   - The number of dirty bytes &gt; MAX_DIRTY_BYTES&n;*/
DECL|function|thread_should_wake
r_static
r_inline
r_int
id|thread_should_wake
(paren
r_struct
id|jffs_control
op_star
id|c
)paren
(brace
id|D1
c_func
(paren
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;thread_should_wake(): free=%d, dirty=%d, blocksize=%d.&bslash;n&quot;
comma
id|c-&gt;fmc-&gt;free_size
comma
id|c-&gt;fmc-&gt;dirty_size
comma
id|c-&gt;fmc-&gt;sector_size
)paren
)paren
suffix:semicolon
multiline_comment|/* If there&squot;s not enough dirty space to free a block, there&squot;s no point. */
r_if
c_cond
(paren
id|c-&gt;fmc-&gt;dirty_size
OL
id|c-&gt;fmc-&gt;sector_size
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* If there are fewer free bytes than the threshold, GC */
r_if
c_cond
(paren
id|c-&gt;fmc-&gt;dirty_size
OL
id|c-&gt;gc_minfree_threshold
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* If there are more dirty bytes than the threshold, GC */
r_if
c_cond
(paren
id|c-&gt;fmc-&gt;dirty_size
OG
id|c-&gt;gc_maxdirty_threshold
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* FIXME: What about the &quot;There are many versions of a node&quot; condition? */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|jffs_garbage_collect_trigger
r_void
id|jffs_garbage_collect_trigger
c_func
(paren
r_struct
id|jffs_control
op_star
id|c
)paren
(brace
multiline_comment|/* NOTE: We rely on the fact that we have the BKL here.&n;&t; * Otherwise, the gc_task could go away between the check&n;&t; * and the wake_up_process()&n;&t; */
r_if
c_cond
(paren
id|c-&gt;gc_task
op_logical_and
id|thread_should_wake
c_func
(paren
id|c
)paren
)paren
id|send_sig
c_func
(paren
id|SIGHUP
comma
id|c-&gt;gc_task
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Kernel threads  take (void *) as arguments.   Thus we pass&n;   the jffs_control data as a (void *) and then cast it. */
r_int
DECL|function|jffs_garbage_collect_thread
id|jffs_garbage_collect_thread
c_func
(paren
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|jffs_control
op_star
id|c
op_assign
(paren
r_struct
id|jffs_control
op_star
)paren
id|ptr
suffix:semicolon
r_struct
id|jffs_fmcontrol
op_star
id|fmc
op_assign
id|c-&gt;fmc
suffix:semicolon
r_int
id|erased
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|D1
c_func
(paren
r_int
id|i
op_assign
l_int|1
)paren
suffix:semicolon
id|c-&gt;gc_task
op_assign
id|current
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|exit_mm
c_func
(paren
id|c-&gt;gc_task
)paren
suffix:semicolon
id|current-&gt;session
op_assign
l_int|1
suffix:semicolon
id|current-&gt;pgrp
op_assign
l_int|1
suffix:semicolon
id|init_MUTEX_LOCKED
c_func
(paren
op_amp
id|c-&gt;gc_thread_sem
)paren
suffix:semicolon
multiline_comment|/* barrier */
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|siginitsetinv
(paren
op_amp
id|current-&gt;blocked
comma
id|sigmask
c_func
(paren
id|SIGHUP
)paren
op_or
id|sigmask
c_func
(paren
id|SIGKILL
)paren
op_or
id|sigmask
c_func
(paren
id|SIGSTOP
)paren
op_or
id|sigmask
c_func
(paren
id|SIGCONT
)paren
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;jffs_gcd&quot;
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;jffs_garbage_collect_thread(): Starting infinite loop.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* See if we need to start gc.  If we don&squot;t, go to sleep.&n;&t;&t;   &n;&t;&t;   Current implementation is a BAD THING(tm).  If we try &n;&t;&t;   to unmount the FS, the unmount operation will sleep waiting&n;&t;&t;   for this thread to exit.  We need to arrange to send it a&n;&t;&t;   sig before the umount process sleeps.&n;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|thread_should_wake
c_func
(paren
id|c
)paren
)paren
id|set_current_state
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Yes, we do this even if we want to go&n;&t;&t;&t;&t;       on immediately - we&squot;re a low priority &n;&t;&t;&t;&t;       background task. */
multiline_comment|/* Put_super will send a SIGKILL and then wait on the sem. &n;&t;&t; */
r_while
c_loop
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|siginfo_t
id|info
suffix:semicolon
r_int
r_int
id|signr
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|signr
op_assign
id|dequeue_signal
c_func
(paren
op_amp
id|current-&gt;blocked
comma
op_amp
id|info
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|signr
)paren
(brace
r_case
id|SIGSTOP
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_garbage_collect_thread(): SIGSTOP received.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_STOPPED
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SIGKILL
suffix:colon
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_garbage_collect_thread(): SIGKILL received.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|c-&gt;gc_task
op_assign
l_int|NULL
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|up_and_exit
c_func
(paren
op_amp
id|c-&gt;gc_thread_sem
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|D1
c_func
(paren
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;jffs_garbage_collect_thread(): collecting.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fmc-&gt;dirty_size
OL
id|fmc-&gt;sector_size
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs_garbage_collect_thread with insufficient dirty space (0x%x)&bslash;n&quot;
comma
id|fmc-&gt;dirty_size
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|D3
c_func
(paren
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;g_c_thread(): down biglock&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|fmc-&gt;biglock
)paren
suffix:semicolon
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;***jffs_garbage_collect_thread(): round #%u, &quot;
l_string|&quot;fmc-&gt;dirty_size = %u&bslash;n&quot;
comma
id|i
op_increment
comma
id|fmc-&gt;dirty_size
)paren
)paren
suffix:semicolon
id|D2
c_func
(paren
id|jffs_print_fmcontrol
c_func
(paren
id|fmc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|erased
op_assign
id|jffs_try_to_erase
c_func
(paren
id|c
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;JFFS: Error in &quot;
l_string|&quot;garbage collector: %ld.&bslash;n&quot;
comma
id|erased
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|erased
)paren
r_goto
id|gc_end
suffix:semicolon
r_if
c_cond
(paren
id|fmc-&gt;free_size
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Argh. Might as well commit suicide. */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;jffs_garbage_collect_thread(): free_size == 0. This is BAD.&bslash;n&quot;
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGQUIT
comma
id|c-&gt;gc_task
comma
l_int|1
)paren
suffix:semicolon
singleline_comment|// panic()
r_goto
id|gc_end
suffix:semicolon
)brace
multiline_comment|/* Let&squot;s dare to make a garbage collect.  */
r_if
c_cond
(paren
(paren
id|result
op_assign
id|jffs_garbage_collect_next
c_func
(paren
id|c
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;JFFS: Something &quot;
l_string|&quot;has gone seriously wrong &quot;
l_string|&quot;with a garbage collect: %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
)brace
id|gc_end
suffix:colon
id|D3
c_func
(paren
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;g_c_thread(): up biglock&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|fmc-&gt;biglock
)paren
suffix:semicolon
)brace
multiline_comment|/* for (;;) */
)brace
multiline_comment|/* jffs_garbage_collect_thread() */
eof
