multiline_comment|/*&n; * JFFS -- Journaling Flash File System, Linux implementation.&n; *&n; * Copyright (C) 1999, 2000  Axis Communications AB.&n; *&n; * Created by Finn Hakansson &lt;finn@axis.com&gt;.&n; *&n; * This is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * $Id: jffs_fm.h,v 1.10 2000/08/17 15:42:44 dwmw2 Exp $&n; *&n; * Ported to Linux 2.3.x and MTD:&n; * Copyright (C) 2000  Alexander Larsson (alex@cendio.se), Cendio Systems AB&n; *&n; */
macro_line|#ifndef __LINUX_JFFS_FM_H__
DECL|macro|__LINUX_JFFS_FM_H__
mdefine_line|#define __LINUX_JFFS_FM_H__
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/jffs.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/config.h&gt;
multiline_comment|/* The alignment between two nodes in the flash memory.  */
DECL|macro|JFFS_ALIGN_SIZE
mdefine_line|#define JFFS_ALIGN_SIZE 4
multiline_comment|/* Mark the on-flash space as obsolete when appropriate.  */
DECL|macro|JFFS_MARK_OBSOLETE
mdefine_line|#define JFFS_MARK_OBSOLETE 0
macro_line|#ifndef CONFIG_JFFS_FS_VERBOSE
DECL|macro|CONFIG_JFFS_FS_VERBOSE
mdefine_line|#define CONFIG_JFFS_FS_VERBOSE 1
macro_line|#endif
macro_line|#if CONFIG_JFFS_FS_VERBOSE &gt; 0
DECL|macro|D
mdefine_line|#define D(x) x
DECL|macro|D1
mdefine_line|#define D1(x) D(x)
macro_line|#else
DECL|macro|D
mdefine_line|#define D(x)
DECL|macro|D1
mdefine_line|#define D1(x)
macro_line|#endif
macro_line|#if CONFIG_JFFS_FS_VERBOSE &gt; 1
DECL|macro|D2
mdefine_line|#define D2(x) D(x)
macro_line|#else
DECL|macro|D2
mdefine_line|#define D2(x)
macro_line|#endif
macro_line|#if CONFIG_JFFS_FS_VERBOSE &gt; 2
DECL|macro|D3
mdefine_line|#define D3(x) D(x)
macro_line|#else
DECL|macro|D3
mdefine_line|#define D3(x)
macro_line|#endif
DECL|macro|ASSERT
mdefine_line|#define ASSERT(x) x
multiline_comment|/* How many padding bytes should be inserted between two chunks of data&n;   on the flash?  */
DECL|macro|JFFS_GET_PAD_BYTES
mdefine_line|#define JFFS_GET_PAD_BYTES(size) ((JFFS_ALIGN_SIZE                     &bslash;&n;&t;&t;&t;&t;  - ((__u32)(size) % JFFS_ALIGN_SIZE)) &bslash;&n;&t;&t;&t;&t;  % JFFS_ALIGN_SIZE)
DECL|macro|JFFS_PAD
mdefine_line|#define JFFS_PAD(size) ( (size + (JFFS_ALIGN_SIZE-1)) &amp; ~(JFFS_ALIGN_SIZE-1) )
DECL|struct|jffs_node_ref
r_struct
id|jffs_node_ref
(brace
DECL|member|node
r_struct
id|jffs_node
op_star
id|node
suffix:semicolon
DECL|member|next
r_struct
id|jffs_node_ref
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* The struct jffs_fm represents a chunk of data in the flash memory.  */
DECL|struct|jffs_fm
r_struct
id|jffs_fm
(brace
DECL|member|offset
id|__u32
id|offset
suffix:semicolon
DECL|member|size
id|__u32
id|size
suffix:semicolon
DECL|member|prev
r_struct
id|jffs_fm
op_star
id|prev
suffix:semicolon
DECL|member|next
r_struct
id|jffs_fm
op_star
id|next
suffix:semicolon
DECL|member|nodes
r_struct
id|jffs_node_ref
op_star
id|nodes
suffix:semicolon
multiline_comment|/* USED if != 0.  */
)brace
suffix:semicolon
DECL|struct|jffs_fmcontrol
r_struct
id|jffs_fmcontrol
(brace
DECL|member|flash_start
id|__u32
id|flash_start
suffix:semicolon
DECL|member|flash_size
id|__u32
id|flash_size
suffix:semicolon
DECL|member|used_size
id|__u32
id|used_size
suffix:semicolon
DECL|member|dirty_size
id|__u32
id|dirty_size
suffix:semicolon
DECL|member|free_size
id|__u32
id|free_size
suffix:semicolon
DECL|member|sector_size
id|__u32
id|sector_size
suffix:semicolon
DECL|member|min_free_size
id|__u32
id|min_free_size
suffix:semicolon
multiline_comment|/* The minimum free space needed to be able&n;&t;&t;&t;&t; to perform garbage collections.  */
DECL|member|max_chunk_size
id|__u32
id|max_chunk_size
suffix:semicolon
multiline_comment|/* The maximum size of a chunk of data.  */
DECL|member|mtd
r_struct
id|mtd_info
op_star
id|mtd
suffix:semicolon
DECL|member|c
r_struct
id|jffs_control
op_star
id|c
suffix:semicolon
DECL|member|head
r_struct
id|jffs_fm
op_star
id|head
suffix:semicolon
DECL|member|tail
r_struct
id|jffs_fm
op_star
id|tail
suffix:semicolon
DECL|member|head_extra
r_struct
id|jffs_fm
op_star
id|head_extra
suffix:semicolon
DECL|member|tail_extra
r_struct
id|jffs_fm
op_star
id|tail_extra
suffix:semicolon
DECL|member|biglock
r_struct
id|semaphore
id|biglock
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Notice the two members head_extra and tail_extra in the jffs_control&n;   structure above. Those are only used during the scanning of the flash&n;   memory; while the file system is being built. If the data in the flash&n;   memory is organized like&n;&n;      +----------------+------------------+----------------+&n;      |  USED / DIRTY  |       FREE       |  USED / DIRTY  |&n;      +----------------+------------------+----------------+&n;&n;   then the scan is split in two parts. The first scanned part of the&n;   flash memory is organized through the members head and tail. The&n;   second scanned part is organized with head_extra and tail_extra. When&n;   the scan is completed, the two lists are merged together. The jffs_fm&n;   struct that head_extra references is the logical beginning of the&n;   flash memory so it will be referenced by the head member.  */
r_struct
id|jffs_fmcontrol
op_star
id|jffs_build_begin
c_func
(paren
r_struct
id|jffs_control
op_star
id|c
comma
id|kdev_t
id|dev
)paren
suffix:semicolon
r_void
id|jffs_build_end
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
)paren
suffix:semicolon
r_void
id|jffs_cleanup_fmcontrol
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
)paren
suffix:semicolon
r_int
id|jffs_fmalloc
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
comma
id|__u32
id|size
comma
r_struct
id|jffs_node
op_star
id|node
comma
r_struct
id|jffs_fm
op_star
op_star
id|result
)paren
suffix:semicolon
r_int
id|jffs_fmfree
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
comma
r_struct
id|jffs_fm
op_star
id|fm
comma
r_struct
id|jffs_node
op_star
id|node
)paren
suffix:semicolon
id|__u32
id|jffs_free_size1
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
)paren
suffix:semicolon
id|__u32
id|jffs_free_size2
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
)paren
suffix:semicolon
r_void
id|jffs_sync_erase
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
comma
r_int
id|erased_size
)paren
suffix:semicolon
r_struct
id|jffs_fm
op_star
id|jffs_cut_node
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
comma
id|__u32
id|size
)paren
suffix:semicolon
r_struct
id|jffs_node
op_star
id|jffs_get_oldest_node
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
)paren
suffix:semicolon
r_int
id|jffs_erasable_size
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
)paren
suffix:semicolon
r_struct
id|jffs_fm
op_star
id|jffs_fmalloced
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
comma
id|__u32
id|offset
comma
id|__u32
id|size
comma
r_struct
id|jffs_node
op_star
id|node
)paren
suffix:semicolon
r_int
id|jffs_add_node
c_func
(paren
r_struct
id|jffs_node
op_star
id|node
)paren
suffix:semicolon
r_void
id|jffs_fmfree_partly
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
comma
r_struct
id|jffs_fm
op_star
id|fm
comma
id|__u32
id|size
)paren
suffix:semicolon
r_void
id|jffs_print_fmcontrol
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
)paren
suffix:semicolon
r_void
id|jffs_print_fm
c_func
(paren
r_struct
id|jffs_fm
op_star
id|fm
)paren
suffix:semicolon
r_void
id|jffs_print_node_ref
c_func
(paren
r_struct
id|jffs_node_ref
op_star
id|ref
)paren
suffix:semicolon
macro_line|#endif /* __LINUX_JFFS_FM_H__  */
eof
