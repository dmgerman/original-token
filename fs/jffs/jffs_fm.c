multiline_comment|/*&n; * JFFS -- Journaling Flash File System, Linux implementation.&n; *&n; * Copyright (C) 1999, 2000  Axis Communications AB.&n; *&n; * Created by Finn Hakansson &lt;finn@axis.com&gt;.&n; *&n; * This is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * $Id: jffs_fm.c,v 1.18 2000/08/21 10:41:45 dwmw2 Exp $&n; *&n; * Ported to Linux 2.3.x and MTD:&n; * Copyright (C) 2000  Alexander Larsson (alex@cendio.se), Cendio Systems AB&n; *&n; */
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/jffs.h&gt;
macro_line|#include &quot;jffs_fm.h&quot;
macro_line|#if defined(JFFS_MARK_OBSOLETE) &amp;&amp; JFFS_MARK_OBSOLETE
r_static
r_int
id|jffs_mark_obsolete
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
comma
id|__u32
id|fm_offset
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* This function creates a new shiny flash memory control structure.  */
r_struct
id|jffs_fmcontrol
op_star
DECL|function|jffs_build_begin
id|jffs_build_begin
c_func
(paren
r_struct
id|jffs_control
op_star
id|c
comma
id|kdev_t
id|dev
)paren
(brace
r_struct
id|jffs_fmcontrol
op_star
id|fmc
suffix:semicolon
r_struct
id|mtd_info
op_star
id|mtd
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_build_begin()&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|fmc
op_assign
(paren
r_struct
id|jffs_fmcontrol
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs_fmcontrol
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fmc
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_build_begin(): Allocation of &quot;
l_string|&quot;struct jffs_fmcontrol failed!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
(paren
r_struct
id|jffs_fmcontrol
op_star
)paren
l_int|0
suffix:semicolon
)brace
id|DJM
c_func
(paren
id|no_jffs_fmcontrol
op_increment
)paren
suffix:semicolon
id|mtd
op_assign
id|get_mtd_device
c_func
(paren
l_int|NULL
comma
id|MINOR
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mtd
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Retrieve the size of the flash memory.  */
id|fmc-&gt;flash_start
op_assign
l_int|0
suffix:semicolon
id|fmc-&gt;flash_size
op_assign
id|mtd-&gt;size
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  fmc-&gt;flash_start = 0x%08x&bslash;n&quot;
comma
id|fmc-&gt;flash_start
)paren
)paren
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;  fmc-&gt;flash_size = %d bytes&bslash;n&quot;
comma
id|fmc-&gt;flash_size
)paren
)paren
suffix:semicolon
id|fmc-&gt;used_size
op_assign
l_int|0
suffix:semicolon
id|fmc-&gt;dirty_size
op_assign
l_int|0
suffix:semicolon
id|fmc-&gt;free_size
op_assign
id|mtd-&gt;size
suffix:semicolon
id|fmc-&gt;sector_size
op_assign
id|mtd-&gt;erasesize
suffix:semicolon
id|fmc-&gt;max_chunk_size
op_assign
id|fmc-&gt;sector_size
op_rshift
l_int|1
suffix:semicolon
multiline_comment|/* min_free_size:&n;&t;   1 sector, obviously.&n;&t;   + 1 x max_chunk_size, for when a nodes overlaps the end of a sector&n;&t;   + 1 x max_chunk_size again, which ought to be enough to handle &n;&t;&t;   the case where a rename causes a name to grow, and GC has&n;&t;&t;   to write out larger nodes than the ones it&squot;s obsoleting.&n;&t;&t;   We should fix it so it doesn&squot;t have to write the name&n;&t;&t;   _every_ time. Later.&n;&t;*/
id|fmc-&gt;min_free_size
op_assign
id|fmc-&gt;sector_size
op_lshift
l_int|1
suffix:semicolon
id|fmc-&gt;mtd
op_assign
id|mtd
suffix:semicolon
id|fmc-&gt;c
op_assign
id|c
suffix:semicolon
id|fmc-&gt;head
op_assign
l_int|0
suffix:semicolon
id|fmc-&gt;tail
op_assign
l_int|0
suffix:semicolon
id|fmc-&gt;head_extra
op_assign
l_int|0
suffix:semicolon
id|fmc-&gt;tail_extra
op_assign
l_int|0
suffix:semicolon
id|init_MUTEX
c_func
(paren
op_amp
id|fmc-&gt;biglock
)paren
suffix:semicolon
r_return
id|fmc
suffix:semicolon
)brace
multiline_comment|/* When the flash memory scan has completed, this function should be called&n;   before use of the control structure.  */
r_void
DECL|function|jffs_build_end
id|jffs_build_end
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
)paren
(brace
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_build_end()&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fmc-&gt;head
)paren
(brace
id|fmc-&gt;head
op_assign
id|fmc-&gt;head_extra
suffix:semicolon
id|fmc-&gt;tail
op_assign
id|fmc-&gt;tail_extra
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|fmc-&gt;head_extra
)paren
(brace
id|fmc-&gt;tail_extra-&gt;next
op_assign
id|fmc-&gt;head
suffix:semicolon
id|fmc-&gt;head-&gt;prev
op_assign
id|fmc-&gt;tail_extra
suffix:semicolon
id|fmc-&gt;head
op_assign
id|fmc-&gt;head_extra
suffix:semicolon
)brace
id|fmc-&gt;head_extra
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* These two instructions should be omitted.  */
id|fmc-&gt;tail_extra
op_assign
l_int|0
suffix:semicolon
id|D3
c_func
(paren
id|jffs_print_fmcontrol
c_func
(paren
id|fmc
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Call this function when the file system is unmounted.  This function&n;   frees all memory used by this module.  */
r_void
DECL|function|jffs_cleanup_fmcontrol
id|jffs_cleanup_fmcontrol
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
)paren
(brace
r_if
c_cond
(paren
id|fmc
)paren
(brace
r_struct
id|jffs_fm
op_star
id|cur
suffix:semicolon
r_struct
id|jffs_fm
op_star
id|next
op_assign
id|fmc-&gt;head
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cur
op_assign
id|next
)paren
)paren
(brace
id|next
op_assign
id|next-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|cur
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_fm
op_decrement
)paren
suffix:semicolon
)brace
id|put_mtd_device
c_func
(paren
id|fmc-&gt;mtd
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fmc
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_fmcontrol
op_decrement
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This function returns the size of the first chunk of free space on the&n;   flash memory.  This function will return something nonzero if the flash&n;   memory contains any free space.  */
id|__u32
DECL|function|jffs_free_size1
id|jffs_free_size1
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
)paren
(brace
id|__u32
id|head
suffix:semicolon
id|__u32
id|tail
suffix:semicolon
id|__u32
id|end
op_assign
id|fmc-&gt;flash_start
op_plus
id|fmc-&gt;flash_size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fmc-&gt;head
)paren
(brace
multiline_comment|/* There is nothing on the flash.  */
r_return
id|fmc-&gt;flash_size
suffix:semicolon
)brace
multiline_comment|/* Compute the beginning and ending of the contents of the flash.  */
id|head
op_assign
id|fmc-&gt;head-&gt;offset
suffix:semicolon
id|tail
op_assign
id|fmc-&gt;tail-&gt;offset
op_plus
id|fmc-&gt;tail-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|tail
op_eq
id|end
)paren
(brace
id|tail
op_assign
id|fmc-&gt;flash_start
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
r_else
r_if
(paren
id|tail
OG
id|end
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs_free_size1(): tail &gt; end&bslash;n&quot;
)paren
suffix:semicolon
id|tail
op_assign
id|fmc-&gt;flash_start
suffix:semicolon
)brace
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head
op_le
id|tail
)paren
(brace
r_return
id|end
op_minus
id|tail
suffix:semicolon
)brace
r_else
(brace
r_return
id|head
op_minus
id|tail
suffix:semicolon
)brace
)brace
multiline_comment|/* This function will return something nonzero in case there are two free&n;   areas on the flash.  Like this:&n;&n;     +----------------+------------------+----------------+&n;     |     FREE 1     |   USED / DIRTY   |     FREE 2     |&n;     +----------------+------------------+----------------+&n;       fmc-&gt;head -----^&n;       fmc-&gt;tail ------------------------^&n;&n;   The value returned, will be the size of the first empty area on the&n;   flash, in this case marked &quot;FREE 1&quot;.  */
id|__u32
DECL|function|jffs_free_size2
id|jffs_free_size2
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
)paren
(brace
r_if
c_cond
(paren
id|fmc-&gt;head
)paren
(brace
id|__u32
id|head
op_assign
id|fmc-&gt;head-&gt;offset
suffix:semicolon
id|__u32
id|tail
op_assign
id|fmc-&gt;tail-&gt;offset
op_plus
id|fmc-&gt;tail-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|tail
op_eq
id|fmc-&gt;flash_start
op_plus
id|fmc-&gt;flash_size
)paren
(brace
id|tail
op_assign
id|fmc-&gt;flash_start
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tail
op_ge
id|head
)paren
(brace
r_return
id|head
op_minus
id|fmc-&gt;flash_start
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Allocate a chunk of flash memory.  If there is enough space on the&n;   device, a reference to the associated node is stored in the jffs_fm&n;   struct.  */
r_int
DECL|function|jffs_fmalloc
id|jffs_fmalloc
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
comma
id|__u32
id|size
comma
r_struct
id|jffs_node
op_star
id|node
comma
r_struct
id|jffs_fm
op_star
op_star
id|result
)paren
(brace
r_struct
id|jffs_fm
op_star
id|fm
suffix:semicolon
id|__u32
id|free_chunk_size1
suffix:semicolon
id|__u32
id|free_chunk_size2
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_fmalloc(): fmc = 0x%p, size = %d, &quot;
l_string|&quot;node = 0x%p&bslash;n&quot;
comma
id|fmc
comma
id|size
comma
id|node
)paren
)paren
suffix:semicolon
op_star
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|fm
op_assign
(paren
r_struct
id|jffs_fm
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs_fm
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_fmalloc(): kmalloc() failed! (fm)&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|DJM
c_func
(paren
id|no_jffs_fm
op_increment
)paren
suffix:semicolon
id|free_chunk_size1
op_assign
id|jffs_free_size1
c_func
(paren
id|fmc
)paren
suffix:semicolon
id|free_chunk_size2
op_assign
id|jffs_free_size2
c_func
(paren
id|fmc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free_chunk_size1
op_plus
id|free_chunk_size2
op_ne
id|fmc-&gt;free_size
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Free size accounting screwed&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;free_chunk_size1 == 0x%x, free_chunk_size2 == 0x%x, fmc-&gt;free_size == 0x%x&bslash;n&quot;
comma
id|free_chunk_size1
comma
id|free_chunk_size2
comma
id|fmc-&gt;free_size
)paren
suffix:semicolon
)brace
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_fmalloc(): free_chunk_size1 = %u, &quot;
l_string|&quot;free_chunk_size2 = %u&bslash;n&quot;
comma
id|free_chunk_size1
comma
id|free_chunk_size2
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_le
id|free_chunk_size1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|fm-&gt;nodes
op_assign
(paren
r_struct
id|jffs_node_ref
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs_node_ref
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_fmalloc(): kmalloc() failed! &quot;
l_string|&quot;(node_ref)&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fm
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_fm
op_decrement
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|DJM
c_func
(paren
id|no_jffs_node_ref
op_increment
)paren
suffix:semicolon
id|fm-&gt;nodes-&gt;node
op_assign
id|node
suffix:semicolon
id|fm-&gt;nodes-&gt;next
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fmc-&gt;tail
)paren
(brace
id|fm-&gt;offset
op_assign
id|fmc-&gt;tail-&gt;offset
op_plus
id|fmc-&gt;tail-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|fm-&gt;offset
op_eq
id|fmc-&gt;flash_start
op_plus
id|fmc-&gt;flash_size
)paren
(brace
id|fm-&gt;offset
op_assign
id|fmc-&gt;flash_start
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
r_else
r_if
(paren
id|fm-&gt;offset
OG
id|fmc-&gt;flash_start
op_plus
id|fmc-&gt;flash_size
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs_fmalloc(): &quot;
l_string|&quot;offset &gt; flash_end&bslash;n&quot;
)paren
suffix:semicolon
id|fm-&gt;offset
op_assign
id|fmc-&gt;flash_start
suffix:semicolon
)brace
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* There don&squot;t have to be files in the file&n;&t;&t;&t;   system yet.  */
id|fm-&gt;offset
op_assign
id|fmc-&gt;flash_start
suffix:semicolon
)brace
id|fm-&gt;size
op_assign
id|size
suffix:semicolon
id|fmc-&gt;free_size
op_sub_assign
id|size
suffix:semicolon
id|fmc-&gt;used_size
op_add_assign
id|size
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|size
OG
id|free_chunk_size2
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;JFFS: Tried to allocate a too &quot;
l_string|&quot;large flash memory chunk. (size = %u)&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fm
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_fm
op_decrement
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_else
(brace
id|fm-&gt;offset
op_assign
id|fmc-&gt;tail-&gt;offset
op_plus
id|fmc-&gt;tail-&gt;size
suffix:semicolon
id|fm-&gt;size
op_assign
id|free_chunk_size1
suffix:semicolon
id|fm-&gt;nodes
op_assign
l_int|0
suffix:semicolon
id|fmc-&gt;free_size
op_sub_assign
id|fm-&gt;size
suffix:semicolon
id|fmc-&gt;dirty_size
op_add_assign
id|fm-&gt;size
suffix:semicolon
multiline_comment|/* Changed by simonk. This seemingly fixes a &n;&t;&t;&t;&t;&t;&t;bug that caused infinite garbage collection.&n;&t;&t;&t;&t;&t;&t;It previously set fmc-&gt;dirty_size to size (which is the&n;&t;&t;&t;&t;&t;&t;size of the requested chunk).&n;&t;&t;&t;&t;&t;     */
)brace
id|fm-&gt;next
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fmc-&gt;head
)paren
(brace
id|fm-&gt;prev
op_assign
l_int|0
suffix:semicolon
id|fmc-&gt;head
op_assign
id|fm
suffix:semicolon
id|fmc-&gt;tail
op_assign
id|fm
suffix:semicolon
)brace
r_else
(brace
id|fm-&gt;prev
op_assign
id|fmc-&gt;tail
suffix:semicolon
id|fmc-&gt;tail-&gt;next
op_assign
id|fm
suffix:semicolon
id|fmc-&gt;tail
op_assign
id|fm
suffix:semicolon
)brace
id|D3
c_func
(paren
id|jffs_print_fmcontrol
c_func
(paren
id|fmc
)paren
)paren
suffix:semicolon
id|D3
c_func
(paren
id|jffs_print_fm
c_func
(paren
id|fm
)paren
)paren
suffix:semicolon
op_star
id|result
op_assign
id|fm
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The on-flash space is not needed anymore by the passed node.  Remove&n;   the reference to the node from the node list.  If the data chunk in&n;   the flash memory isn&squot;t used by any more nodes anymore (fm-&gt;nodes == 0),&n;   then mark that chunk as dirty.  */
r_int
DECL|function|jffs_fmfree
id|jffs_fmfree
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
comma
r_struct
id|jffs_fm
op_star
id|fm
comma
r_struct
id|jffs_node
op_star
id|node
)paren
(brace
r_struct
id|jffs_node_ref
op_star
id|ref
suffix:semicolon
r_struct
id|jffs_node_ref
op_star
id|prev
suffix:semicolon
id|ASSERT
c_func
(paren
r_int
id|del
op_assign
l_int|0
)paren
suffix:semicolon
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_fmfree(): node-&gt;ino = %u, node-&gt;version = %u&bslash;n&quot;
comma
id|node-&gt;ino
comma
id|node-&gt;version
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
r_if
(paren
op_logical_neg
id|fmc
op_logical_or
op_logical_neg
id|fm
op_logical_or
op_logical_neg
id|fm-&gt;nodes
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;jffs_fmfree(): fmc: 0x%p, fm: 0x%p, &quot;
l_string|&quot;fm-&gt;nodes: 0x%p&bslash;n&quot;
comma
id|fmc
comma
id|fm
comma
(paren
id|fm
ques
c_cond
id|fm-&gt;nodes
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)paren
suffix:semicolon
multiline_comment|/* Find the reference to the node that is going to be removed&n;&t;   and remove it.  */
r_for
c_loop
(paren
id|ref
op_assign
id|fm-&gt;nodes
comma
id|prev
op_assign
l_int|0
suffix:semicolon
id|ref
suffix:semicolon
id|ref
op_assign
id|ref-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|ref-&gt;node
op_eq
id|node
)paren
(brace
r_if
c_cond
(paren
id|prev
)paren
(brace
id|prev-&gt;next
op_assign
id|ref-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|fm-&gt;nodes
op_assign
id|ref-&gt;next
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|ref
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_node_ref
op_decrement
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
id|del
op_assign
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|prev
op_assign
id|ref
suffix:semicolon
)brace
multiline_comment|/* If the data chunk in the flash memory isn&squot;t used anymore&n;&t;   just mark it as obsolete.  */
r_if
c_cond
(paren
op_logical_neg
id|fm-&gt;nodes
)paren
(brace
multiline_comment|/* No node uses this chunk so let&squot;s remove it.  */
id|fmc-&gt;used_size
op_sub_assign
id|fm-&gt;size
suffix:semicolon
id|fmc-&gt;dirty_size
op_add_assign
id|fm-&gt;size
suffix:semicolon
macro_line|#if defined(JFFS_MARK_OBSOLETE) &amp;&amp; JFFS_MARK_OBSOLETE
r_if
c_cond
(paren
id|jffs_mark_obsolete
c_func
(paren
id|fmc
comma
id|fm-&gt;offset
)paren
OL
l_int|0
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_fmfree(): Failed to mark an on-flash &quot;
l_string|&quot;node obsolete!&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
id|fmc-&gt;c-&gt;sb-&gt;s_dirt
op_assign
l_int|1
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
r_if
(paren
op_logical_neg
id|del
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;***jffs_fmfree(): &quot;
l_string|&quot;Didn&squot;t delete any node reference!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This allocation function is used during the initialization of&n;   the file system.  */
r_struct
id|jffs_fm
op_star
DECL|function|jffs_fmalloced
id|jffs_fmalloced
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
comma
id|__u32
id|offset
comma
id|__u32
id|size
comma
r_struct
id|jffs_node
op_star
id|node
)paren
(brace
r_struct
id|jffs_fm
op_star
id|fm
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_fmalloced()&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|fm
op_assign
(paren
r_struct
id|jffs_fm
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs_fm
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_fmalloced(0x%p, %u, %u, 0x%p): failed!&bslash;n&quot;
comma
id|fmc
comma
id|offset
comma
id|size
comma
id|node
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DJM
c_func
(paren
id|no_jffs_fm
op_increment
)paren
suffix:semicolon
id|fm-&gt;offset
op_assign
id|offset
suffix:semicolon
id|fm-&gt;size
op_assign
id|size
suffix:semicolon
id|fm-&gt;prev
op_assign
l_int|0
suffix:semicolon
id|fm-&gt;next
op_assign
l_int|0
suffix:semicolon
id|fm-&gt;nodes
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|node
)paren
(brace
multiline_comment|/* `node&squot; exists and it should be associated with the&n;&t;&t;    jffs_fm structure `fm&squot;.  */
r_if
c_cond
(paren
op_logical_neg
(paren
id|fm-&gt;nodes
op_assign
(paren
r_struct
id|jffs_node_ref
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs_node_ref
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_fmalloced(): !fm-&gt;nodes&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fm
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_fm
op_decrement
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DJM
c_func
(paren
id|no_jffs_node_ref
op_increment
)paren
suffix:semicolon
id|fm-&gt;nodes-&gt;node
op_assign
id|node
suffix:semicolon
id|fm-&gt;nodes-&gt;next
op_assign
l_int|0
suffix:semicolon
id|fmc-&gt;used_size
op_add_assign
id|size
suffix:semicolon
id|fmc-&gt;free_size
op_sub_assign
id|size
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If there is no node, then this is just a chunk of dirt.  */
id|fmc-&gt;dirty_size
op_add_assign
id|size
suffix:semicolon
id|fmc-&gt;free_size
op_sub_assign
id|size
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fmc-&gt;head_extra
)paren
(brace
id|fm-&gt;prev
op_assign
id|fmc-&gt;tail_extra
suffix:semicolon
id|fmc-&gt;tail_extra-&gt;next
op_assign
id|fm
suffix:semicolon
id|fmc-&gt;tail_extra
op_assign
id|fm
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|fmc-&gt;head
)paren
(brace
id|fmc-&gt;head
op_assign
id|fm
suffix:semicolon
id|fmc-&gt;tail
op_assign
id|fm
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|fmc-&gt;tail-&gt;offset
op_plus
id|fmc-&gt;tail-&gt;size
OL
id|offset
)paren
(brace
id|fmc-&gt;head_extra
op_assign
id|fm
suffix:semicolon
id|fmc-&gt;tail_extra
op_assign
id|fm
suffix:semicolon
)brace
r_else
(brace
id|fm-&gt;prev
op_assign
id|fmc-&gt;tail
suffix:semicolon
id|fmc-&gt;tail-&gt;next
op_assign
id|fm
suffix:semicolon
id|fmc-&gt;tail
op_assign
id|fm
suffix:semicolon
)brace
id|D3
c_func
(paren
id|jffs_print_fmcontrol
c_func
(paren
id|fmc
)paren
)paren
suffix:semicolon
id|D3
c_func
(paren
id|jffs_print_fm
c_func
(paren
id|fm
)paren
)paren
suffix:semicolon
r_return
id|fm
suffix:semicolon
)brace
multiline_comment|/* Add a new node to an already existing jffs_fm struct.  */
r_int
DECL|function|jffs_add_node
id|jffs_add_node
c_func
(paren
r_struct
id|jffs_node
op_star
id|node
)paren
(brace
r_struct
id|jffs_node_ref
op_star
id|ref
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_add_node(): ino = %u&bslash;n&quot;
comma
id|node-&gt;ino
)paren
)paren
suffix:semicolon
id|ref
op_assign
(paren
r_struct
id|jffs_node_ref
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|jffs_node_ref
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ref
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_node_ref
op_increment
)paren
suffix:semicolon
id|ref-&gt;node
op_assign
id|node
suffix:semicolon
id|ref-&gt;next
op_assign
id|node-&gt;fm-&gt;nodes
suffix:semicolon
id|node-&gt;fm-&gt;nodes
op_assign
id|ref
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Free a part of some allocated space.  */
r_void
DECL|function|jffs_fmfree_partly
id|jffs_fmfree_partly
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
comma
r_struct
id|jffs_fm
op_star
id|fm
comma
id|__u32
id|size
)paren
(brace
id|D1
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;***jffs_fmfree_partly(): fm = 0x%p, fm-&gt;nodes = 0x%p, &quot;
l_string|&quot;fm-&gt;nodes-&gt;node-&gt;ino = %u, size = %u&bslash;n&quot;
comma
id|fm
comma
(paren
id|fm
ques
c_cond
id|fm-&gt;nodes
suffix:colon
l_int|0
)paren
comma
(paren
op_logical_neg
id|fm
ques
c_cond
l_int|0
suffix:colon
(paren
op_logical_neg
id|fm-&gt;nodes
ques
c_cond
l_int|0
suffix:colon
id|fm-&gt;nodes-&gt;node-&gt;ino
)paren
)paren
comma
id|size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fm-&gt;nodes
)paren
(brace
id|kfree
c_func
(paren
id|fm-&gt;nodes
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_node_ref
op_decrement
)paren
suffix:semicolon
id|fm-&gt;nodes
op_assign
l_int|0
suffix:semicolon
)brace
id|fmc-&gt;used_size
op_sub_assign
id|fm-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|fm
op_eq
id|fmc-&gt;tail
)paren
(brace
id|fm-&gt;size
op_sub_assign
id|size
suffix:semicolon
)brace
id|fmc-&gt;dirty_size
op_add_assign
id|fm-&gt;size
suffix:semicolon
)brace
multiline_comment|/* Find the jffs_fm struct that contains the end of the data chunk that&n;   begins at the logical beginning of the flash memory and spans `size&squot;&n;   bytes.  If we want to erase a sector of the flash memory, we use this&n;   function to find where the sector limit cuts a chunk of data.  */
r_struct
id|jffs_fm
op_star
DECL|function|jffs_cut_node
id|jffs_cut_node
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
comma
id|__u32
id|size
)paren
(brace
r_struct
id|jffs_fm
op_star
id|fm
suffix:semicolon
id|__u32
id|pos
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|ASSERT
c_func
(paren
r_if
(paren
op_logical_neg
id|fmc
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;jffs_cut_node(): fmc == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)paren
suffix:semicolon
id|fm
op_assign
id|fmc-&gt;head
suffix:semicolon
r_while
c_loop
(paren
id|fm
)paren
(brace
id|pos
op_add_assign
id|fm-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|size
)paren
(brace
id|fm
op_assign
id|fm-&gt;next
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pos
OG
id|size
)paren
(brace
r_break
suffix:semicolon
)brace
r_else
(brace
id|fm
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|fm
suffix:semicolon
)brace
multiline_comment|/* Move the head of the fmc structures and delete the obsolete parts.  */
r_void
DECL|function|jffs_sync_erase
id|jffs_sync_erase
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
comma
r_int
id|erased_size
)paren
(brace
r_struct
id|jffs_fm
op_star
id|fm
suffix:semicolon
r_struct
id|jffs_fm
op_star
id|del
suffix:semicolon
id|ASSERT
c_func
(paren
r_if
(paren
op_logical_neg
id|fmc
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;jffs_sync_erase(): fmc == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)paren
suffix:semicolon
id|fmc-&gt;dirty_size
op_sub_assign
id|erased_size
suffix:semicolon
id|fmc-&gt;free_size
op_add_assign
id|erased_size
suffix:semicolon
r_for
c_loop
(paren
id|fm
op_assign
id|fmc-&gt;head
suffix:semicolon
id|fm
op_logical_and
(paren
id|erased_size
OG
l_int|0
)paren
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|erased_size
op_ge
id|fm-&gt;size
)paren
(brace
id|erased_size
op_sub_assign
id|fm-&gt;size
suffix:semicolon
id|del
op_assign
id|fm
suffix:semicolon
id|fm
op_assign
id|fm-&gt;next
suffix:semicolon
id|fm-&gt;prev
op_assign
l_int|0
suffix:semicolon
id|fmc-&gt;head
op_assign
id|fm
suffix:semicolon
id|kfree
c_func
(paren
id|del
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_fm
op_decrement
)paren
suffix:semicolon
)brace
r_else
(brace
id|fm-&gt;size
op_sub_assign
id|erased_size
suffix:semicolon
id|fm-&gt;offset
op_add_assign
id|erased_size
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Return the oldest used node in the flash memory.  */
r_struct
id|jffs_node
op_star
DECL|function|jffs_get_oldest_node
id|jffs_get_oldest_node
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
)paren
(brace
r_struct
id|jffs_fm
op_star
id|fm
suffix:semicolon
r_struct
id|jffs_node_ref
op_star
id|nref
suffix:semicolon
r_struct
id|jffs_node
op_star
id|node
op_assign
l_int|0
suffix:semicolon
id|ASSERT
c_func
(paren
r_if
(paren
op_logical_neg
id|fmc
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;jffs_get_oldest_node(): fmc == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)paren
suffix:semicolon
r_for
c_loop
(paren
id|fm
op_assign
id|fmc-&gt;head
suffix:semicolon
id|fm
op_logical_and
op_logical_neg
id|fm-&gt;nodes
suffix:semicolon
id|fm
op_assign
id|fm-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fm
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The oldest node is the last one in the reference list.  This list&n;&t;   shouldn&squot;t be too long; just one or perhaps two elements.  */
r_for
c_loop
(paren
id|nref
op_assign
id|fm-&gt;nodes
suffix:semicolon
id|nref
suffix:semicolon
id|nref
op_assign
id|nref-&gt;next
)paren
(brace
id|node
op_assign
id|nref-&gt;node
suffix:semicolon
)brace
id|D2
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_get_oldest_node(): ino = %u, version = %u&bslash;n&quot;
comma
(paren
id|node
ques
c_cond
id|node-&gt;ino
suffix:colon
l_int|0
)paren
comma
(paren
id|node
ques
c_cond
id|node-&gt;version
suffix:colon
l_int|0
)paren
)paren
)paren
suffix:semicolon
r_return
id|node
suffix:semicolon
)brace
macro_line|#if defined(JFFS_MARK_OBSOLETE) &amp;&amp; JFFS_MARK_OBSOLETE
multiline_comment|/* Mark an on-flash node as obsolete.&n;&n;   Note that this is just an optimization that isn&squot;t necessary for the&n;   filesystem to work.  */
r_static
r_int
DECL|function|jffs_mark_obsolete
id|jffs_mark_obsolete
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
comma
id|__u32
id|fm_offset
)paren
(brace
multiline_comment|/* The `accurate_pos&squot; holds the position of the accurate byte&n;&t;   in the jffs_raw_inode structure that we are going to mark&n;&t;   as obsolete.  */
id|__u32
id|accurate_pos
op_assign
id|fm_offset
op_plus
id|JFFS_RAW_INODE_ACCURATE_OFFSET
suffix:semicolon
r_int
r_char
id|zero
op_assign
l_int|0x00
suffix:semicolon
r_int
id|len
suffix:semicolon
id|D3
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;jffs_mark_obsolete(): accurate_pos = %u&bslash;n&quot;
comma
id|accurate_pos
)paren
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
r_if
(paren
op_logical_neg
id|fmc
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;jffs_mark_obsolete(): fmc == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)paren
suffix:semicolon
multiline_comment|/* Write 0x00 to the raw inode&squot;s accurate member.  Don&squot;t care&n;&t;   about the return value.  */
id|MTD_WRITE
c_func
(paren
id|fmc-&gt;mtd
comma
id|accurate_pos
comma
l_int|1
comma
op_amp
id|len
comma
op_amp
id|zero
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* JFFS_MARK_OBSOLETE  */
multiline_comment|/* check if it&squot;s possible to erase the wanted range, and if not, return&n; * the range that IS erasable, or a negative error code.&n; */
r_int
DECL|function|jffs_flash_erasable_size
id|jffs_flash_erasable_size
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|__u32
id|offset
comma
id|__u32
id|size
)paren
(brace
id|u_long
id|ssize
suffix:semicolon
multiline_comment|/* assume that sector size for a partition is constant even&n;&t; * if it spans more than one chip (you usually put the same&n;&t; * type of chips in a system)&n;&t; */
id|ssize
op_assign
id|mtd-&gt;erasesize
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_mod
id|ssize
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs_flash_erasable_size() given non-aligned offset %x (erasesize %lx)&bslash;n&quot;
comma
id|offset
comma
id|ssize
)paren
suffix:semicolon
multiline_comment|/* The offset is not sector size aligned.  */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|offset
OG
id|mtd-&gt;size
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs_flash_erasable_size given offset off the end of device (%x &gt; %lx)&bslash;n&quot;
comma
id|offset
comma
id|mtd-&gt;size
)paren
suffix:semicolon
r_return
op_minus
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|offset
op_plus
id|size
OG
id|mtd-&gt;size
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;jffs_flash_erasable_size() given length which runs off the end of device (ofs %x + len %x = %x, &gt; %lx)&bslash;n&quot;
comma
id|offset
comma
id|size
comma
id|offset
op_plus
id|size
comma
id|mtd-&gt;size
)paren
suffix:semicolon
r_return
op_minus
l_int|3
suffix:semicolon
)brace
r_return
(paren
id|size
op_div
id|ssize
)paren
op_star
id|ssize
suffix:semicolon
)brace
multiline_comment|/* How much dirty flash memory is possible to erase at the moment?  */
r_int
DECL|function|jffs_erasable_size
id|jffs_erasable_size
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
)paren
(brace
r_struct
id|jffs_fm
op_star
id|fm
suffix:semicolon
id|__u32
id|size
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ASSERT
c_func
(paren
r_if
(paren
op_logical_neg
id|fmc
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;jffs_erasable_size(): fmc = NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fmc-&gt;head
)paren
(brace
multiline_comment|/* The flash memory is totally empty. No nodes. No dirt.&n;&t;&t;   Just return.  */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Calculate how much space that is dirty.  */
r_for
c_loop
(paren
id|fm
op_assign
id|fmc-&gt;head
suffix:semicolon
id|fm
op_logical_and
op_logical_neg
id|fm-&gt;nodes
suffix:semicolon
id|fm
op_assign
id|fm-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|size
op_logical_and
id|fm-&gt;offset
op_eq
id|fmc-&gt;flash_start
)paren
(brace
multiline_comment|/* We have reached the beginning of the flash.  */
r_break
suffix:semicolon
)brace
id|size
op_add_assign
id|fm-&gt;size
suffix:semicolon
)brace
multiline_comment|/* Someone&squot;s signature contained this:&n;&t;   There&squot;s a fine line between fishing and just standing on&n;&t;   the shore like an idiot...  */
id|ret
op_assign
id|jffs_flash_erasable_size
c_func
(paren
id|fmc-&gt;mtd
comma
id|fmc-&gt;head-&gt;offset
op_minus
id|fmc-&gt;flash_start
comma
id|size
)paren
suffix:semicolon
id|ASSERT
c_func
(paren
r_if
(paren
id|ret
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;jffs_erasable_size: flash_erasable_size() &quot;
l_string|&quot;returned something less than zero (%ld).&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;jffs_erasable_size: offset = 0x%08x&bslash;n&quot;
comma
id|fmc-&gt;head-&gt;offset
op_minus
id|fmc-&gt;flash_start
)paren
suffix:semicolon
)brace
)paren
suffix:semicolon
multiline_comment|/* If there is dirt on the flash (which is the reason to why&n;&t;   this function was called in the first place) but no space is&n;&t;   possible to erase right now, the initial part of the list of&n;&t;   jffs_fm structs, that hold place for dirty space, could perhaps&n;&t;   be shortened.  The list&squot;s initial &quot;dirty&quot; elements are merged&n;&t;   into just one large dirty jffs_fm struct.  This operation must&n;&t;   only be performed if nothing is possible to erase.  Otherwise,&n;&t;   jffs_clear_end_of_node() won&squot;t work as expected.  */
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
(brace
r_struct
id|jffs_fm
op_star
id|head
op_assign
id|fmc-&gt;head
suffix:semicolon
r_struct
id|jffs_fm
op_star
id|del
suffix:semicolon
multiline_comment|/* While there are two dirty nodes beside each other.*/
r_while
c_loop
(paren
id|head-&gt;nodes
op_eq
l_int|0
op_logical_and
id|head-&gt;next
op_logical_and
id|head-&gt;next-&gt;nodes
op_eq
l_int|0
)paren
(brace
id|del
op_assign
id|head-&gt;next
suffix:semicolon
id|head-&gt;size
op_add_assign
id|del-&gt;size
suffix:semicolon
id|head-&gt;next
op_assign
id|del-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|del-&gt;next
)paren
(brace
id|del-&gt;next-&gt;prev
op_assign
id|head
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|del
)paren
suffix:semicolon
id|DJM
c_func
(paren
id|no_jffs_fm
op_decrement
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|ret
op_ge
l_int|0
ques
c_cond
id|ret
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_void
DECL|function|jffs_print_fmcontrol
id|jffs_print_fmcontrol
c_func
(paren
r_struct
id|jffs_fmcontrol
op_star
id|fmc
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;struct jffs_fmcontrol: 0x%p&bslash;n&quot;
comma
id|fmc
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;{&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%08x, /* flash_start  */&bslash;n&quot;
comma
id|fmc-&gt;flash_start
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        %u, /* flash_size  */&bslash;n&quot;
comma
id|fmc-&gt;flash_size
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        %u, /* used_size  */&bslash;n&quot;
comma
id|fmc-&gt;used_size
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        %u, /* dirty_size  */&bslash;n&quot;
comma
id|fmc-&gt;dirty_size
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        %u, /* free_size  */&bslash;n&quot;
comma
id|fmc-&gt;free_size
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        %u, /* sector_size  */&bslash;n&quot;
comma
id|fmc-&gt;sector_size
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        %u, /* min_free_size  */&bslash;n&quot;
comma
id|fmc-&gt;min_free_size
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        %u, /* max_chunk_size  */&bslash;n&quot;
comma
id|fmc-&gt;max_chunk_size
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* mtd  */&bslash;n&quot;
comma
id|fmc-&gt;mtd
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* head  */    &quot;
l_string|&quot;(head-&gt;offset = 0x%08x)&bslash;n&quot;
comma
id|fmc-&gt;head
comma
(paren
id|fmc-&gt;head
ques
c_cond
id|fmc-&gt;head-&gt;offset
suffix:colon
l_int|0
)paren
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* tail  */    &quot;
l_string|&quot;(tail-&gt;offset + tail-&gt;size = 0x%08x)&bslash;n&quot;
comma
id|fmc-&gt;tail
comma
(paren
id|fmc-&gt;tail
ques
c_cond
id|fmc-&gt;tail-&gt;offset
op_plus
id|fmc-&gt;tail-&gt;size
suffix:colon
l_int|0
)paren
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* head_extra  */&bslash;n&quot;
comma
id|fmc-&gt;head_extra
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;        0x%p, /* tail_extra  */&bslash;n&quot;
comma
id|fmc-&gt;tail_extra
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;}&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|jffs_print_fm
id|jffs_print_fm
c_func
(paren
r_struct
id|jffs_fm
op_star
id|fm
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;struct jffs_fm: 0x%p&bslash;n&quot;
comma
id|fm
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;{&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;       0x%08x, /* offset  */&bslash;n&quot;
comma
id|fm-&gt;offset
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;       %u, /* size  */&bslash;n&quot;
comma
id|fm-&gt;size
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;       0x%p, /* prev  */&bslash;n&quot;
comma
id|fm-&gt;prev
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;       0x%p, /* next  */&bslash;n&quot;
comma
id|fm-&gt;next
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;       0x%p, /* nodes  */&bslash;n&quot;
comma
id|fm-&gt;nodes
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;}&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|jffs_print_node_ref
id|jffs_print_node_ref
c_func
(paren
r_struct
id|jffs_node_ref
op_star
id|ref
)paren
(brace
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;struct jffs_node_ref: 0x%p&bslash;n&quot;
comma
id|ref
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;{&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;       0x%p, /* node  */&bslash;n&quot;
comma
id|ref-&gt;node
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;       0x%p, /* next  */&bslash;n&quot;
comma
id|ref-&gt;next
)paren
)paren
suffix:semicolon
id|D
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;}&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
eof
