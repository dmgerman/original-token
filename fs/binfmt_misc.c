multiline_comment|/*&n; *  binfmt_misc.c&n; *&n; *  Copyright (C) 1997 Richard G&#xfffd;nther&n; *&n; *  binfmt_misc detects binaries via a magic or filename extension and invokes&n; *  a specified wrapper. This should obsolete binfmt_java, binfmt_em86 and&n; *  binfmt_mz.&n; *&n; *  1997-04-25 first version&n; *  [...]&n; *  1997-05-19 cleanup&n; *  1997-06-26 hpa: pass the real filename rather than argv[0]&n; *  1997-06-30 minor cleanup&n; *  1997-08-09 removed extension stripping, locking cleanup&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/binfmts.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/*&n; * We should make this work with a &quot;stub-only&quot; /proc,&n; * which would just not be able to be configured.&n; * Right now the /proc-fs support is too black and white,&n; * though, so just remind people that this should be&n; * fixed..&n; */
macro_line|#ifndef CONFIG_PROC_FS
macro_line|#error You really need /proc support for binfmt_misc. Please reconfigure!
macro_line|#endif
DECL|macro|VERBOSE_STATUS
mdefine_line|#define VERBOSE_STATUS /* undef this to save 400 bytes kernel memory */
DECL|struct|binfmt_entry
r_struct
id|binfmt_entry
(brace
DECL|member|next
r_struct
id|binfmt_entry
op_star
id|next
suffix:semicolon
DECL|member|id
r_int
id|id
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
multiline_comment|/* type, status, etc. */
DECL|member|offset
r_int
id|offset
suffix:semicolon
multiline_comment|/* offset of magic */
DECL|member|size
r_int
id|size
suffix:semicolon
multiline_comment|/* size of magic/mask */
DECL|member|magic
r_char
op_star
id|magic
suffix:semicolon
multiline_comment|/* magic or filename extension */
DECL|member|mask
r_char
op_star
id|mask
suffix:semicolon
multiline_comment|/* mask, NULL for exact match */
DECL|member|interpreter
r_char
op_star
id|interpreter
suffix:semicolon
multiline_comment|/* filename of interpreter */
DECL|member|proc_name
r_char
op_star
id|proc_name
suffix:semicolon
DECL|member|proc_dir
r_struct
id|proc_dir_entry
op_star
id|proc_dir
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|ENTRY_ENABLED
mdefine_line|#define ENTRY_ENABLED 1&t;&t;/* the old binfmt_entry.enabled */
DECL|macro|ENTRY_MAGIC
mdefine_line|#define&t;ENTRY_MAGIC 8&t;&t;/* not filename detection */
r_static
r_int
id|load_misc_binary
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|entry_proc_cleanup
c_func
(paren
r_struct
id|binfmt_entry
op_star
id|e
)paren
suffix:semicolon
r_static
r_int
id|entry_proc_setup
c_func
(paren
r_struct
id|binfmt_entry
op_star
id|e
)paren
suffix:semicolon
DECL|variable|misc_format
r_static
r_struct
id|linux_binfmt
id|misc_format
op_assign
(brace
l_int|NULL
comma
id|THIS_MODULE
comma
id|load_misc_binary
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|bm_dir
r_static
r_struct
id|proc_dir_entry
op_star
id|bm_dir
suffix:semicolon
DECL|variable|entries
r_static
r_struct
id|binfmt_entry
op_star
id|entries
suffix:semicolon
DECL|variable|free_id
r_static
r_int
id|free_id
op_assign
l_int|1
suffix:semicolon
DECL|variable|enabled
r_static
r_int
id|enabled
op_assign
l_int|1
suffix:semicolon
DECL|variable|entries_lock
r_static
id|rwlock_t
id|entries_lock
id|__attribute__
c_func
(paren
(paren
id|unused
)paren
)paren
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * Unregister one entry&n; */
DECL|function|clear_entry
r_static
r_void
id|clear_entry
c_func
(paren
r_int
id|id
)paren
(brace
r_struct
id|binfmt_entry
op_star
op_star
id|ep
comma
op_star
id|e
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|entries_lock
)paren
suffix:semicolon
id|ep
op_assign
op_amp
id|entries
suffix:semicolon
r_while
c_loop
(paren
op_star
id|ep
op_logical_and
(paren
(paren
op_star
id|ep
)paren
op_member_access_from_pointer
id|id
op_ne
id|id
)paren
)paren
id|ep
op_assign
op_amp
(paren
(paren
op_star
id|ep
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|e
op_assign
op_star
id|ep
)paren
)paren
op_star
id|ep
op_assign
id|e-&gt;next
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|entries_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
)paren
(brace
id|entry_proc_cleanup
c_func
(paren
id|e
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|e
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Clear all registered binary formats&n; */
DECL|function|clear_entries
r_static
r_void
id|clear_entries
c_func
(paren
r_void
)paren
(brace
r_struct
id|binfmt_entry
op_star
id|e
comma
op_star
id|n
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|entries_lock
)paren
suffix:semicolon
id|n
op_assign
id|entries
suffix:semicolon
id|entries
op_assign
l_int|NULL
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|entries_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|e
op_assign
id|n
)paren
)paren
(brace
id|n
op_assign
id|e-&gt;next
suffix:semicolon
id|entry_proc_cleanup
c_func
(paren
id|e
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|e
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Find entry through id and lock it&n; */
DECL|function|get_entry
r_static
r_struct
id|binfmt_entry
op_star
id|get_entry
c_func
(paren
r_int
id|id
)paren
(brace
r_struct
id|binfmt_entry
op_star
id|e
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|entries_lock
)paren
suffix:semicolon
id|e
op_assign
id|entries
suffix:semicolon
r_while
c_loop
(paren
id|e
op_logical_and
(paren
id|e-&gt;id
op_ne
id|id
)paren
)paren
id|e
op_assign
id|e-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|e
)paren
id|read_unlock
c_func
(paren
op_amp
id|entries_lock
)paren
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
multiline_comment|/*&n; * unlock entry&n; */
DECL|function|put_entry
r_static
r_inline
r_void
id|put_entry
c_func
(paren
r_struct
id|binfmt_entry
op_star
id|e
)paren
(brace
r_if
c_cond
(paren
id|e
)paren
id|read_unlock
c_func
(paren
op_amp
id|entries_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Check if we support the binfmt&n; * if we do, return the binfmt_entry, else NULL&n; * locking is done in load_misc_binary&n; */
DECL|function|check_file
r_static
r_struct
id|binfmt_entry
op_star
id|check_file
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
)paren
(brace
r_struct
id|binfmt_entry
op_star
id|e
suffix:semicolon
r_char
op_star
id|p
op_assign
id|strrchr
c_func
(paren
id|bprm-&gt;filename
comma
l_char|&squot;.&squot;
)paren
suffix:semicolon
r_int
id|j
suffix:semicolon
id|e
op_assign
id|entries
suffix:semicolon
r_while
c_loop
(paren
id|e
)paren
(brace
r_if
c_cond
(paren
id|e-&gt;flags
op_amp
id|ENTRY_ENABLED
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|e-&gt;flags
op_amp
id|ENTRY_MAGIC
)paren
)paren
(brace
r_if
c_cond
(paren
id|p
op_logical_and
op_logical_neg
id|strcmp
c_func
(paren
id|e-&gt;magic
comma
id|p
op_plus
l_int|1
)paren
)paren
r_return
id|e
suffix:semicolon
)brace
r_else
(brace
id|j
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|j
OL
id|e-&gt;size
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|bprm-&gt;buf
(braket
id|e-&gt;offset
op_plus
id|j
)braket
op_xor
id|e-&gt;magic
(braket
id|j
)braket
)paren
op_amp
(paren
id|e-&gt;mask
ques
c_cond
id|e-&gt;mask
(braket
id|j
)braket
suffix:colon
l_int|0xff
)paren
)paren
)paren
id|j
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
id|e-&gt;size
)paren
r_return
id|e
suffix:semicolon
)brace
)brace
id|e
op_assign
id|e-&gt;next
suffix:semicolon
)brace
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * the loader itself&n; */
DECL|function|load_misc_binary
r_static
r_int
id|load_misc_binary
c_func
(paren
r_struct
id|linux_binprm
op_star
id|bprm
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|binfmt_entry
op_star
id|fmt
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
r_char
id|iname
(braket
id|BINPRM_BUF_SIZE
)braket
suffix:semicolon
r_char
op_star
id|iname_addr
op_assign
id|iname
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOEXEC
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|enabled
)paren
r_goto
id|_ret
suffix:semicolon
multiline_comment|/* to keep locking time low, we copy the interpreter string */
id|read_lock
c_func
(paren
op_amp
id|entries_lock
)paren
suffix:semicolon
id|fmt
op_assign
id|check_file
c_func
(paren
id|bprm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fmt
)paren
(brace
id|strncpy
c_func
(paren
id|iname
comma
id|fmt-&gt;interpreter
comma
id|BINPRM_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|iname
(braket
id|BINPRM_BUF_SIZE
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|entries_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fmt
)paren
r_goto
id|_ret
suffix:semicolon
id|allow_write_access
c_func
(paren
id|bprm-&gt;file
)paren
suffix:semicolon
id|fput
c_func
(paren
id|bprm-&gt;file
)paren
suffix:semicolon
id|bprm-&gt;file
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Build args for interpreter */
id|remove_arg_zero
c_func
(paren
id|bprm
)paren
suffix:semicolon
id|retval
op_assign
id|copy_strings_kernel
c_func
(paren
l_int|1
comma
op_amp
id|bprm-&gt;filename
comma
id|bprm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|_ret
suffix:semicolon
id|bprm-&gt;argc
op_increment
suffix:semicolon
id|retval
op_assign
id|copy_strings_kernel
c_func
(paren
l_int|1
comma
op_amp
id|iname_addr
comma
id|bprm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|_ret
suffix:semicolon
id|bprm-&gt;argc
op_increment
suffix:semicolon
id|bprm-&gt;filename
op_assign
id|iname
suffix:semicolon
multiline_comment|/* for binfmt_script */
id|file
op_assign
id|open_exec
c_func
(paren
id|iname
)paren
suffix:semicolon
id|retval
op_assign
id|PTR_ERR
c_func
(paren
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|file
)paren
)paren
r_goto
id|_ret
suffix:semicolon
id|bprm-&gt;file
op_assign
id|file
suffix:semicolon
id|retval
op_assign
id|prepare_binprm
c_func
(paren
id|bprm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ge
l_int|0
)paren
id|retval
op_assign
id|search_binary_handler
c_func
(paren
id|bprm
comma
id|regs
)paren
suffix:semicolon
id|_ret
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * /proc handling routines&n; */
multiline_comment|/*&n; * parses and copies one argument enclosed in del from *sp to *dp,&n; * recognising the &bslash;x special.&n; * returns pointer to the copied argument or NULL in case of an&n; * error (and sets err) or null argument length.&n; */
DECL|function|copyarg
r_static
r_char
op_star
id|copyarg
c_func
(paren
r_char
op_star
op_star
id|dp
comma
r_const
r_char
op_star
op_star
id|sp
comma
r_int
op_star
id|count
comma
r_char
id|del
comma
r_int
id|special
comma
r_int
op_star
id|err
)paren
(brace
r_char
id|c
op_assign
l_int|0
comma
op_star
id|res
op_assign
op_star
id|dp
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
op_star
id|err
op_logical_and
(paren
(paren
id|c
op_assign
op_star
(paren
(paren
op_star
id|sp
)paren
op_increment
)paren
)paren
comma
(paren
op_star
id|count
)paren
op_decrement
)paren
op_logical_and
(paren
id|c
op_ne
id|del
)paren
)paren
(brace
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
r_if
c_cond
(paren
id|special
op_logical_and
(paren
op_star
op_star
id|sp
op_eq
l_char|&squot;x&squot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|isxdigit
c_func
(paren
id|c
op_assign
id|toupper
c_func
(paren
op_star
(paren
op_increment
op_star
id|sp
)paren
)paren
)paren
)paren
op_star
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
op_star
op_star
id|dp
op_assign
(paren
id|c
op_minus
(paren
id|isdigit
c_func
(paren
id|c
)paren
ques
c_cond
l_char|&squot;0&squot;
suffix:colon
l_char|&squot;A&squot;
op_minus
l_int|10
)paren
)paren
op_star
l_int|16
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|isxdigit
c_func
(paren
id|c
op_assign
id|toupper
c_func
(paren
op_star
(paren
op_increment
op_star
id|sp
)paren
)paren
)paren
)paren
op_star
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
op_star
(paren
(paren
op_star
id|dp
)paren
op_increment
)paren
op_add_assign
id|c
op_minus
(paren
id|isdigit
c_func
(paren
id|c
)paren
ques
c_cond
l_char|&squot;0&squot;
suffix:colon
l_char|&squot;A&squot;
op_minus
l_int|10
)paren
suffix:semicolon
op_increment
op_star
id|sp
suffix:semicolon
op_star
id|count
op_sub_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
op_star
(paren
(paren
op_star
id|dp
)paren
op_increment
)paren
op_assign
id|c
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_star
id|err
op_logical_or
(paren
id|c
op_ne
id|del
)paren
op_logical_or
(paren
id|res
op_eq
op_star
id|dp
)paren
)paren
id|res
op_assign
l_int|NULL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|special
)paren
op_star
(paren
(paren
op_star
id|dp
)paren
op_increment
)paren
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/*&n; * This registers a new binary format, it recognises the syntax&n; * &squot;:name:type:offset:magic:mask:interpreter:&squot;&n; * where the &squot;:&squot; is the IFS, that can be chosen with the first char&n; */
DECL|function|proc_write_register
r_static
r_int
id|proc_write_register
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
r_const
r_char
op_star
id|sp
suffix:semicolon
r_char
id|del
comma
op_star
id|dp
suffix:semicolon
r_struct
id|binfmt_entry
op_star
id|e
suffix:semicolon
r_int
id|memsize
comma
id|cnt
op_assign
id|count
op_minus
l_int|1
comma
id|err
suffix:semicolon
multiline_comment|/* some sanity checks */
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|count
OL
l_int|11
)paren
op_logical_or
(paren
id|count
OG
l_int|256
)paren
)paren
r_goto
id|_err
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|memsize
op_assign
r_sizeof
(paren
r_struct
id|binfmt_entry
)paren
op_plus
id|count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|e
op_assign
(paren
r_struct
id|binfmt_entry
op_star
)paren
id|kmalloc
c_func
(paren
id|memsize
comma
id|GFP_USER
)paren
)paren
)paren
r_goto
id|_err
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|sp
op_assign
id|buffer
op_plus
l_int|1
suffix:semicolon
id|del
op_assign
id|buffer
(braket
l_int|0
)braket
suffix:semicolon
id|dp
op_assign
(paren
r_char
op_star
)paren
id|e
op_plus
r_sizeof
(paren
r_struct
id|binfmt_entry
)paren
suffix:semicolon
id|e-&gt;proc_name
op_assign
id|copyarg
c_func
(paren
op_amp
id|dp
comma
op_amp
id|sp
comma
op_amp
id|cnt
comma
id|del
comma
l_int|0
comma
op_amp
id|err
)paren
suffix:semicolon
multiline_comment|/* we can use bit 3 of type for ext/magic&n;&t;   flag due to the nice encoding of E and M */
r_if
c_cond
(paren
(paren
op_star
id|sp
op_amp
op_complement
(paren
l_char|&squot;E&squot;
op_or
l_char|&squot;M&squot;
)paren
)paren
op_logical_or
(paren
id|sp
(braket
l_int|1
)braket
op_ne
id|del
)paren
)paren
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
id|e-&gt;flags
op_assign
(paren
op_star
id|sp
op_increment
op_amp
(paren
id|ENTRY_MAGIC
op_or
id|ENTRY_ENABLED
)paren
)paren
suffix:semicolon
id|cnt
op_sub_assign
l_int|2
suffix:semicolon
id|sp
op_increment
suffix:semicolon
id|e-&gt;offset
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cnt
op_decrement
op_logical_and
id|isdigit
c_func
(paren
op_star
id|sp
)paren
)paren
id|e-&gt;offset
op_assign
id|e-&gt;offset
op_star
l_int|10
op_plus
op_star
id|sp
op_increment
op_minus
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_star
id|sp
op_increment
op_ne
id|del
)paren
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|e-&gt;magic
op_assign
id|copyarg
c_func
(paren
op_amp
id|dp
comma
op_amp
id|sp
comma
op_amp
id|cnt
comma
id|del
comma
(paren
id|e-&gt;flags
op_amp
id|ENTRY_MAGIC
)paren
comma
op_amp
id|err
)paren
suffix:semicolon
id|e-&gt;size
op_assign
id|dp
op_minus
id|e-&gt;magic
suffix:semicolon
id|e-&gt;mask
op_assign
id|copyarg
c_func
(paren
op_amp
id|dp
comma
op_amp
id|sp
comma
op_amp
id|cnt
comma
id|del
comma
l_int|1
comma
op_amp
id|err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;mask
op_logical_and
(paren
(paren
id|dp
op_minus
id|e-&gt;mask
)paren
op_ne
id|e-&gt;size
)paren
)paren
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|e-&gt;interpreter
op_assign
id|copyarg
c_func
(paren
op_amp
id|dp
comma
op_amp
id|sp
comma
op_amp
id|cnt
comma
id|del
comma
l_int|0
comma
op_amp
id|err
)paren
suffix:semicolon
id|e-&gt;id
op_assign
id|free_id
op_increment
suffix:semicolon
multiline_comment|/* more sanity checks */
r_if
c_cond
(paren
id|err
op_logical_or
op_logical_neg
(paren
op_logical_neg
id|cnt
op_logical_or
(paren
op_logical_neg
(paren
op_decrement
id|cnt
)paren
op_logical_and
(paren
op_star
id|sp
op_eq
l_char|&squot;&bslash;n&squot;
)paren
)paren
)paren
op_logical_or
(paren
id|e-&gt;size
OL
l_int|1
)paren
op_logical_or
(paren
(paren
id|e-&gt;size
op_plus
id|e-&gt;offset
)paren
OG
(paren
id|BINPRM_BUF_SIZE
op_minus
l_int|1
)paren
)paren
op_logical_or
op_logical_neg
(paren
id|e-&gt;proc_name
)paren
op_logical_or
op_logical_neg
(paren
id|e-&gt;interpreter
)paren
op_logical_or
id|entry_proc_setup
c_func
(paren
id|e
)paren
)paren
r_goto
id|free_err
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|entries_lock
)paren
suffix:semicolon
id|e-&gt;next
op_assign
id|entries
suffix:semicolon
id|entries
op_assign
id|e
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|entries_lock
)paren
suffix:semicolon
id|err
op_assign
id|count
suffix:semicolon
id|_err
suffix:colon
r_return
id|err
suffix:semicolon
id|free_err
suffix:colon
id|kfree
c_func
(paren
id|e
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|_err
suffix:semicolon
)brace
multiline_comment|/*&n; * Get status of entry/binfmt_misc&n; * FIXME? should an entry be marked disabled if binfmt_misc is disabled though&n; *        entry is enabled?&n; */
DECL|function|proc_read_status
r_static
r_int
id|proc_read_status
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|binfmt_entry
op_star
id|e
suffix:semicolon
r_char
op_star
id|dp
suffix:semicolon
r_int
id|elen
comma
id|i
comma
id|err
suffix:semicolon
macro_line|#ifndef VERBOSE_STATUS
r_if
c_cond
(paren
id|data
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|e
op_assign
id|get_entry
c_func
(paren
(paren
r_int
)paren
id|data
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|_err
suffix:semicolon
)brace
id|i
op_assign
id|e-&gt;flags
op_amp
id|ENTRY_ENABLED
suffix:semicolon
id|put_entry
c_func
(paren
id|e
)paren
suffix:semicolon
)brace
r_else
(brace
id|i
op_assign
id|enabled
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%s&bslash;n&quot;
comma
(paren
id|i
ques
c_cond
l_string|&quot;enabled&quot;
suffix:colon
l_string|&quot;disabled&quot;
)paren
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%s&bslash;n&quot;
comma
(paren
id|enabled
ques
c_cond
l_string|&quot;enabled&quot;
suffix:colon
l_string|&quot;disabled&quot;
)paren
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|e
op_assign
id|get_entry
c_func
(paren
(paren
r_int
)paren
id|data
)paren
)paren
)paren
(brace
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|_err
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;%s&bslash;ninterpreter %s&bslash;n&quot;
comma
(paren
id|e-&gt;flags
op_amp
id|ENTRY_ENABLED
ques
c_cond
l_string|&quot;enabled&quot;
suffix:colon
l_string|&quot;disabled&quot;
)paren
comma
id|e-&gt;interpreter
)paren
suffix:semicolon
id|dp
op_assign
id|page
op_plus
id|strlen
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|e-&gt;flags
op_amp
id|ENTRY_MAGIC
)paren
)paren
(brace
id|sprintf
c_func
(paren
id|dp
comma
l_string|&quot;extension .%s&bslash;n&quot;
comma
id|e-&gt;magic
)paren
suffix:semicolon
id|dp
op_assign
id|page
op_plus
id|strlen
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_else
(brace
id|sprintf
c_func
(paren
id|dp
comma
l_string|&quot;offset %i&bslash;nmagic &quot;
comma
id|e-&gt;offset
)paren
suffix:semicolon
id|dp
op_assign
id|page
op_plus
id|strlen
c_func
(paren
id|page
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|e-&gt;size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|dp
comma
l_string|&quot;%02x&quot;
comma
l_int|0xff
op_amp
(paren
r_int
)paren
(paren
id|e-&gt;magic
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|dp
op_add_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|e-&gt;mask
)paren
(brace
id|sprintf
c_func
(paren
id|dp
comma
l_string|&quot;&bslash;nmask &quot;
)paren
suffix:semicolon
id|dp
op_add_assign
l_int|6
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|e-&gt;size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sprintf
c_func
(paren
id|dp
comma
l_string|&quot;%02x&quot;
comma
l_int|0xff
op_amp
(paren
r_int
)paren
(paren
id|e-&gt;mask
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|dp
op_add_assign
l_int|2
suffix:semicolon
)brace
)brace
op_star
id|dp
op_increment
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
op_star
id|dp
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
id|put_entry
c_func
(paren
id|e
)paren
suffix:semicolon
)brace
macro_line|#endif
id|elen
op_assign
id|strlen
c_func
(paren
id|page
)paren
op_minus
id|off
suffix:semicolon
r_if
c_cond
(paren
id|elen
OL
l_int|0
)paren
id|elen
op_assign
l_int|0
suffix:semicolon
op_star
id|eof
op_assign
(paren
id|elen
op_le
id|count
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
id|err
op_assign
id|elen
suffix:semicolon
id|_err
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Set status of entry/binfmt_misc:&n; * &squot;1&squot; enables, &squot;0&squot; disables and &squot;-1&squot; clears entry/binfmt_misc&n; */
DECL|function|proc_write_status
r_static
r_int
id|proc_write_status
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
r_int
id|count
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|binfmt_entry
op_star
id|e
suffix:semicolon
r_int
id|res
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|buffer
(braket
id|count
op_minus
l_int|1
)braket
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
(paren
id|count
op_eq
l_int|1
)paren
op_logical_and
op_logical_neg
(paren
id|buffer
(braket
l_int|0
)braket
op_amp
op_complement
(paren
l_char|&squot;0&squot;
op_or
l_char|&squot;1&squot;
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|data
)paren
(brace
r_if
c_cond
(paren
(paren
id|e
op_assign
id|get_entry
c_func
(paren
(paren
r_int
)paren
id|data
)paren
)paren
)paren
id|e-&gt;flags
op_assign
(paren
id|e-&gt;flags
op_amp
op_complement
id|ENTRY_ENABLED
)paren
op_or
(paren
r_int
)paren
(paren
id|buffer
(braket
l_int|0
)braket
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
id|put_entry
c_func
(paren
id|e
)paren
suffix:semicolon
)brace
r_else
(brace
id|enabled
op_assign
id|buffer
(braket
l_int|0
)braket
op_minus
l_char|&squot;0&squot;
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|count
op_eq
l_int|2
)paren
op_logical_and
(paren
id|buffer
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
)paren
op_logical_and
(paren
id|buffer
(braket
l_int|1
)braket
op_eq
l_char|&squot;1&squot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|data
)paren
id|clear_entry
c_func
(paren
(paren
r_int
)paren
id|data
)paren
suffix:semicolon
r_else
id|clear_entries
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|res
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/*&n; * Remove the /proc-dir entries of one binfmt&n; */
DECL|function|entry_proc_cleanup
r_static
r_void
id|entry_proc_cleanup
c_func
(paren
r_struct
id|binfmt_entry
op_star
id|e
)paren
(brace
id|remove_proc_entry
c_func
(paren
id|e-&gt;proc_name
comma
id|bm_dir
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create the /proc-dir entry for binfmt&n; */
DECL|function|entry_proc_setup
r_static
r_int
id|entry_proc_setup
c_func
(paren
r_struct
id|binfmt_entry
op_star
id|e
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|e-&gt;proc_dir
op_assign
id|create_proc_entry
c_func
(paren
id|e-&gt;proc_name
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|bm_dir
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Unable to create /proc entry.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
id|e-&gt;proc_dir-&gt;data
op_assign
(paren
r_void
op_star
)paren
(paren
id|e-&gt;id
)paren
suffix:semicolon
id|e-&gt;proc_dir-&gt;read_proc
op_assign
id|proc_read_status
suffix:semicolon
id|e-&gt;proc_dir-&gt;write_proc
op_assign
id|proc_write_status
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|init_misc_binfmt
r_static
r_int
id|__init
id|init_misc_binfmt
c_func
(paren
r_void
)paren
(brace
r_int
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_struct
id|proc_dir_entry
op_star
id|status
op_assign
l_int|NULL
comma
op_star
id|reg
suffix:semicolon
id|bm_dir
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;sys/fs/binfmt_misc&quot;
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* WTF??? */
r_if
c_cond
(paren
op_logical_neg
id|bm_dir
)paren
r_goto
id|out
suffix:semicolon
id|bm_dir-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|status
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;status&quot;
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
id|bm_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
r_goto
id|cleanup_bm
suffix:semicolon
id|status-&gt;read_proc
op_assign
id|proc_read_status
suffix:semicolon
id|status-&gt;write_proc
op_assign
id|proc_write_status
suffix:semicolon
id|reg
op_assign
id|create_proc_entry
c_func
(paren
l_string|&quot;register&quot;
comma
id|S_IFREG
op_or
id|S_IWUSR
comma
id|bm_dir
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reg
)paren
r_goto
id|cleanup_status
suffix:semicolon
id|reg-&gt;write_proc
op_assign
id|proc_write_register
suffix:semicolon
id|error
op_assign
id|register_binfmt
c_func
(paren
op_amp
id|misc_format
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
id|cleanup_status
suffix:colon
id|remove_proc_entry
c_func
(paren
l_string|&quot;status&quot;
comma
id|bm_dir
)paren
suffix:semicolon
id|cleanup_bm
suffix:colon
id|remove_proc_entry
c_func
(paren
l_string|&quot;sys/fs/binfmt_misc&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|exit_misc_binfmt
r_static
r_void
id|__exit
id|exit_misc_binfmt
c_func
(paren
r_void
)paren
(brace
id|unregister_binfmt
c_func
(paren
op_amp
id|misc_format
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;register&quot;
comma
id|bm_dir
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;status&quot;
comma
id|bm_dir
)paren
suffix:semicolon
id|clear_entries
c_func
(paren
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;sys/fs/binfmt_misc&quot;
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|EXPORT_NO_SYMBOLS
suffix:semicolon
DECL|variable|init_misc_binfmt
id|module_init
c_func
(paren
id|init_misc_binfmt
)paren
suffix:semicolon
DECL|variable|exit_misc_binfmt
id|module_exit
c_func
(paren
id|exit_misc_binfmt
)paren
suffix:semicolon
eof
