multiline_comment|/*&n; * This file contains the procedures for the handling of select and poll&n; *&n; * Created for Linux based loosely upon Mathius Lattner&squot;s minix&n; * patches by Peter MacDonald. Heavily edited by Linus.&n; *&n; *  4 February 1994&n; *     COFF/ELF binary emulation. If the process has the STICKY_TIMEOUTS&n; *     flag set in its personality we do *not* modify the given timeout&n; *     parameter to reflect time remaining.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/personality.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/poll.h&gt;
DECL|macro|ROUND_UP
mdefine_line|#define ROUND_UP(x,y) (((x)+(y)-1)/(y))
DECL|macro|DEFAULT_POLLMASK
mdefine_line|#define DEFAULT_POLLMASK (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM)
multiline_comment|/*&n; * Ok, Peter made a complicated, but straightforward multiple_wait() function.&n; * I have rewritten this, taking some shortcuts: This code may not be easy to&n; * follow, but it should be free of race-conditions, and it&squot;s practical. If you&n; * understand what I&squot;m doing here, then you understand how the linux&n; * sleep/wakeup mechanism works.&n; *&n; * Two very simple procedures, poll_wait() and free_wait() make all the work.&n; * poll_wait() is an inline-function defined in &lt;linux/sched.h&gt;, as all select/poll&n; * functions have to call it to add an entry to the poll table.&n; */
multiline_comment|/*&n; * I rewrote this again to make the poll_table size variable, take some&n; * more shortcuts, improve responsiveness, and remove another race that&n; * Linus noticed.  -- jrs&n; */
DECL|function|free_wait
r_static
r_void
id|free_wait
c_func
(paren
id|poll_table
op_star
id|p
)paren
(brace
r_struct
id|poll_table_entry
op_star
id|entry
op_assign
id|p-&gt;entry
op_plus
id|p-&gt;nr
suffix:semicolon
r_while
c_loop
(paren
id|p-&gt;nr
OG
l_int|0
)paren
(brace
id|p-&gt;nr
op_decrement
suffix:semicolon
id|entry
op_decrement
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|entry-&gt;wait_address
comma
op_amp
id|entry-&gt;wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * For the kernel fd_set we use a fixed set-size for allocation purposes.&n; * This set-size doesn&squot;t necessarily bear any relation to the size the user&n; * uses, but should preferably obviously be larger than any possible user&n; * size (NR_OPEN bits).&n; *&n; * We need 6 bitmaps (in/out/ex for both incoming and outgoing), and we&n; * allocate one page for all the bitmaps. Thus we have 8*PAGE_SIZE bits,&n; * to be divided by 6. And we&squot;d better make sure we round to a full&n; * long-word (in fact, we&squot;ll round to 64 bytes).&n; */
DECL|macro|KFDS_64BLOCK
mdefine_line|#define KFDS_64BLOCK ((PAGE_SIZE/(6*64))*64)
DECL|macro|KFDS_NR
mdefine_line|#define KFDS_NR (KFDS_64BLOCK*8 &gt; NR_OPEN ? NR_OPEN : KFDS_64BLOCK*8)
DECL|typedef|kernel_fd_set
r_typedef
r_int
r_int
id|kernel_fd_set
(braket
id|KFDS_NR
op_div
(paren
l_int|8
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
)braket
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|in
DECL|member|out
DECL|member|ex
id|kernel_fd_set
id|in
comma
id|out
comma
id|ex
suffix:semicolon
DECL|member|res_in
DECL|member|res_out
DECL|member|res_ex
id|kernel_fd_set
id|res_in
comma
id|res_out
comma
id|res_ex
suffix:semicolon
DECL|typedef|fd_set_buffer
)brace
id|fd_set_buffer
suffix:semicolon
DECL|macro|__IN
mdefine_line|#define __IN(in)&t;(in)
DECL|macro|__OUT
mdefine_line|#define __OUT(in)&t;(in + sizeof(kernel_fd_set)/sizeof(unsigned long))
DECL|macro|__EX
mdefine_line|#define __EX(in)&t;(in + 2*sizeof(kernel_fd_set)/sizeof(unsigned long))
DECL|macro|__RES_IN
mdefine_line|#define __RES_IN(in)&t;(in + 3*sizeof(kernel_fd_set)/sizeof(unsigned long))
DECL|macro|__RES_OUT
mdefine_line|#define __RES_OUT(in)&t;(in + 4*sizeof(kernel_fd_set)/sizeof(unsigned long))
DECL|macro|__RES_EX
mdefine_line|#define __RES_EX(in)&t;(in + 5*sizeof(kernel_fd_set)/sizeof(unsigned long))
DECL|macro|BITS
mdefine_line|#define BITS(in)&t;(*__IN(in)|*__OUT(in)|*__EX(in))
DECL|function|max_select_fd
r_static
r_int
id|max_select_fd
c_func
(paren
r_int
r_int
id|n
comma
id|fd_set_buffer
op_star
id|fds
)paren
(brace
r_int
r_int
op_star
id|open_fds
comma
op_star
id|in
suffix:semicolon
r_int
r_int
id|set
suffix:semicolon
r_int
id|max
suffix:semicolon
multiline_comment|/* handle last in-complete long-word first */
id|set
op_assign
op_complement
(paren
op_complement
l_int|0UL
op_lshift
(paren
id|n
op_amp
(paren
id|__NFDBITS
op_minus
l_int|1
)paren
)paren
)paren
suffix:semicolon
id|n
op_div_assign
id|__NFDBITS
suffix:semicolon
id|open_fds
op_assign
id|current-&gt;files-&gt;open_fds.fds_bits
op_plus
id|n
suffix:semicolon
id|in
op_assign
id|fds-&gt;in
op_plus
id|n
suffix:semicolon
id|max
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|set
)paren
(brace
id|set
op_and_assign
id|BITS
c_func
(paren
id|in
)paren
suffix:semicolon
r_if
c_cond
(paren
id|set
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|set
op_amp
op_complement
op_star
id|open_fds
)paren
)paren
r_goto
id|get_max
suffix:semicolon
r_return
op_minus
id|EBADF
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|n
)paren
(brace
id|in
op_decrement
suffix:semicolon
id|open_fds
op_decrement
suffix:semicolon
id|n
op_decrement
suffix:semicolon
id|set
op_assign
id|BITS
c_func
(paren
id|in
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|set
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|set
op_amp
op_complement
op_star
id|open_fds
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
r_if
c_cond
(paren
id|max
)paren
r_continue
suffix:semicolon
id|get_max
suffix:colon
r_do
(brace
id|max
op_increment
suffix:semicolon
id|set
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|set
)paren
suffix:semicolon
id|max
op_add_assign
id|n
op_star
id|__NFDBITS
suffix:semicolon
)brace
r_return
id|max
suffix:semicolon
)brace
DECL|macro|BIT
mdefine_line|#define BIT(i)&t;&t;(1UL &lt;&lt; ((i)&amp;(__NFDBITS-1)))
DECL|macro|MEM
mdefine_line|#define MEM(i,m)&t;((m)+(unsigned)(i)/__NFDBITS)
DECL|macro|ISSET
mdefine_line|#define ISSET(i,m)&t;(((i)&amp;*(m)) != 0)
DECL|macro|SET
mdefine_line|#define SET(i,m)&t;(*(m) |= (i))
DECL|macro|POLLIN_SET
mdefine_line|#define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR)
DECL|macro|POLLOUT_SET
mdefine_line|#define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)
DECL|macro|POLLEX_SET
mdefine_line|#define POLLEX_SET (POLLPRI)
DECL|function|do_select
r_static
r_int
id|do_select
c_func
(paren
r_int
id|n
comma
id|fd_set_buffer
op_star
id|fds
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
id|i
suffix:semicolon
id|retval
op_assign
id|max_select_fd
c_func
(paren
id|n
comma
id|fds
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|n
op_assign
id|retval
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|file
op_star
op_star
id|fd
op_assign
id|current-&gt;files-&gt;fd
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
comma
id|fd
op_increment
)paren
(brace
r_int
r_int
id|bit
op_assign
id|BIT
c_func
(paren
id|i
)paren
suffix:semicolon
r_int
r_int
op_star
id|in
op_assign
id|MEM
c_func
(paren
id|i
comma
id|fds-&gt;in
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bit
op_amp
id|BITS
c_func
(paren
id|in
)paren
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
op_star
id|fd
suffix:semicolon
r_int
r_int
id|mask
op_assign
id|POLLNVAL
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
id|mask
op_assign
id|DEFAULT_POLLMASK
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_op
op_logical_and
id|file-&gt;f_op-&gt;poll
)paren
id|mask
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|poll
c_func
(paren
id|file
comma
id|wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mask
op_amp
id|POLLIN_SET
)paren
op_logical_and
id|ISSET
c_func
(paren
id|bit
comma
id|__IN
c_func
(paren
id|in
)paren
)paren
)paren
(brace
id|SET
c_func
(paren
id|bit
comma
id|__RES_IN
c_func
(paren
id|in
)paren
)paren
suffix:semicolon
id|retval
op_increment
suffix:semicolon
id|wait
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mask
op_amp
id|POLLOUT_SET
)paren
op_logical_and
id|ISSET
c_func
(paren
id|bit
comma
id|__OUT
c_func
(paren
id|in
)paren
)paren
)paren
(brace
id|SET
c_func
(paren
id|bit
comma
id|__RES_OUT
c_func
(paren
id|in
)paren
)paren
suffix:semicolon
id|retval
op_increment
suffix:semicolon
id|wait
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mask
op_amp
id|POLLEX_SET
)paren
op_logical_and
id|ISSET
c_func
(paren
id|bit
comma
id|__EX
c_func
(paren
id|in
)paren
)paren
)paren
(brace
id|SET
c_func
(paren
id|bit
comma
id|__RES_EX
c_func
(paren
id|in
)paren
)paren
suffix:semicolon
id|retval
op_increment
suffix:semicolon
id|wait
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
id|wait
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_logical_or
op_logical_neg
id|current-&gt;timeout
op_logical_or
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|out
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * We do a VERIFY_WRITE here even though we are only reading this time:&n; * we&squot;ll write to it eventually..&n; *&n; * Use &quot;unsigned long&quot; accesses to let user-mode fd_set&squot;s be long-aligned.&n; */
DECL|function|__get_fd_set
r_static
r_int
id|__get_fd_set
c_func
(paren
r_int
r_int
id|nr
comma
r_int
r_int
op_star
id|fs_pointer
comma
r_int
r_int
op_star
id|fdset
)paren
(brace
multiline_comment|/* round up nr to nearest &quot;unsigned long&quot; */
id|nr
op_assign
(paren
id|nr
op_plus
l_int|8
op_star
r_sizeof
(paren
r_int
r_int
)paren
op_minus
l_int|1
)paren
op_div
(paren
l_int|8
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fs_pointer
)paren
(brace
r_int
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|fs_pointer
comma
id|nr
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
r_while
c_loop
(paren
id|nr
)paren
(brace
id|__get_user
c_func
(paren
op_star
id|fdset
comma
id|fs_pointer
)paren
suffix:semicolon
id|nr
op_decrement
suffix:semicolon
id|fs_pointer
op_increment
suffix:semicolon
id|fdset
op_increment
suffix:semicolon
)brace
)brace
r_return
id|error
suffix:semicolon
)brace
r_while
c_loop
(paren
id|nr
)paren
(brace
op_star
id|fdset
op_assign
l_int|0
suffix:semicolon
id|nr
op_decrement
suffix:semicolon
id|fdset
op_increment
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__set_fd_set
r_static
r_void
id|__set_fd_set
c_func
(paren
r_int
id|nr
comma
r_int
r_int
op_star
id|fs_pointer
comma
r_int
r_int
op_star
id|fdset
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fs_pointer
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
id|nr
op_ge
l_int|0
)paren
(brace
id|__put_user
c_func
(paren
op_star
id|fdset
comma
id|fs_pointer
)paren
suffix:semicolon
id|nr
op_sub_assign
l_int|8
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|fdset
op_increment
suffix:semicolon
id|fs_pointer
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* We can do long accesses here, kernel fdsets are always long-aligned */
DECL|function|__zero_fd_set
r_static
r_inline
r_void
id|__zero_fd_set
c_func
(paren
r_int
id|nr
comma
r_int
r_int
op_star
id|fdset
)paren
(brace
r_while
c_loop
(paren
id|nr
op_ge
l_int|0
)paren
(brace
op_star
id|fdset
op_assign
l_int|0
suffix:semicolon
id|nr
op_sub_assign
l_int|8
op_star
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|fdset
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Note a few subtleties: we use &quot;long&quot; for the dummy, not int, and we do a&n; * subtract by 1 on the nr of file descriptors. The former is better for&n; * machines with long &gt; int, and the latter allows us to test the bit count&n; * against &quot;zero or positive&quot;, which can mostly be just a sign bit test..&n; *&n; * Unfortunately this scheme falls apart on big endian machines where&n; * sizeof(long) &gt; sizeof(int) (ie. V9 Sparc). -DaveM&n; */
DECL|macro|get_fd_set
mdefine_line|#define get_fd_set(nr,fsp,fdp) &bslash;&n;__get_fd_set(nr, (unsigned long *) (fsp), (unsigned long *) (fdp))
DECL|macro|set_fd_set
mdefine_line|#define set_fd_set(nr,fsp,fdp) &bslash;&n;__set_fd_set((nr)-1, (unsigned long *) (fsp), (unsigned long *) (fdp))
DECL|macro|zero_fd_set
mdefine_line|#define zero_fd_set(nr,fdp) &bslash;&n;__zero_fd_set((nr)-1, (unsigned long *) (fdp))
multiline_comment|/*&n; * We can actually return ERESTARTSYS instead of EINTR, but I&squot;d&n; * like to be certain this leads to no problems. So I return&n; * EINTR just for safety.&n; *&n; * Update: ERESTARTSYS breaks at least the xview clock binary, so&n; * I&squot;m trying ERESTARTNOHAND which restart only when you want to.&n; */
DECL|function|sys_select
id|asmlinkage
r_int
id|sys_select
c_func
(paren
r_int
id|n
comma
id|fd_set
op_star
id|inp
comma
id|fd_set
op_star
id|outp
comma
id|fd_set
op_star
id|exp
comma
r_struct
id|timeval
op_star
id|tvp
)paren
(brace
r_int
id|error
suffix:semicolon
id|fd_set_buffer
op_star
id|fds
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
id|poll_table
id|wait_table
comma
op_star
id|wait
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|timeout
op_assign
op_complement
l_int|0UL
suffix:semicolon
r_if
c_cond
(paren
id|tvp
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|tvp
comma
r_sizeof
(paren
op_star
id|tvp
)paren
)paren
)paren
r_goto
id|out_nowait
suffix:semicolon
id|error
op_assign
id|__get_user
c_func
(paren
id|timeout
comma
op_amp
id|tvp-&gt;tv_usec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out_nowait
suffix:semicolon
id|timeout
op_assign
id|ROUND_UP
c_func
(paren
id|timeout
comma
(paren
l_int|1000000
op_div
id|HZ
)paren
)paren
suffix:semicolon
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|error
op_assign
id|__get_user
c_func
(paren
id|tmp
comma
op_amp
id|tvp-&gt;tv_sec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out_nowait
suffix:semicolon
id|timeout
op_add_assign
id|tmp
op_star
(paren
r_int
r_int
)paren
id|HZ
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timeout
)paren
id|timeout
op_add_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|wait
op_assign
l_int|NULL
suffix:semicolon
id|current-&gt;timeout
op_assign
id|timeout
suffix:semicolon
r_if
c_cond
(paren
id|timeout
)paren
(brace
r_struct
id|poll_table_entry
op_star
id|entry
suffix:semicolon
id|entry
op_assign
(paren
r_struct
id|poll_table_entry
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
r_goto
id|out_nowait
suffix:semicolon
id|wait_table.nr
op_assign
l_int|0
suffix:semicolon
id|wait_table.entry
op_assign
id|entry
suffix:semicolon
id|wait
op_assign
op_amp
id|wait_table
suffix:semicolon
)brace
id|fds
op_assign
(paren
id|fd_set_buffer
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fds
)paren
r_goto
id|out_nofds
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
id|KFDS_NR
)paren
id|n
op_assign
id|KFDS_NR
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|get_fd_set
c_func
(paren
id|n
comma
id|inp
comma
op_amp
id|fds-&gt;in
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|get_fd_set
c_func
(paren
id|n
comma
id|outp
comma
op_amp
id|fds-&gt;out
)paren
)paren
op_logical_or
(paren
id|error
op_assign
id|get_fd_set
c_func
(paren
id|n
comma
id|exp
comma
op_amp
id|fds-&gt;ex
)paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|zero_fd_set
c_func
(paren
id|n
comma
op_amp
id|fds-&gt;res_in
)paren
suffix:semicolon
id|zero_fd_set
c_func
(paren
id|n
comma
op_amp
id|fds-&gt;res_out
)paren
suffix:semicolon
id|zero_fd_set
c_func
(paren
id|n
comma
op_amp
id|fds-&gt;res_ex
)paren
suffix:semicolon
id|error
op_assign
id|do_select
c_func
(paren
id|n
comma
id|fds
comma
id|wait
)paren
suffix:semicolon
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
op_minus
id|ERESTARTNOHAND
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
id|set_fd_set
c_func
(paren
id|n
comma
id|inp
comma
op_amp
id|fds-&gt;res_in
)paren
suffix:semicolon
id|set_fd_set
c_func
(paren
id|n
comma
id|outp
comma
op_amp
id|fds-&gt;res_out
)paren
suffix:semicolon
id|set_fd_set
c_func
(paren
id|n
comma
id|exp
comma
op_amp
id|fds-&gt;res_ex
)paren
suffix:semicolon
id|out
suffix:colon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|fds
)paren
suffix:semicolon
id|out_nofds
suffix:colon
r_if
c_cond
(paren
id|wait
)paren
(brace
id|free_wait
c_func
(paren
op_amp
id|wait_table
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|wait-&gt;entry
)paren
suffix:semicolon
)brace
id|out_nowait
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|do_poll
r_static
r_int
id|do_poll
c_func
(paren
r_int
r_int
id|nfds
comma
r_struct
id|pollfd
op_star
id|fds
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_int
id|count
suffix:semicolon
r_struct
id|file
op_star
op_star
id|fd
op_assign
id|current-&gt;files-&gt;fd
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
r_int
id|j
suffix:semicolon
r_struct
id|pollfd
op_star
id|fdpnt
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_for
c_loop
(paren
id|fdpnt
op_assign
id|fds
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|nfds
suffix:semicolon
id|j
op_increment
comma
id|fdpnt
op_increment
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_struct
id|file
op_star
id|file
suffix:semicolon
id|mask
op_assign
id|POLLNVAL
suffix:semicolon
id|i
op_assign
id|fdpnt-&gt;fd
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|NR_OPEN
op_logical_and
(paren
id|file
op_assign
id|fd
(braket
id|i
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|mask
op_assign
id|DEFAULT_POLLMASK
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_op
op_logical_and
id|file-&gt;f_op-&gt;poll
)paren
id|mask
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|poll
c_func
(paren
id|file
comma
id|wait
)paren
suffix:semicolon
id|mask
op_and_assign
id|fdpnt-&gt;events
op_or
id|POLLERR
op_or
id|POLLHUP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mask
)paren
(brace
id|wait
op_assign
l_int|NULL
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
id|fdpnt-&gt;revents
op_assign
id|mask
suffix:semicolon
)brace
id|wait
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|count
op_logical_or
op_logical_neg
id|current-&gt;timeout
op_logical_or
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|sys_poll
id|asmlinkage
r_int
id|sys_poll
c_func
(paren
r_struct
id|pollfd
op_star
id|ufds
comma
r_int
r_int
id|nfds
comma
r_int
id|timeout
)paren
(brace
r_int
id|i
comma
id|count
comma
id|fdcount
comma
id|err
suffix:semicolon
r_struct
id|pollfd
op_star
id|fds
comma
op_star
id|fds1
suffix:semicolon
id|poll_table
id|wait_table
comma
op_star
id|wait
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
OL
l_int|0
)paren
id|timeout
op_assign
l_int|0x7fffffff
suffix:semicolon
r_else
r_if
c_cond
(paren
id|timeout
)paren
id|timeout
op_assign
(paren
(paren
r_int
r_int
)paren
id|timeout
op_star
id|HZ
op_plus
l_int|999
)paren
op_div
l_int|1000
op_plus
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|wait
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|timeout
)paren
(brace
r_struct
id|poll_table_entry
op_star
id|entry
suffix:semicolon
id|entry
op_assign
(paren
r_struct
id|poll_table_entry
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
)paren
r_goto
id|out
suffix:semicolon
id|wait_table.nr
op_assign
l_int|0
suffix:semicolon
id|wait_table.entry
op_assign
id|entry
suffix:semicolon
id|wait
op_assign
op_amp
id|wait_table
suffix:semicolon
)brace
id|fds
op_assign
(paren
r_struct
id|pollfd
op_star
)paren
id|kmalloc
c_func
(paren
id|nfds
op_star
r_sizeof
(paren
r_struct
id|pollfd
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fds
)paren
(brace
r_goto
id|out
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|fds
comma
id|ufds
comma
id|nfds
op_star
r_sizeof
(paren
r_struct
id|pollfd
)paren
)paren
)paren
(brace
id|kfree
c_func
(paren
id|fds
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|current-&gt;timeout
op_assign
id|timeout
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
id|fdcount
op_assign
id|do_poll
c_func
(paren
id|nfds
comma
id|fds
comma
id|wait
)paren
suffix:semicolon
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* OK, now copy the revents fields back to user space. */
id|fds1
op_assign
id|fds
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_int
)paren
id|nfds
suffix:semicolon
id|i
op_increment
comma
id|ufds
op_increment
comma
id|fds
op_increment
)paren
(brace
id|__put_user
c_func
(paren
id|fds-&gt;revents
comma
op_amp
id|ufds-&gt;revents
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|fds1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fdcount
op_logical_and
id|signal_pending
c_func
(paren
id|current
)paren
)paren
id|err
op_assign
op_minus
id|EINTR
suffix:semicolon
r_else
id|err
op_assign
id|fdcount
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|wait
)paren
(brace
id|free_wait
c_func
(paren
op_amp
id|wait_table
)paren
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|wait-&gt;entry
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
eof
