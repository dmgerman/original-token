multiline_comment|/* -*- c -*- --------------------------------------------------------------- *&n; *&n; * linux/fs/autofs/expire.c&n; *&n; *  Copyright 1997-1998 Transmeta Corporation -- All Rights Reserved&n; *  Copyright 1999-2000 Jeremy Fitzhardinge &lt;jeremy@goop.org&gt;&n; *&n; * This file is part of the Linux kernel and is made available under&n; * the terms of the GNU General Public License, version 2, or at your&n; * option, any later version, incorporated herein by reference.&n; *&n; * ------------------------------------------------------------------------- */
macro_line|#include &quot;autofs_i.h&quot;
multiline_comment|/*&n; * Determine if a subtree of the namespace is busy.&n; *&n; * mnt is the mount tree under the autofs mountpoint&n; */
DECL|function|is_vfsmnt_tree_busy
r_static
r_inline
r_int
id|is_vfsmnt_tree_busy
c_func
(paren
r_struct
id|vfsmount
op_star
id|mnt
)paren
(brace
r_struct
id|vfsmount
op_star
id|this_parent
op_assign
id|mnt
suffix:semicolon
r_struct
id|list_head
op_star
id|next
suffix:semicolon
r_int
id|count
suffix:semicolon
id|count
op_assign
id|atomic_read
c_func
(paren
op_amp
id|mnt-&gt;mnt_count
)paren
op_minus
l_int|1
suffix:semicolon
id|repeat
suffix:colon
id|next
op_assign
id|this_parent-&gt;mnt_mounts.next
suffix:semicolon
id|DPRINTK
c_func
(paren
(paren
l_string|&quot;is_vfsmnt_tree_busy: mnt=%p, this_parent=%p, next=%p&bslash;n&quot;
comma
id|mnt
comma
id|this_parent
comma
id|next
)paren
)paren
suffix:semicolon
id|resume
suffix:colon
r_for
c_loop
(paren
suffix:semicolon
id|next
op_ne
op_amp
id|this_parent-&gt;mnt_mounts
suffix:semicolon
id|next
op_assign
id|next-&gt;next
)paren
(brace
r_struct
id|vfsmount
op_star
id|p
op_assign
id|list_entry
c_func
(paren
id|next
comma
r_struct
id|vfsmount
comma
id|mnt_child
)paren
suffix:semicolon
multiline_comment|/* -1 for struct vfs_mount&squot;s normal count, &n;&t;&t;   -1 to compensate for child&squot;s reference to parent */
id|count
op_add_assign
id|atomic_read
c_func
(paren
op_amp
id|p-&gt;mnt_count
)paren
op_minus
l_int|1
op_minus
l_int|1
suffix:semicolon
id|DPRINTK
c_func
(paren
(paren
l_string|&quot;is_vfsmnt_tree_busy: p=%p, count now %d&bslash;n&quot;
comma
id|p
comma
id|count
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|p-&gt;mnt_mounts
)paren
)paren
(brace
id|this_parent
op_assign
id|p
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/* root is busy if any leaf is busy */
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|p-&gt;mnt_count
)paren
OG
l_int|1
)paren
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* All done at this level ... ascend and resume the search. */
r_if
c_cond
(paren
id|this_parent
op_ne
id|mnt
)paren
(brace
id|next
op_assign
id|this_parent-&gt;mnt_child.next
suffix:semicolon
id|this_parent
op_assign
id|this_parent-&gt;mnt_parent
suffix:semicolon
r_goto
id|resume
suffix:semicolon
)brace
id|DPRINTK
c_func
(paren
(paren
l_string|&quot;is_vfsmnt_tree_busy: count=%d&bslash;n&quot;
comma
id|count
)paren
)paren
suffix:semicolon
r_return
id|count
op_ne
l_int|0
suffix:semicolon
multiline_comment|/* remaining users? */
)brace
multiline_comment|/* Traverse a dentry&squot;s list of vfsmounts and return the number of&n;   non-busy mounts */
DECL|function|check_vfsmnt
r_static
r_int
id|check_vfsmnt
c_func
(paren
r_struct
id|vfsmount
op_star
id|mnt
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|dentry-&gt;d_vfsmnt
)paren
(brace
r_struct
id|vfsmount
op_star
id|vfs
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|vfsmount
comma
id|mnt_clash
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
(paren
l_string|&quot;check_vfsmnt: mnt=%p, dentry=%p, tmp=%p, vfs=%p&bslash;n&quot;
comma
id|mnt
comma
id|dentry
comma
id|tmp
comma
id|vfs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vfs-&gt;mnt_parent
op_ne
id|mnt
op_logical_or
multiline_comment|/* don&squot;t care about busy-ness of other namespaces */
op_logical_neg
id|is_vfsmnt_tree_busy
c_func
(paren
id|vfs
)paren
)paren
id|ret
op_increment
suffix:semicolon
)brace
id|DPRINTK
c_func
(paren
(paren
l_string|&quot;check_vfsmnt: ret=%d&bslash;n&quot;
comma
id|ret
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Check dentry tree for busyness.  If a dentry appears to be busy&n;   because it is a mountpoint, check to see if the mounted&n;   filesystem is busy. */
DECL|function|is_tree_busy
r_static
r_int
id|is_tree_busy
c_func
(paren
r_struct
id|vfsmount
op_star
id|topmnt
comma
r_struct
id|dentry
op_star
id|top
)paren
(brace
r_struct
id|dentry
op_star
id|this_parent
suffix:semicolon
r_struct
id|list_head
op_star
id|next
suffix:semicolon
r_int
id|count
suffix:semicolon
id|count
op_assign
id|atomic_read
c_func
(paren
op_amp
id|top-&gt;d_count
)paren
suffix:semicolon
id|DPRINTK
c_func
(paren
(paren
l_string|&quot;is_tree_busy: top=%p initial count=%d&bslash;n&quot;
comma
id|top
comma
id|count
)paren
)paren
suffix:semicolon
id|this_parent
op_assign
id|top
suffix:semicolon
id|count
op_decrement
suffix:semicolon
multiline_comment|/* top is passed in after being dgot */
r_if
c_cond
(paren
id|is_autofs4_dentry
c_func
(paren
id|top
)paren
)paren
(brace
id|count
op_decrement
suffix:semicolon
id|DPRINTK
c_func
(paren
(paren
l_string|&quot;is_tree_busy: autofs; count=%d&bslash;n&quot;
comma
id|count
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d_mountpoint
c_func
(paren
id|top
)paren
)paren
id|count
op_sub_assign
id|check_vfsmnt
c_func
(paren
id|topmnt
comma
id|top
)paren
suffix:semicolon
id|repeat
suffix:colon
id|next
op_assign
id|this_parent-&gt;d_subdirs.next
suffix:semicolon
id|resume
suffix:colon
r_while
c_loop
(paren
id|next
op_ne
op_amp
id|this_parent-&gt;d_subdirs
)paren
(brace
r_int
id|adj
op_assign
l_int|0
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
op_assign
id|list_entry
c_func
(paren
id|next
comma
r_struct
id|dentry
comma
id|d_child
)paren
suffix:semicolon
id|next
op_assign
id|next-&gt;next
suffix:semicolon
id|count
op_add_assign
id|atomic_read
c_func
(paren
op_amp
id|dentry-&gt;d_count
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|d_mountpoint
c_func
(paren
id|dentry
)paren
)paren
id|adj
op_add_assign
id|check_vfsmnt
c_func
(paren
id|topmnt
comma
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_autofs4_dentry
c_func
(paren
id|dentry
)paren
)paren
(brace
id|adj
op_increment
suffix:semicolon
id|DPRINTK
c_func
(paren
(paren
l_string|&quot;is_tree_busy: autofs; adj=%d&bslash;n&quot;
comma
id|adj
)paren
)paren
suffix:semicolon
)brace
id|count
op_sub_assign
id|adj
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|dentry-&gt;d_subdirs
)paren
)paren
(brace
id|this_parent
op_assign
id|dentry
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|dentry-&gt;d_count
)paren
op_ne
id|adj
)paren
(brace
id|DPRINTK
c_func
(paren
(paren
l_string|&quot;is_tree_busy: busy leaf (d_count=%d adj=%d)&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|dentry-&gt;d_count
)paren
comma
id|adj
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* All done at this level ... ascend and resume the search. */
r_if
c_cond
(paren
id|this_parent
op_ne
id|top
)paren
(brace
id|next
op_assign
id|this_parent-&gt;d_child.next
suffix:semicolon
id|this_parent
op_assign
id|this_parent-&gt;d_parent
suffix:semicolon
r_goto
id|resume
suffix:semicolon
)brace
id|DPRINTK
c_func
(paren
(paren
l_string|&quot;is_tree_busy: count=%d&bslash;n&quot;
comma
id|count
)paren
)paren
suffix:semicolon
r_return
id|count
op_ne
l_int|0
suffix:semicolon
multiline_comment|/* remaining users? */
)brace
multiline_comment|/*&n; * Find an eligible tree to time-out&n; * A tree is eligible if :-&n; *  - it is unused by any user process&n; *  - it has been unused for exp_timeout time&n; */
DECL|function|autofs4_expire
r_static
r_struct
id|dentry
op_star
id|autofs4_expire
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|vfsmount
op_star
id|mnt
comma
r_struct
id|autofs_sb_info
op_star
id|sbi
comma
r_int
id|do_now
)paren
(brace
r_int
r_int
id|now
op_assign
id|jiffies
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_struct
id|dentry
op_star
id|root
op_assign
id|sb-&gt;s_root
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_struct
id|dentry
op_star
id|d
suffix:semicolon
r_struct
id|vfsmount
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sbi-&gt;exp_timeout
op_logical_or
op_logical_neg
id|root
)paren
r_return
l_int|NULL
suffix:semicolon
id|timeout
op_assign
id|sbi-&gt;exp_timeout
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|root-&gt;d_subdirs.next
suffix:semicolon
id|tmp
op_ne
op_amp
id|root-&gt;d_subdirs
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
(brace
r_struct
id|autofs_info
op_star
id|ino
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|dentry
comma
id|d_child
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_inode
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|ino
op_assign
id|autofs4_dentry_ino
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ino
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* dentry in the process of being deleted */
r_continue
suffix:semicolon
)brace
multiline_comment|/* No point expiring a pending mount */
r_if
c_cond
(paren
id|dentry-&gt;d_flags
op_amp
id|DCACHE_AUTOFS_PENDING
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|do_now
)paren
(brace
multiline_comment|/* Too young to die */
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|ino-&gt;last_used
op_plus
id|timeout
comma
id|now
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* update last_used here :- &n;&t;&t;&t;   - obviously makes sense if it is in use now&n;&t;&t;&t;   - less obviously, prevents rapid-fire expire&n;&t;&t;&t;     attempts if expire fails the first time */
id|ino-&gt;last_used
op_assign
id|now
suffix:semicolon
)brace
id|p
op_assign
id|mntget
c_func
(paren
id|mnt
)paren
suffix:semicolon
id|d
op_assign
id|dget_locked
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_tree_busy
c_func
(paren
id|p
comma
id|d
)paren
)paren
(brace
id|DPRINTK
c_func
(paren
(paren
l_string|&quot;autofs_expire: returning %p %.*s&bslash;n&quot;
comma
id|dentry
comma
(paren
r_int
)paren
id|dentry-&gt;d_name.len
comma
id|dentry-&gt;d_name.name
)paren
)paren
suffix:semicolon
multiline_comment|/* Start from here next time */
id|list_del
c_func
(paren
op_amp
id|root-&gt;d_subdirs
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|root-&gt;d_subdirs
comma
op_amp
id|dentry-&gt;d_child
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|dput
c_func
(paren
id|d
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
id|dentry
suffix:semicolon
)brace
id|dput
c_func
(paren
id|d
)paren
suffix:semicolon
id|mntput
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Perform an expiry operation */
DECL|function|autofs4_expire_run
r_int
id|autofs4_expire_run
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|vfsmount
op_star
id|mnt
comma
r_struct
id|autofs_sb_info
op_star
id|sbi
comma
r_struct
id|autofs_packet_expire
op_star
id|pkt_p
)paren
(brace
r_struct
id|autofs_packet_expire
id|pkt
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pkt
comma
l_int|0
comma
r_sizeof
id|pkt
)paren
suffix:semicolon
id|pkt.hdr.proto_version
op_assign
id|sbi-&gt;version
suffix:semicolon
id|pkt.hdr.type
op_assign
id|autofs_ptype_expire
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dentry
op_assign
id|autofs4_expire
c_func
(paren
id|sb
comma
id|mnt
comma
id|sbi
comma
l_int|0
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|pkt.len
op_assign
id|dentry-&gt;d_name.len
suffix:semicolon
id|memcpy
c_func
(paren
id|pkt.name
comma
id|dentry-&gt;d_name.name
comma
id|pkt.len
)paren
suffix:semicolon
id|pkt.name
(braket
id|pkt.len
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|pkt_p
comma
op_amp
id|pkt
comma
r_sizeof
(paren
r_struct
id|autofs_packet_expire
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Call repeatedly until it returns -EAGAIN, meaning there&squot;s nothing&n;   more to be done */
DECL|function|autofs4_expire_multi
r_int
id|autofs4_expire_multi
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|vfsmount
op_star
id|mnt
comma
r_struct
id|autofs_sb_info
op_star
id|sbi
comma
r_int
op_star
id|arg
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_int
id|do_now
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_logical_and
id|get_user
c_func
(paren
id|do_now
comma
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dentry
op_assign
id|autofs4_expire
c_func
(paren
id|sb
comma
id|mnt
comma
id|sbi
comma
id|do_now
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_struct
id|autofs_info
op_star
id|de_info
op_assign
id|autofs4_dentry_ino
c_func
(paren
id|dentry
)paren
suffix:semicolon
multiline_comment|/* This is synchronous because it makes the daemon a&n;                   little easier */
id|de_info-&gt;flags
op_or_assign
id|AUTOFS_INF_EXPIRING
suffix:semicolon
id|ret
op_assign
id|autofs4_wait
c_func
(paren
id|sbi
comma
op_amp
id|dentry-&gt;d_name
comma
id|NFY_EXPIRE
)paren
suffix:semicolon
id|de_info-&gt;flags
op_and_assign
op_complement
id|AUTOFS_INF_EXPIRING
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
eof
