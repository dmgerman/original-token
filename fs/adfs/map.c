multiline_comment|/*&n; *  linux/fs/adfs/map.c&n; *&n; *  Copyright (C) 1997-1999 Russell King&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; */
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/adfs_fs.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &quot;adfs.h&quot;
multiline_comment|/*&n; * For the future...&n; */
DECL|variable|adfs_map_lock
r_static
id|rwlock_t
id|adfs_map_lock
suffix:semicolon
multiline_comment|/*&n; * return the map bit offset of the fragment frag_id in&n; * the zone dm.&n; * Note that the loop is optimised for best asm code -&n; * look at the output of:&n; *  gcc -D__KERNEL__ -O2 -I../../include -o - -S map.c&n; */
r_static
r_int
DECL|function|lookup_zone
id|lookup_zone
c_func
(paren
r_const
r_struct
id|adfs_discmap
op_star
id|dm
comma
r_const
r_int
r_int
id|idlen
comma
r_const
r_int
r_int
id|frag_id
comma
r_int
r_int
op_star
id|offset
)paren
(brace
r_const
r_int
r_int
id|mapsize
op_assign
id|dm-&gt;dm_endbit
suffix:semicolon
r_const
r_int
r_int
id|idmask
op_assign
(paren
l_int|1
op_lshift
id|idlen
)paren
op_minus
l_int|1
suffix:semicolon
r_int
r_int
op_star
id|map
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
id|dm-&gt;dm_bh-&gt;b_data
)paren
op_plus
l_int|1
suffix:semicolon
r_int
r_int
id|start
op_assign
id|dm-&gt;dm_startbit
suffix:semicolon
r_int
r_int
id|mapptr
suffix:semicolon
r_do
(brace
r_int
r_int
id|frag
suffix:semicolon
multiline_comment|/*&n;&t;&t; * get fragment id&n;&t;&t; */
(brace
r_int
r_int
id|v2
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|tmp
op_assign
id|start
op_rshift
l_int|5
suffix:semicolon
id|frag
op_assign
id|le32_to_cpu
c_func
(paren
id|map
(braket
id|tmp
)braket
)paren
suffix:semicolon
id|v2
op_assign
id|le32_to_cpu
c_func
(paren
id|map
(braket
id|tmp
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|tmp
op_assign
id|start
op_amp
l_int|31
suffix:semicolon
id|frag
op_assign
(paren
id|frag
op_rshift
id|tmp
)paren
op_or
(paren
id|v2
op_lshift
(paren
l_int|32
op_minus
id|tmp
)paren
)paren
suffix:semicolon
id|frag
op_and_assign
id|idmask
suffix:semicolon
)brace
id|mapptr
op_assign
id|start
op_plus
id|idlen
suffix:semicolon
multiline_comment|/*&n;&t;&t; * find end of fragment&n;&t;&t; */
(brace
r_int
r_int
id|v2
suffix:semicolon
r_while
c_loop
(paren
(paren
id|v2
op_assign
id|map
(braket
id|mapptr
op_rshift
l_int|5
)braket
op_rshift
(paren
id|mapptr
op_amp
l_int|31
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|mapptr
op_assign
(paren
id|mapptr
op_amp
op_complement
l_int|31
)paren
op_plus
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|mapptr
op_ge
id|mapsize
)paren
r_goto
id|error
suffix:semicolon
)brace
id|mapptr
op_add_assign
l_int|1
op_plus
id|ffz
c_func
(paren
op_complement
id|v2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|frag
op_eq
id|frag_id
)paren
r_goto
id|found
suffix:semicolon
id|again
suffix:colon
id|start
op_assign
id|mapptr
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mapptr
OL
id|mapsize
)paren
suffix:semicolon
id|error
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
id|found
suffix:colon
(brace
r_int
id|length
op_assign
id|mapptr
op_minus
id|start
suffix:semicolon
r_if
c_cond
(paren
op_star
id|offset
op_ge
id|length
)paren
(brace
op_star
id|offset
op_sub_assign
id|length
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
)brace
r_return
id|start
op_plus
op_star
id|offset
suffix:semicolon
)brace
multiline_comment|/*&n; * Scan the free space map, for this zone, calculating the total&n; * number of map bits in each free space fragment.&n; *&n; * Note: idmask is limited to 15 bits [3.2]&n; */
r_static
r_int
r_int
DECL|function|scan_free_map
id|scan_free_map
c_func
(paren
r_struct
id|adfs_sb_info
op_star
id|asb
comma
r_struct
id|adfs_discmap
op_star
id|dm
)paren
(brace
r_const
r_int
r_int
id|mapsize
op_assign
id|dm-&gt;dm_endbit
op_plus
l_int|32
suffix:semicolon
r_const
r_int
r_int
id|idlen
op_assign
id|asb-&gt;s_idlen
suffix:semicolon
r_const
r_int
r_int
id|frag_idlen
op_assign
id|idlen
op_le
l_int|15
ques
c_cond
id|idlen
suffix:colon
l_int|15
suffix:semicolon
r_const
r_int
r_int
id|idmask
op_assign
(paren
l_int|1
op_lshift
id|frag_idlen
)paren
op_minus
l_int|1
suffix:semicolon
r_int
r_int
op_star
id|map
op_assign
(paren
r_int
r_int
op_star
)paren
id|dm-&gt;dm_bh-&gt;b_data
suffix:semicolon
r_int
r_int
id|start
op_assign
l_int|8
comma
id|mapptr
suffix:semicolon
r_int
r_int
id|frag
suffix:semicolon
r_int
r_int
id|total
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * get fragment id&n;&t; */
(brace
r_int
r_int
id|v2
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|tmp
op_assign
id|start
op_rshift
l_int|5
suffix:semicolon
id|frag
op_assign
id|le32_to_cpu
c_func
(paren
id|map
(braket
id|tmp
)braket
)paren
suffix:semicolon
id|v2
op_assign
id|le32_to_cpu
c_func
(paren
id|map
(braket
id|tmp
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|tmp
op_assign
id|start
op_amp
l_int|31
suffix:semicolon
id|frag
op_assign
(paren
id|frag
op_rshift
id|tmp
)paren
op_or
(paren
id|v2
op_lshift
(paren
l_int|32
op_minus
id|tmp
)paren
)paren
suffix:semicolon
id|frag
op_and_assign
id|idmask
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the freelink is null, then no free fragments&n;&t; * exist in this zone.&n;&t; */
r_if
c_cond
(paren
id|frag
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_do
(brace
id|start
op_add_assign
id|frag
suffix:semicolon
multiline_comment|/*&n;&t;&t; * get fragment id&n;&t;&t; */
(brace
r_int
r_int
id|v2
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|tmp
op_assign
id|start
op_rshift
l_int|5
suffix:semicolon
id|frag
op_assign
id|le32_to_cpu
c_func
(paren
id|map
(braket
id|tmp
)braket
)paren
suffix:semicolon
id|v2
op_assign
id|le32_to_cpu
c_func
(paren
id|map
(braket
id|tmp
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|tmp
op_assign
id|start
op_amp
l_int|31
suffix:semicolon
id|frag
op_assign
(paren
id|frag
op_rshift
id|tmp
)paren
op_or
(paren
id|v2
op_lshift
(paren
l_int|32
op_minus
id|tmp
)paren
)paren
suffix:semicolon
id|frag
op_and_assign
id|idmask
suffix:semicolon
)brace
id|mapptr
op_assign
id|start
op_plus
id|idlen
suffix:semicolon
multiline_comment|/*&n;&t;&t; * find end of fragment&n;&t;&t; */
(brace
r_int
r_int
id|v2
suffix:semicolon
r_while
c_loop
(paren
(paren
id|v2
op_assign
id|map
(braket
id|mapptr
op_rshift
l_int|5
)braket
op_rshift
(paren
id|mapptr
op_amp
l_int|31
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|mapptr
op_assign
(paren
id|mapptr
op_amp
op_complement
l_int|31
)paren
op_plus
l_int|32
suffix:semicolon
r_if
c_cond
(paren
id|mapptr
op_ge
id|mapsize
)paren
r_goto
id|error
suffix:semicolon
)brace
id|mapptr
op_add_assign
l_int|1
op_plus
id|ffz
c_func
(paren
op_complement
id|v2
)paren
suffix:semicolon
)brace
id|total
op_add_assign
id|mapptr
op_minus
id|start
suffix:semicolon
)brace
r_while
c_loop
(paren
id|frag
op_ge
id|idlen
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|frag
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;adfs: undersized free fragment&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|total
suffix:semicolon
id|error
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;adfs: oversized free fragment&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|scan_map
id|scan_map
c_func
(paren
r_struct
id|adfs_sb_info
op_star
id|asb
comma
r_int
r_int
id|zone
comma
r_const
r_int
r_int
id|frag_id
comma
r_int
r_int
id|mapoff
)paren
(brace
r_const
r_int
r_int
id|idlen
op_assign
id|asb-&gt;s_idlen
suffix:semicolon
r_struct
id|adfs_discmap
op_star
id|dm
comma
op_star
id|dm_end
suffix:semicolon
r_int
id|result
suffix:semicolon
id|dm
op_assign
id|asb-&gt;s_map
op_plus
id|zone
suffix:semicolon
id|zone
op_assign
id|asb-&gt;s_map_size
suffix:semicolon
id|dm_end
op_assign
id|asb-&gt;s_map
op_plus
id|zone
suffix:semicolon
r_do
(brace
id|result
op_assign
id|lookup_zone
c_func
(paren
id|dm
comma
id|idlen
comma
id|frag_id
comma
op_amp
id|mapoff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
op_minus
l_int|1
)paren
r_goto
id|found
suffix:semicolon
id|dm
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|dm
op_eq
id|dm_end
)paren
id|dm
op_assign
id|asb-&gt;s_map
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|zone
OG
l_int|0
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
id|found
suffix:colon
id|result
op_sub_assign
id|dm-&gt;dm_startbit
suffix:semicolon
id|result
op_add_assign
id|dm-&gt;dm_startblk
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * calculate the amount of free blocks in the map.&n; *&n; *              n=1&n; *  total_free = E(free_in_zone_n)&n; *              nzones&n; */
r_int
r_int
DECL|function|adfs_map_free
id|adfs_map_free
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_struct
id|adfs_sb_info
op_star
id|asb
op_assign
op_amp
id|sb-&gt;u.adfs_sb
suffix:semicolon
r_struct
id|adfs_discmap
op_star
id|dm
suffix:semicolon
r_int
r_int
id|total
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|zone
suffix:semicolon
id|dm
op_assign
id|asb-&gt;s_map
suffix:semicolon
id|zone
op_assign
id|asb-&gt;s_map_size
suffix:semicolon
r_do
(brace
id|total
op_add_assign
id|scan_free_map
c_func
(paren
id|asb
comma
id|dm
op_increment
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|zone
OG
l_int|0
)paren
suffix:semicolon
r_return
id|signed_asl
c_func
(paren
id|total
comma
id|asb-&gt;s_map2blk
)paren
suffix:semicolon
)brace
DECL|function|adfs_map_lookup
r_int
id|adfs_map_lookup
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|frag_id
comma
r_int
id|offset
)paren
(brace
r_struct
id|adfs_sb_info
op_star
id|asb
op_assign
op_amp
id|sb-&gt;u.adfs_sb
suffix:semicolon
r_int
r_int
id|zone
comma
id|mapoff
suffix:semicolon
r_int
id|result
suffix:semicolon
multiline_comment|/*&n;&t; * map &amp; root fragment is special - it starts in the center of the&n;&t; * disk.  The other fragments start at zone (frag / ids_per_zone)&n;&t; */
r_if
c_cond
(paren
id|frag_id
op_eq
id|ADFS_ROOT_FRAG
)paren
id|zone
op_assign
id|asb-&gt;s_map_size
op_rshift
l_int|1
suffix:semicolon
r_else
id|zone
op_assign
id|frag_id
op_div
id|asb-&gt;s_ids_per_zone
suffix:semicolon
r_if
c_cond
(paren
id|zone
op_ge
id|asb-&gt;s_map_size
)paren
r_goto
id|bad_fragment
suffix:semicolon
multiline_comment|/* Convert sector offset to map offset */
id|mapoff
op_assign
id|signed_asl
c_func
(paren
id|offset
comma
op_minus
id|asb-&gt;s_map2blk
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|adfs_map_lock
)paren
suffix:semicolon
id|result
op_assign
id|scan_map
c_func
(paren
id|asb
comma
id|zone
comma
id|frag_id
comma
id|mapoff
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|adfs_map_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OG
l_int|0
)paren
(brace
r_int
r_int
id|secoff
suffix:semicolon
multiline_comment|/* Calculate sector offset into map block */
id|secoff
op_assign
id|offset
op_minus
id|signed_asl
c_func
(paren
id|mapoff
comma
id|asb-&gt;s_map2blk
)paren
suffix:semicolon
r_return
id|secoff
op_plus
id|signed_asl
c_func
(paren
id|result
comma
id|asb-&gt;s_map2blk
)paren
suffix:semicolon
)brace
id|adfs_error
c_func
(paren
id|sb
comma
l_string|&quot;fragment %04X at offset %d not found in map&quot;
comma
id|frag_id
comma
id|offset
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|bad_fragment
suffix:colon
id|adfs_error
c_func
(paren
id|sb
comma
l_string|&quot;fragment %X is invalid (zone = %d, max = %d)&quot;
comma
id|frag_id
comma
id|zone
comma
id|asb-&gt;s_map_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
