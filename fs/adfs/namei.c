multiline_comment|/*&n; *  linux/fs/adfs/namei.c&n; *&n; * Copyright (C) 1997 Russell King&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/adfs_fs.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
multiline_comment|/*&n; * NOTE! unlike strncmp, ext2_match returns 1 for success, 0 for failure&n; */
DECL|function|adfs_match
r_static
r_int
id|adfs_match
(paren
r_int
id|len
comma
r_const
r_char
op_star
r_const
id|name
comma
r_struct
id|adfs_idir_entry
op_star
id|de
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de
op_logical_or
id|len
OG
id|ADFS_NAME_LEN
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * &quot;&quot; means &quot;.&quot; ---&gt; so paths like &quot;/usr/lib//libc.a&quot; work&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_and
id|de-&gt;name_len
op_eq
l_int|1
op_logical_and
id|de-&gt;name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
id|de-&gt;name
(braket
l_int|1
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
id|de-&gt;name_len
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|de-&gt;name
(braket
id|i
)braket
op_xor
id|name
(braket
id|i
)braket
)paren
op_amp
l_int|0x5f
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|adfs_find_entry
r_static
r_int
id|adfs_find_entry
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
r_const
id|name
comma
r_int
id|namelen
comma
r_struct
id|adfs_idir_entry
op_star
id|ide
)paren
(brace
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
(braket
l_int|4
)braket
suffix:semicolon
r_union
id|adfs_dirtail
id|dt
suffix:semicolon
r_int
r_int
id|parent_object_id
comma
id|dir_object_id
suffix:semicolon
r_int
id|buffers
comma
id|pos
suffix:semicolon
id|sb
op_assign
id|dir-&gt;i_sb
suffix:semicolon
r_if
c_cond
(paren
id|adfs_inode_validate
(paren
id|dir
)paren
)paren
(brace
id|adfs_error
(paren
id|sb
comma
l_string|&quot;adfs_find_entry&quot;
comma
l_string|&quot;invalid inode number: %lu&quot;
comma
id|dir-&gt;i_ino
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|buffers
op_assign
id|adfs_dir_read
(paren
id|dir
comma
id|bh
)paren
)paren
)paren
(brace
id|adfs_error
(paren
id|sb
comma
l_string|&quot;adfs_find_entry&quot;
comma
l_string|&quot;unable to read directory&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|adfs_dir_check
(paren
id|dir
comma
id|bh
comma
id|buffers
comma
op_amp
id|dt
)paren
)paren
(brace
id|adfs_dir_free
(paren
id|bh
comma
id|buffers
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|parent_object_id
op_assign
id|adfs_val
(paren
id|dt
dot
r_new
dot
id|dirparent
comma
l_int|3
)paren
suffix:semicolon
id|dir_object_id
op_assign
id|adfs_inode_objid
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|namelen
op_eq
l_int|2
op_logical_and
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
id|name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
)paren
(brace
id|ide-&gt;name_len
op_assign
l_int|2
suffix:semicolon
id|ide-&gt;name
(braket
l_int|0
)braket
op_assign
id|ide-&gt;name
(braket
l_int|1
)braket
op_assign
l_char|&squot;.&squot;
suffix:semicolon
id|ide-&gt;name
(braket
l_int|2
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|ide-&gt;inode_no
op_assign
id|adfs_inode_generate
(paren
id|parent_object_id
comma
l_int|0
)paren
suffix:semicolon
id|adfs_dir_free
(paren
id|bh
comma
id|buffers
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|pos
op_assign
l_int|5
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|adfs_dir_get
(paren
id|sb
comma
id|bh
comma
id|buffers
comma
id|pos
comma
id|dir_object_id
comma
id|ide
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|adfs_match
(paren
id|namelen
comma
id|name
comma
id|ide
)paren
)paren
(brace
id|adfs_dir_free
(paren
id|bh
comma
id|buffers
)paren
suffix:semicolon
r_return
id|pos
suffix:semicolon
)brace
id|pos
op_add_assign
l_int|26
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
id|adfs_dir_free
(paren
id|bh
comma
id|buffers
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|adfs_lookup
r_struct
id|dentry
op_star
id|adfs_lookup
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|adfs_idir_entry
id|de
suffix:semicolon
r_int
r_int
id|ino
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_name.len
OG
id|ADFS_NAME_LEN
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|ENAMETOOLONG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|adfs_find_entry
(paren
id|dir
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
op_amp
id|de
)paren
)paren
(brace
id|ino
op_assign
id|de.inode_no
suffix:semicolon
id|inode
op_assign
id|iget
(paren
id|dir-&gt;i_sb
comma
id|ino
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_return
id|ERR_PTR
c_func
(paren
op_minus
id|EACCES
)paren
suffix:semicolon
)brace
id|d_add
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
eof
