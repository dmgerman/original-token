multiline_comment|/*&n; *  linux/fs/adfs/dir_f.c&n; *&n; * Copyright (C) 1997-1999 Russell King&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; *&n; *  E and F format directory handling&n; */
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/adfs_fs.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &quot;adfs.h&quot;
macro_line|#include &quot;dir_f.h&quot;
r_static
r_void
id|adfs_f_free
c_func
(paren
r_struct
id|adfs_dir
op_star
id|dir
)paren
suffix:semicolon
multiline_comment|/*&n; * Read an (unaligned) value of length 1..4 bytes&n; */
DECL|function|adfs_readval
r_static
r_inline
r_int
r_int
id|adfs_readval
c_func
(paren
r_int
r_char
op_star
id|p
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|val
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|len
)paren
(brace
r_case
l_int|4
suffix:colon
id|val
op_or_assign
id|p
(braket
l_int|3
)braket
op_lshift
l_int|24
suffix:semicolon
r_case
l_int|3
suffix:colon
id|val
op_or_assign
id|p
(braket
l_int|2
)braket
op_lshift
l_int|16
suffix:semicolon
r_case
l_int|2
suffix:colon
id|val
op_or_assign
id|p
(braket
l_int|1
)braket
op_lshift
l_int|8
suffix:semicolon
r_default
suffix:colon
id|val
op_or_assign
id|p
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_return
id|val
suffix:semicolon
)brace
DECL|function|adfs_writeval
r_static
r_inline
r_void
id|adfs_writeval
c_func
(paren
r_int
r_char
op_star
id|p
comma
r_int
id|len
comma
r_int
r_int
id|val
)paren
(brace
r_switch
c_cond
(paren
id|len
)paren
(brace
r_case
l_int|4
suffix:colon
id|p
(braket
l_int|3
)braket
op_assign
id|val
op_rshift
l_int|24
suffix:semicolon
r_case
l_int|3
suffix:colon
id|p
(braket
l_int|2
)braket
op_assign
id|val
op_rshift
l_int|16
suffix:semicolon
r_case
l_int|2
suffix:colon
id|p
(braket
l_int|1
)braket
op_assign
id|val
op_rshift
l_int|8
suffix:semicolon
r_default
suffix:colon
id|p
(braket
l_int|0
)braket
op_assign
id|val
suffix:semicolon
)brace
)brace
DECL|function|adfs_readname
r_static
r_inline
r_int
id|adfs_readname
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
id|ptr
comma
r_int
id|maxlen
)paren
(brace
r_char
op_star
id|old_buf
op_assign
id|buf
suffix:semicolon
r_while
c_loop
(paren
op_star
id|ptr
op_ge
l_char|&squot; &squot;
op_logical_and
id|maxlen
op_decrement
)paren
(brace
r_if
c_cond
(paren
op_star
id|ptr
op_eq
l_char|&squot;/&squot;
)paren
op_star
id|buf
op_increment
op_assign
l_char|&squot;.&squot;
suffix:semicolon
r_else
op_star
id|buf
op_increment
op_assign
op_star
id|ptr
suffix:semicolon
id|ptr
op_increment
suffix:semicolon
)brace
op_star
id|buf
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
id|buf
op_minus
id|old_buf
suffix:semicolon
)brace
DECL|function|adfs_writename
r_static
r_inline
r_void
id|adfs_writename
c_func
(paren
r_char
op_star
id|to
comma
r_char
op_star
id|from
comma
r_int
id|maxlen
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|maxlen
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|from
(braket
id|i
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|from
(braket
id|i
)braket
op_eq
l_char|&squot;.&squot;
)paren
id|to
(braket
id|i
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_else
id|to
(braket
id|i
)braket
op_assign
id|from
(braket
id|i
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|maxlen
suffix:semicolon
id|i
op_increment
)paren
id|to
(braket
id|i
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
DECL|macro|ror13
mdefine_line|#define ror13(v) ((v &gt;&gt; 13) | (v &lt;&lt; 19))
DECL|macro|dir_u8
mdefine_line|#define dir_u8(idx)&t;&t;&t;&t;&bslash;&n;&t;({ int _buf = idx &gt;&gt; blocksize_bits;&t;&bslash;&n;&t;   int _off = idx - (_buf &lt;&lt; blocksize_bits);&bslash;&n;&t;  *(u8 *)(bh[_buf]-&gt;b_data + _off);&t;&bslash;&n;&t;})
DECL|macro|dir_u32
mdefine_line|#define dir_u32(idx)&t;&t;&t;&t;&bslash;&n;&t;({ int _buf = idx &gt;&gt; blocksize_bits;&t;&bslash;&n;&t;   int _off = idx - (_buf &lt;&lt; blocksize_bits);&bslash;&n;&t;  *(u32 *)(bh[_buf]-&gt;b_data + _off);&t;&bslash;&n;&t;})
DECL|macro|bufoff
mdefine_line|#define bufoff(_bh,_idx)&t;&t;&t;&bslash;&n;&t;({ int _buf = _idx &gt;&gt; blocksize_bits;&t;&bslash;&n;&t;   int _off = _idx - (_buf &lt;&lt; blocksize_bits);&bslash;&n;&t;  (u8 *)(_bh[_buf]-&gt;b_data + _off);&t;&bslash;&n;&t;})
multiline_comment|/*&n; * There are some algorithms that are nice in&n; * assembler, but a bitch in C...  This is one&n; * of them.&n; */
r_static
id|u8
DECL|function|adfs_dir_checkbyte
id|adfs_dir_checkbyte
c_func
(paren
r_const
r_struct
id|adfs_dir
op_star
id|dir
)paren
(brace
r_struct
id|buffer_head
op_star
r_const
op_star
id|bh
op_assign
id|dir-&gt;bh
suffix:semicolon
r_const
r_int
id|blocksize_bits
op_assign
id|dir-&gt;sb-&gt;s_blocksize_bits
suffix:semicolon
r_union
(brace
id|u32
op_star
id|ptr32
suffix:semicolon
id|u8
op_star
id|ptr8
suffix:semicolon
)brace
id|ptr
comma
id|end
suffix:semicolon
id|u32
id|dircheck
op_assign
l_int|0
suffix:semicolon
r_int
id|last
op_assign
l_int|5
op_minus
l_int|26
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Accumulate each word up to the last whole&n;&t; * word of the last directory entry.  This&n;&t; * can spread across several buffer heads.&n;&t; */
r_do
(brace
id|last
op_add_assign
l_int|26
suffix:semicolon
r_do
(brace
id|dircheck
op_assign
id|cpu_to_le32
c_func
(paren
id|dir_u32
c_func
(paren
id|i
)paren
)paren
op_xor
id|ror13
c_func
(paren
id|dircheck
)paren
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OL
(paren
id|last
op_amp
op_complement
l_int|3
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dir_u8
c_func
(paren
id|last
)paren
op_ne
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Accumulate the last few bytes.  These&n;&t; * bytes will be within the same bh.&n;&t; */
r_if
c_cond
(paren
id|i
op_ne
id|last
)paren
(brace
id|ptr.ptr8
op_assign
id|bufoff
c_func
(paren
id|bh
comma
id|i
)paren
suffix:semicolon
id|end.ptr8
op_assign
id|ptr.ptr8
op_plus
id|last
op_minus
id|i
suffix:semicolon
r_do
id|dircheck
op_assign
op_star
id|ptr.ptr8
op_increment
op_xor
id|ror13
c_func
(paren
id|dircheck
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ptr.ptr8
OL
id|end.ptr8
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The directory tail is in the final bh&n;&t; * Note that contary to the RISC OS PRMs,&n;&t; * the first few bytes are NOT included&n;&t; * in the check.  All bytes are in the&n;&t; * same bh.&n;&t; */
id|ptr.ptr8
op_assign
id|bufoff
c_func
(paren
id|bh
comma
l_int|2008
)paren
suffix:semicolon
id|end.ptr8
op_assign
id|ptr.ptr8
op_plus
l_int|36
suffix:semicolon
r_do
(brace
r_int
r_int
id|v
op_assign
op_star
id|ptr.ptr32
op_increment
suffix:semicolon
id|dircheck
op_assign
id|cpu_to_le32
c_func
(paren
id|v
)paren
op_xor
id|ror13
c_func
(paren
id|dircheck
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ptr.ptr32
OL
id|end.ptr32
)paren
suffix:semicolon
r_return
(paren
id|dircheck
op_xor
(paren
id|dircheck
op_rshift
l_int|8
)paren
op_xor
(paren
id|dircheck
op_rshift
l_int|16
)paren
op_xor
(paren
id|dircheck
op_rshift
l_int|24
)paren
)paren
op_amp
l_int|0xff
suffix:semicolon
)brace
multiline_comment|/*&n; * Read and check that a directory is valid&n; */
r_int
DECL|function|adfs_dir_read
id|adfs_dir_read
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
r_int
id|object_id
comma
r_int
r_int
id|size
comma
r_struct
id|adfs_dir
op_star
id|dir
)paren
(brace
r_const
r_int
r_int
id|blocksize_bits
op_assign
id|sb-&gt;s_blocksize_bits
suffix:semicolon
r_int
id|blk
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Directories which are not a multiple of 2048 bytes&n;&t; * are considered bad v2 [3.6]&n;&t; */
r_if
c_cond
(paren
id|size
op_amp
l_int|2047
)paren
r_goto
id|bad_dir
suffix:semicolon
id|size
op_rshift_assign
id|blocksize_bits
suffix:semicolon
id|dir-&gt;nr_buffers
op_assign
l_int|0
suffix:semicolon
id|dir-&gt;sb
op_assign
id|sb
suffix:semicolon
r_for
c_loop
(paren
id|blk
op_assign
l_int|0
suffix:semicolon
id|blk
OL
id|size
suffix:semicolon
id|blk
op_increment
)paren
(brace
r_int
id|phys
suffix:semicolon
id|phys
op_assign
id|__adfs_block_map
c_func
(paren
id|sb
comma
id|object_id
comma
id|blk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|phys
)paren
(brace
id|adfs_error
c_func
(paren
id|sb
comma
l_string|&quot;dir object %lX has a hole at offset %d&quot;
comma
id|object_id
comma
id|blk
)paren
suffix:semicolon
r_goto
id|release_buffers
suffix:semicolon
)brace
id|dir-&gt;bh
(braket
id|blk
)braket
op_assign
id|bread
c_func
(paren
id|sb-&gt;s_dev
comma
id|phys
comma
id|sb-&gt;s_blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir-&gt;bh
(braket
id|blk
)braket
)paren
r_goto
id|release_buffers
suffix:semicolon
)brace
id|memcpy
c_func
(paren
op_amp
id|dir-&gt;dirhead
comma
id|bufoff
c_func
(paren
id|dir-&gt;bh
comma
l_int|0
)paren
comma
r_sizeof
(paren
id|dir-&gt;dirhead
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|dir-&gt;dirtail
comma
id|bufoff
c_func
(paren
id|dir-&gt;bh
comma
l_int|2007
)paren
comma
r_sizeof
(paren
id|dir-&gt;dirtail
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;dirhead.startmasseq
op_ne
id|dir-&gt;dirtail
dot
r_new
dot
id|endmasseq
op_logical_or
id|memcmp
c_func
(paren
op_amp
id|dir-&gt;dirhead.startname
comma
op_amp
id|dir-&gt;dirtail
dot
r_new
dot
id|endname
comma
l_int|4
)paren
)paren
r_goto
id|bad_dir
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
op_amp
id|dir-&gt;dirhead.startname
comma
l_string|&quot;Nick&quot;
comma
l_int|4
)paren
op_logical_and
id|memcmp
c_func
(paren
op_amp
id|dir-&gt;dirhead.startname
comma
l_string|&quot;Hugo&quot;
comma
l_int|4
)paren
)paren
r_goto
id|bad_dir
suffix:semicolon
r_if
c_cond
(paren
id|adfs_dir_checkbyte
c_func
(paren
id|dir
)paren
op_ne
id|dir-&gt;dirtail
dot
r_new
dot
id|dircheckbyte
)paren
r_goto
id|bad_dir
suffix:semicolon
id|dir-&gt;nr_buffers
op_assign
id|blk
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|bad_dir
suffix:colon
id|adfs_error
c_func
(paren
id|sb
comma
l_string|&quot;corrupted directory fragment %lX&quot;
comma
id|object_id
)paren
suffix:semicolon
id|release_buffers
suffix:colon
r_for
c_loop
(paren
id|blk
op_sub_assign
l_int|1
suffix:semicolon
id|blk
op_ge
l_int|0
suffix:semicolon
id|blk
op_sub_assign
l_int|1
)paren
id|brelse
c_func
(paren
id|dir-&gt;bh
(braket
id|blk
)braket
)paren
suffix:semicolon
id|dir-&gt;sb
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n; * convert a disk-based directory entry to a Linux ADFS directory entry&n; */
r_static
r_inline
r_void
DECL|function|adfs_dir2obj
id|adfs_dir2obj
c_func
(paren
r_struct
id|object_info
op_star
id|obj
comma
r_struct
id|adfs_direntry
op_star
id|de
)paren
(brace
id|obj-&gt;name_len
op_assign
id|adfs_readname
c_func
(paren
id|obj-&gt;name
comma
id|de-&gt;dirobname
comma
id|ADFS_F_NAME_LEN
)paren
suffix:semicolon
id|obj-&gt;file_id
op_assign
id|adfs_readval
c_func
(paren
id|de-&gt;dirinddiscadd
comma
l_int|3
)paren
suffix:semicolon
id|obj-&gt;loadaddr
op_assign
id|adfs_readval
c_func
(paren
id|de-&gt;dirload
comma
l_int|4
)paren
suffix:semicolon
id|obj-&gt;execaddr
op_assign
id|adfs_readval
c_func
(paren
id|de-&gt;direxec
comma
l_int|4
)paren
suffix:semicolon
id|obj-&gt;size
op_assign
id|adfs_readval
c_func
(paren
id|de-&gt;dirlen
comma
l_int|4
)paren
suffix:semicolon
id|obj-&gt;attr
op_assign
id|de-&gt;newdiratts
suffix:semicolon
)brace
multiline_comment|/*&n; * convert a Linux ADFS directory entry to a disk-based directory entry&n; */
r_static
r_inline
r_void
DECL|function|adfs_obj2dir
id|adfs_obj2dir
c_func
(paren
r_struct
id|adfs_direntry
op_star
id|de
comma
r_struct
id|object_info
op_star
id|obj
)paren
(brace
id|adfs_writeval
c_func
(paren
id|de-&gt;dirinddiscadd
comma
l_int|3
comma
id|obj-&gt;file_id
)paren
suffix:semicolon
id|adfs_writeval
c_func
(paren
id|de-&gt;dirload
comma
l_int|4
comma
id|obj-&gt;loadaddr
)paren
suffix:semicolon
id|adfs_writeval
c_func
(paren
id|de-&gt;direxec
comma
l_int|4
comma
id|obj-&gt;execaddr
)paren
suffix:semicolon
id|adfs_writeval
c_func
(paren
id|de-&gt;dirlen
comma
l_int|4
comma
id|obj-&gt;size
)paren
suffix:semicolon
id|de-&gt;newdiratts
op_assign
id|obj-&gt;attr
suffix:semicolon
)brace
multiline_comment|/*&n; * get a directory entry.  Note that the caller is responsible&n; * for holding the relevent locks.&n; */
r_int
DECL|function|__adfs_dir_get
id|__adfs_dir_get
c_func
(paren
r_struct
id|adfs_dir
op_star
id|dir
comma
r_int
id|pos
comma
r_struct
id|object_info
op_star
id|obj
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|dir-&gt;sb
suffix:semicolon
r_struct
id|adfs_direntry
id|de
suffix:semicolon
r_int
id|thissize
comma
id|buffer
comma
id|offset
suffix:semicolon
id|buffer
op_assign
id|pos
op_rshift
id|sb-&gt;s_blocksize_bits
suffix:semicolon
r_if
c_cond
(paren
id|buffer
OG
id|dir-&gt;nr_buffers
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|offset
op_assign
id|pos
op_amp
(paren
id|sb-&gt;s_blocksize
op_minus
l_int|1
)paren
suffix:semicolon
id|thissize
op_assign
id|sb-&gt;s_blocksize
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|thissize
OG
l_int|26
)paren
id|thissize
op_assign
l_int|26
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|de
comma
id|dir-&gt;bh
(braket
id|buffer
)braket
op_member_access_from_pointer
id|b_data
op_plus
id|offset
comma
id|thissize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thissize
op_ne
l_int|26
)paren
id|memcpy
c_func
(paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|de
)paren
op_plus
id|thissize
comma
id|dir-&gt;bh
(braket
id|buffer
op_plus
l_int|1
)braket
op_member_access_from_pointer
id|b_data
comma
l_int|26
op_minus
id|thissize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de.dirobname
(braket
l_int|0
)braket
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|adfs_dir2obj
c_func
(paren
id|obj
comma
op_amp
id|de
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|__adfs_dir_put
id|__adfs_dir_put
c_func
(paren
r_struct
id|adfs_dir
op_star
id|dir
comma
r_int
id|pos
comma
r_struct
id|object_info
op_star
id|obj
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|dir-&gt;sb
suffix:semicolon
r_struct
id|adfs_direntry
id|de
suffix:semicolon
r_int
id|thissize
comma
id|buffer
comma
id|offset
suffix:semicolon
id|buffer
op_assign
id|pos
op_rshift
id|sb-&gt;s_blocksize_bits
suffix:semicolon
r_if
c_cond
(paren
id|buffer
OG
id|dir-&gt;nr_buffers
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|offset
op_assign
id|pos
op_amp
(paren
id|sb-&gt;s_blocksize
op_minus
l_int|1
)paren
suffix:semicolon
id|thissize
op_assign
id|sb-&gt;s_blocksize
op_minus
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|thissize
OG
l_int|26
)paren
id|thissize
op_assign
l_int|26
suffix:semicolon
multiline_comment|/*&n;&t; * Get the entry in total&n;&t; */
id|memcpy
c_func
(paren
op_amp
id|de
comma
id|dir-&gt;bh
(braket
id|buffer
)braket
op_member_access_from_pointer
id|b_data
op_plus
id|offset
comma
id|thissize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thissize
op_ne
l_int|26
)paren
id|memcpy
c_func
(paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|de
)paren
op_plus
id|thissize
comma
id|dir-&gt;bh
(braket
id|buffer
op_plus
l_int|1
)braket
op_member_access_from_pointer
id|b_data
comma
l_int|26
op_minus
id|thissize
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * update it&n;&t; */
id|adfs_obj2dir
c_func
(paren
op_amp
id|de
comma
id|obj
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Put the new entry back&n;&t; */
id|memcpy
c_func
(paren
id|dir-&gt;bh
(braket
id|buffer
)braket
op_member_access_from_pointer
id|b_data
op_plus
id|offset
comma
op_amp
id|de
comma
id|thissize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thissize
op_ne
l_int|26
)paren
id|memcpy
c_func
(paren
id|dir-&gt;bh
(braket
id|buffer
op_plus
l_int|1
)braket
op_member_access_from_pointer
id|b_data
comma
(paren
(paren
r_char
op_star
)paren
op_amp
id|de
)paren
op_plus
id|thissize
comma
l_int|26
op_minus
id|thissize
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * the caller is responsible for holding the necessary&n; * locks.&n; */
r_static
r_int
DECL|function|adfs_dir_find_entry
id|adfs_dir_find_entry
c_func
(paren
r_struct
id|adfs_dir
op_star
id|dir
comma
r_int
r_int
id|object_id
)paren
(brace
r_int
id|pos
comma
id|ret
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_for
c_loop
(paren
id|pos
op_assign
l_int|5
suffix:semicolon
id|pos
OL
id|ADFS_NUM_DIR_ENTRIES
op_star
l_int|26
op_plus
l_int|5
suffix:semicolon
id|pos
op_add_assign
l_int|26
)paren
(brace
r_struct
id|object_info
id|obj
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|__adfs_dir_get
c_func
(paren
id|dir
comma
id|pos
comma
op_amp
id|obj
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|obj.file_id
op_eq
id|object_id
)paren
(brace
id|ret
op_assign
id|pos
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|adfs_f_read
id|adfs_f_read
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
r_int
id|id
comma
r_int
r_int
id|sz
comma
r_struct
id|adfs_dir
op_star
id|dir
)paren
(brace
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|sz
op_ne
id|ADFS_NEWDIR_SIZE
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|ret
op_assign
id|adfs_dir_read
c_func
(paren
id|sb
comma
id|id
comma
id|sz
comma
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|adfs_error
c_func
(paren
id|sb
comma
l_string|&quot;unable to read directory&quot;
)paren
suffix:semicolon
r_else
id|dir-&gt;parent_id
op_assign
id|adfs_readval
c_func
(paren
id|dir-&gt;dirtail
dot
r_new
dot
id|dirparent
comma
l_int|3
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|adfs_f_setpos
id|adfs_f_setpos
c_func
(paren
r_struct
id|adfs_dir
op_star
id|dir
comma
r_int
r_int
id|fpos
)paren
(brace
r_if
c_cond
(paren
id|fpos
op_ge
id|ADFS_NUM_DIR_ENTRIES
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|dir-&gt;pos
op_assign
l_int|5
op_plus
id|fpos
op_star
l_int|26
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|adfs_f_getnext
id|adfs_f_getnext
c_func
(paren
r_struct
id|adfs_dir
op_star
id|dir
comma
r_struct
id|object_info
op_star
id|obj
)paren
(brace
r_int
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|__adfs_dir_get
c_func
(paren
id|dir
comma
id|dir-&gt;pos
comma
id|obj
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|dir-&gt;pos
op_add_assign
l_int|26
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
r_int
DECL|function|adfs_f_update
id|adfs_f_update
c_func
(paren
r_struct
id|adfs_dir
op_star
id|dir
comma
r_struct
id|object_info
op_star
id|obj
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|dir-&gt;sb
suffix:semicolon
r_int
id|ret
comma
id|i
suffix:semicolon
id|ret
op_assign
id|adfs_dir_find_entry
c_func
(paren
id|dir
comma
id|obj-&gt;file_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|adfs_error
c_func
(paren
id|dir-&gt;sb
comma
l_string|&quot;unable to locate entry to update&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|__adfs_dir_put
c_func
(paren
id|dir
comma
id|ret
comma
id|obj
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Increment directory sequence number&n;&t; */
id|dir-&gt;bh
(braket
l_int|0
)braket
op_member_access_from_pointer
id|b_data
(braket
l_int|0
)braket
op_add_assign
l_int|1
suffix:semicolon
id|dir-&gt;bh
(braket
id|dir-&gt;nr_buffers
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|b_data
(braket
id|sb-&gt;s_blocksize
op_minus
l_int|6
)braket
op_add_assign
l_int|1
suffix:semicolon
id|ret
op_assign
id|adfs_dir_checkbyte
c_func
(paren
id|dir
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Update directory check byte&n;&t; */
id|dir-&gt;bh
(braket
id|dir-&gt;nr_buffers
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|b_data
(braket
id|sb-&gt;s_blocksize
op_minus
l_int|1
)braket
op_assign
id|ret
suffix:semicolon
macro_line|#if 1
(brace
r_const
r_int
r_int
id|blocksize_bits
op_assign
id|sb-&gt;s_blocksize_bits
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|dir-&gt;dirhead
comma
id|bufoff
c_func
(paren
id|dir-&gt;bh
comma
l_int|0
)paren
comma
r_sizeof
(paren
id|dir-&gt;dirhead
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|dir-&gt;dirtail
comma
id|bufoff
c_func
(paren
id|dir-&gt;bh
comma
l_int|2007
)paren
comma
r_sizeof
(paren
id|dir-&gt;dirtail
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;dirhead.startmasseq
op_ne
id|dir-&gt;dirtail
dot
r_new
dot
id|endmasseq
op_logical_or
id|memcmp
c_func
(paren
op_amp
id|dir-&gt;dirhead.startname
comma
op_amp
id|dir-&gt;dirtail
dot
r_new
dot
id|endname
comma
l_int|4
)paren
)paren
r_goto
id|bad_dir
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
op_amp
id|dir-&gt;dirhead.startname
comma
l_string|&quot;Nick&quot;
comma
l_int|4
)paren
op_logical_and
id|memcmp
c_func
(paren
op_amp
id|dir-&gt;dirhead.startname
comma
l_string|&quot;Hugo&quot;
comma
l_int|4
)paren
)paren
r_goto
id|bad_dir
suffix:semicolon
r_if
c_cond
(paren
id|adfs_dir_checkbyte
c_func
(paren
id|dir
)paren
op_ne
id|dir-&gt;dirtail
dot
r_new
dot
id|dircheckbyte
)paren
r_goto
id|bad_dir
suffix:semicolon
)brace
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
id|dir-&gt;nr_buffers
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
id|mark_buffer_dirty
c_func
(paren
id|dir-&gt;bh
(braket
id|i
)braket
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
macro_line|#if 1
id|bad_dir
suffix:colon
id|adfs_error
c_func
(paren
id|dir-&gt;sb
comma
l_string|&quot;whoops!  I broke a directory!&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
macro_line|#endif
)brace
r_static
r_void
DECL|function|adfs_f_free
id|adfs_f_free
c_func
(paren
r_struct
id|adfs_dir
op_star
id|dir
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|dir-&gt;nr_buffers
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|brelse
c_func
(paren
id|dir-&gt;bh
(braket
id|i
)braket
)paren
suffix:semicolon
id|dir-&gt;bh
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|dir-&gt;nr_buffers
op_assign
l_int|0
suffix:semicolon
id|dir-&gt;sb
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|variable|adfs_f_dir_ops
r_struct
id|adfs_dir_ops
id|adfs_f_dir_ops
op_assign
(brace
id|adfs_f_read
comma
id|adfs_f_setpos
comma
id|adfs_f_getnext
comma
id|adfs_f_update
comma
l_int|NULL
comma
l_int|NULL
comma
id|adfs_f_free
)brace
suffix:semicolon
eof
