multiline_comment|/*&n; *  linux/fs/hpfs/hpfs_fs.c&n; *  read-only HPFS&n; *  version 1.0&n; *&n; *  Chris Smith 1993&n; *&n; *  Sources &amp; references:&n; *   Duncan, _Design ... of HPFS_, MSJ 4(5)   (C) 1989 Microsoft Corp&n; *   linux/fs/minix  Copyright (C) 1991, 1992, 1993  Linus Torvalds&n; *   linux/fs/msdos  Written 1992, 1993 by Werner Almesberger&n; *   linux/fs/isofs  Copyright (C) 1991  Eric Youngdale&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/hpfs_fs.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;hpfs.h&quot;
macro_line|#include &quot;hpfs_caps.h&quot;
multiline_comment|/* &n; * HPFS is a mixture of 512-byte blocks and 2048-byte blocks.  The 2k blocks&n; * are used for directories and bitmaps.  For bmap to work, we must run the&n; * file system with 512-byte blocks.  The 2k blocks are assembled in buffers&n; * obtained from kmalloc.&n; *&n; * For a file&squot;s i-number we use the sector number of its fnode, coded.&n; * (Directory ino&squot;s are even, file ino&squot;s are odd, and ino &gt;&gt; 1 is the&n; * sector address of the fnode.  This is a hack to allow lookup() to&n; * tell read_inode() whether it is necessary to read the fnode.)&n; *&n; * The map_xxx routines all read something into a buffer and return a&n; * pointer somewhere in the buffer.  The caller must do the brelse.&n; * The other routines are balanced.&n; *&n; * For details on the data structures see hpfs.h and the Duncan paper.&n; *&n; * Overview&n; *&n; * [ The names of these data structures, except fnode, are not Microsoft&squot;s&n; * or IBM&squot;s.  I don&squot;t know what names they use.  The semantics described&n; * here are those of this implementation, and any coincidence between it&n; * and real HPFS is to be hoped for but not guaranteed by me, and&n; * certainly not guaranteed by MS or IBM.  Who know nothing about this. ]&n; *&n; * [ Also, the following will make little sense if you haven&squot;t read the&n; * Duncan paper, which is excellent. ]&n; *&n; * HPFS is a tree.  There are 3 kinds of nodes.  A directory is a tree&n; * of dnodes, and a file&squot;s allocation info is a tree of sector runs&n; * stored in fnodes and anodes.&n; *&n; * The top pointer is in the super block, it points to the fnode of the&n; * root directory.&n; *&n; * The root directory -- all directories -- gives file names, dates &amp;c,&n; * and fnode addresses.  If the directory fits in one dnode, that&squot;s it,&n; * otherwise the top dnode points to other dnodes, forming a tree.  A&n; * dnode tree (one directory) might look like&n; *&n; *     ((a b c) d (e f g) h (i j) k l (m n o p))&n; *&n; * The subtrees appear between the files.  Each dir entry contains, along&n; * with the name and fnode, a dnode pointer to the subtree that precedes it&n; * (if there is one; a flag tells that).  The first entry in every directory&n; * is ^A^A, the &quot;.&quot; entry for the directory itself.  The last entry in every&n; * dnode is &bslash;377, a fake entry whose only valid fields are the bit marking&n; * it last and the down pointer to the subtree preceding it, if any.&n; *&n; * The &quot;value&quot; field of directory entries is an fnode address.  The fnode&n; * tells where the sectors of the file are.  The fnode for a subdirectory&n; * contains one pointer, to the root dnode of the subdirectory.  The fnode&n; * for a data file contains, in effect, a tiny anode.  (Most of the space&n; * in fnodes is for extended attributes.)&n; *&n; * anodes and the anode part of fnodes are trees of extents.  An extent&n; * is a (length, disk address) pair, labeled with the file address being&n; * mapped.  E.g.,&n; *&n; *     (0: 3@1000  3: 1@2000  4: 2@10)&n; *&n; * means the file:disk sector map (0:1000 1:1001 2:1002 3:2000 4:10 5:11).&n; *&n; * There is space for 8 file:len@disk triples in an fnode, or for 40 in an&n; * anode.  If this is insufficient, subtrees are used, as in&n; *&n; *  (6: (0: 3@1000  3: 1@2000  4: 2@10)  12: (6: 3@8000  9: 1@9000  10: 2@20))&n; *&n; * The label on a subtree is the first address *after* that tree.  The&n; * subtrees are always anodes.  The label:subtree pairs require only&n; * two words each, so non-leaf subtrees have a different format; there&n; * is room for 12 label:subtree pairs in an fnode, or 60 in an anode.&n; *&n; * Within a directory, each dnode contains a pointer up to its parent&n; * dnode.  The root dnode points up to the directory&squot;s fnode.&n; *&n; * Each fnode contains a pointer to the directory that contains it&n; * (to the fnode of the directory).  So this pointer in a directory&n; * fnode is &quot;..&quot;.&n; *&n; * On the disk, dnodes are all together in the center of the partition,&n; * and HPFS even manages to put all the dnodes for a single directory&n; * together, generally.  fnodes are out with the data.  anodes are seldom&n; * seen -- in fact noncontiguous files are seldom seen.  I think this is&n; * partly the open() call that lets programs specify the length of an&n; * output file when they know it, and partly because HPFS.IFS really is&n; * very good at resisting fragmentation. &n; */
"&f;"
multiline_comment|/* notation */
DECL|macro|little_ushort
mdefine_line|#define little_ushort(x) (*(unsigned short *) &amp;(x))
DECL|typedef|nonconst
r_typedef
r_void
id|nonconst
suffix:semicolon
multiline_comment|/* super block ops */
r_static
r_void
id|hpfs_read_inode
c_func
(paren
r_struct
id|inode
op_star
)paren
suffix:semicolon
r_static
r_void
id|hpfs_put_super
c_func
(paren
r_struct
id|super_block
op_star
)paren
suffix:semicolon
r_static
r_void
id|hpfs_statfs
c_func
(paren
r_struct
id|super_block
op_star
comma
r_struct
id|statfs
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|hpfs_remount_fs
c_func
(paren
r_struct
id|super_block
op_star
comma
r_int
op_star
comma
r_char
op_star
)paren
suffix:semicolon
DECL|variable|hpfs_sops
r_static
r_const
r_struct
id|super_operations
id|hpfs_sops
op_assign
(brace
id|hpfs_read_inode
comma
multiline_comment|/* read_inode */
l_int|NULL
comma
multiline_comment|/* notify_change */
l_int|NULL
comma
multiline_comment|/* write_inode */
l_int|NULL
comma
multiline_comment|/* put_inode */
id|hpfs_put_super
comma
multiline_comment|/* put_super */
l_int|NULL
comma
multiline_comment|/* write_super */
id|hpfs_statfs
comma
multiline_comment|/* statfs */
id|hpfs_remount_fs
comma
multiline_comment|/* remount_fs */
)brace
suffix:semicolon
multiline_comment|/* file ops */
r_static
r_int
id|hpfs_file_read
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
r_char
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_static
id|secno
id|hpfs_bmap
c_func
(paren
r_struct
id|inode
op_star
comma
r_int
)paren
suffix:semicolon
DECL|variable|hpfs_file_ops
r_static
r_const
r_struct
id|file_operations
id|hpfs_file_ops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|hpfs_file_read
comma
multiline_comment|/* read */
l_int|NULL
comma
multiline_comment|/* write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select - default */
l_int|NULL
comma
multiline_comment|/* ioctl - default */
id|generic_file_mmap
comma
multiline_comment|/* mmap */
l_int|NULL
comma
multiline_comment|/* no special open is needed */
l_int|NULL
comma
multiline_comment|/* release */
id|file_fsync
comma
multiline_comment|/* fsync */
)brace
suffix:semicolon
DECL|variable|hpfs_file_iops
r_static
r_const
r_struct
id|inode_operations
id|hpfs_file_iops
op_assign
(brace
(paren
id|nonconst
op_star
)paren
op_amp
id|hpfs_file_ops
comma
multiline_comment|/* default file operations */
l_int|NULL
comma
multiline_comment|/* create */
l_int|NULL
comma
multiline_comment|/* lookup */
l_int|NULL
comma
multiline_comment|/* link */
l_int|NULL
comma
multiline_comment|/* unlink */
l_int|NULL
comma
multiline_comment|/* symlink */
l_int|NULL
comma
multiline_comment|/* mkdir */
l_int|NULL
comma
multiline_comment|/* rmdir */
l_int|NULL
comma
multiline_comment|/* mknod */
l_int|NULL
comma
multiline_comment|/* rename */
l_int|NULL
comma
multiline_comment|/* readlink */
l_int|NULL
comma
multiline_comment|/* follow_link */
id|generic_readpage
comma
multiline_comment|/* readpage */
l_int|NULL
comma
multiline_comment|/* writepage */
(paren
r_int
(paren
op_star
)paren
(paren
r_struct
id|inode
op_star
comma
r_int
)paren
)paren
op_amp
id|hpfs_bmap
comma
multiline_comment|/* bmap */
l_int|NULL
comma
multiline_comment|/* truncate */
l_int|NULL
comma
multiline_comment|/* permission */
)brace
suffix:semicolon
multiline_comment|/* directory ops */
r_static
r_int
id|hpfs_dir_read
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|count
)paren
suffix:semicolon
r_static
r_int
id|hpfs_readdir
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|dirent
comma
id|filldir_t
id|filldir
)paren
suffix:semicolon
r_static
r_int
id|hpfs_lookup
c_func
(paren
r_struct
id|inode
op_star
comma
r_const
r_char
op_star
comma
r_int
comma
r_struct
id|inode
op_star
op_star
)paren
suffix:semicolon
DECL|variable|hpfs_dir_ops
r_static
r_const
r_struct
id|file_operations
id|hpfs_dir_ops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|hpfs_dir_read
comma
multiline_comment|/* read */
l_int|NULL
comma
multiline_comment|/* write - bad */
id|hpfs_readdir
comma
multiline_comment|/* readdir */
l_int|NULL
comma
multiline_comment|/* select - default */
l_int|NULL
comma
multiline_comment|/* ioctl - default */
l_int|NULL
comma
multiline_comment|/* mmap */
l_int|NULL
comma
multiline_comment|/* no special open code */
l_int|NULL
comma
multiline_comment|/* no special release code */
id|file_fsync
comma
multiline_comment|/* fsync */
)brace
suffix:semicolon
DECL|variable|hpfs_dir_iops
r_static
r_const
r_struct
id|inode_operations
id|hpfs_dir_iops
op_assign
(brace
(paren
id|nonconst
op_star
)paren
op_amp
id|hpfs_dir_ops
comma
multiline_comment|/* default directory file ops */
l_int|NULL
comma
multiline_comment|/* create */
id|hpfs_lookup
comma
multiline_comment|/* lookup */
l_int|NULL
comma
multiline_comment|/* link */
l_int|NULL
comma
multiline_comment|/* unlink */
l_int|NULL
comma
multiline_comment|/* symlink */
l_int|NULL
comma
multiline_comment|/* mkdir */
l_int|NULL
comma
multiline_comment|/* rmdir */
l_int|NULL
comma
multiline_comment|/* mknod */
l_int|NULL
comma
multiline_comment|/* rename */
l_int|NULL
comma
multiline_comment|/* readlink */
l_int|NULL
comma
multiline_comment|/* follow_link */
l_int|NULL
comma
multiline_comment|/* readpage */
l_int|NULL
comma
multiline_comment|/* writepage */
l_int|NULL
comma
multiline_comment|/* bmap */
l_int|NULL
comma
multiline_comment|/* truncate */
l_int|NULL
comma
multiline_comment|/* permission */
)brace
suffix:semicolon
multiline_comment|/* Four 512-byte buffers and the 2k block obtained by concatenating them */
DECL|struct|quad_buffer_head
r_struct
id|quad_buffer_head
(brace
DECL|member|bh
r_struct
id|buffer_head
op_star
id|bh
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|data
r_void
op_star
id|data
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* forwards */
r_static
r_int
id|parse_opts
c_func
(paren
r_char
op_star
id|opts
comma
id|uid_t
op_star
id|uid
comma
id|gid_t
op_star
id|gid
comma
id|umode_t
op_star
id|umask
comma
r_int
op_star
id|lowercase
comma
r_int
op_star
id|conv
comma
r_int
op_star
id|nocheck
)paren
suffix:semicolon
r_static
r_int
id|check_warn
c_func
(paren
r_int
id|not_ok
comma
r_const
r_char
op_star
id|p1
comma
r_const
r_char
op_star
id|p2
comma
r_const
r_char
op_star
id|p3
)paren
suffix:semicolon
r_static
r_int
id|zerop
c_func
(paren
r_void
op_star
id|addr
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_void
id|count_dnodes
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|dnode_secno
id|dno
comma
r_int
op_star
id|n_dnodes
comma
r_int
op_star
id|n_subdirs
)paren
suffix:semicolon
r_static
r_int
id|count_bitmap
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
suffix:semicolon
r_static
r_int
id|count_one_bitmap
c_func
(paren
id|kdev_t
id|dev
comma
id|secno
id|secno
)paren
suffix:semicolon
r_static
id|secno
id|bplus_lookup
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|bplus_header
op_star
id|b
comma
id|secno
id|file_secno
comma
r_struct
id|buffer_head
op_star
op_star
id|bhp
)paren
suffix:semicolon
r_static
r_struct
id|hpfs_dirent
op_star
id|map_dirent
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|dnode_secno
id|dno
comma
r_const
r_int
r_char
op_star
id|name
comma
r_int
id|len
comma
r_struct
id|quad_buffer_head
op_star
id|qbh
)paren
suffix:semicolon
r_static
r_struct
id|hpfs_dirent
op_star
id|map_pos_dirent
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
op_star
id|posp
comma
r_struct
id|quad_buffer_head
op_star
id|qbh
)paren
suffix:semicolon
r_static
id|dnode_secno
id|dir_subdno
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|pos
)paren
suffix:semicolon
r_static
r_struct
id|hpfs_dirent
op_star
id|map_nth_dirent
c_func
(paren
id|kdev_t
id|dev
comma
id|dnode_secno
id|dno
comma
r_int
id|n
comma
r_struct
id|quad_buffer_head
op_star
id|qbh
)paren
suffix:semicolon
r_static
r_int
id|choose_conv
c_func
(paren
r_int
r_char
op_star
id|p
comma
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|convcpy_tofs
c_func
(paren
r_int
r_char
op_star
id|out
comma
r_int
r_char
op_star
id|in
comma
r_int
id|len
)paren
suffix:semicolon
r_static
id|dnode_secno
id|fnode_dno
c_func
(paren
id|kdev_t
id|dev
comma
id|ino_t
id|ino
)paren
suffix:semicolon
r_static
r_struct
id|fnode
op_star
id|map_fnode
c_func
(paren
id|kdev_t
id|dev
comma
id|ino_t
id|ino
comma
r_struct
id|buffer_head
op_star
op_star
id|bhp
)paren
suffix:semicolon
r_static
r_struct
id|anode
op_star
id|map_anode
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|secno
comma
r_struct
id|buffer_head
op_star
op_star
id|bhp
)paren
suffix:semicolon
r_static
r_struct
id|dnode
op_star
id|map_dnode
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|secno
comma
r_struct
id|quad_buffer_head
op_star
id|qbh
)paren
suffix:semicolon
r_static
r_void
op_star
id|map_sector
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|secno
comma
r_struct
id|buffer_head
op_star
op_star
id|bhp
)paren
suffix:semicolon
r_static
r_void
op_star
id|map_4sectors
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|secno
comma
r_struct
id|quad_buffer_head
op_star
id|qbh
)paren
suffix:semicolon
r_static
r_void
id|brelse4
c_func
(paren
r_struct
id|quad_buffer_head
op_star
id|qbh
)paren
suffix:semicolon
multiline_comment|/*&n; * make inode number for a file&n; */
DECL|function|file_ino
r_static
r_inline
id|ino_t
id|file_ino
c_func
(paren
id|fnode_secno
id|secno
)paren
(brace
r_return
id|secno
op_lshift
l_int|1
op_or
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * make inode number for a directory&n; */
DECL|function|dir_ino
r_static
r_inline
id|ino_t
id|dir_ino
c_func
(paren
id|fnode_secno
id|secno
)paren
(brace
r_return
id|secno
op_lshift
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * get fnode address from an inode number&n; */
DECL|function|ino_secno
r_static
r_inline
id|fnode_secno
id|ino_secno
c_func
(paren
id|ino_t
id|ino
)paren
(brace
r_return
id|ino
op_rshift
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * test for directory&squot;s inode number &n; */
DECL|function|ino_is_dir
r_static
r_inline
r_int
id|ino_is_dir
c_func
(paren
id|ino_t
id|ino
)paren
(brace
r_return
(paren
id|ino
op_amp
l_int|1
)paren
op_eq
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * conv= options&n; */
DECL|macro|CONV_BINARY
mdefine_line|#define CONV_BINARY 0&t;&t;&t;/* no conversion */
DECL|macro|CONV_TEXT
mdefine_line|#define CONV_TEXT 1&t;&t;&t;/* crlf-&gt;newline */
DECL|macro|CONV_AUTO
mdefine_line|#define CONV_AUTO 2&t;&t;&t;/* decide based on file contents */
multiline_comment|/*&n; * local time (HPFS) to GMT (Unix)&n; */
DECL|function|local_to_gmt
r_static
r_inline
id|time_t
id|local_to_gmt
c_func
(paren
id|time_t
id|t
)paren
(brace
r_extern
r_struct
id|timezone
id|sys_tz
suffix:semicolon
r_return
id|t
op_plus
id|sys_tz.tz_minuteswest
op_star
l_int|60
op_minus
(paren
id|sys_tz.tz_dsttime
ques
c_cond
l_int|3600
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/* super block ops */
multiline_comment|/*&n; * mount.  This gets one thing, the root directory inode.  It does a&n; * bunch of guessed-at consistency checks.&n; */
DECL|function|hpfs_read_super
r_struct
id|super_block
op_star
id|hpfs_read_super
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_void
op_star
id|options
comma
r_int
id|silent
)paren
(brace
r_struct
id|hpfs_boot_block
op_star
id|bootblock
suffix:semicolon
r_struct
id|hpfs_super_block
op_star
id|superblock
suffix:semicolon
r_struct
id|hpfs_spare_block
op_star
id|spareblock
suffix:semicolon
r_struct
id|hpfs_dirent
op_star
id|de
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh0
comma
op_star
id|bh1
comma
op_star
id|bh2
suffix:semicolon
r_struct
id|quad_buffer_head
id|qbh
suffix:semicolon
id|dnode_secno
id|root_dno
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
id|uid_t
id|uid
suffix:semicolon
id|gid_t
id|gid
suffix:semicolon
id|umode_t
id|umask
suffix:semicolon
r_int
id|lowercase
suffix:semicolon
r_int
id|conv
suffix:semicolon
r_int
id|dubious
suffix:semicolon
r_int
id|nocheck
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/*&n;&t; * Get the mount options&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|parse_opts
c_func
(paren
id|options
comma
op_amp
id|uid
comma
op_amp
id|gid
comma
op_amp
id|umask
comma
op_amp
id|lowercase
comma
op_amp
id|conv
comma
op_amp
id|nocheck
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HPFS: syntax error in mount options.  Not mounted.&bslash;n&quot;
)paren
suffix:semicolon
id|s-&gt;s_dev
op_assign
l_int|0
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Fill in the super block struct&n;&t; */
id|lock_super
c_func
(paren
id|s
)paren
suffix:semicolon
id|dev
op_assign
id|s-&gt;s_dev
suffix:semicolon
id|set_blocksize
c_func
(paren
id|dev
comma
l_int|512
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * fetch sectors 0, 16, 17&n;&t; */
id|bootblock
op_assign
id|map_sector
c_func
(paren
id|dev
comma
l_int|0
comma
op_amp
id|bh0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bootblock
)paren
r_goto
id|bail
suffix:semicolon
id|superblock
op_assign
id|map_sector
c_func
(paren
id|dev
comma
l_int|16
comma
op_amp
id|bh1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|superblock
)paren
r_goto
id|bail0
suffix:semicolon
id|spareblock
op_assign
id|map_sector
c_func
(paren
id|dev
comma
l_int|17
comma
op_amp
id|bh2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|spareblock
)paren
r_goto
id|bail1
suffix:semicolon
multiline_comment|/*&n;&t; * Check that this fs looks enough like a known one that we can find&n;&t; * and read the root directory.&n;&t; */
r_if
c_cond
(paren
id|bootblock-&gt;magic
op_ne
l_int|0xaa55
op_logical_or
id|superblock-&gt;magic
op_ne
id|SB_MAGIC
op_logical_or
id|spareblock-&gt;magic
op_ne
id|SP_MAGIC
op_logical_or
id|bootblock-&gt;sig_28h
op_ne
l_int|0x28
op_logical_or
id|memcmp
c_func
(paren
op_amp
id|bootblock-&gt;sig_hpfs
comma
l_string|&quot;HPFS    &quot;
comma
l_int|8
)paren
op_logical_or
id|little_ushort
c_func
(paren
id|bootblock-&gt;bytes_per_sector
)paren
op_ne
l_int|512
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HPFS: hpfs_read_super: Not HPFS&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|bail2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check for inconsistencies -- possibly wrong guesses here, possibly&n;&t; * filesystem problems.&n;&t; */
id|dubious
op_assign
l_int|0
suffix:semicolon
id|dubious
op_or_assign
id|check_warn
c_func
(paren
id|spareblock-&gt;dirty
op_ne
l_int|0
comma
l_string|&quot;`Improperly stopped&squot;&quot;
comma
l_string|&quot;flag is set&quot;
comma
l_string|&quot;run CHKDSK&quot;
)paren
suffix:semicolon
id|dubious
op_or_assign
id|check_warn
c_func
(paren
id|spareblock-&gt;n_spares_used
op_ne
l_int|0
comma
l_string|&quot;Spare blocks&quot;
comma
l_string|&quot;may be in use&quot;
comma
l_string|&quot;run CHKDSK&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Above errors mean we could get wrong answers if we proceed,&n;&t; * so don&squot;t&n;&t; */
r_if
c_cond
(paren
id|dubious
op_logical_and
op_logical_neg
id|nocheck
)paren
r_goto
id|bail2
suffix:semicolon
id|dubious
op_or_assign
id|check_warn
c_func
(paren
(paren
id|spareblock-&gt;n_dnode_spares
op_ne
id|spareblock-&gt;n_dnode_spares_free
)paren
comma
l_string|&quot;Spare dnodes&quot;
comma
l_string|&quot;may be in use&quot;
comma
l_string|&quot;run CHKDSK&quot;
)paren
suffix:semicolon
id|dubious
op_or_assign
id|check_warn
c_func
(paren
id|superblock-&gt;zero1
op_ne
l_int|0
comma
l_string|&quot;#1&quot;
comma
l_string|&quot;unknown word nonzero&quot;
comma
l_string|&quot;investigate&quot;
)paren
suffix:semicolon
id|dubious
op_or_assign
id|check_warn
c_func
(paren
id|superblock-&gt;zero3
op_ne
l_int|0
comma
l_string|&quot;#3&quot;
comma
l_string|&quot;unknown word nonzero&quot;
comma
l_string|&quot;investigate&quot;
)paren
suffix:semicolon
id|dubious
op_or_assign
id|check_warn
c_func
(paren
id|superblock-&gt;zero4
op_ne
l_int|0
comma
l_string|&quot;#4&quot;
comma
l_string|&quot;unknown word nonzero&quot;
comma
l_string|&quot;investigate&quot;
)paren
suffix:semicolon
id|dubious
op_or_assign
id|check_warn
c_func
(paren
op_logical_neg
id|zerop
c_func
(paren
id|superblock-&gt;zero5
comma
r_sizeof
id|superblock-&gt;zero5
)paren
comma
l_string|&quot;#5&quot;
comma
l_string|&quot;unknown word nonzero&quot;
comma
l_string|&quot;investigate&quot;
)paren
suffix:semicolon
id|dubious
op_or_assign
id|check_warn
c_func
(paren
op_logical_neg
id|zerop
c_func
(paren
id|superblock-&gt;zero6
comma
r_sizeof
id|superblock-&gt;zero6
)paren
comma
l_string|&quot;#6&quot;
comma
l_string|&quot;unknown word nonzero&quot;
comma
l_string|&quot;investigate&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dubious
)paren
id|printk
c_func
(paren
l_string|&quot;HPFS: Proceeding, but operation may be unreliable&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set fs read only&n;&t; */
id|s-&gt;s_flags
op_or_assign
id|MS_RDONLY
suffix:semicolon
multiline_comment|/*&n;&t; * fill in standard stuff&n;&t; */
id|s-&gt;s_magic
op_assign
id|HPFS_SUPER_MAGIC
suffix:semicolon
id|s-&gt;s_blocksize
op_assign
l_int|512
suffix:semicolon
id|s-&gt;s_blocksize_bits
op_assign
l_int|9
suffix:semicolon
id|s-&gt;s_op
op_assign
(paren
r_struct
id|super_operations
op_star
)paren
op_amp
id|hpfs_sops
suffix:semicolon
multiline_comment|/*&n;&t; * fill in hpfs stuff&n;&t; */
id|s-&gt;s_hpfs_root
op_assign
id|dir_ino
c_func
(paren
id|superblock-&gt;root
)paren
suffix:semicolon
id|s-&gt;s_hpfs_fs_size
op_assign
id|superblock-&gt;n_sectors
suffix:semicolon
id|s-&gt;s_hpfs_dirband_size
op_assign
id|superblock-&gt;n_dir_band
op_div
l_int|4
suffix:semicolon
id|s-&gt;s_hpfs_dmap
op_assign
id|superblock-&gt;dir_band_bitmap
suffix:semicolon
id|s-&gt;s_hpfs_bitmaps
op_assign
id|superblock-&gt;bitmaps
suffix:semicolon
id|s-&gt;s_hpfs_uid
op_assign
id|uid
suffix:semicolon
id|s-&gt;s_hpfs_gid
op_assign
id|gid
suffix:semicolon
id|s-&gt;s_hpfs_mode
op_assign
l_int|0777
op_amp
op_complement
id|umask
suffix:semicolon
id|s-&gt;s_hpfs_n_free
op_assign
op_minus
l_int|1
suffix:semicolon
id|s-&gt;s_hpfs_n_free_dnodes
op_assign
op_minus
l_int|1
suffix:semicolon
id|s-&gt;s_hpfs_lowercase
op_assign
id|lowercase
suffix:semicolon
id|s-&gt;s_hpfs_conv
op_assign
id|conv
suffix:semicolon
multiline_comment|/*&n;&t; * done with the low blocks&n;&t; */
id|brelse
c_func
(paren
id|bh2
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh1
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * all set.  try it out.&n;&t; */
id|s-&gt;s_mounted
op_assign
id|iget
c_func
(paren
id|s
comma
id|s-&gt;s_hpfs_root
)paren
suffix:semicolon
id|unlock_super
c_func
(paren
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;s_mounted
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HPFS: hpfs_read_super: inode get failed&bslash;n&quot;
)paren
suffix:semicolon
id|s-&gt;s_dev
op_assign
l_int|0
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * find the root directory&squot;s . pointer &amp; finish filling in the inode&n;&t; */
id|root_dno
op_assign
id|fnode_dno
c_func
(paren
id|dev
comma
id|s-&gt;s_hpfs_root
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root_dno
)paren
id|de
op_assign
id|map_dirent
c_func
(paren
id|s-&gt;s_mounted
comma
id|root_dno
comma
l_string|&quot;&bslash;001&bslash;001&quot;
comma
l_int|2
comma
op_amp
id|qbh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|root_dno
op_logical_or
op_logical_neg
id|de
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HPFS: &quot;
l_string|&quot;hpfs_read_super: root dir isn&squot;t in the root dir&bslash;n&quot;
)paren
suffix:semicolon
id|s-&gt;s_dev
op_assign
l_int|0
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|s-&gt;s_mounted-&gt;i_atime
op_assign
id|local_to_gmt
c_func
(paren
id|de-&gt;read_date
)paren
suffix:semicolon
id|s-&gt;s_mounted-&gt;i_mtime
op_assign
id|local_to_gmt
c_func
(paren
id|de-&gt;write_date
)paren
suffix:semicolon
id|s-&gt;s_mounted-&gt;i_ctime
op_assign
id|local_to_gmt
c_func
(paren
id|de-&gt;creation_date
)paren
suffix:semicolon
id|brelse4
c_func
(paren
op_amp
id|qbh
)paren
suffix:semicolon
r_return
id|s
suffix:semicolon
id|bail2
suffix:colon
id|brelse
c_func
(paren
id|bh2
)paren
suffix:semicolon
id|bail1
suffix:colon
id|brelse
c_func
(paren
id|bh1
)paren
suffix:semicolon
id|bail0
suffix:colon
id|brelse
c_func
(paren
id|bh0
)paren
suffix:semicolon
id|bail
suffix:colon
id|s-&gt;s_dev
op_assign
l_int|0
suffix:semicolon
id|unlock_super
c_func
(paren
id|s
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|check_warn
r_static
r_int
id|check_warn
c_func
(paren
r_int
id|not_ok
comma
r_const
r_char
op_star
id|p1
comma
r_const
r_char
op_star
id|p2
comma
r_const
r_char
op_star
id|p3
)paren
(brace
r_if
c_cond
(paren
id|not_ok
)paren
id|printk
c_func
(paren
l_string|&quot;HPFS: %s %s. Please %s&bslash;n&quot;
comma
id|p1
comma
id|p2
comma
id|p3
)paren
suffix:semicolon
r_return
id|not_ok
suffix:semicolon
)brace
DECL|function|zerop
r_static
r_int
id|zerop
c_func
(paren
r_void
op_star
id|addr
comma
r_int
id|len
)paren
(brace
r_int
r_char
op_star
id|p
op_assign
id|addr
suffix:semicolon
r_return
id|p
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_and
id|memcmp
c_func
(paren
id|p
comma
id|p
op_plus
l_int|1
comma
id|len
op_minus
l_int|1
)paren
op_eq
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * A tiny parser for option strings, stolen from dosfs.&n; */
DECL|function|parse_opts
r_static
r_int
id|parse_opts
c_func
(paren
r_char
op_star
id|opts
comma
id|uid_t
op_star
id|uid
comma
id|gid_t
op_star
id|gid
comma
id|umode_t
op_star
id|umask
comma
r_int
op_star
id|lowercase
comma
r_int
op_star
id|conv
comma
r_int
op_star
id|nocheck
)paren
(brace
r_char
op_star
id|p
comma
op_star
id|rhs
suffix:semicolon
op_star
id|uid
op_assign
id|current-&gt;uid
suffix:semicolon
op_star
id|gid
op_assign
id|current-&gt;gid
suffix:semicolon
op_star
id|umask
op_assign
id|current-&gt;fs-&gt;umask
suffix:semicolon
op_star
id|lowercase
op_assign
l_int|1
suffix:semicolon
op_star
id|conv
op_assign
id|CONV_BINARY
suffix:semicolon
op_star
id|nocheck
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|opts
)paren
r_return
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|strtok
c_func
(paren
id|opts
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
id|p
op_ne
l_int|0
suffix:semicolon
id|p
op_assign
id|strtok
c_func
(paren
l_int|0
comma
l_string|&quot;,&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|rhs
op_assign
id|strchr
c_func
(paren
id|p
comma
l_char|&squot;=&squot;
)paren
)paren
op_ne
l_int|0
)paren
op_star
id|rhs
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;uid&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rhs
op_logical_or
op_logical_neg
op_star
id|rhs
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|uid
op_assign
id|simple_strtoul
c_func
(paren
id|rhs
comma
op_amp
id|rhs
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|rhs
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;gid&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rhs
op_logical_or
op_logical_neg
op_star
id|rhs
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|gid
op_assign
id|simple_strtoul
c_func
(paren
id|rhs
comma
op_amp
id|rhs
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|rhs
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;umask&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rhs
op_logical_or
op_logical_neg
op_star
id|rhs
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|umask
op_assign
id|simple_strtoul
c_func
(paren
id|rhs
comma
op_amp
id|rhs
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|rhs
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;case&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|rhs
comma
l_string|&quot;lower&quot;
)paren
)paren
op_star
id|lowercase
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|rhs
comma
l_string|&quot;asis&quot;
)paren
)paren
op_star
id|lowercase
op_assign
l_int|0
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;conv&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|rhs
comma
l_string|&quot;binary&quot;
)paren
)paren
op_star
id|conv
op_assign
id|CONV_BINARY
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|rhs
comma
l_string|&quot;text&quot;
)paren
)paren
op_star
id|conv
op_assign
id|CONV_TEXT
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|rhs
comma
l_string|&quot;auto&quot;
)paren
)paren
op_star
id|conv
op_assign
id|CONV_AUTO
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|p
comma
l_string|&quot;nocheck&quot;
)paren
)paren
op_star
id|nocheck
op_assign
l_int|1
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * read_inode.  This is called with exclusive access to a new inode that&n; * has only (i_dev,i_ino) set.  It is responsible for filling in the rest.&n; * We leave the dates blank, to be filled in from the dir entry.&n; *&n; * NOTE that there must be no sleeping from the return in this routine&n; * until lookup() finishes filling in the inode, otherwise the partly&n; * completed inode would be visible during the sleep.&n; *&n; * It is done in this strange and sinful way because the alternative&n; * is to read the fnode, find the dir pointer in it, read that fnode&n; * to get the dnode pointer, search through that whole directory for&n; * the ino we&squot;re reading, and get the dates.  It works that way, but&n; * ls sounds like fsck.&n; */
DECL|function|hpfs_read_inode
r_static
r_void
id|hpfs_read_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|super_block
op_star
id|s
op_assign
id|inode-&gt;i_sb
suffix:semicolon
multiline_comment|/* be ready to bail out */
id|inode-&gt;i_op
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_mode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_ino
op_eq
l_int|0
op_logical_or
id|ino_secno
c_func
(paren
id|inode-&gt;i_ino
)paren
op_ge
id|inode-&gt;i_sb-&gt;s_hpfs_fs_size
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HPFS: read_inode: bad ino&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * canned stuff&n;&t; */
id|inode-&gt;i_uid
op_assign
id|s-&gt;s_hpfs_uid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|s-&gt;s_hpfs_gid
suffix:semicolon
id|inode-&gt;i_mode
op_assign
id|s-&gt;s_hpfs_mode
suffix:semicolon
id|inode-&gt;i_hpfs_conv
op_assign
id|s-&gt;s_hpfs_conv
suffix:semicolon
id|inode-&gt;i_hpfs_dno
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_hpfs_n_secs
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_hpfs_file_sec
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_hpfs_disk_sec
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_hpfs_dpos
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_hpfs_dsubdno
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * figure out whether we are looking at a directory or a file&n;&t; */
r_if
c_cond
(paren
id|ino_is_dir
c_func
(paren
id|inode-&gt;i_ino
)paren
)paren
id|inode-&gt;i_mode
op_or_assign
id|S_IFDIR
suffix:semicolon
r_else
(brace
id|inode-&gt;i_mode
op_or_assign
id|S_IFREG
suffix:semicolon
id|inode-&gt;i_mode
op_and_assign
op_complement
l_int|0111
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * these fields must be filled in from the dir entry, which we don&squot;t&n;&t; * have but lookup does.  It will fill them in before letting the&n;&t; * inode out of its grasp.&n;&t; */
id|inode-&gt;i_atime
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * fill in the rest&n;&t; */
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
(paren
r_struct
id|inode_operations
op_star
)paren
op_amp
id|hpfs_file_iops
suffix:semicolon
id|inode-&gt;i_nlink
op_assign
l_int|1
suffix:semicolon
id|inode-&gt;i_blksize
op_assign
l_int|512
suffix:semicolon
)brace
r_else
(brace
r_int
id|n_dnodes
comma
id|n_subdirs
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh0
suffix:semicolon
r_struct
id|fnode
op_star
id|fnode
op_assign
id|map_fnode
c_func
(paren
id|inode-&gt;i_dev
comma
id|inode-&gt;i_ino
comma
op_amp
id|bh0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fnode
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HPFS: read_inode: no fnode&bslash;n&quot;
)paren
suffix:semicolon
id|inode-&gt;i_mode
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|inode-&gt;i_hpfs_parent_dir
op_assign
id|dir_ino
c_func
(paren
id|fnode-&gt;up
)paren
suffix:semicolon
id|inode-&gt;i_hpfs_dno
op_assign
id|fnode-&gt;u.external
(braket
l_int|0
)braket
dot
id|disk_secno
suffix:semicolon
id|brelse
c_func
(paren
id|bh0
)paren
suffix:semicolon
id|n_dnodes
op_assign
id|n_subdirs
op_assign
l_int|0
suffix:semicolon
id|count_dnodes
c_func
(paren
id|inode
comma
id|inode-&gt;i_hpfs_dno
comma
op_amp
id|n_dnodes
comma
op_amp
id|n_subdirs
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
(paren
r_struct
id|inode_operations
op_star
)paren
op_amp
id|hpfs_dir_iops
suffix:semicolon
id|inode-&gt;i_blksize
op_assign
l_int|512
suffix:semicolon
multiline_comment|/* 2048 here confuses ls &amp; du &amp; ... */
id|inode-&gt;i_blocks
op_assign
l_int|4
op_star
id|n_dnodes
suffix:semicolon
id|inode-&gt;i_size
op_assign
l_int|512
op_star
id|inode-&gt;i_blocks
suffix:semicolon
id|inode-&gt;i_nlink
op_assign
l_int|2
op_plus
id|n_subdirs
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * unmount.&n; */
DECL|function|hpfs_put_super
r_static
r_void
id|hpfs_put_super
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
id|lock_super
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;s_dev
op_assign
l_int|0
suffix:semicolon
id|unlock_super
c_func
(paren
id|s
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/*&n; * statfs.  For free inode counts we report the count of dnodes in the&n; * directory band -- not exactly right but pretty analogous.&n; */
DECL|function|hpfs_statfs
r_static
r_void
id|hpfs_statfs
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_struct
id|statfs
op_star
id|buf
comma
r_int
id|bufsiz
)paren
(brace
r_struct
id|statfs
id|tmp
suffix:semicolon
multiline_comment|/*&n;&t; * count the bits in the bitmaps, unless we already have&n;&t; */
r_if
c_cond
(paren
id|s-&gt;s_hpfs_n_free
op_eq
op_minus
l_int|1
)paren
(brace
id|s-&gt;s_hpfs_n_free
op_assign
id|count_bitmap
c_func
(paren
id|s
)paren
suffix:semicolon
id|s-&gt;s_hpfs_n_free_dnodes
op_assign
id|count_one_bitmap
c_func
(paren
id|s-&gt;s_dev
comma
id|s-&gt;s_hpfs_dmap
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * fill in the user statfs struct&n;&t; */
id|tmp.f_type
op_assign
id|s-&gt;s_magic
suffix:semicolon
id|tmp.f_bsize
op_assign
l_int|512
suffix:semicolon
id|tmp.f_blocks
op_assign
id|s-&gt;s_hpfs_fs_size
suffix:semicolon
id|tmp.f_bfree
op_assign
id|s-&gt;s_hpfs_n_free
suffix:semicolon
id|tmp.f_bavail
op_assign
id|s-&gt;s_hpfs_n_free
suffix:semicolon
id|tmp.f_files
op_assign
id|s-&gt;s_hpfs_dirband_size
suffix:semicolon
id|tmp.f_ffree
op_assign
id|s-&gt;s_hpfs_n_free_dnodes
suffix:semicolon
id|tmp.f_namelen
op_assign
l_int|254
suffix:semicolon
id|copy_to_user
c_func
(paren
id|buf
comma
op_amp
id|tmp
comma
id|bufsiz
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * remount.  Don&squot;t let read only be turned off.&n; */
DECL|function|hpfs_remount_fs
r_static
r_int
id|hpfs_remount_fs
c_func
(paren
r_struct
id|super_block
op_star
id|s
comma
r_int
op_star
id|flags
comma
r_char
op_star
id|data
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|flags
op_amp
id|MS_RDONLY
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * count the dnodes in a directory, and the subdirs.&n; */
DECL|function|count_dnodes
r_static
r_void
id|count_dnodes
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|dnode_secno
id|dno
comma
r_int
op_star
id|n_dnodes
comma
r_int
op_star
id|n_subdirs
)paren
(brace
r_struct
id|quad_buffer_head
id|qbh
suffix:semicolon
r_struct
id|dnode
op_star
id|dnode
suffix:semicolon
r_struct
id|hpfs_dirent
op_star
id|de
suffix:semicolon
r_struct
id|hpfs_dirent
op_star
id|de_end
suffix:semicolon
id|dnode
op_assign
id|map_dnode
c_func
(paren
id|inode-&gt;i_dev
comma
id|dno
comma
op_amp
id|qbh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dnode
)paren
r_return
suffix:semicolon
id|de
op_assign
id|dnode_first_de
c_func
(paren
id|dnode
)paren
suffix:semicolon
id|de_end
op_assign
id|dnode_end_de
c_func
(paren
id|dnode
)paren
suffix:semicolon
(paren
op_star
id|n_dnodes
)paren
op_increment
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|de
OL
id|de_end
suffix:semicolon
id|de
op_assign
id|de_next_de
c_func
(paren
id|de
)paren
)paren
(brace
r_if
c_cond
(paren
id|de-&gt;down
)paren
id|count_dnodes
c_func
(paren
id|inode
comma
id|de_down_pointer
c_func
(paren
id|de
)paren
comma
id|n_dnodes
comma
id|n_subdirs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;directory
op_logical_and
op_logical_neg
id|de-&gt;first
)paren
(paren
op_star
id|n_subdirs
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;last
op_logical_or
id|de-&gt;length
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|brelse4
c_func
(paren
op_amp
id|qbh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * count the bits in the free space bit maps&n; */
DECL|function|count_bitmap
r_static
r_int
id|count_bitmap
c_func
(paren
r_struct
id|super_block
op_star
id|s
)paren
(brace
r_int
id|n
comma
id|count
comma
id|n_bands
suffix:semicolon
id|secno
op_star
id|bitmaps
suffix:semicolon
r_struct
id|quad_buffer_head
id|qbh
suffix:semicolon
multiline_comment|/*&n;&t; * there is one bit map for each 16384 sectors&n;&t; */
id|n_bands
op_assign
(paren
id|s-&gt;s_hpfs_fs_size
op_plus
l_int|0x3fff
)paren
op_rshift
l_int|14
suffix:semicolon
multiline_comment|/*&n;&t; * their locations are given in an array pointed to by the super&n;&t; * block&n;&t; */
id|bitmaps
op_assign
id|map_4sectors
c_func
(paren
id|s-&gt;s_dev
comma
id|s-&gt;s_hpfs_bitmaps
comma
op_amp
id|qbh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bitmaps
)paren
r_return
l_int|0
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * map each one and count the free sectors&n;&t; */
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|n_bands
suffix:semicolon
id|n
op_increment
)paren
r_if
c_cond
(paren
id|bitmaps
(braket
id|n
)braket
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;HPFS: bit map pointer missing&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|count
op_add_assign
id|count_one_bitmap
c_func
(paren
id|s-&gt;s_dev
comma
id|bitmaps
(braket
id|n
)braket
)paren
suffix:semicolon
id|brelse4
c_func
(paren
op_amp
id|qbh
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * Read in one bit map, count the bits, return the count.&n; */
DECL|function|count_one_bitmap
r_static
r_int
id|count_one_bitmap
c_func
(paren
id|kdev_t
id|dev
comma
id|secno
id|secno
)paren
(brace
r_struct
id|quad_buffer_head
id|qbh
suffix:semicolon
r_char
op_star
id|bits
suffix:semicolon
r_int
id|i
comma
id|count
suffix:semicolon
id|bits
op_assign
id|map_4sectors
c_func
(paren
id|dev
comma
id|secno
comma
op_amp
id|qbh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bits
)paren
r_return
l_int|0
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
op_star
l_int|2048
suffix:semicolon
id|i
op_increment
)paren
id|count
op_add_assign
(paren
id|test_bit
c_func
(paren
id|i
comma
id|bits
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|brelse4
c_func
(paren
op_amp
id|qbh
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
"&f;"
multiline_comment|/* file ops */
multiline_comment|/*&n; * read.  Read the bytes, put them in buf, return the count.&n; */
DECL|function|hpfs_file_read
r_static
r_int
id|hpfs_file_read
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|count
)paren
(brace
r_int
id|q
comma
id|r
comma
id|n
comma
id|n0
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_char
op_star
id|block
suffix:semicolon
r_char
op_star
id|start
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_eq
l_int|0
op_logical_or
op_logical_neg
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * truncate count at EOF&n;&t; */
r_if
c_cond
(paren
id|count
OG
id|inode-&gt;i_size
op_minus
(paren
id|off_t
)paren
id|filp-&gt;f_pos
)paren
id|count
op_assign
id|inode-&gt;i_size
op_minus
id|filp-&gt;f_pos
suffix:semicolon
id|start
op_assign
id|buf
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * get file sector number, offset in sector, length to end of&n;&t;&t; * sector&n;&t;&t; */
id|q
op_assign
id|filp-&gt;f_pos
op_rshift
l_int|9
suffix:semicolon
id|r
op_assign
id|filp-&gt;f_pos
op_amp
l_int|511
suffix:semicolon
id|n
op_assign
l_int|512
op_minus
id|r
suffix:semicolon
multiline_comment|/*&n;&t;&t; * get length to copy to user buffer&n;&t;&t; */
r_if
c_cond
(paren
id|n
OG
id|count
)paren
id|n
op_assign
id|count
suffix:semicolon
multiline_comment|/*&n;&t;&t; * read the sector, copy to user&n;&t;&t; */
id|block
op_assign
id|map_sector
c_func
(paren
id|inode-&gt;i_dev
comma
id|hpfs_bmap
c_func
(paren
id|inode
comma
id|q
)paren
comma
op_amp
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|block
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/*&n;&t;&t; * but first decide if it has &bslash;r&bslash;n, if the mount option said&n;&t;&t; * to do that&n;&t;&t; */
r_if
c_cond
(paren
id|inode-&gt;i_hpfs_conv
op_eq
id|CONV_AUTO
)paren
id|inode-&gt;i_hpfs_conv
op_assign
id|choose_conv
c_func
(paren
id|block
op_plus
id|r
comma
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_hpfs_conv
op_eq
id|CONV_BINARY
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * regular copy, output length is same as input&n;&t;&t;&t; * length&n;&t;&t;&t; */
id|copy_to_user
c_func
(paren
id|buf
comma
id|block
op_plus
id|r
comma
id|n
)paren
suffix:semicolon
id|n0
op_assign
id|n
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * squeeze out &bslash;r, output length varies&n;&t;&t;&t; */
id|n0
op_assign
id|convcpy_tofs
c_func
(paren
id|buf
comma
id|block
op_plus
id|r
comma
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|inode-&gt;i_size
op_minus
(paren
id|off_t
)paren
id|filp-&gt;f_pos
op_minus
id|n
op_plus
id|n0
)paren
id|count
op_assign
id|inode-&gt;i_size
op_minus
id|filp-&gt;f_pos
op_minus
id|n
op_plus
id|n0
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * advance input n bytes, output n0 bytes&n;&t;&t; */
id|filp-&gt;f_pos
op_add_assign
id|n
suffix:semicolon
id|buf
op_add_assign
id|n0
suffix:semicolon
id|count
op_sub_assign
id|n0
suffix:semicolon
)brace
r_return
id|buf
op_minus
id|start
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine implements conv=auto.  Return CONV_BINARY or CONV_TEXT.&n; */
DECL|function|choose_conv
r_static
r_int
id|choose_conv
c_func
(paren
r_int
r_char
op_star
id|p
comma
r_int
id|len
)paren
(brace
r_int
id|tvote
comma
id|bvote
suffix:semicolon
r_int
id|c
suffix:semicolon
id|tvote
op_assign
id|bvote
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
id|c
op_assign
op_star
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
OL
l_char|&squot; &squot;
)paren
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;r&squot;
op_logical_and
id|len
op_logical_and
op_star
id|p
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|tvote
op_add_assign
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;t&squot;
op_logical_or
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_else
id|bvote
op_add_assign
l_int|5
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
OL
l_char|&squot;&bslash;177&squot;
)paren
id|tvote
op_increment
suffix:semicolon
r_else
id|bvote
op_add_assign
l_int|5
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tvote
OG
id|bvote
)paren
r_return
id|CONV_TEXT
suffix:semicolon
r_else
r_return
id|CONV_BINARY
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine implements conv=text.  :s/crlf/nl/&n; */
DECL|function|convcpy_tofs
r_static
r_int
id|convcpy_tofs
c_func
(paren
r_int
r_char
op_star
id|out
comma
r_int
r_char
op_star
id|in
comma
r_int
id|len
)paren
(brace
r_int
r_char
op_star
id|start
op_assign
id|out
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
r_int
id|c
op_assign
op_star
id|in
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;r&squot;
op_logical_and
(paren
id|len
op_eq
l_int|0
op_logical_or
op_star
id|in
op_eq
l_char|&squot;&bslash;n&squot;
)paren
)paren
suffix:semicolon
r_else
id|put_user
c_func
(paren
id|c
comma
id|out
op_increment
)paren
suffix:semicolon
)brace
r_return
id|out
op_minus
id|start
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the disk sector number containing a file sector.&n; */
DECL|function|hpfs_bmap
r_static
id|secno
id|hpfs_bmap
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|file_secno
)paren
(brace
r_int
id|n
comma
id|disk_secno
suffix:semicolon
r_struct
id|fnode
op_star
id|fnode
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
multiline_comment|/*&n;&t; * There is one sector run cached in the inode. See if the sector is&n;&t; * in it.&n;&t; */
id|n
op_assign
id|file_secno
op_minus
id|inode-&gt;i_hpfs_file_sec
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
id|inode-&gt;i_hpfs_n_secs
)paren
r_return
id|inode-&gt;i_hpfs_disk_sec
op_plus
id|n
suffix:semicolon
multiline_comment|/*&n;&t; * No, read the fnode and go find the sector.&n;&t; */
r_else
(brace
id|fnode
op_assign
id|map_fnode
c_func
(paren
id|inode-&gt;i_dev
comma
id|inode-&gt;i_ino
comma
op_amp
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fnode
)paren
r_return
l_int|0
suffix:semicolon
id|disk_secno
op_assign
id|bplus_lookup
c_func
(paren
id|inode
comma
op_amp
id|fnode-&gt;btree
comma
id|file_secno
comma
op_amp
id|bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
id|disk_secno
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Search allocation tree *b for the given file sector number and return&n; * the disk sector number.  Buffer *bhp has the tree in it, and can be&n; * reused for subtrees when access to *b is no longer needed.&n; * *bhp is busy on entry and exit. &n; */
DECL|function|bplus_lookup
r_static
id|secno
id|bplus_lookup
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|bplus_header
op_star
id|b
comma
id|secno
id|file_secno
comma
r_struct
id|buffer_head
op_star
op_star
id|bhp
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * A leaf-level tree gives a list of sector runs.  Find the one&n;&t; * containing the file sector we want, cache the map info in the&n;&t; * inode for later, and return the corresponding disk sector.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|b-&gt;internal
)paren
(brace
r_struct
id|bplus_leaf_node
op_star
id|n
op_assign
id|b-&gt;u.external
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|b-&gt;n_used_nodes
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|t
op_assign
id|file_secno
op_minus
id|n
(braket
id|i
)braket
dot
id|file_secno
suffix:semicolon
r_if
c_cond
(paren
id|t
OL
id|n
(braket
id|i
)braket
dot
id|length
)paren
(brace
id|inode-&gt;i_hpfs_file_sec
op_assign
id|n
(braket
id|i
)braket
dot
id|file_secno
suffix:semicolon
id|inode-&gt;i_hpfs_disk_sec
op_assign
id|n
(braket
id|i
)braket
dot
id|disk_secno
suffix:semicolon
id|inode-&gt;i_hpfs_n_secs
op_assign
id|n
(braket
id|i
)braket
dot
id|length
suffix:semicolon
r_return
id|n
(braket
id|i
)braket
dot
id|disk_secno
op_plus
id|t
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * A non-leaf tree gives a list of subtrees.  Find the one containing&n;&t; * the file sector we want, read it in, and recurse to search it.&n;&t; */
r_else
(brace
r_struct
id|bplus_internal_node
op_star
id|n
op_assign
id|b-&gt;u.internal
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|b-&gt;n_used_nodes
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|file_secno
OL
id|n
(braket
id|i
)braket
dot
id|file_secno
)paren
(brace
r_struct
id|anode
op_star
id|anode
suffix:semicolon
id|anode_secno
id|ano
op_assign
id|n
(braket
id|i
)braket
dot
id|down
suffix:semicolon
id|brelse
c_func
(paren
op_star
id|bhp
)paren
suffix:semicolon
id|anode
op_assign
id|map_anode
c_func
(paren
id|inode-&gt;i_dev
comma
id|ano
comma
id|bhp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|anode
)paren
r_break
suffix:semicolon
r_return
id|bplus_lookup
c_func
(paren
id|inode
comma
op_amp
id|anode-&gt;btree
comma
id|file_secno
comma
id|bhp
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * If we get here there was a hole in the file.  As far as I know we&n;&t; * never do get here, but falling off the end would be indelicate. So&n;&t; * return a pointer to a handy all-zero sector.  This is not a&n;&t; * reasonable way to handle files with holes if they really do&n;&t; * happen.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;HPFS: bplus_lookup: sector not found&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|15
suffix:semicolon
)brace
"&f;"
multiline_comment|/* directory ops */
multiline_comment|/*&n; * lookup.  Search the specified directory for the specified name, set&n; * *result to the corresponding inode.&n; *&n; * lookup uses the inode number to tell read_inode whether it is reading&n; * the inode of a directory or a file -- file ino&squot;s are odd, directory&n; * ino&squot;s are even.  read_inode avoids i/o for file inodes; everything&n; * needed is up here in the directory.  (And file fnodes are out in&n; * the boondocks.)&n; */
DECL|function|hpfs_lookup
r_static
r_int
id|hpfs_lookup
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
id|len
comma
r_struct
id|inode
op_star
op_star
id|result
)paren
(brace
r_struct
id|quad_buffer_head
id|qbh
suffix:semicolon
r_struct
id|hpfs_dirent
op_star
id|de
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|ino_t
id|ino
suffix:semicolon
multiline_comment|/* In case of madness */
op_star
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
l_int|0
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
c_func
(paren
id|dir-&gt;i_mode
)paren
)paren
r_goto
id|bail
suffix:semicolon
multiline_comment|/*&n;&t; * Read in the directory entry. &quot;.&quot; is there under the name ^A^A .&n;&t; * Always read the dir even for . and .. in case we need the dates.&n;&t; */
r_if
c_cond
(paren
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
id|len
op_eq
l_int|1
)paren
id|de
op_assign
id|map_dirent
c_func
(paren
id|dir
comma
id|dir-&gt;i_hpfs_dno
comma
l_string|&quot;&bslash;001&bslash;001&quot;
comma
l_int|2
comma
op_amp
id|qbh
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
id|name
(braket
l_int|1
)braket
op_eq
l_char|&squot;.&squot;
op_logical_and
id|len
op_eq
l_int|2
)paren
id|de
op_assign
id|map_dirent
c_func
(paren
id|dir
comma
id|fnode_dno
c_func
(paren
id|dir-&gt;i_dev
comma
id|dir-&gt;i_hpfs_parent_dir
)paren
comma
l_string|&quot;&bslash;001&bslash;001&quot;
comma
l_int|2
comma
op_amp
id|qbh
)paren
suffix:semicolon
r_else
id|de
op_assign
id|map_dirent
c_func
(paren
id|dir
comma
id|dir-&gt;i_hpfs_dno
comma
id|name
comma
id|len
comma
op_amp
id|qbh
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This is not really a bailout, just means file not found.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|de
)paren
r_goto
id|bail
suffix:semicolon
multiline_comment|/*&n;&t; * Get inode number, what we&squot;re after.&n;&t; */
r_if
c_cond
(paren
id|de-&gt;directory
)paren
id|ino
op_assign
id|dir_ino
c_func
(paren
id|de-&gt;fnode
)paren
suffix:semicolon
r_else
id|ino
op_assign
id|file_ino
c_func
(paren
id|de-&gt;fnode
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Go find or make an inode.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|inode
op_assign
id|iget
c_func
(paren
id|dir-&gt;i_sb
comma
id|ino
)paren
)paren
)paren
r_goto
id|bail1
suffix:semicolon
multiline_comment|/*&n;&t; * Fill in the info from the directory if this is a newly created&n;&t; * inode.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_atime
)paren
(brace
id|inode-&gt;i_atime
op_assign
id|local_to_gmt
c_func
(paren
id|de-&gt;read_date
)paren
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
id|local_to_gmt
c_func
(paren
id|de-&gt;write_date
)paren
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|local_to_gmt
c_func
(paren
id|de-&gt;creation_date
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;read_only
)paren
id|inode-&gt;i_mode
op_and_assign
op_complement
l_int|0222
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;directory
)paren
(brace
id|inode-&gt;i_size
op_assign
id|de-&gt;file_size
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * i_blocks should count the fnode and any anodes.&n;&t;&t;&t; * We count 1 for the fnode and don&squot;t bother about&n;&t;&t;&t; * anodes -- the disk heads are on the directory band&n;&t;&t;&t; * and we want them to stay there.&n;&t;&t;&t; */
id|inode-&gt;i_blocks
op_assign
l_int|1
op_plus
(paren
(paren
id|inode-&gt;i_size
op_plus
l_int|511
)paren
op_rshift
l_int|9
)paren
suffix:semicolon
)brace
)brace
id|brelse4
c_func
(paren
op_amp
id|qbh
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Made it.&n;&t; */
op_star
id|result
op_assign
id|inode
suffix:semicolon
id|iput
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Didn&squot;t.&n;&t; */
id|bail1
suffix:colon
id|brelse4
c_func
(paren
op_amp
id|qbh
)paren
suffix:semicolon
id|bail
suffix:colon
id|iput
c_func
(paren
id|dir
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
multiline_comment|/*&n; * Compare two counted strings ignoring case.&n; * HPFS directory order sorts letters as if they&squot;re upper case.&n; */
DECL|function|memcasecmp
r_static
r_inline
r_int
id|memcasecmp
c_func
(paren
r_const
r_int
r_char
op_star
id|s1
comma
r_const
r_int
r_char
op_star
id|s2
comma
r_int
id|n
)paren
(brace
r_int
id|t
suffix:semicolon
r_if
c_cond
(paren
id|n
op_ne
l_int|0
)paren
r_do
(brace
r_int
id|c1
op_assign
id|linux_char_to_upper_linux
(paren
op_star
id|s1
op_increment
)paren
suffix:semicolon
r_int
id|c2
op_assign
id|hpfs_char_to_upper_linux
(paren
op_star
id|s2
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|t
op_assign
id|c1
op_minus
id|c2
)paren
op_ne
l_int|0
)paren
r_return
id|t
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|n
op_ne
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Search a directory for the given name, return a pointer to its dir entry&n; * and a pointer to the buffer containing it.&n; */
DECL|function|map_dirent
r_static
r_struct
id|hpfs_dirent
op_star
id|map_dirent
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|dnode_secno
id|dno
comma
r_const
r_int
r_char
op_star
id|name
comma
r_int
id|len
comma
r_struct
id|quad_buffer_head
op_star
id|qbh
)paren
(brace
r_struct
id|dnode
op_star
id|dnode
suffix:semicolon
r_struct
id|hpfs_dirent
op_star
id|de
suffix:semicolon
r_struct
id|hpfs_dirent
op_star
id|de_end
suffix:semicolon
r_int
id|t
comma
id|l
suffix:semicolon
multiline_comment|/*&n;&t; * read the dnode at the root of our subtree&n;&t; */
id|dnode
op_assign
id|map_dnode
c_func
(paren
id|inode-&gt;i_dev
comma
id|dno
comma
id|qbh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dnode
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * get pointers to start and end+1 of dir entries&n;&t; */
id|de
op_assign
id|dnode_first_de
c_func
(paren
id|dnode
)paren
suffix:semicolon
id|de_end
op_assign
id|dnode_end_de
c_func
(paren
id|dnode
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * look through the entries for the name we&squot;re after&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
id|de
OL
id|de_end
suffix:semicolon
id|de
op_assign
id|de_next_de
c_func
(paren
id|de
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * compare names&n;&t;&t; */
id|l
op_assign
id|len
OL
id|de-&gt;namelen
ques
c_cond
id|len
suffix:colon
id|de-&gt;namelen
suffix:semicolon
id|t
op_assign
id|memcasecmp
c_func
(paren
id|name
comma
id|de-&gt;name
comma
id|l
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * initial substring matches, compare lengths&n;&t;&t; */
r_if
c_cond
(paren
id|t
op_eq
l_int|0
)paren
(brace
id|t
op_assign
id|len
op_minus
id|de-&gt;namelen
suffix:semicolon
multiline_comment|/* bingo */
r_if
c_cond
(paren
id|t
op_eq
l_int|0
)paren
r_return
id|de
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * wanted name .lt. dir name =&gt; not present.&n;&t;&t; */
r_if
c_cond
(paren
id|t
OL
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * if there is a subtree, search it.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|de-&gt;down
)paren
(brace
id|dnode_secno
id|sub_dno
op_assign
id|de_down_pointer
c_func
(paren
id|de
)paren
suffix:semicolon
id|brelse4
c_func
(paren
id|qbh
)paren
suffix:semicolon
r_return
id|map_dirent
c_func
(paren
id|inode
comma
id|sub_dno
comma
id|name
comma
id|len
comma
id|qbh
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * de-&gt;last is set on the last name in the dnode (it&squot;s always&n;&t;&t; * a &quot;&bslash;377&quot; pseudo entry).  de-&gt;length == 0 means we&squot;re about&n;&t;&t; * to infinite loop. This test does nothing in a well-formed&n;&t;&t; * dnode.&n;&t;&t; */
r_if
c_cond
(paren
id|de-&gt;last
op_logical_or
id|de-&gt;length
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * name not found.&n;&t; */
id|brelse4
c_func
(paren
id|qbh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * readdir.  Return exactly 1 dirent.  (I tried and tried, but currently&n; * the interface with libc just does not permit more than 1.  If it gets&n; * fixed, throw this out and just walk the tree and write records into&n; * the user buffer.)&n; *&n; * [ we now can handle multiple dirents, although the current libc doesn&squot;t&n; *   use that. The way hpfs does this is pretty strange, as we need to do&n; *   the name translation etc before calling &quot;filldir()&quot;. This is untested,&n; *   as I don&squot;t have any hpfs partitions to test against.   Linus ]&n; *&n; * We keep track of our position in the dnode tree with a sort of&n; * dewey-decimal record of subtree locations.  Like so:&n; *&n; *   (1 (1.1 1.2 1.3) 2 3 (3.1 (3.1.1 3.1.2) 3.2 3.3 (3.3.1)) 4)&n; *&n; * Subtrees appear after their file, out of lexical order,&n; * which would be before their file.  It&squot;s easier.&n; *&n; * A directory can&squot;t hold more than 56 files, so 6 bits are used for&n; * position numbers.  If the tree is so deep that the position encoding&n; * doesn&squot;t fit, I&squot;m sure something absolutely fascinating happens.&n; *&n; * The actual sequence of f_pos values is&n; *     0 =&gt; .   -1 =&gt; ..   1 1.1 ... 8.9 9 =&gt; files  -2 =&gt; eof&n; *&n; * The directory inode caches one position-to-dnode correspondence so&n; * we won&squot;t have to repeatedly scan the top levels of the tree. &n; */
multiline_comment|/*&n; * Translate the given name: Blam it to lowercase if the mount option said to.&n; */
DECL|function|translate_hpfs_name
r_static
r_void
id|translate_hpfs_name
c_func
(paren
r_const
r_int
r_char
op_star
id|from
comma
r_int
id|len
comma
r_char
op_star
id|to
comma
r_int
id|lowercase
)paren
(brace
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_int
id|t
op_assign
op_star
id|from
suffix:semicolon
id|len
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|lowercase
)paren
id|t
op_assign
id|hpfs_char_to_lower_linux
(paren
id|t
)paren
suffix:semicolon
r_else
id|t
op_assign
id|hpfs_char_to_linux
(paren
id|t
)paren
suffix:semicolon
op_star
id|to
op_assign
id|t
suffix:semicolon
id|from
op_increment
suffix:semicolon
id|to
op_increment
suffix:semicolon
)brace
)brace
DECL|function|hpfs_readdir
r_static
r_int
id|hpfs_readdir
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|dirent
comma
id|filldir_t
id|filldir
)paren
(brace
r_struct
id|quad_buffer_head
id|qbh
suffix:semicolon
r_struct
id|hpfs_dirent
op_star
id|de
suffix:semicolon
r_int
id|namelen
comma
id|lc
suffix:semicolon
id|ino_t
id|ino
suffix:semicolon
r_char
op_star
id|tempname
suffix:semicolon
r_int
id|old_pos
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_eq
l_int|0
op_logical_or
id|inode-&gt;i_sb
op_eq
l_int|0
op_logical_or
op_logical_neg
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
id|tempname
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tempname
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|lc
op_assign
id|inode-&gt;i_sb-&gt;s_hpfs_lowercase
suffix:semicolon
r_switch
c_cond
(paren
(paren
r_int
)paren
id|filp-&gt;f_pos
)paren
(brace
r_case
op_minus
l_int|2
suffix:colon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|dirent
comma
l_string|&quot;.&quot;
comma
l_int|1
comma
id|filp-&gt;f_pos
comma
id|inode-&gt;i_ino
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
id|filp-&gt;f_pos
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* fall through */
r_case
op_minus
l_int|1
suffix:colon
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|dirent
comma
l_string|&quot;..&quot;
comma
l_int|2
comma
id|filp-&gt;f_pos
comma
id|inode-&gt;i_hpfs_parent_dir
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
id|filp-&gt;f_pos
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* fall through */
r_default
suffix:colon
(brace
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|old_pos
op_assign
id|filp-&gt;f_pos
suffix:semicolon
id|de
op_assign
id|map_pos_dirent
c_func
(paren
id|inode
comma
op_amp
id|filp-&gt;f_pos
comma
op_amp
id|qbh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de
)paren
(brace
id|filp-&gt;f_pos
op_assign
op_minus
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
id|namelen
op_assign
id|de-&gt;namelen
suffix:semicolon
id|translate_hpfs_name
c_func
(paren
id|de-&gt;name
comma
id|namelen
comma
id|tempname
comma
id|lc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;directory
)paren
id|ino
op_assign
id|dir_ino
c_func
(paren
id|de-&gt;fnode
)paren
suffix:semicolon
r_else
id|ino
op_assign
id|file_ino
c_func
(paren
id|de-&gt;fnode
)paren
suffix:semicolon
id|brelse4
c_func
(paren
op_amp
id|qbh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|dirent
comma
id|tempname
comma
id|namelen
comma
id|old_pos
comma
id|ino
)paren
OL
l_int|0
)paren
(brace
id|filp-&gt;f_pos
op_assign
id|old_pos
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|tempname
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Map the dir entry at subtree coordinates given by *posp, and&n; * increment *posp to point to the following dir entry. &n; */
DECL|function|map_pos_dirent
r_static
r_struct
id|hpfs_dirent
op_star
id|map_pos_dirent
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
id|loff_t
op_star
id|posp
comma
r_struct
id|quad_buffer_head
op_star
id|qbh
)paren
(brace
r_int
id|pos
comma
id|q
comma
id|r
suffix:semicolon
id|dnode_secno
id|dno
suffix:semicolon
r_struct
id|hpfs_dirent
op_star
id|de
suffix:semicolon
multiline_comment|/*&n;&t; * Get the position code and split off the rightmost index r&n;&t; */
id|pos
op_assign
op_star
id|posp
suffix:semicolon
id|q
op_assign
id|pos
op_rshift
l_int|6
suffix:semicolon
id|r
op_assign
id|pos
op_amp
l_int|077
suffix:semicolon
multiline_comment|/*&n;&t; * Get the sector address of the dnode&n;&t; * pointed to by the leading part q&n;&t; */
id|dno
op_assign
id|dir_subdno
c_func
(paren
id|inode
comma
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dno
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Get the entry at index r in dnode q&n;&t; */
id|de
op_assign
id|map_nth_dirent
c_func
(paren
id|inode-&gt;i_dev
comma
id|dno
comma
id|r
comma
id|qbh
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If none, we&squot;re out of files in this dnode.  Ascend.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|de
)paren
(brace
r_if
c_cond
(paren
id|q
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|posp
op_assign
id|q
op_plus
l_int|1
suffix:semicolon
r_return
id|map_pos_dirent
c_func
(paren
id|inode
comma
id|posp
comma
id|qbh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If a subtree is here, descend.&n;&t; */
r_if
c_cond
(paren
id|de-&gt;down
)paren
op_star
id|posp
op_assign
id|pos
op_lshift
l_int|6
op_or
l_int|1
suffix:semicolon
r_else
op_star
id|posp
op_assign
id|pos
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Don&squot;t return the ^A^A and &bslash;377 entries.&n;&t; */
r_if
c_cond
(paren
id|de-&gt;first
op_logical_or
id|de-&gt;last
)paren
(brace
id|brelse4
c_func
(paren
id|qbh
)paren
suffix:semicolon
r_return
id|map_pos_dirent
c_func
(paren
id|inode
comma
id|posp
comma
id|qbh
)paren
suffix:semicolon
)brace
r_else
r_return
id|de
suffix:semicolon
)brace
multiline_comment|/*&n; * Return the address of the dnode with subtree coordinates given by pos.&n; */
DECL|function|dir_subdno
r_static
id|dnode_secno
id|dir_subdno
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|pos
)paren
(brace
r_struct
id|hpfs_dirent
op_star
id|de
suffix:semicolon
r_struct
id|quad_buffer_head
id|qbh
suffix:semicolon
multiline_comment|/*&n;&t; * 0 is the root dnode&n;&t; */
r_if
c_cond
(paren
id|pos
op_eq
l_int|0
)paren
r_return
id|inode-&gt;i_hpfs_dno
suffix:semicolon
multiline_comment|/*&n;&t; * we have one pos-&gt;dnode translation cached in the inode&n;&t; */
r_else
r_if
c_cond
(paren
id|pos
op_eq
id|inode-&gt;i_hpfs_dpos
)paren
r_return
id|inode-&gt;i_hpfs_dsubdno
suffix:semicolon
multiline_comment|/*&n;&t; * otherwise go look&n;&t; */
r_else
(brace
r_int
id|q
op_assign
id|pos
op_rshift
l_int|6
suffix:semicolon
r_int
id|r
op_assign
id|pos
op_amp
l_int|077
suffix:semicolon
id|dnode_secno
id|dno
suffix:semicolon
multiline_comment|/*&n;&t;&t; * dnode at position q&n;&t;&t; */
id|dno
op_assign
id|dir_subdno
c_func
(paren
id|inode
comma
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dno
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * entry at index r&n;&t;&t; */
id|de
op_assign
id|map_nth_dirent
c_func
(paren
id|inode-&gt;i_dev
comma
id|dno
comma
id|r
comma
op_amp
id|qbh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de
op_logical_or
op_logical_neg
id|de-&gt;down
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * get the dnode down pointer&n;&t;&t; */
id|dno
op_assign
id|de_down_pointer
c_func
(paren
id|de
)paren
suffix:semicolon
id|brelse4
c_func
(paren
op_amp
id|qbh
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * cache it for next time&n;&t;&t; */
id|inode-&gt;i_hpfs_dpos
op_assign
id|pos
suffix:semicolon
id|inode-&gt;i_hpfs_dsubdno
op_assign
id|dno
suffix:semicolon
r_return
id|dno
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Return the dir entry at index n in dnode dno, or 0 if there isn&squot;t one&n; */
DECL|function|map_nth_dirent
r_static
r_struct
id|hpfs_dirent
op_star
id|map_nth_dirent
c_func
(paren
id|kdev_t
id|dev
comma
id|dnode_secno
id|dno
comma
r_int
id|n
comma
r_struct
id|quad_buffer_head
op_star
id|qbh
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|hpfs_dirent
op_star
id|de
comma
op_star
id|de_end
suffix:semicolon
r_struct
id|dnode
op_star
id|dnode
op_assign
id|map_dnode
c_func
(paren
id|dev
comma
id|dno
comma
id|qbh
)paren
suffix:semicolon
id|de
op_assign
id|dnode_first_de
c_func
(paren
id|dnode
)paren
suffix:semicolon
id|de_end
op_assign
id|dnode_end_de
c_func
(paren
id|dnode
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|de
OL
id|de_end
suffix:semicolon
id|i
op_increment
comma
id|de
op_assign
id|de_next_de
c_func
(paren
id|de
)paren
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|n
)paren
r_return
id|de
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;last
op_logical_or
id|de-&gt;length
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|brelse4
c_func
(paren
id|qbh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hpfs_dir_read
r_static
r_int
id|hpfs_dir_read
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|count
)paren
(brace
r_return
op_minus
id|EISDIR
suffix:semicolon
)brace
"&f;"
multiline_comment|/* Return the dnode pointer in a directory fnode */
DECL|function|fnode_dno
r_static
id|dnode_secno
id|fnode_dno
c_func
(paren
id|kdev_t
id|dev
comma
id|ino_t
id|ino
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|fnode
op_star
id|fnode
suffix:semicolon
id|dnode_secno
id|dno
suffix:semicolon
id|fnode
op_assign
id|map_fnode
c_func
(paren
id|dev
comma
id|ino
comma
op_amp
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fnode
)paren
r_return
l_int|0
suffix:semicolon
id|dno
op_assign
id|fnode-&gt;u.external
(braket
l_int|0
)braket
dot
id|disk_secno
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
id|dno
suffix:semicolon
)brace
multiline_comment|/* Map an fnode into a buffer and return pointers to it and to the buffer. */
DECL|function|map_fnode
r_static
r_struct
id|fnode
op_star
id|map_fnode
c_func
(paren
id|kdev_t
id|dev
comma
id|ino_t
id|ino
comma
r_struct
id|buffer_head
op_star
op_star
id|bhp
)paren
(brace
r_struct
id|fnode
op_star
id|fnode
suffix:semicolon
r_if
c_cond
(paren
id|ino
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HPFS: missing fnode&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|fnode
op_assign
id|map_sector
c_func
(paren
id|dev
comma
id|ino_secno
c_func
(paren
id|ino
)paren
comma
id|bhp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fnode
)paren
r_if
c_cond
(paren
id|fnode-&gt;magic
op_ne
id|FNODE_MAGIC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HPFS: map_fnode: bad fnode pointer&bslash;n&quot;
)paren
suffix:semicolon
id|brelse
c_func
(paren
op_star
id|bhp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|fnode
suffix:semicolon
)brace
multiline_comment|/* Map an anode into a buffer and return pointers to it and to the buffer. */
DECL|function|map_anode
r_static
r_struct
id|anode
op_star
id|map_anode
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|secno
comma
r_struct
id|buffer_head
op_star
op_star
id|bhp
)paren
(brace
r_struct
id|anode
op_star
id|anode
suffix:semicolon
r_if
c_cond
(paren
id|secno
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HPFS: missing anode&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|anode
op_assign
id|map_sector
c_func
(paren
id|dev
comma
id|secno
comma
id|bhp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|anode
)paren
r_if
c_cond
(paren
id|anode-&gt;magic
op_ne
id|ANODE_MAGIC
op_logical_or
id|anode-&gt;self
op_ne
id|secno
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HPFS: map_anode: bad anode pointer&bslash;n&quot;
)paren
suffix:semicolon
id|brelse
c_func
(paren
op_star
id|bhp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|anode
suffix:semicolon
)brace
multiline_comment|/* Map a dnode into a buffer and return pointers to it and to the buffer. */
DECL|function|map_dnode
r_static
r_struct
id|dnode
op_star
id|map_dnode
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|secno
comma
r_struct
id|quad_buffer_head
op_star
id|qbh
)paren
(brace
r_struct
id|dnode
op_star
id|dnode
suffix:semicolon
r_if
c_cond
(paren
id|secno
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HPFS: missing dnode&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|dnode
op_assign
id|map_4sectors
c_func
(paren
id|dev
comma
id|secno
comma
id|qbh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dnode
)paren
r_if
c_cond
(paren
id|dnode-&gt;magic
op_ne
id|DNODE_MAGIC
op_logical_or
id|dnode-&gt;self
op_ne
id|secno
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HPFS: map_dnode: bad dnode pointer&bslash;n&quot;
)paren
suffix:semicolon
id|brelse4
c_func
(paren
id|qbh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|dnode
suffix:semicolon
)brace
multiline_comment|/* Map a sector into a buffer and return pointers to it and to the buffer. */
DECL|function|map_sector
r_static
r_void
op_star
id|map_sector
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|secno
comma
r_struct
id|buffer_head
op_star
op_star
id|bhp
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|bhp
op_assign
id|bh
op_assign
id|bread
c_func
(paren
id|dev
comma
id|secno
comma
l_int|512
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|bh-&gt;b_data
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;HPFS: map_sector: read error&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Map 4 sectors into a 4buffer and return pointers to it and to the buffer. */
DECL|function|map_4sectors
r_static
r_void
op_star
id|map_4sectors
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|secno
comma
r_struct
id|quad_buffer_head
op_star
id|qbh
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_char
op_star
id|data
suffix:semicolon
r_if
c_cond
(paren
id|secno
op_amp
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HPFS: map_4sectors: unaligned read&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|qbh-&gt;data
op_assign
id|data
op_assign
id|kmalloc
c_func
(paren
l_int|2048
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|data
)paren
r_goto
id|bail
suffix:semicolon
id|qbh-&gt;bh
(braket
l_int|0
)braket
op_assign
id|bh
op_assign
id|breada
c_func
(paren
id|dev
comma
id|secno
comma
l_int|512
comma
l_int|0
comma
id|UINT_MAX
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|bail0
suffix:semicolon
id|memcpy
c_func
(paren
id|data
comma
id|bh-&gt;b_data
comma
l_int|512
)paren
suffix:semicolon
id|qbh-&gt;bh
(braket
l_int|1
)braket
op_assign
id|bh
op_assign
id|bread
c_func
(paren
id|dev
comma
id|secno
op_plus
l_int|1
comma
l_int|512
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|bail1
suffix:semicolon
id|memcpy
c_func
(paren
id|data
op_plus
l_int|512
comma
id|bh-&gt;b_data
comma
l_int|512
)paren
suffix:semicolon
id|qbh-&gt;bh
(braket
l_int|2
)braket
op_assign
id|bh
op_assign
id|bread
c_func
(paren
id|dev
comma
id|secno
op_plus
l_int|2
comma
l_int|512
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|bail2
suffix:semicolon
id|memcpy
c_func
(paren
id|data
op_plus
l_int|2
op_star
l_int|512
comma
id|bh-&gt;b_data
comma
l_int|512
)paren
suffix:semicolon
id|qbh-&gt;bh
(braket
l_int|3
)braket
op_assign
id|bh
op_assign
id|bread
c_func
(paren
id|dev
comma
id|secno
op_plus
l_int|3
comma
l_int|512
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|bail3
suffix:semicolon
id|memcpy
c_func
(paren
id|data
op_plus
l_int|3
op_star
l_int|512
comma
id|bh-&gt;b_data
comma
l_int|512
)paren
suffix:semicolon
r_return
id|data
suffix:semicolon
id|bail3
suffix:colon
id|brelse
c_func
(paren
id|qbh-&gt;bh
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|bail2
suffix:colon
id|brelse
c_func
(paren
id|qbh-&gt;bh
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|bail1
suffix:colon
id|brelse
c_func
(paren
id|qbh-&gt;bh
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|bail0
suffix:colon
id|kfree_s
c_func
(paren
id|data
comma
l_int|2048
)paren
suffix:semicolon
id|bail
suffix:colon
id|printk
c_func
(paren
l_string|&quot;HPFS: map_4sectors: read error&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Deallocate a 4-buffer block */
DECL|function|brelse4
r_static
r_void
id|brelse4
c_func
(paren
r_struct
id|quad_buffer_head
op_star
id|qbh
)paren
(brace
id|brelse
c_func
(paren
id|qbh-&gt;bh
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|qbh-&gt;bh
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|qbh-&gt;bh
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|qbh-&gt;bh
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|qbh-&gt;data
comma
l_int|2048
)paren
suffix:semicolon
)brace
DECL|variable|hpfs_fs_type
r_static
r_struct
id|file_system_type
id|hpfs_fs_type
op_assign
(brace
id|hpfs_read_super
comma
l_string|&quot;hpfs&quot;
comma
l_int|1
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|init_hpfs_fs
r_int
id|init_hpfs_fs
c_func
(paren
r_void
)paren
(brace
r_return
id|register_filesystem
c_func
(paren
op_amp
id|hpfs_fs_type
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|init_hpfs_fs
c_func
(paren
)paren
)paren
op_eq
l_int|0
)paren
id|register_symtab
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|unregister_filesystem
c_func
(paren
op_amp
id|hpfs_fs_type
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
