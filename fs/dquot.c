multiline_comment|/*&n; * Implementation of the diskquota system for the LINUX operating&n; * system. QUOTA is implemented using the BSD system call interface as&n; * the means of communication with the user level. Currently only the&n; * ext2 filesystem has support for disk quotas. Other filesystems may&n; * be added in the future. This file contains the generic routines&n; * called by the different filesystems on allocation of an inode or&n; * block. These routines take care of the administration needed to&n; * have a consistent diskquota tracking system. The ideas of both&n; * user and group quotas are based on the Melbourne quota system as&n; * used on BSD derived systems. The internal implementation is &n; * based on one of the several variants of the LINUX inode-subsystem&n; * with added complexity of the diskquota system.&n; * &n; * Version: $Id: dquot.c,v 6.3 1996/11/17 18:35:34 mvw Exp mvw $&n; * &n; * Author:&t;Marco van Wieringen &lt;mvw@planets.elm.net&gt;&n; *&n; * Fixes:   Dmitry Gorodchanin &lt;pgmdsg@ibi.com&gt;, 11 Feb 96&n; *&n; *&t;&t;Revised list management to avoid races&n; *&t;&t;-- Bill Hawes, &lt;whawes@star.net&gt;, 9/98&n; *&n; *&t;&t;Fixed races in dquot_transfer(), dqget() and dquot_alloc_...().&n; *&t;&t;As the consequence the locking was moved from dquot_decr_...(),&n; *&t;&t;dquot_incr_...() to calling functions.&n; *&t;&t;invalidate_dquots() now writes modified dquots.&n; *&t;&t;Serialized quota_off() and quota_on() for mount point.&n; *&t;&t;Fixed a few bugs in grow_dquots.&n; *&t;&t;Fixed deadlock in write_dquot() - we no longer account quotas on&n; *&t;&t;quota files&n; *&t;&t;remove_dquot_ref() moved to inode.c - it now traverses through inodes&n; *&t;&t;add_dquot_ref() restarts after blocking&n; *&t;&t;Added check for bogus uid and fixed check for group in quotactl.&n; *&t;&t;Jan Kara, &lt;jack@suse.cz&gt;, sponsored by SuSE CR, 10-11/99&n; *&n; * (C) Copyright 1994 - 1997 Marco van Wieringen &n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/mount.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|__DQUOT_VERSION__
mdefine_line|#define __DQUOT_VERSION__&t;&quot;dquot_6.4.0&quot;
DECL|variable|nr_dquots
DECL|variable|nr_free_dquots
r_int
id|nr_dquots
comma
id|nr_free_dquots
suffix:semicolon
DECL|variable|max_dquots
r_int
id|max_dquots
op_assign
id|NR_DQUOTS
suffix:semicolon
DECL|variable|quotamessage
r_static
r_char
id|quotamessage
(braket
id|MAX_QUOTA_MESSAGE
)braket
suffix:semicolon
DECL|variable|quotatypes
r_static
r_char
op_star
id|quotatypes
(braket
)braket
op_assign
id|INITQFNAMES
suffix:semicolon
DECL|function|sb_dqopt
r_static
r_inline
r_struct
id|quota_mount_options
op_star
id|sb_dqopt
c_func
(paren
r_struct
id|super_block
op_star
id|sb
)paren
(brace
r_return
op_amp
id|sb-&gt;s_dquot
suffix:semicolon
)brace
multiline_comment|/*&n; * Dquot List Management:&n; * The quota code uses three lists for dquot management: the inuse_list,&n; * free_dquots, and dquot_hash[] array. A single dquot structure may be&n; * on all three lists, depending on its current state.&n; *&n; * All dquots are placed on the inuse_list when first created, and this&n; * list is used for the sync and invalidate operations, which must look&n; * at every dquot.&n; *&n; * Unused dquots (dq_count == 0) are added to the free_dquots list when&n; * freed, and this list is searched whenever we need an available dquot.&n; * Dquots are removed from the list as soon as they are used again, and&n; * nr_free_dquots gives the number of dquots on the list.&n; *&n; * Dquots with a specific identity (device, type and id) are placed on&n; * one of the dquot_hash[] hash chains. The provides an efficient search&n; * mechanism to lcoate a specific dquot.&n; */
DECL|variable|inuse_list
r_static
r_struct
id|dquot
op_star
id|inuse_list
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|free_dquots
)paren
suffix:semicolon
DECL|variable|dquot_hash
r_static
r_struct
id|dquot
op_star
id|dquot_hash
(braket
id|NR_DQHASH
)braket
suffix:semicolon
DECL|variable|dquot_updating
r_static
r_int
id|dquot_updating
(braket
id|NR_DQHASH
)braket
suffix:semicolon
DECL|variable|dqstats
r_static
r_struct
id|dqstats
id|dqstats
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|dquot_wait
)paren
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|update_wait
)paren
suffix:semicolon
r_static
r_void
id|dqput
c_func
(paren
r_struct
id|dquot
op_star
)paren
suffix:semicolon
r_static
r_struct
id|dquot
op_star
id|dqduplicate
c_func
(paren
r_struct
id|dquot
op_star
)paren
suffix:semicolon
DECL|function|is_enabled
r_static
r_inline
r_char
id|is_enabled
c_func
(paren
r_struct
id|quota_mount_options
op_star
id|dqopt
comma
r_int
id|type
)paren
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|USRQUOTA
suffix:colon
r_return
(paren
id|dqopt-&gt;flags
op_amp
id|DQUOT_USR_ENABLED
)paren
op_ne
l_int|0
suffix:semicolon
r_case
id|GRPQUOTA
suffix:colon
r_return
(paren
id|dqopt-&gt;flags
op_amp
id|DQUOT_GRP_ENABLED
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sb_has_quota_enabled
r_static
r_inline
r_char
id|sb_has_quota_enabled
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
r_return
id|is_enabled
c_func
(paren
id|sb_dqopt
c_func
(paren
id|sb
)paren
comma
id|type
)paren
suffix:semicolon
)brace
DECL|function|hashfn
r_static
r_inline
r_int
r_const
id|hashfn
c_func
(paren
id|kdev_t
id|dev
comma
r_int
r_int
id|id
comma
r_int
id|type
)paren
(brace
r_return
(paren
(paren
id|HASHDEV
c_func
(paren
id|dev
)paren
op_xor
id|id
)paren
op_star
(paren
id|MAXQUOTAS
op_minus
id|type
)paren
)paren
op_mod
id|NR_DQHASH
suffix:semicolon
)brace
DECL|function|insert_dquot_hash
r_static
r_inline
r_void
id|insert_dquot_hash
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_struct
id|dquot
op_star
op_star
id|htable
suffix:semicolon
id|htable
op_assign
op_amp
id|dquot_hash
(braket
id|hashfn
c_func
(paren
id|dquot-&gt;dq_dev
comma
id|dquot-&gt;dq_id
comma
id|dquot-&gt;dq_type
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dquot-&gt;dq_hash_next
op_assign
op_star
id|htable
)paren
op_ne
l_int|NULL
)paren
(paren
op_star
id|htable
)paren
op_member_access_from_pointer
id|dq_hash_pprev
op_assign
op_amp
id|dquot-&gt;dq_hash_next
suffix:semicolon
op_star
id|htable
op_assign
id|dquot
suffix:semicolon
id|dquot-&gt;dq_hash_pprev
op_assign
id|htable
suffix:semicolon
)brace
DECL|function|hash_dquot
r_static
r_inline
r_void
id|hash_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|insert_dquot_hash
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
DECL|function|unhash_dquot
r_static
r_inline
r_void
id|unhash_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_if
c_cond
(paren
id|dquot-&gt;dq_hash_pprev
)paren
(brace
r_if
c_cond
(paren
id|dquot-&gt;dq_hash_next
)paren
id|dquot-&gt;dq_hash_next-&gt;dq_hash_pprev
op_assign
id|dquot-&gt;dq_hash_pprev
suffix:semicolon
op_star
(paren
id|dquot-&gt;dq_hash_pprev
)paren
op_assign
id|dquot-&gt;dq_hash_next
suffix:semicolon
id|dquot-&gt;dq_hash_pprev
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|find_dquot
r_static
r_inline
r_struct
id|dquot
op_star
id|find_dquot
c_func
(paren
r_int
r_int
id|hashent
comma
id|kdev_t
id|dev
comma
r_int
r_int
id|id
comma
r_int
id|type
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
r_for
c_loop
(paren
id|dquot
op_assign
id|dquot_hash
(braket
id|hashent
)braket
suffix:semicolon
id|dquot
suffix:semicolon
id|dquot
op_assign
id|dquot-&gt;dq_hash_next
)paren
r_if
c_cond
(paren
id|dquot-&gt;dq_dev
op_eq
id|dev
op_logical_and
id|dquot-&gt;dq_id
op_eq
id|id
op_logical_and
id|dquot-&gt;dq_type
op_eq
id|type
)paren
r_break
suffix:semicolon
r_return
id|dquot
suffix:semicolon
)brace
multiline_comment|/* Add a dquot to the head of the free list */
DECL|function|put_dquot_head
r_static
r_inline
r_void
id|put_dquot_head
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|dquot-&gt;dq_free
comma
op_amp
id|free_dquots
)paren
suffix:semicolon
id|nr_free_dquots
op_increment
suffix:semicolon
)brace
multiline_comment|/* Add a dquot to the tail of the free list */
DECL|function|put_dquot_last
r_static
r_inline
r_void
id|put_dquot_last
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|dquot-&gt;dq_free
comma
id|free_dquots.prev
)paren
suffix:semicolon
id|nr_free_dquots
op_increment
suffix:semicolon
)brace
DECL|function|remove_free_dquot
r_static
r_inline
r_void
id|remove_free_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
multiline_comment|/* sanity check */
r_if
c_cond
(paren
id|list_empty
c_func
(paren
op_amp
id|dquot-&gt;dq_free
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;remove_free_dquot: dquot not on the free list??&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* J.K. Just don&squot;t do anything */
)brace
id|list_del
c_func
(paren
op_amp
id|dquot-&gt;dq_free
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dquot-&gt;dq_free
)paren
suffix:semicolon
id|nr_free_dquots
op_decrement
suffix:semicolon
)brace
DECL|function|put_inuse
r_static
r_inline
r_void
id|put_inuse
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_if
c_cond
(paren
(paren
id|dquot-&gt;dq_next
op_assign
id|inuse_list
)paren
op_ne
l_int|NULL
)paren
id|inuse_list-&gt;dq_pprev
op_assign
op_amp
id|dquot-&gt;dq_next
suffix:semicolon
id|inuse_list
op_assign
id|dquot
suffix:semicolon
id|dquot-&gt;dq_pprev
op_assign
op_amp
id|inuse_list
suffix:semicolon
)brace
macro_line|#if 0&t;/* currently not needed */
r_static
r_inline
r_void
id|remove_inuse
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_if
c_cond
(paren
id|dquot-&gt;dq_pprev
)paren
(brace
r_if
c_cond
(paren
id|dquot-&gt;dq_next
)paren
id|dquot-&gt;dq_next-&gt;dq_pprev
op_assign
id|dquot-&gt;dq_pprev
suffix:semicolon
op_star
id|dquot-&gt;dq_pprev
op_assign
id|dquot-&gt;dq_next
suffix:semicolon
id|dquot-&gt;dq_pprev
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|function|__wait_on_dquot
r_static
r_void
id|__wait_on_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|dquot-&gt;dq_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|repeat
suffix:colon
id|set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_flags
op_amp
id|DQ_LOCKED
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|dquot-&gt;dq_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
DECL|function|wait_on_dquot
r_static
r_inline
r_void
id|wait_on_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_if
c_cond
(paren
id|dquot-&gt;dq_flags
op_amp
id|DQ_LOCKED
)paren
id|__wait_on_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
DECL|function|lock_dquot
r_static
r_inline
r_void
id|lock_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|wait_on_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|dquot-&gt;dq_flags
op_or_assign
id|DQ_LOCKED
suffix:semicolon
)brace
DECL|function|unlock_dquot
r_static
r_inline
r_void
id|unlock_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
id|dquot-&gt;dq_flags
op_and_assign
op_complement
id|DQ_LOCKED
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|dquot-&gt;dq_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;We don&squot;t have to be afraid of deadlocks as we never have quotas on quota files...&n; */
DECL|function|write_dquot
r_static
r_void
id|write_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_int
id|type
op_assign
id|dquot-&gt;dq_type
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
id|mm_segment_t
id|fs
suffix:semicolon
id|loff_t
id|offset
suffix:semicolon
id|ssize_t
id|ret
suffix:semicolon
r_struct
id|semaphore
op_star
id|sem
op_assign
op_amp
id|dquot-&gt;dq_sb-&gt;s_dquot.dqio_sem
suffix:semicolon
id|lock_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_sb
)paren
(brace
multiline_comment|/* Invalidated quota? */
id|unlock_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|down
c_func
(paren
id|sem
)paren
suffix:semicolon
id|filp
op_assign
id|dquot-&gt;dq_sb-&gt;s_dquot.files
(braket
id|type
)braket
suffix:semicolon
id|offset
op_assign
id|dqoff
c_func
(paren
id|dquot-&gt;dq_id
)paren
suffix:semicolon
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Note: clear the DQ_MOD flag unconditionally,&n;&t; * so we don&squot;t loop forever on failure.&n;&t; */
id|dquot-&gt;dq_flags
op_and_assign
op_complement
id|DQ_MOD
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|filp
)paren
id|ret
op_assign
id|filp-&gt;f_op
op_member_access_from_pointer
id|write
c_func
(paren
id|filp
comma
(paren
r_char
op_star
)paren
op_amp
id|dquot-&gt;dq_dqb
comma
r_sizeof
(paren
r_struct
id|dqblk
)paren
comma
op_amp
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
r_sizeof
(paren
r_struct
id|dqblk
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;VFS: dquota write failed on dev %s&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|dquot-&gt;dq_dev
)paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
id|up
c_func
(paren
id|sem
)paren
suffix:semicolon
id|unlock_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|dqstats.writes
op_increment
suffix:semicolon
)brace
DECL|function|read_dquot
r_static
r_void
id|read_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_int
id|type
op_assign
id|dquot-&gt;dq_type
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
id|mm_segment_t
id|fs
suffix:semicolon
id|loff_t
id|offset
suffix:semicolon
id|filp
op_assign
id|dquot-&gt;dq_sb-&gt;s_dquot.files
(braket
id|type
)braket
suffix:semicolon
r_if
c_cond
(paren
id|filp
op_eq
(paren
r_struct
id|file
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|lock_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_sb
)paren
multiline_comment|/* Invalidated quota? */
r_goto
id|out_lock
suffix:semicolon
multiline_comment|/* Now we are sure filp is valid - the dquot isn&squot;t invalidated */
id|down
c_func
(paren
op_amp
id|dquot-&gt;dq_sb-&gt;s_dquot.dqio_sem
)paren
suffix:semicolon
id|offset
op_assign
id|dqoff
c_func
(paren
id|dquot-&gt;dq_id
)paren
suffix:semicolon
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|filp-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|filp
comma
(paren
r_char
op_star
)paren
op_amp
id|dquot-&gt;dq_dqb
comma
r_sizeof
(paren
r_struct
id|dqblk
)paren
comma
op_amp
id|offset
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dquot-&gt;dq_sb-&gt;s_dquot.dqio_sem
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_bhardlimit
op_eq
l_int|0
op_logical_and
id|dquot-&gt;dq_bsoftlimit
op_eq
l_int|0
op_logical_and
id|dquot-&gt;dq_ihardlimit
op_eq
l_int|0
op_logical_and
id|dquot-&gt;dq_isoftlimit
op_eq
l_int|0
)paren
id|dquot-&gt;dq_flags
op_or_assign
id|DQ_FAKE
suffix:semicolon
id|dqstats.reads
op_increment
suffix:semicolon
id|out_lock
suffix:colon
id|unlock_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Unhash and selectively clear the dquot structure,&n; * but preserve the use count, list pointers, and&n; * wait queue.&n; */
DECL|function|clear_dquot
r_void
id|clear_dquot
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
multiline_comment|/* unhash it first */
id|unhash_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|dquot-&gt;dq_sb
op_assign
l_int|NULL
suffix:semicolon
id|dquot-&gt;dq_flags
op_assign
l_int|0
suffix:semicolon
id|dquot-&gt;dq_referenced
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|dquot-&gt;dq_dqb
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|dqblk
)paren
)paren
suffix:semicolon
)brace
DECL|function|invalidate_dquots
r_void
id|invalidate_dquots
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|type
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
comma
op_star
id|next
suffix:semicolon
r_int
id|need_restart
suffix:semicolon
id|restart
suffix:colon
id|next
op_assign
id|inuse_list
suffix:semicolon
multiline_comment|/* Here it is better. Otherwise the restart doesn&squot;t have any sense ;-) */
id|need_restart
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dquot
op_assign
id|next
)paren
op_ne
l_int|NULL
)paren
(brace
id|next
op_assign
id|dquot-&gt;dq_next
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_type
op_ne
id|type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_sb
)paren
multiline_comment|/* Already invalidated entry? */
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_flags
op_amp
id|DQ_LOCKED
)paren
(brace
id|__wait_on_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
multiline_comment|/* Set the flag for another pass. */
id|need_restart
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Make sure it&squot;s still the same dquot.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|dquot-&gt;dq_dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_type
op_ne
id|type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_sb
)paren
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Because inodes needn&squot;t to be the only holders of dquot&n;&t;&t; *  the quota needn&squot;t to be written to disk. So we write it&n;&t;&t; *  ourselves before discarding the data just for sure...&n;&t;&t; */
r_if
c_cond
(paren
id|dquot-&gt;dq_flags
op_amp
id|DQ_MOD
op_logical_and
id|dquot-&gt;dq_sb
)paren
(brace
id|write_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|need_restart
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* We slept on IO */
)brace
id|clear_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If anything blocked, restart the operation&n;&t; * to ensure we don&squot;t miss any dquots.&n;&t; */
r_if
c_cond
(paren
id|need_restart
)paren
r_goto
id|restart
suffix:semicolon
)brace
DECL|function|sync_dquots
r_int
id|sync_dquots
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|type
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
comma
op_star
id|next
comma
op_star
id|ddquot
suffix:semicolon
r_int
id|need_restart
suffix:semicolon
id|restart
suffix:colon
id|next
op_assign
id|inuse_list
suffix:semicolon
id|need_restart
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dquot
op_assign
id|next
)paren
op_ne
l_int|NULL
)paren
(brace
id|next
op_assign
id|dquot-&gt;dq_next
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_logical_and
id|dquot-&gt;dq_dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
op_minus
l_int|1
op_logical_and
id|dquot-&gt;dq_type
op_ne
id|type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_sb
)paren
multiline_comment|/* Invalidated? */
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dquot-&gt;dq_flags
op_amp
(paren
id|DQ_LOCKED
op_or
id|DQ_MOD
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ddquot
op_assign
id|dqduplicate
c_func
(paren
id|dquot
)paren
)paren
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|ddquot-&gt;dq_flags
op_amp
id|DQ_MOD
)paren
id|write_dquot
c_func
(paren
id|ddquot
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|ddquot
)paren
suffix:semicolon
multiline_comment|/* Set the flag for another pass. */
id|need_restart
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If anything blocked, restart the operation&n;&t; * to ensure we don&squot;t miss any dquots.&n;&t; */
r_if
c_cond
(paren
id|need_restart
)paren
r_goto
id|restart
suffix:semicolon
id|dqstats.syncs
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* NOTE: If you change this function please check whether dqput_blocks() works right... */
DECL|function|dqput
r_static
r_void
id|dqput
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dquot
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_count
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: dqput: trying to free free dquot&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;VFS: device %s, dquot of %s %d&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|dquot-&gt;dq_dev
)paren
comma
id|quotatypes
(braket
id|dquot-&gt;dq_type
)braket
comma
id|dquot-&gt;dq_id
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the dq_sb pointer isn&squot;t initialized this entry needs no&n;&t; * checking and doesn&squot;t need to be written. It&squot;s just an empty&n;&t; * dquot that is put back on to the freelist.&n;&t; */
r_if
c_cond
(paren
id|dquot-&gt;dq_sb
)paren
id|dqstats.drops
op_increment
suffix:semicolon
id|we_slept
suffix:colon
r_if
c_cond
(paren
id|dquot-&gt;dq_count
OG
l_int|1
)paren
(brace
multiline_comment|/* We have more than one user... We can simply decrement use count */
id|dquot-&gt;dq_count
op_decrement
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dquot-&gt;dq_flags
op_amp
id|DQ_LOCKED
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Locked quota to be put on the free list.&bslash;n&quot;
)paren
suffix:semicolon
id|dquot-&gt;dq_flags
op_and_assign
op_complement
id|DQ_LOCKED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dquot-&gt;dq_sb
op_logical_and
id|dquot-&gt;dq_flags
op_amp
id|DQ_MOD
)paren
(brace
id|write_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_goto
id|we_slept
suffix:semicolon
)brace
multiline_comment|/* sanity check */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|dquot-&gt;dq_free
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;dqput: dquot already on free list??&bslash;n&quot;
)paren
suffix:semicolon
id|dquot-&gt;dq_count
op_decrement
suffix:semicolon
multiline_comment|/* J.K. Just decrementing use count seems safer... */
r_return
suffix:semicolon
)brace
id|dquot-&gt;dq_count
op_decrement
suffix:semicolon
id|dquot-&gt;dq_flags
op_and_assign
op_complement
id|DQ_MOD
suffix:semicolon
multiline_comment|/* Modified flag has no sense on free list */
multiline_comment|/* Place at end of LRU free queue */
id|put_dquot_last
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|dquot_wait
)paren
suffix:semicolon
)brace
DECL|function|grow_dquots
r_static
r_int
id|grow_dquots
c_func
(paren
r_void
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
r_int
id|cnt
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|cnt
OL
l_int|32
)paren
(brace
id|dquot
op_assign
id|kmem_cache_alloc
c_func
(paren
id|dquot_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot
)paren
(brace
r_return
id|cnt
suffix:semicolon
)brace
id|nr_dquots
op_increment
suffix:semicolon
id|memset
c_func
(paren
(paren
id|caddr_t
)paren
id|dquot
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|dquot
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|dquot-&gt;dq_wait
)paren
suffix:semicolon
multiline_comment|/* all dquots go on the inuse_list */
id|put_inuse
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|put_dquot_head
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|cnt
op_increment
suffix:semicolon
)brace
r_return
id|cnt
suffix:semicolon
)brace
DECL|function|find_best_candidate_weighted
r_static
r_struct
id|dquot
op_star
id|find_best_candidate_weighted
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
op_assign
op_amp
id|free_dquots
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
comma
op_star
id|best
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|myscore
comma
id|bestscore
op_assign
op_complement
l_int|0U
suffix:semicolon
r_int
id|limit
op_assign
(paren
id|nr_free_dquots
OG
l_int|128
)paren
ques
c_cond
id|nr_free_dquots
op_rshift
l_int|2
suffix:colon
l_int|32
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|tmp-&gt;next
)paren
op_ne
op_amp
id|free_dquots
op_logical_and
op_decrement
id|limit
)paren
(brace
id|dquot
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|dquot
comma
id|dq_free
)paren
suffix:semicolon
multiline_comment|/* This should never happen... */
r_if
c_cond
(paren
id|dquot-&gt;dq_flags
op_amp
(paren
id|DQ_LOCKED
op_or
id|DQ_MOD
)paren
)paren
r_continue
suffix:semicolon
id|myscore
op_assign
id|dquot-&gt;dq_referenced
suffix:semicolon
r_if
c_cond
(paren
id|myscore
OL
id|bestscore
)paren
(brace
id|bestscore
op_assign
id|myscore
suffix:semicolon
id|best
op_assign
id|dquot
suffix:semicolon
)brace
)brace
r_return
id|best
suffix:semicolon
)brace
DECL|function|find_best_free
r_static
r_inline
r_struct
id|dquot
op_star
id|find_best_free
c_func
(paren
r_void
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
op_assign
op_amp
id|free_dquots
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
r_int
id|limit
op_assign
(paren
id|nr_free_dquots
OG
l_int|1024
)paren
ques
c_cond
id|nr_free_dquots
op_rshift
l_int|5
suffix:colon
l_int|32
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|tmp-&gt;next
)paren
op_ne
op_amp
id|free_dquots
op_logical_and
op_decrement
id|limit
)paren
(brace
id|dquot
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|dquot
comma
id|dq_free
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_referenced
op_eq
l_int|0
)paren
r_return
id|dquot
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|get_empty_dquot
r_struct
id|dquot
op_star
id|get_empty_dquot
c_func
(paren
r_void
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
r_int
id|shrink
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* Number of times we should try to shrink dcache and icache */
id|repeat
suffix:colon
id|dquot
op_assign
id|find_best_free
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot
)paren
r_goto
id|pressure
suffix:semicolon
id|got_it
suffix:colon
multiline_comment|/* Sanity checks */
r_if
c_cond
(paren
id|dquot-&gt;dq_flags
op_amp
id|DQ_LOCKED
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: Locked dquot on the free list&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_count
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;VFS: free dquot count=%d&bslash;n&quot;
comma
id|dquot-&gt;dq_count
)paren
suffix:semicolon
id|remove_free_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|dquot-&gt;dq_count
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* unhash and selectively clear the structure */
id|clear_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_return
id|dquot
suffix:semicolon
id|pressure
suffix:colon
r_if
c_cond
(paren
id|nr_dquots
OL
id|max_dquots
)paren
r_if
c_cond
(paren
id|grow_dquots
c_func
(paren
)paren
)paren
r_goto
id|repeat
suffix:semicolon
id|dquot
op_assign
id|find_best_candidate_weighted
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot
)paren
r_goto
id|got_it
suffix:semicolon
multiline_comment|/*&n;&t; * Try pruning the dcache to free up some dquots ...&n;&t; */
r_if
c_cond
(paren
id|shrink
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;get_empty_dquot: pruning dcache and icache&bslash;n&quot;
)paren
suffix:semicolon
id|prune_dcache
c_func
(paren
l_int|128
)paren
suffix:semicolon
id|prune_icache
c_func
(paren
l_int|128
)paren
suffix:semicolon
id|shrink
op_decrement
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;VFS: No free dquots, contact mvw@planets.elm.net&bslash;n&quot;
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|dquot_wait
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
DECL|function|dqget
r_static
r_struct
id|dquot
op_star
id|dqget
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
r_int
id|id
comma
r_int
id|type
)paren
(brace
r_int
r_int
id|hashent
op_assign
id|hashfn
c_func
(paren
id|sb-&gt;s_dev
comma
id|id
comma
id|type
)paren
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
comma
op_star
id|empty
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|quota_mount_options
op_star
id|dqopt
op_assign
id|sb_dqopt
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_enabled
c_func
(paren
id|dqopt
comma
id|type
)paren
)paren
r_return
id|NODQUOT
suffix:semicolon
id|we_slept
suffix:colon
r_if
c_cond
(paren
(paren
id|dquot
op_assign
id|find_dquot
c_func
(paren
id|hashent
comma
id|sb-&gt;s_dev
comma
id|id
comma
id|type
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|empty
op_eq
l_int|NULL
)paren
(brace
id|dquot_updating
(braket
id|hashent
)braket
op_increment
suffix:semicolon
id|empty
op_assign
id|get_empty_dquot
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|dquot_updating
(braket
id|hashent
)braket
)paren
id|wake_up
c_func
(paren
op_amp
id|update_wait
)paren
suffix:semicolon
r_goto
id|we_slept
suffix:semicolon
)brace
id|dquot
op_assign
id|empty
suffix:semicolon
id|dquot-&gt;dq_id
op_assign
id|id
suffix:semicolon
id|dquot-&gt;dq_type
op_assign
id|type
suffix:semicolon
id|dquot-&gt;dq_dev
op_assign
id|sb-&gt;s_dev
suffix:semicolon
id|dquot-&gt;dq_sb
op_assign
id|sb
suffix:semicolon
multiline_comment|/* hash it first so it can be found */
id|hash_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|read_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_count
op_increment
)paren
(brace
id|remove_free_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
r_else
id|dqstats.cache_hits
op_increment
suffix:semicolon
id|wait_on_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|empty
)paren
id|dqput
c_func
(paren
id|empty
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|dquot_updating
(braket
id|hashent
)braket
)paren
id|sleep_on
c_func
(paren
op_amp
id|update_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_sb
)paren
(brace
multiline_comment|/* Has somebody invalidated entry under us? */
multiline_comment|/*&n;&t;&t; *  Do it as if the quota was invalidated before we started&n;&t;&t; */
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_return
id|NODQUOT
suffix:semicolon
)brace
id|dquot-&gt;dq_referenced
op_increment
suffix:semicolon
id|dqstats.lookups
op_increment
suffix:semicolon
r_return
id|dquot
suffix:semicolon
)brace
DECL|function|dqduplicate
r_static
r_struct
id|dquot
op_star
id|dqduplicate
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_if
c_cond
(paren
id|dquot
op_eq
id|NODQUOT
op_logical_or
op_logical_neg
id|dquot-&gt;dq_sb
)paren
r_return
id|NODQUOT
suffix:semicolon
id|dquot-&gt;dq_count
op_increment
suffix:semicolon
id|wait_on_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dquot-&gt;dq_sb
)paren
(brace
id|dquot-&gt;dq_count
op_decrement
suffix:semicolon
r_return
id|NODQUOT
suffix:semicolon
)brace
id|dquot-&gt;dq_referenced
op_increment
suffix:semicolon
id|dqstats.lookups
op_increment
suffix:semicolon
r_return
id|dquot
suffix:semicolon
)brace
multiline_comment|/* Check whether this inode is quota file */
DECL|function|is_quotafile
r_static
r_inline
r_int
id|is_quotafile
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_struct
id|quota_mount_options
op_star
id|dqopt
op_assign
id|sb_dqopt
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_struct
id|file
op_star
op_star
id|files
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dqopt
)paren
r_return
l_int|0
suffix:semicolon
id|files
op_assign
id|dqopt-&gt;files
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
id|files
(braket
id|cnt
)braket
op_logical_and
id|files
(braket
id|cnt
)braket
op_member_access_from_pointer
id|f_dentry-&gt;d_inode
op_eq
id|inode
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dqinit_needed
r_static
r_int
id|dqinit_needed
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|type
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISLNK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_quotafile
c_func
(paren
id|inode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
op_minus
l_int|1
)paren
r_return
id|inode-&gt;i_dquot
(braket
id|type
)braket
op_eq
id|NODQUOT
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|add_dquot_ref
r_static
r_void
id|add_dquot_ref
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
r_struct
id|list_head
op_star
id|p
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb-&gt;dq_op
)paren
r_return
suffix:semicolon
multiline_comment|/* nothing to do */
id|restart
suffix:colon
id|file_list_lock
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|sb-&gt;s_files.next
suffix:semicolon
id|p
op_ne
op_amp
id|sb-&gt;s_files
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_struct
id|file
op_star
id|filp
op_assign
id|list_entry
c_func
(paren
id|p
comma
r_struct
id|file
comma
id|f_list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp-&gt;f_dentry
)paren
r_continue
suffix:semicolon
id|inode
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_WRITE
op_logical_and
id|dqinit_needed
c_func
(paren
id|inode
comma
id|type
)paren
)paren
(brace
id|file_list_unlock
c_func
(paren
)paren
suffix:semicolon
id|sb-&gt;dq_op
op_member_access_from_pointer
id|initialize
c_func
(paren
id|inode
comma
id|type
)paren
suffix:semicolon
id|inode-&gt;i_flags
op_or_assign
id|S_QUOTA
suffix:semicolon
multiline_comment|/* As we may have blocked we had better restart... */
r_goto
id|restart
suffix:semicolon
)brace
)brace
id|file_list_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Return 0 if dqput() won&squot;t block (note that 1 doesn&squot;t necessarily mean blocking) */
DECL|function|dqput_blocks
r_static
r_inline
r_int
id|dqput_blocks
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_if
c_cond
(paren
id|dquot-&gt;dq_count
op_eq
l_int|1
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Remove references to dquots from inode - add dquot to list for freeing if needed */
DECL|function|remove_inode_dquot_ref
r_int
id|remove_inode_dquot_ref
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|type
comma
r_struct
id|list_head
op_star
id|tofree_head
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
op_assign
id|inode-&gt;i_dquot
(braket
id|type
)braket
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|inode-&gt;i_dquot
(braket
id|type
)braket
op_assign
id|NODQUOT
suffix:semicolon
multiline_comment|/* any other quota in use? */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_ne
id|NODQUOT
)paren
r_goto
id|put_it
suffix:semicolon
)brace
id|inode-&gt;i_flags
op_and_assign
op_complement
id|S_QUOTA
suffix:semicolon
id|put_it
suffix:colon
r_if
c_cond
(paren
id|dquot
op_ne
id|NODQUOT
)paren
(brace
r_if
c_cond
(paren
id|dqput_blocks
c_func
(paren
id|dquot
)paren
)paren
(brace
r_if
c_cond
(paren
id|dquot-&gt;dq_count
op_ne
l_int|1
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;VFS: Adding dquot with dq_count %d to dispose list.&bslash;n&quot;
comma
id|dquot-&gt;dq_count
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dquot-&gt;dq_free
comma
id|tofree_head
)paren
suffix:semicolon
multiline_comment|/* As dquot must have currently users it can&squot;t be on the free list... */
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
multiline_comment|/* We have guaranteed we won&squot;t block */
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Free list of dquots - called from inode.c */
DECL|function|put_dquot_list
r_void
id|put_dquot_list
c_func
(paren
r_struct
id|list_head
op_star
id|tofree_head
)paren
(brace
r_struct
id|list_head
op_star
id|act_head
op_assign
id|tofree_head-&gt;next
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
multiline_comment|/* So now we have dquots on the list... Just free them */
r_while
c_loop
(paren
id|act_head
op_ne
id|tofree_head
)paren
(brace
id|dquot
op_assign
id|list_entry
c_func
(paren
id|act_head
comma
r_struct
id|dquot
comma
id|dq_free
)paren
suffix:semicolon
id|act_head
op_assign
id|act_head-&gt;next
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|dquot-&gt;dq_free
)paren
suffix:semicolon
multiline_comment|/* Remove dquot from the list so we won&squot;t have problems... */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|dquot-&gt;dq_free
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
)brace
DECL|function|dquot_incr_inodes
r_static
r_inline
r_void
id|dquot_incr_inodes
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
r_int
r_int
id|number
)paren
(brace
id|dquot-&gt;dq_curinodes
op_add_assign
id|number
suffix:semicolon
id|dquot-&gt;dq_flags
op_or_assign
id|DQ_MOD
suffix:semicolon
)brace
DECL|function|dquot_incr_blocks
r_static
r_inline
r_void
id|dquot_incr_blocks
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
r_int
r_int
id|number
)paren
(brace
id|dquot-&gt;dq_curblocks
op_add_assign
id|number
suffix:semicolon
id|dquot-&gt;dq_flags
op_or_assign
id|DQ_MOD
suffix:semicolon
)brace
DECL|function|dquot_decr_inodes
r_static
r_inline
r_void
id|dquot_decr_inodes
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
r_int
r_int
id|number
)paren
(brace
r_if
c_cond
(paren
id|dquot-&gt;dq_curinodes
OG
id|number
)paren
id|dquot-&gt;dq_curinodes
op_sub_assign
id|number
suffix:semicolon
r_else
id|dquot-&gt;dq_curinodes
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_curinodes
OL
id|dquot-&gt;dq_isoftlimit
)paren
id|dquot-&gt;dq_itime
op_assign
(paren
id|time_t
)paren
l_int|0
suffix:semicolon
id|dquot-&gt;dq_flags
op_and_assign
op_complement
id|DQ_INODES
suffix:semicolon
id|dquot-&gt;dq_flags
op_or_assign
id|DQ_MOD
suffix:semicolon
)brace
DECL|function|dquot_decr_blocks
r_static
r_inline
r_void
id|dquot_decr_blocks
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
r_int
r_int
id|number
)paren
(brace
r_if
c_cond
(paren
id|dquot-&gt;dq_curblocks
OG
id|number
)paren
id|dquot-&gt;dq_curblocks
op_sub_assign
id|number
suffix:semicolon
r_else
id|dquot-&gt;dq_curblocks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_curblocks
OL
id|dquot-&gt;dq_bsoftlimit
)paren
id|dquot-&gt;dq_btime
op_assign
(paren
id|time_t
)paren
l_int|0
suffix:semicolon
id|dquot-&gt;dq_flags
op_and_assign
op_complement
id|DQ_BLKS
suffix:semicolon
id|dquot-&gt;dq_flags
op_or_assign
id|DQ_MOD
suffix:semicolon
)brace
DECL|function|need_print_warning
r_static
r_inline
r_int
id|need_print_warning
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
r_int
id|flag
)paren
(brace
r_switch
c_cond
(paren
id|dquot-&gt;dq_type
)paren
(brace
r_case
id|USRQUOTA
suffix:colon
r_return
id|current-&gt;fsuid
op_eq
id|dquot-&gt;dq_id
op_logical_and
op_logical_neg
(paren
id|dquot-&gt;dq_flags
op_amp
id|flag
)paren
suffix:semicolon
r_case
id|GRPQUOTA
suffix:colon
r_return
id|in_group_p
c_func
(paren
id|dquot-&gt;dq_id
)paren
op_logical_and
op_logical_neg
(paren
id|dquot-&gt;dq_flags
op_amp
id|flag
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|print_warning
r_static
r_void
id|print_warning
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
r_int
id|flag
comma
r_const
r_char
op_star
id|fmtstr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|need_print_warning
c_func
(paren
id|dquot
comma
id|flag
)paren
)paren
r_return
suffix:semicolon
id|sprintf
c_func
(paren
id|quotamessage
comma
id|fmtstr
comma
id|bdevname
c_func
(paren
id|dquot-&gt;dq_sb-&gt;s_dev
)paren
comma
id|quotatypes
(braket
id|dquot-&gt;dq_type
)braket
)paren
suffix:semicolon
id|tty_write_message
c_func
(paren
id|current-&gt;tty
comma
id|quotamessage
)paren
suffix:semicolon
id|dquot-&gt;dq_flags
op_or_assign
id|flag
suffix:semicolon
)brace
DECL|function|ignore_hardlimit
r_static
r_inline
r_char
id|ignore_hardlimit
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
)paren
(brace
r_return
id|capable
c_func
(paren
id|CAP_SYS_RESOURCE
)paren
op_logical_and
op_logical_neg
id|dquot-&gt;dq_sb-&gt;s_dquot.rsquash
(braket
id|dquot-&gt;dq_type
)braket
suffix:semicolon
)brace
DECL|function|check_idq
r_static
r_int
id|check_idq
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
id|u_long
id|inodes
)paren
(brace
r_if
c_cond
(paren
id|inodes
op_le
l_int|0
op_logical_or
id|dquot-&gt;dq_flags
op_amp
id|DQ_FAKE
)paren
r_return
id|QUOTA_OK
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_ihardlimit
op_logical_and
(paren
id|dquot-&gt;dq_curinodes
op_plus
id|inodes
)paren
OG
id|dquot-&gt;dq_ihardlimit
op_logical_and
op_logical_neg
id|ignore_hardlimit
c_func
(paren
id|dquot
)paren
)paren
(brace
id|print_warning
c_func
(paren
id|dquot
comma
id|DQ_INODES
comma
l_string|&quot;%s: write failed, %s file limit reached&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|NO_QUOTA
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dquot-&gt;dq_isoftlimit
op_logical_and
(paren
id|dquot-&gt;dq_curinodes
op_plus
id|inodes
)paren
OG
id|dquot-&gt;dq_isoftlimit
op_logical_and
id|dquot-&gt;dq_itime
op_logical_and
id|CURRENT_TIME
op_ge
id|dquot-&gt;dq_itime
op_logical_and
op_logical_neg
id|ignore_hardlimit
c_func
(paren
id|dquot
)paren
)paren
(brace
id|print_warning
c_func
(paren
id|dquot
comma
id|DQ_INODES
comma
l_string|&quot;%s: warning, %s file quota exceeded too long.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|NO_QUOTA
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dquot-&gt;dq_isoftlimit
op_logical_and
(paren
id|dquot-&gt;dq_curinodes
op_plus
id|inodes
)paren
OG
id|dquot-&gt;dq_isoftlimit
op_logical_and
id|dquot-&gt;dq_itime
op_eq
l_int|0
)paren
(brace
id|print_warning
c_func
(paren
id|dquot
comma
l_int|0
comma
l_string|&quot;%s: warning, %s file quota exceeded&bslash;n&quot;
)paren
suffix:semicolon
id|dquot-&gt;dq_itime
op_assign
id|CURRENT_TIME
op_plus
id|dquot-&gt;dq_sb-&gt;s_dquot.inode_expire
(braket
id|dquot-&gt;dq_type
)braket
suffix:semicolon
)brace
r_return
id|QUOTA_OK
suffix:semicolon
)brace
DECL|function|check_bdq
r_static
r_int
id|check_bdq
c_func
(paren
r_struct
id|dquot
op_star
id|dquot
comma
id|u_long
id|blocks
comma
r_char
id|prealloc
)paren
(brace
r_if
c_cond
(paren
id|blocks
op_le
l_int|0
op_logical_or
id|dquot-&gt;dq_flags
op_amp
id|DQ_FAKE
)paren
r_return
id|QUOTA_OK
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_bhardlimit
op_logical_and
(paren
id|dquot-&gt;dq_curblocks
op_plus
id|blocks
)paren
OG
id|dquot-&gt;dq_bhardlimit
op_logical_and
op_logical_neg
id|ignore_hardlimit
c_func
(paren
id|dquot
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prealloc
)paren
id|print_warning
c_func
(paren
id|dquot
comma
id|DQ_BLKS
comma
l_string|&quot;%s: write failed, %s disk limit reached.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|NO_QUOTA
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dquot-&gt;dq_bsoftlimit
op_logical_and
(paren
id|dquot-&gt;dq_curblocks
op_plus
id|blocks
)paren
OG
id|dquot-&gt;dq_bsoftlimit
op_logical_and
id|dquot-&gt;dq_btime
op_logical_and
id|CURRENT_TIME
op_ge
id|dquot-&gt;dq_btime
op_logical_and
op_logical_neg
id|ignore_hardlimit
c_func
(paren
id|dquot
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prealloc
)paren
id|print_warning
c_func
(paren
id|dquot
comma
id|DQ_BLKS
comma
l_string|&quot;%s: write failed, %s disk quota exceeded too long.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|NO_QUOTA
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dquot-&gt;dq_bsoftlimit
op_logical_and
(paren
id|dquot-&gt;dq_curblocks
op_plus
id|blocks
)paren
OG
id|dquot-&gt;dq_bsoftlimit
op_logical_and
id|dquot-&gt;dq_btime
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|prealloc
)paren
(brace
id|print_warning
c_func
(paren
id|dquot
comma
l_int|0
comma
l_string|&quot;%s: warning, %s disk quota exceeded&bslash;n&quot;
)paren
suffix:semicolon
id|dquot-&gt;dq_btime
op_assign
id|CURRENT_TIME
op_plus
id|dquot-&gt;dq_sb-&gt;s_dquot.block_expire
(braket
id|dquot-&gt;dq_type
)braket
suffix:semicolon
)brace
r_else
multiline_comment|/*&n;&t;&t;&t; * We don&squot;t allow preallocation to exceed softlimit so exceeding will&n;&t;&t;&t; * be always printed&n;&t;&t;&t; */
r_return
id|NO_QUOTA
suffix:semicolon
)brace
r_return
id|QUOTA_OK
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize a dquot-struct with new quota info. This is used by the&n; * system call interface functions.&n; */
DECL|function|set_dqblk
r_static
r_int
id|set_dqblk
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|id
comma
r_int
id|type
comma
r_int
id|flags
comma
r_struct
id|dqblk
op_star
id|dqblk
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_struct
id|dqblk
id|dq_dqblk
suffix:semicolon
r_if
c_cond
(paren
id|dqblk
op_eq
(paren
r_struct
id|dqblk
op_star
)paren
l_int|NULL
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|QUOTA_SYSCALL
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|dq_dqblk
comma
id|dqblk
comma
r_sizeof
(paren
r_struct
id|dqblk
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
)brace
r_else
id|memcpy
c_func
(paren
(paren
id|caddr_t
)paren
op_amp
id|dq_dqblk
comma
(paren
id|caddr_t
)paren
id|dqblk
comma
r_sizeof
(paren
r_struct
id|dqblk
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb
op_logical_and
(paren
id|dquot
op_assign
id|dqget
c_func
(paren
id|sb
comma
id|id
comma
id|type
)paren
)paren
op_ne
id|NODQUOT
)paren
(brace
id|lock_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
OG
l_int|0
op_logical_and
(paren
(paren
id|flags
op_amp
id|SET_QUOTA
)paren
op_logical_or
(paren
id|flags
op_amp
id|SET_QLIMIT
)paren
)paren
)paren
(brace
id|dquot-&gt;dq_bhardlimit
op_assign
id|dq_dqblk.dqb_bhardlimit
suffix:semicolon
id|dquot-&gt;dq_bsoftlimit
op_assign
id|dq_dqblk.dqb_bsoftlimit
suffix:semicolon
id|dquot-&gt;dq_ihardlimit
op_assign
id|dq_dqblk.dqb_ihardlimit
suffix:semicolon
id|dquot-&gt;dq_isoftlimit
op_assign
id|dq_dqblk.dqb_isoftlimit
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|SET_QUOTA
)paren
op_logical_or
(paren
id|flags
op_amp
id|SET_USE
)paren
)paren
(brace
r_if
c_cond
(paren
id|dquot-&gt;dq_isoftlimit
op_logical_and
id|dquot-&gt;dq_curinodes
OL
id|dquot-&gt;dq_isoftlimit
op_logical_and
id|dq_dqblk.dqb_curinodes
op_ge
id|dquot-&gt;dq_isoftlimit
)paren
id|dquot-&gt;dq_itime
op_assign
id|CURRENT_TIME
op_plus
id|dquot-&gt;dq_sb-&gt;s_dquot.inode_expire
(braket
id|type
)braket
suffix:semicolon
id|dquot-&gt;dq_curinodes
op_assign
id|dq_dqblk.dqb_curinodes
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_curinodes
OL
id|dquot-&gt;dq_isoftlimit
)paren
id|dquot-&gt;dq_flags
op_and_assign
op_complement
id|DQ_INODES
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_bsoftlimit
op_logical_and
id|dquot-&gt;dq_curblocks
OL
id|dquot-&gt;dq_bsoftlimit
op_logical_and
id|dq_dqblk.dqb_curblocks
op_ge
id|dquot-&gt;dq_bsoftlimit
)paren
id|dquot-&gt;dq_btime
op_assign
id|CURRENT_TIME
op_plus
id|dquot-&gt;dq_sb-&gt;s_dquot.block_expire
(braket
id|type
)braket
suffix:semicolon
id|dquot-&gt;dq_curblocks
op_assign
id|dq_dqblk.dqb_curblocks
suffix:semicolon
r_if
c_cond
(paren
id|dquot-&gt;dq_curblocks
OL
id|dquot-&gt;dq_bsoftlimit
)paren
id|dquot-&gt;dq_flags
op_and_assign
op_complement
id|DQ_BLKS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|id
op_eq
l_int|0
)paren
(brace
id|dquot-&gt;dq_sb-&gt;s_dquot.block_expire
(braket
id|type
)braket
op_assign
id|dquot-&gt;dq_btime
op_assign
id|dq_dqblk.dqb_btime
suffix:semicolon
id|dquot-&gt;dq_sb-&gt;s_dquot.inode_expire
(braket
id|type
)braket
op_assign
id|dquot-&gt;dq_itime
op_assign
id|dq_dqblk.dqb_itime
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dq_dqblk.dqb_bhardlimit
op_eq
l_int|0
op_logical_and
id|dq_dqblk.dqb_bsoftlimit
op_eq
l_int|0
op_logical_and
id|dq_dqblk.dqb_ihardlimit
op_eq
l_int|0
op_logical_and
id|dq_dqblk.dqb_isoftlimit
op_eq
l_int|0
)paren
id|dquot-&gt;dq_flags
op_or_assign
id|DQ_FAKE
suffix:semicolon
r_else
id|dquot-&gt;dq_flags
op_and_assign
op_complement
id|DQ_FAKE
suffix:semicolon
id|dquot-&gt;dq_flags
op_or_assign
id|DQ_MOD
suffix:semicolon
id|unlock_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|get_quota
r_static
r_int
id|get_quota
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|id
comma
r_int
id|type
comma
r_struct
id|dqblk
op_star
id|dqblk
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb
op_logical_or
op_logical_neg
id|sb_has_quota_enabled
c_func
(paren
id|sb
comma
id|type
)paren
)paren
r_goto
id|out
suffix:semicolon
id|dquot
op_assign
id|dqget
c_func
(paren
id|sb
comma
id|id
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot
op_eq
id|NODQUOT
)paren
r_goto
id|out
suffix:semicolon
id|lock_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
multiline_comment|/* We must protect against invalidating the quota */
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|dqblk
op_logical_and
op_logical_neg
id|copy_to_user
c_func
(paren
id|dqblk
comma
op_amp
id|dquot-&gt;dq_dqb
comma
r_sizeof
(paren
r_struct
id|dqblk
)paren
)paren
)paren
id|error
op_assign
l_int|0
suffix:semicolon
id|unlock_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
DECL|function|get_stats
r_static
r_int
id|get_stats
c_func
(paren
id|caddr_t
id|addr
)paren
(brace
r_int
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_struct
id|dqstats
id|stats
suffix:semicolon
id|dqstats.allocated_dquots
op_assign
id|nr_dquots
suffix:semicolon
id|dqstats.free_dquots
op_assign
id|nr_free_dquots
suffix:semicolon
multiline_comment|/* make a copy, in case we page-fault in user space */
id|memcpy
c_func
(paren
op_amp
id|stats
comma
op_amp
id|dqstats
comma
r_sizeof
(paren
r_struct
id|dqstats
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_to_user
c_func
(paren
id|addr
comma
op_amp
id|stats
comma
r_sizeof
(paren
r_struct
id|dqstats
)paren
)paren
)paren
id|error
op_assign
l_int|0
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|quota_root_squash
r_static
r_int
id|quota_root_squash
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
comma
r_int
op_star
id|addr
)paren
(brace
r_int
id|new_value
comma
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_from_user
c_func
(paren
op_amp
id|new_value
comma
id|addr
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
(brace
id|sb_dqopt
c_func
(paren
id|sb
)paren
op_member_access_from_pointer
id|rsquash
(braket
id|type
)braket
op_assign
id|new_value
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a simple algorithm that calculates the size of a file in blocks.&n; * This is only used on filesystems that do not have an i_blocks count.&n; */
DECL|function|isize_to_blocks
r_static
id|u_long
id|isize_to_blocks
c_func
(paren
id|loff_t
id|isize
comma
r_int
id|blksize_bits
)paren
(brace
id|u_long
id|blocks
suffix:semicolon
id|u_long
id|indirect
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blksize_bits
)paren
id|blksize_bits
op_assign
id|BLOCK_SIZE_BITS
suffix:semicolon
id|blocks
op_assign
(paren
id|isize
op_rshift
id|blksize_bits
)paren
op_plus
(paren
(paren
id|isize
op_amp
op_complement
(paren
(paren
l_int|1
op_lshift
id|blksize_bits
)paren
op_minus
l_int|1
)paren
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blocks
OG
l_int|10
)paren
(brace
id|indirect
op_assign
(paren
(paren
id|blocks
op_minus
l_int|11
)paren
op_rshift
l_int|8
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* single indirect blocks */
r_if
c_cond
(paren
id|blocks
OG
(paren
l_int|10
op_plus
l_int|256
)paren
)paren
(brace
id|indirect
op_add_assign
(paren
(paren
id|blocks
op_minus
l_int|267
)paren
op_rshift
l_int|16
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* double indirect blocks */
r_if
c_cond
(paren
id|blocks
OG
(paren
l_int|10
op_plus
l_int|256
op_plus
(paren
l_int|256
op_lshift
l_int|8
)paren
)paren
)paren
id|indirect
op_increment
suffix:semicolon
multiline_comment|/* triple indirect blocks */
)brace
id|blocks
op_add_assign
id|indirect
suffix:semicolon
)brace
r_return
id|blocks
suffix:semicolon
)brace
multiline_comment|/*&n; * Externally referenced functions through dquot_operations in inode.&n; *&n; * Note: this is a blocking operation.&n; */
DECL|function|dquot_initialize
r_void
id|dquot_initialize
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|type
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
r_int
r_int
id|id
op_assign
l_int|0
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
op_logical_neg
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
op_logical_neg
id|S_ISLNK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_return
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t want to have quotas on quota files - nasty deadlocks possible */
r_if
c_cond
(paren
id|is_quotafile
c_func
(paren
id|inode
)paren
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|type
op_ne
op_minus
l_int|1
op_logical_and
id|cnt
op_ne
id|type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb_has_quota_enabled
c_func
(paren
id|inode-&gt;i_sb
comma
id|cnt
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
(brace
r_switch
c_cond
(paren
id|cnt
)paren
(brace
r_case
id|USRQUOTA
suffix:colon
id|id
op_assign
id|inode-&gt;i_uid
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GRPQUOTA
suffix:colon
id|id
op_assign
id|inode-&gt;i_gid
suffix:semicolon
r_break
suffix:semicolon
)brace
id|dquot
op_assign
id|dqget
c_func
(paren
id|inode-&gt;i_sb
comma
id|id
comma
id|cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_ne
id|NODQUOT
)paren
(brace
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_assign
id|dquot
suffix:semicolon
id|inode-&gt;i_flags
op_or_assign
id|S_QUOTA
suffix:semicolon
)brace
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Release all quota for the specified inode.&n; *&n; * Note: this is a blocking operation.&n; */
DECL|function|dquot_drop
r_void
id|dquot_drop
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
r_int
id|cnt
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|inode-&gt;i_flags
op_and_assign
op_complement
id|S_QUOTA
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|dquot
op_assign
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
suffix:semicolon
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_assign
id|NODQUOT
suffix:semicolon
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: this is a blocking operation.&n; */
DECL|function|dquot_alloc_block
r_int
id|dquot_alloc_block
c_func
(paren
r_const
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|number
comma
r_char
id|warn
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
(braket
id|MAXQUOTAS
)braket
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|dquot
(braket
id|cnt
)braket
op_assign
id|dqduplicate
c_func
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|lock_dquot
c_func
(paren
id|dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_bdq
c_func
(paren
id|dquot
(braket
id|cnt
)braket
comma
id|number
comma
id|warn
)paren
)paren
r_goto
id|put_all
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|dquot_incr_blocks
c_func
(paren
id|dquot
(braket
id|cnt
)braket
comma
id|number
)paren
suffix:semicolon
id|unlock_dquot
c_func
(paren
id|dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
)brace
r_return
id|QUOTA_OK
suffix:semicolon
id|put_all
suffix:colon
r_for
c_loop
(paren
suffix:semicolon
id|cnt
op_ge
l_int|0
suffix:semicolon
id|cnt
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|unlock_dquot
c_func
(paren
id|dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
)brace
r_return
id|NO_QUOTA
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: this is a blocking operation.&n; */
DECL|function|dquot_alloc_inode
r_int
id|dquot_alloc_inode
c_func
(paren
r_const
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|number
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
(braket
id|MAXQUOTAS
)braket
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|dquot
(braket
id|cnt
)braket
op_assign
id|dqduplicate
c_func
(paren
id|inode
op_member_access_from_pointer
id|i_dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|lock_dquot
c_func
(paren
id|dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_idq
c_func
(paren
id|dquot
(braket
id|cnt
)braket
comma
id|number
)paren
)paren
r_goto
id|put_all
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|dquot_incr_inodes
c_func
(paren
id|dquot
(braket
id|cnt
)braket
comma
id|number
)paren
suffix:semicolon
id|unlock_dquot
c_func
(paren
id|dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
)brace
r_return
id|QUOTA_OK
suffix:semicolon
id|put_all
suffix:colon
r_for
c_loop
(paren
suffix:semicolon
id|cnt
op_ge
l_int|0
suffix:semicolon
id|cnt
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|dquot
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|unlock_dquot
c_func
(paren
id|dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|dquot
(braket
id|cnt
)braket
)paren
suffix:semicolon
)brace
r_return
id|NO_QUOTA
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: this is a blocking operation.&n; */
DECL|function|dquot_free_block
r_void
id|dquot_free_block
c_func
(paren
r_const
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|number
)paren
(brace
r_int
r_int
id|cnt
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|dquot
op_assign
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dquot
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|wait_on_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|dquot_decr_blocks
c_func
(paren
id|dquot
comma
id|number
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Note: this is a blocking operation.&n; */
DECL|function|dquot_free_inode
r_void
id|dquot_free_inode
c_func
(paren
r_const
r_struct
id|inode
op_star
id|inode
comma
r_int
r_int
id|number
)paren
(brace
r_int
r_int
id|cnt
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|dquot
op_assign
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dquot
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|wait_on_dquot
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|dquot_decr_inodes
c_func
(paren
id|dquot
comma
id|number
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Transfer the number of inode and blocks from one diskquota to an other.&n; *&n; * Note: this is a blocking operation.&n; */
DECL|function|dquot_transfer
r_int
id|dquot_transfer
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|iattr
op_star
id|iattr
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry
op_member_access_from_pointer
id|d_inode
suffix:semicolon
r_int
r_int
id|blocks
suffix:semicolon
r_struct
id|dquot
op_star
id|transfer_from
(braket
id|MAXQUOTAS
)braket
suffix:semicolon
r_struct
id|dquot
op_star
id|transfer_to
(braket
id|MAXQUOTAS
)braket
suffix:semicolon
r_int
id|cnt
comma
id|disc
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|EDQUOT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
multiline_comment|/* Arguably we could consider that as error, but... no fs - no quota */
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_sb
)paren
r_return
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Build the transfer_from and transfer_to lists and check quotas to see&n;&t; * if operation is permitted.&n;&t; */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|transfer_from
(braket
id|cnt
)braket
op_assign
id|NODQUOT
suffix:semicolon
id|transfer_to
(braket
id|cnt
)braket
op_assign
id|NODQUOT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb_has_quota_enabled
c_func
(paren
id|inode-&gt;i_sb
comma
id|cnt
)paren
)paren
r_continue
suffix:semicolon
r_switch
c_cond
(paren
id|cnt
)paren
(brace
r_case
id|USRQUOTA
suffix:colon
r_if
c_cond
(paren
id|inode-&gt;i_uid
op_eq
id|iattr-&gt;ia_uid
)paren
r_continue
suffix:semicolon
multiline_comment|/* We can get transfer_from from inode, can&squot;t we? */
id|transfer_from
(braket
id|cnt
)braket
op_assign
id|dqget
c_func
(paren
id|inode-&gt;i_sb
comma
id|inode-&gt;i_uid
comma
id|cnt
)paren
suffix:semicolon
id|transfer_to
(braket
id|cnt
)braket
op_assign
id|dqget
c_func
(paren
id|inode-&gt;i_sb
comma
id|iattr-&gt;ia_uid
comma
id|cnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GRPQUOTA
suffix:colon
r_if
c_cond
(paren
id|inode-&gt;i_gid
op_eq
id|iattr-&gt;ia_gid
)paren
r_continue
suffix:semicolon
id|transfer_from
(braket
id|cnt
)braket
op_assign
id|dqget
c_func
(paren
id|inode-&gt;i_sb
comma
id|inode-&gt;i_gid
comma
id|cnt
)paren
suffix:semicolon
id|transfer_to
(braket
id|cnt
)braket
op_assign
id|dqget
c_func
(paren
id|inode-&gt;i_sb
comma
id|iattr-&gt;ia_gid
comma
id|cnt
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Something bad (eg. quotaoff) happened while we were sleeping? */
r_if
c_cond
(paren
id|transfer_from
(braket
id|cnt
)braket
op_eq
id|NODQUOT
op_logical_or
id|transfer_to
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
(brace
r_if
c_cond
(paren
id|transfer_from
(braket
id|cnt
)braket
op_ne
id|NODQUOT
)paren
(brace
id|dqput
c_func
(paren
id|transfer_from
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|transfer_from
(braket
id|cnt
)braket
op_assign
id|NODQUOT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|transfer_to
(braket
id|cnt
)braket
op_ne
id|NODQUOT
)paren
(brace
id|dqput
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|transfer_to
(braket
id|cnt
)braket
op_assign
id|NODQUOT
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  We have to lock the quotas to prevent races...&n;&t;&t; */
r_if
c_cond
(paren
id|transfer_from
(braket
id|cnt
)braket
OL
id|transfer_to
(braket
id|cnt
)braket
)paren
(brace
id|lock_dquot
c_func
(paren
id|transfer_from
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|lock_dquot
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|lock_dquot
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|lock_dquot
c_func
(paren
id|transfer_from
(braket
id|cnt
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The entries might got invalidated while locking. The second&n;&t;&t; * dqget() could block and so the first structure might got&n;&t;&t; * invalidated or locked...&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|transfer_to
(braket
id|cnt
)braket
op_member_access_from_pointer
id|dq_sb
op_logical_or
op_logical_neg
id|transfer_from
(braket
id|cnt
)braket
op_member_access_from_pointer
id|dq_sb
)paren
(brace
id|cnt
op_increment
suffix:semicolon
r_goto
id|put_all
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Find out if this filesystem uses i_blocks.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
id|blocks
op_assign
id|isize_to_blocks
c_func
(paren
id|inode-&gt;i_size
comma
id|BLOCK_SIZE_BITS
)paren
suffix:semicolon
r_else
id|blocks
op_assign
(paren
id|inode-&gt;i_blocks
op_rshift
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|transfer_to
(braket
id|cnt
)braket
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|check_idq
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
comma
l_int|1
)paren
op_eq
id|NO_QUOTA
op_logical_or
id|check_bdq
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
comma
id|blocks
comma
l_int|0
)paren
op_eq
id|NO_QUOTA
)paren
(brace
id|cnt
op_assign
id|MAXQUOTAS
suffix:semicolon
r_goto
id|put_all
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|notify_change
c_func
(paren
id|dentry
comma
id|iattr
)paren
)paren
)paren
r_goto
id|put_all
suffix:semicolon
multiline_comment|/*&n;&t; * Finally perform the needed transfer from transfer_from to transfer_to,&n;&t; * and release any pointers to dquots not needed anymore.&n;&t; */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Skip changes for same uid or gid or for non-existing quota-type.&n;&t;&t; */
r_if
c_cond
(paren
id|transfer_from
(braket
id|cnt
)braket
op_eq
id|NODQUOT
op_logical_and
id|transfer_to
(braket
id|cnt
)braket
op_eq
id|NODQUOT
)paren
r_continue
suffix:semicolon
id|dquot_decr_inodes
c_func
(paren
id|transfer_from
(braket
id|cnt
)braket
comma
l_int|1
)paren
suffix:semicolon
id|dquot_decr_blocks
c_func
(paren
id|transfer_from
(braket
id|cnt
)braket
comma
id|blocks
)paren
suffix:semicolon
id|dquot_incr_inodes
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
comma
l_int|1
)paren
suffix:semicolon
id|dquot_incr_blocks
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
comma
id|blocks
)paren
suffix:semicolon
id|unlock_dquot
c_func
(paren
id|transfer_from
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|transfer_from
(braket
id|cnt
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_ne
id|NODQUOT
)paren
(brace
r_struct
id|dquot
op_star
id|temp
op_assign
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
suffix:semicolon
id|inode-&gt;i_dquot
(braket
id|cnt
)braket
op_assign
id|transfer_to
(braket
id|cnt
)braket
suffix:semicolon
id|unlock_dquot
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|temp
)paren
suffix:semicolon
)brace
r_else
(brace
id|unlock_dquot
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|transfer_to
(braket
id|cnt
)braket
)paren
suffix:semicolon
)brace
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|put_all
suffix:colon
r_for
c_loop
(paren
id|disc
op_assign
l_int|0
suffix:semicolon
id|disc
OL
id|cnt
suffix:semicolon
id|disc
op_increment
)paren
(brace
multiline_comment|/* There should be none or both pointers set but... */
r_if
c_cond
(paren
id|transfer_to
(braket
id|disc
)braket
op_ne
id|NODQUOT
)paren
(brace
id|unlock_dquot
c_func
(paren
id|transfer_to
(braket
id|disc
)braket
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|transfer_to
(braket
id|disc
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|transfer_from
(braket
id|disc
)braket
op_ne
id|NODQUOT
)paren
(brace
id|unlock_dquot
c_func
(paren
id|transfer_from
(braket
id|disc
)braket
)paren
suffix:semicolon
id|dqput
c_func
(paren
id|transfer_from
(braket
id|disc
)braket
)paren
suffix:semicolon
)brace
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|dquot_init_hash
r_void
id|__init
id|dquot_init_hash
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;VFS: Diskquotas version %s initialized&bslash;n&quot;
comma
id|__DQUOT_VERSION__
)paren
suffix:semicolon
id|memset
c_func
(paren
id|dquot_hash
comma
l_int|0
comma
r_sizeof
(paren
id|dquot_hash
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
id|caddr_t
)paren
op_amp
id|dqstats
comma
l_int|0
comma
r_sizeof
(paren
id|dqstats
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Definitions of diskquota operations.&n; */
DECL|variable|dquot_operations
r_struct
id|dquot_operations
id|dquot_operations
op_assign
(brace
id|dquot_initialize
comma
multiline_comment|/* mandatory */
id|dquot_drop
comma
multiline_comment|/* mandatory */
id|dquot_alloc_block
comma
id|dquot_alloc_inode
comma
id|dquot_free_block
comma
id|dquot_free_inode
comma
id|dquot_transfer
)brace
suffix:semicolon
DECL|function|set_enable_flags
r_static
r_inline
r_void
id|set_enable_flags
c_func
(paren
r_struct
id|quota_mount_options
op_star
id|dqopt
comma
r_int
id|type
)paren
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|USRQUOTA
suffix:colon
id|dqopt-&gt;flags
op_or_assign
id|DQUOT_USR_ENABLED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GRPQUOTA
suffix:colon
id|dqopt-&gt;flags
op_or_assign
id|DQUOT_GRP_ENABLED
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|reset_enable_flags
r_static
r_inline
r_void
id|reset_enable_flags
c_func
(paren
r_struct
id|quota_mount_options
op_star
id|dqopt
comma
r_int
id|type
)paren
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|USRQUOTA
suffix:colon
id|dqopt-&gt;flags
op_and_assign
op_complement
id|DQUOT_USR_ENABLED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GRPQUOTA
suffix:colon
id|dqopt-&gt;flags
op_and_assign
op_complement
id|DQUOT_GRP_ENABLED
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Function in inode.c - remove pointers to dquots in icache */
r_extern
r_void
id|remove_dquot_ref
c_func
(paren
id|kdev_t
comma
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * Turn quota off on a device. type == -1 ==&gt; quotaoff for all types (umount)&n; */
DECL|function|quota_off
r_int
id|quota_off
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
)paren
(brace
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_int
id|enabled
op_assign
l_int|0
suffix:semicolon
r_struct
id|quota_mount_options
op_star
id|dqopt
op_assign
id|sb_dqopt
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* We need to serialize quota_off() for device */
id|down
c_func
(paren
op_amp
id|dqopt-&gt;dqoff_sem
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|type
op_ne
op_minus
l_int|1
op_logical_and
id|cnt
op_ne
id|type
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_enabled
c_func
(paren
id|dqopt
comma
id|cnt
)paren
)paren
r_continue
suffix:semicolon
id|reset_enable_flags
c_func
(paren
id|dqopt
comma
id|cnt
)paren
suffix:semicolon
multiline_comment|/* Note: these are blocking operations */
id|remove_dquot_ref
c_func
(paren
id|sb-&gt;s_dev
comma
id|cnt
)paren
suffix:semicolon
id|invalidate_dquots
c_func
(paren
id|sb-&gt;s_dev
comma
id|cnt
)paren
suffix:semicolon
multiline_comment|/* Wait for any pending IO - remove me as soon as invalidate is more polite */
id|down
c_func
(paren
op_amp
id|dqopt-&gt;dqio_sem
)paren
suffix:semicolon
id|filp
op_assign
id|dqopt-&gt;files
(braket
id|cnt
)braket
suffix:semicolon
id|dqopt-&gt;files
(braket
id|cnt
)braket
op_assign
(paren
r_struct
id|file
op_star
)paren
l_int|NULL
suffix:semicolon
id|dqopt-&gt;inode_expire
(braket
id|cnt
)braket
op_assign
l_int|0
suffix:semicolon
id|dqopt-&gt;block_expire
(braket
id|cnt
)braket
op_assign
l_int|0
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dqopt-&gt;dqio_sem
)paren
suffix:semicolon
id|fput
c_func
(paren
id|filp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check whether any quota is still enabled,&n;&t; * and if not clear the dq_op pointer.&n;&t; */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|MAXQUOTAS
suffix:semicolon
id|cnt
op_increment
)paren
id|enabled
op_or_assign
id|is_enabled
c_func
(paren
id|dqopt
comma
id|cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|enabled
)paren
id|sb-&gt;dq_op
op_assign
l_int|NULL
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dqopt-&gt;dqoff_sem
)paren
suffix:semicolon
id|out
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|check_quotafile_size
r_static
r_inline
r_int
id|check_quotafile_size
c_func
(paren
id|loff_t
id|size
)paren
(brace
id|ulong
id|blocks
op_assign
id|size
op_rshift
id|BLOCK_SIZE_BITS
suffix:semicolon
r_int
id|off
op_assign
id|size
op_amp
(paren
id|BLOCK_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_return
op_logical_neg
(paren
(paren
(paren
id|blocks
op_mod
r_sizeof
(paren
r_struct
id|dqblk
)paren
)paren
op_star
id|BLOCK_SIZE
op_plus
id|off
op_mod
r_sizeof
(paren
r_struct
id|dqblk
)paren
)paren
op_mod
r_sizeof
(paren
r_struct
id|dqblk
)paren
)paren
suffix:semicolon
)brace
DECL|function|quota_on
r_static
r_int
id|quota_on
c_func
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_int
id|type
comma
r_char
op_star
id|path
)paren
(brace
r_struct
id|file
op_star
id|f
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|dquot
op_star
id|dquot
suffix:semicolon
r_struct
id|quota_mount_options
op_star
id|dqopt
op_assign
id|sb_dqopt
c_func
(paren
id|sb
)paren
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|is_enabled
c_func
(paren
id|dqopt
comma
id|type
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|down
c_func
(paren
op_amp
id|dqopt-&gt;dqoff_sem
)paren
suffix:semicolon
id|tmp
op_assign
id|getname
c_func
(paren
id|path
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|tmp
)paren
)paren
r_goto
id|out_lock
suffix:semicolon
id|f
op_assign
id|filp_open
c_func
(paren
id|tmp
comma
id|O_RDWR
comma
l_int|0600
)paren
suffix:semicolon
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|f
)paren
)paren
r_goto
id|out_lock
suffix:semicolon
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f-&gt;f_op
op_logical_or
(paren
op_logical_neg
id|f-&gt;f_op-&gt;read
op_logical_and
op_logical_neg
id|f-&gt;f_op-&gt;write
)paren
)paren
r_goto
id|out_f
suffix:semicolon
id|inode
op_assign
id|f-&gt;f_dentry-&gt;d_inode
suffix:semicolon
id|error
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
r_goto
id|out_f
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_size
op_eq
l_int|0
op_logical_or
op_logical_neg
id|check_quotafile_size
c_func
(paren
id|inode-&gt;i_size
)paren
)paren
r_goto
id|out_f
suffix:semicolon
id|dquot_drop
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t want quota on quota files */
id|set_enable_flags
c_func
(paren
id|dqopt
comma
id|type
)paren
suffix:semicolon
id|dqopt-&gt;files
(braket
id|type
)braket
op_assign
id|f
suffix:semicolon
id|dquot
op_assign
id|dqget
c_func
(paren
id|sb
comma
l_int|0
comma
id|type
)paren
suffix:semicolon
id|dqopt-&gt;inode_expire
(braket
id|type
)braket
op_assign
(paren
id|dquot
op_ne
id|NODQUOT
)paren
ques
c_cond
id|dquot-&gt;dq_itime
suffix:colon
id|MAX_IQ_TIME
suffix:semicolon
id|dqopt-&gt;block_expire
(braket
id|type
)braket
op_assign
(paren
id|dquot
op_ne
id|NODQUOT
)paren
ques
c_cond
id|dquot-&gt;dq_btime
suffix:colon
id|MAX_DQ_TIME
suffix:semicolon
id|dqput
c_func
(paren
id|dquot
)paren
suffix:semicolon
id|sb-&gt;dq_op
op_assign
op_amp
id|dquot_operations
suffix:semicolon
id|add_dquot_ref
c_func
(paren
id|sb
comma
id|type
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|dqopt-&gt;dqoff_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_f
suffix:colon
id|filp_close
c_func
(paren
id|f
comma
l_int|NULL
)paren
suffix:semicolon
id|out_lock
suffix:colon
id|up
c_func
(paren
op_amp
id|dqopt-&gt;dqoff_sem
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the system call interface. This communicates with&n; * the user-level programs. Currently this only supports diskquota&n; * calls. Maybe we need to add the process quotas etc. in the future,&n; * but we probably should use rlimits for that.&n; */
DECL|function|sys_quotactl
id|asmlinkage
r_int
id|sys_quotactl
c_func
(paren
r_int
id|cmd
comma
r_const
r_char
op_star
id|special
comma
r_int
id|id
comma
id|caddr_t
id|addr
)paren
(brace
r_int
id|cmds
op_assign
l_int|0
comma
id|type
op_assign
l_int|0
comma
id|flags
op_assign
l_int|0
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|cmds
op_assign
id|cmd
op_rshift
id|SUBCMDSHIFT
suffix:semicolon
id|type
op_assign
id|cmd
op_amp
id|SUBCMDMASK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|u_int
)paren
id|type
op_ge
id|MAXQUOTAS
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|id
op_amp
op_complement
l_int|0xFFFF
)paren
r_goto
id|out
suffix:semicolon
id|ret
op_assign
op_minus
id|EPERM
suffix:semicolon
r_switch
c_cond
(paren
id|cmds
)paren
(brace
r_case
id|Q_SYNC
suffix:colon
r_case
id|Q_GETSTATS
suffix:colon
r_break
suffix:semicolon
r_case
id|Q_GETQUOTA
suffix:colon
r_if
c_cond
(paren
(paren
(paren
id|type
op_eq
id|USRQUOTA
op_logical_and
id|current-&gt;euid
op_ne
id|id
)paren
op_logical_or
(paren
id|type
op_eq
id|GRPQUOTA
op_logical_and
id|in_egroup_p
c_func
(paren
id|id
)paren
)paren
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RESOURCE
)paren
)paren
r_goto
id|out
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RESOURCE
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|dev
op_assign
id|NODEV
suffix:semicolon
r_if
c_cond
(paren
id|special
op_ne
l_int|NULL
op_logical_or
(paren
id|cmds
op_ne
id|Q_SYNC
op_logical_and
id|cmds
op_ne
id|Q_GETSTATS
)paren
)paren
(brace
id|mode_t
id|mode
suffix:semicolon
r_struct
id|nameidata
id|nd
suffix:semicolon
id|ret
op_assign
id|user_path_walk
c_func
(paren
id|special
comma
op_amp
id|nd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|out
suffix:semicolon
id|dev
op_assign
id|nd.dentry-&gt;d_inode-&gt;i_rdev
suffix:semicolon
id|mode
op_assign
id|nd.dentry-&gt;d_inode-&gt;i_mode
suffix:semicolon
id|path_release
c_func
(paren
op_amp
id|nd
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENOTBLK
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISBLK
c_func
(paren
id|mode
)paren
)paren
r_goto
id|out
suffix:semicolon
id|sb
op_assign
id|get_super
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmds
)paren
(brace
r_case
id|Q_QUOTAON
suffix:colon
id|ret
op_assign
id|sb
ques
c_cond
id|quota_on
c_func
(paren
id|sb
comma
id|type
comma
(paren
r_char
op_star
)paren
id|addr
)paren
suffix:colon
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
id|Q_QUOTAOFF
suffix:colon
id|ret
op_assign
id|quota_off
c_func
(paren
id|sb
comma
id|type
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
id|Q_GETQUOTA
suffix:colon
id|ret
op_assign
id|get_quota
c_func
(paren
id|sb
comma
id|id
comma
id|type
comma
(paren
r_struct
id|dqblk
op_star
)paren
id|addr
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
id|Q_SETQUOTA
suffix:colon
id|flags
op_or_assign
id|SET_QUOTA
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_SETUSE
suffix:colon
id|flags
op_or_assign
id|SET_USE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_SETQLIM
suffix:colon
id|flags
op_or_assign
id|SET_QLIMIT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|Q_SYNC
suffix:colon
id|ret
op_assign
id|sync_dquots
c_func
(paren
id|dev
comma
id|type
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
id|Q_GETSTATS
suffix:colon
id|ret
op_assign
id|get_stats
c_func
(paren
id|addr
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
id|Q_RSQUASH
suffix:colon
id|ret
op_assign
id|quota_root_squash
c_func
(paren
id|sb
comma
id|type
comma
(paren
r_int
op_star
)paren
id|addr
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_default
suffix:colon
r_goto
id|out
suffix:semicolon
)brace
id|flags
op_or_assign
id|QUOTA_SYSCALL
suffix:semicolon
id|ret
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
id|sb
op_logical_and
id|sb_has_quota_enabled
c_func
(paren
id|sb
comma
id|type
)paren
)paren
id|ret
op_assign
id|set_dqblk
c_func
(paren
id|sb
comma
id|id
comma
id|type
comma
id|flags
comma
(paren
r_struct
id|dqblk
op_star
)paren
id|addr
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
eof
