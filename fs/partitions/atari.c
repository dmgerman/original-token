multiline_comment|/*&n; *  fs/partitions/atari.c&n; *&n; *  Code extracted from drivers/block/genhd.c&n; *&n; *  Copyright (C) 1991-1998  Linus Torvalds&n; *  Re-organised Feb 1998 Russell King&n; */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &quot;check.h&quot;
macro_line|#include &quot;atari.h&quot;
multiline_comment|/* ++guenther: this should be settable by the user (&quot;make config&quot;)?.&n; */
DECL|macro|ICD_PARTS
mdefine_line|#define ICD_PARTS
multiline_comment|/* check if a partition entry looks valid -- Atari format is assumed if at&n;   least one of the primary entries is ok this way */
DECL|macro|VALID_PARTITION
mdefine_line|#define&t;VALID_PARTITION(pi,hdsiz)&t;&t;&t;&t;&t;     &bslash;&n;    (((pi)-&gt;flg &amp; 1) &amp;&amp;&t;&t;&t;&t;&t;&t;&t;     &bslash;&n;     isalnum((pi)-&gt;id[0]) &amp;&amp; isalnum((pi)-&gt;id[1]) &amp;&amp; isalnum((pi)-&gt;id[2]) &amp;&amp; &bslash;&n;     be32_to_cpu((pi)-&gt;st) &lt;= (hdsiz) &amp;&amp;&t;&t;&t;&t;     &bslash;&n;     be32_to_cpu((pi)-&gt;st) + be32_to_cpu((pi)-&gt;siz) &lt;= (hdsiz))
DECL|function|atari_partition
r_int
id|atari_partition
(paren
r_struct
id|gendisk
op_star
id|hd
comma
id|kdev_t
id|dev
comma
r_int
r_int
id|first_sector
comma
r_int
id|minor
)paren
(brace
r_int
id|m_lim
op_assign
id|minor
op_plus
id|hd-&gt;max_p
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|rootsector
op_star
id|rs
suffix:semicolon
r_struct
id|partition_info
op_star
id|pi
suffix:semicolon
id|u32
id|extensect
suffix:semicolon
id|u32
id|hd_size
suffix:semicolon
macro_line|#ifdef ICD_PARTS
r_int
id|part_fmt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 0:unknown, 1:AHDI, 2:ICD/Supra */
macro_line|#endif
id|bh
op_assign
id|bread
(paren
id|dev
comma
l_int|0
comma
id|get_ptable_blocksize
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
r_if
c_cond
(paren
id|warn_no_part
)paren
id|printk
(paren
l_string|&quot; unable to read block 0 (partition table)&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Verify this is an Atari rootsector: */
id|rs
op_assign
(paren
r_struct
id|rootsector
op_star
)paren
id|bh-&gt;b_data
suffix:semicolon
id|hd_size
op_assign
id|hd-&gt;part
(braket
id|minor
op_minus
l_int|1
)braket
dot
id|nr_sects
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|VALID_PARTITION
c_func
(paren
op_amp
id|rs-&gt;part
(braket
l_int|0
)braket
comma
id|hd_size
)paren
op_logical_and
op_logical_neg
id|VALID_PARTITION
c_func
(paren
op_amp
id|rs-&gt;part
(braket
l_int|1
)braket
comma
id|hd_size
)paren
op_logical_and
op_logical_neg
id|VALID_PARTITION
c_func
(paren
op_amp
id|rs-&gt;part
(braket
l_int|2
)braket
comma
id|hd_size
)paren
op_logical_and
op_logical_neg
id|VALID_PARTITION
c_func
(paren
op_amp
id|rs-&gt;part
(braket
l_int|3
)braket
comma
id|hd_size
)paren
)paren
(brace
multiline_comment|/* if there&squot;s no valid primary partition, assume that no Atari&n;&t; format partition table (there&squot;s no reliable magic or the like&n;&t; :-() */
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|pi
op_assign
op_amp
id|rs-&gt;part
(braket
l_int|0
)braket
suffix:semicolon
id|printk
(paren
l_string|&quot; AHDI&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|pi
OL
op_amp
id|rs-&gt;part
(braket
l_int|4
)braket
op_logical_and
id|minor
OL
id|m_lim
suffix:semicolon
id|minor
op_increment
comma
id|pi
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pi-&gt;flg
op_amp
l_int|1
)paren
multiline_comment|/* active partition */
(brace
r_if
c_cond
(paren
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;XGM&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
multiline_comment|/* extension partition */
(brace
r_struct
id|rootsector
op_star
id|xrs
suffix:semicolon
r_struct
id|buffer_head
op_star
id|xbh
suffix:semicolon
id|ulong
id|partsect
suffix:semicolon
macro_line|#ifdef ICD_PARTS
id|part_fmt
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot; XGM&lt;&quot;
)paren
suffix:semicolon
id|partsect
op_assign
id|extensect
op_assign
id|be32_to_cpu
c_func
(paren
id|pi-&gt;st
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|xbh
op_assign
id|bread
(paren
id|dev
comma
id|partsect
op_div
l_int|2
comma
id|get_ptable_blocksize
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xbh
)paren
(brace
id|printk
(paren
l_string|&quot; block %ld read failed&bslash;n&quot;
comma
id|partsect
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|partsect
op_amp
l_int|1
)paren
id|xrs
op_assign
(paren
r_struct
id|rootsector
op_star
)paren
op_amp
id|xbh-&gt;b_data
(braket
l_int|512
)braket
suffix:semicolon
r_else
id|xrs
op_assign
(paren
r_struct
id|rootsector
op_star
)paren
op_amp
id|xbh-&gt;b_data
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* ++roman: sanity check: bit 0 of flg field must be set */
r_if
c_cond
(paren
op_logical_neg
(paren
id|xrs-&gt;part
(braket
l_int|0
)braket
dot
id|flg
op_amp
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nFirst sub-partition in extended partition is not valid!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|add_gd_partition
c_func
(paren
id|hd
comma
id|minor
comma
id|partsect
op_plus
id|be32_to_cpu
c_func
(paren
id|xrs-&gt;part
(braket
l_int|0
)braket
dot
id|st
)paren
comma
id|be32_to_cpu
c_func
(paren
id|xrs-&gt;part
(braket
l_int|0
)braket
dot
id|siz
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|xrs-&gt;part
(braket
l_int|1
)braket
dot
id|flg
op_amp
l_int|1
)paren
)paren
(brace
multiline_comment|/* end of linked partition list */
id|brelse
c_func
(paren
id|xbh
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|xrs-&gt;part
(braket
l_int|1
)braket
dot
id|id
comma
l_string|&quot;XGM&quot;
comma
l_int|3
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nID of extended partition is not XGM!&bslash;n&quot;
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|xbh
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|partsect
op_assign
id|be32_to_cpu
c_func
(paren
id|xrs-&gt;part
(braket
l_int|1
)braket
dot
id|st
)paren
op_plus
id|extensect
suffix:semicolon
id|brelse
(paren
id|xbh
)paren
suffix:semicolon
id|minor
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|m_lim
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nMaximum number of partitions reached!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot; &gt;&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we don&squot;t care about other id&squot;s */
id|add_gd_partition
(paren
id|hd
comma
id|minor
comma
id|be32_to_cpu
c_func
(paren
id|pi-&gt;st
)paren
comma
id|be32_to_cpu
c_func
(paren
id|pi-&gt;siz
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef ICD_PARTS
r_if
c_cond
(paren
id|part_fmt
op_ne
l_int|1
)paren
multiline_comment|/* no extended partitions -&gt; test ICD-format */
(brace
id|pi
op_assign
op_amp
id|rs-&gt;icdpart
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* sanity check: no ICD format if first partition invalid */
r_if
c_cond
(paren
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;GEM&quot;
comma
l_int|3
)paren
op_eq
l_int|0
op_logical_or
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;BGM&quot;
comma
l_int|3
)paren
op_eq
l_int|0
op_logical_or
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;LNX&quot;
comma
l_int|3
)paren
op_eq
l_int|0
op_logical_or
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;SWP&quot;
comma
l_int|3
)paren
op_eq
l_int|0
op_logical_or
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;RAW&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; ICD&lt;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|pi
OL
op_amp
id|rs-&gt;icdpart
(braket
l_int|8
)braket
op_logical_and
id|minor
OL
id|m_lim
suffix:semicolon
id|minor
op_increment
comma
id|pi
op_increment
)paren
(brace
multiline_comment|/* accept only GEM,BGM,RAW,LNX,SWP partitions */
r_if
c_cond
(paren
id|pi-&gt;flg
op_amp
l_int|1
op_logical_and
(paren
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;GEM&quot;
comma
l_int|3
)paren
op_eq
l_int|0
op_logical_or
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;BGM&quot;
comma
l_int|3
)paren
op_eq
l_int|0
op_logical_or
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;LNX&quot;
comma
l_int|3
)paren
op_eq
l_int|0
op_logical_or
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;SWP&quot;
comma
l_int|3
)paren
op_eq
l_int|0
op_logical_or
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;RAW&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|part_fmt
op_assign
l_int|2
suffix:semicolon
id|add_gd_partition
(paren
id|hd
comma
id|minor
comma
id|be32_to_cpu
c_func
(paren
id|pi-&gt;st
)paren
comma
id|be32_to_cpu
c_func
(paren
id|pi-&gt;siz
)paren
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot; &gt;&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|brelse
(paren
id|bh
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
eof
