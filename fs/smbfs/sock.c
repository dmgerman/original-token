multiline_comment|/*&n; *  sock.c&n; *&n; *  Copyright (C) 1995, 1996 by Paal-Kr. Engstad and Volker Lendecke&n; *  Copyright (C) 1997 by Volker Lendecke&n; *&n; *  Please add a note about your changes to smbfs in the ChangeLog file.&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/socket.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/net.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;net/scm.h&gt;
macro_line|#include &lt;net/ip.h&gt;
macro_line|#include &lt;linux/smb_fs.h&gt;
macro_line|#include &lt;linux/smb.h&gt;
macro_line|#include &lt;linux/smbno.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;smb_debug.h&quot;
r_static
r_int
DECL|function|_recvfrom
id|_recvfrom
c_func
(paren
r_struct
id|socket
op_star
id|socket
comma
r_int
r_char
op_star
id|ubuf
comma
r_int
id|size
comma
r_int
id|flags
)paren
(brace
r_struct
id|iovec
id|iov
suffix:semicolon
r_struct
id|msghdr
id|msg
suffix:semicolon
r_struct
id|scm_cookie
id|scm
suffix:semicolon
id|msg.msg_name
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_namelen
op_assign
l_int|0
suffix:semicolon
id|msg.msg_iov
op_assign
op_amp
id|iov
suffix:semicolon
id|msg.msg_iovlen
op_assign
l_int|1
suffix:semicolon
id|msg.msg_control
op_assign
l_int|NULL
suffix:semicolon
id|iov.iov_base
op_assign
id|ubuf
suffix:semicolon
id|iov.iov_len
op_assign
id|size
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|scm
comma
l_int|0
comma
r_sizeof
(paren
id|scm
)paren
)paren
suffix:semicolon
id|size
op_assign
id|socket-&gt;ops
op_member_access_from_pointer
id|recvmsg
c_func
(paren
id|socket
comma
op_amp
id|msg
comma
id|size
comma
id|flags
comma
op_amp
id|scm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_ge
l_int|0
)paren
(brace
id|scm_recv
c_func
(paren
id|socket
comma
op_amp
id|msg
comma
op_amp
id|scm
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|size
suffix:semicolon
)brace
r_static
r_int
DECL|function|_send
id|_send
c_func
(paren
r_struct
id|socket
op_star
id|socket
comma
r_const
r_void
op_star
id|buff
comma
r_int
id|len
)paren
(brace
r_struct
id|iovec
id|iov
suffix:semicolon
r_struct
id|msghdr
id|msg
suffix:semicolon
r_struct
id|scm_cookie
id|scm
suffix:semicolon
r_int
id|err
suffix:semicolon
id|msg.msg_name
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_namelen
op_assign
l_int|0
suffix:semicolon
id|msg.msg_iov
op_assign
op_amp
id|iov
suffix:semicolon
id|msg.msg_iovlen
op_assign
l_int|1
suffix:semicolon
id|msg.msg_control
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_controllen
op_assign
l_int|0
suffix:semicolon
id|iov.iov_base
op_assign
(paren
r_void
op_star
)paren
id|buff
suffix:semicolon
id|iov.iov_len
op_assign
id|len
suffix:semicolon
id|msg.msg_flags
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|scm_send
c_func
(paren
id|socket
comma
op_amp
id|msg
comma
op_amp
id|scm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ge
l_int|0
)paren
(brace
id|err
op_assign
id|socket-&gt;ops
op_member_access_from_pointer
id|sendmsg
c_func
(paren
id|socket
comma
op_amp
id|msg
comma
id|len
comma
op_amp
id|scm
)paren
suffix:semicolon
id|scm_destroy
c_func
(paren
op_amp
id|scm
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|struct|data_callback
r_struct
id|data_callback
(brace
DECL|member|cb
r_struct
id|tq_struct
id|cb
suffix:semicolon
DECL|member|sk
r_struct
id|sock
op_star
id|sk
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * N.B. What happens if we&squot;re in here when the socket closes??&n; */
r_static
r_void
DECL|function|found_data
id|found_data
c_func
(paren
r_struct
id|sock
op_star
id|sk
)paren
(brace
multiline_comment|/*&n;&t; * FIXME: copied from sock_def_readable, it should be a call to&n;&t; * server-&gt;data_ready()&t;-- manfreds@colorfullife.com&n;&t; */
id|read_lock
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sk-&gt;dead
)paren
(brace
id|wake_up_interruptible
c_func
(paren
id|sk-&gt;sleep
)paren
suffix:semicolon
id|sock_wake_async
c_func
(paren
id|sk-&gt;socket
comma
l_int|1
comma
id|POLL_IN
)paren
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|sk-&gt;callback_lock
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|smb_data_callback
id|smb_data_callback
c_func
(paren
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|data_callback
op_star
id|job
op_assign
id|ptr
suffix:semicolon
r_struct
id|socket
op_star
id|socket
op_assign
id|job-&gt;sk-&gt;socket
suffix:semicolon
r_int
r_char
id|peek_buf
(braket
l_int|4
)braket
suffix:semicolon
r_int
id|result
suffix:semicolon
id|mm_segment_t
id|fs
suffix:semicolon
r_int
id|count
op_assign
l_int|100
suffix:semicolon
multiline_comment|/* this is a lot, we should have some data waiting */
r_int
id|found
op_assign
l_int|0
suffix:semicolon
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|get_ds
c_func
(paren
)paren
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
id|peek_buf
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|job-&gt;sk-&gt;dead
)paren
(brace
id|PARANOIA
c_func
(paren
l_string|&quot;sock dead!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|result
op_assign
id|_recvfrom
c_func
(paren
id|socket
comma
(paren
r_void
op_star
)paren
id|peek_buf
comma
l_int|1
comma
id|MSG_PEEK
op_or
id|MSG_DONTWAIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|peek_buf
(braket
l_int|0
)braket
op_ne
l_int|0x85
)paren
r_break
suffix:semicolon
multiline_comment|/* got SESSION KEEP ALIVE */
id|result
op_assign
id|_recvfrom
c_func
(paren
id|socket
comma
(paren
r_void
op_star
)paren
id|peek_buf
comma
l_int|4
comma
id|MSG_DONTWAIT
)paren
suffix:semicolon
id|DEBUG1
c_func
(paren
l_string|&quot;got SESSION KEEPALIVE&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_break
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
id|DEBUG1
c_func
(paren
l_string|&quot;found=%d, count=%d, result=%d&bslash;n&quot;
comma
id|found
comma
id|count
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|found
)paren
id|found_data
c_func
(paren
id|job-&gt;sk
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|smb_data_ready
id|smb_data_ready
c_func
(paren
r_struct
id|sock
op_star
id|sk
comma
r_int
id|len
)paren
(brace
r_struct
id|data_callback
op_star
id|job
suffix:semicolon
id|job
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|data_callback
)paren
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|job
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;smb_data_ready: lost SESSION KEEPALIVE due to OOM.&bslash;n&quot;
)paren
suffix:semicolon
id|found_data
c_func
(paren
id|sk
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|job-&gt;cb.list
)paren
suffix:semicolon
id|job-&gt;cb.sync
op_assign
l_int|0
suffix:semicolon
id|job-&gt;cb.routine
op_assign
id|smb_data_callback
suffix:semicolon
id|job-&gt;cb.data
op_assign
id|job
suffix:semicolon
id|job-&gt;sk
op_assign
id|sk
suffix:semicolon
id|schedule_task
c_func
(paren
op_amp
id|job-&gt;cb
)paren
suffix:semicolon
)brace
r_int
DECL|function|smb_valid_socket
id|smb_valid_socket
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_return
(paren
id|inode
op_logical_and
id|S_ISSOCK
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_and
id|inode-&gt;u.socket_i.type
op_eq
id|SOCK_STREAM
)paren
suffix:semicolon
)brace
r_static
r_struct
id|socket
op_star
DECL|function|server_sock
id|server_sock
c_func
(paren
r_struct
id|smb_sb_info
op_star
id|server
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
r_if
c_cond
(paren
id|server
op_logical_and
(paren
id|file
op_assign
id|server-&gt;sock_file
)paren
)paren
(brace
macro_line|#ifdef SMBFS_PARANOIA
r_if
c_cond
(paren
op_logical_neg
id|smb_valid_socket
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
)paren
id|PARANOIA
c_func
(paren
l_string|&quot;bad socket!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
op_amp
id|file-&gt;f_dentry-&gt;d_inode-&gt;u.socket_i
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_int
DECL|function|smb_catch_keepalive
id|smb_catch_keepalive
c_func
(paren
r_struct
id|smb_sb_info
op_star
id|server
)paren
(brace
r_struct
id|socket
op_star
id|socket
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_void
op_star
id|data_ready
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|socket
op_assign
id|server_sock
c_func
(paren
id|server
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|socket
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;smb_catch_keepalive: did not get valid server!&bslash;n&quot;
)paren
suffix:semicolon
id|server-&gt;data_ready
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|sk
op_assign
id|socket-&gt;sk
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
id|DEBUG1
c_func
(paren
l_string|&quot;sk == NULL&quot;
)paren
suffix:semicolon
id|server-&gt;data_ready
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|DEBUG1
c_func
(paren
l_string|&quot;sk-&gt;d_r = %x, server-&gt;d_r = %x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
id|sk-&gt;data_ready
)paren
comma
(paren
r_int
r_int
)paren
(paren
id|server-&gt;data_ready
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Install the callback atomically to avoid races ...&n;&t; */
id|data_ready
op_assign
id|xchg
c_func
(paren
op_amp
id|sk-&gt;data_ready
comma
id|smb_data_ready
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data_ready
op_ne
id|smb_data_ready
)paren
(brace
id|server-&gt;data_ready
op_assign
id|data_ready
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;smb_catch_keepalive: already done&bslash;n&quot;
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
r_int
DECL|function|smb_dont_catch_keepalive
id|smb_dont_catch_keepalive
c_func
(paren
r_struct
id|smb_sb_info
op_star
id|server
)paren
(brace
r_struct
id|socket
op_star
id|socket
suffix:semicolon
r_struct
id|sock
op_star
id|sk
suffix:semicolon
r_void
op_star
id|data_ready
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|socket
op_assign
id|server_sock
c_func
(paren
id|server
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|socket
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;smb_dont_catch_keepalive: did not get valid server!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|sk
op_assign
id|socket-&gt;sk
suffix:semicolon
r_if
c_cond
(paren
id|sk
op_eq
l_int|NULL
)paren
(brace
id|DEBUG1
c_func
(paren
l_string|&quot;sk == NULL&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Is this really an error?? */
r_if
c_cond
(paren
id|server-&gt;data_ready
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;smb_dont_catch_keepalive: &quot;
l_string|&quot;server-&gt;data_ready == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|DEBUG1
c_func
(paren
l_string|&quot;smb_dont_catch_keepalive: sk-&gt;d_r = %x, server-&gt;d_r = %x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
(paren
id|sk-&gt;data_ready
)paren
comma
(paren
r_int
r_int
)paren
(paren
id|server-&gt;data_ready
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Restore the original callback atomically to avoid races ...&n;&t; */
id|data_ready
op_assign
id|xchg
c_func
(paren
op_amp
id|sk-&gt;data_ready
comma
id|server-&gt;data_ready
)paren
suffix:semicolon
id|server-&gt;data_ready
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|data_ready
op_ne
id|smb_data_ready
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;smb_dont_catch_keepalive: &quot;
l_string|&quot;sk-&gt;data_ready != smb_data_ready&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Called with the server locked.&n; */
r_void
DECL|function|smb_close_socket
id|smb_close_socket
c_func
(paren
r_struct
id|smb_sb_info
op_star
id|server
)paren
(brace
r_struct
id|file
op_star
id|file
op_assign
id|server-&gt;sock_file
suffix:semicolon
r_if
c_cond
(paren
id|file
)paren
(brace
id|VERBOSE
c_func
(paren
l_string|&quot;closing socket %p&bslash;n&quot;
comma
id|server_sock
c_func
(paren
id|server
)paren
)paren
suffix:semicolon
macro_line|#ifdef SMBFS_PARANOIA
r_if
c_cond
(paren
id|server_sock
c_func
(paren
id|server
)paren
op_member_access_from_pointer
id|sk-&gt;data_ready
op_eq
id|smb_data_ready
)paren
id|PARANOIA
c_func
(paren
l_string|&quot;still catching keepalives!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|server-&gt;sock_file
op_assign
l_int|NULL
suffix:semicolon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|smb_send_raw
id|smb_send_raw
c_func
(paren
r_struct
id|socket
op_star
id|socket
comma
r_int
r_char
op_star
id|source
comma
r_int
id|length
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|already_sent
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|already_sent
OL
id|length
)paren
(brace
id|result
op_assign
id|_send
c_func
(paren
id|socket
comma
(paren
r_void
op_star
)paren
(paren
id|source
op_plus
id|already_sent
)paren
comma
id|length
op_minus
id|already_sent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|DEBUG1
c_func
(paren
l_string|&quot;smb_send_raw: sendto error = %d&bslash;n&quot;
comma
op_minus
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|already_sent
op_add_assign
id|result
suffix:semicolon
)brace
r_return
id|already_sent
suffix:semicolon
)brace
r_static
r_int
DECL|function|smb_receive_raw
id|smb_receive_raw
c_func
(paren
r_struct
id|socket
op_star
id|socket
comma
r_int
r_char
op_star
id|target
comma
r_int
id|length
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|already_read
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|already_read
OL
id|length
)paren
(brace
id|result
op_assign
id|_recvfrom
c_func
(paren
id|socket
comma
(paren
r_void
op_star
)paren
(paren
id|target
op_plus
id|already_read
)paren
comma
id|length
op_minus
id|already_read
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|DEBUG1
c_func
(paren
l_string|&quot;recvfrom error = %d&bslash;n&quot;
comma
op_minus
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|already_read
op_add_assign
id|result
suffix:semicolon
)brace
r_return
id|already_read
suffix:semicolon
)brace
r_static
r_int
DECL|function|smb_get_length
id|smb_get_length
c_func
(paren
r_struct
id|socket
op_star
id|socket
comma
r_int
r_char
op_star
id|header
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
r_char
id|peek_buf
(braket
l_int|4
)braket
suffix:semicolon
id|mm_segment_t
id|fs
suffix:semicolon
id|re_recv
suffix:colon
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|get_ds
c_func
(paren
)paren
)paren
suffix:semicolon
id|result
op_assign
id|smb_receive_raw
c_func
(paren
id|socket
comma
id|peek_buf
comma
l_int|4
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|PARANOIA
c_func
(paren
l_string|&quot;recv error = %d&bslash;n&quot;
comma
op_minus
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|peek_buf
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0x00
suffix:colon
r_case
l_int|0x82
suffix:colon
r_break
suffix:semicolon
r_case
l_int|0x85
suffix:colon
id|DEBUG1
c_func
(paren
l_string|&quot;Got SESSION KEEP ALIVE&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|re_recv
suffix:semicolon
r_default
suffix:colon
id|PARANOIA
c_func
(paren
l_string|&quot;Invalid NBT packet, code=%x&bslash;n&quot;
comma
id|peek_buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|header
op_ne
l_int|NULL
)paren
(brace
id|memcpy
c_func
(paren
id|header
comma
id|peek_buf
comma
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/* The length in the RFC NB header is the raw data length */
r_return
id|smb_len
c_func
(paren
id|peek_buf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Since we allocate memory in increments of PAGE_SIZE,&n; * round up the packet length to the next multiple.&n; */
r_int
DECL|function|smb_round_length
id|smb_round_length
c_func
(paren
r_int
id|len
)paren
(brace
r_return
(paren
id|len
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * smb_receive&n; * fs points to the correct segment&n; */
r_static
r_int
DECL|function|smb_receive
id|smb_receive
c_func
(paren
r_struct
id|smb_sb_info
op_star
id|server
)paren
(brace
r_struct
id|socket
op_star
id|socket
op_assign
id|server_sock
c_func
(paren
id|server
)paren
suffix:semicolon
r_int
r_char
op_star
id|packet
op_assign
id|server-&gt;packet
suffix:semicolon
r_int
id|len
comma
id|result
suffix:semicolon
r_int
r_char
id|peek_buf
(braket
l_int|4
)braket
suffix:semicolon
id|result
op_assign
id|smb_get_length
c_func
(paren
id|socket
comma
id|peek_buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|len
op_assign
id|result
suffix:semicolon
multiline_comment|/*&n;&t; * Some servers do not respect our max_xmit and send&n;&t; * larger packets.  Try to allocate a new packet,&n;&t; * but don&squot;t free the old one unless we succeed.&n;&t; */
r_if
c_cond
(paren
id|len
op_plus
l_int|4
OG
id|server-&gt;packet_size
)paren
(brace
r_int
id|new_len
op_assign
id|smb_round_length
c_func
(paren
id|len
op_plus
l_int|4
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|packet
op_assign
id|smb_vmalloc
c_func
(paren
id|new_len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|packet
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
id|smb_vfree
c_func
(paren
id|server-&gt;packet
)paren
suffix:semicolon
id|server-&gt;packet
op_assign
id|packet
suffix:semicolon
id|server-&gt;packet_size
op_assign
id|new_len
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|packet
comma
id|peek_buf
comma
l_int|4
)paren
suffix:semicolon
id|result
op_assign
id|smb_receive_raw
c_func
(paren
id|socket
comma
id|packet
op_plus
l_int|4
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|VERBOSE
c_func
(paren
l_string|&quot;receive error: %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|server-&gt;rcls
op_assign
op_star
(paren
id|packet
op_plus
id|smb_rcls
)paren
suffix:semicolon
id|server-&gt;err
op_assign
id|WVAL
c_func
(paren
id|packet
comma
id|smb_err
)paren
suffix:semicolon
macro_line|#ifdef SMBFS_DEBUG_VERBOSE
r_if
c_cond
(paren
id|server-&gt;rcls
op_ne
l_int|0
)paren
id|VERBOSE
c_func
(paren
l_string|&quot;rcls=%d, err=%d&bslash;n&quot;
comma
id|server-&gt;rcls
comma
id|server-&gt;err
)paren
suffix:semicolon
macro_line|#endif
id|out
suffix:colon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine checks first for &quot;fast track&quot; processing, as most&n; * packets won&squot;t need to be copied. Otherwise, it allocates a new&n; * packet to hold the incoming data.&n; *&n; * Note that the final server packet must be the larger of the two;&n; * server packets aren&squot;t allowed to shrink.&n; */
r_static
r_int
DECL|function|smb_receive_trans2
id|smb_receive_trans2
c_func
(paren
r_struct
id|smb_sb_info
op_star
id|server
comma
r_int
op_star
id|ldata
comma
r_int
r_char
op_star
op_star
id|data
comma
r_int
op_star
id|lparm
comma
r_int
r_char
op_star
op_star
id|parm
)paren
(brace
r_int
r_char
op_star
id|inbuf
comma
op_star
id|base
comma
op_star
id|rcv_buf
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|parm_disp
comma
id|parm_offset
comma
id|parm_count
comma
id|parm_tot
comma
id|parm_len
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|data_disp
comma
id|data_offset
comma
id|data_count
comma
id|data_tot
comma
id|data_len
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|total_p
op_assign
l_int|0
comma
id|total_d
op_assign
l_int|0
comma
id|buf_len
op_assign
l_int|0
suffix:semicolon
r_int
id|result
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|result
op_assign
id|smb_receive
c_func
(paren
id|server
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|inbuf
op_assign
id|server-&gt;packet
suffix:semicolon
r_if
c_cond
(paren
id|server-&gt;rcls
op_ne
l_int|0
)paren
(brace
op_star
id|parm
op_assign
op_star
id|data
op_assign
id|inbuf
suffix:semicolon
op_star
id|ldata
op_assign
op_star
id|lparm
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Extract the control data from the packet.&n;&t;&t; */
id|data_tot
op_assign
id|WVAL
c_func
(paren
id|inbuf
comma
id|smb_tdrcnt
)paren
suffix:semicolon
id|parm_tot
op_assign
id|WVAL
c_func
(paren
id|inbuf
comma
id|smb_tprcnt
)paren
suffix:semicolon
id|parm_disp
op_assign
id|WVAL
c_func
(paren
id|inbuf
comma
id|smb_prdisp
)paren
suffix:semicolon
id|parm_offset
op_assign
id|WVAL
c_func
(paren
id|inbuf
comma
id|smb_proff
)paren
suffix:semicolon
id|parm_count
op_assign
id|WVAL
c_func
(paren
id|inbuf
comma
id|smb_prcnt
)paren
suffix:semicolon
id|data_disp
op_assign
id|WVAL
c_func
(paren
id|inbuf
comma
id|smb_drdisp
)paren
suffix:semicolon
id|data_offset
op_assign
id|WVAL
c_func
(paren
id|inbuf
comma
id|smb_droff
)paren
suffix:semicolon
id|data_count
op_assign
id|WVAL
c_func
(paren
id|inbuf
comma
id|smb_drcnt
)paren
suffix:semicolon
id|base
op_assign
id|smb_base
c_func
(paren
id|inbuf
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Assume success and increment lengths.&n;&t;&t; */
id|parm_len
op_add_assign
id|parm_count
suffix:semicolon
id|data_len
op_add_assign
id|data_count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rcv_buf
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Check for fast track processing ... just this packet.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|parm_count
op_eq
id|parm_tot
op_logical_and
id|data_count
op_eq
id|data_tot
)paren
(brace
id|VERBOSE
c_func
(paren
l_string|&quot;fast track, parm=%u %u %u, data=%u %u %u&bslash;n&quot;
comma
id|parm_disp
comma
id|parm_offset
comma
id|parm_count
comma
id|data_disp
comma
id|data_offset
comma
id|data_count
)paren
suffix:semicolon
op_star
id|parm
op_assign
id|base
op_plus
id|parm_offset
suffix:semicolon
op_star
id|data
op_assign
id|base
op_plus
id|data_offset
suffix:semicolon
r_goto
id|success
suffix:semicolon
)brace
r_if
c_cond
(paren
id|parm_tot
OG
id|TRANS2_MAX_TRANSFER
op_logical_or
id|data_tot
OG
id|TRANS2_MAX_TRANSFER
)paren
r_goto
id|out_too_long
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Save the total parameter and data length.&n;&t;&t;&t; */
id|total_d
op_assign
id|data_tot
suffix:semicolon
id|total_p
op_assign
id|parm_tot
suffix:semicolon
id|buf_len
op_assign
id|total_d
op_plus
id|total_p
suffix:semicolon
r_if
c_cond
(paren
id|server-&gt;packet_size
OG
id|buf_len
)paren
id|buf_len
op_assign
id|server-&gt;packet_size
suffix:semicolon
id|buf_len
op_assign
id|smb_round_length
c_func
(paren
id|buf_len
)paren
suffix:semicolon
id|rcv_buf
op_assign
id|smb_vmalloc
c_func
(paren
id|buf_len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rcv_buf
)paren
r_goto
id|out_no_mem
suffix:semicolon
op_star
id|parm
op_assign
id|rcv_buf
suffix:semicolon
op_star
id|data
op_assign
id|rcv_buf
op_plus
id|total_p
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data_tot
OG
id|total_d
op_logical_or
id|parm_tot
OG
id|total_p
)paren
r_goto
id|out_data_grew
suffix:semicolon
r_if
c_cond
(paren
id|parm_disp
op_plus
id|parm_count
OG
id|total_p
)paren
r_goto
id|out_bad_parm
suffix:semicolon
r_if
c_cond
(paren
id|data_disp
op_plus
id|data_count
OG
id|total_d
)paren
r_goto
id|out_bad_data
suffix:semicolon
id|memcpy
c_func
(paren
op_star
id|parm
op_plus
id|parm_disp
comma
id|base
op_plus
id|parm_offset
comma
id|parm_count
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_star
id|data
op_plus
id|data_disp
comma
id|base
op_plus
id|data_offset
comma
id|data_count
)paren
suffix:semicolon
id|PARANOIA
c_func
(paren
l_string|&quot;copied, parm=%u of %u, data=%u of %u&bslash;n&quot;
comma
id|parm_len
comma
id|parm_tot
comma
id|data_len
comma
id|data_tot
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check whether we&squot;ve received all of the data. Note that&n;&t;&t; * we use the packet totals -- total lengths might shrink!&n;&t;&t; */
r_if
c_cond
(paren
id|data_len
op_ge
id|data_tot
op_logical_and
id|parm_len
op_ge
id|parm_tot
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Install the new packet.  Note that it&squot;s possible, though&n;&t; * unlikely, that the new packet could be smaller than the&n;&t; * old one, in which case we just copy the data.&n;&t; */
id|inbuf
op_assign
id|server-&gt;packet
suffix:semicolon
r_if
c_cond
(paren
id|buf_len
op_ge
id|server-&gt;packet_size
)paren
(brace
id|server-&gt;packet_size
op_assign
id|buf_len
suffix:semicolon
id|server-&gt;packet
op_assign
id|rcv_buf
suffix:semicolon
id|rcv_buf
op_assign
id|inbuf
suffix:semicolon
)brace
r_else
(brace
id|PARANOIA
c_func
(paren
l_string|&quot;copying data, old size=%d, new size=%u&bslash;n&quot;
comma
id|server-&gt;packet_size
comma
id|buf_len
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|inbuf
comma
id|rcv_buf
comma
id|parm_len
op_plus
id|data_len
)paren
suffix:semicolon
)brace
id|success
suffix:colon
op_star
id|ldata
op_assign
id|data_len
suffix:semicolon
op_star
id|lparm
op_assign
id|parm_len
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|rcv_buf
)paren
id|smb_vfree
c_func
(paren
id|rcv_buf
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
id|out_no_mem
suffix:colon
id|PARANOIA
c_func
(paren
l_string|&quot;couldn&squot;t allocate data area&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|out_too_long
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;smb_receive_trans2: data/param too long, data=%d, parm=%d&bslash;n&quot;
comma
id|data_tot
comma
id|parm_tot
)paren
suffix:semicolon
r_goto
id|out_error
suffix:semicolon
id|out_data_grew
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;smb_receive_trans2: data/params grew!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out_error
suffix:semicolon
id|out_bad_parm
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;smb_receive_trans2: invalid parms, disp=%d, cnt=%d, tot=%d&bslash;n&quot;
comma
id|parm_disp
comma
id|parm_count
comma
id|parm_tot
)paren
suffix:semicolon
r_goto
id|out_error
suffix:semicolon
id|out_bad_data
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;smb_receive_trans2: invalid data, disp=%d, cnt=%d, tot=%d&bslash;n&quot;
comma
id|data_disp
comma
id|data_count
comma
id|data_tot
)paren
suffix:semicolon
id|out_error
suffix:colon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n; * Called with the server locked&n; */
r_int
DECL|function|smb_request
id|smb_request
c_func
(paren
r_struct
id|smb_sb_info
op_star
id|server
)paren
(brace
r_int
r_int
id|flags
comma
id|sigpipe
suffix:semicolon
id|mm_segment_t
id|fs
suffix:semicolon
id|sigset_t
id|old_set
suffix:semicolon
r_int
id|len
comma
id|result
suffix:semicolon
r_int
r_char
op_star
id|buffer
suffix:semicolon
id|result
op_assign
op_minus
id|EBADF
suffix:semicolon
id|buffer
op_assign
id|server-&gt;packet
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
r_goto
id|bad_no_packet
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|server-&gt;state
op_ne
id|CONN_VALID
)paren
r_goto
id|bad_no_conn
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|smb_dont_catch_keepalive
c_func
(paren
id|server
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|bad_conn
suffix:semicolon
id|len
op_assign
id|smb_len
c_func
(paren
id|buffer
)paren
op_plus
l_int|4
suffix:semicolon
id|DEBUG1
c_func
(paren
l_string|&quot;len = %d cmd = 0x%X&bslash;n&quot;
comma
id|len
comma
id|buffer
(braket
l_int|8
)braket
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
comma
id|flags
)paren
suffix:semicolon
id|sigpipe
op_assign
id|sigismember
c_func
(paren
op_amp
id|current-&gt;pending.signal
comma
id|SIGPIPE
)paren
suffix:semicolon
id|old_set
op_assign
id|current-&gt;blocked
suffix:semicolon
id|siginitsetinv
c_func
(paren
op_amp
id|current-&gt;blocked
comma
id|sigmask
c_func
(paren
id|SIGKILL
)paren
op_or
id|sigmask
c_func
(paren
id|SIGSTOP
)paren
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
comma
id|flags
)paren
suffix:semicolon
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|get_ds
c_func
(paren
)paren
)paren
suffix:semicolon
id|result
op_assign
id|smb_send_raw
c_func
(paren
id|server_sock
c_func
(paren
id|server
)paren
comma
(paren
r_void
op_star
)paren
id|buffer
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OG
l_int|0
)paren
(brace
id|result
op_assign
id|smb_receive
c_func
(paren
id|server
)paren
suffix:semicolon
)brace
multiline_comment|/* read/write errors are handled by errno */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
op_logical_and
op_logical_neg
id|sigpipe
)paren
id|sigdelset
c_func
(paren
op_amp
id|current-&gt;pending.signal
comma
id|SIGPIPE
)paren
suffix:semicolon
id|current-&gt;blocked
op_assign
id|old_set
suffix:semicolon
id|recalc_sigpending
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
comma
id|flags
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
r_int
id|result2
op_assign
id|smb_catch_keepalive
c_func
(paren
id|server
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result2
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;smb_request: catch keepalive failed&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|result2
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_goto
id|bad_conn
suffix:semicolon
multiline_comment|/*&n;&t; * Check for fatal server errors ...&n;&t; */
r_if
c_cond
(paren
id|server-&gt;rcls
)paren
(brace
r_int
id|error
op_assign
id|smb_errno
c_func
(paren
id|server
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|EBADSLT
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;smb_request: tree ID invalid&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|error
suffix:semicolon
r_goto
id|bad_conn
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|DEBUG1
c_func
(paren
l_string|&quot;result = %d&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
id|bad_conn
suffix:colon
id|PARANOIA
c_func
(paren
l_string|&quot;result %d, setting invalid&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
id|server-&gt;state
op_assign
id|CONN_INVALID
suffix:semicolon
id|smb_invalidate_inodes
c_func
(paren
id|server
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_no_packet
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;smb_request: no packet!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|bad_no_conn
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;smb_request: connection %d not valid!&bslash;n&quot;
comma
id|server-&gt;state
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|macro|ROUND_UP
mdefine_line|#define ROUND_UP(x) (((x)+3) &amp; ~3)
r_static
r_int
DECL|function|smb_send_trans2
id|smb_send_trans2
c_func
(paren
r_struct
id|smb_sb_info
op_star
id|server
comma
id|__u16
id|trans2_command
comma
r_int
id|ldata
comma
r_int
r_char
op_star
id|data
comma
r_int
id|lparam
comma
r_int
r_char
op_star
id|param
)paren
(brace
r_struct
id|socket
op_star
id|sock
op_assign
id|server_sock
c_func
(paren
id|server
)paren
suffix:semicolon
r_struct
id|scm_cookie
id|scm
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/* I know the following is very ugly, but I want to build the&n;&t;   smb packet as efficiently as possible. */
r_const
r_int
id|smb_parameters
op_assign
l_int|15
suffix:semicolon
r_const
r_int
id|oparam
op_assign
id|ROUND_UP
c_func
(paren
id|SMB_HEADER_LEN
op_plus
l_int|2
op_star
id|smb_parameters
op_plus
l_int|2
op_plus
l_int|3
)paren
suffix:semicolon
r_const
r_int
id|odata
op_assign
id|ROUND_UP
c_func
(paren
id|oparam
op_plus
id|lparam
)paren
suffix:semicolon
r_const
r_int
id|bcc
op_assign
id|odata
op_plus
id|ldata
op_minus
(paren
id|SMB_HEADER_LEN
op_plus
l_int|2
op_star
id|smb_parameters
op_plus
l_int|2
)paren
suffix:semicolon
r_const
r_int
id|packet_length
op_assign
id|SMB_HEADER_LEN
op_plus
l_int|2
op_star
id|smb_parameters
op_plus
id|bcc
op_plus
l_int|2
suffix:semicolon
r_int
r_char
id|padding
(braket
l_int|4
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_struct
id|iovec
id|iov
(braket
l_int|4
)braket
suffix:semicolon
r_struct
id|msghdr
id|msg
suffix:semicolon
multiline_comment|/* N.B. This test isn&squot;t valid! packet_size may be &lt; max_xmit */
r_if
c_cond
(paren
(paren
id|bcc
op_plus
id|oparam
)paren
OG
id|server-&gt;opt.max_xmit
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|p
op_assign
id|smb_setup_header
c_func
(paren
id|server
comma
id|SMBtrans2
comma
id|smb_parameters
comma
id|bcc
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|server-&gt;packet
comma
id|smb_tpscnt
comma
id|lparam
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|server-&gt;packet
comma
id|smb_tdscnt
comma
id|ldata
)paren
suffix:semicolon
multiline_comment|/* N.B. these values should reflect out current packet size */
id|WSET
c_func
(paren
id|server-&gt;packet
comma
id|smb_mprcnt
comma
id|TRANS2_MAX_TRANSFER
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|server-&gt;packet
comma
id|smb_mdrcnt
comma
id|TRANS2_MAX_TRANSFER
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|server-&gt;packet
comma
id|smb_msrcnt
comma
l_int|0
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|server-&gt;packet
comma
id|smb_flags
comma
l_int|0
)paren
suffix:semicolon
id|DSET
c_func
(paren
id|server-&gt;packet
comma
id|smb_timeout
comma
l_int|0
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|server-&gt;packet
comma
id|smb_pscnt
comma
id|lparam
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|server-&gt;packet
comma
id|smb_psoff
comma
id|oparam
op_minus
l_int|4
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|server-&gt;packet
comma
id|smb_dscnt
comma
id|ldata
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|server-&gt;packet
comma
id|smb_dsoff
comma
id|odata
op_minus
l_int|4
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|server-&gt;packet
comma
id|smb_suwcnt
comma
l_int|1
)paren
suffix:semicolon
id|WSET
c_func
(paren
id|server-&gt;packet
comma
id|smb_setup0
comma
id|trans2_command
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* null smb_name for trans2 */
op_star
id|p
op_increment
op_assign
l_char|&squot;D&squot;
suffix:semicolon
multiline_comment|/* this was added because OS/2 does it */
op_star
id|p
op_increment
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|msg.msg_name
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_namelen
op_assign
l_int|0
suffix:semicolon
id|msg.msg_control
op_assign
l_int|NULL
suffix:semicolon
id|msg.msg_controllen
op_assign
l_int|0
suffix:semicolon
id|msg.msg_iov
op_assign
id|iov
suffix:semicolon
id|msg.msg_iovlen
op_assign
l_int|4
suffix:semicolon
id|msg.msg_flags
op_assign
l_int|0
suffix:semicolon
id|iov
(braket
l_int|0
)braket
dot
id|iov_base
op_assign
(paren
r_void
op_star
)paren
id|server-&gt;packet
suffix:semicolon
id|iov
(braket
l_int|0
)braket
dot
id|iov_len
op_assign
id|oparam
suffix:semicolon
id|iov
(braket
l_int|1
)braket
dot
id|iov_base
op_assign
(paren
id|param
op_eq
l_int|NULL
)paren
ques
c_cond
id|padding
suffix:colon
id|param
suffix:semicolon
id|iov
(braket
l_int|1
)braket
dot
id|iov_len
op_assign
id|lparam
suffix:semicolon
id|iov
(braket
l_int|2
)braket
dot
id|iov_base
op_assign
id|padding
suffix:semicolon
id|iov
(braket
l_int|2
)braket
dot
id|iov_len
op_assign
id|odata
op_minus
id|oparam
op_minus
id|lparam
suffix:semicolon
id|iov
(braket
l_int|3
)braket
dot
id|iov_base
op_assign
(paren
id|data
op_eq
l_int|NULL
)paren
ques
c_cond
id|padding
suffix:colon
id|data
suffix:semicolon
id|iov
(braket
l_int|3
)braket
dot
id|iov_len
op_assign
id|ldata
suffix:semicolon
id|err
op_assign
id|scm_send
c_func
(paren
id|sock
comma
op_amp
id|msg
comma
op_amp
id|scm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ge
l_int|0
)paren
(brace
id|err
op_assign
id|sock-&gt;ops
op_member_access_from_pointer
id|sendmsg
c_func
(paren
id|sock
comma
op_amp
id|msg
comma
id|packet_length
comma
op_amp
id|scm
)paren
suffix:semicolon
id|scm_destroy
c_func
(paren
op_amp
id|scm
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * This is not really a trans2 request, we assume that you only have&n; * one packet to send.&n; */
r_int
DECL|function|smb_trans2_request
id|smb_trans2_request
c_func
(paren
r_struct
id|smb_sb_info
op_star
id|server
comma
id|__u16
id|trans2_command
comma
r_int
id|ldata
comma
r_int
r_char
op_star
id|data
comma
r_int
id|lparam
comma
r_int
r_char
op_star
id|param
comma
r_int
op_star
id|lrdata
comma
r_int
r_char
op_star
op_star
id|rdata
comma
r_int
op_star
id|lrparam
comma
r_int
r_char
op_star
op_star
id|rparam
)paren
(brace
id|sigset_t
id|old_set
suffix:semicolon
r_int
r_int
id|flags
comma
id|sigpipe
suffix:semicolon
id|mm_segment_t
id|fs
suffix:semicolon
r_int
id|result
suffix:semicolon
id|DEBUG1
c_func
(paren
l_string|&quot;com=%d, ld=%d, lp=%d&bslash;n&quot;
comma
id|trans2_command
comma
id|ldata
comma
id|lparam
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * These are initialized in smb_request_ok, but not here??&n;&t; */
id|server-&gt;rcls
op_assign
l_int|0
suffix:semicolon
id|server-&gt;err
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|server-&gt;state
op_ne
id|CONN_VALID
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|smb_dont_catch_keepalive
c_func
(paren
id|server
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|bad_conn
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
comma
id|flags
)paren
suffix:semicolon
id|sigpipe
op_assign
id|sigismember
c_func
(paren
op_amp
id|current-&gt;pending.signal
comma
id|SIGPIPE
)paren
suffix:semicolon
id|old_set
op_assign
id|current-&gt;blocked
suffix:semicolon
id|siginitsetinv
c_func
(paren
op_amp
id|current-&gt;blocked
comma
id|sigmask
c_func
(paren
id|SIGKILL
)paren
op_or
id|sigmask
c_func
(paren
id|SIGSTOP
)paren
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
comma
id|flags
)paren
suffix:semicolon
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|get_ds
c_func
(paren
)paren
)paren
suffix:semicolon
id|result
op_assign
id|smb_send_trans2
c_func
(paren
id|server
comma
id|trans2_command
comma
id|ldata
comma
id|data
comma
id|lparam
comma
id|param
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|result
op_assign
id|smb_receive_trans2
c_func
(paren
id|server
comma
id|lrdata
comma
id|rdata
comma
id|lrparam
comma
id|rparam
)paren
suffix:semicolon
)brace
multiline_comment|/* read/write errors are handled by errno */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EPIPE
op_logical_and
op_logical_neg
id|sigpipe
)paren
id|sigdelset
c_func
(paren
op_amp
id|current-&gt;pending.signal
comma
id|SIGPIPE
)paren
suffix:semicolon
id|current-&gt;blocked
op_assign
id|old_set
suffix:semicolon
id|recalc_sigpending
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
comma
id|flags
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
r_int
id|result2
op_assign
id|smb_catch_keepalive
c_func
(paren
id|server
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result2
OL
l_int|0
)paren
(brace
id|result
op_assign
id|result2
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_goto
id|bad_conn
suffix:semicolon
multiline_comment|/*&n;&t; * Check for fatal server errors ...&n;&t; */
r_if
c_cond
(paren
id|server-&gt;rcls
)paren
(brace
r_int
id|error
op_assign
id|smb_errno
c_func
(paren
id|server
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
id|EBADSLT
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;smb_request: tree ID invalid&bslash;n&quot;
)paren
suffix:semicolon
id|result
op_assign
id|error
suffix:semicolon
r_goto
id|bad_conn
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
id|result
suffix:semicolon
id|bad_conn
suffix:colon
id|PARANOIA
c_func
(paren
l_string|&quot;result=%d, setting invalid&bslash;n&quot;
comma
id|result
)paren
suffix:semicolon
id|server-&gt;state
op_assign
id|CONN_INVALID
suffix:semicolon
id|smb_invalidate_inodes
c_func
(paren
id|server
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
eof
