multiline_comment|/*&n; *  dir.c&n; *&n; *  Copyright (C) 1995, 1996 by Paal-Kr. Engstad and Volker Lendecke&n; *  Copyright (C) 1997 by Volker Lendecke&n; *&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/smb_fs.h&gt;
macro_line|#include &lt;linux/smbno.h&gt;
DECL|macro|SMBFS_PARANOIA
mdefine_line|#define SMBFS_PARANOIA 1
multiline_comment|/* #define SMBFS_DEBUG_VERBOSE 1 */
multiline_comment|/* #define pr_debug printk */
DECL|macro|SMBFS_MAX_AGE
mdefine_line|#define SMBFS_MAX_AGE 5*HZ
r_static
id|ssize_t
id|smb_dir_read
c_func
(paren
r_struct
id|file
op_star
comma
r_char
op_star
comma
r_int
comma
id|loff_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|smb_readdir
c_func
(paren
r_struct
id|file
op_star
comma
r_void
op_star
comma
id|filldir_t
)paren
suffix:semicolon
r_static
r_int
id|smb_dir_open
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_int
id|smb_lookup
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|dentry
op_star
)paren
suffix:semicolon
r_static
r_int
id|smb_create
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|dentry
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|smb_mkdir
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|dentry
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|smb_rmdir
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|dentry
op_star
)paren
suffix:semicolon
r_static
r_int
id|smb_unlink
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|dentry
op_star
)paren
suffix:semicolon
r_static
r_int
id|smb_rename
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|dentry
op_star
comma
r_struct
id|inode
op_star
comma
r_struct
id|dentry
op_star
)paren
suffix:semicolon
DECL|variable|smb_dir_operations
r_static
r_struct
id|file_operations
id|smb_dir_operations
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|smb_dir_read
comma
multiline_comment|/* read - bad */
l_int|NULL
comma
multiline_comment|/* write - bad */
id|smb_readdir
comma
multiline_comment|/* readdir */
l_int|NULL
comma
multiline_comment|/* poll - default */
id|smb_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|smb_dir_open
comma
multiline_comment|/* open(struct inode *, struct file *) */
l_int|NULL
comma
multiline_comment|/* no special release code */
l_int|NULL
multiline_comment|/* fsync */
)brace
suffix:semicolon
DECL|variable|smb_dir_inode_operations
r_struct
id|inode_operations
id|smb_dir_inode_operations
op_assign
(brace
op_amp
id|smb_dir_operations
comma
multiline_comment|/* default directory file ops */
id|smb_create
comma
multiline_comment|/* create */
id|smb_lookup
comma
multiline_comment|/* lookup */
l_int|NULL
comma
multiline_comment|/* link */
id|smb_unlink
comma
multiline_comment|/* unlink */
l_int|NULL
comma
multiline_comment|/* symlink */
id|smb_mkdir
comma
multiline_comment|/* mkdir */
id|smb_rmdir
comma
multiline_comment|/* rmdir */
l_int|NULL
comma
multiline_comment|/* mknod */
id|smb_rename
comma
multiline_comment|/* rename */
l_int|NULL
comma
multiline_comment|/* readlink */
l_int|NULL
comma
multiline_comment|/* follow_link */
l_int|NULL
comma
multiline_comment|/* readpage */
l_int|NULL
comma
multiline_comment|/* writepage */
l_int|NULL
comma
multiline_comment|/* bmap */
l_int|NULL
comma
multiline_comment|/* truncate */
l_int|NULL
comma
multiline_comment|/* permission */
l_int|NULL
comma
multiline_comment|/* smap */
l_int|NULL
comma
multiline_comment|/* updatepage */
id|smb_revalidate_inode
comma
multiline_comment|/* revalidate */
)brace
suffix:semicolon
r_static
id|ssize_t
DECL|function|smb_dir_read
id|smb_dir_read
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_return
op_minus
id|EISDIR
suffix:semicolon
)brace
multiline_comment|/*&n; * Check whether a dentry already exists for the given name,&n; * and return the inode number if it has an inode.  This is&n; * needed to keep getcwd() working.&n; */
r_static
id|ino_t
DECL|function|find_inode_number
id|find_inode_number
c_func
(paren
r_struct
id|dentry
op_star
id|dir
comma
r_struct
id|qstr
op_star
id|name
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|ino_t
id|ino
op_assign
l_int|0
suffix:semicolon
id|name-&gt;hash
op_assign
id|full_name_hash
c_func
(paren
id|name-&gt;name
comma
id|name-&gt;len
)paren
suffix:semicolon
id|dentry
op_assign
id|d_lookup
c_func
(paren
id|dir
comma
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry
)paren
(brace
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
id|ino
op_assign
id|dentry-&gt;d_inode-&gt;i_ino
suffix:semicolon
id|dput
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
r_return
id|ino
suffix:semicolon
)brace
r_static
r_int
DECL|function|smb_readdir
id|smb_readdir
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|dirent
comma
id|filldir_t
id|filldir
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|filp-&gt;f_dentry
suffix:semicolon
r_struct
id|inode
op_star
id|dir
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_struct
id|cache_head
op_star
id|cachep
suffix:semicolon
r_int
id|result
suffix:semicolon
macro_line|#ifdef SMBFS_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;smb_readdir: reading %s/%s, f_pos=%d&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
(paren
r_int
)paren
id|filp-&gt;f_pos
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Make sure our inode is up-to-date.&n;&t; */
id|result
op_assign
id|smb_revalidate_inode
c_func
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Get the cache pointer ...&n;&t; */
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
id|cachep
op_assign
id|smb_get_dircache
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cachep
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure the cache is up-to-date.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cachep-&gt;valid
)paren
(brace
id|result
op_assign
id|smb_refill_dircache
c_func
(paren
id|cachep
comma
id|dentry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
r_goto
id|out_free
suffix:semicolon
)brace
id|result
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
(paren
r_int
r_int
)paren
id|filp-&gt;f_pos
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|dirent
comma
l_string|&quot;.&quot;
comma
l_int|1
comma
l_int|0
comma
id|dir-&gt;i_ino
)paren
OL
l_int|0
)paren
r_goto
id|out_free
suffix:semicolon
id|filp-&gt;f_pos
op_assign
l_int|1
suffix:semicolon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|dirent
comma
l_string|&quot;..&quot;
comma
l_int|2
comma
l_int|1
comma
id|dentry-&gt;d_parent-&gt;d_inode-&gt;i_ino
)paren
OL
l_int|0
)paren
r_goto
id|out_free
suffix:semicolon
id|filp-&gt;f_pos
op_assign
l_int|2
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_struct
id|cache_dirent
id|this_dirent
comma
op_star
id|entry
op_assign
op_amp
id|this_dirent
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|smb_find_in_cache
c_func
(paren
id|cachep
comma
id|filp-&gt;f_pos
comma
id|entry
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check whether to look up the inode number.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;ino
)paren
(brace
r_struct
id|qstr
id|qname
suffix:semicolon
multiline_comment|/* N.B. Make cache_dirent name a qstr! */
id|qname.name
op_assign
id|entry-&gt;name
suffix:semicolon
id|qname.len
op_assign
id|entry-&gt;len
suffix:semicolon
id|entry-&gt;ino
op_assign
id|find_inode_number
c_func
(paren
id|dentry
comma
op_amp
id|qname
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry-&gt;ino
)paren
id|entry-&gt;ino
op_assign
id|smb_invent_inos
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|filldir
c_func
(paren
id|dirent
comma
id|entry-&gt;name
comma
id|entry-&gt;len
comma
id|filp-&gt;f_pos
comma
id|entry-&gt;ino
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
id|filp-&gt;f_pos
op_add_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Release the dircache.&n;&t; */
id|out_free
suffix:colon
id|smb_free_dircache
c_func
(paren
id|cachep
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|result
suffix:semicolon
)brace
r_static
r_int
DECL|function|smb_dir_open
id|smb_dir_open
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|file
op_star
id|file
)paren
(brace
macro_line|#ifdef SMBFS_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;smb_dir_open: (%s/%s)&bslash;n&quot;
comma
id|file-&gt;f_dentry-&gt;d_parent-&gt;d_name.name
comma
id|file-&gt;f_dentry-&gt;d_name.name
)paren
suffix:semicolon
macro_line|#endif
r_return
id|smb_revalidate_inode
c_func
(paren
id|dir
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Dentry operations routines&n; */
r_static
r_int
id|smb_lookup_validate
c_func
(paren
r_struct
id|dentry
op_star
)paren
suffix:semicolon
r_static
r_void
id|smb_delete_dentry
c_func
(paren
r_struct
id|dentry
op_star
)paren
suffix:semicolon
DECL|variable|smbfs_dentry_operations
r_static
r_struct
id|dentry_operations
id|smbfs_dentry_operations
op_assign
(brace
id|smb_lookup_validate
comma
multiline_comment|/* d_validate(struct dentry *) */
l_int|NULL
comma
multiline_comment|/* d_hash */
l_int|NULL
comma
multiline_comment|/* d_compare */
id|smb_delete_dentry
multiline_comment|/* d_delete(struct dentry *) */
)brace
suffix:semicolon
multiline_comment|/*&n; * This is the callback when the dcache has a lookup hit.&n; */
r_static
r_int
DECL|function|smb_lookup_validate
id|smb_lookup_validate
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_int
r_int
id|age
op_assign
id|jiffies
op_minus
id|dentry-&gt;d_time
suffix:semicolon
r_int
id|valid
suffix:semicolon
multiline_comment|/*&n;&t; * The default validation is based on dentry age:&n;&t; * we believe in dentries for 5 seconds.  (But each&n;&t; * successful server lookup renews the timestamp.)&n;&t; */
id|valid
op_assign
(paren
id|age
op_le
id|SMBFS_MAX_AGE
)paren
op_logical_or
id|IS_ROOT
c_func
(paren
id|dentry
)paren
suffix:semicolon
macro_line|#ifdef SMBFS_DEBUG_VERBOSE
r_if
c_cond
(paren
op_logical_neg
id|valid
)paren
id|printk
c_func
(paren
l_string|&quot;smb_lookup_validate: %s/%s not valid, age=%lu&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|age
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|inode
)paren
(brace
r_if
c_cond
(paren
id|is_bad_inode
c_func
(paren
id|inode
)paren
)paren
(brace
macro_line|#ifdef SMBFS_PARANOIA
id|printk
c_func
(paren
l_string|&quot;smb_lookup_validate: %s/%s has dud inode&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
macro_line|#endif
id|valid
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t; * What should we do for negative dentries?&n;&t; */
)brace
r_return
id|valid
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the callback from dput() when d_count is going to 0.&n; * We use this to unhash dentries with bad inodes and close files.&n; */
r_static
r_void
DECL|function|smb_delete_dentry
id|smb_delete_dentry
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_if
c_cond
(paren
(paren
id|jiffies
op_minus
id|dentry-&gt;d_time
)paren
OG
id|SMBFS_MAX_AGE
)paren
(brace
macro_line|#ifdef SMBFS_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;smb_delete_dentry: %s/%s expired, d_time=%lu, now=%lu&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_time
comma
id|jiffies
)paren
suffix:semicolon
macro_line|#endif
id|d_drop
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
(brace
r_if
c_cond
(paren
id|is_bad_inode
c_func
(paren
id|dentry-&gt;d_inode
)paren
)paren
(brace
macro_line|#ifdef SMBFS_PARANOIA
id|printk
c_func
(paren
l_string|&quot;smb_delete_dentry: bad inode, unhashing %s/%s&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
macro_line|#endif
id|d_drop
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
id|smb_close_dentry
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* N.B. Unhash negative dentries? */
)brace
)brace
multiline_comment|/*&n; * Whenever a lookup succeeds, we know the parent directories&n; * are all valid, so we want to update the dentry timestamps.&n; * N.B. Move this to dcache?&n; */
r_void
DECL|function|smb_renew_times
id|smb_renew_times
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|dentry-&gt;d_time
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|dentry
op_eq
id|dentry-&gt;d_parent
)paren
r_break
suffix:semicolon
id|dentry
op_assign
id|dentry-&gt;d_parent
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|smb_lookup
id|smb_lookup
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|smb_fattr
id|finfo
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|ENAMETOOLONG
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_name.len
OG
id|SMB_MAXNAMELEN
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|smb_proc_getattr
c_func
(paren
id|dentry-&gt;d_parent
comma
op_amp
(paren
id|dentry-&gt;d_name
)paren
comma
op_amp
id|finfo
)paren
suffix:semicolon
macro_line|#ifdef SMBFS_PARANOIA
r_if
c_cond
(paren
id|error
op_logical_and
id|error
op_ne
op_minus
id|ENOENT
)paren
id|printk
c_func
(paren
l_string|&quot;smb_lookup: find %s/%s failed, error=%d&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|error
)paren
suffix:semicolon
macro_line|#endif
id|inode
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|ENOENT
)paren
r_goto
id|add_entry
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
op_minus
id|EACCES
suffix:semicolon
id|finfo.f_ino
op_assign
id|smb_invent_inos
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|inode
op_assign
id|smb_iget
c_func
(paren
id|dir-&gt;i_sb
comma
op_amp
id|finfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode
)paren
(brace
multiline_comment|/* cache the dentry pointer */
id|inode-&gt;u.smbfs_i.dentry
op_assign
id|dentry
suffix:semicolon
id|add_entry
suffix:colon
id|dentry-&gt;d_op
op_assign
op_amp
id|smbfs_dentry_operations
suffix:semicolon
id|d_add
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|smb_renew_times
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * This code is common to all routines creating a new inode.&n; */
r_static
r_int
DECL|function|smb_instantiate
id|smb_instantiate
c_func
(paren
r_struct
id|dentry
op_star
id|dentry
comma
id|__u16
id|fileid
comma
r_int
id|have_id
)paren
(brace
r_struct
id|smb_sb_info
op_star
id|server
op_assign
id|server_from_dentry
c_func
(paren
id|dentry
)paren
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_struct
id|smb_fattr
id|fattr
suffix:semicolon
r_int
id|error
suffix:semicolon
macro_line|#ifdef SMBFS_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;smb_instantiate: file %s/%s, fileid=%u&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|fileid
)paren
suffix:semicolon
macro_line|#endif
id|error
op_assign
id|smb_proc_getattr
c_func
(paren
id|dentry-&gt;d_parent
comma
op_amp
(paren
id|dentry-&gt;d_name
)paren
comma
op_amp
id|fattr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out_close
suffix:semicolon
id|smb_renew_times
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|fattr.f_ino
op_assign
id|smb_invent_inos
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|inode
op_assign
id|smb_iget
c_func
(paren
id|dentry-&gt;d_sb
comma
op_amp
id|fattr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|out_no_inode
suffix:semicolon
r_if
c_cond
(paren
id|have_id
)paren
(brace
id|inode-&gt;u.smbfs_i.fileid
op_assign
id|fileid
suffix:semicolon
id|inode-&gt;u.smbfs_i.access
op_assign
id|SMB_O_RDWR
suffix:semicolon
id|inode-&gt;u.smbfs_i.open
op_assign
id|server-&gt;generation
suffix:semicolon
)brace
multiline_comment|/* cache the dentry pointer */
id|inode-&gt;u.smbfs_i.dentry
op_assign
id|dentry
suffix:semicolon
id|d_instantiate
c_func
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|error
suffix:semicolon
id|out_no_inode
suffix:colon
id|error
op_assign
op_minus
id|EACCES
suffix:semicolon
id|out_close
suffix:colon
r_if
c_cond
(paren
id|have_id
)paren
(brace
macro_line|#ifdef SMBFS_PARANOIA
id|printk
c_func
(paren
l_string|&quot;smb_instantiate: %s/%s failed, error=%d, closing %u&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|error
comma
id|fileid
)paren
suffix:semicolon
macro_line|#endif
id|smb_close_fileid
c_func
(paren
id|dentry
comma
id|fileid
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* N.B. How should the mode argument be used? */
r_static
r_int
DECL|function|smb_create
id|smb_create
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
id|__u16
id|fileid
suffix:semicolon
r_int
id|error
suffix:semicolon
macro_line|#ifdef SMBFS_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;smb_create: creating %s/%s, mode=%d&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|mode
)paren
suffix:semicolon
macro_line|#endif
id|error
op_assign
op_minus
id|ENAMETOOLONG
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_name.len
OG
id|SMB_MAXNAMELEN
)paren
r_goto
id|out
suffix:semicolon
id|smb_invalid_dir_cache
c_func
(paren
id|dir
)paren
suffix:semicolon
id|error
op_assign
id|smb_proc_create
c_func
(paren
id|dentry-&gt;d_parent
comma
op_amp
(paren
id|dentry-&gt;d_name
)paren
comma
l_int|0
comma
id|CURRENT_TIME
comma
op_amp
id|fileid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|smb_instantiate
c_func
(paren
id|dentry
comma
id|fileid
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef SMBFS_PARANOIA
id|printk
c_func
(paren
l_string|&quot;smb_create: %s/%s failed, error=%d&bslash;n&quot;
comma
id|dentry-&gt;d_parent-&gt;d_name.name
comma
id|dentry-&gt;d_name.name
comma
id|error
)paren
suffix:semicolon
macro_line|#endif
)brace
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* N.B. How should the mode argument be used? */
r_static
r_int
DECL|function|smb_mkdir
id|smb_mkdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|ENAMETOOLONG
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_name.len
OG
id|SMB_MAXNAMELEN
)paren
r_goto
id|out
suffix:semicolon
id|smb_invalid_dir_cache
c_func
(paren
id|dir
)paren
suffix:semicolon
id|error
op_assign
id|smb_proc_mkdir
c_func
(paren
id|dentry-&gt;d_parent
comma
op_amp
(paren
id|dentry-&gt;d_name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
id|smb_instantiate
c_func
(paren
id|dentry
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
r_static
r_int
DECL|function|smb_rmdir
id|smb_rmdir
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|ENAMETOOLONG
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_name.len
OG
id|SMB_MAXNAMELEN
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Since the dentry is holding an inode, the file&n;&t; * is in use, so we have to close it first.&n;&t; */
id|smb_close
c_func
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Prune any child dentries so this dentry can become negative.&n;&t; */
r_if
c_cond
(paren
id|dentry-&gt;d_count
OG
l_int|1
)paren
(brace
id|shrink_dcache_parent
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_count
OG
l_int|1
)paren
r_goto
id|out
suffix:semicolon
)brace
id|smb_invalid_dir_cache
c_func
(paren
id|dir
)paren
suffix:semicolon
id|error
op_assign
id|smb_proc_rmdir
c_func
(paren
id|dentry-&gt;d_parent
comma
op_amp
(paren
id|dentry-&gt;d_name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|smb_renew_times
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|d_delete
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
r_static
r_int
DECL|function|smb_unlink
id|smb_unlink
c_func
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|ENAMETOOLONG
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_name.len
OG
id|SMB_MAXNAMELEN
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Since the dentry is holding an inode, the file&n;&t; * is in use, so we have to close it first.&n;&t; */
id|smb_close
c_func
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
id|smb_invalid_dir_cache
c_func
(paren
id|dir
)paren
suffix:semicolon
id|error
op_assign
id|smb_proc_unlink
c_func
(paren
id|dentry-&gt;d_parent
comma
op_amp
(paren
id|dentry-&gt;d_name
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|smb_renew_times
c_func
(paren
id|dentry
)paren
suffix:semicolon
id|d_delete
c_func
(paren
id|dentry
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
r_static
r_int
DECL|function|smb_rename
id|smb_rename
c_func
(paren
r_struct
id|inode
op_star
id|old_dir
comma
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|new_dir
comma
r_struct
id|dentry
op_star
id|new_dentry
)paren
(brace
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
id|ENAMETOOLONG
suffix:semicolon
r_if
c_cond
(paren
id|old_dentry-&gt;d_name.len
OG
id|SMB_MAXNAMELEN
op_logical_or
id|new_dentry-&gt;d_name.len
OG
id|SMB_MAXNAMELEN
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Since the old and new dentries are holding the files open,&n;&t; * we have to close the files first.&n;&t; */
r_if
c_cond
(paren
id|old_dentry-&gt;d_inode
)paren
id|smb_close
c_func
(paren
id|old_dentry-&gt;d_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_dentry-&gt;d_inode
)paren
id|smb_close
c_func
(paren
id|new_dentry-&gt;d_inode
)paren
suffix:semicolon
id|smb_invalid_dir_cache
c_func
(paren
id|old_dir
)paren
suffix:semicolon
id|smb_invalid_dir_cache
c_func
(paren
id|new_dir
)paren
suffix:semicolon
id|error
op_assign
id|smb_proc_mv
c_func
(paren
id|old_dentry-&gt;d_parent
comma
op_amp
(paren
id|old_dentry-&gt;d_name
)paren
comma
id|new_dentry-&gt;d_parent
comma
op_amp
(paren
id|new_dentry-&gt;d_name
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the new file exists, attempt to delete it.&n;&t; */
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|EEXIST
)paren
(brace
macro_line|#ifdef SMBFS_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;smb_rename: existing file %s/%s, d_count=%d&bslash;n&quot;
comma
id|new_dentry-&gt;d_parent-&gt;d_name.name
comma
id|new_dentry-&gt;d_name.name
comma
id|new_dentry-&gt;d_count
)paren
suffix:semicolon
macro_line|#endif
id|error
op_assign
id|smb_proc_unlink
c_func
(paren
id|new_dentry-&gt;d_parent
comma
op_amp
(paren
id|new_dentry-&gt;d_name
)paren
)paren
suffix:semicolon
macro_line|#ifdef SMBFS_DEBUG_VERBOSE
id|printk
c_func
(paren
l_string|&quot;smb_rename: after unlink error=%d&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|d_delete
c_func
(paren
id|new_dentry
)paren
suffix:semicolon
id|error
op_assign
id|smb_proc_mv
c_func
(paren
id|old_dentry-&gt;d_parent
comma
op_amp
(paren
id|old_dentry-&gt;d_name
)paren
comma
id|new_dentry-&gt;d_parent
comma
op_amp
(paren
id|new_dentry-&gt;d_name
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Update the dcache&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|smb_renew_times
c_func
(paren
id|old_dentry
)paren
suffix:semicolon
id|smb_renew_times
c_func
(paren
id|new_dentry-&gt;d_parent
)paren
suffix:semicolon
id|d_move
c_func
(paren
id|old_dentry
comma
id|new_dentry
)paren
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|error
suffix:semicolon
)brace
eof
