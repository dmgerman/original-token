multiline_comment|/*  devfs (Device FileSystem) driver.&n;&n;    Copyright (C) 1998-2000  Richard Gooch&n;&n;    This library is free software; you can redistribute it and/or&n;    modify it under the terms of the GNU Library General Public&n;    License as published by the Free Software Foundation; either&n;    version 2 of the License, or (at your option) any later version.&n;&n;    This library is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n;    Library General Public License for more details.&n;&n;    You should have received a copy of the GNU Library General Public&n;    License along with this library; if not, write to the Free&n;    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n;    Richard Gooch may be reached by email at  rgooch@atnf.csiro.au&n;    The postal address is:&n;      Richard Gooch, c/o ATNF, P. O. Box 76, Epping, N.S.W., 2121, Australia.&n;&n;    ChangeLog&n;&n;    19980110   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Original version.&n;  v0.1&n;    19980111   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created per-fs inode table rather than using inode-&gt;u.generic_ip&n;  v0.2&n;    19980111   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created .epoch inode which has a ctime of 0.&n;&t;       Fixed loss of named pipes when dentries lost.&n;&t;       Fixed loss of inode data when devfs_register() follows mknod().&n;  v0.3&n;    19980111   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fix for when compiling with CONFIG_KERNELD.&n;    19980112   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fix for readdir() which sometimes didn&squot;t show entries.&n;&t;       Added &lt;&lt;tolerant&gt;&gt; option to &lt;devfs_register&gt;.&n;  v0.4&n;    19980113   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created &lt;devfs_fill_file&gt; function.&n;  v0.5&n;    19980115   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Added subdirectory support. Major restructuring.&n;    19980116   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fixed &lt;find_by_dev&gt; to not search major=0,minor=0.&n;&t;       Added symlink support.&n;  v0.6&n;    19980120   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created &lt;devfs_mk_dir&gt; function and support directory unregister&n;    19980120   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Auto-ownership uses real uid/gid rather than effective uid/gid.&n;  v0.7&n;    19980121   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Supported creation of sockets.&n;  v0.8&n;    19980122   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Added DEVFS_FL_HIDE_UNREG flag.&n;&t;       Interface change to &lt;devfs_mk_symlink&gt;.&n;               Created &lt;devfs_symlink&gt; to support symlink(2).&n;  v0.9&n;    19980123   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Added check to &lt;devfs_fill_file&gt; to check inode is in devfs.&n;&t;       Added optional traversal of symlinks.&n;  v0.10&n;    19980124   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created &lt;devfs_get_flags&gt; and &lt;devfs_set_flags&gt;.&n;  v0.11&n;    19980125   C. Scott Ananian &lt;cananian@alumni.princeton.edu&gt;&n;               Created &lt;devfs_find_handle&gt;.&n;    19980125   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Allow removal of symlinks.&n;  v0.12&n;    19980125   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Created &lt;devfs_set_symlink_destination&gt;.&n;    19980126   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Moved DEVFS_SUPER_MAGIC into header file.&n;&t;       Added DEVFS_FL_HIDE flag.&n;&t;       Created &lt;devfs_get_maj_min&gt;.&n;&t;       Created &lt;devfs_get_handle_from_inode&gt;.&n;&t;       Fixed minor bug in &lt;find_by_dev&gt;.&n;    19980127   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Changed interface to &lt;find_by_dev&gt;, &lt;find_entry&gt;,&n;&t;       &lt;devfs_unregister&gt;, &lt;devfs_fill_file&gt; and &lt;devfs_find_handle&gt;.&n;&t;       Fixed inode times when symlink created with symlink(2).&n;  v0.13&n;    19980129   C. Scott Ananian &lt;cananian@alumni.princeton.edu&gt;&n;               Exported &lt;devfs_set_symlink_destination&gt;, &lt;devfs_get_maj_min&gt;&n;&t;       and &lt;devfs_get_handle_from_inode&gt;.&n;    19980129   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &lt;devfs_unlink&gt; to support unlink(2).&n;  v0.14&n;    19980129   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed kerneld support for entries in devfs subdirectories.&n;    19980130   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Bugfixes in &lt;call_kerneld&gt;.&n;  v0.15&n;    19980207   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Call kerneld when looking up unregistered entries.&n;  v0.16&n;    19980326   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Modified interface to &lt;devfs_find_handle&gt; for symlink traversal.&n;  v0.17&n;    19980331   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed persistence bug with device numbers for manually created&n;&t;       device files.&n;&t;       Fixed problem with recreating symlinks with different content.&n;  v0.18&n;    19980401   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Changed to CONFIG_KMOD.&n;&t;       Hide entries which are manually unlinked.&n;&t;       Always invalidate devfs dentry cache when registering entries.&n;&t;       Created &lt;devfs_rmdir&gt; to support rmdir(2).&n;&t;       Ensure directories created by &lt;devfs_mk_dir&gt; are visible.&n;  v0.19&n;    19980402   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Invalidate devfs dentry cache when making directories.&n;&t;       Invalidate devfs dentry cache when removing entries.&n;&t;       Fixed persistence bug with fifos.&n;  v0.20&n;    19980421   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Print process command when debugging kerneld/kmod.&n;&t;       Added debugging for register/unregister/change operations.&n;    19980422   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added &quot;devfs=&quot; boot options.&n;  v0.21&n;    19980426   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       No longer lock/unlock superblock in &lt;devfs_put_super&gt;.&n;&t;       Drop negative dentries when they are released.&n;&t;       Manage dcache more efficiently.&n;  v0.22&n;    19980427   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added DEVFS_FL_AUTO_DEVNUM flag.&n;  v0.23&n;    19980430   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       No longer set unnecessary methods.&n;  v0.24&n;    19980504   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added PID display to &lt;call_kerneld&gt; debugging message.&n;&t;       Added &quot;after&quot; debugging message to &lt;call_kerneld&gt;.&n;    19980519   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added &quot;diread&quot; and &quot;diwrite&quot; boot options.&n;    19980520   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed persistence problem with permissions.&n;  v0.25&n;    19980602   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Support legacy device nodes.&n;&t;       Fixed bug where recreated inodes were hidden.&n;  v0.26&n;    19980602   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Improved debugging in &lt;get_vfs_inode&gt;.&n;    19980607   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       No longer free old dentries in &lt;devfs_mk_dir&gt;.&n;&t;       Free all dentries for a given entry when deleting inodes.&n;  v0.27&n;    19980627   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Limit auto-device numbering to majors 128 to 239.&n;  v0.28&n;    19980629   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed inode times persistence problem.&n;  v0.29&n;    19980704   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed spelling in &lt;devfs_readlink&gt; debug.&n;&t;       Fixed bug in &lt;devfs_setup&gt; parsing &quot;dilookup&quot;.&n;  v0.30&n;    19980705   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed devfs inode leak when manually recreating inodes.&n;&t;       Fixed permission persistence problem when recreating inodes.&n;  v0.31&n;    19980727   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed harmless &quot;unused variable&quot; compiler warning.&n;&t;       Fixed modes for manually recreated device nodes.&n;  v0.32&n;    19980728   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added NULL devfs inode warning in &lt;devfs_read_inode&gt;.&n;&t;       Force all inode nlink values to 1.&n;  v0.33&n;    19980730   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added &quot;dimknod&quot; boot option.&n;&t;       Set inode nlink to 0 when freeing dentries.&n;&t;       Fixed modes for manually recreated symlinks.&n;  v0.34&n;    19980802   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed bugs in recreated directories and symlinks.&n;  v0.35&n;    19980806   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed bugs in recreated device nodes.&n;    19980807   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed bug in currently unused &lt;devfs_get_handle_from_inode&gt;.&n;&t;       Defined new &lt;devfs_handle_t&gt; type.&n;&t;       Improved debugging when getting entries.&n;&t;       Fixed bug where directories could be emptied.&n;  v0.36&n;    19980809   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Replaced dummy .epoch inode with .devfsd character device.&n;    19980810   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Implemented devfsd protocol revision 0.&n;  v0.37&n;    19980819   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added soothing message to warning in &lt;devfs_d_iput&gt;.&n;  v0.38&n;    19980829   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Use GCC extensions for structure initialisations.&n;&t;       Implemented async open notification.&n;&t;       Incremented devfsd protocol revision to 1.&n;  v0.39&n;    19980908   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Moved async open notification to end of &lt;devfs_open&gt;.&n;  v0.40&n;    19980910   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Prepended &quot;/dev/&quot; to module load request.&n;&t;       Renamed &lt;call_kerneld&gt; to &lt;call_kmod&gt;.&n;  v0.41&n;    19980910   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed typo &quot;AYSNC&quot; -&gt; &quot;ASYNC&quot;.&n;  v0.42&n;    19980910   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added open flag for files.&n;  v0.43&n;    19980927   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Set i_blocks=0 and i_blksize=1024 in &lt;devfs_read_inode&gt;.&n;  v0.44&n;    19981005   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added test for empty &lt;&lt;name&gt;&gt; in &lt;devfs_find_handle&gt;.&n;&t;       Renamed &lt;generate_path&gt; to &lt;devfs_generate_path&gt; and published.&n;  v0.45&n;    19981006   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &lt;devfs_get_fops&gt;.&n;  v0.46&n;    19981007   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Limit auto-device numbering to majors 144 to 239.&n;  v0.47&n;    19981010   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Updated &lt;devfs_follow_link&gt; for VFS change in 2.1.125.&n;  v0.48&n;    19981022   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created DEVFS_ FL_COMPAT flag.&n;  v0.49&n;    19981023   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &quot;nocompat&quot; boot option.&n;  v0.50&n;    19981025   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Replaced &quot;mount&quot; boot option with &quot;nomount&quot;.&n;  v0.51&n;    19981110   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &quot;only&quot; boot option.&n;  v0.52&n;    19981112   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added DEVFS_FL_REMOVABLE flag.&n;  v0.53&n;    19981114   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Only call &lt;scan_dir_for_removable&gt; on first call to&n;&t;       &lt;devfs_readdir&gt;.&n;  v0.54&n;    19981205   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Updated &lt;devfs_rmdir&gt; for VFS change in 2.1.131.&n;  v0.55&n;    19981218   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &lt;devfs_mk_compat&gt;.&n;    19981220   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Check for partitions on removable media in &lt;devfs_lookup&gt;.&n;  v0.56&n;    19990118   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added support for registering regular files.&n;&t;       Created &lt;devfs_set_file_size&gt;.&n;&t;       Update devfs inodes from entries if not changed through FS.&n;  v0.57&n;    19990124   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed &lt;devfs_fill_file&gt; to only initialise temporary inodes.&n;&t;       Trap for NULL fops in &lt;devfs_register&gt;.&n;&t;       Return -ENODEV in &lt;devfs_fill_file&gt; for non-driver inodes.&n;  v0.58&n;    19990126   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Switched from PATH_MAX to DEVFS_PATHLEN.&n;  v0.59&n;    19990127   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &quot;nottycompat&quot; boot option.&n;  v0.60&n;    19990318   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed &lt;devfsd_read&gt; to not overrun event buffer.&n;  v0.61&n;    19990329   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &lt;devfs_auto_unregister&gt;.&n;  v0.62&n;    19990330   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Don&squot;t return unregistred entries in &lt;devfs_find_handle&gt;.&n;&t;       Panic in &lt;devfs_unregister&gt; if entry unregistered.&n;    19990401   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Don&squot;t panic in &lt;devfs_auto_unregister&gt; for duplicates.&n;  v0.63&n;    19990402   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Don&squot;t unregister already unregistered entries in &lt;unregister&gt;.&n;  v0.64&n;    19990510   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Disable warning messages when unable to read partition table for&n;&t;       removable media.&n;  v0.65&n;    19990512   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Updated &lt;devfs_lookup&gt; for VFS change in 2.3.1-pre1.&n;&t;       Created &quot;oops-on-panic&quot; boot option.&n;&t;       Improved debugging in &lt;devfs_register&gt; and &lt;devfs_unregister&gt;.&n;  v0.66&n;    19990519   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added documentation for some functions.&n;    19990525   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed &quot;oops-on-panic&quot; boot option: now always Oops.&n;  v0.67&n;    19990531   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Improved debugging in &lt;devfs_register&gt;.&n;  v0.68&n;    19990604   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added &quot;diunlink&quot; and &quot;nokmod&quot; boot options.&n;&t;       Removed superfluous warning message in &lt;devfs_d_iput&gt;.&n;  v0.69&n;    19990611   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Took account of change to &lt;d_alloc_root&gt;.&n;  v0.70&n;    19990614   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created separate event queue for each mounted devfs.&n;&t;       Removed &lt;devfs_invalidate_dcache&gt;.&n;&t;       Created new ioctl()s.&n;&t;       Incremented devfsd protocol revision to 3.&n;&t;       Fixed bug when re-creating directories: contents were lost.&n;&t;       Block access to inodes until devfsd updates permissions.&n;    19990615   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Support 2.2.x kernels.&n;  v0.71&n;    19990623   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Switched to sending process uid/gid to devfsd.&n;&t;       Renamed &lt;call_kmod&gt; to &lt;try_modload&gt;.&n;&t;       Added DEVFSD_NOTIFY_LOOKUP event.&n;    19990624   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added DEVFSD_NOTIFY_CHANGE event.&n;&t;       Incremented devfsd protocol revision to 4.&n;  v0.72&n;    19990713   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Return EISDIR rather than EINVAL for read(2) on directories.&n;  v0.73&n;    19990809   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Changed &lt;devfs_setup&gt; to new __init scheme.&n;  v0.74&n;    19990901   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Changed remaining function declarations to new __init scheme.&n;  v0.75&n;    19991013   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &lt;devfs_get_info&gt;, &lt;devfs_set_info&gt;,&n;&t;       &lt;devfs_get_first_child&gt; and &lt;devfs_get_next_sibling&gt;.&n;&t;       Added &lt;&lt;dir&gt;&gt; parameter to &lt;devfs_register&gt;, &lt;devfs_mk_compat&gt;,&n;&t;       &lt;devfs_mk_dir&gt; and &lt;devfs_find_handle&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.76&n;    19991017   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Allow multiple unregistrations.&n;&t;       Work sponsored by SGI.&n;  v0.77&n;    19991026   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added major and minor number to devfsd protocol.&n;&t;       Incremented devfsd protocol revision to 5.&n;&t;       Work sponsored by SGI.&n;  v0.78&n;    19991030   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Support info pointer for all devfs entry types.&n;&t;       Added &lt;&lt;info&gt;&gt; parameter to &lt;devfs_mk_dir&gt; and&n;&t;       &lt;devfs_mk_symlink&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.79&n;    19991031   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Support &quot;../&quot; when searching devfs namespace.&n;&t;       Work sponsored by SGI.&n;  v0.80&n;    19991101   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &lt;devfs_get_unregister_slave&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.81&n;    19991103   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Exported &lt;devfs_get_parent&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.82&n;    19991104   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Removed unused &lt;devfs_set_symlink_destination&gt;.&n;    19991105   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Do not hide entries from devfsd or children.&n;&t;       Removed DEVFS_ FL_TTY_COMPAT flag.&n;&t;       Removed &quot;nottycompat&quot; boot option.&n;&t;       Removed &lt;devfs_mk_compat&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.83&n;    19991107   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added DEVFS_ FL_WAIT flag.&n;&t;       Work sponsored by SGI.&n;  v0.84&n;    19991107   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Support new &quot;disc&quot; naming scheme in &lt;get_removable_partition&gt;.&n;&t;       Allow NULL fops in &lt;devfs_register&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.85&n;    19991110   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fall back to major table if NULL fops given to &lt;devfs_register&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.86&n;    19991204   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Support fifos when unregistering.&n;&t;       Work sponsored by SGI.&n;  v0.87&n;    19991209   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed obsolete DEVFS_ FL_COMPAT and DEVFS_ FL_TOLERANT flags.&n;&t;       Work sponsored by SGI.&n;  v0.88&n;    19991214   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed kmod support.&n;&t;       Work sponsored by SGI.&n;  v0.89&n;    19991216   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Improved debugging in &lt;get_vfs_inode&gt;.&n;&t;       Ensure dentries created by devfsd will be cleaned up.&n;&t;       Work sponsored by SGI.&n;  v0.90&n;    19991223   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &lt;devfs_get_name&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.91&n;    20000203   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Ported to kernel 2.3.42.&n;&t;       Removed &lt;devfs_fill_file&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.92&n;    20000306   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added DEVFS_FL_NO_PERSISTENCE flag.&n;&t;       Removed unnecessary call to &lt;update_devfs_inode_from_entry&gt; in&n;&t;       &lt;devfs_readdir&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.93&n;    20000413   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Set inode-&gt;i_size to correct size for symlinks.&n;    20000414   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Only give lookup() method to directories to comply with new VFS&n;&t;       assumptions.&n;&t;       Work sponsored by SGI.&n;    20000415   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Remove unnecessary tests in symlink methods.&n;&t;       Don&squot;t kill existing block ops in &lt;devfs_read_inode&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.94&n;    20000424   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Don&squot;t create missing directories in &lt;devfs_find_handle&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.95&n;    20000430   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added CONFIG_DEVFS_MOUNT.&n;&t;       Work sponsored by SGI.&n;  v0.96&n;    20000608   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Disabled multi-mount capability (use VFS bindings instead).&n;&t;       Work sponsored by SGI.&n;  v0.97&n;    20000610   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Switched to FS_SINGLE to disable multi-mounts.&n;    20000612   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed module support.&n;&t;       Removed multi-mount code.&n;&t;       Removed compatibility macros: VFS has changed too much.&n;&t;       Work sponsored by SGI.&n;  v0.98&n;    20000614   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Merged devfs inode into devfs entry.&n;&t;       Work sponsored by SGI.&n;  v0.99&n;    20000619   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed dead code in &lt;devfs_register&gt; which used to call&n;&t;       &lt;free_dentries&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.100&n;    20000621   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Changed interface to &lt;devfs_register&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.101&n;    20000622   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Simplified interface to &lt;devfs_mk_symlink&gt; and &lt;devfs_mk_dir&gt;.&n;&t;       Simplified interface to &lt;devfs_find_handle&gt;.&n;&t;       Work sponsored by SGI.&n;  v0.102&n;*/
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/kdev_t.h&gt;
macro_line|#include &lt;linux/devfs_fs.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
DECL|macro|DEVFS_VERSION
mdefine_line|#define DEVFS_VERSION            &quot;0.102 (20000622)&quot;
DECL|macro|DEVFS_NAME
mdefine_line|#define DEVFS_NAME &quot;devfs&quot;
DECL|macro|INODE_TABLE_INC
mdefine_line|#define INODE_TABLE_INC 250
DECL|macro|FIRST_INODE
mdefine_line|#define FIRST_INODE 1
DECL|macro|STRING_LENGTH
mdefine_line|#define STRING_LENGTH 256
DECL|macro|MIN_DEVNUM
mdefine_line|#define MIN_DEVNUM 36864  /*  Use major numbers 144   */
DECL|macro|MAX_DEVNUM
mdefine_line|#define MAX_DEVNUM 61439  /*  through 239, inclusive  */
macro_line|#ifndef TRUE
DECL|macro|TRUE
macro_line|#  define TRUE 1
DECL|macro|FALSE
macro_line|#  define FALSE 0
macro_line|#endif
DECL|macro|IS_HIDDEN
mdefine_line|#define IS_HIDDEN(de) (( ((de)-&gt;hide &amp;&amp; !is_devfsd_or_child(fs_info)) || (!(de)-&gt;registered&amp;&amp; !(de)-&gt;show_unreg)))
DECL|macro|DEBUG_NONE
mdefine_line|#define DEBUG_NONE         0x00000
DECL|macro|DEBUG_MODULE_LOAD
mdefine_line|#define DEBUG_MODULE_LOAD  0x00001
DECL|macro|DEBUG_REGISTER
mdefine_line|#define DEBUG_REGISTER     0x00002
DECL|macro|DEBUG_UNREGISTER
mdefine_line|#define DEBUG_UNREGISTER   0x00004
DECL|macro|DEBUG_SET_FLAGS
mdefine_line|#define DEBUG_SET_FLAGS    0x00008
DECL|macro|DEBUG_S_PUT
mdefine_line|#define DEBUG_S_PUT        0x00010
DECL|macro|DEBUG_I_LOOKUP
mdefine_line|#define DEBUG_I_LOOKUP     0x00020
DECL|macro|DEBUG_I_CREATE
mdefine_line|#define DEBUG_I_CREATE     0x00040
DECL|macro|DEBUG_I_READ
mdefine_line|#define DEBUG_I_READ       0x00080
DECL|macro|DEBUG_I_WRITE
mdefine_line|#define DEBUG_I_WRITE      0x00100
DECL|macro|DEBUG_I_UNLINK
mdefine_line|#define DEBUG_I_UNLINK     0x00200
DECL|macro|DEBUG_I_RLINK
mdefine_line|#define DEBUG_I_RLINK      0x00400
DECL|macro|DEBUG_I_FLINK
mdefine_line|#define DEBUG_I_FLINK      0x00800
DECL|macro|DEBUG_I_MKNOD
mdefine_line|#define DEBUG_I_MKNOD      0x01000
DECL|macro|DEBUG_F_READDIR
mdefine_line|#define DEBUG_F_READDIR    0x02000
DECL|macro|DEBUG_D_DELETE
mdefine_line|#define DEBUG_D_DELETE     0x04000
DECL|macro|DEBUG_D_RELEASE
mdefine_line|#define DEBUG_D_RELEASE    0x08000
DECL|macro|DEBUG_D_IPUT
mdefine_line|#define DEBUG_D_IPUT       0x10000
DECL|macro|DEBUG_ALL
mdefine_line|#define DEBUG_ALL          (DEBUG_MODULE_LOAD | DEBUG_REGISTER | &bslash;&n;&t;&t;&t;    DEBUG_SET_FLAGS | DEBUG_I_LOOKUP |   &bslash;&n;&t;&t;&t;    DEBUG_I_UNLINK | DEBUG_I_MKNOD |     &bslash;&n;&t;&t;&t;    DEBUG_D_RELEASE | DEBUG_D_IPUT)
DECL|macro|DEBUG_DISABLED
mdefine_line|#define DEBUG_DISABLED     DEBUG_NONE
DECL|macro|OPTION_NONE
mdefine_line|#define OPTION_NONE             0x00
DECL|macro|OPTION_SHOW
mdefine_line|#define OPTION_SHOW             0x01
DECL|macro|OPTION_NOMOUNT
mdefine_line|#define OPTION_NOMOUNT          0x02
DECL|macro|OPTION_ONLY
mdefine_line|#define OPTION_ONLY             0x04
DECL|macro|OOPS
mdefine_line|#define OOPS(format, args...) {printk (format, ## args); &bslash;&n;                               printk (&quot;Forcing Oops&bslash;n&quot;); &bslash;&n;                               BUG();}
DECL|struct|directory_type
r_struct
id|directory_type
(brace
DECL|member|first
r_struct
id|devfs_entry
op_star
id|first
suffix:semicolon
DECL|member|last
r_struct
id|devfs_entry
op_star
id|last
suffix:semicolon
DECL|member|num_removable
r_int
r_int
id|num_removable
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|file_type
r_struct
id|file_type
(brace
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|device_type
r_struct
id|device_type
(brace
DECL|member|major
r_int
r_int
id|major
suffix:semicolon
DECL|member|minor
r_int
r_int
id|minor
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|fcb_type
r_struct
id|fcb_type
multiline_comment|/*  File, char, block type  */
(brace
DECL|member|default_uid
id|uid_t
id|default_uid
suffix:semicolon
DECL|member|default_gid
id|gid_t
id|default_gid
suffix:semicolon
DECL|member|ops
r_void
op_star
id|ops
suffix:semicolon
r_union
(brace
DECL|member|file
r_struct
id|file_type
id|file
suffix:semicolon
DECL|member|device
r_struct
id|device_type
id|device
suffix:semicolon
)brace
DECL|member|u
id|u
suffix:semicolon
DECL|member|auto_owner
r_int
r_char
id|auto_owner
suffix:colon
l_int|1
suffix:semicolon
DECL|member|aopen_notify
r_int
r_char
id|aopen_notify
suffix:colon
l_int|1
suffix:semicolon
DECL|member|removable
r_int
r_char
id|removable
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/*  Belongs in device_type, but save space   */
DECL|member|open
r_int
r_char
id|open
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/*  Not entirely correct                     */
)brace
suffix:semicolon
DECL|struct|symlink_type
r_struct
id|symlink_type
(brace
DECL|member|length
r_int
r_int
id|length
suffix:semicolon
multiline_comment|/*  Not including the NULL-termimator  */
DECL|member|linkname
r_char
op_star
id|linkname
suffix:semicolon
multiline_comment|/*  This is NULL-terminated            */
)brace
suffix:semicolon
DECL|struct|fifo_type
r_struct
id|fifo_type
(brace
DECL|member|uid
id|uid_t
id|uid
suffix:semicolon
DECL|member|gid
id|gid_t
id|gid
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|devfs_inode
r_struct
id|devfs_inode
multiline_comment|/*  This structure is for &quot;persistent&quot; inode storage  */
(brace
DECL|member|atime
id|time_t
id|atime
suffix:semicolon
DECL|member|mtime
id|time_t
id|mtime
suffix:semicolon
DECL|member|ctime
id|time_t
id|ctime
suffix:semicolon
DECL|member|ino
r_int
r_int
id|ino
suffix:semicolon
multiline_comment|/*  Inode number as seen in the VFS  */
DECL|member|dentry
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
DECL|member|mode
id|umode_t
id|mode
suffix:semicolon
DECL|member|uid
id|uid_t
id|uid
suffix:semicolon
DECL|member|gid
id|gid_t
id|gid
suffix:semicolon
DECL|member|nlink
id|nlink_t
id|nlink
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|devfs_entry
r_struct
id|devfs_entry
(brace
DECL|member|info
r_void
op_star
id|info
suffix:semicolon
r_union
(brace
DECL|member|dir
r_struct
id|directory_type
id|dir
suffix:semicolon
DECL|member|fcb
r_struct
id|fcb_type
id|fcb
suffix:semicolon
DECL|member|symlink
r_struct
id|symlink_type
id|symlink
suffix:semicolon
DECL|member|fifo
r_struct
id|fifo_type
id|fifo
suffix:semicolon
)brace
DECL|member|u
id|u
suffix:semicolon
DECL|member|prev
r_struct
id|devfs_entry
op_star
id|prev
suffix:semicolon
multiline_comment|/*  Previous entry in the parent directory  */
DECL|member|next
r_struct
id|devfs_entry
op_star
id|next
suffix:semicolon
multiline_comment|/*  Next entry in the parent directory      */
DECL|member|parent
r_struct
id|devfs_entry
op_star
id|parent
suffix:semicolon
multiline_comment|/*  The parent directory                    */
DECL|member|slave
r_struct
id|devfs_entry
op_star
id|slave
suffix:semicolon
multiline_comment|/*  Another entry to unregister             */
DECL|member|inode
r_struct
id|devfs_inode
id|inode
suffix:semicolon
DECL|member|mode
id|umode_t
id|mode
suffix:semicolon
DECL|member|namelen
r_int
r_int
id|namelen
suffix:semicolon
multiline_comment|/*  I think 64k+ filenames are a way off...  */
DECL|member|registered
r_int
r_char
id|registered
suffix:colon
l_int|1
suffix:semicolon
DECL|member|show_unreg
r_int
r_char
id|show_unreg
suffix:colon
l_int|1
suffix:semicolon
DECL|member|hide
r_int
r_char
id|hide
suffix:colon
l_int|1
suffix:semicolon
DECL|member|no_persistence
r_int
r_char
id|no_persistence
suffix:colon
l_int|1
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/*  This is just a dummy: the allocated array is&n;&t;&t;&t;&t; bigger. This is NULL-terminated  */
)brace
suffix:semicolon
multiline_comment|/*  The root of the device tree  */
DECL|variable|root_entry
r_static
r_struct
id|devfs_entry
op_star
id|root_entry
suffix:semicolon
DECL|struct|devfsd_buf_entry
r_struct
id|devfsd_buf_entry
(brace
DECL|member|data
r_void
op_star
id|data
suffix:semicolon
DECL|member|type
r_int
r_int
id|type
suffix:semicolon
DECL|member|mode
id|umode_t
id|mode
suffix:semicolon
DECL|member|uid
id|uid_t
id|uid
suffix:semicolon
DECL|member|gid
id|gid_t
id|gid
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|fs_info
r_struct
id|fs_info
multiline_comment|/*  This structure is for each mounted devfs  */
(brace
DECL|member|num_inodes
r_int
r_int
id|num_inodes
suffix:semicolon
multiline_comment|/*  Number of inodes created         */
DECL|member|table_size
r_int
r_int
id|table_size
suffix:semicolon
multiline_comment|/*  Size of the inode pointer table  */
DECL|member|table
r_struct
id|devfs_entry
op_star
op_star
id|table
suffix:semicolon
DECL|member|sb
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
DECL|member|devfsd_buffer
r_volatile
r_struct
id|devfsd_buf_entry
op_star
id|devfsd_buffer
suffix:semicolon
DECL|member|devfsd_buf_in
r_volatile
r_int
r_int
id|devfsd_buf_in
suffix:semicolon
DECL|member|devfsd_buf_out
r_volatile
r_int
r_int
id|devfsd_buf_out
suffix:semicolon
DECL|member|devfsd_sleeping
r_volatile
r_int
id|devfsd_sleeping
suffix:semicolon
DECL|member|devfsd_buffer_in_use
r_volatile
r_int
id|devfsd_buffer_in_use
suffix:semicolon
DECL|member|devfsd_task
r_volatile
r_struct
id|task_struct
op_star
id|devfsd_task
suffix:semicolon
DECL|member|devfsd_file
r_volatile
r_struct
id|file
op_star
id|devfsd_file
suffix:semicolon
DECL|member|devfsd_event_mask
r_volatile
r_int
r_int
id|devfsd_event_mask
suffix:semicolon
DECL|member|devfsd_overrun_count
id|atomic_t
id|devfsd_overrun_count
suffix:semicolon
DECL|member|devfsd_wait_queue
id|wait_queue_head_t
id|devfsd_wait_queue
suffix:semicolon
DECL|member|revalidate_wait_queue
id|wait_queue_head_t
id|revalidate_wait_queue
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|fs_info
r_static
r_struct
id|fs_info
id|fs_info
suffix:semicolon
DECL|variable|next_devnum_char
r_static
r_int
r_int
id|next_devnum_char
op_assign
id|MIN_DEVNUM
suffix:semicolon
DECL|variable|next_devnum_block
r_static
r_int
r_int
id|next_devnum_block
op_assign
id|MIN_DEVNUM
suffix:semicolon
DECL|variable|devfsd_buf_size
r_static
r_const
r_int
id|devfsd_buf_size
op_assign
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_struct
id|devfsd_buf_entry
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
DECL|variable|__initdata
r_static
r_int
r_int
id|devfs_debug_init
id|__initdata
op_assign
id|DEBUG_NONE
suffix:semicolon
DECL|variable|devfs_debug
r_static
r_int
r_int
id|devfs_debug
op_assign
id|DEBUG_NONE
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_DEVFS_MOUNT
DECL|variable|boot_options
r_static
r_int
r_int
id|boot_options
op_assign
id|OPTION_NONE
suffix:semicolon
macro_line|#else
DECL|variable|boot_options
r_static
r_int
r_int
id|boot_options
op_assign
id|OPTION_NOMOUNT
suffix:semicolon
macro_line|#endif
multiline_comment|/*  Forward function declarations  */
r_static
r_struct
id|devfs_entry
op_star
id|search_for_entry
(paren
r_struct
id|devfs_entry
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|namelen
comma
r_int
id|mkdir
comma
r_int
id|mkfile
comma
r_int
op_star
id|is_new
comma
r_int
id|traverse_symlink
)paren
suffix:semicolon
r_static
id|ssize_t
id|devfsd_read
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
r_static
r_int
id|devfsd_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|devfsd_close
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
multiline_comment|/*  Devfs daemon file operations  */
DECL|variable|devfsd_fops
r_static
r_struct
id|file_operations
id|devfsd_fops
op_assign
(brace
id|read
suffix:colon
id|devfsd_read
comma
id|ioctl
suffix:colon
id|devfsd_ioctl
comma
id|release
suffix:colon
id|devfsd_close
comma
)brace
suffix:semicolon
multiline_comment|/*  Support functions follow  */
multiline_comment|/**&n; *&t;search_for_entry_in_dir - Search for a devfs entry inside another devfs entry.&n; *&t;@parent:  The parent devfs entry.&n; *&t;@name:  The name of the entry.&n; *&t;@namelen:  The number of characters in @name.&n; *&t;@traverse_symlink:  If %TRUE then the entry is traversed if it is a symlink.&n; *&n; *  Search for a devfs entry inside another devfs entry and returns a pointer&n; *   to the entry on success, else %NULL.&n; */
DECL|function|search_for_entry_in_dir
r_static
r_struct
id|devfs_entry
op_star
id|search_for_entry_in_dir
(paren
r_struct
id|devfs_entry
op_star
id|parent
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|namelen
comma
r_int
id|traverse_symlink
)paren
(brace
r_struct
id|devfs_entry
op_star
id|curr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
(paren
id|parent-&gt;mode
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: entry is not a directory&bslash;n&quot;
comma
id|DEVFS_NAME
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|curr
op_assign
id|parent-&gt;u.dir.first
suffix:semicolon
id|curr
op_ne
l_int|NULL
suffix:semicolon
id|curr
op_assign
id|curr-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|curr-&gt;namelen
op_ne
id|namelen
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
(paren
id|curr-&gt;name
comma
id|name
comma
id|namelen
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/*  Not found: try the next one  */
)brace
r_if
c_cond
(paren
id|curr
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISLNK
(paren
id|curr-&gt;mode
)paren
op_logical_or
op_logical_neg
id|traverse_symlink
)paren
r_return
id|curr
suffix:semicolon
multiline_comment|/*  Need to follow the link: this is a stack chomper  */
r_return
id|search_for_entry
(paren
id|parent
comma
id|curr-&gt;u.symlink.linkname
comma
id|curr-&gt;u.symlink.length
comma
id|FALSE
comma
id|FALSE
comma
l_int|NULL
comma
id|TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function search_for_entry_in_dir  */
DECL|function|create_entry
r_static
r_struct
id|devfs_entry
op_star
id|create_entry
(paren
r_struct
id|devfs_entry
op_star
id|parent
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|namelen
)paren
(brace
r_struct
id|devfs_entry
op_star
r_new
comma
op_star
op_star
id|table
suffix:semicolon
multiline_comment|/*  First ensure table size is enough  */
r_if
c_cond
(paren
id|fs_info.num_inodes
op_ge
id|fs_info.table_size
)paren
(brace
r_if
c_cond
(paren
(paren
id|table
op_assign
id|kmalloc
(paren
r_sizeof
op_star
id|table
op_star
(paren
id|fs_info.table_size
op_plus
id|INODE_TABLE_INC
)paren
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|fs_info.table_size
op_add_assign
id|INODE_TABLE_INC
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_I_CREATE
)paren
id|printk
(paren
l_string|&quot;%s: create_entry(): grew inode table to: %u entries&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|fs_info.table_size
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|fs_info.table
)paren
(brace
id|memcpy
(paren
id|table
comma
id|fs_info.table
comma
r_sizeof
op_star
id|table
op_star
id|fs_info.num_inodes
)paren
suffix:semicolon
id|kfree
(paren
id|fs_info.table
)paren
suffix:semicolon
)brace
id|fs_info.table
op_assign
id|table
suffix:semicolon
)brace
r_if
c_cond
(paren
id|name
op_logical_and
(paren
id|namelen
OL
l_int|1
)paren
)paren
id|namelen
op_assign
id|strlen
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_new
op_assign
id|kmalloc
(paren
r_sizeof
op_star
r_new
op_plus
id|namelen
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*  Magic: this will set the ctime to zero, thus subsequent lookups will&n;&t;trigger the call to &lt;update_devfs_inode_from_entry&gt;  */
id|memset
(paren
r_new
comma
l_int|0
comma
r_sizeof
op_star
r_new
op_plus
id|namelen
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|parent
op_assign
id|parent
suffix:semicolon
r_if
c_cond
(paren
id|name
)paren
id|memcpy
(paren
r_new
op_member_access_from_pointer
id|name
comma
id|name
comma
id|namelen
)paren
suffix:semicolon
r_new
op_member_access_from_pointer
id|namelen
op_assign
id|namelen
suffix:semicolon
r_new
op_member_access_from_pointer
id|inode.ino
op_assign
id|fs_info.num_inodes
op_plus
id|FIRST_INODE
suffix:semicolon
r_new
op_member_access_from_pointer
id|inode.nlink
op_assign
l_int|1
suffix:semicolon
id|fs_info.table
(braket
id|fs_info.num_inodes
)braket
op_assign
r_new
suffix:semicolon
op_increment
id|fs_info.num_inodes
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_eq
l_int|NULL
)paren
r_return
r_new
suffix:semicolon
r_new
op_member_access_from_pointer
id|prev
op_assign
id|parent-&gt;u.dir.last
suffix:semicolon
multiline_comment|/*  Insert into the parent directory&squot;s list of children  */
r_if
c_cond
(paren
id|parent-&gt;u.dir.first
op_eq
l_int|NULL
)paren
id|parent-&gt;u.dir.first
op_assign
r_new
suffix:semicolon
r_else
id|parent-&gt;u.dir.last-&gt;next
op_assign
r_new
suffix:semicolon
id|parent-&gt;u.dir.last
op_assign
r_new
suffix:semicolon
r_return
r_new
suffix:semicolon
)brace
multiline_comment|/*  End Function create_entry  */
DECL|function|update_devfs_inode_from_entry
r_static
r_void
id|update_devfs_inode_from_entry
(paren
r_struct
id|devfs_entry
op_star
id|de
)paren
(brace
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|de-&gt;mode
)paren
)paren
(brace
id|de-&gt;inode.mode
op_assign
id|S_IFDIR
op_or
id|S_IRWXU
op_or
id|S_IRUGO
op_or
id|S_IXUGO
suffix:semicolon
id|de-&gt;inode.uid
op_assign
l_int|0
suffix:semicolon
id|de-&gt;inode.gid
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
(paren
id|de-&gt;mode
)paren
)paren
(brace
id|de-&gt;inode.mode
op_assign
id|S_IFLNK
op_or
id|S_IRUGO
op_or
id|S_IXUGO
suffix:semicolon
id|de-&gt;inode.uid
op_assign
l_int|0
suffix:semicolon
id|de-&gt;inode.gid
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISFIFO
(paren
id|de-&gt;mode
)paren
)paren
(brace
id|de-&gt;inode.mode
op_assign
id|de-&gt;mode
suffix:semicolon
id|de-&gt;inode.uid
op_assign
id|de-&gt;u.fifo.uid
suffix:semicolon
id|de-&gt;inode.gid
op_assign
id|de-&gt;u.fifo.gid
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|de-&gt;u.fcb.auto_owner
)paren
id|de-&gt;inode.mode
op_assign
(paren
id|de-&gt;mode
op_amp
op_complement
id|S_IALLUGO
)paren
op_or
id|S_IRUGO
op_or
id|S_IWUGO
suffix:semicolon
r_else
id|de-&gt;inode.mode
op_assign
id|de-&gt;mode
suffix:semicolon
id|de-&gt;inode.uid
op_assign
id|de-&gt;u.fcb.default_uid
suffix:semicolon
id|de-&gt;inode.gid
op_assign
id|de-&gt;u.fcb.default_gid
suffix:semicolon
)brace
)brace
multiline_comment|/*  End Function update_devfs_inode_from_entry  */
multiline_comment|/**&n; *&t;get_root_entry - Get the root devfs entry.&n; *&n; *&t;Returns the root devfs entry on success, else %NULL.&n; */
DECL|function|get_root_entry
r_static
r_struct
id|devfs_entry
op_star
id|get_root_entry
(paren
r_void
)paren
(brace
r_struct
id|devfs_entry
op_star
r_new
suffix:semicolon
multiline_comment|/*  Always ensure the root is created  */
r_if
c_cond
(paren
id|root_entry
op_ne
l_int|NULL
)paren
r_return
id|root_entry
suffix:semicolon
r_if
c_cond
(paren
(paren
id|root_entry
op_assign
id|create_entry
(paren
l_int|NULL
comma
l_int|NULL
comma
l_int|0
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|root_entry-&gt;registered
op_assign
id|TRUE
suffix:semicolon
id|root_entry-&gt;mode
op_assign
id|S_IFDIR
suffix:semicolon
multiline_comment|/*  Force an inode update, because lookup() is never done for the root  */
id|update_devfs_inode_from_entry
(paren
id|root_entry
)paren
suffix:semicolon
multiline_comment|/*  And create the entry for &quot;.devfsd&quot;  */
r_if
c_cond
(paren
(paren
r_new
op_assign
id|create_entry
(paren
id|root_entry
comma
l_string|&quot;.devfsd&quot;
comma
l_int|0
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_new
op_member_access_from_pointer
id|registered
op_assign
id|TRUE
suffix:semicolon
r_new
op_member_access_from_pointer
id|u.fcb.u.device.major
op_assign
id|next_devnum_char
op_rshift
l_int|8
suffix:semicolon
r_new
op_member_access_from_pointer
id|u.fcb.u.device.minor
op_assign
id|next_devnum_char
op_amp
l_int|0xff
suffix:semicolon
op_increment
id|next_devnum_char
suffix:semicolon
r_new
op_member_access_from_pointer
id|mode
op_assign
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
suffix:semicolon
r_new
op_member_access_from_pointer
id|u.fcb.default_uid
op_assign
l_int|0
suffix:semicolon
r_new
op_member_access_from_pointer
id|u.fcb.default_gid
op_assign
l_int|0
suffix:semicolon
r_new
op_member_access_from_pointer
id|u.fcb.ops
op_assign
op_amp
id|devfsd_fops
suffix:semicolon
r_return
id|root_entry
suffix:semicolon
)brace
multiline_comment|/*  End Function get_root_entry  */
multiline_comment|/**&n; *&t;search_for_entry - Search for an entry in the devfs tree.&n; *&t;@dir: The parent directory to search from. If this is %NULL the root is used&n; *&t;@name: The name of the entry.&n; *&t;@namelen: The number of characters in @name.&n; *&t;@mkdir: If %TRUE intermediate directories are created as needed.&n; *&t;@mkfile: If %TRUE the file entry is created if it doesn&squot;t exist.&n; *&t;@is_new: If the returned entry was newly made, %TRUE is written here. If&n; * &t;&t;this is %NULL nothing is written here.&n; *&t;@traverse_symlink: If %TRUE then symbolic links are traversed.&n; *&n; *&t;If the entry is created, then it will be in the unregistered state.&n; *&t;Returns a pointer to the entry on success, else %NULL.&n; */
DECL|function|search_for_entry
r_static
r_struct
id|devfs_entry
op_star
id|search_for_entry
(paren
r_struct
id|devfs_entry
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|namelen
comma
r_int
id|mkdir
comma
r_int
id|mkfile
comma
r_int
op_star
id|is_new
comma
r_int
id|traverse_symlink
)paren
(brace
r_int
id|len
suffix:semicolon
r_const
r_char
op_star
id|subname
comma
op_star
id|stop
comma
op_star
id|ptr
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|is_new
)paren
op_star
id|is_new
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
l_int|NULL
)paren
id|dir
op_assign
id|get_root_entry
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*  Extract one filename component  */
id|subname
op_assign
id|name
suffix:semicolon
id|stop
op_assign
id|name
op_plus
id|namelen
suffix:semicolon
r_while
c_loop
(paren
id|subname
OL
id|stop
)paren
(brace
multiline_comment|/*  Search for a possible &squot;/&squot;  */
r_for
c_loop
(paren
id|ptr
op_assign
id|subname
suffix:semicolon
(paren
id|ptr
OL
id|stop
)paren
op_logical_and
(paren
op_star
id|ptr
op_ne
l_char|&squot;/&squot;
)paren
suffix:semicolon
op_increment
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_ge
id|stop
)paren
(brace
multiline_comment|/*  Look for trailing component  */
id|len
op_assign
id|stop
op_minus
id|subname
suffix:semicolon
id|entry
op_assign
id|search_for_entry_in_dir
(paren
id|dir
comma
id|subname
comma
id|len
comma
id|traverse_symlink
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_ne
l_int|NULL
)paren
r_return
id|entry
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mkfile
)paren
r_return
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|create_entry
(paren
id|dir
comma
id|subname
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_logical_and
id|is_new
)paren
op_star
id|is_new
op_assign
id|TRUE
suffix:semicolon
r_return
id|entry
suffix:semicolon
)brace
multiline_comment|/*  Found &squot;/&squot;: search for directory  */
r_if
c_cond
(paren
id|strncmp
(paren
id|subname
comma
l_string|&quot;../&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*  Going up  */
id|dir
op_assign
id|dir-&gt;parent
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*  Cannot escape from devfs  */
id|subname
op_add_assign
l_int|3
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|len
op_assign
id|ptr
op_minus
id|subname
suffix:semicolon
id|entry
op_assign
id|search_for_entry_in_dir
(paren
id|dir
comma
id|subname
comma
id|len
comma
id|traverse_symlink
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry
op_logical_and
op_logical_neg
id|mkdir
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*  Make it  */
r_if
c_cond
(paren
(paren
id|entry
op_assign
id|create_entry
(paren
id|dir
comma
id|subname
comma
id|len
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|entry-&gt;mode
op_assign
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
op_or
id|S_IWUSR
suffix:semicolon
r_if
c_cond
(paren
id|is_new
)paren
op_star
id|is_new
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
(paren
id|entry-&gt;mode
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: existing non-directory entry&bslash;n&quot;
comma
id|DEVFS_NAME
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*  Ensure an unregistered entry is re-registered and visible  */
id|entry-&gt;registered
op_assign
id|TRUE
suffix:semicolon
id|entry-&gt;hide
op_assign
id|FALSE
suffix:semicolon
id|subname
op_assign
id|ptr
op_plus
l_int|1
suffix:semicolon
id|dir
op_assign
id|entry
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*  End Function search_for_entry  */
multiline_comment|/**&n; *&t;find_by_dev - Find a devfs entry in a directory.&n; *&t;@dir: The directory where to search&n; *&t;@major: The major number to search for.&n; *&t;@minor: The minor number to search for.&n; *&t;@type: The type of special file to search for. This may be either&n; *&t;&t;%DEVFS_SPECIAL_CHR or %DEVFS_SPECIAL_BLK.&n; *&n; *&t;Returns the devfs_entry pointer on success, else %NULL.&n; */
DECL|function|find_by_dev
r_static
r_struct
id|devfs_entry
op_star
id|find_by_dev
(paren
r_struct
id|devfs_entry
op_star
id|dir
comma
r_int
r_int
id|major
comma
r_int
r_int
id|minor
comma
r_char
id|type
)paren
(brace
r_struct
id|devfs_entry
op_star
id|entry
comma
op_star
id|de
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
(paren
id|dir-&gt;mode
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: find_by_dev(): not a directory&bslash;n&quot;
comma
id|DEVFS_NAME
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*  First search files in this directory  */
r_for
c_loop
(paren
id|entry
op_assign
id|dir-&gt;u.dir.first
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|S_ISCHR
(paren
id|entry-&gt;mode
)paren
op_logical_and
op_logical_neg
id|S_ISBLK
(paren
id|entry-&gt;mode
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
(paren
id|entry-&gt;mode
)paren
op_logical_and
(paren
id|type
op_ne
id|DEVFS_SPECIAL_CHR
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|S_ISBLK
(paren
id|entry-&gt;mode
)paren
op_logical_and
(paren
id|type
op_ne
id|DEVFS_SPECIAL_BLK
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|entry-&gt;u.fcb.u.device.major
op_eq
id|major
)paren
op_logical_and
(paren
id|entry-&gt;u.fcb.u.device.minor
op_eq
id|minor
)paren
)paren
r_return
id|entry
suffix:semicolon
multiline_comment|/*  Not found: try the next one  */
)brace
multiline_comment|/*  Now recursively search the subdirectories: this is a stack chomper  */
r_for
c_loop
(paren
id|entry
op_assign
id|dir-&gt;u.dir.first
suffix:semicolon
id|entry
op_ne
l_int|NULL
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
(paren
id|entry-&gt;mode
)paren
)paren
r_continue
suffix:semicolon
id|de
op_assign
id|find_by_dev
(paren
id|entry
comma
id|major
comma
id|minor
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
)paren
r_return
id|de
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*  End Function find_by_dev  */
multiline_comment|/**&n; *&t;find_entry - Find a devfs entry.&n; *&t;@dir: The handle to the parent devfs directory entry. If this is %NULL the&n; *&t;&t;name is relative to the root of the devfs.&n; *&t;@name: The name of the entry. This is ignored if @handle is not %NULL.&n; *&t;@namelen: The number of characters in @name, not including a %NULL&n; *&t;&t;terminator. If this is 0, then @name must be %NULL-terminated and the&n; *&t;&t;length is computed internally.&n; *&t;@major: The major number. This is used if @handle and @name are %NULL.&n; *&t;@minor: The minor number. This is used if @handle and @name are %NULL.&n; *&t;&t;NOTE: If @major and @minor are both 0, searching by major and minor&n; *&t;&t;numbers is disabled.&n; *&t;@type: The type of special file to search for. This may be either&n; *&t;&t;%DEVFS_SPECIAL_CHR or %DEVFS_SPECIAL_BLK.&n; *&t;@traverse_symlink: If %TRUE then symbolic links are traversed.&n; *&n; *&t;FIXME: What the hell is @handle? - ch&n; *&t;Returns the devfs_entry pointer on success, else %NULL.&n; */
DECL|function|find_entry
r_static
r_struct
id|devfs_entry
op_star
id|find_entry
(paren
id|devfs_handle_t
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|namelen
comma
r_int
r_int
id|major
comma
r_int
r_int
id|minor
comma
r_char
id|type
comma
r_int
id|traverse_symlink
)paren
(brace
r_struct
id|devfs_entry
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
id|name
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|namelen
OL
l_int|1
)paren
id|namelen
op_assign
id|strlen
(paren
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;/&squot;
)paren
(brace
multiline_comment|/*  Skip leading pathname component  */
r_if
c_cond
(paren
id|namelen
OL
l_int|2
)paren
(brace
id|printk
(paren
l_string|&quot;%s: find_entry(%s): too short&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
op_increment
id|name
comma
op_decrement
id|namelen
suffix:semicolon
(paren
op_star
id|name
op_ne
l_char|&squot;/&squot;
)paren
op_logical_and
(paren
id|namelen
OG
l_int|0
)paren
suffix:semicolon
op_increment
id|name
comma
op_decrement
id|namelen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|namelen
OL
l_int|2
)paren
(brace
id|printk
(paren
l_string|&quot;%s: find_entry(%s): too short&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
op_increment
id|name
suffix:semicolon
op_decrement
id|namelen
suffix:semicolon
)brace
id|entry
op_assign
id|search_for_entry
(paren
id|dir
comma
id|name
comma
id|namelen
comma
id|FALSE
comma
id|FALSE
comma
l_int|NULL
comma
id|traverse_symlink
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry
op_ne
l_int|NULL
)paren
r_return
id|entry
suffix:semicolon
)brace
multiline_comment|/*  Have to search by major and minor: slow  */
r_if
c_cond
(paren
(paren
id|major
op_eq
l_int|0
)paren
op_logical_and
(paren
id|minor
op_eq
l_int|0
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|find_by_dev
(paren
id|root_entry
comma
id|major
comma
id|minor
comma
id|type
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function find_entry  */
DECL|function|get_devfs_entry_from_vfs_inode
r_static
r_struct
id|devfs_entry
op_star
id|get_devfs_entry_from_vfs_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|fs_info
op_star
id|fs_info
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_ino
OL
id|FIRST_INODE
)paren
r_return
l_int|NULL
suffix:semicolon
id|fs_info
op_assign
id|inode-&gt;i_sb-&gt;u.generic_sbp
suffix:semicolon
r_if
c_cond
(paren
id|fs_info
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_ino
op_minus
id|FIRST_INODE
op_ge
id|fs_info-&gt;num_inodes
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|fs_info-&gt;table
(braket
id|inode-&gt;i_ino
op_minus
id|FIRST_INODE
)braket
suffix:semicolon
)brace
multiline_comment|/*  End Function get_devfs_entry_from_vfs_inode  */
multiline_comment|/**&n; *&t;free_dentries - Free the dentries for a device entry and invalidate inodes.&n; *&t;@de: The entry.&n; */
DECL|function|free_dentries
r_static
r_void
id|free_dentries
(paren
r_struct
id|devfs_entry
op_star
id|de
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
id|dentry
op_assign
id|de-&gt;inode.dentry
suffix:semicolon
r_if
c_cond
(paren
id|dentry
op_ne
l_int|NULL
)paren
(brace
id|dget_locked
(paren
id|dentry
)paren
suffix:semicolon
id|de-&gt;inode.dentry
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
multiline_comment|/*  Forcefully remove the inode  */
r_if
c_cond
(paren
id|dentry-&gt;d_inode
op_ne
l_int|NULL
)paren
id|dentry-&gt;d_inode-&gt;i_nlink
op_assign
l_int|0
suffix:semicolon
id|d_drop
(paren
id|dentry
)paren
suffix:semicolon
id|dput
(paren
id|dentry
)paren
suffix:semicolon
)brace
r_else
id|spin_unlock
c_func
(paren
op_amp
id|dcache_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function free_dentries  */
multiline_comment|/**&n; *&t;is_devfsd_or_child - Test if the current process is devfsd or one of its children.&n; *&t;@fs_info: The filesystem information.&n; *&n; *&t;Returns %TRUE if devfsd or child, else %FALSE.&n; */
DECL|function|is_devfsd_or_child
r_static
r_int
id|is_devfsd_or_child
(paren
r_struct
id|fs_info
op_star
id|fs_info
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|current
suffix:semicolon
id|p
op_ne
op_amp
id|init_task
suffix:semicolon
id|p
op_assign
id|p-&gt;p_opptr
)paren
(brace
r_if
c_cond
(paren
id|p
op_eq
id|fs_info-&gt;devfsd_task
)paren
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function is_devfsd_or_child  */
multiline_comment|/**&n; *&t;devfsd_queue_empty - Test if devfsd has work pending in its event queue.&n; *&t;@fs_info: The filesystem information.&n; *&n; *&t;Returns %TRUE if the queue is empty, else %FALSE.&n; */
DECL|function|devfsd_queue_empty
r_static
r_inline
r_int
id|devfsd_queue_empty
(paren
r_struct
id|fs_info
op_star
id|fs_info
)paren
(brace
r_return
(paren
id|fs_info-&gt;devfsd_buf_out
op_eq
id|fs_info-&gt;devfsd_buf_in
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
suffix:semicolon
)brace
multiline_comment|/*  End Function devfsd_queue_empty  */
multiline_comment|/**&n; *&t;wait_for_devfsd_finished - Wait for devfsd to finish processing its event queue.&n; *&t;@fs_info: The filesystem information.&n; *&n; *&t;Returns %TRUE if no more waiting will be required, else %FALSE.&n; */
DECL|function|wait_for_devfsd_finished
r_static
r_int
id|wait_for_devfsd_finished
(paren
r_struct
id|fs_info
op_star
id|fs_info
)paren
(brace
id|DECLARE_WAITQUEUE
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_task
op_eq
l_int|NULL
)paren
r_return
(paren
id|TRUE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfsd_queue_empty
(paren
id|fs_info
)paren
op_logical_and
id|fs_info-&gt;devfsd_sleeping
)paren
r_return
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|is_devfsd_or_child
(paren
id|fs_info
)paren
)paren
r_return
(paren
id|FALSE
)paren
suffix:semicolon
id|add_wait_queue
(paren
op_amp
id|fs_info-&gt;revalidate_wait_queue
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devfsd_queue_empty
(paren
id|fs_info
)paren
op_logical_or
op_logical_neg
id|fs_info-&gt;devfsd_sleeping
)paren
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_task
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
(paren
op_amp
id|fs_info-&gt;revalidate_wait_queue
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function wait_for_devfsd_finished  */
multiline_comment|/**&n; *&t;devfsd_notify_one - Notify a single devfsd daemon of a change.&n; *&t;@data: Data to be passed.&n; *&t;@type: The type of change.&n; *&t;@mode: The mode of the entry.&n; *&t;@uid: The user ID.&n; *&t;@gid: The group ID.&n; *&t;@fs_info: The filesystem info.&n; *&n; *&t;Returns %TRUE if an event was queued and devfsd woken up, else %FALSE.&n; */
DECL|function|devfsd_notify_one
r_static
r_int
id|devfsd_notify_one
(paren
r_void
op_star
id|data
comma
r_int
r_int
id|type
comma
id|umode_t
id|mode
comma
id|uid_t
id|uid
comma
id|gid_t
id|gid
comma
r_struct
id|fs_info
op_star
id|fs_info
)paren
(brace
r_int
r_int
id|next_pos
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|devfsd_buf_entry
op_star
id|entry
suffix:semicolon
r_static
id|spinlock_t
id|lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|fs_info-&gt;devfsd_event_mask
op_amp
(paren
l_int|1
op_lshift
id|type
)paren
)paren
)paren
r_return
(paren
id|FALSE
)paren
suffix:semicolon
id|next_pos
op_assign
id|fs_info-&gt;devfsd_buf_in
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|next_pos
op_ge
id|devfsd_buf_size
)paren
id|next_pos
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|next_pos
op_eq
id|fs_info-&gt;devfsd_buf_out
)paren
(brace
multiline_comment|/*  Running up the arse of the reader: drop it  */
id|atomic_inc
(paren
op_amp
id|fs_info-&gt;devfsd_overrun_count
)paren
suffix:semicolon
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
(paren
op_amp
id|lock
comma
id|flags
)paren
suffix:semicolon
id|fs_info-&gt;devfsd_buffer_in_use
op_assign
id|TRUE
suffix:semicolon
id|next_pos
op_assign
id|fs_info-&gt;devfsd_buf_in
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|next_pos
op_ge
id|devfsd_buf_size
)paren
id|next_pos
op_assign
l_int|0
suffix:semicolon
id|entry
op_assign
(paren
r_struct
id|devfsd_buf_entry
op_star
)paren
id|fs_info-&gt;devfsd_buffer
op_plus
id|fs_info-&gt;devfsd_buf_in
suffix:semicolon
id|entry-&gt;data
op_assign
id|data
suffix:semicolon
id|entry-&gt;type
op_assign
id|type
suffix:semicolon
id|entry-&gt;mode
op_assign
id|mode
suffix:semicolon
id|entry-&gt;uid
op_assign
id|uid
suffix:semicolon
id|entry-&gt;gid
op_assign
id|gid
suffix:semicolon
id|fs_info-&gt;devfsd_buf_in
op_assign
id|next_pos
suffix:semicolon
id|fs_info-&gt;devfsd_buffer_in_use
op_assign
id|FALSE
suffix:semicolon
id|spin_unlock_irqrestore
(paren
op_amp
id|lock
comma
id|flags
)paren
suffix:semicolon
id|wake_up_interruptible
(paren
op_amp
id|fs_info-&gt;devfsd_wait_queue
)paren
suffix:semicolon
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfsd_notify_one  */
multiline_comment|/**&n; *&t;devfsd_notify - Notify all devfsd daemons of a change.&n; *&t;@de: The devfs entry that has changed.&n; *&t;@type: The type of change event.&n; *&t;@wait: If TRUE, the functions waits for all daemons to finish processing&n; *&t;&t;the event.&n; */
DECL|function|devfsd_notify
r_static
r_void
id|devfsd_notify
(paren
r_struct
id|devfs_entry
op_star
id|de
comma
r_int
r_int
id|type
comma
r_int
id|wait
)paren
(brace
r_if
c_cond
(paren
id|devfsd_notify_one
(paren
id|de
comma
id|type
comma
id|de-&gt;mode
comma
id|current-&gt;euid
comma
id|current-&gt;egid
comma
op_amp
id|fs_info
)paren
op_logical_and
id|wait
)paren
id|wait_for_devfsd_finished
(paren
op_amp
id|fs_info
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfsd_notify  */
multiline_comment|/**&n; *&t;devfs_register - Register a device entry.&n; *&t;@dir: The handle to the parent devfs directory entry. If this is %NULL the&n; *&t;&t;new name is relative to the root of the devfs.&n; *&t;@name: The name of the entry.&n; *&t;@flags: A set of bitwise-ORed flags (DEVFS_FL_*).&n; *&t;@major: The major number. Not needed for regular files.&n; *&t;@minor: The minor number. Not needed for regular files.&n; *&t;@mode: The default file mode.&n; *&t;@ops: The &amp;file_operations or &amp;block_device_operations structure.&n; *&t;&t;This must not be externally deallocated.&n; *&t;@info: An arbitrary pointer which will be written to the @private_data&n; *&t;&t;field of the &amp;file structure passed to the device driver. You can set&n; *&t;&t;this to whatever you like, and change it once the file is opened (the next&n; *&t;&t;file opened will not see this change).&n; *&n; *&t;Returns a handle which may later be used in a call to devfs_unregister().&n; *&t;On failure %NULL is returned.&n; */
DECL|function|devfs_register
id|devfs_handle_t
id|devfs_register
(paren
id|devfs_handle_t
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|flags
comma
r_int
r_int
id|major
comma
r_int
r_int
id|minor
comma
id|umode_t
id|mode
comma
r_void
op_star
id|ops
comma
r_void
op_star
id|info
)paren
(brace
r_int
id|is_new
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
r_if
c_cond
(paren
id|name
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;%s: devfs_register(): NULL name pointer&bslash;n&quot;
comma
id|DEVFS_NAME
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ops
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|S_ISBLK
(paren
id|mode
)paren
)paren
id|ops
op_assign
(paren
r_void
op_star
)paren
id|get_blkfops
(paren
id|major
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ops
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;%s: devfs_register(%s): NULL ops pointer&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;%s: devfs_register(%s): NULL ops, got %p from major table&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|name
comma
id|ops
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|mode
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: devfs_register(%s): creating directories is not allowed&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISLNK
(paren
id|mode
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: devfs_register(%s): creating symlinks is not allowed&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISCHR
(paren
id|mode
)paren
op_logical_and
(paren
id|flags
op_amp
id|DEVFS_FL_AUTO_DEVNUM
)paren
)paren
(brace
r_if
c_cond
(paren
id|next_devnum_char
op_ge
id|MAX_DEVNUM
)paren
(brace
id|printk
(paren
l_string|&quot;%s: devfs_register(%s): exhausted char device numbers&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|major
op_assign
id|next_devnum_char
op_rshift
l_int|8
suffix:semicolon
id|minor
op_assign
id|next_devnum_char
op_amp
l_int|0xff
suffix:semicolon
op_increment
id|next_devnum_char
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISBLK
(paren
id|mode
)paren
op_logical_and
(paren
id|flags
op_amp
id|DEVFS_FL_AUTO_DEVNUM
)paren
)paren
(brace
r_if
c_cond
(paren
id|next_devnum_block
op_ge
id|MAX_DEVNUM
)paren
(brace
id|printk
(paren
l_string|&quot;%s: devfs_register(%s): exhausted block device numbers&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|major
op_assign
id|next_devnum_block
op_rshift
l_int|8
suffix:semicolon
id|minor
op_assign
id|next_devnum_block
op_amp
l_int|0xff
suffix:semicolon
op_increment
id|next_devnum_block
suffix:semicolon
)brace
id|de
op_assign
id|search_for_entry
(paren
id|dir
comma
id|name
comma
id|strlen
(paren
id|name
)paren
comma
id|TRUE
comma
id|TRUE
comma
op_amp
id|is_new
comma
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;%s: devfs_register(): could not create entry: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_REGISTER
)paren
id|printk
(paren
l_string|&quot;%s: devfs_register(%s): de: %p %s&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|name
comma
id|de
comma
id|is_new
ques
c_cond
l_string|&quot;new&quot;
suffix:colon
l_string|&quot;existing&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|is_new
)paren
(brace
multiline_comment|/*  Existing entry  */
r_if
c_cond
(paren
op_logical_neg
id|S_ISCHR
(paren
id|de-&gt;mode
)paren
op_logical_and
op_logical_neg
id|S_ISBLK
(paren
id|de-&gt;mode
)paren
op_logical_and
op_logical_neg
id|S_ISREG
(paren
id|de-&gt;mode
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: devfs_register(): existing non-device/file entry: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|de-&gt;registered
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: devfs_register(): device already registered: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
id|de-&gt;registered
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
(paren
id|mode
)paren
op_logical_or
id|S_ISBLK
(paren
id|mode
)paren
)paren
(brace
id|de-&gt;u.fcb.u.device.major
op_assign
id|major
suffix:semicolon
id|de-&gt;u.fcb.u.device.minor
op_assign
id|minor
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISREG
(paren
id|mode
)paren
)paren
id|de-&gt;u.fcb.u.file.size
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|printk
(paren
l_string|&quot;%s: devfs_register(): illegal mode: %x&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|mode
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|de-&gt;info
op_assign
id|info
suffix:semicolon
id|de-&gt;mode
op_assign
id|mode
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|DEVFS_FL_CURRENT_OWNER
)paren
(brace
id|de-&gt;u.fcb.default_uid
op_assign
id|current-&gt;uid
suffix:semicolon
id|de-&gt;u.fcb.default_gid
op_assign
id|current-&gt;gid
suffix:semicolon
)brace
r_else
(brace
id|de-&gt;u.fcb.default_uid
op_assign
l_int|0
suffix:semicolon
id|de-&gt;u.fcb.default_gid
op_assign
l_int|0
suffix:semicolon
)brace
id|de-&gt;registered
op_assign
id|TRUE
suffix:semicolon
id|de-&gt;u.fcb.ops
op_assign
id|ops
suffix:semicolon
id|de-&gt;u.fcb.auto_owner
op_assign
(paren
id|flags
op_amp
id|DEVFS_FL_AUTO_OWNER
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
suffix:semicolon
id|de-&gt;u.fcb.aopen_notify
op_assign
(paren
id|flags
op_amp
id|DEVFS_FL_AOPEN_NOTIFY
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|DEVFS_FL_REMOVABLE
)paren
(brace
id|de-&gt;u.fcb.removable
op_assign
id|TRUE
suffix:semicolon
op_increment
id|de-&gt;parent-&gt;u.dir.num_removable
suffix:semicolon
)brace
id|de-&gt;u.fcb.open
op_assign
id|FALSE
suffix:semicolon
id|de-&gt;show_unreg
op_assign
(paren
(paren
id|boot_options
op_amp
id|OPTION_SHOW
)paren
op_logical_or
(paren
id|flags
op_amp
id|DEVFS_FL_SHOW_UNREG
)paren
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
suffix:semicolon
id|de-&gt;hide
op_assign
(paren
id|flags
op_amp
id|DEVFS_FL_HIDE
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
suffix:semicolon
id|de-&gt;no_persistence
op_assign
(paren
id|flags
op_amp
id|DEVFS_FL_NO_PERSISTENCE
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
suffix:semicolon
id|devfsd_notify
(paren
id|de
comma
id|DEVFSD_NOTIFY_REGISTERED
comma
id|flags
op_amp
id|DEVFS_FL_WAIT
)paren
suffix:semicolon
r_return
id|de
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_register  */
multiline_comment|/**&n; *&t;unregister - Unregister a device entry.&n; *&t;@de: The entry to unregister.&n; */
DECL|function|unregister
r_static
r_void
id|unregister
(paren
r_struct
id|devfs_entry
op_star
id|de
)paren
(brace
r_struct
id|devfs_entry
op_star
id|child
suffix:semicolon
r_if
c_cond
(paren
(paren
id|child
op_assign
id|de-&gt;slave
)paren
op_ne
l_int|NULL
)paren
(brace
id|de-&gt;slave
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Unhook first in case slave is parent directory */
id|unregister
(paren
id|child
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|de-&gt;registered
)paren
(brace
id|devfsd_notify
(paren
id|de
comma
id|DEVFSD_NOTIFY_UNREGISTERED
comma
l_int|0
)paren
suffix:semicolon
id|free_dentries
(paren
id|de
)paren
suffix:semicolon
)brace
id|de-&gt;info
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
(paren
id|de-&gt;mode
)paren
op_logical_or
id|S_ISBLK
(paren
id|de-&gt;mode
)paren
op_logical_or
id|S_ISREG
(paren
id|de-&gt;mode
)paren
)paren
(brace
id|de-&gt;registered
op_assign
id|FALSE
suffix:semicolon
id|de-&gt;u.fcb.ops
op_assign
l_int|NULL
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISLNK
(paren
id|de-&gt;mode
)paren
)paren
(brace
id|de-&gt;registered
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;u.symlink.linkname
op_ne
l_int|NULL
)paren
id|kfree
(paren
id|de-&gt;u.symlink.linkname
)paren
suffix:semicolon
id|de-&gt;u.symlink.linkname
op_assign
l_int|NULL
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|S_ISFIFO
(paren
id|de-&gt;mode
)paren
)paren
(brace
id|de-&gt;registered
op_assign
id|FALSE
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
(paren
id|de-&gt;mode
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: unregister(): unsupported type&bslash;n&quot;
comma
id|DEVFS_NAME
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|de-&gt;registered
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/*  Now recursively search the subdirectories: this is a stack chomper  */
r_for
c_loop
(paren
id|child
op_assign
id|de-&gt;u.dir.first
suffix:semicolon
id|child
op_ne
l_int|NULL
suffix:semicolon
id|child
op_assign
id|child-&gt;next
)paren
(brace
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_UNREGISTER
)paren
id|printk
(paren
l_string|&quot;%s: unregister(): child-&gt;name: &bslash;&quot;%s&bslash;&quot; child: %p&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|child-&gt;name
comma
id|child
)paren
suffix:semicolon
macro_line|#endif
id|unregister
(paren
id|child
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*  End Function unregister  */
multiline_comment|/**&n; *&t;devfs_unregister - Unregister a device entry.&n; *&t;@de: A handle previously created by devfs_register() or returned from&n; *&t;&t;devfs_find_handle(). If this is %NULL the routine does nothing.&n; */
DECL|function|devfs_unregister
r_void
id|devfs_unregister
(paren
id|devfs_handle_t
id|de
)paren
(brace
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_UNREGISTER
)paren
id|printk
(paren
l_string|&quot;%s: devfs_unregister(): de-&gt;name: &bslash;&quot;%s&bslash;&quot; de: %p&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|de-&gt;name
comma
id|de
)paren
suffix:semicolon
macro_line|#endif
id|unregister
(paren
id|de
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_unregister  */
multiline_comment|/**&n; *&t;devfs_mk_symlink Create a symbolic link in the devfs namespace.&n; *&t;@dir: The handle to the parent devfs directory entry. If this is %NULL the&n; *&t;&t;new name is relative to the root of the devfs.&n; *&t;@name: The name of the entry.&n; *&t;@flags: A set of bitwise-ORed flags (DEVFS_FL_*).&n; *&t;@link: The destination name.&n; *&t;@handle: The handle to the symlink entry is written here. This may be %NULL.&n; *&t;@info: An arbitrary pointer which will be associated with the entry.&n; *&n; *&t;Returns 0 on success, else a negative error code is returned.&n; */
DECL|function|devfs_mk_symlink
r_int
id|devfs_mk_symlink
(paren
id|devfs_handle_t
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|flags
comma
r_const
r_char
op_star
id|link
comma
id|devfs_handle_t
op_star
id|handle
comma
r_void
op_star
id|info
)paren
(brace
r_int
id|is_new
suffix:semicolon
r_int
r_int
id|linklength
suffix:semicolon
r_char
op_star
id|newname
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
r_if
c_cond
(paren
id|handle
op_ne
l_int|NULL
)paren
op_star
id|handle
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|name
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;%s: devfs_mk_symlink(): NULL name pointer&bslash;n&quot;
comma
id|DEVFS_NAME
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_REGISTER
)paren
id|printk
(paren
l_string|&quot;%s: devfs_mk_symlink(%s)&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|name
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|link
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;%s: devfs_mk_symlink(): NULL link pointer&bslash;n&quot;
comma
id|DEVFS_NAME
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|linklength
op_assign
id|strlen
(paren
id|link
)paren
suffix:semicolon
id|de
op_assign
id|search_for_entry
(paren
id|dir
comma
id|name
comma
id|strlen
(paren
id|name
)paren
comma
id|TRUE
comma
id|TRUE
comma
op_amp
id|is_new
comma
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISLNK
(paren
id|de-&gt;mode
)paren
op_logical_and
id|de-&gt;registered
)paren
(brace
id|printk
(paren
l_string|&quot;%s: devfs_mk_symlink(): non-link entry already exists&bslash;n&quot;
comma
id|DEVFS_NAME
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
r_if
c_cond
(paren
id|handle
op_ne
l_int|NULL
)paren
op_star
id|handle
op_assign
id|de
suffix:semicolon
id|de-&gt;mode
op_assign
id|S_IFLNK
op_or
id|S_IRUGO
op_or
id|S_IXUGO
suffix:semicolon
id|de-&gt;info
op_assign
id|info
suffix:semicolon
id|de-&gt;show_unreg
op_assign
(paren
(paren
id|boot_options
op_amp
id|OPTION_SHOW
)paren
op_logical_or
(paren
id|flags
op_amp
id|DEVFS_FL_SHOW_UNREG
)paren
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
suffix:semicolon
id|de-&gt;hide
op_assign
(paren
id|flags
op_amp
id|DEVFS_FL_HIDE
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
suffix:semicolon
multiline_comment|/*  Note there is no need to fiddle the dentry cache if the symlink changes&n;&t;as the symlink follow method is called every time it&squot;s needed  */
r_if
c_cond
(paren
id|de-&gt;registered
op_logical_and
(paren
id|linklength
op_eq
id|de-&gt;u.symlink.length
)paren
)paren
(brace
multiline_comment|/*  New link is same length as old link  */
r_if
c_cond
(paren
id|memcmp
(paren
id|link
comma
id|de-&gt;u.symlink.linkname
comma
id|linklength
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
multiline_comment|/*  Contents would change  */
)brace
multiline_comment|/*  Have to create/update  */
r_if
c_cond
(paren
id|de-&gt;registered
)paren
r_return
op_minus
id|EEXIST
suffix:semicolon
id|de-&gt;registered
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|newname
op_assign
id|kmalloc
(paren
id|linklength
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_struct
id|devfs_entry
op_star
id|parent
op_assign
id|de-&gt;parent
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_new
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/*  Have to clean up  */
r_if
c_cond
(paren
id|de-&gt;prev
op_eq
l_int|NULL
)paren
id|parent-&gt;u.dir.first
op_assign
id|de-&gt;next
suffix:semicolon
r_else
id|de-&gt;prev-&gt;next
op_assign
id|de-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;next
op_eq
l_int|NULL
)paren
id|parent-&gt;u.dir.last
op_assign
id|de-&gt;prev
suffix:semicolon
r_else
id|de-&gt;next-&gt;prev
op_assign
id|de-&gt;prev
suffix:semicolon
id|kfree
(paren
id|de
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|de-&gt;u.symlink.linkname
op_ne
l_int|NULL
)paren
id|kfree
(paren
id|de-&gt;u.symlink.linkname
)paren
suffix:semicolon
id|de-&gt;u.symlink.linkname
op_assign
id|newname
suffix:semicolon
id|memcpy
(paren
id|de-&gt;u.symlink.linkname
comma
id|link
comma
id|linklength
)paren
suffix:semicolon
id|de-&gt;u.symlink.linkname
(braket
id|linklength
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|de-&gt;u.symlink.length
op_assign
id|linklength
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_mk_symlink  */
multiline_comment|/**&n; *&t;devfs_mk_dir - Create a directory in the devfs namespace.&n; *&t;@dir: The handle to the parent devfs directory entry. If this is %NULL the&n; *&t;&t;new name is relative to the root of the devfs.&n; *&t;@name: The name of the entry.&n; *&t;@info: An arbitrary pointer which will be associated with the entry.&n; *&n; *&t;Use of this function is optional. The devfs_register() function&n; *&t;will automatically create intermediate directories as needed. This function&n; *&t;is provided for efficiency reasons, as it provides a handle to a directory.&n; *&t;Returns a handle which may later be used in a call to devfs_unregister().&n; *&t;On failure %NULL is returned.&n; */
DECL|function|devfs_mk_dir
id|devfs_handle_t
id|devfs_mk_dir
(paren
id|devfs_handle_t
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_void
op_star
id|info
)paren
(brace
r_int
id|is_new
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
r_if
c_cond
(paren
id|name
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;%s: devfs_mk_dir(): NULL name pointer&bslash;n&quot;
comma
id|DEVFS_NAME
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|de
op_assign
id|search_for_entry
(paren
id|dir
comma
id|name
comma
id|strlen
(paren
id|name
)paren
comma
id|TRUE
comma
id|TRUE
comma
op_amp
id|is_new
comma
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;%s: devfs_mk_dir(): could not create entry: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
(paren
id|de-&gt;mode
)paren
op_logical_and
id|de-&gt;registered
)paren
(brace
id|printk
(paren
l_string|&quot;%s: devfs_mk_dir(): existing non-directory entry: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|name
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_REGISTER
)paren
id|printk
(paren
l_string|&quot;%s: devfs_mk_dir(%s): de: %p %s&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|name
comma
id|de
comma
id|is_new
ques
c_cond
l_string|&quot;new&quot;
suffix:colon
l_string|&quot;existing&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
(paren
id|de-&gt;mode
)paren
op_logical_and
op_logical_neg
id|is_new
)paren
(brace
multiline_comment|/*  Transmogrifying an old entry  */
id|de-&gt;u.dir.first
op_assign
l_int|NULL
suffix:semicolon
id|de-&gt;u.dir.last
op_assign
l_int|NULL
suffix:semicolon
)brace
id|de-&gt;mode
op_assign
id|S_IFDIR
op_or
id|S_IRUGO
op_or
id|S_IXUGO
suffix:semicolon
id|de-&gt;info
op_assign
id|info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
id|de-&gt;u.dir.num_removable
op_assign
l_int|0
suffix:semicolon
id|de-&gt;registered
op_assign
id|TRUE
suffix:semicolon
id|de-&gt;show_unreg
op_assign
(paren
id|boot_options
op_amp
id|OPTION_SHOW
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
suffix:semicolon
id|de-&gt;hide
op_assign
id|FALSE
suffix:semicolon
r_return
id|de
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_mk_dir  */
multiline_comment|/**&n; *&t;devfs_find_handle - Find the handle of a devfs entry.&n; *&t;@dir: The handle to the parent devfs directory entry. If this is %NULL the&n; *&t;&t;name is relative to the root of the devfs.&n; *&t;@name: The name of the entry.&n; *&t;@major: The major number. This is used if @name is %NULL.&n; *&t;@minor: The minor number. This is used if @name is %NULL.&n; *&t;@type: The type of special file to search for. This may be either&n; *&t;&t;%DEVFS_SPECIAL_CHR or %DEVFS_SPECIAL_BLK.&n; *&t;@traverse_symlinks: If %TRUE then symlink entries in the devfs namespace are&n; *&t;&t;traversed. Symlinks pointing out of the devfs namespace will cause a&n; *&t;&t;failure. Symlink traversal consumes stack space.&n; *&n; *&t;Returns a handle which may later be used in a call to devfs_unregister(),&n; *&t;devfs_get_flags(), or devfs_set_flags(). On failure %NULL is returned.&n; */
DECL|function|devfs_find_handle
id|devfs_handle_t
id|devfs_find_handle
(paren
id|devfs_handle_t
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|major
comma
r_int
r_int
id|minor
comma
r_char
id|type
comma
r_int
id|traverse_symlinks
)paren
(brace
id|devfs_handle_t
id|de
suffix:semicolon
r_if
c_cond
(paren
(paren
id|name
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|name
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
)paren
id|name
op_assign
l_int|NULL
suffix:semicolon
id|de
op_assign
id|find_entry
(paren
id|dir
comma
id|name
comma
l_int|0
comma
id|major
comma
id|minor
comma
id|type
comma
id|traverse_symlinks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|de
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_find_handle  */
multiline_comment|/**&n; *&t;devfs_get_flags - Get the flags for a devfs entry.&n; *&t;@de: The handle to the device entry.&n; *&t;@flags: The flags are written here.&n; *&n; *&t;Returns 0 on success, else a negative error code.&n; */
DECL|function|devfs_get_flags
r_int
id|devfs_get_flags
(paren
id|devfs_handle_t
id|de
comma
r_int
r_int
op_star
id|flags
)paren
(brace
r_int
r_int
id|fl
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;show_unreg
)paren
id|fl
op_or_assign
id|DEVFS_FL_SHOW_UNREG
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;hide
)paren
id|fl
op_or_assign
id|DEVFS_FL_HIDE
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
(paren
id|de-&gt;mode
)paren
op_logical_or
id|S_ISBLK
(paren
id|de-&gt;mode
)paren
op_logical_or
id|S_ISREG
(paren
id|de-&gt;mode
)paren
)paren
(brace
r_if
c_cond
(paren
id|de-&gt;u.fcb.auto_owner
)paren
id|fl
op_or_assign
id|DEVFS_FL_AUTO_OWNER
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;u.fcb.aopen_notify
)paren
id|fl
op_or_assign
id|DEVFS_FL_AOPEN_NOTIFY
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;u.fcb.removable
)paren
id|fl
op_or_assign
id|DEVFS_FL_REMOVABLE
suffix:semicolon
)brace
op_star
id|flags
op_assign
id|fl
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_get_flags  */
multiline_comment|/*&n; *&t;devfs_set_flags - Set the flags for a devfs entry.&n; *&t;@de: The handle to the device entry.&n; *&t;@flags: The flags to set. Unset flags are cleared.&n; *&n; *&t;Returns 0 on success, else a negative error code.&n; */
DECL|function|devfs_set_flags
r_int
id|devfs_set_flags
(paren
id|devfs_handle_t
id|de
comma
r_int
r_int
id|flags
)paren
(brace
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_SET_FLAGS
)paren
id|printk
(paren
l_string|&quot;%s: devfs_set_flags(): de-&gt;name: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|de-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|de-&gt;show_unreg
op_assign
(paren
id|flags
op_amp
id|DEVFS_FL_SHOW_UNREG
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
suffix:semicolon
id|de-&gt;hide
op_assign
(paren
id|flags
op_amp
id|DEVFS_FL_HIDE
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
(paren
id|de-&gt;mode
)paren
op_logical_or
id|S_ISBLK
(paren
id|de-&gt;mode
)paren
op_logical_or
id|S_ISREG
(paren
id|de-&gt;mode
)paren
)paren
(brace
id|de-&gt;u.fcb.auto_owner
op_assign
(paren
id|flags
op_amp
id|DEVFS_FL_AUTO_OWNER
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
suffix:semicolon
id|de-&gt;u.fcb.aopen_notify
op_assign
(paren
id|flags
op_amp
id|DEVFS_FL_AOPEN_NOTIFY
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;u.fcb.removable
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|DEVFS_FL_REMOVABLE
)paren
)paren
(brace
id|de-&gt;u.fcb.removable
op_assign
id|FALSE
suffix:semicolon
op_decrement
id|de-&gt;parent-&gt;u.dir.num_removable
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;u.fcb.removable
op_logical_and
(paren
id|flags
op_amp
id|DEVFS_FL_REMOVABLE
)paren
)paren
(brace
id|de-&gt;u.fcb.removable
op_assign
id|TRUE
suffix:semicolon
op_increment
id|de-&gt;parent-&gt;u.dir.num_removable
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_set_flags  */
multiline_comment|/**&n; *&t;devfs_get_maj_min - Get the major and minor numbers for a devfs entry.&n; *&t;@de: The handle to the device entry.&n; *&t;@major: The major number is written here. This may be %NULL.&n; *&t;@minor: The minor number is written here. This may be %NULL.&n; *&n; *&t;Returns 0 on success, else a negative error code.&n; */
DECL|function|devfs_get_maj_min
r_int
id|devfs_get_maj_min
(paren
id|devfs_handle_t
id|de
comma
r_int
r_int
op_star
id|major
comma
r_int
r_int
op_star
id|minor
)paren
(brace
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|de-&gt;mode
)paren
)paren
r_return
op_minus
id|EISDIR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISCHR
(paren
id|de-&gt;mode
)paren
op_logical_and
op_logical_neg
id|S_ISBLK
(paren
id|de-&gt;mode
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|major
op_ne
l_int|NULL
)paren
op_star
id|major
op_assign
id|de-&gt;u.fcb.u.device.major
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ne
l_int|NULL
)paren
op_star
id|minor
op_assign
id|de-&gt;u.fcb.u.device.minor
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_get_maj_min  */
multiline_comment|/**&n; *&t;devfs_get_handle_from_inode - Get the devfs handle for a VFS inode.&n; *&t;@inode: The VFS inode.&n; *&n; *&t;Returns the devfs handle on success, else %NULL.&n; */
DECL|function|devfs_get_handle_from_inode
id|devfs_handle_t
id|devfs_get_handle_from_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|inode
op_logical_or
op_logical_neg
id|inode-&gt;i_sb
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_sb-&gt;s_magic
op_ne
id|DEVFS_SUPER_MAGIC
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|get_devfs_entry_from_vfs_inode
(paren
id|inode
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_get_handle_from_inode  */
multiline_comment|/**&n; *&t;devfs_generate_path - Generate a pathname for an entry, relative to the devfs root.&n; *&t;@de: The devfs entry.&n; *&t;@path: The buffer to write the pathname to. The pathname and &squot;&bslash;0&squot;&n; *&t;&t;terminator will be written at the end of the buffer.&n; *&t;@buflen: The length of the buffer.&n; *&n; *&t;Returns the offset in the buffer where the pathname starts on success,&n; *&t;else a negative error code.&n; */
DECL|function|devfs_generate_path
r_int
id|devfs_generate_path
(paren
id|devfs_handle_t
id|de
comma
r_char
op_star
id|path
comma
r_int
id|buflen
)paren
(brace
r_int
id|pos
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;namelen
op_ge
id|buflen
)paren
r_return
op_minus
id|ENAMETOOLONG
suffix:semicolon
multiline_comment|/*  Must be first       */
r_if
c_cond
(paren
id|de-&gt;parent
op_eq
l_int|NULL
)paren
r_return
id|buflen
suffix:semicolon
multiline_comment|/*  Don&squot;t prepend root  */
id|pos
op_assign
id|buflen
op_minus
id|de-&gt;namelen
op_minus
l_int|1
suffix:semicolon
id|memcpy
(paren
id|path
op_plus
id|pos
comma
id|de-&gt;name
comma
id|de-&gt;namelen
)paren
suffix:semicolon
id|path
(braket
id|buflen
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
id|de
op_assign
id|de-&gt;parent
suffix:semicolon
id|de-&gt;parent
op_ne
l_int|NULL
suffix:semicolon
id|de
op_assign
id|de-&gt;parent
)paren
(brace
r_if
c_cond
(paren
id|pos
op_minus
id|de-&gt;namelen
op_minus
l_int|1
OL
l_int|0
)paren
r_return
op_minus
id|ENAMETOOLONG
suffix:semicolon
id|path
(braket
op_decrement
id|pos
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
id|pos
op_sub_assign
id|de-&gt;namelen
suffix:semicolon
id|memcpy
(paren
id|path
op_plus
id|pos
comma
id|de-&gt;name
comma
id|de-&gt;namelen
)paren
suffix:semicolon
)brace
r_return
id|pos
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_generate_path  */
multiline_comment|/**&n; *&t;devfs_get_ops - Get the device operations for a devfs entry.&n; *&t;@de: The handle to the device entry.&n; *&n; *&t;Returns a pointer to the device operations on success, else NULL.&n; */
DECL|function|devfs_get_ops
r_void
op_star
id|devfs_get_ops
(paren
id|devfs_handle_t
id|de
)paren
(brace
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
(paren
id|de-&gt;mode
)paren
op_logical_or
id|S_ISBLK
(paren
id|de-&gt;mode
)paren
op_logical_or
id|S_ISREG
(paren
id|de-&gt;mode
)paren
)paren
r_return
id|de-&gt;u.fcb.ops
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_get_ops  */
multiline_comment|/**&n; *&t;devfs_set_file_size - Set the file size for a devfs regular file.&n; *&t;@de: The handle to the device entry.&n; *&t;@size: The new file size.&n; *&n; *&t;Returns 0 on success, else a negative error code.&n; */
DECL|function|devfs_set_file_size
r_int
id|devfs_set_file_size
(paren
id|devfs_handle_t
id|de
comma
r_int
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
(paren
id|de-&gt;mode
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;u.fcb.u.file.size
op_eq
id|size
)paren
r_return
l_int|0
suffix:semicolon
id|de-&gt;u.fcb.u.file.size
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;inode.dentry
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;inode.dentry-&gt;d_inode
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|de-&gt;inode.dentry-&gt;d_inode-&gt;i_size
op_assign
id|size
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_set_file_size  */
multiline_comment|/**&n; *&t;devfs_get_info - Get the info pointer written to private_data of @de upon open.&n; *&t;@de: The handle to the device entry.&n; *&n; *&t;Returns the info pointer.&n; */
DECL|function|devfs_get_info
r_void
op_star
id|devfs_get_info
(paren
id|devfs_handle_t
id|de
)paren
(brace
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|de-&gt;info
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_get_info  */
multiline_comment|/**&n; *&t;devfs_set_info - Set the info pointer written to private_data upon open.&n; *&t;@de: The handle to the device entry.&n; *&t;@info: pointer to the data&n; *&n; *&t;Returns 0 on success, else a negative error code.&n; */
DECL|function|devfs_set_info
r_int
id|devfs_set_info
(paren
id|devfs_handle_t
id|de
comma
r_void
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|de-&gt;info
op_assign
id|info
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_set_info  */
multiline_comment|/**&n; *&t;devfs_get_parent - Get the parent device entry.&n; *&t;@de: The handle to the device entry.&n; *&n; *&t;Returns the parent device entry if it exists, else %NULL.&n; */
DECL|function|devfs_get_parent
id|devfs_handle_t
id|devfs_get_parent
(paren
id|devfs_handle_t
id|de
)paren
(brace
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|de-&gt;parent
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_get_parent  */
multiline_comment|/**&n; *&t;devfs_get_first_child - Get the first leaf node in a directory.&n; *&t;@de: The handle to the device entry.&n; *&n; *&t;Returns the leaf node device entry if it exists, else %NULL.&n; */
DECL|function|devfs_get_first_child
id|devfs_handle_t
id|devfs_get_first_child
(paren
id|devfs_handle_t
id|de
)paren
(brace
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
(paren
id|de-&gt;mode
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|de-&gt;u.dir.first
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_get_first_child  */
multiline_comment|/**&n; *&t;devfs_get_next_sibling - Get the next sibling leaf node. for a device entry.&n; *&t;@de: The handle to the device entry.&n; *&n; *&t;Returns the leaf node device entry if it exists, else %NULL.&n; */
DECL|function|devfs_get_next_sibling
id|devfs_handle_t
id|devfs_get_next_sibling
(paren
id|devfs_handle_t
id|de
)paren
(brace
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|de-&gt;next
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_get_next_sibling  */
multiline_comment|/**&n; *&t;devfs_auto_unregister - Configure a devfs entry to be automatically unregistered.&n; *&t;@master: The master devfs entry. Only one slave may be registered.&n; *&t;@slave: The devfs entry which will be automatically unregistered when the&n; *&t;&t;master entry is unregistered. It is illegal to call devfs_unregister()&n; *&t;&t;on this entry.&n; */
DECL|function|devfs_auto_unregister
r_void
id|devfs_auto_unregister
(paren
id|devfs_handle_t
id|master
comma
id|devfs_handle_t
id|slave
)paren
(brace
r_if
c_cond
(paren
id|master
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|master-&gt;slave
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*  Because of the dumbness of the layers above, ignore duplicates  */
r_if
c_cond
(paren
id|master-&gt;slave
op_eq
id|slave
)paren
r_return
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: devfs_auto_unregister(): only one slave allowed&bslash;n&quot;
comma
id|DEVFS_NAME
)paren
suffix:semicolon
id|OOPS
(paren
l_string|&quot;  master: &bslash;&quot;%s&bslash;&quot;  old slave: &bslash;&quot;%s&bslash;&quot;  new slave: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|master-&gt;name
comma
id|master-&gt;slave-&gt;name
comma
id|slave-&gt;name
)paren
suffix:semicolon
)brace
id|master-&gt;slave
op_assign
id|slave
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_auto_unregister  */
multiline_comment|/**&n; *&t;devfs_get_unregister_slave - Get the slave entry which will be automatically unregistered.&n; *&t;@master: The master devfs entry.&n; *&n; *&t;Returns the slave which will be unregistered when @master is unregistered.&n; */
DECL|function|devfs_get_unregister_slave
id|devfs_handle_t
id|devfs_get_unregister_slave
(paren
id|devfs_handle_t
id|master
)paren
(brace
r_if
c_cond
(paren
id|master
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|master-&gt;slave
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_get_unregister_slave  */
multiline_comment|/**&n; *&t;devfs_get_name - Get the name for a device entry in its parent directory.&n; *&t;@de: The handle to the device entry.&n; *&t;@namelen: The length of the name is written here. This may be %NULL.&n; *&n; *&t;Returns the name on success, else %NULL.&n; */
DECL|function|devfs_get_name
r_const
r_char
op_star
id|devfs_get_name
(paren
id|devfs_handle_t
id|de
comma
r_int
r_int
op_star
id|namelen
)paren
(brace
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|namelen
op_ne
l_int|NULL
)paren
op_star
id|namelen
op_assign
id|de-&gt;namelen
suffix:semicolon
r_return
id|de-&gt;name
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_get_name  */
multiline_comment|/**&n; *&t;devfs_register_chrdev - Optionally register a conventional character driver.&n; *&t;@major: The major number for the driver.&n; *&t;@name: The name of the driver (as seen in /proc/devices).&n; *&t;@fops: The &amp;file_operations structure pointer.&n; *&n; *&t;This function will register a character driver provided the &quot;devfs=only&quot;&n; *&t;option was not provided at boot time.&n; *&t;Returns 0 on success, else a negative error code on failure.&n; */
DECL|function|devfs_register_chrdev
r_int
id|devfs_register_chrdev
(paren
r_int
r_int
id|major
comma
r_const
r_char
op_star
id|name
comma
r_struct
id|file_operations
op_star
id|fops
)paren
(brace
r_if
c_cond
(paren
id|boot_options
op_amp
id|OPTION_ONLY
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|register_chrdev
(paren
id|major
comma
id|name
comma
id|fops
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_register_chrdev  */
multiline_comment|/**&n; *&t;devfs_register_blkdev - Optionally register a conventional block driver.&n; *&t;@major: The major number for the driver.&n; *&t;@name: The name of the driver (as seen in /proc/devices).&n; *&t;@bdops: The &amp;block_device_operations structure pointer.&n; *&n; *&t;This function will register a block driver provided the &quot;devfs=only&quot;&n; *&t;option was not provided at boot time.&n; *&t;Returns 0 on success, else a negative error code on failure.&n; */
DECL|function|devfs_register_blkdev
r_int
id|devfs_register_blkdev
(paren
r_int
r_int
id|major
comma
r_const
r_char
op_star
id|name
comma
r_struct
id|block_device_operations
op_star
id|bdops
)paren
(brace
r_if
c_cond
(paren
id|boot_options
op_amp
id|OPTION_ONLY
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|register_blkdev
(paren
id|major
comma
id|name
comma
id|bdops
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_register_blkdev  */
multiline_comment|/**&n; *&t;devfs_unregister_chrdev - Optionally unregister a conventional character driver.&n; *&t;@major: The major number for the driver.&n; *&t;@name: The name of the driver (as seen in /proc/devices).&n; *&n; *&t;This function will unregister a character driver provided the &quot;devfs=only&quot;&n; *&t;option was not provided at boot time.&n; *&t;Returns 0 on success, else a negative error code on failure.&n; */
DECL|function|devfs_unregister_chrdev
r_int
id|devfs_unregister_chrdev
(paren
r_int
r_int
id|major
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
id|boot_options
op_amp
id|OPTION_ONLY
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|unregister_chrdev
(paren
id|major
comma
id|name
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_unregister_chrdev  */
multiline_comment|/**&n; *&t;devfs_unregister_blkdev - Optionally unregister a conventional block driver.&n; *&t;@major: The major number for the driver.&n; *&t;@name: The name of the driver (as seen in /proc/devices).&n; *&n; *&t;This function will unregister a block driver provided the &quot;devfs=only&quot;&n; *&t;option was not provided at boot time.&n; *&t;Returns 0 on success, else a negative error code on failure.&n; */
DECL|function|devfs_unregister_blkdev
r_int
id|devfs_unregister_blkdev
(paren
r_int
r_int
id|major
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
id|boot_options
op_amp
id|OPTION_ONLY
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|unregister_blkdev
(paren
id|major
comma
id|name
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_unregister_blkdev  */
multiline_comment|/**&n; *&t;devfs_setup - Process kernel boot options.&n; *&t;@str: The boot options after the &quot;devfs=&quot;.&n; */
DECL|function|devfs_setup
r_static
r_int
id|__init
id|devfs_setup
(paren
r_char
op_star
id|str
)paren
(brace
r_while
c_loop
(paren
(paren
op_star
id|str
op_ne
l_char|&squot;&bslash;0&squot;
)paren
op_logical_and
op_logical_neg
id|isspace
(paren
op_star
id|str
)paren
)paren
(brace
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|strncmp
(paren
id|str
comma
l_string|&quot;dall&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
id|devfs_debug_init
op_or_assign
id|DEBUG_ALL
suffix:semicolon
id|str
op_add_assign
l_int|4
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
(paren
id|str
comma
l_string|&quot;dmod&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
id|devfs_debug_init
op_or_assign
id|DEBUG_MODULE_LOAD
suffix:semicolon
id|str
op_add_assign
l_int|4
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
(paren
id|str
comma
l_string|&quot;dreg&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
id|devfs_debug_init
op_or_assign
id|DEBUG_REGISTER
suffix:semicolon
id|str
op_add_assign
l_int|4
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
(paren
id|str
comma
l_string|&quot;dunreg&quot;
comma
l_int|6
)paren
op_eq
l_int|0
)paren
(brace
id|devfs_debug_init
op_or_assign
id|DEBUG_UNREGISTER
suffix:semicolon
id|str
op_add_assign
l_int|6
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
(paren
id|str
comma
l_string|&quot;diread&quot;
comma
l_int|6
)paren
op_eq
l_int|0
)paren
(brace
id|devfs_debug_init
op_or_assign
id|DEBUG_I_READ
suffix:semicolon
id|str
op_add_assign
l_int|6
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
(paren
id|str
comma
l_string|&quot;dchange&quot;
comma
l_int|7
)paren
op_eq
l_int|0
)paren
(brace
id|devfs_debug_init
op_or_assign
id|DEBUG_SET_FLAGS
suffix:semicolon
id|str
op_add_assign
l_int|7
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
(paren
id|str
comma
l_string|&quot;diwrite&quot;
comma
l_int|7
)paren
op_eq
l_int|0
)paren
(brace
id|devfs_debug_init
op_or_assign
id|DEBUG_I_WRITE
suffix:semicolon
id|str
op_add_assign
l_int|7
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
(paren
id|str
comma
l_string|&quot;dimknod&quot;
comma
l_int|7
)paren
op_eq
l_int|0
)paren
(brace
id|devfs_debug_init
op_or_assign
id|DEBUG_I_MKNOD
suffix:semicolon
id|str
op_add_assign
l_int|7
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
(paren
id|str
comma
l_string|&quot;dilookup&quot;
comma
l_int|8
)paren
op_eq
l_int|0
)paren
(brace
id|devfs_debug_init
op_or_assign
id|DEBUG_I_LOOKUP
suffix:semicolon
id|str
op_add_assign
l_int|8
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
(paren
id|str
comma
l_string|&quot;diunlink&quot;
comma
l_int|8
)paren
op_eq
l_int|0
)paren
(brace
id|devfs_debug_init
op_or_assign
id|DEBUG_I_UNLINK
suffix:semicolon
id|str
op_add_assign
l_int|8
suffix:semicolon
)brace
r_else
macro_line|#endif  /*  CONFIG_DEVFS_DEBUG  */
r_if
c_cond
(paren
id|strncmp
(paren
id|str
comma
l_string|&quot;show&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
id|boot_options
op_or_assign
id|OPTION_SHOW
suffix:semicolon
id|str
op_add_assign
l_int|4
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
(paren
id|str
comma
l_string|&quot;only&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
id|boot_options
op_or_assign
id|OPTION_ONLY
suffix:semicolon
id|str
op_add_assign
l_int|4
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
(paren
id|str
comma
l_string|&quot;mount&quot;
comma
l_int|5
)paren
op_eq
l_int|0
)paren
(brace
id|boot_options
op_and_assign
op_complement
id|OPTION_NOMOUNT
suffix:semicolon
id|str
op_add_assign
l_int|5
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strncmp
(paren
id|str
comma
l_string|&quot;nomount&quot;
comma
l_int|7
)paren
op_eq
l_int|0
)paren
(brace
id|boot_options
op_or_assign
id|OPTION_NOMOUNT
suffix:semicolon
id|str
op_add_assign
l_int|7
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|str
op_ne
l_char|&squot;,&squot;
)paren
r_return
l_int|0
suffix:semicolon
op_increment
id|str
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_setup  */
id|__setup
c_func
(paren
l_string|&quot;devfs=&quot;
comma
id|devfs_setup
)paren
suffix:semicolon
DECL|variable|devfs_register
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_register
)paren
suffix:semicolon
DECL|variable|devfs_unregister
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_unregister
)paren
suffix:semicolon
DECL|variable|devfs_mk_symlink
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_mk_symlink
)paren
suffix:semicolon
DECL|variable|devfs_mk_dir
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_mk_dir
)paren
suffix:semicolon
DECL|variable|devfs_find_handle
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_find_handle
)paren
suffix:semicolon
DECL|variable|devfs_get_flags
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_get_flags
)paren
suffix:semicolon
DECL|variable|devfs_set_flags
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_set_flags
)paren
suffix:semicolon
DECL|variable|devfs_get_maj_min
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_get_maj_min
)paren
suffix:semicolon
DECL|variable|devfs_get_handle_from_inode
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_get_handle_from_inode
)paren
suffix:semicolon
DECL|variable|devfs_generate_path
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_generate_path
)paren
suffix:semicolon
DECL|variable|devfs_get_ops
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_get_ops
)paren
suffix:semicolon
DECL|variable|devfs_set_file_size
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_set_file_size
)paren
suffix:semicolon
DECL|variable|devfs_get_info
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_get_info
)paren
suffix:semicolon
DECL|variable|devfs_set_info
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_set_info
)paren
suffix:semicolon
DECL|variable|devfs_get_parent
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_get_parent
)paren
suffix:semicolon
DECL|variable|devfs_get_first_child
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_get_first_child
)paren
suffix:semicolon
DECL|variable|devfs_get_next_sibling
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_get_next_sibling
)paren
suffix:semicolon
DECL|variable|devfs_auto_unregister
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_auto_unregister
)paren
suffix:semicolon
DECL|variable|devfs_get_unregister_slave
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_get_unregister_slave
)paren
suffix:semicolon
DECL|variable|devfs_register_chrdev
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_register_chrdev
)paren
suffix:semicolon
DECL|variable|devfs_register_blkdev
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_register_blkdev
)paren
suffix:semicolon
DECL|variable|devfs_unregister_chrdev
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_unregister_chrdev
)paren
suffix:semicolon
DECL|variable|devfs_unregister_blkdev
id|EXPORT_SYMBOL
c_func
(paren
id|devfs_unregister_blkdev
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;try_modload - Notify devfsd of an inode lookup.&n; *&t;@parent: The parent devfs entry.&n; *&t;@fs_info: The filesystem info.&n; *&t;@name: The device name.&n; *&t;@namelen: The number of characters in @name.&n; *&t;@buf: A working area that will be used. This must not go out of scope until&n; *&t;&t;devfsd is idle again.&n; *&n; *&t;Returns 0 on success, else a negative error code.&n; */
DECL|function|try_modload
r_static
r_int
id|try_modload
(paren
r_struct
id|devfs_entry
op_star
id|parent
comma
r_struct
id|fs_info
op_star
id|fs_info
comma
r_const
r_char
op_star
id|name
comma
r_int
id|namelen
comma
r_char
id|buf
(braket
id|STRING_LENGTH
)braket
)paren
(brace
r_int
id|pos
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|fs_info-&gt;devfsd_event_mask
op_amp
(paren
l_int|1
op_lshift
id|DEVFSD_NOTIFY_LOOKUP
)paren
)paren
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|is_devfsd_or_child
(paren
id|fs_info
)paren
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|namelen
op_ge
id|STRING_LENGTH
)paren
r_return
op_minus
id|ENAMETOOLONG
suffix:semicolon
id|memcpy
(paren
id|buf
op_plus
id|STRING_LENGTH
op_minus
id|namelen
op_minus
l_int|1
comma
id|name
comma
id|namelen
)paren
suffix:semicolon
id|buf
(braket
id|STRING_LENGTH
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|pos
op_assign
id|devfs_generate_path
(paren
id|parent
comma
id|buf
comma
id|STRING_LENGTH
op_minus
id|namelen
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
r_return
id|pos
suffix:semicolon
id|buf
(braket
id|STRING_LENGTH
op_minus
id|namelen
op_minus
l_int|2
)braket
op_assign
l_char|&squot;/&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|devfsd_notify_one
(paren
id|buf
op_plus
id|pos
comma
id|DEVFSD_NOTIFY_LOOKUP
comma
l_int|0
comma
id|current-&gt;euid
comma
id|current-&gt;egid
comma
id|fs_info
)paren
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
multiline_comment|/*  Possible success  */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function try_modload  */
multiline_comment|/**&n; *&t;check_disc_changed - Check if a removable disc was changed.&n; *&t;@de: The device.&n; *&n; *&t;Returns 1 if the media was changed, else 0.&n; */
DECL|function|check_disc_changed
r_static
r_int
id|check_disc_changed
(paren
r_struct
id|devfs_entry
op_star
id|de
)paren
(brace
r_int
id|tmp
suffix:semicolon
id|kdev_t
id|dev
op_assign
id|MKDEV
(paren
id|de-&gt;u.fcb.u.device.major
comma
id|de-&gt;u.fcb.u.device.minor
)paren
suffix:semicolon
r_struct
id|block_device_operations
op_star
id|bdops
op_assign
id|de-&gt;u.fcb.ops
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
r_extern
r_int
id|warn_no_part
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISBLK
(paren
id|de-&gt;mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bdops
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bdops-&gt;check_media_change
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bdops-&gt;check_media_change
(paren
id|dev
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;VFS: Disk change detected on device %s&bslash;n&quot;
comma
id|kdevname
(paren
id|dev
)paren
)paren
suffix:semicolon
id|sb
op_assign
id|get_super
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb
op_logical_and
id|invalidate_inodes
(paren
id|sb
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;VFS: busy inodes on changed media..&bslash;n&quot;
)paren
suffix:semicolon
id|invalidate_buffers
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*  Ugly hack to disable messages about unable to read partition table  */
id|tmp
op_assign
id|warn_no_part
suffix:semicolon
id|warn_no_part
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bdops-&gt;revalidate
)paren
id|bdops-&gt;revalidate
(paren
id|dev
)paren
suffix:semicolon
id|warn_no_part
op_assign
id|tmp
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*  End Function check_disc_changed  */
multiline_comment|/**&n; *&t;scan_dir_for_removable - Scan a directory for removable media devices and check media.&n; *&t;@dir: The directory.&n; */
DECL|function|scan_dir_for_removable
r_static
r_void
id|scan_dir_for_removable
(paren
r_struct
id|devfs_entry
op_star
id|dir
)paren
(brace
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;u.dir.num_removable
OL
l_int|1
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|de
op_assign
id|dir-&gt;u.dir.first
suffix:semicolon
id|de
op_ne
l_int|NULL
suffix:semicolon
id|de
op_assign
id|de-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISBLK
(paren
id|de-&gt;mode
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;u.fcb.removable
)paren
r_continue
suffix:semicolon
id|check_disc_changed
(paren
id|de
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*  End Function scan_dir_for_removable  */
multiline_comment|/**&n; *&t;get_removable_partition - Get removable media partition.&n; *&t;@dir: The parent directory.&n; *&t;@name: The name of the entry.&n; *&t;@namelen: The number of characters in &lt;&lt;name&gt;&gt;.&n; *&n; *&t;Returns 1 if the media was changed, else 0.&n; */
DECL|function|get_removable_partition
r_static
r_int
id|get_removable_partition
(paren
r_struct
id|devfs_entry
op_star
id|dir
comma
r_const
r_char
op_star
id|name
comma
r_int
r_int
id|namelen
)paren
(brace
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
r_for
c_loop
(paren
id|de
op_assign
id|dir-&gt;u.dir.first
suffix:semicolon
id|de
op_ne
l_int|NULL
suffix:semicolon
id|de
op_assign
id|de-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISBLK
(paren
id|de-&gt;mode
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;u.fcb.removable
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
(paren
id|de-&gt;name
comma
l_string|&quot;disc&quot;
)paren
op_eq
l_int|0
)paren
r_return
id|check_disc_changed
(paren
id|de
)paren
suffix:semicolon
multiline_comment|/*  Support for names where the partition is appended to the disc name&n;&t; */
r_if
c_cond
(paren
id|de-&gt;namelen
op_ge
id|namelen
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
(paren
id|de-&gt;name
comma
id|name
comma
id|de-&gt;namelen
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
r_return
id|check_disc_changed
(paren
id|de
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function get_removable_partition  */
multiline_comment|/*  Superblock operations follow  */
DECL|variable|devfs_iops
r_static
r_struct
id|inode_operations
id|devfs_iops
suffix:semicolon
DECL|variable|devfs_dir_iops
r_static
r_struct
id|inode_operations
id|devfs_dir_iops
suffix:semicolon
DECL|variable|devfs_fops
r_static
r_struct
id|file_operations
id|devfs_fops
suffix:semicolon
DECL|variable|devfs_symlink_iops
r_static
r_struct
id|inode_operations
id|devfs_symlink_iops
suffix:semicolon
DECL|function|devfs_read_inode
r_static
r_void
id|devfs_read_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
id|de
op_assign
id|get_devfs_entry_from_vfs_inode
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;%s: read_inode(%d): VFS inode: %p  NO devfs_entry&bslash;n&quot;
comma
id|DEVFS_NAME
comma
(paren
r_int
)paren
id|inode-&gt;i_ino
comma
id|inode
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_I_READ
)paren
id|printk
(paren
l_string|&quot;%s: read_inode(%d): VFS inode: %p  devfs_entry: %p&bslash;n&quot;
comma
id|DEVFS_NAME
comma
(paren
r_int
)paren
id|inode-&gt;i_ino
comma
id|inode
comma
id|de
)paren
suffix:semicolon
macro_line|#endif
id|inode-&gt;i_blocks
op_assign
l_int|0
suffix:semicolon
id|inode-&gt;i_blksize
op_assign
l_int|1024
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|devfs_iops
suffix:semicolon
id|inode-&gt;i_fop
op_assign
op_amp
id|devfs_fops
suffix:semicolon
id|inode-&gt;i_rdev
op_assign
id|NODEV
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
(paren
id|de-&gt;inode.mode
)paren
)paren
(brace
id|inode-&gt;i_rdev
op_assign
id|MKDEV
(paren
id|de-&gt;u.fcb.u.device.major
comma
id|de-&gt;u.fcb.u.device.minor
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISBLK
(paren
id|de-&gt;inode.mode
)paren
)paren
(brace
id|inode-&gt;i_rdev
op_assign
id|MKDEV
(paren
id|de-&gt;u.fcb.u.device.major
comma
id|de-&gt;u.fcb.u.device.minor
)paren
suffix:semicolon
id|inode-&gt;i_bdev
op_assign
id|bdget
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_bdev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_bdev-&gt;bd_op
op_logical_and
id|de-&gt;u.fcb.ops
)paren
id|inode-&gt;i_bdev-&gt;bd_op
op_assign
id|de-&gt;u.fcb.ops
suffix:semicolon
)brace
r_else
id|printk
(paren
l_string|&quot;%s: read_inode(%d): no block device from bdget()&bslash;n&quot;
comma
id|DEVFS_NAME
comma
(paren
r_int
)paren
id|inode-&gt;i_ino
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISFIFO
(paren
id|de-&gt;inode.mode
)paren
)paren
id|inode-&gt;i_fop
op_assign
op_amp
id|def_fifo_fops
suffix:semicolon
r_else
r_if
c_cond
(paren
id|S_ISREG
(paren
id|de-&gt;inode.mode
)paren
)paren
id|inode-&gt;i_size
op_assign
id|de-&gt;u.fcb.u.file.size
suffix:semicolon
r_else
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|de-&gt;inode.mode
)paren
)paren
id|inode-&gt;i_op
op_assign
op_amp
id|devfs_dir_iops
suffix:semicolon
r_else
r_if
c_cond
(paren
id|S_ISLNK
(paren
id|de-&gt;inode.mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|devfs_symlink_iops
suffix:semicolon
id|inode-&gt;i_size
op_assign
id|de-&gt;u.symlink.length
suffix:semicolon
)brace
id|inode-&gt;i_mode
op_assign
id|de-&gt;inode.mode
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|de-&gt;inode.uid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|de-&gt;inode.gid
suffix:semicolon
id|inode-&gt;i_atime
op_assign
id|de-&gt;inode.atime
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
id|de-&gt;inode.mtime
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|de-&gt;inode.ctime
suffix:semicolon
id|inode-&gt;i_nlink
op_assign
id|de-&gt;inode.nlink
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_I_READ
)paren
id|printk
(paren
l_string|&quot;%s:   mode: 0%o  uid: %d  gid: %d&bslash;n&quot;
comma
id|DEVFS_NAME
comma
(paren
r_int
)paren
id|inode-&gt;i_mode
comma
(paren
r_int
)paren
id|inode-&gt;i_uid
comma
(paren
r_int
)paren
id|inode-&gt;i_gid
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*  End Function devfs_read_inode  */
DECL|function|devfs_write_inode
r_static
r_void
id|devfs_write_inode
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|wait
)paren
(brace
r_int
id|index
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
op_assign
id|inode-&gt;i_sb-&gt;u.generic_sbp
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_ino
OL
id|FIRST_INODE
)paren
r_return
suffix:semicolon
id|index
op_assign
id|inode-&gt;i_ino
op_minus
id|FIRST_INODE
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
id|fs_info-&gt;num_inodes
)paren
(brace
id|printk
(paren
l_string|&quot;%s: writing inode: %lu for which there is no entry!&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|de
op_assign
id|fs_info-&gt;table
(braket
id|index
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_I_WRITE
)paren
(brace
id|printk
(paren
l_string|&quot;%s: write_inode(%d): VFS inode: %p  devfs_entry: %p&bslash;n&quot;
comma
id|DEVFS_NAME
comma
(paren
r_int
)paren
id|inode-&gt;i_ino
comma
id|inode
comma
id|de
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;%s:   mode: 0%o  uid: %d  gid: %d&bslash;n&quot;
comma
id|DEVFS_NAME
comma
(paren
r_int
)paren
id|inode-&gt;i_mode
comma
(paren
r_int
)paren
id|inode-&gt;i_uid
comma
(paren
r_int
)paren
id|inode-&gt;i_gid
)paren
suffix:semicolon
)brace
macro_line|#endif
id|de-&gt;inode.mode
op_assign
id|inode-&gt;i_mode
suffix:semicolon
id|de-&gt;inode.uid
op_assign
id|inode-&gt;i_uid
suffix:semicolon
id|de-&gt;inode.gid
op_assign
id|inode-&gt;i_gid
suffix:semicolon
id|de-&gt;inode.atime
op_assign
id|inode-&gt;i_atime
suffix:semicolon
id|de-&gt;inode.mtime
op_assign
id|inode-&gt;i_mtime
suffix:semicolon
id|de-&gt;inode.ctime
op_assign
id|inode-&gt;i_ctime
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_write_inode  */
DECL|function|devfs_notify_change
r_static
r_int
id|devfs_notify_change
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|iattr
op_star
id|iattr
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
op_assign
id|inode-&gt;i_sb-&gt;u.generic_sbp
suffix:semicolon
id|de
op_assign
id|get_devfs_entry_from_vfs_inode
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|retval
op_assign
id|inode_change_ok
(paren
id|inode
comma
id|iattr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|0
)paren
r_return
id|retval
suffix:semicolon
id|inode_setattr
(paren
id|inode
comma
id|iattr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iattr-&gt;ia_valid
op_amp
(paren
id|ATTR_MODE
op_or
id|ATTR_UID
op_or
id|ATTR_GID
)paren
)paren
id|devfsd_notify_one
(paren
id|de
comma
id|DEVFSD_NOTIFY_CHANGE
comma
id|inode-&gt;i_mode
comma
id|inode-&gt;i_uid
comma
id|inode-&gt;i_gid
comma
id|fs_info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_notify_change  */
DECL|function|devfs_statfs
r_static
r_int
id|devfs_statfs
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|statfs
op_star
id|buf
)paren
(brace
id|buf-&gt;f_type
op_assign
id|DEVFS_SUPER_MAGIC
suffix:semicolon
id|buf-&gt;f_bsize
op_assign
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|buf-&gt;f_bfree
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;f_bavail
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;f_ffree
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;f_namelen
op_assign
id|NAME_MAX
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_statfs  */
DECL|variable|devfs_sops
r_static
r_struct
id|super_operations
id|devfs_sops
op_assign
(brace
id|read_inode
suffix:colon
id|devfs_read_inode
comma
id|write_inode
suffix:colon
id|devfs_write_inode
comma
id|statfs
suffix:colon
id|devfs_statfs
comma
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;get_vfs_inode - Get a VFS inode.&n; *&t;@sb: The super block.&n; *&t;@de: The devfs inode.&n; *&t;@dentry: The dentry to register with the devfs inode.&n; *&n; *&t;Returns the inode on success, else %NULL.&n; */
DECL|function|get_vfs_inode
r_static
r_struct
id|inode
op_star
id|get_vfs_inode
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_struct
id|devfs_entry
op_star
id|de
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;inode.dentry
op_ne
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;%s: get_vfs_inode(%u): old de-&gt;inode.dentry: %p &bslash;&quot;%s&bslash;&quot;  new dentry: %p &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|de-&gt;inode.ino
comma
id|de-&gt;inode.dentry
comma
id|de-&gt;inode.dentry-&gt;d_name.name
comma
id|dentry
comma
id|dentry-&gt;d_name.name
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;  old inode: %p&bslash;n&quot;
comma
id|de-&gt;inode.dentry-&gt;d_inode
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|inode
op_assign
id|iget
(paren
id|sb
comma
id|de-&gt;inode.ino
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
id|de-&gt;inode.dentry
op_assign
id|dentry
suffix:semicolon
r_return
id|inode
suffix:semicolon
)brace
multiline_comment|/*  End Function get_vfs_inode  */
multiline_comment|/*  File operations for device entries follow  */
DECL|function|devfs_read
r_static
id|ssize_t
id|devfs_read
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_mode
)paren
)paren
r_return
op_minus
id|EISDIR
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_read  */
DECL|function|devfs_readdir
r_static
r_int
id|devfs_readdir
(paren
r_struct
id|file
op_star
id|file
comma
r_void
op_star
id|dirent
comma
id|filldir_t
id|filldir
)paren
(brace
r_int
id|err
comma
id|count
suffix:semicolon
r_int
id|stored
op_assign
l_int|0
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|parent
comma
op_star
id|de
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: readdir(): inode is not a directory&bslash;n&quot;
comma
id|DEVFS_NAME
)paren
suffix:semicolon
r_return
op_minus
id|ENOTDIR
suffix:semicolon
)brace
id|fs_info
op_assign
id|inode-&gt;i_sb-&gt;u.generic_sbp
suffix:semicolon
id|parent
op_assign
id|get_devfs_entry_from_vfs_inode
(paren
id|file-&gt;f_dentry-&gt;d_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|file-&gt;f_pos
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_F_READDIR
)paren
id|printk
(paren
l_string|&quot;%s: readdir(): fs_info: %p  pos: %ld&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|fs_info
comma
(paren
r_int
)paren
id|file-&gt;f_pos
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
(paren
r_int
)paren
id|file-&gt;f_pos
)paren
(brace
r_case
l_int|0
suffix:colon
id|scan_dir_for_removable
(paren
id|parent
)paren
suffix:semicolon
id|err
op_assign
(paren
op_star
id|filldir
)paren
(paren
id|dirent
comma
l_string|&quot;..&quot;
comma
l_int|2
comma
id|file-&gt;f_pos
comma
id|file-&gt;f_dentry-&gt;d_parent-&gt;d_inode-&gt;i_ino
comma
id|DT_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EINVAL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|file-&gt;f_pos
op_increment
suffix:semicolon
op_increment
id|stored
suffix:semicolon
multiline_comment|/*  Fall through  */
r_case
l_int|1
suffix:colon
id|err
op_assign
(paren
op_star
id|filldir
)paren
(paren
id|dirent
comma
l_string|&quot;.&quot;
comma
l_int|1
comma
id|file-&gt;f_pos
comma
id|inode-&gt;i_ino
comma
id|DT_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EINVAL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|file-&gt;f_pos
op_increment
suffix:semicolon
op_increment
id|stored
suffix:semicolon
multiline_comment|/*  Fall through  */
r_default
suffix:colon
multiline_comment|/*  Skip entries  */
id|count
op_assign
id|file-&gt;f_pos
op_minus
l_int|2
suffix:semicolon
r_for
c_loop
(paren
id|de
op_assign
id|parent-&gt;u.dir.first
suffix:semicolon
(paren
id|de
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|count
OG
l_int|0
)paren
suffix:semicolon
id|de
op_assign
id|de-&gt;next
)paren
r_if
c_cond
(paren
op_logical_neg
id|IS_HIDDEN
(paren
id|de
)paren
)paren
op_decrement
id|count
suffix:semicolon
multiline_comment|/*  Now add all remaining entries  */
r_for
c_loop
(paren
suffix:semicolon
id|de
op_ne
l_int|NULL
suffix:semicolon
id|de
op_assign
id|de-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|IS_HIDDEN
(paren
id|de
)paren
)paren
r_continue
suffix:semicolon
id|err
op_assign
(paren
op_star
id|filldir
)paren
(paren
id|dirent
comma
id|de-&gt;name
comma
id|de-&gt;namelen
comma
id|file-&gt;f_pos
comma
id|de-&gt;inode.ino
comma
id|de-&gt;mode
op_rshift
l_int|12
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
op_minus
id|EINVAL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|file-&gt;f_pos
op_increment
suffix:semicolon
op_increment
id|stored
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
id|stored
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_readdir  */
DECL|function|devfs_open
r_static
r_int
id|devfs_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|fcb_type
op_star
id|df
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
op_assign
id|inode-&gt;i_sb-&gt;u.generic_sbp
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|de
op_assign
id|get_devfs_entry_from_vfs_inode
(paren
id|inode
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|S_ISDIR
(paren
id|de-&gt;mode
)paren
)paren
r_goto
id|out
suffix:semicolon
id|df
op_assign
op_amp
id|de-&gt;u.fcb
suffix:semicolon
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
r_goto
id|out
suffix:semicolon
id|file-&gt;private_data
op_assign
id|de-&gt;info
suffix:semicolon
r_if
c_cond
(paren
id|S_ISBLK
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|file-&gt;f_op
op_assign
op_amp
id|def_blk_fops
suffix:semicolon
r_if
c_cond
(paren
id|df-&gt;ops
)paren
id|inode-&gt;i_bdev-&gt;bd_op
op_assign
id|df-&gt;ops
suffix:semicolon
)brace
r_else
id|file-&gt;f_op
op_assign
id|fops_get
c_func
(paren
(paren
r_struct
id|file_operations
op_star
)paren
id|df-&gt;ops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_op
)paren
id|err
op_assign
id|file-&gt;f_op-&gt;open
ques
c_cond
(paren
op_star
id|file-&gt;f_op-&gt;open
)paren
(paren
id|inode
comma
id|file
)paren
suffix:colon
l_int|0
suffix:semicolon
r_else
(brace
multiline_comment|/*  Fallback to legacy scheme  */
multiline_comment|/*&n;&t; * Do we need it? Richard, could you verify it?&n;&t; * It can legitimately happen if&n;&t; *&t;it is a character device and &n;&t; *&t;df-&gt;ops == NULL and&n;&t; *&t;de-&gt;registered is true,&n;&t; * but AFAICS it can&squot;t happen - in devfs_register() we never set&n;&t; * -&gt;ops to NULL, in unregister() we set -&gt;registered to false,&n;&t; * in devfs_mknod() we set it to NULL only if -&gt;register is false.&n;&t; *&n;&t; * Looks like this fallback is not needed at all.&n;&t; *&t;&t;&t;&t;&t;&t;&t;AV&n;&t; */
r_if
c_cond
(paren
id|S_ISCHR
(paren
id|inode-&gt;i_mode
)paren
)paren
id|err
op_assign
id|chrdev_open
(paren
id|inode
comma
id|file
)paren
suffix:semicolon
r_else
id|err
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*  Open was successful  */
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|df-&gt;open
)paren
r_goto
id|out
suffix:semicolon
id|df-&gt;open
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*  This is the first open  */
r_if
c_cond
(paren
id|df-&gt;auto_owner
)paren
(brace
multiline_comment|/*  Change the ownership/protection  */
id|de-&gt;inode.mode
op_assign
(paren
id|de-&gt;inode.mode
op_amp
op_complement
id|S_IALLUGO
)paren
op_or
(paren
id|de-&gt;mode
op_amp
id|S_IRWXUGO
)paren
suffix:semicolon
id|de-&gt;inode.uid
op_assign
id|current-&gt;euid
suffix:semicolon
id|de-&gt;inode.gid
op_assign
id|current-&gt;egid
suffix:semicolon
id|inode-&gt;i_mode
op_assign
id|de-&gt;inode.mode
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|de-&gt;inode.uid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|de-&gt;inode.gid
suffix:semicolon
)brace
r_if
c_cond
(paren
id|df-&gt;aopen_notify
)paren
id|devfsd_notify_one
(paren
id|de
comma
id|DEVFSD_NOTIFY_ASYNC_OPEN
comma
id|inode-&gt;i_mode
comma
id|current-&gt;euid
comma
id|current-&gt;egid
comma
id|fs_info
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_open  */
DECL|variable|devfs_fops
r_static
r_struct
id|file_operations
id|devfs_fops
op_assign
(brace
id|read
suffix:colon
id|devfs_read
comma
id|readdir
suffix:colon
id|devfs_readdir
comma
id|open
suffix:colon
id|devfs_open
comma
)brace
suffix:semicolon
multiline_comment|/*  Dentry operations for device entries follow  */
multiline_comment|/**&n; *&t;devfs_d_release - Callback for when a dentry is freed.&n; *&t;@dentry: The dentry.&n; */
DECL|function|devfs_d_release
r_static
r_void
id|devfs_d_release
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_D_RELEASE
)paren
id|printk
(paren
l_string|&quot;%s: d_release(): dentry: %p inode: %p&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|dentry
comma
id|inode
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*  End Function devfs_d_release  */
multiline_comment|/**&n; *&t;devfs_d_iput - Callback for when a dentry loses its inode.&n; *&t;@dentry: The dentry.&n; *&t;@inode:&t;The inode.&n; */
DECL|function|devfs_d_iput
r_static
r_void
id|devfs_d_iput
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
id|lock_kernel
(paren
)paren
suffix:semicolon
id|de
op_assign
id|get_devfs_entry_from_vfs_inode
(paren
id|inode
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_D_IPUT
)paren
id|printk
(paren
l_string|&quot;%s: d_iput(): dentry: %p inode: %p de: %p  de-&gt;dentry: %p&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|dentry
comma
id|inode
comma
id|de
comma
id|de-&gt;inode.dentry
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|de-&gt;inode.dentry
op_eq
id|dentry
)paren
id|de-&gt;inode.dentry
op_assign
l_int|NULL
suffix:semicolon
id|unlock_kernel
(paren
)paren
suffix:semicolon
id|iput
(paren
id|inode
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_d_iput  */
r_static
r_int
id|devfs_d_delete
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
suffix:semicolon
DECL|variable|devfs_dops
r_static
r_struct
id|dentry_operations
id|devfs_dops
op_assign
(brace
id|d_delete
suffix:colon
id|devfs_d_delete
comma
id|d_release
suffix:colon
id|devfs_d_release
comma
id|d_iput
suffix:colon
id|devfs_d_iput
comma
)brace
suffix:semicolon
r_static
r_int
id|devfs_d_revalidate_wait
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|flags
)paren
suffix:semicolon
DECL|variable|devfs_wait_dops
r_static
r_struct
id|dentry_operations
id|devfs_wait_dops
op_assign
(brace
id|d_delete
suffix:colon
id|devfs_d_delete
comma
id|d_release
suffix:colon
id|devfs_d_release
comma
id|d_iput
suffix:colon
id|devfs_d_iput
comma
id|d_revalidate
suffix:colon
id|devfs_d_revalidate_wait
comma
)brace
suffix:semicolon
multiline_comment|/**&n; *&t;devfs_d_delete - Callback for when all files for a dentry are closed.&n; *&t;@dentry: The dentry.&n; */
DECL|function|devfs_d_delete
r_static
r_int
id|devfs_d_delete
(paren
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_op
op_eq
op_amp
id|devfs_wait_dops
)paren
id|dentry-&gt;d_op
op_assign
op_amp
id|devfs_dops
suffix:semicolon
multiline_comment|/*  Unhash dentry if negative (has no inode)  */
r_if
c_cond
(paren
id|inode
op_eq
l_int|NULL
)paren
(brace
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_D_DELETE
)paren
id|printk
(paren
l_string|&quot;%s: d_delete(): dropping negative dentry: %p&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|dentry
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
id|fs_info
op_assign
id|inode-&gt;i_sb-&gt;u.generic_sbp
suffix:semicolon
id|de
op_assign
id|get_devfs_entry_from_vfs_inode
(paren
id|inode
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_D_DELETE
)paren
id|printk
(paren
l_string|&quot;%s: d_delete(): dentry: %p  inode: %p  devfs_entry: %p&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|dentry
comma
id|inode
comma
id|de
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISCHR
(paren
id|de-&gt;mode
)paren
op_logical_and
op_logical_neg
id|S_ISBLK
(paren
id|de-&gt;mode
)paren
op_logical_and
op_logical_neg
id|S_ISREG
(paren
id|de-&gt;mode
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;u.fcb.open
)paren
r_return
l_int|0
suffix:semicolon
id|de-&gt;u.fcb.open
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;u.fcb.aopen_notify
)paren
id|devfsd_notify_one
(paren
id|de
comma
id|DEVFSD_NOTIFY_CLOSE
comma
id|inode-&gt;i_mode
comma
id|current-&gt;euid
comma
id|current-&gt;egid
comma
id|fs_info
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;u.fcb.auto_owner
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*  Change the ownership/protection back  */
id|de-&gt;inode.mode
op_assign
(paren
id|de-&gt;inode.mode
op_amp
op_complement
id|S_IALLUGO
)paren
op_or
id|S_IRUGO
op_or
id|S_IWUGO
suffix:semicolon
id|de-&gt;inode.uid
op_assign
id|de-&gt;u.fcb.default_uid
suffix:semicolon
id|de-&gt;inode.gid
op_assign
id|de-&gt;u.fcb.default_gid
suffix:semicolon
id|inode-&gt;i_mode
op_assign
id|de-&gt;inode.mode
suffix:semicolon
id|inode-&gt;i_uid
op_assign
id|de-&gt;inode.uid
suffix:semicolon
id|inode-&gt;i_gid
op_assign
id|de-&gt;inode.gid
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_d_delete  */
DECL|function|devfs_d_revalidate_wait
r_static
r_int
id|devfs_d_revalidate_wait
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|flags
)paren
(brace
id|devfs_handle_t
id|de
op_assign
id|dentry-&gt;d_fsdata
suffix:semicolon
r_struct
id|inode
op_star
id|dir
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
suffix:semicolon
id|lock_kernel
(paren
)paren
suffix:semicolon
id|dir
op_assign
id|dentry-&gt;d_parent-&gt;d_inode
suffix:semicolon
id|fs_info
op_assign
id|dir-&gt;i_sb-&gt;u.generic_sbp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de
op_logical_or
id|de-&gt;registered
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dentry-&gt;d_inode
op_logical_and
id|is_devfsd_or_child
(paren
id|fs_info
)paren
)paren
(brace
r_struct
id|inode
op_star
id|inode
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_char
id|txt
(braket
id|STRING_LENGTH
)braket
suffix:semicolon
id|memset
(paren
id|txt
comma
l_int|0
comma
id|STRING_LENGTH
)paren
suffix:semicolon
id|memcpy
(paren
id|txt
comma
id|dentry-&gt;d_name.name
comma
(paren
id|dentry-&gt;d_name.len
op_ge
id|STRING_LENGTH
)paren
ques
c_cond
(paren
id|STRING_LENGTH
op_minus
l_int|1
)paren
suffix:colon
id|dentry-&gt;d_name.len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_I_LOOKUP
)paren
id|printk
(paren
l_string|&quot;%s: d_revalidate(): dentry: %p name: &bslash;&quot;%s&bslash;&quot; by: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|dentry
comma
id|txt
comma
id|current-&gt;comm
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
(brace
id|devfs_handle_t
id|parent
suffix:semicolon
id|parent
op_assign
id|get_devfs_entry_from_vfs_inode
(paren
id|dir
)paren
suffix:semicolon
id|de
op_assign
id|search_for_entry_in_dir
(paren
id|parent
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
id|FALSE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*  Create an inode, now that the driver information is available&n;&t;     */
r_if
c_cond
(paren
id|de-&gt;no_persistence
)paren
id|update_devfs_inode_from_entry
(paren
id|de
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|de-&gt;inode.ctime
op_eq
l_int|0
)paren
id|update_devfs_inode_from_entry
(paren
id|de
)paren
suffix:semicolon
r_else
id|de-&gt;inode.mode
op_assign
(paren
id|de-&gt;mode
op_amp
op_complement
id|S_IALLUGO
)paren
op_or
(paren
id|de-&gt;inode.mode
op_amp
id|S_IALLUGO
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inode
op_assign
id|get_vfs_inode
(paren
id|dir-&gt;i_sb
comma
id|de
comma
id|dentry
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_I_LOOKUP
)paren
id|printk
(paren
l_string|&quot;%s: d_revalidate(): new VFS inode(%u): %p  devfs_entry: %p&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|de-&gt;inode.ino
comma
id|inode
comma
id|de
)paren
suffix:semicolon
macro_line|#endif
id|d_instantiate
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|wait_for_devfsd_finished
(paren
id|fs_info
)paren
)paren
id|dentry-&gt;d_op
op_assign
op_amp
id|devfs_dops
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_d_revalidate_wait  */
multiline_comment|/*  Inode operations for device entries follow  */
DECL|function|devfs_lookup
r_static
r_struct
id|dentry
op_star
id|devfs_lookup
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|fs_info
op_star
id|fs_info
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|parent
comma
op_star
id|de
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_char
id|txt
(braket
id|STRING_LENGTH
)braket
suffix:semicolon
multiline_comment|/*  Set up the dentry operations before anything else, to ensure cleaning&n;&t;up on any error  */
id|dentry-&gt;d_op
op_assign
op_amp
id|devfs_dops
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;%s: lookup(): NULL directory inode&bslash;n&quot;
comma
id|DEVFS_NAME
)paren
suffix:semicolon
r_return
id|ERR_PTR
(paren
op_minus
id|ENOTDIR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
(paren
id|dir-&gt;i_mode
)paren
)paren
r_return
id|ERR_PTR
(paren
op_minus
id|ENOTDIR
)paren
suffix:semicolon
id|memset
(paren
id|txt
comma
l_int|0
comma
id|STRING_LENGTH
)paren
suffix:semicolon
id|memcpy
(paren
id|txt
comma
id|dentry-&gt;d_name.name
comma
(paren
id|dentry-&gt;d_name.len
op_ge
id|STRING_LENGTH
)paren
ques
c_cond
(paren
id|STRING_LENGTH
op_minus
l_int|1
)paren
suffix:colon
id|dentry-&gt;d_name.len
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_I_LOOKUP
)paren
id|printk
(paren
l_string|&quot;%s: lookup(%s): dentry: %p by: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|txt
comma
id|dentry
comma
id|current-&gt;comm
)paren
suffix:semicolon
macro_line|#endif
id|fs_info
op_assign
id|dir-&gt;i_sb-&gt;u.generic_sbp
suffix:semicolon
multiline_comment|/*  First try to get the devfs entry for this directory  */
id|parent
op_assign
id|get_devfs_entry_from_vfs_inode
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_eq
l_int|NULL
)paren
r_return
id|ERR_PTR
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent-&gt;registered
)paren
r_return
id|ERR_PTR
(paren
op_minus
id|ENOENT
)paren
suffix:semicolon
multiline_comment|/*  Try to reclaim an existing devfs entry  */
id|de
op_assign
id|search_for_entry_in_dir
(paren
id|parent
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|de
op_eq
l_int|NULL
)paren
op_logical_or
op_logical_neg
id|de-&gt;registered
)paren
op_logical_and
(paren
id|parent-&gt;u.dir.num_removable
OG
l_int|0
)paren
op_logical_and
id|get_removable_partition
(paren
id|parent
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
)paren
)paren
(brace
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
id|de
op_assign
id|search_for_entry_in_dir
(paren
id|parent
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
id|FALSE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|de
op_eq
l_int|NULL
)paren
op_logical_or
op_logical_neg
id|de-&gt;registered
)paren
(brace
multiline_comment|/*  Try with devfsd. For any kind of failure, leave a negative dentry&n;&t;    so someone else can deal with it (in the case where the sysadmin&n;&t;    does a mknod()). It&squot;s important to do this before hashing the&n;&t;    dentry, so that the devfsd queue is filled before revalidates&n;&t;    can start  */
r_if
c_cond
(paren
id|try_modload
(paren
id|parent
comma
id|fs_info
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
id|txt
)paren
OL
l_int|0
)paren
(brace
id|d_add
(paren
id|dentry
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*  devfsd claimed success  */
id|dentry-&gt;d_op
op_assign
op_amp
id|devfs_wait_dops
suffix:semicolon
id|dentry-&gt;d_fsdata
op_assign
id|de
suffix:semicolon
id|d_add
(paren
id|dentry
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*  Open the floodgates  */
multiline_comment|/*  Unlock directory semaphore, which will release any waiters. They&n;&t;    will get the hashed dentry, and may be forced to wait for&n;&t;    revalidation  */
id|up
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
id|devfs_d_revalidate_wait
(paren
id|dentry
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*  I might have to wait too  */
id|down
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
multiline_comment|/*  Grab it again because them&squot;s the rules  */
multiline_comment|/*  If someone else has been so kind as to make the inode, we go home&n;&t;    early  */
r_if
c_cond
(paren
id|dentry-&gt;d_inode
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|de
op_logical_and
op_logical_neg
id|de-&gt;registered
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
id|de
op_assign
id|search_for_entry_in_dir
(paren
id|parent
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/*  OK, there&squot;s an entry now, but no VFS inode yet  */
)brace
r_else
(brace
id|dentry-&gt;d_op
op_assign
op_amp
id|devfs_wait_dops
suffix:semicolon
id|d_add
(paren
id|dentry
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*  Open the floodgates  */
)brace
multiline_comment|/*  Create an inode, now that the driver information is available  */
r_if
c_cond
(paren
id|de-&gt;no_persistence
)paren
id|update_devfs_inode_from_entry
(paren
id|de
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|de-&gt;inode.ctime
op_eq
l_int|0
)paren
id|update_devfs_inode_from_entry
(paren
id|de
)paren
suffix:semicolon
r_else
id|de-&gt;inode.mode
op_assign
(paren
id|de-&gt;mode
op_amp
op_complement
id|S_IALLUGO
)paren
op_or
(paren
id|de-&gt;inode.mode
op_amp
id|S_IALLUGO
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inode
op_assign
id|get_vfs_inode
(paren
id|dir-&gt;i_sb
comma
id|de
comma
id|dentry
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
id|ERR_PTR
(paren
op_minus
id|ENOMEM
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_I_LOOKUP
)paren
id|printk
(paren
l_string|&quot;%s: lookup(): new VFS inode(%u): %p  devfs_entry: %p&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|de-&gt;inode.ino
comma
id|inode
comma
id|de
)paren
suffix:semicolon
macro_line|#endif
id|d_instantiate
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
multiline_comment|/*  Unlock directory semaphore, which will release any waiters. They will&n;&t;get the hashed dentry, and may be forced to wait for revalidation  */
id|up
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dentry-&gt;d_op
op_eq
op_amp
id|devfs_wait_dops
)paren
id|devfs_d_revalidate_wait
(paren
id|dentry
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*  I might have to wait too  */
id|down
(paren
op_amp
id|dir-&gt;i_sem
)paren
suffix:semicolon
multiline_comment|/*  Grab it again because them&squot;s the rules  */
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_lookup  */
DECL|function|devfs_link
r_static
r_int
id|devfs_link
(paren
r_struct
id|dentry
op_star
id|old_dentry
comma
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
multiline_comment|/*struct inode *inode = old_dentry-&gt;d_inode;*/
r_char
id|txt
(braket
id|STRING_LENGTH
)braket
suffix:semicolon
id|memset
(paren
id|txt
comma
l_int|0
comma
id|STRING_LENGTH
)paren
suffix:semicolon
id|memcpy
(paren
id|txt
comma
id|old_dentry-&gt;d_name.name
comma
id|old_dentry-&gt;d_name.len
)paren
suffix:semicolon
id|txt
(braket
id|STRING_LENGTH
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: link of &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|txt
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_link  */
DECL|function|devfs_unlink
r_static
r_int
id|devfs_unlink
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_char
id|txt
(braket
id|STRING_LENGTH
)braket
suffix:semicolon
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_I_UNLINK
)paren
(brace
id|memset
(paren
id|txt
comma
l_int|0
comma
id|STRING_LENGTH
)paren
suffix:semicolon
id|memcpy
(paren
id|txt
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
)paren
suffix:semicolon
id|txt
(braket
id|STRING_LENGTH
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: unlink(%s)&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|txt
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|dir
op_logical_or
op_logical_neg
id|S_ISDIR
(paren
id|dir-&gt;i_mode
)paren
)paren
r_return
op_minus
id|ENOTDIR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
op_logical_or
op_logical_neg
id|dentry-&gt;d_inode
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|de
op_assign
id|get_devfs_entry_from_vfs_inode
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|de-&gt;registered
op_assign
id|FALSE
suffix:semicolon
id|de-&gt;hide
op_assign
id|TRUE
suffix:semicolon
id|free_dentries
(paren
id|de
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_unlink  */
DECL|function|devfs_symlink
r_static
r_int
id|devfs_symlink
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_const
r_char
op_star
id|symname
)paren
(brace
r_int
id|err
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|parent
comma
op_star
id|de
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
op_logical_or
op_logical_neg
id|S_ISDIR
(paren
id|dir-&gt;i_mode
)paren
)paren
r_return
op_minus
id|ENOTDIR
suffix:semicolon
id|fs_info
op_assign
id|dir-&gt;i_sb-&gt;u.generic_sbp
suffix:semicolon
multiline_comment|/*  First try to get the devfs entry for this directory  */
id|parent
op_assign
id|get_devfs_entry_from_vfs_inode
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent-&gt;registered
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
id|err
op_assign
id|devfs_mk_symlink
(paren
id|parent
comma
id|dentry-&gt;d_name.name
comma
id|DEVFS_FL_NONE
comma
id|symname
comma
op_amp
id|de
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_DISABLED
)paren
id|printk
(paren
l_string|&quot;%s: symlink(): errcode from &lt;devfs_mk_symlink&gt;: %d&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|err
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
id|de-&gt;inode.mode
op_assign
id|de-&gt;mode
suffix:semicolon
id|de-&gt;inode.atime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|de-&gt;inode.mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|de-&gt;inode.ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inode
op_assign
id|get_vfs_inode
(paren
id|dir-&gt;i_sb
comma
id|de
comma
id|dentry
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_DISABLED
)paren
id|printk
(paren
l_string|&quot;%s: symlink(): new VFS inode(%u): %p  dentry: %p&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|de-&gt;inode.ino
comma
id|inode
comma
id|dentry
)paren
suffix:semicolon
macro_line|#endif
id|de-&gt;hide
op_assign
id|FALSE
suffix:semicolon
id|d_instantiate
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|devfsd_notify_one
(paren
id|de
comma
id|DEVFSD_NOTIFY_CREATE
comma
id|inode-&gt;i_mode
comma
id|inode-&gt;i_uid
comma
id|inode-&gt;i_gid
comma
id|fs_info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_symlink  */
DECL|function|devfs_mkdir
r_static
r_int
id|devfs_mkdir
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
)paren
(brace
r_int
id|is_new
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|parent
comma
op_star
id|de
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
id|mode
op_assign
(paren
id|mode
op_amp
op_complement
id|S_IFMT
)paren
op_or
id|S_IFDIR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
op_logical_or
op_logical_neg
id|S_ISDIR
(paren
id|dir-&gt;i_mode
)paren
)paren
r_return
op_minus
id|ENOTDIR
suffix:semicolon
id|fs_info
op_assign
id|dir-&gt;i_sb-&gt;u.generic_sbp
suffix:semicolon
multiline_comment|/*  We are allowed to create the directory  */
multiline_comment|/*  First try to get the devfs entry for this directory  */
id|parent
op_assign
id|get_devfs_entry_from_vfs_inode
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent-&gt;registered
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
multiline_comment|/*  Try to reclaim an existing devfs entry, create if there isn&squot;t one  */
id|de
op_assign
id|search_for_entry
(paren
id|parent
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
id|FALSE
comma
id|TRUE
comma
op_amp
id|is_new
comma
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|de-&gt;registered
)paren
(brace
id|printk
(paren
l_string|&quot;%s: mkdir(): existing entry&bslash;n&quot;
comma
id|DEVFS_NAME
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
id|de-&gt;registered
op_assign
id|TRUE
suffix:semicolon
id|de-&gt;hide
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
(paren
id|de-&gt;mode
)paren
op_logical_and
op_logical_neg
id|is_new
)paren
(brace
multiline_comment|/*  Transmogrifying an old entry  */
id|de-&gt;u.dir.first
op_assign
l_int|NULL
suffix:semicolon
id|de-&gt;u.dir.last
op_assign
l_int|NULL
suffix:semicolon
)brace
id|de-&gt;mode
op_assign
id|mode
suffix:semicolon
id|de-&gt;u.dir.num_removable
op_assign
l_int|0
suffix:semicolon
id|de-&gt;inode.mode
op_assign
id|mode
suffix:semicolon
id|de-&gt;inode.uid
op_assign
id|current-&gt;euid
suffix:semicolon
id|de-&gt;inode.gid
op_assign
id|current-&gt;egid
suffix:semicolon
id|de-&gt;inode.atime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|de-&gt;inode.mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|de-&gt;inode.ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inode
op_assign
id|get_vfs_inode
(paren
id|dir-&gt;i_sb
comma
id|de
comma
id|dentry
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_DISABLED
)paren
id|printk
(paren
l_string|&quot;%s: mkdir(): new VFS inode(%u): %p  dentry: %p&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|de-&gt;inode.ino
comma
id|inode
comma
id|dentry
)paren
suffix:semicolon
macro_line|#endif
id|d_instantiate
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|devfsd_notify_one
(paren
id|de
comma
id|DEVFSD_NOTIFY_CREATE
comma
id|inode-&gt;i_mode
comma
id|inode-&gt;i_uid
comma
id|inode-&gt;i_gid
comma
id|fs_info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_mkdir  */
DECL|function|devfs_rmdir
r_static
r_int
id|devfs_rmdir
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_int
id|has_children
op_assign
id|FALSE
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|de
comma
op_star
id|child
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dir
op_logical_or
op_logical_neg
id|S_ISDIR
(paren
id|dir-&gt;i_mode
)paren
)paren
r_return
op_minus
id|ENOTDIR
suffix:semicolon
r_if
c_cond
(paren
id|dir-&gt;i_sb-&gt;u.generic_sbp
op_ne
id|inode-&gt;i_sb-&gt;u.generic_sbp
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_eq
id|dir
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|fs_info
op_assign
id|dir-&gt;i_sb-&gt;u.generic_sbp
suffix:semicolon
id|de
op_assign
id|get_devfs_entry_from_vfs_inode
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISDIR
(paren
id|de-&gt;mode
)paren
)paren
r_return
op_minus
id|ENOTDIR
suffix:semicolon
r_for
c_loop
(paren
id|child
op_assign
id|de-&gt;u.dir.first
suffix:semicolon
id|child
op_ne
l_int|NULL
suffix:semicolon
id|child
op_assign
id|child-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|child-&gt;registered
)paren
(brace
id|has_children
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|has_children
)paren
r_return
op_minus
id|ENOTEMPTY
suffix:semicolon
id|de-&gt;registered
op_assign
id|FALSE
suffix:semicolon
id|de-&gt;hide
op_assign
id|TRUE
suffix:semicolon
id|free_dentries
(paren
id|de
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_rmdir  */
DECL|function|devfs_mknod
r_static
r_int
id|devfs_mknod
(paren
r_struct
id|inode
op_star
id|dir
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|mode
comma
r_int
id|rdev
)paren
(brace
r_int
id|is_new
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
suffix:semicolon
r_struct
id|devfs_entry
op_star
id|parent
comma
op_star
id|de
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_char
id|txt
(braket
id|STRING_LENGTH
)braket
suffix:semicolon
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_I_MKNOD
)paren
(brace
id|memset
(paren
id|txt
comma
l_int|0
comma
id|STRING_LENGTH
)paren
suffix:semicolon
id|memcpy
(paren
id|txt
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
)paren
suffix:semicolon
id|txt
(braket
id|STRING_LENGTH
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: mknod(%s): mode: 0%o  dev: %d&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|txt
comma
id|mode
comma
id|rdev
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|dir
op_logical_or
op_logical_neg
id|S_ISDIR
(paren
id|dir-&gt;i_mode
)paren
)paren
r_return
op_minus
id|ENOTDIR
suffix:semicolon
id|fs_info
op_assign
id|dir-&gt;i_sb-&gt;u.generic_sbp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISBLK
(paren
id|mode
)paren
op_logical_and
op_logical_neg
id|S_ISCHR
(paren
id|mode
)paren
op_logical_and
op_logical_neg
id|S_ISFIFO
(paren
id|mode
)paren
op_logical_and
op_logical_neg
id|S_ISSOCK
(paren
id|mode
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/*  We are allowed to create the node  */
multiline_comment|/*  First try to get the devfs entry for this directory  */
id|parent
op_assign
id|get_devfs_entry_from_vfs_inode
(paren
id|dir
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parent-&gt;registered
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
multiline_comment|/*  Try to reclaim an existing devfs entry, create if there isn&squot;t one  */
id|de
op_assign
id|search_for_entry
(paren
id|parent
comma
id|dentry-&gt;d_name.name
comma
id|dentry-&gt;d_name.len
comma
id|FALSE
comma
id|TRUE
comma
op_amp
id|is_new
comma
id|FALSE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|de
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|de-&gt;registered
)paren
(brace
multiline_comment|/*  Since we created the devfs entry we get to choose things  */
id|de-&gt;info
op_assign
l_int|NULL
suffix:semicolon
id|de-&gt;mode
op_assign
id|mode
suffix:semicolon
r_if
c_cond
(paren
id|S_ISBLK
(paren
id|mode
)paren
op_logical_or
id|S_ISCHR
(paren
id|mode
)paren
)paren
(brace
id|de-&gt;u.fcb.u.device.major
op_assign
id|MAJOR
(paren
id|rdev
)paren
suffix:semicolon
id|de-&gt;u.fcb.u.device.minor
op_assign
id|MINOR
(paren
id|rdev
)paren
suffix:semicolon
id|de-&gt;u.fcb.default_uid
op_assign
id|current-&gt;euid
suffix:semicolon
id|de-&gt;u.fcb.default_gid
op_assign
id|current-&gt;egid
suffix:semicolon
id|de-&gt;u.fcb.ops
op_assign
l_int|NULL
suffix:semicolon
id|de-&gt;u.fcb.auto_owner
op_assign
id|FALSE
suffix:semicolon
id|de-&gt;u.fcb.aopen_notify
op_assign
id|FALSE
suffix:semicolon
id|de-&gt;u.fcb.open
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISFIFO
(paren
id|mode
)paren
)paren
(brace
id|de-&gt;u.fifo.uid
op_assign
id|current-&gt;euid
suffix:semicolon
id|de-&gt;u.fifo.gid
op_assign
id|current-&gt;egid
suffix:semicolon
)brace
)brace
id|de-&gt;registered
op_assign
id|TRUE
suffix:semicolon
id|de-&gt;show_unreg
op_assign
id|FALSE
suffix:semicolon
id|de-&gt;hide
op_assign
id|FALSE
suffix:semicolon
id|de-&gt;inode.mode
op_assign
id|mode
suffix:semicolon
id|de-&gt;inode.uid
op_assign
id|current-&gt;euid
suffix:semicolon
id|de-&gt;inode.gid
op_assign
id|current-&gt;egid
suffix:semicolon
id|de-&gt;inode.atime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|de-&gt;inode.mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|de-&gt;inode.ctime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inode
op_assign
id|get_vfs_inode
(paren
id|dir-&gt;i_sb
comma
id|de
comma
id|dentry
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_I_MKNOD
)paren
id|printk
(paren
l_string|&quot;%s:   new VFS inode(%u): %p  dentry: %p&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|de-&gt;inode.ino
comma
id|inode
comma
id|dentry
)paren
suffix:semicolon
macro_line|#endif
id|d_instantiate
(paren
id|dentry
comma
id|inode
)paren
suffix:semicolon
id|devfsd_notify_one
(paren
id|de
comma
id|DEVFSD_NOTIFY_CREATE
comma
id|inode-&gt;i_mode
comma
id|inode-&gt;i_uid
comma
id|inode-&gt;i_gid
comma
id|fs_info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_mknod  */
DECL|function|devfs_readlink
r_static
r_int
id|devfs_readlink
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_char
op_star
id|buffer
comma
r_int
id|buflen
)paren
(brace
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
id|lock_kernel
(paren
)paren
suffix:semicolon
id|de
op_assign
id|get_devfs_entry_from_vfs_inode
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
id|unlock_kernel
(paren
)paren
suffix:semicolon
r_return
id|vfs_readlink
(paren
id|dentry
comma
id|buffer
comma
id|buflen
comma
id|de-&gt;u.symlink.linkname
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_readlink  */
DECL|function|devfs_follow_link
r_static
r_int
id|devfs_follow_link
(paren
r_struct
id|dentry
op_star
id|dentry
comma
r_struct
id|nameidata
op_star
id|nd
)paren
(brace
r_struct
id|devfs_entry
op_star
id|de
suffix:semicolon
id|lock_kernel
(paren
)paren
suffix:semicolon
id|de
op_assign
id|get_devfs_entry_from_vfs_inode
(paren
id|dentry-&gt;d_inode
)paren
suffix:semicolon
id|unlock_kernel
(paren
)paren
suffix:semicolon
r_return
id|vfs_follow_link
(paren
id|nd
comma
id|de-&gt;u.symlink.linkname
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_follow_link  */
DECL|variable|devfs_iops
r_static
r_struct
id|inode_operations
id|devfs_iops
op_assign
(brace
id|link
suffix:colon
id|devfs_link
comma
id|unlink
suffix:colon
id|devfs_unlink
comma
id|symlink
suffix:colon
id|devfs_symlink
comma
id|mkdir
suffix:colon
id|devfs_mkdir
comma
id|rmdir
suffix:colon
id|devfs_rmdir
comma
id|mknod
suffix:colon
id|devfs_mknod
comma
id|setattr
suffix:colon
id|devfs_notify_change
comma
)brace
suffix:semicolon
DECL|variable|devfs_dir_iops
r_static
r_struct
id|inode_operations
id|devfs_dir_iops
op_assign
(brace
id|lookup
suffix:colon
id|devfs_lookup
comma
id|link
suffix:colon
id|devfs_link
comma
id|unlink
suffix:colon
id|devfs_unlink
comma
id|symlink
suffix:colon
id|devfs_symlink
comma
id|mkdir
suffix:colon
id|devfs_mkdir
comma
id|rmdir
suffix:colon
id|devfs_rmdir
comma
id|mknod
suffix:colon
id|devfs_mknod
comma
id|setattr
suffix:colon
id|devfs_notify_change
comma
)brace
suffix:semicolon
DECL|variable|devfs_symlink_iops
r_static
r_struct
id|inode_operations
id|devfs_symlink_iops
op_assign
(brace
id|readlink
suffix:colon
id|devfs_readlink
comma
id|follow_link
suffix:colon
id|devfs_follow_link
comma
id|setattr
suffix:colon
id|devfs_notify_change
comma
)brace
suffix:semicolon
DECL|function|devfs_read_super
r_static
r_struct
id|super_block
op_star
id|devfs_read_super
(paren
r_struct
id|super_block
op_star
id|sb
comma
r_void
op_star
id|data
comma
r_int
id|silent
)paren
(brace
r_struct
id|inode
op_star
id|root_inode
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|get_root_entry
(paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|out_no_root
suffix:semicolon
id|atomic_set
(paren
op_amp
id|fs_info.devfsd_overrun_count
comma
l_int|0
)paren
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|fs_info.devfsd_wait_queue
)paren
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|fs_info.revalidate_wait_queue
)paren
suffix:semicolon
id|fs_info.sb
op_assign
id|sb
suffix:semicolon
id|sb-&gt;u.generic_sbp
op_assign
op_amp
id|fs_info
suffix:semicolon
id|sb-&gt;s_blocksize
op_assign
l_int|1024
suffix:semicolon
id|sb-&gt;s_blocksize_bits
op_assign
l_int|10
suffix:semicolon
id|sb-&gt;s_magic
op_assign
id|DEVFS_SUPER_MAGIC
suffix:semicolon
id|sb-&gt;s_op
op_assign
op_amp
id|devfs_sops
suffix:semicolon
r_if
c_cond
(paren
(paren
id|root_inode
op_assign
id|get_vfs_inode
(paren
id|sb
comma
id|root_entry
comma
l_int|NULL
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|out_no_root
suffix:semicolon
id|sb-&gt;s_root
op_assign
id|d_alloc_root
(paren
id|root_inode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sb-&gt;s_root
)paren
r_goto
id|out_no_root
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_if
c_cond
(paren
id|devfs_debug
op_amp
id|DEBUG_DISABLED
)paren
id|printk
(paren
l_string|&quot;%s: read super, made devfs ptr: %p&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|sb-&gt;u.generic_sbp
)paren
suffix:semicolon
macro_line|#endif
r_return
id|sb
suffix:semicolon
id|out_no_root
suffix:colon
id|printk
(paren
l_string|&quot;devfs_read_super: get root inode failed&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|root_inode
)paren
id|iput
(paren
id|root_inode
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*  End Function devfs_read_super  */
r_static
id|DECLARE_FSTYPE
(paren
id|devfs_fs_type
comma
id|DEVFS_NAME
comma
id|devfs_read_super
comma
id|FS_SINGLE
)paren
suffix:semicolon
multiline_comment|/*  File operations for devfsd follow  */
DECL|function|devfsd_read
r_static
id|ssize_t
id|devfsd_read
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
id|done
op_assign
id|FALSE
suffix:semicolon
r_int
id|ival
suffix:semicolon
id|loff_t
id|pos
comma
id|devname_offset
comma
id|tlen
comma
id|rpos
suffix:semicolon
r_struct
id|devfsd_notify_struct
id|info
suffix:semicolon
r_struct
id|devfsd_buf_entry
op_star
id|entry
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
op_assign
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_sb-&gt;u.generic_sbp
suffix:semicolon
id|DECLARE_WAITQUEUE
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
multiline_comment|/*  Can&squot;t seek (pread) on this device  */
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
multiline_comment|/*  Verify the task has grabbed the queue  */
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_task
op_ne
id|current
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|info.major
op_assign
l_int|0
suffix:semicolon
id|info.minor
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*  Block for a new entry  */
id|add_wait_queue
(paren
op_amp
id|fs_info-&gt;devfsd_wait_queue
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_while
c_loop
(paren
id|devfsd_queue_empty
(paren
id|fs_info
)paren
)paren
(brace
id|fs_info-&gt;devfsd_sleeping
op_assign
id|TRUE
suffix:semicolon
id|wake_up
(paren
op_amp
id|fs_info-&gt;revalidate_wait_queue
)paren
suffix:semicolon
id|schedule
(paren
)paren
suffix:semicolon
id|fs_info-&gt;devfsd_sleeping
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
(paren
id|current
)paren
)paren
(brace
id|remove_wait_queue
(paren
op_amp
id|fs_info-&gt;devfsd_wait_queue
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
)brace
id|remove_wait_queue
(paren
op_amp
id|fs_info-&gt;devfsd_wait_queue
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
multiline_comment|/*  Now play with the data  */
id|ival
op_assign
id|atomic_read
(paren
op_amp
id|fs_info-&gt;devfsd_overrun_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ival
OG
l_int|0
)paren
id|atomic_sub
(paren
id|ival
comma
op_amp
id|fs_info-&gt;devfsd_overrun_count
)paren
suffix:semicolon
id|info.overrun_count
op_assign
id|ival
suffix:semicolon
id|entry
op_assign
(paren
r_struct
id|devfsd_buf_entry
op_star
)paren
id|fs_info-&gt;devfsd_buffer
op_plus
id|fs_info-&gt;devfsd_buf_out
suffix:semicolon
id|info.type
op_assign
id|entry-&gt;type
suffix:semicolon
id|info.mode
op_assign
id|entry-&gt;mode
suffix:semicolon
id|info.uid
op_assign
id|entry-&gt;uid
suffix:semicolon
id|info.gid
op_assign
id|entry-&gt;gid
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;type
op_eq
id|DEVFSD_NOTIFY_LOOKUP
)paren
(brace
id|info.namelen
op_assign
id|strlen
(paren
id|entry-&gt;data
)paren
suffix:semicolon
id|pos
op_assign
l_int|0
suffix:semicolon
id|memcpy
(paren
id|info.devname
comma
id|entry-&gt;data
comma
id|info.namelen
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|devfs_handle_t
id|de
op_assign
id|entry-&gt;data
suffix:semicolon
r_if
c_cond
(paren
id|S_ISCHR
(paren
id|de-&gt;mode
)paren
op_logical_or
id|S_ISBLK
(paren
id|de-&gt;mode
)paren
op_logical_or
id|S_ISREG
(paren
id|de-&gt;mode
)paren
)paren
(brace
id|info.major
op_assign
id|de-&gt;u.fcb.u.device.major
suffix:semicolon
id|info.minor
op_assign
id|de-&gt;u.fcb.u.device.minor
suffix:semicolon
)brace
id|pos
op_assign
id|devfs_generate_path
(paren
id|de
comma
id|info.devname
comma
id|DEVFS_PATHLEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
l_int|0
)paren
r_return
id|pos
suffix:semicolon
id|info.namelen
op_assign
id|DEVFS_PATHLEN
op_minus
id|pos
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|info.mode
op_eq
l_int|0
)paren
id|info.mode
op_assign
id|de-&gt;mode
suffix:semicolon
)brace
id|devname_offset
op_assign
id|info.devname
op_minus
(paren
r_char
op_star
)paren
op_amp
id|info
suffix:semicolon
id|rpos
op_assign
op_star
id|ppos
suffix:semicolon
r_if
c_cond
(paren
id|rpos
OL
id|devname_offset
)paren
(brace
multiline_comment|/*  Copy parts of the header  */
id|tlen
op_assign
id|devname_offset
op_minus
id|rpos
suffix:semicolon
r_if
c_cond
(paren
id|tlen
OG
id|len
)paren
id|tlen
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
id|buf
comma
(paren
r_char
op_star
)paren
op_amp
id|info
op_plus
id|rpos
comma
id|tlen
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|rpos
op_add_assign
id|tlen
suffix:semicolon
id|buf
op_add_assign
id|tlen
suffix:semicolon
id|len
op_sub_assign
id|tlen
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rpos
op_ge
id|devname_offset
)paren
op_logical_and
(paren
id|len
OG
l_int|0
)paren
)paren
(brace
multiline_comment|/*  Copy the name  */
id|tlen
op_assign
id|info.namelen
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tlen
OG
id|len
)paren
id|tlen
op_assign
id|len
suffix:semicolon
r_else
id|done
op_assign
id|TRUE
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
id|buf
comma
id|info.devname
op_plus
id|pos
op_plus
id|rpos
op_minus
id|devname_offset
comma
id|tlen
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|rpos
op_add_assign
id|tlen
suffix:semicolon
)brace
id|tlen
op_assign
id|rpos
op_minus
op_star
id|ppos
suffix:semicolon
r_if
c_cond
(paren
id|done
)paren
(brace
r_int
r_int
id|next_pos
op_assign
id|fs_info-&gt;devfsd_buf_out
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|next_pos
op_ge
id|devfsd_buf_size
)paren
id|next_pos
op_assign
l_int|0
suffix:semicolon
id|fs_info-&gt;devfsd_buf_out
op_assign
id|next_pos
suffix:semicolon
op_star
id|ppos
op_assign
l_int|0
suffix:semicolon
)brace
r_else
op_star
id|ppos
op_assign
id|rpos
suffix:semicolon
r_return
id|tlen
suffix:semicolon
)brace
multiline_comment|/*  End Function devfsd_read  */
DECL|function|devfsd_ioctl
r_static
r_int
id|devfsd_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|ival
suffix:semicolon
r_struct
id|fs_info
op_star
id|fs_info
op_assign
id|inode-&gt;i_sb-&gt;u.generic_sbp
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|DEVFSDIOC_GET_PROTO_REV
suffix:colon
id|ival
op_assign
id|DEVFSD_PROTOCOL_REVISION_KERNEL
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|ival
comma
r_sizeof
id|ival
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEVFSDIOC_SET_EVENT_MASK
suffix:colon
multiline_comment|/*  Ensure only one reader has access to the queue. This scheme will&n;&t;    work even if the global kernel lock were to be removed, because it&n;&t;    doesn&squot;t matter who gets in first, as long as only one gets it  */
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_task
op_eq
l_int|NULL
)paren
(brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*  Looks like no-one has it: check again and grab, with interrupts&n;&t;&t;disabled  */
id|__cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_task
op_eq
l_int|NULL
)paren
macro_line|#endif
(brace
id|fs_info-&gt;devfsd_event_mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*  Temporary disable  */
id|fs_info-&gt;devfsd_task
op_assign
id|current
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
id|__sti
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*  Verify the task has grabbed the queue  */
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_task
op_ne
id|current
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|fs_info-&gt;devfsd_file
op_assign
id|file
suffix:semicolon
id|fs_info-&gt;devfsd_buffer
op_assign
(paren
r_void
op_star
)paren
id|__get_free_page
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_buffer
op_eq
l_int|NULL
)paren
(brace
id|devfsd_close
(paren
id|inode
comma
id|file
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|fs_info-&gt;devfsd_buf_out
op_assign
id|fs_info-&gt;devfsd_buf_in
suffix:semicolon
id|fs_info-&gt;devfsd_event_mask
op_assign
id|arg
suffix:semicolon
multiline_comment|/*  Let the masses come forth  */
r_break
suffix:semicolon
r_case
id|DEVFSDIOC_RELEASE_EVENT_QUEUE
suffix:colon
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_file
op_ne
id|file
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_return
id|devfsd_close
(paren
id|inode
comma
id|file
)paren
suffix:semicolon
multiline_comment|/*break;*/
macro_line|#ifdef CONFIG_DEVFS_DEBUG
r_case
id|DEVFSDIOC_SET_DEBUG_MASK
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|ival
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|ival
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|devfs_debug
op_assign
id|ival
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfsd_ioctl  */
DECL|function|devfsd_close
r_static
r_int
id|devfsd_close
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|fs_info
op_star
id|fs_info
op_assign
id|inode-&gt;i_sb-&gt;u.generic_sbp
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_file
op_ne
id|file
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|fs_info-&gt;devfsd_event_mask
op_assign
l_int|0
suffix:semicolon
id|fs_info-&gt;devfsd_file
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|fs_info-&gt;devfsd_buffer
)paren
(brace
r_while
c_loop
(paren
id|fs_info-&gt;devfsd_buffer_in_use
)paren
id|schedule
(paren
)paren
suffix:semicolon
id|free_page
(paren
(paren
r_int
r_int
)paren
id|fs_info-&gt;devfsd_buffer
)paren
suffix:semicolon
)brace
id|fs_info-&gt;devfsd_buffer
op_assign
l_int|NULL
suffix:semicolon
id|fs_info-&gt;devfsd_task
op_assign
l_int|NULL
suffix:semicolon
id|wake_up
(paren
op_amp
id|fs_info-&gt;revalidate_wait_queue
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function devfsd_close  */
DECL|function|init_devfs_fs
r_int
id|__init
id|init_devfs_fs
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: v%s Richard Gooch (rgooch@atnf.csiro.au)&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|DEVFS_VERSION
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_DEVFS_DEBUG
id|devfs_debug
op_assign
id|devfs_debug_init
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: devfs_debug: 0x%0x&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|devfs_debug
)paren
suffix:semicolon
macro_line|#endif
id|printk
(paren
l_string|&quot;%s: boot_options: 0x%0x&bslash;n&quot;
comma
id|DEVFS_NAME
comma
id|boot_options
)paren
suffix:semicolon
id|err
op_assign
id|register_filesystem
(paren
op_amp
id|devfs_fs_type
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
r_struct
id|vfsmount
op_star
id|devfs_mnt
op_assign
id|kern_mount
(paren
op_amp
id|devfs_fs_type
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
(paren
id|devfs_mnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_ERR
(paren
id|devfs_mnt
)paren
)paren
id|err
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*  End Function init_devfs_fs  */
DECL|function|mount_devfs_fs
r_void
id|__init
id|mount_devfs_fs
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|boot_options
op_amp
id|OPTION_NOMOUNT
)paren
)paren
r_return
suffix:semicolon
id|err
op_assign
id|do_mount
(paren
l_string|&quot;none&quot;
comma
l_string|&quot;/dev&quot;
comma
l_string|&quot;devfs&quot;
comma
l_int|0
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_eq
l_int|0
)paren
id|printk
(paren
l_string|&quot;Mounted devfs on /dev&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;Warning: unable to mount devfs, err: %d&bslash;n&quot;
comma
id|err
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function mount_devfs_fs  */
eof
