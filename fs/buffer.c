multiline_comment|/*&n; *  linux/fs/buffer.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; *  &squot;buffer.c&squot; implements the buffer-cache functions. Race-conditions have&n; * been avoided by NEVER letting an interrupt change a buffer (except for the&n; * data, of course), but instead letting the caller do it.&n; */
multiline_comment|/* Some bdflush() changes for the dynamic ramdisk - Paul Gortmaker, 12/94 */
multiline_comment|/* Start bdflush() with kernel_thread not syscall - Paul Gortmaker, 12/95 */
multiline_comment|/* Removed a lot of unnecessary code and simplified things now that&n; * the buffer cache isn&squot;t our primary cache - Andrew Tridgell 12/96&n; */
multiline_comment|/* Speed up hash, lru, and free list operations.  Use gfp() for allocating&n; * hash table, use SLAB cache for buffer heads. -DaveM&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/pagemap.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/swapctl.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/sysrq.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/quotaops.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
DECL|macro|NR_SIZES
mdefine_line|#define NR_SIZES 5
DECL|variable|buffersize_index
r_static
r_char
id|buffersize_index
(braket
l_int|17
)braket
op_assign
(brace
op_minus
l_int|1
comma
l_int|0
comma
l_int|1
comma
op_minus
l_int|1
comma
l_int|2
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|3
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|4
)brace
suffix:semicolon
DECL|macro|BUFSIZE_INDEX
mdefine_line|#define BUFSIZE_INDEX(X) ((int) buffersize_index[(X)&gt;&gt;9])
DECL|macro|MAX_BUF_PER_PAGE
mdefine_line|#define MAX_BUF_PER_PAGE (PAGE_SIZE / 512)
DECL|macro|NR_RESERVED
mdefine_line|#define NR_RESERVED (2*MAX_BUF_PER_PAGE)
DECL|macro|MAX_UNUSED_BUFFERS
mdefine_line|#define MAX_UNUSED_BUFFERS NR_RESERVED+20 /* don&squot;t ever have more than this &n;&t;&t;&t;&t;&t;     number of unused buffer heads */
multiline_comment|/*&n; * Hash table mask..&n; */
DECL|variable|bh_hash_mask
r_static
r_int
r_int
id|bh_hash_mask
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|grow_buffers
c_func
(paren
r_int
id|pri
comma
r_int
id|size
)paren
suffix:semicolon
DECL|variable|hash_table
r_static
r_struct
id|buffer_head
op_star
op_star
id|hash_table
suffix:semicolon
DECL|variable|lru_list
r_static
r_struct
id|buffer_head
op_star
id|lru_list
(braket
id|NR_LIST
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|free_list
r_static
r_struct
id|buffer_head
op_star
id|free_list
(braket
id|NR_SIZES
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|bh_cachep
r_static
id|kmem_cache_t
op_star
id|bh_cachep
suffix:semicolon
DECL|variable|unused_list
r_static
r_struct
id|buffer_head
op_star
id|unused_list
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|reuse_list
r_static
r_struct
id|buffer_head
op_star
id|reuse_list
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|buffer_wait
r_static
r_struct
id|wait_queue
op_star
id|buffer_wait
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|nr_buffers
r_static
r_int
id|nr_buffers
op_assign
l_int|0
suffix:semicolon
DECL|variable|nr_buffers_type
r_static
r_int
id|nr_buffers_type
(braket
id|NR_LIST
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|nr_buffer_heads
r_static
r_int
id|nr_buffer_heads
op_assign
l_int|0
suffix:semicolon
DECL|variable|nr_unused_buffer_heads
r_static
r_int
id|nr_unused_buffer_heads
op_assign
l_int|0
suffix:semicolon
DECL|variable|refilled
r_static
r_int
id|refilled
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set NZ when a buffer freelist is refilled &n;&t;&t;&t;&t;  this is used by the loop device */
multiline_comment|/* This is used by some architectures to estimate available memory. */
DECL|variable|buffermem
r_int
id|buffermem
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Here is the parameter block for the bdflush process. If you add or&n; * remove any of the parameters, make sure to update kernel/sysctl.c.&n; */
DECL|macro|N_PARAM
mdefine_line|#define N_PARAM 9
multiline_comment|/* The dummy values in this structure are left in there for compatibility&n; * with old programs that play with the /proc entries.&n; */
DECL|union|bdflush_param
r_union
id|bdflush_param
(brace
r_struct
(brace
DECL|member|nfract
r_int
id|nfract
suffix:semicolon
multiline_comment|/* Percentage of buffer cache dirty to &n;&t;&t;&t;&t;activate bdflush */
DECL|member|ndirty
r_int
id|ndirty
suffix:semicolon
multiline_comment|/* Maximum number of dirty blocks to write out per&n;&t;&t;&t;&t;wake-cycle */
DECL|member|nrefill
r_int
id|nrefill
suffix:semicolon
multiline_comment|/* Number of clean buffers to try to obtain&n;&t;&t;&t;&t;each time we call refill */
DECL|member|nref_dirt
r_int
id|nref_dirt
suffix:semicolon
multiline_comment|/* Dirty buffer threshold for activating bdflush&n;&t;&t;&t;&t;  when trying to refill buffers. */
DECL|member|dummy1
r_int
id|dummy1
suffix:semicolon
multiline_comment|/* unused */
DECL|member|age_buffer
r_int
id|age_buffer
suffix:semicolon
multiline_comment|/* Time for normal buffer to age before &n;&t;&t;&t;&t;    we flush it */
DECL|member|age_super
r_int
id|age_super
suffix:semicolon
multiline_comment|/* Time for superblock to age before we &n;&t;&t;&t;&t;   flush it */
DECL|member|dummy2
r_int
id|dummy2
suffix:semicolon
multiline_comment|/* unused */
DECL|member|dummy3
r_int
id|dummy3
suffix:semicolon
multiline_comment|/* unused */
DECL|member|b_un
)brace
id|b_un
suffix:semicolon
DECL|member|data
r_int
r_int
id|data
(braket
id|N_PARAM
)braket
suffix:semicolon
DECL|variable|bdf_prm
)brace
id|bdf_prm
op_assign
(brace
(brace
l_int|40
comma
l_int|500
comma
l_int|64
comma
l_int|256
comma
l_int|15
comma
l_int|30
op_star
id|HZ
comma
l_int|5
op_star
id|HZ
comma
l_int|1884
comma
l_int|2
)brace
)brace
suffix:semicolon
multiline_comment|/* These are the min and max parameter values that we will allow to be assigned */
DECL|variable|bdflush_min
r_int
id|bdflush_min
(braket
id|N_PARAM
)braket
op_assign
(brace
l_int|0
comma
l_int|10
comma
l_int|5
comma
l_int|25
comma
l_int|0
comma
l_int|100
comma
l_int|100
comma
l_int|1
comma
l_int|1
)brace
suffix:semicolon
DECL|variable|bdflush_max
r_int
id|bdflush_max
(braket
id|N_PARAM
)braket
op_assign
(brace
l_int|100
comma
l_int|5000
comma
l_int|2000
comma
l_int|2000
comma
l_int|100
comma
l_int|60000
comma
l_int|60000
comma
l_int|2047
comma
l_int|5
)brace
suffix:semicolon
r_void
id|wakeup_bdflush
c_func
(paren
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * Rewrote the wait-routines to use the &quot;new&quot; wait-queue functionality,&n; * and getting rid of the cli-sti pairs. The wait-queue routines still&n; * need cli-sti, but now it&squot;s just a couple of 386 instructions or so.&n; *&n; * Note that the real wait_on_buffer() is an inline function that checks&n; * if &squot;b_wait&squot; is set before calling this, so that the queues aren&squot;t set&n; * up unnecessarily.&n; */
DECL|function|__wait_on_buffer
r_void
id|__wait_on_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_struct
id|wait_queue
id|wait
suffix:semicolon
id|bh-&gt;b_count
op_increment
suffix:semicolon
id|wait.task
op_assign
id|tsk
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|bh-&gt;b_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|repeat
suffix:colon
id|tsk-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|bh-&gt;b_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|bh-&gt;b_count
op_decrement
suffix:semicolon
)brace
multiline_comment|/* Call sync_buffers with wait!=0 to ensure that the call does not&n; * return until all buffer writes have completed.  Sync() may return&n; * before the writes have finished; fsync() may not.&n; */
multiline_comment|/* Godamity-damn.  Some buffers (bitmaps for filesystems)&n; * spontaneously dirty themselves without ever brelse being called.&n; * We will ultimately want to put these in a separate list, but for&n; * now we search all of the lists for dirty buffers.&n; */
DECL|function|sync_buffers
r_static
r_int
id|sync_buffers
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|wait
)paren
(brace
r_int
id|i
comma
id|retry
comma
id|pass
op_assign
l_int|0
comma
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|next
suffix:semicolon
multiline_comment|/* One pass for no-wait, three for wait:&n;&t; * 0) write out all dirty, unlocked buffers;&n;&t; * 1) write out all dirty buffers, waiting if locked;&n;&t; * 2) wait for completion by waiting for all buffers to unlock.&n;&t; */
r_do
(brace
id|retry
op_assign
l_int|0
suffix:semicolon
id|repeat
suffix:colon
multiline_comment|/* We search all lists as a failsafe mechanism, not because we expect&n;&t;&t; * there to be dirty buffers on any of the other lists.&n;&t;&t; */
id|bh
op_assign
id|lru_list
(braket
id|BUF_DIRTY
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|repeat2
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nr_buffers_type
(braket
id|BUF_DIRTY
)braket
op_star
l_int|2
suffix:semicolon
id|i
op_decrement
OG
l_int|0
suffix:semicolon
id|bh
op_assign
id|next
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_list
op_ne
id|BUF_DIRTY
)paren
r_goto
id|repeat
suffix:semicolon
id|next
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lru_list
(braket
id|BUF_DIRTY
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_logical_and
id|bh-&gt;b_dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* Buffer is locked; skip it unless wait is&n;&t;&t;&t;&t; * requested AND pass &gt; 0.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|wait
op_logical_or
op_logical_neg
id|pass
)paren
(brace
id|retry
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|wait_on_buffer
(paren
id|bh
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/* If an unlocked buffer is not uptodate, there has&n;&t;&t;&t; * been an IO error. Skip it.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|wait
op_logical_and
id|buffer_req
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t write clean buffers.  Don&squot;t write ANY buffers&n;&t;&t;&t; * on the third pass.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
op_logical_or
id|pass
op_ge
l_int|2
)paren
r_continue
suffix:semicolon
multiline_comment|/* Don&squot;t bother about locked buffers.&n;&t;&t;&t; *&n;&t;&t;&t; * XXX We checked if it was locked above and there is no&n;&t;&t;&t; * XXX way we could have slept in between. -DaveM&n;&t;&t;&t; */
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
id|bh-&gt;b_count
op_increment
suffix:semicolon
id|next-&gt;b_count
op_increment
suffix:semicolon
id|bh-&gt;b_flushtime
op_assign
l_int|0
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_count
op_decrement
suffix:semicolon
id|next-&gt;b_count
op_decrement
suffix:semicolon
id|retry
op_assign
l_int|1
suffix:semicolon
)brace
id|repeat2
suffix:colon
id|bh
op_assign
id|lru_list
(braket
id|BUF_LOCKED
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_break
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nr_buffers_type
(braket
id|BUF_LOCKED
)braket
op_star
l_int|2
suffix:semicolon
id|i
op_decrement
OG
l_int|0
suffix:semicolon
id|bh
op_assign
id|next
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_list
op_ne
id|BUF_LOCKED
)paren
r_goto
id|repeat2
suffix:semicolon
id|next
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lru_list
(braket
id|BUF_LOCKED
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_logical_and
id|bh-&gt;b_dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* Buffer is locked; skip it unless wait is&n;&t;&t;&t;&t; * requested AND pass &gt; 0.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|wait
op_logical_or
op_logical_neg
id|pass
)paren
(brace
id|retry
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|wait_on_buffer
(paren
id|bh
)paren
suffix:semicolon
r_goto
id|repeat2
suffix:semicolon
)brace
)brace
multiline_comment|/* If we are waiting for the sync to succeed, and if any dirty&n;&t;&t; * blocks were written, then repeat; on the second pass, only&n;&t;&t; * wait for buffers being written (do not pass to write any&n;&t;&t; * more buffers on the second pass).&n;&t;&t; */
)brace
r_while
c_loop
(paren
id|wait
op_logical_and
id|retry
op_logical_and
op_increment
id|pass
op_le
l_int|2
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sync_dev
r_void
id|sync_dev
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
id|sync_buffers
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|sync_supers
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sync_inodes
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sync_buffers
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|DQUOT_SYNC
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME(eric) we need to sync the physical devices here.&n;&t; * This is because some (scsi) controllers have huge amounts of&n;&t; * cache onboard (hundreds of Mb), and we need to instruct&n;&t; * them to commit all of the dirty memory to disk, and we should&n;&t; * not return until this has happened.&n;&t; *&n;&t; * This would need to get implemented by going through the assorted&n;&t; * layers so that each block major number can be synced, and this&n;&t; * would call down into the upper and mid-layer scsi.&n;&t; */
)brace
DECL|function|fsync_dev
r_int
id|fsync_dev
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
id|sync_buffers
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|sync_supers
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sync_inodes
c_func
(paren
id|dev
)paren
suffix:semicolon
id|DQUOT_SYNC
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sync_buffers
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|sys_sync
id|asmlinkage
r_int
id|sys_sync
c_func
(paren
r_void
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|fsync_dev
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;filp may be NULL if called via the msync of a vma.&n; */
DECL|function|file_fsync
r_int
id|file_fsync
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|dentry
op_star
id|dentry
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
multiline_comment|/* sync the inode to buffers */
id|write_inode_now
c_func
(paren
id|inode
)paren
suffix:semicolon
multiline_comment|/* sync the superblock to buffers */
id|sb
op_assign
id|inode-&gt;i_sb
suffix:semicolon
id|wait_on_super
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;s_op
op_logical_and
id|sb-&gt;s_op-&gt;write_super
)paren
id|sb-&gt;s_op
op_member_access_from_pointer
id|write_super
c_func
(paren
id|sb
)paren
suffix:semicolon
multiline_comment|/* .. finally sync the buffers to disk */
id|dev
op_assign
id|inode-&gt;i_dev
suffix:semicolon
r_return
id|sync_buffers
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|sys_fsync
id|asmlinkage
r_int
id|sys_fsync
c_func
(paren
r_int
r_int
id|fd
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|err
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_goto
id|out_putf
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|out_putf
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_op
op_logical_or
op_logical_neg
id|file-&gt;f_op-&gt;fsync
)paren
r_goto
id|out_putf
suffix:semicolon
multiline_comment|/* We need to protect against concurrent writers.. */
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|err
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|fsync
c_func
(paren
id|file
comma
id|dentry
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|out_putf
suffix:colon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sys_fdatasync
id|asmlinkage
r_int
id|sys_fdatasync
c_func
(paren
r_int
r_int
id|fd
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|err
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dentry
)paren
r_goto
id|out_putf
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_goto
id|out_putf
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_op
op_logical_or
op_logical_neg
id|file-&gt;f_op-&gt;fsync
)paren
r_goto
id|out_putf
suffix:semicolon
multiline_comment|/* this needs further work, at the moment it is identical to fsync() */
id|err
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|fsync
c_func
(paren
id|file
comma
id|dentry
)paren
suffix:semicolon
id|out_putf
suffix:colon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|invalidate_buffers
r_void
id|invalidate_buffers
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|nlist
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_for
c_loop
(paren
id|nlist
op_assign
l_int|0
suffix:semicolon
id|nlist
OL
id|NR_LIST
suffix:semicolon
id|nlist
op_increment
)paren
(brace
id|bh
op_assign
id|lru_list
(braket
id|nlist
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nr_buffers_type
(braket
id|nlist
)braket
op_star
l_int|2
suffix:semicolon
op_decrement
id|i
OG
l_int|0
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_next_free
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_count
)paren
r_continue
suffix:semicolon
id|bh-&gt;b_flushtime
op_assign
l_int|0
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Protected
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Dirty
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Req
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|macro|_hashfn
mdefine_line|#define _hashfn(dev,block) (((unsigned)(HASHDEV(dev)^block)) &amp; bh_hash_mask)
DECL|macro|hash
mdefine_line|#define hash(dev,block) hash_table[_hashfn(dev,block)]
DECL|function|remove_from_hash_queue
r_static
r_inline
r_void
id|remove_from_hash_queue
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_pprev
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_next
)paren
(brace
id|bh-&gt;b_next-&gt;b_pprev
op_assign
id|bh-&gt;b_pprev
suffix:semicolon
)brace
op_star
id|bh-&gt;b_pprev
op_assign
id|bh-&gt;b_next
suffix:semicolon
id|bh-&gt;b_pprev
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|remove_from_lru_list
r_static
r_inline
r_void
id|remove_from_lru_list
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh-&gt;b_prev_free
)paren
op_logical_or
op_logical_neg
(paren
id|bh-&gt;b_next_free
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;VFS: LRU block list corrupted&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_eq
id|B_FREE
)paren
id|panic
c_func
(paren
l_string|&quot;LRU list corrupted&quot;
)paren
suffix:semicolon
id|bh-&gt;b_prev_free-&gt;b_next_free
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
id|bh-&gt;b_next_free-&gt;b_prev_free
op_assign
id|bh-&gt;b_prev_free
suffix:semicolon
r_if
c_cond
(paren
id|lru_list
(braket
id|bh-&gt;b_list
)braket
op_eq
id|bh
)paren
id|lru_list
(braket
id|bh-&gt;b_list
)braket
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_if
c_cond
(paren
id|lru_list
(braket
id|bh-&gt;b_list
)braket
op_eq
id|bh
)paren
id|lru_list
(braket
id|bh-&gt;b_list
)braket
op_assign
l_int|NULL
suffix:semicolon
id|bh-&gt;b_next_free
op_assign
id|bh-&gt;b_prev_free
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|remove_from_free_list
r_static
r_inline
r_void
id|remove_from_free_list
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_int
id|isize
op_assign
id|BUFSIZE_INDEX
c_func
(paren
id|bh-&gt;b_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh-&gt;b_prev_free
)paren
op_logical_or
op_logical_neg
(paren
id|bh-&gt;b_next_free
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;VFS: Free block list corrupted&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_ne
id|B_FREE
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Free list corrupted&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|free_list
(braket
id|isize
)braket
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Free list empty&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bh-&gt;b_next_free
op_eq
id|bh
)paren
(brace
id|free_list
(braket
id|isize
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|bh-&gt;b_prev_free-&gt;b_next_free
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
id|bh-&gt;b_next_free-&gt;b_prev_free
op_assign
id|bh-&gt;b_prev_free
suffix:semicolon
r_if
c_cond
(paren
id|free_list
(braket
id|isize
)braket
op_eq
id|bh
)paren
id|free_list
(braket
id|isize
)braket
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
)brace
id|bh-&gt;b_next_free
op_assign
id|bh-&gt;b_prev_free
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|remove_from_queues
r_static
r_inline
r_void
id|remove_from_queues
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_eq
id|B_FREE
)paren
(brace
id|remove_from_free_list
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* Free list entries should not be&n;&t;&t;&t;&t;&t;      in the hash queue */
r_return
suffix:semicolon
)brace
id|nr_buffers_type
(braket
id|bh-&gt;b_list
)braket
op_decrement
suffix:semicolon
id|remove_from_hash_queue
c_func
(paren
id|bh
)paren
suffix:semicolon
id|remove_from_lru_list
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
DECL|function|put_last_lru
r_static
r_inline
r_void
id|put_last_lru
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh
)paren
(brace
r_struct
id|buffer_head
op_star
op_star
id|bhp
op_assign
op_amp
id|lru_list
(braket
id|bh-&gt;b_list
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bh
op_eq
op_star
id|bhp
)paren
(brace
op_star
id|bhp
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_eq
id|B_FREE
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Wrong block for lru list&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Add to back of free list. */
id|remove_from_lru_list
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|bhp
)paren
(brace
op_star
id|bhp
op_assign
id|bh
suffix:semicolon
(paren
op_star
id|bhp
)paren
op_member_access_from_pointer
id|b_prev_free
op_assign
id|bh
suffix:semicolon
)brace
id|bh-&gt;b_next_free
op_assign
op_star
id|bhp
suffix:semicolon
id|bh-&gt;b_prev_free
op_assign
(paren
op_star
id|bhp
)paren
op_member_access_from_pointer
id|b_prev_free
suffix:semicolon
(paren
op_star
id|bhp
)paren
op_member_access_from_pointer
id|b_prev_free-&gt;b_next_free
op_assign
id|bh
suffix:semicolon
(paren
op_star
id|bhp
)paren
op_member_access_from_pointer
id|b_prev_free
op_assign
id|bh
suffix:semicolon
)brace
)brace
DECL|function|put_last_free
r_static
r_inline
r_void
id|put_last_free
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh
)paren
(brace
r_struct
id|buffer_head
op_star
op_star
id|bhp
op_assign
op_amp
id|free_list
(braket
id|BUFSIZE_INDEX
c_func
(paren
id|bh-&gt;b_size
)paren
)braket
suffix:semicolon
id|bh-&gt;b_dev
op_assign
id|B_FREE
suffix:semicolon
multiline_comment|/* So it is obvious we are on the free list. */
multiline_comment|/* Add to back of free list. */
r_if
c_cond
(paren
op_logical_neg
op_star
id|bhp
)paren
(brace
op_star
id|bhp
op_assign
id|bh
suffix:semicolon
id|bh-&gt;b_prev_free
op_assign
id|bh
suffix:semicolon
)brace
id|bh-&gt;b_next_free
op_assign
op_star
id|bhp
suffix:semicolon
id|bh-&gt;b_prev_free
op_assign
(paren
op_star
id|bhp
)paren
op_member_access_from_pointer
id|b_prev_free
suffix:semicolon
(paren
op_star
id|bhp
)paren
op_member_access_from_pointer
id|b_prev_free-&gt;b_next_free
op_assign
id|bh
suffix:semicolon
(paren
op_star
id|bhp
)paren
op_member_access_from_pointer
id|b_prev_free
op_assign
id|bh
suffix:semicolon
)brace
)brace
DECL|function|insert_into_queues
r_static
r_inline
r_void
id|insert_into_queues
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
multiline_comment|/* put at end of free list */
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_eq
id|B_FREE
)paren
(brace
id|put_last_free
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|buffer_head
op_star
op_star
id|bhp
op_assign
op_amp
id|lru_list
(braket
id|bh-&gt;b_list
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|bhp
)paren
(brace
op_star
id|bhp
op_assign
id|bh
suffix:semicolon
id|bh-&gt;b_prev_free
op_assign
id|bh
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bh-&gt;b_next_free
)paren
id|panic
c_func
(paren
l_string|&quot;VFS: buffer LRU pointers corrupted&quot;
)paren
suffix:semicolon
id|bh-&gt;b_next_free
op_assign
op_star
id|bhp
suffix:semicolon
id|bh-&gt;b_prev_free
op_assign
(paren
op_star
id|bhp
)paren
op_member_access_from_pointer
id|b_prev_free
suffix:semicolon
(paren
op_star
id|bhp
)paren
op_member_access_from_pointer
id|b_prev_free-&gt;b_next_free
op_assign
id|bh
suffix:semicolon
(paren
op_star
id|bhp
)paren
op_member_access_from_pointer
id|b_prev_free
op_assign
id|bh
suffix:semicolon
id|nr_buffers_type
(braket
id|bh-&gt;b_list
)braket
op_increment
suffix:semicolon
multiline_comment|/* Put the buffer in new hash-queue if it has a device. */
r_if
c_cond
(paren
id|bh-&gt;b_dev
)paren
(brace
r_struct
id|buffer_head
op_star
op_star
id|bhp
op_assign
op_amp
id|hash
c_func
(paren
id|bh-&gt;b_dev
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bh-&gt;b_next
op_assign
op_star
id|bhp
)paren
op_ne
l_int|NULL
)paren
(brace
(paren
op_star
id|bhp
)paren
op_member_access_from_pointer
id|b_pprev
op_assign
op_amp
id|bh-&gt;b_next
suffix:semicolon
)brace
op_star
id|bhp
op_assign
id|bh
suffix:semicolon
id|bh-&gt;b_pprev
op_assign
id|bhp
suffix:semicolon
multiline_comment|/* Exists in bh hashes. */
)brace
r_else
id|bh-&gt;b_pprev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Not in bh hashes. */
)brace
)brace
DECL|function|find_buffer
r_struct
id|buffer_head
op_star
id|find_buffer
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|next
suffix:semicolon
id|next
op_assign
id|hash
c_func
(paren
id|dev
comma
id|block
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_struct
id|buffer_head
op_star
id|tmp
op_assign
id|next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|next
)paren
r_break
suffix:semicolon
id|next
op_assign
id|tmp-&gt;b_next
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;b_blocknr
op_ne
id|block
op_logical_or
id|tmp-&gt;b_size
op_ne
id|size
op_logical_or
id|tmp-&gt;b_dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
id|next
op_assign
id|tmp
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|next
suffix:semicolon
)brace
multiline_comment|/*&n; * Why like this, I hear you say... The reason is race-conditions.&n; * As we don&squot;t lock buffers (unless we are reading them, that is),&n; * something might happen to it while we sleep (ie a read-error&n; * will force it bad). This shouldn&squot;t really happen currently, but&n; * the code is ready.&n; */
DECL|function|get_hash_table
r_struct
id|buffer_head
op_star
id|get_hash_table
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|bh
op_assign
id|find_buffer
c_func
(paren
id|dev
comma
id|block
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_break
suffix:semicolon
id|bh-&gt;b_count
op_increment
suffix:semicolon
id|bh-&gt;b_lru_time
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
r_break
suffix:semicolon
id|__wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_eq
id|dev
op_logical_and
id|bh-&gt;b_blocknr
op_eq
id|block
op_logical_and
id|bh-&gt;b_size
op_eq
id|size
)paren
r_break
suffix:semicolon
id|bh-&gt;b_count
op_decrement
suffix:semicolon
)brace
r_return
id|bh
suffix:semicolon
)brace
DECL|function|get_hardblocksize
r_int
r_int
id|get_hardblocksize
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
multiline_comment|/*&n;&t; * Get the hard sector size for the given device.  If we don&squot;t know&n;&t; * what it is, return 0.&n;&t; */
r_if
c_cond
(paren
id|hardsect_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
op_ne
l_int|NULL
)paren
(brace
r_int
id|blksize
op_assign
id|hardsect_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|blksize
op_ne
l_int|0
)paren
r_return
id|blksize
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We don&squot;t know what the hardware sector size for this device is.&n;&t; * Return 0 indicating that we don&squot;t know.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|set_blocksize
r_void
id|set_blocksize
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|size
)paren
(brace
r_extern
r_int
op_star
id|blksize_size
(braket
)braket
suffix:semicolon
r_int
id|i
comma
id|nlist
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|bhnext
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|PAGE_SIZE
)paren
id|size
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;Invalid blocksize passed to set_blocksize&quot;
)paren
suffix:semicolon
r_case
l_int|512
suffix:colon
r_case
l_int|1024
suffix:colon
r_case
l_int|2048
suffix:colon
r_case
l_int|4096
suffix:colon
r_case
l_int|8192
suffix:colon
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
op_eq
l_int|0
op_logical_and
id|size
op_eq
id|BLOCK_SIZE
)paren
(brace
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
op_assign
id|size
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
op_eq
id|size
)paren
r_return
suffix:semicolon
id|sync_buffers
c_func
(paren
id|dev
comma
l_int|2
)paren
suffix:semicolon
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
op_assign
id|size
suffix:semicolon
multiline_comment|/* We need to be quite careful how we do this - we are moving entries&n;&t; * around on the free list, and we can get in a loop if we are not careful.&n;&t; */
r_for
c_loop
(paren
id|nlist
op_assign
l_int|0
suffix:semicolon
id|nlist
OL
id|NR_LIST
suffix:semicolon
id|nlist
op_increment
)paren
(brace
id|bh
op_assign
id|lru_list
(braket
id|nlist
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nr_buffers_type
(braket
id|nlist
)braket
op_star
l_int|2
suffix:semicolon
op_decrement
id|i
OG
l_int|0
suffix:semicolon
id|bh
op_assign
id|bhnext
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
r_break
suffix:semicolon
)brace
id|bhnext
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_size
op_eq
id|size
)paren
r_continue
suffix:semicolon
id|bhnext-&gt;b_count
op_increment
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bhnext-&gt;b_count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_eq
id|dev
op_logical_and
id|bh-&gt;b_size
op_ne
id|size
)paren
(brace
id|clear_bit
c_func
(paren
id|BH_Dirty
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Req
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|bh-&gt;b_flushtime
op_assign
l_int|0
suffix:semicolon
)brace
id|remove_from_hash_queue
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Find a candidate buffer to be reclaimed. &n; * N.B. Must search the entire BUF_LOCKED list rather than terminating&n; * when the first locked buffer is found.  Buffers are unlocked at &n; * completion of IO, and under some conditions there may be (many)&n; * unlocked buffers after the first locked one.&n; */
DECL|function|find_candidate
r_static
r_struct
id|buffer_head
op_star
id|find_candidate
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
op_star
id|list_len
comma
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|no_candidate
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
(paren
op_star
id|list_len
)paren
OG
l_int|0
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_next_free
comma
(paren
op_star
id|list_len
)paren
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|size
op_ne
id|bh-&gt;b_size
)paren
(brace
multiline_comment|/* This provides a mechanism for freeing blocks&n;&t;&t;&t; * of other sizes, this is necessary now that we&n;&t;&t;&t; * no longer have the lav code.&n;&t;&t;&t; */
id|try_to_free_buffer
c_func
(paren
id|bh
comma
op_amp
id|bh
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_break
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|bh-&gt;b_count
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_protected
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
r_return
id|bh
suffix:semicolon
)brace
id|no_candidate
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|refill_freelist
r_static
r_void
id|refill_freelist
c_func
(paren
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|next
suffix:semicolon
r_struct
id|buffer_head
op_star
id|candidate
(braket
id|BUF_DIRTY
)braket
suffix:semicolon
r_int
id|buffers
(braket
id|BUF_DIRTY
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|needed
comma
id|obtained
op_assign
l_int|0
suffix:semicolon
id|refilled
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* We are going to try to locate this much memory. */
id|needed
op_assign
id|bdf_prm.b_un.nrefill
op_star
id|size
suffix:semicolon
r_while
c_loop
(paren
(paren
id|nr_free_pages
OG
id|freepages.min
op_star
l_int|2
)paren
op_logical_and
(paren
id|buffermem
op_rshift
id|PAGE_SHIFT
)paren
op_star
l_int|100
OL
(paren
id|buffer_mem.max_percent
op_star
id|num_physpages
)paren
op_logical_and
id|grow_buffers
c_func
(paren
id|GFP_BUFFER
comma
id|size
)paren
)paren
(brace
id|obtained
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|obtained
op_ge
id|needed
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Update the needed amount based on the number of potentially&n;&t; * freeable buffers. We don&squot;t want to free more than one quarter&n;&t; * of the available buffers.&n;&t; */
id|i
op_assign
(paren
id|nr_buffers_type
(braket
id|BUF_CLEAN
)braket
op_plus
id|nr_buffers_type
(braket
id|BUF_LOCKED
)braket
)paren
op_rshift
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|bdf_prm.b_un.nrefill
)paren
(brace
id|needed
op_assign
id|i
op_star
id|size
suffix:semicolon
r_if
c_cond
(paren
id|needed
OL
id|PAGE_SIZE
)paren
id|needed
op_assign
id|PAGE_SIZE
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * OK, we cannot grow the buffer cache, now try to get some&n;&t; * from the lru list.&n;&t; */
id|repeat
suffix:colon
r_if
c_cond
(paren
id|obtained
op_ge
id|needed
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * First set the candidate pointers to usable buffers.  This&n;&t; * should be quick nearly all of the time.  N.B. There must be &n;&t; * no blocking calls after setting up the candidate[] array!&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
id|BUF_CLEAN
suffix:semicolon
id|i
OL
id|BUF_DIRTY
suffix:semicolon
id|i
op_increment
)paren
(brace
id|buffers
(braket
id|i
)braket
op_assign
id|nr_buffers_type
(braket
id|i
)braket
suffix:semicolon
id|candidate
(braket
id|i
)braket
op_assign
id|find_candidate
c_func
(paren
id|lru_list
(braket
id|i
)braket
comma
op_amp
id|buffers
(braket
id|i
)braket
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Select the older of the available buffers until we reach our goal.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|i
op_assign
id|BUF_CLEAN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|candidate
(braket
id|BUF_CLEAN
)braket
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|candidate
(braket
id|BUF_LOCKED
)braket
)paren
r_break
suffix:semicolon
id|i
op_assign
id|BUF_LOCKED
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|candidate
(braket
id|BUF_LOCKED
)braket
op_logical_and
(paren
id|candidate
(braket
id|BUF_LOCKED
)braket
op_member_access_from_pointer
id|b_lru_time
OL
id|candidate
(braket
id|BUF_CLEAN
)braket
op_member_access_from_pointer
id|b_lru_time
)paren
)paren
id|i
op_assign
id|BUF_LOCKED
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Free the selected buffer and get the next candidate.&n;&t;&t; */
id|bh
op_assign
id|candidate
(braket
id|i
)braket
suffix:semicolon
id|next
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
id|obtained
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
id|remove_from_queues
c_func
(paren
id|bh
)paren
suffix:semicolon
id|put_last_free
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obtained
op_ge
id|needed
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|buffers
(braket
id|i
)braket
op_logical_and
id|bh
op_ne
id|next
)paren
id|candidate
(braket
id|i
)braket
op_assign
id|find_candidate
c_func
(paren
id|next
comma
op_amp
id|buffers
(braket
id|i
)braket
comma
id|size
)paren
suffix:semicolon
r_else
id|candidate
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If there are dirty buffers, do a non-blocking wake-up.&n;&t; * This increases the chances of having buffers available&n;&t; * for the next call ...&n;&t; */
r_if
c_cond
(paren
id|nr_buffers_type
(braket
id|BUF_DIRTY
)braket
)paren
id|wakeup_bdflush
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate buffers to reach half our goal, if possible.&n;&t; * Since the allocation doesn&squot;t block, there&squot;s no reason&n;&t; * to search the buffer lists again. Then return if there&n;&t; * are _any_ free buffers.&n;&t; */
r_while
c_loop
(paren
id|obtained
template_param
id|freepages.min
op_plus
l_int|5
op_logical_and
id|grow_buffers
c_func
(paren
id|GFP_BUFFER
comma
id|size
)paren
)paren
id|obtained
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|free_list
(braket
id|BUFSIZE_INDEX
c_func
(paren
id|size
)paren
)braket
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If there are dirty buffers, wait while bdflush writes&n;&t; * them out. The buffers become locked, but we can just&n;&t; * wait for one to unlock ...&n;&t; */
r_if
c_cond
(paren
id|nr_buffers_type
(braket
id|BUF_DIRTY
)braket
)paren
id|wakeup_bdflush
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * In order to prevent a buffer shortage from exhausting&n;&t; * the system&squot;s reserved pages, we force tasks to wait &n;&t; * before using reserved pages for buffers.  This is easily&n;&t; * accomplished by waiting on an unused locked buffer.&n;&t; */
r_if
c_cond
(paren
(paren
id|bh
op_assign
id|lru_list
(braket
id|BUF_LOCKED
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|nr_buffers_type
(braket
id|BUF_LOCKED
)braket
suffix:semicolon
id|i
op_decrement
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_next_free
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_size
op_ne
id|size
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_count
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
op_logical_or
id|buffer_protected
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|bh-&gt;b_dev
)paren
op_eq
id|LOOP_MAJOR
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We&squot;ve found an unused, locked, non-dirty buffer of&n;&t;&t;&t; * the correct size.  Claim it so no one else can, &n;&t;&t;&t; * then wait for it to unlock.&n;&t;&t;&t; */
id|bh-&gt;b_count
op_increment
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_count
op_decrement
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Loop back to harvest this (and maybe other) buffers.&n;&t;&t;&t; */
r_goto
id|repeat
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Convert a reserved page into buffers ... should happen only rarely.&n;&t; */
r_if
c_cond
(paren
id|grow_buffers
c_func
(paren
id|GFP_ATOMIC
comma
id|size
)paren
)paren
(brace
macro_line|#ifdef BUFFER_DEBUG
id|printk
c_func
(paren
l_string|&quot;refill_freelist: used reserve page&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * System is _very_ low on memory ... sleep and try later.&n;&t; */
macro_line|#ifdef BUFFER_DEBUG
id|printk
c_func
(paren
l_string|&quot;refill_freelist: task %s waiting for buffers&bslash;n&quot;
comma
id|current-&gt;comm
)paren
suffix:semicolon
macro_line|#endif
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
DECL|function|init_buffer
r_void
id|init_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
id|kdev_t
id|dev
comma
r_int
id|block
comma
id|bh_end_io_t
op_star
id|handler
comma
r_void
op_star
id|dev_id
)paren
(brace
id|bh-&gt;b_count
op_assign
l_int|1
suffix:semicolon
id|bh-&gt;b_list
op_assign
id|BUF_CLEAN
suffix:semicolon
id|bh-&gt;b_flushtime
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_dev
op_assign
id|dev
suffix:semicolon
id|bh-&gt;b_blocknr
op_assign
id|block
suffix:semicolon
id|bh-&gt;b_end_io
op_assign
id|handler
suffix:semicolon
id|bh-&gt;b_dev_id
op_assign
id|dev_id
suffix:semicolon
)brace
DECL|function|end_buffer_io_sync
r_static
r_void
id|end_buffer_io_sync
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
id|mark_buffer_uptodate
c_func
(paren
id|bh
comma
id|uptodate
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Ok, this is getblk, and it isn&squot;t very clear, again to hinder&n; * race-conditions. Most of the code is seldom used, (ie repeating),&n; * so it should be much more efficient than it looks.&n; *&n; * The algorithm is changed: hopefully better, and an elusive bug removed.&n; *&n; * 14.02.92: changed it to sync dirty buffers a bit: better performance&n; * when the filesystem starts to get full of dirty blocks (I hope).&n; */
DECL|function|getblk
r_struct
id|buffer_head
op_star
id|getblk
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|isize
suffix:semicolon
id|repeat
suffix:colon
id|bh
op_assign
id|get_hash_table
c_func
(paren
id|dev
comma
id|block
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|put_last_lru
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_flushtime
op_assign
l_int|0
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|BH_Touched
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
id|isize
op_assign
id|BUFSIZE_INDEX
c_func
(paren
id|size
)paren
suffix:semicolon
id|get_free
suffix:colon
id|bh
op_assign
id|free_list
(braket
id|isize
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|refill
suffix:semicolon
id|remove_from_free_list
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* OK, FINALLY we know that this buffer is the only one of its kind,&n;&t; * and that it&squot;s unused (b_count=0), unlocked, and clean.&n;&t; */
id|init_buffer
c_func
(paren
id|bh
comma
id|dev
comma
id|block
comma
id|end_buffer_io_sync
comma
l_int|NULL
)paren
suffix:semicolon
id|bh-&gt;b_lru_time
op_assign
id|jiffies
suffix:semicolon
id|bh-&gt;b_state
op_assign
(paren
l_int|1
op_lshift
id|BH_Touched
)paren
suffix:semicolon
id|insert_into_queues
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
id|bh
suffix:semicolon
multiline_comment|/*&n;&t; * If we block while refilling the free list, somebody may&n;&t; * create the buffer first ... search the hashes again.&n;&t; */
id|refill
suffix:colon
id|refill_freelist
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|find_buffer
c_func
(paren
id|dev
comma
id|block
comma
id|size
)paren
)paren
r_goto
id|get_free
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
DECL|function|set_writetime
r_void
id|set_writetime
c_func
(paren
r_struct
id|buffer_head
op_star
id|buf
comma
r_int
id|flag
)paren
(brace
r_int
id|newtime
suffix:semicolon
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|buf
)paren
)paren
(brace
multiline_comment|/* Move buffer to dirty list if jiffies is clear. */
id|newtime
op_assign
id|jiffies
op_plus
(paren
id|flag
ques
c_cond
id|bdf_prm.b_un.age_super
suffix:colon
id|bdf_prm.b_un.age_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf-&gt;b_flushtime
op_logical_or
id|buf-&gt;b_flushtime
OG
id|newtime
)paren
(brace
id|buf-&gt;b_flushtime
op_assign
id|newtime
suffix:semicolon
)brace
)brace
r_else
(brace
id|buf-&gt;b_flushtime
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Put a buffer into the appropriate list, without side-effects.&n; */
DECL|function|file_buffer
r_static
r_inline
r_void
id|file_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|list
)paren
(brace
id|remove_from_queues
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_list
op_assign
id|list
suffix:semicolon
id|insert_into_queues
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * A buffer may need to be moved from one buffer list to another&n; * (e.g. in case it is not shared any more). Handle this.&n; */
DECL|function|refile_buffer
r_void
id|refile_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|buf
)paren
(brace
r_int
id|dispose
suffix:semicolon
r_if
c_cond
(paren
id|buf-&gt;b_dev
op_eq
id|B_FREE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attempt to refile free buffer&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|buf
)paren
)paren
id|dispose
op_assign
id|BUF_DIRTY
suffix:semicolon
r_else
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|buf
)paren
)paren
id|dispose
op_assign
id|BUF_LOCKED
suffix:semicolon
r_else
id|dispose
op_assign
id|BUF_CLEAN
suffix:semicolon
r_if
c_cond
(paren
id|dispose
op_ne
id|buf-&gt;b_list
)paren
(brace
id|file_buffer
c_func
(paren
id|buf
comma
id|dispose
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dispose
op_eq
id|BUF_DIRTY
)paren
(brace
r_int
id|too_many
op_assign
(paren
id|nr_buffers
op_star
id|bdf_prm.b_un.nfract
op_div
l_int|100
)paren
suffix:semicolon
multiline_comment|/* This buffer is dirty, maybe we need to start flushing.&n;&t;&t;&t; * If too high a percentage of the buffers are dirty...&n;&t;&t;&t; */
r_if
c_cond
(paren
id|nr_buffers_type
(braket
id|BUF_DIRTY
)braket
OG
id|too_many
)paren
id|wakeup_bdflush
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* If this is a loop device, and&n;&t;&t;&t; * more than half of the buffers are dirty...&n;&t;&t;&t; * (Prevents no-free-buffers deadlock with loop device.)&n;&t;&t;&t; */
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|buf-&gt;b_dev
)paren
op_eq
id|LOOP_MAJOR
op_logical_and
id|nr_buffers_type
(braket
id|BUF_DIRTY
)braket
op_star
l_int|2
OG
id|nr_buffers
)paren
id|wakeup_bdflush
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Release a buffer head&n; */
DECL|function|__brelse
r_void
id|__brelse
c_func
(paren
r_struct
id|buffer_head
op_star
id|buf
)paren
(brace
id|wait_on_buffer
c_func
(paren
id|buf
)paren
suffix:semicolon
multiline_comment|/* If dirty, mark the time this buffer should be written back. */
id|set_writetime
c_func
(paren
id|buf
comma
l_int|0
)paren
suffix:semicolon
id|refile_buffer
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf-&gt;b_count
)paren
(brace
id|buf-&gt;b_count
op_decrement
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;VFS: brelse: Trying to free free buffer&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * bforget() is like brelse(), except it removes the buffer&n; * from the hash-queues (so that it won&squot;t be re-used if it&squot;s&n; * shared).&n; */
DECL|function|__bforget
r_void
id|__bforget
c_func
(paren
r_struct
id|buffer_head
op_star
id|buf
)paren
(brace
id|wait_on_buffer
c_func
(paren
id|buf
)paren
suffix:semicolon
id|mark_buffer_clean
c_func
(paren
id|buf
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Protected
comma
op_amp
id|buf-&gt;b_state
)paren
suffix:semicolon
id|buf-&gt;b_count
op_decrement
suffix:semicolon
id|remove_from_hash_queue
c_func
(paren
id|buf
)paren
suffix:semicolon
id|buf-&gt;b_dev
op_assign
id|NODEV
suffix:semicolon
id|refile_buffer
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * bread() reads a specified block and returns the buffer that contains&n; * it. It returns NULL if the block was unreadable.&n; */
DECL|function|bread
r_struct
id|buffer_head
op_star
id|bread
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|getblk
c_func
(paren
id|dev
comma
id|block
comma
id|size
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: bread: impossible error&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_return
id|bh
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_return
id|bh
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Ok, breada can be used as bread, but additionally to mark other&n; * blocks for reading as well. End the argument list with a negative&n; * number.&n; */
DECL|macro|NBUF
mdefine_line|#define NBUF 16
DECL|function|breada
r_struct
id|buffer_head
op_star
id|breada
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|block
comma
r_int
id|bufsize
comma
r_int
r_int
id|pos
comma
r_int
r_int
id|filesize
)paren
(brace
r_struct
id|buffer_head
op_star
id|bhlist
(braket
id|NBUF
)braket
suffix:semicolon
r_int
r_int
id|blocks
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|index
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|filesize
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|block
OL
l_int|0
op_logical_or
op_logical_neg
(paren
id|bh
op_assign
id|getblk
c_func
(paren
id|dev
comma
id|block
comma
id|bufsize
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|index
op_assign
id|BUFSIZE_INDEX
c_func
(paren
id|bh-&gt;b_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_return
id|bh
suffix:semicolon
r_else
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|blocks
op_assign
(paren
id|filesize
op_minus
id|pos
)paren
op_rshift
(paren
l_int|9
op_plus
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blocks
OL
(paren
id|read_ahead
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
op_rshift
id|index
)paren
)paren
id|blocks
op_assign
id|read_ahead
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
op_rshift
id|index
suffix:semicolon
r_if
c_cond
(paren
id|blocks
OG
id|NBUF
)paren
id|blocks
op_assign
id|NBUF
suffix:semicolon
multiline_comment|/*&t;if (blocks) printk(&quot;breada (new) %d blocks&bslash;n&quot;,blocks); */
id|bhlist
(braket
l_int|0
)braket
op_assign
id|bh
suffix:semicolon
id|j
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bh
op_assign
id|getblk
c_func
(paren
id|dev
comma
id|block
op_plus
id|i
comma
id|bufsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
id|bhlist
(braket
id|j
op_increment
)braket
op_assign
id|bh
suffix:semicolon
)brace
multiline_comment|/* Request the read for these buffers, and then release them. */
r_if
c_cond
(paren
id|j
OG
l_int|1
)paren
id|ll_rw_block
c_func
(paren
id|READA
comma
(paren
id|j
op_minus
l_int|1
)paren
comma
id|bhlist
op_plus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|j
suffix:semicolon
id|i
op_increment
)paren
(brace
id|brelse
c_func
(paren
id|bhlist
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait for this buffer, and then continue on. */
id|bh
op_assign
id|bhlist
(braket
l_int|0
)braket
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_return
id|bh
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: the caller should wake up the buffer_wait list if needed.&n; */
DECL|function|put_unused_buffer_head
r_static
r_void
id|put_unused_buffer_head
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|nr_unused_buffer_heads
op_ge
id|MAX_UNUSED_BUFFERS
)paren
(brace
id|nr_buffer_heads
op_decrement
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|bh_cachep
comma
id|bh
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|bh
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|bh
)paren
)paren
suffix:semicolon
id|nr_unused_buffer_heads
op_increment
suffix:semicolon
id|bh-&gt;b_next_free
op_assign
id|unused_list
suffix:semicolon
id|unused_list
op_assign
id|bh
suffix:semicolon
)brace
multiline_comment|/* &n; * We can&squot;t put completed temporary IO buffer_heads directly onto the&n; * unused_list when they become unlocked, since the device driver&n; * end_request routines still expect access to the buffer_head&squot;s&n; * fields after the final unlock.  So, the device driver puts them on&n; * the reuse_list instead once IO completes, and we recover these to&n; * the unused_list here.&n; *&n; * Note that we don&squot;t do a wakeup here, but return a flag indicating&n; * whether we got any buffer heads. A task ready to sleep can check&n; * the returned value, and any tasks already sleeping will have been&n; * awakened when the buffer heads were added to the reuse list.&n; */
DECL|function|recover_reusable_buffer_heads
r_static
r_inline
r_int
id|recover_reusable_buffer_heads
c_func
(paren
r_void
)paren
(brace
r_struct
id|buffer_head
op_star
id|head
op_assign
id|xchg
c_func
(paren
op_amp
id|reuse_list
comma
l_int|NULL
)paren
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|head
)paren
(brace
r_do
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|head
suffix:semicolon
id|head
op_assign
id|head-&gt;b_next_free
suffix:semicolon
id|put_unused_buffer_head
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|head
)paren
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|found
suffix:semicolon
)brace
multiline_comment|/*&n; * Reserve NR_RESERVED buffer heads for async IO requests to avoid&n; * no-buffer-head deadlock.  Return NULL on failure; waiting for&n; * buffer heads is now handled in create_buffers().&n; */
DECL|function|get_unused_buffer_head
r_static
r_struct
id|buffer_head
op_star
id|get_unused_buffer_head
c_func
(paren
r_int
id|async
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|recover_reusable_buffer_heads
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_unused_buffer_heads
OG
id|NR_RESERVED
)paren
(brace
id|bh
op_assign
id|unused_list
suffix:semicolon
id|unused_list
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
id|nr_unused_buffer_heads
op_decrement
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
multiline_comment|/* This is critical.  We can&squot;t swap out pages to get&n;&t; * more buffer heads, because the swap-out may need&n;&t; * more buffer-heads itself.  Thus SLAB_ATOMIC.&n;&t; */
r_if
c_cond
(paren
(paren
id|bh
op_assign
id|kmem_cache_alloc
c_func
(paren
id|bh_cachep
comma
id|SLAB_ATOMIC
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|memset
c_func
(paren
id|bh
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|bh
)paren
)paren
suffix:semicolon
id|nr_buffer_heads
op_increment
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we need an async buffer, use the reserved buffer heads.&n;&t; */
r_if
c_cond
(paren
id|async
op_logical_and
id|unused_list
)paren
(brace
id|bh
op_assign
id|unused_list
suffix:semicolon
id|unused_list
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
id|nr_unused_buffer_heads
op_decrement
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n;&t; * (Pending further analysis ...)&n;&t; * Ordinary (non-async) requests can use a different memory priority&n;&t; * to free up pages. Any swapping thus generated will use async&n;&t; * buffer heads.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|async
op_logical_and
(paren
id|bh
op_assign
id|kmem_cache_alloc
c_func
(paren
id|bh_cachep
comma
id|SLAB_KERNEL
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|memset
c_func
(paren
id|bh
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|bh
)paren
)paren
suffix:semicolon
id|nr_buffer_heads
op_increment
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Create the appropriate buffers when given a page for data area and&n; * the size of each buffer.. Use the bh-&gt;b_this_page linked list to&n; * follow the buffers created.  Return NULL if unable to create more&n; * buffers.&n; * The async flag is used to differentiate async IO (paging, swapping)&n; * from ordinary buffer allocations, and only async requests are allowed&n; * to sleep waiting for buffer heads. &n; */
DECL|function|create_buffers
r_static
r_struct
id|buffer_head
op_star
id|create_buffers
c_func
(paren
r_int
r_int
id|page
comma
r_int
r_int
id|size
comma
r_int
id|async
)paren
(brace
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
r_int
id|offset
suffix:semicolon
id|try_again
suffix:colon
id|head
op_assign
l_int|NULL
suffix:semicolon
id|offset
op_assign
id|PAGE_SIZE
suffix:semicolon
r_while
c_loop
(paren
(paren
id|offset
op_sub_assign
id|size
)paren
op_ge
l_int|0
)paren
(brace
id|bh
op_assign
id|get_unused_buffer_head
c_func
(paren
id|async
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|no_grow
suffix:semicolon
id|bh-&gt;b_dev
op_assign
id|B_FREE
suffix:semicolon
multiline_comment|/* Flag as unused */
id|bh-&gt;b_this_page
op_assign
id|head
suffix:semicolon
id|head
op_assign
id|bh
suffix:semicolon
id|bh-&gt;b_state
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_next_free
op_assign
l_int|NULL
suffix:semicolon
id|bh-&gt;b_count
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_size
op_assign
id|size
suffix:semicolon
id|bh-&gt;b_data
op_assign
(paren
r_char
op_star
)paren
(paren
id|page
op_plus
id|offset
)paren
suffix:semicolon
id|bh-&gt;b_list
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|head
suffix:semicolon
multiline_comment|/*&n; * In case anything failed, we just free everything we got.&n; */
id|no_grow
suffix:colon
r_if
c_cond
(paren
id|head
)paren
(brace
r_do
(brace
id|bh
op_assign
id|head
suffix:semicolon
id|head
op_assign
id|head-&gt;b_this_page
suffix:semicolon
id|put_unused_buffer_head
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|head
)paren
suffix:semicolon
multiline_comment|/* Wake up any waiters ... */
id|wake_up
c_func
(paren
op_amp
id|buffer_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Return failure for non-async IO requests.  Async IO requests&n;&t; * are not allowed to fail, so we have to wait until buffer heads&n;&t; * become available.  But we don&squot;t want tasks sleeping with &n;&t; * partially complete buffers, so all were released above.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|async
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Uhhuh. We&squot;re _really_ low on memory. Now we just&n;&t; * wait for old buffer heads to become free due to&n;&t; * finishing IO.  Since this is an async request and&n;&t; * the reserve list is empty, we&squot;re sure there are &n;&t; * async buffer heads in use.&n;&t; */
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Set our state for sleeping, then check again for buffer heads.&n;&t; * This ensures we won&squot;t miss a wake_up from an interrupt.&n;&t; */
id|add_wait_queue
c_func
(paren
op_amp
id|buffer_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|recover_reusable_buffer_heads
c_func
(paren
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|buffer_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_goto
id|try_again
suffix:semicolon
)brace
multiline_comment|/* Run the hooks that have to be done when a page I/O has completed. */
DECL|function|after_unlock_page
r_static
r_inline
r_void
id|after_unlock_page
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|PG_decr_after
comma
op_amp
id|page-&gt;flags
)paren
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|nr_async_pages
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_SWAP
id|printk
(paren
l_string|&quot;DebugVM: Finished IO on page %p, nr_async_pages %d&bslash;n&quot;
comma
(paren
r_char
op_star
)paren
id|page_address
c_func
(paren
id|page
)paren
comma
id|atomic_read
c_func
(paren
op_amp
id|nr_async_pages
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|PG_swap_unlock_after
comma
op_amp
id|page-&gt;flags
)paren
)paren
id|swap_after_unlock_page
c_func
(paren
id|page-&gt;offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|PG_free_after
comma
op_amp
id|page-&gt;flags
)paren
)paren
id|__free_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Free all temporary buffers belonging to a page.&n; * This needs to be called with interrupts disabled.&n; */
DECL|function|free_async_buffers
r_static
r_inline
r_void
id|free_async_buffers
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|buffer_head
op_star
id|tmp
comma
op_star
id|tail
suffix:semicolon
multiline_comment|/*&n;&t; * Link all the buffers into the b_next_free list,&n;&t; * so we only have to do one xchg() operation ...&n;&t; */
id|tail
op_assign
id|bh
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|tail-&gt;b_this_page
)paren
op_ne
id|bh
)paren
(brace
id|tail-&gt;b_next_free
op_assign
id|tmp
suffix:semicolon
id|tail
op_assign
id|tmp
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Update the reuse list */
id|tail-&gt;b_next_free
op_assign
id|xchg
c_func
(paren
op_amp
id|reuse_list
comma
l_int|NULL
)paren
suffix:semicolon
id|reuse_list
op_assign
id|bh
suffix:semicolon
multiline_comment|/* Wake up any waiters ... */
id|wake_up
c_func
(paren
op_amp
id|buffer_wait
)paren
suffix:semicolon
)brace
DECL|function|end_buffer_io_async
r_static
r_void
id|end_buffer_io_async
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tmp
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|mark_buffer_uptodate
c_func
(paren
id|bh
comma
id|uptodate
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* This is a temporary buffer used for page I/O. */
id|page
op_assign
id|mem_map
op_plus
id|MAP_NR
c_func
(paren
id|bh-&gt;b_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
r_goto
id|not_locked
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_count
op_ne
l_int|1
)paren
r_goto
id|bad_count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
)paren
id|set_bit
c_func
(paren
id|PG_error
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Be _very_ careful from here on. Bad things can happen if&n;&t; * two buffer heads end IO at almost the same time and both&n;&t; * decide that the page is now completely done.&n;&t; *&n;&t; * Async buffer_heads are here only as labels for IO, and get&n;&t; * thrown away once the IO for this page is complete.  IO is&n;&t; * deemed complete once all buffers have been visited&n;&t; * (b_count==0) and are now unlocked. We must make sure that&n;&t; * only the _last_ buffer that decrements its count is the one&n;&t; * that free&squot;s the page..&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|bh-&gt;b_count
op_decrement
suffix:semicolon
id|tmp
op_assign
id|bh
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|tmp-&gt;b_count
)paren
r_goto
id|still_busy
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
suffix:semicolon
multiline_comment|/* OK, the async IO on this page is complete. */
id|free_async_buffers
c_func
(paren
id|bh
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|PG_locked
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|page-&gt;wait
)paren
suffix:semicolon
id|after_unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
suffix:semicolon
id|still_busy
suffix:colon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
id|not_locked
suffix:colon
id|printk
(paren
l_string|&quot;Whoops: end_buffer_io_async: async io complete on unlocked page&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
id|bad_count
suffix:colon
id|printk
(paren
l_string|&quot;Whoops: end_buffer_io_async: b_count != 1 on async io.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Start I/O on a page.&n; * This function expects the page to be locked and may return before I/O is complete.&n; * You then have to check page-&gt;locked, page-&gt;uptodate, and maybe wait on page-&gt;wait.&n; */
DECL|function|brw_page
r_int
id|brw_page
c_func
(paren
r_int
id|rw
comma
r_struct
id|page
op_star
id|page
comma
id|kdev_t
id|dev
comma
r_int
id|b
(braket
)braket
comma
r_int
id|size
comma
r_int
id|bmap
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|prev
comma
op_star
id|next
comma
op_star
id|arr
(braket
id|MAX_BUF_PER_PAGE
)braket
suffix:semicolon
r_int
id|block
comma
id|nr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;brw_page: page not locked for I/O&quot;
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|PG_uptodate
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|PG_error
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate async buffer heads pointing to this page, just for I/O.&n;&t; * They do _not_ show up in the buffer hash table!&n;&t; * They are _not_ registered in page-&gt;buffers either!&n;&t; */
id|bh
op_assign
id|create_buffers
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
comma
id|size
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
multiline_comment|/* WSH: exit here leaves page-&gt;count incremented */
id|clear_bit
c_func
(paren
id|PG_locked
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|page-&gt;wait
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|nr
op_assign
l_int|0
suffix:semicolon
id|next
op_assign
id|bh
suffix:semicolon
r_do
(brace
r_struct
id|buffer_head
op_star
id|tmp
suffix:semicolon
id|block
op_assign
op_star
(paren
id|b
op_increment
)paren
suffix:semicolon
id|init_buffer
c_func
(paren
id|next
comma
id|dev
comma
id|block
comma
id|end_buffer_io_async
comma
l_int|NULL
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|next-&gt;b_state
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * When we use bmap, we define block zero to represent&n;&t;&t; * a hole.  ll_rw_page, however, may legitimately&n;&t;&t; * access block zero, and we need to distinguish the&n;&t;&t; * two cases.&n;&t;&t; */
r_if
c_cond
(paren
id|bmap
op_logical_and
op_logical_neg
id|block
)paren
(brace
id|memset
c_func
(paren
id|next-&gt;b_data
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
id|next-&gt;b_count
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|tmp
op_assign
id|get_hash_table
c_func
(paren
id|dev
comma
id|block
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tmp
)paren
)paren
(brace
r_if
c_cond
(paren
id|rw
op_eq
id|READ
)paren
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rw
op_eq
id|READ
)paren
id|memcpy
c_func
(paren
id|next-&gt;b_data
comma
id|tmp-&gt;b_data
comma
id|size
)paren
suffix:semicolon
r_else
(brace
id|memcpy
c_func
(paren
id|tmp-&gt;b_data
comma
id|next-&gt;b_data
comma
id|size
)paren
suffix:semicolon
id|mark_buffer_dirty
c_func
(paren
id|tmp
comma
l_int|0
)paren
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|next-&gt;b_count
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rw
op_eq
id|READ
)paren
id|clear_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|next-&gt;b_state
)paren
suffix:semicolon
r_else
id|set_bit
c_func
(paren
id|BH_Dirty
comma
op_amp
id|next-&gt;b_state
)paren
suffix:semicolon
id|arr
(braket
id|nr
op_increment
)braket
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|prev
op_assign
id|next
comma
(paren
id|next
op_assign
id|next-&gt;b_this_page
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
id|prev-&gt;b_this_page
op_assign
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|nr
)paren
(brace
id|ll_rw_block
c_func
(paren
id|rw
comma
id|nr
comma
id|arr
)paren
suffix:semicolon
multiline_comment|/* The rest of the work is done in mark_buffer_uptodate()&n;&t;&t; * and unlock_buffer(). */
)brace
r_else
(brace
r_int
r_int
id|flags
suffix:semicolon
id|clear_bit
c_func
(paren
id|PG_locked
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|PG_uptodate
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|page-&gt;wait
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|free_async_buffers
c_func
(paren
id|bh
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|after_unlock_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
op_increment
id|current-&gt;maj_flt
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This is called by end_request() when I/O has completed.&n; */
DECL|function|mark_buffer_uptodate
r_void
id|mark_buffer_uptodate
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|on
)paren
(brace
r_if
c_cond
(paren
id|on
)paren
(brace
r_struct
id|buffer_head
op_star
id|tmp
op_assign
id|bh
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
multiline_comment|/* If a page has buffers and all these buffers are uptodate,&n;&t;&t; * then the page is uptodate. */
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|tmp-&gt;b_state
)paren
)paren
r_return
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_logical_and
id|tmp
op_ne
id|bh
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|PG_uptodate
comma
op_amp
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|bh-&gt;b_data
)paren
)braket
dot
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Generic &quot;readpage&quot; function for block devices that have the normal&n; * bmap functionality. This is most of the block device filesystems.&n; * Reads the page asynchronously --- the unlock_buffer() and&n; * mark_buffer_uptodate() functions propagate buffer state into the&n; * page struct once IO has completed.&n; */
DECL|function|generic_readpage
r_int
id|generic_readpage
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
)paren
(brace
r_struct
id|dentry
op_star
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_int
r_int
id|block
suffix:semicolon
r_int
op_star
id|p
comma
id|nr
(braket
id|PAGE_SIZE
op_div
l_int|512
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|page-&gt;count
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|PG_locked
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|PG_free_after
comma
op_amp
id|page-&gt;flags
)paren
suffix:semicolon
id|i
op_assign
id|PAGE_SIZE
op_rshift
id|inode-&gt;i_sb-&gt;s_blocksize_bits
suffix:semicolon
id|block
op_assign
id|page-&gt;offset
op_rshift
id|inode-&gt;i_sb-&gt;s_blocksize_bits
suffix:semicolon
id|p
op_assign
id|nr
suffix:semicolon
r_do
(brace
op_star
id|p
op_assign
id|inode-&gt;i_op
op_member_access_from_pointer
id|bmap
c_func
(paren
id|inode
comma
id|block
)paren
suffix:semicolon
id|i
op_decrement
suffix:semicolon
id|block
op_increment
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OG
l_int|0
)paren
suffix:semicolon
multiline_comment|/* IO start */
id|brw_page
c_func
(paren
id|READ
comma
id|page
comma
id|inode-&gt;i_dev
comma
id|nr
comma
id|inode-&gt;i_sb-&gt;s_blocksize
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to increase the number of buffers available: the size argument&n; * is used to determine what kind of buffers we want.&n; */
DECL|function|grow_buffers
r_static
r_int
id|grow_buffers
c_func
(paren
r_int
id|pri
comma
r_int
id|size
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|tmp
suffix:semicolon
r_struct
id|buffer_head
op_star
id|insert_point
suffix:semicolon
r_int
id|isize
suffix:semicolon
r_if
c_cond
(paren
(paren
id|size
op_amp
l_int|511
)paren
op_logical_or
(paren
id|size
OG
id|PAGE_SIZE
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: grow_buffers: size = %d&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_assign
id|__get_free_page
c_func
(paren
id|pri
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|bh
op_assign
id|create_buffers
c_func
(paren
id|page
comma
id|size
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|isize
op_assign
id|BUFSIZE_INDEX
c_func
(paren
id|size
)paren
suffix:semicolon
id|insert_point
op_assign
id|free_list
(braket
id|isize
)braket
suffix:semicolon
id|tmp
op_assign
id|bh
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|insert_point
)paren
(brace
id|tmp-&gt;b_next_free
op_assign
id|insert_point-&gt;b_next_free
suffix:semicolon
id|tmp-&gt;b_prev_free
op_assign
id|insert_point
suffix:semicolon
id|insert_point-&gt;b_next_free-&gt;b_prev_free
op_assign
id|tmp
suffix:semicolon
id|insert_point-&gt;b_next_free
op_assign
id|tmp
suffix:semicolon
)brace
r_else
(brace
id|tmp-&gt;b_prev_free
op_assign
id|tmp
suffix:semicolon
id|tmp-&gt;b_next_free
op_assign
id|tmp
suffix:semicolon
)brace
id|insert_point
op_assign
id|tmp
suffix:semicolon
op_increment
id|nr_buffers
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;b_this_page
)paren
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
id|tmp-&gt;b_this_page
op_assign
id|bh
suffix:semicolon
id|free_list
(braket
id|isize
)braket
op_assign
id|bh
suffix:semicolon
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
dot
id|buffers
op_assign
id|bh
suffix:semicolon
id|buffermem
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* =========== Reduce the buffer memory ============= */
DECL|function|buffer_waiting
r_static
r_inline
r_int
id|buffer_waiting
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_return
id|waitqueue_active
c_func
(paren
op_amp
id|bh-&gt;b_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * try_to_free_buffer() checks if all the buffers on this particular page&n; * are unused, and free&squot;s the page if so.&n; */
DECL|function|try_to_free_buffer
r_int
id|try_to_free_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_struct
id|buffer_head
op_star
op_star
id|bhp
comma
r_int
id|priority
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tmp
comma
op_star
id|p
suffix:semicolon
op_star
id|bhp
op_assign
id|bh
suffix:semicolon
id|page
op_assign
(paren
r_int
r_int
)paren
id|bh-&gt;b_data
suffix:semicolon
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|tmp
op_assign
id|bh
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;b_count
op_logical_or
id|buffer_protected
c_func
(paren
id|tmp
)paren
op_logical_or
id|buffer_dirty
c_func
(paren
id|tmp
)paren
op_logical_or
id|buffer_locked
c_func
(paren
id|tmp
)paren
op_logical_or
id|buffer_waiting
c_func
(paren
id|tmp
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|priority
op_logical_and
id|buffer_touched
c_func
(paren
id|tmp
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
suffix:semicolon
id|tmp
op_assign
id|bh
suffix:semicolon
r_do
(brace
id|p
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
id|nr_buffers
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
op_star
id|bhp
)paren
(brace
op_star
id|bhp
op_assign
id|p-&gt;b_prev_free
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
op_star
id|bhp
)paren
multiline_comment|/* Was this the last in the list? */
op_star
id|bhp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|remove_from_queues
c_func
(paren
id|p
)paren
suffix:semicolon
id|put_unused_buffer_head
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
suffix:semicolon
multiline_comment|/* Wake up anyone waiting for buffer heads */
id|wake_up
c_func
(paren
op_amp
id|buffer_wait
)paren
suffix:semicolon
id|buffermem
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
dot
id|buffers
op_assign
l_int|NULL
suffix:semicolon
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* ================== Debugging =================== */
DECL|function|show_buffers
r_void
id|show_buffers
c_func
(paren
r_void
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|found
op_assign
l_int|0
comma
id|locked
op_assign
l_int|0
comma
id|dirty
op_assign
l_int|0
comma
id|used
op_assign
l_int|0
comma
id|lastused
op_assign
l_int|0
suffix:semicolon
r_int
r_protected
op_assign
l_int|0
suffix:semicolon
r_int
id|nlist
suffix:semicolon
r_static
r_char
op_star
id|buf_types
(braket
id|NR_LIST
)braket
op_assign
(brace
l_string|&quot;CLEAN&quot;
comma
l_string|&quot;LOCKED&quot;
comma
l_string|&quot;DIRTY&quot;
)brace
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Buffer memory:   %6dkB&bslash;n&quot;
comma
id|buffermem
op_rshift
l_int|10
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Buffer heads:    %6d&bslash;n&quot;
comma
id|nr_buffer_heads
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Buffer blocks:   %6d&bslash;n&quot;
comma
id|nr_buffers
)paren
suffix:semicolon
r_for
c_loop
(paren
id|nlist
op_assign
l_int|0
suffix:semicolon
id|nlist
OL
id|NR_LIST
suffix:semicolon
id|nlist
op_increment
)paren
(brace
id|found
op_assign
id|locked
op_assign
id|dirty
op_assign
id|used
op_assign
id|lastused
op_assign
r_protected
op_assign
l_int|0
suffix:semicolon
id|bh
op_assign
id|lru_list
(braket
id|nlist
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
r_continue
suffix:semicolon
)brace
r_do
(brace
id|found
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
id|locked
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|buffer_protected
c_func
(paren
id|bh
)paren
)paren
r_protected
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
id|dirty
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_count
)paren
id|used
op_increment
comma
id|lastused
op_assign
id|found
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|lru_list
(braket
id|nlist
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%8s: %d buffers, %d used (last=%d), &quot;
l_string|&quot;%d locked, %d protected, %d dirty&bslash;n&quot;
comma
id|buf_types
(braket
id|nlist
)braket
comma
id|found
comma
id|used
comma
id|lastused
comma
id|locked
comma
r_protected
comma
id|dirty
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/* ===================== Init ======================= */
multiline_comment|/*&n; * allocate the hash table and init the free list&n; * Use gfp() for the hash table to decrease TLB misses, use&n; * SLAB cache for buffer heads.&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|buffer_init
c_func
(paren
r_void
)paren
)paren
(brace
r_int
id|order
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* Currently maximum order.. */
r_int
r_int
id|nr_hash
suffix:semicolon
id|nr_hash
op_assign
(paren
l_int|1UL
op_lshift
id|order
)paren
op_star
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
suffix:semicolon
id|hash_table
op_assign
(paren
r_struct
id|buffer_head
op_star
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|order
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hash_table
)paren
id|panic
c_func
(paren
l_string|&quot;Failed to allocate buffer hash table&bslash;n&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|hash_table
comma
l_int|0
comma
id|nr_hash
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
)paren
suffix:semicolon
id|bh_hash_mask
op_assign
id|nr_hash
op_minus
l_int|1
suffix:semicolon
id|bh_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;buffer_head&quot;
comma
r_sizeof
(paren
r_struct
id|buffer_head
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh_cachep
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Cannot create buffer head SLAB cache&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocate the reserved buffer heads.&n;&t; */
r_while
c_loop
(paren
id|nr_buffer_heads
OL
id|NR_RESERVED
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|bh
op_assign
id|kmem_cache_alloc
c_func
(paren
id|bh_cachep
comma
id|SLAB_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_break
suffix:semicolon
id|put_unused_buffer_head
c_func
(paren
id|bh
)paren
suffix:semicolon
id|nr_buffer_heads
op_increment
suffix:semicolon
)brace
id|lru_list
(braket
id|BUF_CLEAN
)braket
op_assign
l_int|0
suffix:semicolon
id|grow_buffers
c_func
(paren
id|GFP_KERNEL
comma
id|BLOCK_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/* ====================== bdflush support =================== */
multiline_comment|/* This is a simple kernel daemon, whose job it is to provide a dynamic&n; * response to dirty buffers.  Once this process is activated, we write back&n; * a limited number of buffers to the disks and then go back to sleep again.&n; */
DECL|variable|bdflush_wait
r_static
r_struct
id|wait_queue
op_star
id|bdflush_wait
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|bdflush_done
r_static
r_struct
id|wait_queue
op_star
id|bdflush_done
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|bdflush_tsk
r_struct
id|task_struct
op_star
id|bdflush_tsk
op_assign
l_int|0
suffix:semicolon
DECL|function|wakeup_bdflush
r_void
id|wakeup_bdflush
c_func
(paren
r_int
id|wait
)paren
(brace
r_if
c_cond
(paren
id|current
op_eq
id|bdflush_tsk
)paren
r_return
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|bdflush_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|bdflush_done
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Here we attempt to write back old buffers.  We also try to flush inodes &n; * and supers as well, since this function is essentially &quot;update&quot;, and &n; * otherwise there would be no way of ensuring that these quantities ever &n; * get written back.  Ideally, we would have a timestamp on the inodes&n; * and superblocks so that we could write back only the old ones as well&n; */
DECL|function|sync_old_buffers
id|asmlinkage
r_int
id|sync_old_buffers
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|ndirty
comma
id|nwritten
suffix:semicolon
r_int
id|nlist
suffix:semicolon
r_int
id|ncount
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|next
suffix:semicolon
id|sync_supers
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|sync_inodes
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|ncount
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
r_for
c_loop
(paren
id|nlist
op_assign
l_int|0
suffix:semicolon
id|nlist
OL
id|NR_LIST
suffix:semicolon
id|nlist
op_increment
)paren
macro_line|#else
r_for
c_loop
(paren
id|nlist
op_assign
id|BUF_DIRTY
suffix:semicolon
id|nlist
op_le
id|BUF_DIRTY
suffix:semicolon
id|nlist
op_increment
)paren
macro_line|#endif
(brace
id|ndirty
op_assign
l_int|0
suffix:semicolon
id|nwritten
op_assign
l_int|0
suffix:semicolon
id|repeat
suffix:colon
id|bh
op_assign
id|lru_list
(braket
id|nlist
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
r_for
c_loop
(paren
id|i
op_assign
id|nr_buffers_type
(braket
id|nlist
)braket
suffix:semicolon
id|i
op_decrement
OG
l_int|0
suffix:semicolon
id|bh
op_assign
id|next
)paren
(brace
multiline_comment|/* We may have stalled while waiting for I/O to complete. */
r_if
c_cond
(paren
id|bh-&gt;b_list
op_ne
id|nlist
)paren
(brace
r_goto
id|repeat
suffix:semicolon
)brace
id|next
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lru_list
(braket
id|nlist
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Dirty list empty %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Clean buffer on dirty list?  Refile it */
r_if
c_cond
(paren
id|nlist
op_eq
id|BUF_DIRTY
op_logical_and
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
id|refile_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
op_logical_or
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
id|ndirty
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_flushtime
OG
id|jiffies
)paren
(brace
r_continue
suffix:semicolon
)brace
id|nwritten
op_increment
suffix:semicolon
id|next-&gt;b_count
op_increment
suffix:semicolon
id|bh-&gt;b_count
op_increment
suffix:semicolon
id|bh-&gt;b_flushtime
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|nlist
op_ne
id|BUF_DIRTY
)paren
(brace
id|ncount
op_increment
suffix:semicolon
)brace
macro_line|#endif
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_count
op_decrement
suffix:semicolon
id|next-&gt;b_count
op_decrement
suffix:semicolon
)brace
)brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|ncount
)paren
id|printk
c_func
(paren
l_string|&quot;sync_old_buffers: %d dirty buffers not on dirty list&bslash;n&quot;
comma
id|ncount
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Wrote %d/%d buffers&bslash;n&quot;
comma
id|nwritten
comma
id|ndirty
)paren
suffix:semicolon
macro_line|#endif
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is the interface to bdflush.  As we get more sophisticated, we can&n; * pass tuning parameters to this &quot;process&quot;, to adjust how it behaves. &n; * We would want to verify each parameter, however, to make sure that it &n; * is reasonable. */
DECL|function|sys_bdflush
id|asmlinkage
r_int
id|sys_bdflush
c_func
(paren
r_int
id|func
comma
r_int
id|data
)paren
(brace
r_int
id|i
comma
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|func
op_eq
l_int|1
)paren
(brace
id|error
op_assign
id|sync_old_buffers
c_func
(paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Basically func 1 means read param 1, 2 means write param 1, etc */
r_if
c_cond
(paren
id|func
op_ge
l_int|2
)paren
(brace
id|i
op_assign
(paren
id|func
op_minus
l_int|2
)paren
op_rshift
l_int|1
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
op_logical_or
id|i
op_ge
id|N_PARAM
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
(paren
id|func
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|error
op_assign
id|put_user
c_func
(paren
id|bdf_prm.data
(braket
id|i
)braket
comma
(paren
r_int
op_star
)paren
id|data
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|data
template_param
id|bdflush_max
(braket
id|i
)braket
)paren
r_goto
id|out
suffix:semicolon
id|bdf_prm.data
(braket
id|i
)braket
op_assign
id|data
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Having func 0 used to launch the actual bdflush and then never&n;&t; * return (unless explicitly killed). We return zero here to &n;&t; * remain semi-compatible with present update(8) programs.&n;&t; */
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* This is the actual bdflush daemon itself. It used to be started from&n; * the syscall above, but now we launch it ourselves internally with&n; * kernel_thread(...)  directly after the first thread in init/main.c */
multiline_comment|/* To prevent deadlocks for a loop device:&n; * 1) Do non-blocking writes to loop (avoids deadlock with running&n; *&t;out of request blocks).&n; * 2) But do a blocking write if the only dirty buffers are loop buffers&n; *&t;(otherwise we go into an infinite busy-loop).&n; * 3) Quit writing loop blocks if a freelist went low (avoids deadlock&n; *&t;with running out of free buffers for loop&squot;s &quot;real&quot; device).&n;*/
DECL|function|bdflush
r_int
id|bdflush
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|ndirty
suffix:semicolon
r_int
id|nlist
suffix:semicolon
r_int
id|ncount
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|next
suffix:semicolon
r_int
id|major
suffix:semicolon
r_int
id|wrta_cmd
op_assign
id|WRITEA
suffix:semicolon
multiline_comment|/* non-blocking write for LOOP */
multiline_comment|/*&n;&t; *&t;We have a bare-bones task_struct, and really should fill&n;&t; *&t;in a few more things so &quot;top&quot; and /proc/2/{exe,root,cwd}&n;&t; *&t;display semi-sane things. Not real crucial though...  &n;&t; */
id|current-&gt;session
op_assign
l_int|1
suffix:semicolon
id|current-&gt;pgrp
op_assign
l_int|1
suffix:semicolon
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;kflushd&quot;
)paren
suffix:semicolon
id|bdflush_tsk
op_assign
id|current
suffix:semicolon
multiline_comment|/*&n;&t; *&t;As a kernel thread we want to tamper with system buffers&n;&t; *&t;and other internals and thus be subject to the SMP locking&n;&t; *&t;rules. (On a uniprocessor box this does nothing).&n;&t; */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;bdflush() activated...&quot;
)paren
suffix:semicolon
macro_line|#endif
id|CHECK_EMERGENCY_SYNC
id|ncount
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
r_for
c_loop
(paren
id|nlist
op_assign
l_int|0
suffix:semicolon
id|nlist
OL
id|NR_LIST
suffix:semicolon
id|nlist
op_increment
)paren
macro_line|#else
r_for
c_loop
(paren
id|nlist
op_assign
id|BUF_DIRTY
suffix:semicolon
id|nlist
op_le
id|BUF_DIRTY
suffix:semicolon
id|nlist
op_increment
)paren
macro_line|#endif
(brace
id|ndirty
op_assign
l_int|0
suffix:semicolon
id|refilled
op_assign
l_int|0
suffix:semicolon
id|repeat
suffix:colon
id|bh
op_assign
id|lru_list
(braket
id|nlist
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
r_for
c_loop
(paren
id|i
op_assign
id|nr_buffers_type
(braket
id|nlist
)braket
suffix:semicolon
id|i
op_decrement
OG
l_int|0
op_logical_and
id|ndirty
OL
id|bdf_prm.b_un.ndirty
suffix:semicolon
id|bh
op_assign
id|next
)paren
(brace
multiline_comment|/* We may have stalled while waiting for I/O to complete. */
r_if
c_cond
(paren
id|bh-&gt;b_list
op_ne
id|nlist
)paren
(brace
r_goto
id|repeat
suffix:semicolon
)brace
id|next
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lru_list
(braket
id|nlist
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Dirty list empty %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Clean buffer on dirty list?  Refile it */
r_if
c_cond
(paren
id|nlist
op_eq
id|BUF_DIRTY
op_logical_and
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
id|refile_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
op_logical_or
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
id|major
op_assign
id|MAJOR
c_func
(paren
id|bh-&gt;b_dev
)paren
suffix:semicolon
multiline_comment|/* Should we write back buffers that are shared or not??&n;&t;&t;&t;&t;&t;     currently dirty buffers are not shared, so it does not matter */
r_if
c_cond
(paren
id|refilled
op_logical_and
id|major
op_eq
id|LOOP_MAJOR
)paren
r_continue
suffix:semicolon
id|next-&gt;b_count
op_increment
suffix:semicolon
id|bh-&gt;b_count
op_increment
suffix:semicolon
id|ndirty
op_increment
suffix:semicolon
id|bh-&gt;b_flushtime
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|major
op_eq
id|LOOP_MAJOR
)paren
(brace
id|ll_rw_block
c_func
(paren
id|wrta_cmd
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|wrta_cmd
op_assign
id|WRITEA
suffix:semicolon
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
op_decrement
id|ndirty
suffix:semicolon
)brace
r_else
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|nlist
op_ne
id|BUF_DIRTY
)paren
(brace
id|ncount
op_increment
suffix:semicolon
)brace
macro_line|#endif
id|bh-&gt;b_count
op_decrement
suffix:semicolon
id|next-&gt;b_count
op_decrement
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|ncount
)paren
id|printk
c_func
(paren
l_string|&quot;sys_bdflush: %d dirty buffers not on dirty list&bslash;n&quot;
comma
id|ncount
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sleeping again.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* If we didn&squot;t write anything, but there are still&n;&t;&t; * dirty buffers, then make the next write to a&n;&t;&t; * loop device to be a blocking write.&n;&t;&t; * This lets us block--which we _must_ do! */
r_if
c_cond
(paren
id|ndirty
op_eq
l_int|0
op_logical_and
id|nr_buffers_type
(braket
id|BUF_DIRTY
)braket
OG
l_int|0
op_logical_and
id|wrta_cmd
op_ne
id|WRITE
)paren
(brace
id|wrta_cmd
op_assign
id|WRITE
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|bdflush_done
)paren
suffix:semicolon
multiline_comment|/* If there are still a lot of dirty buffers around, skip the sleep&n;&t;&t;   and flush some more */
r_if
c_cond
(paren
id|ndirty
op_eq
l_int|0
op_logical_or
id|nr_buffers_type
(braket
id|BUF_DIRTY
)braket
op_le
id|nr_buffers
op_star
id|bdf_prm.b_un.nfract
op_div
l_int|100
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|flush_signals
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|bdflush_wait
)paren
suffix:semicolon
)brace
)brace
)brace
eof
