multiline_comment|/*&n; *  linux/fs/buffer.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; *  &squot;buffer.c&squot; implements the buffer-cache functions. Race-conditions have&n; * been avoided by NEVER letting an interrupt change a buffer (except for the&n; * data, of course), but instead letting the caller do it.&n; */
multiline_comment|/* Start bdflush() with kernel_thread not syscall - Paul Gortmaker, 12/95 */
multiline_comment|/* Removed a lot of unnecessary code and simplified things now that&n; * the buffer cache isn&squot;t our primary cache - Andrew Tridgell 12/96&n; */
multiline_comment|/* Speed up hash, lru, and free list operations.  Use gfp() for allocating&n; * hash table, use SLAB cache for buffer heads. -DaveM&n; */
multiline_comment|/* Added 32k buffer block sizes - these are required older ARM systems.&n; * - RMK&n; */
multiline_comment|/* Thread it... -DaveM */
multiline_comment|/* async buffer flushing, 1999 Andrea Arcangeli &lt;andrea@suse.de&gt; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/swapctl.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/sysrq.h&gt;
macro_line|#include &lt;linux/file.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/quotaops.h&gt;
macro_line|#include &lt;linux/iobuf.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
DECL|macro|NR_SIZES
mdefine_line|#define NR_SIZES 7
DECL|variable|buffersize_index
r_static
r_char
id|buffersize_index
(braket
l_int|65
)braket
op_assign
(brace
op_minus
l_int|1
comma
l_int|0
comma
l_int|1
comma
op_minus
l_int|1
comma
l_int|2
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|3
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|4
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|5
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|6
)brace
suffix:semicolon
DECL|macro|BUFSIZE_INDEX
mdefine_line|#define BUFSIZE_INDEX(X) ((int) buffersize_index[(X)&gt;&gt;9])
DECL|macro|MAX_BUF_PER_PAGE
mdefine_line|#define MAX_BUF_PER_PAGE (PAGE_CACHE_SIZE / 512)
DECL|macro|NR_RESERVED
mdefine_line|#define NR_RESERVED (2*MAX_BUF_PER_PAGE)
DECL|macro|MAX_UNUSED_BUFFERS
mdefine_line|#define MAX_UNUSED_BUFFERS NR_RESERVED+20 /* don&squot;t ever have more than this &n;&t;&t;&t;&t;&t;     number of unused buffer heads */
multiline_comment|/* Anti-deadlock ordering:&n; *&t;lru_list_lock &gt; hash_table_lock &gt; free_list_lock &gt; unused_list_lock&n; */
DECL|macro|BH_ENTRY
mdefine_line|#define BH_ENTRY(list) list_entry((list), struct buffer_head, b_inode_buffers)
multiline_comment|/*&n; * Hash table gook..&n; */
DECL|variable|bh_hash_mask
r_static
r_int
r_int
id|bh_hash_mask
suffix:semicolon
DECL|variable|bh_hash_shift
r_static
r_int
r_int
id|bh_hash_shift
suffix:semicolon
DECL|variable|hash_table
r_static
r_struct
id|buffer_head
op_star
op_star
id|hash_table
suffix:semicolon
DECL|variable|hash_table_lock
r_static
id|rwlock_t
id|hash_table_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|lru_list
r_static
r_struct
id|buffer_head
op_star
id|lru_list
(braket
id|NR_LIST
)braket
suffix:semicolon
DECL|variable|lru_list_lock
r_static
id|spinlock_t
id|lru_list_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|nr_buffers_type
r_static
r_int
id|nr_buffers_type
(braket
id|NR_LIST
)braket
suffix:semicolon
DECL|variable|size_buffers_type
r_static
r_int
r_int
id|size_buffers_type
(braket
id|NR_LIST
)braket
suffix:semicolon
DECL|variable|unused_list
r_static
r_struct
id|buffer_head
op_star
id|unused_list
suffix:semicolon
DECL|variable|nr_unused_buffer_heads
r_static
r_int
id|nr_unused_buffer_heads
suffix:semicolon
DECL|variable|unused_list_lock
r_static
id|spinlock_t
id|unused_list_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|buffer_wait
)paren
suffix:semicolon
DECL|struct|bh_free_head
r_struct
id|bh_free_head
(brace
DECL|member|list
r_struct
id|buffer_head
op_star
id|list
suffix:semicolon
DECL|member|lock
id|spinlock_t
id|lock
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|free_list
r_static
r_struct
id|bh_free_head
id|free_list
(braket
id|NR_SIZES
)braket
suffix:semicolon
r_static
r_int
id|grow_buffers
c_func
(paren
r_int
id|size
)paren
suffix:semicolon
r_static
r_void
id|__refile_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
)paren
suffix:semicolon
multiline_comment|/* This is used by some architectures to estimate available memory. */
DECL|variable|buffermem_pages
id|atomic_t
id|buffermem_pages
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Here is the parameter block for the bdflush process. If you add or&n; * remove any of the parameters, make sure to update kernel/sysctl.c.&n; */
DECL|macro|N_PARAM
mdefine_line|#define N_PARAM 9
multiline_comment|/* The dummy values in this structure are left in there for compatibility&n; * with old programs that play with the /proc entries.&n; */
DECL|union|bdflush_param
r_union
id|bdflush_param
(brace
r_struct
(brace
DECL|member|nfract
r_int
id|nfract
suffix:semicolon
multiline_comment|/* Percentage of buffer cache dirty to &n;&t;&t;&t;&t;activate bdflush */
DECL|member|ndirty
r_int
id|ndirty
suffix:semicolon
multiline_comment|/* Maximum number of dirty blocks to write out per&n;&t;&t;&t;&t;wake-cycle */
DECL|member|nrefill
r_int
id|nrefill
suffix:semicolon
multiline_comment|/* Number of clean buffers to try to obtain&n;&t;&t;&t;&t;each time we call refill */
DECL|member|dummy1
r_int
id|dummy1
suffix:semicolon
multiline_comment|/* unused */
DECL|member|interval
r_int
id|interval
suffix:semicolon
multiline_comment|/* jiffies delay between kupdate flushes */
DECL|member|age_buffer
r_int
id|age_buffer
suffix:semicolon
multiline_comment|/* Time for normal buffer to age before we flush it */
DECL|member|nfract_sync
r_int
id|nfract_sync
suffix:semicolon
multiline_comment|/* Percentage of buffer cache dirty to &n;&t;&t;&t;&t;    activate bdflush synchronously */
DECL|member|dummy2
r_int
id|dummy2
suffix:semicolon
multiline_comment|/* unused */
DECL|member|dummy3
r_int
id|dummy3
suffix:semicolon
multiline_comment|/* unused */
DECL|member|b_un
)brace
id|b_un
suffix:semicolon
DECL|member|data
r_int
r_int
id|data
(braket
id|N_PARAM
)braket
suffix:semicolon
DECL|variable|bdf_prm
)brace
id|bdf_prm
op_assign
(brace
(brace
l_int|30
comma
l_int|64
comma
l_int|64
comma
l_int|256
comma
l_int|5
op_star
id|HZ
comma
l_int|30
op_star
id|HZ
comma
l_int|60
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* These are the min and max parameter values that we will allow to be assigned */
DECL|variable|bdflush_min
r_int
id|bdflush_min
(braket
id|N_PARAM
)braket
op_assign
(brace
l_int|0
comma
l_int|10
comma
l_int|5
comma
l_int|25
comma
l_int|0
comma
l_int|1
op_star
id|HZ
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|bdflush_max
r_int
id|bdflush_max
(braket
id|N_PARAM
)braket
op_assign
(brace
l_int|100
comma
l_int|50000
comma
l_int|20000
comma
l_int|20000
comma
l_int|600
op_star
id|HZ
comma
l_int|6000
op_star
id|HZ
comma
l_int|100
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * Rewrote the wait-routines to use the &quot;new&quot; wait-queue functionality,&n; * and getting rid of the cli-sti pairs. The wait-queue routines still&n; * need cli-sti, but now it&squot;s just a couple of 386 instructions or so.&n; *&n; * Note that the real wait_on_buffer() is an inline function that checks&n; * if &squot;b_wait&squot; is set before calling this, so that the queues aren&squot;t set&n; * up unnecessarily.&n; */
DECL|function|__wait_on_buffer
r_void
id|__wait_on_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|tsk
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|bh-&gt;b_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_do
(brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
id|set_task_state
c_func
(paren
id|tsk
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
suffix:semicolon
id|tsk-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|bh-&gt;b_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
)brace
multiline_comment|/* Call sync_buffers with wait!=0 to ensure that the call does not&n; * return until all buffer writes have completed.  Sync() may return&n; * before the writes have finished; fsync() may not.&n; */
multiline_comment|/* Godamity-damn.  Some buffers (bitmaps for filesystems)&n; * spontaneously dirty themselves without ever brelse being called.&n; * We will ultimately want to put these in a separate list, but for&n; * now we search all of the lists for dirty buffers.&n; */
DECL|function|sync_buffers
r_static
r_int
id|sync_buffers
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|wait
)paren
(brace
r_int
id|i
comma
id|retry
comma
id|pass
op_assign
l_int|0
comma
id|err
op_assign
l_int|0
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|next
suffix:semicolon
multiline_comment|/* One pass for no-wait, three for wait:&n;&t; * 0) write out all dirty, unlocked buffers;&n;&t; * 1) write out all dirty buffers, waiting if locked;&n;&t; * 2) wait for completion by waiting for all buffers to unlock.&n;&t; */
r_do
(brace
id|retry
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We search all lists as a failsafe mechanism, not because we expect&n;&t;&t; * there to be dirty buffers on any of the other lists.&n;&t;&t; */
id|repeat
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|bh
op_assign
id|lru_list
(braket
id|BUF_DIRTY
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|repeat2
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nr_buffers_type
(braket
id|BUF_DIRTY
)braket
op_star
l_int|2
suffix:semicolon
id|i
op_decrement
OG
l_int|0
suffix:semicolon
id|bh
op_assign
id|next
)paren
(brace
id|next
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lru_list
(braket
id|BUF_DIRTY
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_logical_and
id|bh-&gt;b_dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* Buffer is locked; skip it unless wait is&n;&t;&t;&t;&t; * requested AND pass &gt; 0.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|wait
op_logical_or
op_logical_neg
id|pass
)paren
(brace
id|retry
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|wait_on_buffer
(paren
id|bh
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/* If an unlocked buffer is not uptodate, there has&n;&t;&t;&t; * been an IO error. Skip it.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|wait
op_logical_and
id|buffer_req
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t write clean buffers.  Don&squot;t write ANY buffers&n;&t;&t;&t; * on the third pass.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
op_logical_or
id|pass
op_ge
l_int|2
)paren
r_continue
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|retry
op_assign
l_int|1
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|repeat2
suffix:colon
id|bh
op_assign
id|lru_list
(braket
id|BUF_LOCKED
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|nr_buffers_type
(braket
id|BUF_LOCKED
)braket
op_star
l_int|2
suffix:semicolon
id|i
op_decrement
OG
l_int|0
suffix:semicolon
id|bh
op_assign
id|next
)paren
(brace
id|next
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lru_list
(braket
id|BUF_LOCKED
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_logical_and
id|bh-&gt;b_dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* Buffer is locked; skip it unless wait is&n;&t;&t;&t;&t; * requested AND pass &gt; 0.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|wait
op_logical_or
op_logical_neg
id|pass
)paren
(brace
id|retry
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|atomic_inc
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|wait_on_buffer
(paren
id|bh
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
r_goto
id|repeat2
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
multiline_comment|/* If we are waiting for the sync to succeed, and if any dirty&n;&t;&t; * blocks were written, then repeat; on the second pass, only&n;&t;&t; * wait for buffers being written (do not pass to write any&n;&t;&t; * more buffers on the second pass).&n;&t;&t; */
)brace
r_while
c_loop
(paren
id|wait
op_logical_and
id|retry
op_logical_and
op_increment
id|pass
op_le
l_int|2
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sync_dev
r_void
id|sync_dev
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
id|sync_supers
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sync_inodes
c_func
(paren
id|dev
)paren
suffix:semicolon
id|DQUOT_SYNC
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* sync all the dirty buffers out to disk only _after_ all the&n;&t;   high level layers finished generated buffer dirty data&n;&t;   (or we&squot;ll return with some buffer still dirty on the blockdevice&n;&t;   so breaking the semantics of this call) */
id|sync_buffers
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME(eric) we need to sync the physical devices here.&n;&t; * This is because some (scsi) controllers have huge amounts of&n;&t; * cache onboard (hundreds of Mb), and we need to instruct&n;&t; * them to commit all of the dirty memory to disk, and we should&n;&t; * not return until this has happened.&n;&t; *&n;&t; * This would need to get implemented by going through the assorted&n;&t; * layers so that each block major number can be synced, and this&n;&t; * would call down into the upper and mid-layer scsi.&n;&t; */
)brace
DECL|function|fsync_dev
r_int
id|fsync_dev
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
id|sync_buffers
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|sync_supers
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sync_inodes
c_func
(paren
id|dev
)paren
suffix:semicolon
id|DQUOT_SYNC
c_func
(paren
id|dev
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|sync_buffers
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|sys_sync
id|asmlinkage
r_int
id|sys_sync
c_func
(paren
r_void
)paren
(brace
id|fsync_dev
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;filp may be NULL if called via the msync of a vma.&n; */
DECL|function|file_fsync
r_int
id|file_fsync
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_struct
id|dentry
op_star
id|dentry
comma
r_int
id|datasync
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* sync the inode to buffers */
id|write_inode_now
c_func
(paren
id|inode
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* sync the superblock to buffers */
id|sb
op_assign
id|inode-&gt;i_sb
suffix:semicolon
id|lock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;s_op
op_logical_and
id|sb-&gt;s_op-&gt;write_super
)paren
id|sb-&gt;s_op
op_member_access_from_pointer
id|write_super
c_func
(paren
id|sb
)paren
suffix:semicolon
id|unlock_super
c_func
(paren
id|sb
)paren
suffix:semicolon
multiline_comment|/* .. finally sync the buffers to disk */
id|dev
op_assign
id|inode-&gt;i_dev
suffix:semicolon
id|ret
op_assign
id|sync_buffers
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sys_fsync
id|asmlinkage
r_int
id|sys_fsync
c_func
(paren
r_int
r_int
id|fd
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_op
op_logical_or
op_logical_neg
id|file-&gt;f_op-&gt;fsync
)paren
r_goto
id|out_putf
suffix:semicolon
multiline_comment|/* We need to protect against concurrent writers.. */
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|filemap_fdatasync
c_func
(paren
id|inode-&gt;i_mapping
)paren
suffix:semicolon
id|err
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|fsync
c_func
(paren
id|file
comma
id|dentry
comma
l_int|0
)paren
suffix:semicolon
id|filemap_fdatawait
c_func
(paren
id|inode-&gt;i_mapping
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|out_putf
suffix:colon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sys_fdatasync
id|asmlinkage
r_int
id|sys_fdatasync
c_func
(paren
r_int
r_int
id|fd
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|dentry
op_star
id|dentry
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_int
id|err
suffix:semicolon
id|err
op_assign
op_minus
id|EBADF
suffix:semicolon
id|file
op_assign
id|fget
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file
)paren
r_goto
id|out
suffix:semicolon
id|dentry
op_assign
id|file-&gt;f_dentry
suffix:semicolon
id|inode
op_assign
id|dentry-&gt;d_inode
suffix:semicolon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_op
op_logical_or
op_logical_neg
id|file-&gt;f_op-&gt;fsync
)paren
r_goto
id|out_putf
suffix:semicolon
id|down
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|filemap_fdatasync
c_func
(paren
id|inode-&gt;i_mapping
)paren
suffix:semicolon
id|err
op_assign
id|file-&gt;f_op
op_member_access_from_pointer
id|fsync
c_func
(paren
id|file
comma
id|dentry
comma
l_int|1
)paren
suffix:semicolon
id|filemap_fdatawait
c_func
(paren
id|inode-&gt;i_mapping
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
id|out_putf
suffix:colon
id|fput
c_func
(paren
id|file
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* After several hours of tedious analysis, the following hash&n; * function won.  Do not mess with it... -DaveM&n; */
DECL|macro|_hashfn
mdefine_line|#define _hashfn(dev,block)&t;&bslash;&n;&t;((((dev)&lt;&lt;(bh_hash_shift - 6)) ^ ((dev)&lt;&lt;(bh_hash_shift - 9))) ^ &bslash;&n;&t; (((block)&lt;&lt;(bh_hash_shift - 6)) ^ ((block) &gt;&gt; 13) ^ &bslash;&n;&t;  ((block) &lt;&lt; (bh_hash_shift - 12))))
DECL|macro|hash
mdefine_line|#define hash(dev,block) hash_table[(_hashfn(HASHDEV(dev),block) &amp; bh_hash_mask)]
DECL|function|__hash_link
r_static
id|__inline__
r_void
id|__hash_link
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_struct
id|buffer_head
op_star
op_star
id|head
)paren
(brace
r_if
c_cond
(paren
(paren
id|bh-&gt;b_next
op_assign
op_star
id|head
)paren
op_ne
l_int|NULL
)paren
id|bh-&gt;b_next-&gt;b_pprev
op_assign
op_amp
id|bh-&gt;b_next
suffix:semicolon
op_star
id|head
op_assign
id|bh
suffix:semicolon
id|bh-&gt;b_pprev
op_assign
id|head
suffix:semicolon
)brace
DECL|function|__hash_unlink
r_static
id|__inline__
r_void
id|__hash_unlink
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_pprev
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_next
)paren
id|bh-&gt;b_next-&gt;b_pprev
op_assign
id|bh-&gt;b_pprev
suffix:semicolon
op_star
(paren
id|bh-&gt;b_pprev
)paren
op_assign
id|bh-&gt;b_next
suffix:semicolon
id|bh-&gt;b_pprev
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|__insert_into_lru_list
r_static
r_void
id|__insert_into_lru_list
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|blist
)paren
(brace
r_struct
id|buffer_head
op_star
op_star
id|bhp
op_assign
op_amp
id|lru_list
(braket
id|blist
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|bhp
)paren
(brace
op_star
id|bhp
op_assign
id|bh
suffix:semicolon
id|bh-&gt;b_prev_free
op_assign
id|bh
suffix:semicolon
)brace
id|bh-&gt;b_next_free
op_assign
op_star
id|bhp
suffix:semicolon
id|bh-&gt;b_prev_free
op_assign
(paren
op_star
id|bhp
)paren
op_member_access_from_pointer
id|b_prev_free
suffix:semicolon
(paren
op_star
id|bhp
)paren
op_member_access_from_pointer
id|b_prev_free-&gt;b_next_free
op_assign
id|bh
suffix:semicolon
(paren
op_star
id|bhp
)paren
op_member_access_from_pointer
id|b_prev_free
op_assign
id|bh
suffix:semicolon
id|nr_buffers_type
(braket
id|blist
)braket
op_increment
suffix:semicolon
id|size_buffers_type
(braket
id|blist
)braket
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
)brace
DECL|function|__remove_from_lru_list
r_static
r_void
id|__remove_from_lru_list
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|blist
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_prev_free
op_logical_or
id|bh-&gt;b_next_free
)paren
(brace
id|bh-&gt;b_prev_free-&gt;b_next_free
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
id|bh-&gt;b_next_free-&gt;b_prev_free
op_assign
id|bh-&gt;b_prev_free
suffix:semicolon
r_if
c_cond
(paren
id|lru_list
(braket
id|blist
)braket
op_eq
id|bh
)paren
id|lru_list
(braket
id|blist
)braket
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_if
c_cond
(paren
id|lru_list
(braket
id|blist
)braket
op_eq
id|bh
)paren
id|lru_list
(braket
id|blist
)braket
op_assign
l_int|NULL
suffix:semicolon
id|bh-&gt;b_next_free
op_assign
id|bh-&gt;b_prev_free
op_assign
l_int|NULL
suffix:semicolon
id|nr_buffers_type
(braket
id|blist
)braket
op_decrement
suffix:semicolon
id|size_buffers_type
(braket
id|blist
)braket
op_sub_assign
id|bh-&gt;b_size
suffix:semicolon
)brace
)brace
DECL|function|__remove_from_free_list
r_static
r_void
id|__remove_from_free_list
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|index
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_next_free
op_eq
id|bh
)paren
(brace
id|free_list
(braket
id|index
)braket
dot
id|list
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|bh-&gt;b_prev_free-&gt;b_next_free
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
id|bh-&gt;b_next_free-&gt;b_prev_free
op_assign
id|bh-&gt;b_prev_free
suffix:semicolon
r_if
c_cond
(paren
id|free_list
(braket
id|index
)braket
dot
id|list
op_eq
id|bh
)paren
id|free_list
(braket
id|index
)braket
dot
id|list
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
)brace
id|bh-&gt;b_next_free
op_assign
id|bh-&gt;b_prev_free
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* must be called with both the hash_table_lock and the lru_list_lock&n;   held */
DECL|function|__remove_from_queues
r_static
r_void
id|__remove_from_queues
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|__hash_unlink
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__remove_from_lru_list
c_func
(paren
id|bh
comma
id|bh-&gt;b_list
)paren
suffix:semicolon
)brace
DECL|function|__insert_into_queues
r_static
r_void
id|__insert_into_queues
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|buffer_head
op_star
op_star
id|head
op_assign
op_amp
id|hash
c_func
(paren
id|bh-&gt;b_dev
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
id|__hash_link
c_func
(paren
id|bh
comma
id|head
)paren
suffix:semicolon
id|__insert_into_lru_list
c_func
(paren
id|bh
comma
id|bh-&gt;b_list
)paren
suffix:semicolon
)brace
multiline_comment|/* This function must only run if there are no other&n; * references _anywhere_ to this buffer head.&n; */
DECL|function|put_last_free
r_static
r_void
id|put_last_free
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|bh_free_head
op_star
id|head
op_assign
op_amp
id|free_list
(braket
id|BUFSIZE_INDEX
c_func
(paren
id|bh-&gt;b_size
)paren
)braket
suffix:semicolon
r_struct
id|buffer_head
op_star
op_star
id|bhp
op_assign
op_amp
id|head-&gt;list
suffix:semicolon
id|bh-&gt;b_state
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|head-&gt;lock
)paren
suffix:semicolon
id|bh-&gt;b_dev
op_assign
id|B_FREE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|bhp
)paren
(brace
op_star
id|bhp
op_assign
id|bh
suffix:semicolon
id|bh-&gt;b_prev_free
op_assign
id|bh
suffix:semicolon
)brace
id|bh-&gt;b_next_free
op_assign
op_star
id|bhp
suffix:semicolon
id|bh-&gt;b_prev_free
op_assign
(paren
op_star
id|bhp
)paren
op_member_access_from_pointer
id|b_prev_free
suffix:semicolon
(paren
op_star
id|bhp
)paren
op_member_access_from_pointer
id|b_prev_free-&gt;b_next_free
op_assign
id|bh
suffix:semicolon
(paren
op_star
id|bhp
)paren
op_member_access_from_pointer
id|b_prev_free
op_assign
id|bh
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|head-&gt;lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Why like this, I hear you say... The reason is race-conditions.&n; * As we don&squot;t lock buffers (unless we are reading them, that is),&n; * something might happen to it while we sleep (ie a read-error&n; * will force it bad). This shouldn&squot;t really happen currently, but&n; * the code is ready.&n; */
DECL|function|__get_hash_table
r_static
r_inline
r_struct
id|buffer_head
op_star
id|__get_hash_table
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|hash
c_func
(paren
id|dev
comma
id|block
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|bh
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_next
)paren
r_if
c_cond
(paren
id|bh-&gt;b_blocknr
op_eq
id|block
op_logical_and
id|bh-&gt;b_size
op_eq
id|size
op_logical_and
id|bh-&gt;b_dev
op_eq
id|dev
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
id|atomic_inc
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
DECL|function|get_hash_table
r_struct
id|buffer_head
op_star
id|get_hash_table
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|hash_table_lock
)paren
suffix:semicolon
id|bh
op_assign
id|__get_hash_table
c_func
(paren
id|dev
comma
id|block
comma
id|size
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|hash_table_lock
)paren
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
DECL|function|get_hardblocksize
r_int
r_int
id|get_hardblocksize
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
multiline_comment|/*&n;&t; * Get the hard sector size for the given device.  If we don&squot;t know&n;&t; * what it is, return 0.&n;&t; */
r_if
c_cond
(paren
id|hardsect_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
op_ne
l_int|NULL
)paren
(brace
r_int
id|blksize
op_assign
id|hardsect_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|blksize
op_ne
l_int|0
)paren
r_return
id|blksize
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We don&squot;t know what the hardware sector size for this device is.&n;&t; * Return 0 indicating that we don&squot;t know.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|buffer_insert_inode_queue
r_void
id|buffer_insert_inode_queue
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_inode
)paren
id|list_del
c_func
(paren
op_amp
id|bh-&gt;b_inode_buffers
)paren
suffix:semicolon
id|bh-&gt;b_inode
op_assign
id|inode
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|bh-&gt;b_inode_buffers
comma
op_amp
id|inode-&gt;i_dirty_buffers
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* The caller must have the lru_list lock before calling the &n;   remove_inode_queue functions.  */
DECL|function|__remove_inode_queue
r_static
r_void
id|__remove_inode_queue
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|bh-&gt;b_inode
op_assign
l_int|NULL
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|bh-&gt;b_inode_buffers
)paren
suffix:semicolon
)brace
DECL|function|remove_inode_queue
r_static
r_inline
r_void
id|remove_inode_queue
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_inode
)paren
id|__remove_inode_queue
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
DECL|function|inode_has_buffers
r_int
id|inode_has_buffers
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_int
id|ret
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|ret
op_assign
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|inode-&gt;i_dirty_buffers
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* If invalidate_buffers() will trash dirty buffers, it means some kind&n;   of fs corruption is going on. Trashing dirty data always imply losing&n;   information that was supposed to be just stored on the physical layer&n;   by the user.&n;&n;   Thus invalidate_buffers in general usage is not allwowed to trash dirty&n;   buffers. For example ioctl(FLSBLKBUF) expects dirty data to be preserved.&n;&n;   NOTE: In the case where the user removed a removable-media-disk even if&n;   there&squot;s still dirty data not synced on disk (due a bug in the device driver&n;   or due an error of the user), by not destroying the dirty buffers we could&n;   generate corruption also on the next media inserted, thus a parameter is&n;   necessary to handle this case in the most safe way possible (trying&n;   to not corrupt also the new disk inserted with the data belonging to&n;   the old now corrupted disk). Also for the ramdisk the natural thing&n;   to do in order to release the ramdisk memory is to destroy dirty buffers.&n;&n;   These are two special cases. Normal usage imply the device driver&n;   to issue a sync on the device (without waiting I/O completation) and&n;   then an invalidate_buffers call that doesn&squot;t trash dirty buffers. */
DECL|function|__invalidate_buffers
r_void
id|__invalidate_buffers
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|destroy_dirty_buffers
)paren
(brace
r_int
id|i
comma
id|nlist
comma
id|slept
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|bh_next
suffix:semicolon
id|retry
suffix:colon
id|slept
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|nlist
op_assign
l_int|0
suffix:semicolon
id|nlist
OL
id|NR_LIST
suffix:semicolon
id|nlist
op_increment
)paren
(brace
id|bh
op_assign
id|lru_list
(braket
id|nlist
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nr_buffers_type
(braket
id|nlist
)braket
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|bh
op_assign
id|bh_next
comma
id|i
op_decrement
)paren
(brace
id|bh_next
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
multiline_comment|/* Another device? */
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
multiline_comment|/* Part of a mapping? */
r_if
c_cond
(paren
id|bh-&gt;b_page-&gt;mapping
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|slept
op_assign
l_int|1
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
)brace
id|write_lock
c_func
(paren
op_amp
id|hash_table_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
op_logical_and
(paren
id|destroy_dirty_buffers
op_logical_or
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
)paren
(brace
id|remove_inode_queue
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__remove_from_queues
c_func
(paren
id|bh
)paren
suffix:semicolon
id|put_last_free
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/* else complain loudly? */
id|write_unlock
c_func
(paren
op_amp
id|hash_table_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slept
)paren
r_goto
id|out
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slept
)paren
r_goto
id|retry
suffix:semicolon
)brace
DECL|function|set_blocksize
r_void
id|set_blocksize
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|size
)paren
(brace
r_extern
r_int
op_star
id|blksize_size
(braket
)braket
suffix:semicolon
r_int
id|i
comma
id|nlist
comma
id|slept
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|bh_next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
)paren
r_return
suffix:semicolon
multiline_comment|/* Size must be a power of two, and between 512 and PAGE_SIZE */
r_if
c_cond
(paren
id|size
OG
id|PAGE_SIZE
op_logical_or
id|size
OL
l_int|512
op_logical_or
(paren
id|size
op_amp
(paren
id|size
op_minus
l_int|1
)paren
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Invalid blocksize passed to set_blocksize&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
op_eq
l_int|0
op_logical_and
id|size
op_eq
id|BLOCK_SIZE
)paren
(brace
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
op_assign
id|size
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
op_eq
id|size
)paren
r_return
suffix:semicolon
id|sync_buffers
c_func
(paren
id|dev
comma
l_int|2
)paren
suffix:semicolon
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
op_assign
id|size
suffix:semicolon
id|retry
suffix:colon
id|slept
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|nlist
op_assign
l_int|0
suffix:semicolon
id|nlist
OL
id|NR_LIST
suffix:semicolon
id|nlist
op_increment
)paren
(brace
id|bh
op_assign
id|lru_list
(braket
id|nlist
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nr_buffers_type
(braket
id|nlist
)braket
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|bh
op_assign
id|bh_next
comma
id|i
op_decrement
)paren
(brace
id|bh_next
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_ne
id|dev
op_logical_or
id|bh-&gt;b_size
op_eq
id|size
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|slept
op_assign
l_int|1
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
)brace
id|write_lock
c_func
(paren
op_amp
id|hash_table_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
)paren
(brace
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;set_blocksize: dev %s buffer_dirty %lu size %hu&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|dev
)paren
comma
id|bh-&gt;b_blocknr
comma
id|bh-&gt;b_size
)paren
suffix:semicolon
id|remove_inode_queue
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__remove_from_queues
c_func
(paren
id|bh
)paren
suffix:semicolon
id|put_last_free
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|atomic_set_buffer_clean
c_func
(paren
id|bh
)paren
)paren
id|__refile_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;set_blocksize: &quot;
l_string|&quot;b_count %d, dev %s, block %lu, from %p&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
comma
id|bdevname
c_func
(paren
id|bh-&gt;b_dev
)paren
comma
id|bh-&gt;b_blocknr
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|hash_table_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slept
)paren
r_goto
id|out
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slept
)paren
r_goto
id|retry
suffix:semicolon
)brace
multiline_comment|/*&n; * We used to try various strange things. Let&squot;s not.&n; * We&squot;ll just try to balance dirty buffers, and possibly&n; * launder some pages.&n; */
DECL|function|refill_freelist
r_static
r_void
id|refill_freelist
c_func
(paren
r_int
id|size
)paren
(brace
id|balance_dirty
c_func
(paren
id|NODEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free_shortage
c_func
(paren
)paren
)paren
id|page_launder
c_func
(paren
id|GFP_BUFFER
comma
l_int|0
)paren
suffix:semicolon
id|grow_buffers
c_func
(paren
id|size
)paren
suffix:semicolon
)brace
DECL|function|init_buffer
r_void
id|init_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
id|bh_end_io_t
op_star
id|handler
comma
r_void
op_star
r_private
)paren
(brace
id|bh-&gt;b_list
op_assign
id|BUF_CLEAN
suffix:semicolon
id|bh-&gt;b_end_io
op_assign
id|handler
suffix:semicolon
id|bh-&gt;b_private
op_assign
r_private
suffix:semicolon
)brace
DECL|function|end_buffer_io_async
r_static
r_void
id|end_buffer_io_async
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_static
id|spinlock_t
id|page_uptodate_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tmp
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
id|mark_buffer_uptodate
c_func
(paren
id|bh
comma
id|uptodate
)paren
suffix:semicolon
multiline_comment|/* This is a temporary buffer used for page I/O. */
id|page
op_assign
id|bh-&gt;b_page
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|SetPageError
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Be _very_ careful from here on. Bad things can happen if&n;&t; * two buffer heads end IO at almost the same time and both&n;&t; * decide that the page is now completely done.&n;&t; *&n;&t; * Async buffer_heads are here only as labels for IO, and get&n;&t; * thrown away once the IO for this page is complete.  IO is&n;&t; * deemed complete once all buffers have been visited&n;&t; * (b_count==0) and are now unlocked. We must make sure that&n;&t; * only the _last_ buffer that decrements its count is the one&n;&t; * that unlock the page..&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|tmp
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;b_end_io
op_eq
id|end_buffer_io_async
op_logical_and
id|buffer_locked
c_func
(paren
id|tmp
)paren
)paren
r_goto
id|still_busy
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
)brace
multiline_comment|/* OK, the async IO on this page is complete. */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * if none of the buffers had errors then we can set the&n;&t; * page uptodate:&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|PageError
c_func
(paren
id|page
)paren
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Run the hooks that have to be done when a page I/O has completed.&n;&t; */
r_if
c_cond
(paren
id|PageTestandClearDecrAfter
c_func
(paren
id|page
)paren
)paren
id|atomic_dec
c_func
(paren
op_amp
id|nr_async_pages
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
suffix:semicolon
id|still_busy
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|page_uptodate_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Synchronise all the inode&squot;s dirty buffers to the disk.&n; *&n; * We have conflicting pressures: we want to make sure that all&n; * initially dirty buffers get waited on, but that any subsequently&n; * dirtied buffers don&squot;t.  After all, we don&squot;t want fsync to last&n; * forever if somebody is actively writing to the file.&n; *&n; * Do this in two main stages: first we copy dirty buffers to a&n; * temporary inode list, queueing the writes as we go.  Then we clean&n; * up, waiting for those writes to complete.&n; * &n; * During this second stage, any subsequent updates to the file may end&n; * up refiling the buffer on the original inode&squot;s dirty list again, so&n; * there is a chance we will end up with a buffer queued for write but&n; * not yet completed on that list.  So, as a final cleanup we go through&n; * the osync code to catch these locked, dirty buffers without requeuing&n; * any newly dirty buffers for write.&n; */
DECL|function|fsync_inode_buffers
r_int
id|fsync_inode_buffers
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|inode
id|tmp
suffix:semicolon
r_int
id|err
op_assign
l_int|0
comma
id|err2
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|tmp.i_dirty_buffers
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|inode-&gt;i_dirty_buffers
)paren
)paren
(brace
id|bh
op_assign
id|BH_ENTRY
c_func
(paren
id|inode-&gt;i_dirty_buffers.next
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|bh-&gt;b_inode_buffers
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
id|bh-&gt;b_inode
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
id|bh-&gt;b_inode
op_assign
op_amp
id|tmp
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|bh-&gt;b_inode_buffers
comma
op_amp
id|tmp.i_dirty_buffers
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|tmp.i_dirty_buffers
)paren
)paren
(brace
id|bh
op_assign
id|BH_ENTRY
c_func
(paren
id|tmp.i_dirty_buffers.prev
)paren
suffix:semicolon
id|remove_inode_queue
c_func
(paren
id|bh
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|err2
op_assign
id|osync_inode_buffers
c_func
(paren
id|inode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_else
r_return
id|err2
suffix:semicolon
)brace
multiline_comment|/*&n; * osync is designed to support O_SYNC io.  It waits synchronously for&n; * all already-submitted IO to complete, but does not queue any new&n; * writes to the disk.&n; *&n; * To do O_SYNC writes, just queue the buffer writes with ll_rw_block as&n; * you dirty the buffers, and then use osync_inode_buffers to wait for&n; * completion.  Any other dirty buffers which are not yet queued for&n; * write will not be flushed to disk by the osync.&n; */
DECL|function|osync_inode_buffers
r_int
id|osync_inode_buffers
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|list_head
op_star
id|list
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|repeat
suffix:colon
r_for
c_loop
(paren
id|list
op_assign
id|inode-&gt;i_dirty_buffers.prev
suffix:semicolon
id|bh
op_assign
id|BH_ENTRY
c_func
(paren
id|list
)paren
comma
id|list
op_ne
op_amp
id|inode-&gt;i_dirty_buffers
suffix:semicolon
id|list
op_assign
id|bh-&gt;b_inode_buffers.prev
)paren
(brace
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Invalidate any and all dirty buffers on a given inode.  We are&n; * probably unmounting the fs, but that doesn&squot;t mean we have already&n; * done a sync().  Just drop the buffers from the inode list.&n; */
DECL|function|invalidate_inode_buffers
r_void
id|invalidate_inode_buffers
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|list_head
op_star
id|list
comma
op_star
id|next
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|list
op_assign
id|inode-&gt;i_dirty_buffers.next
suffix:semicolon
r_while
c_loop
(paren
id|list
op_ne
op_amp
id|inode-&gt;i_dirty_buffers
)paren
(brace
id|next
op_assign
id|list-&gt;next
suffix:semicolon
id|remove_inode_queue
c_func
(paren
id|BH_ENTRY
c_func
(paren
id|list
)paren
)paren
suffix:semicolon
id|list
op_assign
id|next
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Ok, this is getblk, and it isn&squot;t very clear, again to hinder&n; * race-conditions. Most of the code is seldom used, (ie repeating),&n; * so it should be much more efficient than it looks.&n; *&n; * The algorithm is changed: hopefully better, and an elusive bug removed.&n; *&n; * 14.02.92: changed it to sync dirty buffers a bit: better performance&n; * when the filesystem starts to get full of dirty blocks (I hope).&n; */
DECL|function|getblk
r_struct
id|buffer_head
op_star
id|getblk
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|isize
suffix:semicolon
id|repeat
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|hash_table_lock
)paren
suffix:semicolon
id|bh
op_assign
id|__get_hash_table
c_func
(paren
id|dev
comma
id|block
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
r_goto
id|out
suffix:semicolon
id|isize
op_assign
id|BUFSIZE_INDEX
c_func
(paren
id|size
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|free_list
(braket
id|isize
)braket
dot
id|lock
)paren
suffix:semicolon
id|bh
op_assign
id|free_list
(braket
id|isize
)braket
dot
id|list
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
id|__remove_from_free_list
c_func
(paren
id|bh
comma
id|isize
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|bh-&gt;b_count
comma
l_int|1
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|free_list
(braket
id|isize
)braket
dot
id|lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * OK, FINALLY we know that this buffer is the only one of&n;&t; * its kind, we hold a reference (b_count&gt;0), it is unlocked,&n;&t; * and it is clean.&n;&t; */
r_if
c_cond
(paren
id|bh
)paren
(brace
id|init_buffer
c_func
(paren
id|bh
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|bh-&gt;b_dev
op_assign
id|dev
suffix:semicolon
id|bh-&gt;b_blocknr
op_assign
id|block
suffix:semicolon
id|bh-&gt;b_state
op_assign
l_int|1
op_lshift
id|BH_Mapped
suffix:semicolon
multiline_comment|/* Insert the buffer into the regular lists */
id|__insert_into_queues
c_func
(paren
id|bh
)paren
suffix:semicolon
id|out
suffix:colon
id|write_unlock
c_func
(paren
op_amp
id|hash_table_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|touch_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we block while refilling the free list, somebody may&n;&t; * create the buffer first ... search the hashes again.&n;&t; */
id|write_unlock
c_func
(paren
op_amp
id|hash_table_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|refill_freelist
c_func
(paren
id|size
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/* -1 -&gt; no need to flush&n;    0 -&gt; async flush&n;    1 -&gt; sync flush (wait for I/O completation) */
DECL|function|balance_dirty_state
r_int
id|balance_dirty_state
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
r_int
id|dirty
comma
id|tot
comma
id|hard_dirty_limit
comma
id|soft_dirty_limit
suffix:semicolon
r_int
id|shortage
suffix:semicolon
id|dirty
op_assign
id|size_buffers_type
(braket
id|BUF_DIRTY
)braket
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|tot
op_assign
id|nr_free_buffer_pages
c_func
(paren
)paren
suffix:semicolon
id|dirty
op_mul_assign
l_int|100
suffix:semicolon
id|soft_dirty_limit
op_assign
id|tot
op_star
id|bdf_prm.b_un.nfract
suffix:semicolon
id|hard_dirty_limit
op_assign
id|tot
op_star
id|bdf_prm.b_un.nfract_sync
suffix:semicolon
multiline_comment|/* First, check for the &quot;real&quot; dirty limit. */
r_if
c_cond
(paren
id|dirty
OG
id|soft_dirty_limit
)paren
(brace
r_if
c_cond
(paren
id|dirty
OG
id|hard_dirty_limit
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we are about to get low on free pages and&n;&t; * cleaning the inactive_dirty pages would help&n;&t; * fix this, wake up bdflush.&n;&t; */
id|shortage
op_assign
id|free_shortage
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shortage
op_logical_and
id|nr_inactive_dirty_pages
OG
id|shortage
op_logical_and
id|nr_inactive_dirty_pages
OG
id|freepages.high
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * if a new dirty buffer is created we need to balance bdflush.&n; *&n; * in the future we might want to make bdflush aware of different&n; * pressures on different devices - thus the (currently unused)&n; * &squot;dev&squot; parameter.&n; */
DECL|function|balance_dirty
r_void
id|balance_dirty
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
id|state
op_assign
id|balance_dirty_state
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
OL
l_int|0
)paren
r_return
suffix:semicolon
id|wakeup_bdflush
c_func
(paren
id|state
)paren
suffix:semicolon
)brace
DECL|function|__mark_dirty
r_static
id|__inline__
r_void
id|__mark_dirty
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|bh-&gt;b_flushtime
op_assign
id|jiffies
op_plus
id|bdf_prm.b_un.age_buffer
suffix:semicolon
id|refile_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/* atomic version, the user must call balance_dirty() by hand&n;   as soon as it become possible to block */
DECL|function|__mark_buffer_dirty
r_void
id|__mark_buffer_dirty
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|atomic_set_buffer_dirty
c_func
(paren
id|bh
)paren
)paren
id|__mark_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
DECL|function|mark_buffer_dirty
r_void
id|mark_buffer_dirty
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|atomic_set_buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|__mark_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|balance_dirty
c_func
(paren
id|bh-&gt;b_dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * A buffer may need to be moved from one buffer list to another&n; * (e.g. in case it is not shared any more). Handle this.&n; */
DECL|function|__refile_buffer
r_static
r_void
id|__refile_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_int
id|dispose
op_assign
id|BUF_CLEAN
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
id|dispose
op_assign
id|BUF_LOCKED
suffix:semicolon
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
id|dispose
op_assign
id|BUF_DIRTY
suffix:semicolon
r_if
c_cond
(paren
id|buffer_protected
c_func
(paren
id|bh
)paren
)paren
id|dispose
op_assign
id|BUF_PROTECTED
suffix:semicolon
r_if
c_cond
(paren
id|dispose
op_ne
id|bh-&gt;b_list
)paren
(brace
id|__remove_from_lru_list
c_func
(paren
id|bh
comma
id|bh-&gt;b_list
)paren
suffix:semicolon
id|bh-&gt;b_list
op_assign
id|dispose
suffix:semicolon
r_if
c_cond
(paren
id|dispose
op_eq
id|BUF_CLEAN
)paren
id|remove_inode_queue
c_func
(paren
id|bh
)paren
suffix:semicolon
id|__insert_into_lru_list
c_func
(paren
id|bh
comma
id|dispose
)paren
suffix:semicolon
)brace
)brace
DECL|function|refile_buffer
r_void
id|refile_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|__refile_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Release a buffer head&n; */
DECL|function|__brelse
r_void
id|__brelse
c_func
(paren
r_struct
id|buffer_head
op_star
id|buf
)paren
(brace
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|buf-&gt;b_count
)paren
)paren
(brace
id|atomic_dec
c_func
(paren
op_amp
id|buf-&gt;b_count
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;VFS: brelse: Trying to free free buffer&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * bforget() is like brelse(), except it puts the buffer on the&n; * free list if it can.. We can NOT free the buffer if:&n; *  - there are other users of it&n; *  - it is locked and thus can have active IO&n; */
DECL|function|__bforget
r_void
id|__bforget
c_func
(paren
r_struct
id|buffer_head
op_star
id|buf
)paren
(brace
multiline_comment|/* grab the lru lock here to block bdflush. */
id|spin_lock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|hash_table_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_dec_and_test
c_func
(paren
op_amp
id|buf-&gt;b_count
)paren
op_logical_or
id|buffer_locked
c_func
(paren
id|buf
)paren
)paren
r_goto
id|in_use
suffix:semicolon
id|__hash_unlink
c_func
(paren
id|buf
)paren
suffix:semicolon
id|remove_inode_queue
c_func
(paren
id|buf
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|hash_table_lock
)paren
suffix:semicolon
id|__remove_from_lru_list
c_func
(paren
id|buf
comma
id|buf-&gt;b_list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|put_last_free
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
suffix:semicolon
id|in_use
suffix:colon
id|write_unlock
c_func
(paren
op_amp
id|hash_table_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * bread() reads a specified block and returns the buffer that contains&n; * it. It returns NULL if the block was unreadable.&n; */
DECL|function|bread
r_struct
id|buffer_head
op_star
id|bread
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|bh
op_assign
id|getblk
c_func
(paren
id|dev
comma
id|block
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_return
id|bh
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_return
id|bh
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: the caller should wake up the buffer_wait list if needed.&n; */
DECL|function|__put_unused_buffer_head
r_static
id|__inline__
r_void
id|__put_unused_buffer_head
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_inode
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_unused_buffer_heads
op_ge
id|MAX_UNUSED_BUFFERS
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|bh_cachep
comma
id|bh
)paren
suffix:semicolon
)brace
r_else
(brace
id|bh-&gt;b_blocknr
op_assign
op_minus
l_int|1
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|bh-&gt;b_wait
)paren
suffix:semicolon
id|nr_unused_buffer_heads
op_increment
suffix:semicolon
id|bh-&gt;b_next_free
op_assign
id|unused_list
suffix:semicolon
id|bh-&gt;b_this_page
op_assign
l_int|NULL
suffix:semicolon
id|unused_list
op_assign
id|bh
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Reserve NR_RESERVED buffer heads for async IO requests to avoid&n; * no-buffer-head deadlock.  Return NULL on failure; waiting for&n; * buffer heads is now handled in create_buffers().&n; */
DECL|function|get_unused_buffer_head
r_static
r_struct
id|buffer_head
op_star
id|get_unused_buffer_head
c_func
(paren
r_int
id|async
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|unused_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_unused_buffer_heads
OG
id|NR_RESERVED
)paren
(brace
id|bh
op_assign
id|unused_list
suffix:semicolon
id|unused_list
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
id|nr_unused_buffer_heads
op_decrement
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|unused_list_lock
)paren
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|unused_list_lock
)paren
suffix:semicolon
multiline_comment|/* This is critical.  We can&squot;t swap out pages to get&n;&t; * more buffer heads, because the swap-out may need&n;&t; * more buffer-heads itself.  Thus SLAB_BUFFER.&n;&t; */
r_if
c_cond
(paren
(paren
id|bh
op_assign
id|kmem_cache_alloc
c_func
(paren
id|bh_cachep
comma
id|SLAB_BUFFER
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|memset
c_func
(paren
id|bh
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|bh
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|bh-&gt;b_wait
)paren
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we need an async buffer, use the reserved buffer heads.&n;&t; */
r_if
c_cond
(paren
id|async
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|unused_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unused_list
)paren
(brace
id|bh
op_assign
id|unused_list
suffix:semicolon
id|unused_list
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
id|nr_unused_buffer_heads
op_decrement
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|unused_list_lock
)paren
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|unused_list_lock
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n;&t; * (Pending further analysis ...)&n;&t; * Ordinary (non-async) requests can use a different memory priority&n;&t; * to free up pages. Any swapping thus generated will use async&n;&t; * buffer heads.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|async
op_logical_and
(paren
id|bh
op_assign
id|kmem_cache_alloc
c_func
(paren
id|bh_cachep
comma
id|SLAB_KERNEL
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|memset
c_func
(paren
id|bh
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|bh
)paren
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|bh-&gt;b_wait
)paren
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|set_bh_page
r_void
id|set_bh_page
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
)paren
(brace
id|bh-&gt;b_page
op_assign
id|page
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_ge
id|PAGE_SIZE
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PageHighMem
c_func
(paren
id|page
)paren
)paren
multiline_comment|/*&n;&t;&t; * This catches illegal uses and preserves the offset:&n;&t;&t; */
id|bh-&gt;b_data
op_assign
(paren
r_char
op_star
)paren
(paren
l_int|0
op_plus
id|offset
)paren
suffix:semicolon
r_else
id|bh-&gt;b_data
op_assign
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|offset
suffix:semicolon
)brace
multiline_comment|/*&n; * Create the appropriate buffers when given a page for data area and&n; * the size of each buffer.. Use the bh-&gt;b_this_page linked list to&n; * follow the buffers created.  Return NULL if unable to create more&n; * buffers.&n; * The async flag is used to differentiate async IO (paging, swapping)&n; * from ordinary buffer allocations, and only async requests are allowed&n; * to sleep waiting for buffer heads. &n; */
DECL|function|create_buffers
r_static
r_struct
id|buffer_head
op_star
id|create_buffers
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|size
comma
r_int
id|async
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
r_int
id|offset
suffix:semicolon
id|try_again
suffix:colon
id|head
op_assign
l_int|NULL
suffix:semicolon
id|offset
op_assign
id|PAGE_SIZE
suffix:semicolon
r_while
c_loop
(paren
(paren
id|offset
op_sub_assign
id|size
)paren
op_ge
l_int|0
)paren
(brace
id|bh
op_assign
id|get_unused_buffer_head
c_func
(paren
id|async
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|no_grow
suffix:semicolon
id|bh-&gt;b_dev
op_assign
id|B_FREE
suffix:semicolon
multiline_comment|/* Flag as unused */
id|bh-&gt;b_this_page
op_assign
id|head
suffix:semicolon
id|head
op_assign
id|bh
suffix:semicolon
id|bh-&gt;b_state
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_next_free
op_assign
l_int|NULL
suffix:semicolon
id|bh-&gt;b_pprev
op_assign
l_int|NULL
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|bh-&gt;b_count
comma
l_int|0
)paren
suffix:semicolon
id|bh-&gt;b_size
op_assign
id|size
suffix:semicolon
id|set_bh_page
c_func
(paren
id|bh
comma
id|page
comma
id|offset
)paren
suffix:semicolon
id|bh-&gt;b_list
op_assign
id|BUF_CLEAN
suffix:semicolon
id|bh-&gt;b_end_io
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|head
suffix:semicolon
multiline_comment|/*&n; * In case anything failed, we just free everything we got.&n; */
id|no_grow
suffix:colon
r_if
c_cond
(paren
id|head
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|unused_list_lock
)paren
suffix:semicolon
r_do
(brace
id|bh
op_assign
id|head
suffix:semicolon
id|head
op_assign
id|head-&gt;b_this_page
suffix:semicolon
id|__put_unused_buffer_head
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|head
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|unused_list_lock
)paren
suffix:semicolon
multiline_comment|/* Wake up any waiters ... */
id|wake_up
c_func
(paren
op_amp
id|buffer_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Return failure for non-async IO requests.  Async IO requests&n;&t; * are not allowed to fail, so we have to wait until buffer heads&n;&t; * become available.  But we don&squot;t want tasks sleeping with &n;&t; * partially complete buffers, so all were released above.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|async
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* We&squot;re _really_ low on memory. Now we just&n;&t; * wait for old buffer heads to become free due to&n;&t; * finishing IO.  Since this is an async request and&n;&t; * the reserve list is empty, we&squot;re sure there are &n;&t; * async buffer heads in use.&n;&t; */
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Set our state for sleeping, then check again for buffer heads.&n;&t; * This ensures we won&squot;t miss a wake_up from an interrupt.&n;&t; */
id|wait_event
c_func
(paren
id|buffer_wait
comma
id|nr_unused_buffer_heads
op_ge
id|MAX_BUF_PER_PAGE
)paren
suffix:semicolon
r_goto
id|try_again
suffix:semicolon
)brace
DECL|function|unmap_buffer
r_static
r_void
id|unmap_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
id|mark_buffer_clean
c_func
(paren
id|bh
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Mapped
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Req
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_New
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * We don&squot;t have to release all buffers here, but&n; * we have to be sure that no dirty buffer is left&n; * and no IO is going on (no buffer is locked), because&n; * we have truncated the file and are going to free the&n; * blocks on-disk..&n; */
DECL|function|block_flushpage
r_int
id|block_flushpage
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
r_int
id|offset
)paren
(brace
r_struct
id|buffer_head
op_star
id|head
comma
op_star
id|bh
comma
op_star
id|next
suffix:semicolon
r_int
r_int
id|curr_off
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;buffers
)paren
r_return
l_int|1
suffix:semicolon
id|head
op_assign
id|page-&gt;buffers
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
r_int
r_int
id|next_off
op_assign
id|curr_off
op_plus
id|bh-&gt;b_size
suffix:semicolon
id|next
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
multiline_comment|/*&n;&t;&t; * is this block fully flushed?&n;&t;&t; */
r_if
c_cond
(paren
id|offset
op_le
id|curr_off
)paren
id|unmap_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|curr_off
op_assign
id|next_off
suffix:semicolon
id|bh
op_assign
id|next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * subtle. We release buffer-heads only if this is&n;&t; * the &squot;final&squot; flushpage. We have invalidated the get_block&n;&t; * cached value unconditionally, so real IO is not&n;&t; * possible anymore.&n;&t; *&n;&t; * If the free doesn&squot;t work out, the buffers can be&n;&t; * left around - they just turn into anonymous buffers&n;&t; * instead.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|offset
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|try_to_free_buffers
c_func
(paren
id|page
comma
l_int|0
)paren
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|buffermem_pages
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|create_empty_buffers
r_static
r_void
id|create_empty_buffers
c_func
(paren
r_struct
id|page
op_star
id|page
comma
id|kdev_t
id|dev
comma
r_int
r_int
id|blocksize
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
comma
op_star
id|tail
suffix:semicolon
id|head
op_assign
id|create_buffers
c_func
(paren
id|page
comma
id|blocksize
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|page-&gt;buffers
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
r_do
(brace
id|bh-&gt;b_dev
op_assign
id|dev
suffix:semicolon
id|bh-&gt;b_blocknr
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_end_io
op_assign
l_int|NULL
suffix:semicolon
id|tail
op_assign
id|bh
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
)paren
suffix:semicolon
id|tail-&gt;b_this_page
op_assign
id|head
suffix:semicolon
id|page-&gt;buffers
op_assign
id|head
suffix:semicolon
id|page_cache_get
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We are taking a block for data and we don&squot;t want any output from any&n; * buffer-cache aliases starting from return from that function and&n; * until the moment when something will explicitly mark the buffer&n; * dirty (hopefully that will not happen until we will free that block ;-)&n; * We don&squot;t even need to mark it not-uptodate - nobody can expect&n; * anything from a newly allocated buffer anyway. We used to used&n; * unmap_buffer() for such invalidation, but that was wrong. We definitely&n; * don&squot;t want to mark the alias unmapped, for example - it would confuse&n; * anyone who might pick it with bread() afterwards...&n; */
DECL|function|unmap_underlying_metadata
r_static
r_void
id|unmap_underlying_metadata
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|buffer_head
op_star
id|old_bh
suffix:semicolon
id|old_bh
op_assign
id|get_hash_table
c_func
(paren
id|bh-&gt;b_dev
comma
id|bh-&gt;b_blocknr
comma
id|bh-&gt;b_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_bh
)paren
(brace
id|mark_buffer_clean
c_func
(paren
id|old_bh
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|old_bh
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Req
comma
op_amp
id|old_bh-&gt;b_state
)paren
suffix:semicolon
multiline_comment|/* Here we could run brelse or bforget. We use&n;&t;&t;   bforget because it will try to put the buffer&n;&t;&t;   in the freelist. */
id|__bforget
c_func
(paren
id|old_bh
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * NOTE! All mapped/uptodate combinations are valid:&n; *&n; *&t;Mapped&t;Uptodate&t;Meaning&n; *&n; *&t;No&t;No&t;&t;&quot;unknown&quot; - must do get_block()&n; *&t;No&t;Yes&t;&t;&quot;hole&quot; - zero-filled&n; *&t;Yes&t;No&t;&t;&quot;allocated&quot; - allocated on disk, not read in&n; *&t;Yes&t;Yes&t;&t;&quot;valid&quot; - allocated and up-to-date in memory.&n; *&n; * &quot;Dirty&quot; is valid only with the last case (mapped+uptodate).&n; */
multiline_comment|/*&n; * block_write_full_page() is SMP-safe - currently it&squot;s still&n; * being called with the kernel lock held, but the code is ready.&n; */
DECL|function|__block_write_full_page
r_static
r_int
id|__block_write_full_page
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
comma
id|get_block_t
op_star
id|get_block
)paren
(brace
r_int
id|err
comma
id|i
suffix:semicolon
r_int
r_int
id|block
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;buffers
)paren
id|create_empty_buffers
c_func
(paren
id|page
comma
id|inode-&gt;i_dev
comma
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
suffix:semicolon
id|head
op_assign
id|page-&gt;buffers
suffix:semicolon
id|block
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|inode-&gt;i_sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Stage 1: make sure we have all the buffers mapped! */
r_do
(brace
multiline_comment|/*&n;&t;&t; * If the buffer isn&squot;t up-to-date, we can&squot;t be sure&n;&t;&t; * that the buffer has been initialized with the proper&n;&t;&t; * block number information etc..&n;&t;&t; *&n;&t;&t; * Leave it to the low-level FS to make all those&n;&t;&t; * decisions (block #0 may actually be a valid block)&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
id|err
op_assign
id|get_block
c_func
(paren
id|inode
comma
id|block
comma
id|bh
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|buffer_new
c_func
(paren
id|bh
)paren
)paren
id|unmap_underlying_metadata
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
id|block
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/* Stage 2: lock the buffers, mark them clean */
r_do
(brace
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_end_io
op_assign
id|end_buffer_io_async
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Dirty
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/* Stage 3: submit the IO */
r_do
(brace
id|submit_bh
c_func
(paren
id|WRITE
comma
id|bh
)paren
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/* Done - end_buffer_io_async will unlock */
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out
suffix:colon
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|__block_prepare_write
r_static
r_int
id|__block_prepare_write
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
comma
id|get_block_t
op_star
id|get_block
)paren
(brace
r_int
id|block_start
comma
id|block_end
suffix:semicolon
r_int
r_int
id|block
suffix:semicolon
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|blocksize
comma
id|bbits
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
comma
op_star
id|wait
(braket
l_int|2
)braket
comma
op_star
op_star
id|wait_bh
op_assign
id|wait
suffix:semicolon
r_char
op_star
id|kaddr
op_assign
id|kmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|blocksize
op_assign
id|inode-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;buffers
)paren
id|create_empty_buffers
c_func
(paren
id|page
comma
id|inode-&gt;i_dev
comma
id|blocksize
)paren
suffix:semicolon
id|head
op_assign
id|page-&gt;buffers
suffix:semicolon
id|bbits
op_assign
id|inode-&gt;i_sb-&gt;s_blocksize_bits
suffix:semicolon
id|block
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|bbits
)paren
suffix:semicolon
r_for
c_loop
(paren
id|bh
op_assign
id|head
comma
id|block_start
op_assign
l_int|0
suffix:semicolon
id|bh
op_ne
id|head
op_logical_or
op_logical_neg
id|block_start
suffix:semicolon
id|block
op_increment
comma
id|block_start
op_assign
id|block_end
comma
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|block_end
op_assign
id|block_start
op_plus
id|blocksize
suffix:semicolon
r_if
c_cond
(paren
id|block_end
op_le
id|from
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|block_start
op_ge
id|to
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
id|err
op_assign
id|get_block
c_func
(paren
id|inode
comma
id|block
comma
id|bh
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|buffer_new
c_func
(paren
id|bh
)paren
)paren
(brace
id|unmap_underlying_metadata
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|block_end
OG
id|to
)paren
id|memset
c_func
(paren
id|kaddr
op_plus
id|to
comma
l_int|0
comma
id|block_end
op_minus
id|to
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block_start
OL
id|from
)paren
id|memset
c_func
(paren
id|kaddr
op_plus
id|block_start
comma
l_int|0
comma
id|from
op_minus
id|block_start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block_end
OG
id|to
op_logical_or
id|block_start
OL
id|from
)paren
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
op_logical_and
(paren
id|block_start
template_param
id|to
)paren
)paren
(brace
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
op_star
id|wait_bh
op_increment
op_assign
id|bh
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If we issued read requests - let them complete.&n;&t; */
r_while
c_loop
(paren
id|wait_bh
OG
id|wait
)paren
(brace
id|wait_on_buffer
c_func
(paren
op_star
op_decrement
id|wait_bh
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
op_star
id|wait_bh
)paren
)paren
r_goto
id|out
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|__block_commit_write
r_static
r_int
id|__block_commit_write
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
r_int
id|block_start
comma
id|block_end
suffix:semicolon
r_int
id|partial
op_assign
l_int|0
comma
id|need_balance_dirty
op_assign
l_int|0
suffix:semicolon
r_int
id|blocksize
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
id|blocksize
op_assign
id|inode-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
r_for
c_loop
(paren
id|bh
op_assign
id|head
op_assign
id|page-&gt;buffers
comma
id|block_start
op_assign
l_int|0
suffix:semicolon
id|bh
op_ne
id|head
op_logical_or
op_logical_neg
id|block_start
suffix:semicolon
id|block_start
op_assign
id|block_end
comma
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
(brace
id|block_end
op_assign
id|block_start
op_plus
id|blocksize
suffix:semicolon
r_if
c_cond
(paren
id|block_end
op_le
id|from
op_logical_or
id|block_start
op_ge
id|to
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|partial
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|set_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|atomic_set_buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|__mark_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|buffer_insert_inode_queue
c_func
(paren
id|bh
comma
id|inode
)paren
suffix:semicolon
id|need_balance_dirty
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|need_balance_dirty
)paren
id|balance_dirty
c_func
(paren
id|bh-&gt;b_dev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * is this a partial write that happened to make all buffers&n;&t; * uptodate then we can optimize away a bogus readpage() for&n;&t; * the next read(). Here we &squot;discover&squot; wether the page went&n;&t; * uptodate as a result of this (potentially partial) write.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|partial
)paren
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Generic &quot;read page&quot; function for block devices that have the normal&n; * get_block functionality. This is most of the block device filesystems.&n; * Reads the page asynchronously --- the unlock_buffer() and&n; * mark_buffer_uptodate() functions propagate buffer state into the&n; * page struct once IO has completed.&n; */
DECL|function|block_read_full_page
r_int
id|block_read_full_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
id|get_block_t
op_star
id|get_block
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_int
r_int
id|iblock
comma
id|lblock
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
comma
op_star
id|arr
(braket
id|MAX_BUF_PER_PAGE
)braket
suffix:semicolon
r_int
r_int
id|blocksize
comma
id|blocks
suffix:semicolon
r_int
id|nr
comma
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|PAGE_BUG
c_func
(paren
id|page
)paren
suffix:semicolon
id|blocksize
op_assign
id|inode-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;buffers
)paren
id|create_empty_buffers
c_func
(paren
id|page
comma
id|inode-&gt;i_dev
comma
id|blocksize
)paren
suffix:semicolon
id|head
op_assign
id|page-&gt;buffers
suffix:semicolon
id|blocks
op_assign
id|PAGE_CACHE_SIZE
op_rshift
id|inode-&gt;i_sb-&gt;s_blocksize_bits
suffix:semicolon
id|iblock
op_assign
id|page-&gt;index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|inode-&gt;i_sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
id|lblock
op_assign
(paren
id|inode-&gt;i_size
op_plus
id|blocksize
op_minus
l_int|1
)paren
op_rshift
id|inode-&gt;i_sb-&gt;s_blocksize_bits
suffix:semicolon
id|bh
op_assign
id|head
suffix:semicolon
id|nr
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
r_if
c_cond
(paren
id|iblock
OL
id|lblock
)paren
(brace
r_if
c_cond
(paren
id|get_block
c_func
(paren
id|inode
comma
id|iblock
comma
id|bh
comma
l_int|0
)paren
)paren
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
id|memset
c_func
(paren
id|kmap
c_func
(paren
id|page
)paren
op_plus
id|i
op_star
id|blocksize
comma
l_int|0
comma
id|blocksize
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* get_block() might have updated the buffer synchronously */
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
)brace
id|arr
(braket
id|nr
)braket
op_assign
id|bh
suffix:semicolon
id|nr
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
op_increment
comma
id|iblock
op_increment
comma
(paren
id|bh
op_assign
id|bh-&gt;b_this_page
)paren
op_ne
id|head
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
(brace
multiline_comment|/*&n;&t;&t; * all buffers are uptodate - we can set the page&n;&t;&t; * uptodate as well.&n;&t;&t; */
id|SetPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Stage two: lock the buffers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|arr
(braket
id|i
)braket
suffix:semicolon
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_end_io
op_assign
id|end_buffer_io_async
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
)brace
multiline_comment|/* Stage 3: start the IO */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
id|submit_bh
c_func
(paren
id|READ
comma
id|arr
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * For moronic filesystems that do not allow holes in file.&n; * We may have to extend the file.&n; */
DECL|function|cont_prepare_write
r_int
id|cont_prepare_write
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|offset
comma
r_int
id|to
comma
id|get_block_t
op_star
id|get_block
comma
r_int
r_int
op_star
id|bytes
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|page-&gt;mapping
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
r_struct
id|page
op_star
id|new_page
suffix:semicolon
r_int
r_int
id|pgpos
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|zerofrom
suffix:semicolon
r_int
id|blocksize
op_assign
id|inode-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
r_char
op_star
id|kaddr
suffix:semicolon
r_while
c_loop
(paren
id|page-&gt;index
OG
(paren
id|pgpos
op_assign
op_star
id|bytes
op_rshift
id|PAGE_CACHE_SHIFT
)paren
)paren
(brace
id|status
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|new_page
op_assign
id|grab_cache_page
c_func
(paren
id|mapping
comma
id|pgpos
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_page
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* we might sleep */
r_if
c_cond
(paren
op_star
id|bytes
op_rshift
id|PAGE_CACHE_SHIFT
op_ne
id|pgpos
)paren
(brace
id|UnlockPage
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|new_page
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|zerofrom
op_assign
op_star
id|bytes
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|zerofrom
op_amp
(paren
id|blocksize
op_minus
l_int|1
)paren
)paren
(brace
op_star
id|bytes
op_or_assign
(paren
id|blocksize
op_minus
l_int|1
)paren
suffix:semicolon
(paren
op_star
id|bytes
)paren
op_increment
suffix:semicolon
)brace
id|status
op_assign
id|__block_prepare_write
c_func
(paren
id|inode
comma
id|new_page
comma
id|zerofrom
comma
id|PAGE_CACHE_SIZE
comma
id|get_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_goto
id|out_unmap
suffix:semicolon
id|kaddr
op_assign
id|page_address
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|memset
c_func
(paren
id|kaddr
op_plus
id|zerofrom
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|zerofrom
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|__block_commit_write
c_func
(paren
id|inode
comma
id|new_page
comma
id|zerofrom
comma
id|PAGE_CACHE_SIZE
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|new_page
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page-&gt;index
OL
id|pgpos
)paren
(brace
multiline_comment|/* completely inside the area */
id|zerofrom
op_assign
id|offset
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* page covers the boundary, find the boundary offset */
id|zerofrom
op_assign
op_star
id|bytes
op_amp
op_complement
id|PAGE_CACHE_MASK
suffix:semicolon
multiline_comment|/* if we will expand the thing last block will be filled */
r_if
c_cond
(paren
id|to
OG
id|zerofrom
op_logical_and
(paren
id|zerofrom
op_amp
(paren
id|blocksize
op_minus
l_int|1
)paren
)paren
)paren
(brace
op_star
id|bytes
op_or_assign
(paren
id|blocksize
op_minus
l_int|1
)paren
suffix:semicolon
(paren
op_star
id|bytes
)paren
op_increment
suffix:semicolon
)brace
multiline_comment|/* starting below the boundary? Nothing to zero out */
r_if
c_cond
(paren
id|offset
op_le
id|zerofrom
)paren
id|zerofrom
op_assign
id|offset
suffix:semicolon
)brace
id|status
op_assign
id|__block_prepare_write
c_func
(paren
id|inode
comma
id|page
comma
id|zerofrom
comma
id|to
comma
id|get_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
r_goto
id|out1
suffix:semicolon
id|kaddr
op_assign
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zerofrom
OL
id|offset
)paren
(brace
id|memset
c_func
(paren
id|kaddr
op_plus
id|zerofrom
comma
l_int|0
comma
id|offset
op_minus
id|zerofrom
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|__block_commit_write
c_func
(paren
id|inode
comma
id|page
comma
id|zerofrom
comma
id|offset
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|out1
suffix:colon
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
id|out_unmap
suffix:colon
id|ClearPageUptodate
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|new_page
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|status
suffix:semicolon
)brace
DECL|function|block_prepare_write
r_int
id|block_prepare_write
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
comma
id|get_block_t
op_star
id|get_block
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_int
id|err
op_assign
id|__block_prepare_write
c_func
(paren
id|inode
comma
id|page
comma
id|from
comma
id|to
comma
id|get_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
DECL|function|generic_commit_write
r_int
id|generic_commit_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_struct
id|page
op_star
id|page
comma
r_int
id|from
comma
r_int
id|to
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
id|loff_t
id|pos
op_assign
(paren
(paren
id|loff_t
)paren
id|page-&gt;index
op_lshift
id|PAGE_CACHE_SHIFT
)paren
op_plus
id|to
suffix:semicolon
id|__block_commit_write
c_func
(paren
id|inode
comma
id|page
comma
id|from
comma
id|to
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos
OG
id|inode-&gt;i_size
)paren
(brace
id|inode-&gt;i_size
op_assign
id|pos
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|block_truncate_page
r_int
id|block_truncate_page
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
id|loff_t
id|from
comma
id|get_block_t
op_star
id|get_block
)paren
(brace
r_int
r_int
id|index
op_assign
id|from
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_int
id|offset
op_assign
id|from
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_int
id|blocksize
comma
id|iblock
comma
id|length
comma
id|pos
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|err
suffix:semicolon
id|blocksize
op_assign
id|inode-&gt;i_sb-&gt;s_blocksize
suffix:semicolon
id|length
op_assign
id|offset
op_amp
(paren
id|blocksize
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Block boundary? Nothing to do */
r_if
c_cond
(paren
op_logical_neg
id|length
)paren
r_return
l_int|0
suffix:semicolon
id|length
op_assign
id|blocksize
op_minus
id|length
suffix:semicolon
id|iblock
op_assign
id|index
op_lshift
(paren
id|PAGE_CACHE_SHIFT
op_minus
id|inode-&gt;i_sb-&gt;s_blocksize_bits
)paren
suffix:semicolon
id|page
op_assign
id|grab_cache_page
c_func
(paren
id|mapping
comma
id|index
)paren
suffix:semicolon
id|err
op_assign
id|PTR_ERR
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|page
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;buffers
)paren
id|create_empty_buffers
c_func
(paren
id|page
comma
id|inode-&gt;i_dev
comma
id|blocksize
)paren
suffix:semicolon
multiline_comment|/* Find the buffer that contains &quot;offset&quot; */
id|bh
op_assign
id|page-&gt;buffers
suffix:semicolon
id|pos
op_assign
id|blocksize
suffix:semicolon
r_while
c_loop
(paren
id|offset
op_ge
id|pos
)paren
(brace
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
id|iblock
op_increment
suffix:semicolon
id|pos
op_add_assign
id|blocksize
suffix:semicolon
)brace
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
(brace
multiline_comment|/* Hole? Nothing to do */
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_goto
id|unlock
suffix:semicolon
id|get_block
c_func
(paren
id|inode
comma
id|iblock
comma
id|bh
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Still unmapped? Nothing to do */
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
r_goto
id|unlock
suffix:semicolon
)brace
multiline_comment|/* Ok, it&squot;s mapped. Make sure it&squot;s up-to-date */
r_if
c_cond
(paren
id|Page_Uptodate
c_func
(paren
id|page
)paren
)paren
id|set_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
(brace
id|err
op_assign
op_minus
id|EIO
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* Uhhuh. Read error. Complain and punt. */
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
r_goto
id|unlock
suffix:semicolon
)brace
id|memset
c_func
(paren
id|kmap
c_func
(paren
id|page
)paren
op_plus
id|offset
comma
l_int|0
comma
id|length
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|__mark_buffer_dirty
c_func
(paren
id|bh
)paren
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|unlock
suffix:colon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|out
suffix:colon
r_return
id|err
suffix:semicolon
)brace
DECL|function|block_write_full_page
r_int
id|block_write_full_page
c_func
(paren
r_struct
id|page
op_star
id|page
comma
id|get_block_t
op_star
id|get_block
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|page-&gt;mapping-&gt;host
suffix:semicolon
r_int
r_int
id|end_index
op_assign
id|inode-&gt;i_size
op_rshift
id|PAGE_CACHE_SHIFT
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/* easy case */
r_if
c_cond
(paren
id|page-&gt;index
OL
id|end_index
)paren
r_return
id|__block_write_full_page
c_func
(paren
id|inode
comma
id|page
comma
id|get_block
)paren
suffix:semicolon
multiline_comment|/* things got complicated... */
id|offset
op_assign
id|inode-&gt;i_size
op_amp
(paren
id|PAGE_CACHE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* OK, are we completely out? */
r_if
c_cond
(paren
id|page-&gt;index
op_ge
id|end_index
op_plus
l_int|1
op_logical_or
op_logical_neg
id|offset
)paren
(brace
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Sigh... will have to work, then... */
id|err
op_assign
id|__block_prepare_write
c_func
(paren
id|inode
comma
id|page
comma
l_int|0
comma
id|offset
comma
id|get_block
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
(brace
id|memset
c_func
(paren
id|page_address
c_func
(paren
id|page
)paren
op_plus
id|offset
comma
l_int|0
comma
id|PAGE_CACHE_SIZE
op_minus
id|offset
)paren
suffix:semicolon
id|flush_dcache_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|__block_commit_write
c_func
(paren
id|inode
comma
id|page
comma
l_int|0
comma
id|offset
)paren
suffix:semicolon
id|done
suffix:colon
id|kunmap
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|ClearPageUptodate
c_func
(paren
id|page
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
DECL|function|generic_block_bmap
r_int
id|generic_block_bmap
c_func
(paren
r_struct
id|address_space
op_star
id|mapping
comma
r_int
id|block
comma
id|get_block_t
op_star
id|get_block
)paren
(brace
r_struct
id|buffer_head
id|tmp
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|mapping-&gt;host
suffix:semicolon
id|tmp.b_state
op_assign
l_int|0
suffix:semicolon
id|tmp.b_blocknr
op_assign
l_int|0
suffix:semicolon
id|get_block
c_func
(paren
id|inode
comma
id|block
comma
op_amp
id|tmp
comma
l_int|0
)paren
suffix:semicolon
r_return
id|tmp.b_blocknr
suffix:semicolon
)brace
multiline_comment|/*&n; * IO completion routine for a buffer_head being used for kiobuf IO: we&n; * can&squot;t dispatch the kiobuf callback until io_count reaches 0.  &n; */
DECL|function|end_buffer_io_kiobuf
r_static
r_void
id|end_buffer_io_kiobuf
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_struct
id|kiobuf
op_star
id|kiobuf
suffix:semicolon
id|mark_buffer_uptodate
c_func
(paren
id|bh
comma
id|uptodate
)paren
suffix:semicolon
id|kiobuf
op_assign
id|bh-&gt;b_private
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|end_kio_request
c_func
(paren
id|kiobuf
comma
id|uptodate
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * For brw_kiovec: submit a set of buffer_head temporary IOs and wait&n; * for them to complete.  Clean up the buffer_heads afterwards.  &n; */
DECL|function|wait_kio
r_static
r_int
id|wait_kio
c_func
(paren
r_int
id|rw
comma
r_int
id|nr
comma
r_struct
id|buffer_head
op_star
id|bh
(braket
)braket
comma
r_int
id|size
)paren
(brace
r_int
id|iosize
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tmp
suffix:semicolon
id|iosize
op_assign
l_int|0
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|unused_list_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nr
suffix:semicolon
op_decrement
id|i
op_ge
l_int|0
suffix:semicolon
)paren
(brace
id|iosize
op_add_assign
id|size
suffix:semicolon
id|tmp
op_assign
id|bh
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|tmp
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|unused_list_lock
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|unused_list_lock
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|tmp
)paren
)paren
(brace
multiline_comment|/* We are traversing bh&squot;es in reverse order so&n;                           clearing iosize on error calculates the&n;                           amount of IO before the first error. */
id|iosize
op_assign
l_int|0
suffix:semicolon
)brace
id|__put_unused_buffer_head
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|unused_list_lock
)paren
suffix:semicolon
r_return
id|iosize
suffix:semicolon
)brace
multiline_comment|/*&n; * Start I/O on a physical range of kernel memory, defined by a vector&n; * of kiobuf structs (much like a user-space iovec list).&n; *&n; * The kiobuf must already be locked for IO.  IO is submitted&n; * asynchronously: you need to check page-&gt;locked, page-&gt;uptodate, and&n; * maybe wait on page-&gt;wait.&n; *&n; * It is up to the caller to make sure that there are enough blocks&n; * passed in to completely map the iobufs to disk.&n; */
DECL|function|brw_kiovec
r_int
id|brw_kiovec
c_func
(paren
r_int
id|rw
comma
r_int
id|nr
comma
r_struct
id|kiobuf
op_star
id|iovec
(braket
)braket
comma
id|kdev_t
id|dev
comma
r_int
r_int
id|b
(braket
)braket
comma
r_int
id|size
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
id|length
suffix:semicolon
r_int
id|transferred
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|bufind
suffix:semicolon
r_int
id|pageind
suffix:semicolon
r_int
id|bhind
suffix:semicolon
r_int
id|offset
suffix:semicolon
r_int
r_int
id|blocknr
suffix:semicolon
r_struct
id|kiobuf
op_star
id|iobuf
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|page
op_star
id|map
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tmp
comma
op_star
id|bh
(braket
id|KIO_MAX_SECTORS
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t; * First, do some alignment and validity checks &n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|iobuf
op_assign
id|iovec
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iobuf-&gt;offset
op_amp
(paren
id|size
op_minus
l_int|1
)paren
)paren
op_logical_or
(paren
id|iobuf-&gt;length
op_amp
(paren
id|size
op_minus
l_int|1
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iobuf-&gt;nr_pages
)paren
id|panic
c_func
(paren
l_string|&quot;brw_kiovec: iobuf not initialised&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* &n;&t; * OK to walk down the iovec doing page IO on each page we find. &n;&t; */
id|bufind
op_assign
id|bhind
op_assign
id|transferred
op_assign
id|err
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|iobuf
op_assign
id|iovec
(braket
id|i
)braket
suffix:semicolon
id|offset
op_assign
id|iobuf-&gt;offset
suffix:semicolon
id|length
op_assign
id|iobuf-&gt;length
suffix:semicolon
id|iobuf-&gt;errno
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|pageind
op_assign
l_int|0
suffix:semicolon
id|pageind
OL
id|iobuf-&gt;nr_pages
suffix:semicolon
id|pageind
op_increment
)paren
(brace
id|map
op_assign
id|iobuf-&gt;maplist
(braket
id|pageind
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|map
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
r_while
c_loop
(paren
id|length
OG
l_int|0
)paren
(brace
id|blocknr
op_assign
id|b
(braket
id|bufind
op_increment
)braket
suffix:semicolon
id|tmp
op_assign
id|get_unused_buffer_head
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|error
suffix:semicolon
)brace
id|tmp-&gt;b_dev
op_assign
id|B_FREE
suffix:semicolon
id|tmp-&gt;b_size
op_assign
id|size
suffix:semicolon
id|set_bh_page
c_func
(paren
id|tmp
comma
id|map
comma
id|offset
)paren
suffix:semicolon
id|tmp-&gt;b_this_page
op_assign
id|tmp
suffix:semicolon
id|init_buffer
c_func
(paren
id|tmp
comma
id|end_buffer_io_kiobuf
comma
id|iobuf
)paren
suffix:semicolon
id|tmp-&gt;b_dev
op_assign
id|dev
suffix:semicolon
id|tmp-&gt;b_blocknr
op_assign
id|blocknr
suffix:semicolon
id|tmp-&gt;b_state
op_assign
(paren
l_int|1
op_lshift
id|BH_Mapped
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Lock
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|WRITE
)paren
(brace
id|set_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|tmp-&gt;b_state
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Dirty
comma
op_amp
id|tmp-&gt;b_state
)paren
suffix:semicolon
)brace
id|bh
(braket
id|bhind
op_increment
)braket
op_assign
id|tmp
suffix:semicolon
id|length
op_sub_assign
id|size
suffix:semicolon
id|offset
op_add_assign
id|size
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|iobuf-&gt;io_count
)paren
suffix:semicolon
id|submit_bh
c_func
(paren
id|rw
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t; * Wait for IO if we have got too much &n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|bhind
op_ge
id|KIO_MAX_SECTORS
)paren
(brace
id|err
op_assign
id|wait_kio
c_func
(paren
id|rw
comma
id|bhind
comma
id|bh
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ge
l_int|0
)paren
id|transferred
op_add_assign
id|err
suffix:semicolon
r_else
r_goto
id|finished
suffix:semicolon
id|bhind
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
op_ge
id|PAGE_SIZE
)paren
(brace
id|offset
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* End of block loop */
)brace
multiline_comment|/* End of page loop */
)brace
multiline_comment|/* End of iovec loop */
multiline_comment|/* Is there any IO still left to submit? */
r_if
c_cond
(paren
id|bhind
)paren
(brace
id|err
op_assign
id|wait_kio
c_func
(paren
id|rw
comma
id|bhind
comma
id|bh
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_ge
l_int|0
)paren
id|transferred
op_add_assign
id|err
suffix:semicolon
r_else
r_goto
id|finished
suffix:semicolon
)brace
id|finished
suffix:colon
r_if
c_cond
(paren
id|transferred
)paren
r_return
id|transferred
suffix:semicolon
r_return
id|err
suffix:semicolon
id|error
suffix:colon
multiline_comment|/* We got an error allocating the bh&squot;es.  Just free the current&n;           buffer_heads and exit. */
id|spin_lock
c_func
(paren
op_amp
id|unused_list_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|bhind
suffix:semicolon
op_decrement
id|i
op_ge
l_int|0
suffix:semicolon
)paren
(brace
id|__put_unused_buffer_head
c_func
(paren
id|bh
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|unused_list_lock
)paren
suffix:semicolon
r_goto
id|finished
suffix:semicolon
)brace
multiline_comment|/*&n; * Start I/O on a page.&n; * This function expects the page to be locked and may return&n; * before I/O is complete. You then have to check page-&gt;locked,&n; * page-&gt;uptodate, and maybe wait on page-&gt;wait.&n; *&n; * brw_page() is SMP-safe, although it&squot;s being called with the&n; * kernel lock held - but the code is ready.&n; *&n; * FIXME: we need a swapper_inode-&gt;get_block function to remove&n; *        some of the bmap kludges and interface ugliness here.&n; */
DECL|function|brw_page
r_int
id|brw_page
c_func
(paren
r_int
id|rw
comma
r_struct
id|page
op_star
id|page
comma
id|kdev_t
id|dev
comma
r_int
id|b
(braket
)braket
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|head
comma
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PageLocked
c_func
(paren
id|page
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;brw_page: page not locked for I/O&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page-&gt;buffers
)paren
id|create_empty_buffers
c_func
(paren
id|page
comma
id|dev
comma
id|size
)paren
suffix:semicolon
id|head
op_assign
id|bh
op_assign
id|page-&gt;buffers
suffix:semicolon
multiline_comment|/* Stage 1: lock all the buffers */
r_do
(brace
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_blocknr
op_assign
op_star
(paren
id|b
op_increment
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_Mapped
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|bh-&gt;b_end_io
op_assign
id|end_buffer_io_async
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
multiline_comment|/* Stage 2: start the IO */
r_do
(brace
id|submit_bh
c_func
(paren
id|rw
comma
id|bh
)paren
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|head
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|block_symlink
r_int
id|block_symlink
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_const
r_char
op_star
id|symname
comma
r_int
id|len
)paren
(brace
r_struct
id|address_space
op_star
id|mapping
op_assign
id|inode-&gt;i_mapping
suffix:semicolon
r_struct
id|page
op_star
id|page
op_assign
id|grab_cache_page
c_func
(paren
id|mapping
comma
l_int|0
)paren
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_char
op_star
id|kaddr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|fail
suffix:semicolon
id|err
op_assign
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|prepare_write
c_func
(paren
l_int|NULL
comma
id|page
comma
l_int|0
comma
id|len
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_goto
id|fail_map
suffix:semicolon
id|kaddr
op_assign
id|page_address
c_func
(paren
id|page
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|kaddr
comma
id|symname
comma
id|len
op_minus
l_int|1
)paren
suffix:semicolon
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|commit_write
c_func
(paren
l_int|NULL
comma
id|page
comma
l_int|0
comma
id|len
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Notice that we are _not_ going to block here - end of page is&n;&t; * unmapped, so this will only try to map the rest of page, see&n;&t; * that it is unmapped (typically even will not look into inode -&n;&t; * -&gt;i_size will be enough for everything) and zero it out.&n;&t; * OTOH it&squot;s obviously correct and should make the page up-to-date.&n;&t; */
id|err
op_assign
id|mapping-&gt;a_ops
op_member_access_from_pointer
id|readpage
c_func
(paren
l_int|NULL
comma
id|page
)paren
suffix:semicolon
id|wait_on_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_goto
id|fail
suffix:semicolon
id|mark_inode_dirty
c_func
(paren
id|inode
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail_map
suffix:colon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|fail
suffix:colon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to increase the number of buffers available: the size argument&n; * is used to determine what kind of buffers we want.&n; */
DECL|function|grow_buffers
r_static
r_int
id|grow_buffers
c_func
(paren
r_int
id|size
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|tmp
suffix:semicolon
r_struct
id|buffer_head
op_star
id|insert_point
suffix:semicolon
r_int
id|isize
suffix:semicolon
r_if
c_cond
(paren
(paren
id|size
op_amp
l_int|511
)paren
op_logical_or
(paren
id|size
OG
id|PAGE_SIZE
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: grow_buffers: size = %d&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|page
op_assign
id|alloc_page
c_func
(paren
id|GFP_BUFFER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_goto
id|out
suffix:semicolon
id|LockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|bh
op_assign
id|create_buffers
c_func
(paren
id|page
comma
id|size
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|no_buffer_head
suffix:semicolon
id|isize
op_assign
id|BUFSIZE_INDEX
c_func
(paren
id|size
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|free_list
(braket
id|isize
)braket
dot
id|lock
)paren
suffix:semicolon
id|insert_point
op_assign
id|free_list
(braket
id|isize
)braket
dot
id|list
suffix:semicolon
id|tmp
op_assign
id|bh
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|insert_point
)paren
(brace
id|tmp-&gt;b_next_free
op_assign
id|insert_point-&gt;b_next_free
suffix:semicolon
id|tmp-&gt;b_prev_free
op_assign
id|insert_point
suffix:semicolon
id|insert_point-&gt;b_next_free-&gt;b_prev_free
op_assign
id|tmp
suffix:semicolon
id|insert_point-&gt;b_next_free
op_assign
id|tmp
suffix:semicolon
)brace
r_else
(brace
id|tmp-&gt;b_prev_free
op_assign
id|tmp
suffix:semicolon
id|tmp-&gt;b_next_free
op_assign
id|tmp
suffix:semicolon
)brace
id|insert_point
op_assign
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;b_this_page
)paren
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
id|tmp-&gt;b_this_page
op_assign
id|bh
suffix:semicolon
id|free_list
(braket
id|isize
)braket
dot
id|list
op_assign
id|bh
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|free_list
(braket
id|isize
)braket
dot
id|lock
)paren
suffix:semicolon
id|page-&gt;buffers
op_assign
id|bh
suffix:semicolon
id|page-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|PG_referenced
)paren
suffix:semicolon
id|lru_cache_add
c_func
(paren
id|page
)paren
suffix:semicolon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|buffermem_pages
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|no_buffer_head
suffix:colon
id|UnlockPage
c_func
(paren
id|page
)paren
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|out
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Sync all the buffers on one page..&n; *&n; * If we have old buffers that are locked, we&squot;ll&n; * wait on them, but we won&squot;t wait on the new ones&n; * we&squot;re writing out now.&n; *&n; * This all is required so that we can free up memory&n; * later.&n; *&n; * Wait:&n; *&t;0 - no wait (this does not get called - see try_to_free_buffers below)&n; *&t;1 - start IO for dirty buffers&n; *&t;2 - wait for completion of locked buffers&n; */
DECL|function|sync_page_buffers
r_static
r_void
id|sync_page_buffers
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|wait
)paren
(brace
r_struct
id|buffer_head
op_star
id|tmp
op_assign
id|bh
suffix:semicolon
r_do
(brace
r_struct
id|buffer_head
op_star
id|p
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|p
)paren
)paren
(brace
r_if
c_cond
(paren
id|wait
OG
l_int|1
)paren
id|__wait_on_buffer
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|p
)paren
)paren
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|p
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Can the buffer be thrown out?&n; */
DECL|macro|BUFFER_BUSY_BITS
mdefine_line|#define BUFFER_BUSY_BITS&t;((1&lt;&lt;BH_Dirty) | (1&lt;&lt;BH_Lock) | (1&lt;&lt;BH_Protected))
DECL|macro|buffer_busy
mdefine_line|#define buffer_busy(bh)&t;&t;(atomic_read(&amp;(bh)-&gt;b_count) | ((bh)-&gt;b_state &amp; BUFFER_BUSY_BITS))
multiline_comment|/*&n; * try_to_free_buffers() checks if all the buffers on this particular page&n; * are unused, and free&squot;s the page if so.&n; *&n; * Wake up bdflush() if this fails - if we&squot;re running low on memory due&n; * to dirty buffers, we need to flush them out as quickly as possible.&n; *&n; * NOTE: There are quite a number of ways that threads of control can&n; *       obtain a reference to a buffer head within a page.  So we must&n; *&t; lock out all of these paths to cleanly toss the page.&n; */
DECL|function|try_to_free_buffers
r_int
id|try_to_free_buffers
c_func
(paren
r_struct
id|page
op_star
id|page
comma
r_int
id|wait
)paren
(brace
r_struct
id|buffer_head
op_star
id|tmp
comma
op_star
id|bh
op_assign
id|page-&gt;buffers
suffix:semicolon
r_int
id|index
op_assign
id|BUFSIZE_INDEX
c_func
(paren
id|bh-&gt;b_size
)paren
suffix:semicolon
r_int
id|loop
op_assign
l_int|0
suffix:semicolon
id|cleaned_buffers_try_again
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|hash_table_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|free_list
(braket
id|index
)braket
dot
id|lock
)paren
suffix:semicolon
id|tmp
op_assign
id|bh
suffix:semicolon
r_do
(brace
r_struct
id|buffer_head
op_star
id|p
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
r_if
c_cond
(paren
id|buffer_busy
c_func
(paren
id|p
)paren
)paren
r_goto
id|busy_buffer_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|unused_list_lock
)paren
suffix:semicolon
id|tmp
op_assign
id|bh
suffix:semicolon
r_do
(brace
r_struct
id|buffer_head
op_star
id|p
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
multiline_comment|/* The buffer can be either on the regular&n;&t;&t; * queues or on the free list..&n;&t;&t; */
r_if
c_cond
(paren
id|p-&gt;b_dev
op_ne
id|B_FREE
)paren
(brace
id|remove_inode_queue
c_func
(paren
id|p
)paren
suffix:semicolon
id|__remove_from_queues
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_else
id|__remove_from_free_list
c_func
(paren
id|p
comma
id|index
)paren
suffix:semicolon
id|__put_unused_buffer_head
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|unused_list_lock
)paren
suffix:semicolon
multiline_comment|/* Wake up anyone waiting for buffer heads */
id|wake_up
c_func
(paren
op_amp
id|buffer_wait
)paren
suffix:semicolon
multiline_comment|/* And free the page */
id|page-&gt;buffers
op_assign
l_int|NULL
suffix:semicolon
id|page_cache_release
c_func
(paren
id|page
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|free_list
(braket
id|index
)braket
dot
id|lock
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|hash_table_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
id|busy_buffer_page
suffix:colon
multiline_comment|/* Uhhuh, start writeback so that we don&squot;t end up with all dirty pages */
id|spin_unlock
c_func
(paren
op_amp
id|free_list
(braket
id|index
)braket
dot
id|lock
)paren
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|hash_table_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
(brace
id|sync_page_buffers
c_func
(paren
id|bh
comma
id|wait
)paren
suffix:semicolon
multiline_comment|/* We waited synchronously, so we can free the buffers. */
r_if
c_cond
(paren
id|wait
OG
l_int|1
op_logical_and
op_logical_neg
id|loop
)paren
(brace
id|loop
op_assign
l_int|1
suffix:semicolon
r_goto
id|cleaned_buffers_try_again
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ================== Debugging =================== */
DECL|function|show_buffers
r_void
id|show_buffers
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_SMP
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|found
op_assign
l_int|0
comma
id|locked
op_assign
l_int|0
comma
id|dirty
op_assign
l_int|0
comma
id|used
op_assign
l_int|0
comma
id|lastused
op_assign
l_int|0
suffix:semicolon
r_int
r_protected
op_assign
l_int|0
suffix:semicolon
r_int
id|nlist
suffix:semicolon
r_static
r_char
op_star
id|buf_types
(braket
id|NR_LIST
)braket
op_assign
(brace
l_string|&quot;CLEAN&quot;
comma
l_string|&quot;LOCKED&quot;
comma
l_string|&quot;DIRTY&quot;
comma
l_string|&quot;PROTECTED&quot;
comma
)brace
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;Buffer memory:   %6dkB&bslash;n&quot;
comma
id|atomic_read
c_func
(paren
op_amp
id|buffermem_pages
)paren
op_lshift
(paren
id|PAGE_SHIFT
op_minus
l_int|10
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP /* trylock does nothing on UP and so we could deadlock */
r_if
c_cond
(paren
op_logical_neg
id|spin_trylock
c_func
(paren
op_amp
id|lru_list_lock
)paren
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|nlist
op_assign
l_int|0
suffix:semicolon
id|nlist
OL
id|NR_LIST
suffix:semicolon
id|nlist
op_increment
)paren
(brace
id|found
op_assign
id|locked
op_assign
id|dirty
op_assign
id|used
op_assign
id|lastused
op_assign
r_protected
op_assign
l_int|0
suffix:semicolon
id|bh
op_assign
id|lru_list
(braket
id|nlist
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
r_continue
suffix:semicolon
)brace
r_do
(brace
id|found
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
id|locked
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|buffer_protected
c_func
(paren
id|bh
)paren
)paren
r_protected
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
id|dirty
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
)paren
id|used
op_increment
comma
id|lastused
op_assign
id|found
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|lru_list
(braket
id|nlist
)braket
)paren
suffix:semicolon
(brace
r_int
id|tmp
op_assign
id|nr_buffers_type
(braket
id|nlist
)braket
suffix:semicolon
r_if
c_cond
(paren
id|found
op_ne
id|tmp
)paren
id|printk
c_func
(paren
l_string|&quot;%9s: BUG -&gt; found %d, reported %d&bslash;n&quot;
comma
id|buf_types
(braket
id|nlist
)braket
comma
id|found
comma
id|tmp
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%9s: %d buffers, %lu kbyte, %d used (last=%d), &quot;
l_string|&quot;%d locked, %d protected, %d dirty&bslash;n&quot;
comma
id|buf_types
(braket
id|nlist
)braket
comma
id|found
comma
id|size_buffers_type
(braket
id|nlist
)braket
op_rshift
l_int|10
comma
id|used
comma
id|lastused
comma
id|locked
comma
r_protected
comma
id|dirty
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* ===================== Init ======================= */
multiline_comment|/*&n; * allocate the hash table and init the free list&n; * Use gfp() for the hash table to decrease TLB misses, use&n; * SLAB cache for buffer heads.&n; */
DECL|function|buffer_init
r_void
id|__init
id|buffer_init
c_func
(paren
r_int
r_int
id|mempages
)paren
(brace
r_int
id|order
comma
id|i
suffix:semicolon
r_int
r_int
id|nr_hash
suffix:semicolon
multiline_comment|/* The buffer cache hash table is less important these days,&n;&t; * trim it a bit.&n;&t; */
id|mempages
op_rshift_assign
l_int|14
suffix:semicolon
id|mempages
op_mul_assign
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
suffix:semicolon
r_for
c_loop
(paren
id|order
op_assign
l_int|0
suffix:semicolon
(paren
l_int|1
op_lshift
id|order
)paren
OL
id|mempages
suffix:semicolon
id|order
op_increment
)paren
suffix:semicolon
multiline_comment|/* try to allocate something until we get it or we&squot;re asking&n;&t;   for something that is really too small */
r_do
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|nr_hash
op_assign
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
op_div
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
suffix:semicolon
id|bh_hash_mask
op_assign
(paren
id|nr_hash
op_minus
l_int|1
)paren
suffix:semicolon
id|tmp
op_assign
id|nr_hash
suffix:semicolon
id|bh_hash_shift
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tmp
op_rshift_assign
l_int|1UL
)paren
op_ne
l_int|0UL
)paren
(brace
id|bh_hash_shift
op_increment
suffix:semicolon
)brace
id|hash_table
op_assign
(paren
r_struct
id|buffer_head
op_star
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_ATOMIC
comma
id|order
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|hash_table
op_eq
l_int|NULL
op_logical_and
op_decrement
id|order
OG
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Buffer-cache hash table entries: %d (order: %d, %ld bytes)&bslash;n&quot;
comma
id|nr_hash
comma
id|order
comma
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hash_table
)paren
id|panic
c_func
(paren
l_string|&quot;Failed to allocate buffer hash table&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Setup hash chains. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_hash
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hash_table
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Setup free lists. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_SIZES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|free_list
(braket
id|i
)braket
dot
id|list
op_assign
l_int|NULL
suffix:semicolon
id|free_list
(braket
id|i
)braket
dot
id|lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
)brace
multiline_comment|/* Setup lru lists. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_LIST
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lru_list
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* ====================== bdflush support =================== */
multiline_comment|/* This is a simple kernel daemon, whose job it is to provide a dynamic&n; * response to dirty buffers.  Once this process is activated, we write back&n; * a limited number of buffers to the disks and then go back to sleep again.&n; */
multiline_comment|/* This is the _only_ function that deals with flushing async writes&n;   to disk.&n;   NOTENOTENOTENOTE: we _only_ need to browse the DIRTY lru list&n;   as all dirty buffers lives _only_ in the DIRTY lru list.&n;   As we never browse the LOCKED and CLEAN lru lists they are infact&n;   completly useless. */
DECL|function|flush_dirty_buffers
r_static
r_int
id|flush_dirty_buffers
c_func
(paren
r_int
id|check_flushtime
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|next
suffix:semicolon
r_int
id|flushed
op_assign
l_int|0
comma
id|i
suffix:semicolon
id|restart
suffix:colon
id|spin_lock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|bh
op_assign
id|lru_list
(braket
id|BUF_DIRTY
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|out_unlock
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nr_buffers_type
(braket
id|BUF_DIRTY
)braket
suffix:semicolon
id|i
op_decrement
OG
l_int|0
suffix:semicolon
id|bh
op_assign
id|next
)paren
(brace
id|next
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
(brace
id|__refile_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|check_flushtime
)paren
(brace
multiline_comment|/* The dirty lru list is chronologically ordered so&n;&t;&t;&t;   if the current bh is not yet timed out,&n;&t;&t;&t;   then also all the following bhs&n;&t;&t;&t;   will be too young. */
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|bh-&gt;b_flushtime
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_increment
id|flushed
OG
id|bdf_prm.b_un.ndirty
)paren
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/* OK, now we are committed to write it out. */
id|atomic_inc
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|bh-&gt;b_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;need_resched
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|restart
suffix:semicolon
)brace
id|out_unlock
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|lru_list_lock
)paren
suffix:semicolon
r_return
id|flushed
suffix:semicolon
)brace
DECL|variable|bdflush_tsk
r_struct
id|task_struct
op_star
id|bdflush_tsk
op_assign
l_int|0
suffix:semicolon
DECL|function|wakeup_bdflush
r_void
id|wakeup_bdflush
c_func
(paren
r_int
id|block
)paren
(brace
r_if
c_cond
(paren
id|current
op_ne
id|bdflush_tsk
)paren
(brace
id|wake_up_process
c_func
(paren
id|bdflush_tsk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block
)paren
id|flush_dirty_buffers
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Here we attempt to write back old buffers.  We also try to flush inodes &n; * and supers as well, since this function is essentially &quot;update&quot;, and &n; * otherwise there would be no way of ensuring that these quantities ever &n; * get written back.  Ideally, we would have a timestamp on the inodes&n; * and superblocks so that we could write back only the old ones as well&n; */
DECL|function|sync_old_buffers
r_static
r_int
id|sync_old_buffers
c_func
(paren
r_void
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|sync_supers
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|sync_inodes
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|flush_dirty_buffers
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* must really sync all the active I/O request to disk here */
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|block_sync_page
r_int
id|block_sync_page
c_func
(paren
r_struct
id|page
op_star
id|page
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is the interface to bdflush.  As we get more sophisticated, we can&n; * pass tuning parameters to this &quot;process&quot;, to adjust how it behaves. &n; * We would want to verify each parameter, however, to make sure that it &n; * is reasonable. */
DECL|function|sys_bdflush
id|asmlinkage
r_int
id|sys_bdflush
c_func
(paren
r_int
id|func
comma
r_int
id|data
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|func
op_eq
l_int|1
)paren
(brace
multiline_comment|/* do_exit directly and let kupdate to do its work alone. */
id|do_exit
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#if 0 /* left here as it&squot;s the only example of lazy-mm-stuff used from&n;&t; a syscall that doesn&squot;t care about the current mm context. */
r_int
id|error
suffix:semicolon
r_struct
id|mm_struct
op_star
id|user_mm
suffix:semicolon
multiline_comment|/*&n;&t;&t; * bdflush will spend all of it&squot;s time in kernel-space,&n;&t;&t; * without touching user-space, so we can switch it into&n;&t;&t; * &squot;lazy TLB mode&squot; to reduce the cost of context-switches&n;&t;&t; * to and from bdflush.&n;&t;&t; */
id|user_mm
op_assign
id|start_lazy_tlb
c_func
(paren
)paren
suffix:semicolon
id|error
op_assign
id|sync_old_buffers
c_func
(paren
)paren
suffix:semicolon
id|end_lazy_tlb
c_func
(paren
id|user_mm
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Basically func 1 means read param 1, 2 means write param 1, etc */
r_if
c_cond
(paren
id|func
op_ge
l_int|2
)paren
(brace
r_int
id|i
op_assign
(paren
id|func
op_minus
l_int|2
)paren
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
l_int|0
op_logical_and
id|i
OL
id|N_PARAM
)paren
(brace
r_if
c_cond
(paren
(paren
id|func
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
r_return
id|put_user
c_func
(paren
id|bdf_prm.data
(braket
id|i
)braket
comma
(paren
r_int
op_star
)paren
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_ge
id|bdflush_min
(braket
id|i
)braket
op_logical_and
id|data
op_le
id|bdflush_max
(braket
id|i
)braket
)paren
(brace
id|bdf_prm.data
(braket
id|i
)braket
op_assign
id|data
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Having func 0 used to launch the actual bdflush and then never&n;&t; * return (unless explicitly killed). We return zero here to &n;&t; * remain semi-compatible with present update(8) programs.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the actual bdflush daemon itself. It used to be started from&n; * the syscall above, but now we launch it ourselves internally with&n; * kernel_thread(...)  directly after the first thread in init/main.c&n; */
DECL|function|bdflush
r_int
id|bdflush
c_func
(paren
r_void
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_int
id|flushed
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We have a bare-bones task_struct, and really should fill&n;&t; *&t;in a few more things so &quot;top&quot; and /proc/2/{exe,root,cwd}&n;&t; *&t;display semi-sane things. Not real crucial though...  &n;&t; */
id|tsk-&gt;session
op_assign
l_int|1
suffix:semicolon
id|tsk-&gt;pgrp
op_assign
l_int|1
suffix:semicolon
id|strcpy
c_func
(paren
id|tsk-&gt;comm
comma
l_string|&quot;bdflush&quot;
)paren
suffix:semicolon
id|bdflush_tsk
op_assign
id|tsk
suffix:semicolon
multiline_comment|/* avoid getting signals */
id|spin_lock_irq
c_func
(paren
op_amp
id|tsk-&gt;sigmask_lock
)paren
suffix:semicolon
id|flush_signals
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|sigfillset
c_func
(paren
op_amp
id|tsk-&gt;blocked
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|tsk-&gt;sigmask_lock
)paren
suffix:semicolon
id|up
c_func
(paren
(paren
r_struct
id|semaphore
op_star
)paren
id|sem
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|CHECK_EMERGENCY_SYNC
id|flushed
op_assign
id|flush_dirty_buffers
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|free_shortage
c_func
(paren
)paren
)paren
id|flushed
op_add_assign
id|page_launder
c_func
(paren
id|GFP_KERNEL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If there are still a lot of dirty buffers around,&n;&t;&t; * skip the sleep and flush some more. Otherwise, we&n;&t;&t; * go to sleep waiting a wakeup.&n;&t;&t; */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flushed
op_logical_or
id|balance_dirty_state
c_func
(paren
id|NODEV
)paren
OL
l_int|0
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Remember to mark us as running otherwise&n;&t;&t;   the next schedule will block. */
id|__set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is the kernel update daemon. It was used to live in userspace&n; * but since it&squot;s need to run safely we want it unkillable by mistake.&n; * You don&squot;t need to change your userspace configuration since&n; * the userspace `update` will do_exit(0) at the first sys_bdflush().&n; */
DECL|function|kupdate
r_int
id|kupdate
c_func
(paren
r_void
op_star
id|sem
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_int
id|interval
suffix:semicolon
id|tsk-&gt;session
op_assign
l_int|1
suffix:semicolon
id|tsk-&gt;pgrp
op_assign
l_int|1
suffix:semicolon
id|strcpy
c_func
(paren
id|tsk-&gt;comm
comma
l_string|&quot;kupdate&quot;
)paren
suffix:semicolon
multiline_comment|/* sigstop and sigcont will stop and wakeup kupdate */
id|spin_lock_irq
c_func
(paren
op_amp
id|tsk-&gt;sigmask_lock
)paren
suffix:semicolon
id|sigfillset
c_func
(paren
op_amp
id|tsk-&gt;blocked
)paren
suffix:semicolon
id|siginitsetinv
c_func
(paren
op_amp
id|current-&gt;blocked
comma
id|sigmask
c_func
(paren
id|SIGCONT
)paren
op_or
id|sigmask
c_func
(paren
id|SIGSTOP
)paren
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|tsk-&gt;sigmask_lock
)paren
suffix:semicolon
id|up
c_func
(paren
(paren
r_struct
id|semaphore
op_star
)paren
id|sem
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* update interval */
id|interval
op_assign
id|bdf_prm.b_un.interval
suffix:semicolon
r_if
c_cond
(paren
id|interval
)paren
(brace
id|tsk-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|interval
)paren
suffix:semicolon
)brace
r_else
(brace
id|stop_kupdate
suffix:colon
id|tsk-&gt;state
op_assign
id|TASK_STOPPED
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for SIGCONT */
)brace
multiline_comment|/* check for sigstop */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|tsk
)paren
)paren
(brace
r_int
id|stopped
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|tsk-&gt;sigmask_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sigismember
c_func
(paren
op_amp
id|tsk-&gt;pending.signal
comma
id|SIGSTOP
)paren
)paren
(brace
id|sigdelset
c_func
(paren
op_amp
id|tsk-&gt;pending.signal
comma
id|SIGSTOP
)paren
suffix:semicolon
id|stopped
op_assign
l_int|1
suffix:semicolon
)brace
id|recalc_sigpending
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|tsk-&gt;sigmask_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stopped
)paren
r_goto
id|stop_kupdate
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;kupdate() activated...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sync_old_buffers
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|bdflush_init
r_static
r_int
id|__init
id|bdflush_init
c_func
(paren
r_void
)paren
(brace
id|DECLARE_MUTEX_LOCKED
c_func
(paren
id|sem
)paren
suffix:semicolon
id|kernel_thread
c_func
(paren
id|bdflush
comma
op_amp
id|sem
comma
id|CLONE_FS
op_or
id|CLONE_FILES
op_or
id|CLONE_SIGNAL
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
id|kernel_thread
c_func
(paren
id|kupdate
comma
op_amp
id|sem
comma
id|CLONE_FS
op_or
id|CLONE_FILES
op_or
id|CLONE_SIGNAL
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|module_init
c_func
(paren
id|bdflush_init
)paren
eof
