multiline_comment|/*&n; *  &squot;buffer.c&squot; implements the buffer-cache functions. Race-conditions have&n; * been avoided by NEVER letting a interrupt change a buffer (except for the&n; * data, of course), but instead letting the caller do it. NOTE! As interrupts&n; * can wake up a caller, some cli-sti sequences are needed to check for&n; * sleep-on-calls. These should be extremely quick, though (I hope).&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#if (BUFFER_END &amp; 0xfff)
macro_line|#error &quot;Bad BUFFER_END value&quot;
macro_line|#endif
macro_line|#if (BUFFER_END &gt; 0xA0000 &amp;&amp; BUFFER_END &lt;= 0x100000)
macro_line|#error &quot;Bad BUFFER_END value&quot;
macro_line|#endif
r_extern
r_int
id|end
suffix:semicolon
DECL|variable|start_buffer
r_struct
id|buffer_head
op_star
id|start_buffer
op_assign
(paren
r_struct
id|buffer_head
op_star
)paren
op_amp
id|end
suffix:semicolon
DECL|variable|hash_table
r_struct
id|buffer_head
op_star
id|hash_table
(braket
id|NR_HASH
)braket
suffix:semicolon
DECL|variable|free_list
r_static
r_struct
id|buffer_head
op_star
id|free_list
suffix:semicolon
DECL|variable|buffer_wait
r_static
r_struct
id|task_struct
op_star
id|buffer_wait
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|NR_BUFFERS
r_int
id|NR_BUFFERS
op_assign
l_int|0
suffix:semicolon
DECL|function|wait_on_buffer
r_static
r_inline
r_void
id|wait_on_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|bh-&gt;b_lock
)paren
id|sleep_on
c_func
(paren
op_amp
id|bh-&gt;b_wait
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|sys_sync
r_int
id|sys_sync
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|sync_inodes
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* write out inodes into buffers */
id|bh
op_assign
id|start_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_BUFFERS
suffix:semicolon
id|i
op_increment
comma
id|bh
op_increment
)paren
(brace
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dirt
)paren
id|ll_rw_block
c_func
(paren
id|WRITE
comma
id|bh
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sync_dev
r_static
r_int
id|sync_dev
c_func
(paren
r_int
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|bh
op_assign
id|start_buffer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_BUFFERS
suffix:semicolon
id|i
op_increment
comma
id|bh
op_increment
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dirt
)paren
id|ll_rw_block
c_func
(paren
id|WRITE
comma
id|bh
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|_hashfn
mdefine_line|#define _hashfn(dev,block) (((unsigned)(dev^block))%NR_HASH)
DECL|macro|hash
mdefine_line|#define hash(dev,block) hash_table[_hashfn(dev,block)]
DECL|function|remove_from_queues
r_static
r_inline
r_void
id|remove_from_queues
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
multiline_comment|/* remove from hash-queue */
r_if
c_cond
(paren
id|bh-&gt;b_next
)paren
id|bh-&gt;b_next-&gt;b_prev
op_assign
id|bh-&gt;b_prev
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_prev
)paren
id|bh-&gt;b_prev-&gt;b_next
op_assign
id|bh-&gt;b_next
suffix:semicolon
r_if
c_cond
(paren
id|hash
c_func
(paren
id|bh-&gt;b_dev
comma
id|bh-&gt;b_blocknr
)paren
op_eq
id|bh
)paren
id|hash
c_func
(paren
id|bh-&gt;b_dev
comma
id|bh-&gt;b_blocknr
)paren
op_assign
id|bh-&gt;b_next
suffix:semicolon
multiline_comment|/* remove from free list */
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh-&gt;b_prev_free
)paren
op_logical_or
op_logical_neg
(paren
id|bh-&gt;b_next_free
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Free block list corrupted&quot;
)paren
suffix:semicolon
id|bh-&gt;b_prev_free-&gt;b_next_free
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
id|bh-&gt;b_next_free-&gt;b_prev_free
op_assign
id|bh-&gt;b_prev_free
suffix:semicolon
r_if
c_cond
(paren
id|free_list
op_eq
id|bh
)paren
id|free_list
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
)brace
DECL|function|insert_into_queues
r_static
r_inline
r_void
id|insert_into_queues
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
multiline_comment|/* put at end of free list */
id|bh-&gt;b_next_free
op_assign
id|free_list
suffix:semicolon
id|bh-&gt;b_prev_free
op_assign
id|free_list-&gt;b_prev_free
suffix:semicolon
id|free_list-&gt;b_prev_free-&gt;b_next_free
op_assign
id|bh
suffix:semicolon
id|free_list-&gt;b_prev_free
op_assign
id|bh
suffix:semicolon
multiline_comment|/* put the buffer in new hash-queue if it has a device */
id|bh-&gt;b_prev
op_assign
l_int|NULL
suffix:semicolon
id|bh-&gt;b_next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh-&gt;b_dev
)paren
r_return
suffix:semicolon
id|bh-&gt;b_next
op_assign
id|hash
c_func
(paren
id|bh-&gt;b_dev
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
id|hash
c_func
(paren
id|bh-&gt;b_dev
comma
id|bh-&gt;b_blocknr
)paren
op_assign
id|bh
suffix:semicolon
id|bh-&gt;b_next-&gt;b_prev
op_assign
id|bh
suffix:semicolon
)brace
DECL|function|find_buffer
r_static
r_struct
id|buffer_head
op_star
id|find_buffer
c_func
(paren
r_int
id|dev
comma
r_int
id|block
)paren
(brace
r_struct
id|buffer_head
op_star
id|tmp
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|hash
c_func
(paren
id|dev
comma
id|block
)paren
suffix:semicolon
id|tmp
op_ne
l_int|NULL
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_next
)paren
r_if
c_cond
(paren
id|tmp-&gt;b_dev
op_eq
id|dev
op_logical_and
id|tmp-&gt;b_blocknr
op_eq
id|block
)paren
r_return
id|tmp
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Why like this, I hear you say... The reason is race-conditions.&n; * As we don&squot;t lock buffers (unless we are readint them, that is),&n; * something might happen to it while we sleep (ie a read-error&n; * will force it bad). This shouldn&squot;t really happen currently, but&n; * the code is ready.&n; */
DECL|function|get_hash_table
r_struct
id|buffer_head
op_star
id|get_hash_table
c_func
(paren
r_int
id|dev
comma
r_int
id|block
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|find_buffer
c_func
(paren
id|dev
comma
id|block
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|bh-&gt;b_count
op_increment
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_ne
id|dev
op_logical_or
id|bh-&gt;b_blocknr
op_ne
id|block
)paren
(brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_return
id|bh
suffix:semicolon
)brace
multiline_comment|/*&n; * Ok, this is getblk, and it isn&squot;t very clear, again to hinder&n; * race-conditions. Most of the code is seldom used, (ie repeating),&n; * so it should be much more efficient than it looks.&n; */
DECL|function|getblk
r_struct
id|buffer_head
op_star
id|getblk
c_func
(paren
r_int
id|dev
comma
r_int
id|block
)paren
(brace
r_struct
id|buffer_head
op_star
id|tmp
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
id|tmp
op_assign
id|get_hash_table
c_func
(paren
id|dev
comma
id|block
)paren
)paren
r_return
id|tmp
suffix:semicolon
id|tmp
op_assign
id|free_list
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|tmp-&gt;b_count
)paren
(brace
id|wait_on_buffer
c_func
(paren
id|tmp
)paren
suffix:semicolon
multiline_comment|/* we still have to wait */
r_if
c_cond
(paren
op_logical_neg
id|tmp-&gt;b_count
)paren
multiline_comment|/* on it, it might be dirty */
r_break
suffix:semicolon
)brace
id|tmp
op_assign
id|tmp-&gt;b_next_free
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|free_list
op_logical_or
(paren
id|tmp
op_assign
l_int|NULL
)paren
)paren
suffix:semicolon
multiline_comment|/* Kids, don&squot;t try THIS at home ^^^^^. Magic */
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sleeping on free buffer ..&quot;
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|buffer_wait
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ok&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|tmp-&gt;b_count
op_increment
suffix:semicolon
id|remove_from_queues
c_func
(paren
id|tmp
)paren
suffix:semicolon
multiline_comment|/*&n; * Now, when we know nobody can get to this node (as it&squot;s removed from the&n; * free list), we write it out. We can sleep here without fear of race-&n; * conditions.&n; */
r_if
c_cond
(paren
id|tmp-&gt;b_dirt
)paren
id|sync_dev
c_func
(paren
id|tmp-&gt;b_dev
)paren
suffix:semicolon
multiline_comment|/* update buffer contents */
id|tmp-&gt;b_dev
op_assign
id|dev
suffix:semicolon
id|tmp-&gt;b_blocknr
op_assign
id|block
suffix:semicolon
id|tmp-&gt;b_dirt
op_assign
l_int|0
suffix:semicolon
id|tmp-&gt;b_uptodate
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* NOTE!! While we possibly slept in sync_dev(), somebody else might have&n; * added &quot;this&quot; block already, so check for that. Thank God for goto&squot;s.&n; */
r_if
c_cond
(paren
id|find_buffer
c_func
(paren
id|dev
comma
id|block
)paren
)paren
(brace
id|tmp-&gt;b_dev
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ok, someone else has beaten us */
id|tmp-&gt;b_blocknr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* to it - free this block and */
id|tmp-&gt;b_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* try again */
id|insert_into_queues
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/* and then insert into correct position */
id|insert_into_queues
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|brelse
r_void
id|brelse
c_func
(paren
r_struct
id|buffer_head
op_star
id|buf
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|buf-&gt;b_count
op_decrement
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Trying to free free buffer&quot;
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|buffer_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * bread() reads a specified block and returns the buffer that contains&n; * it. It returns NULL if the block was unreadable.&n; */
DECL|function|bread
r_struct
id|buffer_head
op_star
id|bread
c_func
(paren
r_int
id|dev
comma
r_int
id|block
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|getblk
c_func
(paren
id|dev
comma
id|block
)paren
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;bread: getblk returned NULL&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_uptodate
)paren
r_return
id|bh
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|READ
comma
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_uptodate
)paren
r_return
id|bh
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|buffer_init
r_void
id|buffer_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|buffer_head
op_star
id|h
op_assign
id|start_buffer
suffix:semicolon
r_void
op_star
id|b
op_assign
(paren
r_void
op_star
)paren
id|BUFFER_END
suffix:semicolon
r_int
id|i
suffix:semicolon
r_while
c_loop
(paren
(paren
id|b
op_sub_assign
id|BLOCK_SIZE
)paren
op_ge
(paren
(paren
r_void
op_star
)paren
(paren
id|h
op_plus
l_int|1
)paren
)paren
)paren
(brace
id|h-&gt;b_dev
op_assign
l_int|0
suffix:semicolon
id|h-&gt;b_dirt
op_assign
l_int|0
suffix:semicolon
id|h-&gt;b_count
op_assign
l_int|0
suffix:semicolon
id|h-&gt;b_lock
op_assign
l_int|0
suffix:semicolon
id|h-&gt;b_uptodate
op_assign
l_int|0
suffix:semicolon
id|h-&gt;b_wait
op_assign
l_int|NULL
suffix:semicolon
id|h-&gt;b_next
op_assign
l_int|NULL
suffix:semicolon
id|h-&gt;b_prev
op_assign
l_int|NULL
suffix:semicolon
id|h-&gt;b_data
op_assign
(paren
r_char
op_star
)paren
id|b
suffix:semicolon
id|h-&gt;b_prev_free
op_assign
id|h
op_minus
l_int|1
suffix:semicolon
id|h-&gt;b_next_free
op_assign
id|h
op_plus
l_int|1
suffix:semicolon
id|h
op_increment
suffix:semicolon
id|NR_BUFFERS
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|b
op_eq
(paren
r_void
op_star
)paren
l_int|0x100000
)paren
id|b
op_assign
(paren
r_void
op_star
)paren
l_int|0xA0000
suffix:semicolon
)brace
id|h
op_decrement
suffix:semicolon
id|free_list
op_assign
id|start_buffer
suffix:semicolon
id|free_list-&gt;b_prev_free
op_assign
id|h
suffix:semicolon
id|h-&gt;b_next_free
op_assign
id|free_list
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_HASH
suffix:semicolon
id|i
op_increment
)paren
id|hash_table
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
eof
