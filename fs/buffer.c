multiline_comment|/*&n; *  linux/fs/buffer.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; *  &squot;buffer.c&squot; implements the buffer-cache functions. Race-conditions have&n; * been avoided by NEVER letting an interrupt change a buffer (except for the&n; * data, of course), but instead letting the caller do it.&n; */
multiline_comment|/*&n; * NOTE! There is one discordant note here: checking floppies for&n; * disk change. This is where it fits best, I think, as it should&n; * invalidate changed floppy-disk-caches.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/io.h&gt;
DECL|macro|NR_SIZES
mdefine_line|#define NR_SIZES 4
DECL|variable|buffersize_index
r_static
r_char
id|buffersize_index
(braket
l_int|9
)braket
op_assign
(brace
op_minus
l_int|1
comma
l_int|0
comma
l_int|1
comma
op_minus
l_int|1
comma
l_int|2
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
l_int|3
)brace
suffix:semicolon
DECL|variable|bufferindex_size
r_static
r_int
r_int
id|bufferindex_size
(braket
id|NR_SIZES
)braket
op_assign
(brace
l_int|512
comma
l_int|1024
comma
l_int|2048
comma
l_int|4096
)brace
suffix:semicolon
DECL|macro|BUFSIZE_INDEX
mdefine_line|#define BUFSIZE_INDEX(X) ((int) buffersize_index[(X)&gt;&gt;9])
r_static
r_int
id|grow_buffers
c_func
(paren
r_int
id|pri
comma
r_int
id|size
)paren
suffix:semicolon
r_static
r_int
id|shrink_specific_buffers
c_func
(paren
r_int
r_int
id|priority
comma
r_int
id|size
)paren
suffix:semicolon
r_static
r_int
id|maybe_shrink_lav_buffers
c_func
(paren
r_int
)paren
suffix:semicolon
DECL|variable|nr_hash
r_static
r_int
id|nr_hash
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Size of hash table */
DECL|variable|hash_table
r_static
r_struct
id|buffer_head
op_star
op_star
id|hash_table
suffix:semicolon
DECL|variable|buffer_pages
r_struct
id|buffer_head
op_star
op_star
id|buffer_pages
suffix:semicolon
DECL|variable|lru_list
r_static
r_struct
id|buffer_head
op_star
id|lru_list
(braket
id|NR_LIST
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|free_list
r_static
r_struct
id|buffer_head
op_star
id|free_list
(braket
id|NR_SIZES
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|unused_list
r_static
r_struct
id|buffer_head
op_star
id|unused_list
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|buffer_wait
r_static
r_struct
id|wait_queue
op_star
id|buffer_wait
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|nr_buffers
r_int
id|nr_buffers
op_assign
l_int|0
suffix:semicolon
DECL|variable|nr_buffers_type
r_int
id|nr_buffers_type
(braket
id|NR_LIST
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|nr_buffers_size
r_int
id|nr_buffers_size
(braket
id|NR_SIZES
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|nr_buffers_st
r_int
id|nr_buffers_st
(braket
id|NR_SIZES
)braket
(braket
id|NR_LIST
)braket
op_assign
(brace
(brace
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
DECL|variable|buffer_usage
r_int
id|buffer_usage
(braket
id|NR_SIZES
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* Usage counts used to determine load average */
DECL|variable|buffers_lav
r_int
id|buffers_lav
(braket
id|NR_SIZES
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* Load average of buffer usage */
DECL|variable|nr_free
r_int
id|nr_free
(braket
id|NR_SIZES
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|buffermem
r_int
id|buffermem
op_assign
l_int|0
suffix:semicolon
DECL|variable|nr_buffer_heads
r_int
id|nr_buffer_heads
op_assign
l_int|0
suffix:semicolon
DECL|variable|min_free_pages
r_static
r_int
id|min_free_pages
op_assign
l_int|20
suffix:semicolon
multiline_comment|/* nr free pages needed before buffer grows */
r_extern
r_int
op_star
id|blksize_size
(braket
)braket
suffix:semicolon
multiline_comment|/* Here is the parameter block for the bdflush process. */
r_static
r_void
id|wakeup_bdflush
c_func
(paren
r_int
)paren
suffix:semicolon
DECL|macro|N_PARAM
mdefine_line|#define N_PARAM 9
DECL|macro|LAV
mdefine_line|#define LAV
DECL|union|bdflush_param
r_static
r_union
id|bdflush_param
(brace
r_struct
(brace
DECL|member|nfract
r_int
id|nfract
suffix:semicolon
multiline_comment|/* Percentage of buffer cache dirty to &n;&t;&t;&t;&t;activate bdflush */
DECL|member|ndirty
r_int
id|ndirty
suffix:semicolon
multiline_comment|/* Maximum number of dirty blocks to write out per&n;&t;&t;&t;&t;wake-cycle */
DECL|member|nrefill
r_int
id|nrefill
suffix:semicolon
multiline_comment|/* Number of clean buffers to try and obtain&n;&t;&t;&t;&t;each time we call refill */
DECL|member|nref_dirt
r_int
id|nref_dirt
suffix:semicolon
multiline_comment|/* Dirty buffer threshold for activating bdflush&n;&t;&t;&t;&t;  when trying to refill buffers. */
DECL|member|clu_nfract
r_int
id|clu_nfract
suffix:semicolon
multiline_comment|/* Percentage of buffer cache to scan to &n;&t;&t;&t;&t;    search for free clusters */
DECL|member|age_buffer
r_int
id|age_buffer
suffix:semicolon
multiline_comment|/* Time for normal buffer to age before &n;&t;&t;&t;&t;    we flush it */
DECL|member|age_super
r_int
id|age_super
suffix:semicolon
multiline_comment|/* Time for superblock to age before we &n;&t;&t;&t;&t;   flush it */
DECL|member|lav_const
r_int
id|lav_const
suffix:semicolon
multiline_comment|/* Constant used for load average (time&n;&t;&t;&t;&t;   constant */
DECL|member|lav_ratio
r_int
id|lav_ratio
suffix:semicolon
multiline_comment|/* Used to determine how low a lav for a&n;&t;&t;&t;&t;   particular size can go before we start to&n;&t;&t;&t;&t;   trim back the buffers */
DECL|member|b_un
)brace
id|b_un
suffix:semicolon
DECL|member|data
r_int
r_int
id|data
(braket
id|N_PARAM
)braket
suffix:semicolon
DECL|variable|bdf_prm
)brace
id|bdf_prm
op_assign
(brace
(brace
l_int|25
comma
l_int|500
comma
l_int|64
comma
l_int|256
comma
l_int|15
comma
l_int|3000
comma
l_int|500
comma
l_int|1884
comma
l_int|2
)brace
)brace
suffix:semicolon
multiline_comment|/* The lav constant is set for 1 minute, as long as the update process runs&n;   every 5 seconds.  If you change the frequency of update, the time&n;   constant will also change. */
multiline_comment|/* These are the min and max parameter values that we will allow to be assigned */
DECL|variable|bdflush_min
r_static
r_int
id|bdflush_min
(braket
id|N_PARAM
)braket
op_assign
(brace
l_int|0
comma
l_int|10
comma
l_int|5
comma
l_int|25
comma
l_int|0
comma
l_int|100
comma
l_int|100
comma
l_int|1
comma
l_int|1
)brace
suffix:semicolon
DECL|variable|bdflush_max
r_static
r_int
id|bdflush_max
(braket
id|N_PARAM
)braket
op_assign
(brace
l_int|100
comma
l_int|5000
comma
l_int|2000
comma
l_int|2000
comma
l_int|100
comma
l_int|60000
comma
l_int|60000
comma
l_int|2047
comma
l_int|5
)brace
suffix:semicolon
multiline_comment|/*&n; * Rewrote the wait-routines to use the &quot;new&quot; wait-queue functionality,&n; * and getting rid of the cli-sti pairs. The wait-queue routines still&n; * need cli-sti, but now it&squot;s just a couple of 386 instructions or so.&n; *&n; * Note that the real wait_on_buffer() is an inline function that checks&n; * if &squot;b_wait&squot; is set before calling this, so that the queues aren&squot;t set&n; * up unnecessarily.&n; */
DECL|function|__wait_on_buffer
r_void
id|__wait_on_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
id|bh-&gt;b_count
op_increment
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|bh-&gt;b_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|repeat
suffix:colon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_lock
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|bh-&gt;b_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|bh-&gt;b_count
op_decrement
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
multiline_comment|/* Call sync_buffers with wait!=0 to ensure that the call does not&n;   return until all buffer writes have completed.  Sync() may return&n;   before the writes have finished; fsync() may not. */
multiline_comment|/* Godamity-damn.  Some buffers (bitmaps for filesystems)&n;   spontaneously dirty themselves without ever brelse being called.&n;   We will ultimately want to put these in a separate list, but for&n;   now we search all of the lists for dirty buffers */
DECL|function|sync_buffers
r_static
r_int
id|sync_buffers
c_func
(paren
id|dev_t
id|dev
comma
r_int
id|wait
)paren
(brace
r_int
id|i
comma
id|retry
comma
id|pass
op_assign
l_int|0
comma
id|err
op_assign
l_int|0
suffix:semicolon
r_int
id|nlist
comma
id|ncount
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|next
suffix:semicolon
multiline_comment|/* One pass for no-wait, three for wait:&n;&t;   0) write out all dirty, unlocked buffers;&n;&t;   1) write out all dirty buffers, waiting if locked;&n;&t;   2) wait for completion by waiting for all buffers to unlock. */
id|repeat
suffix:colon
id|retry
op_assign
l_int|0
suffix:semicolon
id|repeat2
suffix:colon
id|ncount
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We search all lists as a failsafe mechanism, not because we expect&n;&t;   there to be dirty buffers on any of the other lists. */
r_for
c_loop
(paren
id|nlist
op_assign
l_int|0
suffix:semicolon
id|nlist
OL
id|NR_LIST
suffix:semicolon
id|nlist
op_increment
)paren
(brace
id|repeat1
suffix:colon
id|bh
op_assign
id|lru_list
(braket
id|nlist
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|nr_buffers_type
(braket
id|nlist
)braket
op_star
l_int|2
suffix:semicolon
id|i
op_decrement
OG
l_int|0
suffix:semicolon
id|bh
op_assign
id|next
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_list
op_ne
id|nlist
)paren
(brace
r_goto
id|repeat1
suffix:semicolon
)brace
id|next
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lru_list
(braket
id|nlist
)braket
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev
op_logical_and
id|bh-&gt;b_dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_lock
)paren
(brace
multiline_comment|/* Buffer is locked; skip it unless wait is&n;&t;&t;&t;&t;     requested AND pass &gt; 0. */
r_if
c_cond
(paren
op_logical_neg
id|wait
op_logical_or
op_logical_neg
id|pass
)paren
(brace
id|retry
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|wait_on_buffer
(paren
id|bh
)paren
suffix:semicolon
r_goto
id|repeat2
suffix:semicolon
)brace
multiline_comment|/* If an unlocked buffer is not uptodate, there has&n;&t;&t;&t;     been an IO error. Skip it. */
r_if
c_cond
(paren
id|wait
op_logical_and
id|bh-&gt;b_req
op_logical_and
op_logical_neg
id|bh-&gt;b_lock
op_logical_and
op_logical_neg
id|bh-&gt;b_dirt
op_logical_and
op_logical_neg
id|bh-&gt;b_uptodate
)paren
(brace
id|err
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Weird - unlocked, clean and not uptodate buffer on list %d %x %lu&bslash;n&quot;
comma
id|nlist
comma
id|bh-&gt;b_dev
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t write clean buffers.  Don&squot;t write ANY buffers&n;&t;&t;&t;    on the third pass. */
r_if
c_cond
(paren
op_logical_neg
id|bh-&gt;b_dirt
op_logical_or
id|pass
op_ge
l_int|2
)paren
r_continue
suffix:semicolon
multiline_comment|/* don&squot;t bother about locked buffers */
r_if
c_cond
(paren
id|bh-&gt;b_lock
)paren
r_continue
suffix:semicolon
id|bh-&gt;b_count
op_increment
suffix:semicolon
id|bh-&gt;b_flushtime
op_assign
l_int|0
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nlist
op_ne
id|BUF_DIRTY
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;[%d %x %ld] &quot;
comma
id|nlist
comma
id|bh-&gt;b_dev
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
id|ncount
op_increment
suffix:semicolon
)brace
suffix:semicolon
id|bh-&gt;b_count
op_decrement
suffix:semicolon
id|retry
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ncount
)paren
id|printk
c_func
(paren
l_string|&quot;sys_sync: %d dirty buffers not on dirty list&bslash;n&quot;
comma
id|ncount
)paren
suffix:semicolon
multiline_comment|/* If we are waiting for the sync to succeed, and if any dirty&n;&t;   blocks were written, then repeat; on the second pass, only&n;&t;   wait for buffers being written (do not pass to write any&n;&t;   more buffers on the second pass). */
r_if
c_cond
(paren
id|wait
op_logical_and
id|retry
op_logical_and
op_increment
id|pass
op_le
l_int|2
)paren
r_goto
id|repeat
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sync_dev
r_void
id|sync_dev
c_func
(paren
id|dev_t
id|dev
)paren
(brace
id|sync_buffers
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|sync_supers
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sync_inodes
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sync_buffers
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|fsync_dev
r_int
id|fsync_dev
c_func
(paren
id|dev_t
id|dev
)paren
(brace
id|sync_buffers
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|sync_supers
c_func
(paren
id|dev
)paren
suffix:semicolon
id|sync_inodes
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|sync_buffers
c_func
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|sys_sync
id|asmlinkage
r_int
id|sys_sync
c_func
(paren
r_void
)paren
(brace
id|sync_dev
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|file_fsync
r_int
id|file_fsync
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_return
id|fsync_dev
c_func
(paren
id|inode-&gt;i_dev
)paren
suffix:semicolon
)brace
DECL|function|sys_fsync
id|asmlinkage
r_int
id|sys_fsync
c_func
(paren
r_int
r_int
id|fd
)paren
(brace
r_struct
id|file
op_star
id|file
suffix:semicolon
r_struct
id|inode
op_star
id|inode
suffix:semicolon
r_if
c_cond
(paren
id|fd
op_ge
id|NR_OPEN
op_logical_or
op_logical_neg
(paren
id|file
op_assign
id|current-&gt;files-&gt;fd
(braket
id|fd
)braket
)paren
op_logical_or
op_logical_neg
(paren
id|inode
op_assign
id|file-&gt;f_inode
)paren
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file-&gt;f_op
op_logical_or
op_logical_neg
id|file-&gt;f_op-&gt;fsync
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_op
op_member_access_from_pointer
id|fsync
c_func
(paren
id|inode
comma
id|file
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|invalidate_buffers
r_void
id|invalidate_buffers
c_func
(paren
id|dev_t
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|nlist
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_for
c_loop
(paren
id|nlist
op_assign
l_int|0
suffix:semicolon
id|nlist
OL
id|NR_LIST
suffix:semicolon
id|nlist
op_increment
)paren
(brace
id|bh
op_assign
id|lru_list
(braket
id|nlist
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nr_buffers_type
(braket
id|nlist
)braket
op_star
l_int|2
suffix:semicolon
op_decrement
id|i
OG
l_int|0
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_next_free
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_eq
id|dev
)paren
id|bh-&gt;b_flushtime
op_assign
id|bh-&gt;b_uptodate
op_assign
id|bh-&gt;b_dirt
op_assign
id|bh-&gt;b_req
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
DECL|macro|_hashfn
mdefine_line|#define _hashfn(dev,block) (((unsigned)(dev^block))%nr_hash)
DECL|macro|hash
mdefine_line|#define hash(dev,block) hash_table[_hashfn(dev,block)]
DECL|function|remove_from_hash_queue
r_static
r_inline
r_void
id|remove_from_hash_queue
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_next
)paren
id|bh-&gt;b_next-&gt;b_prev
op_assign
id|bh-&gt;b_prev
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_prev
)paren
id|bh-&gt;b_prev-&gt;b_next
op_assign
id|bh-&gt;b_next
suffix:semicolon
r_if
c_cond
(paren
id|hash
c_func
(paren
id|bh-&gt;b_dev
comma
id|bh-&gt;b_blocknr
)paren
op_eq
id|bh
)paren
id|hash
c_func
(paren
id|bh-&gt;b_dev
comma
id|bh-&gt;b_blocknr
)paren
op_assign
id|bh-&gt;b_next
suffix:semicolon
id|bh-&gt;b_next
op_assign
id|bh-&gt;b_prev
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|remove_from_lru_list
r_static
r_inline
r_void
id|remove_from_lru_list
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh-&gt;b_prev_free
)paren
op_logical_or
op_logical_neg
(paren
id|bh-&gt;b_next_free
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;VFS: LRU block list corrupted&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_eq
l_int|0xffff
)paren
id|panic
c_func
(paren
l_string|&quot;LRU list corrupted&quot;
)paren
suffix:semicolon
id|bh-&gt;b_prev_free-&gt;b_next_free
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
id|bh-&gt;b_next_free-&gt;b_prev_free
op_assign
id|bh-&gt;b_prev_free
suffix:semicolon
r_if
c_cond
(paren
id|lru_list
(braket
id|bh-&gt;b_list
)braket
op_eq
id|bh
)paren
id|lru_list
(braket
id|bh-&gt;b_list
)braket
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_if
c_cond
(paren
id|lru_list
(braket
id|bh-&gt;b_list
)braket
op_eq
id|bh
)paren
(brace
id|lru_list
(braket
id|bh-&gt;b_list
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|bh-&gt;b_next_free
op_assign
id|bh-&gt;b_prev_free
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|remove_from_free_list
r_static
r_inline
r_void
id|remove_from_free_list
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_int
id|isize
op_assign
id|BUFSIZE_INDEX
c_func
(paren
id|bh-&gt;b_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh-&gt;b_prev_free
)paren
op_logical_or
op_logical_neg
(paren
id|bh-&gt;b_next_free
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;VFS: Free block list corrupted&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_ne
l_int|0xffff
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Free list corrupted&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|free_list
(braket
id|isize
)braket
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Free list empty&quot;
)paren
suffix:semicolon
)brace
id|nr_free
(braket
id|isize
)braket
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_next_free
op_eq
id|bh
)paren
(brace
id|free_list
(braket
id|isize
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|bh-&gt;b_prev_free-&gt;b_next_free
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
id|bh-&gt;b_next_free-&gt;b_prev_free
op_assign
id|bh-&gt;b_prev_free
suffix:semicolon
r_if
c_cond
(paren
id|free_list
(braket
id|isize
)braket
op_eq
id|bh
)paren
id|free_list
(braket
id|isize
)braket
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
)brace
suffix:semicolon
id|bh-&gt;b_next_free
op_assign
id|bh-&gt;b_prev_free
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|remove_from_queues
r_static
r_inline
r_void
id|remove_from_queues
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_eq
l_int|0xffff
)paren
(brace
id|remove_from_free_list
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* Free list entries should not be&n;&t;&t;&t;&t;&t;      in the hash queue */
r_return
suffix:semicolon
)brace
suffix:semicolon
id|nr_buffers_type
(braket
id|bh-&gt;b_list
)braket
op_decrement
suffix:semicolon
id|nr_buffers_st
(braket
id|BUFSIZE_INDEX
c_func
(paren
id|bh-&gt;b_size
)paren
)braket
(braket
id|bh-&gt;b_list
)braket
op_decrement
suffix:semicolon
id|remove_from_hash_queue
c_func
(paren
id|bh
)paren
suffix:semicolon
id|remove_from_lru_list
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
DECL|function|put_last_lru
r_static
r_inline
r_void
id|put_last_lru
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|bh
op_eq
id|lru_list
(braket
id|bh-&gt;b_list
)braket
)paren
(brace
id|lru_list
(braket
id|bh-&gt;b_list
)braket
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_eq
l_int|0xffff
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Wrong block for lru list&quot;
)paren
suffix:semicolon
)brace
id|remove_from_lru_list
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* add to back of free list */
r_if
c_cond
(paren
op_logical_neg
id|lru_list
(braket
id|bh-&gt;b_list
)braket
)paren
(brace
id|lru_list
(braket
id|bh-&gt;b_list
)braket
op_assign
id|bh
suffix:semicolon
id|lru_list
(braket
id|bh-&gt;b_list
)braket
op_member_access_from_pointer
id|b_prev_free
op_assign
id|bh
suffix:semicolon
)brace
suffix:semicolon
id|bh-&gt;b_next_free
op_assign
id|lru_list
(braket
id|bh-&gt;b_list
)braket
suffix:semicolon
id|bh-&gt;b_prev_free
op_assign
id|lru_list
(braket
id|bh-&gt;b_list
)braket
op_member_access_from_pointer
id|b_prev_free
suffix:semicolon
id|lru_list
(braket
id|bh-&gt;b_list
)braket
op_member_access_from_pointer
id|b_prev_free-&gt;b_next_free
op_assign
id|bh
suffix:semicolon
id|lru_list
(braket
id|bh-&gt;b_list
)braket
op_member_access_from_pointer
id|b_prev_free
op_assign
id|bh
suffix:semicolon
)brace
DECL|function|put_last_free
r_static
r_inline
r_void
id|put_last_free
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_int
id|isize
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_return
suffix:semicolon
id|isize
op_assign
id|BUFSIZE_INDEX
c_func
(paren
id|bh-&gt;b_size
)paren
suffix:semicolon
id|bh-&gt;b_dev
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* So it is obvious we are on the free list */
multiline_comment|/* add to back of free list */
r_if
c_cond
(paren
op_logical_neg
id|free_list
(braket
id|isize
)braket
)paren
(brace
id|free_list
(braket
id|isize
)braket
op_assign
id|bh
suffix:semicolon
id|bh-&gt;b_prev_free
op_assign
id|bh
suffix:semicolon
)brace
suffix:semicolon
id|nr_free
(braket
id|isize
)braket
op_increment
suffix:semicolon
id|bh-&gt;b_next_free
op_assign
id|free_list
(braket
id|isize
)braket
suffix:semicolon
id|bh-&gt;b_prev_free
op_assign
id|free_list
(braket
id|isize
)braket
op_member_access_from_pointer
id|b_prev_free
suffix:semicolon
id|free_list
(braket
id|isize
)braket
op_member_access_from_pointer
id|b_prev_free-&gt;b_next_free
op_assign
id|bh
suffix:semicolon
id|free_list
(braket
id|isize
)braket
op_member_access_from_pointer
id|b_prev_free
op_assign
id|bh
suffix:semicolon
)brace
DECL|function|insert_into_queues
r_static
r_inline
r_void
id|insert_into_queues
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
multiline_comment|/* put at end of free list */
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_eq
l_int|0xffff
)paren
(brace
id|put_last_free
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lru_list
(braket
id|bh-&gt;b_list
)braket
)paren
(brace
id|lru_list
(braket
id|bh-&gt;b_list
)braket
op_assign
id|bh
suffix:semicolon
id|bh-&gt;b_prev_free
op_assign
id|bh
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_next_free
)paren
id|panic
c_func
(paren
l_string|&quot;VFS: buffer LRU pointers corrupted&quot;
)paren
suffix:semicolon
id|bh-&gt;b_next_free
op_assign
id|lru_list
(braket
id|bh-&gt;b_list
)braket
suffix:semicolon
id|bh-&gt;b_prev_free
op_assign
id|lru_list
(braket
id|bh-&gt;b_list
)braket
op_member_access_from_pointer
id|b_prev_free
suffix:semicolon
id|lru_list
(braket
id|bh-&gt;b_list
)braket
op_member_access_from_pointer
id|b_prev_free-&gt;b_next_free
op_assign
id|bh
suffix:semicolon
id|lru_list
(braket
id|bh-&gt;b_list
)braket
op_member_access_from_pointer
id|b_prev_free
op_assign
id|bh
suffix:semicolon
id|nr_buffers_type
(braket
id|bh-&gt;b_list
)braket
op_increment
suffix:semicolon
id|nr_buffers_st
(braket
id|BUFSIZE_INDEX
c_func
(paren
id|bh-&gt;b_size
)paren
)braket
(braket
id|bh-&gt;b_list
)braket
op_increment
suffix:semicolon
multiline_comment|/* put the buffer in new hash-queue if it has a device */
id|bh-&gt;b_prev
op_assign
l_int|NULL
suffix:semicolon
id|bh-&gt;b_next
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh-&gt;b_dev
)paren
r_return
suffix:semicolon
id|bh-&gt;b_next
op_assign
id|hash
c_func
(paren
id|bh-&gt;b_dev
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
id|hash
c_func
(paren
id|bh-&gt;b_dev
comma
id|bh-&gt;b_blocknr
)paren
op_assign
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_next
)paren
id|bh-&gt;b_next-&gt;b_prev
op_assign
id|bh
suffix:semicolon
)brace
DECL|function|find_buffer
r_static
r_struct
id|buffer_head
op_star
id|find_buffer
c_func
(paren
id|dev_t
id|dev
comma
r_int
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|tmp
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
id|hash
c_func
(paren
id|dev
comma
id|block
)paren
suffix:semicolon
id|tmp
op_ne
l_int|NULL
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_next
)paren
r_if
c_cond
(paren
id|tmp-&gt;b_dev
op_eq
id|dev
op_logical_and
id|tmp-&gt;b_blocknr
op_eq
id|block
)paren
r_if
c_cond
(paren
id|tmp-&gt;b_size
op_eq
id|size
)paren
r_return
id|tmp
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: Wrong blocksize on device %d/%d&bslash;n&quot;
comma
id|MAJOR
c_func
(paren
id|dev
)paren
comma
id|MINOR
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Why like this, I hear you say... The reason is race-conditions.&n; * As we don&squot;t lock buffers (unless we are reading them, that is),&n; * something might happen to it while we sleep (ie a read-error&n; * will force it bad). This shouldn&squot;t really happen currently, but&n; * the code is ready.&n; */
DECL|function|get_hash_table
r_struct
id|buffer_head
op_star
id|get_hash_table
c_func
(paren
id|dev_t
id|dev
comma
r_int
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|find_buffer
c_func
(paren
id|dev
comma
id|block
comma
id|size
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|bh-&gt;b_count
op_increment
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_eq
id|dev
op_logical_and
id|bh-&gt;b_blocknr
op_eq
id|block
op_logical_and
id|bh-&gt;b_size
op_eq
id|size
)paren
r_return
id|bh
suffix:semicolon
id|bh-&gt;b_count
op_decrement
suffix:semicolon
)brace
)brace
DECL|function|set_blocksize
r_void
id|set_blocksize
c_func
(paren
id|dev_t
id|dev
comma
r_int
id|size
)paren
(brace
r_int
id|i
comma
id|nlist
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|bhnext
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
)paren
r_return
suffix:semicolon
r_switch
c_cond
(paren
id|size
)paren
(brace
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;Invalid blocksize passed to set_blocksize&quot;
)paren
suffix:semicolon
r_case
l_int|512
suffix:colon
r_case
l_int|1024
suffix:colon
r_case
l_int|2048
suffix:colon
r_case
l_int|4096
suffix:colon
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
op_eq
l_int|0
op_logical_and
id|size
op_eq
id|BLOCK_SIZE
)paren
(brace
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
op_assign
id|size
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
op_eq
id|size
)paren
r_return
suffix:semicolon
id|sync_buffers
c_func
(paren
id|dev
comma
l_int|2
)paren
suffix:semicolon
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
op_assign
id|size
suffix:semicolon
multiline_comment|/* We need to be quite careful how we do this - we are moving entries&n;     around on the free list, and we can get in a loop if we are not careful.*/
r_for
c_loop
(paren
id|nlist
op_assign
l_int|0
suffix:semicolon
id|nlist
OL
id|NR_LIST
suffix:semicolon
id|nlist
op_increment
)paren
(brace
id|bh
op_assign
id|lru_list
(braket
id|nlist
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|nr_buffers_type
(braket
id|nlist
)braket
op_star
l_int|2
suffix:semicolon
op_decrement
id|i
OG
l_int|0
suffix:semicolon
id|bh
op_assign
id|bhnext
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
r_break
suffix:semicolon
)brace
id|bhnext
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_ne
id|dev
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_size
op_eq
id|size
)paren
r_continue
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_eq
id|dev
op_logical_and
id|bh-&gt;b_size
op_ne
id|size
)paren
(brace
id|bh-&gt;b_uptodate
op_assign
id|bh-&gt;b_dirt
op_assign
id|bh-&gt;b_req
op_assign
id|bh-&gt;b_flushtime
op_assign
l_int|0
suffix:semicolon
)brace
suffix:semicolon
id|remove_from_hash_queue
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|macro|BADNESS
mdefine_line|#define BADNESS(bh) (((bh)-&gt;b_dirt&lt;&lt;1)+(bh)-&gt;b_lock)
DECL|function|refill_freelist
r_void
id|refill_freelist
c_func
(paren
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|tmp
suffix:semicolon
r_struct
id|buffer_head
op_star
id|candidate
(braket
id|NR_LIST
)braket
suffix:semicolon
r_int
r_int
id|best_time
comma
id|winner
suffix:semicolon
r_int
id|isize
op_assign
id|BUFSIZE_INDEX
c_func
(paren
id|size
)paren
suffix:semicolon
r_int
id|buffers
(braket
id|NR_LIST
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|needed
suffix:semicolon
multiline_comment|/* First see if we even need this.  Sometimes it is advantageous&n;&t; to request some blocks in a filesystem that we know that we will&n;&t; be needing ahead of time. */
r_if
c_cond
(paren
id|nr_free
(braket
id|isize
)braket
OG
l_int|100
)paren
r_return
suffix:semicolon
multiline_comment|/* If there are too many dirty buffers, we wake up the update process&n;&t;   now so as to ensure that there are still clean buffers available&n;&t;   for user processes to use (and dirty) */
multiline_comment|/* We are going to try and locate this much memory */
id|needed
op_assign
id|bdf_prm.b_un.nrefill
op_star
id|size
suffix:semicolon
r_while
c_loop
(paren
id|nr_free_pages
OG
id|min_free_pages
op_logical_and
id|needed
OG
l_int|0
op_logical_and
id|grow_buffers
c_func
(paren
id|GFP_BUFFER
comma
id|size
)paren
)paren
(brace
id|needed
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|needed
op_le
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* See if there are too many buffers of a different size.&n;&t;   If so, victimize them */
r_while
c_loop
(paren
id|maybe_shrink_lav_buffers
c_func
(paren
id|size
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|grow_buffers
c_func
(paren
id|GFP_BUFFER
comma
id|size
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|needed
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|needed
op_le
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
)brace
suffix:semicolon
multiline_comment|/* OK, we cannot grow the buffer cache, now try and get some&n;&t;   from the lru list */
multiline_comment|/* First set the candidate pointers to usable buffers.  This&n;&t;   should be quick nearly all of the time. */
id|repeat0
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_LIST
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|BUF_DIRTY
op_logical_or
id|i
op_eq
id|BUF_SHARED
op_logical_or
id|nr_buffers_type
(braket
id|i
)braket
op_eq
l_int|0
)paren
(brace
id|candidate
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|buffers
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|buffers
(braket
id|i
)braket
op_assign
id|nr_buffers_type
(braket
id|i
)braket
suffix:semicolon
r_for
c_loop
(paren
id|bh
op_assign
id|lru_list
(braket
id|i
)braket
suffix:semicolon
id|buffers
(braket
id|i
)braket
OG
l_int|0
suffix:semicolon
id|bh
op_assign
id|tmp
comma
id|buffers
(braket
id|i
)braket
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|buffers
(braket
id|i
)braket
OL
l_int|0
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Here is the problem&quot;
)paren
suffix:semicolon
)brace
id|tmp
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|mem_map
(braket
id|MAP_NR
c_func
(paren
(paren
r_int
r_int
)paren
id|bh-&gt;b_data
)paren
)braket
op_ne
l_int|1
op_logical_or
id|bh-&gt;b_dirt
)paren
(brace
id|refile_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_count
op_logical_or
id|bh-&gt;b_size
op_ne
id|size
)paren
r_continue
suffix:semicolon
multiline_comment|/* Buffers are written in the order they are placed &n;&t;&t;&t;    on the locked list. If we encounter a locked&n;&t;&t;&t;    buffer here, this means that the rest of them&n;&t;&t;&t;    are also locked */
r_if
c_cond
(paren
id|bh-&gt;b_lock
op_logical_and
(paren
id|i
op_eq
id|BUF_LOCKED
op_logical_or
id|i
op_eq
id|BUF_LOCKED1
)paren
)paren
(brace
id|buffers
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BADNESS
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffers
(braket
id|i
)braket
)paren
(brace
id|candidate
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Nothing on this list */
r_else
id|candidate
(braket
id|i
)braket
op_assign
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|candidate
(braket
id|i
)braket
op_logical_and
id|candidate
(braket
id|i
)braket
op_member_access_from_pointer
id|b_count
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Here is the problem&quot;
)paren
suffix:semicolon
)brace
)brace
id|repeat
suffix:colon
r_if
c_cond
(paren
id|needed
op_le
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Now see which candidate wins the election */
id|winner
op_assign
id|best_time
op_assign
id|UINT_MAX
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_LIST
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|candidate
(braket
id|i
)braket
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|candidate
(braket
id|i
)braket
op_member_access_from_pointer
id|b_lru_time
OL
id|best_time
)paren
(brace
id|best_time
op_assign
id|candidate
(braket
id|i
)braket
op_member_access_from_pointer
id|b_lru_time
suffix:semicolon
id|winner
op_assign
id|i
suffix:semicolon
)brace
)brace
multiline_comment|/* If we have a winner, use it, and then get a new candidate from that list */
r_if
c_cond
(paren
id|winner
op_ne
id|UINT_MAX
)paren
(brace
id|i
op_assign
id|winner
suffix:semicolon
id|bh
op_assign
id|candidate
(braket
id|i
)braket
suffix:semicolon
id|candidate
(braket
id|i
)braket
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_if
c_cond
(paren
id|candidate
(braket
id|i
)braket
op_eq
id|bh
)paren
(brace
id|candidate
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Got last one */
r_if
c_cond
(paren
id|bh-&gt;b_count
op_logical_or
id|bh-&gt;b_size
op_ne
id|size
)paren
id|panic
c_func
(paren
l_string|&quot;Busy buffer in candidate list&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mem_map
(braket
id|MAP_NR
c_func
(paren
(paren
r_int
r_int
)paren
id|bh-&gt;b_data
)paren
)braket
op_ne
l_int|1
)paren
id|panic
c_func
(paren
l_string|&quot;Shared buffer in candidate list&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BADNESS
c_func
(paren
id|bh
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Buffer in candidate list with BADNESS != 0&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dev
op_eq
l_int|0xffff
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Wrong list&quot;
)paren
suffix:semicolon
)brace
id|remove_from_queues
c_func
(paren
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_dev
op_assign
l_int|0xffff
suffix:semicolon
id|put_last_free
c_func
(paren
id|bh
)paren
suffix:semicolon
id|needed
op_sub_assign
id|bh-&gt;b_size
suffix:semicolon
id|buffers
(braket
id|i
)braket
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|buffers
(braket
id|i
)braket
OL
l_int|0
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Here is the problem&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffers
(braket
id|i
)braket
op_eq
l_int|0
)paren
(brace
id|candidate
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Now all we need to do is advance the candidate pointer&n;&t;&t;   from the winner list to the next usable buffer */
r_if
c_cond
(paren
id|candidate
(braket
id|i
)braket
op_logical_and
id|buffers
(braket
id|i
)braket
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|buffers
(braket
id|i
)braket
op_le
l_int|0
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Here is another problem&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|bh
op_assign
id|candidate
(braket
id|i
)braket
suffix:semicolon
id|buffers
(braket
id|i
)braket
OG
l_int|0
suffix:semicolon
id|bh
op_assign
id|tmp
comma
id|buffers
(braket
id|i
)braket
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|buffers
(braket
id|i
)braket
OL
l_int|0
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Here is the problem&quot;
)paren
suffix:semicolon
)brace
id|tmp
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|mem_map
(braket
id|MAP_NR
c_func
(paren
(paren
r_int
r_int
)paren
id|bh-&gt;b_data
)paren
)braket
op_ne
l_int|1
op_logical_or
id|bh-&gt;b_dirt
)paren
(brace
id|refile_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_count
op_logical_or
id|bh-&gt;b_size
op_ne
id|size
)paren
r_continue
suffix:semicolon
multiline_comment|/* Buffers are written in the order they are&n;&t;&t;&t;&t;   placed on the locked list.  If we encounter&n;&t;&t;&t;&t;   a locked buffer here, this means that the&n;&t;&t;&t;&t;   rest of them are also locked */
r_if
c_cond
(paren
id|bh-&gt;b_lock
op_logical_and
(paren
id|i
op_eq
id|BUF_LOCKED
op_logical_or
id|i
op_eq
id|BUF_LOCKED1
)paren
)paren
(brace
id|buffers
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|BADNESS
c_func
(paren
id|bh
)paren
)paren
r_continue
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffers
(braket
id|i
)braket
)paren
(brace
id|candidate
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Nothing here */
r_else
id|candidate
(braket
id|i
)braket
op_assign
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|candidate
(braket
id|i
)braket
op_logical_and
id|candidate
(braket
id|i
)braket
op_member_access_from_pointer
id|b_count
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Here is the problem&quot;
)paren
suffix:semicolon
)brace
)brace
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|needed
op_le
l_int|0
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Too bad, that was not enough. Try a little harder to grow some. */
r_if
c_cond
(paren
id|nr_free_pages
OG
l_int|5
)paren
(brace
r_if
c_cond
(paren
id|grow_buffers
c_func
(paren
id|GFP_BUFFER
comma
id|size
)paren
)paren
(brace
id|needed
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
r_goto
id|repeat0
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/* and repeat until we find something good */
r_if
c_cond
(paren
op_logical_neg
id|grow_buffers
c_func
(paren
id|GFP_ATOMIC
comma
id|size
)paren
)paren
id|wakeup_bdflush
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|needed
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
r_goto
id|repeat0
suffix:semicolon
)brace
multiline_comment|/*&n; * Ok, this is getblk, and it isn&squot;t very clear, again to hinder&n; * race-conditions. Most of the code is seldom used, (ie repeating),&n; * so it should be much more efficient than it looks.&n; *&n; * The algorithm is changed: hopefully better, and an elusive bug removed.&n; *&n; * 14.02.92: changed it to sync dirty buffers a bit: better performance&n; * when the filesystem starts to get full of dirty blocks (I hope).&n; */
DECL|function|getblk
r_struct
id|buffer_head
op_star
id|getblk
c_func
(paren
id|dev_t
id|dev
comma
r_int
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|isize
op_assign
id|BUFSIZE_INDEX
c_func
(paren
id|size
)paren
suffix:semicolon
multiline_comment|/* Update this for the buffer size lav. */
id|buffer_usage
(braket
id|isize
)braket
op_increment
suffix:semicolon
multiline_comment|/* If there are too many dirty buffers, we wake up the update process&n;&t;   now so as to ensure that there are still clean buffers available&n;&t;   for user processes to use (and dirty) */
id|repeat
suffix:colon
id|bh
op_assign
id|get_hash_table
c_func
(paren
id|dev
comma
id|block
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_uptodate
op_logical_and
op_logical_neg
id|bh-&gt;b_dirt
)paren
id|put_last_lru
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh-&gt;b_dirt
)paren
(brace
id|bh-&gt;b_flushtime
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|bh
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|free_list
(braket
id|isize
)braket
)paren
(brace
id|refill_freelist
c_func
(paren
id|size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|find_buffer
c_func
(paren
id|dev
comma
id|block
comma
id|size
)paren
)paren
r_goto
id|repeat
suffix:semicolon
id|bh
op_assign
id|free_list
(braket
id|isize
)braket
suffix:semicolon
id|remove_from_free_list
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* OK, FINALLY we know that this buffer is the only one of it&squot;s kind, */
multiline_comment|/* and that it&squot;s unused (b_count=0), unlocked (b_lock=0), and clean */
id|bh-&gt;b_count
op_assign
l_int|1
suffix:semicolon
id|bh-&gt;b_dirt
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_lock
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_uptodate
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_flushtime
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_req
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_dev
op_assign
id|dev
suffix:semicolon
id|bh-&gt;b_blocknr
op_assign
id|block
suffix:semicolon
id|insert_into_queues
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
DECL|function|set_writetime
r_void
id|set_writetime
c_func
(paren
r_struct
id|buffer_head
op_star
id|buf
comma
r_int
id|flag
)paren
(brace
r_int
id|newtime
suffix:semicolon
r_if
c_cond
(paren
id|buf-&gt;b_dirt
)paren
(brace
multiline_comment|/* Move buffer to dirty list if jiffies is clear */
id|newtime
op_assign
id|jiffies
op_plus
(paren
id|flag
ques
c_cond
id|bdf_prm.b_un.age_super
suffix:colon
id|bdf_prm.b_un.age_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf-&gt;b_flushtime
op_logical_or
id|buf-&gt;b_flushtime
OG
id|newtime
)paren
(brace
id|buf-&gt;b_flushtime
op_assign
id|newtime
suffix:semicolon
)brace
)brace
r_else
(brace
id|buf-&gt;b_flushtime
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|variable|buffer_disposition
r_static
r_char
id|buffer_disposition
(braket
)braket
op_assign
(brace
id|BUF_CLEAN
comma
id|BUF_SHARED
comma
id|BUF_LOCKED
comma
id|BUF_SHARED
comma
id|BUF_DIRTY
comma
id|BUF_DIRTY
comma
id|BUF_DIRTY
comma
id|BUF_DIRTY
)brace
suffix:semicolon
DECL|function|refile_buffer
r_void
(def_block
id|refile_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|buf
)paren
(brace
r_int
id|i
comma
id|dispose
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buf-&gt;b_dev
op_eq
l_int|0xffff
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Attempt to refile free buffer&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mem_map
(braket
id|MAP_NR
c_func
(paren
(paren
r_int
r_int
)paren
id|buf-&gt;b_data
)paren
)braket
op_ne
l_int|1
)paren
(brace
id|i
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf-&gt;b_lock
)paren
(brace
id|i
op_or_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf-&gt;b_dirt
)paren
(brace
id|i
op_or_assign
l_int|4
suffix:semicolon
)brace
id|dispose
op_assign
id|buffer_disposition
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|buf-&gt;b_list
op_eq
id|BUF_SHARED
op_logical_and
id|dispose
op_eq
id|BUF_CLEAN
)paren
(brace
id|dispose
op_assign
id|BUF_UNSHARED
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dispose
op_eq
op_minus
l_int|1
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Bad buffer settings (%d)&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dispose
op_eq
id|BUF_CLEAN
)paren
(brace
id|buf-&gt;b_lru_time
op_assign
id|jiffies
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dispose
op_ne
id|buf-&gt;b_list
)paren
(brace
r_if
c_cond
(paren
id|dispose
op_eq
id|BUF_DIRTY
op_logical_or
id|dispose
op_eq
id|BUF_UNSHARED
)paren
(brace
id|buf-&gt;b_lru_time
op_assign
id|jiffies
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dispose
op_eq
id|BUF_LOCKED
op_logical_and
(paren
id|buf-&gt;b_flushtime
op_minus
id|buf-&gt;b_lru_time
)paren
op_le
id|bdf_prm.b_un.age_super
)paren
(brace
id|dispose
op_assign
id|BUF_LOCKED1
suffix:semicolon
)brace
id|remove_from_queues
c_func
(paren
id|buf
)paren
suffix:semicolon
id|buf-&gt;b_list
op_assign
id|dispose
suffix:semicolon
id|insert_into_queues
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dispose
op_eq
id|BUF_DIRTY
op_logical_and
id|nr_buffers_type
(braket
id|BUF_DIRTY
)braket
OG
(paren
id|nr_buffers
op_minus
id|nr_buffers_type
(braket
id|BUF_SHARED
)braket
)paren
op_star
id|bdf_prm.b_un.nfract
op_div
l_int|100
)paren
(brace
id|wakeup_bdflush
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
)brace
)def_block
DECL|function|brelse
r_void
id|brelse
c_func
(paren
r_struct
id|buffer_head
op_star
id|buf
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|buf
)paren
suffix:semicolon
multiline_comment|/* If dirty, mark the time this buffer should be written back */
id|set_writetime
c_func
(paren
id|buf
comma
l_int|0
)paren
suffix:semicolon
id|refile_buffer
c_func
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf-&gt;b_count
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|buf-&gt;b_count
)paren
r_return
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|buffer_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;VFS: brelse: Trying to free free buffer&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * bread() reads a specified block and returns the buffer that contains&n; * it. It returns NULL if the block was unreadable.&n; */
DECL|function|bread
r_struct
id|buffer_head
op_star
id|bread
c_func
(paren
id|dev_t
id|dev
comma
r_int
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|getblk
c_func
(paren
id|dev
comma
id|block
comma
id|size
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: bread: READ error on device %d/%d&bslash;n&quot;
comma
id|MAJOR
c_func
(paren
id|dev
)paren
comma
id|MINOR
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bh-&gt;b_uptodate
)paren
r_return
id|bh
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_uptodate
)paren
r_return
id|bh
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Ok, breada can be used as bread, but additionally to mark other&n; * blocks for reading as well. End the argument list with a negative&n; * number.&n; */
DECL|macro|NBUF
mdefine_line|#define NBUF 16
DECL|function|breada
r_struct
id|buffer_head
op_star
id|breada
c_func
(paren
id|dev_t
id|dev
comma
r_int
id|block
comma
r_int
id|bufsize
comma
r_int
r_int
id|pos
comma
r_int
r_int
id|filesize
)paren
(brace
r_struct
id|buffer_head
op_star
id|bhlist
(braket
id|NBUF
)braket
suffix:semicolon
r_int
r_int
id|blocks
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|index
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|filesize
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|block
OL
l_int|0
op_logical_or
op_logical_neg
(paren
id|bh
op_assign
id|getblk
c_func
(paren
id|dev
comma
id|block
comma
id|bufsize
)paren
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|index
op_assign
id|BUFSIZE_INDEX
c_func
(paren
id|bh-&gt;b_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_uptodate
)paren
r_return
id|bh
suffix:semicolon
id|blocks
op_assign
(paren
(paren
id|filesize
op_amp
(paren
id|bufsize
op_minus
l_int|1
)paren
)paren
op_minus
(paren
id|pos
op_amp
(paren
id|bufsize
op_minus
l_int|1
)paren
)paren
)paren
op_rshift
(paren
l_int|9
op_plus
id|index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blocks
OG
(paren
id|read_ahead
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
op_rshift
id|index
)paren
)paren
id|blocks
op_assign
id|read_ahead
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
op_rshift
id|index
suffix:semicolon
r_if
c_cond
(paren
id|blocks
OG
id|NBUF
)paren
id|blocks
op_assign
id|NBUF
suffix:semicolon
id|bhlist
(braket
l_int|0
)braket
op_assign
id|bh
suffix:semicolon
id|j
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bh
op_assign
id|getblk
c_func
(paren
id|dev
comma
id|block
op_plus
id|i
comma
id|bufsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_uptodate
)paren
(brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bhlist
(braket
id|j
op_increment
)braket
op_assign
id|bh
suffix:semicolon
)brace
multiline_comment|/* Request the read for these buffers, and then release them */
id|ll_rw_block
c_func
(paren
id|READ
comma
id|j
comma
id|bhlist
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|j
suffix:semicolon
id|i
op_increment
)paren
(brace
id|brelse
c_func
(paren
id|bhlist
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait for this buffer, and then continue on */
id|bh
op_assign
id|bhlist
(braket
l_int|0
)braket
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_uptodate
)paren
r_return
id|bh
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * See fs/inode.c for the weird use of volatile..&n; */
DECL|function|put_unused_buffer_head
r_static
r_void
id|put_unused_buffer_head
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|wait_queue
op_star
id|wait
suffix:semicolon
id|wait
op_assign
(paren
(paren
r_volatile
r_struct
id|buffer_head
op_star
)paren
id|bh
)paren
op_member_access_from_pointer
id|b_wait
suffix:semicolon
id|memset
c_func
(paren
id|bh
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|bh
)paren
)paren
suffix:semicolon
(paren
(paren
r_volatile
r_struct
id|buffer_head
op_star
)paren
id|bh
)paren
op_member_access_from_pointer
id|b_wait
op_assign
id|wait
suffix:semicolon
id|bh-&gt;b_next_free
op_assign
id|unused_list
suffix:semicolon
id|unused_list
op_assign
id|bh
suffix:semicolon
)brace
DECL|function|get_more_buffer_heads
r_static
r_void
id|get_more_buffer_heads
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|unused_list
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
(paren
r_struct
id|buffer_head
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_BUFFER
)paren
)paren
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|nr_buffer_heads
op_add_assign
id|i
op_assign
id|PAGE_SIZE
op_div
r_sizeof
op_star
id|bh
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|bh-&gt;b_next_free
op_assign
id|unused_list
suffix:semicolon
multiline_comment|/* only make link */
id|unused_list
op_assign
id|bh
op_increment
suffix:semicolon
)brace
)brace
DECL|function|get_unused_buffer_head
r_static
r_struct
id|buffer_head
op_star
id|get_unused_buffer_head
c_func
(paren
r_void
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|get_more_buffer_heads
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|unused_list
)paren
r_return
l_int|NULL
suffix:semicolon
id|bh
op_assign
id|unused_list
suffix:semicolon
id|unused_list
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
id|bh-&gt;b_next_free
op_assign
l_int|NULL
suffix:semicolon
id|bh-&gt;b_data
op_assign
l_int|NULL
suffix:semicolon
id|bh-&gt;b_size
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_req
op_assign
l_int|0
suffix:semicolon
r_return
id|bh
suffix:semicolon
)brace
multiline_comment|/*&n; * Create the appropriate buffers when given a page for data area and&n; * the size of each buffer.. Use the bh-&gt;b_this_page linked list to&n; * follow the buffers created.  Return NULL if unable to create more&n; * buffers.&n; */
DECL|function|create_buffers
r_static
r_struct
id|buffer_head
op_star
id|create_buffers
c_func
(paren
r_int
r_int
id|page
comma
r_int
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|head
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
id|head
op_assign
l_int|NULL
suffix:semicolon
id|offset
op_assign
id|PAGE_SIZE
suffix:semicolon
r_while
c_loop
(paren
(paren
id|offset
op_sub_assign
id|size
)paren
OL
id|PAGE_SIZE
)paren
(brace
id|bh
op_assign
id|get_unused_buffer_head
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_goto
id|no_grow
suffix:semicolon
id|bh-&gt;b_this_page
op_assign
id|head
suffix:semicolon
id|head
op_assign
id|bh
suffix:semicolon
id|bh-&gt;b_data
op_assign
(paren
r_char
op_star
)paren
(paren
id|page
op_plus
id|offset
)paren
suffix:semicolon
id|bh-&gt;b_size
op_assign
id|size
suffix:semicolon
id|bh-&gt;b_dev
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* Flag as unused */
)brace
r_return
id|head
suffix:semicolon
multiline_comment|/*&n; * In case anything failed, we just free everything we got.&n; */
id|no_grow
suffix:colon
id|bh
op_assign
id|head
suffix:semicolon
r_while
c_loop
(paren
id|bh
)paren
(brace
id|head
op_assign
id|bh
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
id|put_unused_buffer_head
c_func
(paren
id|head
)paren
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|read_buffers
r_static
r_void
id|read_buffers
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
(braket
)braket
comma
r_int
id|nrbuf
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|bhnum
op_assign
l_int|0
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bhr
(braket
l_int|8
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nrbuf
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|bh
(braket
id|i
)braket
op_logical_and
op_logical_neg
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_uptodate
)paren
id|bhr
(braket
id|bhnum
op_increment
)braket
op_assign
id|bh
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bhnum
)paren
id|ll_rw_block
c_func
(paren
id|READ
comma
id|bhnum
comma
id|bhr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nrbuf
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|bh
(braket
id|i
)braket
)paren
(brace
id|wait_on_buffer
c_func
(paren
id|bh
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|check_aligned
r_static
r_int
r_int
id|check_aligned
c_func
(paren
r_struct
id|buffer_head
op_star
id|first
comma
r_int
r_int
id|address
comma
id|dev_t
id|dev
comma
r_int
op_star
id|b
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
(braket
l_int|8
)braket
suffix:semicolon
r_int
r_int
id|page
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
id|block
suffix:semicolon
r_int
id|nrbuf
suffix:semicolon
id|page
op_assign
(paren
r_int
r_int
)paren
id|first-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
id|page
op_amp
op_complement
id|PAGE_MASK
)paren
(brace
id|brelse
c_func
(paren
id|first
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
op_increment
suffix:semicolon
id|bh
(braket
l_int|0
)braket
op_assign
id|first
suffix:semicolon
id|nrbuf
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
id|size
suffix:semicolon
id|offset
OL
id|PAGE_SIZE
suffix:semicolon
id|offset
op_add_assign
id|size
)paren
(brace
id|block
op_assign
op_star
op_increment
id|b
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|block
)paren
r_goto
id|no_go
suffix:semicolon
id|first
op_assign
id|get_hash_table
c_func
(paren
id|dev
comma
id|block
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|first
)paren
r_goto
id|no_go
suffix:semicolon
id|bh
(braket
id|nrbuf
op_increment
)braket
op_assign
id|first
suffix:semicolon
r_if
c_cond
(paren
id|page
op_plus
id|offset
op_ne
(paren
r_int
r_int
)paren
id|first-&gt;b_data
)paren
r_goto
id|no_go
suffix:semicolon
)brace
id|read_buffers
c_func
(paren
id|bh
comma
id|nrbuf
)paren
suffix:semicolon
multiline_comment|/* make sure they are actually read correctly */
r_while
c_loop
(paren
id|nrbuf
op_decrement
OG
l_int|0
)paren
id|brelse
c_func
(paren
id|bh
(braket
id|nrbuf
)braket
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|address
)paren
suffix:semicolon
op_increment
id|current-&gt;mm-&gt;min_flt
suffix:semicolon
r_return
id|page
suffix:semicolon
id|no_go
suffix:colon
r_while
c_loop
(paren
id|nrbuf
op_decrement
OG
l_int|0
)paren
id|brelse
c_func
(paren
id|bh
(braket
id|nrbuf
)braket
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|try_to_load_aligned
r_static
r_int
r_int
id|try_to_load_aligned
c_func
(paren
r_int
r_int
id|address
comma
id|dev_t
id|dev
comma
r_int
id|b
(braket
)braket
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|tmp
comma
op_star
id|arr
(braket
l_int|8
)braket
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
id|isize
op_assign
id|BUFSIZE_INDEX
c_func
(paren
id|size
)paren
suffix:semicolon
r_int
op_star
id|p
suffix:semicolon
r_int
id|block
suffix:semicolon
id|bh
op_assign
id|create_buffers
c_func
(paren
id|address
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* do any of the buffers already exist? punt if so.. */
id|p
op_assign
id|b
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|offset
OL
id|PAGE_SIZE
suffix:semicolon
id|offset
op_add_assign
id|size
)paren
(brace
id|block
op_assign
op_star
(paren
id|p
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|block
)paren
r_goto
id|not_aligned
suffix:semicolon
r_if
c_cond
(paren
id|find_buffer
c_func
(paren
id|dev
comma
id|block
comma
id|size
)paren
)paren
r_goto
id|not_aligned
suffix:semicolon
)brace
id|tmp
op_assign
id|bh
suffix:semicolon
id|p
op_assign
id|b
suffix:semicolon
id|block
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|arr
(braket
id|block
op_increment
)braket
op_assign
id|bh
suffix:semicolon
id|bh-&gt;b_count
op_assign
l_int|1
suffix:semicolon
id|bh-&gt;b_dirt
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_flushtime
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_uptodate
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_req
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_dev
op_assign
id|dev
suffix:semicolon
id|bh-&gt;b_blocknr
op_assign
op_star
(paren
id|p
op_increment
)paren
suffix:semicolon
id|bh-&gt;b_list
op_assign
id|BUF_CLEAN
suffix:semicolon
id|nr_buffers
op_increment
suffix:semicolon
id|nr_buffers_size
(braket
id|isize
)braket
op_increment
suffix:semicolon
id|insert_into_queues
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_this_page
)paren
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
id|buffermem
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|bh-&gt;b_this_page
op_assign
id|tmp
suffix:semicolon
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|address
)paren
)braket
op_increment
suffix:semicolon
id|buffer_pages
(braket
id|MAP_NR
c_func
(paren
id|address
)paren
)braket
op_assign
id|bh
suffix:semicolon
id|read_buffers
c_func
(paren
id|arr
comma
id|block
)paren
suffix:semicolon
r_while
c_loop
(paren
id|block
op_decrement
OG
l_int|0
)paren
id|brelse
c_func
(paren
id|arr
(braket
id|block
)braket
)paren
suffix:semicolon
op_increment
id|current-&gt;mm-&gt;maj_flt
suffix:semicolon
r_return
id|address
suffix:semicolon
id|not_aligned
suffix:colon
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|bh
)paren
op_ne
l_int|NULL
)paren
(brace
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
id|put_unused_buffer_head
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Try-to-share-buffers tries to minimize memory use by trying to keep&n; * both code pages and the buffer area in the same page. This is done by&n; * (a) checking if the buffers are already aligned correctly in memory and&n; * (b) if none of the buffer heads are in memory at all, trying to load&n; * them into memory the way we want them.&n; *&n; * This doesn&squot;t guarantee that the memory is shared, but should under most&n; * circumstances work very well indeed (ie &gt;90% sharing of code pages on&n; * demand-loadable executables).&n; */
DECL|function|try_to_share_buffers
r_static
r_inline
r_int
r_int
id|try_to_share_buffers
c_func
(paren
r_int
r_int
id|address
comma
id|dev_t
id|dev
comma
r_int
op_star
id|b
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|block
suffix:semicolon
id|block
op_assign
id|b
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|block
)paren
r_return
l_int|0
suffix:semicolon
id|bh
op_assign
id|get_hash_table
c_func
(paren
id|dev
comma
id|block
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
r_return
id|check_aligned
c_func
(paren
id|bh
comma
id|address
comma
id|dev
comma
id|b
comma
id|size
)paren
suffix:semicolon
r_return
id|try_to_load_aligned
c_func
(paren
id|address
comma
id|dev
comma
id|b
comma
id|size
)paren
suffix:semicolon
)brace
DECL|macro|COPYBLK
mdefine_line|#define COPYBLK(size,from,to) &bslash;&n;__asm__ __volatile__(&quot;rep ; movsl&quot;: &bslash;&n;&t;:&quot;c&quot; (((unsigned long) size) &gt;&gt; 2),&quot;S&quot; (from),&quot;D&quot; (to) &bslash;&n;&t;:&quot;cx&quot;,&quot;di&quot;,&quot;si&quot;)
multiline_comment|/*&n; * bread_page reads four buffers into memory at the desired address. It&squot;s&n; * a function of its own, as there is some speed to be got by reading them&n; * all at the same time, not waiting for one to be read, and then another&n; * etc. This also allows us to optimize memory usage by sharing code pages&n; * and filesystem buffers..&n; */
DECL|function|bread_page
r_int
r_int
id|bread_page
c_func
(paren
r_int
r_int
id|address
comma
id|dev_t
id|dev
comma
r_int
id|b
(braket
)braket
comma
r_int
id|size
comma
r_int
id|no_share
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
(braket
l_int|8
)braket
suffix:semicolon
r_int
r_int
id|where
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|no_share
)paren
(brace
id|where
op_assign
id|try_to_share_buffers
c_func
(paren
id|address
comma
id|dev
comma
id|b
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|where
)paren
r_return
id|where
suffix:semicolon
)brace
op_increment
id|current-&gt;mm-&gt;maj_flt
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|PAGE_SIZE
suffix:semicolon
id|i
op_increment
comma
id|j
op_add_assign
id|size
)paren
(brace
id|bh
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|b
(braket
id|i
)braket
)paren
id|bh
(braket
id|i
)braket
op_assign
id|getblk
c_func
(paren
id|dev
comma
id|b
(braket
id|i
)braket
comma
id|size
)paren
suffix:semicolon
)brace
id|read_buffers
c_func
(paren
id|bh
comma
id|i
)paren
suffix:semicolon
id|where
op_assign
id|address
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|PAGE_SIZE
suffix:semicolon
id|i
op_increment
comma
id|j
op_add_assign
id|size
comma
id|where
op_add_assign
id|size
)paren
(brace
r_if
c_cond
(paren
id|bh
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_uptodate
)paren
id|COPYBLK
c_func
(paren
id|size
comma
(paren
r_int
r_int
)paren
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_data
comma
id|where
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_return
id|address
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to increase the number of buffers available: the size argument&n; * is used to determine what kind of buffers we want.&n; */
DECL|function|grow_buffers
r_static
r_int
id|grow_buffers
c_func
(paren
r_int
id|pri
comma
r_int
id|size
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|tmp
suffix:semicolon
r_struct
id|buffer_head
op_star
id|insert_point
suffix:semicolon
r_int
id|isize
suffix:semicolon
r_if
c_cond
(paren
(paren
id|size
op_amp
l_int|511
)paren
op_logical_or
(paren
id|size
OG
id|PAGE_SIZE
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: grow_buffers: size = %d&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|isize
op_assign
id|BUFSIZE_INDEX
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_assign
id|__get_free_page
c_func
(paren
id|pri
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|bh
op_assign
id|create_buffers
c_func
(paren
id|page
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|insert_point
op_assign
id|free_list
(braket
id|isize
)braket
suffix:semicolon
id|tmp
op_assign
id|bh
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|nr_free
(braket
id|isize
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|insert_point
)paren
(brace
id|tmp-&gt;b_next_free
op_assign
id|insert_point-&gt;b_next_free
suffix:semicolon
id|tmp-&gt;b_prev_free
op_assign
id|insert_point
suffix:semicolon
id|insert_point-&gt;b_next_free-&gt;b_prev_free
op_assign
id|tmp
suffix:semicolon
id|insert_point-&gt;b_next_free
op_assign
id|tmp
suffix:semicolon
)brace
r_else
(brace
id|tmp-&gt;b_prev_free
op_assign
id|tmp
suffix:semicolon
id|tmp-&gt;b_next_free
op_assign
id|tmp
suffix:semicolon
)brace
id|insert_point
op_assign
id|tmp
suffix:semicolon
op_increment
id|nr_buffers
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;b_this_page
)paren
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
id|free_list
(braket
id|isize
)braket
op_assign
id|bh
suffix:semicolon
id|buffer_pages
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
op_assign
id|bh
suffix:semicolon
id|tmp-&gt;b_this_page
op_assign
id|bh
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|buffer_wait
)paren
suffix:semicolon
id|buffermem
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * try_to_free() checks if all the buffers on this particular page&n; * are unused, and free&squot;s the page if so.&n; */
DECL|function|try_to_free
r_static
r_int
id|try_to_free
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_struct
id|buffer_head
op_star
op_star
id|bhp
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tmp
comma
op_star
id|p
suffix:semicolon
r_int
id|isize
op_assign
id|BUFSIZE_INDEX
c_func
(paren
id|bh-&gt;b_size
)paren
suffix:semicolon
op_star
id|bhp
op_assign
id|bh
suffix:semicolon
id|page
op_assign
(paren
r_int
r_int
)paren
id|bh-&gt;b_data
suffix:semicolon
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
id|tmp
op_assign
id|bh
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;b_count
op_logical_or
id|tmp-&gt;b_dirt
op_logical_or
id|tmp-&gt;b_lock
op_logical_or
id|tmp-&gt;b_wait
)paren
r_return
l_int|0
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
suffix:semicolon
id|tmp
op_assign
id|bh
suffix:semicolon
r_do
(brace
id|p
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
id|nr_buffers
op_decrement
suffix:semicolon
id|nr_buffers_size
(braket
id|isize
)braket
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
op_star
id|bhp
)paren
(brace
op_star
id|bhp
op_assign
id|p-&gt;b_prev_free
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
op_star
id|bhp
)paren
multiline_comment|/* Was this the last in the list? */
op_star
id|bhp
op_assign
l_int|NULL
suffix:semicolon
)brace
id|remove_from_queues
c_func
(paren
id|p
)paren
suffix:semicolon
id|put_unused_buffer_head
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
suffix:semicolon
id|buffermem
op_sub_assign
id|PAGE_SIZE
suffix:semicolon
id|buffer_pages
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
op_assign
l_int|NULL
suffix:semicolon
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
op_logical_neg
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * Consult the load average for buffers and decide whether or not&n; * we should shrink the buffers of one size or not.  If we decide yes,&n; * do it and return 1.  Else return 0.  Do not attempt to shrink size&n; * that is specified.&n; *&n; * I would prefer not to use a load average, but the way things are now it&n; * seems unavoidable.  The way to get rid of it would be to force clustering&n; * universally, so that when we reclaim buffers we always reclaim an entire&n; * page.  Doing this would mean that we all need to move towards QMAGIC.&n; */
DECL|function|maybe_shrink_lav_buffers
r_static
r_int
id|maybe_shrink_lav_buffers
c_func
(paren
r_int
id|size
)paren
(brace
r_int
id|nlist
suffix:semicolon
r_int
id|isize
suffix:semicolon
r_int
id|total_lav
comma
id|total_n_buffers
comma
id|n_sizes
suffix:semicolon
multiline_comment|/* Do not consider the shared buffers since they would not tend&n;&t;   to have getblk called very often, and this would throw off&n;&t;   the lav.  They are not easily reclaimable anyway (let the swapper&n;&t;   make the first move). */
id|total_lav
op_assign
id|total_n_buffers
op_assign
id|n_sizes
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|nlist
op_assign
l_int|0
suffix:semicolon
id|nlist
OL
id|NR_SIZES
suffix:semicolon
id|nlist
op_increment
)paren
(brace
id|total_lav
op_add_assign
id|buffers_lav
(braket
id|nlist
)braket
suffix:semicolon
r_if
c_cond
(paren
id|nr_buffers_size
(braket
id|nlist
)braket
)paren
(brace
id|n_sizes
op_increment
suffix:semicolon
)brace
id|total_n_buffers
op_add_assign
id|nr_buffers_size
(braket
id|nlist
)braket
suffix:semicolon
id|total_n_buffers
op_sub_assign
id|nr_buffers_st
(braket
id|nlist
)braket
(braket
id|BUF_SHARED
)braket
suffix:semicolon
)brace
multiline_comment|/* See if we have an excessive number of buffers of a particular&n;&t;   size - if so, victimize that bunch. */
id|isize
op_assign
(paren
id|size
ques
c_cond
id|BUFSIZE_INDEX
c_func
(paren
id|size
)paren
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_sizes
OG
l_int|1
)paren
r_for
c_loop
(paren
id|nlist
op_assign
l_int|0
suffix:semicolon
id|nlist
OL
id|NR_SIZES
suffix:semicolon
id|nlist
op_increment
)paren
(brace
r_if
c_cond
(paren
id|nlist
op_eq
id|isize
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nr_buffers_size
(braket
id|nlist
)braket
op_logical_and
id|bdf_prm.b_un.lav_const
op_star
id|buffers_lav
(braket
id|nlist
)braket
op_star
id|total_n_buffers
OL
id|total_lav
op_star
(paren
id|nr_buffers_size
(braket
id|nlist
)braket
op_minus
id|nr_buffers_st
(braket
id|nlist
)braket
(braket
id|BUF_SHARED
)braket
)paren
)paren
r_if
c_cond
(paren
id|shrink_specific_buffers
c_func
(paren
l_int|6
comma
id|bufferindex_size
(braket
id|nlist
)braket
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to free up some pages by shrinking the buffer-cache&n; *&n; * Priority tells the routine how hard to try to shrink the&n; * buffers: 3 means &quot;don&squot;t bother too much&quot;, while a value&n; * of 0 means &quot;we&squot;d better get some free pages now&quot;.&n; */
DECL|function|shrink_buffers
r_int
id|shrink_buffers
c_func
(paren
r_int
r_int
id|priority
)paren
(brace
r_if
c_cond
(paren
id|priority
OL
l_int|2
)paren
(brace
id|sync_buffers
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|priority
op_eq
l_int|2
)paren
(brace
id|wakeup_bdflush
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|maybe_shrink_lav_buffers
c_func
(paren
l_int|0
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* No good candidate size - take any size we can find */
r_return
id|shrink_specific_buffers
c_func
(paren
id|priority
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|shrink_specific_buffers
r_static
r_int
id|shrink_specific_buffers
c_func
(paren
r_int
r_int
id|priority
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|nlist
suffix:semicolon
r_int
id|i
comma
id|isize
comma
id|isize1
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|size
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Shrinking buffers of size %d&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* First try the free lists, and see if we can get a complete page&n;&t;   from here */
id|isize1
op_assign
(paren
id|size
ques
c_cond
id|BUFSIZE_INDEX
c_func
(paren
id|size
)paren
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|isize
op_assign
l_int|0
suffix:semicolon
id|isize
OL
id|NR_SIZES
suffix:semicolon
id|isize
op_increment
)paren
(brace
r_if
c_cond
(paren
id|isize1
op_ne
op_minus
l_int|1
op_logical_and
id|isize1
op_ne
id|isize
)paren
(brace
r_continue
suffix:semicolon
)brace
id|bh
op_assign
id|free_list
(braket
id|isize
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
r_continue
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|i
op_logical_or
id|bh
op_ne
id|free_list
(braket
id|isize
)braket
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_next_free
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_count
op_logical_or
op_logical_neg
id|bh-&gt;b_this_page
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|try_to_free
c_func
(paren
id|bh
comma
op_amp
id|bh
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Some interrupt must have used it after we&n;&t;&t;&t;&t;&t;  freed the page.  No big deal - keep looking */
)brace
)brace
multiline_comment|/* Not enough in the free lists, now try the lru list */
r_for
c_loop
(paren
id|nlist
op_assign
l_int|0
suffix:semicolon
id|nlist
OL
id|NR_LIST
suffix:semicolon
id|nlist
op_increment
)paren
(brace
id|repeat1
suffix:colon
r_if
c_cond
(paren
id|priority
OG
l_int|3
op_logical_and
id|nlist
op_eq
id|BUF_SHARED
)paren
(brace
r_continue
suffix:semicolon
)brace
id|bh
op_assign
id|lru_list
(braket
id|nlist
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
r_continue
suffix:semicolon
)brace
id|i
op_assign
id|nr_buffers_type
(braket
id|nlist
)braket
op_rshift
id|priority
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
op_decrement
OG
l_int|0
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_next_free
)paren
(brace
multiline_comment|/* We may have stalled while waiting for I/O to complete. */
r_if
c_cond
(paren
id|bh-&gt;b_list
op_ne
id|nlist
)paren
(brace
r_goto
id|repeat1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bh-&gt;b_count
op_logical_or
op_logical_neg
id|bh-&gt;b_this_page
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|size
op_logical_and
id|bh-&gt;b_size
op_ne
id|size
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bh-&gt;b_lock
)paren
r_if
c_cond
(paren
id|priority
)paren
r_continue
suffix:semicolon
r_else
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dirt
)paren
(brace
id|bh-&gt;b_count
op_increment
suffix:semicolon
id|bh-&gt;b_flushtime
op_assign
l_int|0
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITEA
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_count
op_decrement
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|try_to_free
c_func
(paren
id|bh
comma
op_amp
id|bh
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|show_buffers
r_void
id|show_buffers
c_func
(paren
r_void
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|found
op_assign
l_int|0
comma
id|locked
op_assign
l_int|0
comma
id|dirty
op_assign
l_int|0
comma
id|used
op_assign
l_int|0
comma
id|lastused
op_assign
l_int|0
suffix:semicolon
r_int
id|shared
suffix:semicolon
r_int
id|nlist
comma
id|isize
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Buffer memory:   %6dkB&bslash;n&quot;
comma
id|buffermem
op_rshift
l_int|10
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Buffer heads:    %6d&bslash;n&quot;
comma
id|nr_buffer_heads
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Buffer blocks:   %6d&bslash;n&quot;
comma
id|nr_buffers
)paren
suffix:semicolon
r_for
c_loop
(paren
id|nlist
op_assign
l_int|0
suffix:semicolon
id|nlist
OL
id|NR_LIST
suffix:semicolon
id|nlist
op_increment
)paren
(brace
id|shared
op_assign
id|found
op_assign
id|locked
op_assign
id|dirty
op_assign
id|used
op_assign
id|lastused
op_assign
l_int|0
suffix:semicolon
id|bh
op_assign
id|lru_list
(braket
id|nlist
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
r_continue
suffix:semicolon
)brace
r_do
(brace
id|found
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_lock
)paren
id|locked
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dirt
)paren
id|dirty
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mem_map
(braket
id|MAP_NR
c_func
(paren
(paren
(paren
r_int
r_int
)paren
id|bh-&gt;b_data
)paren
)paren
)braket
op_ne
l_int|1
)paren
(brace
id|shared
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bh-&gt;b_count
)paren
id|used
op_increment
comma
id|lastused
op_assign
id|found
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bh
op_ne
id|lru_list
(braket
id|nlist
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Buffer[%d] mem: %d buffers, %d used (last=%d), %d locked, %d dirty %d shrd&bslash;n&quot;
comma
id|nlist
comma
id|found
comma
id|used
comma
id|lastused
comma
id|locked
comma
id|dirty
comma
id|shared
)paren
suffix:semicolon
)brace
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Size    [LAV]     Free  Clean  Unshar     Lck    Lck1   Dirty  Shared&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|isize
op_assign
l_int|0
suffix:semicolon
id|isize
OL
id|NR_SIZES
suffix:semicolon
id|isize
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%5d [%5d]: %7d &quot;
comma
id|bufferindex_size
(braket
id|isize
)braket
comma
id|buffers_lav
(braket
id|isize
)braket
comma
id|nr_free
(braket
id|isize
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|nlist
op_assign
l_int|0
suffix:semicolon
id|nlist
OL
id|NR_LIST
suffix:semicolon
id|nlist
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%7d &quot;
comma
id|nr_buffers_st
(braket
id|isize
)braket
(braket
id|nlist
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * try_to_reassign() checks if all the buffers on this particular page&n; * are unused, and reassign to a new cluster them if this is true.&n; */
DECL|function|try_to_reassign
r_static
r_inline
r_int
id|try_to_reassign
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_struct
id|buffer_head
op_star
op_star
id|bhp
comma
id|dev_t
id|dev
comma
r_int
r_int
id|starting_block
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
r_struct
id|buffer_head
op_star
id|tmp
comma
op_star
id|p
suffix:semicolon
op_star
id|bhp
op_assign
id|bh
suffix:semicolon
id|page
op_assign
(paren
r_int
r_int
)paren
id|bh-&gt;b_data
suffix:semicolon
id|page
op_and_assign
id|PAGE_MASK
suffix:semicolon
r_if
c_cond
(paren
id|mem_map
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
op_ne
l_int|1
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|tmp
op_assign
id|bh
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tmp-&gt;b_count
op_logical_or
id|tmp-&gt;b_dirt
op_logical_or
id|tmp-&gt;b_lock
)paren
r_return
l_int|0
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
suffix:semicolon
id|tmp
op_assign
id|bh
suffix:semicolon
r_while
c_loop
(paren
(paren
r_int
r_int
)paren
id|tmp-&gt;b_data
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
(brace
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
)brace
multiline_comment|/* This is the buffer at the head of the page */
id|bh
op_assign
id|tmp
suffix:semicolon
r_do
(brace
id|p
op_assign
id|tmp
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;b_this_page
suffix:semicolon
id|remove_from_queues
c_func
(paren
id|p
)paren
suffix:semicolon
id|p-&gt;b_dev
op_assign
id|dev
suffix:semicolon
id|p-&gt;b_uptodate
op_assign
l_int|0
suffix:semicolon
id|p-&gt;b_req
op_assign
l_int|0
suffix:semicolon
id|p-&gt;b_blocknr
op_assign
id|starting_block
op_increment
suffix:semicolon
id|insert_into_queues
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
id|bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to find a free cluster by locating a page where&n; * all of the buffers are unused.  We would like this function&n; * to be atomic, so we do not call anything that might cause&n; * the process to sleep.  The priority is somewhat similar to&n; * the priority used in shrink_buffers.&n; * &n; * My thinking is that the kernel should end up using whole&n; * pages for the buffer cache as much of the time as possible.&n; * This way the other buffers on a particular page are likely&n; * to be very near each other on the free list, and we will not&n; * be expiring data prematurely.  For now we only cannibalize buffers&n; * of the same size to keep the code simpler.&n; */
DECL|function|reassign_cluster
r_static
r_int
id|reassign_cluster
c_func
(paren
id|dev_t
id|dev
comma
r_int
r_int
id|starting_block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|isize
op_assign
id|BUFSIZE_INDEX
c_func
(paren
id|size
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* We want to give ourselves a really good shot at generating&n;&t;   a cluster, and since we only take buffers from the free&n;&t;   list, we &quot;overfill&quot; it a little. */
r_while
c_loop
(paren
id|nr_free
(braket
id|isize
)braket
OL
l_int|32
)paren
(brace
id|refill_freelist
c_func
(paren
id|size
)paren
suffix:semicolon
)brace
id|bh
op_assign
id|free_list
(braket
id|isize
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|i
op_logical_or
id|bh
op_ne
id|free_list
(braket
id|isize
)braket
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_next_free
comma
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bh-&gt;b_this_page
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|try_to_reassign
c_func
(paren
id|bh
comma
op_amp
id|bh
comma
id|dev
comma
id|starting_block
)paren
)paren
r_return
l_int|4
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This function tries to generate a new cluster of buffers&n; * from a new page in memory.  We should only do this if we have&n; * not expanded the buffer cache to the maximum size that we allow.&n; */
DECL|function|try_to_generate_cluster
r_static
r_int
r_int
id|try_to_generate_cluster
c_func
(paren
id|dev_t
id|dev
comma
r_int
id|block
comma
r_int
id|size
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|tmp
comma
op_star
id|arr
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|isize
op_assign
id|BUFSIZE_INDEX
c_func
(paren
id|size
)paren
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
r_int
id|page
suffix:semicolon
r_int
id|nblock
suffix:semicolon
id|page
op_assign
id|get_free_page
c_func
(paren
id|GFP_NOBUFFER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|bh
op_assign
id|create_buffers
c_func
(paren
id|page
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
id|nblock
op_assign
id|block
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|offset
OL
id|PAGE_SIZE
suffix:semicolon
id|offset
op_add_assign
id|size
)paren
(brace
r_if
c_cond
(paren
id|find_buffer
c_func
(paren
id|dev
comma
id|nblock
op_increment
comma
id|size
)paren
)paren
r_goto
id|not_aligned
suffix:semicolon
)brace
id|tmp
op_assign
id|bh
suffix:semicolon
id|nblock
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|arr
(braket
id|nblock
op_increment
)braket
op_assign
id|bh
suffix:semicolon
id|bh-&gt;b_count
op_assign
l_int|1
suffix:semicolon
id|bh-&gt;b_dirt
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_flushtime
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_lock
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_uptodate
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_req
op_assign
l_int|0
suffix:semicolon
id|bh-&gt;b_dev
op_assign
id|dev
suffix:semicolon
id|bh-&gt;b_list
op_assign
id|BUF_CLEAN
suffix:semicolon
id|bh-&gt;b_blocknr
op_assign
id|block
op_increment
suffix:semicolon
id|nr_buffers
op_increment
suffix:semicolon
id|nr_buffers_size
(braket
id|isize
)braket
op_increment
suffix:semicolon
id|insert_into_queues
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_this_page
)paren
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
id|buffermem
op_add_assign
id|PAGE_SIZE
suffix:semicolon
id|buffer_pages
(braket
id|MAP_NR
c_func
(paren
id|page
)paren
)braket
op_assign
id|bh
suffix:semicolon
id|bh-&gt;b_this_page
op_assign
id|tmp
suffix:semicolon
r_while
c_loop
(paren
id|nblock
op_decrement
OG
l_int|0
)paren
id|brelse
c_func
(paren
id|arr
(braket
id|nblock
)braket
)paren
suffix:semicolon
r_return
l_int|4
suffix:semicolon
id|not_aligned
suffix:colon
r_while
c_loop
(paren
(paren
id|tmp
op_assign
id|bh
)paren
op_ne
l_int|NULL
)paren
(brace
id|bh
op_assign
id|bh-&gt;b_this_page
suffix:semicolon
id|put_unused_buffer_head
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|generate_cluster
r_int
r_int
id|generate_cluster
c_func
(paren
id|dev_t
id|dev
comma
r_int
id|b
(braket
)braket
comma
r_int
id|size
)paren
(brace
r_int
id|i
comma
id|offset
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|offset
op_assign
l_int|0
suffix:semicolon
id|offset
OL
id|PAGE_SIZE
suffix:semicolon
id|i
op_increment
comma
id|offset
op_add_assign
id|size
)paren
(brace
r_if
c_cond
(paren
id|i
op_logical_and
id|b
(braket
id|i
)braket
op_minus
l_int|1
op_ne
id|b
(braket
id|i
op_minus
l_int|1
)braket
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* No need to cluster */
r_if
c_cond
(paren
id|find_buffer
c_func
(paren
id|dev
comma
id|b
(braket
id|i
)braket
comma
id|size
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
suffix:semicolon
multiline_comment|/* OK, we have a candidate for a new cluster */
multiline_comment|/* See if one size of buffer is over-represented in the buffer cache,&n;&t;   if so reduce the numbers of buffers */
r_if
c_cond
(paren
id|maybe_shrink_lav_buffers
c_func
(paren
id|size
)paren
)paren
(brace
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|try_to_generate_cluster
c_func
(paren
id|dev
comma
id|b
(braket
l_int|0
)braket
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
r_return
id|retval
suffix:semicolon
)brace
)brace
suffix:semicolon
r_if
c_cond
(paren
id|nr_free_pages
OG
id|min_free_pages
)paren
r_return
id|try_to_generate_cluster
c_func
(paren
id|dev
comma
id|b
(braket
l_int|0
)braket
comma
id|size
)paren
suffix:semicolon
r_else
r_return
id|reassign_cluster
c_func
(paren
id|dev
comma
id|b
(braket
l_int|0
)braket
comma
id|size
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This initializes the initial buffer free list.  nr_buffers_type is set&n; * to one less the actual number of buffers, as a sop to backwards&n; * compatibility --- the old code did this (I think unintentionally,&n; * but I&squot;m not sure), and programs in the ps package expect it.&n; * &t;&t;&t;&t;&t;- TYT 8/30/92&n; */
DECL|function|buffer_init
r_void
id|buffer_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|isize
op_assign
id|BUFSIZE_INDEX
c_func
(paren
id|BLOCK_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|high_memory
op_ge
l_int|4
op_star
l_int|1024
op_star
l_int|1024
)paren
(brace
id|min_free_pages
op_assign
l_int|200
suffix:semicolon
r_if
c_cond
(paren
id|high_memory
op_ge
l_int|16
op_star
l_int|1024
op_star
l_int|1024
)paren
(brace
id|nr_hash
op_assign
l_int|16381
suffix:semicolon
)brace
r_else
id|nr_hash
op_assign
l_int|4093
suffix:semicolon
)brace
r_else
(brace
id|min_free_pages
op_assign
l_int|20
suffix:semicolon
id|nr_hash
op_assign
l_int|997
suffix:semicolon
)brace
suffix:semicolon
id|hash_table
op_assign
(paren
r_struct
id|buffer_head
op_star
op_star
)paren
id|vmalloc
c_func
(paren
id|nr_hash
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
)paren
suffix:semicolon
id|buffer_pages
op_assign
(paren
r_struct
id|buffer_head
op_star
op_star
)paren
id|vmalloc
c_func
(paren
id|MAP_NR
c_func
(paren
id|high_memory
)paren
op_star
r_sizeof
(paren
r_struct
id|buffer_head
op_star
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAP_NR
c_func
(paren
id|high_memory
)paren
suffix:semicolon
id|i
op_increment
)paren
id|buffer_pages
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_hash
suffix:semicolon
id|i
op_increment
)paren
id|hash_table
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|lru_list
(braket
id|BUF_CLEAN
)braket
op_assign
l_int|0
suffix:semicolon
id|grow_buffers
c_func
(paren
id|GFP_KERNEL
comma
id|BLOCK_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|free_list
(braket
id|isize
)braket
)paren
id|panic
c_func
(paren
l_string|&quot;VFS: Unable to initialize buffer free list!&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* This is a simple kernel daemon, whose job it is to provide a dynamically&n; * response to dirty buffers.  Once this process is activated, we write back&n; * a limited number of buffers to the disks and then go back to sleep again.&n; * In effect this is a process which never leaves kernel mode, and does not have&n; * any user memory associated with it except for the stack.  There is also&n; * a kernel stack page, which obviously must be separate from the user stack.&n; */
DECL|variable|bdflush_wait
r_struct
id|wait_queue
op_star
id|bdflush_wait
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|bdflush_done
r_struct
id|wait_queue
op_star
id|bdflush_done
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|bdflush_running
r_static
r_int
id|bdflush_running
op_assign
l_int|0
suffix:semicolon
DECL|function|wakeup_bdflush
r_static
r_void
id|wakeup_bdflush
c_func
(paren
r_int
id|wait
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bdflush_running
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning - bdflush not running&bslash;n&quot;
)paren
suffix:semicolon
id|sync_buffers
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|bdflush_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|bdflush_done
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* &n; * Here we attempt to write back old buffers.  We also try and flush inodes &n; * and supers as well, since this function is essentially &quot;update&quot;, and &n; * otherwise there would be no way of ensuring that these quantities ever &n; * get written back.  Ideally, we would have a timestamp on the inodes&n; * and superblocks so that we could write back only the old ones as well&n; */
DECL|function|sync_old_buffers
id|asmlinkage
r_int
id|sync_old_buffers
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|isize
suffix:semicolon
r_int
id|ndirty
comma
id|nwritten
suffix:semicolon
r_int
id|nlist
suffix:semicolon
r_int
id|ncount
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|next
suffix:semicolon
id|sync_supers
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|sync_inodes
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|ncount
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
r_for
c_loop
(paren
id|nlist
op_assign
l_int|0
suffix:semicolon
id|nlist
OL
id|NR_LIST
suffix:semicolon
id|nlist
op_increment
)paren
macro_line|#else
r_for
c_loop
(paren
id|nlist
op_assign
id|BUF_DIRTY
suffix:semicolon
id|nlist
op_le
id|BUF_DIRTY
suffix:semicolon
id|nlist
op_increment
)paren
macro_line|#endif
(brace
id|ndirty
op_assign
l_int|0
suffix:semicolon
id|nwritten
op_assign
l_int|0
suffix:semicolon
id|repeat
suffix:colon
id|bh
op_assign
id|lru_list
(braket
id|nlist
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
r_for
c_loop
(paren
id|i
op_assign
id|nr_buffers_type
(braket
id|nlist
)braket
suffix:semicolon
id|i
op_decrement
OG
l_int|0
suffix:semicolon
id|bh
op_assign
id|next
)paren
(brace
multiline_comment|/* We may have stalled while waiting for I/O to complete. */
r_if
c_cond
(paren
id|bh-&gt;b_list
op_ne
id|nlist
)paren
(brace
r_goto
id|repeat
suffix:semicolon
)brace
id|next
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lru_list
(braket
id|nlist
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Dirty list empty %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Clean buffer on dirty list?  Refile it */
r_if
c_cond
(paren
id|nlist
op_eq
id|BUF_DIRTY
op_logical_and
op_logical_neg
id|bh-&gt;b_dirt
op_logical_and
op_logical_neg
id|bh-&gt;b_lock
)paren
(brace
id|refile_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bh-&gt;b_lock
op_logical_or
op_logical_neg
id|bh-&gt;b_dirt
)paren
r_continue
suffix:semicolon
id|ndirty
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_flushtime
OG
id|jiffies
)paren
(brace
r_continue
suffix:semicolon
)brace
id|nwritten
op_increment
suffix:semicolon
id|bh-&gt;b_count
op_increment
suffix:semicolon
id|bh-&gt;b_flushtime
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|nlist
op_ne
id|BUF_DIRTY
)paren
(brace
id|ncount
op_increment
suffix:semicolon
)brace
macro_line|#endif
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|bh-&gt;b_count
op_decrement
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|ncount
)paren
id|printk
c_func
(paren
l_string|&quot;sync_old_buffers: %d dirty buffers not on dirty list&bslash;n&quot;
comma
id|ncount
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Wrote %d/%d buffers&bslash;n&quot;
comma
id|nwritten
comma
id|ndirty
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* We assume that we only come through here on a regular&n;&t;   schedule, like every 5 seconds.  Now update load averages.  &n;&t;   Shift usage counts to prevent overflow. */
r_for
c_loop
(paren
id|isize
op_assign
l_int|0
suffix:semicolon
id|isize
OL
id|NR_SIZES
suffix:semicolon
id|isize
op_increment
)paren
(brace
id|CALC_LOAD
c_func
(paren
id|buffers_lav
(braket
id|isize
)braket
comma
id|bdf_prm.b_un.lav_const
comma
id|buffer_usage
(braket
id|isize
)braket
)paren
suffix:semicolon
id|buffer_usage
(braket
id|isize
)braket
op_assign
l_int|0
suffix:semicolon
)brace
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is the interface to bdflush.  As we get more sophisticated, we can&n; * pass tuning parameters to this &quot;process&quot;, to adjust how it behaves.  If you&n; * invoke this again after you have done this once, you would simply modify &n; * the tuning parameters.  We would want to verify each parameter, however,&n; * to make sure that it is reasonable. */
DECL|function|sys_bdflush
id|asmlinkage
r_int
id|sys_bdflush
c_func
(paren
r_int
id|func
comma
r_int
id|data
)paren
(brace
r_int
id|i
comma
id|error
suffix:semicolon
r_int
id|ndirty
suffix:semicolon
r_int
id|nlist
suffix:semicolon
r_int
id|ncount
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
comma
op_star
id|next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|func
op_eq
l_int|1
)paren
r_return
id|sync_old_buffers
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Basically func 0 means start, 1 means read param 1, 2 means write param 1, etc */
r_if
c_cond
(paren
id|func
op_ge
l_int|2
)paren
(brace
id|i
op_assign
(paren
id|func
op_minus
l_int|2
)paren
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
op_logical_or
id|i
op_ge
id|N_PARAM
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|func
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|data
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|put_fs_long
c_func
(paren
id|bdf_prm.data
(braket
id|i
)braket
comma
id|data
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|data
template_param
id|bdflush_max
(braket
id|i
)braket
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|bdf_prm.data
(braket
id|i
)braket
op_assign
id|data
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|bdflush_running
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* Only one copy of this running at one time */
id|bdflush_running
op_increment
suffix:semicolon
multiline_comment|/* OK, from here on is the daemon */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;bdflush() activated...&quot;
)paren
suffix:semicolon
macro_line|#endif
id|ncount
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
r_for
c_loop
(paren
id|nlist
op_assign
l_int|0
suffix:semicolon
id|nlist
OL
id|NR_LIST
suffix:semicolon
id|nlist
op_increment
)paren
macro_line|#else
r_for
c_loop
(paren
id|nlist
op_assign
id|BUF_DIRTY
suffix:semicolon
id|nlist
op_le
id|BUF_DIRTY
suffix:semicolon
id|nlist
op_increment
)paren
macro_line|#endif
(brace
id|ndirty
op_assign
l_int|0
suffix:semicolon
id|repeat
suffix:colon
id|bh
op_assign
id|lru_list
(braket
id|nlist
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
r_for
c_loop
(paren
id|i
op_assign
id|nr_buffers_type
(braket
id|nlist
)braket
suffix:semicolon
id|i
op_decrement
OG
l_int|0
op_logical_and
id|ndirty
OL
id|bdf_prm.b_un.ndirty
suffix:semicolon
id|bh
op_assign
id|next
)paren
(brace
multiline_comment|/* We may have stalled while waiting for I/O to complete. */
r_if
c_cond
(paren
id|bh-&gt;b_list
op_ne
id|nlist
)paren
(brace
r_goto
id|repeat
suffix:semicolon
)brace
id|next
op_assign
id|bh-&gt;b_next_free
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lru_list
(braket
id|nlist
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Dirty list empty %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Clean buffer on dirty list?  Refile it */
r_if
c_cond
(paren
id|nlist
op_eq
id|BUF_DIRTY
op_logical_and
op_logical_neg
id|bh-&gt;b_dirt
op_logical_and
op_logical_neg
id|bh-&gt;b_lock
)paren
(brace
id|refile_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bh-&gt;b_lock
op_logical_or
op_logical_neg
id|bh-&gt;b_dirt
)paren
r_continue
suffix:semicolon
multiline_comment|/* Should we write back buffers that are shared or not??&n;&t;&t;&t;&t;&t;     currently dirty buffers are not shared, so it does not matter */
id|bh-&gt;b_count
op_increment
suffix:semicolon
id|ndirty
op_increment
suffix:semicolon
id|bh-&gt;b_flushtime
op_assign
l_int|0
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|nlist
op_ne
id|BUF_DIRTY
)paren
(brace
id|ncount
op_increment
suffix:semicolon
)brace
macro_line|#endif
id|bh-&gt;b_count
op_decrement
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|ncount
)paren
id|printk
c_func
(paren
l_string|&quot;sys_bdflush: %d dirty buffers not on dirty list&bslash;n&quot;
comma
id|ncount
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sleeping again.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|wake_up
c_func
(paren
op_amp
id|bdflush_done
)paren
suffix:semicolon
multiline_comment|/* If there are still a lot of dirty buffers around, skip the sleep&n;&t;&t;   and flush some more */
r_if
c_cond
(paren
id|nr_buffers_type
(braket
id|BUF_DIRTY
)braket
OL
(paren
id|nr_buffers
op_minus
id|nr_buffers_type
(braket
id|BUF_SHARED
)braket
)paren
op_star
id|bdf_prm.b_un.nfract
op_div
l_int|100
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
(paren
l_int|1
op_lshift
(paren
id|SIGKILL
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|bdflush_running
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|current-&gt;signal
op_assign
l_int|0
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|bdflush_wait
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 8&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -8&n; * c-argdecl-indent: 8&n; * c-label-offset: -8&n; * c-continued-statement-offset: 8&n; * c-continued-brace-offset: 0&n; * End:&n; */
eof
