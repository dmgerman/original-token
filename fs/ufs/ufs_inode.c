multiline_comment|/*&n; *  linux/fs/ufs/ufs_inode.c&n; *&n; * Copyright (C) 1996&n; * Adrian Rodriguez (adrian@franklins-tower.rutgers.edu)&n; * Laboratory for Computer Science Research Computing Facility&n; * Rutgers, The State University of New Jersey&n; *&n; * Clean swab support on 19970406&n; * by Francois-Rene Rideau &lt;rideau@ens.fr&gt;&n; *&n; * 4.4BSD (FreeBSD) support added on February 1st 1998 by&n; * Niels Kristian Bech Jensen &lt;nkbj@image.dk&gt; partially based&n; * on code by Martin von Loewis &lt;martin@mira.isdn.cs.tu-berlin.de&gt;.&n; *&n; * NeXTstep support added on February 5th 1998 by&n; * Niels Kristian Bech Jensen &lt;nkbj@image.dk&gt;.&n; */
DECL|macro|DEBUG_UFS_INODE
macro_line|#undef DEBUG_UFS_INODE
multiline_comment|/*#define DEBUG_UFS_INODE 1*/
multiline_comment|/* Uncomment the line above when hacking ufs inode code */
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/ufs_fs.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &quot;ufs_swab.h&quot;
DECL|function|ufs_print_inode
r_void
id|ufs_print_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ino %lu  mode 0%6.6o  lk %d  uid %d  gid %d&quot;
l_string|&quot;  sz %lu  blks %lu  cnt %u&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|inode-&gt;i_mode
comma
id|inode-&gt;i_nlink
comma
id|inode-&gt;i_uid
comma
id|inode-&gt;i_gid
comma
id|inode-&gt;i_size
comma
id|inode-&gt;i_blocks
comma
id|inode-&gt;i_count
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  db &lt;0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x&quot;
l_string|&quot; 0x%x 0x%x 0x%x 0x%x&gt;&bslash;n&quot;
comma
id|inode-&gt;u.ufs_i.i_u1.i_data
(braket
l_int|0
)braket
comma
id|inode-&gt;u.ufs_i.i_u1.i_data
(braket
l_int|1
)braket
comma
id|inode-&gt;u.ufs_i.i_u1.i_data
(braket
l_int|2
)braket
comma
id|inode-&gt;u.ufs_i.i_u1.i_data
(braket
l_int|3
)braket
comma
id|inode-&gt;u.ufs_i.i_u1.i_data
(braket
l_int|4
)braket
comma
id|inode-&gt;u.ufs_i.i_u1.i_data
(braket
l_int|5
)braket
comma
id|inode-&gt;u.ufs_i.i_u1.i_data
(braket
l_int|6
)braket
comma
id|inode-&gt;u.ufs_i.i_u1.i_data
(braket
l_int|7
)braket
comma
id|inode-&gt;u.ufs_i.i_u1.i_data
(braket
l_int|8
)braket
comma
id|inode-&gt;u.ufs_i.i_u1.i_data
(braket
l_int|9
)braket
comma
id|inode-&gt;u.ufs_i.i_u1.i_data
(braket
l_int|10
)braket
comma
id|inode-&gt;u.ufs_i.i_u1.i_data
(braket
l_int|11
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  gen 0x%8.8x ib &lt;0x%x 0x%x 0x%x&gt;&bslash;n&quot;
comma
id|inode-&gt;u.ufs_i.i_gen
comma
id|inode-&gt;u.ufs_i.i_u1.i_data
(braket
id|UFS_IND_BLOCK
)braket
comma
id|inode-&gt;u.ufs_i.i_u1.i_data
(braket
id|UFS_DIND_BLOCK
)braket
comma
id|inode-&gt;u.ufs_i.i_u1.i_data
(braket
id|UFS_TIND_BLOCK
)braket
)paren
suffix:semicolon
)brace
DECL|macro|inode_bmap
mdefine_line|#define inode_bmap(inode, nr) ((inode)-&gt;u.ufs_i.i_u1.i_data[(nr)])
DECL|function|block_bmap
r_static
r_inline
r_int
id|block_bmap
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|block
comma
r_int
id|nr
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|__u32
id|flags
op_assign
id|inode-&gt;i_sb-&gt;u.ufs_sb.s_flags
suffix:semicolon
multiline_comment|/* XXX Split in fsize big blocks (Can&squot;t bread 8Kb). */
id|tmp
op_assign
id|nr
op_rshift
(paren
id|inode-&gt;i_sb-&gt;u.ufs_sb.s_fshift
op_minus
l_int|2
)paren
suffix:semicolon
id|bh
op_assign
id|bread
(paren
id|inode-&gt;i_dev
comma
id|inode-&gt;i_sb-&gt;u.ufs_sb.s_blockbase
op_plus
id|block
op_plus
id|tmp
comma
id|inode-&gt;i_sb-&gt;s_blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_return
l_int|0
suffix:semicolon
id|nr
op_and_assign
op_complement
(paren
id|inode-&gt;i_sb-&gt;u.ufs_sb.s_fmask
)paren
op_rshift
l_int|2
suffix:semicolon
id|tmp
op_assign
id|SWAB32
c_func
(paren
(paren
(paren
id|__u32
op_star
)paren
id|bh-&gt;b_data
)paren
(braket
id|nr
)braket
)paren
suffix:semicolon
id|brelse
(paren
id|bh
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
DECL|function|ufs_bmap
r_int
id|ufs_bmap
(paren
r_struct
id|inode
op_star
id|inode
comma
r_int
id|block
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|addr_per_block
op_assign
id|UFS_ADDR_PER_BLOCK
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_int
id|addr_per_block_bits
op_assign
id|UFS_ADDR_PER_BLOCK_BITS
c_func
(paren
id|inode-&gt;i_sb
)paren
suffix:semicolon
r_int
id|lbn
op_assign
id|ufs_lbn
(paren
id|inode-&gt;i_sb
comma
id|block
)paren
suffix:semicolon
r_int
id|boff
op_assign
id|ufs_boff
(paren
id|inode-&gt;i_sb
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lbn
OL
l_int|0
)paren
(brace
id|ufs_warning
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;ufs_bmap&quot;
comma
l_string|&quot;block &lt; 0&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lbn
op_ge
id|UFS_NDADDR
op_plus
id|addr_per_block
op_plus
(paren
l_int|1
op_lshift
(paren
id|addr_per_block_bits
op_star
l_int|2
)paren
)paren
op_plus
(paren
(paren
l_int|1
op_lshift
(paren
id|addr_per_block_bits
op_star
l_int|2
)paren
)paren
op_lshift
id|addr_per_block_bits
)paren
)paren
(brace
id|ufs_warning
(paren
id|inode-&gt;i_sb
comma
l_string|&quot;ufs_bmap&quot;
comma
l_string|&quot;block &gt; big&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lbn
OL
id|UFS_NDADDR
)paren
r_return
(paren
id|inode-&gt;i_sb-&gt;u.ufs_sb.s_blockbase
op_plus
id|ufs_dbn
(paren
id|inode-&gt;i_sb
comma
id|inode_bmap
(paren
id|inode
comma
id|lbn
)paren
comma
id|boff
)paren
)paren
suffix:semicolon
id|lbn
op_sub_assign
id|UFS_NDADDR
suffix:semicolon
r_if
c_cond
(paren
id|lbn
OL
id|addr_per_block
)paren
(brace
id|i
op_assign
id|inode_bmap
(paren
id|inode
comma
id|UFS_IND_BLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
id|inode-&gt;i_sb-&gt;u.ufs_sb.s_blockbase
op_plus
id|ufs_dbn
(paren
id|inode-&gt;i_sb
comma
id|block_bmap
(paren
id|inode
comma
id|i
comma
id|lbn
)paren
comma
id|boff
)paren
)paren
suffix:semicolon
)brace
id|lbn
op_sub_assign
id|addr_per_block
suffix:semicolon
r_if
c_cond
(paren
id|lbn
OL
(paren
l_int|1
op_lshift
(paren
id|addr_per_block_bits
op_star
l_int|2
)paren
)paren
)paren
(brace
id|i
op_assign
id|inode_bmap
(paren
id|inode
comma
id|UFS_DIND_BLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
r_return
l_int|0
suffix:semicolon
id|i
op_assign
id|block_bmap
(paren
id|inode
comma
id|i
comma
id|lbn
op_rshift
id|addr_per_block_bits
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
id|inode-&gt;i_sb-&gt;u.ufs_sb.s_blockbase
op_plus
id|ufs_dbn
(paren
id|inode-&gt;i_sb
comma
id|block_bmap
(paren
id|inode
comma
id|i
comma
id|lbn
op_amp
(paren
id|addr_per_block
op_minus
l_int|1
)paren
)paren
comma
id|boff
)paren
)paren
suffix:semicolon
)brace
id|lbn
op_sub_assign
(paren
l_int|1
op_lshift
(paren
id|addr_per_block_bits
op_star
l_int|2
)paren
)paren
suffix:semicolon
id|i
op_assign
id|inode_bmap
(paren
id|inode
comma
id|UFS_TIND_BLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
r_return
l_int|0
suffix:semicolon
id|i
op_assign
id|block_bmap
(paren
id|inode
comma
id|i
comma
id|lbn
op_rshift
(paren
id|addr_per_block_bits
op_star
l_int|2
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
r_return
l_int|0
suffix:semicolon
id|i
op_assign
id|block_bmap
(paren
id|inode
comma
id|i
comma
(paren
id|lbn
op_rshift
id|addr_per_block_bits
)paren
op_amp
(paren
id|addr_per_block
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
r_return
l_int|0
suffix:semicolon
r_return
(paren
id|inode-&gt;i_sb-&gt;u.ufs_sb.s_blockbase
op_plus
id|ufs_dbn
(paren
id|inode-&gt;i_sb
comma
id|block_bmap
(paren
id|inode
comma
id|i
comma
id|lbn
op_amp
(paren
id|addr_per_block
op_minus
l_int|1
)paren
)paren
comma
id|boff
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* XXX - ufs_read_inode is a mess */
DECL|function|ufs_read_inode
r_void
id|ufs_read_inode
c_func
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
r_struct
id|ufs_inode
op_star
id|ufsip
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|__u32
id|flags
op_assign
id|inode-&gt;i_sb-&gt;u.ufs_sb.s_flags
suffix:semicolon
id|sb
op_assign
id|inode-&gt;i_sb
suffix:semicolon
r_if
c_cond
(paren
id|ufs_ino_ok
c_func
(paren
id|inode
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ufs_read_inode: bad inum %lu&bslash;n&quot;
comma
id|inode-&gt;i_ino
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_UFS_INODE
id|printk
c_func
(paren
l_string|&quot;ufs_read_inode: ino %lu  cg %u  cgino %u  ipg %u  inopb %u&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|ufs_ino2cg
c_func
(paren
id|inode
)paren
comma
(paren
id|inode-&gt;i_ino
op_mod
id|sb-&gt;u.ufs_sb.s_inopb
)paren
comma
id|sb-&gt;u.ufs_sb.s_ipg
comma
id|sb-&gt;u.ufs_sb.s_inopb
)paren
suffix:semicolon
macro_line|#endif
id|bh
op_assign
id|bread
c_func
(paren
id|inode-&gt;i_dev
comma
id|inode-&gt;i_sb-&gt;u.ufs_sb.s_blockbase
op_plus
id|ufs_cgimin
c_func
(paren
id|inode-&gt;i_sb
comma
id|ufs_ino2cg
c_func
(paren
id|inode
)paren
)paren
op_plus
(paren
id|inode-&gt;i_ino
op_mod
id|sb-&gt;u.ufs_sb.s_ipg
)paren
op_div
(paren
id|sb-&gt;u.ufs_sb.s_inopb
op_div
id|sb-&gt;u.ufs_sb.s_fsfrag
)paren
comma
id|sb-&gt;s_blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ufs_read_inode: can&squot;t read inode %lu from dev %d/%d&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|MAJOR
c_func
(paren
id|inode-&gt;i_dev
)paren
comma
id|MINOR
c_func
(paren
id|inode-&gt;i_dev
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ufsip
op_assign
(paren
r_struct
id|ufs_inode
op_star
)paren
id|bh-&gt;b_data
suffix:semicolon
id|ufsip
op_add_assign
(paren
id|inode-&gt;i_ino
op_mod
(paren
id|sb-&gt;u.ufs_sb.s_inopb
op_div
id|sb-&gt;u.ufs_sb.s_fsfrag
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Copy data to the in-core inode.&n;&t; */
id|inode-&gt;i_mode
op_assign
id|SWAB16
c_func
(paren
id|ufsip-&gt;ui_mode
)paren
suffix:semicolon
id|inode-&gt;i_nlink
op_assign
id|SWAB16
c_func
(paren
id|ufsip-&gt;ui_nlink
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_nlink
op_eq
l_int|0
)paren
(brace
multiline_comment|/* XXX */
id|printk
c_func
(paren
l_string|&quot;ufs_read_inode: zero nlink ino %lu  dev %u/%u&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|MAJOR
c_func
(paren
id|inode-&gt;i_dev
)paren
comma
id|MINOR
c_func
(paren
id|inode-&gt;i_dev
)paren
)paren
suffix:semicolon
id|inode-&gt;i_nlink
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ufs_read_inode: fishy ino %lu pblk %lu dev %u/%u&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|ufs_cgimin
c_func
(paren
id|inode-&gt;i_sb
comma
id|ufs_ino2cg
c_func
(paren
id|inode
)paren
)paren
op_plus
(paren
id|inode-&gt;i_ino
op_mod
id|sb-&gt;u.ufs_sb.s_ipg
)paren
op_div
id|sb-&gt;u.ufs_sb.s_inopb
comma
id|MAJOR
c_func
(paren
id|inode-&gt;i_dev
)paren
comma
id|MINOR
c_func
(paren
id|inode-&gt;i_dev
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* XXX - debugging */
r_if
c_cond
(paren
id|SWAB32
c_func
(paren
id|ufsip-&gt;ui_gen
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ufs_read_inode: zero gen ino %lu pblk %lu dev %u/%u&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|ufs_cgimin
c_func
(paren
id|inode-&gt;i_sb
comma
id|ufs_ino2cg
c_func
(paren
id|inode
)paren
)paren
op_plus
(paren
id|inode-&gt;i_ino
op_mod
id|sb-&gt;u.ufs_sb.s_ipg
)paren
op_div
id|sb-&gt;u.ufs_sb.s_inopb
comma
id|MAJOR
c_func
(paren
id|inode-&gt;i_dev
)paren
comma
id|MINOR
c_func
(paren
id|inode-&gt;i_dev
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Since Linux currently only has 16-bit uid_t and gid_t, we can&squot;t&n;&t; * really support EFTs.  For the moment, we use 0 as the uid and gid&n;&t; * if an inode has a uid or gid that won&squot;t fit in 16 bits.  This way&n;&t; * random users can&squot;t get at these files, since they get dynamically&n;&t; * &quot;chown()ed&quot; to root.&n;&t; */
r_if
c_cond
(paren
id|UFS_UID
c_func
(paren
id|ufsip
)paren
op_ge
id|UFS_USEEFT
)paren
(brace
id|inode-&gt;i_uid
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ufs_read_inode: EFT uid %u ino %lu dev %u/%u, using %u&bslash;n&quot;
comma
id|UFS_UID
c_func
(paren
id|ufsip
)paren
comma
id|inode-&gt;i_ino
comma
id|MAJOR
c_func
(paren
id|inode-&gt;i_dev
)paren
comma
id|MINOR
c_func
(paren
id|inode-&gt;i_dev
)paren
comma
id|inode-&gt;i_uid
)paren
suffix:semicolon
)brace
r_else
(brace
id|inode-&gt;i_uid
op_assign
id|UFS_UID
c_func
(paren
id|ufsip
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|UFS_GID
c_func
(paren
id|ufsip
)paren
op_ge
id|UFS_USEEFT
)paren
(brace
id|inode-&gt;i_gid
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ufs_read_inode: EFT gid %u ino %lu dev %u/%u, using %u&bslash;n&quot;
comma
id|UFS_GID
c_func
(paren
id|ufsip
)paren
comma
id|inode-&gt;i_ino
comma
id|MAJOR
c_func
(paren
id|inode-&gt;i_dev
)paren
comma
id|MINOR
c_func
(paren
id|inode-&gt;i_dev
)paren
comma
id|inode-&gt;i_gid
)paren
suffix:semicolon
)brace
r_else
(brace
id|inode-&gt;i_gid
op_assign
id|UFS_GID
c_func
(paren
id|ufsip
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Linux i_size is 32 bits on most architectures,&n;&t; * so some files on a UFS filesystem may not&n;&t; * be readable.  I let people access the first 32 bits worth of them.&n;&t; * for the rw code, we may want to mark these inodes as read-only.&n;&t; * XXX - bug Linus to make i_size a __u64 instead of a __u32.&n;&t; */
id|inode-&gt;u.ufs_i.i_size
op_assign
id|SWAB64
c_func
(paren
id|ufsip-&gt;ui_size
)paren
suffix:semicolon
multiline_comment|/* KRR - Just type cast inode-&gt;u.ufs_i.i_size into off_t and&n;&t; * worry about overflow later&n;         */
id|inode-&gt;i_size
op_assign
(paren
id|off_t
)paren
id|inode-&gt;u.ufs_i.i_size
suffix:semicolon
multiline_comment|/*&n;&t; * Linux doesn&squot;t keep tv_usec around in the kernel, so we discard it.&n;&t; * XXX - I&squot;m not sure what I should do about writing things.  I may&n;&t; * want to keep this data, but for the moment I think I&squot;ll just write&n;&t; * zeros for these fields when writing out inodes.&n;&t; */
id|inode-&gt;i_atime
op_assign
id|SWAB32
c_func
(paren
id|ufsip-&gt;ui_atime.tv_sec
)paren
suffix:semicolon
id|inode-&gt;i_mtime
op_assign
id|SWAB32
c_func
(paren
id|ufsip-&gt;ui_mtime.tv_sec
)paren
suffix:semicolon
id|inode-&gt;i_ctime
op_assign
id|SWAB32
c_func
(paren
id|ufsip-&gt;ui_ctime.tv_sec
)paren
suffix:semicolon
id|inode-&gt;i_blksize
op_assign
id|sb-&gt;u.ufs_sb.s_fsize
suffix:semicolon
id|inode-&gt;i_blocks
op_assign
id|SWAB32
c_func
(paren
id|ufsip-&gt;ui_blocks
)paren
suffix:semicolon
id|inode-&gt;i_version
op_assign
op_increment
id|event
suffix:semicolon
multiline_comment|/* see linux/kernel/sched.c */
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|ufs_file_inode_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|ufs_dir_inode_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISLNK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|ufs_symlink_inode_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|chrdev_inode_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|inode-&gt;i_op
op_assign
op_amp
id|blkdev_inode_operations
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|S_ISFIFO
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|init_fifo
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;ufs_read_inode: unknown file type 0%o ino %lu dev %d/%d&bslash;n&quot;
comma
id|inode-&gt;i_mode
comma
id|inode-&gt;i_ino
comma
id|MAJOR
c_func
(paren
id|inode-&gt;i_dev
)paren
comma
id|MINOR
c_func
(paren
id|inode-&gt;i_dev
)paren
)paren
suffix:semicolon
multiline_comment|/* XXX - debugging */
id|ufs_print_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|inode-&gt;i_op
op_assign
op_amp
id|ufs_file_inode_operations
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * ufs_read_super makes sure that UFS_NDADDR and UFS_NINDIR are sane.&n;&t; */
r_if
c_cond
(paren
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISDIR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISLNK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_blocks
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|UFS_NDADDR
suffix:semicolon
id|i
op_increment
)paren
(brace
id|inode-&gt;u.ufs_i.i_u1.i_data
(braket
id|i
)braket
op_assign
id|SWAB32
c_func
(paren
id|ufsip-&gt;ui_u2.ui_addr.ui_db
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|UFS_NINDIR
suffix:semicolon
id|i
op_increment
)paren
(brace
id|inode-&gt;u.ufs_i.i_u1.i_data
(braket
id|UFS_IND_BLOCK
op_plus
id|i
)braket
op_assign
id|SWAB32
c_func
(paren
id|ufsip-&gt;ui_u2.ui_addr.ui_ib
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* fast symlink */
(brace
id|memcpy
c_func
(paren
id|inode-&gt;u.ufs_i.i_u1.i_symlink
comma
id|ufsip-&gt;ui_u2.ui_symlink
comma
l_int|60
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* KRR - I need to check the SunOS header files, but for the time&n;&t; * being, I&squot;m going to tread ui_db[0] and [1] as a __u64 and swab&n;&t; * them appropriately.  This should clean up any real endian problems,&n;&t; * but we&squot;ll still need to add size checks in the write portion of&n;&t; * the code.&n;&t; */
r_if
c_cond
(paren
id|S_ISCHR
c_func
(paren
id|inode-&gt;i_mode
)paren
op_logical_or
id|S_ISBLK
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|inode-&gt;i_rdev
op_assign
(paren
id|kdev_t
)paren
id|SWAB64
c_func
(paren
op_star
(paren
id|__u64
op_star
)paren
op_amp
id|ufsip-&gt;ui_u2.ui_addr.ui_db
)paren
suffix:semicolon
)brace
id|inode-&gt;u.ufs_i.i_flags
op_assign
id|SWAB32
c_func
(paren
id|ufsip-&gt;ui_flags
)paren
suffix:semicolon
id|inode-&gt;u.ufs_i.i_gen
op_assign
id|SWAB32
c_func
(paren
id|ufsip-&gt;ui_gen
)paren
suffix:semicolon
multiline_comment|/* XXX - is this i_version? */
id|inode-&gt;u.ufs_i.i_shadow
op_assign
id|SWAB32
c_func
(paren
id|ufsip-&gt;ui_u3.ui_sun.ui_shadow
)paren
suffix:semicolon
multiline_comment|/* XXX */
id|inode-&gt;u.ufs_i.i_uid
op_assign
id|SWAB32
c_func
(paren
id|ufsip-&gt;ui_u3.ui_sun.ui_uid
)paren
suffix:semicolon
id|inode-&gt;u.ufs_i.i_gid
op_assign
id|SWAB32
c_func
(paren
id|ufsip-&gt;ui_u3.ui_sun.ui_gid
)paren
suffix:semicolon
id|inode-&gt;u.ufs_i.i_oeftflag
op_assign
id|SWAB32
c_func
(paren
id|ufsip-&gt;ui_u3.ui_sun.ui_oeftflag
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inode-&gt;i_sb-&gt;u.ufs_sb.s_flags
op_amp
(paren
id|UFS_DEBUG
op_or
id|UFS_DEBUG_INODE
)paren
)paren
(brace
id|ufs_print_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|ufs_put_inode
r_void
id|ufs_put_inode
(paren
r_struct
id|inode
op_star
id|inode
)paren
(brace
r_if
c_cond
(paren
id|inode-&gt;i_sb-&gt;u.ufs_sb.s_flags
op_amp
(paren
id|UFS_DEBUG
op_or
id|UFS_DEBUG_INODE
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ufs_put_inode:&bslash;n&quot;
)paren
suffix:semicolon
id|ufs_print_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inode-&gt;i_nlink
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ufs_put_inode: nlink == 0 for inum %lu on dev %d/%d&bslash;n&quot;
comma
id|inode-&gt;i_ino
comma
id|MAJOR
c_func
(paren
id|inode-&gt;i_dev
)paren
comma
id|MINOR
c_func
(paren
id|inode-&gt;i_dev
)paren
)paren
suffix:semicolon
id|ufs_print_inode
c_func
(paren
id|inode
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;ufs_put_inode: fs is read only, and nlink == 0&quot;
)paren
suffix:semicolon
multiline_comment|/* XXX - this code goes here eventually&n;&t;inode-&gt;i_size = 0;&n;&t;if (inode-&gt;i_blocks)&n;&t;        ufs_truncate(inode);&n;&t;ufs_free_inode(inode);&n;&t;*/
r_return
suffix:semicolon
)brace
eof
