multiline_comment|/*&n; *  linux/fs/ufs/swab.h&n; *&n; * Copyright (C) 1997, 1998 Francois-Rene Rideau &lt;fare@tunes.org&gt;&n; * Copyright (C) 1998 Jakub Jelinek &lt;jj@ultra.linux.cz&gt;&n; */
macro_line|#ifndef _UFS_SWAB_H
DECL|macro|_UFS_SWAB_H
mdefine_line|#define _UFS_SWAB_H
multiline_comment|/*&n; * Notes:&n; *    HERE WE ASSUME EITHER BIG OR LITTLE ENDIAN UFSes&n; *    in case there are ufs implementations that have strange bytesexes,&n; *    you&squot;ll need to modify code here as well as in ufs_super.c and ufs_fs.h&n; *    to support them.&n; *&n; *    WE ALSO ASSUME A REMOTELY SANE ARCHITECTURE BYTESEX.&n; *    We are not ready to confront insane bytesexual perversions where&n; *    conversion to/from little/big-endian is not an involution.&n; *    That is, we require that XeYZ_to_cpu(x) == cpu_to_XeYZ(x)&n; *&n; *    NOTE that swab macros depend on a variable (or macro) swab being in&n; *    scope and properly initialized (usually from sb-&gt;u.ufs_sb.s_swab).&n; *    Its meaning depends on whether the architecture is sane-endian or not.&n; *    For sane architectures, it&squot;s a flag taking values UFS_NATIVE_ENDIAN (0)&n; *    or UFS_SWABBED_ENDIAN (1), indicating whether to swab or not.&n; *    For pervert architectures, it&squot;s either UFS_LITTLE_ENDIAN or&n; *    UFS_BIG_ENDIAN whose meaning you&squot;ll have to guess.&n; *&n; *    It is important to keep these conventions in synch with ufs_fs.h&n; *    and super.c. Failure to do so (initializing swab to 0 both for&n; *    NATIVE_ENDIAN and LITTLE_ENDIAN) led to nasty crashes on big endian&n; *    machines reading little endian UFSes. Search for &quot;swab =&quot; in super.c.&n; *&n; *    I also suspect the whole UFS code to trust the on-disk structures&n; *    much too much, which might lead to losing badly when mounting&n; *    inconsistent partitions as UFS filesystems. fsck required (but of&n; *    course, no fsck.ufs has yet to be ported from BSD to Linux as of 199808).&n; */
macro_line|#include &lt;linux/ufs_fs.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
multiline_comment|/*&n; * These are only valid inside ufs routines,&n; * after swab has been initialized to sb-&gt;u.ufs_sb.s_swab&n; */
DECL|macro|SWAB16
mdefine_line|#define SWAB16(x) ufs_swab16(swab,x)
DECL|macro|SWAB32
mdefine_line|#define SWAB32(x) ufs_swab32(swab,x)
DECL|macro|SWAB64
mdefine_line|#define SWAB64(x) ufs_swab64(swab,x)
multiline_comment|/*&n; * We often use swabing, when we want to increment/decrement some value,&n; * so these macros might become handy and increase readability. (Daniel)&n; */
DECL|macro|INC_SWAB16
mdefine_line|#define INC_SWAB16(x)&t;((x)=ufs_swab16_add(swab,x,1))
DECL|macro|INC_SWAB32
mdefine_line|#define INC_SWAB32(x)&t;((x)=ufs_swab32_add(swab,x,1))
DECL|macro|INC_SWAB64
mdefine_line|#define INC_SWAB64(x)&t;((x)=ufs_swab64_add(swab,x,1))
DECL|macro|DEC_SWAB16
mdefine_line|#define DEC_SWAB16(x)&t;((x)=ufs_swab16_add(swab,x,-1))
DECL|macro|DEC_SWAB32
mdefine_line|#define DEC_SWAB32(x)&t;((x)=ufs_swab32_add(swab,x,-1))
DECL|macro|DEC_SWAB64
mdefine_line|#define DEC_SWAB64(x)&t;((x)=ufs_swab64_add(swab,x,-1))
DECL|macro|ADD_SWAB16
mdefine_line|#define ADD_SWAB16(x,y)&t;((x)=ufs_swab16_add(swab,x,y))
DECL|macro|ADD_SWAB32
mdefine_line|#define ADD_SWAB32(x,y)&t;((x)=ufs_swab32_add(swab,x,y))
DECL|macro|ADD_SWAB64
mdefine_line|#define ADD_SWAB64(x,y)&t;((x)=ufs_swab64_add(swab,x,y))
DECL|macro|SUB_SWAB16
mdefine_line|#define SUB_SWAB16(x,y)&t;((x)=ufs_swab16_add(swab,x,-(y)))
DECL|macro|SUB_SWAB32
mdefine_line|#define SUB_SWAB32(x,y)&t;((x)=ufs_swab32_add(swab,x,-(y)))
DECL|macro|SUB_SWAB64
mdefine_line|#define SUB_SWAB64(x,y)&t;((x)=ufs_swab64_add(swab,x,-(y)))
macro_line|#if defined(__LITTLE_ENDIAN) || defined(__BIG_ENDIAN) /* sane bytesex */
DECL|function|ufs_swab16
r_extern
id|__inline__
id|__const__
id|__u16
id|ufs_swab16
c_func
(paren
r_int
id|swab
comma
id|__u16
id|x
)paren
(brace
r_if
c_cond
(paren
id|swab
)paren
r_return
id|swab16
c_func
(paren
id|x
)paren
suffix:semicolon
r_else
r_return
id|x
suffix:semicolon
)brace
DECL|function|ufs_swab32
r_extern
id|__inline__
id|__const__
id|__u32
id|ufs_swab32
c_func
(paren
r_int
id|swab
comma
id|__u32
id|x
)paren
(brace
r_if
c_cond
(paren
id|swab
)paren
r_return
id|swab32
c_func
(paren
id|x
)paren
suffix:semicolon
r_else
r_return
id|x
suffix:semicolon
)brace
DECL|function|ufs_swab64
r_extern
id|__inline__
id|__const__
id|__u64
id|ufs_swab64
c_func
(paren
r_int
id|swab
comma
id|__u64
id|x
)paren
(brace
r_if
c_cond
(paren
id|swab
)paren
r_return
id|swab64
c_func
(paren
id|x
)paren
suffix:semicolon
r_else
r_return
id|x
suffix:semicolon
)brace
DECL|function|ufs_swab16_add
r_extern
id|__inline__
id|__const__
id|__u16
id|ufs_swab16_add
c_func
(paren
r_int
id|swab
comma
id|__u16
id|x
comma
id|__u16
id|y
)paren
(brace
r_if
c_cond
(paren
id|swab
)paren
r_return
id|swab16
c_func
(paren
id|swab16
c_func
(paren
id|x
)paren
op_plus
id|y
)paren
suffix:semicolon
r_else
r_return
id|x
op_plus
id|y
suffix:semicolon
)brace
DECL|function|ufs_swab32_add
r_extern
id|__inline__
id|__const__
id|__u32
id|ufs_swab32_add
c_func
(paren
r_int
id|swab
comma
id|__u32
id|x
comma
id|__u32
id|y
)paren
(brace
r_if
c_cond
(paren
id|swab
)paren
r_return
id|swab32
c_func
(paren
id|swab32
c_func
(paren
id|x
)paren
op_plus
id|y
)paren
suffix:semicolon
r_else
r_return
id|x
op_plus
id|y
suffix:semicolon
)brace
DECL|function|ufs_swab64_add
r_extern
id|__inline__
id|__const__
id|__u64
id|ufs_swab64_add
c_func
(paren
r_int
id|swab
comma
id|__u64
id|x
comma
id|__u64
id|y
)paren
(brace
r_if
c_cond
(paren
id|swab
)paren
r_return
id|swab64
c_func
(paren
id|swab64
c_func
(paren
id|x
)paren
op_plus
id|y
)paren
suffix:semicolon
r_else
r_return
id|x
op_plus
id|y
suffix:semicolon
)brace
macro_line|#else /* bytesexual perversion -- BEWARE! Read note at top of file! */
DECL|function|ufs_swab16
r_extern
id|__inline__
id|__const__
id|__u16
id|ufs_swab16
c_func
(paren
r_int
id|swab
comma
id|__u16
id|x
)paren
(brace
r_if
c_cond
(paren
id|swab
op_eq
id|UFS_LITTLE_ENDIAN
)paren
r_return
id|le16_to_cpu
c_func
(paren
id|x
)paren
suffix:semicolon
r_else
r_return
id|be16_to_cpu
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
DECL|function|ufs_swab32
r_extern
id|__inline__
id|__const__
id|__u32
id|ufs_swab32
c_func
(paren
r_int
id|swab
comma
id|__u32
id|x
)paren
(brace
r_if
c_cond
(paren
id|swab
op_eq
id|UFS_LITTLE_ENDIAN
)paren
r_return
id|le32_to_cpu
c_func
(paren
id|x
)paren
suffix:semicolon
r_else
r_return
id|be32_to_cpu
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
DECL|function|ufs_swab64
r_extern
id|__inline__
id|__const__
id|__u64
id|ufs_swab64
c_func
(paren
r_int
id|swab
comma
id|__u64
id|x
)paren
(brace
r_if
c_cond
(paren
id|swab
op_eq
id|UFS_LITTLE_ENDIAN
)paren
r_return
id|le64_to_cpu
c_func
(paren
id|x
)paren
suffix:semicolon
r_else
r_return
id|be64_to_cpu
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
DECL|function|ufs_swab16_add
r_extern
id|__inline__
id|__const__
id|__u16
id|ufs_swab16_add
c_func
(paren
r_int
id|swab
comma
id|__u16
id|x
comma
id|__u16
id|y
)paren
(brace
r_return
id|ufs_swab16
c_func
(paren
id|swab
comma
id|ufs_swab16
c_func
(paren
id|swab
comma
id|x
)paren
op_plus
id|y
)paren
suffix:semicolon
)brace
DECL|function|ufs_swab32_add
r_extern
id|__inline__
id|__const__
id|__u32
id|ufs_swab32_add
c_func
(paren
r_int
id|swab
comma
id|__u32
id|x
comma
id|__u32
id|y
)paren
(brace
r_return
id|ufs_swab32
c_func
(paren
id|swab
comma
id|ufs_swab32
c_func
(paren
id|swab
comma
id|x
)paren
op_plus
id|y
)paren
suffix:semicolon
)brace
DECL|function|ufs_swab64_add
r_extern
id|__inline__
id|__const__
id|__u64
id|ufs_swab64_add
c_func
(paren
r_int
id|swab
comma
id|__u64
id|x
comma
id|__u64
id|y
)paren
(brace
r_return
id|ufs_swab64
c_func
(paren
id|swab
comma
id|ufs_swab64
c_func
(paren
id|swab
comma
id|x
)paren
op_plus
id|y
)paren
suffix:semicolon
)brace
macro_line|#endif /* byte sexuality */
macro_line|#endif /* _UFS_SWAB_H */
eof
