multiline_comment|/*&n; *  linux/fs/ufs/ufs_swab.h&n; *&n; * Copyright (C) 1997 &n; * Francois-Rene Rideau &lt;rideau@ens.fr&gt;&n; *&n; */
macro_line|#ifndef _UFS_SWAB_H
DECL|macro|_UFS_SWAB_H
mdefine_line|#define _UFS_SWAB_H
multiline_comment|/*&n; * Notes:&n; * (1) HERE WE ASSUME EITHER BIG OR LITTLE ENDIAN UFSes&n; *    in case there are ufs implementations that have strange bytesexes,&n; *    you&squot;ll need to modify code here as well as in ufs_super.c and ufs_fs.h&n; *    to support them.&n; * (2) for a read/write ufs driver, we should distinguish&n; *    between byteswapping for read or write accesses!&n; *    naming should then be UFS16_TO_CPU and suches.&n; *&n; * 4.4BSD (FreeBSD) support added on February 1st 1998 by&n; * Niels Kristian Bech Jensen &lt;nkbj@image.dk&gt; partially based&n; * on code by Martin von Loewis &lt;martin@mira.isdn.cs.tu-berlin.de&gt;.&n; */
macro_line|#include &lt;linux/ufs_fs.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
multiline_comment|/*&n; * These are only valid inside ufs routines, after a variable named flags&n; * has been made visible in current scope and properly initialized:&n;&t;__u32 flags = sb-&gt;u.ufs_sb.s_flags ;&n; */
DECL|macro|SWAB16
mdefine_line|#define SWAB16(x) ufs_swab16(flags,x)
DECL|macro|SWAB32
mdefine_line|#define SWAB32(x) ufs_swab32(flags,x)
DECL|macro|SWAB64
mdefine_line|#define SWAB64(x) ufs_swab64(flags,x)
DECL|function|ufs_swab16
r_extern
id|__inline__
id|__const__
id|__u16
id|ufs_swab16
c_func
(paren
id|__u32
id|flags
comma
id|__u16
id|x
)paren
(brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|UFS_BYTESEX
)paren
op_eq
id|UFS_LITTLE_ENDIAN
)paren
(brace
r_return
id|le16_to_cpu
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|be16_to_cpu
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
)brace
DECL|function|ufs_swab32
r_extern
id|__inline__
id|__const__
id|__u32
id|ufs_swab32
c_func
(paren
id|__u32
id|flags
comma
id|__u32
id|x
)paren
(brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|UFS_BYTESEX
)paren
op_eq
id|UFS_LITTLE_ENDIAN
)paren
(brace
r_return
id|le32_to_cpu
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|be32_to_cpu
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
)brace
DECL|function|ufs_swab64
r_extern
id|__inline__
id|__const__
id|__u64
id|ufs_swab64
c_func
(paren
id|__u32
id|flags
comma
id|__u64
id|x
)paren
(brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|UFS_BYTESEX
)paren
op_eq
id|UFS_LITTLE_ENDIAN
)paren
(brace
r_return
id|le64_to_cpu
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|be64_to_cpu
c_func
(paren
id|x
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * These are for in-core superblock normalization.&n; * It might or not be a bad idea once we go to a read/write driver,&n; * as all critical info should be copied to the sb info structure anyway.&n; * So better replace them with a static inline function&n; * ufs_superblock_to_sb_info() in ufs_super.c&n; */
r_extern
r_void
id|ufs_superblock_le_to_cpus
c_func
(paren
r_struct
id|ufs_superblock
op_star
id|usb
)paren
suffix:semicolon
r_extern
r_void
id|ufs_superblock_be_to_cpus
c_func
(paren
r_struct
id|ufs_superblock
op_star
id|usb
)paren
suffix:semicolon
multiline_comment|/*&n; * These also implicitly depend on variable flags...&n; * NAMLEN(foo) is already normalized to local format, so don&squot;t SWAB16() it!&n; */
DECL|macro|NAMLEN
mdefine_line|#define NAMLEN(direct) ufs_namlen(flags,direct)
DECL|function|ufs_namlen
r_extern
id|__inline__
id|__u16
id|ufs_namlen
c_func
(paren
id|__u32
id|flags
comma
r_struct
id|ufs_direct
op_star
id|direct
)paren
(brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|UFS_DE_MASK
)paren
op_eq
id|UFS_DE_OLD
)paren
(brace
r_return
id|SWAB16
c_func
(paren
id|direct-&gt;d_u.d_namlen
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* UFS_DE_44BSD */
(brace
r_return
id|direct-&gt;d_u.d_44.d_namlen
suffix:semicolon
)brace
)brace
multiline_comment|/* Here is how the uid is computed:&n;   if the file system is 4.2BSD, get it from oldids.&n;   if it has sun extension and oldids is USEEFT, get it from ui_sun.&n;   if it is 4.4 or Hurd, get it from ui_44 (which is the same as ui_hurd).&n;   depends on implicit variable flags being initialized from&n;&t;__u32 flags = sb-&gt;u.ufs_sb.s_flags;&n;*/
DECL|macro|UFS_UID
mdefine_line|#define UFS_UID(ino)&t;ufs_uid(flags,ino)
DECL|macro|UFS_GID
mdefine_line|#define UFS_GID(ino)&t;ufs_gid(flags,ino)
DECL|function|ufs_uid
r_extern
id|__inline__
id|__u32
id|ufs_uid
c_func
(paren
id|__u32
id|flags
comma
r_struct
id|ufs_inode
op_star
id|ino
)paren
(brace
r_switch
c_cond
(paren
id|flags
op_amp
id|UFS_UID_MASK
)paren
(brace
r_case
id|UFS_UID_EFT
suffix:colon
r_return
id|SWAB32
c_func
(paren
id|ino-&gt;ui_u3.ui_sun.ui_uid
)paren
suffix:semicolon
r_case
id|UFS_UID_44BSD
suffix:colon
r_return
id|SWAB32
c_func
(paren
id|ino-&gt;ui_u3.ui_44.ui_uid
)paren
suffix:semicolon
r_case
id|UFS_UID_OLD
suffix:colon
r_default
suffix:colon
r_return
id|SWAB16
c_func
(paren
id|ino-&gt;ui_u1.oldids.suid
)paren
suffix:semicolon
)brace
)brace
DECL|function|ufs_gid
r_extern
id|__inline__
id|__u32
id|ufs_gid
c_func
(paren
id|__u32
id|flags
comma
r_struct
id|ufs_inode
op_star
id|ino
)paren
(brace
r_switch
c_cond
(paren
id|flags
op_amp
id|UFS_UID_MASK
)paren
(brace
r_case
id|UFS_UID_EFT
suffix:colon
r_return
id|SWAB32
c_func
(paren
id|ino-&gt;ui_u3.ui_sun.ui_gid
)paren
suffix:semicolon
r_case
id|UFS_UID_44BSD
suffix:colon
r_return
id|SWAB32
c_func
(paren
id|ino-&gt;ui_u3.ui_44.ui_gid
)paren
suffix:semicolon
r_case
id|UFS_UID_OLD
suffix:colon
r_default
suffix:colon
r_return
id|SWAB16
c_func
(paren
id|ino-&gt;ui_u1.oldids.sgid
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* _UFS_SWAB_H */
eof
