multiline_comment|/*&n; *&t;linux/kernel/resource.c&n; *&n; * Copyright (C) 1995, 1999&t;Linus Torvalds&n; *&t;&t;&t;&t;David Hinds&n; *&n; * Kernel resource management&n; *&n; * We now distinguish between claiming space for devices (using the&n; * &squot;occupy&squot; and &squot;vacate&squot; calls), and associating a resource with a&n; * device driver (with the &squot;request&squot;, &squot;release&squot;, and &squot;check&squot; calls).&n; * A resource can be claimed even if there is no associated driver&n; * (by occupying with name=NULL).  Vacating a resource makes it&n; * available for other dynamically configured devices.&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/init.h&gt;
DECL|macro|RSRC_TABLE_SIZE
mdefine_line|#define RSRC_TABLE_SIZE 128
DECL|struct|resource_entry
r_struct
id|resource_entry
(brace
DECL|member|from
DECL|member|num
id|u_long
id|from
comma
id|num
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|next
r_struct
id|resource_entry
op_star
id|next
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|res_list
r_struct
id|resource_entry
id|res_list
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
multiline_comment|/* IO */
(brace
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)brace
multiline_comment|/* mem */
)brace
suffix:semicolon
DECL|variable|rsrc_table
r_static
r_struct
id|resource_entry
id|rsrc_table
(braket
id|RSRC_TABLE_SIZE
)braket
suffix:semicolon
multiline_comment|/*&n; * This generates reports for /proc/ioports and /proc/memory&n; */
DECL|function|get_resource_list
r_int
id|get_resource_list
c_func
(paren
r_int
r_class
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|resource_entry
op_star
id|root
op_assign
op_amp
id|res_list
(braket
r_class
)braket
suffix:semicolon
r_struct
id|resource_entry
op_star
id|p
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|fmt
op_assign
(paren
r_class
op_eq
id|RES_IO
)paren
ques
c_cond
l_string|&quot;%04lx-%04lx : %s&bslash;n&quot;
suffix:colon
l_string|&quot;%08lx-%08lx : %s&bslash;n&quot;
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|root-&gt;next
suffix:semicolon
(paren
id|p
)paren
op_logical_and
(paren
id|len
OL
l_int|4000
)paren
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
id|fmt
comma
id|p-&gt;from
comma
id|p-&gt;from
op_plus
id|p-&gt;num
op_minus
l_int|1
comma
(paren
id|p-&gt;name
ques
c_cond
id|p-&gt;name
suffix:colon
l_string|&quot;occupied&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|len
comma
l_string|&quot;4K limit reached!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * Basics: find a matching resource entry, or find an insertion point&n; */
r_static
r_struct
id|resource_entry
op_star
DECL|function|find_match
id|find_match
c_func
(paren
r_struct
id|resource_entry
op_star
id|root
comma
id|u_long
id|from
comma
id|u_long
id|num
)paren
(brace
r_struct
id|resource_entry
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|root
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
r_if
c_cond
(paren
(paren
id|p-&gt;from
op_eq
id|from
)paren
op_logical_and
(paren
id|p-&gt;num
op_eq
id|num
)paren
)paren
r_return
id|p
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
r_static
r_struct
id|resource_entry
op_star
DECL|function|find_gap
id|find_gap
c_func
(paren
r_struct
id|resource_entry
op_star
id|root
comma
id|u_long
id|from
comma
id|u_long
id|num
)paren
(brace
r_struct
id|resource_entry
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|from
OG
id|from
op_plus
id|num
op_minus
l_int|1
)paren
r_return
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|root
suffix:semicolon
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|p
op_ne
id|root
)paren
op_logical_and
(paren
id|p-&gt;from
op_plus
id|p-&gt;num
op_minus
l_int|1
op_ge
id|from
)paren
)paren
(brace
id|p
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|p-&gt;next
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|p-&gt;next-&gt;from
OG
id|from
op_plus
id|num
op_minus
l_int|1
)paren
)paren
r_break
suffix:semicolon
)brace
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/*&n; * Call this from a driver to assert ownership of a resource&n; */
DECL|function|request_resource
r_void
id|request_resource
c_func
(paren
r_int
r_class
comma
r_int
r_int
id|from
comma
r_int
r_int
id|num
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|resource_entry
op_star
id|root
op_assign
op_amp
id|res_list
(braket
r_class
)braket
suffix:semicolon
r_struct
id|resource_entry
op_star
id|p
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|p
op_assign
id|find_match
c_func
(paren
id|root
comma
id|from
comma
id|num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|p-&gt;name
op_assign
id|name
suffix:semicolon
r_return
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RSRC_TABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|rsrc_table
(braket
id|i
)braket
dot
id|num
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|RSRC_TABLE_SIZE
)paren
id|printk
c_func
(paren
l_string|&quot;warning: resource table is full&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|p
op_assign
id|find_gap
c_func
(paren
id|root
comma
id|from
comma
id|num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rsrc_table
(braket
id|i
)braket
dot
id|name
op_assign
id|name
suffix:semicolon
id|rsrc_table
(braket
id|i
)braket
dot
id|from
op_assign
id|from
suffix:semicolon
id|rsrc_table
(braket
id|i
)braket
dot
id|num
op_assign
id|num
suffix:semicolon
id|rsrc_table
(braket
id|i
)braket
dot
id|next
op_assign
id|p-&gt;next
suffix:semicolon
id|p-&gt;next
op_assign
op_amp
id|rsrc_table
(braket
id|i
)braket
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Call these when a driver is unloaded but the device remains&n; */
DECL|function|release_resource
r_void
id|release_resource
c_func
(paren
r_int
r_class
comma
r_int
r_int
id|from
comma
r_int
r_int
id|num
)paren
(brace
r_struct
id|resource_entry
op_star
id|root
op_assign
op_amp
id|res_list
(braket
r_class
)braket
suffix:semicolon
r_struct
id|resource_entry
op_star
id|p
suffix:semicolon
id|p
op_assign
id|find_match
c_func
(paren
id|root
comma
id|from
comma
id|num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|p-&gt;name
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Call these to check a region for conflicts before probing&n; */
DECL|function|check_resource
r_int
id|check_resource
c_func
(paren
r_int
r_class
comma
r_int
r_int
id|from
comma
r_int
r_int
id|num
)paren
(brace
r_struct
id|resource_entry
op_star
id|root
op_assign
op_amp
id|res_list
(braket
r_class
)braket
suffix:semicolon
r_struct
id|resource_entry
op_star
id|p
suffix:semicolon
id|p
op_assign
id|find_match
c_func
(paren
id|root
comma
id|from
comma
id|num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ne
l_int|NULL
)paren
r_return
(paren
id|p-&gt;name
op_ne
l_int|NULL
)paren
ques
c_cond
op_minus
id|EBUSY
suffix:colon
l_int|0
suffix:semicolon
r_return
(paren
id|find_gap
c_func
(paren
id|root
comma
id|from
comma
id|num
)paren
op_eq
l_int|NULL
)paren
ques
c_cond
op_minus
id|EBUSY
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Call this to claim a resource for a piece of hardware&n; */
DECL|function|occupy_resource
r_int
r_int
id|occupy_resource
c_func
(paren
r_int
r_class
comma
r_int
r_int
id|base
comma
r_int
r_int
id|end
comma
r_int
r_int
id|num
comma
r_int
r_int
id|align
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|resource_entry
op_star
id|root
op_assign
op_amp
id|res_list
(braket
r_class
)braket
suffix:semicolon
r_int
r_int
id|from
op_assign
l_int|0
comma
id|till
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|resource_entry
op_star
id|p
comma
op_star
id|q
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
OG
id|end
op_minus
l_int|1
)paren
op_logical_or
(paren
id|num
OG
id|end
op_minus
id|base
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RSRC_TABLE_SIZE
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|rsrc_table
(braket
id|i
)braket
dot
id|num
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|RSRC_TABLE_SIZE
)paren
r_return
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* printk(&quot;occupy: search in %08lx[%08lx] &quot;, base, end - base); */
r_for
c_loop
(paren
id|p
op_assign
id|root
suffix:semicolon
id|p
op_ne
l_int|NULL
suffix:semicolon
id|p
op_assign
id|q
)paren
(brace
id|q
op_assign
id|p-&gt;next
suffix:semicolon
multiline_comment|/* Find window in list */
id|from
op_assign
(paren
id|p-&gt;from
op_plus
id|p-&gt;num
op_plus
id|align
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|align
op_minus
l_int|1
)paren
suffix:semicolon
id|till
op_assign
(paren
id|q
op_eq
l_int|NULL
)paren
ques
c_cond
(paren
l_int|0
op_minus
id|align
)paren
suffix:colon
id|q-&gt;from
suffix:semicolon
multiline_comment|/* printk(&quot; %08lx:%08lx&quot;, from, till); */
multiline_comment|/* Clip window with base and end */
r_if
c_cond
(paren
id|from
OL
id|base
)paren
id|from
op_assign
id|base
suffix:semicolon
r_if
c_cond
(paren
id|till
OG
id|end
)paren
id|till
op_assign
id|end
suffix:semicolon
multiline_comment|/* See if result is large enougth */
r_if
c_cond
(paren
(paren
id|from
OL
id|till
)paren
op_logical_and
(paren
id|from
op_plus
id|num
OL
id|till
)paren
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/* printk(&quot;&bslash;r&bslash;n&quot;); */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|rsrc_table
(braket
id|i
)braket
dot
id|name
op_assign
id|name
suffix:semicolon
id|rsrc_table
(braket
id|i
)braket
dot
id|from
op_assign
id|from
suffix:semicolon
id|rsrc_table
(braket
id|i
)braket
dot
id|num
op_assign
id|num
suffix:semicolon
id|rsrc_table
(braket
id|i
)braket
dot
id|next
op_assign
id|p-&gt;next
suffix:semicolon
id|p-&gt;next
op_assign
op_amp
id|rsrc_table
(braket
id|i
)braket
suffix:semicolon
r_return
id|from
suffix:semicolon
)brace
multiline_comment|/*&n; * Call this when a resource becomes available for other hardware&n; */
DECL|function|vacate_resource
r_void
id|vacate_resource
c_func
(paren
r_int
r_class
comma
r_int
r_int
id|from
comma
r_int
r_int
id|num
)paren
(brace
r_struct
id|resource_entry
op_star
id|root
op_assign
op_amp
id|res_list
(braket
r_class
)braket
suffix:semicolon
r_struct
id|resource_entry
op_star
id|p
comma
op_star
id|q
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|root
suffix:semicolon
suffix:semicolon
id|p
op_assign
id|q
)paren
(brace
id|q
op_assign
id|p-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|q
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q-&gt;from
op_eq
id|from
)paren
op_logical_and
(paren
id|q-&gt;num
op_eq
id|num
)paren
)paren
(brace
id|q-&gt;num
op_assign
l_int|0
suffix:semicolon
id|p-&gt;next
op_assign
id|q-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Called from init/main.c to reserve IO ports. */
DECL|function|reserve_setup
r_void
id|__init
id|reserve_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|ints
(braket
l_int|0
)braket
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
id|request_region
c_func
(paren
id|ints
(braket
id|i
)braket
comma
id|ints
(braket
id|i
op_plus
l_int|1
)braket
comma
l_string|&quot;reserved&quot;
)paren
suffix:semicolon
)brace
eof
