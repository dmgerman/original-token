multiline_comment|/*&n; * linux/kernel/itimer.c&n; *&n; * Copyright (C) 1992 Darren Senn&n; */
multiline_comment|/* These are all the functions necessary to implement itimers */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/*&n; * change timeval to jiffies, trying to avoid the&n; * most obvious overflows..&n; *&n; * The tv_*sec values are signed, but nothing seems to&n; * indicate whether we really should use them as signed values&n; * when doing itimers. POSIX doesn&squot;t mention this (but if&n; * alarm() uses itimers without checking, we have to use unsigned&n; * arithmetic).&n; */
DECL|function|tvtojiffies
r_static
r_int
r_int
id|tvtojiffies
c_func
(paren
r_struct
id|timeval
op_star
id|value
)paren
(brace
r_int
r_int
id|sec
op_assign
(paren
r_int
)paren
id|value-&gt;tv_sec
suffix:semicolon
r_int
r_int
id|usec
op_assign
(paren
r_int
)paren
id|value-&gt;tv_usec
suffix:semicolon
r_if
c_cond
(paren
id|sec
OG
(paren
id|ULONG_MAX
op_div
id|HZ
)paren
)paren
r_return
id|ULONG_MAX
suffix:semicolon
id|usec
op_add_assign
l_int|1000000
op_div
id|HZ
op_minus
l_int|1
suffix:semicolon
id|usec
op_div_assign
l_int|1000000
op_div
id|HZ
suffix:semicolon
r_return
id|HZ
op_star
id|sec
op_plus
id|usec
suffix:semicolon
)brace
DECL|function|jiffiestotv
r_static
r_void
id|jiffiestotv
c_func
(paren
r_int
r_int
id|jiffies
comma
r_struct
id|timeval
op_star
id|value
)paren
(brace
id|value-&gt;tv_usec
op_assign
(paren
id|jiffies
op_mod
id|HZ
)paren
op_star
(paren
l_int|1000000
op_div
id|HZ
)paren
suffix:semicolon
id|value-&gt;tv_sec
op_assign
id|jiffies
op_div
id|HZ
suffix:semicolon
)brace
DECL|function|do_getitimer
r_int
id|do_getitimer
c_func
(paren
r_int
id|which
comma
r_struct
id|itimerval
op_star
id|value
)paren
(brace
r_register
r_int
r_int
id|val
comma
id|interval
suffix:semicolon
r_switch
c_cond
(paren
id|which
)paren
(brace
r_case
id|ITIMER_REAL
suffix:colon
id|interval
op_assign
id|current-&gt;it_real_incr
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|current-&gt;real_timer
)paren
)paren
(brace
id|val
op_assign
id|current-&gt;real_timer.expires
op_minus
id|jiffies
suffix:semicolon
multiline_comment|/* look out for negative/zero itimer.. */
r_if
c_cond
(paren
(paren
r_int
)paren
id|val
op_le
l_int|0
)paren
id|val
op_assign
l_int|1
suffix:semicolon
)brace
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ITIMER_VIRTUAL
suffix:colon
id|val
op_assign
id|current-&gt;it_virt_value
suffix:semicolon
id|interval
op_assign
id|current-&gt;it_virt_incr
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ITIMER_PROF
suffix:colon
id|val
op_assign
id|current-&gt;it_prof_value
suffix:semicolon
id|interval
op_assign
id|current-&gt;it_prof_incr
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|jiffiestotv
c_func
(paren
id|val
comma
op_amp
id|value-&gt;it_value
)paren
suffix:semicolon
id|jiffiestotv
c_func
(paren
id|interval
comma
op_amp
id|value-&gt;it_interval
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* SMP: Only we modify our itimer values. */
DECL|function|sys_getitimer
id|asmlinkage
r_int
id|sys_getitimer
c_func
(paren
r_int
id|which
comma
r_struct
id|itimerval
op_star
id|value
)paren
(brace
r_int
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_struct
id|itimerval
id|get_buffer
suffix:semicolon
r_if
c_cond
(paren
id|value
)paren
(brace
id|error
op_assign
id|do_getitimer
c_func
(paren
id|which
comma
op_amp
id|get_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
op_logical_and
id|copy_to_user
c_func
(paren
id|value
comma
op_amp
id|get_buffer
comma
r_sizeof
(paren
id|get_buffer
)paren
)paren
)paren
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|function|it_real_fn
r_void
id|it_real_fn
c_func
(paren
r_int
r_int
id|__data
)paren
(brace
r_struct
id|task_struct
op_star
id|p
op_assign
(paren
r_struct
id|task_struct
op_star
)paren
id|__data
suffix:semicolon
r_int
r_int
id|interval
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGALRM
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
id|interval
op_assign
id|p-&gt;it_real_incr
suffix:semicolon
r_if
c_cond
(paren
id|interval
)paren
(brace
r_if
c_cond
(paren
id|interval
OG
(paren
r_int
r_int
)paren
id|LONG_MAX
)paren
id|interval
op_assign
id|LONG_MAX
suffix:semicolon
id|p-&gt;real_timer.expires
op_assign
id|jiffies
op_plus
id|interval
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|p-&gt;real_timer
)paren
suffix:semicolon
)brace
)brace
DECL|function|do_setitimer
r_int
id|do_setitimer
c_func
(paren
r_int
id|which
comma
r_struct
id|itimerval
op_star
id|value
comma
r_struct
id|itimerval
op_star
id|ovalue
)paren
(brace
r_register
r_int
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|k
suffix:semicolon
id|i
op_assign
id|tvtojiffies
c_func
(paren
op_amp
id|value-&gt;it_interval
)paren
suffix:semicolon
id|j
op_assign
id|tvtojiffies
c_func
(paren
op_amp
id|value-&gt;it_value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ovalue
op_logical_and
(paren
id|k
op_assign
id|do_getitimer
c_func
(paren
id|which
comma
id|ovalue
)paren
)paren
OL
l_int|0
)paren
r_return
id|k
suffix:semicolon
r_switch
c_cond
(paren
id|which
)paren
(brace
r_case
id|ITIMER_REAL
suffix:colon
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|current-&gt;real_timer
)paren
suffix:semicolon
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;it_real_value
op_assign
id|j
suffix:semicolon
id|current-&gt;it_real_incr
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|j
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|j
OG
(paren
r_int
r_int
)paren
id|LONG_MAX
)paren
id|j
op_assign
id|LONG_MAX
suffix:semicolon
id|i
op_assign
id|j
op_plus
id|jiffies
suffix:semicolon
id|current-&gt;real_timer.expires
op_assign
id|i
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|current-&gt;real_timer
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ITIMER_VIRTUAL
suffix:colon
r_if
c_cond
(paren
id|j
)paren
id|j
op_increment
suffix:semicolon
id|current-&gt;it_virt_value
op_assign
id|j
suffix:semicolon
id|current-&gt;it_virt_incr
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ITIMER_PROF
suffix:colon
r_if
c_cond
(paren
id|j
)paren
id|j
op_increment
suffix:semicolon
id|current-&gt;it_prof_value
op_assign
id|j
suffix:semicolon
id|current-&gt;it_prof_incr
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* SMP: Again, only we play with our itimers, and signals are SMP safe&n; *      now so that is not an issue at all anymore.&n; */
DECL|function|sys_setitimer
id|asmlinkage
r_int
id|sys_setitimer
c_func
(paren
r_int
id|which
comma
r_struct
id|itimerval
op_star
id|value
comma
r_struct
id|itimerval
op_star
id|ovalue
)paren
(brace
r_struct
id|itimerval
id|set_buffer
comma
id|get_buffer
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|value
)paren
(brace
r_if
c_cond
(paren
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|value
comma
r_sizeof
(paren
op_star
id|value
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|set_buffer
comma
id|value
comma
r_sizeof
(paren
id|set_buffer
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_else
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|set_buffer
comma
l_int|0
comma
r_sizeof
(paren
id|set_buffer
)paren
)paren
suffix:semicolon
id|error
op_assign
id|do_setitimer
c_func
(paren
id|which
comma
op_amp
id|set_buffer
comma
id|ovalue
ques
c_cond
op_amp
id|get_buffer
suffix:colon
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_logical_or
op_logical_neg
id|ovalue
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|ovalue
comma
op_amp
id|get_buffer
comma
r_sizeof
(paren
id|get_buffer
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* PRECONDITION:&n; * timr-&gt;it_lock must be locked&n; */
DECL|function|timer_notify_task
r_static
r_void
id|timer_notify_task
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
)paren
(brace
r_struct
id|siginfo
id|info
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|timr-&gt;it_signal.sigev_notify
op_eq
id|SIGEV_SIGNAL
)paren
(brace
multiline_comment|/* Send signal to the process that owns this timer. */
id|info.si_signo
op_assign
id|timr-&gt;it_signal.sigev_signo
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|SI_TIMER
suffix:semicolon
multiline_comment|/* TODO: if someone has better ideas what to put in &n;&t;&t; * the next two fields...&n;&t;&t; * si_timer1 is currently used in signal.c to check&n;&t;&t; * whether a signal from this timer is already in the signal&n;&t;&t; * queue.&n;&t;&t; */
id|info.si_timer1
op_assign
id|timr-&gt;it_id
suffix:semicolon
id|info.si_timer2
op_assign
l_int|0
suffix:semicolon
id|info.si_value
op_assign
id|timr-&gt;it_signal.sigev_value
suffix:semicolon
id|ret
op_assign
id|send_sig_info
c_func
(paren
id|info.si_signo
comma
op_amp
id|info
comma
id|timr-&gt;it_process
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ret
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* all&squot;s well */
id|timr-&gt;it_overrun
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* signal from this timer was already in the queue */
id|timr-&gt;it_overrun
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;sending signal failed: %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* This function gets called when a POSIX.1b interval timer expires. */
DECL|function|posix_timer_fn
r_static
r_void
id|posix_timer_fn
c_func
(paren
r_int
r_int
id|__data
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
op_assign
(paren
r_struct
id|k_itimer
op_star
)paren
id|__data
suffix:semicolon
r_int
r_int
id|interval
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|timr-&gt;it_lock
)paren
suffix:semicolon
id|timer_notify_task
c_func
(paren
id|timr
)paren
suffix:semicolon
multiline_comment|/* Set up the timer for the next interval (if there is one) */
r_if
c_cond
(paren
(paren
id|interval
op_assign
id|timr-&gt;it_incr
)paren
op_eq
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|interval
OG
(paren
r_int
r_int
)paren
id|LONG_MAX
)paren
id|interval
op_assign
id|LONG_MAX
suffix:semicolon
id|timr-&gt;it_timer.expires
op_assign
id|jiffies
op_plus
id|interval
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|timr-&gt;it_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Find the first available slot for the new timer. */
DECL|function|timer_find_slot
r_static
r_int
id|timer_find_slot
c_func
(paren
r_struct
id|itimer_struct
op_star
id|timers
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_ITIMERS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|timers-&gt;itimer
(braket
id|i
)braket
op_eq
l_int|NULL
)paren
r_return
id|i
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|good_sigevent
r_static
r_int
id|good_sigevent
c_func
(paren
r_const
r_struct
id|sigevent
op_star
id|sigev
)paren
(brace
r_switch
c_cond
(paren
id|sigev-&gt;sigev_notify
)paren
(brace
r_case
id|SIGEV_NONE
suffix:colon
r_break
suffix:semicolon
r_case
id|SIGEV_SIGNAL
suffix:colon
r_if
c_cond
(paren
(paren
id|sigev-&gt;sigev_signo
op_le
l_int|0
)paren
op_logical_or
(paren
id|sigev-&gt;sigev_signo
OG
id|SIGRTMAX
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Create a POSIX.1b interval timer. */
DECL|function|sys_timer_create
id|asmlinkage
r_int
id|sys_timer_create
c_func
(paren
id|clockid_t
id|which_clock
comma
r_struct
id|sigevent
op_star
id|timer_event_spec
comma
id|timer_t
op_star
id|created_timer_id
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_struct
id|k_itimer
op_star
id|new_timer
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|itimer_struct
op_star
id|timers
op_assign
id|current-&gt;posix_timers
suffix:semicolon
r_int
id|new_timer_id
suffix:semicolon
multiline_comment|/* Right now, we only support CLOCK_REALTIME for timers. */
r_if
c_cond
(paren
id|which_clock
op_ne
id|CLOCK_REALTIME
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|new_timer
op_assign
(paren
r_struct
id|k_itimer
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|new_timer
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_timer
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|new_timer-&gt;it_lock
)paren
suffix:semicolon
id|new_timer-&gt;it_clock
op_assign
id|which_clock
suffix:semicolon
id|new_timer-&gt;it_incr
op_assign
l_int|0
suffix:semicolon
id|new_timer-&gt;it_overrun
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|timer_event_spec
)paren
(brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|new_timer-&gt;it_signal
comma
id|timer_event_spec
comma
r_sizeof
(paren
id|new_timer-&gt;it_signal
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|good_sigevent
c_func
(paren
op_amp
id|new_timer-&gt;it_signal
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_else
(brace
id|new_timer-&gt;it_signal.sigev_notify
op_assign
id|SIGEV_SIGNAL
suffix:semicolon
id|new_timer-&gt;it_signal.sigev_signo
op_assign
id|SIGALRM
suffix:semicolon
)brace
id|new_timer-&gt;it_interval.tv_sec
op_assign
l_int|0
suffix:semicolon
id|new_timer-&gt;it_interval.tv_nsec
op_assign
l_int|0
suffix:semicolon
id|new_timer-&gt;it_process
op_assign
id|current
suffix:semicolon
id|new_timer-&gt;it_timer.next
op_assign
l_int|NULL
suffix:semicolon
id|new_timer-&gt;it_timer.prev
op_assign
l_int|NULL
suffix:semicolon
id|new_timer-&gt;it_timer.expires
op_assign
l_int|0
suffix:semicolon
id|new_timer-&gt;it_timer.data
op_assign
(paren
r_int
r_int
)paren
id|new_timer
suffix:semicolon
id|new_timer-&gt;it_timer.function
op_assign
id|posix_timer_fn
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|timers-&gt;its_lock
)paren
suffix:semicolon
id|new_timer_id
op_assign
id|timer_find_slot
c_func
(paren
id|timers
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_timer_id
op_eq
op_minus
l_int|1
)paren
(brace
id|error
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|new_timer-&gt;it_id
op_assign
id|new_timer_id
suffix:semicolon
id|timers-&gt;itimer
(braket
id|new_timer_id
)braket
op_assign
id|new_timer
suffix:semicolon
r_if
c_cond
(paren
id|timer_event_spec
op_eq
l_int|NULL
)paren
(brace
id|new_timer-&gt;it_signal.sigev_value.sival_int
op_assign
id|new_timer_id
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|created_timer_id
comma
op_amp
id|new_timer_id
comma
r_sizeof
(paren
id|new_timer_id
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|timers-&gt;itimer
(braket
id|new_timer_id
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|timers-&gt;its_lock
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|error
)paren
(brace
id|kfree
c_func
(paren
id|new_timer
)paren
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* good_timespec&n; *&n; * This function checks the elements of a timespec structure.&n; *&n; * Arguments:&n; * ts       : Pointer to the timespec structure to check&n; *&n; * Return value:&n; * If a NULL pointer was passed in, or the tv_nsec field was less than 0 or&n; * greater than NSEC_PER_SEC, or the tv_sec field was less than 0, this&n; * function returns 0. Otherwise it returns 1.&n; */
DECL|function|good_timespec
r_static
r_int
id|good_timespec
c_func
(paren
r_const
r_struct
id|timespec
op_star
id|ts
)paren
(brace
r_if
c_cond
(paren
id|ts
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ts-&gt;tv_sec
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ts-&gt;tv_nsec
OL
l_int|0
)paren
op_logical_or
(paren
id|ts-&gt;tv_nsec
op_ge
id|NSEC_PER_SEC
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|lock_timer
r_static
r_inline
r_struct
id|k_itimer
op_star
id|lock_timer
c_func
(paren
r_struct
id|task_struct
op_star
id|tsk
comma
id|timer_t
id|timer_id
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|timer_id
OL
l_int|0
)paren
op_logical_or
(paren
id|timer_id
op_ge
id|MAX_ITIMERS
)paren
)paren
r_return
l_int|NULL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|tsk-&gt;posix_timers-&gt;its_lock
)paren
suffix:semicolon
id|timr
op_assign
id|tsk-&gt;posix_timers-&gt;itimer
(braket
id|timer_id
)braket
suffix:semicolon
r_if
c_cond
(paren
id|timr
)paren
id|spin_lock
c_func
(paren
op_amp
id|timr-&gt;it_lock
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|tsk-&gt;posix_timers-&gt;its_lock
)paren
suffix:semicolon
r_return
id|timr
suffix:semicolon
)brace
DECL|function|unlock_timer
r_static
r_inline
r_void
id|unlock_timer
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|timr-&gt;it_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the time remaining on a POSIX.1b interval timer. */
DECL|function|do_timer_gettime
r_static
r_void
id|do_timer_gettime
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
comma
r_struct
id|itimerspec
op_star
id|cur_setting
)paren
(brace
r_int
r_int
id|expires
op_assign
id|timr-&gt;it_timer.expires
suffix:semicolon
r_if
c_cond
(paren
id|expires
)paren
id|expires
op_sub_assign
id|jiffies
suffix:semicolon
id|jiffies_to_timespec
c_func
(paren
id|expires
comma
op_amp
id|cur_setting-&gt;it_value
)paren
suffix:semicolon
id|cur_setting-&gt;it_interval
op_assign
id|timr-&gt;it_interval
suffix:semicolon
)brace
multiline_comment|/* Get the time remaining on a POSIX.1b interval timer. */
DECL|function|sys_timer_gettime
id|asmlinkage
r_int
id|sys_timer_gettime
c_func
(paren
id|timer_t
id|timer_id
comma
r_struct
id|itimerspec
op_star
id|setting
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
r_struct
id|itimerspec
id|cur_setting
suffix:semicolon
id|timr
op_assign
id|lock_timer
c_func
(paren
id|current
comma
id|timer_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|do_timer_gettime
c_func
(paren
id|timr
comma
op_amp
id|cur_setting
)paren
suffix:semicolon
id|unlock_timer
c_func
(paren
id|timr
)paren
suffix:semicolon
id|copy_to_user_ret
c_func
(paren
id|setting
comma
op_amp
id|cur_setting
comma
r_sizeof
(paren
id|cur_setting
)paren
comma
op_minus
id|EFAULT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Get the number of overruns of a POSIX.1b interval timer */
DECL|function|sys_timer_getoverrun
id|asmlinkage
r_int
id|sys_timer_getoverrun
c_func
(paren
id|timer_t
id|timer_id
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
r_int
id|overrun
suffix:semicolon
id|timr
op_assign
id|lock_timer
c_func
(paren
id|current
comma
id|timer_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|overrun
op_assign
id|timr-&gt;it_overrun
suffix:semicolon
id|unlock_timer
c_func
(paren
id|timr
)paren
suffix:semicolon
r_return
id|overrun
suffix:semicolon
)brace
DECL|function|timer_value_abs_to_rel
r_static
r_void
id|timer_value_abs_to_rel
c_func
(paren
r_struct
id|timespec
op_star
id|val
)paren
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
r_struct
id|timespec
id|ts
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|ts.tv_sec
op_assign
id|tv.tv_sec
suffix:semicolon
id|ts.tv_nsec
op_assign
id|tv.tv_usec
op_star
id|NSEC_PER_USEC
suffix:semicolon
multiline_comment|/* check whether the time lies in the past */
r_if
c_cond
(paren
(paren
id|val-&gt;tv_sec
OL
id|ts.tv_sec
)paren
op_logical_or
(paren
(paren
id|val-&gt;tv_sec
op_eq
id|ts.tv_sec
)paren
op_logical_and
(paren
id|val-&gt;tv_nsec
op_le
id|ts.tv_nsec
)paren
)paren
)paren
(brace
multiline_comment|/* expire immediately */
id|val-&gt;tv_sec
op_assign
l_int|0
suffix:semicolon
id|val-&gt;tv_nsec
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|val-&gt;tv_sec
op_sub_assign
id|ts.tv_sec
suffix:semicolon
id|val-&gt;tv_nsec
op_sub_assign
id|ts.tv_nsec
suffix:semicolon
r_if
c_cond
(paren
id|val-&gt;tv_nsec
OL
l_int|0
)paren
(brace
id|val-&gt;tv_nsec
op_add_assign
id|NSEC_PER_SEC
suffix:semicolon
id|val-&gt;tv_sec
op_decrement
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Set a POSIX.1b interval timer. */
DECL|function|do_timer_settime
r_static
r_void
id|do_timer_settime
c_func
(paren
r_struct
id|k_itimer
op_star
id|timr
comma
r_int
id|flags
comma
r_struct
id|itimerspec
op_star
id|new_setting
comma
r_struct
id|itimerspec
op_star
id|old_setting
)paren
(brace
multiline_comment|/* disable the timer */
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
suffix:semicolon
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_setting
)paren
(brace
id|do_timer_gettime
c_func
(paren
id|timr
comma
id|old_setting
)paren
suffix:semicolon
)brace
multiline_comment|/* switch off the timer when it_value is zero */
r_if
c_cond
(paren
(paren
id|new_setting-&gt;it_value.tv_sec
op_eq
l_int|0
)paren
op_logical_and
(paren
id|new_setting-&gt;it_value.tv_nsec
op_eq
l_int|0
)paren
)paren
(brace
id|timr-&gt;it_incr
op_assign
l_int|0
suffix:semicolon
id|timr-&gt;it_timer.expires
op_assign
l_int|0
suffix:semicolon
id|timr-&gt;it_interval.tv_sec
op_assign
l_int|0
suffix:semicolon
id|timr-&gt;it_interval.tv_nsec
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|timr-&gt;it_incr
op_assign
id|timespec_to_jiffies
c_func
(paren
op_amp
id|new_setting-&gt;it_interval
)paren
suffix:semicolon
multiline_comment|/* save the interval rounded to jiffies */
id|jiffies_to_timespec
c_func
(paren
id|timr-&gt;it_incr
comma
op_amp
id|timr-&gt;it_interval
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|TIMER_ABSTIME
)paren
(brace
id|timer_value_abs_to_rel
c_func
(paren
op_amp
id|new_setting-&gt;it_value
)paren
suffix:semicolon
)brace
id|timr-&gt;it_timer.expires
op_assign
id|timespec_to_jiffies
c_func
(paren
op_amp
id|new_setting-&gt;it_value
)paren
op_plus
id|jiffies
suffix:semicolon
multiline_comment|/*&n;&t; * For some reason the timer does not fire immediately if expires is&n;&t; * equal to jiffies, so the timer callback function is called directly.&n;&t; */
r_if
c_cond
(paren
id|timr-&gt;it_timer.expires
op_eq
id|jiffies
)paren
(brace
id|posix_timer_fn
c_func
(paren
(paren
r_int
r_int
)paren
id|timr
)paren
suffix:semicolon
)brace
r_else
(brace
id|add_timer
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Set a POSIX.1b interval timer */
DECL|function|sys_timer_settime
id|asmlinkage
r_int
id|sys_timer_settime
c_func
(paren
id|timer_t
id|timer_id
comma
r_int
id|flags
comma
r_const
r_struct
id|itimerspec
op_star
id|new_setting
comma
r_struct
id|itimerspec
op_star
id|old_setting
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
r_struct
id|itimerspec
id|new_spec
comma
id|old_spec
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|timr
op_assign
id|lock_timer
c_func
(paren
id|current
comma
id|timer_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|new_setting
op_eq
l_int|NULL
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|new_spec
comma
id|new_setting
comma
r_sizeof
(paren
id|new_spec
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|good_timespec
c_func
(paren
op_amp
id|new_spec.it_interval
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|good_timespec
c_func
(paren
op_amp
id|new_spec.it_value
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|do_timer_settime
c_func
(paren
id|timr
comma
id|flags
comma
op_amp
id|new_spec
comma
id|old_setting
ques
c_cond
op_amp
id|old_spec
suffix:colon
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_setting
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|old_setting
comma
op_amp
id|old_spec
comma
r_sizeof
(paren
id|old_spec
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|unlock_timer
c_func
(paren
id|timr
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Delete a POSIX.1b interval timer. */
DECL|function|sys_timer_delete
id|asmlinkage
r_int
id|sys_timer_delete
c_func
(paren
id|timer_t
id|timer_id
)paren
(brace
r_struct
id|k_itimer
op_star
id|timr
suffix:semicolon
id|timr
op_assign
id|lock_timer
c_func
(paren
id|current
comma
id|timer_id
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|timr-&gt;it_timer
)paren
suffix:semicolon
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|current-&gt;posix_timers-&gt;its_lock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|timr
)paren
suffix:semicolon
id|current-&gt;posix_timers-&gt;itimer
(braket
id|timer_id
)braket
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|current-&gt;posix_timers-&gt;its_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
