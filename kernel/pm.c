multiline_comment|/*&n; *  pm.c - Power management interface&n; *&n; *  Copyright (C) 2000 Andrew Henroid&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/pm.h&gt;
DECL|variable|pm_active
r_int
id|pm_active
suffix:semicolon
DECL|variable|pm_devs_lock
r_static
id|spinlock_t
id|pm_devs_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_static
id|LIST_HEAD
c_func
(paren
id|pm_devs
)paren
suffix:semicolon
multiline_comment|/**&n; *&t;pm_register - register a device with power management&n; *&t;@type: device type &n; *&t;@id: device ID&n; *&t;@callback: callback function&n; *&n; *&t;Add a device to the list of devices that wish to be notified about&n; *&t;power management events. A &amp;pm_dev structure is returned on success,&n; *&t;on failure the return is %NULL.&n; */
DECL|function|pm_register
r_struct
id|pm_dev
op_star
id|pm_register
c_func
(paren
id|pm_dev_t
id|type
comma
r_int
r_int
id|id
comma
id|pm_callback
id|callback
)paren
(brace
r_struct
id|pm_dev
op_star
id|dev
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|pm_dev
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|memset
c_func
(paren
id|dev
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|dev
)paren
)paren
suffix:semicolon
id|dev-&gt;type
op_assign
id|type
suffix:semicolon
id|dev-&gt;id
op_assign
id|id
suffix:semicolon
id|dev-&gt;callback
op_assign
id|callback
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pm_devs_lock
comma
id|flags
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|dev-&gt;entry
comma
op_amp
id|pm_devs
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pm_devs_lock
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
id|dev
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;pm_unregister -  unregister a device with power management&n; *&t;@dev: device to unregister&n; *&n; *&t;Remove a device from the power management notification lists. The&n; *&t;dev passed must be a handle previously returned by pm_register.&n; */
DECL|function|pm_unregister
r_void
id|pm_unregister
c_func
(paren
r_struct
id|pm_dev
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|pm_devs_lock
comma
id|flags
)paren
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|dev-&gt;entry
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|pm_devs_lock
comma
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;pm_unregister_all - unregister all devices with matching callback&n; *&t;@callback: callback function pointer&n; *&n; *&t;Unregister every device that would call the callback passed. This&n; *&t;is primarily meant as a helper function for loadable modules. It&n; *&t;enables a module to give up all its managed devices without keeping&n; *&t;its own private list.&n; */
DECL|function|pm_unregister_all
r_void
id|pm_unregister_all
c_func
(paren
id|pm_callback
id|callback
)paren
(brace
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|callback
)paren
r_return
suffix:semicolon
id|entry
op_assign
id|pm_devs.next
suffix:semicolon
r_while
c_loop
(paren
id|entry
op_ne
op_amp
id|pm_devs
)paren
(brace
r_struct
id|pm_dev
op_star
id|dev
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|pm_dev
comma
id|entry
)paren
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;callback
op_eq
id|callback
)paren
id|pm_unregister
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;pm_send - send request to a single device&n; *&t;@dev: device to send to&n; *&t;@rqst: power management request&n; *&t;@data: data for the callback&n; *&n; *&t;Issue a power management request to a given device. The &n; *&t;%PM_SUSPEND and %PM_RESUME events are handled specially. The&n; *&t;data field must hold the intended next state. No call is made&n; *&t;if the state matches.&n; *&n; *&t;BUGS: what stops two power management requests occuring in parallel&n; *&t;and conflicting.&n; */
DECL|function|pm_send
r_int
id|pm_send
c_func
(paren
r_struct
id|pm_dev
op_star
id|dev
comma
id|pm_request_t
id|rqst
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_int
id|prev_state
comma
id|next_state
suffix:semicolon
r_switch
c_cond
(paren
id|rqst
)paren
(brace
r_case
id|PM_SUSPEND
suffix:colon
r_case
id|PM_RESUME
suffix:colon
id|prev_state
op_assign
id|dev-&gt;state
suffix:semicolon
id|next_state
op_assign
(paren
r_int
)paren
id|data
suffix:semicolon
r_if
c_cond
(paren
id|prev_state
op_ne
id|next_state
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;callback
)paren
id|status
op_assign
(paren
op_star
id|dev-&gt;callback
)paren
(paren
id|dev
comma
id|rqst
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
(brace
id|dev-&gt;state
op_assign
id|next_state
suffix:semicolon
id|dev-&gt;prev_state
op_assign
id|prev_state
suffix:semicolon
)brace
)brace
r_else
(brace
id|dev-&gt;prev_state
op_assign
id|prev_state
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|dev-&gt;callback
)paren
id|status
op_assign
(paren
op_star
id|dev-&gt;callback
)paren
(paren
id|dev
comma
id|rqst
comma
id|data
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n; * Undo incomplete request&n; */
DECL|function|pm_undo_all
r_static
r_void
id|pm_undo_all
c_func
(paren
r_struct
id|pm_dev
op_star
id|last
)paren
(brace
r_struct
id|list_head
op_star
id|entry
op_assign
id|last-&gt;entry.prev
suffix:semicolon
r_while
c_loop
(paren
id|entry
op_ne
op_amp
id|pm_devs
)paren
(brace
r_struct
id|pm_dev
op_star
id|dev
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|pm_dev
comma
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;state
op_ne
id|dev-&gt;prev_state
)paren
(brace
multiline_comment|/* previous state was zero (running) resume or&n;&t;&t;&t; * previous state was non-zero (suspended) suspend&n;&t;&t;&t; */
id|pm_request_t
id|undo
op_assign
(paren
id|dev-&gt;prev_state
ques
c_cond
id|PM_SUSPEND
suffix:colon
id|PM_RESUME
)paren
suffix:semicolon
id|pm_send
c_func
(paren
id|dev
comma
id|undo
comma
(paren
r_void
op_star
)paren
id|dev-&gt;prev_state
)paren
suffix:semicolon
)brace
id|entry
op_assign
id|entry-&gt;prev
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; *&t;pm_send_all - send request to all managed devices&n; *&t;@rqst: power management request&n; *&t;@data: data for the callback&n; *&n; *&t;Issue a power management request to a all devices. The &n; *&t;%PM_SUSPEND events are handled specially. Any device is &n; *&t;permitted to fail a suspend by returning a non zero (error)&n; *&t;value from its callback function. If any device vetoes a &n; *&t;suspend request then all other devices that have suspended &n; *&t;during the processing of this request are restored to their&n; *&t;previous state.&n; *&n; *&t;Zero is returned on success. If a suspend fails then the status&n; *&t;from the device that vetoes the suspend is returned.&n; *&n; *&t;BUGS: what stops two power management requests occuring in parallel&n; *&t;and conflicting.&n; */
DECL|function|pm_send_all
r_int
id|pm_send_all
c_func
(paren
id|pm_request_t
id|rqst
comma
r_void
op_star
id|data
)paren
(brace
r_struct
id|list_head
op_star
id|entry
op_assign
id|pm_devs.next
suffix:semicolon
r_while
c_loop
(paren
id|entry
op_ne
op_amp
id|pm_devs
)paren
(brace
r_struct
id|pm_dev
op_star
id|dev
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|pm_dev
comma
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;callback
)paren
(brace
r_int
id|status
op_assign
id|pm_send
c_func
(paren
id|dev
comma
id|rqst
comma
id|data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
multiline_comment|/* return devices to previous state on&n;&t;&t;&t;&t; * failed suspend request&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|rqst
op_eq
id|PM_SUSPEND
)paren
id|pm_undo_all
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
)brace
id|entry
op_assign
id|entry-&gt;next
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;pm_find  - find a device&n; *&t;@type: type of device&n; *&t;@from: where to start looking&n; *&n; *&t;Scan the power management list for devices of a specific type. The&n; *&t;return value for a matching device may be passed to further calls&n; *&t;to this function to find further matches. A %NULL indicates the end&n; *&t;of the list. &n; *&n; *&t;To search from the beginning pass %NULL as the @from value.&n; */
DECL|function|pm_find
r_struct
id|pm_dev
op_star
id|pm_find
c_func
(paren
id|pm_dev_t
id|type
comma
r_struct
id|pm_dev
op_star
id|from
)paren
(brace
r_struct
id|list_head
op_star
id|entry
op_assign
id|from
ques
c_cond
id|from-&gt;entry.next
suffix:colon
id|pm_devs.next
suffix:semicolon
r_while
c_loop
(paren
id|entry
op_ne
op_amp
id|pm_devs
)paren
(brace
r_struct
id|pm_dev
op_star
id|dev
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|pm_dev
comma
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|PM_UNKNOWN_DEV
op_logical_or
id|dev-&gt;type
op_eq
id|type
)paren
r_return
id|dev
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pm_register
id|EXPORT_SYMBOL
c_func
(paren
id|pm_register
)paren
suffix:semicolon
DECL|variable|pm_unregister
id|EXPORT_SYMBOL
c_func
(paren
id|pm_unregister
)paren
suffix:semicolon
DECL|variable|pm_unregister_all
id|EXPORT_SYMBOL
c_func
(paren
id|pm_unregister_all
)paren
suffix:semicolon
DECL|variable|pm_send
id|EXPORT_SYMBOL
c_func
(paren
id|pm_send
)paren
suffix:semicolon
DECL|variable|pm_send_all
id|EXPORT_SYMBOL
c_func
(paren
id|pm_send_all
)paren
suffix:semicolon
DECL|variable|pm_find
id|EXPORT_SYMBOL
c_func
(paren
id|pm_find
)paren
suffix:semicolon
DECL|variable|pm_active
id|EXPORT_SYMBOL
c_func
(paren
id|pm_active
)paren
suffix:semicolon
eof
