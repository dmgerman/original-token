multiline_comment|/*&n; * The &quot;user cache&quot;.&n; *&n; * (C) Copyright 1991-2000 Linus Torvalds&n; *&n; * We have a per-user structure to keep track of how many&n; * processes, files etc the user has claimed, in order to be&n; * able to have per-user limits for system resources. &n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
multiline_comment|/*&n; * UID task count cache, to get fast user lookup in &quot;alloc_uid&quot;&n; * when changing user ID&squot;s (ie setuid() and friends).&n; */
DECL|macro|UIDHASH_SZ
mdefine_line|#define UIDHASH_SZ&t;(256)
DECL|variable|uidhash
r_static
r_struct
id|user_struct
op_star
id|uidhash
(braket
id|UIDHASH_SZ
)braket
suffix:semicolon
DECL|variable|uidhash_lock
id|spinlock_t
id|uidhash_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|root_user
r_struct
id|user_struct
id|root_user
op_assign
(brace
id|__count
suffix:colon
id|ATOMIC_INIT
c_func
(paren
l_int|1
)paren
comma
id|processes
suffix:colon
id|ATOMIC_INIT
c_func
(paren
l_int|1
)paren
comma
id|files
suffix:colon
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
)brace
suffix:semicolon
DECL|variable|uid_cachep
r_static
id|kmem_cache_t
op_star
id|uid_cachep
suffix:semicolon
DECL|macro|uidhashfn
mdefine_line|#define uidhashfn(uid)&t;(((uid &gt;&gt; 8) ^ uid) &amp; (UIDHASH_SZ - 1))
multiline_comment|/*&n; * These routines must be called with the uidhash spinlock held!&n; */
DECL|function|uid_hash_insert
r_static
r_inline
r_void
id|uid_hash_insert
c_func
(paren
r_struct
id|user_struct
op_star
id|up
comma
r_int
r_int
id|hashent
)paren
(brace
r_if
c_cond
(paren
(paren
id|up-&gt;next
op_assign
id|uidhash
(braket
id|hashent
)braket
)paren
op_ne
l_int|NULL
)paren
(brace
id|uidhash
(braket
id|hashent
)braket
op_member_access_from_pointer
id|pprev
op_assign
op_amp
id|up-&gt;next
suffix:semicolon
)brace
id|up-&gt;pprev
op_assign
op_amp
id|uidhash
(braket
id|hashent
)braket
suffix:semicolon
id|uidhash
(braket
id|hashent
)braket
op_assign
id|up
suffix:semicolon
)brace
DECL|function|uid_hash_remove
r_static
r_inline
r_void
id|uid_hash_remove
c_func
(paren
r_struct
id|user_struct
op_star
id|up
)paren
(brace
r_if
c_cond
(paren
id|up-&gt;next
)paren
(brace
id|up-&gt;next-&gt;pprev
op_assign
id|up-&gt;pprev
suffix:semicolon
)brace
op_star
id|up-&gt;pprev
op_assign
id|up-&gt;next
suffix:semicolon
)brace
DECL|function|uid_hash_find
r_static
r_inline
r_struct
id|user_struct
op_star
id|uid_hash_find
c_func
(paren
r_int
r_int
id|uid
comma
r_int
r_int
id|hashent
)paren
(brace
r_struct
id|user_struct
op_star
id|up
comma
op_star
id|next
suffix:semicolon
id|next
op_assign
id|uidhash
(braket
id|hashent
)braket
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|up
op_assign
id|next
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
(brace
id|next
op_assign
id|up-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|up-&gt;uid
op_ne
id|uid
)paren
r_continue
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|up-&gt;__count
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
id|up
suffix:semicolon
)brace
multiline_comment|/*&n; * For SMP, we need to re-test the user struct counter&n; * after having aquired the spinlock. This allows us to do&n; * the common case (not freeing anything) without having&n; * any locking.&n; */
macro_line|#ifdef CONFIG_SMP
DECL|macro|uid_hash_free
mdefine_line|#define uid_hash_free(up)&t;(!atomic_read(&amp;(up)-&gt;__count))
macro_line|#else
DECL|macro|uid_hash_free
mdefine_line|#define uid_hash_free(up)&t;(1)
macro_line|#endif
DECL|function|free_uid
r_void
id|free_uid
c_func
(paren
r_struct
id|user_struct
op_star
id|up
)paren
(brace
r_if
c_cond
(paren
id|up
)paren
(brace
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
op_amp
id|up-&gt;__count
)paren
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|uidhash_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uid_hash_free
c_func
(paren
id|up
)paren
)paren
(brace
id|uid_hash_remove
c_func
(paren
id|up
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|uid_cachep
comma
id|up
)paren
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|uidhash_lock
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|alloc_uid
r_struct
id|user_struct
op_star
id|alloc_uid
c_func
(paren
id|uid_t
id|uid
)paren
(brace
r_int
r_int
id|hashent
op_assign
id|uidhashfn
c_func
(paren
id|uid
)paren
suffix:semicolon
r_struct
id|user_struct
op_star
id|up
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|uidhash_lock
)paren
suffix:semicolon
id|up
op_assign
id|uid_hash_find
c_func
(paren
id|uid
comma
id|hashent
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|uidhash_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|up
)paren
(brace
r_struct
id|user_struct
op_star
r_new
suffix:semicolon
r_new
op_assign
id|kmem_cache_alloc
c_func
(paren
id|uid_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
r_new
)paren
r_return
l_int|NULL
suffix:semicolon
r_new
op_member_access_from_pointer
id|uid
op_assign
id|uid
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|__count
comma
l_int|1
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|processes
comma
l_int|0
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
r_new
op_member_access_from_pointer
id|files
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Before adding this, check whether we raced&n;&t;&t; * on adding the same user already..&n;&t;&t; */
id|spin_lock
c_func
(paren
op_amp
id|uidhash_lock
)paren
suffix:semicolon
id|up
op_assign
id|uid_hash_find
c_func
(paren
id|uid
comma
id|hashent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|up
)paren
(brace
id|kmem_cache_free
c_func
(paren
id|uid_cachep
comma
r_new
)paren
suffix:semicolon
)brace
r_else
(brace
id|uid_hash_insert
c_func
(paren
r_new
comma
id|hashent
)paren
suffix:semicolon
id|up
op_assign
r_new
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|uidhash_lock
)paren
suffix:semicolon
)brace
r_return
id|up
suffix:semicolon
)brace
DECL|function|uid_cache_init
r_static
r_int
id|__init
id|uid_cache_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|uid_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;uid_cache&quot;
comma
r_sizeof
(paren
r_struct
id|user_struct
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uid_cachep
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Cannot create uid taskcount SLAB cache&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|UIDHASH_SZ
suffix:semicolon
id|i
op_increment
)paren
(brace
id|uidhash
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Insert the root user immediately - init already runs with this */
id|uid_hash_insert
c_func
(paren
op_amp
id|root_user
comma
id|uidhashfn
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|uid_cache_init
id|module_init
c_func
(paren
id|uid_cache_init
)paren
suffix:semicolon
eof
