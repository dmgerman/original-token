macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/mm.h&gt;&t;&t;/* defines GFP_KERNEL */
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
multiline_comment|/*&n; * Originally by Anonymous (as far as I know...)&n; * Linux version by Bas Laarhoven &lt;bas@vimec.nl&gt;&n; * 0.99.14 version by Jon Tombs &lt;jon@gtex02.us.es&gt;,&n; *&n; * Heavily modified by Bjorn Ekwall &lt;bj0rn@blox.se&gt; May 1994 (C)&n; * This source is covered by the GNU GPL, the same as all kernel sources.&n; *&n; * Features:&n; *&t;- Supports stacked modules (removable only of there are no dependents).&n; *&t;- Supports table of symbols defined by the modules.&n; *&t;- Supports /proc/ksyms, showing value, name and owner of all&n; *&t;  the symbols defined by all modules (in stack order).&n; *&t;- Added module dependencies information into /proc/modules&n; *&t;- Supports redefines of all symbols, for streams-like behaviour.&n; *&t;- Compatible with older versions of insmod.&n; *&n; */
macro_line|#ifdef DEBUG_MODULE
DECL|macro|PRINTK
mdefine_line|#define PRINTK(a) printk a
macro_line|#else
DECL|macro|PRINTK
mdefine_line|#define PRINTK(a) /* */
macro_line|#endif
DECL|variable|kernel_module
r_static
r_struct
id|module
id|kernel_module
suffix:semicolon
DECL|variable|module_list
r_static
r_struct
id|module
op_star
id|module_list
op_assign
op_amp
id|kernel_module
suffix:semicolon
DECL|variable|freeing_modules
r_static
r_int
id|freeing_modules
suffix:semicolon
multiline_comment|/* true if some modules are marked for deletion */
r_static
r_struct
id|module
op_star
id|find_module
c_func
(paren
r_const
r_char
op_star
id|name
)paren
suffix:semicolon
r_static
r_int
id|get_mod_name
c_func
(paren
r_char
op_star
id|user_name
comma
r_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|free_modules
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * Called at boot time&n; */
DECL|function|init_modules
r_void
id|init_modules
c_func
(paren
r_void
)paren
(brace
r_extern
r_struct
id|symbol_table
id|symbol_table
suffix:semicolon
multiline_comment|/* in kernel/ksyms.c */
r_struct
id|internal_symbol
op_star
id|sym
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sym
op_assign
id|symbol_table.symbol
suffix:semicolon
id|sym-&gt;name
suffix:semicolon
op_increment
id|sym
comma
op_increment
id|i
)paren
suffix:semicolon
id|symbol_table.n_symbols
op_assign
id|i
suffix:semicolon
id|kernel_module.symtab
op_assign
op_amp
id|symbol_table
suffix:semicolon
id|kernel_module.state
op_assign
id|MOD_RUNNING
suffix:semicolon
multiline_comment|/* Hah! */
id|kernel_module.name
op_assign
l_string|&quot;&quot;
suffix:semicolon
)brace
r_int
DECL|function|rename_module_symbol
id|rename_module_symbol
c_func
(paren
r_char
op_star
id|old_name
comma
r_char
op_star
id|new_name
)paren
(brace
r_struct
id|internal_symbol
op_star
id|sym
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* keep gcc silent */
r_if
c_cond
(paren
id|module_list-&gt;symtab
)paren
(brace
id|sym
op_assign
id|module_list-&gt;symtab-&gt;symbol
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|module_list-&gt;symtab-&gt;n_symbols
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_increment
id|sym
comma
op_decrement
id|i
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|sym-&gt;name
comma
id|old_name
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* found it! */
id|sym-&gt;name
op_assign
id|new_name
suffix:semicolon
multiline_comment|/* done! */
id|PRINTK
c_func
(paren
(paren
l_string|&quot;renamed %s to %s&bslash;n&quot;
comma
id|old_name
comma
id|new_name
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* it worked! */
)brace
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;rename %s to %s failed!&bslash;n&quot;
comma
id|old_name
comma
id|new_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* not there... */
multiline_comment|/*&n;&t; * This one will change the name of the first matching symbol!&n;&t; *&n;&t; * With this function, you can replace the name of a symbol defined&n;&t; * in the current module with a new name, e.g. when you want to insert&n;&t; * your own function instead of a previously defined function&n;&t; * with the same name.&n;&t; *&n;&t; * &quot;Normal&quot; usage:&n;&t; *&n;&t; * bogus_function(int params)&n;&t; * {&n;&t; *&t;do something &quot;smart&quot;;&n;&t; *&t;return real_function(params);&n;&t; * }&n;&t; *&n;&t; * ...&n;&t; *&n;&t; * init_module()&n;&t; * {&n;&t; *&t;if (rename_module_symbol(&quot;_bogus_function&quot;, &quot;_real_function&quot;))&n;&t; *&t;&t;printk(&quot;yep!&bslash;n&quot;);&n;&t; *&t;else&n;&t; *&t;&t;printk(&quot;no way!&bslash;n&quot;);&n;&t; * ...&n;&t; * }&n;&t; *&n;&t; * When loading this module, real_function will be resolved&n;&t; * to the real function address.&n;&t; * All later loaded modules that refer to &quot;real_function()&quot; will&n;&t; * then really call &quot;bogus_function()&quot; instead!!!&n;&t; *&n;&t; * This feature will give you ample opportunities to get to know&n;&t; * the taste of your foot when you stuff it into your mouth!!!&n;&t; */
)brace
multiline_comment|/*&n; * Allocate space for a module.&n; */
id|asmlinkage
r_int
DECL|function|sys_create_module
id|sys_create_module
c_func
(paren
r_char
op_star
id|module_name
comma
r_int
r_int
id|size
)paren
(brace
r_struct
id|module
op_star
id|mp
suffix:semicolon
r_void
op_star
id|addr
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|npages
suffix:semicolon
r_int
id|sspace
op_assign
r_sizeof
(paren
r_struct
id|module
)paren
op_plus
id|MOD_MAX_NAME
suffix:semicolon
r_char
id|name
(braket
id|MOD_MAX_NAME
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|module_name
op_eq
l_int|NULL
op_logical_or
id|size
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|get_mod_name
c_func
(paren
id|module_name
comma
id|name
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|find_module
c_func
(paren
id|name
)paren
op_ne
l_int|NULL
)paren
(brace
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mp
op_assign
(paren
r_struct
id|module
op_star
)paren
id|kmalloc
c_func
(paren
id|sspace
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|strcpy
c_func
(paren
(paren
r_char
op_star
)paren
(paren
id|mp
op_plus
l_int|1
)paren
comma
id|name
)paren
suffix:semicolon
multiline_comment|/* why not? */
id|npages
op_assign
(paren
id|size
op_plus
r_sizeof
(paren
r_int
)paren
op_plus
l_int|4095
)paren
op_div
l_int|4096
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_assign
id|vmalloc
c_func
(paren
id|npages
op_star
l_int|4096
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|kfree_s
c_func
(paren
id|mp
comma
id|sspace
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|mp-&gt;next
op_assign
id|module_list
suffix:semicolon
id|mp-&gt;ref
op_assign
l_int|NULL
suffix:semicolon
id|mp-&gt;symtab
op_assign
l_int|NULL
suffix:semicolon
id|mp-&gt;name
op_assign
(paren
r_char
op_star
)paren
(paren
id|mp
op_plus
l_int|1
)paren
suffix:semicolon
id|mp-&gt;size
op_assign
id|npages
suffix:semicolon
id|mp-&gt;addr
op_assign
id|addr
suffix:semicolon
id|mp-&gt;state
op_assign
id|MOD_UNINITIALIZED
suffix:semicolon
id|mp-&gt;cleanup
op_assign
l_int|NULL
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
id|addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set use count to zero */
id|module_list
op_assign
id|mp
suffix:semicolon
multiline_comment|/* link it in */
id|PRINTK
c_func
(paren
(paren
l_string|&quot;module `%s&squot; (%lu pages @ 0x%08lx) created&bslash;n&quot;
comma
id|mp-&gt;name
comma
(paren
r_int
r_int
)paren
id|mp-&gt;size
comma
(paren
r_int
r_int
)paren
id|mp-&gt;addr
)paren
)paren
suffix:semicolon
r_return
(paren
r_int
)paren
id|addr
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize a module.&n; */
id|asmlinkage
r_int
DECL|function|sys_init_module
id|sys_init_module
c_func
(paren
r_char
op_star
id|module_name
comma
r_char
op_star
id|code
comma
r_int
id|codesize
comma
r_struct
id|mod_routines
op_star
id|routines
comma
r_struct
id|symbol_table
op_star
id|symtab
)paren
(brace
r_struct
id|module
op_star
id|mp
suffix:semicolon
r_struct
id|symbol_table
op_star
id|newtab
suffix:semicolon
r_char
id|name
(braket
id|MOD_MAX_NAME
)braket
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|mod_routines
id|rt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* A little bit of protection... we &quot;know&quot; where the user stack is... */
r_if
c_cond
(paren
id|symtab
op_logical_and
(paren
(paren
r_int
r_int
)paren
id|symtab
OG
l_int|0xb0000000
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;warning: you are using an old insmod, no symbols will be inserted!&bslash;n&quot;
)paren
suffix:semicolon
id|symtab
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * First reclaim any memory from dead modules that where not&n;&t; * freed when deleted. Should I think be done by timers when&n;&t; * the module was deleted - Jon.&n;&t; */
id|free_modules
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|get_mod_name
c_func
(paren
id|module_name
comma
id|name
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|error
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;initializing module `%s&squot;, %d (0x%x) bytes&bslash;n&quot;
comma
id|name
comma
id|codesize
comma
id|codesize
)paren
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|rt
comma
id|routines
comma
r_sizeof
id|rt
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mp
op_assign
id|find_module
c_func
(paren
id|name
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|codesize
op_plus
r_sizeof
(paren
r_int
)paren
op_plus
l_int|4095
)paren
op_div
l_int|4096
OG
id|mp-&gt;size
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
(paren
r_char
op_star
)paren
id|mp-&gt;addr
op_plus
r_sizeof
(paren
r_int
)paren
comma
id|code
comma
id|codesize
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|mp-&gt;addr
op_plus
r_sizeof
(paren
r_int
)paren
op_plus
id|codesize
comma
l_int|0
comma
id|mp-&gt;size
op_star
l_int|4096
op_minus
(paren
id|codesize
op_plus
r_sizeof
(paren
r_int
)paren
)paren
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;module init entry = 0x%08lx, cleanup entry = 0x%08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|rt.init
comma
(paren
r_int
r_int
)paren
id|rt.cleanup
)paren
)paren
suffix:semicolon
id|mp-&gt;cleanup
op_assign
id|rt.cleanup
suffix:semicolon
multiline_comment|/* update kernel symbol table */
r_if
c_cond
(paren
id|symtab
)paren
(brace
multiline_comment|/* symtab == NULL means no new entries to handle */
r_struct
id|internal_symbol
op_star
id|sym
suffix:semicolon
r_struct
id|module_ref
op_star
id|ref
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|legal_start
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|symtab
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
(paren
r_char
op_star
)paren
(paren
op_amp
(paren
id|size
)paren
)paren
comma
id|symtab
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|newtab
op_assign
(paren
r_struct
id|symbol_table
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|symtab
comma
id|size
)paren
)paren
)paren
(brace
id|kfree_s
c_func
(paren
id|newtab
comma
id|size
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
(paren
r_char
op_star
)paren
(paren
id|newtab
)paren
comma
id|symtab
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* sanity check */
id|legal_start
op_assign
r_sizeof
(paren
r_struct
id|symbol_table
)paren
op_plus
id|newtab-&gt;n_symbols
op_star
r_sizeof
(paren
r_struct
id|internal_symbol
)paren
op_plus
id|newtab-&gt;n_refs
op_star
r_sizeof
(paren
r_struct
id|module_ref
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|newtab-&gt;n_symbols
OL
l_int|0
)paren
op_logical_or
(paren
id|newtab-&gt;n_refs
OL
l_int|0
)paren
op_logical_or
(paren
id|legal_start
OG
id|size
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Illegal symbol table! Rejected!&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|newtab
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* relocate name pointers, index referred from start of table */
r_for
c_loop
(paren
id|sym
op_assign
op_amp
(paren
id|newtab-&gt;symbol
(braket
l_int|0
)braket
)paren
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|newtab-&gt;n_symbols
suffix:semicolon
op_increment
id|sym
comma
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|sym-&gt;name
OL
id|legal_start
op_logical_or
id|size
op_le
(paren
r_int
)paren
id|sym-&gt;name
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Illegal symbol table! Rejected!&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|newtab
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* else */
id|sym-&gt;name
op_add_assign
(paren
r_int
)paren
id|newtab
suffix:semicolon
)brace
id|mp-&gt;symtab
op_assign
id|newtab
suffix:semicolon
multiline_comment|/* Update module references.&n;&t;&t; * On entry, from &quot;insmod&quot;, ref-&gt;module points to&n;&t;&t; * the referenced module!&n;&t;&t; * Now it will point to the current module instead!&n;&t;&t; * The ref structure becomes the first link in the linked&n;&t;&t; * list of references to the referenced module.&n;&t;&t; * Also, &quot;sym&quot; from above, points to the first ref entry!!!&n;&t;&t; */
r_for
c_loop
(paren
id|ref
op_assign
(paren
r_struct
id|module_ref
op_star
)paren
id|sym
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|newtab-&gt;n_refs
suffix:semicolon
op_increment
id|ref
comma
op_increment
id|i
)paren
(brace
multiline_comment|/* Check for valid reference */
r_struct
id|module
op_star
id|link
op_assign
id|module_list
suffix:semicolon
r_while
c_loop
(paren
id|link
op_logical_and
(paren
id|ref-&gt;module
op_ne
id|link
)paren
)paren
id|link
op_assign
id|link-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|link
op_eq
(paren
r_struct
id|module
op_star
)paren
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Non-module reference! Rejected!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ref-&gt;next
op_assign
id|ref-&gt;module-&gt;ref
suffix:semicolon
id|ref-&gt;module-&gt;ref
op_assign
id|ref
suffix:semicolon
id|ref-&gt;module
op_assign
id|mp
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
op_star
id|rt.init
)paren
(paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|mp-&gt;state
op_assign
id|MOD_RUNNING
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_delete_module
id|sys_delete_module
c_func
(paren
r_char
op_star
id|module_name
)paren
(brace
r_struct
id|module
op_star
id|mp
suffix:semicolon
r_char
id|name
(braket
id|MOD_MAX_NAME
)braket
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* else */
r_if
c_cond
(paren
id|module_name
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|get_mod_name
c_func
(paren
id|module_name
comma
id|name
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mp
op_assign
id|find_module
c_func
(paren
id|name
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mp-&gt;ref
op_ne
l_int|NULL
)paren
op_logical_or
(paren
id|GET_USE_COUNT
c_func
(paren
id|mp
)paren
op_ne
l_int|0
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;state
op_eq
id|MOD_RUNNING
)paren
(paren
op_star
id|mp-&gt;cleanup
)paren
(paren
)paren
suffix:semicolon
id|mp-&gt;state
op_assign
id|MOD_DELETED
suffix:semicolon
)brace
id|free_modules
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy the kernel symbol table to user space.  If the argument is null,&n; * just return the size of the table.&n; *&n; * Note that the transient module symbols are copied _first_,&n; * in lifo order!!!&n; *&n; * The symbols to &quot;insmod&quot; are according to the &quot;old&quot; format: struct kernel_sym,&n; * which is actually quite handy for this purpose.&n; * Note that insmod inserts a struct symbol_table later on...&n; * (as that format is quite handy for the kernel...)&n; *&n; * For every module, the first (pseudo)symbol copied is the module name&n; * and the address of the module struct.&n; * This lets &quot;insmod&quot; keep track of references, and build the array of&n; * struct module_refs in the symbol table.&n; * The format of the module name is &quot;#module&quot;, so that &quot;insmod&quot; can easily&n; * notice when a module name comes along. Also, this will make it possible&n; * to use old versions of &quot;insmod&quot;, albeit with reduced functionality...&n; * The &quot;kernel&quot; module has an empty name.&n; */
id|asmlinkage
r_int
DECL|function|sys_get_kernel_syms
id|sys_get_kernel_syms
c_func
(paren
r_struct
id|kernel_sym
op_star
id|table
)paren
(brace
r_struct
id|internal_symbol
op_star
id|from
suffix:semicolon
r_struct
id|kernel_sym
id|isym
suffix:semicolon
r_struct
id|kernel_sym
op_star
id|to
suffix:semicolon
r_struct
id|module
op_star
id|mp
op_assign
id|module_list
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|nmodsyms
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|mp
op_assign
id|module_list
suffix:semicolon
id|mp
suffix:semicolon
id|mp
op_assign
id|mp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;symtab
op_logical_and
id|mp-&gt;symtab-&gt;n_symbols
)paren
(brace
multiline_comment|/* include the count for the module name! */
id|nmodsyms
op_add_assign
id|mp-&gt;symtab-&gt;n_symbols
op_plus
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|table
op_ne
l_int|NULL
)paren
(brace
id|to
op_assign
id|table
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|to
comma
id|nmodsyms
op_star
r_sizeof
(paren
op_star
id|table
)paren
)paren
)paren
)paren
r_return
id|i
suffix:semicolon
multiline_comment|/* copy all module symbols first (always LIFO order) */
r_for
c_loop
(paren
id|mp
op_assign
id|module_list
suffix:semicolon
id|mp
suffix:semicolon
id|mp
op_assign
id|mp-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|mp-&gt;state
op_eq
id|MOD_RUNNING
)paren
op_logical_and
(paren
id|mp-&gt;symtab
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|mp-&gt;symtab-&gt;n_symbols
OG
l_int|0
)paren
)paren
(brace
multiline_comment|/* magic: write module info as a pseudo symbol */
id|isym.value
op_assign
(paren
r_int
r_int
)paren
id|mp
suffix:semicolon
id|sprintf
c_func
(paren
id|isym.name
comma
l_string|&quot;#%s&quot;
comma
id|mp-&gt;name
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|to
comma
op_amp
id|isym
comma
r_sizeof
id|isym
)paren
suffix:semicolon
op_increment
id|to
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|mp-&gt;symtab-&gt;n_symbols
comma
id|from
op_assign
id|mp-&gt;symtab-&gt;symbol
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
comma
op_increment
id|from
comma
op_increment
id|to
)paren
(brace
id|isym.value
op_assign
(paren
r_int
r_int
)paren
id|from-&gt;addr
suffix:semicolon
id|strncpy
c_func
(paren
id|isym.name
comma
id|from-&gt;name
comma
r_sizeof
id|isym.name
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|to
comma
op_amp
id|isym
comma
r_sizeof
id|isym
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
id|nmodsyms
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy the name of a module from user space.&n; */
r_int
DECL|function|get_mod_name
id|get_mod_name
c_func
(paren
r_char
op_star
id|user_name
comma
r_char
op_star
id|buf
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|buf
(braket
id|i
)braket
op_assign
id|get_fs_byte
c_func
(paren
id|user_name
op_plus
id|i
)paren
)paren
op_ne
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_increment
id|i
op_ge
id|MOD_MAX_NAME
)paren
r_return
op_minus
id|E2BIG
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Look for a module by name, ignoring modules marked for deletion.&n; */
r_struct
id|module
op_star
DECL|function|find_module
id|find_module
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|module
op_star
id|mp
suffix:semicolon
r_for
c_loop
(paren
id|mp
op_assign
id|module_list
suffix:semicolon
id|mp
suffix:semicolon
id|mp
op_assign
id|mp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;state
op_eq
id|MOD_DELETED
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|mp-&gt;name
comma
id|name
)paren
)paren
r_break
suffix:semicolon
)brace
r_return
id|mp
suffix:semicolon
)brace
r_static
r_void
DECL|function|drop_refs
id|drop_refs
c_func
(paren
r_struct
id|module
op_star
id|mp
)paren
(brace
r_struct
id|module
op_star
id|step
suffix:semicolon
r_struct
id|module_ref
op_star
id|prev
suffix:semicolon
r_struct
id|module_ref
op_star
id|ref
suffix:semicolon
r_for
c_loop
(paren
id|step
op_assign
id|module_list
suffix:semicolon
id|step
suffix:semicolon
id|step
op_assign
id|step-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|prev
op_assign
id|ref
op_assign
id|step-&gt;ref
suffix:semicolon
id|ref
suffix:semicolon
id|ref
op_assign
id|prev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|ref-&gt;module
op_eq
id|mp
)paren
(brace
r_if
c_cond
(paren
id|ref
op_eq
id|step-&gt;ref
)paren
id|step-&gt;ref
op_assign
id|ref-&gt;next
suffix:semicolon
r_else
id|prev-&gt;next
op_assign
id|ref-&gt;next
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* every module only references once! */
)brace
r_else
id|prev
op_assign
id|ref
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Try to free modules which have been marked for deletion.  Returns nonzero&n; * if a module was actually freed.&n; */
r_int
DECL|function|free_modules
id|free_modules
c_func
(paren
r_void
)paren
(brace
r_struct
id|module
op_star
id|mp
suffix:semicolon
r_struct
id|module
op_star
op_star
id|mpp
suffix:semicolon
r_int
id|did_deletion
suffix:semicolon
id|did_deletion
op_assign
l_int|0
suffix:semicolon
id|freeing_modules
op_assign
l_int|0
suffix:semicolon
id|mpp
op_assign
op_amp
id|module_list
suffix:semicolon
r_while
c_loop
(paren
(paren
id|mp
op_assign
op_star
id|mpp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;state
op_ne
id|MOD_DELETED
)paren
(brace
id|mpp
op_assign
op_amp
id|mp-&gt;next
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|GET_USE_COUNT
c_func
(paren
id|mp
)paren
op_ne
l_int|0
)paren
(brace
id|freeing_modules
op_assign
l_int|1
suffix:semicolon
id|mpp
op_assign
op_amp
id|mp-&gt;next
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* delete it */
op_star
id|mpp
op_assign
id|mp-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;symtab
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;symtab-&gt;n_refs
)paren
id|drop_refs
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;symtab-&gt;size
)paren
id|kfree_s
c_func
(paren
id|mp-&gt;symtab
comma
id|mp-&gt;symtab-&gt;size
)paren
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|mp-&gt;addr
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|mp
comma
r_sizeof
(paren
r_struct
id|module
)paren
op_plus
id|MOD_MAX_NAME
)paren
suffix:semicolon
id|did_deletion
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_return
id|did_deletion
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by the /proc file system to return a current list of modules.&n; */
DECL|function|get_module_list
r_int
id|get_module_list
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_char
op_star
id|q
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|module
op_star
id|mp
suffix:semicolon
r_struct
id|module_ref
op_star
id|ref
suffix:semicolon
r_char
id|size
(braket
l_int|32
)braket
suffix:semicolon
id|p
op_assign
id|buf
suffix:semicolon
multiline_comment|/* Do not show the kernel pseudo module */
r_for
c_loop
(paren
id|mp
op_assign
id|module_list
suffix:semicolon
id|mp
op_logical_and
id|mp-&gt;next
suffix:semicolon
id|mp
op_assign
id|mp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p
op_minus
id|buf
OG
l_int|4096
op_minus
l_int|100
)paren
r_break
suffix:semicolon
multiline_comment|/* avoid overflowing buffer */
id|q
op_assign
id|mp-&gt;name
suffix:semicolon
id|i
op_assign
l_int|20
suffix:semicolon
r_while
c_loop
(paren
op_star
id|q
)paren
(brace
op_star
id|p
op_increment
op_assign
op_star
id|q
op_increment
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|size
comma
l_string|&quot;%d&quot;
comma
id|mp-&gt;size
)paren
suffix:semicolon
id|i
op_sub_assign
id|strlen
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_le
l_int|0
)paren
id|i
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|i
op_ge
l_int|0
)paren
op_star
id|p
op_increment
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|q
op_assign
id|size
suffix:semicolon
r_while
c_loop
(paren
op_star
id|q
)paren
op_star
id|p
op_increment
op_assign
op_star
id|q
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;state
op_eq
id|MOD_UNINITIALIZED
)paren
id|q
op_assign
l_string|&quot;  (uninitialized)&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mp-&gt;state
op_eq
id|MOD_RUNNING
)paren
id|q
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mp-&gt;state
op_eq
id|MOD_DELETED
)paren
id|q
op_assign
l_string|&quot;  (deleted)&quot;
suffix:semicolon
r_else
id|q
op_assign
l_string|&quot;  (bad state)&quot;
suffix:semicolon
r_while
c_loop
(paren
op_star
id|q
)paren
op_star
id|p
op_increment
op_assign
op_star
id|q
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ref
op_assign
id|mp-&gt;ref
)paren
op_ne
l_int|NULL
)paren
(brace
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;t&squot;
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_char|&squot;[&squot;
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|ref
suffix:semicolon
id|ref
op_assign
id|ref-&gt;next
)paren
(brace
id|q
op_assign
id|ref-&gt;module-&gt;name
suffix:semicolon
r_while
c_loop
(paren
op_star
id|q
)paren
op_star
id|p
op_increment
op_assign
op_star
id|q
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ref-&gt;next
)paren
op_star
id|p
op_increment
op_assign
l_char|&squot; &squot;
suffix:semicolon
)brace
op_star
id|p
op_increment
op_assign
l_char|&squot;]&squot;
suffix:semicolon
)brace
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
)brace
r_return
id|p
op_minus
id|buf
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by the /proc file system to return a current list of ksyms.&n; */
DECL|function|get_ksyms_list
r_int
id|get_ksyms_list
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_struct
id|module
op_star
id|mp
suffix:semicolon
r_struct
id|internal_symbol
op_star
id|sym
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
op_star
id|p
op_assign
id|buf
suffix:semicolon
r_for
c_loop
(paren
id|mp
op_assign
id|module_list
suffix:semicolon
id|mp
suffix:semicolon
id|mp
op_assign
id|mp-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|mp-&gt;state
op_eq
id|MOD_RUNNING
)paren
op_logical_and
(paren
id|mp-&gt;symtab
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|mp-&gt;symtab-&gt;n_symbols
OG
l_int|0
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|mp-&gt;symtab-&gt;n_symbols
comma
id|sym
op_assign
id|mp-&gt;symtab-&gt;symbol
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
comma
op_increment
id|sym
)paren
(brace
r_if
c_cond
(paren
id|p
op_minus
id|buf
OG
l_int|4096
op_minus
l_int|100
)paren
(brace
id|strcat
c_func
(paren
id|p
comma
l_string|&quot;...&bslash;n&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|strlen
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
id|p
op_minus
id|buf
suffix:semicolon
multiline_comment|/* avoid overflowing buffer */
)brace
r_if
c_cond
(paren
id|mp-&gt;name
(braket
l_int|0
)braket
)paren
(brace
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%08lx %s&bslash;t[%s]&bslash;n&quot;
comma
(paren
r_int
)paren
id|sym-&gt;addr
comma
id|sym-&gt;name
comma
id|mp-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%08lx %s&bslash;n&quot;
comma
(paren
r_int
)paren
id|sym-&gt;addr
comma
id|sym-&gt;name
)paren
suffix:semicolon
)brace
id|p
op_add_assign
id|strlen
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
id|p
op_minus
id|buf
suffix:semicolon
)brace
eof
