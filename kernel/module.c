macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/module.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/kmod.h&gt;
multiline_comment|/*&n; * Originally by Anonymous (as far as I know...)&n; * Linux version by Bas Laarhoven &lt;bas@vimec.nl&gt;&n; * 0.99.14 version by Jon Tombs &lt;jon@gtex02.us.es&gt;,&n; * Heavily modified by Bjorn Ekwall &lt;bj0rn@blox.se&gt; May 1994 (C)&n; * Rewritten by Richard Henderson &lt;rth@tamu.edu&gt; Dec 1996&n; * Add MOD_INITIALIZING Keith Owens &lt;kaos@ocs.com.au&gt; Nov 1999&n; * Add kallsyms support, Keith Owens &lt;kaos@ocs.com.au&gt; Apr 2000&n; * Add asm/module support, IA64 has special requirements.  Keith Owens &lt;kaos@ocs.com.au&gt; Sep 2000&n; * Fix assorted bugs in module verification.  Keith Owens &lt;kaos@ocs.com.au&gt; Sep 2000&n; * Fix sys_init_module race, Andrew Morton &lt;andrewm@uow.edu.au&gt; Oct 2000&n; *     http://www.uwsg.iu.edu/hypermail/linux/kernel/0008.3/0379.html&n; * Replace xxx_module_symbol with inter_module_xxx.  Keith Owens &lt;kaos@ocs.com.au&gt; Oct 2000&n; *&n; * This source is covered by the GNU GPL, the same as all kernel sources.&n; */
macro_line|#if defined(CONFIG_MODULES) || defined(CONFIG_KALLSYMS)
r_extern
r_struct
id|module_symbol
id|__start___ksymtab
(braket
)braket
suffix:semicolon
r_extern
r_struct
id|module_symbol
id|__stop___ksymtab
(braket
)braket
suffix:semicolon
r_extern
r_const
r_struct
id|exception_table_entry
id|__start___ex_table
(braket
)braket
suffix:semicolon
r_extern
r_const
r_struct
id|exception_table_entry
id|__stop___ex_table
(braket
)braket
suffix:semicolon
r_extern
r_const
r_char
id|__start___kallsyms
(braket
)braket
id|__attribute__
(paren
(paren
id|weak
)paren
)paren
suffix:semicolon
r_extern
r_const
r_char
id|__stop___kallsyms
(braket
)braket
id|__attribute__
(paren
(paren
id|weak
)paren
)paren
suffix:semicolon
DECL|variable|kernel_module
r_static
r_struct
id|module
id|kernel_module
op_assign
(brace
id|size_of_struct
suffix:colon
r_sizeof
(paren
r_struct
id|module
)paren
comma
id|name
suffix:colon
l_string|&quot;&quot;
comma
id|uc
suffix:colon
(brace
id|ATOMIC_INIT
c_func
(paren
l_int|1
)paren
)brace
comma
id|flags
suffix:colon
id|MOD_RUNNING
comma
id|syms
suffix:colon
id|__start___ksymtab
comma
id|ex_table_start
suffix:colon
id|__start___ex_table
comma
id|ex_table_end
suffix:colon
id|__stop___ex_table
comma
id|kallsyms_start
suffix:colon
id|__start___kallsyms
comma
id|kallsyms_end
suffix:colon
id|__stop___kallsyms
comma
)brace
suffix:semicolon
DECL|variable|module_list
r_struct
id|module
op_star
id|module_list
op_assign
op_amp
id|kernel_module
suffix:semicolon
macro_line|#endif&t;/* defined(CONFIG_MODULES) || defined(CONFIG_KALLSYMS) */
multiline_comment|/* inter_module functions are always available, even when the kernel is&n; * compiled without modules.  Consumers of inter_module_xxx routines&n; * will always work, even when both are built into the kernel, this&n; * approach removes lots of #ifdefs in mainline code.&n; */
DECL|variable|ime_list
r_static
r_struct
id|list_head
id|ime_list
op_assign
id|LIST_HEAD_INIT
c_func
(paren
id|ime_list
)paren
suffix:semicolon
DECL|variable|ime_lock
r_static
id|spinlock_t
id|ime_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|kmalloc_failed
r_static
r_int
id|kmalloc_failed
suffix:semicolon
multiline_comment|/**&n; * inter_module_register - register a new set of inter module data.&n; * @im_name: an arbitrary string to identify the data, must be unique&n; * @owner: module that is registering the data, always use THIS_MODULE&n; * @userdata: pointer to arbitrary userdata to be registered&n; *&n; * Description: Check that the im_name has not already been registered,&n; * complain if it has.  For new data, add it to the inter_module_entry&n; * list.&n; */
DECL|function|inter_module_register
r_void
id|inter_module_register
c_func
(paren
r_const
r_char
op_star
id|im_name
comma
r_struct
id|module
op_star
id|owner
comma
r_const
r_void
op_star
id|userdata
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_struct
id|inter_module_entry
op_star
id|ime
comma
op_star
id|ime_new
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ime_new
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|ime
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
multiline_comment|/* Overloaded kernel, not fatal */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Aiee, inter_module_register: cannot kmalloc entry for &squot;%s&squot;&bslash;n&quot;
comma
id|im_name
)paren
suffix:semicolon
id|kmalloc_failed
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ime_new
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|ime_new
)paren
)paren
suffix:semicolon
id|ime_new-&gt;im_name
op_assign
id|im_name
suffix:semicolon
id|ime_new-&gt;owner
op_assign
id|owner
suffix:semicolon
id|ime_new-&gt;userdata
op_assign
id|userdata
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ime_lock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|ime_list
)paren
(brace
id|ime
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|inter_module_entry
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ime-&gt;im_name
comma
id|im_name
)paren
op_eq
l_int|0
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|ime_lock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ime_new
)paren
suffix:semicolon
multiline_comment|/* Program logic error, fatal */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;inter_module_register: duplicate im_name &squot;%s&squot;&quot;
comma
id|im_name
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|list_add
c_func
(paren
op_amp
(paren
id|ime_new-&gt;list
)paren
comma
op_amp
id|ime_list
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ime_lock
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * inter_module_unregister - unregister a set of inter module data.&n; * @im_name: an arbitrary string to identify the data, must be unique&n; *&n; * Description: Check that the im_name has been registered, complain if&n; * it has not.  For existing data, remove it from the&n; * inter_module_entry list.&n; */
DECL|function|inter_module_unregister
r_void
id|inter_module_unregister
c_func
(paren
r_const
r_char
op_star
id|im_name
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_struct
id|inter_module_entry
op_star
id|ime
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ime_lock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|ime_list
)paren
(brace
id|ime
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|inter_module_entry
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ime-&gt;im_name
comma
id|im_name
)paren
op_eq
l_int|0
)paren
(brace
id|list_del
c_func
(paren
op_amp
(paren
id|ime-&gt;list
)paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ime_lock
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ime
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|ime_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kmalloc_failed
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;inter_module_unregister: no entry for &squot;%s&squot;, &quot;
l_string|&quot;probably caused by previous kmalloc failure&bslash;n&quot;
comma
id|im_name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Program logic error, fatal */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;inter_module_unregister: no entry for &squot;%s&squot;&quot;
comma
id|im_name
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/**&n; * inter_module_get - return arbitrary userdata from another module.&n; * @im_name: an arbitrary string to identify the data, must be unique&n; *&n; * Description: If the im_name has not been registered, return NULL.&n; * Try to increment the use count on the owning module, if that fails&n; * then return NULL.  Otherwise return the userdata.&n; */
DECL|function|inter_module_get
r_const
r_void
op_star
id|inter_module_get
c_func
(paren
r_const
r_char
op_star
id|im_name
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_struct
id|inter_module_entry
op_star
id|ime
suffix:semicolon
r_const
r_void
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ime_lock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|ime_list
)paren
(brace
id|ime
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|inter_module_entry
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ime-&gt;im_name
comma
id|im_name
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|try_inc_mod_count
c_func
(paren
id|ime-&gt;owner
)paren
)paren
id|result
op_assign
id|ime-&gt;userdata
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|ime_lock
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/**&n; * inter_module_get_request - im get with automatic request_module.&n; * @im_name: an arbitrary string to identify the data, must be unique&n; * @modname: module that is expected to register im_name&n; *&n; * Description: If inter_module_get fails, do request_module then retry.&n; */
DECL|function|inter_module_get_request
r_const
r_void
op_star
id|inter_module_get_request
c_func
(paren
r_const
r_char
op_star
id|im_name
comma
r_const
r_char
op_star
id|modname
)paren
(brace
r_const
r_void
op_star
id|result
op_assign
id|inter_module_get
c_func
(paren
id|im_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
id|request_module
c_func
(paren
id|modname
)paren
suffix:semicolon
id|result
op_assign
id|inter_module_get
c_func
(paren
id|im_name
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/**&n; * inter_module_put - release use of data from another module.&n; * @im_name: an arbitrary string to identify the data, must be unique&n; *&n; * Description: If the im_name has not been registered, complain,&n; * otherwise decrement the use count on the owning module.&n; */
DECL|function|inter_module_put
r_void
id|inter_module_put
c_func
(paren
r_const
r_char
op_star
id|im_name
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_struct
id|inter_module_entry
op_star
id|ime
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|ime_lock
)paren
suffix:semicolon
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|ime_list
)paren
(brace
id|ime
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|inter_module_entry
comma
id|list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|ime-&gt;im_name
comma
id|im_name
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ime-&gt;owner
)paren
id|__MOD_DEC_USE_COUNT
c_func
(paren
id|ime-&gt;owner
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|ime_lock
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|spin_unlock
c_func
(paren
op_amp
id|ime_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;inter_module_put: no entry for &squot;%s&squot;&quot;
comma
id|im_name
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#if defined(CONFIG_MODULES)&t;/* The rest of the source */
r_static
r_int
id|get_mod_name
c_func
(paren
r_const
r_char
op_star
id|user_name
comma
r_char
op_star
op_star
id|buf
)paren
suffix:semicolon
r_static
r_void
id|put_mod_name
c_func
(paren
r_char
op_star
id|buf
)paren
suffix:semicolon
r_struct
id|module
op_star
id|find_module
c_func
(paren
r_const
r_char
op_star
id|name
)paren
suffix:semicolon
r_void
id|free_module
c_func
(paren
r_struct
id|module
op_star
comma
r_int
id|tag_freed
)paren
suffix:semicolon
multiline_comment|/*&n; * Called at boot time&n; */
DECL|function|init_modules
r_void
id|__init
id|init_modules
c_func
(paren
r_void
)paren
(brace
id|kernel_module.nsyms
op_assign
id|__stop___ksymtab
op_minus
id|__start___ksymtab
suffix:semicolon
macro_line|#ifdef __alpha__
id|__asm__
c_func
(paren
l_string|&quot;stq $29,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|kernel_module.gp
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Copy the name of a module from user space.&n; */
r_static
r_inline
r_int
DECL|function|get_mod_name
id|get_mod_name
c_func
(paren
r_const
r_char
op_star
id|user_name
comma
r_char
op_star
op_star
id|buf
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|page
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|retval
op_assign
id|strncpy_from_user
c_func
(paren
(paren
r_char
op_star
)paren
id|page
comma
id|user_name
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|retval
OL
id|PAGE_SIZE
)paren
(brace
op_star
id|buf
op_assign
(paren
r_char
op_star
)paren
id|page
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|retval
op_assign
op_minus
id|ENAMETOOLONG
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|put_mod_name
id|put_mod_name
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate space for a module.&n; */
id|asmlinkage
r_int
r_int
DECL|function|sys_create_module
id|sys_create_module
c_func
(paren
r_const
r_char
op_star
id|name_user
comma
r_int
id|size
)paren
(brace
r_char
op_star
id|name
suffix:semicolon
r_int
id|namelen
comma
id|error
suffix:semicolon
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_MODULE
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|namelen
op_assign
id|get_mod_name
c_func
(paren
id|name_user
comma
op_amp
id|name
)paren
)paren
OL
l_int|0
)paren
(brace
id|error
op_assign
id|namelen
suffix:semicolon
r_goto
id|err0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
OL
r_sizeof
(paren
r_struct
id|module
)paren
op_plus
id|namelen
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|find_module
c_func
(paren
id|name
)paren
op_ne
l_int|NULL
)paren
(brace
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|err1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mod
op_assign
(paren
r_struct
id|module
op_star
)paren
id|module_map
c_func
(paren
id|size
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|mod
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|mod
)paren
)paren
suffix:semicolon
id|mod-&gt;size_of_struct
op_assign
r_sizeof
(paren
op_star
id|mod
)paren
suffix:semicolon
id|mod-&gt;next
op_assign
id|module_list
suffix:semicolon
id|mod-&gt;name
op_assign
(paren
r_char
op_star
)paren
(paren
id|mod
op_plus
l_int|1
)paren
suffix:semicolon
id|mod-&gt;size
op_assign
id|size
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
(paren
id|mod
op_plus
l_int|1
)paren
comma
id|name
comma
id|namelen
op_plus
l_int|1
)paren
suffix:semicolon
id|put_mod_name
c_func
(paren
id|name
)paren
suffix:semicolon
id|module_list
op_assign
id|mod
suffix:semicolon
multiline_comment|/* link it in */
id|error
op_assign
(paren
r_int
)paren
id|mod
suffix:semicolon
r_goto
id|err0
suffix:semicolon
id|err1
suffix:colon
id|put_mod_name
c_func
(paren
id|name
)paren
suffix:semicolon
id|err0
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize a module.&n; */
id|asmlinkage
r_int
DECL|function|sys_init_module
id|sys_init_module
c_func
(paren
r_const
r_char
op_star
id|name_user
comma
r_struct
id|module
op_star
id|mod_user
)paren
(brace
r_struct
id|module
id|mod_tmp
comma
op_star
id|mod
suffix:semicolon
r_char
op_star
id|name
comma
op_star
id|n_name
comma
op_star
id|name_tmp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|namelen
comma
id|n_namelen
comma
id|i
comma
id|error
suffix:semicolon
r_int
r_int
id|mod_user_size
suffix:semicolon
r_struct
id|module_ref
op_star
id|dep
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_MODULE
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|namelen
op_assign
id|get_mod_name
c_func
(paren
id|name_user
comma
op_amp
id|name
)paren
)paren
OL
l_int|0
)paren
(brace
id|error
op_assign
id|namelen
suffix:semicolon
r_goto
id|err0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mod
op_assign
id|find_module
c_func
(paren
id|name
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|err1
suffix:semicolon
)brace
multiline_comment|/* Check module header size.  We allow a bit of slop over the&n;&t;   size we are familiar with to cope with a version of insmod&n;&t;   for a newer kernel.  But don&squot;t over do it. */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|get_user
c_func
(paren
id|mod_user_size
comma
op_amp
id|mod_user-&gt;size_of_struct
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|err1
suffix:semicolon
r_if
c_cond
(paren
id|mod_user_size
template_param
r_sizeof
(paren
r_struct
id|module
)paren
op_plus
l_int|16
op_star
r_sizeof
(paren
r_void
op_star
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: Invalid module header size.&bslash;n&quot;
id|KERN_ERR
l_string|&quot;A new version of the modutils is likely &quot;
l_string|&quot;needed.&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err1
suffix:semicolon
)brace
multiline_comment|/* Hold the current contents while we play with the user&squot;s idea&n;&t;   of righteousness.  */
id|mod_tmp
op_assign
op_star
id|mod
suffix:semicolon
id|name_tmp
op_assign
id|kmalloc
c_func
(paren
id|strlen
c_func
(paren
id|mod-&gt;name
)paren
op_plus
l_int|1
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* Where&squot;s kstrdup()? */
r_if
c_cond
(paren
id|name_tmp
op_eq
l_int|NULL
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err1
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|name_tmp
comma
id|mod-&gt;name
)paren
suffix:semicolon
id|error
op_assign
id|copy_from_user
c_func
(paren
id|mod
comma
id|mod_user
comma
id|mod_user_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
multiline_comment|/* Sanity check the size of the module.  */
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;size
OG
id|mod_tmp.size
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: Size of initialized module &quot;
l_string|&quot;exceeds size of created module.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
multiline_comment|/* Make sure all interesting pointers are sane.  */
r_if
c_cond
(paren
op_logical_neg
id|mod_bound
c_func
(paren
id|mod-&gt;name
comma
id|namelen
comma
id|mod
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;name out of bounds.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;nsyms
op_logical_and
op_logical_neg
id|mod_bound
c_func
(paren
id|mod-&gt;syms
comma
id|mod-&gt;nsyms
comma
id|mod
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;syms out of bounds.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;ndeps
op_logical_and
op_logical_neg
id|mod_bound
c_func
(paren
id|mod-&gt;deps
comma
id|mod-&gt;ndeps
comma
id|mod
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;deps out of bounds.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;init
op_logical_and
op_logical_neg
id|mod_bound
c_func
(paren
id|mod-&gt;init
comma
l_int|0
comma
id|mod
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;init out of bounds.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;cleanup
op_logical_and
op_logical_neg
id|mod_bound
c_func
(paren
id|mod-&gt;cleanup
comma
l_int|0
comma
id|mod
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;cleanup out of bounds.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;ex_table_start
OG
id|mod-&gt;ex_table_end
op_logical_or
(paren
id|mod-&gt;ex_table_start
op_logical_and
op_logical_neg
(paren
(paren
r_int
r_int
)paren
id|mod-&gt;ex_table_start
op_ge
(paren
(paren
r_int
r_int
)paren
id|mod
op_plus
id|mod-&gt;size_of_struct
)paren
op_logical_and
(paren
(paren
r_int
r_int
)paren
id|mod-&gt;ex_table_end
OL
(paren
r_int
r_int
)paren
id|mod
op_plus
id|mod-&gt;size
)paren
)paren
)paren
op_logical_or
(paren
(paren
(paren
r_int
r_int
)paren
id|mod-&gt;ex_table_start
op_minus
(paren
r_int
r_int
)paren
id|mod-&gt;ex_table_end
)paren
op_mod
r_sizeof
(paren
r_struct
id|exception_table_entry
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;ex_table_* invalid.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;flags
op_amp
op_complement
id|MOD_AUTOCLEAN
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;flags invalid.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
macro_line|#ifdef __alpha__
r_if
c_cond
(paren
op_logical_neg
id|mod_bound
c_func
(paren
id|mod-&gt;gp
op_minus
l_int|0x8000
comma
l_int|0
comma
id|mod
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;gp out of bounds.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|mod_member_present
c_func
(paren
id|mod
comma
id|can_unload
)paren
op_logical_and
id|mod-&gt;can_unload
op_logical_and
op_logical_neg
id|mod_bound
c_func
(paren
id|mod-&gt;can_unload
comma
l_int|0
comma
id|mod
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;can_unload out of bounds.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod_member_present
c_func
(paren
id|mod
comma
id|kallsyms_end
)paren
)paren
(brace
r_if
c_cond
(paren
id|mod-&gt;kallsyms_end
op_logical_and
(paren
op_logical_neg
id|mod_bound
c_func
(paren
id|mod-&gt;kallsyms_start
comma
l_int|0
comma
id|mod
)paren
op_logical_or
op_logical_neg
id|mod_bound
c_func
(paren
id|mod-&gt;kallsyms_end
comma
l_int|0
comma
id|mod
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;kallsyms out of bounds.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;kallsyms_start
OG
id|mod-&gt;kallsyms_end
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;kallsyms invalid.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|mod_member_present
c_func
(paren
id|mod
comma
id|archdata_end
)paren
)paren
(brace
r_if
c_cond
(paren
id|mod-&gt;archdata_end
op_logical_and
(paren
op_logical_neg
id|mod_bound
c_func
(paren
id|mod-&gt;archdata_start
comma
l_int|0
comma
id|mod
)paren
op_logical_or
op_logical_neg
id|mod_bound
c_func
(paren
id|mod-&gt;archdata_end
comma
l_int|0
comma
id|mod
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;archdata out of bounds.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;archdata_start
OG
id|mod-&gt;archdata_end
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;archdata invalid.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|mod_member_present
c_func
(paren
id|mod
comma
id|kernel_data
)paren
op_logical_and
id|mod-&gt;kernel_data
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;kernel_data must be zero.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
multiline_comment|/* Check that the user isn&squot;t doing something silly with the name.  */
r_if
c_cond
(paren
(paren
id|n_namelen
op_assign
id|get_mod_name
c_func
(paren
id|mod-&gt;name
op_minus
(paren
r_int
r_int
)paren
id|mod
op_plus
(paren
r_int
r_int
)paren
id|mod_user
comma
op_amp
id|n_name
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: get_mod_name failure.&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
id|n_namelen
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|namelen
op_ne
id|n_namelen
op_logical_or
id|strcmp
c_func
(paren
id|n_name
comma
id|mod_tmp.name
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: changed module name to &quot;
l_string|&quot;`%s&squot; from `%s&squot;&bslash;n&quot;
comma
id|n_name
comma
id|mod_tmp.name
)paren
suffix:semicolon
r_goto
id|err3
suffix:semicolon
)brace
multiline_comment|/* Ok, that&squot;s about all the sanity we can stomach; copy the rest.  */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
(paren
r_char
op_star
)paren
id|mod
op_plus
id|mod_user_size
comma
(paren
r_char
op_star
)paren
id|mod_user
op_plus
id|mod_user_size
comma
id|mod-&gt;size
op_minus
id|mod_user_size
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|err3
suffix:semicolon
)brace
r_if
c_cond
(paren
id|module_arch_init
c_func
(paren
id|mod
)paren
)paren
r_goto
id|err3
suffix:semicolon
multiline_comment|/* On some machines it is necessary to do something here&n;&t;   to make the I and D caches consistent.  */
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|mod
comma
(paren
r_int
r_int
)paren
id|mod
op_plus
id|mod-&gt;size
)paren
suffix:semicolon
id|mod-&gt;next
op_assign
id|mod_tmp.next
suffix:semicolon
id|mod-&gt;refs
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Sanity check the module&squot;s dependents */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|dep
op_assign
id|mod-&gt;deps
suffix:semicolon
id|i
OL
id|mod-&gt;ndeps
suffix:semicolon
op_increment
id|i
comma
op_increment
id|dep
)paren
(brace
r_struct
id|module
op_star
id|o
comma
op_star
id|d
op_assign
id|dep-&gt;dep
suffix:semicolon
multiline_comment|/* Make sure the indicated dependencies are really modules.  */
r_if
c_cond
(paren
id|d
op_eq
id|mod
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: self-referential &quot;
l_string|&quot;dependency in mod-&gt;deps.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err3
suffix:semicolon
)brace
multiline_comment|/* Scan the current modules for this dependency */
r_for
c_loop
(paren
id|o
op_assign
id|module_list
suffix:semicolon
id|o
op_ne
op_amp
id|kernel_module
op_logical_and
id|o
op_ne
id|d
suffix:semicolon
id|o
op_assign
id|o-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o
op_ne
id|d
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: found dependency that is &quot;
l_string|&quot;(no longer?) a module.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err3
suffix:semicolon
)brace
)brace
multiline_comment|/* Update module references.  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|dep
op_assign
id|mod-&gt;deps
suffix:semicolon
id|i
OL
id|mod-&gt;ndeps
suffix:semicolon
op_increment
id|i
comma
op_increment
id|dep
)paren
(brace
r_struct
id|module
op_star
id|d
op_assign
id|dep-&gt;dep
suffix:semicolon
id|dep-&gt;ref
op_assign
id|mod
suffix:semicolon
id|dep-&gt;next_ref
op_assign
id|d-&gt;refs
suffix:semicolon
id|d-&gt;refs
op_assign
id|dep
suffix:semicolon
multiline_comment|/* Being referenced by a dependent module counts as a&n;&t;&t;   use as far as kmod is concerned.  */
id|d-&gt;flags
op_or_assign
id|MOD_USED_ONCE
suffix:semicolon
)brace
multiline_comment|/* Free our temporary memory.  */
id|put_mod_name
c_func
(paren
id|n_name
)paren
suffix:semicolon
id|put_mod_name
c_func
(paren
id|name
)paren
suffix:semicolon
multiline_comment|/* Initialize the module.  */
id|mod-&gt;flags
op_or_assign
id|MOD_INITIALIZING
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|mod-&gt;uc.usecount
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;init
op_logical_and
(paren
id|error
op_assign
id|mod
op_member_access_from_pointer
id|init
c_func
(paren
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|mod-&gt;uc.usecount
comma
l_int|0
)paren
suffix:semicolon
id|mod-&gt;flags
op_and_assign
op_complement
id|MOD_INITIALIZING
suffix:semicolon
r_if
c_cond
(paren
id|error
OG
l_int|0
)paren
multiline_comment|/* Buggy module */
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|err0
suffix:semicolon
)brace
id|atomic_dec
c_func
(paren
op_amp
id|mod-&gt;uc.usecount
)paren
suffix:semicolon
multiline_comment|/* And set it running.  */
id|mod-&gt;flags
op_assign
(paren
id|mod-&gt;flags
op_or
id|MOD_RUNNING
)paren
op_amp
op_complement
id|MOD_INITIALIZING
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_goto
id|err0
suffix:semicolon
id|err3
suffix:colon
id|put_mod_name
c_func
(paren
id|n_name
)paren
suffix:semicolon
id|err2
suffix:colon
op_star
id|mod
op_assign
id|mod_tmp
suffix:semicolon
id|strcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|mod-&gt;name
comma
id|name_tmp
)paren
suffix:semicolon
multiline_comment|/* We know there is room for this */
id|err1
suffix:colon
id|put_mod_name
c_func
(paren
id|name
)paren
suffix:semicolon
id|err0
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|name_tmp
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|variable|unload_lock
r_static
id|spinlock_t
id|unload_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|try_inc_mod_count
r_int
id|try_inc_mod_count
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
r_int
id|res
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|mod
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|unload_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;flags
op_amp
id|MOD_DELETED
)paren
id|res
op_assign
l_int|0
suffix:semicolon
r_else
id|__MOD_INC_USE_COUNT
c_func
(paren
id|mod
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|unload_lock
)paren
suffix:semicolon
)brace
r_return
id|res
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_delete_module
id|sys_delete_module
c_func
(paren
r_const
r_char
op_star
id|name_user
)paren
(brace
r_struct
id|module
op_star
id|mod
comma
op_star
id|next
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|something_changed
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_MODULE
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name_user
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|get_mod_name
c_func
(paren
id|name_user
comma
op_amp
id|name
)paren
)paren
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|put_mod_name
c_func
(paren
id|name
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mod
op_assign
id|find_module
c_func
(paren
id|name
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|put_mod_name
c_func
(paren
id|name
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|put_mod_name
c_func
(paren
id|name
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;refs
op_ne
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|unload_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|__MOD_IN_USE
c_func
(paren
id|mod
)paren
)paren
(brace
id|mod-&gt;flags
op_or_assign
id|MOD_DELETED
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|unload_lock
)paren
suffix:semicolon
id|free_module
c_func
(paren
id|mod
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock
c_func
(paren
op_amp
id|unload_lock
)paren
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Do automatic reaping */
id|restart
suffix:colon
id|something_changed
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|mod
op_assign
id|module_list
suffix:semicolon
id|mod
op_ne
op_amp
id|kernel_module
suffix:semicolon
id|mod
op_assign
id|next
)paren
(brace
id|next
op_assign
id|mod-&gt;next
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|unload_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;refs
op_eq
l_int|NULL
op_logical_and
(paren
id|mod-&gt;flags
op_amp
id|MOD_AUTOCLEAN
)paren
op_logical_and
(paren
id|mod-&gt;flags
op_amp
id|MOD_RUNNING
)paren
op_logical_and
op_logical_neg
(paren
id|mod-&gt;flags
op_amp
id|MOD_DELETED
)paren
op_logical_and
(paren
id|mod-&gt;flags
op_amp
id|MOD_USED_ONCE
)paren
op_logical_and
op_logical_neg
id|__MOD_IN_USE
c_func
(paren
id|mod
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|mod-&gt;flags
op_amp
id|MOD_VISITED
)paren
op_logical_and
op_logical_neg
(paren
id|mod-&gt;flags
op_amp
id|MOD_JUST_FREED
)paren
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|unload_lock
)paren
suffix:semicolon
id|mod-&gt;flags
op_and_assign
op_complement
id|MOD_VISITED
suffix:semicolon
)brace
r_else
(brace
id|mod-&gt;flags
op_or_assign
id|MOD_DELETED
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|unload_lock
)paren
suffix:semicolon
id|free_module
c_func
(paren
id|mod
comma
l_int|1
)paren
suffix:semicolon
id|something_changed
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|spin_unlock
c_func
(paren
op_amp
id|unload_lock
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|something_changed
)paren
r_goto
id|restart
suffix:semicolon
r_for
c_loop
(paren
id|mod
op_assign
id|module_list
suffix:semicolon
id|mod
op_ne
op_amp
id|kernel_module
suffix:semicolon
id|mod
op_assign
id|mod-&gt;next
)paren
id|mod-&gt;flags
op_and_assign
op_complement
id|MOD_JUST_FREED
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Query various bits about modules.  */
r_static
r_int
DECL|function|qm_modules
id|qm_modules
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|bufsize
comma
r_int
op_star
id|ret
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_int
id|nmod
comma
id|space
comma
id|len
suffix:semicolon
id|nmod
op_assign
id|space
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|mod
op_assign
id|module_list
suffix:semicolon
id|mod
op_ne
op_amp
id|kernel_module
suffix:semicolon
id|mod
op_assign
id|mod-&gt;next
comma
op_increment
id|nmod
)paren
(brace
id|len
op_assign
id|strlen
c_func
(paren
id|mod-&gt;name
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|bufsize
)paren
r_goto
id|calc_space_needed
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|mod-&gt;name
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|buf
op_add_assign
id|len
suffix:semicolon
id|bufsize
op_sub_assign
id|len
suffix:semicolon
id|space
op_add_assign
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|nmod
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
id|calc_space_needed
suffix:colon
id|space
op_add_assign
id|len
suffix:semicolon
r_while
c_loop
(paren
(paren
id|mod
op_assign
id|mod-&gt;next
)paren
op_ne
op_amp
id|kernel_module
)paren
id|space
op_add_assign
id|strlen
c_func
(paren
id|mod-&gt;name
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|space
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_static
r_int
DECL|function|qm_deps
id|qm_deps
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
r_char
op_star
id|buf
comma
r_int
id|bufsize
comma
r_int
op_star
id|ret
)paren
(brace
r_int
id|i
comma
id|space
comma
id|len
suffix:semicolon
r_if
c_cond
(paren
id|mod
op_eq
op_amp
id|kernel_module
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MOD_CAN_QUERY
c_func
(paren
id|mod
)paren
)paren
r_if
c_cond
(paren
id|put_user
c_func
(paren
l_int|0
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
id|space
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mod-&gt;ndeps
suffix:semicolon
op_increment
id|i
)paren
(brace
r_const
r_char
op_star
id|dep_name
op_assign
id|mod-&gt;deps
(braket
id|i
)braket
dot
id|dep-&gt;name
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|dep_name
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|bufsize
)paren
r_goto
id|calc_space_needed
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|dep_name
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|buf
op_add_assign
id|len
suffix:semicolon
id|bufsize
op_sub_assign
id|len
suffix:semicolon
id|space
op_add_assign
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|i
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
id|calc_space_needed
suffix:colon
id|space
op_add_assign
id|len
suffix:semicolon
r_while
c_loop
(paren
op_increment
id|i
OL
id|mod-&gt;ndeps
)paren
id|space
op_add_assign
id|strlen
c_func
(paren
id|mod-&gt;deps
(braket
id|i
)braket
dot
id|dep-&gt;name
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|space
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_static
r_int
DECL|function|qm_refs
id|qm_refs
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
r_char
op_star
id|buf
comma
r_int
id|bufsize
comma
r_int
op_star
id|ret
)paren
(brace
r_int
id|nrefs
comma
id|space
comma
id|len
suffix:semicolon
r_struct
id|module_ref
op_star
id|ref
suffix:semicolon
r_if
c_cond
(paren
id|mod
op_eq
op_amp
id|kernel_module
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MOD_CAN_QUERY
c_func
(paren
id|mod
)paren
)paren
r_if
c_cond
(paren
id|put_user
c_func
(paren
l_int|0
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
id|space
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|nrefs
op_assign
l_int|0
comma
id|ref
op_assign
id|mod-&gt;refs
suffix:semicolon
id|ref
suffix:semicolon
op_increment
id|nrefs
comma
id|ref
op_assign
id|ref-&gt;next_ref
)paren
(brace
r_const
r_char
op_star
id|ref_name
op_assign
id|ref-&gt;ref-&gt;name
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|ref_name
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|bufsize
)paren
r_goto
id|calc_space_needed
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|ref_name
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|buf
op_add_assign
id|len
suffix:semicolon
id|bufsize
op_sub_assign
id|len
suffix:semicolon
id|space
op_add_assign
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|nrefs
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
id|calc_space_needed
suffix:colon
id|space
op_add_assign
id|len
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ref
op_assign
id|ref-&gt;next_ref
)paren
op_ne
l_int|NULL
)paren
id|space
op_add_assign
id|strlen
c_func
(paren
id|ref-&gt;ref-&gt;name
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|space
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_static
r_int
DECL|function|qm_symbols
id|qm_symbols
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
r_char
op_star
id|buf
comma
r_int
id|bufsize
comma
r_int
op_star
id|ret
)paren
(brace
r_int
id|i
comma
id|space
comma
id|len
suffix:semicolon
r_struct
id|module_symbol
op_star
id|s
suffix:semicolon
r_char
op_star
id|strings
suffix:semicolon
r_int
r_int
op_star
id|vals
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MOD_CAN_QUERY
c_func
(paren
id|mod
)paren
)paren
r_if
c_cond
(paren
id|put_user
c_func
(paren
l_int|0
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
id|space
op_assign
id|mod-&gt;nsyms
op_star
l_int|2
op_star
r_sizeof
(paren
r_void
op_star
)paren
suffix:semicolon
id|i
op_assign
id|len
op_assign
l_int|0
suffix:semicolon
id|s
op_assign
id|mod-&gt;syms
suffix:semicolon
r_if
c_cond
(paren
id|space
OG
id|bufsize
)paren
r_goto
id|calc_space_needed
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buf
comma
id|space
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|bufsize
op_sub_assign
id|space
suffix:semicolon
id|vals
op_assign
(paren
r_int
r_int
op_star
)paren
id|buf
suffix:semicolon
id|strings
op_assign
id|buf
op_plus
id|space
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|mod-&gt;nsyms
suffix:semicolon
op_increment
id|i
comma
op_increment
id|s
comma
id|vals
op_add_assign
l_int|2
)paren
(brace
id|len
op_assign
id|strlen
c_func
(paren
id|s-&gt;name
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|bufsize
)paren
r_goto
id|calc_space_needed
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|strings
comma
id|s-&gt;name
comma
id|len
)paren
op_logical_or
id|__put_user
c_func
(paren
id|s-&gt;value
comma
id|vals
op_plus
l_int|0
)paren
op_logical_or
id|__put_user
c_func
(paren
id|space
comma
id|vals
op_plus
l_int|1
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|strings
op_add_assign
id|len
suffix:semicolon
id|bufsize
op_sub_assign
id|len
suffix:semicolon
id|space
op_add_assign
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|i
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
id|calc_space_needed
suffix:colon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|mod-&gt;nsyms
suffix:semicolon
op_increment
id|i
comma
op_increment
id|s
)paren
id|space
op_add_assign
id|strlen
c_func
(paren
id|s-&gt;name
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|space
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_static
r_int
DECL|function|qm_info
id|qm_info
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
r_char
op_star
id|buf
comma
r_int
id|bufsize
comma
r_int
op_star
id|ret
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mod
op_eq
op_amp
id|kernel_module
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|module_info
)paren
op_le
id|bufsize
)paren
(brace
r_struct
id|module_info
id|info
suffix:semicolon
id|info.addr
op_assign
(paren
r_int
r_int
)paren
id|mod
suffix:semicolon
id|info.size
op_assign
id|mod-&gt;size
suffix:semicolon
id|info.flags
op_assign
id|mod-&gt;flags
suffix:semicolon
id|info.usecount
op_assign
(paren
id|mod_member_present
c_func
(paren
id|mod
comma
id|can_unload
)paren
op_logical_and
id|mod-&gt;can_unload
ques
c_cond
op_minus
l_int|1
suffix:colon
id|atomic_read
c_func
(paren
op_amp
id|mod-&gt;uc.usecount
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
op_amp
id|info
comma
r_sizeof
(paren
r_struct
id|module_info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
id|error
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
r_sizeof
(paren
r_struct
id|module_info
)paren
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_query_module
id|sys_query_module
c_func
(paren
r_const
r_char
op_star
id|name_user
comma
r_int
id|which
comma
r_char
op_star
id|buf
comma
r_int
id|bufsize
comma
r_int
op_star
id|ret
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_int
id|err
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name_user
op_eq
l_int|NULL
)paren
id|mod
op_assign
op_amp
id|kernel_module
suffix:semicolon
r_else
(brace
r_int
id|namelen
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_if
c_cond
(paren
(paren
id|namelen
op_assign
id|get_mod_name
c_func
(paren
id|name_user
comma
op_amp
id|name
)paren
)paren
OL
l_int|0
)paren
(brace
id|err
op_assign
id|namelen
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|namelen
op_eq
l_int|0
)paren
id|mod
op_assign
op_amp
id|kernel_module
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|mod
op_assign
id|find_module
c_func
(paren
id|name
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|put_mod_name
c_func
(paren
id|name
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|put_mod_name
c_func
(paren
id|name
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|which
)paren
(brace
r_case
l_int|0
suffix:colon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QM_MODULES
suffix:colon
id|err
op_assign
id|qm_modules
c_func
(paren
id|buf
comma
id|bufsize
comma
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QM_DEPS
suffix:colon
id|err
op_assign
id|qm_deps
c_func
(paren
id|mod
comma
id|buf
comma
id|bufsize
comma
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QM_REFS
suffix:colon
id|err
op_assign
id|qm_refs
c_func
(paren
id|mod
comma
id|buf
comma
id|bufsize
comma
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QM_SYMBOLS
suffix:colon
id|err
op_assign
id|qm_symbols
c_func
(paren
id|mod
comma
id|buf
comma
id|bufsize
comma
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QM_INFO
suffix:colon
id|err
op_assign
id|qm_info
c_func
(paren
id|mod
comma
id|buf
comma
id|bufsize
comma
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy the kernel symbol table to user space.  If the argument is&n; * NULL, just return the size of the table.&n; *&n; * This call is obsolete.  New programs should use query_module+QM_SYMBOLS&n; * which does not arbitrarily limit the length of symbols.&n; */
id|asmlinkage
r_int
DECL|function|sys_get_kernel_syms
id|sys_get_kernel_syms
c_func
(paren
r_struct
id|kernel_sym
op_star
id|table
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|kernel_sym
id|ksym
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mod
op_assign
id|module_list
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|mod
suffix:semicolon
id|mod
op_assign
id|mod-&gt;next
)paren
(brace
multiline_comment|/* include the count for the module name! */
id|i
op_add_assign
id|mod-&gt;nsyms
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|table
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* So that we don&squot;t give the user our stack content */
id|memset
(paren
op_amp
id|ksym
comma
l_int|0
comma
r_sizeof
(paren
id|ksym
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mod
op_assign
id|module_list
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|mod
suffix:semicolon
id|mod
op_assign
id|mod-&gt;next
)paren
(brace
r_struct
id|module_symbol
op_star
id|msym
suffix:semicolon
r_int
r_int
id|j
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MOD_CAN_QUERY
c_func
(paren
id|mod
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* magic: write module info as a pseudo symbol */
id|ksym.value
op_assign
(paren
r_int
r_int
)paren
id|mod
suffix:semicolon
id|ksym.name
(braket
l_int|0
)braket
op_assign
l_char|&squot;#&squot;
suffix:semicolon
id|strncpy
c_func
(paren
id|ksym.name
op_plus
l_int|1
comma
id|mod-&gt;name
comma
r_sizeof
(paren
id|ksym.name
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|ksym.name
(braket
r_sizeof
(paren
id|ksym.name
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|table
comma
op_amp
id|ksym
comma
r_sizeof
(paren
id|ksym
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
op_increment
id|i
comma
op_increment
id|table
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;nsyms
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
comma
id|msym
op_assign
id|mod-&gt;syms
suffix:semicolon
id|j
OL
id|mod-&gt;nsyms
suffix:semicolon
op_increment
id|j
comma
op_increment
id|msym
)paren
(brace
id|ksym.value
op_assign
id|msym-&gt;value
suffix:semicolon
id|strncpy
c_func
(paren
id|ksym.name
comma
id|msym-&gt;name
comma
r_sizeof
(paren
id|ksym.name
)paren
)paren
suffix:semicolon
id|ksym.name
(braket
r_sizeof
(paren
id|ksym.name
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|table
comma
op_amp
id|ksym
comma
r_sizeof
(paren
id|ksym
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
op_increment
id|i
comma
op_increment
id|table
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * Look for a module by name, ignoring modules marked for deletion.&n; */
r_struct
id|module
op_star
DECL|function|find_module
id|find_module
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_for
c_loop
(paren
id|mod
op_assign
id|module_list
suffix:semicolon
id|mod
suffix:semicolon
id|mod
op_assign
id|mod-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|mod-&gt;flags
op_amp
id|MOD_DELETED
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|mod-&gt;name
comma
id|name
)paren
)paren
r_break
suffix:semicolon
)brace
r_return
id|mod
suffix:semicolon
)brace
multiline_comment|/*&n; * Free the given module.&n; */
r_void
DECL|function|free_module
id|free_module
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
r_int
id|tag_freed
)paren
(brace
r_struct
id|module_ref
op_star
id|dep
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Let the module clean up.  */
r_if
c_cond
(paren
id|mod-&gt;flags
op_amp
id|MOD_RUNNING
)paren
(brace
r_if
c_cond
(paren
id|mod-&gt;cleanup
)paren
(brace
id|mod
op_member_access_from_pointer
id|cleanup
c_func
(paren
)paren
suffix:semicolon
)brace
id|mod-&gt;flags
op_and_assign
op_complement
id|MOD_RUNNING
suffix:semicolon
)brace
multiline_comment|/* Remove the module from the dependency lists.  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|dep
op_assign
id|mod-&gt;deps
suffix:semicolon
id|i
OL
id|mod-&gt;ndeps
suffix:semicolon
op_increment
id|i
comma
op_increment
id|dep
)paren
(brace
r_struct
id|module_ref
op_star
op_star
id|pp
suffix:semicolon
r_for
c_loop
(paren
id|pp
op_assign
op_amp
id|dep-&gt;dep-&gt;refs
suffix:semicolon
op_star
id|pp
op_ne
id|dep
suffix:semicolon
id|pp
op_assign
op_amp
(paren
op_star
id|pp
)paren
op_member_access_from_pointer
id|next_ref
)paren
r_continue
suffix:semicolon
op_star
id|pp
op_assign
id|dep-&gt;next_ref
suffix:semicolon
r_if
c_cond
(paren
id|tag_freed
op_logical_and
id|dep-&gt;dep-&gt;refs
op_eq
l_int|NULL
)paren
id|dep-&gt;dep-&gt;flags
op_or_assign
id|MOD_JUST_FREED
suffix:semicolon
)brace
multiline_comment|/* And from the main module list.  */
r_if
c_cond
(paren
id|mod
op_eq
id|module_list
)paren
(brace
id|module_list
op_assign
id|mod-&gt;next
suffix:semicolon
)brace
r_else
(brace
r_struct
id|module
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|module_list
suffix:semicolon
id|p-&gt;next
op_ne
id|mod
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
r_continue
suffix:semicolon
id|p-&gt;next
op_assign
id|mod-&gt;next
suffix:semicolon
)brace
multiline_comment|/* And free the memory.  */
id|module_unmap
c_func
(paren
id|mod
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by the /proc file system to return a current list of modules.&n; */
DECL|function|get_module_list
r_int
id|get_module_list
c_func
(paren
r_char
op_star
id|p
)paren
(brace
r_int
id|left
op_assign
id|PAGE_SIZE
suffix:semicolon
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_char
id|tmpstr
(braket
l_int|64
)braket
suffix:semicolon
r_struct
id|module_ref
op_star
id|ref
suffix:semicolon
r_for
c_loop
(paren
id|mod
op_assign
id|module_list
suffix:semicolon
id|mod
op_ne
op_amp
id|kernel_module
suffix:semicolon
id|mod
op_assign
id|mod-&gt;next
)paren
(brace
r_int
id|len
suffix:semicolon
r_const
r_char
op_star
id|q
suffix:semicolon
DECL|macro|safe_copy_str
mdefine_line|#define safe_copy_str(str, len)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;if (left &lt; len)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;goto fini;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;memcpy(p, str, len); p += len, left -= len;&t;&bslash;&n;&t;&t;} while (0)
DECL|macro|safe_copy_cstr
mdefine_line|#define safe_copy_cstr(str)&t;safe_copy_str(str, sizeof(str)-1)
id|len
op_assign
id|strlen
c_func
(paren
id|mod-&gt;name
)paren
suffix:semicolon
id|safe_copy_str
c_func
(paren
id|mod-&gt;name
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
l_int|20
op_minus
id|len
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|left
OL
id|len
)paren
r_goto
id|fini
suffix:semicolon
id|memset
c_func
(paren
id|p
comma
l_char|&squot; &squot;
comma
id|len
)paren
suffix:semicolon
id|p
op_add_assign
id|len
suffix:semicolon
id|left
op_sub_assign
id|len
suffix:semicolon
)brace
id|len
op_assign
id|sprintf
c_func
(paren
id|tmpstr
comma
l_string|&quot;%8lu&quot;
comma
id|mod-&gt;size
)paren
suffix:semicolon
id|safe_copy_str
c_func
(paren
id|tmpstr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;flags
op_amp
id|MOD_RUNNING
)paren
(brace
id|len
op_assign
id|sprintf
c_func
(paren
id|tmpstr
comma
l_string|&quot;%4ld&quot;
comma
(paren
id|mod_member_present
c_func
(paren
id|mod
comma
id|can_unload
)paren
op_logical_and
id|mod-&gt;can_unload
ques
c_cond
op_minus
l_int|1L
suffix:colon
(paren
r_int
)paren
id|atomic_read
c_func
(paren
op_amp
id|mod-&gt;uc.usecount
)paren
)paren
)paren
suffix:semicolon
id|safe_copy_str
c_func
(paren
id|tmpstr
comma
id|len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;flags
op_amp
id|MOD_DELETED
)paren
id|safe_copy_cstr
c_func
(paren
l_string|&quot; (deleted)&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mod-&gt;flags
op_amp
id|MOD_RUNNING
)paren
(brace
r_if
c_cond
(paren
id|mod-&gt;flags
op_amp
id|MOD_AUTOCLEAN
)paren
id|safe_copy_cstr
c_func
(paren
l_string|&quot; (autoclean)&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mod-&gt;flags
op_amp
id|MOD_USED_ONCE
)paren
)paren
id|safe_copy_cstr
c_func
(paren
l_string|&quot; (unused)&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mod-&gt;flags
op_amp
id|MOD_INITIALIZING
)paren
id|safe_copy_cstr
c_func
(paren
l_string|&quot; (initializing)&quot;
)paren
suffix:semicolon
r_else
id|safe_copy_cstr
c_func
(paren
l_string|&quot; (uninitialized)&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ref
op_assign
id|mod-&gt;refs
)paren
op_ne
l_int|NULL
)paren
(brace
id|safe_copy_cstr
c_func
(paren
l_string|&quot; [&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|q
op_assign
id|ref-&gt;ref-&gt;name
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|q
)paren
suffix:semicolon
id|safe_copy_str
c_func
(paren
id|q
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ref
op_assign
id|ref-&gt;next_ref
)paren
op_ne
l_int|NULL
)paren
id|safe_copy_cstr
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
id|safe_copy_cstr
c_func
(paren
l_string|&quot;]&quot;
)paren
suffix:semicolon
)brace
id|safe_copy_cstr
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
DECL|macro|safe_copy_str
macro_line|#undef safe_copy_str
DECL|macro|safe_copy_cstr
macro_line|#undef safe_copy_cstr
)brace
id|fini
suffix:colon
r_return
id|PAGE_SIZE
op_minus
id|left
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by the /proc file system to return a current list of ksyms.&n; */
r_int
DECL|function|get_ksyms_list
id|get_ksyms_list
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_char
op_star
id|p
op_assign
id|buf
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* code from  net/ipv4/proc.c */
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|mod
op_assign
id|module_list
suffix:semicolon
id|mod
suffix:semicolon
id|mod
op_assign
id|mod-&gt;next
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|module_symbol
op_star
id|sym
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MOD_CAN_QUERY
c_func
(paren
id|mod
)paren
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|mod-&gt;nsyms
comma
id|sym
op_assign
id|mod-&gt;syms
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
comma
op_increment
id|sym
)paren
(brace
id|p
op_assign
id|buf
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
op_star
id|mod-&gt;name
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%0*lx %s&bslash;t[%s]&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
l_int|2
op_star
r_sizeof
(paren
r_void
op_star
)paren
)paren
comma
id|sym-&gt;value
comma
id|sym-&gt;name
comma
id|mod-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%0*lx %s&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
l_int|2
op_star
r_sizeof
(paren
r_void
op_star
)paren
)paren
comma
id|sym-&gt;value
comma
id|sym-&gt;name
)paren
suffix:semicolon
)brace
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
r_goto
id|leave_the_loop
suffix:semicolon
)brace
)brace
id|leave_the_loop
suffix:colon
op_star
id|start
op_assign
id|buf
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#else&t;&t;/* CONFIG_MODULES */
multiline_comment|/* Dummy syscalls for people who don&squot;t want modules */
id|asmlinkage
r_int
r_int
DECL|function|sys_create_module
id|sys_create_module
c_func
(paren
r_const
r_char
op_star
id|name_user
comma
r_int
id|size
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_init_module
id|sys_init_module
c_func
(paren
r_const
r_char
op_star
id|name_user
comma
r_struct
id|module
op_star
id|mod_user
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_delete_module
id|sys_delete_module
c_func
(paren
r_const
r_char
op_star
id|name_user
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_query_module
id|sys_query_module
c_func
(paren
r_const
r_char
op_star
id|name_user
comma
r_int
id|which
comma
r_char
op_star
id|buf
comma
r_int
id|bufsize
comma
r_int
op_star
id|ret
)paren
(brace
multiline_comment|/* Let the program know about the new interface.  Not that&n;&t;   it&squot;ll do them much good.  */
r_if
c_cond
(paren
id|which
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_get_kernel_syms
id|sys_get_kernel_syms
c_func
(paren
r_struct
id|kernel_sym
op_star
id|table
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|try_inc_mod_count
r_int
id|try_inc_mod_count
c_func
(paren
r_struct
id|module
op_star
id|mod
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_MODULES */
eof
