macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/mm.h&gt;&t;&t;/* defines GFP_KERNEL */
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/config.h&gt;
multiline_comment|/*&n; * Originally by Anonymous (as far as I know...)&n; * Linux version by Bas Laarhoven &lt;bas@vimec.nl&gt;&n; * 0.99.14 version by Jon Tombs &lt;jon@gtex02.us.es&gt;,&n; *&n; * Heavily modified by Bjorn Ekwall &lt;bj0rn@blox.se&gt; May 1994 (C)&n; * This source is covered by the GNU GPL, the same as all kernel sources.&n; *&n; * Features:&n; *&t;- Supports stacked modules (removable only of there are no dependents).&n; *&t;- Supports table of symbols defined by the modules.&n; *&t;- Supports /proc/ksyms, showing value, name and owner of all&n; *&t;  the symbols defined by all modules (in stack order).&n; *&t;- Added module dependencies information into /proc/modules&n; *&t;- Supports redefines of all symbols, for streams-like behaviour.&n; *&t;- Compatible with older versions of insmod.&n; *&n; * New addition in December 1994: (Bjorn Ekwall, idea from Jacques Gelinas)&n; *&t;- Externally callable function:&n; *&n; *&t;&t;&quot;int register_symtab(struct symbol_table *)&quot;&n; *&n; *&t;  This function can be called from within the kernel,&n; *&t;  and ALSO from loadable modules.&n; *&t;  The goal is to assist in modularizing the kernel even more,&n; *&t;  and finally: reducing the number of entries in ksyms.c&n; *&t;  since every subsystem should now be able to decide and&n; *&t;  control exactly what symbols it wants to export, locally!&n; *&n; * On 1-Aug-95:  &lt;Matti.Aarnio@utu.fi&gt;  altered code to use same style as&n; *&t;&t; do  /proc/net/XXX  &quot;files&quot;.  Namely allow more than 4kB&n; *&t;&t; (or what the block size is) output.&n; *&n; *&t;- Use dummy syscall functions for users who disable all&n; *&t;  module support. Similar to kernel/sys.c (Paul Gortmaker)&n; */
macro_line|#ifdef CONFIG_MODULES&t;&t;/* a *big* #ifdef block... */
macro_line|#ifdef DEBUG_MODULE
DECL|macro|PRINTK
mdefine_line|#define PRINTK(a) printk a
macro_line|#else
DECL|macro|PRINTK
mdefine_line|#define PRINTK(a) /* */
macro_line|#endif
DECL|variable|kernel_module
r_static
r_struct
id|module
id|kernel_module
suffix:semicolon
DECL|variable|module_list
r_static
r_struct
id|module
op_star
id|module_list
op_assign
op_amp
id|kernel_module
suffix:semicolon
DECL|variable|freeing_modules
r_static
r_int
id|freeing_modules
suffix:semicolon
multiline_comment|/* true if some modules are marked for deletion */
r_static
r_struct
id|module
op_star
id|find_module
c_func
(paren
r_const
r_char
op_star
id|name
)paren
suffix:semicolon
r_static
r_int
id|get_mod_name
c_func
(paren
r_char
op_star
id|user_name
comma
r_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|free_modules
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|module_init_flag
r_static
r_int
id|module_init_flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Hmm... */
r_extern
r_struct
id|symbol_table
id|symbol_table
suffix:semicolon
multiline_comment|/* in kernel/ksyms.c */
multiline_comment|/*&n; * Called at boot time&n; */
DECL|function|init_modules
r_void
id|init_modules
c_func
(paren
r_void
)paren
(brace
r_struct
id|internal_symbol
op_star
id|sym
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|sym
op_assign
id|symbol_table.symbol
suffix:semicolon
id|sym-&gt;name
suffix:semicolon
op_increment
id|sym
comma
op_increment
id|i
)paren
suffix:semicolon
id|symbol_table.n_symbols
op_assign
id|i
suffix:semicolon
id|kernel_module.symtab
op_assign
op_amp
id|symbol_table
suffix:semicolon
id|kernel_module.state
op_assign
id|MOD_RUNNING
suffix:semicolon
multiline_comment|/* Hah! */
id|kernel_module.name
op_assign
l_string|&quot;&quot;
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate space for a module.&n; */
id|asmlinkage
r_int
r_int
DECL|function|sys_create_module
id|sys_create_module
c_func
(paren
r_char
op_star
id|module_name
comma
r_int
r_int
id|size
)paren
(brace
r_struct
id|module
op_star
id|mp
suffix:semicolon
r_void
op_star
id|addr
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|npages
suffix:semicolon
r_int
id|sspace
op_assign
r_sizeof
(paren
r_struct
id|module
)paren
op_plus
id|MOD_MAX_NAME
suffix:semicolon
r_char
id|name
(braket
id|MOD_MAX_NAME
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|module_name
op_eq
l_int|NULL
op_logical_or
id|size
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|get_mod_name
c_func
(paren
id|module_name
comma
id|name
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
id|find_module
c_func
(paren
id|name
)paren
op_ne
l_int|NULL
)paren
(brace
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mp
op_assign
(paren
r_struct
id|module
op_star
)paren
id|kmalloc
c_func
(paren
id|sspace
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|strcpy
c_func
(paren
(paren
r_char
op_star
)paren
(paren
id|mp
op_plus
l_int|1
)paren
comma
id|name
)paren
suffix:semicolon
multiline_comment|/* why not? */
id|npages
op_assign
(paren
id|size
op_plus
r_sizeof
(paren
r_int
)paren
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_div
id|PAGE_SIZE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr
op_assign
id|vmalloc
c_func
(paren
id|npages
op_star
id|PAGE_SIZE
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|kfree_s
c_func
(paren
id|mp
comma
id|sspace
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|mp-&gt;next
op_assign
id|module_list
suffix:semicolon
id|mp-&gt;ref
op_assign
l_int|NULL
suffix:semicolon
id|mp-&gt;symtab
op_assign
l_int|NULL
suffix:semicolon
id|mp-&gt;name
op_assign
(paren
r_char
op_star
)paren
(paren
id|mp
op_plus
l_int|1
)paren
suffix:semicolon
id|mp-&gt;size
op_assign
id|npages
suffix:semicolon
id|mp-&gt;addr
op_assign
id|addr
suffix:semicolon
id|mp-&gt;state
op_assign
id|MOD_UNINITIALIZED
suffix:semicolon
id|mp-&gt;cleanup
op_assign
l_int|NULL
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
id|addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set use count to zero */
id|module_list
op_assign
id|mp
suffix:semicolon
multiline_comment|/* link it in */
id|PRINTK
c_func
(paren
(paren
l_string|&quot;module `%s&squot; (%lu pages @ 0x%08lx) created&bslash;n&quot;
comma
id|mp-&gt;name
comma
(paren
r_int
r_int
)paren
id|mp-&gt;size
comma
(paren
r_int
r_int
)paren
id|mp-&gt;addr
)paren
)paren
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|addr
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize a module.&n; */
id|asmlinkage
r_int
DECL|function|sys_init_module
id|sys_init_module
c_func
(paren
r_char
op_star
id|module_name
comma
r_char
op_star
id|code
comma
r_int
id|codesize
comma
r_struct
id|mod_routines
op_star
id|routines
comma
r_struct
id|symbol_table
op_star
id|symtab
)paren
(brace
r_struct
id|module
op_star
id|mp
suffix:semicolon
r_struct
id|symbol_table
op_star
id|newtab
suffix:semicolon
r_char
id|name
(braket
id|MOD_MAX_NAME
)braket
suffix:semicolon
r_int
id|error
suffix:semicolon
r_struct
id|mod_routines
id|rt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
macro_line|#ifdef __i386__
multiline_comment|/* A little bit of protection... we &quot;know&quot; where the user stack is... */
r_if
c_cond
(paren
id|symtab
op_logical_and
(paren
(paren
r_int
r_int
)paren
id|symtab
OG
l_int|0xb0000000
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;warning: you are using an old insmod, no symbols will be inserted!&bslash;n&quot;
)paren
suffix:semicolon
id|symtab
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * First reclaim any memory from dead modules that where not&n;&t; * freed when deleted. Should I think be done by timers when&n;&t; * the module was deleted - Jon.&n;&t; */
id|free_modules
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|get_mod_name
c_func
(paren
id|module_name
comma
id|name
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|error
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;initializing module `%s&squot;, %d (0x%x) bytes&bslash;n&quot;
comma
id|name
comma
id|codesize
comma
id|codesize
)paren
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|rt
comma
id|routines
comma
r_sizeof
id|rt
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mp
op_assign
id|find_module
c_func
(paren
id|name
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|codesize
op_amp
id|MOD_AUTOCLEAN
)paren
(brace
multiline_comment|/*&n;&t;&t; * set autoclean marker from codesize...&n;&t;&t; * set useage count to &quot;zero&quot;&n;&t;&t; */
id|codesize
op_and_assign
op_complement
id|MOD_AUTOCLEAN
suffix:semicolon
id|GET_USE_COUNT
c_func
(paren
id|mp
)paren
op_assign
id|MOD_AUTOCLEAN
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|codesize
op_plus
r_sizeof
(paren
r_int
)paren
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_div
id|PAGE_SIZE
OG
id|mp-&gt;size
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
(paren
r_char
op_star
)paren
id|mp-&gt;addr
op_plus
r_sizeof
(paren
r_int
)paren
comma
id|code
comma
id|codesize
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
id|mp-&gt;addr
op_plus
r_sizeof
(paren
r_int
)paren
op_plus
id|codesize
comma
l_int|0
comma
id|mp-&gt;size
op_star
id|PAGE_SIZE
op_minus
(paren
id|codesize
op_plus
r_sizeof
(paren
r_int
)paren
)paren
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;module init entry = 0x%08lx, cleanup entry = 0x%08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|rt.init
comma
(paren
r_int
r_int
)paren
id|rt.cleanup
)paren
)paren
suffix:semicolon
id|mp-&gt;cleanup
op_assign
id|rt.cleanup
suffix:semicolon
multiline_comment|/* update kernel symbol table */
r_if
c_cond
(paren
id|symtab
)paren
(brace
multiline_comment|/* symtab == NULL means no new entries to handle */
r_struct
id|internal_symbol
op_star
id|sym
suffix:semicolon
r_struct
id|module_ref
op_star
id|ref
suffix:semicolon
r_int
id|size
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|legal_start
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
op_amp
id|symtab-&gt;size
comma
r_sizeof
(paren
id|symtab-&gt;size
)paren
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|size
op_assign
id|get_user
c_func
(paren
op_amp
id|symtab-&gt;size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|newtab
op_assign
(paren
r_struct
id|symbol_table
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|symtab
comma
id|size
)paren
)paren
)paren
(brace
id|kfree_s
c_func
(paren
id|newtab
comma
id|size
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|memcpy_fromfs
c_func
(paren
(paren
r_char
op_star
)paren
(paren
id|newtab
)paren
comma
id|symtab
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* sanity check */
id|legal_start
op_assign
r_sizeof
(paren
r_struct
id|symbol_table
)paren
op_plus
id|newtab-&gt;n_symbols
op_star
r_sizeof
(paren
r_struct
id|internal_symbol
)paren
op_plus
id|newtab-&gt;n_refs
op_star
r_sizeof
(paren
r_struct
id|module_ref
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|newtab-&gt;n_symbols
OL
l_int|0
)paren
op_logical_or
(paren
id|newtab-&gt;n_refs
OL
l_int|0
)paren
op_logical_or
(paren
id|legal_start
OG
id|size
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Rejecting illegal symbol table (n_symbols=%d,n_refs=%d)&bslash;n&quot;
comma
id|newtab-&gt;n_symbols
comma
id|newtab-&gt;n_refs
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|newtab
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* relocate name pointers, index referred from start of table */
r_for
c_loop
(paren
id|sym
op_assign
op_amp
(paren
id|newtab-&gt;symbol
(braket
l_int|0
)braket
)paren
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|newtab-&gt;n_symbols
suffix:semicolon
op_increment
id|sym
comma
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|sym-&gt;name
OL
id|legal_start
op_logical_or
id|size
op_le
(paren
r_int
r_int
)paren
id|sym-&gt;name
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Rejecting illegal symbol table&bslash;n&quot;
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|newtab
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* else */
id|sym-&gt;name
op_add_assign
(paren
r_int
)paren
id|newtab
suffix:semicolon
)brace
id|mp-&gt;symtab
op_assign
id|newtab
suffix:semicolon
multiline_comment|/* Update module references.&n;&t;&t; * On entry, from &quot;insmod&quot;, ref-&gt;module points to&n;&t;&t; * the referenced module!&n;&t;&t; * Now it will point to the current module instead!&n;&t;&t; * The ref structure becomes the first link in the linked&n;&t;&t; * list of references to the referenced module.&n;&t;&t; * Also, &quot;sym&quot; from above, points to the first ref entry!!!&n;&t;&t; */
r_for
c_loop
(paren
id|ref
op_assign
(paren
r_struct
id|module_ref
op_star
)paren
id|sym
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|newtab-&gt;n_refs
suffix:semicolon
op_increment
id|ref
comma
op_increment
id|i
)paren
(brace
multiline_comment|/* Check for valid reference */
r_struct
id|module
op_star
id|link
op_assign
id|module_list
suffix:semicolon
r_while
c_loop
(paren
id|link
op_logical_and
(paren
id|ref-&gt;module
op_ne
id|link
)paren
)paren
id|link
op_assign
id|link-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|link
op_eq
(paren
r_struct
id|module
op_star
)paren
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Non-module reference! Rejected!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ref-&gt;next
op_assign
id|ref-&gt;module-&gt;ref
suffix:semicolon
id|ref-&gt;module-&gt;ref
op_assign
id|ref
suffix:semicolon
id|ref-&gt;module
op_assign
id|mp
suffix:semicolon
)brace
)brace
id|module_init_flag
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Hmm... */
r_if
c_cond
(paren
(paren
op_star
id|rt.init
)paren
(paren
)paren
op_ne
l_int|0
)paren
(brace
id|module_init_flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Hmm... */
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|module_init_flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Hmm... */
id|mp-&gt;state
op_assign
id|MOD_RUNNING
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_delete_module
id|sys_delete_module
c_func
(paren
r_char
op_star
id|module_name
)paren
(brace
r_struct
id|module
op_star
id|mp
suffix:semicolon
r_char
id|name
(braket
id|MOD_MAX_NAME
)braket
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* else */
r_if
c_cond
(paren
id|module_name
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|get_mod_name
c_func
(paren
id|module_name
comma
id|name
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mp
op_assign
id|find_module
c_func
(paren
id|name
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mp-&gt;ref
op_ne
l_int|NULL
)paren
op_logical_or
(paren
(paren
id|GET_USE_COUNT
c_func
(paren
id|mp
)paren
op_amp
op_complement
id|MOD_AUTOCLEAN
)paren
op_ne
l_int|0
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|GET_USE_COUNT
c_func
(paren
id|mp
)paren
op_and_assign
op_complement
id|MOD_AUTOCLEAN
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;state
op_eq
id|MOD_RUNNING
)paren
(paren
op_star
id|mp-&gt;cleanup
)paren
(paren
)paren
suffix:semicolon
id|mp-&gt;state
op_assign
id|MOD_DELETED
suffix:semicolon
id|free_modules
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* for automatic reaping */
r_else
(brace
r_for
c_loop
(paren
id|mp
op_assign
id|module_list
suffix:semicolon
id|mp
op_ne
op_amp
id|kernel_module
suffix:semicolon
id|mp
op_assign
id|mp-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|mp-&gt;ref
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|GET_USE_COUNT
c_func
(paren
id|mp
)paren
op_eq
id|MOD_AUTOCLEAN
)paren
op_logical_and
(paren
id|mp-&gt;state
op_eq
id|MOD_RUNNING
)paren
)paren
(brace
id|GET_USE_COUNT
c_func
(paren
id|mp
)paren
op_and_assign
op_complement
id|MOD_AUTOCLEAN
suffix:semicolon
(paren
op_star
id|mp-&gt;cleanup
)paren
(paren
)paren
suffix:semicolon
id|mp-&gt;state
op_assign
id|MOD_DELETED
suffix:semicolon
id|free_modules
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy the kernel symbol table to user space.  If the argument is null,&n; * just return the size of the table.&n; *&n; * Note that the transient module symbols are copied _first_,&n; * in lifo order!!!&n; *&n; * The symbols to &quot;insmod&quot; are according to the &quot;old&quot; format: struct kernel_sym,&n; * which is actually quite handy for this purpose.&n; * Note that insmod inserts a struct symbol_table later on...&n; * (as that format is quite handy for the kernel...)&n; *&n; * For every module, the first (pseudo)symbol copied is the module name&n; * and the address of the module struct.&n; * This lets &quot;insmod&quot; keep track of references, and build the array of&n; * struct module_refs in the symbol table.&n; * The format of the module name is &quot;#module&quot;, so that &quot;insmod&quot; can easily&n; * notice when a module name comes along. Also, this will make it possible&n; * to use old versions of &quot;insmod&quot;, albeit with reduced functionality...&n; * The &quot;kernel&quot; module has an empty name.&n; */
id|asmlinkage
r_int
DECL|function|sys_get_kernel_syms
id|sys_get_kernel_syms
c_func
(paren
r_struct
id|kernel_sym
op_star
id|table
)paren
(brace
r_struct
id|internal_symbol
op_star
id|from
suffix:semicolon
r_struct
id|kernel_sym
id|isym
suffix:semicolon
r_struct
id|kernel_sym
op_star
id|to
suffix:semicolon
r_struct
id|module
op_star
id|mp
op_assign
id|module_list
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|nmodsyms
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|mp
op_assign
id|module_list
suffix:semicolon
id|mp
suffix:semicolon
id|mp
op_assign
id|mp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;symtab
op_logical_and
id|mp-&gt;symtab-&gt;n_symbols
)paren
(brace
multiline_comment|/* include the count for the module name! */
id|nmodsyms
op_add_assign
id|mp-&gt;symtab-&gt;n_symbols
op_plus
l_int|1
suffix:semicolon
)brace
r_else
multiline_comment|/* include the count for the module name! */
id|nmodsyms
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* return modules without symbols too */
)brace
r_if
c_cond
(paren
id|table
op_ne
l_int|NULL
)paren
(brace
id|to
op_assign
id|table
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|to
comma
id|nmodsyms
op_star
r_sizeof
(paren
op_star
id|table
)paren
)paren
)paren
)paren
r_return
id|i
suffix:semicolon
multiline_comment|/* copy all module symbols first (always LIFO order) */
r_for
c_loop
(paren
id|mp
op_assign
id|module_list
suffix:semicolon
id|mp
suffix:semicolon
id|mp
op_assign
id|mp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;state
op_eq
id|MOD_RUNNING
)paren
(brace
multiline_comment|/* magic: write module info as a pseudo symbol */
id|isym.value
op_assign
(paren
r_int
r_int
)paren
id|mp
suffix:semicolon
id|sprintf
c_func
(paren
id|isym.name
comma
l_string|&quot;#%s&quot;
comma
id|mp-&gt;name
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|to
comma
op_amp
id|isym
comma
r_sizeof
id|isym
)paren
suffix:semicolon
op_increment
id|to
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;symtab
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|mp-&gt;symtab-&gt;n_symbols
comma
id|from
op_assign
id|mp-&gt;symtab-&gt;symbol
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
comma
op_increment
id|from
comma
op_increment
id|to
)paren
(brace
id|isym.value
op_assign
(paren
r_int
r_int
)paren
id|from-&gt;addr
suffix:semicolon
id|strncpy
c_func
(paren
id|isym.name
comma
id|from-&gt;name
comma
r_sizeof
id|isym.name
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|to
comma
op_amp
id|isym
comma
r_sizeof
id|isym
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
r_return
id|nmodsyms
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy the name of a module from user space.&n; */
r_int
DECL|function|get_mod_name
id|get_mod_name
c_func
(paren
r_char
op_star
id|user_name
comma
r_char
op_star
id|buf
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|buf
(braket
id|i
)braket
op_assign
id|get_user
c_func
(paren
id|user_name
op_plus
id|i
)paren
)paren
op_ne
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_increment
id|i
op_ge
id|MOD_MAX_NAME
)paren
r_return
op_minus
id|E2BIG
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Look for a module by name, ignoring modules marked for deletion.&n; */
r_struct
id|module
op_star
DECL|function|find_module
id|find_module
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|module
op_star
id|mp
suffix:semicolon
r_for
c_loop
(paren
id|mp
op_assign
id|module_list
suffix:semicolon
id|mp
suffix:semicolon
id|mp
op_assign
id|mp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;state
op_eq
id|MOD_DELETED
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|mp-&gt;name
comma
id|name
)paren
)paren
r_break
suffix:semicolon
)brace
r_return
id|mp
suffix:semicolon
)brace
r_static
r_void
DECL|function|drop_refs
id|drop_refs
c_func
(paren
r_struct
id|module
op_star
id|mp
)paren
(brace
r_struct
id|module
op_star
id|step
suffix:semicolon
r_struct
id|module_ref
op_star
id|prev
suffix:semicolon
r_struct
id|module_ref
op_star
id|ref
suffix:semicolon
r_for
c_loop
(paren
id|step
op_assign
id|module_list
suffix:semicolon
id|step
suffix:semicolon
id|step
op_assign
id|step-&gt;next
)paren
(brace
r_for
c_loop
(paren
id|prev
op_assign
id|ref
op_assign
id|step-&gt;ref
suffix:semicolon
id|ref
suffix:semicolon
id|ref
op_assign
id|prev-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|ref-&gt;module
op_eq
id|mp
)paren
(brace
r_if
c_cond
(paren
id|ref
op_eq
id|step-&gt;ref
)paren
id|step-&gt;ref
op_assign
id|ref-&gt;next
suffix:semicolon
r_else
id|prev-&gt;next
op_assign
id|ref-&gt;next
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* every module only references once! */
)brace
r_else
id|prev
op_assign
id|ref
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Try to free modules which have been marked for deletion.  Returns nonzero&n; * if a module was actually freed.&n; */
r_int
DECL|function|free_modules
id|free_modules
c_func
(paren
r_void
)paren
(brace
r_struct
id|module
op_star
id|mp
suffix:semicolon
r_struct
id|module
op_star
op_star
id|mpp
suffix:semicolon
r_int
id|did_deletion
suffix:semicolon
id|did_deletion
op_assign
l_int|0
suffix:semicolon
id|freeing_modules
op_assign
l_int|0
suffix:semicolon
id|mpp
op_assign
op_amp
id|module_list
suffix:semicolon
r_while
c_loop
(paren
(paren
id|mp
op_assign
op_star
id|mpp
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;state
op_ne
id|MOD_DELETED
)paren
(brace
id|mpp
op_assign
op_amp
id|mp-&gt;next
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|GET_USE_COUNT
c_func
(paren
id|mp
)paren
op_ne
l_int|0
)paren
op_logical_or
(paren
id|mp-&gt;ref
op_ne
l_int|NULL
)paren
)paren
(brace
id|freeing_modules
op_assign
l_int|1
suffix:semicolon
id|mpp
op_assign
op_amp
id|mp-&gt;next
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* delete it */
op_star
id|mpp
op_assign
id|mp-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;symtab
)paren
(brace
r_if
c_cond
(paren
id|mp-&gt;symtab-&gt;n_refs
)paren
id|drop_refs
c_func
(paren
id|mp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;symtab-&gt;size
)paren
id|kfree_s
c_func
(paren
id|mp-&gt;symtab
comma
id|mp-&gt;symtab-&gt;size
)paren
suffix:semicolon
)brace
id|vfree
c_func
(paren
id|mp-&gt;addr
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|mp
comma
r_sizeof
(paren
r_struct
id|module
)paren
op_plus
id|MOD_MAX_NAME
)paren
suffix:semicolon
id|did_deletion
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_return
id|did_deletion
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by the /proc file system to return a current list of modules.&n; */
DECL|function|get_module_list
r_int
id|get_module_list
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_const
r_char
op_star
id|q
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|module
op_star
id|mp
suffix:semicolon
r_struct
id|module_ref
op_star
id|ref
suffix:semicolon
r_char
id|size
(braket
l_int|32
)braket
suffix:semicolon
id|p
op_assign
id|buf
suffix:semicolon
multiline_comment|/* Do not show the kernel pseudo module */
r_for
c_loop
(paren
id|mp
op_assign
id|module_list
suffix:semicolon
id|mp
op_logical_and
id|mp-&gt;next
suffix:semicolon
id|mp
op_assign
id|mp-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p
op_minus
id|buf
OG
l_int|4096
op_minus
l_int|100
)paren
r_break
suffix:semicolon
multiline_comment|/* avoid overflowing buffer */
id|q
op_assign
id|mp-&gt;name
suffix:semicolon
r_if
c_cond
(paren
op_star
id|q
op_eq
l_char|&squot;&bslash;0&squot;
op_logical_and
id|mp-&gt;size
op_eq
l_int|0
op_logical_and
id|mp-&gt;ref
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
multiline_comment|/* don&squot;t list modules for kernel syms */
id|i
op_assign
l_int|20
suffix:semicolon
r_while
c_loop
(paren
op_star
id|q
)paren
(brace
op_star
id|p
op_increment
op_assign
op_star
id|q
op_increment
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|size
comma
l_string|&quot;%d&quot;
comma
id|mp-&gt;size
)paren
suffix:semicolon
id|i
op_sub_assign
id|strlen
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_le
l_int|0
)paren
id|i
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|i
op_ge
l_int|0
)paren
op_star
id|p
op_increment
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|q
op_assign
id|size
suffix:semicolon
r_while
c_loop
(paren
op_star
id|q
)paren
op_star
id|p
op_increment
op_assign
op_star
id|q
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;state
op_eq
id|MOD_UNINITIALIZED
)paren
id|q
op_assign
l_string|&quot;  (uninitialized)&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mp-&gt;state
op_eq
id|MOD_RUNNING
)paren
id|q
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mp-&gt;state
op_eq
id|MOD_DELETED
)paren
id|q
op_assign
l_string|&quot;  (deleted)&quot;
suffix:semicolon
r_else
id|q
op_assign
l_string|&quot;  (bad state)&quot;
suffix:semicolon
r_while
c_loop
(paren
op_star
id|q
)paren
op_star
id|p
op_increment
op_assign
op_star
id|q
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ref
op_assign
id|mp-&gt;ref
)paren
op_ne
l_int|NULL
)paren
(brace
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;t&squot;
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_char|&squot;[&squot;
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|ref
suffix:semicolon
id|ref
op_assign
id|ref-&gt;next
)paren
(brace
id|q
op_assign
id|ref-&gt;module-&gt;name
suffix:semicolon
r_while
c_loop
(paren
op_star
id|q
)paren
op_star
id|p
op_increment
op_assign
op_star
id|q
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ref-&gt;next
)paren
op_star
id|p
op_increment
op_assign
l_char|&squot; &squot;
suffix:semicolon
)brace
op_star
id|p
op_increment
op_assign
l_char|&squot;]&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mp-&gt;state
op_eq
id|MOD_RUNNING
)paren
(brace
id|sprintf
c_func
(paren
id|size
comma
l_string|&quot;&bslash;t%ld%s&quot;
comma
id|GET_USE_COUNT
c_func
(paren
id|mp
)paren
op_amp
op_complement
id|MOD_AUTOCLEAN
comma
(paren
(paren
id|GET_USE_COUNT
c_func
(paren
id|mp
)paren
op_amp
id|MOD_AUTOCLEAN
)paren
ques
c_cond
l_string|&quot; (autoclean)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
)paren
suffix:semicolon
id|q
op_assign
id|size
suffix:semicolon
r_while
c_loop
(paren
op_star
id|q
)paren
op_star
id|p
op_increment
op_assign
op_star
id|q
op_increment
suffix:semicolon
)brace
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
)brace
r_return
id|p
op_minus
id|buf
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by the /proc file system to return a current list of ksyms.&n; */
DECL|function|get_ksyms_list
r_int
id|get_ksyms_list
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_struct
id|module
op_star
id|mp
suffix:semicolon
r_struct
id|internal_symbol
op_star
id|sym
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
op_star
id|p
op_assign
id|buf
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* code from  net/ipv4/proc.c */
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|mp
op_assign
id|module_list
suffix:semicolon
id|mp
suffix:semicolon
id|mp
op_assign
id|mp-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
id|mp-&gt;state
op_eq
id|MOD_RUNNING
)paren
op_logical_and
(paren
id|mp-&gt;symtab
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|mp-&gt;symtab-&gt;n_symbols
OG
l_int|0
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|mp-&gt;symtab-&gt;n_symbols
comma
id|sym
op_assign
id|mp-&gt;symtab-&gt;symbol
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
comma
op_increment
id|sym
)paren
(brace
id|p
op_assign
id|buf
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;name
(braket
l_int|0
)braket
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%08lx %s&bslash;t[%s]&bslash;n&quot;
comma
(paren
r_int
)paren
id|sym-&gt;addr
comma
id|sym-&gt;name
comma
id|mp-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%08lx %s&bslash;n&quot;
comma
(paren
r_int
)paren
id|sym-&gt;addr
comma
id|sym-&gt;name
)paren
suffix:semicolon
)brace
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
r_goto
id|leave_the_loop
suffix:semicolon
)brace
)brace
)brace
id|leave_the_loop
suffix:colon
op_star
id|start
op_assign
id|buf
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * Rules:&n; * - The new symbol table should be statically allocated, or else you _have_&n; *   to set the &quot;size&quot; field of the struct to the number of bytes allocated.&n; *&n; * - The strings that name the symbols will not be copied, maybe the pointers&n; *&n; * - For a loadable module, the function should only be called in the&n; *   context of init_module&n; *&n; * Those are the only restrictions! (apart from not being reentrant...)&n; *&n; * If you want to remove a symbol table for a loadable module,&n; * the call looks like: &quot;register_symtab(0)&quot;.&n; *&n; * The look of the code is mostly dictated by the format of&n; * the frozen struct symbol_table, due to compatibility demands.&n; */
DECL|macro|INTSIZ
mdefine_line|#define INTSIZ sizeof(struct internal_symbol)
DECL|macro|REFSIZ
mdefine_line|#define REFSIZ sizeof(struct module_ref)
DECL|macro|SYMSIZ
mdefine_line|#define SYMSIZ sizeof(struct symbol_table)
DECL|macro|MODSIZ
mdefine_line|#define MODSIZ sizeof(struct module)
DECL|variable|nulltab
r_static
r_struct
id|symbol_table
id|nulltab
suffix:semicolon
r_int
DECL|function|register_symtab
id|register_symtab
c_func
(paren
r_struct
id|symbol_table
op_star
id|intab
)paren
(brace
r_struct
id|module
op_star
id|mp
suffix:semicolon
r_struct
id|module
op_star
id|link
suffix:semicolon
r_struct
id|symbol_table
op_star
id|oldtab
suffix:semicolon
r_struct
id|symbol_table
op_star
id|newtab
suffix:semicolon
r_struct
id|module_ref
op_star
id|newref
suffix:semicolon
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|intab
op_logical_and
(paren
id|intab-&gt;n_symbols
op_eq
l_int|0
)paren
)paren
(brace
r_struct
id|internal_symbol
op_star
id|sym
suffix:semicolon
multiline_comment|/* How many symbols, really? */
r_for
c_loop
(paren
id|sym
op_assign
id|intab-&gt;symbol
suffix:semicolon
id|sym-&gt;name
suffix:semicolon
op_increment
id|sym
)paren
id|intab-&gt;n_symbols
op_add_assign
l_int|1
suffix:semicolon
)brace
macro_line|#if 1
r_if
c_cond
(paren
id|module_init_flag
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Hmm... */
macro_line|#else
r_if
c_cond
(paren
id|module_list
op_eq
op_amp
id|kernel_module
)paren
(brace
macro_line|#endif
multiline_comment|/* Aha! Called from an &quot;internal&quot; module */
r_if
c_cond
(paren
op_logical_neg
id|intab
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* or -ESILLY_PROGRAMMER :-) */
multiline_comment|/* create a pseudo module! */
r_if
c_cond
(paren
op_logical_neg
(paren
id|mp
op_assign
(paren
r_struct
id|module
op_star
)paren
id|kmalloc
c_func
(paren
id|MODSIZ
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
multiline_comment|/* panic time! */
id|printk
c_func
(paren
l_string|&quot;Out of memory for new symbol table!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* else  OK */
id|memset
c_func
(paren
id|mp
comma
l_int|0
comma
id|MODSIZ
)paren
suffix:semicolon
id|mp-&gt;state
op_assign
id|MOD_RUNNING
suffix:semicolon
multiline_comment|/* Since it is resident... */
id|mp-&gt;name
op_assign
l_string|&quot;&quot;
suffix:semicolon
multiline_comment|/* This is still the &quot;kernel&quot; symbol table! */
id|mp-&gt;symtab
op_assign
id|intab
suffix:semicolon
multiline_comment|/* link it in _after_ the resident symbol table */
id|mp-&gt;next
op_assign
id|kernel_module.next
suffix:semicolon
id|kernel_module.next
op_assign
id|mp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* else ******** Called from a loadable module **********/
multiline_comment|/*&n;&t; * This call should _only_ be done in the context of the&n;&t; * call to  init_module  i.e. when loading the module!!&n;&t; * Or else...&n;&t; */
id|mp
op_assign
id|module_list
suffix:semicolon
multiline_comment|/* true when doing init_module! */
multiline_comment|/* Any table there before? */
r_if
c_cond
(paren
(paren
id|oldtab
op_assign
id|mp-&gt;symtab
)paren
op_eq
(paren
r_struct
id|symbol_table
op_star
)paren
l_int|0
)paren
(brace
multiline_comment|/* No, just insert it! */
id|mp-&gt;symtab
op_assign
id|intab
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* else  ****** we have to replace the module symbol table ******/
macro_line|#if 0
r_if
c_cond
(paren
id|oldtab-&gt;n_symbols
OG
l_int|0
)paren
(brace
multiline_comment|/* Oh dear, I have to drop the old ones... */
id|printk
c_func
(paren
l_string|&quot;Warning, dropping old symbols&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|oldtab-&gt;n_refs
op_eq
l_int|0
)paren
(brace
multiline_comment|/* no problems! */
id|mp-&gt;symtab
op_assign
id|intab
suffix:semicolon
multiline_comment|/* if the old table was kmalloc-ed, drop it */
r_if
c_cond
(paren
id|oldtab-&gt;size
OG
l_int|0
)paren
id|kfree_s
c_func
(paren
id|oldtab
comma
id|oldtab-&gt;size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* else */
multiline_comment|/***** The module references other modules... insmod said so! *****/
multiline_comment|/* We have to allocate a new symbol table, or we lose them! */
r_if
c_cond
(paren
id|intab
op_eq
(paren
r_struct
id|symbol_table
op_star
)paren
l_int|0
)paren
id|intab
op_assign
op_amp
id|nulltab
suffix:semicolon
multiline_comment|/* easier code with zeroes in place */
multiline_comment|/* the input symbol table space does not include the string table */
multiline_comment|/* (it does for symbol tables that insmod creates) */
r_if
c_cond
(paren
op_logical_neg
(paren
id|newtab
op_assign
(paren
r_struct
id|symbol_table
op_star
)paren
id|kmalloc
c_func
(paren
id|size
op_assign
id|SYMSIZ
op_plus
id|intab-&gt;n_symbols
op_star
id|INTSIZ
op_plus
id|oldtab-&gt;n_refs
op_star
id|REFSIZ
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
multiline_comment|/* panic time! */
id|printk
c_func
(paren
l_string|&quot;Out of memory for new symbol table!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* copy up to, and including, the new symbols */
id|memcpy
c_func
(paren
id|newtab
comma
id|intab
comma
id|SYMSIZ
op_plus
id|intab-&gt;n_symbols
op_star
id|INTSIZ
)paren
suffix:semicolon
id|newtab-&gt;size
op_assign
id|size
suffix:semicolon
id|newtab-&gt;n_refs
op_assign
id|oldtab-&gt;n_refs
suffix:semicolon
multiline_comment|/* copy references */
id|memcpy
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|newtab
)paren
op_plus
id|SYMSIZ
op_plus
id|intab-&gt;n_symbols
op_star
id|INTSIZ
comma
(paren
(paren
r_char
op_star
)paren
id|oldtab
)paren
op_plus
id|SYMSIZ
op_plus
id|oldtab-&gt;n_symbols
op_star
id|INTSIZ
comma
id|oldtab-&gt;n_refs
op_star
id|REFSIZ
)paren
suffix:semicolon
multiline_comment|/* relink references from the old table to the new one */
multiline_comment|/* pointer to the first reference entry in newtab! Really! */
id|newref
op_assign
(paren
r_struct
id|module_ref
op_star
)paren
op_amp
(paren
id|newtab-&gt;symbol
(braket
id|newtab-&gt;n_symbols
)braket
)paren
suffix:semicolon
multiline_comment|/* check for reference links from previous modules */
r_for
c_loop
(paren
id|link
op_assign
id|module_list
suffix:semicolon
id|link
op_logical_and
(paren
id|link
op_ne
op_amp
id|kernel_module
)paren
suffix:semicolon
id|link
op_assign
id|link-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|link-&gt;ref
op_logical_and
(paren
id|link-&gt;ref-&gt;module
op_eq
id|mp
)paren
)paren
id|link-&gt;ref
op_assign
id|newref
op_increment
suffix:semicolon
)brace
id|mp-&gt;symtab
op_assign
id|newtab
suffix:semicolon
multiline_comment|/* all references (if any) have been handled */
multiline_comment|/* if the old table was kmalloc-ed, drop it */
r_if
c_cond
(paren
id|oldtab-&gt;size
OG
l_int|0
)paren
id|kfree_s
c_func
(paren
id|oldtab
comma
id|oldtab-&gt;size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else&t;&t;/* CONFIG_MODULES */
multiline_comment|/* Dummy syscalls for people who don&squot;t want modules */
DECL|function|sys_create_module
id|asmlinkage
r_int
r_int
id|sys_create_module
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|sys_init_module
id|asmlinkage
r_int
id|sys_init_module
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|sys_delete_module
id|asmlinkage
r_int
id|sys_delete_module
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|sys_get_kernel_syms
id|asmlinkage
r_int
id|sys_get_kernel_syms
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|register_symtab
r_int
id|register_symtab
c_func
(paren
r_struct
id|symbol_table
op_star
id|intab
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_MODULES */
eof
