macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;linux/init.h&gt;
multiline_comment|/*&n; * Originally by Anonymous (as far as I know...)&n; * Linux version by Bas Laarhoven &lt;bas@vimec.nl&gt;&n; * 0.99.14 version by Jon Tombs &lt;jon@gtex02.us.es&gt;,&n; * Heavily modified by Bjorn Ekwall &lt;bj0rn@blox.se&gt; May 1994 (C)&n; * Rewritten by Richard Henderson &lt;rth@tamu.edu&gt; Dec 1996&n; * Use rw spinlock instead of global kernel lock for module_list, by TA &lt;tigran@sco.com&gt;&n; *&n; * This source is covered by the GNU GPL, the same as all kernel sources.&n; */
macro_line|#ifdef CONFIG_MODULES&t;&t;/* a *big* #ifdef block... */
r_extern
r_struct
id|module_symbol
id|__start___ksymtab
(braket
)braket
suffix:semicolon
r_extern
r_struct
id|module_symbol
id|__stop___ksymtab
(braket
)braket
suffix:semicolon
r_extern
r_const
r_struct
id|exception_table_entry
id|__start___ex_table
(braket
)braket
suffix:semicolon
r_extern
r_const
r_struct
id|exception_table_entry
id|__stop___ex_table
(braket
)braket
suffix:semicolon
DECL|variable|kernel_module
r_static
r_struct
id|module
id|kernel_module
op_assign
(brace
r_sizeof
(paren
r_struct
id|module
)paren
comma
multiline_comment|/* size_of_struct */
l_int|NULL
comma
multiline_comment|/* next */
l_string|&quot;&quot;
comma
multiline_comment|/* name */
l_int|0
comma
multiline_comment|/* size */
(brace
id|ATOMIC_INIT
c_func
(paren
l_int|1
)paren
)brace
comma
multiline_comment|/* usecount */
id|MOD_RUNNING
comma
multiline_comment|/* flags */
l_int|0
comma
multiline_comment|/* nsyms -- to filled in in init_modules */
l_int|0
comma
multiline_comment|/* ndeps */
id|__start___ksymtab
comma
multiline_comment|/* syms */
l_int|NULL
comma
multiline_comment|/* deps */
l_int|NULL
comma
multiline_comment|/* refs */
l_int|NULL
comma
multiline_comment|/* init */
l_int|NULL
comma
multiline_comment|/* cleanup */
id|__start___ex_table
comma
multiline_comment|/* ex_table_start */
id|__stop___ex_table
comma
multiline_comment|/* ex_table_end */
multiline_comment|/* Rest are NULL */
)brace
suffix:semicolon
DECL|variable|module_list
r_struct
id|module
op_star
id|module_list
op_assign
op_amp
id|kernel_module
suffix:semicolon
r_static
r_int
id|get_mod_name
c_func
(paren
r_const
r_char
op_star
id|user_name
comma
r_char
op_star
op_star
id|buf
)paren
suffix:semicolon
r_static
r_void
id|put_mod_name
c_func
(paren
r_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_struct
id|module
op_star
id|find_module
c_func
(paren
r_const
r_char
op_star
id|name
)paren
suffix:semicolon
r_static
r_void
id|free_module
c_func
(paren
r_struct
id|module
op_star
comma
r_int
id|tag_freed
)paren
suffix:semicolon
DECL|variable|modlist_lock
id|rwlock_t
id|modlist_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* needed for /proc/kcore, here because kernel_module is static (TA) */
DECL|function|get_kcore_size
r_int
r_int
id|get_kcore_size
c_func
(paren
r_void
)paren
(brace
r_int
r_int
r_try
comma
id|size
op_assign
l_int|0
suffix:semicolon
r_struct
id|module
op_star
id|m
suffix:semicolon
r_if
c_cond
(paren
id|module_list
op_eq
op_amp
id|kernel_module
)paren
r_return
(paren
(paren
r_int
r_int
)paren
id|high_memory
op_minus
id|PAGE_OFFSET
op_plus
id|PAGE_SIZE
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|m
op_assign
id|module_list
suffix:semicolon
id|m
suffix:semicolon
id|m
op_assign
id|m-&gt;next
)paren
(brace
r_try
op_assign
(paren
r_int
r_int
)paren
id|m
op_plus
id|m-&gt;size
suffix:semicolon
r_if
c_cond
(paren
r_try
OG
id|size
)paren
id|size
op_assign
r_try
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_return
(paren
id|size
op_minus
id|PAGE_OFFSET
op_plus
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called at boot time&n; */
DECL|function|init_modules
r_void
id|__init
id|init_modules
c_func
(paren
r_void
)paren
(brace
id|kernel_module.nsyms
op_assign
id|__stop___ksymtab
op_minus
id|__start___ksymtab
suffix:semicolon
macro_line|#ifdef __alpha__
id|__asm__
c_func
(paren
l_string|&quot;stq $29,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|kernel_module.gp
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Copy the name of a module from user space.&n; */
r_static
r_inline
r_int
DECL|function|get_mod_name
id|get_mod_name
c_func
(paren
r_const
r_char
op_star
id|user_name
comma
r_char
op_star
op_star
id|buf
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|page
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|retval
op_assign
id|strncpy_from_user
c_func
(paren
(paren
r_char
op_star
)paren
id|page
comma
id|user_name
comma
id|PAGE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|retval
OL
id|PAGE_SIZE
)paren
(brace
op_star
id|buf
op_assign
(paren
r_char
op_star
)paren
id|page
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|retval
op_assign
op_minus
id|ENAMETOOLONG
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|put_mod_name
id|put_mod_name
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|buf
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate space for a module.&n; */
id|asmlinkage
r_int
r_int
DECL|function|sys_create_module
id|sys_create_module
c_func
(paren
r_const
r_char
op_star
id|name_user
comma
r_int
id|size
)paren
(brace
r_char
op_star
id|name
suffix:semicolon
r_int
id|namelen
comma
id|error
suffix:semicolon
r_struct
id|module
op_star
id|mod
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_MODULE
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|err0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|namelen
op_assign
id|get_mod_name
c_func
(paren
id|name_user
comma
op_amp
id|name
)paren
)paren
OL
l_int|0
)paren
(brace
id|error
op_assign
id|namelen
suffix:semicolon
r_goto
id|err0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|size
OL
r_sizeof
(paren
r_struct
id|module
)paren
op_plus
id|namelen
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|find_module
c_func
(paren
id|name
)paren
op_ne
l_int|NULL
)paren
(brace
id|error
op_assign
op_minus
id|EEXIST
suffix:semicolon
r_goto
id|err1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mod
op_assign
(paren
r_struct
id|module
op_star
)paren
id|module_map
c_func
(paren
id|size
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|err1
suffix:semicolon
)brace
id|memset
c_func
(paren
id|mod
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|mod
)paren
)paren
suffix:semicolon
id|mod-&gt;size_of_struct
op_assign
r_sizeof
(paren
op_star
id|mod
)paren
suffix:semicolon
id|mod-&gt;next
op_assign
id|module_list
suffix:semicolon
id|mod-&gt;name
op_assign
(paren
r_char
op_star
)paren
(paren
id|mod
op_plus
l_int|1
)paren
suffix:semicolon
id|mod-&gt;size
op_assign
id|size
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
(paren
id|mod
op_plus
l_int|1
)paren
comma
id|name
comma
id|namelen
op_plus
l_int|1
)paren
suffix:semicolon
id|put_mod_name
c_func
(paren
id|name
)paren
suffix:semicolon
id|module_list
op_assign
id|mod
suffix:semicolon
multiline_comment|/* link it in */
id|error
op_assign
(paren
r_int
)paren
id|mod
suffix:semicolon
r_goto
id|err0
suffix:semicolon
id|err1
suffix:colon
id|put_mod_name
c_func
(paren
id|name
)paren
suffix:semicolon
id|err0
suffix:colon
id|write_unlock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize a module.&n; */
id|asmlinkage
r_int
DECL|function|sys_init_module
id|sys_init_module
c_func
(paren
r_const
r_char
op_star
id|name_user
comma
r_struct
id|module
op_star
id|mod_user
)paren
(brace
r_struct
id|module
id|mod_tmp
comma
op_star
id|mod
suffix:semicolon
r_char
op_star
id|name
comma
op_star
id|n_name
suffix:semicolon
r_int
id|namelen
comma
id|n_namelen
comma
id|i
comma
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_int
r_int
id|mod_user_size
suffix:semicolon
r_struct
id|module_ref
op_star
id|dep
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_MODULE
)paren
)paren
r_goto
id|err0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|namelen
op_assign
id|get_mod_name
c_func
(paren
id|name_user
comma
op_amp
id|name
)paren
)paren
OL
l_int|0
)paren
(brace
id|error
op_assign
id|namelen
suffix:semicolon
r_goto
id|err0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mod
op_assign
id|find_module
c_func
(paren
id|name
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_goto
id|err1
suffix:semicolon
)brace
multiline_comment|/* Check module header size.  We allow a bit of slop over the &n;&t;   size we are familiar with to cope with a version of insmod&n;&t;   for a newer kernel.  But don&squot;t over do it. */
r_if
c_cond
(paren
(paren
id|error
op_assign
id|get_user
c_func
(paren
id|mod_user_size
comma
op_amp
id|mod_user-&gt;size_of_struct
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|err1
suffix:semicolon
r_if
c_cond
(paren
id|mod_user_size
template_param
r_sizeof
(paren
r_struct
id|module
)paren
op_plus
l_int|16
op_star
r_sizeof
(paren
r_void
op_star
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: Invalid module header size.&bslash;n&quot;
id|KERN_ERR
l_string|&quot;A new version of the modutils is likely &quot;
l_string|&quot;needed.&bslash;n&quot;
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_goto
id|err1
suffix:semicolon
)brace
multiline_comment|/* Hold the current contents while we play with the user&squot;s idea&n;&t;   of righteousness.  */
id|mod_tmp
op_assign
op_star
id|mod
suffix:semicolon
id|error
op_assign
id|copy_from_user
c_func
(paren
id|mod
comma
id|mod_user
comma
r_sizeof
(paren
r_struct
id|module
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
multiline_comment|/* Sanity check the size of the module.  */
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;size
OG
id|mod_tmp.size
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: Size of initialized module &quot;
l_string|&quot;exceeds size of created module.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
multiline_comment|/* Make sure all interesting pointers are sane.  */
DECL|macro|bound
mdefine_line|#define bound(p, n, m)  ((unsigned long)(p) &gt;= (unsigned long)(m+1) &amp;&amp;  &bslash;&n;&t;         (unsigned long)((p)+(n)) &lt;= (unsigned long)(m) + (m)-&gt;size)
r_if
c_cond
(paren
op_logical_neg
id|bound
c_func
(paren
id|mod-&gt;name
comma
id|namelen
comma
id|mod
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;name out of bounds.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;nsyms
op_logical_and
op_logical_neg
id|bound
c_func
(paren
id|mod-&gt;syms
comma
id|mod-&gt;nsyms
comma
id|mod
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;syms out of bounds.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;ndeps
op_logical_and
op_logical_neg
id|bound
c_func
(paren
id|mod-&gt;deps
comma
id|mod-&gt;ndeps
comma
id|mod
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;deps out of bounds.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;init
op_logical_and
op_logical_neg
id|bound
c_func
(paren
id|mod-&gt;init
comma
l_int|0
comma
id|mod
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;init out of bounds.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;cleanup
op_logical_and
op_logical_neg
id|bound
c_func
(paren
id|mod-&gt;cleanup
comma
l_int|0
comma
id|mod
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;cleanup out of bounds.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;ex_table_start
OG
id|mod-&gt;ex_table_end
op_logical_or
(paren
id|mod-&gt;ex_table_start
op_logical_and
op_logical_neg
(paren
(paren
r_int
r_int
)paren
id|mod-&gt;ex_table_start
op_ge
(paren
r_int
r_int
)paren
(paren
id|mod
op_plus
l_int|1
)paren
op_logical_and
(paren
(paren
r_int
r_int
)paren
id|mod-&gt;ex_table_end
OL
(paren
r_int
r_int
)paren
id|mod
op_plus
id|mod-&gt;size
)paren
)paren
)paren
op_logical_or
(paren
(paren
(paren
r_int
r_int
)paren
id|mod-&gt;ex_table_start
op_minus
(paren
r_int
r_int
)paren
id|mod-&gt;ex_table_end
)paren
op_mod
r_sizeof
(paren
r_struct
id|exception_table_entry
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;ex_table_* invalid.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;flags
op_amp
op_complement
id|MOD_AUTOCLEAN
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;flags invalid.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
macro_line|#ifdef __alpha__
r_if
c_cond
(paren
op_logical_neg
id|bound
c_func
(paren
id|mod-&gt;gp
op_minus
l_int|0x8000
comma
l_int|0
comma
id|mod
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;gp out of bounds.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|mod_member_present
c_func
(paren
id|mod
comma
id|can_unload
)paren
op_logical_and
id|mod-&gt;can_unload
op_logical_and
op_logical_neg
id|bound
c_func
(paren
id|mod-&gt;can_unload
comma
l_int|0
comma
id|mod
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: mod-&gt;can_unload out of bounds.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
DECL|macro|bound
macro_line|#undef bound
multiline_comment|/* Check that the user isn&squot;t doing something silly with the name.  */
r_if
c_cond
(paren
(paren
id|n_namelen
op_assign
id|get_mod_name
c_func
(paren
id|mod-&gt;name
op_minus
(paren
r_int
r_int
)paren
id|mod
op_plus
(paren
r_int
r_int
)paren
id|mod_user
comma
op_amp
id|n_name
)paren
)paren
OL
l_int|0
)paren
(brace
id|error
op_assign
id|n_namelen
suffix:semicolon
r_goto
id|err2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|namelen
op_ne
id|n_namelen
op_logical_or
id|strcmp
c_func
(paren
id|n_name
comma
id|mod_tmp.name
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: changed module name to &quot;
l_string|&quot;`%s&squot; from `%s&squot;&bslash;n&quot;
comma
id|n_name
comma
id|mod_tmp.name
)paren
suffix:semicolon
r_goto
id|err3
suffix:semicolon
)brace
multiline_comment|/* Ok, that&squot;s about all the sanity we can stomach; copy the rest.  */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|mod
op_plus
l_int|1
comma
id|mod_user
op_plus
l_int|1
comma
id|mod-&gt;size
op_minus
r_sizeof
(paren
op_star
id|mod
)paren
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|err3
suffix:semicolon
)brace
multiline_comment|/* On some machines it is necessary to do something here&n;&t;   to make the I and D caches consistent.  */
id|flush_icache_range
c_func
(paren
(paren
r_int
r_int
)paren
id|mod
comma
(paren
r_int
r_int
)paren
id|mod
op_plus
id|mod-&gt;size
)paren
suffix:semicolon
multiline_comment|/* Update module references.  */
id|mod-&gt;next
op_assign
id|mod_tmp.next
suffix:semicolon
id|mod-&gt;refs
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|dep
op_assign
id|mod-&gt;deps
suffix:semicolon
id|i
OL
id|mod-&gt;ndeps
suffix:semicolon
op_increment
id|i
comma
op_increment
id|dep
)paren
(brace
r_struct
id|module
op_star
id|o
comma
op_star
id|d
op_assign
id|dep-&gt;dep
suffix:semicolon
multiline_comment|/* Make sure the indicated dependencies are really modules.  */
r_if
c_cond
(paren
id|d
op_eq
id|mod
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: self-referential &quot;
l_string|&quot;dependency in mod-&gt;deps.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err3
suffix:semicolon
)brace
r_for
c_loop
(paren
id|o
op_assign
id|module_list
suffix:semicolon
id|o
op_ne
op_amp
id|kernel_module
suffix:semicolon
id|o
op_assign
id|o-&gt;next
)paren
r_if
c_cond
(paren
id|o
op_eq
id|d
)paren
r_goto
id|found_dep
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;init_module: found dependency that is &quot;
l_string|&quot;(no longer?) a module.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err3
suffix:semicolon
id|found_dep
suffix:colon
id|dep-&gt;ref
op_assign
id|mod
suffix:semicolon
id|dep-&gt;next_ref
op_assign
id|d-&gt;refs
suffix:semicolon
id|d-&gt;refs
op_assign
id|dep
suffix:semicolon
multiline_comment|/* Being referenced by a dependent module counts as a &n;&t;&t;   use as far as kmod is concerned.  */
id|d-&gt;flags
op_or_assign
id|MOD_USED_ONCE
suffix:semicolon
)brace
multiline_comment|/* Free our temporary memory.  */
id|put_mod_name
c_func
(paren
id|n_name
)paren
suffix:semicolon
id|put_mod_name
c_func
(paren
id|name
)paren
suffix:semicolon
multiline_comment|/* Initialize the module.  */
id|atomic_set
c_func
(paren
op_amp
id|mod-&gt;uc.usecount
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;init
op_logical_and
id|mod
op_member_access_from_pointer
id|init
c_func
(paren
)paren
op_ne
l_int|0
)paren
(brace
id|atomic_set
c_func
(paren
op_amp
id|mod-&gt;uc.usecount
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|err0
suffix:semicolon
)brace
id|atomic_dec
c_func
(paren
op_amp
id|mod-&gt;uc.usecount
)paren
suffix:semicolon
multiline_comment|/* And set it running.  */
id|mod-&gt;flags
op_or_assign
id|MOD_RUNNING
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_goto
id|err0
suffix:semicolon
id|err3
suffix:colon
id|put_mod_name
c_func
(paren
id|n_name
)paren
suffix:semicolon
id|err2
suffix:colon
op_star
id|mod
op_assign
id|mod_tmp
suffix:semicolon
id|err1
suffix:colon
id|put_mod_name
c_func
(paren
id|name
)paren
suffix:semicolon
id|err0
suffix:colon
id|write_unlock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_delete_module
id|sys_delete_module
c_func
(paren
r_const
r_char
op_star
id|name_user
)paren
(brace
r_struct
id|module
op_star
id|mod
comma
op_star
id|next
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_int
id|something_changed
suffix:semicolon
id|write_lock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_MODULE
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|name_user
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|get_mod_name
c_func
(paren
id|name_user
comma
op_amp
id|name
)paren
)paren
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|put_mod_name
c_func
(paren
id|name
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mod
op_assign
id|find_module
c_func
(paren
id|name
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|put_mod_name
c_func
(paren
id|name
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|put_mod_name
c_func
(paren
id|name
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;refs
op_ne
l_int|NULL
op_logical_or
id|__MOD_IN_USE
c_func
(paren
id|mod
)paren
)paren
r_goto
id|out
suffix:semicolon
id|free_module
c_func
(paren
id|mod
comma
l_int|0
)paren
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/* Do automatic reaping */
id|restart
suffix:colon
id|something_changed
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|mod
op_assign
id|module_list
suffix:semicolon
id|mod
op_ne
op_amp
id|kernel_module
suffix:semicolon
id|mod
op_assign
id|next
)paren
(brace
id|next
op_assign
id|mod-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;refs
op_eq
l_int|NULL
op_logical_and
(paren
id|mod-&gt;flags
op_amp
id|MOD_AUTOCLEAN
)paren
op_logical_and
(paren
id|mod-&gt;flags
op_amp
id|MOD_RUNNING
)paren
op_logical_and
op_logical_neg
(paren
id|mod-&gt;flags
op_amp
id|MOD_DELETED
)paren
op_logical_and
(paren
id|mod-&gt;flags
op_amp
id|MOD_USED_ONCE
)paren
op_logical_and
op_logical_neg
id|__MOD_IN_USE
c_func
(paren
id|mod
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|mod-&gt;flags
op_amp
id|MOD_VISITED
)paren
op_logical_and
op_logical_neg
(paren
id|mod-&gt;flags
op_amp
id|MOD_JUST_FREED
)paren
)paren
(brace
id|mod-&gt;flags
op_and_assign
op_complement
id|MOD_VISITED
suffix:semicolon
)brace
r_else
(brace
id|free_module
c_func
(paren
id|mod
comma
l_int|1
)paren
suffix:semicolon
id|something_changed
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|something_changed
)paren
r_goto
id|restart
suffix:semicolon
r_for
c_loop
(paren
id|mod
op_assign
id|module_list
suffix:semicolon
id|mod
op_ne
op_amp
id|kernel_module
suffix:semicolon
id|mod
op_assign
id|mod-&gt;next
)paren
id|mod-&gt;flags
op_and_assign
op_complement
id|MOD_JUST_FREED
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|write_unlock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Query various bits about modules.  */
r_static
r_int
DECL|function|qm_modules
id|qm_modules
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|bufsize
comma
r_int
op_star
id|ret
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_int
id|nmod
comma
id|space
comma
id|len
suffix:semicolon
id|nmod
op_assign
id|space
op_assign
l_int|0
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mod
op_assign
id|module_list
suffix:semicolon
id|mod
op_ne
op_amp
id|kernel_module
suffix:semicolon
id|mod
op_assign
id|mod-&gt;next
comma
op_increment
id|nmod
)paren
(brace
id|len
op_assign
id|strlen
c_func
(paren
id|mod-&gt;name
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|bufsize
)paren
r_goto
id|calc_space_needed
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|mod-&gt;name
comma
id|len
)paren
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|buf
op_add_assign
id|len
suffix:semicolon
id|bufsize
op_sub_assign
id|len
suffix:semicolon
id|space
op_add_assign
id|len
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|nmod
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
id|calc_space_needed
suffix:colon
id|space
op_add_assign
id|len
suffix:semicolon
r_while
c_loop
(paren
(paren
id|mod
op_assign
id|mod-&gt;next
)paren
op_ne
op_amp
id|kernel_module
)paren
id|space
op_add_assign
id|strlen
c_func
(paren
id|mod-&gt;name
)paren
op_plus
l_int|1
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|space
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_static
r_int
DECL|function|qm_deps
id|qm_deps
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
r_char
op_star
id|buf
comma
r_int
id|bufsize
comma
r_int
op_star
id|ret
)paren
(brace
r_int
id|i
comma
id|space
comma
id|len
suffix:semicolon
r_if
c_cond
(paren
id|mod
op_eq
op_amp
id|kernel_module
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mod-&gt;flags
op_amp
(paren
id|MOD_RUNNING
op_or
id|MOD_DELETED
)paren
)paren
op_ne
id|MOD_RUNNING
)paren
r_if
c_cond
(paren
id|put_user
c_func
(paren
l_int|0
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
id|space
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mod-&gt;ndeps
suffix:semicolon
op_increment
id|i
)paren
(brace
r_const
r_char
op_star
id|dep_name
op_assign
id|mod-&gt;deps
(braket
id|i
)braket
dot
id|dep-&gt;name
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|dep_name
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|bufsize
)paren
r_goto
id|calc_space_needed
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|dep_name
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|buf
op_add_assign
id|len
suffix:semicolon
id|bufsize
op_sub_assign
id|len
suffix:semicolon
id|space
op_add_assign
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|i
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
id|calc_space_needed
suffix:colon
id|space
op_add_assign
id|len
suffix:semicolon
r_while
c_loop
(paren
op_increment
id|i
OL
id|mod-&gt;ndeps
)paren
id|space
op_add_assign
id|strlen
c_func
(paren
id|mod-&gt;deps
(braket
id|i
)braket
dot
id|dep-&gt;name
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|space
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_static
r_int
DECL|function|qm_refs
id|qm_refs
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
r_char
op_star
id|buf
comma
r_int
id|bufsize
comma
r_int
op_star
id|ret
)paren
(brace
r_int
id|nrefs
comma
id|space
comma
id|len
suffix:semicolon
r_struct
id|module_ref
op_star
id|ref
suffix:semicolon
r_if
c_cond
(paren
id|mod
op_eq
op_amp
id|kernel_module
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mod-&gt;flags
op_amp
(paren
id|MOD_RUNNING
op_or
id|MOD_DELETED
)paren
)paren
op_ne
id|MOD_RUNNING
)paren
r_if
c_cond
(paren
id|put_user
c_func
(paren
l_int|0
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
id|space
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|nrefs
op_assign
l_int|0
comma
id|ref
op_assign
id|mod-&gt;refs
suffix:semicolon
id|ref
suffix:semicolon
op_increment
id|nrefs
comma
id|ref
op_assign
id|ref-&gt;next_ref
)paren
(brace
r_const
r_char
op_star
id|ref_name
op_assign
id|ref-&gt;ref-&gt;name
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|ref_name
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|bufsize
)paren
r_goto
id|calc_space_needed
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
id|ref_name
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|buf
op_add_assign
id|len
suffix:semicolon
id|bufsize
op_sub_assign
id|len
suffix:semicolon
id|space
op_add_assign
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|nrefs
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
id|calc_space_needed
suffix:colon
id|space
op_add_assign
id|len
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ref
op_assign
id|ref-&gt;next_ref
)paren
op_ne
l_int|NULL
)paren
id|space
op_add_assign
id|strlen
c_func
(paren
id|ref-&gt;ref-&gt;name
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|space
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_static
r_int
DECL|function|qm_symbols
id|qm_symbols
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
r_char
op_star
id|buf
comma
r_int
id|bufsize
comma
r_int
op_star
id|ret
)paren
(brace
r_int
id|i
comma
id|space
comma
id|len
suffix:semicolon
r_struct
id|module_symbol
op_star
id|s
suffix:semicolon
r_char
op_star
id|strings
suffix:semicolon
r_int
r_int
op_star
id|vals
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mod-&gt;flags
op_amp
(paren
id|MOD_RUNNING
op_or
id|MOD_DELETED
)paren
)paren
op_ne
id|MOD_RUNNING
)paren
r_if
c_cond
(paren
id|put_user
c_func
(paren
l_int|0
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
id|space
op_assign
id|mod-&gt;nsyms
op_star
l_int|2
op_star
r_sizeof
(paren
r_void
op_star
)paren
suffix:semicolon
id|i
op_assign
id|len
op_assign
l_int|0
suffix:semicolon
id|s
op_assign
id|mod-&gt;syms
suffix:semicolon
r_if
c_cond
(paren
id|space
OG
id|bufsize
)paren
r_goto
id|calc_space_needed
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|access_ok
c_func
(paren
id|VERIFY_WRITE
comma
id|buf
comma
id|space
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|bufsize
op_sub_assign
id|space
suffix:semicolon
id|vals
op_assign
(paren
r_int
r_int
op_star
)paren
id|buf
suffix:semicolon
id|strings
op_assign
id|buf
op_plus
id|space
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|mod-&gt;nsyms
suffix:semicolon
op_increment
id|i
comma
op_increment
id|s
comma
id|vals
op_add_assign
l_int|2
)paren
(brace
id|len
op_assign
id|strlen
c_func
(paren
id|s-&gt;name
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|bufsize
)paren
r_goto
id|calc_space_needed
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|strings
comma
id|s-&gt;name
comma
id|len
)paren
op_logical_or
id|__put_user
c_func
(paren
id|s-&gt;value
comma
id|vals
op_plus
l_int|0
)paren
op_logical_or
id|__put_user
c_func
(paren
id|space
comma
id|vals
op_plus
l_int|1
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|strings
op_add_assign
id|len
suffix:semicolon
id|bufsize
op_sub_assign
id|len
suffix:semicolon
id|space
op_add_assign
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|i
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
id|calc_space_needed
suffix:colon
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
id|mod-&gt;nsyms
suffix:semicolon
op_increment
id|i
comma
op_increment
id|s
)paren
id|space
op_add_assign
id|strlen
c_func
(paren
id|s-&gt;name
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|space
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_static
r_int
DECL|function|qm_info
id|qm_info
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
r_char
op_star
id|buf
comma
r_int
id|bufsize
comma
r_int
op_star
id|ret
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mod
op_eq
op_amp
id|kernel_module
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|module_info
)paren
op_le
id|bufsize
)paren
(brace
r_struct
id|module_info
id|info
suffix:semicolon
id|info.addr
op_assign
(paren
r_int
r_int
)paren
id|mod
suffix:semicolon
id|info.size
op_assign
id|mod-&gt;size
suffix:semicolon
id|info.flags
op_assign
id|mod-&gt;flags
suffix:semicolon
id|info.usecount
op_assign
(paren
id|mod_member_present
c_func
(paren
id|mod
comma
id|can_unload
)paren
op_logical_and
id|mod-&gt;can_unload
ques
c_cond
op_minus
l_int|1
suffix:colon
id|atomic_read
c_func
(paren
op_amp
id|mod-&gt;uc.usecount
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
op_amp
id|info
comma
r_sizeof
(paren
r_struct
id|module_info
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
id|error
op_assign
op_minus
id|ENOSPC
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
r_sizeof
(paren
r_struct
id|module_info
)paren
comma
id|ret
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_query_module
id|sys_query_module
c_func
(paren
r_const
r_char
op_star
id|name_user
comma
r_int
id|which
comma
r_char
op_star
id|buf
comma
r_int
id|bufsize
comma
r_int
op_star
id|ret
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_int
id|err
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name_user
op_eq
l_int|NULL
)paren
id|mod
op_assign
op_amp
id|kernel_module
suffix:semicolon
r_else
(brace
r_int
id|namelen
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_if
c_cond
(paren
(paren
id|namelen
op_assign
id|get_mod_name
c_func
(paren
id|name_user
comma
op_amp
id|name
)paren
)paren
OL
l_int|0
)paren
(brace
id|err
op_assign
id|namelen
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|namelen
op_eq
l_int|0
)paren
id|mod
op_assign
op_amp
id|kernel_module
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|mod
op_assign
id|find_module
c_func
(paren
id|name
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|put_mod_name
c_func
(paren
id|name
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|put_mod_name
c_func
(paren
id|name
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|which
)paren
(brace
r_case
l_int|0
suffix:colon
id|err
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QM_MODULES
suffix:colon
id|err
op_assign
id|qm_modules
c_func
(paren
id|buf
comma
id|bufsize
comma
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QM_DEPS
suffix:colon
id|err
op_assign
id|qm_deps
c_func
(paren
id|mod
comma
id|buf
comma
id|bufsize
comma
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QM_REFS
suffix:colon
id|err
op_assign
id|qm_refs
c_func
(paren
id|mod
comma
id|buf
comma
id|bufsize
comma
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QM_SYMBOLS
suffix:colon
id|err
op_assign
id|qm_symbols
c_func
(paren
id|mod
comma
id|buf
comma
id|bufsize
comma
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QM_INFO
suffix:colon
id|err
op_assign
id|qm_info
c_func
(paren
id|mod
comma
id|buf
comma
id|bufsize
comma
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|out
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Copy the kernel symbol table to user space.  If the argument is&n; * NULL, just return the size of the table.&n; *&n; * This call is obsolete.  New programs should use query_module+QM_SYMBOLS&n; * which does not arbitrarily limit the length of symbols.&n; */
id|asmlinkage
r_int
DECL|function|sys_get_kernel_syms
id|sys_get_kernel_syms
c_func
(paren
r_struct
id|kernel_sym
op_star
id|table
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|kernel_sym
id|ksym
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mod
op_assign
id|module_list
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|mod
suffix:semicolon
id|mod
op_assign
id|mod-&gt;next
)paren
(brace
multiline_comment|/* include the count for the module name! */
id|i
op_add_assign
id|mod-&gt;nsyms
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|table
op_eq
l_int|NULL
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* So that we don&squot;t give the user our stack content */
id|memset
(paren
op_amp
id|ksym
comma
l_int|0
comma
r_sizeof
(paren
id|ksym
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mod
op_assign
id|module_list
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|mod
suffix:semicolon
id|mod
op_assign
id|mod-&gt;next
)paren
(brace
r_struct
id|module_symbol
op_star
id|msym
suffix:semicolon
r_int
r_int
id|j
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mod-&gt;flags
op_amp
(paren
id|MOD_RUNNING
op_or
id|MOD_DELETED
)paren
)paren
op_ne
id|MOD_RUNNING
)paren
r_continue
suffix:semicolon
multiline_comment|/* magic: write module info as a pseudo symbol */
id|ksym.value
op_assign
(paren
r_int
r_int
)paren
id|mod
suffix:semicolon
id|ksym.name
(braket
l_int|0
)braket
op_assign
l_char|&squot;#&squot;
suffix:semicolon
id|strncpy
c_func
(paren
id|ksym.name
op_plus
l_int|1
comma
id|mod-&gt;name
comma
r_sizeof
(paren
id|ksym.name
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|ksym.name
(braket
r_sizeof
(paren
id|ksym.name
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|table
comma
op_amp
id|ksym
comma
r_sizeof
(paren
id|ksym
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
op_increment
id|i
comma
op_increment
id|table
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;nsyms
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
comma
id|msym
op_assign
id|mod-&gt;syms
suffix:semicolon
id|j
OL
id|mod-&gt;nsyms
suffix:semicolon
op_increment
id|j
comma
op_increment
id|msym
)paren
(brace
id|ksym.value
op_assign
id|msym-&gt;value
suffix:semicolon
id|strncpy
c_func
(paren
id|ksym.name
comma
id|msym-&gt;name
comma
r_sizeof
(paren
id|ksym.name
)paren
)paren
suffix:semicolon
id|ksym.name
(braket
r_sizeof
(paren
id|ksym.name
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|table
comma
op_amp
id|ksym
comma
r_sizeof
(paren
id|ksym
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
op_increment
id|i
comma
op_increment
id|table
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * Look for a module by name, ignoring modules marked for deletion.&n; * Callers must hold modlist_lock at least in read mode.&n; */
r_static
r_struct
id|module
op_star
DECL|function|find_module
id|find_module
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_for
c_loop
(paren
id|mod
op_assign
id|module_list
suffix:semicolon
id|mod
suffix:semicolon
id|mod
op_assign
id|mod-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|mod-&gt;flags
op_amp
id|MOD_DELETED
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|mod-&gt;name
comma
id|name
)paren
)paren
r_break
suffix:semicolon
)brace
r_return
id|mod
suffix:semicolon
)brace
multiline_comment|/*&n; * Free the given module.&n; * Callers must hold modlist_lock in exclusive (write) mode.&n; */
r_static
r_void
DECL|function|free_module
id|free_module
c_func
(paren
r_struct
id|module
op_star
id|mod
comma
r_int
id|tag_freed
)paren
(brace
r_struct
id|module_ref
op_star
id|dep
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Let the module clean up.  */
id|mod-&gt;flags
op_or_assign
id|MOD_DELETED
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;flags
op_amp
id|MOD_RUNNING
)paren
(brace
r_if
c_cond
(paren
id|mod-&gt;cleanup
)paren
(brace
id|mod
op_member_access_from_pointer
id|cleanup
c_func
(paren
)paren
suffix:semicolon
)brace
id|mod-&gt;flags
op_and_assign
op_complement
id|MOD_RUNNING
suffix:semicolon
)brace
multiline_comment|/* Remove the module from the dependency lists.  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|dep
op_assign
id|mod-&gt;deps
suffix:semicolon
id|i
OL
id|mod-&gt;ndeps
suffix:semicolon
op_increment
id|i
comma
op_increment
id|dep
)paren
(brace
r_struct
id|module_ref
op_star
op_star
id|pp
suffix:semicolon
r_for
c_loop
(paren
id|pp
op_assign
op_amp
id|dep-&gt;dep-&gt;refs
suffix:semicolon
op_star
id|pp
op_ne
id|dep
suffix:semicolon
id|pp
op_assign
op_amp
(paren
op_star
id|pp
)paren
op_member_access_from_pointer
id|next_ref
)paren
r_continue
suffix:semicolon
op_star
id|pp
op_assign
id|dep-&gt;next_ref
suffix:semicolon
r_if
c_cond
(paren
id|tag_freed
op_logical_and
id|dep-&gt;dep-&gt;refs
op_eq
l_int|NULL
)paren
id|dep-&gt;dep-&gt;flags
op_or_assign
id|MOD_JUST_FREED
suffix:semicolon
)brace
multiline_comment|/* And from the main module list.  */
r_if
c_cond
(paren
id|mod
op_eq
id|module_list
)paren
(brace
id|module_list
op_assign
id|mod-&gt;next
suffix:semicolon
)brace
r_else
(brace
r_struct
id|module
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|module_list
suffix:semicolon
id|p-&gt;next
op_ne
id|mod
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
r_continue
suffix:semicolon
id|p-&gt;next
op_assign
id|mod-&gt;next
suffix:semicolon
)brace
multiline_comment|/* And free the memory.  */
id|module_unmap
c_func
(paren
id|mod
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by the /proc file system to return a current list of modules.&n; */
DECL|function|get_module_list
r_int
id|get_module_list
c_func
(paren
r_char
op_star
id|p
)paren
(brace
r_int
id|left
op_assign
id|PAGE_SIZE
suffix:semicolon
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_char
id|tmpstr
(braket
l_int|64
)braket
suffix:semicolon
r_struct
id|module_ref
op_star
id|ref
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mod
op_assign
id|module_list
suffix:semicolon
id|mod
op_ne
op_amp
id|kernel_module
suffix:semicolon
id|mod
op_assign
id|mod-&gt;next
)paren
(brace
r_int
id|len
suffix:semicolon
r_const
r_char
op_star
id|q
suffix:semicolon
DECL|macro|safe_copy_str
mdefine_line|#define safe_copy_str(str, len)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;if (left &lt; len)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;goto fini;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;memcpy(p, str, len); p += len, left -= len;&t;&bslash;&n;&t;&t;} while (0)
DECL|macro|safe_copy_cstr
mdefine_line|#define safe_copy_cstr(str)&t;safe_copy_str(str, sizeof(str)-1)
id|len
op_assign
id|strlen
c_func
(paren
id|mod-&gt;name
)paren
suffix:semicolon
id|safe_copy_str
c_func
(paren
id|mod-&gt;name
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_assign
l_int|20
op_minus
id|len
)paren
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|left
OL
id|len
)paren
r_goto
id|fini
suffix:semicolon
id|memset
c_func
(paren
id|p
comma
l_char|&squot; &squot;
comma
id|len
)paren
suffix:semicolon
id|p
op_add_assign
id|len
suffix:semicolon
id|left
op_sub_assign
id|len
suffix:semicolon
)brace
id|len
op_assign
id|sprintf
c_func
(paren
id|tmpstr
comma
l_string|&quot;%8lu&quot;
comma
id|mod-&gt;size
)paren
suffix:semicolon
id|safe_copy_str
c_func
(paren
id|tmpstr
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mod-&gt;flags
op_amp
id|MOD_RUNNING
)paren
(brace
id|len
op_assign
id|sprintf
c_func
(paren
id|tmpstr
comma
l_string|&quot;%4ld&quot;
comma
(paren
id|mod_member_present
c_func
(paren
id|mod
comma
id|can_unload
)paren
op_logical_and
id|mod-&gt;can_unload
ques
c_cond
op_minus
l_int|1L
suffix:colon
(paren
r_int
)paren
id|atomic_read
c_func
(paren
op_amp
id|mod-&gt;uc.usecount
)paren
)paren
)paren
suffix:semicolon
id|safe_copy_str
c_func
(paren
id|tmpstr
comma
id|len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod-&gt;flags
op_amp
id|MOD_DELETED
)paren
id|safe_copy_cstr
c_func
(paren
l_string|&quot; (deleted)&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mod-&gt;flags
op_amp
id|MOD_RUNNING
)paren
(brace
r_if
c_cond
(paren
id|mod-&gt;flags
op_amp
id|MOD_AUTOCLEAN
)paren
id|safe_copy_cstr
c_func
(paren
l_string|&quot; (autoclean)&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mod-&gt;flags
op_amp
id|MOD_USED_ONCE
)paren
)paren
id|safe_copy_cstr
c_func
(paren
l_string|&quot; (unused)&quot;
)paren
suffix:semicolon
)brace
r_else
id|safe_copy_cstr
c_func
(paren
l_string|&quot; (uninitialized)&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ref
op_assign
id|mod-&gt;refs
)paren
op_ne
l_int|NULL
)paren
(brace
id|safe_copy_cstr
c_func
(paren
l_string|&quot; [&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|q
op_assign
id|ref-&gt;ref-&gt;name
suffix:semicolon
id|len
op_assign
id|strlen
c_func
(paren
id|q
)paren
suffix:semicolon
id|safe_copy_str
c_func
(paren
id|q
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ref
op_assign
id|ref-&gt;next_ref
)paren
op_ne
l_int|NULL
)paren
id|safe_copy_cstr
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
id|safe_copy_cstr
c_func
(paren
l_string|&quot;]&quot;
)paren
suffix:semicolon
)brace
id|safe_copy_cstr
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
DECL|macro|safe_copy_str
macro_line|#undef safe_copy_str
DECL|macro|safe_copy_cstr
macro_line|#undef safe_copy_cstr
)brace
id|fini
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_return
id|PAGE_SIZE
op_minus
id|left
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by the /proc file system to return a current list of ksyms.&n; */
r_int
DECL|function|get_ksyms_list
id|get_ksyms_list
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
)paren
(brace
r_struct
id|module
op_star
id|mod
suffix:semicolon
r_char
op_star
id|p
op_assign
id|buf
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* code from  net/ipv4/proc.c */
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mod
op_assign
id|module_list
suffix:semicolon
id|mod
suffix:semicolon
id|mod
op_assign
id|mod-&gt;next
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|module_symbol
op_star
id|sym
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mod-&gt;flags
op_amp
id|MOD_RUNNING
)paren
op_logical_or
(paren
id|mod-&gt;flags
op_amp
id|MOD_DELETED
)paren
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|mod-&gt;nsyms
comma
id|sym
op_assign
id|mod-&gt;syms
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
comma
op_increment
id|sym
)paren
(brace
id|p
op_assign
id|buf
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
op_star
id|mod-&gt;name
)paren
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%0*lx %s&bslash;t[%s]&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
l_int|2
op_star
r_sizeof
(paren
r_void
op_star
)paren
)paren
comma
id|sym-&gt;value
comma
id|sym-&gt;name
comma
id|mod-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|len
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%0*lx %s&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
l_int|2
op_star
r_sizeof
(paren
r_void
op_star
)paren
)paren
comma
id|sym-&gt;value
comma
id|sym-&gt;name
)paren
suffix:semicolon
)brace
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OL
id|offset
)paren
(brace
id|len
op_assign
l_int|0
suffix:semicolon
id|begin
op_assign
id|pos
suffix:semicolon
)brace
id|pos
op_assign
id|begin
op_plus
id|len
suffix:semicolon
r_if
c_cond
(paren
id|pos
OG
id|offset
op_plus
id|length
)paren
r_goto
id|leave_the_loop
suffix:semicolon
)brace
)brace
id|leave_the_loop
suffix:colon
op_star
id|start
op_assign
id|buf
op_plus
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
id|len
op_sub_assign
(paren
id|offset
op_minus
id|begin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * Gets the address for a symbol in the given module.  If modname is&n; * NULL, it looks for the name in any registered symbol table.  If the&n; * modname is an empty string, it looks for the symbol in kernel exported&n; * symbol tables.&n; */
r_int
r_int
DECL|function|get_module_symbol
id|get_module_symbol
c_func
(paren
r_char
op_star
id|modname
comma
r_char
op_star
id|symname
)paren
(brace
r_struct
id|module
op_star
id|mp
suffix:semicolon
r_struct
id|module_symbol
op_star
id|sym
suffix:semicolon
r_int
id|i
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mp
op_assign
id|module_list
suffix:semicolon
id|mp
suffix:semicolon
id|mp
op_assign
id|mp-&gt;next
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|modname
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|strcmp
c_func
(paren
id|mp-&gt;name
comma
id|modname
)paren
op_eq
l_int|0
)paren
)paren
op_logical_and
(paren
id|mp-&gt;flags
op_amp
(paren
id|MOD_RUNNING
op_or
id|MOD_DELETED
)paren
)paren
op_eq
id|MOD_RUNNING
op_logical_and
(paren
id|mp-&gt;nsyms
OG
l_int|0
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|mp-&gt;nsyms
comma
id|sym
op_assign
id|mp-&gt;syms
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
op_decrement
id|i
comma
op_increment
id|sym
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|sym-&gt;name
comma
id|symname
)paren
op_eq
l_int|0
)paren
(brace
id|read_unlock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_return
id|sym-&gt;value
suffix:semicolon
)brace
)brace
)brace
)brace
id|read_unlock
c_func
(paren
op_amp
id|modlist_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else&t;&t;/* CONFIG_MODULES */
multiline_comment|/* no MODULES so high_memory is good enough for /proc/kcore (TA) */
DECL|function|get_kcore_size
r_int
r_int
id|get_kcore_size
c_func
(paren
r_void
)paren
(brace
r_return
(paren
(paren
r_int
r_int
)paren
id|high_memory
op_minus
id|PAGE_OFFSET
op_plus
id|PAGE_SIZE
)paren
suffix:semicolon
)brace
multiline_comment|/* Dummy syscalls for people who don&squot;t want modules */
id|asmlinkage
r_int
r_int
DECL|function|sys_create_module
id|sys_create_module
c_func
(paren
r_const
r_char
op_star
id|name_user
comma
r_int
id|size
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_init_module
id|sys_init_module
c_func
(paren
r_const
r_char
op_star
id|name_user
comma
r_struct
id|module
op_star
id|mod_user
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_delete_module
id|sys_delete_module
c_func
(paren
r_const
r_char
op_star
id|name_user
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_query_module
id|sys_query_module
c_func
(paren
r_const
r_char
op_star
id|name_user
comma
r_int
id|which
comma
r_char
op_star
id|buf
comma
r_int
id|bufsize
comma
r_int
op_star
id|ret
)paren
(brace
multiline_comment|/* Let the program know about the new interface.  Not that&n;&t;   it&squot;ll do them much good.  */
r_if
c_cond
(paren
id|which
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
id|asmlinkage
r_int
DECL|function|sys_get_kernel_syms
id|sys_get_kernel_syms
c_func
(paren
r_struct
id|kernel_sym
op_star
id|table
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_MODULES */
eof
