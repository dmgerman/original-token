multiline_comment|/*&n; * linux/kernel/math/add.c&n; *&n; * Copyright (C) 1991, 1992 Linus Torvalds&n; */
multiline_comment|/*&n; * temporary real addition routine.&n; *&n; * NOTE! These aren&squot;t exact: they are only 62 bits wide, and don&squot;t do&n; * correct rounding. Fast hack. The reason is that we shift right the&n; * values by two, in order not to have overflow (1 bit), and to be able&n; * to move the sign into the mantissa (1 bit). Much simpler algorithms,&n; * and 62 bits (61 really - no rounding) accuracy is usually enough. The&n; * only time you should notice anything weird is when adding 64-bit&n; * integers together. When using doubles (52 bits accuracy), the&n; * 61-bit accuracy never shows at all.&n; */
macro_line|#include &lt;linux/math_emu.h&gt;
DECL|macro|NEGINT
mdefine_line|#define NEGINT(a) &bslash;&n;__asm__(&quot;notl %0 ; notl %1 ; addl $1,%0 ; adcl $0,%1&quot; &bslash;&n;&t;:&quot;=r&quot; (a-&gt;a),&quot;=r&quot; (a-&gt;b) &bslash;&n;&t;:&quot;0&quot; (a-&gt;a),&quot;1&quot; (a-&gt;b))
DECL|function|signify
r_static
r_void
id|signify
c_func
(paren
id|temp_real
op_star
id|a
)paren
(brace
id|a-&gt;exponent
op_add_assign
l_int|2
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;shrdl $2,%1,%0 ; shrl $2,%1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|a-&gt;a
)paren
comma
l_string|&quot;=r&quot;
(paren
id|a-&gt;b
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|a-&gt;a
)paren
comma
l_string|&quot;1&quot;
(paren
id|a-&gt;b
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;exponent
OL
l_int|0
)paren
id|NEGINT
c_func
(paren
id|a
)paren
suffix:semicolon
id|a-&gt;exponent
op_and_assign
l_int|0x7fff
suffix:semicolon
)brace
DECL|function|unsignify
r_static
r_void
id|unsignify
c_func
(paren
id|temp_real
op_star
id|a
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|a-&gt;a
op_logical_or
id|a-&gt;b
)paren
)paren
(brace
id|a-&gt;exponent
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|a-&gt;exponent
op_and_assign
l_int|0x7fff
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;b
OL
l_int|0
)paren
(brace
id|NEGINT
c_func
(paren
id|a
)paren
suffix:semicolon
id|a-&gt;exponent
op_or_assign
l_int|0x8000
suffix:semicolon
)brace
r_while
c_loop
(paren
id|a-&gt;b
op_ge
l_int|0
)paren
(brace
id|a-&gt;exponent
op_decrement
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;addl %0,%0 ; adcl %1,%1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|a-&gt;a
)paren
comma
l_string|&quot;=r&quot;
(paren
id|a-&gt;b
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|a-&gt;a
)paren
comma
l_string|&quot;1&quot;
(paren
id|a-&gt;b
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|fadd
r_void
id|fadd
c_func
(paren
r_const
id|temp_real
op_star
id|src1
comma
r_const
id|temp_real
op_star
id|src2
comma
id|temp_real
op_star
id|result
)paren
(brace
id|temp_real
id|a
comma
id|b
suffix:semicolon
r_int
id|x1
comma
id|x2
comma
id|shift
suffix:semicolon
id|x1
op_assign
id|src1-&gt;exponent
op_amp
l_int|0x7fff
suffix:semicolon
id|x2
op_assign
id|src2-&gt;exponent
op_amp
l_int|0x7fff
suffix:semicolon
r_if
c_cond
(paren
id|x1
OG
id|x2
)paren
(brace
id|a
op_assign
op_star
id|src1
suffix:semicolon
id|b
op_assign
op_star
id|src2
suffix:semicolon
id|shift
op_assign
id|x1
op_minus
id|x2
suffix:semicolon
)brace
r_else
(brace
id|a
op_assign
op_star
id|src2
suffix:semicolon
id|b
op_assign
op_star
id|src1
suffix:semicolon
id|shift
op_assign
id|x2
op_minus
id|x1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|shift
op_ge
l_int|64
)paren
(brace
op_star
id|result
op_assign
id|a
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|shift
op_ge
l_int|32
)paren
(brace
id|b.a
op_assign
id|b.b
suffix:semicolon
id|b.b
op_assign
l_int|0
suffix:semicolon
id|shift
op_sub_assign
l_int|32
suffix:semicolon
)brace
id|__asm__
c_func
(paren
l_string|&quot;shrdl %4,%1,%0 ; shrl %4,%1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|b.a
)paren
comma
l_string|&quot;=r&quot;
(paren
id|b.b
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|b.a
)paren
comma
l_string|&quot;1&quot;
(paren
id|b.b
)paren
comma
l_string|&quot;c&quot;
(paren
(paren
r_char
)paren
id|shift
)paren
)paren
suffix:semicolon
id|signify
c_func
(paren
op_amp
id|a
)paren
suffix:semicolon
id|signify
c_func
(paren
op_amp
id|b
)paren
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;addl %4,%0 ; adcl %5,%1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|a.a
)paren
comma
l_string|&quot;=r&quot;
(paren
id|a.b
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|a.a
)paren
comma
l_string|&quot;1&quot;
(paren
id|a.b
)paren
comma
l_string|&quot;g&quot;
(paren
id|b.a
)paren
comma
l_string|&quot;g&quot;
(paren
id|b.b
)paren
)paren
suffix:semicolon
id|unsignify
c_func
(paren
op_amp
id|a
)paren
suffix:semicolon
op_star
id|result
op_assign
id|a
suffix:semicolon
)brace
eof
