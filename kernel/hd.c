macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
multiline_comment|/*&n; * This code handles all hd-interrupts, and read/write requests to&n; * the hard-disk. It is relatively straigthforward (not obvious maybe,&n; * but interrupts never are), while still being efficient, and never&n; * disabling interrupts (except to overcome possible race-condition).&n; * The elevator block-seek algorithm doesn&squot;t need to disable interrupts&n; * due to clever programming.&n; */
multiline_comment|/* Max read/write errors/sector */
DECL|macro|MAX_ERRORS
mdefine_line|#define MAX_ERRORS&t;5
DECL|macro|MAX_HD
mdefine_line|#define MAX_HD&t;&t;2
DECL|macro|NR_REQUEST
mdefine_line|#define NR_REQUEST&t;32
multiline_comment|/*&n; *  This struct defines the HD&squot;s and their types.&n; *  Currently defined for CP3044&squot;s, ie a modified&n; *  type 17.&n; */
DECL|struct|hd_i_struct
r_static
r_struct
id|hd_i_struct
(brace
DECL|member|head
DECL|member|sect
DECL|member|cyl
DECL|member|wpcom
DECL|member|lzone
DECL|member|ctl
r_int
id|head
comma
id|sect
comma
id|cyl
comma
id|wpcom
comma
id|lzone
comma
id|ctl
suffix:semicolon
DECL|variable|hd_info
)brace
id|hd_info
(braket
)braket
op_assign
(brace
id|HD_TYPE
)brace
suffix:semicolon
DECL|macro|NR_HD
mdefine_line|#define NR_HD ((sizeof (hd_info))/(sizeof (struct hd_i_struct)))
DECL|struct|hd_struct
r_static
r_struct
id|hd_struct
(brace
DECL|member|start_sect
r_int
id|start_sect
suffix:semicolon
DECL|member|nr_sects
r_int
id|nr_sects
suffix:semicolon
DECL|variable|hd
)brace
id|hd
(braket
l_int|5
op_star
id|MAX_HD
)braket
op_assign
initialization_block
suffix:semicolon
DECL|struct|hd_request
r_static
r_struct
id|hd_request
(brace
DECL|member|hd
r_int
id|hd
suffix:semicolon
multiline_comment|/* -1 if no request */
DECL|member|nsector
r_int
id|nsector
suffix:semicolon
DECL|member|sector
r_int
id|sector
suffix:semicolon
DECL|member|head
r_int
id|head
suffix:semicolon
DECL|member|cyl
r_int
id|cyl
suffix:semicolon
DECL|member|cmd
r_int
id|cmd
suffix:semicolon
DECL|member|errors
r_int
id|errors
suffix:semicolon
DECL|member|bh
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
DECL|member|next
r_struct
id|hd_request
op_star
id|next
suffix:semicolon
DECL|variable|request
)brace
id|request
(braket
id|NR_REQUEST
)braket
suffix:semicolon
DECL|macro|IN_ORDER
mdefine_line|#define IN_ORDER(s1,s2) &bslash;&n;((s1)-&gt;hd&lt;(s2)-&gt;hd || (s1)-&gt;hd==(s2)-&gt;hd &amp;&amp; &bslash;&n;((s1)-&gt;cyl&lt;(s2)-&gt;cyl || (s1)-&gt;cyl==(s2)-&gt;cyl &amp;&amp; &bslash;&n;((s1)-&gt;head&lt;(s2)-&gt;head || (s1)-&gt;head==(s2)-&gt;head &amp;&amp; &bslash;&n;((s1)-&gt;sector&lt;(s2)-&gt;sector))))
DECL|variable|this_request
r_static
r_struct
id|hd_request
op_star
id|this_request
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|sorting
r_static
r_int
id|sorting
op_assign
l_int|0
suffix:semicolon
r_static
r_void
id|do_request
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|reset_controller
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|rw_abs_hd
c_func
(paren
r_int
id|rw
comma
r_int
r_int
id|nr
comma
r_int
r_int
id|sec
comma
r_int
r_int
id|head
comma
r_int
r_int
id|cyl
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
suffix:semicolon
r_void
id|hd_init
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|port_read
mdefine_line|#define port_read(port,buf,nr) &bslash;&n;__asm__(&quot;cld;rep;insw&quot;::&quot;d&quot; (port),&quot;D&quot; (buf),&quot;c&quot; (nr):&quot;cx&quot;,&quot;di&quot;)
DECL|macro|port_write
mdefine_line|#define port_write(port,buf,nr) &bslash;&n;__asm__(&quot;cld;rep;outsw&quot;::&quot;d&quot; (port),&quot;S&quot; (buf),&quot;c&quot; (nr):&quot;cx&quot;,&quot;si&quot;)
r_extern
r_void
id|hd_interrupt
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|wait_for_request
r_static
r_struct
id|task_struct
op_star
id|wait_for_request
op_assign
l_int|NULL
suffix:semicolon
DECL|function|lock_buffer
r_static
r_inline
r_void
id|lock_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_lock
)paren
id|printk
c_func
(paren
l_string|&quot;hd.c: buffer multiply locked&bslash;n&quot;
)paren
suffix:semicolon
id|bh-&gt;b_lock
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|unlock_buffer
r_static
r_inline
r_void
id|unlock_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bh-&gt;b_lock
)paren
id|printk
c_func
(paren
l_string|&quot;hd.c: free buffer being unlocked&bslash;n&quot;
)paren
suffix:semicolon
id|bh-&gt;b_lock
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|bh-&gt;b_wait
)paren
suffix:semicolon
)brace
DECL|function|wait_on_buffer
r_static
r_inline
r_void
id|wait_on_buffer
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|bh-&gt;b_lock
)paren
id|sleep_on
c_func
(paren
op_amp
id|bh-&gt;b_wait
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|rw_hd
r_void
id|rw_hd
c_func
(paren
r_int
id|rw
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_int
r_int
id|block
comma
id|dev
suffix:semicolon
r_int
r_int
id|sec
comma
id|head
comma
id|cyl
suffix:semicolon
id|block
op_assign
id|bh-&gt;b_blocknr
op_lshift
l_int|1
suffix:semicolon
id|dev
op_assign
id|MINOR
c_func
(paren
id|bh-&gt;b_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ge
l_int|5
op_star
id|NR_HD
op_logical_or
id|block
op_plus
l_int|2
OG
id|hd
(braket
id|dev
)braket
dot
id|nr_sects
)paren
r_return
suffix:semicolon
id|block
op_add_assign
id|hd
(braket
id|dev
)braket
dot
id|start_sect
suffix:semicolon
id|dev
op_div_assign
l_int|5
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;divl %4&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|block
)paren
comma
l_string|&quot;=d&quot;
(paren
id|sec
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|block
)paren
comma
l_string|&quot;1&quot;
(paren
l_int|0
)paren
comma
l_string|&quot;r&quot;
(paren
id|hd_info
(braket
id|dev
)braket
dot
id|sect
)paren
)paren
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;divl %4&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|cyl
)paren
comma
l_string|&quot;=d&quot;
(paren
id|head
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|block
)paren
comma
l_string|&quot;1&quot;
(paren
l_int|0
)paren
comma
l_string|&quot;r&quot;
(paren
id|hd_info
(braket
id|dev
)braket
dot
id|head
)paren
)paren
suffix:semicolon
id|rw_abs_hd
c_func
(paren
id|rw
comma
id|dev
comma
id|sec
op_plus
l_int|1
comma
id|head
comma
id|cyl
comma
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/* This may be used only once, enforced by &squot;static int callable&squot; */
DECL|function|sys_setup
r_int
id|sys_setup
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|callable
op_assign
l_int|1
suffix:semicolon
r_int
id|i
comma
id|drive
suffix:semicolon
r_struct
id|partition
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|callable
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|callable
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|NR_HD
suffix:semicolon
id|drive
op_increment
)paren
(brace
id|rw_abs_hd
c_func
(paren
id|READ
comma
id|drive
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
(paren
r_struct
id|buffer_head
op_star
)paren
id|start_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|start_buffer-&gt;b_uptodate
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to read partition table of drive %d&bslash;n&bslash;r&quot;
comma
id|drive
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start_buffer-&gt;b_data
(braket
l_int|510
)braket
op_ne
l_int|0x55
op_logical_or
(paren
r_int
r_char
)paren
id|start_buffer-&gt;b_data
(braket
l_int|511
)braket
op_ne
l_int|0xAA
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bad partition table on drive %d&bslash;n&bslash;r&quot;
comma
id|drive
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
id|p
op_assign
l_int|0x1BE
op_plus
(paren
r_void
op_star
)paren
id|start_buffer-&gt;b_data
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
comma
id|p
op_increment
)paren
(brace
id|hd
(braket
id|i
op_plus
l_int|5
op_star
id|drive
)braket
dot
id|start_sect
op_assign
id|p-&gt;start_sect
suffix:semicolon
id|hd
(braket
id|i
op_plus
l_int|5
op_star
id|drive
)braket
dot
id|nr_sects
op_assign
id|p-&gt;nr_sects
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;Partition table%s ok.&bslash;n&bslash;r&quot;
comma
(paren
id|NR_HD
OG
l_int|1
)paren
ques
c_cond
l_string|&quot;s&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|mount_root
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the pointer to a routine to be executed at every hd-interrupt.&n; * Interesting way of doing things, but should be rather practical.&n; */
DECL|variable|do_hd
r_void
(paren
op_star
id|do_hd
)paren
(paren
r_void
)paren
op_assign
l_int|NULL
suffix:semicolon
DECL|function|controller_ready
r_static
r_int
id|controller_ready
c_func
(paren
r_void
)paren
(brace
r_int
id|retries
op_assign
l_int|1000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|retries
op_logical_and
(paren
id|inb
c_func
(paren
id|HD_STATUS
)paren
op_amp
l_int|0xc0
)paren
op_ne
l_int|0x40
)paren
suffix:semicolon
r_return
(paren
id|retries
)paren
suffix:semicolon
)brace
DECL|function|win_result
r_static
r_int
id|win_result
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
id|inb
c_func
(paren
id|HD_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_amp
(paren
id|BUSY_STAT
op_or
id|READY_STAT
op_or
id|WRERR_STAT
op_or
id|SEEK_STAT
op_or
id|ERR_STAT
)paren
)paren
op_eq
(paren
id|READY_STAT
op_or
id|SEEK_STAT
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* ok */
r_if
c_cond
(paren
id|i
op_amp
l_int|1
)paren
id|i
op_assign
id|inb
c_func
(paren
id|HD_ERROR
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|hd_out
r_static
r_void
id|hd_out
c_func
(paren
r_int
r_int
id|drive
comma
r_int
r_int
id|nsect
comma
r_int
r_int
id|sect
comma
r_int
r_int
id|head
comma
r_int
r_int
id|cyl
comma
r_int
r_int
id|cmd
comma
r_void
(paren
op_star
id|intr_addr
)paren
(paren
r_void
)paren
)paren
(brace
r_register
r_int
id|port
id|asm
c_func
(paren
l_string|&quot;dx&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
OG
l_int|1
op_logical_or
id|head
OG
l_int|15
)paren
id|panic
c_func
(paren
l_string|&quot;Trying to write bad sector&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|controller_ready
c_func
(paren
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;HD controller not ready&quot;
)paren
suffix:semicolon
id|do_hd
op_assign
id|intr_addr
suffix:semicolon
id|outb
c_func
(paren
id|_CTL
comma
id|HD_CMD
)paren
suffix:semicolon
id|port
op_assign
id|HD_DATA
suffix:semicolon
id|outb_p
c_func
(paren
id|_WPCOM
comma
op_increment
id|port
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|nsect
comma
op_increment
id|port
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|sect
comma
op_increment
id|port
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|cyl
comma
op_increment
id|port
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|cyl
op_rshift
l_int|8
comma
op_increment
id|port
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0xA0
op_or
(paren
id|drive
op_lshift
l_int|4
)paren
op_or
id|head
comma
op_increment
id|port
)paren
suffix:semicolon
id|outb
c_func
(paren
id|cmd
comma
op_increment
id|port
)paren
suffix:semicolon
)brace
DECL|function|drive_busy
r_static
r_int
id|drive_busy
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100000
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|READY_STAT
op_eq
(paren
id|inb
c_func
(paren
id|HD_STATUS
)paren
op_amp
(paren
id|BUSY_STAT
op_or
id|READY_STAT
)paren
)paren
)paren
r_break
suffix:semicolon
id|i
op_assign
id|inb
c_func
(paren
id|HD_STATUS
)paren
suffix:semicolon
id|i
op_and_assign
id|BUSY_STAT
op_or
id|READY_STAT
op_or
id|SEEK_STAT
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|READY_STAT
op_or
id|SEEK_STAT
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HD controller times out&bslash;n&bslash;r&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|reset_controller
r_static
r_void
id|reset_controller
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|outb
c_func
(paren
l_int|4
comma
id|HD_CMD
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1000
suffix:semicolon
id|i
op_increment
)paren
(brace
id|nop
c_func
(paren
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0
comma
id|HD_CMD
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10000
op_logical_and
id|drive_busy
c_func
(paren
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* nothing */
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drive_busy
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;HD-controller still busy&bslash;n&bslash;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|inb
c_func
(paren
id|ERR_STAT
)paren
)paren
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;HD-controller reset failed: %02x&bslash;n&bslash;r&quot;
comma
id|i
)paren
suffix:semicolon
)brace
)brace
DECL|function|reset_hd
r_static
r_void
id|reset_hd
c_func
(paren
r_int
id|nr
)paren
(brace
id|reset_controller
c_func
(paren
)paren
suffix:semicolon
id|hd_out
c_func
(paren
id|nr
comma
id|_SECT
comma
id|_SECT
comma
id|_HEAD
op_minus
l_int|1
comma
id|_CYL
comma
id|WIN_SPECIFY
comma
op_amp
id|do_request
)paren
suffix:semicolon
)brace
DECL|function|unexpected_hd_interrupt
r_void
id|unexpected_hd_interrupt
c_func
(paren
r_void
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Unexpected HD interrupt&bslash;n&bslash;r&quot;
)paren
suffix:semicolon
)brace
DECL|function|bad_rw_intr
r_static
r_void
id|bad_rw_intr
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
id|this_request-&gt;hd
suffix:semicolon
r_if
c_cond
(paren
id|this_request-&gt;errors
op_increment
op_ge
id|MAX_ERRORS
)paren
(brace
id|this_request-&gt;bh-&gt;b_uptodate
op_assign
l_int|0
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|this_request-&gt;bh
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|wait_for_request
)paren
suffix:semicolon
id|this_request-&gt;hd
op_assign
op_minus
l_int|1
suffix:semicolon
id|this_request
op_assign
id|this_request-&gt;next
suffix:semicolon
)brace
id|reset_hd
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
DECL|function|read_intr
r_static
r_void
id|read_intr
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|win_result
c_func
(paren
)paren
)paren
(brace
id|bad_rw_intr
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|port_read
c_func
(paren
id|HD_DATA
comma
id|this_request-&gt;bh-&gt;b_data
op_plus
l_int|512
op_star
(paren
id|this_request-&gt;nsector
op_amp
l_int|1
)paren
comma
l_int|256
)paren
suffix:semicolon
id|this_request-&gt;errors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|this_request-&gt;nsector
)paren
r_return
suffix:semicolon
id|this_request-&gt;bh-&gt;b_uptodate
op_assign
l_int|1
suffix:semicolon
id|this_request-&gt;bh-&gt;b_dirt
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|wait_for_request
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|this_request-&gt;bh
)paren
suffix:semicolon
id|this_request-&gt;hd
op_assign
op_minus
l_int|1
suffix:semicolon
id|this_request
op_assign
id|this_request-&gt;next
suffix:semicolon
id|do_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|write_intr
r_static
r_void
id|write_intr
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|win_result
c_func
(paren
)paren
)paren
(brace
id|bad_rw_intr
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|this_request-&gt;nsector
)paren
(brace
id|port_write
c_func
(paren
id|HD_DATA
comma
id|this_request-&gt;bh-&gt;b_data
op_plus
l_int|512
comma
l_int|256
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|this_request-&gt;bh-&gt;b_uptodate
op_assign
l_int|1
suffix:semicolon
id|this_request-&gt;bh-&gt;b_dirt
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|wait_for_request
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|this_request-&gt;bh
)paren
suffix:semicolon
id|this_request-&gt;hd
op_assign
op_minus
l_int|1
suffix:semicolon
id|this_request
op_assign
id|this_request-&gt;next
suffix:semicolon
id|do_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|do_request
r_static
r_void
id|do_request
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|r
suffix:semicolon
r_if
c_cond
(paren
id|sorting
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this_request
)paren
(brace
id|do_hd
op_assign
l_int|NULL
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|this_request-&gt;cmd
op_eq
id|WIN_WRITE
)paren
(brace
id|hd_out
c_func
(paren
id|this_request-&gt;hd
comma
id|this_request-&gt;nsector
comma
id|this_request
op_member_access_from_pointer
id|sector
comma
id|this_request-&gt;head
comma
id|this_request-&gt;cyl
comma
id|this_request-&gt;cmd
comma
op_amp
id|write_intr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3000
op_logical_and
op_logical_neg
(paren
id|r
op_assign
id|inb_p
c_func
(paren
id|HD_STATUS
)paren
op_amp
id|DRQ_STAT
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* nothing */
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
(brace
id|reset_hd
c_func
(paren
id|this_request-&gt;hd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|port_write
c_func
(paren
id|HD_DATA
comma
id|this_request-&gt;bh-&gt;b_data
op_plus
l_int|512
op_star
(paren
id|this_request-&gt;nsector
op_amp
l_int|1
)paren
comma
l_int|256
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|this_request-&gt;cmd
op_eq
id|WIN_READ
)paren
(brace
id|hd_out
c_func
(paren
id|this_request-&gt;hd
comma
id|this_request-&gt;nsector
comma
id|this_request
op_member_access_from_pointer
id|sector
comma
id|this_request-&gt;head
comma
id|this_request-&gt;cyl
comma
id|this_request-&gt;cmd
comma
op_amp
id|read_intr
)paren
suffix:semicolon
)brace
r_else
id|panic
c_func
(paren
l_string|&quot;unknown hd-command&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * add-request adds a request to the linked list.&n; * It sets the &squot;sorting&squot;-variable when doing something&n; * that interrupts shouldn&squot;t touch.&n; */
DECL|function|add_request
r_static
r_void
id|add_request
c_func
(paren
r_struct
id|hd_request
op_star
id|req
)paren
(brace
r_struct
id|hd_request
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;nsector
op_ne
l_int|2
)paren
id|panic
c_func
(paren
l_string|&quot;nsector!=2 not implemented&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; * Not to mess up the linked lists, we never touch the two first&n; * entries (not this_request, as it is used by current interrups,&n; * and not this_request-&gt;next, as it can be assigned to this_request).&n; * This is not too high a price to pay for the ability of not&n; * disabling interrupts.&n; */
id|sorting
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp
op_assign
id|this_request
)paren
)paren
id|this_request
op_assign
id|req
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp-&gt;next
)paren
)paren
id|tmp-&gt;next
op_assign
id|req
suffix:semicolon
r_else
(brace
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|tmp-&gt;next
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
r_if
c_cond
(paren
(paren
id|IN_ORDER
c_func
(paren
id|tmp
comma
id|req
)paren
op_logical_or
op_logical_neg
id|IN_ORDER
c_func
(paren
id|tmp
comma
id|tmp-&gt;next
)paren
)paren
op_logical_and
id|IN_ORDER
c_func
(paren
id|req
comma
id|tmp-&gt;next
)paren
)paren
r_break
suffix:semicolon
id|req-&gt;next
op_assign
id|tmp-&gt;next
suffix:semicolon
id|tmp-&gt;next
op_assign
id|req
suffix:semicolon
)brace
)brace
id|sorting
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * NOTE! As a result of sorting, the interrupts may have died down,&n; * as they aren&squot;t redone due to locking with sorting=1. They might&n; * also never have started, if this is the first request in the queue,&n; * so we restart them if necessary.&n; */
r_if
c_cond
(paren
op_logical_neg
id|do_hd
)paren
id|do_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|rw_abs_hd
r_void
id|rw_abs_hd
c_func
(paren
r_int
id|rw
comma
r_int
r_int
id|nr
comma
r_int
r_int
id|sec
comma
r_int
r_int
id|head
comma
r_int
r_int
id|cyl
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|hd_request
op_star
id|req
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_ne
id|READ
op_logical_and
id|rw
op_ne
id|WRITE
)paren
id|panic
c_func
(paren
l_string|&quot;Bad hd command, must be R/W&quot;
)paren
suffix:semicolon
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|repeat
suffix:colon
r_for
c_loop
(paren
id|req
op_assign
l_int|0
op_plus
id|request
suffix:semicolon
id|req
OL
id|NR_REQUEST
op_plus
id|request
suffix:semicolon
id|req
op_increment
)paren
r_if
c_cond
(paren
id|req-&gt;hd
OL
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|req
op_eq
id|NR_REQUEST
op_plus
id|request
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|wait_for_request
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|req-&gt;hd
op_assign
id|nr
suffix:semicolon
id|req-&gt;nsector
op_assign
l_int|2
suffix:semicolon
id|req-&gt;sector
op_assign
id|sec
suffix:semicolon
id|req-&gt;head
op_assign
id|head
suffix:semicolon
id|req-&gt;cyl
op_assign
id|cyl
suffix:semicolon
id|req-&gt;cmd
op_assign
(paren
(paren
id|rw
op_eq
id|READ
)paren
ques
c_cond
id|WIN_READ
suffix:colon
id|WIN_WRITE
)paren
suffix:semicolon
id|req-&gt;bh
op_assign
id|bh
suffix:semicolon
id|req-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|req-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|add_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
DECL|function|hd_init
r_void
id|hd_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_REQUEST
suffix:semicolon
id|i
op_increment
)paren
(brace
id|request
(braket
id|i
)braket
dot
id|hd
op_assign
op_minus
l_int|1
suffix:semicolon
id|request
(braket
id|i
)braket
dot
id|next
op_assign
l_int|NULL
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_HD
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hd
(braket
id|i
op_star
l_int|5
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|hd
(braket
id|i
op_star
l_int|5
)braket
dot
id|nr_sects
op_assign
id|hd_info
(braket
id|i
)braket
dot
id|head
op_star
id|hd_info
(braket
id|i
)braket
dot
id|sect
op_star
id|hd_info
(braket
id|i
)braket
dot
id|cyl
suffix:semicolon
)brace
id|set_trap_gate
c_func
(paren
l_int|0x2E
comma
op_amp
id|hd_interrupt
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|inb_p
c_func
(paren
l_int|0x21
)paren
op_amp
l_int|0xfb
comma
l_int|0x21
)paren
suffix:semicolon
id|outb
c_func
(paren
id|inb_p
c_func
(paren
l_int|0xA1
)paren
op_amp
l_int|0xbf
comma
l_int|0xA1
)paren
suffix:semicolon
)brace
eof
