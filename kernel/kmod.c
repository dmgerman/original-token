multiline_comment|/*&n;&t;kmod, the new module loader (replaces kerneld)&n;&t;Kirk Petersen&n;&n;&t;Reorganized not to be a daemon by Adam Richter, with guidance&n;&t;from Greg Zornetzer.&n;&n;&t;Modified to avoid chroot and file sharing problems.&n;&t;Mikael Pettersson&n;*/
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;asm/smp_lock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/*&n;&t;modprobe_path is set via /proc/sys.&n;*/
DECL|variable|modprobe_path
r_char
id|modprobe_path
(braket
l_int|256
)braket
op_assign
l_string|&quot;/sbin/modprobe&quot;
suffix:semicolon
DECL|variable|envp
r_static
r_char
op_star
id|envp
(braket
)braket
op_assign
(brace
l_string|&quot;HOME=/&quot;
comma
l_string|&quot;TERM=linux&quot;
comma
l_string|&quot;PATH=/usr/bin:/bin&quot;
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n;&t;exec_modprobe is spawned from a kernel-mode user process,&n;&t;then changes its state to behave _as_if_ it was spawned&n;&t;from the kernel&squot;s init process&n;&t;(ppid and {e,}gid are not adjusted, but that shouldn&squot;t&n;&t;be a problem since we trust modprobe)&n;*/
DECL|macro|task_init
mdefine_line|#define task_init task[smp_num_cpus]
r_static
r_inline
r_void
DECL|function|use_init_file_context
id|use_init_file_context
c_func
(paren
r_void
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* don&squot;t use the user&squot;s root, use init&squot;s root instead */
id|exit_fs
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/* current-&gt;fs-&gt;count--; */
id|current-&gt;fs
op_assign
id|task_init-&gt;fs
suffix:semicolon
id|current-&gt;fs-&gt;count
op_increment
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|exec_modprobe
r_static
r_int
id|exec_modprobe
c_func
(paren
r_void
op_star
id|module_name
)paren
(brace
r_char
op_star
id|argv
(braket
)braket
op_assign
(brace
id|modprobe_path
comma
l_string|&quot;-s&quot;
comma
l_string|&quot;-k&quot;
comma
(paren
r_char
op_star
)paren
id|module_name
comma
l_int|NULL
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
id|use_init_file_context
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Prevent parent user process from sending signals to child.&n;&t;   Otherwise, if the modprobe program does not exist, it might&n;&t;   be possible to get a user defined signal handler to execute&n;&t;   as the super user right after the execve fails if you time&n;&t;   the signal just right.&n;&t;*/
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|flush_signals
c_func
(paren
id|current
)paren
suffix:semicolon
id|flush_signal_handlers
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|current-&gt;files-&gt;max_fds
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;files-&gt;fd
(braket
id|i
)braket
)paren
id|close
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* Give kmod all privileges.. */
id|current-&gt;uid
op_assign
id|current-&gt;euid
op_assign
id|current-&gt;fsuid
op_assign
l_int|0
suffix:semicolon
id|cap_set_full
c_func
(paren
id|current-&gt;cap_inheritable
)paren
suffix:semicolon
id|cap_set_full
c_func
(paren
id|current-&gt;cap_effective
)paren
suffix:semicolon
multiline_comment|/* Allow execve args to be in kernel space. */
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
multiline_comment|/* Go, go, go... */
r_if
c_cond
(paren
id|execve
c_func
(paren
id|modprobe_path
comma
id|argv
comma
id|envp
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmod: failed to exec %s -s -k %s, errno = %d&bslash;n&quot;
comma
id|modprobe_path
comma
(paren
r_char
op_star
)paren
id|module_name
comma
id|errno
)paren
suffix:semicolon
r_return
op_minus
id|errno
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;request_module: the function that everyone calls when they need&n;&t;a module.&n;*/
DECL|function|request_module
r_int
id|request_module
c_func
(paren
r_const
r_char
op_star
id|module_name
)paren
(brace
r_int
id|pid
suffix:semicolon
r_int
id|waitpid_result
suffix:semicolon
multiline_comment|/* Don&squot;t allow request_mode() before the root fs is mounted!  */
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;fs-&gt;root
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;request_module[%s]: Root fs not mounted&bslash;n&quot;
comma
id|module_name
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|pid
op_assign
id|kernel_thread
c_func
(paren
id|exec_modprobe
comma
(paren
r_void
op_star
)paren
id|module_name
comma
id|CLONE_FS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pid
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmod: fork failed, errno %d&bslash;n&quot;
comma
op_minus
id|pid
)paren
suffix:semicolon
r_return
id|pid
suffix:semicolon
)brace
id|waitpid_result
op_assign
id|waitpid
c_func
(paren
id|pid
comma
l_int|NULL
comma
id|__WCLONE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitpid_result
op_ne
id|pid
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;kmod: waitpid(%d,NULL,0) failed, returning %d.&bslash;n&quot;
comma
id|pid
comma
id|waitpid_result
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
