multiline_comment|/*&n;&t;kmod, the new module loader (replaces kerneld)&n;&t;Kirk Petersen&n;*/
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
multiline_comment|/*&n;&t;kmod_unload_delay and modprobe_path are set via /proc/sys.&n;*/
DECL|variable|kmod_unload_delay
r_int
id|kmod_unload_delay
op_assign
l_int|60
suffix:semicolon
DECL|variable|modprobe_path
r_char
id|modprobe_path
(braket
l_int|256
)braket
op_assign
l_string|&quot;/sbin/modprobe&quot;
suffix:semicolon
DECL|variable|module_name
r_static
r_char
id|module_name
(braket
l_int|64
)braket
op_assign
l_string|&quot;&quot;
suffix:semicolon
DECL|variable|argv
r_static
r_char
op_star
id|argv
(braket
)braket
op_assign
(brace
id|modprobe_path
comma
l_string|&quot;-s&quot;
comma
l_string|&quot;-k&quot;
comma
id|module_name
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|envp
r_static
r_char
op_star
id|envp
(braket
)braket
op_assign
(brace
l_string|&quot;HOME=/&quot;
comma
l_string|&quot;TERM=linux&quot;
comma
l_string|&quot;PATH=/usr/bin:/bin&quot;
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n;&t;kmod_queue synchronizes the kmod thread and the rest of the system&n;&t;kmod_unload_timer is what we use to unload modules&n;&t;after kmod_unload_delay seconds&n;*/
DECL|variable|kmod_queue
r_static
r_struct
id|wait_queue
op_star
id|kmod_queue
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|kmod_unload_timer
r_static
r_struct
id|timer_list
id|kmod_unload_timer
suffix:semicolon
multiline_comment|/*&n;&t;It is not easy to implement a full fork in kernel-space on some&n;&t;systems (Alpha), and it is not necessary for us here.  This is &n;&t;a new thread that does the exec.&n;*/
DECL|function|kmod_exec_modprobe
r_static
r_int
id|kmod_exec_modprobe
c_func
(paren
r_void
op_star
id|data
)paren
(brace
id|sigemptyset
c_func
(paren
op_amp
id|current-&gt;blocked
)paren
suffix:semicolon
id|execve
c_func
(paren
id|modprobe_path
comma
id|argv
comma
id|envp
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmod: failed to load module %s&bslash;n&quot;
comma
id|module_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;kmod_thread is the thread that does most of the work.  kmod_unload and&n;&t;request_module tell it to wake up and do work.&n;*/
DECL|function|kmod_thread
r_static
r_int
id|kmod_thread
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_int
id|pid
suffix:semicolon
multiline_comment|/*&n;&t;&t;Initialize basic thread information&n;&t;*/
id|current-&gt;session
op_assign
l_int|1
suffix:semicolon
id|current-&gt;pgrp
op_assign
l_int|1
suffix:semicolon
id|sprintf
c_func
(paren
id|current-&gt;comm
comma
l_string|&quot;kmod&quot;
)paren
suffix:semicolon
id|sigfillset
c_func
(paren
op_amp
id|current-&gt;blocked
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;This is the main kmod_thread loop.  It first sleeps, then&n;&t;&t;handles requests from request_module or kmod_unload.&n;&t;*/
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|kmod_queue
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;If request_module woke us up, we should try to&n;&t;&t;&t;load module_name.  If not, kmod_unload woke us up,&n;&t;&t;&t;do call delete_module.&n;&t;&t;&t;(if somehow both want us to do something, ignore the&n;&t;&t;&t; delete_module request)&n;&t;&t;*/
r_if
c_cond
(paren
id|module_name
(braket
l_int|0
)braket
op_eq
l_char|&squot;&bslash;0&squot;
)paren
(brace
id|delete_module
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
id|pid
op_assign
id|kernel_thread
c_func
(paren
id|kmod_exec_modprobe
comma
l_int|NULL
comma
id|SIGCHLD
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pid
OG
l_int|0
)paren
(brace
id|waitpid
c_func
(paren
id|pid
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|module_name
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|kmod_queue
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;kmod: fork failed, errno %d&bslash;n&quot;
comma
op_minus
id|pid
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Never reached. */
)brace
multiline_comment|/*&n;&t;kmod_unload is the function that the kernel calls when&n;&t;the kmod_unload_timer expires&n;*/
DECL|function|kmod_unload
r_void
id|kmod_unload
c_func
(paren
r_int
r_int
id|x
)paren
(brace
multiline_comment|/*&n;&t;&t;wake up the kmod thread, which does the work&n;&t;&t;(we can&squot;t call delete_module, as it locks the kernel and&n;&t;&t; we are in the bottom half of the kernel (right?))&n;&t;&t;once it is awake, reset the timer&n;&t;*/
id|wake_up
c_func
(paren
op_amp
id|kmod_queue
)paren
suffix:semicolon
id|kmod_unload_timer.expires
op_assign
id|jiffies
op_plus
(paren
id|kmod_unload_delay
op_star
id|HZ
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|kmod_unload_timer
)paren
suffix:semicolon
)brace
DECL|function|kmod_init
r_int
id|kmod_init
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Starting kmod&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * CLONE_FS means that our &quot;cwd&quot; will follow that of init.&n;&t; * CLONE_FILES just saves some space (we don&squot;t need any&n;&t; * new file descriptors). Ditto for CLONE_SIGHAND.&n;&t; */
id|kernel_thread
c_func
(paren
id|kmod_thread
comma
l_int|NULL
comma
id|CLONE_FILES
op_or
"&#xfffd;"
id|CLONE_FS
op_or
id|CLONE_SIGHAND
)paren
suffix:semicolon
id|kmod_unload_timer.next
op_assign
l_int|NULL
suffix:semicolon
id|kmod_unload_timer.prev
op_assign
l_int|NULL
suffix:semicolon
id|kmod_unload_timer.expires
op_assign
id|jiffies
op_plus
(paren
l_int|5
op_star
l_int|60
op_star
id|HZ
)paren
suffix:semicolon
id|kmod_unload_timer.data
op_assign
l_int|0L
suffix:semicolon
id|kmod_unload_timer.function
op_assign
id|kmod_unload
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|kmod_unload_timer
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;request_module, the function that everyone calls when they need a&n;&t;module to be loaded&n;*/
DECL|function|request_module
r_int
id|request_module
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
multiline_comment|/* first, copy the name of the module into module_name */
multiline_comment|/* then wake_up() the kmod daemon */
multiline_comment|/* wait for the kmod daemon to finish (it will wake us up) */
multiline_comment|/*&n;&t;&t;kmod_thread is sleeping, so start by copying the name of&n;&t;&t;the module into module_name.  Once that is done, wake up&n;&t;&t;kmod_thread.&n;&t;*/
id|strncpy
c_func
(paren
id|module_name
comma
id|name
comma
r_sizeof
(paren
id|module_name
)paren
)paren
suffix:semicolon
id|module_name
(braket
r_sizeof
(paren
id|module_name
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|kmod_queue
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;Now that we have told kmod_thread what to do, we want to&n;&t;&t;go to sleep and let it do its work.  It will wake us up,&n;&t;&t;at which point we will be done (the module will be loaded).&n;&t;*/
id|interruptible_sleep_on
c_func
(paren
op_amp
id|kmod_queue
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
