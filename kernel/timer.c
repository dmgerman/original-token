multiline_comment|/*&n; *  linux/kernel/timer.c&n; *&n; *  Kernel internal timers, kernel timekeeping, basic process system calls&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; *&n; *  1997-01-28  Modified by Finn Arne Gangstad to make timers scale better.&n; *&n; *  1997-09-10  Updated NTP code according to technical memorandum Jan &squot;96&n; *              &quot;A Kernel Model for Precision Timekeeping&quot; by Dave Mills&n; *  1998-12-24  Fixed a xtime SMP race (we need the xtime_lock rw spinlock to&n; *              serialize accesses to xtime/lost_ticks).&n; *                              Copyright (C) 1998  Andrea Arcangeli&n; *  1999-03-10  Improved NTP compatibility by Ulrich Windl&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/*&n; * Timekeeping variables&n; */
DECL|variable|tick
r_int
id|tick
op_assign
(paren
l_int|1000000
op_plus
id|HZ
op_div
l_int|2
)paren
op_div
id|HZ
suffix:semicolon
multiline_comment|/* timer interrupt period */
multiline_comment|/* The current time */
DECL|variable|xtime
r_volatile
r_struct
id|timeval
id|xtime
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|16
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t completely fail for HZ &gt; 500.  */
DECL|variable|tickadj
r_int
id|tickadj
op_assign
l_int|500
op_div
id|HZ
ques
c_cond
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* microsecs */
DECL|variable|tq_timer
id|DECLARE_TASK_QUEUE
c_func
(paren
id|tq_timer
)paren
suffix:semicolon
DECL|variable|tq_immediate
id|DECLARE_TASK_QUEUE
c_func
(paren
id|tq_immediate
)paren
suffix:semicolon
multiline_comment|/*&n; * phase-lock loop variables&n; */
multiline_comment|/* TIME_ERROR prevents overwriting the CMOS clock */
DECL|variable|time_state
r_int
id|time_state
op_assign
id|TIME_OK
suffix:semicolon
multiline_comment|/* clock synchronization status&t;*/
DECL|variable|time_status
r_int
id|time_status
op_assign
id|STA_UNSYNC
suffix:semicolon
multiline_comment|/* clock status bits&t;&t;*/
DECL|variable|time_offset
r_int
id|time_offset
suffix:semicolon
multiline_comment|/* time adjustment (us)&t;&t;*/
DECL|variable|time_constant
r_int
id|time_constant
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* pll time constant&t;&t;*/
DECL|variable|time_tolerance
r_int
id|time_tolerance
op_assign
id|MAXFREQ
suffix:semicolon
multiline_comment|/* frequency tolerance (ppm)&t;*/
DECL|variable|time_precision
r_int
id|time_precision
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* clock precision (us)&t;&t;*/
DECL|variable|time_maxerror
r_int
id|time_maxerror
op_assign
id|NTP_PHASE_LIMIT
suffix:semicolon
multiline_comment|/* maximum error (us)&t;&t;*/
DECL|variable|time_esterror
r_int
id|time_esterror
op_assign
id|NTP_PHASE_LIMIT
suffix:semicolon
multiline_comment|/* estimated error (us)&t;&t;*/
DECL|variable|time_phase
r_int
id|time_phase
suffix:semicolon
multiline_comment|/* phase offset (scaled us)&t;*/
DECL|variable|time_freq
r_int
id|time_freq
op_assign
(paren
(paren
l_int|1000000
op_plus
id|HZ
op_div
l_int|2
)paren
op_mod
id|HZ
op_minus
id|HZ
op_div
l_int|2
)paren
op_lshift
id|SHIFT_USEC
suffix:semicolon
multiline_comment|/* frequency offset (scaled ppm)*/
DECL|variable|time_adj
r_int
id|time_adj
suffix:semicolon
multiline_comment|/* tick adjust (scaled 1 / HZ)&t;*/
DECL|variable|time_reftime
r_int
id|time_reftime
suffix:semicolon
multiline_comment|/* time at last adjustment (s)&t;*/
DECL|variable|time_adjust
r_int
id|time_adjust
suffix:semicolon
DECL|variable|time_adjust_step
r_int
id|time_adjust_step
suffix:semicolon
DECL|variable|event
r_int
r_int
id|event
suffix:semicolon
r_extern
r_int
id|do_setitimer
c_func
(paren
r_int
comma
r_struct
id|itimerval
op_star
comma
r_struct
id|itimerval
op_star
)paren
suffix:semicolon
DECL|variable|jiffies
r_int
r_int
r_volatile
id|jiffies
suffix:semicolon
DECL|variable|prof_buffer
r_int
r_int
op_star
id|prof_buffer
suffix:semicolon
DECL|variable|prof_len
r_int
r_int
id|prof_len
suffix:semicolon
DECL|variable|prof_shift
r_int
r_int
id|prof_shift
suffix:semicolon
multiline_comment|/*&n; * Event timer code&n; */
DECL|macro|TVN_BITS
mdefine_line|#define TVN_BITS 6
DECL|macro|TVR_BITS
mdefine_line|#define TVR_BITS 8
DECL|macro|TVN_SIZE
mdefine_line|#define TVN_SIZE (1 &lt;&lt; TVN_BITS)
DECL|macro|TVR_SIZE
mdefine_line|#define TVR_SIZE (1 &lt;&lt; TVR_BITS)
DECL|macro|TVN_MASK
mdefine_line|#define TVN_MASK (TVN_SIZE - 1)
DECL|macro|TVR_MASK
mdefine_line|#define TVR_MASK (TVR_SIZE - 1)
DECL|struct|timer_vec
r_struct
id|timer_vec
(brace
DECL|member|index
r_int
id|index
suffix:semicolon
DECL|member|vec
r_struct
id|list_head
id|vec
(braket
id|TVN_SIZE
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|timer_vec_root
r_struct
id|timer_vec_root
(brace
DECL|member|index
r_int
id|index
suffix:semicolon
DECL|member|vec
r_struct
id|list_head
id|vec
(braket
id|TVR_SIZE
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|tv5
r_static
r_struct
id|timer_vec
id|tv5
suffix:semicolon
DECL|variable|tv4
r_static
r_struct
id|timer_vec
id|tv4
suffix:semicolon
DECL|variable|tv3
r_static
r_struct
id|timer_vec
id|tv3
suffix:semicolon
DECL|variable|tv2
r_static
r_struct
id|timer_vec
id|tv2
suffix:semicolon
DECL|variable|tv1
r_static
r_struct
id|timer_vec_root
id|tv1
suffix:semicolon
DECL|variable|tvecs
r_static
r_struct
id|timer_vec
op_star
r_const
id|tvecs
(braket
)braket
op_assign
(brace
(paren
r_struct
id|timer_vec
op_star
)paren
op_amp
id|tv1
comma
op_amp
id|tv2
comma
op_amp
id|tv3
comma
op_amp
id|tv4
comma
op_amp
id|tv5
)brace
suffix:semicolon
DECL|macro|NOOF_TVECS
mdefine_line|#define NOOF_TVECS (sizeof(tvecs) / sizeof(tvecs[0]))
DECL|function|init_timervecs
r_void
id|init_timervecs
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TVN_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
id|tv5.vec
op_plus
id|i
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
id|tv4.vec
op_plus
id|i
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
id|tv3.vec
op_plus
id|i
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
id|tv2.vec
op_plus
id|i
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TVR_SIZE
suffix:semicolon
id|i
op_increment
)paren
id|INIT_LIST_HEAD
c_func
(paren
id|tv1.vec
op_plus
id|i
)paren
suffix:semicolon
)brace
DECL|variable|timer_jiffies
r_static
r_int
r_int
id|timer_jiffies
suffix:semicolon
DECL|function|internal_add_timer
r_static
r_inline
r_void
id|internal_add_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
multiline_comment|/*&n;&t; * must be cli-ed when calling this&n;&t; */
r_int
r_int
id|expires
op_assign
id|timer-&gt;expires
suffix:semicolon
r_int
r_int
id|idx
op_assign
id|expires
op_minus
id|timer_jiffies
suffix:semicolon
r_struct
id|list_head
op_star
id|vec
suffix:semicolon
r_if
c_cond
(paren
id|idx
OL
id|TVR_SIZE
)paren
(brace
r_int
id|i
op_assign
id|expires
op_amp
id|TVR_MASK
suffix:semicolon
id|vec
op_assign
id|tv1.vec
op_plus
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|idx
OL
l_int|1
op_lshift
(paren
id|TVR_BITS
op_plus
id|TVN_BITS
)paren
)paren
(brace
r_int
id|i
op_assign
(paren
id|expires
op_rshift
id|TVR_BITS
)paren
op_amp
id|TVN_MASK
suffix:semicolon
id|vec
op_assign
id|tv2.vec
op_plus
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|idx
OL
l_int|1
op_lshift
(paren
id|TVR_BITS
op_plus
l_int|2
op_star
id|TVN_BITS
)paren
)paren
(brace
r_int
id|i
op_assign
(paren
id|expires
op_rshift
(paren
id|TVR_BITS
op_plus
id|TVN_BITS
)paren
)paren
op_amp
id|TVN_MASK
suffix:semicolon
id|vec
op_assign
id|tv3.vec
op_plus
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|idx
OL
l_int|1
op_lshift
(paren
id|TVR_BITS
op_plus
l_int|3
op_star
id|TVN_BITS
)paren
)paren
(brace
r_int
id|i
op_assign
(paren
id|expires
op_rshift
(paren
id|TVR_BITS
op_plus
l_int|2
op_star
id|TVN_BITS
)paren
)paren
op_amp
id|TVN_MASK
suffix:semicolon
id|vec
op_assign
id|tv4.vec
op_plus
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|idx
OL
l_int|0
)paren
(brace
multiline_comment|/* can happen if you add a timer with expires == jiffies,&n;&t;&t; * or you set a timer to go off in the past&n;&t;&t; */
id|vec
op_assign
id|tv1.vec
op_plus
id|tv1.index
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|idx
op_le
l_int|0xffffffffUL
)paren
(brace
r_int
id|i
op_assign
(paren
id|expires
op_rshift
(paren
id|TVR_BITS
op_plus
l_int|3
op_star
id|TVN_BITS
)paren
)paren
op_amp
id|TVN_MASK
suffix:semicolon
id|vec
op_assign
id|tv5.vec
op_plus
id|i
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Can only get here on architectures with 64-bit jiffies */
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|timer-&gt;list
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Timers are FIFO!&n;&t; */
id|list_add
c_func
(paren
op_amp
id|timer-&gt;list
comma
id|vec-&gt;prev
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize both explicitly - let&squot;s try to have them in the same cache line */
DECL|variable|timerlist_lock
id|spinlock_t
id|timerlist_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
DECL|variable|running_timer
r_volatile
r_struct
id|timer_list
op_star
r_volatile
id|running_timer
suffix:semicolon
DECL|macro|timer_enter
mdefine_line|#define timer_enter(t) do { running_timer = t; mb(); } while (0)
DECL|macro|timer_exit
mdefine_line|#define timer_exit() do { running_timer = NULL; } while (0)
DECL|macro|timer_is_running
mdefine_line|#define timer_is_running(t) (running_timer == t)
DECL|macro|timer_synchronize
mdefine_line|#define timer_synchronize(t) while (timer_is_running(t)) barrier()
macro_line|#else
DECL|macro|timer_enter
mdefine_line|#define timer_enter(t)&t;&t;do { } while (0)
DECL|macro|timer_exit
mdefine_line|#define timer_exit()&t;&t;do { } while (0)
macro_line|#endif
DECL|function|add_timer
r_void
id|add_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|timerlist_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
id|timer
)paren
)paren
r_goto
id|bug
suffix:semicolon
id|internal_add_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|timerlist_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
id|bug
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|timerlist_lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bug: kernel timer added twice at %p.&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
DECL|function|detach_timer
r_static
r_inline
r_int
id|detach_timer
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|timer_pending
c_func
(paren
id|timer
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|timer-&gt;list
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|mod_timer
r_int
id|mod_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
comma
r_int
r_int
id|expires
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|timerlist_lock
comma
id|flags
)paren
suffix:semicolon
id|timer-&gt;expires
op_assign
id|expires
suffix:semicolon
id|ret
op_assign
id|detach_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|internal_add_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|timerlist_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|del_timer
r_int
id|del_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|timerlist_lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|detach_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|timer-&gt;list.next
op_assign
id|timer-&gt;list.prev
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|timerlist_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
DECL|function|sync_timers
r_void
id|sync_timers
c_func
(paren
r_void
)paren
(brace
id|spin_unlock_wait
c_func
(paren
op_amp
id|global_bh_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * SMP specific function to delete periodic timer.&n; * Caller must disable by some means restarting the timer&n; * for new. Upon exit the timer is not queued and handler is not running&n; * on any CPU. It returns number of times, which timer was deleted&n; * (for reference counting).&n; */
DECL|function|del_timer_sync
r_int
id|del_timer_sync
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|running
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|timerlist_lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_add_assign
id|detach_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|timer-&gt;list.next
op_assign
id|timer-&gt;list.prev
op_assign
l_int|0
suffix:semicolon
id|running
op_assign
id|timer_is_running
c_func
(paren
id|timer
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|timerlist_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|running
)paren
r_break
suffix:semicolon
id|timer_synchronize
c_func
(paren
id|timer
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#endif
DECL|function|cascade_timers
r_static
r_inline
r_void
id|cascade_timers
c_func
(paren
r_struct
id|timer_vec
op_star
id|tv
)paren
(brace
multiline_comment|/* cascade all the timers from tv up one level */
r_struct
id|list_head
op_star
id|head
comma
op_star
id|curr
comma
op_star
id|next
suffix:semicolon
id|head
op_assign
id|tv-&gt;vec
op_plus
id|tv-&gt;index
suffix:semicolon
id|curr
op_assign
id|head-&gt;next
suffix:semicolon
multiline_comment|/*&n;&t; * We are removing _all_ timers from the list, so we don&squot;t  have to&n;&t; * detach them individually, just clear the list afterwards.&n;&t; */
r_while
c_loop
(paren
id|curr
op_ne
id|head
)paren
(brace
r_struct
id|timer_list
op_star
id|tmp
suffix:semicolon
id|tmp
op_assign
id|list_entry
c_func
(paren
id|curr
comma
r_struct
id|timer_list
comma
id|list
)paren
suffix:semicolon
id|next
op_assign
id|curr-&gt;next
suffix:semicolon
id|list_del
c_func
(paren
id|curr
)paren
suffix:semicolon
singleline_comment|// not needed
id|internal_add_timer
c_func
(paren
id|tmp
)paren
suffix:semicolon
id|curr
op_assign
id|next
suffix:semicolon
)brace
id|INIT_LIST_HEAD
c_func
(paren
id|head
)paren
suffix:semicolon
id|tv-&gt;index
op_assign
(paren
id|tv-&gt;index
op_plus
l_int|1
)paren
op_amp
id|TVN_MASK
suffix:semicolon
)brace
DECL|function|run_timer_list
r_static
r_inline
r_void
id|run_timer_list
c_func
(paren
r_void
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|timerlist_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
r_int
)paren
(paren
id|jiffies
op_minus
id|timer_jiffies
)paren
op_ge
l_int|0
)paren
(brace
r_struct
id|list_head
op_star
id|head
comma
op_star
id|curr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tv1.index
)paren
(brace
r_int
id|n
op_assign
l_int|1
suffix:semicolon
r_do
(brace
id|cascade_timers
c_func
(paren
id|tvecs
(braket
id|n
)braket
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tvecs
(braket
id|n
)braket
op_member_access_from_pointer
id|index
op_eq
l_int|1
op_logical_and
op_increment
id|n
OL
id|NOOF_TVECS
)paren
suffix:semicolon
)brace
id|repeat
suffix:colon
id|head
op_assign
id|tv1.vec
op_plus
id|tv1.index
suffix:semicolon
id|curr
op_assign
id|head-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|curr
op_ne
id|head
)paren
(brace
r_struct
id|timer_list
op_star
id|timer
suffix:semicolon
r_void
(paren
op_star
id|fn
)paren
(paren
r_int
r_int
)paren
suffix:semicolon
r_int
r_int
id|data
suffix:semicolon
id|timer
op_assign
id|list_entry
c_func
(paren
id|curr
comma
r_struct
id|timer_list
comma
id|list
)paren
suffix:semicolon
id|fn
op_assign
id|timer-&gt;function
suffix:semicolon
id|data
op_assign
id|timer-&gt;data
suffix:semicolon
id|detach_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|timer-&gt;list.next
op_assign
id|timer-&gt;list.prev
op_assign
l_int|NULL
suffix:semicolon
id|timer_enter
c_func
(paren
id|timer
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|timerlist_lock
)paren
suffix:semicolon
id|fn
c_func
(paren
id|data
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|timerlist_lock
)paren
suffix:semicolon
id|timer_exit
c_func
(paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
op_increment
id|timer_jiffies
suffix:semicolon
id|tv1.index
op_assign
(paren
id|tv1.index
op_plus
l_int|1
)paren
op_amp
id|TVR_MASK
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|timerlist_lock
)paren
suffix:semicolon
)brace
DECL|variable|tqueue_lock
id|spinlock_t
id|tqueue_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|tqueue_bh
r_void
id|tqueue_bh
c_func
(paren
r_void
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_timer
)paren
suffix:semicolon
)brace
DECL|function|immediate_bh
r_void
id|immediate_bh
c_func
(paren
r_void
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_immediate
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * this routine handles the overflow of the microsecond field&n; *&n; * The tricky bits of code to handle the accurate clock support&n; * were provided by Dave Mills (Mills@UDEL.EDU) of NTP fame.&n; * They were originally developed for SUN and DEC kernels.&n; * All the kudos should go to Dave for this stuff.&n; *&n; */
DECL|function|second_overflow
r_static
r_void
id|second_overflow
c_func
(paren
r_void
)paren
(brace
r_int
id|ltemp
suffix:semicolon
multiline_comment|/* Bump the maxerror field */
id|time_maxerror
op_add_assign
id|time_tolerance
op_rshift
id|SHIFT_USEC
suffix:semicolon
r_if
c_cond
(paren
id|time_maxerror
OG
id|NTP_PHASE_LIMIT
)paren
(brace
id|time_maxerror
op_assign
id|NTP_PHASE_LIMIT
suffix:semicolon
id|time_status
op_or_assign
id|STA_UNSYNC
suffix:semicolon
)brace
multiline_comment|/*&n;     * Leap second processing. If in leap-insert state at&n;     * the end of the day, the system clock is set back one&n;     * second; if in leap-delete state, the system clock is&n;     * set ahead one second. The microtime() routine or&n;     * external clock driver will insure that reported time&n;     * is always monotonic. The ugly divides should be&n;     * replaced.&n;     */
r_switch
c_cond
(paren
id|time_state
)paren
(brace
r_case
id|TIME_OK
suffix:colon
r_if
c_cond
(paren
id|time_status
op_amp
id|STA_INS
)paren
id|time_state
op_assign
id|TIME_INS
suffix:semicolon
r_else
r_if
c_cond
(paren
id|time_status
op_amp
id|STA_DEL
)paren
id|time_state
op_assign
id|TIME_DEL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_INS
suffix:colon
r_if
c_cond
(paren
id|xtime.tv_sec
op_mod
l_int|86400
op_eq
l_int|0
)paren
(brace
id|xtime.tv_sec
op_decrement
suffix:semicolon
id|time_state
op_assign
id|TIME_OOP
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Clock: inserting leap second 23:59:60 UTC&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIME_DEL
suffix:colon
r_if
c_cond
(paren
(paren
id|xtime.tv_sec
op_plus
l_int|1
)paren
op_mod
l_int|86400
op_eq
l_int|0
)paren
(brace
id|xtime.tv_sec
op_increment
suffix:semicolon
id|time_state
op_assign
id|TIME_WAIT
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Clock: deleting leap second 23:59:59 UTC&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIME_OOP
suffix:colon
id|time_state
op_assign
id|TIME_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_WAIT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|time_status
op_amp
(paren
id|STA_INS
op_or
id|STA_DEL
)paren
)paren
)paren
id|time_state
op_assign
id|TIME_OK
suffix:semicolon
)brace
multiline_comment|/*&n;     * Compute the phase adjustment for the next second. In&n;     * PLL mode, the offset is reduced by a fixed factor&n;     * times the time constant. In FLL mode the offset is&n;     * used directly. In either mode, the maximum phase&n;     * adjustment for each second is clamped so as to spread&n;     * the adjustment over not more than the number of&n;     * seconds between updates.&n;     */
r_if
c_cond
(paren
id|time_offset
OL
l_int|0
)paren
(brace
id|ltemp
op_assign
op_minus
id|time_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|time_status
op_amp
id|STA_FLL
)paren
)paren
id|ltemp
op_rshift_assign
id|SHIFT_KG
op_plus
id|time_constant
suffix:semicolon
r_if
c_cond
(paren
id|ltemp
OG
(paren
id|MAXPHASE
op_div
id|MINSEC
)paren
op_lshift
id|SHIFT_UPDATE
)paren
id|ltemp
op_assign
(paren
id|MAXPHASE
op_div
id|MINSEC
)paren
op_lshift
id|SHIFT_UPDATE
suffix:semicolon
id|time_offset
op_add_assign
id|ltemp
suffix:semicolon
id|time_adj
op_assign
op_minus
id|ltemp
op_lshift
(paren
id|SHIFT_SCALE
op_minus
id|SHIFT_HZ
op_minus
id|SHIFT_UPDATE
)paren
suffix:semicolon
)brace
r_else
(brace
id|ltemp
op_assign
id|time_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|time_status
op_amp
id|STA_FLL
)paren
)paren
id|ltemp
op_rshift_assign
id|SHIFT_KG
op_plus
id|time_constant
suffix:semicolon
r_if
c_cond
(paren
id|ltemp
OG
(paren
id|MAXPHASE
op_div
id|MINSEC
)paren
op_lshift
id|SHIFT_UPDATE
)paren
id|ltemp
op_assign
(paren
id|MAXPHASE
op_div
id|MINSEC
)paren
op_lshift
id|SHIFT_UPDATE
suffix:semicolon
id|time_offset
op_sub_assign
id|ltemp
suffix:semicolon
id|time_adj
op_assign
id|ltemp
op_lshift
(paren
id|SHIFT_SCALE
op_minus
id|SHIFT_HZ
op_minus
id|SHIFT_UPDATE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Compute the frequency estimate and additional phase&n;     * adjustment due to frequency error for the next&n;     * second. When the PPS signal is engaged, gnaw on the&n;     * watchdog counter and update the frequency computed by&n;     * the pll and the PPS signal.&n;     */
id|pps_valid
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pps_valid
op_eq
id|PPS_VALID
)paren
(brace
multiline_comment|/* PPS signal lost */
id|pps_jitter
op_assign
id|MAXTIME
suffix:semicolon
id|pps_stabil
op_assign
id|MAXFREQ
suffix:semicolon
id|time_status
op_and_assign
op_complement
(paren
id|STA_PPSSIGNAL
op_or
id|STA_PPSJITTER
op_or
id|STA_PPSWANDER
op_or
id|STA_PPSERROR
)paren
suffix:semicolon
)brace
id|ltemp
op_assign
id|time_freq
op_plus
id|pps_freq
suffix:semicolon
r_if
c_cond
(paren
id|ltemp
OL
l_int|0
)paren
id|time_adj
op_sub_assign
op_minus
id|ltemp
op_rshift
(paren
id|SHIFT_USEC
op_plus
id|SHIFT_HZ
op_minus
id|SHIFT_SCALE
)paren
suffix:semicolon
r_else
id|time_adj
op_add_assign
id|ltemp
op_rshift
(paren
id|SHIFT_USEC
op_plus
id|SHIFT_HZ
op_minus
id|SHIFT_SCALE
)paren
suffix:semicolon
macro_line|#if HZ == 100
multiline_comment|/* Compensate for (HZ==100) != (1 &lt;&lt; SHIFT_HZ).&n;     * Add 25% and 3.125% to get 128.125; =&gt; only 0.125% error (p. 14)&n;     */
r_if
c_cond
(paren
id|time_adj
OL
l_int|0
)paren
id|time_adj
op_sub_assign
(paren
op_minus
id|time_adj
op_rshift
l_int|2
)paren
op_plus
(paren
op_minus
id|time_adj
op_rshift
l_int|5
)paren
suffix:semicolon
r_else
id|time_adj
op_add_assign
(paren
id|time_adj
op_rshift
l_int|2
)paren
op_plus
(paren
id|time_adj
op_rshift
l_int|5
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* in the NTP reference this is called &quot;hardclock()&quot; */
DECL|function|update_wall_time_one_tick
r_static
r_void
id|update_wall_time_one_tick
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
(paren
id|time_adjust_step
op_assign
id|time_adjust
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* We are doing an adjtime thing. &n;&t;     *&n;&t;     * Prepare time_adjust_step to be within bounds.&n;&t;     * Note that a positive time_adjust means we want the clock&n;&t;     * to run faster.&n;&t;     *&n;&t;     * Limit the amount of the step to be in the range&n;&t;     * -tickadj .. +tickadj&n;&t;     */
r_if
c_cond
(paren
id|time_adjust
OG
id|tickadj
)paren
id|time_adjust_step
op_assign
id|tickadj
suffix:semicolon
r_else
r_if
c_cond
(paren
id|time_adjust
OL
op_minus
id|tickadj
)paren
id|time_adjust_step
op_assign
op_minus
id|tickadj
suffix:semicolon
multiline_comment|/* Reduce by this step the amount of time left  */
id|time_adjust
op_sub_assign
id|time_adjust_step
suffix:semicolon
)brace
id|xtime.tv_usec
op_add_assign
id|tick
op_plus
id|time_adjust_step
suffix:semicolon
multiline_comment|/*&n;&t; * Advance the phase, once it gets to one microsecond, then&n;&t; * advance the tick more.&n;&t; */
id|time_phase
op_add_assign
id|time_adj
suffix:semicolon
r_if
c_cond
(paren
id|time_phase
op_le
op_minus
id|FINEUSEC
)paren
(brace
r_int
id|ltemp
op_assign
op_minus
id|time_phase
op_rshift
id|SHIFT_SCALE
suffix:semicolon
id|time_phase
op_add_assign
id|ltemp
op_lshift
id|SHIFT_SCALE
suffix:semicolon
id|xtime.tv_usec
op_sub_assign
id|ltemp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|time_phase
op_ge
id|FINEUSEC
)paren
(brace
r_int
id|ltemp
op_assign
id|time_phase
op_rshift
id|SHIFT_SCALE
suffix:semicolon
id|time_phase
op_sub_assign
id|ltemp
op_lshift
id|SHIFT_SCALE
suffix:semicolon
id|xtime.tv_usec
op_add_assign
id|ltemp
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Using a loop looks inefficient, but &quot;ticks&quot; is&n; * usually just one (we shouldn&squot;t be losing ticks,&n; * we&squot;re doing this this way mainly for interrupt&n; * latency reasons, not because we think we&squot;ll&n; * have lots of lost timer ticks&n; */
DECL|function|update_wall_time
r_static
r_void
id|update_wall_time
c_func
(paren
r_int
r_int
id|ticks
)paren
(brace
r_do
(brace
id|ticks
op_decrement
suffix:semicolon
id|update_wall_time_one_tick
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ticks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xtime.tv_usec
op_ge
l_int|1000000
)paren
(brace
id|xtime.tv_usec
op_sub_assign
l_int|1000000
suffix:semicolon
id|xtime.tv_sec
op_increment
suffix:semicolon
id|second_overflow
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|do_process_times
r_static
r_inline
r_void
id|do_process_times
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
r_int
id|user
comma
r_int
r_int
id|system
)paren
(brace
r_int
r_int
id|psecs
suffix:semicolon
id|psecs
op_assign
(paren
id|p-&gt;times.tms_utime
op_add_assign
id|user
)paren
suffix:semicolon
id|psecs
op_add_assign
(paren
id|p-&gt;times.tms_stime
op_add_assign
id|system
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psecs
op_div
id|HZ
OG
id|p-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_cur
)paren
(brace
multiline_comment|/* Send SIGXCPU every second.. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|psecs
op_mod
id|HZ
)paren
)paren
id|send_sig
c_func
(paren
id|SIGXCPU
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* and SIGKILL when we go over max.. */
r_if
c_cond
(paren
id|psecs
op_div
id|HZ
OG
id|p-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_max
)paren
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
DECL|function|do_it_virt
r_static
r_inline
r_void
id|do_it_virt
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
r_int
id|ticks
)paren
(brace
r_int
r_int
id|it_virt
op_assign
id|p-&gt;it_virt_value
suffix:semicolon
r_if
c_cond
(paren
id|it_virt
)paren
(brace
id|it_virt
op_sub_assign
id|ticks
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|it_virt
)paren
(brace
id|it_virt
op_assign
id|p-&gt;it_virt_incr
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGVTALRM
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
)brace
id|p-&gt;it_virt_value
op_assign
id|it_virt
suffix:semicolon
)brace
)brace
DECL|function|do_it_prof
r_static
r_inline
r_void
id|do_it_prof
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_int
r_int
id|it_prof
op_assign
id|p-&gt;it_prof_value
suffix:semicolon
r_if
c_cond
(paren
id|it_prof
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|it_prof
op_eq
l_int|0
)paren
(brace
id|it_prof
op_assign
id|p-&gt;it_prof_incr
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGPROF
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
)brace
id|p-&gt;it_prof_value
op_assign
id|it_prof
suffix:semicolon
)brace
)brace
DECL|function|update_one_process
r_void
id|update_one_process
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
r_int
id|user
comma
r_int
r_int
id|system
comma
r_int
id|cpu
)paren
(brace
id|p-&gt;per_cpu_utime
(braket
id|cpu
)braket
op_add_assign
id|user
suffix:semicolon
id|p-&gt;per_cpu_stime
(braket
id|cpu
)braket
op_add_assign
id|system
suffix:semicolon
id|do_process_times
c_func
(paren
id|p
comma
id|user
comma
id|system
)paren
suffix:semicolon
id|do_it_virt
c_func
(paren
id|p
comma
id|user
)paren
suffix:semicolon
id|do_it_prof
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called from the timer interrupt handler to charge one tick to the current &n; * process.  user_tick is 1 if the tick is user time, 0 for system.&n; */
DECL|function|update_process_times
r_void
id|update_process_times
c_func
(paren
r_int
id|user_tick
)paren
(brace
r_struct
id|task_struct
op_star
id|p
op_assign
id|current
suffix:semicolon
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
comma
id|system
op_assign
id|user_tick
op_xor
l_int|1
suffix:semicolon
id|update_one_process
c_func
(paren
id|p
comma
id|user_tick
comma
id|system
comma
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;pid
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|p-&gt;counter
op_le
l_int|0
)paren
(brace
id|p-&gt;counter
op_assign
l_int|0
suffix:semicolon
id|p-&gt;need_resched
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;nice
OG
l_int|0
)paren
id|kstat.per_cpu_nice
(braket
id|cpu
)braket
op_add_assign
id|user_tick
suffix:semicolon
r_else
id|kstat.per_cpu_user
(braket
id|cpu
)braket
op_add_assign
id|user_tick
suffix:semicolon
id|kstat.per_cpu_system
(braket
id|cpu
)braket
op_add_assign
id|system
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|local_bh_count
c_func
(paren
id|cpu
)paren
op_logical_or
id|local_irq_count
c_func
(paren
id|cpu
)paren
OG
l_int|1
)paren
id|kstat.per_cpu_system
(braket
id|cpu
)braket
op_add_assign
id|system
suffix:semicolon
)brace
multiline_comment|/*&n; * Nr of active tasks - counted in fixed-point numbers&n; */
DECL|function|count_active_tasks
r_static
r_int
r_int
id|count_active_tasks
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|nr
op_assign
l_int|0
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
(paren
id|p-&gt;state
op_eq
id|TASK_RUNNING
op_logical_or
(paren
id|p-&gt;state
op_amp
id|TASK_UNINTERRUPTIBLE
)paren
)paren
)paren
id|nr
op_add_assign
id|FIXED_1
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|nr
suffix:semicolon
)brace
multiline_comment|/*&n; * Hmm.. Changed this, as the GNU make sources (load.c) seems to&n; * imply that avenrun[] is the standard name for this kind of thing.&n; * Nothing else seems to be standardized: the fractional size etc&n; * all seem to differ on different machines.&n; */
DECL|variable|avenrun
r_int
r_int
id|avenrun
(braket
l_int|3
)braket
suffix:semicolon
DECL|function|calc_load
r_static
r_inline
r_void
id|calc_load
c_func
(paren
r_int
r_int
id|ticks
)paren
(brace
r_int
r_int
id|active_tasks
suffix:semicolon
multiline_comment|/* fixed-point */
r_static
r_int
id|count
op_assign
id|LOAD_FREQ
suffix:semicolon
id|count
op_sub_assign
id|ticks
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
(brace
id|count
op_add_assign
id|LOAD_FREQ
suffix:semicolon
id|active_tasks
op_assign
id|count_active_tasks
c_func
(paren
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|0
)braket
comma
id|EXP_1
comma
id|active_tasks
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|1
)braket
comma
id|EXP_5
comma
id|active_tasks
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|2
)braket
comma
id|EXP_15
comma
id|active_tasks
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* jiffies at the most recent update of wall time */
DECL|variable|wall_jiffies
r_int
r_int
id|wall_jiffies
suffix:semicolon
multiline_comment|/*&n; * This spinlock protect us from races in SMP while playing with xtime. -arca&n; */
DECL|variable|xtime_lock
id|rwlock_t
id|xtime_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
DECL|function|update_times
r_static
r_inline
r_void
id|update_times
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|ticks
suffix:semicolon
multiline_comment|/*&n;&t; * update_times() is run from the raw timer_bh handler so we&n;&t; * just know that the irqs are locally enabled and so we don&squot;t&n;&t; * need to save/restore the flags of the local CPU here. -arca&n;&t; */
id|write_lock_irq
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
id|ticks
op_assign
id|jiffies
op_minus
id|wall_jiffies
suffix:semicolon
r_if
c_cond
(paren
id|ticks
)paren
(brace
id|wall_jiffies
op_add_assign
id|ticks
suffix:semicolon
id|update_wall_time
c_func
(paren
id|ticks
)paren
suffix:semicolon
)brace
id|write_unlock_irq
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
id|calc_load
c_func
(paren
id|ticks
)paren
suffix:semicolon
)brace
DECL|function|timer_bh
r_void
id|timer_bh
c_func
(paren
r_void
)paren
(brace
id|update_times
c_func
(paren
)paren
suffix:semicolon
id|run_timer_list
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|do_timer
r_void
id|do_timer
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
(paren
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|jiffies
)paren
op_increment
suffix:semicolon
macro_line|#ifndef CONFIG_SMP
multiline_comment|/* SMP process accounting uses the local APIC timer */
id|update_process_times
c_func
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
suffix:semicolon
macro_line|#endif
id|mark_bh
c_func
(paren
id|TIMER_BH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TQ_ACTIVE
c_func
(paren
id|tq_timer
)paren
)paren
id|mark_bh
c_func
(paren
id|TQUEUE_BH
)paren
suffix:semicolon
)brace
macro_line|#if !defined(__alpha__) &amp;&amp; !defined(__ia64__)
multiline_comment|/*&n; * For backwards compatibility?  This can be done in libc so Alpha&n; * and all newer ports shouldn&squot;t need it.&n; */
DECL|function|sys_alarm
id|asmlinkage
r_int
r_int
id|sys_alarm
c_func
(paren
r_int
r_int
id|seconds
)paren
(brace
r_struct
id|itimerval
id|it_new
comma
id|it_old
suffix:semicolon
r_int
r_int
id|oldalarm
suffix:semicolon
id|it_new.it_interval.tv_sec
op_assign
id|it_new.it_interval.tv_usec
op_assign
l_int|0
suffix:semicolon
id|it_new.it_value.tv_sec
op_assign
id|seconds
suffix:semicolon
id|it_new.it_value.tv_usec
op_assign
l_int|0
suffix:semicolon
id|do_setitimer
c_func
(paren
id|ITIMER_REAL
comma
op_amp
id|it_new
comma
op_amp
id|it_old
)paren
suffix:semicolon
id|oldalarm
op_assign
id|it_old.it_value.tv_sec
suffix:semicolon
multiline_comment|/* ehhh.. We can&squot;t return 0 if we have an alarm pending.. */
multiline_comment|/* And we&squot;d better return too much than too little anyway */
r_if
c_cond
(paren
id|it_old.it_value.tv_usec
)paren
id|oldalarm
op_increment
suffix:semicolon
r_return
id|oldalarm
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifndef __alpha__
multiline_comment|/*&n; * The Alpha uses getxpid, getxuid, and getxgid instead.  Maybe this&n; * should be moved into arch/i386 instead?&n; */
DECL|function|sys_getpid
id|asmlinkage
r_int
id|sys_getpid
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* This is SMP safe - current-&gt;pid doesn&squot;t change */
r_return
id|current-&gt;tgid
suffix:semicolon
)brace
multiline_comment|/*&n; * This is not strictly SMP safe: p_opptr could change&n; * from under us. However, rather than getting any lock&n; * we can use an optimistic algorithm: get the parent&n; * pid, and go back and check that the parent is still&n; * the same. If it has changed (which is extremely unlikely&n; * indeed), we just try again..&n; *&n; * NOTE! This depends on the fact that even if we _do_&n; * get an old value of &quot;parent&quot;, we can happily dereference&n; * the pointer: we just can&squot;t necessarily trust the result&n; * until we know that the parent pointer is valid.&n; *&n; * The &quot;mb()&quot; macro is a memory barrier - a synchronizing&n; * event. It also makes sure that gcc doesn&squot;t optimize&n; * away the necessary memory references.. The barrier doesn&squot;t&n; * have to have all that strong semantics: on x86 we don&squot;t&n; * really require a synchronizing instruction, for example.&n; * The barrier is more important for code generation than&n; * for any real memory ordering semantics (even if there is&n; * a small window for a race, using the old pointer is&n; * harmless for a while).&n; */
DECL|function|sys_getppid
id|asmlinkage
r_int
id|sys_getppid
c_func
(paren
r_void
)paren
(brace
r_int
id|pid
suffix:semicolon
r_struct
id|task_struct
op_star
id|me
op_assign
id|current
suffix:semicolon
r_struct
id|task_struct
op_star
id|parent
suffix:semicolon
id|parent
op_assign
id|me-&gt;p_opptr
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|pid
op_assign
id|parent-&gt;pid
suffix:semicolon
macro_line|#if CONFIG_SMP
(brace
r_struct
id|task_struct
op_star
id|old
op_assign
id|parent
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|parent
op_assign
id|me-&gt;p_opptr
suffix:semicolon
r_if
c_cond
(paren
id|old
op_ne
id|parent
)paren
r_continue
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
)brace
r_return
id|pid
suffix:semicolon
)brace
DECL|function|sys_getuid
id|asmlinkage
r_int
id|sys_getuid
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Only we change this so SMP safe */
r_return
id|current-&gt;uid
suffix:semicolon
)brace
DECL|function|sys_geteuid
id|asmlinkage
r_int
id|sys_geteuid
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Only we change this so SMP safe */
r_return
id|current-&gt;euid
suffix:semicolon
)brace
DECL|function|sys_getgid
id|asmlinkage
r_int
id|sys_getgid
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Only we change this so SMP safe */
r_return
id|current-&gt;gid
suffix:semicolon
)brace
DECL|function|sys_getegid
id|asmlinkage
r_int
id|sys_getegid
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Only we change this so SMP safe */
r_return
id|current-&gt;egid
suffix:semicolon
)brace
macro_line|#endif
DECL|function|sys_nanosleep
id|asmlinkage
r_int
id|sys_nanosleep
c_func
(paren
r_struct
id|timespec
op_star
id|rqtp
comma
r_struct
id|timespec
op_star
id|rmtp
)paren
(brace
r_struct
id|timespec
id|t
suffix:semicolon
r_int
r_int
id|expire
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|t
comma
id|rqtp
comma
r_sizeof
(paren
r_struct
id|timespec
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|t.tv_nsec
op_ge
l_int|1000000000L
op_logical_or
id|t.tv_nsec
OL
l_int|0
op_logical_or
id|t.tv_sec
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|t.tv_sec
op_eq
l_int|0
op_logical_and
id|t.tv_nsec
op_le
l_int|2000000L
op_logical_and
id|current-&gt;policy
op_ne
id|SCHED_OTHER
)paren
(brace
multiline_comment|/*&n;&t;&t; * Short delay requests up to 2 ms will be handled with&n;&t;&t; * high precision by a busy wait for all real-time processes.&n;&t;&t; *&n;&t;&t; * Its important on SMP not to do this holding locks.&n;&t;&t; */
id|udelay
c_func
(paren
(paren
id|t.tv_nsec
op_plus
l_int|999
)paren
op_div
l_int|1000
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|expire
op_assign
id|timespec_to_jiffies
c_func
(paren
op_amp
id|t
)paren
op_plus
(paren
id|t.tv_sec
op_logical_or
id|t.tv_nsec
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|expire
op_assign
id|schedule_timeout
c_func
(paren
id|expire
)paren
suffix:semicolon
r_if
c_cond
(paren
id|expire
)paren
(brace
r_if
c_cond
(paren
id|rmtp
)paren
(brace
id|jiffies_to_timespec
c_func
(paren
id|expire
comma
op_amp
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|rmtp
comma
op_amp
id|t
comma
r_sizeof
(paren
r_struct
id|timespec
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
