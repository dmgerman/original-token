multiline_comment|/*&n; *  linux/kernel/sys.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/utsname.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/prctl.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/highuid.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
multiline_comment|/*&n; * this is where the system-wide overflow UID and GID are defined, for&n; * architectures that now have 32-bit UID/GID but didn&squot;t in the past&n; */
DECL|variable|overflowuid
r_int
id|overflowuid
op_assign
id|DEFAULT_OVERFLOWUID
suffix:semicolon
DECL|variable|overflowgid
r_int
id|overflowgid
op_assign
id|DEFAULT_OVERFLOWGID
suffix:semicolon
multiline_comment|/*&n; * the same as above, but for filesystems which can only store a 16-bit&n; * UID and GID. as such, this is needed on all architectures&n; */
DECL|variable|fs_overflowuid
r_int
id|fs_overflowuid
op_assign
id|DEFAULT_FS_OVERFLOWUID
suffix:semicolon
DECL|variable|fs_overflowgid
r_int
id|fs_overflowgid
op_assign
id|DEFAULT_FS_OVERFLOWUID
suffix:semicolon
multiline_comment|/*&n; * this indicates whether you can reboot with ctrl-alt-del: the default is yes&n; */
DECL|variable|C_A_D
r_int
id|C_A_D
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n; *&t;Notifier list for kernel code which wants to be called&n; *&t;at shutdown. This is used to stop any idling DMA operations&n; *&t;and the like. &n; */
DECL|variable|reboot_notifier_list
r_static
r_struct
id|notifier_block
op_star
id|reboot_notifier_list
suffix:semicolon
DECL|variable|notifier_lock
id|rwlock_t
id|notifier_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/**&n; *&t;notifier_chain_register&t;- Add notifier to a notifier chain&n; *&t;@list: Pointer to root list pointer&n; *&t;@n: New entry in notifier chain&n; *&n; *&t;Adds a notifier to a notifier chain.&n; *&n; *&t;Currently always returns zero.&n; */
DECL|function|notifier_chain_register
r_int
id|notifier_chain_register
c_func
(paren
r_struct
id|notifier_block
op_star
op_star
id|list
comma
r_struct
id|notifier_block
op_star
id|n
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|notifier_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|list
)paren
(brace
r_if
c_cond
(paren
id|n-&gt;priority
OG
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|priority
)paren
(brace
r_break
suffix:semicolon
)brace
id|list
op_assign
op_amp
(paren
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
)brace
id|n-&gt;next
op_assign
op_star
id|list
suffix:semicolon
op_star
id|list
op_assign
id|n
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|notifier_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;notifier_chain_unregister - Remove notifier from a notifier chain&n; *&t;@nl: Pointer to root list pointer&n; *&t;@n: New entry in notifier chain&n; *&n; *&t;Removes a notifier from a notifier chain.&n; *&n; *&t;Returns zero on success, or %-ENOENT on failure.&n; */
DECL|function|notifier_chain_unregister
r_int
id|notifier_chain_unregister
c_func
(paren
r_struct
id|notifier_block
op_star
op_star
id|nl
comma
r_struct
id|notifier_block
op_star
id|n
)paren
(brace
id|write_lock
c_func
(paren
op_amp
id|notifier_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|nl
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|nl
)paren
op_eq
id|n
)paren
(brace
op_star
id|nl
op_assign
id|n-&gt;next
suffix:semicolon
id|write_unlock
c_func
(paren
op_amp
id|notifier_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|nl
op_assign
op_amp
(paren
(paren
op_star
id|nl
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
)brace
id|write_unlock
c_func
(paren
op_amp
id|notifier_lock
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;notifier_call_chain - Call functions in a notifier chain&n; *&t;@n: Pointer to root pointer of notifier chain&n; *&t;@val: Value passed unmodified to notifier function&n; *&t;@v: Pointer passed unmodified to notifier function&n; *&n; *&t;Calls each function in a notifier chain in turn.&n; *&n; *&t;If the return value of the notifier can be and&squot;d&n; *&t;with %NOTIFY_STOP_MASK, then notifier_call_chain&n; *&t;will return immediately, with the return value of&n; *&t;the notifier function which halted execution.&n; *&t;Otherwise, the return value is the return value&n; *&t;of the last notifier function called.&n; */
DECL|function|notifier_call_chain
r_int
id|notifier_call_chain
c_func
(paren
r_struct
id|notifier_block
op_star
op_star
id|n
comma
r_int
r_int
id|val
comma
r_void
op_star
id|v
)paren
(brace
r_int
id|ret
op_assign
id|NOTIFY_DONE
suffix:semicolon
r_struct
id|notifier_block
op_star
id|nb
op_assign
op_star
id|n
suffix:semicolon
r_while
c_loop
(paren
id|nb
)paren
(brace
id|ret
op_assign
id|nb
op_member_access_from_pointer
id|notifier_call
c_func
(paren
id|nb
comma
id|val
comma
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_amp
id|NOTIFY_STOP_MASK
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
id|nb
op_assign
id|nb-&gt;next
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;register_reboot_notifier - Register function to be called at reboot time&n; *&t;@nb: Info about notifier function to be called&n; *&n; *&t;Registers a function with the list of functions&n; *&t;to be called at reboot time.&n; *&n; *&t;Currently always returns zero, as notifier_chain_register&n; *&t;always returns zero.&n; */
DECL|function|register_reboot_notifier
r_int
id|register_reboot_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_return
id|notifier_chain_register
c_func
(paren
op_amp
id|reboot_notifier_list
comma
id|nb
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; *&t;unregister_reboot_notifier - Unregister previously registered reboot notifier&n; *&t;@nb: Hook to be unregistered&n; *&n; *&t;Unregisters a previously registered reboot&n; *&t;notifier function.&n; *&n; *&t;Returns zero on success, or %-ENOENT on failure.&n; */
DECL|function|unregister_reboot_notifier
r_int
id|unregister_reboot_notifier
c_func
(paren
r_struct
id|notifier_block
op_star
id|nb
)paren
(brace
r_return
id|notifier_chain_unregister
c_func
(paren
op_amp
id|reboot_notifier_list
comma
id|nb
)paren
suffix:semicolon
)brace
DECL|function|sys_ni_syscall
id|asmlinkage
r_int
id|sys_ni_syscall
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|proc_sel
r_static
r_int
id|proc_sel
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
id|which
comma
r_int
id|who
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;pid
)paren
(brace
r_switch
c_cond
(paren
id|which
)paren
(brace
r_case
id|PRIO_PROCESS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|who
op_logical_and
id|p
op_eq
id|current
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|p-&gt;pid
op_eq
id|who
suffix:semicolon
r_case
id|PRIO_PGRP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|who
)paren
id|who
op_assign
id|current-&gt;pgrp
suffix:semicolon
r_return
id|p-&gt;pgrp
op_eq
id|who
suffix:semicolon
r_case
id|PRIO_USER
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|who
)paren
id|who
op_assign
id|current-&gt;uid
suffix:semicolon
r_return
id|p-&gt;uid
op_eq
id|who
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_setpriority
id|asmlinkage
r_int
id|sys_setpriority
c_func
(paren
r_int
id|which
comma
r_int
id|who
comma
r_int
id|niceval
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|which
OG
l_int|2
op_logical_or
id|which
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* normalize: avoid signed division (rounding problems) */
id|error
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
id|niceval
OL
op_minus
l_int|20
)paren
id|niceval
op_assign
op_minus
l_int|20
suffix:semicolon
r_if
c_cond
(paren
id|niceval
OG
l_int|19
)paren
id|niceval
op_assign
l_int|19
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|proc_sel
c_func
(paren
id|p
comma
id|which
comma
id|who
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;uid
op_ne
id|current-&gt;euid
op_logical_and
id|p-&gt;uid
op_ne
id|current-&gt;uid
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_NICE
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
op_eq
op_minus
id|ESRCH
)paren
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|niceval
OL
id|p-&gt;nice
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_NICE
)paren
)paren
id|error
op_assign
op_minus
id|EACCES
suffix:semicolon
r_else
id|p-&gt;nice
op_assign
id|niceval
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Ugh. To avoid negative return values, &quot;getpriority()&quot; will&n; * not return the normal nice-value, but a negated value that&n; * has been offset by 20 (ie it returns 40..1 instead of -20..19)&n; * to stay compatible.&n; */
DECL|function|sys_getpriority
id|asmlinkage
r_int
id|sys_getpriority
c_func
(paren
r_int
id|which
comma
r_int
id|who
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|retval
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
id|which
OG
l_int|2
op_logical_or
id|which
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
(paren
id|p
)paren
(brace
r_int
id|niceval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|proc_sel
c_func
(paren
id|p
comma
id|which
comma
id|who
)paren
)paren
r_continue
suffix:semicolon
id|niceval
op_assign
l_int|20
op_minus
id|p-&gt;nice
suffix:semicolon
r_if
c_cond
(paren
id|niceval
OG
id|retval
)paren
id|retval
op_assign
id|niceval
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Reboot system call: for obvious reasons only root may call it,&n; * and even root needs to set up some magic numbers in the registers&n; * so that some mistake won&squot;t make this reboot the whole machine.&n; * You can also set the meaning of the ctrl-alt-del-key here.&n; *&n; * reboot doesn&squot;t sync: do that yourself before calling this.&n; */
DECL|function|sys_reboot
id|asmlinkage
r_int
id|sys_reboot
c_func
(paren
r_int
id|magic1
comma
r_int
id|magic2
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_char
id|buffer
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/* We only trust the superuser with rebooting the system. */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_BOOT
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* For safety, we require &quot;magic&quot; arguments. */
r_if
c_cond
(paren
id|magic1
op_ne
id|LINUX_REBOOT_MAGIC1
op_logical_or
(paren
id|magic2
op_ne
id|LINUX_REBOOT_MAGIC2
op_logical_and
id|magic2
op_ne
id|LINUX_REBOOT_MAGIC2A
op_logical_and
id|magic2
op_ne
id|LINUX_REBOOT_MAGIC2B
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|LINUX_REBOOT_CMD_RESTART
suffix:colon
id|notifier_call_chain
c_func
(paren
op_amp
id|reboot_notifier_list
comma
id|SYS_RESTART
comma
l_int|NULL
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;Restarting system.&bslash;n&quot;
)paren
suffix:semicolon
id|machine_restart
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LINUX_REBOOT_CMD_CAD_ON
suffix:colon
id|C_A_D
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LINUX_REBOOT_CMD_CAD_OFF
suffix:colon
id|C_A_D
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LINUX_REBOOT_CMD_HALT
suffix:colon
id|notifier_call_chain
c_func
(paren
op_amp
id|reboot_notifier_list
comma
id|SYS_HALT
comma
l_int|NULL
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;System halted.&bslash;n&quot;
)paren
suffix:semicolon
id|machine_halt
c_func
(paren
)paren
suffix:semicolon
id|do_exit
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LINUX_REBOOT_CMD_POWER_OFF
suffix:colon
id|notifier_call_chain
c_func
(paren
op_amp
id|reboot_notifier_list
comma
id|SYS_POWER_OFF
comma
l_int|NULL
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;Power down.&bslash;n&quot;
)paren
suffix:semicolon
id|machine_power_off
c_func
(paren
)paren
suffix:semicolon
id|do_exit
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LINUX_REBOOT_CMD_RESTART2
suffix:colon
r_if
c_cond
(paren
id|strncpy_from_user
c_func
(paren
op_amp
id|buffer
(braket
l_int|0
)braket
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|buffer
)paren
op_minus
l_int|1
)paren
OL
l_int|0
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|buffer
(braket
r_sizeof
(paren
id|buffer
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|notifier_call_chain
c_func
(paren
op_amp
id|reboot_notifier_list
comma
id|SYS_RESTART
comma
id|buffer
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;Restarting system with command &squot;%s&squot;.&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
id|machine_restart
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function gets called by ctrl-alt-del - ie the keyboard interrupt.&n; * As it&squot;s called within an interrupt, it may NOT sync: the only choice&n; * is whether to reboot at once, or just ignore the ctrl-alt-del.&n; */
DECL|function|ctrl_alt_del
r_void
id|ctrl_alt_del
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|C_A_D
)paren
(brace
id|notifier_call_chain
c_func
(paren
op_amp
id|reboot_notifier_list
comma
id|SYS_RESTART
comma
l_int|NULL
)paren
suffix:semicolon
id|machine_restart
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
id|kill_proc
c_func
(paren
l_int|1
comma
id|SIGINT
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Unprivileged users may change the real gid to the effective gid&n; * or vice versa.  (BSD-style)&n; *&n; * If you set the real gid at all, or set the effective gid to a value not&n; * equal to the real gid, then the saved gid is set to the new effective gid.&n; *&n; * This makes it possible for a setgid program to completely drop its&n; * privileges, which is often a useful assertion to make when you are doing&n; * a security audit over a program.&n; *&n; * The general idea is that a program which uses just setregid() will be&n; * 100% compatible with BSD.  A program which uses just setgid() will be&n; * 100% compatible with POSIX with saved IDs. &n; *&n; * SMP: There are not races, the GIDs are checked only by filesystem&n; *      operations (as far as semantic preservation is concerned).&n; */
DECL|function|sys_setregid
id|asmlinkage
r_int
id|sys_setregid
c_func
(paren
id|gid_t
id|rgid
comma
id|gid_t
id|egid
)paren
(brace
r_int
id|old_rgid
op_assign
id|current-&gt;gid
suffix:semicolon
r_int
id|old_egid
op_assign
id|current-&gt;egid
suffix:semicolon
r_if
c_cond
(paren
id|rgid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|old_rgid
op_eq
id|rgid
)paren
op_logical_or
(paren
id|current-&gt;egid
op_eq
id|rgid
)paren
op_logical_or
id|capable
c_func
(paren
id|CAP_SETGID
)paren
)paren
id|current-&gt;gid
op_assign
id|rgid
suffix:semicolon
r_else
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|egid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|old_rgid
op_eq
id|egid
)paren
op_logical_or
(paren
id|current-&gt;egid
op_eq
id|egid
)paren
op_logical_or
(paren
id|current-&gt;sgid
op_eq
id|egid
)paren
op_logical_or
id|capable
c_func
(paren
id|CAP_SETGID
)paren
)paren
id|current-&gt;fsgid
op_assign
id|current-&gt;egid
op_assign
id|egid
suffix:semicolon
r_else
(brace
id|current-&gt;gid
op_assign
id|old_rgid
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rgid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
op_logical_or
(paren
id|egid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
op_logical_and
id|egid
op_ne
id|old_rgid
)paren
)paren
id|current-&gt;sgid
op_assign
id|current-&gt;egid
suffix:semicolon
id|current-&gt;fsgid
op_assign
id|current-&gt;egid
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;egid
op_ne
id|old_egid
)paren
id|current-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * setgid() is implemented like SysV w/ SAVED_IDS &n; *&n; * SMP: Same implicit races as above.&n; */
DECL|function|sys_setgid
id|asmlinkage
r_int
id|sys_setgid
c_func
(paren
id|gid_t
id|gid
)paren
(brace
r_int
id|old_egid
op_assign
id|current-&gt;egid
suffix:semicolon
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_SETGID
)paren
)paren
id|current-&gt;gid
op_assign
id|current-&gt;egid
op_assign
id|current-&gt;sgid
op_assign
id|current-&gt;fsgid
op_assign
id|gid
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|gid
op_eq
id|current-&gt;gid
)paren
op_logical_or
(paren
id|gid
op_eq
id|current-&gt;sgid
)paren
)paren
id|current-&gt;egid
op_assign
id|current-&gt;fsgid
op_assign
id|gid
suffix:semicolon
r_else
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;egid
op_ne
id|old_egid
)paren
id|current-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * cap_emulate_setxuid() fixes the effective / permitted capabilities of&n; * a process after a call to setuid, setreuid, or setresuid.&n; *&n; *  1) When set*uiding _from_ one of {r,e,s}uid == 0 _to_ all of&n; *  {r,e,s}uid != 0, the permitted and effective capabilities are&n; *  cleared.&n; *&n; *  2) When set*uiding _from_ euid == 0 _to_ euid != 0, the effective&n; *  capabilities of the process are cleared.&n; *&n; *  3) When set*uiding _from_ euid != 0 _to_ euid == 0, the effective&n; *  capabilities are set to the permitted capabilities.&n; *&n; *  fsuid is handled elsewhere. fsuid == 0 and {r,e,s}uid!= 0 should &n; *  never happen.&n; *&n; *  -astor &n; *&n; * cevans - New behaviour, Oct &squot;99&n; * A process may, via prctl(), elect to keep its capabilities when it&n; * calls setuid() and switches away from uid==0. Both permitted and&n; * effective sets will be retained.&n; * Without this change, it was impossible for a daemon to drop only some&n; * of its privilege. The call to setuid(!=0) would drop all privileges!&n; * Keeping uid 0 is not an option because uid 0 owns too many vital&n; * files..&n; * Thanks to Olaf Kirch and Peter Benie for spotting this.&n; */
DECL|function|cap_emulate_setxuid
r_extern
r_inline
r_void
id|cap_emulate_setxuid
c_func
(paren
r_int
id|old_ruid
comma
r_int
id|old_euid
comma
r_int
id|old_suid
)paren
(brace
r_if
c_cond
(paren
(paren
id|old_ruid
op_eq
l_int|0
op_logical_or
id|old_euid
op_eq
l_int|0
op_logical_or
id|old_suid
op_eq
l_int|0
)paren
op_logical_and
(paren
id|current-&gt;uid
op_ne
l_int|0
op_logical_and
id|current-&gt;euid
op_ne
l_int|0
op_logical_and
id|current-&gt;suid
op_ne
l_int|0
)paren
op_logical_and
op_logical_neg
id|current-&gt;keep_capabilities
)paren
(brace
id|cap_clear
c_func
(paren
id|current-&gt;cap_permitted
)paren
suffix:semicolon
id|cap_clear
c_func
(paren
id|current-&gt;cap_effective
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_euid
op_eq
l_int|0
op_logical_and
id|current-&gt;euid
op_ne
l_int|0
)paren
(brace
id|cap_clear
c_func
(paren
id|current-&gt;cap_effective
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_euid
op_ne
l_int|0
op_logical_and
id|current-&gt;euid
op_eq
l_int|0
)paren
(brace
id|current-&gt;cap_effective
op_assign
id|current-&gt;cap_permitted
suffix:semicolon
)brace
)brace
DECL|function|set_user
r_static
r_int
id|set_user
c_func
(paren
id|uid_t
id|new_ruid
)paren
(brace
r_struct
id|user_struct
op_star
id|new_user
comma
op_star
id|old_user
suffix:semicolon
multiline_comment|/* What if a process setreuid()&squot;s and this brings the&n;&t; * new uid over his NPROC rlimit?  We can check this now&n;&t; * cheaply with the new uid cache, so if it matters&n;&t; * we should be checking for it.  -DaveM&n;&t; */
id|new_user
op_assign
id|alloc_uid
c_func
(paren
id|new_ruid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_user
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|old_user
op_assign
id|current-&gt;user
suffix:semicolon
id|atomic_dec
c_func
(paren
op_amp
id|old_user-&gt;processes
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|new_user-&gt;processes
)paren
suffix:semicolon
id|current-&gt;uid
op_assign
id|new_ruid
suffix:semicolon
id|current-&gt;user
op_assign
id|new_user
suffix:semicolon
id|free_uid
c_func
(paren
id|old_user
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Unprivileged users may change the real uid to the effective uid&n; * or vice versa.  (BSD-style)&n; *&n; * If you set the real uid at all, or set the effective uid to a value not&n; * equal to the real uid, then the saved uid is set to the new effective uid.&n; *&n; * This makes it possible for a setuid program to completely drop its&n; * privileges, which is often a useful assertion to make when you are doing&n; * a security audit over a program.&n; *&n; * The general idea is that a program which uses just setreuid() will be&n; * 100% compatible with BSD.  A program which uses just setuid() will be&n; * 100% compatible with POSIX with saved IDs. &n; */
DECL|function|sys_setreuid
id|asmlinkage
r_int
id|sys_setreuid
c_func
(paren
id|uid_t
id|ruid
comma
id|uid_t
id|euid
)paren
(brace
r_int
id|old_ruid
comma
id|old_euid
comma
id|old_suid
comma
id|new_ruid
comma
id|new_euid
suffix:semicolon
id|new_ruid
op_assign
id|old_ruid
op_assign
id|current-&gt;uid
suffix:semicolon
id|new_euid
op_assign
id|old_euid
op_assign
id|current-&gt;euid
suffix:semicolon
id|old_suid
op_assign
id|current-&gt;suid
suffix:semicolon
r_if
c_cond
(paren
id|ruid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
(brace
id|new_ruid
op_assign
id|ruid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|old_ruid
op_ne
id|ruid
)paren
op_logical_and
(paren
id|current-&gt;euid
op_ne
id|ruid
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SETUID
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|euid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
(brace
id|new_euid
op_assign
id|euid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|old_ruid
op_ne
id|euid
)paren
op_logical_and
(paren
id|current-&gt;euid
op_ne
id|euid
)paren
op_logical_and
(paren
id|current-&gt;suid
op_ne
id|euid
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SETUID
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_ruid
op_ne
id|old_ruid
op_logical_and
id|set_user
c_func
(paren
id|new_ruid
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|current-&gt;fsuid
op_assign
id|current-&gt;euid
op_assign
id|new_euid
suffix:semicolon
r_if
c_cond
(paren
id|ruid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
op_logical_or
(paren
id|euid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
op_logical_and
id|euid
op_ne
id|old_ruid
)paren
)paren
id|current-&gt;suid
op_assign
id|current-&gt;euid
suffix:semicolon
id|current-&gt;fsuid
op_assign
id|current-&gt;euid
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;euid
op_ne
id|old_euid
)paren
id|current-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|issecure
c_func
(paren
id|SECURE_NO_SETUID_FIXUP
)paren
)paren
(brace
id|cap_emulate_setxuid
c_func
(paren
id|old_ruid
comma
id|old_euid
comma
id|old_suid
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * setuid() is implemented like SysV with SAVED_IDS &n; * &n; * Note that SAVED_ID&squot;s is deficient in that a setuid root program&n; * like sendmail, for example, cannot set its uid to be a normal &n; * user and then switch back, because if you&squot;re root, setuid() sets&n; * the saved uid too.  If you don&squot;t like this, blame the bright people&n; * in the POSIX committee and/or USG.  Note that the BSD-style setreuid()&n; * will allow a root program to temporarily drop privileges and be able to&n; * regain them by swapping the real and effective uid.  &n; */
DECL|function|sys_setuid
id|asmlinkage
r_int
id|sys_setuid
c_func
(paren
id|uid_t
id|uid
)paren
(brace
r_int
id|old_euid
op_assign
id|current-&gt;euid
suffix:semicolon
r_int
id|old_ruid
comma
id|old_suid
comma
id|new_ruid
suffix:semicolon
id|old_ruid
op_assign
id|new_ruid
op_assign
id|current-&gt;uid
suffix:semicolon
id|old_suid
op_assign
id|current-&gt;suid
suffix:semicolon
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_SETUID
)paren
)paren
(brace
r_if
c_cond
(paren
id|uid
op_ne
id|old_ruid
op_logical_and
id|set_user
c_func
(paren
id|uid
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|current-&gt;suid
op_assign
id|uid
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|uid
op_ne
id|current-&gt;uid
)paren
op_logical_and
(paren
id|uid
op_ne
id|current-&gt;suid
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|current-&gt;fsuid
op_assign
id|current-&gt;euid
op_assign
id|uid
suffix:semicolon
r_if
c_cond
(paren
id|old_euid
op_ne
id|uid
)paren
id|current-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|issecure
c_func
(paren
id|SECURE_NO_SETUID_FIXUP
)paren
)paren
(brace
id|cap_emulate_setxuid
c_func
(paren
id|old_ruid
comma
id|old_euid
comma
id|old_suid
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function implements a generic ability to update ruid, euid,&n; * and suid.  This allows you to implement the 4.4 compatible seteuid().&n; */
DECL|function|sys_setresuid
id|asmlinkage
r_int
id|sys_setresuid
c_func
(paren
id|uid_t
id|ruid
comma
id|uid_t
id|euid
comma
id|uid_t
id|suid
)paren
(brace
r_int
id|old_ruid
op_assign
id|current-&gt;uid
suffix:semicolon
r_int
id|old_euid
op_assign
id|current-&gt;euid
suffix:semicolon
r_int
id|old_suid
op_assign
id|current-&gt;suid
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SETUID
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|ruid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
op_logical_and
(paren
id|ruid
op_ne
id|current-&gt;uid
)paren
op_logical_and
(paren
id|ruid
op_ne
id|current-&gt;euid
)paren
op_logical_and
(paren
id|ruid
op_ne
id|current-&gt;suid
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|euid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
op_logical_and
(paren
id|euid
op_ne
id|current-&gt;uid
)paren
op_logical_and
(paren
id|euid
op_ne
id|current-&gt;euid
)paren
op_logical_and
(paren
id|euid
op_ne
id|current-&gt;suid
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|suid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
op_logical_and
(paren
id|suid
op_ne
id|current-&gt;uid
)paren
op_logical_and
(paren
id|suid
op_ne
id|current-&gt;euid
)paren
op_logical_and
(paren
id|suid
op_ne
id|current-&gt;suid
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ruid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|ruid
op_ne
id|current-&gt;uid
op_logical_and
id|set_user
c_func
(paren
id|ruid
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|euid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|euid
op_ne
id|current-&gt;euid
)paren
id|current-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
id|current-&gt;euid
op_assign
id|euid
suffix:semicolon
id|current-&gt;fsuid
op_assign
id|euid
suffix:semicolon
)brace
r_if
c_cond
(paren
id|suid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
id|current-&gt;suid
op_assign
id|suid
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|issecure
c_func
(paren
id|SECURE_NO_SETUID_FIXUP
)paren
)paren
(brace
id|cap_emulate_setxuid
c_func
(paren
id|old_ruid
comma
id|old_euid
comma
id|old_suid
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_getresuid
id|asmlinkage
r_int
id|sys_getresuid
c_func
(paren
id|uid_t
op_star
id|ruid
comma
id|uid_t
op_star
id|euid
comma
id|uid_t
op_star
id|suid
)paren
(brace
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|retval
op_assign
id|put_user
c_func
(paren
id|current-&gt;uid
comma
id|ruid
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|retval
op_assign
id|put_user
c_func
(paren
id|current-&gt;euid
comma
id|euid
)paren
)paren
)paren
id|retval
op_assign
id|put_user
c_func
(paren
id|current-&gt;suid
comma
id|suid
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Same as above, but for rgid, egid, sgid.&n; */
DECL|function|sys_setresgid
id|asmlinkage
r_int
id|sys_setresgid
c_func
(paren
id|gid_t
id|rgid
comma
id|gid_t
id|egid
comma
id|gid_t
id|sgid
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SETGID
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|rgid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
op_logical_and
(paren
id|rgid
op_ne
id|current-&gt;gid
)paren
op_logical_and
(paren
id|rgid
op_ne
id|current-&gt;egid
)paren
op_logical_and
(paren
id|rgid
op_ne
id|current-&gt;sgid
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|egid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
op_logical_and
(paren
id|egid
op_ne
id|current-&gt;gid
)paren
op_logical_and
(paren
id|egid
op_ne
id|current-&gt;egid
)paren
op_logical_and
(paren
id|egid
op_ne
id|current-&gt;sgid
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sgid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
op_logical_and
(paren
id|sgid
op_ne
id|current-&gt;gid
)paren
op_logical_and
(paren
id|sgid
op_ne
id|current-&gt;egid
)paren
op_logical_and
(paren
id|sgid
op_ne
id|current-&gt;sgid
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rgid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
id|current-&gt;gid
op_assign
id|rgid
suffix:semicolon
r_if
c_cond
(paren
id|egid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|egid
op_ne
id|current-&gt;egid
)paren
id|current-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
id|current-&gt;egid
op_assign
id|egid
suffix:semicolon
id|current-&gt;fsgid
op_assign
id|egid
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sgid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
id|current-&gt;sgid
op_assign
id|sgid
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_getresgid
id|asmlinkage
r_int
id|sys_getresgid
c_func
(paren
id|gid_t
op_star
id|rgid
comma
id|gid_t
op_star
id|egid
comma
id|gid_t
op_star
id|sgid
)paren
(brace
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|retval
op_assign
id|put_user
c_func
(paren
id|current-&gt;gid
comma
id|rgid
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|retval
op_assign
id|put_user
c_func
(paren
id|current-&gt;egid
comma
id|egid
)paren
)paren
)paren
id|retval
op_assign
id|put_user
c_func
(paren
id|current-&gt;sgid
comma
id|sgid
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * &quot;setfsuid()&quot; sets the fsuid - the uid used for filesystem checks. This&n; * is used for &quot;access()&quot; and for the NFS daemon (letting nfsd stay at&n; * whatever uid it wants to). It normally shadows &quot;euid&quot;, except when&n; * explicitly set by setfsuid() or for access..&n; */
DECL|function|sys_setfsuid
id|asmlinkage
r_int
id|sys_setfsuid
c_func
(paren
id|uid_t
id|uid
)paren
(brace
r_int
id|old_fsuid
suffix:semicolon
id|old_fsuid
op_assign
id|current-&gt;fsuid
suffix:semicolon
r_if
c_cond
(paren
id|uid
op_eq
id|current-&gt;uid
op_logical_or
id|uid
op_eq
id|current-&gt;euid
op_logical_or
id|uid
op_eq
id|current-&gt;suid
op_logical_or
id|uid
op_eq
id|current-&gt;fsuid
op_logical_or
id|capable
c_func
(paren
id|CAP_SETUID
)paren
)paren
id|current-&gt;fsuid
op_assign
id|uid
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;fsuid
op_ne
id|old_fsuid
)paren
id|current-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We emulate fsuid by essentially doing a scaled-down version&n;&t; * of what we did in setresuid and friends. However, we only&n;&t; * operate on the fs-specific bits of the process&squot; effective&n;&t; * capabilities &n;&t; *&n;&t; * FIXME - is fsuser used for all CAP_FS_MASK capabilities?&n;&t; *          if not, we might be a bit too harsh here.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|issecure
c_func
(paren
id|SECURE_NO_SETUID_FIXUP
)paren
)paren
(brace
r_if
c_cond
(paren
id|old_fsuid
op_eq
l_int|0
op_logical_and
id|current-&gt;fsuid
op_ne
l_int|0
)paren
(brace
id|cap_t
c_func
(paren
id|current-&gt;cap_effective
)paren
op_and_assign
op_complement
id|CAP_FS_MASK
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_fsuid
op_ne
l_int|0
op_logical_and
id|current-&gt;fsuid
op_eq
l_int|0
)paren
(brace
id|cap_t
c_func
(paren
id|current-&gt;cap_effective
)paren
op_or_assign
(paren
id|cap_t
c_func
(paren
id|current-&gt;cap_permitted
)paren
op_amp
id|CAP_FS_MASK
)paren
suffix:semicolon
)brace
)brace
r_return
id|old_fsuid
suffix:semicolon
)brace
multiline_comment|/*&n; * Samma p&#xfffd; svenska..&n; */
DECL|function|sys_setfsgid
id|asmlinkage
r_int
id|sys_setfsgid
c_func
(paren
id|gid_t
id|gid
)paren
(brace
r_int
id|old_fsgid
suffix:semicolon
id|old_fsgid
op_assign
id|current-&gt;fsgid
suffix:semicolon
r_if
c_cond
(paren
id|gid
op_eq
id|current-&gt;gid
op_logical_or
id|gid
op_eq
id|current-&gt;egid
op_logical_or
id|gid
op_eq
id|current-&gt;sgid
op_logical_or
id|gid
op_eq
id|current-&gt;fsgid
op_logical_or
id|capable
c_func
(paren
id|CAP_SETGID
)paren
)paren
id|current-&gt;fsgid
op_assign
id|gid
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;fsgid
op_ne
id|old_fsgid
)paren
id|current-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
r_return
id|old_fsgid
suffix:semicolon
)brace
DECL|function|sys_times
id|asmlinkage
r_int
id|sys_times
c_func
(paren
r_struct
id|tms
op_star
id|tbuf
)paren
(brace
multiline_comment|/*&n;&t; *&t;In the SMP world we might just be unlucky and have one of&n;&t; *&t;the times increment as we use it. Since the value is an&n;&t; *&t;atomically safe type this is just fine. Conceptually its&n;&t; *&t;as if the syscall took an instant longer to occur.&n;&t; */
r_if
c_cond
(paren
id|tbuf
)paren
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|tbuf
comma
op_amp
id|current-&gt;times
comma
r_sizeof
(paren
r_struct
id|tms
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|jiffies
suffix:semicolon
)brace
multiline_comment|/*&n; * This needs some heavy checking ...&n; * I just haven&squot;t the stomach for it. I also don&squot;t fully&n; * understand sessions/pgrp etc. Let somebody who does explain it.&n; *&n; * OK, I think I have the protection semantics right.... this is really&n; * only important on a multi-user system anyway, to make sure one user&n; * can&squot;t send a signal to a process owned by another.  -TYT, 12/12/91&n; *&n; * Auch. Had to add the &squot;did_exec&squot; flag to conform completely to POSIX.&n; * LBT 04.03.94&n; */
DECL|function|sys_setpgid
id|asmlinkage
r_int
id|sys_setpgid
c_func
(paren
id|pid_t
id|pid
comma
id|pid_t
id|pgid
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pid
)paren
id|pid
op_assign
id|current-&gt;pid
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgid
)paren
id|pgid
op_assign
id|pid
suffix:semicolon
r_if
c_cond
(paren
id|pgid
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* From this point forward we keep holding onto the tasklist lock&n;&t; * so that our parent does not change from under us. -DaveM&n;&t; */
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|err
op_assign
op_minus
id|ESRCH
suffix:semicolon
id|p
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;p_pptr
op_eq
id|current
op_logical_or
id|p-&gt;p_opptr
op_eq
id|current
)paren
(brace
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;session
op_ne
id|current-&gt;session
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;did_exec
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p
op_ne
id|current
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;leader
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|pgid
op_ne
id|pid
)paren
(brace
r_struct
id|task_struct
op_star
id|tmp
suffix:semicolon
id|for_each_task
(paren
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;pgrp
op_eq
id|pgid
op_logical_and
id|tmp-&gt;session
op_eq
id|current-&gt;session
)paren
r_goto
id|ok_pgid
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
id|ok_pgid
suffix:colon
id|p-&gt;pgrp
op_assign
id|pgid
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
multiline_comment|/* All paths lead to here, thus we are safe. -DaveM */
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sys_getpgid
id|asmlinkage
r_int
id|sys_getpgid
c_func
(paren
id|pid_t
id|pid
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pid
)paren
(brace
r_return
id|current-&gt;pgrp
suffix:semicolon
)brace
r_else
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|p
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|retval
op_assign
id|p-&gt;pgrp
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
)brace
DECL|function|sys_getpgrp
id|asmlinkage
r_int
id|sys_getpgrp
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* SMP - assuming writes are word atomic this is fine */
r_return
id|current-&gt;pgrp
suffix:semicolon
)brace
DECL|function|sys_getsid
id|asmlinkage
r_int
id|sys_getsid
c_func
(paren
id|pid_t
id|pid
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pid
)paren
(brace
r_return
id|current-&gt;session
suffix:semicolon
)brace
r_else
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|p
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|retval
op_assign
id|p-&gt;session
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
)brace
DECL|function|sys_setsid
id|asmlinkage
r_int
id|sys_setsid
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;pgrp
op_eq
id|current-&gt;pid
)paren
r_goto
id|out
suffix:semicolon
)brace
id|current-&gt;leader
op_assign
l_int|1
suffix:semicolon
id|current-&gt;session
op_assign
id|current-&gt;pgrp
op_assign
id|current-&gt;pid
suffix:semicolon
id|current-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|current-&gt;tty_old_pgrp
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|current-&gt;pgrp
suffix:semicolon
id|out
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Supplementary group IDs&n; */
DECL|function|sys_getgroups
id|asmlinkage
r_int
id|sys_getgroups
c_func
(paren
r_int
id|gidsetsize
comma
id|gid_t
op_star
id|grouplist
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *&t;SMP: Nobody else can change our grouplist. Thus we are&n;&t; *&t;safe.&n;&t; */
r_if
c_cond
(paren
id|gidsetsize
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|i
op_assign
id|current-&gt;ngroups
suffix:semicolon
r_if
c_cond
(paren
id|gidsetsize
)paren
(brace
r_if
c_cond
(paren
id|i
OG
id|gidsetsize
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|grouplist
comma
id|current-&gt;groups
comma
r_sizeof
(paren
id|gid_t
)paren
op_star
id|i
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;SMP: Our groups are not shared. We can copy to/from them safely&n; *&t;without another task interfering.&n; */
DECL|function|sys_setgroups
id|asmlinkage
r_int
id|sys_setgroups
c_func
(paren
r_int
id|gidsetsize
comma
id|gid_t
op_star
id|grouplist
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SETGID
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|gidsetsize
OG
id|NGROUPS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|current-&gt;groups
comma
id|grouplist
comma
id|gidsetsize
op_star
r_sizeof
(paren
id|gid_t
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|current-&gt;ngroups
op_assign
id|gidsetsize
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|supplemental_group_member
r_static
r_int
id|supplemental_group_member
c_func
(paren
id|gid_t
id|grp
)paren
(brace
r_int
id|i
op_assign
id|current-&gt;ngroups
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|gid_t
op_star
id|groups
op_assign
id|current-&gt;groups
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_star
id|groups
op_eq
id|grp
)paren
r_return
l_int|1
suffix:semicolon
id|groups
op_increment
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Check whether we&squot;re fsgid/egid or in the supplemental group..&n; */
DECL|function|in_group_p
r_int
id|in_group_p
c_func
(paren
id|gid_t
id|grp
)paren
(brace
r_int
id|retval
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|grp
op_ne
id|current-&gt;fsgid
)paren
id|retval
op_assign
id|supplemental_group_member
c_func
(paren
id|grp
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|in_egroup_p
r_int
id|in_egroup_p
c_func
(paren
id|gid_t
id|grp
)paren
(brace
r_int
id|retval
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|grp
op_ne
id|current-&gt;egid
)paren
id|retval
op_assign
id|supplemental_group_member
c_func
(paren
id|grp
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|uts_sem
id|DECLARE_RWSEM
c_func
(paren
id|uts_sem
)paren
suffix:semicolon
DECL|function|sys_newuname
id|asmlinkage
r_int
id|sys_newuname
c_func
(paren
r_struct
id|new_utsname
op_star
id|name
)paren
(brace
r_int
id|errno
op_assign
l_int|0
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|uts_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|name
comma
op_amp
id|system_utsname
comma
r_sizeof
op_star
id|name
)paren
)paren
id|errno
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|uts_sem
)paren
suffix:semicolon
r_return
id|errno
suffix:semicolon
)brace
DECL|function|sys_sethostname
id|asmlinkage
r_int
id|sys_sethostname
c_func
(paren
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
r_int
id|errno
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|len
template_param
id|__NEW_UTS_LEN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|uts_sem
)paren
suffix:semicolon
id|errno
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_from_user
c_func
(paren
id|system_utsname.nodename
comma
id|name
comma
id|len
)paren
)paren
(brace
id|system_utsname.nodename
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|errno
op_assign
l_int|0
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|uts_sem
)paren
suffix:semicolon
r_return
id|errno
suffix:semicolon
)brace
DECL|function|sys_gethostname
id|asmlinkage
r_int
id|sys_gethostname
c_func
(paren
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
r_int
id|i
comma
id|errno
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|down_read
c_func
(paren
op_amp
id|uts_sem
)paren
suffix:semicolon
id|i
op_assign
l_int|1
op_plus
id|strlen
c_func
(paren
id|system_utsname.nodename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
id|len
)paren
id|i
op_assign
id|len
suffix:semicolon
id|errno
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|name
comma
id|system_utsname.nodename
comma
id|i
)paren
)paren
id|errno
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|up_read
c_func
(paren
op_amp
id|uts_sem
)paren
suffix:semicolon
r_return
id|errno
suffix:semicolon
)brace
multiline_comment|/*&n; * Only setdomainname; getdomainname can be implemented by calling&n; * uname()&n; */
DECL|function|sys_setdomainname
id|asmlinkage
r_int
id|sys_setdomainname
c_func
(paren
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
r_int
id|errno
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|len
template_param
id|__NEW_UTS_LEN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|down_write
c_func
(paren
op_amp
id|uts_sem
)paren
suffix:semicolon
id|errno
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy_from_user
c_func
(paren
id|system_utsname.domainname
comma
id|name
comma
id|len
)paren
)paren
(brace
id|errno
op_assign
l_int|0
suffix:semicolon
id|system_utsname.domainname
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|up_write
c_func
(paren
op_amp
id|uts_sem
)paren
suffix:semicolon
r_return
id|errno
suffix:semicolon
)brace
DECL|function|sys_getrlimit
id|asmlinkage
r_int
id|sys_getrlimit
c_func
(paren
r_int
r_int
id|resource
comma
r_struct
id|rlimit
op_star
id|rlim
)paren
(brace
r_if
c_cond
(paren
id|resource
op_ge
id|RLIM_NLIMITS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
r_return
id|copy_to_user
c_func
(paren
id|rlim
comma
id|current-&gt;rlim
op_plus
id|resource
comma
r_sizeof
(paren
op_star
id|rlim
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#if !defined(__ia64__) &amp;&amp; !defined(__s390__)
multiline_comment|/*&n; *&t;Back compatibility for getrlimit. Needed for some apps.&n; */
DECL|function|sys_old_getrlimit
id|asmlinkage
r_int
id|sys_old_getrlimit
c_func
(paren
r_int
r_int
id|resource
comma
r_struct
id|rlimit
op_star
id|rlim
)paren
(brace
r_struct
id|rlimit
id|x
suffix:semicolon
r_if
c_cond
(paren
id|resource
op_ge
id|RLIM_NLIMITS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|x
comma
id|current-&gt;rlim
op_plus
id|resource
comma
r_sizeof
(paren
op_star
id|rlim
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x.rlim_cur
OG
l_int|0x7FFFFFFF
)paren
(brace
id|x.rlim_cur
op_assign
l_int|0x7FFFFFFF
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x.rlim_max
OG
l_int|0x7FFFFFFF
)paren
(brace
id|x.rlim_max
op_assign
l_int|0x7FFFFFFF
suffix:semicolon
)brace
r_return
id|copy_to_user
c_func
(paren
id|rlim
comma
op_amp
id|x
comma
r_sizeof
(paren
id|x
)paren
)paren
ques
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|sys_setrlimit
id|asmlinkage
r_int
id|sys_setrlimit
c_func
(paren
r_int
r_int
id|resource
comma
r_struct
id|rlimit
op_star
id|rlim
)paren
(brace
r_struct
id|rlimit
id|new_rlim
comma
op_star
id|old_rlim
suffix:semicolon
r_if
c_cond
(paren
id|resource
op_ge
id|RLIM_NLIMITS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|new_rlim
comma
id|rlim
comma
r_sizeof
(paren
op_star
id|rlim
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_rlim.rlim_cur
OL
l_int|0
op_logical_or
id|new_rlim.rlim_max
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|old_rlim
op_assign
id|current-&gt;rlim
op_plus
id|resource
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|new_rlim.rlim_cur
OG
id|old_rlim-&gt;rlim_max
)paren
op_logical_or
(paren
id|new_rlim.rlim_max
OG
id|old_rlim-&gt;rlim_max
)paren
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RESOURCE
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|resource
op_eq
id|RLIMIT_NOFILE
)paren
(brace
r_if
c_cond
(paren
id|new_rlim.rlim_cur
OG
id|NR_OPEN
op_logical_or
id|new_rlim.rlim_max
OG
id|NR_OPEN
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
op_star
id|old_rlim
op_assign
id|new_rlim
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * It would make sense to put struct rusage in the task_struct,&n; * except that would make the task_struct be *really big*.  After&n; * task_struct gets moved into malloc&squot;ed memory, it would&n; * make sense to do this.  It will make moving the rest of the information&n; * a lot simpler!  (Which we&squot;re not doing right now because we&squot;re not&n; * measuring them yet).&n; *&n; * This is SMP safe.  Either we are called from sys_getrusage on ourselves&n; * below (we know we aren&squot;t going to exit/disappear and only we change our&n; * rusage counters), or we are called from wait4() on a process which is&n; * either stopped or zombied.  In the zombied case the task won&squot;t get&n; * reaped till shortly after the call to getrusage(), in both cases the&n; * task being examined is in a frozen state so the counters won&squot;t change.&n; *&n; * FIXME! Get the fault counts properly!&n; */
DECL|function|getrusage
r_int
id|getrusage
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
id|who
comma
r_struct
id|rusage
op_star
id|ru
)paren
(brace
r_struct
id|rusage
id|r
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|r
comma
l_int|0
comma
r_sizeof
(paren
id|r
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|who
)paren
(brace
r_case
id|RUSAGE_SELF
suffix:colon
id|r.ru_utime.tv_sec
op_assign
id|CT_TO_SECS
c_func
(paren
id|p-&gt;times.tms_utime
)paren
suffix:semicolon
id|r.ru_utime.tv_usec
op_assign
id|CT_TO_USECS
c_func
(paren
id|p-&gt;times.tms_utime
)paren
suffix:semicolon
id|r.ru_stime.tv_sec
op_assign
id|CT_TO_SECS
c_func
(paren
id|p-&gt;times.tms_stime
)paren
suffix:semicolon
id|r.ru_stime.tv_usec
op_assign
id|CT_TO_USECS
c_func
(paren
id|p-&gt;times.tms_stime
)paren
suffix:semicolon
id|r.ru_minflt
op_assign
id|p-&gt;min_flt
suffix:semicolon
id|r.ru_majflt
op_assign
id|p-&gt;maj_flt
suffix:semicolon
id|r.ru_nswap
op_assign
id|p-&gt;nswap
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RUSAGE_CHILDREN
suffix:colon
id|r.ru_utime.tv_sec
op_assign
id|CT_TO_SECS
c_func
(paren
id|p-&gt;times.tms_cutime
)paren
suffix:semicolon
id|r.ru_utime.tv_usec
op_assign
id|CT_TO_USECS
c_func
(paren
id|p-&gt;times.tms_cutime
)paren
suffix:semicolon
id|r.ru_stime.tv_sec
op_assign
id|CT_TO_SECS
c_func
(paren
id|p-&gt;times.tms_cstime
)paren
suffix:semicolon
id|r.ru_stime.tv_usec
op_assign
id|CT_TO_USECS
c_func
(paren
id|p-&gt;times.tms_cstime
)paren
suffix:semicolon
id|r.ru_minflt
op_assign
id|p-&gt;cmin_flt
suffix:semicolon
id|r.ru_majflt
op_assign
id|p-&gt;cmaj_flt
suffix:semicolon
id|r.ru_nswap
op_assign
id|p-&gt;cnswap
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|r.ru_utime.tv_sec
op_assign
id|CT_TO_SECS
c_func
(paren
id|p-&gt;times.tms_utime
op_plus
id|p-&gt;times.tms_cutime
)paren
suffix:semicolon
id|r.ru_utime.tv_usec
op_assign
id|CT_TO_USECS
c_func
(paren
id|p-&gt;times.tms_utime
op_plus
id|p-&gt;times.tms_cutime
)paren
suffix:semicolon
id|r.ru_stime.tv_sec
op_assign
id|CT_TO_SECS
c_func
(paren
id|p-&gt;times.tms_stime
op_plus
id|p-&gt;times.tms_cstime
)paren
suffix:semicolon
id|r.ru_stime.tv_usec
op_assign
id|CT_TO_USECS
c_func
(paren
id|p-&gt;times.tms_stime
op_plus
id|p-&gt;times.tms_cstime
)paren
suffix:semicolon
id|r.ru_minflt
op_assign
id|p-&gt;min_flt
op_plus
id|p-&gt;cmin_flt
suffix:semicolon
id|r.ru_majflt
op_assign
id|p-&gt;maj_flt
op_plus
id|p-&gt;cmaj_flt
suffix:semicolon
id|r.ru_nswap
op_assign
id|p-&gt;nswap
op_plus
id|p-&gt;cnswap
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|copy_to_user
c_func
(paren
id|ru
comma
op_amp
id|r
comma
r_sizeof
(paren
id|r
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|sys_getrusage
id|asmlinkage
r_int
id|sys_getrusage
c_func
(paren
r_int
id|who
comma
r_struct
id|rusage
op_star
id|ru
)paren
(brace
r_if
c_cond
(paren
id|who
op_ne
id|RUSAGE_SELF
op_logical_and
id|who
op_ne
id|RUSAGE_CHILDREN
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|getrusage
c_func
(paren
id|current
comma
id|who
comma
id|ru
)paren
suffix:semicolon
)brace
DECL|function|sys_umask
id|asmlinkage
r_int
id|sys_umask
c_func
(paren
r_int
id|mask
)paren
(brace
id|mask
op_assign
id|xchg
c_func
(paren
op_amp
id|current-&gt;fs-&gt;umask
comma
id|mask
op_amp
id|S_IRWXUGO
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
DECL|function|sys_prctl
id|asmlinkage
r_int
id|sys_prctl
c_func
(paren
r_int
id|option
comma
r_int
r_int
id|arg2
comma
r_int
r_int
id|arg3
comma
r_int
r_int
id|arg4
comma
r_int
r_int
id|arg5
)paren
(brace
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|sig
suffix:semicolon
r_switch
c_cond
(paren
id|option
)paren
(brace
r_case
id|PR_SET_PDEATHSIG
suffix:colon
id|sig
op_assign
id|arg2
suffix:semicolon
r_if
c_cond
(paren
id|sig
OG
id|_NSIG
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|current-&gt;pdeath_signal
op_assign
id|sig
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_GET_PDEATHSIG
suffix:colon
id|error
op_assign
id|put_user
c_func
(paren
id|current-&gt;pdeath_signal
comma
(paren
r_int
op_star
)paren
id|arg2
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_GET_DUMPABLE
suffix:colon
r_if
c_cond
(paren
id|current-&gt;dumpable
)paren
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_SET_DUMPABLE
suffix:colon
r_if
c_cond
(paren
id|arg2
op_ne
l_int|0
op_logical_and
id|arg2
op_ne
l_int|1
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|current-&gt;dumpable
op_assign
id|arg2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_SET_UNALIGN
suffix:colon
macro_line|#ifdef SET_UNALIGN_CTL
id|error
op_assign
id|SET_UNALIGN_CTL
c_func
(paren
id|current
comma
id|arg2
)paren
suffix:semicolon
macro_line|#else
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|PR_GET_UNALIGN
suffix:colon
macro_line|#ifdef GET_UNALIGN_CTL
id|error
op_assign
id|GET_UNALIGN_CTL
c_func
(paren
id|current
comma
id|arg2
)paren
suffix:semicolon
macro_line|#else
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|PR_GET_KEEPCAPS
suffix:colon
r_if
c_cond
(paren
id|current-&gt;keep_capabilities
)paren
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PR_SET_KEEPCAPS
suffix:colon
r_if
c_cond
(paren
id|arg2
op_ne
l_int|0
op_logical_and
id|arg2
op_ne
l_int|1
)paren
(brace
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|current-&gt;keep_capabilities
op_assign
id|arg2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
DECL|variable|notifier_chain_register
id|EXPORT_SYMBOL
c_func
(paren
id|notifier_chain_register
)paren
suffix:semicolon
DECL|variable|notifier_chain_unregister
id|EXPORT_SYMBOL
c_func
(paren
id|notifier_chain_unregister
)paren
suffix:semicolon
DECL|variable|notifier_call_chain
id|EXPORT_SYMBOL
c_func
(paren
id|notifier_call_chain
)paren
suffix:semicolon
DECL|variable|register_reboot_notifier
id|EXPORT_SYMBOL
c_func
(paren
id|register_reboot_notifier
)paren
suffix:semicolon
DECL|variable|unregister_reboot_notifier
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_reboot_notifier
)paren
suffix:semicolon
DECL|variable|in_group_p
id|EXPORT_SYMBOL
c_func
(paren
id|in_group_p
)paren
suffix:semicolon
DECL|variable|in_egroup_p
id|EXPORT_SYMBOL
c_func
(paren
id|in_egroup_p
)paren
suffix:semicolon
eof
