multiline_comment|/*&n; *  linux/kernel/sys.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/times.h&gt;
macro_line|#include &lt;linux/utsname.h&gt;
macro_line|#include &lt;linux/param.h&gt;
macro_line|#include &lt;linux/resource.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/acct.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#if defined(CONFIG_APM) &amp;&amp; defined(CONFIG_APM_POWER_OFF)
macro_line|#include &lt;linux/apm_bios.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/notifier.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
multiline_comment|/*&n; * this indicates whether you can reboot with ctrl-alt-del: the default is yes&n; */
DECL|variable|C_A_D
r_int
id|C_A_D
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n; *&t;List of functions to call at shutdown. This is used to stop any&n; *&t;idling DMA operations and the like. &n; */
DECL|variable|boot_notifier_list
r_struct
id|notifier_block
op_star
id|boot_notifier_list
op_assign
l_int|NULL
suffix:semicolon
r_extern
r_void
id|adjust_clock
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|sys_ni_syscall
id|asmlinkage
r_int
id|sys_ni_syscall
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|proc_sel
r_static
r_int
id|proc_sel
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
id|which
comma
r_int
id|who
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;pid
)paren
(brace
r_switch
c_cond
(paren
id|which
)paren
(brace
r_case
id|PRIO_PROCESS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|who
op_logical_and
id|p
op_eq
id|current
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|p-&gt;pid
op_eq
id|who
suffix:semicolon
r_case
id|PRIO_PGRP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|who
)paren
id|who
op_assign
id|current-&gt;pgrp
suffix:semicolon
r_return
id|p-&gt;pgrp
op_eq
id|who
suffix:semicolon
r_case
id|PRIO_USER
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|who
)paren
id|who
op_assign
id|current-&gt;uid
suffix:semicolon
r_return
id|p-&gt;uid
op_eq
id|who
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_setpriority
id|asmlinkage
r_int
id|sys_setpriority
c_func
(paren
r_int
id|which
comma
r_int
id|who
comma
r_int
id|niceval
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|error
op_assign
id|EINVAL
suffix:semicolon
r_int
r_int
id|priority
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|which
OG
l_int|2
op_logical_or
id|which
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/* normalize: avoid signed division (rounding problems) */
id|error
op_assign
id|ESRCH
suffix:semicolon
id|priority
op_assign
id|niceval
suffix:semicolon
r_if
c_cond
(paren
id|niceval
OL
l_int|0
)paren
id|priority
op_assign
op_minus
id|niceval
suffix:semicolon
r_if
c_cond
(paren
id|priority
OG
l_int|20
)paren
id|priority
op_assign
l_int|20
suffix:semicolon
id|priority
op_assign
(paren
id|priority
op_star
id|DEF_PRIORITY
op_plus
l_int|10
)paren
op_div
l_int|20
op_plus
id|DEF_PRIORITY
suffix:semicolon
r_if
c_cond
(paren
id|niceval
op_ge
l_int|0
)paren
(brace
id|priority
op_assign
l_int|2
op_star
id|DEF_PRIORITY
op_minus
id|priority
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priority
)paren
id|priority
op_assign
l_int|1
suffix:semicolon
)brace
id|for_each_task
c_func
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|proc_sel
c_func
(paren
id|p
comma
id|which
comma
id|who
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;uid
op_ne
id|current-&gt;euid
op_logical_and
id|p-&gt;uid
op_ne
id|current-&gt;uid
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
id|error
op_assign
id|EPERM
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|error
op_eq
id|ESRCH
)paren
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|priority
OG
id|p-&gt;priority
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
id|error
op_assign
id|EACCES
suffix:semicolon
r_else
id|p-&gt;priority
op_assign
id|priority
suffix:semicolon
)brace
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Ugh. To avoid negative return values, &quot;getpriority()&quot; will&n; * not return the normal nice-value, but a value that has been&n; * offset by 20 (ie it returns 0..40 instead of -20..20)&n; */
DECL|function|sys_getpriority
id|asmlinkage
r_int
id|sys_getpriority
c_func
(paren
r_int
id|which
comma
r_int
id|who
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|max_prio
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|which
OG
l_int|2
op_logical_or
id|which
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|for_each_task
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|proc_sel
c_func
(paren
id|p
comma
id|which
comma
id|who
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;priority
OG
id|max_prio
)paren
id|max_prio
op_assign
id|p-&gt;priority
suffix:semicolon
)brace
multiline_comment|/* scale the priority from timeslice to 0..40 */
r_if
c_cond
(paren
id|max_prio
OG
l_int|0
)paren
id|max_prio
op_assign
(paren
id|max_prio
op_star
l_int|20
op_plus
id|DEF_PRIORITY
op_div
l_int|2
)paren
op_div
id|DEF_PRIORITY
suffix:semicolon
id|ret
op_assign
id|max_prio
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifndef __alpha__
multiline_comment|/*&n; * Why do these exist?  Binary compatibility with some other standard?&n; * If so, maybe they should be moved into the appropriate arch&n; * directory.&n; */
DECL|function|sys_profil
id|asmlinkage
r_int
id|sys_profil
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|sys_ftime
id|asmlinkage
r_int
id|sys_ftime
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|sys_break
id|asmlinkage
r_int
id|sys_break
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|sys_stty
id|asmlinkage
r_int
id|sys_stty
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|sys_gtty
id|asmlinkage
r_int
id|sys_gtty
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|sys_prof
id|asmlinkage
r_int
id|sys_prof
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
macro_line|#endif
r_extern
r_void
id|hard_reset_now
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef __sparc__
r_extern
r_void
id|halt_now
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
r_extern
id|asmlinkage
r_int
id|sys_kill
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
multiline_comment|/*&n; * Reboot system call: for obvious reasons only root may call it,&n; * and even root needs to set up some magic numbers in the registers&n; * so that some mistake won&squot;t make this reboot the whole machine.&n; * You can also set the meaning of the ctrl-alt-del-key here.&n; *&n; * reboot doesn&squot;t sync: do that yourself before calling this.&n; */
DECL|function|sys_reboot
id|asmlinkage
r_int
id|sys_reboot
c_func
(paren
r_int
id|magic
comma
r_int
id|magic_too
comma
r_int
id|flag
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|magic
op_ne
l_int|0xfee1dead
op_logical_or
(paren
id|magic_too
op_ne
l_int|672274793
op_logical_and
id|magic_too
op_ne
l_int|85072278
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_eq
l_int|0x01234567
)paren
(brace
multiline_comment|/* SMP: We need to lock during the shutdown still */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|notifier_call_chain
c_func
(paren
op_amp
id|boot_notifier_list
comma
id|SYS_DOWN
comma
l_int|NULL
)paren
suffix:semicolon
id|hard_reset_now
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flag
op_eq
l_int|0x89ABCDEF
)paren
id|C_A_D
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
id|C_A_D
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|flag
op_eq
l_int|0xCDEF0123
)paren
(brace
multiline_comment|/* SMP: We need to lock during the shutdown still */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_EMERG
l_string|&quot;System halted&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef __sparc__
id|halt_now
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif&t;
id|sys_kill
c_func
(paren
op_minus
l_int|1
comma
id|SIGKILL
)paren
suffix:semicolon
macro_line|#if defined(CONFIG_APM) &amp;&amp; defined(CONFIG_APM_POWER_OFF)
id|apm_set_power_state
c_func
(paren
id|APM_STATE_OFF
)paren
suffix:semicolon
macro_line|#endif
id|notifier_call_chain
c_func
(paren
op_amp
id|boot_notifier_list
comma
id|SYS_HALT
comma
l_int|NULL
)paren
suffix:semicolon
id|do_exit
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function gets called by ctrl-alt-del - ie the keyboard interrupt.&n; * As it&squot;s called within an interrupt, it may NOT sync: the only choice&n; * is whether to reboot at once, or just ignore the ctrl-alt-del.&n; */
DECL|function|ctrl_alt_del
r_void
id|ctrl_alt_del
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|C_A_D
)paren
(brace
id|notifier_call_chain
c_func
(paren
op_amp
id|boot_notifier_list
comma
id|SYS_DOWN
comma
l_int|NULL
)paren
suffix:semicolon
id|hard_reset_now
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|kill_proc
c_func
(paren
l_int|1
comma
id|SIGINT
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Unprivileged users may change the real gid to the effective gid&n; * or vice versa.  (BSD-style)&n; *&n; * If you set the real gid at all, or set the effective gid to a value not&n; * equal to the real gid, then the saved gid is set to the new effective gid.&n; *&n; * This makes it possible for a setgid program to completely drop its&n; * privileges, which is often a useful assertion to make when you are doing&n; * a security audit over a program.&n; *&n; * The general idea is that a program which uses just setregid() will be&n; * 100% compatible with BSD.  A program which uses just setgid() will be&n; * 100% compatible with POSIX w/ Saved ID&squot;s. &n; */
DECL|function|sys_setregid
id|asmlinkage
r_int
id|sys_setregid
c_func
(paren
id|gid_t
id|rgid
comma
id|gid_t
id|egid
)paren
(brace
r_int
id|old_rgid
op_assign
id|current-&gt;gid
suffix:semicolon
r_int
id|old_egid
op_assign
id|current-&gt;egid
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rgid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|old_rgid
op_eq
id|rgid
)paren
op_logical_or
(paren
id|current-&gt;egid
op_eq
id|rgid
)paren
op_logical_or
id|suser
c_func
(paren
)paren
)paren
id|current-&gt;gid
op_assign
id|rgid
suffix:semicolon
r_else
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|egid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|old_rgid
op_eq
id|egid
)paren
op_logical_or
(paren
id|current-&gt;egid
op_eq
id|egid
)paren
op_logical_or
(paren
id|current-&gt;sgid
op_eq
id|egid
)paren
op_logical_or
id|suser
c_func
(paren
)paren
)paren
id|current-&gt;fsgid
op_assign
id|current-&gt;egid
op_assign
id|egid
suffix:semicolon
r_else
(brace
id|current-&gt;gid
op_assign
id|old_rgid
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rgid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
op_logical_or
(paren
id|egid
op_ne
(paren
id|gid_t
)paren
op_minus
l_int|1
op_logical_and
id|egid
op_ne
id|old_rgid
)paren
)paren
id|current-&gt;sgid
op_assign
id|current-&gt;egid
suffix:semicolon
id|current-&gt;fsgid
op_assign
id|current-&gt;egid
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;egid
op_ne
id|old_egid
)paren
id|current-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * setgid() is implemented like SysV w/ SAVED_IDS &n; */
DECL|function|sys_setgid
id|asmlinkage
r_int
id|sys_setgid
c_func
(paren
id|gid_t
id|gid
)paren
(brace
r_int
id|old_egid
op_assign
id|current-&gt;egid
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
id|current-&gt;gid
op_assign
id|current-&gt;egid
op_assign
id|current-&gt;sgid
op_assign
id|current-&gt;fsgid
op_assign
id|gid
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|gid
op_eq
id|current-&gt;gid
)paren
op_logical_or
(paren
id|gid
op_eq
id|current-&gt;sgid
)paren
)paren
id|current-&gt;egid
op_assign
id|current-&gt;fsgid
op_assign
id|gid
suffix:semicolon
r_else
r_goto
id|out
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;egid
op_ne
id|old_egid
)paren
id|current-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|variable|acct_active
r_static
r_char
id|acct_active
op_assign
l_int|0
suffix:semicolon
DECL|variable|acct_file
r_static
r_struct
id|file
id|acct_file
suffix:semicolon
DECL|function|acct_process
r_int
id|acct_process
c_func
(paren
r_int
id|exitcode
)paren
(brace
r_struct
id|acct
id|ac
suffix:semicolon
r_int
r_int
id|fs
suffix:semicolon
r_if
c_cond
(paren
id|acct_active
)paren
(brace
id|strncpy
c_func
(paren
id|ac.ac_comm
comma
id|current-&gt;comm
comma
id|ACCT_COMM
)paren
suffix:semicolon
id|ac.ac_comm
(braket
id|ACCT_COMM
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|ac.ac_utime
op_assign
id|current-&gt;utime
suffix:semicolon
id|ac.ac_stime
op_assign
id|current-&gt;stime
suffix:semicolon
id|ac.ac_btime
op_assign
id|CT_TO_SECS
c_func
(paren
id|current-&gt;start_time
)paren
op_plus
(paren
id|xtime.tv_sec
op_minus
(paren
id|jiffies
op_div
id|HZ
)paren
)paren
suffix:semicolon
id|ac.ac_etime
op_assign
id|CURRENT_TIME
op_minus
id|ac.ac_btime
suffix:semicolon
id|ac.ac_uid
op_assign
id|current-&gt;uid
suffix:semicolon
id|ac.ac_gid
op_assign
id|current-&gt;gid
suffix:semicolon
id|ac.ac_tty
op_assign
(paren
id|current
)paren
op_member_access_from_pointer
id|tty
op_eq
l_int|NULL
ques
c_cond
op_minus
l_int|1
suffix:colon
id|kdev_t_to_nr
c_func
(paren
id|current-&gt;tty-&gt;device
)paren
suffix:semicolon
id|ac.ac_flag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;flags
op_amp
id|PF_FORKNOEXEC
)paren
id|ac.ac_flag
op_or_assign
id|AFORK
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;flags
op_amp
id|PF_SUPERPRIV
)paren
id|ac.ac_flag
op_or_assign
id|ASU
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;flags
op_amp
id|PF_DUMPCORE
)paren
id|ac.ac_flag
op_or_assign
id|ACORE
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;flags
op_amp
id|PF_SIGNALED
)paren
id|ac.ac_flag
op_or_assign
id|AXSIG
suffix:semicolon
id|ac.ac_minflt
op_assign
id|current-&gt;min_flt
suffix:semicolon
id|ac.ac_majflt
op_assign
id|current-&gt;maj_flt
suffix:semicolon
id|ac.ac_exitcode
op_assign
id|exitcode
suffix:semicolon
multiline_comment|/* Kernel segment override */
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|acct_file.f_op
op_member_access_from_pointer
id|write
c_func
(paren
id|acct_file.f_inode
comma
op_amp
id|acct_file
comma
(paren
r_char
op_star
)paren
op_amp
id|ac
comma
r_sizeof
(paren
r_struct
id|acct
)paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_acct
id|asmlinkage
r_int
id|sys_acct
c_func
(paren
r_const
r_char
op_star
id|name
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
(paren
r_struct
id|inode
op_star
)paren
l_int|0
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
r_int
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|name
op_eq
(paren
r_char
op_star
)paren
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|acct_active
)paren
(brace
r_if
c_cond
(paren
id|acct_file.f_op-&gt;release
)paren
id|acct_file.f_op
op_member_access_from_pointer
id|release
c_func
(paren
id|acct_file.f_inode
comma
op_amp
id|acct_file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acct_file.f_inode
op_ne
(paren
r_struct
id|inode
op_star
)paren
l_int|0
)paren
id|iput
c_func
(paren
id|acct_file.f_inode
)paren
suffix:semicolon
id|acct_active
op_assign
l_int|0
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acct_active
)paren
(brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|getname
c_func
(paren
id|name
comma
op_amp
id|tmp
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|open_namei
c_func
(paren
id|tmp
comma
id|O_RDWR
comma
l_int|0600
comma
op_amp
id|inode
comma
l_int|0
)paren
suffix:semicolon
id|putname
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|S_ISREG
c_func
(paren
id|inode-&gt;i_mode
)paren
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_op
op_logical_or
op_logical_neg
id|inode-&gt;i_op-&gt;default_file_ops
op_logical_or
op_logical_neg
id|inode-&gt;i_op-&gt;default_file_ops-&gt;write
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|acct_file.f_mode
op_assign
l_int|3
suffix:semicolon
id|acct_file.f_flags
op_assign
l_int|0
suffix:semicolon
id|acct_file.f_count
op_assign
l_int|1
suffix:semicolon
id|acct_file.f_inode
op_assign
id|inode
suffix:semicolon
id|acct_file.f_pos
op_assign
id|inode-&gt;i_size
suffix:semicolon
id|acct_file.f_reada
op_assign
l_int|0
suffix:semicolon
id|acct_file.f_op
op_assign
id|inode-&gt;i_op-&gt;default_file_ops
suffix:semicolon
r_if
c_cond
(paren
id|acct_file.f_op-&gt;open
)paren
r_if
c_cond
(paren
id|acct_file.f_op
op_member_access_from_pointer
id|open
c_func
(paren
id|acct_file.f_inode
comma
op_amp
id|acct_file
)paren
)paren
(brace
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|acct_active
op_assign
l_int|1
suffix:semicolon
id|error
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
macro_line|#ifndef __alpha__
multiline_comment|/*&n; * Why do these exist?  Binary compatibility with some other standard?&n; * If so, maybe they should be moved into the appropriate arch&n; * directory.&n; */
DECL|function|sys_phys
id|asmlinkage
r_int
id|sys_phys
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|sys_lock
id|asmlinkage
r_int
id|sys_lock
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|sys_mpx
id|asmlinkage
r_int
id|sys_mpx
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|sys_ulimit
id|asmlinkage
r_int
id|sys_ulimit
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
DECL|function|sys_old_syscall
id|asmlinkage
r_int
id|sys_old_syscall
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Unprivileged users may change the real uid to the effective uid&n; * or vice versa.  (BSD-style)&n; *&n; * If you set the real uid at all, or set the effective uid to a value not&n; * equal to the real uid, then the saved uid is set to the new effective uid.&n; *&n; * This makes it possible for a setuid program to completely drop its&n; * privileges, which is often a useful assertion to make when you are doing&n; * a security audit over a program.&n; *&n; * The general idea is that a program which uses just setreuid() will be&n; * 100% compatible with BSD.  A program which uses just setuid() will be&n; * 100% compatible with POSIX w/ Saved ID&squot;s. &n; */
DECL|function|sys_setreuid
id|asmlinkage
r_int
id|sys_setreuid
c_func
(paren
id|uid_t
id|ruid
comma
id|uid_t
id|euid
)paren
(brace
r_int
id|old_ruid
suffix:semicolon
r_int
id|old_euid
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|old_ruid
op_assign
id|current-&gt;uid
suffix:semicolon
id|old_euid
op_assign
id|current-&gt;euid
suffix:semicolon
r_if
c_cond
(paren
id|ruid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|old_ruid
op_eq
id|ruid
)paren
op_logical_or
(paren
id|current-&gt;euid
op_eq
id|ruid
)paren
op_logical_or
id|suser
c_func
(paren
)paren
)paren
id|current-&gt;uid
op_assign
id|ruid
suffix:semicolon
r_else
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|euid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|old_ruid
op_eq
id|euid
)paren
op_logical_or
(paren
id|current-&gt;euid
op_eq
id|euid
)paren
op_logical_or
(paren
id|current-&gt;suid
op_eq
id|euid
)paren
op_logical_or
id|suser
c_func
(paren
)paren
)paren
id|current-&gt;fsuid
op_assign
id|current-&gt;euid
op_assign
id|euid
suffix:semicolon
r_else
(brace
id|current-&gt;uid
op_assign
id|old_ruid
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ruid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
op_logical_or
(paren
id|euid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
op_logical_and
id|euid
op_ne
id|old_ruid
)paren
)paren
id|current-&gt;suid
op_assign
id|current-&gt;euid
suffix:semicolon
id|current-&gt;fsuid
op_assign
id|current-&gt;euid
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;euid
op_ne
id|old_euid
)paren
id|current-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * setuid() is implemented like SysV w/ SAVED_IDS &n; * &n; * Note that SAVED_ID&squot;s is deficient in that a setuid root program&n; * like sendmail, for example, cannot set its uid to be a normal &n; * user and then switch back, because if you&squot;re root, setuid() sets&n; * the saved uid too.  If you don&squot;t like this, blame the bright people&n; * in the POSIX committee and/or USG.  Note that the BSD-style setreuid()&n; * will allow a root program to temporarily drop privileges and be able to&n; * regain them by swapping the real and effective uid.  &n; */
DECL|function|sys_setuid
id|asmlinkage
r_int
id|sys_setuid
c_func
(paren
id|uid_t
id|uid
)paren
(brace
r_int
id|old_euid
op_assign
id|current-&gt;euid
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
id|current-&gt;uid
op_assign
id|current-&gt;euid
op_assign
id|current-&gt;suid
op_assign
id|current-&gt;fsuid
op_assign
id|uid
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|uid
op_eq
id|current-&gt;uid
)paren
op_logical_or
(paren
id|uid
op_eq
id|current-&gt;suid
)paren
)paren
id|current-&gt;fsuid
op_assign
id|current-&gt;euid
op_assign
id|uid
suffix:semicolon
r_else
(brace
id|retval
op_assign
op_minus
id|EPERM
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current-&gt;euid
op_ne
id|old_euid
)paren
id|current-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * This function implementes a generic ability to update ruid, euid,&n; * and suid.  This allows you to implement the 4.4 compatible seteuid().&n; */
DECL|function|sys_setresuid
id|asmlinkage
r_int
id|sys_setresuid
c_func
(paren
id|uid_t
id|ruid
comma
id|uid_t
id|euid
comma
id|uid_t
id|suid
)paren
(brace
id|uid_t
id|old_ruid
comma
id|old_euid
comma
id|old_suid
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|old_ruid
op_assign
id|current-&gt;uid
suffix:semicolon
id|old_euid
op_assign
id|current-&gt;euid
suffix:semicolon
id|old_suid
op_assign
id|current-&gt;suid
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ruid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
op_logical_and
(paren
id|ruid
op_ne
id|current-&gt;uid
)paren
op_logical_and
(paren
id|ruid
op_ne
id|current-&gt;euid
)paren
op_logical_and
(paren
id|ruid
op_ne
id|current-&gt;suid
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
(paren
id|euid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
op_logical_and
(paren
id|euid
op_ne
id|current-&gt;uid
)paren
op_logical_and
(paren
id|euid
op_ne
id|current-&gt;euid
)paren
op_logical_and
(paren
id|euid
op_ne
id|current-&gt;suid
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
(paren
id|suid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
op_logical_and
(paren
id|suid
op_ne
id|current-&gt;uid
)paren
op_logical_and
(paren
id|suid
op_ne
id|current-&gt;euid
)paren
op_logical_and
(paren
id|suid
op_ne
id|current-&gt;suid
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|ruid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
id|current-&gt;uid
op_assign
id|ruid
suffix:semicolon
r_if
c_cond
(paren
id|euid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
id|current-&gt;euid
op_assign
id|euid
suffix:semicolon
r_if
c_cond
(paren
id|suid
op_ne
(paren
id|uid_t
)paren
op_minus
l_int|1
)paren
id|current-&gt;suid
op_assign
id|suid
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sys_getresuid
id|asmlinkage
r_int
id|sys_getresuid
c_func
(paren
id|uid_t
op_star
id|ruid
comma
id|uid_t
op_star
id|euid
comma
id|uid_t
op_star
id|suid
)paren
(brace
r_int
id|retval
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|retval
op_assign
id|put_user
c_func
(paren
id|current-&gt;uid
comma
id|ruid
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|retval
op_assign
id|put_user
c_func
(paren
id|current-&gt;euid
comma
id|euid
)paren
)paren
)paren
id|retval
op_assign
id|put_user
c_func
(paren
id|current-&gt;suid
comma
id|suid
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * &quot;setfsuid()&quot; sets the fsuid - the uid used for filesystem checks. This&n; * is used for &quot;access()&quot; and for the NFS daemon (letting nfsd stay at&n; * whatever uid it wants to). It normally shadows &quot;euid&quot;, except when&n; * explicitly set by setfsuid() or for access..&n; */
DECL|function|sys_setfsuid
id|asmlinkage
r_int
id|sys_setfsuid
c_func
(paren
id|uid_t
id|uid
)paren
(brace
r_int
id|old_fsuid
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|old_fsuid
op_assign
id|current-&gt;fsuid
suffix:semicolon
r_if
c_cond
(paren
id|uid
op_eq
id|current-&gt;uid
op_logical_or
id|uid
op_eq
id|current-&gt;euid
op_logical_or
id|uid
op_eq
id|current-&gt;suid
op_logical_or
id|uid
op_eq
id|current-&gt;fsuid
op_logical_or
id|suser
c_func
(paren
)paren
)paren
id|current-&gt;fsuid
op_assign
id|uid
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;fsuid
op_ne
id|old_fsuid
)paren
id|current-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|old_fsuid
suffix:semicolon
)brace
multiline_comment|/*&n; * Samma p&#xfffd; svenska..&n; */
DECL|function|sys_setfsgid
id|asmlinkage
r_int
id|sys_setfsgid
c_func
(paren
id|gid_t
id|gid
)paren
(brace
r_int
id|old_fsgid
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|old_fsgid
op_assign
id|current-&gt;fsgid
suffix:semicolon
r_if
c_cond
(paren
id|gid
op_eq
id|current-&gt;gid
op_logical_or
id|gid
op_eq
id|current-&gt;egid
op_logical_or
id|gid
op_eq
id|current-&gt;sgid
op_logical_or
id|gid
op_eq
id|current-&gt;fsgid
op_logical_or
id|suser
c_func
(paren
)paren
)paren
id|current-&gt;fsgid
op_assign
id|gid
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;fsgid
op_ne
id|old_fsgid
)paren
id|current-&gt;dumpable
op_assign
l_int|0
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|old_fsgid
suffix:semicolon
)brace
DECL|function|sys_times
id|asmlinkage
r_int
id|sys_times
c_func
(paren
r_struct
id|tms
op_star
id|tbuf
)paren
(brace
multiline_comment|/*&n;&t; *&t;In the SMP world we might just be unlucky and have one of&n;&t; *&t;the times increment as we use it. Since the value is an&n;&t; *&t;atomically safe type this is just fine. Conceptually its&n;&t; *&t;as if the syscall took an instant longer to occur.&n;&t; */
r_if
c_cond
(paren
id|tbuf
)paren
(brace
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|current-&gt;utime
comma
op_amp
id|tbuf-&gt;tms_utime
)paren
op_logical_or
id|put_user
c_func
(paren
id|current-&gt;stime
comma
op_amp
id|tbuf-&gt;tms_stime
)paren
op_logical_or
id|put_user
c_func
(paren
id|current-&gt;cutime
comma
op_amp
id|tbuf-&gt;tms_cutime
)paren
op_logical_or
id|put_user
c_func
(paren
id|current-&gt;cstime
comma
op_amp
id|tbuf-&gt;tms_cstime
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_return
id|jiffies
suffix:semicolon
)brace
multiline_comment|/*&n; * This needs some heavy checking ...&n; * I just haven&squot;t the stomach for it. I also don&squot;t fully&n; * understand sessions/pgrp etc. Let somebody who does explain it.&n; *&n; * OK, I think I have the protection semantics right.... this is really&n; * only important on a multi-user system anyway, to make sure one user&n; * can&squot;t send a signal to a process owned by another.  -TYT, 12/12/91&n; *&n; * Auch. Had to add the &squot;did_exec&squot; flag to conform completely to POSIX.&n; * LBT 04.03.94&n; */
DECL|function|sys_setpgid
id|asmlinkage
r_int
id|sys_setpgid
c_func
(paren
id|pid_t
id|pid
comma
id|pid_t
id|pgid
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pid
)paren
id|pid
op_assign
id|current-&gt;pid
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pgid
)paren
id|pgid
op_assign
id|pid
suffix:semicolon
r_if
c_cond
(paren
id|pgid
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;pid
op_eq
id|pid
)paren
r_goto
id|found_task
suffix:semicolon
)brace
id|err
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_goto
id|out
suffix:semicolon
id|found_task
suffix:colon
id|err
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;p_pptr
op_eq
id|current
op_logical_or
id|p-&gt;p_opptr
op_eq
id|current
)paren
(brace
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;session
op_ne
id|current-&gt;session
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;did_exec
)paren
r_goto
id|out
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|p
op_ne
id|current
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;leader
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|pgid
op_ne
id|pid
)paren
(brace
r_struct
id|task_struct
op_star
id|tmp
suffix:semicolon
id|for_each_task
(paren
id|tmp
)paren
(brace
r_if
c_cond
(paren
id|tmp-&gt;pgrp
op_eq
id|pgid
op_logical_and
id|tmp-&gt;session
op_eq
id|current-&gt;session
)paren
r_goto
id|ok_pgid
suffix:semicolon
)brace
r_goto
id|out
suffix:semicolon
)brace
id|ok_pgid
suffix:colon
id|p-&gt;pgrp
op_assign
id|pgid
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sys_getpgid
id|asmlinkage
r_int
id|sys_getpgid
c_func
(paren
id|pid_t
id|pid
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pid
)paren
(brace
id|ret
op_assign
id|current-&gt;pgrp
suffix:semicolon
)brace
r_else
(brace
id|for_each_task
c_func
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;pid
op_eq
id|pid
)paren
(brace
id|ret
op_assign
id|p-&gt;pgrp
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|ret
op_assign
op_minus
id|ESRCH
suffix:semicolon
)brace
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sys_getpgrp
id|asmlinkage
r_int
id|sys_getpgrp
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* SMP - assuming writes are word atomic this is fine */
r_return
id|current-&gt;pgrp
suffix:semicolon
)brace
DECL|function|sys_getsid
id|asmlinkage
r_int
id|sys_getsid
c_func
(paren
id|pid_t
id|pid
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* SMP: The &squot;self&squot; case requires no lock */
r_if
c_cond
(paren
op_logical_neg
id|pid
)paren
(brace
id|ret
op_assign
id|current-&gt;session
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Walking the process table needs locks */
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;pid
op_eq
id|pid
)paren
(brace
id|ret
op_assign
id|p-&gt;session
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|ret
op_assign
op_minus
id|ESRCH
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sys_setsid
id|asmlinkage
r_int
id|sys_setsid
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;pgrp
op_eq
id|current-&gt;pid
)paren
r_goto
id|out
suffix:semicolon
)brace
id|current-&gt;leader
op_assign
l_int|1
suffix:semicolon
id|current-&gt;session
op_assign
id|current-&gt;pgrp
op_assign
id|current-&gt;pid
suffix:semicolon
id|current-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|current-&gt;tty_old_pgrp
op_assign
l_int|0
suffix:semicolon
id|err
op_assign
id|current-&gt;pgrp
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Supplementary group ID&squot;s&n; */
DECL|function|sys_getgroups
id|asmlinkage
r_int
id|sys_getgroups
c_func
(paren
r_int
id|gidsetsize
comma
id|gid_t
op_star
id|grouplist
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; *&t;SMP: Nobody else can change our grouplist. Thus we are&n;&t; *&t;safe.&n;&t; */
r_if
c_cond
(paren
id|gidsetsize
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|i
op_assign
id|current-&gt;ngroups
suffix:semicolon
r_if
c_cond
(paren
id|gidsetsize
)paren
(brace
r_if
c_cond
(paren
id|i
OG
id|gidsetsize
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|grouplist
comma
id|current-&gt;groups
comma
r_sizeof
(paren
id|gid_t
)paren
op_star
id|i
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;SMP: Our groups are not shared. We can copy to/from them safely&n; *&t;without another task interfering.&n; */
DECL|function|sys_setgroups
id|asmlinkage
r_int
id|sys_setgroups
c_func
(paren
r_int
id|gidsetsize
comma
id|gid_t
op_star
id|grouplist
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|gidsetsize
OG
id|NGROUPS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|current-&gt;groups
comma
id|grouplist
comma
id|gidsetsize
op_star
r_sizeof
(paren
id|gid_t
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|current-&gt;ngroups
op_assign
id|gidsetsize
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|in_group_p
r_int
id|in_group_p
c_func
(paren
id|gid_t
id|grp
)paren
(brace
r_if
c_cond
(paren
id|grp
op_ne
id|current-&gt;fsgid
)paren
(brace
r_int
id|i
op_assign
id|current-&gt;ngroups
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|gid_t
op_star
id|groups
op_assign
id|current-&gt;groups
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_star
id|groups
op_eq
id|grp
)paren
r_goto
id|out
suffix:semicolon
id|groups
op_increment
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|out
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|sys_newuname
id|asmlinkage
r_int
id|sys_newuname
c_func
(paren
r_struct
id|new_utsname
op_star
id|name
)paren
(brace
r_int
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|name
comma
op_amp
id|system_utsname
comma
r_sizeof
op_star
id|name
)paren
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#ifndef __alpha__
multiline_comment|/*&n; * Move these to arch dependent dir since they are for&n; * backward compatibility only?&n; */
DECL|function|sys_uname
id|asmlinkage
r_int
id|sys_uname
c_func
(paren
r_struct
id|old_utsname
op_star
id|name
)paren
(brace
r_int
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
op_logical_and
op_logical_neg
id|copy_to_user
c_func
(paren
id|name
comma
op_amp
id|system_utsname
comma
r_sizeof
(paren
op_star
id|name
)paren
)paren
)paren
id|error
op_assign
l_int|0
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_olduname
id|asmlinkage
r_int
id|sys_olduname
c_func
(paren
r_struct
id|oldold_utsname
op_star
id|name
)paren
(brace
r_int
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|copy_to_user
c_func
(paren
op_amp
id|name-&gt;sysname
comma
op_amp
id|system_utsname.sysname
comma
id|__OLD_UTS_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|put_user
c_func
(paren
l_int|0
comma
id|name-&gt;sysname
op_plus
id|__OLD_UTS_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|copy_to_user
c_func
(paren
op_amp
id|name-&gt;nodename
comma
op_amp
id|system_utsname.nodename
comma
id|__OLD_UTS_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|put_user
c_func
(paren
l_int|0
comma
id|name-&gt;nodename
op_plus
id|__OLD_UTS_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|copy_to_user
c_func
(paren
op_amp
id|name-&gt;release
comma
op_amp
id|system_utsname.release
comma
id|__OLD_UTS_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|put_user
c_func
(paren
l_int|0
comma
id|name-&gt;release
op_plus
id|__OLD_UTS_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|copy_to_user
c_func
(paren
op_amp
id|name-&gt;version
comma
op_amp
id|system_utsname.version
comma
id|__OLD_UTS_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|put_user
c_func
(paren
l_int|0
comma
id|name-&gt;version
op_plus
id|__OLD_UTS_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|copy_to_user
c_func
(paren
op_amp
id|name-&gt;machine
comma
op_amp
id|system_utsname.machine
comma
id|__OLD_UTS_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|error
op_assign
id|put_user
c_func
(paren
l_int|0
comma
id|name-&gt;machine
op_plus
id|__OLD_UTS_LEN
)paren
suffix:semicolon
id|error
op_assign
id|error
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
macro_line|#endif
DECL|function|sys_sethostname
id|asmlinkage
r_int
id|sys_sethostname
c_func
(paren
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
r_int
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|len
template_param
id|__NEW_UTS_LEN
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|copy_from_user
c_func
(paren
id|system_utsname.nodename
comma
id|name
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|system_utsname.nodename
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_gethostname
id|asmlinkage
r_int
id|sys_gethostname
c_func
(paren
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
r_int
id|i
comma
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
r_goto
id|out
suffix:semicolon
id|i
op_assign
l_int|1
op_plus
id|strlen
c_func
(paren
id|system_utsname.nodename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
id|len
)paren
id|i
op_assign
id|len
suffix:semicolon
id|err
op_assign
id|copy_to_user
c_func
(paren
id|name
comma
id|system_utsname.nodename
comma
id|i
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * Only setdomainname; getdomainname can be implemented by calling&n; * uname()&n; */
DECL|function|sys_setdomainname
id|asmlinkage
r_int
id|sys_setdomainname
c_func
(paren
r_char
op_star
id|name
comma
r_int
id|len
)paren
(brace
r_int
id|error
op_assign
op_minus
id|EPERM
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|len
template_param
id|__NEW_UTS_LEN
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|copy_from_user
c_func
(paren
id|system_utsname.domainname
comma
id|name
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|error
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_else
id|system_utsname.domainname
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_getrlimit
id|asmlinkage
r_int
id|sys_getrlimit
c_func
(paren
r_int
r_int
id|resource
comma
r_struct
id|rlimit
op_star
id|rlim
)paren
(brace
r_int
id|error
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resource
op_ge
id|RLIM_NLIMITS
)paren
id|error
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_else
id|error
op_assign
id|copy_to_user
c_func
(paren
id|rlim
comma
id|current-&gt;rlim
op_plus
id|resource
comma
r_sizeof
(paren
op_star
id|rlim
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
DECL|function|sys_setrlimit
id|asmlinkage
r_int
id|sys_setrlimit
c_func
(paren
r_int
r_int
id|resource
comma
r_struct
id|rlimit
op_star
id|rlim
)paren
(brace
r_struct
id|rlimit
id|new_rlim
comma
op_star
id|old_rlim
suffix:semicolon
r_int
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resource
op_ge
id|RLIM_NLIMITS
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|copy_from_user
c_func
(paren
op_amp
id|new_rlim
comma
id|rlim
comma
r_sizeof
(paren
op_star
id|rlim
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|err
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|old_rlim
op_assign
id|current-&gt;rlim
op_plus
id|resource
suffix:semicolon
id|err
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|new_rlim.rlim_cur
OG
id|old_rlim-&gt;rlim_max
)paren
op_logical_or
(paren
id|new_rlim.rlim_max
OG
id|old_rlim-&gt;rlim_max
)paren
)paren
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|resource
op_eq
id|RLIMIT_NOFILE
)paren
(brace
r_if
c_cond
(paren
id|new_rlim.rlim_cur
OG
id|NR_OPEN
op_logical_or
id|new_rlim.rlim_max
OG
id|NR_OPEN
)paren
r_goto
id|out
suffix:semicolon
)brace
op_star
id|old_rlim
op_assign
id|new_rlim
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * It would make sense to put struct rusage in the task_struct,&n; * except that would make the task_struct be *really big*.  After&n; * task_struct gets moved into malloc&squot;ed memory, it would&n; * make sense to do this.  It will make moving the rest of the information&n; * a lot simpler!  (Which we&squot;re not doing right now because we&squot;re not&n; * measuring them yet).&n; */
DECL|function|getrusage
r_int
id|getrusage
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
id|who
comma
r_struct
id|rusage
op_star
id|ru
)paren
(brace
r_struct
id|rusage
id|r
suffix:semicolon
r_int
id|err
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|r
comma
l_int|0
comma
r_sizeof
(paren
id|r
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|who
)paren
(brace
r_case
id|RUSAGE_SELF
suffix:colon
id|r.ru_utime.tv_sec
op_assign
id|CT_TO_SECS
c_func
(paren
id|p-&gt;utime
)paren
suffix:semicolon
id|r.ru_utime.tv_usec
op_assign
id|CT_TO_USECS
c_func
(paren
id|p-&gt;utime
)paren
suffix:semicolon
id|r.ru_stime.tv_sec
op_assign
id|CT_TO_SECS
c_func
(paren
id|p-&gt;stime
)paren
suffix:semicolon
id|r.ru_stime.tv_usec
op_assign
id|CT_TO_USECS
c_func
(paren
id|p-&gt;stime
)paren
suffix:semicolon
id|r.ru_minflt
op_assign
id|p-&gt;min_flt
suffix:semicolon
id|r.ru_majflt
op_assign
id|p-&gt;maj_flt
suffix:semicolon
id|r.ru_nswap
op_assign
id|p-&gt;nswap
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RUSAGE_CHILDREN
suffix:colon
id|r.ru_utime.tv_sec
op_assign
id|CT_TO_SECS
c_func
(paren
id|p-&gt;cutime
)paren
suffix:semicolon
id|r.ru_utime.tv_usec
op_assign
id|CT_TO_USECS
c_func
(paren
id|p-&gt;cutime
)paren
suffix:semicolon
id|r.ru_stime.tv_sec
op_assign
id|CT_TO_SECS
c_func
(paren
id|p-&gt;cstime
)paren
suffix:semicolon
id|r.ru_stime.tv_usec
op_assign
id|CT_TO_USECS
c_func
(paren
id|p-&gt;cstime
)paren
suffix:semicolon
id|r.ru_minflt
op_assign
id|p-&gt;cmin_flt
suffix:semicolon
id|r.ru_majflt
op_assign
id|p-&gt;cmaj_flt
suffix:semicolon
id|r.ru_nswap
op_assign
id|p-&gt;cnswap
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|r.ru_utime.tv_sec
op_assign
id|CT_TO_SECS
c_func
(paren
id|p-&gt;utime
op_plus
id|p-&gt;cutime
)paren
suffix:semicolon
id|r.ru_utime.tv_usec
op_assign
id|CT_TO_USECS
c_func
(paren
id|p-&gt;utime
op_plus
id|p-&gt;cutime
)paren
suffix:semicolon
id|r.ru_stime.tv_sec
op_assign
id|CT_TO_SECS
c_func
(paren
id|p-&gt;stime
op_plus
id|p-&gt;cstime
)paren
suffix:semicolon
id|r.ru_stime.tv_usec
op_assign
id|CT_TO_USECS
c_func
(paren
id|p-&gt;stime
op_plus
id|p-&gt;cstime
)paren
suffix:semicolon
id|r.ru_minflt
op_assign
id|p-&gt;min_flt
op_plus
id|p-&gt;cmin_flt
suffix:semicolon
id|r.ru_majflt
op_assign
id|p-&gt;maj_flt
op_plus
id|p-&gt;cmaj_flt
suffix:semicolon
id|r.ru_nswap
op_assign
id|p-&gt;nswap
op_plus
id|p-&gt;cnswap
suffix:semicolon
r_break
suffix:semicolon
)brace
id|err
op_assign
id|copy_to_user
c_func
(paren
id|ru
comma
op_amp
id|r
comma
r_sizeof
(paren
id|r
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sys_getrusage
id|asmlinkage
r_int
id|sys_getrusage
c_func
(paren
r_int
id|who
comma
r_struct
id|rusage
op_star
id|ru
)paren
(brace
r_int
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|who
op_ne
id|RUSAGE_SELF
op_logical_and
id|who
op_ne
id|RUSAGE_CHILDREN
)paren
r_goto
id|out
suffix:semicolon
id|err
op_assign
id|getrusage
c_func
(paren
id|current
comma
id|who
comma
id|ru
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|sys_umask
id|asmlinkage
r_int
id|sys_umask
c_func
(paren
r_int
id|mask
)paren
(brace
multiline_comment|/* The xchg() isn&squot;t SMP-safe on x86 right now.. */
id|mask
op_assign
id|xchg
c_func
(paren
op_amp
id|current-&gt;fs-&gt;umask
comma
id|mask
op_amp
id|S_IRWXUGO
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
eof
