multiline_comment|/*&n; * This file contains the driver for an XT hard disk controller (at least the DTC 5150X) for Linux.&n; *&n; * Author: Pat Mackinlay, smackinla@cc.curtin.edu.au&n; * Date: 29/09/92&n; * &n; * Revised: 01/01/93, ...&n; *&n; * Ref: DTC 5150X Controller Specification (thanks to Kevin Fowler, kevinf@agora.rain.com)&n; * Also thanks to: Salvador Abreu, Dave Thaler, Risto Kankkunen and Wim Van Dorst.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef CONFIG_BLK_DEV_XD
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/xd.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR 13
macro_line|#include &quot;blk.h&quot;
DECL|variable|xd_info
id|XD_INFO
id|xd_info
(braket
id|XD_MAXDRIVES
)braket
suffix:semicolon
multiline_comment|/* If you try this driver and find that your card is not detected by the driver at bootup, you need to add your BIOS&n;   signature and details to the following list of signatures. A BIOS signature is a string embedded into the first&n;   few bytes of your controller&squot;s on-board ROM BIOS. To find out what yours is, use something like MS-DOS&squot;s DEBUG&n;   command. Run DEBUG, and then you can examine your BIOS signature with:&n;&n;&t;d xxxx:0000&n;&n;   where xxxx is the segment of your controller (like C800 or D000 or something). On the ASCII dump at the right, you should&n;   be able to see a string mentioning the manufacturer&squot;s copyright etc. Add this string into the table below. The parameters&n;   in the table are, in order:&n;&n;&t;offset&t;&t;&t;; this is the offset (in bytes) from the start of your ROM where the signature starts&n;&t;signature&t;&t;; this is the actual text of the signature&n;&t;xd_?_init_controller&t;; this is the controller init routine used by your controller&n;&t;xd_?_init_drive&t;&t;; this is the drive init routine used by your controller&n;&n;   The controllers directly supported at the moment are: DTC 5150x, WD 1004A27X, ST11M/R and override. If your controller is&n;   made by the same manufacturer as one of these, try using the same init routines as they do. If that doesn&squot;t work, your&n;   best bet is to use the &quot;override&quot; routines. These routines use a &quot;portable&quot; method of getting the disk&squot;s geometry, and&n;   may work with your card. If none of these seem to work, try sending me some email and I&squot;ll see what I can do &lt;grin&gt;. */
DECL|variable|xd_sigs
r_static
id|XD_SIGNATURE
id|xd_sigs
(braket
)braket
op_assign
(brace
(brace
l_int|0x0000
comma
l_string|&quot;Override geometry handler&quot;
comma
id|xd_override_init_controller
comma
id|xd_override_init_drive
comma
l_string|&quot;n unknown&quot;
)brace
comma
multiline_comment|/* Pat Mackinlay, smackinla@cc.curtin.edu.au (pat@gu.uwa.edu.au) */
macro_line|#ifndef XD_OVERRIDE
(brace
l_int|0x000B
comma
l_string|&quot;CXD23A Not an IBM ROM (C)Copyright Data Technology Corp 12/03/88&quot;
comma
id|xd_dtc5150x_init_controller
comma
id|xd_dtc5150x_init_drive
comma
l_string|&quot; DTC 5150X&quot;
)brace
comma
multiline_comment|/* Pat Mackinlay, smackinla@cc.curtin.edu.au (pat@gu.uwa.edu.au) */
(brace
l_int|0x0008
comma
l_string|&quot;07/15/86 (C) Copyright 1986 Western Digital Corp&quot;
comma
id|xd_wd1004a27x_init_controller
comma
id|xd_wd1004a27x_init_drive
comma
l_string|&quot; Western Digital 1002AWX1&quot;
)brace
comma
multiline_comment|/* Ian Justman, citrus!ianj@csusac.ecs.csus.edu */
(brace
l_int|0x0008
comma
l_string|&quot;06/24/88 (C) Copyright 1988 Western Digital Corp&quot;
comma
id|xd_wd1004a27x_init_controller
comma
id|xd_wd1004a27x_init_drive
comma
l_string|&quot; Western Digital 1004A27X&quot;
)brace
comma
multiline_comment|/* Dave Thaler, thalerd@engin.umich.edu */
(brace
l_int|0x0015
comma
l_string|&quot;SEAGATE ST11 BIOS REVISION&quot;
comma
id|xd_seagate11_init_controller
comma
id|xd_seagate11_init_drive
comma
l_string|&quot; Seagate ST11M/R&quot;
)brace
comma
multiline_comment|/* Salvador Abreu, spa@fct.unl.pt */
(brace
l_int|0x0010
comma
l_string|&quot;ST11R BIOS&quot;
comma
id|xd_seagate11_init_controller
comma
id|xd_seagate11_init_drive
comma
l_string|&quot; Seagate ST11M/R&quot;
)brace
comma
multiline_comment|/* Risto Kankkunen, risto.kankkunen@cs.helsinki.fi */
macro_line|#endif XD_OVERRIDE
)brace
suffix:semicolon
macro_line|#ifndef XD_OVERRIDE
DECL|variable|xd_bases
r_static
id|u_char
op_star
id|xd_bases
(braket
)braket
op_assign
(brace
(paren
id|u_char
op_star
)paren
l_int|0xC8000
comma
(paren
id|u_char
op_star
)paren
l_int|0xCA000
comma
(paren
id|u_char
op_star
)paren
l_int|0xD0000
comma
(paren
id|u_char
op_star
)paren
l_int|0xD8000
comma
(paren
id|u_char
op_star
)paren
l_int|0xE0000
)brace
suffix:semicolon
macro_line|#endif XD_OVERRIDE
DECL|variable|xd
r_static
r_struct
id|hd_struct
id|xd
(braket
id|XD_MAXDRIVES
op_lshift
l_int|6
)braket
suffix:semicolon
DECL|variable|xd_sizes
DECL|variable|xd_access
r_static
r_int
id|xd_sizes
(braket
id|XD_MAXDRIVES
op_lshift
l_int|6
)braket
comma
id|xd_access
(braket
id|XD_MAXDRIVES
)braket
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|xd_blocksizes
r_static
r_int
id|xd_blocksizes
(braket
id|XD_MAXDRIVES
op_lshift
l_int|6
)braket
suffix:semicolon
DECL|variable|xd_gendisk
r_static
r_struct
id|gendisk
id|xd_gendisk
op_assign
(brace
id|MAJOR_NR
comma
l_string|&quot;xd&quot;
comma
l_int|6
comma
l_int|1
op_lshift
l_int|6
comma
id|XD_MAXDRIVES
comma
id|xd_geninit
comma
id|xd
comma
id|xd_sizes
comma
l_int|0
comma
(paren
r_void
op_star
)paren
id|xd_info
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|xd_fops
r_static
r_struct
id|file_operations
id|xd_fops
op_assign
(brace
l_int|NULL
comma
id|block_read
comma
id|block_write
comma
l_int|NULL
comma
l_int|NULL
comma
id|xd_ioctl
comma
l_int|NULL
comma
id|xd_open
comma
id|xd_release
comma
id|block_fsync
)brace
suffix:semicolon
DECL|variable|xd_wait_int
DECL|variable|xd_wait_open
r_static
r_struct
id|wait_queue
op_star
id|xd_wait_int
op_assign
l_int|NULL
comma
op_star
id|xd_wait_open
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|xd_valid
r_static
id|u_char
id|xd_valid
(braket
id|XD_MAXDRIVES
)braket
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|xd_drives
DECL|variable|xd_irq
DECL|variable|xd_dma
DECL|variable|xd_maxsectors
r_static
id|u_char
id|xd_drives
op_assign
l_int|0
comma
id|xd_irq
comma
id|xd_dma
comma
id|xd_maxsectors
suffix:semicolon
DECL|variable|xd_iobase
r_static
id|u_short
id|xd_iobase
suffix:semicolon
multiline_comment|/* xd_init: grab the IRQ and DMA channel and initialise the drives */
DECL|function|xd_init
id|u_long
id|xd_init
(paren
id|u_long
id|mem_start
comma
id|u_long
id|mem_end
)paren
(brace
id|u_char
id|i
comma
id|controller
comma
op_star
id|address
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;xd&quot;
comma
op_amp
id|xd_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;xd_init: unable to get major number %d&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
(paren
id|mem_start
)paren
suffix:semicolon
)brace
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* 8 sector (4kB) read ahead */
id|xd_gendisk.next
op_assign
id|gendisk_head
suffix:semicolon
id|gendisk_head
op_assign
op_amp
id|xd_gendisk
suffix:semicolon
r_if
c_cond
(paren
id|xd_detect
c_func
(paren
op_amp
id|controller
comma
op_amp
id|address
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;xd_init: detected a%s controller (type %d) at address %p&bslash;n&quot;
comma
id|xd_sigs
(braket
id|controller
)braket
dot
id|name
comma
id|controller
comma
id|address
)paren
suffix:semicolon
id|xd_sigs
(braket
id|controller
)braket
dot
id|init_controller
c_func
(paren
id|address
)paren
suffix:semicolon
id|xd_drives
op_assign
id|xd_initdrives
c_func
(paren
id|xd_sigs
(braket
id|controller
)braket
dot
id|init_drive
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;xd_init: detected %d hard drive%s (using IRQ%d &amp; DMA%d)&bslash;n&quot;
comma
id|xd_drives
comma
id|xd_drives
op_eq
l_int|1
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
comma
id|xd_irq
comma
id|xd_dma
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|xd_drives
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;xd_init: drive %d geometry - heads = %d, cylinders = %d, sectors = %d&bslash;n&quot;
comma
id|i
comma
id|xd_info
(braket
id|i
)braket
dot
id|heads
comma
id|xd_info
(braket
id|i
)braket
dot
id|cylinders
comma
id|xd_info
(braket
id|i
)braket
dot
id|sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_irq
c_func
(paren
id|xd_irq
comma
id|xd_interrupt_handler
)paren
)paren
(brace
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|xd_dma
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;xd_init: unable to get DMA%d&bslash;n&quot;
comma
id|xd_dma
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|xd_irq
)paren
suffix:semicolon
)brace
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;xd_init: unable to get IRQ%d&bslash;n&quot;
comma
id|xd_irq
)paren
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
multiline_comment|/* xd_detect: scan the possible BIOS ROM locations for the signature strings */
DECL|function|xd_detect
r_static
id|u_char
id|xd_detect
(paren
id|u_char
op_star
id|controller
comma
id|u_char
op_star
op_star
id|address
)paren
(brace
macro_line|#ifndef XD_OVERRIDE
id|u_char
id|i
comma
id|j
comma
id|found
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_sizeof
(paren
id|xd_bases
)paren
op_div
r_sizeof
(paren
id|xd_bases
(braket
l_int|0
)braket
)paren
)paren
op_logical_and
op_logical_neg
id|found
suffix:semicolon
id|i
op_increment
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
OL
(paren
r_sizeof
(paren
id|xd_sigs
)paren
op_div
r_sizeof
(paren
id|xd_sigs
(braket
l_int|0
)braket
)paren
)paren
op_logical_and
op_logical_neg
id|found
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|xd_bases
(braket
id|i
)braket
op_plus
id|xd_sigs
(braket
id|j
)braket
dot
id|offset
comma
id|xd_sigs
(braket
id|j
)braket
dot
id|string
comma
id|strlen
c_func
(paren
id|xd_sigs
(braket
id|j
)braket
dot
id|string
)paren
)paren
)paren
(brace
op_star
id|controller
op_assign
id|j
suffix:semicolon
op_star
id|address
op_assign
id|xd_bases
(braket
id|i
)braket
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
r_return
(paren
id|found
)paren
suffix:semicolon
macro_line|#else
op_star
id|controller
op_assign
l_int|0
suffix:semicolon
op_star
id|address
op_assign
l_int|NULL
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif XD_OVERRIDE
)brace
multiline_comment|/* xd_geninit: set up the &quot;raw&quot; device entries in the table */
DECL|function|xd_geninit
r_static
r_void
id|xd_geninit
(paren
r_void
)paren
(brace
id|u_char
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|xd_drives
suffix:semicolon
id|i
op_increment
)paren
(brace
id|xd
(braket
id|i
op_lshift
l_int|6
)braket
dot
id|nr_sects
op_assign
id|xd_info
(braket
id|i
)braket
dot
id|heads
op_star
id|xd_info
(braket
id|i
)braket
dot
id|cylinders
op_star
id|xd_info
(braket
id|i
)braket
dot
id|sectors
suffix:semicolon
id|xd_valid
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
)brace
id|xd_gendisk.nr_real
op_assign
id|xd_drives
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|XD_MAXDRIVES
op_lshift
l_int|6
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|xd_blocksizes
(braket
id|i
)braket
op_assign
l_int|1024
suffix:semicolon
)brace
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|xd_blocksizes
suffix:semicolon
)brace
multiline_comment|/* xd_open: open a device */
DECL|function|xd_open
r_static
r_int
id|xd_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|dev
op_assign
id|DEVICE_NR
c_func
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
OL
id|xd_drives
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|xd_valid
(braket
id|dev
)braket
)paren
id|sleep_on
c_func
(paren
op_amp
id|xd_wait_open
)paren
suffix:semicolon
id|xd_access
(braket
id|dev
)braket
op_increment
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
multiline_comment|/* do_xd_request: handle an incoming request */
DECL|function|do_xd_request
r_static
r_void
id|do_xd_request
(paren
r_void
)paren
(brace
id|u_int
id|block
comma
id|count
comma
id|retry
suffix:semicolon
r_int
id|code
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|code
op_assign
l_int|0
comma
id|CURRENT
)paren
(brace
id|INIT_REQUEST
suffix:semicolon
multiline_comment|/* do some checking on the request structure */
r_if
c_cond
(paren
id|CURRENT_DEV
OL
id|xd_drives
op_logical_and
id|CURRENT-&gt;sector
op_plus
id|CURRENT-&gt;nr_sectors
op_le
id|xd
(braket
id|MINOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
)braket
dot
id|nr_sects
)paren
(brace
id|block
op_assign
id|CURRENT-&gt;sector
op_plus
id|xd
(braket
id|MINOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
)braket
dot
id|start_sect
suffix:semicolon
id|count
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
r_switch
c_cond
(paren
id|CURRENT-&gt;cmd
)paren
(brace
r_case
id|READ
suffix:colon
r_case
id|WRITE
suffix:colon
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
(paren
id|retry
OL
id|XD_RETRIES
)paren
op_logical_and
op_logical_neg
id|code
suffix:semicolon
id|retry
op_increment
)paren
id|code
op_assign
id|xd_readwrite
c_func
(paren
id|CURRENT-&gt;cmd
comma
id|CURRENT_DEV
comma
id|CURRENT-&gt;buffer
comma
id|block
comma
id|count
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;do_xd_request: unknown request&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|end_request
c_func
(paren
id|code
)paren
suffix:semicolon
multiline_comment|/* wrap up, 0 = fail, 1 = success */
)brace
)brace
multiline_comment|/* xd_ioctl: handle device ioctl&squot;s */
DECL|function|xd_ioctl
r_static
r_int
id|xd_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|u_int
id|cmd
comma
id|u_long
id|arg
)paren
(brace
id|XD_GEOMETRY
op_star
id|geometry
op_assign
(paren
id|XD_GEOMETRY
op_star
)paren
id|arg
suffix:semicolon
r_int
id|dev
op_assign
id|DEVICE_NR
c_func
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
id|inode
op_logical_and
(paren
id|dev
OL
id|xd_drives
)paren
)paren
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_GETGEO
suffix:colon
r_if
c_cond
(paren
id|arg
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|geometry
comma
r_sizeof
(paren
op_star
id|geometry
)paren
)paren
)paren
)paren
r_return
(paren
id|err
)paren
suffix:semicolon
id|put_fs_byte
c_func
(paren
id|xd_info
(braket
id|dev
)braket
dot
id|heads
comma
(paren
r_char
op_star
)paren
op_amp
id|geometry-&gt;heads
)paren
suffix:semicolon
id|put_fs_byte
c_func
(paren
id|xd_info
(braket
id|dev
)braket
dot
id|sectors
comma
(paren
r_char
op_star
)paren
op_amp
id|geometry-&gt;sectors
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
id|xd_info
(braket
id|dev
)braket
dot
id|cylinders
comma
(paren
r_int
op_star
)paren
op_amp
id|geometry-&gt;cylinders
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|xd
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|start_sect
comma
(paren
r_int
op_star
)paren
op_amp
id|geometry-&gt;start
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BLKGETSIZE
suffix:colon
r_if
c_cond
(paren
id|arg
)paren
(brace
r_if
c_cond
(paren
(paren
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
)paren
r_return
(paren
id|err
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|xd
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|nr_sects
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|BLKFLSBUF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_rdev
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|sync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKRRPART
suffix:colon
r_return
(paren
id|xd_reread_partitions
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
suffix:semicolon
id|RO_IOCTLS
c_func
(paren
id|inode-&gt;i_rdev
comma
id|arg
)paren
suffix:semicolon
)brace
r_return
(paren
op_minus
id|EINVAL
)paren
suffix:semicolon
)brace
multiline_comment|/* xd_release: release the device */
DECL|function|xd_release
r_static
r_void
id|xd_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|dev
op_assign
id|DEVICE_NR
c_func
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
OL
id|xd_drives
)paren
(brace
id|sync_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|xd_access
(braket
id|dev
)braket
op_decrement
suffix:semicolon
)brace
)brace
multiline_comment|/* xd_reread_partitions: rereads the partition table from a drive */
DECL|function|xd_reread_partitions
r_static
r_int
id|xd_reread_partitions
c_func
(paren
r_int
id|dev
)paren
(brace
r_int
id|target
op_assign
id|DEVICE_NR
c_func
(paren
id|MINOR
c_func
(paren
id|dev
)paren
)paren
comma
id|start
op_assign
id|target
op_lshift
id|xd_gendisk.minor_shift
comma
id|partition
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|xd_valid
(braket
id|target
)braket
op_assign
(paren
id|xd_access
(braket
id|target
)braket
op_ne
l_int|1
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xd_valid
(braket
id|target
)braket
)paren
r_return
(paren
op_minus
id|EBUSY
)paren
suffix:semicolon
r_for
c_loop
(paren
id|partition
op_assign
id|xd_gendisk.max_p
op_minus
l_int|1
suffix:semicolon
id|partition
op_ge
l_int|0
suffix:semicolon
id|partition
op_decrement
)paren
(brace
id|sync_dev
c_func
(paren
id|MAJOR_NR
op_lshift
l_int|8
op_or
id|start
op_or
id|partition
)paren
suffix:semicolon
id|invalidate_inodes
c_func
(paren
id|MAJOR_NR
op_lshift
l_int|8
op_or
id|start
op_or
id|partition
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|MAJOR_NR
op_lshift
l_int|8
op_or
id|start
op_or
id|partition
)paren
suffix:semicolon
id|xd_gendisk.part
(braket
id|start
op_plus
id|partition
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|xd_gendisk.part
(braket
id|start
op_plus
id|partition
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
)brace
suffix:semicolon
id|xd_gendisk.part
(braket
id|start
)braket
dot
id|nr_sects
op_assign
id|xd_info
(braket
id|target
)braket
dot
id|heads
op_star
id|xd_info
(braket
id|target
)braket
dot
id|cylinders
op_star
id|xd_info
(braket
id|target
)braket
dot
id|sectors
suffix:semicolon
id|resetup_one_dev
c_func
(paren
op_amp
id|xd_gendisk
comma
id|target
)paren
suffix:semicolon
id|xd_valid
(braket
id|target
)braket
op_assign
l_int|1
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|xd_wait_open
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* xd_readwrite: handle a read/write request */
DECL|function|xd_readwrite
r_static
r_int
id|xd_readwrite
(paren
id|u_char
id|operation
comma
id|u_char
id|drive
comma
r_char
op_star
id|buffer
comma
id|u_int
id|block
comma
id|u_int
id|count
)paren
(brace
id|u_char
id|cmdblk
(braket
l_int|6
)braket
comma
id|sense
(braket
l_int|4
)braket
suffix:semicolon
id|u_short
id|track
comma
id|cylinder
suffix:semicolon
id|u_char
id|head
comma
id|sector
comma
id|control
comma
id|mode
comma
id|temp
suffix:semicolon
macro_line|#ifdef DEBUG_READWRITE
id|printk
c_func
(paren
l_string|&quot;xd_readwrite: operation = %s, drive = %d, buffer = 0x%X, block = %d, count = %d&bslash;n&quot;
comma
id|operation
op_eq
id|READ
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;write&quot;
comma
id|drive
comma
id|buffer
comma
id|block
comma
id|count
)paren
suffix:semicolon
macro_line|#endif DEBUG_READWRITE
id|control
op_assign
id|xd_info
(braket
id|drive
)braket
dot
id|control
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|temp
op_assign
id|count
OL
id|xd_maxsectors
ques
c_cond
id|count
suffix:colon
id|xd_maxsectors
suffix:semicolon
id|track
op_assign
id|block
op_div
id|xd_info
(braket
id|drive
)braket
dot
id|sectors
suffix:semicolon
id|head
op_assign
id|track
op_mod
id|xd_info
(braket
id|drive
)braket
dot
id|heads
suffix:semicolon
id|cylinder
op_assign
id|track
op_div
id|xd_info
(braket
id|drive
)braket
dot
id|heads
suffix:semicolon
id|sector
op_assign
id|block
op_mod
id|xd_info
(braket
id|drive
)braket
dot
id|sectors
suffix:semicolon
macro_line|#ifdef DEBUG_READWRITE
id|printk
c_func
(paren
l_string|&quot;xd_readwrite: drive = %d, head = %d, cylinder = %d, sector = %d, count = %d&bslash;n&quot;
comma
id|drive
comma
id|head
comma
id|cylinder
comma
id|sector
comma
id|temp
)paren
suffix:semicolon
macro_line|#endif DEBUG_READWRITE
id|mode
op_assign
id|xd_setup_dma
c_func
(paren
id|operation
op_eq
id|READ
ques
c_cond
id|DMA_MODE_READ
suffix:colon
id|DMA_MODE_WRITE
comma
(paren
id|u_char
op_star
)paren
id|buffer
comma
id|temp
op_star
l_int|0x200
)paren
suffix:semicolon
id|xd_build
c_func
(paren
id|cmdblk
comma
id|operation
op_eq
id|READ
ques
c_cond
id|CMD_READ
suffix:colon
id|CMD_WRITE
comma
id|drive
comma
id|head
comma
id|cylinder
comma
id|sector
comma
id|temp
op_amp
l_int|0xFF
comma
id|control
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|xd_command
c_func
(paren
id|cmdblk
comma
id|mode
comma
(paren
id|u_char
op_star
)paren
id|buffer
comma
(paren
id|u_char
op_star
)paren
id|buffer
comma
id|sense
comma
id|XD_TIMEOUT
)paren
)paren
(brace
r_case
l_int|1
suffix:colon
id|printk
c_func
(paren
l_string|&quot;xd_readwrite: timeout, recalibrating drive&bslash;n&quot;
)paren
suffix:semicolon
id|xd_recalibrate
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
l_int|2
suffix:colon
r_switch
c_cond
(paren
(paren
id|sense
(braket
l_int|0
)braket
op_amp
l_int|0x30
)paren
op_rshift
l_int|4
)paren
(brace
r_case
l_int|0
suffix:colon
id|printk
c_func
(paren
l_string|&quot;xd_readwrite: drive error, code = 0x%X&quot;
comma
id|sense
(braket
l_int|0
)braket
op_amp
l_int|0x0F
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|printk
c_func
(paren
l_string|&quot;xd_readwrite: controller error, code = 0x%X&quot;
comma
id|sense
(braket
l_int|0
)braket
op_amp
l_int|0x0F
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
c_func
(paren
l_string|&quot;xd_readwrite: command error, code = 0x%X&quot;
comma
id|sense
(braket
l_int|0
)braket
op_amp
l_int|0x0F
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|printk
c_func
(paren
l_string|&quot;xd_readwrite: miscellaneous error, code = 0x%X&quot;
comma
id|sense
(braket
l_int|0
)braket
op_amp
l_int|0x0F
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sense
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
id|printk
c_func
(paren
l_string|&quot; - drive = %d, head = %d, cylinder = %d, sector = %d&bslash;n&quot;
comma
id|sense
(braket
l_int|1
)braket
op_amp
l_int|0xE0
comma
id|sense
(braket
l_int|1
)braket
op_amp
l_int|0x1F
comma
(paren
(paren
id|sense
(braket
l_int|2
)braket
op_amp
l_int|0xC0
)paren
op_lshift
l_int|2
)paren
op_or
id|sense
(braket
l_int|3
)braket
comma
id|sense
(braket
l_int|2
)braket
op_amp
l_int|0x3F
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; - no valid disk address&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|count
op_sub_assign
id|temp
comma
id|buffer
op_add_assign
id|temp
op_star
l_int|0x200
comma
id|block
op_add_assign
id|temp
suffix:semicolon
)brace
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* xd_recalibrate: recalibrate a given drive and reset controller if necessary */
DECL|function|xd_recalibrate
r_static
r_void
id|xd_recalibrate
(paren
id|u_char
id|drive
)paren
(brace
id|u_char
id|cmdblk
(braket
l_int|6
)braket
suffix:semicolon
id|xd_build
c_func
(paren
id|cmdblk
comma
id|CMD_RECALIBRATE
comma
id|drive
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xd_command
c_func
(paren
id|cmdblk
comma
id|PIO_MODE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|XD_TIMEOUT
op_star
l_int|8
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;xd_recalibrate: warning! error recalibrating, controller may be unstable&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* xd_interrupt_handler: interrupt service routine */
DECL|function|xd_interrupt_handler
r_static
r_void
id|xd_interrupt_handler
(paren
r_int
id|unused
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|XD_STATUS
)paren
op_amp
id|STAT_INTERRUPT
)paren
(brace
multiline_comment|/* check if it was our device */
macro_line|#ifdef DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;xd_interrupt_handler: interrupt detected&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif DEBUG_OTHER
id|outb
c_func
(paren
l_int|0
comma
id|XD_CONTROL
)paren
suffix:semicolon
multiline_comment|/* acknowledge interrupt */
id|wake_up
c_func
(paren
op_amp
id|xd_wait_int
)paren
suffix:semicolon
multiline_comment|/* and wake up sleeping processes */
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;xd_interrupt_handler: unexpected interrupt&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* xd_dma: set up the DMA controller for a data transfer */
DECL|function|xd_setup_dma
r_static
id|u_char
id|xd_setup_dma
(paren
id|u_char
id|mode
comma
id|u_char
op_star
id|buffer
comma
id|u_int
id|count
)paren
(brace
r_if
c_cond
(paren
id|buffer
OL
(paren
(paren
id|u_char
op_star
)paren
l_int|0x1000000
op_minus
id|count
)paren
)paren
(brace
multiline_comment|/* transfer to address &lt; 16M? */
r_if
c_cond
(paren
(paren
(paren
id|u_int
)paren
id|buffer
op_amp
l_int|0xFFFF0000
)paren
op_ne
(paren
(paren
id|u_int
)paren
id|buffer
op_plus
id|count
)paren
op_amp
l_int|0xFFFF0000
)paren
(brace
macro_line|#ifdef DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;xd_setup_dma: using PIO, transfer overlaps 64k boundary&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif DEBUG_OTHER
r_return
(paren
id|PIO_MODE
)paren
suffix:semicolon
)brace
id|disable_dma
c_func
(paren
id|xd_dma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|xd_dma
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|xd_dma
comma
id|mode
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|xd_dma
comma
(paren
id|u_int
)paren
id|buffer
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|xd_dma
comma
id|count
)paren
suffix:semicolon
r_return
(paren
id|DMA_MODE
)paren
suffix:semicolon
multiline_comment|/* use DMA and INT */
)brace
macro_line|#ifdef DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;xd_setup_dma: using PIO, cannot DMA above 16 meg&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif DEBUG_OTHER
r_return
(paren
id|PIO_MODE
)paren
suffix:semicolon
)brace
multiline_comment|/* xd_build: put stuff into an array in a format suitable for the controller */
DECL|function|xd_build
r_static
id|u_char
op_star
id|xd_build
(paren
id|u_char
op_star
id|cmdblk
comma
id|u_char
id|command
comma
id|u_char
id|drive
comma
id|u_char
id|head
comma
id|u_short
id|cylinder
comma
id|u_char
id|sector
comma
id|u_char
id|count
comma
id|u_char
id|control
)paren
(brace
id|cmdblk
(braket
l_int|0
)braket
op_assign
id|command
suffix:semicolon
id|cmdblk
(braket
l_int|1
)braket
op_assign
(paren
(paren
id|drive
op_amp
l_int|0x07
)paren
op_lshift
l_int|5
)paren
op_or
(paren
id|head
op_amp
l_int|0x1F
)paren
suffix:semicolon
id|cmdblk
(braket
l_int|2
)braket
op_assign
(paren
(paren
id|cylinder
op_amp
l_int|0x300
)paren
op_rshift
l_int|2
)paren
op_or
(paren
id|sector
op_amp
l_int|0x3F
)paren
suffix:semicolon
id|cmdblk
(braket
l_int|3
)braket
op_assign
id|cylinder
op_amp
l_int|0xFF
suffix:semicolon
id|cmdblk
(braket
l_int|4
)braket
op_assign
id|count
suffix:semicolon
id|cmdblk
(braket
l_int|5
)braket
op_assign
id|control
suffix:semicolon
r_return
(paren
id|cmdblk
)paren
suffix:semicolon
)brace
multiline_comment|/* xd_waitport: waits until port &amp; mask == flags or a timeout occurs. return 1 for a timeout */
DECL|function|xd_waitport
r_static
r_inline
id|u_char
id|xd_waitport
(paren
id|u_short
id|port
comma
id|u_char
id|flags
comma
id|u_char
id|mask
comma
id|u_long
id|timeout
)paren
(brace
id|u_long
id|expiry
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|inb
c_func
(paren
id|port
)paren
op_amp
id|mask
)paren
op_ne
id|flags
)paren
op_logical_and
(paren
id|jiffies
OL
id|expiry
)paren
)paren
suffix:semicolon
r_return
(paren
id|jiffies
op_ge
id|expiry
)paren
suffix:semicolon
)brace
multiline_comment|/* xd_command: handle all data transfers necessary for a single command */
DECL|function|xd_command
r_static
id|u_int
id|xd_command
(paren
id|u_char
op_star
id|command
comma
id|u_char
id|mode
comma
id|u_char
op_star
id|indata
comma
id|u_char
op_star
id|outdata
comma
id|u_char
op_star
id|sense
comma
id|u_long
id|timeout
)paren
(brace
id|u_char
id|cmdblk
(braket
l_int|6
)braket
comma
id|csb
comma
id|complete
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG_COMMAND
id|printk
c_func
(paren
l_string|&quot;xd_command: command = 0x%X, mode = 0x%X, indata = 0x%X, outdata = 0x%X, sense = 0x%X&bslash;n&quot;
comma
id|command
comma
id|mode
comma
id|indata
comma
id|outdata
comma
id|sense
)paren
suffix:semicolon
macro_line|#endif DEBUG_COMMAND
id|outb
c_func
(paren
l_int|0
comma
id|XD_SELECT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|mode
comma
id|XD_CONTROL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xd_waitport
c_func
(paren
id|XD_STATUS
comma
id|STAT_SELECT
comma
id|STAT_SELECT
comma
id|timeout
)paren
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|complete
)paren
(brace
r_if
c_cond
(paren
id|xd_waitport
c_func
(paren
id|XD_STATUS
comma
id|STAT_READY
comma
id|STAT_READY
comma
id|timeout
)paren
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|inb
c_func
(paren
id|XD_STATUS
)paren
op_amp
(paren
id|STAT_COMMAND
op_or
id|STAT_INPUT
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|mode
op_eq
id|DMA_MODE
)paren
(brace
id|enable_dma
c_func
(paren
id|xd_dma
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|xd_wait_int
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|xd_dma
)paren
suffix:semicolon
)brace
r_else
id|outb
c_func
(paren
id|outdata
ques
c_cond
op_star
id|outdata
op_increment
suffix:colon
l_int|0
comma
id|XD_DATA
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STAT_INPUT
suffix:colon
r_if
c_cond
(paren
id|mode
op_eq
id|DMA_MODE
)paren
(brace
id|enable_dma
c_func
(paren
id|xd_dma
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|xd_wait_int
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|xd_dma
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|indata
)paren
op_star
id|indata
op_increment
op_assign
id|inb
c_func
(paren
id|XD_DATA
)paren
suffix:semicolon
r_else
id|inb
c_func
(paren
id|XD_DATA
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STAT_COMMAND
suffix:colon
id|outb
c_func
(paren
id|command
ques
c_cond
op_star
id|command
op_increment
suffix:colon
l_int|0
comma
id|XD_DATA
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STAT_COMMAND
op_or
id|STAT_INPUT
suffix:colon
id|complete
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|csb
op_assign
id|inb
c_func
(paren
id|XD_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xd_waitport
c_func
(paren
id|XD_STATUS
comma
l_int|0
comma
id|STAT_SELECT
comma
id|timeout
)paren
)paren
multiline_comment|/* wait until deselected */
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|csb
op_amp
id|CSB_ERROR
)paren
(brace
multiline_comment|/* read sense data if error */
id|xd_build
c_func
(paren
id|cmdblk
comma
id|CMD_SENSE
comma
(paren
id|csb
op_amp
id|CSB_LUN
)paren
op_rshift
l_int|5
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xd_command
c_func
(paren
id|cmdblk
comma
l_int|0
comma
id|sense
comma
l_int|0
comma
l_int|0
comma
id|XD_TIMEOUT
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;xd_command: warning! sense command failed!&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_COMMAND
id|printk
c_func
(paren
l_string|&quot;xd_command: completed with csb = 0x%X&bslash;n&quot;
comma
id|csb
)paren
suffix:semicolon
macro_line|#endif DEBUG_COMMAND
r_return
(paren
id|csb
op_amp
id|CSB_ERROR
)paren
suffix:semicolon
)brace
DECL|function|xd_initdrives
r_static
id|u_char
id|xd_initdrives
(paren
r_void
(paren
op_star
id|init_drive
)paren
(paren
id|u_char
id|drive
)paren
)paren
(brace
id|u_char
id|cmdblk
(braket
l_int|6
)braket
comma
id|i
comma
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|XD_MAXDRIVES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|xd_build
c_func
(paren
id|cmdblk
comma
id|CMD_TESTREADY
comma
id|i
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xd_command
c_func
(paren
id|cmdblk
comma
id|PIO_MODE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|XD_TIMEOUT
op_star
l_int|2
)paren
)paren
(brace
id|init_drive
c_func
(paren
id|count
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
)brace
r_return
(paren
id|count
)paren
suffix:semicolon
)brace
macro_line|#ifndef XD_OVERRIDE
DECL|function|xd_dtc5150x_init_controller
r_static
r_void
id|xd_dtc5150x_init_controller
(paren
id|u_char
op_star
id|address
)paren
(brace
r_switch
c_cond
(paren
(paren
id|u_long
)paren
id|address
)paren
(brace
r_case
l_int|0xC8000
suffix:colon
id|xd_iobase
op_assign
l_int|0x320
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xCA000
suffix:colon
id|xd_iobase
op_assign
l_int|0x324
suffix:semicolon
r_break
suffix:semicolon
)brace
id|xd_irq
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* the IRQ _can_ be changed on this card, but requires a hardware mod */
id|xd_dma
op_assign
l_int|3
suffix:semicolon
id|xd_maxsectors
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* my card seems to have trouble doing multi-block transfers? */
id|outb
c_func
(paren
l_int|0
comma
id|XD_RESET
)paren
suffix:semicolon
multiline_comment|/* reset the controller */
)brace
DECL|function|xd_dtc5150x_init_drive
r_static
r_void
id|xd_dtc5150x_init_drive
(paren
id|u_char
id|drive
)paren
(brace
id|u_char
id|cmdblk
(braket
l_int|6
)braket
comma
id|buf
(braket
l_int|64
)braket
suffix:semicolon
id|xd_build
c_func
(paren
id|cmdblk
comma
id|CMD_DTCGETGEOM
comma
id|drive
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xd_command
c_func
(paren
id|cmdblk
comma
id|PIO_MODE
comma
id|buf
comma
l_int|0
comma
l_int|0
comma
id|XD_TIMEOUT
op_star
l_int|2
)paren
)paren
(brace
id|xd_info
(braket
id|drive
)braket
dot
id|heads
op_assign
id|buf
(braket
l_int|0x0A
)braket
suffix:semicolon
multiline_comment|/* heads */
id|xd_info
(braket
id|drive
)braket
dot
id|cylinders
op_assign
(paren
(paren
id|u_short
op_star
)paren
(paren
id|buf
)paren
)paren
(braket
l_int|0x04
)braket
suffix:semicolon
multiline_comment|/* cylinders */
id|xd_info
(braket
id|drive
)braket
dot
id|sectors
op_assign
l_int|17
suffix:semicolon
multiline_comment|/* sectors */
macro_line|#if 0
id|xd_info
(braket
id|drive
)braket
dot
id|rwrite
op_assign
(paren
(paren
id|u_short
op_star
)paren
(paren
id|buf
op_plus
l_int|1
)paren
)paren
(braket
l_int|0x05
)braket
suffix:semicolon
multiline_comment|/* reduced write */
id|xd_info
(braket
id|drive
)braket
dot
id|precomp
op_assign
(paren
(paren
id|u_short
op_star
)paren
(paren
id|buf
op_plus
l_int|1
)paren
)paren
(braket
l_int|0x06
)braket
suffix:semicolon
multiline_comment|/* write precomp */
id|xd_info
(braket
id|drive
)braket
dot
id|ecc
op_assign
id|buf
(braket
l_int|0x0F
)braket
suffix:semicolon
multiline_comment|/* ecc length */
macro_line|#endif 0
id|xd_info
(braket
id|drive
)braket
dot
id|control
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* control byte */
id|xd_setparam
c_func
(paren
id|CMD_DTCSETPARAM
comma
id|drive
comma
id|xd_info
(braket
id|drive
)braket
dot
id|heads
comma
id|xd_info
(braket
id|drive
)braket
dot
id|cylinders
comma
(paren
(paren
id|u_short
op_star
)paren
(paren
id|buf
op_plus
l_int|1
)paren
)paren
(braket
l_int|0x05
)braket
comma
(paren
(paren
id|u_short
op_star
)paren
(paren
id|buf
op_plus
l_int|1
)paren
)paren
(braket
l_int|0x06
)braket
comma
id|buf
(braket
l_int|0x0F
)braket
)paren
suffix:semicolon
id|xd_build
c_func
(paren
id|cmdblk
comma
id|CMD_DTCSETSTEP
comma
id|drive
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xd_command
c_func
(paren
id|cmdblk
comma
id|PIO_MODE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|XD_TIMEOUT
op_star
l_int|2
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;xd_dtc5150x_init_drive: error setting step rate for drive %d&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;xd_dtc5150x_init_drive: error reading geometry for drive %d&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
)brace
DECL|function|xd_wd1004a27x_init_controller
r_static
r_void
id|xd_wd1004a27x_init_controller
(paren
id|u_char
op_star
id|address
)paren
(brace
r_switch
c_cond
(paren
(paren
id|u_long
)paren
id|address
)paren
(brace
r_case
l_int|0xC8000
suffix:colon
id|xd_iobase
op_assign
l_int|0x320
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xCA000
suffix:colon
id|xd_iobase
op_assign
l_int|0x324
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xD0000
suffix:colon
id|xd_iobase
op_assign
l_int|0x328
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xD8000
suffix:colon
id|xd_iobase
op_assign
l_int|0x32C
suffix:semicolon
r_break
suffix:semicolon
)brace
id|xd_irq
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* don&squot;t know how to auto-detect this yet */
id|xd_dma
op_assign
l_int|3
suffix:semicolon
id|xd_maxsectors
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* this one doesn&squot;t wrap properly either... */
id|outb
c_func
(paren
l_int|0
comma
id|XD_RESET
)paren
suffix:semicolon
multiline_comment|/* reset the controller */
)brace
DECL|function|xd_wd1004a27x_init_drive
r_static
r_void
id|xd_wd1004a27x_init_drive
(paren
id|u_char
id|drive
)paren
(brace
id|u_char
id|cmdblk
(braket
l_int|6
)braket
comma
id|buf
(braket
l_int|0x200
)braket
suffix:semicolon
id|xd_build
c_func
(paren
id|cmdblk
comma
id|CMD_READ
comma
id|drive
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xd_command
c_func
(paren
id|cmdblk
comma
id|PIO_MODE
comma
id|buf
comma
l_int|0
comma
l_int|0
comma
id|XD_TIMEOUT
op_star
l_int|2
)paren
)paren
(brace
id|xd_info
(braket
id|drive
)braket
dot
id|heads
op_assign
id|buf
(braket
l_int|0x1AF
)braket
suffix:semicolon
multiline_comment|/* heads */
id|xd_info
(braket
id|drive
)braket
dot
id|cylinders
op_assign
(paren
(paren
id|u_short
op_star
)paren
(paren
id|buf
op_plus
l_int|1
)paren
)paren
(braket
l_int|0xD6
)braket
suffix:semicolon
multiline_comment|/* cylinders */
id|xd_info
(braket
id|drive
)braket
dot
id|sectors
op_assign
l_int|17
suffix:semicolon
multiline_comment|/* sectors */
macro_line|#if 0
id|xd_info
(braket
id|drive
)braket
dot
id|rwrite
op_assign
(paren
(paren
id|u_short
op_star
)paren
(paren
id|buf
)paren
)paren
(braket
l_int|0xD8
)braket
suffix:semicolon
multiline_comment|/* reduced write */
id|xd_info
(braket
id|drive
)braket
dot
id|wprecomp
op_assign
(paren
(paren
id|u_short
op_star
)paren
(paren
id|buf
)paren
)paren
(braket
l_int|0xDA
)braket
suffix:semicolon
multiline_comment|/* write precomp */
id|xd_info
(braket
id|drive
)braket
dot
id|ecc
op_assign
id|buf
(braket
l_int|0x1B4
)braket
suffix:semicolon
multiline_comment|/* ecc length */
macro_line|#endif 0
id|xd_info
(braket
id|drive
)braket
dot
id|control
op_assign
id|buf
(braket
l_int|0x1B5
)braket
suffix:semicolon
multiline_comment|/* control byte */
id|xd_setparam
c_func
(paren
id|CMD_WDSETPARAM
comma
id|drive
comma
id|xd_info
(braket
id|drive
)braket
dot
id|heads
comma
id|xd_info
(braket
id|drive
)braket
dot
id|cylinders
comma
(paren
(paren
id|u_short
op_star
)paren
(paren
id|buf
)paren
)paren
(braket
l_int|0xD8
)braket
comma
(paren
(paren
id|u_short
op_star
)paren
(paren
id|buf
)paren
)paren
(braket
l_int|0xDA
)braket
comma
id|buf
(braket
l_int|0x1B4
)braket
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;xd_wd1004a27x_init_drive: error reading geometry for drive %d&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
)brace
DECL|function|xd_seagate11_init_controller
r_static
r_void
id|xd_seagate11_init_controller
(paren
id|u_char
op_star
id|address
)paren
(brace
r_switch
c_cond
(paren
(paren
id|u_long
)paren
id|address
)paren
(brace
r_case
l_int|0xC8000
suffix:colon
id|xd_iobase
op_assign
l_int|0x320
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xD0000
suffix:colon
id|xd_iobase
op_assign
l_int|0x324
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xD8000
suffix:colon
id|xd_iobase
op_assign
l_int|0x328
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xE0000
suffix:colon
id|xd_iobase
op_assign
l_int|0x32C
suffix:semicolon
r_break
suffix:semicolon
)brace
id|xd_irq
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* the IRQ and DMA channel are fixed on the Seagate controllers */
id|xd_dma
op_assign
l_int|3
suffix:semicolon
id|xd_maxsectors
op_assign
l_int|0x40
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|XD_RESET
)paren
suffix:semicolon
multiline_comment|/* reset the controller */
)brace
DECL|function|xd_seagate11_init_drive
r_static
r_void
id|xd_seagate11_init_drive
(paren
id|u_char
id|drive
)paren
(brace
id|u_char
id|cmdblk
(braket
l_int|6
)braket
comma
id|buf
(braket
l_int|0x200
)braket
suffix:semicolon
id|xd_build
c_func
(paren
id|cmdblk
comma
id|CMD_ST11GETGEOM
comma
id|drive
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xd_command
c_func
(paren
id|cmdblk
comma
id|PIO_MODE
comma
id|buf
comma
l_int|0
comma
l_int|0
comma
id|XD_TIMEOUT
op_star
l_int|2
)paren
)paren
(brace
id|xd_info
(braket
id|drive
)braket
dot
id|heads
op_assign
id|buf
(braket
l_int|0x04
)braket
suffix:semicolon
multiline_comment|/* heads */
id|xd_info
(braket
id|drive
)braket
dot
id|cylinders
op_assign
(paren
id|buf
(braket
l_int|0x02
)braket
op_lshift
l_int|8
)paren
op_or
id|buf
(braket
l_int|0x03
)braket
suffix:semicolon
multiline_comment|/* cylinders */
id|xd_info
(braket
id|drive
)braket
dot
id|sectors
op_assign
id|buf
(braket
l_int|0x05
)braket
suffix:semicolon
multiline_comment|/* sectors */
id|xd_info
(braket
id|drive
)braket
dot
id|control
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* control byte */
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;xd_seagate11_init_drive: error reading geometry from drive %d&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
)brace
macro_line|#endif XD_OVERRIDE
multiline_comment|/* xd_override_init_controller: sets appropriate values for unknown controllers. */
DECL|function|xd_override_init_controller
r_static
r_void
id|xd_override_init_controller
(paren
id|u_char
op_star
id|address
)paren
(brace
id|xd_iobase
op_assign
l_int|0x320
suffix:semicolon
multiline_comment|/* standard setting */
id|xd_irq
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* ditto */
id|xd_dma
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* ditto */
id|xd_maxsectors
op_assign
l_int|0x01
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|XD_RESET
)paren
suffix:semicolon
multiline_comment|/* reset the controller */
)brace
multiline_comment|/* xd_override_init_drive: this finds disk geometry in a &quot;binary search&quot; style, narrowing in on the &quot;correct&quot; number of heads&n;   etc. by trying values until it gets the highest successful value. Idea courtesy Salvador Abreu (spa@fct.unl.pt). */
DECL|function|xd_override_init_drive
r_static
r_void
id|xd_override_init_drive
(paren
id|u_char
id|drive
)paren
(brace
id|u_short
id|min
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
id|max
(braket
)braket
op_assign
(brace
l_int|16
comma
l_int|1024
comma
l_int|64
)brace
comma
id|test
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|u_char
id|cmdblk
(braket
l_int|6
)braket
comma
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
r_while
c_loop
(paren
id|min
(braket
id|i
)braket
op_ne
id|max
(braket
id|i
)braket
op_minus
l_int|1
)paren
(brace
id|test
(braket
id|i
)braket
op_assign
(paren
id|min
(braket
id|i
)braket
op_plus
id|max
(braket
id|i
)braket
)paren
op_div
l_int|2
suffix:semicolon
id|xd_build
c_func
(paren
id|cmdblk
comma
id|CMD_SEEK
comma
id|drive
comma
(paren
id|u_char
)paren
id|test
(braket
l_int|0
)braket
comma
(paren
id|u_short
)paren
id|test
(braket
l_int|1
)braket
comma
(paren
id|u_char
)paren
id|test
(braket
l_int|2
)braket
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xd_command
c_func
(paren
id|cmdblk
comma
id|PIO_MODE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|XD_TIMEOUT
op_star
l_int|2
)paren
)paren
id|min
(braket
id|i
)braket
op_assign
id|test
(braket
id|i
)braket
suffix:semicolon
r_else
id|max
(braket
id|i
)braket
op_assign
id|test
(braket
id|i
)braket
suffix:semicolon
)brace
id|test
(braket
id|i
)braket
op_assign
id|min
(braket
id|i
)braket
suffix:semicolon
)brace
id|xd_info
(braket
id|drive
)braket
dot
id|heads
op_assign
(paren
id|u_char
)paren
id|min
(braket
l_int|0
)braket
op_plus
l_int|1
suffix:semicolon
id|xd_info
(braket
id|drive
)braket
dot
id|cylinders
op_assign
(paren
id|u_short
)paren
id|min
(braket
l_int|1
)braket
op_plus
l_int|1
suffix:semicolon
id|xd_info
(braket
id|drive
)braket
dot
id|sectors
op_assign
(paren
id|u_char
)paren
id|min
(braket
l_int|2
)braket
op_plus
l_int|1
suffix:semicolon
id|xd_info
(braket
id|drive
)braket
dot
id|control
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifndef XD_OVERRIDE
multiline_comment|/* xd_setparam: set the drive characteristics */
DECL|function|xd_setparam
r_static
r_void
id|xd_setparam
(paren
id|u_char
id|command
comma
id|u_char
id|drive
comma
id|u_char
id|heads
comma
id|u_short
id|cylinders
comma
id|u_short
id|rwrite
comma
id|u_short
id|wprecomp
comma
id|u_char
id|ecc
)paren
(brace
id|u_char
id|cmdblk
(braket
l_int|14
)braket
suffix:semicolon
id|xd_build
c_func
(paren
id|cmdblk
comma
id|command
comma
id|drive
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|cmdblk
(braket
l_int|6
)braket
op_assign
(paren
id|u_char
)paren
(paren
id|cylinders
op_rshift
l_int|8
)paren
op_amp
l_int|0x03
suffix:semicolon
id|cmdblk
(braket
l_int|7
)braket
op_assign
(paren
id|u_char
)paren
(paren
id|cylinders
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|cmdblk
(braket
l_int|8
)braket
op_assign
id|heads
op_amp
l_int|0x1F
suffix:semicolon
id|cmdblk
(braket
l_int|9
)braket
op_assign
(paren
id|u_char
)paren
(paren
id|rwrite
op_rshift
l_int|8
)paren
op_amp
l_int|0x03
suffix:semicolon
id|cmdblk
(braket
l_int|10
)braket
op_assign
(paren
id|u_char
)paren
(paren
id|rwrite
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|cmdblk
(braket
l_int|11
)braket
op_assign
(paren
id|u_char
)paren
(paren
id|wprecomp
op_rshift
l_int|8
)paren
op_amp
l_int|0x03
suffix:semicolon
id|cmdblk
(braket
l_int|12
)braket
op_assign
(paren
id|u_char
)paren
(paren
id|wprecomp
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|cmdblk
(braket
l_int|13
)braket
op_assign
id|ecc
suffix:semicolon
r_if
c_cond
(paren
id|xd_command
c_func
(paren
id|cmdblk
comma
id|PIO_MODE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|XD_TIMEOUT
op_star
l_int|2
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;xd_setparam: error setting characteristics for drive %d&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
)brace
macro_line|#endif XD_OVERRIDE
macro_line|#endif CONFIG_BLK_DEV_XD
eof
