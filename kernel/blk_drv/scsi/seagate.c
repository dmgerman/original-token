multiline_comment|/*&n; *&t;seagate.c Copyright (C) 1992 Drew Eckhardt &n; *&t;low level scsi driver for ST01/ST02 by&n; *&t;&t;Drew Eckhardt &n; *&n; *&t;&lt;drew@colorado.edu&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#if defined(CONFIG_SCSI_SEAGATE) || defined(CONFIG_SCSI_FD_88x) 
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &quot;../blk.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;seagate.h&quot;
r_static
r_int
id|internal_command
c_func
(paren
r_int
r_char
id|target
comma
r_int
r_char
id|lun
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buff
comma
r_int
id|bufflen
comma
r_int
id|reselect
)paren
suffix:semicolon
DECL|variable|incommand
r_static
r_int
id|incommand
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;set if arbitration has finished and we are &n;&t;&t;&t;&t;&t;&t;in some command phase.&n;&t;&t;&t;&t;&t;*/
DECL|variable|base_address
r_static
r_void
op_star
id|base_address
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;Where the card ROM starts,&n;&t;&t;&t;&t;&t;&t;used to calculate memory mapped&n;&t;&t;&t;&t;&t;&t;register location.&n;&t;&t;&t;&t;&t;*/
DECL|variable|abort_confirm
r_static
r_volatile
r_int
id|abort_confirm
op_assign
l_int|0
suffix:semicolon
DECL|variable|st0x_cr_sr
r_static
r_volatile
r_void
op_star
id|st0x_cr_sr
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;control register write,&n;&t;&t;&t;&t;&t;&t;status register read.&n;&t;&t;&t;&t;&t;&t;256 bytes in length.&n;&n;&t;&t;&t;&t;&t;&t;Read is status of SCSI BUS,&n;&t;&t;&t;&t;&t;&t;as per STAT masks.&n;&n;&t;&t;&t;&t;&t;*/
DECL|variable|st0x_dr
r_static
r_volatile
r_void
op_star
id|st0x_dr
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;data register, read write&n;&t;&t;&t;&t;&t;&t;256 bytes in length.&n;&t;&t;&t;&t;&t;*/
DECL|variable|st0x_aborted
r_static
r_volatile
r_int
id|st0x_aborted
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;set when we are aborted, ie by a time out, etc.&n;&t;&t;&t;&t;&t;*/
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;In theory, we have a nice auto&n;&t;&t;&t;&t;&t;&t;detect routine - but this &n;&t;&t;&t;&t;&t;&t;overides it. &n;&t;&t;&t;&t;&t;*/
DECL|macro|retcode
mdefine_line|#define retcode(result) (((result) &lt;&lt; 16) | (message &lt;&lt; 8) | status) &t;&t;&t;
DECL|macro|STATUS
mdefine_line|#define STATUS (*(unsigned char *) st0x_cr_sr)
DECL|macro|CONTROL
mdefine_line|#define CONTROL STATUS 
DECL|macro|DATA
mdefine_line|#define DATA (*(unsigned char *) st0x_dr)
macro_line|#ifndef OVERRIDE&t;&t;
DECL|variable|seagate_bases
r_static
r_const
r_char
op_star
id|seagate_bases
(braket
)braket
op_assign
(brace
(paren
r_char
op_star
)paren
l_int|0xc8000
comma
(paren
r_char
op_star
)paren
l_int|0xca000
comma
(paren
r_char
op_star
)paren
l_int|0xcc000
comma
(paren
r_char
op_star
)paren
l_int|0xce000
comma
(paren
r_char
op_star
)paren
l_int|0xce000
comma
(paren
r_char
op_star
)paren
l_int|0xdc000
comma
(paren
r_char
op_star
)paren
l_int|0xde000
)brace
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|signature
r_char
op_star
id|signature
suffix:semicolon
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|typedef|Signature
)brace
id|Signature
suffix:semicolon
DECL|variable|signatures
r_static
r_const
id|Signature
id|signatures
(braket
)braket
op_assign
(brace
macro_line|#ifdef CONFIG_SCSI_SEAGATE
(brace
l_string|&quot;SCSI BIOS 2.00  (C) Copyright 1987 Seagate&quot;
comma
l_int|15
comma
l_int|40
)brace
comma
multiline_comment|/*&n;&t;The following two lines are NOT mistakes.  One detects &n; &t;ROM revision 3.0.0, the other 3.2.  Since seagate&n;&t;has only one type of SCSI adapter, and this is not &n;&t;going to change, the &quot;SEAGATE&quot; and &quot;SCSI&quot; together&n;&t;are probably &quot;good enough&quot;&n;*/
(brace
l_string|&quot;SEAGATE SCSI BIOS &quot;
comma
l_int|16
comma
l_int|17
)brace
comma
(brace
l_string|&quot;SEAGATE SCSI BIOS &quot;
comma
l_int|17
comma
l_int|17
)brace
comma
macro_line|#endif
multiline_comment|/*&n;&t;This is for the Future Domain 88x series.  I&squot;ve been told that&n;&t;the Seagate controllers are just repackages of these, and seeing&n;&t;early seagate BIOS bearing the Future Domain copyright,&n;&t;I believe it.&n;*/
macro_line|#ifdef CONFIG_SCSI_FD_88x
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1989 V6.0A7/28/90&quot;
comma
l_int|5
comma
l_int|46
)brace
comma
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/*&n;&t;Note that the last signature handles BIOS revisions 3.0.0 and &n;&t;3.2 - the real ID&squot;s are &n;&n;SEAGATE SCSI BIOS REVISION 3.0.0&n;SEAGATE SCSI BIOS REVISION 3.2&n;&n;*/
DECL|macro|NUM_SIGNATURES
mdefine_line|#define NUM_SIGNATURES (sizeof(signatures) / sizeof(Signature))
macro_line|#endif
multiline_comment|/*&n; * hostno stores the hostnumber, as told to us by the init routine.&n; */
DECL|variable|hostno
r_static
r_int
id|hostno
op_assign
op_minus
l_int|1
suffix:semicolon
r_static
r_void
id|seagate_reconnect_intr
c_func
(paren
r_int
)paren
suffix:semicolon
DECL|function|seagate_st0x_detect
r_int
id|seagate_st0x_detect
(paren
r_int
id|hostnum
)paren
(brace
macro_line|#ifndef OVERRIDE
r_int
id|i
comma
id|j
suffix:semicolon
macro_line|#endif
r_static
r_struct
id|sigaction
id|seagate_sigaction
op_assign
(brace
op_amp
id|seagate_reconnect_intr
comma
l_int|0
comma
id|SA_INTERRUPT
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;First, we try for the manual override.&n; */
macro_line|#ifdef DEBUG 
id|printk
c_func
(paren
l_string|&quot;Autodetecting seagate ST0x&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|hostno
op_ne
op_minus
l_int|1
)paren
(brace
id|printk
(paren
l_string|&quot;ERROR : seagate_st0x_detect() called twice.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|base_address
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef OVERRIDE
id|base_address
op_assign
(paren
r_void
op_star
)paren
id|OVERRIDE
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Base address overridden to %x&bslash;n&quot;
comma
id|base_address
)paren
suffix:semicolon
macro_line|#endif
macro_line|#else&t;
multiline_comment|/*&n; *&t;To detect this card, we simply look for the signature&n; *&t;from the BIOS version notice in all the possible locations&n; *&t;of the ROM&squot;s.  This has a nice sideeffect of not trashing&n; * &t;any register locations that might be used by something else.&n; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_sizeof
(paren
id|seagate_bases
)paren
op_div
r_sizeof
(paren
r_char
op_star
)paren
)paren
suffix:semicolon
op_increment
id|i
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|base_address
op_logical_and
id|j
OL
id|NUM_SIGNATURES
suffix:semicolon
op_increment
id|j
)paren
r_if
c_cond
(paren
op_logical_neg
id|memcmp
(paren
(paren
r_void
op_star
)paren
(paren
id|seagate_bases
(braket
id|i
)braket
op_plus
id|signatures
(braket
id|j
)braket
dot
id|offset
)paren
comma
(paren
r_void
op_star
)paren
id|signatures
(braket
id|j
)braket
dot
id|signature
comma
id|signatures
(braket
id|j
)braket
dot
id|length
)paren
)paren
id|base_address
op_assign
(paren
r_void
op_star
)paren
id|seagate_bases
(braket
id|i
)braket
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|base_address
)paren
(brace
id|st0x_cr_sr
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|base_address
)paren
op_plus
l_int|0x1a00
)paren
suffix:semicolon
id|st0x_dr
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|base_address
)paren
op_plus
l_int|0x1c00
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;ST0x detected. Base address = %x, cr = %x, dr = %x&bslash;n&quot;
comma
id|base_address
comma
id|st0x_cr_sr
comma
id|st0x_dr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;At all times, we will use IRQ 5.  &n; */
id|hostno
op_assign
id|hostnum
suffix:semicolon
r_if
c_cond
(paren
id|irqaction
c_func
(paren
l_int|5
comma
op_amp
id|seagate_sigaction
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to allocate IRQ5 for ST0x driver&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;ST0x not detected.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|seagate_st0x_info
r_const
r_char
op_star
id|seagate_st0x_info
c_func
(paren
r_void
)paren
(brace
r_static
r_char
id|buffer
(braket
)braket
op_assign
l_string|&quot;Seagate ST-0X SCSI driver by Drew Eckhardt &bslash;n&quot;
l_string|&quot;$Header: /usr/src/linux/kernel/blk_drv/scsi/RCS/seagate.c,v 1.1 1992/07/24 06:27:38 root Exp root $&bslash;n&quot;
suffix:semicolon
r_return
id|buffer
suffix:semicolon
)brace
multiline_comment|/*&n; * These are our saved pointers for the outstanding command that is &n; * waiting for a reconnect&n; */
DECL|variable|current_target
DECL|variable|current_lun
r_static
r_int
r_char
id|current_target
comma
id|current_lun
suffix:semicolon
DECL|variable|current_cmnd
DECL|variable|current_data
r_static
r_int
r_char
op_star
id|current_cmnd
comma
op_star
id|current_data
suffix:semicolon
DECL|variable|current_bufflen
r_static
r_int
id|current_bufflen
suffix:semicolon
DECL|variable|done_fn
r_static
r_void
(paren
op_star
id|done_fn
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|SCint
r_static
id|Scsi_Cmnd
op_star
id|SCint
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * These control whether or not disconnect / reconnect will be attempted,&n; * or are being attempted.&n; */
DECL|macro|NO_RECONNECT
mdefine_line|#define NO_RECONNECT &t;0
DECL|macro|RECONNECT_NOW
mdefine_line|#define RECONNECT_NOW &t;1
DECL|macro|CAN_RECONNECT
mdefine_line|#define CAN_RECONNECT&t;2
multiline_comment|/*&n; * This determines if we are expecting to reconnect or not.&n; */
DECL|variable|should_reconnect
r_static
r_int
id|should_reconnect
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * The seagate_reconnect_intr routine is called when a target reselects the &n; * host adapter.  This occurs on the interrupt triggered by the target &n; * asserting SEL.&n; */
DECL|function|seagate_reconnect_intr
r_static
r_void
id|seagate_reconnect_intr
(paren
r_int
id|unused
)paren
(brace
r_int
id|temp
suffix:semicolon
multiline_comment|/* enable all other interrupts. */
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if (DEBUG &amp; PHASE_RESELECT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : seagate_reconnect_intr() called&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|should_reconnect
)paren
id|printk
c_func
(paren
l_string|&quot;scsi%d: unexpected interrupt.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_else
(brace
id|should_reconnect
op_assign
l_int|0
suffix:semicolon
macro_line|#if (DEBUG &amp; PHASE_RESELECT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : internal_command(&quot;
l_string|&quot;%d, %08x, %08x, %d, RECONNECT_NOW&bslash;n&quot;
comma
id|hostno
comma
id|current_target
comma
id|current_data
comma
id|current_bufflen
)paren
suffix:semicolon
macro_line|#endif
id|temp
op_assign
id|internal_command
(paren
id|current_target
comma
id|current_lun
comma
id|current_cmnd
comma
id|current_data
comma
id|current_bufflen
comma
id|RECONNECT_NOW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg_byte
c_func
(paren
id|temp
)paren
op_ne
id|DISCONNECT
)paren
(brace
r_if
c_cond
(paren
id|done_fn
)paren
(brace
macro_line|#if (DEBUG &amp; PHASE_RESELECT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : done_fn(%d,%08x)&quot;
comma
id|hostno
comma
id|hostno
comma
id|temp
)paren
suffix:semicolon
macro_line|#endif
id|SCint-&gt;result
op_assign
id|temp
suffix:semicolon
id|done_fn
(paren
id|SCint
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;done_fn() not defined.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* &n; * The seagate_st0x_queue_command() function provides a queued interface&n; * to the seagate SCSI driver.  Basically, it just passes control onto the&n; * seagate_command() function, after fixing it so that the done_fn()&n; * is set to the one passed to the function.&n; */
DECL|function|seagate_st0x_queue_command
r_int
id|seagate_st0x_queue_command
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
id|result
suffix:semicolon
id|done_fn
op_assign
id|done
suffix:semicolon
id|current_target
op_assign
id|SCpnt-&gt;target
suffix:semicolon
id|current_lun
op_assign
id|SCpnt-&gt;lun
suffix:semicolon
(paren
r_const
r_void
op_star
)paren
id|current_cmnd
op_assign
id|SCpnt-&gt;cmnd
suffix:semicolon
id|current_data
op_assign
id|SCpnt-&gt;request_buffer
suffix:semicolon
id|current_bufflen
op_assign
id|SCpnt-&gt;request_bufflen
suffix:semicolon
id|SCint
op_assign
id|SCpnt
suffix:semicolon
id|result
op_assign
id|internal_command
(paren
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;request_buffer
comma
id|SCpnt-&gt;request_bufflen
comma
id|CAN_RECONNECT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg_byte
c_func
(paren
id|result
)paren
op_eq
id|DISCONNECT
)paren
r_return
l_int|0
suffix:semicolon
r_else
(brace
id|SCpnt-&gt;result
op_assign
id|result
suffix:semicolon
id|done_fn
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|seagate_st0x_command
r_int
id|seagate_st0x_command
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_return
id|internal_command
(paren
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;lun
comma
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;request_buffer
comma
id|SCpnt-&gt;request_bufflen
comma
(paren
r_int
)paren
id|NO_RECONNECT
)paren
suffix:semicolon
)brace
DECL|function|internal_command
r_static
r_int
id|internal_command
c_func
(paren
r_int
r_char
id|target
comma
r_int
r_char
id|lun
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buff
comma
r_int
id|bufflen
comma
r_int
id|reselect
)paren
(brace
r_int
id|len
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
id|clock
suffix:semicolon
r_int
id|temp
suffix:semicolon
macro_line|#if ((DEBUG &amp; PHASE_ETC) || (DEBUG &amp; PRINT_COMMAND) || (DEBUG &amp; PHASE_EXIT))&t;
r_int
id|i
suffix:semicolon
macro_line|#endif
macro_line|#if (DEBUG &amp; PHASE_ETC)
r_int
id|phase
op_assign
l_int|0
comma
id|newphase
suffix:semicolon
macro_line|#endif
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|status
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|message
op_assign
l_int|0
suffix:semicolon
r_register
r_int
r_char
id|status_read
suffix:semicolon
id|len
op_assign
id|bufflen
suffix:semicolon
id|data
op_assign
(paren
r_int
r_char
op_star
)paren
id|buff
suffix:semicolon
id|incommand
op_assign
l_int|0
suffix:semicolon
id|st0x_aborted
op_assign
l_int|0
suffix:semicolon
macro_line|#if (DEBUG &amp; PRINT_COMMAND)
id|printk
(paren
l_string|&quot;scsi%d : target = %d, command = &quot;
comma
id|hostno
comma
id|target
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|COMMAND_SIZE
c_func
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|cmnd
)paren
(braket
l_int|0
)braket
)paren
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|cmnd
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if (DEBUG &amp; PHASE_RESELECT)
r_switch
c_cond
(paren
id|reselect
)paren
(brace
r_case
id|RECONNECT_NOW
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : reconnecting&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CAN_RECONNECT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : allowed to reconnect&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : not allowed to reconnect&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|target
OG
l_int|6
)paren
r_return
id|DID_BAD_TARGET
suffix:semicolon
multiline_comment|/*&n; *&t;We work it differently depending on if this is is &quot;the first time,&quot;&n; *&t;or a reconnect.  If this is a reselct phase, then SEL will &n; *&t;be asserted, and we must skip selection / arbitration phases.&n; */
r_if
c_cond
(paren
id|reselect
op_eq
id|RECONNECT_NOW
)paren
(brace
macro_line|#if (DEBUG &amp; PHASE_RESELECT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase RESELECT &bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;At this point, we should find the logical or of our ID and the original&n; *&t;target&squot;s ID on the BUS, with BSY, SEL, and I/O signals asserted.&n; *&n; *&t;After ARBITRATION phase is completed, only SEL, BSY, and the &n; *&t;target ID are asserted.  A valid initator ID is not on the bus&n; *&t;until IO is asserted, so we must wait for that.&n; */
r_for
c_loop
(paren
id|clock
op_assign
id|jiffies
op_plus
l_int|10
comma
id|temp
op_assign
l_int|0
suffix:semicolon
(paren
id|jiffies
OL
id|clock
)paren
op_logical_and
op_logical_neg
(paren
id|STATUS
op_amp
id|STAT_IO
)paren
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
op_ge
id|clock
)paren
(brace
macro_line|#if (DEBUG &amp; PHASE_RESELECT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : RESELECT timed out while waiting for IO .&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|DID_BAD_INTR
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * &t;After I/O is asserted by the target, we can read our ID and its&n; *&t;ID off of the BUS.&n; */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|temp
op_assign
id|DATA
)paren
op_amp
l_int|0x80
)paren
)paren
(brace
macro_line|#if (DEBUG &amp; PHASE_RESELECT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : detected reconnect request to different target.&bslash;n&quot;
l_string|&quot;&bslash;tData bus = %d&bslash;n&quot;
comma
id|hostno
comma
id|temp
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|DID_BAD_INTR
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|temp
op_amp
(paren
l_int|1
op_lshift
id|current_target
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scsi%d : Unexpected reselect interrupt.  Data bus = %d&bslash;n&quot;
comma
id|hostno
comma
id|temp
)paren
suffix:semicolon
r_return
(paren
id|DID_BAD_INTR
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
id|data
op_assign
id|current_data
suffix:semicolon
multiline_comment|/* WDE add */
id|cmnd
op_assign
id|current_cmnd
suffix:semicolon
multiline_comment|/* WDE add */
id|len
op_assign
id|current_bufflen
suffix:semicolon
multiline_comment|/* WDE add */
multiline_comment|/*&n; * &t;We have determined that we have been selected.  At this point, &n; *&t;we must respond to the reselection by asserting BSY ourselves&n; */
id|CONTROL
op_assign
(paren
id|BASE_CMD
op_or
id|CMD_DRVR_ENABLE
op_or
id|CMD_BSY
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;The target will drop SEL, and raise BSY, at which time we must drop&n; *&t;BSY.&n; */
r_for
c_loop
(paren
id|clock
op_assign
id|jiffies
op_plus
l_int|10
suffix:semicolon
(paren
id|jiffies
OL
id|clock
)paren
op_logical_and
(paren
id|STATUS
op_amp
id|STAT_SEL
)paren
suffix:semicolon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
op_ge
id|clock
)paren
(brace
id|CONTROL
op_assign
(paren
id|BASE_CMD
op_or
id|CMD_INTR
)paren
suffix:semicolon
macro_line|#if (DEBUG &amp; PHASE_RESELECT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : RESELECT timed out while waiting for SEL.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|DID_BAD_INTR
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
id|CONTROL
op_assign
id|BASE_CMD
suffix:semicolon
multiline_comment|/*&n; *&t;At this point, we have connected with the target and can get &n; *&t;on with our lives.&n; */
)brace
r_else
(brace
macro_line|#if (DEBUG &amp; PHASE_BUS_FREE)
id|printk
(paren
l_string|&quot;scsi%d : phase = BUS FREE &bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;BUS FREE PHASE&n; *&n; * &t;On entry, we make sure that the BUS is in a BUS FREE&n; *&t;phase, by insuring that both BSY and SEL are low for&n; *&t;at least one bus settle delay.  Several reads help&n; *&t;eliminate wire glitch.&n; */
id|clock
op_assign
id|jiffies
op_plus
id|ST0X_BUS_FREE_DELAY
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|STATUS
op_or
id|STATUS
op_or
id|STATUS
)paren
op_amp
(paren
id|STAT_BSY
op_or
id|STAT_SEL
)paren
)paren
op_logical_and
(paren
op_logical_neg
id|st0x_aborted
)paren
op_logical_and
(paren
id|jiffies
OL
id|clock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
OG
id|clock
)paren
r_return
id|retcode
c_func
(paren
id|DID_BUS_BUSY
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|st0x_aborted
)paren
r_return
id|retcode
c_func
(paren
id|st0x_aborted
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Bus free has been detected, within BUS settle.  I used to &n; *&t;support an arbitration phase - however, on the Seagate, this &n; *&t;degraded performance by a factor &gt; 10 - so it is no more.&n; */
multiline_comment|/*&n; *&t;SELECTION PHASE&n; *&n; *&t;Now, we select the disk, giving it the SCSI ID at data&n; *&t;and a command of PARITY if necessary, and we raise SEL.&n; */
macro_line|#if (DEBUG &amp; PHASE_SELECTION)
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase = SELECTION&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
id|clock
op_assign
id|jiffies
op_plus
id|ST0X_SELECTION_DELAY
suffix:semicolon
multiline_comment|/*&n; *&t;If we wish to disconnect, we should request a MESSAGE OUT&n; *&t;at this point.  Technically, ATTN should be raised before &n; *&t;SEL = true and BSY = false (from arbitration), but I think this &n; *&t;should do.&n; */
r_if
c_cond
(paren
id|reselect
)paren
id|CONTROL
op_assign
id|BASE_CMD
op_or
id|CMD_DRVR_ENABLE
op_or
id|CMD_ATTN
suffix:semicolon
multiline_comment|/*&n; *&t;We must assert both our ID and our target&squot;s ID on the bus.&n; */
id|DATA
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
l_int|1
op_lshift
id|target
)paren
op_or
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;If we are allowing ourselves to reconnect, then I will keep &n; *&t;ATTN raised so we get MSG OUT. &n; */
id|CONTROL
op_assign
id|BASE_CMD
op_or
id|CMD_DRVR_ENABLE
op_or
id|CMD_SEL
op_or
(paren
id|reselect
ques
c_cond
id|CMD_ATTN
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;When the SCSI device decides that we&squot;re gawking at it, it will &n; *&t;respond by asserting BUSY on the bus.&n; */
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|status_read
op_assign
id|STATUS
)paren
op_amp
id|STAT_BSY
)paren
op_logical_and
(paren
id|jiffies
OL
id|clock
)paren
op_logical_and
op_logical_neg
id|st0x_aborted
)paren
macro_line|#if (DEBUG &amp; PHASE_SELECTION)
(brace
id|temp
op_assign
id|clock
op_minus
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|jiffies
op_mod
l_int|5
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;seagate_st0x_timeout : %d            &bslash;r&quot;
comma
id|temp
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Done.                                             &bslash;n&bslash;r&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;scsi%d : status = %02x, seagate_st0x_timeout = %d, aborted = %02x &bslash;n&quot;
comma
id|hostno
comma
id|status_read
comma
id|temp
comma
id|st0x_aborted
)paren
suffix:semicolon
macro_line|#else
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|jiffies
OG
id|clock
)paren
op_logical_or
(paren
op_logical_neg
id|st0x_aborted
op_logical_and
op_logical_neg
(paren
id|status_read
op_amp
id|STAT_BSY
)paren
)paren
)paren
(brace
macro_line|#if (DEBUG &amp; PHASE_SELECT)
id|printk
(paren
l_string|&quot;scsi%d : NO CONNECT with target %d, status = %x &bslash;n&quot;
comma
id|hostno
comma
id|target
comma
id|STATUS
)paren
suffix:semicolon
macro_line|#endif
r_return
id|retcode
c_func
(paren
id|DID_NO_CONNECT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;If we have been aborted, and we have a command in progress, IE the &n; *&t;target still has BSY asserted, then we will reset the bus, and &n; * &t;notify the midlevel driver to expect sense.&n; */
r_if
c_cond
(paren
id|st0x_aborted
)paren
(brace
id|CONTROL
op_assign
id|BASE_CMD
suffix:semicolon
r_if
c_cond
(paren
id|STATUS
op_amp
id|STAT_BSY
)paren
(brace
id|seagate_st0x_reset
c_func
(paren
)paren
suffix:semicolon
r_return
id|retcode
c_func
(paren
id|DID_RESET
)paren
suffix:semicolon
)brace
r_return
id|retcode
c_func
(paren
id|st0x_aborted
)paren
suffix:semicolon
)brace
)brace
id|CONTROL
op_assign
id|BASE_CMD
op_or
id|CMD_DRVR_ENABLE
op_or
(paren
(paren
id|reselect
op_eq
id|CAN_RECONNECT
)paren
ques
c_cond
id|CMD_ATTN
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n; * &t;INFORMATION TRANSFER PHASE&n; *&n; *&t;The nasty looking read / write inline assembler loops we use for &n; *&t;DATAIN and DATAOUT phases are approximately 4-5 times as fast as &n; *&t;the &squot;C&squot; versions - since we&squot;re moving 1024 bytes of data, this&n; *&t;really adds up.&n; */
macro_line|#if (DEBUG &amp; PHASE_ETC)
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase = INFORMATION TRANSFER&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif  
id|incommand
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n; * &t;Now, we poll the device for status information,&n; *&t;and handle any requests it makes.  Note that since we are unsure of &n; *&t;how much data will be flowing across the system, etc and cannot &n; *&t;make reasonable timeouts, that we will instead have the midlevel&n; * &t;driver handle any timeouts that occur in this phase.&n; */
r_while
c_loop
(paren
(paren
(paren
id|status_read
op_assign
id|STATUS
)paren
op_amp
id|STAT_BSY
)paren
op_logical_and
op_logical_neg
id|st0x_aborted
op_logical_and
op_logical_neg
id|done
)paren
(brace
macro_line|#ifdef PARITY
r_if
c_cond
(paren
id|status_read
op_amp
id|STAT_PARITY
)paren
(brace
id|done
op_assign
l_int|1
suffix:semicolon
id|st0x_aborted
op_assign
id|DID_PARITY
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|status_read
op_amp
id|STAT_REQ
)paren
(brace
macro_line|#if (DEBUG &amp; PHASE_ETC)
r_if
c_cond
(paren
(paren
id|newphase
op_assign
(paren
id|status_read
op_amp
id|REQ_MASK
)paren
)paren
op_ne
id|phase
)paren
(brace
id|phase
op_assign
id|newphase
suffix:semicolon
r_switch
c_cond
(paren
id|phase
)paren
(brace
r_case
id|REQ_DATAOUT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase = DATA OUT&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_DATAIN
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase = DATA IN&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_CMDOUT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase = COMMAND OUT&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_STATIN
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase = STATUS IN&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_MSGOUT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase = MESSAGE OUT&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_MSGIN
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase = MESSAGE IN&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : phase = UNKNOWN&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|st0x_aborted
op_assign
l_int|1
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#endif
r_switch
c_cond
(paren
id|status_read
op_amp
id|REQ_MASK
)paren
(brace
r_case
id|REQ_DATAOUT
suffix:colon
multiline_comment|/*&n; * &t;We loop as long as we are in a data out phase, there is data to send, &n; *&t;and BSY is still active.&n; */
id|__asm__
(paren
multiline_comment|/*&n;&t;Local variables : &n;&t;len = ecx&n;&t;data = esi&n;&t;st0x_cr_sr = ebx&n;&t;st0x_dr =  edi&n;&n;&t;Test for any data here at all.&n;*/
l_string|&quot;movl %0, %%esi&bslash;n&quot;
multiline_comment|/* local value of data */
l_string|&quot;&bslash;tmovl %1, %%ecx&bslash;n&quot;
multiline_comment|/* local value of len */
"&quot;&bslash;"
id|torl
op_mod
op_mod
id|ecx
comma
op_mod
op_mod
id|ecx
id|jz
l_float|2f
id|cld
id|movl
id|_st0x_cr_sr
comma
op_mod
op_mod
id|ebx
id|movl
id|_st0x_dr
comma
op_mod
op_mod
id|edi
l_int|1
suffix:colon
id|movb
(paren
op_mod
op_mod
id|ebx
)paren
comma
op_mod
op_mod
id|al
"&bslash;"
id|n
"&quot;"
multiline_comment|/*&n;&t;Test for BSY&n;*/
"&quot;&bslash;"
id|ttest
"$"
l_int|1
comma
op_mod
op_mod
id|al
id|jz
l_float|2f
"&bslash;"
id|n
"&quot;"
multiline_comment|/*&n;&t;Test for data out phase - STATUS &amp; REQ_MASK should be REQ_DATAOUT, which is 0.&n;*/
"&quot;&bslash;"
id|ttest
"$"
l_int|0xe
comma
op_mod
op_mod
id|al
id|jnz
l_float|2f
"&bslash;"
id|n
"&quot;"
multiline_comment|/*&n;&t;Test for REQ&n;*/
"&quot;&bslash;"
id|ttest
"$"
l_int|0x10
comma
op_mod
op_mod
id|al
id|jz
l_int|1
id|b
id|lodsb
id|movb
op_mod
op_mod
id|al
comma
(paren
op_mod
op_mod
id|edi
)paren
id|loop
l_int|1
id|b
l_int|2
suffix:colon
id|movl
op_mod
op_mod
id|esi
comma
op_mod
l_int|2
id|movl
op_mod
op_mod
id|ecx
comma
op_mod
l_int|3
"&quot;"
suffix:colon
multiline_comment|/* output */
l_string|&quot;=r&quot;
(paren
id|data
)paren
comma
l_string|&quot;=r&quot;
(paren
id|len
)paren
suffix:colon
multiline_comment|/* input */
l_string|&quot;0&quot;
(paren
id|data
)paren
comma
l_string|&quot;1&quot;
(paren
id|len
)paren
suffix:colon
multiline_comment|/* clobbered */
l_string|&quot;ebx&quot;
comma
l_string|&quot;ecx&quot;
comma
l_string|&quot;edi&quot;
comma
l_string|&quot;esi&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_DATAIN
suffix:colon
multiline_comment|/*&n; * &t;We loop as long as we are in a data in phase, there is room to read, &n; * &t;and BSY is still active&n; */
id|__asm__
(paren
multiline_comment|/*&n;&t;Local variables : &n;&t;ecx = len&n;&t;edi = data&n;&t;esi = st0x_cr_sr&n;&t;ebx = st0x_dr&n;&n;&t;Test for room to read&n;*/
l_string|&quot;movl %0, %%edi&bslash;n&quot;
multiline_comment|/* data */
l_string|&quot;&bslash;tmovl %1, %%ecx&bslash;n&quot;
multiline_comment|/* len */
"&quot;&bslash;"
id|torl
op_mod
op_mod
id|ecx
comma
op_mod
op_mod
id|ecx
id|jz
l_float|2f
id|cld
id|movl
id|_st0x_cr_sr
comma
op_mod
op_mod
id|esi
id|movl
id|_st0x_dr
comma
op_mod
op_mod
id|ebx
l_int|1
suffix:colon
id|movb
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|al
"&bslash;"
id|n
"&quot;"
multiline_comment|/*&n;&t;Test for BSY&n;*/
"&quot;&bslash;"
id|ttest
"$"
l_int|1
comma
op_mod
op_mod
id|al
id|jz
l_float|2f
"&bslash;"
id|n
"&quot;"
multiline_comment|/*&n;&t;Test for data in phase - STATUS &amp; REQ_MASK should be REQ_DATAIN, = STAT_IO, which is 4.&n;*/
"&quot;&bslash;"
id|tmovb
"$"
l_int|0xe
comma
op_mod
op_mod
id|ah
id|andb
op_mod
op_mod
id|al
comma
op_mod
op_mod
id|ah
id|cmpb
"$"
l_int|0x04
comma
op_mod
op_mod
id|ah
id|jne
l_float|2f
"&bslash;"
id|n
"&quot;"
multiline_comment|/*&n;&t;Test for REQ&n;*/
"&quot;&bslash;"
id|ttest
"$"
l_int|0x10
comma
op_mod
op_mod
id|al
id|jz
l_int|1
id|b
id|movb
(paren
op_mod
op_mod
id|ebx
)paren
comma
op_mod
op_mod
id|al
id|stosb
id|loop
l_int|1
id|b
l_int|2
suffix:colon
id|movl
op_mod
op_mod
id|edi
comma
op_mod
l_int|2
"&bslash;"
id|n
"&quot;"
multiline_comment|/* data */
l_string|&quot;&bslash;tmovl %%ecx, %3&bslash;n&quot;
multiline_comment|/* len */
suffix:colon
multiline_comment|/* output */
l_string|&quot;=r&quot;
(paren
id|data
)paren
comma
l_string|&quot;=r&quot;
(paren
id|len
)paren
suffix:colon
multiline_comment|/* input */
l_string|&quot;0&quot;
(paren
id|data
)paren
comma
l_string|&quot;1&quot;
(paren
id|len
)paren
suffix:colon
multiline_comment|/* clobbered */
l_string|&quot;ebx&quot;
comma
l_string|&quot;ecx&quot;
comma
l_string|&quot;edi&quot;
comma
l_string|&quot;esi&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_CMDOUT
suffix:colon
r_while
c_loop
(paren
(paren
(paren
id|status_read
op_assign
id|STATUS
)paren
op_amp
id|STAT_BSY
)paren
op_logical_and
(paren
(paren
id|status_read
op_amp
id|REQ_MASK
)paren
op_eq
id|REQ_CMDOUT
)paren
)paren
r_if
c_cond
(paren
id|status_read
op_amp
id|STAT_REQ
)paren
id|DATA
op_assign
op_star
(paren
r_int
r_char
op_star
)paren
id|cmnd
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_STATIN
suffix:colon
id|status
op_assign
id|DATA
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_MSGOUT
suffix:colon
multiline_comment|/*&n; *&t;We can only have sent a MSG OUT if we requested to do this &n; *&t;by raising ATTN.  So, we must drop ATTN.&n; */
id|CONTROL
op_assign
id|BASE_CMD
op_or
id|CMD_DRVR_ENABLE
suffix:semicolon
multiline_comment|/*&n; * &t;If we are reconecting, then we must send an IDENTIFY message in &n; *&t; response  to MSGOUT.&n; */
r_if
c_cond
(paren
id|reselect
)paren
(brace
id|DATA
op_assign
id|IDENTIFY
c_func
(paren
l_int|1
comma
id|lun
)paren
suffix:semicolon
macro_line|#if (DEBUG &amp; (PHASE_RESELECT | PHASE_MSGOUT)) 
id|printk
c_func
(paren
l_string|&quot;scsi%d : sent IDENTIFY message.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|DATA
op_assign
id|MESSAGE_REJECT
suffix:semicolon
macro_line|#if (DEBUG &amp; PHASE_MSGOUT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : sent MESSAGE REJECT message.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
)brace
r_break
suffix:semicolon
r_case
id|REQ_MSGIN
suffix:colon
r_switch
c_cond
(paren
id|message
op_assign
id|DATA
)paren
(brace
r_case
id|DISCONNECT
suffix:colon
id|should_reconnect
op_assign
l_int|1
suffix:semicolon
id|current_data
op_assign
id|data
suffix:semicolon
multiline_comment|/* WDE add */
id|current_bufflen
op_assign
id|len
suffix:semicolon
multiline_comment|/* WDE add */
macro_line|#if (DEBUG &amp; (PHASE_RESELECT | PHASE_MSGIN))
id|printk
c_func
(paren
l_string|&quot;scsi%d : disconnected.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|COMMAND_COMPLETE
suffix:colon
macro_line|#if (DEBUG &amp; PHASE_MSGIN)&t;
id|printk
c_func
(paren
l_string|&quot;scsi%d : command complete.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|ABORT
suffix:colon
macro_line|#if (DEBUG &amp; PHASE_MSGIN)
id|printk
c_func
(paren
l_string|&quot;scsi%d : abort message.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SAVE_POINTERS
suffix:colon
id|current_data
op_assign
id|data
suffix:semicolon
multiline_comment|/* WDE mod */
id|current_bufflen
op_assign
id|len
suffix:semicolon
multiline_comment|/* WDE add */
macro_line|#if (DEBUG &amp; PHASE_MSGIN)
id|printk
c_func
(paren
l_string|&quot;scsi%d : pointers saved.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif 
r_break
suffix:semicolon
r_case
id|RESTORE_POINTERS
suffix:colon
id|data
op_assign
id|current_data
suffix:semicolon
multiline_comment|/* WDE mod */
id|cmnd
op_assign
id|current_cmnd
suffix:semicolon
macro_line|#if (DEBUG &amp; PHASE_MSGIN)
id|printk
c_func
(paren
l_string|&quot;scsi%d : pointers restored.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/*&n; * &t;IDENTIFY distinguishes itself from the other messages by setting the&n; *&t;high byte.&n; */
r_if
c_cond
(paren
id|message
op_amp
l_int|0x80
)paren
(brace
macro_line|#if (DEBUG &amp; PHASE_MSGIN)
id|printk
c_func
(paren
l_string|&quot;scsi%d : IDENTIFY message received from id %d, lun %d.&bslash;n&quot;
comma
id|hostno
comma
id|target
comma
id|message
op_amp
l_int|7
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
macro_line|#if (DEBUG &amp; PHASE_MSGIN)
id|printk
c_func
(paren
l_string|&quot;scsi%d : unknown message %d from target %d.&bslash;n&quot;
comma
id|hostno
comma
id|message
comma
id|target
)paren
suffix:semicolon
macro_line|#endif&t;
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi%d : unknown phase.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
id|st0x_aborted
op_assign
id|DID_ERROR
suffix:semicolon
)brace
)brace
multiline_comment|/* while ends */
)brace
multiline_comment|/* if ends */
macro_line|#if (DEBUG &amp; (PHASE_DATAIN | PHASE_DATAOUT | PHASE_EXIT))
id|printk
c_func
(paren
l_string|&quot;Transfered %d bytes, allowed %d additional bytes&bslash;n&quot;
comma
(paren
id|bufflen
op_minus
id|len
)paren
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if (DEBUG &amp; PHASE_EXIT)
id|printk
c_func
(paren
l_string|&quot;Buffer : &bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
op_increment
id|i
)paren
id|printk
(paren
l_string|&quot;%02x  &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|data
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* WDE mod */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Status = %02x, message = %02x&bslash;n&quot;
comma
id|status
comma
id|message
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|st0x_aborted
)paren
(brace
r_if
c_cond
(paren
id|STATUS
op_amp
id|STAT_BSY
)paren
(brace
id|seagate_st0x_reset
c_func
(paren
)paren
suffix:semicolon
id|st0x_aborted
op_assign
id|DID_RESET
suffix:semicolon
)brace
id|abort_confirm
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|should_reconnect
)paren
(brace
macro_line|#if (DEBUG &amp; PHASE_RESELECT)
id|printk
c_func
(paren
l_string|&quot;scsi%d : exiting seagate_st0x_queue_command() with reconnect enabled.&bslash;n&quot;
comma
id|hostno
)paren
suffix:semicolon
macro_line|#endif
id|CONTROL
op_assign
id|BASE_CMD
op_or
id|CMD_INTR
suffix:semicolon
)brace
r_else
id|CONTROL
op_assign
id|BASE_CMD
suffix:semicolon
r_return
id|retcode
(paren
id|st0x_aborted
)paren
suffix:semicolon
)brace
DECL|function|seagate_st0x_abort
r_int
id|seagate_st0x_abort
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|code
)paren
(brace
r_if
c_cond
(paren
id|code
)paren
id|st0x_aborted
op_assign
id|code
suffix:semicolon
r_else
id|st0x_aborted
op_assign
id|DID_ABORT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;the seagate_st0x_reset function resets the SCSI bus&n;*/
DECL|function|seagate_st0x_reset
r_int
id|seagate_st0x_reset
(paren
r_void
)paren
(brace
r_int
id|clock
suffix:semicolon
multiline_comment|/*&n;&t;&t;No timeouts - this command is going to fail because &n;&t;&t;it was reset.&n;&t;*/
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;In seagate_st0x_reset()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* assert  RESET signal on SCSI bus.  */
id|CONTROL
op_assign
id|BASE_CMD
op_or
id|CMD_RST
suffix:semicolon
id|clock
op_assign
id|jiffies
op_plus
l_int|2
suffix:semicolon
multiline_comment|/* Wait.  */
r_while
c_loop
(paren
id|jiffies
OL
id|clock
)paren
suffix:semicolon
id|CONTROL
op_assign
id|BASE_CMD
suffix:semicolon
id|st0x_aborted
op_assign
id|DID_RESET
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SCSI bus reset.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;
eof
