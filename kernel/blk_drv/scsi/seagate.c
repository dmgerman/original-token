multiline_comment|/*&n; *&t;seagate.c Copyright (C) 1992 Drew Eckhardt &n; *&t;low level scsi driver for ST01/ST02 by&n; *&t;&t;Drew Eckhardt &n; *&n; *&t;&lt;drew@colorado.edu&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef CONFIG_SCSI_SEAGATE
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &quot;seagate.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
DECL|variable|incommand
r_static
r_int
id|incommand
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;set if arbitration has finished and we are &n;&t;&t;&t;&t;&t;&t;in some command phase.&n;&t;&t;&t;&t;&t;*/
DECL|variable|base_address
r_static
r_void
op_star
id|base_address
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;Where the card ROM starts,&n;&t;&t;&t;&t;&t;&t;used to calculate memory mapped&n;&t;&t;&t;&t;&t;&t;register location.&n;&t;&t;&t;&t;&t;*/
DECL|variable|abort_confirm
r_static
r_volatile
r_int
id|abort_confirm
op_assign
l_int|0
suffix:semicolon
DECL|variable|st0x_cr_sr
r_volatile
r_void
op_star
id|st0x_cr_sr
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;control register write,&n;&t;&t;&t;&t;&t;&t;status register read.&n;&t;&t;&t;&t;&t;&t;256 bytes in length.&n;&n;&t;&t;&t;&t;&t;&t;Read is status of SCSI BUS,&n;&t;&t;&t;&t;&t;&t;as per STAT masks.&n;&n;&t;&t;&t;&t;&t;*/
DECL|variable|st0x_dr
r_static
r_volatile
r_void
op_star
id|st0x_dr
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;data register, read write&n;&t;&t;&t;&t;&t;&t;256 bytes in length.&n;&t;&t;&t;&t;&t;*/
DECL|variable|st0x_aborted
r_static
r_volatile
r_int
id|st0x_aborted
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t;&t;&t;&t;set when we are aborted, ie by a time out, etc.&n;&t;&t;&t;&t;&t;*/
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;In theory, we have a nice auto&n;&t;&t;&t;&t;&t;&t;detect routine - but this &n;&t;&t;&t;&t;&t;&t;overides it. &n;&t;&t;&t;&t;&t;*/
DECL|macro|retcode
mdefine_line|#define retcode(result) (((result) &lt;&lt; 16) | (message &lt;&lt; 8) | status) &t;&t;&t;
DECL|macro|STATUS
mdefine_line|#define STATUS (*(unsigned char *) st0x_cr_sr)
DECL|macro|CONTROL
mdefine_line|#define CONTROL STATUS 
DECL|macro|DATA
mdefine_line|#define DATA (*(unsigned char *) st0x_dr)
macro_line|#ifndef OVERRIDE&t;&t;
DECL|variable|seagate_bases
r_static
r_const
r_char
op_star
id|seagate_bases
(braket
)braket
op_assign
(brace
(paren
r_char
op_star
)paren
l_int|0xc8000
comma
(paren
r_char
op_star
)paren
l_int|0xca000
comma
(paren
r_char
op_star
)paren
l_int|0xcc000
comma
(paren
r_char
op_star
)paren
l_int|0xce000
comma
(paren
r_char
op_star
)paren
l_int|0xce000
comma
(paren
r_char
op_star
)paren
l_int|0xdc000
comma
(paren
r_char
op_star
)paren
l_int|0xde000
)brace
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|signature
r_char
op_star
id|signature
suffix:semicolon
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|typedef|Signature
)brace
id|Signature
suffix:semicolon
DECL|variable|signatures
r_static
r_const
id|Signature
id|signatures
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;SCSI BIOS 2.00  (C) Copyright 1987 Seagate&quot;
comma
l_int|15
comma
l_int|40
)brace
comma
(brace
l_string|&quot;SEAGATE SCSI BIOS &quot;
comma
l_int|16
comma
l_int|17
)brace
comma
(brace
l_string|&quot;SEAGATE SCSI BIOS &quot;
comma
l_int|17
comma
l_int|17
)brace
)brace
suffix:semicolon
multiline_comment|/*&n;&t;Note that the last signature handles BIOS revisions 3.0.0 and &n;&t;3.2 - the real ID&squot;s are &n;&n;SEAGATE SCSI BIOS REVISION 3.0.0&n;SEAGATE SCSI BIOS REVISION 3.2&n;&n;*/
DECL|macro|NUM_SIGNATURES
mdefine_line|#define NUM_SIGNATURES (sizeof(signatures) / sizeof(Signature))
macro_line|#endif
DECL|function|seagate_st0x_detect
r_int
id|seagate_st0x_detect
(paren
r_int
id|hostnum
)paren
(brace
macro_line|#ifndef OVERRIDE
r_int
id|i
comma
id|j
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;First, we try for the manual override.&n;&t;*/
macro_line|#ifdef DEBUG 
id|printk
c_func
(paren
l_string|&quot;Autodetecting seagate ST0x&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|base_address
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef OVERRIDE
id|base_address
op_assign
(paren
r_void
op_star
)paren
id|OVERRIDE
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Base address overridden to %x&bslash;n&quot;
comma
id|base_address
)paren
suffix:semicolon
macro_line|#endif
macro_line|#else&t;
multiline_comment|/*&n;&t;&t;To detect this card, we simply look for the SEAGATE SCSI&n;&t;&t;from the BIOS version notice in all the possible locations&n;&t;&t;of the ROM&squot;s.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_sizeof
(paren
id|seagate_bases
)paren
op_div
r_sizeof
(paren
r_char
op_star
)paren
)paren
suffix:semicolon
op_increment
id|i
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|base_address
op_logical_and
id|j
OL
id|NUM_SIGNATURES
suffix:semicolon
op_increment
id|j
)paren
r_if
c_cond
(paren
op_logical_neg
id|memcmp
(paren
(paren
r_void
op_star
)paren
(paren
id|seagate_bases
(braket
id|i
)braket
op_plus
id|signatures
(braket
id|j
)braket
dot
id|offset
)paren
comma
(paren
r_void
op_star
)paren
id|signatures
(braket
id|j
)braket
dot
id|signature
comma
id|signatures
(braket
id|j
)braket
dot
id|length
)paren
)paren
id|base_address
op_assign
(paren
r_void
op_star
)paren
id|seagate_bases
(braket
id|i
)braket
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|base_address
)paren
(brace
id|st0x_cr_sr
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|base_address
)paren
op_plus
l_int|0x1a00
)paren
suffix:semicolon
id|st0x_dr
op_assign
(paren
r_void
op_star
)paren
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|base_address
)paren
op_plus
l_int|0x1c00
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;ST0x detected. Base address = %x, cr = %x, dr = %x&bslash;n&quot;
comma
id|base_address
comma
id|st0x_cr_sr
comma
id|st0x_dr
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;ST0x not detected.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|seagate_st0x_info
r_char
op_star
id|seagate_st0x_info
c_func
(paren
r_void
)paren
(brace
r_static
r_char
id|buffer
(braket
)braket
op_assign
l_string|&quot;Seagate ST-0X SCSI driver by Drew Eckhardt &bslash;n&quot;
l_string|&quot;$Header: /usr/src/linux/kernel/blk_drv/scsi/RCS/seagate.c,v 1.1 1992/04/24 18:01:50 root Exp root $&bslash;n&quot;
suffix:semicolon
r_return
id|buffer
suffix:semicolon
)brace
DECL|function|seagate_st0x_command
r_int
id|seagate_st0x_command
c_func
(paren
r_int
r_char
id|target
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buff
comma
r_int
id|bufflen
)paren
(brace
r_int
id|len
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
id|clock
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;We use clock for timeouts, etc.   This replaces the &n;&t;&t;&t;&t;&t;&t;seagate_st0x_timeout that we had been using.&n;&t;&t;&t;&t;&t;*/
macro_line|#if (DEBUG &amp; PHASE_SELECTION)
r_int
id|temp
suffix:semicolon
macro_line|#endif
macro_line|#if (DEBUG &amp; PHASE_EXIT)
r_void
op_star
id|retaddr
comma
op_star
id|realretaddr
suffix:semicolon
macro_line|#endif
macro_line|#if ((DEBUG &amp; PHASE_ETC) || (DEBUG &amp; PRINT_COMMAND) || (DEBUG &amp; PHASE_EXIT))&t;
r_int
id|i
suffix:semicolon
macro_line|#endif
macro_line|#if (DEBUG &amp; PHASE_ETC)
r_int
id|phase
op_assign
l_int|0
comma
id|newphase
suffix:semicolon
macro_line|#endif
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|status
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|message
op_assign
l_int|0
suffix:semicolon
r_register
r_int
r_char
id|status_read
suffix:semicolon
macro_line|#if (DEBUG &amp; PHASE_EXIT)
id|__asm__
c_func
(paren
"&quot;"
id|movl
l_int|4
(paren
op_mod
op_mod
id|ebp
)paren
comma
op_mod
op_mod
id|eax
l_string|&quot;:&quot;
op_assign
id|a
"&quot;"
(paren
id|realretaddr
)paren
suffix:colon
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;return address = %08x&bslash;n&quot;
comma
id|realretaddr
)paren
suffix:semicolon
macro_line|#endif
id|len
op_assign
id|bufflen
suffix:semicolon
id|data
op_assign
(paren
r_int
r_char
op_star
)paren
id|buff
suffix:semicolon
id|incommand
op_assign
l_int|0
suffix:semicolon
id|st0x_aborted
op_assign
l_int|0
suffix:semicolon
macro_line|#if (DEBUG &amp; PRINT_COMMAND)
id|printk
(paren
l_string|&quot;seagate_st0x_command, target = %d, command = &quot;
comma
id|target
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|COMMAND_SIZE
c_func
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|cmnd
)paren
(braket
l_int|0
)braket
)paren
suffix:semicolon
op_increment
id|i
)paren
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|cmnd
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|target
OG
l_int|6
)paren
r_return
id|DID_BAD_TARGET
suffix:semicolon
macro_line|#if (DEBUG &amp; PHASE_BUS_FREE)
id|printk
(paren
l_string|&quot;SCSI PHASE = BUS FREE &bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&n;&t;&t;BUS FREE PHASE&n;&n;&t;&t;On entry, we make sure that the BUS is in a BUS FREE&n;&t;&t;phase, by insuring that both BSY and SEL are low for&n;&t;&t;at least one bus settle delay.  The standard requires a&n;&t;&t;minimum of 400 ns, which is 16 clock cycles on a&n;&t;&t;386-40  .&n;&n;&t;&t;This doesn&squot;t give us much time - so we&squot;ll do two several&n;&t;&t;reads to be sure be sure.&n;&t;*/
id|clock
op_assign
id|jiffies
op_plus
id|ST0X_BUS_FREE_DELAY
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|STATUS
op_or
id|STATUS
op_or
id|STATUS
)paren
op_amp
(paren
id|STAT_BSY
op_or
id|STAT_SEL
)paren
)paren
op_logical_and
(paren
op_logical_neg
id|st0x_aborted
)paren
op_logical_and
(paren
id|jiffies
OL
id|clock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
OG
id|clock
)paren
r_return
id|retcode
c_func
(paren
id|DID_BUS_BUSY
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|st0x_aborted
)paren
r_return
id|retcode
c_func
(paren
id|st0x_aborted
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;Bus free has been detected, within BUS settle.  I used to support an arbitration&n;&t;&t;phase - however, on the seagate, this degraded performance by a factor &gt; 10 - so&n;&t;        it is no more.&n;&t;*/
multiline_comment|/*&n;&t;&t;SELECTION PHASE&n;&n;&t;&t;Now, we select the disk, giving it the SCSI ID at data&n;&t;&t;and a command of PARITY if necessary, plus driver enable,&n;&t;&t;plus raise select signal.&n;&t;*/
macro_line|#if (DEBUG &amp; PHASE_SELECTION)
id|printk
c_func
(paren
l_string|&quot;SCSI PHASE = SELECTION&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|clock
op_assign
id|jiffies
op_plus
id|ST0X_SELECTION_DELAY
suffix:semicolon
id|DATA
op_assign
(paren
r_int
r_char
)paren
(paren
l_int|1
op_lshift
id|target
)paren
suffix:semicolon
id|CONTROL
op_assign
id|BASE_CMD
op_or
id|CMD_DRVR_ENABLE
op_or
id|CMD_SEL
suffix:semicolon
multiline_comment|/*&n;&t;&t;When the SCSI device decides that we&squot;re gawking at it, it will respond by asserting BUSY on the bus.&n;&t;*/
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|status_read
op_assign
id|STATUS
)paren
op_amp
id|STAT_BSY
)paren
op_logical_and
(paren
id|jiffies
OL
id|clock
)paren
op_logical_and
op_logical_neg
id|st0x_aborted
)paren
macro_line|#if (DEBUG &amp; PHASE_SELECTION)
(brace
id|temp
op_assign
id|clock
op_minus
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|jiffies
op_mod
l_int|5
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;seagate_st0x_timeout : %d            &bslash;r&quot;
comma
id|temp
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Done.                                             &bslash;n&bslash;r&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Status = %02x, seagate_st0x_timeout = %d, aborted = %02x &bslash;n&quot;
comma
id|status_read
comma
id|temp
comma
id|st0x_aborted
)paren
suffix:semicolon
macro_line|#else
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|jiffies
OG
id|clock
)paren
op_logical_or
(paren
op_logical_neg
id|st0x_aborted
op_amp
op_logical_neg
(paren
id|status_read
op_amp
id|STAT_BSY
)paren
)paren
)paren
(brace
macro_line|#if (DEBUG &amp; PHASE_SELECT)
id|printk
(paren
l_string|&quot;NO CONNECT with target %d, status = %x &bslash;n&quot;
comma
id|target
comma
id|STATUS
)paren
suffix:semicolon
macro_line|#endif
r_return
id|retcode
c_func
(paren
id|DID_NO_CONNECT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;If we have been aborted, and we have a command in progress, IE the target still has&n;&t;&t;BSY asserted, then we will reset the bus, and notify the midlevel driver to&n;&t;&t;expect sense.&n;&t;*/
r_if
c_cond
(paren
id|st0x_aborted
)paren
(brace
id|CONTROL
op_assign
id|BASE_CMD
suffix:semicolon
r_if
c_cond
(paren
id|STATUS
op_amp
id|STAT_BSY
)paren
(brace
id|seagate_st0x_reset
c_func
(paren
)paren
suffix:semicolon
r_return
id|retcode
c_func
(paren
id|DID_RESET
)paren
suffix:semicolon
)brace
r_return
id|retcode
c_func
(paren
id|st0x_aborted
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;COMMAND PHASE&n;&t;&t;The device has responded with a BSY, so we may now enter&n;&t;&t;the information transfer phase, where we will send / recieve&n;&t;&t;data and command as directed by the target.&n;&n;&n;&t;&t;The nasty looking read / write inline assembler loops we use for &n;&t;&t;DATAIN and DATAOUT phases are approximately 4-5 times as fast as &n;&t;&t;the &squot;C&squot; versions - since we&squot;re moving 1024 bytes of data, this&n;&t;&t;really adds up.&n;&t;*/
macro_line|#if (DEBUG &amp; PHASE_ETC)
id|printk
c_func
(paren
l_string|&quot;PHASE = information transfer&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif  
id|incommand
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;Enable command&n;&t;*/
id|CONTROL
op_assign
id|BASE_CMD
op_or
id|CMD_DRVR_ENABLE
suffix:semicolon
multiline_comment|/*&n;&t;&t;Now, we poll the device for status information,&n;&t;&t;and handle any requests it makes.  Note that since we are unsure of &n;&t;&t;how much data will be flowing across the system, etc and cannot &n;&t;&t;make reasonable timeouts, that we will instead have the midlevel&n;&t;&t;driver handle any timeouts that occur in this phase.&n;&t;*/
r_while
c_loop
(paren
(paren
(paren
id|status_read
op_assign
id|STATUS
)paren
op_amp
id|STAT_BSY
)paren
op_logical_and
op_logical_neg
id|st0x_aborted
op_logical_and
op_logical_neg
id|done
)paren
(brace
macro_line|#ifdef PARITY
r_if
c_cond
(paren
id|status_read
op_amp
id|STAT_PARITY
)paren
(brace
id|done
op_assign
l_int|1
suffix:semicolon
id|st0x_aborted
op_assign
id|DID_PARITY
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|status_read
op_amp
id|STAT_REQ
)paren
(brace
macro_line|#if (DEBUG &amp; PHASE_ETC)
r_if
c_cond
(paren
(paren
id|newphase
op_assign
(paren
id|status_read
op_amp
id|REQ_MASK
)paren
)paren
op_ne
id|phase
)paren
(brace
id|phase
op_assign
id|newphase
suffix:semicolon
r_switch
c_cond
(paren
id|phase
)paren
(brace
r_case
id|REQ_DATAOUT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SCSI PHASE = DATA OUT&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_DATAIN
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SCSI PHASE = DATA IN&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_CMDOUT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SCSI PHASE = COMMAND OUT&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_STATIN
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SCSI PHASE = STATUS IN&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_MSGOUT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SCSI PHASE = MESSAGE OUT&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_MSGIN
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SCSI PHASE = MESSAGE IN&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UNKNOWN PHASE&quot;
)paren
suffix:semicolon
id|st0x_aborted
op_assign
l_int|1
suffix:semicolon
id|done
op_assign
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#endif
r_switch
c_cond
(paren
id|status_read
op_amp
id|REQ_MASK
)paren
(brace
r_case
id|REQ_DATAOUT
suffix:colon
multiline_comment|/*&n;&t;&t;We loop as long as we are in a data out phase, there is data to send, and BSY is still&n;&t;&t;active&n;&t;*/
id|__asm__
(paren
"&quot;"
multiline_comment|/*&n;&t;Local variables : &n;&t;len = ecx&n;&t;data = esi&n;&t;st0x_cr_sr = ebx&n;&t;st0x_dr =  edi&n;&n;&t;Test for any data here at all.&n;*/
id|movl
op_mod
l_int|0
comma
op_mod
op_mod
id|esi
multiline_comment|/* local value of data */
id|movl
op_mod
l_int|1
comma
op_mod
op_mod
id|ecx
multiline_comment|/* local value of len */
id|orl
op_mod
op_mod
id|ecx
comma
op_mod
op_mod
id|ecx
id|jz
l_float|2f
id|cld
id|movl
id|_st0x_cr_sr
comma
op_mod
op_mod
id|ebx
id|movl
id|_st0x_dr
comma
op_mod
op_mod
id|edi
l_int|1
suffix:colon
id|movb
(paren
op_mod
op_mod
id|ebx
)paren
comma
op_mod
op_mod
id|al
multiline_comment|/*&n;&t;Test for BSY&n;*/
id|test
"$"
l_int|1
comma
op_mod
op_mod
id|al
id|jz
l_float|2f
multiline_comment|/*&n;&t;Test for data out phase - STATUS &amp; REQ_MASK should be REQ_DATAOUT, which is 0.&n;*/
id|test
"$"
l_int|0xe
comma
op_mod
op_mod
id|al
id|jnz
l_float|2f
multiline_comment|/*&n;&t;Test for REQ&n;*/
id|test
"$"
l_int|0x10
comma
op_mod
op_mod
id|al
id|jz
l_int|1
id|b
id|lodsb
id|movb
op_mod
op_mod
id|al
comma
(paren
op_mod
op_mod
id|edi
)paren
id|loop
l_int|1
id|b
l_int|2
suffix:colon
id|movl
op_mod
op_mod
id|esi
comma
op_mod
l_int|2
id|movl
op_mod
op_mod
id|ecx
comma
op_mod
l_int|3
"&quot;"
suffix:colon
multiline_comment|/* output */
l_string|&quot;=r&quot;
(paren
id|data
)paren
comma
l_string|&quot;=r&quot;
(paren
id|len
)paren
suffix:colon
multiline_comment|/* input */
l_string|&quot;0&quot;
(paren
id|data
)paren
comma
l_string|&quot;1&quot;
(paren
id|len
)paren
suffix:colon
multiline_comment|/* clobbered */
l_string|&quot;ebx&quot;
comma
l_string|&quot;ecx&quot;
comma
l_string|&quot;edi&quot;
comma
l_string|&quot;esi&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_DATAIN
suffix:colon
multiline_comment|/*&n;&t;&t;We loop as long as we are in a data out phase, there is room to read, and BSY is still&n;&t;&t;active&n;&t;*/
id|__asm__
(paren
"&quot;"
multiline_comment|/*&n;&t;Local variables : &n;&t;ecx = len&n;&t;edi = data&n;&t;esi = st0x_cr_sr&n;&t;ebx = st0x_dr&n;&n;&t;Test for room to read&n;*/
id|movl
op_mod
l_int|0
comma
op_mod
op_mod
id|edi
multiline_comment|/* data */
id|movl
op_mod
l_int|1
comma
op_mod
op_mod
id|ecx
multiline_comment|/* len */
id|orl
op_mod
op_mod
id|ecx
comma
op_mod
op_mod
id|ecx
id|jz
l_float|2f
id|cld
id|movl
id|_st0x_cr_sr
comma
op_mod
op_mod
id|esi
id|movl
id|_st0x_dr
comma
op_mod
op_mod
id|ebx
l_int|1
suffix:colon
id|movb
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|al
multiline_comment|/*&n;&t;Test for BSY&n;*/
id|test
"$"
l_int|1
comma
op_mod
op_mod
id|al
id|jz
l_float|2f
multiline_comment|/*&n;&t;Test for data in phase - STATUS &amp; REQ_MASK should be REQ_DATAIN, = STAT_IO, which is 4.&n;*/
id|movb
"$"
l_int|0xe
comma
op_mod
op_mod
id|ah
id|andb
op_mod
op_mod
id|al
comma
op_mod
op_mod
id|ah
id|cmpb
"$"
l_int|0x04
comma
op_mod
op_mod
id|ah
id|jne
l_float|2f
multiline_comment|/*&n;&t;Test for REQ&n;*/
id|test
"$"
l_int|0x10
comma
op_mod
op_mod
id|al
id|jz
l_int|1
id|b
id|movb
(paren
op_mod
op_mod
id|ebx
)paren
comma
op_mod
op_mod
id|al
id|stosb
id|loop
l_int|1
id|b
l_int|2
suffix:colon
id|movl
op_mod
op_mod
id|edi
comma
op_mod
l_int|2
multiline_comment|/* data */
id|movl
op_mod
op_mod
id|ecx
comma
op_mod
l_int|3
multiline_comment|/* len */
"&quot;"
suffix:colon
multiline_comment|/* output */
l_string|&quot;=r&quot;
(paren
id|data
)paren
comma
l_string|&quot;=r&quot;
(paren
id|len
)paren
suffix:colon
multiline_comment|/* input */
l_string|&quot;0&quot;
(paren
id|data
)paren
comma
l_string|&quot;1&quot;
(paren
id|len
)paren
suffix:colon
multiline_comment|/* clobbered */
l_string|&quot;ebx&quot;
comma
l_string|&quot;ecx&quot;
comma
l_string|&quot;edi&quot;
comma
l_string|&quot;esi&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_CMDOUT
suffix:colon
r_while
c_loop
(paren
(paren
(paren
id|status_read
op_assign
id|STATUS
)paren
op_amp
id|STAT_BSY
)paren
op_logical_and
(paren
(paren
id|status_read
op_amp
id|REQ_MASK
)paren
op_eq
id|REQ_CMDOUT
)paren
)paren
id|DATA
op_assign
op_star
(paren
r_int
r_char
op_star
)paren
id|cmnd
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_STATIN
suffix:colon
id|status
op_assign
id|DATA
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_MSGOUT
suffix:colon
id|DATA
op_assign
id|MESSAGE_REJECT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|REQ_MSGIN
suffix:colon
r_if
c_cond
(paren
(paren
id|message
op_assign
id|DATA
)paren
op_eq
id|COMMAND_COMPLETE
)paren
id|done
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;UNKNOWN PHASE&quot;
)paren
suffix:semicolon
id|st0x_aborted
op_assign
id|DID_ERROR
suffix:semicolon
)brace
)brace
)brace
macro_line|#if (DEBUG &amp; (PHASE_DATAIN | PHASE_DATAOUT | PHASE_EXIT))
id|printk
c_func
(paren
l_string|&quot;Transfered %d bytes, allowed %d additional bytes&bslash;n&quot;
comma
(paren
id|bufflen
op_minus
id|len
)paren
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if (DEBUG &amp; PHASE_EXIT)
id|printk
c_func
(paren
l_string|&quot;Buffer : &bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
op_increment
id|i
)paren
id|printk
(paren
l_string|&quot;%02x  &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|buff
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Status = %02x, message = %02x&bslash;n&quot;
comma
id|status
comma
id|message
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|st0x_aborted
)paren
(brace
r_if
c_cond
(paren
id|STATUS
op_amp
id|STAT_BSY
)paren
(brace
id|seagate_st0x_reset
c_func
(paren
)paren
suffix:semicolon
id|st0x_aborted
op_assign
id|DID_RESET
suffix:semicolon
)brace
id|abort_confirm
op_assign
l_int|1
suffix:semicolon
)brace
id|CONTROL
op_assign
id|BASE_CMD
suffix:semicolon
macro_line|#if (DEBUG &amp; PHASE_EXIT)
id|__asm__
c_func
(paren
"&quot;"
id|mov
l_int|4
(paren
op_mod
op_mod
id|ebp
)paren
comma
op_mod
op_mod
id|eax
l_string|&quot;:&quot;
op_assign
id|a
"&quot;"
(paren
id|retaddr
)paren
suffix:colon
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Exiting seagate_st0x_command() - return address is %08x &bslash;n&quot;
comma
id|retaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retaddr
op_ne
id|realretaddr
)paren
id|panic
(paren
l_string|&quot;Corrupted stack : return address on entry != return address on exit.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|retcode
(paren
id|st0x_aborted
)paren
suffix:semicolon
)brace
DECL|function|seagate_st0x_abort
r_int
id|seagate_st0x_abort
(paren
r_int
id|code
)paren
(brace
r_if
c_cond
(paren
id|code
)paren
id|st0x_aborted
op_assign
id|code
suffix:semicolon
r_else
id|st0x_aborted
op_assign
id|DID_ABORT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;the seagate_st0x_reset function resets the SCSI bus&n;*/
DECL|function|seagate_st0x_reset
r_int
id|seagate_st0x_reset
(paren
r_void
)paren
(brace
r_int
id|clock
suffix:semicolon
multiline_comment|/*&n;&t;&t;No timeouts - this command is going to fail because &n;&t;&t;it was reset.&n;&t;*/
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;In seagate_st0x_reset()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* assert  RESET signal on SCSI bus.  */
id|CONTROL
op_assign
id|BASE_CMD
op_or
id|CMD_RST
suffix:semicolon
id|clock
op_assign
id|jiffies
op_plus
l_int|2
suffix:semicolon
multiline_comment|/* Wait.  */
r_while
c_loop
(paren
id|jiffies
OL
id|clock
)paren
suffix:semicolon
id|CONTROL
op_assign
id|BASE_CMD
suffix:semicolon
id|st0x_aborted
op_assign
id|DID_RESET
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SCSI bus reset.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;
eof
