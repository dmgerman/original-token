multiline_comment|/*&n; *&t;ultrastor.c&t;(C) 1991 David B. Gentzel&n; *&t;Low-level SCSI driver for UltraStor 14F&n; *&t;by David B. Gentzel, Whitfield Software Services, Carnegie, PA&n; *&t;    (gentzel@nova.enet.dec.com)&n; *&t;Thanks to UltraStor for providing the necessary documentation&n; */
multiline_comment|/*&n; * NOTES:&n; *    The UltraStor 14F is an intelligent, high performance ISA SCSI-2 host&n; *    adapter.  It is essentially an ISA version of the UltraStor 24F EISA&n; *    adapter.  It supports first-party DMA, command queueing, and&n; *    scatter/gather I/O.  It can also emulate the standard AT MFM/RLL/IDE&n; *    interface for use with OS&squot;s which don&squot;t support SCSI.&n; *&n; *    This driver may also work (with some small changes) with the UltraStor&n; *    24F.  I have no way of confirming this...&n; *&n; *    Places flagged with a triple question-mark are things which are either&n; *    unfinished, questionable, or wrong.&n; */
multiline_comment|/*&n; * CAVEATS: ???&n; *    This driver is VERY stupid.  It takes no advantage of much of the power&n; *    of the UltraStor controller.  We just sit-and-spin while waiting for&n; *    commands to complete.  I hope to go back and beat it into shape, but&n; *    PLEASE, anyone else who would like to, please make improvements!&n; *&n; *    By defining USE_QUEUECOMMAND as TRUE in ultrastor.h, you enable the&n; *    queueing feature of the mid-level SCSI driver.  This should improve&n; *    performance somewhat.  However, it does not seem to work.  I believe&n; *    this is due to a bug in the mid-level driver, but I haven&squot;t looked&n; *    too closely.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef CONFIG_SCSI_ULTRASTOR
macro_line|#include &lt;stddef.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
DECL|macro|ULTRASTOR_PRIVATE
mdefine_line|#define ULTRASTOR_PRIVATE&t;/* Get the private stuff from ultrastor.h */
macro_line|#include &quot;ultrastor.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
DECL|macro|VERSION
mdefine_line|#define VERSION &quot;1.0 beta&quot;
DECL|macro|ARRAY_SIZE
mdefine_line|#define ARRAY_SIZE(arr) (sizeof (arr) / sizeof (arr)[0])
DECL|macro|BIT
mdefine_line|#define BIT(n) (1ul &lt;&lt; (n))
DECL|macro|BYTE
mdefine_line|#define BYTE(num, n) ((unsigned char)((unsigned int)(num) &gt;&gt; ((n) * 8)))
multiline_comment|/* Simply using &quot;unsigned long&quot; in these structures won&squot;t work as it causes&n;   alignment.  Perhaps the &quot;aligned&quot; attribute may be used in GCC 2.0 to get&n;   around this, but for now I use this hack. */
r_typedef
r_struct
(brace
DECL|member|bytes
r_int
r_char
id|bytes
(braket
l_int|4
)braket
suffix:semicolon
DECL|typedef|Longword
)brace
id|Longword
suffix:semicolon
multiline_comment|/* Used to fetch the configuration info from the config i/o registers.  We&n;   then store (in a friendlier format) in config. */
DECL|struct|config_1
r_struct
id|config_1
(brace
DECL|member|bios_segment
r_int
r_char
id|bios_segment
suffix:colon
l_int|3
suffix:semicolon
DECL|member|reserved
r_int
r_char
id|reserved
suffix:colon
l_int|1
suffix:semicolon
DECL|member|interrupt
r_int
r_char
id|interrupt
suffix:colon
l_int|2
suffix:semicolon
DECL|member|dma_channel
r_int
r_char
id|dma_channel
suffix:colon
l_int|2
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|config_2
r_struct
id|config_2
(brace
DECL|member|ha_scsi_id
r_int
r_char
id|ha_scsi_id
suffix:colon
l_int|3
suffix:semicolon
DECL|member|mapping_mode
r_int
r_char
id|mapping_mode
suffix:colon
l_int|2
suffix:semicolon
DECL|member|bios_drive_number
r_int
r_char
id|bios_drive_number
suffix:colon
l_int|1
suffix:semicolon
DECL|member|tfr_port
r_int
r_char
id|tfr_port
suffix:colon
l_int|2
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Used to store configuration info read from config i/o registers.  Most of&n;   this is not used yet, but might as well save it. */
DECL|struct|config
r_struct
id|config
(brace
DECL|member|port_address
r_int
r_int
id|port_address
suffix:semicolon
DECL|member|bios_segment
r_const
r_void
op_star
id|bios_segment
suffix:semicolon
DECL|member|interrupt
r_int
r_char
id|interrupt
suffix:colon
l_int|4
suffix:semicolon
DECL|member|dma_channel
r_int
r_char
id|dma_channel
suffix:colon
l_int|3
suffix:semicolon
DECL|member|ha_scsi_id
r_int
r_char
id|ha_scsi_id
suffix:colon
l_int|3
suffix:semicolon
DECL|member|heads
r_int
r_char
id|heads
suffix:colon
l_int|6
suffix:semicolon
DECL|member|sectors
r_int
r_char
id|sectors
suffix:colon
l_int|6
suffix:semicolon
DECL|member|bios_drive_number
r_int
r_char
id|bios_drive_number
suffix:colon
l_int|1
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* MailBox SCSI Command Packet.  Basic command structure for communicating&n;   with controller. */
DECL|struct|mscp
r_struct
id|mscp
(brace
DECL|member|opcode
r_int
r_char
id|opcode
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* type of command */
DECL|member|xdir
r_int
r_char
id|xdir
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* data transfer direction */
DECL|member|dcn
r_int
r_char
id|dcn
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* disable disconnect */
DECL|member|ca
r_int
r_char
id|ca
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* use cache (if available) */
DECL|member|sg
r_int
r_char
id|sg
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* scatter/gather operation */
DECL|member|target_id
r_int
r_char
id|target_id
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* target SCSI id */
DECL|member|ch_no
r_int
r_char
id|ch_no
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* SCSI channel (always 0 for 14f) */
DECL|member|lun
r_int
r_char
id|lun
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* logical unit number */
DECL|member|transfer_data
id|Longword
id|transfer_data
suffix:semicolon
multiline_comment|/* transfer data pointer */
DECL|member|transfer_data_length
id|Longword
id|transfer_data_length
suffix:semicolon
multiline_comment|/* length in bytes */
DECL|member|command_link
id|Longword
id|command_link
suffix:semicolon
multiline_comment|/* for linking command chains */
DECL|member|scsi_command_link_id
r_int
r_char
id|scsi_command_link_id
suffix:semicolon
multiline_comment|/* identifies command in chain */
DECL|member|number_of_sg_list
r_int
r_char
id|number_of_sg_list
suffix:semicolon
multiline_comment|/* (if sg is set) 8 bytes per list */
DECL|member|length_of_sense_byte
r_int
r_char
id|length_of_sense_byte
suffix:semicolon
DECL|member|length_of_scsi_cdbs
r_int
r_char
id|length_of_scsi_cdbs
suffix:semicolon
multiline_comment|/* 6, 10, or 12 */
DECL|member|scsi_cdbs
r_int
r_char
id|scsi_cdbs
(braket
l_int|12
)braket
suffix:semicolon
multiline_comment|/* SCSI commands */
DECL|member|adapter_status
r_int
r_char
id|adapter_status
suffix:semicolon
multiline_comment|/* non-zero indicates HA error */
DECL|member|target_status
r_int
r_char
id|target_status
suffix:semicolon
multiline_comment|/* non-zero indicates target error */
DECL|member|sense_data
id|Longword
id|sense_data
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Allowed BIOS base addresses for 14f (NULL indicates reserved) */
DECL|variable|bios_segment_table
r_static
r_const
r_void
op_star
r_const
id|bios_segment_table
(braket
l_int|8
)braket
op_assign
(brace
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|0xC4000
comma
(paren
r_void
op_star
)paren
l_int|0xC8000
comma
(paren
r_void
op_star
)paren
l_int|0xCC000
comma
(paren
r_void
op_star
)paren
l_int|0xD0000
comma
(paren
r_void
op_star
)paren
l_int|0xD4000
comma
(paren
r_void
op_star
)paren
l_int|0xD8000
comma
(paren
r_void
op_star
)paren
l_int|0xDC000
comma
)brace
suffix:semicolon
multiline_comment|/* Allowed IRQs for 14f */
DECL|variable|interrupt_table
r_static
r_const
r_int
r_char
id|interrupt_table
(braket
l_int|4
)braket
op_assign
(brace
l_int|15
comma
l_int|14
comma
l_int|11
comma
l_int|10
)brace
suffix:semicolon
multiline_comment|/* Allowed DMA channels for 14f (0 indicates reserved) */
DECL|variable|dma_channel_table
r_static
r_const
r_int
r_char
id|dma_channel_table
(braket
l_int|4
)braket
op_assign
(brace
l_int|5
comma
l_int|6
comma
l_int|7
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* Head/sector mappings allowed by 14f */
r_static
r_const
r_struct
(brace
DECL|member|heads
r_int
r_char
id|heads
suffix:semicolon
DECL|member|sectors
r_int
r_char
id|sectors
suffix:semicolon
DECL|variable|mapping_table
)brace
id|mapping_table
(braket
l_int|4
)braket
op_assign
(brace
(brace
l_int|16
comma
l_int|63
)brace
comma
(brace
l_int|64
comma
l_int|32
)brace
comma
(brace
l_int|64
comma
l_int|63
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* Config info */
DECL|variable|config
r_static
r_struct
id|config
id|config
suffix:semicolon
multiline_comment|/* Our index in the host adapter array maintained by higher-level driver */
DECL|variable|host_number
r_static
r_int
id|host_number
suffix:semicolon
multiline_comment|/* PORT_ADDRESS is first port address used for i/o of messages. */
macro_line|#ifdef PORT_OVERRIDE
DECL|macro|PORT_ADDRESS
macro_line|# define PORT_ADDRESS PORT_OVERRIDE
macro_line|#else
DECL|macro|PORT_ADDRESS
macro_line|# define PORT_ADDRESS (config.port_address)
macro_line|#endif
DECL|variable|aborted
r_static
r_volatile
r_int
id|aborted
op_assign
l_int|0
suffix:semicolon
macro_line|#ifndef PORT_OVERRIDE
DECL|variable|ultrastor_ports
r_static
r_const
r_int
r_int
id|ultrastor_ports
(braket
)braket
op_assign
(brace
l_int|0x330
comma
l_int|0x340
comma
l_int|0x310
comma
l_int|0x230
comma
l_int|0x240
comma
l_int|0x210
comma
l_int|0x130
comma
l_int|0x140
comma
)brace
suffix:semicolon
macro_line|#endif
r_void
id|ultrastor_interrupt
c_func
(paren
r_int
id|cpl
)paren
suffix:semicolon
DECL|variable|ultrastor_done
r_static
r_void
(paren
op_star
id|ultrastor_done
)paren
(paren
r_int
comma
r_int
)paren
op_assign
l_int|0
suffix:semicolon
r_static
r_const
r_struct
(brace
DECL|member|signature
r_const
r_char
op_star
id|signature
suffix:semicolon
DECL|member|offset
r_int
id|offset
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|variable|signatures
)brace
id|signatures
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;SBIOS 1.01 COPYRIGHT (C) UltraStor Corporation,1990-1992.&quot;
comma
l_int|0x10
comma
l_int|57
)brace
comma
)brace
suffix:semicolon
DECL|function|ultrastor_14f_detect
r_int
id|ultrastor_14f_detect
c_func
(paren
r_int
id|hostnum
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|in_byte
suffix:semicolon
r_struct
id|config_1
id|config_1
suffix:semicolon
r_struct
id|config_2
id|config_2
suffix:semicolon
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: called&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifndef PORT_OVERRIDE
id|PORT_ADDRESS
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|ultrastor_ports
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|PORT_ADDRESS
op_assign
id|ultrastor_ports
(braket
id|i
)braket
suffix:semicolon
macro_line|#endif
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: testing port address %03X&bslash;n&quot;
comma
id|PORT_ADDRESS
)paren
suffix:semicolon
macro_line|#endif
id|in_byte
op_assign
id|inb
c_func
(paren
id|PRODUCT_ID
c_func
(paren
id|PORT_ADDRESS
op_plus
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_byte
op_ne
id|US14F_PRODUCT_ID_0
)paren
(brace
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
macro_line|# ifdef PORT_OVERRIDE
id|printk
c_func
(paren
l_string|&quot;US14F: detect: wrong product ID 0 - %02X&bslash;n&quot;
comma
id|in_byte
)paren
suffix:semicolon
macro_line|# else
id|printk
c_func
(paren
l_string|&quot;US14F: detect: no adapter at port %03X&quot;
comma
id|PORT_ADDRESS
)paren
suffix:semicolon
macro_line|# endif
macro_line|#endif
macro_line|#ifdef PORT_OVERRIDE
r_return
id|FALSE
suffix:semicolon
macro_line|#else
r_continue
suffix:semicolon
macro_line|#endif
)brace
id|in_byte
op_assign
id|inb
c_func
(paren
id|PRODUCT_ID
c_func
(paren
id|PORT_ADDRESS
op_plus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* Only upper nibble is defined for Product ID 1 */
r_if
c_cond
(paren
(paren
id|in_byte
op_amp
l_int|0xF0
)paren
op_ne
id|US14F_PRODUCT_ID_1
)paren
(brace
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
macro_line|# ifdef PORT_OVERRIDE
id|printk
c_func
(paren
l_string|&quot;US14F: detect: wrong product ID 1 - %02X&bslash;n&quot;
comma
id|in_byte
)paren
suffix:semicolon
macro_line|# else
id|printk
c_func
(paren
l_string|&quot;US14F: detect: no adapter at port %03X&quot;
comma
id|PORT_ADDRESS
)paren
suffix:semicolon
macro_line|# endif
macro_line|#endif
macro_line|#ifdef PORT_OVERRIDE
r_return
id|FALSE
suffix:semicolon
macro_line|#else
r_continue
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifndef PORT_OVERRIDE
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|ARRAY_SIZE
c_func
(paren
id|ultrastor_ports
)paren
)paren
(brace
macro_line|# if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: no port address found!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|# endif
r_return
id|FALSE
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: adapter found at port address %03X&bslash;n&quot;
comma
id|PORT_ADDRESS
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* All above tests passed, must be the right thing.  Get some useful&n;       info. */
op_star
(paren
r_char
op_star
)paren
op_amp
id|config_1
op_assign
id|inb
c_func
(paren
id|CONFIG
c_func
(paren
id|PORT_ADDRESS
op_plus
l_int|0
)paren
)paren
suffix:semicolon
op_star
(paren
r_char
op_star
)paren
op_amp
id|config_2
op_assign
id|inb
c_func
(paren
id|CONFIG
c_func
(paren
id|PORT_ADDRESS
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|config.bios_segment
op_assign
id|bios_segment_table
(braket
id|config_1.bios_segment
)braket
suffix:semicolon
id|config.interrupt
op_assign
id|interrupt_table
(braket
id|config_1.interrupt
)braket
suffix:semicolon
id|config.dma_channel
op_assign
id|dma_channel_table
(braket
id|config_1.dma_channel
)braket
suffix:semicolon
id|config.ha_scsi_id
op_assign
id|config_2.ha_scsi_id
suffix:semicolon
id|config.heads
op_assign
id|mapping_table
(braket
id|config_2.mapping_mode
)braket
dot
id|heads
suffix:semicolon
id|config.sectors
op_assign
id|mapping_table
(braket
id|config_2.mapping_mode
)braket
dot
id|sectors
suffix:semicolon
id|config.bios_drive_number
op_assign
id|config_2.bios_drive_number
suffix:semicolon
multiline_comment|/* To verify this card, we simply look for the UltraStor SCSI from the&n;       BIOS version notice. */
r_if
c_cond
(paren
id|config.bios_segment
op_ne
l_int|NULL
)paren
(brace
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|found
op_logical_and
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|signatures
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|memcmp
c_func
(paren
(paren
r_char
op_star
)paren
id|config.bios_segment
op_plus
id|signatures
(braket
id|i
)braket
dot
id|offset
comma
id|signatures
(braket
id|i
)braket
dot
id|signature
comma
id|signatures
(braket
id|i
)braket
dot
id|length
)paren
)paren
id|found
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|found
)paren
id|config.bios_segment
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|config.bios_segment
)paren
(brace
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: not detected.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Final consistancy check, verify previous info. */
r_if
c_cond
(paren
op_logical_neg
id|config.dma_channel
op_logical_or
op_logical_neg
(paren
id|config_2.tfr_port
op_amp
l_int|0x2
)paren
)paren
(brace
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: consistancy check failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* If we were TRULY paranoid, we could issue a host adapter inquiry&n;       command here and verify the data returned.  But frankly, I&squot;m&n;       exhausted! */
multiline_comment|/* Finally!  Now I&squot;m satisfied... */
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: detect succeeded&bslash;n&quot;
l_string|&quot;  Port address: %03X&bslash;n&quot;
l_string|&quot;  BIOS segment: %05X&bslash;n&quot;
l_string|&quot;  Interrupt: %u&bslash;n&quot;
l_string|&quot;  DMA channel: %u&bslash;n&quot;
l_string|&quot;  H/A SCSI ID: %u&bslash;n&quot;
comma
id|PORT_ADDRESS
comma
id|config.bios_segment
comma
id|config.interrupt
comma
id|config.dma_channel
comma
id|config.ha_scsi_id
)paren
suffix:semicolon
macro_line|#endif
id|host_number
op_assign
id|hostnum
suffix:semicolon
id|scsi_hosts
(braket
id|hostnum
)braket
dot
id|this_id
op_assign
id|config.ha_scsi_id
suffix:semicolon
macro_line|#if USE_QUEUECOMMAND
(brace
r_struct
id|sigaction
id|sa
suffix:semicolon
id|sa.sa_handler
op_assign
id|ultrastor_interrupt
suffix:semicolon
id|sa.sa_flags
op_assign
id|SA_INTERRUPT
suffix:semicolon
id|sa.sa_mask
op_assign
l_int|0
suffix:semicolon
id|sa.sa_restorer
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|irqaction
c_func
(paren
id|config.interrupt
comma
op_amp
id|sa
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;unable to get IRQ%d for ultrastor controller&bslash;n&quot;
comma
id|config.interrupt
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
)brace
macro_line|#endif
r_return
id|TRUE
suffix:semicolon
)brace
DECL|function|ultrastor_14f_info
r_const
r_char
op_star
id|ultrastor_14f_info
c_func
(paren
r_void
)paren
(brace
r_return
l_string|&quot;UltraStor 14F SCSI driver version &quot;
id|VERSION
l_string|&quot; by David B. Gentzel&bslash;n&quot;
suffix:semicolon
)brace
DECL|variable|mscp
r_static
r_struct
id|mscp
id|mscp
op_assign
(brace
id|OP_SCSI
comma
id|DTD_SCSI
comma
id|FALSE
comma
id|TRUE
comma
id|FALSE
multiline_comment|/* This stuff doesn&squot;t change */
)brace
suffix:semicolon
DECL|function|ultrastor_14f_queuecommand
r_int
id|ultrastor_14f_queuecommand
c_func
(paren
r_int
r_char
id|target
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buff
comma
r_int
id|bufflen
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_int
comma
r_int
)paren
)paren
(brace
r_int
r_char
id|in_byte
suffix:semicolon
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_COMMAND)
id|printk
c_func
(paren
l_string|&quot;US14F: queuecommand: called&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Skip first (constant) byte */
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|mscp
op_plus
l_int|1
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mscp
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|mscp.target_id
op_assign
id|target
suffix:semicolon
multiline_comment|/* mscp.lun = ???; */
id|mscp.transfer_data
op_assign
op_star
(paren
id|Longword
op_star
)paren
op_amp
id|buff
suffix:semicolon
id|mscp.transfer_data_length
op_assign
op_star
(paren
id|Longword
op_star
)paren
op_amp
id|bufflen
comma
id|mscp.length_of_scsi_cdbs
op_assign
(paren
(paren
op_star
(paren
r_int
r_char
op_star
)paren
id|cmnd
op_le
l_int|0x1F
)paren
ques
c_cond
l_int|6
suffix:colon
l_int|10
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|mscp.scsi_cdbs
comma
id|cmnd
comma
id|mscp.length_of_scsi_cdbs
)paren
suffix:semicolon
multiline_comment|/* Find free OGM slot (OGMINT bit is 0) */
r_do
id|in_byte
op_assign
id|inb_p
c_func
(paren
id|LCL_DOORBELL_INTR
c_func
(paren
id|PORT_ADDRESS
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|aborted
op_logical_and
(paren
id|in_byte
op_amp
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aborted
)paren
multiline_comment|/* ??? is this right? */
r_return
(paren
id|aborted
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Store pointer in OGM address bytes */
id|outb_p
c_func
(paren
id|BYTE
c_func
(paren
op_amp
id|mscp
comma
l_int|0
)paren
comma
id|OGM_DATA_PTR
c_func
(paren
id|PORT_ADDRESS
op_plus
l_int|0
)paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|BYTE
c_func
(paren
op_amp
id|mscp
comma
l_int|1
)paren
comma
id|OGM_DATA_PTR
c_func
(paren
id|PORT_ADDRESS
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|BYTE
c_func
(paren
op_amp
id|mscp
comma
l_int|2
)paren
comma
id|OGM_DATA_PTR
c_func
(paren
id|PORT_ADDRESS
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|BYTE
c_func
(paren
op_amp
id|mscp
comma
l_int|3
)paren
comma
id|OGM_DATA_PTR
c_func
(paren
id|PORT_ADDRESS
op_plus
l_int|3
)paren
)paren
suffix:semicolon
multiline_comment|/* Issue OGM interrupt */
id|outb_p
c_func
(paren
l_int|0x1
comma
id|LCL_DOORBELL_INTR
c_func
(paren
id|PORT_ADDRESS
)paren
)paren
suffix:semicolon
id|ultrastor_done
op_assign
id|done
suffix:semicolon
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_COMMAND)
id|printk
c_func
(paren
l_string|&quot;US14F: queuecommand: returning&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if !USE_QUEUECOMMAND
DECL|function|ultrastor_14f_command
r_int
id|ultrastor_14f_command
c_func
(paren
r_int
r_char
id|target
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buff
comma
r_int
id|bufflen
)paren
(brace
r_int
r_char
id|in_byte
suffix:semicolon
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_COMMAND)
id|printk
c_func
(paren
l_string|&quot;US14F: command: called&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
(paren
r_void
)paren
id|ultrastor_14f_queuecommand
c_func
(paren
id|target
comma
id|cmnd
comma
id|buff
comma
id|bufflen
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Wait for ICM interrupt */
r_do
id|in_byte
op_assign
id|inb_p
c_func
(paren
id|SYS_DOORBELL_INTR
c_func
(paren
id|PORT_ADDRESS
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|aborted
op_logical_and
op_logical_neg
(paren
id|in_byte
op_amp
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aborted
)paren
multiline_comment|/* ??? is this right? */
r_return
(paren
id|aborted
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* Clean ICM slot (set ICMINT bit to 0) */
id|outb_p
c_func
(paren
l_int|0x1
comma
id|SYS_DOORBELL_INTR
c_func
(paren
id|PORT_ADDRESS
)paren
)paren
suffix:semicolon
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_COMMAND)
id|printk
c_func
(paren
l_string|&quot;US14F: command: returning %08X&bslash;n&quot;
comma
(paren
id|mscp.adapter_status
op_lshift
l_int|16
)paren
op_or
id|mscp.target_status
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* ??? not right, but okay for now? */
r_return
(paren
id|mscp.adapter_status
op_lshift
l_int|16
)paren
op_or
id|mscp.target_status
suffix:semicolon
)brace
macro_line|#endif
DECL|function|ultrastor_14f_abort
r_int
id|ultrastor_14f_abort
c_func
(paren
r_int
id|code
)paren
(brace
id|aborted
op_assign
(paren
id|code
ques
c_cond
id|code
suffix:colon
id|DID_ABORT
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ultrastor_14f_reset
r_int
id|ultrastor_14f_reset
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|in_byte
suffix:semicolon
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_RESET)
id|printk
c_func
(paren
l_string|&quot;US14F: reset: called&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Issue SCSI BUS reset */
id|outb_p
c_func
(paren
l_int|0x20
comma
id|LCL_DOORBELL_INTR
c_func
(paren
id|PORT_ADDRESS
)paren
)paren
suffix:semicolon
multiline_comment|/* Wait for completion... */
r_do
id|in_byte
op_assign
id|inb_p
c_func
(paren
id|LCL_DOORBELL_INTR
c_func
(paren
id|PORT_ADDRESS
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|in_byte
op_amp
l_int|0x20
)paren
suffix:semicolon
id|aborted
op_assign
id|DID_RESET
suffix:semicolon
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_RESET)
id|printk
c_func
(paren
l_string|&quot;US14F: reset: returning&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if USE_QUEUECOMMAND
DECL|function|ultrastor_interrupt
r_void
id|ultrastor_interrupt
c_func
(paren
r_int
id|cpl
)paren
(brace
r_if
c_cond
(paren
id|ultrastor_done
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;US14F: unexpected ultrastor interrupt&bslash;n&bslash;r&quot;
)paren
suffix:semicolon
multiline_comment|/* ??? Anything else we should do here?  Reset? */
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;US14F: got an ultrastor interrupt: %u&bslash;n&bslash;r&quot;
comma
(paren
id|mscp.adapter_status
op_lshift
l_int|16
)paren
op_or
id|mscp.target_status
)paren
suffix:semicolon
id|ultrastor_done
c_func
(paren
id|host_number
comma
(paren
id|mscp.adapter_status
op_lshift
l_int|16
)paren
op_or
id|mscp.target_status
)paren
suffix:semicolon
id|ultrastor_done
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif
eof
