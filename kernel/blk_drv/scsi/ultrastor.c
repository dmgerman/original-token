multiline_comment|/*&n; *&t;ultrastor.c&t;Copyright (C) 1992 David B. Gentzel&n; *&t;Low-level SCSI driver for UltraStor 14F&n; *&t;by David B. Gentzel, Whitfield Software Services, Carnegie, PA&n; *&t;    (gentzel@nova.enet.dec.com)&n; *  scatter/gather added by Scott Taylor (n217cg@tamuts.tamu.edu)&n; *&t;Thanks to UltraStor for providing the necessary documentation&n; */
multiline_comment|/*&n; * TODO:&n; *&t;1. Cleanup error handling &amp; reporting.&n; *&t;2. Find out why scatter/gather is limited to 16 requests per command.&n; *&t;3. Add multiple outstanding requests.&n; *&t;4. See if we can make good use of having more than one command per lun.&n; *&t;5. Test/improve/fix abort &amp; reset functions.&n; *&t;6. Look at command linking (mscp.command_link and&n; *&t;   mscp.command_link_id).&n; */
multiline_comment|/*&n; * NOTES:&n; *    The UltraStor 14F is one of a family of intelligent, high performance&n; *    SCSI-2 host adapters.  They all support command queueing and&n; *    scatter/gather I/O.  Some of them can also emulate the standard&n; *    WD1003 interface for use with OS&squot;s which don&squot;t support SCSI.&n; *    Here is the scoop on the various models:&n; *&t;14F - ISA first-party DMA HA with floppy support and WD1003 emulation.&n; *&t;14N - ISA HA with floppy support.  I think that this is a non-DMA&n; *&t;      HA.  Nothing further known.&n; *&t;24F - EISA Bus Master HA with floppy support and WD1003 emulation.&n; *&t;34F - VL-Bus Bus Master HA with floppy support (no WD1003 emulation).&n; *&n; *    The 14F is supported by this driver.  An effort has been made to support&n; *    the 34F.  It should work, but is untested.  The 24F does not work at&n; *    present.&n; *&n; *    Places flagged with a triple question-mark are things which are either&n; *    unfinished, questionable, or wrong.&n; */
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
DECL|macro|ULTRASTOR_PRIVATE
mdefine_line|#define ULTRASTOR_PRIVATE&t;/* Get the private stuff from ultrastor.h */
macro_line|#include &quot;../blk.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;ultrastor.h&quot;
DECL|macro|ULTRASTOR_DEBUG
mdefine_line|#define ULTRASTOR_DEBUG 0
DECL|macro|VERSION
mdefine_line|#define VERSION &quot;1.1 alpha&quot;
DECL|macro|ARRAY_SIZE
mdefine_line|#define ARRAY_SIZE(arr) (sizeof (arr) / sizeof (arr)[0])
DECL|macro|BYTE
mdefine_line|#define BYTE(num, n) ((unsigned char)((unsigned int)(num) &gt;&gt; ((n) * 8)))
multiline_comment|/* Simply using &quot;unsigned long&quot; in these structures won&squot;t work as it causes&n;   alignment.  Perhaps the &quot;aligned&quot; attribute may be used in GCC 2.0 to get&n;   around this, but for now I use this hack. */
r_typedef
r_struct
(brace
DECL|member|bytes
r_int
r_char
id|bytes
(braket
l_int|4
)braket
suffix:semicolon
DECL|typedef|Longword
)brace
id|Longword
suffix:semicolon
multiline_comment|/* Used to fetch the configuration info from the config i/o registers.  We&n;   then store (in a friendlier format) in config. */
DECL|struct|config_1
r_struct
id|config_1
(brace
DECL|member|bios_segment
r_int
r_char
id|bios_segment
suffix:colon
l_int|3
suffix:semicolon
DECL|member|removable_disks_as_fixed
r_int
r_char
id|removable_disks_as_fixed
suffix:colon
l_int|1
suffix:semicolon
DECL|member|interrupt
r_int
r_char
id|interrupt
suffix:colon
l_int|2
suffix:semicolon
DECL|member|dma_channel
r_int
r_char
id|dma_channel
suffix:colon
l_int|2
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|config_2
r_struct
id|config_2
(brace
DECL|member|ha_scsi_id
r_int
r_char
id|ha_scsi_id
suffix:colon
l_int|3
suffix:semicolon
DECL|member|mapping_mode
r_int
r_char
id|mapping_mode
suffix:colon
l_int|2
suffix:semicolon
DECL|member|bios_drive_number
r_int
r_char
id|bios_drive_number
suffix:colon
l_int|1
suffix:semicolon
DECL|member|tfr_port
r_int
r_char
id|tfr_port
suffix:colon
l_int|2
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Used to store configuration info read from config i/o registers.  Most of&n;   this is not used yet, but might as well save it. */
DECL|struct|config
r_struct
id|config
(brace
DECL|member|bios_segment
r_const
r_void
op_star
id|bios_segment
suffix:semicolon
DECL|member|port_address
r_int
r_int
id|port_address
suffix:semicolon
DECL|member|interrupt
r_int
r_char
id|interrupt
suffix:colon
l_int|4
suffix:semicolon
DECL|member|dma_channel
r_int
r_char
id|dma_channel
suffix:colon
l_int|3
suffix:semicolon
DECL|member|bios_drive_number
r_int
r_char
id|bios_drive_number
suffix:colon
l_int|1
suffix:semicolon
DECL|member|heads
r_int
r_char
id|heads
suffix:semicolon
DECL|member|sectors
r_int
r_char
id|sectors
suffix:semicolon
DECL|member|ha_scsi_id
r_int
r_char
id|ha_scsi_id
suffix:colon
l_int|3
suffix:semicolon
DECL|member|subversion
r_int
r_char
id|subversion
suffix:colon
l_int|4
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* MailBox SCSI Command Packet.  Basic command structure for communicating&n;   with controller. */
DECL|struct|mscp
r_struct
id|mscp
(brace
DECL|member|opcode
r_int
r_char
id|opcode
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* type of command */
DECL|member|xdir
r_int
r_char
id|xdir
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* data transfer direction */
DECL|member|dcn
r_int
r_char
id|dcn
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* disable disconnect */
DECL|member|ca
r_int
r_char
id|ca
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* use cache (if available) */
DECL|member|sg
r_int
r_char
id|sg
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* scatter/gather operation */
DECL|member|target_id
r_int
r_char
id|target_id
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* target SCSI id */
DECL|member|ch_no
r_int
r_char
id|ch_no
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* SCSI channel (always 0 for 14f) */
DECL|member|lun
r_int
r_char
id|lun
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* logical unit number */
DECL|member|transfer_data
id|Longword
id|transfer_data
suffix:semicolon
multiline_comment|/* transfer data pointer */
DECL|member|transfer_data_length
id|Longword
id|transfer_data_length
suffix:semicolon
multiline_comment|/* length in bytes */
DECL|member|command_link
id|Longword
id|command_link
suffix:semicolon
multiline_comment|/* for linking command chains */
DECL|member|scsi_command_link_id
r_int
r_char
id|scsi_command_link_id
suffix:semicolon
multiline_comment|/* identifies command in chain */
DECL|member|number_of_sg_list
r_int
r_char
id|number_of_sg_list
suffix:semicolon
multiline_comment|/* (if sg is set) 8 bytes per list */
DECL|member|length_of_sense_byte
r_int
r_char
id|length_of_sense_byte
suffix:semicolon
DECL|member|length_of_scsi_cdbs
r_int
r_char
id|length_of_scsi_cdbs
suffix:semicolon
multiline_comment|/* 6, 10, or 12 */
DECL|member|scsi_cdbs
r_int
r_char
id|scsi_cdbs
(braket
l_int|12
)braket
suffix:semicolon
multiline_comment|/* SCSI commands */
DECL|member|adapter_status
r_int
r_char
id|adapter_status
suffix:semicolon
multiline_comment|/* non-zero indicates HA error */
DECL|member|target_status
r_int
r_char
id|target_status
suffix:semicolon
multiline_comment|/* non-zero indicates target error */
DECL|member|sense_data
id|Longword
id|sense_data
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* The 14F uses an array of unaligned 4-byte ints for its scatter/gather list. */
r_typedef
r_struct
(brace
DECL|member|address
r_int
r_int
id|address
suffix:semicolon
DECL|member|num_bytes
r_int
r_int
id|num_bytes
suffix:semicolon
DECL|typedef|ultrastor_sg_list
)brace
id|ultrastor_sg_list
suffix:semicolon
multiline_comment|/* This is our semaphore for mscp block availability */
DECL|variable|mscp_free
r_int
id|mscp_free
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Allowed BIOS base addresses for 14f (NULL indicates reserved) */
DECL|variable|bios_segment_table_14f
r_static
r_const
r_void
op_star
r_const
id|bios_segment_table_14f
(braket
l_int|8
)braket
op_assign
(brace
l_int|NULL
comma
(paren
r_void
op_star
)paren
l_int|0xC4000
comma
(paren
r_void
op_star
)paren
l_int|0xC8000
comma
(paren
r_void
op_star
)paren
l_int|0xCC000
comma
(paren
r_void
op_star
)paren
l_int|0xD0000
comma
(paren
r_void
op_star
)paren
l_int|0xD4000
comma
(paren
r_void
op_star
)paren
l_int|0xD8000
comma
(paren
r_void
op_star
)paren
l_int|0xDC000
comma
)brace
suffix:semicolon
multiline_comment|/* Allowed IRQs for 14f */
DECL|variable|interrupt_table_14f
r_static
r_const
r_int
r_char
id|interrupt_table_14f
(braket
l_int|4
)braket
op_assign
(brace
l_int|15
comma
l_int|14
comma
l_int|11
comma
l_int|10
)brace
suffix:semicolon
multiline_comment|/* Allowed DMA channels for 14f (0 indicates reserved) */
DECL|variable|dma_channel_table_14f
r_static
r_const
r_int
r_char
id|dma_channel_table_14f
(braket
l_int|4
)braket
op_assign
(brace
l_int|5
comma
l_int|6
comma
l_int|7
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* Head/sector mappings allowed by 14f */
r_static
r_const
r_struct
(brace
DECL|member|heads
r_int
r_char
id|heads
suffix:semicolon
DECL|member|sectors
r_int
r_char
id|sectors
suffix:semicolon
DECL|variable|mapping_table_14f
)brace
id|mapping_table_14f
(braket
l_int|4
)braket
op_assign
(brace
(brace
l_int|16
comma
l_int|63
)brace
comma
(brace
l_int|64
comma
l_int|32
)brace
comma
(brace
l_int|64
comma
l_int|63
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* Subversions of the 14F */
DECL|variable|subversion_names
r_static
r_const
r_char
op_star
r_const
id|subversion_names
(braket
)braket
op_assign
(brace
l_string|&quot;14F&quot;
comma
l_string|&quot;34F&quot;
)brace
suffix:semicolon
multiline_comment|/* Config info */
DECL|variable|config
r_static
r_struct
id|config
id|config
suffix:semicolon
multiline_comment|/* Our index in the host adapter array maintained by higher-level driver */
DECL|variable|host_number
r_static
r_int
id|host_number
suffix:semicolon
multiline_comment|/* PORT_ADDRESS is first port address used for i/o of messages. */
macro_line|#ifdef PORT_OVERRIDE
DECL|macro|PORT_ADDRESS
macro_line|# define PORT_ADDRESS PORT_OVERRIDE
macro_line|#else
DECL|macro|PORT_ADDRESS
macro_line|# define PORT_ADDRESS (config.port_address)
macro_line|#endif
DECL|variable|aborted
r_static
r_volatile
r_int
id|aborted
op_assign
l_int|0
suffix:semicolon
macro_line|#ifndef PORT_OVERRIDE
multiline_comment|/* ??? A probe of address 0x310 screws up NE2000 cards */
DECL|variable|ultrastor_ports_14f
r_static
r_const
r_int
r_int
id|ultrastor_ports_14f
(braket
)braket
op_assign
(brace
l_int|0x330
comma
l_int|0x340
comma
multiline_comment|/*0x310,*/
l_int|0x230
comma
l_int|0x240
comma
l_int|0x210
comma
l_int|0x130
comma
l_int|0x140
comma
)brace
suffix:semicolon
macro_line|#endif
r_static
r_void
id|ultrastor_interrupt
c_func
(paren
r_int
id|cpl
)paren
suffix:semicolon
r_static
r_inline
r_void
id|build_sg_list
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
DECL|variable|ultrastor_done
r_static
r_void
(paren
op_star
id|ultrastor_done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
op_assign
l_int|0
suffix:semicolon
DECL|variable|SCint
r_static
id|Scsi_Cmnd
op_star
id|SCint
op_assign
l_int|NULL
suffix:semicolon
DECL|function|ultrastor_detect
r_int
id|ultrastor_detect
c_func
(paren
r_int
id|hostnum
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|in_byte
comma
id|version_byte
op_assign
l_int|0
suffix:semicolon
r_struct
id|config_1
id|config_1
suffix:semicolon
r_struct
id|config_2
id|config_2
suffix:semicolon
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: called&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifndef PORT_OVERRIDE
id|PORT_ADDRESS
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|ultrastor_ports_14f
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|PORT_ADDRESS
op_assign
id|ultrastor_ports_14f
(braket
id|i
)braket
suffix:semicolon
macro_line|#endif
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: testing port address %03X&bslash;n&quot;
comma
id|PORT_ADDRESS
)paren
suffix:semicolon
macro_line|#endif
id|in_byte
op_assign
id|inb
c_func
(paren
id|PRODUCT_ID
c_func
(paren
id|PORT_ADDRESS
op_plus
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_byte
op_ne
id|US14F_PRODUCT_ID_0
)paren
(brace
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
macro_line|# ifdef PORT_OVERRIDE
id|printk
c_func
(paren
l_string|&quot;US14F: detect: wrong product ID 0 - %02X&bslash;n&quot;
comma
id|in_byte
)paren
suffix:semicolon
macro_line|# else
id|printk
c_func
(paren
l_string|&quot;US14F: detect: no adapter at port %03X&bslash;n&quot;
comma
id|PORT_ADDRESS
)paren
suffix:semicolon
macro_line|# endif
macro_line|#endif
macro_line|#ifdef PORT_OVERRIDE
r_return
id|FALSE
suffix:semicolon
macro_line|#else
r_continue
suffix:semicolon
macro_line|#endif
)brace
id|in_byte
op_assign
id|inb
c_func
(paren
id|PRODUCT_ID
c_func
(paren
id|PORT_ADDRESS
op_plus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* Only upper nibble is significant for Product ID 1 */
r_if
c_cond
(paren
(paren
id|in_byte
op_amp
l_int|0xF0
)paren
op_ne
id|US14F_PRODUCT_ID_1
)paren
(brace
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
macro_line|# ifdef PORT_OVERRIDE
id|printk
c_func
(paren
l_string|&quot;US14F: detect: wrong product ID 1 - %02X&bslash;n&quot;
comma
id|in_byte
)paren
suffix:semicolon
macro_line|# else
id|printk
c_func
(paren
l_string|&quot;US14F: detect: no adapter at port %03X&bslash;n&quot;
comma
id|PORT_ADDRESS
)paren
suffix:semicolon
macro_line|# endif
macro_line|#endif
macro_line|#ifdef PORT_OVERRIDE
r_return
id|FALSE
suffix:semicolon
macro_line|#else
r_continue
suffix:semicolon
macro_line|#endif
)brace
id|version_byte
op_assign
id|in_byte
suffix:semicolon
macro_line|#ifndef PORT_OVERRIDE
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|ARRAY_SIZE
c_func
(paren
id|ultrastor_ports_14f
)paren
)paren
(brace
macro_line|# if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: no port address found!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|# endif
r_return
id|FALSE
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: adapter found at port address %03X&bslash;n&quot;
comma
id|PORT_ADDRESS
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* All above tests passed, must be the right thing.  Get some useful&n;       info. */
op_star
(paren
r_char
op_star
)paren
op_amp
id|config_1
op_assign
id|inb
c_func
(paren
id|CONFIG
c_func
(paren
id|PORT_ADDRESS
op_plus
l_int|0
)paren
)paren
suffix:semicolon
op_star
(paren
r_char
op_star
)paren
op_amp
id|config_2
op_assign
id|inb
c_func
(paren
id|CONFIG
c_func
(paren
id|PORT_ADDRESS
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|config.bios_segment
op_assign
id|bios_segment_table_14f
(braket
id|config_1.bios_segment
)braket
suffix:semicolon
id|config.interrupt
op_assign
id|interrupt_table_14f
(braket
id|config_1.interrupt
)braket
suffix:semicolon
id|config.ha_scsi_id
op_assign
id|config_2.ha_scsi_id
suffix:semicolon
id|config.heads
op_assign
id|mapping_table_14f
(braket
id|config_2.mapping_mode
)braket
dot
id|heads
suffix:semicolon
id|config.sectors
op_assign
id|mapping_table_14f
(braket
id|config_2.mapping_mode
)braket
dot
id|sectors
suffix:semicolon
id|config.bios_drive_number
op_assign
id|config_2.bios_drive_number
suffix:semicolon
id|config.subversion
op_assign
(paren
id|version_byte
op_amp
l_int|0x0F
)paren
suffix:semicolon
r_if
c_cond
(paren
id|config.subversion
op_eq
id|U34F
)paren
id|config.dma_channel
op_assign
l_int|0
suffix:semicolon
r_else
id|config.dma_channel
op_assign
id|dma_channel_table_14f
(braket
id|config_1.dma_channel
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|config.bios_segment
)paren
(brace
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: not detected.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Final consistancy check, verify previous info. */
r_if
c_cond
(paren
id|config.subversion
op_ne
id|U34F
)paren
r_if
c_cond
(paren
op_logical_neg
id|config.dma_channel
op_logical_or
op_logical_neg
(paren
id|config_2.tfr_port
op_amp
l_int|0x2
)paren
)paren
(brace
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: consistancy check failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* If we were TRULY paranoid, we could issue a host adapter inquiry&n;       command here and verify the data returned.  But frankly, I&squot;m&n;       exhausted! */
multiline_comment|/* Finally!  Now I&squot;m satisfied... */
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_DETECT)
id|printk
c_func
(paren
l_string|&quot;US14F: detect: detect succeeded&bslash;n&quot;
l_string|&quot;  Port address: %03X&bslash;n&quot;
l_string|&quot;  BIOS segment: %05X&bslash;n&quot;
l_string|&quot;  Interrupt: %u&bslash;n&quot;
l_string|&quot;  DMA channel: %u&bslash;n&quot;
l_string|&quot;  H/A SCSI ID: %u&bslash;n&quot;
l_string|&quot;  Subversion: %u&bslash;n&quot;
comma
id|PORT_ADDRESS
comma
id|config.bios_segment
comma
id|config.interrupt
comma
id|config.dma_channel
comma
id|config.ha_scsi_id
comma
id|config.subversion
)paren
suffix:semicolon
macro_line|#endif
id|host_number
op_assign
id|hostnum
suffix:semicolon
id|scsi_hosts
(braket
id|hostnum
)braket
dot
id|this_id
op_assign
id|config.ha_scsi_id
suffix:semicolon
id|scsi_hosts
(braket
id|hostnum
)braket
dot
id|unchecked_isa_dma
op_assign
(paren
id|config.subversion
op_ne
id|U34F
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|config.interrupt
comma
id|ultrastor_interrupt
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to allocate IRQ%u for UltraStor controller.&bslash;n&quot;
comma
id|config.interrupt
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|config.dma_channel
op_logical_and
id|request_dma
c_func
(paren
id|config.dma_channel
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to allocate DMA channel %u for UltraStor controller.&bslash;n&quot;
comma
id|config.dma_channel
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|config.interrupt
)paren
suffix:semicolon
r_return
id|FALSE
suffix:semicolon
)brace
id|scsi_hosts
(braket
id|hostnum
)braket
dot
id|sg_tablesize
op_assign
id|ULTRASTOR_14F_MAX_SG
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;UltraStor: scatter/gather enabled.  Using %d SG lists.&bslash;n&quot;
comma
id|ULTRASTOR_14F_MAX_SG
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
DECL|function|ultrastor_info
r_const
r_char
op_star
id|ultrastor_info
c_func
(paren
r_void
)paren
(brace
r_static
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
(paren
r_void
)paren
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;UltraStor %s SCSI @ Port %03X BIOS %05X IRQ%u DMA%u&bslash;n&quot;
comma
(paren
(paren
id|config.subversion
OL
id|ARRAY_SIZE
c_func
(paren
id|subversion_names
)paren
)paren
ques
c_cond
id|subversion_names
(braket
id|config.subversion
)braket
suffix:colon
l_string|&quot;14F?&quot;
)paren
comma
id|PORT_ADDRESS
comma
(paren
r_int
)paren
id|config.bios_segment
comma
id|config.interrupt
comma
id|config.dma_channel
)paren
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
DECL|variable|mscp
r_static
r_struct
id|mscp
id|mscp
op_assign
(brace
id|OP_SCSI
comma
id|DTD_SCSI
comma
l_int|0
comma
l_int|1
comma
l_int|0
multiline_comment|/* This stuff doesn&squot;t change */
)brace
suffix:semicolon
DECL|function|build_sg_list
r_static
r_inline
r_void
id|build_sg_list
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
id|ultrastor_sg_list
op_star
id|sglist
suffix:semicolon
r_struct
id|scatterlist
op_star
id|sl
suffix:semicolon
r_int
id|transfer_length
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|sl
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|SCpnt-&gt;request_buffer
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
(paren
r_int
r_char
op_star
)paren
id|scsi_malloc
c_func
(paren
l_int|512
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;host_scribble
op_eq
l_int|NULL
)paren
multiline_comment|/* Not sure what to do here; just panic for now */
id|panic
c_func
(paren
l_string|&quot;US14F: Can&squot;t allocate DMA buffer for scatter-gather list!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Save ourselves some casts; can eliminate when we don&squot;t have to look at it anymore! */
id|sglist
op_assign
(paren
id|ultrastor_sg_list
op_star
)paren
id|SCpnt-&gt;host_scribble
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SCpnt-&gt;use_sg
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sglist
(braket
id|i
)braket
dot
id|address
op_assign
id|sl
(braket
id|i
)braket
dot
id|address
suffix:semicolon
id|sglist
(braket
id|i
)braket
dot
id|num_bytes
op_assign
id|sl
(braket
id|i
)braket
dot
id|length
suffix:semicolon
id|transfer_length
op_add_assign
id|sl
(braket
id|i
)braket
dot
id|length
suffix:semicolon
)brace
id|mscp.number_of_sg_list
op_assign
(paren
r_char
)paren
id|SCpnt-&gt;use_sg
suffix:semicolon
id|mscp.transfer_data
op_assign
op_star
(paren
id|Longword
op_star
)paren
op_amp
id|sglist
suffix:semicolon
multiline_comment|/* ??? May not be necessary.  Docs are unclear as to whether transfer length field is */
multiline_comment|/* ignored or whether it should be set to the total number of bytes of the transfer.  */
id|mscp.transfer_data_length
op_assign
op_star
(paren
id|Longword
op_star
)paren
op_amp
id|transfer_length
suffix:semicolon
)brace
DECL|function|ultrastor_queuecommand
r_int
id|ultrastor_queuecommand
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_int
r_char
id|in_byte
suffix:semicolon
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_COMMAND)
id|printk
c_func
(paren
l_string|&quot;US14F: queuecommand: called&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* We want to be sure that a command queued while another command   */
multiline_comment|/* is running doesn&squot;t overwrite the mscp block until the running    */
multiline_comment|/* command is finished.  mscp_free is set in the interrupt handler. */
multiline_comment|/* I&squot;m not sure if the upper level driver will send another command */
multiline_comment|/* with a command pending; this is just insurance.                  */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mscp_free
)paren
(brace
id|mscp_free
op_assign
id|FALSE
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
id|mscp.opcode
op_assign
id|OP_SCSI
suffix:semicolon
id|mscp.xdir
op_assign
id|DTD_SCSI
suffix:semicolon
id|mscp.dcn
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Tape drives don&squot;t work properly if the cache is used.  The SCSI&n;       READ command for a tape doesn&squot;t have a block offset, and the adapter&n;       incorrectly assumes that all reads from the tape read the same&n;       blocks.  Results will depend on read buffer size and other disk&n;       activity. &n;&n;       ???  Which other device types should never use the cache?   */
id|mscp.ca
op_assign
id|scsi_devices
(braket
id|SCpnt-&gt;index
)braket
dot
id|type
op_ne
id|TYPE_TAPE
suffix:semicolon
id|mscp.target_id
op_assign
id|SCpnt-&gt;target
suffix:semicolon
id|mscp.ch_no
op_assign
l_int|0
suffix:semicolon
id|mscp.lun
op_assign
id|SCpnt-&gt;lun
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;use_sg
)paren
(brace
multiline_comment|/* Set scatter/gather flag in SCSI command packet */
id|mscp.sg
op_assign
id|TRUE
suffix:semicolon
id|build_sg_list
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Unset scatter/gather flag in SCSI command packet */
id|mscp.sg
op_assign
id|FALSE
suffix:semicolon
id|mscp.transfer_data
op_assign
op_star
(paren
id|Longword
op_star
)paren
op_amp
id|SCpnt-&gt;request_buffer
suffix:semicolon
id|mscp.transfer_data_length
op_assign
op_star
(paren
id|Longword
op_star
)paren
op_amp
id|SCpnt-&gt;request_bufflen
suffix:semicolon
id|SCpnt-&gt;host_scribble
op_assign
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|mscp.command_link
comma
l_int|0
comma
r_sizeof
(paren
id|mscp.command_link
)paren
)paren
suffix:semicolon
multiline_comment|/*???*/
id|mscp.scsi_command_link_id
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*???*/
id|mscp.length_of_sense_byte
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*???*/
id|mscp.length_of_scsi_cdbs
op_assign
id|COMMAND_SIZE
c_func
(paren
op_star
(paren
r_int
r_char
op_star
)paren
id|SCpnt-&gt;cmnd
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|mscp.scsi_cdbs
comma
id|SCpnt-&gt;cmnd
comma
id|mscp.length_of_scsi_cdbs
)paren
suffix:semicolon
id|mscp.adapter_status
op_assign
l_int|0
suffix:semicolon
id|mscp.target_status
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|mscp.sense_data
comma
l_int|0
comma
r_sizeof
(paren
id|mscp.sense_data
)paren
)paren
suffix:semicolon
multiline_comment|/*???*/
multiline_comment|/* Find free OGM slot (OGMINT bit is 0) */
r_do
id|in_byte
op_assign
id|inb_p
c_func
(paren
id|LCL_DOORBELL_INTR
c_func
(paren
id|PORT_ADDRESS
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|aborted
op_logical_and
(paren
id|in_byte
op_amp
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aborted
)paren
(brace
macro_line|#if (ULTRASTOR_DEBUG &amp; (UD_COMMAND | UD_ABORT))
id|printk
c_func
(paren
l_string|&quot;US14F: queuecommand: aborted&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* ??? is this right? */
r_return
(paren
id|aborted
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
multiline_comment|/* Store pointer in OGM address bytes */
id|outb_p
c_func
(paren
id|BYTE
c_func
(paren
op_amp
id|mscp
comma
l_int|0
)paren
comma
id|OGM_DATA_PTR
c_func
(paren
id|PORT_ADDRESS
op_plus
l_int|0
)paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|BYTE
c_func
(paren
op_amp
id|mscp
comma
l_int|1
)paren
comma
id|OGM_DATA_PTR
c_func
(paren
id|PORT_ADDRESS
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|BYTE
c_func
(paren
op_amp
id|mscp
comma
l_int|2
)paren
comma
id|OGM_DATA_PTR
c_func
(paren
id|PORT_ADDRESS
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|BYTE
c_func
(paren
op_amp
id|mscp
comma
l_int|3
)paren
comma
id|OGM_DATA_PTR
c_func
(paren
id|PORT_ADDRESS
op_plus
l_int|3
)paren
)paren
suffix:semicolon
multiline_comment|/* Issue OGM interrupt */
id|outb_p
c_func
(paren
l_int|0x1
comma
id|LCL_DOORBELL_INTR
c_func
(paren
id|PORT_ADDRESS
)paren
)paren
suffix:semicolon
id|ultrastor_done
op_assign
id|done
suffix:semicolon
id|SCint
op_assign
id|SCpnt
suffix:semicolon
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_COMMAND)
id|printk
c_func
(paren
l_string|&quot;US14F: queuecommand: returning&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ultrastor_abort
r_int
id|ultrastor_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|code
)paren
(brace
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_ABORT)
id|printk
c_func
(paren
l_string|&quot;US14F: abort: called&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|aborted
op_assign
(paren
id|code
ques
c_cond
id|code
suffix:colon
id|DID_ABORT
)paren
suffix:semicolon
multiline_comment|/* Free DMA buffer used for scatter/gather list */
r_if
c_cond
(paren
id|SCpnt-&gt;host_scribble
)paren
id|scsi_free
c_func
(paren
id|SCpnt-&gt;host_scribble
comma
l_int|512
)paren
suffix:semicolon
multiline_comment|/* Free up mscp block for next command */
id|mscp_free
op_assign
id|TRUE
suffix:semicolon
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_ABORT)
id|printk
c_func
(paren
l_string|&quot;US14F: abort: returning&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ultrastor_reset
r_int
id|ultrastor_reset
c_func
(paren
r_void
)paren
(brace
macro_line|#if 0
r_int
r_char
id|in_byte
suffix:semicolon
macro_line|#endif
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_RESET)
id|printk
c_func
(paren
l_string|&quot;US14F: reset: called&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* ??? SCSI bus reset causes problems on some systems. */
macro_line|#if 0
multiline_comment|/* Issue SCSI BUS reset */
id|outb_p
c_func
(paren
l_int|0x20
comma
id|LCL_DOORBELL_INTR
c_func
(paren
id|PORT_ADDRESS
)paren
)paren
suffix:semicolon
multiline_comment|/* Wait for completion... */
r_do
id|in_byte
op_assign
id|inb_p
c_func
(paren
id|LCL_DOORBELL_INTR
c_func
(paren
id|PORT_ADDRESS
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|in_byte
op_amp
l_int|0x20
)paren
suffix:semicolon
id|aborted
op_assign
id|DID_RESET
suffix:semicolon
macro_line|#endif
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_RESET)
id|printk
c_func
(paren
l_string|&quot;US14F: reset: returning&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ultrastor_biosparam
r_int
id|ultrastor_biosparam
c_func
(paren
r_int
id|size
comma
r_int
id|dev
comma
r_int
op_star
id|ip
)paren
(brace
r_int
r_int
id|s
op_assign
id|config.heads
op_star
id|config.sectors
suffix:semicolon
id|ip
(braket
l_int|0
)braket
op_assign
id|config.heads
suffix:semicolon
id|ip
(braket
l_int|1
)braket
op_assign
id|config.sectors
suffix:semicolon
id|ip
(braket
l_int|2
)braket
op_assign
(paren
id|size
op_plus
(paren
id|s
op_minus
l_int|1
)paren
)paren
op_div
id|s
suffix:semicolon
multiline_comment|/*    if (ip[2] &gt; 1024)&n;&t;ip[2] = 1024; */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ultrastor_interrupt
r_static
r_void
id|ultrastor_interrupt
c_func
(paren
r_int
id|cpl
)paren
(brace
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_INTERRUPT)
id|printk
c_func
(paren
l_string|&quot;US14F: interrupt: called: status = %08X&bslash;n&quot;
comma
(paren
id|mscp.adapter_status
op_lshift
l_int|16
)paren
op_or
id|mscp.target_status
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ultrastor_done
op_eq
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;US14F: interrupt: unexpected interrupt&quot;
)paren
suffix:semicolon
r_else
(brace
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCtmp
suffix:semicolon
multiline_comment|/* Save ultrastor_done locally and zero before calling.  This is needed&n;&t;   as once we call done, we may get another command queued before this&n;&t;   interrupt service routine can return. */
id|done
op_assign
id|ultrastor_done
suffix:semicolon
id|ultrastor_done
op_assign
l_int|0
suffix:semicolon
id|SCtmp
op_assign
id|SCint
suffix:semicolon
multiline_comment|/* Clean ICM slot (set ICMINT bit to 0) */
id|outb_p
c_func
(paren
l_int|0x1
comma
id|SYS_DOORBELL_INTR
c_func
(paren
id|PORT_ADDRESS
)paren
)paren
suffix:semicolon
multiline_comment|/* Let the higher levels know that we&squot;re done */
multiline_comment|/* ??? status is wrong here... */
id|SCtmp-&gt;result
op_assign
(paren
id|mscp.adapter_status
op_lshift
l_int|16
)paren
op_or
id|mscp.target_status
suffix:semicolon
multiline_comment|/* Free temp space used for scatter-gather list */
r_if
c_cond
(paren
id|SCtmp-&gt;host_scribble
)paren
id|scsi_free
c_func
(paren
id|SCtmp-&gt;host_scribble
comma
l_int|512
)paren
suffix:semicolon
multiline_comment|/* Free up mscp block for next command */
id|mscp_free
op_assign
id|TRUE
suffix:semicolon
id|done
c_func
(paren
id|SCtmp
)paren
suffix:semicolon
)brace
macro_line|#if (ULTRASTOR_DEBUG &amp; UD_INTERRUPT)
id|printk
c_func
(paren
l_string|&quot;US14F: interrupt: returning&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
