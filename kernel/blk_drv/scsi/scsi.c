multiline_comment|/*&n; *&t;scsi.c Copyright (C) 1992 Drew Eckhardt &n; *&t;generic mid-level SCSI driver by&n; *&t;&t;Drew Eckhardt &n; *&n; *&t;&lt;drew@colorado.edu&gt;&n; *&n; *&t;Bug correction thanks go to : &n; *&t;&t;Rik Faith &lt;faith@cs.unc.edu&gt;&n; *&t;&t;Tommy Thorn &lt;tthorn&gt;&n; *&t;&t;Thomas Wuensche &lt;tw@fgb1.fgb.mw.tu-muenchen.de&gt;&n; * &n; *       Modified by Eric Youngdale eric@tantalus.nrl.navy.mil to&n; *       add scatter-gather, multiple outstanding request, and other&n; *       enhancements.&n; */
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &quot;../blk.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
multiline_comment|/*&n;static const char RCSid[] = &quot;$Header: /usr/src/linux/kernel/blk_drv/scsi/RCS/scsi.c,v 1.1 1992/07/24 06:27:38 root Exp root $&quot;;&n;*/
DECL|macro|INTERNAL_ERROR
mdefine_line|#define INTERNAL_ERROR (printk (&quot;Internal error in file %s, line %d.&bslash;n&quot;, __FILE__, __LINE__), panic(&quot;&quot;))
r_static
r_void
id|scsi_done
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
r_static
r_int
id|update_timeout
(paren
id|Scsi_Cmnd
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|data
)paren
suffix:semicolon
r_static
r_void
id|scsi_times_out
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
suffix:semicolon
DECL|variable|time_start
r_static
r_int
id|time_start
suffix:semicolon
DECL|variable|time_elapsed
r_static
r_int
id|time_elapsed
suffix:semicolon
multiline_comment|/*&n;&t;global variables : &n;&t;NR_SCSI_DEVICES is the number of SCSI devices we have detected, &n;&t;scsi_devices an array of these specifing the address for each &n;&t;(host, id, LUN)&n;*/
DECL|variable|NR_SCSI_DEVICES
r_int
id|NR_SCSI_DEVICES
op_assign
l_int|0
suffix:semicolon
DECL|variable|scsi_devices
id|Scsi_Device
op_star
id|scsi_devices
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|generic_sense
r_static
r_int
r_char
id|generic_sense
(braket
l_int|6
)braket
op_assign
(brace
id|REQUEST_SENSE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|255
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* We make this not static so that we can read the array with gdb. */
DECL|variable|last_cmnd
multiline_comment|/* static */
id|Scsi_Cmnd
op_star
id|last_cmnd
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; *&t;As the scsi do command functions are inteligent, and may need to &n; *&t;redo a command, we need to keep track of the last command &n; *&t;executed on each one.&n; */
DECL|macro|WAS_RESET
mdefine_line|#define WAS_RESET &t;0x01
DECL|macro|WAS_TIMEDOUT
mdefine_line|#define WAS_TIMEDOUT &t;0x02
DECL|macro|WAS_SENSE
mdefine_line|#define WAS_SENSE&t;0x04
DECL|macro|IS_RESETTING
mdefine_line|#define IS_RESETTING&t;0x08
r_extern
r_int
id|last_reset
(braket
)braket
suffix:semicolon
multiline_comment|/*&n; *&t;This is the number  of clock ticks we should wait before we time out &n; *&t;and abort the command.  This is for  where the scsi.c module generates &n; *&t;the command, not where it originates from a higher level, in which&n; *&t;case the timeout is specified there.&n; *&n; *&t;ABORT_TIMEOUT and RESET_TIMEOUT are the timeouts for RESET and ABORT&n; *&t;respectively.&n; */
macro_line|#ifdef DEBUG
DECL|macro|SCSI_TIMEOUT
mdefine_line|#define SCSI_TIMEOUT 500
macro_line|#else
DECL|macro|SCSI_TIMEOUT
mdefine_line|#define SCSI_TIMEOUT 100
macro_line|#endif
macro_line|#ifdef DEBUG
DECL|macro|SENSE_TIMEOUT
mdefine_line|#define SENSE_TIMEOUT SCSI_TIMEOUT
DECL|macro|ABORT_TIMEOUT
mdefine_line|#define ABORT_TIMEOUT SCSI_TIMEOUT
DECL|macro|RESET_TIMEOUT
mdefine_line|#define RESET_TIMEOUT SCSI_TIMEOUT
macro_line|#else
DECL|macro|SENSE_TIMEOUT
mdefine_line|#define SENSE_TIMEOUT 50
DECL|macro|RESET_TIMEOUT
mdefine_line|#define RESET_TIMEOUT 50
DECL|macro|ABORT_TIMEOUT
mdefine_line|#define ABORT_TIMEOUT 50
DECL|macro|MIN_RESET_DELAY
mdefine_line|#define MIN_RESET_DELAY 25
macro_line|#endif
multiline_comment|/* The following devices are known not to tolerate a lun != 0 scan for&n;   one reason or another.  Some will respond to all luns, others will&n;   lock up. */
DECL|struct|blist
r_struct
id|blist
(brace
DECL|member|vendor
r_char
op_star
id|vendor
suffix:semicolon
DECL|member|model
r_char
op_star
id|model
suffix:semicolon
DECL|member|revision
r_char
op_star
id|revision
suffix:semicolon
multiline_comment|/* Latest revision known to be bad.  Not used yet */
)brace
suffix:semicolon
DECL|variable|blacklist
r_static
r_struct
id|blist
id|blacklist
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;TANDBERG&quot;
comma
l_string|&quot;TDC 3600&quot;
comma
l_string|&quot;U07&quot;
)brace
comma
multiline_comment|/* Locks up if polled for lun != 0 */
(brace
l_string|&quot;SEAGATE&quot;
comma
l_string|&quot;ST296&quot;
comma
l_string|&quot;921&quot;
)brace
comma
multiline_comment|/* Responds to all lun */
(brace
l_string|&quot;SONY&quot;
comma
l_string|&quot;CD-ROM CDU-541&quot;
comma
l_string|&quot;4.3d&quot;
)brace
comma
(brace
l_string|&quot;DENON&quot;
comma
l_string|&quot;DRD-25X&quot;
comma
l_string|&quot;V&quot;
)brace
comma
multiline_comment|/* A cdrom that locks up when probed at lun != 0 */
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
suffix:semicolon
DECL|function|blacklisted
r_static
r_int
(def_block
id|blacklisted
c_func
(paren
r_char
op_star
id|response_data
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|pnt
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|blacklist
(braket
id|i
)braket
dot
id|vendor
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|pnt
op_assign
op_amp
id|response_data
(braket
l_int|8
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
op_star
id|pnt
op_eq
l_char|&squot; &squot;
)paren
(brace
id|pnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|blacklist
(braket
id|i
)braket
dot
id|vendor
comma
id|pnt
comma
id|strlen
c_func
(paren
id|blacklist
(braket
id|i
)braket
dot
id|vendor
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|pnt
op_assign
op_amp
id|response_data
(braket
l_int|16
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|pnt
op_logical_and
op_star
id|pnt
op_eq
l_char|&squot; &squot;
)paren
(brace
id|pnt
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|blacklist
(braket
id|i
)braket
dot
id|model
comma
id|pnt
comma
id|strlen
c_func
(paren
id|blacklist
(braket
id|i
)braket
dot
id|model
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
suffix:semicolon
)brace
)def_block
suffix:semicolon
multiline_comment|/*&n; *&t;As the actual SCSI command runs in the background, we must set up a &n; *&t;flag that tells scan_scsis() when the result it has is valid.  &n; *&t;scan_scsis can set the_result to -1, and watch for it to become the &n; *&t;actual return code for that call.  the scan_scsis_done function() is &n; *&t;our user specified completion function that is passed on to the  &n; *&t;scsi_do_cmd() function.&n; */
DECL|variable|in_scan
r_static
r_volatile
r_int
id|in_scan
op_assign
l_int|0
suffix:semicolon
DECL|variable|the_result
r_static
r_int
id|the_result
suffix:semicolon
DECL|function|scan_scsis_done
r_static
r_void
id|scan_scsis_done
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
(paren
l_string|&quot;scan_scsis_done(%d, %06x)&bslash;n&quot;
comma
id|SCpnt-&gt;host
comma
id|SCpnt-&gt;result
)paren
suffix:semicolon
macro_line|#endif&t;
id|SCpnt-&gt;request.dev
op_assign
l_int|0xfffe
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Detecting SCSI devices :&t;&n; *&t;We scan all present host adapter&squot;s busses,  from ID 0 to ID 6.  &n; *&t;We use the INQUIRY command, determine device type, and pass the ID / &n; *&t;lun address of all sequential devices to the tape driver, all random &n; *&t;devices to the disk driver.&n; */
DECL|function|scan_scsis
r_static
r_void
id|scan_scsis
(paren
r_void
)paren
(brace
r_int
id|host_nr
comma
id|dev
comma
id|lun
comma
id|type
suffix:semicolon
r_int
r_char
id|scsi_cmd
(braket
l_int|12
)braket
suffix:semicolon
r_int
r_char
id|scsi_result
(braket
l_int|256
)braket
suffix:semicolon
id|Scsi_Cmnd
id|SCmd
suffix:semicolon
op_increment
id|in_scan
suffix:semicolon
id|lun
op_assign
l_int|0
suffix:semicolon
id|SCmd.next
op_assign
l_int|NULL
suffix:semicolon
id|SCmd.prev
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|host_nr
op_assign
l_int|0
suffix:semicolon
id|host_nr
OL
id|max_scsi_hosts
suffix:semicolon
op_increment
id|host_nr
)paren
r_if
c_cond
(paren
id|scsi_hosts
(braket
id|host_nr
)braket
dot
id|present
)paren
(brace
id|host_queue
(braket
id|host_nr
)braket
op_assign
op_amp
id|SCmd
suffix:semicolon
multiline_comment|/* We need this so that commands can&n;&t;&t;&t;&t;&t;time out */
r_for
c_loop
(paren
id|dev
op_assign
l_int|0
suffix:semicolon
id|dev
OL
l_int|8
suffix:semicolon
op_increment
id|dev
)paren
r_if
c_cond
(paren
id|scsi_hosts
(braket
id|host_nr
)braket
dot
id|this_id
op_ne
id|dev
)paren
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
l_int|8
suffix:semicolon
op_increment
id|lun
)paren
(brace
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|host_no
op_assign
id|host_nr
suffix:semicolon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|id
op_assign
id|dev
suffix:semicolon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|lun
op_assign
id|lun
suffix:semicolon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|index
op_assign
id|NR_SCSI_DEVICES
suffix:semicolon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|device_wait
op_assign
l_int|NULL
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|TEST_UNIT_READY
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
id|lun
op_lshift
l_int|5
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
id|SCmd.host
op_assign
id|host_nr
suffix:semicolon
id|SCmd.target
op_assign
id|dev
suffix:semicolon
id|SCmd.lun
op_assign
id|lun
suffix:semicolon
id|SCmd.request.dev
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* Mark not busy */
id|SCmd.use_sg
op_assign
l_int|0
suffix:semicolon
id|SCmd.transfersize
op_assign
l_int|0
suffix:semicolon
id|SCmd.underflow
op_assign
l_int|0
suffix:semicolon
id|scsi_do_cmd
(paren
op_amp
id|SCmd
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|256
comma
id|scan_scsis_done
comma
id|SCSI_TIMEOUT
op_plus
l_int|400
comma
l_int|3
)paren
suffix:semicolon
r_while
c_loop
(paren
id|SCmd.request.dev
op_ne
l_int|0xfffe
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCmd.result
)paren
(brace
r_if
c_cond
(paren
(paren
id|driver_byte
c_func
(paren
id|SCmd.result
)paren
op_amp
id|DRIVER_SENSE
)paren
op_logical_and
(paren
(paren
id|SCmd.sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x70
)paren
op_rshift
l_int|4
)paren
op_eq
l_int|7
)paren
(brace
r_if
c_cond
(paren
id|SCmd.sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xe0
)paren
r_continue
suffix:semicolon
multiline_comment|/* No devices here... */
r_if
c_cond
(paren
(paren
(paren
id|SCmd.sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_ne
id|NOT_READY
)paren
op_logical_and
(paren
(paren
id|SCmd.sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_ne
id|UNIT_ATTENTION
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
)brace
r_else
r_break
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Build an INQUIRY command block.  &n;&t;&t; */
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|255
suffix:semicolon
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|SCmd.request.dev
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* Mark not busy */
id|scsi_do_cmd
(paren
op_amp
id|SCmd
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|256
comma
id|scan_scsis_done
comma
id|SCSI_TIMEOUT
comma
l_int|3
)paren
suffix:semicolon
r_while
c_loop
(paren
id|SCmd.request.dev
op_ne
l_int|0xfffe
)paren
suffix:semicolon
id|the_result
op_assign
id|SCmd.result
suffix:semicolon
r_if
c_cond
(paren
id|the_result
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* skip other luns on this device */
r_if
c_cond
(paren
op_logical_neg
id|the_result
)paren
(brace
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|removable
op_assign
(paren
l_int|0x80
op_amp
id|scsi_result
(braket
l_int|1
)braket
)paren
op_rshift
l_int|7
suffix:semicolon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|lockable
op_assign
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|removable
suffix:semicolon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|changed
op_assign
l_int|0
suffix:semicolon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|access_count
op_assign
l_int|0
suffix:semicolon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|busy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n; *&t;Currently, all sequential devices are assumed to be tapes,&n; *&t;all random devices disk, with the appropriate read only &n; *&t;flags set for ROM / WORM treated as RO.&n; */
r_switch
c_cond
(paren
id|type
op_assign
id|scsi_result
(braket
l_int|0
)braket
)paren
(brace
r_case
id|TYPE_TAPE
suffix:colon
r_case
id|TYPE_DISK
suffix:colon
r_case
id|TYPE_MOD
suffix:colon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|writeable
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_WORM
suffix:colon
r_case
id|TYPE_ROM
suffix:colon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|writeable
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|type
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|random
op_assign
(paren
id|type
op_eq
id|TYPE_TAPE
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|type
op_assign
id|type
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ne
op_minus
l_int|1
)paren
(brace
id|print_inquiry
c_func
(paren
id|scsi_result
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|TYPE_TAPE
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Detected scsi tape st%d at scsi%d, id %d, lun %d&bslash;n&quot;
comma
id|MAX_ST
comma
id|host_nr
comma
id|dev
comma
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NR_ST
op_ne
op_minus
l_int|1
)paren
(brace
op_increment
id|MAX_ST
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TYPE_ROM
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Detected scsi CD-ROM sr%d at scsi%d, id %d, lun %d&bslash;n&quot;
comma
id|MAX_SR
comma
id|host_nr
comma
id|dev
comma
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NR_SR
op_ne
op_minus
l_int|1
)paren
(brace
op_increment
id|MAX_SR
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TYPE_DISK
suffix:colon
r_case
id|TYPE_MOD
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Detected scsi disk sd%d at scsi%d, id %d, lun %d&bslash;n&quot;
comma
id|MAX_SD
comma
id|host_nr
comma
id|dev
comma
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NR_SD
op_ne
op_minus
l_int|1
)paren
(brace
op_increment
id|MAX_SD
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|scsi_level
op_assign
id|scsi_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
suffix:semicolon
r_if
c_cond
(paren
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|scsi_level
op_ge
l_int|2
op_logical_or
(paren
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|scsi_level
op_eq
l_int|1
op_logical_and
(paren
id|scsi_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
)paren
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|scsi_level
op_increment
suffix:semicolon
multiline_comment|/* These devices need this &quot;key&quot; to unlock the device&n;&t;&t;&t;   so we can use it */
r_if
c_cond
(paren
id|strncmp
c_func
(paren
l_string|&quot;INSITE&quot;
comma
op_amp
id|scsi_result
(braket
l_int|8
)braket
comma
l_int|6
)paren
op_eq
l_int|0
op_logical_and
(paren
id|strncmp
c_func
(paren
l_string|&quot;Floptical   F*8I&quot;
comma
op_amp
id|scsi_result
(braket
l_int|16
)braket
comma
l_int|16
)paren
op_eq
l_int|0
op_logical_or
id|strncmp
c_func
(paren
l_string|&quot;I325VM&quot;
comma
op_amp
id|scsi_result
(braket
l_int|16
)braket
comma
l_int|6
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unlocked floptical drive.&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|lockable
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|MODE_SENSE
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0x2e
suffix:semicolon
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|0x2a
suffix:semicolon
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|SCmd.request.dev
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* Mark not busy */
id|scsi_do_cmd
(paren
op_amp
id|SCmd
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|0x2a
comma
id|scan_scsis_done
comma
id|SCSI_TIMEOUT
comma
l_int|3
)paren
suffix:semicolon
r_while
c_loop
(paren
id|SCmd.request.dev
op_ne
l_int|0xfffe
)paren
suffix:semicolon
)brace
suffix:semicolon
op_increment
id|NR_SCSI_DEVICES
suffix:semicolon
multiline_comment|/* Some scsi devices cannot be polled for lun != 0&n;&t;&t;&t;   due to firmware bugs */
r_if
c_cond
(paren
id|blacklisted
c_func
(paren
id|scsi_result
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Some scsi-1 peripherals do not handle lun != 0.&n;&t;&t;&t;   I am assuming that scsi-2 peripherals do better */
r_if
c_cond
(paren
(paren
id|scsi_result
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|1
op_logical_and
(paren
id|scsi_result
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* if result == DID_OK ends */
)brace
multiline_comment|/* for lun ends */
id|host_queue
(braket
id|host_nr
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* No longer needed here */
)brace
multiline_comment|/* if present */
r_for
c_loop
(paren
id|host_nr
op_assign
l_int|0
suffix:semicolon
id|host_nr
OL
id|max_scsi_hosts
suffix:semicolon
op_increment
id|host_nr
)paren
r_if
c_cond
(paren
id|scsi_hosts
(braket
id|host_nr
)braket
dot
id|present
)paren
r_if
c_cond
(paren
id|host_queue
(braket
id|host_nr
)braket
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;host_queue not cleared&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;scsi : detected &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NR_SD
op_ne
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%d SCSI disk%s &quot;
comma
id|MAX_SD
comma
(paren
id|MAX_SD
op_ne
l_int|1
)paren
ques
c_cond
l_string|&quot;s&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|NR_ST
op_ne
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%d tape%s &quot;
comma
id|MAX_ST
comma
(paren
id|MAX_ST
op_ne
l_int|1
)paren
ques
c_cond
l_string|&quot;s&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|NR_SR
op_ne
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%d CD-ROM drive%s &quot;
comma
id|MAX_SR
comma
(paren
id|MAX_SR
op_ne
l_int|1
)paren
ques
c_cond
l_string|&quot;s&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;total.&bslash;n&quot;
)paren
suffix:semicolon
id|in_scan
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* scan_scsis  ends */
multiline_comment|/*&n; *&t;Flag bits for the internal_timeout array &n; */
DECL|macro|NORMAL_TIMEOUT
mdefine_line|#define NORMAL_TIMEOUT 0
DECL|macro|IN_ABORT
mdefine_line|#define IN_ABORT 1
DECL|macro|IN_RESET
mdefine_line|#define IN_RESET 2
multiline_comment|/*&n;&t;This is our time out function, called when the timer expires for a &n;&t;given host adapter.  It will attempt to abort the currently executing &n;&t;command, that failing perform a kernel panic.&n;*/
DECL|function|scsi_times_out
r_static
r_void
id|scsi_times_out
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_switch
c_cond
(paren
id|SCpnt-&gt;internal_timeout
op_amp
(paren
id|IN_ABORT
op_or
id|IN_RESET
)paren
)paren
(brace
r_case
id|NORMAL_TIMEOUT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|in_scan
)paren
id|printk
c_func
(paren
l_string|&quot;SCSI host %d timed out - aborting command&bslash;n&quot;
comma
id|SCpnt-&gt;host
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_abort
(paren
id|SCpnt
comma
id|DID_TIME_OUT
)paren
)paren
r_return
suffix:semicolon
r_case
id|IN_ABORT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SCSI host %d abort() timed out - reseting&bslash;n&quot;
comma
id|SCpnt-&gt;host
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_reset
(paren
id|SCpnt
)paren
)paren
r_return
suffix:semicolon
r_case
id|IN_RESET
suffix:colon
r_case
(paren
id|IN_ABORT
op_or
id|IN_RESET
)paren
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unable to reset scsi host %d&bslash;n&quot;
comma
id|SCpnt-&gt;host
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
r_default
suffix:colon
id|INTERNAL_ERROR
suffix:semicolon
)brace
)brace
multiline_comment|/* This function takes a quick look at a request, and decides if it&n;can be queued now, or if there would be a stall while waiting for&n;something else to finish.  This routine assumes that interrupts are&n;turned off when entering the routine.  It is the responsibility&n;of the calling code to ensure that this is the case. */
DECL|function|request_queueable
id|Scsi_Cmnd
op_star
id|request_queueable
(paren
r_struct
id|request
op_star
id|req
comma
r_int
id|index
)paren
(brace
r_int
id|host
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|index
OL
l_int|0
)paren
op_logical_or
(paren
id|index
OG
id|NR_SCSI_DEVICES
)paren
)paren
id|panic
(paren
l_string|&quot;Index number in allocate_device() is out of range.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
op_logical_and
id|req-&gt;dev
op_le
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Invalid device in allocate_device&quot;
)paren
suffix:semicolon
id|host
op_assign
id|scsi_devices
(braket
id|index
)braket
dot
id|host_no
suffix:semicolon
id|SCpnt
op_assign
id|host_queue
(braket
id|host
)braket
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;target
op_eq
id|scsi_devices
(braket
id|index
)braket
dot
id|id
op_logical_and
id|SCpnt-&gt;lun
op_eq
id|scsi_devices
(braket
id|index
)braket
dot
id|lun
)paren
r_if
c_cond
(paren
id|SCpnt-&gt;request.dev
OL
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|SCpnt
op_assign
id|SCpnt-&gt;next
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SCpnt
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|scsi_hosts
(braket
id|host
)braket
dot
id|can_queue
op_logical_and
id|host_busy
(braket
id|host
)braket
op_ge
id|scsi_hosts
(braket
id|host
)braket
dot
id|can_queue
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|SCpnt-&gt;request
comma
id|req
comma
r_sizeof
(paren
r_struct
id|request
)paren
)paren
suffix:semicolon
id|req-&gt;dev
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|SCpnt-&gt;request.dev
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* Busy, but no request */
id|SCpnt-&gt;request.waiting
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* And no one is waiting for the device either */
)brace
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the scatter-gather flag */
id|SCpnt-&gt;transfersize
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
r_return
id|SCpnt
suffix:semicolon
)brace
multiline_comment|/* This function returns a structure pointer that will be valid for&n;the device.  The wait parameter tells us whether we should wait for&n;the unit to become free or not.  We are also able to tell this routine&n;not to return a descriptor if the host is unable to accept any more&n;commands for the time being.  We need to keep in mind that there is no&n;guarantee that the host remain not busy.  Keep in mind the&n;request_queueable function also knows the internal allocation scheme&n;of the packets for each device */
DECL|function|allocate_device
id|Scsi_Cmnd
op_star
id|allocate_device
(paren
r_struct
id|request
op_star
op_star
id|reqp
comma
r_int
id|index
comma
r_int
id|wait
)paren
(brace
r_int
id|host
comma
id|dev
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|request
op_star
id|req
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCwait
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|index
OL
l_int|0
)paren
op_logical_or
(paren
id|index
OG
id|NR_SCSI_DEVICES
)paren
)paren
id|panic
(paren
l_string|&quot;Index number in allocate_device() is out of range.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reqp
)paren
id|req
op_assign
op_star
id|reqp
suffix:semicolon
multiline_comment|/* See if this request has already been queued by an interrupt routine */
r_if
c_cond
(paren
id|req
op_logical_and
(paren
id|dev
op_assign
id|req-&gt;dev
)paren
op_le
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
id|host
op_assign
id|scsi_devices
(braket
id|index
)braket
dot
id|host_no
suffix:semicolon
r_while
c_loop
(paren
l_int|1
op_eq
l_int|1
)paren
(brace
id|SCpnt
op_assign
id|host_queue
(braket
id|host
)braket
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;target
op_eq
id|scsi_devices
(braket
id|index
)braket
dot
id|id
op_logical_and
id|SCpnt-&gt;lun
op_eq
id|scsi_devices
(braket
id|index
)braket
dot
id|lun
)paren
(brace
id|SCwait
op_assign
id|SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;request.dev
OL
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
suffix:semicolon
)brace
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* See if this request has already been queued by an interrupt routine */
r_if
c_cond
(paren
id|req
op_logical_and
(paren
(paren
id|req-&gt;dev
OL
l_int|0
)paren
op_logical_or
(paren
id|req-&gt;dev
op_ne
id|dev
)paren
)paren
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SCpnt
op_logical_or
id|SCpnt-&gt;request.dev
op_ge
l_int|0
)paren
multiline_comment|/* Might have changed */
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|wait
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|SCwait
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attempt to allocate device index %d, target %d, lun %d&bslash;n&quot;
comma
id|index
comma
id|scsi_devices
(braket
id|index
)braket
dot
id|id
comma
id|scsi_devices
(braket
id|index
)braket
dot
id|lun
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;No device found in allocate_device&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
id|SCSI_SLEEP
c_func
(paren
op_amp
id|scsi_devices
(braket
id|SCwait-&gt;index
)braket
dot
id|device_wait
comma
(paren
id|SCwait-&gt;request.dev
OG
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|req
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|SCpnt-&gt;request
comma
id|req
comma
r_sizeof
(paren
r_struct
id|request
)paren
)paren
suffix:semicolon
id|req-&gt;dev
op_assign
op_minus
l_int|1
suffix:semicolon
op_star
id|reqp
op_assign
id|req-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|SCpnt-&gt;request.dev
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* Busy */
id|SCpnt-&gt;request.waiting
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* And no one is waiting for this to complete */
)brace
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset the scatter-gather flag */
id|SCpnt-&gt;transfersize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No default transfer size */
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do not flag underflow conditions */
r_return
id|SCpnt
suffix:semicolon
)brace
multiline_comment|/*&n;&t;This is inline because we have stack problemes if we recurse to deeply.&n;*/
DECL|function|internal_cmnd
r_inline
r_void
id|internal_cmnd
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|temp
comma
id|host
suffix:semicolon
macro_line|#ifdef DEBUG_DELAY&t;
r_int
id|clock
suffix:semicolon
macro_line|#endif
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
r_if
c_cond
(paren
(paren
id|host
OL
l_int|0
)paren
op_logical_or
(paren
id|host
OG
id|max_scsi_hosts
)paren
)paren
id|panic
(paren
l_string|&quot;Host number in internal_cmnd() is out of range.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;We will wait MIN_RESET_DELAY clock ticks after the last reset so &n;&t;we can avoid the drive not being ready.&n;*/
id|temp
op_assign
id|last_reset
(braket
id|host
)braket
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|temp
)paren
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|SCpnt-&gt;timeout_per_command
)paren
suffix:semicolon
multiline_comment|/*&n;&t;We will use a queued command if possible, otherwise we will emulate the&n;&t;queing and calling of completion function ourselves. &n;*/
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;internal_cmnd (host = %d, target = %d, command = %08x, buffer =  %08x, &bslash;n&quot;
l_string|&quot;bufflen = %d, done = %08x)&bslash;n&quot;
comma
id|SCpnt-&gt;host
comma
id|SCpnt-&gt;target
comma
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;buffer
comma
id|SCpnt-&gt;bufflen
comma
id|SCpnt-&gt;done
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|scsi_hosts
(braket
id|host
)braket
dot
id|can_queue
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;queuecommand : routine at %08x&bslash;n&quot;
comma
id|scsi_hosts
(braket
id|host
)braket
dot
id|queuecommand
)paren
suffix:semicolon
macro_line|#endif
id|scsi_hosts
(braket
id|host
)braket
dot
id|queuecommand
(paren
id|SCpnt
comma
id|scsi_done
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;command() :  routine at %08x&bslash;n&quot;
comma
id|scsi_hosts
(braket
id|host
)braket
dot
id|command
)paren
suffix:semicolon
macro_line|#endif
id|temp
op_assign
id|scsi_hosts
(braket
id|host
)braket
dot
id|command
(paren
id|SCpnt
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|temp
suffix:semicolon
macro_line|#ifdef DEBUG_DELAY
id|clock
op_assign
id|jiffies
op_plus
l_int|400
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|clock
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;done(host = %d, result = %04x) : routine at %08x&bslash;n&quot;
comma
id|host
comma
id|temp
comma
id|done
)paren
suffix:semicolon
macro_line|#endif
id|scsi_done
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;leaving internal_cmnd()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|scsi_request_sense
r_static
r_void
id|scsi_request_sense
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|old_use_sg
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|SCpnt-&gt;flags
op_or_assign
id|WAS_SENSE
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|SENSE_TIMEOUT
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|generic_sense
comma
r_sizeof
(paren
id|generic_sense
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|1
)braket
op_assign
id|SCpnt-&gt;lun
op_lshift
l_int|5
suffix:semicolon
id|SCpnt-&gt;cmnd
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
op_amp
id|SCpnt-&gt;sense_buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
r_sizeof
(paren
id|SCpnt-&gt;sense_buffer
)paren
suffix:semicolon
id|old_use_sg
op_assign
id|SCpnt-&gt;use_sg
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|internal_cmnd
(paren
id|SCpnt
)paren
suffix:semicolon
id|SCpnt-&gt;use_sg
op_assign
id|old_use_sg
suffix:semicolon
)brace
multiline_comment|/*&n;&t;scsi_do_cmd sends all the commands out to the low-level driver.  It &n;&t;handles the specifics required for each low level driver - ie queued &n;&t;or non queud.  It also prevents conflicts when different high level &n;&t;drivers go for the same host at the same time.&n;*/
DECL|function|scsi_do_cmd
r_void
id|scsi_do_cmd
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buffer
comma
r_int
id|bufflen
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
comma
r_int
id|timeout
comma
r_int
id|retries
)paren
(brace
r_int
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
macro_line|#ifdef DEBUG
(brace
r_int
id|i
suffix:semicolon
r_int
id|target
op_assign
id|SCpnt-&gt;target
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi_do_cmd (host = %d, target = %d, buffer =%08x, &quot;
l_string|&quot;bufflen = %d, done = %08x, timeout = %d, retries = %d)&bslash;n&quot;
l_string|&quot;command : &quot;
comma
id|host
comma
id|target
comma
id|buffer
comma
id|bufflen
comma
id|done
comma
id|timeout
comma
id|retries
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
op_increment
id|i
)paren
id|printk
(paren
l_string|&quot;%02x  &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|cmnd
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|host
OL
l_int|0
)paren
op_logical_or
(paren
id|host
op_ge
id|max_scsi_hosts
)paren
op_logical_or
op_logical_neg
id|scsi_hosts
(braket
id|host
)braket
dot
id|present
)paren
(brace
id|printk
(paren
l_string|&quot;Invalid or not present host number. %d&bslash;n&quot;
comma
id|host
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;We must prevent reentrancy to the lowlevel host driver.  This prevents &n;&t;it - we enter a loop until the host we want to talk to is not busy.   &n;&t;Race conditions are prevented, as interrupts are disabled inbetween the&n;&t;time we check for the host being not busy, and the time we mark it busy&n;&t;ourselves.&n;*/
r_while
c_loop
(paren
l_int|1
op_eq
l_int|1
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scsi_hosts
(braket
id|host
)braket
dot
id|can_queue
op_logical_and
id|host_busy
(braket
id|host
)braket
op_ge
id|scsi_hosts
(braket
id|host
)braket
dot
id|can_queue
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|SCSI_SLEEP
c_func
(paren
op_amp
id|host_wait
(braket
id|host
)braket
comma
(paren
id|host_busy
(braket
id|host
)braket
op_ge
id|scsi_hosts
(braket
id|host
)braket
dot
id|can_queue
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|host_busy
(braket
id|host
)braket
op_increment
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;Our own function scsi_done (which marks the host as not busy, disables &n;&t;the timeout counter, etc) will be called by us or by the &n;&t;scsi_hosts[host].queuecommand() function needs to also call&n;&t;the completion function for the high level driver.&n;&n;*/
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
(paren
r_void
op_star
)paren
id|cmnd
comma
l_int|10
)paren
suffix:semicolon
macro_line|#if 0
id|SCpnt-&gt;host
op_assign
id|host
suffix:semicolon
id|SCpnt-&gt;target
op_assign
id|target
suffix:semicolon
id|SCpnt-&gt;lun
op_assign
(paren
id|SCpnt-&gt;data_cmnd
(braket
l_int|1
)braket
op_rshift
l_int|5
)paren
suffix:semicolon
macro_line|#endif
id|SCpnt-&gt;bufflen
op_assign
id|bufflen
suffix:semicolon
id|SCpnt-&gt;buffer
op_assign
id|buffer
suffix:semicolon
id|SCpnt-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;retries
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;allowed
op_assign
id|retries
suffix:semicolon
id|SCpnt-&gt;done
op_assign
id|done
suffix:semicolon
id|SCpnt-&gt;timeout_per_command
op_assign
id|timeout
suffix:semicolon
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|cmnd
comma
l_int|10
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|bufflen
suffix:semicolon
multiline_comment|/* Start the timer ticking.  */
id|SCpnt-&gt;internal_timeout
op_assign
l_int|0
suffix:semicolon
id|internal_cmnd
(paren
id|SCpnt
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
(paren
l_string|&quot;Leaving scsi_do_cmd()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t;The scsi_done() function disables the timeout timer for the scsi host, &n;&t;marks the host as not busy, and calls the user specified completion &n;&t;function for that host&squot;s current command.&n;*/
DECL|function|reset
r_static
r_void
id|reset
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;reset(%d)&bslash;n&quot;
comma
id|SCpnt-&gt;host
)paren
suffix:semicolon
macro_line|#endif
id|SCpnt-&gt;flags
op_or_assign
(paren
id|WAS_RESET
op_or
id|IS_RESETTING
)paren
suffix:semicolon
id|scsi_reset
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;performing request sense&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|scsi_request_sense
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
DECL|function|check_sense
r_static
r_int
id|check_sense
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x70
)paren
op_rshift
l_int|4
)paren
op_eq
l_int|7
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xe0
)paren
r_return
id|SUGGEST_ABORT
suffix:semicolon
r_switch
c_cond
(paren
id|SCpnt-&gt;sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
(brace
r_case
id|NO_SENSE
suffix:colon
r_case
id|RECOVERED_ERROR
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|ABORTED_COMMAND
suffix:colon
r_return
id|SUGGEST_RETRY
suffix:semicolon
r_case
id|NOT_READY
suffix:colon
r_case
id|UNIT_ATTENTION
suffix:colon
r_return
id|SUGGEST_ABORT
suffix:semicolon
multiline_comment|/* these three are not supported */
r_case
id|COPY_ABORTED
suffix:colon
r_case
id|VOLUME_OVERFLOW
suffix:colon
r_case
id|MISCOMPARE
suffix:colon
r_case
id|MEDIUM_ERROR
suffix:colon
r_return
id|SUGGEST_REMAP
suffix:semicolon
r_case
id|BLANK_CHECK
suffix:colon
r_case
id|DATA_PROTECT
suffix:colon
r_case
id|HARDWARE_ERROR
suffix:colon
r_case
id|ILLEGAL_REQUEST
suffix:colon
r_default
suffix:colon
r_return
id|SUGGEST_ABORT
suffix:semicolon
)brace
)brace
r_else
r_return
id|SUGGEST_RETRY
suffix:semicolon
)brace
multiline_comment|/* This function is the mid-level interrupt routine, which decides how&n; *  to handle error conditions.  Each invocation of this function must&n; *  do one and *only* one of the following:&n; *&n; *  (1) Call last_cmnd[host].done.  This is done for fatal errors and&n; *      normal completion, and indicates that the handling for this&n; *      request is complete.&n; *  (2) Call internal_cmnd to requeue the command.  This will result in&n; *      scsi_done being called again when the retry is complete.&n; *  (3) Call scsi_request_sense.  This asks the host adapter/drive for&n; *      more information about the error condition.  When the information&n; *      is available, scsi_done will be called again.&n; *  (4) Call reset().  This is sort of a last resort, and the idea is that&n; *      this may kick things loose and get the drive working again.  reset()&n; *      automatically calls scsi_request_sense, and thus scsi_done will be&n; *      called again once the reset is complete.&n; *&n; *      If none of the above actions are taken, the drive in question&n; * will hang. If more than one of the above actions are taken by&n; * scsi_done, then unpredictable behavior will result.&n; */
DECL|function|scsi_done
r_static
r_void
id|scsi_done
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_int
m_exit
op_assign
l_int|0
suffix:semicolon
r_int
id|checked
suffix:semicolon
r_int
id|oldto
suffix:semicolon
r_int
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
r_int
id|result
op_assign
id|SCpnt-&gt;result
suffix:semicolon
id|oldto
op_assign
id|update_timeout
c_func
(paren
id|SCpnt
comma
l_int|0
)paren
suffix:semicolon
DECL|macro|FINISHED
mdefine_line|#define FINISHED 0
DECL|macro|MAYREDO
mdefine_line|#define MAYREDO  1
DECL|macro|REDO
mdefine_line|#define REDO&t; 3
DECL|macro|PENDING
mdefine_line|#define PENDING  4
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;In scsi_done(host = %d, result = %06x)&bslash;n&quot;
comma
id|host
comma
id|result
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|host
OG
id|max_scsi_hosts
op_logical_or
id|host
OL
l_int|0
)paren
(brace
id|update_timeout
c_func
(paren
id|SCpnt
comma
l_int|0
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;scsi_done() called with invalid host number.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|host_byte
c_func
(paren
id|result
)paren
)paren
(brace
r_case
id|DID_OK
suffix:colon
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|IS_RESETTING
)paren
(brace
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|IS_RESETTING
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status_byte
c_func
(paren
id|result
)paren
op_logical_and
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_SENSE
)paren
)paren
multiline_comment|/* Failed to obtain sense information */
(brace
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|WAS_SENSE
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|SENSE_TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_RESET
)paren
)paren
(brace
id|reset
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
m_exit
op_assign
(paren
id|DRIVER_HARD
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
id|status
op_assign
id|FINISHED
suffix:semicolon
)brace
)brace
r_else
r_switch
c_cond
(paren
id|msg_byte
c_func
(paren
id|result
)paren
)paren
(brace
r_case
id|COMMAND_COMPLETE
suffix:colon
r_switch
c_cond
(paren
id|status_byte
c_func
(paren
id|result
)paren
)paren
(brace
r_case
id|GOOD
suffix:colon
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_SENSE
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
(paren
l_string|&quot;In scsi_done, GOOD status, COMMAND COMPLETE, parsing sense information.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SCpnt-&gt;flags
op_and_assign
op_complement
id|WAS_SENSE
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|SENSE_TIMEOUT
suffix:semicolon
r_switch
c_cond
(paren
id|checked
op_assign
id|check_sense
c_func
(paren
id|SCpnt
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;NO SENSE.  status = REDO&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_REMAP
suffix:colon
r_case
id|SUGGEST_RETRY
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SENSE SUGGEST REMAP or SUGGEST RETRY - status = MAYREDO&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|status
op_assign
id|MAYREDO
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_RETRY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_ABORT
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SENSE SUGGEST ABORT - status = FINISHED&quot;
)paren
suffix:semicolon
macro_line|#endif
id|status
op_assign
id|FINISHED
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
op_or
id|SUGGEST_ABORT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Internal error %s %s &bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;COMMAND COMPLETE message returned, status = FINISHED. &bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
m_exit
op_assign
id|DRIVER_OK
suffix:semicolon
id|status
op_assign
id|FINISHED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CHECK_CONDITION
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;CHECK CONDITION message returned, performing request sense.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|scsi_request_sense
(paren
id|SCpnt
)paren
suffix:semicolon
id|status
op_assign
id|PENDING
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CONDITION_GOOD
suffix:colon
r_case
id|INTERMEDIATE_GOOD
suffix:colon
r_case
id|INTERMEDIATE_C_GOOD
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;CONDITION GOOD, INTERMEDIATE GOOD, or INTERMEDIATE CONDITION GOOD recieved and ignored. &bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|BUSY
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;BUSY message returned, performing REDO&quot;
)paren
suffix:semicolon
macro_line|#endif
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESERVATION_CONFLICT
suffix:colon
id|reset
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#if 0
m_exit
op_assign
id|DRIVER_SOFT
op_or
id|SUGGEST_ABORT
suffix:semicolon
id|status
op_assign
id|MAYREDO
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Internal error %s %s &bslash;n&quot;
l_string|&quot;status byte = %d &bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|status_byte
c_func
(paren
id|result
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scsi: unsupported message byte %d recieved&bslash;n&quot;
comma
id|msg_byte
c_func
(paren
id|result
)paren
)paren
suffix:semicolon
id|panic
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DID_TIME_OUT
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Host returned DID_TIME_OUT - &quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_TIMEDOUT
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Aborting&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif&t;
m_exit
op_assign
(paren
id|DRIVER_TIMEOUT
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
(paren
l_string|&quot;Retrying.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SCpnt-&gt;flags
op_or_assign
id|WAS_TIMEDOUT
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DID_BUS_BUSY
suffix:colon
r_case
id|DID_PARITY
suffix:colon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_NO_CONNECT
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Couldn&squot;t connect.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
m_exit
op_assign
(paren
id|DRIVER_HARD
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_ERROR
suffix:colon
id|status
op_assign
id|MAYREDO
suffix:semicolon
m_exit
op_assign
(paren
id|DRIVER_HARD
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_BAD_TARGET
suffix:colon
r_case
id|DID_ABORT
suffix:colon
m_exit
op_assign
(paren
id|DRIVER_INVALID
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_RESET
suffix:colon
r_if
c_cond
(paren
id|msg_byte
c_func
(paren
id|result
)paren
op_eq
id|GOOD
op_logical_and
id|status_byte
c_func
(paren
id|result
)paren
op_eq
id|CHECK_CONDITION
)paren
(brace
id|scsi_request_sense
(paren
id|SCpnt
)paren
suffix:semicolon
id|status
op_assign
id|PENDING
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
m_exit
op_assign
id|SUGGEST_RETRY
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
m_exit
op_assign
(paren
id|DRIVER_ERROR
op_or
id|SUGGEST_DIE
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|FINISHED
suffix:colon
r_case
id|PENDING
suffix:colon
r_break
suffix:semicolon
r_case
id|MAYREDO
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;In MAYREDO, allowing %d retries, have %d&bslash;n&quot;
comma
id|SCpnt-&gt;allowed
comma
id|SCpnt-&gt;retries
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
op_increment
id|SCpnt-&gt;retries
)paren
OL
id|SCpnt-&gt;allowed
)paren
(brace
r_if
c_cond
(paren
(paren
id|SCpnt-&gt;retries
op_ge
(paren
id|SCpnt-&gt;allowed
op_rshift
l_int|1
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_RESET
)paren
)paren
(brace
id|reset
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
id|FINISHED
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* fall through to REDO */
r_case
id|REDO
suffix:colon
r_if
c_cond
(paren
id|SCpnt-&gt;flags
op_amp
id|WAS_SENSE
)paren
id|scsi_request_sense
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
r_else
(brace
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|SCpnt-&gt;cmnd
comma
(paren
r_void
op_star
)paren
id|SCpnt-&gt;data_cmnd
comma
r_sizeof
(paren
id|SCpnt-&gt;data_cmnd
)paren
)paren
suffix:semicolon
id|SCpnt-&gt;request_buffer
op_assign
id|SCpnt-&gt;buffer
suffix:semicolon
id|SCpnt-&gt;request_bufflen
op_assign
id|SCpnt-&gt;bufflen
suffix:semicolon
id|internal_cmnd
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|INTERNAL_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_eq
id|FINISHED
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Calling done function - at address %08x&bslash;n&quot;
comma
id|SCpnt-&gt;done
)paren
suffix:semicolon
macro_line|#endif
id|host_busy
(braket
id|host
)braket
op_decrement
suffix:semicolon
multiline_comment|/* Indicate that we are free */
id|wake_up
c_func
(paren
op_amp
id|host_wait
(braket
id|host
)braket
)paren
suffix:semicolon
id|SCpnt-&gt;result
op_assign
id|result
op_or
(paren
(paren
m_exit
op_amp
l_int|0xff
)paren
op_lshift
l_int|24
)paren
suffix:semicolon
id|SCpnt-&gt;done
(paren
id|SCpnt
)paren
suffix:semicolon
)brace
DECL|macro|FINISHED
macro_line|#undef FINISHED
DECL|macro|REDO
macro_line|#undef REDO
DECL|macro|MAYREDO
macro_line|#undef MAYREDO
DECL|macro|PENDING
macro_line|#undef PENDING
)brace
multiline_comment|/*&n;&t;The scsi_abort function interfaces with the abort() function of the host&n;&t;we are aborting, and causes the current command to not complete.  The &n;&t;caller should deal with any error messages or status returned on the &n;&t;next call.&n;&t;&n;&t;This will not be called rentrantly for a given host.&n;*/
multiline_comment|/*&n;&t;Since we&squot;re nice guys and specified that abort() and reset()&n;&t;can be non-reentrant.  The internal_timeout flags are used for&n;&t;this.&n;*/
DECL|function|scsi_abort
r_int
id|scsi_abort
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|why
)paren
(brace
r_int
id|temp
comma
id|oldto
suffix:semicolon
r_int
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;internal_timeout
op_amp
id|IN_ABORT
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt-&gt;internal_timeout
op_amp
id|IN_ABORT
)paren
suffix:semicolon
)brace
r_else
(brace
id|SCpnt-&gt;internal_timeout
op_or_assign
id|IN_ABORT
suffix:semicolon
id|oldto
op_assign
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|ABORT_TIMEOUT
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host_busy
(braket
id|host
)braket
op_logical_or
op_logical_neg
id|scsi_hosts
(braket
id|host
)braket
dot
m_abort
(paren
id|SCpnt
comma
id|why
)paren
)paren
id|temp
op_assign
l_int|0
suffix:semicolon
r_else
id|temp
op_assign
l_int|1
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_ABORT
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
id|temp
suffix:semicolon
)brace
)brace
)brace
DECL|function|scsi_reset
r_int
id|scsi_reset
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_int
id|temp
comma
id|oldto
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt1
suffix:semicolon
r_int
id|host
op_assign
id|SCpnt-&gt;host
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Danger Will Robinson! - SCSI bus for host %d is being reset.&bslash;n&quot;
comma
id|host
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SCpnt-&gt;internal_timeout
op_amp
id|IN_RESET
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt-&gt;internal_timeout
op_amp
id|IN_RESET
)paren
suffix:semicolon
)brace
r_else
(brace
id|SCpnt-&gt;internal_timeout
op_or_assign
id|IN_RESET
suffix:semicolon
id|oldto
op_assign
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|RESET_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host_busy
(braket
id|host
)braket
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|SCpnt1
op_assign
id|host_queue
(braket
id|host
)braket
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt1
)paren
(brace
r_if
c_cond
(paren
(paren
id|SCpnt1-&gt;request.dev
OG
l_int|0
)paren
op_logical_and
op_logical_neg
(paren
id|SCpnt1-&gt;flags
op_amp
id|IS_RESETTING
)paren
op_logical_and
op_logical_neg
(paren
id|SCpnt1-&gt;internal_timeout
op_amp
id|IN_ABORT
)paren
)paren
id|scsi_abort
c_func
(paren
id|SCpnt1
comma
id|DID_RESET
)paren
suffix:semicolon
id|SCpnt1
op_assign
id|SCpnt1-&gt;next
suffix:semicolon
)brace
suffix:semicolon
id|temp
op_assign
id|scsi_hosts
(braket
id|host
)braket
dot
id|reset
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|host_busy
(braket
id|host
)braket
op_increment
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|temp
op_assign
id|scsi_hosts
(braket
id|host
)braket
dot
id|reset
c_func
(paren
)paren
suffix:semicolon
id|last_reset
(braket
id|host
)braket
op_assign
id|jiffies
suffix:semicolon
id|host_busy
(braket
id|host
)braket
op_decrement
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|SCpnt-&gt;internal_timeout
op_and_assign
op_complement
id|IN_RESET
suffix:semicolon
id|update_timeout
c_func
(paren
id|SCpnt
comma
id|oldto
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
id|temp
suffix:semicolon
)brace
)brace
)brace
DECL|function|scsi_main_timeout
r_static
r_void
id|scsi_main_timeout
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t;&t;We must not enter update_timeout with a timeout condition still pending.&n;&t;*/
r_int
id|timed_out
comma
id|host
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
r_do
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;Find all timers such that they have 0 or negative (shouldn&squot;t happen)&n;&t;&t;time remaining on them.&n;&t;*/
id|timed_out
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|host
op_assign
l_int|0
suffix:semicolon
id|host
OL
id|max_scsi_hosts
suffix:semicolon
id|host
op_increment
)paren
(brace
id|SCpnt
op_assign
id|host_queue
(braket
id|host
)braket
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;timeout
OG
l_int|0
op_logical_and
id|SCpnt-&gt;timeout
op_le
id|time_elapsed
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|SCpnt-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|scsi_times_out
c_func
(paren
id|SCpnt
)paren
suffix:semicolon
op_increment
id|timed_out
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|SCpnt
op_assign
id|SCpnt-&gt;next
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
id|update_timeout
c_func
(paren
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|timed_out
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;These are used to keep track of things. &n;*/
DECL|variable|time_start
DECL|variable|time_elapsed
r_static
r_int
id|time_start
comma
id|time_elapsed
suffix:semicolon
multiline_comment|/*&n;&t;The strategy is to cause the timer code to call scsi_times_out()&n;&t;when the soonest timeout is pending.  &n;&t;The arguments are used when we are queueing a new command, because&n;&t;we do not want to subtract the time used from this time, but when we&n;&t;set the timer, we want to take this value into account.&n;*/
DECL|function|update_timeout
r_static
r_int
id|update_timeout
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCset
comma
r_int
id|timeout
)paren
(brace
r_int
r_int
id|least
comma
id|used
comma
id|host
suffix:semicolon
r_int
r_int
id|oldto
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
op_assign
l_int|NULL
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;Figure out how much time has passed since the last time the timeouts &n;   &t;were updated &n;*/
id|used
op_assign
(paren
id|time_start
)paren
ques
c_cond
(paren
id|jiffies
op_minus
id|time_start
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;Find out what is due to timeout soonest, and adjust all timeouts for&n;&t;the amount of time that has passed since the last time we called &n;&t;update_timeout. &n;*/
id|oldto
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|SCset
)paren
(brace
id|oldto
op_assign
id|SCset-&gt;timeout
op_minus
id|used
suffix:semicolon
id|SCset-&gt;timeout
op_assign
id|timeout
op_plus
id|used
suffix:semicolon
)brace
suffix:semicolon
id|least
op_assign
l_int|0xffffffff
suffix:semicolon
r_for
c_loop
(paren
id|host
op_assign
l_int|0
suffix:semicolon
id|host
OL
id|max_scsi_hosts
suffix:semicolon
id|host
op_increment
)paren
(brace
id|SCpnt
op_assign
id|host_queue
(braket
id|host
)braket
suffix:semicolon
r_while
c_loop
(paren
id|SCpnt
)paren
(brace
r_if
c_cond
(paren
id|SCpnt-&gt;timeout
OG
l_int|0
op_logical_and
(paren
id|SCpnt-&gt;timeout
op_sub_assign
id|used
)paren
OL
id|least
)paren
id|least
op_assign
id|SCpnt-&gt;timeout
suffix:semicolon
id|SCpnt
op_assign
id|SCpnt-&gt;next
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n;&t;If something is due to timeout again, then we will set the next timeout &n;&t;interrupt to occur.  Otherwise, timeouts are disabled.&n;*/
r_if
c_cond
(paren
id|least
op_ne
l_int|0xffffffff
)paren
(brace
id|time_start
op_assign
id|jiffies
suffix:semicolon
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|expires
op_assign
(paren
id|time_elapsed
op_assign
id|least
)paren
op_plus
id|jiffies
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|SCSI_TIMER
suffix:semicolon
)brace
r_else
(brace
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|expires
op_assign
id|time_start
op_assign
id|time_elapsed
op_assign
l_int|0
suffix:semicolon
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|SCSI_TIMER
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
id|oldto
suffix:semicolon
)brace
DECL|variable|dma_malloc_freelist
r_static
r_int
r_int
op_star
id|dma_malloc_freelist
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|dma_sectors
r_static
r_int
r_int
id|dma_sectors
op_assign
l_int|0
suffix:semicolon
DECL|variable|dma_free_sectors
r_int
r_int
id|dma_free_sectors
op_assign
l_int|0
suffix:semicolon
DECL|variable|need_isa_buffer
r_int
r_int
id|need_isa_buffer
op_assign
l_int|0
suffix:semicolon
DECL|variable|dma_malloc_buffer
r_static
r_int
r_char
op_star
id|dma_malloc_buffer
op_assign
l_int|NULL
suffix:semicolon
DECL|function|scsi_malloc
r_char
op_star
id|scsi_malloc
c_func
(paren
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|nbits
comma
id|mask
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_amp
l_int|0x1ff
)paren
op_logical_or
id|len
OG
l_int|4096
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Inappropriate buffer size requested&quot;
)paren
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|nbits
op_assign
id|len
op_rshift
l_int|9
suffix:semicolon
id|mask
op_assign
(paren
l_int|1
op_lshift
id|nbits
)paren
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|dma_sectors
op_rshift
l_int|4
)paren
suffix:semicolon
id|i
op_increment
)paren
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|17
op_minus
id|nbits
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|dma_malloc_freelist
(braket
id|i
)braket
op_amp
(paren
id|mask
op_lshift
id|j
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|dma_malloc_freelist
(braket
id|i
)braket
op_or_assign
(paren
id|mask
op_lshift
id|j
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|dma_free_sectors
op_sub_assign
id|nbits
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SMalloc: %d %x &quot;
comma
id|len
comma
id|dma_malloc_buffer
op_plus
(paren
id|i
op_lshift
l_int|13
)paren
op_plus
(paren
id|j
op_lshift
l_int|9
)paren
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
r_void
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|dma_malloc_buffer
op_plus
(paren
id|i
op_lshift
l_int|13
)paren
op_plus
(paren
id|j
op_lshift
l_int|9
)paren
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Nope.  No more */
)brace
DECL|function|scsi_free
r_int
id|scsi_free
c_func
(paren
r_char
op_star
id|obj
comma
r_int
r_int
id|len
)paren
(brace
r_int
id|offset
suffix:semicolon
r_int
id|page
comma
id|sector
comma
id|nbits
comma
id|mask
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Sfree %x %d&bslash;n&quot;
comma
id|obj
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
id|offset
op_assign
(paren
(paren
r_int
)paren
id|obj
)paren
op_minus
(paren
(paren
r_int
)paren
id|dma_malloc_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Bad offset&quot;
)paren
suffix:semicolon
id|page
op_assign
id|offset
op_rshift
l_int|13
suffix:semicolon
id|sector
op_assign
id|offset
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|sector
op_ge
id|dma_sectors
)paren
(brace
id|panic
(paren
l_string|&quot;Bad page&quot;
)paren
suffix:semicolon
)brace
id|sector
op_assign
(paren
id|offset
op_rshift
l_int|9
)paren
op_amp
l_int|15
suffix:semicolon
id|nbits
op_assign
id|len
op_rshift
l_int|9
suffix:semicolon
id|mask
op_assign
(paren
l_int|1
op_lshift
id|nbits
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mask
op_lshift
id|sector
)paren
OG
l_int|0xffff
)paren
id|panic
(paren
l_string|&quot;Bad memory alignment&quot;
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dma_malloc_freelist
(braket
id|page
)braket
op_amp
(paren
id|mask
op_lshift
id|sector
)paren
op_ne
(paren
id|mask
op_lshift
id|sector
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Trying to free unused memory&quot;
)paren
suffix:semicolon
)brace
id|dma_free_sectors
op_add_assign
id|nbits
suffix:semicolon
id|dma_malloc_freelist
(braket
id|page
)braket
op_and_assign
op_complement
(paren
id|mask
op_lshift
id|sector
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;scsi_dev_init() is our initialization routine, which inturn calls host &n;&t;initialization, bus scanning, and sd/st initialization routines.  It &n;&t;should be called from main().&n;*/
DECL|function|scsi_dev_init
r_int
r_int
id|scsi_dev_init
(paren
r_int
r_int
id|memory_start
comma
r_int
r_int
id|memory_end
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|host
suffix:semicolon
id|Scsi_Cmnd
op_star
id|SCpnt
suffix:semicolon
macro_line|#ifdef FOO_ON_YOU
r_return
suffix:semicolon
macro_line|#endif&t;
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|fn
op_assign
id|scsi_main_timeout
suffix:semicolon
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|expires
op_assign
l_int|0
suffix:semicolon
id|scsi_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* initialize all hosts */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max_scsi_hosts
suffix:semicolon
op_increment
id|i
)paren
id|last_reset
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_devices
op_assign
(paren
id|Scsi_Device
op_star
)paren
id|memory_start
suffix:semicolon
id|scan_scsis
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* scan for scsi devices */
id|memory_start
op_add_assign
id|NR_SCSI_DEVICES
op_star
r_sizeof
(paren
id|Scsi_Device
)paren
suffix:semicolon
id|memory_start
op_assign
id|sd_init1
c_func
(paren
id|memory_start
comma
id|memory_end
)paren
suffix:semicolon
id|memory_start
op_assign
id|st_init1
c_func
(paren
id|memory_start
comma
id|memory_end
)paren
suffix:semicolon
id|memory_start
op_assign
id|sr_init1
c_func
(paren
id|memory_start
comma
id|memory_end
)paren
suffix:semicolon
id|last_cmnd
op_assign
(paren
id|Scsi_Cmnd
op_star
)paren
id|memory_start
suffix:semicolon
id|SCpnt
op_assign
id|last_cmnd
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_SCSI_DEVICES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|j
suffix:semicolon
r_switch
c_cond
(paren
id|scsi_devices
(braket
id|i
)braket
dot
id|type
)paren
(brace
r_case
id|TYPE_TAPE
suffix:colon
id|st_attach
c_func
(paren
op_amp
id|scsi_devices
(braket
id|i
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_ROM
suffix:colon
id|sr_attach
c_func
(paren
op_amp
id|scsi_devices
(braket
id|i
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_DISK
suffix:colon
r_case
id|TYPE_MOD
suffix:colon
id|sd_attach
c_func
(paren
op_amp
id|scsi_devices
(braket
id|i
)braket
)paren
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|scsi_devices
(braket
id|i
)braket
dot
id|type
op_ne
op_minus
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|scsi_hosts
(braket
id|scsi_devices
(braket
id|i
)braket
dot
id|host_no
)braket
dot
id|cmd_per_lun
suffix:semicolon
id|j
op_increment
)paren
(brace
id|SCpnt-&gt;host
op_assign
id|scsi_devices
(braket
id|i
)braket
dot
id|host_no
suffix:semicolon
id|SCpnt-&gt;target
op_assign
id|scsi_devices
(braket
id|i
)braket
dot
id|id
suffix:semicolon
id|SCpnt-&gt;lun
op_assign
id|scsi_devices
(braket
id|i
)braket
dot
id|lun
suffix:semicolon
id|SCpnt-&gt;index
op_assign
id|i
suffix:semicolon
id|SCpnt-&gt;request.dev
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Mark not busy */
id|SCpnt-&gt;use_sg
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;underflow
op_assign
l_int|0
suffix:semicolon
id|SCpnt-&gt;transfersize
op_assign
l_int|0
suffix:semicolon
id|host
op_assign
id|scsi_devices
(braket
id|i
)braket
dot
id|host_no
suffix:semicolon
r_if
c_cond
(paren
id|host_queue
(braket
id|host
)braket
)paren
(brace
id|host_queue
(braket
id|host
)braket
op_member_access_from_pointer
id|prev
op_assign
id|SCpnt
suffix:semicolon
)brace
id|SCpnt-&gt;next
op_assign
id|host_queue
(braket
id|host
)braket
suffix:semicolon
id|SCpnt-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|host_queue
(braket
id|host
)braket
op_assign
id|SCpnt
suffix:semicolon
id|SCpnt
op_increment
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
id|memory_start
op_assign
(paren
r_int
)paren
id|SCpnt
suffix:semicolon
r_if
c_cond
(paren
id|NR_SD
OG
l_int|0
op_logical_or
id|NR_SR
OG
l_int|0
op_logical_or
id|NR_ST
OG
l_int|0
)paren
id|dma_sectors
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* Base value we use */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_SCSI_DEVICES
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int
id|host
suffix:semicolon
id|host
op_assign
id|scsi_devices
(braket
id|i
)braket
dot
id|host_no
suffix:semicolon
r_if
c_cond
(paren
id|scsi_devices
(braket
id|i
)braket
dot
id|type
op_ne
id|TYPE_TAPE
)paren
(brace
id|dma_sectors
op_add_assign
(paren
(paren
id|scsi_hosts
(braket
id|host
)braket
dot
id|sg_tablesize
op_star
r_sizeof
(paren
r_struct
id|scatterlist
)paren
op_plus
l_int|511
)paren
op_rshift
l_int|9
)paren
op_star
id|scsi_hosts
(braket
id|host
)braket
dot
id|cmd_per_lun
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scsi_hosts
(braket
id|host
)braket
dot
id|unchecked_isa_dma
op_logical_and
id|memory_end
OG
id|ISA_DMA_THRESHOLD
op_logical_and
id|scsi_devices
(braket
id|i
)braket
dot
id|type
op_ne
id|TYPE_TAPE
)paren
(brace
id|dma_sectors
op_add_assign
(paren
id|BLOCK_SIZE
op_rshift
l_int|9
)paren
op_star
id|scsi_hosts
(braket
id|host
)braket
dot
id|sg_tablesize
op_star
id|scsi_hosts
(braket
id|host
)braket
dot
id|cmd_per_lun
suffix:semicolon
id|need_isa_buffer
op_increment
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
id|dma_sectors
op_assign
(paren
id|dma_sectors
op_plus
l_int|15
)paren
op_amp
l_int|0xfff0
suffix:semicolon
id|dma_free_sectors
op_assign
id|dma_sectors
suffix:semicolon
multiline_comment|/* This must be a multiple of 16 */
id|memory_start
op_assign
(paren
id|memory_start
op_plus
l_int|3
)paren
op_amp
l_int|0xfffffffc
suffix:semicolon
id|dma_malloc_freelist
op_assign
(paren
r_int
r_int
op_star
)paren
id|memory_start
suffix:semicolon
id|memory_start
op_add_assign
id|dma_sectors
op_rshift
l_int|3
suffix:semicolon
id|memset
c_func
(paren
id|dma_malloc_freelist
comma
l_int|0
comma
id|dma_sectors
op_rshift
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memory_start
op_amp
l_int|1
)paren
(brace
id|memory_start
op_increment
suffix:semicolon
)brace
multiline_comment|/* Some host adapters require&n;&t;&t;&t;&t;&t;&t;buffers to be word aligned */
id|dma_malloc_buffer
op_assign
(paren
r_char
op_star
)paren
id|memory_start
suffix:semicolon
id|memory_start
op_add_assign
id|dma_sectors
op_lshift
l_int|9
suffix:semicolon
id|memory_start
op_assign
id|sd_init
c_func
(paren
id|memory_start
comma
id|memory_end
)paren
suffix:semicolon
multiline_comment|/* init scsi disks */
id|memory_start
op_assign
id|st_init
c_func
(paren
id|memory_start
comma
id|memory_end
)paren
suffix:semicolon
multiline_comment|/* init scsi tapes */
id|memory_start
op_assign
id|sr_init
c_func
(paren
id|memory_start
comma
id|memory_end
)paren
suffix:semicolon
r_return
id|memory_start
suffix:semicolon
)brace
DECL|function|print_inquiry
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|data
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Vendor: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  Model: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  Rev: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|32
suffix:semicolon
id|i
OL
l_int|36
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Type:   %s &quot;
comma
id|i
op_eq
l_int|0x00
ques
c_cond
l_string|&quot;Direct-Access    &quot;
suffix:colon
id|i
op_eq
l_int|0x01
ques
c_cond
l_string|&quot;Sequential-Access&quot;
suffix:colon
id|i
op_eq
l_int|0x02
ques
c_cond
l_string|&quot;Printer          &quot;
suffix:colon
id|i
op_eq
l_int|0x03
ques
c_cond
l_string|&quot;Processor        &quot;
suffix:colon
id|i
op_eq
l_int|0x04
ques
c_cond
l_string|&quot;WORM             &quot;
suffix:colon
id|i
op_eq
l_int|0x05
ques
c_cond
l_string|&quot;CD-ROM           &quot;
suffix:colon
id|i
op_eq
l_int|0x06
ques
c_cond
l_string|&quot;Scanner          &quot;
suffix:colon
id|i
op_eq
l_int|0x07
ques
c_cond
l_string|&quot;Optical Device   &quot;
suffix:colon
id|i
op_eq
l_int|0x08
ques
c_cond
l_string|&quot;Medium Changer   &quot;
suffix:colon
id|i
op_eq
l_int|0x09
ques
c_cond
l_string|&quot;Communications   &quot;
suffix:colon
l_string|&quot;Unknown          &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                 ANSI SCSI revision: %02x&quot;
comma
id|data
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|1
op_logical_and
(paren
id|data
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot; CCS&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
eof
