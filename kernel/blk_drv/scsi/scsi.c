multiline_comment|/*&n; *&t;scsi.c Copyright (C) 1992 Drew Eckhardt &n; *&t;generic mid-level SCSI driver by&n; *&t;&t;Drew Eckhardt &n; *&n; *&t;&lt;drew@colorado.edu&gt;&n; *&n; *&t;Bug correction thanks go to : &n; *&t;&t;Rik Faith &lt;faith@cs.unc.edu&gt;&n; *&t;&t;Tommy Thorn &lt;tthorn&gt;&n; *&t;&t;Thomas Wuensche &lt;tw@fgb1.fgb.mw.tu-meunchen.de&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef CONFIG_SCSI
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#ifdef CONFIG_BLK_DEV_SD
macro_line|#include &quot;sd.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_ST
macro_line|#include &quot;st.h&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_SR
macro_line|#include &quot;sr.h&quot;
macro_line|#endif
multiline_comment|/*&n;static const char RCSid[] = &quot;$Header: /usr/src/linux/kernel/blk_drv/scsi/RCS/scsi.c,v 1.1 1992/07/24 06:27:38 root Exp root $&quot;;&n;*/
DECL|macro|INTERNAL_ERROR
mdefine_line|#define INTERNAL_ERROR (printk (&quot;Internal error in file %s, line %d.&bslash;n&quot;, __FILE__, __LINE__), panic(&quot;&quot;))
r_static
r_void
id|scsi_done
(paren
r_int
id|host
comma
r_int
id|result
)paren
suffix:semicolon
r_static
r_void
id|update_timeout
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|data
)paren
suffix:semicolon
DECL|variable|time_start
r_static
r_int
id|time_start
suffix:semicolon
DECL|variable|time_elapsed
r_static
r_int
id|time_elapsed
suffix:semicolon
multiline_comment|/*&n;&t;global variables : &n;&t;NR_SCSI_DEVICES is the number of SCSI devices we have detected, &n;&t;scsi_devices an array of these specifing the address for each &n;&t;(host, id, LUN)&n;*/
DECL|variable|NR_SCSI_DEVICES
r_int
id|NR_SCSI_DEVICES
op_assign
l_int|0
suffix:semicolon
DECL|variable|scsi_devices
id|Scsi_Device
id|scsi_devices
(braket
id|MAX_SCSI_DEVICE
)braket
suffix:semicolon
DECL|macro|SENSE_LENGTH
mdefine_line|#define SENSE_LENGTH 255
multiline_comment|/*&n; *&t;As the scsi do command functions are inteligent, and may need to &n; *&t;redo a command, we need to keep track of the last command &n; *&t;executed on each one.&n; */
DECL|macro|WAS_RESET
mdefine_line|#define WAS_RESET &t;0x01
DECL|macro|WAS_TIMEDOUT
mdefine_line|#define WAS_TIMEDOUT &t;0x02
DECL|macro|WAS_SENSE
mdefine_line|#define WAS_SENSE&t;0x04
DECL|macro|IS_RESETTING
mdefine_line|#define IS_RESETTING&t;0x08
DECL|variable|last_cmnd
r_static
id|Scsi_Cmnd
id|last_cmnd
(braket
id|MAX_SCSI_HOSTS
)braket
suffix:semicolon
DECL|variable|last_reset
r_static
r_int
id|last_reset
(braket
id|MAX_SCSI_HOSTS
)braket
suffix:semicolon
multiline_comment|/*&n; *&t;This is the number  of clock ticks we should wait before we time out &n; *&t;and abort the command.  This is for  where the scsi.c module generates &n; *&t;the command, not where it originates from a higher level, in which&n; *&t;case the timeout is specified there.&n; *&n; *&t;ABORT_TIMEOUT and RESET_TIMEOUT are the timeouts for RESET and ABORT&n; *&t;respectively.&n; */
macro_line|#ifdef DEBUG
DECL|macro|SCSI_TIMEOUT
mdefine_line|#define SCSI_TIMEOUT 500
macro_line|#else
DECL|macro|SCSI_TIMEOUT
mdefine_line|#define SCSI_TIMEOUT 100
macro_line|#endif
macro_line|#ifdef DEBUG
DECL|macro|SENSE_TIMEOUT
mdefine_line|#define SENSE_TIMEOUT SCSI_TIMEOUT
DECL|macro|ABORT_TIMEOUT
mdefine_line|#define ABORT_TIMEOUT SCSI_TIMEOUT
DECL|macro|RESET_TIMEOUT
mdefine_line|#define RESET_TIMEOUT SCSI_TIMEOUT
macro_line|#else
DECL|macro|SENSE_TIMEOUT
mdefine_line|#define SENSE_TIMEOUT 50
DECL|macro|RESET_TIMEOUT
mdefine_line|#define RESET_TIMEOUT 50
DECL|macro|ABORT_TIMEOUT
mdefine_line|#define ABORT_TIMEOUT 50
DECL|macro|MIN_RESET_DELAY
mdefine_line|#define MIN_RESET_DELAY 25
macro_line|#endif
multiline_comment|/*&n; *&t;As the actual SCSI command runs in the background, we must set up a &n; *&t;flag that tells scan_scsis() when the result it has is valid.  &n; *&t;scan_scsis can set the_result to -1, and watch for it to become the &n; *&t;actual return code for that call.  the scan_scsis_done function() is &n; *&t;our user specified completion function that is passed on to the  &n; *&t;scsi_do_cmd() function.&n; */
DECL|variable|in_scan
r_volatile
r_static
r_int
id|in_scan
op_assign
l_int|0
suffix:semicolon
DECL|variable|the_result
r_static
r_int
id|the_result
suffix:semicolon
DECL|variable|sense_buffer
r_static
r_int
r_char
id|sense_buffer
(braket
id|SENSE_LENGTH
)braket
suffix:semicolon
DECL|function|scan_scsis_done
r_static
r_void
id|scan_scsis_done
(paren
r_int
id|host
comma
r_int
id|result
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
(paren
l_string|&quot;scan_scsis_done(%d, %06x)&bslash;n&bslash;r&quot;
comma
id|host
comma
id|result
)paren
suffix:semicolon
macro_line|#endif&t;
id|the_result
op_assign
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Detecting SCSI devices :&t;&n; *&t;We scan all present host adapter&squot;s busses,  from ID 0 to ID 6.  &n; *&t;We use the INQUIRY command, determine device type, and pass the ID / &n; *&t;lun address of all sequential devices to the tape driver, all random &n; *&t;devices to the disk driver.&n; */
DECL|function|scan_scsis
r_static
r_void
id|scan_scsis
(paren
r_void
)paren
(brace
r_int
id|host_nr
comma
id|dev
comma
id|lun
comma
id|type
comma
id|maxed
comma
id|slave
suffix:semicolon
r_static
r_int
r_char
id|scsi_cmd
(braket
l_int|12
)braket
suffix:semicolon
r_static
r_int
r_char
id|scsi_result
(braket
l_int|256
)braket
suffix:semicolon
op_increment
id|in_scan
suffix:semicolon
r_for
c_loop
(paren
id|slave
op_assign
id|host_nr
op_assign
l_int|0
suffix:semicolon
id|host_nr
OL
id|MAX_SCSI_HOSTS
suffix:semicolon
op_increment
id|host_nr
comma
id|slave
op_assign
l_int|0
)paren
r_if
c_cond
(paren
id|scsi_hosts
(braket
id|host_nr
)braket
dot
id|present
)paren
(brace
r_for
c_loop
(paren
id|dev
op_assign
l_int|0
suffix:semicolon
id|dev
OL
l_int|7
suffix:semicolon
op_increment
id|dev
)paren
r_if
c_cond
(paren
id|scsi_hosts
(braket
id|host_nr
)braket
dot
id|this_id
op_ne
id|dev
)paren
macro_line|#ifdef MULTI_LUN
r_for
c_loop
(paren
id|lun
op_assign
l_int|0
suffix:semicolon
id|lun
OL
l_int|8
suffix:semicolon
op_increment
id|lun
)paren
(brace
macro_line|#else
(brace
id|lun
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Build an INQUIRY command block.  &n; */
id|scsi_cmd
(braket
l_int|0
)braket
op_assign
id|INQUIRY
suffix:semicolon
id|scsi_cmd
(braket
l_int|1
)braket
op_assign
(paren
id|lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|scsi_cmd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_cmd
(braket
l_int|4
)braket
op_assign
l_int|255
suffix:semicolon
id|scsi_cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
id|the_result
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef DEBUG
id|memset
(paren
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|0
comma
l_int|255
)paren
suffix:semicolon
macro_line|#endif 
id|scsi_do_cmd
(paren
id|host_nr
comma
id|dev
comma
(paren
r_void
op_star
)paren
id|scsi_cmd
comma
(paren
r_void
op_star
)paren
id|scsi_result
comma
l_int|256
comma
id|scan_scsis_done
comma
id|SCSI_TIMEOUT
comma
id|sense_buffer
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/*&n; * &t;Wait for valid result &n; */
r_while
c_loop
(paren
id|the_result
OL
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|the_result
)paren
(brace
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|host_no
op_assign
id|host_nr
suffix:semicolon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|id
op_assign
id|dev
suffix:semicolon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|lun
op_assign
id|lun
suffix:semicolon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|removable
op_assign
(paren
l_int|0x80
op_amp
id|scsi_result
(braket
l_int|1
)braket
)paren
op_rshift
l_int|7
suffix:semicolon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|changed
op_assign
l_int|0
suffix:semicolon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|access_count
op_assign
l_int|0
suffix:semicolon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|busy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n; *&t;Currently, all sequential devices are assumed to be tapes,&n; *&t;all random devices disk, with the appropriate read only &n; *&t;flags set for ROM / WORM treated as RO.&n; */
r_switch
c_cond
(paren
id|type
op_assign
id|scsi_result
(braket
l_int|0
)braket
)paren
(brace
r_case
id|TYPE_TAPE
suffix:colon
r_case
id|TYPE_DISK
suffix:colon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|writeable
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_WORM
suffix:colon
r_case
id|TYPE_ROM
suffix:colon
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|writeable
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|type
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
dot
id|random
op_assign
(paren
id|type
op_eq
id|TYPE_TAPE
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
id|maxed
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
op_minus
l_int|1
suffix:colon
r_break
suffix:semicolon
r_case
id|TYPE_TAPE
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Detected scsi tape at host %d, ID  %d, lun %d &bslash;n&quot;
comma
id|host_nr
comma
id|dev
comma
id|lun
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_ST
r_if
c_cond
(paren
op_logical_neg
(paren
id|maxed
op_assign
(paren
id|NR_ST
op_eq
id|MAX_ST
)paren
)paren
)paren
id|scsi_tapes
(braket
id|NR_ST
)braket
dot
id|device
op_assign
op_amp
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|TYPE_ROM
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Detected scsi CD-ROM at host %d, ID  %d, lun %d &bslash;n&quot;
comma
id|host_nr
comma
id|dev
comma
id|lun
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_SR
r_if
c_cond
(paren
op_logical_neg
(paren
id|maxed
op_assign
(paren
id|NR_SR
op_ge
id|MAX_SR
)paren
)paren
)paren
id|scsi_CDs
(braket
id|NR_SR
)braket
dot
id|device
op_assign
op_amp
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_default
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Detected scsi disk at host %d, ID  %d, lun %d &bslash;n&quot;
comma
id|host_nr
comma
id|dev
comma
id|lun
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_SD
r_if
c_cond
(paren
op_logical_neg
(paren
id|maxed
op_assign
(paren
id|NR_SD
op_ge
id|MAX_SD
)paren
)paren
)paren
id|rscsi_disks
(braket
id|NR_SD
)braket
dot
id|device
op_assign
op_amp
id|scsi_devices
(braket
id|NR_SCSI_DEVICES
)braket
suffix:semicolon
macro_line|#endif
)brace
id|print_inquiry
c_func
(paren
id|scsi_result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxed
)paren
(brace
id|printk
(paren
l_string|&quot;Already have detected &quot;
l_string|&quot;maximum number of SCSI &quot;
l_string|&quot;%ss Unable to &bslash;n&quot;
l_string|&quot;add drive at SCSI host &quot;
l_string|&quot;%s, ID %d, LUN %d&bslash;n&bslash;r&quot;
comma
(paren
id|type
op_eq
id|TYPE_TAPE
)paren
ques
c_cond
l_string|&quot;tape&quot;
suffix:colon
(paren
id|type
op_eq
id|TYPE_DISK
)paren
ques
c_cond
l_string|&quot;disk&quot;
suffix:colon
l_string|&quot;CD-ROM&quot;
comma
id|scsi_hosts
(braket
id|host_nr
)braket
dot
id|name
comma
id|dev
comma
id|lun
)paren
suffix:semicolon
id|type
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|type
op_ne
op_minus
l_int|1
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_char
id|str
(braket
l_int|25
)braket
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|str
comma
(paren
r_void
op_star
)paren
op_amp
id|scsi_result
(braket
l_int|8
)braket
comma
l_int|8
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|str
suffix:semicolon
(paren
id|p
OL
(paren
id|str
op_plus
l_int|8
)paren
)paren
op_logical_and
(paren
op_star
id|p
op_ne
l_char|&squot; &squot;
)paren
suffix:semicolon
op_increment
id|p
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
id|p
comma
(paren
r_void
op_star
)paren
op_amp
id|scsi_result
(braket
l_int|16
)braket
comma
l_int|16
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
op_star
id|p
op_ne
l_char|&squot; &squot;
suffix:semicolon
op_increment
id|p
)paren
suffix:semicolon
op_star
id|p
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;s%c%d at scsi%d, id %d, lun %d : %s&bslash;n&quot;
comma
(paren
id|type
op_eq
id|TYPE_TAPE
)paren
ques
c_cond
l_char|&squot;t&squot;
suffix:colon
(paren
(paren
id|type
op_eq
id|TYPE_ROM
)paren
ques
c_cond
l_char|&squot;r&squot;
suffix:colon
l_char|&squot;d&squot;
)paren
comma
(paren
id|type
op_eq
id|TYPE_TAPE
)paren
ques
c_cond
macro_line|#ifdef CONFIG_BLK_DEV_ST
id|NR_ST
macro_line|#else 
op_minus
l_int|1
macro_line|#endif
suffix:colon
(paren
id|type
op_eq
id|TYPE_ROM
ques
c_cond
macro_line|#ifdef CONFIG_BLK_DEV_SR
id|NR_SR
macro_line|#else
op_minus
l_int|1
macro_line|#endif
suffix:colon
macro_line|#ifdef CONFIG_BLK_DEV_SD
id|NR_SD
macro_line|#else
op_minus
l_int|1
macro_line|#endif
)paren
comma
id|host_nr
comma
id|dev
comma
id|lun
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|TYPE_TAPE
)paren
macro_line|#ifdef CONFIG_BLK_DEV_ST
op_increment
id|NR_ST
suffix:semicolon
macro_line|#else
suffix:semicolon
macro_line|#endif
r_else
r_if
c_cond
(paren
id|type
op_eq
id|TYPE_DISK
)paren
macro_line|#ifdef CONFIG_BLK_DEV_SD
op_increment
id|NR_SD
suffix:semicolon
macro_line|#else
suffix:semicolon
macro_line|#endif
r_else
macro_line|#ifdef CONFIG_BLK_DEV_SR
op_increment
id|NR_SR
suffix:semicolon
macro_line|#else
suffix:semicolon
macro_line|#endif
)brace
op_increment
id|slave
suffix:semicolon
op_increment
id|NR_SCSI_DEVICES
suffix:semicolon
)brace
multiline_comment|/* if result == DID_OK ends */
)brace
multiline_comment|/* for lun ends */
)brace
multiline_comment|/* if present */
id|printk
c_func
(paren
l_string|&quot;scsi : detected &quot;
macro_line|#ifdef CONFIG_BLK_DEV_SD
l_string|&quot;%d SCSI disk%s &quot;
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_ST
l_string|&quot;%d tape%s &quot;
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_SR
l_string|&quot;%d CD-ROM drive%s &quot;
macro_line|#endif
l_string|&quot;total.&bslash;n&quot;
macro_line|#ifdef CONFIG_BLK_DEV_SD
comma
id|NR_SD
comma
(paren
id|NR_SD
op_ne
l_int|1
)paren
ques
c_cond
l_string|&quot;s&quot;
suffix:colon
l_string|&quot;&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_ST
comma
id|NR_ST
comma
(paren
id|NR_ST
op_ne
l_int|1
)paren
ques
c_cond
l_string|&quot;s&quot;
suffix:colon
l_string|&quot;&quot;
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_SR
comma
id|NR_SR
comma
(paren
id|NR_SR
op_ne
l_int|1
)paren
ques
c_cond
l_string|&quot;s&quot;
suffix:colon
l_string|&quot;&quot;
macro_line|#endif
)paren
suffix:semicolon
id|in_scan
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* scan_scsis  ends */
multiline_comment|/*&n; *&t;We handle the timeout differently if it happens when a reset, &n; *&t;abort, etc are in process. &n; */
DECL|variable|internal_timeout
r_static
r_int
r_char
id|internal_timeout
(braket
id|MAX_SCSI_HOSTS
)braket
suffix:semicolon
multiline_comment|/*&n; *&t;Flag bits for the internal_timeout array &n; */
DECL|macro|NORMAL_TIMEOUT
mdefine_line|#define NORMAL_TIMEOUT 0
DECL|macro|IN_ABORT
mdefine_line|#define IN_ABORT 1
DECL|macro|IN_RESET
mdefine_line|#define IN_RESET 2
multiline_comment|/*&n;&t;This is our time out function, called when the timer expires for a &n;&t;given host adapter.  It will attempt to abort the currently executing &n;&t;command, that failing perform a kernel panic.&n;*/
DECL|function|scsi_times_out
r_static
r_void
id|scsi_times_out
(paren
r_int
id|host
)paren
(brace
r_switch
c_cond
(paren
id|internal_timeout
(braket
id|host
)braket
op_amp
(paren
id|IN_ABORT
op_or
id|IN_RESET
)paren
)paren
(brace
r_case
id|NORMAL_TIMEOUT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|in_scan
)paren
id|printk
c_func
(paren
l_string|&quot;SCSI host %d timed out - aborting command &bslash;r&bslash;n&quot;
comma
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_abort
(paren
id|host
comma
id|DID_TIME_OUT
)paren
)paren
r_return
suffix:semicolon
r_case
id|IN_ABORT
suffix:colon
id|printk
c_func
(paren
l_string|&quot;SCSI host %d abort() timed out - reseting &bslash;r&bslash;n&quot;
comma
id|host
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scsi_reset
(paren
id|host
)paren
)paren
r_return
suffix:semicolon
r_case
id|IN_RESET
suffix:colon
r_case
(paren
id|IN_ABORT
op_or
id|IN_RESET
)paren
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unable to reset scsi host %d&bslash;r&bslash;n&quot;
comma
id|host
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
r_default
suffix:colon
id|INTERNAL_ERROR
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;This is inline because we have stack problemes if we recurse to deeply.&n;*/
DECL|function|internal_cmnd
r_static
r_void
id|internal_cmnd
(paren
r_int
id|host
comma
r_int
r_char
id|target
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buffer
comma
r_int
id|bufflen
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_int
comma
r_int
)paren
)paren
(brace
r_int
id|temp
suffix:semicolon
macro_line|#ifdef DEBUG_DELAY&t;
r_int
id|clock
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|host
OL
l_int|0
)paren
op_logical_or
(paren
id|host
OG
id|MAX_SCSI_HOSTS
)paren
)paren
id|panic
(paren
l_string|&quot;Host number in internal_cmnd() is out of range.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;We will wait MIN_RESET_DELAY clock ticks after the last reset so &n;&t;we can avoid the drive not being ready.&n;*/
id|temp
op_assign
id|last_reset
(braket
id|host
)braket
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|temp
)paren
suffix:semicolon
id|host_timeout
(braket
id|host
)braket
op_assign
id|last_cmnd
(braket
id|host
)braket
dot
id|timeout_per_command
suffix:semicolon
id|update_timeout
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;We will use a queued command if possible, otherwise we will emulate the&n;&t;queing and calling of completion function ourselves. &n;*/
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;internal_cmnd (host = %d, target = %d, command = %08x, buffer =  %08x, &bslash;n&quot;
l_string|&quot;bufflen = %d, done = %08x)&bslash;n&quot;
comma
id|host
comma
id|target
comma
id|cmnd
comma
id|buffer
comma
id|bufflen
comma
id|done
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|scsi_hosts
(braket
id|host
)braket
dot
id|can_queue
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;queuecommand : routine at %08x&bslash;n&quot;
comma
id|scsi_hosts
(braket
id|host
)braket
dot
id|queuecommand
)paren
suffix:semicolon
macro_line|#endif
id|scsi_hosts
(braket
id|host
)braket
dot
id|queuecommand
(paren
id|target
comma
id|cmnd
comma
id|buffer
comma
id|bufflen
comma
id|done
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;command() :  routine at %08x&bslash;n&quot;
comma
id|scsi_hosts
(braket
id|host
)braket
dot
id|command
)paren
suffix:semicolon
macro_line|#endif
id|temp
op_assign
id|scsi_hosts
(braket
id|host
)braket
dot
id|command
(paren
id|target
comma
id|cmnd
comma
id|buffer
comma
id|bufflen
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_DELAY
id|clock
op_assign
id|jiffies
op_plus
l_int|400
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|clock
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;done(host = %d, result = %04x) : routine at %08x&bslash;n&quot;
comma
id|host
comma
id|temp
comma
id|done
)paren
suffix:semicolon
macro_line|#endif
id|done
c_func
(paren
id|host
comma
id|temp
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;leaving internal_cmnd()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|scsi_request_sense
r_static
r_void
id|scsi_request_sense
(paren
r_int
id|host
comma
r_int
r_char
id|target
comma
r_int
r_char
id|lun
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|host_timeout
(braket
id|host
)braket
op_assign
id|SENSE_TIMEOUT
suffix:semicolon
id|update_timeout
c_func
(paren
)paren
suffix:semicolon
id|last_cmnd
(braket
id|host
)braket
dot
id|flags
op_or_assign
id|WAS_SENSE
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|last_cmnd
(braket
id|host
)braket
dot
id|sense_cmnd
(braket
l_int|1
)braket
op_assign
id|lun
op_lshift
l_int|5
suffix:semicolon
id|internal_cmnd
(paren
id|host
comma
id|target
comma
(paren
r_void
op_star
)paren
id|last_cmnd
(braket
id|host
)braket
dot
id|sense_cmnd
comma
(paren
r_void
op_star
)paren
id|last_cmnd
(braket
id|host
)braket
dot
id|sense_buffer
comma
id|SENSE_LENGTH
comma
id|scsi_done
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;scsi_do_cmd sends all the commands out to the low-level driver.  It &n;&t;handles the specifics required for each low level driver - ie queued &n;&t;or non queud.  It also prevents conflicts when different high level &n;&t;drivers go for the same host at the same time.&n;*/
DECL|function|scsi_do_cmd
r_void
id|scsi_do_cmd
(paren
r_int
id|host
comma
r_int
r_char
id|target
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buffer
comma
r_int
id|bufflen
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_int
comma
r_int
)paren
comma
r_int
id|timeout
comma
r_int
r_char
op_star
id|sense_buffer
comma
r_int
id|retries
)paren
(brace
r_int
id|ok
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
r_int
id|i
suffix:semicolon
id|printk
(paren
l_string|&quot;scsi_do_cmd (host = %d, target = %d, buffer =%08x, &quot;
l_string|&quot;bufflen = %d, done = %08x, timeout = %d, retries = %d)&bslash;n&quot;
l_string|&quot;command : &quot;
comma
id|host
comma
id|target
comma
id|buffer
comma
id|bufflen
comma
id|done
comma
id|timeout
comma
id|retries
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
op_increment
id|i
)paren
id|printk
(paren
l_string|&quot;%02x  &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|cmnd
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|host
op_ge
id|MAX_SCSI_HOSTS
)paren
op_logical_or
op_logical_neg
id|scsi_hosts
(braket
id|host
)braket
dot
id|present
)paren
(brace
id|printk
(paren
l_string|&quot;Invalid or not present host number. %d&bslash;n&quot;
comma
id|host
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;We must prevent reentrancy to the lowlevel host driver.  This prevents &n;&t;it - we enter a loop until the host we want to talk to is not busy.   &n;&t;Race conditions are prevented, as interrupts are disabled inbetween the&n;&t;time we check for the host being not busy, and the time we mark it busy&n;&t;ourselves.&n;*/
r_do
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|host_busy
(braket
id|host
)braket
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Host %d is busy.&bslash;n&quot;
comma
id|host
)paren
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|host_busy
(braket
id|host
)braket
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Host %d is no longer busy.&bslash;n&quot;
comma
id|host
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|host_busy
(braket
id|host
)braket
op_assign
l_int|1
suffix:semicolon
id|ok
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|ok
)paren
suffix:semicolon
multiline_comment|/*&n;&t;Our own function scsi_done (which marks the host as not busy, disables &n;&t;the timeout counter, etc) will be called by us or by the &n;&t;scsi_hosts[host].queuecommand() function needs to also call&n;&t;the completion function for the high level driver.&n;&n;*/
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|last_cmnd
(braket
id|host
)braket
dot
id|cmnd
comma
(paren
r_void
op_star
)paren
id|cmnd
comma
l_int|10
)paren
suffix:semicolon
id|last_cmnd
(braket
id|host
)braket
dot
id|host
op_assign
id|host
suffix:semicolon
id|last_cmnd
(braket
id|host
)braket
dot
id|target
op_assign
id|target
suffix:semicolon
id|last_cmnd
(braket
id|host
)braket
dot
id|lun
op_assign
(paren
id|last_cmnd
(braket
id|host
)braket
dot
id|cmnd
(braket
l_int|1
)braket
op_rshift
l_int|5
)paren
suffix:semicolon
id|last_cmnd
(braket
id|host
)braket
dot
id|bufflen
op_assign
id|bufflen
suffix:semicolon
id|last_cmnd
(braket
id|host
)braket
dot
id|buffer
op_assign
id|buffer
suffix:semicolon
id|last_cmnd
(braket
id|host
)braket
dot
id|sense_buffer
op_assign
id|sense_buffer
suffix:semicolon
id|last_cmnd
(braket
id|host
)braket
dot
id|flags
op_assign
l_int|0
suffix:semicolon
id|last_cmnd
(braket
id|host
)braket
dot
id|retries
op_assign
l_int|0
suffix:semicolon
id|last_cmnd
(braket
id|host
)braket
dot
id|allowed
op_assign
id|retries
suffix:semicolon
id|last_cmnd
(braket
id|host
)braket
dot
id|done
op_assign
id|done
suffix:semicolon
id|last_cmnd
(braket
id|host
)braket
dot
id|timeout_per_command
op_assign
id|timeout
suffix:semicolon
multiline_comment|/* Start the timer ticking.  */
id|internal_timeout
(braket
id|host
)braket
op_assign
l_int|0
suffix:semicolon
id|internal_cmnd
(paren
id|host
comma
id|target
comma
id|cmnd
comma
id|buffer
comma
id|bufflen
comma
id|scsi_done
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
(paren
l_string|&quot;Leaving scsi_do_cmd()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n;&t;The scsi_done() function disables the timeout timer for the scsi host, &n;&t;marks the host as not busy, and calls the user specified completion &n;&t;function for that host&squot;s current command.&n;*/
DECL|function|reset
r_static
r_void
id|reset
(paren
r_int
id|host
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;reset(%d)&bslash;n&quot;
comma
id|host
)paren
suffix:semicolon
macro_line|#endif
id|last_cmnd
(braket
id|host
)braket
dot
id|flags
op_or_assign
(paren
id|WAS_RESET
op_or
id|IS_RESETTING
)paren
suffix:semicolon
id|scsi_reset
c_func
(paren
id|host
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;performing request sense&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|scsi_request_sense
(paren
id|host
comma
id|last_cmnd
(braket
id|host
)braket
dot
id|target
comma
id|last_cmnd
(braket
id|host
)braket
dot
id|lun
)paren
suffix:semicolon
)brace
DECL|function|check_sense
r_static
r_int
id|check_sense
(paren
r_int
id|host
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|last_cmnd
(braket
id|host
)braket
dot
id|sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x70
)paren
op_rshift
l_int|4
)paren
op_eq
l_int|7
)paren
r_switch
c_cond
(paren
id|last_cmnd
(braket
id|host
)braket
dot
id|sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
(brace
r_case
id|NO_SENSE
suffix:colon
r_case
id|RECOVERED_ERROR
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|ABORTED_COMMAND
suffix:colon
r_case
id|NOT_READY
suffix:colon
r_return
id|SUGGEST_RETRY
suffix:semicolon
r_case
id|UNIT_ATTENTION
suffix:colon
r_return
id|SUGGEST_ABORT
suffix:semicolon
multiline_comment|/* these three are not supported */
r_case
id|COPY_ABORTED
suffix:colon
r_case
id|VOLUME_OVERFLOW
suffix:colon
r_case
id|MISCOMPARE
suffix:colon
r_case
id|MEDIUM_ERROR
suffix:colon
r_return
id|SUGGEST_REMAP
suffix:semicolon
r_case
id|BLANK_CHECK
suffix:colon
r_case
id|DATA_PROTECT
suffix:colon
r_case
id|HARDWARE_ERROR
suffix:colon
r_case
id|ILLEGAL_REQUEST
suffix:colon
r_default
suffix:colon
r_return
id|SUGGEST_ABORT
suffix:semicolon
)brace
r_else
r_return
id|SUGGEST_RETRY
suffix:semicolon
)brace
multiline_comment|/* This function is the mid-level interrupt routine, which decides how&n; *  to handle error conditions.  Each invocation of this function must&n; *  do one and *only* one of the following:&n; *&n; *  (1) Call last_cmnd[host].done.  This is done for fatal errors and&n; *      normal completion, and indicates that the handling for this&n; *      request is complete.&n; *  (2) Call internal_cmnd to requeue the command.  This will result in&n; *      scsi_done being called again when the retry is complete.&n; *  (3) Call scsi_request_sense.  This asks the host adapter/drive for&n; *      more information about the error condition.  When the information&n; *      is available, scsi_done will be called again.&n; *  (4) Call reset().  This is sort of a last resort, and the idea is that&n; *      this may kick things loose and get the drive working again.  reset()&n; *      automatically calls scsi_request_sense, and thus scsi_done will be&n; *      called again once the reset is complete.&n; *&n; *      If none of the above actions are taken, the drive in question&n; * will hang. If more than one of the above actions are taken by&n; * scsi_done, then unpredictable behavior will result.&n; */
DECL|function|scsi_done
r_static
r_void
id|scsi_done
(paren
r_int
id|host
comma
r_int
id|result
)paren
(brace
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_int
m_exit
op_assign
l_int|0
suffix:semicolon
r_int
id|checked
suffix:semicolon
r_int
id|oldto
suffix:semicolon
id|oldto
op_assign
id|host_timeout
(braket
id|host
)braket
suffix:semicolon
id|host_timeout
(braket
id|host
)braket
op_assign
l_int|0
suffix:semicolon
id|update_timeout
c_func
(paren
)paren
suffix:semicolon
DECL|macro|FINISHED
mdefine_line|#define FINISHED 0
DECL|macro|MAYREDO
mdefine_line|#define MAYREDO  1
DECL|macro|REDO
mdefine_line|#define REDO&t; 3
DECL|macro|PENDING
mdefine_line|#define PENDING  4
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;In scsi_done(host = %d, result = %06x)&bslash;n&quot;
comma
id|host
comma
id|result
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|host
OG
id|MAX_SCSI_HOSTS
op_logical_or
id|host
OL
l_int|0
)paren
(brace
id|host_timeout
(braket
id|host
)braket
op_assign
l_int|0
suffix:semicolon
id|update_timeout
c_func
(paren
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;scsi_done() called with invalid host number.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|host_byte
c_func
(paren
id|result
)paren
)paren
(brace
r_case
id|DID_OK
suffix:colon
r_if
c_cond
(paren
id|last_cmnd
(braket
id|host
)braket
dot
id|flags
op_amp
id|IS_RESETTING
)paren
(brace
id|last_cmnd
(braket
id|host
)braket
dot
id|flags
op_and_assign
op_complement
id|IS_RESETTING
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status_byte
c_func
(paren
id|result
)paren
op_logical_and
(paren
id|last_cmnd
(braket
id|host
)braket
dot
id|flags
op_amp
id|WAS_SENSE
)paren
)paren
(brace
id|last_cmnd
(braket
id|host
)braket
dot
id|flags
op_and_assign
op_complement
id|WAS_SENSE
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|internal_timeout
(braket
id|host
)braket
op_and_assign
op_complement
id|SENSE_TIMEOUT
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|last_cmnd
(braket
id|host
)braket
dot
id|flags
op_amp
id|WAS_RESET
)paren
)paren
(brace
id|reset
c_func
(paren
id|host
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
m_exit
op_assign
(paren
id|DRIVER_HARD
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
id|status
op_assign
id|FINISHED
suffix:semicolon
)brace
)brace
r_else
r_switch
c_cond
(paren
id|msg_byte
c_func
(paren
id|result
)paren
)paren
(brace
r_case
id|COMMAND_COMPLETE
suffix:colon
r_switch
c_cond
(paren
id|status_byte
c_func
(paren
id|result
)paren
)paren
(brace
r_case
id|GOOD
suffix:colon
r_if
c_cond
(paren
id|last_cmnd
(braket
id|host
)braket
dot
id|flags
op_amp
id|WAS_SENSE
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
(paren
l_string|&quot;In scsi_done, GOOD status, COMMAND COMPLETE, parsing sense information.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|last_cmnd
(braket
id|host
)braket
dot
id|flags
op_and_assign
op_complement
id|WAS_SENSE
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|internal_timeout
(braket
id|host
)braket
op_and_assign
op_complement
id|SENSE_TIMEOUT
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|checked
op_assign
id|check_sense
c_func
(paren
id|host
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;NO SENSE.  status = REDO&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|host_timeout
(braket
id|host
)braket
op_assign
id|oldto
suffix:semicolon
id|update_timeout
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_REMAP
suffix:colon
r_case
id|SUGGEST_RETRY
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SENSE SUGGEST REMAP or SUGGEST RETRY - status = MAYREDO&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|status
op_assign
id|MAYREDO
suffix:semicolon
m_exit
op_assign
id|SUGGEST_RETRY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SUGGEST_ABORT
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SENSE SUGGEST ABORT - status = FINISHED&quot;
)paren
suffix:semicolon
macro_line|#endif
id|status
op_assign
id|FINISHED
suffix:semicolon
m_exit
op_assign
id|DRIVER_SENSE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Internal error %s %s &bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;COMMAND COMPLETE message returned, status = FINISHED. &bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
m_exit
op_assign
id|DRIVER_OK
suffix:semicolon
id|status
op_assign
id|FINISHED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CHECK_CONDITION
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;CHECK CONDITION message returned, performing request sense.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|scsi_request_sense
(paren
id|host
comma
id|last_cmnd
(braket
id|host
)braket
dot
id|target
comma
id|last_cmnd
(braket
id|host
)braket
dot
id|lun
)paren
suffix:semicolon
id|status
op_assign
id|PENDING
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CONDITION_GOOD
suffix:colon
r_case
id|INTERMEDIATE_GOOD
suffix:colon
r_case
id|INTERMEDIATE_C_GOOD
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;CONDITION GOOD, INTERMEDIATE GOOD, or INTERMEDIATE CONDITION GOOD recieved and ignored. &bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|BUSY
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;BUSY message returned, performing REDO&quot;
)paren
suffix:semicolon
macro_line|#endif
id|host_timeout
(braket
id|host
)braket
op_assign
id|oldto
suffix:semicolon
id|update_timeout
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RESERVATION_CONFLICT
suffix:colon
id|reset
c_func
(paren
id|host
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#if 0
m_exit
op_assign
id|DRIVER_SOFT
op_or
id|SUGGEST_ABORT
suffix:semicolon
id|status
op_assign
id|MAYREDO
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Internal error %s %s &bslash;n&quot;
l_string|&quot;status byte = %d &bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|status_byte
c_func
(paren
id|result
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
(paren
l_string|&quot;unsupported message byte recieved.&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DID_TIME_OUT
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Host returned DID_TIME_OUT - &quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|last_cmnd
(braket
id|host
)braket
dot
id|flags
op_amp
id|WAS_TIMEDOUT
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Aborting&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif&t;
m_exit
op_assign
(paren
id|DRIVER_TIMEOUT
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
(paren
l_string|&quot;Retrying.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|last_cmnd
(braket
id|host
)braket
dot
id|flags
op_or_assign
id|WAS_TIMEDOUT
suffix:semicolon
id|status
op_assign
id|REDO
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|DID_BUS_BUSY
suffix:colon
r_case
id|DID_PARITY
suffix:colon
id|status
op_assign
id|REDO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_NO_CONNECT
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Couldn&squot;t connect.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
m_exit
op_assign
(paren
id|DRIVER_HARD
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_ERROR
suffix:colon
id|status
op_assign
id|MAYREDO
suffix:semicolon
m_exit
op_assign
(paren
id|DRIVER_HARD
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DID_BAD_TARGET
suffix:colon
r_case
id|DID_ABORT
suffix:colon
m_exit
op_assign
(paren
id|DRIVER_INVALID
op_or
id|SUGGEST_ABORT
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
m_exit
op_assign
(paren
id|DRIVER_ERROR
op_or
id|SUGGEST_DIE
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|FINISHED
suffix:colon
r_case
id|PENDING
suffix:colon
r_break
suffix:semicolon
r_case
id|MAYREDO
suffix:colon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;In MAYREDO, allowing %d retries, have %d&bslash;n&bslash;r&quot;
comma
id|last_cmnd
(braket
id|host
)braket
dot
id|allowed
comma
id|last_cmnd
(braket
id|host
)braket
dot
id|retries
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
op_increment
id|last_cmnd
(braket
id|host
)braket
dot
id|retries
)paren
OL
id|last_cmnd
(braket
id|host
)braket
dot
id|allowed
)paren
(brace
r_if
c_cond
(paren
(paren
id|last_cmnd
(braket
id|host
)braket
dot
id|retries
op_ge
(paren
id|last_cmnd
(braket
id|host
)braket
dot
id|allowed
op_rshift
l_int|1
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|last_cmnd
(braket
id|host
)braket
dot
id|flags
op_amp
id|WAS_RESET
)paren
)paren
(brace
id|reset
c_func
(paren
id|host
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
id|FINISHED
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* fall through to REDO */
r_case
id|REDO
suffix:colon
r_if
c_cond
(paren
id|last_cmnd
(braket
id|host
)braket
dot
id|flags
op_amp
id|WAS_SENSE
)paren
id|scsi_request_sense
(paren
id|host
comma
id|last_cmnd
(braket
id|host
)braket
dot
id|target
comma
id|last_cmnd
(braket
id|host
)braket
dot
id|lun
)paren
suffix:semicolon
r_else
id|internal_cmnd
(paren
id|host
comma
id|last_cmnd
(braket
id|host
)braket
dot
id|target
comma
id|last_cmnd
(braket
id|host
)braket
dot
id|cmnd
comma
id|last_cmnd
(braket
id|host
)braket
dot
id|buffer
comma
id|last_cmnd
(braket
id|host
)braket
dot
id|bufflen
comma
id|scsi_done
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|INTERNAL_ERROR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_eq
id|FINISHED
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Calling done function - at address %08x&bslash;n&quot;
comma
id|last_cmnd
(braket
id|host
)braket
dot
id|done
)paren
suffix:semicolon
macro_line|#endif
id|host_busy
(braket
id|host
)braket
op_assign
l_int|0
suffix:semicolon
id|last_cmnd
(braket
id|host
)braket
dot
id|done
(paren
id|host
comma
(paren
id|result
op_or
(paren
(paren
m_exit
op_amp
l_int|0xff
)paren
op_lshift
l_int|24
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|macro|FINISHED
macro_line|#undef FINISHED
DECL|macro|REDO
macro_line|#undef REDO
DECL|macro|MAYREDO
macro_line|#undef MAYREDO
DECL|macro|PENDING
macro_line|#undef PENDING
)brace
multiline_comment|/*&n;&t;The scsi_abort function interfaces with the abort() function of the host&n;&t;we are aborting, and causes the current command to not complete.  The &n;&t;caller should deal with any error messages or status returned on the &n;&t;next call.&n;&t;&n;&t;This will not be called rentrantly for a given host.&n;*/
multiline_comment|/*&n;&t;Since we&squot;re nice guys and specified that abort() and reset()&n;&t;can be non-reentrant.  The internal_timeout flags are used for&n;&t;this.&n;*/
DECL|function|scsi_abort
r_int
id|scsi_abort
(paren
r_int
id|host
comma
r_int
id|why
)paren
(brace
r_int
id|temp
comma
id|oldto
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|internal_timeout
(braket
id|host
)braket
op_amp
id|IN_ABORT
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|internal_timeout
(braket
id|host
)braket
op_amp
id|IN_ABORT
)paren
suffix:semicolon
)brace
r_else
(brace
id|oldto
op_assign
id|host_timeout
(braket
id|host
)braket
suffix:semicolon
id|internal_timeout
(braket
id|host
)braket
op_or_assign
id|IN_ABORT
suffix:semicolon
id|host_timeout
(braket
id|host
)braket
op_assign
id|ABORT_TIMEOUT
suffix:semicolon
id|update_timeout
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|host_busy
(braket
id|host
)braket
op_logical_or
op_logical_neg
id|scsi_hosts
(braket
id|host
)braket
dot
m_abort
(paren
id|why
)paren
)paren
id|temp
op_assign
l_int|0
suffix:semicolon
r_else
id|temp
op_assign
l_int|1
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|internal_timeout
(braket
id|host
)braket
op_and_assign
op_complement
id|IN_ABORT
suffix:semicolon
id|host_timeout
(braket
id|host
)braket
op_assign
id|oldto
suffix:semicolon
id|update_timeout
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
id|temp
suffix:semicolon
)brace
)brace
)brace
DECL|function|scsi_reset
r_int
id|scsi_reset
(paren
r_int
id|host
)paren
(brace
r_int
id|temp
comma
id|oldto
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|internal_timeout
(braket
id|host
)braket
op_amp
id|IN_RESET
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|internal_timeout
(braket
id|host
)braket
op_amp
id|IN_RESET
)paren
suffix:semicolon
)brace
r_else
(brace
id|oldto
op_assign
id|host_timeout
(braket
id|host
)braket
suffix:semicolon
id|host_timeout
(braket
id|host
)braket
op_assign
id|RESET_TIMEOUT
suffix:semicolon
id|update_timeout
c_func
(paren
)paren
suffix:semicolon
id|internal_timeout
(braket
id|host
)braket
op_or_assign
id|IN_RESET
suffix:semicolon
r_if
c_cond
(paren
id|host_busy
(braket
id|host
)braket
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|last_cmnd
(braket
id|host
)braket
dot
id|flags
op_amp
id|IS_RESETTING
)paren
op_logical_and
op_logical_neg
(paren
id|internal_timeout
(braket
id|host
)braket
op_amp
id|IN_ABORT
)paren
)paren
id|scsi_abort
c_func
(paren
id|host
comma
id|DID_RESET
)paren
suffix:semicolon
id|temp
op_assign
id|scsi_hosts
(braket
id|host
)braket
dot
id|reset
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|host_busy
(braket
id|host
)braket
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|temp
op_assign
id|scsi_hosts
(braket
id|host
)braket
dot
id|reset
c_func
(paren
)paren
suffix:semicolon
id|last_reset
(braket
id|host
)braket
op_assign
id|jiffies
suffix:semicolon
id|host_busy
(braket
id|host
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|host_timeout
(braket
id|host
)braket
op_assign
id|oldto
suffix:semicolon
id|update_timeout
c_func
(paren
)paren
suffix:semicolon
id|internal_timeout
(braket
id|host
)braket
op_and_assign
op_complement
id|IN_RESET
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
id|temp
suffix:semicolon
)brace
)brace
)brace
DECL|function|scsi_main_timeout
r_static
r_void
id|scsi_main_timeout
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t;&t;We must not enter update_timeout with a timeout condition still pending.&n;&t;*/
r_int
id|i
comma
id|timed_out
suffix:semicolon
r_do
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;Find all timers such that they have 0 or negative (shouldn&squot;t happen)&n;&t;&t;time remaining on them.&n;&t;*/
r_for
c_loop
(paren
id|i
op_assign
id|timed_out
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SCSI_HOSTS
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|host_timeout
(braket
id|i
)braket
op_ne
l_int|0
op_logical_and
id|host_timeout
(braket
id|i
)braket
op_le
id|time_elapsed
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|host_timeout
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|scsi_times_out
c_func
(paren
id|i
)paren
suffix:semicolon
op_increment
id|timed_out
suffix:semicolon
)brace
id|update_timeout
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|timed_out
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;These are used to keep track of things. &n;*/
DECL|variable|time_start
DECL|variable|time_elapsed
r_static
r_int
id|time_start
comma
id|time_elapsed
suffix:semicolon
multiline_comment|/*&n;&t;The strategy is to cause the timer code to call scsi_times_out()&n;&t;when the soonest timeout is pending.  &n;*/
DECL|function|update_timeout
r_static
r_void
id|update_timeout
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
comma
id|least
comma
id|used
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t;Figure out how much time has passed since the last time the timeouts &n;   &t;were updated &n;*/
id|used
op_assign
(paren
id|time_start
)paren
ques
c_cond
(paren
id|jiffies
op_minus
id|time_start
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;Find out what is due to timeout soonest, and adjust all timeouts for&n;&t;the amount of time that has passed since the last time we called &n;&t;update_timeout. &n;*/
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|least
op_assign
l_int|0xffffffff
suffix:semicolon
id|i
OL
id|MAX_SCSI_HOSTS
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|host_timeout
(braket
id|i
)braket
OG
l_int|0
op_logical_and
(paren
id|host_timeout
(braket
id|i
)braket
op_sub_assign
id|used
)paren
OL
id|least
)paren
id|least
op_assign
id|host_timeout
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/*&n;&t;If something is due to timeout again, then we will set the next timeout &n;&t;interrupt to occur.  Otherwise, timeouts are disabled.&n;*/
r_if
c_cond
(paren
id|least
op_ne
l_int|0xffffffff
)paren
(brace
id|time_start
op_assign
id|jiffies
suffix:semicolon
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|expires
op_assign
(paren
id|time_elapsed
op_assign
id|least
)paren
op_plus
id|jiffies
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|SCSI_TIMER
suffix:semicolon
)brace
r_else
(brace
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|expires
op_assign
id|time_start
op_assign
id|time_elapsed
op_assign
l_int|0
suffix:semicolon
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|SCSI_TIMER
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;scsi_dev_init() is our initialization routine, which inturn calls host &n;&t;initialization, bus scanning, and sd/st initialization routines.  It &n;&t;should be called from main().&n;*/
DECL|variable|generic_sense
r_static
r_int
r_char
id|generic_sense
(braket
l_int|6
)braket
op_assign
(brace
id|REQUEST_SENSE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|255
comma
l_int|0
)brace
suffix:semicolon
DECL|function|scsi_dev_init
r_int
r_int
id|scsi_dev_init
(paren
r_int
r_int
id|memory_start
comma
r_int
r_int
id|memory_end
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#ifdef FOO_ON_YOU
r_return
suffix:semicolon
macro_line|#endif&t;
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|fn
op_assign
id|scsi_main_timeout
suffix:semicolon
id|timer_table
(braket
id|SCSI_TIMER
)braket
dot
id|expires
op_assign
l_int|0
suffix:semicolon
id|scsi_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* initialize all hosts */
multiline_comment|/*&n; *&t;Set up sense command in each host structure.&n; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_SCSI_HOSTS
suffix:semicolon
op_increment
id|i
)paren
(brace
id|memcpy
(paren
(paren
r_void
op_star
)paren
id|last_cmnd
(braket
id|i
)braket
dot
id|sense_cmnd
comma
(paren
r_void
op_star
)paren
id|generic_sense
comma
l_int|6
)paren
suffix:semicolon
id|last_reset
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|scan_scsis
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* scan for scsi devices */
macro_line|#ifdef CONFIG_BLK_DEV_SD
id|memory_start
op_assign
id|sd_init
c_func
(paren
id|memory_start
comma
id|memory_end
)paren
suffix:semicolon
multiline_comment|/* init scsi disks */
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_ST
id|memory_start
op_assign
id|st_init
c_func
(paren
id|memory_start
comma
id|memory_end
)paren
suffix:semicolon
multiline_comment|/* init scsi tapes */
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_SR
id|memory_start
op_assign
id|sr_init
c_func
(paren
id|memory_start
comma
id|memory_end
)paren
suffix:semicolon
macro_line|#endif
r_return
id|memory_start
suffix:semicolon
)brace
macro_line|#endif
DECL|function|print_inquiry
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|data
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Vendor:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
OL
l_int|15
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|20
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  Model:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OL
l_int|31
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|20
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  Rev:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|32
suffix:semicolon
id|i
OL
l_int|35
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|20
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Type: %s &quot;
comma
id|i
op_eq
l_int|0x00
ques
c_cond
l_string|&quot;Direct-Access    &quot;
suffix:colon
id|i
op_eq
l_int|0x01
ques
c_cond
l_string|&quot;Sequential-Access&quot;
suffix:colon
id|i
op_eq
l_int|0x02
ques
c_cond
l_string|&quot;Printer          &quot;
suffix:colon
id|i
op_eq
l_int|0x03
ques
c_cond
l_string|&quot;Processor        &quot;
suffix:colon
id|i
op_eq
l_int|0x04
ques
c_cond
l_string|&quot;WORM             &quot;
suffix:colon
id|i
op_eq
l_int|0x05
ques
c_cond
l_string|&quot;CD-ROM           &quot;
suffix:colon
id|i
op_eq
l_int|0x06
ques
c_cond
l_string|&quot;Scanner          &quot;
suffix:colon
id|i
op_eq
l_int|0x07
ques
c_cond
l_string|&quot;Optical Device   &quot;
suffix:colon
id|i
op_eq
l_int|0x08
ques
c_cond
l_string|&quot;Medium Changer   &quot;
suffix:colon
id|i
op_eq
l_int|0x09
ques
c_cond
l_string|&quot;Communications   &quot;
suffix:colon
l_string|&quot;Unknown          &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ANSI SCSI revision: %02x&bslash;n&quot;
comma
id|data
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
)brace
eof
