multiline_comment|/*&n; *&t;sd.c Copyright (C) 1992 Drew Eckhardt&n; *&t;Linux scsi disk driver by&n; *&t;&t;Drew Eckhardt&n; *&n; *&t;&lt;drew@colorado.edu&gt;&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef CONFIG_BLK_DEV_SD
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;sd.h&quot;
macro_line|#include &quot;scsi_ioctl.h&quot;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR 8
macro_line|#include &quot;../blk.h&quot;
macro_line|#include &lt;linux/genhd.h&gt;
multiline_comment|/*&n;static const char RCSid[] = &quot;$Header:&quot;;&n;*/
DECL|macro|MAX_RETRIES
mdefine_line|#define MAX_RETRIES 5
multiline_comment|/*&n; *&t;Time out in seconds&n; */
DECL|macro|SD_TIMEOUT
mdefine_line|#define SD_TIMEOUT 200
DECL|variable|sd
r_struct
id|hd_struct
id|sd
(braket
id|MAX_SD
op_lshift
l_int|4
)braket
suffix:semicolon
DECL|variable|NR_SD
r_int
id|NR_SD
op_assign
l_int|0
suffix:semicolon
DECL|variable|rscsi_disks
id|Scsi_Disk
id|rscsi_disks
(braket
id|MAX_SD
)braket
suffix:semicolon
DECL|variable|sd_sizes
r_static
r_int
id|sd_sizes
(braket
id|MAX_SD
op_lshift
l_int|4
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|this_count
DECL|variable|total_count
r_static
r_int
id|this_count
comma
id|total_count
op_assign
l_int|0
suffix:semicolon
DECL|variable|the_result
r_static
r_int
id|the_result
suffix:semicolon
DECL|variable|boot_init_done
r_static
r_int
id|boot_init_done
op_assign
l_int|0
suffix:semicolon
DECL|variable|sense_buffer
r_static
r_char
id|sense_buffer
(braket
l_int|255
)braket
suffix:semicolon
DECL|variable|slow_scsi_io
r_int
id|slow_scsi_io
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* This is set by aha1542.c, and others, if needed */
multiline_comment|/* used to re-read partitions. */
r_extern
r_void
id|resetup_one_dev
c_func
(paren
r_struct
id|gendisk
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_int
id|sd_ioctl
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
id|sd_init_onedisk
c_func
(paren
r_int
)paren
suffix:semicolon
DECL|function|sd_open
r_static
r_int
id|sd_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|target
suffix:semicolon
id|target
op_assign
id|DEVICE_NR
c_func
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
suffix:semicolon
multiline_comment|/* Make sure that only one process can do a check_change_disk at one time.&n; This is also used to lock out further access when the partition table is being re-read. */
r_while
c_loop
(paren
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;busy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;removable
)paren
(brace
r_if
c_cond
(paren
id|filp-&gt;f_mode
)paren
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;access_count
)paren
(brace
id|sd_ioctl
c_func
(paren
id|inode
comma
l_int|NULL
comma
id|SCSI_IOCTL_DOORLOCK
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
suffix:semicolon
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;access_count
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sd_release
r_static
r_void
id|sd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|target
suffix:semicolon
id|sync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|target
op_assign
id|DEVICE_NR
c_func
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
suffix:semicolon
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;access_count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;removable
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;access_count
)paren
(brace
id|sd_ioctl
c_func
(paren
id|inode
comma
l_int|NULL
comma
id|SCSI_IOCTL_DOORUNLOCK
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
suffix:semicolon
)brace
DECL|variable|sd_gendisk
r_static
r_struct
id|gendisk
id|sd_gendisk
suffix:semicolon
DECL|function|sd_geninit
r_static
r_void
id|sd_geninit
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_SD
suffix:semicolon
op_increment
id|i
)paren
id|sd
(braket
id|i
op_lshift
l_int|4
)braket
dot
id|nr_sects
op_assign
id|rscsi_disks
(braket
id|i
)braket
dot
id|capacity
suffix:semicolon
id|sd_gendisk.nr_real
op_assign
id|NR_SD
suffix:semicolon
)brace
DECL|variable|sd_fops
r_static
r_struct
id|file_operations
id|sd_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|sd_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|sd_open
comma
multiline_comment|/* open code */
id|sd_release
multiline_comment|/* release */
)brace
suffix:semicolon
DECL|variable|sd_gendisk
r_static
r_struct
id|gendisk
id|sd_gendisk
op_assign
(brace
id|MAJOR_NR
comma
multiline_comment|/* Major number */
l_string|&quot;sd&quot;
comma
multiline_comment|/* Major name */
l_int|4
comma
multiline_comment|/* Bits to shift to get real from partition */
l_int|1
op_lshift
l_int|4
comma
multiline_comment|/* Number of partitions per real */
id|MAX_SD
comma
multiline_comment|/* maximum number of real */
id|sd_geninit
comma
multiline_comment|/* init function */
id|sd
comma
multiline_comment|/* hd struct */
id|sd_sizes
comma
multiline_comment|/* block sizes */
l_int|0
comma
multiline_comment|/* number */
(paren
r_void
op_star
)paren
id|rscsi_disks
comma
multiline_comment|/* internal */
l_int|NULL
multiline_comment|/* next */
)brace
suffix:semicolon
multiline_comment|/*&n;&t;rw_intr is the interrupt routine for the device driver.  It will&n;&t;be notified on the end of a SCSI read / write, and&n;&t;will take on of several actions based on success or failure.&n;*/
DECL|function|rw_intr
r_static
r_void
id|rw_intr
(paren
r_int
id|host
comma
r_int
id|result
)paren
(brace
r_if
c_cond
(paren
id|HOST
op_ne
id|host
)paren
id|panic
(paren
l_string|&quot;sd.o : rw_intr() recieving interrupt for different host.&quot;
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sd%d : rw_intr(%d, %x)&bslash;n&quot;
comma
id|MINOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
comma
id|host
comma
id|result
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;First case : we assume that the command succeeded.  One of two things will&n;&t;happen here.  Either we will be finished, or there will be more&n;&t;sectors that we were unable to read last time.&n;*/
r_if
c_cond
(paren
op_logical_neg
id|result
)paren
(brace
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|this_count
suffix:semicolon
r_if
c_cond
(paren
id|slow_scsi_io
op_eq
id|host
)paren
(brace
id|total_count
op_sub_assign
id|this_count
suffix:semicolon
r_if
c_cond
(paren
id|total_count
)paren
(brace
id|CURRENT-&gt;sector
op_add_assign
id|this_count
suffix:semicolon
id|CURRENT-&gt;buffer
op_add_assign
(paren
id|this_count
op_lshift
l_int|9
)paren
suffix:semicolon
id|do_sd_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sd%d : %d sectors remain.&bslash;n&quot;
comma
id|MINOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
comma
id|CURRENT-&gt;nr_sectors
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * &t;If multiple sectors are requested in one buffer, then&n; *&t;they will have been finished off by the first command.  If&n; *&t;not, then we have a multi-buffer command.&n; */
r_if
c_cond
(paren
id|CURRENT-&gt;nr_sectors
)paren
(brace
id|CURRENT-&gt;sector
op_add_assign
id|this_count
suffix:semicolon
id|CURRENT-&gt;errors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CURRENT-&gt;bh
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sd%d : handling page request, no buffer&bslash;n&quot;
comma
id|MINOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;The CURRENT-&gt;nr_sectors field is always done in 512 byte sectors,&n;&t;even if this really isn&squot;t the case.&n;*/
(paren
r_char
op_star
)paren
id|CURRENT-&gt;buffer
op_add_assign
id|this_count
op_lshift
l_int|9
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sd%d :  handling linked buffer request&bslash;n&quot;
comma
id|MINOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
)paren
suffix:semicolon
macro_line|#endif
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|do_sd_request
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Of course, the error handling code is a little Fubar down in scsi.c.&n; *&t;Version 2 of the drivers will fix that, and we will *really* recover&n; *&t;from errors.&n; */
multiline_comment|/*&n;&t;Now, if we were good little boys and girls, Santa left us a request&n;&t;sense buffer.  We can extract information from this, so we&n;&t;can choose a block to remap, etc.&n;*/
r_else
r_if
c_cond
(paren
id|driver_byte
c_func
(paren
id|result
)paren
op_amp
id|DRIVER_SENSE
)paren
(brace
r_if
c_cond
(paren
id|sugestion
c_func
(paren
id|result
)paren
op_eq
id|SUGGEST_REMAP
)paren
(brace
macro_line|#ifdef REMAP
multiline_comment|/*&n;&t;Not yet implemented.  A read will fail after being remapped,&n;&t;a write will call the strategy routine again.&n;*/
r_else
r_if
c_cond
(paren
(paren
id|sense_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x7f
)paren
op_eq
l_int|0x70
)paren
(brace
r_if
c_cond
(paren
(paren
id|sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_eq
id|UNIT_ATTENTION
)paren
(brace
multiline_comment|/* detected disc change.  set a bit and quietly refuse&t;*/
multiline_comment|/* further access.&t;&t;&t;&t;&t;*/
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|CURRENT-&gt;dev
)paren
)braket
dot
id|device-&gt;changed
op_assign
l_int|1
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|do_sd_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|CURRENT-&gt;dev
)paren
)braket
dot
id|remap
(brace
id|result
op_assign
l_int|0
suffix:semicolon
)brace
r_else
macro_line|#endif
)brace
multiline_comment|/*&n;&t;If we had an ILLEGAL REQUEST returned, then we may have performed&n;&t;an unsupported command.  The only thing this should be would be a  ten&n;&t;byte read where only a six byte read was supportted.  Also, on a&n;&t;system where READ CAPACITY failed, we mave have read past the end of the&n;&t;disk.&n;*/
r_else
r_if
c_cond
(paren
id|sense_buffer
(braket
l_int|7
)braket
op_eq
id|ILLEGAL_REQUEST
)paren
(brace
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|CURRENT-&gt;dev
)paren
)braket
dot
id|ten
)paren
(brace
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|CURRENT-&gt;dev
)paren
)braket
dot
id|ten
op_assign
l_int|0
suffix:semicolon
id|do_sd_request
c_func
(paren
)paren
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|result
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI disk error : host %d id %d lun %d return code = %x&bslash;n&quot;
comma
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|CURRENT-&gt;dev
)paren
)braket
dot
id|device-&gt;host_no
comma
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|CURRENT-&gt;dev
)paren
)braket
dot
id|device-&gt;id
comma
id|rscsi_disks
(braket
id|DEVICE_NR
c_func
(paren
id|CURRENT-&gt;dev
)paren
)braket
dot
id|device-&gt;lun
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver_byte
c_func
(paren
id|result
)paren
op_amp
id|DRIVER_SENSE
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;tSense class %x, sense error %x, extended sense %x&bslash;n&quot;
comma
id|sense_class
c_func
(paren
id|sense_buffer
(braket
l_int|0
)braket
)paren
comma
id|sense_error
c_func
(paren
id|sense_buffer
(braket
l_int|0
)braket
)paren
comma
id|sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|do_sd_request
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;do_sd_request() is the request handler function for the sd driver.&n;&t;Its function in life is to take block device requests, and translate&n;&t;them to SCSI commands.&n;*/
DECL|function|do_sd_request
r_static
r_void
id|do_sd_request
(paren
r_void
)paren
(brace
r_int
id|dev
comma
id|block
suffix:semicolon
r_int
r_char
id|cmd
(braket
l_int|10
)braket
suffix:semicolon
id|repeat
suffix:colon
id|INIT_REQUEST
suffix:semicolon
id|dev
op_assign
id|MINOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
suffix:semicolon
id|block
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Doing sd request, dev = %d, block = %d&bslash;n&quot;
comma
id|dev
comma
id|block
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|dev
op_ge
(paren
id|NR_SD
op_lshift
l_int|4
)paren
op_logical_or
id|block
op_plus
id|CURRENT-&gt;nr_sectors
OG
id|sd
(braket
id|dev
)braket
dot
id|nr_sects
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|block
op_add_assign
id|sd
(braket
id|dev
)braket
dot
id|start_sect
suffix:semicolon
id|dev
op_assign
id|DEVICE_NR
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|dev
)braket
dot
id|device-&gt;changed
)paren
(brace
multiline_comment|/*&n; * quietly refuse to do anything to a changed disc until the changed bit has been reset&n; */
multiline_comment|/* printk(&quot;SCSI disk has been changed.  Prohibiting further I/O.&bslash;n&quot;);&t;*/
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sd%d : real dev = /dev/sd%d, block = %d&bslash;n&quot;
comma
id|MINOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
comma
id|dev
comma
id|block
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|CURRENT-&gt;bh
)paren
id|this_count
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
r_else
id|this_count
op_assign
(paren
id|BLOCK_SIZE
op_div
l_int|512
)paren
suffix:semicolon
multiline_comment|/* This is a temporary hack for the AHA1742. */
r_if
c_cond
(paren
id|slow_scsi_io
op_eq
id|HOST
)paren
(brace
r_if
c_cond
(paren
id|total_count
op_eq
l_int|0
)paren
(brace
id|total_count
op_assign
id|this_count
suffix:semicolon
)brace
id|this_count
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Take only 512 bytes at a time */
)brace
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sd%d : %s %d/%d 512 byte blocks.&bslash;n&quot;
comma
id|MINOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
comma
(paren
id|CURRENT-&gt;cmd
op_eq
id|WRITE
)paren
ques
c_cond
l_string|&quot;writing&quot;
suffix:colon
l_string|&quot;reading&quot;
comma
id|this_count
comma
id|CURRENT-&gt;nr_sectors
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|CURRENT-&gt;cmd
)paren
(brace
r_case
id|WRITE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|rscsi_disks
(braket
id|dev
)braket
dot
id|device-&gt;writeable
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|cmd
(braket
l_int|0
)braket
op_assign
id|WRITE_6
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ
suffix:colon
id|cmd
(braket
l_int|0
)braket
op_assign
id|READ_6
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Unknown sd command %d&bslash;r&bslash;n&quot;
comma
id|CURRENT-&gt;cmd
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
id|cmd
(braket
l_int|1
)braket
op_assign
(paren
id|LUN
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|this_count
OG
l_int|0xff
)paren
op_logical_or
(paren
id|block
OG
l_int|0x1fffff
)paren
)paren
op_logical_and
id|rscsi_disks
(braket
id|dev
)braket
dot
id|ten
)paren
(brace
r_if
c_cond
(paren
id|this_count
OG
l_int|0xffff
)paren
id|this_count
op_assign
l_int|0xffff
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_add_assign
id|READ_10
op_minus
id|READ_6
suffix:semicolon
id|cmd
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|block
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|3
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|block
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|4
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|block
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|5
)braket
op_assign
(paren
r_int
r_char
)paren
id|block
op_amp
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|6
)braket
op_assign
id|cmd
(braket
l_int|9
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd
(braket
l_int|7
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|this_count
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|8
)braket
op_assign
(paren
r_int
r_char
)paren
id|this_count
op_amp
l_int|0xff
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|this_count
OG
l_int|0xff
)paren
id|this_count
op_assign
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_or_assign
(paren
r_int
r_char
)paren
(paren
(paren
id|block
op_rshift
l_int|16
)paren
op_amp
l_int|0x1f
)paren
suffix:semicolon
id|cmd
(braket
l_int|2
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
id|block
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|cmd
(braket
l_int|3
)braket
op_assign
(paren
r_int
r_char
)paren
id|block
op_amp
l_int|0xff
suffix:semicolon
id|cmd
(braket
l_int|4
)braket
op_assign
(paren
r_int
r_char
)paren
id|this_count
suffix:semicolon
id|cmd
(braket
l_int|5
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|scsi_do_cmd
(paren
id|HOST
comma
id|ID
comma
(paren
r_void
op_star
)paren
id|cmd
comma
id|CURRENT-&gt;buffer
comma
id|this_count
op_lshift
l_int|9
comma
id|rw_intr
comma
id|SD_TIMEOUT
comma
id|sense_buffer
comma
id|MAX_RETRIES
)paren
suffix:semicolon
)brace
DECL|function|check_scsidisk_media_change
r_int
(def_block
id|check_scsidisk_media_change
c_func
(paren
r_int
id|full_dev
comma
r_int
id|flag
)paren
(brace
r_int
id|retval
suffix:semicolon
r_int
id|target
suffix:semicolon
r_struct
id|inode
id|inode
suffix:semicolon
id|target
op_assign
id|DEVICE_NR
c_func
(paren
id|MINOR
c_func
(paren
id|full_dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
op_ge
id|NR_SD
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI disk request error: invalid device.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;removable
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|inode.i_rdev
op_assign
id|full_dev
suffix:semicolon
multiline_comment|/* This is all we really need here */
id|retval
op_assign
id|sd_ioctl
c_func
(paren
op_amp
id|inode
comma
l_int|NULL
comma
id|SCSI_IOCTL_TEST_UNIT_READY
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
multiline_comment|/* Unable to test, unit probably not ready.  This usually&n;&t;&t;     means there is no disc in the drive.  Mark as changed,&n;&t;&t;     and we will figure it out later once the drive is&n;&t;&t;     available again.  */
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;changed
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* This will force a flush, if called from&n;&t;&t;       check_disk_change */
)brace
suffix:semicolon
id|retval
op_assign
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;changed
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
id|rscsi_disks
(braket
id|target
)braket
dot
id|device-&gt;changed
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
)def_block
DECL|function|sd_init_done
r_static
r_void
id|sd_init_done
(paren
r_int
id|host
comma
r_int
id|result
)paren
(brace
id|the_result
op_assign
id|result
suffix:semicolon
)brace
DECL|function|sd_init_onedisk
r_static
r_int
id|sd_init_onedisk
c_func
(paren
r_int
id|i
)paren
(brace
r_int
id|j
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|cmd
(braket
l_int|10
)braket
suffix:semicolon
r_int
r_char
id|buffer
(braket
l_int|513
)braket
suffix:semicolon
r_int
id|try_again
suffix:semicolon
id|try_again
op_assign
l_int|2
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
id|READ_CAPACITY
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
(paren
id|rscsi_disks
(braket
id|i
)braket
dot
id|device-&gt;lun
op_lshift
l_int|5
)paren
op_amp
l_int|0xe0
suffix:semicolon
id|memset
(paren
(paren
r_void
op_star
)paren
op_amp
id|cmd
(braket
l_int|2
)braket
comma
l_int|0
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/*&n;   *&t;Super Kludge - since the midlevel error handling code doesn&squot;t work&n;   *&t;Version 2 will - it&squot;s under development 8^)&n;   *&n;   *&t;We manually retry&n;   */
r_do
(brace
id|the_result
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;sd%d : READ CAPACITY&bslash;n &quot;
comma
id|i
)paren
suffix:semicolon
macro_line|#endif
id|scsi_do_cmd
(paren
id|rscsi_disks
(braket
id|i
)braket
dot
id|device-&gt;host_no
comma
id|rscsi_disks
(braket
id|i
)braket
dot
id|device-&gt;id
comma
(paren
r_void
op_star
)paren
id|cmd
comma
(paren
r_void
op_star
)paren
id|buffer
comma
l_int|512
comma
id|sd_init_done
comma
id|SD_TIMEOUT
comma
id|sense_buffer
comma
id|MAX_RETRIES
)paren
suffix:semicolon
r_while
c_loop
(paren
id|the_result
OL
l_int|0
)paren
(brace
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|try_again
op_logical_and
id|the_result
)paren
suffix:semicolon
multiline_comment|/*&n;   *&t;The SCSI standard says &quot;READ CAPACITY is necessary for self confuring software&quot;&n;   *&t;While not mandatory, support of READ CAPACITY is strongly encouraged.&n;   *&t;We used to die if we couldn&squot;t successfully do a READ CAPACITY.&n;   *&t;But, now we go on about our way.  The side effects of this are&n;   *&n;   *&t;1.  We can&squot;t know block size with certainty.  I have said &quot;512 bytes is it&quot;&n;   *&t;   &t;as this is most common.&n;   *&n;   *&t;2.  Recovery from when some one attempts to read past the end of the raw device will&n;   *&t;    be slower.&n;   */
r_if
c_cond
(paren
id|the_result
)paren
(brace
id|printk
(paren
l_string|&quot;sd%d : READ CAPACITY failed.&bslash;n&quot;
l_string|&quot;sd%d : status = %x, message = %02x, host = %02x, driver = %02x &bslash;n&quot;
comma
id|i
comma
id|i
comma
id|rscsi_disks
(braket
id|i
)braket
dot
id|device-&gt;host_no
comma
id|rscsi_disks
(braket
id|i
)braket
dot
id|device-&gt;id
comma
id|rscsi_disks
(braket
id|i
)braket
dot
id|device-&gt;lun
comma
id|status_byte
c_func
(paren
id|the_result
)paren
comma
id|msg_byte
c_func
(paren
id|the_result
)paren
comma
id|host_byte
c_func
(paren
id|the_result
)paren
comma
id|driver_byte
c_func
(paren
id|the_result
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver_byte
c_func
(paren
id|the_result
)paren
op_amp
id|DRIVER_SENSE
)paren
id|printk
c_func
(paren
l_string|&quot;sd%d : extended sense code = %1x &bslash;n&quot;
comma
id|i
comma
id|sense_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;sd%d : sense not available. &bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sd%d : block size assumed to be 512 bytes, disk size 1GB.  &bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|rscsi_disks
(braket
id|i
)braket
dot
id|capacity
op_assign
l_int|0x1fffff
suffix:semicolon
id|rscsi_disks
(braket
id|i
)braket
dot
id|sector_size
op_assign
l_int|512
suffix:semicolon
)brace
r_else
(brace
id|rscsi_disks
(braket
id|i
)braket
dot
id|capacity
op_assign
(paren
id|buffer
(braket
l_int|0
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|buffer
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|buffer
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
id|buffer
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rscsi_disks
(braket
id|i
)braket
dot
id|sector_size
op_assign
(paren
id|buffer
(braket
l_int|4
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|buffer
(braket
l_int|5
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|buffer
(braket
l_int|6
)braket
op_lshift
l_int|8
)paren
op_or
id|buffer
(braket
l_int|7
)braket
)paren
op_ne
l_int|512
)paren
(brace
id|printk
(paren
l_string|&quot;sd%d : unsupported sector size %d.&bslash;n&quot;
comma
id|i
comma
id|rscsi_disks
(braket
id|i
)braket
dot
id|sector_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rscsi_disks
(braket
id|j
)braket
dot
id|device-&gt;removable
)paren
(brace
id|rscsi_disks
(braket
id|j
)braket
dot
id|capacity
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;scsi : deleting disk entry.&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
suffix:semicolon
id|j
OL
id|NR_SD
suffix:semicolon
)paren
id|rscsi_disks
(braket
id|j
)braket
op_assign
id|rscsi_disks
(braket
op_increment
id|j
)braket
suffix:semicolon
op_decrement
id|i
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
suffix:semicolon
)brace
)brace
id|rscsi_disks
(braket
id|i
)braket
dot
id|ten
op_assign
l_int|1
suffix:semicolon
id|rscsi_disks
(braket
id|i
)braket
dot
id|remap
op_assign
l_int|1
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n;&t;The sd_init() function looks at all SCSI drives present, determines&n;&t;their size, and reads partition&t;table entries for them.&n;*/
DECL|function|sd_init
r_void
id|sd_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_SD
suffix:semicolon
op_increment
id|i
)paren
id|i
op_assign
id|sd_init_onedisk
c_func
(paren
id|i
)paren
suffix:semicolon
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|blkdev_fops
(braket
id|MAJOR_NR
)braket
op_assign
op_amp
id|sd_fops
suffix:semicolon
id|sd_gendisk.next
op_assign
id|gendisk_head
suffix:semicolon
id|gendisk_head
op_assign
op_amp
id|sd_gendisk
suffix:semicolon
id|boot_init_done
op_increment
suffix:semicolon
)brace
DECL|macro|DEVICE_BUSY
mdefine_line|#define DEVICE_BUSY rscsi_disks[target].device-&gt;busy
DECL|macro|USAGE
mdefine_line|#define USAGE rscsi_disks[target].device-&gt;access_count
DECL|macro|CAPACITY
mdefine_line|#define CAPACITY rscsi_disks[target].capacity
DECL|macro|MAYBE_REINIT
mdefine_line|#define MAYBE_REINIT  sd_init_onedisk(target)
DECL|macro|GENDISK_STRUCT
mdefine_line|#define GENDISK_STRUCT sd_gendisk
multiline_comment|/* This routine is called to flush all partitions and partition tables&n;   for a changed scsi disk, and then re-read the new partition table.&n;   If we are revalidating a disk because of a media change, then we&n;   enter with usage == 0.  If we are using an ioctl, we automatically have&n;   usage == 1 (we need an open channel to use an ioctl :-), so this&n;   is our limit.&n; */
DECL|function|revalidate_scsidisk
r_int
(def_block
id|revalidate_scsidisk
c_func
(paren
r_int
id|dev
comma
r_int
id|maxusage
)paren
(brace
r_int
id|target
comma
id|major
suffix:semicolon
r_struct
id|gendisk
op_star
id|gdev
suffix:semicolon
r_int
id|max_p
suffix:semicolon
r_int
id|start
suffix:semicolon
r_int
id|i
suffix:semicolon
id|target
op_assign
id|DEVICE_NR
c_func
(paren
id|MINOR
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
id|gdev
op_assign
op_amp
id|GENDISK_STRUCT
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEVICE_BUSY
op_logical_or
id|USAGE
OG
id|maxusage
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
suffix:semicolon
id|DEVICE_BUSY
op_assign
l_int|1
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|max_p
op_assign
id|gdev-&gt;max_p
suffix:semicolon
id|start
op_assign
id|target
op_lshift
id|gdev-&gt;minor_shift
suffix:semicolon
id|major
op_assign
id|MAJOR_NR
op_lshift
l_int|8
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|max_p
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|sync_dev
c_func
(paren
id|major
op_or
id|start
op_or
id|i
)paren
suffix:semicolon
id|invalidate_inodes
c_func
(paren
id|major
op_or
id|start
op_or
id|i
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|major
op_or
id|start
op_or
id|i
)paren
suffix:semicolon
id|gdev-&gt;part
(braket
id|i
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|gdev-&gt;part
(braket
id|i
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifdef MAYBE_REINIT
id|MAYBE_REINIT
suffix:semicolon
macro_line|#endif
id|gdev-&gt;part
(braket
id|start
)braket
dot
id|nr_sects
op_assign
id|CAPACITY
suffix:semicolon
id|resetup_one_dev
c_func
(paren
id|gdev
comma
id|target
)paren
suffix:semicolon
id|DEVICE_BUSY
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)def_block
macro_line|#endif
eof
