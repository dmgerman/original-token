multiline_comment|/* fdomain.c -- Future Domain TMC-1660/TMC-1680 driver&n; * Created: Sun May  3 18:53:19 1992&n; * Revised: Tue Jul 28 19:45:25 1992 by root&n; * Author: Rickard E. Faith, faith@cs.unc.edu&n; * Copyright 1992 Rickard E. Faith&n; *&n; * $Log$&n;&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n;&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n;&n; * WARNING: THIS IS A BETA VERSION!&n; *          USE AT YOUR OWN RISK!&n; *          BACKUP YOUR SYSTEM BEFORE USING!&n;&n; * I would like to thank Maxtor, whose *free* 206 page manual on the LXT&n; * drives was very helpful: &quot;LXT SCSI Products: Specifications and OEM&n; * Technical Manual (Revision B/September 1991)&quot;&n;&n; * I wish that I could thank Future Domain for the necessary documentation,&n; * but I can&squot;t.  I used the $25 &quot;TMC-1800 SCSI Chip Specification&quot; document&n; * (FDC-1800T), which documents the *chip* and not the board.  Without it,&n; * I would have been totally lost, but it would have been nice to have some&n; * example source.  (The DOS BIOS source cost $250 and the UN*X driver&n; * source was $750 [both required a non-disclosure agreement].  Ever wonder&n; * why there are no freely available Future Domain drivers?)&n;&n; * Thanks to Todd Carrico (todd@wutc.wustl.edu), Dan Poirier&n; * (poirier@cs.unc.edu ), Ken Corey (kenc@sol.acs.unt.edu), and C. de Bruin&n; * (bruin@dutiba.tudelft.nl) for alpha testing.  Also thanks to Drew&n; * Eckhardt (drew@cs.colorado.edu) for answering questions. */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef CONFIG_SCSI_FUTURE_DOMAIN
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;fdomain.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#if QUEUE
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#endif
DECL|macro|VERSION
mdefine_line|#define VERSION          &quot;1.9&quot;&t;/* Change with each revision */
DECL|macro|DEBUG
mdefine_line|#define DEBUG            1&t;/* Enable debugging output */
DECL|macro|SEND_IDENTIFY
mdefine_line|#define SEND_IDENTIFY    0&t;/* Send IDENTIFY message -- DOESN&squot;T WORK! */
DECL|macro|USE_FIFO
mdefine_line|#define USE_FIFO         1&t;/* Use the FIFO buffer for I/O */
DECL|macro|FAST_SYNCH
mdefine_line|#define FAST_SYNCH       1&t;/* Enable Fast Synchronous */
DECL|macro|ALLOW_ALL_IRQ
mdefine_line|#define ALLOW_ALL_IRQ    0&t;/* Allow all IRQ&squot;s -- NOT RECOMMENDED */
DECL|macro|NEW_IRQ
mdefine_line|#define NEW_IRQ          1&t;/* Enable new IRQ handling */
DECL|macro|DECREASE_IL
mdefine_line|#define DECREASE_IL      1&t;/* Try to decrease interrupt latency */
macro_line|#if DEBUG
DECL|macro|EVERY_ACCESS
mdefine_line|#define EVERY_ACCESS     0&t;/* Write a line on every scsi access */
DECL|macro|ERRORS_ONLY
mdefine_line|#define ERRORS_ONLY      1&t;/* Only write a line if there is an error */
DECL|macro|DEBUG_DETECT
mdefine_line|#define DEBUG_DETECT     0&t;/* Debug fdomain_16x0_detect() */
macro_line|#else
DECL|macro|EVERY_ACCESS
mdefine_line|#define EVERY_ACCESS     0&t;/* LEAVE THESE ALONE--CHANGE THE ONES ABOVE */
DECL|macro|ERRORS_ONLY
mdefine_line|#define ERRORS_ONLY      0
DECL|macro|DEBUG_DETECT
mdefine_line|#define DEBUG_DETECT     0
macro_line|#endif
multiline_comment|/* Errors are reported on the line, so we don&squot;t need to report them again */
macro_line|#if EVERY_ACCESS
DECL|macro|ERRORS_ONLY
macro_line|#undef ERRORS_ONLY
DECL|macro|ERRORS_ONLY
mdefine_line|#define ERRORS_ONLY      0
macro_line|#endif
DECL|variable|port_base
r_static
r_int
id|port_base
op_assign
l_int|0
suffix:semicolon
DECL|variable|bios_base
r_static
r_void
op_star
id|bios_base
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|interrupt_level
r_static
r_int
id|interrupt_level
op_assign
l_int|0
suffix:semicolon
DECL|variable|aborted
r_static
r_volatile
r_int
id|aborted
op_assign
l_int|0
suffix:semicolon
DECL|variable|Data_Mode_Cntl_port
r_static
r_int
id|Data_Mode_Cntl_port
suffix:semicolon
DECL|variable|FIFO_Data_Count_port
r_static
r_int
id|FIFO_Data_Count_port
suffix:semicolon
DECL|variable|Interrupt_Cntl_port
r_static
r_int
id|Interrupt_Cntl_port
suffix:semicolon
DECL|variable|Read_FIFO_port
r_static
r_int
id|Read_FIFO_port
suffix:semicolon
DECL|variable|Read_SCSI_Data_port
r_static
r_int
id|Read_SCSI_Data_port
suffix:semicolon
DECL|variable|SCSI_Cntl_port
r_static
r_int
id|SCSI_Cntl_port
suffix:semicolon
DECL|variable|SCSI_Status_port
r_static
r_int
id|SCSI_Status_port
suffix:semicolon
DECL|variable|TMC_Cntl_port
r_static
r_int
id|TMC_Cntl_port
suffix:semicolon
DECL|variable|TMC_Status_port
r_static
r_int
id|TMC_Status_port
suffix:semicolon
DECL|variable|Write_FIFO_port
r_static
r_int
id|Write_FIFO_port
suffix:semicolon
DECL|variable|Write_SCSI_Data_port
r_static
r_int
id|Write_SCSI_Data_port
suffix:semicolon
macro_line|#if QUEUE
DECL|variable|current_target
r_static
r_int
r_char
id|current_target
op_assign
l_int|0
suffix:semicolon
DECL|variable|current_cmnd
r_static
r_int
r_char
id|current_cmnd
(braket
l_int|10
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|current_buff
r_static
r_void
op_star
id|current_buff
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|current_bufflen
r_static
r_int
id|current_bufflen
op_assign
l_int|0
suffix:semicolon
DECL|variable|current_done
r_static
r_void
(paren
op_star
id|current_done
)paren
(paren
r_int
comma
r_int
)paren
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|in_command
r_volatile
r_static
r_int
id|in_command
op_assign
l_int|0
suffix:semicolon
DECL|variable|current_phase
r_volatile
r_static
r_int
id|current_phase
suffix:semicolon
DECL|variable|this_host
r_static
r_int
id|this_host
op_assign
l_int|0
suffix:semicolon
DECL|enumerator|in_arbitration
DECL|enumerator|in_selection
DECL|enumerator|in_other
r_enum
(brace
id|in_arbitration
comma
id|in_selection
comma
id|in_other
)brace
suffix:semicolon
macro_line|#if NEW_IRQ
r_extern
r_void
id|fdomain_16x0_intr
c_func
(paren
r_int
id|unused
)paren
suffix:semicolon
macro_line|#else
r_extern
r_void
id|fdomain_16x0_interrupt
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|cmd_pt
r_static
r_const
r_char
op_star
id|cmd_pt
suffix:semicolon
DECL|variable|the_command
r_static
r_const
r_char
op_star
id|the_command
suffix:semicolon
DECL|variable|out_buf_pt
r_static
r_int
r_char
op_star
id|out_buf_pt
suffix:semicolon
DECL|variable|in_buf_pt
r_static
r_int
r_char
op_star
id|in_buf_pt
suffix:semicolon
DECL|variable|Status
r_volatile
r_static
r_int
id|Status
suffix:semicolon
DECL|variable|Message
r_volatile
r_static
r_int
id|Message
suffix:semicolon
DECL|variable|data_sent
r_volatile
r_static
r_int
id|data_sent
suffix:semicolon
DECL|variable|have_data_in
r_volatile
r_static
r_int
id|have_data_in
suffix:semicolon
DECL|variable|in_interrupt_code
r_volatile
r_static
r_int
id|in_interrupt_code
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|enum|in_port_type
DECL|enumerator|Read_SCSI_Data
DECL|enumerator|SCSI_Status
DECL|enumerator|TMC_Status
r_enum
id|in_port_type
(brace
id|Read_SCSI_Data
op_assign
l_int|0
comma
id|SCSI_Status
op_assign
l_int|1
comma
id|TMC_Status
op_assign
l_int|2
comma
DECL|enumerator|LSB_ID_Code
DECL|enumerator|MSB_ID_Code
DECL|enumerator|Read_Loopback
id|LSB_ID_Code
op_assign
l_int|5
comma
id|MSB_ID_Code
op_assign
l_int|6
comma
id|Read_Loopback
op_assign
l_int|7
comma
DECL|enumerator|SCSI_Data_NoACK
DECL|enumerator|Option_Select
id|SCSI_Data_NoACK
op_assign
l_int|8
comma
id|Option_Select
op_assign
l_int|10
comma
DECL|enumerator|Read_FIFO
DECL|enumerator|FIFO_Data_Count
id|Read_FIFO
op_assign
l_int|12
comma
id|FIFO_Data_Count
op_assign
l_int|14
)brace
suffix:semicolon
DECL|enum|out_port_type
DECL|enumerator|Write_SCSI_Data
DECL|enumerator|SCSI_Cntl
DECL|enumerator|Interrupt_Cntl
r_enum
id|out_port_type
(brace
id|Write_SCSI_Data
op_assign
l_int|0
comma
id|SCSI_Cntl
op_assign
l_int|1
comma
id|Interrupt_Cntl
op_assign
l_int|2
comma
DECL|enumerator|Data_Mode_Cntl
DECL|enumerator|TMC_Cntl
DECL|enumerator|Write_Loopback
id|Data_Mode_Cntl
op_assign
l_int|3
comma
id|TMC_Cntl
op_assign
l_int|4
comma
id|Write_Loopback
op_assign
l_int|7
comma
DECL|enumerator|Write_FIFO
id|Write_FIFO
op_assign
l_int|12
)brace
suffix:semicolon
DECL|variable|addresses
r_static
r_void
op_star
id|addresses
(braket
)braket
op_assign
(brace
(paren
r_void
op_star
)paren
l_int|0xc8000
comma
(paren
r_void
op_star
)paren
l_int|0xca000
comma
(paren
r_void
op_star
)paren
l_int|0xce000
comma
(paren
r_void
op_star
)paren
l_int|0xde000
)brace
suffix:semicolon
DECL|macro|ADDRESS_COUNT
mdefine_line|#define ADDRESS_COUNT (sizeof( addresses ) / sizeof( unsigned ))
DECL|variable|ports
r_static
r_int
r_int
id|ports
(braket
)braket
op_assign
(brace
l_int|0x140
comma
l_int|0x150
comma
l_int|0x160
comma
l_int|0x170
)brace
suffix:semicolon
DECL|macro|PORT_COUNT
mdefine_line|#define PORT_COUNT (sizeof( ports ) / sizeof( unsigned short ))
DECL|variable|ints
r_static
r_int
r_int
id|ints
(braket
)braket
op_assign
(brace
l_int|3
comma
l_int|5
comma
l_int|10
comma
l_int|11
comma
l_int|12
comma
l_int|14
comma
l_int|15
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n;&n;  READ THIS BEFORE YOU ADD A SIGNATURE!&n;&n;  READING THIS SHORT NOTE CAN SAVE YOU LOTS OF TIME!&n;&n;  READ EVERY WORD, ESPECIALLY THE WORD *NOT*&n;&n;  This driver works *ONLY* for Future Domain cards using the&n;  TMC-1600 chip.  This includes models TMC-1660 and TMC-1680&n;  *ONLY*.&n;&n;  The following is a BIOS signature for a TMC-950 board, which&n;  looks like it is a 16 bit board (based on card edge), but&n;  which only uses the extra lines for IRQ&squot;s (not for data):&n;&n;  FUTURE DOMAIN CORP. (C) 1986-1990 V7.009/18/90&n;&n;  THIS WILL *NOT* WORK WITH THIS DRIVER!&n;&n;  Here is another BIOS signature for yet another Future&n;  Domain board WHICH WILL *NOT* WORK WITH THIS DRIVER:&n;&n;  FUTURE DOMAIN CORP. (C) 1986-1990 V6.0209/18/90&n;&n;  Here is another BIOS signature for the TMC-88x series:&n;&n;  FUTURE DOMAIN COPR. (C) 1986-1989 V6.0A7/28/90&n;&n;  THIS WILL *NOT* WORK WITH THIS DRIVER, but it *WILL*&n;  work with the *SEAGATE* ST-01/ST-02 driver.&n;&n;  */
DECL|struct|signature
r_struct
id|signature
(brace
DECL|member|signature
r_char
op_star
id|signature
suffix:semicolon
DECL|member|sig_offset
r_int
id|sig_offset
suffix:semicolon
DECL|member|sig_length
r_int
id|sig_length
suffix:semicolon
DECL|variable|signatures
)brace
id|signatures
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1990 1800-V2.0 7/28/89&quot;
comma
l_int|5
comma
l_int|50
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1990 1800&quot;
comma
l_int|5
comma
l_int|37
)brace
comma
multiline_comment|/* READ NOTICE ABOVE *BEFORE* YOU WASTE YOUR TIME ADDING A SIGANTURE */
)brace
suffix:semicolon
DECL|macro|SIGNATURE_COUNT
mdefine_line|#define SIGNATURE_COUNT (sizeof( signatures ) / sizeof( struct signature ))
multiline_comment|/* These functions are based on include/asm/io.h */
macro_line|#if 1
DECL|function|inw
r_static
r_int
r_int
r_inline
id|inw
c_func
(paren
r_int
r_int
id|port
)paren
(brace
r_int
r_int
id|_v
suffix:semicolon
id|__asm__
r_volatile
(paren
l_string|&quot;inw %1,%0&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|_v
)paren
suffix:colon
l_string|&quot;d&quot;
(paren
(paren
r_int
r_int
)paren
id|port
)paren
)paren
suffix:semicolon
r_return
id|_v
suffix:semicolon
)brace
DECL|function|outw
r_static
r_void
r_inline
id|outw
c_func
(paren
r_int
r_int
id|value
comma
r_int
r_int
id|port
)paren
(brace
id|__asm__
r_volatile
(paren
l_string|&quot;outw %0,%1&quot;
op_scope_resolution
l_string|&quot;a&quot;
(paren
(paren
r_int
r_int
)paren
id|value
)paren
comma
l_string|&quot;d&quot;
(paren
(paren
r_int
r_int
)paren
id|port
)paren
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|inw
mdefine_line|#define inw( port ) &bslash;&n;      ({ unsigned short _v; &bslash;&n;&t;       __asm__ volatile (&quot;inw %1,%0&quot; &bslash;&n;&t;&t;&t;&t;: &quot;=a&quot; (_v) : &quot;d&quot; ((unsigned short) port)); &bslash;&n;&t;&t;&t;&t;      _v; })
DECL|macro|outw
mdefine_line|#define outw( value ) &bslash;&n;      __asm__ volatile &bslash;&n;      (&quot;outw %0,%1&quot; : : &quot;a&quot; ((unsigned short) value), &bslash;&n;       &quot;d&quot; ((unsigned short) port))
macro_line|#endif
multiline_comment|/* These defines are copied from kernel/blk_drv/hd.c */
DECL|macro|insw
mdefine_line|#define insw( buf, count, port ) &bslash;&n;      __asm__ volatile &bslash;&n;      ( &quot;cld;rep;insw&quot;::&quot;d&quot; (port),&quot;D&quot; (buf),&quot;c&quot; (count):&quot;cx&quot;,&quot;di&quot; )
DECL|macro|outsw
mdefine_line|#define outsw( buf, count, port) &bslash;&n;      __asm__ volatile &bslash;&n;      (&quot;cld;rep;outsw&quot;::&quot;d&quot; (port),&quot;S&quot; (buf),&quot;c&quot; (count):&quot;cx&quot;,&quot;si&quot;)
DECL|function|do_pause
r_static
r_void
id|do_pause
c_func
(paren
r_int
id|amount
)paren
multiline_comment|/* Pause for amount*10 milliseconds */
(brace
r_int
r_int
id|the_time
op_assign
id|jiffies
op_plus
id|amount
suffix:semicolon
multiline_comment|/* 0.01 seconds per jiffy */
r_while
c_loop
(paren
id|jiffies
OL
id|the_time
)paren
suffix:semicolon
)brace
DECL|function|fdomain_make_bus_idle
r_static
r_void
r_inline
id|fdomain_make_bus_idle
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|Data_Mode_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
)brace
DECL|function|fdomain_is_valid_port
r_static
r_int
id|fdomain_is_valid_port
c_func
(paren
r_int
id|port
)paren
(brace
r_int
id|options
suffix:semicolon
macro_line|#if DEBUG_DETECT 
id|printk
c_func
(paren
l_string|&quot; (%x%x),&quot;
comma
id|inb
c_func
(paren
id|port
op_plus
id|MSB_ID_Code
)paren
comma
id|inb
c_func
(paren
id|port
op_plus
id|LSB_ID_Code
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* The MCA ID is a unique id for each MCA compatible board.  We&n;      are using ISA boards, but Future Domain provides the MCA ID&n;      anyway.  We can use this ID to ensure that this is a Future&n;      Domain TMC-1660/TMC-1680.&n;    */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port
op_plus
id|LSB_ID_Code
)paren
op_ne
l_int|0xe9
)paren
(brace
multiline_comment|/* test for 0x6127 id */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port
op_plus
id|LSB_ID_Code
)paren
op_ne
l_int|0x27
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port
op_plus
id|MSB_ID_Code
)paren
op_ne
l_int|0x61
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* test for 0xe960 id */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port
op_plus
id|MSB_ID_Code
)paren
op_ne
l_int|0x60
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We have a valid MCA ID for a TMC-1660/TMC-1680 Future Domain board.&n;      Now, check to be sure the bios_base matches these ports.&n;      If someone was unlucky enough to have purchased more than one&n;      Future Domain board, then they will have to modify this code, as&n;      we only detect one board here.  [The one with the lowest bios_base].&n;    */
id|options
op_assign
id|inb
c_func
(paren
id|port
op_plus
id|Option_Select
)paren
suffix:semicolon
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; Options = %x,&quot;
comma
id|options
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|addresses
(braket
(paren
id|options
op_amp
l_int|0xc0
)paren
op_rshift
l_int|6
)braket
op_ne
id|bios_base
)paren
r_return
l_int|0
suffix:semicolon
id|interrupt_level
op_assign
id|ints
(braket
(paren
id|options
op_amp
l_int|0x0e
)paren
op_rshift
l_int|1
)braket
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|fdomain_test_loopback
r_static
r_int
id|fdomain_test_loopback
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|255
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
id|i
comma
id|port_base
op_plus
id|Write_Loopback
)paren
suffix:semicolon
id|result
op_assign
id|inb
c_func
(paren
id|port_base
op_plus
id|Read_Loopback
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|result
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if !NEW_IRQ
DECL|function|fdomain_enable_interrupt
r_static
r_void
id|fdomain_enable_interrupt
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|interrupt_level
)paren
r_return
suffix:semicolon
macro_line|#if ALLOW_ALL_IRQ
r_if
c_cond
(paren
id|interrupt_level
OL
l_int|8
)paren
(brace
id|outb
c_func
(paren
id|inb_p
c_func
(paren
l_int|0x21
)paren
op_amp
op_complement
(paren
l_int|1
op_lshift
id|interrupt_level
)paren
comma
l_int|0x21
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
id|outb
c_func
(paren
id|inb_p
c_func
(paren
l_int|0xa1
)paren
op_amp
op_complement
(paren
l_int|1
op_lshift
(paren
id|interrupt_level
op_minus
l_int|8
)paren
)paren
comma
l_int|0xa1
)paren
suffix:semicolon
)brace
)brace
DECL|function|fdomain_disable_interrupt
r_static
r_void
id|fdomain_disable_interrupt
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|interrupt_level
)paren
r_return
suffix:semicolon
macro_line|#if ALLOW_ALL_IRQ
r_if
c_cond
(paren
id|interrupt_level
OL
l_int|8
)paren
(brace
id|outb
c_func
(paren
id|inb_p
c_func
(paren
l_int|0x21
)paren
op_or
(paren
l_int|1
op_lshift
id|interrupt_level
)paren
comma
l_int|0x21
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
id|outb
c_func
(paren
id|inb_p
c_func
(paren
l_int|0xa1
)paren
op_or
(paren
l_int|1
op_lshift
(paren
id|interrupt_level
op_minus
l_int|8
)paren
)paren
comma
l_int|0xa1
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|function|fdomain_16x0_detect
r_int
id|fdomain_16x0_detect
c_func
(paren
r_int
id|hostnum
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_int
r_char
id|do_inquiry
(braket
)braket
op_assign
(brace
l_int|0x12
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|255
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|do_request_sense
(braket
)braket
op_assign
(brace
l_int|0x03
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|255
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|do_read_capacity
(braket
)braket
op_assign
(brace
l_int|0x25
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|256
)braket
suffix:semicolon
r_int
id|retcode
suffix:semicolon
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot;SCSI: fdomain_16x0_detect(),&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|bios_base
op_logical_and
id|i
OL
id|ADDRESS_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; %x(%x),&quot;
comma
(paren
r_int
)paren
id|addresses
(braket
id|i
)braket
comma
(paren
r_int
)paren
id|bios_base
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|bios_base
op_logical_and
id|j
OL
id|SIGNATURE_COUNT
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|addresses
(braket
id|i
)braket
op_plus
id|signatures
(braket
id|j
)braket
dot
id|sig_offset
)paren
comma
id|signatures
(braket
id|j
)braket
dot
id|signature
comma
id|signatures
(braket
id|j
)braket
dot
id|sig_length
)paren
)paren
(brace
id|bios_base
op_assign
id|addresses
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|bios_base
)paren
(brace
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; FAILED: NO BIOS&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The TMC-1660/TMC-1680 has a RAM area just after the BIOS ROM.&n;      Assuming the ROM is enabled (otherwise we wouldn&squot;t have been&n;      able to read the ROM signature :-), then the ROM set up the&n;      RAM area with some magic numbers, such as a list of port&n;      base addresses and a list of the disk &quot;geometry&quot; reported to&n;      DOS (this geometry has nothing to do with physical geometry).&n;    */
id|port_base
op_assign
op_star
(paren
(paren
r_char
op_star
)paren
id|bios_base
op_plus
l_int|0x1fcc
)paren
op_plus
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|bios_base
op_plus
l_int|0x1fcd
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; %x,&quot;
comma
id|port_base
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|flag
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|flag
op_logical_and
id|i
OL
id|PORT_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|port_base
op_eq
id|ports
(braket
id|i
)braket
)paren
op_increment
id|flag
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flag
)paren
id|flag
op_assign
id|fdomain_is_valid_port
c_func
(paren
id|port_base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
multiline_comment|/* Cannot get port base from BIOS RAM */
multiline_comment|/* This is a bad sign.  It usually means that someone patched the&n;&t; BIOS signature list (the signatures variable) to contain a BIOS&n;&t; signature for a board *OTHER THAN* the TMC-1660/TMC-1680.&n;       */
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; RAM FAILED, &quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Anyway, the alternative to finding the address in the RAM is&n;&t; to just search through every possible port address for one&n;&t; that is attached to the Future Domain card.  Don&squot;t panic,&n;&t; though, about reading all these random port addresses--there&n;&t; are rumors that the Future Domain BIOS does something very&n;&t; similar.&n;       */
r_for
c_loop
(paren
id|flag
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|flag
op_logical_and
id|i
OL
id|PORT_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|port_base
op_assign
id|ports
(braket
id|i
)braket
suffix:semicolon
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; %x,&quot;
comma
id|port_base
)paren
suffix:semicolon
macro_line|#endif
id|flag
op_assign
id|fdomain_is_valid_port
c_func
(paren
id|port_base
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; FAILED: NO PORT&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Cannot find valid set of ports */
)brace
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SCSI: bios_base = %x, port_base = %x, interrupt_level = %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|bios_base
comma
id|port_base
comma
id|interrupt_level
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|interrupt_level
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain BIOS at %x; port base at %x; using IRQ %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|bios_base
comma
id|port_base
comma
id|interrupt_level
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain BIOS at %x; port base at %x; *NO* IRQ&bslash;n&quot;
comma
(paren
r_int
)paren
id|bios_base
comma
id|port_base
)paren
suffix:semicolon
)brace
id|Data_Mode_Cntl_port
op_assign
id|port_base
op_plus
id|Data_Mode_Cntl
suffix:semicolon
id|FIFO_Data_Count_port
op_assign
id|port_base
op_plus
id|FIFO_Data_Count
suffix:semicolon
id|Interrupt_Cntl_port
op_assign
id|port_base
op_plus
id|Interrupt_Cntl
suffix:semicolon
id|Read_FIFO_port
op_assign
id|port_base
op_plus
id|Read_FIFO
suffix:semicolon
id|Read_SCSI_Data_port
op_assign
id|port_base
op_plus
id|Read_SCSI_Data
suffix:semicolon
id|SCSI_Cntl_port
op_assign
id|port_base
op_plus
id|SCSI_Cntl
suffix:semicolon
id|SCSI_Status_port
op_assign
id|port_base
op_plus
id|SCSI_Status
suffix:semicolon
id|TMC_Cntl_port
op_assign
id|port_base
op_plus
id|TMC_Cntl
suffix:semicolon
id|TMC_Status_port
op_assign
id|port_base
op_plus
id|TMC_Status
suffix:semicolon
id|Write_FIFO_port
op_assign
id|port_base
op_plus
id|Write_FIFO
suffix:semicolon
id|Write_SCSI_Data_port
op_assign
id|port_base
op_plus
id|Write_SCSI_Data
suffix:semicolon
id|fdomain_16x0_reset
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdomain_test_loopback
c_func
(paren
)paren
)paren
(brace
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot;SCSI: LOOPBACK TEST FAILED, FAILING DETECT!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* These routines are here because of the way the SCSI bus behaves&n;      after a reset.  This appropriate behavior was not handled correctly&n;      by the higher level SCSI routines when I first wrote this driver.&n;    */
id|printk
c_func
(paren
l_string|&quot;Future Domain detection routine scanning for devices:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
l_int|6
)paren
r_continue
suffix:semicolon
multiline_comment|/* The host adapter is at SCSI ID 6 */
id|retcode
op_assign
id|fdomain_16x0_command
c_func
(paren
id|i
comma
id|do_request_sense
comma
id|buf
comma
l_int|255
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
)paren
(brace
id|retcode
op_assign
id|fdomain_16x0_command
c_func
(paren
id|i
comma
id|do_inquiry
comma
id|buf
comma
l_int|255
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;     SCSI ID %d: &quot;
comma
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|8
suffix:semicolon
id|j
OL
l_int|32
suffix:semicolon
id|j
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|buf
(braket
id|j
)braket
)paren
suffix:semicolon
id|retcode
op_assign
id|fdomain_16x0_command
c_func
(paren
id|i
comma
id|do_read_capacity
comma
id|buf
comma
l_int|255
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
)paren
(brace
r_int
r_int
id|blocks
comma
id|size
comma
id|capacity
suffix:semicolon
id|blocks
op_assign
(paren
id|buf
(braket
l_int|0
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|buf
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|buf
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
id|buf
(braket
l_int|3
)braket
suffix:semicolon
id|size
op_assign
(paren
id|buf
(braket
l_int|4
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|buf
(braket
l_int|5
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|buf
(braket
l_int|6
)braket
op_lshift
l_int|8
)paren
op_or
id|buf
(braket
l_int|7
)braket
suffix:semicolon
id|capacity
op_assign
op_plus
(paren
id|blocks
op_star
id|size
op_star
l_int|10
)paren
op_div
op_plus
(paren
l_int|1024L
op_star
l_int|1024L
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%lu MB (%lu byte blocks)&quot;
comma
(paren
(paren
id|capacity
op_plus
l_int|5L
)paren
op_div
l_int|10L
)paren
comma
id|size
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#if QUEUE
macro_line|#if !ALLOW_ALL_IRQ
r_if
c_cond
(paren
id|interrupt_level
OL
l_int|8
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain: WILL NOT USE IRQ LESS THAN 8 FOR QUEUEING!&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_hosts
(braket
id|hostnum
)braket
dot
id|can_queue
op_assign
l_int|0
suffix:semicolon
)brace
r_else
macro_line|#endif
macro_line|#if NEW_IRQ
(brace
r_int
id|retcode
suffix:semicolon
r_struct
id|sigaction
id|sa
suffix:semicolon
id|this_host
op_assign
id|hostnum
suffix:semicolon
id|sa.sa_handler
op_assign
id|fdomain_16x0_intr
suffix:semicolon
id|sa.sa_flags
op_assign
id|SA_INTERRUPT
suffix:semicolon
id|sa.sa_mask
op_assign
l_int|0
suffix:semicolon
id|sa.sa_restorer
op_assign
l_int|NULL
suffix:semicolon
id|retcode
op_assign
id|irqaction
c_func
(paren
id|interrupt_level
comma
op_amp
id|sa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retcode
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|retcode
op_eq
op_minus
id|EINVAL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain: IRQ %d is bad!&bslash;n&quot;
comma
id|interrupt_level
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;       This shouldn&squot;t happen: REPORT TO RIK!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|retcode
op_eq
op_minus
id|EBUSY
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain: IRQ %d is already in use!&bslash;n&quot;
comma
id|interrupt_level
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;       Please use another IRQ for the FD card!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain: Error getting IRQ %d&bslash;n&quot;
comma
id|interrupt_level
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;       This shouldn&squot;t happen: REPORT TO RIK!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;       IRQs WILL NOT BE USED!&bslash;n&quot;
)paren
suffix:semicolon
id|scsi_hosts
(braket
id|this_host
)braket
dot
id|can_queue
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain: IRQ %d selected with retcode = %d&bslash;n&quot;
comma
id|interrupt_level
comma
id|retcode
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
(brace
id|this_host
op_assign
id|hostnum
suffix:semicolon
id|set_intr_gate
c_func
(paren
l_int|0x20
op_plus
id|interrupt_level
comma
op_amp
id|fdomain_16x0_interrupt
)paren
suffix:semicolon
id|fdomain_enable_interrupt
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|fdomain_16x0_info
r_char
op_star
id|fdomain_16x0_info
c_func
(paren
r_void
)paren
(brace
r_static
r_char
id|buffer
(braket
)braket
op_assign
l_string|&quot;Future Domain TMC-1660/TMC-1680 SCSI driver version &quot;
id|VERSION
l_string|&quot;&bslash;n&quot;
suffix:semicolon
r_return
id|buffer
suffix:semicolon
)brace
DECL|function|fdomain_arbitrate
r_static
r_int
id|fdomain_arbitrate
c_func
(paren
r_void
)paren
(brace
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
macro_line|#if VERBOSE
id|printk
c_func
(paren
l_string|&quot;SCSI: fdomain_arbitrate()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
l_int|0x00
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Disable data drivers */
id|outb
c_func
(paren
l_int|0x40
comma
id|port_base
op_plus
id|SCSI_Data_NoACK
)paren
suffix:semicolon
multiline_comment|/* Set our id bit */
id|outb
c_func
(paren
l_int|0x04
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Start arbitration */
id|timeout
op_assign
id|jiffies
op_plus
l_int|50
suffix:semicolon
multiline_comment|/* 500 mS */
r_while
c_loop
(paren
id|jiffies
OL
id|timeout
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|TMC_Status_port
)paren
suffix:semicolon
multiline_comment|/* Read adapter status */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x02
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Arbitration complete */
)brace
multiline_comment|/* Make bus idle */
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Arbitration failed, status = %x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot;SCSI: Arbitration failed, status = %x&quot;
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|fdomain_select
r_static
r_int
id|fdomain_select
c_func
(paren
r_int
id|target
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
id|outb
c_func
(paren
l_int|0x80
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Bus Enable */
id|outb
c_func
(paren
l_int|0x8a
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Bus Enable + Attention + Select */
multiline_comment|/* Send our address OR&squot;d with target address */
macro_line|#if SEND_IDENTIFY
id|outb
c_func
(paren
l_int|0x40
op_or
(paren
l_int|1
op_lshift
id|target
)paren
comma
id|port_base
op_plus
id|SCSI_Data_NoACK
)paren
suffix:semicolon
macro_line|#else
id|outb
c_func
(paren
(paren
l_int|1
op_lshift
id|target
)paren
comma
id|port_base
op_plus
id|SCSI_Data_NoACK
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Stop arbitration (also set FIFO for output and enable parity) */
id|outb
c_func
(paren
l_int|0xc8
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
l_int|25
suffix:semicolon
multiline_comment|/* 250mS */
r_while
c_loop
(paren
id|jiffies
OL
id|timeout
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
suffix:semicolon
multiline_comment|/* Read adapter status */
r_if
c_cond
(paren
id|status
op_amp
l_int|1
)paren
(brace
multiline_comment|/* Busy asserted */
multiline_comment|/* Enable SCSI Bus (on error, should make bus idle with 0) */
macro_line|#if SEND_IDENTIFY
multiline_comment|/* Also, set ATN so that the drive will make a MESSAGE OUT phase */
id|outb
c_func
(paren
l_int|0x88
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
macro_line|#else
id|outb
c_func
(paren
l_int|0x80
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Make bus idle */
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
r_if
c_cond
(paren
op_logical_neg
id|target
)paren
id|printk
c_func
(paren
l_string|&quot;Select failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
op_logical_neg
id|target
)paren
id|printk
c_func
(paren
l_string|&quot;SCSI: Select failed&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#if QUEUE
macro_line|#if !USE_FIFO
macro_line|#pragma error QUEUE requires USE_FIFO
macro_line|#endif
DECL|function|my_done
r_void
id|my_done
c_func
(paren
r_int
id|error
)paren
(brace
r_if
c_cond
(paren
id|in_command
)paren
(brace
id|in_command
op_assign
l_int|0
suffix:semicolon
id|in_interrupt_code
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_done
)paren
id|current_done
c_func
(paren
id|this_host
comma
id|error
)paren
suffix:semicolon
r_else
id|panic
c_func
(paren
l_string|&quot;SCSI (Future Domain): current_done() == NULL&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|panic
c_func
(paren
l_string|&quot;SCSI (Future Domain): my_done() called outside of command&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#if NEW_IRQ
DECL|function|fdomain_16x0_intr
r_void
id|fdomain_16x0_intr
c_func
(paren
r_int
id|unused
)paren
macro_line|#else
r_void
id|fdomain_16x0_intr
c_func
(paren
r_void
)paren
macro_line|#endif
(brace
r_int
id|status
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_int
id|data_count
suffix:semicolon
macro_line|#if NEW_IRQ
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|in_interrupt_code
)paren
id|panic
c_func
(paren
l_string|&quot;SCSI (Future Domain): fdomain_16x0_intr() NOT REENTRANT!&bslash;n&quot;
)paren
suffix:semicolon
r_else
op_increment
id|in_interrupt_code
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;aborted = %d, &quot;
comma
id|aborted
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|aborted
)paren
(brace
multiline_comment|/* Force retry for timeouts after selection complete */
r_if
c_cond
(paren
id|current_phase
op_eq
id|in_other
)paren
id|my_done
c_func
(paren
id|DID_BUS_BUSY
op_lshift
l_int|16
)paren
suffix:semicolon
r_else
id|my_done
c_func
(paren
id|aborted
op_lshift
l_int|16
)paren
suffix:semicolon
macro_line|#if NEW_IRQ &amp;&amp; !DECREASE_IL
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* We usually have one spurious interrupt after each command.  Ignore it. */
r_if
c_cond
(paren
op_logical_neg
id|in_command
)paren
(brace
multiline_comment|/* Spurious interrupt */
id|in_interrupt_code
op_assign
l_int|0
suffix:semicolon
macro_line|#if NEW_IRQ &amp;&amp; !DECREASE_IL
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current_phase
op_eq
id|in_arbitration
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|TMC_Status_port
)paren
suffix:semicolon
multiline_comment|/* Read adapter status */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
l_int|0x02
)paren
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; AFAIL &quot;
)paren
suffix:semicolon
macro_line|#endif
id|my_done
c_func
(paren
id|DID_TIME_OUT
op_lshift
l_int|16
)paren
suffix:semicolon
macro_line|#if NEW_IRQ &amp;&amp; !DECREASE_IL
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
id|current_phase
op_assign
id|in_selection
suffix:semicolon
id|outb
c_func
(paren
l_int|0x80
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Bus Enable */
id|outb
c_func
(paren
l_int|0x8a
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Bus Enable + Attention + Select */
id|outb
c_func
(paren
(paren
l_int|1
op_lshift
id|current_target
)paren
comma
id|port_base
op_plus
id|SCSI_Data_NoACK
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x40
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Stop arbitration (also set FIFO for output and enable parity) */
id|in_interrupt_code
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|0xd8
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
macro_line|#if NEW_IRQ &amp;&amp; !DECREASE_IL
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|current_phase
op_eq
id|in_selection
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
l_int|0x01
)paren
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; SFAIL &quot;
)paren
suffix:semicolon
macro_line|#endif
id|my_done
c_func
(paren
id|DID_NO_CONNECT
op_lshift
l_int|16
)paren
suffix:semicolon
macro_line|#if NEW_IRQ &amp;&amp; !DECREASE_IL
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
id|current_phase
op_assign
id|in_other
suffix:semicolon
macro_line|#if FAST_SYNCH
id|outb
c_func
(paren
l_int|0xc0
comma
id|Data_Mode_Cntl_port
)paren
suffix:semicolon
macro_line|#endif
id|in_interrupt_code
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|0x90
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x80
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
macro_line|#if NEW_IRQ &amp;&amp; !DECREASE_IL
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* current_phase == in_other: this is the body of the routine */
r_switch
c_cond
(paren
(paren
r_int
r_char
)paren
op_star
id|the_command
)paren
(brace
r_case
l_int|0x04
suffix:colon
r_case
l_int|0x07
suffix:colon
r_case
l_int|0x0a
suffix:colon
r_case
l_int|0x15
suffix:colon
r_case
l_int|0x2a
suffix:colon
r_case
l_int|0x2e
suffix:colon
r_case
l_int|0x3b
suffix:colon
r_case
l_int|0xea
suffix:colon
r_case
l_int|0x3f
suffix:colon
id|data_count
op_assign
l_int|0x2000
op_minus
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_bufflen
op_minus
id|data_sent
OL
id|data_count
)paren
id|data_count
op_assign
id|current_bufflen
op_minus
id|data_sent
suffix:semicolon
r_if
c_cond
(paren
id|data_count
OG
l_int|0
)paren
(brace
multiline_comment|/* &t; if (data_count &gt; 512) data_count = 512; */
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;%d OUT, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
id|outb
c_func
(paren
op_star
id|out_buf_pt
op_increment
comma
id|Write_FIFO_port
)paren
suffix:semicolon
op_increment
id|data_sent
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
id|outsw
c_func
(paren
id|out_buf_pt
comma
id|data_count
comma
id|Write_FIFO_port
)paren
suffix:semicolon
id|out_buf_pt
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
id|data_sent
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|have_data_in
)paren
(brace
id|outb
c_func
(paren
l_int|0x98
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
op_increment
id|have_data_in
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_assign
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
suffix:semicolon
multiline_comment|/* &t; if (data_count &gt; 512) data_count = 512; */
r_if
c_cond
(paren
id|data_count
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;%d IN, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
op_star
id|in_buf_pt
op_increment
op_assign
id|inb
c_func
(paren
id|Read_FIFO_port
)paren
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Number of words */
id|insw
c_func
(paren
id|in_buf_pt
comma
id|data_count
comma
id|Read_FIFO_port
)paren
suffix:semicolon
id|in_buf_pt
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
)brace
)brace
r_break
suffix:semicolon
)brace
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x10
)paren
(brace
multiline_comment|/* REQ */
r_switch
c_cond
(paren
id|status
op_amp
l_int|0x0e
)paren
(brace
r_case
l_int|0x08
suffix:colon
multiline_comment|/* COMMAND OUT */
id|outb
c_func
(paren
op_star
id|cmd_pt
op_increment
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;CMD = %x,&quot;
comma
(paren
r_int
r_char
)paren
id|cmd_pt
(braket
op_minus
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x0c
suffix:colon
multiline_comment|/* STATUS IN */
id|Status
op_assign
id|inb
c_func
(paren
id|Read_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Status = %x, &quot;
comma
id|Status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
id|Status
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI: target = %d, command = %x, Status = %x&bslash;n&quot;
comma
id|current_target
comma
(paren
r_int
r_char
)paren
op_star
id|the_command
comma
id|Status
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x0a
suffix:colon
multiline_comment|/* MESSAGE OUT */
macro_line|#if SEND_IDENTIFY
multiline_comment|/* On the first request, send an Identify message */
r_if
c_cond
(paren
op_logical_neg
id|sent_identify
)paren
(brace
id|outb
c_func
(paren
l_int|0x80
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Lower ATN */
id|outb
c_func
(paren
l_int|0x80
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
multiline_comment|/* Identify */
op_increment
id|sent_identify
suffix:semicolon
)brace
r_else
macro_line|#else
id|outb
c_func
(paren
l_int|0x07
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
multiline_comment|/* Reject */
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x0e
suffix:colon
multiline_comment|/* MESSAGE IN */
id|Message
op_assign
id|inb
c_func
(paren
id|Read_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Message = %x, &quot;
comma
id|Message
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|Message
)paren
op_increment
id|done
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|done
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; ** IN DONE ** &quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|have_data_in
)paren
(brace
r_while
c_loop
(paren
id|data_count
op_assign
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
)paren
(brace
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
op_star
id|in_buf_pt
op_increment
op_assign
id|inb
c_func
(paren
id|Read_FIFO_port
)paren
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Number of words */
id|insw
c_func
(paren
id|in_buf_pt
comma
id|data_count
comma
id|Read_FIFO_port
)paren
suffix:semicolon
id|in_buf_pt
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
)brace
)brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;AFTER DATA GET&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
op_star
id|the_command
op_eq
id|REQUEST_SENSE
op_logical_and
op_logical_neg
id|Status
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|current_buff
op_plus
l_int|2
)paren
)paren
op_amp
l_int|0x0f
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI REQUEST SENSE: Sense Key = %x, Sense Code = %x&bslash;n&quot;
comma
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|current_buff
op_plus
l_int|2
)paren
)paren
op_amp
l_int|0x0f
comma
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|current_buff
op_plus
l_int|12
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;BEFORE MY_DONE&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|my_done
c_func
(paren
(paren
id|Status
op_amp
l_int|0xff
)paren
op_or
(paren
(paren
id|Message
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|DID_OK
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|in_interrupt_code
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|0x90
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
)brace
macro_line|#if NEW_IRQ &amp;&amp; !DECREASE_IL
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
DECL|function|fdomain_16x0_queue
r_int
id|fdomain_16x0_queue
c_func
(paren
r_int
r_char
id|target
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buff
comma
r_int
id|bufflen
comma
r_void
(paren
op_star
id|done
)paren
(paren
r_int
comma
r_int
)paren
)paren
(brace
r_if
c_cond
(paren
id|in_command
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;SCSI (Future Domain): fdomain_16x0_queue() NOT REENTRANT!&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;queue %d %x&bslash;n&quot;
comma
id|target
comma
op_star
(paren
r_int
r_char
op_star
)paren
id|cmnd
)paren
suffix:semicolon
macro_line|#endif
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
id|aborted
op_assign
l_int|0
suffix:semicolon
id|current_target
op_assign
id|target
suffix:semicolon
id|memcpy
c_func
(paren
id|current_cmnd
comma
id|cmnd
comma
(paren
(paren
op_star
(paren
r_int
r_char
op_star
)paren
id|cmnd
)paren
op_le
l_int|0x1f
ques
c_cond
l_int|6
suffix:colon
l_int|10
)paren
)paren
suffix:semicolon
id|current_buff
op_assign
id|buff
suffix:semicolon
id|current_bufflen
op_assign
id|bufflen
suffix:semicolon
id|current_done
op_assign
id|done
suffix:semicolon
multiline_comment|/* Initialize static data */
id|cmd_pt
op_assign
id|current_cmnd
suffix:semicolon
id|the_command
op_assign
id|current_cmnd
suffix:semicolon
id|out_buf_pt
op_assign
id|current_buff
suffix:semicolon
id|in_buf_pt
op_assign
id|current_buff
suffix:semicolon
id|Status
op_assign
l_int|0
suffix:semicolon
id|Message
op_assign
l_int|0
suffix:semicolon
id|data_sent
op_assign
l_int|0
suffix:semicolon
id|have_data_in
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Start arbitration */
id|current_phase
op_assign
id|in_arbitration
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Disable data drivers */
id|outb
c_func
(paren
l_int|0x40
comma
id|port_base
op_plus
id|SCSI_Data_NoACK
)paren
suffix:semicolon
multiline_comment|/* Set our id bit */
op_increment
id|in_command
suffix:semicolon
id|outb
c_func
(paren
l_int|0x20
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x1c
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Start arbitration */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|fdomain_16x0_command
r_int
id|fdomain_16x0_command
c_func
(paren
r_int
r_char
id|target
comma
r_const
r_void
op_star
id|cmnd
comma
r_void
op_star
id|buff
comma
r_int
id|bufflen
)paren
(brace
r_const
r_char
op_star
id|cmd_pt
op_assign
id|cmnd
suffix:semicolon
r_const
r_char
op_star
id|the_command
op_assign
id|cmnd
suffix:semicolon
r_int
r_char
op_star
id|out_buf_pt
op_assign
id|buff
suffix:semicolon
r_int
r_char
op_star
id|in_buf_pt
op_assign
id|buff
suffix:semicolon
r_int
id|Status
op_assign
l_int|0
suffix:semicolon
r_int
id|Message
op_assign
l_int|0
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_int
id|data_sent
op_assign
l_int|0
suffix:semicolon
r_int
id|data_count
suffix:semicolon
macro_line|#if USE_FIFO
r_int
id|have_data_in
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#if SEND_IDENTITY
r_int
id|sent_identify
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;fdomain_command(%d, %x): &quot;
comma
id|target
comma
(paren
r_int
r_char
)paren
op_star
id|the_command
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|fdomain_arbitrate
c_func
(paren
)paren
)paren
(brace
macro_line|#if ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot;, target = %d, command = %x&bslash;n&quot;
comma
id|target
comma
(paren
r_int
r_char
)paren
op_star
id|the_command
)paren
suffix:semicolon
macro_line|#endif
r_return
id|DID_TIME_OUT
op_lshift
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fdomain_select
c_func
(paren
id|target
)paren
)paren
(brace
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
op_logical_neg
id|target
)paren
id|printk
c_func
(paren
l_string|&quot;, target = %d, command = %x&bslash;n&quot;
comma
id|target
comma
(paren
r_int
r_char
)paren
op_star
id|the_command
)paren
suffix:semicolon
macro_line|#endif
r_return
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
)brace
id|timeout
op_assign
id|jiffies
op_plus
l_int|500
suffix:semicolon
multiline_comment|/* 5000 mS -- For Maxtor after a RST */
id|aborted
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* How is this supposed to get reset??? */
macro_line|#if FAST_SYNCH
id|outb
c_func
(paren
l_int|0xc0
comma
id|Data_Mode_Cntl_port
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if USE_FIFO
r_switch
c_cond
(paren
(paren
r_int
r_char
)paren
op_star
id|the_command
)paren
(brace
r_case
l_int|0x04
suffix:colon
r_case
l_int|0x07
suffix:colon
r_case
l_int|0x0a
suffix:colon
r_case
l_int|0x15
suffix:colon
r_case
l_int|0x2a
suffix:colon
r_case
l_int|0x2e
suffix:colon
r_case
l_int|0x3b
suffix:colon
r_case
l_int|0xea
suffix:colon
r_case
l_int|0x3f
suffix:colon
id|data_count
op_assign
l_int|0x2000
op_minus
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bufflen
op_minus
id|data_sent
OL
id|data_count
)paren
id|data_count
op_assign
id|bufflen
op_minus
id|data_sent
suffix:semicolon
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
id|outb
c_func
(paren
op_star
id|out_buf_pt
op_increment
comma
id|Write_FIFO_port
)paren
suffix:semicolon
op_increment
id|data_sent
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
id|outsw
c_func
(paren
id|out_buf_pt
comma
id|data_count
comma
id|Write_FIFO_port
)paren
suffix:semicolon
id|out_buf_pt
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
id|data_sent
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|outb
c_func
(paren
l_int|0x88
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
op_increment
id|have_data_in
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
r_while
c_loop
(paren
(paren
(paren
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
)paren
op_amp
l_int|1
)paren
op_logical_and
op_logical_neg
id|done
op_logical_and
op_logical_neg
id|aborted
op_logical_and
id|jiffies
OL
id|timeout
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
l_int|0x10
)paren
(brace
multiline_comment|/* REQ */
r_switch
c_cond
(paren
id|status
op_amp
l_int|0x0e
)paren
(brace
r_case
l_int|0x00
suffix:colon
multiline_comment|/* DATA OUT */
macro_line|#if USE_FIFO
id|data_count
op_assign
l_int|0x2000
op_minus
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bufflen
op_minus
id|data_sent
OL
id|data_count
)paren
id|data_count
op_assign
id|bufflen
op_minus
id|data_sent
suffix:semicolon
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
id|outb
c_func
(paren
op_star
id|out_buf_pt
op_increment
comma
id|Write_FIFO_port
)paren
suffix:semicolon
op_increment
id|data_sent
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
id|outsw
c_func
(paren
id|out_buf_pt
comma
id|data_count
comma
id|Write_FIFO_port
)paren
suffix:semicolon
id|out_buf_pt
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
id|data_sent
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
macro_line|#else
id|outb
c_func
(paren
op_star
id|out_buf_pt
op_increment
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x04
suffix:colon
multiline_comment|/* DATA IN */
macro_line|#if USE_FIFO
r_if
c_cond
(paren
op_logical_neg
id|have_data_in
)paren
(brace
id|outb
c_func
(paren
l_int|0x88
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
op_increment
id|have_data_in
suffix:semicolon
)brace
id|data_count
op_assign
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
op_star
id|in_buf_pt
op_increment
op_assign
id|inb
c_func
(paren
id|Read_FIFO_port
)paren
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Number of words */
id|insw
c_func
(paren
id|in_buf_pt
comma
id|data_count
comma
id|Read_FIFO_port
)paren
suffix:semicolon
id|in_buf_pt
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
macro_line|#else
op_star
id|in_buf_pt
op_increment
op_assign
id|inb
c_func
(paren
id|Read_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x08
suffix:colon
multiline_comment|/* COMMAND OUT */
id|outb
c_func
(paren
op_star
id|cmd_pt
op_increment
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;%x,&quot;
comma
(paren
r_int
r_char
)paren
id|cmd_pt
(braket
op_minus
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x0c
suffix:colon
multiline_comment|/* STATUS IN */
id|Status
op_assign
id|inb
c_func
(paren
id|Read_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Status = %x, &quot;
comma
id|Status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
id|Status
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI: target = %d, command = %x, Status = %x&bslash;n&quot;
comma
id|target
comma
(paren
r_int
r_char
)paren
op_star
id|the_command
comma
id|Status
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x0a
suffix:colon
multiline_comment|/* MESSAGE OUT */
macro_line|#if SEND_IDENTIFY
multiline_comment|/* On the first request, send an Identify message */
r_if
c_cond
(paren
op_logical_neg
id|sent_identify
)paren
(brace
id|outb
c_func
(paren
l_int|0x80
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Lower ATN */
id|outb
c_func
(paren
l_int|0x80
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
multiline_comment|/* Identify */
op_increment
id|sent_identify
suffix:semicolon
)brace
r_else
macro_line|#else
id|outb
c_func
(paren
l_int|0x07
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
multiline_comment|/* Reject */
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x0e
suffix:colon
multiline_comment|/* MESSAGE IN */
id|Message
op_assign
id|inb
c_func
(paren
id|Read_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Message = %x, &quot;
comma
id|Message
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|Message
)paren
op_increment
id|done
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|jiffies
op_ge
id|timeout
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Time out, status = %x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot;SCSI: Time out, status = %x (target = %d, command = %x)&bslash;n&quot;
comma
id|status
comma
id|target
comma
(paren
r_int
r_char
)paren
op_star
id|the_command
)paren
suffix:semicolon
macro_line|#endif
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
r_return
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aborted
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Aborted&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ONLY_ERRORS
id|printk
c_func
(paren
l_string|&quot;SCSI: Aborted (command = %x)&bslash;n&quot;
comma
(paren
r_int
r_char
)paren
op_star
id|the_command
)paren
suffix:semicolon
macro_line|#endif
id|fdomain_16x0_reset
c_func
(paren
)paren
suffix:semicolon
r_return
id|DID_ABORT
op_lshift
l_int|16
suffix:semicolon
)brace
macro_line|#if USE_FIFO
r_if
c_cond
(paren
id|have_data_in
)paren
(brace
r_while
c_loop
(paren
id|data_count
op_assign
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
)paren
(brace
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
op_star
id|in_buf_pt
op_increment
op_assign
id|inb
c_func
(paren
id|Read_FIFO_port
)paren
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Number of words */
id|insw
c_func
(paren
id|in_buf_pt
comma
id|data_count
comma
id|Read_FIFO_port
)paren
suffix:semicolon
id|in_buf_pt
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Retcode = %x&bslash;n&quot;
comma
(paren
id|Status
op_amp
l_int|0xff
)paren
op_or
(paren
(paren
id|Message
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|DID_OK
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
op_star
id|the_command
op_eq
id|REQUEST_SENSE
op_logical_and
op_logical_neg
id|Status
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|buff
op_plus
l_int|2
)paren
)paren
op_amp
l_int|0x0f
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI REQUEST SENSE: Sense Key = %x, Sense Code = %x&bslash;n&quot;
comma
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|buff
op_plus
l_int|2
)paren
)paren
op_amp
l_int|0x0f
comma
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|buff
op_plus
l_int|12
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_return
(paren
id|Status
op_amp
l_int|0xff
)paren
op_or
(paren
(paren
id|Message
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|DID_OK
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
DECL|function|fdomain_16x0_abort
r_int
id|fdomain_16x0_abort
c_func
(paren
r_int
id|code
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; ABORT &quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if QUEUE
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_command
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|aborted
op_assign
id|code
ques
c_cond
id|code
suffix:colon
id|DID_ABORT
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
id|aborted
op_assign
id|code
ques
c_cond
id|code
suffix:colon
id|DID_ABORT
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fdomain_16x0_reset
r_int
id|fdomain_16x0_reset
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
l_int|1
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
id|do_pause
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
id|do_pause
c_func
(paren
l_int|115
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|Data_Mode_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
id|aborted
op_assign
id|DID_RESET
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if QUEUE &amp;&amp; !NEW_IRQ
multiline_comment|/* This is copied from kernel/sys_calls.s&n;   and from kernel/blk_drv/scsi/aha1542.c */
id|__asm__
c_func
(paren
"&quot;"
id|_fdomain_16x0_interrupt
suffix:colon
id|cld
id|push
op_mod
id|gs
id|push
op_mod
id|fs
id|push
op_mod
id|es
id|push
op_mod
id|ds
id|pushl
op_mod
id|eax
id|pushl
op_mod
id|ebp
id|pushl
op_mod
id|edi
id|pushl
op_mod
id|esi
id|pushl
op_mod
id|edx
id|pushl
op_mod
id|ecx
id|pushl
op_mod
id|ebx
id|movl
"$"
l_int|0x10
comma
op_mod
id|edx
id|mov
op_mod
id|dx
comma
op_mod
id|ds
id|mov
op_mod
id|dx
comma
op_mod
id|es
id|movl
"$"
l_int|0x17
comma
op_mod
id|edx
id|mov
op_mod
id|dx
comma
op_mod
id|fs
id|movl
"$"
id|_fdomain_disable_interrupt
comma
op_mod
id|edx
id|call
op_star
op_mod
id|edx
id|movb
"$"
l_int|0x20
comma
op_mod
id|al
id|outb
op_mod
id|al
comma
"$"
l_int|0xA0
macro_line|# EOI to interrupt controller #1
id|jmp
l_float|1f
macro_line|# give port chance to breathe
l_int|1
suffix:colon
id|jmp
l_float|1f
l_int|1
suffix:colon
id|outb
op_mod
id|al
comma
"$"
l_int|0x20
id|sti
id|movl
"$"
id|_fdomain_16x0_intr
comma
op_mod
id|edx
id|call
op_star
op_mod
id|edx
macro_line|# ``interesting&squot;&squot; way of handling intr.
id|cli
id|movl
"$"
id|_fdomain_enable_interrupt
comma
op_mod
id|edx
id|call
op_star
op_mod
id|edx
id|popl
op_mod
id|ebx
id|popl
op_mod
id|ecx
id|popl
op_mod
id|edx
id|popl
op_mod
id|esi
id|popl
op_mod
id|edi
id|popl
op_mod
id|ebp
id|popl
op_mod
id|eax
id|pop
op_mod
id|ds
id|pop
op_mod
id|es
id|pop
op_mod
id|fs
id|pop
op_mod
id|gs
id|iret
"&quot;"
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
eof
