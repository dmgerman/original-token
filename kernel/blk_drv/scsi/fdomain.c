multiline_comment|/* fdomain.c -- Future Domain TMC-1660/TMC-1680 driver&n; * Created: Sun May  3 18:53:19 1992 by faith&n; * Revised: Sat May 15 15:29:19 1993 by faith@cs.unc.edu&n; * Author: Rickard E. Faith, faith@cs.unc.edu&n; * Copyright 1992, 1993 Rickard E. Faith&n; *&n; * $Log$&n;&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n;&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n;&n; **************************************************************************&n;&n;&n; DESCRIPTION:&n;&n; This is the Linux low-level SCSI driver for Future Domain TMC-1660/1680&n; and TMC-1650/1670 SCSI host adapters.  The older boards are based on the&n; TMC-1800 chip, and the driver was originally written for a TMC-1680 with&n; this chip.  More recently, boards are being produced with the TMC-18C50&n; chip.  This driver may not work with the more recent boards.&n;&n;&n; REFERENCES USED:&n;&n; &quot;TMC-1800 SCSI Chip Specification (FDC-1800T)&quot;, Future Domain Corporation,&n; 1990.&n;&n; &quot;Technical Reference Manual: 18C50 SCSI Host Adapter Chip&quot;, Future Domain&n; Corporation, January 1992.&n;&n; &quot;LXT SCSI Products: Specifications and OEM Technical Manual (Revision&n; B/September 1991)&quot;, Maxtor Corporation, 1991.&n;&n; &quot;7213S product Manual (Revision P3)&quot;, Maxtor Corporation, 1992.&n;&n; &quot;Draft Proposed American National Standard: Small Computer System&n; Interface - 2 (SCSI-2)&quot;, Global Engineering Documents. (X3T9.2/86-109,&n; revision 10h, October 17, 1991)&n;&n; Private communications, Drew Eckhardt (drew@cs.colorado.edu) and Eric&n; Youngdale (eric@tantalus.nrl.navy.mil), 1992.&n;&n;&n; NOTES ON REFERENCES:&n;&n; The Maxtor manuals were free.  Maxtor telephone technical support is&n; great!&n;&n; The Future Domain manuals were $25 and $35.  They document the chip, not&n; the TMC-16x0 boards, so some information I had to guess at.  In 1992,&n; Future Domain sells DOS BIOS source for $250 and the UN*X driver source&n; was $750, but these require a non-disclosure agreement, so even if I could&n; afford them, they would *not* have been useful for writing this publically&n; distributable driver.  Future Domain technical support has provided some&n; information on the phone and have sent a few useful FAXs.&n;&n;&n; ALPHA TESTERS:&n;&n; There are many other alpha testers that come and go as the driver&n; develops.  The people listed here were most helpful in times of greatest&n; need.  However, all of the alpha testers deserve much thanks.&n;&n; Todd Carrico (todd@wutc.wustl.edu), Dan Poirier (poirier@cs.unc.edu ), Ken&n; Corey (kenc@sol.acs.unt.edu), C. de Bruin (bruin@dutiba.tudelft.nl),&n; Sakari Aaltonen (sakaria@vipunen.hit.fi), John Rice&n; (rice@xanth.cs.odu.edu), and Brad Yearwood (brad@optilink.com).&n;&n;&n; NOTES ON USER DEFINABLE OPTIONS:&n;&n; DEBUG: This turns on the printing of various debug informaiton.&n;&n; ENABLE_PARITY: This turns on SCSI parity checking.  With the current&n; driver, all attached devices must support SCSI parity.  If none of your&n; devices support parity, then you can probably get the driver to work by&n; turning this option off.  I have no way of testing this, however.&n;&n; QUEUE: Enable &quot;command queueing.&quot;  This is supported by the higher level&n; SCSI code, and allows the kernel to continue to schedule tasks while the&n; SCSI request is pending.  If this option is turned off, then everything&n; will &quot;freeze&quot; during SCSI requests, and system performance will become&n; unbearable.  Later, this will allow multiple outstanding SCSI requests.  I&n; have received reports that if this option is turned off, the driver will&n; no longer function correctly.  I have not had time to track down this bug,&n; since I hope to make the driver work for everyone with QUEUE on.&n;&n; FIFO_COUNT: The host adapter has an 8K cache.  When this many 512 byte&n; blocks are filled by the SCSI device, an interrupt will be raised.&n; Therefore, this could be as low as 0, or as high as 16.  Note, however,&n; that values which are too high or too low seem to prevent any interrupts&n; from occuring, and thereby lock up the machine.  I have found that 2 is a&n; good number, but throughput may be increased by changing this value to&n; values which are close to 2.  Please let me know if you try any different&n; values.&n;&n; DO_DETECT: This activates some old scan code which was needed before the&n; high level drivers got fixed.  If you are having toruble with the driver,&n; turning this on should not hurt, and might help.  Please let me know if&n; this is the case, since this code will be removed from future drivers.&n;&n; RESELECTION: DO *NOT* USE THIS OPTION!  This turns on SCSI device&n; disconnect and reselection, which does not work at this time.  When I get&n; this working, it will support multiple outstanding SCSI commands.&n;&n; **************************************************************************/
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;../blk.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;fdomain.h&quot;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
DECL|macro|VERSION
mdefine_line|#define VERSION          &quot;3.6&quot;&t;/* Change with each revision */
multiline_comment|/* START OF USER DEFINABLE OPTIONS */
DECL|macro|DEBUG
mdefine_line|#define DEBUG            1&t;/* Enable debugging output */
DECL|macro|ENABLE_PARITY
mdefine_line|#define ENABLE_PARITY    1&t;/* Enable SCSI Parity */
DECL|macro|QUEUE
mdefine_line|#define QUEUE            1&t;/* Enable command queueing */
DECL|macro|FIFO_COUNT
mdefine_line|#define FIFO_COUNT       2&t;/* Number of 512 byte blocks before INTR */
DECL|macro|DO_DETECT
mdefine_line|#define DO_DETECT        0&t;/* Do device detection here (see scsi.c) */
DECL|macro|RESELECTION
mdefine_line|#define RESELECTION      0&t;/* Support RESELECTION PHASE (NOT stable) */
multiline_comment|/* END OF USER DEFINABLE OPTIONS */
macro_line|#if DEBUG
DECL|macro|EVERY_ACCESS
mdefine_line|#define EVERY_ACCESS     0&t;/* Write a line on every scsi access */
DECL|macro|ERRORS_ONLY
mdefine_line|#define ERRORS_ONLY      1&t;/* Only write a line if there is an error */
DECL|macro|DEBUG_DETECT
mdefine_line|#define DEBUG_DETECT     0&t;/* Debug fdomain_16x0_detect() */
DECL|macro|DEBUG_MESSAGES
mdefine_line|#define DEBUG_MESSAGES   0&t;/* Debug MESSAGE IN PHASE */
DECL|macro|DEBUG_ABORT
mdefine_line|#define DEBUG_ABORT      1&t;/* Debug abort() routine */
DECL|macro|DEBUG_RACE
mdefine_line|#define DEBUG_RACE       1      /* Debug interrupt-driven race condition */
macro_line|#else
DECL|macro|EVERY_ACCESS
mdefine_line|#define EVERY_ACCESS     0&t;/* LEAVE THESE ALONE--CHANGE THE ONES ABOVE */
DECL|macro|ERRORS_ONLY
mdefine_line|#define ERRORS_ONLY      0
DECL|macro|DEBUG_DETECT
mdefine_line|#define DEBUG_DETECT     0
DECL|macro|DEBUG_MESSAGES
mdefine_line|#define DEBUG_MESSAGES   0
DECL|macro|DEBUG_ABORT
mdefine_line|#define DEBUG_ABORT      0
macro_line|#endif
multiline_comment|/* Errors are reported on the line, so we don&squot;t need to report them again */
macro_line|#if EVERY_ACCESS
DECL|macro|ERRORS_ONLY
macro_line|#undef ERRORS_ONLY
DECL|macro|ERRORS_ONLY
mdefine_line|#define ERRORS_ONLY      0
macro_line|#endif
macro_line|#if ENABLE_PARITY
DECL|macro|PARITY_MASK
mdefine_line|#define PARITY_MASK      0x08
macro_line|#else
DECL|macro|PARITY_MASK
mdefine_line|#define PARITY_MASK      0x00
macro_line|#endif
DECL|enum|chip_type
r_enum
id|chip_type
(brace
DECL|enumerator|unknown
id|unknown
op_assign
l_int|0x00
comma
DECL|enumerator|tmc1800
id|tmc1800
op_assign
l_int|0x01
comma
DECL|enumerator|tmc18c50
id|tmc18c50
op_assign
l_int|0x02
comma
)brace
suffix:semicolon
r_enum
(brace
DECL|enumerator|non_queueing
id|non_queueing
op_assign
l_int|0x01
comma
DECL|enumerator|in_arbitration
id|in_arbitration
op_assign
l_int|0x02
comma
DECL|enumerator|in_selection
id|in_selection
op_assign
l_int|0x04
comma
DECL|enumerator|in_other
id|in_other
op_assign
l_int|0x08
comma
DECL|enumerator|disconnect
id|disconnect
op_assign
l_int|0x10
comma
DECL|enumerator|aborted
id|aborted
op_assign
l_int|0x20
comma
DECL|enumerator|sent_ident
id|sent_ident
op_assign
l_int|0x40
comma
)brace
suffix:semicolon
DECL|enum|in_port_type
r_enum
id|in_port_type
(brace
DECL|enumerator|Read_SCSI_Data
id|Read_SCSI_Data
op_assign
l_int|0
comma
DECL|enumerator|SCSI_Status
id|SCSI_Status
op_assign
l_int|1
comma
DECL|enumerator|TMC_Status
id|TMC_Status
op_assign
l_int|2
comma
DECL|enumerator|FIFO_Status
id|FIFO_Status
op_assign
l_int|3
comma
multiline_comment|/* tmc18c50 only */
DECL|enumerator|Interrupt_Cond
id|Interrupt_Cond
op_assign
l_int|4
comma
multiline_comment|/* tmc18c50 only */
DECL|enumerator|LSB_ID_Code
id|LSB_ID_Code
op_assign
l_int|5
comma
DECL|enumerator|MSB_ID_Code
id|MSB_ID_Code
op_assign
l_int|6
comma
DECL|enumerator|Read_Loopback
id|Read_Loopback
op_assign
l_int|7
comma
DECL|enumerator|SCSI_Data_NoACK
id|SCSI_Data_NoACK
op_assign
l_int|8
comma
DECL|enumerator|Interrupt_Mask
id|Interrupt_Mask
op_assign
l_int|9
comma
DECL|enumerator|Option_Select
id|Option_Select
op_assign
l_int|10
comma
DECL|enumerator|Configuration
id|Configuration
op_assign
l_int|11
comma
multiline_comment|/* tmc18c50 only */
DECL|enumerator|Read_FIFO
id|Read_FIFO
op_assign
l_int|12
comma
DECL|enumerator|FIFO_Data_Count
id|FIFO_Data_Count
op_assign
l_int|14
)brace
suffix:semicolon
DECL|enum|out_port_type
r_enum
id|out_port_type
(brace
DECL|enumerator|Write_SCSI_Data
id|Write_SCSI_Data
op_assign
l_int|0
comma
DECL|enumerator|SCSI_Cntl
id|SCSI_Cntl
op_assign
l_int|1
comma
DECL|enumerator|Interrupt_Cntl
id|Interrupt_Cntl
op_assign
l_int|2
comma
DECL|enumerator|Data_Mode_Cntl
id|Data_Mode_Cntl
op_assign
l_int|3
comma
DECL|enumerator|TMC_Cntl
id|TMC_Cntl
op_assign
l_int|4
comma
DECL|enumerator|Memory_Cntl
id|Memory_Cntl
op_assign
l_int|5
comma
multiline_comment|/* tmc18c50 only */
DECL|enumerator|Write_Loopback
id|Write_Loopback
op_assign
l_int|7
comma
DECL|enumerator|Write_FIFO
id|Write_FIFO
op_assign
l_int|12
)brace
suffix:semicolon
DECL|variable|port_base
r_static
r_int
id|port_base
op_assign
l_int|0
suffix:semicolon
DECL|variable|bios_base
r_static
r_void
op_star
id|bios_base
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|bios_major
r_static
r_int
id|bios_major
op_assign
l_int|0
suffix:semicolon
DECL|variable|bios_minor
r_static
r_int
id|bios_minor
op_assign
l_int|0
suffix:semicolon
DECL|variable|interrupt_level
r_static
r_int
id|interrupt_level
op_assign
l_int|0
suffix:semicolon
DECL|variable|this_host
r_static
r_int
id|this_host
op_assign
l_int|0
suffix:semicolon
DECL|variable|can_queue
r_static
r_int
id|can_queue
op_assign
id|QUEUE
suffix:semicolon
DECL|variable|in_command
r_static
r_volatile
r_int
id|in_command
op_assign
l_int|0
suffix:semicolon
DECL|variable|current_SC
r_static
id|Scsi_Cmnd
op_star
id|current_SC
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|chip
r_static
r_enum
id|chip_type
id|chip
op_assign
id|unknown
suffix:semicolon
macro_line|#if DEBUG_RACE
DECL|variable|in_interrupt_flag
r_static
r_volatile
r_int
id|in_interrupt_flag
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|variable|Data_Mode_Cntl_port
r_static
r_int
id|Data_Mode_Cntl_port
suffix:semicolon
DECL|variable|FIFO_Data_Count_port
r_static
r_int
id|FIFO_Data_Count_port
suffix:semicolon
DECL|variable|Interrupt_Cntl_port
r_static
r_int
id|Interrupt_Cntl_port
suffix:semicolon
DECL|variable|Interrupt_Mask_port
r_static
r_int
id|Interrupt_Mask_port
suffix:semicolon
DECL|variable|Read_FIFO_port
r_static
r_int
id|Read_FIFO_port
suffix:semicolon
DECL|variable|Read_SCSI_Data_port
r_static
r_int
id|Read_SCSI_Data_port
suffix:semicolon
DECL|variable|SCSI_Cntl_port
r_static
r_int
id|SCSI_Cntl_port
suffix:semicolon
DECL|variable|SCSI_Data_NoACK_port
r_static
r_int
id|SCSI_Data_NoACK_port
suffix:semicolon
DECL|variable|SCSI_Status_port
r_static
r_int
id|SCSI_Status_port
suffix:semicolon
DECL|variable|TMC_Cntl_port
r_static
r_int
id|TMC_Cntl_port
suffix:semicolon
DECL|variable|TMC_Status_port
r_static
r_int
id|TMC_Status_port
suffix:semicolon
DECL|variable|Write_FIFO_port
r_static
r_int
id|Write_FIFO_port
suffix:semicolon
DECL|variable|Write_SCSI_Data_port
r_static
r_int
id|Write_SCSI_Data_port
suffix:semicolon
r_extern
r_void
id|fdomain_16x0_intr
c_func
(paren
r_int
id|unused
)paren
suffix:semicolon
DECL|variable|addresses
r_static
r_void
op_star
id|addresses
(braket
)braket
op_assign
(brace
(paren
r_void
op_star
)paren
l_int|0xc8000
comma
(paren
r_void
op_star
)paren
l_int|0xca000
comma
(paren
r_void
op_star
)paren
l_int|0xce000
comma
(paren
r_void
op_star
)paren
l_int|0xde000
)brace
suffix:semicolon
DECL|macro|ADDRESS_COUNT
mdefine_line|#define ADDRESS_COUNT (sizeof( addresses ) / sizeof( unsigned ))
DECL|variable|ports
r_static
r_int
r_int
id|ports
(braket
)braket
op_assign
(brace
l_int|0x140
comma
l_int|0x150
comma
l_int|0x160
comma
l_int|0x170
)brace
suffix:semicolon
DECL|macro|PORT_COUNT
mdefine_line|#define PORT_COUNT (sizeof( ports ) / sizeof( unsigned short ))
DECL|variable|ints
r_static
r_int
r_int
id|ints
(braket
)braket
op_assign
(brace
l_int|3
comma
l_int|5
comma
l_int|10
comma
l_int|11
comma
l_int|12
comma
l_int|14
comma
l_int|15
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n;&n;  READ THIS BEFORE YOU ADD A SIGNATURE!&n;&n;  READING THIS SHORT NOTE CAN SAVE YOU LOTS OF TIME!&n;&n;  READ EVERY WORD, ESPECIALLY THE WORD *NOT*&n;&n;  This driver works *ONLY* for Future Domain cards using the TMC-1800 chip.&n;  This includes models TMC-1660, 1670, and 1680 *ONLY*.&n;&n;  The following BIOS signatures have been tried with this driver.  These&n;  signatures are for boards which do *NOT* work with this driver (but the&n;  first one should work with the Seagate driver):&n;&n;      FUTURE DOMAIN COPR. (C) 1986-1989 V6.0A7/28/90&n;      FUTURE DOMAIN CORP. (C) 1986-1990 V6.0209/18/90&n;      FUTURE DOMAIN CORP. (C) 1986-1990 V7.009/18/90&n;&n;  */
DECL|struct|signature
r_struct
id|signature
(brace
DECL|member|signature
r_char
op_star
id|signature
suffix:semicolon
DECL|member|sig_offset
r_int
id|sig_offset
suffix:semicolon
DECL|member|sig_length
r_int
id|sig_length
suffix:semicolon
DECL|member|major_bios_version
r_int
id|major_bios_version
suffix:semicolon
DECL|member|minor_bios_version
r_int
id|minor_bios_version
suffix:semicolon
DECL|variable|signatures
)brace
id|signatures
(braket
)braket
op_assign
(brace
multiline_comment|/*          1         2         3         4         5         6 */
multiline_comment|/* 123456789012345678901234567890123456789012345678901234567890 */
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1990 1800-V2.07/28/89&quot;
comma
l_int|5
comma
l_int|50
comma
l_int|2
comma
l_int|0
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1992 V3.00.004/02/92&quot;
comma
l_int|5
comma
l_int|44
comma
l_int|3
comma
l_int|0
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN TMC-18XX (C) 1993 V3.203/12/93&quot;
comma
l_int|5
comma
l_int|44
comma
l_int|3
comma
l_int|2
)brace
comma
multiline_comment|/* READ NOTICE ABOVE *BEFORE* YOU WASTE YOUR TIME ADDING A SIGANTURE */
)brace
suffix:semicolon
DECL|macro|SIGNATURE_COUNT
mdefine_line|#define SIGNATURE_COUNT (sizeof( signatures ) / sizeof( struct signature ))
multiline_comment|/* These functions are based on include/asm/io.h */
DECL|function|inw
r_inline
r_static
r_int
r_int
id|inw
c_func
(paren
r_int
r_int
id|port
)paren
(brace
r_int
r_int
id|_v
suffix:semicolon
id|__asm__
r_volatile
(paren
l_string|&quot;inw %1,%0&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|_v
)paren
suffix:colon
l_string|&quot;d&quot;
(paren
(paren
r_int
r_int
)paren
id|port
)paren
)paren
suffix:semicolon
r_return
id|_v
suffix:semicolon
)brace
DECL|function|outw
r_inline
r_static
r_void
id|outw
c_func
(paren
r_int
r_int
id|value
comma
r_int
r_int
id|port
)paren
(brace
id|__asm__
r_volatile
(paren
l_string|&quot;outw %0,%1&quot;
op_scope_resolution
l_string|&quot;a&quot;
(paren
(paren
r_int
r_int
)paren
id|value
)paren
comma
l_string|&quot;d&quot;
(paren
(paren
r_int
r_int
)paren
id|port
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* These defines are copied from kernel/blk_drv/hd.c */
DECL|macro|insw
mdefine_line|#define insw( buf, count, port ) &bslash;&n;   __asm__ volatile &bslash;&n;      (&quot;cld;rep;insw&quot;::&quot;d&quot; (port),&quot;D&quot; (buf),&quot;c&quot; (count):&quot;cx&quot;,&quot;di&quot; )
DECL|macro|outsw
mdefine_line|#define outsw( buf, count, port ) &bslash;&n;    __asm__ volatile &bslash;&n;       (&quot;cld;rep;outsw&quot;::&quot;d&quot; (port),&quot;S&quot; (buf),&quot;c&quot; (count):&quot;cx&quot;,&quot;si&quot;)
DECL|function|print_banner
r_static
r_void
id|print_banner
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|fdomain_16x0_info
c_func
(paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Future Domain: BIOS version %d.%d, %s&bslash;n&quot;
comma
id|bios_major
comma
id|bios_minor
comma
id|chip
op_eq
id|tmc1800
ques
c_cond
l_string|&quot;TMC-1800&quot;
suffix:colon
(paren
id|chip
op_eq
id|tmc18c50
ques
c_cond
l_string|&quot;TMC-18C50&quot;
suffix:colon
l_string|&quot;Unknown&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|interrupt_level
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain: BIOS at %x; port base at %x; using IRQ %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|bios_base
comma
id|port_base
comma
id|interrupt_level
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain: BIOS at %x; port base at %x; *NO* IRQ&bslash;n&quot;
comma
(paren
r_int
)paren
id|bios_base
comma
id|port_base
)paren
suffix:semicolon
)brace
)brace
DECL|function|do_pause
r_static
r_void
id|do_pause
c_func
(paren
r_int
id|amount
)paren
multiline_comment|/* Pause for amount*10 milliseconds */
(brace
r_int
r_int
id|the_time
op_assign
id|jiffies
op_plus
id|amount
suffix:semicolon
multiline_comment|/* 0.01 seconds per jiffy */
r_while
c_loop
(paren
id|jiffies
OL
id|the_time
)paren
suffix:semicolon
)brace
DECL|function|fdomain_make_bus_idle
r_inline
r_static
r_void
id|fdomain_make_bus_idle
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|Data_Mode_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|1
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
)brace
DECL|function|fdomain_is_valid_port
r_static
r_int
id|fdomain_is_valid_port
c_func
(paren
r_int
id|port
)paren
(brace
r_int
id|options
suffix:semicolon
macro_line|#if DEBUG_DETECT 
id|printk
c_func
(paren
l_string|&quot; (%x%x),&quot;
comma
id|inb
c_func
(paren
id|port
op_plus
id|MSB_ID_Code
)paren
comma
id|inb
c_func
(paren
id|port
op_plus
id|LSB_ID_Code
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* The MCA ID is a unique id for each MCA compatible board.  We&n;      are using ISA boards, but Future Domain provides the MCA ID&n;      anyway.  We can use this ID to ensure that this is a Future&n;      Domain TMC-1660/TMC-1680.&n;    */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port
op_plus
id|LSB_ID_Code
)paren
op_ne
l_int|0xe9
)paren
(brace
multiline_comment|/* test for 0x6127 id */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port
op_plus
id|LSB_ID_Code
)paren
op_ne
l_int|0x27
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port
op_plus
id|MSB_ID_Code
)paren
op_ne
l_int|0x61
)paren
r_return
l_int|0
suffix:semicolon
id|chip
op_assign
id|tmc1800
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* test for 0xe960 id */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port
op_plus
id|MSB_ID_Code
)paren
op_ne
l_int|0x60
)paren
r_return
l_int|0
suffix:semicolon
id|chip
op_assign
id|tmc18c50
suffix:semicolon
)brace
multiline_comment|/* We have a valid MCA ID for a TMC-1660/TMC-1680 Future Domain board.&n;      Now, check to be sure the bios_base matches these ports.&n;      If someone was unlucky enough to have purchased more than one&n;      Future Domain board, then they will have to modify this code, as&n;      we only detect one board here.  [The one with the lowest bios_base.]&n;    */
id|options
op_assign
id|inb
c_func
(paren
id|port
op_plus
id|Option_Select
)paren
suffix:semicolon
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; Options = %x,&quot;
comma
id|options
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|addresses
(braket
(paren
id|options
op_amp
l_int|0xc0
)paren
op_rshift
l_int|6
)braket
op_ne
id|bios_base
)paren
r_return
l_int|0
suffix:semicolon
id|interrupt_level
op_assign
id|ints
(braket
(paren
id|options
op_amp
l_int|0x0e
)paren
op_rshift
l_int|1
)braket
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|fdomain_test_loopback
r_static
r_int
id|fdomain_test_loopback
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|255
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
id|i
comma
id|port_base
op_plus
id|Write_Loopback
)paren
suffix:semicolon
id|result
op_assign
id|inb
c_func
(paren
id|port_base
op_plus
id|Read_Loopback
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|result
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fdomain_16x0_detect
r_int
id|fdomain_16x0_detect
c_func
(paren
r_int
id|hostnum
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_struct
id|sigaction
id|sa
suffix:semicolon
r_int
id|retcode
suffix:semicolon
macro_line|#if DO_DETECT
r_const
r_int
id|buflen
op_assign
l_int|255
suffix:semicolon
id|Scsi_Cmnd
id|SCinit
suffix:semicolon
r_int
r_char
id|do_inquiry
(braket
)braket
op_assign
(brace
id|INQUIRY
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|buflen
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|do_request_sense
(braket
)braket
op_assign
(brace
id|REQUEST_SENSE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|buflen
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|do_read_capacity
(braket
)braket
op_assign
(brace
id|READ_CAPACITY
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|buf
(braket
id|buflen
)braket
suffix:semicolon
macro_line|#endif
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot;SCSI: fdomain_16x0_detect(),&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|bios_base
op_logical_and
id|i
OL
id|ADDRESS_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; %x(%x),&quot;
comma
(paren
r_int
)paren
id|addresses
(braket
id|i
)braket
comma
(paren
r_int
)paren
id|bios_base
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|bios_base
op_logical_and
id|j
OL
id|SIGNATURE_COUNT
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|addresses
(braket
id|i
)braket
op_plus
id|signatures
(braket
id|j
)braket
dot
id|sig_offset
)paren
comma
id|signatures
(braket
id|j
)braket
dot
id|signature
comma
id|signatures
(braket
id|j
)braket
dot
id|sig_length
)paren
)paren
(brace
id|bios_major
op_assign
id|signatures
(braket
id|j
)braket
dot
id|major_bios_version
suffix:semicolon
id|bios_minor
op_assign
id|signatures
(braket
id|j
)braket
dot
id|minor_bios_version
suffix:semicolon
id|bios_base
op_assign
id|addresses
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|bios_base
)paren
(brace
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; FAILED: NO BIOS&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The TMC-1660/TMC-1680 has a RAM area just after the BIOS ROM.&n;      Assuming the ROM is enabled (otherwise we wouldn&squot;t have been&n;      able to read the ROM signature :-), then the ROM sets up the&n;      RAM area with some magic numbers, such as a list of port&n;      base addresses and a list of the disk &quot;geometry&quot; reported to&n;      DOS (this geometry has nothing to do with physical geometry).&n;    */
id|port_base
op_assign
op_star
(paren
(paren
r_char
op_star
)paren
id|bios_base
op_plus
l_int|0x1fcc
)paren
op_plus
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|bios_base
op_plus
l_int|0x1fcd
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; %x,&quot;
comma
id|port_base
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|flag
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|flag
op_logical_and
id|i
OL
id|PORT_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|port_base
op_eq
id|ports
(braket
id|i
)braket
)paren
op_increment
id|flag
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flag
)paren
id|flag
op_assign
id|fdomain_is_valid_port
c_func
(paren
id|port_base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
multiline_comment|/* Cannot get port base from BIOS RAM */
multiline_comment|/* This is a bad sign.  It usually means that someone patched the&n;&t; BIOS signature list (the signatures variable) to contain a BIOS&n;&t; signature for a board *OTHER THAN* the TMC-1660/TMC-1680.&n;       */
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; RAM FAILED, &quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Anyway, the alternative to finding the address in the RAM is&n;&t; to just search through every possible port address for one&n;&t; that is attached to the Future Domain card.  Don&squot;t panic,&n;&t; though, about reading all these random port addresses--there&n;&t; are rumors that the Future Domain BIOS does something very&n;&t; similar.&n;       */
r_for
c_loop
(paren
id|flag
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|flag
op_logical_and
id|i
OL
id|PORT_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|port_base
op_assign
id|ports
(braket
id|i
)braket
suffix:semicolon
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; %x,&quot;
comma
id|port_base
)paren
suffix:semicolon
macro_line|#endif
id|flag
op_assign
id|fdomain_is_valid_port
c_func
(paren
id|port_base
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; FAILED: NO PORT&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Cannot find valid set of ports */
)brace
id|print_banner
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chip
op_eq
id|tmc18c50
)paren
id|printk
c_func
(paren
l_string|&quot;Future Domain WARNING: This driver may not work with the&quot;
l_string|&quot; TMC-18C50 chip!&bslash;n&quot;
l_string|&quot;                       Send mail to faith@cs.unc.edu&bslash;n&quot;
)paren
suffix:semicolon
id|Data_Mode_Cntl_port
op_assign
id|port_base
op_plus
id|Data_Mode_Cntl
suffix:semicolon
id|FIFO_Data_Count_port
op_assign
id|port_base
op_plus
id|FIFO_Data_Count
suffix:semicolon
id|Interrupt_Cntl_port
op_assign
id|port_base
op_plus
id|Interrupt_Cntl
suffix:semicolon
id|Interrupt_Mask_port
op_assign
id|port_base
op_plus
id|Interrupt_Mask
suffix:semicolon
id|Read_FIFO_port
op_assign
id|port_base
op_plus
id|Read_FIFO
suffix:semicolon
id|Read_SCSI_Data_port
op_assign
id|port_base
op_plus
id|Read_SCSI_Data
suffix:semicolon
id|SCSI_Cntl_port
op_assign
id|port_base
op_plus
id|SCSI_Cntl
suffix:semicolon
id|SCSI_Data_NoACK_port
op_assign
id|port_base
op_plus
id|SCSI_Data_NoACK
suffix:semicolon
id|SCSI_Status_port
op_assign
id|port_base
op_plus
id|SCSI_Status
suffix:semicolon
id|TMC_Cntl_port
op_assign
id|port_base
op_plus
id|TMC_Cntl
suffix:semicolon
id|TMC_Status_port
op_assign
id|port_base
op_plus
id|TMC_Status
suffix:semicolon
id|Write_FIFO_port
op_assign
id|port_base
op_plus
id|Write_FIFO
suffix:semicolon
id|Write_SCSI_Data_port
op_assign
id|port_base
op_plus
id|Write_SCSI_Data
suffix:semicolon
id|fdomain_16x0_reset
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdomain_test_loopback
c_func
(paren
)paren
)paren
(brace
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot;SCSI: LOOPBACK TEST FAILED, FAILING DETECT!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if DO_DETECT
multiline_comment|/* These routines are here because of the way the SCSI bus behaves after&n;      a reset.  This appropriate behavior was not handled correctly by the&n;      higher level SCSI routines when I first wrote this driver.  Now,&n;      however, correct scan routines are part of scsi.c and these routines&n;      are no longer needed.  However, this code is still good for&n;      debugging.&n;    */
id|SCinit.request_buffer
op_assign
id|SCinit.buffer
op_assign
id|buf
suffix:semicolon
id|SCinit.request_bufflen
op_assign
id|SCinit.bufflen
op_assign
r_sizeof
(paren
id|buf
)paren
op_minus
l_int|1
suffix:semicolon
id|SCinit.use_sg
op_assign
l_int|0
suffix:semicolon
id|SCinit.lun
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Future Domain detection routine scanning for devices:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|SCinit.target
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|6
)paren
r_continue
suffix:semicolon
multiline_comment|/* The host adapter is at SCSI ID 6 */
id|memcpy
c_func
(paren
id|SCinit.cmnd
comma
id|do_request_sense
comma
r_sizeof
(paren
id|do_request_sense
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|fdomain_16x0_command
c_func
(paren
op_amp
id|SCinit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
)paren
(brace
id|memcpy
c_func
(paren
id|SCinit.cmnd
comma
id|do_inquiry
comma
r_sizeof
(paren
id|do_inquiry
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|fdomain_16x0_command
c_func
(paren
op_amp
id|SCinit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;     SCSI ID %d: &quot;
comma
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|8
suffix:semicolon
id|j
OL
(paren
id|buf
(braket
l_int|4
)braket
OL
l_int|32
ques
c_cond
id|buf
(braket
l_int|4
)braket
suffix:colon
l_int|32
)paren
suffix:semicolon
id|j
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|buf
(braket
id|j
)braket
op_ge
l_int|20
ques
c_cond
id|buf
(braket
id|j
)braket
suffix:colon
l_char|&squot; &squot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|SCinit.cmnd
comma
id|do_read_capacity
comma
r_sizeof
(paren
id|do_read_capacity
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|fdomain_16x0_command
c_func
(paren
op_amp
id|SCinit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
)paren
(brace
r_int
r_int
id|blocks
comma
id|size
comma
id|capacity
suffix:semicolon
id|blocks
op_assign
(paren
id|buf
(braket
l_int|0
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|buf
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|buf
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
id|buf
(braket
l_int|3
)braket
suffix:semicolon
id|size
op_assign
(paren
id|buf
(braket
l_int|4
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|buf
(braket
l_int|5
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|buf
(braket
l_int|6
)braket
op_lshift
l_int|8
)paren
op_or
id|buf
(braket
l_int|7
)braket
suffix:semicolon
id|capacity
op_assign
op_plus
(paren
op_plus
(paren
id|blocks
op_div
l_int|1024L
)paren
op_star
op_plus
(paren
id|size
op_star
l_int|10L
)paren
)paren
op_div
l_int|1024L
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%lu MB (%lu byte blocks)&quot;
comma
(paren
(paren
id|capacity
op_plus
l_int|5L
)paren
op_div
l_int|10L
)paren
comma
id|size
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|SCinit.cmnd
comma
id|do_request_sense
comma
r_sizeof
(paren
id|do_request_sense
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|fdomain_16x0_command
c_func
(paren
op_amp
id|SCinit
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|SCinit.cmnd
comma
id|do_request_sense
comma
r_sizeof
(paren
id|do_request_sense
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|fdomain_16x0_command
c_func
(paren
op_amp
id|SCinit
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
id|this_host
op_assign
id|hostnum
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|QUEUE
op_logical_or
op_logical_neg
id|interrupt_level
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain: *NO* interrupt level selected!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;               COMMAND QUEUEING DISABLED!&bslash;n&quot;
)paren
suffix:semicolon
id|can_queue
op_assign
id|scsi_hosts
(braket
id|this_host
)braket
dot
id|can_queue
op_assign
l_int|0
suffix:semicolon
id|scsi_hosts
(braket
id|this_host
)braket
dot
id|sg_tablesize
op_assign
id|SG_NONE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Register the IRQ with the kernel */
id|sa.sa_handler
op_assign
id|fdomain_16x0_intr
suffix:semicolon
id|sa.sa_flags
op_assign
id|SA_INTERRUPT
suffix:semicolon
id|sa.sa_mask
op_assign
l_int|0
suffix:semicolon
id|sa.sa_restorer
op_assign
l_int|NULL
suffix:semicolon
id|retcode
op_assign
id|irqaction
c_func
(paren
id|interrupt_level
comma
op_amp
id|sa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retcode
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|retcode
op_eq
op_minus
id|EINVAL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain: IRQ %d is bad!&bslash;n&quot;
comma
id|interrupt_level
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;               This shouldn&squot;t happen!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;               Send mail to faith@cs.unc.edu&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|retcode
op_eq
op_minus
id|EBUSY
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain: IRQ %d is already in use!&bslash;n&quot;
comma
id|interrupt_level
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;               Please use another IRQ!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain: Error getting IRQ %d&bslash;n&quot;
comma
id|interrupt_level
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;               This shouldn&squot;t happen!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;               Send mail to faith@cs.unc.edu&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;               COMMAND QUEUEING DISABLED!&bslash;n&quot;
)paren
suffix:semicolon
id|can_queue
op_assign
id|scsi_hosts
(braket
id|this_host
)braket
dot
id|can_queue
op_assign
l_int|0
suffix:semicolon
id|scsi_hosts
(braket
id|this_host
)braket
dot
id|sg_tablesize
op_assign
id|SG_NONE
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain: IRQ %d requested from kernel&bslash;n&quot;
comma
id|interrupt_level
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|fdomain_16x0_info
r_const
r_char
op_star
id|fdomain_16x0_info
c_func
(paren
r_void
)paren
(brace
r_static
r_char
id|buffer
(braket
)braket
op_assign
l_string|&quot;Future Domain TMC-16x0 SCSI driver version &quot;
id|VERSION
l_string|&quot;&bslash;n&quot;
suffix:semicolon
r_return
id|buffer
suffix:semicolon
)brace
DECL|function|fdomain_arbitrate
r_static
r_int
id|fdomain_arbitrate
c_func
(paren
r_void
)paren
(brace
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;SCSI: fdomain_arbitrate()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
l_int|0x00
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Disable data drivers */
id|outb
c_func
(paren
l_int|0x40
comma
id|port_base
op_plus
id|SCSI_Data_NoACK
)paren
suffix:semicolon
multiline_comment|/* Set our id bit */
id|outb
c_func
(paren
l_int|0x04
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Start arbitration */
id|timeout
op_assign
id|jiffies
op_plus
l_int|50
suffix:semicolon
multiline_comment|/* 500 mS */
r_while
c_loop
(paren
id|jiffies
OL
id|timeout
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|TMC_Status_port
)paren
suffix:semicolon
multiline_comment|/* Read adapter status */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x02
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Arbitration complete */
)brace
multiline_comment|/* Make bus idle */
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Arbitration failed, status = %x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot;SCSI (Future Domain): Arbitration failed, status = %x&quot;
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|fdomain_select
r_static
r_int
id|fdomain_select
c_func
(paren
r_int
id|target
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
multiline_comment|/* Send our address OR&squot;d with target address */
id|outb
c_func
(paren
l_int|0x40
op_or
(paren
l_int|1
op_lshift
id|target
)paren
comma
id|SCSI_Data_NoACK_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RESELECTION
op_logical_and
id|can_queue
)paren
id|outb
c_func
(paren
l_int|0x8a
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Bus Enable + Attention + Select */
r_else
id|outb
c_func
(paren
l_int|0x82
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Bus Enable + Select */
multiline_comment|/* Stop arbitration (also set FIFO for output and enable parity) */
id|outb
c_func
(paren
l_int|0xc0
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
l_int|25
suffix:semicolon
multiline_comment|/* 250mS */
r_while
c_loop
(paren
id|jiffies
OL
id|timeout
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
suffix:semicolon
multiline_comment|/* Read adapter status */
r_if
c_cond
(paren
id|status
op_amp
l_int|1
)paren
(brace
multiline_comment|/* Busy asserted */
multiline_comment|/* Enable SCSI Bus (on error, should make bus idle with 0) */
id|outb
c_func
(paren
l_int|0x80
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Make bus idle */
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
r_if
c_cond
(paren
op_logical_neg
id|target
)paren
id|printk
c_func
(paren
l_string|&quot;Selection failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
op_logical_neg
id|target
)paren
id|printk
c_func
(paren
l_string|&quot;SCSI (Future Domain): Selection failed&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|my_done
r_void
id|my_done
c_func
(paren
r_int
id|error
)paren
(brace
r_if
c_cond
(paren
id|in_command
)paren
(brace
id|in_command
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
id|current_SC-&gt;result
op_assign
id|error
suffix:semicolon
r_if
c_cond
(paren
id|current_SC-&gt;scsi_done
)paren
id|current_SC
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|current_SC
)paren
suffix:semicolon
r_else
id|panic
c_func
(paren
l_string|&quot;SCSI (Future Domain): current_SC-&gt;scsi_done() == NULL&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|panic
c_func
(paren
l_string|&quot;SCSI (Future Domain): my_done() called outside of command&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#if DEBUG_RACE
id|in_interrupt_flag
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
)brace
DECL|function|fdomain_16x0_intr
r_void
id|fdomain_16x0_intr
c_func
(paren
r_int
id|unused
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_int
id|data_count
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* We usually have one spurious interrupt after each command.  Ignore it. */
r_if
c_cond
(paren
op_logical_neg
id|in_command
op_logical_or
op_logical_neg
id|current_SC
)paren
(brace
multiline_comment|/* Spurious interrupt */
r_return
suffix:semicolon
)brace
macro_line|#if DEBUG_RACE
op_increment
id|in_interrupt_flag
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|aborted
)paren
(brace
macro_line|#if EVERY_ACCESS
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
(paren
id|in_other
op_logical_or
id|disconnect
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;aborted (%s) = %d, &quot;
comma
id|current_SC-&gt;SCp.phase
op_amp
id|in_other
ques
c_cond
l_string|&quot;in_other&quot;
suffix:colon
l_string|&quot;disconnect&quot;
comma
id|current_SC-&gt;result
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;aborted = %d, &quot;
comma
id|current_SC-&gt;result
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Force retry for timeouts after selection complete */
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
(paren
id|in_other
op_logical_or
id|disconnect
)paren
)paren
(brace
id|fdomain_16x0_reset
c_func
(paren
)paren
suffix:semicolon
id|my_done
c_func
(paren
id|DID_RESET
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
r_else
(brace
id|my_done
c_func
(paren
id|current_SC-&gt;result
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
macro_line|#if RESELECTION
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|disconnect
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; RECON %x &quot;
comma
id|inb
c_func
(paren
id|SCSI_Data_NoACK_port
)paren
)paren
suffix:semicolon
id|current_SC-&gt;SCp.phase
op_assign
id|in_other
suffix:semicolon
id|outb
c_func
(paren
l_int|0x90
op_or
id|FIFO_COUNT
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x84
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
)paren
op_amp
l_int|0x20
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;s = %x, &quot;
comma
id|status
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0x80
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|in_arbitration
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|TMC_Status_port
)paren
suffix:semicolon
multiline_comment|/* Read adapter status */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
l_int|0x02
)paren
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; AFAIL &quot;
)paren
suffix:semicolon
macro_line|#endif
id|my_done
c_func
(paren
id|DID_BUS_BUSY
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|current_SC-&gt;SCp.phase
op_assign
id|in_selection
suffix:semicolon
id|outb
c_func
(paren
l_int|0x40
op_or
id|FIFO_COUNT
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x40
op_or
(paren
l_int|1
op_lshift
id|current_SC-&gt;target
)paren
comma
id|SCSI_Data_NoACK_port
)paren
suffix:semicolon
macro_line|#if RESELECTION
id|outb
c_func
(paren
l_int|0x8a
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Bus Enable + Attention + Select */
macro_line|#else
id|outb
c_func
(paren
l_int|0x82
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Bus Enable + Select */
macro_line|#endif
multiline_comment|/* Stop arbitration (also set FIFO for output and enable parity) */
id|outb
c_func
(paren
l_int|0xd0
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
macro_line|#if DEBUG_RACE
id|in_interrupt_flag
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|in_selection
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
l_int|0x01
)paren
)paren
(brace
multiline_comment|/* Try again, for slow devices */
r_if
c_cond
(paren
id|fdomain_select
c_func
(paren
id|current_SC-&gt;target
)paren
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; SFAIL &quot;
)paren
suffix:semicolon
macro_line|#endif
id|my_done
c_func
(paren
id|DID_NO_CONNECT
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; AltSel &quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Stop arbitration (also set FIFO for output and enable parity) */
id|outb
c_func
(paren
l_int|0xd0
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
)brace
)brace
id|current_SC-&gt;SCp.phase
op_assign
id|in_other
suffix:semicolon
id|outb
c_func
(paren
l_int|0x90
op_or
id|FIFO_COUNT
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
macro_line|#if RESELECTION
id|outb
c_func
(paren
l_int|0x88
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
macro_line|#else
id|outb
c_func
(paren
l_int|0x80
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if DEBUG_RACE
id|in_interrupt_flag
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* current_SC-&gt;SCp.phase == in_other: this is the body of the routine */
r_switch
c_cond
(paren
id|current_SC-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0x04
suffix:colon
r_case
l_int|0x07
suffix:colon
r_case
l_int|0x0a
suffix:colon
r_case
l_int|0x15
suffix:colon
r_case
l_int|0x2a
suffix:colon
r_case
l_int|0x2e
suffix:colon
r_case
l_int|0x3b
suffix:colon
r_case
l_int|0xea
suffix:colon
r_case
l_int|0x3f
suffix:colon
r_while
c_loop
(paren
(paren
id|data_count
op_assign
l_int|0x2000
op_minus
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
)paren
OG
l_int|512
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;DC=%d, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
OG
id|current_SC-&gt;SCp.this_residual
)paren
id|data_count
op_assign
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
r_if
c_cond
(paren
id|data_count
OG
l_int|0
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;%d OUT, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
id|outb
c_func
(paren
op_star
id|current_SC-&gt;SCp.ptr
op_increment
comma
id|Write_FIFO_port
)paren
suffix:semicolon
op_decrement
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
id|outsw
c_func
(paren
id|current_SC-&gt;SCp.ptr
comma
id|data_count
comma
id|Write_FIFO_port
)paren
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_sub_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.this_residual
)paren
(brace
r_if
c_cond
(paren
id|current_SC-&gt;SCp.buffers_residual
)paren
(brace
op_decrement
id|current_SC-&gt;SCp.buffers_residual
suffix:semicolon
op_increment
id|current_SC-&gt;SCp.buffer
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;SCp.buffer-&gt;length
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.have_data_in
)paren
(brace
id|outb
c_func
(paren
l_int|0x90
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
op_increment
id|current_SC-&gt;SCp.have_data_in
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
(paren
id|data_count
op_assign
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
)paren
op_ne
l_int|0
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;DC=%d, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
OG
id|current_SC-&gt;SCp.this_residual
)paren
id|data_count
op_assign
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
r_if
c_cond
(paren
id|data_count
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;%d IN, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
op_star
id|current_SC-&gt;SCp.ptr
op_increment
op_assign
id|inb
c_func
(paren
id|Read_FIFO_port
)paren
suffix:semicolon
op_decrement
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Number of words */
id|insw
c_func
(paren
id|current_SC-&gt;SCp.ptr
comma
id|data_count
comma
id|Read_FIFO_port
)paren
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_sub_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.this_residual
op_logical_and
id|current_SC-&gt;SCp.buffers_residual
)paren
(brace
op_decrement
id|current_SC-&gt;SCp.buffers_residual
suffix:semicolon
op_increment
id|current_SC-&gt;SCp.buffer
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;SCp.buffer-&gt;length
suffix:semicolon
)brace
)brace
)brace
r_break
suffix:semicolon
)brace
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x10
)paren
(brace
multiline_comment|/* REQ */
r_switch
c_cond
(paren
id|status
op_amp
l_int|0x0e
)paren
(brace
r_case
l_int|0x08
suffix:colon
multiline_comment|/* COMMAND OUT */
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.sent_command
)paren
(brace
r_int
id|i
suffix:semicolon
op_increment
id|current_SC-&gt;SCp.sent_command
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|COMMAND_SIZE
c_func
(paren
id|current_SC-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
id|current_SC-&gt;cmnd
(braket
id|i
)braket
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;CMD = %x,&quot;
comma
id|current_SC-&gt;cmnd
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
macro_line|#else
id|outb
c_func
(paren
id|current_SC-&gt;cmnd
(braket
id|current_SC-&gt;SCp.sent_command
op_increment
)braket
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;CMD = %x,&quot;
comma
id|current_SC-&gt;cmnd
(braket
id|current_SC-&gt;SCp.sent_command
op_minus
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x0c
suffix:colon
multiline_comment|/* STATUS IN */
id|current_SC-&gt;SCp.Status
op_assign
id|inb
c_func
(paren
id|Read_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Status = %x, &quot;
comma
id|current_SC-&gt;SCp.Status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
id|current_SC-&gt;SCp.Status
op_logical_and
id|current_SC-&gt;SCp.Status
op_ne
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI (Future Domain): target = %d, command = %x, &quot;
l_string|&quot;Status = %x&bslash;n&quot;
comma
id|current_SC-&gt;target
comma
id|current_SC-&gt;cmnd
(braket
l_int|0
)braket
comma
id|current_SC-&gt;SCp.Status
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x0a
suffix:colon
multiline_comment|/* MESSAGE OUT */
macro_line|#if RESELECTION
r_if
c_cond
(paren
op_logical_neg
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|sent_ident
)paren
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; IDENT &quot;
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
l_int|0x80
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
id|IDENTIFY
c_func
(paren
l_int|1
comma
l_int|0
)paren
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
id|current_SC-&gt;SCp.phase
op_or_assign
id|sent_ident
suffix:semicolon
)brace
r_else
macro_line|#else
id|outb
c_func
(paren
id|MESSAGE_REJECT
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
multiline_comment|/* Reject */
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x0e
suffix:colon
multiline_comment|/* MESSAGE IN */
id|current_SC-&gt;SCp.Message
op_assign
id|inb
c_func
(paren
id|Read_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Message = %x, &quot;
comma
id|current_SC-&gt;SCp.Message
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.Message
)paren
op_increment
id|done
suffix:semicolon
macro_line|#if RESELECTION
r_if
c_cond
(paren
id|current_SC-&gt;SCp.Message
op_eq
id|DISCONNECT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; DISCON &quot;
)paren
suffix:semicolon
id|current_SC-&gt;SCp.phase
op_assign
id|disconnect
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if DEBUG_MESSAGES || EVERY_ACCESS
r_if
c_cond
(paren
id|current_SC-&gt;SCp.Message
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI (Future Domain): Message = %x&bslash;n&quot;
comma
id|current_SC-&gt;SCp.Message
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|done
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; ** IN DONE ** &quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|current_SC-&gt;SCp.have_data_in
)paren
(brace
r_while
c_loop
(paren
(paren
id|data_count
op_assign
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|data_count
OG
id|current_SC-&gt;SCp.this_residual
)paren
id|data_count
op_assign
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
r_if
c_cond
(paren
id|data_count
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;%d IN, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
op_star
id|current_SC-&gt;SCp.ptr
op_increment
op_assign
id|inb
c_func
(paren
id|Read_FIFO_port
)paren
suffix:semicolon
op_decrement
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Number of words */
id|insw
c_func
(paren
id|current_SC-&gt;SCp.ptr
comma
id|data_count
comma
id|Read_FIFO_port
)paren
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_sub_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.this_residual
op_logical_and
id|current_SC-&gt;SCp.buffers_residual
)paren
(brace
op_decrement
id|current_SC-&gt;SCp.buffers_residual
suffix:semicolon
op_increment
id|current_SC-&gt;SCp.buffer
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;SCp.buffer-&gt;length
suffix:semicolon
)brace
)brace
)brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;AFTER DATA GET&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
id|current_SC-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_and
op_logical_neg
id|current_SC-&gt;SCp.Status
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|current_SC-&gt;request_buffer
op_plus
l_int|2
)paren
)paren
op_amp
l_int|0x0f
)paren
(brace
r_int
r_char
id|key
suffix:semicolon
r_int
r_char
id|code
suffix:semicolon
id|key
op_assign
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|current_SC-&gt;request_buffer
op_plus
l_int|2
)paren
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|code
op_assign
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|current_SC-&gt;request_buffer
op_plus
l_int|12
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|key
op_eq
id|UNIT_ATTENTION
op_logical_and
(paren
id|code
op_eq
l_int|0x29
op_logical_or
op_logical_neg
id|code
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|key
op_eq
id|ILLEGAL_REQUEST
op_logical_and
(paren
id|code
op_eq
l_int|0x25
op_logical_or
op_logical_neg
id|code
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;SCSI REQUEST SENSE: Key = %x, Code = %x&bslash;n&quot;
comma
id|key
comma
id|code
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;BEFORE MY_DONE. . .&quot;
)paren
suffix:semicolon
macro_line|#endif
id|my_done
c_func
(paren
(paren
id|current_SC-&gt;SCp.Status
op_amp
l_int|0xff
)paren
op_or
(paren
(paren
id|current_SC-&gt;SCp.Message
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|DID_OK
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;RETURNING.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|disconnect
)paren
(brace
id|outb
c_func
(paren
l_int|0xd0
op_or
id|FIFO_COUNT
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
l_int|0x90
op_or
id|FIFO_COUNT
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
)brace
)brace
macro_line|#if DEBUG_RACE
id|in_interrupt_flag
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
DECL|function|fdomain_16x0_queue
r_int
id|fdomain_16x0_queue
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_if
c_cond
(paren
id|in_command
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;SCSI (Future Domain): fdomain_16x0_queue() NOT REENTRANT!&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;queue: target = %d cmnd = 0x%02x pieces = %d size = %u&bslash;n&quot;
comma
id|SCpnt-&gt;target
comma
op_star
(paren
r_int
r_char
op_star
)paren
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;use_sg
comma
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
macro_line|#endif
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
id|current_SC
op_assign
id|SCpnt
suffix:semicolon
multiline_comment|/* Save this for the done function */
id|current_SC-&gt;scsi_done
op_assign
id|done
suffix:semicolon
multiline_comment|/* Initialize static data */
r_if
c_cond
(paren
id|current_SC-&gt;use_sg
)paren
(brace
id|current_SC-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|current_SC-&gt;request_buffer
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|current_SC-&gt;SCp.buffers_residual
op_assign
id|current_SC-&gt;use_sg
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;request_buffer
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;request_bufflen
suffix:semicolon
id|current_SC-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|current_SC-&gt;SCp.buffers_residual
op_assign
l_int|0
suffix:semicolon
)brace
id|current_SC-&gt;SCp.Status
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.Message
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.have_data_in
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.sent_command
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.phase
op_assign
id|in_arbitration
suffix:semicolon
multiline_comment|/* Start arbitration */
id|outb
c_func
(paren
l_int|0x00
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Disable data drivers */
id|outb
c_func
(paren
l_int|0x40
comma
id|SCSI_Data_NoACK_port
)paren
suffix:semicolon
multiline_comment|/* Set our id bit */
op_increment
id|in_command
suffix:semicolon
id|outb
c_func
(paren
l_int|0x20
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x14
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Start arbitration */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fdomain_16x0_command
r_int
id|fdomain_16x0_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_const
r_char
op_star
id|cmd_pt
op_assign
id|SCpnt-&gt;cmnd
suffix:semicolon
r_const
r_char
op_star
id|the_command
op_assign
id|SCpnt-&gt;cmnd
suffix:semicolon
r_int
r_char
op_star
id|out_buf_pt
op_assign
id|SCpnt-&gt;request_buffer
suffix:semicolon
r_int
r_char
op_star
id|in_buf_pt
op_assign
id|SCpnt-&gt;request_buffer
suffix:semicolon
r_int
r_char
id|target
op_assign
id|SCpnt-&gt;target
suffix:semicolon
r_void
op_star
id|buff
op_assign
id|SCpnt-&gt;request_buffer
suffix:semicolon
r_int
id|bufflen
op_assign
id|SCpnt-&gt;request_bufflen
suffix:semicolon
r_int
id|Status
op_assign
l_int|0
suffix:semicolon
r_int
id|Message
op_assign
l_int|0
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_int
id|data_sent
op_assign
l_int|0
suffix:semicolon
r_int
id|data_count
suffix:semicolon
r_int
id|have_data_in
op_assign
l_int|0
suffix:semicolon
id|current_SC
op_assign
id|SCpnt
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;fdomain_command(%d, %x): &quot;
comma
id|target
comma
(paren
r_int
r_char
)paren
op_star
id|the_command
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|fdomain_arbitrate
c_func
(paren
)paren
)paren
(brace
macro_line|#if ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot;, target = %d, command = %x&bslash;n&quot;
comma
id|target
comma
(paren
r_int
r_char
)paren
op_star
id|the_command
)paren
suffix:semicolon
macro_line|#endif
r_return
id|DID_TIME_OUT
op_lshift
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fdomain_select
c_func
(paren
id|target
)paren
)paren
(brace
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
op_logical_neg
id|target
)paren
id|printk
c_func
(paren
l_string|&quot;, target = %d, command = %x&bslash;n&quot;
comma
id|target
comma
(paren
r_int
r_char
)paren
op_star
id|the_command
)paren
suffix:semicolon
macro_line|#endif
r_return
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
)brace
id|timeout
op_assign
id|jiffies
op_plus
l_int|500
suffix:semicolon
multiline_comment|/* 5000 mS -- For Maxtor after a RST */
id|current_SC-&gt;SCp.phase
op_assign
id|non_queueing
suffix:semicolon
r_switch
c_cond
(paren
(paren
r_int
r_char
)paren
op_star
id|the_command
)paren
(brace
r_case
l_int|0x04
suffix:colon
r_case
l_int|0x07
suffix:colon
r_case
l_int|0x0a
suffix:colon
r_case
l_int|0x15
suffix:colon
r_case
l_int|0x2a
suffix:colon
r_case
l_int|0x2e
suffix:colon
r_case
l_int|0x3b
suffix:colon
r_case
l_int|0xea
suffix:colon
r_case
l_int|0x3f
suffix:colon
id|data_count
op_assign
l_int|0x2000
op_minus
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bufflen
op_minus
id|data_sent
OL
id|data_count
)paren
id|data_count
op_assign
id|bufflen
op_minus
id|data_sent
suffix:semicolon
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
id|outb
c_func
(paren
op_star
id|out_buf_pt
op_increment
comma
id|Write_FIFO_port
)paren
suffix:semicolon
op_increment
id|data_sent
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
id|outsw
c_func
(paren
id|out_buf_pt
comma
id|data_count
comma
id|Write_FIFO_port
)paren
suffix:semicolon
id|out_buf_pt
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
id|data_sent
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|outb
c_func
(paren
l_int|0x80
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
op_increment
id|have_data_in
suffix:semicolon
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
(paren
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
)paren
op_amp
l_int|1
)paren
op_logical_and
op_logical_neg
id|done
op_logical_and
op_logical_neg
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|aborted
)paren
op_logical_and
id|jiffies
OL
id|timeout
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
l_int|0x10
)paren
(brace
multiline_comment|/* REQ */
r_switch
c_cond
(paren
id|status
op_amp
l_int|0x0e
)paren
(brace
r_case
l_int|0x00
suffix:colon
multiline_comment|/* DATA OUT */
id|data_count
op_assign
l_int|0x2000
op_minus
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bufflen
op_minus
id|data_sent
OL
id|data_count
)paren
id|data_count
op_assign
id|bufflen
op_minus
id|data_sent
suffix:semicolon
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
id|outb
c_func
(paren
op_star
id|out_buf_pt
op_increment
comma
id|Write_FIFO_port
)paren
suffix:semicolon
op_increment
id|data_sent
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
id|outsw
c_func
(paren
id|out_buf_pt
comma
id|data_count
comma
id|Write_FIFO_port
)paren
suffix:semicolon
id|out_buf_pt
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
id|data_sent
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x04
suffix:colon
multiline_comment|/* DATA IN */
r_if
c_cond
(paren
op_logical_neg
id|have_data_in
)paren
(brace
id|outb
c_func
(paren
l_int|0x80
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
op_increment
id|have_data_in
suffix:semicolon
)brace
id|data_count
op_assign
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
op_star
id|in_buf_pt
op_increment
op_assign
id|inb
c_func
(paren
id|Read_FIFO_port
)paren
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Number of words */
id|insw
c_func
(paren
id|in_buf_pt
comma
id|data_count
comma
id|Read_FIFO_port
)paren
suffix:semicolon
id|in_buf_pt
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x08
suffix:colon
multiline_comment|/* COMMAND OUT */
id|outb
c_func
(paren
op_star
id|cmd_pt
op_increment
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;%x,&quot;
comma
(paren
r_int
r_char
)paren
id|cmd_pt
(braket
op_minus
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x0c
suffix:colon
multiline_comment|/* STATUS IN */
id|Status
op_assign
id|inb
c_func
(paren
id|Read_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Status = %x, &quot;
comma
id|Status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
id|Status
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI (Future Domain): target = %d, command = %x, &quot;
l_string|&quot;Status = %x&bslash;n&quot;
comma
id|target
comma
(paren
r_int
r_char
)paren
op_star
id|the_command
comma
id|Status
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x0a
suffix:colon
multiline_comment|/* MESSAGE OUT */
id|outb
c_func
(paren
l_int|0x07
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
multiline_comment|/* Reject */
r_break
suffix:semicolon
r_case
l_int|0x0e
suffix:colon
multiline_comment|/* MESSAGE IN */
id|Message
op_assign
id|inb
c_func
(paren
id|Read_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Message = %x, &quot;
comma
id|Message
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|Message
)paren
op_increment
id|done
suffix:semicolon
r_if
c_cond
(paren
id|Message
op_eq
id|DISCONNECT
)paren
id|printk
c_func
(paren
l_string|&quot;DISCONNECT&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|jiffies
op_ge
id|timeout
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Time out, status = %x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot;SCSI (Future Domain): &quot;
l_string|&quot;Time out, status = %x (target = %d, command = %x)&bslash;n&quot;
comma
id|status
comma
id|target
comma
(paren
r_int
r_char
)paren
op_star
id|the_command
)paren
suffix:semicolon
macro_line|#endif
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
r_return
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|aborted
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Aborted&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot;SCSI (Future Domain): Aborted (command = %x)&bslash;n&quot;
comma
(paren
r_int
r_char
)paren
op_star
id|the_command
)paren
suffix:semicolon
macro_line|#endif
id|fdomain_16x0_reset
c_func
(paren
)paren
suffix:semicolon
r_return
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|have_data_in
)paren
(brace
r_while
c_loop
(paren
(paren
id|data_count
op_assign
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
op_star
id|in_buf_pt
op_increment
op_assign
id|inb
c_func
(paren
id|Read_FIFO_port
)paren
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Number of words */
id|insw
c_func
(paren
id|in_buf_pt
comma
id|data_count
comma
id|Read_FIFO_port
)paren
suffix:semicolon
id|in_buf_pt
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
)brace
)brace
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Retcode = %x&bslash;n&quot;
comma
(paren
id|Status
op_amp
l_int|0xff
)paren
op_or
(paren
(paren
id|Message
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|DID_OK
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
op_star
id|the_command
op_eq
id|REQUEST_SENSE
op_logical_and
op_logical_neg
id|Status
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|buff
op_plus
l_int|2
)paren
)paren
op_amp
l_int|0x0f
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI REQUEST SENSE: Sense Key = %x, Sense Code = %x&bslash;n&quot;
comma
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|buff
op_plus
l_int|2
)paren
)paren
op_amp
l_int|0x0f
comma
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|buff
op_plus
l_int|12
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_return
(paren
id|Status
op_amp
l_int|0xff
)paren
op_or
(paren
(paren
id|Message
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|DID_OK
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
DECL|function|fdomain_16x0_abort
r_int
id|fdomain_16x0_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|code
)paren
(brace
macro_line|#if EVERY_ACCESS || ERRORS_ONLY || DEBUG_ABORT
id|printk
c_func
(paren
l_string|&quot;SCSI (Future Domain): Abort &quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if DEBUG_ABORT
id|print_banner
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|current_SC-&gt;SCp.phase
)paren
(brace
r_case
id|non_queueing
suffix:colon
id|printk
c_func
(paren
l_string|&quot;nonqueueing &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|in_arbitration
suffix:colon
id|printk
c_func
(paren
l_string|&quot;arbitration &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|in_selection
suffix:colon
id|printk
c_func
(paren
l_string|&quot;selection &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|in_other
suffix:colon
id|printk
c_func
(paren
l_string|&quot;other &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;unknown &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;phase = %d, target = %d cmnd = 0x%02x pieces = %d size = %u&bslash;n&quot;
comma
id|current_SC-&gt;SCp.phase
comma
id|current_SC-&gt;target
comma
op_star
(paren
r_int
r_char
op_star
)paren
id|current_SC-&gt;cmnd
comma
id|current_SC-&gt;use_sg
comma
id|current_SC-&gt;request_bufflen
)paren
suffix:semicolon
macro_line|#if DEBUG_RACE
id|printk
c_func
(paren
l_string|&quot;in_interrupt_flag = %d&bslash;n&quot;
comma
id|in_interrupt_flag
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;IMR = 0x%02x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
l_int|0x0a1
)paren
comma
id|inb
c_func
(paren
l_int|0x21
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0a
comma
l_int|0xa0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IRR = 0x%02x&quot;
comma
id|inb
c_func
(paren
l_int|0xa0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0a
comma
l_int|0x20
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
l_int|0x20
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0b
comma
l_int|0xa0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ISR = 0x%02x&quot;
comma
id|inb
c_func
(paren
l_int|0xa0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0b
comma
l_int|0x20
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
l_int|0x20
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SCSI Status    = %x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TMC Status     = %x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|TMC_Status_port
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Interrupt Mask = %x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|Interrupt_Mask_port
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Option Select  = %x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|port_base
op_plus
id|Option_Select
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chip
op_eq
id|tmc18c50
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FIFO Status    = %x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|port_base
op_plus
id|FIFO_Status
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Int. Condition = %x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|port_base
op_plus
id|Interrupt_Cond
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Configuration  = %x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|port_base
op_plus
id|Configuration
)paren
)paren
suffix:semicolon
)brace
macro_line|#else
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_command
)paren
(brace
macro_line|#if EVERY_ACCESS || ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot; (not in command)&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
macro_line|#if EVERY_ACCESS || ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot; code = %d&bslash;n&quot;
comma
id|code
)paren
suffix:semicolon
macro_line|#endif
)brace
id|current_SC-&gt;SCp.phase
op_or_assign
id|aborted
suffix:semicolon
id|current_SC-&gt;result
op_assign
id|code
ques
c_cond
id|code
suffix:colon
id|DID_ABORT
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Aborts are not done well. . . */
id|my_done
c_func
(paren
id|code
op_lshift
l_int|16
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fdomain_16x0_reset
r_int
id|fdomain_16x0_reset
c_func
(paren
r_void
)paren
(brace
macro_line|#if ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot;Future Domain: SCSI Bus Reset&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
l_int|1
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
id|do_pause
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
id|do_pause
c_func
(paren
l_int|115
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|Data_Mode_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fdomain_16x0_biosparam
r_int
id|fdomain_16x0_biosparam
c_func
(paren
r_int
id|size
comma
r_int
id|dev
comma
r_int
op_star
id|info
)paren
(brace
r_int
id|drive
suffix:semicolon
r_struct
id|drive_info
(brace
r_int
r_int
id|cylinders
suffix:semicolon
r_int
r_char
id|heads
suffix:semicolon
r_int
r_char
id|sectors
suffix:semicolon
)brace
op_star
id|i
suffix:semicolon
multiline_comment|/* NOTES:&n;      The RAM area starts at 0x1f00 from the bios_base address.&n;      The drive parameter table seems to start at 0x1f30.&n;      The first byte&squot;s purpose is not known.&n;      Next is the cylinder, head, and sector information.&n;      The last 4 bytes appear to be the drive&squot;s size in sectors.&n;      The other bytes in the drive parameter table are unknown.&n;      If anyone figures them out, please send me mail, and I will&n;      update these notes.&n;&n;      Tape drives do not get placed in this table.&n;&n;      There is another table at 0x1fea:&n;      If the byte is 0x01, then the SCSI ID is not in use.&n;      If the byte is 0x18 or 0x48, then the SCSI ID is in use,&n;      although tapes don&squot;t seem to be in this table.  I haven&squot;t&n;      seen any other numbers (in a limited sample).&n;&n;      0x1f2d is a drive count (i.e., not including tapes)&n;&n;      The table at 0x1fcc are I/O ports addresses for the various&n;      operations.  I calculate these by hand in this driver code.&n;    */
id|drive
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
op_div
l_int|16
suffix:semicolon
id|i
op_assign
(paren
r_struct
id|drive_info
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|bios_base
op_plus
l_int|0x1f31
op_plus
id|drive
op_star
l_int|25
)paren
suffix:semicolon
id|info
(braket
l_int|0
)braket
op_assign
id|i-&gt;heads
suffix:semicolon
id|info
(braket
l_int|1
)braket
op_assign
id|i-&gt;sectors
suffix:semicolon
id|info
(braket
l_int|2
)braket
op_assign
id|i-&gt;cylinders
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
