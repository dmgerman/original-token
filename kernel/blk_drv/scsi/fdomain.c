multiline_comment|/* fdomain.c -- Future Domain TMC-1660/TMC-1680 driver&n; * Created: Sun May  3 18:53:19 1992 by faith&n; * Revised: Wed Dec  9 21:34:53 1992 by root&n; * Author: Rickard E. Faith, faith@cs.unc.edu&n; * Copyright 1992 Rickard E. Faith&n; *&n; * $Log$&n;&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n;&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n;&n; * WARNING: THIS IS A BETA VERSION!&n; *          USE AT YOUR OWN RISK!&n; *          BACKUP YOUR SYSTEM BEFORE USING!&n;&n; * I would like to thank Maxtor, whose *free* 206 page manual on the LXT&n; * drives was very helpful: &quot;LXT SCSI Products: Specifications and OEM&n; * Technical Manual (Revision B/September 1991)&quot;&n;&n; * I wish that I could thank Future Domain for the necessary documentation,&n; * but I can&squot;t.  I used the $25 &quot;TMC-1800 SCSI Chip Specification&quot; document&n; * (FDC-1800T), which documents the *chip* and not the board.  Without it,&n; * I would have been totally lost, but it would have been nice to have some&n; * example source.  (The DOS BIOS source cost $250 and the UN*X driver&n; * source was $750 [both required a non-disclosure agreement].  Ever wonder&n; * why there are no freely available Future Domain drivers?)&n;&n; * Thanks to: Todd Carrico (todd@wutc.wustl.edu), Dan Poirier&n; * (poirier@cs.unc.edu ), Ken Corey (kenc@sol.acs.unt.edu), C. de Bruin&n; * (bruin@dutiba.tudelft.nl) and Sakari Aaltonen (sakaria@vipunen.hit.fi)&n; * for alpha testing.  Also thanks to Drew Eckhardt (drew@cs.colorado.edu)&n; * and Eric Youngdale (eric@tantalus.nrl.navy.mil) for answering questions,&n; * and to Doug Hoffman (hoffman@cs.unc.edu) for lending me SCSI devices to&n; * make the driver more robust. */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;../blk.h&quot;
macro_line|#include &quot;scsi.h&quot;
macro_line|#include &quot;hosts.h&quot;
macro_line|#include &quot;fdomain.h&quot;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
DECL|macro|VERSION
mdefine_line|#define VERSION          &quot;3.2&quot;&t;/* Change with each revision */
multiline_comment|/* START OF USER DEFINABLE OPTIONS */
DECL|macro|DEBUG
mdefine_line|#define DEBUG            1&t;/* Enable debugging output */
DECL|macro|ENABLE_PARITY
mdefine_line|#define ENABLE_PARITY    1&t;/* Enable SCSI Parity */
DECL|macro|QUEUE
mdefine_line|#define QUEUE            1&t;/* Enable command queueing */
DECL|macro|FIFO_COUNT
mdefine_line|#define FIFO_COUNT       2      /* Number of 512 byte blocks before INTR */
DECL|macro|DO_DETECT
mdefine_line|#define DO_DETECT        0&t;/* Do device detection here (see scsi.c) */
DECL|macro|RESELECTION
mdefine_line|#define RESELECTION      0&t;/* Support RESELECTION PHASE (NOT stable) */
multiline_comment|/* END OF USER DEFINABLE OPTIONS */
macro_line|#if DEBUG
DECL|macro|EVERY_ACCESS
mdefine_line|#define EVERY_ACCESS     0&t;/* Write a line on every scsi access */
DECL|macro|ERRORS_ONLY
mdefine_line|#define ERRORS_ONLY      1&t;/* Only write a line if there is an error */
DECL|macro|DEBUG_DETECT
mdefine_line|#define DEBUG_DETECT     0&t;/* Debug fdomain_16x0_detect() */
DECL|macro|DEBUG_MESSAGES
mdefine_line|#define DEBUG_MESSAGES   0      /* Debug MESSAGE IN PHASE */
DECL|macro|DEBUG_ABORT
mdefine_line|#define DEBUG_ABORT      1    /* Debug abort() routine */
macro_line|#else
DECL|macro|EVERY_ACCESS
mdefine_line|#define EVERY_ACCESS     0&t;/* LEAVE THESE ALONE--CHANGE THE ONES ABOVE */
DECL|macro|ERRORS_ONLY
mdefine_line|#define ERRORS_ONLY      0
DECL|macro|DEBUG_DETECT
mdefine_line|#define DEBUG_DETECT     0
DECL|macro|DEBUG_MESSAGES
mdefine_line|#define DEBUG_MESSAGES   0
DECL|macro|DEBUG_ABORT
mdefine_line|#define DEBUG_ABORT      0
macro_line|#endif
multiline_comment|/* Errors are reported on the line, so we don&squot;t need to report them again */
macro_line|#if EVERY_ACCESS
DECL|macro|ERRORS_ONLY
macro_line|#undef ERRORS_ONLY
DECL|macro|ERRORS_ONLY
mdefine_line|#define ERRORS_ONLY      0
macro_line|#endif
macro_line|#if ENABLE_PARITY
DECL|macro|PARITY_MASK
mdefine_line|#define PARITY_MASK      0x08
macro_line|#else
DECL|macro|PARITY_MASK
mdefine_line|#define PARITY_MASK      0x00
macro_line|#endif
DECL|variable|port_base
r_static
r_int
id|port_base
op_assign
l_int|0
suffix:semicolon
DECL|variable|bios_base
r_static
r_void
op_star
id|bios_base
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|interrupt_level
r_static
r_int
id|interrupt_level
op_assign
l_int|0
suffix:semicolon
DECL|variable|Data_Mode_Cntl_port
r_static
r_int
id|Data_Mode_Cntl_port
suffix:semicolon
DECL|variable|FIFO_Data_Count_port
r_static
r_int
id|FIFO_Data_Count_port
suffix:semicolon
DECL|variable|Interrupt_Cntl_port
r_static
r_int
id|Interrupt_Cntl_port
suffix:semicolon
DECL|variable|Interrupt_Mask_port
r_static
r_int
id|Interrupt_Mask_port
suffix:semicolon
DECL|variable|Read_FIFO_port
r_static
r_int
id|Read_FIFO_port
suffix:semicolon
DECL|variable|Read_SCSI_Data_port
r_static
r_int
id|Read_SCSI_Data_port
suffix:semicolon
DECL|variable|SCSI_Cntl_port
r_static
r_int
id|SCSI_Cntl_port
suffix:semicolon
DECL|variable|SCSI_Data_NoACK_port
r_static
r_int
id|SCSI_Data_NoACK_port
suffix:semicolon
DECL|variable|SCSI_Status_port
r_static
r_int
id|SCSI_Status_port
suffix:semicolon
DECL|variable|TMC_Cntl_port
r_static
r_int
id|TMC_Cntl_port
suffix:semicolon
DECL|variable|TMC_Status_port
r_static
r_int
id|TMC_Status_port
suffix:semicolon
DECL|variable|Write_FIFO_port
r_static
r_int
id|Write_FIFO_port
suffix:semicolon
DECL|variable|Write_SCSI_Data_port
r_static
r_int
id|Write_SCSI_Data_port
suffix:semicolon
DECL|variable|this_host
r_static
r_int
id|this_host
op_assign
l_int|0
suffix:semicolon
DECL|variable|can_queue
r_static
r_int
id|can_queue
op_assign
id|QUEUE
suffix:semicolon
DECL|variable|in_command
r_static
r_volatile
r_int
id|in_command
op_assign
l_int|0
suffix:semicolon
DECL|variable|in_interrupt_code
r_static
r_volatile
r_int
id|in_interrupt_code
op_assign
l_int|0
suffix:semicolon
DECL|variable|current_SC
r_static
id|Scsi_Cmnd
op_star
id|current_SC
op_assign
l_int|NULL
suffix:semicolon
DECL|enumerator|non_queueing
r_enum
(brace
id|non_queueing
op_assign
l_int|0x01
comma
DECL|enumerator|in_arbitration
id|in_arbitration
op_assign
l_int|0x02
comma
DECL|enumerator|in_selection
id|in_selection
op_assign
l_int|0x04
comma
DECL|enumerator|in_other
id|in_other
op_assign
l_int|0x08
comma
DECL|enumerator|disconnect
id|disconnect
op_assign
l_int|0x10
comma
DECL|enumerator|aborted
id|aborted
op_assign
l_int|0x20
comma
DECL|enumerator|sent_ident
id|sent_ident
op_assign
l_int|0x40
comma
)brace
suffix:semicolon
r_extern
r_void
id|fdomain_16x0_intr
c_func
(paren
r_int
id|unused
)paren
suffix:semicolon
DECL|enum|in_port_type
DECL|enumerator|Read_SCSI_Data
DECL|enumerator|SCSI_Status
DECL|enumerator|TMC_Status
r_enum
id|in_port_type
(brace
id|Read_SCSI_Data
op_assign
l_int|0
comma
id|SCSI_Status
op_assign
l_int|1
comma
id|TMC_Status
op_assign
l_int|2
comma
DECL|enumerator|LSB_ID_Code
DECL|enumerator|MSB_ID_Code
DECL|enumerator|Read_Loopback
id|LSB_ID_Code
op_assign
l_int|5
comma
id|MSB_ID_Code
op_assign
l_int|6
comma
id|Read_Loopback
op_assign
l_int|7
comma
DECL|enumerator|SCSI_Data_NoACK
DECL|enumerator|Interrupt_Mask
id|SCSI_Data_NoACK
op_assign
l_int|8
comma
id|Interrupt_Mask
op_assign
l_int|9
comma
DECL|enumerator|Option_Select
DECL|enumerator|Read_FIFO
id|Option_Select
op_assign
l_int|10
comma
id|Read_FIFO
op_assign
l_int|12
comma
DECL|enumerator|FIFO_Data_Count
id|FIFO_Data_Count
op_assign
l_int|14
)brace
suffix:semicolon
DECL|enum|out_port_type
DECL|enumerator|Write_SCSI_Data
DECL|enumerator|SCSI_Cntl
DECL|enumerator|Interrupt_Cntl
r_enum
id|out_port_type
(brace
id|Write_SCSI_Data
op_assign
l_int|0
comma
id|SCSI_Cntl
op_assign
l_int|1
comma
id|Interrupt_Cntl
op_assign
l_int|2
comma
DECL|enumerator|Data_Mode_Cntl
DECL|enumerator|TMC_Cntl
DECL|enumerator|Write_Loopback
id|Data_Mode_Cntl
op_assign
l_int|3
comma
id|TMC_Cntl
op_assign
l_int|4
comma
id|Write_Loopback
op_assign
l_int|7
comma
DECL|enumerator|Write_FIFO
id|Write_FIFO
op_assign
l_int|12
)brace
suffix:semicolon
DECL|variable|addresses
r_static
r_void
op_star
id|addresses
(braket
)braket
op_assign
(brace
(paren
r_void
op_star
)paren
l_int|0xc8000
comma
(paren
r_void
op_star
)paren
l_int|0xca000
comma
(paren
r_void
op_star
)paren
l_int|0xce000
comma
(paren
r_void
op_star
)paren
l_int|0xde000
)brace
suffix:semicolon
DECL|macro|ADDRESS_COUNT
mdefine_line|#define ADDRESS_COUNT (sizeof( addresses ) / sizeof( unsigned ))
DECL|variable|ports
r_static
r_int
r_int
id|ports
(braket
)braket
op_assign
(brace
l_int|0x140
comma
l_int|0x150
comma
l_int|0x160
comma
l_int|0x170
)brace
suffix:semicolon
DECL|macro|PORT_COUNT
mdefine_line|#define PORT_COUNT (sizeof( ports ) / sizeof( unsigned short ))
DECL|variable|ints
r_static
r_int
r_int
id|ints
(braket
)braket
op_assign
(brace
l_int|3
comma
l_int|5
comma
l_int|10
comma
l_int|11
comma
l_int|12
comma
l_int|14
comma
l_int|15
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n;&n;  READ THIS BEFORE YOU ADD A SIGNATURE!&n;&n;  READING THIS SHORT NOTE CAN SAVE YOU LOTS OF TIME!&n;&n;  READ EVERY WORD, ESPECIALLY THE WORD *NOT*&n;&n;  This driver works *ONLY* for Future Domain cards using the&n;  TMC-1800 chip.  This includes models TMC-1660 and TMC-1680&n;  *ONLY*.&n;&n;  The following BIOS signatures have been tried with this driver.  These&n;  signatures are for boards which do *NOT* work with this driver (but the&n;  first one should work with the Seagate driver):&n;&n;  FUTURE DOMAIN COPR. (C) 1986-1989 V6.0A7/28/90&n;&n;  FUTURE DOMAIN CORP. (C) 1986-1990 V6.0209/18/90&n;&n;  FUTURE DOMAIN CORP. (C) 1986-1990 V7.009/18/90&n;&n;  */
DECL|struct|signature
r_struct
id|signature
(brace
DECL|member|signature
r_char
op_star
id|signature
suffix:semicolon
DECL|member|sig_offset
r_int
id|sig_offset
suffix:semicolon
DECL|member|sig_length
r_int
id|sig_length
suffix:semicolon
DECL|variable|signatures
)brace
id|signatures
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1990 1800-V2.0 7/28/89&quot;
comma
l_int|5
comma
l_int|50
)brace
comma
(brace
l_string|&quot;FUTURE DOMAIN CORP. (C) 1986-1990 1800&quot;
comma
l_int|5
comma
l_int|37
)brace
comma
multiline_comment|/* READ NOTICE ABOVE *BEFORE* YOU WASTE YOUR TIME ADDING A SIGANTURE */
)brace
suffix:semicolon
DECL|macro|SIGNATURE_COUNT
mdefine_line|#define SIGNATURE_COUNT (sizeof( signatures ) / sizeof( struct signature ))
multiline_comment|/* These functions are based on include/asm/io.h */
DECL|function|inw
r_inline
r_static
r_int
r_int
id|inw
c_func
(paren
r_int
r_int
id|port
)paren
(brace
r_int
r_int
id|_v
suffix:semicolon
id|__asm__
r_volatile
(paren
l_string|&quot;inw %1,%0&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|_v
)paren
suffix:colon
l_string|&quot;d&quot;
(paren
(paren
r_int
r_int
)paren
id|port
)paren
)paren
suffix:semicolon
r_return
id|_v
suffix:semicolon
)brace
DECL|function|outw
r_inline
r_static
r_void
id|outw
c_func
(paren
r_int
r_int
id|value
comma
r_int
r_int
id|port
)paren
(brace
id|__asm__
r_volatile
(paren
l_string|&quot;outw %0,%1&quot;
op_scope_resolution
l_string|&quot;a&quot;
(paren
(paren
r_int
r_int
)paren
id|value
)paren
comma
l_string|&quot;d&quot;
(paren
(paren
r_int
r_int
)paren
id|port
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* These defines are copied from kernel/blk_drv/hd.c */
DECL|macro|insw
mdefine_line|#define insw( buf, count, port ) &bslash;&n;      __asm__ volatile &bslash;&n;      ( &quot;cld;rep;insw&quot;::&quot;d&quot; (port),&quot;D&quot; (buf),&quot;c&quot; (count):&quot;cx&quot;,&quot;di&quot; )
DECL|macro|outsw
mdefine_line|#define outsw( buf, count, port ) &bslash;&n;      __asm__ volatile &bslash;&n;      (&quot;cld;rep;outsw&quot;::&quot;d&quot; (port),&quot;S&quot; (buf),&quot;c&quot; (count):&quot;cx&quot;,&quot;si&quot;)
DECL|function|do_pause
r_static
r_void
id|do_pause
c_func
(paren
r_int
id|amount
)paren
multiline_comment|/* Pause for amount*10 milliseconds */
(brace
r_int
r_int
id|the_time
op_assign
id|jiffies
op_plus
id|amount
suffix:semicolon
multiline_comment|/* 0.01 seconds per jiffy */
r_while
c_loop
(paren
id|jiffies
OL
id|the_time
)paren
suffix:semicolon
)brace
DECL|function|fdomain_make_bus_idle
r_inline
r_static
r_void
id|fdomain_make_bus_idle
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|Data_Mode_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|1
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
)brace
DECL|function|fdomain_is_valid_port
r_static
r_int
id|fdomain_is_valid_port
c_func
(paren
r_int
id|port
)paren
(brace
r_int
id|options
suffix:semicolon
macro_line|#if DEBUG_DETECT 
id|printk
c_func
(paren
l_string|&quot; (%x%x),&quot;
comma
id|inb
c_func
(paren
id|port
op_plus
id|MSB_ID_Code
)paren
comma
id|inb
c_func
(paren
id|port
op_plus
id|LSB_ID_Code
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* The MCA ID is a unique id for each MCA compatible board.  We&n;      are using ISA boards, but Future Domain provides the MCA ID&n;      anyway.  We can use this ID to ensure that this is a Future&n;      Domain TMC-1660/TMC-1680.&n;    */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port
op_plus
id|LSB_ID_Code
)paren
op_ne
l_int|0xe9
)paren
(brace
multiline_comment|/* test for 0x6127 id */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port
op_plus
id|LSB_ID_Code
)paren
op_ne
l_int|0x27
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port
op_plus
id|MSB_ID_Code
)paren
op_ne
l_int|0x61
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* test for 0xe960 id */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|port
op_plus
id|MSB_ID_Code
)paren
op_ne
l_int|0x60
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We have a valid MCA ID for a TMC-1660/TMC-1680 Future Domain board.&n;      Now, check to be sure the bios_base matches these ports.&n;      If someone was unlucky enough to have purchased more than one&n;      Future Domain board, then they will have to modify this code, as&n;      we only detect one board here.  [The one with the lowest bios_base.]&n;    */
id|options
op_assign
id|inb
c_func
(paren
id|port
op_plus
id|Option_Select
)paren
suffix:semicolon
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; Options = %x,&quot;
comma
id|options
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|addresses
(braket
(paren
id|options
op_amp
l_int|0xc0
)paren
op_rshift
l_int|6
)braket
op_ne
id|bios_base
)paren
r_return
l_int|0
suffix:semicolon
id|interrupt_level
op_assign
id|ints
(braket
(paren
id|options
op_amp
l_int|0x0e
)paren
op_rshift
l_int|1
)braket
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|fdomain_test_loopback
r_static
r_int
id|fdomain_test_loopback
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|255
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
id|i
comma
id|port_base
op_plus
id|Write_Loopback
)paren
suffix:semicolon
id|result
op_assign
id|inb
c_func
(paren
id|port_base
op_plus
id|Read_Loopback
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|result
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fdomain_16x0_detect
r_int
id|fdomain_16x0_detect
c_func
(paren
r_int
id|hostnum
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|flag
suffix:semicolon
r_struct
id|sigaction
id|sa
suffix:semicolon
r_int
id|retcode
suffix:semicolon
macro_line|#if DO_DETECT
r_const
r_int
id|buflen
op_assign
l_int|255
suffix:semicolon
id|Scsi_Cmnd
id|SCinit
suffix:semicolon
r_int
r_char
id|do_inquiry
(braket
)braket
op_assign
(brace
id|INQUIRY
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|buflen
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|do_request_sense
(braket
)braket
op_assign
(brace
id|REQUEST_SENSE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|buflen
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|do_read_capacity
(braket
)braket
op_assign
(brace
id|READ_CAPACITY
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
r_char
id|buf
(braket
id|buflen
)braket
suffix:semicolon
macro_line|#endif
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot;SCSI: fdomain_16x0_detect(),&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|bios_base
op_logical_and
id|i
OL
id|ADDRESS_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; %x(%x),&quot;
comma
(paren
r_int
)paren
id|addresses
(braket
id|i
)braket
comma
(paren
r_int
)paren
id|bios_base
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|bios_base
op_logical_and
id|j
OL
id|SIGNATURE_COUNT
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|addresses
(braket
id|i
)braket
op_plus
id|signatures
(braket
id|j
)braket
dot
id|sig_offset
)paren
comma
id|signatures
(braket
id|j
)braket
dot
id|signature
comma
id|signatures
(braket
id|j
)braket
dot
id|sig_length
)paren
)paren
(brace
id|bios_base
op_assign
id|addresses
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|bios_base
)paren
(brace
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; FAILED: NO BIOS&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The TMC-1660/TMC-1680 has a RAM area just after the BIOS ROM.&n;      Assuming the ROM is enabled (otherwise we wouldn&squot;t have been&n;      able to read the ROM signature :-), then the ROM sets up the&n;      RAM area with some magic numbers, such as a list of port&n;      base addresses and a list of the disk &quot;geometry&quot; reported to&n;      DOS (this geometry has nothing to do with physical geometry).&n;    */
id|port_base
op_assign
op_star
(paren
(paren
r_char
op_star
)paren
id|bios_base
op_plus
l_int|0x1fcc
)paren
op_plus
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|bios_base
op_plus
l_int|0x1fcd
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; %x,&quot;
comma
id|port_base
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|flag
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|flag
op_logical_and
id|i
OL
id|PORT_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|port_base
op_eq
id|ports
(braket
id|i
)braket
)paren
op_increment
id|flag
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flag
)paren
id|flag
op_assign
id|fdomain_is_valid_port
c_func
(paren
id|port_base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
multiline_comment|/* Cannot get port base from BIOS RAM */
multiline_comment|/* This is a bad sign.  It usually means that someone patched the&n;&t; BIOS signature list (the signatures variable) to contain a BIOS&n;&t; signature for a board *OTHER THAN* the TMC-1660/TMC-1680.&n;       */
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; RAM FAILED, &quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Anyway, the alternative to finding the address in the RAM is&n;&t; to just search through every possible port address for one&n;&t; that is attached to the Future Domain card.  Don&squot;t panic,&n;&t; though, about reading all these random port addresses--there&n;&t; are rumors that the Future Domain BIOS does something very&n;&t; similar.&n;       */
r_for
c_loop
(paren
id|flag
op_assign
l_int|0
comma
id|i
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|flag
op_logical_and
id|i
OL
id|PORT_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|port_base
op_assign
id|ports
(braket
id|i
)braket
suffix:semicolon
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; %x,&quot;
comma
id|port_base
)paren
suffix:semicolon
macro_line|#endif
id|flag
op_assign
id|fdomain_is_valid_port
c_func
(paren
id|port_base
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot; FAILED: NO PORT&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Cannot find valid set of ports */
)brace
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SCSI: bios_base = %x, port_base = %x, interrupt_level = %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|bios_base
comma
id|port_base
comma
id|interrupt_level
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|interrupt_level
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain: BIOS at %x; port base at %x; using IRQ %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|bios_base
comma
id|port_base
comma
id|interrupt_level
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain: BIOS at %x; port base at %x; *NO* IRQ&bslash;n&quot;
comma
(paren
r_int
)paren
id|bios_base
comma
id|port_base
)paren
suffix:semicolon
)brace
id|Data_Mode_Cntl_port
op_assign
id|port_base
op_plus
id|Data_Mode_Cntl
suffix:semicolon
id|FIFO_Data_Count_port
op_assign
id|port_base
op_plus
id|FIFO_Data_Count
suffix:semicolon
id|Interrupt_Cntl_port
op_assign
id|port_base
op_plus
id|Interrupt_Cntl
suffix:semicolon
id|Interrupt_Mask_port
op_assign
id|port_base
op_plus
id|Interrupt_Mask
suffix:semicolon
id|Read_FIFO_port
op_assign
id|port_base
op_plus
id|Read_FIFO
suffix:semicolon
id|Read_SCSI_Data_port
op_assign
id|port_base
op_plus
id|Read_SCSI_Data
suffix:semicolon
id|SCSI_Cntl_port
op_assign
id|port_base
op_plus
id|SCSI_Cntl
suffix:semicolon
id|SCSI_Data_NoACK_port
op_assign
id|port_base
op_plus
id|SCSI_Data_NoACK
suffix:semicolon
id|SCSI_Status_port
op_assign
id|port_base
op_plus
id|SCSI_Status
suffix:semicolon
id|TMC_Cntl_port
op_assign
id|port_base
op_plus
id|TMC_Cntl
suffix:semicolon
id|TMC_Status_port
op_assign
id|port_base
op_plus
id|TMC_Status
suffix:semicolon
id|Write_FIFO_port
op_assign
id|port_base
op_plus
id|Write_FIFO
suffix:semicolon
id|Write_SCSI_Data_port
op_assign
id|port_base
op_plus
id|Write_SCSI_Data
suffix:semicolon
id|fdomain_16x0_reset
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdomain_test_loopback
c_func
(paren
)paren
)paren
(brace
macro_line|#if DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot;SCSI: LOOPBACK TEST FAILED, FAILING DETECT!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if DO_DETECT
multiline_comment|/* These routines are here because of the way the SCSI bus behaves after&n;      a reset.  This appropriate behavior was not handled correctly by the&n;      higher level SCSI routines when I first wrote this driver.  Now,&n;      however, correct scan routines are part of scsi.c and these routines&n;      are no longer needed.  However, this code is still good for&n;      debugging.&n;    */
id|SCinit.request_buffer
op_assign
id|SCinit.buffer
op_assign
id|buf
suffix:semicolon
id|SCinit.request_bufflen
op_assign
id|SCinit.bufflen
op_assign
r_sizeof
(paren
id|buf
)paren
op_minus
l_int|1
suffix:semicolon
id|SCinit.use_sg
op_assign
l_int|0
suffix:semicolon
id|SCinit.lun
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Future Domain detection routine scanning for devices:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|SCinit.target
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|6
)paren
r_continue
suffix:semicolon
multiline_comment|/* The host adapter is at SCSI ID 6 */
id|memcpy
c_func
(paren
id|SCinit.cmnd
comma
id|do_request_sense
comma
r_sizeof
(paren
id|do_request_sense
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|fdomain_16x0_command
c_func
(paren
op_amp
id|SCinit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
)paren
(brace
id|memcpy
c_func
(paren
id|SCinit.cmnd
comma
id|do_inquiry
comma
r_sizeof
(paren
id|do_inquiry
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|fdomain_16x0_command
c_func
(paren
op_amp
id|SCinit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;     SCSI ID %d: &quot;
comma
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|8
suffix:semicolon
id|j
OL
(paren
id|buf
(braket
l_int|4
)braket
OL
l_int|32
ques
c_cond
id|buf
(braket
l_int|4
)braket
suffix:colon
l_int|32
)paren
suffix:semicolon
id|j
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|buf
(braket
id|j
)braket
op_ge
l_int|20
ques
c_cond
id|buf
(braket
id|j
)braket
suffix:colon
l_char|&squot; &squot;
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|SCinit.cmnd
comma
id|do_read_capacity
comma
r_sizeof
(paren
id|do_read_capacity
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|fdomain_16x0_command
c_func
(paren
op_amp
id|SCinit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retcode
)paren
(brace
r_int
r_int
id|blocks
comma
id|size
comma
id|capacity
suffix:semicolon
id|blocks
op_assign
(paren
id|buf
(braket
l_int|0
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|buf
(braket
l_int|1
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|buf
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
id|buf
(braket
l_int|3
)braket
suffix:semicolon
id|size
op_assign
(paren
id|buf
(braket
l_int|4
)braket
op_lshift
l_int|24
)paren
op_or
(paren
id|buf
(braket
l_int|5
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|buf
(braket
l_int|6
)braket
op_lshift
l_int|8
)paren
op_or
id|buf
(braket
l_int|7
)braket
suffix:semicolon
id|capacity
op_assign
op_plus
(paren
op_plus
(paren
id|blocks
op_div
l_int|1024L
)paren
op_star
op_plus
(paren
id|size
op_star
l_int|10L
)paren
)paren
op_div
l_int|1024L
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%lu MB (%lu byte blocks)&quot;
comma
(paren
(paren
id|capacity
op_plus
l_int|5L
)paren
op_div
l_int|10L
)paren
comma
id|size
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|SCinit.cmnd
comma
id|do_request_sense
comma
r_sizeof
(paren
id|do_request_sense
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|fdomain_16x0_command
c_func
(paren
op_amp
id|SCinit
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|SCinit.cmnd
comma
id|do_request_sense
comma
r_sizeof
(paren
id|do_request_sense
)paren
)paren
suffix:semicolon
id|retcode
op_assign
id|fdomain_16x0_command
c_func
(paren
op_amp
id|SCinit
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
id|this_host
op_assign
id|hostnum
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|QUEUE
op_logical_or
op_logical_neg
id|interrupt_level
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain: *NO* interrupt level selected!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;               COMMAND QUEUEING DISABLED!&bslash;n&quot;
)paren
suffix:semicolon
id|can_queue
op_assign
id|scsi_hosts
(braket
id|this_host
)braket
dot
id|can_queue
op_assign
l_int|0
suffix:semicolon
id|scsi_hosts
(braket
id|this_host
)braket
dot
id|sg_tablesize
op_assign
id|SG_NONE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Register the IRQ with the kernel */
id|sa.sa_handler
op_assign
id|fdomain_16x0_intr
suffix:semicolon
id|sa.sa_flags
op_assign
id|SA_INTERRUPT
suffix:semicolon
id|sa.sa_mask
op_assign
l_int|0
suffix:semicolon
id|sa.sa_restorer
op_assign
l_int|NULL
suffix:semicolon
id|retcode
op_assign
id|irqaction
c_func
(paren
id|interrupt_level
comma
op_amp
id|sa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retcode
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|retcode
op_eq
op_minus
id|EINVAL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain: IRQ %d is bad!&bslash;n&quot;
comma
id|interrupt_level
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;               This shouldn&squot;t happen: REPORT TO RIK!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|retcode
op_eq
op_minus
id|EBUSY
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain: IRQ %d is already in use!&bslash;n&quot;
comma
id|interrupt_level
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;               Please use another IRQ for the FD card!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain: Error getting IRQ %d&bslash;n&quot;
comma
id|interrupt_level
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;               This shouldn&squot;t happen: REPORT TO RIK!&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;               COMMAND QUEUEING DISABLED!&bslash;n&quot;
)paren
suffix:semicolon
id|can_queue
op_assign
id|scsi_hosts
(braket
id|this_host
)braket
dot
id|can_queue
op_assign
l_int|0
suffix:semicolon
id|scsi_hosts
(braket
id|this_host
)braket
dot
id|sg_tablesize
op_assign
id|SG_NONE
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Future Domain: IRQ %d requested from kernel&bslash;n&quot;
comma
id|interrupt_level
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|fdomain_16x0_info
r_const
r_char
op_star
id|fdomain_16x0_info
c_func
(paren
r_void
)paren
(brace
r_static
r_char
id|buffer
(braket
)braket
op_assign
l_string|&quot;Future Domain TMC-1660/TMC-1680 SCSI driver version &quot;
id|VERSION
l_string|&quot;&bslash;n&quot;
suffix:semicolon
r_return
id|buffer
suffix:semicolon
)brace
DECL|function|fdomain_arbitrate
r_static
r_int
id|fdomain_arbitrate
c_func
(paren
r_void
)paren
(brace
r_int
id|status
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;SCSI: fdomain_arbitrate()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
l_int|0x00
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Disable data drivers */
id|outb
c_func
(paren
l_int|0x40
comma
id|port_base
op_plus
id|SCSI_Data_NoACK
)paren
suffix:semicolon
multiline_comment|/* Set our id bit */
id|outb
c_func
(paren
l_int|0x04
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Start arbitration */
id|timeout
op_assign
id|jiffies
op_plus
l_int|50
suffix:semicolon
multiline_comment|/* 500 mS */
r_while
c_loop
(paren
id|jiffies
OL
id|timeout
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|TMC_Status_port
)paren
suffix:semicolon
multiline_comment|/* Read adapter status */
r_if
c_cond
(paren
id|status
op_amp
l_int|0x02
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Arbitration complete */
)brace
multiline_comment|/* Make bus idle */
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Arbitration failed, status = %x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot;SCSI (Future Domain): Arbitration failed, status = %x&quot;
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|fdomain_select
r_static
r_int
id|fdomain_select
c_func
(paren
r_int
id|target
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
multiline_comment|/* Send our address OR&squot;d with target address */
id|outb
c_func
(paren
l_int|0x40
op_or
(paren
l_int|1
op_lshift
id|target
)paren
comma
id|SCSI_Data_NoACK_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RESELECTION
op_logical_and
id|can_queue
)paren
id|outb
c_func
(paren
l_int|0x8a
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Bus Enable + Attention + Select */
r_else
id|outb
c_func
(paren
l_int|0x82
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Bus Enable + Select */
multiline_comment|/* Stop arbitration (also set FIFO for output and enable parity) */
id|outb
c_func
(paren
l_int|0xc0
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
l_int|25
suffix:semicolon
multiline_comment|/* 250mS */
r_while
c_loop
(paren
id|jiffies
OL
id|timeout
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
suffix:semicolon
multiline_comment|/* Read adapter status */
r_if
c_cond
(paren
id|status
op_amp
l_int|1
)paren
(brace
multiline_comment|/* Busy asserted */
multiline_comment|/* Enable SCSI Bus (on error, should make bus idle with 0) */
id|outb
c_func
(paren
l_int|0x80
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Make bus idle */
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
r_if
c_cond
(paren
op_logical_neg
id|target
)paren
id|printk
c_func
(paren
l_string|&quot;Selection failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
op_logical_neg
id|target
)paren
id|printk
c_func
(paren
l_string|&quot;SCSI (Future Domain): Selection failed&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|my_done
r_void
id|my_done
c_func
(paren
r_int
id|error
)paren
(brace
r_if
c_cond
(paren
id|in_command
)paren
(brace
id|in_command
op_assign
l_int|0
suffix:semicolon
id|in_interrupt_code
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
id|current_SC-&gt;result
op_assign
id|error
suffix:semicolon
r_if
c_cond
(paren
id|current_SC-&gt;scsi_done
)paren
id|current_SC
op_member_access_from_pointer
id|scsi_done
c_func
(paren
id|current_SC
)paren
suffix:semicolon
r_else
id|panic
c_func
(paren
l_string|&quot;SCSI (Future Domain): current_SC-&gt;scsi_done() == NULL&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|panic
c_func
(paren
l_string|&quot;SCSI (Future Domain): my_done() called outside of command&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|fdomain_16x0_intr
r_void
id|fdomain_16x0_intr
c_func
(paren
r_int
id|unused
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_int
id|data_count
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt_code
)paren
id|panic
c_func
(paren
l_string|&quot;SCSI (Future Domain): fdomain_16x0_intr() NOT REENTRANT!&bslash;n&quot;
)paren
suffix:semicolon
r_else
op_increment
id|in_interrupt_code
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|aborted
)paren
(brace
macro_line|#if EVERY_ACCESS
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
(paren
id|in_other
op_logical_or
id|disconnect
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;aborted (%s) = %d, &quot;
comma
id|current_SC-&gt;SCp.phase
op_amp
id|in_other
ques
c_cond
l_string|&quot;in_other&quot;
suffix:colon
l_string|&quot;disconnect&quot;
comma
id|current_SC-&gt;result
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;aborted = %d, &quot;
comma
id|current_SC-&gt;result
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Force retry for timeouts after selection complete */
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
(paren
id|in_other
op_logical_or
id|disconnect
)paren
)paren
(brace
id|fdomain_16x0_reset
c_func
(paren
)paren
suffix:semicolon
id|my_done
c_func
(paren
id|DID_RESET
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
r_else
(brace
id|my_done
c_func
(paren
id|current_SC-&gt;result
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* We usually have one spurious interrupt after each command.  Ignore it. */
r_if
c_cond
(paren
op_logical_neg
id|in_command
)paren
(brace
multiline_comment|/* Spurious interrupt */
id|in_interrupt_code
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if RESELECTION
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|disconnect
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; RECON %x &quot;
comma
id|inb
c_func
(paren
id|SCSI_Data_NoACK_port
)paren
)paren
suffix:semicolon
id|current_SC-&gt;SCp.phase
op_assign
id|in_other
suffix:semicolon
id|outb
c_func
(paren
l_int|0x90
op_or
id|FIFO_COUNT
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x84
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
)paren
op_amp
l_int|0x20
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;s = %x, &quot;
comma
id|status
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0x80
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|in_arbitration
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|TMC_Status_port
)paren
suffix:semicolon
multiline_comment|/* Read adapter status */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
l_int|0x02
)paren
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; AFAIL &quot;
)paren
suffix:semicolon
macro_line|#endif
id|my_done
c_func
(paren
id|DID_BUS_BUSY
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|current_SC-&gt;SCp.phase
op_assign
id|in_selection
suffix:semicolon
id|outb
c_func
(paren
l_int|0x40
op_or
id|FIFO_COUNT
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x40
op_or
(paren
l_int|1
op_lshift
id|current_SC-&gt;target
)paren
comma
id|SCSI_Data_NoACK_port
)paren
suffix:semicolon
macro_line|#if RESELECTION
id|outb
c_func
(paren
l_int|0x8a
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Bus Enable + Attention + Select */
macro_line|#else
id|outb
c_func
(paren
l_int|0x82
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Bus Enable + Select */
macro_line|#endif
multiline_comment|/* Stop arbitration (also set FIFO for output and enable parity) */
id|outb
c_func
(paren
l_int|0xd0
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
id|in_interrupt_code
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|in_selection
)paren
(brace
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
l_int|0x01
)paren
)paren
(brace
multiline_comment|/* Try again, for slow devices */
r_if
c_cond
(paren
id|fdomain_select
c_func
(paren
id|current_SC-&gt;target
)paren
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; SFAIL &quot;
)paren
suffix:semicolon
macro_line|#endif
id|my_done
c_func
(paren
id|DID_NO_CONNECT
op_lshift
l_int|16
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; AltSel &quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Stop arbitration (also set FIFO for output and enable parity) */
id|outb
c_func
(paren
l_int|0xd0
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
)brace
)brace
id|current_SC-&gt;SCp.phase
op_assign
id|in_other
suffix:semicolon
id|in_interrupt_code
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
l_int|0x90
op_or
id|FIFO_COUNT
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
macro_line|#if RESELECTION
id|outb
c_func
(paren
l_int|0x88
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
macro_line|#else
id|outb
c_func
(paren
l_int|0x80
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* current_SC-&gt;SCp.phase == in_other: this is the body of the routine */
r_switch
c_cond
(paren
id|current_SC-&gt;cmnd
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|0x04
suffix:colon
r_case
l_int|0x07
suffix:colon
r_case
l_int|0x0a
suffix:colon
r_case
l_int|0x15
suffix:colon
r_case
l_int|0x2a
suffix:colon
r_case
l_int|0x2e
suffix:colon
r_case
l_int|0x3b
suffix:colon
r_case
l_int|0xea
suffix:colon
r_case
l_int|0x3f
suffix:colon
r_while
c_loop
(paren
(paren
id|data_count
op_assign
l_int|0x2000
op_minus
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
)paren
OG
l_int|512
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;DC=%d, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
OG
id|current_SC-&gt;SCp.this_residual
)paren
id|data_count
op_assign
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
r_if
c_cond
(paren
id|data_count
OG
l_int|0
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;%d OUT, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
id|outb
c_func
(paren
op_star
id|current_SC-&gt;SCp.ptr
op_increment
comma
id|Write_FIFO_port
)paren
suffix:semicolon
op_decrement
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
id|outsw
c_func
(paren
id|current_SC-&gt;SCp.ptr
comma
id|data_count
comma
id|Write_FIFO_port
)paren
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_sub_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.this_residual
)paren
(brace
r_if
c_cond
(paren
id|current_SC-&gt;SCp.buffers_residual
)paren
(brace
op_decrement
id|current_SC-&gt;SCp.buffers_residual
suffix:semicolon
op_increment
id|current_SC-&gt;SCp.buffer
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;SCp.buffer-&gt;length
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.have_data_in
)paren
(brace
id|outb
c_func
(paren
l_int|0x90
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
op_increment
id|current_SC-&gt;SCp.have_data_in
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
(paren
id|data_count
op_assign
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
)paren
op_ne
l_int|0
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;DC=%d, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
OG
id|current_SC-&gt;SCp.this_residual
)paren
id|data_count
op_assign
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
r_if
c_cond
(paren
id|data_count
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;%d IN, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
op_star
id|current_SC-&gt;SCp.ptr
op_increment
op_assign
id|inb
c_func
(paren
id|Read_FIFO_port
)paren
suffix:semicolon
op_decrement
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Number of words */
id|insw
c_func
(paren
id|current_SC-&gt;SCp.ptr
comma
id|data_count
comma
id|Read_FIFO_port
)paren
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_sub_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.this_residual
op_logical_and
id|current_SC-&gt;SCp.buffers_residual
)paren
(brace
op_decrement
id|current_SC-&gt;SCp.buffers_residual
suffix:semicolon
op_increment
id|current_SC-&gt;SCp.buffer
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;SCp.buffer-&gt;length
suffix:semicolon
)brace
)brace
)brace
r_break
suffix:semicolon
)brace
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
l_int|0x10
)paren
(brace
multiline_comment|/* REQ */
r_switch
c_cond
(paren
id|status
op_amp
l_int|0x0e
)paren
(brace
r_case
l_int|0x08
suffix:colon
multiline_comment|/* COMMAND OUT */
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.sent_command
)paren
(brace
r_int
id|i
suffix:semicolon
op_increment
id|current_SC-&gt;SCp.sent_command
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|COMMAND_SIZE
c_func
(paren
id|current_SC-&gt;cmnd
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
id|current_SC-&gt;cmnd
(braket
id|i
)braket
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;CMD = %x,&quot;
comma
id|current_SC-&gt;cmnd
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
macro_line|#else
id|outb
c_func
(paren
id|current_SC-&gt;cmnd
(braket
id|current_SC-&gt;SCp.sent_command
op_increment
)braket
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;CMD = %x,&quot;
comma
id|current_SC-&gt;cmnd
(braket
id|current_SC-&gt;SCp.sent_command
op_minus
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x0c
suffix:colon
multiline_comment|/* STATUS IN */
id|current_SC-&gt;SCp.Status
op_assign
id|inb
c_func
(paren
id|Read_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Status = %x, &quot;
comma
id|current_SC-&gt;SCp.Status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
id|current_SC-&gt;SCp.Status
op_logical_and
id|current_SC-&gt;SCp.Status
op_ne
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI (Future Domain): target = %d, command = %x, Status = %x&bslash;n&quot;
comma
id|current_SC-&gt;target
comma
id|current_SC-&gt;cmnd
(braket
l_int|0
)braket
comma
id|current_SC-&gt;SCp.Status
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x0a
suffix:colon
multiline_comment|/* MESSAGE OUT */
macro_line|#if RESELECTION
r_if
c_cond
(paren
op_logical_neg
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|sent_ident
)paren
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; IDENT &quot;
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
l_int|0x80
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
id|IDENTIFY
c_func
(paren
l_int|1
comma
l_int|0
)paren
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
id|current_SC-&gt;SCp.phase
op_or_assign
id|sent_ident
suffix:semicolon
)brace
r_else
macro_line|#else
id|outb
c_func
(paren
id|MESSAGE_REJECT
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
multiline_comment|/* Reject */
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x0e
suffix:colon
multiline_comment|/* MESSAGE IN */
id|current_SC-&gt;SCp.Message
op_assign
id|inb
c_func
(paren
id|Read_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Message = %x, &quot;
comma
id|current_SC-&gt;SCp.Message
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.Message
)paren
op_increment
id|done
suffix:semicolon
macro_line|#if RESELECTION
r_if
c_cond
(paren
id|current_SC-&gt;SCp.Message
op_eq
id|DISCONNECT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; DISCON &quot;
)paren
suffix:semicolon
id|current_SC-&gt;SCp.phase
op_assign
id|disconnect
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if DEBUG_MESSAGES || EVERY_ACCESS
r_if
c_cond
(paren
id|current_SC-&gt;SCp.Message
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI (Future Domain): Message = %x&bslash;n&quot;
comma
id|current_SC-&gt;SCp.Message
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|done
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot; ** IN DONE ** &quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|current_SC-&gt;SCp.have_data_in
)paren
(brace
r_while
c_loop
(paren
(paren
id|data_count
op_assign
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|data_count
OG
id|current_SC-&gt;SCp.this_residual
)paren
id|data_count
op_assign
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
r_if
c_cond
(paren
id|data_count
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;%d IN, &quot;
comma
id|data_count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
op_star
id|current_SC-&gt;SCp.ptr
op_increment
op_assign
id|inb
c_func
(paren
id|Read_FIFO_port
)paren
suffix:semicolon
op_decrement
id|current_SC-&gt;SCp.this_residual
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Number of words */
id|insw
c_func
(paren
id|current_SC-&gt;SCp.ptr
comma
id|data_count
comma
id|Read_FIFO_port
)paren
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_sub_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|current_SC-&gt;SCp.this_residual
op_logical_and
id|current_SC-&gt;SCp.buffers_residual
)paren
(brace
op_decrement
id|current_SC-&gt;SCp.buffers_residual
suffix:semicolon
op_increment
id|current_SC-&gt;SCp.buffer
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;SCp.buffer-&gt;length
suffix:semicolon
)brace
)brace
)brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;AFTER DATA GET&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
id|current_SC-&gt;cmnd
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_and
op_logical_neg
id|current_SC-&gt;SCp.Status
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|current_SC-&gt;request_buffer
op_plus
l_int|2
)paren
)paren
op_amp
l_int|0x0f
)paren
(brace
r_int
r_char
id|key
suffix:semicolon
r_int
r_char
id|code
suffix:semicolon
id|key
op_assign
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|current_SC-&gt;request_buffer
op_plus
l_int|2
)paren
)paren
op_amp
l_int|0x0f
suffix:semicolon
id|code
op_assign
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|current_SC-&gt;request_buffer
op_plus
l_int|12
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|key
op_eq
id|UNIT_ATTENTION
op_logical_and
(paren
id|code
op_eq
l_int|0x29
op_logical_or
op_logical_neg
id|code
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|key
op_eq
id|ILLEGAL_REQUEST
op_logical_and
(paren
id|code
op_eq
l_int|0x25
op_logical_or
op_logical_neg
id|code
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;SCSI REQUEST SENSE: Sense Key = %x, Sense Code = %x&bslash;n&quot;
comma
id|key
comma
id|code
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;BEFORE MY_DONE. . .&quot;
)paren
suffix:semicolon
macro_line|#endif
id|my_done
c_func
(paren
(paren
id|current_SC-&gt;SCp.Status
op_amp
l_int|0xff
)paren
op_or
(paren
(paren
id|current_SC-&gt;SCp.Message
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|DID_OK
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;RETURNING.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|in_interrupt_code
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|disconnect
)paren
(brace
id|outb
c_func
(paren
l_int|0xd0
op_or
id|FIFO_COUNT
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
l_int|0x90
op_or
id|FIFO_COUNT
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
DECL|function|fdomain_16x0_queue
r_int
id|fdomain_16x0_queue
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_void
(paren
op_star
id|done
)paren
(paren
id|Scsi_Cmnd
op_star
)paren
)paren
(brace
r_if
c_cond
(paren
id|in_command
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;SCSI (Future Domain): fdomain_16x0_queue() NOT REENTRANT!&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;queue: target = %d cmnd = 0x%02x pieces = %d size = %u&bslash;n&quot;
comma
id|SCpnt-&gt;target
comma
op_star
(paren
r_int
r_char
op_star
)paren
id|SCpnt-&gt;cmnd
comma
id|SCpnt-&gt;use_sg
comma
id|SCpnt-&gt;request_bufflen
)paren
suffix:semicolon
macro_line|#endif
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
id|current_SC
op_assign
id|SCpnt
suffix:semicolon
multiline_comment|/* Save this for the done function */
id|current_SC-&gt;scsi_done
op_assign
id|done
suffix:semicolon
multiline_comment|/* Initialize static data */
r_if
c_cond
(paren
id|current_SC-&gt;use_sg
)paren
(brace
id|current_SC-&gt;SCp.buffer
op_assign
(paren
r_struct
id|scatterlist
op_star
)paren
id|current_SC-&gt;request_buffer
suffix:semicolon
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;SCp.buffer-&gt;address
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;SCp.buffer-&gt;length
suffix:semicolon
id|current_SC-&gt;SCp.buffers_residual
op_assign
id|current_SC-&gt;use_sg
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|current_SC-&gt;SCp.ptr
op_assign
id|current_SC-&gt;request_buffer
suffix:semicolon
id|current_SC-&gt;SCp.this_residual
op_assign
id|current_SC-&gt;request_bufflen
suffix:semicolon
id|current_SC-&gt;SCp.buffer
op_assign
l_int|NULL
suffix:semicolon
id|current_SC-&gt;SCp.buffers_residual
op_assign
l_int|0
suffix:semicolon
)brace
id|current_SC-&gt;SCp.Status
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.Message
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.have_data_in
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.sent_command
op_assign
l_int|0
suffix:semicolon
id|current_SC-&gt;SCp.phase
op_assign
id|in_arbitration
suffix:semicolon
multiline_comment|/* Start arbitration */
id|outb
c_func
(paren
l_int|0x00
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Disable data drivers */
id|outb
c_func
(paren
l_int|0x40
comma
id|SCSI_Data_NoACK_port
)paren
suffix:semicolon
multiline_comment|/* Set our id bit */
op_increment
id|in_command
suffix:semicolon
id|outb
c_func
(paren
l_int|0x20
comma
id|Interrupt_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x14
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
multiline_comment|/* Start arbitration */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fdomain_16x0_command
r_int
id|fdomain_16x0_command
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
)paren
(brace
r_const
r_char
op_star
id|cmd_pt
op_assign
id|SCpnt-&gt;cmnd
suffix:semicolon
r_const
r_char
op_star
id|the_command
op_assign
id|SCpnt-&gt;cmnd
suffix:semicolon
r_int
r_char
op_star
id|out_buf_pt
op_assign
id|SCpnt-&gt;request_buffer
suffix:semicolon
r_int
r_char
op_star
id|in_buf_pt
op_assign
id|SCpnt-&gt;request_buffer
suffix:semicolon
r_int
r_char
id|target
op_assign
id|SCpnt-&gt;target
suffix:semicolon
r_void
op_star
id|buff
op_assign
id|SCpnt-&gt;request_buffer
suffix:semicolon
r_int
id|bufflen
op_assign
id|SCpnt-&gt;request_bufflen
suffix:semicolon
r_int
id|Status
op_assign
l_int|0
suffix:semicolon
r_int
id|Message
op_assign
l_int|0
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_int
id|data_sent
op_assign
l_int|0
suffix:semicolon
r_int
id|data_count
suffix:semicolon
r_int
id|have_data_in
op_assign
l_int|0
suffix:semicolon
id|current_SC
op_assign
id|SCpnt
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;fdomain_command(%d, %x): &quot;
comma
id|target
comma
(paren
r_int
r_char
)paren
op_star
id|the_command
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|fdomain_arbitrate
c_func
(paren
)paren
)paren
(brace
macro_line|#if ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot;, target = %d, command = %x&bslash;n&quot;
comma
id|target
comma
(paren
r_int
r_char
)paren
op_star
id|the_command
)paren
suffix:semicolon
macro_line|#endif
r_return
id|DID_TIME_OUT
op_lshift
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fdomain_select
c_func
(paren
id|target
)paren
)paren
(brace
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
op_logical_neg
id|target
)paren
id|printk
c_func
(paren
l_string|&quot;, target = %d, command = %x&bslash;n&quot;
comma
id|target
comma
(paren
r_int
r_char
)paren
op_star
id|the_command
)paren
suffix:semicolon
macro_line|#endif
r_return
id|DID_NO_CONNECT
op_lshift
l_int|16
suffix:semicolon
)brace
id|timeout
op_assign
id|jiffies
op_plus
l_int|500
suffix:semicolon
multiline_comment|/* 5000 mS -- For Maxtor after a RST */
id|current_SC-&gt;SCp.phase
op_assign
id|non_queueing
suffix:semicolon
r_switch
c_cond
(paren
(paren
r_int
r_char
)paren
op_star
id|the_command
)paren
(brace
r_case
l_int|0x04
suffix:colon
r_case
l_int|0x07
suffix:colon
r_case
l_int|0x0a
suffix:colon
r_case
l_int|0x15
suffix:colon
r_case
l_int|0x2a
suffix:colon
r_case
l_int|0x2e
suffix:colon
r_case
l_int|0x3b
suffix:colon
r_case
l_int|0xea
suffix:colon
r_case
l_int|0x3f
suffix:colon
id|data_count
op_assign
l_int|0x2000
op_minus
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bufflen
op_minus
id|data_sent
OL
id|data_count
)paren
id|data_count
op_assign
id|bufflen
op_minus
id|data_sent
suffix:semicolon
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
id|outb
c_func
(paren
op_star
id|out_buf_pt
op_increment
comma
id|Write_FIFO_port
)paren
suffix:semicolon
op_increment
id|data_sent
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
id|outsw
c_func
(paren
id|out_buf_pt
comma
id|data_count
comma
id|Write_FIFO_port
)paren
suffix:semicolon
id|out_buf_pt
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
id|data_sent
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|outb
c_func
(paren
l_int|0x80
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
op_increment
id|have_data_in
suffix:semicolon
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
(paren
id|status
op_assign
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
)paren
op_amp
l_int|1
)paren
op_logical_and
op_logical_neg
id|done
op_logical_and
op_logical_neg
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|aborted
)paren
op_logical_and
id|jiffies
OL
id|timeout
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
l_int|0x10
)paren
(brace
multiline_comment|/* REQ */
r_switch
c_cond
(paren
id|status
op_amp
l_int|0x0e
)paren
(brace
r_case
l_int|0x00
suffix:colon
multiline_comment|/* DATA OUT */
id|data_count
op_assign
l_int|0x2000
op_minus
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bufflen
op_minus
id|data_sent
OL
id|data_count
)paren
id|data_count
op_assign
id|bufflen
op_minus
id|data_sent
suffix:semicolon
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
id|outb
c_func
(paren
op_star
id|out_buf_pt
op_increment
comma
id|Write_FIFO_port
)paren
suffix:semicolon
op_increment
id|data_sent
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
id|outsw
c_func
(paren
id|out_buf_pt
comma
id|data_count
comma
id|Write_FIFO_port
)paren
suffix:semicolon
id|out_buf_pt
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
id|data_sent
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x04
suffix:colon
multiline_comment|/* DATA IN */
r_if
c_cond
(paren
op_logical_neg
id|have_data_in
)paren
(brace
id|outb
c_func
(paren
l_int|0x80
op_or
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
op_increment
id|have_data_in
suffix:semicolon
)brace
id|data_count
op_assign
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
op_star
id|in_buf_pt
op_increment
op_assign
id|inb
c_func
(paren
id|Read_FIFO_port
)paren
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Number of words */
id|insw
c_func
(paren
id|in_buf_pt
comma
id|data_count
comma
id|Read_FIFO_port
)paren
suffix:semicolon
id|in_buf_pt
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0x08
suffix:colon
multiline_comment|/* COMMAND OUT */
id|outb
c_func
(paren
op_star
id|cmd_pt
op_increment
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;%x,&quot;
comma
(paren
r_int
r_char
)paren
id|cmd_pt
(braket
op_minus
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x0c
suffix:colon
multiline_comment|/* STATUS IN */
id|Status
op_assign
id|inb
c_func
(paren
id|Read_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Status = %x, &quot;
comma
id|Status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
id|Status
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI (Future Domain): target = %d, command = %x, Status = %x&bslash;n&quot;
comma
id|target
comma
(paren
r_int
r_char
)paren
op_star
id|the_command
comma
id|Status
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|0x0a
suffix:colon
multiline_comment|/* MESSAGE OUT */
id|outb
c_func
(paren
l_int|0x07
comma
id|Write_SCSI_Data_port
)paren
suffix:semicolon
multiline_comment|/* Reject */
r_break
suffix:semicolon
r_case
l_int|0x0e
suffix:colon
multiline_comment|/* MESSAGE IN */
id|Message
op_assign
id|inb
c_func
(paren
id|Read_SCSI_Data_port
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Message = %x, &quot;
comma
id|Message
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|Message
)paren
op_increment
id|done
suffix:semicolon
r_if
c_cond
(paren
id|Message
op_eq
id|DISCONNECT
)paren
id|printk
c_func
(paren
l_string|&quot;DISCONNECT&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|jiffies
op_ge
id|timeout
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Time out, status = %x&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot;SCSI (Future Domain): &quot;
l_string|&quot;Time out, status = %x (target = %d, command = %x)&bslash;n&quot;
comma
id|status
comma
id|target
comma
(paren
r_int
r_char
)paren
op_star
id|the_command
)paren
suffix:semicolon
macro_line|#endif
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
r_return
id|DID_BUS_BUSY
op_lshift
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current_SC-&gt;SCp.phase
op_amp
id|aborted
)paren
(brace
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Aborted&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot;SCSI (Future Domain): Aborted (command = %x)&bslash;n&quot;
comma
(paren
r_int
r_char
)paren
op_star
id|the_command
)paren
suffix:semicolon
macro_line|#endif
id|fdomain_16x0_reset
c_func
(paren
)paren
suffix:semicolon
r_return
id|DID_RESET
op_lshift
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|have_data_in
)paren
(brace
r_while
c_loop
(paren
(paren
id|data_count
op_assign
id|inw
c_func
(paren
id|FIFO_Data_Count_port
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|data_count
op_eq
l_int|1
)paren
(brace
op_star
id|in_buf_pt
op_increment
op_assign
id|inb
c_func
(paren
id|Read_FIFO_port
)paren
suffix:semicolon
)brace
r_else
(brace
id|data_count
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* Number of words */
id|insw
c_func
(paren
id|in_buf_pt
comma
id|data_count
comma
id|Read_FIFO_port
)paren
suffix:semicolon
id|in_buf_pt
op_add_assign
l_int|2
op_star
id|data_count
suffix:semicolon
)brace
)brace
)brace
id|fdomain_make_bus_idle
c_func
(paren
)paren
suffix:semicolon
macro_line|#if EVERY_ACCESS
id|printk
c_func
(paren
l_string|&quot;Retcode = %x&bslash;n&quot;
comma
(paren
id|Status
op_amp
l_int|0xff
)paren
op_or
(paren
(paren
id|Message
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|DID_OK
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if ERRORS_ONLY
r_if
c_cond
(paren
op_star
id|the_command
op_eq
id|REQUEST_SENSE
op_logical_and
op_logical_neg
id|Status
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|buff
op_plus
l_int|2
)paren
)paren
op_amp
l_int|0x0f
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SCSI REQUEST SENSE: Sense Key = %x, Sense Code = %x&bslash;n&quot;
comma
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|buff
op_plus
l_int|2
)paren
)paren
op_amp
l_int|0x0f
comma
(paren
r_int
r_char
)paren
(paren
op_star
(paren
(paren
r_char
op_star
)paren
id|buff
op_plus
l_int|12
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_return
(paren
id|Status
op_amp
l_int|0xff
)paren
op_or
(paren
(paren
id|Message
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
id|DID_OK
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
DECL|function|fdomain_16x0_abort
r_int
id|fdomain_16x0_abort
c_func
(paren
id|Scsi_Cmnd
op_star
id|SCpnt
comma
r_int
id|code
)paren
(brace
macro_line|#if EVERY_ACCESS || ERRORS_ONLY || DEBUG_ABORT
id|printk
c_func
(paren
l_string|&quot;SCSI (Future Domain): Abort &quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if DEBUG_ABORT
id|printk
c_func
(paren
l_string|&quot;Phase = %d, flag = %d, target = %d cmnd = 0x%02x pieces = %d size = %u&bslash;n&quot;
comma
id|current_SC-&gt;SCp.phase
comma
id|in_interrupt_code
comma
id|current_SC-&gt;target
comma
op_star
(paren
r_int
r_char
op_star
)paren
id|current_SC-&gt;cmnd
comma
id|current_SC-&gt;use_sg
comma
id|current_SC-&gt;request_bufflen
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IMR = 0x%02x%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
l_int|0x0a1
)paren
comma
id|inb
c_func
(paren
l_int|0x21
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0a
comma
l_int|0xa0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;IRR = 0x%02x&quot;
comma
id|inb
c_func
(paren
l_int|0xa0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0a
comma
l_int|0x20
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
l_int|0x20
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0b
comma
l_int|0xa0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ISR = 0x%02x&quot;
comma
id|inb
c_func
(paren
l_int|0xa0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0b
comma
l_int|0x20
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02x&bslash;n&quot;
comma
id|inb
c_func
(paren
l_int|0x20
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SCSI Status    = %x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|SCSI_Status_port
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;TMC Status     = %x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|TMC_Status_port
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Interrupt Mask = %x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|Interrupt_Mask_port
)paren
)paren
suffix:semicolon
macro_line|#else
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|in_command
)paren
(brace
macro_line|#if EVERY_ACCESS || ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot; (not in command)&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
macro_line|#if EVERY_ACCESS || ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot; code = %d&bslash;n&quot;
comma
id|code
)paren
suffix:semicolon
macro_line|#endif
)brace
id|current_SC-&gt;SCp.phase
op_or_assign
id|aborted
suffix:semicolon
id|current_SC-&gt;result
op_assign
id|code
ques
c_cond
id|code
suffix:colon
id|DID_ABORT
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Aborts are not done well. . . */
id|my_done
c_func
(paren
id|code
op_lshift
l_int|16
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fdomain_16x0_reset
r_int
id|fdomain_16x0_reset
c_func
(paren
r_void
)paren
(brace
macro_line|#if ERRORS_ONLY
id|printk
c_func
(paren
l_string|&quot;Future Domain: SCSI Bus Reset&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
l_int|1
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
id|do_pause
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|SCSI_Cntl_port
)paren
suffix:semicolon
id|do_pause
c_func
(paren
l_int|115
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|Data_Mode_Cntl_port
)paren
suffix:semicolon
id|outb
c_func
(paren
id|PARITY_MASK
comma
id|TMC_Cntl_port
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fdomain_16x0_biosparam
r_int
id|fdomain_16x0_biosparam
c_func
(paren
r_int
id|size
comma
r_int
id|dev
comma
r_int
op_star
id|info
)paren
(brace
r_int
id|drive
suffix:semicolon
r_struct
id|drive_info
(brace
r_int
r_int
id|cylinders
suffix:semicolon
r_int
r_char
id|heads
suffix:semicolon
r_int
r_char
id|sectors
suffix:semicolon
)brace
op_star
id|i
suffix:semicolon
multiline_comment|/* NOTES:&n;      The RAM area starts at 0x1f00 from the bios_base address.&n;      The drive parameter table seems to start at 0x1f30.&n;      The first byte&squot;s purpose is not known.&n;      Next is the cylinder, head, and sector information.&n;      The last 4 bytes appear to be the drive&squot;s size in sectors.&n;      The other bytes in the drive parameter table are unknown.&n;      If anyone figures them out, please send me mail, and I will&n;      update these notes.&n;&n;      Tape drives do not get placed in this table.&n;&n;      There is another table at 0x1fea:&n;      If the byte is 0x01, then the SCSI ID is not in use.&n;      If the byte is 0x18 or 0x48, then the SCSI ID is in use,&n;      although tapes don&squot;t seem to be in this table.  I haven&squot;t&n;      seen any other numbers (in a limited sample).&n;&n;      0x1f2d is a drive count (i.e., not including tapes)&n;&n;      The table at 0x1fcc are I/O ports addresses for the various&n;      operations.  I calculate these by hand in this driver code.&n;    */
id|drive
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
op_div
l_int|16
suffix:semicolon
id|i
op_assign
(paren
r_struct
id|drive_info
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|bios_base
op_plus
l_int|0x1f31
op_plus
id|drive
op_star
l_int|25
)paren
suffix:semicolon
id|info
(braket
l_int|0
)braket
op_assign
id|i-&gt;heads
suffix:semicolon
id|info
(braket
l_int|1
)braket
op_assign
id|i-&gt;sectors
suffix:semicolon
id|info
(braket
l_int|2
)braket
op_assign
id|i-&gt;cylinders
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
