multiline_comment|/*&n; *  linux/kernel/floppy.c&n; *&n; *  (C) 1991  Linus Torvalds&n; */
multiline_comment|/*&n; * 02.12.91 - Changed to static variables to indicate need for reset&n; * and recalibrate. This makes some things easier (output_byte reset&n; * checking etc), and means less interrupt jumping in case of errors,&n; * so the code is hopefully easier to understand.&n; */
multiline_comment|/*&n; * This file is certainly a mess. I&squot;ve tried my best to get it working,&n; * but I don&squot;t like programming floppies, and I have only one anyway.&n; * Urgel. I should check for more errors, and do more graceful error&n; * recovery. Seems there are problems with several drives. I&squot;ve tried to&n; * correct them. No promises. &n; */
multiline_comment|/*&n; * As with hd.c, all routines within this file can (and will) be called&n; * by interrupts, so extreme caution is needed. A hardware interrupt&n; * handler may not sleep, or a kernel panic will happen. Thus I cannot&n; * call &quot;floppy-on&quot; directly, but have to set a special timer interrupt&n; * etc.&n; */
multiline_comment|/*&n; * 28.02.92 - made track-buffering routines, based on the routines written&n; * by entropy@wintermute.wpi.edu (Lawrence Foard). Linus.&n; */
multiline_comment|/*&n; * Automatic floppy-detection and formatting written by Werner Almesberger&n; * (almesber@nessie.cs.id.ethz.ch), who also corrected some problems with&n; * the floppy-change signa| detection.&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fdreg.h&gt;
macro_line|#include &lt;linux/fd.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;errno.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR 2
macro_line|#include &quot;blk.h&quot;
DECL|variable|changed_floppies
DECL|variable|fake_change
r_static
r_int
r_int
id|changed_floppies
op_assign
l_int|0
comma
id|fake_change
op_assign
l_int|0
suffix:semicolon
DECL|variable|recalibrate
r_static
r_int
id|recalibrate
op_assign
l_int|0
suffix:semicolon
DECL|variable|reset
r_static
r_int
id|reset
op_assign
l_int|0
suffix:semicolon
DECL|variable|recover
r_static
r_int
id|recover
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* recalibrate immediately after resetting */
DECL|variable|seek
r_static
r_int
id|seek
op_assign
l_int|0
suffix:semicolon
r_extern
r_int
r_char
id|current_DOR
suffix:semicolon
DECL|macro|immoutb_p
mdefine_line|#define immoutb_p(val,port) &bslash;&n;__asm__(&quot;outb %0,%1&bslash;n&bslash;tjmp 1f&bslash;n1:&bslash;tjmp 1f&bslash;n1:&quot;::&quot;a&quot; ((char) (val)),&quot;i&quot; (port))
DECL|macro|TYPE
mdefine_line|#define TYPE(x) ((x)&gt;&gt;2)
DECL|macro|DRIVE
mdefine_line|#define DRIVE(x) ((x)&amp;0x03)
multiline_comment|/*&n; * Note that MAX_ERRORS=X doesn&squot;t imply that we retry every bad read&n; * max X times - some types of errors increase the errorcount by 2 or&n; * even 3, so we might actually retry only X/2 times before giving up.&n; */
DECL|macro|MAX_ERRORS
mdefine_line|#define MAX_ERRORS 12
multiline_comment|/*&n; * Maximum disk size (in kilobytes). This default is used whenever the&n; * current disk size is unknown.&n; */
DECL|macro|MAX_DISK_SIZE
mdefine_line|#define MAX_DISK_SIZE 1440
multiline_comment|/*&n; * Maximum number of sectors in a track buffer. Track buffering is disabled&n; * if tracks are bigger.&n; */
DECL|macro|MAX_BUFFER_SECTORS
mdefine_line|#define MAX_BUFFER_SECTORS 18
multiline_comment|/*&n; * globals used by &squot;result()&squot;&n; */
DECL|macro|MAX_REPLIES
mdefine_line|#define MAX_REPLIES 7
DECL|variable|reply_buffer
r_static
r_int
r_char
id|reply_buffer
(braket
id|MAX_REPLIES
)braket
suffix:semicolon
DECL|macro|ST0
mdefine_line|#define ST0 (reply_buffer[0])
DECL|macro|ST1
mdefine_line|#define ST1 (reply_buffer[1])
DECL|macro|ST2
mdefine_line|#define ST2 (reply_buffer[2])
DECL|macro|ST3
mdefine_line|#define ST3 (reply_buffer[3])
multiline_comment|/*&n; * This struct defines the different floppy types. Unlike minix&n; * linux doesn&squot;t have a &quot;search for right type&quot;-type, as the code&n; * for that is convoluted and weird. I&squot;ve got enough problems with&n; * this driver as it is.&n; *&n; * The &squot;stretch&squot; tells if the tracks need to be boubled for some&n; * types (ie 360kB diskette in 1.2MB drive etc). Others should&n; * be self-explanatory.&n; */
DECL|variable|floppy_type
r_static
r_struct
id|floppy_struct
id|floppy_type
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|NULL
)brace
comma
multiline_comment|/* no testing */
(brace
l_int|720
comma
l_int|9
comma
l_int|2
comma
l_int|40
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_int|NULL
)brace
comma
multiline_comment|/* 360kB PC diskettes */
(brace
l_int|2400
comma
l_int|15
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x54
comma
l_int|NULL
)brace
comma
multiline_comment|/* 1.2 MB AT-diskettes */
(brace
l_int|720
comma
l_int|9
comma
l_int|2
comma
l_int|40
comma
l_int|1
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_int|NULL
)brace
comma
multiline_comment|/* 360kB in 720kB drive */
(brace
l_int|1440
comma
l_int|9
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_int|NULL
)brace
comma
multiline_comment|/* 3.5&quot; 720kB diskette */
(brace
l_int|720
comma
l_int|9
comma
l_int|2
comma
l_int|40
comma
l_int|1
comma
l_int|0x23
comma
l_int|0x01
comma
l_int|0xDF
comma
l_int|0x50
comma
l_int|NULL
)brace
comma
multiline_comment|/* 360kB in 1.2MB drive */
(brace
l_int|1440
comma
l_int|9
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x23
comma
l_int|0x01
comma
l_int|0xDF
comma
l_int|0x50
comma
l_int|NULL
)brace
comma
multiline_comment|/* 720kB in 1.2MB drive */
(brace
l_int|2880
comma
l_int|18
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x00
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_int|NULL
)brace
comma
multiline_comment|/* 1.44MB diskette */
)brace
suffix:semicolon
multiline_comment|/* For auto-detection. Each drive type has a pair of formats to try. */
DECL|variable|floppy_types
r_static
r_struct
id|floppy_struct
id|floppy_types
(braket
)braket
op_assign
(brace
(brace
l_int|720
comma
l_int|9
comma
l_int|2
comma
l_int|40
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;360k/PC&quot;
)brace
comma
multiline_comment|/* 360kB PC diskettes */
(brace
l_int|720
comma
l_int|9
comma
l_int|2
comma
l_int|40
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;360k/PC&quot;
)brace
comma
multiline_comment|/* 360kB PC diskettes */
(brace
l_int|2400
comma
l_int|15
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x54
comma
l_string|&quot;1.2M&quot;
)brace
comma
multiline_comment|/* 1.2 MB AT-diskettes */
(brace
l_int|720
comma
l_int|9
comma
l_int|2
comma
l_int|40
comma
l_int|1
comma
l_int|0x23
comma
l_int|0x01
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;360k/AT&quot;
)brace
comma
multiline_comment|/* 360kB in 1.2MB drive */
(brace
l_int|1440
comma
l_int|9
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;720k&quot;
)brace
comma
multiline_comment|/* 3.5&quot; 720kB diskette */
(brace
l_int|1440
comma
l_int|9
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;720k&quot;
)brace
comma
multiline_comment|/* 3.5&quot; 720kB diskette */
(brace
l_int|2880
comma
l_int|18
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x00
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_string|&quot;1.44M&quot;
)brace
comma
multiline_comment|/* 1.44MB diskette */
(brace
l_int|1440
comma
l_int|9
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;720k/AT&quot;
)brace
comma
multiline_comment|/* 3.5&quot; 720kB diskette */
)brace
suffix:semicolon
multiline_comment|/* Auto-detection: Disk type used until the next media change occurs. */
DECL|variable|current_type
r_struct
id|floppy_struct
op_star
id|current_type
(braket
l_int|4
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/* This type is tried first. */
DECL|variable|base_type
r_struct
id|floppy_struct
op_star
id|base_type
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* User-provided type information. current_type points to the respective entry&n;   of this array. */
DECL|variable|user_params
r_struct
id|floppy_struct
id|user_params
(braket
l_int|4
)braket
suffix:semicolon
DECL|variable|floppy_sizes
r_static
r_int
id|floppy_sizes
(braket
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* The driver is trying to determine the correct media format while probing&n;   is set. rw_interrupts clears it after a successful access. */
DECL|variable|probing
r_static
r_int
id|probing
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* (User-provided) media information is _not_ discarded after a media change&n;   if the corresponding keep_data flag is non-zero. Positive values are&n;   decremented after each probe. */
DECL|variable|keep_data
r_static
r_int
id|keep_data
(braket
l_int|4
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* Announce successful media type detection and media information loss after&n;   disk changes. */
DECL|variable|ftd_msg
r_static
id|ftd_msg
(braket
l_int|4
)braket
op_assign
(brace
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|1
)brace
suffix:semicolon
multiline_comment|/* Synchronization of FDC access. */
DECL|variable|format_status
DECL|variable|fdc_busy
r_static
r_volatile
r_int
id|format_status
op_assign
id|FORMAT_NONE
comma
id|fdc_busy
op_assign
l_int|0
suffix:semicolon
DECL|variable|fdc_wait
DECL|variable|format_done
r_static
r_struct
id|task_struct
op_star
id|fdc_wait
op_assign
l_int|NULL
comma
op_star
id|format_done
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Errors during formatting are counted here. */
DECL|variable|format_errors
r_static
r_int
id|format_errors
suffix:semicolon
multiline_comment|/* Format request descriptor. */
DECL|variable|format_req
r_static
r_struct
id|format_descr
id|format_req
suffix:semicolon
multiline_comment|/* Current device number. Taken either from the block header or from the&n;   format request descriptor. */
DECL|macro|CURRENT_DEVICE
mdefine_line|#define CURRENT_DEVICE (format_status == FORMAT_BUSY ? format_req.device : &bslash;&n;   (CURRENT-&gt;dev))
multiline_comment|/* Current error count. */
DECL|macro|CURRENT_ERRORS
mdefine_line|#define CURRENT_ERRORS (format_status == FORMAT_BUSY ? format_errors : &bslash;&n;    (CURRENT-&gt;errors))
multiline_comment|/*&n; * Rate is 0 for 500kb/s, 2 for 300kbps, 1 for 250kbps&n; * Spec1 is 0xSH, where S is stepping rate (F=1ms, E=2ms, D=3ms etc),&n; * H is head unload time (1=16ms, 2=32ms, etc)&n; *&n; * Spec2 is (HLD&lt;&lt;1 | ND), where HLD is head load time (1=2ms, 2=4 ms etc)&n; * and ND is set means no DMA. Hardcoded to 6 (HLD=6ms, use DMA).&n; */
r_extern
r_void
id|floppy_interrupt
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_char
id|tmp_floppy_area
(braket
l_int|1024
)braket
suffix:semicolon
r_extern
r_char
id|floppy_track_buffer
(braket
l_int|512
op_star
l_int|2
op_star
id|MAX_BUFFER_SECTORS
)braket
suffix:semicolon
r_static
r_void
id|redo_fd_request
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * These are global variables, as that&squot;s the easiest way to give&n; * information to interrupts. They are the data used for the current&n; * request.&n; */
DECL|macro|NO_TRACK
mdefine_line|#define NO_TRACK 255
DECL|variable|read_track
r_static
r_int
id|read_track
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* flag to indicate if we want to read all track */
DECL|variable|buffer_track
r_static
r_int
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|buffer_drive
r_static
r_int
id|buffer_drive
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|cur_spec1
r_static
r_int
id|cur_spec1
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|cur_rate
r_static
r_int
id|cur_rate
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|floppy
r_static
r_struct
id|floppy_struct
op_star
id|floppy
op_assign
id|floppy_type
suffix:semicolon
DECL|variable|current_drive
r_static
r_int
r_char
id|current_drive
op_assign
l_int|255
suffix:semicolon
DECL|variable|sector
r_static
r_int
r_char
id|sector
op_assign
l_int|0
suffix:semicolon
DECL|variable|head
r_static
r_int
r_char
id|head
op_assign
l_int|0
suffix:semicolon
DECL|variable|track
r_static
r_int
r_char
id|track
op_assign
l_int|0
suffix:semicolon
DECL|variable|seek_track
r_static
r_int
r_char
id|seek_track
op_assign
l_int|0
suffix:semicolon
DECL|variable|current_track
r_static
r_int
r_char
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
DECL|variable|command
r_static
r_int
r_char
id|command
op_assign
l_int|0
suffix:semicolon
DECL|variable|selected
r_int
r_char
id|selected
op_assign
l_int|0
suffix:semicolon
DECL|variable|wait_on_floppy_select
r_struct
id|task_struct
op_star
id|wait_on_floppy_select
op_assign
l_int|NULL
suffix:semicolon
DECL|function|floppy_deselect
r_void
id|floppy_deselect
c_func
(paren
r_int
r_int
id|nr
)paren
(brace
r_if
c_cond
(paren
id|nr
op_ne
(paren
id|current_DOR
op_amp
l_int|3
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;floppy_deselect: drive not selected&bslash;n&bslash;r&quot;
)paren
suffix:semicolon
id|selected
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|wait_on_floppy_select
)paren
suffix:semicolon
)brace
DECL|function|request_done
r_void
id|request_done
c_func
(paren
r_int
id|uptodate
)paren
(brace
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|FLOPPY_TIMER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|format_status
op_ne
id|FORMAT_BUSY
)paren
id|end_request
c_func
(paren
id|uptodate
)paren
suffix:semicolon
r_else
(brace
id|format_status
op_assign
id|uptodate
ques
c_cond
id|FORMAT_OKAY
suffix:colon
id|FORMAT_ERROR
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|format_done
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * floppy-change is never called from an interrupt, so we can relax a bit&n; * here, sleep etc. Note that floppy-on tries to set current_DOR to point&n; * to the desired drive, but it will probably not survive the sleep if&n; * several floppies are used at the same time: thus the loop.&n; */
DECL|function|floppy_change
r_int
id|floppy_change
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_int
r_int
id|mask
op_assign
l_int|1
op_lshift
(paren
id|bh-&gt;b_dev
op_amp
l_int|0x03
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|bh-&gt;b_dev
)paren
op_ne
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;floppy_changed: not a floppy&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fake_change
op_amp
id|mask
)paren
(brace
id|fake_change
op_and_assign
op_complement
id|mask
suffix:semicolon
multiline_comment|/* omitting the next line breaks formatting in a horrible way ... */
id|changed_floppies
op_and_assign
op_complement
id|mask
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|changed_floppies
op_amp
id|mask
)paren
(brace
id|changed_floppies
op_and_assign
op_complement
id|mask
suffix:semicolon
id|recalibrate
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dirt
)paren
id|ll_rw_block
c_func
(paren
id|WRITE
comma
id|bh
)paren
suffix:semicolon
r_else
(brace
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|bh-&gt;b_uptodate
op_assign
l_int|0
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|READ
comma
id|bh
)paren
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|bh-&gt;b_lock
)paren
id|sleep_on
c_func
(paren
op_amp
id|bh-&gt;b_wait
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|changed_floppies
op_amp
id|mask
)paren
(brace
id|changed_floppies
op_and_assign
op_complement
id|mask
suffix:semicolon
id|recalibrate
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|copy_buffer
mdefine_line|#define copy_buffer(from,to) &bslash;&n;__asm__(&quot;cld ; rep ; movsl&quot; &bslash;&n;&t;::&quot;c&quot; (BLOCK_SIZE/4),&quot;S&quot; ((long)(from)),&quot;D&quot; ((long)(to)) &bslash;&n;&t;:&quot;cx&quot;,&quot;di&quot;,&quot;si&quot;)
DECL|function|setup_DMA
r_static
r_void
id|setup_DMA
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|addr
comma
id|count
suffix:semicolon
r_if
c_cond
(paren
id|command
op_eq
id|FD_FORMAT
)paren
(brace
id|addr
op_assign
(paren
r_int
)paren
id|tmp_floppy_area
suffix:semicolon
id|count
op_assign
id|floppy-&gt;sect
op_star
l_int|4
suffix:semicolon
)brace
r_else
(brace
id|addr
op_assign
(paren
r_int
)paren
id|CURRENT-&gt;buffer
suffix:semicolon
id|count
op_assign
l_int|1024
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_track
)paren
(brace
multiline_comment|/* mark buffer-track bad, in case all this fails.. */
id|buffer_drive
op_assign
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|count
op_assign
id|floppy-&gt;sect
op_star
l_int|2
op_star
l_int|512
suffix:semicolon
id|addr
op_assign
(paren
r_int
)paren
id|floppy_track_buffer
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|addr
op_ge
l_int|0x100000
)paren
(brace
id|addr
op_assign
(paren
r_int
)paren
id|tmp_floppy_area
suffix:semicolon
r_if
c_cond
(paren
id|command
op_eq
id|FD_WRITE
)paren
id|copy_buffer
c_func
(paren
id|CURRENT-&gt;buffer
comma
id|tmp_floppy_area
)paren
suffix:semicolon
)brace
multiline_comment|/* mask DMA 2 */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|immoutb_p
c_func
(paren
l_int|4
op_or
l_int|2
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/* output command byte. I don&squot;t know why, but everyone (minix, */
multiline_comment|/* sanches &amp; canton) output this twice, first to 12 then to 11 */
id|__asm__
c_func
(paren
l_string|&quot;outb %%al,$12&bslash;n&bslash;tjmp 1f&bslash;n1:&bslash;tjmp 1f&bslash;n1:&bslash;t&quot;
l_string|&quot;outb %%al,$11&bslash;n&bslash;tjmp 1f&bslash;n1:&bslash;tjmp 1f&bslash;n1:&quot;
op_scope_resolution
l_string|&quot;a&quot;
(paren
(paren
r_char
)paren
(paren
(paren
id|command
op_eq
id|FD_READ
)paren
ques
c_cond
id|DMA_READ
suffix:colon
id|DMA_WRITE
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* 8 low bits of addr */
id|immoutb_p
c_func
(paren
id|addr
comma
l_int|4
)paren
suffix:semicolon
id|addr
op_rshift_assign
l_int|8
suffix:semicolon
multiline_comment|/* bits 8-15 of addr */
id|immoutb_p
c_func
(paren
id|addr
comma
l_int|4
)paren
suffix:semicolon
id|addr
op_rshift_assign
l_int|8
suffix:semicolon
multiline_comment|/* bits 16-19 of addr */
id|immoutb_p
c_func
(paren
id|addr
comma
l_int|0x81
)paren
suffix:semicolon
multiline_comment|/* low 8 bits of count-1 */
id|count
op_decrement
suffix:semicolon
id|immoutb_p
c_func
(paren
id|count
comma
l_int|5
)paren
suffix:semicolon
id|count
op_rshift_assign
l_int|8
suffix:semicolon
multiline_comment|/* high 8 bits of count-1 */
id|immoutb_p
c_func
(paren
id|count
comma
l_int|5
)paren
suffix:semicolon
multiline_comment|/* activate DMA 2 */
id|immoutb_p
c_func
(paren
l_int|0
op_or
l_int|2
comma
l_int|10
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|output_byte
r_static
r_void
id|output_byte
c_func
(paren
r_char
id|byte
)paren
(brace
r_int
id|counter
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
l_int|10000
suffix:semicolon
id|counter
op_increment
)paren
(brace
id|status
op_assign
id|inb_p
c_func
(paren
id|FD_STATUS
)paren
op_amp
(paren
id|STATUS_READY
op_or
id|STATUS_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|STATUS_READY
)paren
(brace
id|outb
c_func
(paren
id|byte
comma
id|FD_DATA
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
id|reset
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Unable to send byte to FDC&bslash;n&bslash;r&quot;
)paren
suffix:semicolon
)brace
DECL|function|result
r_static
r_int
id|result
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|counter
comma
id|status
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
l_int|10000
suffix:semicolon
id|counter
op_increment
)paren
(brace
id|status
op_assign
id|inb_p
c_func
(paren
id|FD_STATUS
)paren
op_amp
(paren
id|STATUS_DIR
op_or
id|STATUS_READY
op_or
id|STATUS_BUSY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|STATUS_READY
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
(paren
id|STATUS_DIR
op_or
id|STATUS_READY
op_or
id|STATUS_BUSY
)paren
)paren
(brace
r_if
c_cond
(paren
id|i
op_ge
id|MAX_REPLIES
)paren
r_break
suffix:semicolon
id|reply_buffer
(braket
id|i
op_increment
)braket
op_assign
id|inb_p
c_func
(paren
id|FD_DATA
)paren
suffix:semicolon
)brace
)brace
id|reset
op_assign
l_int|1
suffix:semicolon
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Getstatus times out&bslash;n&bslash;r&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|bad_flp_intr
r_static
r_void
id|bad_flp_intr
c_func
(paren
r_void
)paren
(brace
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
id|CURRENT_ERRORS
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT_ERRORS
OG
id|MAX_ERRORS
)paren
(brace
id|floppy_deselect
c_func
(paren
id|current_drive
)paren
suffix:semicolon
id|request_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT_ERRORS
OG
id|MAX_ERRORS
op_div
l_int|2
)paren
id|reset
op_assign
l_int|1
suffix:semicolon
r_else
id|recalibrate
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Ok, this interrupt is called after a DMA read/write has succeeded,&n; * so we check the results, and copy any buffers.&n; */
DECL|function|rw_interrupt
r_static
r_void
id|rw_interrupt
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|buffer_area
suffix:semicolon
r_if
c_cond
(paren
id|result
c_func
(paren
)paren
op_ne
l_int|7
op_logical_or
(paren
id|ST0
op_amp
l_int|0xf8
)paren
op_logical_or
(paren
id|ST1
op_amp
l_int|0xbf
)paren
op_logical_or
(paren
id|ST2
op_amp
l_int|0x73
)paren
)paren
(brace
r_if
c_cond
(paren
id|ST1
op_amp
l_int|0x02
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Drive %d is write protected&bslash;n&bslash;r&quot;
comma
id|current_drive
)paren
suffix:semicolon
id|floppy_deselect
c_func
(paren
id|current_drive
)paren
suffix:semicolon
id|request_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
id|bad_flp_intr
c_func
(paren
)paren
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|probing
)paren
(brace
r_int
id|drive
op_assign
id|MINOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftd_msg
(braket
id|drive
)braket
)paren
id|printk
c_func
(paren
l_string|&quot;Auto-detected floppy type %s in fd%d&bslash;r&bslash;n&quot;
comma
id|floppy-&gt;name
comma
id|drive
)paren
suffix:semicolon
id|current_type
(braket
id|drive
)braket
op_assign
id|floppy
suffix:semicolon
id|floppy_sizes
(braket
id|drive
)braket
op_assign
id|floppy-&gt;size
op_rshift
l_int|1
suffix:semicolon
id|probing
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_track
)paren
(brace
id|buffer_track
op_assign
id|seek_track
suffix:semicolon
id|buffer_drive
op_assign
id|current_drive
suffix:semicolon
id|buffer_area
op_assign
id|floppy_track_buffer
op_plus
(paren
(paren
id|sector
op_minus
l_int|1
op_plus
id|head
op_star
id|floppy-&gt;sect
)paren
op_lshift
l_int|9
)paren
suffix:semicolon
id|copy_buffer
c_func
(paren
id|buffer_area
comma
id|CURRENT-&gt;buffer
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|command
op_eq
id|FD_READ
op_logical_and
(paren
r_int
r_int
)paren
(paren
id|CURRENT-&gt;buffer
)paren
op_ge
l_int|0x100000
)paren
id|copy_buffer
c_func
(paren
id|tmp_floppy_area
comma
id|CURRENT-&gt;buffer
)paren
suffix:semicolon
id|floppy_deselect
c_func
(paren
id|current_drive
)paren
suffix:semicolon
id|request_done
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We try to read tracks, but if we get too many errors, we&n; * go back to reading just one sector at a time.&n; *&n; * This means we should be able to read a sector even if there&n; * are other bad sectors on this track.&n; */
DECL|function|setup_rw_floppy
r_inline
r_void
id|setup_rw_floppy
c_func
(paren
r_void
)paren
(brace
id|setup_DMA
c_func
(paren
)paren
suffix:semicolon
id|do_floppy
op_assign
id|rw_interrupt
suffix:semicolon
id|output_byte
c_func
(paren
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|command
op_ne
id|FD_FORMAT
)paren
(brace
r_if
c_cond
(paren
id|read_track
)paren
(brace
id|output_byte
c_func
(paren
id|current_drive
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|track
)paren
suffix:semicolon
id|output_byte
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|output_byte
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|output_byte
c_func
(paren
id|head
op_lshift
l_int|2
op_or
id|current_drive
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|track
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|head
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|sector
)paren
suffix:semicolon
)brace
id|output_byte
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* sector size = 512 */
id|output_byte
c_func
(paren
id|floppy-&gt;sect
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|floppy-&gt;gap
)paren
suffix:semicolon
id|output_byte
c_func
(paren
l_int|0xFF
)paren
suffix:semicolon
multiline_comment|/* sector size (0xff when n!=0 ?) */
)brace
r_else
(brace
id|output_byte
c_func
(paren
id|head
op_lshift
l_int|2
op_or
id|current_drive
)paren
suffix:semicolon
id|output_byte
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|floppy-&gt;sect
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|floppy-&gt;fmt_gap
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_FILL_BYTE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reset
)paren
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the routine called after every seek (or recalibrate) interrupt&n; * from the floppy controller. Note that the &quot;unexpected interrupt&quot; routine&n; * also does a recalibrate, but doesn&squot;t come here.&n; */
DECL|function|seek_interrupt
r_static
r_void
id|seek_interrupt
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* sense drive status */
id|output_byte
c_func
(paren
id|FD_SENSEI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
c_func
(paren
)paren
op_ne
l_int|2
op_logical_or
(paren
id|ST0
op_amp
l_int|0xF8
)paren
op_ne
l_int|0x20
op_logical_or
id|ST1
op_ne
id|seek_track
)paren
(brace
id|recalibrate
op_assign
l_int|1
suffix:semicolon
id|bad_flp_intr
c_func
(paren
)paren
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|current_track
op_assign
id|ST1
suffix:semicolon
id|setup_rw_floppy
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called when everything should be correctly set up&n; * for the transfer (ie floppy motor is on and the correct floppy is&n; * selected).&n; */
DECL|function|transfer
r_static
r_void
id|transfer
c_func
(paren
r_void
)paren
(brace
id|read_track
op_assign
(paren
id|command
op_eq
id|FD_READ
)paren
op_logical_and
(paren
id|CURRENT_ERRORS
OL
l_int|4
)paren
op_logical_and
(paren
id|floppy-&gt;sect
op_le
id|MAX_BUFFER_SECTORS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur_spec1
op_ne
id|floppy-&gt;spec1
)paren
(brace
id|cur_spec1
op_assign
id|floppy-&gt;spec1
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_SPECIFY
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|cur_spec1
)paren
suffix:semicolon
multiline_comment|/* hut etc */
id|output_byte
c_func
(paren
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Head load time =6ms, DMA */
)brace
r_if
c_cond
(paren
id|cur_rate
op_ne
id|floppy-&gt;rate
)paren
id|outb_p
c_func
(paren
id|cur_rate
op_assign
id|floppy-&gt;rate
comma
id|FD_DCR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
(brace
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|seek
)paren
(brace
id|setup_rw_floppy
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|do_floppy
op_assign
id|seek_interrupt
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_SEEK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_track
)paren
id|output_byte
c_func
(paren
id|current_drive
)paren
suffix:semicolon
r_else
id|output_byte
c_func
(paren
(paren
id|head
op_lshift
l_int|2
)paren
op_or
id|current_drive
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|seek_track
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Special case - used after a unexpected interrupt (or reset)&n; */
r_static
r_void
id|recalibrate_floppy
c_func
(paren
)paren
suffix:semicolon
DECL|function|recal_interrupt
r_static
r_void
id|recal_interrupt
c_func
(paren
r_void
)paren
(brace
id|output_byte
c_func
(paren
id|FD_SENSEI
)paren
suffix:semicolon
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
r_if
c_cond
(paren
id|result
c_func
(paren
)paren
op_ne
l_int|2
op_logical_or
(paren
id|ST0
op_amp
l_int|0xE0
)paren
op_eq
l_int|0x60
)paren
id|reset
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Recalibrate until track 0 is reached. Might help on some errors. */
r_if
c_cond
(paren
(paren
id|ST0
op_amp
l_int|0x10
)paren
op_eq
l_int|0x10
)paren
id|recalibrate_floppy
c_func
(paren
)paren
suffix:semicolon
r_else
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|unexpected_floppy_interrupt
r_void
id|unexpected_floppy_interrupt
c_func
(paren
r_void
)paren
(brace
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_SENSEI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
c_func
(paren
)paren
op_ne
l_int|2
op_logical_or
(paren
id|ST0
op_amp
l_int|0xE0
)paren
op_eq
l_int|0x60
)paren
id|reset
op_assign
l_int|1
suffix:semicolon
r_else
id|recalibrate
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|recalibrate_floppy
r_static
r_void
id|recalibrate_floppy
c_func
(paren
r_void
)paren
(brace
id|recalibrate
op_assign
l_int|0
suffix:semicolon
id|current_track
op_assign
l_int|0
suffix:semicolon
id|do_floppy
op_assign
id|recal_interrupt
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_RECALIBRATE
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|head
op_lshift
l_int|2
op_or
id|current_drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|reset_interrupt
r_static
r_void
id|reset_interrupt
c_func
(paren
r_void
)paren
(brace
id|output_byte
c_func
(paren
id|FD_SENSEI
)paren
suffix:semicolon
(paren
r_void
)paren
id|result
c_func
(paren
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_SPECIFY
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|cur_spec1
)paren
suffix:semicolon
multiline_comment|/* hut etc */
id|output_byte
c_func
(paren
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Head load time =6ms, DMA */
r_if
c_cond
(paren
op_logical_neg
id|recover
)paren
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
r_else
(brace
id|recalibrate_floppy
c_func
(paren
)paren
suffix:semicolon
id|recover
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * reset is done by pulling bit 2 of DOR low for a while.&n; */
DECL|function|reset_floppy
r_static
r_void
id|reset_floppy
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|do_floppy
op_assign
id|reset_interrupt
suffix:semicolon
id|reset
op_assign
l_int|0
suffix:semicolon
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
id|cur_spec1
op_assign
op_minus
l_int|1
suffix:semicolon
id|cur_rate
op_assign
op_minus
l_int|1
suffix:semicolon
id|recalibrate
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Reset-floppy called&bslash;n&bslash;r&quot;
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|current_DOR
op_amp
op_complement
l_int|0x04
comma
id|FD_DOR
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1000
suffix:semicolon
id|i
op_increment
)paren
id|__asm__
c_func
(paren
l_string|&quot;nop&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
id|current_DOR
comma
id|FD_DOR
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|floppy_shutdown
r_static
r_void
id|floppy_shutdown
c_func
(paren
r_void
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|request_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|recover
op_assign
l_int|1
suffix:semicolon
id|reset_floppy
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|shake_done
r_static
r_void
id|shake_done
c_func
(paren
r_void
)paren
(brace
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|FD_DIR
)paren
op_amp
l_int|0x80
)paren
id|request_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|retry_recal
r_static
r_int
id|retry_recal
c_func
(paren
r_void
(paren
op_star
id|proc
)paren
(paren
r_void
)paren
)paren
(brace
id|output_byte
c_func
(paren
id|FD_SENSEI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
c_func
(paren
)paren
op_eq
l_int|2
op_logical_and
(paren
id|ST0
op_amp
l_int|0x10
)paren
op_ne
l_int|0x10
)paren
r_return
l_int|0
suffix:semicolon
id|do_floppy
op_assign
id|proc
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_RECALIBRATE
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|head
op_lshift
l_int|2
op_or
id|current_drive
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|shake_zero
r_static
r_void
id|shake_zero
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|retry_recal
c_func
(paren
id|shake_zero
)paren
)paren
id|shake_done
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|shake_one
r_static
r_void
id|shake_one
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|retry_recal
c_func
(paren
id|shake_one
)paren
)paren
r_return
suffix:semicolon
id|do_floppy
op_assign
id|shake_done
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_SEEK
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|head
op_lshift
l_int|2
op_or
id|current_drive
)paren
suffix:semicolon
id|output_byte
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|floppy_on_interrupt
r_static
r_void
id|floppy_on_interrupt
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|FD_DIR
)paren
op_amp
l_int|0x80
)paren
(brace
id|changed_floppies
op_or_assign
l_int|1
op_lshift
id|current_drive
suffix:semicolon
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|keep_data
(braket
id|current_drive
)braket
)paren
(brace
r_if
c_cond
(paren
id|keep_data
(braket
id|current_drive
)braket
OG
l_int|0
)paren
id|keep_data
(braket
id|current_drive
)braket
op_decrement
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ftd_msg
(braket
id|current_drive
)braket
op_logical_and
id|current_type
(braket
id|current_drive
)braket
op_ne
l_int|NULL
)paren
id|printk
c_func
(paren
l_string|&quot;Disk type is undefined after disk &quot;
l_string|&quot;change in fd%d&bslash;r&bslash;n&quot;
comma
id|current_drive
)paren
suffix:semicolon
id|current_type
(braket
id|current_drive
)braket
op_assign
l_int|NULL
suffix:semicolon
id|floppy_sizes
(braket
id|current_drive
)braket
op_assign
id|MAX_DISK_SIZE
suffix:semicolon
)brace
multiline_comment|/* Forcing the drive to seek makes the &quot;media changed&quot; condition go away.&n;   There should be a cleaner solution for that ... */
r_if
c_cond
(paren
op_logical_neg
id|reset
op_logical_and
op_logical_neg
id|recalibrate
)paren
(brace
id|do_floppy
op_assign
(paren
id|current_track
op_logical_and
id|current_track
op_ne
id|NO_TRACK
)paren
ques
c_cond
id|shake_zero
suffix:colon
id|shake_one
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_RECALIBRATE
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|head
op_lshift
l_int|2
op_or
id|current_drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|reset
)paren
(brace
id|reset_floppy
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|recalibrate
)paren
(brace
id|recalibrate_floppy
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* We cannot do a floppy-select, as that might sleep. We just force it */
id|selected
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|current_drive
op_ne
(paren
id|current_DOR
op_amp
l_int|3
)paren
)paren
(brace
id|seek
op_assign
l_int|1
suffix:semicolon
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
id|current_DOR
op_and_assign
l_int|0xFC
suffix:semicolon
id|current_DOR
op_or_assign
id|current_drive
suffix:semicolon
id|outb
c_func
(paren
id|current_DOR
comma
id|FD_DOR
)paren
suffix:semicolon
id|add_timer
c_func
(paren
l_int|2
comma
op_amp
id|transfer
)paren
suffix:semicolon
)brace
r_else
id|transfer
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|setup_format_params
r_static
r_void
id|setup_format_params
c_func
(paren
r_void
)paren
(brace
r_int
r_char
op_star
id|here
op_assign
(paren
r_int
r_char
op_star
)paren
id|tmp_floppy_area
suffix:semicolon
r_int
id|count
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|1
suffix:semicolon
id|count
op_le
id|floppy-&gt;sect
suffix:semicolon
id|count
op_increment
)paren
(brace
op_star
id|here
op_increment
op_assign
id|track
suffix:semicolon
op_star
id|here
op_increment
op_assign
id|head
suffix:semicolon
op_star
id|here
op_increment
op_assign
id|count
suffix:semicolon
op_star
id|here
op_increment
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* 512 bytes */
)brace
)brace
DECL|function|redo_fd_request
r_static
r_void
id|redo_fd_request
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|block
suffix:semicolon
r_char
op_star
id|buffer_area
suffix:semicolon
r_int
id|device
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
id|format_status
op_eq
id|FORMAT_WAIT
)paren
id|format_status
op_assign
id|FORMAT_BUSY
suffix:semicolon
r_if
c_cond
(paren
id|format_status
op_ne
id|FORMAT_BUSY
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|CURRENT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fdc_busy
)paren
id|panic
c_func
(paren
l_string|&quot;FDC access conflict&quot;
)paren
suffix:semicolon
id|fdc_busy
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
id|CLEAR_INTR
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
op_ne
id|MAJOR_NR
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: request list destroyed&quot;
)paren
suffix:semicolon
"&bslash;"
r_if
c_cond
(paren
id|CURRENT-&gt;bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|CURRENT-&gt;bh-&gt;b_lock
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: block not locked&quot;
)paren
suffix:semicolon
)brace
)brace
id|seek
op_assign
l_int|0
suffix:semicolon
id|probing
op_assign
l_int|0
suffix:semicolon
id|device
op_assign
id|MINOR
c_func
(paren
id|CURRENT_DEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device
OG
l_int|3
)paren
id|floppy
op_assign
(paren
id|device
op_rshift
l_int|2
)paren
op_plus
id|floppy_type
suffix:semicolon
r_else
(brace
multiline_comment|/* Auto-detection */
r_if
c_cond
(paren
(paren
id|floppy
op_assign
id|current_type
(braket
id|device
op_amp
l_int|3
)braket
)paren
op_eq
l_int|NULL
)paren
(brace
id|probing
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|floppy
op_assign
id|base_type
(braket
id|device
op_amp
l_int|3
)braket
)paren
op_eq
l_int|NULL
)paren
(brace
id|request_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|floppy
op_add_assign
id|CURRENT_ERRORS
op_amp
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|format_status
op_ne
id|FORMAT_BUSY
)paren
(brace
r_if
c_cond
(paren
id|current_drive
op_ne
id|CURRENT_DEV
)paren
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
id|current_drive
op_assign
id|CURRENT_DEV
suffix:semicolon
id|block
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
r_if
c_cond
(paren
id|block
op_plus
l_int|2
OG
id|floppy-&gt;size
)paren
(brace
id|request_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|sector
op_assign
id|block
op_mod
id|floppy-&gt;sect
suffix:semicolon
id|block
op_div_assign
id|floppy-&gt;sect
suffix:semicolon
id|head
op_assign
id|block
op_mod
id|floppy-&gt;head
suffix:semicolon
id|track
op_assign
id|block
op_div
id|floppy-&gt;head
suffix:semicolon
id|seek_track
op_assign
id|track
op_lshift
id|floppy-&gt;stretch
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|READ
)paren
id|command
op_assign
id|FD_READ
suffix:semicolon
r_else
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|WRITE
)paren
id|command
op_assign
id|FD_WRITE
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;do_fd_request: unknown command&bslash;n&quot;
)paren
suffix:semicolon
id|request_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|current_drive
op_ne
(paren
id|format_req.device
op_amp
l_int|3
)paren
)paren
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
id|current_drive
op_assign
id|format_req.device
op_amp
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|format_req.track
OL
l_int|0
op_logical_or
id|format_req.track
op_ge
id|floppy-&gt;track
op_logical_or
(paren
id|format_req.head
op_amp
l_int|0xfffe
)paren
op_logical_or
id|probing
)paren
(brace
id|request_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|head
op_assign
id|format_req.head
suffix:semicolon
id|track
op_assign
id|format_req.track
suffix:semicolon
id|seek_track
op_assign
id|track
op_lshift
id|floppy-&gt;stretch
suffix:semicolon
r_if
c_cond
(paren
id|seek_track
op_eq
id|buffer_track
)paren
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|command
op_assign
id|FD_FORMAT
suffix:semicolon
id|setup_format_params
c_func
(paren
)paren
suffix:semicolon
)brace
id|timer_table
(braket
id|FLOPPY_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
l_int|10
op_star
id|HZ
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|FLOPPY_TIMER
suffix:semicolon
r_if
c_cond
(paren
(paren
id|seek_track
op_eq
id|buffer_track
)paren
op_logical_and
(paren
id|current_drive
op_eq
id|buffer_drive
)paren
)paren
(brace
id|buffer_area
op_assign
id|floppy_track_buffer
op_plus
(paren
(paren
id|sector
op_plus
id|head
op_star
id|floppy-&gt;sect
)paren
op_lshift
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
id|command
op_eq
id|FD_READ
)paren
(brace
id|copy_buffer
c_func
(paren
id|buffer_area
comma
id|CURRENT-&gt;buffer
)paren
suffix:semicolon
id|request_done
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|command
op_eq
id|FD_WRITE
)paren
id|copy_buffer
c_func
(paren
id|CURRENT-&gt;buffer
comma
id|buffer_area
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|seek_track
op_ne
id|current_track
)paren
id|seek
op_assign
l_int|1
suffix:semicolon
id|sector
op_increment
suffix:semicolon
id|add_timer
c_func
(paren
id|ticks_to_floppy_on
c_func
(paren
id|current_drive
)paren
comma
op_amp
id|floppy_on_interrupt
)paren
suffix:semicolon
)brace
DECL|function|do_fd_request
r_void
id|do_fd_request
c_func
(paren
r_void
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fdc_busy
)paren
id|sleep_on
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
id|fdc_busy
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fd_ioctl
r_static
r_int
id|fd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|param
)paren
(brace
r_int
id|drive
comma
id|cnt
comma
id|okay
suffix:semicolon
r_struct
id|floppy_struct
op_star
id|this
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|drive
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FDFMTBEG
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|FDFMTEND
suffix:colon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|fake_change
op_or_assign
l_int|1
op_lshift
(paren
id|drive
op_amp
l_int|3
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|drive
op_and_assign
l_int|3
suffix:semicolon
id|cmd
op_assign
id|FDCLRPRM
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDGETPRM
suffix:colon
r_if
c_cond
(paren
id|drive
OG
l_int|3
)paren
id|this
op_assign
op_amp
id|floppy_type
(braket
id|drive
op_rshift
l_int|2
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|this
op_assign
id|current_type
(braket
id|drive
op_amp
l_int|3
)braket
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|verify_area
c_func
(paren
(paren
r_void
op_star
)paren
id|param
comma
r_sizeof
(paren
r_struct
id|floppy_struct
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
r_sizeof
(paren
r_struct
id|floppy_struct
)paren
suffix:semicolon
id|cnt
op_increment
)paren
id|put_fs_byte
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|this
)paren
(braket
id|cnt
)braket
comma
(paren
r_char
op_star
)paren
id|param
op_plus
id|cnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FDFMTTRK
suffix:colon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|format_status
op_ne
id|FORMAT_NONE
)paren
id|sleep_on
c_func
(paren
op_amp
id|format_done
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
r_sizeof
(paren
r_struct
id|format_descr
)paren
suffix:semicolon
id|cnt
op_increment
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|format_req
)paren
(braket
id|cnt
)braket
op_assign
id|get_fs_byte
c_func
(paren
(paren
r_char
op_star
)paren
id|param
op_plus
id|cnt
)paren
suffix:semicolon
id|format_req.device
op_assign
id|drive
suffix:semicolon
id|format_status
op_assign
id|FORMAT_WAIT
suffix:semicolon
id|format_errors
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|format_status
op_ne
id|FORMAT_OKAY
op_logical_and
id|format_status
op_ne
id|FORMAT_ERROR
)paren
(brace
r_if
c_cond
(paren
id|fdc_busy
)paren
id|sleep_on
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
r_else
(brace
id|fdc_busy
op_assign
l_int|1
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|format_status
op_ne
id|FORMAT_OKAY
op_logical_and
id|format_status
op_ne
id|FORMAT_ERROR
)paren
id|sleep_on
c_func
(paren
op_amp
id|format_done
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|okay
op_assign
id|format_status
op_eq
id|FORMAT_OKAY
suffix:semicolon
id|format_status
op_assign
id|FORMAT_NONE
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|format_done
)paren
suffix:semicolon
r_return
id|okay
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drive
template_param
l_int|3
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FDCLRPRM
suffix:colon
id|current_type
(braket
id|drive
)braket
op_assign
l_int|NULL
suffix:semicolon
id|floppy_sizes
(braket
id|drive
)braket
op_assign
id|MAX_DISK_SIZE
suffix:semicolon
id|keep_data
(braket
id|drive
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDSETPRM
suffix:colon
r_case
id|FDDEFPRM
suffix:colon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
r_sizeof
(paren
r_struct
id|floppy_struct
)paren
suffix:semicolon
id|cnt
op_increment
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|user_params
(braket
id|drive
)braket
)paren
(braket
id|cnt
)braket
op_assign
id|get_fs_byte
c_func
(paren
(paren
r_char
op_star
)paren
id|param
op_plus
id|cnt
)paren
suffix:semicolon
id|current_type
(braket
id|drive
)braket
op_assign
op_amp
id|user_params
(braket
id|drive
)braket
suffix:semicolon
id|floppy_sizes
(braket
id|drive
)braket
op_assign
id|user_params
(braket
id|drive
)braket
dot
id|size
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|FDDEFPRM
)paren
id|keep_data
(braket
id|drive
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fdc_busy
)paren
id|sleep_on
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
id|fdc_busy
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
(paren
id|current_DOR
op_amp
l_int|0xfc
)paren
op_or
id|drive
op_or
(paren
l_int|0x10
op_lshift
id|drive
)paren
comma
id|FD_DOR
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
l_int|1000
suffix:semicolon
id|cnt
op_increment
)paren
id|__asm__
c_func
(paren
l_string|&quot;nop&quot;
)paren
suffix:semicolon
id|keep_data
(braket
id|drive
)braket
op_assign
(paren
id|inb
c_func
(paren
id|FD_DIR
)paren
op_amp
l_int|0x80
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|outb_p
c_func
(paren
id|current_DOR
comma
id|FD_DOR
)paren
suffix:semicolon
id|fdc_busy
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|FDMSGON
suffix:colon
id|ftd_msg
(braket
id|drive
)braket
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDMSGOFF
suffix:colon
id|ftd_msg
(braket
id|drive
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|CMOS_READ
mdefine_line|#define CMOS_READ(addr) ({ &bslash;&n;outb_p(0x80|addr,0x70); &bslash;&n;inb_p(0x71); &bslash;&n;})
DECL|function|find_base
r_static
r_struct
id|floppy_struct
op_star
id|find_base
c_func
(paren
r_int
id|drive
comma
r_int
id|code
)paren
(brace
r_struct
id|floppy_struct
op_star
id|base
suffix:semicolon
r_if
c_cond
(paren
id|code
OG
l_int|0
op_logical_and
id|code
OL
l_int|5
)paren
(brace
id|base
op_assign
op_amp
id|floppy_types
(braket
(paren
id|code
op_minus
l_int|1
)paren
op_star
l_int|2
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fd%d is %s&quot;
comma
id|drive
comma
id|base-&gt;name
)paren
suffix:semicolon
r_return
id|base
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;fd%d is unknown type %d&quot;
comma
id|drive
comma
id|code
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|config_types
r_static
r_void
id|config_types
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Floppy drive(s): &quot;
)paren
suffix:semicolon
id|base_type
(braket
l_int|0
)braket
op_assign
id|find_base
c_func
(paren
l_int|0
comma
(paren
id|CMOS_READ
c_func
(paren
l_int|0x10
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|15
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|CMOS_READ
c_func
(paren
l_int|0x14
)paren
op_rshift
l_int|6
)paren
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
id|base_type
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, &quot;
)paren
suffix:semicolon
id|base_type
(braket
l_int|1
)braket
op_assign
id|find_base
c_func
(paren
l_int|1
comma
id|CMOS_READ
c_func
(paren
l_int|0x10
)paren
op_amp
l_int|15
)paren
suffix:semicolon
)brace
id|base_type
(braket
l_int|2
)braket
op_assign
id|base_type
(braket
l_int|3
)braket
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;r&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|floppy_open
r_static
r_int
id|floppy_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_if
c_cond
(paren
id|filp-&gt;f_mode
)paren
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|floppy_release
r_static
r_void
id|floppy_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|sync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
)brace
DECL|variable|floppy_fops
r_static
r_struct
id|file_operations
id|floppy_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|fd_ioctl
comma
multiline_comment|/* ioctl */
id|floppy_open
comma
multiline_comment|/* open */
id|floppy_release
multiline_comment|/* release */
)brace
suffix:semicolon
DECL|function|floppy_init
r_void
id|floppy_init
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
id|current_DOR
comma
id|FD_DOR
)paren
suffix:semicolon
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
id|floppy_sizes
suffix:semicolon
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|blkdev_fops
(braket
id|MAJOR_NR
)braket
op_assign
op_amp
id|floppy_fops
suffix:semicolon
id|timer_table
(braket
id|FLOPPY_TIMER
)braket
dot
id|fn
op_assign
id|floppy_shutdown
suffix:semicolon
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|FLOPPY_TIMER
)paren
suffix:semicolon
id|config_types
c_func
(paren
)paren
suffix:semicolon
id|set_intr_gate
c_func
(paren
l_int|0x26
comma
op_amp
id|floppy_interrupt
)paren
suffix:semicolon
id|outb
c_func
(paren
id|inb_p
c_func
(paren
l_int|0x21
)paren
op_amp
op_complement
l_int|0x40
comma
l_int|0x21
)paren
suffix:semicolon
)brace
eof
