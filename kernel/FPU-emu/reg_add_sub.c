multiline_comment|/*---------------------------------------------------------------------------+&n; |  reg_add_sub.c                                                            |&n; |                                                                           |&n; | Functions to add or subtract two registers and put the result in a third. |&n; |                                                                           |&n; | Copyright (C) 1992,1993                                                   |&n; |                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,      |&n; |                       Australia.  E-mail apm233m@vaxc.cc.monash.edu.au    |&n; |                                                                           |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
multiline_comment|/*---------------------------------------------------------------------------+&n; | For each function, the destination may be any FPU_REG, including one of   |&n; | the source FPU_REGs.                                                      |&n; +---------------------------------------------------------------------------*/
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;reg_constant.h&quot;
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &quot;control_w.h&quot;
macro_line|#include &quot;fpu_system.h&quot;
DECL|function|reg_add
r_void
id|reg_add
c_func
(paren
id|FPU_REG
op_star
id|a
comma
id|FPU_REG
op_star
id|b
comma
id|FPU_REG
op_star
id|dest
)paren
(brace
r_int
id|diff
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|a-&gt;tag
op_or
id|b-&gt;tag
)paren
)paren
(brace
multiline_comment|/* Both registers are valid */
r_if
c_cond
(paren
op_logical_neg
(paren
id|a-&gt;sign
op_xor
id|b-&gt;sign
)paren
)paren
(brace
multiline_comment|/* signs are the same */
id|reg_u_add
c_func
(paren
id|a
comma
id|b
comma
id|dest
)paren
suffix:semicolon
id|dest-&gt;sign
op_assign
id|a-&gt;sign
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* The signs are different, so do a subtraction */
id|diff
op_assign
id|a-&gt;exp
op_minus
id|b-&gt;exp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|diff
)paren
(brace
id|diff
op_assign
id|a-&gt;sigh
op_minus
id|b-&gt;sigh
suffix:semicolon
multiline_comment|/* Works only if ms bits are identical */
r_if
c_cond
(paren
op_logical_neg
id|diff
)paren
(brace
id|diff
op_assign
id|a-&gt;sigl
OG
id|b-&gt;sigl
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|diff
)paren
id|diff
op_assign
op_minus
(paren
id|a-&gt;sigl
OL
id|b-&gt;sigl
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|diff
OG
l_int|0
)paren
(brace
id|reg_u_sub
c_func
(paren
id|a
comma
id|b
comma
id|dest
)paren
suffix:semicolon
id|dest-&gt;sign
op_assign
id|a-&gt;sign
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|diff
op_eq
l_int|0
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|dest
)paren
suffix:semicolon
multiline_comment|/* sign depends upon rounding mode */
id|dest-&gt;sign
op_assign
(paren
(paren
id|control_word
op_amp
id|CW_RC
)paren
op_ne
id|RC_DOWN
)paren
ques
c_cond
id|SIGN_POS
suffix:colon
id|SIGN_NEG
suffix:semicolon
)brace
r_else
(brace
id|reg_u_sub
c_func
(paren
id|b
comma
id|a
comma
id|dest
)paren
suffix:semicolon
id|dest-&gt;sign
op_assign
id|b-&gt;sign
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|a-&gt;tag
op_eq
id|TW_NaN
)paren
op_logical_or
(paren
id|b-&gt;tag
op_eq
id|TW_NaN
)paren
)paren
(brace
id|real_2op_NaN
c_func
(paren
id|a
comma
id|b
comma
id|dest
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|a-&gt;tag
op_eq
id|TW_Zero
)paren
(brace
r_if
c_cond
(paren
id|b-&gt;tag
op_eq
id|TW_Zero
)paren
(brace
r_char
id|different_signs
op_assign
id|a-&gt;sign
op_xor
id|b-&gt;sign
suffix:semicolon
multiline_comment|/* Both are zero, result will be zero. */
id|reg_move
c_func
(paren
id|a
comma
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
id|different_signs
)paren
(brace
multiline_comment|/* Signs are different. */
multiline_comment|/* Sign of answer depends upon rounding mode. */
id|dest-&gt;sign
op_assign
(paren
(paren
id|control_word
op_amp
id|CW_RC
)paren
op_ne
id|RC_DOWN
)paren
ques
c_cond
id|SIGN_POS
suffix:colon
id|SIGN_NEG
suffix:semicolon
)brace
)brace
r_else
id|reg_move
c_func
(paren
id|b
comma
id|dest
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|b-&gt;tag
op_eq
id|TW_Zero
)paren
(brace
id|reg_move
c_func
(paren
id|a
comma
id|dest
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|a-&gt;tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|b-&gt;tag
op_ne
id|TW_Infinity
)paren
(brace
id|reg_move
c_func
(paren
id|a
comma
id|dest
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* They are both + or - infinity */
r_if
c_cond
(paren
id|a-&gt;sign
op_eq
id|b-&gt;sign
)paren
(brace
id|reg_move
c_func
(paren
id|a
comma
id|dest
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|reg_move
c_func
(paren
op_amp
id|CONST_QNaN
comma
id|dest
)paren
suffix:semicolon
multiline_comment|/* inf - inf is undefined. */
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|b-&gt;tag
op_eq
id|TW_Infinity
)paren
(brace
id|reg_move
c_func
(paren
id|b
comma
id|dest
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#ifdef PARANOID
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x101
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Subtract b from a.  (a-b) -&gt; dest */
DECL|function|reg_sub
r_void
id|reg_sub
c_func
(paren
id|FPU_REG
op_star
id|a
comma
id|FPU_REG
op_star
id|b
comma
id|FPU_REG
op_star
id|dest
)paren
(brace
r_int
id|diff
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|a-&gt;tag
op_or
id|b-&gt;tag
)paren
)paren
(brace
multiline_comment|/* Both registers are valid */
id|diff
op_assign
id|a-&gt;exp
op_minus
id|b-&gt;exp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|diff
)paren
(brace
id|diff
op_assign
id|a-&gt;sigh
op_minus
id|b-&gt;sigh
suffix:semicolon
multiline_comment|/* Works only if ms bits are identical */
r_if
c_cond
(paren
op_logical_neg
id|diff
)paren
(brace
id|diff
op_assign
id|a-&gt;sigl
OG
id|b-&gt;sigl
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|diff
)paren
id|diff
op_assign
op_minus
(paren
id|a-&gt;sigl
OL
id|b-&gt;sigl
)paren
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|a-&gt;sign
op_star
l_int|2
op_plus
id|b-&gt;sign
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* P - P */
r_case
l_int|3
suffix:colon
multiline_comment|/* N - N */
r_if
c_cond
(paren
id|diff
OG
l_int|0
)paren
(brace
id|reg_u_sub
c_func
(paren
id|a
comma
id|b
comma
id|dest
)paren
suffix:semicolon
id|dest-&gt;sign
op_assign
id|a-&gt;sign
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|diff
op_eq
l_int|0
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|dest
)paren
suffix:semicolon
multiline_comment|/* sign depends upon rounding mode */
id|dest-&gt;sign
op_assign
(paren
(paren
id|control_word
op_amp
id|CW_RC
)paren
op_ne
id|RC_DOWN
)paren
ques
c_cond
id|SIGN_POS
suffix:colon
id|SIGN_NEG
suffix:semicolon
)brace
r_else
(brace
id|reg_u_sub
c_func
(paren
id|b
comma
id|a
comma
id|dest
)paren
suffix:semicolon
id|dest-&gt;sign
op_assign
id|a-&gt;sign
op_xor
id|SIGN_POS
op_xor
id|SIGN_NEG
suffix:semicolon
)brace
r_return
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* P - N */
id|reg_u_add
c_func
(paren
id|a
comma
id|b
comma
id|dest
)paren
suffix:semicolon
id|dest-&gt;sign
op_assign
id|SIGN_POS
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* N - P */
id|reg_u_add
c_func
(paren
id|a
comma
id|b
comma
id|dest
)paren
suffix:semicolon
id|dest-&gt;sign
op_assign
id|SIGN_NEG
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|a-&gt;tag
op_eq
id|TW_NaN
)paren
op_logical_or
(paren
id|b-&gt;tag
op_eq
id|TW_NaN
)paren
)paren
(brace
id|real_2op_NaN
c_func
(paren
id|a
comma
id|b
comma
id|dest
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|b-&gt;tag
op_eq
id|TW_Zero
)paren
(brace
r_if
c_cond
(paren
id|a-&gt;tag
op_eq
id|TW_Zero
)paren
(brace
r_char
id|same_signs
op_assign
op_logical_neg
(paren
id|a-&gt;sign
op_xor
id|b-&gt;sign
)paren
suffix:semicolon
multiline_comment|/* Both are zero, result will be zero. */
id|reg_move
c_func
(paren
id|a
comma
id|dest
)paren
suffix:semicolon
multiline_comment|/* Answer for different signs. */
r_if
c_cond
(paren
id|same_signs
)paren
(brace
multiline_comment|/* Sign depends upon rounding mode */
id|dest-&gt;sign
op_assign
(paren
(paren
id|control_word
op_amp
id|CW_RC
)paren
op_ne
id|RC_DOWN
)paren
ques
c_cond
id|SIGN_POS
suffix:colon
id|SIGN_NEG
suffix:semicolon
)brace
)brace
r_else
id|reg_move
c_func
(paren
id|a
comma
id|dest
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|a-&gt;tag
op_eq
id|TW_Zero
)paren
(brace
id|reg_move
c_func
(paren
id|b
comma
id|dest
)paren
suffix:semicolon
id|dest-&gt;sign
op_xor_assign
id|SIGN_POS
op_xor
id|SIGN_NEG
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|a-&gt;tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|b-&gt;tag
op_ne
id|TW_Infinity
)paren
(brace
id|reg_move
c_func
(paren
id|a
comma
id|dest
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|a-&gt;sign
op_eq
id|b-&gt;sign
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_QNaN
comma
id|dest
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|reg_move
c_func
(paren
id|a
comma
id|dest
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|b-&gt;tag
op_eq
id|TW_Infinity
)paren
(brace
id|reg_move
c_func
(paren
id|b
comma
id|dest
)paren
suffix:semicolon
id|dest-&gt;sign
op_xor_assign
id|SIGN_POS
op_xor
id|SIGN_NEG
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#ifdef PARANOID
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x110
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
