multiline_comment|/*---------------------------------------------------------------------------+&n; |  fpu_trig.c                                                               |&n; |                                                                           |&n; | Implementation of the FPU &quot;transcendental&quot; functions.                     |&n; |                                                                           |&n; | Copyright (C) 1992,1993                                                   |&n; |                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,      |&n; |                       Australia.  E-mail apm233m@vaxc.cc.monash.edu.au    |&n; |                                                                           |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
macro_line|#include &quot;fpu_system.h&quot;
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &quot;status_w.h&quot;
macro_line|#include &quot;control_w.h&quot;
macro_line|#include &quot;reg_constant.h&quot;&t;
DECL|function|trig_arg
r_static
r_int
id|trig_arg
c_func
(paren
id|FPU_REG
op_star
id|X
)paren
(brace
id|FPU_REG
id|tmp
comma
id|quot
suffix:semicolon
r_int
id|rv
suffix:semicolon
r_int
r_int
id|q
suffix:semicolon
r_int
id|old_cw
op_assign
id|control_word
suffix:semicolon
id|control_word
op_and_assign
op_complement
id|CW_RC
suffix:semicolon
id|control_word
op_or_assign
id|RC_CHOP
suffix:semicolon
id|reg_move
c_func
(paren
id|X
comma
op_amp
id|quot
)paren
suffix:semicolon
id|reg_div
c_func
(paren
op_amp
id|quot
comma
op_amp
id|CONST_PI2
comma
op_amp
id|quot
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|quot
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|round_to_int
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp.sigh
op_amp
l_int|0x80000000
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* |Arg| is &gt;= 2^63 */
id|tmp.exp
op_assign
id|EXP_BIAS
op_plus
l_int|63
suffix:semicolon
id|q
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
(paren
id|tmp.sigl
)paren
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|reg_sub
c_func
(paren
op_amp
id|quot
comma
op_amp
id|tmp
comma
id|X
)paren
suffix:semicolon
id|rv
op_assign
id|q
op_amp
l_int|7
suffix:semicolon
id|control_word
op_assign
id|old_cw
suffix:semicolon
r_return
id|rv
suffix:semicolon
suffix:semicolon
)brace
multiline_comment|/* Convert a long to register */
DECL|function|convert_l2reg
r_void
id|convert_l2reg
c_func
(paren
r_int
op_star
id|arg
comma
id|FPU_REG
op_star
id|dest
)paren
(brace
r_int
id|num
op_assign
op_star
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|num
op_eq
l_int|0
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|dest
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|num
OG
l_int|0
)paren
id|dest-&gt;sign
op_assign
id|SIGN_POS
suffix:semicolon
r_else
(brace
id|num
op_assign
op_minus
id|num
suffix:semicolon
id|dest-&gt;sign
op_assign
id|SIGN_NEG
suffix:semicolon
)brace
id|dest-&gt;sigh
op_assign
id|num
suffix:semicolon
id|dest-&gt;sigl
op_assign
l_int|0
suffix:semicolon
id|dest-&gt;exp
op_assign
id|EXP_BIAS
op_plus
l_int|31
suffix:semicolon
id|dest-&gt;tag
op_assign
id|TW_Valid
suffix:semicolon
id|normalize
c_func
(paren
id|dest
)paren
suffix:semicolon
)brace
DECL|function|single_arg_error
r_static
r_void
id|single_arg_error
c_func
(paren
r_void
)paren
(brace
r_switch
c_cond
(paren
id|FPU_st0_tag
)paren
(brace
r_case
id|TW_NaN
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|FPU_st0_ptr-&gt;sigh
op_amp
l_int|0x40000000
)paren
)paren
multiline_comment|/* Signaling ? */
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
multiline_comment|/* Convert to a QNaN */
id|FPU_st0_ptr-&gt;sigh
op_or_assign
l_int|0x40000000
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* return with a NaN in st(0) */
r_case
id|TW_Empty
suffix:colon
id|stack_underflow
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Puts a QNaN in st(0) */
r_break
suffix:semicolon
macro_line|#ifdef PARANOID
r_default
suffix:colon
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x0112
)paren
suffix:semicolon
macro_line|#endif PARANOID
)brace
)brace
multiline_comment|/*---------------------------------------------------------------------------*/
DECL|function|f2xm1
r_static
r_void
id|f2xm1
c_func
(paren
r_void
)paren
(brace
r_switch
c_cond
(paren
id|FPU_st0_tag
)paren
(brace
r_case
id|TW_Valid
suffix:colon
(brace
id|FPU_REG
id|rv
comma
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_POS
)paren
(brace
multiline_comment|/* poly_2xm1(x) requires 0 &lt; x &lt; 1. */
r_if
c_cond
(paren
id|poly_2xm1
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|rv
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* error */
id|reg_mul
c_func
(paren
op_amp
id|rv
comma
id|FPU_st0_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* **** Should change poly_2xm1() to at least handle numbers near 0 */
multiline_comment|/* poly_2xm1(x) doesn&squot;t handle negative numbers. */
multiline_comment|/* So we compute (poly_2xm1(x+1)-1)/2, for -1 &lt; x &lt; 0 */
id|reg_add
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|CONST_1
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|poly_2xm1
c_func
(paren
op_amp
id|tmp
comma
op_amp
id|rv
)paren
suffix:semicolon
id|reg_mul
c_func
(paren
op_amp
id|rv
comma
op_amp
id|tmp
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|reg_sub
c_func
(paren
op_amp
id|tmp
comma
op_amp
id|CONST_1
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;exp
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
id|arith_underflow
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_case
id|TW_Zero
suffix:colon
r_return
suffix:semicolon
r_case
id|TW_Infinity
suffix:colon
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_NEG
)paren
(brace
multiline_comment|/* -infinity gives -1 (p16-10) */
id|reg_move
c_func
(paren
op_amp
id|CONST_1
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|SIGN_NEG
suffix:semicolon
)brace
r_return
suffix:semicolon
r_default
suffix:colon
id|single_arg_error
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|fptan
r_static
r_void
id|fptan
c_func
(paren
r_void
)paren
(brace
id|FPU_REG
op_star
id|st_new_ptr
suffix:semicolon
r_int
id|q
suffix:semicolon
r_char
id|arg_sign
op_assign
id|FPU_st0_ptr-&gt;sign
suffix:semicolon
r_if
c_cond
(paren
id|STACK_OVERFLOW
)paren
(brace
id|stack_overflow
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|FPU_st0_tag
)paren
(brace
r_case
id|TW_Valid
suffix:colon
id|FPU_st0_ptr-&gt;sign
op_assign
id|SIGN_POS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q
op_assign
id|trig_arg
c_func
(paren
id|FPU_st0_ptr
)paren
)paren
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|q
op_amp
l_int|1
)paren
id|reg_sub
c_func
(paren
op_amp
id|CONST_1
comma
id|FPU_st0_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|poly_tan
c_func
(paren
id|FPU_st0_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
(paren
id|q
op_amp
l_int|1
)paren
op_xor
id|arg_sign
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
id|arith_underflow
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_1
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Operand is out of range */
id|setcc
c_func
(paren
id|SW_C2
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|arg_sign
suffix:semicolon
multiline_comment|/* restore st(0) */
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TW_Infinity
suffix:colon
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|TW_Zero
suffix:colon
id|push
c_func
(paren
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_1
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|single_arg_error
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|fxtract
r_static
r_void
id|fxtract
c_func
(paren
r_void
)paren
(brace
id|FPU_REG
op_star
id|st_new_ptr
suffix:semicolon
r_register
id|FPU_REG
op_star
id|st1_ptr
op_assign
id|FPU_st0_ptr
suffix:semicolon
multiline_comment|/* anticipate */
r_if
c_cond
(paren
id|STACK_OVERFLOW
)paren
(brace
id|stack_overflow
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|FPU_st0_tag
op_xor
id|TW_Valid
)paren
)paren
(brace
r_int
id|e
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|reg_move
c_func
(paren
id|st1_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;exp
op_assign
id|EXP_BIAS
suffix:semicolon
id|e
op_assign
id|st1_ptr-&gt;exp
op_minus
id|EXP_BIAS
suffix:semicolon
id|convert_l2reg
c_func
(paren
op_amp
id|e
comma
id|st1_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
(brace
r_char
id|sign
op_assign
id|FPU_st0_ptr-&gt;sign
suffix:semicolon
id|divide_by_zero
c_func
(paren
id|SIGN_NEG
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_char
id|sign
op_assign
id|FPU_st0_ptr-&gt;sign
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|SIGN_POS
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_INF
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|FPU_st0_ptr-&gt;sigh
op_amp
l_int|0x40000000
)paren
)paren
multiline_comment|/* Signaling ? */
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
multiline_comment|/* Convert to a QNaN */
id|FPU_st0_ptr-&gt;sigh
op_or_assign
l_int|0x40000000
suffix:semicolon
)brace
id|push
c_func
(paren
)paren
suffix:semicolon
id|reg_move
c_func
(paren
id|st1_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
(brace
multiline_comment|/* Is this the correct behaviour? */
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
id|stack_underflow
c_func
(paren
)paren
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|stack_underflow
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
r_else
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x119
)paren
suffix:semicolon
macro_line|#endif PARANOID
)brace
DECL|function|fdecstp
r_static
r_void
id|fdecstp
c_func
(paren
r_void
)paren
(brace
id|top
op_decrement
suffix:semicolon
multiline_comment|/* FPU_st0_ptr will be fixed in math_emulate() before the next instr */
)brace
DECL|function|fincstp
r_static
r_void
id|fincstp
c_func
(paren
r_void
)paren
(brace
id|top
op_increment
suffix:semicolon
multiline_comment|/* FPU_st0_ptr will be fixed in math_emulate() before the next instr */
)brace
DECL|function|fsqrt_
r_static
r_void
id|fsqrt_
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|FPU_st0_tag
op_xor
id|TW_Valid
)paren
)paren
(brace
r_int
id|expon
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_NEG
)paren
(brace
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|expon
op_assign
id|FPU_st0_ptr-&gt;exp
op_minus
id|EXP_BIAS
suffix:semicolon
id|FPU_st0_ptr-&gt;exp
op_assign
id|EXP_BIAS
op_plus
(paren
id|expon
op_amp
l_int|1
)paren
suffix:semicolon
multiline_comment|/* make st(0) in  [1.0 .. 4.0) */
id|wm_sqrt
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
multiline_comment|/* Do the computation */
id|FPU_st0_ptr-&gt;exp
op_add_assign
id|expon
op_rshift
l_int|1
suffix:semicolon
id|FPU_st0_ptr-&gt;tag
op_assign
id|TW_Valid
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|SIGN_POS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
r_return
suffix:semicolon
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_NEG
)paren
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|single_arg_error
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|PRECISION_ADJUST
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
)brace
DECL|function|frndint_
r_static
r_void
id|frndint_
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|FPU_st0_tag
op_xor
id|TW_Valid
)paren
)paren
(brace
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
OG
id|EXP_BIAS
op_plus
l_int|63
)paren
r_return
suffix:semicolon
id|round_to_int
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
multiline_comment|/* Fortunately, this can&squot;t overflow to 2^64 */
id|FPU_st0_ptr-&gt;exp
op_assign
id|EXP_BIAS
op_plus
l_int|63
suffix:semicolon
id|normalize
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
op_logical_or
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
)paren
r_return
suffix:semicolon
r_else
id|single_arg_error
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fsin
r_static
r_void
id|fsin
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Valid
)paren
(brace
r_int
id|q
suffix:semicolon
r_char
id|arg_sign
op_assign
id|FPU_st0_ptr-&gt;sign
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|SIGN_POS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q
op_assign
id|trig_arg
c_func
(paren
id|FPU_st0_ptr
)paren
)paren
op_ne
op_minus
l_int|1
)paren
(brace
id|FPU_REG
id|rv
suffix:semicolon
r_if
c_cond
(paren
id|q
op_amp
l_int|1
)paren
id|reg_sub
c_func
(paren
op_amp
id|CONST_1
comma
id|FPU_st0_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|poly_sine
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|rv
)paren
suffix:semicolon
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
op_amp
l_int|2
)paren
id|rv.sign
op_xor_assign
id|SIGN_POS
op_xor
id|SIGN_NEG
suffix:semicolon
id|rv.sign
op_xor_assign
id|arg_sign
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|rv
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
id|arith_underflow
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Operand is out of range */
id|setcc
c_func
(paren
id|SW_C2
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|arg_sign
suffix:semicolon
multiline_comment|/* restore st(0) */
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
(brace
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
id|single_arg_error
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|f_cos
r_static
r_int
id|f_cos
c_func
(paren
id|FPU_REG
op_star
id|arg
)paren
(brace
r_if
c_cond
(paren
id|arg-&gt;tag
op_eq
id|TW_Valid
)paren
(brace
r_int
id|q
suffix:semicolon
r_char
id|arg_sign
op_assign
id|arg-&gt;sign
suffix:semicolon
id|arg-&gt;sign
op_assign
id|SIGN_POS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q
op_assign
id|trig_arg
c_func
(paren
id|arg
)paren
)paren
op_ne
op_minus
l_int|1
)paren
(brace
id|FPU_REG
id|rv
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|q
op_amp
l_int|1
)paren
)paren
id|reg_sub
c_func
(paren
op_amp
id|CONST_1
comma
id|arg
comma
id|arg
)paren
suffix:semicolon
id|poly_sine
c_func
(paren
id|arg
comma
op_amp
id|rv
)paren
suffix:semicolon
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q
op_plus
l_int|1
)paren
op_amp
l_int|2
)paren
id|rv.sign
op_xor_assign
id|SIGN_POS
op_xor
id|SIGN_NEG
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|rv
comma
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Operand is out of range */
id|setcc
c_func
(paren
id|SW_C2
)paren
suffix:semicolon
id|arg-&gt;sign
op_assign
id|arg_sign
suffix:semicolon
multiline_comment|/* restore st(0) */
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|arg-&gt;tag
op_eq
id|TW_Zero
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_1
comma
id|arg
)paren
suffix:semicolon
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|single_arg_error
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* requires arg == &amp;st(0) */
r_return
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|fcos
r_static
r_void
id|fcos
c_func
(paren
r_void
)paren
(brace
id|f_cos
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
)brace
DECL|function|fsincos
r_static
r_void
id|fsincos
c_func
(paren
r_void
)paren
(brace
id|FPU_REG
op_star
id|st_new_ptr
suffix:semicolon
id|FPU_REG
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|STACK_OVERFLOW
)paren
(brace
id|stack_overflow
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f_cos
c_func
(paren
op_amp
id|arg
)paren
)paren
(brace
id|fsin
c_func
(paren
)paren
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|arg
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*---------------------------------------------------------------------------*/
multiline_comment|/* The following all require two arguments: st(0) and st(1) */
multiline_comment|/* remainder of st(0) / st(1) */
multiline_comment|/* Assumes that st(0) and st(1) are both TW_Valid */
DECL|function|fprem_kernel
r_static
r_void
id|fprem_kernel
c_func
(paren
r_int
id|round
)paren
(brace
id|FPU_REG
op_star
id|st1_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_char
id|st1_tag
op_assign
id|st1_ptr-&gt;tag
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|FPU_st0_tag
op_xor
id|TW_Valid
)paren
op_or
(paren
id|st1_tag
op_xor
id|TW_Valid
)paren
)paren
)paren
(brace
id|FPU_REG
id|tmp
suffix:semicolon
r_int
id|old_cw
op_assign
id|control_word
suffix:semicolon
r_int
id|expdif
op_assign
id|FPU_st0_ptr-&gt;exp
op_minus
(paren
id|st1_ptr
)paren
op_member_access_from_pointer
id|exp
suffix:semicolon
id|control_word
op_and_assign
op_complement
id|CW_RC
suffix:semicolon
id|control_word
op_or_assign
id|round
suffix:semicolon
r_if
c_cond
(paren
id|expdif
OL
l_int|64
)paren
(brace
multiline_comment|/* This should be the most common case */
r_int
r_int
id|q
suffix:semicolon
r_int
id|c
op_assign
l_int|0
suffix:semicolon
id|reg_div
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|round_to_int
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* Fortunately, this can&squot;t overflow to 2^64 */
id|tmp.exp
op_assign
id|EXP_BIAS
op_plus
l_int|63
suffix:semicolon
id|q
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
(paren
id|tmp.sigl
)paren
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|reg_mul
c_func
(paren
id|st1_ptr
comma
op_amp
id|tmp
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|reg_sub
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|tmp
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
op_amp
l_int|4
)paren
id|c
op_or_assign
id|SW_C3
suffix:semicolon
r_if
c_cond
(paren
id|q
op_amp
l_int|2
)paren
id|c
op_or_assign
id|SW_C1
suffix:semicolon
r_if
c_cond
(paren
id|q
op_amp
l_int|1
)paren
id|c
op_or_assign
id|SW_C0
suffix:semicolon
id|setcc
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* There is a large exponent difference ( &gt;= 64 ) */
r_int
id|N_exp
suffix:semicolon
id|reg_div
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* N is &squot;a number between 32 and 63&squot; (p26-113) */
id|N_exp
op_assign
(paren
id|tmp.exp
op_amp
l_int|31
)paren
op_plus
l_int|32
suffix:semicolon
id|tmp.exp
op_assign
id|EXP_BIAS
op_plus
id|N_exp
suffix:semicolon
id|round_to_int
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* Fortunately, this can&squot;t overflow to 2^64 */
id|tmp.exp
op_assign
id|EXP_BIAS
op_plus
l_int|63
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|tmp.exp
op_assign
id|EXP_BIAS
op_plus
id|expdif
op_minus
id|N_exp
suffix:semicolon
id|reg_mul
c_func
(paren
id|st1_ptr
comma
op_amp
id|tmp
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|reg_sub
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|tmp
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|setcc
c_func
(paren
id|SW_C2
)paren
suffix:semicolon
)brace
id|control_word
op_assign
id|old_cw
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
id|arith_underflow
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
op_or
(paren
id|st1_tag
op_eq
id|TW_Empty
)paren
)paren
(brace
id|stack_underflow
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
(brace
r_if
c_cond
(paren
(paren
id|st1_tag
op_eq
id|TW_Valid
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
)paren
(brace
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Zero
)paren
(brace
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
op_or
(paren
id|st1_tag
op_eq
id|TW_NaN
)paren
)paren
(brace
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
r_else
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x118
)paren
suffix:semicolon
macro_line|#endif PARANOID
)brace
multiline_comment|/* ST(1) &lt;- ST(1) * log ST;  pop ST */
DECL|function|fyl2x
r_static
r_void
id|fyl2x
c_func
(paren
r_void
)paren
(brace
id|FPU_REG
op_star
id|st1_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_char
id|st1_tag
op_assign
id|st1_ptr-&gt;tag
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|FPU_st0_tag
op_xor
id|TW_Valid
)paren
op_or
(paren
id|st1_tag
op_xor
id|TW_Valid
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_POS
)paren
(brace
id|poly_l2
c_func
(paren
id|FPU_st0_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|reg_mul
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|st1_ptr
)paren
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
id|FPU_st0_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
(brace
id|arith_underflow
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
op_ge
id|EXP_OVER
)paren
(brace
id|arith_overflow
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* negative&t;*/
id|pop
c_func
(paren
)paren
suffix:semicolon
id|FPU_st0_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_Empty
)paren
)paren
(brace
id|stack_underflow
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_NaN
)paren
)paren
(brace
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|st1_ptr
)paren
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_le
id|TW_Zero
)paren
op_logical_and
(paren
id|st1_tag
op_le
id|TW_Zero
)paren
)paren
(brace
multiline_comment|/* one of the args is zero, the other valid, or both zero */
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
(brace
id|pop
c_func
(paren
)paren
suffix:semicolon
id|FPU_st0_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;tag
op_eq
id|TW_Zero
)paren
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_else
id|divide_by_zero
c_func
(paren
id|st1_ptr-&gt;sign
op_xor
id|SIGN_NEG
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_ptr-&gt;sign
op_eq
id|SIGN_POS
)paren
(brace
multiline_comment|/* Zero is the valid answer */
r_char
id|sign
op_assign
id|FPU_st0_ptr-&gt;sign
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
OL
id|EXP_BIAS
)paren
id|sign
op_xor_assign
id|SIGN_NEG
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
id|FPU_st0_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|pop
c_func
(paren
)paren
suffix:semicolon
id|FPU_st0_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* One or both arg must be an infinity */
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_NEG
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_Zero
)paren
)paren
(brace
id|pop
c_func
(paren
)paren
suffix:semicolon
id|FPU_st0_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
r_char
id|sign
op_assign
id|st1_ptr-&gt;sign
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
id|FPU_st0_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_INF
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* st(1) must be infinity here */
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_Valid
)paren
op_logical_and
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_POS
)paren
)paren
(brace
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
op_ge
id|EXP_BIAS
)paren
(brace
r_if
c_cond
(paren
(paren
id|FPU_st0_ptr-&gt;exp
op_eq
id|EXP_BIAS
)paren
op_logical_and
(paren
id|FPU_st0_ptr-&gt;sigh
op_eq
l_int|0x80000000
)paren
op_logical_and
(paren
id|FPU_st0_ptr-&gt;sigl
op_eq
l_int|0
)paren
)paren
(brace
id|pop
c_func
(paren
)paren
suffix:semicolon
id|FPU_st0_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pop
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pop
c_func
(paren
)paren
suffix:semicolon
id|FPU_st0_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_xor_assign
id|SIGN_NEG
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* st(0) must be zero or negative */
id|pop
c_func
(paren
)paren
suffix:semicolon
id|FPU_st0_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
DECL|function|fpatan
r_static
r_void
id|fpatan
c_func
(paren
r_void
)paren
(brace
id|FPU_REG
op_star
id|st1_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_char
id|st1_tag
op_assign
id|st1_ptr-&gt;tag
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|FPU_st0_tag
op_xor
id|TW_Valid
)paren
op_or
(paren
id|st1_tag
op_xor
id|TW_Valid
)paren
)paren
)paren
(brace
id|FPU_REG
id|sum
suffix:semicolon
r_int
id|quadrant
op_assign
id|st1_ptr-&gt;sign
op_or
(paren
(paren
id|FPU_st0_ptr-&gt;sign
)paren
op_lshift
l_int|1
)paren
suffix:semicolon
id|st1_ptr-&gt;sign
op_assign
id|FPU_st0_ptr-&gt;sign
op_assign
id|SIGN_POS
suffix:semicolon
r_if
c_cond
(paren
id|compare
c_func
(paren
id|st1_ptr
)paren
op_eq
id|COMP_A_LT_B
)paren
(brace
id|quadrant
op_or_assign
l_int|4
suffix:semicolon
id|reg_div
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
op_amp
id|sum
)paren
suffix:semicolon
)brace
r_else
id|reg_div
c_func
(paren
id|st1_ptr
comma
id|FPU_st0_ptr
comma
op_amp
id|sum
)paren
suffix:semicolon
id|poly_atan
c_func
(paren
op_amp
id|sum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|quadrant
op_amp
l_int|4
)paren
(brace
id|reg_sub
c_func
(paren
op_amp
id|CONST_PI2
comma
op_amp
id|sum
comma
op_amp
id|sum
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|quadrant
op_amp
l_int|2
)paren
(brace
id|reg_sub
c_func
(paren
op_amp
id|CONST_PI
comma
op_amp
id|sum
comma
op_amp
id|sum
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|quadrant
op_amp
l_int|1
)paren
id|sum.sign
op_xor_assign
id|SIGN_POS
op_xor
id|SIGN_NEG
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|sum
comma
id|st1_ptr
)paren
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
id|FPU_st0_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;exp
op_le
id|EXP_UNDER
)paren
(brace
id|arith_underflow
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_Empty
)paren
)paren
(brace
id|stack_underflow
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_NaN
)paren
)paren
(brace
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|st1_ptr
)paren
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
)paren
(brace
r_char
id|sign
op_assign
id|st1_ptr-&gt;sign
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_POS
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_PI4
comma
id|st1_ptr
)paren
suffix:semicolon
)brace
r_else
id|reg_add
c_func
(paren
op_amp
id|CONST_PI4
comma
op_amp
id|CONST_PI2
comma
id|st1_ptr
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_POS
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|st1_ptr
)paren
suffix:semicolon
)brace
r_else
id|reg_move
c_func
(paren
op_amp
id|CONST_PI
comma
id|st1_ptr
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_PI2
comma
id|st1_ptr
)paren
suffix:semicolon
)brace
id|st1_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Zero
)paren
(brace
r_char
id|sign
op_assign
id|st1_ptr-&gt;sign
suffix:semicolon
multiline_comment|/* st(0) must be valid or zero */
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_POS
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|st1_ptr
)paren
suffix:semicolon
)brace
r_else
id|reg_move
c_func
(paren
op_amp
id|CONST_PI
comma
id|st1_ptr
)paren
suffix:semicolon
id|st1_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
(brace
r_char
id|sign
op_assign
id|st1_ptr-&gt;sign
suffix:semicolon
multiline_comment|/* st(1) must be TW_Valid here */
id|reg_move
c_func
(paren
op_amp
id|CONST_PI2
comma
id|st1_ptr
)paren
suffix:semicolon
id|st1_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
r_else
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x220
)paren
suffix:semicolon
macro_line|#endif PARANOID
)brace
DECL|function|fprem
r_static
r_void
id|fprem
c_func
(paren
r_void
)paren
(brace
id|fprem_kernel
c_func
(paren
id|RC_CHOP
)paren
suffix:semicolon
)brace
DECL|function|fprem1
r_static
r_void
id|fprem1
c_func
(paren
r_void
)paren
(brace
id|fprem_kernel
c_func
(paren
id|RC_RND
)paren
suffix:semicolon
)brace
DECL|function|fyl2xp1
r_static
r_void
id|fyl2xp1
c_func
(paren
r_void
)paren
(brace
id|FPU_REG
op_star
id|st1_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_char
id|st1_tag
op_assign
id|st1_ptr-&gt;tag
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|FPU_st0_tag
op_xor
id|TW_Valid
)paren
op_or
(paren
id|st1_tag
op_xor
id|TW_Valid
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|poly_l2p1
c_func
(paren
id|FPU_st0_ptr
comma
id|FPU_st0_ptr
)paren
)paren
(brace
id|arith_invalid
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|reg_mul
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|st1_ptr
)paren
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
op_or
(paren
id|st1_tag
op_eq
id|TW_Empty
)paren
)paren
(brace
id|stack_underflow
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_le
id|TW_Zero
)paren
(brace
id|st1_ptr-&gt;sign
op_xor_assign
id|FPU_st0_ptr-&gt;sign
suffix:semicolon
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
(brace
id|arith_invalid
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_NaN
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|st1_ptr-&gt;sigh
op_amp
l_int|0x40000000
)paren
)paren
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
multiline_comment|/* signaling NaN */
id|st1_ptr-&gt;sigh
op_or_assign
l_int|0x40000000
suffix:semicolon
multiline_comment|/* QNaN */
r_return
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
r_else
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x116
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif PARANOID
id|pop
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
(brace
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|st1_ptr
)paren
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_NaN
)paren
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|st1_ptr
)paren
suffix:semicolon
r_else
id|arith_invalid
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
id|pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
r_else
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x117
)paren
suffix:semicolon
macro_line|#endif PARANOID
)brace
DECL|function|fscale
r_static
r_void
id|fscale
c_func
(paren
r_void
)paren
(brace
id|FPU_REG
op_star
id|st1_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_char
id|st1_tag
op_assign
id|st1_ptr-&gt;tag
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|FPU_st0_tag
op_xor
id|TW_Valid
)paren
op_or
(paren
id|st1_tag
op_xor
id|TW_Valid
)paren
)paren
)paren
(brace
r_int
id|scale
suffix:semicolon
id|FPU_REG
id|tmp
suffix:semicolon
multiline_comment|/* 2^31 is far too large, 2^-31 is far too small */
r_if
c_cond
(paren
id|st1_ptr-&gt;exp
OG
id|EXP_BIAS
op_plus
l_int|30
)paren
(brace
r_char
id|sign
suffix:semicolon
id|EXCEPTION
c_func
(paren
id|EX_Overflow
)paren
suffix:semicolon
id|sign
op_assign
id|FPU_st0_ptr-&gt;sign
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_INF
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_ptr-&gt;exp
OL
id|EXP_BIAS
op_minus
l_int|30
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Underflow
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|reg_move
c_func
(paren
id|st1_ptr
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|round_to_int
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* This can never overflow here */
id|scale
op_assign
id|st1_ptr-&gt;sign
ques
c_cond
op_minus
id|tmp.sigl
suffix:colon
id|tmp.sigl
suffix:semicolon
id|scale
op_add_assign
id|FPU_st0_ptr-&gt;exp
suffix:semicolon
id|FPU_st0_ptr-&gt;exp
op_assign
id|scale
suffix:semicolon
r_if
c_cond
(paren
id|scale
op_le
id|EXP_UNDER
)paren
(brace
id|arith_underflow
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scale
op_ge
id|EXP_OVER
)paren
(brace
id|arith_overflow
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Valid
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Zero
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
(brace
r_char
id|sign
op_assign
id|st1_ptr-&gt;sign
suffix:semicolon
r_if
c_cond
(paren
id|sign
op_eq
id|SIGN_POS
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_INF
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
)brace
r_else
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
id|FPU_st0_ptr-&gt;sign
op_assign
id|sign
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_NaN
)paren
(brace
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_le
id|TW_Zero
)paren
(brace
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|st1_ptr-&gt;sign
op_eq
id|SIGN_NEG
)paren
r_return
suffix:semicolon
r_else
(brace
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_NaN
)paren
(brace
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
op_logical_and
(paren
id|st1_ptr-&gt;sign
op_eq
id|SIGN_POS
)paren
)paren
op_logical_or
(paren
id|st1_tag
op_le
id|TW_Zero
)paren
)paren
r_return
suffix:semicolon
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
(brace
id|arith_invalid
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_NaN
)paren
(brace
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_ne
id|TW_Empty
)paren
(brace
id|real_2op_NaN
c_func
(paren
id|FPU_st0_ptr
comma
id|st1_ptr
comma
id|FPU_st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#ifdef PARANOID
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_Empty
)paren
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x115
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* At least one of st(0), st(1) must be empty */
id|stack_underflow
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*---------------------------------------------------------------------------*/
DECL|variable|trig_table_a
r_static
id|FUNC
id|trig_table_a
(braket
)braket
op_assign
(brace
id|f2xm1
comma
id|fyl2x
comma
id|fptan
comma
id|fpatan
comma
id|fxtract
comma
id|fprem1
comma
id|fdecstp
comma
id|fincstp
)brace
suffix:semicolon
DECL|function|trig_a
r_void
id|trig_a
c_func
(paren
r_void
)paren
(brace
(paren
id|trig_table_a
(braket
id|FPU_rm
)braket
)paren
(paren
)paren
suffix:semicolon
)brace
DECL|variable|trig_table_b
r_static
id|FUNC
id|trig_table_b
(braket
)braket
op_assign
(brace
id|fprem
comma
id|fyl2xp1
comma
id|fsqrt_
comma
id|fsincos
comma
id|frndint_
comma
id|fscale
comma
id|fsin
comma
id|fcos
)brace
suffix:semicolon
DECL|function|trig_b
r_void
id|trig_b
c_func
(paren
r_void
)paren
(brace
(paren
id|trig_table_b
(braket
id|FPU_rm
)braket
)paren
(paren
)paren
suffix:semicolon
)brace
eof
