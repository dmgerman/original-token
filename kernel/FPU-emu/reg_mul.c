multiline_comment|/*---------------------------------------------------------------------------+&n; |  reg_mul.c                                                                |&n; |                                                                           |&n; | Multiply one FPU_REG by another, put the result in a destination FPU_REG. |&n; |                                                                           |&n; | Copyright (C) 1992,1993                                                   |&n; |                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,      |&n; |                       Australia.  E-mail apm233m@vaxc.cc.monash.edu.au    |&n; |                                                                           |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
multiline_comment|/*---------------------------------------------------------------------------+&n; | The destination may be any FPU_REG, including one of the source FPU_REGs. |&n; +---------------------------------------------------------------------------*/
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;reg_constant.h&quot;
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &quot;fpu_system.h&quot;
multiline_comment|/* This routine must be called with non-empty source registers */
DECL|function|reg_mul
r_void
id|reg_mul
c_func
(paren
id|FPU_REG
op_star
id|a
comma
id|FPU_REG
op_star
id|b
comma
id|FPU_REG
op_star
id|dest
comma
r_int
r_int
id|control_w
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|a-&gt;tag
op_or
id|b-&gt;tag
)paren
)paren
(brace
multiline_comment|/* This should be the most common case */
id|dest-&gt;sign
op_assign
(paren
id|a-&gt;sign
op_xor
id|b-&gt;sign
)paren
suffix:semicolon
id|reg_u_mul
c_func
(paren
id|a
comma
id|b
comma
id|dest
comma
id|control_w
)paren
suffix:semicolon
id|dest-&gt;exp
op_add_assign
op_minus
id|EXP_BIAS
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*      dest-&gt;tag = TW_Valid; ****** */
r_if
c_cond
(paren
id|dest-&gt;exp
op_le
id|EXP_UNDER
)paren
(brace
id|arith_underflow
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dest-&gt;exp
op_ge
id|EXP_OVER
)paren
(brace
id|arith_overflow
c_func
(paren
id|FPU_st0_ptr
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|a-&gt;tag
op_le
id|TW_Zero
)paren
op_logical_and
(paren
id|b-&gt;tag
op_le
id|TW_Zero
)paren
)paren
(brace
multiline_comment|/* Must have either both arguments == zero, or&n;&t; one valid and the other zero.&n;&t; The result is therefore zero. */
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|dest
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|a-&gt;tag
op_le
id|TW_Denormal
)paren
op_logical_and
(paren
id|b-&gt;tag
op_le
id|TW_Denormal
)paren
)paren
(brace
multiline_comment|/* One or both arguments are de-normalized */
multiline_comment|/* Internal de-normalized numbers are not supported yet */
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x105
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|dest
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Must have infinities, NaNs, etc */
r_if
c_cond
(paren
(paren
id|a-&gt;tag
op_eq
id|TW_NaN
)paren
op_logical_or
(paren
id|b-&gt;tag
op_eq
id|TW_NaN
)paren
)paren
(brace
id|real_2op_NaN
c_func
(paren
id|a
comma
id|b
comma
id|dest
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|a-&gt;tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|b-&gt;tag
op_eq
id|TW_Zero
)paren
(brace
id|arith_invalid
c_func
(paren
id|dest
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|reg_move
c_func
(paren
id|a
comma
id|dest
)paren
suffix:semicolon
id|dest-&gt;sign
op_assign
id|a-&gt;sign
op_eq
id|b-&gt;sign
ques
c_cond
id|SIGN_POS
suffix:colon
id|SIGN_NEG
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|b-&gt;tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|a-&gt;tag
op_eq
id|TW_Zero
)paren
(brace
id|arith_invalid
c_func
(paren
id|dest
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|reg_move
c_func
(paren
id|b
comma
id|dest
)paren
suffix:semicolon
id|dest-&gt;sign
op_assign
id|a-&gt;sign
op_eq
id|b-&gt;sign
ques
c_cond
id|SIGN_POS
suffix:colon
id|SIGN_NEG
suffix:semicolon
)brace
)brace
macro_line|#ifdef PARANOID
r_else
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x102
)paren
suffix:semicolon
)brace
macro_line|#endif PARANOID
id|dest-&gt;sign
op_assign
(paren
id|a-&gt;sign
op_xor
id|b-&gt;sign
)paren
suffix:semicolon
)brace
)brace
eof
