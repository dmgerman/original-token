multiline_comment|/*---------------------------------------------------------------------------+&n; |  reg_mul.c                                                                |&n; |                                                                           |&n; | Multiply one FPU_REG by another, put the result in a destination FPU_REG. |&n; |                                                                           |&n; | Copyright (C) 1992,1993                                                   |&n; |                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,      |&n; |                       Australia.  E-mail apm233m@vaxc.cc.monash.edu.au    |&n; |                                                                           |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
multiline_comment|/*---------------------------------------------------------------------------+&n; | The destination may be any FPU_REG, including one of the source FPU_REGs. |&n; +---------------------------------------------------------------------------*/
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;reg_constant.h&quot;
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &quot;fpu_system.h&quot;
multiline_comment|/* This routine must be called with non-empty source registers */
DECL|function|reg_mul
r_int
id|reg_mul
c_func
(paren
id|FPU_REG
op_star
id|a
comma
id|FPU_REG
op_star
id|b
comma
id|FPU_REG
op_star
id|dest
comma
r_int
r_int
id|control_w
)paren
(brace
r_char
id|saved_sign
op_assign
id|dest-&gt;sign
suffix:semicolon
r_char
id|sign
op_assign
(paren
id|a-&gt;sign
op_xor
id|b-&gt;sign
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|a-&gt;tag
op_or
id|b-&gt;tag
)paren
)paren
(brace
multiline_comment|/* Both regs Valid, this should be the most common case. */
id|dest-&gt;sign
op_assign
id|sign
suffix:semicolon
r_if
c_cond
(paren
id|reg_u_mul
c_func
(paren
id|a
comma
id|b
comma
id|dest
comma
id|control_w
)paren
)paren
(brace
id|dest-&gt;sign
op_assign
id|saved_sign
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|a-&gt;tag
op_le
id|TW_Zero
)paren
op_logical_and
(paren
id|b-&gt;tag
op_le
id|TW_Zero
)paren
)paren
(brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
(paren
id|b-&gt;tag
op_eq
id|TW_Valid
)paren
op_logical_and
(paren
id|b-&gt;exp
op_le
id|EXP_UNDER
)paren
)paren
op_logical_or
(paren
(paren
id|a-&gt;tag
op_eq
id|TW_Valid
)paren
op_logical_and
(paren
id|a-&gt;exp
op_le
id|EXP_UNDER
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|denormal_operand
c_func
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif DENORM_OPERAND
multiline_comment|/* Must have either both arguments == zero, or&n;&t; one valid and the other zero.&n;&t; The result is therefore zero. */
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|dest
)paren
suffix:semicolon
macro_line|#ifdef PECULIAR_486
multiline_comment|/* The 80486 book says that the answer is +0, but a real&n;&t; 80486 appears to behave this way... */
id|dest-&gt;sign
op_assign
id|sign
suffix:semicolon
macro_line|#endif PECULIAR_486
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Must have infinities, NaNs, etc */
r_if
c_cond
(paren
(paren
id|a-&gt;tag
op_eq
id|TW_NaN
)paren
op_logical_or
(paren
id|b-&gt;tag
op_eq
id|TW_NaN
)paren
)paren
(brace
r_return
id|real_2op_NaN
c_func
(paren
id|a
comma
id|b
comma
id|dest
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|a-&gt;tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|b-&gt;tag
op_eq
id|TW_Zero
)paren
(brace
r_return
id|arith_invalid
c_func
(paren
id|dest
)paren
suffix:semicolon
)brace
multiline_comment|/* Zero*Infinity is invalid */
r_else
(brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|b-&gt;tag
op_eq
id|TW_Valid
)paren
op_logical_and
(paren
id|b-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
id|denormal_operand
c_func
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
macro_line|#endif DENORM_OPERAND
id|reg_move
c_func
(paren
id|a
comma
id|dest
)paren
suffix:semicolon
id|dest-&gt;sign
op_assign
id|sign
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|b-&gt;tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|a-&gt;tag
op_eq
id|TW_Zero
)paren
(brace
r_return
id|arith_invalid
c_func
(paren
id|dest
)paren
suffix:semicolon
)brace
multiline_comment|/* Zero*Infinity is invalid */
r_else
(brace
macro_line|#ifdef DENORM_OPERAND
r_if
c_cond
(paren
(paren
id|a-&gt;tag
op_eq
id|TW_Valid
)paren
op_logical_and
(paren
id|a-&gt;exp
op_le
id|EXP_UNDER
)paren
op_logical_and
id|denormal_operand
c_func
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
macro_line|#endif DENORM_OPERAND
id|reg_move
c_func
(paren
id|b
comma
id|dest
)paren
suffix:semicolon
id|dest-&gt;sign
op_assign
id|sign
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
r_else
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x102
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif PARANOID
)brace
)brace
eof
