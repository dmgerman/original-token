multiline_comment|/*---------------------------------------------------------------------------+&n; |  p_atan.c                                                                 |&n; |                                                                           |&n; | Compute the tan of a FPU_REG, using a polynomial approximation.           |&n; |                                                                           |&n; | Copyright (C) 1992,1993                                                   |&n; |                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,      |&n; |                       Australia.  E-mail apm233m@vaxc.cc.monash.edu.au    |&n; |                                                                           |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;reg_constant.h&quot;
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &quot;control_w.h&quot;
DECL|macro|HIPOWERon
mdefine_line|#define&t;HIPOWERon&t;6&t;/* odd poly, negative terms */
DECL|variable|oddnegterms
r_static
r_int
id|oddnegterms
(braket
id|HIPOWERon
)braket
(braket
l_int|2
)braket
op_assign
(brace
(brace
l_int|0x00000000
comma
l_int|0x00000000
)brace
comma
multiline_comment|/* for + 1.0 */
(brace
l_int|0x763b6f3d
comma
l_int|0x1adc4428
)brace
comma
(brace
l_int|0x20f0630b
comma
l_int|0x0502909d
)brace
comma
(brace
l_int|0x4e825578
comma
l_int|0x0198ce38
)brace
comma
(brace
l_int|0x22b7cb87
comma
l_int|0x008da6e3
)brace
comma
(brace
l_int|0x9b30ca03
comma
l_int|0x00239c79
)brace
)brace
suffix:semicolon
DECL|macro|HIPOWERop
mdefine_line|#define&t;HIPOWERop&t;6&t;/* odd poly, positive terms */
DECL|variable|oddplterms
r_static
r_int
id|oddplterms
(braket
id|HIPOWERop
)braket
(braket
l_int|2
)braket
op_assign
(brace
(brace
l_int|0xa6f67cb8
comma
l_int|0x94d910bd
)brace
comma
(brace
l_int|0xa02ffab4
comma
l_int|0x0a43cb45
)brace
comma
(brace
l_int|0x04265e6b
comma
l_int|0x02bf5655
)brace
comma
(brace
l_int|0x0a728914
comma
l_int|0x00f280f7
)brace
comma
(brace
l_int|0x6d640e01
comma
l_int|0x004d6556
)brace
comma
(brace
l_int|0xf1dd2dbf
comma
l_int|0x000a530a
)brace
)brace
suffix:semicolon
DECL|variable|denomterm
r_static
r_int
id|denomterm
(braket
l_int|2
)braket
op_assign
(brace
l_int|0xfc4bd208
comma
l_int|0xea2e6612
)brace
suffix:semicolon
multiline_comment|/*--- poly_atan() -----------------------------------------------------------+&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
DECL|function|poly_atan
r_void
id|poly_atan
c_func
(paren
id|FPU_REG
op_star
id|arg
)paren
(brace
r_char
id|recursions
op_assign
l_int|0
suffix:semicolon
r_int
id|exponent
suffix:semicolon
id|FPU_REG
id|odd_poly
comma
id|even_poly
comma
id|pos_poly
comma
id|neg_poly
suffix:semicolon
id|FPU_REG
id|argSq
suffix:semicolon
r_int
r_int
id|arg_signif
comma
id|argSqSq
suffix:semicolon
macro_line|#ifdef PARANOID
r_if
c_cond
(paren
id|arg-&gt;sign
op_ne
l_int|0
)paren
multiline_comment|/* Can&squot;t hack a number &lt; 0.0 */
(brace
id|arith_invalid
c_func
(paren
id|arg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif PARANOID
id|exponent
op_assign
id|arg-&gt;exp
op_minus
id|EXP_BIAS
suffix:semicolon
r_if
c_cond
(paren
id|arg-&gt;tag
op_eq
id|TW_Zero
)paren
(brace
multiline_comment|/* Return 0.0 */
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|arg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|exponent
op_ge
op_minus
l_int|2
)paren
(brace
multiline_comment|/* argument is in the range  [0.25 .. 1.0] */
r_if
c_cond
(paren
id|exponent
op_ge
l_int|0
)paren
(brace
macro_line|#ifdef PARANOID
r_if
c_cond
(paren
(paren
id|exponent
op_eq
l_int|0
)paren
op_logical_and
(paren
id|arg-&gt;sigl
op_eq
l_int|0
)paren
op_logical_and
(paren
id|arg-&gt;sigh
op_eq
l_int|0x80000000
)paren
)paren
macro_line|#endif PARANOID
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_PI4
comma
id|arg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x104
)paren
suffix:semicolon
multiline_comment|/* There must be a logic error */
macro_line|#endif PARANOID
)brace
multiline_comment|/* If the argument is greater than sqrt(2)-1 (=0.414213562...) */
multiline_comment|/* convert the argument by an identity for atan */
r_if
c_cond
(paren
(paren
id|exponent
op_ge
op_minus
l_int|1
)paren
op_logical_or
(paren
id|arg-&gt;sigh
OG
l_int|0xd413ccd0
)paren
)paren
(brace
id|FPU_REG
id|numerator
comma
id|denom
suffix:semicolon
id|recursions
op_increment
suffix:semicolon
id|arg_signif
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
(paren
id|arg-&gt;sigl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exponent
OL
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|shrx
c_func
(paren
op_amp
id|arg_signif
comma
op_minus
l_int|1
op_minus
id|exponent
)paren
op_ge
l_int|0x80000000U
)paren
id|arg_signif
op_increment
suffix:semicolon
multiline_comment|/* round up */
)brace
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
(paren
id|numerator.sigl
)paren
op_assign
op_minus
id|arg_signif
suffix:semicolon
id|numerator.exp
op_assign
id|EXP_BIAS
op_minus
l_int|1
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|numerator
)paren
suffix:semicolon
multiline_comment|/* 1 - arg */
id|arg_signif
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
(paren
id|arg-&gt;sigl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|shrx
c_func
(paren
op_amp
id|arg_signif
comma
op_minus
id|exponent
)paren
op_ge
l_int|0x80000000U
)paren
id|arg_signif
op_increment
suffix:semicolon
multiline_comment|/* round up */
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
(paren
id|denom.sigl
)paren
op_assign
id|arg_signif
suffix:semicolon
id|denom.sigh
op_or_assign
l_int|0x80000000
suffix:semicolon
multiline_comment|/* 1 + arg */
id|arg-&gt;exp
op_assign
id|numerator.exp
suffix:semicolon
id|reg_u_div
c_func
(paren
op_amp
id|numerator
comma
op_amp
id|denom
comma
id|arg
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|exponent
op_assign
id|arg-&gt;exp
op_minus
id|EXP_BIAS
suffix:semicolon
)brace
)brace
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|arg_signif
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
(paren
id|arg-&gt;sigl
)paren
suffix:semicolon
macro_line|#ifdef PARANOID
multiline_comment|/* This must always be true */
r_if
c_cond
(paren
id|exponent
op_ge
op_minus
l_int|1
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x120
)paren
suffix:semicolon
multiline_comment|/* There must be a logic error */
)brace
macro_line|#endif PARANOID
multiline_comment|/* shift the argument right by the required places */
r_if
c_cond
(paren
id|shrx
c_func
(paren
op_amp
id|arg_signif
comma
op_minus
l_int|1
op_minus
id|exponent
)paren
op_ge
l_int|0x80000000U
)paren
id|arg_signif
op_increment
suffix:semicolon
multiline_comment|/* round up */
multiline_comment|/* Now have arg_signif with binary point at the left&n;     .1xxxxxxxx */
id|mul64
c_func
(paren
op_amp
id|arg_signif
comma
op_amp
id|arg_signif
comma
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|argSq.sigl
)paren
)paren
suffix:semicolon
id|mul64
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|argSq.sigl
)paren
comma
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|argSq.sigl
)paren
comma
op_amp
id|argSqSq
)paren
suffix:semicolon
multiline_comment|/* will be a valid positive nr with expon = 0 */
op_star
(paren
r_int
op_star
)paren
op_amp
(paren
id|pos_poly.sign
)paren
op_assign
l_int|0
suffix:semicolon
id|pos_poly.exp
op_assign
id|EXP_BIAS
suffix:semicolon
multiline_comment|/* Do the basic fixed point polynomial evaluation */
id|polynomial
c_func
(paren
op_amp
id|pos_poly.sigl
comma
(paren
r_int
op_star
)paren
op_amp
id|argSqSq
comma
(paren
r_int
r_int
(paren
op_star
)paren
(braket
l_int|4
)braket
)paren
id|oddplterms
comma
id|HIPOWERop
op_minus
l_int|1
)paren
suffix:semicolon
id|mul64
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|argSq.sigl
)paren
comma
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|pos_poly.sigl
)paren
comma
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|pos_poly.sigl
)paren
)paren
suffix:semicolon
multiline_comment|/* will be a valid positive nr with expon = 0 */
op_star
(paren
r_int
op_star
)paren
op_amp
(paren
id|neg_poly.sign
)paren
op_assign
l_int|0
suffix:semicolon
id|neg_poly.exp
op_assign
id|EXP_BIAS
suffix:semicolon
multiline_comment|/* Do the basic fixed point polynomial evaluation */
id|polynomial
c_func
(paren
op_amp
id|neg_poly.sigl
comma
(paren
r_int
op_star
)paren
op_amp
id|argSqSq
comma
(paren
r_int
r_int
(paren
op_star
)paren
(braket
l_int|4
)braket
)paren
id|oddnegterms
comma
id|HIPOWERon
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Subtract the mantissas */
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|pos_poly.sigl
)paren
)paren
op_sub_assign
op_star
(paren
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|neg_poly.sigl
)paren
)paren
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|pos_poly
comma
op_amp
id|odd_poly
)paren
suffix:semicolon
id|poly_add_1
c_func
(paren
op_amp
id|odd_poly
)paren
suffix:semicolon
multiline_comment|/* The complete odd polynomial */
id|reg_u_mul
c_func
(paren
op_amp
id|odd_poly
comma
id|arg
comma
op_amp
id|odd_poly
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|odd_poly.exp
op_sub_assign
id|EXP_BIAS
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* will be a valid positive nr with expon = 0 */
op_star
(paren
r_int
op_star
)paren
op_amp
(paren
id|even_poly.sign
)paren
op_assign
l_int|0
suffix:semicolon
id|mul64
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|argSq.sigl
)paren
comma
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|denomterm
)paren
comma
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|even_poly.sigl
)paren
)paren
suffix:semicolon
id|poly_add_1
c_func
(paren
op_amp
id|even_poly
)paren
suffix:semicolon
id|reg_div
c_func
(paren
op_amp
id|odd_poly
comma
op_amp
id|even_poly
comma
id|arg
comma
id|FULL_PRECISION
)paren
suffix:semicolon
r_if
c_cond
(paren
id|recursions
)paren
id|reg_sub
c_func
(paren
op_amp
id|CONST_PI4
comma
id|arg
comma
id|arg
comma
id|FULL_PRECISION
)paren
suffix:semicolon
)brace
multiline_comment|/* The argument to this function must be polynomial() compatible,&n;   i.e. have an exponent (not checked) of EXP_BIAS-1 but need not&n;   be normalized.&n;   This function adds 1.0 to the (assumed positive) argument. */
DECL|function|poly_add_1
r_void
id|poly_add_1
c_func
(paren
id|FPU_REG
op_star
id|src
)paren
(brace
multiline_comment|/* Rounding in a consistent direction produces better results&n;   for the use of this function in poly_atan. Simple truncation&n;   is used here instead of round-to-nearest. */
macro_line|#ifdef OBSOLETE
r_char
id|round
op_assign
(paren
id|src-&gt;sigl
op_amp
l_int|3
)paren
op_eq
l_int|3
suffix:semicolon
macro_line|#endif OBSOLETE
id|shrx
c_func
(paren
op_amp
id|src-&gt;sigl
comma
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef OBSOLETE
r_if
c_cond
(paren
id|round
)paren
(paren
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|src-&gt;sigl
)paren
op_increment
suffix:semicolon
multiline_comment|/* Round to even */
macro_line|#endif OBSOLETE
id|src-&gt;sigh
op_or_assign
l_int|0x80000000
suffix:semicolon
id|src-&gt;exp
op_assign
id|EXP_BIAS
suffix:semicolon
)brace
eof
