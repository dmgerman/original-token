multiline_comment|/*---------------------------------------------------------------------------+&n; |  reg_ld_str.c                                                             |&n; |                                                                           |&n; | All of the functions which transfer data between user memory and FPU_REGs.|&n; |                                                                           |&n; | Copyright (C) 1992,1993                                                   |&n; |                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,      |&n; |                       Australia.  E-mail apm233m@vaxc.cc.monash.edu.au    |&n; |                                                                           |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
multiline_comment|/*---------------------------------------------------------------------------+&n; | Note:                                                                     |&n; |    The file contains code which accesses user memory.                     |&n; |    Emulator static data may change when user memory is accessed, due to   |&n; |    other processes using the emulator while swapping is in progress.      |&n; +---------------------------------------------------------------------------*/
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &quot;fpu_system.h&quot;
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;reg_constant.h&quot;
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &quot;control_w.h&quot;
DECL|macro|EXTENDED_Emax
mdefine_line|#define EXTENDED_Emax 0x3fff     /* largest valid exponent */
DECL|macro|EXTENDED_Ebias
mdefine_line|#define EXTENDED_Ebias 0x3fff
DECL|macro|EXTENDED_Emin
mdefine_line|#define EXTENDED_Emin (-0x3ffe)  /* smallest valid exponent */
DECL|macro|DOUBLE_Emax
mdefine_line|#define DOUBLE_Emax 1023         /* largest valid exponent */
DECL|macro|DOUBLE_Ebias
mdefine_line|#define DOUBLE_Ebias 1023
DECL|macro|DOUBLE_Emin
mdefine_line|#define DOUBLE_Emin (-1022)      /* smallest valid exponent */
DECL|macro|SINGLE_Emax
mdefine_line|#define SINGLE_Emax 127          /* largest valid exponent */
DECL|macro|SINGLE_Ebias
mdefine_line|#define SINGLE_Ebias 127
DECL|macro|SINGLE_Emin
mdefine_line|#define SINGLE_Emin (-126)       /* smallest valid exponent */
DECL|variable|FPU_loaded_data
id|FPU_REG
id|FPU_loaded_data
suffix:semicolon
multiline_comment|/* Get a long double from user memory */
DECL|function|reg_load_extended
r_void
id|reg_load_extended
c_func
(paren
r_void
)paren
(brace
r_int
r_float
op_star
id|s
op_assign
(paren
r_int
r_float
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
r_int
id|sigl
comma
id|sigh
comma
id|exp
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
multiline_comment|/* Use temporary variables here because FPU_loaded data is&n;     static and hence re-entrancy problems can arise */
id|sigl
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|s
)paren
suffix:semicolon
id|sigh
op_assign
id|get_fs_long
c_func
(paren
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|s
)paren
suffix:semicolon
id|exp
op_assign
id|get_fs_word
c_func
(paren
l_int|4
op_plus
(paren
r_int
r_int
op_star
)paren
id|s
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
id|FPU_loaded_data.sigl
op_assign
id|sigl
suffix:semicolon
id|FPU_loaded_data.sigh
op_assign
id|sigh
suffix:semicolon
id|FPU_loaded_data.exp
op_assign
id|exp
suffix:semicolon
r_if
c_cond
(paren
id|FPU_loaded_data.exp
op_amp
l_int|0x8000
)paren
id|FPU_loaded_data.sign
op_assign
id|SIGN_NEG
suffix:semicolon
r_else
id|FPU_loaded_data.sign
op_assign
id|SIGN_POS
suffix:semicolon
r_if
c_cond
(paren
(paren
id|FPU_loaded_data.exp
op_and_assign
l_int|0x7fff
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|FPU_loaded_data.sigl
op_or
id|FPU_loaded_data.sigh
)paren
)paren
(brace
id|FPU_loaded_data.tag
op_assign
id|TW_Zero
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* The number is de-normal */
multiline_comment|/* The default behaviour will take care of this */
)brace
r_else
r_if
c_cond
(paren
id|FPU_loaded_data.exp
op_eq
l_int|0x7fff
)paren
(brace
id|FPU_loaded_data.exp
op_assign
id|EXTENDED_Emax
suffix:semicolon
r_if
c_cond
(paren
(paren
id|FPU_loaded_data.sigh
op_eq
l_int|0x80000000
)paren
op_logical_and
(paren
id|FPU_loaded_data.sigl
op_eq
l_int|0
)paren
)paren
(brace
id|FPU_loaded_data.tag
op_assign
id|TW_Infinity
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|FPU_loaded_data.sigh
op_amp
l_int|0x80000000
)paren
)paren
(brace
multiline_comment|/* Unsupported data type */
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_NaN
suffix:semicolon
r_return
suffix:semicolon
)brace
id|FPU_loaded_data.tag
op_assign
id|TW_NaN
suffix:semicolon
r_return
suffix:semicolon
)brace
id|FPU_loaded_data.exp
op_assign
(paren
id|FPU_loaded_data.exp
op_amp
l_int|0x7fff
)paren
op_minus
id|EXTENDED_Ebias
op_plus
id|EXP_BIAS
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Valid
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
)brace
multiline_comment|/* Get a double from user memory */
DECL|function|reg_load_double
r_void
id|reg_load_double
c_func
(paren
r_void
)paren
(brace
r_float
op_star
id|dfloat
op_assign
(paren
r_float
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
id|exp
suffix:semicolon
r_int
id|m64
comma
id|l64
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
id|m64
op_assign
id|get_fs_long
c_func
(paren
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|dfloat
)paren
suffix:semicolon
id|l64
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|dfloat
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_if
c_cond
(paren
id|m64
op_amp
l_int|0x80000000
)paren
id|FPU_loaded_data.sign
op_assign
id|SIGN_NEG
suffix:semicolon
r_else
id|FPU_loaded_data.sign
op_assign
id|SIGN_POS
suffix:semicolon
id|exp
op_assign
(paren
(paren
id|m64
op_amp
l_int|0x7ff00000
)paren
op_rshift
l_int|20
)paren
op_minus
id|DOUBLE_Ebias
suffix:semicolon
id|m64
op_and_assign
l_int|0xfffff
suffix:semicolon
r_if
c_cond
(paren
id|exp
OG
id|DOUBLE_Emax
)paren
(brace
multiline_comment|/* Infinity or NaN */
r_if
c_cond
(paren
(paren
id|m64
op_eq
l_int|0
)paren
op_logical_and
(paren
id|l64
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* +- infinity */
id|FPU_loaded_data.exp
op_assign
id|EXTENDED_Emax
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Infinity
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Must be a signaling or quiet NaN */
id|FPU_loaded_data.exp
op_assign
id|EXTENDED_Emax
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_NaN
suffix:semicolon
id|FPU_loaded_data.sigh
op_assign
(paren
id|m64
op_lshift
l_int|11
)paren
op_or
l_int|0x80000000
suffix:semicolon
id|FPU_loaded_data.sigh
op_or_assign
id|l64
op_rshift
l_int|21
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
id|l64
op_lshift
l_int|11
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|exp
OL
id|DOUBLE_Emin
)paren
(brace
multiline_comment|/* Zero or de-normal */
r_if
c_cond
(paren
(paren
id|m64
op_eq
l_int|0
)paren
op_logical_and
(paren
id|l64
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* Zero */
r_int
id|c
op_assign
id|FPU_loaded_data.sign
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
id|FPU_loaded_data.sign
op_assign
id|c
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* De-normal */
id|FPU_loaded_data.exp
op_assign
id|DOUBLE_Emin
op_plus
id|EXP_BIAS
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Valid
suffix:semicolon
id|FPU_loaded_data.sigh
op_assign
id|m64
op_lshift
l_int|11
suffix:semicolon
id|FPU_loaded_data.sigh
op_or_assign
id|l64
op_rshift
l_int|21
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
id|l64
op_lshift
l_int|11
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
id|FPU_loaded_data.exp
op_assign
id|exp
op_plus
id|EXP_BIAS
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Valid
suffix:semicolon
id|FPU_loaded_data.sigh
op_assign
(paren
id|m64
op_lshift
l_int|11
)paren
op_or
l_int|0x80000000
suffix:semicolon
id|FPU_loaded_data.sigh
op_or_assign
id|l64
op_rshift
l_int|21
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
id|l64
op_lshift
l_int|11
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* Get a float from user memory */
DECL|function|reg_load_single
r_void
id|reg_load_single
c_func
(paren
r_void
)paren
(brace
r_float
op_star
id|single
op_assign
(paren
r_float
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
id|m32
suffix:semicolon
r_int
id|exp
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
id|m32
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|single
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_if
c_cond
(paren
id|m32
op_amp
l_int|0x80000000
)paren
id|FPU_loaded_data.sign
op_assign
id|SIGN_NEG
suffix:semicolon
r_else
id|FPU_loaded_data.sign
op_assign
id|SIGN_POS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|m32
op_amp
l_int|0x7fffffff
)paren
)paren
(brace
multiline_comment|/* Zero */
r_int
id|c
op_assign
id|FPU_loaded_data.sign
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
id|FPU_loaded_data.sign
op_assign
id|c
suffix:semicolon
r_return
suffix:semicolon
)brace
id|exp
op_assign
(paren
(paren
id|m32
op_amp
l_int|0x7f800000
)paren
op_rshift
l_int|23
)paren
op_minus
id|SINGLE_Ebias
suffix:semicolon
id|m32
op_assign
(paren
id|m32
op_amp
l_int|0x7fffff
)paren
op_lshift
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|exp
OL
id|SINGLE_Emin
)paren
(brace
multiline_comment|/* De-normals */
id|FPU_loaded_data.exp
op_assign
id|SINGLE_Emin
op_plus
id|EXP_BIAS
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Valid
suffix:semicolon
id|FPU_loaded_data.sigh
op_assign
id|m32
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
l_int|0
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|exp
OG
id|SINGLE_Emax
)paren
(brace
multiline_comment|/* Infinity or NaN */
r_if
c_cond
(paren
id|m32
op_eq
l_int|0
)paren
(brace
multiline_comment|/* +- infinity */
id|FPU_loaded_data.exp
op_assign
id|EXTENDED_Emax
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Infinity
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Must be a signaling or quiet NaN */
id|FPU_loaded_data.exp
op_assign
id|EXTENDED_Emax
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_NaN
suffix:semicolon
id|FPU_loaded_data.sigh
op_assign
id|m32
op_or
l_int|0x80000000
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
id|FPU_loaded_data.exp
op_assign
id|exp
op_plus
id|EXP_BIAS
suffix:semicolon
id|FPU_loaded_data.sigh
op_assign
id|m32
op_or
l_int|0x80000000
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
l_int|0
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Valid
suffix:semicolon
)brace
)brace
multiline_comment|/* Get a long long from user memory */
DECL|function|reg_load_int64
r_void
id|reg_load_int64
c_func
(paren
r_void
)paren
(brace
r_int
r_int
op_star
id|_s
op_assign
(paren
r_int
r_int
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
id|e
suffix:semicolon
r_int
r_int
id|s
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|s
)paren
(braket
l_int|0
)braket
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|_s
)paren
suffix:semicolon
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|s
)paren
(braket
l_int|1
)braket
op_assign
id|get_fs_long
c_func
(paren
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|_s
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_if
c_cond
(paren
id|s
op_eq
l_int|0
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
OG
l_int|0
)paren
id|FPU_loaded_data.sign
op_assign
id|SIGN_POS
suffix:semicolon
r_else
(brace
id|s
op_assign
op_minus
id|s
suffix:semicolon
id|FPU_loaded_data.sign
op_assign
id|SIGN_NEG
suffix:semicolon
)brace
id|e
op_assign
id|EXP_BIAS
op_plus
l_int|63
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|FPU_loaded_data.sigl
)paren
op_assign
id|s
suffix:semicolon
id|FPU_loaded_data.exp
op_assign
id|e
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Valid
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
)brace
multiline_comment|/* Get a long from user memory */
DECL|function|reg_load_int32
r_void
id|reg_load_int32
c_func
(paren
r_void
)paren
(brace
r_int
op_star
id|_s
op_assign
(paren
r_int
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
id|s
suffix:semicolon
r_int
id|e
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
id|s
op_assign
(paren
r_int
)paren
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|_s
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_if
c_cond
(paren
id|s
op_eq
l_int|0
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
OG
l_int|0
)paren
id|FPU_loaded_data.sign
op_assign
id|SIGN_POS
suffix:semicolon
r_else
(brace
id|s
op_assign
op_minus
id|s
suffix:semicolon
id|FPU_loaded_data.sign
op_assign
id|SIGN_NEG
suffix:semicolon
)brace
id|e
op_assign
id|EXP_BIAS
op_plus
l_int|31
suffix:semicolon
id|FPU_loaded_data.sigh
op_assign
id|s
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
l_int|0
suffix:semicolon
id|FPU_loaded_data.exp
op_assign
id|e
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Valid
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
)brace
multiline_comment|/* Get a short from user memory */
DECL|function|reg_load_int16
r_void
id|reg_load_int16
c_func
(paren
r_void
)paren
(brace
r_int
op_star
id|_s
op_assign
(paren
r_int
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
id|s
comma
id|e
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
id|s
op_assign
(paren
r_int
)paren
id|get_fs_word
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|_s
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_if
c_cond
(paren
id|s
op_eq
l_int|0
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
OG
l_int|0
)paren
id|FPU_loaded_data.sign
op_assign
id|SIGN_POS
suffix:semicolon
r_else
(brace
id|s
op_assign
op_minus
id|s
suffix:semicolon
id|FPU_loaded_data.sign
op_assign
id|SIGN_NEG
suffix:semicolon
)brace
id|e
op_assign
id|EXP_BIAS
op_plus
l_int|15
suffix:semicolon
id|FPU_loaded_data.sigh
op_assign
id|s
op_lshift
l_int|16
suffix:semicolon
id|FPU_loaded_data.sigl
op_assign
l_int|0
suffix:semicolon
id|FPU_loaded_data.exp
op_assign
id|e
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Valid
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
)brace
multiline_comment|/* Get a packed bcd array from user memory */
DECL|function|reg_load_bcd
r_void
id|reg_load_bcd
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|s
op_assign
(paren
r_char
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
id|pos
suffix:semicolon
r_int
r_char
id|bcd
suffix:semicolon
r_int
r_int
id|l
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|pos
op_assign
l_int|8
suffix:semicolon
id|pos
op_ge
l_int|0
suffix:semicolon
id|pos
op_decrement
)paren
(brace
id|l
op_mul_assign
l_int|10
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
id|bcd
op_assign
(paren
r_int
r_char
)paren
id|get_fs_byte
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|s
op_plus
id|pos
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
id|l
op_add_assign
id|bcd
op_rshift
l_int|4
suffix:semicolon
id|l
op_mul_assign
l_int|10
suffix:semicolon
id|l
op_add_assign
id|bcd
op_amp
l_int|0x0f
suffix:semicolon
)brace
multiline_comment|/* Finish all access to user memory before putting stuff into&n;     the static FPU_loaded_data */
id|RE_ENTRANT_CHECK_OFF
id|FPU_loaded_data.sign
op_assign
(paren
(paren
r_int
r_char
)paren
id|get_fs_byte
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|s
op_plus
l_int|9
)paren
)paren
op_amp
l_int|0x80
ques
c_cond
id|SIGN_NEG
suffix:colon
id|SIGN_POS
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_if
c_cond
(paren
id|l
op_eq
l_int|0
)paren
(brace
r_char
id|sign
op_assign
id|FPU_loaded_data.sign
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
id|FPU_loaded_data.sign
op_assign
id|sign
suffix:semicolon
)brace
r_else
(brace
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|FPU_loaded_data.sigl
)paren
op_assign
id|l
suffix:semicolon
id|FPU_loaded_data.exp
op_assign
id|EXP_BIAS
op_plus
l_int|63
suffix:semicolon
id|FPU_loaded_data.tag
op_assign
id|TW_Valid
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|FPU_loaded_data
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*===========================================================================*/
multiline_comment|/* Put a long double into user memory */
DECL|function|reg_store_extended
r_int
id|reg_store_extended
c_func
(paren
r_void
)paren
(brace
r_int
r_float
op_star
id|d
op_assign
(paren
r_int
r_float
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
id|e
op_assign
id|FPU_st0_ptr-&gt;exp
op_minus
id|EXP_BIAS
op_plus
id|EXTENDED_Ebias
suffix:semicolon
r_int
r_int
id|sign
op_assign
id|FPU_st0_ptr-&gt;sign
op_star
l_int|0x8000
suffix:semicolon
r_int
r_int
id|ls
comma
id|ms
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Valid
)paren
(brace
r_if
c_cond
(paren
id|e
op_ge
l_int|0x7fff
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Overflow
)paren
suffix:semicolon
multiline_comment|/* Overflow */
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Overflow
)paren
(brace
multiline_comment|/* Overflow to infinity */
id|ls
op_assign
l_int|0
suffix:semicolon
id|ms
op_assign
l_int|0x80000000
suffix:semicolon
id|e
op_assign
l_int|0x7fff
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|e
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|e
op_eq
l_int|0
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Denormal
)paren
suffix:semicolon
multiline_comment|/* Pseudo de-normal */
id|ls
op_assign
id|FPU_st0_ptr-&gt;sigl
suffix:semicolon
id|ms
op_assign
id|FPU_st0_ptr-&gt;sigh
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|e
OG
op_minus
l_int|64
)paren
(brace
multiline_comment|/* Make a de-normal */
id|FPU_REG
id|tmp
suffix:semicolon
id|EXCEPTION
c_func
(paren
id|EX_Denormal
)paren
suffix:semicolon
multiline_comment|/* De-normal */
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|tmp.exp
op_add_assign
op_minus
id|EXTENDED_Emin
op_plus
l_int|64
suffix:semicolon
multiline_comment|/* largest exp to be 63 */
id|round_to_int
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|e
op_assign
l_int|0
suffix:semicolon
id|ls
op_assign
id|tmp.sigl
suffix:semicolon
id|ms
op_assign
id|tmp.sigh
suffix:semicolon
)brace
r_else
(brace
id|EXCEPTION
c_func
(paren
id|EX_Underflow
)paren
suffix:semicolon
multiline_comment|/* Underflow */
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Underflow
)paren
(brace
multiline_comment|/* Underflow to zero */
id|ls
op_assign
l_int|0
suffix:semicolon
id|ms
op_assign
l_int|0
suffix:semicolon
id|e
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|ls
op_assign
id|FPU_st0_ptr-&gt;sigl
suffix:semicolon
id|ms
op_assign
id|FPU_st0_ptr-&gt;sigh
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
(brace
id|ls
op_assign
id|ms
op_assign
l_int|0
suffix:semicolon
id|e
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
id|ls
op_assign
l_int|0
suffix:semicolon
id|ms
op_assign
l_int|0x80000000
suffix:semicolon
id|e
op_assign
l_int|0x7fff
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
(brace
id|ls
op_assign
id|FPU_st0_ptr-&gt;sigl
suffix:semicolon
id|ms
op_assign
id|FPU_st0_ptr-&gt;sigh
suffix:semicolon
id|e
op_assign
l_int|0x7fff
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
(brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
multiline_comment|/* The masked response */
multiline_comment|/* Put out the QNaN indefinite */
id|ls
op_assign
l_int|0
suffix:semicolon
id|ms
op_assign
l_int|0xc0000000
suffix:semicolon
id|e
op_assign
l_int|0xffff
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We don&squot;t use TW_Denormal yet ... perhaps never! */
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
multiline_comment|/* Store a NaN */
id|e
op_assign
l_int|0x7fff
suffix:semicolon
id|ls
op_assign
l_int|1
suffix:semicolon
id|ms
op_assign
l_int|0x80000000
suffix:semicolon
)brace
id|RE_ENTRANT_CHECK_OFF
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|10
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|ls
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|ms
comma
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
(paren
r_int
r_int
)paren
id|e
op_or
id|sign
comma
l_int|4
op_plus
(paren
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Put a double into user memory */
DECL|function|reg_store_double
r_int
id|reg_store_double
c_func
(paren
r_void
)paren
(brace
r_float
op_star
id|dfloat
op_assign
(paren
r_float
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
r_int
id|l
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Valid
)paren
(brace
r_int
id|exp
suffix:semicolon
id|FPU_REG
id|tmp
suffix:semicolon
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp.sigl
op_amp
l_int|0x000007ff
)paren
(brace
r_int
r_int
id|increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* avoid gcc warnings */
r_switch
c_cond
(paren
id|control_word
op_amp
id|CW_RC
)paren
(brace
r_case
id|RC_RND
suffix:colon
multiline_comment|/* Rounding can get a little messy.. */
id|increment
op_assign
(paren
(paren
id|tmp.sigl
op_amp
l_int|0x7ff
)paren
OG
l_int|0x400
)paren
op_or
multiline_comment|/* nearest */
(paren
(paren
id|tmp.sigl
op_amp
l_int|0xc00
)paren
op_eq
l_int|0xc00
)paren
suffix:semicolon
multiline_comment|/* odd -&gt; even */
r_break
suffix:semicolon
r_case
id|RC_DOWN
suffix:colon
multiline_comment|/* towards -infinity */
id|increment
op_assign
(paren
id|tmp.sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
l_int|0
suffix:colon
id|tmp.sigl
op_amp
l_int|0x7ff
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RC_UP
suffix:colon
multiline_comment|/* towards +infinity */
id|increment
op_assign
(paren
id|tmp.sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
id|tmp.sigl
op_amp
l_int|0x7ff
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RC_CHOP
suffix:colon
id|increment
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Truncate the mantissa */
id|tmp.sigl
op_and_assign
l_int|0xfffff800
suffix:semicolon
r_if
c_cond
(paren
id|increment
)paren
(brace
r_if
c_cond
(paren
id|tmp.sigl
op_ge
l_int|0xfffff800
)paren
(brace
multiline_comment|/* the sigl part overflows */
r_if
c_cond
(paren
id|tmp.sigh
op_eq
l_int|0xffffffff
)paren
(brace
multiline_comment|/* The sigh part overflows */
id|tmp.sigh
op_assign
l_int|0x80000000
suffix:semicolon
id|tmp.exp
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tmp.exp
op_ge
id|EXP_OVER
)paren
r_goto
id|overflow
suffix:semicolon
)brace
r_else
(brace
id|tmp.sigh
op_increment
suffix:semicolon
)brace
id|tmp.sigl
op_assign
l_int|0x00000000
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We only need to increment sigl */
id|tmp.sigl
op_add_assign
l_int|0x00000800
suffix:semicolon
)brace
)brace
)brace
id|l
(braket
l_int|0
)braket
op_assign
(paren
id|tmp.sigl
op_rshift
l_int|11
)paren
op_or
(paren
id|tmp.sigh
op_lshift
l_int|21
)paren
suffix:semicolon
id|l
(braket
l_int|1
)braket
op_assign
(paren
(paren
id|tmp.sigh
op_rshift
l_int|11
)paren
op_amp
l_int|0xfffff
)paren
suffix:semicolon
id|exp
op_assign
id|tmp.exp
op_minus
id|EXP_BIAS
suffix:semicolon
r_if
c_cond
(paren
id|exp
OG
id|DOUBLE_Emax
)paren
(brace
id|overflow
suffix:colon
id|EXCEPTION
c_func
(paren
id|EX_Overflow
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Overflow
)paren
(brace
multiline_comment|/* Overflow to infinity */
id|l
(braket
l_int|0
)braket
op_assign
l_int|0x00000000
suffix:semicolon
multiline_comment|/* Set to */
id|l
(braket
l_int|1
)braket
op_assign
l_int|0x7ff00000
suffix:semicolon
multiline_comment|/* + INF */
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|exp
OL
id|DOUBLE_Emin
)paren
(brace
r_if
c_cond
(paren
id|exp
OG
id|DOUBLE_Emin
op_minus
l_int|53
)paren
(brace
multiline_comment|/* Make a de-normal */
id|FPU_REG
id|tmp
suffix:semicolon
id|EXCEPTION
c_func
(paren
id|EX_Denormal
)paren
suffix:semicolon
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|tmp.exp
op_add_assign
op_minus
id|DOUBLE_Emin
op_plus
l_int|52
suffix:semicolon
multiline_comment|/* largest exp to be 51 */
id|round_to_int
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|l
(braket
l_int|0
)braket
op_assign
id|tmp.sigl
suffix:semicolon
id|l
(braket
l_int|1
)braket
op_assign
id|tmp.sigh
suffix:semicolon
)brace
r_else
(brace
id|EXCEPTION
c_func
(paren
id|EX_Underflow
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Underflow
)paren
(brace
multiline_comment|/* Underflow to zero */
id|l
(braket
l_int|0
)braket
op_assign
id|l
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Add the exponent */
id|l
(braket
l_int|1
)braket
op_or_assign
(paren
(paren
(paren
id|exp
op_plus
id|DOUBLE_Ebias
)paren
op_amp
l_int|0x7ff
)paren
op_lshift
l_int|20
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
(brace
multiline_comment|/* Number is zero */
id|l
(braket
l_int|0
)braket
op_assign
id|l
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
id|l
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|l
(braket
l_int|1
)braket
op_assign
l_int|0x7ff00000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
(brace
multiline_comment|/* See if we can get a valid NaN from the FPU_REG */
id|l
(braket
l_int|0
)braket
op_assign
(paren
id|FPU_st0_ptr-&gt;sigl
op_rshift
l_int|11
)paren
op_or
(paren
id|FPU_st0_ptr-&gt;sigh
op_lshift
l_int|21
)paren
suffix:semicolon
id|l
(braket
l_int|1
)braket
op_assign
(paren
(paren
id|FPU_st0_ptr-&gt;sigh
op_rshift
l_int|11
)paren
op_amp
l_int|0xfffff
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|l
(braket
l_int|0
)braket
op_or
id|l
(braket
l_int|1
)braket
)paren
)paren
(brace
multiline_comment|/* This case does not seem to be handled by the 80486 specs */
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
multiline_comment|/* Make the quiet NaN &quot;real indefinite&quot; */
r_goto
id|put_indefinite
suffix:semicolon
)brace
id|l
(braket
l_int|1
)braket
op_or_assign
l_int|0x7ff00000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
(brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
multiline_comment|/* The masked response */
multiline_comment|/* Put out the QNaN indefinite */
id|put_indefinite
suffix:colon
id|RE_ENTRANT_CHECK_OFF
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|dfloat
comma
l_int|8
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
l_int|0
comma
(paren
r_int
r_int
op_star
)paren
id|dfloat
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
l_int|0xfff80000
comma
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|dfloat
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Denormal
)paren
(brace
multiline_comment|/* Extended real -&gt; double real will always underflow */
id|l
(braket
l_int|0
)braket
op_assign
id|l
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|EXCEPTION
c_func
(paren
id|EX_Underflow
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
)paren
id|l
(braket
l_int|1
)braket
op_or_assign
l_int|0x80000000
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|dfloat
comma
l_int|8
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|l
(braket
l_int|0
)braket
comma
(paren
r_int
r_int
op_star
)paren
id|dfloat
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|l
(braket
l_int|1
)braket
comma
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|dfloat
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Put a float into user memory */
DECL|function|reg_store_single
r_int
id|reg_store_single
c_func
(paren
r_void
)paren
(brace
r_float
op_star
id|single
op_assign
(paren
r_float
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
id|templ
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Valid
)paren
(brace
r_int
id|exp
suffix:semicolon
id|FPU_REG
id|tmp
suffix:semicolon
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp.sigl
op_or
(paren
id|tmp.sigh
op_amp
l_int|0x000000ff
)paren
)paren
(brace
r_int
r_int
id|increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* avoid gcc warnings */
r_int
r_int
id|sigh
op_assign
id|tmp.sigh
suffix:semicolon
r_int
r_int
id|sigl
op_assign
id|tmp.sigl
suffix:semicolon
r_switch
c_cond
(paren
id|control_word
op_amp
id|CW_RC
)paren
(brace
r_case
id|RC_RND
suffix:colon
id|increment
op_assign
(paren
(paren
id|sigh
op_amp
l_int|0xff
)paren
OG
l_int|0x80
)paren
multiline_comment|/* more than half */
op_logical_or
(paren
(paren
(paren
id|sigh
op_amp
l_int|0xff
)paren
op_eq
l_int|0x80
)paren
op_logical_and
id|sigl
)paren
multiline_comment|/* more than half */
op_logical_or
(paren
(paren
id|sigh
op_amp
l_int|0x180
)paren
op_eq
l_int|0x180
)paren
suffix:semicolon
multiline_comment|/* round to even */
r_break
suffix:semicolon
r_case
id|RC_DOWN
suffix:colon
multiline_comment|/* towards -infinity */
id|increment
op_assign
(paren
id|tmp.sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
l_int|0
suffix:colon
(paren
id|sigl
op_or
(paren
id|sigh
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RC_UP
suffix:colon
multiline_comment|/* towards +infinity */
id|increment
op_assign
(paren
id|tmp.sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
(paren
id|sigl
op_or
(paren
id|sigh
op_amp
l_int|0xff
)paren
)paren
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RC_CHOP
suffix:colon
id|increment
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Truncate part of the mantissa */
id|tmp.sigl
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|increment
)paren
(brace
r_if
c_cond
(paren
id|sigh
op_ge
l_int|0xffffff00
)paren
(brace
multiline_comment|/* The sigh part overflows */
id|tmp.sigh
op_assign
l_int|0x80000000
suffix:semicolon
id|tmp.exp
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tmp.exp
op_ge
id|EXP_OVER
)paren
r_goto
id|overflow
suffix:semicolon
)brace
r_else
(brace
id|tmp.sigh
op_and_assign
l_int|0xffffff00
suffix:semicolon
id|tmp.sigh
op_add_assign
l_int|0x100
suffix:semicolon
)brace
)brace
r_else
id|tmp.sigh
op_and_assign
l_int|0xffffff00
suffix:semicolon
multiline_comment|/* Finish the truncation */
)brace
id|templ
op_assign
(paren
id|tmp.sigh
op_rshift
l_int|8
)paren
op_amp
l_int|0x007fffff
suffix:semicolon
id|exp
op_assign
id|tmp.exp
op_minus
id|EXP_BIAS
suffix:semicolon
r_if
c_cond
(paren
id|exp
OG
id|SINGLE_Emax
)paren
(brace
id|overflow
suffix:colon
id|EXCEPTION
c_func
(paren
id|EX_Overflow
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Overflow
)paren
(brace
multiline_comment|/* Overflow to infinity */
id|templ
op_assign
l_int|0x7f800000
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|exp
OL
id|SINGLE_Emin
)paren
(brace
r_if
c_cond
(paren
id|exp
OG
id|SINGLE_Emin
op_minus
l_int|24
)paren
(brace
multiline_comment|/* Make a de-normal */
id|FPU_REG
id|tmp
suffix:semicolon
id|EXCEPTION
c_func
(paren
id|EX_Denormal
)paren
suffix:semicolon
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|tmp.exp
op_add_assign
op_minus
id|SINGLE_Emin
op_plus
l_int|23
suffix:semicolon
multiline_comment|/* largest exp to be 22 */
id|round_to_int
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|templ
op_assign
id|tmp.sigl
suffix:semicolon
)brace
r_else
(brace
id|EXCEPTION
c_func
(paren
id|EX_Underflow
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Underflow
)paren
(brace
multiline_comment|/* Underflow to zero */
id|templ
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
id|templ
op_or_assign
(paren
(paren
id|exp
op_plus
id|SINGLE_Ebias
)paren
op_amp
l_int|0xff
)paren
op_lshift
l_int|23
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Zero
)paren
(brace
id|templ
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Infinity
)paren
(brace
id|templ
op_assign
l_int|0x7f800000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_NaN
)paren
(brace
multiline_comment|/* See if we can get a valid NaN from the FPU_REG */
id|templ
op_assign
id|FPU_st0_ptr-&gt;sigh
op_rshift
l_int|8
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|templ
op_amp
l_int|0x3fffff
)paren
)paren
(brace
multiline_comment|/* This case does not seem to be handled by the 80486 specs */
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
multiline_comment|/* Make the quiet NaN &quot;real indefinite&quot; */
r_goto
id|put_indefinite
suffix:semicolon
)brace
id|templ
op_or_assign
l_int|0x7f800000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
(brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
multiline_comment|/* The masked response */
multiline_comment|/* Put out the QNaN indefinite */
id|put_indefinite
suffix:colon
id|RE_ENTRANT_CHECK_OFF
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|single
comma
l_int|4
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
l_int|0xffc00000
comma
(paren
r_int
r_int
op_star
)paren
id|single
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Denormal
)paren
(brace
multiline_comment|/* Extended real -&gt; real will always underflow */
id|templ
op_assign
l_int|0
suffix:semicolon
id|EXCEPTION
c_func
(paren
id|EX_Underflow
)paren
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
r_else
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x106
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|FPU_st0_ptr-&gt;sign
)paren
id|templ
op_or_assign
l_int|0x80000000
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|single
comma
l_int|4
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|templ
comma
(paren
r_int
r_int
op_star
)paren
id|single
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Put a long long into user memory */
DECL|function|reg_store_int64
r_int
id|reg_store_int64
c_func
(paren
r_void
)paren
(brace
r_int
r_int
op_star
id|d
op_assign
(paren
r_int
r_int
op_star
)paren
id|FPU_data_address
suffix:semicolon
id|FPU_REG
id|t
suffix:semicolon
r_int
r_int
id|tll
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
(brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
multiline_comment|/* The masked response */
multiline_comment|/* Put out the QNaN indefinite */
r_goto
id|put_indefinite
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|t
)paren
suffix:semicolon
id|round_to_int
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
(paren
(paren
r_int
op_star
)paren
op_amp
id|tll
)paren
(braket
l_int|0
)braket
op_assign
id|t.sigl
suffix:semicolon
(paren
(paren
r_int
op_star
)paren
op_amp
id|tll
)paren
(braket
l_int|1
)braket
op_assign
id|t.sigh
suffix:semicolon
r_if
c_cond
(paren
(paren
id|t.sigh
op_amp
l_int|0x80000000
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|t.sigh
op_eq
l_int|0x80000000
)paren
op_logical_and
(paren
id|t.sigl
op_eq
l_int|0
)paren
op_logical_and
(paren
id|t.sign
op_eq
id|SIGN_NEG
)paren
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
multiline_comment|/* Produce &quot;indefinite&quot; */
id|put_indefinite
suffix:colon
(paren
(paren
r_int
op_star
)paren
op_amp
id|tll
)paren
(braket
l_int|1
)braket
op_assign
l_int|0x80000000
suffix:semicolon
(paren
(paren
r_int
op_star
)paren
op_amp
id|tll
)paren
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|t.sign
)paren
id|tll
op_assign
op_minus
id|tll
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|d
comma
l_int|8
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|tll
)paren
(braket
l_int|0
)braket
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|tll
)paren
(braket
l_int|1
)braket
comma
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Put a long into user memory */
DECL|function|reg_store_int32
r_int
id|reg_store_int32
c_func
(paren
r_void
)paren
(brace
r_int
op_star
id|d
op_assign
(paren
r_int
op_star
)paren
id|FPU_data_address
suffix:semicolon
id|FPU_REG
id|t
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
(brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
multiline_comment|/* The masked response */
multiline_comment|/* Put out the QNaN indefinite */
id|RE_ENTRANT_CHECK_OFF
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|4
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
l_int|0x80000000
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|t
)paren
suffix:semicolon
id|round_to_int
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t.sigh
op_logical_or
(paren
(paren
id|t.sigl
op_amp
l_int|0x80000000
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|t.sigl
op_eq
l_int|0x80000000
)paren
op_logical_and
(paren
id|t.sign
op_eq
id|SIGN_NEG
)paren
)paren
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
multiline_comment|/* Produce &quot;indefinite&quot; */
id|t.sigl
op_assign
l_int|0x80000000
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|t.sign
)paren
id|t.sigl
op_assign
op_minus
(paren
r_int
)paren
id|t.sigl
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|4
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|t.sigl
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Put a short into user memory */
DECL|function|reg_store_int16
r_int
id|reg_store_int16
c_func
(paren
r_void
)paren
(brace
r_int
op_star
id|d
op_assign
(paren
r_int
op_star
)paren
id|FPU_data_address
suffix:semicolon
id|FPU_REG
id|t
suffix:semicolon
r_int
id|ts
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
(brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
multiline_comment|/* The masked response */
multiline_comment|/* Put out the QNaN indefinite */
id|RE_ENTRANT_CHECK_OFF
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|2
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
l_int|0x8000
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|t
)paren
suffix:semicolon
id|round_to_int
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t.sigh
op_logical_or
(paren
(paren
id|t.sigl
op_amp
l_int|0xffff8000
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|t.sigl
op_eq
l_int|0x8000
)paren
op_logical_and
(paren
id|t.sign
op_eq
id|SIGN_NEG
)paren
)paren
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
multiline_comment|/* Produce &quot;indefinite&quot; */
id|ts
op_assign
l_int|0x8000
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|t.sign
)paren
id|t.sigl
op_assign
op_minus
id|t.sigl
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|2
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
(paren
r_int
)paren
id|t.sigl
comma
(paren
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Put a packed bcd array into user memory */
DECL|function|reg_store_bcd
r_int
id|reg_store_bcd
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|d
op_assign
(paren
r_char
op_star
)paren
id|FPU_data_address
suffix:semicolon
id|FPU_REG
id|t
suffix:semicolon
r_int
r_int
id|ll
suffix:semicolon
r_int
r_char
id|b
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_char
id|sign
op_assign
(paren
id|FPU_st0_ptr-&gt;sign
op_eq
id|SIGN_NEG
)paren
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|FPU_st0_tag
op_eq
id|TW_Empty
)paren
(brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
multiline_comment|/* The masked response */
multiline_comment|/* Put out the QNaN indefinite */
r_goto
id|put_indefinite
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
id|reg_move
c_func
(paren
id|FPU_st0_ptr
comma
op_amp
id|t
)paren
suffix:semicolon
id|round_to_int
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
id|ll
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|t.sigl
)paren
suffix:semicolon
multiline_comment|/* Check for overflow, by comparing with 999999999999999999 decimal. */
r_if
c_cond
(paren
(paren
id|t.sigh
OG
l_int|0x0de0b6b3
)paren
op_logical_or
(paren
(paren
id|t.sigh
op_eq
l_int|0x0de0b6b3
)paren
op_logical_and
(paren
id|t.sigl
OG
l_int|0xa763ffff
)paren
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
id|put_indefinite
suffix:colon
multiline_comment|/* Produce &quot;indefinite&quot; */
id|RE_ENTRANT_CHECK_OFF
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|10
)paren
suffix:semicolon
id|put_fs_byte
c_func
(paren
l_int|0xff
comma
(paren
r_int
r_char
op_star
)paren
id|d
op_plus
l_int|7
)paren
suffix:semicolon
id|put_fs_byte
c_func
(paren
l_int|0xff
comma
(paren
r_int
r_char
op_star
)paren
id|d
op_plus
l_int|8
)paren
suffix:semicolon
id|put_fs_byte
c_func
(paren
l_int|0xff
comma
(paren
r_int
r_char
op_star
)paren
id|d
op_plus
l_int|9
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|10
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|9
suffix:semicolon
id|i
op_increment
)paren
(brace
id|b
op_assign
id|div_small
c_func
(paren
op_amp
id|ll
comma
l_int|10
)paren
suffix:semicolon
id|b
op_or_assign
(paren
id|div_small
c_func
(paren
op_amp
id|ll
comma
l_int|10
)paren
)paren
op_lshift
l_int|4
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
id|put_fs_byte
c_func
(paren
id|b
comma
(paren
r_int
r_char
op_star
)paren
id|d
op_plus
id|i
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
)brace
id|RE_ENTRANT_CHECK_OFF
id|put_fs_byte
c_func
(paren
id|sign
comma
(paren
r_int
r_char
op_star
)paren
id|d
op_plus
l_int|9
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*===========================================================================*/
multiline_comment|/* r gets mangled such that sig is int, sign: &n;   it is NOT normalized*/
multiline_comment|/* Overflow is signalled by a non-zero return value (in eax).&n;   In the case of overflow, the returned significand always has the&n;   the largest possible value */
multiline_comment|/* The value returned in eax is never actually needed :-) */
DECL|function|round_to_int
r_int
id|round_to_int
c_func
(paren
id|FPU_REG
op_star
id|r
)paren
(brace
r_char
id|very_big
suffix:semicolon
r_int
id|eax
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;tag
op_eq
id|TW_Zero
)paren
(brace
multiline_comment|/* Make sure that zero is returned */
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|r-&gt;sigl
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* o.k. */
)brace
r_if
c_cond
(paren
id|r-&gt;exp
OG
id|EXP_BIAS
op_plus
l_int|63
)paren
(brace
id|r-&gt;sigl
op_assign
id|r-&gt;sigh
op_assign
op_complement
l_int|0
suffix:semicolon
multiline_comment|/* The largest representable number */
r_return
l_int|1
suffix:semicolon
multiline_comment|/* overflow */
)brace
id|eax
op_assign
id|shrxs
c_func
(paren
op_amp
id|r-&gt;sigl
comma
id|EXP_BIAS
op_plus
l_int|63
op_minus
id|r-&gt;exp
)paren
suffix:semicolon
id|very_big
op_assign
op_logical_neg
(paren
op_complement
(paren
id|r-&gt;sigh
)paren
op_or
op_complement
(paren
id|r-&gt;sigl
)paren
)paren
suffix:semicolon
multiline_comment|/* test for 0xfff...fff */
DECL|macro|half_or_more
mdefine_line|#define&t;half_or_more&t;(eax &amp; 0x80000000)
DECL|macro|frac_part
mdefine_line|#define&t;frac_part&t;(eax)
DECL|macro|more_than_half
mdefine_line|#define more_than_half  ((eax &amp; 0x80000001) == 0x80000001)
r_switch
c_cond
(paren
id|control_word
op_amp
id|CW_RC
)paren
(brace
r_case
id|RC_RND
suffix:colon
r_if
c_cond
(paren
id|more_than_half
multiline_comment|/* nearest */
op_logical_or
(paren
id|half_or_more
op_logical_and
(paren
id|r-&gt;sigl
op_amp
l_int|1
)paren
)paren
)paren
multiline_comment|/* odd -&gt; even */
(brace
r_if
c_cond
(paren
id|very_big
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* overflow */
(paren
op_star
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|r-&gt;sigl
)paren
)paren
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RC_DOWN
suffix:colon
r_if
c_cond
(paren
id|frac_part
op_logical_and
id|r-&gt;sign
)paren
(brace
r_if
c_cond
(paren
id|very_big
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* overflow */
(paren
op_star
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|r-&gt;sigl
)paren
)paren
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RC_UP
suffix:colon
r_if
c_cond
(paren
id|frac_part
op_logical_and
op_logical_neg
id|r-&gt;sign
)paren
(brace
r_if
c_cond
(paren
id|very_big
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* overflow */
(paren
op_star
(paren
r_int
r_int
op_star
)paren
(paren
op_amp
id|r-&gt;sigl
)paren
)paren
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RC_CHOP
suffix:colon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* o.k. */
)brace
multiline_comment|/*===========================================================================*/
DECL|function|fldenv
r_char
op_star
id|fldenv
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|s
op_assign
(paren
r_char
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
r_int
id|tag_word
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|tag
suffix:semicolon
r_int
id|i
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
id|control_word
op_assign
id|get_fs_word
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|s
)paren
suffix:semicolon
id|status_word
op_assign
id|get_fs_word
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|tag_word
op_assign
id|get_fs_word
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|8
)paren
)paren
suffix:semicolon
id|ip_offset
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|0x0c
)paren
)paren
suffix:semicolon
id|cs_selector
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|0x10
)paren
)paren
suffix:semicolon
id|data_operand_offset
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|0x14
)paren
)paren
suffix:semicolon
id|operand_selector
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|0x18
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_for
c_loop
(paren
id|i
op_assign
l_int|7
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|tag
op_assign
id|tag_word
op_amp
l_int|3
suffix:semicolon
id|tag_word
op_lshift_assign
l_int|2
suffix:semicolon
r_switch
c_cond
(paren
id|tag
)paren
(brace
r_case
l_int|0
suffix:colon
id|regs
(braket
id|i
)braket
dot
id|tag
op_assign
id|TW_Valid
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|regs
(braket
id|i
)braket
dot
id|tag
op_assign
id|TW_Zero
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|regs
(braket
id|i
)braket
dot
id|tag
op_assign
id|TW_NaN
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|regs
(braket
id|i
)braket
dot
id|tag
op_assign
id|TW_Empty
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|FPU_data_address
op_assign
(paren
r_void
op_star
)paren
id|data_operand_offset
suffix:semicolon
multiline_comment|/* We want no net effect */
id|FPU_entry_eip
op_assign
id|ip_offset
suffix:semicolon
multiline_comment|/* We want no net effect */
r_return
id|s
op_plus
l_int|0x1c
suffix:semicolon
)brace
DECL|function|frstor
r_void
id|frstor
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|tag
suffix:semicolon
id|FPU_REG
op_star
id|s
op_assign
(paren
id|FPU_REG
op_star
)paren
id|fldenv
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* load each register */
id|FPU_data_address
op_assign
(paren
r_void
op_star
)paren
op_amp
(paren
id|s
(braket
id|i
)braket
)paren
suffix:semicolon
id|reg_load_extended
c_func
(paren
)paren
suffix:semicolon
id|tag
op_assign
id|regs
(braket
id|i
)braket
dot
id|tag
suffix:semicolon
id|reg_move
c_func
(paren
op_amp
id|FPU_loaded_data
comma
op_amp
id|regs
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|TW_NaN
)paren
(brace
r_int
r_char
id|t
op_assign
id|regs
(braket
id|i
)braket
dot
id|tag
suffix:semicolon
r_if
c_cond
(paren
(paren
id|t
op_eq
id|TW_Valid
)paren
op_logical_or
(paren
id|t
op_eq
id|TW_Zero
)paren
)paren
id|regs
(braket
id|i
)braket
dot
id|tag
op_assign
id|TW_NaN
suffix:semicolon
)brace
r_else
id|regs
(braket
id|i
)braket
dot
id|tag
op_assign
id|tag
suffix:semicolon
)brace
id|FPU_data_address
op_assign
(paren
r_void
op_star
)paren
id|data_operand_offset
suffix:semicolon
multiline_comment|/* We want no net effect */
)brace
DECL|function|fstenv
r_char
op_star
id|fstenv
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|d
op_assign
(paren
r_char
op_star
)paren
id|FPU_data_address
suffix:semicolon
r_int
r_int
id|tag_word
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|tag
suffix:semicolon
r_int
id|i
suffix:semicolon
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|28
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|7
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_switch
c_cond
(paren
id|tag
op_assign
id|regs
(braket
id|i
)braket
dot
id|tag
)paren
(brace
r_case
id|TW_Denormal
suffix:colon
r_case
id|TW_Infinity
suffix:colon
r_case
id|TW_NaN
suffix:colon
id|tag
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TW_Empty
suffix:colon
id|tag
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* TW_Valid and TW_Zero already have the correct value */
)brace
id|tag_word
op_lshift_assign
l_int|2
suffix:semicolon
id|tag_word
op_or_assign
id|tag
suffix:semicolon
)brace
multiline_comment|/* This is not what should be done ... but saves overheads. */
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|cs_selector
op_assign
id|FPU_CS
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|operand_selector
op_assign
id|FPU_DS
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
id|put_fs_word
c_func
(paren
id|control_word
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
id|status_word
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
id|tag_word
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|8
)paren
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|ip_offset
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|0x0c
)paren
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|cs_selector
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|0x10
)paren
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|data_operand_offset
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|0x14
)paren
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|operand_selector
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|0x18
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
r_return
id|d
op_plus
l_int|0x1c
suffix:semicolon
)brace
DECL|function|fsave
r_void
id|fsave
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|d
suffix:semicolon
id|FPU_REG
id|tmp
comma
op_star
id|rp
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|e
suffix:semicolon
id|d
op_assign
id|fstenv
c_func
(paren
)paren
suffix:semicolon
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|80
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* store each register */
id|rp
op_assign
op_amp
id|regs
(braket
id|i
)braket
suffix:semicolon
id|e
op_assign
id|rp-&gt;exp
op_minus
id|EXP_BIAS
op_plus
id|EXTENDED_Ebias
suffix:semicolon
r_if
c_cond
(paren
id|rp-&gt;tag
op_eq
id|TW_Valid
)paren
(brace
r_if
c_cond
(paren
id|e
op_ge
l_int|0x7fff
)paren
(brace
multiline_comment|/* Overflow to infinity */
id|RE_ENTRANT_CHECK_OFF
id|put_fs_long
c_func
(paren
l_int|0
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
id|i
op_star
l_int|10
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
l_int|0x80000000
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
id|i
op_star
l_int|10
op_plus
l_int|6
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
id|e
op_assign
l_int|0x7fff
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|e
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|e
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Pseudo de-normal */
id|RE_ENTRANT_CHECK_OFF
id|put_fs_long
c_func
(paren
id|rp-&gt;sigl
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
id|i
op_star
l_int|10
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|rp-&gt;sigh
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
id|i
op_star
l_int|10
op_plus
l_int|6
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
)brace
r_else
r_if
c_cond
(paren
id|e
OG
op_minus
l_int|64
)paren
(brace
multiline_comment|/* Make a de-normal */
id|reg_move
c_func
(paren
id|rp
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|tmp.exp
op_add_assign
op_minus
id|EXTENDED_Emin
op_plus
l_int|64
suffix:semicolon
multiline_comment|/* largest exp to be 63 */
id|round_to_int
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|e
op_assign
l_int|0
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
id|put_fs_long
c_func
(paren
id|tmp.sigl
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
id|i
op_star
l_int|10
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|tmp.sigh
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
id|i
op_star
l_int|10
op_plus
l_int|6
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
)brace
r_else
(brace
multiline_comment|/* Underflow to zero */
id|RE_ENTRANT_CHECK_OFF
id|put_fs_long
c_func
(paren
l_int|0
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
id|i
op_star
l_int|10
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
l_int|0
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
id|i
op_star
l_int|10
op_plus
l_int|6
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
id|e
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|RE_ENTRANT_CHECK_OFF
id|put_fs_long
c_func
(paren
id|rp-&gt;sigl
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
id|i
op_star
l_int|10
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|rp-&gt;sigh
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
id|i
op_star
l_int|10
op_plus
l_int|6
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
)brace
)brace
r_else
r_if
c_cond
(paren
id|rp-&gt;tag
op_eq
id|TW_Zero
)paren
(brace
id|RE_ENTRANT_CHECK_OFF
id|put_fs_long
c_func
(paren
l_int|0
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
id|i
op_star
l_int|10
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
l_int|0
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
id|i
op_star
l_int|10
op_plus
l_int|6
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
id|e
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rp-&gt;tag
op_eq
id|TW_Infinity
)paren
(brace
id|RE_ENTRANT_CHECK_OFF
id|put_fs_long
c_func
(paren
l_int|0
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
id|i
op_star
l_int|10
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
l_int|0x80000000
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
id|i
op_star
l_int|10
op_plus
l_int|6
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
id|e
op_assign
l_int|0x7fff
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rp-&gt;tag
op_eq
id|TW_NaN
)paren
(brace
id|RE_ENTRANT_CHECK_OFF
id|put_fs_long
c_func
(paren
id|rp-&gt;sigl
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
id|i
op_star
l_int|10
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|rp-&gt;sigh
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
id|i
op_star
l_int|10
op_plus
l_int|6
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
id|e
op_assign
l_int|0x7fff
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rp-&gt;tag
op_eq
id|TW_Empty
)paren
(brace
multiline_comment|/* just copy the reg */
id|RE_ENTRANT_CHECK_OFF
id|put_fs_long
c_func
(paren
id|rp-&gt;sigl
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
id|i
op_star
l_int|10
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|rp-&gt;sigh
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
id|i
op_star
l_int|10
op_plus
l_int|6
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
)brace
id|RE_ENTRANT_CHECK_OFF
id|put_fs_word
c_func
(paren
id|e
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
id|i
op_star
l_int|10
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
)brace
)brace
multiline_comment|/*===========================================================================*/
eof
