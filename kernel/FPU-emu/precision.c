multiline_comment|/*---------------------------------------------------------------------------+&n; |  precision.c                                                              |&n; |                                                                           |&n; | The functions which adjust the precision of a result.                     |&n; |                                                                           |&n; | Copyright (C) 1993    W. Metzenthen, 22 Parker St, Ormond, Vic 3163,      |&n; |                       Australia.  E-mail apm233m@vaxc.cc.monash.edu.au    |&n; |                                                                           |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &quot;fpu_system.h&quot;
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;reg_constant.h&quot;
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &quot;control_w.h&quot;
multiline_comment|/* Round the result to 53 bits */
DECL|function|round_to_53_bits
r_int
id|round_to_53_bits
c_func
(paren
id|FPU_REG
op_star
id|reg
)paren
(brace
r_if
c_cond
(paren
id|reg-&gt;tag
op_eq
id|TW_Valid
)paren
(brace
r_int
r_int
id|increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* avoid gcc warnings */
r_switch
c_cond
(paren
id|control_word
op_amp
id|CW_RC
)paren
(brace
r_case
id|RC_RND
suffix:colon
multiline_comment|/* Rounding can get a little messy.. */
id|increment
op_assign
(paren
(paren
id|reg-&gt;sigl
op_amp
l_int|0x7ff
)paren
OG
l_int|0x400
)paren
op_or
multiline_comment|/* nearest */
(paren
(paren
id|reg-&gt;sigl
op_amp
l_int|0xc00
)paren
op_eq
l_int|0xc00
)paren
suffix:semicolon
multiline_comment|/* odd -&gt; even */
r_break
suffix:semicolon
r_case
id|RC_DOWN
suffix:colon
multiline_comment|/* towards -infinity */
id|increment
op_assign
(paren
id|reg-&gt;sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
l_int|0
suffix:colon
id|reg-&gt;sigl
op_amp
l_int|0x7ff
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RC_UP
suffix:colon
multiline_comment|/* towards +infinity */
id|increment
op_assign
(paren
id|reg-&gt;sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
id|reg-&gt;sigl
op_amp
l_int|0x7ff
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RC_CHOP
suffix:colon
id|increment
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Truncate the mantissa */
id|reg-&gt;sigl
op_and_assign
l_int|0xfffff800
suffix:semicolon
r_if
c_cond
(paren
id|increment
)paren
(brace
r_if
c_cond
(paren
id|reg-&gt;sigl
op_ge
l_int|0xfffff800
)paren
(brace
multiline_comment|/* the sigl part overflows */
r_if
c_cond
(paren
id|reg-&gt;sigh
op_eq
l_int|0xffffffff
)paren
(brace
multiline_comment|/* The sigh part overflows */
id|reg-&gt;sigh
op_assign
l_int|0x80000000
suffix:semicolon
id|reg-&gt;exp
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|reg-&gt;exp
op_ge
id|EXP_OVER
)paren
(brace
id|arith_overflow
c_func
(paren
id|reg
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|reg-&gt;sigh
op_increment
suffix:semicolon
)brace
id|reg-&gt;sigl
op_assign
l_int|0x00000000
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We only need to increment sigl */
id|reg-&gt;sigl
op_add_assign
l_int|0x00000800
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Round the result to 24 bits */
DECL|function|round_to_24_bits
r_int
id|round_to_24_bits
c_func
(paren
id|FPU_REG
op_star
id|reg
)paren
(brace
r_if
c_cond
(paren
id|reg-&gt;tag
op_eq
id|TW_Valid
)paren
(brace
r_int
r_int
id|increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* avoid gcc warnings */
r_int
r_int
id|sigh
op_assign
id|reg-&gt;sigh
suffix:semicolon
r_int
r_int
id|sigl
op_assign
id|reg-&gt;sigl
suffix:semicolon
r_switch
c_cond
(paren
id|control_word
op_amp
id|CW_RC
)paren
(brace
r_case
id|RC_RND
suffix:colon
id|increment
op_assign
(paren
(paren
id|sigh
op_amp
l_int|0xff
)paren
OG
l_int|0x80
)paren
multiline_comment|/* more than half */
op_logical_or
(paren
(paren
(paren
id|sigh
op_amp
l_int|0xff
)paren
op_eq
l_int|0x80
)paren
op_logical_and
id|sigl
)paren
multiline_comment|/* more than half */
op_logical_or
(paren
(paren
id|sigh
op_amp
l_int|0x180
)paren
op_eq
l_int|0x180
)paren
suffix:semicolon
multiline_comment|/* round to even */
r_break
suffix:semicolon
r_case
id|RC_DOWN
suffix:colon
multiline_comment|/* towards -infinity */
id|increment
op_assign
(paren
id|reg-&gt;sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
l_int|0
suffix:colon
(paren
id|sigl
op_or
(paren
id|sigh
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RC_UP
suffix:colon
multiline_comment|/* towards +infinity */
id|increment
op_assign
(paren
id|reg-&gt;sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
(paren
id|sigl
op_or
(paren
id|sigh
op_amp
l_int|0xff
)paren
)paren
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RC_CHOP
suffix:colon
id|increment
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Truncate the mantissa */
id|reg-&gt;sigl
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|increment
)paren
(brace
r_if
c_cond
(paren
id|sigh
op_ge
l_int|0xffffff00
)paren
(brace
multiline_comment|/* The sigh part overflows */
id|reg-&gt;sigh
op_assign
l_int|0x80000000
suffix:semicolon
id|reg-&gt;exp
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|reg-&gt;exp
op_ge
id|EXP_OVER
)paren
(brace
id|arith_overflow
c_func
(paren
id|reg
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|reg-&gt;sigh
op_and_assign
l_int|0xffffff00
suffix:semicolon
id|reg-&gt;sigh
op_add_assign
l_int|0x100
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
