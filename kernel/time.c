multiline_comment|/*&n; *  linux/kernel/time.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; *&n; *  This file contains the interface functions for the various&n; *  time related system calls: time, stime, gettimeofday, settimeofday,&n; *&t;&t;&t;       adjtime&n; */
multiline_comment|/*&n; * Modification history kernel/time.c&n; * &n; * 1993-09-02    Philip Gladstone&n; *      Created file with time related functions from sched.c and adjtimex() &n; * 1993-10-08    Torsten Duwe&n; *      adjtime interface update and CMOS clock write code&n; * 1995-08-13    Torsten Duwe&n; *      kernel PLL updated to 1994-12-13 specs (rfc-1489)&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/param.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
multiline_comment|/* &n; * The timezone where the local system is located.  Used as a default by some&n; * programs who obtain this value by using gettimeofday.&n; */
DECL|variable|sys_tz
r_struct
id|timezone
id|sys_tz
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
macro_line|#ifndef __alpha__
multiline_comment|/*&n; * sys_time() can be implemented in user-level using&n; * sys_gettimeofday().  Is this for backwards compatibility?  If so,&n; * why not move it into the appropriate arch directory (for those&n; * architectures that need it).&n; */
DECL|function|sys_time
id|asmlinkage
r_int
id|sys_time
c_func
(paren
r_int
op_star
id|tloc
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|CURRENT_TIME
suffix:semicolon
r_if
c_cond
(paren
id|tloc
)paren
(brace
r_int
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|tloc
comma
r_sizeof
(paren
op_star
id|tloc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|put_user
c_func
(paren
id|i
comma
id|tloc
)paren
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * sys_stime() can be implemented in user-level using&n; * sys_settimeofday().  Is this for backwards compatibility?  If so,&n; * why not move it into the appropriate arch directory (for those&n; * architectures that need it).&n; */
DECL|function|sys_stime
id|asmlinkage
r_int
id|sys_stime
c_func
(paren
r_int
op_star
id|tptr
)paren
(brace
r_int
id|error
comma
id|value
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|tptr
comma
r_sizeof
(paren
op_star
id|tptr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|value
op_assign
id|get_user
c_func
(paren
id|tptr
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|xtime.tv_sec
op_assign
id|value
suffix:semicolon
id|xtime.tv_usec
op_assign
l_int|0
suffix:semicolon
id|time_state
op_assign
id|TIME_BAD
suffix:semicolon
id|time_maxerror
op_assign
l_int|0x70000000
suffix:semicolon
id|time_esterror
op_assign
l_int|0x70000000
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|sys_gettimeofday
id|asmlinkage
r_int
id|sys_gettimeofday
c_func
(paren
r_struct
id|timeval
op_star
id|tv
comma
r_struct
id|timezone
op_star
id|tz
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|tv
)paren
(brace
r_struct
id|timeval
id|ktv
suffix:semicolon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|tv
comma
r_sizeof
op_star
id|tv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|ktv
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|tv
comma
op_amp
id|ktv
comma
r_sizeof
(paren
id|ktv
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tz
)paren
(brace
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|tz
comma
r_sizeof
op_star
id|tz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|tz
comma
op_amp
id|sys_tz
comma
r_sizeof
(paren
id|sys_tz
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Adjust the time obtained from the CMOS to be UTC time instead of&n; * local time.&n; * &n; * This is ugly, but preferable to the alternatives.  Otherwise we&n; * would either need to write a program to do it in /etc/rc (and risk&n; * confusion if the program gets run more than once; it would also be &n; * hard to make the program warp the clock precisely n hours)  or&n; * compile in the timezone information into the kernel.  Bad, bad....&n; *&n; *              &t;&t;&t;&t;- TYT, 1992-01-01&n; *&n; * The best thing to do is to keep the CMOS clock in universal time (UTC)&n; * as real UNIX machines always do it. This avoids all headaches about&n; * daylight saving times and warping kernel clocks.&n; */
DECL|function|warp_clock
r_inline
r_static
r_void
id|warp_clock
c_func
(paren
r_void
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|xtime.tv_sec
op_add_assign
id|sys_tz.tz_minuteswest
op_star
l_int|60
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * In case for some reason the CMOS clock has not already been running&n; * in UTC, but in some local time: The first time we set the timezone,&n; * we will warp the clock so that it is ticking UTC time instead of&n; * local time. Presumably, if someone is setting the timezone then we&n; * are running in an environment where the programs understand about&n; * timezones. This should be done at boot time in the /etc/rc script,&n; * as soon as possible, so that the clock can be set right. Otherwise,&n; * various programs will get confused when the clock gets warped.&n; */
DECL|function|sys_settimeofday
id|asmlinkage
r_int
id|sys_settimeofday
c_func
(paren
r_struct
id|timeval
op_star
id|tv
comma
r_struct
id|timezone
op_star
id|tz
)paren
(brace
r_static
r_int
id|firsttime
op_assign
l_int|1
suffix:semicolon
r_struct
id|timeval
id|new_tv
suffix:semicolon
r_struct
id|timezone
id|new_tz
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|tv
)paren
(brace
r_int
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|tv
comma
r_sizeof
(paren
op_star
id|tv
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|new_tv
comma
id|tv
comma
r_sizeof
(paren
op_star
id|tv
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tz
)paren
(brace
r_int
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|tz
comma
r_sizeof
(paren
op_star
id|tz
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|new_tz
comma
id|tz
comma
r_sizeof
(paren
op_star
id|tz
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tz
)paren
(brace
id|sys_tz
op_assign
id|new_tz
suffix:semicolon
r_if
c_cond
(paren
id|firsttime
)paren
(brace
id|firsttime
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tv
)paren
id|warp_clock
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tv
)paren
id|do_settimeofday
c_func
(paren
op_amp
id|new_tv
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|pps_offset
r_int
id|pps_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* pps time offset (us) */
DECL|variable|pps_jitter
r_int
id|pps_jitter
op_assign
id|MAXTIME
suffix:semicolon
multiline_comment|/* time dispersion (jitter) (us) */
DECL|variable|pps_freq
r_int
id|pps_freq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* frequency offset (scaled ppm) */
DECL|variable|pps_stabil
r_int
id|pps_stabil
op_assign
id|MAXFREQ
suffix:semicolon
multiline_comment|/* frequency dispersion (scaled ppm) */
DECL|variable|pps_valid
r_int
id|pps_valid
op_assign
id|PPS_VALID
suffix:semicolon
multiline_comment|/* pps signal watchdog counter */
DECL|variable|pps_shift
r_int
id|pps_shift
op_assign
id|PPS_SHIFT
suffix:semicolon
multiline_comment|/* interval duration (s) (shift) */
DECL|variable|pps_jitcnt
r_int
id|pps_jitcnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* jitter limit exceeded */
DECL|variable|pps_calcnt
r_int
id|pps_calcnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* calibration intervals */
DECL|variable|pps_errcnt
r_int
id|pps_errcnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* calibration errors */
DECL|variable|pps_stbcnt
r_int
id|pps_stbcnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* stability limit exceeded */
multiline_comment|/* hook for a loadable hardpps kernel module */
DECL|variable|hardpps_ptr
r_void
(paren
op_star
id|hardpps_ptr
)paren
(paren
r_struct
id|timeval
op_star
)paren
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_struct
id|timeval
op_star
)paren
)paren
l_int|0
suffix:semicolon
multiline_comment|/* adjtimex mainly allows reading (and writing, if superuser) of&n; * kernel time-keeping variables. used by xntpd.&n; */
DECL|function|sys_adjtimex
id|asmlinkage
r_int
id|sys_adjtimex
c_func
(paren
r_struct
id|timex
op_star
id|txc_p
)paren
(brace
r_int
id|ltemp
comma
id|mtemp
comma
id|save_adjust
suffix:semicolon
r_int
id|error
suffix:semicolon
multiline_comment|/* Local copy of parameter */
r_struct
id|timex
id|txc
suffix:semicolon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|txc_p
comma
r_sizeof
(paren
r_struct
id|timex
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
multiline_comment|/* Copy the user data space into the kernel copy&n;&t; * structure. But bear in mind that the structures&n;&t; * may change&n;&t; */
id|memcpy_fromfs
c_func
(paren
op_amp
id|txc
comma
id|txc_p
comma
r_sizeof
(paren
r_struct
id|timex
)paren
)paren
suffix:semicolon
multiline_comment|/* In order to modify anything, you gotta be super-user! */
r_if
c_cond
(paren
id|txc.modes
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* Now we validate the data before disabling interrupts&n;&t; */
r_if
c_cond
(paren
id|txc.modes
op_ne
id|ADJ_OFFSET_SINGLESHOT
op_logical_and
(paren
id|txc.modes
op_amp
id|ADJ_OFFSET
)paren
)paren
multiline_comment|/* adjustment Offset limited to +- .512 seconds */
r_if
c_cond
(paren
id|txc.offset
op_le
op_minus
id|MAXPHASE
op_logical_or
id|txc.offset
op_ge
id|MAXPHASE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* if the quartz is off by more than 10% something is VERY wrong ! */
r_if
c_cond
(paren
id|txc.modes
op_amp
id|ADJ_TICK
)paren
r_if
c_cond
(paren
id|txc.tick
template_param
l_int|1100000
op_div
id|HZ
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Save for later - semantics of adjtime is to return old value */
id|save_adjust
op_assign
id|time_adjust
suffix:semicolon
multiline_comment|/* If there are input parameters, then process them */
r_if
c_cond
(paren
id|txc.modes
)paren
(brace
r_if
c_cond
(paren
id|time_state
op_eq
id|TIME_BAD
)paren
id|time_state
op_assign
id|TIME_OK
suffix:semicolon
r_if
c_cond
(paren
id|txc.modes
op_amp
id|ADJ_STATUS
)paren
id|time_status
op_assign
id|txc.status
suffix:semicolon
r_if
c_cond
(paren
id|txc.modes
op_amp
id|ADJ_FREQUENCY
)paren
id|time_freq
op_assign
id|txc.freq
suffix:semicolon
r_if
c_cond
(paren
id|txc.modes
op_amp
id|ADJ_MAXERROR
)paren
id|time_maxerror
op_assign
id|txc.maxerror
suffix:semicolon
r_if
c_cond
(paren
id|txc.modes
op_amp
id|ADJ_ESTERROR
)paren
id|time_esterror
op_assign
id|txc.esterror
suffix:semicolon
r_if
c_cond
(paren
id|txc.modes
op_amp
id|ADJ_TIMECONST
)paren
id|time_constant
op_assign
id|txc.constant
suffix:semicolon
r_if
c_cond
(paren
id|txc.modes
op_amp
id|ADJ_OFFSET
)paren
r_if
c_cond
(paren
(paren
id|txc.modes
op_eq
id|ADJ_OFFSET_SINGLESHOT
)paren
op_logical_or
op_logical_neg
(paren
id|time_status
op_amp
id|STA_PLL
)paren
)paren
(brace
id|time_adjust
op_assign
id|txc.offset
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|time_status
op_amp
id|STA_PLL
)paren
op_logical_or
(paren
id|time_status
op_amp
id|STA_PPSTIME
)paren
)paren
(brace
id|ltemp
op_assign
(paren
id|time_status
op_amp
id|STA_PPSTIME
op_logical_and
id|time_status
op_amp
id|STA_PPSSIGNAL
)paren
ques
c_cond
id|pps_offset
suffix:colon
id|txc.offset
suffix:semicolon
multiline_comment|/*&n;&t;&t;   * Scale the phase adjustment and&n;&t;&t;   * clamp to the operating range.&n;&t;&t;   */
r_if
c_cond
(paren
id|ltemp
OG
id|MAXPHASE
)paren
id|time_offset
op_assign
id|MAXPHASE
op_lshift
id|SHIFT_UPDATE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ltemp
OL
op_minus
id|MAXPHASE
)paren
id|time_offset
op_assign
op_minus
(paren
id|MAXPHASE
op_lshift
id|SHIFT_UPDATE
)paren
suffix:semicolon
r_else
id|time_offset
op_assign
id|ltemp
op_lshift
id|SHIFT_UPDATE
suffix:semicolon
multiline_comment|/*&n;&t;&t;   * Select whether the frequency is to be controlled and in which&n;&t;&t;   * mode (PLL or FLL). Clamp to the operating range. Ugly&n;&t;&t;   * multiply/divide should be replaced someday.&n;&t;&t;   */
r_if
c_cond
(paren
id|time_status
op_amp
id|STA_FREQHOLD
op_logical_or
id|time_reftime
op_eq
l_int|0
)paren
id|time_reftime
op_assign
id|xtime.tv_sec
suffix:semicolon
id|mtemp
op_assign
id|xtime.tv_sec
op_minus
id|time_reftime
suffix:semicolon
id|time_reftime
op_assign
id|xtime.tv_sec
suffix:semicolon
r_if
c_cond
(paren
id|time_status
op_amp
id|STA_FLL
)paren
(brace
r_if
c_cond
(paren
id|mtemp
op_ge
id|MINSEC
)paren
(brace
id|ltemp
op_assign
(paren
(paren
id|time_offset
op_div
id|mtemp
)paren
op_lshift
(paren
id|SHIFT_USEC
op_minus
id|SHIFT_UPDATE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ltemp
OL
l_int|0
)paren
id|time_freq
op_sub_assign
op_minus
id|ltemp
op_rshift
id|SHIFT_KH
suffix:semicolon
r_else
id|time_freq
op_add_assign
id|ltemp
op_rshift
id|SHIFT_KH
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|mtemp
OL
id|MAXSEC
)paren
(brace
id|ltemp
op_mul_assign
id|mtemp
suffix:semicolon
r_if
c_cond
(paren
id|ltemp
OL
l_int|0
)paren
id|time_freq
op_sub_assign
op_minus
id|ltemp
op_rshift
(paren
id|time_constant
op_plus
id|time_constant
op_plus
id|SHIFT_KF
op_minus
id|SHIFT_USEC
)paren
suffix:semicolon
r_else
id|time_freq
op_add_assign
id|ltemp
op_rshift
(paren
id|time_constant
op_plus
id|time_constant
op_plus
id|SHIFT_KF
op_minus
id|SHIFT_USEC
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|time_freq
OG
id|time_tolerance
)paren
id|time_freq
op_assign
id|time_tolerance
suffix:semicolon
r_else
r_if
c_cond
(paren
id|time_freq
OL
op_minus
id|time_tolerance
)paren
id|time_freq
op_assign
op_minus
id|time_tolerance
suffix:semicolon
)brace
r_if
c_cond
(paren
id|txc.modes
op_amp
id|ADJ_TICK
)paren
id|tick
op_assign
id|txc.tick
suffix:semicolon
)brace
id|txc.offset
op_assign
id|save_adjust
suffix:semicolon
id|txc.freq
op_assign
id|time_freq
suffix:semicolon
id|txc.maxerror
op_assign
id|time_maxerror
suffix:semicolon
id|txc.esterror
op_assign
id|time_esterror
suffix:semicolon
id|txc.status
op_assign
id|time_status
suffix:semicolon
id|txc.constant
op_assign
id|time_constant
suffix:semicolon
id|txc.precision
op_assign
id|time_precision
suffix:semicolon
id|txc.tolerance
op_assign
id|time_tolerance
suffix:semicolon
id|txc.time
op_assign
id|xtime
suffix:semicolon
id|txc.tick
op_assign
id|tick
suffix:semicolon
id|txc.ppsfreq
op_assign
id|pps_freq
suffix:semicolon
id|txc.jitter
op_assign
id|pps_jitter
suffix:semicolon
id|txc.shift
op_assign
id|pps_shift
suffix:semicolon
id|txc.stabil
op_assign
id|pps_stabil
suffix:semicolon
id|txc.jitcnt
op_assign
id|pps_jitcnt
suffix:semicolon
id|txc.calcnt
op_assign
id|pps_calcnt
suffix:semicolon
id|txc.errcnt
op_assign
id|pps_errcnt
suffix:semicolon
id|txc.stbcnt
op_assign
id|pps_stbcnt
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|txc_p
comma
op_amp
id|txc
comma
r_sizeof
(paren
r_struct
id|timex
)paren
)paren
suffix:semicolon
r_return
id|time_state
suffix:semicolon
)brace
eof
