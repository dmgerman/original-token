multiline_comment|/*&n; * linux/kernel/info.c&n; *&n; * Copyright (C) 1992 Darren Senn&n; */
multiline_comment|/* This implements the sysinfo() system call */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/swap.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|function|sys_sysinfo
id|asmlinkage
r_int
id|sys_sysinfo
c_func
(paren
r_struct
id|sysinfo
op_star
id|info
)paren
(brace
r_struct
id|sysinfo
id|val
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|val
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|sysinfo
)paren
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|val.uptime
op_assign
id|jiffies
op_div
id|HZ
suffix:semicolon
id|val.loads
(braket
l_int|0
)braket
op_assign
id|avenrun
(braket
l_int|0
)braket
op_lshift
(paren
id|SI_LOAD_SHIFT
op_minus
id|FSHIFT
)paren
suffix:semicolon
id|val.loads
(braket
l_int|1
)braket
op_assign
id|avenrun
(braket
l_int|1
)braket
op_lshift
(paren
id|SI_LOAD_SHIFT
op_minus
id|FSHIFT
)paren
suffix:semicolon
id|val.loads
(braket
l_int|2
)braket
op_assign
id|avenrun
(braket
l_int|2
)braket
op_lshift
(paren
id|SI_LOAD_SHIFT
op_minus
id|FSHIFT
)paren
suffix:semicolon
id|val.procs
op_assign
id|nr_threads
op_minus
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|si_meminfo
c_func
(paren
op_amp
id|val
)paren
suffix:semicolon
id|si_swapinfo
c_func
(paren
op_amp
id|val
)paren
suffix:semicolon
(brace
multiline_comment|/* If the sum of all the available memory (i.e. ram + swap +&n;&t;&t; * highmem) is less then can be stored in a 32 bit unsigned long&n;&t;&t; * then we can be binary compatible with 2.2.x kernels.  If not,&n;&t;&t; * well, who cares since in that case 2.2.x was broken anyways...&n;&t;&t; *&n;&t;&t; *  -Erik Andersen &lt;andersee@debian.org&gt; */
r_int
r_int
id|mem_total
op_assign
id|val.totalram
op_plus
id|val.totalswap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mem_total
OL
id|val.totalram
op_logical_or
id|mem_total
OL
id|val.totalswap
)paren
)paren
(brace
r_int
r_int
id|mem_total2
op_assign
id|mem_total
op_plus
id|val.totalhigh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mem_total2
OL
id|mem_total
op_logical_or
id|mem_total2
OL
id|val.totalhigh
)paren
)paren
(brace
multiline_comment|/* If mem_total did not overflow.  Divide all memory values by&n;&t;&t;&t;&t; * mem_unit and set mem_unit=1.  This leaves things compatible with&n;&t;&t;&t;&t; * 2.2.x, and also retains compatibility with earlier 2.4.x&n;&t;&t;&t;&t; * kernels...  */
r_int
id|bitcount
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|val.mem_unit
OG
l_int|1
)paren
(brace
id|bitcount
op_increment
suffix:semicolon
id|val.mem_unit
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|val.totalram
op_lshift_assign
id|bitcount
suffix:semicolon
id|val.freeram
op_lshift_assign
id|bitcount
suffix:semicolon
id|val.sharedram
op_lshift_assign
id|bitcount
suffix:semicolon
id|val.bufferram
op_lshift_assign
id|bitcount
suffix:semicolon
id|val.totalswap
op_lshift_assign
id|bitcount
suffix:semicolon
id|val.freeswap
op_lshift_assign
id|bitcount
suffix:semicolon
id|val.totalhigh
op_lshift_assign
id|bitcount
suffix:semicolon
id|val.freehigh
op_lshift_assign
id|bitcount
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|info
comma
op_amp
id|val
comma
r_sizeof
(paren
r_struct
id|sysinfo
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
