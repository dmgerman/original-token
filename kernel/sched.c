multiline_comment|/*&n; *  linux/kernel/sched.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; * &squot;sched.c&squot; is the main kernel file. It contains scheduling primitives&n; * (sleep_on, wakeup, schedule etc) as well as a number of simple system&n; * call functions (type getpid(), which just extracts a field from&n; * current-task&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sys.h&gt;
macro_line|#include &lt;linux/fdreg.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/segment.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
DECL|macro|TIMER_IRQ
mdefine_line|#define TIMER_IRQ 0
DECL|variable|need_resched
r_int
id|need_resched
op_assign
l_int|0
suffix:semicolon
DECL|variable|hard_math
r_int
id|hard_math
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set by boot/head.S */
DECL|variable|ignore_irq13
r_int
id|ignore_irq13
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set if exception 16 works */
r_extern
r_int
id|_setitimer
c_func
(paren
r_int
comma
r_struct
id|itimerval
op_star
comma
r_struct
id|itimerval
op_star
)paren
suffix:semicolon
DECL|variable|prof_buffer
r_int
r_int
op_star
id|prof_buffer
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|prof_len
r_int
r_int
id|prof_len
op_assign
l_int|0
suffix:semicolon
DECL|macro|_S
mdefine_line|#define _S(nr) (1&lt;&lt;((nr)-1))
DECL|macro|LATCH
mdefine_line|#define LATCH ((1193180 + HZ/2)/HZ)
r_extern
r_void
id|mem_use
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|timer_interrupt
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
l_string|&quot;C&quot;
r_int
id|system_call
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|init_kernel_stack
r_static
r_int
r_int
id|init_kernel_stack
(braket
l_int|1024
)braket
suffix:semicolon
DECL|variable|init_task
r_struct
id|task_struct
id|init_task
op_assign
id|INIT_TASK
suffix:semicolon
DECL|variable|jiffies
r_int
r_int
r_volatile
id|jiffies
op_assign
l_int|0
suffix:semicolon
DECL|variable|startup_time
r_int
r_int
id|startup_time
op_assign
l_int|0
suffix:semicolon
DECL|variable|jiffies_offset
r_int
id|jiffies_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* # clock ticks to add to get &quot;true&n;&t;&t;&t;&t;   time&quot;.  Should always be less than&n;&t;&t;&t;&t;   1 second&squot;s worth.  For time fanatics&n;&t;&t;&t;&t;   who like to syncronize their machines&n;&t;&t;&t;&t;   to WWV :-) */
DECL|variable|current
r_struct
id|task_struct
op_star
id|current
op_assign
op_amp
id|init_task
suffix:semicolon
DECL|variable|last_task_used_math
r_struct
id|task_struct
op_star
id|last_task_used_math
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|task
r_struct
id|task_struct
op_star
id|task
(braket
id|NR_TASKS
)braket
op_assign
(brace
op_amp
id|init_task
comma
)brace
suffix:semicolon
DECL|variable|user_stack
r_int
id|user_stack
(braket
id|PAGE_SIZE
op_rshift
l_int|2
)braket
suffix:semicolon
r_struct
(brace
DECL|member|a
r_int
op_star
id|a
suffix:semicolon
DECL|member|b
r_int
id|b
suffix:semicolon
DECL|variable|stack_start
)brace
id|stack_start
op_assign
(brace
op_amp
id|user_stack
(braket
id|PAGE_SIZE
op_rshift
l_int|2
)braket
comma
id|KERNEL_DS
)brace
suffix:semicolon
multiline_comment|/*&n; *  &squot;math_state_restore()&squot; saves the current math information in the&n; * old math state array, and gets the new ones from the current task&n; *&n; * Careful.. There are problems with IBM-designed IRQ13 behaviour.&n; * Don&squot;t touch unless you *really* know how it works.&n; */
DECL|function|math_state_restore
r_extern
l_string|&quot;C&quot;
r_void
id|math_state_restore
c_func
(paren
r_void
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;clts&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_task_used_math
op_eq
id|current
)paren
r_return
suffix:semicolon
id|timer_table
(braket
id|COPRO_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
l_int|50
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|COPRO_TIMER
suffix:semicolon
r_if
c_cond
(paren
id|last_task_used_math
)paren
id|__asm__
c_func
(paren
l_string|&quot;fnsave %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|last_task_used_math-&gt;tss.i387
)paren
)paren
suffix:semicolon
r_else
id|__asm__
c_func
(paren
l_string|&quot;fnclex&quot;
)paren
suffix:semicolon
id|last_task_used_math
op_assign
id|current
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;used_math
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;frstor %0&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
id|current-&gt;tss.i387
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|__asm__
c_func
(paren
l_string|&quot;fninit&quot;
)paren
suffix:semicolon
id|current-&gt;used_math
op_assign
l_int|1
suffix:semicolon
)brace
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|COPRO_TIMER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  &squot;schedule()&squot; is the scheduler function. It&squot;s a very simple and nice&n; * scheduler: it&squot;s not perfect, but certainly works for most things.&n; * The one thing you might take a look at is the signal-handler code here.&n; *&n; *   NOTE!!  Task 0 is the &squot;idle&squot; task, which gets called when no other&n; * tasks can run. It can not be killed, and it cannot sleep. The &squot;state&squot;&n; * information in task[0] is never used.&n; *&n; * The &quot;confuse_gcc&quot; goto is used only to get better assembly code..&n; * Djikstra probably hates me.&n; */
DECL|function|schedule
r_extern
l_string|&quot;C&quot;
r_void
id|schedule
c_func
(paren
r_void
)paren
(brace
r_int
id|c
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_struct
id|task_struct
op_star
id|next
suffix:semicolon
multiline_comment|/* check alarm, wake up any interruptible tasks that have got a signal */
id|sti
c_func
(paren
)paren
suffix:semicolon
id|need_resched
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
op_amp
id|init_task
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
id|p
op_assign
id|p-&gt;next_task
)paren
op_eq
op_amp
id|init_task
)paren
r_goto
id|confuse_gcc1
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;state
op_ne
id|TASK_INTERRUPTIBLE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;signal
op_amp
op_complement
id|p-&gt;blocked
)paren
(brace
id|p-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;timeout
op_logical_and
id|p-&gt;timeout
OL
id|jiffies
)paren
(brace
id|p-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|p-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
)brace
id|confuse_gcc1
suffix:colon
multiline_comment|/* this is the scheduler proper: */
id|c
op_assign
op_minus
l_int|1
suffix:semicolon
id|next
op_assign
id|p
op_assign
op_amp
id|init_task
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
id|p
op_assign
id|p-&gt;next_task
)paren
op_eq
op_amp
id|init_task
)paren
r_goto
id|confuse_gcc2
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;state
op_eq
id|TASK_RUNNING
op_logical_and
id|p-&gt;counter
OG
id|c
)paren
id|c
op_assign
id|p-&gt;counter
comma
id|next
op_assign
id|p
suffix:semicolon
)brace
id|confuse_gcc2
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
id|p
op_assign
op_amp
id|init_task
suffix:semicolon
r_while
c_loop
(paren
(paren
id|p
op_assign
id|p-&gt;next_task
)paren
op_ne
op_amp
id|init_task
)paren
id|p-&gt;counter
op_assign
(paren
id|p-&gt;counter
op_rshift
l_int|1
)paren
op_plus
id|p-&gt;priority
suffix:semicolon
)brace
id|switch_to
c_func
(paren
id|next
)paren
suffix:semicolon
)brace
DECL|function|sys_pause
r_extern
l_string|&quot;C&quot;
r_int
id|sys_pause
c_func
(paren
r_void
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTNOHAND
suffix:semicolon
)brace
multiline_comment|/*&n; * wake_up doesn&squot;t wake up stopped processes - they have to be awakened&n; * with signals or similar.&n; *&n; * Note that this doesn&squot;t need cli-sti pairs: interrupts may not change&n; * the wait-queue structures directly, but only call wake_up() to wake&n; * a process. The process itself must remove the queue once it has woken.&n; */
DECL|function|wake_up
r_void
id|wake_up
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|q
)paren
(brace
r_struct
id|wait_queue
op_star
id|tmp
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
op_logical_or
op_logical_neg
(paren
id|tmp
op_assign
op_star
id|q
)paren
)paren
r_return
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|p
op_assign
id|tmp-&gt;task
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|p-&gt;state
op_eq
id|TASK_UNINTERRUPTIBLE
)paren
op_logical_or
(paren
id|p-&gt;state
op_eq
id|TASK_INTERRUPTIBLE
)paren
)paren
(brace
id|p-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;counter
OG
id|current-&gt;counter
)paren
id|need_resched
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmp-&gt;next
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;wait_queue is bad (eip = %08x)&bslash;n&quot;
comma
(paren
(paren
r_int
r_int
op_star
)paren
id|q
)paren
(braket
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        q = %08x&bslash;n&quot;
comma
id|q
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;       *q = %08x&bslash;n&quot;
comma
op_star
id|q
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;      tmp = %08x&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
op_star
id|q
)paren
suffix:semicolon
)brace
DECL|function|wake_up_interruptible
r_void
id|wake_up_interruptible
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|q
)paren
(brace
r_struct
id|wait_queue
op_star
id|tmp
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
op_logical_or
op_logical_neg
(paren
id|tmp
op_assign
op_star
id|q
)paren
)paren
r_return
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|p
op_assign
id|tmp-&gt;task
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;state
op_eq
id|TASK_INTERRUPTIBLE
)paren
(brace
id|p-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;counter
OG
id|current-&gt;counter
)paren
id|need_resched
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmp-&gt;next
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;wait_queue is bad (eip = %08x)&bslash;n&quot;
comma
(paren
(paren
r_int
r_int
op_star
)paren
id|q
)paren
(braket
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        q = %08x&bslash;n&quot;
comma
id|q
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;       *q = %08x&bslash;n&quot;
comma
op_star
id|q
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;      tmp = %08x&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
op_star
id|q
)paren
suffix:semicolon
)brace
DECL|function|__sleep_on
r_static
r_inline
r_void
id|__sleep_on
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|p
comma
r_int
id|state
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|current
op_eq
id|task
(braket
l_int|0
)braket
)paren
id|panic
c_func
(paren
l_string|&quot;task[0] trying to sleep&quot;
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|state
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|p
comma
op_amp
id|wait
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|p
comma
op_amp
id|wait
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|interruptible_sleep_on
r_void
id|interruptible_sleep_on
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|p
)paren
(brace
id|__sleep_on
c_func
(paren
id|p
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
)brace
DECL|function|sleep_on
r_void
id|sleep_on
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|p
)paren
(brace
id|__sleep_on
c_func
(paren
id|p
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
)brace
DECL|variable|next_timer
r_static
r_struct
id|timer_list
op_star
id|next_timer
op_assign
l_int|NULL
suffix:semicolon
DECL|function|add_timer
r_void
id|add_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|timer_list
op_star
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timer
)paren
r_return
suffix:semicolon
id|timer-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|p
op_assign
op_amp
id|next_timer
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|expires
OG
id|timer-&gt;expires
)paren
(brace
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|expires
op_sub_assign
id|timer-&gt;expires
suffix:semicolon
id|timer-&gt;next
op_assign
op_star
id|p
suffix:semicolon
r_break
suffix:semicolon
)brace
id|timer-&gt;expires
op_sub_assign
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|expires
suffix:semicolon
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
op_star
id|p
op_assign
id|timer
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|del_timer
r_void
id|del_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|timer_list
op_star
op_star
id|p
suffix:semicolon
id|p
op_assign
op_amp
id|next_timer
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
op_star
id|p
op_eq
id|timer
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|p
op_assign
id|timer-&gt;next
)paren
op_ne
l_int|NULL
)paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|expires
op_add_assign
id|timer-&gt;expires
suffix:semicolon
r_break
suffix:semicolon
)brace
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|variable|timer_active
r_int
r_int
id|timer_active
op_assign
l_int|0
suffix:semicolon
DECL|variable|timer_table
r_struct
id|timer_struct
id|timer_table
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/*&n; * Hmm.. Changed this, as the GNU make sources (load.c) seems to&n; * imply that avenrun[] is the standard name for this kind of thing.&n; * Nothing else seems to be standardized: the fractional size etc&n; * all seem to differ on different machines.&n; */
DECL|variable|avenrun
r_int
r_int
id|avenrun
(braket
l_int|3
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * Nr of active tasks - counted in fixed-point numbers&n; */
DECL|function|count_active_tasks
r_static
r_int
r_int
id|count_active_tasks
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
op_star
id|p
suffix:semicolon
r_int
r_int
id|nr
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|LAST_TASK
suffix:semicolon
id|p
OG
op_amp
id|FIRST_TASK
suffix:semicolon
op_decrement
id|p
)paren
r_if
c_cond
(paren
op_star
id|p
op_logical_and
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|state
op_eq
id|TASK_RUNNING
)paren
id|nr
op_add_assign
id|FIXED_1
suffix:semicolon
r_return
id|nr
suffix:semicolon
)brace
DECL|function|calc_load
r_static
r_inline
r_void
id|calc_load
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|active_tasks
suffix:semicolon
multiline_comment|/* fixed-point */
r_static
r_int
id|count
op_assign
id|LOAD_FREQ
suffix:semicolon
r_if
c_cond
(paren
id|count
op_decrement
OG
l_int|0
)paren
r_return
suffix:semicolon
id|count
op_assign
id|LOAD_FREQ
suffix:semicolon
id|active_tasks
op_assign
id|count_active_tasks
c_func
(paren
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|0
)braket
comma
id|EXP_1
comma
id|active_tasks
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|1
)braket
comma
id|EXP_5
comma
id|active_tasks
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|2
)braket
comma
id|EXP_15
comma
id|active_tasks
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The int argument is really a (struct pt_regs *), in case the&n; * interrupt wants to know from where it was called. The timer&n; * irq uses this to decide if it should update the user or system&n; * times.&n; */
DECL|function|do_timer
r_static
r_void
id|do_timer
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_struct
id|timer_struct
op_star
id|tp
op_assign
id|timer_table
op_plus
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
op_star
id|task_p
suffix:semicolon
id|jiffies
op_increment
suffix:semicolon
id|calc_load
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|VM_MASK
op_amp
id|regs-&gt;eflags
)paren
op_logical_or
(paren
l_int|3
op_amp
id|regs-&gt;cs
)paren
)paren
(brace
id|current-&gt;utime
op_increment
suffix:semicolon
multiline_comment|/* Update ITIMER_VIRT for current task if not in a system call */
r_if
c_cond
(paren
id|current-&gt;it_virt_value
op_logical_and
op_logical_neg
(paren
op_decrement
id|current-&gt;it_virt_value
)paren
)paren
(brace
id|current-&gt;it_virt_value
op_assign
id|current-&gt;it_virt_incr
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGVTALRM
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|current-&gt;stime
op_increment
suffix:semicolon
macro_line|#ifdef CONFIG_PROFILE
r_if
c_cond
(paren
id|prof_buffer
op_logical_and
id|current
op_ne
id|task
(braket
l_int|0
)braket
)paren
(brace
r_int
r_int
id|eip
op_assign
id|regs-&gt;eip
suffix:semicolon
id|eip
op_rshift_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|eip
OL
id|prof_len
)paren
id|prof_buffer
(braket
id|eip
)braket
op_increment
suffix:semicolon
)brace
macro_line|#endif
)brace
r_if
c_cond
(paren
id|current
op_eq
id|task
(braket
l_int|0
)braket
op_logical_or
(paren
op_decrement
id|current-&gt;counter
)paren
op_le
l_int|0
)paren
(brace
id|current-&gt;counter
op_assign
l_int|0
suffix:semicolon
id|need_resched
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Update ITIMER_REAL for every task */
r_for
c_loop
(paren
id|task_p
op_assign
op_amp
id|LAST_TASK
suffix:semicolon
id|task_p
op_ge
op_amp
id|FIRST_TASK
suffix:semicolon
id|task_p
op_decrement
)paren
r_if
c_cond
(paren
op_star
id|task_p
op_logical_and
(paren
op_star
id|task_p
)paren
op_member_access_from_pointer
id|it_real_value
op_logical_and
op_logical_neg
(paren
op_decrement
(paren
op_star
id|task_p
)paren
op_member_access_from_pointer
id|it_real_value
)paren
)paren
(brace
id|send_sig
c_func
(paren
id|SIGALRM
comma
op_star
id|task_p
comma
l_int|1
)paren
suffix:semicolon
(paren
op_star
id|task_p
)paren
op_member_access_from_pointer
id|it_real_value
op_assign
(paren
op_star
id|task_p
)paren
op_member_access_from_pointer
id|it_real_incr
suffix:semicolon
id|need_resched
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Update ITIMER_PROF for the current task */
r_if
c_cond
(paren
id|current-&gt;it_prof_value
op_logical_and
op_logical_neg
(paren
op_decrement
id|current-&gt;it_prof_value
)paren
)paren
(brace
id|current-&gt;it_prof_value
op_assign
id|current-&gt;it_prof_incr
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGPROF
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|mask
op_assign
l_int|1
suffix:semicolon
id|mask
suffix:semicolon
id|tp
op_increment
comma
id|mask
op_add_assign
id|mask
)paren
(brace
r_if
c_cond
(paren
id|mask
OG
id|timer_active
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mask
op_amp
id|timer_active
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;expires
OG
id|jiffies
)paren
r_continue
suffix:semicolon
id|timer_active
op_and_assign
op_complement
id|mask
suffix:semicolon
id|tp
op_member_access_from_pointer
id|fn
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|next_timer
op_logical_and
id|next_timer-&gt;expires
op_eq
l_int|0
)paren
(brace
r_void
(paren
op_star
id|fn
)paren
(paren
r_int
r_int
)paren
op_assign
id|next_timer-&gt;function
suffix:semicolon
r_int
r_int
id|data
op_assign
id|next_timer-&gt;data
suffix:semicolon
id|next_timer
op_assign
id|next_timer-&gt;next
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|fn
c_func
(paren
id|data
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|next_timer
)paren
id|next_timer-&gt;expires
op_decrement
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|sys_alarm
r_extern
l_string|&quot;C&quot;
r_int
id|sys_alarm
c_func
(paren
r_int
id|seconds
)paren
(brace
r_struct
id|itimerval
id|it_new
comma
id|it_old
suffix:semicolon
id|it_new.it_interval.tv_sec
op_assign
id|it_new.it_interval.tv_usec
op_assign
l_int|0
suffix:semicolon
id|it_new.it_value.tv_sec
op_assign
id|seconds
suffix:semicolon
id|it_new.it_value.tv_usec
op_assign
l_int|0
suffix:semicolon
id|_setitimer
c_func
(paren
id|ITIMER_REAL
comma
op_amp
id|it_new
comma
op_amp
id|it_old
)paren
suffix:semicolon
r_return
id|it_old.it_value.tv_sec
op_plus
(paren
id|it_old.it_value.tv_usec
op_div
l_int|1000000
)paren
suffix:semicolon
)brace
DECL|function|sys_getpid
r_extern
l_string|&quot;C&quot;
r_int
id|sys_getpid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;pid
suffix:semicolon
)brace
DECL|function|sys_getppid
r_extern
l_string|&quot;C&quot;
r_int
id|sys_getppid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;p_pptr-&gt;pid
suffix:semicolon
)brace
DECL|function|sys_getuid
r_extern
l_string|&quot;C&quot;
r_int
id|sys_getuid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;uid
suffix:semicolon
)brace
DECL|function|sys_geteuid
r_extern
l_string|&quot;C&quot;
r_int
id|sys_geteuid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;euid
suffix:semicolon
)brace
DECL|function|sys_getgid
r_extern
l_string|&quot;C&quot;
r_int
id|sys_getgid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;gid
suffix:semicolon
)brace
DECL|function|sys_getegid
r_extern
l_string|&quot;C&quot;
r_int
id|sys_getegid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;egid
suffix:semicolon
)brace
DECL|function|sys_nice
r_extern
l_string|&quot;C&quot;
r_int
id|sys_nice
c_func
(paren
r_int
id|increment
)paren
(brace
r_int
id|newprio
suffix:semicolon
r_if
c_cond
(paren
id|increment
OL
l_int|0
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|newprio
op_assign
id|current-&gt;priority
op_minus
id|increment
suffix:semicolon
r_if
c_cond
(paren
id|newprio
OL
l_int|1
)paren
id|newprio
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|newprio
OG
l_int|35
)paren
id|newprio
op_assign
l_int|35
suffix:semicolon
id|current-&gt;priority
op_assign
id|newprio
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|show_task
r_static
r_void
id|show_task
c_func
(paren
r_int
id|nr
comma
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_int
r_char
op_star
id|stack
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d: pid=%d, state=%d, father=%d, child=%d, &quot;
comma
(paren
id|p
op_eq
id|current
)paren
ques
op_minus
id|nr
suffix:colon
id|nr
comma
id|p-&gt;pid
comma
id|p-&gt;state
comma
id|p-&gt;p_pptr-&gt;pid
comma
id|p-&gt;p_cptr
ques
c_cond
id|p-&gt;p_cptr-&gt;pid
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|j
op_assign
l_int|4096
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|stack
op_assign
(paren
r_int
r_char
op_star
)paren
id|p-&gt;kernel_stack_page
)paren
)paren
(brace
id|stack
op_assign
(paren
r_int
r_char
op_star
)paren
id|init_kernel_stack
suffix:semicolon
id|j
op_assign
r_sizeof
(paren
id|init_kernel_stack
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OL
id|j
op_logical_and
op_logical_neg
op_star
(paren
id|stack
op_increment
)paren
)paren
id|i
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d/%d chars free in kstack&bslash;n&quot;
comma
id|i
comma
id|j
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   PC=%08X.&quot;
comma
op_star
(paren
l_int|1019
op_plus
(paren
r_int
r_int
op_star
)paren
id|p
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;p_ysptr
op_logical_or
id|p-&gt;p_osptr
)paren
id|printk
c_func
(paren
l_string|&quot;   Younger sib=%d, older sib=%d&bslash;n&quot;
comma
id|p-&gt;p_ysptr
ques
c_cond
id|p-&gt;p_ysptr-&gt;pid
suffix:colon
op_minus
l_int|1
comma
id|p-&gt;p_osptr
ques
c_cond
id|p-&gt;p_osptr-&gt;pid
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|show_state
r_void
id|show_state
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Task-info:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_TASKS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|task
(braket
id|i
)braket
)paren
id|show_task
c_func
(paren
id|i
comma
id|task
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|function|sched_init
r_void
id|sched_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|desc_struct
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|sigaction
)paren
op_ne
l_int|16
)paren
id|panic
c_func
(paren
l_string|&quot;Struct sigaction MUST be 16 bytes&quot;
)paren
suffix:semicolon
id|set_tss_desc
c_func
(paren
id|gdt
op_plus
id|FIRST_TSS_ENTRY
comma
op_amp
id|init_task.tss
)paren
suffix:semicolon
id|set_ldt_desc
c_func
(paren
id|gdt
op_plus
id|FIRST_LDT_ENTRY
comma
op_amp
id|init_task.ldt
)paren
suffix:semicolon
id|set_system_gate
c_func
(paren
l_int|0x80
comma
op_amp
id|system_call
)paren
suffix:semicolon
id|p
op_assign
id|gdt
op_plus
l_int|2
op_plus
id|FIRST_TSS_ENTRY
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|NR_TASKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|task
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;a
op_assign
id|p-&gt;b
op_assign
l_int|0
suffix:semicolon
id|p
op_increment
suffix:semicolon
id|p-&gt;a
op_assign
id|p-&gt;b
op_assign
l_int|0
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
multiline_comment|/* Clear NT, so that we won&squot;t have troubles with that later on */
id|__asm__
c_func
(paren
l_string|&quot;pushfl ; andl $0xffffbfff,(%esp) ; popfl&quot;
)paren
suffix:semicolon
id|load_TR
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|load_ldt
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x34
comma
l_int|0x43
)paren
suffix:semicolon
multiline_comment|/* binary, mode 2, LSB/MSB, ch 0 */
id|outb_p
c_func
(paren
id|LATCH
op_amp
l_int|0xff
comma
l_int|0x40
)paren
suffix:semicolon
multiline_comment|/* LSB */
id|outb
c_func
(paren
id|LATCH
op_rshift
l_int|8
comma
l_int|0x40
)paren
suffix:semicolon
multiline_comment|/* MSB */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|TIMER_IRQ
comma
(paren
r_void
(paren
op_star
)paren
(paren
r_int
)paren
)paren
id|do_timer
)paren
op_ne
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Could not allocate timer IRQ!&quot;
)paren
suffix:semicolon
)brace
eof
