multiline_comment|/*&n; *  linux/kernel/sched.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; *&n; *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and&n; *              make semaphores SMP safe&n; *  1997-01-28  Modified by Finn Arne Gangstad to make timers scale better.&n; *  1997-09-10&t;Updated NTP code according to technical memorandum Jan &squot;96&n; *&t;&t;&quot;A Kernel Model for Precision Timekeeping&quot; by Dave Mills&n; *  1998-11-19&t;Implemented schedule_timeout() and related stuff&n; *&t;&t;by Andrea Arcangeli&n; *  1998-12-24&t;Fixed a xtime SMP race (we need the xtime_lock rw spinlock to&n; *&t;&t;serialize accesses to xtime/lost_ticks).&n; *&t;&t;&t;&t;Copyright (C) 1998  Andrea Arcangeli&n; *  1998-12-28  Implemented better SMP scheduling by Ingo Molnar&n; *  1999-03-10&t;Improved NTP compatibility by Ulrich Windl&n; */
multiline_comment|/*&n; * &squot;sched.c&squot; is the main kernel file. It contains scheduling primitives&n; * (sleep_on, wakeup, schedule etc) as well as a number of simple system&n; * call functions (type getpid()), which just extract a field from&n; * current-task&n; */
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/fdreg.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
macro_line|#include &lt;asm/semaphore-helper.h&gt;
macro_line|#include &lt;linux/timex.h&gt;
multiline_comment|/*&n; * kernel variables&n; */
DECL|variable|securebits
r_int
id|securebits
op_assign
id|SECUREBITS_DEFAULT
suffix:semicolon
multiline_comment|/* systemwide security settings */
DECL|variable|tick
r_int
id|tick
op_assign
(paren
l_int|1000000
op_plus
id|HZ
op_div
l_int|2
)paren
op_div
id|HZ
suffix:semicolon
multiline_comment|/* timer interrupt period */
multiline_comment|/* The current time */
DECL|variable|xtime
r_volatile
r_struct
id|timeval
id|xtime
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|16
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t completely fail for HZ &gt; 500.  */
DECL|variable|tickadj
r_int
id|tickadj
op_assign
l_int|500
op_div
id|HZ
ques
c_cond
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* microsecs */
DECL|variable|tq_timer
id|DECLARE_TASK_QUEUE
c_func
(paren
id|tq_timer
)paren
suffix:semicolon
DECL|variable|tq_immediate
id|DECLARE_TASK_QUEUE
c_func
(paren
id|tq_immediate
)paren
suffix:semicolon
DECL|variable|tq_scheduler
id|DECLARE_TASK_QUEUE
c_func
(paren
id|tq_scheduler
)paren
suffix:semicolon
multiline_comment|/*&n; * phase-lock loop variables&n; */
multiline_comment|/* TIME_ERROR prevents overwriting the CMOS clock */
DECL|variable|time_state
r_int
id|time_state
op_assign
id|TIME_OK
suffix:semicolon
multiline_comment|/* clock synchronization status */
DECL|variable|time_status
r_int
id|time_status
op_assign
id|STA_UNSYNC
suffix:semicolon
multiline_comment|/* clock status bits */
DECL|variable|time_offset
r_int
id|time_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* time adjustment (us) */
DECL|variable|time_constant
r_int
id|time_constant
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* pll time constant */
DECL|variable|time_tolerance
r_int
id|time_tolerance
op_assign
id|MAXFREQ
suffix:semicolon
multiline_comment|/* frequency tolerance (ppm) */
DECL|variable|time_precision
r_int
id|time_precision
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* clock precision (us) */
DECL|variable|time_maxerror
r_int
id|time_maxerror
op_assign
id|NTP_PHASE_LIMIT
suffix:semicolon
multiline_comment|/* maximum error (us) */
DECL|variable|time_esterror
r_int
id|time_esterror
op_assign
id|NTP_PHASE_LIMIT
suffix:semicolon
multiline_comment|/* estimated error (us) */
DECL|variable|time_phase
r_int
id|time_phase
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* phase offset (scaled us) */
DECL|variable|time_freq
r_int
id|time_freq
op_assign
(paren
(paren
l_int|1000000
op_plus
id|HZ
op_div
l_int|2
)paren
op_mod
id|HZ
op_minus
id|HZ
op_div
l_int|2
)paren
op_lshift
id|SHIFT_USEC
suffix:semicolon
multiline_comment|/* frequency offset (scaled ppm) */
DECL|variable|time_adj
r_int
id|time_adj
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* tick adjust (scaled 1 / HZ) */
DECL|variable|time_reftime
r_int
id|time_reftime
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* time at last adjustment (s) */
DECL|variable|time_adjust
r_int
id|time_adjust
op_assign
l_int|0
suffix:semicolon
DECL|variable|time_adjust_step
r_int
id|time_adjust_step
op_assign
l_int|0
suffix:semicolon
DECL|variable|event
r_int
r_int
id|event
op_assign
l_int|0
suffix:semicolon
r_extern
r_int
id|do_setitimer
c_func
(paren
r_int
comma
r_struct
id|itimerval
op_star
comma
r_struct
id|itimerval
op_star
)paren
suffix:semicolon
DECL|variable|prof_buffer
r_int
r_int
op_star
id|prof_buffer
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|prof_len
r_int
r_int
id|prof_len
op_assign
l_int|0
suffix:semicolon
DECL|variable|prof_shift
r_int
r_int
id|prof_shift
op_assign
l_int|0
suffix:semicolon
r_extern
r_void
id|mem_use
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|jiffies
r_int
r_int
r_volatile
id|jiffies
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; *&t;Init task must be ok at boot for the ix86 as we will check its signals&n; *&t;via the SMP irq return path.&n; */
DECL|variable|init_tasks
r_struct
id|task_struct
op_star
id|init_tasks
(braket
id|NR_CPUS
)braket
op_assign
(brace
op_amp
id|init_task
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * The tasklist_lock protects the linked list of processes.&n; *&n; * The scheduler lock is protecting against multiple entry&n; * into the scheduling code, and doesn&squot;t need to worry&n; * about interrupts (because interrupts cannot call the&n; * scheduler).&n; *&n; * The run-queue lock locks the parts that actually access&n; * and change the run-queues, and have to be interrupt-safe.&n; */
DECL|variable|runqueue_lock
id|spinlock_t
id|runqueue_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* second */
DECL|variable|tasklist_lock
id|rwlock_t
id|tasklist_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* third */
r_static
id|LIST_HEAD
c_func
(paren
id|runqueue_head
)paren
suffix:semicolon
multiline_comment|/*&n; * We align per-CPU scheduling data on cacheline boundaries,&n; * to prevent cacheline ping-pong.&n; */
r_static
r_union
(brace
DECL|struct|schedule_data
r_struct
id|schedule_data
(brace
DECL|member|curr
r_struct
id|task_struct
op_star
id|curr
suffix:semicolon
DECL|member|last_schedule
id|cycles_t
id|last_schedule
suffix:semicolon
DECL|member|schedule_data
)brace
id|schedule_data
suffix:semicolon
DECL|member|__pad
r_char
id|__pad
(braket
id|SMP_CACHE_BYTES
)braket
suffix:semicolon
DECL|variable|__cacheline_aligned
)brace
id|aligned_data
(braket
id|NR_CPUS
)braket
id|__cacheline_aligned
op_assign
(brace
(brace
(brace
op_amp
id|init_task
comma
l_int|0
)brace
)brace
)brace
suffix:semicolon
DECL|macro|cpu_curr
mdefine_line|#define cpu_curr(cpu) aligned_data[(cpu)].schedule_data.curr
DECL|variable|kstat
r_struct
id|kernel_stat
id|kstat
op_assign
(brace
l_int|0
)brace
suffix:semicolon
macro_line|#ifdef __SMP__
DECL|macro|idle_task
mdefine_line|#define idle_task(cpu) (init_tasks[cpu_number_map[(cpu)]])
DECL|macro|can_schedule
mdefine_line|#define can_schedule(p)&t;(!(p)-&gt;has_cpu)
macro_line|#else
DECL|macro|idle_task
mdefine_line|#define idle_task(cpu) (&amp;init_task)
DECL|macro|can_schedule
mdefine_line|#define can_schedule(p) (1)
macro_line|#endif
DECL|function|scheduling_functions_start_here
r_void
id|scheduling_functions_start_here
c_func
(paren
r_void
)paren
(brace
)brace
multiline_comment|/*&n; * This is the function that decides how desirable a process is..&n; * You can weigh different processes against each other depending&n; * on what CPU they&squot;ve run on lately etc to try to handle cache&n; * and TLB miss penalties.&n; *&n; * Return values:&n; *&t; -1000: never select this&n; *&t;     0: out of time, recalculate counters (but it might still be&n; *&t;&t;selected)&n; *&t;   +ve: &quot;goodness&quot; value (the larger, the better)&n; *&t; +1000: realtime process, select this.&n; */
DECL|function|goodness
r_static
r_inline
r_int
id|goodness
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
id|this_cpu
comma
r_struct
id|mm_struct
op_star
id|this_mm
)paren
(brace
r_int
id|weight
suffix:semicolon
multiline_comment|/*&n;&t; * Realtime process, select the first one on the&n;&t; * runqueue (taking priorities within processes&n;&t; * into account).&n;&t; */
r_if
c_cond
(paren
id|p-&gt;policy
op_ne
id|SCHED_OTHER
)paren
(brace
id|weight
op_assign
l_int|1000
op_plus
id|p-&gt;rt_priority
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Give the process a first-approximation goodness value&n;&t; * according to the number of clock-ticks it has left.&n;&t; *&n;&t; * Don&squot;t do any other calculations if the time slice is&n;&t; * over..&n;&t; */
id|weight
op_assign
id|p-&gt;counter
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|weight
)paren
r_goto
id|out
suffix:semicolon
macro_line|#ifdef __SMP__
multiline_comment|/* Give a largish advantage to the same processor...   */
multiline_comment|/* (this is equivalent to penalizing other processors) */
r_if
c_cond
(paren
id|p-&gt;processor
op_eq
id|this_cpu
)paren
id|weight
op_add_assign
id|PROC_CHANGE_PENALTY
suffix:semicolon
macro_line|#endif
multiline_comment|/* .. and a slight advantage to the current MM */
r_if
c_cond
(paren
id|p-&gt;mm
op_eq
id|this_mm
)paren
id|weight
op_add_assign
l_int|1
suffix:semicolon
id|weight
op_add_assign
id|p-&gt;priority
suffix:semicolon
id|out
suffix:colon
r_return
id|weight
suffix:semicolon
)brace
multiline_comment|/*&n; * subtle. We want to discard a yielded process only if it&squot;s being&n; * considered for a reschedule. Wakeup-time &squot;queries&squot; of the scheduling&n; * state do not count. Another optimization we do: sched_yield()-ed&n; * processes are runnable (and thus will be considered for scheduling)&n; * right when they are calling schedule(). So the only place we need&n; * to care about SCHED_YIELD is when we calculate the previous process&squot;&n; * goodness ...&n; */
DECL|function|prev_goodness
r_static
r_inline
r_int
id|prev_goodness
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
id|this_cpu
comma
r_struct
id|mm_struct
op_star
id|this_mm
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;policy
op_amp
id|SCHED_YIELD
)paren
(brace
id|p-&gt;policy
op_and_assign
op_complement
id|SCHED_YIELD
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|goodness
c_func
(paren
id|p
comma
id|this_cpu
comma
id|this_mm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * the &squot;goodness value&squot; of replacing a process on a given CPU.&n; * positive value means &squot;replace&squot;, zero or negative means &squot;dont&squot;.&n; */
DECL|function|preemption_goodness
r_static
r_inline
r_int
id|preemption_goodness
c_func
(paren
r_struct
id|task_struct
op_star
id|prev
comma
r_struct
id|task_struct
op_star
id|p
comma
r_int
id|cpu
)paren
(brace
r_return
id|goodness
c_func
(paren
id|p
comma
id|cpu
comma
id|prev-&gt;mm
)paren
op_minus
id|goodness
c_func
(paren
id|prev
comma
id|cpu
comma
id|prev-&gt;mm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If there is a dependency between p1 and p2,&n; * don&squot;t be too eager to go into the slow schedule.&n; * In particular, if p1 and p2 both want the kernel&n; * lock, there is no point in trying to make them&n; * extremely parallel..&n; *&n; * (No lock - lock_depth &lt; 0)&n; *&n; * There are two additional metrics here:&n; *&n; * first, a &squot;cutoff&squot; interval, currently 0-200 usecs on&n; * x86 CPUs, depending on the size of the &squot;SMP-local cache&squot;.&n; * If the current process has longer average timeslices than&n; * this, then we utilize the idle CPU.&n; *&n; * second, if the wakeup comes from a process context,&n; * then the two processes are &squot;related&squot;. (they form a&n; * &squot;gang&squot;)&n; *&n; * An idle CPU is almost always a bad thing, thus we skip&n; * the idle-CPU utilization only if both these conditions&n; * are true. (ie. a &squot;process-gang&squot; rescheduling with rather&n; * high frequency should stay on the same CPU).&n; *&n; * [We can switch to something more finegrained in 2.3.]&n; *&n; * do not &squot;guess&squot; if the to-be-scheduled task is RT.&n; */
DECL|macro|related
mdefine_line|#define related(p1,p2) (((p1)-&gt;lock_depth &gt;= 0) &amp;&amp; (p2)-&gt;lock_depth &gt;= 0) &amp;&amp; &bslash;&n;&t;(((p2)-&gt;policy == SCHED_OTHER) &amp;&amp; ((p1)-&gt;avg_slice &lt; cacheflush_time))
DECL|function|reschedule_idle_slow
r_static
r_inline
r_void
id|reschedule_idle_slow
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
macro_line|#ifdef __SMP__
multiline_comment|/*&n; * (see reschedule_idle() for an explanation first ...)&n; *&n; * Pass #2&n; *&n; * We try to find another (idle) CPU for this woken-up process.&n; *&n; * On SMP, we mostly try to see if the CPU the task used&n; * to run on is idle.. but we will use another idle CPU too,&n; * at this point we already know that this CPU is not&n; * willing to reschedule in the near future.&n; *&n; * An idle CPU is definitely wasted, especially if this CPU is&n; * running long-timeslice processes. The following algorithm is&n; * pretty good at finding the best idle CPU to send this process&n; * to.&n; *&n; * [We can try to preempt low-priority processes on other CPUs in&n; * 2.3. Also we can try to use the avg_slice value to predict&n; * &squot;likely reschedule&squot; events even on other CPUs.]&n; */
r_int
id|this_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
comma
id|target_cpu
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
comma
op_star
id|target_tsk
suffix:semicolon
r_int
id|cpu
comma
id|best_cpu
comma
id|weight
comma
id|best_weight
comma
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|best_weight
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* prevents negative weight */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|runqueue_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * shortcut if the woken up task&squot;s last CPU is&n;&t; * idle now.&n;&t; */
id|best_cpu
op_assign
id|p-&gt;processor
suffix:semicolon
id|target_tsk
op_assign
id|idle_task
c_func
(paren
id|best_cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_curr
c_func
(paren
id|best_cpu
)paren
op_eq
id|target_tsk
)paren
r_goto
id|send_now
suffix:semicolon
id|target_tsk
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cpu
op_assign
id|cpu_logical_map
c_func
(paren
id|i
)paren
suffix:semicolon
id|tsk
op_assign
id|cpu_curr
c_func
(paren
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|related
c_func
(paren
id|tsk
comma
id|p
)paren
)paren
r_goto
id|out_no_target
suffix:semicolon
id|weight
op_assign
id|preemption_goodness
c_func
(paren
id|tsk
comma
id|p
comma
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|weight
OG
id|best_weight
)paren
(brace
id|best_weight
op_assign
id|weight
suffix:semicolon
id|target_tsk
op_assign
id|tsk
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * found any suitable CPU?&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|target_tsk
)paren
r_goto
id|out_no_target
suffix:semicolon
id|send_now
suffix:colon
id|target_cpu
op_assign
id|target_tsk-&gt;processor
suffix:semicolon
id|target_tsk-&gt;need_resched
op_assign
l_int|1
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|runqueue_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * the APIC stuff can go outside of the lock because&n;&t; * it uses no task information, only CPU#.&n;&t; */
r_if
c_cond
(paren
id|target_cpu
op_ne
id|this_cpu
)paren
id|smp_send_reschedule
c_func
(paren
id|target_cpu
)paren
suffix:semicolon
r_return
suffix:semicolon
id|out_no_target
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|runqueue_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#else /* UP */
r_int
id|this_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
suffix:semicolon
id|tsk
op_assign
id|cpu_curr
c_func
(paren
id|this_cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|preemption_goodness
c_func
(paren
id|tsk
comma
id|p
comma
id|this_cpu
)paren
OG
l_int|0
)paren
id|tsk-&gt;need_resched
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
)brace
DECL|function|reschedule_idle
r_static
r_void
id|reschedule_idle
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
macro_line|#ifdef __SMP__
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * (&quot;wakeup()&quot; should not be called before we&squot;ve initialized&n;&t; * SMP completely.&n;&t; * Basically a not-yet initialized SMP subsystem can be&n;&t; * considered as a not-yet working scheduler, simply dont use&n;&t; * it before it&squot;s up and running ...)&n;&t; *&n;&t; * SMP rescheduling is done in 2 passes:&n;&t; *  - pass #1: faster: &squot;quick decisions&squot;&n;&t; *  - pass #2: slower: &squot;lets try and find a suitable CPU&squot;&n;&t; */
multiline_comment|/*&n;&t; * Pass #1. (subtle. We might be in the middle of __switch_to, so&n;&t; * to preserve scheduling atomicity we have to use cpu_curr)&n;&t; */
r_if
c_cond
(paren
(paren
id|p-&gt;processor
op_eq
id|cpu
)paren
op_logical_and
id|related
c_func
(paren
id|cpu_curr
c_func
(paren
id|cpu
)paren
comma
id|p
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif /* __SMP__ */
multiline_comment|/*&n;&t; * Pass #2&n;&t; */
id|reschedule_idle_slow
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Careful!&n; *&n; * This has to add the process to the _beginning_ of the&n; * run-queue, not the end. See the comment about &quot;This is&n; * subtle&quot; in the scheduler proper..&n; */
DECL|function|add_to_runqueue
r_static
r_inline
r_void
id|add_to_runqueue
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|p-&gt;run_list
comma
op_amp
id|runqueue_head
)paren
suffix:semicolon
id|nr_running
op_increment
suffix:semicolon
)brace
DECL|function|move_last_runqueue
r_static
r_inline
r_void
id|move_last_runqueue
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|p-&gt;run_list
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|p-&gt;run_list
comma
op_amp
id|runqueue_head
)paren
suffix:semicolon
)brace
DECL|function|move_first_runqueue
r_static
r_inline
r_void
id|move_first_runqueue
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|p-&gt;run_list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|p-&gt;run_list
comma
op_amp
id|runqueue_head
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wake up a process. Put it on the run-queue if it&squot;s not&n; * already there.  The &quot;current&quot; process is always on the&n; * run-queue (except when the actual re-schedule is in&n; * progress), and as such you&squot;re allowed to do the simpler&n; * &quot;current-&gt;state = TASK_RUNNING&quot; to mark yourself runnable&n; * without the overhead of this.&n; */
DECL|function|wake_up_process
r_void
id|wake_up_process
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * We want the common case fall through straight, thus the goto.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|runqueue_lock
comma
id|flags
)paren
suffix:semicolon
id|p-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|task_on_runqueue
c_func
(paren
id|p
)paren
)paren
r_goto
id|out
suffix:semicolon
id|add_to_runqueue
c_func
(paren
id|p
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|runqueue_lock
comma
id|flags
)paren
suffix:semicolon
id|reschedule_idle
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|runqueue_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|process_timeout
r_static
r_void
id|process_timeout
c_func
(paren
r_int
r_int
id|__data
)paren
(brace
r_struct
id|task_struct
op_star
id|p
op_assign
(paren
r_struct
id|task_struct
op_star
)paren
id|__data
suffix:semicolon
id|wake_up_process
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Event timer code&n; */
DECL|macro|TVN_BITS
mdefine_line|#define TVN_BITS 6
DECL|macro|TVR_BITS
mdefine_line|#define TVR_BITS 8
DECL|macro|TVN_SIZE
mdefine_line|#define TVN_SIZE (1 &lt;&lt; TVN_BITS)
DECL|macro|TVR_SIZE
mdefine_line|#define TVR_SIZE (1 &lt;&lt; TVR_BITS)
DECL|macro|TVN_MASK
mdefine_line|#define TVN_MASK (TVN_SIZE - 1)
DECL|macro|TVR_MASK
mdefine_line|#define TVR_MASK (TVR_SIZE - 1)
DECL|struct|timer_vec
r_struct
id|timer_vec
(brace
DECL|member|index
r_int
id|index
suffix:semicolon
DECL|member|vec
r_struct
id|timer_list
op_star
id|vec
(braket
id|TVN_SIZE
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|timer_vec_root
r_struct
id|timer_vec_root
(brace
DECL|member|index
r_int
id|index
suffix:semicolon
DECL|member|vec
r_struct
id|timer_list
op_star
id|vec
(braket
id|TVR_SIZE
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|tv5
r_static
r_struct
id|timer_vec
id|tv5
op_assign
(brace
l_int|0
)brace
suffix:semicolon
DECL|variable|tv4
r_static
r_struct
id|timer_vec
id|tv4
op_assign
(brace
l_int|0
)brace
suffix:semicolon
DECL|variable|tv3
r_static
r_struct
id|timer_vec
id|tv3
op_assign
(brace
l_int|0
)brace
suffix:semicolon
DECL|variable|tv2
r_static
r_struct
id|timer_vec
id|tv2
op_assign
(brace
l_int|0
)brace
suffix:semicolon
DECL|variable|tv1
r_static
r_struct
id|timer_vec_root
id|tv1
op_assign
(brace
l_int|0
)brace
suffix:semicolon
DECL|variable|tvecs
r_static
r_struct
id|timer_vec
op_star
r_const
id|tvecs
(braket
)braket
op_assign
(brace
(paren
r_struct
id|timer_vec
op_star
)paren
op_amp
id|tv1
comma
op_amp
id|tv2
comma
op_amp
id|tv3
comma
op_amp
id|tv4
comma
op_amp
id|tv5
)brace
suffix:semicolon
DECL|macro|NOOF_TVECS
mdefine_line|#define NOOF_TVECS (sizeof(tvecs) / sizeof(tvecs[0]))
DECL|variable|timer_jiffies
r_static
r_int
r_int
id|timer_jiffies
op_assign
l_int|0
suffix:semicolon
DECL|function|insert_timer
r_static
r_inline
r_void
id|insert_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
comma
r_struct
id|timer_list
op_star
op_star
id|vec
comma
r_int
id|idx
)paren
(brace
r_if
c_cond
(paren
(paren
id|timer-&gt;next
op_assign
id|vec
(braket
id|idx
)braket
)paren
)paren
id|vec
(braket
id|idx
)braket
op_member_access_from_pointer
id|prev
op_assign
id|timer
suffix:semicolon
id|vec
(braket
id|idx
)braket
op_assign
id|timer
suffix:semicolon
id|timer-&gt;prev
op_assign
(paren
r_struct
id|timer_list
op_star
)paren
op_amp
id|vec
(braket
id|idx
)braket
suffix:semicolon
)brace
DECL|function|internal_add_timer
r_static
r_inline
r_void
id|internal_add_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
multiline_comment|/*&n;&t; * must be cli-ed when calling this&n;&t; */
r_int
r_int
id|expires
op_assign
id|timer-&gt;expires
suffix:semicolon
r_int
r_int
id|idx
op_assign
id|expires
op_minus
id|timer_jiffies
suffix:semicolon
r_if
c_cond
(paren
id|idx
OL
id|TVR_SIZE
)paren
(brace
r_int
id|i
op_assign
id|expires
op_amp
id|TVR_MASK
suffix:semicolon
id|insert_timer
c_func
(paren
id|timer
comma
id|tv1.vec
comma
id|i
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|idx
OL
l_int|1
op_lshift
(paren
id|TVR_BITS
op_plus
id|TVN_BITS
)paren
)paren
(brace
r_int
id|i
op_assign
(paren
id|expires
op_rshift
id|TVR_BITS
)paren
op_amp
id|TVN_MASK
suffix:semicolon
id|insert_timer
c_func
(paren
id|timer
comma
id|tv2.vec
comma
id|i
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|idx
OL
l_int|1
op_lshift
(paren
id|TVR_BITS
op_plus
l_int|2
op_star
id|TVN_BITS
)paren
)paren
(brace
r_int
id|i
op_assign
(paren
id|expires
op_rshift
(paren
id|TVR_BITS
op_plus
id|TVN_BITS
)paren
)paren
op_amp
id|TVN_MASK
suffix:semicolon
id|insert_timer
c_func
(paren
id|timer
comma
id|tv3.vec
comma
id|i
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|idx
OL
l_int|1
op_lshift
(paren
id|TVR_BITS
op_plus
l_int|3
op_star
id|TVN_BITS
)paren
)paren
(brace
r_int
id|i
op_assign
(paren
id|expires
op_rshift
(paren
id|TVR_BITS
op_plus
l_int|2
op_star
id|TVN_BITS
)paren
)paren
op_amp
id|TVN_MASK
suffix:semicolon
id|insert_timer
c_func
(paren
id|timer
comma
id|tv4.vec
comma
id|i
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|idx
OL
l_int|0
)paren
(brace
multiline_comment|/* can happen if you add a timer with expires == jiffies,&n;&t;&t; * or you set a timer to go off in the past&n;&t;&t; */
id|insert_timer
c_func
(paren
id|timer
comma
id|tv1.vec
comma
id|tv1.index
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|idx
op_le
l_int|0xffffffffUL
)paren
(brace
r_int
id|i
op_assign
(paren
id|expires
op_rshift
(paren
id|TVR_BITS
op_plus
l_int|3
op_star
id|TVN_BITS
)paren
)paren
op_amp
id|TVN_MASK
suffix:semicolon
id|insert_timer
c_func
(paren
id|timer
comma
id|tv5.vec
comma
id|i
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Can only get here on architectures with 64-bit jiffies */
id|timer-&gt;next
op_assign
id|timer-&gt;prev
op_assign
id|timer
suffix:semicolon
)brace
)brace
DECL|variable|timerlist_lock
id|spinlock_t
id|timerlist_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|add_timer
r_void
id|add_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|timerlist_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer-&gt;prev
)paren
r_goto
id|bug
suffix:semicolon
id|internal_add_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|timerlist_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
id|bug
suffix:colon
id|printk
c_func
(paren
l_string|&quot;bug: kernel timer added twice at %p.&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
DECL|function|detach_timer
r_static
r_inline
r_int
id|detach_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
r_struct
id|timer_list
op_star
id|prev
op_assign
id|timer-&gt;prev
suffix:semicolon
r_if
c_cond
(paren
id|prev
)paren
(brace
r_struct
id|timer_list
op_star
id|next
op_assign
id|timer-&gt;next
suffix:semicolon
id|prev-&gt;next
op_assign
id|next
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
id|next-&gt;prev
op_assign
id|prev
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mod_timer
r_void
id|mod_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
comma
r_int
r_int
id|expires
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|timerlist_lock
comma
id|flags
)paren
suffix:semicolon
id|timer-&gt;expires
op_assign
id|expires
suffix:semicolon
id|detach_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|internal_add_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|timerlist_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|del_timer
r_int
id|del_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|timerlist_lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|detach_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|timer-&gt;next
op_assign
id|timer-&gt;prev
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|timerlist_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|schedule_timeout
r_int
r_int
id|schedule_timeout
c_func
(paren
r_int
r_int
id|timeout
)paren
(brace
r_struct
id|timer_list
id|timer
suffix:semicolon
r_int
r_int
id|expire
suffix:semicolon
r_switch
c_cond
(paren
id|timeout
)paren
(brace
r_case
id|MAX_SCHEDULE_TIMEOUT
suffix:colon
multiline_comment|/*&n;&t;&t; * These two special cases are useful to be comfortable&n;&t;&t; * in the caller. Nothing more. We could take&n;&t;&t; * MAX_SCHEDULE_TIMEOUT from one of the negative value&n;&t;&t; * but I&squot; d like to return a valid offset (&gt;=0) to allow&n;&t;&t; * the caller to do everything it want with the retval.&n;&t;&t; */
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/*&n;&t;&t; * Another bit of PARANOID. Note that the retval will be&n;&t;&t; * 0 since no piece of kernel is supposed to do a check&n;&t;&t; * for a negative retval of schedule_timeout() (since it&n;&t;&t; * should never happens anyway). You just have the printk()&n;&t;&t; * that will tell you if something is gone wrong and where.&n;&t;&t; */
r_if
c_cond
(paren
id|timeout
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;schedule_timeout: wrong timeout &quot;
l_string|&quot;value %lx from %p&bslash;n&quot;
comma
id|timeout
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|expire
op_assign
id|timeout
op_plus
id|jiffies
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|timer.expires
op_assign
id|expire
suffix:semicolon
id|timer.data
op_assign
(paren
r_int
r_int
)paren
id|current
suffix:semicolon
id|timer.function
op_assign
id|process_timeout
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|timeout
op_assign
id|expire
op_minus
id|jiffies
suffix:semicolon
id|out
suffix:colon
r_return
id|timeout
OL
l_int|0
ques
c_cond
l_int|0
suffix:colon
id|timeout
suffix:semicolon
)brace
multiline_comment|/*&n; * schedule_tail() is getting called from the fork return path. This&n; * cleans up all remaining scheduler things, without impacting the&n; * common case.&n; */
DECL|function|__schedule_tail
r_static
r_inline
r_void
id|__schedule_tail
c_func
(paren
r_struct
id|task_struct
op_star
id|prev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;active_mm
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|prev-&gt;mm
)paren
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|prev-&gt;active_mm
suffix:semicolon
r_if
c_cond
(paren
id|mm
)paren
(brace
id|prev-&gt;active_mm
op_assign
l_int|NULL
suffix:semicolon
id|mmdrop
c_func
(paren
id|mm
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef __SMP__
r_if
c_cond
(paren
(paren
id|prev-&gt;state
op_eq
id|TASK_RUNNING
)paren
op_logical_and
(paren
id|prev
op_ne
id|idle_task
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
)paren
)paren
id|reschedule_idle
c_func
(paren
id|prev
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|prev-&gt;has_cpu
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* __SMP__ */
)brace
DECL|function|schedule_tail
r_void
id|schedule_tail
c_func
(paren
r_struct
id|task_struct
op_star
id|prev
)paren
(brace
id|__schedule_tail
c_func
(paren
id|prev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  &squot;schedule()&squot; is the scheduler function. It&squot;s a very simple and nice&n; * scheduler: it&squot;s not perfect, but certainly works for most things.&n; *&n; * The goto is &quot;interesting&quot;.&n; *&n; *   NOTE!!  Task 0 is the &squot;idle&squot; task, which gets called when no other&n; * tasks can run. It can not be killed, and it cannot sleep. The &squot;state&squot;&n; * information in task[0] is never used.&n; */
DECL|function|schedule
id|asmlinkage
r_void
id|schedule
c_func
(paren
r_void
)paren
(brace
r_struct
id|schedule_data
op_star
id|sched_data
suffix:semicolon
r_struct
id|task_struct
op_star
id|prev
comma
op_star
id|next
comma
op_star
id|p
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_int
id|this_cpu
comma
id|c
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;active_mm
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tq_scheduler
)paren
r_goto
id|handle_tq_scheduler
suffix:semicolon
id|tq_scheduler_back
suffix:colon
id|prev
op_assign
id|current
suffix:semicolon
id|this_cpu
op_assign
id|prev-&gt;processor
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
r_goto
id|scheduling_in_interrupt
suffix:semicolon
id|release_kernel_lock
c_func
(paren
id|prev
comma
id|this_cpu
)paren
suffix:semicolon
multiline_comment|/* Do &quot;administrative&quot; work here while we don&squot;t hold any locks */
r_if
c_cond
(paren
id|bh_mask
op_amp
id|bh_active
)paren
r_goto
id|handle_bh
suffix:semicolon
id|handle_bh_back
suffix:colon
multiline_comment|/*&n;&t; * &squot;sched_data&squot; is protected by the fact that we can run&n;&t; * only one process per CPU.&n;&t; */
id|sched_data
op_assign
op_amp
id|aligned_data
(braket
id|this_cpu
)braket
dot
id|schedule_data
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|runqueue_lock
)paren
suffix:semicolon
multiline_comment|/* move an exhausted RR process to be last.. */
r_if
c_cond
(paren
id|prev-&gt;policy
op_eq
id|SCHED_RR
)paren
r_goto
id|move_rr_last
suffix:semicolon
id|move_rr_back
suffix:colon
r_switch
c_cond
(paren
id|prev-&gt;state
)paren
(brace
r_case
id|TASK_INTERRUPTIBLE
suffix:colon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|prev
)paren
)paren
(brace
id|prev-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|del_from_runqueue
c_func
(paren
id|prev
)paren
suffix:semicolon
r_case
id|TASK_RUNNING
suffix:colon
)brace
id|prev-&gt;need_resched
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * this is the scheduler proper:&n;&t; */
id|repeat_schedule
suffix:colon
multiline_comment|/*&n;&t; * Default process to select..&n;&t; */
id|next
op_assign
id|idle_task
c_func
(paren
id|this_cpu
)paren
suffix:semicolon
id|c
op_assign
op_minus
l_int|1000
suffix:semicolon
r_if
c_cond
(paren
id|prev-&gt;state
op_eq
id|TASK_RUNNING
)paren
r_goto
id|still_running
suffix:semicolon
id|still_running_back
suffix:colon
id|tmp
op_assign
id|runqueue_head.next
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
op_amp
id|runqueue_head
)paren
(brace
id|p
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|task_struct
comma
id|run_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|can_schedule
c_func
(paren
id|p
)paren
)paren
(brace
r_int
id|weight
op_assign
id|goodness
c_func
(paren
id|p
comma
id|this_cpu
comma
id|prev-&gt;active_mm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|weight
OG
id|c
)paren
id|c
op_assign
id|weight
comma
id|next
op_assign
id|p
suffix:semicolon
)brace
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
multiline_comment|/* Do we need to re-calculate counters? */
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_goto
id|recalculate
suffix:semicolon
multiline_comment|/*&n;&t; * from this point on nothing can prevent us from&n;&t; * switching to the next task, save this fact in&n;&t; * sched_data.&n;&t; */
id|sched_data-&gt;curr
op_assign
id|next
suffix:semicolon
macro_line|#ifdef __SMP__
id|next-&gt;has_cpu
op_assign
l_int|1
suffix:semicolon
id|next-&gt;processor
op_assign
id|this_cpu
suffix:semicolon
macro_line|#endif
id|spin_unlock_irq
c_func
(paren
op_amp
id|runqueue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev
op_eq
id|next
)paren
r_goto
id|same_process
suffix:semicolon
macro_line|#ifdef __SMP__
multiline_comment|/*&n; &t; * maintain the per-process &squot;average timeslice&squot; value.&n; &t; * (this has to be recalculated even if we reschedule to&n; &t; * the same process) Currently this is only used on SMP,&n;&t; * and it&squot;s approximate, so we do not have to maintain&n;&t; * it while holding the runqueue spinlock.&n; &t; */
(brace
id|cycles_t
id|t
comma
id|this_slice
suffix:semicolon
id|t
op_assign
id|get_cycles
c_func
(paren
)paren
suffix:semicolon
id|this_slice
op_assign
id|t
op_minus
id|sched_data-&gt;last_schedule
suffix:semicolon
id|sched_data-&gt;last_schedule
op_assign
id|t
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Exponentially fading average calculation, with&n;&t;&t; * some weight so it doesnt get fooled easily by&n;&t;&t; * smaller irregularities.&n;&t;&t; */
id|prev-&gt;avg_slice
op_assign
(paren
id|this_slice
op_star
l_int|1
op_plus
id|prev-&gt;avg_slice
op_star
l_int|1
)paren
op_div
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We drop the scheduler lock early (it&squot;s a global spinlock),&n;&t; * thus we have to lock the previous process from getting&n;&t; * rescheduled during switch_to().&n;&t; */
macro_line|#endif /* __SMP__ */
id|kstat.context_swtch
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * there are 3 processes which are affected by a context switch:&n;&t; *&n;&t; * prev == .... ==&gt; (last =&gt; next)&n;&t; *&n;&t; * It&squot;s the &squot;much more previous&squot; &squot;prev&squot; that is on next&squot;s stack,&n;&t; * but prev is set to (the just run) &squot;last&squot; process by switch_to().&n;&t; * This might sound slightly confusing but makes tons of sense.&n;&t; */
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|next-&gt;mm
suffix:semicolon
r_struct
id|mm_struct
op_star
id|oldmm
op_assign
id|prev-&gt;active_mm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mm
)paren
(brace
r_if
c_cond
(paren
id|next-&gt;active_mm
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|next-&gt;active_mm
op_assign
id|oldmm
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|oldmm-&gt;mm_count
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|next-&gt;active_mm
op_ne
id|mm
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mm
op_ne
id|oldmm
)paren
id|switch_mm
c_func
(paren
id|oldmm
comma
id|mm
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * This just switches the register state and the&n;&t; * stack.&n;&t; */
id|switch_to
c_func
(paren
id|prev
comma
id|next
comma
id|prev
)paren
suffix:semicolon
id|__schedule_tail
c_func
(paren
id|prev
)paren
suffix:semicolon
id|same_process
suffix:colon
id|reacquire_kernel_lock
c_func
(paren
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
id|recalculate
suffix:colon
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|runqueue_lock
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
id|p-&gt;counter
op_assign
(paren
id|p-&gt;counter
op_rshift
l_int|1
)paren
op_plus
id|p-&gt;priority
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|runqueue_lock
)paren
suffix:semicolon
)brace
r_goto
id|repeat_schedule
suffix:semicolon
id|still_running
suffix:colon
id|c
op_assign
id|prev_goodness
c_func
(paren
id|prev
comma
id|this_cpu
comma
id|prev-&gt;active_mm
)paren
suffix:semicolon
id|next
op_assign
id|prev
suffix:semicolon
r_goto
id|still_running_back
suffix:semicolon
id|handle_bh
suffix:colon
id|do_bottom_half
c_func
(paren
)paren
suffix:semicolon
r_goto
id|handle_bh_back
suffix:semicolon
id|handle_tq_scheduler
suffix:colon
id|run_task_queue
c_func
(paren
op_amp
id|tq_scheduler
)paren
suffix:semicolon
r_goto
id|tq_scheduler_back
suffix:semicolon
id|move_rr_last
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|prev-&gt;counter
)paren
(brace
id|prev-&gt;counter
op_assign
id|prev-&gt;priority
suffix:semicolon
id|move_last_runqueue
c_func
(paren
id|prev
)paren
suffix:semicolon
)brace
r_goto
id|move_rr_back
suffix:semicolon
id|scheduling_in_interrupt
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Scheduling in interrupt&bslash;n&quot;
)paren
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
l_int|0
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|__wake_up
r_void
id|__wake_up
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
r_int
id|mode
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
comma
op_star
id|head
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
r_goto
id|out
suffix:semicolon
id|wq_write_lock_irqsave
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC_WQHEAD
c_func
(paren
id|q
)paren
suffix:semicolon
macro_line|#endif
id|head
op_assign
op_amp
id|q-&gt;task_list
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
r_if
c_cond
(paren
op_logical_neg
id|head-&gt;next
op_logical_or
op_logical_neg
id|head-&gt;prev
)paren
id|WQ_BUG
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|tmp
op_assign
id|head-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
id|head
)paren
(brace
r_int
r_int
id|state
suffix:semicolon
id|wait_queue_t
op_star
id|curr
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
id|wait_queue_t
comma
id|task_list
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC
c_func
(paren
id|curr-&gt;__magic
)paren
suffix:semicolon
macro_line|#endif
id|p
op_assign
id|curr-&gt;task
suffix:semicolon
id|state
op_assign
id|p-&gt;state
suffix:semicolon
r_if
c_cond
(paren
id|state
op_amp
id|mode
)paren
(brace
macro_line|#if WAITQUEUE_DEBUG
id|curr-&gt;__waker
op_assign
(paren
r_int
)paren
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|wake_up_process
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
op_amp
id|TASK_EXCLUSIVE
)paren
r_break
suffix:semicolon
)brace
)brace
id|wq_write_unlock_irqrestore
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|out
suffix:colon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Semaphores are implemented using a two-way counter:&n; * The &quot;count&quot; variable is decremented for each process&n; * that tries to sleep, while the &quot;waking&quot; variable is&n; * incremented when the &quot;up()&quot; code goes to wake up waiting&n; * processes.&n; *&n; * Notably, the inline &quot;up()&quot; and &quot;down()&quot; functions can&n; * efficiently test if they need to do any extra work (up&n; * needs to do something only if count was negative before&n; * the increment operation.&n; *&n; * waking_non_zero() (from asm/semaphore.h) must execute&n; * atomically.&n; *&n; * When __up() is called, the count was negative before&n; * incrementing it, and we need to wake up somebody.&n; *&n; * This routine adds one to the count of processes that need to&n; * wake up and exit.  ALL waiting processes actually wake up but&n; * only the one that gets to the &quot;waking&quot; field first will gate&n; * through and acquire the semaphore.  The others will go back&n; * to sleep.&n; *&n; * Note that these functions are only called when there is&n; * contention on the lock, and as such all this is the&n; * &quot;non-critical&quot; part of the whole semaphore business. The&n; * critical part is the inline stuff in &lt;asm/semaphore.h&gt;&n; * where we want to avoid any extra jumps and calls.&n; */
DECL|function|__up
r_void
id|__up
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
id|wake_one_more
c_func
(paren
id|sem
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|sem-&gt;wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform the &quot;down&quot; function.  Return zero for semaphore acquired,&n; * return negative for signalled out of the function.&n; *&n; * If called from __down, the return is ignored and the wait loop is&n; * not interruptible.  This means that a task waiting on a semaphore&n; * using &quot;down()&quot; cannot be killed until someone does an &quot;up()&quot; on&n; * the semaphore.&n; *&n; * If called from __down_interruptible, the return value gets checked&n; * upon return.  If the return value is negative then the task continues&n; * with the negative value in the return register (it can be tested by&n; * the caller).&n; *&n; * Either form may be used in conjunction with &quot;up()&quot;.&n; *&n; */
DECL|macro|DOWN_VAR
mdefine_line|#define DOWN_VAR&t;&t;&t;&t;&bslash;&n;&t;struct task_struct *tsk = current;&t;&bslash;&n;&t;wait_queue_t wait;&t;&t;&t;&bslash;&n;&t;init_waitqueue_entry(&amp;wait, tsk);
DECL|macro|DOWN_HEAD
mdefine_line|#define DOWN_HEAD(task_state)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;tsk-&gt;state = (task_state);&t;&t;&t;&t;&t;&bslash;&n;&t;add_wait_queue(&amp;sem-&gt;wait, &amp;wait);&t;&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;/*&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t; * Ok, we&squot;re set up.  sem-&gt;count is known to be less than zero&t;&bslash;&n;&t; * so we must wait.&t;&t;&t;&t;&t;&t;&bslash;&n;&t; *&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t; * We can let go the lock for purposes of waiting.&t;&t;&bslash;&n;&t; * We re-acquire it after awaking so as to protect&t;&t;&bslash;&n;&t; * all semaphore operations.&t;&t;&t;&t;&t;&bslash;&n;&t; *&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t; * If &quot;up()&quot; is called before we call waking_non_zero() then&t;&bslash;&n;&t; * we will catch it right away.  If it is called later then&t;&bslash;&n;&t; * we will have to go through a wakeup cycle to catch it.&t;&bslash;&n;&t; *&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t; * Multiple waiters contend for the semaphore lock to see&t;&bslash;&n;&t; * who gets to gate through and who has to wait some more.&t;&bslash;&n;&t; */&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;for (;;) {
DECL|macro|DOWN_TAIL
mdefine_line|#define DOWN_TAIL(task_state)&t;&t;&t;&bslash;&n;&t;&t;tsk-&gt;state = (task_state);&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&bslash;&n;&t;tsk-&gt;state = TASK_RUNNING;&t;&t;&bslash;&n;&t;remove_wait_queue(&amp;sem-&gt;wait, &amp;wait);
DECL|function|__down
r_void
id|__down
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
id|DOWN_VAR
id|DOWN_HEAD
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
r_if
c_cond
(paren
id|waking_non_zero
c_func
(paren
id|sem
)paren
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|DOWN_TAIL
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
)brace
DECL|function|__down_interruptible
r_int
id|__down_interruptible
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|DOWN_VAR
id|DOWN_HEAD
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
id|ret
op_assign
id|waking_non_zero_interruptible
c_func
(paren
id|sem
comma
id|tsk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
r_if
c_cond
(paren
id|ret
op_eq
l_int|1
)paren
multiline_comment|/* ret != 0 only if we get interrupted -arca */
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|DOWN_TAIL
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
r_return
id|ret
suffix:semicolon
)brace
DECL|function|__down_trylock
r_int
id|__down_trylock
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_return
id|waking_non_zero_trylock
c_func
(paren
id|sem
)paren
suffix:semicolon
)brace
DECL|macro|SLEEP_ON_VAR
mdefine_line|#define&t;SLEEP_ON_VAR&t;&t;&t;&t;&bslash;&n;&t;unsigned long flags;&t;&t;&t;&bslash;&n;&t;wait_queue_t wait;&t;&t;&t;&bslash;&n;&t;init_waitqueue_entry(&amp;wait, current);
DECL|macro|SLEEP_ON_HEAD
mdefine_line|#define&t;SLEEP_ON_HEAD&t;&t;&t;&t;&t;&bslash;&n;&t;wq_write_lock_irqsave(&amp;q-&gt;lock,flags);&t;&t;&bslash;&n;&t;__add_wait_queue(q, &amp;wait);&t;&t;&t;&bslash;&n;&t;wq_write_unlock(&amp;q-&gt;lock);
DECL|macro|SLEEP_ON_TAIL
mdefine_line|#define&t;SLEEP_ON_TAIL&t;&t;&t;&t;&t;&t;&bslash;&n;&t;wq_write_lock_irq(&amp;q-&gt;lock);&t;&t;&t;&t;&bslash;&n;&t;__remove_wait_queue(q, &amp;wait);&t;&t;&t;&t;&bslash;&n;&t;wq_write_unlock_irqrestore(&amp;q-&gt;lock,flags);
DECL|function|interruptible_sleep_on
r_void
id|interruptible_sleep_on
c_func
(paren
id|wait_queue_head_t
op_star
id|q
)paren
(brace
id|SLEEP_ON_VAR
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|SLEEP_ON_HEAD
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|SLEEP_ON_TAIL
)brace
DECL|function|interruptible_sleep_on_timeout
r_int
id|interruptible_sleep_on_timeout
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
id|timeout
)paren
(brace
id|SLEEP_ON_VAR
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|SLEEP_ON_HEAD
id|timeout
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
id|SLEEP_ON_TAIL
r_return
id|timeout
suffix:semicolon
)brace
DECL|function|sleep_on
r_void
id|sleep_on
c_func
(paren
id|wait_queue_head_t
op_star
id|q
)paren
(brace
id|SLEEP_ON_VAR
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|SLEEP_ON_HEAD
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|SLEEP_ON_TAIL
)brace
DECL|function|sleep_on_timeout
r_int
id|sleep_on_timeout
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
id|timeout
)paren
(brace
id|SLEEP_ON_VAR
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|SLEEP_ON_HEAD
id|timeout
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
id|SLEEP_ON_TAIL
r_return
id|timeout
suffix:semicolon
)brace
DECL|function|scheduling_functions_end_here
r_void
id|scheduling_functions_end_here
c_func
(paren
r_void
)paren
(brace
)brace
DECL|function|cascade_timers
r_static
r_inline
r_void
id|cascade_timers
c_func
(paren
r_struct
id|timer_vec
op_star
id|tv
)paren
(brace
multiline_comment|/* cascade all the timers from tv up one level */
r_struct
id|timer_list
op_star
id|timer
suffix:semicolon
id|timer
op_assign
id|tv-&gt;vec
(braket
id|tv-&gt;index
)braket
suffix:semicolon
multiline_comment|/*&n;         * We are removing _all_ timers from the list, so we don&squot;t  have to&n;         * detach them individually, just clear the list afterwards.&n;         */
r_while
c_loop
(paren
id|timer
)paren
(brace
r_struct
id|timer_list
op_star
id|tmp
op_assign
id|timer
suffix:semicolon
id|timer
op_assign
id|timer-&gt;next
suffix:semicolon
id|internal_add_timer
c_func
(paren
id|tmp
)paren
suffix:semicolon
)brace
id|tv-&gt;vec
(braket
id|tv-&gt;index
)braket
op_assign
l_int|NULL
suffix:semicolon
id|tv-&gt;index
op_assign
(paren
id|tv-&gt;index
op_plus
l_int|1
)paren
op_amp
id|TVN_MASK
suffix:semicolon
)brace
DECL|function|run_timer_list
r_static
r_inline
r_void
id|run_timer_list
c_func
(paren
r_void
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|timerlist_lock
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
r_int
)paren
(paren
id|jiffies
op_minus
id|timer_jiffies
)paren
op_ge
l_int|0
)paren
(brace
r_struct
id|timer_list
op_star
id|timer
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tv1.index
)paren
(brace
r_int
id|n
op_assign
l_int|1
suffix:semicolon
r_do
(brace
id|cascade_timers
c_func
(paren
id|tvecs
(braket
id|n
)braket
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tvecs
(braket
id|n
)braket
op_member_access_from_pointer
id|index
op_eq
l_int|1
op_logical_and
op_increment
id|n
OL
id|NOOF_TVECS
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|timer
op_assign
id|tv1.vec
(braket
id|tv1.index
)braket
)paren
)paren
(brace
r_void
(paren
op_star
id|fn
)paren
(paren
r_int
r_int
)paren
op_assign
id|timer-&gt;function
suffix:semicolon
r_int
r_int
id|data
op_assign
id|timer-&gt;data
suffix:semicolon
id|detach_timer
c_func
(paren
id|timer
)paren
suffix:semicolon
id|timer-&gt;next
op_assign
id|timer-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|timerlist_lock
)paren
suffix:semicolon
id|fn
c_func
(paren
id|data
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|timerlist_lock
)paren
suffix:semicolon
)brace
op_increment
id|timer_jiffies
suffix:semicolon
id|tv1.index
op_assign
(paren
id|tv1.index
op_plus
l_int|1
)paren
op_amp
id|TVR_MASK
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|timerlist_lock
)paren
suffix:semicolon
)brace
DECL|function|run_old_timers
r_static
r_inline
r_void
id|run_old_timers
c_func
(paren
r_void
)paren
(brace
r_struct
id|timer_struct
op_star
id|tp
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_for
c_loop
(paren
id|mask
op_assign
l_int|1
comma
id|tp
op_assign
id|timer_table
op_plus
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|tp
op_increment
comma
id|mask
op_add_assign
id|mask
)paren
(brace
r_if
c_cond
(paren
id|mask
OG
id|timer_active
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mask
op_amp
id|timer_active
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|tp-&gt;expires
comma
id|jiffies
)paren
)paren
r_continue
suffix:semicolon
id|timer_active
op_and_assign
op_complement
id|mask
suffix:semicolon
id|tp
op_member_access_from_pointer
id|fn
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|variable|tqueue_lock
id|spinlock_t
id|tqueue_lock
suffix:semicolon
DECL|function|tqueue_bh
r_void
id|tqueue_bh
c_func
(paren
r_void
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_timer
)paren
suffix:semicolon
)brace
DECL|function|immediate_bh
r_void
id|immediate_bh
c_func
(paren
r_void
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_immediate
)paren
suffix:semicolon
)brace
DECL|variable|timer_active
r_int
r_int
id|timer_active
op_assign
l_int|0
suffix:semicolon
DECL|variable|timer_table
r_struct
id|timer_struct
id|timer_table
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/*&n; * Hmm.. Changed this, as the GNU make sources (load.c) seems to&n; * imply that avenrun[] is the standard name for this kind of thing.&n; * Nothing else seems to be standardized: the fractional size etc&n; * all seem to differ on different machines.&n; */
DECL|variable|avenrun
r_int
r_int
id|avenrun
(braket
l_int|3
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * Nr of active tasks - counted in fixed-point numbers&n; */
DECL|function|count_active_tasks
r_static
r_int
r_int
id|count_active_tasks
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
r_int
id|nr
op_assign
l_int|0
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
(paren
id|p-&gt;state
op_eq
id|TASK_RUNNING
op_logical_or
(paren
id|p-&gt;state
op_amp
id|TASK_UNINTERRUPTIBLE
)paren
op_logical_or
(paren
id|p-&gt;state
op_amp
id|TASK_SWAPPING
)paren
)paren
)paren
id|nr
op_add_assign
id|FIXED_1
suffix:semicolon
)brace
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|nr
suffix:semicolon
)brace
DECL|function|calc_load
r_static
r_inline
r_void
id|calc_load
c_func
(paren
r_int
r_int
id|ticks
)paren
(brace
r_int
r_int
id|active_tasks
suffix:semicolon
multiline_comment|/* fixed-point */
r_static
r_int
id|count
op_assign
id|LOAD_FREQ
suffix:semicolon
id|count
op_sub_assign
id|ticks
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
(brace
id|count
op_add_assign
id|LOAD_FREQ
suffix:semicolon
id|active_tasks
op_assign
id|count_active_tasks
c_func
(paren
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|0
)braket
comma
id|EXP_1
comma
id|active_tasks
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|1
)braket
comma
id|EXP_5
comma
id|active_tasks
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|2
)braket
comma
id|EXP_15
comma
id|active_tasks
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * this routine handles the overflow of the microsecond field&n; *&n; * The tricky bits of code to handle the accurate clock support&n; * were provided by Dave Mills (Mills@UDEL.EDU) of NTP fame.&n; * They were originally developed for SUN and DEC kernels.&n; * All the kudos should go to Dave for this stuff.&n; *&n; */
DECL|function|second_overflow
r_static
r_void
id|second_overflow
c_func
(paren
r_void
)paren
(brace
r_int
id|ltemp
suffix:semicolon
multiline_comment|/* Bump the maxerror field */
id|time_maxerror
op_add_assign
id|time_tolerance
op_rshift
id|SHIFT_USEC
suffix:semicolon
r_if
c_cond
(paren
id|time_maxerror
OG
id|NTP_PHASE_LIMIT
)paren
(brace
id|time_maxerror
op_assign
id|NTP_PHASE_LIMIT
suffix:semicolon
id|time_status
op_or_assign
id|STA_UNSYNC
suffix:semicolon
)brace
multiline_comment|/*&n;     * Leap second processing. If in leap-insert state at&n;     * the end of the day, the system clock is set back one&n;     * second; if in leap-delete state, the system clock is&n;     * set ahead one second. The microtime() routine or&n;     * external clock driver will insure that reported time&n;     * is always monotonic. The ugly divides should be&n;     * replaced.&n;     */
r_switch
c_cond
(paren
id|time_state
)paren
(brace
r_case
id|TIME_OK
suffix:colon
r_if
c_cond
(paren
id|time_status
op_amp
id|STA_INS
)paren
id|time_state
op_assign
id|TIME_INS
suffix:semicolon
r_else
r_if
c_cond
(paren
id|time_status
op_amp
id|STA_DEL
)paren
id|time_state
op_assign
id|TIME_DEL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_INS
suffix:colon
r_if
c_cond
(paren
id|xtime.tv_sec
op_mod
l_int|86400
op_eq
l_int|0
)paren
(brace
id|xtime.tv_sec
op_decrement
suffix:semicolon
id|time_state
op_assign
id|TIME_OOP
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Clock: inserting leap second 23:59:60 UTC&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIME_DEL
suffix:colon
r_if
c_cond
(paren
(paren
id|xtime.tv_sec
op_plus
l_int|1
)paren
op_mod
l_int|86400
op_eq
l_int|0
)paren
(brace
id|xtime.tv_sec
op_increment
suffix:semicolon
id|time_state
op_assign
id|TIME_WAIT
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Clock: deleting leap second 23:59:59 UTC&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIME_OOP
suffix:colon
id|time_state
op_assign
id|TIME_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIME_WAIT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|time_status
op_amp
(paren
id|STA_INS
op_or
id|STA_DEL
)paren
)paren
)paren
id|time_state
op_assign
id|TIME_OK
suffix:semicolon
)brace
multiline_comment|/*&n;     * Compute the phase adjustment for the next second. In&n;     * PLL mode, the offset is reduced by a fixed factor&n;     * times the time constant. In FLL mode the offset is&n;     * used directly. In either mode, the maximum phase&n;     * adjustment for each second is clamped so as to spread&n;     * the adjustment over not more than the number of&n;     * seconds between updates.&n;     */
r_if
c_cond
(paren
id|time_offset
OL
l_int|0
)paren
(brace
id|ltemp
op_assign
op_minus
id|time_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|time_status
op_amp
id|STA_FLL
)paren
)paren
id|ltemp
op_rshift_assign
id|SHIFT_KG
op_plus
id|time_constant
suffix:semicolon
r_if
c_cond
(paren
id|ltemp
OG
(paren
id|MAXPHASE
op_div
id|MINSEC
)paren
op_lshift
id|SHIFT_UPDATE
)paren
id|ltemp
op_assign
(paren
id|MAXPHASE
op_div
id|MINSEC
)paren
op_lshift
id|SHIFT_UPDATE
suffix:semicolon
id|time_offset
op_add_assign
id|ltemp
suffix:semicolon
id|time_adj
op_assign
op_minus
id|ltemp
op_lshift
(paren
id|SHIFT_SCALE
op_minus
id|SHIFT_HZ
op_minus
id|SHIFT_UPDATE
)paren
suffix:semicolon
)brace
r_else
(brace
id|ltemp
op_assign
id|time_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|time_status
op_amp
id|STA_FLL
)paren
)paren
id|ltemp
op_rshift_assign
id|SHIFT_KG
op_plus
id|time_constant
suffix:semicolon
r_if
c_cond
(paren
id|ltemp
OG
(paren
id|MAXPHASE
op_div
id|MINSEC
)paren
op_lshift
id|SHIFT_UPDATE
)paren
id|ltemp
op_assign
(paren
id|MAXPHASE
op_div
id|MINSEC
)paren
op_lshift
id|SHIFT_UPDATE
suffix:semicolon
id|time_offset
op_sub_assign
id|ltemp
suffix:semicolon
id|time_adj
op_assign
id|ltemp
op_lshift
(paren
id|SHIFT_SCALE
op_minus
id|SHIFT_HZ
op_minus
id|SHIFT_UPDATE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;     * Compute the frequency estimate and additional phase&n;     * adjustment due to frequency error for the next&n;     * second. When the PPS signal is engaged, gnaw on the&n;     * watchdog counter and update the frequency computed by&n;     * the pll and the PPS signal.&n;     */
id|pps_valid
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|pps_valid
op_eq
id|PPS_VALID
)paren
(brace
multiline_comment|/* PPS signal lost */
id|pps_jitter
op_assign
id|MAXTIME
suffix:semicolon
id|pps_stabil
op_assign
id|MAXFREQ
suffix:semicolon
id|time_status
op_and_assign
op_complement
(paren
id|STA_PPSSIGNAL
op_or
id|STA_PPSJITTER
op_or
id|STA_PPSWANDER
op_or
id|STA_PPSERROR
)paren
suffix:semicolon
)brace
id|ltemp
op_assign
id|time_freq
op_plus
id|pps_freq
suffix:semicolon
r_if
c_cond
(paren
id|ltemp
OL
l_int|0
)paren
id|time_adj
op_sub_assign
op_minus
id|ltemp
op_rshift
(paren
id|SHIFT_USEC
op_plus
id|SHIFT_HZ
op_minus
id|SHIFT_SCALE
)paren
suffix:semicolon
r_else
id|time_adj
op_add_assign
id|ltemp
op_rshift
(paren
id|SHIFT_USEC
op_plus
id|SHIFT_HZ
op_minus
id|SHIFT_SCALE
)paren
suffix:semicolon
macro_line|#if HZ == 100
multiline_comment|/* Compensate for (HZ==100) != (1 &lt;&lt; SHIFT_HZ).&n;     * Add 25% and 3.125% to get 128.125; =&gt; only 0.125% error (p. 14)&n;     */
r_if
c_cond
(paren
id|time_adj
OL
l_int|0
)paren
id|time_adj
op_sub_assign
(paren
op_minus
id|time_adj
op_rshift
l_int|2
)paren
op_plus
(paren
op_minus
id|time_adj
op_rshift
l_int|5
)paren
suffix:semicolon
r_else
id|time_adj
op_add_assign
(paren
id|time_adj
op_rshift
l_int|2
)paren
op_plus
(paren
id|time_adj
op_rshift
l_int|5
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* in the NTP reference this is called &quot;hardclock()&quot; */
DECL|function|update_wall_time_one_tick
r_static
r_void
id|update_wall_time_one_tick
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
(paren
id|time_adjust_step
op_assign
id|time_adjust
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* We are doing an adjtime thing. &n;&t;     *&n;&t;     * Prepare time_adjust_step to be within bounds.&n;&t;     * Note that a positive time_adjust means we want the clock&n;&t;     * to run faster.&n;&t;     *&n;&t;     * Limit the amount of the step to be in the range&n;&t;     * -tickadj .. +tickadj&n;&t;     */
r_if
c_cond
(paren
id|time_adjust
OG
id|tickadj
)paren
id|time_adjust_step
op_assign
id|tickadj
suffix:semicolon
r_else
r_if
c_cond
(paren
id|time_adjust
OL
op_minus
id|tickadj
)paren
id|time_adjust_step
op_assign
op_minus
id|tickadj
suffix:semicolon
multiline_comment|/* Reduce by this step the amount of time left  */
id|time_adjust
op_sub_assign
id|time_adjust_step
suffix:semicolon
)brace
id|xtime.tv_usec
op_add_assign
id|tick
op_plus
id|time_adjust_step
suffix:semicolon
multiline_comment|/*&n;&t; * Advance the phase, once it gets to one microsecond, then&n;&t; * advance the tick more.&n;&t; */
id|time_phase
op_add_assign
id|time_adj
suffix:semicolon
r_if
c_cond
(paren
id|time_phase
op_le
op_minus
id|FINEUSEC
)paren
(brace
r_int
id|ltemp
op_assign
op_minus
id|time_phase
op_rshift
id|SHIFT_SCALE
suffix:semicolon
id|time_phase
op_add_assign
id|ltemp
op_lshift
id|SHIFT_SCALE
suffix:semicolon
id|xtime.tv_usec
op_sub_assign
id|ltemp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|time_phase
op_ge
id|FINEUSEC
)paren
(brace
r_int
id|ltemp
op_assign
id|time_phase
op_rshift
id|SHIFT_SCALE
suffix:semicolon
id|time_phase
op_sub_assign
id|ltemp
op_lshift
id|SHIFT_SCALE
suffix:semicolon
id|xtime.tv_usec
op_add_assign
id|ltemp
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Using a loop looks inefficient, but &quot;ticks&quot; is&n; * usually just one (we shouldn&squot;t be losing ticks,&n; * we&squot;re doing this this way mainly for interrupt&n; * latency reasons, not because we think we&squot;ll&n; * have lots of lost timer ticks&n; */
DECL|function|update_wall_time
r_static
r_void
id|update_wall_time
c_func
(paren
r_int
r_int
id|ticks
)paren
(brace
r_do
(brace
id|ticks
op_decrement
suffix:semicolon
id|update_wall_time_one_tick
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ticks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xtime.tv_usec
op_ge
l_int|1000000
)paren
(brace
id|xtime.tv_usec
op_sub_assign
l_int|1000000
suffix:semicolon
id|xtime.tv_sec
op_increment
suffix:semicolon
id|second_overflow
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|do_process_times
r_static
r_inline
r_void
id|do_process_times
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
r_int
id|user
comma
r_int
r_int
id|system
)paren
(brace
r_int
id|psecs
suffix:semicolon
id|psecs
op_assign
(paren
id|p-&gt;times.tms_utime
op_add_assign
id|user
)paren
suffix:semicolon
id|psecs
op_add_assign
(paren
id|p-&gt;times.tms_stime
op_add_assign
id|system
)paren
suffix:semicolon
r_if
c_cond
(paren
id|psecs
op_div
id|HZ
OG
id|p-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_cur
)paren
(brace
multiline_comment|/* Send SIGXCPU every second.. */
r_if
c_cond
(paren
op_logical_neg
(paren
id|psecs
op_mod
id|HZ
)paren
)paren
id|send_sig
c_func
(paren
id|SIGXCPU
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* and SIGKILL when we go over max.. */
r_if
c_cond
(paren
id|psecs
op_div
id|HZ
OG
id|p-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_max
)paren
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
DECL|function|do_it_virt
r_static
r_inline
r_void
id|do_it_virt
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
r_int
id|ticks
)paren
(brace
r_int
r_int
id|it_virt
op_assign
id|p-&gt;it_virt_value
suffix:semicolon
r_if
c_cond
(paren
id|it_virt
)paren
(brace
r_if
c_cond
(paren
id|it_virt
op_le
id|ticks
)paren
(brace
id|it_virt
op_assign
id|ticks
op_plus
id|p-&gt;it_virt_incr
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGVTALRM
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
)brace
id|p-&gt;it_virt_value
op_assign
id|it_virt
op_minus
id|ticks
suffix:semicolon
)brace
)brace
DECL|function|do_it_prof
r_static
r_inline
r_void
id|do_it_prof
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
r_int
id|ticks
)paren
(brace
r_int
r_int
id|it_prof
op_assign
id|p-&gt;it_prof_value
suffix:semicolon
r_if
c_cond
(paren
id|it_prof
)paren
(brace
r_if
c_cond
(paren
id|it_prof
op_le
id|ticks
)paren
(brace
id|it_prof
op_assign
id|ticks
op_plus
id|p-&gt;it_prof_incr
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGPROF
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
)brace
id|p-&gt;it_prof_value
op_assign
id|it_prof
op_minus
id|ticks
suffix:semicolon
)brace
)brace
DECL|function|update_one_process
r_void
id|update_one_process
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
r_int
id|ticks
comma
r_int
r_int
id|user
comma
r_int
r_int
id|system
comma
r_int
id|cpu
)paren
(brace
id|p-&gt;per_cpu_utime
(braket
id|cpu
)braket
op_add_assign
id|user
suffix:semicolon
id|p-&gt;per_cpu_stime
(braket
id|cpu
)braket
op_add_assign
id|system
suffix:semicolon
id|do_process_times
c_func
(paren
id|p
comma
id|user
comma
id|system
)paren
suffix:semicolon
id|do_it_virt
c_func
(paren
id|p
comma
id|user
)paren
suffix:semicolon
id|do_it_prof
c_func
(paren
id|p
comma
id|ticks
)paren
suffix:semicolon
)brace
DECL|function|update_process_times
r_static
r_void
id|update_process_times
c_func
(paren
r_int
r_int
id|ticks
comma
r_int
r_int
id|system
)paren
(brace
multiline_comment|/*&n; * SMP does this on a per-CPU basis elsewhere&n; */
macro_line|#ifndef  __SMP__
r_struct
id|task_struct
op_star
id|p
op_assign
id|current
suffix:semicolon
r_int
r_int
id|user
op_assign
id|ticks
op_minus
id|system
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;pid
)paren
(brace
id|p-&gt;counter
op_sub_assign
id|ticks
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;counter
op_le
l_int|0
)paren
(brace
id|p-&gt;counter
op_assign
l_int|0
suffix:semicolon
id|p-&gt;need_resched
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;priority
OL
id|DEF_PRIORITY
)paren
id|kstat.cpu_nice
op_add_assign
id|user
suffix:semicolon
r_else
id|kstat.cpu_user
op_add_assign
id|user
suffix:semicolon
id|kstat.cpu_system
op_add_assign
id|system
suffix:semicolon
)brace
id|update_one_process
c_func
(paren
id|p
comma
id|ticks
comma
id|user
comma
id|system
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|lost_ticks
r_volatile
r_int
r_int
id|lost_ticks
op_assign
l_int|0
suffix:semicolon
DECL|variable|lost_ticks_system
r_static
r_int
r_int
id|lost_ticks_system
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * This spinlock protect us from races in SMP while playing with xtime. -arca&n; */
DECL|variable|xtime_lock
id|rwlock_t
id|xtime_lock
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
DECL|function|update_times
r_static
r_inline
r_void
id|update_times
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|ticks
suffix:semicolon
multiline_comment|/*&n;&t; * update_times() is run from the raw timer_bh handler so we&n;&t; * just know that the irqs are locally enabled and so we don&squot;t&n;&t; * need to save/restore the flags of the local CPU here. -arca&n;&t; */
id|write_lock_irq
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
id|ticks
op_assign
id|lost_ticks
suffix:semicolon
id|lost_ticks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ticks
)paren
(brace
r_int
r_int
id|system
suffix:semicolon
id|system
op_assign
id|xchg
c_func
(paren
op_amp
id|lost_ticks_system
comma
l_int|0
)paren
suffix:semicolon
id|calc_load
c_func
(paren
id|ticks
)paren
suffix:semicolon
id|update_wall_time
c_func
(paren
id|ticks
)paren
suffix:semicolon
id|write_unlock_irq
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
id|update_process_times
c_func
(paren
id|ticks
comma
id|system
)paren
suffix:semicolon
)brace
r_else
id|write_unlock_irq
c_func
(paren
op_amp
id|xtime_lock
)paren
suffix:semicolon
)brace
DECL|function|timer_bh
r_static
r_void
id|timer_bh
c_func
(paren
r_void
)paren
(brace
id|update_times
c_func
(paren
)paren
suffix:semicolon
id|run_old_timers
c_func
(paren
)paren
suffix:semicolon
id|run_timer_list
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|do_timer
r_void
id|do_timer
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
(paren
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|jiffies
)paren
op_increment
suffix:semicolon
id|lost_ticks
op_increment
suffix:semicolon
id|mark_bh
c_func
(paren
id|TIMER_BH
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
id|lost_ticks_system
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tq_timer
)paren
id|mark_bh
c_func
(paren
id|TQUEUE_BH
)paren
suffix:semicolon
)brace
macro_line|#ifndef __alpha__
multiline_comment|/*&n; * For backwards compatibility?  This can be done in libc so Alpha&n; * and all newer ports shouldn&squot;t need it.&n; */
DECL|function|sys_alarm
id|asmlinkage
r_int
r_int
id|sys_alarm
c_func
(paren
r_int
r_int
id|seconds
)paren
(brace
r_struct
id|itimerval
id|it_new
comma
id|it_old
suffix:semicolon
r_int
r_int
id|oldalarm
suffix:semicolon
id|it_new.it_interval.tv_sec
op_assign
id|it_new.it_interval.tv_usec
op_assign
l_int|0
suffix:semicolon
id|it_new.it_value.tv_sec
op_assign
id|seconds
suffix:semicolon
id|it_new.it_value.tv_usec
op_assign
l_int|0
suffix:semicolon
id|do_setitimer
c_func
(paren
id|ITIMER_REAL
comma
op_amp
id|it_new
comma
op_amp
id|it_old
)paren
suffix:semicolon
id|oldalarm
op_assign
id|it_old.it_value.tv_sec
suffix:semicolon
multiline_comment|/* ehhh.. We can&squot;t return 0 if we have an alarm pending.. */
multiline_comment|/* And we&squot;d better return too much than too little anyway */
r_if
c_cond
(paren
id|it_old.it_value.tv_usec
)paren
id|oldalarm
op_increment
suffix:semicolon
r_return
id|oldalarm
suffix:semicolon
)brace
multiline_comment|/*&n; * The Alpha uses getxpid, getxuid, and getxgid instead.  Maybe this&n; * should be moved into arch/i386 instead?&n; */
DECL|function|sys_getpid
id|asmlinkage
r_int
id|sys_getpid
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* This is SMP safe - current-&gt;pid doesn&squot;t change */
r_return
id|current-&gt;pid
suffix:semicolon
)brace
multiline_comment|/*&n; * This is not strictly SMP safe: p_opptr could change&n; * from under us. However, rather than getting any lock&n; * we can use an optimistic algorithm: get the parent&n; * pid, and go back and check that the parent is still&n; * the same. If it has changed (which is extremely unlikely&n; * indeed), we just try again..&n; *&n; * NOTE! This depends on the fact that even if we _do_&n; * get an old value of &quot;parent&quot;, we can happily dereference&n; * the pointer: we just can&squot;t necessarily trust the result&n; * until we know that the parent pointer is valid.&n; *&n; * The &quot;mb()&quot; macro is a memory barrier - a synchronizing&n; * event. It also makes sure that gcc doesn&squot;t optimize&n; * away the necessary memory references.. The barrier doesn&squot;t&n; * have to have all that strong semantics: on x86 we don&squot;t&n; * really require a synchronizing instruction, for example.&n; * The barrier is more important for code generation than&n; * for any real memory ordering semantics (even if there is&n; * a small window for a race, using the old pointer is&n; * harmless for a while).&n; */
DECL|function|sys_getppid
id|asmlinkage
r_int
id|sys_getppid
c_func
(paren
r_void
)paren
(brace
r_int
id|pid
suffix:semicolon
r_struct
id|task_struct
op_star
id|me
op_assign
id|current
suffix:semicolon
r_struct
id|task_struct
op_star
id|parent
suffix:semicolon
id|parent
op_assign
id|me-&gt;p_opptr
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|pid
op_assign
id|parent-&gt;pid
suffix:semicolon
macro_line|#if __SMP__
(brace
r_struct
id|task_struct
op_star
id|old
op_assign
id|parent
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|parent
op_assign
id|me-&gt;p_opptr
suffix:semicolon
r_if
c_cond
(paren
id|old
op_ne
id|parent
)paren
r_continue
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
)brace
r_return
id|pid
suffix:semicolon
)brace
DECL|function|sys_getuid
id|asmlinkage
r_int
id|sys_getuid
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Only we change this so SMP safe */
r_return
id|current-&gt;uid
suffix:semicolon
)brace
DECL|function|sys_geteuid
id|asmlinkage
r_int
id|sys_geteuid
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Only we change this so SMP safe */
r_return
id|current-&gt;euid
suffix:semicolon
)brace
DECL|function|sys_getgid
id|asmlinkage
r_int
id|sys_getgid
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Only we change this so SMP safe */
r_return
id|current-&gt;gid
suffix:semicolon
)brace
DECL|function|sys_getegid
id|asmlinkage
r_int
id|sys_getegid
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Only we change this so SMP safe */
r_return
id|current-&gt;egid
suffix:semicolon
)brace
multiline_comment|/*&n; * This has been replaced by sys_setpriority.  Maybe it should be&n; * moved into the arch dependent tree for those ports that require&n; * it for backward compatibility?&n; */
DECL|function|sys_nice
id|asmlinkage
r_int
id|sys_nice
c_func
(paren
r_int
id|increment
)paren
(brace
r_int
r_int
id|newprio
suffix:semicolon
r_int
id|increase
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Setpriority might change our priority at the same moment.&n;&t; *&t;We don&squot;t have to worry. Conceptually one call occurs first&n;&t; *&t;and we have a single winner.&n;&t; */
id|newprio
op_assign
id|increment
suffix:semicolon
r_if
c_cond
(paren
id|increment
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_NICE
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|newprio
op_assign
op_minus
id|increment
suffix:semicolon
id|increase
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newprio
OG
l_int|40
)paren
id|newprio
op_assign
l_int|40
suffix:semicolon
multiline_comment|/*&n;&t; * do a &quot;normalization&quot; of the priority (traditionally&n;&t; * Unix nice values are -20 to 20; Linux doesn&squot;t really&n;&t; * use that kind of thing, but uses the length of the&n;&t; * timeslice instead (default 200 ms). The rounding is&n;&t; * why we want to avoid negative values.&n;&t; */
id|newprio
op_assign
(paren
id|newprio
op_star
id|DEF_PRIORITY
op_plus
l_int|10
)paren
op_div
l_int|20
suffix:semicolon
id|increment
op_assign
id|newprio
suffix:semicolon
r_if
c_cond
(paren
id|increase
)paren
id|increment
op_assign
op_minus
id|increment
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Current-&gt;priority can change between this point&n;&t; *&t;and the assignment. We are assigning not doing add/subs&n;&t; *&t;so thats ok. Conceptually a process might just instantaneously&n;&t; *&t;read the value we stomp over. I don&squot;t think that is an issue&n;&t; *&t;unless posix makes it one. If so we can loop on changes&n;&t; *&t;to current-&gt;priority.&n;&t; */
id|newprio
op_assign
id|current-&gt;priority
op_minus
id|increment
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|newprio
OL
l_int|1
)paren
id|newprio
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|newprio
OG
id|DEF_PRIORITY
op_star
l_int|2
)paren
id|newprio
op_assign
id|DEF_PRIORITY
op_star
l_int|2
suffix:semicolon
id|current-&gt;priority
op_assign
id|newprio
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|find_process_by_pid
r_static
r_inline
r_struct
id|task_struct
op_star
id|find_process_by_pid
c_func
(paren
id|pid_t
id|pid
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_if
c_cond
(paren
id|pid
)paren
id|tsk
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
r_return
id|tsk
suffix:semicolon
)brace
DECL|function|setscheduler
r_static
r_int
id|setscheduler
c_func
(paren
id|pid_t
id|pid
comma
r_int
id|policy
comma
r_struct
id|sched_param
op_star
id|param
)paren
(brace
r_struct
id|sched_param
id|lp
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|param
op_logical_or
id|pid
OL
l_int|0
)paren
r_goto
id|out_nounlock
suffix:semicolon
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|lp
comma
id|param
comma
r_sizeof
(paren
r_struct
id|sched_param
)paren
)paren
)paren
r_goto
id|out_nounlock
suffix:semicolon
multiline_comment|/*&n;&t; * We play safe to avoid deadlocks.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|runqueue_lock
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|p
op_assign
id|find_process_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_goto
id|out_unlock
suffix:semicolon
r_if
c_cond
(paren
id|policy
OL
l_int|0
)paren
id|policy
op_assign
id|p-&gt;policy
suffix:semicolon
r_else
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|policy
op_ne
id|SCHED_FIFO
op_logical_and
id|policy
op_ne
id|SCHED_RR
op_logical_and
id|policy
op_ne
id|SCHED_OTHER
)paren
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Valid priorities for SCHED_FIFO and SCHED_RR are 1..99, valid&n;&t; * priority for SCHED_OTHER is 0.&n;&t; */
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|lp.sched_priority
template_param
l_int|99
)paren
r_goto
id|out_unlock
suffix:semicolon
r_if
c_cond
(paren
(paren
id|policy
op_eq
id|SCHED_OTHER
)paren
op_ne
(paren
id|lp.sched_priority
op_eq
l_int|0
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|retval
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|policy
op_eq
id|SCHED_FIFO
op_logical_or
id|policy
op_eq
id|SCHED_RR
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_NICE
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current-&gt;euid
op_ne
id|p-&gt;euid
)paren
op_logical_and
(paren
id|current-&gt;euid
op_ne
id|p-&gt;uid
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_NICE
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|p-&gt;policy
op_assign
id|policy
suffix:semicolon
id|p-&gt;rt_priority
op_assign
id|lp.sched_priority
suffix:semicolon
r_if
c_cond
(paren
id|task_on_runqueue
c_func
(paren
id|p
)paren
)paren
id|move_first_runqueue
c_func
(paren
id|p
)paren
suffix:semicolon
id|current-&gt;need_resched
op_assign
l_int|1
suffix:semicolon
id|out_unlock
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|runqueue_lock
)paren
suffix:semicolon
id|out_nounlock
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|sys_sched_setscheduler
id|asmlinkage
r_int
id|sys_sched_setscheduler
c_func
(paren
id|pid_t
id|pid
comma
r_int
id|policy
comma
r_struct
id|sched_param
op_star
id|param
)paren
(brace
r_return
id|setscheduler
c_func
(paren
id|pid
comma
id|policy
comma
id|param
)paren
suffix:semicolon
)brace
DECL|function|sys_sched_setparam
id|asmlinkage
r_int
id|sys_sched_setparam
c_func
(paren
id|pid_t
id|pid
comma
r_struct
id|sched_param
op_star
id|param
)paren
(brace
r_return
id|setscheduler
c_func
(paren
id|pid
comma
op_minus
l_int|1
comma
id|param
)paren
suffix:semicolon
)brace
DECL|function|sys_sched_getscheduler
id|asmlinkage
r_int
id|sys_sched_getscheduler
c_func
(paren
id|pid_t
id|pid
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|pid
OL
l_int|0
)paren
r_goto
id|out_nounlock
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ESRCH
suffix:semicolon
id|p
op_assign
id|find_process_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_goto
id|out_unlock
suffix:semicolon
id|retval
op_assign
id|p-&gt;policy
suffix:semicolon
id|out_unlock
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|out_nounlock
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|sys_sched_getparam
id|asmlinkage
r_int
id|sys_sched_getparam
c_func
(paren
id|pid_t
id|pid
comma
r_struct
id|sched_param
op_star
id|param
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_struct
id|sched_param
id|lp
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|param
op_logical_or
id|pid
OL
l_int|0
)paren
r_goto
id|out_nounlock
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|p
op_assign
id|find_process_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_goto
id|out_unlock
suffix:semicolon
id|lp.sched_priority
op_assign
id|p-&gt;rt_priority
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This one might sleep, we cannot do it with a spinlock held ...&n;&t; */
id|retval
op_assign
id|copy_to_user
c_func
(paren
id|param
comma
op_amp
id|lp
comma
r_sizeof
(paren
op_star
id|param
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
id|out_nounlock
suffix:colon
r_return
id|retval
suffix:semicolon
id|out_unlock
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|sys_sched_yield
id|asmlinkage
r_int
id|sys_sched_yield
c_func
(paren
r_void
)paren
(brace
id|spin_lock_irq
c_func
(paren
op_amp
id|runqueue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;policy
op_eq
id|SCHED_OTHER
)paren
id|current-&gt;policy
op_or_assign
id|SCHED_YIELD
suffix:semicolon
id|current-&gt;need_resched
op_assign
l_int|1
suffix:semicolon
id|move_last_runqueue
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|runqueue_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_sched_get_priority_max
id|asmlinkage
r_int
id|sys_sched_get_priority_max
c_func
(paren
r_int
id|policy
)paren
(brace
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|policy
)paren
(brace
r_case
id|SCHED_FIFO
suffix:colon
r_case
id|SCHED_RR
suffix:colon
id|ret
op_assign
l_int|99
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCHED_OTHER
suffix:colon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sys_sched_get_priority_min
id|asmlinkage
r_int
id|sys_sched_get_priority_min
c_func
(paren
r_int
id|policy
)paren
(brace
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|policy
)paren
(brace
r_case
id|SCHED_FIFO
suffix:colon
r_case
id|SCHED_RR
suffix:colon
id|ret
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCHED_OTHER
suffix:colon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sys_sched_rr_get_interval
id|asmlinkage
r_int
id|sys_sched_rr_get_interval
c_func
(paren
id|pid_t
id|pid
comma
r_struct
id|timespec
op_star
id|interval
)paren
(brace
r_struct
id|timespec
id|t
suffix:semicolon
id|t.tv_sec
op_assign
l_int|0
suffix:semicolon
id|t.tv_nsec
op_assign
l_int|150000
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|interval
comma
op_amp
id|t
comma
r_sizeof
(paren
r_struct
id|timespec
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_nanosleep
id|asmlinkage
r_int
id|sys_nanosleep
c_func
(paren
r_struct
id|timespec
op_star
id|rqtp
comma
r_struct
id|timespec
op_star
id|rmtp
)paren
(brace
r_struct
id|timespec
id|t
suffix:semicolon
r_int
r_int
id|expire
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|t
comma
id|rqtp
comma
r_sizeof
(paren
r_struct
id|timespec
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|t.tv_nsec
op_ge
l_int|1000000000L
op_logical_or
id|t.tv_nsec
OL
l_int|0
op_logical_or
id|t.tv_sec
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|t.tv_sec
op_eq
l_int|0
op_logical_and
id|t.tv_nsec
op_le
l_int|2000000L
op_logical_and
id|current-&gt;policy
op_ne
id|SCHED_OTHER
)paren
(brace
multiline_comment|/*&n;&t;&t; * Short delay requests up to 2 ms will be handled with&n;&t;&t; * high precision by a busy wait for all real-time processes.&n;&t;&t; *&n;&t;&t; * Its important on SMP not to do this holding locks.&n;&t;&t; */
id|udelay
c_func
(paren
(paren
id|t.tv_nsec
op_plus
l_int|999
)paren
op_div
l_int|1000
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|expire
op_assign
id|timespec_to_jiffies
c_func
(paren
op_amp
id|t
)paren
op_plus
(paren
id|t.tv_sec
op_logical_or
id|t.tv_nsec
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|expire
op_assign
id|schedule_timeout
c_func
(paren
id|expire
)paren
suffix:semicolon
r_if
c_cond
(paren
id|expire
)paren
(brace
r_if
c_cond
(paren
id|rmtp
)paren
(brace
id|jiffies_to_timespec
c_func
(paren
id|expire
comma
op_amp
id|t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|rmtp
comma
op_amp
id|t
comma
r_sizeof
(paren
r_struct
id|timespec
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|show_task
r_static
r_void
id|show_task
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_int
r_int
id|free
op_assign
l_int|0
suffix:semicolon
r_int
id|state
suffix:semicolon
r_static
r_const
r_char
op_star
id|stat_nam
(braket
)braket
op_assign
(brace
l_string|&quot;R&quot;
comma
l_string|&quot;S&quot;
comma
l_string|&quot;D&quot;
comma
l_string|&quot;Z&quot;
comma
l_string|&quot;T&quot;
comma
l_string|&quot;W&quot;
)brace
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%-8s  &quot;
comma
id|p-&gt;comm
)paren
suffix:semicolon
id|state
op_assign
id|p-&gt;state
ques
c_cond
id|ffz
c_func
(paren
op_complement
id|p-&gt;state
)paren
op_plus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|state
)paren
OL
r_sizeof
(paren
id|stat_nam
)paren
op_div
r_sizeof
(paren
r_char
op_star
)paren
)paren
id|printk
c_func
(paren
id|stat_nam
(braket
id|state
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
macro_line|#if (BITS_PER_LONG == 32)
r_if
c_cond
(paren
id|p
op_eq
id|current
)paren
id|printk
c_func
(paren
l_string|&quot; current  &quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; %08lX &quot;
comma
id|thread_saved_pc
c_func
(paren
op_amp
id|p-&gt;thread
)paren
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|p
op_eq
id|current
)paren
id|printk
c_func
(paren
l_string|&quot;   current task   &quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; %016lx &quot;
comma
id|thread_saved_pc
c_func
(paren
op_amp
id|p-&gt;thread
)paren
)paren
suffix:semicolon
macro_line|#endif
(brace
r_int
r_int
op_star
id|n
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|p
op_plus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
op_star
id|n
)paren
id|n
op_increment
suffix:semicolon
id|free
op_assign
(paren
r_int
r_int
)paren
id|n
op_minus
(paren
r_int
r_int
)paren
(paren
id|p
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%5lu %5d %6d &quot;
comma
id|free
comma
id|p-&gt;pid
comma
id|p-&gt;p_pptr-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;p_cptr
)paren
id|printk
c_func
(paren
l_string|&quot;%5d &quot;
comma
id|p-&gt;p_cptr-&gt;pid
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;      &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;mm
)paren
id|printk
c_func
(paren
l_string|&quot; (L-TLB) &quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; (NOTLB) &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;p_ysptr
)paren
id|printk
c_func
(paren
l_string|&quot;%7d&quot;
comma
id|p-&gt;p_ysptr-&gt;pid
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;       &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;p_osptr
)paren
id|printk
c_func
(paren
l_string|&quot; %5d&bslash;n&quot;
comma
id|p-&gt;p_osptr-&gt;pid
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
(brace
r_struct
id|signal_queue
op_star
id|q
suffix:semicolon
r_char
id|s
(braket
r_sizeof
(paren
id|sigset_t
)paren
op_star
l_int|2
op_plus
l_int|1
)braket
comma
id|b
(braket
r_sizeof
(paren
id|sigset_t
)paren
op_star
l_int|2
op_plus
l_int|1
)braket
suffix:semicolon
id|render_sigset_t
c_func
(paren
op_amp
id|p-&gt;signal
comma
id|s
)paren
suffix:semicolon
id|render_sigset_t
c_func
(paren
op_amp
id|p-&gt;blocked
comma
id|b
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   sig: %d %s %s :&quot;
comma
id|signal_pending
c_func
(paren
id|p
)paren
comma
id|s
comma
id|b
)paren
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
id|p-&gt;sigqueue
suffix:semicolon
id|q
suffix:semicolon
id|q
op_assign
id|q-&gt;next
)paren
id|printk
c_func
(paren
l_string|&quot; %d&quot;
comma
id|q-&gt;info.si_signo
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; X&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|render_sigset_t
r_char
op_star
id|render_sigset_t
c_func
(paren
id|sigset_t
op_star
id|set
comma
r_char
op_star
id|buffer
)paren
(brace
r_int
id|i
op_assign
id|_NSIG
comma
id|x
suffix:semicolon
r_do
(brace
id|i
op_sub_assign
l_int|4
comma
id|x
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sigismember
c_func
(paren
id|set
comma
id|i
op_plus
l_int|1
)paren
)paren
id|x
op_or_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sigismember
c_func
(paren
id|set
comma
id|i
op_plus
l_int|2
)paren
)paren
id|x
op_or_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|sigismember
c_func
(paren
id|set
comma
id|i
op_plus
l_int|3
)paren
)paren
id|x
op_or_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|sigismember
c_func
(paren
id|set
comma
id|i
op_plus
l_int|4
)paren
)paren
id|x
op_or_assign
l_int|8
suffix:semicolon
op_star
id|buffer
op_increment
op_assign
(paren
id|x
OL
l_int|10
ques
c_cond
l_char|&squot;0&squot;
suffix:colon
l_char|&squot;a&squot;
op_minus
l_int|10
)paren
op_plus
id|x
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
op_ge
l_int|4
)paren
suffix:semicolon
op_star
id|buffer
op_assign
l_int|0
suffix:semicolon
r_return
id|buffer
suffix:semicolon
)brace
DECL|function|show_state
r_void
id|show_state
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
macro_line|#if (BITS_PER_LONG == 32)
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
l_string|&quot;                         free                        sibling&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  task             PC    stack   pid father child younger older&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
l_string|&quot;                                 free                        sibling&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  task                 PC        stack   pid father child younger older&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
id|show_task
c_func
(paren
id|p
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
DECL|function|init_idle
r_void
id|__init
id|init_idle
c_func
(paren
r_void
)paren
(brace
id|cycles_t
id|t
suffix:semicolon
r_struct
id|schedule_data
op_star
id|sched_data
suffix:semicolon
id|sched_data
op_assign
op_amp
id|aligned_data
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|schedule_data
suffix:semicolon
r_if
c_cond
(paren
id|current
op_ne
op_amp
id|init_task
op_logical_and
id|task_on_runqueue
c_func
(paren
id|current
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;UGH! (%d:%d) was on the runqueue, removing.&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|del_from_runqueue
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
id|t
op_assign
id|get_cycles
c_func
(paren
)paren
suffix:semicolon
id|sched_data-&gt;curr
op_assign
id|current
suffix:semicolon
id|sched_data-&gt;last_schedule
op_assign
id|t
suffix:semicolon
)brace
DECL|function|sched_init
r_void
id|__init
id|sched_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * We have to do a little magic to get the first&n;&t; * process right in SMP mode.&n;&t; */
r_int
id|cpu
op_assign
id|hard_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|nr
suffix:semicolon
id|init_task.processor
op_assign
id|cpu
suffix:semicolon
r_for
c_loop
(paren
id|nr
op_assign
l_int|0
suffix:semicolon
id|nr
OL
id|PIDHASH_SZ
suffix:semicolon
id|nr
op_increment
)paren
(brace
id|pidhash
(braket
id|nr
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|init_bh
c_func
(paren
id|TIMER_BH
comma
id|timer_bh
)paren
suffix:semicolon
id|init_bh
c_func
(paren
id|TQUEUE_BH
comma
id|tqueue_bh
)paren
suffix:semicolon
id|init_bh
c_func
(paren
id|IMMEDIATE_BH
comma
id|immediate_bh
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The boot idle thread does lazy MMU switching as well:&n;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|init_mm.mm_count
)paren
suffix:semicolon
)brace
eof
