multiline_comment|/*&n; *  linux/kernel/sched.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; * &squot;sched.c&squot; is the main kernel file. It contains scheduling primitives&n; * (sleep_on, wakeup, schedule etc) as well as a number of simple system&n; * call functions (type getpid(), which just extracts a field from&n; * current-task&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sys.h&gt;
macro_line|#include &lt;linux/fdreg.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/segment.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
DECL|macro|TIMER_IRQ
mdefine_line|#define TIMER_IRQ 0
macro_line|#include &lt;linux/timex.h&gt;
multiline_comment|/*&n; * kernel variables&n; */
DECL|variable|tick
r_int
id|tick
op_assign
l_int|1000000
op_div
id|HZ
suffix:semicolon
multiline_comment|/* timer interrupt period */
DECL|variable|xtime
r_volatile
r_struct
id|timeval
id|xtime
suffix:semicolon
multiline_comment|/* The current time */
DECL|variable|tickadj
r_int
id|tickadj
op_assign
l_int|500
op_div
id|HZ
suffix:semicolon
multiline_comment|/* microsecs */
multiline_comment|/*&n; * phase-lock loop variables&n; */
DECL|variable|time_status
r_int
id|time_status
op_assign
id|TIME_BAD
suffix:semicolon
multiline_comment|/* clock synchronization status */
DECL|variable|time_offset
r_int
id|time_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* time adjustment (us) */
DECL|variable|time_constant
r_int
id|time_constant
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* pll time constant */
DECL|variable|time_tolerance
r_int
id|time_tolerance
op_assign
id|MAXFREQ
suffix:semicolon
multiline_comment|/* frequency tolerance (ppm) */
DECL|variable|time_precision
r_int
id|time_precision
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* clock precision (us) */
DECL|variable|time_maxerror
r_int
id|time_maxerror
op_assign
l_int|0x70000000
suffix:semicolon
multiline_comment|/* maximum error */
DECL|variable|time_esterror
r_int
id|time_esterror
op_assign
l_int|0x70000000
suffix:semicolon
multiline_comment|/* estimated error */
DECL|variable|time_phase
r_int
id|time_phase
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* phase offset (scaled us) */
DECL|variable|time_freq
r_int
id|time_freq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* frequency offset (scaled ppm) */
DECL|variable|time_adj
r_int
id|time_adj
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* tick adjust (scaled 1 / HZ) */
DECL|variable|time_reftime
r_int
id|time_reftime
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* time at last adjustment (s) */
DECL|variable|time_adjust
r_int
id|time_adjust
op_assign
l_int|0
suffix:semicolon
DECL|variable|need_resched
r_int
id|need_resched
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Tell us the machine setup..&n; */
DECL|variable|hard_math
r_int
id|hard_math
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set by boot/head.S */
DECL|variable|x86
r_int
id|x86
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set by boot/head.S to 3 or 4 */
DECL|variable|ignore_irq13
r_int
id|ignore_irq13
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set if exception 16 works */
DECL|variable|wp_works_ok
r_int
id|wp_works_ok
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set if paging hardware honours WP */
r_extern
r_int
id|_setitimer
c_func
(paren
r_int
comma
r_struct
id|itimerval
op_star
comma
r_struct
id|itimerval
op_star
)paren
suffix:semicolon
DECL|variable|prof_buffer
r_int
r_int
op_star
id|prof_buffer
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|prof_len
r_int
r_int
id|prof_len
op_assign
l_int|0
suffix:semicolon
DECL|macro|_S
mdefine_line|#define _S(nr) (1&lt;&lt;((nr)-1))
r_extern
r_void
id|mem_use
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|timer_interrupt
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_int
id|system_call
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|init_kernel_stack
r_static
r_int
r_int
id|init_kernel_stack
(braket
l_int|1024
)braket
suffix:semicolon
DECL|variable|init_task
r_struct
id|task_struct
id|init_task
op_assign
id|INIT_TASK
suffix:semicolon
DECL|variable|jiffies
r_int
r_int
r_volatile
id|jiffies
op_assign
l_int|0
suffix:semicolon
DECL|variable|current
r_struct
id|task_struct
op_star
id|current
op_assign
op_amp
id|init_task
suffix:semicolon
DECL|variable|last_task_used_math
r_struct
id|task_struct
op_star
id|last_task_used_math
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|task
r_struct
id|task_struct
op_star
id|task
(braket
id|NR_TASKS
)braket
op_assign
(brace
op_amp
id|init_task
comma
)brace
suffix:semicolon
DECL|variable|user_stack
r_int
id|user_stack
(braket
id|PAGE_SIZE
op_rshift
l_int|2
)braket
suffix:semicolon
r_struct
(brace
DECL|member|a
r_int
op_star
id|a
suffix:semicolon
DECL|member|b
r_int
id|b
suffix:semicolon
DECL|variable|stack_start
)brace
id|stack_start
op_assign
(brace
op_amp
id|user_stack
(braket
id|PAGE_SIZE
op_rshift
l_int|2
)braket
comma
id|KERNEL_DS
)brace
suffix:semicolon
multiline_comment|/*&n; * int 0x80 entry points.. Moved away from the header file, as&n; * iBCS2 may also want to use the &squot;&lt;linux/sys.h&gt;&squot; headers..&n; */
macro_line|#ifdef __cplusplus
r_extern
l_string|&quot;C&quot;
(brace
macro_line|#endif
DECL|function|sys_ni_syscall
r_int
id|sys_ni_syscall
c_func
(paren
r_void
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|variable|sys_call_table
id|fn_ptr
id|sys_call_table
(braket
)braket
op_assign
(brace
id|sys_setup
comma
id|sys_exit
comma
id|sys_fork
comma
id|sys_read
comma
id|sys_write
comma
id|sys_open
comma
id|sys_close
comma
id|sys_waitpid
comma
id|sys_creat
comma
id|sys_link
comma
id|sys_unlink
comma
id|sys_execve
comma
id|sys_chdir
comma
id|sys_time
comma
id|sys_mknod
comma
id|sys_chmod
comma
id|sys_chown
comma
id|sys_break
comma
id|sys_stat
comma
id|sys_lseek
comma
id|sys_getpid
comma
id|sys_mount
comma
id|sys_umount
comma
id|sys_setuid
comma
id|sys_getuid
comma
id|sys_stime
comma
id|sys_ptrace
comma
id|sys_alarm
comma
id|sys_fstat
comma
id|sys_pause
comma
id|sys_utime
comma
id|sys_stty
comma
id|sys_gtty
comma
id|sys_access
comma
id|sys_nice
comma
id|sys_ftime
comma
id|sys_sync
comma
id|sys_kill
comma
id|sys_rename
comma
id|sys_mkdir
comma
id|sys_rmdir
comma
id|sys_dup
comma
id|sys_pipe
comma
id|sys_times
comma
id|sys_prof
comma
id|sys_brk
comma
id|sys_setgid
comma
id|sys_getgid
comma
id|sys_signal
comma
id|sys_geteuid
comma
id|sys_getegid
comma
id|sys_acct
comma
id|sys_phys
comma
id|sys_lock
comma
id|sys_ioctl
comma
id|sys_fcntl
comma
id|sys_mpx
comma
id|sys_setpgid
comma
id|sys_ulimit
comma
id|sys_olduname
comma
id|sys_umask
comma
id|sys_chroot
comma
id|sys_ustat
comma
id|sys_dup2
comma
id|sys_getppid
comma
id|sys_getpgrp
comma
id|sys_setsid
comma
id|sys_sigaction
comma
id|sys_sgetmask
comma
id|sys_ssetmask
comma
id|sys_setreuid
comma
id|sys_setregid
comma
id|sys_sigsuspend
comma
id|sys_sigpending
comma
id|sys_sethostname
comma
id|sys_setrlimit
comma
id|sys_getrlimit
comma
id|sys_getrusage
comma
id|sys_gettimeofday
comma
id|sys_settimeofday
comma
id|sys_getgroups
comma
id|sys_setgroups
comma
id|sys_select
comma
id|sys_symlink
comma
id|sys_lstat
comma
id|sys_readlink
comma
id|sys_uselib
comma
id|sys_swapon
comma
id|sys_reboot
comma
id|sys_readdir
comma
id|sys_mmap
comma
id|sys_munmap
comma
id|sys_truncate
comma
id|sys_ftruncate
comma
id|sys_fchmod
comma
id|sys_fchown
comma
id|sys_getpriority
comma
id|sys_setpriority
comma
id|sys_profil
comma
id|sys_statfs
comma
id|sys_fstatfs
comma
id|sys_ioperm
comma
id|sys_socketcall
comma
id|sys_syslog
comma
id|sys_setitimer
comma
id|sys_getitimer
comma
id|sys_newstat
comma
id|sys_newlstat
comma
id|sys_newfstat
comma
id|sys_uname
comma
id|sys_iopl
comma
id|sys_vhangup
comma
id|sys_idle
comma
id|sys_vm86
comma
id|sys_wait4
comma
id|sys_swapoff
comma
id|sys_sysinfo
comma
id|sys_ipc
comma
id|sys_fsync
comma
id|sys_sigreturn
comma
id|sys_clone
comma
id|sys_setdomainname
comma
id|sys_newuname
comma
id|sys_modify_ldt
comma
id|sys_adjtimex
comma
id|sys_mprotect
comma
id|sys_sigprocmask
comma
id|sys_create_module
comma
id|sys_init_module
comma
id|sys_delete_module
comma
id|sys_get_kernel_syms
comma
id|sys_quotactl
)brace
suffix:semicolon
multiline_comment|/* So we don&squot;t have to do any more manual updating.... */
DECL|variable|NR_syscalls
r_int
id|NR_syscalls
op_assign
r_sizeof
(paren
id|sys_call_table
)paren
op_div
r_sizeof
(paren
id|fn_ptr
)paren
suffix:semicolon
macro_line|#ifdef __cplusplus
)brace
macro_line|#endif
multiline_comment|/*&n; *  &squot;math_state_restore()&squot; saves the current math information in the&n; * old math state array, and gets the new ones from the current task&n; *&n; * Careful.. There are problems with IBM-designed IRQ13 behaviour.&n; * Don&squot;t touch unless you *really* know how it works.&n; */
DECL|function|math_state_restore
id|asmlinkage
r_void
id|math_state_restore
c_func
(paren
r_void
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;clts&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_task_used_math
op_eq
id|current
)paren
r_return
suffix:semicolon
id|timer_table
(braket
id|COPRO_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
l_int|50
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|COPRO_TIMER
suffix:semicolon
r_if
c_cond
(paren
id|last_task_used_math
)paren
id|__asm__
c_func
(paren
l_string|&quot;fnsave %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|last_task_used_math-&gt;tss.i387
)paren
)paren
suffix:semicolon
r_else
id|__asm__
c_func
(paren
l_string|&quot;fnclex&quot;
)paren
suffix:semicolon
id|last_task_used_math
op_assign
id|current
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;used_math
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;frstor %0&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
id|current-&gt;tss.i387
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|__asm__
c_func
(paren
l_string|&quot;fninit&quot;
)paren
suffix:semicolon
id|current-&gt;used_math
op_assign
l_int|1
suffix:semicolon
)brace
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|COPRO_TIMER
)paren
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_MATH_EMULATION
DECL|function|math_emulate
id|asmlinkage
r_void
id|math_emulate
c_func
(paren
r_int
id|arg
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;math-emulation not enabled and no coprocessor found.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;killing %s.&bslash;n&quot;
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGFPE
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_MATH_EMULATION */
DECL|variable|itimer_ticks
r_static
r_int
r_int
id|itimer_ticks
op_assign
l_int|0
suffix:semicolon
DECL|variable|itimer_next
r_static
r_int
r_int
id|itimer_next
op_assign
op_complement
l_int|0
suffix:semicolon
DECL|variable|lost_ticks
r_static
r_int
r_int
id|lost_ticks
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; *  &squot;schedule()&squot; is the scheduler function. It&squot;s a very simple and nice&n; * scheduler: it&squot;s not perfect, but certainly works for most things.&n; * The one thing you might take a look at is the signal-handler code here.&n; *&n; *   NOTE!!  Task 0 is the &squot;idle&squot; task, which gets called when no other&n; * tasks can run. It can not be killed, and it cannot sleep. The &squot;state&squot;&n; * information in task[0] is never used.&n; *&n; * The &quot;confuse_gcc&quot; goto is used only to get better assembly code..&n; * Djikstra probably hates me.&n; */
DECL|function|schedule
id|asmlinkage
r_void
id|schedule
c_func
(paren
r_void
)paren
(brace
r_int
id|c
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_struct
id|task_struct
op_star
id|next
suffix:semicolon
r_int
r_int
id|ticks
suffix:semicolon
multiline_comment|/* check alarm, wake up any interruptible tasks that have got a signal */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ticks
op_assign
id|itimer_ticks
suffix:semicolon
id|itimer_ticks
op_assign
l_int|0
suffix:semicolon
id|itimer_next
op_assign
op_complement
l_int|0
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|need_resched
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
op_amp
id|init_task
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
id|p
op_assign
id|p-&gt;next_task
)paren
op_eq
op_amp
id|init_task
)paren
r_goto
id|confuse_gcc1
suffix:semicolon
r_if
c_cond
(paren
id|ticks
op_logical_and
id|p-&gt;it_real_value
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;it_real_value
op_le
id|ticks
)paren
(brace
id|send_sig
c_func
(paren
id|SIGALRM
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;it_real_incr
)paren
(brace
id|p-&gt;it_real_value
op_assign
l_int|0
suffix:semicolon
r_goto
id|end_itimer
suffix:semicolon
)brace
r_do
(brace
id|p-&gt;it_real_value
op_add_assign
id|p-&gt;it_real_incr
suffix:semicolon
)brace
r_while
c_loop
(paren
id|p-&gt;it_real_value
op_le
id|ticks
)paren
suffix:semicolon
)brace
id|p-&gt;it_real_value
op_sub_assign
id|ticks
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;it_real_value
OL
id|itimer_next
)paren
id|itimer_next
op_assign
id|p-&gt;it_real_value
suffix:semicolon
)brace
id|end_itimer
suffix:colon
r_if
c_cond
(paren
id|p-&gt;state
op_ne
id|TASK_INTERRUPTIBLE
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;signal
op_amp
op_complement
id|p-&gt;blocked
)paren
(brace
id|p-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;timeout
op_logical_and
id|p-&gt;timeout
op_le
id|jiffies
)paren
(brace
id|p-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|p-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
)brace
id|confuse_gcc1
suffix:colon
multiline_comment|/* this is the scheduler proper: */
macro_line|#if 0
multiline_comment|/* give processes that go to sleep a bit higher priority.. */
multiline_comment|/* This depends on the values for TASK_XXX */
multiline_comment|/* This gives smoother scheduling for some things, but */
multiline_comment|/* can be very unfair under some circumstances, so.. */
r_if
c_cond
(paren
id|TASK_UNINTERRUPTIBLE
op_ge
(paren
r_int
)paren
id|current-&gt;state
op_logical_and
id|current-&gt;counter
OL
id|current-&gt;priority
op_star
l_int|2
)paren
(brace
op_increment
id|current-&gt;counter
suffix:semicolon
)brace
macro_line|#endif
id|c
op_assign
op_minus
l_int|1
suffix:semicolon
id|next
op_assign
id|p
op_assign
op_amp
id|init_task
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
id|p
op_assign
id|p-&gt;next_task
)paren
op_eq
op_amp
id|init_task
)paren
r_goto
id|confuse_gcc2
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;state
op_eq
id|TASK_RUNNING
op_logical_and
id|p-&gt;counter
OG
id|c
)paren
id|c
op_assign
id|p-&gt;counter
comma
id|next
op_assign
id|p
suffix:semicolon
)brace
id|confuse_gcc2
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
id|for_each_task
c_func
(paren
id|p
)paren
id|p-&gt;counter
op_assign
(paren
id|p-&gt;counter
op_rshift
l_int|1
)paren
op_plus
id|p-&gt;priority
suffix:semicolon
)brace
id|switch_to
c_func
(paren
id|next
)paren
suffix:semicolon
multiline_comment|/* Now maybe reload the debug registers */
r_if
c_cond
(paren
id|current-&gt;debugreg
(braket
l_int|7
)braket
)paren
(brace
id|loaddebug
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|loaddebug
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|loaddebug
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|loaddebug
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|loaddebug
c_func
(paren
l_int|6
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
DECL|function|sys_pause
id|asmlinkage
r_int
id|sys_pause
c_func
(paren
r_void
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTNOHAND
suffix:semicolon
)brace
multiline_comment|/*&n; * wake_up doesn&squot;t wake up stopped processes - they have to be awakened&n; * with signals or similar.&n; *&n; * Note that this doesn&squot;t need cli-sti pairs: interrupts may not change&n; * the wait-queue structures directly, but only call wake_up() to wake&n; * a process. The process itself must remove the queue once it has woken.&n; */
DECL|function|wake_up
r_void
id|wake_up
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|q
)paren
(brace
r_struct
id|wait_queue
op_star
id|tmp
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
op_logical_or
op_logical_neg
(paren
id|tmp
op_assign
op_star
id|q
)paren
)paren
r_return
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|p
op_assign
id|tmp-&gt;task
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|p-&gt;state
op_eq
id|TASK_UNINTERRUPTIBLE
)paren
op_logical_or
(paren
id|p-&gt;state
op_eq
id|TASK_INTERRUPTIBLE
)paren
)paren
(brace
id|p-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;counter
OG
id|current-&gt;counter
)paren
id|need_resched
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmp-&gt;next
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;wait_queue is bad (eip = %08lx)&bslash;n&quot;
comma
(paren
(paren
r_int
r_int
op_star
)paren
id|q
)paren
(braket
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        q = %p&bslash;n&quot;
comma
id|q
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;       *q = %p&bslash;n&quot;
comma
op_star
id|q
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;      tmp = %p&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
op_star
id|q
)paren
suffix:semicolon
)brace
DECL|function|wake_up_interruptible
r_void
id|wake_up_interruptible
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|q
)paren
(brace
r_struct
id|wait_queue
op_star
id|tmp
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
op_logical_or
op_logical_neg
(paren
id|tmp
op_assign
op_star
id|q
)paren
)paren
r_return
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|p
op_assign
id|tmp-&gt;task
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;state
op_eq
id|TASK_INTERRUPTIBLE
)paren
(brace
id|p-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;counter
OG
id|current-&gt;counter
)paren
id|need_resched
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmp-&gt;next
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;wait_queue is bad (eip = %08lx)&bslash;n&quot;
comma
(paren
(paren
r_int
r_int
op_star
)paren
id|q
)paren
(braket
op_minus
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        q = %p&bslash;n&quot;
comma
id|q
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;       *q = %p&bslash;n&quot;
comma
op_star
id|q
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;      tmp = %p&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
op_star
id|q
)paren
suffix:semicolon
)brace
DECL|function|__sleep_on
r_static
r_inline
r_void
id|__sleep_on
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|p
comma
r_int
id|state
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|current
op_eq
id|task
(braket
l_int|0
)braket
)paren
id|panic
c_func
(paren
l_string|&quot;task[0] trying to sleep&quot;
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|state
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|p
comma
op_amp
id|wait
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|p
comma
op_amp
id|wait
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|interruptible_sleep_on
r_void
id|interruptible_sleep_on
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|p
)paren
(brace
id|__sleep_on
c_func
(paren
id|p
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
)brace
DECL|function|sleep_on
r_void
id|sleep_on
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|p
)paren
(brace
id|__sleep_on
c_func
(paren
id|p
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
)brace
DECL|variable|next_timer
r_static
r_struct
id|timer_list
op_star
id|next_timer
op_assign
l_int|NULL
suffix:semicolon
DECL|function|add_timer
r_void
id|add_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|timer_list
op_star
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timer
)paren
r_return
suffix:semicolon
id|timer-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|p
op_assign
op_amp
id|next_timer
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|expires
OG
id|timer-&gt;expires
)paren
(brace
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|expires
op_sub_assign
id|timer-&gt;expires
suffix:semicolon
id|timer-&gt;next
op_assign
op_star
id|p
suffix:semicolon
r_break
suffix:semicolon
)brace
id|timer-&gt;expires
op_sub_assign
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|expires
suffix:semicolon
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
op_star
id|p
op_assign
id|timer
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|del_timer
r_int
id|del_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|expires
op_assign
l_int|0
suffix:semicolon
r_struct
id|timer_list
op_star
op_star
id|p
suffix:semicolon
id|p
op_assign
op_amp
id|next_timer
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
op_star
id|p
op_eq
id|timer
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|p
op_assign
id|timer-&gt;next
)paren
op_ne
l_int|NULL
)paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|expires
op_add_assign
id|timer-&gt;expires
suffix:semicolon
id|timer-&gt;expires
op_add_assign
id|expires
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|expires
op_add_assign
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|expires
suffix:semicolon
id|p
op_assign
op_amp
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|timer_active
r_int
r_int
id|timer_active
op_assign
l_int|0
suffix:semicolon
DECL|variable|timer_table
r_struct
id|timer_struct
id|timer_table
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/*&n; * Hmm.. Changed this, as the GNU make sources (load.c) seems to&n; * imply that avenrun[] is the standard name for this kind of thing.&n; * Nothing else seems to be standardized: the fractional size etc&n; * all seem to differ on different machines.&n; */
DECL|variable|avenrun
r_int
r_int
id|avenrun
(braket
l_int|3
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * Nr of active tasks - counted in fixed-point numbers&n; */
DECL|function|count_active_tasks
r_static
r_int
r_int
id|count_active_tasks
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
op_star
id|p
suffix:semicolon
r_int
r_int
id|nr
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|LAST_TASK
suffix:semicolon
id|p
OG
op_amp
id|FIRST_TASK
suffix:semicolon
op_decrement
id|p
)paren
r_if
c_cond
(paren
op_star
id|p
op_logical_and
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|state
op_eq
id|TASK_RUNNING
op_logical_or
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|state
op_eq
id|TASK_UNINTERRUPTIBLE
op_logical_or
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|state
op_eq
id|TASK_SWAPPING
)paren
)paren
id|nr
op_add_assign
id|FIXED_1
suffix:semicolon
r_return
id|nr
suffix:semicolon
)brace
DECL|function|calc_load
r_static
r_inline
r_void
id|calc_load
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|active_tasks
suffix:semicolon
multiline_comment|/* fixed-point */
r_static
r_int
id|count
op_assign
id|LOAD_FREQ
suffix:semicolon
r_if
c_cond
(paren
id|count
op_decrement
OG
l_int|0
)paren
r_return
suffix:semicolon
id|count
op_assign
id|LOAD_FREQ
suffix:semicolon
id|active_tasks
op_assign
id|count_active_tasks
c_func
(paren
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|0
)braket
comma
id|EXP_1
comma
id|active_tasks
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|1
)braket
comma
id|EXP_5
comma
id|active_tasks
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|2
)braket
comma
id|EXP_15
comma
id|active_tasks
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * this routine handles the overflow of the microsecond field&n; *&n; * The tricky bits of code to handle the accurate clock support&n; * were provided by Dave Mills (Mills@UDEL.EDU) of NTP fame.&n; * They were originally developed for SUN and DEC kernels.&n; * All the kudos should go to Dave for this stuff.&n; *&n; * These were ported to Linux by Philip Gladstone.&n; */
DECL|function|second_overflow
r_static
r_void
id|second_overflow
c_func
(paren
r_void
)paren
(brace
r_int
id|ltemp
suffix:semicolon
multiline_comment|/* last time the cmos clock got updated */
r_static
r_int
id|last_rtc_update
op_assign
l_int|0
suffix:semicolon
r_extern
r_int
id|set_rtc_mmss
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* Bump the maxerror field */
id|time_maxerror
op_assign
(paren
l_int|0x70000000
op_minus
id|time_maxerror
OL
id|time_tolerance
)paren
ques
c_cond
l_int|0x70000000
suffix:colon
(paren
id|time_maxerror
op_plus
id|time_tolerance
)paren
suffix:semicolon
multiline_comment|/* Run the PLL */
r_if
c_cond
(paren
id|time_offset
OL
l_int|0
)paren
(brace
id|ltemp
op_assign
(paren
op_minus
(paren
id|time_offset
op_plus
l_int|1
)paren
op_rshift
(paren
id|SHIFT_KG
op_plus
id|time_constant
)paren
)paren
op_plus
l_int|1
suffix:semicolon
id|time_adj
op_assign
id|ltemp
op_lshift
(paren
id|SHIFT_SCALE
op_minus
id|SHIFT_HZ
op_minus
id|SHIFT_UPDATE
)paren
suffix:semicolon
id|time_offset
op_add_assign
(paren
id|time_adj
op_star
id|HZ
)paren
op_rshift
(paren
id|SHIFT_SCALE
op_minus
id|SHIFT_UPDATE
)paren
suffix:semicolon
id|time_adj
op_assign
op_minus
id|time_adj
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|time_offset
OG
l_int|0
)paren
(brace
id|ltemp
op_assign
(paren
(paren
id|time_offset
op_minus
l_int|1
)paren
op_rshift
(paren
id|SHIFT_KG
op_plus
id|time_constant
)paren
)paren
op_plus
l_int|1
suffix:semicolon
id|time_adj
op_assign
id|ltemp
op_lshift
(paren
id|SHIFT_SCALE
op_minus
id|SHIFT_HZ
op_minus
id|SHIFT_UPDATE
)paren
suffix:semicolon
id|time_offset
op_sub_assign
(paren
id|time_adj
op_star
id|HZ
)paren
op_rshift
(paren
id|SHIFT_SCALE
op_minus
id|SHIFT_UPDATE
)paren
suffix:semicolon
)brace
r_else
(brace
id|time_adj
op_assign
l_int|0
suffix:semicolon
)brace
id|time_adj
op_add_assign
(paren
id|time_freq
op_rshift
(paren
id|SHIFT_KF
op_plus
id|SHIFT_HZ
op_minus
id|SHIFT_SCALE
)paren
)paren
op_plus
id|FINETUNE
suffix:semicolon
multiline_comment|/* Handle the leap second stuff */
r_switch
c_cond
(paren
id|time_status
)paren
(brace
r_case
id|TIME_INS
suffix:colon
multiline_comment|/* ugly divide should be replaced */
r_if
c_cond
(paren
id|xtime.tv_sec
op_mod
l_int|86400
op_eq
l_int|0
)paren
(brace
id|xtime.tv_sec
op_decrement
suffix:semicolon
multiline_comment|/* !! */
id|time_status
op_assign
id|TIME_OOP
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Clock: inserting leap second 23:59:60 GMT&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIME_DEL
suffix:colon
multiline_comment|/* ugly divide should be replaced */
r_if
c_cond
(paren
id|xtime.tv_sec
op_mod
l_int|86400
op_eq
l_int|86399
)paren
(brace
id|xtime.tv_sec
op_increment
suffix:semicolon
id|time_status
op_assign
id|TIME_OK
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Clock: deleting leap second 23:59:59 GMT&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIME_OOP
suffix:colon
id|time_status
op_assign
id|TIME_OK
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xtime.tv_sec
OG
id|last_rtc_update
op_plus
l_int|660
)paren
r_if
c_cond
(paren
id|set_rtc_mmss
c_func
(paren
id|xtime.tv_sec
)paren
op_eq
l_int|0
)paren
id|last_rtc_update
op_assign
id|xtime.tv_sec
suffix:semicolon
)brace
multiline_comment|/*&n; * disregard lost ticks for now.. We don&squot;t care enough.&n; */
DECL|function|timer_bh
r_static
r_void
id|timer_bh
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_struct
id|timer_struct
op_star
id|tp
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|next_timer
op_logical_and
id|next_timer-&gt;expires
op_eq
l_int|0
)paren
(brace
r_void
(paren
op_star
id|fn
)paren
(paren
r_int
r_int
)paren
op_assign
id|next_timer-&gt;function
suffix:semicolon
r_int
r_int
id|data
op_assign
id|next_timer-&gt;data
suffix:semicolon
id|next_timer
op_assign
id|next_timer-&gt;next
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|fn
c_func
(paren
id|data
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mask
op_assign
l_int|1
comma
id|tp
op_assign
id|timer_table
op_plus
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|tp
op_increment
comma
id|mask
op_add_assign
id|mask
)paren
(brace
r_if
c_cond
(paren
id|mask
OG
id|timer_active
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mask
op_amp
id|timer_active
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;expires
OG
id|jiffies
)paren
r_continue
suffix:semicolon
id|timer_active
op_and_assign
op_complement
id|mask
suffix:semicolon
id|tp
op_member_access_from_pointer
id|fn
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The int argument is really a (struct pt_regs *), in case the&n; * interrupt wants to know from where it was called. The timer&n; * irq uses this to decide if it should update the user or system&n; * times.&n; */
DECL|function|do_timer
r_static
r_void
id|do_timer
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_struct
id|timer_struct
op_star
id|tp
suffix:semicolon
r_int
id|ltemp
suffix:semicolon
multiline_comment|/* Advance the phase, once it gets to one microsecond, then&n;&t; * advance the tick more.&n;&t; */
id|time_phase
op_add_assign
id|time_adj
suffix:semicolon
r_if
c_cond
(paren
id|time_phase
OL
op_minus
id|FINEUSEC
)paren
(brace
id|ltemp
op_assign
op_minus
id|time_phase
op_rshift
id|SHIFT_SCALE
suffix:semicolon
id|time_phase
op_add_assign
id|ltemp
op_lshift
id|SHIFT_SCALE
suffix:semicolon
id|xtime.tv_usec
op_add_assign
id|tick
op_minus
id|ltemp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|time_phase
OG
id|FINEUSEC
)paren
(brace
id|ltemp
op_assign
id|time_phase
op_rshift
id|SHIFT_SCALE
suffix:semicolon
id|time_phase
op_sub_assign
id|ltemp
op_lshift
id|SHIFT_SCALE
suffix:semicolon
id|xtime.tv_usec
op_add_assign
id|tick
op_plus
id|ltemp
suffix:semicolon
)brace
r_else
id|xtime.tv_usec
op_add_assign
id|tick
suffix:semicolon
r_if
c_cond
(paren
id|time_adjust
)paren
(brace
multiline_comment|/* We are doing an adjtime thing. &n;&t;     */
multiline_comment|/* Limit the amount of the step for *next* tick to be&n;&t;     * in the range -tickadj .. +tickadj&n;&t;     */
r_if
c_cond
(paren
id|time_adjust
OG
id|tickadj
)paren
id|ltemp
op_assign
id|tickadj
suffix:semicolon
r_else
r_if
c_cond
(paren
id|time_adjust
OL
op_minus
id|tickadj
)paren
id|ltemp
op_assign
op_minus
id|tickadj
suffix:semicolon
r_else
id|ltemp
op_assign
id|time_adjust
suffix:semicolon
multiline_comment|/* Reduce the amount of time left by this step */
id|time_adjust
op_sub_assign
id|ltemp
suffix:semicolon
multiline_comment|/* Modify the value of the tick for next time.&n;&t;     * Note that a positive delta means we want the clock&n;&t;     * to run fast. This means that the tick should be bigger&n;&t;     */
id|tick
op_assign
l_int|1000000
op_div
id|HZ
op_plus
id|ltemp
suffix:semicolon
)brace
r_else
id|tick
op_assign
l_int|1000000
op_div
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|xtime.tv_usec
op_ge
l_int|1000000
)paren
(brace
id|xtime.tv_usec
op_sub_assign
l_int|1000000
suffix:semicolon
id|xtime.tv_sec
op_increment
suffix:semicolon
id|second_overflow
c_func
(paren
)paren
suffix:semicolon
)brace
id|jiffies
op_increment
suffix:semicolon
id|calc_load
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|VM_MASK
op_amp
id|regs-&gt;eflags
)paren
op_logical_or
(paren
l_int|3
op_amp
id|regs-&gt;cs
)paren
)paren
(brace
id|current-&gt;utime
op_increment
suffix:semicolon
multiline_comment|/* Update ITIMER_VIRT for current task if not in a system call */
r_if
c_cond
(paren
id|current-&gt;it_virt_value
op_logical_and
op_logical_neg
(paren
op_decrement
id|current-&gt;it_virt_value
)paren
)paren
(brace
id|current-&gt;it_virt_value
op_assign
id|current-&gt;it_virt_incr
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGVTALRM
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|current-&gt;stime
op_increment
suffix:semicolon
macro_line|#ifdef CONFIG_PROFILE
r_if
c_cond
(paren
id|prof_buffer
op_logical_and
id|current
op_ne
id|task
(braket
l_int|0
)braket
)paren
(brace
r_int
r_int
id|eip
op_assign
id|regs-&gt;eip
suffix:semicolon
id|eip
op_rshift_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|eip
OL
id|prof_len
)paren
id|prof_buffer
(braket
id|eip
)braket
op_increment
suffix:semicolon
)brace
macro_line|#endif
)brace
r_if
c_cond
(paren
id|current
op_eq
id|task
(braket
l_int|0
)braket
op_logical_or
(paren
op_decrement
id|current-&gt;counter
)paren
op_le
l_int|0
)paren
(brace
id|current-&gt;counter
op_assign
l_int|0
suffix:semicolon
id|need_resched
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Update ITIMER_PROF for the current task */
r_if
c_cond
(paren
id|current-&gt;it_prof_value
op_logical_and
op_logical_neg
(paren
op_decrement
id|current-&gt;it_prof_value
)paren
)paren
(brace
id|current-&gt;it_prof_value
op_assign
id|current-&gt;it_prof_incr
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGPROF
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|mask
op_assign
l_int|1
comma
id|tp
op_assign
id|timer_table
op_plus
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|tp
op_increment
comma
id|mask
op_add_assign
id|mask
)paren
(brace
r_if
c_cond
(paren
id|mask
OG
id|timer_active
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mask
op_amp
id|timer_active
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;expires
OG
id|jiffies
)paren
r_continue
suffix:semicolon
id|mark_bh
c_func
(paren
id|TIMER_BH
)paren
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|itimer_ticks
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|itimer_ticks
OG
id|itimer_next
)paren
id|need_resched
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|next_timer
)paren
(brace
r_if
c_cond
(paren
id|next_timer-&gt;expires
)paren
(brace
id|next_timer-&gt;expires
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|next_timer-&gt;expires
)paren
id|mark_bh
c_func
(paren
id|TIMER_BH
)paren
suffix:semicolon
)brace
r_else
(brace
id|lost_ticks
op_increment
suffix:semicolon
id|mark_bh
c_func
(paren
id|TIMER_BH
)paren
suffix:semicolon
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|sys_alarm
id|asmlinkage
r_int
id|sys_alarm
c_func
(paren
r_int
id|seconds
)paren
(brace
r_struct
id|itimerval
id|it_new
comma
id|it_old
suffix:semicolon
id|it_new.it_interval.tv_sec
op_assign
id|it_new.it_interval.tv_usec
op_assign
l_int|0
suffix:semicolon
id|it_new.it_value.tv_sec
op_assign
id|seconds
suffix:semicolon
id|it_new.it_value.tv_usec
op_assign
l_int|0
suffix:semicolon
id|_setitimer
c_func
(paren
id|ITIMER_REAL
comma
op_amp
id|it_new
comma
op_amp
id|it_old
)paren
suffix:semicolon
r_return
id|it_old.it_value.tv_sec
op_plus
(paren
id|it_old.it_value.tv_usec
op_div
l_int|1000000
)paren
suffix:semicolon
)brace
DECL|function|sys_getpid
id|asmlinkage
r_int
id|sys_getpid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;pid
suffix:semicolon
)brace
DECL|function|sys_getppid
id|asmlinkage
r_int
id|sys_getppid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;p_opptr-&gt;pid
suffix:semicolon
)brace
DECL|function|sys_getuid
id|asmlinkage
r_int
id|sys_getuid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;uid
suffix:semicolon
)brace
DECL|function|sys_geteuid
id|asmlinkage
r_int
id|sys_geteuid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;euid
suffix:semicolon
)brace
DECL|function|sys_getgid
id|asmlinkage
r_int
id|sys_getgid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;gid
suffix:semicolon
)brace
DECL|function|sys_getegid
id|asmlinkage
r_int
id|sys_getegid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;egid
suffix:semicolon
)brace
DECL|function|sys_nice
id|asmlinkage
r_int
id|sys_nice
c_func
(paren
r_int
id|increment
)paren
(brace
r_int
id|newprio
suffix:semicolon
r_if
c_cond
(paren
id|increment
OL
l_int|0
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|newprio
op_assign
id|current-&gt;priority
op_minus
id|increment
suffix:semicolon
r_if
c_cond
(paren
id|newprio
OL
l_int|1
)paren
id|newprio
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|newprio
OG
l_int|35
)paren
id|newprio
op_assign
l_int|35
suffix:semicolon
id|current-&gt;priority
op_assign
id|newprio
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|show_task
r_static
r_void
id|show_task
c_func
(paren
r_int
id|nr
comma
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_static
r_char
op_star
id|stat_nam
(braket
)braket
op_assign
(brace
l_string|&quot;R&quot;
comma
l_string|&quot;S&quot;
comma
l_string|&quot;D&quot;
comma
l_string|&quot;Z&quot;
comma
l_string|&quot;T&quot;
comma
l_string|&quot;W&quot;
)brace
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%-8s %3d &quot;
comma
id|p-&gt;comm
comma
(paren
id|p
op_eq
id|current
)paren
ques
c_cond
op_minus
id|nr
suffix:colon
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|p-&gt;state
)paren
OL
r_sizeof
(paren
id|stat_nam
)paren
op_div
r_sizeof
(paren
r_char
op_star
)paren
)paren
id|printk
c_func
(paren
id|stat_nam
(braket
id|p-&gt;state
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
id|current
)paren
id|printk
c_func
(paren
l_string|&quot; current  &quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; %08lX &quot;
comma
(paren
(paren
r_int
r_int
op_star
)paren
id|p-&gt;tss.esp
)paren
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%5lu %5d %6d &quot;
comma
id|p-&gt;tss.esp
op_minus
id|p-&gt;kernel_stack_page
comma
id|p-&gt;pid
comma
id|p-&gt;p_pptr-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;p_cptr
)paren
id|printk
c_func
(paren
l_string|&quot;%5d &quot;
comma
id|p-&gt;p_cptr-&gt;pid
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;      &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;p_ysptr
)paren
id|printk
c_func
(paren
l_string|&quot;%7d&quot;
comma
id|p-&gt;p_ysptr-&gt;pid
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;       &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;p_osptr
)paren
id|printk
c_func
(paren
l_string|&quot; %5d&bslash;n&quot;
comma
id|p-&gt;p_osptr-&gt;pid
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|show_state
r_void
id|show_state
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                         free                        sibling&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  task             PC    stack   pid father child younger older&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_TASKS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|task
(braket
id|i
)braket
)paren
id|show_task
c_func
(paren
id|i
comma
id|task
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|function|sched_init
r_void
id|sched_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|desc_struct
op_star
id|p
suffix:semicolon
id|bh_base
(braket
id|TIMER_BH
)braket
dot
id|routine
op_assign
id|timer_bh
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|sigaction
)paren
op_ne
l_int|16
)paren
id|panic
c_func
(paren
l_string|&quot;Struct sigaction MUST be 16 bytes&quot;
)paren
suffix:semicolon
id|set_tss_desc
c_func
(paren
id|gdt
op_plus
id|FIRST_TSS_ENTRY
comma
op_amp
id|init_task.tss
)paren
suffix:semicolon
id|set_ldt_desc
c_func
(paren
id|gdt
op_plus
id|FIRST_LDT_ENTRY
comma
op_amp
id|default_ldt
comma
l_int|1
)paren
suffix:semicolon
id|set_system_gate
c_func
(paren
l_int|0x80
comma
op_amp
id|system_call
)paren
suffix:semicolon
id|p
op_assign
id|gdt
op_plus
l_int|2
op_plus
id|FIRST_TSS_ENTRY
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|NR_TASKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|task
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;a
op_assign
id|p-&gt;b
op_assign
l_int|0
suffix:semicolon
id|p
op_increment
suffix:semicolon
id|p-&gt;a
op_assign
id|p-&gt;b
op_assign
l_int|0
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
multiline_comment|/* Clear NT, so that we won&squot;t have troubles with that later on */
id|__asm__
c_func
(paren
l_string|&quot;pushfl ; andl $0xffffbfff,(%esp) ; popfl&quot;
)paren
suffix:semicolon
id|load_TR
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|load_ldt
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x34
comma
l_int|0x43
)paren
suffix:semicolon
multiline_comment|/* binary, mode 2, LSB/MSB, ch 0 */
id|outb_p
c_func
(paren
id|LATCH
op_amp
l_int|0xff
comma
l_int|0x40
)paren
suffix:semicolon
multiline_comment|/* LSB */
id|outb
c_func
(paren
id|LATCH
op_rshift
l_int|8
comma
l_int|0x40
)paren
suffix:semicolon
multiline_comment|/* MSB */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|TIMER_IRQ
comma
(paren
r_void
(paren
op_star
)paren
(paren
r_int
)paren
)paren
id|do_timer
)paren
op_ne
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Could not allocate timer IRQ!&quot;
)paren
suffix:semicolon
)brace
eof
