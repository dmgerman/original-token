multiline_comment|/*&n; *  linux/kernel/sched.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; * &squot;sched.c&squot; is the main kernel file. It contains scheduling primitives&n; * (sleep_on, wakeup, schedule etc) as well as a number of simple system&n; * call functions (type getpid(), which just extracts a field from&n; * current-task&n; */
DECL|macro|TIMER_IRQ
mdefine_line|#define TIMER_IRQ 0
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sys.h&gt;
macro_line|#include &lt;linux/fdreg.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
DECL|variable|need_resched
r_int
id|need_resched
op_assign
l_int|0
suffix:semicolon
DECL|variable|hard_math
r_int
id|hard_math
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set by boot/head.S */
DECL|variable|prof_buffer
r_int
r_int
op_star
id|prof_buffer
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|prof_len
r_int
r_int
id|prof_len
op_assign
l_int|0
suffix:semicolon
DECL|macro|_S
mdefine_line|#define _S(nr) (1&lt;&lt;((nr)-1))
DECL|macro|_BLOCKABLE
mdefine_line|#define _BLOCKABLE (~(_S(SIGKILL) | _S(SIGSTOP)))
DECL|function|show_task
r_static
r_void
id|show_task
c_func
(paren
r_int
id|nr
comma
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_int
id|i
comma
id|j
op_assign
l_int|4096
op_minus
r_sizeof
(paren
r_struct
id|task_struct
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d: pid=%d, state=%d, father=%d, child=%d, &quot;
comma
(paren
id|p
op_eq
id|current
)paren
ques
op_minus
id|nr
suffix:colon
id|nr
comma
id|p-&gt;pid
comma
id|p-&gt;state
comma
id|p-&gt;p_pptr-&gt;pid
comma
id|p-&gt;p_cptr
ques
c_cond
id|p-&gt;p_cptr-&gt;pid
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|j
op_logical_and
op_logical_neg
(paren
(paren
r_char
op_star
)paren
(paren
id|p
op_plus
l_int|1
)paren
)paren
(braket
id|i
)braket
)paren
id|i
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d/%d chars free in kstack&bslash;n&bslash;r&quot;
comma
id|i
comma
id|j
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   PC=%08X.&quot;
comma
op_star
(paren
l_int|1019
op_plus
(paren
r_int
r_int
op_star
)paren
id|p
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;p_ysptr
op_logical_or
id|p-&gt;p_osptr
)paren
id|printk
c_func
(paren
l_string|&quot;   Younger sib=%d, older sib=%d&bslash;n&bslash;r&quot;
comma
id|p-&gt;p_ysptr
ques
c_cond
id|p-&gt;p_ysptr-&gt;pid
suffix:colon
op_minus
l_int|1
comma
id|p-&gt;p_osptr
ques
c_cond
id|p-&gt;p_osptr-&gt;pid
suffix:colon
op_minus
l_int|1
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&bslash;r&quot;
)paren
suffix:semicolon
)brace
DECL|function|show_state
r_void
id|show_state
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;rTask-info:&bslash;n&bslash;r&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_TASKS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|task
(braket
id|i
)braket
)paren
id|show_task
c_func
(paren
id|i
comma
id|task
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|macro|LATCH
mdefine_line|#define LATCH (1193180/HZ)
r_extern
r_void
id|mem_use
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|timer_interrupt
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|system_call
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|union|task_union
r_union
id|task_union
(brace
DECL|member|task
r_struct
id|task_struct
id|task
suffix:semicolon
DECL|member|stack
r_char
id|stack
(braket
id|PAGE_SIZE
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|init_task
r_static
r_union
id|task_union
id|init_task
op_assign
(brace
id|INIT_TASK
comma
)brace
suffix:semicolon
DECL|variable|jiffies
r_int
r_int
r_volatile
id|jiffies
op_assign
l_int|0
suffix:semicolon
DECL|variable|startup_time
r_int
r_int
id|startup_time
op_assign
l_int|0
suffix:semicolon
DECL|variable|jiffies_offset
r_int
id|jiffies_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* # clock ticks to add to get &quot;true&n;&t;&t;&t;&t;   time&quot;.  Should always be less than&n;&t;&t;&t;&t;   1 second&squot;s worth.  For time fanatics&n;&t;&t;&t;&t;   who like to syncronize their machines&n;&t;&t;&t;&t;   to WWV :-) */
DECL|variable|current
r_struct
id|task_struct
op_star
id|current
op_assign
op_amp
(paren
id|init_task.task
)paren
suffix:semicolon
DECL|variable|last_task_used_math
r_struct
id|task_struct
op_star
id|last_task_used_math
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|task
r_struct
id|task_struct
op_star
id|task
(braket
id|NR_TASKS
)braket
op_assign
(brace
op_amp
(paren
id|init_task.task
)paren
comma
)brace
suffix:semicolon
DECL|variable|user_stack
r_int
id|user_stack
(braket
id|PAGE_SIZE
op_rshift
l_int|2
)braket
suffix:semicolon
r_struct
(brace
DECL|member|a
r_int
op_star
id|a
suffix:semicolon
DECL|member|b
r_int
id|b
suffix:semicolon
DECL|variable|stack_start
)brace
id|stack_start
op_assign
(brace
op_amp
id|user_stack
(braket
id|PAGE_SIZE
op_rshift
l_int|2
)braket
comma
l_int|0x10
)brace
suffix:semicolon
multiline_comment|/*&n; *  &squot;math_state_restore()&squot; saves the current math information in the&n; * old math state array, and gets the new ones from the current task&n; */
DECL|function|math_state_restore
r_void
id|math_state_restore
c_func
(paren
)paren
(brace
r_if
c_cond
(paren
id|last_task_used_math
op_eq
id|current
)paren
r_return
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;fwait&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_task_used_math
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;fnsave %0&quot;
op_scope_resolution
l_string|&quot;m&quot;
(paren
id|last_task_used_math-&gt;tss.i387
)paren
)paren
suffix:semicolon
)brace
id|last_task_used_math
op_assign
id|current
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;used_math
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;frstor %0&quot;
op_scope_resolution
l_string|&quot;m&quot;
(paren
id|current-&gt;tss.i387
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|__asm__
c_func
(paren
l_string|&quot;fninit&quot;
op_scope_resolution
)paren
suffix:semicolon
id|current-&gt;used_math
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  &squot;schedule()&squot; is the scheduler function. It&squot;s a very simple and nice&n; * scheduler: it&squot;s not perfect, but certainly works for most things.&n; * The one thing you might take a look at is the signal-handler code here.&n; *&n; *   NOTE!!  Task 0 is the &squot;idle&squot; task, which gets called when no other&n; * tasks can run. It can not be killed, and it cannot sleep. The &squot;state&squot;&n; * information in task[0] is never used.&n; */
DECL|function|schedule
r_void
id|schedule
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|next
comma
id|c
suffix:semicolon
r_struct
id|task_struct
op_star
op_star
id|p
suffix:semicolon
multiline_comment|/* check alarm, wake up any interruptible tasks that have got a signal */
id|need_resched
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|LAST_TASK
suffix:semicolon
id|p
OG
op_amp
id|FIRST_TASK
suffix:semicolon
op_decrement
id|p
)paren
r_if
c_cond
(paren
op_star
id|p
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|timeout
op_logical_and
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|timeout
OL
id|jiffies
)paren
r_if
c_cond
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|state
op_eq
id|TASK_INTERRUPTIBLE
)paren
(brace
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|timeout
op_assign
l_int|0
suffix:semicolon
id|wake_one_task
c_func
(paren
op_star
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|signal
op_amp
op_complement
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|blocked
)paren
op_logical_and
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|state
op_eq
id|TASK_INTERRUPTIBLE
)paren
id|wake_one_task
c_func
(paren
op_star
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/* this is the scheduler proper: */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|c
op_assign
op_minus
l_int|1
suffix:semicolon
id|next
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|NR_TASKS
suffix:semicolon
id|p
op_assign
op_amp
id|task
(braket
id|NR_TASKS
)braket
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|i
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
op_decrement
id|p
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|state
op_eq
id|TASK_RUNNING
op_logical_and
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|counter
OG
id|c
)paren
id|c
op_assign
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|counter
comma
id|next
op_assign
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
)paren
r_break
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|LAST_TASK
suffix:semicolon
id|p
OG
op_amp
id|FIRST_TASK
suffix:semicolon
op_decrement
id|p
)paren
r_if
c_cond
(paren
op_star
id|p
)paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|counter
op_assign
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|counter
op_rshift
l_int|1
)paren
op_plus
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|priority
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|switch_to
c_func
(paren
id|next
)paren
suffix:semicolon
)brace
DECL|function|sys_pause
r_int
id|sys_pause
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|old_blocked
suffix:semicolon
r_int
r_int
id|mask
suffix:semicolon
r_struct
id|sigaction
op_star
id|sa
op_assign
id|current-&gt;sigaction
suffix:semicolon
id|old_blocked
op_assign
id|current-&gt;blocked
suffix:semicolon
r_for
c_loop
(paren
id|mask
op_assign
l_int|1
suffix:semicolon
id|mask
suffix:semicolon
id|sa
op_increment
comma
id|mask
op_add_assign
id|mask
)paren
r_if
c_cond
(paren
id|sa-&gt;sa_handler
op_eq
id|SIG_IGN
)paren
id|current-&gt;blocked
op_or_assign
id|mask
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;blocked
op_assign
id|old_blocked
suffix:semicolon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
DECL|function|wake_one_task
r_void
id|wake_one_task
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|p-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;counter
OG
id|current-&gt;counter
)paren
id|need_resched
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * wake_up doesn&squot;t wake up stopped processes - they have to be awakened&n; * with signals or similar.&n; *&n; * Note that this doesn&squot;t need cli-sti pairs: interrupts may not change&n; * the wait-queue structures directly, but only call wake_up() to wake&n; * a process. The process itself must remove the queue once it has woken.&n; */
DECL|function|wake_up
r_void
id|wake_up
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|q
)paren
(brace
r_struct
id|wait_queue
op_star
id|tmp
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
op_logical_or
op_logical_neg
(paren
id|tmp
op_assign
op_star
id|q
)paren
)paren
r_return
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|p
op_assign
id|tmp-&gt;task
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;state
op_eq
id|TASK_ZOMBIE
)paren
id|printk
c_func
(paren
l_string|&quot;wake_up: TASK_ZOMBIE&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|p-&gt;state
op_ne
id|TASK_STOPPED
)paren
(brace
id|p-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;counter
OG
id|current-&gt;counter
)paren
id|need_resched
op_assign
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
op_logical_neg
id|tmp-&gt;next
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;wait_queue is bad&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        q = %08x&bslash;n&quot;
comma
id|q
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;       *q = %08x&bslash;n&quot;
comma
op_star
id|q
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;      tmp = %08x&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
op_star
id|q
)paren
suffix:semicolon
)brace
DECL|function|__sleep_on
r_static
r_inline
r_void
id|__sleep_on
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|p
comma
r_int
id|state
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|current
op_eq
id|task
(braket
l_int|0
)braket
)paren
id|panic
c_func
(paren
l_string|&quot;task[0] trying to sleep&quot;
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|state
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|p
comma
op_amp
id|current-&gt;wait
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|p
comma
op_amp
id|current-&gt;wait
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|interruptible_sleep_on
r_void
id|interruptible_sleep_on
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|p
)paren
(brace
id|__sleep_on
c_func
(paren
id|p
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
)brace
DECL|function|sleep_on
r_void
id|sleep_on
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|p
)paren
(brace
id|__sleep_on
c_func
(paren
id|p
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * OK, here are some floppy things that shouldn&squot;t be in the kernel&n; * proper. They are here because the floppy needs a timer, and this&n; * was the easiest way of doing it.&n; */
DECL|variable|wait_motor
r_static
r_struct
id|wait_queue
op_star
id|wait_motor
(braket
l_int|4
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|mon_timer
r_static
r_int
id|mon_timer
(braket
l_int|4
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|moff_timer
r_static
r_int
id|moff_timer
(braket
l_int|4
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|current_DOR
r_int
r_char
id|current_DOR
op_assign
l_int|0x0C
suffix:semicolon
DECL|function|ticks_to_floppy_on
r_int
id|ticks_to_floppy_on
c_func
(paren
r_int
r_int
id|nr
)paren
(brace
r_extern
r_int
r_char
id|selected
suffix:semicolon
r_int
r_char
id|mask
op_assign
l_int|0x10
op_lshift
id|nr
suffix:semicolon
r_if
c_cond
(paren
id|nr
OG
l_int|3
)paren
id|panic
c_func
(paren
l_string|&quot;floppy_on: nr&gt;3&quot;
)paren
suffix:semicolon
id|moff_timer
(braket
id|nr
)braket
op_assign
l_int|10000
suffix:semicolon
multiline_comment|/* 100 s = very big :-) */
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* use floppy_off to turn it off */
id|mask
op_or_assign
id|current_DOR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|selected
)paren
(brace
id|mask
op_and_assign
l_int|0xFC
suffix:semicolon
id|mask
op_or_assign
id|nr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mask
op_ne
id|current_DOR
)paren
(brace
id|outb
c_func
(paren
id|mask
comma
id|FD_DOR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mask
op_xor
id|current_DOR
)paren
op_amp
l_int|0xf0
)paren
id|mon_timer
(braket
id|nr
)braket
op_assign
id|HZ
op_div
l_int|2
suffix:semicolon
r_else
r_if
c_cond
(paren
id|mon_timer
(braket
id|nr
)braket
OL
l_int|2
)paren
id|mon_timer
(braket
id|nr
)braket
op_assign
l_int|2
suffix:semicolon
id|current_DOR
op_assign
id|mask
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
id|mon_timer
(braket
id|nr
)braket
suffix:semicolon
)brace
DECL|function|floppy_off
r_void
id|floppy_off
c_func
(paren
r_int
r_int
id|nr
)paren
(brace
id|moff_timer
(braket
id|nr
)braket
op_assign
l_int|3
op_star
id|HZ
suffix:semicolon
)brace
DECL|function|do_floppy_timer
r_void
id|do_floppy_timer
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|mask
op_assign
l_int|0x10
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
comma
id|mask
op_lshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|mask
op_amp
id|current_DOR
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|mon_timer
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|mon_timer
(braket
id|i
)braket
)paren
id|wake_up
c_func
(paren
id|i
op_plus
id|wait_motor
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|moff_timer
(braket
id|i
)braket
)paren
(brace
id|current_DOR
op_and_assign
op_complement
id|mask
suffix:semicolon
id|outb
c_func
(paren
id|current_DOR
comma
id|FD_DOR
)paren
suffix:semicolon
)brace
r_else
id|moff_timer
(braket
id|i
)braket
op_decrement
suffix:semicolon
)brace
)brace
DECL|macro|TIME_REQUESTS
mdefine_line|#define TIME_REQUESTS 64
DECL|struct|timer_list
r_static
r_struct
id|timer_list
(brace
DECL|member|jiffies
r_int
id|jiffies
suffix:semicolon
DECL|member|fn
r_void
(paren
op_star
id|fn
)paren
(paren
)paren
suffix:semicolon
DECL|member|next
r_struct
id|timer_list
op_star
id|next
suffix:semicolon
DECL|variable|timer_list
)brace
id|timer_list
(braket
id|TIME_REQUESTS
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|NULL
comma
l_int|NULL
)brace
comma
)brace
suffix:semicolon
DECL|variable|next_timer
r_static
r_struct
id|timer_list
op_star
id|next_timer
op_assign
l_int|NULL
suffix:semicolon
DECL|function|add_timer
r_void
id|add_timer
c_func
(paren
r_int
id|jiffies
comma
r_void
(paren
op_star
id|fn
)paren
(paren
r_void
)paren
)paren
(brace
r_struct
id|timer_list
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fn
)paren
r_return
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
op_le
l_int|0
)paren
(paren
id|fn
)paren
(paren
)paren
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|p
op_assign
id|timer_list
suffix:semicolon
id|p
OL
id|timer_list
op_plus
id|TIME_REQUESTS
suffix:semicolon
id|p
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;fn
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ge
id|timer_list
op_plus
id|TIME_REQUESTS
)paren
id|panic
c_func
(paren
l_string|&quot;No more time requests free&quot;
)paren
suffix:semicolon
id|p-&gt;fn
op_assign
id|fn
suffix:semicolon
id|p-&gt;jiffies
op_assign
id|jiffies
suffix:semicolon
id|p-&gt;next
op_assign
id|next_timer
suffix:semicolon
id|next_timer
op_assign
id|p
suffix:semicolon
r_while
c_loop
(paren
id|p-&gt;next
op_logical_and
id|p-&gt;next-&gt;jiffies
OL
id|p-&gt;jiffies
)paren
(brace
id|p-&gt;jiffies
op_sub_assign
id|p-&gt;next-&gt;jiffies
suffix:semicolon
id|fn
op_assign
id|p-&gt;fn
suffix:semicolon
id|p-&gt;fn
op_assign
id|p-&gt;next-&gt;fn
suffix:semicolon
id|p-&gt;next-&gt;fn
op_assign
id|fn
suffix:semicolon
id|jiffies
op_assign
id|p-&gt;jiffies
suffix:semicolon
id|p-&gt;jiffies
op_assign
id|p-&gt;next-&gt;jiffies
suffix:semicolon
id|p-&gt;next-&gt;jiffies
op_assign
id|jiffies
suffix:semicolon
id|p
op_assign
id|p-&gt;next
suffix:semicolon
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|timer_active
r_int
r_int
id|timer_active
op_assign
l_int|0
suffix:semicolon
DECL|variable|timer_table
r_struct
id|timer_struct
id|timer_table
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/*&n; * Hmm.. Changed this, as the GNU make sources (load.c) seems to&n; * imply that avenrun[] is the standard name for this kind of thing.&n; * Nothing else seems to be standardized: the fractional size etc&n; * all seem to differ on different machines.&n; */
DECL|variable|avenrun
r_int
r_int
id|avenrun
(braket
l_int|3
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * Nr of active tasks - counted in fixed-point numbers&n; */
DECL|function|count_active_tasks
r_static
r_int
r_int
id|count_active_tasks
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
op_star
id|p
suffix:semicolon
r_int
r_int
id|nr
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|LAST_TASK
suffix:semicolon
id|p
OG
op_amp
id|FIRST_TASK
suffix:semicolon
op_decrement
id|p
)paren
r_if
c_cond
(paren
op_star
id|p
op_logical_and
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|state
op_eq
id|TASK_RUNNING
)paren
id|nr
op_add_assign
id|FIXED_1
suffix:semicolon
r_return
id|nr
suffix:semicolon
)brace
DECL|function|calc_load
r_static
r_inline
r_void
id|calc_load
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|active_tasks
suffix:semicolon
multiline_comment|/* fixed-point */
r_static
r_int
id|count
op_assign
id|LOAD_FREQ
suffix:semicolon
r_if
c_cond
(paren
id|count
op_decrement
OG
l_int|0
)paren
r_return
suffix:semicolon
id|count
op_assign
id|LOAD_FREQ
suffix:semicolon
id|active_tasks
op_assign
id|count_active_tasks
c_func
(paren
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|0
)braket
comma
id|EXP_1
comma
id|active_tasks
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|1
)braket
comma
id|EXP_5
comma
id|active_tasks
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|2
)braket
comma
id|EXP_15
comma
id|active_tasks
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The int argument is really a (struct pt_regs *), in case the&n; * interrupt wants to know from where it was called. The timer&n; * irq uses this to decide if it should update the user or system&n; * times.&n; */
DECL|function|do_timer
r_static
r_void
id|do_timer
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_struct
id|timer_struct
op_star
id|tp
op_assign
id|timer_table
op_plus
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
op_star
id|task_p
suffix:semicolon
id|jiffies
op_increment
suffix:semicolon
id|calc_load
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|VM_MASK
op_amp
id|regs-&gt;eflags
)paren
op_logical_or
(paren
l_int|3
op_amp
id|regs-&gt;cs
)paren
)paren
(brace
id|current-&gt;utime
op_increment
suffix:semicolon
multiline_comment|/* Update ITIMER_VIRT for current task if not in a system call */
r_if
c_cond
(paren
id|current-&gt;it_virt_value
op_logical_and
op_logical_neg
(paren
op_decrement
id|current-&gt;it_virt_value
)paren
)paren
(brace
id|current-&gt;it_virt_value
op_assign
id|current-&gt;it_virt_incr
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGVTALRM
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|current-&gt;stime
op_increment
suffix:semicolon
macro_line|#ifdef PROFILE_SHIFT
r_if
c_cond
(paren
id|prof_buffer
op_logical_and
id|current
op_ne
id|task
(braket
l_int|0
)braket
)paren
(brace
r_int
r_int
id|eip
op_assign
id|regs-&gt;eip
suffix:semicolon
id|eip
op_rshift_assign
id|PROFILE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|eip
OL
id|prof_len
)paren
id|prof_buffer
(braket
id|eip
)braket
op_increment
suffix:semicolon
)brace
macro_line|#endif
)brace
r_if
c_cond
(paren
id|current
op_eq
id|task
(braket
l_int|0
)braket
op_logical_or
(paren
op_decrement
id|current-&gt;counter
)paren
op_le
l_int|0
)paren
(brace
id|current-&gt;counter
op_assign
l_int|0
suffix:semicolon
id|need_resched
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Update ITIMER_REAL for every task */
r_for
c_loop
(paren
id|task_p
op_assign
op_amp
id|LAST_TASK
suffix:semicolon
id|task_p
op_ge
op_amp
id|FIRST_TASK
suffix:semicolon
id|task_p
op_decrement
)paren
r_if
c_cond
(paren
op_star
id|task_p
op_logical_and
(paren
op_star
id|task_p
)paren
op_member_access_from_pointer
id|it_real_value
op_logical_and
op_logical_neg
(paren
op_decrement
(paren
op_star
id|task_p
)paren
op_member_access_from_pointer
id|it_real_value
)paren
)paren
(brace
id|send_sig
c_func
(paren
id|SIGALRM
comma
op_star
id|task_p
comma
l_int|1
)paren
suffix:semicolon
(paren
op_star
id|task_p
)paren
op_member_access_from_pointer
id|it_real_value
op_assign
(paren
op_star
id|task_p
)paren
op_member_access_from_pointer
id|it_real_incr
suffix:semicolon
id|need_resched
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Update ITIMER_PROF for the current task */
r_if
c_cond
(paren
id|current-&gt;it_prof_value
op_logical_and
op_logical_neg
(paren
op_decrement
id|current-&gt;it_prof_value
)paren
)paren
(brace
id|current-&gt;it_prof_value
op_assign
id|current-&gt;it_prof_incr
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGPROF
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|mask
op_assign
l_int|1
suffix:semicolon
id|mask
suffix:semicolon
id|tp
op_increment
comma
id|mask
op_add_assign
id|mask
)paren
(brace
r_if
c_cond
(paren
id|mask
OG
id|timer_active
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mask
op_amp
id|timer_active
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;expires
OG
id|jiffies
)paren
r_continue
suffix:semicolon
id|timer_active
op_and_assign
op_complement
id|mask
suffix:semicolon
id|tp
op_member_access_from_pointer
id|fn
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|next_timer
)paren
(brace
id|next_timer-&gt;jiffies
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|next_timer
op_logical_and
id|next_timer-&gt;jiffies
op_le
l_int|0
)paren
(brace
r_void
(paren
op_star
id|fn
)paren
(paren
r_void
)paren
suffix:semicolon
id|fn
op_assign
id|next_timer-&gt;fn
suffix:semicolon
id|next_timer-&gt;fn
op_assign
l_int|NULL
suffix:semicolon
id|next_timer
op_assign
id|next_timer-&gt;next
suffix:semicolon
(paren
id|fn
)paren
(paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|current_DOR
op_amp
l_int|0xf0
)paren
id|do_floppy_timer
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|sys_alarm
r_int
id|sys_alarm
c_func
(paren
r_int
id|seconds
)paren
(brace
r_extern
r_int
id|_setitimer
c_func
(paren
r_int
comma
r_struct
id|itimerval
op_star
comma
r_struct
id|itimerval
op_star
)paren
suffix:semicolon
r_struct
id|itimerval
r_new
comma
id|old
suffix:semicolon
r_new
dot
id|it_interval.tv_sec
op_assign
r_new
dot
id|it_interval.tv_usec
op_assign
l_int|0
suffix:semicolon
r_new
dot
id|it_value.tv_sec
op_assign
id|seconds
suffix:semicolon
r_new
dot
id|it_value.tv_usec
op_assign
l_int|0
suffix:semicolon
id|_setitimer
c_func
(paren
id|ITIMER_REAL
comma
op_amp
r_new
comma
op_amp
id|old
)paren
suffix:semicolon
r_return
id|old.it_value.tv_sec
op_plus
(paren
id|old.it_value.tv_usec
op_div
l_int|1000000
)paren
suffix:semicolon
)brace
DECL|function|sys_getpid
r_int
id|sys_getpid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;pid
suffix:semicolon
)brace
DECL|function|sys_getppid
r_int
id|sys_getppid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;p_pptr-&gt;pid
suffix:semicolon
)brace
DECL|function|sys_getuid
r_int
id|sys_getuid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;uid
suffix:semicolon
)brace
DECL|function|sys_geteuid
r_int
id|sys_geteuid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;euid
suffix:semicolon
)brace
DECL|function|sys_getgid
r_int
id|sys_getgid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;gid
suffix:semicolon
)brace
DECL|function|sys_getegid
r_int
id|sys_getegid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;egid
suffix:semicolon
)brace
DECL|function|sys_nice
r_int
id|sys_nice
c_func
(paren
r_int
id|increment
)paren
(brace
r_if
c_cond
(paren
id|increment
OL
l_int|0
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|increment
op_ge
id|current-&gt;priority
)paren
id|increment
op_assign
id|current-&gt;priority
op_minus
l_int|1
suffix:semicolon
id|current-&gt;priority
op_sub_assign
id|increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sched_init
r_void
id|sched_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|desc_struct
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|sigaction
)paren
op_ne
l_int|16
)paren
id|panic
c_func
(paren
l_string|&quot;Struct sigaction MUST be 16 bytes&quot;
)paren
suffix:semicolon
id|set_tss_desc
c_func
(paren
id|gdt
op_plus
id|FIRST_TSS_ENTRY
comma
op_amp
(paren
id|init_task.task.tss
)paren
)paren
suffix:semicolon
id|set_ldt_desc
c_func
(paren
id|gdt
op_plus
id|FIRST_LDT_ENTRY
comma
op_amp
(paren
id|init_task.task.ldt
)paren
)paren
suffix:semicolon
id|set_system_gate
c_func
(paren
l_int|0x80
comma
op_amp
id|system_call
)paren
suffix:semicolon
id|p
op_assign
id|gdt
op_plus
l_int|2
op_plus
id|FIRST_TSS_ENTRY
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|NR_TASKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|task
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;a
op_assign
id|p-&gt;b
op_assign
l_int|0
suffix:semicolon
id|p
op_increment
suffix:semicolon
id|p-&gt;a
op_assign
id|p-&gt;b
op_assign
l_int|0
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
multiline_comment|/* Clear NT, so that we won&squot;t have troubles with that later on */
id|__asm__
c_func
(paren
l_string|&quot;pushfl ; andl $0xffffbfff,(%esp) ; popfl&quot;
)paren
suffix:semicolon
id|ltr
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|lldt
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x36
comma
l_int|0x43
)paren
suffix:semicolon
multiline_comment|/* binary, mode 3, LSB/MSB, ch 0 */
id|outb_p
c_func
(paren
id|LATCH
op_amp
l_int|0xff
comma
l_int|0x40
)paren
suffix:semicolon
multiline_comment|/* LSB */
id|outb
c_func
(paren
id|LATCH
op_rshift
l_int|8
comma
l_int|0x40
)paren
suffix:semicolon
multiline_comment|/* MSB */
id|request_irq
c_func
(paren
id|TIMER_IRQ
comma
(paren
r_void
(paren
op_star
)paren
(paren
r_int
)paren
)paren
id|do_timer
)paren
suffix:semicolon
)brace
eof
