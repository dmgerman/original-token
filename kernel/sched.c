multiline_comment|/*&n; *  linux/kernel/sched.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; * &squot;sched.c&squot; is the main kernel file. It contains scheduling primitives&n; * (sleep_on, wakeup, schedule etc) as well as a number of simple system&n; * call functions (type getpid(), which just extracts a field from&n; * current-task&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/fdreg.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/resource.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
DECL|macro|TIMER_IRQ
mdefine_line|#define TIMER_IRQ 0
macro_line|#include &lt;linux/timex.h&gt;
multiline_comment|/*&n; * kernel variables&n; */
DECL|variable|tick
r_int
id|tick
op_assign
l_int|1000000
op_div
id|HZ
suffix:semicolon
multiline_comment|/* timer interrupt period */
DECL|variable|xtime
r_volatile
r_struct
id|timeval
id|xtime
suffix:semicolon
multiline_comment|/* The current time */
DECL|variable|tickadj
r_int
id|tickadj
op_assign
l_int|500
op_div
id|HZ
suffix:semicolon
multiline_comment|/* microsecs */
DECL|variable|tq_timer
id|DECLARE_TASK_QUEUE
c_func
(paren
id|tq_timer
)paren
suffix:semicolon
DECL|variable|tq_immediate
id|DECLARE_TASK_QUEUE
c_func
(paren
id|tq_immediate
)paren
suffix:semicolon
DECL|variable|tq_scheduler
id|DECLARE_TASK_QUEUE
c_func
(paren
id|tq_scheduler
)paren
suffix:semicolon
multiline_comment|/*&n; * phase-lock loop variables&n; */
DECL|variable|time_status
r_int
id|time_status
op_assign
id|TIME_BAD
suffix:semicolon
multiline_comment|/* clock synchronization status */
DECL|variable|time_offset
r_int
id|time_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* time adjustment (us) */
DECL|variable|time_constant
r_int
id|time_constant
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* pll time constant */
DECL|variable|time_tolerance
r_int
id|time_tolerance
op_assign
id|MAXFREQ
suffix:semicolon
multiline_comment|/* frequency tolerance (ppm) */
DECL|variable|time_precision
r_int
id|time_precision
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* clock precision (us) */
DECL|variable|time_maxerror
r_int
id|time_maxerror
op_assign
l_int|0x70000000
suffix:semicolon
multiline_comment|/* maximum error */
DECL|variable|time_esterror
r_int
id|time_esterror
op_assign
l_int|0x70000000
suffix:semicolon
multiline_comment|/* estimated error */
DECL|variable|time_phase
r_int
id|time_phase
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* phase offset (scaled us) */
DECL|variable|time_freq
r_int
id|time_freq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* frequency offset (scaled ppm) */
DECL|variable|time_adj
r_int
id|time_adj
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* tick adjust (scaled 1 / HZ) */
DECL|variable|time_reftime
r_int
id|time_reftime
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* time at last adjustment (s) */
DECL|variable|time_adjust
r_int
id|time_adjust
op_assign
l_int|0
suffix:semicolon
DECL|variable|time_adjust_step
r_int
id|time_adjust_step
op_assign
l_int|0
suffix:semicolon
DECL|variable|need_resched
r_int
id|need_resched
op_assign
l_int|0
suffix:semicolon
DECL|variable|event
r_int
r_int
id|event
op_assign
l_int|0
suffix:semicolon
r_extern
r_int
id|_setitimer
c_func
(paren
r_int
comma
r_struct
id|itimerval
op_star
comma
r_struct
id|itimerval
op_star
)paren
suffix:semicolon
DECL|variable|prof_buffer
r_int
r_int
op_star
id|prof_buffer
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|prof_len
r_int
r_int
id|prof_len
op_assign
l_int|0
suffix:semicolon
DECL|macro|_S
mdefine_line|#define _S(nr) (1&lt;&lt;((nr)-1))
r_extern
r_void
id|mem_use
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|timer_interrupt
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|init_kernel_stack
r_static
r_int
r_int
id|init_kernel_stack
(braket
l_int|1024
)braket
op_assign
(brace
id|STACK_MAGIC
comma
)brace
suffix:semicolon
DECL|variable|init_user_stack
r_int
r_int
id|init_user_stack
(braket
l_int|1024
)braket
op_assign
(brace
id|STACK_MAGIC
comma
)brace
suffix:semicolon
DECL|variable|init_mmap
r_static
r_struct
id|vm_area_struct
id|init_mmap
op_assign
id|INIT_MMAP
suffix:semicolon
DECL|variable|init_task
r_struct
id|task_struct
id|init_task
op_assign
id|INIT_TASK
suffix:semicolon
DECL|variable|jiffies
r_int
r_int
r_volatile
id|jiffies
op_assign
l_int|0
suffix:semicolon
DECL|variable|current
r_struct
id|task_struct
op_star
id|current
op_assign
op_amp
id|init_task
suffix:semicolon
DECL|variable|last_task_used_math
r_struct
id|task_struct
op_star
id|last_task_used_math
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|task
r_struct
id|task_struct
op_star
id|task
(braket
id|NR_TASKS
)braket
op_assign
(brace
op_amp
id|init_task
comma
)brace
suffix:semicolon
DECL|variable|kstat
r_struct
id|kernel_stat
id|kstat
op_assign
(brace
l_int|0
)brace
suffix:semicolon
DECL|function|add_to_runqueue
r_static
r_inline
r_void
id|add_to_runqueue
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
macro_line|#if 1&t;/* sanity tests */
r_if
c_cond
(paren
id|p-&gt;next_run
op_logical_or
id|p-&gt;prev_run
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;task already on run-queue&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|p-&gt;counter
OG
id|current-&gt;counter
op_plus
l_int|3
)paren
id|need_resched
op_assign
l_int|1
suffix:semicolon
id|nr_running
op_increment
suffix:semicolon
(paren
id|p-&gt;next_run
op_assign
id|init_task.next_run
)paren
op_member_access_from_pointer
id|prev_run
op_assign
id|p
suffix:semicolon
id|p-&gt;prev_run
op_assign
op_amp
id|init_task
suffix:semicolon
id|init_task.next_run
op_assign
id|p
suffix:semicolon
)brace
DECL|function|del_from_runqueue
r_static
r_inline
r_void
id|del_from_runqueue
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_struct
id|task_struct
op_star
id|next
op_assign
id|p-&gt;next_run
suffix:semicolon
r_struct
id|task_struct
op_star
id|prev
op_assign
id|p-&gt;prev_run
suffix:semicolon
macro_line|#if 1&t;/* sanity tests */
r_if
c_cond
(paren
op_logical_neg
id|next
op_logical_or
op_logical_neg
id|prev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;task not on run-queue&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|p
op_eq
op_amp
id|init_task
)paren
(brace
r_static
r_int
id|nr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nr
OL
l_int|5
)paren
(brace
id|nr
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;idle task may not sleep&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|nr_running
op_decrement
suffix:semicolon
id|next-&gt;prev_run
op_assign
id|prev
suffix:semicolon
id|prev-&gt;next_run
op_assign
id|next
suffix:semicolon
id|p-&gt;next_run
op_assign
l_int|NULL
suffix:semicolon
id|p-&gt;prev_run
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Wake up a process. Put it on the run-queue if it&squot;s not&n; * already there.  The &quot;current&quot; process is always on the&n; * run-queue (except when the actual re-schedule is in&n; * progress), and as such you&squot;re allowed to do the simpler&n; * &quot;current-&gt;state = TASK_RUNNING&quot; to mark yourself runnable&n; * without the overhead of this.&n; */
DECL|function|wake_up_process
r_inline
r_void
id|wake_up_process
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|p-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;next_run
)paren
id|add_to_runqueue
c_func
(paren
id|p
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|process_timeout
r_static
r_void
id|process_timeout
c_func
(paren
r_int
r_int
id|__data
)paren
(brace
r_struct
id|task_struct
op_star
id|p
op_assign
(paren
r_struct
id|task_struct
op_star
)paren
id|__data
suffix:semicolon
id|p-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|wake_up_process
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  &squot;schedule()&squot; is the scheduler function. It&squot;s a very simple and nice&n; * scheduler: it&squot;s not perfect, but certainly works for most things.&n; *&n; * The goto is &quot;interesting&quot;.&n; *&n; *   NOTE!!  Task 0 is the &squot;idle&squot; task, which gets called when no other&n; * tasks can run. It can not be killed, and it cannot sleep. The &squot;state&squot;&n; * information in task[0] is never used.&n; */
DECL|function|schedule
id|asmlinkage
r_void
id|schedule
c_func
(paren
r_void
)paren
(brace
r_int
id|c
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_struct
id|task_struct
op_star
id|next
suffix:semicolon
r_int
r_int
id|timeout
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* check alarm, wake up any interruptible tasks that have got a signal */
r_if
c_cond
(paren
id|intr_count
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Aiee: scheduling in interrupt&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_scheduler
)paren
suffix:semicolon
id|need_resched
op_assign
l_int|0
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|current-&gt;state
)paren
(brace
r_case
id|TASK_INTERRUPTIBLE
suffix:colon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
r_goto
id|makerunnable
suffix:semicolon
id|timeout
op_assign
id|current-&gt;timeout
suffix:semicolon
r_if
c_cond
(paren
id|timeout
op_logical_and
(paren
id|timeout
op_le
id|jiffies
)paren
)paren
(brace
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|timeout
op_assign
l_int|0
suffix:semicolon
id|makerunnable
suffix:colon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|del_from_runqueue
c_func
(paren
id|current
)paren
suffix:semicolon
r_case
id|TASK_RUNNING
suffix:colon
)brace
id|p
op_assign
id|init_task.next_run
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n; * Note! there may appear new tasks on the run-queue during this, as&n; * interrupts are enabled. However, they will be put on front of the&n; * list, so our list starting at &quot;p&quot; is essentially fixed.&n; */
multiline_comment|/* this is the scheduler proper: */
id|c
op_assign
op_minus
l_int|1000
suffix:semicolon
id|next
op_assign
op_amp
id|init_task
suffix:semicolon
r_while
c_loop
(paren
id|p
op_ne
op_amp
id|init_task
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;counter
OG
id|c
)paren
id|c
op_assign
id|p-&gt;counter
comma
id|next
op_assign
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next_run
suffix:semicolon
)brace
multiline_comment|/* if all runnable processes have &quot;counter == 0&quot;, re-calculate counters */
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
id|for_each_task
c_func
(paren
id|p
)paren
id|p-&gt;counter
op_assign
(paren
id|p-&gt;counter
op_rshift
l_int|1
)paren
op_plus
id|p-&gt;priority
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current
op_ne
id|next
)paren
(brace
r_struct
id|timer_list
id|timer
suffix:semicolon
id|kstat.context_swtch
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|timeout
)paren
(brace
id|init_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|timer.expires
op_assign
id|timeout
suffix:semicolon
id|timer.data
op_assign
(paren
r_int
r_int
)paren
id|current
suffix:semicolon
id|timer.function
op_assign
id|process_timeout
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
)brace
id|switch_to
c_func
(paren
id|next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timeout
)paren
id|del_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
)brace
)brace
DECL|function|sys_pause
id|asmlinkage
r_int
id|sys_pause
c_func
(paren
r_void
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTNOHAND
suffix:semicolon
)brace
multiline_comment|/*&n; * wake_up doesn&squot;t wake up stopped processes - they have to be awakened&n; * with signals or similar.&n; *&n; * Note that this doesn&squot;t need cli-sti pairs: interrupts may not change&n; * the wait-queue structures directly, but only call wake_up() to wake&n; * a process. The process itself must remove the queue once it has woken.&n; */
DECL|function|wake_up
r_void
id|wake_up
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|q
)paren
(brace
r_struct
id|wait_queue
op_star
id|tmp
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
op_logical_or
op_logical_neg
(paren
id|tmp
op_assign
op_star
id|q
)paren
)paren
r_return
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|p
op_assign
id|tmp-&gt;task
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|p-&gt;state
op_eq
id|TASK_UNINTERRUPTIBLE
)paren
op_logical_or
(paren
id|p-&gt;state
op_eq
id|TASK_INTERRUPTIBLE
)paren
)paren
id|wake_up_process
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmp-&gt;next
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;wait_queue is bad (eip = %p)&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        q = %p&bslash;n&quot;
comma
id|q
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;       *q = %p&bslash;n&quot;
comma
op_star
id|q
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;      tmp = %p&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
op_star
id|q
)paren
suffix:semicolon
)brace
DECL|function|wake_up_interruptible
r_void
id|wake_up_interruptible
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|q
)paren
(brace
r_struct
id|wait_queue
op_star
id|tmp
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
op_logical_or
op_logical_neg
(paren
id|tmp
op_assign
op_star
id|q
)paren
)paren
r_return
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|p
op_assign
id|tmp-&gt;task
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;state
op_eq
id|TASK_INTERRUPTIBLE
)paren
id|wake_up_process
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmp-&gt;next
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;wait_queue is bad (eip = %p)&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;        q = %p&bslash;n&quot;
comma
id|q
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;       *q = %p&bslash;n&quot;
comma
op_star
id|q
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;      tmp = %p&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tmp
op_ne
op_star
id|q
)paren
suffix:semicolon
)brace
DECL|function|__down
r_void
id|__down
c_func
(paren
r_struct
id|semaphore
op_star
id|sem
)paren
(brace
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
r_while
c_loop
(paren
id|sem-&gt;count
op_le
l_int|0
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|sem-&gt;wait
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
DECL|function|__sleep_on
r_static
r_inline
r_void
id|__sleep_on
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|p
comma
r_int
id|state
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|current
op_eq
id|task
(braket
l_int|0
)braket
)paren
id|panic
c_func
(paren
l_string|&quot;task[0] trying to sleep&quot;
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|state
suffix:semicolon
id|add_wait_queue
c_func
(paren
id|p
comma
op_amp
id|wait
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
id|p
comma
op_amp
id|wait
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|interruptible_sleep_on
r_void
id|interruptible_sleep_on
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|p
)paren
(brace
id|__sleep_on
c_func
(paren
id|p
comma
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
)brace
DECL|function|sleep_on
r_void
id|sleep_on
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|p
)paren
(brace
id|__sleep_on
c_func
(paren
id|p
comma
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The head for the timer-list has a &quot;expires&quot; field of MAX_UINT,&n; * and the sorting routine counts on this..&n; */
DECL|variable|timer_head
r_static
r_struct
id|timer_list
id|timer_head
op_assign
(brace
op_amp
id|timer_head
comma
op_amp
id|timer_head
comma
op_complement
l_int|0
comma
l_int|0
comma
l_int|NULL
)brace
suffix:semicolon
DECL|macro|SLOW_BUT_DEBUGGING_TIMERS
mdefine_line|#define SLOW_BUT_DEBUGGING_TIMERS 1
DECL|function|add_timer
r_void
id|add_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|timer_list
op_star
id|p
suffix:semicolon
macro_line|#if SLOW_BUT_DEBUGGING_TIMERS
r_if
c_cond
(paren
id|timer-&gt;next
op_logical_or
id|timer-&gt;prev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;add_timer() called with non-zero list from %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|p
op_assign
op_amp
id|timer_head
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
id|p
op_assign
id|p-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|timer-&gt;expires
OG
id|p-&gt;expires
)paren
suffix:semicolon
id|timer-&gt;next
op_assign
id|p
suffix:semicolon
id|timer-&gt;prev
op_assign
id|p-&gt;prev
suffix:semicolon
id|p-&gt;prev
op_assign
id|timer
suffix:semicolon
id|timer-&gt;prev-&gt;next
op_assign
id|timer
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|del_timer
r_int
id|del_timer
c_func
(paren
r_struct
id|timer_list
op_star
id|timer
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if SLOW_BUT_DEBUGGING_TIMERS
r_struct
id|timer_list
op_star
id|p
suffix:semicolon
id|p
op_assign
op_amp
id|timer_head
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|p
op_assign
id|p-&gt;next
)paren
op_ne
op_amp
id|timer_head
)paren
(brace
r_if
c_cond
(paren
id|p
op_eq
id|timer
)paren
(brace
id|timer-&gt;next-&gt;prev
op_assign
id|timer-&gt;prev
suffix:semicolon
id|timer-&gt;prev-&gt;next
op_assign
id|timer-&gt;next
suffix:semicolon
id|timer-&gt;next
op_assign
id|timer-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|timer-&gt;next
op_logical_or
id|timer-&gt;prev
)paren
id|printk
c_func
(paren
l_string|&quot;del_timer() called from %p with timer not initialized&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#else&t;
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer-&gt;next
)paren
(brace
id|timer-&gt;next-&gt;prev
op_assign
id|timer-&gt;prev
suffix:semicolon
id|timer-&gt;prev-&gt;next
op_assign
id|timer-&gt;next
suffix:semicolon
id|timer-&gt;next
op_assign
id|timer-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|timer_active
r_int
r_int
id|timer_active
op_assign
l_int|0
suffix:semicolon
DECL|variable|timer_table
r_struct
id|timer_struct
id|timer_table
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/*&n; * Hmm.. Changed this, as the GNU make sources (load.c) seems to&n; * imply that avenrun[] is the standard name for this kind of thing.&n; * Nothing else seems to be standardized: the fractional size etc&n; * all seem to differ on different machines.&n; */
DECL|variable|avenrun
r_int
r_int
id|avenrun
(braket
l_int|3
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * Nr of active tasks - counted in fixed-point numbers&n; */
DECL|function|count_active_tasks
r_static
r_int
r_int
id|count_active_tasks
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
op_star
id|p
suffix:semicolon
r_int
r_int
id|nr
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|LAST_TASK
suffix:semicolon
id|p
OG
op_amp
id|FIRST_TASK
suffix:semicolon
op_decrement
id|p
)paren
r_if
c_cond
(paren
op_star
id|p
op_logical_and
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|state
op_eq
id|TASK_RUNNING
op_logical_or
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|state
op_eq
id|TASK_UNINTERRUPTIBLE
op_logical_or
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|state
op_eq
id|TASK_SWAPPING
)paren
)paren
id|nr
op_add_assign
id|FIXED_1
suffix:semicolon
r_return
id|nr
suffix:semicolon
)brace
DECL|function|calc_load
r_static
r_inline
r_void
id|calc_load
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|active_tasks
suffix:semicolon
multiline_comment|/* fixed-point */
r_static
r_int
id|count
op_assign
id|LOAD_FREQ
suffix:semicolon
r_if
c_cond
(paren
id|count
op_decrement
OG
l_int|0
)paren
r_return
suffix:semicolon
id|count
op_assign
id|LOAD_FREQ
suffix:semicolon
id|active_tasks
op_assign
id|count_active_tasks
c_func
(paren
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|0
)braket
comma
id|EXP_1
comma
id|active_tasks
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|1
)braket
comma
id|EXP_5
comma
id|active_tasks
)paren
suffix:semicolon
id|CALC_LOAD
c_func
(paren
id|avenrun
(braket
l_int|2
)braket
comma
id|EXP_15
comma
id|active_tasks
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * this routine handles the overflow of the microsecond field&n; *&n; * The tricky bits of code to handle the accurate clock support&n; * were provided by Dave Mills (Mills@UDEL.EDU) of NTP fame.&n; * They were originally developed for SUN and DEC kernels.&n; * All the kudos should go to Dave for this stuff.&n; *&n; * These were ported to Linux by Philip Gladstone.&n; */
DECL|function|second_overflow
r_static
r_void
id|second_overflow
c_func
(paren
r_void
)paren
(brace
r_int
id|ltemp
suffix:semicolon
multiline_comment|/* Bump the maxerror field */
id|time_maxerror
op_assign
(paren
l_int|0x70000000
op_minus
id|time_maxerror
OL
id|time_tolerance
)paren
ques
c_cond
l_int|0x70000000
suffix:colon
(paren
id|time_maxerror
op_plus
id|time_tolerance
)paren
suffix:semicolon
multiline_comment|/* Run the PLL */
r_if
c_cond
(paren
id|time_offset
OL
l_int|0
)paren
(brace
id|ltemp
op_assign
(paren
op_minus
(paren
id|time_offset
op_plus
l_int|1
)paren
op_rshift
(paren
id|SHIFT_KG
op_plus
id|time_constant
)paren
)paren
op_plus
l_int|1
suffix:semicolon
id|time_adj
op_assign
id|ltemp
op_lshift
(paren
id|SHIFT_SCALE
op_minus
id|SHIFT_HZ
op_minus
id|SHIFT_UPDATE
)paren
suffix:semicolon
id|time_offset
op_add_assign
(paren
id|time_adj
op_star
id|HZ
)paren
op_rshift
(paren
id|SHIFT_SCALE
op_minus
id|SHIFT_UPDATE
)paren
suffix:semicolon
id|time_adj
op_assign
op_minus
id|time_adj
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|time_offset
OG
l_int|0
)paren
(brace
id|ltemp
op_assign
(paren
(paren
id|time_offset
op_minus
l_int|1
)paren
op_rshift
(paren
id|SHIFT_KG
op_plus
id|time_constant
)paren
)paren
op_plus
l_int|1
suffix:semicolon
id|time_adj
op_assign
id|ltemp
op_lshift
(paren
id|SHIFT_SCALE
op_minus
id|SHIFT_HZ
op_minus
id|SHIFT_UPDATE
)paren
suffix:semicolon
id|time_offset
op_sub_assign
(paren
id|time_adj
op_star
id|HZ
)paren
op_rshift
(paren
id|SHIFT_SCALE
op_minus
id|SHIFT_UPDATE
)paren
suffix:semicolon
)brace
r_else
(brace
id|time_adj
op_assign
l_int|0
suffix:semicolon
)brace
id|time_adj
op_add_assign
(paren
id|time_freq
op_rshift
(paren
id|SHIFT_KF
op_plus
id|SHIFT_HZ
op_minus
id|SHIFT_SCALE
)paren
)paren
op_plus
id|FINETUNE
suffix:semicolon
multiline_comment|/* Handle the leap second stuff */
r_switch
c_cond
(paren
id|time_status
)paren
(brace
r_case
id|TIME_INS
suffix:colon
multiline_comment|/* ugly divide should be replaced */
r_if
c_cond
(paren
id|xtime.tv_sec
op_mod
l_int|86400
op_eq
l_int|0
)paren
(brace
id|xtime.tv_sec
op_decrement
suffix:semicolon
multiline_comment|/* !! */
id|time_status
op_assign
id|TIME_OOP
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Clock: inserting leap second 23:59:60 UTC&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIME_DEL
suffix:colon
multiline_comment|/* ugly divide should be replaced */
r_if
c_cond
(paren
id|xtime.tv_sec
op_mod
l_int|86400
op_eq
l_int|86399
)paren
(brace
id|xtime.tv_sec
op_increment
suffix:semicolon
id|time_status
op_assign
id|TIME_OK
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Clock: deleting leap second 23:59:59 UTC&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIME_OOP
suffix:colon
id|time_status
op_assign
id|TIME_OK
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * disregard lost ticks for now.. We don&squot;t care enough.&n; */
DECL|function|timer_bh
r_static
r_void
id|timer_bh
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_struct
id|timer_struct
op_star
id|tp
suffix:semicolon
r_struct
id|timer_list
op_star
id|timer
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|timer
op_assign
id|timer_head.next
)paren
op_ne
op_amp
id|timer_head
op_logical_and
id|timer-&gt;expires
OL
id|jiffies
)paren
(brace
r_void
(paren
op_star
id|fn
)paren
(paren
r_int
r_int
)paren
op_assign
id|timer-&gt;function
suffix:semicolon
r_int
r_int
id|data
op_assign
id|timer-&gt;data
suffix:semicolon
id|timer-&gt;next-&gt;prev
op_assign
id|timer-&gt;prev
suffix:semicolon
id|timer-&gt;prev-&gt;next
op_assign
id|timer-&gt;next
suffix:semicolon
id|timer-&gt;next
op_assign
id|timer-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|fn
c_func
(paren
id|data
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|mask
op_assign
l_int|1
comma
id|tp
op_assign
id|timer_table
op_plus
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|tp
op_increment
comma
id|mask
op_add_assign
id|mask
)paren
(brace
r_if
c_cond
(paren
id|mask
OG
id|timer_active
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mask
op_amp
id|timer_active
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;expires
OG
id|jiffies
)paren
r_continue
suffix:semicolon
id|timer_active
op_and_assign
op_complement
id|mask
suffix:semicolon
id|tp
op_member_access_from_pointer
id|fn
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|tqueue_bh
r_void
id|tqueue_bh
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_timer
)paren
suffix:semicolon
)brace
DECL|function|immediate_bh
r_void
id|immediate_bh
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_immediate
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The int argument is really a (struct pt_regs *), in case the&n; * interrupt wants to know from where it was called. The timer&n; * irq uses this to decide if it should update the user or system&n; * times.&n; */
DECL|function|do_timer
r_static
r_void
id|do_timer
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|mask
suffix:semicolon
r_struct
id|timer_struct
op_star
id|tp
suffix:semicolon
multiline_comment|/* last time the cmos clock got updated */
r_static
r_int
id|last_rtc_update
op_assign
l_int|0
suffix:semicolon
r_extern
r_int
id|set_rtc_mmss
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_int
id|ltemp
comma
id|psecs
suffix:semicolon
multiline_comment|/* Advance the phase, once it gets to one microsecond, then&n;&t; * advance the tick more.&n;&t; */
id|time_phase
op_add_assign
id|time_adj
suffix:semicolon
r_if
c_cond
(paren
id|time_phase
OL
op_minus
id|FINEUSEC
)paren
(brace
id|ltemp
op_assign
op_minus
id|time_phase
op_rshift
id|SHIFT_SCALE
suffix:semicolon
id|time_phase
op_add_assign
id|ltemp
op_lshift
id|SHIFT_SCALE
suffix:semicolon
id|xtime.tv_usec
op_add_assign
id|tick
op_plus
id|time_adjust_step
op_minus
id|ltemp
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|time_phase
OG
id|FINEUSEC
)paren
(brace
id|ltemp
op_assign
id|time_phase
op_rshift
id|SHIFT_SCALE
suffix:semicolon
id|time_phase
op_sub_assign
id|ltemp
op_lshift
id|SHIFT_SCALE
suffix:semicolon
id|xtime.tv_usec
op_add_assign
id|tick
op_plus
id|time_adjust_step
op_plus
id|ltemp
suffix:semicolon
)brace
r_else
id|xtime.tv_usec
op_add_assign
id|tick
op_plus
id|time_adjust_step
suffix:semicolon
r_if
c_cond
(paren
id|time_adjust
)paren
(brace
multiline_comment|/* We are doing an adjtime thing. &n;&t;     *&n;&t;     * Modify the value of the tick for next time.&n;&t;     * Note that a positive delta means we want the clock&n;&t;     * to run fast. This means that the tick should be bigger&n;&t;     *&n;&t;     * Limit the amount of the step for *next* tick to be&n;&t;     * in the range -tickadj .. +tickadj&n;&t;     */
r_if
c_cond
(paren
id|time_adjust
OG
id|tickadj
)paren
id|time_adjust_step
op_assign
id|tickadj
suffix:semicolon
r_else
r_if
c_cond
(paren
id|time_adjust
OL
op_minus
id|tickadj
)paren
id|time_adjust_step
op_assign
op_minus
id|tickadj
suffix:semicolon
r_else
id|time_adjust_step
op_assign
id|time_adjust
suffix:semicolon
multiline_comment|/* Reduce by this step the amount of time left  */
id|time_adjust
op_sub_assign
id|time_adjust_step
suffix:semicolon
)brace
r_else
id|time_adjust_step
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|xtime.tv_usec
op_ge
l_int|1000000
)paren
(brace
id|xtime.tv_usec
op_sub_assign
l_int|1000000
suffix:semicolon
id|xtime.tv_sec
op_increment
suffix:semicolon
id|second_overflow
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* If we have an externally synchronized Linux clock, then update&n;&t; * CMOS clock accordingly every ~11 minutes. Set_rtc_mmss() has to be&n;&t; * called as close as possible to 500 ms before the new second starts.&n;&t; */
r_if
c_cond
(paren
id|time_status
op_ne
id|TIME_BAD
op_logical_and
id|xtime.tv_sec
OG
id|last_rtc_update
op_plus
l_int|660
op_logical_and
id|xtime.tv_usec
OG
l_int|500000
op_minus
(paren
id|tick
op_rshift
l_int|1
)paren
op_logical_and
id|xtime.tv_usec
OL
l_int|500000
op_plus
(paren
id|tick
op_rshift
l_int|1
)paren
)paren
r_if
c_cond
(paren
id|set_rtc_mmss
c_func
(paren
id|xtime.tv_sec
)paren
op_eq
l_int|0
)paren
id|last_rtc_update
op_assign
id|xtime.tv_sec
suffix:semicolon
r_else
id|last_rtc_update
op_assign
id|xtime.tv_sec
op_minus
l_int|600
suffix:semicolon
multiline_comment|/* do it again in 60 s */
id|jiffies
op_increment
suffix:semicolon
id|calc_load
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
id|current-&gt;utime
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|current
op_ne
id|task
(braket
l_int|0
)braket
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;priority
OL
l_int|15
)paren
id|kstat.cpu_nice
op_increment
suffix:semicolon
r_else
id|kstat.cpu_user
op_increment
suffix:semicolon
)brace
multiline_comment|/* Update ITIMER_VIRT for current task if not in a system call */
r_if
c_cond
(paren
id|current-&gt;it_virt_value
op_logical_and
op_logical_neg
(paren
op_decrement
id|current-&gt;it_virt_value
)paren
)paren
(brace
id|current-&gt;it_virt_value
op_assign
id|current-&gt;it_virt_incr
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGVTALRM
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|current-&gt;stime
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|current
op_ne
id|task
(braket
l_int|0
)braket
)paren
(brace
id|kstat.cpu_system
op_increment
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROFILE
r_if
c_cond
(paren
id|prof_buffer
op_logical_and
id|current
op_ne
id|task
(braket
l_int|0
)braket
)paren
(brace
r_extern
r_int
id|_stext
suffix:semicolon
r_int
r_int
id|eip
op_assign
id|regs-&gt;eip
op_minus
(paren
r_int
r_int
)paren
op_amp
id|_stext
suffix:semicolon
id|eip
op_rshift_assign
id|CONFIG_PROFILE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|eip
OL
id|prof_len
)paren
id|prof_buffer
(braket
id|eip
)braket
op_increment
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n;&t; * check the cpu time limit on the process.&n;&t; */
r_if
c_cond
(paren
(paren
id|current-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_max
op_ne
id|RLIM_INFINITY
)paren
op_logical_and
(paren
(paren
(paren
id|current-&gt;stime
op_plus
id|current-&gt;utime
)paren
op_div
id|HZ
)paren
op_ge
id|current-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_max
)paren
)paren
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_cur
op_ne
id|RLIM_INFINITY
)paren
op_logical_and
(paren
(paren
(paren
id|current-&gt;stime
op_plus
id|current-&gt;utime
)paren
op_mod
id|HZ
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|psecs
op_assign
(paren
id|current-&gt;stime
op_plus
id|current-&gt;utime
)paren
op_div
id|HZ
suffix:semicolon
multiline_comment|/* send when equal */
r_if
c_cond
(paren
id|psecs
op_eq
id|current-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_cur
)paren
id|send_sig
c_func
(paren
id|SIGXCPU
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* and every five seconds thereafter. */
r_else
r_if
c_cond
(paren
(paren
id|psecs
OG
id|current-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_cur
)paren
op_logical_and
(paren
(paren
id|psecs
op_minus
id|current-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_cur
)paren
op_mod
l_int|5
)paren
op_eq
l_int|0
)paren
id|send_sig
c_func
(paren
id|SIGXCPU
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current
op_ne
id|task
(braket
l_int|0
)braket
op_logical_and
l_int|0
OG
op_decrement
id|current-&gt;counter
)paren
(brace
id|current-&gt;counter
op_assign
l_int|0
suffix:semicolon
id|need_resched
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Update ITIMER_PROF for the current task */
r_if
c_cond
(paren
id|current-&gt;it_prof_value
op_logical_and
op_logical_neg
(paren
op_decrement
id|current-&gt;it_prof_value
)paren
)paren
(brace
id|current-&gt;it_prof_value
op_assign
id|current-&gt;it_prof_incr
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGPROF
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|mask
op_assign
l_int|1
comma
id|tp
op_assign
id|timer_table
op_plus
l_int|0
suffix:semicolon
id|mask
suffix:semicolon
id|tp
op_increment
comma
id|mask
op_add_assign
id|mask
)paren
(brace
r_if
c_cond
(paren
id|mask
OG
id|timer_active
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mask
op_amp
id|timer_active
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|tp-&gt;expires
OG
id|jiffies
)paren
r_continue
suffix:semicolon
id|mark_bh
c_func
(paren
id|TIMER_BH
)paren
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_head.next-&gt;expires
OL
id|jiffies
)paren
id|mark_bh
c_func
(paren
id|TIMER_BH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tq_timer
op_ne
op_amp
id|tq_last
)paren
id|mark_bh
c_func
(paren
id|TQUEUE_BH
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|sys_alarm
id|asmlinkage
r_int
r_int
id|sys_alarm
c_func
(paren
r_int
r_int
id|seconds
)paren
(brace
r_struct
id|itimerval
id|it_new
comma
id|it_old
suffix:semicolon
id|it_new.it_interval.tv_sec
op_assign
id|it_new.it_interval.tv_usec
op_assign
l_int|0
suffix:semicolon
id|it_new.it_value.tv_sec
op_assign
id|seconds
suffix:semicolon
id|it_new.it_value.tv_usec
op_assign
l_int|0
suffix:semicolon
id|_setitimer
c_func
(paren
id|ITIMER_REAL
comma
op_amp
id|it_new
comma
op_amp
id|it_old
)paren
suffix:semicolon
r_return
id|it_old.it_value.tv_sec
op_plus
(paren
id|it_old.it_value.tv_usec
op_div
l_int|1000000
)paren
suffix:semicolon
)brace
DECL|function|sys_getpid
id|asmlinkage
r_int
id|sys_getpid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;pid
suffix:semicolon
)brace
DECL|function|sys_getppid
id|asmlinkage
r_int
id|sys_getppid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;p_opptr-&gt;pid
suffix:semicolon
)brace
DECL|function|sys_getuid
id|asmlinkage
r_int
id|sys_getuid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;uid
suffix:semicolon
)brace
DECL|function|sys_geteuid
id|asmlinkage
r_int
id|sys_geteuid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;euid
suffix:semicolon
)brace
DECL|function|sys_getgid
id|asmlinkage
r_int
id|sys_getgid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;gid
suffix:semicolon
)brace
DECL|function|sys_getegid
id|asmlinkage
r_int
id|sys_getegid
c_func
(paren
r_void
)paren
(brace
r_return
id|current-&gt;egid
suffix:semicolon
)brace
DECL|function|sys_nice
id|asmlinkage
r_int
id|sys_nice
c_func
(paren
r_int
id|increment
)paren
(brace
r_int
id|newprio
suffix:semicolon
r_if
c_cond
(paren
id|increment
OL
l_int|0
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|newprio
op_assign
id|current-&gt;priority
op_minus
id|increment
suffix:semicolon
r_if
c_cond
(paren
id|newprio
OL
l_int|1
)paren
id|newprio
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|newprio
OG
l_int|35
)paren
id|newprio
op_assign
l_int|35
suffix:semicolon
id|current-&gt;priority
op_assign
id|newprio
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|show_task
r_static
r_void
id|show_task
c_func
(paren
r_int
id|nr
comma
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_int
r_int
id|free
suffix:semicolon
r_static
r_const
r_char
op_star
id|stat_nam
(braket
)braket
op_assign
(brace
l_string|&quot;R&quot;
comma
l_string|&quot;S&quot;
comma
l_string|&quot;D&quot;
comma
l_string|&quot;Z&quot;
comma
l_string|&quot;T&quot;
comma
l_string|&quot;W&quot;
)brace
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%-8s %3d &quot;
comma
id|p-&gt;comm
comma
(paren
id|p
op_eq
id|current
)paren
ques
c_cond
op_minus
id|nr
suffix:colon
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|p-&gt;state
)paren
OL
r_sizeof
(paren
id|stat_nam
)paren
op_div
r_sizeof
(paren
r_char
op_star
)paren
)paren
id|printk
c_func
(paren
id|stat_nam
(braket
id|p-&gt;state
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
macro_line|#if ((~0UL) == 0xffffffff)
r_if
c_cond
(paren
id|p
op_eq
id|current
)paren
id|printk
c_func
(paren
l_string|&quot; current  &quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; %08lX &quot;
comma
id|thread_saved_pc
c_func
(paren
op_amp
id|p-&gt;tss
)paren
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|p
op_eq
id|current
)paren
id|printk
c_func
(paren
l_string|&quot;   current task   &quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; %016lx &quot;
comma
id|thread_saved_pc
c_func
(paren
op_amp
id|p-&gt;tss
)paren
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|free
op_assign
l_int|1
suffix:semicolon
id|free
OL
id|PAGE_SIZE
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|free
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
op_star
)paren
id|p-&gt;kernel_stack_page
)paren
(braket
id|free
)braket
)paren
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%5lu %5d %6d &quot;
comma
id|free
op_star
r_sizeof
(paren
r_int
)paren
comma
id|p-&gt;pid
comma
id|p-&gt;p_pptr-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;p_cptr
)paren
id|printk
c_func
(paren
l_string|&quot;%5d &quot;
comma
id|p-&gt;p_cptr-&gt;pid
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;      &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;p_ysptr
)paren
id|printk
c_func
(paren
l_string|&quot;%7d&quot;
comma
id|p-&gt;p_ysptr-&gt;pid
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;       &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;p_osptr
)paren
id|printk
c_func
(paren
l_string|&quot; %5d&bslash;n&quot;
comma
id|p-&gt;p_osptr-&gt;pid
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|show_state
r_void
id|show_state
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#if ((~0UL) == 0xffffffff)
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
l_string|&quot;                         free                        sibling&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  task             PC    stack   pid father child younger older&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
l_string|&quot;                                 free                        sibling&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  task                 PC        stack   pid father child younger older&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_TASKS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|task
(braket
id|i
)braket
)paren
id|show_task
c_func
(paren
id|i
comma
id|task
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
DECL|function|sched_init
r_void
id|sched_init
c_func
(paren
r_void
)paren
(brace
id|bh_base
(braket
id|TIMER_BH
)braket
dot
id|routine
op_assign
id|timer_bh
suffix:semicolon
id|bh_base
(braket
id|TQUEUE_BH
)braket
dot
id|routine
op_assign
id|tqueue_bh
suffix:semicolon
id|bh_base
(braket
id|IMMEDIATE_BH
)braket
dot
id|routine
op_assign
id|immediate_bh
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|TIMER_IRQ
comma
id|do_timer
comma
l_int|0
comma
l_string|&quot;timer&quot;
)paren
op_ne
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Could not allocate timer IRQ!&quot;
)paren
suffix:semicolon
id|enable_bh
c_func
(paren
id|TIMER_BH
)paren
suffix:semicolon
id|enable_bh
c_func
(paren
id|TQUEUE_BH
)paren
suffix:semicolon
id|enable_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
)brace
eof
