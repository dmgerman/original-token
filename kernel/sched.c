multiline_comment|/*&n; *  linux/kernel/sched.c&n; *&n; *  Kernel scheduler and related syscalls&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; *&n; *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and&n; *              make semaphores SMP safe&n; *  1998-11-19&t;Implemented schedule_timeout() and related stuff&n; *&t;&t;by Andrea Arcangeli&n; *  1998-12-28  Implemented better SMP scheduling by Ingo Molnar&n; */
multiline_comment|/*&n; * &squot;sched.c&squot; is the main kernel file. It contains scheduling primitives&n; * (sleep_on, wakeup, schedule etc) as well as a number of simple system&n; * call functions (type getpid()), which just extract a field from&n; * current-task&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
r_extern
r_void
id|timer_bh
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|tqueue_bh
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|immediate_bh
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * scheduler variables&n; */
DECL|variable|securebits
r_int
id|securebits
op_assign
id|SECUREBITS_DEFAULT
suffix:semicolon
multiline_comment|/* systemwide security settings */
r_extern
r_void
id|mem_use
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * Scheduling quanta.&n; *&n; * NOTE! The unix &quot;nice&quot; value influences how long a process&n; * gets. The nice value ranges from -20 to +19, where a -20&n; * is a &quot;high-priority&quot; task, and a &quot;+10&quot; is a low-priority&n; * task.&n; *&n; * We want the time-slice to be around 50ms or so, so this&n; * calculation depends on the value of HZ.&n; */
macro_line|#if HZ &lt; 200
DECL|macro|TICK_SCALE
mdefine_line|#define TICK_SCALE(x)&t;((x) &gt;&gt; 2)
macro_line|#elif HZ &lt; 400
DECL|macro|TICK_SCALE
mdefine_line|#define TICK_SCALE(x)&t;((x) &gt;&gt; 1)
macro_line|#elif HZ &lt; 800
DECL|macro|TICK_SCALE
mdefine_line|#define TICK_SCALE(x)&t;(x)
macro_line|#elif HZ &lt; 1600
DECL|macro|TICK_SCALE
mdefine_line|#define TICK_SCALE(x)&t;((x) &lt;&lt; 1)
macro_line|#else
DECL|macro|TICK_SCALE
mdefine_line|#define TICK_SCALE(x)&t;((x) &lt;&lt; 2)
macro_line|#endif
DECL|macro|NICE_TO_TICKS
mdefine_line|#define NICE_TO_TICKS(nice)&t;(TICK_SCALE(20-(nice))+1)
multiline_comment|/*&n; *&t;Init task must be ok at boot for the ix86 as we will check its signals&n; *&t;via the SMP irq return path.&n; */
DECL|variable|init_tasks
r_struct
id|task_struct
op_star
id|init_tasks
(braket
id|NR_CPUS
)braket
op_assign
(brace
op_amp
id|init_task
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * The tasklist_lock protects the linked list of processes.&n; *&n; * The runqueue_lock locks the parts that actually access&n; * and change the run-queues, and have to be interrupt-safe.&n; *&n; * If both locks are to be concurrently held, the runqueue_lock&n; * nests inside the tasklist_lock.&n; */
DECL|variable|__cacheline_aligned
id|spinlock_t
id|runqueue_lock
id|__cacheline_aligned
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* inner */
DECL|variable|__cacheline_aligned
id|rwlock_t
id|tasklist_lock
id|__cacheline_aligned
op_assign
id|RW_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* outer */
r_static
id|LIST_HEAD
c_func
(paren
id|runqueue_head
)paren
suffix:semicolon
multiline_comment|/*&n; * We align per-CPU scheduling data on cacheline boundaries,&n; * to prevent cacheline ping-pong.&n; */
r_static
r_union
(brace
DECL|struct|schedule_data
r_struct
id|schedule_data
(brace
DECL|member|curr
r_struct
id|task_struct
op_star
id|curr
suffix:semicolon
DECL|member|last_schedule
id|cycles_t
id|last_schedule
suffix:semicolon
DECL|member|schedule_data
)brace
id|schedule_data
suffix:semicolon
DECL|member|__pad
r_char
id|__pad
(braket
id|SMP_CACHE_BYTES
)braket
suffix:semicolon
DECL|variable|__cacheline_aligned
)brace
id|aligned_data
(braket
id|NR_CPUS
)braket
id|__cacheline_aligned
op_assign
(brace
(brace
(brace
op_amp
id|init_task
comma
l_int|0
)brace
)brace
)brace
suffix:semicolon
DECL|macro|cpu_curr
mdefine_line|#define cpu_curr(cpu) aligned_data[(cpu)].schedule_data.curr
DECL|macro|last_schedule
mdefine_line|#define last_schedule(cpu) aligned_data[(cpu)].schedule_data.last_schedule
DECL|variable|kstat
r_struct
id|kernel_stat
id|kstat
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
DECL|macro|idle_task
mdefine_line|#define idle_task(cpu) (init_tasks[cpu_number_map(cpu)])
DECL|macro|can_schedule
mdefine_line|#define can_schedule(p,cpu) ((!(p)-&gt;has_cpu) &amp;&amp; &bslash;&n;&t;&t;&t;&t;((p)-&gt;cpus_allowed &amp; (1 &lt;&lt; cpu)))
macro_line|#else
DECL|macro|idle_task
mdefine_line|#define idle_task(cpu) (&amp;init_task)
DECL|macro|can_schedule
mdefine_line|#define can_schedule(p,cpu) (1)
macro_line|#endif
DECL|function|scheduling_functions_start_here
r_void
id|scheduling_functions_start_here
c_func
(paren
r_void
)paren
(brace
)brace
multiline_comment|/*&n; * This is the function that decides how desirable a process is..&n; * You can weigh different processes against each other depending&n; * on what CPU they&squot;ve run on lately etc to try to handle cache&n; * and TLB miss penalties.&n; *&n; * Return values:&n; *&t; -1000: never select this&n; *&t;     0: out of time, recalculate counters (but it might still be&n; *&t;&t;selected)&n; *&t;   +ve: &quot;goodness&quot; value (the larger, the better)&n; *&t; +1000: realtime process, select this.&n; */
DECL|function|goodness
r_static
r_inline
r_int
id|goodness
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
id|this_cpu
comma
r_struct
id|mm_struct
op_star
id|this_mm
)paren
(brace
r_int
id|weight
suffix:semicolon
multiline_comment|/*&n;&t; * select the current process after every other&n;&t; * runnable process, but before the idle thread.&n;&t; * Also, dont trigger a counter recalculation.&n;&t; */
id|weight
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;policy
op_amp
id|SCHED_YIELD
)paren
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t; * Non-RT process - normal case first.&n;&t; */
r_if
c_cond
(paren
id|p-&gt;policy
op_eq
id|SCHED_OTHER
)paren
(brace
multiline_comment|/*&n;&t;&t; * Give the process a first-approximation goodness value&n;&t;&t; * according to the number of clock-ticks it has left.&n;&t;&t; *&n;&t;&t; * Don&squot;t do any other calculations if the time slice is&n;&t;&t; * over..&n;&t;&t; */
id|weight
op_assign
id|p-&gt;counter
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|weight
)paren
r_goto
id|out
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* Give a largish advantage to the same processor...   */
multiline_comment|/* (this is equivalent to penalizing other processors) */
r_if
c_cond
(paren
id|p-&gt;processor
op_eq
id|this_cpu
)paren
id|weight
op_add_assign
id|PROC_CHANGE_PENALTY
suffix:semicolon
macro_line|#endif
multiline_comment|/* .. and a slight advantage to the current MM */
r_if
c_cond
(paren
id|p-&gt;mm
op_eq
id|this_mm
op_logical_or
op_logical_neg
id|p-&gt;mm
)paren
id|weight
op_add_assign
l_int|1
suffix:semicolon
id|weight
op_add_assign
l_int|20
op_minus
id|p-&gt;nice
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Realtime process, select the first one on the&n;&t; * runqueue (taking priorities within processes&n;&t; * into account).&n;&t; */
id|weight
op_assign
l_int|1000
op_plus
id|p-&gt;rt_priority
suffix:semicolon
id|out
suffix:colon
r_return
id|weight
suffix:semicolon
)brace
multiline_comment|/*&n; * the &squot;goodness value&squot; of replacing a process on a given CPU.&n; * positive value means &squot;replace&squot;, zero or negative means &squot;dont&squot;.&n; */
DECL|function|preemption_goodness
r_static
r_inline
r_int
id|preemption_goodness
c_func
(paren
r_struct
id|task_struct
op_star
id|prev
comma
r_struct
id|task_struct
op_star
id|p
comma
r_int
id|cpu
)paren
(brace
r_return
id|goodness
c_func
(paren
id|p
comma
id|cpu
comma
id|prev-&gt;active_mm
)paren
op_minus
id|goodness
c_func
(paren
id|prev
comma
id|cpu
comma
id|prev-&gt;active_mm
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is ugly, but reschedule_idle() is very timing-critical.&n; * We are called with the runqueue spinlock held and we must&n; * not claim the tasklist_lock.&n; */
r_static
id|FASTCALL
c_func
(paren
r_void
id|reschedule_idle
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
)paren
suffix:semicolon
DECL|function|reschedule_idle
r_static
r_void
id|reschedule_idle
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
macro_line|#ifdef CONFIG_SMP
r_int
id|this_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
comma
op_star
id|target_tsk
suffix:semicolon
r_int
id|cpu
comma
id|best_cpu
comma
id|i
comma
id|max_prio
suffix:semicolon
id|cycles_t
id|oldest_idle
suffix:semicolon
multiline_comment|/*&n;&t; * shortcut if the woken up task&squot;s last CPU is&n;&t; * idle now.&n;&t; */
id|best_cpu
op_assign
id|p-&gt;processor
suffix:semicolon
r_if
c_cond
(paren
id|can_schedule
c_func
(paren
id|p
comma
id|best_cpu
)paren
)paren
(brace
id|tsk
op_assign
id|idle_task
c_func
(paren
id|best_cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_curr
c_func
(paren
id|best_cpu
)paren
op_eq
id|tsk
)paren
(brace
r_int
id|need_resched
suffix:semicolon
id|send_now_idle
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * If need_resched == -1 then we can skip sending&n;&t;&t;&t; * the IPI altogether, tsk-&gt;need_resched is&n;&t;&t;&t; * actively watched by the idle thread.&n;&t;&t;&t; */
id|need_resched
op_assign
id|tsk-&gt;need_resched
suffix:semicolon
id|tsk-&gt;need_resched
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|best_cpu
op_ne
id|this_cpu
)paren
op_logical_and
op_logical_neg
id|need_resched
)paren
id|smp_send_reschedule
c_func
(paren
id|best_cpu
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * We know that the preferred CPU has a cache-affine current&n;&t; * process, lets try to find a new idle CPU for the woken-up&n;&t; * process. Select the least recently active idle CPU. (that&n;&t; * one will have the least active cache context.) Also find&n;&t; * the executing process which has the least priority.&n;&t; */
id|oldest_idle
op_assign
(paren
id|cycles_t
)paren
op_minus
l_int|1
suffix:semicolon
id|target_tsk
op_assign
l_int|NULL
suffix:semicolon
id|max_prio
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cpu
op_assign
id|cpu_logical_map
c_func
(paren
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|can_schedule
c_func
(paren
id|p
comma
id|cpu
)paren
)paren
r_continue
suffix:semicolon
id|tsk
op_assign
id|cpu_curr
c_func
(paren
id|cpu
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We use the first available idle CPU. This creates&n;&t;&t; * a priority list between idle CPUs, but this is not&n;&t;&t; * a problem.&n;&t;&t; */
r_if
c_cond
(paren
id|tsk
op_eq
id|idle_task
c_func
(paren
id|cpu
)paren
)paren
(brace
r_if
c_cond
(paren
id|last_schedule
c_func
(paren
id|cpu
)paren
OL
id|oldest_idle
)paren
(brace
id|oldest_idle
op_assign
id|last_schedule
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|target_tsk
op_assign
id|tsk
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|oldest_idle
op_eq
op_minus
l_int|1ULL
)paren
(brace
r_int
id|prio
op_assign
id|preemption_goodness
c_func
(paren
id|tsk
comma
id|p
comma
id|cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prio
OG
id|max_prio
)paren
(brace
id|max_prio
op_assign
id|prio
suffix:semicolon
id|target_tsk
op_assign
id|tsk
suffix:semicolon
)brace
)brace
)brace
)brace
id|tsk
op_assign
id|target_tsk
suffix:semicolon
r_if
c_cond
(paren
id|tsk
)paren
(brace
r_if
c_cond
(paren
id|oldest_idle
op_ne
op_minus
l_int|1ULL
)paren
(brace
id|best_cpu
op_assign
id|tsk-&gt;processor
suffix:semicolon
r_goto
id|send_now_idle
suffix:semicolon
)brace
id|tsk-&gt;need_resched
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tsk-&gt;processor
op_ne
id|this_cpu
)paren
id|smp_send_reschedule
c_func
(paren
id|tsk-&gt;processor
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
macro_line|#else /* UP */
r_int
id|this_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
suffix:semicolon
id|tsk
op_assign
id|cpu_curr
c_func
(paren
id|this_cpu
)paren
suffix:semicolon
r_if
c_cond
(paren
id|preemption_goodness
c_func
(paren
id|tsk
comma
id|p
comma
id|this_cpu
)paren
OG
l_int|1
)paren
id|tsk-&gt;need_resched
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Careful!&n; *&n; * This has to add the process to the _beginning_ of the&n; * run-queue, not the end. See the comment about &quot;This is&n; * subtle&quot; in the scheduler proper..&n; */
DECL|function|add_to_runqueue
r_static
r_inline
r_void
id|add_to_runqueue
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|p-&gt;run_list
comma
op_amp
id|runqueue_head
)paren
suffix:semicolon
id|nr_running
op_increment
suffix:semicolon
)brace
DECL|function|move_last_runqueue
r_static
r_inline
r_void
id|move_last_runqueue
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|p-&gt;run_list
)paren
suffix:semicolon
id|list_add_tail
c_func
(paren
op_amp
id|p-&gt;run_list
comma
op_amp
id|runqueue_head
)paren
suffix:semicolon
)brace
DECL|function|move_first_runqueue
r_static
r_inline
r_void
id|move_first_runqueue
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
id|list_del
c_func
(paren
op_amp
id|p-&gt;run_list
)paren
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|p-&gt;run_list
comma
op_amp
id|runqueue_head
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wake up a process. Put it on the run-queue if it&squot;s not&n; * already there.  The &quot;current&quot; process is always on the&n; * run-queue (except when the actual re-schedule is in&n; * progress), and as such you&squot;re allowed to do the simpler&n; * &quot;current-&gt;state = TASK_RUNNING&quot; to mark yourself runnable&n; * without the overhead of this.&n; */
DECL|function|wake_up_process
r_inline
r_void
id|wake_up_process
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * We want the common case fall through straight, thus the goto.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|runqueue_lock
comma
id|flags
)paren
suffix:semicolon
id|p-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|task_on_runqueue
c_func
(paren
id|p
)paren
)paren
r_goto
id|out
suffix:semicolon
id|add_to_runqueue
c_func
(paren
id|p
)paren
suffix:semicolon
id|reschedule_idle
c_func
(paren
id|p
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|runqueue_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|wake_up_process_synchronous
r_static
r_inline
r_void
id|wake_up_process_synchronous
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * We want the common case fall through straight, thus the goto.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|runqueue_lock
comma
id|flags
)paren
suffix:semicolon
id|p-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|task_on_runqueue
c_func
(paren
id|p
)paren
)paren
r_goto
id|out
suffix:semicolon
id|add_to_runqueue
c_func
(paren
id|p
)paren
suffix:semicolon
id|out
suffix:colon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|runqueue_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|process_timeout
r_static
r_void
id|process_timeout
c_func
(paren
r_int
r_int
id|__data
)paren
(brace
r_struct
id|task_struct
op_star
id|p
op_assign
(paren
r_struct
id|task_struct
op_star
)paren
id|__data
suffix:semicolon
id|wake_up_process
c_func
(paren
id|p
)paren
suffix:semicolon
)brace
DECL|function|schedule_timeout
r_int
r_int
id|schedule_timeout
c_func
(paren
r_int
r_int
id|timeout
)paren
(brace
r_struct
id|timer_list
id|timer
suffix:semicolon
r_int
r_int
id|expire
suffix:semicolon
r_switch
c_cond
(paren
id|timeout
)paren
(brace
r_case
id|MAX_SCHEDULE_TIMEOUT
suffix:colon
multiline_comment|/*&n;&t;&t; * These two special cases are useful to be comfortable&n;&t;&t; * in the caller. Nothing more. We could take&n;&t;&t; * MAX_SCHEDULE_TIMEOUT from one of the negative value&n;&t;&t; * but I&squot; d like to return a valid offset (&gt;=0) to allow&n;&t;&t; * the caller to do everything it want with the retval.&n;&t;&t; */
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/*&n;&t;&t; * Another bit of PARANOID. Note that the retval will be&n;&t;&t; * 0 since no piece of kernel is supposed to do a check&n;&t;&t; * for a negative retval of schedule_timeout() (since it&n;&t;&t; * should never happens anyway). You just have the printk()&n;&t;&t; * that will tell you if something is gone wrong and where.&n;&t;&t; */
r_if
c_cond
(paren
id|timeout
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;schedule_timeout: wrong timeout &quot;
l_string|&quot;value %lx from %p&bslash;n&quot;
comma
id|timeout
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|expire
op_assign
id|timeout
op_plus
id|jiffies
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|timer.expires
op_assign
id|expire
suffix:semicolon
id|timer.data
op_assign
(paren
r_int
r_int
)paren
id|current
suffix:semicolon
id|timer.function
op_assign
id|process_timeout
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|timer
)paren
suffix:semicolon
id|timeout
op_assign
id|expire
op_minus
id|jiffies
suffix:semicolon
id|out
suffix:colon
r_return
id|timeout
OL
l_int|0
ques
c_cond
l_int|0
suffix:colon
id|timeout
suffix:semicolon
)brace
multiline_comment|/*&n; * schedule_tail() is getting called from the fork return path. This&n; * cleans up all remaining scheduler things, without impacting the&n; * common case.&n; */
DECL|function|__schedule_tail
r_static
r_inline
r_void
id|__schedule_tail
c_func
(paren
r_struct
id|task_struct
op_star
id|prev
)paren
(brace
macro_line|#ifdef CONFIG_SMP
r_int
id|policy
suffix:semicolon
multiline_comment|/*&n;&t; * prev-&gt;policy can be written from here only before `prev&squot;&n;&t; * can be scheduled (before setting prev-&gt;has_cpu to zero).&n;&t; * Of course it must also be read before allowing prev&n;&t; * to be rescheduled, but since the write depends on the read&n;&t; * to complete, wmb() is enough. (the spin_lock() acquired&n;&t; * before setting has_cpu is not enough because the spin_lock()&n;&t; * common code semantics allows code outside the critical section&n;&t; * to enter inside the critical section)&n;&t; */
id|policy
op_assign
id|prev-&gt;policy
suffix:semicolon
id|prev-&gt;policy
op_assign
id|policy
op_amp
op_complement
id|SCHED_YIELD
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * fast path falls through. We have to clear has_cpu before&n;&t; * checking prev-&gt;state to avoid a wakeup race - thus we&n;&t; * also have to protect against the task exiting early.&n;&t; */
id|task_lock
c_func
(paren
id|prev
)paren
suffix:semicolon
id|prev-&gt;has_cpu
op_assign
l_int|0
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev-&gt;state
op_eq
id|TASK_RUNNING
)paren
r_goto
id|needs_resched
suffix:semicolon
id|out_unlock
suffix:colon
id|task_unlock
c_func
(paren
id|prev
)paren
suffix:semicolon
multiline_comment|/* Synchronise here with release_task() if prev is TASK_ZOMBIE */
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Slow path - we &squot;push&squot; the previous process and&n;&t; * reschedule_idle() will attempt to find a new&n;&t; * processor for it. (but it might preempt the&n;&t; * current process as well.) We must take the runqueue&n;&t; * lock and re-check prev-&gt;state to be correct. It might&n;&t; * still happen that this process has a preemption&n;&t; * &squot;in progress&squot; already - but this is not a problem and&n;&t; * might happen in other circumstances as well.&n;&t; */
id|needs_resched
suffix:colon
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Avoid taking the runqueue lock in cases where&n;&t;&t; * no preemption-check is necessery:&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|prev
op_eq
id|idle_task
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
)paren
op_logical_or
(paren
id|policy
op_amp
id|SCHED_YIELD
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|runqueue_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev-&gt;state
op_eq
id|TASK_RUNNING
)paren
id|reschedule_idle
c_func
(paren
id|prev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|runqueue_lock
comma
id|flags
)paren
suffix:semicolon
r_goto
id|out_unlock
suffix:semicolon
)brace
macro_line|#else
id|prev-&gt;policy
op_and_assign
op_complement
id|SCHED_YIELD
suffix:semicolon
macro_line|#endif /* CONFIG_SMP */
)brace
DECL|function|schedule_tail
r_void
id|schedule_tail
c_func
(paren
r_struct
id|task_struct
op_star
id|prev
)paren
(brace
id|__schedule_tail
c_func
(paren
id|prev
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  &squot;schedule()&squot; is the scheduler function. It&squot;s a very simple and nice&n; * scheduler: it&squot;s not perfect, but certainly works for most things.&n; *&n; * The goto is &quot;interesting&quot;.&n; *&n; *   NOTE!!  Task 0 is the &squot;idle&squot; task, which gets called when no other&n; * tasks can run. It can not be killed, and it cannot sleep. The &squot;state&squot;&n; * information in task[0] is never used.&n; */
DECL|function|schedule
id|asmlinkage
r_void
id|schedule
c_func
(paren
r_void
)paren
(brace
r_struct
id|schedule_data
op_star
id|sched_data
suffix:semicolon
r_struct
id|task_struct
op_star
id|prev
comma
op_star
id|next
comma
op_star
id|p
suffix:semicolon
r_struct
id|list_head
op_star
id|tmp
suffix:semicolon
r_int
id|this_cpu
comma
id|c
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;active_mm
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|need_resched_back
suffix:colon
id|prev
op_assign
id|current
suffix:semicolon
id|this_cpu
op_assign
id|prev-&gt;processor
suffix:semicolon
r_if
c_cond
(paren
id|in_interrupt
c_func
(paren
)paren
)paren
r_goto
id|scheduling_in_interrupt
suffix:semicolon
id|release_kernel_lock
c_func
(paren
id|prev
comma
id|this_cpu
)paren
suffix:semicolon
multiline_comment|/* Do &quot;administrative&quot; work here while we don&squot;t hold any locks */
r_if
c_cond
(paren
id|softirq_active
c_func
(paren
id|this_cpu
)paren
op_amp
id|softirq_mask
c_func
(paren
id|this_cpu
)paren
)paren
r_goto
id|handle_softirq
suffix:semicolon
id|handle_softirq_back
suffix:colon
multiline_comment|/*&n;&t; * &squot;sched_data&squot; is protected by the fact that we can run&n;&t; * only one process per CPU.&n;&t; */
id|sched_data
op_assign
op_amp
id|aligned_data
(braket
id|this_cpu
)braket
dot
id|schedule_data
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|runqueue_lock
)paren
suffix:semicolon
multiline_comment|/* move an exhausted RR process to be last.. */
r_if
c_cond
(paren
id|prev-&gt;policy
op_eq
id|SCHED_RR
)paren
r_goto
id|move_rr_last
suffix:semicolon
id|move_rr_back
suffix:colon
r_switch
c_cond
(paren
id|prev-&gt;state
)paren
(brace
r_case
id|TASK_INTERRUPTIBLE
suffix:colon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|prev
)paren
)paren
(brace
id|prev-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|del_from_runqueue
c_func
(paren
id|prev
)paren
suffix:semicolon
r_case
id|TASK_RUNNING
suffix:colon
)brace
id|prev-&gt;need_resched
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * this is the scheduler proper:&n;&t; */
id|repeat_schedule
suffix:colon
multiline_comment|/*&n;&t; * Default process to select..&n;&t; */
id|next
op_assign
id|idle_task
c_func
(paren
id|this_cpu
)paren
suffix:semicolon
id|c
op_assign
op_minus
l_int|1000
suffix:semicolon
r_if
c_cond
(paren
id|prev-&gt;state
op_eq
id|TASK_RUNNING
)paren
r_goto
id|still_running
suffix:semicolon
id|still_running_back
suffix:colon
id|list_for_each
c_func
(paren
id|tmp
comma
op_amp
id|runqueue_head
)paren
(brace
id|p
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
r_struct
id|task_struct
comma
id|run_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|can_schedule
c_func
(paren
id|p
comma
id|this_cpu
)paren
)paren
(brace
r_int
id|weight
op_assign
id|goodness
c_func
(paren
id|p
comma
id|this_cpu
comma
id|prev-&gt;active_mm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|weight
OG
id|c
)paren
id|c
op_assign
id|weight
comma
id|next
op_assign
id|p
suffix:semicolon
)brace
)brace
multiline_comment|/* Do we need to re-calculate counters? */
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_goto
id|recalculate
suffix:semicolon
multiline_comment|/*&n;&t; * from this point on nothing can prevent us from&n;&t; * switching to the next task, save this fact in&n;&t; * sched_data.&n;&t; */
id|sched_data-&gt;curr
op_assign
id|next
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
id|next-&gt;has_cpu
op_assign
l_int|1
suffix:semicolon
id|next-&gt;processor
op_assign
id|this_cpu
suffix:semicolon
macro_line|#endif
id|spin_unlock_irq
c_func
(paren
op_amp
id|runqueue_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|prev
op_eq
id|next
)paren
r_goto
id|same_process
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n; &t; * maintain the per-process &squot;last schedule&squot; value.&n; &t; * (this has to be recalculated even if we reschedule to&n; &t; * the same process) Currently this is only used on SMP,&n;&t; * and it&squot;s approximate, so we do not have to maintain&n;&t; * it while holding the runqueue spinlock.&n; &t; */
id|sched_data-&gt;last_schedule
op_assign
id|get_cycles
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We drop the scheduler lock early (it&squot;s a global spinlock),&n;&t; * thus we have to lock the previous process from getting&n;&t; * rescheduled during switch_to().&n;&t; */
macro_line|#endif /* CONFIG_SMP */
id|kstat.context_swtch
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * there are 3 processes which are affected by a context switch:&n;&t; *&n;&t; * prev == .... ==&gt; (last =&gt; next)&n;&t; *&n;&t; * It&squot;s the &squot;much more previous&squot; &squot;prev&squot; that is on next&squot;s stack,&n;&t; * but prev is set to (the just run) &squot;last&squot; process by switch_to().&n;&t; * This might sound slightly confusing but makes tons of sense.&n;&t; */
id|prepare_to_switch
c_func
(paren
)paren
suffix:semicolon
(brace
r_struct
id|mm_struct
op_star
id|mm
op_assign
id|next-&gt;mm
suffix:semicolon
r_struct
id|mm_struct
op_star
id|oldmm
op_assign
id|prev-&gt;active_mm
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mm
)paren
(brace
r_if
c_cond
(paren
id|next-&gt;active_mm
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|next-&gt;active_mm
op_assign
id|oldmm
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|oldmm-&gt;mm_count
)paren
suffix:semicolon
id|enter_lazy_tlb
c_func
(paren
id|oldmm
comma
id|next
comma
id|this_cpu
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|next-&gt;active_mm
op_ne
id|mm
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|switch_mm
c_func
(paren
id|oldmm
comma
id|mm
comma
id|next
comma
id|this_cpu
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|prev-&gt;mm
)paren
(brace
id|prev-&gt;active_mm
op_assign
l_int|NULL
suffix:semicolon
id|mmdrop
c_func
(paren
id|oldmm
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * This just switches the register state and the&n;&t; * stack.&n;&t; */
id|switch_to
c_func
(paren
id|prev
comma
id|next
comma
id|prev
)paren
suffix:semicolon
id|__schedule_tail
c_func
(paren
id|prev
)paren
suffix:semicolon
id|same_process
suffix:colon
id|reacquire_kernel_lock
c_func
(paren
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;need_resched
)paren
r_goto
id|need_resched_back
suffix:semicolon
r_return
suffix:semicolon
id|recalculate
suffix:colon
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|runqueue_lock
)paren
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
id|p-&gt;counter
op_assign
(paren
id|p-&gt;counter
op_rshift
l_int|1
)paren
op_plus
id|NICE_TO_TICKS
c_func
(paren
id|p-&gt;nice
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|runqueue_lock
)paren
suffix:semicolon
)brace
r_goto
id|repeat_schedule
suffix:semicolon
id|still_running
suffix:colon
id|c
op_assign
id|goodness
c_func
(paren
id|prev
comma
id|this_cpu
comma
id|prev-&gt;active_mm
)paren
suffix:semicolon
id|next
op_assign
id|prev
suffix:semicolon
r_goto
id|still_running_back
suffix:semicolon
id|handle_softirq
suffix:colon
id|do_softirq
c_func
(paren
)paren
suffix:semicolon
r_goto
id|handle_softirq_back
suffix:semicolon
id|move_rr_last
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|prev-&gt;counter
)paren
(brace
id|prev-&gt;counter
op_assign
id|NICE_TO_TICKS
c_func
(paren
id|prev-&gt;nice
)paren
suffix:semicolon
id|move_last_runqueue
c_func
(paren
id|prev
)paren
suffix:semicolon
)brace
r_goto
id|move_rr_back
suffix:semicolon
id|scheduling_in_interrupt
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Scheduling in interrupt&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|__wake_up_common
r_static
r_inline
r_void
id|__wake_up_common
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
r_int
id|mode
comma
r_int
r_int
id|wq_mode
comma
r_const
r_int
id|sync
)paren
(brace
r_struct
id|list_head
op_star
id|tmp
comma
op_star
id|head
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
comma
op_star
id|best_exclusive
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|best_cpu
comma
id|irq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
r_goto
id|out
suffix:semicolon
id|best_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|irq
op_assign
id|in_interrupt
c_func
(paren
)paren
suffix:semicolon
id|best_exclusive
op_assign
l_int|NULL
suffix:semicolon
id|wq_write_lock_irqsave
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC_WQHEAD
c_func
(paren
id|q
)paren
suffix:semicolon
macro_line|#endif
id|head
op_assign
op_amp
id|q-&gt;task_list
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
r_if
c_cond
(paren
op_logical_neg
id|head-&gt;next
op_logical_or
op_logical_neg
id|head-&gt;prev
)paren
id|WQ_BUG
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|tmp
op_assign
id|head-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|tmp
op_ne
id|head
)paren
(brace
r_int
r_int
id|state
suffix:semicolon
id|wait_queue_t
op_star
id|curr
op_assign
id|list_entry
c_func
(paren
id|tmp
comma
id|wait_queue_t
comma
id|task_list
)paren
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
suffix:semicolon
macro_line|#if WAITQUEUE_DEBUG
id|CHECK_MAGIC
c_func
(paren
id|curr-&gt;__magic
)paren
suffix:semicolon
macro_line|#endif
id|p
op_assign
id|curr-&gt;task
suffix:semicolon
id|state
op_assign
id|p-&gt;state
suffix:semicolon
r_if
c_cond
(paren
id|state
op_amp
id|mode
)paren
(brace
macro_line|#if WAITQUEUE_DEBUG
id|curr-&gt;__waker
op_assign
(paren
r_int
)paren
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t; * If waking up from an interrupt context then&n;&t;&t;&t; * prefer processes which are affine to this&n;&t;&t;&t; * CPU.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|irq
op_logical_and
(paren
id|curr-&gt;flags
op_amp
id|wq_mode
op_amp
id|WQ_FLAG_EXCLUSIVE
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|best_exclusive
)paren
id|best_exclusive
op_assign
id|p
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;processor
op_eq
id|best_cpu
)paren
(brace
id|best_exclusive
op_assign
id|p
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|sync
)paren
id|wake_up_process_synchronous
c_func
(paren
id|p
)paren
suffix:semicolon
r_else
id|wake_up_process
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|curr-&gt;flags
op_amp
id|wq_mode
op_amp
id|WQ_FLAG_EXCLUSIVE
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|best_exclusive
)paren
(brace
r_if
c_cond
(paren
id|sync
)paren
id|wake_up_process_synchronous
c_func
(paren
id|best_exclusive
)paren
suffix:semicolon
r_else
id|wake_up_process
c_func
(paren
id|best_exclusive
)paren
suffix:semicolon
)brace
id|wq_write_unlock_irqrestore
c_func
(paren
op_amp
id|q-&gt;lock
comma
id|flags
)paren
suffix:semicolon
id|out
suffix:colon
r_return
suffix:semicolon
)brace
DECL|function|__wake_up
r_void
id|__wake_up
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
r_int
id|mode
comma
r_int
r_int
id|wq_mode
)paren
(brace
id|__wake_up_common
c_func
(paren
id|q
comma
id|mode
comma
id|wq_mode
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|__wake_up_sync
r_void
id|__wake_up_sync
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
r_int
id|mode
comma
r_int
r_int
id|wq_mode
)paren
(brace
id|__wake_up_common
c_func
(paren
id|q
comma
id|mode
comma
id|wq_mode
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|macro|SLEEP_ON_VAR
mdefine_line|#define&t;SLEEP_ON_VAR&t;&t;&t;&t;&bslash;&n;&t;unsigned long flags;&t;&t;&t;&bslash;&n;&t;wait_queue_t wait;&t;&t;&t;&bslash;&n;&t;init_waitqueue_entry(&amp;wait, current);
DECL|macro|SLEEP_ON_HEAD
mdefine_line|#define&t;SLEEP_ON_HEAD&t;&t;&t;&t;&t;&bslash;&n;&t;wq_write_lock_irqsave(&amp;q-&gt;lock,flags);&t;&t;&bslash;&n;&t;__add_wait_queue(q, &amp;wait);&t;&t;&t;&bslash;&n;&t;wq_write_unlock(&amp;q-&gt;lock);
DECL|macro|SLEEP_ON_TAIL
mdefine_line|#define&t;SLEEP_ON_TAIL&t;&t;&t;&t;&t;&t;&bslash;&n;&t;wq_write_lock_irq(&amp;q-&gt;lock);&t;&t;&t;&t;&bslash;&n;&t;__remove_wait_queue(q, &amp;wait);&t;&t;&t;&t;&bslash;&n;&t;wq_write_unlock_irqrestore(&amp;q-&gt;lock,flags);
DECL|function|interruptible_sleep_on
r_void
id|interruptible_sleep_on
c_func
(paren
id|wait_queue_head_t
op_star
id|q
)paren
(brace
id|SLEEP_ON_VAR
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|SLEEP_ON_HEAD
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|SLEEP_ON_TAIL
)brace
DECL|function|interruptible_sleep_on_timeout
r_int
id|interruptible_sleep_on_timeout
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
id|timeout
)paren
(brace
id|SLEEP_ON_VAR
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|SLEEP_ON_HEAD
id|timeout
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
id|SLEEP_ON_TAIL
r_return
id|timeout
suffix:semicolon
)brace
DECL|function|sleep_on
r_void
id|sleep_on
c_func
(paren
id|wait_queue_head_t
op_star
id|q
)paren
(brace
id|SLEEP_ON_VAR
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|SLEEP_ON_HEAD
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|SLEEP_ON_TAIL
)brace
DECL|function|sleep_on_timeout
r_int
id|sleep_on_timeout
c_func
(paren
id|wait_queue_head_t
op_star
id|q
comma
r_int
id|timeout
)paren
(brace
id|SLEEP_ON_VAR
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|SLEEP_ON_HEAD
id|timeout
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
id|SLEEP_ON_TAIL
r_return
id|timeout
suffix:semicolon
)brace
DECL|function|scheduling_functions_end_here
r_void
id|scheduling_functions_end_here
c_func
(paren
r_void
)paren
(brace
)brace
macro_line|#ifndef __alpha__
multiline_comment|/*&n; * This has been replaced by sys_setpriority.  Maybe it should be&n; * moved into the arch dependent tree for those ports that require&n; * it for backward compatibility?&n; */
DECL|function|sys_nice
id|asmlinkage
r_int
id|sys_nice
c_func
(paren
r_int
id|increment
)paren
(brace
r_int
id|newprio
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Setpriority might change our priority at the same moment.&n;&t; *&t;We don&squot;t have to worry. Conceptually one call occurs first&n;&t; *&t;and we have a single winner.&n;&t; */
r_if
c_cond
(paren
id|increment
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_NICE
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|increment
OL
op_minus
l_int|40
)paren
id|increment
op_assign
op_minus
l_int|40
suffix:semicolon
)brace
r_if
c_cond
(paren
id|increment
OG
l_int|40
)paren
id|increment
op_assign
l_int|40
suffix:semicolon
id|newprio
op_assign
id|current-&gt;nice
op_plus
id|increment
suffix:semicolon
r_if
c_cond
(paren
id|newprio
OL
op_minus
l_int|20
)paren
id|newprio
op_assign
op_minus
l_int|20
suffix:semicolon
r_if
c_cond
(paren
id|newprio
OG
l_int|19
)paren
id|newprio
op_assign
l_int|19
suffix:semicolon
id|current-&gt;nice
op_assign
id|newprio
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|find_process_by_pid
r_static
r_inline
r_struct
id|task_struct
op_star
id|find_process_by_pid
c_func
(paren
id|pid_t
id|pid
)paren
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_if
c_cond
(paren
id|pid
)paren
id|tsk
op_assign
id|find_task_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
r_return
id|tsk
suffix:semicolon
)brace
DECL|function|setscheduler
r_static
r_int
id|setscheduler
c_func
(paren
id|pid_t
id|pid
comma
r_int
id|policy
comma
r_struct
id|sched_param
op_star
id|param
)paren
(brace
r_struct
id|sched_param
id|lp
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|param
op_logical_or
id|pid
OL
l_int|0
)paren
r_goto
id|out_nounlock
suffix:semicolon
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|lp
comma
id|param
comma
r_sizeof
(paren
r_struct
id|sched_param
)paren
)paren
)paren
r_goto
id|out_nounlock
suffix:semicolon
multiline_comment|/*&n;&t; * We play safe to avoid deadlocks.&n;&t; */
id|read_lock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|runqueue_lock
)paren
suffix:semicolon
id|p
op_assign
id|find_process_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_goto
id|out_unlock
suffix:semicolon
r_if
c_cond
(paren
id|policy
OL
l_int|0
)paren
id|policy
op_assign
id|p-&gt;policy
suffix:semicolon
r_else
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|policy
op_ne
id|SCHED_FIFO
op_logical_and
id|policy
op_ne
id|SCHED_RR
op_logical_and
id|policy
op_ne
id|SCHED_OTHER
)paren
r_goto
id|out_unlock
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Valid priorities for SCHED_FIFO and SCHED_RR are 1..99, valid&n;&t; * priority for SCHED_OTHER is 0.&n;&t; */
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|lp.sched_priority
template_param
l_int|99
)paren
r_goto
id|out_unlock
suffix:semicolon
r_if
c_cond
(paren
(paren
id|policy
op_eq
id|SCHED_OTHER
)paren
op_ne
(paren
id|lp.sched_priority
op_eq
l_int|0
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|retval
op_assign
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|policy
op_eq
id|SCHED_FIFO
op_logical_or
id|policy
op_eq
id|SCHED_RR
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_NICE
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current-&gt;euid
op_ne
id|p-&gt;euid
)paren
op_logical_and
(paren
id|current-&gt;euid
op_ne
id|p-&gt;uid
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_NICE
)paren
)paren
r_goto
id|out_unlock
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|p-&gt;policy
op_assign
id|policy
suffix:semicolon
id|p-&gt;rt_priority
op_assign
id|lp.sched_priority
suffix:semicolon
r_if
c_cond
(paren
id|task_on_runqueue
c_func
(paren
id|p
)paren
)paren
id|move_first_runqueue
c_func
(paren
id|p
)paren
suffix:semicolon
id|current-&gt;need_resched
op_assign
l_int|1
suffix:semicolon
id|out_unlock
suffix:colon
id|spin_unlock
c_func
(paren
op_amp
id|runqueue_lock
)paren
suffix:semicolon
id|read_unlock_irq
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|out_nounlock
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|sys_sched_setscheduler
id|asmlinkage
r_int
id|sys_sched_setscheduler
c_func
(paren
id|pid_t
id|pid
comma
r_int
id|policy
comma
r_struct
id|sched_param
op_star
id|param
)paren
(brace
r_return
id|setscheduler
c_func
(paren
id|pid
comma
id|policy
comma
id|param
)paren
suffix:semicolon
)brace
DECL|function|sys_sched_setparam
id|asmlinkage
r_int
id|sys_sched_setparam
c_func
(paren
id|pid_t
id|pid
comma
r_struct
id|sched_param
op_star
id|param
)paren
(brace
r_return
id|setscheduler
c_func
(paren
id|pid
comma
op_minus
l_int|1
comma
id|param
)paren
suffix:semicolon
)brace
DECL|function|sys_sched_getscheduler
id|asmlinkage
r_int
id|sys_sched_getscheduler
c_func
(paren
id|pid_t
id|pid
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|pid
OL
l_int|0
)paren
r_goto
id|out_nounlock
suffix:semicolon
id|retval
op_assign
op_minus
id|ESRCH
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|p
op_assign
id|find_process_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|retval
op_assign
id|p-&gt;policy
op_amp
op_complement
id|SCHED_YIELD
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|out_nounlock
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|sys_sched_getparam
id|asmlinkage
r_int
id|sys_sched_getparam
c_func
(paren
id|pid_t
id|pid
comma
r_struct
id|sched_param
op_star
id|param
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_struct
id|sched_param
id|lp
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|param
op_logical_or
id|pid
OL
l_int|0
)paren
r_goto
id|out_nounlock
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|p
op_assign
id|find_process_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|ESRCH
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_goto
id|out_unlock
suffix:semicolon
id|lp.sched_priority
op_assign
id|p-&gt;rt_priority
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This one might sleep, we cannot do it with a spinlock held ...&n;&t; */
id|retval
op_assign
id|copy_to_user
c_func
(paren
id|param
comma
op_amp
id|lp
comma
r_sizeof
(paren
op_star
id|param
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
id|out_nounlock
suffix:colon
r_return
id|retval
suffix:semicolon
id|out_unlock
suffix:colon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|sys_sched_yield
id|asmlinkage
r_int
id|sys_sched_yield
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * Trick. sched_yield() first counts the number of truly &n;&t; * &squot;pending&squot; runnable processes, then returns if it&squot;s&n;&t; * only the current processes. (This test does not have&n;&t; * to be atomic.) In threaded applications this optimization&n;&t; * gets triggered quite often.&n;&t; */
r_int
id|nr_pending
op_assign
id|nr_running
suffix:semicolon
macro_line|#if CONFIG_SMP
r_int
id|i
suffix:semicolon
singleline_comment|// Substract non-idle processes running on other CPUs.
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|aligned_data
(braket
id|i
)braket
dot
id|schedule_data.curr
op_ne
id|idle_task
c_func
(paren
id|i
)paren
)paren
id|nr_pending
op_decrement
suffix:semicolon
macro_line|#else
singleline_comment|// on UP this process is on the runqueue as well
id|nr_pending
op_decrement
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|nr_pending
)paren
(brace
multiline_comment|/*&n;&t;&t; * This process can only be rescheduled by us,&n;&t;&t; * so this is safe without any locking.&n;&t;&t; */
r_if
c_cond
(paren
id|current-&gt;policy
op_eq
id|SCHED_OTHER
)paren
id|current-&gt;policy
op_or_assign
id|SCHED_YIELD
suffix:semicolon
id|current-&gt;need_resched
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sys_sched_get_priority_max
id|asmlinkage
r_int
id|sys_sched_get_priority_max
c_func
(paren
r_int
id|policy
)paren
(brace
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|policy
)paren
(brace
r_case
id|SCHED_FIFO
suffix:colon
r_case
id|SCHED_RR
suffix:colon
id|ret
op_assign
l_int|99
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCHED_OTHER
suffix:colon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sys_sched_get_priority_min
id|asmlinkage
r_int
id|sys_sched_get_priority_min
c_func
(paren
r_int
id|policy
)paren
(brace
r_int
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|policy
)paren
(brace
r_case
id|SCHED_FIFO
suffix:colon
r_case
id|SCHED_RR
suffix:colon
id|ret
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SCHED_OTHER
suffix:colon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|sys_sched_rr_get_interval
id|asmlinkage
r_int
id|sys_sched_rr_get_interval
c_func
(paren
id|pid_t
id|pid
comma
r_struct
id|timespec
op_star
id|interval
)paren
(brace
r_struct
id|timespec
id|t
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|pid
OL
l_int|0
)paren
r_goto
id|out_nounlock
suffix:semicolon
id|retval
op_assign
op_minus
id|ESRCH
suffix:semicolon
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|p
op_assign
id|find_process_by_pid
c_func
(paren
id|pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|jiffies_to_timespec
c_func
(paren
id|p-&gt;policy
op_amp
id|SCHED_FIFO
ques
c_cond
l_int|0
suffix:colon
id|NICE_TO_TICKS
c_func
(paren
id|p-&gt;nice
)paren
comma
op_amp
id|t
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|retval
op_assign
id|copy_to_user
c_func
(paren
id|interval
comma
op_amp
id|t
comma
r_sizeof
(paren
id|t
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
id|out_nounlock
suffix:colon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|show_task
r_static
r_void
id|show_task
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
r_int
r_int
id|free
op_assign
l_int|0
suffix:semicolon
r_int
id|state
suffix:semicolon
r_static
r_const
r_char
op_star
id|stat_nam
(braket
)braket
op_assign
(brace
l_string|&quot;R&quot;
comma
l_string|&quot;S&quot;
comma
l_string|&quot;D&quot;
comma
l_string|&quot;Z&quot;
comma
l_string|&quot;T&quot;
comma
l_string|&quot;W&quot;
)brace
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%-8s  &quot;
comma
id|p-&gt;comm
)paren
suffix:semicolon
id|state
op_assign
id|p-&gt;state
ques
c_cond
id|ffz
c_func
(paren
op_complement
id|p-&gt;state
)paren
op_plus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|state
)paren
OL
r_sizeof
(paren
id|stat_nam
)paren
op_div
r_sizeof
(paren
r_char
op_star
)paren
)paren
id|printk
c_func
(paren
id|stat_nam
(braket
id|state
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
macro_line|#if (BITS_PER_LONG == 32)
r_if
c_cond
(paren
id|p
op_eq
id|current
)paren
id|printk
c_func
(paren
l_string|&quot; current  &quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; %08lX &quot;
comma
id|thread_saved_pc
c_func
(paren
op_amp
id|p-&gt;thread
)paren
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|p
op_eq
id|current
)paren
id|printk
c_func
(paren
l_string|&quot;   current task   &quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; %016lx &quot;
comma
id|thread_saved_pc
c_func
(paren
op_amp
id|p-&gt;thread
)paren
)paren
suffix:semicolon
macro_line|#endif
(brace
r_int
r_int
op_star
id|n
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|p
op_plus
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
op_star
id|n
)paren
id|n
op_increment
suffix:semicolon
id|free
op_assign
(paren
r_int
r_int
)paren
id|n
op_minus
(paren
r_int
r_int
)paren
(paren
id|p
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%5lu %5d %6d &quot;
comma
id|free
comma
id|p-&gt;pid
comma
id|p-&gt;p_pptr-&gt;pid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;p_cptr
)paren
id|printk
c_func
(paren
l_string|&quot;%5d &quot;
comma
id|p-&gt;p_cptr-&gt;pid
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;      &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;mm
)paren
id|printk
c_func
(paren
l_string|&quot; (L-TLB) &quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; (NOTLB) &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;p_ysptr
)paren
id|printk
c_func
(paren
l_string|&quot;%7d&quot;
comma
id|p-&gt;p_ysptr-&gt;pid
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;       &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;p_osptr
)paren
id|printk
c_func
(paren
l_string|&quot; %5d&bslash;n&quot;
comma
id|p-&gt;p_osptr-&gt;pid
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_X86
multiline_comment|/* This is very useful, but only works on x86 right now */
(brace
r_extern
r_void
id|show_trace
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
id|show_trace
c_func
(paren
id|p-&gt;thread.esp
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
DECL|function|render_sigset_t
r_char
op_star
id|render_sigset_t
c_func
(paren
id|sigset_t
op_star
id|set
comma
r_char
op_star
id|buffer
)paren
(brace
r_int
id|i
op_assign
id|_NSIG
comma
id|x
suffix:semicolon
r_do
(brace
id|i
op_sub_assign
l_int|4
comma
id|x
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sigismember
c_func
(paren
id|set
comma
id|i
op_plus
l_int|1
)paren
)paren
id|x
op_or_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sigismember
c_func
(paren
id|set
comma
id|i
op_plus
l_int|2
)paren
)paren
id|x
op_or_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|sigismember
c_func
(paren
id|set
comma
id|i
op_plus
l_int|3
)paren
)paren
id|x
op_or_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|sigismember
c_func
(paren
id|set
comma
id|i
op_plus
l_int|4
)paren
)paren
id|x
op_or_assign
l_int|8
suffix:semicolon
op_star
id|buffer
op_increment
op_assign
(paren
id|x
OL
l_int|10
ques
c_cond
l_char|&squot;0&squot;
suffix:colon
l_char|&squot;a&squot;
op_minus
l_int|10
)paren
op_plus
id|x
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
op_ge
l_int|4
)paren
suffix:semicolon
op_star
id|buffer
op_assign
l_int|0
suffix:semicolon
r_return
id|buffer
suffix:semicolon
)brace
DECL|function|show_state
r_void
id|show_state
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
macro_line|#if (BITS_PER_LONG == 32)
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
l_string|&quot;                         free                        sibling&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  task             PC    stack   pid father child younger older&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
l_string|&quot;                                 free                        sibling&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  task                 PC        stack   pid father child younger older&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|read_lock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
id|show_task
c_func
(paren
id|p
)paren
suffix:semicolon
id|read_unlock
c_func
(paren
op_amp
id|tasklist_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Put all the gunge required to become a kernel thread without&n; *&t;attached user resources in one place where it belongs.&n; */
DECL|function|daemonize
r_void
id|daemonize
c_func
(paren
r_void
)paren
(brace
r_struct
id|fs_struct
op_star
id|fs
suffix:semicolon
multiline_comment|/*&n;&t; * If we were started as result of loading a module, close all of the&n;&t; * user space pages.  We don&squot;t need them, and if we didn&squot;t close them&n;&t; * they would be locked into memory.&n;&t; */
id|exit_mm
c_func
(paren
id|current
)paren
suffix:semicolon
id|current-&gt;session
op_assign
l_int|1
suffix:semicolon
id|current-&gt;pgrp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Become as one with the init task */
id|exit_fs
c_func
(paren
id|current
)paren
suffix:semicolon
multiline_comment|/* current-&gt;fs-&gt;count--; */
id|fs
op_assign
id|init_task.fs
suffix:semicolon
id|current-&gt;fs
op_assign
id|fs
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|fs-&gt;count
)paren
suffix:semicolon
id|exit_files
c_func
(paren
id|current
)paren
suffix:semicolon
id|current-&gt;files
op_assign
id|init_task.files
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|current-&gt;files-&gt;count
)paren
suffix:semicolon
)brace
DECL|function|init_idle
r_void
id|__init
id|init_idle
c_func
(paren
r_void
)paren
(brace
r_struct
id|schedule_data
op_star
id|sched_data
suffix:semicolon
id|sched_data
op_assign
op_amp
id|aligned_data
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|schedule_data
suffix:semicolon
r_if
c_cond
(paren
id|current
op_ne
op_amp
id|init_task
op_logical_and
id|task_on_runqueue
c_func
(paren
id|current
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;UGH! (%d:%d) was on the runqueue, removing.&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|del_from_runqueue
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
id|sched_data-&gt;curr
op_assign
id|current
suffix:semicolon
id|sched_data-&gt;last_schedule
op_assign
id|get_cycles
c_func
(paren
)paren
suffix:semicolon
)brace
r_extern
r_void
id|init_timervecs
(paren
r_void
)paren
suffix:semicolon
DECL|function|sched_init
r_void
id|__init
id|sched_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * We have to do a little magic to get the first&n;&t; * process right in SMP mode.&n;&t; */
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|nr
suffix:semicolon
id|init_task.processor
op_assign
id|cpu
suffix:semicolon
r_for
c_loop
(paren
id|nr
op_assign
l_int|0
suffix:semicolon
id|nr
OL
id|PIDHASH_SZ
suffix:semicolon
id|nr
op_increment
)paren
(brace
id|pidhash
(braket
id|nr
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|init_timervecs
c_func
(paren
)paren
suffix:semicolon
id|init_bh
c_func
(paren
id|TIMER_BH
comma
id|timer_bh
)paren
suffix:semicolon
id|init_bh
c_func
(paren
id|TQUEUE_BH
comma
id|tqueue_bh
)paren
suffix:semicolon
id|init_bh
c_func
(paren
id|IMMEDIATE_BH
comma
id|immediate_bh
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The boot idle thread does lazy MMU switching as well:&n;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|init_mm.mm_count
)paren
suffix:semicolon
id|enter_lazy_tlb
c_func
(paren
op_amp
id|init_mm
comma
id|current
comma
id|cpu
)paren
suffix:semicolon
)brace
eof
