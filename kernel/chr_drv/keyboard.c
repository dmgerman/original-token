multiline_comment|/*&n; * linux/kernel/chr_drv/keyboard.c&n; *&n; * Keyboard driver for Linux v0.96 using Latin-1.&n; *&n; * Written for linux by Johan Myreen as a translation from&n; * the assembly version by Linus (with diacriticals added)&n; *&n; * Some additional features added by Christoph Niemann (ChN), March 1993&n; *&n; * Loadable keymaps by Risto Kankkunen, May 1993&n; */
DECL|macro|KEYBOARD_IRQ
mdefine_line|#define KEYBOARD_IRQ 1
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/keyboard.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#ifndef KBD_DEFFLAGS
macro_line|#ifdef CONFIG_KBD_META
DECL|macro|KBD_META
mdefine_line|#define KBD_META (1 &lt;&lt; VC_META)
macro_line|#else
DECL|macro|KBD_META
mdefine_line|#define KBD_META 0
macro_line|#endif
macro_line|#ifdef CONFIG_KBD_NUML
DECL|macro|KBD_NUML
mdefine_line|#define KBD_NUML (1 &lt;&lt; VC_NUMLOCK)
macro_line|#else
DECL|macro|KBD_NUML
mdefine_line|#define KBD_NUML 0
macro_line|#endif
DECL|macro|KBD_DEFFLAGS
mdefine_line|#define KBD_DEFFLAGS (KBD_NUML | (1 &lt;&lt; VC_REPEAT) | KBD_META)
macro_line|#endif
multiline_comment|/*&n; * The default IO slowdown is doing &squot;inb()&squot;s from 0x61, which should be&n; * safe. But as that is the keyboard controller chip address, we do our&n; * slowdowns here by doing short jumps: the keyboard controller should&n; * be able to keep up&n; */
DECL|macro|REALLY_SLOW_IO
mdefine_line|#define REALLY_SLOW_IO
DECL|macro|SLOW_IO_BY_JUMPING
mdefine_line|#define SLOW_IO_BY_JUMPING
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
r_extern
r_void
id|do_keyboard_interrupt
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|ctrl_alt_del
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|change_console
c_func
(paren
r_int
r_int
id|new_console
)paren
suffix:semicolon
r_extern
r_void
id|scrollback
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_void
id|scrollfront
c_func
(paren
r_int
)paren
suffix:semicolon
DECL|macro|fake_keyboard_interrupt
mdefine_line|#define fake_keyboard_interrupt() &bslash;&n;__asm__ __volatile__(&quot;int $0x21&quot;)
DECL|variable|kbd_dead_keys
r_int
r_int
id|kbd_dead_keys
op_assign
l_int|0
suffix:semicolon
DECL|variable|kbd_prev_dead_keys
r_int
r_int
id|kbd_prev_dead_keys
op_assign
l_int|0
suffix:semicolon
DECL|variable|k_down
r_static
r_int
r_char
id|k_down
(braket
id|NR_SHIFT
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|want_console
r_static
r_int
id|want_console
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|last_console
r_static
r_int
id|last_console
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* last used VC */
DECL|variable|rep
r_static
r_char
id|rep
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* flag telling character repeat */
DECL|variable|kbd_table
r_struct
id|kbd_struct
id|kbd_table
(braket
id|NR_CONSOLES
)braket
suffix:semicolon
DECL|variable|kbd
r_static
r_struct
id|kbd_struct
op_star
id|kbd
op_assign
id|kbd_table
suffix:semicolon
DECL|variable|tty
r_static
r_struct
id|tty_struct
op_star
id|tty
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|acknowledge
r_static
r_volatile
r_int
r_char
id|acknowledge
op_assign
l_int|0
suffix:semicolon
DECL|variable|resend
r_static
r_volatile
r_int
r_char
id|resend
op_assign
l_int|0
suffix:semicolon
DECL|typedef|k_hand
r_typedef
r_void
(paren
op_star
id|k_hand
)paren
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
suffix:semicolon
r_static
r_void
id|do_self
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
suffix:semicolon
r_static
r_void
id|do_fn
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
suffix:semicolon
r_static
r_void
id|do_spec
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
suffix:semicolon
r_static
r_void
id|do_pad
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
suffix:semicolon
r_static
r_void
id|do_dead
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
suffix:semicolon
r_static
r_void
id|do_cons
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
suffix:semicolon
r_static
r_void
id|do_cur
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
suffix:semicolon
r_static
r_void
id|do_shift
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
suffix:semicolon
r_static
r_void
id|do_meta
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
suffix:semicolon
r_static
r_void
id|do_ascii
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
suffix:semicolon
DECL|variable|key_handler
r_static
id|k_hand
id|key_handler
(braket
)braket
op_assign
(brace
id|do_self
comma
id|do_fn
comma
id|do_spec
comma
id|do_pad
comma
id|do_dead
comma
id|do_cons
comma
id|do_cur
comma
id|do_shift
comma
id|do_meta
comma
id|do_ascii
)brace
suffix:semicolon
multiline_comment|/* maximum values each key_handler can handle */
DECL|variable|max_vals
r_const
r_int
id|max_vals
(braket
)braket
op_assign
(brace
l_int|255
comma
id|NR_FUNC
op_minus
l_int|1
comma
l_int|13
comma
l_int|16
comma
l_int|4
comma
l_int|255
comma
l_int|3
comma
id|NR_SHIFT
comma
l_int|255
comma
l_int|9
)brace
suffix:semicolon
DECL|variable|NR_TYPES
r_const
r_int
id|NR_TYPES
op_assign
(paren
r_sizeof
(paren
id|max_vals
)paren
op_div
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
DECL|macro|E0_BASE
mdefine_line|#define E0_BASE 96
DECL|variable|shift_state
r_static
r_int
id|shift_state
op_assign
l_int|0
suffix:semicolon
DECL|variable|diacr
r_static
r_int
id|diacr
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|npadch
r_static
r_int
id|npadch
op_assign
l_int|0
suffix:semicolon
r_static
r_void
id|put_queue
c_func
(paren
r_int
)paren
suffix:semicolon
r_static
r_int
r_int
id|handle_diacr
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|variable|pt_regs
r_static
r_struct
id|pt_regs
op_star
id|pt_regs
suffix:semicolon
r_static
r_inline
r_void
id|translate
c_func
(paren
r_int
r_char
id|scancode
)paren
suffix:semicolon
DECL|function|kb_wait
r_static
r_inline
r_void
id|kb_wait
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x10000
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|inb_p
c_func
(paren
l_int|0x64
)paren
op_amp
l_int|0x02
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
DECL|function|keyboard_interrupt
r_static
r_void
id|keyboard_interrupt
c_func
(paren
r_int
id|int_pt_regs
)paren
(brace
r_int
r_char
id|scancode
suffix:semicolon
id|pt_regs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
id|int_pt_regs
suffix:semicolon
id|kbd_prev_dead_keys
op_or_assign
id|kbd_dead_keys
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kbd_dead_keys
)paren
id|kbd_prev_dead_keys
op_assign
l_int|0
suffix:semicolon
id|kbd_dead_keys
op_assign
l_int|0
suffix:semicolon
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb_p
c_func
(paren
l_int|0x64
)paren
op_amp
l_int|0x01
)paren
)paren
r_goto
id|end_kbd_intr
suffix:semicolon
id|scancode
op_assign
id|inb
c_func
(paren
l_int|0x60
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|KEYBOARD_BH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0xfa
)paren
(brace
id|acknowledge
op_assign
l_int|1
suffix:semicolon
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0xfe
)paren
(brace
id|resend
op_assign
l_int|1
suffix:semicolon
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
id|tty
op_assign
id|TTY_TABLE
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|kbd
op_assign
id|kbd_table
op_plus
id|fg_console
suffix:semicolon
r_if
c_cond
(paren
id|vc_kbd_flag
c_func
(paren
id|kbd
comma
id|VC_RAW
)paren
)paren
(brace
id|memset
c_func
(paren
id|k_down
comma
l_int|0
comma
r_sizeof
(paren
id|k_down
)paren
)paren
suffix:semicolon
id|put_queue
c_func
(paren
id|scancode
)paren
suffix:semicolon
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
r_else
id|translate
c_func
(paren
id|scancode
)paren
suffix:semicolon
id|end_kbd_intr
suffix:colon
r_return
suffix:semicolon
)brace
DECL|function|translate
r_static
r_inline
r_void
id|translate
c_func
(paren
r_int
r_char
id|scancode
)paren
(brace
r_char
id|break_flag
suffix:semicolon
r_static
r_int
r_int
id|key_down
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
r_static
r_int
r_char
id|e0_keys
(braket
)braket
op_assign
(brace
l_int|0x1c
comma
multiline_comment|/* keypad enter */
l_int|0x1d
comma
multiline_comment|/* right control */
l_int|0x35
comma
multiline_comment|/* keypad slash */
l_int|0x37
comma
multiline_comment|/* print screen */
l_int|0x38
comma
multiline_comment|/* right alt */
l_int|0x46
comma
multiline_comment|/* break (control-pause) */
l_int|0x47
comma
multiline_comment|/* editpad home */
l_int|0x48
comma
multiline_comment|/* editpad up */
l_int|0x49
comma
multiline_comment|/* editpad pgup */
l_int|0x4b
comma
multiline_comment|/* editpad left */
l_int|0x4d
comma
multiline_comment|/* editpad right */
l_int|0x4f
comma
multiline_comment|/* editpad end */
l_int|0x50
comma
multiline_comment|/* editpad dn */
l_int|0x51
comma
multiline_comment|/* editpad pgdn */
l_int|0x52
comma
multiline_comment|/* editpad ins */
l_int|0x53
comma
multiline_comment|/* editpad del */
macro_line|#ifdef LK450
l_int|0x3d
comma
multiline_comment|/* f13 */
l_int|0x3e
comma
multiline_comment|/* f14 */
l_int|0x3f
comma
multiline_comment|/* help */
l_int|0x40
comma
multiline_comment|/* do */
l_int|0x41
comma
multiline_comment|/* f17 */
l_int|0x4e
multiline_comment|/* keypad minus/plus */
macro_line|#endif
)brace
suffix:semicolon
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0xe0
)paren
(brace
id|set_kbd_dead
c_func
(paren
id|KGD_E0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0xe1
)paren
(brace
id|set_kbd_dead
c_func
(paren
id|KGD_E1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  The keyboard maintains its own internal caps lock and num lock&n;&t; *  statuses. In caps lock mode E0 AA precedes make code and E0 2A&n;&t; *  follows break code. In num lock mode, E0 2A precedes make&n;&t; *  code and E0 AA follows break code. We do our own book-keeping,&n;&t; *  so we will just ignore these.&n;&t; */
r_if
c_cond
(paren
id|kbd_dead
c_func
(paren
id|KGD_E0
)paren
op_logical_and
(paren
id|scancode
op_eq
l_int|0x2a
op_logical_or
id|scancode
op_eq
l_int|0xaa
op_logical_or
id|scancode
op_eq
l_int|0x36
op_logical_or
id|scancode
op_eq
l_int|0xb6
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* map two byte scancodes into one byte id&squot;s */
id|break_flag
op_assign
id|scancode
OG
l_int|0x7f
suffix:semicolon
id|scancode
op_and_assign
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|scancode
op_ge
id|E0_BASE
)paren
(brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;keyboard: scancode (%02x) not in range 00 - %2x&bslash;n&quot;
comma
id|scancode
comma
id|E0_BASE
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kbd_dead
c_func
(paren
id|KGD_E0
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|e0_keys
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|scancode
op_eq
id|e0_keys
(braket
id|i
)braket
)paren
(brace
id|scancode
op_assign
id|E0_BASE
op_plus
id|i
suffix:semicolon
id|i
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ne
op_minus
l_int|1
)paren
(brace
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;keyboard: unknown scancode e0 %02x&bslash;n&quot;
comma
id|scancode
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
)brace
id|rep
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|break_flag
)paren
id|clear_bit
c_func
(paren
id|scancode
comma
id|key_down
)paren
suffix:semicolon
r_else
id|rep
op_assign
id|set_bit
c_func
(paren
id|scancode
comma
id|key_down
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Repeat a key only if the input buffers are empty or the&n;&t; *  characters get echoed locally. This makes key repeat usable&n;&t; *  with slow applications and under heavy loads.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rep
op_logical_or
(paren
id|vc_kbd_flag
c_func
(paren
id|kbd
comma
id|VC_REPEAT
)paren
op_logical_and
id|tty
op_logical_and
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
op_logical_or
(paren
id|EMPTY
c_func
(paren
op_amp
id|tty-&gt;secondary
)paren
op_logical_and
id|EMPTY
c_func
(paren
op_amp
id|tty-&gt;read_q
)paren
)paren
)paren
)paren
)paren
(brace
id|u_short
id|key_code
suffix:semicolon
id|key_code
op_assign
id|key_map
(braket
id|shift_state
)braket
(braket
id|scancode
)braket
suffix:semicolon
(paren
op_star
id|key_handler
(braket
id|key_code
op_rshift
l_int|8
)braket
)paren
(paren
id|key_code
op_amp
l_int|0xff
comma
id|break_flag
)paren
suffix:semicolon
)brace
)brace
DECL|function|put_queue
r_static
r_void
id|put_queue
c_func
(paren
r_int
id|ch
)paren
(brace
r_struct
id|tty_queue
op_star
id|qp
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|keypress_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|qp
op_assign
op_amp
id|tty-&gt;read_q
suffix:semicolon
r_if
c_cond
(paren
id|LEFT
c_func
(paren
id|qp
)paren
)paren
(brace
id|qp-&gt;buf
(braket
id|qp-&gt;head
)braket
op_assign
id|ch
suffix:semicolon
id|INC
c_func
(paren
id|qp-&gt;head
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|qp-&gt;proc_list
)paren
suffix:semicolon
)brace
)brace
DECL|function|puts_queue
r_static
r_void
id|puts_queue
c_func
(paren
r_char
op_star
id|cp
)paren
(brace
r_struct
id|tty_queue
op_star
id|qp
suffix:semicolon
r_char
id|ch
suffix:semicolon
multiline_comment|/* why interruptible here, plain wake_up above? */
id|wake_up_interruptible
c_func
(paren
op_amp
id|keypress_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|qp
op_assign
op_amp
id|tty-&gt;read_q
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ch
op_assign
op_star
(paren
id|cp
op_increment
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|LEFT
c_func
(paren
id|qp
)paren
)paren
(brace
id|qp-&gt;buf
(braket
id|qp-&gt;head
)braket
op_assign
id|ch
suffix:semicolon
id|INC
c_func
(paren
id|qp-&gt;head
)paren
suffix:semicolon
)brace
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|qp-&gt;proc_list
)paren
suffix:semicolon
)brace
DECL|function|applkey
r_static
r_void
id|applkey
c_func
(paren
r_int
id|key
comma
r_char
id|mode
)paren
(brace
r_static
r_char
id|buf
(braket
)braket
op_assign
(brace
l_int|0x1b
comma
l_char|&squot;O&squot;
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
(paren
id|mode
ques
c_cond
l_char|&squot;O&squot;
suffix:colon
l_char|&squot;[&squot;
)paren
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
id|key
suffix:semicolon
id|puts_queue
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
DECL|function|enter
r_static
r_void
id|enter
c_func
(paren
r_void
)paren
(brace
id|put_queue
c_func
(paren
l_int|13
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vc_kbd_flag
c_func
(paren
id|kbd
comma
id|VC_CRLF
)paren
)paren
id|put_queue
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|caps_toggle
r_static
r_void
id|caps_toggle
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|rep
)paren
r_return
suffix:semicolon
id|chg_vc_kbd_flag
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
suffix:semicolon
)brace
DECL|function|caps_on
r_static
r_void
id|caps_on
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|rep
)paren
r_return
suffix:semicolon
id|set_vc_kbd_flag
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
suffix:semicolon
)brace
DECL|function|show_ptregs
r_static
r_void
id|show_ptregs
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pt_regs
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EIP: %04x:%08x&quot;
comma
l_int|0xffff
op_amp
id|pt_regs-&gt;cs
comma
id|pt_regs-&gt;eip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pt_regs-&gt;cs
op_amp
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot; ESP: %04x:%08x&quot;
comma
l_int|0xffff
op_amp
id|pt_regs-&gt;ss
comma
id|pt_regs-&gt;esp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; EFLAGS: %08x&bslash;n&quot;
comma
id|pt_regs-&gt;eflags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EAX: %08x EBX: %08x ECX: %08x EDX: %08x&bslash;n&quot;
comma
id|pt_regs-&gt;orig_eax
comma
id|pt_regs-&gt;ebx
comma
id|pt_regs-&gt;ecx
comma
id|pt_regs-&gt;edx
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ESI: %08x EDI: %08x EBP: %08x&quot;
comma
id|pt_regs-&gt;esi
comma
id|pt_regs-&gt;edi
comma
id|pt_regs-&gt;ebp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; DS: %04x ES: %04x FS: %04x GS: %04x&bslash;n&quot;
comma
l_int|0xffff
op_amp
id|pt_regs-&gt;ds
comma
l_int|0xffff
op_amp
id|pt_regs-&gt;es
comma
l_int|0xffff
op_amp
id|pt_regs-&gt;fs
comma
l_int|0xffff
op_amp
id|pt_regs-&gt;gs
)paren
suffix:semicolon
)brace
DECL|function|hold
r_static
r_void
id|hold
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|rep
op_logical_or
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|vc_kbd_flag
c_func
(paren
id|kbd
comma
id|VC_SCROLLOCK
)paren
)paren
multiline_comment|/* pressing srcoll lock 2nd time sends ^Q, ChN */
id|put_queue
c_func
(paren
id|START_CHAR
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
r_else
multiline_comment|/* pressing srcoll lock 1st time sends ^S, ChN */
id|put_queue
c_func
(paren
id|STOP_CHAR
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
id|chg_vc_kbd_flag
c_func
(paren
id|kbd
comma
id|VC_SCROLLOCK
)paren
suffix:semicolon
)brace
DECL|function|num
r_static
r_void
id|num
c_func
(paren
r_void
)paren
(brace
macro_line|#if 0
r_if
c_cond
(paren
id|k_down
(braket
id|KG_CTRL
)braket
)paren
(brace
multiline_comment|/* pause key pressed, sends E1 1D 45, ChN */
id|chg_vc_kbd_flag
c_func
(paren
id|kbd
comma
id|VC_PAUSE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|vc_kbd_flag
c_func
(paren
id|kbd
comma
id|VC_APPLIC
)paren
)paren
(brace
id|applkey
c_func
(paren
l_char|&squot;P&squot;
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rep
)paren
multiline_comment|/* no autorepeat for numlock, ChN */
id|chg_vc_kbd_flag
c_func
(paren
id|kbd
comma
id|VC_NUMLOCK
)paren
suffix:semicolon
)brace
DECL|function|lastcons
r_static
r_void
id|lastcons
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* pressing alt-printscreen switches to the last used console, ChN */
id|want_console
op_assign
id|last_console
suffix:semicolon
)brace
DECL|function|send_intr
r_static
r_void
id|send_intr
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|tty
)paren
id|put_queue
c_func
(paren
id|INTR_CHAR
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
)brace
DECL|function|scrll_forw
r_static
r_void
id|scrll_forw
c_func
(paren
r_void
)paren
(brace
id|scrollfront
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|scrll_back
r_static
r_void
id|scrll_back
c_func
(paren
r_void
)paren
(brace
id|scrollback
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|boot_it
r_static
r_void
id|boot_it
c_func
(paren
r_void
)paren
(brace
id|ctrl_alt_del
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|do_spec
r_static
r_void
id|do_spec
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_typedef
r_void
(paren
op_star
id|fnp
)paren
(paren
r_void
)paren
suffix:semicolon
id|fnp
id|fn_table
(braket
)braket
op_assign
(brace
l_int|NULL
comma
id|enter
comma
id|show_ptregs
comma
id|show_mem
comma
id|show_state
comma
id|send_intr
comma
id|lastcons
comma
id|caps_toggle
comma
id|num
comma
id|hold
comma
id|scrll_forw
comma
id|scrll_back
comma
id|boot_it
comma
id|caps_on
)brace
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ge
r_sizeof
(paren
id|fn_table
)paren
op_div
r_sizeof
(paren
id|fnp
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fn_table
(braket
id|value
)braket
)paren
r_return
suffix:semicolon
id|fn_table
(braket
id|value
)braket
(paren
)paren
suffix:semicolon
)brace
DECL|function|do_self
r_static
r_void
id|do_self
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
multiline_comment|/* no action, if this is a key release */
id|value
op_assign
id|handle_diacr
c_func
(paren
id|value
)paren
suffix:semicolon
multiline_comment|/* kludge... but works for ISO 8859-1 */
r_if
c_cond
(paren
id|vc_kbd_flag
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
)paren
r_if
c_cond
(paren
(paren
id|value
op_ge
l_char|&squot;a&squot;
op_logical_and
id|value
op_le
l_char|&squot;z&squot;
)paren
op_logical_or
(paren
id|value
op_ge
l_int|224
op_logical_and
id|value
op_le
l_int|254
)paren
)paren
(brace
id|value
op_sub_assign
l_int|32
suffix:semicolon
)brace
id|put_queue
c_func
(paren
id|value
)paren
suffix:semicolon
)brace
DECL|variable|ret_diacr
r_static
r_int
r_char
id|ret_diacr
(braket
)braket
op_assign
(brace
l_char|&squot;`&squot;
comma
l_char|&squot;&bslash;&squot;&squot;
comma
l_char|&squot;^&squot;
comma
l_char|&squot;~&squot;
comma
l_char|&squot;&quot;&squot;
)brace
suffix:semicolon
multiline_comment|/* Must not end with 0 */
multiline_comment|/* If a dead key pressed twice, output a character corresponding to it,&t;*/
multiline_comment|/* otherwise just remember the dead key.&t;&t;&t;&t;*/
DECL|function|do_dead
r_static
r_void
id|do_dead
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|diacr
op_eq
id|value
)paren
(brace
multiline_comment|/* pressed twice */
id|diacr
op_assign
op_minus
l_int|1
suffix:semicolon
id|put_queue
c_func
(paren
id|ret_diacr
(braket
id|value
)braket
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|diacr
op_assign
id|value
suffix:semicolon
)brace
multiline_comment|/* If no pending dead key, return the character unchanged. Otherwise,&t;*/
multiline_comment|/* if space if pressed, return a character corresponding the pending&t;*/
multiline_comment|/* dead key, otherwise try to combine the two.&t;&t;&t;&t;*/
DECL|function|handle_diacr
r_int
r_int
id|handle_diacr
c_func
(paren
r_int
r_int
id|ch
)paren
(brace
r_static
r_int
r_char
id|accent_table
(braket
l_int|5
)braket
(braket
l_int|64
)braket
op_assign
(brace
l_string|&quot; &bslash;300BCD&bslash;310FGH&bslash;314JKLMN&bslash;322PQRST&bslash;331VWXYZ[&bslash;&bslash;]^_&quot;
l_string|&quot;`&bslash;340bcd&bslash;350fgh&bslash;354jklmn&bslash;362pqrst&bslash;371vwxyz{|}~&quot;
comma
multiline_comment|/* accent grave */
l_string|&quot; &bslash;301BCD&bslash;311FGH&bslash;315JKLMN&bslash;323PQRST&bslash;332VWX&bslash;335Z[&bslash;&bslash;]^_&quot;
l_string|&quot;`&bslash;341bcd&bslash;351fgh&bslash;355jklmn&bslash;363pqrst&bslash;372vwx&bslash;375z{|}~&quot;
comma
multiline_comment|/* accent acute */
l_string|&quot; &bslash;302BCD&bslash;312FGH&bslash;316JKLMN&bslash;324PQRST&bslash;333VWXYZ[&bslash;&bslash;]^_&quot;
l_string|&quot;`&bslash;342bcd&bslash;352fgh&bslash;356jklmn&bslash;364pqrst&bslash;373vwxyz{|}~&quot;
comma
multiline_comment|/* circumflex */
l_string|&quot; &bslash;303BCDEFGHIJKLM&bslash;321&bslash;325PQRSTUVWXYZ[&bslash;&bslash;]^_&quot;
l_string|&quot;`&bslash;343bcdefghijklm&bslash;361&bslash;365pqrstuvwxyz{|}~&quot;
comma
multiline_comment|/* tilde */
l_string|&quot; &bslash;304BCD&bslash;313FGH&bslash;317JKLMN&bslash;326PQRST&bslash;334VWXYZ[&bslash;&bslash;]^_&quot;
l_string|&quot;`&bslash;344bcd&bslash;353fgh&bslash;357jklmn&bslash;366pqrst&bslash;374vwx&bslash;377z{|}~&quot;
multiline_comment|/* dieresis */
)brace
suffix:semicolon
r_int
id|d
op_assign
id|diacr
comma
id|e
suffix:semicolon
r_if
c_cond
(paren
id|diacr
op_eq
op_minus
l_int|1
)paren
r_return
id|ch
suffix:semicolon
id|diacr
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot; &squot;
)paren
r_return
id|ret_diacr
(braket
id|d
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_ge
l_int|64
op_logical_and
id|ch
op_le
l_int|122
)paren
(brace
id|e
op_assign
id|accent_table
(braket
id|d
)braket
(braket
id|ch
op_minus
l_int|64
)braket
suffix:semicolon
r_if
c_cond
(paren
id|e
op_ne
id|ch
)paren
r_return
id|e
suffix:semicolon
)brace
id|put_queue
c_func
(paren
id|ret_diacr
(braket
id|d
)braket
)paren
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
DECL|function|do_cons
r_static
r_void
id|do_cons
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
id|want_console
op_assign
id|value
suffix:semicolon
)brace
DECL|function|do_fn
r_static
r_void
id|do_fn
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
id|puts_queue
c_func
(paren
id|func_table
(braket
id|value
)braket
)paren
suffix:semicolon
)brace
DECL|function|do_pad
r_static
r_void
id|do_pad
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_static
r_char
op_star
id|pad_chars
op_assign
l_string|&quot;0123456789+-*/&bslash;015,.&quot;
suffix:semicolon
r_static
r_char
op_star
id|app_map
op_assign
l_string|&quot;pqrstuvwxylSRQMnn&quot;
suffix:semicolon
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
multiline_comment|/* no action, if this is a key release */
multiline_comment|/* kludge... shift forces cursor/number keys */
r_if
c_cond
(paren
id|vc_kbd_flag
c_func
(paren
id|kbd
comma
id|VC_APPLIC
)paren
op_logical_and
op_logical_neg
id|k_down
(braket
id|KG_SHIFT
)braket
)paren
(brace
id|applkey
c_func
(paren
id|app_map
(braket
id|value
)braket
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|vc_kbd_flag
c_func
(paren
id|kbd
comma
id|VC_NUMLOCK
)paren
)paren
r_switch
c_cond
(paren
id|value
)paren
(brace
r_case
id|KVAL
c_func
(paren
id|K_PCOMMA
)paren
suffix:colon
r_case
id|KVAL
c_func
(paren
id|K_PDOT
)paren
suffix:colon
id|do_fn
c_func
(paren
id|KVAL
c_func
(paren
id|K_REMOVE
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P0
)paren
suffix:colon
id|do_fn
c_func
(paren
id|KVAL
c_func
(paren
id|K_INSERT
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P1
)paren
suffix:colon
id|do_fn
c_func
(paren
id|KVAL
c_func
(paren
id|K_SELECT
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P2
)paren
suffix:colon
id|do_cur
c_func
(paren
id|KVAL
c_func
(paren
id|K_DOWN
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P3
)paren
suffix:colon
id|do_fn
c_func
(paren
id|KVAL
c_func
(paren
id|K_PGDN
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P4
)paren
suffix:colon
id|do_cur
c_func
(paren
id|KVAL
c_func
(paren
id|K_LEFT
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P6
)paren
suffix:colon
id|do_cur
c_func
(paren
id|KVAL
c_func
(paren
id|K_RIGHT
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P7
)paren
suffix:colon
id|do_fn
c_func
(paren
id|KVAL
c_func
(paren
id|K_FIND
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P8
)paren
suffix:colon
id|do_cur
c_func
(paren
id|KVAL
c_func
(paren
id|K_UP
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P9
)paren
suffix:colon
id|do_fn
c_func
(paren
id|KVAL
c_func
(paren
id|K_PGUP
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P5
)paren
suffix:colon
id|applkey
c_func
(paren
l_char|&squot;G&squot;
comma
id|vc_kbd_flag
c_func
(paren
id|kbd
comma
id|VC_APPLIC
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|put_queue
c_func
(paren
id|pad_chars
(braket
id|value
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_eq
id|KVAL
c_func
(paren
id|K_PENTER
)paren
op_logical_and
id|vc_kbd_flag
c_func
(paren
id|kbd
comma
id|VC_CRLF
)paren
)paren
id|put_queue
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|do_cur
r_static
r_void
id|do_cur
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_static
r_char
op_star
id|cur_chars
op_assign
l_string|&quot;BDCA&quot;
suffix:semicolon
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
id|applkey
c_func
(paren
id|cur_chars
(braket
id|value
)braket
comma
id|vc_kbd_flag
c_func
(paren
id|kbd
comma
id|VC_CKMODE
)paren
)paren
suffix:semicolon
)brace
DECL|function|do_shift
r_static
r_void
id|do_shift
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_int
id|old_state
op_assign
id|shift_state
suffix:semicolon
r_if
c_cond
(paren
id|rep
)paren
r_return
suffix:semicolon
multiline_comment|/* kludge... */
r_if
c_cond
(paren
id|value
op_eq
id|KVAL
c_func
(paren
id|K_CAPSSHIFT
)paren
)paren
(brace
id|value
op_assign
id|KVAL
c_func
(paren
id|K_SHIFT
)paren
suffix:semicolon
id|clr_vc_kbd_flag
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|k_down
(braket
id|value
)braket
)paren
id|k_down
(braket
id|value
)braket
op_decrement
suffix:semicolon
)brace
r_else
id|k_down
(braket
id|value
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|k_down
(braket
id|value
)braket
)paren
id|shift_state
op_or_assign
(paren
l_int|1
op_lshift
id|value
)paren
suffix:semicolon
r_else
id|shift_state
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|value
)paren
suffix:semicolon
multiline_comment|/* kludge */
r_if
c_cond
(paren
id|up_flag
op_logical_and
id|shift_state
op_ne
id|old_state
op_logical_and
id|npadch
op_ne
l_int|0
)paren
(brace
id|put_queue
c_func
(paren
id|npadch
)paren
suffix:semicolon
id|npadch
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|do_meta
r_static
r_void
id|do_meta
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|vc_kbd_flag
c_func
(paren
id|kbd
comma
id|VC_META
)paren
)paren
(brace
id|put_queue
c_func
(paren
l_char|&squot;&bslash;033&squot;
)paren
suffix:semicolon
id|put_queue
c_func
(paren
id|value
)paren
suffix:semicolon
)brace
r_else
id|put_queue
c_func
(paren
id|value
op_or
l_int|0x80
)paren
suffix:semicolon
)brace
DECL|function|do_ascii
r_static
r_void
id|do_ascii
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
id|npadch
op_assign
(paren
id|npadch
op_star
l_int|10
op_plus
id|value
)paren
op_mod
l_int|1000
suffix:semicolon
)brace
multiline_comment|/*&n; * send_data sends a character to the keyboard and waits&n; * for a acknowledge, possibly retrying if asked to. Returns&n; * the success status.&n; */
DECL|function|send_data
r_static
r_int
id|send_data
c_func
(paren
r_int
r_char
id|data
)paren
(brace
r_int
id|retries
op_assign
l_int|3
suffix:semicolon
r_int
id|i
suffix:semicolon
r_do
(brace
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
id|acknowledge
op_assign
l_int|0
suffix:semicolon
id|resend
op_assign
l_int|0
suffix:semicolon
id|outb_p
c_func
(paren
id|data
comma
l_int|0x60
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x20000
suffix:semicolon
id|i
op_increment
)paren
(brace
id|inb_p
c_func
(paren
l_int|0x64
)paren
suffix:semicolon
multiline_comment|/* just as a delay */
r_if
c_cond
(paren
id|acknowledge
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|resend
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|resend
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|retries
op_decrement
OG
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is the bottom half of the keyboard interrupt&n; * routine, and runs with all interrupts enabled. It does&n; * console changing, led setting and copy_to_cooked, which can&n; * take a reasonably long time.&n; *&n; * Aside from timing (which isn&squot;t really that important for&n; * keyboard interrupts as they happen often), using the software&n; * interrupt routines for this thing allows us to easily mask&n; * this when we don&squot;t want any of the above to happen. Not yet&n; * used, but this allows for easy and efficient race-condition&n; * prevention later on.&n; */
DECL|function|kbd_bh
r_static
r_void
id|kbd_bh
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
r_static
r_int
r_char
id|old_leds
op_assign
l_int|0xff
suffix:semicolon
r_int
r_char
id|leds
op_assign
id|kbd_table
(braket
id|fg_console
)braket
dot
id|flags
op_amp
id|LED_MASK
suffix:semicolon
r_if
c_cond
(paren
id|leds
op_ne
id|old_leds
)paren
(brace
id|old_leds
op_assign
id|leds
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|send_data
c_func
(paren
l_int|0xed
)paren
op_logical_or
op_logical_neg
id|send_data
c_func
(paren
id|leds
)paren
)paren
id|send_data
c_func
(paren
l_int|0xf4
)paren
suffix:semicolon
multiline_comment|/* re-enable kbd if any errors */
)brace
r_if
c_cond
(paren
id|want_console
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|want_console
op_ne
id|fg_console
)paren
(brace
id|last_console
op_assign
id|fg_console
suffix:semicolon
id|change_console
c_func
(paren
id|want_console
)paren
suffix:semicolon
)brace
id|want_console
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|do_keyboard_interrupt
c_func
(paren
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb_p
c_func
(paren
l_int|0x64
)paren
op_amp
l_int|0x01
)paren
id|fake_keyboard_interrupt
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|no_idt
r_int
id|no_idt
(braket
l_int|2
)braket
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * This routine reboots the machine by asking the keyboard&n; * controller to pulse the reset-line low. We try that for a while,&n; * and if it doesn&squot;t work, we do some other stupid things.&n; */
DECL|function|hard_reset_now
r_void
id|hard_reset_now
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_extern
r_int
r_int
id|pg0
(braket
l_int|1024
)braket
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* rebooting needs to touch the page at absolute addr 0 */
id|pg0
(braket
l_int|0
)braket
op_assign
l_int|7
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
l_int|0x472
)paren
op_assign
l_int|0x1234
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|100000
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/* nothing */
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0xfe
comma
l_int|0x64
)paren
suffix:semicolon
multiline_comment|/* pulse reset low */
)brace
id|__asm__
c_func
(paren
l_string|&quot;&bslash;tlidt _no_idt&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|kbd_init
r_int
r_int
id|kbd_init
c_func
(paren
r_int
r_int
id|kmem_start
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|kbd_struct
op_star
id|kbd
suffix:semicolon
id|kbd
op_assign
id|kbd_table
op_plus
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CONSOLES
suffix:semicolon
id|i
op_increment
comma
id|kbd
op_increment
)paren
(brace
id|kbd-&gt;flags
op_assign
id|KBD_DEFFLAGS
suffix:semicolon
id|kbd-&gt;default_flags
op_assign
id|KBD_DEFFLAGS
suffix:semicolon
)brace
id|bh_base
(braket
id|KEYBOARD_BH
)braket
dot
id|routine
op_assign
id|kbd_bh
suffix:semicolon
id|request_irq
c_func
(paren
id|KEYBOARD_IRQ
comma
id|keyboard_interrupt
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|KEYBOARD_BH
)paren
suffix:semicolon
r_return
id|kmem_start
suffix:semicolon
)brace
eof
