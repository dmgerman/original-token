multiline_comment|/* cfg.c  -  Configuration file parser */
multiline_comment|/* Copyright 1992-1997 Werner Almesberger. See file COPYING for details. */
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;ctype.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &quot;cfg.h&quot;
DECL|macro|MAX_TOKEN
mdefine_line|#define MAX_TOKEN 200
DECL|macro|MAX_VAR_NAME
mdefine_line|#define MAX_VAR_NAME MAX_TOKEN
DECL|variable|file
r_static
id|FILE
op_star
id|file
suffix:semicolon
DECL|variable|flag_set
r_static
r_char
id|flag_set
suffix:semicolon
DECL|variable|last_token
DECL|variable|last_item
DECL|variable|last_value
r_static
r_char
op_star
id|last_token
op_assign
l_int|NULL
comma
op_star
id|last_item
op_assign
l_int|NULL
comma
op_star
id|last_value
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|line_num
r_static
r_int
id|line_num
suffix:semicolon
DECL|variable|file_name
r_static
r_char
op_star
id|file_name
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|back
r_static
r_int
id|back
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* can go back by one char */
DECL|function|pdie
r_void
id|pdie
c_func
(paren
r_char
op_star
id|msg
)paren
(brace
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
id|perror
c_func
(paren
id|msg
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|die
r_void
id|die
c_func
(paren
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
id|va_list
id|ap
suffix:semicolon
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|fmt
)paren
suffix:semicolon
id|vfprintf
c_func
(paren
id|stderr
comma
id|fmt
comma
id|ap
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|ap
)paren
suffix:semicolon
id|fputc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|stderr
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|pstrdup
r_char
op_star
id|pstrdup
c_func
(paren
r_const
r_char
op_star
id|str
)paren
(brace
r_char
op_star
id|this
suffix:semicolon
r_if
c_cond
(paren
(paren
id|this
op_assign
id|strdup
c_func
(paren
id|str
)paren
)paren
op_eq
l_int|NULL
)paren
id|pdie
c_func
(paren
l_string|&quot;Out of memory&quot;
)paren
suffix:semicolon
r_return
id|this
suffix:semicolon
)brace
DECL|function|cfg_open
r_int
id|cfg_open
c_func
(paren
r_char
op_star
id|name
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|name
comma
l_string|&quot;-&quot;
)paren
)paren
id|file
op_assign
id|stdin
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|file
op_assign
id|fopen
c_func
(paren
id|file_name
op_assign
id|name
comma
l_string|&quot;r&quot;
)paren
)paren
)paren
id|pdie
c_func
(paren
id|name
)paren
suffix:semicolon
id|line_num
op_assign
l_int|1
suffix:semicolon
r_return
id|fileno
c_func
(paren
id|file
)paren
suffix:semicolon
)brace
DECL|function|cfg_error
r_void
id|cfg_error
c_func
(paren
r_char
op_star
id|msg
comma
dot
dot
dot
)paren
(brace
id|va_list
id|ap
suffix:semicolon
id|fflush
c_func
(paren
id|stdout
)paren
suffix:semicolon
id|va_start
c_func
(paren
id|ap
comma
id|msg
)paren
suffix:semicolon
id|vfprintf
c_func
(paren
id|stderr
comma
id|msg
comma
id|ap
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|ap
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|file_name
)paren
id|fputc
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|stderr
)paren
suffix:semicolon
r_else
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot; near line %d in file %s&bslash;n&quot;
comma
id|line_num
comma
id|file_name
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|next_raw
r_static
r_int
id|next_raw
c_func
(paren
r_void
)paren
(brace
r_int
id|ch
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|back
)paren
r_return
id|getc
c_func
(paren
id|file
)paren
suffix:semicolon
id|ch
op_assign
id|back
suffix:semicolon
id|back
op_assign
l_int|0
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
DECL|function|next
r_static
r_int
id|next
c_func
(paren
r_void
)paren
(brace
r_static
r_char
op_star
id|var
suffix:semicolon
r_char
id|buffer
(braket
id|MAX_VAR_NAME
op_plus
l_int|1
)braket
suffix:semicolon
r_int
id|ch
comma
id|braced
suffix:semicolon
r_char
op_star
id|put
suffix:semicolon
r_if
c_cond
(paren
id|back
)paren
(brace
id|ch
op_assign
id|back
suffix:semicolon
id|back
op_assign
l_int|0
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
r_if
c_cond
(paren
id|var
op_logical_and
op_star
id|var
)paren
r_return
op_star
id|var
op_increment
suffix:semicolon
id|ch
op_assign
id|getc
c_func
(paren
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
id|ch
op_assign
id|getc
c_func
(paren
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;$&squot;
)paren
r_return
id|ch
suffix:semicolon
id|ungetc
c_func
(paren
id|ch
comma
id|file
)paren
suffix:semicolon
r_return
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ch
op_ne
l_char|&squot;$&squot;
)paren
r_return
id|ch
suffix:semicolon
id|ch
op_assign
id|getc
c_func
(paren
id|file
)paren
suffix:semicolon
id|braced
op_assign
id|ch
op_eq
l_char|&squot;{&squot;
suffix:semicolon
id|put
op_assign
id|buffer
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|braced
)paren
op_star
id|put
op_increment
op_assign
id|ch
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|ch
op_assign
id|getc
c_func
(paren
id|file
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
id|braced
op_logical_and
id|ch
OL
l_char|&squot; &squot;
)paren
(brace
id|ungetc
c_func
(paren
id|ch
comma
id|file
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|ch
op_eq
id|EOF
)paren
id|cfg_error
c_func
(paren
l_string|&quot;EOF in variable name&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
OL
l_char|&squot; &squot;
)paren
id|cfg_error
c_func
(paren
l_string|&quot;control character in variable name&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|braced
op_logical_and
id|ch
op_eq
l_char|&squot;}&squot;
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|braced
op_logical_and
op_logical_neg
id|isalpha
c_func
(paren
id|ch
)paren
op_logical_and
op_logical_neg
id|isdigit
c_func
(paren
id|ch
)paren
op_logical_and
id|ch
op_ne
l_char|&squot;_&squot;
)paren
(brace
id|ungetc
c_func
(paren
id|ch
comma
id|file
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|put
op_minus
id|buffer
op_eq
id|MAX_VAR_NAME
)paren
id|cfg_error
c_func
(paren
l_string|&quot;variable name too long&quot;
)paren
suffix:semicolon
op_star
id|put
op_increment
op_assign
id|ch
suffix:semicolon
)brace
op_star
id|put
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|var
op_assign
id|getenv
c_func
(paren
id|buffer
)paren
)paren
)paren
id|cfg_error
c_func
(paren
l_string|&quot;unknown variable &bslash;&quot;%s&bslash;&quot;&quot;
comma
id|buffer
)paren
suffix:semicolon
r_return
id|next
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|again
r_static
r_void
id|again
c_func
(paren
r_int
id|ch
)paren
(brace
r_if
c_cond
(paren
id|back
)paren
id|die
c_func
(paren
l_string|&quot;internal error: again invoked twice&quot;
)paren
suffix:semicolon
id|back
op_assign
id|ch
suffix:semicolon
)brace
DECL|function|cfg_get_token
r_static
r_char
op_star
id|cfg_get_token
c_func
(paren
r_void
)paren
(brace
r_char
id|buf
(braket
id|MAX_TOKEN
op_plus
l_int|1
)braket
suffix:semicolon
r_char
op_star
id|here
suffix:semicolon
r_int
id|ch
comma
id|escaped
suffix:semicolon
r_if
c_cond
(paren
id|last_token
)paren
(brace
id|here
op_assign
id|last_token
suffix:semicolon
id|last_token
op_assign
l_int|NULL
suffix:semicolon
r_return
id|here
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|next
c_func
(paren
)paren
)paren
comma
id|ch
op_eq
l_char|&squot; &squot;
op_logical_or
id|ch
op_eq
l_char|&squot;&bslash;t&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;&bslash;n&squot;
)paren
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|line_num
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
id|EOF
)paren
r_return
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_ne
l_char|&squot;#&squot;
)paren
r_break
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|next_raw
c_func
(paren
)paren
)paren
comma
id|ch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
r_if
c_cond
(paren
id|ch
op_eq
id|EOF
)paren
r_return
l_int|NULL
suffix:semicolon
id|line_num
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;=&squot;
)paren
r_return
id|pstrdup
c_func
(paren
l_string|&quot;=&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
id|here
op_assign
id|buf
suffix:semicolon
r_while
c_loop
(paren
id|here
op_minus
id|buf
OL
id|MAX_TOKEN
)paren
(brace
r_if
c_cond
(paren
(paren
id|ch
op_assign
id|next
c_func
(paren
)paren
)paren
op_eq
id|EOF
)paren
id|cfg_error
c_func
(paren
l_string|&quot;EOF in quoted string&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;&quot;&squot;
)paren
(brace
op_star
id|here
op_assign
l_int|0
suffix:semicolon
r_return
id|pstrdup
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
(brace
id|ch
op_assign
id|next
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_ne
l_char|&squot;&quot;&squot;
op_logical_and
id|ch
op_ne
l_char|&squot;&bslash;&bslash;&squot;
op_logical_and
id|ch
op_ne
l_char|&squot;&bslash;n&squot;
)paren
id|cfg_error
c_func
(paren
l_string|&quot;Bad use of &bslash;&bslash; in quoted string&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|next
c_func
(paren
)paren
)paren
comma
id|ch
op_eq
l_char|&squot; &squot;
op_logical_or
id|ch
op_eq
l_char|&squot;&bslash;t&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ch
)paren
r_continue
suffix:semicolon
id|again
c_func
(paren
id|ch
)paren
suffix:semicolon
id|ch
op_assign
l_char|&squot; &squot;
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|cfg_error
c_func
(paren
l_string|&quot;&bslash;&bslash;n and &bslash;&bslash;t are not allowed in quoted strings&quot;
)paren
suffix:semicolon
op_star
id|here
op_increment
op_assign
id|ch
suffix:semicolon
)brace
id|cfg_error
c_func
(paren
l_string|&quot;Quoted string is too long&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* not reached */
)brace
id|here
op_assign
id|buf
suffix:semicolon
id|escaped
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|here
op_minus
id|buf
OL
id|MAX_TOKEN
)paren
(brace
r_if
c_cond
(paren
id|escaped
)paren
(brace
r_if
c_cond
(paren
id|ch
op_eq
id|EOF
)paren
id|cfg_error
c_func
(paren
l_string|&quot;&bslash;&bslash; precedes EOF&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|line_num
op_increment
suffix:semicolon
r_else
op_star
id|here
op_increment
op_assign
id|ch
op_eq
l_char|&squot;&bslash;t&squot;
ques
c_cond
l_char|&squot; &squot;
suffix:colon
id|ch
suffix:semicolon
id|escaped
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot; &squot;
op_logical_or
id|ch
op_eq
l_char|&squot;&bslash;t&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;#&squot;
op_logical_or
id|ch
op_eq
l_char|&squot;=&squot;
op_logical_or
id|ch
op_eq
id|EOF
)paren
(brace
id|again
c_func
(paren
id|ch
)paren
suffix:semicolon
op_star
id|here
op_assign
l_int|0
suffix:semicolon
r_return
id|pstrdup
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|escaped
op_assign
(paren
id|ch
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
)paren
)paren
op_star
id|here
op_increment
op_assign
id|ch
suffix:semicolon
)brace
id|ch
op_assign
id|next
c_func
(paren
)paren
suffix:semicolon
)brace
id|cfg_error
c_func
(paren
l_string|&quot;Token is too long&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* not reached */
)brace
DECL|function|cfg_return_token
r_static
r_void
id|cfg_return_token
c_func
(paren
r_char
op_star
id|token
)paren
(brace
id|last_token
op_assign
id|token
suffix:semicolon
)brace
DECL|function|cfg_next
r_static
r_int
id|cfg_next
c_func
(paren
r_char
op_star
op_star
id|item
comma
r_char
op_star
op_star
id|value
)paren
(brace
r_char
op_star
id|this
suffix:semicolon
r_if
c_cond
(paren
id|last_item
)paren
(brace
op_star
id|item
op_assign
id|last_item
suffix:semicolon
op_star
id|value
op_assign
id|last_value
suffix:semicolon
id|last_item
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
op_star
id|value
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|item
op_assign
id|cfg_get_token
c_func
(paren
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
op_star
id|item
comma
l_string|&quot;=&quot;
)paren
)paren
id|cfg_error
c_func
(paren
l_string|&quot;Syntax error&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|this
op_assign
id|cfg_get_token
c_func
(paren
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|this
comma
l_string|&quot;=&quot;
)paren
)paren
(brace
id|cfg_return_token
c_func
(paren
id|this
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|value
op_assign
id|cfg_get_token
c_func
(paren
)paren
)paren
)paren
id|cfg_error
c_func
(paren
l_string|&quot;Value expected at EOF&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
op_star
id|value
comma
l_string|&quot;=&quot;
)paren
)paren
id|cfg_error
c_func
(paren
l_string|&quot;Syntax error after %s&quot;
comma
op_star
id|item
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|cfg_return
r_static
r_void
id|cfg_return
c_func
(paren
r_char
op_star
id|item
comma
r_char
op_star
id|value
)paren
(brace
id|last_item
op_assign
id|item
suffix:semicolon
id|last_value
op_assign
id|value
suffix:semicolon
)brace
DECL|function|cfg_init
r_void
id|cfg_init
c_func
(paren
id|CONFIG
op_star
id|table
)paren
(brace
r_while
c_loop
(paren
id|table-&gt;type
op_ne
id|cft_end
)paren
(brace
r_switch
c_cond
(paren
id|table-&gt;type
)paren
(brace
r_case
id|cft_strg
suffix:colon
r_if
c_cond
(paren
id|table-&gt;data
)paren
id|free
c_func
(paren
id|table-&gt;data
)paren
suffix:semicolon
r_case
id|cft_flag
suffix:colon
id|table-&gt;data
op_assign
l_int|NULL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|cft_link
suffix:colon
id|table
op_assign
(paren
(paren
id|CONFIG
op_star
)paren
id|table-&gt;action
)paren
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|die
c_func
(paren
l_string|&quot;Unknown syntax code %d&quot;
comma
id|table-&gt;type
)paren
suffix:semicolon
)brace
id|table
op_increment
suffix:semicolon
)brace
)brace
DECL|function|cfg_do_set
r_static
r_int
id|cfg_do_set
c_func
(paren
id|CONFIG
op_star
id|table
comma
r_char
op_star
id|item
comma
r_char
op_star
id|value
comma
r_int
id|copy
comma
r_void
op_star
id|context
)paren
(brace
id|CONFIG
op_star
id|walk
suffix:semicolon
r_for
c_loop
(paren
id|walk
op_assign
id|table
suffix:semicolon
id|walk-&gt;type
op_ne
id|cft_end
suffix:semicolon
id|walk
op_increment
)paren
(brace
r_if
c_cond
(paren
id|walk-&gt;name
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|walk-&gt;name
comma
id|item
)paren
)paren
(brace
r_if
c_cond
(paren
id|value
op_logical_and
id|walk-&gt;type
op_ne
id|cft_strg
)paren
id|cfg_error
c_func
(paren
l_string|&quot;&squot;%s&squot; doesn&squot;t have a value&quot;
comma
id|walk-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|value
op_logical_and
id|walk-&gt;type
op_eq
id|cft_strg
)paren
id|cfg_error
c_func
(paren
l_string|&quot;Value expected for &squot;%s&squot;&quot;
comma
id|walk-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|walk-&gt;data
)paren
(brace
r_if
c_cond
(paren
id|walk-&gt;context
op_eq
id|context
)paren
id|cfg_error
c_func
(paren
l_string|&quot;Duplicate entry &squot;%s&squot;&quot;
comma
id|walk-&gt;name
)paren
suffix:semicolon
r_else
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Ignoring entry &squot;%s&squot;&bslash;n&quot;
comma
id|walk-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|copy
)paren
id|free
c_func
(paren
id|value
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|walk-&gt;type
op_eq
id|cft_flag
)paren
id|walk-&gt;data
op_assign
op_amp
id|flag_set
suffix:semicolon
r_else
r_if
c_cond
(paren
id|walk-&gt;type
op_eq
id|cft_strg
)paren
(brace
r_if
c_cond
(paren
id|copy
)paren
id|walk-&gt;data
op_assign
id|pstrdup
c_func
(paren
id|value
)paren
suffix:semicolon
r_else
id|walk-&gt;data
op_assign
id|value
suffix:semicolon
)brace
id|walk-&gt;context
op_assign
id|context
suffix:semicolon
r_if
c_cond
(paren
id|walk-&gt;action
)paren
(paren
(paren
r_void
(paren
op_star
)paren
(paren
r_void
)paren
)paren
id|walk-&gt;action
)paren
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|walk-&gt;type
op_eq
id|cft_link
)paren
id|walk
op_assign
(paren
(paren
id|CONFIG
op_star
)paren
id|walk-&gt;action
)paren
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|walk-&gt;type
op_ne
id|cft_end
)paren
r_return
l_int|1
suffix:semicolon
id|cfg_return
c_func
(paren
id|item
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cfg_set
r_void
id|cfg_set
c_func
(paren
id|CONFIG
op_star
id|table
comma
r_char
op_star
id|item
comma
r_char
op_star
id|value
comma
r_void
op_star
id|context
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cfg_do_set
c_func
(paren
id|table
comma
id|item
comma
id|value
comma
l_int|1
comma
id|context
)paren
)paren
id|cfg_error
c_func
(paren
l_string|&quot;cfg_set: Can&squot;t set %s&quot;
comma
id|item
)paren
suffix:semicolon
)brace
DECL|function|cfg_unset
r_void
id|cfg_unset
c_func
(paren
id|CONFIG
op_star
id|table
comma
r_char
op_star
id|item
)paren
(brace
id|CONFIG
op_star
id|walk
suffix:semicolon
r_for
c_loop
(paren
id|walk
op_assign
id|table
suffix:semicolon
id|walk-&gt;type
op_ne
id|cft_end
suffix:semicolon
id|walk
op_increment
)paren
r_if
c_cond
(paren
id|walk-&gt;name
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|walk-&gt;name
comma
id|item
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|walk-&gt;data
)paren
id|die
c_func
(paren
l_string|&quot;internal error (cfg_unset %s, unset)&quot;
comma
id|item
)paren
suffix:semicolon
r_if
c_cond
(paren
id|walk-&gt;type
op_eq
id|cft_strg
)paren
id|free
c_func
(paren
id|walk-&gt;data
)paren
suffix:semicolon
id|walk-&gt;data
op_assign
l_int|NULL
suffix:semicolon
r_return
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;internal error (cfg_unset %s, unknown&quot;
comma
id|item
)paren
suffix:semicolon
)brace
DECL|function|cfg_parse
r_int
id|cfg_parse
c_func
(paren
id|CONFIG
op_star
id|table
)paren
(brace
r_char
op_star
id|item
comma
op_star
id|value
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cfg_next
c_func
(paren
op_amp
id|item
comma
op_amp
id|value
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cfg_do_set
c_func
(paren
id|table
comma
id|item
comma
id|value
comma
l_int|0
comma
id|table
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|free
c_func
(paren
id|item
)paren
suffix:semicolon
)brace
)brace
DECL|function|cfg_get_flag
r_int
id|cfg_get_flag
c_func
(paren
id|CONFIG
op_star
id|table
comma
r_char
op_star
id|item
)paren
(brace
id|CONFIG
op_star
id|walk
suffix:semicolon
r_for
c_loop
(paren
id|walk
op_assign
id|table
suffix:semicolon
id|walk-&gt;type
op_ne
id|cft_end
suffix:semicolon
id|walk
op_increment
)paren
(brace
r_if
c_cond
(paren
id|walk-&gt;name
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|walk-&gt;name
comma
id|item
)paren
)paren
(brace
r_if
c_cond
(paren
id|walk-&gt;type
op_ne
id|cft_flag
)paren
id|die
c_func
(paren
l_string|&quot;cfg_get_flag: operating on non-flag %s&quot;
comma
id|item
)paren
suffix:semicolon
r_return
op_logical_neg
op_logical_neg
id|walk-&gt;data
suffix:semicolon
)brace
r_if
c_cond
(paren
id|walk-&gt;type
op_eq
id|cft_link
)paren
id|walk
op_assign
(paren
(paren
id|CONFIG
op_star
)paren
id|walk-&gt;action
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;cfg_get_flag: unknown item %s&quot;
comma
id|item
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* not reached */
)brace
DECL|function|cfg_get_strg
r_char
op_star
id|cfg_get_strg
c_func
(paren
id|CONFIG
op_star
id|table
comma
r_char
op_star
id|item
)paren
(brace
id|CONFIG
op_star
id|walk
suffix:semicolon
r_for
c_loop
(paren
id|walk
op_assign
id|table
suffix:semicolon
id|walk-&gt;type
op_ne
id|cft_end
suffix:semicolon
id|walk
op_increment
)paren
(brace
r_if
c_cond
(paren
id|walk-&gt;name
op_logical_and
op_logical_neg
id|strcasecmp
c_func
(paren
id|walk-&gt;name
comma
id|item
)paren
)paren
(brace
r_if
c_cond
(paren
id|walk-&gt;type
op_ne
id|cft_strg
)paren
id|die
c_func
(paren
l_string|&quot;cfg_get_strg: operating on non-string %s&quot;
comma
id|item
)paren
suffix:semicolon
r_return
id|walk-&gt;data
suffix:semicolon
)brace
r_if
c_cond
(paren
id|walk-&gt;type
op_eq
id|cft_link
)paren
id|walk
op_assign
(paren
(paren
id|CONFIG
op_star
)paren
id|walk-&gt;action
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;cfg_get_strg: unknown item %s&quot;
comma
id|item
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* not reached */
)brace
eof
