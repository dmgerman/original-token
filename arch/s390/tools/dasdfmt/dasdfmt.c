multiline_comment|/*&n; *&n; * dasdfmt.c&n; *&n; *  S390 version&n; *    Copyright (C) 1999,2000 IBM Corporation&n; *    Author(s): Utz Bacher, &lt;utz.bacher@de.ibm.com&gt;&n; *&n; *  Device-in-use-checks by Fritz Elfert, &lt;felfert@to.com&gt;&n; *&n; * Still to do:&n; *   detect non-switch parameters (&quot;dasdfmt -n 170 XY&quot;) and complain about them &n; */
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;sys/stat.h&gt;
macro_line|#include &lt;fcntl.h&gt;
macro_line|#include &lt;sys/ioctl.h&gt;
macro_line|#include &lt;errno.h&gt;
macro_line|#include &lt;getopt.h&gt;
macro_line|#include &lt;limits.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;dirent.h&gt;
macro_line|#include &lt;mntent.h&gt;
macro_line|#include &quot;../../../drivers/s390/block/dasd.h&quot; /* uses DASD_PARTN_BITS */
DECL|macro|__KERNEL__
mdefine_line|#define __KERNEL__ /* we want to use kdev_t and not have to define it */
macro_line|#include &lt;linux/kdev_t.h&gt;
DECL|macro|__KERNEL__
macro_line|#undef __KERNEL__
DECL|macro|EXIT_MISUSE
mdefine_line|#define EXIT_MISUSE 1
DECL|macro|EXIT_BUSY
mdefine_line|#define EXIT_BUSY 2
DECL|macro|TEMPFILENAME
mdefine_line|#define TEMPFILENAME &quot;/tmp/ddfXXXXXX&quot;
DECL|macro|TEMPFILENAMECHARS
mdefine_line|#define TEMPFILENAMECHARS 8  /* 8 characters are fixed in all temp filenames */
DECL|macro|IOCTL_COMMAND
mdefine_line|#define IOCTL_COMMAND &squot;D&squot; &lt;&lt; 8
DECL|macro|SLASHDEV
mdefine_line|#define SLASHDEV &quot;/dev/&quot;
DECL|macro|PROC_DASD_DEVICES
mdefine_line|#define PROC_DASD_DEVICES &quot;/proc/dasd/devices&quot;
DECL|macro|DASD_DRIVER_NAME
mdefine_line|#define DASD_DRIVER_NAME &quot;dasd&quot;
DECL|macro|PROC_LINE_LENGTH
mdefine_line|#define PROC_LINE_LENGTH 80
DECL|macro|ERR_LENGTH
mdefine_line|#define ERR_LENGTH 80
DECL|macro|MAX_FILELEN
mdefine_line|#define MAX_FILELEN NAME_MAX+PATH_MAX
DECL|macro|GIVEN_DEVNO
mdefine_line|#define GIVEN_DEVNO 1
DECL|macro|GIVEN_MAJOR
mdefine_line|#define GIVEN_MAJOR 2
DECL|macro|GIVEN_MINOR
mdefine_line|#define GIVEN_MINOR 4
DECL|macro|CHECK_START
mdefine_line|#define CHECK_START 1
DECL|macro|CHECK_END
mdefine_line|#define CHECK_END 2
DECL|macro|CHECK_BLKSIZE
mdefine_line|#define CHECK_BLKSIZE 4
DECL|macro|CHECK_ALL
mdefine_line|#define CHECK_ALL ~0
DECL|macro|ERRMSG
mdefine_line|#define ERRMSG(x...) {fflush(stdout);fprintf(stderr,x);}
DECL|macro|ERRMSG_EXIT
mdefine_line|#define ERRMSG_EXIT(ec,x...) {fflush(stdout);fprintf(stderr,x);exit(ec);}
DECL|macro|CHECK_SPEC_MAX_ONCE
mdefine_line|#define CHECK_SPEC_MAX_ONCE(i,str) &bslash;&n;&t;{if (i&gt;1) &bslash;&n;&t;&t;ERRMSG_EXIT(EXIT_MISUSE,&quot;%s: &quot; str &quot; &quot; &bslash;&n;&t;&t;&t;&quot;can only be specified once&bslash;n&quot;,prog_name);}
DECL|macro|PARSE_PARAM_INTO
mdefine_line|#define PARSE_PARAM_INTO(x,param,base,str) &bslash;&n;&t;{x=(int)strtol(param,&amp;endptr,base); &bslash;&n;&t;if (*endptr) &bslash;&n;&t;&t;ERRMSG_EXIT(EXIT_MISUSE,&quot;%s: &quot; str &quot; &quot; &bslash;&n;&t;&t;&t;&quot;is in invalid format&bslash;n&quot;,prog_name);}
r_typedef
r_struct
(brace
DECL|member|start_unit
r_int
id|start_unit
suffix:semicolon
DECL|member|stop_unit
r_int
id|stop_unit
suffix:semicolon
DECL|member|blksize
r_int
id|blksize
suffix:semicolon
DECL|typedef|format_data_t
)brace
id|format_data_t
suffix:semicolon
DECL|variable|prog_name
r_char
id|prog_name
(braket
)braket
op_assign
l_string|&quot;dasd_format&quot;
suffix:semicolon
DECL|variable|tempfilename
r_char
id|tempfilename
(braket
)braket
op_assign
id|TEMPFILENAME
suffix:semicolon
r_void
DECL|function|exit_usage
id|exit_usage
c_func
(paren
r_int
id|exitcode
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Usage: %s [-htvyV] [-b blocksize] &lt;range&gt; &lt;diskspec&gt;&bslash;n&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;       where &lt;range&gt; is either&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;           -s start_track -e end_track&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;       or&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;           -r start_track-end_track&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;       and &lt;diskspec&gt; is either&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;           -f /dev/dasdX&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;       or&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;           -n &lt;s390-devnr&gt;&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
id|exitcode
)paren
suffix:semicolon
)brace
r_void
DECL|function|get_xno_from_xno
id|get_xno_from_xno
c_func
(paren
r_int
op_star
id|devno
comma
id|kdev_t
op_star
id|major_no
comma
id|kdev_t
op_star
id|minor_no
comma
r_int
id|mode
)paren
(brace
id|FILE
op_star
id|file
suffix:semicolon
r_int
id|d
comma
id|rc
suffix:semicolon
id|kdev_t
id|mi
comma
id|ma
suffix:semicolon
r_int
id|mi_i
comma
id|ma_i
suffix:semicolon
multiline_comment|/* for scanf :-( */
r_char
id|line
(braket
id|PROC_LINE_LENGTH
)braket
suffix:semicolon
id|file
op_assign
id|fopen
c_func
(paren
id|PROC_DASD_DEVICES
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file
op_eq
l_int|NULL
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: failed to open &quot;
"&bslash;"
id|PROC_DASD_DEVICES
l_string|&quot;: %s (do you have the /proc &quot;
"&bslash;"
l_string|&quot;filesystem enabled?)&bslash;n&quot;
comma
id|prog_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|file
)paren
suffix:semicolon
multiline_comment|/* omit first line */
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|file
)paren
op_ne
l_int|NULL
)paren
(brace
id|rc
op_assign
id|sscanf
c_func
(paren
id|line
comma
l_string|&quot;%X%d%d&quot;
comma
op_amp
id|d
comma
op_amp
id|ma_i
comma
op_amp
id|mi_i
)paren
suffix:semicolon
id|ma
op_assign
id|ma_i
suffix:semicolon
id|mi
op_assign
id|mi_i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_eq
l_int|3
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|d
op_ne
op_star
id|devno
)paren
op_logical_and
(paren
id|mode
op_amp
id|GIVEN_DEVNO
)paren
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|ma
op_ne
op_star
id|major_no
)paren
op_logical_and
(paren
id|mode
op_amp
id|GIVEN_MAJOR
)paren
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|mi
op_ne
op_star
id|minor_no
)paren
op_logical_and
(paren
id|mode
op_amp
id|GIVEN_MINOR
)paren
)paren
)paren
(brace
op_star
id|devno
op_assign
id|d
suffix:semicolon
op_star
id|major_no
op_assign
id|ma
suffix:semicolon
op_star
id|minor_no
op_assign
id|mi
suffix:semicolon
multiline_comment|/* yes, this is a quick exit, but the easiest way */
id|fclose
c_func
(paren
id|file
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|fclose
c_func
(paren
id|file
)paren
suffix:semicolon
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: failed to find device in the /proc &quot;
"&bslash;"
l_string|&quot;filesystem (are you sure to have the right param line?)&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
)brace
r_char
op_star
DECL|function|get_devname_from_devno
id|get_devname_from_devno
c_func
(paren
r_int
id|devno
comma
r_int
id|verbosity
)paren
(brace
id|kdev_t
id|major_no
comma
id|minor_no
suffix:semicolon
id|kdev_t
id|file_major
comma
id|file_minor
suffix:semicolon
r_struct
id|stat
id|stat_buf
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
id|found
suffix:semicolon
r_char
op_star
id|devname
suffix:semicolon
r_char
id|tmpname
(braket
id|MAX_FILELEN
)braket
suffix:semicolon
id|DIR
op_star
id|dp
suffix:semicolon
r_struct
id|dirent
op_star
id|direntp
suffix:semicolon
multiline_comment|/**** get minor number ****/
id|get_xno_from_xno
c_func
(paren
op_amp
id|devno
comma
op_amp
id|major_no
comma
op_amp
id|minor_no
comma
id|GIVEN_DEVNO
)paren
suffix:semicolon
multiline_comment|/**** get device file ****/
r_if
c_cond
(paren
(paren
id|dp
op_assign
id|opendir
c_func
(paren
id|SLASHDEV
)paren
)paren
op_eq
l_int|NULL
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: unable to read &quot;
id|SLASHDEV
"&bslash;"
l_string|&quot;&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
id|found
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|direntp
op_assign
id|readdir
c_func
(paren
id|dp
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|strcpy
c_func
(paren
id|tmpname
comma
id|SLASHDEV
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|tmpname
comma
id|direntp-&gt;d_name
)paren
suffix:semicolon
id|rc
op_assign
id|stat
c_func
(paren
id|tmpname
comma
op_amp
id|stat_buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
id|file_major
op_assign
id|MAJOR
c_func
(paren
id|stat_buf.st_rdev
)paren
suffix:semicolon
id|file_minor
op_assign
id|MINOR
c_func
(paren
id|stat_buf.st_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|file_major
op_eq
id|major_no
)paren
op_logical_and
(paren
id|file_minor
op_eq
id|minor_no
)paren
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
id|devname
op_assign
id|malloc
c_func
(paren
id|strlen
c_func
(paren
id|direntp-&gt;d_name
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|devname
comma
id|tmpname
)paren
suffix:semicolon
)brace
id|rc
op_assign
id|closedir
c_func
(paren
id|dp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
id|ERRMSG
c_func
(paren
l_string|&quot;%s: unable to close directory &quot;
id|SLASHDEV
"&bslash;"
l_string|&quot;; continuing&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|found
)paren
r_return
id|devname
suffix:semicolon
r_if
c_cond
(paren
id|verbosity
op_ge
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;I didn&squot;t find device node in &quot;
id|SLASHDEV
"&bslash;"
l_string|&quot;; trying to create a temporary node&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/**** get temp file and create device node *****/
id|rc
op_assign
id|mkstemp
c_func
(paren
id|tempfilename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: failed to get temporary &quot;
"&bslash;"
l_string|&quot;filename: %s&bslash;n&quot;
comma
id|prog_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|close
c_func
(paren
id|rc
)paren
suffix:semicolon
id|rc
op_assign
id|unlink
c_func
(paren
id|tempfilename
)paren
suffix:semicolon
id|rc
op_assign
id|mknod
c_func
(paren
id|tempfilename
comma
id|S_IFBLK
op_or
l_int|0600
comma
id|MKDEV
c_func
(paren
id|major_no
comma
id|minor_no
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: failed to create temporary &quot;
"&bslash;"
l_string|&quot;device node %s: %s&bslash;n&quot;
comma
id|prog_name
comma
id|tempfilename
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_return
id|tempfilename
suffix:semicolon
)brace
r_char
op_star
DECL|function|check_param
id|check_param
c_func
(paren
r_int
id|mode
comma
id|format_data_t
id|data
)paren
(brace
r_char
op_star
id|s
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
(paren
id|s
op_assign
id|malloc
c_func
(paren
id|ERR_LENGTH
)paren
)paren
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: not enough memory.&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode
op_amp
id|CHECK_START
)paren
op_logical_and
(paren
id|data.start_unit
OL
l_int|0
)paren
)paren
(brace
id|strcpy
c_func
(paren
id|s
comma
l_string|&quot;start track must be greater than zero&quot;
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mode
op_amp
id|CHECK_END
)paren
op_logical_and
(paren
id|data.stop_unit
OL
op_minus
l_int|1
)paren
)paren
(brace
id|strcpy
c_func
(paren
id|s
comma
l_string|&quot;end track must be -1 or greater than zero&quot;
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mode
op_amp
id|CHECK_END
)paren
op_logical_and
(paren
id|data.start_unit
OG
id|data.stop_unit
)paren
op_logical_and
(paren
id|data.stop_unit
op_ne
op_minus
l_int|1
)paren
)paren
(brace
id|strcpy
c_func
(paren
id|s
comma
l_string|&quot;end track must be higher than start track&quot;
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|mode
op_amp
id|CHECK_BLKSIZE
)paren
op_logical_and
(paren
id|data.blksize
OL
l_int|1
)paren
)paren
(brace
id|strcpy
c_func
(paren
id|s
comma
l_string|&quot;blocksize must be a positive integer&quot;
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode
op_amp
id|CHECK_BLKSIZE
)paren
r_while
c_loop
(paren
id|data.blksize
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|data.blksize
op_mod
l_int|2
)paren
op_logical_and
(paren
id|data.blksize
op_ne
l_int|1
)paren
)paren
(brace
id|strcpy
c_func
(paren
id|s
comma
l_string|&quot;blocksize must be a power of 2&quot;
)paren
suffix:semicolon
r_goto
m_exit
suffix:semicolon
)brace
id|data.blksize
op_div_assign
l_int|2
suffix:semicolon
)brace
id|free
c_func
(paren
id|s
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
m_exit
suffix:colon
r_return
id|s
suffix:semicolon
)brace
DECL|macro|ASK_PRINTOUT
mdefine_line|#define ASK_PRINTOUT printf(&quot;Please enter %s&quot;,output)
DECL|macro|ASK_GETBUFFER
mdefine_line|#define ASK_GETBUFFER fgets(buffer,sizeof(buffer),stdin)
DECL|macro|ASK_SCANFORNUMBER
mdefine_line|#define ASK_SCANFORNUMBER(var) rc=sscanf(buffer,&quot;%d%c&quot;,&amp;var,&amp;c)
DECL|macro|ASK_COMPLAIN_FORMAT
mdefine_line|#define ASK_COMPLAIN_FORMAT if ((rc==2)&amp;&amp;(c==&squot;&bslash;n&squot;)) rc=1; &bslash;&n;&t;if (rc==-1) rc=1; /* this happens, if enter is pressed */ &bslash;&n;&t;if (rc!=1) printf(&quot; -- wrong input, try again.&bslash;n&quot;)
DECL|macro|ASK_CHECK_PARAM
mdefine_line|#define ASK_CHECK_PARAM(mode) str=check_param(mode,params); &bslash;&n;&t;&t;if (str!=NULL) { printf(&quot; -- %s&bslash;n&quot;,str); rc=0; free(str); }
id|format_data_t
DECL|function|ask_user_for_data
id|ask_user_for_data
c_func
(paren
id|format_data_t
id|params
)paren
(brace
r_char
id|buffer
(braket
l_int|20
)braket
suffix:semicolon
multiline_comment|/* should be enough for inputing track numbers */
r_char
id|c
suffix:semicolon
r_int
id|i
comma
id|rc
suffix:semicolon
r_char
op_star
id|str
suffix:semicolon
r_char
id|output
(braket
l_int|60
)braket
comma
id|o2
(braket
l_int|12
)braket
suffix:semicolon
id|i
op_assign
id|params.start_unit
suffix:semicolon
r_do
(brace
id|params.start_unit
op_assign
id|i
suffix:semicolon
id|sprintf
c_func
(paren
id|output
comma
l_string|&quot;the start track of the range to format &quot;
"&bslash;"
l_string|&quot;[%d]: &quot;
comma
id|i
)paren
suffix:semicolon
id|ASK_PRINTOUT
suffix:semicolon
id|ASK_GETBUFFER
suffix:semicolon
id|ASK_SCANFORNUMBER
c_func
(paren
id|params.start_unit
)paren
suffix:semicolon
id|ASK_COMPLAIN_FORMAT
suffix:semicolon
id|ASK_CHECK_PARAM
c_func
(paren
id|CHECK_START
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|rc
op_ne
l_int|1
)paren
suffix:semicolon
id|i
op_assign
id|params.stop_unit
suffix:semicolon
r_do
(brace
id|params.stop_unit
op_assign
id|i
suffix:semicolon
id|sprintf
c_func
(paren
id|output
comma
l_string|&quot;the end track of the range to format [&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
op_minus
l_int|1
)paren
id|sprintf
c_func
(paren
id|o2
comma
l_string|&quot;END]: &quot;
)paren
suffix:semicolon
r_else
id|sprintf
c_func
(paren
id|o2
comma
l_string|&quot;%d]: &quot;
comma
id|i
)paren
suffix:semicolon
id|strcat
c_func
(paren
id|output
comma
id|o2
)paren
suffix:semicolon
id|ASK_PRINTOUT
suffix:semicolon
id|ASK_GETBUFFER
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|buffer
comma
l_string|&quot;end&quot;
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|buffer
comma
l_string|&quot;end&bslash;n&quot;
)paren
)paren
)paren
(brace
id|rc
op_assign
l_int|1
suffix:semicolon
id|params.stop_unit
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|ASK_SCANFORNUMBER
c_func
(paren
id|params.stop_unit
)paren
suffix:semicolon
id|ASK_COMPLAIN_FORMAT
suffix:semicolon
id|ASK_CHECK_PARAM
c_func
(paren
id|CHECK_END
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|rc
op_ne
l_int|1
)paren
suffix:semicolon
id|i
op_assign
id|params.blksize
suffix:semicolon
r_do
(brace
id|params.blksize
op_assign
id|i
suffix:semicolon
id|sprintf
c_func
(paren
id|output
comma
l_string|&quot;the blocksize of the formatting [%d]: &quot;
comma
id|i
)paren
suffix:semicolon
id|ASK_PRINTOUT
suffix:semicolon
id|ASK_GETBUFFER
suffix:semicolon
id|ASK_SCANFORNUMBER
c_func
(paren
id|params.blksize
)paren
suffix:semicolon
id|ASK_COMPLAIN_FORMAT
suffix:semicolon
id|ASK_CHECK_PARAM
c_func
(paren
id|CHECK_BLKSIZE
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|rc
op_ne
l_int|1
)paren
suffix:semicolon
r_return
id|params
suffix:semicolon
)brace
multiline_comment|/* Check if the device we are going to format is mounted.&n; * If true, complain and exit.&n; */
r_void
DECL|function|check_mounted
id|check_mounted
c_func
(paren
r_int
id|major
comma
r_int
id|minor
)paren
(brace
id|FILE
op_star
id|f
suffix:semicolon
r_int
id|ishift
op_assign
l_int|0
suffix:semicolon
r_struct
id|mntent
op_star
id|ment
suffix:semicolon
r_struct
id|stat
id|stbuf
suffix:semicolon
r_char
id|line
(braket
l_int|128
)braket
suffix:semicolon
multiline_comment|/* If whole disk to be formatted ... */
r_if
c_cond
(paren
(paren
id|minor
op_mod
(paren
l_int|1U
op_lshift
id|DASD_PARTN_BITS
)paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* ... ignore partition-selector */
id|minor
op_rshift_assign
id|DASD_PARTN_BITS
suffix:semicolon
id|ishift
op_assign
id|DASD_PARTN_BITS
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * first, check filesystems&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|f
op_assign
id|fopen
c_func
(paren
id|_PATH_MOUNTED
comma
l_string|&quot;r&quot;
)paren
)paren
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|_PATH_MOUNTED
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ment
op_assign
id|getmntent
c_func
(paren
id|f
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
c_func
(paren
id|ment-&gt;mnt_fsname
comma
op_amp
id|stbuf
)paren
op_eq
l_int|0
)paren
r_if
c_cond
(paren
(paren
id|major
op_eq
id|MAJOR
c_func
(paren
id|stbuf.st_rdev
)paren
)paren
op_logical_and
(paren
id|minor
op_eq
(paren
id|MINOR
c_func
(paren
id|stbuf.st_rdev
)paren
op_rshift
id|ishift
)paren
)paren
)paren
(brace
id|ERRMSG
c_func
(paren
l_string|&quot;%s: device is mounted on %s!!&bslash;n&quot;
comma
id|prog_name
comma
id|ment-&gt;mnt_dir
)paren
suffix:semicolon
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_BUSY
comma
l_string|&quot;If you really want to &quot;
l_string|&quot;format it, please unmount it.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|fclose
c_func
(paren
id|f
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * second, check active swap spaces&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|f
op_assign
id|fopen
c_func
(paren
l_string|&quot;/proc/swaps&quot;
comma
l_string|&quot;r&quot;
)paren
)paren
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;/proc/swaps: %s&quot;
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * skip header line&n;&t; */
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|f
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|line
comma
r_sizeof
(paren
id|line
)paren
comma
id|f
)paren
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|line
suffix:semicolon
op_star
id|p
op_logical_and
(paren
op_logical_neg
id|isspace
c_func
(paren
op_star
id|p
)paren
)paren
suffix:semicolon
id|p
op_increment
)paren
suffix:semicolon
op_star
id|p
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|stat
c_func
(paren
id|line
comma
op_amp
id|stbuf
)paren
op_eq
l_int|0
)paren
r_if
c_cond
(paren
(paren
id|major
op_eq
id|MAJOR
c_func
(paren
id|stbuf.st_rdev
)paren
)paren
op_logical_and
(paren
id|minor
op_eq
(paren
id|MINOR
c_func
(paren
id|stbuf.st_rdev
)paren
op_rshift
id|ishift
)paren
)paren
)paren
(brace
id|ERRMSG
c_func
(paren
l_string|&quot;%s: the device is in use for &quot;
l_string|&quot;swapping!!&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_BUSY
comma
l_string|&quot;If you really want to &quot;
l_string|&quot;format it, please use swapoff %s.&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
)brace
)brace
id|fclose
c_func
(paren
id|f
)paren
suffix:semicolon
)brace
r_void
DECL|function|do_format_dasd
id|do_format_dasd
c_func
(paren
r_char
op_star
id|dev_name
comma
id|format_data_t
id|format_params
comma
r_int
id|testmode
comma
r_int
id|verbosity
comma
r_int
id|withoutprompt
)paren
(brace
r_int
id|fd
comma
id|rc
suffix:semicolon
r_struct
id|stat
id|stat_buf
suffix:semicolon
id|kdev_t
id|minor_no
comma
id|major_no
suffix:semicolon
r_int
id|devno
suffix:semicolon
r_char
id|inp_buffer
(braket
l_int|5
)braket
suffix:semicolon
multiline_comment|/* to contain yes */
id|fd
op_assign
id|open
c_func
(paren
id|dev_name
comma
id|O_RDWR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
op_eq
op_minus
l_int|1
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: error opening device %s: &quot;
"&bslash;"
l_string|&quot;%s&bslash;n&quot;
comma
id|prog_name
comma
id|dev_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|verbosity
op_ge
l_int|1
)paren
(brace
)brace
id|rc
op_assign
id|stat
c_func
(paren
id|dev_name
comma
op_amp
id|stat_buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: error occured during stat: &quot;
"&bslash;"
l_string|&quot;%s&bslash;n&quot;
comma
id|prog_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|S_ISBLK
c_func
(paren
id|stat_buf.st_mode
)paren
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: file is not a &quot;
"&bslash;"
l_string|&quot;blockdevice.&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
id|major_no
op_assign
id|MAJOR
c_func
(paren
id|stat_buf.st_rdev
)paren
suffix:semicolon
id|minor_no
op_assign
id|MINOR
c_func
(paren
id|stat_buf.st_rdev
)paren
suffix:semicolon
)brace
id|check_mounted
c_func
(paren
id|major_no
comma
id|minor_no
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|withoutprompt
)paren
op_logical_and
(paren
id|verbosity
op_ge
l_int|1
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|withoutprompt
)paren
)paren
(brace
id|get_xno_from_xno
c_func
(paren
op_amp
id|devno
comma
op_amp
id|major_no
comma
op_amp
id|minor_no
comma
id|GIVEN_MAJOR
op_or
id|GIVEN_MINOR
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;nI am going to format the device %s in the &quot;
"&bslash;"
l_string|&quot;following way:&bslash;n&quot;
comma
id|dev_name
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;   Device number of device : 0x%x&bslash;n&quot;
comma
id|devno
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;   Major number of device  : %u&bslash;n&quot;
comma
id|major_no
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;   Minor number of device  : %u&bslash;n&quot;
comma
id|minor_no
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;   Start track             : %d&bslash;n&quot;
"&bslash;"
comma
id|format_params.start_unit
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;   End track               : &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|format_params.stop_unit
op_eq
op_minus
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;last track of disk&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;%d&bslash;n&quot;
comma
id|format_params.stop_unit
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;   Blocksize               : %d&bslash;n&quot;
"&bslash;"
comma
id|format_params.blksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|testmode
)paren
id|printf
c_func
(paren
l_string|&quot;Test mode active, omitting ioctl.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|testmode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|withoutprompt
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n---&gt;&gt; ATTENTION! &lt;&lt;---&bslash;n&quot;
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;All data in the specified range of that &quot;
"&bslash;"
l_string|&quot;device will be lost.&bslash;nType yes to continue&quot;
"&bslash;"
l_string|&quot;, no will leave the disk untouched: &quot;
)paren
suffix:semicolon
id|fgets
c_func
(paren
id|inp_buffer
comma
r_sizeof
(paren
id|inp_buffer
)paren
comma
id|stdin
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strcasecmp
c_func
(paren
id|inp_buffer
comma
l_string|&quot;yes&quot;
)paren
op_logical_and
id|strcasecmp
c_func
(paren
id|inp_buffer
comma
l_string|&quot;yes&bslash;n&quot;
)paren
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;Omitting ioctl call (disk will &quot;
"&bslash;"
l_string|&quot;NOT be formatted).&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|withoutprompt
)paren
op_logical_and
(paren
id|verbosity
OL
l_int|1
)paren
)paren
)paren
id|printf
c_func
(paren
l_string|&quot;Formatting the device. This may take a &quot;
"&bslash;"
l_string|&quot;while (get yourself a coffee).&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|ioctl
c_func
(paren
id|fd
comma
id|IOCTL_COMMAND
comma
id|format_params
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_FAILURE
comma
l_string|&quot;%s: the dasd driver &quot;
"&bslash;"
l_string|&quot;returned with the following error &quot;
"&bslash;"
l_string|&quot;message:&bslash;n%s&bslash;n&quot;
comma
id|prog_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;Finished formatting the device.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|rc
op_assign
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
id|ERRMSG
c_func
(paren
l_string|&quot;%s: error during close: &quot;
"&bslash;"
l_string|&quot;%s; continuing.&bslash;n&quot;
comma
id|prog_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
id|argv
(braket
)braket
)paren
(brace
r_int
id|verbosity
suffix:semicolon
r_int
id|testmode
suffix:semicolon
r_int
id|withoutprompt
suffix:semicolon
r_char
op_star
id|dev_name
suffix:semicolon
r_int
id|devno
suffix:semicolon
r_char
op_star
id|dev_filename
comma
op_star
id|devno_param_str
comma
op_star
id|range_param_str
suffix:semicolon
r_char
op_star
id|start_param_str
comma
op_star
id|end_param_str
comma
op_star
id|blksize_param_str
suffix:semicolon
id|format_data_t
id|format_params
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_int
id|oc
suffix:semicolon
r_char
op_star
id|endptr
suffix:semicolon
r_char
id|c1
comma
id|c2
comma
id|cbuffer
(braket
l_int|6
)braket
suffix:semicolon
multiline_comment|/* should be able to contain -end plus 1 char */
r_int
id|i1
comma
id|i2
suffix:semicolon
r_char
op_star
id|str
suffix:semicolon
r_int
id|start_specified
comma
id|end_specified
comma
id|blksize_specified
suffix:semicolon
r_int
id|devfile_specified
comma
id|devno_specified
comma
id|range_specified
suffix:semicolon
multiline_comment|/******************* initialization ********************/
id|endptr
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* set default values */
id|format_params.start_unit
op_assign
l_int|0
suffix:semicolon
id|format_params.stop_unit
op_assign
op_minus
l_int|1
suffix:semicolon
id|format_params.blksize
op_assign
l_int|4096
suffix:semicolon
id|testmode
op_assign
l_int|0
suffix:semicolon
id|verbosity
op_assign
l_int|0
suffix:semicolon
id|withoutprompt
op_assign
l_int|0
suffix:semicolon
id|start_specified
op_assign
id|end_specified
op_assign
id|blksize_specified
op_assign
l_int|0
suffix:semicolon
id|devfile_specified
op_assign
id|devno_specified
op_assign
id|range_specified
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*************** parse parameters **********************/
multiline_comment|/* avoid error message generated by getopt */
id|opterr
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|oc
op_assign
id|getopt
c_func
(paren
id|argc
comma
id|argv
comma
l_string|&quot;r:s:e:b:n:f:hty?vV&quot;
)paren
)paren
op_ne
id|EOF
)paren
(brace
r_switch
c_cond
(paren
id|oc
)paren
(brace
r_case
l_char|&squot;y&squot;
suffix:colon
id|withoutprompt
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;t&squot;
suffix:colon
id|testmode
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;v&squot;
suffix:colon
id|verbosity
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;?&squot;
suffix:colon
multiline_comment|/* fall-through */
r_case
l_char|&squot;:&squot;
suffix:colon
id|exit_usage
c_func
(paren
id|EXIT_MISUSE
)paren
suffix:semicolon
r_case
l_char|&squot;h&squot;
suffix:colon
id|exit_usage
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_case
l_char|&squot;V&squot;
suffix:colon
id|printf
c_func
(paren
l_string|&quot;%s version 0.99&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
m_exit
(paren
l_int|0
)paren
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
id|start_param_str
op_assign
id|optarg
suffix:semicolon
id|start_specified
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;e&squot;
suffix:colon
id|end_param_str
op_assign
id|optarg
suffix:semicolon
id|end_specified
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
id|blksize_param_str
op_assign
id|optarg
suffix:semicolon
id|blksize_specified
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
id|devno_param_str
op_assign
id|optarg
suffix:semicolon
id|devno_specified
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;f&squot;
suffix:colon
id|dev_filename
op_assign
id|optarg
suffix:semicolon
id|devfile_specified
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
id|range_param_str
op_assign
id|optarg
suffix:semicolon
id|range_specified
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/******************** checking of parameters **************/
multiline_comment|/* convert range into -s and -e */
id|CHECK_SPEC_MAX_ONCE
c_func
(paren
id|range_specified
comma
l_string|&quot;formatting range&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|range_specified
)paren
(brace
id|start_specified
op_increment
suffix:semicolon
id|end_specified
op_increment
suffix:semicolon
multiline_comment|/* scan for 1 or 2 integers, separated by a dash */
id|rc
op_assign
id|sscanf
c_func
(paren
id|range_param_str
comma
l_string|&quot;%d%c%d%c&quot;
comma
op_amp
id|i1
comma
op_amp
id|c1
comma
op_amp
id|i2
comma
op_amp
id|c2
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_eq
l_int|3
)paren
op_logical_and
(paren
id|c1
op_eq
l_char|&squot;-&squot;
)paren
)paren
(brace
id|format_params.start_unit
op_assign
id|i1
suffix:semicolon
id|format_params.stop_unit
op_assign
id|i2
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
op_eq
l_int|1
)paren
(brace
id|format_params.start_unit
op_assign
id|i1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* scan for integer and -END */
id|rc
op_assign
id|sscanf
c_func
(paren
id|range_param_str
comma
l_string|&quot;%d%s&quot;
comma
op_amp
id|i1
comma
id|cbuffer
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_eq
l_int|2
)paren
op_logical_and
(paren
op_logical_neg
id|strcasecmp
c_func
(paren
id|cbuffer
comma
l_string|&quot;-END&quot;
)paren
)paren
)paren
(brace
id|format_params.start_unit
op_assign
id|i1
suffix:semicolon
id|format_params.stop_unit
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_MISUSE
comma
l_string|&quot;%s: specified range &quot;
"&bslash;"
l_string|&quot;is in invalid format&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|devfile_specified
)paren
op_logical_and
(paren
op_logical_neg
id|devno_specified
)paren
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_MISUSE
comma
l_string|&quot;%s: device to format &quot;
"&bslash;"
l_string|&quot;not specified&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|devfile_specified
op_plus
id|devno_specified
)paren
OG
l_int|1
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_MISUSE
comma
l_string|&quot;%s: device to format &quot;
"&bslash;"
l_string|&quot;can only be specified once&bslash;n&quot;
comma
id|prog_name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|start_specified
)paren
op_logical_and
(paren
op_logical_neg
id|end_specified
)paren
op_logical_and
(paren
op_logical_neg
id|range_specified
)paren
op_logical_and
(paren
op_logical_neg
id|blksize_specified
)paren
)paren
(brace
id|format_params
op_assign
id|ask_user_for_data
c_func
(paren
id|format_params
)paren
suffix:semicolon
)brace
id|CHECK_SPEC_MAX_ONCE
c_func
(paren
id|start_specified
comma
l_string|&quot;start track&quot;
)paren
suffix:semicolon
id|CHECK_SPEC_MAX_ONCE
c_func
(paren
id|end_specified
comma
l_string|&quot;end track&quot;
)paren
suffix:semicolon
id|CHECK_SPEC_MAX_ONCE
c_func
(paren
id|blksize_specified
comma
l_string|&quot;blocksize&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devno_specified
)paren
id|PARSE_PARAM_INTO
c_func
(paren
id|devno
comma
id|devno_param_str
comma
l_int|16
comma
l_string|&quot;device number&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start_specified
op_logical_and
op_logical_neg
id|range_specified
)paren
id|PARSE_PARAM_INTO
c_func
(paren
id|format_params.start_unit
comma
id|start_param_str
comma
l_int|10
comma
l_string|&quot;start track&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end_specified
op_logical_and
op_logical_neg
id|range_specified
)paren
id|PARSE_PARAM_INTO
c_func
(paren
id|format_params.stop_unit
comma
id|end_param_str
comma
l_int|10
comma
l_string|&quot;end track&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blksize_specified
)paren
id|PARSE_PARAM_INTO
c_func
(paren
id|format_params.blksize
comma
id|blksize_param_str
comma
l_int|10
comma
l_string|&quot;blocksize&quot;
)paren
suffix:semicolon
multiline_comment|/***********get dev_name *********************/
id|dev_name
op_assign
(paren
id|devno_specified
)paren
ques
c_cond
id|get_devname_from_devno
c_func
(paren
id|devno
comma
id|verbosity
)paren
suffix:colon
id|dev_filename
suffix:semicolon
multiline_comment|/*** range checking *********/
id|str
op_assign
id|check_param
c_func
(paren
id|CHECK_ALL
comma
id|format_params
)paren
suffix:semicolon
r_if
c_cond
(paren
id|str
op_ne
l_int|NULL
)paren
id|ERRMSG_EXIT
c_func
(paren
id|EXIT_MISUSE
comma
l_string|&quot;%s: %s&bslash;n&quot;
comma
id|prog_name
comma
id|str
)paren
suffix:semicolon
multiline_comment|/*************** issue the real command *****************/
id|do_format_dasd
c_func
(paren
id|dev_name
comma
id|format_params
comma
id|testmode
comma
id|verbosity
comma
id|withoutprompt
)paren
suffix:semicolon
multiline_comment|/*************** cleanup ********************************/
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|dev_name
comma
id|TEMPFILENAME
comma
id|TEMPFILENAMECHARS
)paren
op_eq
l_int|0
)paren
(brace
id|rc
op_assign
id|unlink
c_func
(paren
id|dev_name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
)paren
op_logical_and
(paren
id|verbosity
op_ge
l_int|1
)paren
)paren
id|ERRMSG
c_func
(paren
l_string|&quot;%s: temporary device node %s could not be &quot;
"&bslash;"
l_string|&quot;removed: %s&bslash;n&quot;
comma
id|prog_name
comma
id|dev_name
comma
id|strerror
c_func
(paren
id|errno
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|devno_specified
)paren
(brace
multiline_comment|/* so we have allocated space for the filename */
id|free
c_func
(paren
id|dev_name
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
