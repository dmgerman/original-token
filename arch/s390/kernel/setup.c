multiline_comment|/*&n; *  arch/s390/kernel/setup.c&n; *&n; *  S390 version&n; *    Copyright (C) 1999,2000 IBM Deutschland Entwicklung GmbH, IBM Corporation&n; *    Author(s): Hartmut Penner (hp@de.ibm.com),&n; *               Martin Schwidefsky (schwidefsky@de.ibm.com)&n; *&n; *  Derived from &quot;arch/i386/kernel/setup.c&quot;&n; *    Copyright (C) 1995, Linus Torvalds&n; */
multiline_comment|/*&n; * This file handles the architecture-dependent parts of initialization&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/user.h&gt;
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#ifdef CONFIG_BLK_DEV_RAM
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
multiline_comment|/*&n; * Machine setup..&n; */
DECL|variable|boot_cpu_addr
id|__u16
id|boot_cpu_addr
suffix:semicolon
DECL|variable|cpus_initialized
r_int
id|cpus_initialized
op_assign
l_int|0
suffix:semicolon
DECL|variable|cpu_initialized
r_int
r_int
id|cpu_initialized
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Setup options&n; */
macro_line|#ifdef CONFIG_BLK_DEV_RAM
r_extern
r_int
id|rd_doload
suffix:semicolon
multiline_comment|/* 1 = load ramdisk, 0 = don&squot;t load */
r_extern
r_int
id|rd_prompt
suffix:semicolon
multiline_comment|/* 1 = prompt for ramdisk, 0 = don&squot;t prompt*/
r_extern
r_int
id|rd_image_start
suffix:semicolon
multiline_comment|/* starting block # of image        */
macro_line|#endif
r_extern
r_int
id|root_mountflags
suffix:semicolon
r_extern
r_int
id|_text
comma
id|_etext
comma
id|_edata
comma
id|_end
suffix:semicolon
multiline_comment|/*&n; * This is set up by the setup-routine at boot-time&n; * for S390 need to find out, what we have to setup&n; * using address 0x10400 ...&n; */
macro_line|#include &lt;asm/setup.h&gt;
DECL|variable|command_line
r_static
r_char
id|command_line
(braket
id|COMMAND_LINE_SIZE
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|saved_command_line
r_char
id|saved_command_line
(braket
id|COMMAND_LINE_SIZE
)braket
suffix:semicolon
DECL|variable|code_resource
r_static
r_struct
id|resource
id|code_resource
op_assign
(brace
l_string|&quot;Kernel code&quot;
comma
l_int|0x100000
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|data_resource
r_static
r_struct
id|resource
id|data_resource
op_assign
(brace
l_string|&quot;Kernel data&quot;
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * cpu_init() initializes state that is per-CPU.&n; */
DECL|function|cpu_init
r_void
id|__init
id|cpu_init
(paren
r_void
)paren
(brace
r_int
id|nr
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|nr
comma
op_amp
id|cpu_initialized
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CPU#%d ALREADY INITIALIZED!!!!!!!!!&bslash;n&quot;
comma
id|nr
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
id|__sti
c_func
(paren
)paren
suffix:semicolon
)brace
id|cpus_initialized
op_increment
suffix:semicolon
multiline_comment|/*&n;         * Store processor id in lowcore (used e.g. in timer_interrupt)&n;         */
id|asm
r_volatile
(paren
l_string|&quot;stidp %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|S390_lowcore.cpu_data.cpu_id
)paren
)paren
suffix:semicolon
id|S390_lowcore.cpu_data.cpu_addr
op_assign
id|hard_smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|S390_lowcore.cpu_data.cpu_nr
op_assign
id|nr
suffix:semicolon
multiline_comment|/*&n;         * Force FPU initialization:&n;         */
id|current-&gt;flags
op_and_assign
op_complement
id|PF_USEDFPU
suffix:semicolon
id|current-&gt;used_math
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Setup active_mm for idle_task  */
id|atomic_inc
c_func
(paren
op_amp
id|init_mm.mm_count
)paren
suffix:semicolon
id|current-&gt;active_mm
op_assign
op_amp
id|init_mm
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;mm
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|enter_lazy_tlb
c_func
(paren
op_amp
id|init_mm
comma
id|current
comma
id|nr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * VM halt and poweroff setup routines&n; */
DECL|variable|vmhalt_cmd
r_char
id|vmhalt_cmd
(braket
l_int|128
)braket
op_assign
l_string|&quot;&quot;
suffix:semicolon
DECL|variable|vmpoff_cmd
r_char
id|vmpoff_cmd
(braket
l_int|128
)braket
op_assign
l_string|&quot;&quot;
suffix:semicolon
DECL|function|strncpy_skip_quote
r_static
r_inline
r_void
id|strncpy_skip_quote
c_func
(paren
r_char
op_star
id|dst
comma
r_char
op_star
id|src
comma
r_int
id|n
)paren
(brace
r_int
id|sx
comma
id|dx
suffix:semicolon
id|dx
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|sx
op_assign
l_int|0
suffix:semicolon
id|src
(braket
id|sx
)braket
op_ne
l_int|0
suffix:semicolon
id|sx
op_increment
)paren
(brace
r_if
c_cond
(paren
id|src
(braket
id|sx
)braket
op_eq
l_char|&squot;&quot;&squot;
)paren
r_continue
suffix:semicolon
id|dst
(braket
id|dx
op_increment
)braket
op_assign
id|src
(braket
id|sx
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dx
op_ge
id|n
)paren
r_break
suffix:semicolon
)brace
)brace
DECL|function|vmhalt_setup
r_static
r_int
id|__init
id|vmhalt_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|strncpy_skip_quote
c_func
(paren
id|vmhalt_cmd
comma
id|str
comma
l_int|127
)paren
suffix:semicolon
id|vmhalt_cmd
(braket
l_int|127
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;vmhalt=&quot;
comma
id|vmhalt_setup
)paren
suffix:semicolon
DECL|function|vmpoff_setup
r_static
r_int
id|__init
id|vmpoff_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|strncpy_skip_quote
c_func
(paren
id|vmpoff_cmd
comma
id|str
comma
l_int|127
)paren
suffix:semicolon
id|vmpoff_cmd
(braket
l_int|127
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;vmpoff=&quot;
comma
id|vmpoff_setup
)paren
suffix:semicolon
multiline_comment|/*&n; * Reboot, halt and power_off routines for non SMP.&n; */
macro_line|#ifndef CONFIG_SMP
DECL|function|machine_restart
r_void
id|machine_restart
c_func
(paren
r_char
op_star
id|__unused
)paren
(brace
id|reipl
c_func
(paren
id|S390_lowcore.ipl_device
)paren
suffix:semicolon
)brace
DECL|function|machine_halt
r_void
id|machine_halt
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|MACHINE_IS_VM
op_logical_and
id|strlen
c_func
(paren
id|vmhalt_cmd
)paren
OG
l_int|0
)paren
id|cpcmd
c_func
(paren
id|vmhalt_cmd
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|disabled_wait
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|machine_power_off
r_void
id|machine_power_off
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|MACHINE_IS_VM
op_logical_and
id|strlen
c_func
(paren
id|vmpoff_cmd
)paren
OG
l_int|0
)paren
id|cpcmd
c_func
(paren
id|vmpoff_cmd
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|disabled_wait
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Waits for &squot;delay&squot; microseconds using the tod clock&n; */
DECL|function|tod_wait
r_void
id|tod_wait
c_func
(paren
r_int
r_int
id|delay
)paren
(brace
r_uint64
id|start_cc
comma
id|end_cc
suffix:semicolon
r_if
c_cond
(paren
id|delay
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;STCK %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|start_cc
)paren
)paren
suffix:semicolon
r_do
(brace
id|asm
r_volatile
(paren
l_string|&quot;STCK %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|end_cc
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
(paren
id|end_cc
op_minus
id|start_cc
)paren
op_div
l_int|4096
)paren
OL
id|delay
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Setup function called from init/main.c just after the banner&n; * was printed.&n; */
DECL|function|setup_arch
r_void
id|__init
id|setup_arch
c_func
(paren
r_char
op_star
op_star
id|cmdline_p
)paren
(brace
r_int
r_int
id|bootmap_size
suffix:semicolon
r_int
r_int
id|memory_start
comma
id|memory_end
suffix:semicolon
r_char
id|c
op_assign
l_char|&squot; &squot;
comma
op_star
id|to
op_assign
id|command_line
comma
op_star
id|from
op_assign
id|COMMAND_LINE
suffix:semicolon
r_struct
id|resource
op_star
id|res
suffix:semicolon
r_int
r_int
id|start_pfn
comma
id|end_pfn
suffix:semicolon
r_static
r_int
r_int
id|smptrap
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|delay
op_assign
l_int|0
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|smptrap
)paren
r_return
suffix:semicolon
id|smptrap
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Command line is: %s&bslash;n&quot;
comma
id|COMMAND_LINE
)paren
suffix:semicolon
multiline_comment|/*&n;         * Setup lowcore information for boot cpu&n;         */
id|cpu_init
c_func
(paren
)paren
suffix:semicolon
id|boot_cpu_addr
op_assign
id|S390_lowcore.cpu_data.cpu_addr
suffix:semicolon
multiline_comment|/*&n;         * print what head.S has found out about the machine &n;         */
id|printk
c_func
(paren
(paren
id|MACHINE_IS_VM
)paren
ques
c_cond
l_string|&quot;We are running under VM&bslash;n&quot;
suffix:colon
l_string|&quot;We are running native&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
(paren
id|MACHINE_HAS_IEEE
)paren
ques
c_cond
l_string|&quot;This machine has an IEEE fpu&bslash;n&quot;
suffix:colon
l_string|&quot;This machine has no IEEE fpu&bslash;n&quot;
)paren
suffix:semicolon
id|ROOT_DEV
op_assign
id|to_kdev_t
c_func
(paren
id|ORIG_ROOT_DEV
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_RAM
id|rd_image_start
op_assign
id|RAMDISK_FLAGS
op_amp
id|RAMDISK_IMAGE_START_MASK
suffix:semicolon
id|rd_prompt
op_assign
(paren
(paren
id|RAMDISK_FLAGS
op_amp
id|RAMDISK_PROMPT_FLAG
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|rd_doload
op_assign
(paren
(paren
id|RAMDISK_FLAGS
op_amp
id|RAMDISK_LOAD_FLAG
)paren
op_ne
l_int|0
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* nasty stuff with PARMAREAs. we use head.S or parameterline&n;&t;  if (!MOUNT_ROOT_RDONLY)&n;&t;  root_mountflags &amp;= ~MS_RDONLY;&n;&t;*/
id|memory_start
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_end
suffix:semicolon
multiline_comment|/* fixit if use $CODELO etc*/
id|memory_end
op_assign
id|MEMORY_SIZE
suffix:semicolon
multiline_comment|/* detected in head.s */
id|init_mm.start_code
op_assign
id|PAGE_OFFSET
suffix:semicolon
id|init_mm.end_code
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_etext
suffix:semicolon
id|init_mm.end_data
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_edata
suffix:semicolon
id|init_mm.brk
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_end
suffix:semicolon
id|code_resource.start
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_text
suffix:semicolon
id|code_resource.end
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_etext
op_minus
l_int|1
suffix:semicolon
id|data_resource.start
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_etext
suffix:semicolon
id|data_resource.end
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_edata
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Save unparsed command line copy for /proc/cmdline */
id|memcpy
c_func
(paren
id|saved_command_line
comma
id|COMMAND_LINE
comma
id|COMMAND_LINE_SIZE
)paren
suffix:semicolon
id|saved_command_line
(braket
id|COMMAND_LINE_SIZE
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;                 * &quot;mem=XXX[kKmM]&quot; sets memsize &n;                 */
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot; &squot;
op_logical_and
id|strncmp
c_func
(paren
id|from
comma
l_string|&quot;mem=&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|to
op_ne
id|command_line
)paren
id|to
op_decrement
suffix:semicolon
id|memory_end
op_assign
id|simple_strtoul
c_func
(paren
id|from
op_plus
l_int|4
comma
op_amp
id|from
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|from
op_eq
l_char|&squot;K&squot;
op_logical_or
op_star
id|from
op_eq
l_char|&squot;k&squot;
)paren
(brace
id|memory_end
op_assign
id|memory_end
op_lshift
l_int|10
suffix:semicolon
id|from
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|from
op_eq
l_char|&squot;M&squot;
op_logical_or
op_star
id|from
op_eq
l_char|&squot;m&squot;
)paren
(brace
id|memory_end
op_assign
id|memory_end
op_lshift
l_int|20
suffix:semicolon
id|from
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;                 * &quot;ipldelay=XXX[sm]&quot; sets ipl delay in seconds or minutes&n;                 */
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot; &squot;
op_logical_and
id|strncmp
c_func
(paren
id|from
comma
l_string|&quot;ipldelay=&quot;
comma
l_int|9
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|to
op_ne
id|command_line
)paren
id|to
op_decrement
suffix:semicolon
id|delay
op_assign
id|simple_strtoul
c_func
(paren
id|from
op_plus
l_int|9
comma
op_amp
id|from
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|from
op_eq
l_char|&squot;s&squot;
op_logical_or
op_star
id|from
op_eq
l_char|&squot;S&squot;
)paren
(brace
id|delay
op_assign
id|delay
op_star
l_int|1000000
suffix:semicolon
id|from
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|from
op_eq
l_char|&squot;m&squot;
op_logical_or
op_star
id|from
op_eq
l_char|&squot;M&squot;
)paren
(brace
id|delay
op_assign
id|delay
op_star
l_int|60
op_star
l_int|1000000
suffix:semicolon
id|from
op_increment
suffix:semicolon
)brace
multiline_comment|/* now wait for the requestion amount of time */
id|tod_wait
c_func
(paren
id|delay
)paren
suffix:semicolon
)brace
id|c
op_assign
op_star
(paren
id|from
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|COMMAND_LINE_SIZE
op_le
op_increment
id|len
)paren
r_break
suffix:semicolon
op_star
(paren
id|to
op_increment
)paren
op_assign
id|c
suffix:semicolon
)brace
op_star
id|to
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
op_star
id|cmdline_p
op_assign
id|command_line
suffix:semicolon
multiline_comment|/*&n;&t; * partially used pages are not usable - thus&n;&t; * we are rounding upwards:&n;&t; */
id|start_pfn
op_assign
(paren
id|__pa
c_func
(paren
op_amp
id|_end
)paren
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|end_pfn
op_assign
id|memory_end
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the boot-time allocator (with low memory only):&n;&t; */
id|bootmap_size
op_assign
id|init_bootmem
c_func
(paren
id|start_pfn
comma
id|end_pfn
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Register RAM pages with the bootmem allocator.&n;&t; */
id|free_bootmem
c_func
(paren
id|start_pfn
op_lshift
id|PAGE_SHIFT
comma
(paren
id|end_pfn
op_minus
id|start_pfn
)paren
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
multiline_comment|/*&n;         * Reserve the bootmem bitmap itself as well. We do this in two&n;         * steps (first step was init_bootmem()) because this catches&n;         * the (very unlikely) case of us accidentally initializing the&n;         * bootmem allocator with an invalid RAM area.&n;         */
id|reserve_bootmem
c_func
(paren
id|start_pfn
op_lshift
id|PAGE_SHIFT
comma
id|bootmap_size
)paren
suffix:semicolon
id|paging_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
id|INITRD_START
)paren
(brace
r_if
c_cond
(paren
id|INITRD_START
op_plus
id|INITRD_SIZE
OL
id|memory_end
)paren
(brace
id|reserve_bootmem
c_func
(paren
id|INITRD_START
comma
id|INITRD_SIZE
)paren
suffix:semicolon
id|initrd_start
op_assign
id|INITRD_START
suffix:semicolon
id|initrd_end
op_assign
id|initrd_start
op_plus
id|INITRD_SIZE
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;initrd extends beyond end of memory &quot;
l_string|&quot;(0x%08lx &gt; 0x%08lx)&bslash;ndisabling initrd&bslash;n&quot;
comma
id|initrd_start
op_plus
id|INITRD_SIZE
comma
id|memory_end
)paren
suffix:semicolon
id|initrd_start
op_assign
id|initrd_end
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
id|res
op_assign
id|alloc_bootmem_low
c_func
(paren
r_sizeof
(paren
r_struct
id|resource
)paren
)paren
suffix:semicolon
id|res-&gt;start
op_assign
l_int|0
suffix:semicolon
id|res-&gt;end
op_assign
id|memory_end
suffix:semicolon
id|res-&gt;flags
op_assign
id|IORESOURCE_MEM
op_or
id|IORESOURCE_BUSY
suffix:semicolon
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
id|res
)paren
suffix:semicolon
id|request_resource
c_func
(paren
id|res
comma
op_amp
id|code_resource
)paren
suffix:semicolon
id|request_resource
c_func
(paren
id|res
comma
op_amp
id|data_resource
)paren
suffix:semicolon
)brace
DECL|function|print_cpu_info
r_void
id|print_cpu_info
c_func
(paren
r_struct
id|cpuinfo_S390
op_star
id|cpuinfo
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cpu %d &quot;
macro_line|#ifdef CONFIG_SMP
l_string|&quot;phys_idx=%d &quot;
macro_line|#endif
l_string|&quot;vers=%02X ident=%06X machine=%04X unused=%04X&bslash;n&quot;
comma
id|cpuinfo-&gt;cpu_nr
comma
macro_line|#ifdef CONFIG_SMP
id|cpuinfo-&gt;cpu_addr
comma
macro_line|#endif
id|cpuinfo-&gt;cpu_id.version
comma
id|cpuinfo-&gt;cpu_id.ident
comma
id|cpuinfo-&gt;cpu_id.machine
comma
id|cpuinfo-&gt;cpu_id.unused
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get CPU information for use by the procfs.&n; */
DECL|function|get_cpuinfo
r_int
id|get_cpuinfo
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_struct
id|cpuinfo_S390
op_star
id|cpuinfo
suffix:semicolon
r_char
op_star
id|p
op_assign
id|buffer
suffix:semicolon
r_int
id|i
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;vendor_id       : IBM/S390&bslash;n&quot;
l_string|&quot;# processors    : %i&bslash;n&quot;
l_string|&quot;bogomips per cpu: %lu.%02lu&bslash;n&quot;
comma
id|smp_num_cpus
comma
id|loops_per_sec
op_div
l_int|500000
comma
(paren
id|loops_per_sec
op_div
l_int|5000
)paren
op_mod
l_int|100
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|smp_num_cpus
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cpuinfo
op_assign
op_amp
id|safe_get_cpu_lowcore
c_func
(paren
id|i
)paren
dot
id|cpu_data
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;processor %i: &quot;
l_string|&quot;version = %02X,  &quot;
l_string|&quot;identification = %06X,  &quot;
l_string|&quot;machine = %04X&bslash;n&quot;
comma
id|i
comma
id|cpuinfo-&gt;cpu_id.version
comma
id|cpuinfo-&gt;cpu_id.ident
comma
id|cpuinfo-&gt;cpu_id.machine
)paren
suffix:semicolon
)brace
r_return
id|p
op_minus
id|buffer
suffix:semicolon
)brace
eof
