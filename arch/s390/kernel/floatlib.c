multiline_comment|/*&n;** libgcc support for software floating point.&n;** Copyright (C) 1991 by Pipeline Associates, Inc.  All rights reserved.&n;** Permission is granted to do *anything* you want with this file,&n;** commercial or otherwise, provided this message remains intact.  So there!&n;** I would appreciate receiving any updates/patches/changes that anyone&n;** makes, and am willing to be the repository for said changes (am I&n;** making a big mistake?).&n;&n;Warning! Only single-precision is actually implemented.  This file&n;won&squot;t really be much use until double-precision is supported.&n;&n;However, once that is done, this file might eventually become a&n;replacement for libgcc1.c.  It might also make possible&n;cross-compilation for an IEEE target machine from a non-IEEE&n;host such as a VAX.&n;&n;If you&squot;d like to work on completing this, please talk to rms@gnu.ai.mit.edu.&n;&n;--&gt; Double precision floating support added by James Carlson on 20 April 1998.&n;&n;**&n;** Pat Wood&n;** Pipeline Associates, Inc.&n;** pipeline!phw@motown.com or&n;** sun!pipeline!phw or&n;** uunet!motown!pipeline!phw&n;**&n;** 05/01/91 -- V1.0 -- first release to gcc mailing lists&n;** 05/04/91 -- V1.1 -- added float and double prototypes and return values&n;**                  -- fixed problems with adding and subtracting zero&n;**                  -- fixed rounding in truncdfsf2&n;**                  -- fixed SWAP define and tested on 386&n;*/
multiline_comment|/*&n;** The following are routines that replace the libgcc soft floating point&n;** routines that are called automatically when -msoft-float is selected.&n;** The support single and double precision IEEE format, with provisions&n;** for byte-swapped machines (tested on 386).  Some of the double-precision&n;** routines work at full precision, but most of the hard ones simply punt&n;** and call the single precision routines, producing a loss of accuracy.&n;** long long support is not assumed or included.&n;** Overall accuracy is close to IEEE (actually 68882) for single-precision&n;** arithmetic.  I think there may still be a 1 in 1000 chance of a bit&n;** being rounded the wrong way during a multiply.  I&squot;m not fussy enough to&n;** bother with it, but if anyone is, knock yourself out.&n;**&n;** Efficiency has only been addressed where it was obvious that something&n;** would make a big difference.  Anyone who wants to do this right for&n;** best speed should go in and rewrite in assembler.&n;**&n;** I have tested this only on a 68030 workstation and 386/ix integrated&n;** in with -msoft-float.&n;*/
DECL|macro|float
mdefine_line|#define float long
DECL|macro|double
mdefine_line|#define double long long
multiline_comment|/* the following deal with IEEE single-precision numbers */
DECL|macro|EXCESS
mdefine_line|#define EXCESS          126
DECL|macro|SIGNBIT
mdefine_line|#define SIGNBIT         0x80000000
DECL|macro|HIDDEN
mdefine_line|#define HIDDEN          (1 &lt;&lt; 23)
DECL|macro|SIGN
mdefine_line|#define SIGN(fp)        ((fp) &amp; SIGNBIT)
DECL|macro|EXP
mdefine_line|#define EXP(fp)         (((fp) &gt;&gt; 23) &amp; 0xFF)
DECL|macro|MANT
mdefine_line|#define MANT(fp)        (((fp) &amp; 0x7FFFFF) | HIDDEN)
DECL|macro|PACK
mdefine_line|#define PACK(s,e,m)     ((s) | ((e) &lt;&lt; 23) | (m))
multiline_comment|/* the following deal with IEEE double-precision numbers */
DECL|macro|EXCESSD
mdefine_line|#define EXCESSD         1022
DECL|macro|HIDDEND
mdefine_line|#define HIDDEND         (1 &lt;&lt; 20)
DECL|macro|EXPD
mdefine_line|#define EXPD(fp)        (((fp.l.upper) &gt;&gt; 20) &amp; 0x7FF)
DECL|macro|SIGND
mdefine_line|#define SIGND(fp)       ((fp.l.upper) &amp; SIGNBIT)
DECL|macro|MANTD
mdefine_line|#define MANTD(fp)       (((((fp.l.upper) &amp; 0xFFFFF) | HIDDEND) &lt;&lt; 10) |(fp.l.lower &gt;&gt; 22))
DECL|macro|HIDDEND_LL
mdefine_line|#define HIDDEND_LL      ((long long)1 &lt;&lt; 52)
DECL|macro|MANTD_LL
mdefine_line|#define MANTD_LL(fp)    ((fp.ll &amp; (HIDDEND_LL-1)) | HIDDEND_LL)
DECL|macro|PACKD_LL
mdefine_line|#define PACKD_LL(s,e,m) (((long long)((s)+((e)&lt;&lt;20))&lt;&lt;32)|(m))
multiline_comment|/* define SWAP for 386/960 reverse-byte-order brain-damaged CPUs */
DECL|union|double_long
r_union
id|double_long
(brace
DECL|member|d
r_float
id|d
suffix:semicolon
macro_line|#ifdef SWAP
r_struct
(brace
DECL|member|lower
r_int
r_int
id|lower
suffix:semicolon
DECL|member|upper
r_int
id|upper
suffix:semicolon
DECL|member|l
)brace
id|l
suffix:semicolon
macro_line|#else
r_struct
(brace
DECL|member|upper
r_int
id|upper
suffix:semicolon
DECL|member|lower
r_int
r_int
id|lower
suffix:semicolon
DECL|member|l
)brace
id|l
suffix:semicolon
macro_line|#endif
DECL|member|ll
r_int
r_int
id|ll
suffix:semicolon
)brace
suffix:semicolon
DECL|union|float_long
r_union
id|float_long
(brace
DECL|member|f
r_float
id|f
suffix:semicolon
DECL|member|l
r_int
id|l
suffix:semicolon
)brace
suffix:semicolon
r_int
r_int
DECL|function|__negdi2
id|__negdi2
(paren
r_int
r_int
id|u
)paren
(brace
r_union
id|lll
(brace
r_int
r_int
id|ll
suffix:semicolon
r_int
id|s
(braket
l_int|2
)braket
suffix:semicolon
)brace
suffix:semicolon
r_union
id|lll
id|w
comma
id|uu
suffix:semicolon
id|uu.ll
op_assign
id|u
suffix:semicolon
id|w.s
(braket
l_int|1
)braket
op_assign
op_minus
id|uu.s
(braket
l_int|1
)braket
suffix:semicolon
id|w.s
(braket
l_int|0
)braket
op_assign
op_minus
id|uu.s
(braket
l_int|0
)braket
op_minus
(paren
(paren
r_int
)paren
id|w.s
(braket
l_int|1
)braket
op_ne
l_int|0
)paren
suffix:semicolon
r_return
id|w.ll
suffix:semicolon
)brace
multiline_comment|/* add two floats */
r_float
DECL|function|__addsf3
id|__addsf3
(paren
r_float
id|a1
comma
r_float
id|a2
)paren
(brace
r_register
r_int
id|mant1
comma
id|mant2
suffix:semicolon
r_register
r_union
id|float_long
id|fl1
comma
id|fl2
suffix:semicolon
r_register
r_int
id|exp1
comma
id|exp2
suffix:semicolon
r_int
id|sign
op_assign
l_int|0
suffix:semicolon
id|fl1.f
op_assign
id|a1
suffix:semicolon
id|fl2.f
op_assign
id|a2
suffix:semicolon
multiline_comment|/* check for zero args */
r_if
c_cond
(paren
op_logical_neg
id|fl1.l
)paren
(brace
id|fl1.f
op_assign
id|fl2.f
suffix:semicolon
r_goto
id|test_done
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|fl2.l
)paren
r_goto
id|test_done
suffix:semicolon
id|exp1
op_assign
id|EXP
(paren
id|fl1.l
)paren
suffix:semicolon
id|exp2
op_assign
id|EXP
(paren
id|fl2.l
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exp1
OG
id|exp2
op_plus
l_int|25
)paren
r_goto
id|test_done
suffix:semicolon
r_if
c_cond
(paren
id|exp2
OG
id|exp1
op_plus
l_int|25
)paren
(brace
id|fl1.f
op_assign
id|fl2.f
suffix:semicolon
r_goto
id|test_done
suffix:semicolon
)brace
multiline_comment|/* do everything in excess precision so&squot;s we can round later */
id|mant1
op_assign
id|MANT
(paren
id|fl1.l
)paren
op_lshift
l_int|6
suffix:semicolon
id|mant2
op_assign
id|MANT
(paren
id|fl2.l
)paren
op_lshift
l_int|6
suffix:semicolon
r_if
c_cond
(paren
id|SIGN
(paren
id|fl1.l
)paren
)paren
id|mant1
op_assign
op_minus
id|mant1
suffix:semicolon
r_if
c_cond
(paren
id|SIGN
(paren
id|fl2.l
)paren
)paren
id|mant2
op_assign
op_minus
id|mant2
suffix:semicolon
r_if
c_cond
(paren
id|exp1
OG
id|exp2
)paren
(brace
id|mant2
op_rshift_assign
id|exp1
op_minus
id|exp2
suffix:semicolon
)brace
r_else
(brace
id|mant1
op_rshift_assign
id|exp2
op_minus
id|exp1
suffix:semicolon
id|exp1
op_assign
id|exp2
suffix:semicolon
)brace
id|mant1
op_add_assign
id|mant2
suffix:semicolon
r_if
c_cond
(paren
id|mant1
OL
l_int|0
)paren
(brace
id|mant1
op_assign
op_minus
id|mant1
suffix:semicolon
id|sign
op_assign
id|SIGNBIT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|mant1
)paren
(brace
id|fl1.f
op_assign
l_int|0
suffix:semicolon
r_goto
id|test_done
suffix:semicolon
)brace
multiline_comment|/* normalize up */
r_while
c_loop
(paren
op_logical_neg
(paren
id|mant1
op_amp
l_int|0xE0000000
)paren
)paren
(brace
id|mant1
op_lshift_assign
l_int|1
suffix:semicolon
id|exp1
op_decrement
suffix:semicolon
)brace
multiline_comment|/* normalize down? */
r_if
c_cond
(paren
id|mant1
op_amp
(paren
l_int|1
op_lshift
l_int|30
)paren
)paren
(brace
id|mant1
op_rshift_assign
l_int|1
suffix:semicolon
id|exp1
op_increment
suffix:semicolon
)brace
multiline_comment|/* round to even */
id|mant1
op_add_assign
(paren
id|mant1
op_amp
l_int|0x40
)paren
ques
c_cond
l_int|0x20
suffix:colon
l_int|0x1F
suffix:semicolon
multiline_comment|/* normalize down? */
r_if
c_cond
(paren
id|mant1
op_amp
(paren
l_int|1
op_lshift
l_int|30
)paren
)paren
(brace
id|mant1
op_rshift_assign
l_int|1
suffix:semicolon
id|exp1
op_increment
suffix:semicolon
)brace
multiline_comment|/* lose extra precision */
id|mant1
op_rshift_assign
l_int|6
suffix:semicolon
multiline_comment|/* turn off hidden bit */
id|mant1
op_and_assign
op_complement
id|HIDDEN
suffix:semicolon
multiline_comment|/* pack up and go home */
id|fl1.l
op_assign
id|PACK
(paren
id|sign
comma
id|exp1
comma
id|mant1
)paren
suffix:semicolon
id|test_done
suffix:colon
r_return
(paren
id|fl1.f
)paren
suffix:semicolon
)brace
multiline_comment|/* subtract two floats */
r_float
DECL|function|__subsf3
id|__subsf3
(paren
r_float
id|a1
comma
r_float
id|a2
)paren
(brace
r_register
r_union
id|float_long
id|fl1
comma
id|fl2
suffix:semicolon
id|fl1.f
op_assign
id|a1
suffix:semicolon
id|fl2.f
op_assign
id|a2
suffix:semicolon
multiline_comment|/* check for second arg zero */
r_if
c_cond
(paren
op_logical_neg
id|fl2.l
)paren
r_return
(paren
id|fl1.f
)paren
suffix:semicolon
multiline_comment|/* twiddle sign bit */
id|fl2.l
op_xor_assign
id|SIGNBIT
suffix:semicolon
multiline_comment|/* check for first arg zero */
r_if
c_cond
(paren
op_logical_neg
id|fl1.l
)paren
r_return
(paren
id|fl2.f
)paren
suffix:semicolon
multiline_comment|/* add values */
r_return
id|__addsf3
(paren
id|a1
comma
id|fl2.f
)paren
suffix:semicolon
)brace
multiline_comment|/* compare two floats */
r_int
DECL|function|__cmpsf2
id|__cmpsf2
(paren
r_float
id|a1
comma
r_float
id|a2
)paren
(brace
r_register
r_union
id|float_long
id|fl1
comma
id|fl2
suffix:semicolon
id|fl1.f
op_assign
id|a1
suffix:semicolon
id|fl2.f
op_assign
id|a2
suffix:semicolon
r_if
c_cond
(paren
id|SIGN
(paren
id|fl1.l
)paren
op_logical_and
id|SIGN
(paren
id|fl2.l
)paren
)paren
(brace
id|fl1.l
op_xor_assign
id|SIGNBIT
suffix:semicolon
id|fl2.l
op_xor_assign
id|SIGNBIT
suffix:semicolon
r_if
c_cond
(paren
id|fl1.l
OL
id|fl2.l
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fl1.l
OG
id|fl2.l
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|fl1.l
OL
id|fl2.l
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fl1.l
OG
id|fl2.l
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* multiply two floats */
r_float
DECL|function|__mulsf3
id|__mulsf3
(paren
r_float
id|a1
comma
r_float
id|a2
)paren
(brace
r_register
r_union
id|float_long
id|fl1
comma
id|fl2
suffix:semicolon
r_register
r_int
r_int
id|result
suffix:semicolon
r_register
r_int
id|exp
suffix:semicolon
r_int
id|sign
suffix:semicolon
id|fl1.f
op_assign
id|a1
suffix:semicolon
id|fl2.f
op_assign
id|a2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fl1.l
op_logical_or
op_logical_neg
id|fl2.l
)paren
(brace
id|fl1.f
op_assign
l_int|0
suffix:semicolon
r_goto
id|test_done
suffix:semicolon
)brace
multiline_comment|/* compute sign and exponent */
id|sign
op_assign
id|SIGN
(paren
id|fl1.l
)paren
op_xor
id|SIGN
(paren
id|fl2.l
)paren
suffix:semicolon
id|exp
op_assign
id|EXP
(paren
id|fl1.l
)paren
op_minus
id|EXCESS
suffix:semicolon
id|exp
op_add_assign
id|EXP
(paren
id|fl2.l
)paren
suffix:semicolon
id|fl1.l
op_assign
id|MANT
(paren
id|fl1.l
)paren
suffix:semicolon
id|fl2.l
op_assign
id|MANT
(paren
id|fl2.l
)paren
suffix:semicolon
multiline_comment|/* the multiply is done as one 16x16 multiply and two 16x8 multiples */
id|result
op_assign
(paren
id|fl1.l
op_rshift
l_int|8
)paren
op_star
(paren
id|fl2.l
op_rshift
l_int|8
)paren
suffix:semicolon
id|result
op_add_assign
(paren
(paren
id|fl1.l
op_amp
l_int|0xFF
)paren
op_star
(paren
id|fl2.l
op_rshift
l_int|8
)paren
)paren
op_rshift
l_int|8
suffix:semicolon
id|result
op_add_assign
(paren
(paren
id|fl2.l
op_amp
l_int|0xFF
)paren
op_star
(paren
id|fl1.l
op_rshift
l_int|8
)paren
)paren
op_rshift
l_int|8
suffix:semicolon
id|result
op_rshift_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|result
op_amp
l_int|0x20000000
)paren
(brace
multiline_comment|/* round */
id|result
op_add_assign
l_int|0x20
suffix:semicolon
id|result
op_rshift_assign
l_int|6
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* round */
id|result
op_add_assign
l_int|0x10
suffix:semicolon
id|result
op_rshift_assign
l_int|5
suffix:semicolon
id|exp
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_amp
(paren
id|HIDDEN
op_lshift
l_int|1
)paren
)paren
(brace
id|result
op_rshift_assign
l_int|1
suffix:semicolon
id|exp
op_increment
suffix:semicolon
)brace
id|result
op_and_assign
op_complement
id|HIDDEN
suffix:semicolon
multiline_comment|/* pack up and go home */
id|fl1.l
op_assign
id|PACK
(paren
id|sign
comma
id|exp
comma
id|result
)paren
suffix:semicolon
id|test_done
suffix:colon
r_return
(paren
id|fl1.f
)paren
suffix:semicolon
)brace
multiline_comment|/* divide two floats */
r_float
DECL|function|__divsf3
id|__divsf3
(paren
r_float
id|a1
comma
r_float
id|a2
)paren
(brace
r_register
r_union
id|float_long
id|fl1
comma
id|fl2
suffix:semicolon
r_register
r_int
id|result
suffix:semicolon
r_register
r_int
id|mask
suffix:semicolon
r_register
r_int
id|exp
comma
id|sign
suffix:semicolon
id|fl1.f
op_assign
id|a1
suffix:semicolon
id|fl2.f
op_assign
id|a2
suffix:semicolon
multiline_comment|/* subtract exponents */
id|exp
op_assign
id|EXP
(paren
id|fl1.l
)paren
op_minus
id|EXP
(paren
id|fl2.l
)paren
op_plus
id|EXCESS
suffix:semicolon
multiline_comment|/* compute sign */
id|sign
op_assign
id|SIGN
(paren
id|fl1.l
)paren
op_xor
id|SIGN
(paren
id|fl2.l
)paren
suffix:semicolon
multiline_comment|/* divide by zero??? */
r_if
c_cond
(paren
op_logical_neg
id|fl2.l
)paren
multiline_comment|/* return NaN or -NaN */
r_return
(paren
id|sign
ques
c_cond
l_int|0xFFFFFFFF
suffix:colon
l_int|0x7FFFFFFF
)paren
suffix:semicolon
multiline_comment|/* numerator zero??? */
r_if
c_cond
(paren
op_logical_neg
id|fl1.l
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* now get mantissas */
id|fl1.l
op_assign
id|MANT
(paren
id|fl1.l
)paren
suffix:semicolon
id|fl2.l
op_assign
id|MANT
(paren
id|fl2.l
)paren
suffix:semicolon
multiline_comment|/* this assures we have 25 bits of precision in the end */
r_if
c_cond
(paren
id|fl1.l
OL
id|fl2.l
)paren
(brace
id|fl1.l
op_lshift_assign
l_int|1
suffix:semicolon
id|exp
op_decrement
suffix:semicolon
)brace
multiline_comment|/* now we perform repeated subtraction of fl2.l from fl1.l */
id|mask
op_assign
l_int|0x1000000
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|mask
)paren
(brace
r_if
c_cond
(paren
id|fl1.l
op_ge
id|fl2.l
)paren
(brace
id|result
op_or_assign
id|mask
suffix:semicolon
id|fl1.l
op_sub_assign
id|fl2.l
suffix:semicolon
)brace
id|fl1.l
op_lshift_assign
l_int|1
suffix:semicolon
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* round */
id|result
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* normalize down */
id|exp
op_increment
suffix:semicolon
id|result
op_rshift_assign
l_int|1
suffix:semicolon
id|result
op_and_assign
op_complement
id|HIDDEN
suffix:semicolon
multiline_comment|/* pack up and go home */
id|fl1.l
op_assign
id|PACK
(paren
id|sign
comma
id|exp
comma
id|result
)paren
suffix:semicolon
r_return
(paren
id|fl1.f
)paren
suffix:semicolon
)brace
multiline_comment|/* convert double to float */
r_float
DECL|function|__truncdfsf2
id|__truncdfsf2
(paren
r_float
id|a1
)paren
(brace
r_register
r_int
id|exp
suffix:semicolon
r_register
r_int
id|mant
suffix:semicolon
r_register
r_union
id|float_long
id|fl
suffix:semicolon
r_register
r_union
id|double_long
id|dl1
suffix:semicolon
id|dl1.d
op_assign
id|a1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dl1.l.upper
op_logical_and
op_logical_neg
id|dl1.l.lower
)paren
r_return
(paren
r_float
)paren
(paren
l_int|0
)paren
suffix:semicolon
id|exp
op_assign
id|EXPD
(paren
id|dl1
)paren
op_minus
id|EXCESSD
op_plus
id|EXCESS
suffix:semicolon
multiline_comment|/* shift double mantissa 6 bits so we can round */
id|mant
op_assign
id|MANTD
(paren
id|dl1
)paren
op_rshift
l_int|6
suffix:semicolon
multiline_comment|/* now round and shift down */
id|mant
op_add_assign
l_int|1
suffix:semicolon
id|mant
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* did the round overflow? */
r_if
c_cond
(paren
id|mant
op_amp
l_int|0xFF000000
)paren
(brace
id|mant
op_rshift_assign
l_int|1
suffix:semicolon
id|exp
op_increment
suffix:semicolon
)brace
id|mant
op_and_assign
op_complement
id|HIDDEN
suffix:semicolon
multiline_comment|/* pack up and go home */
id|fl.l
op_assign
id|PACK
(paren
id|SIGND
(paren
id|dl1
)paren
comma
id|exp
comma
id|mant
)paren
suffix:semicolon
r_return
(paren
id|fl.f
)paren
suffix:semicolon
)brace
multiline_comment|/* convert int to double */
r_float
DECL|function|__floatsidf
id|__floatsidf
(paren
r_register
r_int
id|a1
)paren
(brace
r_register
r_int
id|sign
op_assign
l_int|0
comma
id|exp
op_assign
l_int|31
op_plus
id|EXCESSD
suffix:semicolon
r_union
id|double_long
id|dl
suffix:semicolon
r_if
c_cond
(paren
id|a1
op_eq
l_int|0x80000000
)paren
(brace
multiline_comment|/*&n;       * -a1 would be 0 !&n;       */
id|dl.l.upper
op_assign
l_int|0xc1e00000
suffix:semicolon
id|dl.l.lower
op_assign
l_int|0x0
suffix:semicolon
r_return
(paren
id|dl.d
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|a1
)paren
(brace
id|dl.l.upper
op_assign
id|dl.l.lower
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|dl.d
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|a1
OL
l_int|0
)paren
(brace
id|sign
op_assign
id|SIGNBIT
suffix:semicolon
id|a1
op_assign
op_minus
id|a1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|a1
OL
l_int|0x1000000
)paren
(brace
id|a1
op_lshift_assign
l_int|4
suffix:semicolon
id|exp
op_sub_assign
l_int|4
suffix:semicolon
)brace
r_while
c_loop
(paren
id|a1
OL
l_int|0x40000000
)paren
(brace
id|a1
op_lshift_assign
l_int|1
suffix:semicolon
id|exp
op_decrement
suffix:semicolon
)brace
multiline_comment|/* pack up and go home */
id|dl.l.upper
op_assign
id|sign
suffix:semicolon
id|dl.l.upper
op_or_assign
id|exp
op_lshift
l_int|20
suffix:semicolon
id|dl.l.upper
op_or_assign
(paren
id|a1
op_rshift
l_int|10
)paren
op_amp
op_complement
id|HIDDEND
suffix:semicolon
id|dl.l.lower
op_assign
id|a1
op_lshift
l_int|22
suffix:semicolon
r_return
(paren
id|dl.d
)paren
suffix:semicolon
)brace
r_float
DECL|function|__floatdidf
id|__floatdidf
(paren
r_register
r_int
r_int
id|a1
)paren
(brace
r_register
r_int
id|exp
op_assign
l_int|63
op_plus
id|EXCESSD
suffix:semicolon
r_union
id|double_long
id|dl
suffix:semicolon
id|dl.l.upper
op_assign
id|dl.l.lower
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|a1
op_eq
l_int|0
)paren
r_return
(paren
id|dl.d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a1
OL
l_int|0
)paren
(brace
id|dl.l.upper
op_assign
id|SIGNBIT
suffix:semicolon
id|a1
op_assign
op_minus
id|a1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|a1
OL
(paren
r_int
r_int
)paren
l_int|1
op_lshift
l_int|54
)paren
(brace
id|a1
op_lshift_assign
l_int|8
suffix:semicolon
id|exp
op_sub_assign
l_int|8
suffix:semicolon
)brace
r_while
c_loop
(paren
id|a1
OL
(paren
r_int
r_int
)paren
l_int|1
op_lshift
l_int|62
)paren
(brace
id|a1
op_lshift_assign
l_int|1
suffix:semicolon
id|exp
op_sub_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* pack up and go home */
id|dl.ll
op_or_assign
(paren
id|a1
op_rshift
l_int|10
)paren
op_amp
op_complement
id|HIDDEND_LL
suffix:semicolon
id|dl.l.upper
op_or_assign
id|exp
op_lshift
l_int|20
suffix:semicolon
r_return
(paren
id|dl.d
)paren
suffix:semicolon
)brace
r_float
DECL|function|__floatsisf
id|__floatsisf
(paren
r_register
r_int
id|a1
)paren
(brace
r_return
id|__truncdfsf2
c_func
(paren
id|__floatsidf
c_func
(paren
id|a1
)paren
)paren
suffix:semicolon
)brace
r_float
DECL|function|__floatdisf
id|__floatdisf
(paren
r_register
r_int
r_int
id|a1
)paren
(brace
r_return
(paren
r_float
)paren
id|__floatdidf
c_func
(paren
id|a1
)paren
suffix:semicolon
)brace
multiline_comment|/* negate a float */
r_float
DECL|function|__negsf2
id|__negsf2
(paren
r_float
id|a1
)paren
(brace
r_register
r_union
id|float_long
id|fl1
suffix:semicolon
id|fl1.f
op_assign
id|a1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fl1.l
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|fl1.l
op_xor_assign
id|SIGNBIT
suffix:semicolon
r_return
(paren
id|fl1.f
)paren
suffix:semicolon
)brace
multiline_comment|/* negate a double */
r_float
DECL|function|__negdf2
id|__negdf2
(paren
r_float
id|a1
)paren
(brace
r_register
r_union
id|double_long
id|dl1
suffix:semicolon
id|dl1.d
op_assign
id|a1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dl1.l.upper
op_logical_and
op_logical_neg
id|dl1.l.lower
)paren
r_return
(paren
id|dl1.d
)paren
suffix:semicolon
id|dl1.l.upper
op_xor_assign
id|SIGNBIT
suffix:semicolon
r_return
(paren
id|dl1.d
)paren
suffix:semicolon
)brace
multiline_comment|/* convert float to double */
r_float
DECL|function|__extendsfdf2
id|__extendsfdf2
(paren
r_float
id|a1
)paren
(brace
r_register
r_union
id|float_long
id|fl1
suffix:semicolon
r_register
r_union
id|double_long
id|dl
suffix:semicolon
r_register
r_int
id|exp
suffix:semicolon
id|fl1.f
op_assign
id|a1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fl1.l
)paren
(brace
id|dl.l.upper
op_assign
id|dl.l.lower
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|dl.d
)paren
suffix:semicolon
)brace
id|dl.l.upper
op_assign
id|SIGN
(paren
id|fl1.l
)paren
suffix:semicolon
id|exp
op_assign
id|EXP
(paren
id|fl1.l
)paren
op_minus
id|EXCESS
op_plus
id|EXCESSD
suffix:semicolon
id|dl.l.upper
op_or_assign
id|exp
op_lshift
l_int|20
suffix:semicolon
id|dl.l.upper
op_or_assign
(paren
id|MANT
(paren
id|fl1.l
)paren
op_amp
op_complement
id|HIDDEN
)paren
op_rshift
l_int|3
suffix:semicolon
id|dl.l.lower
op_assign
id|MANT
(paren
id|fl1.l
)paren
op_lshift
l_int|29
suffix:semicolon
r_return
(paren
id|dl.d
)paren
suffix:semicolon
)brace
multiline_comment|/* compare two doubles */
r_int
DECL|function|__cmpdf2
id|__cmpdf2
(paren
r_float
id|a1
comma
r_float
id|a2
)paren
(brace
r_register
r_union
id|double_long
id|dl1
comma
id|dl2
suffix:semicolon
id|dl1.d
op_assign
id|a1
suffix:semicolon
id|dl2.d
op_assign
id|a2
suffix:semicolon
r_if
c_cond
(paren
id|SIGND
(paren
id|dl1
)paren
op_logical_and
id|SIGND
(paren
id|dl2
)paren
)paren
(brace
id|dl1.l.upper
op_xor_assign
id|SIGNBIT
suffix:semicolon
id|dl2.l.upper
op_xor_assign
id|SIGNBIT
suffix:semicolon
r_if
c_cond
(paren
id|dl1.l.upper
OL
id|dl2.l.upper
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dl1.l.upper
OG
id|dl2.l.upper
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dl1.l.lower
OL
id|dl2.l.lower
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dl1.l.lower
OG
id|dl2.l.lower
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|dl1.l.upper
OL
id|dl2.l.upper
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dl1.l.upper
OG
id|dl2.l.upper
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dl1.l.lower
OL
id|dl2.l.lower
)paren
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dl1.l.lower
OG
id|dl2.l.lower
)paren
r_return
(paren
l_int|1
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* convert double to int */
r_int
DECL|function|__fixdfsi
id|__fixdfsi
(paren
r_float
id|a1
)paren
(brace
r_register
r_union
id|double_long
id|dl1
suffix:semicolon
r_register
r_int
id|exp
suffix:semicolon
r_register
r_int
id|l
suffix:semicolon
id|dl1.d
op_assign
id|a1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dl1.l.upper
op_logical_and
op_logical_neg
id|dl1.l.lower
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|exp
op_assign
id|EXPD
(paren
id|dl1
)paren
op_minus
id|EXCESSD
op_minus
l_int|31
suffix:semicolon
id|l
op_assign
id|MANTD
(paren
id|dl1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exp
OG
l_int|0
)paren
r_return
id|SIGND
c_func
(paren
id|dl1
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|31
)paren
suffix:colon
(paren
(paren
l_int|1ul
op_lshift
l_int|31
)paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* shift down until exp = 0 or l = 0 */
r_if
c_cond
(paren
id|exp
op_le
l_int|0
op_logical_and
id|exp
OG
op_minus
l_int|32
op_logical_and
id|l
)paren
id|l
op_rshift_assign
op_minus
id|exp
suffix:semicolon
r_else
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|SIGND
(paren
id|dl1
)paren
ques
c_cond
op_minus
id|l
suffix:colon
id|l
)paren
suffix:semicolon
)brace
multiline_comment|/* convert float to int */
r_int
DECL|function|__fixsfsi
id|__fixsfsi
(paren
r_float
id|a1
)paren
(brace
r_return
id|__fixdfsi
c_func
(paren
id|__extendsfdf2
c_func
(paren
id|a1
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* convert double to int */
r_int
r_int
DECL|function|__fixdfdi
id|__fixdfdi
(paren
r_float
id|a1
)paren
(brace
r_register
r_union
id|double_long
id|dl1
suffix:semicolon
r_register
r_int
id|exp
suffix:semicolon
r_register
r_int
r_int
id|l
suffix:semicolon
id|dl1.d
op_assign
id|a1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dl1.l.upper
op_logical_and
op_logical_neg
id|dl1.l.lower
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|exp
op_assign
id|EXPD
(paren
id|dl1
)paren
op_minus
id|EXCESSD
op_minus
l_int|64
suffix:semicolon
id|l
op_assign
id|MANTD_LL
c_func
(paren
id|dl1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exp
OG
l_int|0
)paren
(brace
id|l
op_assign
(paren
r_int
r_int
)paren
l_int|1
op_lshift
l_int|63
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SIGND
c_func
(paren
id|dl1
)paren
)paren
id|l
op_decrement
suffix:semicolon
r_return
id|l
suffix:semicolon
)brace
multiline_comment|/* shift down until exp = 0 or l = 0 */
r_if
c_cond
(paren
id|exp
op_le
l_int|0
op_logical_and
id|exp
OG
op_minus
l_int|64
op_logical_and
id|l
)paren
id|l
op_rshift_assign
op_minus
id|exp
suffix:semicolon
r_else
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|SIGND
(paren
id|dl1
)paren
ques
c_cond
op_minus
id|l
suffix:colon
id|l
)paren
suffix:semicolon
)brace
multiline_comment|/* convert double to unsigned int */
r_int
r_int
DECL|function|__fixunsdfsi
id|__fixunsdfsi
(paren
r_float
id|a1
)paren
(brace
r_register
r_union
id|double_long
id|dl1
suffix:semicolon
r_register
r_int
id|exp
suffix:semicolon
r_register
r_int
r_int
id|l
suffix:semicolon
id|dl1.d
op_assign
id|a1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dl1.l.upper
op_logical_and
op_logical_neg
id|dl1.l.lower
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|exp
op_assign
id|EXPD
(paren
id|dl1
)paren
op_minus
id|EXCESSD
op_minus
l_int|32
suffix:semicolon
id|l
op_assign
(paren
(paren
(paren
(paren
(paren
id|dl1.l.upper
)paren
op_amp
l_int|0xFFFFF
)paren
op_or
id|HIDDEND
)paren
op_lshift
l_int|11
)paren
op_or
(paren
id|dl1.l.lower
op_rshift
l_int|21
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exp
OG
l_int|0
)paren
r_return
(paren
l_int|0xFFFFFFFFul
)paren
suffix:semicolon
multiline_comment|/* largest integer */
multiline_comment|/* shift down until exp = 0 or l = 0 */
r_if
c_cond
(paren
id|exp
template_param
op_minus
l_int|32
op_logical_and
id|l
)paren
id|l
op_rshift_assign
op_minus
id|exp
suffix:semicolon
r_else
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|l
)paren
suffix:semicolon
)brace
multiline_comment|/* convert double to unsigned int */
r_int
r_int
r_int
DECL|function|__fixunsdfdi
id|__fixunsdfdi
(paren
r_float
id|a1
)paren
(brace
r_register
r_union
id|double_long
id|dl1
suffix:semicolon
r_register
r_int
id|exp
suffix:semicolon
r_register
r_int
r_int
r_int
id|l
suffix:semicolon
id|dl1.d
op_assign
id|a1
suffix:semicolon
r_if
c_cond
(paren
id|dl1.ll
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|exp
op_assign
id|EXPD
(paren
id|dl1
)paren
op_minus
id|EXCESSD
op_minus
l_int|64
suffix:semicolon
id|l
op_assign
id|dl1.ll
suffix:semicolon
r_if
c_cond
(paren
id|exp
OG
l_int|0
)paren
r_return
(paren
r_int
r_int
r_int
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* shift down until exp = 0 or l = 0 */
r_if
c_cond
(paren
id|exp
template_param
op_minus
l_int|64
op_logical_and
id|l
)paren
id|l
op_rshift_assign
op_minus
id|exp
suffix:semicolon
r_else
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|l
)paren
suffix:semicolon
)brace
multiline_comment|/* addtwo doubles */
r_float
DECL|function|__adddf3
id|__adddf3
(paren
r_float
id|a1
comma
r_float
id|a2
)paren
(brace
r_register
r_int
r_int
id|mant1
comma
id|mant2
suffix:semicolon
r_register
r_union
id|double_long
id|fl1
comma
id|fl2
suffix:semicolon
r_register
r_int
id|exp1
comma
id|exp2
suffix:semicolon
r_int
id|sign
op_assign
l_int|0
suffix:semicolon
id|fl1.d
op_assign
id|a1
suffix:semicolon
id|fl2.d
op_assign
id|a2
suffix:semicolon
multiline_comment|/* check for zero args */
r_if
c_cond
(paren
op_logical_neg
id|fl2.ll
)paren
r_goto
id|test_done
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fl1.ll
)paren
(brace
id|fl1.d
op_assign
id|fl2.d
suffix:semicolon
r_goto
id|test_done
suffix:semicolon
)brace
id|exp1
op_assign
id|EXPD
c_func
(paren
id|fl1
)paren
suffix:semicolon
id|exp2
op_assign
id|EXPD
c_func
(paren
id|fl2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exp1
OG
id|exp2
op_plus
l_int|54
)paren
r_goto
id|test_done
suffix:semicolon
r_if
c_cond
(paren
id|exp2
OG
id|exp1
op_plus
l_int|54
)paren
(brace
id|fl1.d
op_assign
id|fl2.d
suffix:semicolon
r_goto
id|test_done
suffix:semicolon
)brace
multiline_comment|/* do everything in excess precision so&squot;s we can round later */
id|mant1
op_assign
id|MANTD_LL
c_func
(paren
id|fl1
)paren
op_lshift
l_int|9
suffix:semicolon
id|mant2
op_assign
id|MANTD_LL
c_func
(paren
id|fl2
)paren
op_lshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|SIGND
c_func
(paren
id|fl1
)paren
)paren
id|mant1
op_assign
op_minus
id|mant1
suffix:semicolon
r_if
c_cond
(paren
id|SIGND
c_func
(paren
id|fl2
)paren
)paren
id|mant2
op_assign
op_minus
id|mant2
suffix:semicolon
r_if
c_cond
(paren
id|exp1
OG
id|exp2
)paren
id|mant2
op_rshift_assign
id|exp1
op_minus
id|exp2
suffix:semicolon
r_else
(brace
id|mant1
op_rshift_assign
id|exp2
op_minus
id|exp1
suffix:semicolon
id|exp1
op_assign
id|exp2
suffix:semicolon
)brace
id|mant1
op_add_assign
id|mant2
suffix:semicolon
r_if
c_cond
(paren
id|mant1
OL
l_int|0
)paren
(brace
id|mant1
op_assign
op_minus
id|mant1
suffix:semicolon
id|sign
op_assign
id|SIGNBIT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|mant1
)paren
(brace
id|fl1.d
op_assign
l_int|0
suffix:semicolon
r_goto
id|test_done
suffix:semicolon
)brace
multiline_comment|/* normalize up */
r_while
c_loop
(paren
op_logical_neg
(paren
id|mant1
op_amp
(paren
(paren
r_int
r_int
)paren
l_int|7
op_lshift
l_int|61
)paren
)paren
)paren
(brace
id|mant1
op_lshift_assign
l_int|1
suffix:semicolon
id|exp1
op_decrement
suffix:semicolon
)brace
multiline_comment|/* normalize down? */
r_if
c_cond
(paren
id|mant1
op_amp
(paren
(paren
r_int
r_int
)paren
l_int|3
op_lshift
l_int|62
)paren
)paren
(brace
id|mant1
op_rshift_assign
l_int|1
suffix:semicolon
id|exp1
op_increment
suffix:semicolon
)brace
multiline_comment|/* round to even */
id|mant1
op_add_assign
(paren
id|mant1
op_amp
(paren
l_int|1
op_lshift
l_int|9
)paren
)paren
ques
c_cond
(paren
l_int|1
op_lshift
l_int|8
)paren
suffix:colon
(paren
(paren
l_int|1
op_lshift
l_int|8
)paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* normalize down? */
r_if
c_cond
(paren
id|mant1
op_amp
(paren
(paren
r_int
r_int
)paren
l_int|3
op_lshift
l_int|62
)paren
)paren
(brace
id|mant1
op_rshift_assign
l_int|1
suffix:semicolon
id|exp1
op_increment
suffix:semicolon
)brace
multiline_comment|/* lose extra precision */
id|mant1
op_rshift_assign
l_int|9
suffix:semicolon
multiline_comment|/* turn off hidden bit */
id|mant1
op_and_assign
op_complement
id|HIDDEND_LL
suffix:semicolon
multiline_comment|/* pack up and go home */
id|fl1.ll
op_assign
id|PACKD_LL
c_func
(paren
id|sign
comma
id|exp1
comma
id|mant1
)paren
suffix:semicolon
id|test_done
suffix:colon
r_return
(paren
id|fl1.d
)paren
suffix:semicolon
)brace
multiline_comment|/* subtract two doubles */
r_float
DECL|function|__subdf3
id|__subdf3
(paren
r_float
id|a1
comma
r_float
id|a2
)paren
(brace
r_register
r_union
id|double_long
id|fl1
comma
id|fl2
suffix:semicolon
id|fl1.d
op_assign
id|a1
suffix:semicolon
id|fl2.d
op_assign
id|a2
suffix:semicolon
multiline_comment|/* check for zero args */
r_if
c_cond
(paren
op_logical_neg
id|fl2.ll
)paren
r_return
(paren
id|fl1.d
)paren
suffix:semicolon
multiline_comment|/* twiddle sign bit and add */
id|fl2.l.upper
op_xor_assign
id|SIGNBIT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fl1.ll
)paren
r_return
(paren
id|fl2.d
)paren
suffix:semicolon
r_return
id|__adddf3
(paren
id|a1
comma
id|fl2.d
)paren
suffix:semicolon
)brace
multiline_comment|/* multiply two doubles */
r_float
DECL|function|__muldf3
id|__muldf3
(paren
r_float
id|a1
comma
r_float
id|a2
)paren
(brace
r_register
r_union
id|double_long
id|fl1
comma
id|fl2
suffix:semicolon
r_register
r_int
r_int
r_int
id|result
op_assign
l_int|0ULL
suffix:semicolon
r_register
r_int
id|exp
suffix:semicolon
r_int
id|sign
suffix:semicolon
id|fl1.d
op_assign
id|a1
suffix:semicolon
id|fl2.d
op_assign
id|a2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fl1.ll
op_logical_or
op_logical_neg
id|fl2.ll
)paren
(brace
id|fl1.d
op_assign
l_int|0
suffix:semicolon
r_goto
id|test_done
suffix:semicolon
)brace
multiline_comment|/* compute sign and exponent */
id|sign
op_assign
id|SIGND
c_func
(paren
id|fl1
)paren
op_xor
id|SIGND
c_func
(paren
id|fl2
)paren
suffix:semicolon
id|exp
op_assign
id|EXPD
c_func
(paren
id|fl1
)paren
op_minus
id|EXCESSD
suffix:semicolon
id|exp
op_add_assign
id|EXPD
c_func
(paren
id|fl2
)paren
suffix:semicolon
id|fl1.ll
op_assign
id|MANTD_LL
c_func
(paren
id|fl1
)paren
suffix:semicolon
id|fl2.ll
op_assign
id|MANTD_LL
c_func
(paren
id|fl2
)paren
suffix:semicolon
multiline_comment|/* the multiply is done as one 31x31 multiply and two 31x21 multiples */
id|result
op_assign
(paren
id|fl1.ll
op_rshift
l_int|21
)paren
op_star
(paren
id|fl2.ll
op_rshift
l_int|21
)paren
suffix:semicolon
id|result
op_add_assign
(paren
(paren
id|fl1.ll
op_amp
l_int|0x1FFFFF
)paren
op_star
(paren
id|fl2.ll
op_rshift
l_int|21
)paren
)paren
op_rshift
l_int|21
suffix:semicolon
id|result
op_add_assign
(paren
(paren
id|fl2.ll
op_amp
l_int|0x1FFFFF
)paren
op_star
(paren
id|fl1.ll
op_rshift
l_int|21
)paren
)paren
op_rshift
l_int|21
suffix:semicolon
id|result
op_rshift_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|result
op_amp
(paren
(paren
r_int
r_int
)paren
l_int|1
op_lshift
l_int|61
)paren
)paren
(brace
multiline_comment|/* round */
id|result
op_add_assign
l_int|1
op_lshift
l_int|8
suffix:semicolon
id|result
op_rshift_assign
l_int|9
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* round */
id|result
op_add_assign
l_int|1
op_lshift
l_int|7
suffix:semicolon
id|result
op_rshift_assign
l_int|8
suffix:semicolon
id|exp
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_amp
(paren
id|HIDDEND_LL
op_lshift
l_int|1
)paren
)paren
(brace
id|result
op_rshift_assign
l_int|1
suffix:semicolon
id|exp
op_increment
suffix:semicolon
)brace
id|result
op_and_assign
op_complement
id|HIDDEND_LL
suffix:semicolon
multiline_comment|/* pack up and go home */
id|fl1.ll
op_assign
id|PACKD_LL
c_func
(paren
id|sign
comma
id|exp
comma
id|result
)paren
suffix:semicolon
id|test_done
suffix:colon
r_return
(paren
id|fl1.d
)paren
suffix:semicolon
)brace
multiline_comment|/* divide two doubles */
r_float
DECL|function|__divdf3
id|__divdf3
(paren
r_float
id|a1
comma
r_float
id|a2
)paren
(brace
r_register
r_union
id|double_long
id|fl1
comma
id|fl2
suffix:semicolon
r_register
r_int
r_int
id|mask
comma
id|result
suffix:semicolon
r_register
r_int
id|exp
comma
id|sign
suffix:semicolon
id|fl1.d
op_assign
id|a1
suffix:semicolon
id|fl2.d
op_assign
id|a2
suffix:semicolon
multiline_comment|/* subtract exponents */
id|exp
op_assign
id|EXPD
c_func
(paren
id|fl1
)paren
op_minus
id|EXPD
c_func
(paren
id|fl2
)paren
op_plus
id|EXCESSD
suffix:semicolon
multiline_comment|/* compute sign */
id|sign
op_assign
id|SIGND
c_func
(paren
id|fl1
)paren
op_xor
id|SIGND
c_func
(paren
id|fl2
)paren
suffix:semicolon
multiline_comment|/* numerator zero??? */
r_if
c_cond
(paren
id|fl1.ll
op_eq
l_int|0
)paren
(brace
multiline_comment|/* divide by zero??? */
r_if
c_cond
(paren
id|fl2.ll
op_eq
l_int|0
)paren
id|fl1.ll
op_assign
(paren
(paren
r_int
r_int
r_int
)paren
l_int|1
op_lshift
l_int|63
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* NaN */
r_else
id|fl1.ll
op_assign
l_int|0
suffix:semicolon
r_goto
id|test_done
suffix:semicolon
)brace
multiline_comment|/* return +Inf or -Inf */
r_if
c_cond
(paren
id|fl2.ll
op_eq
l_int|0
)paren
(brace
id|fl1.ll
op_assign
id|PACKD_LL
c_func
(paren
id|SIGND
c_func
(paren
id|fl1
)paren
comma
l_int|2047
comma
l_int|0
)paren
suffix:semicolon
r_goto
id|test_done
suffix:semicolon
)brace
multiline_comment|/* now get mantissas */
id|fl1.ll
op_assign
id|MANTD_LL
c_func
(paren
id|fl1
)paren
suffix:semicolon
id|fl2.ll
op_assign
id|MANTD_LL
c_func
(paren
id|fl2
)paren
suffix:semicolon
multiline_comment|/* this assures we have 54 bits of precision in the end */
r_if
c_cond
(paren
id|fl1.ll
OL
id|fl2.ll
)paren
(brace
id|fl1.ll
op_lshift_assign
l_int|1
suffix:semicolon
id|exp
op_decrement
suffix:semicolon
)brace
multiline_comment|/* now we perform repeated subtraction of fl2.ll from fl1.ll */
id|mask
op_assign
(paren
r_int
r_int
)paren
l_int|1
op_lshift
l_int|53
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|mask
)paren
(brace
r_if
c_cond
(paren
id|fl1.ll
op_ge
id|fl2.ll
)paren
(brace
id|result
op_or_assign
id|mask
suffix:semicolon
id|fl1.ll
op_sub_assign
id|fl2.ll
suffix:semicolon
)brace
id|fl1.ll
op_lshift_assign
l_int|1
suffix:semicolon
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* round */
id|result
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* normalize down */
id|exp
op_increment
suffix:semicolon
id|result
op_rshift_assign
l_int|1
suffix:semicolon
id|result
op_and_assign
op_complement
id|HIDDEND_LL
suffix:semicolon
multiline_comment|/* pack up and go home */
id|fl1.ll
op_assign
id|PACKD_LL
c_func
(paren
id|sign
comma
id|exp
comma
id|result
)paren
suffix:semicolon
id|test_done
suffix:colon
r_return
(paren
id|fl1.d
)paren
suffix:semicolon
)brace
r_int
DECL|function|__gtdf2
id|__gtdf2
(paren
r_float
id|a1
comma
r_float
id|a2
)paren
(brace
r_return
id|__cmpdf2
(paren
(paren
r_float
)paren
id|a1
comma
(paren
r_float
)paren
id|a2
)paren
OG
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|__gedf2
id|__gedf2
(paren
r_float
id|a1
comma
r_float
id|a2
)paren
(brace
r_return
(paren
id|__cmpdf2
(paren
(paren
r_float
)paren
id|a1
comma
(paren
r_float
)paren
id|a2
)paren
op_ge
l_int|0
)paren
op_minus
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|__ltdf2
id|__ltdf2
(paren
r_float
id|a1
comma
r_float
id|a2
)paren
(brace
r_return
op_minus
(paren
id|__cmpdf2
(paren
(paren
r_float
)paren
id|a1
comma
(paren
r_float
)paren
id|a2
)paren
OL
l_int|0
)paren
suffix:semicolon
)brace
r_int
DECL|function|__ledf2
id|__ledf2
(paren
r_float
id|a1
comma
r_float
id|a2
)paren
(brace
r_return
id|__cmpdf2
(paren
(paren
r_float
)paren
id|a1
comma
(paren
r_float
)paren
id|a2
)paren
OG
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|__eqdf2
id|__eqdf2
(paren
r_float
id|a1
comma
r_float
id|a2
)paren
(brace
r_return
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|a1
op_eq
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|a2
suffix:semicolon
)brace
r_int
DECL|function|__nedf2
id|__nedf2
(paren
r_float
id|a1
comma
r_float
id|a2
)paren
(brace
r_return
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|a1
op_ne
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|a2
suffix:semicolon
)brace
multiline_comment|/* absolute value of double */
r_float
DECL|function|__absdf2
id|__absdf2
c_func
(paren
r_float
id|a1
)paren
(brace
r_if
c_cond
(paren
id|__cmpdf2
c_func
(paren
id|a1
comma
l_float|0.0
)paren
OL
l_int|0
)paren
r_return
id|__negdf2
c_func
(paren
id|a1
)paren
suffix:semicolon
r_else
r_return
id|a1
suffix:semicolon
)brace
multiline_comment|/* absolute value of float */
r_float
DECL|function|__abssf2
id|__abssf2
c_func
(paren
r_float
id|a1
)paren
(brace
r_if
c_cond
(paren
id|__cmpsf2
c_func
(paren
id|a1
comma
l_float|0.0
)paren
OL
l_int|0
)paren
r_return
id|__negsf2
c_func
(paren
id|a1
)paren
suffix:semicolon
r_else
r_return
id|a1
suffix:semicolon
)brace
eof
