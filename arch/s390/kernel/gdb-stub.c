multiline_comment|/*&n; *  arch/s390/kernel/gdb-stub.c&n; *&n; *  S390 version&n; *    Copyright (C) 1999 IBM Deutschland Entwicklung GmbH, IBM Corporation&n; *    Author(s): Denis Joseph Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com),&n; *&n; *  Originally written by Glenn Engel, Lake Stevens Instrument Division&n; *&n; *  Contributed by HP Systems&n; *&n; *  Modified for SPARC by Stu Grossman, Cygnus Support.&n; *&n; *  Modified for Linux/MIPS (and MIPS in general) by Andreas Busse&n; *  Send complaints, suggestions etc. to &lt;andy@waldorf-gmbh.de&gt;&n; *&n; *  Copyright (C) 1995 Andreas Busse&n; */
multiline_comment|/*&n; *  To enable debugger support, two things need to happen.  One, a&n; *  call to set_debug_traps() is necessary in order to allow any breakpoints&n; *  or error conditions to be properly intercepted and reported to gdb.&n; *  Two, a breakpoint needs to be generated to begin communication.  This&n; *  is most easily accomplished by a call to breakpoint().  Breakpoint()&n; *  simulates a breakpoint by executing a BREAK instruction.&n; *&n; *&n; *    The following gdb commands are supported:&n; *&n; * command          function                               Return value&n; *&n; *    g             return the value of the CPU registers  hex data or ENN&n; *    G             set the value of the CPU registers     OK or ENN&n; *&n; *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN&n; *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN&n; *&n; *    c             Resume at current address              SNN   ( signal NN)&n; *    cAA..AA       Continue at address AA..AA             SNN&n; *&n; *    s             Step one instruction                   SNN&n; *    sAA..AA       Step one instruction from AA..AA       SNN&n; *&n; *    k             kill&n; *&n; *    ?             What was the last sigval ?             SNN   (signal NN)&n; *&n; *&n; * All commands and responses are sent with a packet which includes a&n; * checksum.  A packet consists of&n; *&n; * $&lt;packet info&gt;#&lt;checksum&gt;.&n; *&n; * where&n; * &lt;packet info&gt; :: &lt;characters representing the command or response&gt;&n; * &lt;checksum&gt;    :: &lt; two hex digits computed as modulo 256 sum of &lt;packetinfo&gt;&gt;&n; *&n; * When a packet is received, it is first acknowledged with either &squot;+&squot; or &squot;-&squot;.&n; * &squot;+&squot; indicates a successful transfer.  &squot;-&squot; indicates a failed transfer.&n; *&n; * Example:&n; *&n; * Host:                  Reply:&n; * $m0,10#2a               +$00010203040506070809101112131415#42&n; *&n; */
macro_line|#include &lt;asm/gdb-stub.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/system.h&gt;
multiline_comment|/*&n; * external low-level support routines&n; */
r_extern
r_int
id|putDebugChar
c_func
(paren
r_char
id|c
)paren
suffix:semicolon
multiline_comment|/* write a single character      */
r_extern
r_char
id|getDebugChar
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* read and return a single char */
r_extern
r_void
id|fltr_set_mem_err
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|trap_low
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * breakpoint and test functions&n; */
r_extern
r_void
id|breakpoint
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|breakinst
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * local prototypes&n; */
r_static
r_void
id|getpacket
c_func
(paren
r_char
op_star
id|buffer
)paren
suffix:semicolon
r_static
r_void
id|putpacket
c_func
(paren
r_char
op_star
id|buffer
)paren
suffix:semicolon
r_static
r_int
id|hex
c_func
(paren
r_int
r_char
id|ch
)paren
suffix:semicolon
r_static
r_int
id|hexToInt
c_func
(paren
r_char
op_star
op_star
id|ptr
comma
r_int
op_star
id|intValue
)paren
suffix:semicolon
r_static
r_int
r_char
op_star
id|mem2hex
c_func
(paren
r_char
op_star
id|mem
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|may_fault
)paren
suffix:semicolon
multiline_comment|/*&n; * BUFMAX defines the maximum number of characters in inbound/outbound buffers&n; * at least NUMREGBYTES*2 are needed for register packets&n; */
DECL|macro|BUFMAX
mdefine_line|#define BUFMAX 2048
DECL|variable|input_buffer
r_static
r_char
id|input_buffer
(braket
id|BUFMAX
)braket
suffix:semicolon
DECL|variable|output_buffer
r_static
r_char
id|output_buffer
(braket
id|BUFMAX
)braket
suffix:semicolon
DECL|variable|gdb_stub_initialised
r_int
id|gdb_stub_initialised
op_assign
id|FALSE
suffix:semicolon
DECL|variable|hexchars
r_static
r_const
r_char
id|hexchars
(braket
)braket
op_assign
l_string|&quot;0123456789abcdef&quot;
suffix:semicolon
multiline_comment|/*&n; * Convert ch from a hex digit to an int&n; */
DECL|function|hex
r_static
r_int
id|hex
c_func
(paren
r_int
r_char
id|ch
)paren
(brace
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;a&squot;
op_logical_and
id|ch
op_le
l_char|&squot;f&squot;
)paren
r_return
id|ch
op_minus
l_char|&squot;a&squot;
op_plus
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;0&squot;
op_logical_and
id|ch
op_le
l_char|&squot;9&squot;
)paren
r_return
id|ch
op_minus
l_char|&squot;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_ge
l_char|&squot;A&squot;
op_logical_and
id|ch
op_le
l_char|&squot;F&squot;
)paren
r_return
id|ch
op_minus
l_char|&squot;A&squot;
op_plus
l_int|10
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * scan for the sequence $&lt;data&gt;#&lt;checksum&gt;&n; */
DECL|function|getpacket
r_static
r_void
id|getpacket
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_int
r_char
id|checksum
suffix:semicolon
r_int
r_char
id|xmitcsum
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * wait around for the start character,&n;&t;&t; * ignore all other characters&n;&t;&t; */
r_while
c_loop
(paren
(paren
id|ch
op_assign
(paren
id|getDebugChar
c_func
(paren
)paren
op_amp
l_int|0x7f
)paren
)paren
op_ne
l_char|&squot;$&squot;
)paren
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
id|xmitcsum
op_assign
op_minus
l_int|1
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * now, read until a # or end of buffer is found&n;&t;&t; */
r_while
c_loop
(paren
id|count
OL
id|BUFMAX
)paren
(brace
id|ch
op_assign
id|getDebugChar
c_func
(paren
)paren
op_amp
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;#&squot;
)paren
r_break
suffix:semicolon
id|checksum
op_assign
id|checksum
op_plus
id|ch
suffix:semicolon
id|buffer
(braket
id|count
)braket
op_assign
id|ch
suffix:semicolon
id|count
op_assign
id|count
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_ge
id|BUFMAX
)paren
r_continue
suffix:semicolon
id|buffer
(braket
id|count
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot;#&squot;
)paren
(brace
id|xmitcsum
op_assign
id|hex
c_func
(paren
id|getDebugChar
c_func
(paren
)paren
op_amp
l_int|0x7f
)paren
op_lshift
l_int|4
suffix:semicolon
id|xmitcsum
op_or_assign
id|hex
c_func
(paren
id|getDebugChar
c_func
(paren
)paren
op_amp
l_int|0x7f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|checksum
op_ne
id|xmitcsum
)paren
id|putDebugChar
c_func
(paren
l_char|&squot;-&squot;
)paren
suffix:semicolon
multiline_comment|/* failed checksum */
r_else
(brace
id|putDebugChar
c_func
(paren
l_char|&squot;+&squot;
)paren
suffix:semicolon
multiline_comment|/* successful transfer */
multiline_comment|/*&n;&t;&t;&t;&t; * if a sequence char is present,&n;&t;&t;&t;&t; * reply the sequence ID&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|buffer
(braket
l_int|2
)braket
op_eq
l_char|&squot;:&squot;
)paren
(brace
id|putDebugChar
c_func
(paren
id|buffer
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|putDebugChar
c_func
(paren
id|buffer
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * remove sequence chars from buffer&n;&t;&t;&t;&t;&t; */
id|count
op_assign
id|strlen
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|3
suffix:semicolon
id|i
op_le
id|count
suffix:semicolon
id|i
op_increment
)paren
id|buffer
(braket
id|i
op_minus
l_int|3
)braket
op_assign
id|buffer
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
)brace
)brace
r_while
c_loop
(paren
id|checksum
op_ne
id|xmitcsum
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * send the packet in buffer.&n; */
DECL|function|putpacket
r_static
r_void
id|putpacket
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_int
r_char
id|checksum
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
multiline_comment|/*&n;&t; * $&lt;packet info&gt;#&lt;checksum&gt;.&n;&t; */
r_do
(brace
id|putDebugChar
c_func
(paren
l_char|&squot;$&squot;
)paren
suffix:semicolon
id|checksum
op_assign
l_int|0
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ch
op_assign
id|buffer
(braket
id|count
)braket
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|putDebugChar
c_func
(paren
id|ch
)paren
)paren
)paren
r_return
suffix:semicolon
id|checksum
op_add_assign
id|ch
suffix:semicolon
id|count
op_add_assign
l_int|1
suffix:semicolon
)brace
id|putDebugChar
c_func
(paren
l_char|&squot;#&squot;
)paren
suffix:semicolon
id|putDebugChar
c_func
(paren
id|hexchars
(braket
id|checksum
op_rshift
l_int|4
)braket
)paren
suffix:semicolon
id|putDebugChar
c_func
(paren
id|hexchars
(braket
id|checksum
op_amp
l_int|0xf
)braket
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|getDebugChar
c_func
(paren
)paren
op_amp
l_int|0x7f
)paren
op_ne
l_char|&squot;+&squot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert the memory pointed to by mem into hex, placing result in buf.&n; * Return a pointer to the last char put in buf (null), in case of mem fault,&n; * return 0.&n; * If MAY_FAULT is non-zero, then we will handle memory faults by returning&n; * a 0, else treat a fault like any other fault in the stub.&n; */
DECL|function|mem2hex
r_static
r_int
r_char
op_star
id|mem2hex
c_func
(paren
r_char
op_star
id|mem
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
r_int
id|may_fault
)paren
(brace
r_int
r_char
id|ch
suffix:semicolon
multiline_comment|/*&t;set_mem_fault_trap(may_fault); */
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
id|ch
op_assign
op_star
(paren
id|mem
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mem_err
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|buf
op_increment
op_assign
id|hexchars
(braket
id|ch
op_amp
l_int|0xf
)braket
suffix:semicolon
)brace
op_star
id|buf
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&t;set_mem_fault_trap(0); */
r_return
id|buf
suffix:semicolon
)brace
multiline_comment|/*&n; * convert the hex array pointed to by buf into binary to be placed in mem&n; * return a pointer to the character AFTER the last byte written&n; */
DECL|function|hex2mem
r_static
r_char
op_star
id|hex2mem
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
id|mem
comma
r_int
id|count
comma
r_int
id|may_fault
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
multiline_comment|/*&t;set_mem_fault_trap(may_fault); */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ch
op_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
op_lshift
l_int|4
suffix:semicolon
id|ch
op_or_assign
id|hex
c_func
(paren
op_star
id|buf
op_increment
)paren
suffix:semicolon
op_star
(paren
id|mem
op_increment
)paren
op_assign
id|ch
suffix:semicolon
r_if
c_cond
(paren
id|mem_err
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&t;set_mem_fault_trap(0); */
r_return
id|mem
suffix:semicolon
)brace
multiline_comment|/*&n; * Set up exception handlers for tracing and breakpoints&n; */
DECL|function|set_debug_traps
r_void
id|set_debug_traps
c_func
(paren
r_void
)paren
(brace
singleline_comment|//&t;unsigned long flags;
r_int
r_char
id|c
suffix:semicolon
singleline_comment|//&t;save_and_cli(flags);
multiline_comment|/*&n;&t; * In case GDB is started before us, ack any packets&n;&t; * (presumably &quot;$?#xx&quot;) sitting there.&n;&t; */
r_while
c_loop
(paren
(paren
id|c
op_assign
id|getDebugChar
c_func
(paren
)paren
)paren
op_ne
l_char|&squot;$&squot;
)paren
(brace
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|c
op_assign
id|getDebugChar
c_func
(paren
)paren
)paren
op_ne
l_char|&squot;#&squot;
)paren
(brace
suffix:semicolon
)brace
id|c
op_assign
id|getDebugChar
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* eat first csum byte */
id|c
op_assign
id|getDebugChar
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* eat second csum byte */
id|putDebugChar
c_func
(paren
l_char|&squot;+&squot;
)paren
suffix:semicolon
multiline_comment|/* ack it */
id|gdb_stub_initialised
op_assign
id|TRUE
suffix:semicolon
singleline_comment|//&t;restore_flags(flags);
)brace
multiline_comment|/*&n; * Trap handler for memory errors.  This just sets mem_err to be non-zero.  It&n; * assumes that %l1 is non-zero.  This should be safe, as it is doubtful that&n; * 0 would ever contain code that could mem fault.  This routine will skip&n; * past the faulting instruction after setting mem_err.&n; */
DECL|function|fltr_set_mem_err
r_extern
r_void
id|fltr_set_mem_err
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* FIXME: Needs to be written... */
)brace
multiline_comment|/*&n; * While we find nice hex chars, build an int.&n; * Return number of chars processed.&n; */
DECL|function|hexToInt
r_static
r_int
id|hexToInt
c_func
(paren
r_char
op_star
op_star
id|ptr
comma
r_int
op_star
id|intValue
)paren
(brace
r_int
id|numChars
op_assign
l_int|0
suffix:semicolon
r_int
id|hexValue
suffix:semicolon
op_star
id|intValue
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
op_star
id|ptr
)paren
(brace
id|hexValue
op_assign
id|hex
c_func
(paren
op_star
op_star
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hexValue
OL
l_int|0
)paren
r_break
suffix:semicolon
op_star
id|intValue
op_assign
(paren
op_star
id|intValue
op_lshift
l_int|4
)paren
op_or
id|hexValue
suffix:semicolon
id|numChars
op_increment
suffix:semicolon
(paren
op_star
id|ptr
)paren
op_increment
suffix:semicolon
)brace
r_return
(paren
id|numChars
)paren
suffix:semicolon
)brace
DECL|function|gdb_stub_get_non_pt_regs
r_void
id|gdb_stub_get_non_pt_regs
c_func
(paren
id|gdb_pt_regs
op_star
id|regs
)paren
(brace
id|s390_fp_regs
op_star
id|fpregs
op_assign
op_amp
id|regs-&gt;fp_regs
suffix:semicolon
r_int
id|has_ieee
op_assign
id|save_fp_regs1
c_func
(paren
id|fpregs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|has_ieee
)paren
(brace
id|fpregs-&gt;fpc
op_assign
l_int|0
suffix:semicolon
id|fpregs-&gt;fprs
(braket
l_int|1
)braket
dot
id|d
op_assign
id|fpregs-&gt;fprs
(braket
l_int|3
)braket
dot
id|d
op_assign
id|fpregs-&gt;fprs
(braket
l_int|5
)braket
dot
id|d
op_assign
id|fpregs-&gt;fprs
(braket
l_int|7
)braket
dot
id|d
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|fpregs-&gt;fprs
(braket
l_int|8
)braket
dot
id|d
comma
l_int|0
comma
r_sizeof
(paren
id|freg_t
)paren
op_star
l_int|8
)paren
suffix:semicolon
)brace
)brace
DECL|function|gdb_stub_set_non_pt_regs
r_void
id|gdb_stub_set_non_pt_regs
c_func
(paren
id|gdb_pt_regs
op_star
id|regs
)paren
(brace
id|restore_fp_regs1
c_func
(paren
op_amp
id|regs-&gt;fp_regs
)paren
suffix:semicolon
)brace
DECL|function|gdb_stub_send_signal
r_void
id|gdb_stub_send_signal
c_func
(paren
r_int
id|sigval
)paren
(brace
r_char
op_star
id|ptr
suffix:semicolon
id|ptr
op_assign
id|output_buffer
suffix:semicolon
multiline_comment|/*&n;&t; * Send trap type (converted to signal)&n;&t; */
op_star
id|ptr
op_increment
op_assign
l_char|&squot;S&squot;
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|sigval
op_rshift
l_int|4
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|hexchars
(braket
id|sigval
op_amp
l_int|0xf
)braket
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_int|0
suffix:semicolon
id|putpacket
c_func
(paren
id|output_buffer
)paren
suffix:semicolon
multiline_comment|/* send it off... */
)brace
multiline_comment|/*&n; * This function does all command processing for interfacing to gdb.  It&n; * returns 1 if you should skip the instruction at the trap address, 0&n; * otherwise.&n; */
DECL|function|gdb_stub_handle_exception
r_void
id|gdb_stub_handle_exception
c_func
(paren
id|gdb_pt_regs
op_star
id|regs
comma
r_int
id|sigval
)paren
(brace
r_int
id|trap
suffix:semicolon
multiline_comment|/* Trap type */
r_int
id|addr
suffix:semicolon
r_int
id|length
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
r_int
r_int
op_star
id|stack
suffix:semicolon
multiline_comment|/*&n;&t; * reply to host that an exception has occurred&n;&t; */
id|send_signal
c_func
(paren
id|sigval
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wait for input from remote GDB&n;&t; */
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|output_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|getpacket
c_func
(paren
id|input_buffer
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|input_buffer
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;?&squot;
suffix:colon
id|send_signal
c_func
(paren
id|sigval
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
multiline_comment|/* toggle debug flag */
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Return the value of the CPU registers&n;&t;&t; */
r_case
l_char|&squot;g&squot;
suffix:colon
id|gdb_stub_get_non_pt_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
id|ptr
op_assign
id|output_buffer
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
id|regs
comma
id|ptr
comma
r_sizeof
(paren
id|s390_regs_common
)paren
comma
id|FALSE
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;crs
(braket
l_int|0
)braket
comma
id|ptr
comma
id|NUM_CRS
op_star
id|CR_SIZE
comma
id|FALSE
)paren
suffix:semicolon
id|ptr
op_assign
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|regs-&gt;fp_regs
comma
id|ptr
comma
r_sizeof
(paren
id|s390_fp_regs
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * set the value of the CPU registers - return OK&n;&t;&t; * FIXME: Needs to be written&n;&t;&t; */
r_case
l_char|&squot;G&squot;
suffix:colon
id|ptr
op_assign
id|input_buffer
suffix:semicolon
id|hex2mem
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
id|regs
comma
r_sizeof
(paren
id|s390_regs_common
)paren
comma
id|FALSE
)paren
suffix:semicolon
id|ptr
op_add_assign
r_sizeof
(paren
id|s390_regs_common
)paren
op_star
l_int|2
suffix:semicolon
id|hex2mem
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
id|regs-&gt;crs
(braket
l_int|0
)braket
comma
id|NUM_CRS
op_star
id|CR_SIZE
comma
id|FALSE
)paren
suffix:semicolon
id|ptr
op_add_assign
id|NUM_CRS
op_star
id|CR_SIZE
op_star
l_int|2
suffix:semicolon
id|hex2mem
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
id|regs-&gt;fp_regs
comma
r_sizeof
(paren
id|s390_fp_regs
)paren
comma
id|FALSE
)paren
suffix:semicolon
id|gdb_stub_set_non_pt_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * mAA..AA,LLLL  Read LLLL bytes at address AA..AA&n;&t;&t; */
r_case
l_char|&squot;m&squot;
suffix:colon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
op_logical_and
op_star
id|ptr
op_increment
op_eq
l_char|&squot;,&squot;
op_logical_and
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|length
)paren
)paren
(brace
r_if
c_cond
(paren
id|mem2hex
c_func
(paren
(paren
r_char
op_star
)paren
id|addr
comma
id|output_buffer
comma
id|length
comma
l_int|1
)paren
)paren
r_break
suffix:semicolon
id|strcpy
(paren
id|output_buffer
comma
l_string|&quot;E03&quot;
)paren
suffix:semicolon
)brace
r_else
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E01&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK&n;&t;&t; */
r_case
l_char|&squot;M&squot;
suffix:colon
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
op_logical_and
op_star
id|ptr
op_increment
op_eq
l_char|&squot;,&squot;
op_logical_and
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|length
)paren
op_logical_and
op_star
id|ptr
op_increment
op_eq
l_char|&squot;:&squot;
)paren
(brace
r_if
c_cond
(paren
id|hex2mem
c_func
(paren
id|ptr
comma
(paren
r_char
op_star
)paren
id|addr
comma
id|length
comma
l_int|1
)paren
)paren
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;OK&quot;
)paren
suffix:semicolon
r_else
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E03&quot;
)paren
suffix:semicolon
)brace
r_else
id|strcpy
c_func
(paren
id|output_buffer
comma
l_string|&quot;E02&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * cAA..AA    Continue at address AA..AA(optional)&n;&t;&t; */
r_case
l_char|&squot;c&squot;
suffix:colon
multiline_comment|/* try to read optional parameter, pc unchanged if no parm */
id|ptr
op_assign
op_amp
id|input_buffer
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hexToInt
c_func
(paren
op_amp
id|ptr
comma
op_amp
id|addr
)paren
)paren
id|regs-&gt;cp0_epc
op_assign
id|addr
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Need to flush the instruction cache here, as we may&n;&t;&t;&t; * have deposited a breakpoint, and the icache probably&n;&t;&t;&t; * has no way of knowing that a data ref to some location&n;&t;&t;&t; * may have changed something that is in the instruction&n;&t;&t;&t; * cache.&n;&t;&t;&t; * NB: We flush both caches, just to be sure...&n;&t;&t;&t; */
id|flush_cache_all
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* NOTREACHED */
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * kill the program&n;&t;&t; */
r_case
l_char|&squot;k&squot;
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* do nothing */
multiline_comment|/*&n;&t;&t; * Reset the whole machine (FIXME: system dependent)&n;&t;&t; */
r_case
l_char|&squot;r&squot;
suffix:colon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Step to next instruction&n;&t;&t; */
r_case
l_char|&squot;s&squot;
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * There is no single step insn in the MIPS ISA, so we&n;&t;&t;&t; * use breakpoints and continue, instead.&n;&t;&t;&t; */
id|single_step
c_func
(paren
id|regs
)paren
suffix:semicolon
id|flush_cache_all
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* NOTREACHED */
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* switch */
multiline_comment|/*&n;&t;&t; * reply to the request&n;&t;&t; */
id|putpacket
c_func
(paren
id|output_buffer
)paren
suffix:semicolon
)brace
multiline_comment|/* while */
)brace
multiline_comment|/*&n; * This function will generate a breakpoint exception.  It is used at the&n; * beginning of a program to sync up with a debugger and can be used&n; * otherwise as a quick means to stop program execution and &quot;break&quot; into&n; * the debugger.&n; */
r_void
id|breakpoint
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|gdb_stub_initialised
)paren
r_return
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;.globl&t;breakinst&bslash;n&quot;
l_string|&quot;breakinst:&bslash;t.word   %0&bslash;n&bslash;t&quot;
suffix:colon
suffix:colon
l_string|&quot;i&quot;
(paren
id|S390_BREAKPOINT_U16
)paren
suffix:colon
)paren
suffix:semicolon
)brace
eof
