multiline_comment|/*&n; *  arch/s390/kernel/s390io.c&n; *   S/390 common I/O routines&n; *&n; *  S390 version&n; *    Copyright (C) 1999, 2000 IBM Deutschland Entwicklung GmbH,&n; *                             IBM Corporation&n; *    Author(s): Ingo Adlung (adlung@de.ibm.com)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/tasks.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/lowcore.h&gt;
macro_line|#include &lt;asm/s390io.h&gt;
macro_line|#include &lt;asm/s390dyn.h&gt;
macro_line|#include &lt;asm/s390mach.h&gt;
macro_line|#ifndef TRUE
DECL|macro|TRUE
mdefine_line|#define TRUE  1
DECL|macro|FALSE
mdefine_line|#define FALSE 0
macro_line|#endif
DECL|macro|CONFIG_DEBUG_IO
macro_line|#undef CONFIG_DEBUG_IO
DECL|macro|REIPL_DEVID_MAGIC
mdefine_line|#define REIPL_DEVID_MAGIC 0x87654321
DECL|variable|init_IRQ_action
r_struct
id|irqaction
id|init_IRQ_action
suffix:semicolon
DECL|variable|highest_subchannel
r_int
r_int
id|highest_subchannel
suffix:semicolon
DECL|variable|ioinfo_head
id|ioinfo_t
op_star
id|ioinfo_head
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|ioinfo_tail
id|ioinfo_t
op_star
id|ioinfo_tail
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|ioinfo
id|ioinfo_t
op_star
id|ioinfo
(braket
id|__MAX_SUBCHANNELS
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
(paren
id|__MAX_SUBCHANNELS
op_minus
l_int|1
)paren
)braket
op_assign
id|INVALID_STORAGE_AREA
)brace
suffix:semicolon
DECL|variable|sync_isc
r_static
id|spinlock_t
id|sync_isc
suffix:semicolon
singleline_comment|// synchronous irq processing lock
DECL|variable|io_sync_wait
r_static
id|psw_t
id|io_sync_wait
suffix:semicolon
singleline_comment|// wait PSW for sync IO, prot. by sync_isc
DECL|variable|io_new_psw
r_static
id|psw_t
id|io_new_psw
suffix:semicolon
singleline_comment|// save I/O new PSW, prot. by sync_isc
DECL|variable|cons_dev
r_static
r_int
id|cons_dev
op_assign
op_minus
l_int|1
suffix:semicolon
singleline_comment|// identify console device
DECL|variable|init_IRQ_complete
r_static
r_int
id|init_IRQ_complete
op_assign
l_int|0
suffix:semicolon
DECL|variable|init_schib
r_static
id|schib_t
id|init_schib
suffix:semicolon
DECL|variable|irq_IPL_TOD
r_static
id|__u64
id|irq_IPL_TOD
suffix:semicolon
multiline_comment|/*&n; * Dummy controller type for unused interrupts&n; */
DECL|function|do_none
r_int
id|do_none
c_func
(paren
r_int
r_int
id|irq
comma
r_int
id|cpu
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|enable_none
r_int
id|enable_none
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|function|disable_none
r_int
id|disable_none
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|variable|no_irq_type
r_struct
id|hw_interrupt_type
id|no_irq_type
op_assign
(brace
l_string|&quot;none&quot;
comma
id|do_none
comma
id|enable_none
comma
id|disable_none
)brace
suffix:semicolon
r_static
r_void
id|init_IRQ_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|s390_setup_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_struct
id|irqaction
op_star
r_new
)paren
suffix:semicolon
r_static
r_void
id|s390_process_subchannels
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|s390_device_recognition
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|s390_validate_subchannel
c_func
(paren
r_int
id|irq
)paren
suffix:semicolon
r_static
r_int
id|s390_SenseID
c_func
(paren
r_int
id|irq
comma
id|senseid_t
op_star
id|sid
)paren
suffix:semicolon
r_static
r_int
id|s390_SetPGID
c_func
(paren
r_int
id|irq
comma
id|__u8
id|lpm
comma
id|pgid_t
op_star
id|pgid
)paren
suffix:semicolon
r_static
r_int
id|s390_SensePGID
c_func
(paren
r_int
id|irq
comma
id|__u8
id|lpm
comma
id|pgid_t
op_star
id|pgid
)paren
suffix:semicolon
r_static
r_int
id|s390_process_IRQ
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
r_static
r_int
id|s390_DevicePathVerification
c_func
(paren
r_int
id|irq
)paren
suffix:semicolon
r_extern
r_int
id|do_none
c_func
(paren
r_int
r_int
id|irq
comma
r_int
id|cpu
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_extern
r_int
id|enable_none
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
r_extern
r_int
id|disable_none
c_func
(paren
r_int
r_int
id|irq
)paren
suffix:semicolon
r_extern
r_void
id|tod_wait
c_func
(paren
r_int
r_int
id|usecs
)paren
suffix:semicolon
id|asmlinkage
r_void
id|do_IRQ
c_func
(paren
r_struct
id|pt_regs
id|regs
comma
r_int
r_int
id|irq
comma
id|__u32
id|s390_intparm
)paren
suffix:semicolon
r_void
id|s390_displayhex
c_func
(paren
r_char
op_star
id|str
comma
r_void
op_star
id|ptr
comma
id|s32
id|cnt
)paren
suffix:semicolon
DECL|function|s390_displayhex
r_void
id|s390_displayhex
c_func
(paren
r_char
op_star
id|str
comma
r_void
op_star
id|ptr
comma
id|s32
id|cnt
)paren
(brace
id|s32
id|cnt1
comma
id|cnt2
comma
id|maxcnt2
suffix:semicolon
id|u32
op_star
id|currptr
op_assign
(paren
id|__u32
op_star
)paren
id|ptr
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n%s&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt1
op_assign
l_int|0
suffix:semicolon
id|cnt1
OL
id|cnt
suffix:semicolon
id|cnt1
op_add_assign
l_int|16
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%08lX &quot;
comma
(paren
r_int
r_int
)paren
id|currptr
)paren
suffix:semicolon
id|maxcnt2
op_assign
id|cnt
op_minus
id|cnt1
suffix:semicolon
r_if
c_cond
(paren
id|maxcnt2
OG
l_int|16
)paren
(brace
id|maxcnt2
op_assign
l_int|16
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cnt2
op_assign
l_int|0
suffix:semicolon
id|cnt2
OL
id|maxcnt2
suffix:semicolon
id|cnt2
op_add_assign
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%08X &quot;
comma
op_star
id|currptr
op_increment
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|s390_request_irq
r_int
id|s390_request_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
comma
r_int
r_int
id|irqflags
comma
r_const
r_char
op_star
id|devname
comma
r_void
op_star
id|dev_id
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ge
id|__MAX_SUBCHANNELS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handler
op_logical_or
op_logical_neg
id|dev_id
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * during init_IRQ() processing we don&squot;t have memory&n;&t; *  management yet, thus need to use a statically&n;&t; *  allocated irqaction control block&n;&t; */
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
(brace
id|action
op_assign
(paren
r_struct
id|irqaction
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|irqaction
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_else
(brace
id|action
op_assign
op_amp
id|init_IRQ_action
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* endif */
id|action-&gt;handler
op_assign
id|handler
suffix:semicolon
id|action-&gt;flags
op_assign
id|irqflags
suffix:semicolon
id|action-&gt;mask
op_assign
l_int|0
suffix:semicolon
id|action-&gt;name
op_assign
id|devname
suffix:semicolon
id|action-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|action-&gt;dev_id
op_assign
id|dev_id
suffix:semicolon
id|retval
op_assign
id|s390_setup_irq
c_func
(paren
id|irq
comma
id|action
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
(brace
id|retval
op_assign
id|s390_DevicePathVerification
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|retval
op_logical_and
id|init_IRQ_complete
)paren
(brace
id|kfree
c_func
(paren
id|action
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|retval
suffix:semicolon
)brace
DECL|function|s390_free_irq
r_void
id|s390_free_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_void
op_star
id|dev_id
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ge
id|__MAX_SUBCHANNELS
op_logical_or
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* endif */
id|s390irq_spin_lock_irqsave
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef  CONFIG_KERNEL_DEBUG
r_if
c_cond
(paren
id|irq
op_ne
id|cons_dev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Trying to free IRQ%d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
macro_line|#endif
multiline_comment|/*&n;&t; * disable the device and reset all IRQ info if&n;&t; *  the IRQ is actually owned by the handler ...&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.action
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev_id
op_eq
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.action-&gt;dev_id
)paren
op_logical_or
(paren
id|dev_id
op_eq
(paren
id|devstat_t
op_star
)paren
id|REIPL_DEVID_MAGIC
)paren
)paren
(brace
multiline_comment|/* start deregister */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unready
op_assign
l_int|1
suffix:semicolon
r_do
(brace
id|ret
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.handler
op_member_access_from_pointer
id|disable
c_func
(paren
id|irq
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EBUSY
)paren
(brace
r_int
id|iret
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * kill it !&n;&t;&t;&t;&t;&t; * ... we first try sync and eventually&n;&t;&t;&t;&t;&t; *  try terminating the current I/O by&n;&t;&t;&t;&t;&t; *  an async request, twice halt, then&n;&t;&t;&t;&t;&t; *  clear.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|count
OL
l_int|3
)paren
(brace
id|iret
op_assign
id|halt_IO
c_func
(paren
id|irq
comma
l_int|0xC8C1D3E3
comma
id|DOIO_WAIT_FOR_INTERRUPT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iret
op_eq
op_minus
id|EBUSY
)paren
(brace
id|halt_IO
c_func
(paren
id|irq
comma
l_int|0xC8C1D3E3
comma
l_int|0
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|tod_wait
c_func
(paren
l_int|200000
)paren
suffix:semicolon
multiline_comment|/* 200 ms */
id|s390irq_spin_lock_irqsave
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|iret
op_assign
id|clear_IO
c_func
(paren
id|irq
comma
l_int|0x40C3D3D9
comma
id|DOIO_WAIT_FOR_INTERRUPT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|iret
op_eq
op_minus
id|EBUSY
)paren
(brace
id|clear_IO
c_func
(paren
id|irq
comma
l_int|0xC8C1D3E3
comma
l_int|0
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|tod_wait
c_func
(paren
l_int|1000000
)paren
suffix:semicolon
multiline_comment|/* 1000 ms */
id|s390irq_spin_lock_irqsave
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|count
op_eq
l_int|3
)paren
(brace
multiline_comment|/* give it a very last try ... */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.handler
op_member_access_from_pointer
id|disable
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;free_irq(%04X) &quot;
l_string|&quot;- device %04X busy, retry &quot;
l_string|&quot;count exceeded&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_break
suffix:semicolon
multiline_comment|/* sigh, let&squot;s give up ... */
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
)brace
r_while
c_loop
(paren
id|ret
op_eq
op_minus
id|EBUSY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|init_IRQ_complete
)paren
id|kfree
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.action
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.action
op_assign
l_int|NULL
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.handler-&gt;enable
op_assign
op_amp
id|enable_none
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.handler-&gt;disable
op_assign
op_amp
id|disable_none
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unready
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* deregister ended */
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;free_irq() : error, dev_id does not match !&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;free_irq() : error, no action block ... !&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/*&n; * Generic enable/disable code&n; */
DECL|function|disable_irq
r_int
id|disable_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|s390irq_spin_lock_irqsave
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * At this point we may actually have a pending interrupt being active&n;&t; * on another CPU. So don&squot;t touch the IRQ_INPROGRESS bit..&n;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.status
op_or_assign
id|IRQ_DISABLED
suffix:semicolon
id|ret
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.handler
op_member_access_from_pointer
id|disable
c_func
(paren
id|irq
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|synchronize_irq
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|enable_irq
r_int
id|enable_irq
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|s390irq_spin_lock_irqsave
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.status
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.handler
op_member_access_from_pointer
id|enable
c_func
(paren
id|irq
)paren
suffix:semicolon
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Enable IRQ by modifying the subchannel&n; */
DECL|function|enable_subchannel
r_static
r_int
id|enable_subchannel
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|irq
OG
id|highest_subchannel
op_logical_or
id|irq
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n;&t; * If a previous disable request is pending we reset it. However, this&n;&t; *  status implies that the device may (still) be not-operational.&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.d_disable
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.d_disable
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ccode
op_assign
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.ena
op_assign
l_int|1
suffix:semicolon
r_do
(brace
id|ccode
op_assign
id|msch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * very bad, requires interrupt alike&n;&t;&t;&t;&t;&t; *  processing, where &quot;rbh&quot; is a dummy&n;&t;&t;&t;&t;&t; *  parameter for interface compatibility&n;&t;&t;&t;&t;&t; *  only. Bottom-half handling cannot be&n;&t;&t;&t;&t;&t; *  required as this must be an&n;&t;&t;&t;&t;&t; *  unsolicited interrupt (!busy).&n;&t;&t;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|1
suffix:semicolon
id|s390_process_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* might be overwritten */
multiline_comment|/* ... on re-driving    */
multiline_comment|/* ... the msch() */
id|retry
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;enable_subchannel(%04X) &quot;
l_string|&quot; : ccode 2 on msch() for device &quot;
l_string|&quot;%04X received !&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
singleline_comment|// never reached
)brace
)brace
r_while
c_loop
(paren
(paren
id|ccode
op_eq
l_int|1
)paren
op_logical_and
id|retry
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Disable IRQ by modifying the subchannel&n; */
DECL|function|disable_subchannel
r_static
r_int
id|disable_subchannel
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|cc
suffix:semicolon
multiline_comment|/* condition code */
r_int
id|ret
suffix:semicolon
multiline_comment|/* function return value */
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|irq
OG
id|highest_subchannel
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
)paren
(brace
multiline_comment|/*&n;&t;&t; * the disable function must not be called while there are&n;&t;&t; *  requests pending for completion !&n;&t;&t; */
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * If device isn&squot;t operational we have to perform delayed&n;&t;&t; *  disabling when the next interrupt occurs - unless the&n;&t;&t; *  irq is re-requested prior to the interrupt to occur.&n;&t;&t; */
id|cc
op_assign
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cc
op_eq
l_int|3
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.d_disable
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
r_else
singleline_comment|// cc == 0
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.ena
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|cc
op_assign
id|msch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cc
)paren
(brace
r_case
l_int|0
suffix:colon
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* done */
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * very bad, requires interrupt alike&n;  &t;&t;&t;&t;&t; *  processing, where &quot;rbh&quot; is a dummy&n;&t;&t;&t;&t;&t; *  parm for interface compatibility&n;&t;&t;&t;&t;&t; *  only. Bottom-half handling cannot&n;&t;&t;&t;&t;&t; *  be required as this must be an&n;&t;&t;&t;&t;&t; *  unsolicited interrupt (!busy).&n;&t;&t;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|1
suffix:semicolon
id|s390_process_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* might be overwritten  */
multiline_comment|/* ... on re-driving the */
multiline_comment|/* ... msch() call       */
id|retry
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * *** must not occur !              ***&n;&t;&t;&t;&t;&t; * ***                               ***&n;&t;&t;&t;&t;&t; * *** indicates our internal        ***&n;&t;&t;&t;&t;&t; * *** interrupt accounting is out   ***&n;&t;&t;&t;&t;&t; * ***  of sync ===&gt; panic()         ***&n;&t;&t;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;disable_subchannel(%04X) &quot;
l_string|&quot;- unexpected busy condition for &quot;
l_string|&quot;device %04X received !&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
singleline_comment|// never reached
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * should hardly occur ?!&n;&t;&t;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.d_disable
op_assign
l_int|1
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* if the device has gone we */
multiline_comment|/* ... don&squot;t need to disable */
multiline_comment|/* ... it anymore !    */
r_break
suffix:semicolon
r_default
suffix:colon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
singleline_comment|// never reached ...
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
)brace
r_while
c_loop
(paren
(paren
id|cc
op_eq
l_int|1
)paren
op_logical_and
id|retry
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
)brace
DECL|function|s390_setup_irq
r_int
id|s390_setup_irq
c_func
(paren
r_int
r_int
id|irq
comma
r_struct
id|irqaction
op_star
r_new
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * The following block of code has to be executed atomically&n;&t; */
id|s390irq_spin_lock_irqsave
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.action
op_eq
l_int|NULL
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.action
op_assign
r_new
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.status
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.handler-&gt;enable
op_assign
op_amp
id|enable_subchannel
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.handler-&gt;disable
op_assign
op_amp
id|disable_subchannel
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.handler-&gt;handle
op_assign
op_amp
id|handle_IRQ_event
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.handler
op_member_access_from_pointer
id|enable
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; *  interrupt already owned, and shared interrupts&n;&t;&t; *   aren&squot;t supported on S/390.&n;&t;&t; */
id|rc
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* endif */
id|s390irq_spin_unlock_irqrestore
c_func
(paren
id|irq
comma
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|s390_init_IRQ
r_void
id|s390_init_IRQ
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* PSW flags */
r_int
id|cr6
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
singleline_comment|// Hopefully bh_count&squot;s will get set when we copy the prefix lowcore
singleline_comment|// structure to other CPI&squot;s ( DJB )
id|softirq_active
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
op_assign
l_int|0
suffix:semicolon
id|softirq_mask
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
op_assign
l_int|0
suffix:semicolon
id|local_bh_count
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
op_assign
l_int|0
suffix:semicolon
id|local_irq_count
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
op_assign
l_int|0
suffix:semicolon
id|syscall_count
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
op_assign
l_int|0
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;STCK %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|irq_IPL_TOD
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * As we don&squot;t know about the calling environment&n;&t; *  we assure running disabled. Before leaving the&n;&t; *  function we resestablish the old environment.&n;&t; *&n;&t; * Note : as we don&squot;t need a system wide lock, therefore&n;&t; *        we shouldn&squot;t use cli(), but __cli() as this&n;&t; *        affects the current CPU only.&n;&t; */
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * disable all interrupts&n;&t; */
id|cr6
op_assign
l_int|0
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;LCTL 6,6,%0&quot;
op_scope_resolution
l_string|&quot;m&quot;
(paren
id|cr6
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|s390_process_subchannels
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * enable default I/O-interrupt sublass 3&n;&t; */
id|cr6
op_assign
l_int|0x10000000
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;LCTL 6,6,%0&quot;
op_scope_resolution
l_string|&quot;m&quot;
(paren
id|cr6
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|s390_device_recognition
c_func
(paren
)paren
suffix:semicolon
id|init_IRQ_complete
op_assign
l_int|1
suffix:semicolon
id|s390_init_machine_check
c_func
(paren
)paren
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * dummy handler, used during init_IRQ() processing for compatibility only&n; */
DECL|function|init_IRQ_handler
r_void
id|init_IRQ_handler
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/* this is a dummy handler only ... */
)brace
DECL|function|s390_start_IO
r_int
id|s390_start_IO
c_func
(paren
r_int
id|irq
comma
multiline_comment|/* IRQ */
id|ccw1_t
op_star
id|cpa
comma
multiline_comment|/* logical channel prog addr */
r_int
r_int
id|user_intparm
comma
multiline_comment|/* interruption parameter */
id|__u8
id|lpm
comma
multiline_comment|/* logical path mask */
r_int
r_int
id|flag
)paren
multiline_comment|/* flags */
(brace
r_int
id|ccode
suffix:semicolon
r_int
r_int
id|psw_flags
suffix:semicolon
r_int
id|sync_isc_locked
op_assign
l_int|0
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * The flag usage is mutal exclusive ...&n;&t; */
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|DOIO_RETURN_CHAN_END
)paren
op_logical_and
(paren
id|flag
op_amp
id|DOIO_REPORT_ALL
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* endif */
id|memset
c_func
(paren
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb
)paren
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|orb_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * setup ORB&n;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.intparm
op_assign
(paren
id|__u32
)paren
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|u_intparm
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.fmt
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.pfch
op_assign
op_logical_neg
(paren
id|flag
op_amp
id|DOIO_DENY_PREFETCH
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.spnd
op_assign
(paren
id|flag
op_amp
id|DOIO_ALLOW_SUSPEND
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.ssic
op_assign
(paren
(paren
id|flag
op_amp
id|DOIO_ALLOW_SUSPEND
)paren
op_logical_and
(paren
id|flag
op_amp
id|DOIO_SUPPRESS_INTER
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_VALID_LPM
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.lpm
op_assign
id|lpm
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.lpm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
suffix:semicolon
)brace
multiline_comment|/* endif */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.cpa
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
c_func
(paren
id|cpa
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If sync processing was requested we lock the sync ISC, modify the&n;&t; *  device to present interrupts for this ISC only and switch the&n;&t; *  CPU to handle this ISC + the console ISC exclusively.&n;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
(brace
singleline_comment|//
singleline_comment|// check whether we run recursively (sense processing)
singleline_comment|//
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sync_isc
comma
id|psw_flags
)paren
suffix:semicolon
id|ret
op_assign
id|enable_cpu_sync_isc
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sync_isc
comma
id|psw_flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_else
(brace
id|sync_isc_locked
op_assign
l_int|1
suffix:semicolon
singleline_comment|// local
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
op_assign
l_int|1
suffix:semicolon
singleline_comment|// global
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t; * Issue &quot;Start subchannel&quot; and process condition code&n;&t; */
id|ccode
op_assign
id|ssch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4sense
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * init the device driver specific devstat irb area&n;&t;&t;&t; *&n;&t;&t;&t; * Note : don&#xfffd;t clear saved irb info in case of sense !&n;&t;&t;&t; */
id|memset
c_func
(paren
op_amp
(paren
(paren
id|devstat_t
op_star
)paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.action-&gt;dev_id
)paren
op_member_access_from_pointer
id|ii.irb
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|irb_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t; * initialize device status information&n;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|u_intparm
op_assign
id|user_intparm
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.cstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.dstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.lpum
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_assign
id|DEVSTAT_START_FUNCTION
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.scnt
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check for either early (FAST) notification requests&n;&t;&t; *  or if we are to return all interrupt info.&n;&t;&t; * Default is to call IRQ handler at secondary status only&n;&t;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_RETURN_CHAN_END
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_REPORT_ALL
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ulpm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|orb.lpm
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If synchronous I/O processing is requested, we have&n;&t;&t; *  to wait for the corresponding interrupt to occur by&n;&t;&t; *  polling the interrupt condition. However, as multiple&n;&t;&t; *  interrupts may be outstanding, we must not just wait&n;&t;&t; *  for the first interrupt, but must poll until ours&n;&t;&t; *  pops up.&n;&t;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
(brace
singleline_comment|//&t;&t;__u32            io_parm;
id|psw_t
id|io_new_psw
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_int
id|ready
op_assign
l_int|0
suffix:semicolon
r_int
id|io_sub
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|_lowcore
op_star
id|lc
op_assign
l_int|NULL
suffix:semicolon
r_int
id|count
op_assign
l_int|30000
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We shouldn&squot;t perform a TPI loop, waiting for an&n;&t;&t;&t; *  interrupt to occur, but should load a WAIT PSW&n;&t;&t;&t; *  instead. Otherwise we may keep the channel subsystem&n;&t;&t;&t; *  busy, not able to present the interrupt. When our&n;&t;&t;&t; *  sync. interrupt arrived we reset the I/O old PSW to&n;&t;&t;&t; *  its original value.&n;&t;&t;&t; */
id|memcpy
c_func
(paren
op_amp
id|io_new_psw
comma
op_amp
id|lc-&gt;io_new_psw
comma
r_sizeof
(paren
id|psw_t
)paren
)paren
suffix:semicolon
id|ccode
op_assign
id|iac
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
singleline_comment|// primary-space
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_PRIM_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
singleline_comment|// secondary-space
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_SEC_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
singleline_comment|// access-register
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_ACC_REG_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
singleline_comment|// home-space&t;
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_HOME_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;start_IO() : unexpected &quot;
l_string|&quot;address-space-control %d&bslash;n&quot;
comma
id|ccode
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
id|io_sync_wait.addr
op_assign
id|FIX_PSW
c_func
(paren
op_logical_and
id|io_wakeup
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Martin didn&squot;t like modifying the new PSW, now we take&n;&t;&t;&t; *  a fast exit in do_IRQ() instead&n;&t;&t;&t; */
op_star
(paren
id|__u32
op_star
)paren
id|__LC_SYNC_IO_WORD
op_assign
l_int|1
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_TIMEOUT
)paren
(brace
id|tpi_info_t
id|tpi_info
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|tpi
c_func
(paren
op_amp
id|tpi_info
)paren
op_eq
l_int|1
)paren
(brace
id|io_sub
op_assign
id|tpi_info.irq
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|count
op_decrement
suffix:semicolon
id|tod_wait
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* usecs */
)brace
multiline_comment|/* endif */
)brace
r_while
c_loop
(paren
id|count
)paren
suffix:semicolon
)brace
r_else
(brace
id|asm
r_volatile
(paren
l_string|&quot;lpsw %0&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
id|io_sync_wait
)paren
)paren
suffix:semicolon
id|io_wakeup
suffix:colon
id|io_sub
op_assign
(paren
id|__u32
)paren
op_star
(paren
id|__u16
op_star
)paren
id|__LC_SUBCHANNEL_NR
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|count
)paren
id|ready
op_assign
id|s390_process_IRQ
c_func
(paren
id|io_sub
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * surrender when retry count&squot;s exceeded ...&n;&t;&t;&t;&t; */
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|io_sub
op_eq
id|irq
)paren
op_logical_and
(paren
id|ready
op_eq
l_int|1
)paren
)paren
op_logical_and
id|count
)paren
suffix:semicolon
op_star
(paren
id|__u32
op_star
)paren
id|__LC_SYNC_IO_WORD
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
id|ret
op_assign
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
multiline_comment|/* endif */
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* status pending */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_STATUS_PENDING
suffix:semicolon
multiline_comment|/*&n;&t;&t; * initialize the device driver specific devstat irb area&n;&t;&t; */
id|memset
c_func
(paren
op_amp
(paren
(paren
id|devstat_t
op_star
)paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.action-&gt;dev_id
)paren
op_member_access_from_pointer
id|ii.irb
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|irb_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Let the common interrupt handler process the pending status.&n;&t;&t; *  However, we must avoid calling the user action handler, as&n;&t;&t; *  it won&squot;t be prepared to handle a pending status during&n;&t;&t; *  do_IO() processing inline. This also implies that process_IRQ&n;&t;&t; *  must terminate synchronously - especially if device sensing&n;&t;&t; *  is required.&n;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|1
suffix:semicolon
id|s390_process_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_FINAL_STATUS
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In multipath mode a condition code 3 implies the last path&n;&t;&t; *  has gone, except we have previously restricted the I/O to&n;&t;&t; *  a particular path. A condition code 1 (0 won&squot;t occur)&n;&t;&t; *  results in return code EIO as well as 3 with another path&n;&t;&t; *  than the one used (i.e. path available mask is non-zero).&n;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.cc
op_eq
l_int|3
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
macro_line|#if CONFIG_DEBUG_IO
(brace
r_char
id|buffer
(braket
l_int|80
)braket
suffix:semicolon
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;s390_start_IO(%04X) - irb for &quot;
l_string|&quot;device %04X, after status pending&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|s390_displayhex
c_func
(paren
id|buffer
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb
)paren
comma
r_sizeof
(paren
id|irb_t
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;s390_start_IO(%04X) - schib for &quot;
l_string|&quot;device %04X, after status pending&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|s390_displayhex
c_func
(paren
id|buffer
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
comma
r_sizeof
(paren
id|schib_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_amp
id|DEVSTAT_FLAG_SENSE_AVAIL
)paren
(brace
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;s390_start_IO(%04X) - sense &quot;
l_string|&quot;data for &quot;
l_string|&quot;device %04X, after status pending&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|s390_displayhex
c_func
(paren
id|buffer
comma
(paren
(paren
id|devstat_t
op_star
)paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.action-&gt;dev_id
)paren
)paren
op_member_access_from_pointer
id|ii.sense.data
comma
(paren
(paren
id|devstat_t
op_star
)paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.action-&gt;dev_id
)paren
)paren
op_member_access_from_pointer
id|rescnt
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_and_assign
op_complement
id|DEVSTAT_NOT_OPER
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* busy */
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* device not operational */
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
id|memcpy
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.action-&gt;dev_id
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat
)paren
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
macro_line|#if CONFIG_DEBUG_IO
(brace
r_char
id|buffer
(braket
l_int|80
)braket
suffix:semicolon
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;s390_start_IO(%04X) - schib for &quot;
l_string|&quot;device %04X, after &squot;not oper&squot; status&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|s390_displayhex
c_func
(paren
id|buffer
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
comma
r_sizeof
(paren
id|schib_t
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
op_logical_and
(paren
id|sync_isc_locked
)paren
)paren
(brace
id|disable_cpu_sync_isc
c_func
(paren
id|irq
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sync_isc
comma
id|psw_flags
)paren
suffix:semicolon
id|sync_isc_locked
op_assign
l_int|0
suffix:semicolon
singleline_comment|// local setting
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
op_assign
l_int|0
suffix:semicolon
singleline_comment|// global setting
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
)brace
DECL|function|do_IO
r_int
id|do_IO
c_func
(paren
r_int
id|irq
comma
multiline_comment|/* IRQ */
id|ccw1_t
op_star
id|cpa
comma
multiline_comment|/* channel program address */
r_int
r_int
id|user_intparm
comma
multiline_comment|/* interruption parameter */
id|__u8
id|lpm
comma
multiline_comment|/* logical path mask */
r_int
r_int
id|flag
)paren
multiline_comment|/* flags : see above */
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|irq
OG
id|highest_subchannel
op_logical_or
id|irq
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* handler registered ? or free_irq() in process already ? */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
op_logical_or
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unready
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t; * Note: We ignore the device operational status - if not operational,&n;&t; *        the SSCH will lead to an -ENODEV condition ...&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
)paren
multiline_comment|/* last I/O completed ? */
(brace
id|ret
op_assign
id|s390_start_IO
c_func
(paren
id|irq
comma
id|cpa
comma
id|user_intparm
comma
id|lpm
comma
id|flag
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
)paren
(brace
multiline_comment|/*&n;&t;&t; * If primary status was received and ending status is missing,&n;&t;&t; *  the device driver won&squot;t be notified on the ending status&n;&t;&t; *  if early (fast) interrupt notification was requested.&n;&t;&t; *  Therefore we have to queue the next incoming request. If&n;&t;&t; *  halt_IO() is issued while there is a request queued, a HSCH&n;&t;&t; *  needs to be issued and the queued request must be deleted&n;&t;&t; *  but its intparm must be returned (see halt_IO() processing)&n;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_logical_and
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio_q
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qflag
op_assign
id|flag
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qcpa
op_assign
id|cpa
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qintparm
op_assign
id|user_intparm
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qlpm
op_assign
id|lpm
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * resume suspended I/O operation&n; */
DECL|function|resume_IO
r_int
id|resume_IO
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|irq
OG
id|highest_subchannel
op_logical_or
id|irq
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We allow for &squot;resume&squot; requests only for active I/O operations&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
)paren
(brace
r_int
id|ccode
suffix:semicolon
id|ccode
op_assign
id|rsch
c_func
(paren
id|irq
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|s390_process_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * useless to wait for request completion&n;&t;&t;&t; *  as device is no longer operational !&n;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|ENOTCONN
suffix:semicolon
)brace
multiline_comment|/* endif  */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: The &quot;intparm&quot; parameter is not used by the halt_IO() function&n; *       itself, as no ORB is built for the HSCH instruction. However,&n; *       it allows the device interrupt handler to associate the upcoming&n; *       interrupt with the halt_IO() request.&n; */
DECL|function|halt_IO
r_int
id|halt_IO
c_func
(paren
r_int
id|irq
comma
r_int
r_int
id|user_intparm
comma
r_int
r_int
id|flag
)paren
multiline_comment|/* possible DOIO_WAIT_FOR_INTERRUPT */
(brace
r_int
id|ret
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_int
r_int
id|psw_flags
suffix:semicolon
r_int
id|sync_isc_locked
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|irq
OG
id|highest_subchannel
op_logical_or
id|irq
OL
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we only allow for halt_IO if the device has an I/O handler associated&n;&t; */
r_else
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we ignore the halt_io() request if ending_status was received but&n;&t; *  a SENSE operation is waiting for completion.&n;&t; */
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4sense
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We don&squot;t allow for halt_io with a sync do_IO() requests pending.&n;&t; */
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * If sync processing was requested we lock the sync ISC,&n;&t;&t; *  modify the device to present interrupts for this ISC only&n;&t;&t; *  and switch the CPU to handle this ISC + the console ISC&n;&t;&t; *  exclusively.&n;&t;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
(brace
singleline_comment|//
singleline_comment|// check whether we run recursively (sense processing)
singleline_comment|//
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sync_isc
comma
id|psw_flags
)paren
suffix:semicolon
id|ret
op_assign
id|enable_cpu_sync_isc
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sync_isc
comma
id|psw_flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_else
(brace
id|sync_isc_locked
op_assign
l_int|1
suffix:semicolon
singleline_comment|// local
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
op_assign
l_int|1
suffix:semicolon
singleline_comment|// global
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t; * Issue &quot;Halt subchannel&quot; and process condition code&n;&t;&t; */
id|ccode
op_assign
id|hsch
c_func
(paren
id|irq
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.haltio
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|u_intparm
op_assign
id|user_intparm
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.cstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.dstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.lpum
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_assign
id|DEVSTAT_HALT_FUNCTION
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.scnt
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_HALT_FUNCTION
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t;&t; * If synchronous I/O processing is requested, we have&n;&t;&t;&t; *  to wait for the corresponding interrupt to occur by&n;&t;&t;&t; *  polling the interrupt condition. However, as multiple&n;&t;&t;&t; *  interrupts may be outstanding, we must not just wait&n;&t;&t;&t; *  for the first interrupt, but must poll until ours&n;&t;&t;&t; *  pops up.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
(brace
r_int
id|io_sub
suffix:semicolon
id|__u32
id|io_parm
suffix:semicolon
id|psw_t
id|io_new_psw
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_int
id|ready
op_assign
l_int|0
suffix:semicolon
r_struct
id|_lowcore
op_star
id|lc
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * We shouldn&squot;t perform a TPI loop, waiting for&n;&t;&t;&t;&t; *  an interrupt to occur, but should load a&n;&t;&t;&t;&t; *  WAIT PSW instead. Otherwise we may keep the&n;&t;&t;&t;&t; *  channel subsystem busy, not able to present&n;&t;&t;&t;&t; *  the interrupt. When our sync. interrupt&n;&t;&t;&t;&t; *  arrived we reset the I/O old PSW to its&n;&t;&t;&t;&t; *  original value.&n;&t;&t;&t;&t; */
id|memcpy
c_func
(paren
op_amp
id|io_new_psw
comma
op_amp
id|lc-&gt;io_new_psw
comma
r_sizeof
(paren
id|psw_t
)paren
)paren
suffix:semicolon
id|ccode
op_assign
id|iac
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
singleline_comment|// primary-space
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_PRIM_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
singleline_comment|// secondary-space
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_SEC_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
singleline_comment|// access-register
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_ACC_REG_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
singleline_comment|// home-space&t;
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_HOME_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;halt_IO() : unexpected &quot;
l_string|&quot;address-space-control %d&bslash;n&quot;
comma
id|ccode
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
id|io_sync_wait.addr
op_assign
id|FIX_PSW
c_func
(paren
op_logical_and
id|hio_wakeup
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Martin didn&squot;t like modifying the new PSW, now we take&n;&t;&t;&t;&t; *  a fast exit in do_IRQ() instead&n;&t;&t;&t;&t; */
op_star
(paren
id|__u32
op_star
)paren
id|__LC_SYNC_IO_WORD
op_assign
l_int|1
suffix:semicolon
r_do
(brace
id|asm
r_volatile
(paren
l_string|&quot;lpsw %0&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
id|io_sync_wait
)paren
)paren
suffix:semicolon
id|hio_wakeup
suffix:colon
id|io_parm
op_assign
op_star
(paren
id|__u32
op_star
)paren
id|__LC_IO_INT_PARM
suffix:semicolon
id|io_sub
op_assign
(paren
id|__u32
)paren
op_star
(paren
id|__u16
op_star
)paren
id|__LC_SUBCHANNEL_NR
suffix:semicolon
id|ready
op_assign
id|s390_process_IRQ
c_func
(paren
id|io_sub
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|io_sub
op_eq
id|irq
)paren
op_logical_and
(paren
id|ready
op_eq
l_int|1
)paren
)paren
)paren
suffix:semicolon
op_star
(paren
id|__u32
op_star
)paren
id|__LC_SYNC_IO_WORD
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* status pending */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_STATUS_PENDING
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * initialize the device driver specific devstat irb area&n;&t;&t;&t; */
id|memset
c_func
(paren
op_amp
(paren
(paren
id|devstat_t
op_star
)paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.action-&gt;dev_id
)paren
op_member_access_from_pointer
id|ii.irb
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|irb_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Let the common interrupt handler process the pending&n;&t;&t;&t; *  status. However, we must avoid calling the user&n;&t;&t;&t; *  action handler, as it won&squot;t be prepared to handle&n;                        *  a pending status during do_IO() processing inline.&n;&t;&t;&t; *  This also implies that s390_process_IRQ must&n;&t;&t;&t; *  terminate synchronously - especially if device&n;&t;&t;&t; *  sensing is required.&n;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|1
suffix:semicolon
id|s390_process_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_FINAL_STATUS
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * In multipath mode a condition code 3 implies the last&n;&t;&t;&t; *  path has gone, except we have previously restricted&n;&t;&t;&t; *  the I/O to a particular path. A condition code 1&n;&t;&t;&t; *  (0 won&squot;t occur) results in return code EIO as well&n;&t;&t;&t; *  as 3 with another path than the one used (i.e. path available mask is non-zero).&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.cc
op_eq
l_int|3
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_and_assign
op_complement
id|DEVSTAT_NOT_OPER
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* busy */
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* device not operational */
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
op_logical_and
(paren
id|sync_isc_locked
)paren
)paren
(brace
id|sync_isc_locked
op_assign
l_int|0
suffix:semicolon
singleline_comment|// local setting
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
op_assign
l_int|0
suffix:semicolon
singleline_comment|// global setting
id|disable_cpu_sync_isc
c_func
(paren
id|irq
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sync_isc
comma
id|psw_flags
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Note: The &quot;intparm&quot; parameter is not used by the clear_IO() function&n; *       itself, as no ORB is built for the CSCH instruction. However,&n; *       it allows the device interrupt handler to associate the upcoming&n; *       interrupt with the clear_IO() request.&n; */
DECL|function|clear_IO
r_int
id|clear_IO
c_func
(paren
r_int
id|irq
comma
r_int
r_int
id|user_intparm
comma
r_int
r_int
id|flag
)paren
multiline_comment|/* possible DOIO_WAIT_FOR_INTERRUPT */
(brace
r_int
id|ret
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_int
r_int
id|psw_flags
suffix:semicolon
r_int
id|sync_isc_locked
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|irq
OG
id|highest_subchannel
op_logical_or
id|irq
OL
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we only allow for halt_IO if the device has an I/O handler associated&n;&t; */
r_else
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * we ignore the halt_io() request if ending_status was received but&n;&t; *  a SENSE operation is waiting for completion.&n;&t; */
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4sense
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We don&squot;t allow for halt_io with a sync do_IO() requests pending.&n;&t; *  Concurrent I/O is possible in SMP environments only, but the&n;&t; *  sync. I/O request can be gated to one CPU at a time only.&n;&t; */
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * If sync processing was requested we lock the sync ISC,&n;&t;&t; *  modify the device to present interrupts for this ISC only&n;&t;&t; *  and switch the CPU to handle this ISC + the console ISC&n;&t;&t; *  exclusively.&n;&t;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
(brace
singleline_comment|//
singleline_comment|// check whether we run recursively (sense processing)
singleline_comment|//
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|sync_isc
comma
id|psw_flags
)paren
suffix:semicolon
id|ret
op_assign
id|enable_cpu_sync_isc
c_func
(paren
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sync_isc
comma
id|psw_flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_else
(brace
id|sync_isc_locked
op_assign
l_int|1
suffix:semicolon
singleline_comment|// local
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
op_assign
l_int|1
suffix:semicolon
singleline_comment|// global
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t; * Issue &quot;Halt subchannel&quot; and process condition code&n;&t;&t; */
id|ccode
op_assign
id|csch
c_func
(paren
id|irq
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.haltio
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|u_intparm
op_assign
id|user_intparm
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.cstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.dstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.lpum
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_assign
id|DEVSTAT_CLEAR_FUNCTION
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.scnt
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_CLEAR_FUNCTION
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t;&t; * If synchronous I/O processing is requested, we have&n;&t;&t;&t; *  to wait for the corresponding interrupt to occur by&n;&t;&t;&t; *  polling the interrupt condition. However, as multiple&n;&t;&t;&t; *  interrupts may be outstanding, we must not just wait&n;&t;&t;&t; *  for the first interrupt, but must poll until ours&n;&t;&t;&t; *  pops up.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
(brace
r_int
id|io_sub
suffix:semicolon
id|__u32
id|io_parm
suffix:semicolon
id|psw_t
id|io_new_psw
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_int
id|ready
op_assign
l_int|0
suffix:semicolon
r_struct
id|_lowcore
op_star
id|lc
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * We shouldn&squot;t perform a TPI loop, waiting for&n;&t;&t;&t;&t; *  an interrupt to occur, but should load a&n;&t;&t;&t;&t; *  WAIT PSW instead. Otherwise we may keep the&n;&t;&t;&t;&t; *  channel subsystem busy, not able to present&n;&t;&t;&t;&t; *  the interrupt. When our sync. interrupt&n;&t;&t;&t;&t; *  arrived we reset the I/O old PSW to its&n;&t;&t;&t;&t; *  original value.&n;&t;&t;&t;&t; */
id|memcpy
c_func
(paren
op_amp
id|io_new_psw
comma
op_amp
id|lc-&gt;io_new_psw
comma
r_sizeof
(paren
id|psw_t
)paren
)paren
suffix:semicolon
id|ccode
op_assign
id|iac
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode
)paren
(brace
r_case
l_int|0
suffix:colon
singleline_comment|// primary-space
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_PRIM_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
singleline_comment|// secondary-space
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_SEC_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
singleline_comment|// access-register
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_ACC_REG_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
singleline_comment|// home-space&t;
id|io_sync_wait.mask
op_assign
id|_IO_PSW_MASK
op_or
id|_PSW_HOME_SPACE_MODE
op_or
id|_PSW_IO_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;halt_IO() : unexpected &quot;
l_string|&quot;address-space-control %d&bslash;n&quot;
comma
id|ccode
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
id|io_sync_wait.addr
op_assign
id|FIX_PSW
c_func
(paren
op_logical_and
id|cio_wakeup
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Martin didn&squot;t like modifying the new PSW, now we take&n;&t;&t;&t;&t; *  a fast exit in do_IRQ() instead&n;&t;&t;&t;&t; */
op_star
(paren
id|__u32
op_star
)paren
id|__LC_SYNC_IO_WORD
op_assign
l_int|1
suffix:semicolon
r_do
(brace
id|asm
r_volatile
(paren
l_string|&quot;lpsw %0&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
id|io_sync_wait
)paren
)paren
suffix:semicolon
id|cio_wakeup
suffix:colon
id|io_parm
op_assign
op_star
(paren
id|__u32
op_star
)paren
id|__LC_IO_INT_PARM
suffix:semicolon
id|io_sub
op_assign
(paren
id|__u32
)paren
op_star
(paren
id|__u16
op_star
)paren
id|__LC_SUBCHANNEL_NR
suffix:semicolon
id|ready
op_assign
id|s390_process_IRQ
c_func
(paren
id|io_sub
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
(paren
id|io_sub
op_eq
id|irq
)paren
op_logical_and
(paren
id|ready
op_eq
l_int|1
)paren
)paren
)paren
suffix:semicolon
op_star
(paren
id|__u32
op_star
)paren
id|__LC_SYNC_IO_WORD
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
id|ret
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* status pending */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_STATUS_PENDING
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * initialize the device driver specific devstat irb area&n;&t;&t;&t; */
id|memset
c_func
(paren
op_amp
(paren
(paren
id|devstat_t
op_star
)paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.action-&gt;dev_id
)paren
op_member_access_from_pointer
id|ii.irb
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|irb_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Let the common interrupt handler process the pending&n;&t;&t;&t; *  status. However, we must avoid calling the user&n;&t;&t;&t; *  action handler, as it won&squot;t be prepared to handle&n;                        *  a pending status during do_IO() processing inline.&n;&t;&t;&t; *  This also implies that s390_process_IRQ must&n;&t;&t;&t; *  terminate synchronously - especially if device&n;&t;&t;&t; *  sensing is required.&n;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|1
suffix:semicolon
id|s390_process_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_FINAL_STATUS
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * In multipath mode a condition code 3 implies the last&n;&t;&t;&t; *  path has gone, except we have previously restricted&n;&t;&t;&t; *  the I/O to a particular path. A condition code 1&n;&t;&t;&t; *  (0 won&squot;t occur) results in return code EIO as well&n;&t;&t;&t; *  as 3 with another path than the one used (i.e. path available mask is non-zero).&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.cc
op_eq
l_int|3
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_and_assign
op_complement
id|DEVSTAT_NOT_OPER
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* busy */
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* device not operational */
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_if
c_cond
(paren
(paren
id|flag
op_amp
id|DOIO_WAIT_FOR_INTERRUPT
)paren
op_logical_and
(paren
id|sync_isc_locked
)paren
)paren
(brace
id|sync_isc_locked
op_assign
l_int|0
suffix:semicolon
singleline_comment|// local setting
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
op_assign
l_int|0
suffix:semicolon
singleline_comment|// global setting
id|disable_cpu_sync_isc
c_func
(paren
id|irq
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|sync_isc
comma
id|psw_flags
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * do_IRQ() handles all normal I/O device IRQ&squot;s (the special&n; *          SMP cross-CPU interrupts have their own specific&n; *          handlers).&n; *&n; * Returns: 0 - no ending status received, no further action taken&n; *          1 - interrupt handler was called with ending status&n; */
DECL|function|do_IRQ
id|asmlinkage
r_void
id|do_IRQ
c_func
(paren
r_struct
id|pt_regs
id|regs
comma
r_int
r_int
id|irq
comma
id|__u32
id|s390_intparm
)paren
(brace
macro_line|#ifdef CONFIG_FAST_IRQ
r_int
id|ccode
suffix:semicolon
id|tpi_info_t
id|tpi_info
suffix:semicolon
r_int
id|new_irq
suffix:semicolon
macro_line|#endif
r_int
id|use_irq
op_assign
id|irq
suffix:semicolon
singleline_comment|//&t;__u32       use_intparm = s390_intparm;
singleline_comment|//
singleline_comment|// fix me !!!
singleline_comment|//
singleline_comment|// We need to schedule device recognition, the interrupt stays
singleline_comment|//  pending. We need to dynamically allocate an ioinfo structure.
singleline_comment|//
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_return
suffix:semicolon
multiline_comment|/* this keeps the device boxed ... */
)brace
multiline_comment|/*&n;&t; * take fast exit if CPU is in sync. I/O state&n;&t; *&n;&t; * Note: we have to turn off the WAIT bit and re-disable&n;&t; *       interrupts prior to return as this was the initial&n;&t; *       entry condition to synchronous I/O.&n;&t; */
r_if
c_cond
(paren
op_star
(paren
id|__u32
op_star
)paren
id|__LC_SYNC_IO_WORD
)paren
(brace
id|regs.psw.mask
op_and_assign
op_complement
(paren
id|_PSW_WAIT_MASK_BIT
op_or
id|_PSW_IO_MASK_BIT
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* endif */
id|s390irq_spin_lock
c_func
(paren
id|use_irq
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_FAST_IRQ
r_do
(brace
macro_line|#endif /*  CONFIG_FAST_IRQ */
id|s390_process_IRQ
c_func
(paren
id|use_irq
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_FAST_IRQ
multiline_comment|/*&n;&t;&t; * more interrupts pending ?&n;&t;&t; */
id|ccode
op_assign
id|tpi
c_func
(paren
op_amp
id|tpi_info
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ccode
)paren
r_break
suffix:semicolon
singleline_comment|// no, leave ...
id|new_irq
op_assign
id|tpi_info.irq
suffix:semicolon
singleline_comment|//&t;&t;use_intparm = tpi_info.intparm;
multiline_comment|/*&n;&t;&t; * if the interrupt is for a different irq we&n;&t;&t; *  release the current irq lock and obtain&n;&t;&t; *  a new one ...&n;&t;&t; */
r_if
c_cond
(paren
id|new_irq
op_ne
id|use_irq
)paren
(brace
id|s390irq_spin_unlock
c_func
(paren
id|use_irq
)paren
suffix:semicolon
id|use_irq
op_assign
id|new_irq
suffix:semicolon
id|s390irq_spin_lock
c_func
(paren
id|use_irq
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
macro_line|#endif /*  CONFIG_FAST_IRQ */
id|s390irq_spin_unlock
c_func
(paren
id|use_irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_process_IRQ() handles status pending situations and interrupts&n; *&n; * Called by : do_IRQ()             - for &quot;real&quot; interrupts&n; *             s390_start_IO, halt_IO()&n; *                                  - status pending cond. after SSCH, or HSCH&n; *             disable_subchannel() - status pending conditions (after MSCH)&n; *&n; * Returns: 0 - no ending status received, no further action taken&n; *          1 - interrupt handler was called with ending status&n; */
DECL|function|s390_process_IRQ
r_int
id|s390_process_IRQ
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_int
id|ccode
suffix:semicolon
multiline_comment|/* condition code from tsch() operation */
r_int
id|irb_cc
suffix:semicolon
multiline_comment|/* condition code from irb */
r_int
id|sdevstat
suffix:semicolon
multiline_comment|/* effective struct devstat size to copy */
r_int
r_int
id|fctl
suffix:semicolon
multiline_comment|/* function control */
r_int
r_int
id|stctl
suffix:semicolon
multiline_comment|/* status   control */
r_int
r_int
id|actl
suffix:semicolon
multiline_comment|/* activity control */
r_struct
id|irqaction
op_star
id|action
suffix:semicolon
r_struct
id|pt_regs
id|regs
suffix:semicolon
multiline_comment|/* for interface compatibility only */
r_int
id|issense
op_assign
l_int|0
suffix:semicolon
r_int
id|ending_status
op_assign
l_int|0
suffix:semicolon
r_int
id|allow4handler
op_assign
l_int|1
suffix:semicolon
r_int
id|chnchk
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|kstat.irqs
(braket
id|cpu
)braket
(braket
id|irq
)braket
op_increment
suffix:semicolon
macro_line|#endif
id|action
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.action
suffix:semicolon
multiline_comment|/*&n;&t; * It might be possible that a device was not-oper. at the time&n;&t; *  of free_irq() processing. This means the handler is no longer&n;&t; *  available when the device possibly becomes ready again. In&n;&t; *  this case we perform delayed disable_subchannel() processing.&n;&t; */
r_if
c_cond
(paren
id|action
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.d_disable
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;s390_process_IRQ(%04X) &quot;
l_string|&quot;- no interrupt handler registered&quot;
l_string|&quot;for device %04X !&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t; * retrieve the i/o interrupt information (irb),&n;&t; *  update the device specific status information&n;&t; *  and possibly call the interrupt handler.&n;&t; *&n;&t; * Note 1: At this time we don&squot;t process the resulting&n;&t; *         condition code (ccode) from tsch(), although&n;&t; *         we probably should.&n;&t; *&n;&t; * Note 2: Here we will have to check for channel&n;&t; *         check conditions and call a channel check&n;&t; *         handler.&n;&t; *&n;&t; * Note 3: If a start function was issued, the interruption&n;&t; *         parameter relates to it. If a halt function was&n;&t; *         issued for an idle device, the intparm must not&n;&t; *         be taken from lowcore, but from the devstat area.&n;&t; */
id|ccode
op_assign
id|tsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb
)paren
)paren
suffix:semicolon
singleline_comment|//
singleline_comment|// We must only accumulate the status if initiated by do_IO() or halt_IO()
singleline_comment|//
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.dstat
op_or_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.dstat
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.cstat
op_or_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.cstat
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.dstat
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.dstat
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.cstat
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.cstat
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_assign
l_int|0
suffix:semicolon
singleline_comment|// reset status flags
)brace
multiline_comment|/* endif */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.lpum
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.esw.esw1.lpum
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.intparm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|u_intparm
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t; * reset device-busy bit if no longer set in irb&n;&t; */
r_if
c_cond
(paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.dstat
op_amp
id|DEV_STAT_BUSY
)paren
op_logical_and
(paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.dstat
op_amp
id|DEV_STAT_BUSY
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.dstat
op_and_assign
op_complement
id|DEV_STAT_BUSY
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t; * Save residual count and CCW information in case primary and&n;&t; *  secondary status are presented with different interrupts.&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.stctl
op_amp
id|SCSW_STCTL_PRIM_STATUS
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.rescnt
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.count
suffix:semicolon
macro_line|#if CONFIG_DEBUG_IO
r_if
c_cond
(paren
id|irq
op_ne
id|cons_dev
)paren
id|printk
c_func
(paren
l_string|&quot;s390_process_IRQ( %04X ) : &quot;
l_string|&quot;residual count from irb after tsch() %d&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.rescnt
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.cpa
op_ne
l_int|0
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.cpa
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.cpa
suffix:semicolon
)brace
multiline_comment|/* endif */
id|irb_cc
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.cc
suffix:semicolon
singleline_comment|//
singleline_comment|// check for any kind of channel or interface control check but don&squot;t
singleline_comment|//  issue the message for the console device
singleline_comment|//
r_if
c_cond
(paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.cstat
op_amp
(paren
id|SCHN_STAT_CHN_DATA_CHK
op_or
id|SCHN_STAT_CHN_CTRL_CHK
op_or
id|SCHN_STAT_INTF_CTRL_CHK
)paren
)paren
op_logical_and
(paren
id|irq
op_ne
id|cons_dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Channel-Check or Interface-Control-Check &quot;
l_string|&quot;received&bslash;n&quot;
l_string|&quot; ... device %04X on subchannel %04X, dev_stat &quot;
l_string|&quot;: %02X sch_stat : %02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.dstat
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.cstat
)paren
suffix:semicolon
id|chnchk
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
id|issense
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.esw.esw0.erw.cons
suffix:semicolon
r_if
c_cond
(paren
id|issense
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.scnt
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.esw.esw0.erw.scnt
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_FLAG_SENSE_AVAIL
suffix:semicolon
id|sdevstat
op_assign
r_sizeof
(paren
id|devstat_t
)paren
suffix:semicolon
macro_line|#if CONFIG_DEBUG_IO
r_if
c_cond
(paren
id|irq
op_ne
id|cons_dev
)paren
id|printk
c_func
(paren
l_string|&quot;s390_process_IRQ( %04X ) : &quot;
l_string|&quot;concurrent sense bytes avail %d&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.scnt
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* don&squot;t copy the sense data area ! */
id|sdevstat
op_assign
r_sizeof
(paren
id|devstat_t
)paren
op_minus
id|SENSE_MAX_COUNT
suffix:semicolon
)brace
multiline_comment|/* endif */
r_switch
c_cond
(paren
id|irb_cc
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* status pending */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_STATUS_PENDING
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* normal i/o interruption */
id|fctl
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.fctl
suffix:semicolon
id|stctl
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.stctl
suffix:semicolon
id|actl
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.actl
suffix:semicolon
r_if
c_cond
(paren
id|chnchk
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.cu_type
op_eq
l_int|0x3088
)paren
)paren
(brace
r_char
id|buffer
(braket
l_int|80
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;s390_process_IRQ(%04X) - irb for &quot;
l_string|&quot;device %04X after channel check&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
)paren
suffix:semicolon
id|s390_displayhex
c_func
(paren
id|buffer
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb
)paren
comma
r_sizeof
(paren
id|irb_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|stctl
op_or_assign
id|stctl
suffix:semicolon
id|ending_status
op_assign
(paren
id|stctl
op_amp
id|SCSW_STCTL_SEC_STATUS
)paren
op_logical_or
(paren
id|stctl
op_eq
(paren
id|SCSW_STCTL_ALERT_STATUS
op_or
id|SCSW_STCTL_STATUS_PEND
)paren
)paren
op_logical_or
(paren
(paren
id|fctl
op_eq
id|SCSW_FCTL_HALT_FUNC
)paren
op_logical_and
(paren
id|stctl
op_eq
id|SCSW_STCTL_STATUS_PEND
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check for unsolicited interrupts - for debug purposes only&n;&t;&t; *&n;&t;&t; * We only consider an interrupt as unsolicited, if the device was not&n;&t;&t; *  actively in use (busy) and an interrupt other than an ALERT status&n;&t;&t; *  was received.&n;&t;&t; *&n;&t;&t; * Note: We must not issue a message to the console, if the&n;&t;&t; *       unsolicited interrupt applies to the console device&n;&t;&t; *       itself !&n;&t;&t; */
macro_line|#if CONFIG_DEBUG_IO
r_if
c_cond
(paren
(paren
id|irq
op_ne
id|cons_dev
)paren
op_logical_and
op_logical_neg
(paren
id|stctl
op_amp
id|SCSW_STCTL_ALERT_STATUS
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_eq
l_int|0
)paren
)paren
(brace
r_char
id|buffer
(braket
l_int|80
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Unsolicited interrupt received for device %04X on subchannel %04X&bslash;n&quot;
l_string|&quot; ... device status : %02X subchannel status : %02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.dstat
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.cstat
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;s390_process_IRQ(%04X) - irb for &quot;
l_string|&quot;device %04X, ending_status %d&bslash;n&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
comma
id|ending_status
)paren
suffix:semicolon
id|s390_displayhex
c_func
(paren
id|buffer
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb
)paren
comma
r_sizeof
(paren
id|irb_t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t; * take fast exit if no handler is available&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|action
)paren
r_return
id|ending_status
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Check whether we must issue a SENSE CCW ourselves if there is no&n;&t;&t; *  concurrent sense facility installed for the subchannel.&n;&t;&t; *&n;&t;&t; * Note: We should check for ioinfo[irq]-&gt;ui.flags.consns but VM&n;&t;&t; *       violates the ESA/390 architecture and doesn&squot;t present an&n;&t;&t; *       operand exception for virtual devices without concurrent&n;&t;&t; *       sense facility available/supported when enabling the&n;       *       concurrent sense facility.&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.dstat
op_amp
id|DEV_STAT_UNIT_CHECK
)paren
op_logical_and
(paren
op_logical_neg
id|issense
)paren
)paren
op_logical_or
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.delsense
op_logical_and
id|ending_status
)paren
)paren
(brace
r_int
id|ret_io
suffix:semicolon
id|ccw1_t
op_star
id|s_ccw
op_assign
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseccw
suffix:semicolon
r_int
r_int
id|s_flag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ending_status
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * We copy the current status information into the device driver&n;&t;&t;&t;&t; *  status area. Then we can use the local devstat area for device&n;&t;&t;&t;&t; *  sensing. When finally calling the IRQ handler we must not overlay&n;&t;&t;&t;&t; *  the original device status but copy the sense data only.&n;&t;&t;&t;&t; */
id|memcpy
c_func
(paren
id|action-&gt;dev_id
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat
)paren
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
id|s_ccw-&gt;cmd_code
op_assign
id|CCW_CMD_BASIC_SENSE
suffix:semicolon
id|s_ccw-&gt;cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.sense.data
)paren
suffix:semicolon
id|s_ccw-&gt;count
op_assign
id|SENSE_MAX_COUNT
suffix:semicolon
id|s_ccw-&gt;flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * If free_irq() or a sync do_IO/s390_start_IO() is in&n;&t;&t;&t;&t; *  process we have to sense synchronously&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unready
op_logical_or
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.syncio
)paren
(brace
id|s_flag
op_assign
id|DOIO_WAIT_FOR_INTERRUPT
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t;&t;&t; * Reset status info&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * It does not matter whether this is a sync. or async.&n;&t;&t;&t;&t; *  SENSE request, but we have to assure we don&squot;t call&n;&t;&t;&t;&t; *  the irq handler now, but keep the irq in busy state.&n;&t;&t;&t;&t; *  In sync. mode s390_process_IRQ() is called recursively,&n;&t;&t;&t;&t; *  while in async. mode we re-enter do_IRQ() with the&n;&t;&t;&t;&t; *  next interrupt.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * Note : this may be a delayed sense request !&n;&t;&t;&t;&t; */
id|allow4handler
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.delsense
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.cstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.dstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.rescnt
op_assign
id|SENSE_MAX_COUNT
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4sense
op_assign
l_int|1
suffix:semicolon
id|ret_io
op_assign
id|s390_start_IO
c_func
(paren
id|irq
comma
id|s_ccw
comma
l_int|0xE2C5D5E2
comma
singleline_comment|// = SENSe
l_int|0
comma
singleline_comment|// n/a
id|s_flag
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * we received an Unit Check but we have no final&n;&t;&t;&t;&t; *  status yet, therefore we must delay the SENSE&n;&t;&t;&t;&t; *  processing. However, we must not report this&n;&t;&t;&t;&t; *  intermediate status to the device interrupt&n;&t;&t;&t;&t; *  handler.&n;&t;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.delsense
op_assign
l_int|1
suffix:semicolon
id|allow4handler
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t; * we allow for the device action handler if .&n;&t;&t; *  - we received ending status&n;&t;&t; *  - the action handler requested to see all interrupts&n;&t;&t; *  - we received a PCI&n;&t;&t; *  - fast notification was requested (primary status)&n;&t;&t; *  - unsollicited interrupts&n;&t;&t; *&n;&t;&t; */
r_if
c_cond
(paren
id|allow4handler
)paren
(brace
id|allow4handler
op_assign
id|ending_status
op_logical_or
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
)paren
op_logical_or
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb.scsw.cstat
op_amp
id|SCHN_STAT_PCI
)paren
op_logical_or
(paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
)paren
op_logical_and
(paren
id|stctl
op_amp
id|SCSW_STCTL_PRIM_STATUS
)paren
)paren
op_logical_or
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t; * We used to copy the device status information right before&n;&t;&t; *  calling the device action handler. However, in status&n;&t;&t; *  pending situations during do_IO() or halt_IO(), as well as&n;&t;&t; *  enable_subchannel/disable_subchannel processing we must&n;&t;&t; *  synchronously return the status information and must not&n;&t;&t; *  call the device action handler.&n;&t;&t; *&n;&t;&t; */
r_if
c_cond
(paren
id|allow4handler
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * if we were waiting for sense data we copy the sense&n;&t;&t;&t; *  bytes only as the original status information was&n;&t;&t;&t; *  saved prior to sense already.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4sense
)paren
(brace
r_int
id|sense_count
op_assign
id|SENSE_MAX_COUNT
op_minus
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.rescnt
suffix:semicolon
macro_line|#if CONFIG_DEBUG_IO
r_if
c_cond
(paren
id|irq
op_ne
id|cons_dev
)paren
id|printk
c_func
(paren
l_string|&quot;s390_process_IRQ( %04X ) : &quot;
l_string|&quot;BASIC SENSE bytes avail %d&bslash;n&quot;
comma
id|irq
comma
id|sense_count
)paren
suffix:semicolon
macro_line|#endif
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4sense
op_assign
l_int|0
suffix:semicolon
(paren
(paren
id|devstat_t
op_star
)paren
(paren
id|action-&gt;dev_id
)paren
)paren
op_member_access_from_pointer
id|flag
op_or_assign
id|DEVSTAT_FLAG_SENSE_AVAIL
suffix:semicolon
(paren
(paren
id|devstat_t
op_star
)paren
(paren
id|action-&gt;dev_id
)paren
)paren
op_member_access_from_pointer
id|scnt
op_assign
id|sense_count
suffix:semicolon
r_if
c_cond
(paren
id|sense_count
op_ge
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
(paren
(paren
id|devstat_t
op_star
)paren
(paren
id|action-&gt;dev_id
)paren
)paren
op_member_access_from_pointer
id|ii.sense.data
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.sense.data
)paren
comma
id|sense_count
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if 1
id|panic
c_func
(paren
l_string|&quot;s390_process_IRQ(%04x) encountered &quot;
l_string|&quot;negative sense count&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;s390_process_IRQ(%04x) encountered &quot;
l_string|&quot;negative sense count&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|action-&gt;dev_id
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat
)paren
comma
id|sdevstat
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t; * for status pending situations other than deferred interrupt&n;&t;&t; *  conditions detected by s390_process_IRQ() itself we must not&n;&t;&t; *  call the handler. This will synchronously be reported back&n;&t;&t; *  to the caller instead, e.g. when detected during do_IO().&n;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_logical_or
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.unready
)paren
id|allow4handler
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Call device action handler if applicable&n;&t;&t; */
r_if
c_cond
(paren
id|allow4handler
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  We only reset the busy condition when we are sure that no further&n;&t;&t;&t; *   interrupt is pending for the current I/O request (ending_status).&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ending_status
op_logical_or
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* dev IS oper */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.haltio
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_FINAL_STATUS
suffix:semicolon
(paren
(paren
id|devstat_t
op_star
)paren
(paren
id|action-&gt;dev_id
)paren
)paren
op_member_access_from_pointer
id|flag
op_or_assign
id|DEVSTAT_FINAL_STATUS
suffix:semicolon
id|action
op_member_access_from_pointer
id|handler
c_func
(paren
id|irq
comma
id|action-&gt;dev_id
comma
op_amp
id|regs
)paren
suffix:semicolon
singleline_comment|//
singleline_comment|// reset intparm after final status or we will badly present unsolicited
singleline_comment|//  interrupts with a intparm value possibly no longer valid.
singleline_comment|//
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.intparm
op_assign
l_int|0
suffix:semicolon
singleline_comment|//
singleline_comment|// Was there anything queued ? Start the pending channel program
singleline_comment|//  if there is one.
singleline_comment|//
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio_q
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
id|s390_start_IO
c_func
(paren
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qcpa
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qintparm
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qlpm
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qflag
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio_q
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * If s390_start_IO() failed call the device&squot;s interrupt&n;&t;&t;&t;&t;&t; *  handler, the IRQ related devstat area was setup by&n;&t;&t;&t;&t;&t; *  s390_start_IO() accordingly already (status pending&n;&t;&t;&t;&t;&t; *  condition).&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ret
)paren
(brace
id|action
op_member_access_from_pointer
id|handler
c_func
(paren
id|irq
comma
id|action-&gt;dev_id
comma
op_amp
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_assign
l_int|1
suffix:semicolon
id|action
op_member_access_from_pointer
id|handler
c_func
(paren
id|irq
comma
id|action-&gt;dev_id
comma
op_amp
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* device not operational */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.haltio
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.cstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.dstat
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_FINAL_STATUS
suffix:semicolon
multiline_comment|/*&n;&t;&t; * When we find a device &quot;not oper&quot; we save the status&n;&t;&t; *  information into the device status area and call the&n;&t;&t; *  device specific interrupt handler.&n;&t;&t; *&n;&t;&t; * Note: currently we don&squot;t have any way to reenable&n;&t;&t; *       the device unless an unsolicited interrupt&n;&t;&t; *       is presented. We don&squot;t check for spurious&n;&t;&t; *       interrupts on &quot;not oper&quot; conditions.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * If a new request was queued already, we have&n;&t;&t;&t; *  to simulate the &quot;not oper&quot; status for the&n;&t;&t;&t; *  queued request by switching the &quot;intparm&quot; value&n;&t;&t;&t; *  and notify the interrupt handler.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.doio_q
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.intparm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|qintparm
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.fast
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.repall
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.w4final
op_assign
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
id|action-&gt;dev_id
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat
)paren
comma
id|sdevstat
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.intparm
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
)paren
id|action
op_member_access_from_pointer
id|handler
c_func
(paren
id|irq
comma
id|action-&gt;dev_id
comma
op_amp
id|regs
)paren
suffix:semicolon
id|ending_status
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_return
id|ending_status
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the special i/o-interruption sublass 7 for the&n; *  device specified by parameter irq. There can only&n; *  be a single device been operated on this special&n; *  isc. This function is aimed being able to check&n; *  on special device interrupts in disabled state,&n; *  without having to delay I/O processing (by queueing)&n; *  for non-console devices.&n; *&n; * Setting of this isc is done by set_cons_dev(), while&n; *  reset_cons_dev() resets this isc and re-enables the&n; *  default isc3 for this device. wait_cons_dev() allows&n; *  to actively wait on an interrupt for this device in&n; *  disabed state. When the interrupt condition is&n; *  encountered, wait_cons_dev(9 calls do_IRQ() to have&n; *  the console device driver processing the interrupt.&n; */
DECL|function|set_cons_dev
r_int
id|set_cons_dev
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|ccode
suffix:semicolon
r_int
r_int
id|cr6
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cons_dev
op_ne
op_minus
l_int|1
)paren
(brace
id|rc
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|irq
OG
id|highest_subchannel
)paren
op_logical_or
(paren
id|irq
OL
l_int|0
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * modify the indicated console device to operate&n;&t;&t; *  on special console interrupt sublass 7&n;&t;&t; */
id|ccode
op_assign
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
)paren
(brace
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.isc
op_assign
l_int|7
suffix:semicolon
id|ccode
op_assign
id|msch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
)paren
(brace
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|cons_dev
op_assign
id|irq
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * enable console I/O-interrupt sublass 7&n;&t;&t;&t;&t; */
id|asm
r_volatile
(paren
l_string|&quot;STCTL 6,6,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|cr6
)paren
)paren
suffix:semicolon
id|cr6
op_or_assign
l_int|0x01000000
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;LCTL 6,6,%0&quot;
op_scope_resolution
l_string|&quot;m&quot;
(paren
id|cr6
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_return
id|rc
suffix:semicolon
)brace
DECL|function|reset_cons_dev
r_int
id|reset_cons_dev
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_int
id|cr6
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cons_dev
op_ne
op_minus
l_int|1
)paren
(brace
id|rc
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|irq
OG
id|highest_subchannel
)paren
op_logical_or
(paren
id|irq
OL
l_int|0
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * reset the indicated console device to operate&n;&t;&t; *  on default console interrupt sublass 3&n;&t;&t; */
id|ccode
op_assign
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
)paren
(brace
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.flag
op_or_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.isc
op_assign
l_int|3
suffix:semicolon
id|ccode
op_assign
id|msch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
)paren
(brace
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|cons_dev
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * disable special console I/O-interrupt sublass 7&n;&t;&t;&t;&t; */
id|asm
r_volatile
(paren
l_string|&quot;STCTL 6,6,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|cr6
)paren
)paren
suffix:semicolon
id|cr6
op_and_assign
l_int|0xFEFFFFFF
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;LCTL 6,6,%0&quot;
op_scope_resolution
l_string|&quot;m&quot;
(paren
id|cr6
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_return
id|rc
suffix:semicolon
)brace
DECL|function|wait_cons_dev
r_int
id|wait_cons_dev
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|save_cr6
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_eq
id|cons_dev
)paren
(brace
multiline_comment|/*&n;&t;&t; * before entering the spinlock we may already have&n;&t;&t; *  processed the interrupt on a different CPU ...&n;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_eq
l_int|1
)paren
(brace
r_int
id|cr6
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * disable all, but isc 7 (console device)&n;&t;&t;&t; */
id|asm
r_volatile
(paren
l_string|&quot;STCTL 6,6,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|cr6
)paren
)paren
suffix:semicolon
id|save_cr6
op_assign
id|cr6
suffix:semicolon
id|cr6
op_and_assign
l_int|0x01FFFFFF
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;LCTL 6,6,%0&quot;
op_scope_resolution
l_string|&quot;m&quot;
(paren
id|cr6
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_do
(brace
id|tpi_info_t
id|tpi_info
suffix:semicolon
r_if
c_cond
(paren
id|tpi
c_func
(paren
op_amp
id|tpi_info
)paren
op_eq
l_int|1
)paren
(brace
id|s390_process_IRQ
c_func
(paren
id|tpi_info.irq
)paren
suffix:semicolon
)brace
r_else
(brace
id|s390irq_spin_unlock
c_func
(paren
id|irq
)paren
suffix:semicolon
id|tod_wait
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|s390irq_spin_lock
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
id|eieio
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_eq
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * restore previous isc value&n;&t;&t;&t; */
id|asm
r_volatile
(paren
l_string|&quot;STCTL 6,6,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|cr6
)paren
)paren
suffix:semicolon
id|cr6
op_assign
id|save_cr6
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;LCTL 6,6,%0&quot;
op_scope_resolution
l_string|&quot;m&quot;
(paren
id|cr6
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|rc
op_assign
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|rc
suffix:semicolon
)brace
DECL|function|enable_cpu_sync_isc
r_int
id|enable_cpu_sync_isc
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|ccode
suffix:semicolon
r_int
id|cr6
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_le
id|highest_subchannel
op_logical_and
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
(brace
id|ccode
op_assign
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ccode
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.isc
op_assign
l_int|5
suffix:semicolon
r_do
(brace
id|ccode
op_assign
id|msch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * enable interrupt subclass in CPU&n;&t;&t;&t;&t;&t; */
id|asm
r_volatile
(paren
l_string|&quot;STCTL 6,6,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|cr6
)paren
)paren
suffix:semicolon
id|cr6
op_or_assign
l_int|0x04000000
suffix:semicolon
singleline_comment|// enable sync isc 5
id|cr6
op_and_assign
l_int|0xEFFFFFFF
suffix:semicolon
singleline_comment|// disable standard isc 3
id|asm
r_volatile
(paren
l_string|&quot;LCTL 6,6,%0&quot;
op_scope_resolution
l_string|&quot;m&quot;
(paren
id|cr6
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ccode
op_eq
l_int|3
)paren
(brace
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
singleline_comment|// device not-oper - very unlikely
)brace
r_else
r_if
c_cond
(paren
id|ccode
op_eq
l_int|2
)paren
(brace
id|rc
op_assign
op_minus
id|EBUSY
suffix:semicolon
singleline_comment|// device busy - should not happen
)brace
r_else
r_if
c_cond
(paren
id|ccode
op_eq
l_int|1
)paren
(brace
singleline_comment|//
singleline_comment|// process pending status
singleline_comment|//
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|1
suffix:semicolon
id|s390_process_IRQ
c_func
(paren
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.s_pend
op_assign
l_int|0
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_while
c_loop
(paren
id|ccode
op_eq
l_int|1
op_logical_and
id|count
OL
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|3
)paren
(brace
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
singleline_comment|// device is not-operational
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|rc
suffix:semicolon
)brace
DECL|function|disable_cpu_sync_isc
r_int
id|disable_cpu_sync_isc
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_int
id|cr6
id|__attribute__
(paren
(paren
id|aligned
(paren
l_int|8
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_le
id|highest_subchannel
op_logical_and
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
(brace
id|ccode
op_assign
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.isc
op_assign
l_int|3
suffix:semicolon
id|ccode
op_assign
id|msch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
)paren
(brace
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * enable interrupt subclass in CPU&n;&t;&t;&t; */
id|asm
r_volatile
(paren
l_string|&quot;STCTL 6,6,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|cr6
)paren
)paren
suffix:semicolon
id|cr6
op_and_assign
l_int|0xFBFFFFFF
suffix:semicolon
singleline_comment|// disable sync isc 5
id|cr6
op_or_assign
l_int|0x10000000
suffix:semicolon
singleline_comment|// enable standard isc 3
id|asm
r_volatile
(paren
l_string|&quot;LCTL 6,6,%0&quot;
op_scope_resolution
l_string|&quot;m&quot;
(paren
id|cr6
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|rc
suffix:semicolon
)brace
singleline_comment|//
singleline_comment|// Input :
singleline_comment|//   devno - device number
singleline_comment|//   ps    - pointer to sense ID data area
singleline_comment|//
singleline_comment|// Output : none
singleline_comment|//
DECL|function|VM_virtual_device_info
r_void
id|VM_virtual_device_info
c_func
(paren
id|__u16
id|devno
comma
id|senseid_t
op_star
id|ps
)paren
(brace
id|diag210_t
id|diag_data
suffix:semicolon
r_int
id|ccode
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|diag_data.vrdcdvno
op_assign
id|devno
suffix:semicolon
id|diag_data.vrdclen
op_assign
r_sizeof
(paren
id|diag210_t
)paren
suffix:semicolon
id|ccode
op_assign
id|diag210
c_func
(paren
(paren
id|diag210_t
op_star
)paren
id|virt_to_phys
c_func
(paren
op_amp
id|diag_data
)paren
)paren
suffix:semicolon
id|ps-&gt;reserved
op_assign
l_int|0xff
suffix:semicolon
r_switch
c_cond
(paren
id|diag_data.vrdcvcla
)paren
(brace
r_case
l_int|0x80
suffix:colon
r_switch
c_cond
(paren
id|diag_data.vrdcvtyp
)paren
(brace
r_case
l_int|00
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3215
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_break
suffix:semicolon
r_case
l_int|0x40
suffix:colon
r_switch
c_cond
(paren
id|diag_data.vrdcvtyp
)paren
(brace
r_case
l_int|0xC0
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x5080
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x80
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x2250
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x04
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3277
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3278
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_break
suffix:semicolon
r_case
l_int|0x20
suffix:colon
r_switch
c_cond
(paren
id|diag_data.vrdcvtyp
)paren
(brace
r_case
l_int|0x84
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3505
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x82
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x2540
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x81
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x2501
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_break
suffix:semicolon
r_case
l_int|0x10
suffix:colon
r_switch
c_cond
(paren
id|diag_data.vrdcvtyp
)paren
(brace
r_case
l_int|0x84
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3525
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x82
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x2540
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x4F
suffix:colon
r_case
l_int|0x4E
suffix:colon
r_case
l_int|0x48
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3820
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x4D
suffix:colon
r_case
l_int|0x49
suffix:colon
r_case
l_int|0x45
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3800
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x4B
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x4248
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x4A
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x4245
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x47
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3262
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x43
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3203
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x42
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3211
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x41
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x1403
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_break
suffix:semicolon
r_case
l_int|0x08
suffix:colon
r_switch
c_cond
(paren
id|diag_data.vrdcvtyp
)paren
(brace
r_case
l_int|0x82
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3422
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x81
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3490
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x10
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3420
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x02
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3430
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3480
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x42
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x3424
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x44
suffix:colon
id|ps-&gt;cu_type
op_assign
l_int|0x9348
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
r_if
c_cond
(paren
id|error
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DIAG X&squot;210&squot; for device %04X returned (cc = %d): vdev class : %02X, &quot;
l_string|&quot;vdev type : %04X &bslash;n ...  rdev class : %02X, rdev type : %04X, rdev model: %02X&bslash;n&quot;
comma
id|devno
comma
id|ccode
comma
id|diag_data.vrdcvcla
comma
id|diag_data.vrdcvtyp
comma
id|diag_data.vrdcrccl
comma
id|diag_data.vrdccrty
comma
id|diag_data.vrdccrmd
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/*&n; * This routine returns the characteristics for the device&n; *  specified. Some old devices might not provide the necessary&n; *  command code information during SenseID processing. In this&n; *  case the function returns -EINVAL. Otherwise the function&n; *  allocates a decice specific data buffer and provides the&n; *  device characteristics together with the buffer size. Its&n; *  the callers responability to release the kernel memory if&n; *  not longer needed. In case of persistent I/O problems -EBUSY&n; *  is returned.&n; *&n; *  The function may be called enabled or disabled. However, the&n; *   caller must have locked the irq it is requesting data for.&n; *&n; * Note : It would have been nice to collect this information&n; *         during init_IRQ() processing but this is not possible&n; *&n; *         a) without statically pre-allocation fixed size buffers&n; *            as virtual memory management isn&squot;t available yet.&n; *&n; *         b) without unnecessarily increase system startup by&n; *            evaluating devices eventually not used at all.&n; */
DECL|function|read_dev_chars
r_int
id|read_dev_chars
c_func
(paren
r_int
id|irq
comma
r_void
op_star
op_star
id|buffer
comma
r_int
id|length
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|ccw1_t
op_star
id|rdc_ccw
suffix:semicolon
id|devstat_t
id|devstat
suffix:semicolon
r_char
op_star
id|rdc_buf
suffix:semicolon
r_int
id|devflag
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|emulated
op_assign
l_int|0
suffix:semicolon
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
op_logical_or
op_logical_neg
id|length
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
(paren
id|irq
OG
id|highest_subchannel
)paren
op_logical_or
(paren
id|irq
OL
l_int|0
)paren
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t; * Before playing around with irq locks we should assure&n;&t; *   running disabled on (just) our CPU. Sync. I/O requests&n;    *   also require to run disabled.&n;&t; *&n;&t; * Note : as no global lock is required, we must not use&n;&t; *        cli(), but __cli() instead.  &t;&n;&t; */
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
id|rdc_ccw
op_assign
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseccw
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
id|ret
op_assign
id|request_irq
c_func
(paren
id|irq
comma
id|init_IRQ_handler
comma
l_int|0
comma
l_string|&quot;RDC&quot;
comma
op_amp
id|devstat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|emulated
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|buffer
)paren
(brace
id|rdc_buf
op_assign
id|kmalloc
c_func
(paren
id|length
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_else
(brace
id|rdc_buf
op_assign
op_star
id|buffer
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
op_logical_neg
id|rdc_buf
)paren
(brace
id|ret
op_assign
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_else
(brace
r_do
(brace
id|rdc_ccw-&gt;cmd_code
op_assign
id|CCW_CMD_RDC
suffix:semicolon
id|rdc_ccw-&gt;cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
c_func
(paren
id|rdc_buf
)paren
suffix:semicolon
id|rdc_ccw-&gt;count
op_assign
id|length
suffix:semicolon
id|rdc_ccw-&gt;flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
id|ret
op_assign
id|s390_start_IO
c_func
(paren
id|irq
comma
id|rdc_ccw
comma
l_int|0x00524443
comma
singleline_comment|// RDC
l_int|0
comma
singleline_comment|// n/a
id|DOIO_WAIT_FOR_INTERRUPT
)paren
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
id|devflag
op_assign
(paren
(paren
id|devstat_t
op_star
)paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.action-&gt;dev_id
)paren
)paren
op_member_access_from_pointer
id|flag
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|retry
)paren
op_logical_and
(paren
id|ret
op_logical_or
(paren
id|devflag
op_amp
id|DEVSTAT_STATUS_PENDING
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
op_logical_neg
id|retry
)paren
(brace
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* endif */
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * on success we update the user input parms&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
op_star
id|buffer
op_assign
id|rdc_buf
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|emulated
)paren
(brace
id|free_irq
c_func
(paren
id|irq
comma
op_amp
id|devstat
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *  Read Configuration data&n; */
DECL|function|read_conf_data
r_int
id|read_conf_data
c_func
(paren
r_int
id|irq
comma
r_void
op_star
op_star
id|buffer
comma
r_int
op_star
id|length
)paren
(brace
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_int
id|ciw_cnt
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|irq
OG
id|highest_subchannel
)paren
op_logical_or
(paren
id|irq
OL
l_int|0
)paren
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;    * scan for RCD command in extended SenseID data&n;    */
r_for
c_loop
(paren
suffix:semicolon
(paren
id|found
op_eq
l_int|0
)paren
op_logical_and
(paren
id|ciw_cnt
OL
l_int|62
)paren
suffix:semicolon
id|ciw_cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|ct
op_eq
id|CIW_TYPE_RCD
)paren
(brace
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endfor */
r_if
c_cond
(paren
id|found
)paren
(brace
id|ccw1_t
op_star
id|rcd_ccw
op_assign
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseccw
suffix:semicolon
id|devstat_t
id|devstat
suffix:semicolon
r_char
op_star
id|rcd_buf
suffix:semicolon
r_int
id|devflag
suffix:semicolon
r_int
id|emulated
op_assign
l_int|0
suffix:semicolon
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
id|ret
op_assign
id|request_irq
c_func
(paren
id|irq
comma
id|init_IRQ_handler
comma
l_int|0
comma
l_string|&quot;RCD&quot;
comma
op_amp
id|devstat
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|emulated
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|rcd_buf
op_assign
id|kmalloc
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|count
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_do
(brace
id|rcd_ccw-&gt;cmd_code
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|cmd
suffix:semicolon
id|rcd_ccw-&gt;cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
c_func
(paren
id|rcd_buf
)paren
suffix:semicolon
id|rcd_ccw-&gt;count
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|count
suffix:semicolon
id|rcd_ccw-&gt;flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
id|ret
op_assign
id|s390_start_IO
c_func
(paren
id|irq
comma
id|rcd_ccw
comma
l_int|0x00524344
comma
singleline_comment|// == RCD
l_int|0
comma
singleline_comment|// n/a
id|DOIO_WAIT_FOR_INTERRUPT
)paren
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
id|devflag
op_assign
(paren
(paren
id|devstat_t
op_star
)paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.action-&gt;dev_id
)paren
)paren
op_member_access_from_pointer
id|flag
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|retry
)paren
op_logical_and
(paren
id|ret
op_logical_or
(paren
id|devflag
op_amp
id|DEVSTAT_STATUS_PENDING
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retry
)paren
id|ret
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t; * on success we update the user input parms&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
op_star
id|length
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.ciw
(braket
id|ciw_cnt
)braket
dot
id|count
suffix:semicolon
op_star
id|buffer
op_assign
id|rcd_buf
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|emulated
)paren
id|free_irq
c_func
(paren
id|irq
comma
op_amp
id|devstat
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
)brace
DECL|function|get_dev_info
r_int
id|get_dev_info
c_func
(paren
r_int
id|irq
comma
id|dev_info_t
op_star
id|pdi
)paren
(brace
r_return
id|get_dev_info_by_irq
c_func
(paren
id|irq
comma
id|pdi
)paren
suffix:semicolon
)brace
DECL|function|get_next_available_irq
r_static
r_int
id|__inline__
id|get_next_available_irq
c_func
(paren
id|ioinfo_t
op_star
id|pi
)paren
(brace
r_int
id|ret_val
suffix:semicolon
r_while
c_loop
(paren
id|TRUE
)paren
(brace
r_if
c_cond
(paren
id|pi-&gt;ui.flags.oper
)paren
(brace
id|ret_val
op_assign
id|pi-&gt;irq
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|pi
op_assign
id|pi-&gt;next
suffix:semicolon
singleline_comment|//
singleline_comment|// leave at end of list unconditionally
singleline_comment|//
r_if
c_cond
(paren
id|pi
op_eq
l_int|NULL
)paren
(brace
id|ret_val
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endwhile */
r_return
id|ret_val
suffix:semicolon
)brace
DECL|function|get_irq_first
r_int
id|get_irq_first
c_func
(paren
r_void
)paren
(brace
r_int
id|ret_irq
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo_head
)paren
(brace
r_if
c_cond
(paren
id|ioinfo_head-&gt;ui.flags.oper
)paren
(brace
id|ret_irq
op_assign
id|ioinfo_head-&gt;irq
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo_head-&gt;next
)paren
(brace
id|ret_irq
op_assign
id|get_next_available_irq
c_func
(paren
id|ioinfo_head-&gt;next
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret_irq
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|ret_irq
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|ret_irq
suffix:semicolon
)brace
DECL|function|get_irq_next
r_int
id|get_irq_next
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|ret_irq
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
(brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|next
)paren
(brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|next-&gt;ui.flags.oper
)paren
(brace
id|ret_irq
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|next-&gt;irq
suffix:semicolon
)brace
r_else
(brace
id|ret_irq
op_assign
id|get_next_available_irq
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|ret_irq
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|ret_irq
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|ret_irq
suffix:semicolon
)brace
DECL|function|get_dev_info_by_irq
r_int
id|get_dev_info_by_irq
c_func
(paren
r_int
id|irq
comma
id|dev_info_t
op_star
id|pdi
)paren
(brace
r_if
c_cond
(paren
id|irq
OG
id|highest_subchannel
op_logical_or
id|irq
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pdi
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
id|pdi-&gt;devno
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
suffix:semicolon
id|pdi-&gt;irq
op_assign
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
)paren
(brace
id|pdi-&gt;status
op_assign
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
(paren
id|pdi-&gt;sid_data
)paren
comma
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid
comma
r_sizeof
(paren
id|senseid_t
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pdi-&gt;status
op_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
(paren
id|pdi-&gt;sid_data
)paren
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|senseid_t
)paren
)paren
suffix:semicolon
id|pdi-&gt;sid_data.cu_type
op_assign
l_int|0xFFFF
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
id|pdi-&gt;status
op_or_assign
id|DEVSTAT_DEVICE_OWNED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
DECL|function|get_dev_info_by_devno
r_int
id|get_dev_info_by_devno
c_func
(paren
id|__u16
id|devno
comma
id|dev_info_t
op_star
id|pdi
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|devno
OG
l_int|0x0000ffff
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pdi
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|highest_subchannel
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|i
)braket
op_ne
id|INVALID_STORAGE_AREA
op_logical_and
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
op_eq
id|devno
)paren
(brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|ui.flags.oper
)paren
(brace
id|pdi-&gt;status
op_assign
l_int|0
suffix:semicolon
id|pdi-&gt;irq
op_assign
id|i
suffix:semicolon
id|pdi-&gt;devno
op_assign
id|devno
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
(paren
id|pdi-&gt;sid_data
)paren
comma
op_amp
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|senseid
comma
r_sizeof
(paren
id|senseid_t
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|pdi-&gt;status
op_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
id|pdi-&gt;irq
op_assign
id|i
suffix:semicolon
id|pdi-&gt;devno
op_assign
id|devno
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
(paren
id|pdi-&gt;sid_data
)paren
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|senseid_t
)paren
)paren
suffix:semicolon
id|pdi-&gt;sid_data.cu_type
op_assign
l_int|0xFFFF
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
id|pdi-&gt;status
op_or_assign
id|DEVSTAT_DEVICE_OWNED
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* found */
r_break
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endfor */
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
DECL|function|get_irq_by_devno
r_int
id|get_irq_by_devno
c_func
(paren
id|__u16
id|devno
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|rc
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|devno
op_le
l_int|0x0000ffff
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|highest_subchannel
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|ioinfo
(braket
id|i
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
op_eq
id|devno
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|i
)braket
op_member_access_from_pointer
id|schib.pmcw.dnv
op_eq
l_int|1
)paren
)paren
(brace
id|rc
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endfor */
)brace
multiline_comment|/* endif */
r_return
id|rc
suffix:semicolon
)brace
DECL|function|get_devno_by_irq
r_int
r_int
id|get_devno_by_irq
c_func
(paren
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
(paren
id|irq
OG
id|highest_subchannel
)paren
op_logical_or
(paren
id|irq
OL
l_int|0
)paren
op_logical_or
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t; * we don&squot;t need to check for the device be operational&n;&t; *  as the initial STSCH will always present the device&n;&t; *  number defined by the IOCDS regardless of the device&n;&t; *  existing or not. However, there could be subchannels&n;&t; *  defined who&squot;s device number isn&squot;t valid ...&n;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dnv
)paren
r_return
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
suffix:semicolon
r_else
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_device_recognition&n; *&n; * Used for system wide device recognition. Issues the device&n; *  independant SenseID command to obtain info the device type.&n; *&n; */
DECL|function|s390_device_recognition
r_void
id|s390_device_recognition
c_func
(paren
r_void
)paren
(brace
r_int
id|irq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* let&squot;s start with subchannel 0 ... */
r_do
(brace
multiline_comment|/*&n;&t;&t; * We issue the SenseID command on I/O subchannels we think are&n;&t;&t; *  operational only.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.st
op_eq
l_int|0
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|1
)paren
)paren
(brace
id|s390_SenseID
c_func
(paren
id|irq
comma
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
id|irq
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|irq
op_le
id|highest_subchannel
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_search_devices&n; *&n; * Determines all subchannels available to the system.&n; *&n; */
DECL|function|s390_process_subchannels
r_void
id|s390_process_subchannels
c_func
(paren
r_void
)paren
(brace
r_int
id|isValid
suffix:semicolon
r_int
id|irq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Evaluate all subchannels starting with 0 ... */
r_do
(brace
id|isValid
op_assign
id|s390_validate_subchannel
c_func
(paren
id|irq
)paren
suffix:semicolon
id|irq
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|isValid
op_logical_and
id|irq
OL
id|__MAX_SUBCHANNELS
)paren
suffix:semicolon
id|highest_subchannel
op_assign
op_decrement
id|irq
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nHighest subchannel number detected: %u&bslash;n&quot;
comma
id|highest_subchannel
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_validate_subchannel()&n; *&n; * Process the subchannel for the requested irq. Returns 1 for valid&n; *  subchannels, otherwise 0.&n; */
DECL|function|s390_validate_subchannel
r_int
id|s390_validate_subchannel
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|retry
suffix:semicolon
multiline_comment|/* retry count for status pending conditions */
r_int
id|ccode
suffix:semicolon
multiline_comment|/* condition code for stsch() only */
r_int
id|ccode2
suffix:semicolon
multiline_comment|/* condition code for other I/O routines */
id|schib_t
op_star
id|p_schib
suffix:semicolon
multiline_comment|/*&n;&t; * The first subchannel that is not-operational (ccode==3)&n;&t; *  indicates that there aren&squot;t any more devices available.&n;&t; */
r_if
c_cond
(paren
(paren
id|init_IRQ_complete
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
)paren
(brace
id|p_schib
op_assign
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
suffix:semicolon
)brace
r_else
(brace
id|p_schib
op_assign
op_amp
id|init_schib
suffix:semicolon
)brace
multiline_comment|/* endif */
id|ccode
op_assign
id|stsch
c_func
(paren
id|irq
comma
id|p_schib
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * ... just being curious we check for non I/O subchannels&n;&t;&t; */
r_if
c_cond
(paren
id|p_schib-&gt;pmcw.st
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Subchannel %04X reports &quot;
l_string|&quot;non-I/O subchannel type %04X&bslash;n&quot;
comma
id|irq
comma
id|p_schib-&gt;pmcw.st
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_ne
id|INVALID_STORAGE_AREA
)paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|p_schib-&gt;pmcw.dnv
)paren
(brace
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|init_IRQ_complete
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_assign
(paren
id|ioinfo_t
op_star
)paren
id|alloc_bootmem
c_func
(paren
r_sizeof
(paren
id|ioinfo_t
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_assign
(paren
id|ioinfo_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ioinfo_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
id|memset
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|ioinfo_t
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
comma
op_amp
id|init_schib
comma
r_sizeof
(paren
id|schib_t
)paren
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.status
op_assign
id|IRQ_DISABLED
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq_desc.handler
op_assign
op_amp
id|no_irq_type
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * We have to insert the new ioinfo element&n;&t;&t;&t;&t; *  into the linked list, either at its head,&n;&t;&t;&t;&t; *  its tail or insert it.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo_head
op_eq
l_int|NULL
)paren
multiline_comment|/* first element */
(brace
id|ioinfo_head
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
id|ioinfo_tail
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|irq
OL
id|ioinfo_head-&gt;irq
)paren
multiline_comment|/* new head */
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|next
op_assign
id|ioinfo_head
suffix:semicolon
id|ioinfo_head-&gt;prev
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
id|ioinfo_head
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|irq
OG
id|ioinfo_tail-&gt;irq
)paren
multiline_comment|/* new tail */
(brace
id|ioinfo_tail-&gt;next
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|prev
op_assign
id|ioinfo_tail
suffix:semicolon
id|ioinfo_tail
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
)brace
r_else
multiline_comment|/* insert element */
(brace
id|ioinfo_t
op_star
id|pi
op_assign
id|ioinfo_head
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|irq
OL
id|pi-&gt;next-&gt;irq
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|next
op_assign
id|pi-&gt;next
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|prev
op_assign
id|pi
suffix:semicolon
id|pi-&gt;next-&gt;prev
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
id|pi-&gt;next
op_assign
id|ioinfo
(braket
id|irq
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endif */
id|pi
op_assign
id|pi-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
singleline_comment|// initialize some values ...&t;
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid_supp
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|opm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pam
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pom
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Detected device %04X on subchannel %04X&quot;
l_string|&quot; - PIM = %02X, PAM = %02X, POM = %02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pam
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pom
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We should have at least one CHPID ...&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pam
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pom
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * We now have to initially ...&n;&t;&t;&t;&t; *  ... set &quot;interruption sublass&quot;&n;&t;&t;&t;&t; *  ... enable &quot;concurrent sense&quot;&n;&t;&t;&t;&t; *  ... enable &quot;multipath mode&quot; if more than one&n;&t;&t;&t;&t; *        CHPID is available. This is done regardless&n;&t;&t;&t;&t; *        whether multiple paths are available for us.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * Note : we don&squot;t enable the device here, this is temporarily&n;&t;&t;&t;&t; *        done during device sensing below.&n;&t;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.isc
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* could be smth. else */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.csense
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* concurrent sense */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.ena
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* force disable it */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.intparm
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
op_ne
l_int|0
)paren
op_logical_and
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pim
op_ne
l_int|0x80
)paren
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.mp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* multipath mode */
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t;&t;&t; * initialize ioinfo structure&n;&t;&t;&t;    */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|irq
op_assign
id|irq
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.busy
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|1
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.intparm
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.devno
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
suffix:semicolon
id|retry
op_assign
l_int|5
suffix:semicolon
r_do
(brace
id|ccode2
op_assign
id|msch_err
c_func
(paren
id|irq
comma
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ccode2
)paren
(brace
r_case
l_int|0
suffix:colon
singleline_comment|// successful completion
singleline_comment|//
singleline_comment|// concurrent sense facility available ...
singleline_comment|//
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.consns
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
singleline_comment|// status pending
singleline_comment|//
singleline_comment|// How can we have a pending status as device is
singleline_comment|//  disabled for interrupts ? Anyway, clear it ...
singleline_comment|//
id|tsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|devstat.ii.irb
)paren
)paren
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
singleline_comment|// busy
id|retry
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
singleline_comment|// not operational
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
DECL|macro|PGMCHK_OPERAND_EXC
mdefine_line|#define PGMCHK_OPERAND_EXC      0x15
r_if
c_cond
(paren
(paren
id|ccode2
op_amp
id|PGMCHK_OPERAND_EXC
)paren
op_eq
id|PGMCHK_OPERAND_EXC
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;&t; * re-issue the modify subchannel without trying to&n;&t;&t;&t;&t;&t;&t;&t; *  enable the concurrent sense facility&n;&t;&t;&t;&t;&t;&t;&t; */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.csense
op_assign
l_int|0
suffix:semicolon
id|ccode2
op_assign
id|msch_err
c_func
(paren
id|irq
comma
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode2
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; ... modify subchannel (2) failed with CC = %X&bslash;n&quot;
comma
id|ccode2
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.consns
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot; ... modify subchannel (1) failed with CC = %X&bslash;n&quot;
comma
id|ccode2
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
id|retry
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* endswitch */
)brace
r_while
c_loop
(paren
id|ccode2
op_logical_and
id|retry
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ccode2
OL
l_int|3
)paren
op_logical_and
(paren
op_logical_neg
id|retry
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; ... msch() retry count for &quot;
l_string|&quot;subchannel %04X exceeded, CC = %d&bslash;n&quot;
comma
id|irq
comma
id|ccode2
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t; * indicate whether the subchannel is valid&n;&t; */
r_if
c_cond
(paren
id|ccode
op_eq
l_int|3
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_SenseID&n; *&n; * Try to obtain the &squot;control unit&squot;/&squot;device type&squot; information&n; *  associated with the subchannel.&n; *&n; * The function is primarily meant to be called without irq&n; *  action handler in place. However, it also allows for&n; *  use with an action handler in place. If there is already&n; *  an action handler registered assure it can handle the&n; *  s390_SenseID() related device interrupts - interruption&n; *  parameter used is 0x00E2C9C4 ( SID ).&n; */
DECL|function|s390_SenseID
r_int
id|s390_SenseID
c_func
(paren
r_int
id|irq
comma
id|senseid_t
op_star
id|sid
)paren
(brace
id|ccw1_t
id|sense_ccw
suffix:semicolon
multiline_comment|/* ccw area for SenseID command */
id|devstat_t
id|devstat
suffix:semicolon
multiline_comment|/* required by request_irq() */
r_int
id|irq_ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* return code */
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* retry count */
r_int
id|inlreq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* inline request_irq() */
r_if
c_cond
(paren
(paren
id|irq
OG
id|highest_subchannel
)paren
op_logical_or
(paren
id|irq
OL
l_int|0
)paren
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
multiline_comment|/*&n;&t;&t; * Perform SENSE ID command processing. We have to request device&n;&t;&t; *  ownership and provide a dummy I/O handler. We issue sync. I/O&n;       *  requests and evaluate the devstat area on return therefore&n;       *  we don&squot;t need a real I/O handler in place.&n;       */
id|irq_ret
op_assign
id|request_irq
c_func
(paren
id|irq
comma
id|init_IRQ_handler
comma
l_int|0
comma
l_string|&quot;SID&quot;
comma
op_amp
id|devstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_ret
op_eq
l_int|0
)paren
id|inlreq
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|irq_ret
op_eq
l_int|0
)paren
(brace
id|s390irq_spin_lock
c_func
(paren
id|irq
)paren
suffix:semicolon
id|sense_ccw.cmd_code
op_assign
id|CCW_CMD_SENSE_ID
suffix:semicolon
id|sense_ccw.cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
c_func
(paren
id|sid
)paren
suffix:semicolon
id|sense_ccw.count
op_assign
r_sizeof
(paren
id|senseid_t
)paren
suffix:semicolon
id|sense_ccw.flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.cu_type
op_assign
l_int|0xFFFF
suffix:semicolon
multiline_comment|/* initialize fields ... */
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.cu_model
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.dev_type
op_assign
l_int|0
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|senseid.dev_model
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We now issue a SenseID request. In case of BUSY&n;&t;&t; *  or STATUS PENDING conditions we retry 5 times.&n;&t;&t; */
r_do
(brace
id|memset
c_func
(paren
op_amp
id|devstat
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
id|irq_ret
op_assign
id|s390_start_IO
c_func
(paren
id|irq
comma
op_amp
id|sense_ccw
comma
l_int|0x00E2C9C4
comma
singleline_comment|// == SID
l_int|0
comma
singleline_comment|// n/a
id|DOIO_WAIT_FOR_INTERRUPT
op_or
id|DOIO_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_ret
op_eq
op_minus
id|ETIMEDOUT
)paren
(brace
id|halt_IO
c_func
(paren
id|irq
comma
l_int|0x80E2C9C4
comma
id|DOIO_WAIT_FOR_INTERRUPT
)paren
suffix:semicolon
id|devstat.flag
op_or_assign
id|DEVSTAT_NOT_OPER
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|sid-&gt;cu_type
op_eq
l_int|0xFFFF
op_logical_and
id|devstat.flag
op_ne
id|DEVSTAT_NOT_OPER
)paren
(brace
r_if
c_cond
(paren
id|devstat.flag
op_amp
id|DEVSTAT_STATUS_PENDING
)paren
(brace
macro_line|#if CONFIG_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;Device %04X on Subchannel %04X &quot;
l_string|&quot;reports pending status, retry : %d&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
comma
id|retry
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|devstat.flag
op_amp
id|DEVSTAT_FLAG_SENSE_AVAIL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * if the device doesn&squot;t support the SenseID&n;&t;&t;&t;&t;&t; *  command further retries wouldn&squot;t help ...&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|devstat.ii.sense.data
(braket
l_int|0
)braket
op_amp
id|SNS0_CMD_REJECT
)paren
(brace
id|retry
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#if CONFIG_DEBUG_IO
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Device %04X,&quot;
l_string|&quot; UC/SenseID,&quot;
l_string|&quot; retry %d, cnt %02d,&quot;
l_string|&quot; sns :&quot;
l_string|&quot; %02X%02X%02X%02X %02X%02X%02X%02X ...&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|retry
comma
id|devstat.scnt
comma
id|devstat.ii.sense.data
(braket
l_int|0
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|1
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|2
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|3
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|4
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|5
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|6
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|7
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|devstat.flag
op_amp
id|DEVSTAT_NOT_OPER
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Device %04X on Subchannel %04X &quot;
l_string|&quot;became &squot;not operational&squot;&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
)paren
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
singleline_comment|// we got it or the device is not-operational ...
(brace
id|retry
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
id|retry
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|retry
OG
l_int|0
)paren
suffix:semicolon
id|s390irq_spin_unlock
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we installed the irq action handler we have to&n;&t;&t; *  release it too.&n;&t;&t; */
r_if
c_cond
(paren
id|inlreq
)paren
id|free_irq
c_func
(paren
id|irq
comma
op_amp
id|devstat
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if running under VM check there ... perhaps we should do&n;&t;&t; *  only if we suffered a command reject, but it doesn&squot;t harm&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|sid-&gt;cu_type
op_eq
l_int|0xFFFF
)paren
op_logical_and
(paren
id|MACHINE_IS_VM
)paren
)paren
(brace
id|VM_virtual_device_info
c_func
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|sid
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|sid-&gt;cu_type
op_eq
l_int|0xFFFF
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * SenseID CU-type of 0xffff indicates that no device&n;&t;&t;&t; *  information could be retrieved (pre-init value).&n;&t;&t;&t; *&n;&t;&t;&t; * If we can&squot;t couldn&squot;t identify the device type we&n;&t;&t;&t; *  consider the device &quot;not operational&quot;.&n;&t;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;Unknown device %04X on subchannel %04X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
)paren
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
multiline_comment|/*&n;&t;&t; * Issue device info message if unit was operational .&n;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
)paren
(brace
r_if
c_cond
(paren
id|sid-&gt;dev_type
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Device %04X reports: CU  Type/Mod = %04X/%02X,&quot;
l_string|&quot; Dev Type/Mod = %04X/%02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|sid-&gt;cu_type
comma
id|sid-&gt;cu_model
comma
id|sid-&gt;dev_type
comma
id|sid-&gt;dev_model
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Device %04X reports:&quot;
l_string|&quot; Dev Type/Mod = %04X/%02X&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|sid-&gt;cu_type
comma
id|sid-&gt;cu_model
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
)paren
id|irq_ret
op_assign
l_int|0
suffix:semicolon
r_else
id|irq_ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|irq_ret
suffix:semicolon
)brace
DECL|function|s390_SetMultiPath
r_static
r_int
id|__inline__
id|s390_SetMultiPath
c_func
(paren
r_int
id|irq
)paren
(brace
r_int
id|cc
suffix:semicolon
id|cc
op_assign
id|stsch
c_func
(paren
id|irq
comma
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cc
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.mp
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* multipath mode */
id|cc
op_assign
id|msch
c_func
(paren
id|irq
comma
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|cc
suffix:semicolon
)brace
multiline_comment|/*&n; * Device Path Verification&n; *&n; * Path verification is accomplished by checking which paths (CHPIDs) are&n; *  available. Further, a path group ID is set, if possible in multipath&n; *  mode, otherwise in single path mode.&n; *&n; */
DECL|function|s390_DevicePathVerification
r_int
id|s390_DevicePathVerification
c_func
(paren
r_int
id|irq
)paren
(brace
macro_line|#if 0
r_int
id|ccode
suffix:semicolon
id|__u8
id|pathmask
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid_supp
op_eq
l_int|0
)paren
(brace
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
multiline_comment|/* endif */
id|ccode
op_assign
id|stsch
c_func
(paren
id|irq
comma
op_amp
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccode
)paren
(brace
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
id|pgid_t
id|pgid
suffix:semicolon
r_int
id|first
op_assign
l_int|1
suffix:semicolon
id|__u8
id|dev_path
op_assign
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pam
op_amp
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.pom
suffix:semicolon
multiline_comment|/*&n;&t;&t; * let&squot;s build a path group ID if we don&squot;t have one yet&n;&t;&t; */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid
op_eq
l_int|0
)paren
(brace
r_struct
id|_lowcore
op_star
id|lowcore
op_assign
op_amp
id|get_cpu_lowcore
c_func
(paren
id|cpu
)paren
suffix:semicolon
id|ioinfo-&gt;pgid.cpu_addr
op_assign
id|lowcore-&gt;cpu_data.cpu_addr
suffix:semicolon
id|ioinfo-&gt;pgid.cpu_id
op_assign
id|lowcore-&gt;cpu_data.cpu_id.ident
suffix:semicolon
id|ioinfo-&gt;pgid.cpu_model
op_assign
id|lowcore-&gt;cpu_data.cpu_id.machine
suffix:semicolon
id|ioinfo-&gt;pgid.tod_high
op_assign
op_star
(paren
id|__u32
op_star
)paren
op_amp
id|irq_IPL_TOD
suffix:semicolon
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
id|memcpy
c_func
(paren
op_amp
id|pgid
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|pgid
comma
r_sizeof
(paren
id|pgid_t
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
op_logical_and
op_logical_neg
id|ret
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pathmask
op_assign
l_int|0x80
op_rshift
id|i
suffix:semicolon
r_if
c_cond
(paren
id|dev_path
op_amp
id|pathmask
)paren
(brace
id|ret
op_assign
id|s390_SetPGID
c_func
(paren
id|irq
comma
id|pathmask
comma
op_amp
id|pgid
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * For the *first* path we are prepared&n;&t;&t;&t;&t; *  for recovery&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; *  - If we fail setting the PGID we assume its&n;&t;&t;&t;&t; *     using  a different PGID already (VM) we&n;&t;&t;&t;&t; *     try to sense.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ret
op_eq
op_minus
id|EOPNOTSUPP
op_logical_and
id|first
)paren
(brace
op_star
(paren
r_int
op_star
)paren
op_amp
id|pgid
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
id|s390_SensePGID
c_func
(paren
id|irq
comma
id|pathmask
comma
op_amp
id|pgid
)paren
suffix:semicolon
id|first
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Check whether we retrieved&n;&t;&t;&t;&t;&t;&t; *  a reasonable PGID ...&n;&t;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
(paren
op_star
(paren
r_int
op_star
)paren
op_amp
id|pgid
op_eq
l_int|0
)paren
)paren
(brace
id|ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
id|s390_SetPGID
c_func
(paren
id|irq
comma
id|pathmask
comma
op_amp
id|pgid
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|ret
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid_supp
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PathVerification(%04X) &quot;
l_string|&quot;- Device %04X doesn&squot;t &quot;
l_string|&quot; support path grouping&quot;
comma
id|irq
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
r_if
c_cond
(paren
id|ret
)paren
(brace
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.pgid_supp
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endif */
)brace
multiline_comment|/* endfor */
)brace
multiline_comment|/* endif */
r_return
id|ret
suffix:semicolon
macro_line|#else
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * s390_SetPGID&n; *&n; * Set Path Group ID&n; *&n; */
DECL|function|s390_SetPGID
r_int
id|s390_SetPGID
c_func
(paren
r_int
id|irq
comma
id|__u8
id|lpm
comma
id|pgid_t
op_star
id|pgid
)paren
(brace
id|ccw1_t
id|spid_ccw
suffix:semicolon
multiline_comment|/* ccw area for SPID command */
id|devstat_t
id|devstat
suffix:semicolon
multiline_comment|/* required by request_irq() */
r_int
id|irq_ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* return code */
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* retry count */
r_int
id|inlreq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* inline request_irq() */
r_int
id|mpath
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* try multi-path first */
r_if
c_cond
(paren
(paren
id|irq
OG
id|highest_subchannel
)paren
op_logical_or
(paren
id|irq
OL
l_int|0
)paren
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
multiline_comment|/*&n;&t;&t; * Perform SENSE ID command processing. We have to request device&n;&t;&t; *  ownership and provide a dummy I/O handler. We issue sync. I/O&n;&t;&t; *  requests and evaluate the devstat area on return therefore&n;&t;&t; *  we don&squot;t need a real I/O handler in place.&n;&t;&t; */
id|irq_ret
op_assign
id|request_irq
c_func
(paren
id|irq
comma
id|init_IRQ_handler
comma
l_int|0
comma
l_string|&quot;SPID&quot;
comma
op_amp
id|devstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_ret
op_eq
l_int|0
)paren
id|inlreq
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|irq_ret
op_eq
l_int|0
)paren
(brace
id|s390irq_spin_lock
c_func
(paren
id|irq
)paren
suffix:semicolon
id|spid_ccw.cmd_code
op_assign
id|CCW_CMD_SET_PGID
suffix:semicolon
id|spid_ccw.cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
c_func
(paren
id|pgid
)paren
suffix:semicolon
id|spid_ccw.count
op_assign
r_sizeof
(paren
id|pgid_t
)paren
suffix:semicolon
id|spid_ccw.flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We now issue a SenseID request. In case of BUSY&n;&t;&t; *  or STATUS PENDING conditions we retry 5 times.&n;&t;&t; */
r_do
(brace
id|memset
c_func
(paren
op_amp
id|devstat
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
id|irq_ret
op_assign
id|s390_start_IO
c_func
(paren
id|irq
comma
op_amp
id|spid_ccw
comma
l_int|0xE2D7C9C4
comma
singleline_comment|// == SPID
id|lpm
comma
singleline_comment|// n/a
id|DOIO_WAIT_FOR_INTERRUPT
op_or
id|DOIO_VALID_LPM
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|irq_ret
)paren
(brace
r_if
c_cond
(paren
id|devstat.flag
op_amp
id|DEVSTAT_STATUS_PENDING
)paren
(brace
macro_line|#if CONFIG_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;SPID - Device %04X &quot;
l_string|&quot;on Subchannel %04X &quot;
l_string|&quot;reports pending status, &quot;
l_string|&quot;retry : %d&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
comma
id|retry
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|devstat.flag
op_eq
(paren
id|DEVSTAT_START_FUNCTION
op_or
id|DEVSTAT_FINAL_STATUS
)paren
)paren
(brace
id|retry
op_assign
l_int|0
suffix:semicolon
singleline_comment|// successfully set ...
)brace
r_else
r_if
c_cond
(paren
id|devstat.flag
op_amp
id|DEVSTAT_FLAG_SENSE_AVAIL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * If the device doesn&squot;t support the&n;&t;&t;&t;&t;&t; *  Sense Path Group ID command&n;&t;&t;&t;&t;&t; *  further retries wouldn&squot;t help ...&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|devstat.ii.sense.data
(braket
l_int|0
)braket
op_amp
id|SNS0_CMD_REJECT
)paren
(brace
r_if
c_cond
(paren
id|mpath
)paren
(brace
id|pgid-&gt;inf.fc
op_assign
id|SPID_FUNC_ESTABLISH
suffix:semicolon
id|mpath
op_assign
l_int|0
suffix:semicolon
id|retry
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|irq_ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
macro_line|#if CONFIG_DEBUG_IO
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;SPID - device %04X,&quot;
l_string|&quot; unit check,&quot;
l_string|&quot; retry %d, cnt %02d,&quot;
l_string|&quot; sns :&quot;
l_string|&quot; %02X%02X%02X%02X %02X%02X%02X%02X ...&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|retry
comma
id|devstat.scnt
comma
id|devstat.ii.sense.data
(braket
l_int|0
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|1
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|2
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|3
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|4
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|5
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|6
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|7
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|devstat.flag
op_amp
id|DEVSTAT_NOT_OPER
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SPID - Device %04X &quot;
l_string|&quot;on Subchannel %04X &quot;
l_string|&quot;became &squot;not operational&squot;&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
)paren
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
r_if
c_cond
(paren
id|irq_ret
op_ne
op_minus
id|ENODEV
)paren
(brace
id|retry
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|retry
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_while
c_loop
(paren
id|retry
OG
l_int|0
)paren
suffix:semicolon
id|s390irq_spin_unlock
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we installed the irq action handler we have to&n;&t;&t; *  release it too.&n;&t;&t; */
r_if
c_cond
(paren
id|inlreq
)paren
id|free_irq
c_func
(paren
id|irq
comma
op_amp
id|devstat
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|irq_ret
suffix:semicolon
)brace
multiline_comment|/*&n; * s390_SensePGID&n; *&n; * Sense Path Group ID&n; *&n; */
DECL|function|s390_SensePGID
r_int
id|s390_SensePGID
c_func
(paren
r_int
id|irq
comma
id|__u8
id|lpm
comma
id|pgid_t
op_star
id|pgid
)paren
(brace
id|ccw1_t
id|snid_ccw
suffix:semicolon
multiline_comment|/* ccw area for SNID command */
id|devstat_t
id|devstat
suffix:semicolon
multiline_comment|/* required by request_irq() */
r_int
id|irq_ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* return code */
r_int
id|retry
op_assign
l_int|5
suffix:semicolon
multiline_comment|/* retry count */
r_int
id|inlreq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* inline request_irq() */
r_if
c_cond
(paren
(paren
id|irq
OG
id|highest_subchannel
)paren
op_logical_or
(paren
id|irq
OL
l_int|0
)paren
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_eq
id|INVALID_STORAGE_AREA
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.oper
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
op_logical_neg
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|ui.flags.ready
)paren
(brace
multiline_comment|/*&n;&t;&t; * Perform SENSE ID command processing. We have to request device&n;&t;&t; *  ownership and provide a dummy I/O handler. We issue sync. I/O&n;&t;&t; *  requests and evaluate the devstat area on return therefore&n;&t;&t; *  we don&squot;t need a real I/O handler in place.&n;&t;&t; */
id|irq_ret
op_assign
id|request_irq
c_func
(paren
id|irq
comma
id|init_IRQ_handler
comma
l_int|0
comma
l_string|&quot;SNID&quot;
comma
op_amp
id|devstat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_ret
op_eq
l_int|0
)paren
id|inlreq
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|irq_ret
op_eq
l_int|0
)paren
(brace
id|s390irq_spin_lock
c_func
(paren
id|irq
)paren
suffix:semicolon
id|snid_ccw.cmd_code
op_assign
id|CCW_CMD_SENSE_PGID
suffix:semicolon
id|snid_ccw.cda
op_assign
(paren
id|__u32
)paren
id|virt_to_phys
c_func
(paren
id|pgid
)paren
suffix:semicolon
id|snid_ccw.count
op_assign
r_sizeof
(paren
id|pgid_t
)paren
suffix:semicolon
id|snid_ccw.flags
op_assign
id|CCW_FLAG_SLI
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We now issue a SenseID request. In case of BUSY&n;&t;&t; *  or STATUS PENDING conditions we retry 5 times.&n;&t;&t; */
r_do
(brace
id|memset
c_func
(paren
op_amp
id|devstat
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|devstat_t
)paren
)paren
suffix:semicolon
id|irq_ret
op_assign
id|s390_start_IO
c_func
(paren
id|irq
comma
op_amp
id|snid_ccw
comma
l_int|0xE2D5C9C4
comma
singleline_comment|// == SNID
id|lpm
comma
singleline_comment|// n/a
id|DOIO_WAIT_FOR_INTERRUPT
op_or
id|DOIO_VALID_LPM
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|irq_ret
)paren
(brace
r_if
c_cond
(paren
id|devstat.flag
op_amp
id|DEVSTAT_STATUS_PENDING
)paren
(brace
macro_line|#if CONFIG_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;SNID - Device %04X &quot;
l_string|&quot;on Subchannel %04X &quot;
l_string|&quot;reports pending status, &quot;
l_string|&quot;retry : %d&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
comma
id|retry
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* endif */
r_if
c_cond
(paren
id|devstat.flag
op_amp
id|DEVSTAT_FLAG_SENSE_AVAIL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * If the device doesn&squot;t support the&n;&t;&t;&t;&t;&t; *  Sense Path Group ID command&n;&t;&t;&t;&t;&t; *  further retries wouldn&squot;t help ...&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|devstat.ii.sense.data
(braket
l_int|0
)braket
op_amp
id|SNS0_CMD_REJECT
)paren
(brace
id|retry
op_assign
l_int|0
suffix:semicolon
id|irq_ret
op_assign
op_minus
id|EOPNOTSUPP
suffix:semicolon
)brace
macro_line|#if CONFIG_DEBUG_IO
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;SNID - device %04X,&quot;
l_string|&quot; unit check,&quot;
l_string|&quot; retry %d, cnt %02d,&quot;
l_string|&quot; sns :&quot;
l_string|&quot; %02X%02X%02X%02X %02X%02X%02X%02X ...&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|retry
comma
id|devstat.scnt
comma
id|devstat.ii.sense.data
(braket
l_int|0
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|1
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|2
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|3
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|4
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|5
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|6
)braket
comma
id|devstat.ii.sense.data
(braket
l_int|7
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|devstat.flag
op_amp
id|DEVSTAT_NOT_OPER
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SNID - Device %04X &quot;
l_string|&quot;on Subchannel %04X &quot;
l_string|&quot;became &squot;not operational&squot;&bslash;n&quot;
comma
id|ioinfo
(braket
id|irq
)braket
op_member_access_from_pointer
id|schib.pmcw.dev
comma
id|irq
)paren
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_else
r_if
c_cond
(paren
id|irq_ret
op_ne
op_minus
id|ENODEV
)paren
(brace
id|retry
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|retry
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* endif */
)brace
r_while
c_loop
(paren
id|retry
OG
l_int|0
)paren
suffix:semicolon
id|s390irq_spin_unlock
c_func
(paren
id|irq
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we installed the irq action handler we have to&n;&t;&t; *  release it too.&n;&t;&t; */
r_if
c_cond
(paren
id|inlreq
)paren
id|free_irq
c_func
(paren
id|irq
comma
op_amp
id|devstat
)paren
suffix:semicolon
)brace
multiline_comment|/* endif */
r_return
id|irq_ret
suffix:semicolon
)brace
DECL|function|do_crw_pending
r_void
id|do_crw_pending
c_func
(paren
r_void
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* added by Holger Smolinski for reipl support in reipl.S */
r_void
DECL|function|reipl
id|reipl
(paren
r_int
id|sch
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|highest_subchannel
suffix:semicolon
id|i
op_increment
)paren
(brace
id|free_irq
(paren
id|i
comma
(paren
r_void
op_star
)paren
id|REIPL_DEVID_MAGIC
)paren
suffix:semicolon
)brace
id|do_reipl
c_func
(paren
l_int|0x10000
op_or
id|sch
)paren
suffix:semicolon
)brace
eof
