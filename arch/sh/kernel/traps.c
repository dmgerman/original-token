multiline_comment|/* $Id: traps.c,v 1.5 2000/02/27 08:27:55 gniibe Exp $&n; *&n; *  linux/arch/sh/traps.c&n; *&n; *  SuperH version: Copyright (C) 1999  Niibe Yutaka&n; */
multiline_comment|/*&n; * &squot;Traps.c&squot; handles hardware traps and faults after we have saved some&n; * state in &squot;entry.S&squot;.&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
DECL|macro|DO_ERROR
mdefine_line|#define DO_ERROR(trapnr, signr, str, name, tsk) &bslash;&n;asmlinkage void do_##name(unsigned long r4, unsigned long r5, &bslash;&n;&t;&t;&t;  unsigned long r6, unsigned long r7, &bslash;&n;&t;&t;&t;  struct pt_regs regs) &bslash;&n;{ &bslash;&n;&t;unsigned long error_code; &bslash;&n; &bslash;&n;&t;asm volatile(&quot;stc&t;$r2_bank, %0&quot;: &quot;=r&quot; (error_code)); &bslash;&n;&t;sti(); &bslash;&n;&t;tsk-&gt;thread.error_code = error_code; &bslash;&n;&t;tsk-&gt;thread.trap_no = trapnr; &bslash;&n;&t;force_sig(signr, tsk); &bslash;&n;&t;die_if_no_fixup(str,&amp;regs,error_code); &bslash;&n;}
multiline_comment|/*&n; * These constants are for searching for possible module text&n; * segments.  VMALLOC_OFFSET comes from mm/vmalloc.c; MODULE_RANGE is&n; * a guess of how much space is likely to be vmalloced.&n; */
DECL|macro|VMALLOC_OFFSET
mdefine_line|#define VMALLOC_OFFSET (8*1024*1024)
DECL|macro|MODULE_RANGE
mdefine_line|#define MODULE_RANGE (8*1024*1024)
DECL|variable|die_lock
id|spinlock_t
id|die_lock
suffix:semicolon
DECL|function|die
r_void
id|die
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
id|console_verbose
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|die_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %04lx&bslash;n&quot;
comma
id|str
comma
id|err
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|show_regs
c_func
(paren
id|regs
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|die_lock
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
DECL|function|die_if_kernel
r_static
r_inline
r_void
id|die_if_kernel
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
id|die
c_func
(paren
id|str
comma
id|regs
comma
id|err
)paren
suffix:semicolon
)brace
DECL|function|die_if_no_fixup
r_static
r_void
id|die_if_no_fixup
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
r_int
r_int
id|fixup
suffix:semicolon
id|fixup
op_assign
id|search_exception_table
c_func
(paren
id|regs-&gt;pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fixup
)paren
(brace
id|regs-&gt;pc
op_assign
id|fixup
suffix:semicolon
r_return
suffix:semicolon
)brace
id|die
c_func
(paren
id|str
comma
id|regs
comma
id|err
)paren
suffix:semicolon
)brace
)brace
id|DO_ERROR
c_func
(paren
l_int|7
comma
id|SIGSEGV
comma
l_string|&quot;address error (load)&quot;
comma
id|address_error_load
comma
id|current
)paren
id|DO_ERROR
c_func
(paren
l_int|8
comma
id|SIGSEGV
comma
l_string|&quot;address error (store)&quot;
comma
id|address_error_store
comma
id|current
)paren
id|DO_ERROR
c_func
(paren
l_int|12
comma
id|SIGILL
comma
l_string|&quot;reserved instruction&quot;
comma
id|reserved_inst
comma
id|current
)paren
id|DO_ERROR
c_func
(paren
l_int|13
comma
id|SIGILL
comma
l_string|&quot;illegal slot instruction&quot;
comma
id|illegal_slot_inst
comma
id|current
)paren
DECL|function|do_exception_error
id|asmlinkage
r_void
id|do_exception_error
c_func
(paren
r_int
r_int
id|r4
comma
r_int
r_int
id|r5
comma
r_int
r_int
id|r6
comma
r_int
r_int
id|r7
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
r_int
id|ex
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;stc&t;$r2_bank, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ex
)paren
)paren
suffix:semicolon
id|die_if_kernel
c_func
(paren
l_string|&quot;exception&quot;
comma
op_amp
id|regs
comma
id|ex
)paren
suffix:semicolon
)brace
DECL|function|trap_init
r_void
id|__init
id|trap_init
c_func
(paren
r_void
)paren
(brace
r_extern
r_void
op_star
id|vbr_base
suffix:semicolon
r_extern
r_void
op_star
id|exception_handling_table
(braket
l_int|14
)braket
suffix:semicolon
id|exception_handling_table
(braket
l_int|7
)braket
op_assign
(paren
r_void
op_star
)paren
id|do_address_error_load
suffix:semicolon
id|exception_handling_table
(braket
l_int|8
)braket
op_assign
(paren
r_void
op_star
)paren
id|do_address_error_store
suffix:semicolon
id|exception_handling_table
(braket
l_int|12
)braket
op_assign
(paren
r_void
op_star
)paren
id|do_reserved_inst
suffix:semicolon
id|exception_handling_table
(braket
l_int|13
)braket
op_assign
(paren
r_void
op_star
)paren
id|do_illegal_slot_inst
suffix:semicolon
multiline_comment|/* NOTE: The VBR value should be at P1&n;&t;   (or P2, virtural &quot;fixed&quot; address space).&n;&t;   It&squot;s definitely should not in physical address.  */
id|asm
r_volatile
(paren
l_string|&quot;ldc&t;%0, $vbr&quot;
suffix:colon
multiline_comment|/* no output */
suffix:colon
l_string|&quot;r&quot;
(paren
op_amp
id|vbr_base
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
)brace
DECL|function|dump_stack
r_void
id|dump_stack
c_func
(paren
r_void
)paren
(brace
r_int
r_int
op_star
id|start
suffix:semicolon
r_int
r_int
op_star
id|end
suffix:semicolon
r_int
r_int
op_star
id|p
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;mov&t;$r15, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|start
)paren
)paren
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;stc&t;$r7_bank, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|end
)paren
)paren
suffix:semicolon
id|end
op_add_assign
l_int|8192
op_div
l_int|4
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%08lx:%08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|start
comma
(paren
r_int
r_int
)paren
id|end
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|start
suffix:semicolon
id|p
OL
id|end
suffix:semicolon
id|p
op_increment
)paren
(brace
r_extern
r_int
id|_text
comma
id|_etext
suffix:semicolon
r_int
r_int
id|v
op_assign
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
(paren
id|v
op_ge
(paren
r_int
r_int
)paren
op_amp
id|_text
)paren
op_logical_and
(paren
id|v
op_le
(paren
r_int
r_int
)paren
op_amp
id|_etext
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%08lx&bslash;n&quot;
comma
id|v
)paren
suffix:semicolon
)brace
)brace
)brace
eof
