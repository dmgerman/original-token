multiline_comment|/*&n; * bios32.c - BIOS32, PCI BIOS functions.&n; *&n; * Sponsored by&n; *&t;iX Multiuser Multitasking Magazine&n; *&t;Hannover, Germany&n; *&t;hm@ix.de&n; *&n; * Copyright 1993, 1994 Drew Eckhardt&n; *      Visionary Computing&n; *      (Unix and Linux consulting and custom programming)&n; *      Drew@Colorado.EDU&n; *      +1 (303) 786-7975&n; *&n; * For more information, please consult&n; *&n; * PCI BIOS Specification Revision&n; * PCI Local Bus Specification&n; * PCI System Design Guide&n; *&n; * PCI Special Interest Group&n; * M/S HF3-15A&n; * 5200 N.E. Elam Young Parkway&n; * Hillsboro, Oregon 97124-6497&n; * +1 (503) 696-2000&n; * +1 (800) 433-5177&n; *&n; * Manuals are $25 each or $50 for all three, plus $7 shipping&n; * within the United States, $35 abroad.&n; *&n; *&n; * CHANGELOG :&n; * Jun 17, 1994 : Modified to accommodate the broken pre-PCI BIOS SPECIFICATION&n; *&t;Revision 2.0 present on &lt;thys@dennis.ee.up.ac.za&gt;&squot;s ASUS mainboard.&n; *&n; * Jan 5,  1995 : Modified to probe PCI hardware at boot time by Frederic&n; *     Potter, potter@cao-vlsi.ibp.fr&n; *&n; * Jan 10, 1995 : Modified to store the information about configured pci&n; *      devices into a list, which can be accessed via /proc/pci by&n; *      Curtis Varner, cvarner@cs.ucr.edu&n; *&n; * Jan 12, 1995 : CPU-PCI bridge optimization support by Frederic Potter.&n; *&t;Alpha version. Intel &amp; UMC chipset support only. See pci.h for more.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
DECL|macro|PCIBIOS_PCI_FUNCTION_ID
mdefine_line|#define PCIBIOS_PCI_FUNCTION_ID &t;0xb1XX
DECL|macro|PCIBIOS_PCI_BIOS_PRESENT
mdefine_line|#define PCIBIOS_PCI_BIOS_PRESENT &t;0xb101
DECL|macro|PCIBIOS_FIND_PCI_DEVICE
mdefine_line|#define PCIBIOS_FIND_PCI_DEVICE&t;&t;0xb102
DECL|macro|PCIBIOS_FIND_PCI_CLASS_CODE
mdefine_line|#define PCIBIOS_FIND_PCI_CLASS_CODE&t;0xb103
DECL|macro|PCIBIOS_GENERATE_SPECIAL_CYCLE
mdefine_line|#define PCIBIOS_GENERATE_SPECIAL_CYCLE&t;0xb106
DECL|macro|PCIBIOS_READ_CONFIG_BYTE
mdefine_line|#define PCIBIOS_READ_CONFIG_BYTE&t;0xb108
DECL|macro|PCIBIOS_READ_CONFIG_WORD
mdefine_line|#define PCIBIOS_READ_CONFIG_WORD&t;0xb109
DECL|macro|PCIBIOS_READ_CONFIG_DWORD
mdefine_line|#define PCIBIOS_READ_CONFIG_DWORD&t;0xb10a
DECL|macro|PCIBIOS_WRITE_CONFIG_BYTE
mdefine_line|#define PCIBIOS_WRITE_CONFIG_BYTE&t;0xb10b
DECL|macro|PCIBIOS_WRITE_CONFIG_WORD
mdefine_line|#define PCIBIOS_WRITE_CONFIG_WORD&t;0xb10c
DECL|macro|PCIBIOS_WRITE_CONFIG_DWORD
mdefine_line|#define PCIBIOS_WRITE_CONFIG_DWORD&t;0xb10d
macro_line|#ifdef CONFIG_PCI
r_extern
r_void
id|add_pci_resource
c_func
(paren
r_int
r_char
comma
r_int
r_char
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* BIOS32 signature: &quot;_32_&quot; */
DECL|macro|BIOS32_SIGNATURE
mdefine_line|#define BIOS32_SIGNATURE&t;((&squot;_&squot; &lt;&lt; 0) + (&squot;3&squot; &lt;&lt; 8) + (&squot;2&squot; &lt;&lt; 16) + (&squot;_&squot; &lt;&lt; 24))
multiline_comment|/* PCI signature: &quot;PCI &quot; */
DECL|macro|PCI_SIGNATURE
mdefine_line|#define PCI_SIGNATURE&t;&t;((&squot;P&squot; &lt;&lt; 0) + (&squot;C&squot; &lt;&lt; 8) + (&squot;I&squot; &lt;&lt; 16) + (&squot; &squot; &lt;&lt; 24))
multiline_comment|/* PCI service signature: &quot;$PCI&quot; */
DECL|macro|PCI_SERVICE
mdefine_line|#define PCI_SERVICE&t;&t;((&squot;$&squot; &lt;&lt; 0) + (&squot;P&squot; &lt;&lt; 8) + (&squot;C&squot; &lt;&lt; 16) + (&squot;I&squot; &lt;&lt; 24))
multiline_comment|/*&n; * This is the standard structure used to identify the entry point&n; * to the BIOS32 Service Directory, as documented in&n; * &t;Standard BIOS 32-bit Service Directory Proposal&n; * &t;Revision 0.4 May 24, 1993&n; * &t;Phoenix Technologies Ltd.&n; *&t;Norwood, MA&n; * and the PCI BIOS specification.&n; */
macro_line|#ifdef CONFIG_PCI
DECL|struct|pci_resource_t
r_typedef
r_struct
id|pci_resource_t
(brace
DECL|member|bus
r_int
r_char
id|bus
suffix:semicolon
DECL|member|dev_fn
r_int
r_char
id|dev_fn
suffix:semicolon
DECL|member|next
r_struct
id|pci_resource_t
op_star
id|next
suffix:semicolon
DECL|typedef|pci_resource_t
)brace
id|pci_resource_t
suffix:semicolon
macro_line|#endif
DECL|union|bios32
r_union
id|bios32
(brace
r_struct
(brace
DECL|member|signature
r_int
r_int
id|signature
suffix:semicolon
multiline_comment|/* _32_ */
DECL|member|entry
r_int
r_int
id|entry
suffix:semicolon
multiline_comment|/* 32 bit physical address */
DECL|member|revision
r_int
r_char
id|revision
suffix:semicolon
multiline_comment|/* Revision level, 0 */
DECL|member|length
r_int
r_char
id|length
suffix:semicolon
multiline_comment|/* Length in paragraphs should be 01 */
DECL|member|checksum
r_int
r_char
id|checksum
suffix:semicolon
multiline_comment|/* All bytes must add up to zero */
DECL|member|reserved
r_int
r_char
id|reserved
(braket
l_int|5
)braket
suffix:semicolon
multiline_comment|/* Must be zero */
DECL|member|fields
)brace
id|fields
suffix:semicolon
DECL|member|chars
r_char
id|chars
(braket
l_int|16
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Physical address of the service directory.  I don&squot;t know if we&squot;re&n; * allowed to have more than one of these or not, so just in case&n; * we&squot;ll make bios32_init() take a memory start parameter and store&n; * the array there.&n; */
DECL|variable|bios32_entry
r_static
r_int
r_int
id|bios32_entry
op_assign
l_int|0
suffix:semicolon
r_static
r_struct
(brace
DECL|member|address
r_int
r_int
id|address
suffix:semicolon
DECL|member|segment
r_int
r_int
id|segment
suffix:semicolon
DECL|variable|bios32_indirect
)brace
id|bios32_indirect
op_assign
(brace
l_int|0
comma
id|KERNEL_CS
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
multiline_comment|/*&n; * Returns the entry point for the given service, NULL on error&n; */
DECL|macro|PCI_LIST_SIZE
mdefine_line|#define PCI_LIST_SIZE 32
DECL|variable|pci_list
r_static
id|pci_resource_t
id|pci_list
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|pci_index
r_static
r_int
id|pci_index
op_assign
l_int|0
suffix:semicolon
DECL|variable|pci_table
r_static
id|pci_resource_t
id|pci_table
(braket
id|PCI_LIST_SIZE
)braket
suffix:semicolon
DECL|function|bios32_service
r_static
r_int
r_int
id|bios32_service
c_func
(paren
r_int
r_int
id|service
)paren
(brace
r_int
r_char
id|return_code
suffix:semicolon
multiline_comment|/* %al */
r_int
r_int
id|address
suffix:semicolon
multiline_comment|/* %ebx */
r_int
r_int
id|length
suffix:semicolon
multiline_comment|/* %ecx */
r_int
r_int
id|entry
suffix:semicolon
multiline_comment|/* %edx */
id|__asm__
c_func
(paren
l_string|&quot;lcall (%%edi)&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|return_code
)paren
comma
l_string|&quot;=b&quot;
(paren
id|address
)paren
comma
l_string|&quot;=c&quot;
(paren
id|length
)paren
comma
l_string|&quot;=d&quot;
(paren
id|entry
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|service
)paren
comma
l_string|&quot;1&quot;
(paren
l_int|0
)paren
comma
l_string|&quot;D&quot;
(paren
op_amp
id|bios32_indirect
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|return_code
)paren
(brace
r_case
l_int|0
suffix:colon
r_return
id|address
op_plus
id|entry
suffix:semicolon
r_case
l_int|0x80
suffix:colon
multiline_comment|/* Not present */
id|printk
c_func
(paren
l_string|&quot;bios32_service(%ld) : not present&bslash;n&quot;
comma
id|service
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Shouldn&squot;t happen */
id|printk
c_func
(paren
l_string|&quot;bios32_service(%ld) : returned 0x%x, mail drew@colorado.edu&bslash;n&quot;
comma
id|service
comma
id|return_code
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|variable|pcibios_entry
r_static
r_int
id|pcibios_entry
op_assign
l_int|0
suffix:semicolon
r_static
r_struct
(brace
DECL|member|address
r_int
r_int
id|address
suffix:semicolon
DECL|member|segment
r_int
r_int
id|segment
suffix:semicolon
DECL|variable|pci_indirect
)brace
id|pci_indirect
op_assign
(brace
l_int|0
comma
id|KERNEL_CS
)brace
suffix:semicolon
r_void
id|NCR53c810_test
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|pcibios_init
r_static
r_int
r_int
id|pcibios_init
c_func
(paren
r_int
r_int
id|memory_start
comma
r_int
r_int
id|memory_end
)paren
(brace
r_int
r_int
id|signature
suffix:semicolon
r_int
r_char
id|present_status
suffix:semicolon
r_int
r_char
id|major_revision
suffix:semicolon
r_int
r_char
id|minor_revision
suffix:semicolon
r_int
id|pack
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pcibios_entry
op_assign
id|bios32_service
c_func
(paren
id|PCI_SERVICE
)paren
)paren
)paren
(brace
id|pci_indirect.address
op_assign
id|pcibios_entry
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;lcall (%%edi)&bslash;n&bslash;t&quot;
l_string|&quot;jc 1f&bslash;n&bslash;t&quot;
l_string|&quot;xor %%ah, %%ah&bslash;n&quot;
l_string|&quot;1:&bslash;tshl $8, %%eax&bslash;n&bslash;t&quot;
l_string|&quot;movw %%bx, %%ax&quot;
suffix:colon
l_string|&quot;=d&quot;
(paren
id|signature
)paren
comma
l_string|&quot;=a&quot;
(paren
id|pack
)paren
suffix:colon
l_string|&quot;1&quot;
(paren
id|PCIBIOS_PCI_BIOS_PRESENT
)paren
comma
l_string|&quot;D&quot;
(paren
op_amp
id|pci_indirect
)paren
suffix:colon
l_string|&quot;bx&quot;
comma
l_string|&quot;cx&quot;
)paren
suffix:semicolon
id|present_status
op_assign
(paren
id|pack
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|major_revision
op_assign
(paren
id|pack
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|minor_revision
op_assign
id|pack
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|present_status
op_logical_or
(paren
id|signature
op_ne
id|PCI_SIGNATURE
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;pcibios_init : %s : BIOS32 Service Directory says PCI BIOS is present,&bslash;n&quot;
l_string|&quot;&t;but PCI_BIOS_PRESENT subfunction fails with present status of 0x%x&bslash;n&quot;
l_string|&quot;&t;and signature of 0x%08lx (%c%c%c%c).  mail drew@Colorado.EDU&bslash;n&quot;
comma
(paren
id|signature
op_eq
id|PCI_SIGNATURE
)paren
ques
c_cond
l_string|&quot;WARNING&quot;
suffix:colon
l_string|&quot;ERROR&quot;
comma
id|present_status
comma
id|signature
comma
(paren
r_char
)paren
(paren
id|signature
op_rshift
l_int|0
)paren
comma
(paren
r_char
)paren
(paren
id|signature
op_rshift
l_int|8
)paren
comma
(paren
r_char
)paren
(paren
id|signature
op_rshift
l_int|16
)paren
comma
(paren
r_char
)paren
(paren
id|signature
op_rshift
l_int|24
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signature
op_ne
id|PCI_SIGNATURE
)paren
id|pcibios_entry
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pcibios_entry
)paren
(brace
id|printk
(paren
l_string|&quot;pcibios_init : PCI BIOS revision %x.%02x entry at 0x%lx&bslash;n&quot;
comma
id|major_revision
comma
id|minor_revision
comma
id|pcibios_entry
)paren
suffix:semicolon
)brace
)brace
macro_line|#if 0
id|NCR53c810_test
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
id|memory_start
suffix:semicolon
)brace
DECL|function|pcibios_present
r_int
id|pcibios_present
c_func
(paren
r_void
)paren
(brace
r_return
id|pcibios_entry
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|pcibios_find_class
r_int
id|pcibios_find_class
(paren
r_int
r_int
id|class_code
comma
r_int
r_int
id|index
comma
r_int
r_char
op_star
id|bus
comma
r_int
r_char
op_star
id|device_fn
)paren
(brace
r_int
r_int
id|bx
suffix:semicolon
r_int
r_int
id|ret
suffix:semicolon
id|__asm__
(paren
l_string|&quot;lcall (%%edi)&bslash;n&bslash;t&quot;
l_string|&quot;jc 1f&bslash;n&bslash;t&quot;
l_string|&quot;xor %%ah, %%ah&bslash;n&quot;
l_string|&quot;1:&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|bx
)paren
comma
l_string|&quot;=a&quot;
(paren
id|ret
)paren
suffix:colon
l_string|&quot;1&quot;
(paren
id|PCIBIOS_FIND_PCI_CLASS_CODE
)paren
comma
l_string|&quot;c&quot;
(paren
id|class_code
)paren
comma
l_string|&quot;S&quot;
(paren
(paren
r_int
)paren
id|index
)paren
comma
l_string|&quot;D&quot;
(paren
op_amp
id|pci_indirect
)paren
)paren
suffix:semicolon
op_star
id|bus
op_assign
(paren
id|bx
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
op_star
id|device_fn
op_assign
id|bx
op_amp
l_int|0xff
suffix:semicolon
r_return
(paren
r_int
)paren
(paren
id|ret
op_amp
l_int|0xff00
)paren
op_rshift
l_int|8
suffix:semicolon
)brace
DECL|function|pcibios_find_device
r_int
id|pcibios_find_device
(paren
r_int
r_int
id|vendor
comma
r_int
r_int
id|device_id
comma
r_int
r_int
id|index
comma
r_int
r_char
op_star
id|bus
comma
r_int
r_char
op_star
id|device_fn
)paren
(brace
r_int
r_int
id|bx
suffix:semicolon
r_int
r_int
id|ret
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;lcall (%%edi)&bslash;n&bslash;t&quot;
l_string|&quot;jc 1f&bslash;n&bslash;t&quot;
l_string|&quot;xor %%ah, %%ah&bslash;n&quot;
l_string|&quot;1:&quot;
suffix:colon
l_string|&quot;=b&quot;
(paren
id|bx
)paren
comma
l_string|&quot;=a&quot;
(paren
id|ret
)paren
suffix:colon
l_string|&quot;1&quot;
(paren
id|PCIBIOS_FIND_PCI_DEVICE
)paren
comma
l_string|&quot;c&quot;
(paren
id|device_id
)paren
comma
l_string|&quot;d&quot;
(paren
id|vendor
)paren
comma
l_string|&quot;S&quot;
(paren
(paren
r_int
)paren
id|index
)paren
comma
l_string|&quot;D&quot;
(paren
op_amp
id|pci_indirect
)paren
)paren
suffix:semicolon
op_star
id|bus
op_assign
(paren
id|bx
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
op_star
id|device_fn
op_assign
id|bx
op_amp
l_int|0xff
suffix:semicolon
r_return
(paren
r_int
)paren
(paren
id|ret
op_amp
l_int|0xff00
)paren
op_rshift
l_int|8
suffix:semicolon
)brace
DECL|function|pcibios_read_config_byte
r_int
id|pcibios_read_config_byte
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|device_fn
comma
r_int
r_char
id|where
comma
r_int
r_char
op_star
id|value
)paren
(brace
r_int
r_int
id|ret
suffix:semicolon
r_int
r_int
id|bx
op_assign
(paren
id|bus
op_lshift
l_int|8
)paren
op_or
id|device_fn
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;lcall (%%esi)&bslash;n&bslash;t&quot;
l_string|&quot;jc 1f&bslash;n&bslash;t&quot;
l_string|&quot;xor %%ah, %%ah&bslash;n&quot;
l_string|&quot;1:&quot;
suffix:colon
l_string|&quot;=c&quot;
(paren
op_star
id|value
)paren
comma
l_string|&quot;=a&quot;
(paren
id|ret
)paren
suffix:colon
l_string|&quot;1&quot;
(paren
id|PCIBIOS_READ_CONFIG_BYTE
)paren
comma
l_string|&quot;b&quot;
(paren
id|bx
)paren
comma
l_string|&quot;D&quot;
(paren
(paren
r_int
)paren
id|where
)paren
comma
l_string|&quot;S&quot;
(paren
op_amp
id|pci_indirect
)paren
)paren
suffix:semicolon
r_return
(paren
r_int
)paren
(paren
id|ret
op_amp
l_int|0xff00
)paren
op_rshift
l_int|8
suffix:semicolon
)brace
DECL|function|pcibios_read_config_word
r_int
id|pcibios_read_config_word
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|device_fn
comma
r_int
r_char
id|where
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_int
r_int
id|ret
suffix:semicolon
r_int
r_int
id|bx
op_assign
(paren
id|bus
op_lshift
l_int|8
)paren
op_or
id|device_fn
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;lcall (%%esi)&bslash;n&bslash;t&quot;
l_string|&quot;jc 1f&bslash;n&bslash;t&quot;
l_string|&quot;xor %%ah, %%ah&bslash;n&quot;
l_string|&quot;1:&quot;
suffix:colon
l_string|&quot;=c&quot;
(paren
op_star
id|value
)paren
comma
l_string|&quot;=a&quot;
(paren
id|ret
)paren
suffix:colon
l_string|&quot;1&quot;
(paren
id|PCIBIOS_READ_CONFIG_WORD
)paren
comma
l_string|&quot;b&quot;
(paren
id|bx
)paren
comma
l_string|&quot;D&quot;
(paren
(paren
r_int
)paren
id|where
)paren
comma
l_string|&quot;S&quot;
(paren
op_amp
id|pci_indirect
)paren
)paren
suffix:semicolon
r_return
(paren
r_int
)paren
(paren
id|ret
op_amp
l_int|0xff00
)paren
op_rshift
l_int|8
suffix:semicolon
)brace
DECL|function|pcibios_read_config_dword
r_int
id|pcibios_read_config_dword
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|device_fn
comma
r_int
r_char
id|where
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_int
r_int
id|ret
suffix:semicolon
r_int
r_int
id|bx
op_assign
(paren
id|bus
op_lshift
l_int|8
)paren
op_or
id|device_fn
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;lcall (%%esi)&bslash;n&bslash;t&quot;
l_string|&quot;jc 1f&bslash;n&bslash;t&quot;
l_string|&quot;xor %%ah, %%ah&bslash;n&quot;
l_string|&quot;1:&quot;
suffix:colon
l_string|&quot;=c&quot;
(paren
op_star
id|value
)paren
comma
l_string|&quot;=a&quot;
(paren
id|ret
)paren
suffix:colon
l_string|&quot;1&quot;
(paren
id|PCIBIOS_READ_CONFIG_DWORD
)paren
comma
l_string|&quot;b&quot;
(paren
id|bx
)paren
comma
l_string|&quot;D&quot;
(paren
(paren
r_int
)paren
id|where
)paren
comma
l_string|&quot;S&quot;
(paren
op_amp
id|pci_indirect
)paren
)paren
suffix:semicolon
r_return
(paren
r_int
)paren
(paren
id|ret
op_amp
l_int|0xff00
)paren
op_rshift
l_int|8
suffix:semicolon
)brace
DECL|function|pcibios_write_config_byte
r_int
id|pcibios_write_config_byte
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|device_fn
comma
r_int
r_char
id|where
comma
r_int
r_char
id|value
)paren
(brace
r_int
r_int
id|ret
suffix:semicolon
r_int
r_int
id|bx
op_assign
(paren
id|bus
op_lshift
l_int|8
)paren
op_or
id|device_fn
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;lcall (%%esi)&bslash;n&bslash;t&quot;
l_string|&quot;jc 1f&bslash;n&bslash;t&quot;
l_string|&quot;xor %%ah, %%ah&bslash;n&quot;
l_string|&quot;1:&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|ret
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|PCIBIOS_WRITE_CONFIG_BYTE
)paren
comma
l_string|&quot;c&quot;
(paren
id|value
)paren
comma
l_string|&quot;b&quot;
(paren
id|bx
)paren
comma
l_string|&quot;D&quot;
(paren
(paren
r_int
)paren
id|where
)paren
comma
l_string|&quot;S&quot;
(paren
op_amp
id|pci_indirect
)paren
)paren
suffix:semicolon
r_return
(paren
r_int
)paren
(paren
id|ret
op_amp
l_int|0xff00
)paren
op_rshift
l_int|8
suffix:semicolon
)brace
DECL|function|pcibios_write_config_word
r_int
id|pcibios_write_config_word
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|device_fn
comma
r_int
r_char
id|where
comma
r_int
r_int
id|value
)paren
(brace
r_int
r_int
id|ret
suffix:semicolon
r_int
r_int
id|bx
op_assign
(paren
id|bus
op_lshift
l_int|8
)paren
op_or
id|device_fn
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;lcall (%%esi)&bslash;n&bslash;t&quot;
l_string|&quot;jc 1f&bslash;n&bslash;t&quot;
l_string|&quot;xor %%ah, %%ah&bslash;n&quot;
l_string|&quot;1:&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|ret
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|PCIBIOS_WRITE_CONFIG_WORD
)paren
comma
l_string|&quot;c&quot;
(paren
id|value
)paren
comma
l_string|&quot;b&quot;
(paren
id|bx
)paren
comma
l_string|&quot;D&quot;
(paren
(paren
r_int
)paren
id|where
)paren
comma
l_string|&quot;S&quot;
(paren
op_amp
id|pci_indirect
)paren
)paren
suffix:semicolon
r_return
(paren
r_int
)paren
(paren
id|ret
op_amp
l_int|0xff00
)paren
op_rshift
l_int|8
suffix:semicolon
)brace
DECL|function|pcibios_write_config_dword
r_int
id|pcibios_write_config_dword
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|device_fn
comma
r_int
r_char
id|where
comma
r_int
r_int
id|value
)paren
(brace
r_int
r_int
id|ret
suffix:semicolon
r_int
r_int
id|bx
op_assign
(paren
id|bus
op_lshift
l_int|8
)paren
op_or
id|device_fn
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;lcall (%%esi)&bslash;n&bslash;t&quot;
l_string|&quot;jc 1f&bslash;n&bslash;t&quot;
l_string|&quot;xor %%ah, %%ah&bslash;n&quot;
l_string|&quot;1:&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|ret
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|PCIBIOS_WRITE_CONFIG_DWORD
)paren
comma
l_string|&quot;c&quot;
(paren
id|value
)paren
comma
l_string|&quot;b&quot;
(paren
id|bx
)paren
comma
l_string|&quot;D&quot;
(paren
(paren
r_int
)paren
id|where
)paren
comma
l_string|&quot;S&quot;
(paren
op_amp
id|pci_indirect
)paren
)paren
suffix:semicolon
r_return
(paren
r_int
)paren
(paren
id|ret
op_amp
l_int|0xff00
)paren
op_rshift
l_int|8
suffix:semicolon
)brace
DECL|function|NCR53c810_test
r_void
id|NCR53c810_test
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|bus
comma
id|device_fn
suffix:semicolon
r_int
r_int
id|index
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
r_char
id|row
comma
id|col
suffix:semicolon
r_int
r_int
id|val
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
l_int|4
suffix:semicolon
op_increment
id|index
)paren
(brace
id|ret
op_assign
id|pcibios_find_device
(paren
(paren
r_int
r_int
)paren
id|PCI_VENDOR_ID_NCR
comma
(paren
r_int
r_int
)paren
id|PCI_DEVICE_ID_NCR_53C810
comma
id|index
comma
op_amp
id|bus
comma
op_amp
id|device_fn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_break
suffix:semicolon
id|printk
(paren
l_string|&quot;ncr53c810 : at PCI bus %d, device %d, function %d.&quot;
comma
id|bus
comma
(paren
(paren
id|device_fn
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
)paren
comma
(paren
id|device_fn
op_amp
l_int|7
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|row
op_assign
l_int|0
suffix:semicolon
id|row
OL
l_int|0x3c
suffix:semicolon
id|row
op_add_assign
l_int|0x10
)paren
(brace
id|printk
(paren
l_string|&quot;&bslash;n&t;reg 0x%02x&t;&quot;
comma
id|row
)paren
suffix:semicolon
r_for
c_loop
(paren
id|col
op_assign
l_int|0
suffix:semicolon
id|col
OL
l_int|0x10
suffix:semicolon
id|col
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ret
op_assign
id|pcibios_read_config_dword
(paren
id|bus
comma
id|device_fn
comma
id|row
op_plus
id|col
comma
op_amp
id|val
)paren
)paren
)paren
id|printk
(paren
l_string|&quot;0x%08lx&t;  &quot;
comma
id|val
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;error 0x%02x &quot;
comma
id|ret
)paren
suffix:semicolon
)brace
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|pcibios_strerror
r_char
op_star
id|pcibios_strerror
(paren
r_int
id|error
)paren
(brace
r_static
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|error
)paren
(brace
r_case
id|PCIBIOS_SUCCESSFUL
suffix:colon
r_return
l_string|&quot;SUCCESSFUL&quot;
suffix:semicolon
r_case
id|PCIBIOS_FUNC_NOT_SUPPORTED
suffix:colon
r_return
l_string|&quot;FUNC_NOT_SUPPORTED&quot;
suffix:semicolon
r_case
id|PCIBIOS_BAD_VENDOR_ID
suffix:colon
r_return
l_string|&quot;SUCCESSFUL&quot;
suffix:semicolon
r_case
id|PCIBIOS_DEVICE_NOT_FOUND
suffix:colon
r_return
l_string|&quot;DEVICE_NOT_FOUND&quot;
suffix:semicolon
r_case
id|PCIBIOS_BAD_REGISTER_NUMBER
suffix:colon
r_return
l_string|&quot;BAD_REGISTER_NUMBER&quot;
suffix:semicolon
r_default
suffix:colon
id|sprintf
(paren
id|buf
comma
l_string|&quot;UNKNOWN RETURN 0x%x&quot;
comma
id|error
)paren
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
)brace
multiline_comment|/* Recognize multi-function device */
DECL|function|multi_function
r_int
id|multi_function
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|dev_fn
)paren
(brace
r_int
r_char
id|header
suffix:semicolon
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|dev_fn
comma
(paren
r_int
r_char
)paren
id|PCI_HEADER_TYPE
comma
op_amp
id|header
)paren
suffix:semicolon
r_return
(paren
id|header
op_amp
l_int|7
op_eq
l_int|7
)paren
suffix:semicolon
)brace
multiline_comment|/* Returns Interrupt register */
DECL|function|interrupt_decode
r_int
id|interrupt_decode
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|dev_fn
)paren
(brace
r_int
r_char
id|interrupt
suffix:semicolon
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|dev_fn
comma
(paren
r_int
r_char
)paren
id|PCI_INTERRUPT_LINE
comma
op_amp
id|interrupt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|interrupt
OG
l_int|16
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|interrupt
suffix:semicolon
)brace
multiline_comment|/* probe for being bist capable */
DECL|function|bist_probe
r_int
id|bist_probe
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|dev_fn
)paren
(brace
r_int
r_char
id|bist
suffix:semicolon
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|dev_fn
comma
(paren
r_int
r_char
)paren
id|PCI_BIST
comma
op_amp
id|bist
)paren
suffix:semicolon
r_return
(paren
id|bist
op_amp
id|PCI_BIST_CAPABLE
op_ne
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the chip revision */
DECL|function|revision_decode
r_int
id|revision_decode
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|dev_fn
)paren
(brace
r_int
r_char
id|revision
suffix:semicolon
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|dev_fn
comma
(paren
r_int
r_char
)paren
id|PCI_CLASS_REVISION
comma
op_amp
id|revision
)paren
suffix:semicolon
r_return
(paren
r_int
)paren
id|revision
suffix:semicolon
)brace
multiline_comment|/* Gives the Class code using the 16 higher bits */
multiline_comment|/* of the PCI_CLASS_REVISION configuration register */
DECL|function|class_decode
r_int
id|class_decode
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|dev_fn
)paren
(brace
r_struct
id|pci_class_type
id|pci_class
(braket
id|PCI_CLASS_NUM
)braket
op_assign
id|PCI_CLASS_TYPE
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
r_class
suffix:semicolon
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|dev_fn
comma
(paren
r_int
r_char
)paren
id|PCI_CLASS_REVISION
comma
op_amp
r_class
)paren
suffix:semicolon
r_class
op_assign
r_class
op_rshift
l_int|16
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PCI_CLASS_NUM
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
r_class
op_eq
id|pci_class
(braket
id|i
)braket
dot
id|class_id
)paren
r_break
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|device_decode
r_int
id|device_decode
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|dev_fn
comma
r_int
r_int
id|vendor_num
)paren
(brace
r_struct
id|pci_device_type
id|pci_device
(braket
id|PCI_DEVICE_NUM
)braket
op_assign
id|PCI_DEVICE_TYPE
suffix:semicolon
r_struct
id|pci_vendor_type
id|pci_vendor
(braket
id|PCI_VENDOR_NUM
)braket
op_assign
id|PCI_VENDOR_TYPE
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|device
suffix:semicolon
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|dev_fn
comma
(paren
r_int
r_char
)paren
id|PCI_DEVICE_ID
comma
op_amp
id|device
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PCI_DEVICE_NUM
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|device
op_eq
id|pci_device
(braket
id|i
)braket
dot
id|device_id
)paren
op_logical_and
(paren
id|pci_vendor
(braket
id|vendor_num
)braket
dot
id|vendor_id
op_eq
id|pci_device
(braket
id|i
)braket
dot
id|vendor_id
)paren
)paren
r_return
id|i
suffix:semicolon
r_return
l_int|0x10000
op_plus
(paren
r_int
)paren
id|device
suffix:semicolon
)brace
DECL|function|vendor_decode
r_int
id|vendor_decode
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|dev_fn
)paren
(brace
r_struct
id|pci_vendor_type
id|pci_vendor
(braket
id|PCI_VENDOR_NUM
)braket
op_assign
id|PCI_VENDOR_TYPE
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|vendor
suffix:semicolon
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|dev_fn
comma
(paren
r_int
r_char
)paren
id|PCI_VENDOR_ID
comma
op_amp
id|vendor
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PCI_VENDOR_NUM
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|vendor
op_eq
id|pci_vendor
(braket
id|i
)braket
dot
id|vendor_id
)paren
r_return
id|i
suffix:semicolon
r_return
l_int|0x10000
op_plus
(paren
r_int
)paren
id|vendor
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PCI_OPTIMIZE
DECL|function|bridge_decode
r_int
r_char
id|bridge_decode
c_func
(paren
r_int
id|device
)paren
(brace
r_struct
id|pci_device_type
id|pci_device
(braket
id|PCI_DEVICE_NUM
)braket
op_assign
id|PCI_DEVICE_TYPE
suffix:semicolon
r_return
(paren
id|pci_device
(braket
id|device
)braket
dot
id|bridge_id
)paren
suffix:semicolon
)brace
multiline_comment|/* Turn on/off PCI bridge optimisation. This should allow benchmarking. */
DECL|function|burst_bridge
r_void
id|burst_bridge
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|dev_fn
comma
r_int
r_char
id|pos
comma
r_int
id|turn_on
)paren
(brace
r_struct
id|bridge_mapping_type
id|bridge_mapping
(braket
l_int|5
op_star
id|BRIDGE_MAPPING_NUM
)braket
op_assign
id|BRIDGE_MAPPING_TYPE
suffix:semicolon
r_struct
id|optimisation_type
id|optimisation
(braket
id|OPTIMISATION_NUM
)braket
op_assign
id|OPTIMISATION_TYPE
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_char
id|val
suffix:semicolon
id|pos
op_mul_assign
id|OPTIMISATION_NUM
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PCI bridge optimisation.&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|OPTIMISATION_NUM
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;    %s : &quot;
comma
id|optimisation
(braket
id|i
)braket
dot
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bridge_mapping
(braket
id|pos
op_plus
id|i
)braket
dot
id|address
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;Not supported.&quot;
)paren
suffix:semicolon
r_else
(brace
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|dev_fn
comma
id|bridge_mapping
(braket
id|pos
op_plus
id|i
)braket
dot
id|address
comma
op_amp
id|val
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|val
op_amp
id|bridge_mapping
(braket
id|pos
op_plus
id|i
)braket
dot
id|mask
)paren
op_eq
id|bridge_mapping
(braket
id|pos
op_plus
id|i
)braket
dot
id|value
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s.&quot;
comma
id|optimisation
(braket
id|i
)braket
dot
id|on
)paren
suffix:semicolon
r_if
c_cond
(paren
id|turn_on
op_eq
l_int|0
)paren
(brace
id|pcibios_write_config_byte
c_func
(paren
id|bus
comma
id|dev_fn
comma
id|bridge_mapping
(braket
id|pos
op_plus
id|i
)braket
dot
id|address
comma
(paren
id|val
op_or
id|bridge_mapping
(braket
id|pos
op_plus
id|i
)braket
dot
id|mask
)paren
op_minus
id|bridge_mapping
(braket
id|pos
op_plus
id|i
)braket
dot
id|value
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Changed! now %s.&quot;
comma
id|optimisation
(braket
id|i
)braket
dot
id|off
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s.&quot;
comma
id|optimisation
(braket
id|i
)braket
dot
id|off
)paren
suffix:semicolon
r_if
c_cond
(paren
id|turn_on
op_eq
l_int|1
)paren
(brace
id|pcibios_write_config_byte
c_func
(paren
id|bus
comma
id|dev_fn
comma
id|bridge_mapping
(braket
id|pos
op_plus
id|i
)braket
dot
id|address
comma
(paren
id|val
op_amp
(paren
l_int|0xff
op_minus
id|bridge_mapping
(braket
id|pos
op_plus
id|i
)braket
dot
id|mask
)paren
)paren
op_plus
id|bridge_mapping
(braket
id|pos
op_plus
id|i
)braket
dot
id|value
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Changed! now %s.&quot;
comma
id|optimisation
(braket
id|i
)braket
dot
id|on
)paren
suffix:semicolon
)brace
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* In future version in case we detect a PCI to PCi bridge, we will go&n;for a recursive device search*/
DECL|function|probe_devices
r_void
id|probe_devices
c_func
(paren
r_int
r_char
id|bus
)paren
(brace
r_int
r_int
id|res
suffix:semicolon
r_int
r_char
id|dev_fn
suffix:semicolon
multiline_comment|/* For a mysterious reason, my PC crash if I try to probe device 31 function 7  */
multiline_comment|/* (i.e. dev_fn=0xff) It can be a bug in my BIOS, or I haven&squot;t understood all about */
multiline_comment|/* PCI */
r_for
c_loop
(paren
id|dev_fn
op_assign
l_int|0x0
suffix:semicolon
id|dev_fn
OL
l_int|0xff
suffix:semicolon
id|dev_fn
op_increment
)paren
(brace
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|dev_fn
comma
(paren
r_int
r_char
)paren
id|PCI_CLASS_REVISION
comma
op_amp
id|res
)paren
suffix:semicolon
multiline_comment|/* First we won&squot;t try to talk to non_present chip */
multiline_comment|/* Second, we get rid of non multi-function device that seems to be lazy  */
multiline_comment|/* and not fully decode the function number */
r_if
c_cond
(paren
(paren
id|res
op_ne
l_int|0xffffffff
)paren
op_logical_and
(paren
(paren
(paren
id|dev_fn
op_amp
l_int|7
)paren
op_eq
l_int|0
)paren
op_logical_or
id|multi_function
c_func
(paren
id|bus
comma
id|dev_fn
)paren
)paren
)paren
(brace
id|add_pci_resource
c_func
(paren
id|bus
comma
id|dev_fn
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|probe_pci
r_void
id|probe_pci
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|pcibios_present
c_func
(paren
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ProbePci PCI bios not detected.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Probing PCI hardware.&bslash;n&quot;
)paren
suffix:semicolon
id|probe_devices
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Function to add a resource to the pci list...&n; */
DECL|function|add_pci_resource
r_void
id|add_pci_resource
c_func
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|dev_fn
)paren
(brace
id|pci_resource_t
op_star
id|new_pci
suffix:semicolon
id|pci_resource_t
op_star
id|temp
suffix:semicolon
r_int
id|vendor_id
comma
id|device_id
suffix:semicolon
macro_line|#ifdef CONFIG_PCI_OPTIMIZE
r_int
r_char
id|bridge_id
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Verify if we know about this chip. If not, print Vendor &amp; Device id&n;&t; * + ask for report.&n;&t; */
id|vendor_id
op_assign
id|vendor_decode
c_func
(paren
id|bus
comma
id|dev_fn
)paren
suffix:semicolon
id|device_id
op_assign
id|device_decode
c_func
(paren
id|bus
comma
id|dev_fn
comma
id|vendor_id
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|device_id
op_amp
l_int|0x10000
)paren
op_eq
l_int|0x10000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unknown PCI device. PCI Vendor id=%x. PCI Device id=%x.&bslash;n&quot;
comma
id|vendor_id
op_amp
l_int|0xffff
comma
id|device_id
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;PLEASE MAIL POTTER@CAO-VLSI.IBP.FR your hardware description and /proc/pci.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the PCI agent is a known bridge, then configure it.&n;&t; */
macro_line|#ifdef CONFIG_PCI_OPTIMIZE
id|bridge_id
op_assign
id|bridge_decode
c_func
(paren
id|device_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bridge_id
op_ne
l_int|0xff
)paren
(brace
id|burst_bridge
c_func
(paren
id|bus
comma
id|dev_fn
comma
id|bridge_id
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Burst bridge */
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Request and verify allocation of kernel RAM&n;&t; */
r_if
c_cond
(paren
id|pci_index
OG
id|PCI_LIST_SIZE
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;PCI resource list full.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|new_pci
op_assign
op_amp
id|pci_table
(braket
id|pci_index
)braket
suffix:semicolon
id|pci_index
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Enter the new node into the list....&n;&t; *&n;&t; */
r_if
c_cond
(paren
id|pci_list.next
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|temp
op_assign
id|pci_list.next
suffix:semicolon
(paren
id|temp-&gt;next
)paren
suffix:semicolon
id|temp
op_assign
id|temp-&gt;next
)paren
(brace
multiline_comment|/* nothing */
suffix:semicolon
)brace
id|temp-&gt;next
op_assign
id|new_pci
suffix:semicolon
)brace
r_else
id|pci_list.next
op_assign
id|new_pci
suffix:semicolon
multiline_comment|/*&n;&t; * Set the information for the node&n;&t; */
id|new_pci-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|new_pci-&gt;bus
op_assign
id|bus
suffix:semicolon
id|new_pci-&gt;dev_fn
op_assign
id|dev_fn
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|get_pci_list
r_int
id|get_pci_list
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_int
id|pr
comma
id|length
suffix:semicolon
id|pci_resource_t
op_star
id|temp
op_assign
id|pci_list.next
suffix:semicolon
r_struct
id|pci_class_type
id|pci_class
(braket
id|PCI_CLASS_NUM
)braket
op_assign
id|PCI_CLASS_TYPE
suffix:semicolon
r_struct
id|pci_vendor_type
id|pci_vendor
(braket
id|PCI_VENDOR_NUM
)braket
op_assign
id|PCI_VENDOR_TYPE
suffix:semicolon
r_struct
id|pci_device_type
id|pci_device
(braket
id|PCI_DEVICE_NUM
)braket
op_assign
id|PCI_DEVICE_TYPE
suffix:semicolon
id|pr
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;PCI devices found :&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|length
op_assign
id|pr
suffix:semicolon
(paren
id|temp
)paren
op_logical_and
(paren
id|length
OL
l_int|4000
)paren
suffix:semicolon
id|temp
op_assign
id|temp-&gt;next
)paren
(brace
id|pr
op_assign
id|vendor_decode
c_func
(paren
id|temp-&gt;bus
comma
id|temp-&gt;dev_fn
)paren
suffix:semicolon
id|length
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|length
comma
l_string|&quot;Bus %2d Device %3d Function %2d.&bslash;n&quot;
comma
(paren
r_int
)paren
id|temp-&gt;bus
comma
(paren
r_int
)paren
(paren
(paren
id|temp-&gt;dev_fn
op_amp
l_int|0xf8
)paren
op_rshift
l_int|3
)paren
comma
(paren
r_int
)paren
(paren
id|temp-&gt;dev_fn
op_amp
l_int|7
)paren
)paren
suffix:semicolon
id|length
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|length
comma
l_string|&quot;    %s : %s %s (rev %d). &quot;
comma
id|pci_class
(braket
id|class_decode
c_func
(paren
id|temp-&gt;bus
comma
id|temp-&gt;dev_fn
)paren
)braket
dot
id|class_name
comma
id|pci_vendor
(braket
id|pr
)braket
dot
id|vendor_name
comma
id|pci_device
(braket
id|device_decode
c_func
(paren
id|temp-&gt;bus
comma
id|temp-&gt;dev_fn
comma
id|pr
)paren
)braket
dot
id|device_name
comma
id|revision_decode
c_func
(paren
id|temp-&gt;bus
comma
id|temp-&gt;dev_fn
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bist_probe
c_func
(paren
id|temp-&gt;bus
comma
id|temp-&gt;dev_fn
)paren
)paren
id|length
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|length
comma
l_string|&quot;BIST capable. &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pr
op_assign
id|interrupt_decode
c_func
(paren
id|temp-&gt;bus
comma
id|temp-&gt;dev_fn
)paren
)paren
op_ne
l_int|0
)paren
id|length
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|length
comma
l_string|&quot;8259&squot;s interrupt %d.&quot;
comma
id|pr
)paren
suffix:semicolon
id|length
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|length
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|temp
)paren
id|length
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|length
comma
l_string|&quot;4K limit reached!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
macro_line|#endif
DECL|function|bios32_init
r_int
r_int
id|bios32_init
c_func
(paren
r_int
r_int
id|memory_start
comma
r_int
r_int
id|memory_end
)paren
(brace
r_union
id|bios32
op_star
id|check
suffix:semicolon
r_int
r_char
id|sum
suffix:semicolon
r_int
id|i
comma
id|length
suffix:semicolon
multiline_comment|/*&n;&t; * Follow the standard procedure for locating the BIOS32 Service&n;&t; * directory by scanning the permissible address range from&n;&t; * 0xe0000 through 0xfffff for a valid BIOS32 structure.&n;&t; *&n;&t; * The PCI BIOS doesn&squot;t seem to work too well on many machines,&n;&t; * so we disable this unless it&squot;s really needed (NCR SCSI driver)&n;&t; */
r_for
c_loop
(paren
id|check
op_assign
(paren
r_union
id|bios32
op_star
)paren
l_int|0xe0000
suffix:semicolon
id|check
op_le
(paren
r_union
id|bios32
op_star
)paren
l_int|0xffff0
suffix:semicolon
op_increment
id|check
)paren
(brace
r_if
c_cond
(paren
id|check-&gt;fields.signature
op_ne
id|BIOS32_SIGNATURE
)paren
r_continue
suffix:semicolon
id|length
op_assign
id|check-&gt;fields.length
op_star
l_int|16
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|length
)paren
r_continue
suffix:semicolon
id|sum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|length
suffix:semicolon
op_increment
id|i
)paren
id|sum
op_add_assign
id|check-&gt;chars
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|sum
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|check-&gt;fields.revision
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bios32_init : unsupported revision %d at 0x%p, mail drew@colorado.edu&bslash;n&quot;
comma
id|check-&gt;fields.revision
comma
id|check
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;bios32_init : BIOS32 Service Directory structure at 0x%p&bslash;n&quot;
comma
id|check
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bios32_entry
)paren
(brace
id|bios32_indirect.address
op_assign
id|bios32_entry
op_assign
id|check-&gt;fields.entry
suffix:semicolon
id|printk
(paren
l_string|&quot;bios32_init : BIOS32 Service Directory entry at 0x%lx&bslash;n&quot;
comma
id|bios32_entry
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;bios32_init : multiple entries, mail drew@colorado.edu&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Jeremy Fitzhardinge reports at least one PCI BIOS&n;&t;&t;&t; * with two different service directories, and as both&n;&t;&t;&t; * worked for him, we&squot;ll just mention the fact, and&n;&t;&t;&t; * not actually disallow it..&n;&t;&t;&t; */
macro_line|#if 0
r_return
id|memory_start
suffix:semicolon
macro_line|#endif
)brace
)brace
macro_line|#ifdef CONFIG_PCI
r_if
c_cond
(paren
id|bios32_entry
)paren
(brace
id|memory_start
op_assign
id|pcibios_init
(paren
id|memory_start
comma
id|memory_end
)paren
suffix:semicolon
id|probe_pci
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
id|memory_start
suffix:semicolon
)brace
eof
