multiline_comment|/*  Generic MTRR (Memory Type Range Register) driver.&n;&n;    Copyright (C) 1997-1998  Richard Gooch&n;&n;    This library is free software; you can redistribute it and/or&n;    modify it under the terms of the GNU Library General Public&n;    License as published by the Free Software Foundation; either&n;    version 2 of the License, or (at your option) any later version.&n;&n;    This library is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n;    Library General Public License for more details.&n;&n;    You should have received a copy of the GNU Library General Public&n;    License along with this library; if not, write to the Free&n;    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n;    Richard Gooch may be reached by email at  rgooch@atnf.csiro.au&n;    The postal address is:&n;      Richard Gooch, c/o ATNF, P. O. Box 76, Epping, N.S.W., 2121, Australia.&n;&n;    Source: &quot;Pentium Pro Family Developer&squot;s Manual, Volume 3:&n;    Operating System Writer&squot;s Guide&quot; (Intel document number 242692),&n;    section 11.11.7&n;&n;    ChangeLog&n;&n;    Prehistory Martin Tischh&#xfffd;user &lt;martin@ikcbarka.fzk.de&gt;&n;&t;       Initial register-setting code (from proform-1.0).&n;    19971216   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Original version for /proc/mtrr interface, SMP-safe.&n;  v1.0&n;    19971217   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Bug fix for ioctls()&squot;s.&n;&t;       Added sample code in Documentation/mtrr.txt&n;  v1.1&n;    19971218   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Disallow overlapping regions.&n;    19971219   Jens Maurer &lt;jmaurer@menuett.rhein-main.de&gt;&n;               Register-setting fixups.&n;  v1.2&n;    19971222   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fixups for kernel 2.1.75.&n;  v1.3&n;    19971229   David Wragg &lt;dpw@doc.ic.ac.uk&gt;&n;               Register-setting fixups and conformity with Intel conventions.&n;    19971229   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Cosmetic changes and wrote this ChangeLog ;-)&n;    19980106   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fixups for kernel 2.1.78.&n;  v1.4&n;    19980119   David Wragg &lt;dpw@doc.ic.ac.uk&gt;&n;               Included passive-release enable code (elsewhere in PCI setup).&n;  v1.5&n;    19980131   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Replaced global kernel lock with private spinlock.&n;  v1.6&n;    19980201   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Added wait for other CPUs to complete changes.&n;  v1.7&n;    19980202   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Bug fix in definition of &lt;set_mtrr&gt; for UP.&n;  v1.8&n;    19980319   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fixups for kernel 2.1.90.&n;    19980323   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Move SMP BIOS fixup before secondary CPUs call &lt;calibrate_delay&gt;&n;  v1.9&n;    19980325   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fixed test for overlapping regions: confused by adjacent regions&n;    19980326   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Added wbinvd in &lt;set_mtrr_prepare&gt;.&n;    19980401   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Bug fix for non-SMP compilation.&n;    19980418   David Wragg &lt;dpw@doc.ic.ac.uk&gt;&n;               Fixed-MTRR synchronisation for SMP and use atomic operations&n;&t;       instead of spinlocks.&n;    19980418   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Differentiate different MTRR register classes for BIOS fixup.&n;  v1.10&n;    19980419   David Wragg &lt;dpw@doc.ic.ac.uk&gt;&n;&t;       Bug fix in variable MTRR synchronisation.&n;  v1.11&n;    19980419   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixups for kernel 2.1.97.&n;  v1.12&n;    19980421   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Safer synchronisation across CPUs when changing MTRRs.&n;  v1.13&n;    19980423   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Bugfix for SMP systems without MTRR support.&n;  v1.14&n;    19980427   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Trap calls to &lt;mtrr_add&gt; and &lt;mtrr_del&gt; on non-MTRR machines.&n;  v1.15&n;    19980427   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Use atomic bitops for setting SMP change mask.&n;  v1.16&n;    19980428   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed spurious diagnostic message.&n;  v1.17&n;    19980429   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Moved register-setting macros into this file.&n;&t;       Moved setup code from init/main.c to i386-specific areas.&n;  v1.18&n;    19980502   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Moved MTRR detection outside conditionals in &lt;mtrr_init&gt;.&n;  v1.19&n;    19980502   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Documentation improvement: mention Pentium II and AGP.&n;  v1.20&n;    19980521   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Only manipulate interrupt enable flag on local CPU.&n;&t;       Allow enclosed uncachable regions.&n;  v1.21&n;*/
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
DECL|macro|MTRR_NEED_STRINGS
mdefine_line|#define MTRR_NEED_STRINGS
macro_line|#include &lt;asm/mtrr.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/smp_lock.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
DECL|macro|MTRR_VERSION
mdefine_line|#define MTRR_VERSION            &quot;1.21 (19980521)&quot;
DECL|macro|TRUE
mdefine_line|#define TRUE  1
DECL|macro|FALSE
mdefine_line|#define FALSE 0
DECL|macro|X86_FEATURE_MTRR
mdefine_line|#define X86_FEATURE_MTRR&t;0x1000&t;&t;/* memory type registers */
DECL|macro|MTRRcap_MSR
mdefine_line|#define MTRRcap_MSR     0x0fe
DECL|macro|MTRRdefType_MSR
mdefine_line|#define MTRRdefType_MSR 0x2ff
DECL|macro|MTRRphysBase_MSR
mdefine_line|#define MTRRphysBase_MSR(reg) (0x200 + 2 * (reg))
DECL|macro|MTRRphysMask_MSR
mdefine_line|#define MTRRphysMask_MSR(reg) (0x200 + 2 * (reg) + 1)
DECL|macro|NUM_FIXED_RANGES
mdefine_line|#define NUM_FIXED_RANGES 88
DECL|macro|MTRRfix64K_00000_MSR
mdefine_line|#define MTRRfix64K_00000_MSR 0x250
DECL|macro|MTRRfix16K_80000_MSR
mdefine_line|#define MTRRfix16K_80000_MSR 0x258
DECL|macro|MTRRfix16K_A0000_MSR
mdefine_line|#define MTRRfix16K_A0000_MSR 0x259
DECL|macro|MTRRfix4K_C0000_MSR
mdefine_line|#define MTRRfix4K_C0000_MSR 0x268
DECL|macro|MTRRfix4K_C8000_MSR
mdefine_line|#define MTRRfix4K_C8000_MSR 0x269
DECL|macro|MTRRfix4K_D0000_MSR
mdefine_line|#define MTRRfix4K_D0000_MSR 0x26a
DECL|macro|MTRRfix4K_D8000_MSR
mdefine_line|#define MTRRfix4K_D8000_MSR 0x26b
DECL|macro|MTRRfix4K_E0000_MSR
mdefine_line|#define MTRRfix4K_E0000_MSR 0x26c
DECL|macro|MTRRfix4K_E8000_MSR
mdefine_line|#define MTRRfix4K_E8000_MSR 0x26d
DECL|macro|MTRRfix4K_F0000_MSR
mdefine_line|#define MTRRfix4K_F0000_MSR 0x26e
DECL|macro|MTRRfix4K_F8000_MSR
mdefine_line|#define MTRRfix4K_F8000_MSR 0x26f
macro_line|#ifdef __SMP__
DECL|macro|MTRR_CHANGE_MASK_FIXED
macro_line|#  define MTRR_CHANGE_MASK_FIXED     0x01
DECL|macro|MTRR_CHANGE_MASK_VARIABLE
macro_line|#  define MTRR_CHANGE_MASK_VARIABLE  0x02
DECL|macro|MTRR_CHANGE_MASK_DEFTYPE
macro_line|#  define MTRR_CHANGE_MASK_DEFTYPE   0x04
macro_line|#endif
multiline_comment|/* In the processor&squot;s MTRR interface, the MTRR type is always held in&n;   an 8 bit field: */
DECL|typedef|mtrr_type
r_typedef
id|u8
id|mtrr_type
suffix:semicolon
DECL|macro|LINE_SIZE
mdefine_line|#define LINE_SIZE      80
DECL|macro|JIFFIE_TIMEOUT
mdefine_line|#define JIFFIE_TIMEOUT 100
macro_line|#ifdef __SMP__
DECL|macro|set_mtrr
macro_line|#  define set_mtrr(reg,base,size,type) set_mtrr_smp (reg, base, size, type)
macro_line|#else
DECL|macro|set_mtrr
macro_line|#  define set_mtrr(reg,base,size,type) set_mtrr_up (reg, base, size, type,TRUE)
macro_line|#endif
macro_line|#ifndef CONFIG_PROC_FS
DECL|macro|compute_ascii
macro_line|#  define compute_ascii() while (0)
macro_line|#endif
macro_line|#ifdef CONFIG_PROC_FS
DECL|variable|ascii_buffer
r_static
r_char
op_star
id|ascii_buffer
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|ascii_buf_bytes
r_static
r_int
r_int
id|ascii_buf_bytes
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|variable|usage_table
r_static
r_int
r_int
op_star
id|usage_table
op_assign
l_int|NULL
suffix:semicolon
macro_line|#ifdef __SMP__
DECL|variable|main_lock
r_static
id|spinlock_t
id|main_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
macro_line|#endif
multiline_comment|/*  Private functions  */
macro_line|#ifdef CONFIG_PROC_FS
r_static
r_void
id|compute_ascii
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
DECL|struct|set_mtrr_context
r_struct
id|set_mtrr_context
(brace
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|deftype_lo
r_int
r_int
id|deftype_lo
suffix:semicolon
DECL|member|deftype_hi
r_int
r_int
id|deftype_hi
suffix:semicolon
DECL|member|cr4val
r_int
r_int
id|cr4val
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Access to machine-specific registers (available on 586 and better only)&n; * Note: the rd* operations modify the parameters directly (without using&n; * pointer indirection), this allows gcc to optimize better&n; */
DECL|macro|rdmsr
mdefine_line|#define rdmsr(msr,val1,val2) &bslash;&n;       __asm__ __volatile__(&quot;rdmsr&quot; &bslash;&n;&t;&t;&t;    : &quot;=a&quot; (val1), &quot;=d&quot; (val2) &bslash;&n;&t;&t;&t;    : &quot;c&quot; (msr))
DECL|macro|wrmsr
mdefine_line|#define wrmsr(msr,val1,val2) &bslash;&n;     __asm__ __volatile__(&quot;wrmsr&quot; &bslash;&n;&t;&t;&t;  : /* no outputs */ &bslash;&n;&t;&t;&t;  : &quot;c&quot; (msr), &quot;a&quot; (val1), &quot;d&quot; (val2))
DECL|macro|rdtsc
mdefine_line|#define rdtsc(low,high) &bslash;&n;     __asm__ __volatile__(&quot;rdtsc&quot; : &quot;=a&quot; (low), &quot;=d&quot; (high))
DECL|macro|rdpmc
mdefine_line|#define rdpmc(counter,low,high) &bslash;&n;     __asm__ __volatile__(&quot;rdpmc&quot; &bslash;&n;&t;&t;&t;  : &quot;=a&quot; (low), &quot;=d&quot; (high) &bslash;&n;&t;&t;&t;  : &quot;c&quot; (counter))
multiline_comment|/* Put the processor into a state where MTRRs can be safely set. */
DECL|function|set_mtrr_prepare
r_static
r_void
id|set_mtrr_prepare
c_func
(paren
r_struct
id|set_mtrr_context
op_star
id|ctxt
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
multiline_comment|/* disable interrupts locally */
id|__save_flags
(paren
id|ctxt-&gt;flags
)paren
suffix:semicolon
id|__cli
(paren
)paren
suffix:semicolon
multiline_comment|/* save value of CR4 and clear Page Global Enable (bit 7) */
id|asm
r_volatile
(paren
l_string|&quot;movl  %%cr4, %0&bslash;n&bslash;t&quot;
l_string|&quot;movl  %0, %1&bslash;n&bslash;t&quot;
l_string|&quot;andb  $0x7f, %b1&bslash;n&bslash;t&quot;
l_string|&quot;movl  %1, %%cr4&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ctxt-&gt;cr4val
)paren
comma
l_string|&quot;=q&quot;
(paren
id|tmp
)paren
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/* disable and flush caches. Note that wbinvd flushes the TLBs as&n;       a side-effect. */
id|asm
r_volatile
(paren
l_string|&quot;movl  %%cr0, %0&bslash;n&bslash;t&quot;
l_string|&quot;orl   $0x40000000, %0&bslash;n&bslash;t&quot;
l_string|&quot;wbinvd&bslash;n&bslash;t&quot;
l_string|&quot;movl  %0, %%cr0&bslash;n&bslash;t&quot;
l_string|&quot;wbinvd&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/* disable MTRRs, and set the default type to uncached. */
id|rdmsr
c_func
(paren
id|MTRRdefType_MSR
comma
id|ctxt-&gt;deftype_lo
comma
id|ctxt-&gt;deftype_hi
)paren
suffix:semicolon
id|wrmsr
c_func
(paren
id|MTRRdefType_MSR
comma
id|ctxt-&gt;deftype_lo
op_amp
l_int|0xf300UL
comma
id|ctxt-&gt;deftype_hi
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function set_mtrr_prepare  */
multiline_comment|/* Restore the processor after a set_mtrr_prepare */
DECL|function|set_mtrr_done
r_static
r_void
id|set_mtrr_done
c_func
(paren
r_struct
id|set_mtrr_context
op_star
id|ctxt
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
multiline_comment|/* flush caches and TLBs */
id|asm
r_volatile
(paren
l_string|&quot;wbinvd&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/* restore MTRRdefType */
id|wrmsr
c_func
(paren
id|MTRRdefType_MSR
comma
id|ctxt-&gt;deftype_lo
comma
id|ctxt-&gt;deftype_hi
)paren
suffix:semicolon
multiline_comment|/* enable caches */
id|asm
r_volatile
(paren
l_string|&quot;movl  %%cr0, %0&bslash;n&bslash;t&quot;
l_string|&quot;andl  $0xbfffffff, %0&bslash;n&bslash;t&quot;
l_string|&quot;movl  %0, %%cr0&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/* restore value of CR4 */
id|asm
r_volatile
(paren
l_string|&quot;movl  %0, %%cr4&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|ctxt-&gt;cr4val
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/* re-enable interrupts locally (if enabled previously) */
id|__restore_flags
(paren
id|ctxt-&gt;flags
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function set_mtrr_done  */
multiline_comment|/* this function returns the number of variable MTRRs */
DECL|function|get_num_var_ranges
r_static
r_int
r_int
id|get_num_var_ranges
(paren
r_void
)paren
(brace
r_int
r_int
id|config
comma
id|dummy
suffix:semicolon
id|rdmsr
c_func
(paren
id|MTRRcap_MSR
comma
id|config
comma
id|dummy
)paren
suffix:semicolon
r_return
(paren
id|config
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function get_num_var_ranges  */
multiline_comment|/* non-zero if we have the write-combining memory type. */
DECL|function|have_wrcomb
r_static
r_int
id|have_wrcomb
(paren
r_void
)paren
(brace
r_int
r_int
id|config
comma
id|dummy
suffix:semicolon
id|rdmsr
c_func
(paren
id|MTRRcap_MSR
comma
id|config
comma
id|dummy
)paren
suffix:semicolon
r_return
(paren
id|config
op_amp
(paren
l_int|1
op_lshift
l_int|10
)paren
)paren
suffix:semicolon
)brace
DECL|function|get_mtrr
r_static
r_void
id|get_mtrr
(paren
r_int
r_int
id|reg
comma
r_int
r_int
op_star
id|base
comma
r_int
r_int
op_star
id|size
comma
id|mtrr_type
op_star
id|type
)paren
(brace
r_int
r_int
id|dummy
comma
id|mask_lo
comma
id|base_lo
suffix:semicolon
id|rdmsr
c_func
(paren
id|MTRRphysMask_MSR
c_func
(paren
id|reg
)paren
comma
id|mask_lo
comma
id|dummy
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mask_lo
op_amp
l_int|0x800
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Invalid (i.e. free) range. */
op_star
id|base
op_assign
l_int|0
suffix:semicolon
op_star
id|size
op_assign
l_int|0
suffix:semicolon
op_star
id|type
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rdmsr
c_func
(paren
id|MTRRphysBase_MSR
c_func
(paren
id|reg
)paren
comma
id|base_lo
comma
id|dummy
)paren
suffix:semicolon
multiline_comment|/* We ignore the extra address bits (32-35). If someone wants to&n;       run x86 Linux on a machine with &gt;4GB memory, this will be the&n;       least of their problems. */
multiline_comment|/* Clean up mask_lo so it gives the real address mask. */
id|mask_lo
op_assign
(paren
id|mask_lo
op_amp
l_int|0xfffff000UL
)paren
suffix:semicolon
multiline_comment|/* This works correctly if size is a power of two, i.e. a&n;       contiguous range. */
op_star
id|size
op_assign
op_complement
(paren
id|mask_lo
op_minus
l_int|1
)paren
suffix:semicolon
op_star
id|base
op_assign
(paren
id|base_lo
op_amp
l_int|0xfffff000UL
)paren
suffix:semicolon
op_star
id|type
op_assign
(paren
id|base_lo
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function get_mtrr  */
DECL|function|set_mtrr_up
r_static
r_void
id|set_mtrr_up
(paren
r_int
r_int
id|reg
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
id|mtrr_type
id|type
comma
r_int
id|do_safe
)paren
multiline_comment|/*  [SUMMARY] Set variable MTRR register on the local CPU.&n;    &lt;reg&gt; The register to set.&n;    &lt;base&gt; The base address of the region.&n;    &lt;size&gt; The size of the region. If this is 0 the region is disabled.&n;    &lt;type&gt; The type of the region.&n;    &lt;do_safe&gt; If TRUE, do the change safely. If FALSE, safety measures should&n;    be done externally.&n;*/
(brace
r_struct
id|set_mtrr_context
id|ctxt
suffix:semicolon
r_if
c_cond
(paren
id|do_safe
)paren
id|set_mtrr_prepare
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
(brace
multiline_comment|/* The invalid bit is kept in the mask, so we simply clear the&n;&t;   relevant mask register to disable a range. */
id|wrmsr
(paren
id|MTRRphysMask_MSR
(paren
id|reg
)paren
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|wrmsr
(paren
id|MTRRphysBase_MSR
(paren
id|reg
)paren
comma
id|base
op_or
id|type
comma
l_int|0
)paren
suffix:semicolon
id|wrmsr
(paren
id|MTRRphysMask_MSR
(paren
id|reg
)paren
comma
op_complement
(paren
id|size
op_minus
l_int|1
)paren
op_or
l_int|0x800
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_safe
)paren
id|set_mtrr_done
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function set_mtrr_up  */
macro_line|#ifdef __SMP__
DECL|struct|mtrr_var_range
r_struct
id|mtrr_var_range
(brace
DECL|member|base_lo
r_int
r_int
id|base_lo
suffix:semicolon
DECL|member|base_hi
r_int
r_int
id|base_hi
suffix:semicolon
DECL|member|mask_lo
r_int
r_int
id|mask_lo
suffix:semicolon
DECL|member|mask_hi
r_int
r_int
id|mask_hi
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Get the MSR pair relating to a var range. */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|get_mtrr_var_range
(paren
r_int
r_int
id|index
comma
r_struct
id|mtrr_var_range
op_star
id|vr
)paren
)paren
(brace
id|rdmsr
(paren
id|MTRRphysBase_MSR
(paren
id|index
)paren
comma
id|vr-&gt;base_lo
comma
id|vr-&gt;base_hi
)paren
suffix:semicolon
id|rdmsr
(paren
id|MTRRphysMask_MSR
(paren
id|index
)paren
comma
id|vr-&gt;mask_lo
comma
id|vr-&gt;mask_hi
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function get_mtrr_var_range  */
multiline_comment|/* Set the MSR pair relating to a var range. Returns TRUE if&n;   changes are made. */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|set_mtrr_var_range_testing
(paren
r_int
r_int
id|index
comma
r_struct
id|mtrr_var_range
op_star
id|vr
)paren
)paren
(brace
r_int
r_int
id|lo
comma
id|hi
suffix:semicolon
r_int
id|changed
op_assign
id|FALSE
suffix:semicolon
id|rdmsr
c_func
(paren
id|MTRRphysBase_MSR
c_func
(paren
id|index
)paren
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vr-&gt;base_lo
op_amp
l_int|0xfffff0ffUL
)paren
op_ne
(paren
id|lo
op_amp
l_int|0xfffff0ffUL
)paren
op_logical_or
(paren
id|vr-&gt;base_hi
op_amp
l_int|0xfUL
)paren
op_ne
(paren
id|hi
op_amp
l_int|0xfUL
)paren
)paren
(brace
id|wrmsr
c_func
(paren
id|MTRRphysBase_MSR
c_func
(paren
id|index
)paren
comma
id|vr-&gt;base_lo
comma
id|vr-&gt;base_hi
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
id|rdmsr
c_func
(paren
id|MTRRphysMask_MSR
c_func
(paren
id|index
)paren
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vr-&gt;mask_lo
op_amp
l_int|0xfffff800UL
)paren
op_ne
(paren
id|lo
op_amp
l_int|0xfffff800UL
)paren
op_logical_or
(paren
id|vr-&gt;mask_hi
op_amp
l_int|0xfUL
)paren
op_ne
(paren
id|hi
op_amp
l_int|0xfUL
)paren
)paren
(brace
id|wrmsr
c_func
(paren
id|MTRRphysMask_MSR
c_func
(paren
id|index
)paren
comma
id|vr-&gt;mask_lo
comma
id|vr-&gt;mask_hi
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
r_return
id|changed
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|get_fixed_ranges
c_func
(paren
id|mtrr_type
op_star
id|frs
)paren
)paren
(brace
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|frs
suffix:semicolon
r_int
id|i
suffix:semicolon
id|rdmsr
c_func
(paren
id|MTRRfix64K_00000_MSR
comma
id|p
(braket
l_int|0
)braket
comma
id|p
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|rdmsr
c_func
(paren
id|MTRRfix16K_80000_MSR
op_plus
id|i
comma
id|p
(braket
l_int|2
op_plus
id|i
op_star
l_int|2
)braket
comma
id|p
(braket
l_int|3
op_plus
id|i
op_star
l_int|2
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|rdmsr
c_func
(paren
id|MTRRfix4K_C0000_MSR
op_plus
id|i
comma
id|p
(braket
l_int|6
op_plus
id|i
op_star
l_int|2
)braket
comma
id|p
(braket
l_int|7
op_plus
id|i
op_star
l_int|2
)braket
)paren
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|set_fixed_ranges_testing
c_func
(paren
id|mtrr_type
op_star
id|frs
)paren
)paren
(brace
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|frs
suffix:semicolon
r_int
id|changed
op_assign
id|FALSE
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|lo
comma
id|hi
suffix:semicolon
id|rdmsr
c_func
(paren
id|MTRRfix64K_00000_MSR
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_ne
id|lo
op_logical_or
id|p
(braket
l_int|1
)braket
op_ne
id|hi
)paren
(brace
id|wrmsr
c_func
(paren
id|MTRRfix64K_00000_MSR
comma
id|p
(braket
l_int|0
)braket
comma
id|p
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rdmsr
c_func
(paren
id|MTRRfix16K_80000_MSR
op_plus
id|i
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|2
op_plus
id|i
op_star
l_int|2
)braket
op_ne
id|lo
op_logical_or
id|p
(braket
l_int|3
op_plus
id|i
op_star
l_int|2
)braket
op_ne
id|hi
)paren
(brace
id|wrmsr
c_func
(paren
id|MTRRfix16K_80000_MSR
op_plus
id|i
comma
id|p
(braket
l_int|2
op_plus
id|i
op_star
l_int|2
)braket
comma
id|p
(braket
l_int|3
op_plus
id|i
op_star
l_int|2
)braket
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rdmsr
c_func
(paren
id|MTRRfix4K_C0000_MSR
op_plus
id|i
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|6
op_plus
id|i
op_star
l_int|2
)braket
op_ne
id|lo
op_logical_or
id|p
(braket
l_int|7
op_plus
id|i
op_star
l_int|2
)braket
op_ne
id|hi
)paren
(brace
id|wrmsr
c_func
(paren
id|MTRRfix4K_C0000_MSR
op_plus
id|i
comma
id|p
(braket
l_int|6
op_plus
id|i
op_star
l_int|2
)braket
comma
id|p
(braket
l_int|7
op_plus
id|i
op_star
l_int|2
)braket
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
r_return
id|changed
suffix:semicolon
)brace
DECL|struct|mtrr_state
r_struct
id|mtrr_state
(brace
DECL|member|num_var_ranges
r_int
r_int
id|num_var_ranges
suffix:semicolon
DECL|member|var_ranges
r_struct
id|mtrr_var_range
op_star
id|var_ranges
suffix:semicolon
DECL|member|fixed_ranges
id|mtrr_type
id|fixed_ranges
(braket
id|NUM_FIXED_RANGES
)braket
suffix:semicolon
DECL|member|enabled
r_int
r_char
id|enabled
suffix:semicolon
DECL|member|def_type
id|mtrr_type
id|def_type
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Grab all of the mtrr state for this cpu into *state. */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|get_mtrr_state
c_func
(paren
r_struct
id|mtrr_state
op_star
id|state
)paren
)paren
(brace
r_int
r_int
id|nvrs
comma
id|i
suffix:semicolon
r_struct
id|mtrr_var_range
op_star
id|vrs
suffix:semicolon
r_int
r_int
id|lo
comma
id|dummy
suffix:semicolon
id|nvrs
op_assign
id|state-&gt;num_var_ranges
op_assign
id|get_num_var_ranges
c_func
(paren
)paren
suffix:semicolon
id|vrs
op_assign
id|state-&gt;var_ranges
op_assign
id|kmalloc
c_func
(paren
id|nvrs
op_star
r_sizeof
(paren
r_struct
id|mtrr_var_range
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vrs
op_eq
l_int|NULL
)paren
id|nvrs
op_assign
id|state-&gt;num_var_ranges
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nvrs
suffix:semicolon
id|i
op_increment
)paren
id|get_mtrr_var_range
c_func
(paren
id|i
comma
op_amp
id|vrs
(braket
id|i
)braket
)paren
suffix:semicolon
id|get_fixed_ranges
c_func
(paren
id|state-&gt;fixed_ranges
)paren
suffix:semicolon
id|rdmsr
c_func
(paren
id|MTRRdefType_MSR
comma
id|lo
comma
id|dummy
)paren
suffix:semicolon
id|state-&gt;def_type
op_assign
(paren
id|lo
op_amp
l_int|0xff
)paren
suffix:semicolon
id|state-&gt;enabled
op_assign
(paren
id|lo
op_amp
l_int|0xc00
)paren
op_rshift
l_int|10
suffix:semicolon
)brace
multiline_comment|/*  End Function get_mtrr_state  */
multiline_comment|/* Free resources associated with a struct mtrr_state */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|finalize_mtrr_state
c_func
(paren
r_struct
id|mtrr_state
op_star
id|state
)paren
)paren
(brace
r_if
c_cond
(paren
id|state-&gt;var_ranges
)paren
id|kfree
(paren
id|state-&gt;var_ranges
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function finalize_mtrr_state  */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
r_int
id|set_mtrr_state
(paren
r_struct
id|mtrr_state
op_star
id|state
comma
r_struct
id|set_mtrr_context
op_star
id|ctxt
)paren
)paren
multiline_comment|/*  [SUMMARY] Set the MTRR state for this CPU.&n;    &lt;state&gt; The MTRR state information to read.&n;    &lt;ctxt&gt; Some relevant CPU context.&n;    [NOTE] The CPU must already be in a safe state for MTRR changes.&n;    [RETURNS] 0 if no changes made, else a mask indication what was changed.&n;*/
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|change_mask
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|state-&gt;num_var_ranges
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|set_mtrr_var_range_testing
c_func
(paren
id|i
comma
op_amp
id|state-&gt;var_ranges
(braket
id|i
)braket
)paren
)paren
id|change_mask
op_or_assign
id|MTRR_CHANGE_MASK_VARIABLE
suffix:semicolon
r_if
c_cond
(paren
id|set_fixed_ranges_testing
c_func
(paren
id|state-&gt;fixed_ranges
)paren
)paren
id|change_mask
op_or_assign
id|MTRR_CHANGE_MASK_FIXED
suffix:semicolon
multiline_comment|/* set_mtrr_restore restores the old value of MTRRdefType,&n;       so to set it we fiddle with the saved value. */
r_if
c_cond
(paren
(paren
id|ctxt-&gt;deftype_lo
op_amp
l_int|0xff
)paren
op_ne
id|state-&gt;def_type
op_logical_or
(paren
(paren
id|ctxt-&gt;deftype_lo
op_amp
l_int|0xc00
)paren
op_rshift
l_int|10
)paren
op_ne
id|state-&gt;enabled
)paren
(brace
id|ctxt-&gt;deftype_lo
op_or_assign
(paren
id|state-&gt;def_type
op_or
id|state-&gt;enabled
op_lshift
l_int|10
)paren
suffix:semicolon
id|change_mask
op_or_assign
id|MTRR_CHANGE_MASK_DEFTYPE
suffix:semicolon
)brace
r_return
id|change_mask
suffix:semicolon
)brace
multiline_comment|/*  End Function set_mtrr_state  */
DECL|variable|undone_count
r_static
id|atomic_t
id|undone_count
suffix:semicolon
DECL|variable|handler_func
r_static
r_void
(paren
op_star
id|handler_func
)paren
(paren
r_struct
id|set_mtrr_context
op_star
id|ctxt
comma
r_void
op_star
id|info
)paren
suffix:semicolon
DECL|variable|handler_info
r_static
r_void
op_star
id|handler_info
suffix:semicolon
DECL|variable|wait_barrier_execute
r_static
r_volatile
r_int
id|wait_barrier_execute
op_assign
id|FALSE
suffix:semicolon
DECL|variable|wait_barrier_cache_enable
r_static
r_volatile
r_int
id|wait_barrier_cache_enable
op_assign
id|FALSE
suffix:semicolon
DECL|function|sync_handler
r_static
r_void
id|sync_handler
(paren
r_void
)paren
multiline_comment|/*  [SUMMARY] Synchronisation handler. Executed by &quot;other&quot; CPUs.&n;    [RETURNS] Nothing.&n;*/
(brace
r_struct
id|set_mtrr_context
id|ctxt
suffix:semicolon
id|set_mtrr_prepare
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
multiline_comment|/*  Notify master CPU that I&squot;m at the barrier and then wait  */
id|atomic_dec
(paren
op_amp
id|undone_count
)paren
suffix:semicolon
r_while
c_loop
(paren
id|wait_barrier_execute
)paren
id|barrier
(paren
)paren
suffix:semicolon
multiline_comment|/*  The master has cleared me to execute  */
(paren
op_star
id|handler_func
)paren
(paren
op_amp
id|ctxt
comma
id|handler_info
)paren
suffix:semicolon
multiline_comment|/*  Notify master CPU that I&squot;ve executed the function  */
id|atomic_dec
(paren
op_amp
id|undone_count
)paren
suffix:semicolon
multiline_comment|/*  Wait for master to clear me to enable cache and return  */
r_while
c_loop
(paren
id|wait_barrier_cache_enable
)paren
id|barrier
(paren
)paren
suffix:semicolon
id|set_mtrr_done
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function sync_handler  */
DECL|function|do_all_cpus
r_static
r_void
id|do_all_cpus
(paren
r_void
(paren
op_star
id|handler
)paren
(paren
r_struct
id|set_mtrr_context
op_star
id|ctxt
comma
r_void
op_star
id|info
)paren
comma
r_void
op_star
id|info
comma
r_int
id|local
)paren
multiline_comment|/*  [SUMMARY] Execute a function on all CPUs, with caches flushed and disabled.&n;    [PURPOSE] This function will synchronise all CPUs, flush and disable caches&n;    on all CPUs, then call a specified function. When the specified function&n;    finishes on all CPUs, caches are enabled on all CPUs.&n;    &lt;handler&gt; The function to execute.&n;    &lt;info&gt; An arbitrary information pointer which is passed to &lt;&lt;handler&gt;&gt;.&n;    &lt;local&gt; If TRUE &lt;&lt;handler&gt;&gt; is executed locally.&n;    [RETURNS] Nothing.&n;*/
(brace
r_int
r_int
id|timeout
suffix:semicolon
r_struct
id|set_mtrr_context
id|ctxt
suffix:semicolon
id|mtrr_hook
op_assign
id|sync_handler
suffix:semicolon
id|handler_func
op_assign
id|handler
suffix:semicolon
id|handler_info
op_assign
id|info
suffix:semicolon
id|wait_barrier_execute
op_assign
id|TRUE
suffix:semicolon
id|wait_barrier_cache_enable
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/*  Send a message to all other CPUs and wait for them to enter the&n;&t;barrier  */
id|atomic_set
(paren
op_amp
id|undone_count
comma
id|smp_num_cpus
op_minus
l_int|1
)paren
suffix:semicolon
id|smp_message_pass
(paren
id|MSG_ALL_BUT_SELF
comma
id|MSG_MTRR_CHANGE
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*  Wait for it to be done  */
id|timeout
op_assign
id|jiffies
op_plus
id|JIFFIE_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|atomic_read
(paren
op_amp
id|undone_count
)paren
OG
l_int|0
)paren
op_logical_and
(paren
id|jiffies
OL
id|timeout
)paren
)paren
id|barrier
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_read
(paren
op_amp
id|undone_count
)paren
OG
l_int|0
)paren
(brace
id|panic
(paren
l_string|&quot;mtrr: timed out waiting for other CPUs&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|mtrr_hook
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*  All other CPUs should be waiting for the barrier, with their caches&n;&t;already flushed and disabled. Prepare for function completion&n;&t;notification  */
id|atomic_set
(paren
op_amp
id|undone_count
comma
id|smp_num_cpus
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*  Flush and disable the local CPU&squot;s cache&t;and release the barier, which&n;&t;should cause the other CPUs to execute the function. Also execute it&n;&t;locally if required  */
id|set_mtrr_prepare
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
id|wait_barrier_execute
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
id|local
)paren
(paren
op_star
id|handler
)paren
(paren
op_amp
id|ctxt
comma
id|info
)paren
suffix:semicolon
multiline_comment|/*  Now wait for other CPUs to complete the function  */
r_while
c_loop
(paren
id|atomic_read
(paren
op_amp
id|undone_count
)paren
OG
l_int|0
)paren
id|barrier
(paren
)paren
suffix:semicolon
multiline_comment|/*  Now all CPUs should have finished the function. Release the barrier to&n;&t;allow them to re-enable their caches and return from their interrupt,&n;&t;then enable the local cache and return  */
id|wait_barrier_cache_enable
op_assign
id|FALSE
suffix:semicolon
id|set_mtrr_done
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
id|handler_func
op_assign
l_int|NULL
suffix:semicolon
id|handler_info
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*  End Function do_all_cpus  */
DECL|struct|set_mtrr_data
r_struct
id|set_mtrr_data
(brace
DECL|member|smp_base
r_int
r_int
id|smp_base
suffix:semicolon
DECL|member|smp_size
r_int
r_int
id|smp_size
suffix:semicolon
DECL|member|smp_reg
r_int
r_int
id|smp_reg
suffix:semicolon
DECL|member|smp_type
id|mtrr_type
id|smp_type
suffix:semicolon
)brace
suffix:semicolon
DECL|function|set_mtrr_handler
r_static
r_void
id|set_mtrr_handler
(paren
r_struct
id|set_mtrr_context
op_star
id|ctxt
comma
r_void
op_star
id|info
)paren
(brace
r_struct
id|set_mtrr_data
op_star
id|data
op_assign
id|info
suffix:semicolon
id|set_mtrr_up
(paren
id|data-&gt;smp_reg
comma
id|data-&gt;smp_base
comma
id|data-&gt;smp_size
comma
id|data-&gt;smp_type
comma
id|FALSE
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function set_mtrr_handler  */
DECL|function|set_mtrr_smp
r_static
r_void
id|set_mtrr_smp
(paren
r_int
r_int
id|reg
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
id|mtrr_type
id|type
)paren
(brace
r_struct
id|set_mtrr_data
id|data
suffix:semicolon
id|data.smp_reg
op_assign
id|reg
suffix:semicolon
id|data.smp_base
op_assign
id|base
suffix:semicolon
id|data.smp_size
op_assign
id|size
suffix:semicolon
id|data.smp_type
op_assign
id|type
suffix:semicolon
id|do_all_cpus
(paren
id|set_mtrr_handler
comma
op_amp
id|data
comma
id|TRUE
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function set_mtrr_smp  */
multiline_comment|/* A warning that is common to the module and non-module cases. */
multiline_comment|/* Some BIOS&squot;s are fucked and don&squot;t set all MTRRs the same! */
macro_line|#ifdef MODULE
DECL|function|mtrr_state_warn
r_static
r_void
id|mtrr_state_warn
(paren
r_int
r_int
id|mask
)paren
macro_line|#else
id|__initfunc
c_func
(paren
r_static
r_void
id|mtrr_state_warn
(paren
r_int
r_int
id|mask
)paren
)paren
macro_line|#endif
(brace
r_if
c_cond
(paren
op_logical_neg
id|mask
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|MTRR_CHANGE_MASK_FIXED
)paren
id|printk
(paren
l_string|&quot;mtrr: your CPUs had inconsistent fixed MTRR settings&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|MTRR_CHANGE_MASK_VARIABLE
)paren
id|printk
(paren
l_string|&quot;mtrr: your CPUs had inconsistent variable MTRR settings&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|MTRR_CHANGE_MASK_DEFTYPE
)paren
id|printk
(paren
l_string|&quot;mtrr: your CPUs had inconsistent MTRRdefType settings&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: probably your BIOS does not setup all CPUs&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_state_warn  */
macro_line|#ifdef MODULE
multiline_comment|/* As a module, copy the MTRR state using an IPI handler. */
DECL|variable|smp_changes_mask
r_static
r_volatile
r_int
r_int
id|smp_changes_mask
op_assign
l_int|0
suffix:semicolon
DECL|function|copy_mtrr_state_handler
r_static
r_void
id|copy_mtrr_state_handler
(paren
r_struct
id|set_mtrr_context
op_star
id|ctxt
comma
r_void
op_star
id|info
)paren
(brace
r_int
r_int
id|mask
comma
id|count
suffix:semicolon
r_struct
id|mtrr_state
op_star
id|smp_mtrr_state
op_assign
id|info
suffix:semicolon
id|mask
op_assign
id|set_mtrr_state
(paren
id|smp_mtrr_state
comma
id|ctxt
)paren
suffix:semicolon
multiline_comment|/*  Use the atomic bitops to update the global mask  */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
r_sizeof
id|mask
op_star
l_int|8
suffix:semicolon
op_increment
id|count
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x01
)paren
id|set_bit
(paren
id|count
comma
op_amp
id|smp_changes_mask
)paren
suffix:semicolon
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*  End Function copy_mtrr_state_handler  */
multiline_comment|/* Copies the entire MTRR state of this cpu to all the others. */
DECL|function|copy_mtrr_state
r_static
r_void
id|copy_mtrr_state
(paren
r_void
)paren
(brace
r_struct
id|mtrr_state
id|ms
suffix:semicolon
id|get_mtrr_state
(paren
op_amp
id|ms
)paren
suffix:semicolon
id|do_all_cpus
(paren
id|copy_mtrr_state_handler
comma
op_amp
id|ms
comma
id|FALSE
)paren
suffix:semicolon
id|finalize_mtrr_state
(paren
op_amp
id|ms
)paren
suffix:semicolon
id|mtrr_state_warn
(paren
id|smp_changes_mask
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function copy_mtrr_state  */
macro_line|#endif /* MODULE */
macro_line|#endif  /*  __SMP__  */
DECL|function|attrib_to_str
r_static
r_char
op_star
id|attrib_to_str
(paren
r_int
id|x
)paren
(brace
r_return
(paren
id|x
op_le
l_int|6
)paren
ques
c_cond
id|mtrr_strings
(braket
id|x
)braket
suffix:colon
l_string|&quot;?&quot;
suffix:semicolon
)brace
multiline_comment|/*  End Function attrib_to_str  */
DECL|function|init_table
r_static
r_void
id|init_table
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|max
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|usage_table
op_assign
id|kmalloc
(paren
id|max
op_star
r_sizeof
op_star
id|usage_table
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: could not allocate&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
id|i
op_increment
)paren
id|usage_table
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_if
c_cond
(paren
(paren
id|ascii_buffer
op_assign
id|kmalloc
(paren
id|max
op_star
id|LINE_SIZE
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: could not allocate&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ascii_buf_bytes
op_assign
l_int|0
suffix:semicolon
id|compute_ascii
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*  End Function init_table  */
DECL|function|mtrr_add
r_int
id|mtrr_add
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
r_int
r_int
id|type
comma
r_char
id|increment
)paren
multiline_comment|/*  [SUMMARY] Add an MTRR entry.&n;    &lt;base&gt; The starting (base) address of the region.&n;    &lt;size&gt; The size (in bytes) of the region.&n;    &lt;type&gt; The type of the new region.&n;    &lt;increment&gt; If true and the region already exists, the usage count will be&n;    incremented.&n;    [RETURNS] The MTRR register on success, else a negative number indicating&n;    the error code.&n;    [NOTE] This routine uses a spinlock.&n;*/
(brace
r_int
id|i
comma
id|max
suffix:semicolon
id|mtrr_type
id|ltype
suffix:semicolon
r_int
r_int
id|lbase
comma
id|lsize
comma
id|last
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|boot_cpu_data.x86_capability
op_amp
id|X86_FEATURE_MTRR
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
op_amp
l_int|0xfff
)paren
op_logical_or
(paren
id|size
op_amp
l_int|0xfff
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: size and base must be multiples of 4kB&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: size: %lx  base: %lx&bslash;n&quot;
comma
id|size
comma
id|base
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base
op_plus
id|size
OL
l_int|0x100000
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: cannot set region below 1 MByte (0x%lx,0x%lx)&bslash;n&quot;
comma
id|base
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*  Check upper bits of base and last are equal and lower bits are 0 for&n;&t;base and 1 for last  */
id|last
op_assign
id|base
op_plus
id|size
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|lbase
op_assign
id|base
suffix:semicolon
op_logical_neg
(paren
id|lbase
op_amp
l_int|1
)paren
op_logical_and
(paren
id|last
op_amp
l_int|1
)paren
suffix:semicolon
id|lbase
op_assign
id|lbase
op_rshift
l_int|1
comma
id|last
op_assign
id|last
op_rshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lbase
op_ne
id|last
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: base(0x%lx) is not aligned on a size(0x%lx) boundary&bslash;n&quot;
comma
id|base
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_ge
id|MTRR_NUM_TYPES
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: type: %u illegal&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*  If the type is WC, check that this processor supports it  */
r_if
c_cond
(paren
(paren
id|type
op_eq
id|MTRR_TYPE_WRCOMB
)paren
op_logical_and
op_logical_neg
id|have_wrcomb
(paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: your processor doesn&squot;t support write-combining&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
id|increment
op_assign
id|increment
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
multiline_comment|/*  Search for existing MTRR  */
id|spin_lock
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
op_increment
id|i
)paren
(brace
id|get_mtrr
(paren
id|i
comma
op_amp
id|lbase
comma
op_amp
id|lsize
comma
op_amp
id|ltype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_ge
id|lbase
op_plus
id|lsize
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
OL
id|lbase
)paren
op_logical_and
(paren
id|base
op_plus
id|size
op_le
id|lbase
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*  At this point we know there is some kind of overlap/enclosure  */
r_if
c_cond
(paren
(paren
id|base
OL
id|lbase
)paren
op_logical_or
(paren
id|base
op_plus
id|size
OG
id|lbase
op_plus
id|lsize
)paren
)paren
(brace
id|spin_unlock
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: 0x%lx,0x%lx overlaps existing 0x%lx,0x%lx&bslash;n&quot;
comma
id|base
comma
id|size
comma
id|lbase
comma
id|lsize
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*  New region is enclosed by an existing region  */
r_if
c_cond
(paren
id|ltype
op_ne
id|type
)paren
(brace
r_if
c_cond
(paren
id|type
op_eq
id|MTRR_TYPE_UNCACHABLE
)paren
r_continue
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: type mismatch for %lx,%lx old: %s new: %s&bslash;n&quot;
comma
id|base
comma
id|size
comma
id|attrib_to_str
(paren
id|ltype
)paren
comma
id|attrib_to_str
(paren
id|type
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|increment
)paren
op_increment
id|usage_table
(braket
id|i
)braket
suffix:semicolon
id|compute_ascii
(paren
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*  Search for an empty MTRR  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
op_increment
id|i
)paren
(brace
id|get_mtrr
(paren
id|i
comma
op_amp
id|lbase
comma
op_amp
id|lsize
comma
op_amp
id|ltype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lsize
OG
l_int|0
)paren
r_continue
suffix:semicolon
id|set_mtrr
(paren
id|i
comma
id|base
comma
id|size
comma
id|type
)paren
suffix:semicolon
id|usage_table
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
id|compute_ascii
(paren
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
id|spin_unlock
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: no more MTRRs available&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_add  */
DECL|function|mtrr_del
r_int
id|mtrr_del
(paren
r_int
id|reg
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
)paren
multiline_comment|/*  [SUMMARY] Delete MTRR/decrement usage count.&n;    &lt;reg&gt; The register. If this is less than 0 then &lt;&lt;base&gt;&gt; and &lt;&lt;size&gt;&gt; must&n;    be supplied.&n;    &lt;base&gt; The base address of the region. This is ignored if &lt;&lt;reg&gt;&gt; is &gt;= 0.&n;    &lt;size&gt; The size of the region. This is ignored if &lt;&lt;reg&gt;&gt; is &gt;= 0.&n;    [RETURNS] The register on success, else a negative number indicating&n;    the error code.&n;    [NOTE] This routine uses a spinlock.&n;*/
(brace
r_int
id|i
comma
id|max
suffix:semicolon
id|mtrr_type
id|ltype
suffix:semicolon
r_int
r_int
id|lbase
comma
id|lsize
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|boot_cpu_data.x86_capability
op_amp
id|X86_FEATURE_MTRR
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
id|spin_lock
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
OL
l_int|0
)paren
(brace
multiline_comment|/*  Search for existing MTRR  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
op_increment
id|i
)paren
(brace
id|get_mtrr
(paren
id|i
comma
op_amp
id|lbase
comma
op_amp
id|lsize
comma
op_amp
id|ltype
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lbase
op_eq
id|base
)paren
op_logical_and
(paren
id|lsize
op_eq
id|size
)paren
)paren
(brace
id|reg
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|reg
OL
l_int|0
)paren
(brace
id|spin_unlock
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: no MTRR for %lx,%lx found&bslash;n&quot;
comma
id|base
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|reg
op_ge
id|max
)paren
(brace
id|spin_unlock
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: register: %d too big&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|get_mtrr
(paren
id|reg
comma
op_amp
id|lbase
comma
op_amp
id|lsize
comma
op_amp
id|ltype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lsize
OL
l_int|1
)paren
(brace
id|spin_unlock
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: MTRR %d not used&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usage_table
(braket
id|reg
)braket
OL
l_int|1
)paren
(brace
id|spin_unlock
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: reg: %d has count=0&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|usage_table
(braket
id|reg
)braket
OL
l_int|1
)paren
id|set_mtrr
(paren
id|reg
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|compute_ascii
(paren
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
r_return
id|reg
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_del  */
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|mtrr_file_add
r_static
r_int
id|mtrr_file_add
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
r_int
r_int
id|type
comma
r_char
id|increment
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|reg
comma
id|max
suffix:semicolon
r_int
r_int
op_star
id|fcount
op_assign
id|file-&gt;private_data
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fcount
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|fcount
op_assign
id|kmalloc
(paren
id|max
op_star
r_sizeof
op_star
id|fcount
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: could not allocate&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|fcount
comma
l_int|0
comma
id|max
op_star
r_sizeof
op_star
id|fcount
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
id|fcount
suffix:semicolon
)brace
id|reg
op_assign
id|mtrr_add
(paren
id|base
comma
id|size
comma
id|type
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_ge
l_int|0
)paren
op_increment
id|fcount
(braket
id|reg
)braket
suffix:semicolon
r_return
id|reg
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_file_add  */
DECL|function|mtrr_file_del
r_static
r_int
id|mtrr_file_del
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|reg
suffix:semicolon
r_int
r_int
op_star
id|fcount
op_assign
id|file-&gt;private_data
suffix:semicolon
id|reg
op_assign
id|mtrr_del
(paren
op_minus
l_int|1
comma
id|base
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
OL
l_int|0
)paren
r_return
id|reg
suffix:semicolon
r_if
c_cond
(paren
id|fcount
op_ne
l_int|NULL
)paren
op_decrement
id|fcount
(braket
id|reg
)braket
suffix:semicolon
r_return
id|reg
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_file_del  */
DECL|function|mtrr_read
r_static
id|ssize_t
id|mtrr_read
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_if
c_cond
(paren
op_star
id|ppos
op_ge
id|ascii_buf_bytes
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ppos
op_plus
id|len
OG
id|ascii_buf_bytes
)paren
id|len
op_assign
id|ascii_buf_bytes
op_minus
op_star
id|ppos
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
id|buf
comma
id|ascii_buffer
op_plus
op_star
id|ppos
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
op_star
id|ppos
op_add_assign
id|len
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_read  */
DECL|function|mtrr_write
r_static
id|ssize_t
id|mtrr_write
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ppos
)paren
multiline_comment|/*  Format of control line:&n;    &quot;base=%lx size=%lx type=%s&quot;     OR:&n;    &quot;disable=%d&quot;&n;*/
(brace
r_int
id|i
comma
id|err
suffix:semicolon
r_int
r_int
id|reg
comma
id|base
comma
id|size
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
r_char
id|line
(braket
id|LINE_SIZE
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/*  Can&squot;t seek (pwrite) on this device  */
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
id|memset
(paren
id|line
comma
l_int|0
comma
id|LINE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|LINE_SIZE
)paren
id|len
op_assign
id|LINE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
id|line
comma
id|buf
comma
id|len
op_minus
l_int|1
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ptr
op_assign
id|line
op_plus
id|strlen
(paren
id|line
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ptr
op_eq
l_char|&squot;&bslash;n&squot;
)paren
op_star
id|ptr
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
(paren
id|line
comma
l_string|&quot;disable=&quot;
comma
l_int|8
)paren
)paren
(brace
id|reg
op_assign
id|simple_strtoul
(paren
id|line
op_plus
l_int|8
comma
op_amp
id|ptr
comma
l_int|0
)paren
suffix:semicolon
id|err
op_assign
id|mtrr_del
(paren
id|reg
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strncmp
(paren
id|line
comma
l_string|&quot;base=&quot;
comma
l_int|5
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: no &bslash;&quot;base=&bslash;&quot; in line: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|base
op_assign
id|simple_strtoul
(paren
id|line
op_plus
l_int|5
comma
op_amp
id|ptr
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|isspace
(paren
op_star
id|ptr
)paren
suffix:semicolon
op_increment
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
(paren
id|ptr
comma
l_string|&quot;size=&quot;
comma
l_int|5
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: no &bslash;&quot;size=&bslash;&quot; in line: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|size
op_assign
id|simple_strtoul
(paren
id|ptr
op_plus
l_int|5
comma
op_amp
id|ptr
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|isspace
(paren
op_star
id|ptr
)paren
suffix:semicolon
op_increment
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
(paren
id|ptr
comma
l_string|&quot;type=&quot;
comma
l_int|5
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: no &bslash;&quot;type=&bslash;&quot; in line: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ptr
op_add_assign
l_int|5
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|isspace
(paren
op_star
id|ptr
)paren
suffix:semicolon
op_increment
id|ptr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MTRR_NUM_TYPES
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|strcmp
(paren
id|ptr
comma
id|mtrr_strings
(braket
id|i
)braket
)paren
)paren
r_continue
suffix:semicolon
id|err
op_assign
id|mtrr_add
(paren
id|base
comma
id|size
comma
id|i
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;mtrr: illegal type: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|ptr
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_write  */
DECL|function|mtrr_ioctl
r_static
r_int
id|mtrr_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
id|mtrr_type
id|type
suffix:semicolon
r_struct
id|mtrr_sentry
id|sentry
suffix:semicolon
r_struct
id|mtrr_gentry
id|gentry
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
r_case
id|MTRRIOC_ADD_ENTRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|sentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|mtrr_file_add
(paren
id|sentry.base
comma
id|sentry.size
comma
id|sentry.type
comma
l_int|1
comma
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_SET_ENTRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|sentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|mtrr_add
(paren
id|sentry.base
comma
id|sentry.size
comma
id|sentry.type
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_DEL_ENTRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|sentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|mtrr_file_del
(paren
id|sentry.base
comma
id|sentry.size
comma
id|file
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_GET_ENTRY
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|gentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|gentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|gentry.regnum
op_ge
id|get_num_var_ranges
(paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|get_mtrr
(paren
id|gentry.regnum
comma
op_amp
id|gentry.base
comma
op_amp
id|gentry.size
comma
op_amp
id|type
)paren
suffix:semicolon
id|gentry.type
op_assign
id|type
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|gentry
comma
r_sizeof
id|gentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_ioctl  */
DECL|function|mtrr_open
r_static
r_int
id|mtrr_open
(paren
r_struct
id|inode
op_star
id|ino
comma
r_struct
id|file
op_star
id|filep
)paren
(brace
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_open  */
DECL|function|mtrr_close
r_static
r_int
id|mtrr_close
(paren
r_struct
id|inode
op_star
id|ino
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|i
comma
id|max
suffix:semicolon
r_int
r_int
op_star
id|fcount
op_assign
id|file-&gt;private_data
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|fcount
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
op_increment
id|i
)paren
(brace
r_while
c_loop
(paren
id|fcount
(braket
id|i
)braket
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|mtrr_del
(paren
id|i
comma
l_int|0
comma
l_int|0
)paren
OL
l_int|0
)paren
id|printk
(paren
l_string|&quot;mtrr: reg %d not used&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
op_decrement
id|fcount
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
id|kfree
(paren
id|fcount
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_close  */
DECL|variable|mtrr_fops
r_static
r_struct
id|file_operations
id|mtrr_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/*  Seek              */
id|mtrr_read
comma
multiline_comment|/*  Read              */
id|mtrr_write
comma
multiline_comment|/*  Write             */
l_int|NULL
comma
multiline_comment|/*  Readdir           */
l_int|NULL
comma
multiline_comment|/*  Poll              */
id|mtrr_ioctl
comma
multiline_comment|/*  IOctl             */
l_int|NULL
comma
multiline_comment|/*  MMAP              */
id|mtrr_open
comma
multiline_comment|/*  Open              */
id|mtrr_close
comma
multiline_comment|/*  Release           */
l_int|NULL
comma
multiline_comment|/*  Fsync             */
l_int|NULL
comma
multiline_comment|/*  Fasync            */
l_int|NULL
comma
multiline_comment|/*  CheckMediaChange  */
l_int|NULL
comma
multiline_comment|/*  Revalidate        */
l_int|NULL
comma
multiline_comment|/*  Lock              */
)brace
suffix:semicolon
DECL|variable|proc_mtrr_inode_operations
r_static
r_struct
id|inode_operations
id|proc_mtrr_inode_operations
op_assign
(brace
op_amp
id|mtrr_fops
comma
multiline_comment|/* default property file-ops */
l_int|NULL
comma
multiline_comment|/* create */
l_int|NULL
comma
multiline_comment|/* lookup */
l_int|NULL
comma
multiline_comment|/* link */
l_int|NULL
comma
multiline_comment|/* unlink */
l_int|NULL
comma
multiline_comment|/* symlink */
l_int|NULL
comma
multiline_comment|/* mkdir */
l_int|NULL
comma
multiline_comment|/* rmdir */
l_int|NULL
comma
multiline_comment|/* mknod */
l_int|NULL
comma
multiline_comment|/* rename */
l_int|NULL
comma
multiline_comment|/* readlink */
l_int|NULL
comma
multiline_comment|/* follow_link */
l_int|NULL
comma
multiline_comment|/* readpage */
l_int|NULL
comma
multiline_comment|/* writepage */
l_int|NULL
comma
multiline_comment|/* bmap */
l_int|NULL
comma
multiline_comment|/* truncate */
l_int|NULL
multiline_comment|/* permission */
)brace
suffix:semicolon
DECL|variable|proc_root_mtrr
r_static
r_struct
id|proc_dir_entry
id|proc_root_mtrr
op_assign
(brace
id|PROC_MTRR
comma
l_int|4
comma
l_string|&quot;mtrr&quot;
comma
id|S_IFREG
op_or
id|S_IWUSR
op_or
id|S_IRUGO
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_amp
id|proc_mtrr_inode_operations
)brace
suffix:semicolon
DECL|function|compute_ascii
r_static
r_void
id|compute_ascii
(paren
r_void
)paren
(brace
r_char
id|factor
suffix:semicolon
r_int
id|i
comma
id|max
suffix:semicolon
id|mtrr_type
id|type
suffix:semicolon
r_int
r_int
id|base
comma
id|size
suffix:semicolon
id|ascii_buf_bytes
op_assign
l_int|0
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
id|i
op_increment
)paren
(brace
id|get_mtrr
(paren
id|i
comma
op_amp
id|base
comma
op_amp
id|size
comma
op_amp
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
l_int|1
)paren
id|usage_table
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|size
OL
l_int|0x100000
)paren
(brace
multiline_comment|/* 1MB */
id|factor
op_assign
l_char|&squot;k&squot;
suffix:semicolon
id|size
op_rshift_assign
l_int|10
suffix:semicolon
)brace
r_else
(brace
id|factor
op_assign
l_char|&squot;M&squot;
suffix:semicolon
id|size
op_rshift_assign
l_int|20
suffix:semicolon
)brace
id|sprintf
(paren
id|ascii_buffer
op_plus
id|ascii_buf_bytes
comma
l_string|&quot;reg%02i: base=0x%08lx (%4liMB), size=%4li%cB: %s, count=%d&bslash;n&quot;
comma
id|i
comma
id|base
comma
id|base
op_rshift
l_int|20
comma
id|size
comma
id|factor
comma
id|attrib_to_str
(paren
id|type
)paren
comma
id|usage_table
(braket
id|i
)braket
)paren
suffix:semicolon
id|ascii_buf_bytes
op_add_assign
id|strlen
(paren
id|ascii_buffer
op_plus
id|ascii_buf_bytes
)paren
suffix:semicolon
)brace
)brace
id|proc_root_mtrr.size
op_assign
id|ascii_buf_bytes
suffix:semicolon
)brace
multiline_comment|/*  End Function compute_ascii  */
macro_line|#endif  /*  CONFIG_PROC_FS  */
DECL|variable|mtrr_add
id|EXPORT_SYMBOL
c_func
(paren
id|mtrr_add
)paren
suffix:semicolon
DECL|variable|mtrr_del
id|EXPORT_SYMBOL
c_func
(paren
id|mtrr_del
)paren
suffix:semicolon
macro_line|#if defined(__SMP__) &amp;&amp; !defined(MODULE)
DECL|variable|__initdata
r_static
r_volatile
r_int
r_int
id|smp_changes_mask
id|__initdata
op_assign
l_int|0
suffix:semicolon
DECL|variable|__initdata
r_static
r_struct
id|mtrr_state
id|smp_mtrr_state
id|__initdata
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|mtrr_init_boot_cpu
(paren
r_void
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|boot_cpu_data.x86_capability
op_amp
id|X86_FEATURE_MTRR
)paren
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;mtrr: v%s Richard Gooch (rgooch@atnf.csiro.au)&bslash;n&quot;
comma
id|MTRR_VERSION
)paren
suffix:semicolon
id|get_mtrr_state
(paren
op_amp
id|smp_mtrr_state
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_init_boot_cpu  */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|mtrr_init_secondary_cpu
(paren
r_void
)paren
)paren
(brace
r_int
r_int
id|mask
comma
id|count
suffix:semicolon
r_struct
id|set_mtrr_context
id|ctxt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|boot_cpu_data.x86_capability
op_amp
id|X86_FEATURE_MTRR
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*  Note that this is not ideal, since the cache is only flushed/disabled&n;&t;for this CPU while the MTRRs are changed, but changing this requires&n;&t;more invasive changes to the way the kernel boots  */
id|set_mtrr_prepare
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
id|mask
op_assign
id|set_mtrr_state
(paren
op_amp
id|smp_mtrr_state
comma
op_amp
id|ctxt
)paren
suffix:semicolon
id|set_mtrr_done
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
multiline_comment|/*  Use the atomic bitops to update the global mask  */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
r_sizeof
id|mask
op_star
l_int|8
suffix:semicolon
op_increment
id|count
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x01
)paren
id|set_bit
(paren
id|count
comma
op_amp
id|smp_changes_mask
)paren
suffix:semicolon
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*  End Function mtrr_init_secondary_cpu  */
macro_line|#endif
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
(paren
r_void
)paren
macro_line|#else
id|__initfunc
c_func
(paren
r_int
id|mtrr_init
c_func
(paren
r_void
)paren
)paren
macro_line|#endif
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|boot_cpu_data.x86_capability
op_amp
id|X86_FEATURE_MTRR
)paren
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#  if !defined(__SMP__) || defined(MODULE) 
id|printk
c_func
(paren
l_string|&quot;mtrr: v%s Richard Gooch (rgooch@atnf.csiro.au)&bslash;n&quot;
comma
id|MTRR_VERSION
)paren
suffix:semicolon
macro_line|#  endif
macro_line|#  ifdef __SMP__
macro_line|#    ifdef MODULE
id|copy_mtrr_state
(paren
)paren
suffix:semicolon
macro_line|#    else /* MODULE */
id|finalize_mtrr_state
(paren
op_amp
id|smp_mtrr_state
)paren
suffix:semicolon
id|mtrr_state_warn
(paren
id|smp_changes_mask
)paren
suffix:semicolon
macro_line|#    endif /* MODULE */
macro_line|#  endif /* __SMP__ */
macro_line|#  ifdef CONFIG_PROC_FS
id|proc_register
(paren
op_amp
id|proc_root
comma
op_amp
id|proc_root_mtrr
)paren
suffix:semicolon
macro_line|#  endif
id|init_table
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef&t;MODULE
DECL|function|cleanup_module
r_void
id|cleanup_module
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|boot_cpu_data.x86_capability
op_amp
id|X86_FEATURE_MTRR
)paren
)paren
r_return
suffix:semicolon
macro_line|#  ifdef CONFIG_PROC_FS
id|proc_unregister
(paren
op_amp
id|proc_root
comma
id|PROC_MTRR
)paren
suffix:semicolon
macro_line|#  endif
macro_line|#    ifdef __SMP__
id|mtrr_hook
op_assign
l_int|NULL
suffix:semicolon
macro_line|#    endif
)brace
macro_line|#endif
eof
