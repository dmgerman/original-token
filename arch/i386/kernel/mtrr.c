multiline_comment|/*  Generic MTRR (Memory Type Range Register) driver.&n;&n;    Copyright (C) 1997-2000  Richard Gooch&n;&n;    This library is free software; you can redistribute it and/or&n;    modify it under the terms of the GNU Library General Public&n;    License as published by the Free Software Foundation; either&n;    version 2 of the License, or (at your option) any later version.&n;&n;    This library is distributed in the hope that it will be useful,&n;    but WITHOUT ANY WARRANTY; without even the implied warranty of&n;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n;    Library General Public License for more details.&n;&n;    You should have received a copy of the GNU Library General Public&n;    License along with this library; if not, write to the Free&n;    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n;    Richard Gooch may be reached by email at  rgooch@atnf.csiro.au&n;    The postal address is:&n;      Richard Gooch, c/o ATNF, P. O. Box 76, Epping, N.S.W., 2121, Australia.&n;&n;    Source: &quot;Pentium Pro Family Developer&squot;s Manual, Volume 3:&n;    Operating System Writer&squot;s Guide&quot; (Intel document number 242692),&n;    section 11.11.7&n;&n;    ChangeLog&n;&n;    Prehistory Martin Tischh&#xfffd;user &lt;martin@ikcbarka.fzk.de&gt;&n;&t;       Initial register-setting code (from proform-1.0).&n;    19971216   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Original version for /proc/mtrr interface, SMP-safe.&n;  v1.0&n;    19971217   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Bug fix for ioctls()&squot;s.&n;&t;       Added sample code in Documentation/mtrr.txt&n;  v1.1&n;    19971218   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Disallow overlapping regions.&n;    19971219   Jens Maurer &lt;jmaurer@menuett.rhein-main.de&gt;&n;               Register-setting fixups.&n;  v1.2&n;    19971222   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fixups for kernel 2.1.75.&n;  v1.3&n;    19971229   David Wragg &lt;dpw@doc.ic.ac.uk&gt;&n;               Register-setting fixups and conformity with Intel conventions.&n;    19971229   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Cosmetic changes and wrote this ChangeLog ;-)&n;    19980106   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fixups for kernel 2.1.78.&n;  v1.4&n;    19980119   David Wragg &lt;dpw@doc.ic.ac.uk&gt;&n;               Included passive-release enable code (elsewhere in PCI setup).&n;  v1.5&n;    19980131   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Replaced global kernel lock with private spinlock.&n;  v1.6&n;    19980201   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Added wait for other CPUs to complete changes.&n;  v1.7&n;    19980202   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Bug fix in definition of &lt;set_mtrr&gt; for UP.&n;  v1.8&n;    19980319   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fixups for kernel 2.1.90.&n;    19980323   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Move SMP BIOS fixup before secondary CPUs call &lt;calibrate_delay&gt;&n;  v1.9&n;    19980325   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Fixed test for overlapping regions: confused by adjacent regions&n;    19980326   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Added wbinvd in &lt;set_mtrr_prepare&gt;.&n;    19980401   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Bug fix for non-SMP compilation.&n;    19980418   David Wragg &lt;dpw@doc.ic.ac.uk&gt;&n;               Fixed-MTRR synchronisation for SMP and use atomic operations&n;&t;       instead of spinlocks.&n;    19980418   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Differentiate different MTRR register classes for BIOS fixup.&n;  v1.10&n;    19980419   David Wragg &lt;dpw@doc.ic.ac.uk&gt;&n;&t;       Bug fix in variable MTRR synchronisation.&n;  v1.11&n;    19980419   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixups for kernel 2.1.97.&n;  v1.12&n;    19980421   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Safer synchronisation across CPUs when changing MTRRs.&n;  v1.13&n;    19980423   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Bugfix for SMP systems without MTRR support.&n;  v1.14&n;    19980427   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Trap calls to &lt;mtrr_add&gt; and &lt;mtrr_del&gt; on non-MTRR machines.&n;  v1.15&n;    19980427   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Use atomic bitops for setting SMP change mask.&n;  v1.16&n;    19980428   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed spurious diagnostic message.&n;  v1.17&n;    19980429   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Moved register-setting macros into this file.&n;&t;       Moved setup code from init/main.c to i386-specific areas.&n;  v1.18&n;    19980502   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Moved MTRR detection outside conditionals in &lt;mtrr_init&gt;.&n;  v1.19&n;    19980502   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Documentation improvement: mention Pentium II and AGP.&n;  v1.20&n;    19980521   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Only manipulate interrupt enable flag on local CPU.&n;&t;       Allow enclosed uncachable regions.&n;  v1.21&n;    19980611   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Always define &lt;main_lock&gt;.&n;  v1.22&n;    19980901   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed module support in order to tidy up code.&n;&t;       Added sanity check for &lt;mtrr_add&gt;/&lt;mtrr_del&gt; before &lt;mtrr_init&gt;.&n;&t;       Created addition queue for prior to SMP commence.&n;  v1.23&n;    19980902   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Ported patch to kernel 2.1.120-pre3.&n;  v1.24&n;    19980910   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Removed sanity checks and addition queue: Linus prefers an OOPS.&n;  v1.25&n;    19981001   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed harmless compiler warning in include/asm-i386/mtrr.h&n;&t;       Fixed version numbering and history for v1.23 -&gt; v1.24.&n;  v1.26&n;    19990118   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added devfs support.&n;  v1.27&n;    19990123   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Changed locking to spin with reschedule.&n;&t;       Made use of new &lt;smp_call_function&gt;.&n;  v1.28&n;    19990201   Zolt&#xfffd;n B&#xfffd;sz&#xfffd;rm&#xfffd;nyi &lt;zboszor@mail.externet.hu&gt;&n;&t;       Extended the driver to be able to use Cyrix style ARRs.&n;    19990204   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Restructured Cyrix support.&n;  v1.29&n;    19990204   Zolt&#xfffd;n B&#xfffd;sz&#xfffd;rm&#xfffd;nyi &lt;zboszor@mail.externet.hu&gt;&n;&t;       Refined ARR support: enable MAPEN in set_mtrr_prepare()&n;&t;       and disable MAPEN in set_mtrr_done().&n;    19990205   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Minor cleanups.&n;  v1.30&n;    19990208   Zolt&#xfffd;n B&#xfffd;sz&#xfffd;rm&#xfffd;nyi &lt;zboszor@mail.externet.hu&gt;&n;               Protect plain 6x86s (and other processors without the&n;               Page Global Enable feature) against accessing CR4 in&n;               set_mtrr_prepare() and set_mtrr_done().&n;    19990210   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Turned &lt;set_mtrr_up&gt; and &lt;get_mtrr&gt; into function pointers.&n;  v1.31&n;    19990212   Zolt&#xfffd;n B&#xfffd;sz&#xfffd;rm&#xfffd;nyi &lt;zboszor@mail.externet.hu&gt;&n;               Major rewrite of cyrix_arr_init(): do not touch ARRs,&n;               leave them as the BIOS have set them up.&n;               Enable usage of all 8 ARRs.&n;               Avoid multiplications by 3 everywhere and other&n;               code clean ups/speed ups.&n;    19990213   Zolt&#xfffd;n B&#xfffd;sz&#xfffd;rm&#xfffd;nyi &lt;zboszor@mail.externet.hu&gt;&n;               Set up other Cyrix processors identical to the boot cpu.&n;               Since Cyrix don&squot;t support Intel APIC, this is l&squot;art pour l&squot;art.&n;               Weigh ARRs by size:&n;               If size &lt;= 32M is given, set up ARR# we were given.&n;               If size &gt;  32M is given, set up ARR7 only if it is free,&n;               fail otherwise.&n;    19990214   Zolt&#xfffd;n B&#xfffd;sz&#xfffd;rm&#xfffd;nyi &lt;zboszor@mail.externet.hu&gt;&n;               Also check for size &gt;= 256K if we are to set up ARR7,&n;               mtrr_add() returns the value it gets from set_mtrr()&n;    19990218   Zolt&#xfffd;n B&#xfffd;sz&#xfffd;rm&#xfffd;nyi &lt;zboszor@mail.externet.hu&gt;&n;               Remove Cyrix &quot;coma bug&quot; workaround from here.&n;               Moved to linux/arch/i386/kernel/setup.c and&n;               linux/include/asm-i386/bugs.h&n;    19990228   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Added MTRRIOC_KILL_ENTRY ioctl(2)&n;&t;       Trap for counter underflow in &lt;mtrr_file_del&gt;.&n;&t;       Trap for 4 MiB aligned regions for PPro, stepping &lt;= 7.&n;    19990301   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Created &lt;get_free_region&gt; hook.&n;    19990305   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Temporarily disable AMD support now MTRR capability flag is set.&n;  v1.32&n;    19990308   Zolt&#xfffd;n B&#xfffd;sz&#xfffd;rm&#xfffd;nyi &lt;zboszor@mail.externet.hu&gt;&n;&t;       Adjust my changes (19990212-19990218) to Richard Gooch&squot;s&n;&t;       latest changes. (19990228-19990305)&n;  v1.33&n;    19990309   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Fixed typo in &lt;printk&gt; message.&n;    19990310   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Support K6-II/III based on Alan Cox&squot;s &lt;alan@redhat.com&gt; patches.&n;  v1.34&n;    19990511   Bart Hartgers &lt;bart@etpmod.phys.tue.nl&gt;&n;&t;       Support Centaur C6 MCR&squot;s.&n;    19990512   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;&t;       Minor cleanups.&n;  v1.35&n;    19990707   Zolt&#xfffd;n B&#xfffd;sz&#xfffd;rm&#xfffd;nyi &lt;zboszor@mail.externet.hu&gt;&n;               Check whether ARR3 is protected in cyrix_get_free_region()&n;               and mtrr_del(). The code won&squot;t attempt to delete or change it&n;               from now on if the BIOS protected ARR3. It silently skips ARR3&n;               in cyrix_get_free_region() or returns with an error code from&n;               mtrr_del().&n;    19990711   Zolt&#xfffd;n B&#xfffd;sz&#xfffd;rm&#xfffd;nyi &lt;zboszor@mail.externet.hu&gt;&n;               Reset some bits in the CCRs in cyrix_arr_init() to disable SMM&n;               if ARR3 isn&squot;t protected. This is needed because if SMM is active&n;               and ARR3 isn&squot;t protected then deleting and setting ARR3 again&n;               may lock up the processor. With SMM entirely disabled, it does&n;               not happen.&n;    19990812   Zolt&#xfffd;n B&#xfffd;sz&#xfffd;rm&#xfffd;nyi &lt;zboszor@mail.externet.hu&gt;&n;               Rearrange switch() statements so the driver accomodates to&n;               the fact that the AMD Athlon handles its MTRRs the same way&n;               as Intel does.&n;    19990814   Zolt&#xfffd;n B&#xfffd;sz&#xfffd;rm&#xfffd;nyi &lt;zboszor@mail.externet.hu&gt;&n;&t;       Double check for Intel in mtrr_add()&squot;s big switch() because&n;&t;       that revision check is only valid for Intel CPUs.&n;    19990819   Alan Cox &lt;alan@redhat.com&gt;&n;               Tested Zoltan&squot;s changes on a pre production Athlon - 100%&n;               success.&n;    19991008   Manfred Spraul &lt;manfreds@colorfullife.com&gt;&n;    &t;       replaced spin_lock_reschedule() with a normal semaphore.&n;  v1.36&n;    20000221   Richard Gooch &lt;rgooch@atnf.csiro.au&gt;&n;               Compile fix if procfs and devfs not enabled.&n;&t;       Formatting changes.&n;  v1.37&n;    20001109   H. Peter Anvin &lt;hpa@zytor.com&gt;&n;&t;       Use the new centralized CPU feature detects.&n;*/
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
DECL|macro|MTRR_NEED_STRINGS
mdefine_line|#define MTRR_NEED_STRINGS
macro_line|#include &lt;asm/mtrr.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/msr.h&gt;
macro_line|#include &lt;asm/hardirq.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
DECL|macro|MTRR_VERSION
mdefine_line|#define MTRR_VERSION            &quot;1.37 (20001109)&quot;
DECL|macro|TRUE
mdefine_line|#define TRUE  1
DECL|macro|FALSE
mdefine_line|#define FALSE 0
multiline_comment|/*&n; * The code assumes all processors support the same MTRR&n; * interface.  This is generally a good assumption, but could&n; * potentially be a problem.&n; */
DECL|enum|mtrr_if_type
r_enum
id|mtrr_if_type
(brace
DECL|enumerator|MTRR_IF_NONE
id|MTRR_IF_NONE
comma
multiline_comment|/* No MTRRs supported */
DECL|enumerator|MTRR_IF_INTEL
id|MTRR_IF_INTEL
comma
multiline_comment|/* Intel (P6) standard MTRRs */
DECL|enumerator|MTRR_IF_AMD_K6
id|MTRR_IF_AMD_K6
comma
multiline_comment|/* AMD pre-Athlon MTRRs */
DECL|enumerator|MTRR_IF_CYRIX_ARR
id|MTRR_IF_CYRIX_ARR
comma
multiline_comment|/* Cyrix ARRs */
DECL|enumerator|MTRR_IF_CENTAUR_MCR
id|MTRR_IF_CENTAUR_MCR
comma
multiline_comment|/* Centaur MCRs */
DECL|variable|mtrr_if
)brace
id|mtrr_if
op_assign
id|MTRR_IF_NONE
suffix:semicolon
DECL|variable|mtrr_if_name
r_static
id|__initdata
r_char
op_star
id|mtrr_if_name
(braket
)braket
op_assign
(brace
l_string|&quot;none&quot;
comma
l_string|&quot;Intel&quot;
comma
l_string|&quot;AMD K6&quot;
comma
l_string|&quot;Cyrix ARR&quot;
comma
l_string|&quot;Centaur MCR&quot;
)brace
suffix:semicolon
DECL|macro|MTRRcap_MSR
mdefine_line|#define MTRRcap_MSR     0x0fe
DECL|macro|MTRRdefType_MSR
mdefine_line|#define MTRRdefType_MSR 0x2ff
DECL|macro|MTRRphysBase_MSR
mdefine_line|#define MTRRphysBase_MSR(reg) (0x200 + 2 * (reg))
DECL|macro|MTRRphysMask_MSR
mdefine_line|#define MTRRphysMask_MSR(reg) (0x200 + 2 * (reg) + 1)
DECL|macro|NUM_FIXED_RANGES
mdefine_line|#define NUM_FIXED_RANGES 88
DECL|macro|MTRRfix64K_00000_MSR
mdefine_line|#define MTRRfix64K_00000_MSR 0x250
DECL|macro|MTRRfix16K_80000_MSR
mdefine_line|#define MTRRfix16K_80000_MSR 0x258
DECL|macro|MTRRfix16K_A0000_MSR
mdefine_line|#define MTRRfix16K_A0000_MSR 0x259
DECL|macro|MTRRfix4K_C0000_MSR
mdefine_line|#define MTRRfix4K_C0000_MSR 0x268
DECL|macro|MTRRfix4K_C8000_MSR
mdefine_line|#define MTRRfix4K_C8000_MSR 0x269
DECL|macro|MTRRfix4K_D0000_MSR
mdefine_line|#define MTRRfix4K_D0000_MSR 0x26a
DECL|macro|MTRRfix4K_D8000_MSR
mdefine_line|#define MTRRfix4K_D8000_MSR 0x26b
DECL|macro|MTRRfix4K_E0000_MSR
mdefine_line|#define MTRRfix4K_E0000_MSR 0x26c
DECL|macro|MTRRfix4K_E8000_MSR
mdefine_line|#define MTRRfix4K_E8000_MSR 0x26d
DECL|macro|MTRRfix4K_F0000_MSR
mdefine_line|#define MTRRfix4K_F0000_MSR 0x26e
DECL|macro|MTRRfix4K_F8000_MSR
mdefine_line|#define MTRRfix4K_F8000_MSR 0x26f
macro_line|#ifdef CONFIG_SMP
DECL|macro|MTRR_CHANGE_MASK_FIXED
macro_line|#  define MTRR_CHANGE_MASK_FIXED     0x01
DECL|macro|MTRR_CHANGE_MASK_VARIABLE
macro_line|#  define MTRR_CHANGE_MASK_VARIABLE  0x02
DECL|macro|MTRR_CHANGE_MASK_DEFTYPE
macro_line|#  define MTRR_CHANGE_MASK_DEFTYPE   0x04
macro_line|#endif
multiline_comment|/* In the Intel processor&squot;s MTRR interface, the MTRR type is always held in&n;   an 8 bit field: */
DECL|typedef|mtrr_type
r_typedef
id|u8
id|mtrr_type
suffix:semicolon
DECL|macro|LINE_SIZE
mdefine_line|#define LINE_SIZE      80
DECL|macro|JIFFIE_TIMEOUT
mdefine_line|#define JIFFIE_TIMEOUT 100
macro_line|#ifdef CONFIG_SMP
DECL|macro|set_mtrr
macro_line|#  define set_mtrr(reg,base,size,type) set_mtrr_smp (reg, base, size, type)
macro_line|#else
DECL|macro|set_mtrr
macro_line|#  define set_mtrr(reg,base,size,type) (*set_mtrr_up) (reg, base, size, type, &bslash;&n;&t;&t;&t;&t;&t;&t;       TRUE)
macro_line|#endif
macro_line|#if defined(CONFIG_PROC_FS) || defined(CONFIG_DEVFS_FS)
DECL|macro|USERSPACE_INTERFACE
macro_line|# define USERSPACE_INTERFACE
macro_line|#endif
macro_line|#ifndef USERSPACE_INTERFACE
DECL|macro|compute_ascii
macro_line|#  define compute_ascii() while (0)
macro_line|#endif
macro_line|#ifdef USERSPACE_INTERFACE
DECL|variable|ascii_buffer
r_static
r_char
op_star
id|ascii_buffer
suffix:semicolon
DECL|variable|ascii_buf_bytes
r_static
r_int
r_int
id|ascii_buf_bytes
suffix:semicolon
macro_line|#endif
DECL|variable|usage_table
r_static
r_int
r_int
op_star
id|usage_table
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|main_lock
)paren
suffix:semicolon
multiline_comment|/*  Private functions  */
macro_line|#ifdef USERSPACE_INTERFACE
r_static
r_void
id|compute_ascii
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
DECL|struct|set_mtrr_context
r_struct
id|set_mtrr_context
(brace
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
DECL|member|deftype_lo
r_int
r_int
id|deftype_lo
suffix:semicolon
DECL|member|deftype_hi
r_int
r_int
id|deftype_hi
suffix:semicolon
DECL|member|cr4val
r_int
r_int
id|cr4val
suffix:semicolon
DECL|member|ccr3
r_int
r_int
id|ccr3
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|arr3_protected
r_static
r_int
id|arr3_protected
suffix:semicolon
multiline_comment|/*  Put the processor into a state where MTRRs can be safely set  */
DECL|function|set_mtrr_prepare
r_static
r_void
id|set_mtrr_prepare
(paren
r_struct
id|set_mtrr_context
op_star
id|ctxt
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
multiline_comment|/*  Disable interrupts locally  */
id|__save_flags
(paren
id|ctxt-&gt;flags
)paren
suffix:semicolon
id|__cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mtrr_if
op_ne
id|MTRR_IF_INTEL
op_logical_and
id|mtrr_if
op_ne
id|MTRR_IF_CYRIX_ARR
)paren
r_return
suffix:semicolon
multiline_comment|/*  Save value of CR4 and clear Page Global Enable (bit 7)  */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|X86_FEATURE_PGE
comma
op_amp
id|boot_cpu_data.x86_capability
)paren
)paren
id|asm
r_volatile
(paren
l_string|&quot;movl  %%cr4, %0&bslash;n&bslash;t&quot;
l_string|&quot;movl  %0, %1&bslash;n&bslash;t&quot;
l_string|&quot;andb  $0x7f, %b1&bslash;n&bslash;t&quot;
l_string|&quot;movl  %1, %%cr4&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|ctxt-&gt;cr4val
)paren
comma
l_string|&quot;=q&quot;
(paren
id|tmp
)paren
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*  Disable and flush caches. Note that wbinvd flushes the TLBs as&n;&t;a side-effect  */
id|asm
r_volatile
(paren
l_string|&quot;movl  %%cr0, %0&bslash;n&bslash;t&quot;
l_string|&quot;orl   $0x40000000, %0&bslash;n&bslash;t&quot;
l_string|&quot;wbinvd&bslash;n&bslash;t&quot;
l_string|&quot;movl  %0, %%cr0&bslash;n&bslash;t&quot;
l_string|&quot;wbinvd&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mtrr_if
op_eq
id|MTRR_IF_INTEL
)paren
(brace
multiline_comment|/*  Disable MTRRs, and set the default type to uncached  */
id|rdmsr
(paren
id|MTRRdefType_MSR
comma
id|ctxt-&gt;deftype_lo
comma
id|ctxt-&gt;deftype_hi
)paren
suffix:semicolon
id|wrmsr
(paren
id|MTRRdefType_MSR
comma
id|ctxt-&gt;deftype_lo
op_amp
l_int|0xf300UL
comma
id|ctxt-&gt;deftype_hi
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Cyrix ARRs - everything else were excluded at the top */
id|tmp
op_assign
id|getCx86
(paren
id|CX86_CCR3
)paren
suffix:semicolon
id|setCx86
(paren
id|CX86_CCR3
comma
(paren
id|tmp
op_amp
l_int|0x0f
)paren
op_or
l_int|0x10
)paren
suffix:semicolon
id|ctxt-&gt;ccr3
op_assign
id|tmp
suffix:semicolon
)brace
)brace
multiline_comment|/*  End Function set_mtrr_prepare  */
multiline_comment|/*  Restore the processor after a set_mtrr_prepare  */
DECL|function|set_mtrr_done
r_static
r_void
id|set_mtrr_done
(paren
r_struct
id|set_mtrr_context
op_star
id|ctxt
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|mtrr_if
op_ne
id|MTRR_IF_INTEL
op_logical_and
id|mtrr_if
op_ne
id|MTRR_IF_CYRIX_ARR
)paren
(brace
id|__restore_flags
(paren
id|ctxt-&gt;flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*  Flush caches and TLBs  */
id|asm
r_volatile
(paren
l_string|&quot;wbinvd&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*  Restore MTRRdefType  */
r_if
c_cond
(paren
id|mtrr_if
op_eq
id|MTRR_IF_INTEL
)paren
(brace
multiline_comment|/* Intel (P6) standard MTRRs */
id|wrmsr
(paren
id|MTRRdefType_MSR
comma
id|ctxt-&gt;deftype_lo
comma
id|ctxt-&gt;deftype_hi
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Cyrix ARRs - everything else was excluded at the top */
id|setCx86
(paren
id|CX86_CCR3
comma
id|ctxt-&gt;ccr3
)paren
suffix:semicolon
)brace
multiline_comment|/*  Enable caches  */
id|asm
r_volatile
(paren
l_string|&quot;movl  %%cr0, %0&bslash;n&bslash;t&quot;
l_string|&quot;andl  $0xbfffffff, %0&bslash;n&bslash;t&quot;
l_string|&quot;movl  %0, %%cr0&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*  Restore value of CR4  */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|X86_FEATURE_PGE
comma
op_amp
id|boot_cpu_data.x86_capability
)paren
)paren
id|asm
r_volatile
(paren
l_string|&quot;movl  %0, %%cr4&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|ctxt-&gt;cr4val
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
multiline_comment|/*  Re-enable interrupts locally (if enabled previously)  */
id|__restore_flags
(paren
id|ctxt-&gt;flags
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function set_mtrr_done  */
multiline_comment|/*  This function returns the number of variable MTRRs  */
DECL|function|get_num_var_ranges
r_static
r_int
r_int
id|get_num_var_ranges
(paren
r_void
)paren
(brace
r_int
r_int
id|config
comma
id|dummy
suffix:semicolon
r_switch
c_cond
(paren
id|mtrr_if
)paren
(brace
r_case
id|MTRR_IF_INTEL
suffix:colon
id|rdmsr
(paren
id|MTRRcap_MSR
comma
id|config
comma
id|dummy
)paren
suffix:semicolon
r_return
(paren
id|config
op_amp
l_int|0xff
)paren
suffix:semicolon
r_case
id|MTRR_IF_AMD_K6
suffix:colon
r_return
l_int|2
suffix:semicolon
r_case
id|MTRR_IF_CYRIX_ARR
suffix:colon
r_return
l_int|8
suffix:semicolon
r_case
id|MTRR_IF_CENTAUR_MCR
suffix:colon
r_return
l_int|8
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*  End Function get_num_var_ranges  */
multiline_comment|/*  Returns non-zero if we have the write-combining memory type  */
DECL|function|have_wrcomb
r_static
r_int
id|have_wrcomb
(paren
r_void
)paren
(brace
r_int
r_int
id|config
comma
id|dummy
suffix:semicolon
r_switch
c_cond
(paren
id|mtrr_if
)paren
(brace
r_case
id|MTRR_IF_INTEL
suffix:colon
id|rdmsr
(paren
id|MTRRcap_MSR
comma
id|config
comma
id|dummy
)paren
suffix:semicolon
r_return
(paren
id|config
op_amp
(paren
l_int|1
op_lshift
l_int|10
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
id|MTRR_IF_AMD_K6
suffix:colon
r_case
id|MTRR_IF_CENTAUR_MCR
suffix:colon
r_case
id|MTRR_IF_CYRIX_ARR
suffix:colon
r_return
l_int|1
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*  End Function have_wrcomb  */
DECL|variable|size_or_mask
DECL|variable|size_and_mask
r_static
id|u32
id|size_or_mask
comma
id|size_and_mask
suffix:semicolon
DECL|function|intel_get_mtrr
r_static
r_void
id|intel_get_mtrr
(paren
r_int
r_int
id|reg
comma
r_int
r_int
op_star
id|base
comma
r_int
r_int
op_star
id|size
comma
id|mtrr_type
op_star
id|type
)paren
(brace
r_int
r_int
id|mask_lo
comma
id|mask_hi
comma
id|base_lo
comma
id|base_hi
suffix:semicolon
id|rdmsr
(paren
id|MTRRphysMask_MSR
c_func
(paren
id|reg
)paren
comma
id|mask_lo
comma
id|mask_hi
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mask_lo
op_amp
l_int|0x800
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*  Invalid (i.e. free) range  */
op_star
id|base
op_assign
l_int|0
suffix:semicolon
op_star
id|size
op_assign
l_int|0
suffix:semicolon
op_star
id|type
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rdmsr
c_func
(paren
id|MTRRphysBase_MSR
c_func
(paren
id|reg
)paren
comma
id|base_lo
comma
id|base_hi
)paren
suffix:semicolon
multiline_comment|/* Work out the shifted address mask. */
id|mask_lo
op_assign
id|size_or_mask
op_or
id|mask_hi
op_lshift
(paren
l_int|32
op_minus
id|PAGE_SHIFT
)paren
op_or
id|mask_lo
op_rshift
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* This works correctly if size is a power of two, i.e. a&n;       contiguous range. */
op_star
id|size
op_assign
op_minus
id|mask_lo
suffix:semicolon
op_star
id|base
op_assign
id|base_hi
op_lshift
(paren
l_int|32
op_minus
id|PAGE_SHIFT
)paren
op_or
id|base_lo
op_rshift
id|PAGE_SHIFT
suffix:semicolon
op_star
id|type
op_assign
id|base_lo
op_amp
l_int|0xff
suffix:semicolon
)brace
multiline_comment|/*  End Function intel_get_mtrr  */
DECL|function|cyrix_get_arr
r_static
r_void
id|cyrix_get_arr
(paren
r_int
r_int
id|reg
comma
r_int
r_int
op_star
id|base
comma
r_int
r_int
op_star
id|size
comma
id|mtrr_type
op_star
id|type
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|arr
comma
id|ccr3
comma
id|rcr
comma
id|shift
suffix:semicolon
id|arr
op_assign
id|CX86_ARR_BASE
op_plus
(paren
id|reg
op_lshift
l_int|1
)paren
op_plus
id|reg
suffix:semicolon
multiline_comment|/* avoid multiplication by 3 */
multiline_comment|/* Save flags and disable interrupts */
id|__save_flags
(paren
id|flags
)paren
suffix:semicolon
id|__cli
(paren
)paren
suffix:semicolon
id|ccr3
op_assign
id|getCx86
(paren
id|CX86_CCR3
)paren
suffix:semicolon
id|setCx86
(paren
id|CX86_CCR3
comma
(paren
id|ccr3
op_amp
l_int|0x0f
)paren
op_or
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* enable MAPEN */
(paren
(paren
r_int
r_char
op_star
)paren
id|base
)paren
(braket
l_int|3
)braket
op_assign
id|getCx86
(paren
id|arr
)paren
suffix:semicolon
(paren
(paren
r_int
r_char
op_star
)paren
id|base
)paren
(braket
l_int|2
)braket
op_assign
id|getCx86
(paren
id|arr
op_plus
l_int|1
)paren
suffix:semicolon
(paren
(paren
r_int
r_char
op_star
)paren
id|base
)paren
(braket
l_int|1
)braket
op_assign
id|getCx86
(paren
id|arr
op_plus
l_int|2
)paren
suffix:semicolon
id|rcr
op_assign
id|getCx86
c_func
(paren
id|CX86_RCR_BASE
op_plus
id|reg
)paren
suffix:semicolon
id|setCx86
(paren
id|CX86_CCR3
comma
id|ccr3
)paren
suffix:semicolon
multiline_comment|/* disable MAPEN */
multiline_comment|/* Enable interrupts if it was enabled previously */
id|__restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|shift
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|base
)paren
(braket
l_int|1
)braket
op_amp
l_int|0x0f
suffix:semicolon
op_star
id|base
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
multiline_comment|/* Power of two, at least 4K on ARR0-ARR6, 256K on ARR7&n;     * Note: shift==0xf means 4G, this is unsupported.&n;     */
r_if
c_cond
(paren
id|shift
)paren
op_star
id|size
op_assign
(paren
id|reg
OL
l_int|7
ques
c_cond
l_int|0x1UL
suffix:colon
l_int|0x40UL
)paren
op_lshift
id|shift
suffix:semicolon
r_else
op_star
id|size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Bit 0 is Cache Enable on ARR7, Cache Disable on ARR0-ARR6 */
r_if
c_cond
(paren
id|reg
OL
l_int|7
)paren
(brace
r_switch
c_cond
(paren
id|rcr
)paren
(brace
r_case
l_int|1
suffix:colon
op_star
id|type
op_assign
id|MTRR_TYPE_UNCACHABLE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
op_star
id|type
op_assign
id|MTRR_TYPE_WRBACK
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
op_star
id|type
op_assign
id|MTRR_TYPE_WRCOMB
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|24
suffix:colon
r_default
suffix:colon
op_star
id|type
op_assign
id|MTRR_TYPE_WRTHROUGH
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
r_switch
c_cond
(paren
id|rcr
)paren
(brace
r_case
l_int|0
suffix:colon
op_star
id|type
op_assign
id|MTRR_TYPE_UNCACHABLE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
op_star
id|type
op_assign
id|MTRR_TYPE_WRCOMB
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
op_star
id|type
op_assign
id|MTRR_TYPE_WRBACK
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|25
suffix:colon
r_default
suffix:colon
op_star
id|type
op_assign
id|MTRR_TYPE_WRTHROUGH
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*  End Function cyrix_get_arr  */
DECL|function|amd_get_mtrr
r_static
r_void
id|amd_get_mtrr
(paren
r_int
r_int
id|reg
comma
r_int
r_int
op_star
id|base
comma
r_int
r_int
op_star
id|size
comma
id|mtrr_type
op_star
id|type
)paren
(brace
r_int
r_int
id|low
comma
id|high
suffix:semicolon
id|rdmsr
(paren
l_int|0xC0000085
comma
id|low
comma
id|high
)paren
suffix:semicolon
multiline_comment|/*  Upper dword is region 1, lower is region 0  */
r_if
c_cond
(paren
id|reg
op_eq
l_int|1
)paren
id|low
op_assign
id|high
suffix:semicolon
multiline_comment|/*  The base masks off on the right alignment  */
op_star
id|base
op_assign
(paren
id|low
op_amp
l_int|0xFFFE0000
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
op_star
id|type
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|low
op_amp
l_int|1
)paren
op_star
id|type
op_assign
id|MTRR_TYPE_UNCACHABLE
suffix:semicolon
r_if
c_cond
(paren
id|low
op_amp
l_int|2
)paren
op_star
id|type
op_assign
id|MTRR_TYPE_WRCOMB
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|low
op_amp
l_int|3
)paren
)paren
(brace
op_star
id|size
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;     *&t;This needs a little explaining. The size is stored as an&n;     *&t;inverted mask of bits of 128K granularity 15 bits long offset&n;     *&t;2 bits&n;     *&n;     *&t;So to get a size we do invert the mask and add 1 to the lowest&n;     *&t;mask bit (4 as its 2 bits in). This gives us a size we then shift&n;     *&t;to turn into 128K blocks&n;     *&n;     *&t;eg&t;&t;111 1111 1111 1100      is 512K&n;     *&n;     *&t;invert&t;&t;000 0000 0000 0011&n;     *&t;+1&t;&t;000 0000 0000 0100&n;     *&t;*128K&t;...&n;     */
id|low
op_assign
(paren
op_complement
id|low
)paren
op_amp
l_int|0x1FFFC
suffix:semicolon
op_star
id|size
op_assign
(paren
id|low
op_plus
l_int|4
)paren
op_lshift
(paren
l_int|15
op_minus
id|PAGE_SHIFT
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*  End Function amd_get_mtrr  */
r_static
r_struct
(brace
DECL|member|high
r_int
r_int
id|high
suffix:semicolon
DECL|member|low
r_int
r_int
id|low
suffix:semicolon
DECL|variable|centaur_mcr
)brace
id|centaur_mcr
(braket
l_int|8
)braket
suffix:semicolon
DECL|function|centaur_get_mcr
r_static
r_void
id|centaur_get_mcr
(paren
r_int
r_int
id|reg
comma
r_int
r_int
op_star
id|base
comma
r_int
r_int
op_star
id|size
comma
id|mtrr_type
op_star
id|type
)paren
(brace
op_star
id|base
op_assign
id|centaur_mcr
(braket
id|reg
)braket
dot
id|high
op_rshift
id|PAGE_SHIFT
suffix:semicolon
op_star
id|size
op_assign
op_minus
(paren
id|centaur_mcr
(braket
id|reg
)braket
dot
id|low
op_amp
l_int|0xfffff000
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
op_star
id|type
op_assign
id|MTRR_TYPE_WRCOMB
suffix:semicolon
multiline_comment|/*  If it is there, it is write-combining  */
)brace
multiline_comment|/*  End Function centaur_get_mcr  */
DECL|variable|get_mtrr
r_static
r_void
(paren
op_star
id|get_mtrr
)paren
(paren
r_int
r_int
id|reg
comma
r_int
r_int
op_star
id|base
comma
r_int
r_int
op_star
id|size
comma
id|mtrr_type
op_star
id|type
)paren
suffix:semicolon
DECL|function|intel_set_mtrr_up
r_static
r_void
id|intel_set_mtrr_up
(paren
r_int
r_int
id|reg
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
id|mtrr_type
id|type
comma
r_int
id|do_safe
)paren
multiline_comment|/*  [SUMMARY] Set variable MTRR register on the local CPU.&n;    &lt;reg&gt; The register to set.&n;    &lt;base&gt; The base address of the region.&n;    &lt;size&gt; The size of the region. If this is 0 the region is disabled.&n;    &lt;type&gt; The type of the region.&n;    &lt;do_safe&gt; If TRUE, do the change safely. If FALSE, safety measures should&n;    be done externally.&n;    [RETURNS] Nothing.&n;*/
(brace
r_struct
id|set_mtrr_context
id|ctxt
suffix:semicolon
r_if
c_cond
(paren
id|do_safe
)paren
id|set_mtrr_prepare
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
(brace
multiline_comment|/* The invalid bit is kept in the mask, so we simply clear the&n;&t;   relevant mask register to disable a range. */
id|wrmsr
(paren
id|MTRRphysMask_MSR
(paren
id|reg
)paren
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|wrmsr
(paren
id|MTRRphysBase_MSR
(paren
id|reg
)paren
comma
id|base
op_lshift
id|PAGE_SHIFT
op_or
id|type
comma
(paren
id|base
op_amp
id|size_and_mask
)paren
op_rshift
(paren
l_int|32
op_minus
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
id|wrmsr
(paren
id|MTRRphysMask_MSR
(paren
id|reg
)paren
comma
op_minus
id|size
op_lshift
id|PAGE_SHIFT
op_or
l_int|0x800
comma
(paren
op_minus
id|size
op_amp
id|size_and_mask
)paren
op_rshift
(paren
l_int|32
op_minus
id|PAGE_SHIFT
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_safe
)paren
id|set_mtrr_done
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function intel_set_mtrr_up  */
DECL|function|cyrix_set_arr_up
r_static
r_void
id|cyrix_set_arr_up
(paren
r_int
r_int
id|reg
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
id|mtrr_type
id|type
comma
r_int
id|do_safe
)paren
(brace
r_struct
id|set_mtrr_context
id|ctxt
suffix:semicolon
r_int
r_char
id|arr
comma
id|arr_type
comma
id|arr_size
suffix:semicolon
id|arr
op_assign
id|CX86_ARR_BASE
op_plus
(paren
id|reg
op_lshift
l_int|1
)paren
op_plus
id|reg
suffix:semicolon
multiline_comment|/* avoid multiplication by 3 */
multiline_comment|/* count down from 32M (ARR0-ARR6) or from 2G (ARR7) */
r_if
c_cond
(paren
id|reg
op_ge
l_int|7
)paren
id|size
op_rshift_assign
l_int|6
suffix:semicolon
id|size
op_and_assign
l_int|0x7fff
suffix:semicolon
multiline_comment|/* make sure arr_size &lt;= 14 */
r_for
c_loop
(paren
id|arr_size
op_assign
l_int|0
suffix:semicolon
id|size
suffix:semicolon
id|arr_size
op_increment
comma
id|size
op_rshift_assign
l_int|1
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reg
OL
l_int|7
)paren
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|MTRR_TYPE_UNCACHABLE
suffix:colon
id|arr_type
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRR_TYPE_WRCOMB
suffix:colon
id|arr_type
op_assign
l_int|9
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRR_TYPE_WRTHROUGH
suffix:colon
id|arr_type
op_assign
l_int|24
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|arr_type
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|MTRR_TYPE_UNCACHABLE
suffix:colon
id|arr_type
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRR_TYPE_WRCOMB
suffix:colon
id|arr_type
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRR_TYPE_WRTHROUGH
suffix:colon
id|arr_type
op_assign
l_int|25
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|arr_type
op_assign
l_int|9
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|do_safe
)paren
id|set_mtrr_prepare
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
id|base
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|setCx86
c_func
(paren
id|arr
comma
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|base
)paren
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|setCx86
c_func
(paren
id|arr
op_plus
l_int|1
comma
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|base
)paren
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|setCx86
c_func
(paren
id|arr
op_plus
l_int|2
comma
(paren
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|base
)paren
(braket
l_int|1
)braket
)paren
op_or
id|arr_size
)paren
suffix:semicolon
id|setCx86
c_func
(paren
id|CX86_RCR_BASE
op_plus
id|reg
comma
id|arr_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_safe
)paren
id|set_mtrr_done
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function cyrix_set_arr_up  */
DECL|function|amd_set_mtrr_up
r_static
r_void
id|amd_set_mtrr_up
(paren
r_int
r_int
id|reg
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
id|mtrr_type
id|type
comma
r_int
id|do_safe
)paren
multiline_comment|/*  [SUMMARY] Set variable MTRR register on the local CPU.&n;    &lt;reg&gt; The register to set.&n;    &lt;base&gt; The base address of the region.&n;    &lt;size&gt; The size of the region. If this is 0 the region is disabled.&n;    &lt;type&gt; The type of the region.&n;    &lt;do_safe&gt; If TRUE, do the change safely. If FALSE, safety measures should&n;    be done externally.&n;    [RETURNS] Nothing.&n;*/
(brace
id|u32
id|regs
(braket
l_int|2
)braket
suffix:semicolon
r_struct
id|set_mtrr_context
id|ctxt
suffix:semicolon
r_if
c_cond
(paren
id|do_safe
)paren
id|set_mtrr_prepare
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
multiline_comment|/*&n;     *&t;Low is MTRR0 , High MTRR 1&n;     */
id|rdmsr
(paren
l_int|0xC0000085
comma
id|regs
(braket
l_int|0
)braket
comma
id|regs
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;     *&t;Blank to disable&n;     */
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
id|regs
(braket
id|reg
)braket
op_assign
l_int|0
suffix:semicolon
r_else
multiline_comment|/* Set the register to the base, the type (off by one) and an&n;&t;   inverted bitmask of the size The size is the only odd&n;&t;   bit. We are fed say 512K We invert this and we get 111 1111&n;&t;   1111 1011 but if you subtract one and invert you get the   &n;&t;   desired 111 1111 1111 1100 mask&n;&n;&t;   But ~(x - 1) == ~x + 1 == -x. Two&squot;s complement rocks!  */
id|regs
(braket
id|reg
)braket
op_assign
(paren
op_minus
id|size
op_rshift
(paren
l_int|15
op_minus
id|PAGE_SHIFT
)paren
op_amp
l_int|0x0001FFFC
)paren
op_or
(paren
id|base
op_lshift
id|PAGE_SHIFT
)paren
op_or
(paren
id|type
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;     *&t;The writeback rule is quite specific. See the manual. Its&n;     *&t;disable local interrupts, write back the cache, set the mtrr&n;     */
id|__asm__
id|__volatile__
(paren
l_string|&quot;wbinvd&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|wrmsr
(paren
l_int|0xC0000085
comma
id|regs
(braket
l_int|0
)braket
comma
id|regs
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_safe
)paren
id|set_mtrr_done
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function amd_set_mtrr_up  */
DECL|function|centaur_set_mcr_up
r_static
r_void
id|centaur_set_mcr_up
(paren
r_int
r_int
id|reg
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
id|mtrr_type
id|type
comma
r_int
id|do_safe
)paren
(brace
r_struct
id|set_mtrr_context
id|ctxt
suffix:semicolon
r_int
r_int
id|low
comma
id|high
suffix:semicolon
r_if
c_cond
(paren
id|do_safe
)paren
id|set_mtrr_prepare
c_func
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
(brace
multiline_comment|/*  Disable  */
id|high
op_assign
id|low
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|high
op_assign
id|base
op_lshift
id|PAGE_SHIFT
suffix:semicolon
id|low
op_assign
op_minus
id|size
op_lshift
id|PAGE_SHIFT
op_or
l_int|0x1f
suffix:semicolon
multiline_comment|/* only support write-combining... */
)brace
id|centaur_mcr
(braket
id|reg
)braket
dot
id|high
op_assign
id|high
suffix:semicolon
id|centaur_mcr
(braket
id|reg
)braket
dot
id|low
op_assign
id|low
suffix:semicolon
id|wrmsr
(paren
l_int|0x110
op_plus
id|reg
comma
id|low
comma
id|high
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_safe
)paren
id|set_mtrr_done
c_func
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function centaur_set_mtrr_up  */
DECL|variable|set_mtrr_up
r_static
r_void
(paren
op_star
id|set_mtrr_up
)paren
(paren
r_int
r_int
id|reg
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
id|mtrr_type
id|type
comma
r_int
id|do_safe
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
DECL|struct|mtrr_var_range
r_struct
id|mtrr_var_range
(brace
DECL|member|base_lo
r_int
r_int
id|base_lo
suffix:semicolon
DECL|member|base_hi
r_int
r_int
id|base_hi
suffix:semicolon
DECL|member|mask_lo
r_int
r_int
id|mask_lo
suffix:semicolon
DECL|member|mask_hi
r_int
r_int
id|mask_hi
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*  Get the MSR pair relating to a var range  */
DECL|function|get_mtrr_var_range
r_static
r_void
id|__init
id|get_mtrr_var_range
(paren
r_int
r_int
id|index
comma
r_struct
id|mtrr_var_range
op_star
id|vr
)paren
(brace
id|rdmsr
(paren
id|MTRRphysBase_MSR
(paren
id|index
)paren
comma
id|vr-&gt;base_lo
comma
id|vr-&gt;base_hi
)paren
suffix:semicolon
id|rdmsr
(paren
id|MTRRphysMask_MSR
(paren
id|index
)paren
comma
id|vr-&gt;mask_lo
comma
id|vr-&gt;mask_hi
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function get_mtrr_var_range  */
multiline_comment|/*  Set the MSR pair relating to a var range. Returns TRUE if&n;    changes are made  */
DECL|function|set_mtrr_var_range_testing
r_static
r_int
id|__init
id|set_mtrr_var_range_testing
(paren
r_int
r_int
id|index
comma
r_struct
id|mtrr_var_range
op_star
id|vr
)paren
(brace
r_int
r_int
id|lo
comma
id|hi
suffix:semicolon
r_int
id|changed
op_assign
id|FALSE
suffix:semicolon
id|rdmsr
c_func
(paren
id|MTRRphysBase_MSR
c_func
(paren
id|index
)paren
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vr-&gt;base_lo
op_amp
l_int|0xfffff0ffUL
)paren
op_ne
(paren
id|lo
op_amp
l_int|0xfffff0ffUL
)paren
op_logical_or
(paren
id|vr-&gt;base_hi
op_amp
l_int|0xfUL
)paren
op_ne
(paren
id|hi
op_amp
l_int|0xfUL
)paren
)paren
(brace
id|wrmsr
(paren
id|MTRRphysBase_MSR
c_func
(paren
id|index
)paren
comma
id|vr-&gt;base_lo
comma
id|vr-&gt;base_hi
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
id|rdmsr
(paren
id|MTRRphysMask_MSR
c_func
(paren
id|index
)paren
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|vr-&gt;mask_lo
op_amp
l_int|0xfffff800UL
)paren
op_ne
(paren
id|lo
op_amp
l_int|0xfffff800UL
)paren
op_logical_or
(paren
id|vr-&gt;mask_hi
op_amp
l_int|0xfUL
)paren
op_ne
(paren
id|hi
op_amp
l_int|0xfUL
)paren
)paren
(brace
id|wrmsr
c_func
(paren
id|MTRRphysMask_MSR
c_func
(paren
id|index
)paren
comma
id|vr-&gt;mask_lo
comma
id|vr-&gt;mask_hi
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
r_return
id|changed
suffix:semicolon
)brace
multiline_comment|/*  End Function set_mtrr_var_range_testing  */
DECL|function|get_fixed_ranges
r_static
r_void
id|__init
id|get_fixed_ranges
c_func
(paren
id|mtrr_type
op_star
id|frs
)paren
(brace
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|frs
suffix:semicolon
r_int
id|i
suffix:semicolon
id|rdmsr
c_func
(paren
id|MTRRfix64K_00000_MSR
comma
id|p
(braket
l_int|0
)braket
comma
id|p
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|rdmsr
c_func
(paren
id|MTRRfix16K_80000_MSR
op_plus
id|i
comma
id|p
(braket
l_int|2
op_plus
id|i
op_star
l_int|2
)braket
comma
id|p
(braket
l_int|3
op_plus
id|i
op_star
l_int|2
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|rdmsr
c_func
(paren
id|MTRRfix4K_C0000_MSR
op_plus
id|i
comma
id|p
(braket
l_int|6
op_plus
id|i
op_star
l_int|2
)braket
comma
id|p
(braket
l_int|7
op_plus
id|i
op_star
l_int|2
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function get_fixed_ranges  */
DECL|function|set_fixed_ranges_testing
r_static
r_int
id|__init
id|set_fixed_ranges_testing
c_func
(paren
id|mtrr_type
op_star
id|frs
)paren
(brace
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|frs
suffix:semicolon
r_int
id|changed
op_assign
id|FALSE
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|lo
comma
id|hi
suffix:semicolon
id|rdmsr
c_func
(paren
id|MTRRfix64K_00000_MSR
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_ne
id|lo
op_logical_or
id|p
(braket
l_int|1
)braket
op_ne
id|hi
)paren
(brace
id|wrmsr
(paren
id|MTRRfix64K_00000_MSR
comma
id|p
(braket
l_int|0
)braket
comma
id|p
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rdmsr
(paren
id|MTRRfix16K_80000_MSR
op_plus
id|i
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|2
op_plus
id|i
op_star
l_int|2
)braket
op_ne
id|lo
op_logical_or
id|p
(braket
l_int|3
op_plus
id|i
op_star
l_int|2
)braket
op_ne
id|hi
)paren
(brace
id|wrmsr
(paren
id|MTRRfix16K_80000_MSR
op_plus
id|i
comma
id|p
(braket
l_int|2
op_plus
id|i
op_star
l_int|2
)braket
comma
id|p
(braket
l_int|3
op_plus
id|i
op_star
l_int|2
)braket
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rdmsr
(paren
id|MTRRfix4K_C0000_MSR
op_plus
id|i
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|6
op_plus
id|i
op_star
l_int|2
)braket
op_ne
id|lo
op_logical_or
id|p
(braket
l_int|7
op_plus
id|i
op_star
l_int|2
)braket
op_ne
id|hi
)paren
(brace
id|wrmsr
c_func
(paren
id|MTRRfix4K_C0000_MSR
op_plus
id|i
comma
id|p
(braket
l_int|6
op_plus
id|i
op_star
l_int|2
)braket
comma
id|p
(braket
l_int|7
op_plus
id|i
op_star
l_int|2
)braket
)paren
suffix:semicolon
id|changed
op_assign
id|TRUE
suffix:semicolon
)brace
)brace
r_return
id|changed
suffix:semicolon
)brace
multiline_comment|/*  End Function set_fixed_ranges_testing  */
DECL|struct|mtrr_state
r_struct
id|mtrr_state
(brace
DECL|member|num_var_ranges
r_int
r_int
id|num_var_ranges
suffix:semicolon
DECL|member|var_ranges
r_struct
id|mtrr_var_range
op_star
id|var_ranges
suffix:semicolon
DECL|member|fixed_ranges
id|mtrr_type
id|fixed_ranges
(braket
id|NUM_FIXED_RANGES
)braket
suffix:semicolon
DECL|member|enabled
r_int
r_char
id|enabled
suffix:semicolon
DECL|member|def_type
id|mtrr_type
id|def_type
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*  Grab all of the MTRR state for this CPU into *state  */
DECL|function|get_mtrr_state
r_static
r_void
id|__init
id|get_mtrr_state
c_func
(paren
r_struct
id|mtrr_state
op_star
id|state
)paren
(brace
r_int
r_int
id|nvrs
comma
id|i
suffix:semicolon
r_struct
id|mtrr_var_range
op_star
id|vrs
suffix:semicolon
r_int
r_int
id|lo
comma
id|dummy
suffix:semicolon
id|nvrs
op_assign
id|state-&gt;num_var_ranges
op_assign
id|get_num_var_ranges
c_func
(paren
)paren
suffix:semicolon
id|vrs
op_assign
id|state-&gt;var_ranges
op_assign
id|kmalloc
(paren
id|nvrs
op_star
r_sizeof
(paren
r_struct
id|mtrr_var_range
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vrs
op_eq
l_int|NULL
)paren
id|nvrs
op_assign
id|state-&gt;num_var_ranges
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nvrs
suffix:semicolon
id|i
op_increment
)paren
id|get_mtrr_var_range
(paren
id|i
comma
op_amp
id|vrs
(braket
id|i
)braket
)paren
suffix:semicolon
id|get_fixed_ranges
(paren
id|state-&gt;fixed_ranges
)paren
suffix:semicolon
id|rdmsr
(paren
id|MTRRdefType_MSR
comma
id|lo
comma
id|dummy
)paren
suffix:semicolon
id|state-&gt;def_type
op_assign
(paren
id|lo
op_amp
l_int|0xff
)paren
suffix:semicolon
id|state-&gt;enabled
op_assign
(paren
id|lo
op_amp
l_int|0xc00
)paren
op_rshift
l_int|10
suffix:semicolon
)brace
multiline_comment|/*  End Function get_mtrr_state  */
multiline_comment|/*  Free resources associated with a struct mtrr_state  */
DECL|function|finalize_mtrr_state
r_static
r_void
id|__init
id|finalize_mtrr_state
c_func
(paren
r_struct
id|mtrr_state
op_star
id|state
)paren
(brace
r_if
c_cond
(paren
id|state-&gt;var_ranges
)paren
id|kfree
(paren
id|state-&gt;var_ranges
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function finalize_mtrr_state  */
DECL|function|set_mtrr_state
r_static
r_int
r_int
id|__init
id|set_mtrr_state
(paren
r_struct
id|mtrr_state
op_star
id|state
comma
r_struct
id|set_mtrr_context
op_star
id|ctxt
)paren
multiline_comment|/*  [SUMMARY] Set the MTRR state for this CPU.&n;    &lt;state&gt; The MTRR state information to read.&n;    &lt;ctxt&gt; Some relevant CPU context.&n;    [NOTE] The CPU must already be in a safe state for MTRR changes.&n;    [RETURNS] 0 if no changes made, else a mask indication what was changed.&n;*/
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|change_mask
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|state-&gt;num_var_ranges
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|set_mtrr_var_range_testing
(paren
id|i
comma
op_amp
id|state-&gt;var_ranges
(braket
id|i
)braket
)paren
)paren
id|change_mask
op_or_assign
id|MTRR_CHANGE_MASK_VARIABLE
suffix:semicolon
r_if
c_cond
(paren
id|set_fixed_ranges_testing
c_func
(paren
id|state-&gt;fixed_ranges
)paren
)paren
id|change_mask
op_or_assign
id|MTRR_CHANGE_MASK_FIXED
suffix:semicolon
multiline_comment|/*  Set_mtrr_restore restores the old value of MTRRdefType,&n;&t;so to set it we fiddle with the saved value  */
r_if
c_cond
(paren
(paren
id|ctxt-&gt;deftype_lo
op_amp
l_int|0xff
)paren
op_ne
id|state-&gt;def_type
op_logical_or
(paren
(paren
id|ctxt-&gt;deftype_lo
op_amp
l_int|0xc00
)paren
op_rshift
l_int|10
)paren
op_ne
id|state-&gt;enabled
)paren
(brace
id|ctxt-&gt;deftype_lo
op_or_assign
(paren
id|state-&gt;def_type
op_or
id|state-&gt;enabled
op_lshift
l_int|10
)paren
suffix:semicolon
id|change_mask
op_or_assign
id|MTRR_CHANGE_MASK_DEFTYPE
suffix:semicolon
)brace
r_return
id|change_mask
suffix:semicolon
)brace
multiline_comment|/*  End Function set_mtrr_state  */
DECL|variable|undone_count
r_static
id|atomic_t
id|undone_count
suffix:semicolon
DECL|variable|wait_barrier_execute
r_static
r_volatile
r_int
id|wait_barrier_execute
op_assign
id|FALSE
suffix:semicolon
DECL|variable|wait_barrier_cache_enable
r_static
r_volatile
r_int
id|wait_barrier_cache_enable
op_assign
id|FALSE
suffix:semicolon
DECL|struct|set_mtrr_data
r_struct
id|set_mtrr_data
(brace
DECL|member|smp_base
r_int
r_int
id|smp_base
suffix:semicolon
DECL|member|smp_size
r_int
r_int
id|smp_size
suffix:semicolon
DECL|member|smp_reg
r_int
r_int
id|smp_reg
suffix:semicolon
DECL|member|smp_type
id|mtrr_type
id|smp_type
suffix:semicolon
)brace
suffix:semicolon
DECL|function|ipi_handler
r_static
r_void
id|ipi_handler
(paren
r_void
op_star
id|info
)paren
multiline_comment|/*  [SUMMARY] Synchronisation handler. Executed by &quot;other&quot; CPUs.&n;    [RETURNS] Nothing.&n;*/
(brace
r_struct
id|set_mtrr_data
op_star
id|data
op_assign
id|info
suffix:semicolon
r_struct
id|set_mtrr_context
id|ctxt
suffix:semicolon
id|set_mtrr_prepare
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
multiline_comment|/*  Notify master that I&squot;ve flushed and disabled my cache  */
id|atomic_dec
(paren
op_amp
id|undone_count
)paren
suffix:semicolon
r_while
c_loop
(paren
id|wait_barrier_execute
)paren
id|barrier
(paren
)paren
suffix:semicolon
multiline_comment|/*  The master has cleared me to execute  */
(paren
op_star
id|set_mtrr_up
)paren
(paren
id|data-&gt;smp_reg
comma
id|data-&gt;smp_base
comma
id|data-&gt;smp_size
comma
id|data-&gt;smp_type
comma
id|FALSE
)paren
suffix:semicolon
multiline_comment|/*  Notify master CPU that I&squot;ve executed the function  */
id|atomic_dec
(paren
op_amp
id|undone_count
)paren
suffix:semicolon
multiline_comment|/*  Wait for master to clear me to enable cache and return  */
r_while
c_loop
(paren
id|wait_barrier_cache_enable
)paren
id|barrier
(paren
)paren
suffix:semicolon
id|set_mtrr_done
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function ipi_handler  */
DECL|function|set_mtrr_smp
r_static
r_void
id|set_mtrr_smp
(paren
r_int
r_int
id|reg
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
id|mtrr_type
id|type
)paren
(brace
r_struct
id|set_mtrr_data
id|data
suffix:semicolon
r_struct
id|set_mtrr_context
id|ctxt
suffix:semicolon
id|data.smp_reg
op_assign
id|reg
suffix:semicolon
id|data.smp_base
op_assign
id|base
suffix:semicolon
id|data.smp_size
op_assign
id|size
suffix:semicolon
id|data.smp_type
op_assign
id|type
suffix:semicolon
id|wait_barrier_execute
op_assign
id|TRUE
suffix:semicolon
id|wait_barrier_cache_enable
op_assign
id|TRUE
suffix:semicolon
id|atomic_set
(paren
op_amp
id|undone_count
comma
id|smp_num_cpus
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*  Start the ball rolling on other CPUs  */
r_if
c_cond
(paren
id|smp_call_function
(paren
id|ipi_handler
comma
op_amp
id|data
comma
l_int|1
comma
l_int|0
)paren
op_ne
l_int|0
)paren
id|panic
(paren
l_string|&quot;mtrr: timed out waiting for other CPUs&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Flush and disable the local CPU&squot;s cache */
id|set_mtrr_prepare
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
multiline_comment|/*  Wait for all other CPUs to flush and disable their caches  */
r_while
c_loop
(paren
id|atomic_read
(paren
op_amp
id|undone_count
)paren
OG
l_int|0
)paren
id|barrier
(paren
)paren
suffix:semicolon
multiline_comment|/* Set up for completion wait and then release other CPUs to change MTRRs*/
id|atomic_set
(paren
op_amp
id|undone_count
comma
id|smp_num_cpus
op_minus
l_int|1
)paren
suffix:semicolon
id|wait_barrier_execute
op_assign
id|FALSE
suffix:semicolon
(paren
op_star
id|set_mtrr_up
)paren
(paren
id|reg
comma
id|base
comma
id|size
comma
id|type
comma
id|FALSE
)paren
suffix:semicolon
multiline_comment|/*  Now wait for other CPUs to complete the function  */
r_while
c_loop
(paren
id|atomic_read
(paren
op_amp
id|undone_count
)paren
OG
l_int|0
)paren
id|barrier
(paren
)paren
suffix:semicolon
multiline_comment|/*  Now all CPUs should have finished the function. Release the barrier to&n;&t;allow them to re-enable their caches and return from their interrupt,&n;&t;then enable the local cache and return  */
id|wait_barrier_cache_enable
op_assign
id|FALSE
suffix:semicolon
id|set_mtrr_done
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function set_mtrr_smp  */
multiline_comment|/*  Some BIOS&squot;s are fucked and don&squot;t set all MTRRs the same!  */
DECL|function|mtrr_state_warn
r_static
r_void
id|__init
id|mtrr_state_warn
c_func
(paren
r_int
r_int
id|mask
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mask
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|MTRR_CHANGE_MASK_FIXED
)paren
id|printk
(paren
l_string|&quot;mtrr: your CPUs had inconsistent fixed MTRR settings&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|MTRR_CHANGE_MASK_VARIABLE
)paren
id|printk
(paren
l_string|&quot;mtrr: your CPUs had inconsistent variable MTRR settings&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|MTRR_CHANGE_MASK_DEFTYPE
)paren
id|printk
(paren
l_string|&quot;mtrr: your CPUs had inconsistent MTRRdefType settings&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: probably your BIOS does not setup all CPUs&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_state_warn  */
macro_line|#endif  /*  CONFIG_SMP  */
DECL|function|attrib_to_str
r_static
r_char
op_star
id|attrib_to_str
(paren
r_int
id|x
)paren
(brace
r_return
(paren
id|x
op_le
l_int|6
)paren
ques
c_cond
id|mtrr_strings
(braket
id|x
)braket
suffix:colon
l_string|&quot;?&quot;
suffix:semicolon
)brace
multiline_comment|/*  End Function attrib_to_str  */
DECL|function|init_table
r_static
r_void
id|init_table
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|max
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|usage_table
op_assign
id|kmalloc
(paren
id|max
op_star
r_sizeof
op_star
id|usage_table
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: could not allocate&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
id|i
op_increment
)paren
id|usage_table
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef USERSPACE_INTERFACE
r_if
c_cond
(paren
(paren
id|ascii_buffer
op_assign
id|kmalloc
(paren
id|max
op_star
id|LINE_SIZE
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: could not allocate&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ascii_buf_bytes
op_assign
l_int|0
suffix:semicolon
id|compute_ascii
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*  End Function init_table  */
DECL|function|generic_get_free_region
r_static
r_int
id|generic_get_free_region
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
)paren
multiline_comment|/*  [SUMMARY] Get a free MTRR.&n;    &lt;base&gt; The starting (base) address of the region.&n;    &lt;size&gt; The size (in bytes) of the region.&n;    [RETURNS] The index of the region on success, else -1 on error.&n;*/
(brace
r_int
id|i
comma
id|max
suffix:semicolon
id|mtrr_type
id|ltype
suffix:semicolon
r_int
r_int
id|lbase
comma
id|lsize
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
op_increment
id|i
)paren
(brace
(paren
op_star
id|get_mtrr
)paren
(paren
id|i
comma
op_amp
id|lbase
comma
op_amp
id|lsize
comma
op_amp
id|ltype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lsize
op_eq
l_int|0
)paren
r_return
id|i
suffix:semicolon
)brace
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
multiline_comment|/*  End Function generic_get_free_region  */
DECL|function|cyrix_get_free_region
r_static
r_int
id|cyrix_get_free_region
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
)paren
multiline_comment|/*  [SUMMARY] Get a free ARR.&n;    &lt;base&gt; The starting (base) address of the region.&n;    &lt;size&gt; The size (in bytes) of the region.&n;    [RETURNS] The index of the region on success, else -1 on error.&n;*/
(brace
r_int
id|i
suffix:semicolon
id|mtrr_type
id|ltype
suffix:semicolon
r_int
r_int
id|lbase
comma
id|lsize
suffix:semicolon
multiline_comment|/* If we are to set up a region &gt;32M then look at ARR7 immediately */
r_if
c_cond
(paren
id|size
OG
l_int|0x2000
)paren
(brace
id|cyrix_get_arr
(paren
l_int|7
comma
op_amp
id|lbase
comma
op_amp
id|lsize
comma
op_amp
id|ltype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lsize
op_eq
l_int|0
)paren
r_return
l_int|7
suffix:semicolon
multiline_comment|/*  Else try ARR0-ARR6 first  */
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cyrix_get_arr
(paren
id|i
comma
op_amp
id|lbase
comma
op_amp
id|lsize
comma
op_amp
id|ltype
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_eq
l_int|3
)paren
op_logical_and
id|arr3_protected
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|lsize
op_eq
l_int|0
)paren
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* ARR0-ARR6 isn&squot;t free, try ARR7 but its size must be at least 256K */
id|cyrix_get_arr
(paren
id|i
comma
op_amp
id|lbase
comma
op_amp
id|lsize
comma
op_amp
id|ltype
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lsize
op_eq
l_int|0
)paren
op_logical_and
(paren
id|size
op_ge
l_int|0x40
)paren
)paren
r_return
id|i
suffix:semicolon
)brace
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
multiline_comment|/*  End Function cyrix_get_free_region  */
DECL|variable|get_free_region
r_static
r_int
(paren
op_star
id|get_free_region
)paren
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
)paren
op_assign
id|generic_get_free_region
suffix:semicolon
multiline_comment|/**&n; *&t;mtrr_add_page - Add a memory type region&n; *&t;@base: Physical base address of region in pages (4 KB)&n; *&t;@size: Physical size of region in pages (4 KB)&n; *&t;@type: Type of MTRR desired&n; *&t;@increment: If this is true do usage counting on the region&n; *&n; *&t;Memory type region registers control the caching on newer Intel and&n; *&t;non Intel processors. This function allows drivers to request an&n; *&t;MTRR is added. The details and hardware specifics of each processor&squot;s&n; *&t;implementation are hidden from the caller, but nevertheless the &n; *&t;caller should expect to need to provide a power of two size on an&n; *&t;equivalent power of two boundary.&n; *&n; *&t;If the region cannot be added either because all regions are in use&n; *&t;or the CPU cannot support it a negative value is returned. On success&n; *&t;the register number for this entry is returned, but should be treated&n; *&t;as a cookie only.&n; *&n; *&t;On a multiprocessor machine the changes are made to all processors.&n; *&t;This is required on x86 by the Intel processors.&n; *&n; *&t;The available types are&n; *&n; *&t;%MTRR_TYPE_UNCACHEABLE&t;-&t;No caching&n; *&n; *&t;%MTRR_TYPE_WRITEBACK&t;-&t;Write data back in bursts whenever&n; *&n; *&t;%MTRR_TYPE_WRCOMB&t;-&t;Write data back soon but allow bursts&n; *&n; *&t;%MTRR_TYPE_WRTHROUGH&t;-&t;Cache reads but not writes&n; *&n; *&t;BUGS: Needs a quiet flag for the cases where drivers do not mind&n; *&t;failures and do not wish system log messages to be sent.&n; */
DECL|function|mtrr_add_page
r_int
id|mtrr_add_page
c_func
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
r_int
r_int
id|type
comma
r_char
id|increment
)paren
(brace
multiline_comment|/*  [SUMMARY] Add an MTRR entry.&n;    &lt;base&gt; The starting (base, in pages) address of the region.&n;    &lt;size&gt; The size of the region. (in pages)&n;    &lt;type&gt; The type of the new region.&n;    &lt;increment&gt; If true and the region already exists, the usage count will be&n;    incremented.&n;    [RETURNS] The MTRR register on success, else a negative number indicating&n;    the error code.&n;    [NOTE] This routine uses a spinlock.&n;*/
r_int
id|i
comma
id|max
suffix:semicolon
id|mtrr_type
id|ltype
suffix:semicolon
r_int
r_int
id|lbase
comma
id|lsize
comma
id|last
suffix:semicolon
r_switch
c_cond
(paren
id|mtrr_if
)paren
(brace
r_case
id|MTRR_IF_NONE
suffix:colon
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* No MTRRs whatsoever */
r_case
id|MTRR_IF_AMD_K6
suffix:colon
multiline_comment|/* Apply the K6 block alignment and size rules&n;&t;   In order&n;&t;   o Uncached or gathering only&n;&t;   o 128K or bigger block&n;&t;   o Power of 2 block&n;&t;   o base suitably aligned to the power&n;&t;*/
r_if
c_cond
(paren
id|type
OG
id|MTRR_TYPE_WRCOMB
op_logical_or
id|size
OL
(paren
l_int|1
op_lshift
(paren
l_int|17
op_minus
id|PAGE_SHIFT
)paren
)paren
op_logical_or
(paren
id|size
op_amp
op_complement
(paren
id|size
op_minus
l_int|1
)paren
)paren
op_minus
id|size
op_logical_or
(paren
id|base
op_amp
(paren
id|size
op_minus
l_int|1
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRR_IF_INTEL
suffix:colon
multiline_comment|/*  For Intel PPro stepping &lt;= 7, must be 4 MiB aligned  */
r_if
c_cond
(paren
id|boot_cpu_data.x86_vendor
op_eq
id|X86_VENDOR_INTEL
op_logical_and
id|boot_cpu_data.x86
op_eq
l_int|6
op_logical_and
id|boot_cpu_data.x86_model
op_eq
l_int|1
op_logical_and
id|boot_cpu_data.x86_mask
op_le
l_int|7
)paren
(brace
r_if
c_cond
(paren
id|base
op_amp
(paren
(paren
l_int|1
op_lshift
(paren
l_int|22
op_minus
id|PAGE_SHIFT
)paren
)paren
op_minus
l_int|1
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;mtrr: base(0x%lx000) is not 4 MiB aligned&bslash;n&quot;
comma
id|base
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/* Fall through */
r_case
id|MTRR_IF_CYRIX_ARR
suffix:colon
r_case
id|MTRR_IF_CENTAUR_MCR
suffix:colon
r_if
c_cond
(paren
id|mtrr_if
op_eq
id|MTRR_IF_CENTAUR_MCR
)paren
(brace
r_if
c_cond
(paren
id|type
op_ne
id|MTRR_TYPE_WRCOMB
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;mtrr: only write-combining is supported&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|base
op_plus
id|size
OL
l_int|0x100
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;mtrr: cannot set region below 1 MiB (0x%lx000,0x%lx000)&bslash;n&quot;
comma
id|base
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*  Check upper bits of base and last are equal and lower bits are 0&n;&t;    for base and 1 for last  */
id|last
op_assign
id|base
op_plus
id|size
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|lbase
op_assign
id|base
suffix:semicolon
op_logical_neg
(paren
id|lbase
op_amp
l_int|1
)paren
op_logical_and
(paren
id|last
op_amp
l_int|1
)paren
suffix:semicolon
id|lbase
op_assign
id|lbase
op_rshift
l_int|1
comma
id|last
op_assign
id|last
op_rshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lbase
op_ne
id|last
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;mtrr: base(0x%lx000) is not aligned on a size(0x%lx000) boundary&bslash;n&quot;
comma
id|base
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_ge
id|MTRR_NUM_TYPES
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: type: %u illegal&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*  If the type is WC, check that this processor supports it  */
r_if
c_cond
(paren
(paren
id|type
op_eq
id|MTRR_TYPE_WRCOMB
)paren
op_logical_and
op_logical_neg
id|have_wrcomb
(paren
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;mtrr: your processor doesn&squot;t support write-combining&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|base
op_amp
id|size_or_mask
op_logical_or
id|size
op_amp
id|size_or_mask
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: base or size exceeds the MTRR width&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|increment
op_assign
id|increment
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
multiline_comment|/*  Search for existing MTRR  */
id|down
c_func
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
op_increment
id|i
)paren
(brace
(paren
op_star
id|get_mtrr
)paren
(paren
id|i
comma
op_amp
id|lbase
comma
op_amp
id|lsize
comma
op_amp
id|ltype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_ge
id|lbase
op_plus
id|lsize
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
OL
id|lbase
)paren
op_logical_and
(paren
id|base
op_plus
id|size
op_le
id|lbase
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/*  At this point we know there is some kind of overlap/enclosure  */
r_if
c_cond
(paren
(paren
id|base
OL
id|lbase
)paren
op_logical_or
(paren
id|base
op_plus
id|size
OG
id|lbase
op_plus
id|lsize
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;mtrr: 0x%lx000,0x%lx000 overlaps existing&quot;
l_string|&quot; 0x%lx000,0x%lx000&bslash;n&quot;
comma
id|base
comma
id|size
comma
id|lbase
comma
id|lsize
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*  New region is enclosed by an existing region  */
r_if
c_cond
(paren
id|ltype
op_ne
id|type
)paren
(brace
r_if
c_cond
(paren
id|type
op_eq
id|MTRR_TYPE_UNCACHABLE
)paren
r_continue
suffix:semicolon
id|up
c_func
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: type mismatch for %lx000,%lx000 old: %s new: %s&bslash;n&quot;
comma
id|base
comma
id|size
comma
id|attrib_to_str
(paren
id|ltype
)paren
comma
id|attrib_to_str
(paren
id|type
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|increment
)paren
op_increment
id|usage_table
(braket
id|i
)braket
suffix:semicolon
id|compute_ascii
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*  Search for an empty MTRR  */
id|i
op_assign
(paren
op_star
id|get_free_region
)paren
(paren
id|base
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|up
c_func
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: no more MTRRs available&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
id|set_mtrr
(paren
id|i
comma
id|base
comma
id|size
comma
id|type
)paren
suffix:semicolon
id|usage_table
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
id|compute_ascii
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_add_page  */
multiline_comment|/**&n; *&t;mtrr_add - Add a memory type region&n; *&t;@base: Physical base address of region&n; *&t;@size: Physical size of region&n; *&t;@type: Type of MTRR desired&n; *&t;@increment: If this is true do usage counting on the region&n; *&n; *&t;Memory type region registers control the caching on newer Intel and&n; *&t;non Intel processors. This function allows drivers to request an&n; *&t;MTRR is added. The details and hardware specifics of each processor&squot;s&n; *&t;implementation are hidden from the caller, but nevertheless the &n; *&t;caller should expect to need to provide a power of two size on an&n; *&t;equivalent power of two boundary.&n; *&n; *&t;If the region cannot be added either because all regions are in use&n; *&t;or the CPU cannot support it a negative value is returned. On success&n; *&t;the register number for this entry is returned, but should be treated&n; *&t;as a cookie only.&n; *&n; *&t;On a multiprocessor machine the changes are made to all processors.&n; *&t;This is required on x86 by the Intel processors.&n; *&n; *&t;The available types are&n; *&n; *&t;%MTRR_TYPE_UNCACHEABLE&t;-&t;No caching&n; *&n; *&t;%MTRR_TYPE_WRITEBACK&t;-&t;Write data back in bursts whenever&n; *&n; *&t;%MTRR_TYPE_WRCOMB&t;-&t;Write data back soon but allow bursts&n; *&n; *&t;%MTRR_TYPE_WRTHROUGH&t;-&t;Cache reads but not writes&n; *&n; *&t;BUGS: Needs a quiet flag for the cases where drivers do not mind&n; *&t;failures and do not wish system log messages to be sent.&n; */
DECL|function|mtrr_add
r_int
id|mtrr_add
c_func
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
r_int
r_int
id|type
comma
r_char
id|increment
)paren
(brace
multiline_comment|/*  [SUMMARY] Add an MTRR entry.&n;    &lt;base&gt; The starting (base) address of the region.&n;    &lt;size&gt; The size (in bytes) of the region.&n;    &lt;type&gt; The type of the new region.&n;    &lt;increment&gt; If true and the region already exists, the usage count will be&n;    incremented.&n;    [RETURNS] The MTRR register on success, else a negative number indicating&n;    the error code.&n;*/
r_if
c_cond
(paren
(paren
id|base
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
op_logical_or
(paren
id|size
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: size and base must be multiples of 4 kiB&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: size: 0x%lx  base: 0x%lx&bslash;n&quot;
comma
id|size
comma
id|base
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|mtrr_add_page
c_func
(paren
id|base
op_rshift
id|PAGE_SHIFT
comma
id|size
op_rshift
id|PAGE_SHIFT
comma
id|type
comma
id|increment
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_add  */
multiline_comment|/**&n; *&t;mtrr_del_page - delete a memory type region&n; *&t;@reg: Register returned by mtrr_add&n; *&t;@base: Physical base address&n; *&t;@size: Size of region&n; *&n; *&t;If register is supplied then base and size are ignored. This is&n; *&t;how drivers should call it.&n; *&n; *&t;Releases an MTRR region. If the usage count drops to zero the &n; *&t;register is freed and the region returns to default state.&n; *&t;On success the register is returned, on failure a negative error&n; *&t;code.&n; */
DECL|function|mtrr_del_page
r_int
id|mtrr_del_page
(paren
r_int
id|reg
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
)paren
multiline_comment|/*  [SUMMARY] Delete MTRR/decrement usage count.&n;    &lt;reg&gt; The register. If this is less than 0 then &lt;&lt;base&gt;&gt; and &lt;&lt;size&gt;&gt; must&n;    be supplied.&n;    &lt;base&gt; The base address of the region. This is ignored if &lt;&lt;reg&gt;&gt; is &gt;= 0.&n;    &lt;size&gt; The size of the region. This is ignored if &lt;&lt;reg&gt;&gt; is &gt;= 0.&n;    [RETURNS] The register on success, else a negative number indicating&n;    the error code.&n;    [NOTE] This routine uses a spinlock.&n;*/
(brace
r_int
id|i
comma
id|max
suffix:semicolon
id|mtrr_type
id|ltype
suffix:semicolon
r_int
r_int
id|lbase
comma
id|lsize
suffix:semicolon
r_if
c_cond
(paren
id|mtrr_if
op_eq
id|MTRR_IF_NONE
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
id|down
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
OL
l_int|0
)paren
(brace
multiline_comment|/*  Search for existing MTRR  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
op_increment
id|i
)paren
(brace
(paren
op_star
id|get_mtrr
)paren
(paren
id|i
comma
op_amp
id|lbase
comma
op_amp
id|lsize
comma
op_amp
id|ltype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lbase
op_eq
id|base
op_logical_and
id|lsize
op_eq
id|size
)paren
(brace
id|reg
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|reg
OL
l_int|0
)paren
(brace
id|up
c_func
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: no MTRR for %lx000,%lx000 found&bslash;n&quot;
comma
id|base
comma
id|size
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|reg
op_ge
id|max
)paren
(brace
id|up
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: register: %d too big&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mtrr_if
op_eq
id|MTRR_IF_CYRIX_ARR
)paren
(brace
r_if
c_cond
(paren
(paren
id|reg
op_eq
l_int|3
)paren
op_logical_and
id|arr3_protected
)paren
(brace
id|up
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: ARR3 cannot be changed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
(paren
op_star
id|get_mtrr
)paren
(paren
id|reg
comma
op_amp
id|lbase
comma
op_amp
id|lsize
comma
op_amp
id|ltype
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lsize
OL
l_int|1
)paren
(brace
id|up
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: MTRR %d not used&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usage_table
(braket
id|reg
)braket
OL
l_int|1
)paren
(brace
id|up
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: reg: %d has count=0&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|usage_table
(braket
id|reg
)braket
OL
l_int|1
)paren
id|set_mtrr
(paren
id|reg
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|compute_ascii
(paren
)paren
suffix:semicolon
id|up
(paren
op_amp
id|main_lock
)paren
suffix:semicolon
r_return
id|reg
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_del_page  */
multiline_comment|/**&n; *&t;mtrr_del - delete a memory type region&n; *&t;@reg: Register returned by mtrr_add&n; *&t;@base: Physical base address&n; *&t;@size: Size of region&n; *&n; *&t;If register is supplied then base and size are ignored. This is&n; *&t;how drivers should call it.&n; *&n; *&t;Releases an MTRR region. If the usage count drops to zero the &n; *&t;register is freed and the region returns to default state.&n; *&t;On success the register is returned, on failure a negative error&n; *&t;code.&n; */
DECL|function|mtrr_del
r_int
id|mtrr_del
(paren
r_int
id|reg
comma
r_int
r_int
id|base
comma
r_int
r_int
id|size
)paren
multiline_comment|/*  [SUMMARY] Delete MTRR/decrement usage count.&n;    &lt;reg&gt; The register. If this is less than 0 then &lt;&lt;base&gt;&gt; and &lt;&lt;size&gt;&gt; must&n;    be supplied.&n;    &lt;base&gt; The base address of the region. This is ignored if &lt;&lt;reg&gt;&gt; is &gt;= 0.&n;    &lt;size&gt; The size of the region. This is ignored if &lt;&lt;reg&gt;&gt; is &gt;= 0.&n;    [RETURNS] The register on success, else a negative number indicating&n;    the error code.&n;*/
(brace
r_if
c_cond
(paren
(paren
id|base
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
op_logical_or
(paren
id|size
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: size and base must be multiples of 4 kiB&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: size: 0x%lx  base: 0x%lx&bslash;n&quot;
comma
id|size
comma
id|base
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|mtrr_del_page
c_func
(paren
id|reg
comma
id|base
op_rshift
id|PAGE_SHIFT
comma
id|size
op_rshift
id|PAGE_SHIFT
)paren
suffix:semicolon
)brace
macro_line|#ifdef USERSPACE_INTERFACE
DECL|function|mtrr_file_add
r_static
r_int
id|mtrr_file_add
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
r_int
r_int
id|type
comma
r_char
id|increment
comma
r_struct
id|file
op_star
id|file
comma
r_int
id|page
)paren
(brace
r_int
id|reg
comma
id|max
suffix:semicolon
r_int
r_int
op_star
id|fcount
op_assign
id|file-&gt;private_data
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fcount
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|fcount
op_assign
id|kmalloc
(paren
id|max
op_star
r_sizeof
op_star
id|fcount
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: could not allocate&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
(paren
id|fcount
comma
l_int|0
comma
id|max
op_star
r_sizeof
op_star
id|fcount
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
id|fcount
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_if
c_cond
(paren
(paren
id|base
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
op_logical_or
(paren
id|size
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: size and base must be multiples of 4 kiB&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: size: 0x%lx  base: 0x%lx&bslash;n&quot;
comma
id|size
comma
id|base
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|base
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|size
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
)brace
id|reg
op_assign
id|mtrr_add_page
(paren
id|base
comma
id|size
comma
id|type
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
op_ge
l_int|0
)paren
op_increment
id|fcount
(braket
id|reg
)braket
suffix:semicolon
r_return
id|reg
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_file_add  */
DECL|function|mtrr_file_del
r_static
r_int
id|mtrr_file_del
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|size
comma
r_struct
id|file
op_star
id|file
comma
r_int
id|page
)paren
(brace
r_int
id|reg
suffix:semicolon
r_int
r_int
op_star
id|fcount
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
r_if
c_cond
(paren
(paren
id|base
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
op_logical_or
(paren
id|size
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: size and base must be multiples of 4 kiB&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: size: 0x%lx  base: 0x%lx&bslash;n&quot;
comma
id|size
comma
id|base
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|base
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|size
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
)brace
id|reg
op_assign
id|mtrr_del_page
(paren
op_minus
l_int|1
comma
id|base
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reg
OL
l_int|0
)paren
r_return
id|reg
suffix:semicolon
r_if
c_cond
(paren
id|fcount
op_eq
l_int|NULL
)paren
r_return
id|reg
suffix:semicolon
r_if
c_cond
(paren
id|fcount
(braket
id|reg
)braket
OL
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
op_decrement
id|fcount
(braket
id|reg
)braket
suffix:semicolon
r_return
id|reg
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_file_del  */
DECL|function|mtrr_read
r_static
id|ssize_t
id|mtrr_read
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_if
c_cond
(paren
op_star
id|ppos
op_ge
id|ascii_buf_bytes
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ppos
op_plus
id|len
OG
id|ascii_buf_bytes
)paren
id|len
op_assign
id|ascii_buf_bytes
op_minus
op_star
id|ppos
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
id|buf
comma
id|ascii_buffer
op_plus
op_star
id|ppos
comma
id|len
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
op_star
id|ppos
op_add_assign
id|len
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_read  */
DECL|function|mtrr_write
r_static
id|ssize_t
id|mtrr_write
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|len
comma
id|loff_t
op_star
id|ppos
)paren
multiline_comment|/*  Format of control line:&n;    &quot;base=%Lx size=%Lx type=%s&quot;     OR:&n;    &quot;disable=%d&quot;&n;*/
(brace
r_int
id|i
comma
id|err
suffix:semicolon
r_int
r_int
id|reg
suffix:semicolon
r_int
r_int
r_int
id|base
comma
id|size
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
r_char
id|line
(braket
id|LINE_SIZE
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/*  Can&squot;t seek (pwrite) on this device  */
r_if
c_cond
(paren
id|ppos
op_ne
op_amp
id|file-&gt;f_pos
)paren
r_return
op_minus
id|ESPIPE
suffix:semicolon
id|memset
(paren
id|line
comma
l_int|0
comma
id|LINE_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|LINE_SIZE
)paren
id|len
op_assign
id|LINE_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
id|line
comma
id|buf
comma
id|len
op_minus
l_int|1
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|ptr
op_assign
id|line
op_plus
id|strlen
(paren
id|line
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_star
id|ptr
op_eq
l_char|&squot;&bslash;n&squot;
)paren
op_star
id|ptr
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
(paren
id|line
comma
l_string|&quot;disable=&quot;
comma
l_int|8
)paren
)paren
(brace
id|reg
op_assign
id|simple_strtoul
(paren
id|line
op_plus
l_int|8
comma
op_amp
id|ptr
comma
l_int|0
)paren
suffix:semicolon
id|err
op_assign
id|mtrr_del_page
(paren
id|reg
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
r_if
c_cond
(paren
id|strncmp
(paren
id|line
comma
l_string|&quot;base=&quot;
comma
l_int|5
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: no &bslash;&quot;base=&bslash;&quot; in line: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|base
op_assign
id|simple_strtoull
(paren
id|line
op_plus
l_int|5
comma
op_amp
id|ptr
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|isspace
(paren
op_star
id|ptr
)paren
suffix:semicolon
op_increment
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
(paren
id|ptr
comma
l_string|&quot;size=&quot;
comma
l_int|5
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: no &bslash;&quot;size=&bslash;&quot; in line: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|size
op_assign
id|simple_strtoull
(paren
id|ptr
op_plus
l_int|5
comma
op_amp
id|ptr
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
op_amp
l_int|0xfff
)paren
op_logical_or
(paren
id|size
op_amp
l_int|0xfff
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: size and base must be multiples of 4 kiB&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;mtrr: size: 0x%Lx  base: 0x%Lx&bslash;n&quot;
comma
id|size
comma
id|base
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|isspace
(paren
op_star
id|ptr
)paren
suffix:semicolon
op_increment
id|ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
(paren
id|ptr
comma
l_string|&quot;type=&quot;
comma
l_int|5
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;mtrr: no &bslash;&quot;type=&bslash;&quot; in line: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|ptr
op_add_assign
l_int|5
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|isspace
(paren
op_star
id|ptr
)paren
suffix:semicolon
op_increment
id|ptr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MTRR_NUM_TYPES
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|strcmp
(paren
id|ptr
comma
id|mtrr_strings
(braket
id|i
)braket
)paren
)paren
r_continue
suffix:semicolon
id|base
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|size
op_rshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|err
op_assign
id|mtrr_add_page
(paren
(paren
r_int
r_int
)paren
id|base
comma
(paren
r_int
r_int
)paren
id|size
comma
id|i
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;mtrr: illegal type: &bslash;&quot;%s&bslash;&quot;&bslash;n&quot;
comma
id|ptr
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_write  */
DECL|function|mtrr_ioctl
r_static
r_int
id|mtrr_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
id|mtrr_type
id|type
suffix:semicolon
r_struct
id|mtrr_sentry
id|sentry
suffix:semicolon
r_struct
id|mtrr_gentry
id|gentry
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
r_case
id|MTRRIOC_ADD_ENTRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|sentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|mtrr_file_add
(paren
id|sentry.base
comma
id|sentry.size
comma
id|sentry.type
comma
l_int|1
comma
id|file
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_SET_ENTRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|sentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|mtrr_add
(paren
id|sentry.base
comma
id|sentry.size
comma
id|sentry.type
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_DEL_ENTRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|sentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|mtrr_file_del
(paren
id|sentry.base
comma
id|sentry.size
comma
id|file
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_KILL_ENTRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|sentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|mtrr_del
(paren
op_minus
l_int|1
comma
id|sentry.base
comma
id|sentry.size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_GET_ENTRY
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|gentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|gentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|gentry.regnum
op_ge
id|get_num_var_ranges
(paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
(paren
op_star
id|get_mtrr
)paren
(paren
id|gentry.regnum
comma
op_amp
id|gentry.base
comma
op_amp
id|gentry.size
comma
op_amp
id|type
)paren
suffix:semicolon
multiline_comment|/* Hide entries that go above 4GB */
r_if
c_cond
(paren
id|gentry.base
op_plus
id|gentry.size
OG
l_int|0x100000
op_logical_or
id|gentry.size
op_eq
l_int|0x100000
)paren
id|gentry.base
op_assign
id|gentry.size
op_assign
id|gentry.type
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|gentry.base
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|gentry.size
op_lshift_assign
id|PAGE_SHIFT
suffix:semicolon
id|gentry.type
op_assign
id|type
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|gentry
comma
r_sizeof
id|gentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_ADD_PAGE_ENTRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|sentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|mtrr_file_add
(paren
id|sentry.base
comma
id|sentry.size
comma
id|sentry.type
comma
l_int|1
comma
id|file
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_SET_PAGE_ENTRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|sentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|mtrr_add_page
(paren
id|sentry.base
comma
id|sentry.size
comma
id|sentry.type
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_DEL_PAGE_ENTRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|sentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|mtrr_file_del
(paren
id|sentry.base
comma
id|sentry.size
comma
id|file
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_KILL_PAGE_ENTRY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|sentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|sentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|err
op_assign
id|mtrr_del_page
(paren
op_minus
l_int|1
comma
id|sentry.base
comma
id|sentry.size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRRIOC_GET_PAGE_ENTRY
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|gentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|gentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|gentry.regnum
op_ge
id|get_num_var_ranges
(paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
(paren
op_star
id|get_mtrr
)paren
(paren
id|gentry.regnum
comma
op_amp
id|gentry.base
comma
op_amp
id|gentry.size
comma
op_amp
id|type
)paren
suffix:semicolon
id|gentry.type
op_assign
id|type
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|gentry
comma
r_sizeof
id|gentry
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_ioctl  */
DECL|function|mtrr_close
r_static
r_int
id|mtrr_close
(paren
r_struct
id|inode
op_star
id|ino
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|i
comma
id|max
suffix:semicolon
r_int
r_int
op_star
id|fcount
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|fcount
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
op_increment
id|i
)paren
(brace
r_while
c_loop
(paren
id|fcount
(braket
id|i
)braket
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|mtrr_del
(paren
id|i
comma
l_int|0
comma
l_int|0
)paren
OL
l_int|0
)paren
id|printk
(paren
l_string|&quot;mtrr: reg %d not used&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
op_decrement
id|fcount
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
id|kfree
(paren
id|fcount
)paren
suffix:semicolon
id|file-&gt;private_data
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_close  */
DECL|variable|mtrr_fops
r_static
r_struct
id|file_operations
id|mtrr_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|read
suffix:colon
id|mtrr_read
comma
id|write
suffix:colon
id|mtrr_write
comma
id|ioctl
suffix:colon
id|mtrr_ioctl
comma
id|release
suffix:colon
id|mtrr_close
comma
)brace
suffix:semicolon
macro_line|#  ifdef CONFIG_PROC_FS
DECL|variable|proc_root_mtrr
r_static
r_struct
id|proc_dir_entry
op_star
id|proc_root_mtrr
suffix:semicolon
macro_line|#  endif  /*  CONFIG_PROC_FS  */
DECL|variable|devfs_handle
r_static
id|devfs_handle_t
id|devfs_handle
suffix:semicolon
DECL|function|compute_ascii
r_static
r_void
id|compute_ascii
(paren
r_void
)paren
(brace
r_char
id|factor
suffix:semicolon
r_int
id|i
comma
id|max
suffix:semicolon
id|mtrr_type
id|type
suffix:semicolon
r_int
r_int
id|base
comma
id|size
suffix:semicolon
id|ascii_buf_bytes
op_assign
l_int|0
suffix:semicolon
id|max
op_assign
id|get_num_var_ranges
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|max
suffix:semicolon
id|i
op_increment
)paren
(brace
(paren
op_star
id|get_mtrr
)paren
(paren
id|i
comma
op_amp
id|base
comma
op_amp
id|size
comma
op_amp
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
id|usage_table
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|size
OL
(paren
l_int|0x100000
op_rshift
id|PAGE_SHIFT
)paren
)paren
(brace
multiline_comment|/* less than 1MB */
id|factor
op_assign
l_char|&squot;K&squot;
suffix:semicolon
id|size
op_lshift_assign
id|PAGE_SHIFT
op_minus
l_int|10
suffix:semicolon
)brace
r_else
(brace
id|factor
op_assign
l_char|&squot;M&squot;
suffix:semicolon
id|size
op_rshift_assign
l_int|20
op_minus
id|PAGE_SHIFT
suffix:semicolon
)brace
id|sprintf
(paren
id|ascii_buffer
op_plus
id|ascii_buf_bytes
comma
l_string|&quot;reg%02i: base=0x%05lx000 (%4liMB), size=%4li%cB: %s, count=%d&bslash;n&quot;
comma
id|i
comma
id|base
comma
id|base
op_rshift
(paren
l_int|20
op_minus
id|PAGE_SHIFT
)paren
comma
id|size
comma
id|factor
comma
id|attrib_to_str
(paren
id|type
)paren
comma
id|usage_table
(braket
id|i
)braket
)paren
suffix:semicolon
id|ascii_buf_bytes
op_add_assign
id|strlen
(paren
id|ascii_buffer
op_plus
id|ascii_buf_bytes
)paren
suffix:semicolon
)brace
)brace
id|devfs_set_file_size
(paren
id|devfs_handle
comma
id|ascii_buf_bytes
)paren
suffix:semicolon
macro_line|#  ifdef CONFIG_PROC_FS
id|proc_root_mtrr-&gt;size
op_assign
id|ascii_buf_bytes
suffix:semicolon
macro_line|#  endif  /*  CONFIG_PROC_FS  */
)brace
multiline_comment|/*  End Function compute_ascii  */
macro_line|#endif  /*  USERSPACE_INTERFACE  */
DECL|variable|mtrr_add
id|EXPORT_SYMBOL
c_func
(paren
id|mtrr_add
)paren
suffix:semicolon
DECL|variable|mtrr_del
id|EXPORT_SYMBOL
c_func
(paren
id|mtrr_del
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_typedef
r_struct
(brace
DECL|member|base
r_int
r_int
id|base
suffix:semicolon
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
DECL|member|type
id|mtrr_type
id|type
suffix:semicolon
DECL|typedef|arr_state_t
)brace
id|arr_state_t
suffix:semicolon
DECL|variable|__initdata
id|arr_state_t
id|arr_state
(braket
l_int|8
)braket
id|__initdata
op_assign
(brace
(brace
l_int|0UL
comma
l_int|0UL
comma
l_int|0UL
)brace
comma
(brace
l_int|0UL
comma
l_int|0UL
comma
l_int|0UL
)brace
comma
(brace
l_int|0UL
comma
l_int|0UL
comma
l_int|0UL
)brace
comma
(brace
l_int|0UL
comma
l_int|0UL
comma
l_int|0UL
)brace
comma
(brace
l_int|0UL
comma
l_int|0UL
comma
l_int|0UL
)brace
comma
(brace
l_int|0UL
comma
l_int|0UL
comma
l_int|0UL
)brace
comma
(brace
l_int|0UL
comma
l_int|0UL
comma
l_int|0UL
)brace
comma
(brace
l_int|0UL
comma
l_int|0UL
comma
l_int|0UL
)brace
)brace
suffix:semicolon
DECL|variable|__initdata
r_int
r_char
id|ccr_state
(braket
l_int|7
)braket
id|__initdata
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|function|cyrix_arr_init_secondary
r_static
r_void
id|__init
id|cyrix_arr_init_secondary
c_func
(paren
r_void
)paren
(brace
r_struct
id|set_mtrr_context
id|ctxt
suffix:semicolon
r_int
id|i
suffix:semicolon
id|set_mtrr_prepare
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
multiline_comment|/* flush cache and enable MAPEN */
multiline_comment|/* the CCRs are not contiguous */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|setCx86
c_func
(paren
id|CX86_CCR0
op_plus
id|i
comma
id|ccr_state
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
id|setCx86
c_func
(paren
id|CX86_CCR4
op_plus
id|i
comma
id|ccr_state
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cyrix_set_arr_up
c_func
(paren
id|i
comma
id|arr_state
(braket
id|i
)braket
dot
id|base
comma
id|arr_state
(braket
id|i
)braket
dot
id|size
comma
id|arr_state
(braket
id|i
)braket
dot
id|type
comma
id|FALSE
)paren
suffix:semicolon
)brace
id|set_mtrr_done
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
multiline_comment|/* flush cache and disable MAPEN */
)brace
multiline_comment|/*  End Function cyrix_arr_init_secondary  */
macro_line|#endif
multiline_comment|/*&n; * On Cyrix 6x86(MX) and M II the ARR3 is special: it has connection&n; * with the SMM (System Management Mode) mode. So we need the following:&n; * Check whether SMI_LOCK (CCR3 bit 0) is set&n; *   if it is set, write a warning message: ARR3 cannot be changed!&n; *     (it cannot be changed until the next processor reset)&n; *   if it is reset, then we can change it, set all the needed bits:&n; *   - disable access to SMM memory through ARR3 range (CCR1 bit 7 reset)&n; *   - disable access to SMM memory (CCR1 bit 2 reset)&n; *   - disable SMM mode (CCR1 bit 1 reset)&n; *   - disable write protection of ARR3 (CCR6 bit 1 reset)&n; *   - (maybe) disable ARR3&n; * Just to be sure, we enable ARR usage by the processor (CCR5 bit 5 set)&n; */
DECL|function|cyrix_arr_init
r_static
r_void
id|__init
id|cyrix_arr_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|set_mtrr_context
id|ctxt
suffix:semicolon
r_int
r_char
id|ccr
(braket
l_int|7
)braket
suffix:semicolon
r_int
id|ccrc
(braket
l_int|7
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_int
id|i
suffix:semicolon
macro_line|#endif
id|set_mtrr_prepare
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
multiline_comment|/* flush cache and enable MAPEN */
multiline_comment|/* Save all CCRs locally */
id|ccr
(braket
l_int|0
)braket
op_assign
id|getCx86
(paren
id|CX86_CCR0
)paren
suffix:semicolon
id|ccr
(braket
l_int|1
)braket
op_assign
id|getCx86
(paren
id|CX86_CCR1
)paren
suffix:semicolon
id|ccr
(braket
l_int|2
)braket
op_assign
id|getCx86
(paren
id|CX86_CCR2
)paren
suffix:semicolon
id|ccr
(braket
l_int|3
)braket
op_assign
id|ctxt.ccr3
suffix:semicolon
id|ccr
(braket
l_int|4
)braket
op_assign
id|getCx86
(paren
id|CX86_CCR4
)paren
suffix:semicolon
id|ccr
(braket
l_int|5
)braket
op_assign
id|getCx86
(paren
id|CX86_CCR5
)paren
suffix:semicolon
id|ccr
(braket
l_int|6
)braket
op_assign
id|getCx86
(paren
id|CX86_CCR6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccr
(braket
l_int|3
)braket
op_amp
l_int|1
)paren
(brace
id|ccrc
(braket
l_int|3
)braket
op_assign
l_int|1
suffix:semicolon
id|arr3_protected
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Disable SMM mode (bit 1), access to SMM memory (bit 2) and&n;&t; * access to SMM memory through ARR3 (bit 7).&n;&t; */
r_if
c_cond
(paren
id|ccr
(braket
l_int|1
)braket
op_amp
l_int|0x80
)paren
(brace
id|ccr
(braket
l_int|1
)braket
op_and_assign
l_int|0x7f
suffix:semicolon
id|ccrc
(braket
l_int|1
)braket
op_or_assign
l_int|0x80
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ccr
(braket
l_int|1
)braket
op_amp
l_int|0x04
)paren
(brace
id|ccr
(braket
l_int|1
)braket
op_and_assign
l_int|0xfb
suffix:semicolon
id|ccrc
(braket
l_int|1
)braket
op_or_assign
l_int|0x04
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ccr
(braket
l_int|1
)braket
op_amp
l_int|0x02
)paren
(brace
id|ccr
(braket
l_int|1
)braket
op_and_assign
l_int|0xfd
suffix:semicolon
id|ccrc
(braket
l_int|1
)braket
op_or_assign
l_int|0x02
suffix:semicolon
)brace
id|arr3_protected
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ccr
(braket
l_int|6
)braket
op_amp
l_int|0x02
)paren
(brace
id|ccr
(braket
l_int|6
)braket
op_and_assign
l_int|0xfd
suffix:semicolon
id|ccrc
(braket
l_int|6
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Disable write protection of ARR3 */
id|setCx86
(paren
id|CX86_CCR6
comma
id|ccr
(braket
l_int|6
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Disable ARR3. This is safe now that we disabled SMM. */
multiline_comment|/* cyrix_set_arr_up (3, 0, 0, 0, FALSE); */
)brace
multiline_comment|/* If we changed CCR1 in memory, change it in the processor, too. */
r_if
c_cond
(paren
id|ccrc
(braket
l_int|1
)braket
)paren
id|setCx86
(paren
id|CX86_CCR1
comma
id|ccr
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* Enable ARR usage by the processor */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ccr
(braket
l_int|5
)braket
op_amp
l_int|0x20
)paren
)paren
(brace
id|ccr
(braket
l_int|5
)braket
op_or_assign
l_int|0x20
suffix:semicolon
id|ccrc
(braket
l_int|5
)braket
op_assign
l_int|1
suffix:semicolon
id|setCx86
(paren
id|CX86_CCR5
comma
id|ccr
(braket
l_int|5
)braket
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SMP
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ccr_state
(braket
id|i
)braket
op_assign
id|ccr
(braket
id|i
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cyrix_get_arr
c_func
(paren
id|i
comma
op_amp
id|arr_state
(braket
id|i
)braket
dot
id|base
comma
op_amp
id|arr_state
(braket
id|i
)braket
dot
id|size
comma
op_amp
id|arr_state
(braket
id|i
)braket
dot
id|type
)paren
suffix:semicolon
)brace
macro_line|#endif
id|set_mtrr_done
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
multiline_comment|/* flush cache and disable MAPEN */
r_if
c_cond
(paren
id|ccrc
(braket
l_int|5
)braket
)paren
id|printk
(paren
l_string|&quot;mtrr: ARR usage was not enabled, enabled manually&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccrc
(braket
l_int|3
)braket
)paren
id|printk
(paren
l_string|&quot;mtrr: ARR3 cannot be changed&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;    if ( ccrc[1] &amp; 0x80) printk (&quot;mtrr: SMM memory access through ARR3 disabled&bslash;n&quot;);&n;    if ( ccrc[1] &amp; 0x04) printk (&quot;mtrr: SMM memory access disabled&bslash;n&quot;);&n;    if ( ccrc[1] &amp; 0x02) printk (&quot;mtrr: SMM mode disabled&bslash;n&quot;);&n;*/
r_if
c_cond
(paren
id|ccrc
(braket
l_int|6
)braket
)paren
id|printk
(paren
l_string|&quot;mtrr: ARR3 was write protected, unprotected&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function cyrix_arr_init  */
DECL|function|centaur_mcr_init
r_static
r_void
id|__init
id|centaur_mcr_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|set_mtrr_context
id|ctxt
suffix:semicolon
id|set_mtrr_prepare
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
multiline_comment|/* Unfortunately, MCR&squot;s are read-only, so there is no way to&n;     * find out what the bios might have done.&n;     */
multiline_comment|/* Clear all MCR&squot;s.&n;     * This way we are sure that the centaur_mcr array contains the actual&n;     * values. The disadvantage is that any BIOS tweaks are thus undone.&n;     */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
(brace
id|centaur_mcr
(braket
id|i
)braket
dot
id|high
op_assign
l_int|0
suffix:semicolon
id|centaur_mcr
(braket
id|i
)braket
dot
id|low
op_assign
l_int|0
suffix:semicolon
id|wrmsr
(paren
l_int|0x110
op_plus
id|i
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*  Throw the main write-combining switch...  */
id|wrmsr
(paren
l_int|0x120
comma
l_int|0x01f0001f
comma
l_int|0
)paren
suffix:semicolon
id|set_mtrr_done
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function centaur_mcr_init  */
DECL|function|mtrr_setup
r_static
r_int
id|__init
id|mtrr_setup
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|X86_FEATURE_MTRR
comma
op_amp
id|boot_cpu_data.x86_capability
)paren
)paren
(brace
multiline_comment|/* Intel (P6) standard MTRRs */
id|mtrr_if
op_assign
id|MTRR_IF_INTEL
suffix:semicolon
id|get_mtrr
op_assign
id|intel_get_mtrr
suffix:semicolon
id|set_mtrr_up
op_assign
id|intel_set_mtrr_up
suffix:semicolon
r_switch
c_cond
(paren
id|boot_cpu_data.x86_vendor
)paren
(brace
r_case
id|X86_VENDOR_AMD
suffix:colon
multiline_comment|/* The original Athlon docs said that&n;&t;&t;   total addressable memory is 44 bits wide.&n;&t;&t;   It was not really clear whether its MTRRs&n;&t;&t;   follow this or not. (Read: 44 or 36 bits).&n;&t;&t;   However, &quot;x86-64_overview.pdf&quot; explicitly&n;&t;&t;   states that &quot;previous implementations support&n;&t;&t;   36 bit MTRRs&quot; and also provides a way to&n;&t;&t;   query the width (in bits) of the physical&n;&t;&t;   addressable memory on the Hammer family.&n;&t;&t; */
r_if
c_cond
(paren
id|boot_cpu_data.x86
op_eq
l_int|7
op_logical_and
(paren
id|cpuid_eax
c_func
(paren
l_int|0x80000000
)paren
op_ge
l_int|0x80000008
)paren
)paren
(brace
id|u32
id|phys_addr
suffix:semicolon
id|phys_addr
op_assign
id|cpuid_eax
c_func
(paren
l_int|0x80000008
)paren
op_amp
l_int|0xff
suffix:semicolon
id|size_or_mask
op_assign
op_complement
(paren
(paren
l_int|1
op_lshift
(paren
id|phys_addr
op_minus
id|PAGE_SHIFT
)paren
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|size_and_mask
op_assign
op_complement
id|size_or_mask
op_amp
l_int|0xfff00000
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
multiline_comment|/* Intel, etc. */
id|size_or_mask
op_assign
l_int|0xff000000
suffix:semicolon
multiline_comment|/* 36 bits */
id|size_and_mask
op_assign
l_int|0x00f00000
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|X86_FEATURE_K6_MTRR
comma
op_amp
id|boot_cpu_data.x86_capability
)paren
)paren
(brace
multiline_comment|/* Pre-Athlon (K6) AMD CPU MTRRs */
id|mtrr_if
op_assign
id|MTRR_IF_AMD_K6
suffix:semicolon
id|get_mtrr
op_assign
id|amd_get_mtrr
suffix:semicolon
id|set_mtrr_up
op_assign
id|amd_set_mtrr_up
suffix:semicolon
id|size_or_mask
op_assign
l_int|0xfff00000
suffix:semicolon
multiline_comment|/* 32 bits */
id|size_and_mask
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|X86_FEATURE_CYRIX_ARR
comma
op_amp
id|boot_cpu_data.x86_capability
)paren
)paren
(brace
multiline_comment|/* Cyrix ARRs */
id|mtrr_if
op_assign
id|MTRR_IF_CYRIX_ARR
suffix:semicolon
id|get_mtrr
op_assign
id|cyrix_get_arr
suffix:semicolon
id|set_mtrr_up
op_assign
id|cyrix_set_arr_up
suffix:semicolon
id|get_free_region
op_assign
id|cyrix_get_free_region
suffix:semicolon
id|cyrix_arr_init
c_func
(paren
)paren
suffix:semicolon
id|size_or_mask
op_assign
l_int|0xfff00000
suffix:semicolon
multiline_comment|/* 32 bits */
id|size_and_mask
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|X86_FEATURE_CENTAUR_MCR
comma
op_amp
id|boot_cpu_data.x86_capability
)paren
)paren
(brace
multiline_comment|/* Centaur MCRs */
id|mtrr_if
op_assign
id|MTRR_IF_CENTAUR_MCR
suffix:semicolon
id|get_mtrr
op_assign
id|centaur_get_mcr
suffix:semicolon
id|set_mtrr_up
op_assign
id|centaur_set_mcr_up
suffix:semicolon
id|centaur_mcr_init
c_func
(paren
)paren
suffix:semicolon
id|size_or_mask
op_assign
l_int|0xfff00000
suffix:semicolon
multiline_comment|/* 32 bits */
id|size_and_mask
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No supported MTRR interface */
id|mtrr_if
op_assign
id|MTRR_IF_NONE
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;mtrr: v%s Richard Gooch (rgooch@atnf.csiro.au)&bslash;n&quot;
l_string|&quot;mtrr: detected mtrr type: %s&bslash;n&quot;
comma
id|MTRR_VERSION
comma
id|mtrr_if_name
(braket
id|mtrr_if
)braket
)paren
suffix:semicolon
r_return
(paren
id|mtrr_if
op_ne
id|MTRR_IF_NONE
)paren
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_setup  */
macro_line|#ifdef CONFIG_SMP
DECL|variable|__initdata
r_static
r_volatile
r_int
r_int
id|smp_changes_mask
id|__initdata
op_assign
l_int|0
suffix:semicolon
DECL|variable|__initdata
r_static
r_struct
id|mtrr_state
id|smp_mtrr_state
id|__initdata
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|function|mtrr_init_boot_cpu
r_void
id|__init
id|mtrr_init_boot_cpu
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mtrr_setup
(paren
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|mtrr_if
op_eq
id|MTRR_IF_INTEL
)paren
(brace
multiline_comment|/* Only for Intel MTRRs */
id|get_mtrr_state
(paren
op_amp
id|smp_mtrr_state
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*  End Function mtrr_init_boot_cpu  */
DECL|function|intel_mtrr_init_secondary_cpu
r_static
r_void
id|__init
id|intel_mtrr_init_secondary_cpu
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|mask
comma
id|count
suffix:semicolon
r_struct
id|set_mtrr_context
id|ctxt
suffix:semicolon
multiline_comment|/*  Note that this is not ideal, since the cache is only flushed/disabled&n;&t;for this CPU while the MTRRs are changed, but changing this requires&n;&t;more invasive changes to the way the kernel boots  */
id|set_mtrr_prepare
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
id|mask
op_assign
id|set_mtrr_state
(paren
op_amp
id|smp_mtrr_state
comma
op_amp
id|ctxt
)paren
suffix:semicolon
id|set_mtrr_done
(paren
op_amp
id|ctxt
)paren
suffix:semicolon
multiline_comment|/*  Use the atomic bitops to update the global mask  */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
r_sizeof
id|mask
op_star
l_int|8
suffix:semicolon
op_increment
id|count
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|0x01
)paren
id|set_bit
(paren
id|count
comma
op_amp
id|smp_changes_mask
)paren
suffix:semicolon
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*  End Function intel_mtrr_init_secondary_cpu  */
DECL|function|mtrr_init_secondary_cpu
r_void
id|__init
id|mtrr_init_secondary_cpu
c_func
(paren
r_void
)paren
(brace
r_switch
c_cond
(paren
id|mtrr_if
)paren
(brace
r_case
id|MTRR_IF_INTEL
suffix:colon
multiline_comment|/* Intel (P6) standard MTRRs */
id|intel_mtrr_init_secondary_cpu
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MTRR_IF_CYRIX_ARR
suffix:colon
multiline_comment|/* This is _completely theoretical_!&n;&t; * I assume here that one day Cyrix will support Intel APIC.&n;&t; * In reality on non-Intel CPUs we won&squot;t even get to this routine.&n;&t; * Hopefully no one will plug two Cyrix processors in a dual P5 board.&n;&t; *  :-)&n;&t; */
id|cyrix_arr_init_secondary
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* I see no MTRRs I can support in SMP mode... */
id|printk
(paren
l_string|&quot;mtrr: SMP support incomplete for this vendor&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*  End Function mtrr_init_secondary_cpu  */
macro_line|#endif  /*  CONFIG_SMP  */
DECL|function|mtrr_init
r_int
id|__init
id|mtrr_init
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_SMP
multiline_comment|/* mtrr_setup() should already have been called from mtrr_init_boot_cpu() */
r_if
c_cond
(paren
id|mtrr_if
op_eq
id|MTRR_IF_INTEL
)paren
(brace
id|finalize_mtrr_state
(paren
op_amp
id|smp_mtrr_state
)paren
suffix:semicolon
id|mtrr_state_warn
(paren
id|smp_changes_mask
)paren
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
id|mtrr_setup
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* MTRRs not supported? */
macro_line|#endif
macro_line|#ifdef CONFIG_PROC_FS
id|proc_root_mtrr
op_assign
id|create_proc_entry
(paren
l_string|&quot;mtrr&quot;
comma
id|S_IWUSR
op_or
id|S_IRUGO
comma
op_amp
id|proc_root
)paren
suffix:semicolon
id|proc_root_mtrr-&gt;owner
op_assign
id|THIS_MODULE
suffix:semicolon
id|proc_root_mtrr-&gt;proc_fops
op_assign
op_amp
id|mtrr_fops
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_DEVFS_FS
id|devfs_handle
op_assign
id|devfs_register
(paren
l_int|NULL
comma
l_string|&quot;cpu/mtrr&quot;
comma
id|DEVFS_FL_DEFAULT
comma
l_int|0
comma
l_int|0
comma
id|S_IFREG
op_or
id|S_IRUGO
op_or
id|S_IWUSR
comma
op_amp
id|mtrr_fops
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
id|init_table
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  End Function mtrr_init  */
multiline_comment|/*&n; * Local Variables:&n; * mode:c&n; * c-file-style:&quot;k&amp;r&quot;&n; * c-basic-offset:4&n; * End:&n; */
eof
