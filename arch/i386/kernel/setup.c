multiline_comment|/*&n; *  linux/arch/i386/kernel/setup.c&n; *&n; *  Copyright (C) 1995  Linus Torvalds&n; *&n; *  Enhanced CPU detection and feature setting code by Mike Jagdis&n; *  and Martin Mares, November 1997, and partially recoded and moved&n; *  form head.S by Willy Tarreau, July 1998.&n; */
multiline_comment|/*&n; * This file handles the architecture-dependent parts of initialization&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/user.h&gt;
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#ifdef CONFIG_APM
macro_line|#include &lt;linux/apm_bios.h&gt;
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_RAM
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
multiline_comment|/*&n; * Machine setup..&n; */
DECL|variable|ignore_irq13
r_char
id|ignore_irq13
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set if exception 16 works */
DECL|variable|boot_cpu_data
r_struct
id|cpuinfo_x86
id|boot_cpu_data
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
)brace
suffix:semicolon
multiline_comment|/*&n; * Bus types ..&n; */
DECL|variable|EISA_bus
r_int
id|EISA_bus
op_assign
l_int|0
suffix:semicolon
DECL|variable|MCA_bus
r_int
id|MCA_bus
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* for MCA, but anyone else can use it if they want */
DECL|variable|machine_id
r_int
r_int
id|machine_id
op_assign
l_int|0
suffix:semicolon
DECL|variable|machine_submodel_id
r_int
r_int
id|machine_submodel_id
op_assign
l_int|0
suffix:semicolon
DECL|variable|BIOS_revision
r_int
r_int
id|BIOS_revision
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Setup options&n; */
DECL|struct|drive_info_struct
DECL|member|dummy
DECL|variable|drive_info
r_struct
id|drive_info_struct
(brace
r_char
id|dummy
(braket
l_int|32
)braket
suffix:semicolon
)brace
id|drive_info
suffix:semicolon
DECL|variable|screen_info
r_struct
id|screen_info
id|screen_info
suffix:semicolon
macro_line|#ifdef CONFIG_APM
DECL|variable|apm_bios_info
r_struct
id|apm_bios_info
id|apm_bios_info
suffix:semicolon
macro_line|#endif
DECL|struct|sys_desc_table_struct
r_struct
id|sys_desc_table_struct
(brace
DECL|member|length
r_int
r_int
id|length
suffix:semicolon
DECL|member|table
r_int
r_char
id|table
(braket
l_int|0
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|aux_device_present
r_int
r_char
id|aux_device_present
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_RAM
r_extern
r_int
id|rd_doload
suffix:semicolon
multiline_comment|/* 1 = load ramdisk, 0 = don&squot;t load */
r_extern
r_int
id|rd_prompt
suffix:semicolon
multiline_comment|/* 1 = prompt for ramdisk, 0 = don&squot;t prompt */
r_extern
r_int
id|rd_image_start
suffix:semicolon
multiline_comment|/* starting block # of image */
macro_line|#endif
r_extern
r_int
id|root_mountflags
suffix:semicolon
r_extern
r_int
id|_etext
comma
id|_edata
comma
id|_end
suffix:semicolon
r_extern
r_char
id|empty_zero_page
(braket
id|PAGE_SIZE
)braket
suffix:semicolon
multiline_comment|/*&n; * This is set up by the setup-routine at boot-time&n; */
DECL|macro|PARAM
mdefine_line|#define PARAM&t;empty_zero_page
DECL|macro|EXT_MEM_K
mdefine_line|#define EXT_MEM_K (*(unsigned short *) (PARAM+2))
DECL|macro|ALT_MEM_K
mdefine_line|#define ALT_MEM_K (*(unsigned long *) (PARAM+0x1e0))
macro_line|#ifdef CONFIG_APM
DECL|macro|APM_BIOS_INFO
mdefine_line|#define APM_BIOS_INFO (*(struct apm_bios_info *) (PARAM+64))
macro_line|#endif
DECL|macro|DRIVE_INFO
mdefine_line|#define DRIVE_INFO (*(struct drive_info_struct *) (PARAM+0x80))
DECL|macro|SCREEN_INFO
mdefine_line|#define SCREEN_INFO (*(struct screen_info *) (PARAM+0))
DECL|macro|MOUNT_ROOT_RDONLY
mdefine_line|#define MOUNT_ROOT_RDONLY (*(unsigned short *) (PARAM+0x1F2))
DECL|macro|RAMDISK_FLAGS
mdefine_line|#define RAMDISK_FLAGS (*(unsigned short *) (PARAM+0x1F8))
DECL|macro|ORIG_ROOT_DEV
mdefine_line|#define ORIG_ROOT_DEV (*(unsigned short *) (PARAM+0x1FC))
DECL|macro|AUX_DEVICE_INFO
mdefine_line|#define AUX_DEVICE_INFO (*(unsigned char *) (PARAM+0x1FF))
DECL|macro|LOADER_TYPE
mdefine_line|#define LOADER_TYPE (*(unsigned char *) (PARAM+0x210))
DECL|macro|KERNEL_START
mdefine_line|#define KERNEL_START (*(unsigned long *) (PARAM+0x214))
DECL|macro|INITRD_START
mdefine_line|#define INITRD_START (*(unsigned long *) (PARAM+0x218))
DECL|macro|INITRD_SIZE
mdefine_line|#define INITRD_SIZE (*(unsigned long *) (PARAM+0x21c))
DECL|macro|SYS_DESC_TABLE
mdefine_line|#define SYS_DESC_TABLE (*(struct sys_desc_table_struct*)(PARAM+0x220))
DECL|macro|COMMAND_LINE
mdefine_line|#define COMMAND_LINE ((char *) (PARAM+2048))
DECL|macro|COMMAND_LINE_SIZE
mdefine_line|#define COMMAND_LINE_SIZE 256
DECL|macro|RAMDISK_IMAGE_START_MASK
mdefine_line|#define RAMDISK_IMAGE_START_MASK  &t;0x07FF
DECL|macro|RAMDISK_PROMPT_FLAG
mdefine_line|#define RAMDISK_PROMPT_FLAG&t;&t;0x8000
DECL|macro|RAMDISK_LOAD_FLAG
mdefine_line|#define RAMDISK_LOAD_FLAG&t;&t;0x4000&t;
DECL|variable|command_line
r_static
r_char
id|command_line
(braket
id|COMMAND_LINE_SIZE
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|saved_command_line
r_char
id|saved_command_line
(braket
id|COMMAND_LINE_SIZE
)braket
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|setup_arch
c_func
(paren
r_char
op_star
op_star
id|cmdline_p
comma
r_int
r_int
op_star
id|memory_start_p
comma
r_int
r_int
op_star
id|memory_end_p
)paren
)paren
(brace
r_int
r_int
id|memory_start
comma
id|memory_end
suffix:semicolon
r_char
id|c
op_assign
l_char|&squot; &squot;
comma
op_star
id|to
op_assign
id|command_line
comma
op_star
id|from
op_assign
id|COMMAND_LINE
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_static
r_int
r_char
id|smptrap
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|smptrap
)paren
r_return
suffix:semicolon
id|smptrap
op_assign
l_int|1
suffix:semicolon
id|ROOT_DEV
op_assign
id|to_kdev_t
c_func
(paren
id|ORIG_ROOT_DEV
)paren
suffix:semicolon
id|drive_info
op_assign
id|DRIVE_INFO
suffix:semicolon
id|screen_info
op_assign
id|SCREEN_INFO
suffix:semicolon
macro_line|#ifdef CONFIG_APM
id|apm_bios_info
op_assign
id|APM_BIOS_INFO
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|SYS_DESC_TABLE.length
op_ne
l_int|0
)paren
(brace
id|MCA_bus
op_assign
id|SYS_DESC_TABLE.table
(braket
l_int|3
)braket
op_amp
l_int|0x2
suffix:semicolon
id|machine_id
op_assign
id|SYS_DESC_TABLE.table
(braket
l_int|0
)braket
suffix:semicolon
id|machine_submodel_id
op_assign
id|SYS_DESC_TABLE.table
(braket
l_int|1
)braket
suffix:semicolon
id|BIOS_revision
op_assign
id|SYS_DESC_TABLE.table
(braket
l_int|2
)braket
suffix:semicolon
)brace
id|aux_device_present
op_assign
id|AUX_DEVICE_INFO
suffix:semicolon
id|memory_end
op_assign
(paren
l_int|1
op_lshift
l_int|20
)paren
op_plus
(paren
id|EXT_MEM_K
op_lshift
l_int|10
)paren
suffix:semicolon
macro_line|#ifndef STANDARD_MEMORY_BIOS_CALL
(brace
r_int
r_int
id|memory_alt_end
op_assign
(paren
l_int|1
op_lshift
l_int|20
)paren
op_plus
(paren
id|ALT_MEM_K
op_lshift
l_int|10
)paren
suffix:semicolon
multiline_comment|/* printk(KERN_DEBUG &quot;Memory sizing: %08x %08x&bslash;n&quot;, memory_end, memory_alt_end); */
r_if
c_cond
(paren
id|memory_alt_end
OG
id|memory_end
)paren
id|memory_end
op_assign
id|memory_alt_end
suffix:semicolon
)brace
macro_line|#endif
id|memory_end
op_and_assign
id|PAGE_MASK
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_RAM
id|rd_image_start
op_assign
id|RAMDISK_FLAGS
op_amp
id|RAMDISK_IMAGE_START_MASK
suffix:semicolon
id|rd_prompt
op_assign
(paren
(paren
id|RAMDISK_FLAGS
op_amp
id|RAMDISK_PROMPT_FLAG
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|rd_doload
op_assign
(paren
(paren
id|RAMDISK_FLAGS
op_amp
id|RAMDISK_LOAD_FLAG
)paren
op_ne
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|MOUNT_ROOT_RDONLY
)paren
id|root_mountflags
op_and_assign
op_complement
id|MS_RDONLY
suffix:semicolon
id|memory_start
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_end
suffix:semicolon
id|init_task.mm-&gt;start_code
op_assign
id|PAGE_OFFSET
suffix:semicolon
id|init_task.mm-&gt;end_code
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_etext
suffix:semicolon
id|init_task.mm-&gt;end_data
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_edata
suffix:semicolon
id|init_task.mm-&gt;brk
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_end
suffix:semicolon
multiline_comment|/* Save unparsed command line copy for /proc/cmdline */
id|memcpy
c_func
(paren
id|saved_command_line
comma
id|COMMAND_LINE
comma
id|COMMAND_LINE_SIZE
)paren
suffix:semicolon
id|saved_command_line
(braket
id|COMMAND_LINE_SIZE
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;&t;&t; * &quot;mem=nopentium&quot; disables the 4MB page tables.&n;&t;&t; * &quot;mem=XXX[kKmM]&quot; overrides the BIOS-reported&n;&t;&t; * memory size&n;&t;&t; */
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot; &squot;
op_logical_and
op_star
(paren
r_const
r_int
r_int
op_star
)paren
id|from
op_eq
op_star
(paren
r_const
r_int
r_int
op_star
)paren
l_string|&quot;mem=&quot;
)paren
(brace
r_if
c_cond
(paren
id|to
op_ne
id|command_line
)paren
id|to
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|from
op_plus
l_int|4
comma
l_string|&quot;nopentium&quot;
comma
l_int|9
)paren
)paren
(brace
id|from
op_add_assign
l_int|9
op_plus
l_int|4
suffix:semicolon
id|boot_cpu_data.x86_capability
op_and_assign
op_complement
id|X86_FEATURE_PSE
suffix:semicolon
)brace
r_else
(brace
id|memory_end
op_assign
id|simple_strtoul
c_func
(paren
id|from
op_plus
l_int|4
comma
op_amp
id|from
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|from
op_eq
l_char|&squot;K&squot;
op_logical_or
op_star
id|from
op_eq
l_char|&squot;k&squot;
)paren
(brace
id|memory_end
op_assign
id|memory_end
op_lshift
l_int|10
suffix:semicolon
id|from
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|from
op_eq
l_char|&squot;M&squot;
op_logical_or
op_star
id|from
op_eq
l_char|&squot;m&squot;
)paren
(brace
id|memory_end
op_assign
id|memory_end
op_lshift
l_int|20
suffix:semicolon
id|from
op_increment
suffix:semicolon
)brace
)brace
)brace
id|c
op_assign
op_star
(paren
id|from
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|COMMAND_LINE_SIZE
op_le
op_increment
id|len
)paren
r_break
suffix:semicolon
op_star
(paren
id|to
op_increment
)paren
op_assign
id|c
suffix:semicolon
)brace
op_star
id|to
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
op_star
id|cmdline_p
op_assign
id|command_line
suffix:semicolon
id|memory_end
op_add_assign
id|PAGE_OFFSET
suffix:semicolon
op_star
id|memory_start_p
op_assign
id|memory_start
suffix:semicolon
op_star
id|memory_end_p
op_assign
id|memory_end
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
id|LOADER_TYPE
)paren
(brace
id|initrd_start
op_assign
id|INITRD_START
ques
c_cond
id|INITRD_START
op_plus
id|PAGE_OFFSET
suffix:colon
l_int|0
suffix:semicolon
id|initrd_end
op_assign
id|initrd_start
op_plus
id|INITRD_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|initrd_end
OG
id|memory_end
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;initrd extends beyond end of memory &quot;
l_string|&quot;(0x%08lx &gt; 0x%08lx)&bslash;ndisabling initrd&bslash;n&quot;
comma
id|initrd_end
comma
id|memory_end
)paren
suffix:semicolon
id|initrd_start
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* request I/O space for devices used on all i[345]86 PCs */
id|request_region
c_func
(paren
l_int|0x00
comma
l_int|0x20
comma
l_string|&quot;dma1&quot;
)paren
suffix:semicolon
id|request_region
c_func
(paren
l_int|0x40
comma
l_int|0x20
comma
l_string|&quot;timer&quot;
)paren
suffix:semicolon
id|request_region
c_func
(paren
l_int|0x80
comma
l_int|0x10
comma
l_string|&quot;dma page reg&quot;
)paren
suffix:semicolon
id|request_region
c_func
(paren
l_int|0xc0
comma
l_int|0x20
comma
l_string|&quot;dma2&quot;
)paren
suffix:semicolon
id|request_region
c_func
(paren
l_int|0xf0
comma
l_int|0x10
comma
l_string|&quot;fpu&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_VT
macro_line|#if defined(CONFIG_VGA_CONSOLE)
id|conswitchp
op_assign
op_amp
id|vga_con
suffix:semicolon
macro_line|#elif defined(CONFIG_DUMMY_CONSOLE)
id|conswitchp
op_assign
op_amp
id|dummy_con
suffix:semicolon
macro_line|#endif
macro_line|#endif
)brace
multiline_comment|/*&n; *&t;Detection of CPU model.&n; */
DECL|function|cpuid
r_extern
r_inline
r_void
id|cpuid
c_func
(paren
r_int
id|op
comma
r_int
op_star
id|eax
comma
r_int
op_star
id|ebx
comma
r_int
op_star
id|ecx
comma
r_int
op_star
id|edx
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;cpuid&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
op_star
id|eax
)paren
comma
l_string|&quot;=b&quot;
(paren
op_star
id|ebx
)paren
comma
l_string|&quot;=c&quot;
(paren
op_star
id|ecx
)paren
comma
l_string|&quot;=d&quot;
(paren
op_star
id|edx
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
id|op
)paren
suffix:colon
l_string|&quot;cc&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Try to enable ID flag in EFLAGS, in order to allow CPUID instruction.&n; *&t;Return 0 if not possible, anything else if it succeeded.&n; *&t;&n; */
DECL|function|enable_cpuid
r_extern
id|__u32
id|enable_cpuid
c_func
(paren
r_void
)paren
(brace
id|__u32
id|ret
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;pushfl&bslash;n&bslash;t&quot;
l_string|&quot;popl %%eax&bslash;n&bslash;t&quot;
l_string|&quot;movl %%eax,%%ecx&bslash;n&bslash;t&quot;
l_string|&quot;xorl $0x200000,%%eax&bslash;n&bslash;t&quot;
l_string|&quot;pushl %%eax&bslash;n&bslash;t&quot;
l_string|&quot;popfl&bslash;n&bslash;t&quot;
l_string|&quot;pushfl&bslash;n&bslash;t&quot;
l_string|&quot;popl %%eax&bslash;n&bslash;t&quot;
l_string|&quot;xorl %%ecx,%%eax&bslash;n&bslash;t&quot;
l_string|&quot;andl $0x200000,%%eax&bslash;n&bslash;t&quot;
multiline_comment|/* get only the ID flag */
l_string|&quot;orl  %%eax,%%ecx&bslash;n&bslash;t&quot;
multiline_comment|/* and force it into EFLAGS */
l_string|&quot;pushl %%ecx&bslash;n&bslash;t&quot;
l_string|&quot;popfl&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|ret
)paren
suffix:colon
suffix:colon
l_string|&quot;cc&quot;
comma
l_string|&quot;%ecx&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Returns 1 only if the DIV instruction keeps flags. This is the case on&n; *&t;all Cyrix, and on Intel&squot;s PPro/PII, but they can be distinguished from&n; *&t;a Cyrix. In other cases, it returns 0.&n; */
DECL|function|div_keeps_flags
r_extern
r_inline
id|__u32
id|div_keeps_flags
c_func
(paren
r_void
)paren
(brace
id|__u32
id|ret
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;xorl %%eax,%%eax&bslash;n&bslash;t&quot;
l_string|&quot;sahf&bslash;n&bslash;t&quot;
l_string|&quot;movb $5,%%al&bslash;n&bslash;t&quot;
l_string|&quot;movb $2,%%bl&bslash;n&bslash;t&quot;
l_string|&quot;divb %%bl&bslash;n&bslash;t&quot;
l_string|&quot;lahf&bslash;n&bslash;t&quot;
l_string|&quot;cmpb $2,%%ah&bslash;n&bslash;t&quot;
l_string|&quot;setzb %%al&bslash;n&bslash;t&quot;
l_string|&quot;movzbl %%al, %%eax&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|ret
)paren
suffix:colon
suffix:colon
l_string|&quot;cc&quot;
comma
l_string|&quot;%ebx&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Functions for getting/setting Cyrix&squot;s control registers (CCR).&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_inline
r_void
id|setCx86
c_func
(paren
id|__u8
id|reg
comma
id|__u8
id|val
)paren
)paren
(brace
id|__asm__
id|__volatile__
(paren
l_string|&quot;outb %%al,$0x22&bslash;n&bslash;t&quot;
l_string|&quot;mov %1,%%al&bslash;n&bslash;t&quot;
l_string|&quot;outb %%al,$0x23&bslash;n&bslash;t&quot;
suffix:colon
suffix:colon
l_string|&quot;a&quot;
(paren
id|reg
)paren
comma
l_string|&quot;q&quot;
(paren
id|val
)paren
suffix:colon
l_string|&quot;eax&quot;
)paren
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_inline
id|__u8
id|getCx86
c_func
(paren
id|__u8
id|reg
)paren
)paren
(brace
id|__u8
id|ret
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;outb %%al,$0x22&bslash;n&bslash;t&quot;
l_string|&quot;inb $0x23,%%al&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|ret
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
id|reg
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|refine_cyrix_detection
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
)paren
(brace
id|__u8
id|ccr3
suffix:semicolon
id|ccr3
op_assign
id|getCx86
c_func
(paren
l_int|0xc3
)paren
suffix:semicolon
id|setCx86
c_func
(paren
l_int|0xc3
comma
id|ccr3
op_or
l_int|0x80
)paren
suffix:semicolon
id|getCx86
c_func
(paren
l_int|0xc0
)paren
suffix:semicolon
multiline_comment|/* dummy read to change the bus */
r_if
c_cond
(paren
id|getCx86
c_func
(paren
l_int|0xc3
)paren
op_eq
id|ccr3
)paren
multiline_comment|/* ccr3 unchanged : DEVID not supported */
r_return
suffix:semicolon
multiline_comment|/* let&squot;s end here. */
id|setCx86
c_func
(paren
l_int|0xc3
comma
id|ccr3
)paren
suffix:semicolon
multiline_comment|/* restore ccr3 */
multiline_comment|/*&n;&t; * Now, fill x86_mask/model with DEVID.&n;&t; */
id|c-&gt;x86_model
op_assign
id|getCx86
c_func
(paren
l_int|0xfe
)paren
suffix:semicolon
multiline_comment|/* DIR0 to model */
id|c-&gt;x86_mask
op_assign
id|getCx86
c_func
(paren
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* DIR1 to mask */
r_if
c_cond
(paren
(paren
id|c-&gt;x86_model
op_amp
l_int|0xF0
)paren
op_eq
l_int|0x30
)paren
(brace
multiline_comment|/* 6x86(L)! we got it !*/
multiline_comment|/*&n;&t;&t; * we&squot;ll do here a few optimizations.&n;&t;&t; */
multiline_comment|/* since 6x86(L) doesn&squot;t support SMP, we&squot;ll deactivate all LOCK# cycles&n;&t;&t; * so that even if the kernel has been compiled with the -D__SMP__ option&n;&t;&t; * as this is often the case, lock instructions won&squot;t hurt performance.&n;&t;&t; */
id|setCx86
c_func
(paren
l_int|0xc1
comma
id|getCx86
c_func
(paren
l_int|0xc1
)paren
op_or
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* assert NO_LOCK */
id|setCx86
c_func
(paren
l_int|0xc3
comma
(paren
id|getCx86
c_func
(paren
l_int|0xc3
)paren
op_or
l_int|0x10
)paren
op_amp
l_int|0x1F
)paren
suffix:semicolon
multiline_comment|/* enables high registers */
id|setCx86
c_func
(paren
l_int|0xe8
comma
id|getCx86
c_func
(paren
l_int|0xe8
)paren
op_or
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* enable Directory Table Entry Cache */
id|setCx86
c_func
(paren
l_int|0xe9
comma
id|getCx86
c_func
(paren
l_int|0xe9
)paren
op_or
l_int|0x01
)paren
suffix:semicolon
multiline_comment|/* enable cache Write-Through Allocate */
id|setCx86
c_func
(paren
l_int|0xc3
comma
id|getCx86
c_func
(paren
l_int|0xc3
)paren
op_amp
l_int|0x0F
)paren
suffix:semicolon
multiline_comment|/* disable high registers */
)brace
macro_line|#ifdef CONFIG_CYRIX_SUSP
multiline_comment|/*&n;&t; * This option enables the low power feature of the 6x86: it can&n;&t; * suspend on halt without any performance hurt, as Cyrix claims.&n;&t; *&n;&t; * This option is not exported yet, as I wonder about the cycle&n;&t; * counter..&t;&t;&t;Linus&n;&t; */
r_if
c_cond
(paren
(paren
(paren
id|c-&gt;x86_model
op_amp
l_int|0xF0
)paren
op_eq
l_int|0x30
)paren
op_logical_or
multiline_comment|/* 6x86(L) */
(paren
(paren
id|c-&gt;x86_model
op_amp
l_int|0xF0
)paren
op_eq
l_int|0x50
)paren
)paren
(brace
multiline_comment|/* 6x86MX */
multiline_comment|/*&n;&t;&t; * suspend on halt : this amazingly reduces power consumption&n;&t;&t; * and cpu overheat.&n;&t;&t; */
id|setCx86
c_func
(paren
l_int|0xc2
comma
id|getCx86
c_func
(paren
l_int|0xc2
)paren
op_or
l_int|0x08
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; *&t;This function uses CPUID to get some precisions about the current&n; *&t;cpu. It&squot;s called directly from head.S, just before branching to&n; *&t;start_kernel. It could have been called from other points, but in&n; *&t;any case, it must be called before setup_arch() because this function&n; *&t;uses (and changes) x86_capability which, of course, must have been set.&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|refine_cpu_detection
c_func
(paren
r_void
)paren
)paren
(brace
r_int
r_int
id|dummy
comma
id|r
suffix:semicolon
r_struct
id|cpuinfo_x86
op_star
id|c
op_assign
op_amp
id|boot_cpu_data
suffix:semicolon
id|c-&gt;cpuid_level
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|enable_cpuid
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;&t; * CPUID is supported by this cpu. It&squot;s a recent one.&n;&t; * All Pentium, PentiumPro, PentiumII, AmdK5, AmdK6, 6x86MX and some&n;&t; * latests 486 will go directly here.&n;&t; */
multiline_comment|/* get vendor_id string */
id|cpuid
c_func
(paren
l_int|0
comma
op_amp
id|c-&gt;cpuid_level
comma
(paren
r_int
op_star
)paren
op_amp
id|c-&gt;x86_vendor_id
(braket
l_int|0
)braket
comma
(paren
r_int
op_star
)paren
op_amp
id|c-&gt;x86_vendor_id
(braket
l_int|8
)braket
comma
(paren
r_int
op_star
)paren
op_amp
id|c-&gt;x86_vendor_id
(braket
l_int|4
)braket
)paren
suffix:semicolon
multiline_comment|/* get model and mask */
id|cpuid
c_func
(paren
l_int|1
comma
op_amp
id|r
comma
op_amp
id|dummy
comma
op_amp
id|dummy
comma
(paren
r_int
op_star
)paren
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
id|c-&gt;x86
op_assign
(paren
id|r
op_rshift
l_int|8
)paren
op_amp
l_int|0xF
suffix:semicolon
id|c-&gt;x86_model
op_assign
(paren
id|r
op_rshift
l_int|4
)paren
op_amp
l_int|0xF
suffix:semicolon
id|c-&gt;x86_mask
op_assign
id|r
op_amp
l_int|0xF
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * CPUID doesn&squot;t seem to be supported. But if the cpu is a Cyrix, we&n;&t;&t; * can try to activate it. If not, it&squot;s simply an old 386 or 486 from&n;&t;&t; * which we won&squot;t get anything more.&n;&t;&t; */
id|__u8
id|ccr3
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;x86
op_le
l_int|3
)paren
multiline_comment|/* nothing more can be done, it&squot;s a 386. */
r_return
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The following test can distinguish a Cyrix from an other 486 cpu.&n;&t;&t; * As Intel&squot;s PPro and PII behaves like cyrix, we must use this code&n;&t;&t; * only when we are certain that the cpu *is not* a PPro/PII.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|div_keeps_flags
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* just a simple 486. let&squot;s forget CPUID. */
multiline_comment|/*&n;&t;&t; * now we know we have a Cyrix. let&squot;s activate its CPUID if it has one.&n;&t;&t; */
id|setCx86
c_func
(paren
l_int|0xC3
comma
(paren
(paren
id|ccr3
op_assign
id|getCx86
c_func
(paren
l_int|0xC3
)paren
)paren
op_amp
l_int|0x0F
)paren
op_or
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* enable all CCRs */
id|setCx86
c_func
(paren
l_int|0xE8
comma
id|getCx86
c_func
(paren
l_int|0xE8
)paren
op_or
l_int|0x80
)paren
suffix:semicolon
id|setCx86
c_func
(paren
l_int|0xC3
comma
id|ccr3
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * first we assume it&squot;s a cx486 because it doesn&squot;t have cpuid.&n;&t;&t; */
op_star
(paren
r_int
r_int
r_int
op_star
)paren
op_amp
id|c-&gt;x86_vendor_id
op_assign
l_int|0x7869727943ULL
suffix:semicolon
multiline_comment|/* &quot;Cyrix&bslash;0&bslash;0&bslash;0&quot; */
id|c-&gt;x86_model
op_assign
l_int|0xFE
suffix:semicolon
multiline_comment|/* Cx486 */
id|c-&gt;x86_mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if CPUID is supported now, we&squot;ll use it, but won&squot;t trust it.&n;&t;&t; */
r_if
c_cond
(paren
id|enable_cpuid
c_func
(paren
)paren
)paren
(brace
id|cpuid
c_func
(paren
l_int|0
comma
op_amp
id|c-&gt;cpuid_level
comma
(paren
r_int
op_star
)paren
op_amp
id|c-&gt;x86_vendor_id
(braket
l_int|0
)braket
comma
(paren
r_int
op_star
)paren
op_amp
id|c-&gt;x86_vendor_id
(braket
l_int|8
)braket
comma
(paren
r_int
op_star
)paren
op_amp
id|c-&gt;x86_vendor_id
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|cpuid
c_func
(paren
l_int|1
comma
op_amp
id|r
comma
op_amp
id|dummy
comma
op_amp
id|dummy
comma
(paren
r_int
op_star
)paren
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
id|c-&gt;x86
op_assign
(paren
id|r
op_rshift
l_int|8
)paren
op_amp
l_int|0xF
suffix:semicolon
multiline_comment|/* cpu family */
id|c-&gt;x86_model
op_assign
(paren
id|r
op_rshift
l_int|4
)paren
op_amp
l_int|0xF
suffix:semicolon
id|c-&gt;x86_mask
op_assign
id|r
op_amp
l_int|0xF
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * If we have any Cyrix, even the latest one, we&squot;ll read DEVID.&n;&t; * As it was assumed in head.S, we suppose that Cyrix&squot;s DEVID is&n;&t; * more accurate than its CPUID. So if available, we read it.&n;&t; */
r_if
c_cond
(paren
op_star
(paren
r_int
op_star
)paren
op_amp
id|c-&gt;x86_vendor_id
op_eq
l_int|0x69727943
)paren
(brace
multiline_comment|/* &quot;Cyri&quot;... */
id|refine_cyrix_detection
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
id|c-&gt;x86_vendor_id
(braket
l_int|12
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* terminates the vendor id string. */
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|cyrix_model
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
)paren
(brace
r_int
id|nr
op_assign
id|c-&gt;x86_model
suffix:semicolon
r_char
op_star
id|buf
op_assign
id|c-&gt;x86_model_id
suffix:semicolon
multiline_comment|/* Cyrix claims they have a TSC, but it is broken */
id|c-&gt;x86_capability
op_and_assign
op_complement
id|X86_FEATURE_TSC
suffix:semicolon
multiline_comment|/* Note that some of the possibilities this decoding allows&n;&t; * have never actually been manufactured - but those that&n;&t; * do actually exist are correctly decoded.&n;&t; */
r_if
c_cond
(paren
id|nr
OL
l_int|0x20
)paren
(brace
id|strcpy
c_func
(paren
id|buf
comma
l_string|&quot;Cx486&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|nr
op_amp
l_int|0x10
)paren
)paren
(brace
id|sprintf
c_func
(paren
id|buf
op_plus
l_int|5
comma
l_string|&quot;%c%s%c&quot;
comma
(paren
id|nr
op_amp
l_int|0x01
)paren
ques
c_cond
l_char|&squot;D&squot;
suffix:colon
l_char|&squot;S&squot;
comma
(paren
id|nr
op_amp
l_int|0x04
)paren
ques
c_cond
l_string|&quot;Rx&quot;
suffix:colon
l_string|&quot;LC&quot;
comma
(paren
id|nr
op_amp
l_int|0x02
)paren
ques
c_cond
l_char|&squot;2&squot;
suffix:colon
l_char|&squot;&bslash;000&squot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|nr
op_amp
l_int|0x08
)paren
)paren
(brace
id|sprintf
c_func
(paren
id|buf
op_plus
l_int|5
comma
l_string|&quot;S%s%c&quot;
comma
(paren
id|nr
op_amp
l_int|0x01
)paren
ques
c_cond
l_string|&quot;2&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|nr
op_amp
l_int|0x02
)paren
ques
c_cond
l_char|&squot;e&squot;
suffix:colon
l_char|&squot;&bslash;000&squot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|sprintf
c_func
(paren
id|buf
op_plus
l_int|5
comma
l_string|&quot;DX%c&quot;
comma
id|nr
op_eq
l_int|0x1b
ques
c_cond
l_char|&squot;2&squot;
suffix:colon
(paren
id|nr
op_eq
l_int|0x1f
ques
c_cond
l_char|&squot;4&squot;
suffix:colon
l_char|&squot;&bslash;000&squot;
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|nr
op_ge
l_int|0x20
op_logical_and
id|nr
op_le
l_int|0x4f
)paren
(brace
multiline_comment|/* 5x86, 6x86 or Gx86 */
r_char
op_star
id|s
op_assign
l_string|&quot;&quot;
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_ge
l_int|0x30
op_logical_and
id|nr
OL
l_int|0x40
)paren
(brace
multiline_comment|/* 6x86 */
r_if
c_cond
(paren
id|c-&gt;x86
op_eq
l_int|5
op_logical_and
(paren
id|c-&gt;x86_capability
op_amp
id|X86_FEATURE_CX8
)paren
)paren
id|s
op_assign
l_string|&quot;L&quot;
suffix:semicolon
multiline_comment|/* 6x86L */
r_else
r_if
c_cond
(paren
id|c-&gt;x86
op_eq
l_int|6
)paren
id|s
op_assign
l_string|&quot;MX&quot;
suffix:semicolon
multiline_comment|/* 6x86MX */
)brace
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%cx86%s %cx Core/Bus Clock&quot;
comma
l_string|&quot;??56G&quot;
(braket
id|nr
op_rshift
l_int|4
)braket
comma
id|s
comma
l_string|&quot;12??43&quot;
(braket
id|nr
op_amp
l_int|0x05
)braket
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|nr
op_ge
l_int|0x50
op_logical_and
id|nr
op_le
l_int|0x5f
)paren
(brace
multiline_comment|/* Cyrix 6x86MX */
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;6x86MX %c%sx Core/Bus Clock&quot;
comma
l_string|&quot;12233445&quot;
(braket
id|nr
op_amp
l_int|0x07
)braket
comma
(paren
id|nr
op_logical_and
op_logical_neg
(paren
id|nr
op_amp
l_int|1
)paren
)paren
ques
c_cond
l_string|&quot;.5&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|nr
op_ge
l_int|0xfd
op_logical_and
id|c-&gt;cpuid_level
OL
l_int|0
)paren
(brace
multiline_comment|/* Probably 0xfd (Cx486[SD]LC with no ID register)&n;&t;&t; * or 0xfe (Cx486 A step with no ID register).&n;&t;&t; */
id|strcpy
c_func
(paren
id|buf
comma
l_string|&quot;Cx486&quot;
)paren
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Use CPUID if applicable */
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|amd_model
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
)paren
(brace
r_int
r_int
id|n
comma
id|dummy
comma
op_star
id|v
suffix:semicolon
multiline_comment|/* Actually we must have cpuid or we could never have&n;&t; * figured out that this was AMD from the vendor info :-).&n;&t; */
id|cpuid
c_func
(paren
l_int|0x80000000
comma
op_amp
id|n
comma
op_amp
id|dummy
comma
op_amp
id|dummy
comma
op_amp
id|dummy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
l_int|4
)paren
r_return
l_int|0
suffix:semicolon
id|v
op_assign
(paren
r_int
r_int
op_star
)paren
id|c-&gt;x86_model_id
suffix:semicolon
id|cpuid
c_func
(paren
l_int|0x80000002
comma
op_amp
id|v
(braket
l_int|0
)braket
comma
op_amp
id|v
(braket
l_int|1
)braket
comma
op_amp
id|v
(braket
l_int|2
)braket
comma
op_amp
id|v
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|cpuid
c_func
(paren
l_int|0x80000003
comma
op_amp
id|v
(braket
l_int|4
)braket
comma
op_amp
id|v
(braket
l_int|5
)braket
comma
op_amp
id|v
(braket
l_int|6
)braket
comma
op_amp
id|v
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|cpuid
c_func
(paren
l_int|0x80000004
comma
op_amp
id|v
(braket
l_int|8
)braket
comma
op_amp
id|v
(braket
l_int|9
)braket
comma
op_amp
id|v
(braket
l_int|10
)braket
comma
op_amp
id|v
(braket
l_int|11
)braket
)paren
suffix:semicolon
id|c-&gt;x86_model_id
(braket
l_int|48
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|get_cpu_vendor
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
)paren
(brace
r_char
op_star
id|v
op_assign
id|c-&gt;x86_vendor_id
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|v
comma
l_string|&quot;GenuineIntel&quot;
)paren
)paren
id|c-&gt;x86_vendor
op_assign
id|X86_VENDOR_INTEL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|v
comma
l_string|&quot;AuthenticAMD&quot;
)paren
)paren
id|c-&gt;x86_vendor
op_assign
id|X86_VENDOR_AMD
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|v
comma
l_string|&quot;Cyrix&quot;
comma
l_int|5
)paren
)paren
id|c-&gt;x86_vendor
op_assign
id|X86_VENDOR_CYRIX
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|v
comma
l_string|&quot;UMC UMC UMC &quot;
)paren
)paren
id|c-&gt;x86_vendor
op_assign
id|X86_VENDOR_UMC
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|v
comma
l_string|&quot;CentaurHauls&quot;
)paren
)paren
id|c-&gt;x86_vendor
op_assign
id|X86_VENDOR_CENTAUR
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|v
comma
l_string|&quot;NexGenDriven&quot;
)paren
)paren
id|c-&gt;x86_vendor
op_assign
id|X86_VENDOR_NEXGEN
suffix:semicolon
r_else
id|c-&gt;x86_vendor
op_assign
id|X86_VENDOR_UNKNOWN
suffix:semicolon
)brace
DECL|struct|cpu_model_info
r_struct
id|cpu_model_info
(brace
DECL|member|vendor
r_int
id|vendor
suffix:semicolon
DECL|member|x86
r_int
id|x86
suffix:semicolon
DECL|member|model_names
r_char
op_star
id|model_names
(braket
l_int|16
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
r_struct
id|cpu_model_info
id|cpu_models
(braket
)braket
id|__initdata
op_assign
(brace
(brace
id|X86_VENDOR_INTEL
comma
l_int|4
comma
(brace
l_string|&quot;486 DX-25/33&quot;
comma
l_string|&quot;486 DX-50&quot;
comma
l_string|&quot;486 SX&quot;
comma
l_string|&quot;486 DX/2&quot;
comma
l_string|&quot;486 SL&quot;
comma
l_string|&quot;486 SX/2&quot;
comma
l_int|NULL
comma
l_string|&quot;486 DX/2-WB&quot;
comma
l_string|&quot;486 DX/4&quot;
comma
l_string|&quot;486 DX/4-WB&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
comma
(brace
id|X86_VENDOR_INTEL
comma
l_int|5
comma
(brace
l_string|&quot;Pentium 60/66 A-step&quot;
comma
l_string|&quot;Pentium 60/66&quot;
comma
l_string|&quot;Pentium 75+&quot;
comma
l_string|&quot;OverDrive PODP5V83&quot;
comma
l_string|&quot;Pentium MMX&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;Mobile Pentium 75+&quot;
comma
l_string|&quot;Mobile Pentium MMX&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
comma
(brace
id|X86_VENDOR_INTEL
comma
l_int|6
comma
(brace
l_string|&quot;Pentium Pro A-step&quot;
comma
l_string|&quot;Pentium Pro&quot;
comma
l_int|NULL
comma
l_string|&quot;Pentium II (Klamath)&quot;
comma
l_int|NULL
comma
l_string|&quot;Pentium II (Deschutes)&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
comma
(brace
id|X86_VENDOR_CYRIX
comma
l_int|4
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;MediaGX&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;5x86&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
comma
(brace
id|X86_VENDOR_CYRIX
comma
l_int|5
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;6x86&quot;
comma
l_int|NULL
comma
l_string|&quot;GXm&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
comma
(brace
id|X86_VENDOR_CYRIX
comma
l_int|6
comma
(brace
l_string|&quot;6x86MX&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
comma
(brace
id|X86_VENDOR_AMD
comma
l_int|4
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;DX/2&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;DX/2-WB&quot;
comma
l_string|&quot;DX/4&quot;
comma
l_string|&quot;DX/4-WB&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;Am5x86-WT&quot;
comma
l_string|&quot;Am5x86-WB&quot;
)brace
)brace
comma
(brace
id|X86_VENDOR_AMD
comma
l_int|5
comma
(brace
l_string|&quot;K5/SSA5 (PR75, PR90, PR100)&quot;
comma
l_string|&quot;K5 (PR120, PR133)&quot;
comma
l_string|&quot;K5 (PR166)&quot;
comma
l_string|&quot;K5 (PR200)&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;K6 (PR166 - PR266)&quot;
comma
l_string|&quot;K6 (PR166 - PR300)&quot;
comma
l_string|&quot;K6-2 (PR233 - PR333)&quot;
comma
l_string|&quot;K6-3 (PR300 - PR450)&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
comma
(brace
id|X86_VENDOR_UMC
comma
l_int|4
comma
(brace
l_int|NULL
comma
l_string|&quot;U5D&quot;
comma
l_string|&quot;U5S&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
comma
(brace
id|X86_VENDOR_CENTAUR
comma
l_int|5
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;C6&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
comma
(brace
id|X86_VENDOR_NEXGEN
comma
l_int|5
comma
(brace
l_string|&quot;Nx586&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
comma
)brace
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|identify_cpu
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
id|c-&gt;loops_per_sec
op_assign
id|loops_per_sec
suffix:semicolon
id|get_cpu_vendor
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;x86_vendor
op_eq
id|X86_VENDOR_UNKNOWN
op_logical_and
id|c-&gt;cpuid_level
OL
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;x86_vendor
op_eq
id|X86_VENDOR_CYRIX
op_logical_and
id|cyrix_model
c_func
(paren
id|c
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;x86_model
OL
l_int|16
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|cpu_models
)paren
op_div
r_sizeof
(paren
r_struct
id|cpu_model_info
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|cpu_models
(braket
id|i
)braket
dot
id|vendor
op_eq
id|c-&gt;x86_vendor
op_logical_and
id|cpu_models
(braket
id|i
)braket
dot
id|x86
op_eq
id|c-&gt;x86
)paren
(brace
id|p
op_assign
id|cpu_models
(braket
id|i
)braket
dot
id|model_names
(braket
id|c-&gt;x86_model
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p
)paren
(brace
id|strcpy
c_func
(paren
id|c-&gt;x86_model_id
comma
id|p
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c-&gt;x86_vendor
op_eq
id|X86_VENDOR_AMD
op_logical_and
id|amd_model
c_func
(paren
id|c
)paren
)paren
r_return
suffix:semicolon
id|sprintf
c_func
(paren
id|c-&gt;x86_model_id
comma
l_string|&quot;%02x/%02x&quot;
comma
id|c-&gt;x86_vendor
comma
id|c-&gt;x86_model
)paren
suffix:semicolon
)brace
DECL|variable|__initdata
r_static
r_char
op_star
id|cpu_vendor_names
(braket
)braket
id|__initdata
op_assign
(brace
l_string|&quot;Intel&quot;
comma
l_string|&quot;Cyrix&quot;
comma
l_string|&quot;AMD&quot;
comma
l_string|&quot;UMC&quot;
comma
l_string|&quot;NexGen&quot;
comma
l_string|&quot;Centaur&quot;
)brace
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|print_cpu_info
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
)paren
(brace
r_char
op_star
id|vendor
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;x86_vendor
OL
r_sizeof
(paren
id|cpu_vendor_names
)paren
op_div
r_sizeof
(paren
r_char
op_star
)paren
)paren
id|vendor
op_assign
id|cpu_vendor_names
(braket
id|c-&gt;x86_vendor
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c-&gt;cpuid_level
op_ge
l_int|0
)paren
id|vendor
op_assign
id|c-&gt;x86_vendor_id
suffix:semicolon
r_if
c_cond
(paren
id|vendor
)paren
id|printk
c_func
(paren
l_string|&quot;%s &quot;
comma
id|vendor
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;x86_model_id
(braket
l_int|0
)braket
)paren
id|printk
c_func
(paren
l_string|&quot;%d86&quot;
comma
id|c-&gt;x86
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|c-&gt;x86_model_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;x86_mask
)paren
id|printk
c_func
(paren
l_string|&quot; stepping %02x&quot;
comma
id|c-&gt;x86_mask
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get CPU information for use by the procfs.&n; */
DECL|function|get_cpuinfo
r_int
id|get_cpuinfo
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_char
op_star
id|p
op_assign
id|buffer
suffix:semicolon
r_int
id|sep_bug
suffix:semicolon
r_static
r_char
op_star
id|x86_cap_flags
(braket
)braket
op_assign
(brace
l_string|&quot;fpu&quot;
comma
l_string|&quot;vme&quot;
comma
l_string|&quot;de&quot;
comma
l_string|&quot;pse&quot;
comma
l_string|&quot;tsc&quot;
comma
l_string|&quot;msr&quot;
comma
l_string|&quot;6&quot;
comma
l_string|&quot;mce&quot;
comma
l_string|&quot;cx8&quot;
comma
l_string|&quot;9&quot;
comma
l_string|&quot;10&quot;
comma
l_string|&quot;sep&quot;
comma
l_string|&quot;12&quot;
comma
l_string|&quot;pge&quot;
comma
l_string|&quot;14&quot;
comma
l_string|&quot;cmov&quot;
comma
l_string|&quot;16&quot;
comma
l_string|&quot;17&quot;
comma
l_string|&quot;18&quot;
comma
l_string|&quot;19&quot;
comma
l_string|&quot;20&quot;
comma
l_string|&quot;21&quot;
comma
l_string|&quot;22&quot;
comma
l_string|&quot;mmx&quot;
comma
l_string|&quot;24&quot;
comma
l_string|&quot;25&quot;
comma
l_string|&quot;26&quot;
comma
l_string|&quot;27&quot;
comma
l_string|&quot;28&quot;
comma
l_string|&quot;29&quot;
comma
l_string|&quot;30&quot;
comma
l_string|&quot;31&quot;
)brace
suffix:semicolon
r_struct
id|cpuinfo_x86
op_star
id|c
op_assign
id|cpu_data
suffix:semicolon
r_int
id|i
comma
id|n
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|NR_CPUS
suffix:semicolon
id|n
op_increment
comma
id|c
op_increment
)paren
(brace
macro_line|#ifdef __SMP__
r_if
c_cond
(paren
op_logical_neg
(paren
id|cpu_present_map
op_amp
(paren
l_int|1
op_lshift
id|n
)paren
)paren
)paren
r_continue
suffix:semicolon
macro_line|#endif
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;processor&bslash;t: %d&bslash;n&quot;
l_string|&quot;cpu family&bslash;t: %c&bslash;n&quot;
l_string|&quot;model&bslash;t&bslash;t: %s&bslash;n&quot;
l_string|&quot;vendor_id&bslash;t: %s&bslash;n&quot;
comma
id|n
comma
id|c-&gt;x86
op_plus
l_char|&squot;0&squot;
comma
id|c-&gt;x86_model_id
(braket
l_int|0
)braket
ques
c_cond
id|c-&gt;x86_model_id
suffix:colon
l_string|&quot;unknown&quot;
comma
id|c-&gt;x86_vendor_id
(braket
l_int|0
)braket
ques
c_cond
id|c-&gt;x86_vendor_id
suffix:colon
l_string|&quot;unknown&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;x86_mask
)paren
(brace
r_if
c_cond
(paren
id|c-&gt;x86_vendor
op_eq
id|X86_VENDOR_CYRIX
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;stepping&bslash;t: %d rev %d&bslash;n&quot;
comma
id|c-&gt;x86_mask
op_rshift
l_int|4
comma
id|c-&gt;x86_mask
op_amp
l_int|0x0f
)paren
suffix:semicolon
r_else
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;stepping&bslash;t: %d&bslash;n&quot;
comma
id|c-&gt;x86_mask
)paren
suffix:semicolon
)brace
r_else
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;stepping&bslash;t: unknown&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Modify the capabilities according to chip type */
r_if
c_cond
(paren
id|c-&gt;x86_mask
)paren
(brace
r_if
c_cond
(paren
id|c-&gt;x86_vendor
op_eq
id|X86_VENDOR_CYRIX
)paren
(brace
id|x86_cap_flags
(braket
l_int|24
)braket
op_assign
l_string|&quot;cxmmx&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c-&gt;x86_vendor
op_eq
id|X86_VENDOR_AMD
)paren
(brace
id|x86_cap_flags
(braket
l_int|16
)braket
op_assign
l_string|&quot;fcmov&quot;
suffix:semicolon
id|x86_cap_flags
(braket
l_int|31
)braket
op_assign
l_string|&quot;amd3d&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c-&gt;x86_vendor
op_eq
id|X86_VENDOR_INTEL
)paren
(brace
id|x86_cap_flags
(braket
l_int|6
)braket
op_assign
l_string|&quot;pae&quot;
suffix:semicolon
id|x86_cap_flags
(braket
l_int|9
)braket
op_assign
l_string|&quot;apic&quot;
suffix:semicolon
id|x86_cap_flags
(braket
l_int|12
)braket
op_assign
l_string|&quot;mtrr&quot;
suffix:semicolon
id|x86_cap_flags
(braket
l_int|14
)braket
op_assign
l_string|&quot;mca&quot;
suffix:semicolon
id|x86_cap_flags
(braket
l_int|16
)braket
op_assign
l_string|&quot;pat&quot;
suffix:semicolon
id|x86_cap_flags
(braket
l_int|17
)braket
op_assign
l_string|&quot;pse36&quot;
suffix:semicolon
id|x86_cap_flags
(braket
l_int|24
)braket
op_assign
l_string|&quot;osfxsr&quot;
suffix:semicolon
)brace
)brace
id|sep_bug
op_assign
id|c-&gt;x86_vendor
op_eq
id|X86_VENDOR_INTEL
op_logical_and
id|c-&gt;x86
op_eq
l_int|0x06
op_logical_and
id|c-&gt;cpuid_level
op_ge
l_int|0
op_logical_and
(paren
id|c-&gt;x86_capability
op_amp
id|X86_FEATURE_SEP
)paren
op_logical_and
id|c-&gt;x86_model
OL
l_int|3
op_logical_and
id|c-&gt;x86_mask
OL
l_int|3
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;fdiv_bug&bslash;t: %s&bslash;n&quot;
l_string|&quot;hlt_bug&bslash;t&bslash;t: %s&bslash;n&quot;
l_string|&quot;sep_bug&bslash;t&bslash;t: %s&bslash;n&quot;
l_string|&quot;f00f_bug&bslash;t: %s&bslash;n&quot;
l_string|&quot;fpu&bslash;t&bslash;t: %s&bslash;n&quot;
l_string|&quot;fpu_exception&bslash;t: %s&bslash;n&quot;
l_string|&quot;cpuid level&bslash;t: %d&bslash;n&quot;
l_string|&quot;wp&bslash;t&bslash;t: %s&bslash;n&quot;
l_string|&quot;flags&bslash;t&bslash;t:&quot;
comma
id|c-&gt;fdiv_bug
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
id|c-&gt;hlt_works_ok
ques
c_cond
l_string|&quot;no&quot;
suffix:colon
l_string|&quot;yes&quot;
comma
id|sep_bug
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
id|c-&gt;f00f_bug
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
id|c-&gt;hard_math
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
(paren
id|c-&gt;hard_math
op_logical_and
id|ignore_irq13
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
id|c-&gt;cpuid_level
comma
id|c-&gt;wp_works_ok
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|c-&gt;x86_capability
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; %s&quot;
comma
id|x86_cap_flags
(braket
id|i
)braket
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;nbogomips&bslash;t: %lu.%02lu&bslash;n&bslash;n&quot;
comma
(paren
id|c-&gt;loops_per_sec
op_plus
l_int|2500
)paren
op_div
l_int|500000
comma
(paren
(paren
id|c-&gt;loops_per_sec
op_plus
l_int|2500
)paren
op_div
l_int|5000
)paren
op_mod
l_int|100
)paren
suffix:semicolon
)brace
r_return
id|p
op_minus
id|buffer
suffix:semicolon
)brace
eof
