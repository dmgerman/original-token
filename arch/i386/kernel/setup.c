multiline_comment|/*&n; *  linux/arch/i386/kernel/setup.c&n; *&n; *  Copyright (C) 1995  Linus Torvalds&n; *&n; *  Enhanced CPU type detection by Mike Jagdis, Patrick St. Jean&n; *  and Martin Mares, November 1997.&n; *&n; *  Force Cyrix 6x86(MX) and M II processors to report MTRR capability&n; *  and Cyrix &quot;coma bug&quot; recognition by&n; *      Zolt&#xfffd;n B&#xfffd;sz&#xfffd;rm&#xfffd;nyi &lt;zboszor@mail.externet.hu&gt; February 1999.&n; * &n; *  Force Centaur C6 processors to report MTRR capability.&n; *      Bart Hartgers &lt;bart@etpmod.phys.tue.nl&gt;, May 1999.&n; *&n; *  Intel Mobile Pentium II detection fix. Sean Gilley, June 1999.&n; *&n; *  IDT Winchip tweaks, misc clean ups.&n; *&t;Dave Jones &lt;davej@suse.de&gt;, August 1999&n; *&n; *  Support of BIGMEM added by Gerhard Wichert, Siemens AG, July 1999&n; *&n; *  Better detection of Centaur/IDT WinChip models.&n; *      Bart Hartgers &lt;bart@etpmod.phys.tue.nl&gt;, August 1999.&n; *&n; *  Memory region support&n; *&t;David Parsons &lt;orc@pell.chi.il.us&gt;, July-August 1999&n; *&n; *  Cleaned up cache-detection code&n; *&t;Dave Jones &lt;davej@suse.de&gt;, October 1999&n; *&n; *&t;Added proper L2 cache detection for Coppermine&n; *&t;Dragan Stancevic &lt;visitor@valinux.com&gt;, October 1999&n; *&n; *  Added the original array for capability flags but forgot to credit &n; *  myself :) (~1998) Fixed/cleaned up some cpu_model_info and other stuff&n; *  &t;Jauder Ho &lt;jauderho@carumba.com&gt;, January 2000&n; *&n; *  Detection for Celeron coppermine, identify_cpu() overhauled,&n; *  and a few other clean ups.&n; *  Dave Jones &lt;davej@suse.de&gt;, April 2000&n; *&n; *  Pentium III FXSR, SSE support&n; *  General FPU state handling cleanups&n; *&t;Gareth Hughes &lt;gareth@valinux.com&gt;, May 2000&n; *&n; *  Added proper Cascades CPU and L2 cache detection for Cascades&n; *  and 8-way type cache happy bunch from Intel:^)&n; *  Dragan Stancevic &lt;visitor@valinux.com&gt;, May 2000 &n; *&n; *  Forward port AMD Duron errata T13 from 2.2.17pre&n; *  Dave Jones &lt;davej@suse.de&gt;, August 2000&n; *&n; *  Forward port lots of fixes/improvements from 2.2.18pre&n; *  Cyrix III, Pentium IV support.&n; *  Dave Jones &lt;davej@suse.de&gt;, October 2000&n; *&n; *  Massive cleanup of CPU detection and bug handling;&n; *  Transmeta CPU detection,&n; *  H. Peter Anvin &lt;hpa@zytor.com&gt;, November 2000&n; */
multiline_comment|/*&n; * This file handles the architecture-dependent parts of initialization&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/user.h&gt;
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/apm_bios.h&gt;
macro_line|#ifdef CONFIG_BLK_DEV_RAM
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/cobalt.h&gt;
macro_line|#include &lt;asm/msr.h&gt;
macro_line|#include &lt;asm/desc.h&gt;
macro_line|#include &lt;asm/e820.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/mpspec.h&gt;
macro_line|#include &lt;asm/mmu_context.h&gt;
multiline_comment|/*&n; * Machine setup..&n; */
DECL|variable|ignore_irq13
r_char
id|ignore_irq13
suffix:semicolon
multiline_comment|/* set if exception 16 works */
DECL|variable|boot_cpu_data
r_struct
id|cpuinfo_x86
id|boot_cpu_data
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|mmu_cr4_features
r_int
r_int
id|mmu_cr4_features
suffix:semicolon
multiline_comment|/*&n; * Bus types ..&n; */
macro_line|#ifdef CONFIG_EISA
DECL|variable|EISA_bus
r_int
id|EISA_bus
suffix:semicolon
macro_line|#endif
DECL|variable|MCA_bus
r_int
id|MCA_bus
suffix:semicolon
multiline_comment|/* for MCA, but anyone else can use it if they want */
DECL|variable|machine_id
r_int
r_int
id|machine_id
suffix:semicolon
DECL|variable|machine_submodel_id
r_int
r_int
id|machine_submodel_id
suffix:semicolon
DECL|variable|BIOS_revision
r_int
r_int
id|BIOS_revision
suffix:semicolon
DECL|variable|mca_pentium_flag
r_int
r_int
id|mca_pentium_flag
suffix:semicolon
multiline_comment|/*&n; * Setup options&n; */
DECL|struct|drive_info_struct
DECL|member|dummy
DECL|variable|drive_info
r_struct
id|drive_info_struct
(brace
r_char
id|dummy
(braket
l_int|32
)braket
suffix:semicolon
)brace
id|drive_info
suffix:semicolon
DECL|variable|screen_info
r_struct
id|screen_info
id|screen_info
suffix:semicolon
DECL|variable|apm_info
r_struct
id|apm_info
id|apm_info
suffix:semicolon
DECL|struct|sys_desc_table_struct
r_struct
id|sys_desc_table_struct
(brace
DECL|member|length
r_int
r_int
id|length
suffix:semicolon
DECL|member|table
r_int
r_char
id|table
(braket
l_int|0
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|e820
r_struct
id|e820map
id|e820
suffix:semicolon
DECL|variable|aux_device_present
r_int
r_char
id|aux_device_present
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_RAM
r_extern
r_int
id|rd_doload
suffix:semicolon
multiline_comment|/* 1 = load ramdisk, 0 = don&squot;t load */
r_extern
r_int
id|rd_prompt
suffix:semicolon
multiline_comment|/* 1 = prompt for ramdisk, 0 = don&squot;t prompt */
r_extern
r_int
id|rd_image_start
suffix:semicolon
multiline_comment|/* starting block # of image */
macro_line|#endif
r_extern
r_int
id|root_mountflags
suffix:semicolon
r_extern
r_char
id|_text
comma
id|_etext
comma
id|_edata
comma
id|_end
suffix:semicolon
r_extern
r_int
r_int
id|cpu_khz
suffix:semicolon
DECL|variable|__initdata
r_static
r_int
id|disable_x86_serial_nr
id|__initdata
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n; * This is set up by the setup-routine at boot-time&n; */
DECL|macro|PARAM
mdefine_line|#define PARAM&t;((unsigned char *)empty_zero_page)
DECL|macro|SCREEN_INFO
mdefine_line|#define SCREEN_INFO (*(struct screen_info *) (PARAM+0))
DECL|macro|EXT_MEM_K
mdefine_line|#define EXT_MEM_K (*(unsigned short *) (PARAM+2))
DECL|macro|ALT_MEM_K
mdefine_line|#define ALT_MEM_K (*(unsigned long *) (PARAM+0x1e0))
DECL|macro|E820_MAP_NR
mdefine_line|#define E820_MAP_NR (*(char*) (PARAM+E820NR))
DECL|macro|E820_MAP
mdefine_line|#define E820_MAP    ((struct e820entry *) (PARAM+E820MAP))
DECL|macro|APM_BIOS_INFO
mdefine_line|#define APM_BIOS_INFO (*(struct apm_bios_info *) (PARAM+0x40))
DECL|macro|DRIVE_INFO
mdefine_line|#define DRIVE_INFO (*(struct drive_info_struct *) (PARAM+0x80))
DECL|macro|SYS_DESC_TABLE
mdefine_line|#define SYS_DESC_TABLE (*(struct sys_desc_table_struct*)(PARAM+0xa0))
DECL|macro|MOUNT_ROOT_RDONLY
mdefine_line|#define MOUNT_ROOT_RDONLY (*(unsigned short *) (PARAM+0x1F2))
DECL|macro|RAMDISK_FLAGS
mdefine_line|#define RAMDISK_FLAGS (*(unsigned short *) (PARAM+0x1F8))
DECL|macro|ORIG_ROOT_DEV
mdefine_line|#define ORIG_ROOT_DEV (*(unsigned short *) (PARAM+0x1FC))
DECL|macro|AUX_DEVICE_INFO
mdefine_line|#define AUX_DEVICE_INFO (*(unsigned char *) (PARAM+0x1FF))
DECL|macro|LOADER_TYPE
mdefine_line|#define LOADER_TYPE (*(unsigned char *) (PARAM+0x210))
DECL|macro|KERNEL_START
mdefine_line|#define KERNEL_START (*(unsigned long *) (PARAM+0x214))
DECL|macro|INITRD_START
mdefine_line|#define INITRD_START (*(unsigned long *) (PARAM+0x218))
DECL|macro|INITRD_SIZE
mdefine_line|#define INITRD_SIZE (*(unsigned long *) (PARAM+0x21c))
DECL|macro|COMMAND_LINE
mdefine_line|#define COMMAND_LINE ((char *) (PARAM+2048))
DECL|macro|COMMAND_LINE_SIZE
mdefine_line|#define COMMAND_LINE_SIZE 256
DECL|macro|RAMDISK_IMAGE_START_MASK
mdefine_line|#define RAMDISK_IMAGE_START_MASK  &t;0x07FF
DECL|macro|RAMDISK_PROMPT_FLAG
mdefine_line|#define RAMDISK_PROMPT_FLAG&t;&t;0x8000
DECL|macro|RAMDISK_LOAD_FLAG
mdefine_line|#define RAMDISK_LOAD_FLAG&t;&t;0x4000&t;
macro_line|#ifdef&t;CONFIG_VISWS
DECL|variable|visws_board_type
r_char
id|visws_board_type
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|visws_board_rev
r_char
id|visws_board_rev
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|macro|PIIX_PM_START
mdefine_line|#define&t;PIIX_PM_START&t;&t;0x0F80
DECL|macro|SIO_GPIO_START
mdefine_line|#define&t;SIO_GPIO_START&t;&t;0x0FC0
DECL|macro|SIO_PM_START
mdefine_line|#define&t;SIO_PM_START&t;&t;0x0FC8
DECL|macro|PMBASE
mdefine_line|#define&t;PMBASE&t;&t;&t;PIIX_PM_START
DECL|macro|GPIREG0
mdefine_line|#define&t;GPIREG0&t;&t;&t;(PMBASE+0x30)
DECL|macro|GPIREG
mdefine_line|#define&t;GPIREG(x)&t;&t;(GPIREG0+((x)/8))
DECL|macro|PIIX_GPI_BD_ID1
mdefine_line|#define&t;PIIX_GPI_BD_ID1&t;&t;18
DECL|macro|PIIX_GPI_BD_REG
mdefine_line|#define&t;PIIX_GPI_BD_REG&t;&t;GPIREG(PIIX_GPI_BD_ID1)
DECL|macro|PIIX_GPI_BD_SHIFT
mdefine_line|#define&t;PIIX_GPI_BD_SHIFT&t;(PIIX_GPI_BD_ID1 % 8)
DECL|macro|SIO_INDEX
mdefine_line|#define&t;SIO_INDEX&t;0x2e
DECL|macro|SIO_DATA
mdefine_line|#define&t;SIO_DATA&t;0x2f
DECL|macro|SIO_DEV_SEL
mdefine_line|#define&t;SIO_DEV_SEL&t;0x7
DECL|macro|SIO_DEV_ENB
mdefine_line|#define&t;SIO_DEV_ENB&t;0x30
DECL|macro|SIO_DEV_MSB
mdefine_line|#define&t;SIO_DEV_MSB&t;0x60
DECL|macro|SIO_DEV_LSB
mdefine_line|#define&t;SIO_DEV_LSB&t;0x61
DECL|macro|SIO_GP_DEV
mdefine_line|#define&t;SIO_GP_DEV&t;0x7
DECL|macro|SIO_GP_BASE
mdefine_line|#define&t;SIO_GP_BASE&t;SIO_GPIO_START
DECL|macro|SIO_GP_MSB
mdefine_line|#define&t;SIO_GP_MSB&t;(SIO_GP_BASE&gt;&gt;8)
DECL|macro|SIO_GP_LSB
mdefine_line|#define&t;SIO_GP_LSB&t;(SIO_GP_BASE&amp;0xff)
DECL|macro|SIO_GP_DATA1
mdefine_line|#define&t;SIO_GP_DATA1&t;(SIO_GP_BASE+0)
DECL|macro|SIO_PM_DEV
mdefine_line|#define&t;SIO_PM_DEV&t;0x8
DECL|macro|SIO_PM_BASE
mdefine_line|#define&t;SIO_PM_BASE&t;SIO_PM_START
DECL|macro|SIO_PM_MSB
mdefine_line|#define&t;SIO_PM_MSB&t;(SIO_PM_BASE&gt;&gt;8)
DECL|macro|SIO_PM_LSB
mdefine_line|#define&t;SIO_PM_LSB&t;(SIO_PM_BASE&amp;0xff)
DECL|macro|SIO_PM_INDEX
mdefine_line|#define&t;SIO_PM_INDEX&t;(SIO_PM_BASE+0)
DECL|macro|SIO_PM_DATA
mdefine_line|#define&t;SIO_PM_DATA&t;(SIO_PM_BASE+1)
DECL|macro|SIO_PM_FER2
mdefine_line|#define&t;SIO_PM_FER2&t;0x1
DECL|macro|SIO_PM_GP_EN
mdefine_line|#define&t;SIO_PM_GP_EN&t;0x80
r_static
r_void
DECL|function|visws_get_board_type_and_rev
id|visws_get_board_type_and_rev
c_func
(paren
r_void
)paren
(brace
r_int
id|raw
suffix:semicolon
id|visws_board_type
op_assign
(paren
r_char
)paren
(paren
id|inb_p
c_func
(paren
id|PIIX_GPI_BD_REG
)paren
op_amp
id|PIIX_GPI_BD_REG
)paren
op_rshift
id|PIIX_GPI_BD_SHIFT
suffix:semicolon
multiline_comment|/*&n; * Get Board rev.&n; * First, we have to initialize the 307 part to allow us access&n; * to the GPIO registers.  Let&squot;s map them at 0x0fc0 which is right&n; * after the PIIX4 PM section.&n; */
id|outb_p
c_func
(paren
id|SIO_DEV_SEL
comma
id|SIO_INDEX
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|SIO_GP_DEV
comma
id|SIO_DATA
)paren
suffix:semicolon
multiline_comment|/* Talk to GPIO regs. */
id|outb_p
c_func
(paren
id|SIO_DEV_MSB
comma
id|SIO_INDEX
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|SIO_GP_MSB
comma
id|SIO_DATA
)paren
suffix:semicolon
multiline_comment|/* MSB of GPIO base address */
id|outb_p
c_func
(paren
id|SIO_DEV_LSB
comma
id|SIO_INDEX
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|SIO_GP_LSB
comma
id|SIO_DATA
)paren
suffix:semicolon
multiline_comment|/* LSB of GPIO base address */
id|outb_p
c_func
(paren
id|SIO_DEV_ENB
comma
id|SIO_INDEX
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|1
comma
id|SIO_DATA
)paren
suffix:semicolon
multiline_comment|/* Enable GPIO registers. */
multiline_comment|/*&n; * Now, we have to map the power management section to write&n; * a bit which enables access to the GPIO registers.&n; * What lunatic came up with this shit?&n; */
id|outb_p
c_func
(paren
id|SIO_DEV_SEL
comma
id|SIO_INDEX
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|SIO_PM_DEV
comma
id|SIO_DATA
)paren
suffix:semicolon
multiline_comment|/* Talk to GPIO regs. */
id|outb_p
c_func
(paren
id|SIO_DEV_MSB
comma
id|SIO_INDEX
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|SIO_PM_MSB
comma
id|SIO_DATA
)paren
suffix:semicolon
multiline_comment|/* MSB of PM base address */
id|outb_p
c_func
(paren
id|SIO_DEV_LSB
comma
id|SIO_INDEX
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|SIO_PM_LSB
comma
id|SIO_DATA
)paren
suffix:semicolon
multiline_comment|/* LSB of PM base address */
id|outb_p
c_func
(paren
id|SIO_DEV_ENB
comma
id|SIO_INDEX
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|1
comma
id|SIO_DATA
)paren
suffix:semicolon
multiline_comment|/* Enable PM registers. */
multiline_comment|/*&n; * Now, write the PM register which enables the GPIO registers.&n; */
id|outb_p
c_func
(paren
id|SIO_PM_FER2
comma
id|SIO_PM_INDEX
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|SIO_PM_GP_EN
comma
id|SIO_PM_DATA
)paren
suffix:semicolon
multiline_comment|/*&n; * Now, initialize the GPIO registers.&n; * We want them all to be inputs which is the&n; * power on default, so let&squot;s leave them alone.&n; * So, let&squot;s just read the board rev!&n; */
id|raw
op_assign
id|inb_p
c_func
(paren
id|SIO_GP_DATA1
)paren
suffix:semicolon
id|raw
op_and_assign
l_int|0x7f
suffix:semicolon
multiline_comment|/* 7 bits of valid board revision ID. */
r_if
c_cond
(paren
id|visws_board_type
op_eq
id|VISWS_320
)paren
(brace
r_if
c_cond
(paren
id|raw
OL
l_int|0x6
)paren
(brace
id|visws_board_rev
op_assign
l_int|4
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|raw
OL
l_int|0xc
)paren
(brace
id|visws_board_rev
op_assign
l_int|5
suffix:semicolon
)brace
r_else
(brace
id|visws_board_rev
op_assign
l_int|6
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|visws_board_type
op_eq
id|VISWS_540
)paren
(brace
id|visws_board_rev
op_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|visws_board_rev
op_assign
id|raw
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Silicon Graphics %s (rev %d)&bslash;n&quot;
comma
id|visws_board_type
op_eq
id|VISWS_320
ques
c_cond
l_string|&quot;320&quot;
suffix:colon
(paren
id|visws_board_type
op_eq
id|VISWS_540
ques
c_cond
l_string|&quot;540&quot;
suffix:colon
l_string|&quot;unknown&quot;
)paren
comma
id|visws_board_rev
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|variable|command_line
r_static
r_char
id|command_line
(braket
id|COMMAND_LINE_SIZE
)braket
suffix:semicolon
DECL|variable|saved_command_line
r_char
id|saved_command_line
(braket
id|COMMAND_LINE_SIZE
)braket
suffix:semicolon
DECL|variable|standard_io_resources
r_struct
id|resource
id|standard_io_resources
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;dma1&quot;
comma
l_int|0x00
comma
l_int|0x1f
comma
id|IORESOURCE_BUSY
)brace
comma
(brace
l_string|&quot;pic1&quot;
comma
l_int|0x20
comma
l_int|0x3f
comma
id|IORESOURCE_BUSY
)brace
comma
(brace
l_string|&quot;timer&quot;
comma
l_int|0x40
comma
l_int|0x5f
comma
id|IORESOURCE_BUSY
)brace
comma
(brace
l_string|&quot;keyboard&quot;
comma
l_int|0x60
comma
l_int|0x6f
comma
id|IORESOURCE_BUSY
)brace
comma
(brace
l_string|&quot;dma page reg&quot;
comma
l_int|0x80
comma
l_int|0x8f
comma
id|IORESOURCE_BUSY
)brace
comma
(brace
l_string|&quot;pic2&quot;
comma
l_int|0xa0
comma
l_int|0xbf
comma
id|IORESOURCE_BUSY
)brace
comma
(brace
l_string|&quot;dma2&quot;
comma
l_int|0xc0
comma
l_int|0xdf
comma
id|IORESOURCE_BUSY
)brace
comma
(brace
l_string|&quot;fpu&quot;
comma
l_int|0xf0
comma
l_int|0xff
comma
id|IORESOURCE_BUSY
)brace
)brace
suffix:semicolon
DECL|macro|STANDARD_IO_RESOURCES
mdefine_line|#define STANDARD_IO_RESOURCES (sizeof(standard_io_resources)/sizeof(struct resource))
DECL|variable|code_resource
r_static
r_struct
id|resource
id|code_resource
op_assign
(brace
l_string|&quot;Kernel code&quot;
comma
l_int|0x100000
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|data_resource
r_static
r_struct
id|resource
id|data_resource
op_assign
(brace
l_string|&quot;Kernel data&quot;
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|vram_resource
r_static
r_struct
id|resource
id|vram_resource
op_assign
(brace
l_string|&quot;Video RAM area&quot;
comma
l_int|0xa0000
comma
l_int|0xbffff
comma
id|IORESOURCE_BUSY
)brace
suffix:semicolon
multiline_comment|/* System ROM resources */
DECL|macro|MAXROMS
mdefine_line|#define MAXROMS 6
DECL|variable|rom_resources
r_static
r_struct
id|resource
id|rom_resources
(braket
id|MAXROMS
)braket
op_assign
(brace
(brace
l_string|&quot;System ROM&quot;
comma
l_int|0xF0000
comma
l_int|0xFFFFF
comma
id|IORESOURCE_BUSY
)brace
comma
(brace
l_string|&quot;Video ROM&quot;
comma
l_int|0xc0000
comma
l_int|0xc7fff
comma
id|IORESOURCE_BUSY
)brace
)brace
suffix:semicolon
DECL|macro|romsignature
mdefine_line|#define romsignature(x) (*(unsigned short *)(x) == 0xaa55)
DECL|function|probe_roms
r_static
r_void
id|__init
id|probe_roms
c_func
(paren
r_void
)paren
(brace
r_int
id|roms
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_int
r_char
op_star
id|romstart
suffix:semicolon
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
id|rom_resources
op_plus
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Video ROM is standard at C000:0000 - C7FF:0000, check signature */
r_for
c_loop
(paren
id|base
op_assign
l_int|0xC0000
suffix:semicolon
id|base
OL
l_int|0xE0000
suffix:semicolon
id|base
op_add_assign
l_int|2048
)paren
(brace
id|romstart
op_assign
id|bus_to_virt
c_func
(paren
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|romsignature
c_func
(paren
id|romstart
)paren
)paren
r_continue
suffix:semicolon
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
id|rom_resources
op_plus
id|roms
)paren
suffix:semicolon
id|roms
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Extension roms at C800:0000 - DFFF:0000 */
r_for
c_loop
(paren
id|base
op_assign
l_int|0xC8000
suffix:semicolon
id|base
OL
l_int|0xE0000
suffix:semicolon
id|base
op_add_assign
l_int|2048
)paren
(brace
r_int
r_int
id|length
suffix:semicolon
id|romstart
op_assign
id|bus_to_virt
c_func
(paren
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|romsignature
c_func
(paren
id|romstart
)paren
)paren
r_continue
suffix:semicolon
id|length
op_assign
id|romstart
(braket
l_int|2
)braket
op_star
l_int|512
suffix:semicolon
r_if
c_cond
(paren
id|length
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_char
id|chksum
suffix:semicolon
id|chksum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|length
suffix:semicolon
id|i
op_increment
)paren
id|chksum
op_add_assign
id|romstart
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Good checksum? */
r_if
c_cond
(paren
op_logical_neg
id|chksum
)paren
(brace
id|rom_resources
(braket
id|roms
)braket
dot
id|start
op_assign
id|base
suffix:semicolon
id|rom_resources
(braket
id|roms
)braket
dot
id|end
op_assign
id|base
op_plus
id|length
op_minus
l_int|1
suffix:semicolon
id|rom_resources
(braket
id|roms
)braket
dot
id|name
op_assign
l_string|&quot;Extension ROM&quot;
suffix:semicolon
id|rom_resources
(braket
id|roms
)braket
dot
id|flags
op_assign
id|IORESOURCE_BUSY
suffix:semicolon
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
id|rom_resources
op_plus
id|roms
)paren
suffix:semicolon
id|roms
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|roms
op_ge
id|MAXROMS
)paren
r_return
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Final check for motherboard extension rom at E000:0000 */
id|base
op_assign
l_int|0xE0000
suffix:semicolon
id|romstart
op_assign
id|bus_to_virt
c_func
(paren
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|romsignature
c_func
(paren
id|romstart
)paren
)paren
(brace
id|rom_resources
(braket
id|roms
)braket
dot
id|start
op_assign
id|base
suffix:semicolon
id|rom_resources
(braket
id|roms
)braket
dot
id|end
op_assign
id|base
op_plus
l_int|65535
suffix:semicolon
id|rom_resources
(braket
id|roms
)braket
dot
id|name
op_assign
l_string|&quot;Extension ROM&quot;
suffix:semicolon
id|rom_resources
(braket
id|roms
)braket
dot
id|flags
op_assign
id|IORESOURCE_BUSY
suffix:semicolon
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
id|rom_resources
op_plus
id|roms
)paren
suffix:semicolon
)brace
)brace
DECL|function|add_memory_region
r_void
id|__init
id|add_memory_region
c_func
(paren
r_int
r_int
r_int
id|start
comma
r_int
r_int
r_int
id|size
comma
r_int
id|type
)paren
(brace
r_int
id|x
op_assign
id|e820.nr_map
suffix:semicolon
r_if
c_cond
(paren
id|x
op_eq
id|E820MAX
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Ooops! Too many entries in the memory map!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|e820.map
(braket
id|x
)braket
dot
id|addr
op_assign
id|start
suffix:semicolon
id|e820.map
(braket
id|x
)braket
dot
id|size
op_assign
id|size
suffix:semicolon
id|e820.map
(braket
id|x
)braket
dot
id|type
op_assign
id|type
suffix:semicolon
id|e820.nr_map
op_increment
suffix:semicolon
)brace
multiline_comment|/* add_memory_region */
DECL|macro|E820_DEBUG
mdefine_line|#define E820_DEBUG&t;1
DECL|function|print_memory_map
r_static
r_void
id|__init
id|print_memory_map
c_func
(paren
r_char
op_star
id|who
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|e820.nr_map
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %s: %016Lx @ %016Lx &quot;
comma
id|who
comma
id|e820.map
(braket
id|i
)braket
dot
id|size
comma
id|e820.map
(braket
id|i
)braket
dot
id|addr
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|e820.map
(braket
id|i
)braket
dot
id|type
)paren
(brace
r_case
id|E820_RAM
suffix:colon
id|printk
c_func
(paren
l_string|&quot;(usable)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E820_RESERVED
suffix:colon
id|printk
c_func
(paren
l_string|&quot;(reserved)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E820_ACPI
suffix:colon
id|printk
c_func
(paren
l_string|&quot;(ACPI data)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E820_NVS
suffix:colon
id|printk
c_func
(paren
l_string|&quot;(ACPI NVS)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;type %lu&bslash;n&quot;
comma
id|e820.map
(braket
id|i
)braket
dot
id|type
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * Copy the BIOS e820 map into a safe place.&n; *&n; * Sanity-check it while we&squot;re at it..&n; *&n; * If we&squot;re lucky and live on a modern system, the setup code&n; * will have given us a memory map that we can use to properly&n; * set up memory.  If we aren&squot;t, we&squot;ll fake a memory map.&n; *&n; * We check to see that the memory map contains at least 2 elements&n; * before we&squot;ll use it, because the detection code in setup.S may&n; * not be perfect and most every PC known to man has two memory&n; * regions: one from 0 to 640k, and one from 1mb up.  (The IBM&n; * thinkpad 560x, for example, does not cooperate with the memory&n; * detection code.)&n; */
DECL|function|copy_e820_map
r_static
r_int
id|__init
id|copy_e820_map
c_func
(paren
r_struct
id|e820entry
op_star
id|biosmap
comma
r_int
id|nr_map
)paren
(brace
multiline_comment|/* Only one memory region (or negative)? Ignore it */
r_if
c_cond
(paren
id|nr_map
OL
l_int|2
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_do
(brace
r_int
r_int
r_int
id|start
op_assign
id|biosmap-&gt;addr
suffix:semicolon
r_int
r_int
r_int
id|size
op_assign
id|biosmap-&gt;size
suffix:semicolon
r_int
r_int
r_int
id|end
op_assign
id|start
op_plus
id|size
suffix:semicolon
r_int
r_int
id|type
op_assign
id|biosmap-&gt;type
suffix:semicolon
multiline_comment|/* Overflow in 64 bits? Ignore the memory map. */
r_if
c_cond
(paren
id|start
OG
id|end
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Some BIOSes claim RAM in the 640k - 1M region.&n;&t;&t; * Not right. Fix it up.&n;&t;&t; */
r_if
c_cond
(paren
id|type
op_eq
id|E820_RAM
)paren
(brace
r_if
c_cond
(paren
id|start
template_param
l_int|0xA0000ULL
)paren
(brace
r_if
c_cond
(paren
id|start
OL
l_int|0xA0000ULL
)paren
id|add_memory_region
c_func
(paren
id|start
comma
l_int|0xA0000ULL
op_minus
id|start
comma
id|type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
op_le
l_int|0x100000ULL
)paren
r_continue
suffix:semicolon
id|start
op_assign
l_int|0x100000ULL
suffix:semicolon
id|size
op_assign
id|end
op_minus
id|start
suffix:semicolon
)brace
)brace
id|add_memory_region
c_func
(paren
id|start
comma
id|size
comma
id|type
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|biosmap
op_increment
comma
op_decrement
id|nr_map
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Do NOT EVER look at the BIOS memory size location.&n; * It does not work on many machines.&n; */
DECL|macro|LOWMEMSIZE
mdefine_line|#define LOWMEMSIZE()&t;(0x9f000)
DECL|function|setup_memory_region
r_void
id|__init
id|setup_memory_region
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|who
op_assign
l_string|&quot;BIOS-e820&quot;
suffix:semicolon
multiline_comment|/*&n;&t; * Try to copy the BIOS-supplied E820-map.&n;&t; *&n;&t; * Otherwise fake a memory map; one section from 0k-&gt;640k,&n;&t; * the next section from 1mb-&gt;appropriate_mem_k&n;&t; */
r_if
c_cond
(paren
id|copy_e820_map
c_func
(paren
id|E820_MAP
comma
id|E820_MAP_NR
)paren
OL
l_int|0
)paren
(brace
r_int
r_int
id|mem_size
suffix:semicolon
multiline_comment|/* compare results from other methods and take the greater */
r_if
c_cond
(paren
id|ALT_MEM_K
OL
id|EXT_MEM_K
)paren
(brace
id|mem_size
op_assign
id|EXT_MEM_K
suffix:semicolon
id|who
op_assign
l_string|&quot;BIOS-88&quot;
suffix:semicolon
)brace
r_else
(brace
id|mem_size
op_assign
id|ALT_MEM_K
suffix:semicolon
id|who
op_assign
l_string|&quot;BIOS-e801&quot;
suffix:semicolon
)brace
id|e820.nr_map
op_assign
l_int|0
suffix:semicolon
id|add_memory_region
c_func
(paren
l_int|0
comma
id|LOWMEMSIZE
c_func
(paren
)paren
comma
id|E820_RAM
)paren
suffix:semicolon
id|add_memory_region
c_func
(paren
id|HIGH_MEMORY
comma
(paren
id|mem_size
op_lshift
l_int|10
)paren
op_minus
id|HIGH_MEMORY
comma
id|E820_RAM
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;BIOS-provided physical RAM map:&bslash;n&quot;
)paren
suffix:semicolon
id|print_memory_map
c_func
(paren
id|who
)paren
suffix:semicolon
)brace
multiline_comment|/* setup_memory_region */
DECL|function|parse_mem_cmdline
r_static
r_inline
r_void
id|parse_mem_cmdline
(paren
r_char
op_star
op_star
id|cmdline_p
)paren
(brace
r_char
id|c
op_assign
l_char|&squot; &squot;
comma
op_star
id|to
op_assign
id|command_line
comma
op_star
id|from
op_assign
id|COMMAND_LINE
suffix:semicolon
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|usermem
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Save unparsed command line copy for /proc/cmdline */
id|memcpy
c_func
(paren
id|saved_command_line
comma
id|COMMAND_LINE
comma
id|COMMAND_LINE_SIZE
)paren
suffix:semicolon
id|saved_command_line
(braket
id|COMMAND_LINE_SIZE
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/*&n;&t;&t; * &quot;mem=nopentium&quot; disables the 4MB page tables.&n;&t;&t; * &quot;mem=XXX[kKmM]&quot; defines a memory region from HIGH_MEM&n;&t;&t; * to &lt;mem&gt;, overriding the bios size.&n;&t;&t; * &quot;mem=XXX[KkmM]@XXX[KkmM]&quot; defines a memory region from&n;&t;&t; * &lt;start&gt; to &lt;start&gt;+&lt;mem&gt;, overriding the bios size.&n;&t;&t; */
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot; &squot;
op_logical_and
op_logical_neg
id|memcmp
c_func
(paren
id|from
comma
l_string|&quot;mem=&quot;
comma
l_int|4
)paren
)paren
(brace
r_if
c_cond
(paren
id|to
op_ne
id|command_line
)paren
id|to
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|from
op_plus
l_int|4
comma
l_string|&quot;nopentium&quot;
comma
l_int|9
)paren
)paren
(brace
id|from
op_add_assign
l_int|9
op_plus
l_int|4
suffix:semicolon
id|clear_bit
c_func
(paren
id|X86_FEATURE_PSE
comma
op_amp
id|boot_cpu_data.x86_capability
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|from
op_plus
l_int|4
comma
l_string|&quot;exactmap&quot;
comma
l_int|8
)paren
)paren
(brace
id|from
op_add_assign
l_int|8
op_plus
l_int|4
suffix:semicolon
id|e820.nr_map
op_assign
l_int|0
suffix:semicolon
id|usermem
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* If the user specifies memory size, we&n;&t;&t;&t;&t; * blow away any automatically generated&n;&t;&t;&t;&t; * size&n;&t;&t;&t;&t; */
r_int
r_int
id|start_at
comma
id|mem_size
suffix:semicolon
r_if
c_cond
(paren
id|usermem
op_eq
l_int|0
)paren
(brace
multiline_comment|/* first time in: zap the whitelist&n;&t;&t;&t;&t;&t; * and reinitialize it with the&n;&t;&t;&t;&t;&t; * standard low-memory region.&n;&t;&t;&t;&t;&t; */
id|e820.nr_map
op_assign
l_int|0
suffix:semicolon
id|usermem
op_assign
l_int|1
suffix:semicolon
id|add_memory_region
c_func
(paren
l_int|0
comma
id|LOWMEMSIZE
c_func
(paren
)paren
comma
id|E820_RAM
)paren
suffix:semicolon
)brace
id|mem_size
op_assign
id|memparse
c_func
(paren
id|from
op_plus
l_int|4
comma
op_amp
id|from
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|from
op_eq
l_char|&squot;@&squot;
)paren
id|start_at
op_assign
id|memparse
c_func
(paren
id|from
op_plus
l_int|1
comma
op_amp
id|from
)paren
suffix:semicolon
r_else
(brace
id|start_at
op_assign
id|HIGH_MEMORY
suffix:semicolon
id|mem_size
op_sub_assign
id|HIGH_MEMORY
suffix:semicolon
id|usermem
op_assign
l_int|0
suffix:semicolon
)brace
id|add_memory_region
c_func
(paren
id|start_at
comma
id|mem_size
comma
id|E820_RAM
)paren
suffix:semicolon
)brace
)brace
id|c
op_assign
op_star
(paren
id|from
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|COMMAND_LINE_SIZE
op_le
op_increment
id|len
)paren
r_break
suffix:semicolon
op_star
(paren
id|to
op_increment
)paren
op_assign
id|c
suffix:semicolon
)brace
op_star
id|to
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
op_star
id|cmdline_p
op_assign
id|command_line
suffix:semicolon
r_if
c_cond
(paren
id|usermem
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;user-defined physical RAM map:&bslash;n&quot;
)paren
suffix:semicolon
id|print_memory_map
c_func
(paren
l_string|&quot;user&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|setup_arch
r_void
id|__init
id|setup_arch
c_func
(paren
r_char
op_star
op_star
id|cmdline_p
)paren
(brace
r_int
r_int
id|bootmap_size
suffix:semicolon
r_int
r_int
id|start_pfn
comma
id|max_pfn
comma
id|max_low_pfn
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef CONFIG_VISWS
id|visws_get_board_type_and_rev
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|ROOT_DEV
op_assign
id|to_kdev_t
c_func
(paren
id|ORIG_ROOT_DEV
)paren
suffix:semicolon
id|drive_info
op_assign
id|DRIVE_INFO
suffix:semicolon
id|screen_info
op_assign
id|SCREEN_INFO
suffix:semicolon
id|apm_info.bios
op_assign
id|APM_BIOS_INFO
suffix:semicolon
r_if
c_cond
(paren
id|SYS_DESC_TABLE.length
op_ne
l_int|0
)paren
(brace
id|MCA_bus
op_assign
id|SYS_DESC_TABLE.table
(braket
l_int|3
)braket
op_amp
l_int|0x2
suffix:semicolon
id|machine_id
op_assign
id|SYS_DESC_TABLE.table
(braket
l_int|0
)braket
suffix:semicolon
id|machine_submodel_id
op_assign
id|SYS_DESC_TABLE.table
(braket
l_int|1
)braket
suffix:semicolon
id|BIOS_revision
op_assign
id|SYS_DESC_TABLE.table
(braket
l_int|2
)braket
suffix:semicolon
)brace
id|aux_device_present
op_assign
id|AUX_DEVICE_INFO
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_RAM
id|rd_image_start
op_assign
id|RAMDISK_FLAGS
op_amp
id|RAMDISK_IMAGE_START_MASK
suffix:semicolon
id|rd_prompt
op_assign
(paren
(paren
id|RAMDISK_FLAGS
op_amp
id|RAMDISK_PROMPT_FLAG
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|rd_doload
op_assign
(paren
(paren
id|RAMDISK_FLAGS
op_amp
id|RAMDISK_LOAD_FLAG
)paren
op_ne
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|setup_memory_region
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MOUNT_ROOT_RDONLY
)paren
id|root_mountflags
op_and_assign
op_complement
id|MS_RDONLY
suffix:semicolon
id|init_mm.start_code
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_text
suffix:semicolon
id|init_mm.end_code
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_etext
suffix:semicolon
id|init_mm.end_data
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_edata
suffix:semicolon
id|init_mm.brk
op_assign
(paren
r_int
r_int
)paren
op_amp
id|_end
suffix:semicolon
id|code_resource.start
op_assign
id|virt_to_bus
c_func
(paren
op_amp
id|_text
)paren
suffix:semicolon
id|code_resource.end
op_assign
id|virt_to_bus
c_func
(paren
op_amp
id|_etext
)paren
op_minus
l_int|1
suffix:semicolon
id|data_resource.start
op_assign
id|virt_to_bus
c_func
(paren
op_amp
id|_etext
)paren
suffix:semicolon
id|data_resource.end
op_assign
id|virt_to_bus
c_func
(paren
op_amp
id|_edata
)paren
op_minus
l_int|1
suffix:semicolon
id|parse_mem_cmdline
c_func
(paren
id|cmdline_p
)paren
suffix:semicolon
DECL|macro|PFN_UP
mdefine_line|#define PFN_UP(x)&t;(((x) + PAGE_SIZE-1) &gt;&gt; PAGE_SHIFT)
DECL|macro|PFN_DOWN
mdefine_line|#define PFN_DOWN(x)&t;((x) &gt;&gt; PAGE_SHIFT)
DECL|macro|PFN_PHYS
mdefine_line|#define PFN_PHYS(x)&t;((x) &lt;&lt; PAGE_SHIFT)
multiline_comment|/*&n; * 128MB for vmalloc and initrd&n; */
DECL|macro|VMALLOC_RESERVE
mdefine_line|#define VMALLOC_RESERVE&t;(unsigned long)(128 &lt;&lt; 20)
DECL|macro|MAXMEM
mdefine_line|#define MAXMEM&t;&t;(unsigned long)(-PAGE_OFFSET-VMALLOC_RESERVE)
DECL|macro|MAXMEM_PFN
mdefine_line|#define MAXMEM_PFN&t;PFN_DOWN(MAXMEM)
DECL|macro|MAX_NONPAE_PFN
mdefine_line|#define MAX_NONPAE_PFN&t;(1 &lt;&lt; 20)
multiline_comment|/*&n;&t; * partially used pages are not usable - thus&n;&t; * we are rounding upwards:&n;&t; */
id|start_pfn
op_assign
id|PFN_UP
c_func
(paren
id|__pa
c_func
(paren
op_amp
id|_end
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Find the highest page frame number we have available&n;&t; */
id|max_pfn
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|e820.nr_map
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|start
comma
id|end
suffix:semicolon
multiline_comment|/* RAM? */
r_if
c_cond
(paren
id|e820.map
(braket
id|i
)braket
dot
id|type
op_ne
id|E820_RAM
)paren
r_continue
suffix:semicolon
id|start
op_assign
id|PFN_UP
c_func
(paren
id|e820.map
(braket
id|i
)braket
dot
id|addr
)paren
suffix:semicolon
id|end
op_assign
id|PFN_DOWN
c_func
(paren
id|e820.map
(braket
id|i
)braket
dot
id|addr
op_plus
id|e820.map
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
op_ge
id|end
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|end
OG
id|max_pfn
)paren
id|max_pfn
op_assign
id|end
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Determine low and high memory ranges:&n;&t; */
id|max_low_pfn
op_assign
id|max_pfn
suffix:semicolon
r_if
c_cond
(paren
id|max_low_pfn
OG
id|MAXMEM_PFN
)paren
(brace
id|max_low_pfn
op_assign
id|MAXMEM_PFN
suffix:semicolon
macro_line|#ifndef CONFIG_HIGHMEM
multiline_comment|/* Maximum memory usable is what is directly addressable */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Warning only %ldMB will be used.&bslash;n&quot;
comma
id|MAXMEM
op_rshift
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_pfn
OG
id|MAX_NONPAE_PFN
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Use a PAE enabled kernel.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Use a HIGHMEM enabled kernel.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else /* !CONFIG_HIGHMEM */
macro_line|#ifndef CONFIG_X86_PAE
r_if
c_cond
(paren
id|max_pfn
OG
id|MAX_NONPAE_PFN
)paren
(brace
id|max_pfn
op_assign
id|MAX_NONPAE_PFN
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Warning only 4GB will be used.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Use a PAE enabled kernel.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* !CONFIG_X86_PAE */
macro_line|#endif /* !CONFIG_HIGHMEM */
)brace
macro_line|#ifdef CONFIG_HIGHMEM
id|highstart_pfn
op_assign
id|highend_pfn
op_assign
id|max_pfn
suffix:semicolon
r_if
c_cond
(paren
id|max_pfn
OG
id|MAXMEM_PFN
)paren
(brace
id|highstart_pfn
op_assign
id|MAXMEM_PFN
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%ldMB HIGHMEM available.&bslash;n&quot;
comma
id|pages_to_mb
c_func
(paren
id|highend_pfn
op_minus
id|highstart_pfn
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Initialize the boot-time allocator (with low memory only):&n;&t; */
id|bootmap_size
op_assign
id|init_bootmem
c_func
(paren
id|start_pfn
comma
id|max_low_pfn
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Register fully available low RAM pages with the bootmem allocator.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|e820.nr_map
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|curr_pfn
comma
id|last_pfn
comma
id|size
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Reserve usable low memory&n;&t;&t; */
r_if
c_cond
(paren
id|e820.map
(braket
id|i
)braket
dot
id|type
op_ne
id|E820_RAM
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We are rounding up the start address of usable memory:&n;&t;&t; */
id|curr_pfn
op_assign
id|PFN_UP
c_func
(paren
id|e820.map
(braket
id|i
)braket
dot
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|curr_pfn
op_ge
id|max_low_pfn
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;&t; * ... and at the end of the usable range downwards:&n;&t;&t; */
id|last_pfn
op_assign
id|PFN_DOWN
c_func
(paren
id|e820.map
(braket
id|i
)braket
dot
id|addr
op_plus
id|e820.map
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|last_pfn
OG
id|max_low_pfn
)paren
id|last_pfn
op_assign
id|max_low_pfn
suffix:semicolon
multiline_comment|/*&n;&t;&t; * .. finally, did all the rounding and playing&n;&t;&t; * around just make the area go away?&n;&t;&t; */
r_if
c_cond
(paren
id|last_pfn
op_le
id|curr_pfn
)paren
r_continue
suffix:semicolon
id|size
op_assign
id|last_pfn
op_minus
id|curr_pfn
suffix:semicolon
id|free_bootmem
c_func
(paren
id|PFN_PHYS
c_func
(paren
id|curr_pfn
)paren
comma
id|PFN_PHYS
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Reserve the bootmem bitmap itself as well. We do this in two&n;&t; * steps (first step was init_bootmem()) because this catches&n;&t; * the (very unlikely) case of us accidentally initializing the&n;&t; * bootmem allocator with an invalid RAM area.&n;&t; */
id|reserve_bootmem
c_func
(paren
id|HIGH_MEMORY
comma
(paren
id|PFN_PHYS
c_func
(paren
id|start_pfn
)paren
op_plus
id|bootmap_size
op_plus
id|PAGE_SIZE
op_minus
l_int|1
)paren
op_minus
(paren
id|HIGH_MEMORY
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * reserve physical page 0 - it&squot;s a special BIOS page on many boxes,&n;&t; * enabling clean reboots, SMP operation, laptop functions.&n;&t; */
id|reserve_bootmem
c_func
(paren
l_int|0
comma
id|PAGE_SIZE
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
multiline_comment|/*&n;&t; * But first pinch a few for the stack/trampoline stuff&n;&t; * FIXME: Don&squot;t need the extra page at 4K, but need to fix&n;&t; * trampoline before removing it. (see the GDT stuff)&n;&t; */
id|reserve_bootmem
c_func
(paren
id|PAGE_SIZE
comma
id|PAGE_SIZE
)paren
suffix:semicolon
id|smp_alloc_memory
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* AP processor realmode stacks in low memory*/
macro_line|#endif
macro_line|#ifdef CONFIG_X86_IO_APIC
multiline_comment|/*&n;&t; * Find and reserve possible boot-time SMP configuration:&n;&t; */
id|find_smp_config
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|paging_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_X86_IO_APIC
multiline_comment|/*&n;&t; * get boot-time SMP configuration:&n;&t; */
r_if
c_cond
(paren
id|smp_found_config
)paren
id|get_smp_config
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_X86_LOCAL_APIC
id|init_apic_mappings
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
id|LOADER_TYPE
op_logical_and
id|INITRD_START
)paren
(brace
r_if
c_cond
(paren
id|INITRD_START
op_plus
id|INITRD_SIZE
op_le
(paren
id|max_low_pfn
op_lshift
id|PAGE_SHIFT
)paren
)paren
(brace
id|reserve_bootmem
c_func
(paren
id|INITRD_START
comma
id|INITRD_SIZE
)paren
suffix:semicolon
id|initrd_start
op_assign
id|INITRD_START
ques
c_cond
id|INITRD_START
op_plus
id|PAGE_OFFSET
suffix:colon
l_int|0
suffix:semicolon
id|initrd_end
op_assign
id|initrd_start
op_plus
id|INITRD_SIZE
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;initrd extends beyond end of memory &quot;
l_string|&quot;(0x%08lx &gt; 0x%08lx)&bslash;ndisabling initrd&bslash;n&quot;
comma
id|INITRD_START
op_plus
id|INITRD_SIZE
comma
id|max_low_pfn
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|initrd_start
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Request address space for all standard RAM and ROM resources&n;&t; * and also for regions reported as reserved by the e820.&n;&t; */
id|probe_roms
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|e820.nr_map
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|resource
op_star
id|res
suffix:semicolon
r_if
c_cond
(paren
id|e820.map
(braket
id|i
)braket
dot
id|addr
op_plus
id|e820.map
(braket
id|i
)braket
dot
id|size
OG
l_int|0x100000000ULL
)paren
r_continue
suffix:semicolon
id|res
op_assign
id|alloc_bootmem_low
c_func
(paren
r_sizeof
(paren
r_struct
id|resource
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|e820.map
(braket
id|i
)braket
dot
id|type
)paren
(brace
r_case
id|E820_RAM
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;System RAM&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E820_ACPI
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;ACPI Tables&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|E820_NVS
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;ACPI Non-volatile Storage&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|res-&gt;name
op_assign
l_string|&quot;reserved&quot;
suffix:semicolon
)brace
id|res-&gt;start
op_assign
id|e820.map
(braket
id|i
)braket
dot
id|addr
suffix:semicolon
id|res-&gt;end
op_assign
id|res-&gt;start
op_plus
id|e820.map
(braket
id|i
)braket
dot
id|size
op_minus
l_int|1
suffix:semicolon
id|res-&gt;flags
op_assign
id|IORESOURCE_MEM
op_or
id|IORESOURCE_BUSY
suffix:semicolon
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
id|res
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e820.map
(braket
id|i
)braket
dot
id|type
op_eq
id|E820_RAM
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  We dont&squot;t know which RAM region contains kernel data,&n;&t;&t;&t; *  so we try it repeatedly and let the resource manager&n;&t;&t;&t; *  test it.&n;&t;&t;&t; */
id|request_resource
c_func
(paren
id|res
comma
op_amp
id|code_resource
)paren
suffix:semicolon
id|request_resource
c_func
(paren
id|res
comma
op_amp
id|data_resource
)paren
suffix:semicolon
)brace
)brace
id|request_resource
c_func
(paren
op_amp
id|iomem_resource
comma
op_amp
id|vram_resource
)paren
suffix:semicolon
multiline_comment|/* request I/O space for devices used on all i[345]86 PCs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|STANDARD_IO_RESOURCES
suffix:semicolon
id|i
op_increment
)paren
id|request_resource
c_func
(paren
op_amp
id|ioport_resource
comma
id|standard_io_resources
op_plus
id|i
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_VT
macro_line|#if defined(CONFIG_VGA_CONSOLE)
id|conswitchp
op_assign
op_amp
id|vga_con
suffix:semicolon
macro_line|#elif defined(CONFIG_DUMMY_CONSOLE)
id|conswitchp
op_assign
op_amp
id|dummy_con
suffix:semicolon
macro_line|#endif
macro_line|#endif
)brace
macro_line|#ifndef CONFIG_X86_TSC
DECL|variable|__initdata
r_static
r_int
id|tsc_disable
id|__initdata
op_assign
l_int|0
suffix:semicolon
DECL|function|tsc_setup
r_static
r_int
id|__init
id|tsc_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|tsc_disable
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;notsc&quot;
comma
id|tsc_setup
)paren
suffix:semicolon
macro_line|#endif
DECL|function|get_model_name
r_static
r_int
id|__init
id|get_model_name
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
(brace
r_int
r_int
op_star
id|v
suffix:semicolon
r_char
op_star
id|p
comma
op_star
id|q
suffix:semicolon
r_if
c_cond
(paren
id|cpuid_eax
c_func
(paren
l_int|0x80000000
)paren
OL
l_int|0x80000004
)paren
r_return
l_int|0
suffix:semicolon
id|v
op_assign
(paren
r_int
r_int
op_star
)paren
id|c-&gt;x86_model_id
suffix:semicolon
id|cpuid
c_func
(paren
l_int|0x80000002
comma
op_amp
id|v
(braket
l_int|0
)braket
comma
op_amp
id|v
(braket
l_int|1
)braket
comma
op_amp
id|v
(braket
l_int|2
)braket
comma
op_amp
id|v
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|cpuid
c_func
(paren
l_int|0x80000003
comma
op_amp
id|v
(braket
l_int|4
)braket
comma
op_amp
id|v
(braket
l_int|5
)braket
comma
op_amp
id|v
(braket
l_int|6
)braket
comma
op_amp
id|v
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|cpuid
c_func
(paren
l_int|0x80000004
comma
op_amp
id|v
(braket
l_int|8
)braket
comma
op_amp
id|v
(braket
l_int|9
)braket
comma
op_amp
id|v
(braket
l_int|10
)braket
comma
op_amp
id|v
(braket
l_int|11
)braket
)paren
suffix:semicolon
id|c-&gt;x86_model_id
(braket
l_int|48
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Intel chips right-justify this string for some dumb reason;&n;&t;   undo that brain damage */
id|p
op_assign
id|q
op_assign
op_amp
id|c-&gt;x86_model_id
(braket
l_int|0
)braket
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
op_eq
l_char|&squot; &squot;
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ne
id|q
)paren
(brace
r_while
c_loop
(paren
op_star
id|p
)paren
op_star
id|q
op_increment
op_assign
op_star
id|p
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|q
op_le
op_amp
id|c-&gt;x86_model_id
(braket
l_int|48
)braket
)paren
op_star
id|q
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* Zero-pad the rest */
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|display_cacheinfo
r_static
r_void
id|__init
id|display_cacheinfo
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
(brace
r_int
r_int
id|n
comma
id|dummy
comma
id|ecx
comma
id|edx
comma
id|l2size
suffix:semicolon
id|n
op_assign
id|cpuid_eax
c_func
(paren
l_int|0x80000000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_ge
l_int|0x80000005
)paren
(brace
id|cpuid
c_func
(paren
l_int|0x80000005
comma
op_amp
id|dummy
comma
op_amp
id|dummy
comma
op_amp
id|ecx
comma
op_amp
id|edx
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU: L1 I Cache: %dK (%d bytes/line), D cache %dK (%d bytes/line)&bslash;n&quot;
comma
id|edx
op_rshift
l_int|24
comma
id|edx
op_amp
l_int|0xFF
comma
id|ecx
op_rshift
l_int|24
comma
id|ecx
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|c-&gt;x86_cache_size
op_assign
(paren
id|ecx
op_rshift
l_int|24
)paren
op_plus
(paren
id|edx
op_rshift
l_int|24
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n
OL
l_int|0x80000006
)paren
multiline_comment|/* Some chips just has a large L1. */
r_return
suffix:semicolon
id|ecx
op_assign
id|cpuid_ecx
c_func
(paren
l_int|0x80000006
)paren
suffix:semicolon
id|l2size
op_assign
id|ecx
op_rshift
l_int|16
suffix:semicolon
multiline_comment|/* AMD errata T13 (order #21922) */
r_if
c_cond
(paren
id|c-&gt;x86_vendor
op_eq
id|X86_VENDOR_AMD
op_logical_and
id|c-&gt;x86
op_eq
l_int|6
op_logical_and
id|c-&gt;x86_model
op_eq
l_int|3
op_logical_and
id|c-&gt;x86_mask
op_eq
l_int|0
)paren
(brace
id|l2size
op_assign
l_int|64
suffix:semicolon
)brace
r_if
c_cond
(paren
id|l2size
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* Again, no L2 cache is possible */
id|c-&gt;x86_cache_size
op_assign
id|l2size
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU: L2 Cache: %dK (%d bytes/line)&bslash;n&quot;
comma
id|l2size
comma
id|ecx
op_amp
l_int|0xFF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;B step AMD K6 before B 9730xxxx have hardware bugs that can cause&n; *&t;misexecution of code under Linux. Owners of such processors should&n; *&t;contact AMD for precise details and a CPU swap.&n; *&n; *&t;See&t;http://www.mygale.com/~poulot/k6bug.html&n; *&t;&t;http://www.amd.com/K6/k6docs/revgd.html&n; *&n; *&t;The following test is erm.. interesting. AMD neglected to up&n; *&t;the chip setting when fixing the bug but they also tweaked some&n; *&t;performance at the same time..&n; */
r_extern
r_void
id|vide
c_func
(paren
r_void
)paren
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;.align 4&bslash;nvide: ret&quot;
)paren
suffix:semicolon
DECL|function|init_amd
r_static
r_int
id|__init
id|init_amd
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
(brace
id|u32
id|l
comma
id|h
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|mbytes
op_assign
id|max_mapnr
op_rshift
(paren
l_int|20
op_minus
id|PAGE_SHIFT
)paren
suffix:semicolon
r_int
id|r
suffix:semicolon
multiline_comment|/* Bit 31 in normal CPUID used for nonstandard 3DNow ID;&n;&t;   3DNow is IDd by bit 31 in extended CPUID (1*32+31) anyway */
id|clear_bit
c_func
(paren
l_int|0
op_star
l_int|32
op_plus
l_int|31
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
id|r
op_assign
id|get_model_name
c_func
(paren
id|c
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c-&gt;x86
)paren
(brace
r_case
l_int|5
suffix:colon
r_if
c_cond
(paren
id|c-&gt;x86_model
OL
l_int|6
)paren
(brace
multiline_comment|/* Based on AMD doc 20734R - June 2000 */
r_if
c_cond
(paren
id|c-&gt;x86_model
op_eq
l_int|0
)paren
(brace
id|clear_bit
c_func
(paren
id|X86_FEATURE_APIC
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|X86_FEATURE_PGE
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c-&gt;x86_model
op_eq
l_int|6
op_logical_and
id|c-&gt;x86_mask
op_eq
l_int|1
)paren
(brace
r_const
r_int
id|K6_BUG_LOOP
op_assign
l_int|1000000
suffix:semicolon
r_int
id|n
suffix:semicolon
r_void
(paren
op_star
id|f_vide
)paren
(paren
r_void
)paren
suffix:semicolon
r_int
r_int
id|d
comma
id|d2
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;AMD K6 stepping B detected - &quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * It looks like AMD fixed the 2.6.2 bug and improved indirect &n;&t;&t;&t;&t; * calls at the same time.&n;&t;&t;&t;&t; */
id|n
op_assign
id|K6_BUG_LOOP
suffix:semicolon
id|f_vide
op_assign
id|vide
suffix:semicolon
id|rdtscl
c_func
(paren
id|d
)paren
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
)paren
id|f_vide
c_func
(paren
)paren
suffix:semicolon
id|rdtscl
c_func
(paren
id|d2
)paren
suffix:semicolon
id|d
op_assign
id|d2
op_minus
id|d
suffix:semicolon
multiline_comment|/* Knock these two lines out if it debugs out ok */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;K6 BUG %ld %d (Report these if test report is incorrect)&bslash;n&quot;
comma
id|d
comma
l_int|20
op_star
id|K6_BUG_LOOP
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;AMD K6 stepping B detected - &quot;
)paren
suffix:semicolon
multiline_comment|/* -- cut here -- */
r_if
c_cond
(paren
id|d
OG
l_int|20
op_star
id|K6_BUG_LOOP
)paren
id|printk
c_func
(paren
l_string|&quot;system stability may be impaired when more than 32 MB are used.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;probably OK (after B9730xxxx).&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Please see http://www.mygale.com/~poulot/k6bug.html&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* K6 with old style WHCR */
r_if
c_cond
(paren
id|c-&gt;x86_model
OL
l_int|8
op_logical_or
(paren
id|c-&gt;x86_model
op_eq
l_int|8
op_logical_and
id|c-&gt;x86_mask
OL
l_int|8
)paren
)paren
(brace
multiline_comment|/* We can only write allocate on the low 508Mb */
r_if
c_cond
(paren
id|mbytes
OG
l_int|508
)paren
(brace
id|mbytes
op_assign
l_int|508
suffix:semicolon
)brace
id|rdmsr
c_func
(paren
l_int|0xC0000082
comma
id|l
comma
id|h
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|l
op_amp
l_int|0x0000FFFF
)paren
op_eq
l_int|0
)paren
(brace
id|l
op_assign
(paren
l_int|1
op_lshift
l_int|0
)paren
op_or
(paren
(paren
id|mbytes
op_div
l_int|4
)paren
op_lshift
l_int|1
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;wbinvd&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|wrmsr
c_func
(paren
l_int|0xC0000082
comma
id|l
comma
id|h
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Enabling old style K6 write allocation for %d Mb&bslash;n&quot;
comma
id|mbytes
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c-&gt;x86_model
op_eq
l_int|8
op_logical_or
id|c-&gt;x86_model
op_eq
l_int|9
op_logical_or
id|c-&gt;x86_model
op_eq
l_int|13
)paren
(brace
multiline_comment|/* The more serious chips .. */
r_if
c_cond
(paren
id|mbytes
OG
l_int|4092
)paren
(brace
id|mbytes
op_assign
l_int|4092
suffix:semicolon
)brace
id|rdmsr
c_func
(paren
l_int|0xC0000082
comma
id|l
comma
id|h
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|l
op_amp
l_int|0xFFFF0000
)paren
op_eq
l_int|0
)paren
(brace
id|l
op_assign
(paren
(paren
id|mbytes
op_rshift
l_int|2
)paren
op_lshift
l_int|22
)paren
op_or
(paren
l_int|1
op_lshift
l_int|16
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;wbinvd&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
id|wrmsr
c_func
(paren
l_int|0xC0000082
comma
id|l
comma
id|h
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Enabling new style K6 write allocation for %d Mb&bslash;n&quot;
comma
id|mbytes
)paren
suffix:semicolon
)brace
multiline_comment|/*  Set MTRR capability flag if appropriate */
r_if
c_cond
(paren
(paren
id|c-&gt;x86_model
op_eq
l_int|13
)paren
op_logical_or
(paren
id|c-&gt;x86_model
op_eq
l_int|9
)paren
op_logical_or
(paren
(paren
id|c-&gt;x86_model
op_eq
l_int|8
)paren
op_logical_and
(paren
id|c-&gt;x86_mask
op_ge
l_int|8
)paren
)paren
)paren
id|set_bit
c_func
(paren
id|X86_FEATURE_K6_MTRR
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* An Athlon/Duron. We can trust the BIOS probably */
r_break
suffix:semicolon
)brace
id|display_cacheinfo
c_func
(paren
id|c
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
multiline_comment|/*&n; * Read Cyrix DEVID registers (DIR) to get more detailed info. about the CPU&n; */
DECL|function|do_cyrix_devid
r_static
r_inline
r_void
id|do_cyrix_devid
c_func
(paren
r_int
r_char
op_star
id|dir0
comma
r_int
r_char
op_star
id|dir1
)paren
(brace
r_int
r_char
id|ccr2
comma
id|ccr3
suffix:semicolon
multiline_comment|/* we test for DEVID by checking whether CCR3 is writable */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ccr3
op_assign
id|getCx86
c_func
(paren
id|CX86_CCR3
)paren
suffix:semicolon
id|setCx86
c_func
(paren
id|CX86_CCR3
comma
id|ccr3
op_xor
l_int|0x80
)paren
suffix:semicolon
id|getCx86
c_func
(paren
l_int|0xc0
)paren
suffix:semicolon
multiline_comment|/* dummy to change bus */
r_if
c_cond
(paren
id|getCx86
c_func
(paren
id|CX86_CCR3
)paren
op_eq
id|ccr3
)paren
(brace
multiline_comment|/* no DEVID regs. */
id|ccr2
op_assign
id|getCx86
c_func
(paren
id|CX86_CCR2
)paren
suffix:semicolon
id|setCx86
c_func
(paren
id|CX86_CCR2
comma
id|ccr2
op_xor
l_int|0x04
)paren
suffix:semicolon
id|getCx86
c_func
(paren
l_int|0xc0
)paren
suffix:semicolon
multiline_comment|/* dummy */
r_if
c_cond
(paren
id|getCx86
c_func
(paren
id|CX86_CCR2
)paren
op_eq
id|ccr2
)paren
multiline_comment|/* old Cx486SLC/DLC */
op_star
id|dir0
op_assign
l_int|0xfd
suffix:semicolon
r_else
(brace
multiline_comment|/* Cx486S A step */
id|setCx86
c_func
(paren
id|CX86_CCR2
comma
id|ccr2
)paren
suffix:semicolon
op_star
id|dir0
op_assign
l_int|0xfe
suffix:semicolon
)brace
)brace
r_else
(brace
id|setCx86
c_func
(paren
id|CX86_CCR3
comma
id|ccr3
)paren
suffix:semicolon
multiline_comment|/* restore CCR3 */
multiline_comment|/* read DIR0 and DIR1 CPU registers */
op_star
id|dir0
op_assign
id|getCx86
c_func
(paren
id|CX86_DIR0
)paren
suffix:semicolon
op_star
id|dir1
op_assign
id|getCx86
c_func
(paren
id|CX86_DIR1
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Cx86_dir0_msb is a HACK needed by check_cx686_cpuid/slop in bugs.h in&n; * order to identify the Cyrix CPU model after we&squot;re out of setup.c&n; */
DECL|variable|__initdata
r_int
r_char
id|Cx86_dir0_msb
id|__initdata
op_assign
l_int|0
suffix:semicolon
DECL|variable|__initdata
r_static
r_char
id|Cx86_model
(braket
)braket
(braket
l_int|9
)braket
id|__initdata
op_assign
(brace
l_string|&quot;Cx486&quot;
comma
l_string|&quot;Cx486&quot;
comma
l_string|&quot;5x86 &quot;
comma
l_string|&quot;6x86&quot;
comma
l_string|&quot;MediaGX &quot;
comma
l_string|&quot;6x86MX &quot;
comma
l_string|&quot;M II &quot;
comma
l_string|&quot;Unknown&quot;
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
r_char
id|Cx486_name
(braket
)braket
(braket
l_int|5
)braket
id|__initdata
op_assign
(brace
l_string|&quot;SLC&quot;
comma
l_string|&quot;DLC&quot;
comma
l_string|&quot;SLC2&quot;
comma
l_string|&quot;DLC2&quot;
comma
l_string|&quot;SRx&quot;
comma
l_string|&quot;DRx&quot;
comma
l_string|&quot;SRx2&quot;
comma
l_string|&quot;DRx2&quot;
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
r_char
id|Cx486S_name
(braket
)braket
(braket
l_int|4
)braket
id|__initdata
op_assign
(brace
l_string|&quot;S&quot;
comma
l_string|&quot;S2&quot;
comma
l_string|&quot;Se&quot;
comma
l_string|&quot;S2e&quot;
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
r_char
id|Cx486D_name
(braket
)braket
(braket
l_int|4
)braket
id|__initdata
op_assign
(brace
l_string|&quot;DX&quot;
comma
l_string|&quot;DX2&quot;
comma
l_string|&quot;?&quot;
comma
l_string|&quot;?&quot;
comma
l_string|&quot;?&quot;
comma
l_string|&quot;DX4&quot;
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
r_char
id|Cx86_cb
(braket
)braket
id|__initdata
op_assign
l_string|&quot;?.5x Core/Bus Clock&quot;
suffix:semicolon
DECL|variable|__initdata
r_static
r_char
id|cyrix_model_mult1
(braket
)braket
id|__initdata
op_assign
l_string|&quot;12??43&quot;
suffix:semicolon
DECL|variable|__initdata
r_static
r_char
id|cyrix_model_mult2
(braket
)braket
id|__initdata
op_assign
l_string|&quot;12233445&quot;
suffix:semicolon
multiline_comment|/*&n; * Reset the slow-loop (SLOP) bit on the 686(L) which is set by some old&n; * BIOSes for compatability with DOS games.  This makes the udelay loop&n; * work correctly, and improves performance.&n; */
r_extern
r_void
id|calibrate_delay
c_func
(paren
r_void
)paren
id|__init
suffix:semicolon
DECL|function|check_cx686_slop
r_static
r_void
id|__init
id|check_cx686_slop
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
(brace
r_if
c_cond
(paren
id|Cx86_dir0_msb
op_eq
l_int|3
)paren
(brace
r_int
r_char
id|ccr3
comma
id|ccr5
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|ccr3
op_assign
id|getCx86
c_func
(paren
id|CX86_CCR3
)paren
suffix:semicolon
id|setCx86
c_func
(paren
id|CX86_CCR3
comma
(paren
id|ccr3
op_amp
l_int|0x0f
)paren
op_or
l_int|0x10
)paren
suffix:semicolon
multiline_comment|/* enable MAPEN  */
id|ccr5
op_assign
id|getCx86
c_func
(paren
id|CX86_CCR5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccr5
op_amp
l_int|2
)paren
id|setCx86
c_func
(paren
id|CX86_CCR5
comma
id|ccr5
op_amp
l_int|0xfd
)paren
suffix:semicolon
multiline_comment|/* reset SLOP */
id|setCx86
c_func
(paren
id|CX86_CCR3
comma
id|ccr3
)paren
suffix:semicolon
multiline_comment|/* disable MAPEN */
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ccr5
op_amp
l_int|2
)paren
(brace
multiline_comment|/* possible wrong calibration done */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Recalibrating delay loop with SLOP bit reset&bslash;n&quot;
)paren
suffix:semicolon
id|calibrate_delay
c_func
(paren
)paren
suffix:semicolon
id|c-&gt;loops_per_jiffy
op_assign
id|loops_per_jiffy
suffix:semicolon
)brace
)brace
)brace
DECL|function|init_cyrix
r_static
r_void
id|__init
id|init_cyrix
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
(brace
r_int
r_char
id|dir0
comma
id|dir0_msn
comma
id|dir0_lsn
comma
id|dir1
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|buf
op_assign
id|c-&gt;x86_model_id
suffix:semicolon
r_const
r_char
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Bit 31 in normal CPUID used for nonstandard 3DNow ID;&n;&t;   3DNow is IDd by bit 31 in extended CPUID (1*32+31) anyway */
id|clear_bit
c_func
(paren
l_int|0
op_star
l_int|32
op_plus
l_int|31
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
multiline_comment|/* Cyrix used bit 24 in extended (AMD) CPUID for Cyrix MMX extensions */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
l_int|1
op_star
l_int|32
op_plus
l_int|24
comma
op_amp
id|c-&gt;x86_capability
)paren
)paren
(brace
id|clear_bit
c_func
(paren
l_int|1
op_star
l_int|32
op_plus
l_int|24
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|X86_FEATURE_CXMMX
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
)brace
id|do_cyrix_devid
c_func
(paren
op_amp
id|dir0
comma
op_amp
id|dir1
)paren
suffix:semicolon
id|check_cx686_slop
c_func
(paren
id|c
)paren
suffix:semicolon
id|Cx86_dir0_msb
op_assign
id|dir0_msn
op_assign
id|dir0
op_rshift
l_int|4
suffix:semicolon
multiline_comment|/* identifies CPU &quot;family&quot;   */
id|dir0_lsn
op_assign
id|dir0
op_amp
l_int|0xf
suffix:semicolon
multiline_comment|/* model or clock multiplier */
multiline_comment|/* common case step number/rev -- exceptions handled below */
id|c-&gt;x86_model
op_assign
(paren
id|dir1
op_rshift
l_int|4
)paren
op_plus
l_int|1
suffix:semicolon
id|c-&gt;x86_mask
op_assign
id|dir1
op_amp
l_int|0xf
suffix:semicolon
multiline_comment|/* Now cook; the original recipe is by Channing Corn, from Cyrix.&n;&t; * We do the same thing for each generation: we work out&n;&t; * the model, multiplier and stepping.  Black magic included,&n;&t; * to make the silicon step/rev numbers match the printed ones.&n;&t; */
r_switch
c_cond
(paren
id|dir0_msn
)paren
(brace
r_int
r_char
id|tmp
suffix:semicolon
r_case
l_int|0
suffix:colon
multiline_comment|/* Cx486SLC/DLC/SRx/DRx */
id|p
op_assign
id|Cx486_name
(braket
id|dir0_lsn
op_amp
l_int|7
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* Cx486S/DX/DX2/DX4 */
id|p
op_assign
(paren
id|dir0_lsn
op_amp
l_int|8
)paren
ques
c_cond
id|Cx486D_name
(braket
id|dir0_lsn
op_amp
l_int|5
)braket
suffix:colon
id|Cx486S_name
(braket
id|dir0_lsn
op_amp
l_int|3
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* 5x86 */
id|Cx86_cb
(braket
l_int|2
)braket
op_assign
id|cyrix_model_mult1
(braket
id|dir0_lsn
op_amp
l_int|5
)braket
suffix:semicolon
id|p
op_assign
id|Cx86_cb
op_plus
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* 6x86/6x86L */
id|Cx86_cb
(braket
l_int|1
)braket
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|Cx86_cb
(braket
l_int|2
)braket
op_assign
id|cyrix_model_mult1
(braket
id|dir0_lsn
op_amp
l_int|5
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dir1
OG
l_int|0x21
)paren
(brace
multiline_comment|/* 686L */
id|Cx86_cb
(braket
l_int|0
)braket
op_assign
l_char|&squot;L&squot;
suffix:semicolon
id|p
op_assign
id|Cx86_cb
suffix:semicolon
(paren
id|c-&gt;x86_model
)paren
op_increment
suffix:semicolon
)brace
r_else
multiline_comment|/* 686 */
id|p
op_assign
id|Cx86_cb
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* Emulate MTRRs using Cyrix&squot;s ARRs. */
id|set_bit
c_func
(paren
id|X86_FEATURE_CYRIX_ARR
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
multiline_comment|/* 6x86&squot;s contain this bug */
id|c-&gt;coma_bug
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* MediaGX/GXm */
multiline_comment|/*&n;&t;&t; *&t;Life sometimes gets weiiiiiiiird if we use this&n;&t;&t; *&t;on the MediaGX. So we turn it off for now. &n;&t;&t; */
macro_line|#ifdef CONFIG_PCI
multiline_comment|/* It isnt really a PCI quirk directly, but the cure is the&n;&t;&t;   same. The MediaGX has deep magic SMM stuff that handles the&n;&t;&t;   SB emulation. It thows away the fifo on disable_dma() which&n;&t;&t;   is wrong and ruins the audio. &n;                   &n;&t;&t;   Bug2: VSA1 has a wrap bug so that using maximum sized DMA &n;&t;&t;   causes bad things. According to NatSemi VSA2 has another&n;&t;&t;   bug to do with &squot;hlt&squot;. I&squot;ve not seen any boards using VSA2&n;&t;&t;   and X doesn&squot;t seem to support it either so who cares 8).&n;&t;&t;   VSA1 we work around however.&n;&t;&t;*/
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Working around Cyrix MediaGX virtual DMA bugs.&bslash;n&quot;
)paren
suffix:semicolon
id|isa_dma_bridge_buggy
op_assign
l_int|2
suffix:semicolon
macro_line|#endif&t;&t;
id|c-&gt;x86_cache_size
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* Yep 16K integrated cache thats it */
multiline_comment|/* GXm supports extended cpuid levels &squot;ala&squot; AMD */
r_if
c_cond
(paren
id|c-&gt;cpuid_level
op_eq
l_int|2
)paren
(brace
id|get_model_name
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/* get CPU marketing name */
id|clear_bit
c_func
(paren
id|X86_FEATURE_TSC
comma
id|c-&gt;x86_capability
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* MediaGX */
id|Cx86_cb
(braket
l_int|2
)braket
op_assign
(paren
id|dir0_lsn
op_amp
l_int|1
)paren
ques
c_cond
l_char|&squot;3&squot;
suffix:colon
l_char|&squot;4&squot;
suffix:semicolon
id|p
op_assign
id|Cx86_cb
op_plus
l_int|2
suffix:semicolon
id|c-&gt;x86_model
op_assign
(paren
id|dir1
op_amp
l_int|0x20
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|2
suffix:semicolon
id|clear_bit
c_func
(paren
id|X86_FEATURE_TSC
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
multiline_comment|/* 6x86MX/M II */
r_if
c_cond
(paren
id|dir1
OG
l_int|7
)paren
id|dir0_msn
op_increment
suffix:semicolon
multiline_comment|/* M II */
r_else
id|c-&gt;coma_bug
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* 6x86MX, it has the bug. */
id|tmp
op_assign
(paren
op_logical_neg
(paren
id|dir0_lsn
op_amp
l_int|7
)paren
op_logical_or
id|dir0_lsn
op_amp
l_int|1
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|0
suffix:semicolon
id|Cx86_cb
(braket
id|tmp
)braket
op_assign
id|cyrix_model_mult2
(braket
id|dir0_lsn
op_amp
l_int|7
)braket
suffix:semicolon
id|p
op_assign
id|Cx86_cb
op_plus
id|tmp
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|dir1
op_amp
l_int|0x0f
)paren
OG
l_int|4
)paren
op_logical_or
(paren
(paren
id|dir1
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
)paren
(paren
id|c-&gt;x86_model
)paren
op_increment
suffix:semicolon
multiline_comment|/* Emulate MTRRs using Cyrix&squot;s ARRs. */
id|set_bit
c_func
(paren
id|X86_FEATURE_CYRIX_ARR
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xf
suffix:colon
multiline_comment|/* Cyrix 486 without DEVID registers */
r_switch
c_cond
(paren
id|dir0_lsn
)paren
(brace
r_case
l_int|0xd
suffix:colon
multiline_comment|/* either a 486SLC or DLC w/o DEVID */
id|dir0_msn
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|Cx486_name
(braket
(paren
id|c-&gt;hard_math
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xe
suffix:colon
multiline_comment|/* a 486S A step */
id|dir0_msn
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|Cx486S_name
(braket
l_int|0
)braket
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* unknown (shouldn&squot;t happen, we know everyone ;-) */
id|dir0_msn
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|buf
comma
id|Cx86_model
(braket
id|dir0_msn
op_amp
l_int|7
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|strcat
c_func
(paren
id|buf
comma
id|p
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|init_centaur
r_static
r_void
id|__init
id|init_centaur
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
(brace
r_enum
(brace
id|ECX8
op_assign
l_int|1
op_lshift
l_int|1
comma
id|EIERRINT
op_assign
l_int|1
op_lshift
l_int|2
comma
id|DPM
op_assign
l_int|1
op_lshift
l_int|3
comma
id|DMCE
op_assign
l_int|1
op_lshift
l_int|4
comma
id|DSTPCLK
op_assign
l_int|1
op_lshift
l_int|5
comma
id|ELINEAR
op_assign
l_int|1
op_lshift
l_int|6
comma
id|DSMC
op_assign
l_int|1
op_lshift
l_int|7
comma
id|DTLOCK
op_assign
l_int|1
op_lshift
l_int|8
comma
id|EDCTLB
op_assign
l_int|1
op_lshift
l_int|8
comma
id|EMMX
op_assign
l_int|1
op_lshift
l_int|9
comma
id|DPDC
op_assign
l_int|1
op_lshift
l_int|11
comma
id|EBRPRED
op_assign
l_int|1
op_lshift
l_int|12
comma
id|DIC
op_assign
l_int|1
op_lshift
l_int|13
comma
id|DDC
op_assign
l_int|1
op_lshift
l_int|14
comma
id|DNA
op_assign
l_int|1
op_lshift
l_int|15
comma
id|ERETSTK
op_assign
l_int|1
op_lshift
l_int|16
comma
id|E2MMX
op_assign
l_int|1
op_lshift
l_int|19
comma
id|EAMD3D
op_assign
l_int|1
op_lshift
l_int|20
comma
)brace
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
id|u32
id|fcr_set
op_assign
l_int|0
suffix:semicolon
id|u32
id|fcr_clr
op_assign
l_int|0
suffix:semicolon
id|u32
id|lo
comma
id|hi
comma
id|newlo
suffix:semicolon
id|u32
id|aa
comma
id|bb
comma
id|cc
comma
id|dd
suffix:semicolon
multiline_comment|/* Bit 31 in normal CPUID used for nonstandard 3DNow ID;&n;&t;   3DNow is IDd by bit 31 in extended CPUID (1*32+31) anyway */
id|clear_bit
c_func
(paren
l_int|0
op_star
l_int|32
op_plus
l_int|31
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|c-&gt;x86
)paren
(brace
r_case
l_int|5
suffix:colon
r_switch
c_cond
(paren
id|c-&gt;x86_model
)paren
(brace
r_case
l_int|4
suffix:colon
id|name
op_assign
l_string|&quot;C6&quot;
suffix:semicolon
id|fcr_set
op_assign
id|ECX8
op_or
id|DSMC
op_or
id|EDCTLB
op_or
id|EMMX
op_or
id|ERETSTK
suffix:semicolon
id|fcr_clr
op_assign
id|DPDC
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Disabling bugged TSC.&bslash;n&quot;
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|X86_FEATURE_TSC
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
r_switch
c_cond
(paren
id|c-&gt;x86_mask
)paren
(brace
r_default
suffix:colon
id|name
op_assign
l_string|&quot;2&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
dot
dot
dot
l_int|9
suffix:colon
id|name
op_assign
l_string|&quot;2A&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10
dot
dot
dot
l_int|15
suffix:colon
id|name
op_assign
l_string|&quot;2B&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|fcr_set
op_assign
id|ECX8
op_or
id|DSMC
op_or
id|DTLOCK
op_or
id|EMMX
op_or
id|EBRPRED
op_or
id|ERETSTK
op_or
id|E2MMX
op_or
id|EAMD3D
suffix:semicolon
id|fcr_clr
op_assign
id|DPDC
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
id|name
op_assign
l_string|&quot;3&quot;
suffix:semicolon
id|fcr_set
op_assign
id|ECX8
op_or
id|DSMC
op_or
id|DTLOCK
op_or
id|EMMX
op_or
id|EBRPRED
op_or
id|ERETSTK
op_or
id|E2MMX
op_or
id|EAMD3D
suffix:semicolon
id|fcr_clr
op_assign
id|DPDC
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10
suffix:colon
id|name
op_assign
l_string|&quot;4&quot;
suffix:semicolon
multiline_comment|/* no info on the WC4 yet */
r_break
suffix:semicolon
r_default
suffix:colon
id|name
op_assign
l_string|&quot;??&quot;
suffix:semicolon
)brace
multiline_comment|/* get FCR  */
id|rdmsr
c_func
(paren
l_int|0x107
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
id|newlo
op_assign
(paren
id|lo
op_or
id|fcr_set
)paren
op_amp
(paren
op_complement
id|fcr_clr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|newlo
op_ne
id|lo
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Centaur FCR was 0x%X now 0x%X&bslash;n&quot;
comma
id|lo
comma
id|newlo
)paren
suffix:semicolon
id|wrmsr
c_func
(paren
l_int|0x107
comma
id|newlo
comma
id|hi
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Centaur FCR is 0x%X&bslash;n&quot;
comma
id|lo
)paren
suffix:semicolon
)brace
multiline_comment|/* Emulate MTRRs using Centaur&squot;s MCR. */
id|set_bit
c_func
(paren
id|X86_FEATURE_CENTAUR_MCR
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
multiline_comment|/* Report CX8 */
id|set_bit
c_func
(paren
id|X86_FEATURE_CX8
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
multiline_comment|/* Set 3DNow! on Winchip 2 and above. */
r_if
c_cond
(paren
id|c-&gt;x86_model
op_ge
l_int|8
)paren
id|set_bit
c_func
(paren
id|X86_FEATURE_3DNOW
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
multiline_comment|/* See if we can find out some more. */
r_if
c_cond
(paren
id|cpuid_eax
c_func
(paren
l_int|0x80000000
)paren
op_ge
l_int|0x80000005
)paren
(brace
multiline_comment|/* Yes, we can. */
id|cpuid
c_func
(paren
l_int|0x80000005
comma
op_amp
id|aa
comma
op_amp
id|bb
comma
op_amp
id|cc
comma
op_amp
id|dd
)paren
suffix:semicolon
multiline_comment|/* Add L1 data and code cache sizes. */
id|c-&gt;x86_cache_size
op_assign
(paren
id|cc
op_rshift
l_int|24
)paren
op_plus
(paren
id|dd
op_rshift
l_int|24
)paren
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|c-&gt;x86_model_id
comma
l_string|&quot;WinChip %s&quot;
comma
id|name
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
r_switch
c_cond
(paren
id|c-&gt;x86_model
)paren
(brace
r_case
l_int|6
suffix:colon
multiline_comment|/* Cyrix III */
id|rdmsr
(paren
l_int|0x1107
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
id|lo
op_or_assign
(paren
l_int|1
op_lshift
l_int|1
op_or
l_int|1
op_lshift
l_int|7
)paren
suffix:semicolon
multiline_comment|/* Report CX8 &amp; enable PGE */
id|wrmsr
(paren
l_int|0x1107
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|X86_FEATURE_CX8
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
id|rdmsr
(paren
l_int|0x80000001
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hi
op_amp
(paren
l_int|1
op_lshift
l_int|31
)paren
)paren
id|set_bit
c_func
(paren
id|X86_FEATURE_3DNOW
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
id|get_model_name
c_func
(paren
id|c
)paren
suffix:semicolon
id|display_cacheinfo
c_func
(paren
id|c
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
DECL|function|init_transmeta
r_static
r_void
id|__init
id|init_transmeta
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
(brace
r_int
r_int
id|cap_mask
comma
id|uk
comma
id|max
comma
id|dummy
suffix:semicolon
r_int
r_int
id|cms_rev1
comma
id|cms_rev2
suffix:semicolon
r_int
r_int
id|cpu_rev
comma
id|cpu_freq
comma
id|cpu_flags
suffix:semicolon
r_char
id|cpu_info
(braket
l_int|65
)braket
suffix:semicolon
id|get_model_name
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/* Same as AMD/Cyrix */
id|display_cacheinfo
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/* Print CMS and CPU revision */
id|max
op_assign
id|cpuid_eax
c_func
(paren
l_int|0x80860000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max
op_ge
l_int|0x80860001
)paren
(brace
id|cpuid
c_func
(paren
l_int|0x80860001
comma
op_amp
id|dummy
comma
op_amp
id|cpu_rev
comma
op_amp
id|cpu_freq
comma
op_amp
id|cpu_flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU: Processor revision %u.%u.%u.%u, %u MHz&bslash;n&quot;
comma
(paren
id|cpu_rev
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
comma
(paren
id|cpu_rev
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
comma
(paren
id|cpu_rev
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|cpu_rev
op_amp
l_int|0xff
comma
id|cpu_freq
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|max
op_ge
l_int|0x80860002
)paren
(brace
id|cpuid
c_func
(paren
l_int|0x80860002
comma
op_amp
id|dummy
comma
op_amp
id|cms_rev1
comma
op_amp
id|cms_rev2
comma
op_amp
id|dummy
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU: Code Morphing Software revision %u.%u.%u-%u-%u&bslash;n&quot;
comma
(paren
id|cms_rev1
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
comma
(paren
id|cms_rev1
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
comma
(paren
id|cms_rev1
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|cms_rev1
op_amp
l_int|0xff
comma
id|cms_rev2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|max
op_ge
l_int|0x80860006
)paren
(brace
id|cpuid
c_func
(paren
l_int|0x80860003
comma
(paren
r_void
op_star
)paren
op_amp
id|cpu_info
(braket
l_int|0
)braket
comma
(paren
r_void
op_star
)paren
op_amp
id|cpu_info
(braket
l_int|4
)braket
comma
(paren
r_void
op_star
)paren
op_amp
id|cpu_info
(braket
l_int|8
)braket
comma
(paren
r_void
op_star
)paren
op_amp
id|cpu_info
(braket
l_int|12
)braket
)paren
suffix:semicolon
id|cpuid
c_func
(paren
l_int|0x80860004
comma
(paren
r_void
op_star
)paren
op_amp
id|cpu_info
(braket
l_int|16
)braket
comma
(paren
r_void
op_star
)paren
op_amp
id|cpu_info
(braket
l_int|20
)braket
comma
(paren
r_void
op_star
)paren
op_amp
id|cpu_info
(braket
l_int|24
)braket
comma
(paren
r_void
op_star
)paren
op_amp
id|cpu_info
(braket
l_int|28
)braket
)paren
suffix:semicolon
id|cpuid
c_func
(paren
l_int|0x80860005
comma
(paren
r_void
op_star
)paren
op_amp
id|cpu_info
(braket
l_int|32
)braket
comma
(paren
r_void
op_star
)paren
op_amp
id|cpu_info
(braket
l_int|36
)braket
comma
(paren
r_void
op_star
)paren
op_amp
id|cpu_info
(braket
l_int|40
)braket
comma
(paren
r_void
op_star
)paren
op_amp
id|cpu_info
(braket
l_int|44
)braket
)paren
suffix:semicolon
id|cpuid
c_func
(paren
l_int|0x80860006
comma
(paren
r_void
op_star
)paren
op_amp
id|cpu_info
(braket
l_int|48
)braket
comma
(paren
r_void
op_star
)paren
op_amp
id|cpu_info
(braket
l_int|52
)braket
comma
(paren
r_void
op_star
)paren
op_amp
id|cpu_info
(braket
l_int|56
)braket
comma
(paren
r_void
op_star
)paren
op_amp
id|cpu_info
(braket
l_int|60
)braket
)paren
suffix:semicolon
id|cpu_info
(braket
l_int|64
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU: %s&bslash;n&quot;
comma
id|cpu_info
)paren
suffix:semicolon
)brace
multiline_comment|/* Unhide possibly hidden capability flags */
id|rdmsr
c_func
(paren
l_int|0x80860004
comma
id|cap_mask
comma
id|uk
)paren
suffix:semicolon
id|wrmsr
c_func
(paren
l_int|0x80860004
comma
op_complement
l_int|0
comma
id|uk
)paren
suffix:semicolon
id|c-&gt;x86_capability
(braket
l_int|0
)braket
op_assign
id|cpuid_edx
c_func
(paren
l_int|0x00000001
)paren
suffix:semicolon
id|wrmsr
c_func
(paren
l_int|0x80860004
comma
id|cap_mask
comma
id|uk
)paren
suffix:semicolon
)brace
r_extern
r_void
id|trap_init_f00f_bug
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|init_intel
r_static
r_void
id|__init
id|init_intel
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
(brace
macro_line|#ifndef CONFIG_M686
r_static
r_int
id|f00f_workaround_enabled
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_extern
r_void
id|mcheck_init
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
suffix:semicolon
r_char
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|l1i
op_assign
l_int|0
comma
id|l1d
op_assign
l_int|0
comma
id|l2
op_assign
l_int|0
comma
id|l3
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Cache sizes */
macro_line|#ifndef CONFIG_M686
multiline_comment|/*&n;&t; * All current models of Pentium and Pentium with MMX technology CPUs&n;&t; * have the F0 0F bug, which lets nonpriviledged users lock up the system.&n;&t; * Note that the workaround only should be initialized once...&n;&t; */
id|c-&gt;f00f_bug
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;x86
op_eq
l_int|5
)paren
(brace
id|c-&gt;f00f_bug
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|f00f_workaround_enabled
)paren
(brace
id|trap_init_f00f_bug
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Intel Pentium with F0 0F bug - workaround enabled.&bslash;n&quot;
)paren
suffix:semicolon
id|f00f_workaround_enabled
op_assign
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|c-&gt;cpuid_level
OG
l_int|1
)paren
(brace
multiline_comment|/* supports eax=2  call */
r_int
id|i
comma
id|j
comma
id|n
suffix:semicolon
r_int
id|regs
(braket
l_int|4
)braket
suffix:semicolon
r_int
r_char
op_star
id|dp
op_assign
(paren
r_int
r_char
op_star
)paren
id|regs
suffix:semicolon
multiline_comment|/* Number of times to iterate */
id|n
op_assign
id|cpuid_eax
c_func
(paren
l_int|2
)paren
op_amp
l_int|0xFF
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cpuid
c_func
(paren
l_int|2
comma
op_amp
id|regs
(braket
l_int|0
)braket
comma
op_amp
id|regs
(braket
l_int|1
)braket
comma
op_amp
id|regs
(braket
l_int|2
)braket
comma
op_amp
id|regs
(braket
l_int|3
)braket
)paren
suffix:semicolon
multiline_comment|/* If bit 31 is set, this is an unknown format */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|3
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|regs
(braket
id|j
)braket
OL
l_int|0
)paren
id|regs
(braket
id|j
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Byte 0 is level count, not a descriptor */
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
OL
l_int|16
suffix:semicolon
id|j
op_increment
)paren
(brace
r_int
r_char
id|des
op_assign
id|dp
(braket
id|j
)braket
suffix:semicolon
r_int
r_char
id|dl
comma
id|dh
suffix:semicolon
r_int
r_int
id|cs
suffix:semicolon
id|dh
op_assign
id|des
op_rshift
l_int|4
suffix:semicolon
id|dl
op_assign
id|des
op_amp
l_int|0x0F
suffix:semicolon
multiline_comment|/* Black magic... */
r_switch
c_cond
(paren
id|dh
)paren
(brace
r_case
l_int|0
suffix:colon
r_switch
c_cond
(paren
id|dl
)paren
(brace
r_case
l_int|6
suffix:colon
multiline_comment|/* L1 I cache */
id|l1i
op_add_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
multiline_comment|/* L1 I cache */
id|l1i
op_add_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10
suffix:colon
multiline_comment|/* L1 D cache */
id|l1d
op_add_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
multiline_comment|/* L1 D cache */
id|l1d
op_add_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
suffix:semicolon
multiline_comment|/* TLB, or unknown */
)brace
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
id|dl
)paren
(brace
multiline_comment|/* L3 cache */
id|cs
op_assign
(paren
id|dl
op_minus
l_int|1
)paren
op_lshift
l_int|9
suffix:semicolon
id|l3
op_add_assign
id|cs
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_if
c_cond
(paren
id|c-&gt;x86
OG
l_int|6
op_logical_and
id|dl
)paren
(brace
multiline_comment|/* P4 family */
r_if
c_cond
(paren
id|dl
)paren
(brace
multiline_comment|/* L3 cache */
id|cs
op_assign
l_int|128
op_lshift
(paren
id|dl
op_minus
l_int|1
)paren
suffix:semicolon
id|l3
op_add_assign
id|cs
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* else same as 8 - fall through */
r_case
l_int|8
suffix:colon
r_if
c_cond
(paren
id|dl
)paren
(brace
multiline_comment|/* L2 cache */
id|cs
op_assign
l_int|128
op_lshift
(paren
id|dl
op_minus
l_int|1
)paren
suffix:semicolon
id|l2
op_add_assign
id|cs
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
r_if
c_cond
(paren
id|dl
OG
l_int|5
)paren
(brace
multiline_comment|/* L1 D cache */
id|cs
op_assign
l_int|8
op_lshift
(paren
id|dl
op_minus
l_int|6
)paren
suffix:semicolon
id|l1d
op_add_assign
id|cs
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
r_if
c_cond
(paren
id|dl
op_ge
l_int|8
)paren
(brace
multiline_comment|/* L2 cache */
id|cs
op_assign
l_int|64
op_lshift
(paren
id|dl
op_minus
l_int|8
)paren
suffix:semicolon
id|l2
op_add_assign
id|cs
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* L0 I cache, count as L1 */
id|cs
op_assign
id|dl
ques
c_cond
(paren
l_int|16
op_lshift
(paren
id|dl
op_minus
l_int|1
)paren
)paren
suffix:colon
l_int|12
suffix:semicolon
id|l1i
op_add_assign
id|cs
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* TLB, or something else we don&squot;t know about */
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|l1i
op_logical_or
id|l1d
)paren
id|printk
c_func
(paren
l_string|&quot;CPU: L1 I cache: %dK, L1 D cache: %dK&bslash;n&quot;
comma
id|l1i
comma
id|l1d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l2
)paren
id|printk
c_func
(paren
l_string|&quot;CPU: L2 cache: %dK&bslash;n&quot;
comma
id|l2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l3
)paren
id|printk
c_func
(paren
l_string|&quot;CPU: L3 cache: %dK&bslash;n&quot;
comma
id|l3
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This assumes the L3 cache is shared; it typically lives in&n;&t;&t; * the northbridge.  The L1 caches are included by the L2&n;&t;&t; * cache, and so should not be included for the purpose of&n;&t;&t; * SMP switching weights.&n;&t;&t; */
id|c-&gt;x86_cache_size
op_assign
id|l2
ques
c_cond
id|l2
suffix:colon
(paren
id|l1i
op_plus
id|l1d
)paren
suffix:semicolon
)brace
multiline_comment|/* SEP CPUID bug: Pentium Pro reports SEP but doesn&squot;t have it */
r_if
c_cond
(paren
id|c-&gt;x86
op_eq
l_int|6
op_logical_and
id|c-&gt;x86_model
OL
l_int|3
op_logical_and
id|c-&gt;x86_mask
OL
l_int|3
)paren
id|clear_bit
c_func
(paren
id|X86_FEATURE_SEP
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
multiline_comment|/* Names for the Pentium II/Celeron processors &n;&t;   detectable only by also checking the cache size.&n;&t;   Dixon is NOT a Celeron. */
r_if
c_cond
(paren
id|c-&gt;x86
op_eq
l_int|6
)paren
(brace
r_switch
c_cond
(paren
id|c-&gt;x86_model
)paren
(brace
r_case
l_int|5
suffix:colon
r_if
c_cond
(paren
id|l2
op_eq
l_int|0
)paren
id|p
op_assign
l_string|&quot;Celeron (Covington)&quot;
suffix:semicolon
r_if
c_cond
(paren
id|l2
op_eq
l_int|256
)paren
id|p
op_assign
l_string|&quot;Mobile Pentium II (Dixon)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
r_if
c_cond
(paren
id|l2
op_eq
l_int|128
)paren
id|p
op_assign
l_string|&quot;Celeron (Mendocino)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
r_if
c_cond
(paren
id|l2
op_eq
l_int|128
)paren
id|p
op_assign
l_string|&quot;Celeron (Coppermine)&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|p
)paren
id|strcpy
c_func
(paren
id|c-&gt;x86_model_id
comma
id|p
)paren
suffix:semicolon
multiline_comment|/* Enable MCA if available */
id|mcheck_init
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
DECL|function|get_cpu_vendor
r_void
id|__init
id|get_cpu_vendor
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
(brace
r_char
op_star
id|v
op_assign
id|c-&gt;x86_vendor_id
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|v
comma
l_string|&quot;GenuineIntel&quot;
)paren
)paren
id|c-&gt;x86_vendor
op_assign
id|X86_VENDOR_INTEL
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|v
comma
l_string|&quot;AuthenticAMD&quot;
)paren
)paren
id|c-&gt;x86_vendor
op_assign
id|X86_VENDOR_AMD
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|v
comma
l_string|&quot;CyrixInstead&quot;
)paren
)paren
id|c-&gt;x86_vendor
op_assign
id|X86_VENDOR_CYRIX
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|v
comma
l_string|&quot;UMC UMC UMC &quot;
)paren
)paren
id|c-&gt;x86_vendor
op_assign
id|X86_VENDOR_UMC
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|v
comma
l_string|&quot;CentaurHauls&quot;
)paren
)paren
id|c-&gt;x86_vendor
op_assign
id|X86_VENDOR_CENTAUR
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|v
comma
l_string|&quot;NexGenDriven&quot;
)paren
)paren
id|c-&gt;x86_vendor
op_assign
id|X86_VENDOR_NEXGEN
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|v
comma
l_string|&quot;RiseRiseRise&quot;
)paren
)paren
id|c-&gt;x86_vendor
op_assign
id|X86_VENDOR_RISE
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|v
comma
l_string|&quot;GenuineTMx86&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|v
comma
l_string|&quot;TransmetaCPU&quot;
)paren
)paren
id|c-&gt;x86_vendor
op_assign
id|X86_VENDOR_TRANSMETA
suffix:semicolon
r_else
id|c-&gt;x86_vendor
op_assign
id|X86_VENDOR_UNKNOWN
suffix:semicolon
)brace
DECL|struct|cpu_model_info
r_struct
id|cpu_model_info
(brace
DECL|member|vendor
r_int
id|vendor
suffix:semicolon
DECL|member|family
r_int
id|family
suffix:semicolon
DECL|member|model_names
r_char
op_star
id|model_names
(braket
l_int|16
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Naming convention should be: &lt;Name&gt; [(&lt;Codename&gt;)] */
multiline_comment|/* This table only is used unless init_&lt;vendor&gt;() below doesn&squot;t set it; */
multiline_comment|/* in particular, if CPUID levels 0x80000002..4 are supported, this isn&squot;t used */
DECL|variable|__initdata
r_static
r_struct
id|cpu_model_info
id|cpu_models
(braket
)braket
id|__initdata
op_assign
(brace
(brace
id|X86_VENDOR_INTEL
comma
l_int|4
comma
(brace
l_string|&quot;486 DX-25/33&quot;
comma
l_string|&quot;486 DX-50&quot;
comma
l_string|&quot;486 SX&quot;
comma
l_string|&quot;486 DX/2&quot;
comma
l_string|&quot;486 SL&quot;
comma
l_string|&quot;486 SX/2&quot;
comma
l_int|NULL
comma
l_string|&quot;486 DX/2-WB&quot;
comma
l_string|&quot;486 DX/4&quot;
comma
l_string|&quot;486 DX/4-WB&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
comma
(brace
id|X86_VENDOR_INTEL
comma
l_int|5
comma
(brace
l_string|&quot;Pentium 60/66 A-step&quot;
comma
l_string|&quot;Pentium 60/66&quot;
comma
l_string|&quot;Pentium 75 - 200&quot;
comma
l_string|&quot;OverDrive PODP5V83&quot;
comma
l_string|&quot;Pentium MMX&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;Mobile Pentium 75 - 200&quot;
comma
l_string|&quot;Mobile Pentium MMX&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
comma
(brace
id|X86_VENDOR_INTEL
comma
l_int|6
comma
(brace
l_string|&quot;Pentium Pro A-step&quot;
comma
l_string|&quot;Pentium Pro&quot;
comma
l_int|NULL
comma
l_string|&quot;Pentium II (Klamath)&quot;
comma
l_int|NULL
comma
l_string|&quot;Pentium II (Deschutes)&quot;
comma
l_string|&quot;Mobile Pentium II&quot;
comma
l_string|&quot;Pentium III (Katmai)&quot;
comma
l_string|&quot;Pentium III (Coppermine)&quot;
comma
l_int|NULL
comma
l_string|&quot;Pentium III (Cascades)&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
comma
(brace
id|X86_VENDOR_AMD
comma
l_int|4
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;486 DX/2&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;486 DX/2-WB&quot;
comma
l_string|&quot;486 DX/4&quot;
comma
l_string|&quot;486 DX/4-WB&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;Am5x86-WT&quot;
comma
l_string|&quot;Am5x86-WB&quot;
)brace
)brace
comma
(brace
id|X86_VENDOR_AMD
comma
l_int|5
comma
multiline_comment|/* Is this this really necessary?? */
(brace
l_string|&quot;K5/SSA5&quot;
comma
l_string|&quot;K5&quot;
comma
l_string|&quot;K5&quot;
comma
l_string|&quot;K5&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;K6&quot;
comma
l_string|&quot;K6&quot;
comma
l_string|&quot;K6-2&quot;
comma
l_string|&quot;K6-3&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
comma
(brace
id|X86_VENDOR_AMD
comma
l_int|6
comma
multiline_comment|/* Is this this really necessary?? */
(brace
l_string|&quot;Athlon&quot;
comma
l_string|&quot;Athlon&quot;
comma
l_string|&quot;Athlon&quot;
comma
l_int|NULL
comma
l_string|&quot;Athlon&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
comma
(brace
id|X86_VENDOR_UMC
comma
l_int|4
comma
(brace
l_int|NULL
comma
l_string|&quot;U5D&quot;
comma
l_string|&quot;U5S&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
comma
(brace
id|X86_VENDOR_NEXGEN
comma
l_int|5
comma
(brace
l_string|&quot;Nx586&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
comma
(brace
id|X86_VENDOR_RISE
comma
l_int|5
comma
(brace
l_string|&quot;mP6&quot;
comma
l_string|&quot;mP6&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
)brace
comma
)brace
suffix:semicolon
multiline_comment|/* Look up CPU names by table lookup. */
DECL|function|table_lookup_model
r_static
r_char
id|__init
op_star
id|table_lookup_model
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
(brace
r_struct
id|cpu_model_info
op_star
id|info
op_assign
id|cpu_models
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;x86_model
op_ge
l_int|16
)paren
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Range check */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|cpu_models
)paren
op_div
r_sizeof
(paren
r_struct
id|cpu_model_info
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;vendor
op_eq
id|c-&gt;x86_vendor
op_logical_and
id|info-&gt;family
op_eq
id|c-&gt;x86
)paren
(brace
r_return
id|info-&gt;model_names
(braket
id|c-&gt;x86_model
)braket
suffix:semicolon
)brace
id|info
op_increment
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* Not found */
)brace
multiline_comment|/*&n; *&t;Detect a NexGen CPU running without BIOS hypercode new enough&n; *&t;to have CPUID. (Thanks to Herbert Oppmann)&n; */
DECL|function|deep_magic_nexgen_probe
r_static
r_int
id|__init
id|deep_magic_nexgen_probe
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
id|__asm__
id|__volatile__
(paren
l_string|&quot;&t;movw&t;$0x5555, %%ax&bslash;n&quot;
l_string|&quot;&t;xorw&t;%%dx,%%dx&bslash;n&quot;
l_string|&quot;&t;movw&t;$2, %%cx&bslash;n&quot;
l_string|&quot;&t;divw&t;%%cx&bslash;n&quot;
l_string|&quot;&t;movl&t;$0, %%eax&bslash;n&quot;
l_string|&quot;&t;jnz&t;1f&bslash;n&quot;
l_string|&quot;&t;movl&t;$1, %%eax&bslash;n&quot;
l_string|&quot;1:&bslash;n&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|ret
)paren
suffix:colon
suffix:colon
l_string|&quot;cx&quot;
comma
l_string|&quot;dx&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|squash_the_stupid_serial_number
r_static
r_void
id|__init
id|squash_the_stupid_serial_number
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|X86_FEATURE_PN
comma
op_amp
id|c-&gt;x86_capability
)paren
op_logical_and
id|disable_x86_serial_nr
)paren
(brace
multiline_comment|/* Disable processor serial number */
r_int
r_int
id|lo
comma
id|hi
suffix:semicolon
id|rdmsr
c_func
(paren
l_int|0x119
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
id|lo
op_or_assign
l_int|0x200000
suffix:semicolon
id|wrmsr
c_func
(paren
l_int|0x119
comma
id|lo
comma
id|hi
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;CPU serial number disabled.&bslash;n&quot;
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|X86_FEATURE_PN
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
)brace
)brace
DECL|function|x86_serial_nr_setup
r_int
id|__init
id|x86_serial_nr_setup
c_func
(paren
r_char
op_star
id|s
)paren
(brace
id|disable_x86_serial_nr
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;serialnumber&quot;
comma
id|x86_serial_nr_setup
)paren
suffix:semicolon
multiline_comment|/* Standard macro to see if a specific flag is changeable */
DECL|function|flag_is_changeable_p
r_static
r_inline
r_int
id|flag_is_changeable_p
c_func
(paren
id|u32
id|flag
)paren
(brace
id|u32
id|f1
comma
id|f2
suffix:semicolon
id|asm
c_func
(paren
l_string|&quot;pushfl&bslash;n&bslash;t&quot;
l_string|&quot;pushfl&bslash;n&bslash;t&quot;
l_string|&quot;popl %0&bslash;n&bslash;t&quot;
l_string|&quot;movl %0,%1&bslash;n&bslash;t&quot;
l_string|&quot;xorl %2,%0&bslash;n&bslash;t&quot;
l_string|&quot;pushl %0&bslash;n&bslash;t&quot;
l_string|&quot;popfl&bslash;n&bslash;t&quot;
l_string|&quot;pushfl&bslash;n&bslash;t&quot;
l_string|&quot;popl %0&bslash;n&bslash;t&quot;
l_string|&quot;popfl&bslash;n&bslash;t&quot;
suffix:colon
l_string|&quot;=&amp;r&quot;
(paren
id|f1
)paren
comma
l_string|&quot;=&amp;r&quot;
(paren
id|f2
)paren
suffix:colon
l_string|&quot;ir&quot;
(paren
id|flag
)paren
)paren
suffix:semicolon
r_return
(paren
(paren
id|f1
op_xor
id|f2
)paren
op_amp
id|flag
)paren
op_ne
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Probe for the CPUID instruction */
DECL|function|have_cpuid_p
r_static
r_int
id|__init
id|have_cpuid_p
c_func
(paren
r_void
)paren
(brace
r_return
id|flag_is_changeable_p
c_func
(paren
id|X86_EFLAGS_ID
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Cyrix CPUs without cpuid or with cpuid not yet enabled can be detected&n; * by the fact that they preserve the flags across the division of 5/2.&n; * PII and PPro exhibit this behavior too, but they have cpuid available.&n; */
multiline_comment|/*&n; * Perform the Cyrix 5/2 test. A Cyrix won&squot;t change&n; * the flags, while other 486 chips will.&n; */
DECL|function|test_cyrix_52div
r_static
r_inline
r_int
id|test_cyrix_52div
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|test
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;sahf&bslash;n&bslash;t&quot;
multiline_comment|/* clear flags (%eax = 0x0005) */
l_string|&quot;div %b2&bslash;n&bslash;t&quot;
multiline_comment|/* divide 5 by 2 */
l_string|&quot;lahf&quot;
multiline_comment|/* store flags into %ah */
suffix:colon
l_string|&quot;=a&quot;
(paren
id|test
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
l_int|5
)paren
comma
l_string|&quot;q&quot;
(paren
l_int|2
)paren
suffix:colon
l_string|&quot;cc&quot;
)paren
suffix:semicolon
multiline_comment|/* AH is 0x02 on Cyrix after the divide.. */
r_return
(paren
r_int
r_char
)paren
(paren
id|test
op_rshift
l_int|8
)paren
op_eq
l_int|0x02
suffix:semicolon
)brace
multiline_comment|/* Try to detect a CPU with disabled CPUID, and if so, enable.  This routine&n;   may also be used to detect non-CPUID processors and fill in some of&n;   the information manually. */
DECL|function|id_and_try_enable_cpuid
r_static
r_int
id|__init
id|id_and_try_enable_cpuid
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
(brace
multiline_comment|/* First of all, decide if this is a 486 or higher */
multiline_comment|/* It&squot;s a 486 if we can modify the AC flag */
r_if
c_cond
(paren
id|flag_is_changeable_p
c_func
(paren
id|X86_EFLAGS_AC
)paren
)paren
id|c-&gt;x86
op_assign
l_int|4
suffix:semicolon
r_else
id|c-&gt;x86
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* Detect Cyrix with disabled CPUID */
r_if
c_cond
(paren
id|c-&gt;x86
op_eq
l_int|4
op_logical_and
id|test_cyrix_52div
c_func
(paren
)paren
)paren
(brace
id|strcpy
c_func
(paren
id|c-&gt;x86_vendor_id
comma
l_string|&quot;CyrixInstead&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Detect NexGen with old hypercode */
r_if
c_cond
(paren
id|deep_magic_nexgen_probe
c_func
(paren
)paren
)paren
(brace
id|strcpy
c_func
(paren
id|c-&gt;x86_vendor_id
comma
l_string|&quot;NexGenDriven&quot;
)paren
suffix:semicolon
)brace
r_return
id|have_cpuid_p
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Check to see if CPUID now enabled? */
)brace
multiline_comment|/*&n; * This does the hard work of actually picking apart the CPU stuff...&n; */
DECL|function|identify_cpu
r_void
id|__init
id|identify_cpu
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
(brace
r_int
id|junk
comma
id|i
suffix:semicolon
id|u32
id|xlvl
comma
id|tfms
suffix:semicolon
id|c-&gt;loops_per_jiffy
op_assign
id|loops_per_jiffy
suffix:semicolon
id|c-&gt;x86_cache_size
op_assign
op_minus
l_int|1
suffix:semicolon
id|c-&gt;x86_vendor
op_assign
id|X86_VENDOR_UNKNOWN
suffix:semicolon
id|c-&gt;cpuid_level
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* CPUID not detected */
id|c-&gt;x86_model
op_assign
id|c-&gt;x86_mask
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* So far unknown... */
id|c-&gt;x86_vendor_id
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* Unset */
id|c-&gt;x86_model_id
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
multiline_comment|/* Unset */
id|memset
c_func
(paren
op_amp
id|c-&gt;x86_capability
comma
l_int|0
comma
r_sizeof
id|c-&gt;x86_capability
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|have_cpuid_p
c_func
(paren
)paren
op_logical_and
op_logical_neg
id|id_and_try_enable_cpuid
c_func
(paren
id|c
)paren
)paren
(brace
multiline_comment|/* CPU doesn&squot;t have CPUID */
multiline_comment|/* If there are any capabilities, they&squot;re vendor-specific */
multiline_comment|/* enable_cpuid() would have set c-&gt;x86 for us. */
)brace
r_else
(brace
multiline_comment|/* CPU does have CPUID */
multiline_comment|/* Get vendor name */
id|cpuid
c_func
(paren
l_int|0x00000000
comma
op_amp
id|c-&gt;cpuid_level
comma
(paren
r_int
op_star
)paren
op_amp
id|c-&gt;x86_vendor_id
(braket
l_int|0
)braket
comma
(paren
r_int
op_star
)paren
op_amp
id|c-&gt;x86_vendor_id
(braket
l_int|8
)braket
comma
(paren
r_int
op_star
)paren
op_amp
id|c-&gt;x86_vendor_id
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|get_cpu_vendor
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/* Initialize the standard set of capabilities */
multiline_comment|/* Note that the vendor-specific code below might override */
multiline_comment|/* Intel-defined flags: level 0x00000001 */
r_if
c_cond
(paren
id|c-&gt;cpuid_level
op_ge
l_int|0x00000001
)paren
(brace
id|cpuid
c_func
(paren
l_int|0x00000001
comma
op_amp
id|tfms
comma
op_amp
id|junk
comma
op_amp
id|junk
comma
op_amp
id|c-&gt;x86_capability
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|c-&gt;x86
op_assign
(paren
id|tfms
op_rshift
l_int|8
)paren
op_amp
l_int|15
suffix:semicolon
id|c-&gt;x86_model
op_assign
(paren
id|tfms
op_rshift
l_int|4
)paren
op_amp
l_int|15
suffix:semicolon
id|c-&gt;x86_mask
op_assign
id|tfms
op_amp
l_int|15
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Have CPUID level 0 only - unheard of */
id|c-&gt;x86
op_assign
l_int|4
suffix:semicolon
)brace
multiline_comment|/* AMD-defined flags: level 0x80000001 */
id|xlvl
op_assign
id|cpuid_eax
c_func
(paren
l_int|0x80000000
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xlvl
op_amp
l_int|0xffff0000
)paren
op_eq
l_int|0x80000000
)paren
(brace
r_if
c_cond
(paren
id|xlvl
op_ge
l_int|0x80000001
)paren
id|c-&gt;x86_capability
(braket
l_int|1
)braket
op_assign
id|cpuid_edx
c_func
(paren
l_int|0x80000001
)paren
suffix:semicolon
r_if
c_cond
(paren
id|xlvl
op_ge
l_int|0x80000004
)paren
id|get_model_name
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/* Default name */
)brace
multiline_comment|/* Transmeta-defined flags: level 0x80860001 */
id|xlvl
op_assign
id|cpuid_eax
c_func
(paren
l_int|0x80860000
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xlvl
op_amp
l_int|0xffff0000
)paren
op_eq
l_int|0x80860000
)paren
(brace
r_if
c_cond
(paren
id|xlvl
op_ge
l_int|0x80860001
)paren
id|c-&gt;x86_capability
(braket
l_int|2
)braket
op_assign
id|cpuid_edx
c_func
(paren
l_int|0x80860001
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;CPU: Before vendor init, caps: %08x %08x %08x, vendor = %d&bslash;n&quot;
comma
id|c-&gt;x86_capability
(braket
l_int|0
)braket
comma
id|c-&gt;x86_capability
(braket
l_int|1
)braket
comma
id|c-&gt;x86_capability
(braket
l_int|2
)braket
comma
id|c-&gt;x86_vendor
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Vendor-specific initialization.  In this section we&n;&t; * canonicalize the feature flags, meaning if there are&n;&t; * features a certain CPU supports which CPUID doesn&squot;t&n;&t; * tell us, CPUID claiming incorrect flags, or other bugs,&n;&t; * we handle them here.&n;&t; *&n;&t; * At the end of this section, c-&gt;x86_capability better&n;&t; * indicate the features this CPU genuinely supports!&n;&t; */
r_switch
c_cond
(paren
id|c-&gt;x86_vendor
)paren
(brace
r_case
id|X86_VENDOR_UNKNOWN
suffix:colon
r_default
suffix:colon
multiline_comment|/* Not much we can do here... */
r_break
suffix:semicolon
r_case
id|X86_VENDOR_CYRIX
suffix:colon
id|init_cyrix
c_func
(paren
id|c
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|X86_VENDOR_AMD
suffix:colon
id|init_amd
c_func
(paren
id|c
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|X86_VENDOR_CENTAUR
suffix:colon
id|init_centaur
c_func
(paren
id|c
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|X86_VENDOR_INTEL
suffix:colon
id|init_intel
c_func
(paren
id|c
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|X86_VENDOR_NEXGEN
suffix:colon
id|c-&gt;x86_cache_size
op_assign
l_int|256
suffix:semicolon
multiline_comment|/* A few had 1 MB... */
r_break
suffix:semicolon
r_case
id|X86_VENDOR_TRANSMETA
suffix:colon
id|init_transmeta
c_func
(paren
id|c
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;CPU: After vendor init, caps: %08x %08x %08x %08x&bslash;n&quot;
comma
id|c-&gt;x86_capability
(braket
l_int|0
)braket
comma
id|c-&gt;x86_capability
(braket
l_int|1
)braket
comma
id|c-&gt;x86_capability
(braket
l_int|2
)braket
comma
id|c-&gt;x86_capability
(braket
l_int|3
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The vendor-specific functions might have changed features.  Now&n;&t; * we do &quot;generic changes.&quot;&n;&t; */
multiline_comment|/* TSC disabled? */
macro_line|#ifdef CONFIG_TSC
r_if
c_cond
(paren
id|tsc_disable
)paren
id|clear_bit
c_func
(paren
id|X86_FEATURE_TSC
comma
op_amp
id|c-&gt;x86_capability
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Disable the PN if appropriate */
id|squash_the_stupid_serial_number
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/* If the model name is still unset, do table lookup. */
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;x86_model_id
(braket
l_int|0
)braket
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
id|p
op_assign
id|table_lookup_model
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|strcpy
c_func
(paren
id|c-&gt;x86_model_id
comma
id|p
)paren
suffix:semicolon
r_else
multiline_comment|/* Last resort... */
id|sprintf
c_func
(paren
id|c-&gt;x86_model_id
comma
l_string|&quot;%02x/%02x&quot;
comma
id|c-&gt;x86_vendor
comma
id|c-&gt;x86_model
)paren
suffix:semicolon
)brace
multiline_comment|/* Now the feature flags better reflect actual CPU features! */
id|printk
c_func
(paren
l_string|&quot;CPU: After generic, caps: %08x %08x %08x %08x&bslash;n&quot;
comma
id|c-&gt;x86_capability
(braket
l_int|0
)braket
comma
id|c-&gt;x86_capability
(braket
l_int|1
)braket
comma
id|c-&gt;x86_capability
(braket
l_int|2
)braket
comma
id|c-&gt;x86_capability
(braket
l_int|3
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * On SMP, boot_cpu_data holds the common feature set between&n;&t; * all CPUs; so make sure that we indicate which features are&n;&t; * common between the CPUs.  The first time this routine gets&n;&t; * executed, c == &amp;boot_cpu_data.&n;&t; */
r_if
c_cond
(paren
id|c
op_ne
op_amp
id|boot_cpu_data
)paren
(brace
multiline_comment|/* AND the already accumulated flags with these */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NCAPINTS
suffix:semicolon
id|i
op_increment
)paren
id|boot_cpu_data.x86_capability
(braket
id|i
)braket
op_and_assign
id|c-&gt;x86_capability
(braket
id|i
)braket
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;CPU: Common caps: %08x %08x %08x %08x&bslash;n&quot;
comma
id|boot_cpu_data.x86_capability
(braket
l_int|0
)braket
comma
id|boot_cpu_data.x86_capability
(braket
l_int|1
)braket
comma
id|boot_cpu_data.x86_capability
(braket
l_int|2
)braket
comma
id|boot_cpu_data.x86_capability
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Perform early boot up checks for a valid TSC. See arch/i386/kernel/time.c&n; */
DECL|function|dodgy_tsc
r_void
id|__init
id|dodgy_tsc
c_func
(paren
r_void
)paren
(brace
id|get_cpu_vendor
c_func
(paren
op_amp
id|boot_cpu_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|boot_cpu_data.x86_vendor
op_eq
id|X86_VENDOR_CYRIX
)paren
id|init_cyrix
c_func
(paren
op_amp
id|boot_cpu_data
)paren
suffix:semicolon
)brace
multiline_comment|/* These need to match &lt;asm/processor.h&gt; */
DECL|variable|__initdata
r_static
r_char
op_star
id|cpu_vendor_names
(braket
)braket
id|__initdata
op_assign
(brace
l_string|&quot;Intel&quot;
comma
l_string|&quot;Cyrix&quot;
comma
l_string|&quot;AMD&quot;
comma
l_string|&quot;UMC&quot;
comma
l_string|&quot;NexGen&quot;
comma
l_string|&quot;Centaur&quot;
comma
l_string|&quot;Rise&quot;
comma
l_string|&quot;Transmeta&quot;
)brace
suffix:semicolon
DECL|function|print_cpu_info
r_void
id|__init
id|print_cpu_info
c_func
(paren
r_struct
id|cpuinfo_x86
op_star
id|c
)paren
(brace
r_char
op_star
id|vendor
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;x86_vendor
OL
r_sizeof
(paren
id|cpu_vendor_names
)paren
op_div
r_sizeof
(paren
r_char
op_star
)paren
)paren
id|vendor
op_assign
id|cpu_vendor_names
(braket
id|c-&gt;x86_vendor
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c-&gt;cpuid_level
op_ge
l_int|0
)paren
id|vendor
op_assign
id|c-&gt;x86_vendor_id
suffix:semicolon
r_if
c_cond
(paren
id|vendor
op_logical_and
id|strncmp
c_func
(paren
id|c-&gt;x86_model_id
comma
id|vendor
comma
id|strlen
c_func
(paren
id|vendor
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;%s &quot;
comma
id|vendor
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;x86_model_id
(braket
l_int|0
)braket
)paren
id|printk
c_func
(paren
l_string|&quot;%d86&quot;
comma
id|c-&gt;x86
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%s&quot;
comma
id|c-&gt;x86_model_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;x86_mask
op_logical_or
id|c-&gt;cpuid_level
op_ge
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot; stepping %02x&bslash;n&quot;
comma
id|c-&gt;x86_mask
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Get CPU information for use by the procfs.&n; */
DECL|function|get_cpuinfo
r_int
id|get_cpuinfo
c_func
(paren
r_char
op_star
id|buffer
)paren
(brace
r_char
op_star
id|p
op_assign
id|buffer
suffix:semicolon
multiline_comment|/* &n;&t; * These flag bits must match the definitions in &lt;asm/cpufeature.h&gt;.&n;&t; * NULL means this bit is undefined or reserved; either way it doesn&squot;t&n;&t; * have meaning as far as Linux is concerned.  Note that it&squot;s important&n;&t; * to realize there is a difference between this table and CPUID -- if&n;&t; * applications want to get the raw CPUID data, they should access&n;&t; * /dev/cpu/&lt;cpu_nr&gt;/cpuid instead.&n;&t; */
r_static
r_char
op_star
id|x86_cap_flags
(braket
)braket
op_assign
(brace
multiline_comment|/* Intel-defined */
l_string|&quot;fpu&quot;
comma
l_string|&quot;vme&quot;
comma
l_string|&quot;de&quot;
comma
l_string|&quot;pse&quot;
comma
l_string|&quot;tsc&quot;
comma
l_string|&quot;msr&quot;
comma
l_string|&quot;pae&quot;
comma
l_string|&quot;mce&quot;
comma
l_string|&quot;cx8&quot;
comma
l_string|&quot;apic&quot;
comma
l_int|NULL
comma
l_string|&quot;sep&quot;
comma
l_string|&quot;mtrr&quot;
comma
l_string|&quot;pge&quot;
comma
l_string|&quot;mca&quot;
comma
l_string|&quot;cmov&quot;
comma
l_string|&quot;pat&quot;
comma
l_string|&quot;pse36&quot;
comma
l_string|&quot;pn&quot;
comma
l_string|&quot;clflush&quot;
comma
l_int|NULL
comma
l_string|&quot;dts&quot;
comma
l_string|&quot;acpi&quot;
comma
l_string|&quot;mmx&quot;
comma
l_string|&quot;fxsr&quot;
comma
l_string|&quot;sse&quot;
comma
l_string|&quot;sse2&quot;
comma
l_string|&quot;ss&quot;
comma
l_int|NULL
comma
l_string|&quot;tm&quot;
comma
l_string|&quot;ia64&quot;
comma
l_int|NULL
comma
multiline_comment|/* AMD-defined */
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;syscall&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;mmxext&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_string|&quot;lm&quot;
comma
l_string|&quot;3dnowext&quot;
comma
l_string|&quot;3dnow&quot;
comma
multiline_comment|/* Transmeta-defined */
l_string|&quot;recovery&quot;
comma
l_string|&quot;longrun&quot;
comma
l_int|NULL
comma
l_string|&quot;lrti&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
multiline_comment|/* Other (Linux-defined) */
l_string|&quot;cxmmx&quot;
comma
l_string|&quot;k6_mtrr&quot;
comma
l_string|&quot;cyrix_arr&quot;
comma
l_string|&quot;centaur_mcr&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
)brace
suffix:semicolon
r_struct
id|cpuinfo_x86
op_star
id|c
op_assign
id|cpu_data
suffix:semicolon
r_int
id|i
comma
id|n
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|NR_CPUS
suffix:semicolon
id|n
op_increment
comma
id|c
op_increment
)paren
(brace
r_int
id|fpu_exception
suffix:semicolon
macro_line|#ifdef CONFIG_SMP
r_if
c_cond
(paren
op_logical_neg
(paren
id|cpu_online_map
op_amp
(paren
l_int|1
op_lshift
id|n
)paren
)paren
)paren
r_continue
suffix:semicolon
macro_line|#endif
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;processor&bslash;t: %d&bslash;n&quot;
l_string|&quot;vendor_id&bslash;t: %s&bslash;n&quot;
l_string|&quot;cpu family&bslash;t: %d&bslash;n&quot;
l_string|&quot;model&bslash;t&bslash;t: %d&bslash;n&quot;
l_string|&quot;model name&bslash;t: %s&bslash;n&quot;
comma
id|n
comma
id|c-&gt;x86_vendor_id
(braket
l_int|0
)braket
ques
c_cond
id|c-&gt;x86_vendor_id
suffix:colon
l_string|&quot;unknown&quot;
comma
id|c-&gt;x86
comma
id|c-&gt;x86_model
comma
id|c-&gt;x86_model_id
(braket
l_int|0
)braket
ques
c_cond
id|c-&gt;x86_model_id
suffix:colon
l_string|&quot;unknown&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;x86_mask
op_logical_or
id|c-&gt;cpuid_level
op_ge
l_int|0
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;stepping&bslash;t: %d&bslash;n&quot;
comma
id|c-&gt;x86_mask
)paren
suffix:semicolon
r_else
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;stepping&bslash;t: unknown&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|X86_FEATURE_TSC
comma
op_amp
id|c-&gt;x86_capability
)paren
)paren
(brace
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;cpu MHz&bslash;t&bslash;t: %lu.%03lu&bslash;n&quot;
comma
id|cpu_khz
op_div
l_int|1000
comma
(paren
id|cpu_khz
op_mod
l_int|1000
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Cache size */
r_if
c_cond
(paren
id|c-&gt;x86_cache_size
op_ge
l_int|0
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;cache size&bslash;t: %d KB&bslash;n&quot;
comma
id|c-&gt;x86_cache_size
)paren
suffix:semicolon
multiline_comment|/* We use exception 16 if we have hardware math and we&squot;ve either seen it or the CPU claims it is internal */
id|fpu_exception
op_assign
id|c-&gt;hard_math
op_logical_and
(paren
id|ignore_irq13
op_logical_or
id|cpu_has_fpu
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;fdiv_bug&bslash;t: %s&bslash;n&quot;
l_string|&quot;hlt_bug&bslash;t&bslash;t: %s&bslash;n&quot;
l_string|&quot;f00f_bug&bslash;t: %s&bslash;n&quot;
l_string|&quot;coma_bug&bslash;t: %s&bslash;n&quot;
l_string|&quot;fpu&bslash;t&bslash;t: %s&bslash;n&quot;
l_string|&quot;fpu_exception&bslash;t: %s&bslash;n&quot;
l_string|&quot;cpuid level&bslash;t: %d&bslash;n&quot;
l_string|&quot;wp&bslash;t&bslash;t: %s&bslash;n&quot;
l_string|&quot;flags&bslash;t&bslash;t:&quot;
comma
id|c-&gt;fdiv_bug
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
id|c-&gt;hlt_works_ok
ques
c_cond
l_string|&quot;no&quot;
suffix:colon
l_string|&quot;yes&quot;
comma
id|c-&gt;f00f_bug
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
id|c-&gt;coma_bug
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
id|c-&gt;hard_math
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
id|fpu_exception
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
id|c-&gt;cpuid_level
comma
id|c-&gt;wp_works_ok
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
op_star
id|NCAPINTS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|i
comma
op_amp
id|c-&gt;x86_capability
)paren
op_logical_and
id|x86_cap_flags
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot; %s&quot;
comma
id|x86_cap_flags
(braket
id|i
)braket
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;&bslash;nbogomips&bslash;t: %lu.%02lu&bslash;n&bslash;n&quot;
comma
id|c-&gt;loops_per_jiffy
op_div
(paren
l_int|500000
op_div
id|HZ
)paren
comma
(paren
id|c-&gt;loops_per_jiffy
op_div
(paren
l_int|5000
op_div
id|HZ
)paren
)paren
op_mod
l_int|100
)paren
suffix:semicolon
)brace
r_return
id|p
op_minus
id|buffer
suffix:semicolon
)brace
DECL|variable|__initdata
r_static
r_int
r_int
id|cpu_initialized
id|__initdata
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * cpu_init() initializes state that is per-CPU. Some data is already&n; * initialized (naturally) in the bootstrap process, such as the GDT&n; * and IDT. We reload them nevertheless, this function acts as a&n; * &squot;CPU state barrier&squot;, nothing should get across.&n; */
DECL|function|cpu_init
r_void
id|__init
id|cpu_init
(paren
r_void
)paren
(brace
r_int
id|nr
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_struct
id|tss_struct
op_star
id|t
op_assign
op_amp
id|init_tss
(braket
id|nr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|nr
comma
op_amp
id|cpu_initialized
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CPU#%d already initialized!&bslash;n&quot;
comma
id|nr
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
id|__sti
c_func
(paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Initializing CPU#%d&bslash;n&quot;
comma
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_has_vme
op_logical_or
id|cpu_has_tsc
op_logical_or
id|cpu_has_de
)paren
id|clear_in_cr4
c_func
(paren
id|X86_CR4_VME
op_or
id|X86_CR4_PVI
op_or
id|X86_CR4_TSD
op_or
id|X86_CR4_DE
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_X86_TSC
r_if
c_cond
(paren
id|tsc_disable
op_logical_and
id|cpu_has_tsc
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Disabling TSC...&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/**** FIX-HPA: DOES THIS REALLY BELONG HERE? ****/
id|clear_bit
c_func
(paren
id|X86_FEATURE_TSC
comma
id|boot_cpu_data.x86_capability
)paren
suffix:semicolon
id|set_in_cr4
c_func
(paren
id|X86_CR4_TSD
)paren
suffix:semicolon
)brace
macro_line|#endif
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;lgdt %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|gdt_descr
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;lidt %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|idt_descr
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Delete NT&n;&t; */
id|__asm__
c_func
(paren
l_string|&quot;pushfl ; andl $0xffffbfff,(%esp) ; popfl&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set up and load the per-CPU TSS and LDT&n;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|init_mm.mm_count
)paren
suffix:semicolon
id|current-&gt;active_mm
op_assign
op_amp
id|init_mm
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;mm
)paren
(brace
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
id|enter_lazy_tlb
c_func
(paren
op_amp
id|init_mm
comma
id|current
comma
id|nr
)paren
suffix:semicolon
id|t-&gt;esp0
op_assign
id|current-&gt;thread.esp0
suffix:semicolon
id|set_tss_desc
c_func
(paren
id|nr
comma
id|t
)paren
suffix:semicolon
id|gdt_table
(braket
id|__TSS
c_func
(paren
id|nr
)paren
)braket
dot
id|b
op_and_assign
l_int|0xfffffdff
suffix:semicolon
id|load_TR
c_func
(paren
id|nr
)paren
suffix:semicolon
id|load_LDT
c_func
(paren
op_amp
id|init_mm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear all 6 debug registers:&n;&t; */
DECL|macro|CD
mdefine_line|#define CD(register) __asm__(&quot;movl %0,%%db&quot; #register ::&quot;r&quot;(0) );
id|CD
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|CD
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|CD
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|CD
c_func
(paren
l_int|3
)paren
suffix:semicolon
multiline_comment|/* no db4 and db5 */
suffix:semicolon
id|CD
c_func
(paren
l_int|6
)paren
suffix:semicolon
id|CD
c_func
(paren
l_int|7
)paren
suffix:semicolon
DECL|macro|CD
macro_line|#undef CD
multiline_comment|/*&n;&t; * Force FPU initialization:&n;&t; */
id|current-&gt;flags
op_and_assign
op_complement
id|PF_USEDFPU
suffix:semicolon
id|current-&gt;used_math
op_assign
l_int|0
suffix:semicolon
id|stts
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Local Variables:&n; * mode:c&n; * c-file-style:&quot;k&amp;r&quot;&n; * c-basic-offset:8&n; * End:&n; */
eof
