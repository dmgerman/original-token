multiline_comment|/*&n; *  linux/arch/i386/traps.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; * &squot;Traps.c&squot; handles hardware traps and faults after we have saved some&n; * state in &squot;asm.s&squot;.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/spinlock.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/debugreg.h&gt;
macro_line|#include &lt;asm/desc.h&gt;
id|asmlinkage
r_int
id|system_call
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|lcall7
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|default_ldt
r_struct
id|desc_struct
id|default_ldt
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * The IDT has to be page-aligned to simplify the Pentium&n; * F0 0F bug workaround.. We have a special link segment&n; * for this.&n; */
DECL|variable|idt_table
r_struct
id|desc_struct
id|idt_table
(braket
l_int|256
)braket
id|__attribute__
c_func
(paren
(paren
id|__section__
c_func
(paren
l_string|&quot;.data.idt&quot;
)paren
)paren
)paren
op_assign
(brace
(brace
l_int|0
comma
l_int|0
)brace
comma
)brace
suffix:semicolon
DECL|function|console_verbose
r_static
r_inline
r_void
id|console_verbose
c_func
(paren
r_void
)paren
(brace
r_extern
r_int
id|console_loglevel
suffix:semicolon
id|console_loglevel
op_assign
l_int|15
suffix:semicolon
)brace
DECL|macro|DO_ERROR
mdefine_line|#define DO_ERROR(trapnr, signr, str, name, tsk) &bslash;&n;asmlinkage void do_##name(struct pt_regs * regs, long error_code) &bslash;&n;{ &bslash;&n;&t;tsk-&gt;tss.error_code = error_code; &bslash;&n;&t;tsk-&gt;tss.trap_no = trapnr; &bslash;&n;&t;force_sig(signr, tsk); &bslash;&n;&t;die_if_no_fixup(str,regs,error_code); &bslash;&n;}
DECL|macro|DO_VM86_ERROR
mdefine_line|#define DO_VM86_ERROR(trapnr, signr, str, name, tsk) &bslash;&n;asmlinkage void do_##name(struct pt_regs * regs, long error_code) &bslash;&n;{ &bslash;&n;&t;lock_kernel(); &bslash;&n;&t;if (regs-&gt;eflags &amp; VM_MASK) { &bslash;&n;&t;&t;if (!handle_vm86_trap((struct kernel_vm86_regs *) regs, error_code, trapnr)) &bslash;&n;&t;&t;&t;goto out; &bslash;&n;&t;&t;/* else fall through */ &bslash;&n;&t;} &bslash;&n;&t;tsk-&gt;tss.error_code = error_code; &bslash;&n;&t;tsk-&gt;tss.trap_no = trapnr; &bslash;&n;&t;force_sig(signr, tsk); &bslash;&n;&t;die_if_kernel(str,regs,error_code); &bslash;&n;out: &bslash;&n;&t;unlock_kernel(); &bslash;&n;}
r_void
id|page_exception
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|divide_error
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|debug
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|nmi
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|int3
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|overflow
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|bounds
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|invalid_op
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|device_not_available
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|double_fault
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|coprocessor_segment_overrun
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|invalid_TSS
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|segment_not_present
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|stack_segment
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|general_protection
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|page_fault
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|coprocessor_error
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|reserved
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|alignment_check
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|spurious_interrupt_bug
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|kstack_depth_to_print
r_int
id|kstack_depth_to_print
op_assign
l_int|24
suffix:semicolon
multiline_comment|/*&n; * These constants are for searching for possible module text&n; * segments.  VMALLOC_OFFSET comes from mm/vmalloc.c; MODULE_RANGE is&n; * a guess of how much space is likely to be vmalloced.&n; */
DECL|macro|VMALLOC_OFFSET
mdefine_line|#define VMALLOC_OFFSET (8*1024*1024)
DECL|macro|MODULE_RANGE
mdefine_line|#define MODULE_RANGE (8*1024*1024)
DECL|function|show_registers
r_static
r_void
id|show_registers
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|in_kernel
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|esp
suffix:semicolon
r_int
r_int
id|ss
suffix:semicolon
r_int
r_int
op_star
id|stack
comma
id|addr
comma
id|module_start
comma
id|module_end
suffix:semicolon
r_extern
r_char
id|_stext
comma
id|_etext
suffix:semicolon
id|esp
op_assign
(paren
r_int
r_int
)paren
(paren
l_int|1
op_plus
id|regs
)paren
suffix:semicolon
id|ss
op_assign
id|__KERNEL_DS
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;xcs
op_amp
l_int|3
)paren
(brace
id|in_kernel
op_assign
l_int|0
suffix:semicolon
id|esp
op_assign
id|regs-&gt;esp
suffix:semicolon
id|ss
op_assign
id|regs-&gt;xss
op_amp
l_int|0xffff
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;CPU:    %d&bslash;nEIP:    %04x:[&lt;%08lx&gt;]&bslash;nEFLAGS: %08lx&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
l_int|0xffff
op_amp
id|regs-&gt;xcs
comma
id|regs-&gt;eip
comma
id|regs-&gt;eflags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;eax: %08lx   ebx: %08lx   ecx: %08lx   edx: %08lx&bslash;n&quot;
comma
id|regs-&gt;eax
comma
id|regs-&gt;ebx
comma
id|regs-&gt;ecx
comma
id|regs-&gt;edx
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;esi: %08lx   edi: %08lx   ebp: %08lx   esp: %08lx&bslash;n&quot;
comma
id|regs-&gt;esi
comma
id|regs-&gt;edi
comma
id|regs-&gt;ebp
comma
id|esp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ds: %04x   es: %04x   ss: %04x&bslash;n&quot;
comma
id|regs-&gt;xds
op_amp
l_int|0xffff
comma
id|regs-&gt;xes
op_amp
l_int|0xffff
comma
id|ss
)paren
suffix:semicolon
id|store_TR
c_func
(paren
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Process %s (pid: %d, process nr: %d, stackpage=%08lx)&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
l_int|0xffff
op_amp
id|i
comma
l_int|4096
op_plus
(paren
r_int
r_int
)paren
id|current
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * When in-kernel, we also print out the stack and code at the&n;&t; * time of the fault..&n;&t; */
r_if
c_cond
(paren
id|in_kernel
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nStack: &quot;
)paren
suffix:semicolon
id|stack
op_assign
(paren
r_int
r_int
op_star
)paren
id|esp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kstack_depth_to_print
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|stack
op_amp
l_int|4095
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%08lx &quot;
comma
op_star
id|stack
op_increment
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nCall Trace: &quot;
)paren
suffix:semicolon
id|stack
op_assign
(paren
r_int
r_int
op_star
)paren
id|esp
suffix:semicolon
id|i
op_assign
l_int|1
suffix:semicolon
id|module_start
op_assign
id|PAGE_OFFSET
op_plus
(paren
id|max_mapnr
op_lshift
id|PAGE_SHIFT
)paren
suffix:semicolon
id|module_start
op_assign
(paren
(paren
id|module_start
op_plus
id|VMALLOC_OFFSET
)paren
op_amp
op_complement
(paren
id|VMALLOC_OFFSET
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|module_end
op_assign
id|module_start
op_plus
id|MODULE_RANGE
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
r_int
)paren
id|stack
op_amp
l_int|4095
)paren
op_ne
l_int|0
)paren
(brace
id|addr
op_assign
op_star
id|stack
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If the address is either in the text segment of the&n;&t;&t;&t; * kernel, or in the region which contains vmalloc&squot;ed&n;&t;&t;&t; * memory, it *may* be the address of a calling&n;&t;&t;&t; * routine; if so, print it so that someone tracing&n;&t;&t;&t; * down the cause of the crash will be able to figure&n;&t;&t;&t; * out the call path that was taken.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|addr
op_ge
(paren
r_int
r_int
)paren
op_amp
id|_stext
)paren
op_logical_and
(paren
id|addr
op_le
(paren
r_int
r_int
)paren
op_amp
id|_etext
)paren
)paren
op_logical_or
(paren
(paren
id|addr
op_ge
id|module_start
)paren
op_logical_and
(paren
id|addr
op_le
id|module_end
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|i
op_logical_and
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;[&lt;%08lx&gt;] &quot;
comma
id|addr
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nCode: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
id|regs-&gt;eip
)paren
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|die_lock
id|spinlock_t
id|die_lock
suffix:semicolon
DECL|function|die
r_void
id|die
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
id|console_verbose
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|die_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %04lx&bslash;n&quot;
comma
id|str
comma
id|err
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|die_lock
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
DECL|function|die_if_kernel
r_static
r_void
id|die_if_kernel
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|regs-&gt;eflags
op_amp
id|VM_MASK
)paren
op_logical_and
op_logical_neg
(paren
l_int|3
op_amp
id|regs-&gt;xcs
)paren
)paren
id|die
c_func
(paren
id|str
comma
id|regs
comma
id|err
)paren
suffix:semicolon
)brace
DECL|function|die_if_no_fixup
r_static
r_void
id|die_if_no_fixup
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|regs-&gt;eflags
op_amp
id|VM_MASK
)paren
op_logical_and
op_logical_neg
(paren
l_int|3
op_amp
id|regs-&gt;xcs
)paren
)paren
(brace
r_int
r_int
id|fixup
suffix:semicolon
id|fixup
op_assign
id|search_exception_table
c_func
(paren
id|regs-&gt;eip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fixup
)paren
(brace
id|regs-&gt;eip
op_assign
id|fixup
suffix:semicolon
r_return
suffix:semicolon
)brace
id|die
c_func
(paren
id|str
comma
id|regs
comma
id|err
)paren
suffix:semicolon
)brace
)brace
id|DO_VM86_ERROR
c_func
(paren
l_int|0
comma
id|SIGFPE
comma
l_string|&quot;divide error&quot;
comma
id|divide_error
comma
id|current
)paren
id|DO_VM86_ERROR
c_func
(paren
l_int|3
comma
id|SIGTRAP
comma
l_string|&quot;int3&quot;
comma
id|int3
comma
id|current
)paren
id|DO_VM86_ERROR
c_func
(paren
l_int|4
comma
id|SIGSEGV
comma
l_string|&quot;overflow&quot;
comma
id|overflow
comma
id|current
)paren
id|DO_VM86_ERROR
c_func
(paren
l_int|5
comma
id|SIGSEGV
comma
l_string|&quot;bounds&quot;
comma
id|bounds
comma
id|current
)paren
id|DO_ERROR
c_func
(paren
l_int|6
comma
id|SIGILL
comma
l_string|&quot;invalid operand&quot;
comma
id|invalid_op
comma
id|current
)paren
id|DO_VM86_ERROR
c_func
(paren
l_int|7
comma
id|SIGSEGV
comma
l_string|&quot;device not available&quot;
comma
id|device_not_available
comma
id|current
)paren
id|DO_ERROR
c_func
(paren
l_int|8
comma
id|SIGSEGV
comma
l_string|&quot;double fault&quot;
comma
id|double_fault
comma
id|current
)paren
id|DO_ERROR
c_func
(paren
l_int|9
comma
id|SIGFPE
comma
l_string|&quot;coprocessor segment overrun&quot;
comma
id|coprocessor_segment_overrun
comma
id|current
)paren
id|DO_ERROR
c_func
(paren
l_int|10
comma
id|SIGSEGV
comma
l_string|&quot;invalid TSS&quot;
comma
id|invalid_TSS
comma
id|current
)paren
id|DO_ERROR
c_func
(paren
l_int|11
comma
id|SIGBUS
comma
l_string|&quot;segment not present&quot;
comma
id|segment_not_present
comma
id|current
)paren
id|DO_ERROR
c_func
(paren
l_int|12
comma
id|SIGBUS
comma
l_string|&quot;stack segment&quot;
comma
id|stack_segment
comma
id|current
)paren
id|DO_ERROR
c_func
(paren
l_int|17
comma
id|SIGSEGV
comma
l_string|&quot;alignment check&quot;
comma
id|alignment_check
comma
id|current
)paren
id|DO_ERROR
c_func
(paren
l_int|18
comma
id|SIGSEGV
comma
l_string|&quot;reserved&quot;
comma
id|reserved
comma
id|current
)paren
multiline_comment|/* I don&squot;t have documents for this but it does seem to cover the cache&n;   flush from user space exception some people get. */
id|DO_ERROR
c_func
(paren
l_int|19
comma
id|SIGSEGV
comma
l_string|&quot;cache flush denied&quot;
comma
id|cache_flush_denied
comma
id|current
)paren
DECL|function|cache_flush_denied
id|asmlinkage
r_void
id|cache_flush_denied
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
r_if
c_cond
(paren
id|regs-&gt;eflags
op_amp
id|VM_MASK
)paren
(brace
id|handle_vm86_fault
c_func
(paren
(paren
r_struct
id|kernel_vm86_regs
op_star
)paren
id|regs
comma
id|error_code
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|die_if_kernel
c_func
(paren
l_string|&quot;cache flush denied&quot;
comma
id|regs
comma
id|error_code
)paren
suffix:semicolon
id|current-&gt;tss.error_code
op_assign
id|error_code
suffix:semicolon
id|current-&gt;tss.trap_no
op_assign
l_int|19
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGSEGV
comma
id|current
)paren
suffix:semicolon
)brace
DECL|function|do_general_protection
id|asmlinkage
r_void
id|do_general_protection
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
r_if
c_cond
(paren
id|regs-&gt;eflags
op_amp
id|VM_MASK
)paren
r_goto
id|gp_in_vm86
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|regs-&gt;xcs
op_amp
l_int|3
)paren
)paren
r_goto
id|gp_in_kernel
suffix:semicolon
id|current-&gt;tss.error_code
op_assign
id|error_code
suffix:semicolon
id|current-&gt;tss.trap_no
op_assign
l_int|13
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGSEGV
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
id|gp_in_vm86
suffix:colon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|handle_vm86_fault
c_func
(paren
(paren
r_struct
id|kernel_vm86_regs
op_star
)paren
id|regs
comma
id|error_code
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|gp_in_kernel
suffix:colon
(brace
r_int
r_int
id|fixup
suffix:semicolon
id|fixup
op_assign
id|search_exception_table
c_func
(paren
id|regs-&gt;eip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fixup
)paren
(brace
id|regs-&gt;eip
op_assign
id|fixup
suffix:semicolon
r_return
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;general protection fault&quot;
comma
id|regs
comma
id|error_code
)paren
suffix:semicolon
)brace
)brace
DECL|function|mem_parity_error
r_static
r_void
id|mem_parity_error
c_func
(paren
r_int
r_char
id|reason
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Uhhuh. NMI received. Dazed and confused, but trying to continue&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;You probably have a hardware problem with your RAM chips&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|io_check_error
r_static
r_void
id|io_check_error
c_func
(paren
r_int
r_char
id|reason
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NMI: IOCK error (debug interrupt?)&bslash;n&quot;
)paren
suffix:semicolon
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
multiline_comment|/* Re-enable the&#xfffd;IOCK line, wait for a few seconds */
id|reason
op_or_assign
l_int|8
suffix:semicolon
id|outb
c_func
(paren
id|reason
comma
l_int|0x61
)paren
suffix:semicolon
id|i
op_assign
l_int|2000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|i
)paren
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|reason
op_and_assign
op_complement
l_int|8
suffix:semicolon
id|outb
c_func
(paren
id|reason
comma
l_int|0x61
)paren
suffix:semicolon
)brace
DECL|function|unknown_nmi_error
r_static
r_void
id|unknown_nmi_error
c_func
(paren
r_int
r_char
id|reason
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Uhhuh. NMI received for unknown reason %02x.&bslash;n&quot;
comma
id|reason
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Dazed and confused, but trying to continue&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Do you have a strange power saving mode enabled?&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|do_nmi
id|asmlinkage
r_void
id|do_nmi
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
r_int
r_char
id|reason
op_assign
id|inb
c_func
(paren
l_int|0x61
)paren
suffix:semicolon
r_extern
id|atomic_t
id|nmi_counter
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|nmi_counter
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reason
op_amp
l_int|0x80
)paren
id|mem_parity_error
c_func
(paren
id|reason
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reason
op_amp
l_int|0x40
)paren
id|io_check_error
c_func
(paren
id|reason
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|reason
op_amp
l_int|0xc0
)paren
)paren
id|unknown_nmi_error
c_func
(paren
id|reason
comma
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Careful - we must not do a lock-kernel until we have checked that the&n; * debug fault happened in user mode. Getting debug exceptions while&n; * in the kernel has to be handled without locking, to avoid deadlocks..&n; *&n; * Being careful here means that we don&squot;t have to be as careful in a&n; * lot of more complicated places (task switching can be a bit lazy&n; * about restoring all the debug state, and ptrace doesn&squot;t have to&n; * find every occurrence of the TF bit that could be saved away even&n; * by user code - and we don&squot;t have to be careful about what values&n; * can be written to the debug registers because there are no really&n; * bad cases).&n; */
DECL|function|do_debug
id|asmlinkage
r_void
id|do_debug
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
r_int
r_int
id|condition
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;eflags
op_amp
id|VM_MASK
)paren
r_goto
id|debug_vm86
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;movl %%db6,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|condition
)paren
)paren
suffix:semicolon
multiline_comment|/* Mask out spurious TF errors due to lazy TF clearing */
r_if
c_cond
(paren
id|condition
op_amp
id|DR_STEP
)paren
(brace
r_if
c_cond
(paren
(paren
id|tsk-&gt;flags
op_amp
id|PF_PTRACED
)paren
op_eq
l_int|0
)paren
r_goto
id|clear_TF
suffix:semicolon
)brace
multiline_comment|/* Mast out spurious debug traps due to lazy DR7 setting */
r_if
c_cond
(paren
id|condition
op_amp
(paren
id|DR_TRAP0
op_or
id|DR_TRAP1
op_or
id|DR_TRAP2
op_or
id|DR_TRAP3
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tsk-&gt;tss.debugreg
(braket
l_int|7
)braket
)paren
r_goto
id|clear_dr7
suffix:semicolon
)brace
multiline_comment|/* If this is a kernel mode trap, we need to reset db7 to allow us to continue sanely */
r_if
c_cond
(paren
(paren
id|regs-&gt;xcs
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
r_goto
id|clear_dr7
suffix:semicolon
multiline_comment|/* Ok, finally something we can handle */
id|tsk-&gt;tss.trap_no
op_assign
l_int|1
suffix:semicolon
id|tsk-&gt;tss.error_code
op_assign
id|error_code
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGTRAP
comma
id|tsk
)paren
suffix:semicolon
r_return
suffix:semicolon
id|debug_vm86
suffix:colon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|handle_vm86_trap
c_func
(paren
(paren
r_struct
id|kernel_vm86_regs
op_star
)paren
id|regs
comma
id|error_code
comma
l_int|1
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|clear_dr7
suffix:colon
id|__asm__
c_func
(paren
l_string|&quot;movl %0,%%db7&quot;
suffix:colon
multiline_comment|/* no output */
suffix:colon
l_string|&quot;r&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|clear_TF
suffix:colon
id|regs-&gt;eflags
op_and_assign
op_complement
id|TF_MASK
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Note that we play around with the &squot;TS&squot; bit in an attempt to get&n; * the correct behaviour even in the presence of the asynchronous&n; * IRQ13 behaviour&n; */
DECL|function|math_error
r_void
id|math_error
c_func
(paren
r_void
)paren
(brace
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|clts
c_func
(paren
)paren
suffix:semicolon
id|task
op_assign
id|current
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Save the info for the exception handler&n;&t; */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;fnsave %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|task-&gt;tss.i387.hard
)paren
)paren
suffix:semicolon
id|task-&gt;flags
op_and_assign
op_complement
id|PF_USEDFPU
suffix:semicolon
id|stts
c_func
(paren
)paren
suffix:semicolon
id|task-&gt;tss.trap_no
op_assign
l_int|16
suffix:semicolon
id|task-&gt;tss.error_code
op_assign
l_int|0
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGFPE
comma
id|task
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|do_coprocessor_error
id|asmlinkage
r_void
id|do_coprocessor_error
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
id|ignore_irq13
op_assign
l_int|1
suffix:semicolon
id|math_error
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|do_spurious_interrupt_bug
id|asmlinkage
r_void
id|do_spurious_interrupt_bug
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
macro_line|#if 0
multiline_comment|/* No need to warn about this any longer. */
id|printk
c_func
(paren
l_string|&quot;Ignoring P6 Local APIC Spurious Interrupt Bug...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *  &squot;math_state_restore()&squot; saves the current math information in the&n; * old math state array, and gets the new ones from the current task&n; *&n; * Careful.. There are problems with IBM-designed IRQ13 behaviour.&n; * Don&squot;t touch unless you *really* know how it works.&n; */
DECL|function|math_state_restore
id|asmlinkage
r_void
id|math_state_restore
c_func
(paren
r_void
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;clts&quot;
)paren
suffix:semicolon
multiline_comment|/* Allow maths ops (or we recurse) */
multiline_comment|/*&n; *&t;SMP is actually simpler than uniprocessor for once. Because&n; *&t;we can&squot;t pull the delayed FPU switching trick Linus does&n; *&t;we simply have to do the restore each context switch and&n; *&t;set the flag. switch_to() will always save the state in&n; *&t;case we swap processors. We also don&squot;t use the coprocessor&n; *&t;timer - IRQ 13 mode isn&squot;t used with SMP machines (thank god).&n; */
r_if
c_cond
(paren
id|current-&gt;used_math
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;frstor %0&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
id|current-&gt;tss.i387
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; *&t;Our first FPU usage, clean the chip.&n;&t;&t; */
id|__asm__
c_func
(paren
l_string|&quot;fninit&quot;
)paren
suffix:semicolon
id|current-&gt;used_math
op_assign
l_int|1
suffix:semicolon
)brace
id|current-&gt;flags
op_or_assign
id|PF_USEDFPU
suffix:semicolon
multiline_comment|/* So we fnsave on switch_to() */
)brace
macro_line|#ifndef CONFIG_MATH_EMULATION
DECL|function|math_emulate
id|asmlinkage
r_void
id|math_emulate
c_func
(paren
r_int
id|arg
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;math-emulation not enabled and no coprocessor found.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;killing %s.&bslash;n&quot;
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGFPE
comma
id|current
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_MATH_EMULATION */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|trap_init_f00f_bug
c_func
(paren
r_void
)paren
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate a new page in virtual address space, &n;&t; * move the IDT into it and write protect this page.&n;&t; */
id|page
op_assign
(paren
r_int
r_int
)paren
id|vmalloc
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
id|pgd
op_assign
id|pgd_offset
c_func
(paren
op_amp
id|init_mm
comma
id|page
)paren
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|page
)paren
suffix:semicolon
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|page
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|pte_page
c_func
(paren
op_star
id|pte
)paren
)paren
suffix:semicolon
op_star
id|pte
op_assign
id|mk_pte
c_func
(paren
op_amp
id|idt_table
comma
id|PAGE_KERNEL_RO
)paren
suffix:semicolon
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * &quot;idt&quot; is magic - it overlaps the idt_descr&n;&t; * variable so that updating idt will automatically&n;&t; * update the idt descriptor..&n;&t; */
id|idt
op_assign
(paren
r_struct
id|desc_struct
op_star
)paren
id|page
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;lidt %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|idt_descr
)paren
)paren
suffix:semicolon
)brace
DECL|macro|_set_gate
mdefine_line|#define _set_gate(gate_addr,type,dpl,addr) &bslash;&n;__asm__ __volatile__ (&quot;movw %%dx,%%ax&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movw %2,%%dx&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movl %%eax,%0&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movl %%edx,%1&quot; &bslash;&n;&t;:&quot;=m&quot; (*((long *) (gate_addr))), &bslash;&n;&t; &quot;=m&quot; (*(1+(long *) (gate_addr))) &bslash;&n;&t;:&quot;i&quot; ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), &bslash;&n;&t; &quot;d&quot; ((char *) (addr)),&quot;a&quot; (__KERNEL_CS &lt;&lt; 16) &bslash;&n;&t;:&quot;ax&quot;,&quot;dx&quot;)
multiline_comment|/*&n; * This needs to use &squot;idt_table&squot; rather than &squot;idt&squot;, and&n; * thus use the _nonmapped_ version of the IDT, as the&n; * Pentium F0 0F bugfix can have resulted in the mapped&n; * IDT being write-protected.&n; */
DECL|function|set_intr_gate
r_void
id|set_intr_gate
c_func
(paren
r_int
r_int
id|n
comma
r_void
op_star
id|addr
)paren
(brace
id|_set_gate
c_func
(paren
id|idt_table
op_plus
id|n
comma
l_int|14
comma
l_int|0
comma
id|addr
)paren
suffix:semicolon
)brace
DECL|function|set_trap_gate
r_static
r_void
id|__init
id|set_trap_gate
c_func
(paren
r_int
r_int
id|n
comma
r_void
op_star
id|addr
)paren
(brace
id|_set_gate
c_func
(paren
id|idt_table
op_plus
id|n
comma
l_int|15
comma
l_int|0
comma
id|addr
)paren
suffix:semicolon
)brace
DECL|function|set_system_gate
r_static
r_void
id|__init
id|set_system_gate
c_func
(paren
r_int
r_int
id|n
comma
r_void
op_star
id|addr
)paren
(brace
id|_set_gate
c_func
(paren
id|idt_table
op_plus
id|n
comma
l_int|15
comma
l_int|3
comma
id|addr
)paren
suffix:semicolon
)brace
DECL|function|set_call_gate
r_static
r_void
id|__init
id|set_call_gate
c_func
(paren
r_void
op_star
id|a
comma
r_void
op_star
id|addr
)paren
(brace
id|_set_gate
c_func
(paren
id|a
comma
l_int|12
comma
l_int|3
comma
id|addr
)paren
suffix:semicolon
)brace
DECL|macro|_set_seg_desc
mdefine_line|#define _set_seg_desc(gate_addr,type,dpl,base,limit) {&bslash;&n;&t;*((gate_addr)+1) = ((base) &amp; 0xff000000) | &bslash;&n;&t;&t;(((base) &amp; 0x00ff0000)&gt;&gt;16) | &bslash;&n;&t;&t;((limit) &amp; 0xf0000) | &bslash;&n;&t;&t;((dpl)&lt;&lt;13) | &bslash;&n;&t;&t;(0x00408000) | &bslash;&n;&t;&t;((type)&lt;&lt;8); &bslash;&n;&t;*(gate_addr) = (((base) &amp; 0x0000ffff)&lt;&lt;16) | &bslash;&n;&t;&t;((limit) &amp; 0x0ffff); }
DECL|macro|_set_tssldt_desc
mdefine_line|#define _set_tssldt_desc(n,addr,limit,type) &bslash;&n;__asm__ __volatile__ (&quot;movw %3,0(%2)&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movw %%ax,2(%2)&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;rorl $16,%%eax&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movb %%al,4(%2)&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movb %4,5(%2)&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movb $0,6(%2)&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movb %%ah,7(%2)&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;rorl $16,%%eax&quot; &bslash;&n;&t;: &quot;=m&quot;(*(n)) : &quot;a&quot; (addr), &quot;r&quot;(n), &quot;ir&quot;(limit), &quot;i&quot;(type))
DECL|function|set_tss_desc
r_void
id|set_tss_desc
c_func
(paren
r_int
r_int
id|n
comma
r_void
op_star
id|addr
)paren
(brace
id|_set_tssldt_desc
c_func
(paren
id|gdt_table
op_plus
id|FIRST_TSS_ENTRY
op_plus
(paren
id|n
op_lshift
l_int|1
)paren
comma
(paren
r_int
)paren
id|addr
comma
l_int|235
comma
l_int|0x89
)paren
suffix:semicolon
)brace
DECL|function|set_ldt_desc
r_void
id|set_ldt_desc
c_func
(paren
r_int
r_int
id|n
comma
r_void
op_star
id|addr
comma
r_int
r_int
id|size
)paren
(brace
id|_set_tssldt_desc
c_func
(paren
id|gdt_table
op_plus
id|FIRST_LDT_ENTRY
op_plus
(paren
id|n
op_lshift
l_int|1
)paren
comma
(paren
r_int
)paren
id|addr
comma
(paren
(paren
id|size
op_lshift
l_int|3
)paren
op_minus
l_int|1
)paren
comma
l_int|0x82
)paren
suffix:semicolon
)brace
DECL|function|trap_init
r_void
id|__init
id|trap_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|readl
c_func
(paren
l_int|0x0FFFD9
)paren
op_eq
l_char|&squot;E&squot;
op_plus
(paren
l_char|&squot;I&squot;
op_lshift
l_int|8
)paren
op_plus
(paren
l_char|&squot;S&squot;
op_lshift
l_int|16
)paren
op_plus
(paren
l_char|&squot;A&squot;
op_lshift
l_int|24
)paren
)paren
id|EISA_bus
op_assign
l_int|1
suffix:semicolon
id|set_call_gate
c_func
(paren
op_amp
id|default_ldt
comma
id|lcall7
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|0
comma
op_amp
id|divide_error
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|1
comma
op_amp
id|debug
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|2
comma
op_amp
id|nmi
)paren
suffix:semicolon
id|set_system_gate
c_func
(paren
l_int|3
comma
op_amp
id|int3
)paren
suffix:semicolon
multiline_comment|/* int3-5 can be called from all */
id|set_system_gate
c_func
(paren
l_int|4
comma
op_amp
id|overflow
)paren
suffix:semicolon
id|set_system_gate
c_func
(paren
l_int|5
comma
op_amp
id|bounds
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|6
comma
op_amp
id|invalid_op
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|7
comma
op_amp
id|device_not_available
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|8
comma
op_amp
id|double_fault
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|9
comma
op_amp
id|coprocessor_segment_overrun
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|10
comma
op_amp
id|invalid_TSS
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|11
comma
op_amp
id|segment_not_present
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|12
comma
op_amp
id|stack_segment
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|13
comma
op_amp
id|general_protection
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|14
comma
op_amp
id|page_fault
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|15
comma
op_amp
id|spurious_interrupt_bug
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|16
comma
op_amp
id|coprocessor_error
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|17
comma
op_amp
id|alignment_check
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|18
suffix:semicolon
id|i
OL
l_int|48
suffix:semicolon
id|i
op_increment
)paren
id|set_trap_gate
c_func
(paren
id|i
comma
op_amp
id|reserved
)paren
suffix:semicolon
id|set_system_gate
c_func
(paren
l_int|0x80
comma
op_amp
id|system_call
)paren
suffix:semicolon
multiline_comment|/* set up GDT task &amp; ldt entries */
id|set_tss_desc
c_func
(paren
l_int|0
comma
op_amp
id|init_task.tss
)paren
suffix:semicolon
id|set_ldt_desc
c_func
(paren
l_int|0
comma
op_amp
id|default_ldt
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Clear NT, so that we won&squot;t have troubles with that later on */
id|__asm__
c_func
(paren
l_string|&quot;pushfl ; andl $0xffffbfff,(%esp) ; popfl&quot;
)paren
suffix:semicolon
id|load_TR
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|load_ldt
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
eof
