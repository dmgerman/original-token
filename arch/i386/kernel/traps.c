multiline_comment|/*&n; *  linux/arch/i386/traps.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; *&n; *  Pentium III FXSR, SSE support&n; *&t;Gareth Hughes &lt;gareth@valinux.com&gt;, May 2000&n; */
multiline_comment|/*&n; * &squot;Traps.c&squot; handles hardware traps and faults after we have saved some&n; * state in &squot;asm.s&squot;.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#ifdef CONFIG_MCA
macro_line|#include &lt;linux/mca.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
macro_line|#include &lt;asm/debugreg.h&gt;
macro_line|#include &lt;asm/desc.h&gt;
macro_line|#include &lt;asm/i387.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
macro_line|#ifdef CONFIG_X86_VISWS_APIC
macro_line|#include &lt;asm/fixmap.h&gt;
macro_line|#include &lt;asm/cobalt.h&gt;
macro_line|#include &lt;asm/lithium.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/irq.h&gt;
id|asmlinkage
r_int
id|system_call
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|lcall7
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|lcall27
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|default_ldt
r_struct
id|desc_struct
id|default_ldt
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * The IDT has to be page-aligned to simplify the Pentium&n; * F0 0F bug workaround.. We have a special link segment&n; * for this.&n; */
DECL|variable|idt_table
r_struct
id|desc_struct
id|idt_table
(braket
l_int|256
)braket
id|__attribute__
c_func
(paren
(paren
id|__section__
c_func
(paren
l_string|&quot;.data.idt&quot;
)paren
)paren
)paren
op_assign
(brace
(brace
l_int|0
comma
l_int|0
)brace
comma
)brace
suffix:semicolon
r_extern
r_void
id|bust_spinlocks
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|divide_error
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|debug
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|nmi
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|int3
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|overflow
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|bounds
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|invalid_op
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|device_not_available
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|double_fault
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|coprocessor_segment_overrun
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|invalid_TSS
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|segment_not_present
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|stack_segment
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|general_protection
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|page_fault
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|coprocessor_error
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|simd_coprocessor_error
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|alignment_check
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|spurious_interrupt_bug
c_func
(paren
r_void
)paren
suffix:semicolon
id|asmlinkage
r_void
id|machine_check
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|kstack_depth_to_print
r_int
id|kstack_depth_to_print
op_assign
l_int|24
suffix:semicolon
multiline_comment|/*&n; * These constants are for searching for possible module text&n; * segments.&n; */
DECL|function|show_trace
r_void
id|show_trace
c_func
(paren
r_int
r_int
op_star
id|stack
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|addr
comma
id|module_start
comma
id|module_end
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stack
)paren
id|stack
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|stack
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Call Trace: &quot;
)paren
suffix:semicolon
id|i
op_assign
l_int|1
suffix:semicolon
id|module_start
op_assign
id|VMALLOC_START
suffix:semicolon
id|module_end
op_assign
id|VMALLOC_END
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
r_int
)paren
id|stack
op_amp
(paren
id|THREAD_SIZE
op_minus
l_int|1
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|addr
op_assign
op_star
id|stack
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the address is either in the text segment of the&n;&t;&t; * kernel, or in the region which contains vmalloc&squot;ed&n;&t;&t; * memory, it *may* be the address of a calling&n;&t;&t; * routine; if so, print it so that someone tracing&n;&t;&t; * down the cause of the crash will be able to figure&n;&t;&t; * out the call path that was taken.&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|addr
op_ge
(paren
r_int
r_int
)paren
op_amp
id|_stext
)paren
op_logical_and
(paren
id|addr
op_le
(paren
r_int
r_int
)paren
op_amp
id|_etext
)paren
)paren
op_logical_or
(paren
(paren
id|addr
op_ge
id|module_start
)paren
op_logical_and
(paren
id|addr
op_le
id|module_end
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|i
op_logical_and
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;[&lt;%08lx&gt;] &quot;
comma
id|addr
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|show_stack
r_void
id|show_stack
c_func
(paren
r_int
r_int
op_star
id|esp
)paren
(brace
r_int
r_int
op_star
id|stack
suffix:semicolon
r_int
id|i
suffix:semicolon
singleline_comment|// debugging aid: &quot;show_stack(NULL);&quot; prints the
singleline_comment|// back trace for this cpu.
r_if
c_cond
(paren
id|esp
op_eq
l_int|NULL
)paren
(brace
id|esp
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|esp
suffix:semicolon
)brace
id|stack
op_assign
id|esp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|kstack_depth_to_print
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|stack
op_amp
(paren
id|THREAD_SIZE
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_and
(paren
(paren
id|i
op_mod
l_int|8
)paren
op_eq
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n       &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%08lx &quot;
comma
op_star
id|stack
op_increment
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|show_trace
c_func
(paren
id|esp
)paren
suffix:semicolon
)brace
DECL|function|show_registers
r_static
r_void
id|show_registers
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|in_kernel
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|esp
suffix:semicolon
r_int
r_int
id|ss
suffix:semicolon
id|esp
op_assign
(paren
r_int
r_int
)paren
(paren
op_amp
id|regs-&gt;esp
)paren
suffix:semicolon
id|ss
op_assign
id|__KERNEL_DS
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;xcs
op_amp
l_int|3
)paren
(brace
id|in_kernel
op_assign
l_int|0
suffix:semicolon
id|esp
op_assign
id|regs-&gt;esp
suffix:semicolon
id|ss
op_assign
id|regs-&gt;xss
op_amp
l_int|0xffff
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;CPU:    %d&bslash;nEIP:    %04x:[&lt;%08lx&gt;]&bslash;nEFLAGS: %08lx&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
l_int|0xffff
op_amp
id|regs-&gt;xcs
comma
id|regs-&gt;eip
comma
id|regs-&gt;eflags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;eax: %08lx   ebx: %08lx   ecx: %08lx   edx: %08lx&bslash;n&quot;
comma
id|regs-&gt;eax
comma
id|regs-&gt;ebx
comma
id|regs-&gt;ecx
comma
id|regs-&gt;edx
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;esi: %08lx   edi: %08lx   ebp: %08lx   esp: %08lx&bslash;n&quot;
comma
id|regs-&gt;esi
comma
id|regs-&gt;edi
comma
id|regs-&gt;ebp
comma
id|esp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ds: %04x   es: %04x   ss: %04x&bslash;n&quot;
comma
id|regs-&gt;xds
op_amp
l_int|0xffff
comma
id|regs-&gt;xes
op_amp
l_int|0xffff
comma
id|ss
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Process %s (pid: %d, stackpage=%08lx)&quot;
comma
id|current-&gt;comm
comma
id|current-&gt;pid
comma
l_int|4096
op_plus
(paren
r_int
r_int
)paren
id|current
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * When in-kernel, we also print out the stack and code at the&n;&t; * time of the fault..&n;&t; */
r_if
c_cond
(paren
id|in_kernel
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nStack: &quot;
)paren
suffix:semicolon
id|show_stack
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|esp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;nCode: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;eip
OL
id|PAGE_OFFSET
)paren
(brace
r_goto
id|bad
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|c
comma
op_amp
(paren
(paren
r_int
r_char
op_star
)paren
id|regs-&gt;eip
)paren
(braket
id|i
)braket
)paren
)paren
(brace
id|bad
suffix:colon
id|printk
c_func
(paren
l_string|&quot; Bad EIP value.&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|c
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|die_lock
id|spinlock_t
id|die_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|die
r_void
id|die
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
id|console_verbose
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|die_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %04lx&bslash;n&quot;
comma
id|str
comma
id|err
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|die_lock
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
DECL|function|die_if_kernel
r_static
r_inline
r_void
id|die_if_kernel
c_func
(paren
r_const
r_char
op_star
id|str
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|err
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|regs-&gt;eflags
op_amp
id|VM_MASK
)paren
op_logical_and
op_logical_neg
(paren
l_int|3
op_amp
id|regs-&gt;xcs
)paren
)paren
id|die
c_func
(paren
id|str
comma
id|regs
comma
id|err
)paren
suffix:semicolon
)brace
DECL|function|get_cr2
r_static
r_inline
r_int
r_int
id|get_cr2
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|address
suffix:semicolon
multiline_comment|/* get the address */
id|__asm__
c_func
(paren
l_string|&quot;movl %%cr2,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|address
)paren
)paren
suffix:semicolon
r_return
id|address
suffix:semicolon
)brace
DECL|function|do_trap
r_static
r_void
r_inline
id|do_trap
c_func
(paren
r_int
id|trapnr
comma
r_int
id|signr
comma
r_char
op_star
id|str
comma
r_int
id|vm86
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
comma
id|siginfo_t
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|vm86
op_logical_and
id|regs-&gt;eflags
op_amp
id|VM_MASK
)paren
r_goto
id|vm86_trap
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|regs-&gt;xcs
op_amp
l_int|3
)paren
)paren
r_goto
id|kernel_trap
suffix:semicolon
id|trap_signal
suffix:colon
(brace
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|tsk-&gt;thread.error_code
op_assign
id|error_code
suffix:semicolon
id|tsk-&gt;thread.trap_no
op_assign
id|trapnr
suffix:semicolon
r_if
c_cond
(paren
id|info
)paren
id|force_sig_info
c_func
(paren
id|signr
comma
id|info
comma
id|tsk
)paren
suffix:semicolon
r_else
id|force_sig
c_func
(paren
id|signr
comma
id|tsk
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|kernel_trap
suffix:colon
(brace
r_int
r_int
id|fixup
op_assign
id|search_exception_table
c_func
(paren
id|regs-&gt;eip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fixup
)paren
id|regs-&gt;eip
op_assign
id|fixup
suffix:semicolon
r_else
id|die
c_func
(paren
id|str
comma
id|regs
comma
id|error_code
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|vm86_trap
suffix:colon
(brace
r_int
id|ret
op_assign
id|handle_vm86_trap
c_func
(paren
(paren
r_struct
id|kernel_vm86_regs
op_star
)paren
id|regs
comma
id|error_code
comma
id|trapnr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_goto
id|trap_signal
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
DECL|macro|DO_ERROR
mdefine_line|#define DO_ERROR(trapnr, signr, str, name) &bslash;&n;asmlinkage void do_##name(struct pt_regs * regs, long error_code) &bslash;&n;{ &bslash;&n;&t;do_trap(trapnr, signr, str, 0, regs, error_code, NULL); &bslash;&n;}
DECL|macro|DO_ERROR_INFO
mdefine_line|#define DO_ERROR_INFO(trapnr, signr, str, name, sicode, siaddr) &bslash;&n;asmlinkage void do_##name(struct pt_regs * regs, long error_code) &bslash;&n;{ &bslash;&n;&t;siginfo_t info; &bslash;&n;&t;info.si_signo = signr; &bslash;&n;&t;info.si_errno = 0; &bslash;&n;&t;info.si_code = sicode; &bslash;&n;&t;info.si_addr = (void *)siaddr; &bslash;&n;&t;do_trap(trapnr, signr, str, 0, regs, error_code, &amp;info); &bslash;&n;}
DECL|macro|DO_VM86_ERROR
mdefine_line|#define DO_VM86_ERROR(trapnr, signr, str, name) &bslash;&n;asmlinkage void do_##name(struct pt_regs * regs, long error_code) &bslash;&n;{ &bslash;&n;&t;do_trap(trapnr, signr, str, 1, regs, error_code, NULL); &bslash;&n;}
DECL|macro|DO_VM86_ERROR_INFO
mdefine_line|#define DO_VM86_ERROR_INFO(trapnr, signr, str, name, sicode, siaddr) &bslash;&n;asmlinkage void do_##name(struct pt_regs * regs, long error_code) &bslash;&n;{ &bslash;&n;&t;siginfo_t info; &bslash;&n;&t;info.si_signo = signr; &bslash;&n;&t;info.si_errno = 0; &bslash;&n;&t;info.si_code = sicode; &bslash;&n;&t;info.si_addr = (void *)siaddr; &bslash;&n;&t;do_trap(trapnr, signr, str, 1, regs, error_code, &amp;info); &bslash;&n;}
id|DO_VM86_ERROR_INFO
c_func
(paren
l_int|0
comma
id|SIGFPE
comma
l_string|&quot;divide error&quot;
comma
id|divide_error
comma
id|FPE_INTDIV
comma
id|regs-&gt;eip
)paren
id|DO_VM86_ERROR
c_func
(paren
l_int|3
comma
id|SIGTRAP
comma
l_string|&quot;int3&quot;
comma
id|int3
)paren
id|DO_VM86_ERROR
c_func
(paren
l_int|4
comma
id|SIGSEGV
comma
l_string|&quot;overflow&quot;
comma
id|overflow
)paren
id|DO_VM86_ERROR
c_func
(paren
l_int|5
comma
id|SIGSEGV
comma
l_string|&quot;bounds&quot;
comma
id|bounds
)paren
id|DO_ERROR_INFO
c_func
(paren
l_int|6
comma
id|SIGILL
comma
l_string|&quot;invalid operand&quot;
comma
id|invalid_op
comma
id|ILL_ILLOPN
comma
id|regs-&gt;eip
)paren
id|DO_VM86_ERROR
c_func
(paren
l_int|7
comma
id|SIGSEGV
comma
l_string|&quot;device not available&quot;
comma
id|device_not_available
)paren
id|DO_ERROR
c_func
(paren
l_int|8
comma
id|SIGSEGV
comma
l_string|&quot;double fault&quot;
comma
id|double_fault
)paren
id|DO_ERROR
c_func
(paren
l_int|9
comma
id|SIGFPE
comma
l_string|&quot;coprocessor segment overrun&quot;
comma
id|coprocessor_segment_overrun
)paren
id|DO_ERROR
c_func
(paren
l_int|10
comma
id|SIGSEGV
comma
l_string|&quot;invalid TSS&quot;
comma
id|invalid_TSS
)paren
id|DO_ERROR
c_func
(paren
l_int|11
comma
id|SIGBUS
comma
l_string|&quot;segment not present&quot;
comma
id|segment_not_present
)paren
id|DO_ERROR
c_func
(paren
l_int|12
comma
id|SIGBUS
comma
l_string|&quot;stack segment&quot;
comma
id|stack_segment
)paren
id|DO_ERROR_INFO
c_func
(paren
l_int|17
comma
id|SIGBUS
comma
l_string|&quot;alignment check&quot;
comma
id|alignment_check
comma
id|BUS_ADRALN
comma
id|get_cr2
c_func
(paren
)paren
)paren
DECL|function|do_general_protection
id|asmlinkage
r_void
id|do_general_protection
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
r_if
c_cond
(paren
id|regs-&gt;eflags
op_amp
id|VM_MASK
)paren
r_goto
id|gp_in_vm86
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|regs-&gt;xcs
op_amp
l_int|3
)paren
)paren
r_goto
id|gp_in_kernel
suffix:semicolon
id|current-&gt;thread.error_code
op_assign
id|error_code
suffix:semicolon
id|current-&gt;thread.trap_no
op_assign
l_int|13
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGSEGV
comma
id|current
)paren
suffix:semicolon
r_return
suffix:semicolon
id|gp_in_vm86
suffix:colon
id|handle_vm86_fault
c_func
(paren
(paren
r_struct
id|kernel_vm86_regs
op_star
)paren
id|regs
comma
id|error_code
)paren
suffix:semicolon
r_return
suffix:semicolon
id|gp_in_kernel
suffix:colon
(brace
r_int
r_int
id|fixup
suffix:semicolon
id|fixup
op_assign
id|search_exception_table
c_func
(paren
id|regs-&gt;eip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fixup
)paren
(brace
id|regs-&gt;eip
op_assign
id|fixup
suffix:semicolon
r_return
suffix:semicolon
)brace
id|die
c_func
(paren
l_string|&quot;general protection fault&quot;
comma
id|regs
comma
id|error_code
)paren
suffix:semicolon
)brace
)brace
DECL|function|mem_parity_error
r_static
r_void
id|mem_parity_error
c_func
(paren
r_int
r_char
id|reason
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Uhhuh. NMI received. Dazed and confused, but trying to continue&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;You probably have a hardware problem with your RAM chips&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Clear and disable the memory parity error line. */
id|reason
op_assign
(paren
id|reason
op_amp
l_int|0xf
)paren
op_or
l_int|4
suffix:semicolon
id|outb
c_func
(paren
id|reason
comma
l_int|0x61
)paren
suffix:semicolon
)brace
DECL|function|io_check_error
r_static
r_void
id|io_check_error
c_func
(paren
r_int
r_char
id|reason
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NMI: IOCK error (debug interrupt?)&bslash;n&quot;
)paren
suffix:semicolon
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
multiline_comment|/* Re-enable the IOCK line, wait for a few seconds */
id|reason
op_assign
(paren
id|reason
op_amp
l_int|0xf
)paren
op_or
l_int|8
suffix:semicolon
id|outb
c_func
(paren
id|reason
comma
l_int|0x61
)paren
suffix:semicolon
id|i
op_assign
l_int|2000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|i
)paren
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|reason
op_and_assign
op_complement
l_int|8
suffix:semicolon
id|outb
c_func
(paren
id|reason
comma
l_int|0x61
)paren
suffix:semicolon
)brace
DECL|function|unknown_nmi_error
r_static
r_void
id|unknown_nmi_error
c_func
(paren
r_int
r_char
id|reason
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
macro_line|#ifdef CONFIG_MCA
multiline_comment|/* Might actually be able to figure out what the guilty party&n;&t;* is. */
r_if
c_cond
(paren
id|MCA_bus
)paren
(brace
id|mca_handle_nmi
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;Uhhuh. NMI received for unknown reason %02x.&bslash;n&quot;
comma
id|reason
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Dazed and confused, but trying to continue&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Do you have a strange power saving mode enabled?&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#if CONFIG_X86_IO_APIC
DECL|variable|nmi_watchdog
r_int
id|nmi_watchdog
op_assign
l_int|1
suffix:semicolon
DECL|function|setup_nmi_watchdog
r_static
r_int
id|__init
id|setup_nmi_watchdog
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|nmi_watchdog
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;nmi_watchdog=&quot;
comma
id|setup_nmi_watchdog
)paren
suffix:semicolon
DECL|variable|nmi_print_lock
r_static
id|spinlock_t
id|nmi_print_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|nmi_watchdog_tick
r_inline
r_void
id|nmi_watchdog_tick
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/*&n;&t; * the best way to detect wether a CPU has a &squot;hard lockup&squot; problem&n;&t; * is to check it&squot;s local APIC timer IRQ counts. If they are not&n;&t; * changing then that CPU has some problem.&n;&t; *&n;&t; * as these watchdog NMI IRQs are broadcasted to every CPU, here&n;&t; * we only have to check the current processor.&n;&t; *&n;&t; * since NMIs dont listen to _any_ locks, we have to be extremely&n;&t; * careful not to rely on unsafe variables. The printk might lock&n;&t; * up though, so we have to break up console_lock first ...&n;&t; * [when there will be more tty-related locks, break them up&n;&t; *  here too!]&n;&t; */
r_static
r_int
r_int
id|last_irq_sums
(braket
id|NR_CPUS
)braket
comma
id|alert_counter
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Since current-&gt; is always on the stack, and we always switch&n;&t; * the stack NMI-atomically, it&squot;s safe to use smp_processor_id().&n;&t; */
r_int
id|sum
comma
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|sum
op_assign
id|apic_timer_irqs
(braket
id|cpu
)braket
suffix:semicolon
r_if
c_cond
(paren
id|last_irq_sums
(braket
id|cpu
)braket
op_eq
id|sum
)paren
(brace
multiline_comment|/*&n;&t;&t; * Ayiee, looks like this CPU is stuck ...&n;&t;&t; * wait a few IRQs (5 seconds) before doing the oops ...&n;&t;&t; */
id|alert_counter
(braket
id|cpu
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|alert_counter
(braket
id|cpu
)braket
op_eq
l_int|5
op_star
id|HZ
)paren
(brace
id|spin_lock
c_func
(paren
op_amp
id|nmi_print_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We are in trouble anyway, lets at least try&n;&t;&t;&t; * to get a message out.&n;&t;&t;&t; */
id|bust_spinlocks
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NMI Watchdog detected LOCKUP on CPU%d, registers:&bslash;n&quot;
comma
id|cpu
)paren
suffix:semicolon
id|show_registers
c_func
(paren
id|regs
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;console shuts up ...&bslash;n&quot;
)paren
suffix:semicolon
id|console_silent
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock
c_func
(paren
op_amp
id|nmi_print_lock
)paren
suffix:semicolon
id|do_exit
c_func
(paren
id|SIGSEGV
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|last_irq_sums
(braket
id|cpu
)braket
op_assign
id|sum
suffix:semicolon
id|alert_counter
(braket
id|cpu
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|function|do_nmi
id|asmlinkage
r_void
id|do_nmi
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
r_int
r_char
id|reason
op_assign
id|inb
c_func
(paren
l_int|0x61
)paren
suffix:semicolon
op_increment
id|nmi_count
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|reason
op_amp
l_int|0xc0
)paren
)paren
(brace
macro_line|#if CONFIG_X86_IO_APIC
multiline_comment|/*&n;&t;&t; * Ok, so this is none of the documented NMI sources,&n;&t;&t; * so it must be the NMI watchdog.&n;&t;&t; */
r_if
c_cond
(paren
id|nmi_watchdog
)paren
(brace
id|nmi_watchdog_tick
c_func
(paren
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
id|unknown_nmi_error
c_func
(paren
id|reason
comma
id|regs
)paren
suffix:semicolon
macro_line|#else
id|unknown_nmi_error
c_func
(paren
id|reason
comma
id|regs
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reason
op_amp
l_int|0x80
)paren
id|mem_parity_error
c_func
(paren
id|reason
comma
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reason
op_amp
l_int|0x40
)paren
id|io_check_error
c_func
(paren
id|reason
comma
id|regs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reassert NMI in case it became active meanwhile&n;&t; * as it&squot;s edge-triggered.&n;&t; */
id|outb
c_func
(paren
l_int|0x8f
comma
l_int|0x70
)paren
suffix:semicolon
id|inb
c_func
(paren
l_int|0x71
)paren
suffix:semicolon
multiline_comment|/* dummy */
id|outb
c_func
(paren
l_int|0x0f
comma
l_int|0x70
)paren
suffix:semicolon
id|inb
c_func
(paren
l_int|0x71
)paren
suffix:semicolon
multiline_comment|/* dummy */
)brace
multiline_comment|/*&n; * Our handling of the processor debug registers is non-trivial.&n; * We do not clear them on entry and exit from the kernel. Therefore&n; * it is possible to get a watchpoint trap here from inside the kernel.&n; * However, the code in ./ptrace.c has ensured that the user can&n; * only set watchpoints on userspace addresses. Therefore the in-kernel&n; * watchpoint trap can only occur in code which is reading/writing&n; * from user space. Such code must not hold kernel locks (since it&n; * can equally take a page fault), therefore it is safe to call&n; * force_sig_info even though that claims and releases locks.&n; * &n; * Code in ./signal.c ensures that the debug control register&n; * is restored before we deliver any signal, and therefore that&n; * user code runs with the correct debug control register even though&n; * we clear it here.&n; *&n; * Being careful here means that we don&squot;t have to be as careful in a&n; * lot of more complicated places (task switching can be a bit lazy&n; * about restoring all the debug state, and ptrace doesn&squot;t have to&n; * find every occurrence of the TF bit that could be saved away even&n; * by user code)&n; */
DECL|function|do_debug
id|asmlinkage
r_void
id|do_debug
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
r_int
r_int
id|condition
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|siginfo_t
id|info
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;movl %%db6,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|condition
)paren
)paren
suffix:semicolon
multiline_comment|/* Mask out spurious debug traps due to lazy DR7 setting */
r_if
c_cond
(paren
id|condition
op_amp
(paren
id|DR_TRAP0
op_or
id|DR_TRAP1
op_or
id|DR_TRAP2
op_or
id|DR_TRAP3
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tsk-&gt;thread.debugreg
(braket
l_int|7
)braket
)paren
r_goto
id|clear_dr7
suffix:semicolon
)brace
r_if
c_cond
(paren
id|regs-&gt;eflags
op_amp
id|VM_MASK
)paren
r_goto
id|debug_vm86
suffix:semicolon
multiline_comment|/* Save debug status register where ptrace can see it */
id|tsk-&gt;thread.debugreg
(braket
l_int|6
)braket
op_assign
id|condition
suffix:semicolon
multiline_comment|/* Mask out spurious TF errors due to lazy TF clearing */
r_if
c_cond
(paren
id|condition
op_amp
id|DR_STEP
)paren
(brace
multiline_comment|/*&n;&t;&t; * The TF error should be masked out only if the current&n;&t;&t; * process is not traced and if the TRAP flag has been set&n;&t;&t; * previously by a tracing process (condition detected by&n;&t;&t; * the PT_DTRACE flag); remember that the i386 TRAP flag&n;&t;&t; * can be modified by the process itself in user mode,&n;&t;&t; * allowing programs to debug themselves without the ptrace()&n;&t;&t; * interface.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|tsk-&gt;ptrace
op_amp
(paren
id|PT_DTRACE
op_or
id|PT_PTRACED
)paren
)paren
op_eq
id|PT_DTRACE
)paren
r_goto
id|clear_TF
suffix:semicolon
)brace
multiline_comment|/* Ok, finally something we can handle */
id|tsk-&gt;thread.trap_no
op_assign
l_int|1
suffix:semicolon
id|tsk-&gt;thread.error_code
op_assign
id|error_code
suffix:semicolon
id|info.si_signo
op_assign
id|SIGTRAP
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|TRAP_BRKPT
suffix:semicolon
multiline_comment|/* If this is a kernel mode trap, save the user PC on entry to &n;&t; * the kernel, that&squot;s what the debugger can make sense of.&n;&t; */
id|info.si_addr
op_assign
(paren
(paren
id|regs-&gt;xcs
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
ques
c_cond
(paren
r_void
op_star
)paren
id|tsk-&gt;thread.eip
suffix:colon
(paren
r_void
op_star
)paren
id|regs-&gt;eip
suffix:semicolon
id|force_sig_info
c_func
(paren
id|SIGTRAP
comma
op_amp
id|info
comma
id|tsk
)paren
suffix:semicolon
multiline_comment|/* Disable additional traps. They&squot;ll be re-enabled when&n;&t; * the signal is delivered.&n;&t; */
id|clear_dr7
suffix:colon
id|__asm__
c_func
(paren
l_string|&quot;movl %0,%%db7&quot;
suffix:colon
multiline_comment|/* no output */
suffix:colon
l_string|&quot;r&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|debug_vm86
suffix:colon
id|handle_vm86_trap
c_func
(paren
(paren
r_struct
id|kernel_vm86_regs
op_star
)paren
id|regs
comma
id|error_code
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
id|clear_TF
suffix:colon
id|regs-&gt;eflags
op_and_assign
op_complement
id|TF_MASK
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Note that we play around with the &squot;TS&squot; bit in an attempt to get&n; * the correct behaviour even in the presence of the asynchronous&n; * IRQ13 behaviour&n; */
DECL|function|math_error
r_void
id|math_error
c_func
(paren
r_void
op_star
id|eip
)paren
(brace
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
id|siginfo_t
id|info
suffix:semicolon
r_int
r_int
id|cwd
comma
id|swd
suffix:semicolon
multiline_comment|/*&n;&t; * Save the info for the exception handler and clear the error.&n;&t; */
id|task
op_assign
id|current
suffix:semicolon
id|save_init_fpu
c_func
(paren
id|task
)paren
suffix:semicolon
id|task-&gt;thread.trap_no
op_assign
l_int|16
suffix:semicolon
id|task-&gt;thread.error_code
op_assign
l_int|0
suffix:semicolon
id|info.si_signo
op_assign
id|SIGFPE
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|__SI_FAULT
suffix:semicolon
id|info.si_addr
op_assign
id|eip
suffix:semicolon
multiline_comment|/*&n;&t; * (~cwd &amp; swd) will mask out exceptions that are not set to unmasked&n;&t; * status.  0x3f is the exception bits in these regs, 0x200 is the&n;&t; * C1 reg you need in case of a stack fault, 0x040 is the stack&n;&t; * fault bit.  We should only be taking one exception at a time,&n;&t; * so if this combination doesn&squot;t produce any single exception,&n;&t; * then we have a bad program that isn&squot;t syncronizing its FPU usage&n;&t; * and it will suffer the consequences since we won&squot;t be able to&n;&t; * fully reproduce the context of the exception&n;&t; */
id|cwd
op_assign
id|get_fpu_cwd
c_func
(paren
id|task
)paren
suffix:semicolon
id|swd
op_assign
id|get_fpu_swd
c_func
(paren
id|task
)paren
suffix:semicolon
r_switch
c_cond
(paren
(paren
(paren
op_complement
id|cwd
)paren
op_amp
id|swd
op_amp
l_int|0x3f
)paren
op_or
(paren
id|swd
op_amp
l_int|0x240
)paren
)paren
(brace
r_case
l_int|0x000
suffix:colon
r_default
suffix:colon
r_break
suffix:semicolon
r_case
l_int|0x001
suffix:colon
multiline_comment|/* Invalid Op */
r_case
l_int|0x040
suffix:colon
multiline_comment|/* Stack Fault */
r_case
l_int|0x240
suffix:colon
multiline_comment|/* Stack Fault | Direction */
id|info.si_code
op_assign
id|FPE_FLTINV
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x002
suffix:colon
multiline_comment|/* Denormalize */
r_case
l_int|0x010
suffix:colon
multiline_comment|/* Underflow */
id|info.si_code
op_assign
id|FPE_FLTUND
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x004
suffix:colon
multiline_comment|/* Zero Divide */
id|info.si_code
op_assign
id|FPE_FLTDIV
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x008
suffix:colon
multiline_comment|/* Overflow */
id|info.si_code
op_assign
id|FPE_FLTOVF
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x020
suffix:colon
multiline_comment|/* Precision */
id|info.si_code
op_assign
id|FPE_FLTRES
suffix:semicolon
r_break
suffix:semicolon
)brace
id|force_sig_info
c_func
(paren
id|SIGFPE
comma
op_amp
id|info
comma
id|task
)paren
suffix:semicolon
)brace
DECL|function|do_coprocessor_error
id|asmlinkage
r_void
id|do_coprocessor_error
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
id|ignore_irq13
op_assign
l_int|1
suffix:semicolon
id|math_error
c_func
(paren
(paren
r_void
op_star
)paren
id|regs-&gt;eip
)paren
suffix:semicolon
)brace
DECL|function|simd_math_error
r_void
id|simd_math_error
c_func
(paren
r_void
op_star
id|eip
)paren
(brace
r_struct
id|task_struct
op_star
id|task
suffix:semicolon
id|siginfo_t
id|info
suffix:semicolon
r_int
r_int
id|mxcsr
suffix:semicolon
multiline_comment|/*&n;&t; * Save the info for the exception handler and clear the error.&n;&t; */
id|task
op_assign
id|current
suffix:semicolon
id|save_init_fpu
c_func
(paren
id|task
)paren
suffix:semicolon
id|task-&gt;thread.trap_no
op_assign
l_int|19
suffix:semicolon
id|task-&gt;thread.error_code
op_assign
l_int|0
suffix:semicolon
id|info.si_signo
op_assign
id|SIGFPE
suffix:semicolon
id|info.si_errno
op_assign
l_int|0
suffix:semicolon
id|info.si_code
op_assign
id|__SI_FAULT
suffix:semicolon
id|info.si_addr
op_assign
id|eip
suffix:semicolon
multiline_comment|/*&n;&t; * The SIMD FPU exceptions are handled a little differently, as there&n;&t; * is only a single status/control register.  Thus, to determine which&n;&t; * unmasked exception was caught we must mask the exception mask bits&n;&t; * at 0x1f80, and then use these to mask the exception bits at 0x3f.&n;&t; */
id|mxcsr
op_assign
id|get_fpu_mxcsr
c_func
(paren
id|task
)paren
suffix:semicolon
r_switch
c_cond
(paren
op_complement
(paren
(paren
id|mxcsr
op_amp
l_int|0x1f80
)paren
op_rshift
l_int|7
)paren
op_amp
(paren
id|mxcsr
op_amp
l_int|0x3f
)paren
)paren
(brace
r_case
l_int|0x000
suffix:colon
r_default
suffix:colon
r_break
suffix:semicolon
r_case
l_int|0x001
suffix:colon
multiline_comment|/* Invalid Op */
id|info.si_code
op_assign
id|FPE_FLTINV
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x002
suffix:colon
multiline_comment|/* Denormalize */
r_case
l_int|0x010
suffix:colon
multiline_comment|/* Underflow */
id|info.si_code
op_assign
id|FPE_FLTUND
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x004
suffix:colon
multiline_comment|/* Zero Divide */
id|info.si_code
op_assign
id|FPE_FLTDIV
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x008
suffix:colon
multiline_comment|/* Overflow */
id|info.si_code
op_assign
id|FPE_FLTOVF
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x020
suffix:colon
multiline_comment|/* Precision */
id|info.si_code
op_assign
id|FPE_FLTRES
suffix:semicolon
r_break
suffix:semicolon
)brace
id|force_sig_info
c_func
(paren
id|SIGFPE
comma
op_amp
id|info
comma
id|task
)paren
suffix:semicolon
)brace
DECL|function|do_simd_coprocessor_error
id|asmlinkage
r_void
id|do_simd_coprocessor_error
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
r_if
c_cond
(paren
id|cpu_has_xmm
)paren
(brace
multiline_comment|/* Handle SIMD FPU exceptions on PIII+ processors. */
id|ignore_irq13
op_assign
l_int|1
suffix:semicolon
id|simd_math_error
c_func
(paren
(paren
r_void
op_star
)paren
id|regs-&gt;eip
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Handle strange cache flush from user space exception&n;&t;&t; * in all other cases.  This is undocumented behaviour.&n;&t;&t; */
r_if
c_cond
(paren
id|regs-&gt;eflags
op_amp
id|VM_MASK
)paren
(brace
id|handle_vm86_fault
c_func
(paren
(paren
r_struct
id|kernel_vm86_regs
op_star
)paren
id|regs
comma
id|error_code
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|die_if_kernel
c_func
(paren
l_string|&quot;cache flush denied&quot;
comma
id|regs
comma
id|error_code
)paren
suffix:semicolon
id|current-&gt;thread.trap_no
op_assign
l_int|19
suffix:semicolon
id|current-&gt;thread.error_code
op_assign
id|error_code
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGSEGV
comma
id|current
)paren
suffix:semicolon
)brace
)brace
DECL|function|do_spurious_interrupt_bug
id|asmlinkage
r_void
id|do_spurious_interrupt_bug
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
id|error_code
)paren
(brace
macro_line|#if 0
multiline_comment|/* No need to warn about this any longer. */
id|printk
c_func
(paren
l_string|&quot;Ignoring P6 Local APIC Spurious Interrupt Bug...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; *  &squot;math_state_restore()&squot; saves the current math information in the&n; * old math state array, and gets the new ones from the current task&n; *&n; * Careful.. There are problems with IBM-designed IRQ13 behaviour.&n; * Don&squot;t touch unless you *really* know how it works.&n; */
DECL|function|math_state_restore
id|asmlinkage
r_void
id|math_state_restore
c_func
(paren
r_struct
id|pt_regs
id|regs
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;clts&quot;
)paren
suffix:semicolon
multiline_comment|/* Allow maths ops (or we recurse) */
r_if
c_cond
(paren
id|current-&gt;used_math
)paren
(brace
id|restore_fpu
c_func
(paren
id|current
)paren
suffix:semicolon
)brace
r_else
(brace
id|init_fpu
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;flags
op_or_assign
id|PF_USEDFPU
suffix:semicolon
multiline_comment|/* So we fnsave on switch_to() */
)brace
macro_line|#ifndef CONFIG_MATH_EMULATION
DECL|function|math_emulate
id|asmlinkage
r_void
id|math_emulate
c_func
(paren
r_int
id|arg
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;math-emulation not enabled and no coprocessor found.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;killing %s.&bslash;n&quot;
comma
id|current-&gt;comm
)paren
suffix:semicolon
id|force_sig
c_func
(paren
id|SIGFPE
comma
id|current
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_MATH_EMULATION */
macro_line|#ifndef CONFIG_M686
DECL|function|trap_init_f00f_bug
r_void
id|__init
id|trap_init_f00f_bug
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|page
suffix:semicolon
id|pgd_t
op_star
id|pgd
suffix:semicolon
id|pmd_t
op_star
id|pmd
suffix:semicolon
id|pte_t
op_star
id|pte
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate a new page in virtual address space, &n;&t; * move the IDT into it and write protect this page.&n;&t; */
id|page
op_assign
(paren
r_int
r_int
)paren
id|vmalloc
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
id|pgd
op_assign
id|pgd_offset
c_func
(paren
op_amp
id|init_mm
comma
id|page
)paren
suffix:semicolon
id|pmd
op_assign
id|pmd_offset
c_func
(paren
id|pgd
comma
id|page
)paren
suffix:semicolon
id|pte
op_assign
id|pte_offset
c_func
(paren
id|pmd
comma
id|page
)paren
suffix:semicolon
id|__free_page
c_func
(paren
id|pte_page
c_func
(paren
op_star
id|pte
)paren
)paren
suffix:semicolon
op_star
id|pte
op_assign
id|mk_pte_phys
c_func
(paren
id|__pa
c_func
(paren
op_amp
id|idt_table
)paren
comma
id|PAGE_KERNEL_RO
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Not that any PGE-capable kernel should have the f00f bug ...&n;&t; */
id|__flush_tlb_all
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * &quot;idt&quot; is magic - it overlaps the idt_descr&n;&t; * variable so that updating idt will automatically&n;&t; * update the idt descriptor..&n;&t; */
id|idt
op_assign
(paren
r_struct
id|desc_struct
op_star
)paren
id|page
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;lidt %0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
id|idt_descr
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|macro|_set_gate
mdefine_line|#define _set_gate(gate_addr,type,dpl,addr) &bslash;&n;do { &bslash;&n;  int __d0, __d1; &bslash;&n;  __asm__ __volatile__ (&quot;movw %%dx,%%ax&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movw %4,%%dx&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movl %%eax,%0&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movl %%edx,%1&quot; &bslash;&n;&t;:&quot;=m&quot; (*((long *) (gate_addr))), &bslash;&n;&t; &quot;=m&quot; (*(1+(long *) (gate_addr))), &quot;=&amp;a&quot; (__d0), &quot;=&amp;d&quot; (__d1) &bslash;&n;&t;:&quot;i&quot; ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), &bslash;&n;&t; &quot;3&quot; ((char *) (addr)),&quot;2&quot; (__KERNEL_CS &lt;&lt; 16)); &bslash;&n;} while (0)
multiline_comment|/*&n; * This needs to use &squot;idt_table&squot; rather than &squot;idt&squot;, and&n; * thus use the _nonmapped_ version of the IDT, as the&n; * Pentium F0 0F bugfix can have resulted in the mapped&n; * IDT being write-protected.&n; */
DECL|function|set_intr_gate
r_void
id|set_intr_gate
c_func
(paren
r_int
r_int
id|n
comma
r_void
op_star
id|addr
)paren
(brace
id|_set_gate
c_func
(paren
id|idt_table
op_plus
id|n
comma
l_int|14
comma
l_int|0
comma
id|addr
)paren
suffix:semicolon
)brace
DECL|function|set_trap_gate
r_static
r_void
id|__init
id|set_trap_gate
c_func
(paren
r_int
r_int
id|n
comma
r_void
op_star
id|addr
)paren
(brace
id|_set_gate
c_func
(paren
id|idt_table
op_plus
id|n
comma
l_int|15
comma
l_int|0
comma
id|addr
)paren
suffix:semicolon
)brace
DECL|function|set_system_gate
r_static
r_void
id|__init
id|set_system_gate
c_func
(paren
r_int
r_int
id|n
comma
r_void
op_star
id|addr
)paren
(brace
id|_set_gate
c_func
(paren
id|idt_table
op_plus
id|n
comma
l_int|15
comma
l_int|3
comma
id|addr
)paren
suffix:semicolon
)brace
DECL|function|set_call_gate
r_static
r_void
id|__init
id|set_call_gate
c_func
(paren
r_void
op_star
id|a
comma
r_void
op_star
id|addr
)paren
(brace
id|_set_gate
c_func
(paren
id|a
comma
l_int|12
comma
l_int|3
comma
id|addr
)paren
suffix:semicolon
)brace
DECL|macro|_set_seg_desc
mdefine_line|#define _set_seg_desc(gate_addr,type,dpl,base,limit) {&bslash;&n;&t;*((gate_addr)+1) = ((base) &amp; 0xff000000) | &bslash;&n;&t;&t;(((base) &amp; 0x00ff0000)&gt;&gt;16) | &bslash;&n;&t;&t;((limit) &amp; 0xf0000) | &bslash;&n;&t;&t;((dpl)&lt;&lt;13) | &bslash;&n;&t;&t;(0x00408000) | &bslash;&n;&t;&t;((type)&lt;&lt;8); &bslash;&n;&t;*(gate_addr) = (((base) &amp; 0x0000ffff)&lt;&lt;16) | &bslash;&n;&t;&t;((limit) &amp; 0x0ffff); }
DECL|macro|_set_tssldt_desc
mdefine_line|#define _set_tssldt_desc(n,addr,limit,type) &bslash;&n;__asm__ __volatile__ (&quot;movw %w3,0(%2)&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movw %%ax,2(%2)&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;rorl $16,%%eax&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movb %%al,4(%2)&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movb %4,5(%2)&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movb $0,6(%2)&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;movb %%ah,7(%2)&bslash;n&bslash;t&quot; &bslash;&n;&t;&quot;rorl $16,%%eax&quot; &bslash;&n;&t;: &quot;=m&quot;(*(n)) : &quot;a&quot; (addr), &quot;r&quot;(n), &quot;ir&quot;(limit), &quot;i&quot;(type))
DECL|function|set_tss_desc
r_void
id|set_tss_desc
c_func
(paren
r_int
r_int
id|n
comma
r_void
op_star
id|addr
)paren
(brace
id|_set_tssldt_desc
c_func
(paren
id|gdt_table
op_plus
id|__TSS
c_func
(paren
id|n
)paren
comma
(paren
r_int
)paren
id|addr
comma
l_int|235
comma
l_int|0x89
)paren
suffix:semicolon
)brace
DECL|function|set_ldt_desc
r_void
id|set_ldt_desc
c_func
(paren
r_int
r_int
id|n
comma
r_void
op_star
id|addr
comma
r_int
r_int
id|size
)paren
(brace
id|_set_tssldt_desc
c_func
(paren
id|gdt_table
op_plus
id|__LDT
c_func
(paren
id|n
)paren
comma
(paren
r_int
)paren
id|addr
comma
(paren
(paren
id|size
op_lshift
l_int|3
)paren
op_minus
l_int|1
)paren
comma
l_int|0x82
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_X86_VISWS_APIC
multiline_comment|/*&n; * On Rev 005 motherboards legacy device interrupt lines are wired directly&n; * to Lithium from the 307.  But the PROM leaves the interrupt type of each&n; * 307 logical device set appropriate for the 8259.  Later we&squot;ll actually use&n; * the 8259, but for now we have to flip the interrupt types to&n; * level triggered, active lo as required by Lithium.&n; */
DECL|macro|REG
mdefine_line|#define&t;REG&t;0x2e&t;/* The register to read/write */
DECL|macro|DEV
mdefine_line|#define&t;DEV&t;0x07&t;/* Register: Logical device select */
DECL|macro|VAL
mdefine_line|#define&t;VAL&t;0x2f&t;/* The value to read/write */
r_static
r_void
DECL|function|superio_outb
id|superio_outb
c_func
(paren
r_int
id|dev
comma
r_int
id|reg
comma
r_int
id|val
)paren
(brace
id|outb
c_func
(paren
id|DEV
comma
id|REG
)paren
suffix:semicolon
id|outb
c_func
(paren
id|dev
comma
id|VAL
)paren
suffix:semicolon
id|outb
c_func
(paren
id|reg
comma
id|REG
)paren
suffix:semicolon
id|outb
c_func
(paren
id|val
comma
id|VAL
)paren
suffix:semicolon
)brace
r_static
r_int
id|__attribute__
(paren
(paren
id|unused
)paren
)paren
DECL|function|superio_inb
id|superio_inb
c_func
(paren
r_int
id|dev
comma
r_int
id|reg
)paren
(brace
id|outb
c_func
(paren
id|DEV
comma
id|REG
)paren
suffix:semicolon
id|outb
c_func
(paren
id|dev
comma
id|VAL
)paren
suffix:semicolon
id|outb
c_func
(paren
id|reg
comma
id|REG
)paren
suffix:semicolon
r_return
id|inb
c_func
(paren
id|VAL
)paren
suffix:semicolon
)brace
DECL|macro|FLOP
mdefine_line|#define&t;FLOP&t;3&t;/* floppy logical device */
DECL|macro|PPORT
mdefine_line|#define&t;PPORT&t;4&t;/* parallel logical device */
DECL|macro|UART5
mdefine_line|#define&t;UART5&t;5&t;/* uart2 logical device (not wired up) */
DECL|macro|UART6
mdefine_line|#define&t;UART6&t;6&t;/* uart1 logical device (THIS is the serial port!) */
DECL|macro|IDEST
mdefine_line|#define&t;IDEST&t;0x70&t;/* int. destination (which 307 IRQ line) reg. */
DECL|macro|ITYPE
mdefine_line|#define&t;ITYPE&t;0x71&t;/* interrupt type register */
multiline_comment|/* interrupt type bits */
DECL|macro|LEVEL
mdefine_line|#define&t;LEVEL&t;0x01&t;/* bit 0, 0 == edge triggered */
DECL|macro|ACTHI
mdefine_line|#define&t;ACTHI&t;0x02&t;/* bit 1, 0 == active lo */
r_static
r_void
DECL|function|superio_init
id|superio_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|visws_board_type
op_eq
id|VISWS_320
op_logical_and
id|visws_board_rev
op_eq
l_int|5
)paren
(brace
id|superio_outb
c_func
(paren
id|UART6
comma
id|IDEST
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* 0 means no intr propagated */
id|printk
c_func
(paren
l_string|&quot;SGI 320 rev 5: disabling 307 uart1 interrupt&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|lithium_init
id|lithium_init
c_func
(paren
r_void
)paren
(brace
id|set_fixmap
c_func
(paren
id|FIX_LI_PCIA
comma
id|LI_PCI_A_PHYS
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Lithium PCI Bridge A, Bus Number: %d&bslash;n&quot;
comma
id|li_pcia_read16
c_func
(paren
id|LI_PCI_BUSNUM
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|set_fixmap
c_func
(paren
id|FIX_LI_PCIB
comma
id|LI_PCI_B_PHYS
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Lithium PCI Bridge B (PIIX4), Bus Number: %d&bslash;n&quot;
comma
id|li_pcib_read16
c_func
(paren
id|LI_PCI_BUSNUM
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* XXX blindly enables all interrupts */
id|li_pcia_write16
c_func
(paren
id|LI_PCI_INTEN
comma
l_int|0xffff
)paren
suffix:semicolon
id|li_pcib_write16
c_func
(paren
id|LI_PCI_INTEN
comma
l_int|0xffff
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|cobalt_init
id|cobalt_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * On normal SMP PC this is used only with SMP, but we have to&n;&t; * use it and set it up here to start the Cobalt clock&n;&t; */
id|set_fixmap
c_func
(paren
id|FIX_APIC_BASE
comma
id|APIC_DEFAULT_PHYS_BASE
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Local APIC ID %lx&bslash;n&quot;
comma
id|apic_read
c_func
(paren
id|APIC_ID
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Local APIC Version %lx&bslash;n&quot;
comma
id|apic_read
c_func
(paren
id|APIC_LVR
)paren
)paren
suffix:semicolon
id|set_fixmap
c_func
(paren
id|FIX_CO_CPU
comma
id|CO_CPU_PHYS
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Cobalt Revision %lx&bslash;n&quot;
comma
id|co_cpu_read
c_func
(paren
id|CO_CPU_REV
)paren
)paren
suffix:semicolon
id|set_fixmap
c_func
(paren
id|FIX_CO_APIC
comma
id|CO_APIC_PHYS
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Cobalt APIC ID %lx&bslash;n&quot;
comma
id|co_apic_read
c_func
(paren
id|CO_APIC_ID
)paren
)paren
suffix:semicolon
multiline_comment|/* Enable Cobalt APIC being careful to NOT change the ID! */
id|co_apic_write
c_func
(paren
id|CO_APIC_ID
comma
id|co_apic_read
c_func
(paren
id|CO_APIC_ID
)paren
op_or
id|CO_APIC_ENABLE
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Cobalt APIC enabled: ID reg %lx&bslash;n&quot;
comma
id|co_apic_read
c_func
(paren
id|CO_APIC_ID
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|trap_init
r_void
id|__init
id|trap_init
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_EISA
r_if
c_cond
(paren
id|isa_readl
c_func
(paren
l_int|0x0FFFD9
)paren
op_eq
l_char|&squot;E&squot;
op_plus
(paren
l_char|&squot;I&squot;
op_lshift
l_int|8
)paren
op_plus
(paren
l_char|&squot;S&squot;
op_lshift
l_int|16
)paren
op_plus
(paren
l_char|&squot;A&squot;
op_lshift
l_int|24
)paren
)paren
id|EISA_bus
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|set_trap_gate
c_func
(paren
l_int|0
comma
op_amp
id|divide_error
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|1
comma
op_amp
id|debug
)paren
suffix:semicolon
id|set_intr_gate
c_func
(paren
l_int|2
comma
op_amp
id|nmi
)paren
suffix:semicolon
id|set_system_gate
c_func
(paren
l_int|3
comma
op_amp
id|int3
)paren
suffix:semicolon
multiline_comment|/* int3-5 can be called from all */
id|set_system_gate
c_func
(paren
l_int|4
comma
op_amp
id|overflow
)paren
suffix:semicolon
id|set_system_gate
c_func
(paren
l_int|5
comma
op_amp
id|bounds
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|6
comma
op_amp
id|invalid_op
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|7
comma
op_amp
id|device_not_available
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|8
comma
op_amp
id|double_fault
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|9
comma
op_amp
id|coprocessor_segment_overrun
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|10
comma
op_amp
id|invalid_TSS
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|11
comma
op_amp
id|segment_not_present
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|12
comma
op_amp
id|stack_segment
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|13
comma
op_amp
id|general_protection
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|14
comma
op_amp
id|page_fault
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|15
comma
op_amp
id|spurious_interrupt_bug
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|16
comma
op_amp
id|coprocessor_error
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|17
comma
op_amp
id|alignment_check
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|18
comma
op_amp
id|machine_check
)paren
suffix:semicolon
id|set_trap_gate
c_func
(paren
l_int|19
comma
op_amp
id|simd_coprocessor_error
)paren
suffix:semicolon
id|set_system_gate
c_func
(paren
id|SYSCALL_VECTOR
comma
op_amp
id|system_call
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * default LDT is a single-entry callgate to lcall7 for iBCS&n;&t; * and a callgate to lcall27 for Solaris/x86 binaries&n;&t; */
id|set_call_gate
c_func
(paren
op_amp
id|default_ldt
(braket
l_int|0
)braket
comma
id|lcall7
)paren
suffix:semicolon
id|set_call_gate
c_func
(paren
op_amp
id|default_ldt
(braket
l_int|4
)braket
comma
id|lcall27
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Should be a barrier for any external CPU state.&n;&t; */
id|cpu_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_X86_VISWS_APIC
id|superio_init
c_func
(paren
)paren
suffix:semicolon
id|lithium_init
c_func
(paren
)paren
suffix:semicolon
id|cobalt_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
