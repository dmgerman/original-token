multiline_comment|/*&n; *&t;Intel MP v1.1/v1.4 specification compliant parsing routines.&n; *&n; *&t;(c) 1995 Alan Cox, Building #3 &lt;alan@redhat.com&gt;&n; *&t;(c) 1998, 1999 Ingo Molnar &lt;mingo@redhat.com&gt;&n; *&n; *&t;Much of the core SMP work is based on previous work by Thomas Radke, to&n; *&t;whom a great many thanks are extended.&n; *&n; *&t;Thanks to Intel for making available several different Pentium,&n; *&t;Pentium Pro and Pentium-II/Xeon MP machines.&n; *&t;Original development of Linux SMP code supported by Caldera.&n; *&n; *&t;This code is released under the GNU public license version 2 or&n; *&t;later.&n; *&n; *&t;Fixes&n; *&t;&t;Felix Koop&t;:&t;NR_CPUS used properly&n; *&t;&t;Jose Renau&t;:&t;Handle single CPU case.&n; *&t;&t;Alan Cox&t;:&t;By repeated request 8) - Total BogoMIP report.&n; *&t;&t;Greg Wright&t;:&t;Fix for kernel stacks panic.&n; *&t;&t;Erich Boleyn&t;:&t;MP v1.4 and additional changes.&n; *&t;Matthias Sattler&t;:&t;Changes for 2.1 kernel map.&n; *&t;Michel Lespinasse&t;:&t;Changes for 2.1 kernel map.&n; *&t;Michael Chastain&t;:&t;Change trampoline.S to gnu as.&n; *&t;&t;Alan Cox&t;:&t;Dumb bug: &squot;B&squot; step PPro&squot;s are fine&n; *&t;&t;Ingo Molnar&t;:&t;Added APIC timers, based on code&n; *&t;&t;&t;&t;&t;from Jose Renau&n; *&t;&t;Alan Cox&t;:&t;Added EBDA scanning&n; *&t;&t;Ingo Molnar&t;:&t;various cleanups and rewrites&n; *&t;&t;Tigran Aivazian&t;:&t;fixed &quot;0.00 in /proc/uptime on SMP&quot; bug.&n; *&t;Maciej W. Rozycki&t;:&t;Bits for genuine 82489DX timers&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;linux/bootmem.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/mc146818rtc.h&gt;
macro_line|#include &lt;asm/mtrr.h&gt;
macro_line|#include &lt;asm/pgalloc.h&gt;
multiline_comment|/* Set if we find a B stepping CPU&t;&t;&t;*/
DECL|variable|smp_b_stepping
r_static
r_int
id|smp_b_stepping
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Setup configured maximum number of CPUs to activate */
DECL|variable|max_cpus
r_static
r_int
id|max_cpus
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* 1 if &quot;noapic&quot; boot option passed */
DECL|variable|skip_ioapic_setup
r_int
id|skip_ioapic_setup
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Total count of live CPUs */
DECL|variable|smp_num_cpus
r_int
id|smp_num_cpus
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Internal processor count */
DECL|variable|num_processors
r_static
r_int
r_int
id|num_processors
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Have we found an SMP box */
DECL|variable|smp_found_config
r_int
id|smp_found_config
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Bitmask of physically existing CPUs */
DECL|variable|cpu_present_map
r_int
r_int
id|cpu_present_map
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Bitmask of currently online CPUs */
DECL|variable|cpu_online_map
r_int
r_int
id|cpu_online_map
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* which CPU maps to which logical number */
DECL|variable|cpu_number_map
r_volatile
r_int
id|cpu_number_map
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* which logical number maps to which CPU */
DECL|variable|__cpu_logical_map
r_volatile
r_int
id|__cpu_logical_map
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|cpu_callin_map
r_static
r_volatile
r_int
r_int
id|cpu_callin_map
op_assign
l_int|0
suffix:semicolon
DECL|variable|cpu_callout_map
r_static
r_volatile
r_int
r_int
id|cpu_callout_map
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Per CPU bogomips and other parameters */
DECL|variable|cpu_data
r_struct
id|cpuinfo_x86
id|cpu_data
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* Processor that is doing the boot up */
DECL|variable|boot_cpu_id
r_static
r_int
r_int
id|boot_cpu_id
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set when the idlers are all forked */
DECL|variable|smp_threads_ready
r_int
id|smp_threads_ready
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Various Linux-internal data structures created from the&n; * MP-table.&n; */
DECL|variable|apic_version
r_int
id|apic_version
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|mp_bus_id_to_type
r_int
id|mp_bus_id_to_type
(braket
id|MAX_MP_BUSSES
)braket
op_assign
(brace
op_minus
l_int|1
comma
)brace
suffix:semicolon
r_extern
r_int
id|nr_ioapics
suffix:semicolon
r_extern
r_struct
id|mpc_config_ioapic
id|mp_ioapics
(braket
id|MAX_IO_APICS
)braket
suffix:semicolon
r_extern
r_int
id|mp_irq_entries
suffix:semicolon
r_extern
r_struct
id|mpc_config_intsrc
id|mp_irqs
(braket
id|MAX_IRQ_SOURCES
)braket
suffix:semicolon
r_extern
r_int
id|mpc_default_type
suffix:semicolon
DECL|variable|mp_bus_id_to_pci_bus
r_int
id|mp_bus_id_to_pci_bus
(braket
id|MAX_MP_BUSSES
)braket
op_assign
(brace
op_minus
l_int|1
comma
)brace
suffix:semicolon
DECL|variable|mp_current_pci_id
r_int
id|mp_current_pci_id
op_assign
l_int|0
suffix:semicolon
DECL|variable|mp_lapic_addr
r_int
r_int
id|mp_lapic_addr
op_assign
l_int|0
suffix:semicolon
DECL|variable|pic_mode
r_int
id|pic_mode
suffix:semicolon
r_extern
r_void
id|cache_APIC_registers
(paren
r_void
)paren
suffix:semicolon
DECL|macro|SMP_DEBUG
mdefine_line|#define SMP_DEBUG 1
macro_line|#if SMP_DEBUG
DECL|macro|dprintk
mdefine_line|#define dprintk(x...) printk(##x)
macro_line|#else
DECL|macro|dprintk
mdefine_line|#define dprintk(x...)
macro_line|#endif
multiline_comment|/*&n; * IA s/w dev Vol 3, Section 7.4&n; */
DECL|macro|APIC_DEFAULT_PHYS_BASE
mdefine_line|#define APIC_DEFAULT_PHYS_BASE 0xfee00000
multiline_comment|/*&n; * Setup routine for controlling SMP activation&n; *&n; * Command-line option of &quot;nosmp&quot; or &quot;maxcpus=0&quot; will disable SMP&n; * activation entirely (the MPS table probe still happens, though).&n; *&n; * Command-line option of &quot;maxcpus=&lt;NUM&gt;&quot;, where &lt;NUM&gt; is an integer&n; * greater than 0, limits the maximum number of CPUs activated in&n; * SMP mode to &lt;NUM&gt;.&n; */
DECL|function|nosmp
r_static
r_int
id|__init
id|nosmp
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|max_cpus
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;nosmp&quot;
comma
id|nosmp
)paren
suffix:semicolon
DECL|function|maxcpus
r_static
r_int
id|__init
id|maxcpus
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|get_option
c_func
(paren
op_amp
id|str
comma
op_amp
id|max_cpus
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;maxcpus=&quot;
comma
id|maxcpus
)paren
suffix:semicolon
multiline_comment|/*&n; * Intel MP BIOS table parsing routines:&n; */
macro_line|#ifndef CONFIG_X86_VISWS_APIC
multiline_comment|/*&n; * Checksum an MP configuration block.&n; */
DECL|function|mpf_checksum
r_static
r_int
id|__init
id|mpf_checksum
c_func
(paren
r_int
r_char
op_star
id|mp
comma
r_int
id|len
)paren
(brace
r_int
id|sum
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
id|sum
op_add_assign
op_star
id|mp
op_increment
suffix:semicolon
)brace
r_return
id|sum
op_amp
l_int|0xFF
suffix:semicolon
)brace
multiline_comment|/*&n; * Processor encoding in an MP configuration block&n; */
DECL|function|mpc_family
r_static
r_char
id|__init
op_star
id|mpc_family
c_func
(paren
r_int
id|family
comma
r_int
id|model
)paren
(brace
r_static
r_char
id|n
(braket
l_int|32
)braket
suffix:semicolon
r_static
r_char
op_star
id|model_defs
(braket
)braket
op_assign
(brace
l_string|&quot;80486DX&quot;
comma
l_string|&quot;80486DX&quot;
comma
l_string|&quot;80486SX&quot;
comma
l_string|&quot;80486DX/2 or 80487&quot;
comma
l_string|&quot;80486SL&quot;
comma
l_string|&quot;80486SX/2&quot;
comma
l_string|&quot;Unknown&quot;
comma
l_string|&quot;80486DX/2-WB&quot;
comma
l_string|&quot;80486DX/4&quot;
comma
l_string|&quot;80486DX/4-WB&quot;
)brace
suffix:semicolon
r_switch
c_cond
(paren
id|family
)paren
(brace
r_case
l_int|0x04
suffix:colon
r_if
c_cond
(paren
id|model
OL
l_int|10
)paren
r_return
id|model_defs
(braket
id|model
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x05
suffix:colon
r_return
l_string|&quot;Pentium(tm)&quot;
suffix:semicolon
r_case
l_int|0x06
suffix:colon
r_return
l_string|&quot;Pentium(tm) Pro&quot;
suffix:semicolon
r_case
l_int|0x0F
suffix:colon
r_if
c_cond
(paren
id|model
op_eq
l_int|0x0F
)paren
r_return
l_string|&quot;Special controller&quot;
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|n
comma
l_string|&quot;Unknown CPU [%d:%d]&quot;
comma
id|family
comma
id|model
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|function|MP_processor_info
r_static
r_void
id|__init
id|MP_processor_info
(paren
r_struct
id|mpc_config_processor
op_star
id|m
)paren
(brace
r_int
id|ver
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|m-&gt;mpc_cpuflag
op_amp
id|CPU_ENABLED
)paren
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Processor #%d %s APIC version %d&bslash;n&quot;
comma
id|m-&gt;mpc_apicid
comma
id|mpc_family
c_func
(paren
(paren
id|m-&gt;mpc_cpufeature
op_amp
id|CPU_FAMILY_MASK
)paren
op_rshift
l_int|8
comma
(paren
id|m-&gt;mpc_cpufeature
op_amp
id|CPU_MODEL_MASK
)paren
op_rshift
l_int|4
)paren
comma
id|m-&gt;mpc_apicver
)paren
suffix:semicolon
macro_line|#ifdef SMP_DEBUG
r_if
c_cond
(paren
id|m-&gt;mpc_featureflag
op_amp
(paren
l_int|1
op_lshift
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;    Floating point unit present.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;mpc_featureflag
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;    Machine Exception supported.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;mpc_featureflag
op_amp
(paren
l_int|1
op_lshift
l_int|8
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;    64 bit compare &amp; exchange supported.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;mpc_featureflag
op_amp
(paren
l_int|1
op_lshift
l_int|9
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;    Internal APIC present.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|m-&gt;mpc_cpuflag
op_amp
id|CPU_BOOTPROCESSOR
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;    Bootup CPU&bslash;n&quot;
)paren
suffix:semicolon
id|boot_cpu_id
op_assign
id|m-&gt;mpc_apicid
suffix:semicolon
)brace
r_else
multiline_comment|/* Boot CPU already counted */
id|num_processors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;mpc_apicid
OG
id|NR_CPUS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Processor #%d unused. (Max %d processors).&bslash;n&quot;
comma
id|m-&gt;mpc_apicid
comma
id|NR_CPUS
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ver
op_assign
id|m-&gt;mpc_apicver
suffix:semicolon
id|cpu_present_map
op_or_assign
(paren
l_int|1
op_lshift
id|m-&gt;mpc_apicid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Validate version&n;&t; */
r_if
c_cond
(paren
id|ver
op_eq
l_int|0x0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BIOS bug, APIC version is 0 for CPU#%d! fixing up to 0x10. (tell your hw vendor)&bslash;n&quot;
comma
id|m-&gt;mpc_apicid
)paren
suffix:semicolon
id|ver
op_assign
l_int|0x10
suffix:semicolon
)brace
id|apic_version
(braket
id|m-&gt;mpc_apicid
)braket
op_assign
id|ver
suffix:semicolon
)brace
DECL|function|MP_bus_info
r_static
r_void
id|__init
id|MP_bus_info
(paren
r_struct
id|mpc_config_bus
op_star
id|m
)paren
(brace
r_char
id|str
(braket
l_int|7
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|str
comma
id|m-&gt;mpc_bustype
comma
l_int|6
)paren
suffix:semicolon
id|str
(braket
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;Bus #%d is %s&bslash;n&quot;
comma
id|m-&gt;mpc_busid
comma
id|str
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|str
comma
l_string|&quot;ISA&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
id|mp_bus_id_to_type
(braket
id|m-&gt;mpc_busid
)braket
op_assign
id|MP_BUS_ISA
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|str
comma
l_string|&quot;EISA&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
id|mp_bus_id_to_type
(braket
id|m-&gt;mpc_busid
)braket
op_assign
id|MP_BUS_EISA
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|str
comma
l_string|&quot;PCI&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
id|mp_bus_id_to_type
(braket
id|m-&gt;mpc_busid
)braket
op_assign
id|MP_BUS_PCI
suffix:semicolon
id|mp_bus_id_to_pci_bus
(braket
id|m-&gt;mpc_busid
)braket
op_assign
id|mp_current_pci_id
suffix:semicolon
id|mp_current_pci_id
op_increment
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Unknown bustype %s&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;cannot handle bus - mail to linux-smp@vger.rutgers.edu&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|MP_ioapic_info
r_static
r_void
id|__init
id|MP_ioapic_info
(paren
r_struct
id|mpc_config_ioapic
op_star
id|m
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|m-&gt;mpc_flags
op_amp
id|MPC_APIC_USABLE
)paren
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;I/O APIC #%d Version %d at 0x%lX.&bslash;n&quot;
comma
id|m-&gt;mpc_apicid
comma
id|m-&gt;mpc_apicver
comma
id|m-&gt;mpc_apicaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_ioapics
op_ge
id|MAX_IO_APICS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Max # of I/O APICs (%d) exceeded (found %d).&bslash;n&quot;
comma
id|MAX_IO_APICS
comma
id|nr_ioapics
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;Recompile kernel with bigger MAX_IO_APICS!.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|mp_ioapics
(braket
id|nr_ioapics
)braket
op_assign
op_star
id|m
suffix:semicolon
id|nr_ioapics
op_increment
suffix:semicolon
)brace
DECL|function|MP_intsrc_info
r_static
r_void
id|__init
id|MP_intsrc_info
(paren
r_struct
id|mpc_config_intsrc
op_star
id|m
)paren
(brace
id|mp_irqs
(braket
id|mp_irq_entries
)braket
op_assign
op_star
id|m
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|mp_irq_entries
op_eq
id|MAX_IRQ_SOURCES
)paren
id|panic
c_func
(paren
l_string|&quot;Max # of irq sources exceeded!!&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|MP_lintsrc_info
r_static
r_void
id|__init
id|MP_lintsrc_info
(paren
r_struct
id|mpc_config_lintsrc
op_star
id|m
)paren
(brace
multiline_comment|/*&n;&t; * Well it seems all SMP boards in existence&n;&t; * use ExtINT/LVT1 == LINT0 and&n;&t; * NMI/LVT2 == LINT1 - the following check&n;&t; * will show us if this assumptions is false.&n;&t; * Until then we do not have to add baggage.&n;&t; */
r_if
c_cond
(paren
(paren
id|m-&gt;mpc_irqtype
op_eq
id|mp_ExtINT
)paren
op_logical_and
(paren
id|m-&gt;mpc_destapiclint
op_ne
l_int|0
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|m-&gt;mpc_irqtype
op_eq
id|mp_NMI
)paren
op_logical_and
(paren
id|m-&gt;mpc_destapiclint
op_ne
l_int|1
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read/parse the MPC&n; */
DECL|function|smp_read_mpc
r_static
r_int
id|__init
id|smp_read_mpc
c_func
(paren
r_struct
id|mp_config_table
op_star
id|mpc
)paren
(brace
r_char
id|str
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|count
op_assign
r_sizeof
(paren
op_star
id|mpc
)paren
suffix:semicolon
r_int
r_char
op_star
id|mpt
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|mpc
)paren
op_plus
id|count
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|mpc-&gt;mpc_signature
comma
id|MPC_SIGNATURE
comma
l_int|4
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;SMP mptable: bad signature [%c%c%c%c]!&bslash;n&quot;
comma
id|mpc-&gt;mpc_signature
(braket
l_int|0
)braket
comma
id|mpc-&gt;mpc_signature
(braket
l_int|1
)braket
comma
id|mpc-&gt;mpc_signature
(braket
l_int|2
)braket
comma
id|mpc-&gt;mpc_signature
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mpf_checksum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|mpc
comma
id|mpc-&gt;mpc_length
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;SMP mptable: checksum error!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mpc-&gt;mpc_spec
op_ne
l_int|0x01
op_logical_and
id|mpc-&gt;mpc_spec
op_ne
l_int|0x04
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bad Config Table version (%d)!!&bslash;n&quot;
comma
id|mpc-&gt;mpc_spec
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|str
comma
id|mpc-&gt;mpc_oem
comma
l_int|8
)paren
suffix:semicolon
id|str
(braket
l_int|8
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;OEM ID: %s &quot;
comma
id|str
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|str
comma
id|mpc-&gt;mpc_productid
comma
l_int|12
)paren
suffix:semicolon
id|str
(braket
l_int|12
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Product ID: %s &quot;
comma
id|str
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;APIC at: 0x%lX&bslash;n&quot;
comma
id|mpc-&gt;mpc_lapic
)paren
suffix:semicolon
multiline_comment|/* save the local APIC address, it might be non-default */
id|mp_lapic_addr
op_assign
id|mpc-&gt;mpc_lapic
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now process the configuration blocks.&n;&t; */
r_while
c_loop
(paren
id|count
OL
id|mpc-&gt;mpc_length
)paren
(brace
r_switch
c_cond
(paren
op_star
id|mpt
)paren
(brace
r_case
id|MP_PROCESSOR
suffix:colon
(brace
r_struct
id|mpc_config_processor
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_processor
op_star
)paren
id|mpt
suffix:semicolon
id|MP_processor_info
c_func
(paren
id|m
)paren
suffix:semicolon
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_BUS
suffix:colon
(brace
r_struct
id|mpc_config_bus
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_bus
op_star
)paren
id|mpt
suffix:semicolon
id|MP_bus_info
c_func
(paren
id|m
)paren
suffix:semicolon
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_IOAPIC
suffix:colon
(brace
r_struct
id|mpc_config_ioapic
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_ioapic
op_star
)paren
id|mpt
suffix:semicolon
id|MP_ioapic_info
c_func
(paren
id|m
)paren
suffix:semicolon
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_INTSRC
suffix:colon
(brace
r_struct
id|mpc_config_intsrc
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_intsrc
op_star
)paren
id|mpt
suffix:semicolon
id|MP_intsrc_info
c_func
(paren
id|m
)paren
suffix:semicolon
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_LINTSRC
suffix:colon
(brace
r_struct
id|mpc_config_lintsrc
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_lintsrc
op_star
)paren
id|mpt
suffix:semicolon
id|MP_lintsrc_info
c_func
(paren
id|m
)paren
suffix:semicolon
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_return
id|num_processors
suffix:semicolon
)brace
multiline_comment|/*&n; * Scan the memory blocks for an SMP configuration block.&n; */
DECL|function|smp_get_mpf
r_static
r_int
id|__init
id|smp_get_mpf
c_func
(paren
r_struct
id|intel_mp_floating
op_star
id|mpf
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Intel MultiProcessor Specification v1.%d&bslash;n&quot;
comma
id|mpf-&gt;mpf_specification
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpf-&gt;mpf_feature2
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;    IMCR and PIC compatibility mode.&bslash;n&quot;
)paren
suffix:semicolon
id|pic_mode
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;    Virtual Wire compatibility mode.&bslash;n&quot;
)paren
suffix:semicolon
id|pic_mode
op_assign
l_int|0
suffix:semicolon
)brace
id|smp_found_config
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * default CPU id - if it&squot;s different in the mptable&n;&t; * then we change it before first using it.&n;&t; */
id|boot_cpu_id
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Now see if we need to read further.&n;&t; */
r_if
c_cond
(paren
id|mpf-&gt;mpf_feature1
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * local APIC has default address&n;&t;&t; */
id|mp_lapic_addr
op_assign
id|APIC_DEFAULT_PHYS_BASE
suffix:semicolon
multiline_comment|/*&n;&t;&t; * 2 CPUs, numbered 0 &amp; 1.&n;&t;&t; */
id|cpu_present_map
op_assign
l_int|3
suffix:semicolon
id|num_processors
op_assign
l_int|2
suffix:semicolon
id|nr_ioapics
op_assign
l_int|1
suffix:semicolon
id|mp_ioapics
(braket
l_int|0
)braket
dot
id|mpc_apicaddr
op_assign
l_int|0xFEC00000
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Save the default type number, we&n;&t;&t; * need it later to set the IO-APIC&n;&t;&t; * up properly:&n;&t;&t; */
id|mpc_default_type
op_assign
id|mpf-&gt;mpf_feature1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Bus #0 is &quot;
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|mpf-&gt;mpf_feature1
)paren
(brace
r_case
l_int|1
suffix:colon
r_case
l_int|5
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ISA&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EISA with no IRQ0 and no IRQ13 DMA chaining&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
r_case
l_int|3
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EISA&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_case
l_int|7
suffix:colon
id|printk
c_func
(paren
l_string|&quot;MCA&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|mpf-&gt;mpf_physptr
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;???&bslash;nUnknown standard configuration %d&bslash;n&quot;
comma
id|mpf-&gt;mpf_feature1
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mpf-&gt;mpf_feature1
OG
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bus #1 is PCI&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set local APIC version to the integrated form.&n;&t;&t; * It&squot;s initialized to zero otherwise, representing&n;&t;&t; * a discrete 82489DX.&n;&t;&t; */
id|apic_version
(braket
l_int|0
)braket
op_assign
l_int|0x10
suffix:semicolon
id|apic_version
(braket
l_int|1
)braket
op_assign
l_int|0x10
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Read the physical hardware table. Anything here will override the&n;&t; * defaults.&n;&t; */
r_if
c_cond
(paren
id|mpf-&gt;mpf_physptr
)paren
id|smp_read_mpc
c_func
(paren
(paren
r_void
op_star
)paren
id|mpf-&gt;mpf_physptr
)paren
suffix:semicolon
id|__cpu_logical_map
(braket
l_int|0
)braket
op_assign
id|boot_cpu_id
suffix:semicolon
id|global_irq_holder
op_assign
id|boot_cpu_id
suffix:semicolon
id|current-&gt;processor
op_assign
id|boot_cpu_id
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Processors: %d&bslash;n&quot;
comma
id|num_processors
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Only use the first configuration found.&n;&t; */
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|smp_scan_config
r_static
r_int
id|__init
id|smp_scan_config
c_func
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|length
)paren
(brace
r_int
r_int
op_star
id|bp
op_assign
id|phys_to_virt
c_func
(paren
id|base
)paren
suffix:semicolon
r_struct
id|intel_mp_floating
op_star
id|mpf
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;Scan SMP from %p for %ld bytes.&bslash;n&quot;
comma
id|bp
comma
id|length
)paren
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
op_star
id|mpf
)paren
op_ne
l_int|16
)paren
id|printk
c_func
(paren
l_string|&quot;Error: MPF size&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|length
OG
l_int|0
)paren
(brace
id|mpf
op_assign
(paren
r_struct
id|intel_mp_floating
op_star
)paren
id|bp
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|bp
op_eq
id|SMP_MAGIC_IDENT
)paren
op_logical_and
(paren
id|mpf-&gt;mpf_length
op_eq
l_int|1
)paren
op_logical_and
op_logical_neg
id|mpf_checksum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|bp
comma
l_int|16
)paren
op_logical_and
(paren
(paren
id|mpf-&gt;mpf_specification
op_eq
l_int|1
)paren
op_logical_or
(paren
id|mpf-&gt;mpf_specification
op_eq
l_int|4
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;found SMP MP-table at %08ld&bslash;n&quot;
comma
id|virt_to_phys
c_func
(paren
id|mpf
)paren
)paren
suffix:semicolon
id|smp_get_mpf
c_func
(paren
id|mpf
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|bp
op_add_assign
l_int|4
suffix:semicolon
id|length
op_sub_assign
l_int|16
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|init_intel_smp
r_void
id|__init
id|init_intel_smp
(paren
r_void
)paren
(brace
r_int
r_int
id|address
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: Linux assumes you have 640K of base ram..&n;&t; * this continues the error...&n;&t; *&n;&t; * 1) Scan the bottom 1K for a signature&n;&t; * 2) Scan the top 1K of base RAM&n;&t; * 3) Scan the 64K of bios&n;&t; */
r_if
c_cond
(paren
id|smp_scan_config
c_func
(paren
l_int|0x0
comma
l_int|0x400
)paren
op_logical_or
id|smp_scan_config
c_func
(paren
l_int|639
op_star
l_int|0x400
comma
l_int|0x400
)paren
op_logical_or
id|smp_scan_config
c_func
(paren
l_int|0xF0000
comma
l_int|0x10000
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If it is an SMP machine we should know now, unless the&n;&t; * configuration is in an EISA/MCA bus machine with an&n;&t; * extended bios data area.&n;&t; *&n;&t; * there is a real-mode segmented pointer pointing to the&n;&t; * 4K EBDA area at 0x40E, calculate and scan it here.&n;&t; *&n;&t; * NOTE! There are Linux loaders that will corrupt the EBDA&n;&t; * area, and as such this kind of SMP config may be less&n;&t; * trustworthy, simply because the SMP table may have been&n;&t; * stomped on during early boot. These loaders are buggy and&n;&t; * should be fixed.&n;&t; */
id|address
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|phys_to_virt
c_func
(paren
l_int|0x40E
)paren
suffix:semicolon
id|address
op_lshift_assign
l_int|4
suffix:semicolon
id|smp_scan_config
c_func
(paren
id|address
comma
l_int|0x1000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smp_found_config
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;WARNING: MP table in the EBDA can be UNSAFE, contact linux-smp@vger.rutgers.edu if you experience SMP problems!&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/*&n; * The Visual Workstation is Intel MP compliant in the hardware&n; * sense, but it doesnt have a BIOS(-configuration table).&n; * No problem for Linux.&n; */
DECL|function|init_visws_smp
r_void
id|__init
id|init_visws_smp
c_func
(paren
r_void
)paren
(brace
id|smp_found_config
op_assign
l_int|1
suffix:semicolon
id|cpu_present_map
op_or_assign
l_int|2
suffix:semicolon
multiline_comment|/* or in id 1 */
id|apic_version
(braket
l_int|1
)braket
op_or_assign
l_int|0x10
suffix:semicolon
multiline_comment|/* integrated APIC */
id|apic_version
(braket
l_int|0
)braket
op_or_assign
l_int|0x10
suffix:semicolon
id|mp_lapic_addr
op_assign
id|APIC_DEFAULT_PHYS_BASE
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * - Intel MP Configuration Table&n; * - or SGI Visual Workstation configuration&n; */
DECL|function|init_smp_config
r_void
id|__init
id|init_smp_config
(paren
r_void
)paren
(brace
macro_line|#ifndef CONFIG_VISWS
id|init_intel_smp
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
id|init_visws_smp
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Trampoline 80x86 program as an array.&n; */
r_extern
r_int
r_char
id|trampoline_data
(braket
)braket
suffix:semicolon
r_extern
r_int
r_char
id|trampoline_end
(braket
)braket
suffix:semicolon
DECL|variable|trampoline_base
r_static
r_int
r_char
op_star
id|trampoline_base
suffix:semicolon
multiline_comment|/*&n; * Currently trivial. Write the real-&gt;protected mode&n; * bootstrap into the page concerned. The caller&n; * has made sure it&squot;s suitably aligned.&n; */
DECL|function|setup_trampoline
r_static
r_int
r_int
id|__init
id|setup_trampoline
c_func
(paren
r_void
)paren
(brace
id|memcpy
c_func
(paren
id|trampoline_base
comma
id|trampoline_data
comma
id|trampoline_end
op_minus
id|trampoline_data
)paren
suffix:semicolon
r_return
id|virt_to_phys
c_func
(paren
id|trampoline_base
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We are called very early to get the low memory for the&n; * SMP bootup trampoline page.&n; */
DECL|function|smp_alloc_memory
r_void
id|__init
id|smp_alloc_memory
c_func
(paren
r_void
)paren
(brace
id|trampoline_base
op_assign
(paren
r_void
op_star
)paren
id|alloc_bootmem_low_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Has to be in very low memory so we can execute&n;&t; * real-mode AP code.&n;&t; */
r_if
c_cond
(paren
id|__pa
c_func
(paren
id|trampoline_base
)paren
op_ge
l_int|0x9F000
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The bootstrap kernel entry code has set these up. Save them for&n; * a given CPU&n; */
DECL|function|smp_store_cpu_info
r_void
id|__init
id|smp_store_cpu_info
c_func
(paren
r_int
id|id
)paren
(brace
r_struct
id|cpuinfo_x86
op_star
id|c
op_assign
id|cpu_data
op_plus
id|id
suffix:semicolon
op_star
id|c
op_assign
id|boot_cpu_data
suffix:semicolon
id|c-&gt;pte_quick
op_assign
l_int|0
suffix:semicolon
id|c-&gt;pmd_quick
op_assign
l_int|0
suffix:semicolon
id|c-&gt;pgd_quick
op_assign
l_int|0
suffix:semicolon
id|c-&gt;pgtable_cache_sz
op_assign
l_int|0
suffix:semicolon
id|identify_cpu
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Mask B, Pentium, but not Pentium MMX&n;&t; */
r_if
c_cond
(paren
id|c-&gt;x86_vendor
op_eq
id|X86_VENDOR_INTEL
op_logical_and
id|c-&gt;x86
op_eq
l_int|5
op_logical_and
id|c-&gt;x86_mask
op_ge
l_int|1
op_logical_and
id|c-&gt;x86_mask
op_le
l_int|4
op_logical_and
id|c-&gt;x86_model
op_le
l_int|3
)paren
multiline_comment|/*&n;&t;&t; * Remember we have B step Pentia with bugs&n;&t;&t; */
id|smp_b_stepping
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Architecture specific routine called by the kernel just before init is&n; * fired off. This allows the BP to have everything in order [we hope].&n; * At the end of this all the APs will hit the system scheduling and off&n; * we go. Each AP will load the system gdt&squot;s and jump through the kernel&n; * init into idle(). At this point the scheduler will one day take over&n; * and give them jobs to do. smp_callin is a standard routine&n; * we use to track CPUs as they power up.&n; */
DECL|variable|smp_commenced
r_static
id|atomic_t
id|smp_commenced
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|function|smp_commence
r_void
id|__init
id|smp_commence
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * Lets the callins below out of their loop.&n;&t; */
id|dprintk
c_func
(paren
l_string|&quot;Setting commenced=1, go go go&bslash;n&quot;
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|smp_commenced
comma
l_int|1
)paren
suffix:semicolon
)brace
r_extern
r_void
id|__error_in_io_apic_c
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|get_maxlvt
r_int
id|get_maxlvt
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|v
comma
id|ver
comma
id|maxlvt
suffix:semicolon
id|v
op_assign
id|apic_read
c_func
(paren
id|APIC_LVR
)paren
suffix:semicolon
id|ver
op_assign
id|GET_APIC_VERSION
c_func
(paren
id|v
)paren
suffix:semicolon
multiline_comment|/* 82489DXs do not report # of LVT entries. */
id|maxlvt
op_assign
id|APIC_INTEGRATED
c_func
(paren
id|ver
)paren
ques
c_cond
id|GET_APIC_MAXLVT
c_func
(paren
id|v
)paren
suffix:colon
l_int|2
suffix:semicolon
r_return
id|maxlvt
suffix:semicolon
)brace
DECL|function|disable_local_APIC
r_void
id|disable_local_APIC
(paren
r_void
)paren
(brace
r_int
r_int
id|value
suffix:semicolon
r_int
id|maxlvt
suffix:semicolon
multiline_comment|/*&n;&t; * Disable APIC&n;&t; */
id|value
op_assign
id|apic_read
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
id|value
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|8
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_SPIV
comma
id|value
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clean APIC state for other OSs:&n;&t; */
id|value
op_assign
id|apic_read
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
id|value
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|8
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_SPIV
comma
id|value
)paren
suffix:semicolon
id|maxlvt
op_assign
id|get_maxlvt
c_func
(paren
)paren
suffix:semicolon
id|apic_write_around
c_func
(paren
id|APIC_LVTT
comma
l_int|0x00010000
)paren
suffix:semicolon
id|apic_write_around
c_func
(paren
id|APIC_LVT0
comma
l_int|0x00010000
)paren
suffix:semicolon
id|apic_write_around
c_func
(paren
id|APIC_LVT1
comma
l_int|0x00010000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxlvt
op_ge
l_int|3
)paren
id|apic_write_around
c_func
(paren
id|APIC_LVTERR
comma
l_int|0x00010000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxlvt
op_ge
l_int|4
)paren
id|apic_write_around
c_func
(paren
id|APIC_LVTPC
comma
l_int|0x00010000
)paren
suffix:semicolon
)brace
DECL|function|setup_local_APIC
r_void
id|__init
id|setup_local_APIC
(paren
r_void
)paren
(brace
r_int
r_int
id|value
comma
id|ver
comma
id|maxlvt
suffix:semicolon
r_if
c_cond
(paren
(paren
id|SPURIOUS_APIC_VECTOR
op_amp
l_int|0x0f
)paren
op_ne
l_int|0x0f
)paren
id|__error_in_io_apic_c
c_func
(paren
)paren
suffix:semicolon
id|value
op_assign
id|apic_read
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Enable APIC&n;&t; */
id|value
op_or_assign
(paren
l_int|1
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Some unknown Intel IO/APIC (or APIC) errata is biting us with&n;&t; * certain networking cards. If high frequency interrupts are&n;&t; * happening on a particular IOAPIC pin, plus the IOAPIC routing&n;&t; * entry is masked/unmasked at a high rate as well then sooner or&n;&t; * later IOAPIC line gets &squot;stuck&squot;, no more interrupts are received&n;&t; * from the device. If focus CPU is disabled then the hang goes&n;&t; * away, oh well :-(&n;&t; *&n;&t; * [ This bug can be reproduced easily with a level-triggered&n;&t; *   PCI Ne2000 networking cards and PII/PIII processors, dual&n;&t; *   BX chipset. ]&n;&t; */
macro_line|#if 0
multiline_comment|/* Enable focus processor (bit==0) */
id|value
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|9
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* Disable focus processor (bit==1) */
id|value
op_or_assign
(paren
l_int|1
op_lshift
l_int|9
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Set spurious IRQ vector&n;&t; */
id|value
op_or_assign
id|SPURIOUS_APIC_VECTOR
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_SPIV
comma
id|value
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up LVT0, LVT1:&n;&t; *&n;&t; * set up through-local-APIC on the BP&squot;s LINT0. This is not&n;&t; * strictly necessery in pure symmetric-IO mode, but sometimes&n;&t; * we delegate interrupts to the 8259A.&n;&t; */
r_if
c_cond
(paren
id|hard_smp_processor_id
c_func
(paren
)paren
op_eq
id|boot_cpu_id
)paren
(brace
id|value
op_assign
l_int|0x00000700
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;enabled ExtINT on CPU#%d&bslash;n&quot;
comma
id|hard_smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|value
op_assign
l_int|0x00010700
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;masked ExtINT on CPU#%d&bslash;n&quot;
comma
id|hard_smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
id|apic_write_around
c_func
(paren
id|APIC_LVT0
comma
id|value
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * only the BP should see the LINT1 NMI signal, obviously.&n;&t; */
r_if
c_cond
(paren
id|hard_smp_processor_id
c_func
(paren
)paren
op_eq
id|boot_cpu_id
)paren
id|value
op_assign
l_int|0x00000400
suffix:semicolon
singleline_comment|// unmask NMI
r_else
id|value
op_assign
l_int|0x00010400
suffix:semicolon
singleline_comment|// mask NMI
id|apic_write_around
c_func
(paren
id|APIC_LVT1
comma
id|value
)paren
suffix:semicolon
id|value
op_assign
id|apic_read
c_func
(paren
id|APIC_LVR
)paren
suffix:semicolon
id|ver
op_assign
id|GET_APIC_VERSION
c_func
(paren
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|APIC_INTEGRATED
c_func
(paren
id|ver
)paren
)paren
(brace
multiline_comment|/* !82489DX */
id|maxlvt
op_assign
id|get_maxlvt
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Due to the Pentium erratum 3AP.&n;&t;&t; */
r_if
c_cond
(paren
id|maxlvt
OG
l_int|3
)paren
(brace
id|apic_readaround
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
singleline_comment|// not strictly necessery
id|apic_write
c_func
(paren
id|APIC_ESR
comma
l_int|0
)paren
suffix:semicolon
)brace
id|value
op_assign
id|apic_read
c_func
(paren
id|APIC_ESR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ESR value before enabling vector: %08lx&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
id|value
op_assign
id|apic_read
c_func
(paren
id|APIC_LVTERR
)paren
suffix:semicolon
id|value
op_assign
id|ERROR_APIC_VECTOR
suffix:semicolon
singleline_comment|// enables sending errors
id|apic_write
c_func
(paren
id|APIC_LVTERR
comma
id|value
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * spec says clear errors after enabling vector.&n;&t;&t; */
r_if
c_cond
(paren
id|maxlvt
op_ne
l_int|3
)paren
(brace
id|apic_readaround
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ESR
comma
l_int|0
)paren
suffix:semicolon
)brace
id|value
op_assign
id|apic_read
c_func
(paren
id|APIC_ESR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ESR value after enabling vector: %08lx&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;No ESR for 82489DX.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set Task Priority to &squot;accept all&squot;. We never change this&n;&t; * later on.&n;&t; */
id|value
op_assign
id|apic_read
c_func
(paren
id|APIC_TASKPRI
)paren
suffix:semicolon
id|value
op_and_assign
op_complement
id|APIC_TPRI_MASK
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_TASKPRI
comma
id|value
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up the logical destination ID and put the&n;&t; * APIC into flat delivery mode.&n;&t; */
id|value
op_assign
id|apic_read
c_func
(paren
id|APIC_LDR
)paren
suffix:semicolon
id|value
op_and_assign
op_complement
id|APIC_LDR_MASK
suffix:semicolon
id|value
op_or_assign
(paren
l_int|1
op_lshift
(paren
id|smp_processor_id
c_func
(paren
)paren
op_plus
l_int|24
)paren
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_LDR
comma
id|value
)paren
suffix:semicolon
id|value
op_assign
id|apic_read
c_func
(paren
id|APIC_DFR
)paren
suffix:semicolon
id|value
op_or_assign
id|SET_APIC_DFR
c_func
(paren
l_int|0xf
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_DFR
comma
id|value
)paren
suffix:semicolon
)brace
DECL|function|init_smp_mappings
r_void
id|__init
id|init_smp_mappings
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|apic_phys
suffix:semicolon
r_if
c_cond
(paren
id|smp_found_config
)paren
(brace
id|apic_phys
op_assign
id|mp_lapic_addr
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * set up a fake all zeroes page to simulate the&n;&t;&t; * local APIC and another one for the IO-APIC. We&n;&t;&t; * could use the real zero-page, but it&squot;s safer&n;&t;&t; * this way if some buggy code writes to this page ...&n;&t;&t; */
id|apic_phys
op_assign
(paren
r_int
r_int
)paren
id|alloc_bootmem_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
id|apic_phys
op_assign
id|__pa
c_func
(paren
id|apic_phys
)paren
suffix:semicolon
)brace
id|set_fixmap
c_func
(paren
id|FIX_APIC_BASE
comma
id|apic_phys
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;mapped APIC to %08lx (%08lx)&bslash;n&quot;
comma
id|APIC_BASE
comma
id|apic_phys
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_X86_IO_APIC
(brace
r_int
r_int
id|ioapic_phys
comma
id|idx
op_assign
id|FIX_IO_APIC_BASE_0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_ioapics
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|smp_found_config
)paren
(brace
id|ioapic_phys
op_assign
id|mp_ioapics
(braket
id|i
)braket
dot
id|mpc_apicaddr
suffix:semicolon
)brace
r_else
(brace
id|ioapic_phys
op_assign
(paren
r_int
r_int
)paren
id|alloc_bootmem_pages
c_func
(paren
id|PAGE_SIZE
)paren
suffix:semicolon
id|ioapic_phys
op_assign
id|__pa
c_func
(paren
id|ioapic_phys
)paren
suffix:semicolon
)brace
id|set_fixmap
c_func
(paren
id|idx
comma
id|ioapic_phys
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;mapped IOAPIC to %08lx (%08lx)&bslash;n&quot;
comma
id|__fix_to_virt
c_func
(paren
id|idx
)paren
comma
id|ioapic_phys
)paren
suffix:semicolon
id|idx
op_increment
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * TSC synchronization.&n; *&n; * We first check wether all CPUs have their TSC&squot;s synchronized,&n; * then we print a warning if not, and always resync.&n; */
DECL|variable|tsc_start_flag
r_static
id|atomic_t
id|tsc_start_flag
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|tsc_count_start
r_static
id|atomic_t
id|tsc_count_start
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|tsc_count_stop
r_static
id|atomic_t
id|tsc_count_stop
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|variable|tsc_values
r_static
r_int
r_int
r_int
id|tsc_values
(braket
id|NR_CPUS
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|macro|NR_LOOPS
mdefine_line|#define NR_LOOPS 5
r_extern
r_int
r_int
id|fast_gettimeoffset_quotient
suffix:semicolon
multiline_comment|/*&n; * accurate 64-bit/32-bit division, expanded to 32-bit divisions and 64-bit&n; * multiplication. Not terribly optimized but we need it at boot time only&n; * anyway.&n; *&n; * result == a / b&n; *&t;== (a1 + a2*(2^32)) / b&n; *&t;== a1/b + a2*(2^32/b)&n; *&t;== a1/b + a2*((2^32-1)/b) + a2/b + (a2*((2^32-1) % b))/b&n; *&t;&t;    ^---- (this multiplication can overflow)&n; */
DECL|function|div64
r_static
r_int
r_int
r_int
id|div64
(paren
r_int
r_int
r_int
id|a
comma
r_int
r_int
id|b0
)paren
(brace
r_int
r_int
id|a1
comma
id|a2
suffix:semicolon
r_int
r_int
r_int
id|res
suffix:semicolon
id|a1
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|a
)paren
(braket
l_int|0
)braket
suffix:semicolon
id|a2
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|a
)paren
(braket
l_int|1
)braket
suffix:semicolon
id|res
op_assign
id|a1
op_div
id|b0
op_plus
(paren
r_int
r_int
r_int
)paren
id|a2
op_star
(paren
r_int
r_int
r_int
)paren
(paren
l_int|0xffffffff
op_div
id|b0
)paren
op_plus
id|a2
op_div
id|b0
op_plus
(paren
id|a2
op_star
(paren
l_int|0xffffffff
op_mod
id|b0
)paren
)paren
op_div
id|b0
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
DECL|function|synchronize_tsc_bp
r_static
r_void
id|__init
id|synchronize_tsc_bp
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
r_int
id|t0
suffix:semicolon
r_int
r_int
r_int
id|sum
comma
id|avg
suffix:semicolon
r_int
r_int
id|delta
suffix:semicolon
r_int
r_int
id|one_usec
suffix:semicolon
r_int
id|buggy
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;checking TSC synchronization across CPUs: &quot;
)paren
suffix:semicolon
id|one_usec
op_assign
(paren
(paren
l_int|1
op_lshift
l_int|30
)paren
op_div
id|fast_gettimeoffset_quotient
)paren
op_star
(paren
l_int|1
op_lshift
l_int|2
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|tsc_start_flag
comma
l_int|1
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We loop a few times to get a primed instruction cache,&n;&t; * then the last pass is more or less synchronized and&n;&t; * the BP and APs set their cycle counters to zero all at&n;&t; * once. This reduces the chance of having random offsets&n;&t; * between the processors, and guarantees that the maximum&n;&t; * delay between the cycle counters is never bigger than&n;&t; * the latency of information-passing (cachelines) between&n;&t; * two CPUs.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_LOOPS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * all APs synchronize but they loop on &squot;== num_cpus&squot;&n;&t;&t; */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|tsc_count_start
)paren
op_ne
id|smp_num_cpus
op_minus
l_int|1
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|tsc_count_stop
comma
l_int|0
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * this lets the APs save their current TSC:&n;&t;&t; */
id|atomic_inc
c_func
(paren
op_amp
id|tsc_count_start
)paren
suffix:semicolon
id|rdtscll
c_func
(paren
id|tsc_values
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We clear the TSC in the last loop:&n;&t;&t; */
r_if
c_cond
(paren
id|i
op_eq
id|NR_LOOPS
op_minus
l_int|1
)paren
id|write_tsc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Wait for all APs to leave the synchronization point:&n;&t;&t; */
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|tsc_count_stop
)paren
op_ne
id|smp_num_cpus
op_minus
l_int|1
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|tsc_count_start
comma
l_int|0
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|tsc_count_stop
)paren
suffix:semicolon
)brace
id|sum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|cpu_online_map
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
r_continue
suffix:semicolon
id|t0
op_assign
id|tsc_values
(braket
id|i
)braket
suffix:semicolon
id|sum
op_add_assign
id|t0
suffix:semicolon
)brace
id|avg
op_assign
id|div64
c_func
(paren
id|sum
comma
id|smp_num_cpus
)paren
suffix:semicolon
id|sum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|cpu_online_map
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
r_continue
suffix:semicolon
id|delta
op_assign
id|tsc_values
(braket
id|i
)braket
op_minus
id|avg
suffix:semicolon
r_if
c_cond
(paren
id|delta
OL
l_int|0
)paren
id|delta
op_assign
op_minus
id|delta
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We report bigger than 2 microseconds clock differences.&n;&t;&t; */
r_if
c_cond
(paren
id|delta
OG
l_int|2
op_star
id|one_usec
)paren
(brace
r_int
id|realdelta
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buggy
)paren
(brace
id|buggy
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|realdelta
op_assign
id|div64
c_func
(paren
id|delta
comma
id|one_usec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tsc_values
(braket
id|i
)braket
OL
id|avg
)paren
id|realdelta
op_assign
op_minus
id|realdelta
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;BIOS BUG: CPU#%d improperly initialized, has %ld usecs TSC skew! FIXED.&bslash;n&quot;
comma
id|i
comma
id|realdelta
)paren
suffix:semicolon
)brace
id|sum
op_add_assign
id|delta
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buggy
)paren
id|printk
c_func
(paren
l_string|&quot;passed.&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|synchronize_tsc_ap
r_static
r_void
id|__init
id|synchronize_tsc_ap
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * smp_num_cpus is not necessarily known at the time&n;&t; * this gets called, so we first wait for the BP to&n;&t; * finish SMP initialization:&n;&t; */
r_while
c_loop
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|tsc_start_flag
)paren
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_LOOPS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|atomic_inc
c_func
(paren
op_amp
id|tsc_count_start
)paren
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|tsc_count_start
)paren
op_ne
id|smp_num_cpus
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
id|rdtscll
c_func
(paren
id|tsc_values
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|NR_LOOPS
op_minus
l_int|1
)paren
id|write_tsc
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|tsc_count_stop
)paren
suffix:semicolon
r_while
c_loop
(paren
id|atomic_read
c_func
(paren
op_amp
id|tsc_count_stop
)paren
op_ne
id|smp_num_cpus
)paren
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|macro|NR_LOOPS
macro_line|#undef NR_LOOPS
r_extern
r_void
id|calibrate_delay
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|smp_callin
r_void
id|__init
id|smp_callin
c_func
(paren
r_void
)paren
(brace
r_int
id|cpuid
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
multiline_comment|/*&n;&t; * (This works even if the APIC is not enabled.)&n;&t; */
id|cpuid
op_assign
id|GET_APIC_ID
c_func
(paren
id|apic_read
c_func
(paren
id|APIC_ID
)paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;CPU#%d waiting for CALLOUT&bslash;n&quot;
comma
id|cpuid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * STARTUP IPIs are fragile beasts as they might sometimes&n;&t; * trigger some glue motherboard logic. Complete APIC bus&n;&t; * silence for 1 second, this overestimates the time the&n;&t; * boot CPU is spending to send the up to 2 STARTUP IPIs&n;&t; * by a factor of two. This should be enough.&n;&t; */
multiline_comment|/*&n;&t; * Waiting 2s total for startup (udelay is not yet working)&n;&t; */
id|timeout
op_assign
id|jiffies
op_plus
l_int|2
op_star
id|HZ
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Has the boot CPU finished it&squot;s STARTUP sequence?&n;&t;&t; */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|cpuid
comma
op_amp
id|cpu_callout_map
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BUG: CPU%d started up but did not get a callout!&bslash;n&quot;
comma
id|cpuid
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * the boot CPU has finished the init stage and is spinning&n;&t; * on callin_map until we finish. We are free to set up this&n;&t; * CPU, first the APIC. (this is probably redundant on most&n;&t; * boards)&n;&t; */
id|dprintk
c_func
(paren
l_string|&quot;CALLIN, before setup_local_APIC().&bslash;n&quot;
)paren
suffix:semicolon
id|setup_local_APIC
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MTRR
multiline_comment|/*&n;&t; * Must be done before calibration delay is computed&n;&t; */
id|mtrr_init_secondary_cpu
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Get our bogomips.&n;&t; */
id|calibrate_delay
c_func
(paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;Stack at about %p&bslash;n&quot;
comma
op_amp
id|cpuid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Save our processor parameters&n;&t; */
id|smp_store_cpu_info
c_func
(paren
id|cpuid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allow the master to continue.&n;&t; */
id|set_bit
c_func
(paren
id|cpuid
comma
op_amp
id|cpu_callin_map
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *      Synchronize the TSC with the BP&n;&t; */
r_if
c_cond
(paren
id|cpu_has_tsc
)paren
id|synchronize_tsc_ap
(paren
)paren
suffix:semicolon
)brace
DECL|variable|cpucount
r_int
id|cpucount
op_assign
l_int|0
suffix:semicolon
r_extern
r_int
id|cpu_idle
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * Activate a secondary processor.&n; */
DECL|function|start_secondary
r_int
id|__init
id|start_secondary
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
multiline_comment|/*&n;&t; * Dont put anything before smp_callin(), SMP&n;&t; * booting is too fragile that we want to limit the&n;&t; * things done here to the most necessary things.&n;&t; */
id|cpu_init
c_func
(paren
)paren
suffix:semicolon
id|smp_callin
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|smp_commenced
)paren
)paren
multiline_comment|/* nothing */
suffix:semicolon
multiline_comment|/*&n;&t; * low-memory mappings have been cleared, flush them from&n;&t; * the local TLBs too.&n;&t; */
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
r_return
id|cpu_idle
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Everything has been set up for the secondary&n; * CPUs - they just need to reload everything&n; * from the task structure&n; * This function must not return.&n; */
DECL|function|initialize_secondary
r_void
id|__init
id|initialize_secondary
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * We don&squot;t actually need to load the full TSS,&n;&t; * basically just the stack pointer and the eip.&n;&t; */
id|asm
r_volatile
(paren
l_string|&quot;movl %0,%%esp&bslash;n&bslash;t&quot;
l_string|&quot;jmp *%1&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|current-&gt;thread.esp
)paren
comma
l_string|&quot;r&quot;
(paren
id|current-&gt;thread.eip
)paren
)paren
suffix:semicolon
)brace
r_extern
r_struct
(brace
DECL|member|esp
r_void
op_star
id|esp
suffix:semicolon
DECL|member|ss
r_int
r_int
id|ss
suffix:semicolon
)brace
id|stack_start
suffix:semicolon
DECL|function|fork_by_hand
r_static
r_int
id|__init
id|fork_by_hand
c_func
(paren
r_void
)paren
(brace
r_struct
id|pt_regs
id|regs
suffix:semicolon
multiline_comment|/*&n;&t; * don&squot;t care about the eip and regs settings since&n;&t; * we&squot;ll never reschedule the forked task.&n;&t; */
r_return
id|do_fork
c_func
(paren
id|CLONE_VM
op_or
id|CLONE_PID
comma
l_int|0
comma
op_amp
id|regs
)paren
suffix:semicolon
)brace
DECL|function|do_boot_cpu
r_static
r_void
id|__init
id|do_boot_cpu
c_func
(paren
r_int
id|i
)paren
(brace
r_int
r_int
id|cfg
suffix:semicolon
r_struct
id|task_struct
op_star
id|idle
suffix:semicolon
r_int
r_int
id|send_status
comma
id|accept_status
suffix:semicolon
r_int
id|timeout
comma
id|num_starts
comma
id|j
suffix:semicolon
r_int
r_int
id|start_eip
suffix:semicolon
id|cpucount
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * We can&squot;t use kernel_thread since we must avoid to&n;&t; * reschedule the child.&n;&t; */
r_if
c_cond
(paren
id|fork_by_hand
c_func
(paren
)paren
OL
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;failed fork for CPU %d&quot;
comma
id|i
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We remove it from the pidhash and the runqueue&n;&t; * once we got the process:&n;&t; */
id|idle
op_assign
id|init_task.prev_task
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|idle
)paren
id|panic
c_func
(paren
l_string|&quot;No idle process for CPU %d&quot;
comma
id|i
)paren
suffix:semicolon
id|idle-&gt;processor
op_assign
id|i
suffix:semicolon
id|__cpu_logical_map
(braket
id|cpucount
)braket
op_assign
id|i
suffix:semicolon
id|cpu_number_map
(braket
id|i
)braket
op_assign
id|cpucount
suffix:semicolon
id|idle-&gt;has_cpu
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* we schedule the first task manually */
id|idle-&gt;thread.eip
op_assign
(paren
r_int
r_int
)paren
id|start_secondary
suffix:semicolon
id|del_from_runqueue
c_func
(paren
id|idle
)paren
suffix:semicolon
id|unhash_process
c_func
(paren
id|idle
)paren
suffix:semicolon
id|init_tasks
(braket
id|cpucount
)braket
op_assign
id|idle
suffix:semicolon
multiline_comment|/* start_eip had better be page-aligned! */
id|start_eip
op_assign
id|setup_trampoline
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* So we see what&squot;s up   */
id|printk
c_func
(paren
l_string|&quot;Booting processor %d eip %lx&bslash;n&quot;
comma
id|i
comma
id|start_eip
)paren
suffix:semicolon
id|stack_start.esp
op_assign
(paren
r_void
op_star
)paren
(paren
l_int|1024
op_plus
id|PAGE_SIZE
op_plus
(paren
r_char
op_star
)paren
id|idle
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * This grunge runs the startup process for&n;&t; * the targeted processor.&n;&t; */
id|dprintk
c_func
(paren
l_string|&quot;Setting warm reset code and vector.&bslash;n&quot;
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
l_int|0xa
comma
l_int|0xf
)paren
suffix:semicolon
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;1.&bslash;n&quot;
)paren
suffix:semicolon
op_star
(paren
(paren
r_volatile
r_int
r_int
op_star
)paren
id|phys_to_virt
c_func
(paren
l_int|0x469
)paren
)paren
op_assign
id|start_eip
op_rshift
l_int|4
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;2.&bslash;n&quot;
)paren
suffix:semicolon
op_star
(paren
(paren
r_volatile
r_int
r_int
op_star
)paren
id|phys_to_virt
c_func
(paren
l_int|0x467
)paren
)paren
op_assign
id|start_eip
op_amp
l_int|0xf
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;3.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Be paranoid about clearing APIC errors.&n;&t; */
r_if
c_cond
(paren
id|APIC_INTEGRATED
c_func
(paren
id|apic_version
(braket
id|i
)braket
)paren
)paren
(brace
id|apic_readaround
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ESR
comma
l_int|0
)paren
suffix:semicolon
id|accept_status
op_assign
(paren
id|apic_read
c_func
(paren
id|APIC_ESR
)paren
op_amp
l_int|0xEF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Status is now clean&n;&t; */
id|send_status
op_assign
l_int|0
suffix:semicolon
id|accept_status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Starting actual IPI sequence...&n;&t; */
id|dprintk
c_func
(paren
l_string|&quot;Asserting INIT.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Turn INIT on&n;&t; */
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR2
)paren
suffix:semicolon
id|cfg
op_and_assign
l_int|0x00FFFFFF
suffix:semicolon
multiline_comment|/*&n;&t; * Target chip&n;&t; */
id|apic_write
c_func
(paren
id|APIC_ICR2
comma
id|cfg
op_or
id|SET_APIC_DEST_FIELD
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Send IPI&n;&t; */
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
suffix:semicolon
id|cfg
op_and_assign
op_complement
l_int|0xCDFFF
suffix:semicolon
id|cfg
op_or_assign
(paren
id|APIC_DEST_LEVELTRIG
op_or
id|APIC_DEST_ASSERT
op_or
id|APIC_DEST_DM_INIT
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR
comma
id|cfg
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|200
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;Deasserting INIT.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Target chip */
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR2
)paren
suffix:semicolon
id|cfg
op_and_assign
l_int|0x00FFFFFF
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR2
comma
id|cfg
op_or
id|SET_APIC_DEST_FIELD
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
multiline_comment|/* Send IPI */
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
suffix:semicolon
id|cfg
op_and_assign
op_complement
l_int|0xCDFFF
suffix:semicolon
id|cfg
op_or_assign
(paren
id|APIC_DEST_LEVELTRIG
op_or
id|APIC_DEST_DM_INIT
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR
comma
id|cfg
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Should we send STARTUP IPIs ?&n;&t; *&n;&t; * Determine this based on the APIC version.&n;&t; * If we don&squot;t have an integrated APIC, don&squot;t&n;&t; * send the STARTUP IPIs.&n;&t; */
r_if
c_cond
(paren
id|APIC_INTEGRATED
c_func
(paren
id|apic_version
(braket
id|i
)braket
)paren
)paren
id|num_starts
op_assign
l_int|2
suffix:semicolon
r_else
id|num_starts
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Run STARTUP IPI loop.&n;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
op_le
id|num_starts
suffix:semicolon
id|j
op_increment
)paren
(brace
id|dprintk
c_func
(paren
l_string|&quot;Sending STARTUP #%d.&bslash;n&quot;
comma
id|j
)paren
suffix:semicolon
id|apic_readaround
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ESR
comma
l_int|0
)paren
suffix:semicolon
id|apic_read
c_func
(paren
id|APIC_ESR
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;After apic_write.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * STARTUP IPI&n;&t;&t; */
multiline_comment|/* Target chip */
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR2
)paren
suffix:semicolon
id|cfg
op_and_assign
l_int|0x00FFFFFF
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR2
comma
id|cfg
op_or
id|SET_APIC_DEST_FIELD
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
multiline_comment|/* Boot on the stack */
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
suffix:semicolon
id|cfg
op_and_assign
op_complement
l_int|0xCDFFF
suffix:semicolon
id|cfg
op_or_assign
(paren
id|APIC_DEST_DM_STARTUP
op_or
(paren
id|start_eip
op_rshift
l_int|12
)paren
)paren
suffix:semicolon
multiline_comment|/* Kick the second */
id|apic_write
c_func
(paren
id|APIC_ICR
comma
id|cfg
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;Startup point 1.&bslash;n&quot;
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;Waiting for send to finish...&bslash;n&quot;
)paren
suffix:semicolon
id|timeout
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|dprintk
c_func
(paren
l_string|&quot;+&quot;
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|send_status
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
op_amp
l_int|0x1000
suffix:semicolon
)brace
r_while
c_loop
(paren
id|send_status
op_logical_and
(paren
id|timeout
op_increment
OL
l_int|1000
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Give the other CPU some time to accept the IPI.&n;&t;&t; */
id|udelay
c_func
(paren
l_int|200
)paren
suffix:semicolon
id|accept_status
op_assign
(paren
id|apic_read
c_func
(paren
id|APIC_ESR
)paren
op_amp
l_int|0xEF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|send_status
op_logical_or
id|accept_status
)paren
r_break
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;After Startup.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|send_status
)paren
id|printk
c_func
(paren
l_string|&quot;APIC never delivered???&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|accept_status
)paren
id|printk
c_func
(paren
l_string|&quot;APIC delivery error (%lx).&bslash;n&quot;
comma
id|accept_status
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|send_status
op_logical_and
op_logical_neg
id|accept_status
)paren
(brace
multiline_comment|/*&n;&t;&t; * allow APs to start initializing.&n;&t;&t; */
id|dprintk
c_func
(paren
l_string|&quot;Before Callout %d.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|i
comma
op_amp
id|cpu_callout_map
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;After Callout %d.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Wait 5s total for a response&n;&t;&t; */
r_for
c_loop
(paren
id|timeout
op_assign
l_int|0
suffix:semicolon
id|timeout
OL
l_int|50000
suffix:semicolon
id|timeout
op_increment
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|i
comma
op_amp
id|cpu_callin_map
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* It has booted */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|i
comma
op_amp
id|cpu_callin_map
)paren
)paren
(brace
multiline_comment|/* number CPUs logically, starting from 1 (BSP is 0) */
id|printk
c_func
(paren
l_string|&quot;OK.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU%d: &quot;
comma
id|i
)paren
suffix:semicolon
id|print_cpu_info
c_func
(paren
op_amp
id|cpu_data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_star
(paren
(paren
r_volatile
r_int
r_char
op_star
)paren
id|phys_to_virt
c_func
(paren
l_int|8192
)paren
)paren
op_eq
l_int|0xA5
)paren
multiline_comment|/* trampoline code not run */
id|printk
c_func
(paren
l_string|&quot;Stuck ??&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;CPU booted but not responding.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|dprintk
c_func
(paren
l_string|&quot;CPU has booted.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|__cpu_logical_map
(braket
id|cpucount
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|cpu_number_map
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|cpucount
op_decrement
suffix:semicolon
)brace
multiline_comment|/* mark &quot;stuck&quot; area as not stuck */
op_star
(paren
(paren
r_volatile
r_int
r_int
op_star
)paren
id|phys_to_virt
c_func
(paren
l_int|8192
)paren
)paren
op_assign
l_int|0
suffix:semicolon
)brace
DECL|variable|cacheflush_time
id|cycles_t
id|cacheflush_time
suffix:semicolon
r_extern
r_int
r_int
id|cpu_hz
suffix:semicolon
DECL|function|smp_tune_scheduling
r_static
r_void
id|smp_tune_scheduling
(paren
r_void
)paren
(brace
r_int
r_int
id|cachesize
suffix:semicolon
multiline_comment|/*&n;&t; * Rough estimation for SMP scheduling, this is the number of&n;&t; * cycles it takes for a fully memory-limited process to flush&n;&t; * the SMP-local cache.&n;&t; *&n;&t; * (For a P5 this pretty much means we will choose another idle&n;&t; *  CPU almost always at wakeup time (this is due to the small&n;&t; *  L1 cache), on PIIs it&squot;s around 50-100 usecs, depending on&n;&t; *  the cache size)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cpu_hz
)paren
(brace
multiline_comment|/*&n;&t;&t; * this basically disables processor-affinity&n;&t;&t; * scheduling on SMP without a TSC.&n;&t;&t; */
id|cacheflush_time
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|cachesize
op_assign
id|boot_cpu_data.x86_cache_size
suffix:semicolon
r_if
c_cond
(paren
id|cachesize
op_eq
op_minus
l_int|1
)paren
id|cachesize
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* Pentiums */
id|cacheflush_time
op_assign
id|cpu_hz
op_div
l_int|1024
op_star
id|cachesize
op_div
l_int|5000
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;per-CPU timeslice cutoff: %ld.%02ld usecs.&bslash;n&quot;
comma
(paren
r_int
)paren
id|cacheflush_time
op_div
(paren
id|cpu_hz
op_div
l_int|1000000
)paren
comma
(paren
(paren
r_int
)paren
id|cacheflush_time
op_star
l_int|100
op_div
(paren
id|cpu_hz
op_div
l_int|1000000
)paren
)paren
op_mod
l_int|100
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Cycle through the processors sending APIC IPIs to boot each.&n; */
r_extern
r_int
id|prof_multiplier
(braket
id|NR_CPUS
)braket
suffix:semicolon
r_extern
r_int
id|prof_old_multiplier
(braket
id|NR_CPUS
)braket
suffix:semicolon
r_extern
r_int
id|prof_counter
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|function|smp_boot_cpus
r_void
id|__init
id|smp_boot_cpus
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#ifdef CONFIG_MTRR
multiline_comment|/*  Must be done before other processors booted  */
id|mtrr_init_boot_cpu
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Initialize the logical to physical CPU number mapping&n;&t; * and the per-CPU profiling counter/multiplier&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cpu_number_map
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|prof_counter
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
id|prof_old_multiplier
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
id|prof_multiplier
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Setup boot CPU information&n;&t; */
id|smp_store_cpu_info
c_func
(paren
id|boot_cpu_id
)paren
suffix:semicolon
multiline_comment|/* Final full version of the data */
id|smp_tune_scheduling
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU%d: &quot;
comma
id|boot_cpu_id
)paren
suffix:semicolon
id|print_cpu_info
c_func
(paren
op_amp
id|cpu_data
(braket
id|boot_cpu_id
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * not necessary because the MP table should list the boot&n;&t; * CPU too, but we do it for the sake of robustness anyway.&n;&t; * (and for the case when a non-SMP board boots an SMP kernel)&n;&t; */
id|cpu_present_map
op_or_assign
(paren
l_int|1
op_lshift
id|hard_smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|cpu_number_map
(braket
id|boot_cpu_id
)braket
op_assign
l_int|0
suffix:semicolon
id|init_idle
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we couldnt find an SMP configuration at boot time,&n;&t; * get out of here now!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|smp_found_config
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;SMP motherboard not detected. Using dummy APIC emulation.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_VISWS
id|io_apic_irqs
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|cpu_online_map
op_assign
id|cpu_present_map
suffix:semicolon
id|smp_num_cpus
op_assign
l_int|1
suffix:semicolon
r_goto
id|smp_done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If SMP should be disabled, then really disable it!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|max_cpus
)paren
(brace
id|smp_found_config
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SMP mode deactivated, forcing use of dummy APIC emulation.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef SMP_DEBUG
(brace
r_int
id|reg
suffix:semicolon
multiline_comment|/*&n;&t;&t; * This is to verify that we&squot;re looking at&n;&t;&t; * a real local APIC.  Check these against&n;&t;&t; * your board if the CPUs aren&squot;t getting&n;&t;&t; * started for no apparent reason.&n;&t;&t; */
id|reg
op_assign
id|apic_read
c_func
(paren
id|APIC_LVR
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;Getting VERSION: %x&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_LVR
comma
l_int|0
)paren
suffix:semicolon
id|reg
op_assign
id|apic_read
c_func
(paren
id|APIC_LVR
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;Getting VERSION: %x&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The two version reads above should print the same&n;&t;&t; * NON-ZERO!!! numbers.  If the second one is zero,&n;&t;&t; * there is a problem with the APIC write/read&n;&t;&t; * definitions.&n;&t;&t; *&n;&t;&t; * The next two are just to see if we have sane values.&n;&t;&t; * They&squot;re only really relevant if we&squot;re in Virtual Wire&n;&t;&t; * compatibility mode, but most boxes are anymore.&n;&t;&t; */
id|reg
op_assign
id|apic_read
c_func
(paren
id|APIC_LVT0
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;Getting LVT0: %x&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
id|reg
op_assign
id|apic_read
c_func
(paren
id|APIC_LVT1
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;Getting LVT1: %x&bslash;n&quot;
comma
id|reg
)paren
suffix:semicolon
)brace
macro_line|#endif
id|setup_local_APIC
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GET_APIC_ID
c_func
(paren
id|apic_read
c_func
(paren
id|APIC_ID
)paren
)paren
op_ne
id|boot_cpu_id
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now scan the CPU present map and fire up the other CPUs.&n;&t; */
multiline_comment|/*&n;&t; * Add all detected CPUs. (later on we can down individual&n;&t; * CPUs which will change cpu_online_map but not necessarily&n;&t; * cpu_present_map. We are pretty much ready for hot-swap CPUs.)&n;&t; */
id|cpu_online_map
op_assign
id|cpu_present_map
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;CPU map: %lx&bslash;n&quot;
comma
id|cpu_present_map
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Don&squot;t even attempt to start the boot CPU!&n;&t;&t; */
r_if
c_cond
(paren
id|i
op_eq
id|boot_cpu_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cpu_online_map
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_logical_and
(paren
id|max_cpus
template_param
id|cpucount
op_plus
l_int|1
)paren
)paren
(brace
id|do_boot_cpu
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Make sure we unmap all failed CPUs&n;&t;&t; */
r_if
c_cond
(paren
id|cpu_number_map
(braket
id|i
)braket
op_eq
op_minus
l_int|1
op_logical_and
(paren
id|cpu_online_map
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CPU #%d not responding - cannot use it.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|cpu_online_map
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Cleanup possible dangling ends...&n;&t; */
macro_line|#ifndef CONFIG_VISWS
(brace
multiline_comment|/*&n;&t;&t; * Install writable page 0 entry to set BIOS data area.&n;&t;&t; */
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Paranoid:  Set warm reset code and vector here back&n;&t;&t; * to default values.&n;&t;&t; */
id|CMOS_WRITE
c_func
(paren
l_int|0
comma
l_int|0xf
)paren
suffix:semicolon
op_star
(paren
(paren
r_volatile
r_int
op_star
)paren
id|phys_to_virt
c_func
(paren
l_int|0x467
)paren
)paren
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Allow the user to impress friends.&n;&t; */
id|dprintk
c_func
(paren
l_string|&quot;Before bogomips.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpucount
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Error: only one processor found.&bslash;n&quot;
)paren
suffix:semicolon
id|cpu_online_map
op_assign
(paren
l_int|1
op_lshift
id|hard_smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|bogosum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|cpu_online_map
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|bogosum
op_add_assign
id|cpu_data
(braket
id|i
)braket
dot
id|loops_per_sec
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Total of %d processors activated (%lu.%02lu BogoMIPS).&bslash;n&quot;
comma
id|cpucount
op_plus
l_int|1
comma
(paren
id|bogosum
op_plus
l_int|2500
)paren
op_div
l_int|500000
comma
(paren
(paren
id|bogosum
op_plus
l_int|2500
)paren
op_div
l_int|5000
)paren
op_mod
l_int|100
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;Before bogocount - setting activated=1.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|smp_num_cpus
op_assign
id|cpucount
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|smp_b_stepping
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;WARNING: SMP operation may be unreliable with B stepping processors.&bslash;n&quot;
)paren
suffix:semicolon
id|dprintk
c_func
(paren
l_string|&quot;Boot done.&bslash;n&quot;
)paren
suffix:semicolon
id|cache_APIC_registers
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_VISWS
multiline_comment|/*&n;&t; * Here we can be sure that there is an IO-APIC in the system. Let&squot;s&n;&t; * go and set it up:&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|skip_ioapic_setup
)paren
id|setup_IO_APIC
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|smp_done
suffix:colon
multiline_comment|/*&n;&t; * now we know the other CPUs have fired off and we know our&n;&t; * APIC ID, so we can go init the TSS and stuff:&n;&t; */
id|cpu_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up all local APIC timers in the system:&n;&t; */
id|setup_APIC_clocks
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Synchronize the TSC with the AP&n;&t; */
r_if
c_cond
(paren
id|cpu_has_tsc
op_logical_and
id|cpucount
)paren
id|synchronize_tsc_bp
c_func
(paren
)paren
suffix:semicolon
id|zap_low_mappings
c_func
(paren
)paren
suffix:semicolon
)brace
eof
