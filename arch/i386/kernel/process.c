multiline_comment|/*&n; *  linux/arch/i386/kernel/process.c&n; *&n; *  Copyright (C) 1995  Linus Torvalds&n; */
multiline_comment|/*&n; * This file handles the architecture-dependent parts of process handling..&n; */
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/user.h&gt;
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/reboot.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#if defined(CONFIG_APM) &amp;&amp; defined(CONFIG_APM_POWER_OFF)
macro_line|#include &lt;linux/apm_bios.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/ldt.h&gt;
macro_line|#include &lt;asm/processor.h&gt;
macro_line|#include &lt;asm/desc.h&gt;
macro_line|#ifdef CONFIG_MATH_EMULATION
macro_line|#include &lt;asm/math_emu.h&gt;
macro_line|#endif
macro_line|#include &quot;irq.h&quot;
DECL|variable|semaphore_wake_lock
id|spinlock_t
id|semaphore_wake_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
id|asmlinkage
r_void
id|ret_from_fork
c_func
(paren
r_void
)paren
id|__asm__
c_func
(paren
l_string|&quot;ret_from_fork&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_APM
r_extern
r_int
id|apm_do_idle
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|apm_do_busy
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|hlt_counter
r_static
r_int
id|hlt_counter
op_assign
l_int|0
suffix:semicolon
DECL|macro|HARD_IDLE_TIMEOUT
mdefine_line|#define HARD_IDLE_TIMEOUT (HZ / 3)
DECL|function|disable_hlt
r_void
id|disable_hlt
c_func
(paren
r_void
)paren
(brace
id|hlt_counter
op_increment
suffix:semicolon
)brace
DECL|function|enable_hlt
r_void
id|enable_hlt
c_func
(paren
r_void
)paren
(brace
id|hlt_counter
op_decrement
suffix:semicolon
)brace
macro_line|#ifndef __SMP__
DECL|function|hard_idle
r_static
r_void
id|hard_idle
c_func
(paren
r_void
)paren
(brace
r_while
c_loop
(paren
op_logical_neg
id|current-&gt;need_resched
)paren
(brace
r_if
c_cond
(paren
id|boot_cpu_data.hlt_works_ok
op_logical_and
op_logical_neg
id|hlt_counter
)paren
(brace
macro_line|#ifdef CONFIG_APM
multiline_comment|/* If the APM BIOS is not enabled, or there&n;&t;&t;&t;&t; is an error calling the idle routine, we&n;&t;&t;&t;&t; should hlt if possible.  We need to check&n;&t;&t;&t;&t; need_resched again because an interrupt&n;&t;&t;&t;&t; may have occurred in apm_do_idle(). */
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|apm_do_idle
c_func
(paren
)paren
op_logical_and
op_logical_neg
id|current-&gt;need_resched
)paren
id|__asm__
c_func
(paren
l_string|&quot;hlt&quot;
)paren
suffix:semicolon
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
id|__asm__
c_func
(paren
l_string|&quot;hlt&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|current-&gt;need_resched
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_APM
id|apm_do_busy
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * The idle loop on a uniprocessor i386..&n; */
DECL|function|cpu_idle
r_static
r_int
id|cpu_idle
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
r_int
id|work
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|start_idle
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* endless idle loop with no priority at all */
id|current-&gt;priority
op_assign
l_int|0
suffix:semicolon
id|current-&gt;counter
op_assign
op_minus
l_int|100
suffix:semicolon
id|init_idle
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|work
)paren
id|start_idle
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
op_minus
id|start_idle
OG
id|HARD_IDLE_TIMEOUT
)paren
id|hard_idle
c_func
(paren
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|boot_cpu_data.hlt_works_ok
op_logical_and
op_logical_neg
id|hlt_counter
op_logical_and
op_logical_neg
id|current-&gt;need_resched
)paren
id|__asm__
c_func
(paren
l_string|&quot;hlt&quot;
)paren
suffix:semicolon
)brace
id|work
op_assign
id|current-&gt;need_resched
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|check_pgt_cache
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
multiline_comment|/*&n; *&t;This is being executed in task 0 &squot;user space&squot;.&n; */
DECL|function|cpu_idle
r_int
id|cpu_idle
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
multiline_comment|/* endless idle loop with no priority at all */
id|current-&gt;priority
op_assign
l_int|0
suffix:semicolon
id|current-&gt;counter
op_assign
op_minus
l_int|100
suffix:semicolon
id|init_idle
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|current_cpu_data.hlt_works_ok
op_logical_and
op_logical_neg
id|hlt_counter
op_logical_and
op_logical_neg
id|current-&gt;need_resched
)paren
id|__asm__
c_func
(paren
l_string|&quot;hlt&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * although we are an idle CPU, we do not want to&n;&t;&t; * get into the scheduler unnecessarily.&n;&t;&t; */
r_if
c_cond
(paren
id|current-&gt;need_resched
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|check_pgt_cache
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
DECL|function|sys_idle
id|asmlinkage
r_int
id|sys_idle
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;pid
op_ne
l_int|0
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|cpu_idle
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine reboots the machine by asking the keyboard&n; * controller to pulse the reset-line low. We try that for a while,&n; * and if it doesn&squot;t work, we do some other stupid things.&n; */
DECL|variable|no_idt
r_static
r_int
id|no_idt
(braket
l_int|2
)braket
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|reboot_mode
r_static
r_int
id|reboot_mode
op_assign
l_int|0
suffix:semicolon
DECL|variable|reboot_thru_bios
r_static
r_int
id|reboot_thru_bios
op_assign
l_int|0
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|reboot_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
)paren
(brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_switch
c_cond
(paren
op_star
id|str
)paren
(brace
r_case
l_char|&squot;w&squot;
suffix:colon
multiline_comment|/* &quot;warm&quot; reboot (no memory testing etc) */
id|reboot_mode
op_assign
l_int|0x1234
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
multiline_comment|/* &quot;cold&quot; reboot (with memory testing etc) */
id|reboot_mode
op_assign
l_int|0x0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
multiline_comment|/* &quot;bios&quot; reboot by jumping through the BIOS */
id|reboot_thru_bios
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;h&squot;
suffix:colon
multiline_comment|/* &quot;hard&quot; reboot by toggling RESET and/or crashing the CPU */
id|reboot_thru_bios
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|str
op_assign
id|strchr
c_func
(paren
id|str
comma
l_char|&squot;,&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|str
op_increment
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* The following code and data reboots the machine by switching to real&n;   mode and jumping to the BIOS reset entry point, as if the CPU has&n;   really been reset.  The previous version asked the keyboard&n;   controller to pulse the CPU reset line, which is more thorough, but&n;   doesn&squot;t work with at least one type of 486 motherboard.  It is easy&n;   to stop this code working; hence the copious comments. */
r_static
r_int
r_int
r_int
DECL|variable|real_mode_gdt_entries
id|real_mode_gdt_entries
(braket
l_int|3
)braket
op_assign
(brace
l_int|0x0000000000000000ULL
comma
multiline_comment|/* Null descriptor */
l_int|0x00009a000000ffffULL
comma
multiline_comment|/* 16-bit real-mode 64k code at 0x00000000 */
l_int|0x000092000100ffffULL
multiline_comment|/* 16-bit real-mode 64k data at 0x00000100 */
)brace
suffix:semicolon
r_static
r_struct
(brace
DECL|member|size
r_int
r_int
id|size
id|__attribute__
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
DECL|member|base
r_int
r_int
r_int
op_star
id|base
id|__attribute__
(paren
(paren
id|packed
)paren
)paren
suffix:semicolon
)brace
DECL|variable|real_mode_gdt
id|real_mode_gdt
op_assign
(brace
r_sizeof
(paren
id|real_mode_gdt_entries
)paren
op_minus
l_int|1
comma
id|real_mode_gdt_entries
)brace
comma
DECL|variable|real_mode_idt
id|real_mode_idt
op_assign
(brace
l_int|0x3ff
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* This is 16-bit protected mode code to disable paging and the cache,&n;   switch to real mode and jump to the BIOS reset code.&n;&n;   The instruction that switches to real mode by writing to CR0 must be&n;   followed immediately by a far jump instruction, which set CS to a&n;   valid value for real mode, and flushes the prefetch queue to avoid&n;   running instructions that have already been decoded in protected&n;   mode.&n;&n;   Clears all the flags except ET, especially PG (paging), PE&n;   (protected-mode enable) and TS (task switch for coprocessor state&n;   save).  Flushes the TLB after paging has been disabled.  Sets CD and&n;   NW, to disable the cache on a 486, and invalidates the cache.  This&n;   is more like the state of a 486 after reset.  I don&squot;t know if&n;   something else should be done for other chips.&n;&n;   More could be done here to set up the registers as if a CPU reset had&n;   occurred; hopefully real BIOSs don&squot;t assume much. */
DECL|variable|real_mode_switch
r_static
r_int
r_char
id|real_mode_switch
(braket
)braket
op_assign
(brace
l_int|0x66
comma
l_int|0x0f
comma
l_int|0x20
comma
l_int|0xc0
comma
multiline_comment|/*    movl  %cr0,%eax        */
l_int|0x66
comma
l_int|0x83
comma
l_int|0xe0
comma
l_int|0x11
comma
multiline_comment|/*    andl  $0x00000011,%eax */
l_int|0x66
comma
l_int|0x0d
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x60
comma
multiline_comment|/*    orl   $0x60000000,%eax */
l_int|0x66
comma
l_int|0x0f
comma
l_int|0x22
comma
l_int|0xc0
comma
multiline_comment|/*    movl  %eax,%cr0        */
l_int|0x66
comma
l_int|0x0f
comma
l_int|0x22
comma
l_int|0xd8
comma
multiline_comment|/*    movl  %eax,%cr3        */
l_int|0x66
comma
l_int|0x0f
comma
l_int|0x20
comma
l_int|0xc3
comma
multiline_comment|/*    movl  %cr0,%ebx        */
l_int|0x66
comma
l_int|0x81
comma
l_int|0xe3
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x60
comma
multiline_comment|/*    andl  $0x60000000,%ebx */
l_int|0x74
comma
l_int|0x02
comma
multiline_comment|/*    jz    f                */
l_int|0x0f
comma
l_int|0x08
comma
multiline_comment|/*    invd                   */
l_int|0x24
comma
l_int|0x10
comma
multiline_comment|/* f: andb  $0x10,al         */
l_int|0x66
comma
l_int|0x0f
comma
l_int|0x22
comma
l_int|0xc0
comma
multiline_comment|/*    movl  %eax,%cr0        */
l_int|0xea
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xff
comma
l_int|0xff
multiline_comment|/*    ljmp  $0xffff,$0x0000  */
)brace
suffix:semicolon
DECL|function|kb_wait
r_static
r_inline
r_void
id|kb_wait
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x10000
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|inb_p
c_func
(paren
l_int|0x64
)paren
op_amp
l_int|0x02
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
DECL|function|machine_restart
r_void
id|machine_restart
c_func
(paren
r_char
op_star
id|__unused
)paren
(brace
macro_line|#if __SMP__
multiline_comment|/*&n;&t; * turn off the IO-APIC, so we can do a clean reboot&n;&t; */
id|init_pic_mode
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|reboot_thru_bios
)paren
(brace
multiline_comment|/* rebooting needs to touch the page at absolute addr 0 */
op_star
(paren
(paren
r_int
r_int
op_star
)paren
id|__va
c_func
(paren
l_int|0x472
)paren
)paren
op_assign
id|reboot_mode
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xfe
comma
l_int|0x64
)paren
suffix:semicolon
multiline_comment|/* pulse reset low */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
)brace
multiline_comment|/* That didn&squot;t work - force a triple fault.. */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;lidt %0&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
id|no_idt
)paren
)paren
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;int3&quot;
)paren
suffix:semicolon
)brace
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Write zero to CMOS register number 0x0f, which the BIOS POST&n;&t;   routine will recognize as telling it to do a proper reboot.  (Well&n;&t;   that&squot;s what this book in front of me says -- it may only apply to&n;&t;   the Phoenix BIOS though, it&squot;s not clear).  At the same time,&n;&t;   disable NMIs by setting the top bit in the CMOS address register,&n;&t;   as we&squot;re about to do peculiar things to the CPU.  I&squot;m not sure if&n;&t;   `outb_p&squot; is needed instead of just `outb&squot;.  Use it to be on the&n;&t;   safe side. */
id|outb_p
(paren
l_int|0x8f
comma
l_int|0x70
)paren
suffix:semicolon
id|outb_p
(paren
l_int|0x00
comma
l_int|0x71
)paren
suffix:semicolon
multiline_comment|/* Remap the kernel at virtual address zero, as well as offset zero&n;&t;   from the kernel segment.  This assumes the kernel segment starts at&n;&t;   virtual address PAGE_OFFSET. */
id|memcpy
(paren
id|swapper_pg_dir
comma
id|swapper_pg_dir
op_plus
id|USER_PGD_PTRS
comma
r_sizeof
(paren
id|swapper_pg_dir
(braket
l_int|0
)braket
)paren
op_star
id|KERNEL_PGD_PTRS
)paren
suffix:semicolon
multiline_comment|/* Make sure the first page is mapped to the start of physical memory.&n;&t;   It is normally not mapped, to trap kernel NULL pointer dereferences. */
id|pg0
(braket
l_int|0
)braket
op_assign
id|_PAGE_RW
op_or
id|_PAGE_PRESENT
suffix:semicolon
multiline_comment|/*&n;&t; * Use `swapper_pg_dir&squot; as our page directory.  We bother with&n;&t; * `SET_PAGE_DIR&squot; because although might be rebooting, but if we change&n;&t; * the way we set root page dir in the future, then we wont break a&n;&t; * seldom used feature ;)&n;&t; */
id|SET_PAGE_DIR
c_func
(paren
id|current
comma
id|swapper_pg_dir
)paren
suffix:semicolon
multiline_comment|/* Write 0x1234 to absolute memory location 0x472.  The BIOS reads&n;&t;   this on booting to tell it to &quot;Bypass memory test (also warm&n;&t;   boot)&quot;.  This seems like a fairly standard thing that gets set by&n;&t;   REBOOT.COM programs, and the previous reset routine did this&n;&t;   too. */
op_star
(paren
(paren
r_int
r_int
op_star
)paren
l_int|0x472
)paren
op_assign
id|reboot_mode
suffix:semicolon
multiline_comment|/* For the switch to real mode, copy some code to low memory.  It has&n;&t;   to be in the first 64k because it is running in 16-bit mode, and it&n;&t;   has to have the same physical and virtual address, because it turns&n;&t;   off paging.  Copy it near the end of the first page, out of the way&n;&t;   of BIOS variables. */
id|memcpy
(paren
(paren
r_void
op_star
)paren
(paren
l_int|0x1000
op_minus
r_sizeof
(paren
id|real_mode_switch
)paren
)paren
comma
id|real_mode_switch
comma
r_sizeof
(paren
id|real_mode_switch
)paren
)paren
suffix:semicolon
multiline_comment|/* Set up the IDT for real mode. */
id|__asm__
id|__volatile__
(paren
l_string|&quot;lidt %0&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
id|real_mode_idt
)paren
)paren
suffix:semicolon
multiline_comment|/* Set up a GDT from which we can load segment descriptors for real&n;&t;   mode.  The GDT is not used in real mode; it is just needed here to&n;&t;   prepare the descriptors. */
id|__asm__
id|__volatile__
(paren
l_string|&quot;lgdt %0&quot;
suffix:colon
suffix:colon
l_string|&quot;m&quot;
(paren
id|real_mode_gdt
)paren
)paren
suffix:semicolon
multiline_comment|/* Load the data segment registers, and thus the descriptors ready for&n;&t;   real mode.  The base address of each segment is 0x100, 16 times the&n;&t;   selector value being loaded here.  This is so that the segment&n;&t;   registers don&squot;t have to be reloaded after switching to real mode:&n;&t;   the values are consistent for real mode operation already. */
id|__asm__
id|__volatile__
(paren
l_string|&quot;movl $0x0010,%%eax&bslash;n&quot;
l_string|&quot;&bslash;tmovl %%ax,%%ds&bslash;n&quot;
l_string|&quot;&bslash;tmovl %%ax,%%es&bslash;n&quot;
l_string|&quot;&bslash;tmovl %%ax,%%fs&bslash;n&quot;
l_string|&quot;&bslash;tmovl %%ax,%%gs&bslash;n&quot;
l_string|&quot;&bslash;tmovl %%ax,%%ss&quot;
suffix:colon
suffix:colon
suffix:colon
l_string|&quot;eax&quot;
)paren
suffix:semicolon
multiline_comment|/* Jump to the 16-bit code that we copied earlier.  It disables paging&n;&t;   and the cache, switches to real mode, and jumps to the BIOS reset&n;&t;   entry point. */
id|__asm__
id|__volatile__
(paren
l_string|&quot;ljmp $0x0008,%0&quot;
suffix:colon
suffix:colon
l_string|&quot;i&quot;
(paren
(paren
r_void
op_star
)paren
(paren
l_int|0x1000
op_minus
r_sizeof
(paren
id|real_mode_switch
)paren
)paren
)paren
)paren
suffix:semicolon
)brace
DECL|function|machine_halt
r_void
id|machine_halt
c_func
(paren
r_void
)paren
(brace
)brace
DECL|function|machine_power_off
r_void
id|machine_power_off
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined(CONFIG_APM) &amp;&amp; defined(CONFIG_APM_POWER_OFF)
id|apm_power_off
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|show_regs
r_void
id|show_regs
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|cr0
op_assign
l_int|0L
comma
id|cr2
op_assign
l_int|0L
comma
id|cr3
op_assign
l_int|0L
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EIP: %04x:[&lt;%08lx&gt;]&quot;
comma
l_int|0xffff
op_amp
id|regs-&gt;xcs
comma
id|regs-&gt;eip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|regs-&gt;xcs
op_amp
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot; ESP: %04x:%08lx&quot;
comma
l_int|0xffff
op_amp
id|regs-&gt;xss
comma
id|regs-&gt;esp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; EFLAGS: %08lx&bslash;n&quot;
comma
id|regs-&gt;eflags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EAX: %08lx EBX: %08lx ECX: %08lx EDX: %08lx&bslash;n&quot;
comma
id|regs-&gt;eax
comma
id|regs-&gt;ebx
comma
id|regs-&gt;ecx
comma
id|regs-&gt;edx
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ESI: %08lx EDI: %08lx EBP: %08lx&quot;
comma
id|regs-&gt;esi
comma
id|regs-&gt;edi
comma
id|regs-&gt;ebp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; DS: %04x ES: %04x&bslash;n&quot;
comma
l_int|0xffff
op_amp
id|regs-&gt;xds
comma
l_int|0xffff
op_amp
id|regs-&gt;xes
)paren
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;movl %%cr0, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|cr0
)paren
)paren
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;movl %%cr2, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|cr2
)paren
)paren
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;movl %%cr3, %0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|cr3
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CR0: %08lx CR2: %08lx CR3: %08lx&bslash;n&quot;
comma
id|cr0
comma
id|cr2
comma
id|cr3
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocation and freeing of basic task resources.&n; *&n; * NOTE! The task struct and the stack go together&n; *&n; * The task structure is a two-page thing, and as such&n; * not reliable to allocate using the basic page alloc&n; * functions. We have a small cache of structures for&n; * when the allocations fail..&n; *&n; * This extra buffer essentially acts to make for less&n; * &quot;jitter&quot; in the allocations..&n; *&n; * On SMP we don&squot;t do this right now because:&n; *  - we aren&squot;t holding any locks when called, and we might&n; *    as well just depend on the generic memory management&n; *    to do proper locking for us instead of complicating it&n; *    here.&n; *  - if you use SMP you have a beefy enough machine that&n; *    this shouldn&squot;t matter..&n; */
macro_line|#ifndef __SMP__
DECL|macro|EXTRA_TASK_STRUCT
mdefine_line|#define EXTRA_TASK_STRUCT&t;16
DECL|variable|task_struct_stack
r_static
r_struct
id|task_struct
op_star
id|task_struct_stack
(braket
id|EXTRA_TASK_STRUCT
)braket
suffix:semicolon
DECL|variable|task_struct_stack_ptr
r_static
r_int
id|task_struct_stack_ptr
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
DECL|function|alloc_task_struct
r_struct
id|task_struct
op_star
id|alloc_task_struct
c_func
(paren
r_void
)paren
(brace
macro_line|#ifndef EXTRA_TASK_STRUCT
r_return
(paren
r_struct
id|task_struct
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
l_int|1
)paren
suffix:semicolon
macro_line|#else
r_int
id|index
suffix:semicolon
r_struct
id|task_struct
op_star
id|ret
suffix:semicolon
id|index
op_assign
id|task_struct_stack_ptr
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
id|EXTRA_TASK_STRUCT
op_div
l_int|2
)paren
r_goto
id|use_cache
suffix:semicolon
id|ret
op_assign
(paren
r_struct
id|task_struct
op_star
)paren
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|index
op_assign
id|task_struct_stack_ptr
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
l_int|0
)paren
(brace
id|use_cache
suffix:colon
id|ret
op_assign
id|task_struct_stack
(braket
id|index
)braket
suffix:semicolon
id|task_struct_stack_ptr
op_assign
id|index
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|ret
suffix:semicolon
macro_line|#endif
)brace
DECL|function|free_task_struct
r_void
id|free_task_struct
c_func
(paren
r_struct
id|task_struct
op_star
id|p
)paren
(brace
macro_line|#ifdef EXTRA_TASK_STRUCT
r_int
id|index
op_assign
id|task_struct_stack_ptr
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|index
OL
id|EXTRA_TASK_STRUCT
)paren
(brace
id|task_struct_stack
(braket
id|index
)braket
op_assign
id|p
suffix:semicolon
id|task_struct_stack_ptr
op_assign
id|index
suffix:semicolon
)brace
r_else
macro_line|#endif
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|p
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|release_segments
r_void
id|release_segments
c_func
(paren
r_struct
id|mm_struct
op_star
id|mm
)paren
(brace
r_if
c_cond
(paren
id|mm-&gt;segments
)paren
(brace
r_void
op_star
id|ldt
op_assign
id|mm-&gt;segments
suffix:semicolon
id|mm-&gt;segments
op_assign
l_int|NULL
suffix:semicolon
id|vfree
c_func
(paren
id|ldt
)paren
suffix:semicolon
)brace
)brace
DECL|function|forget_segments
r_void
id|forget_segments
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* forget local segments */
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;movl %w0,%%fs ; movl %w0,%%gs&quot;
suffix:colon
multiline_comment|/* no outputs */
suffix:colon
l_string|&quot;r&quot;
(paren
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the LDT entry from init_task.&n;&t; */
id|current-&gt;tss.ldt
op_assign
id|_LDT
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|load_ldt
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Create a kernel thread&n; */
DECL|function|kernel_thread
r_int
id|kernel_thread
c_func
(paren
r_int
(paren
op_star
id|fn
)paren
(paren
r_void
op_star
)paren
comma
r_void
op_star
id|arg
comma
r_int
r_int
id|flags
)paren
(brace
r_int
id|retval
comma
id|d0
suffix:semicolon
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;movl %%esp,%%esi&bslash;n&bslash;t&quot;
l_string|&quot;int $0x80&bslash;n&bslash;t&quot;
multiline_comment|/* Linux/i386 system call */
l_string|&quot;cmpl %%esp,%%esi&bslash;n&bslash;t&quot;
multiline_comment|/* child or parent? */
l_string|&quot;je 1f&bslash;n&bslash;t&quot;
multiline_comment|/* parent - jump */
multiline_comment|/* Load the argument into eax, and push it.  That way, it does&n;&t;&t; * not matter whether the called function is compiled with&n;&t;&t; * -mregparm or not.  */
l_string|&quot;movl %4,%%eax&bslash;n&bslash;t&quot;
l_string|&quot;pushl %%eax&bslash;n&bslash;t&quot;
l_string|&quot;call *%5&bslash;n&bslash;t&quot;
multiline_comment|/* call fn */
l_string|&quot;movl %3,%0&bslash;n&bslash;t&quot;
multiline_comment|/* exit */
l_string|&quot;int $0x80&bslash;n&quot;
l_string|&quot;1:&bslash;t&quot;
suffix:colon
l_string|&quot;=&amp;a&quot;
(paren
id|retval
)paren
comma
l_string|&quot;=&amp;S&quot;
(paren
id|d0
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|__NR_clone
)paren
comma
l_string|&quot;i&quot;
(paren
id|__NR_exit
)paren
comma
l_string|&quot;r&quot;
(paren
id|arg
)paren
comma
l_string|&quot;r&quot;
(paren
id|fn
)paren
comma
l_string|&quot;b&quot;
(paren
id|flags
op_or
id|CLONE_VM
)paren
suffix:colon
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Free current thread data structures etc..&n; */
DECL|function|exit_thread
r_void
id|exit_thread
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* nothing to do ... */
)brace
DECL|function|flush_thread
r_void
id|flush_thread
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|tsk-&gt;tss.debugreg
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Forget coprocessor state..&n;&t; */
id|clear_fpu
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|tsk-&gt;used_math
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|release_thread
r_void
id|release_thread
c_func
(paren
r_struct
id|task_struct
op_star
id|dead_task
)paren
(brace
)brace
multiline_comment|/*&n; * If new_mm is NULL, we&squot;re being called to set up the LDT descriptor&n; * for a clone task. Each clone must have a separate entry in the GDT.&n; */
DECL|function|copy_segments
r_void
id|copy_segments
c_func
(paren
r_int
id|nr
comma
r_struct
id|task_struct
op_star
id|p
comma
r_struct
id|mm_struct
op_star
id|new_mm
)paren
(brace
r_struct
id|mm_struct
op_star
id|old_mm
op_assign
id|current-&gt;mm
suffix:semicolon
r_void
op_star
id|old_ldt
op_assign
id|old_mm-&gt;segments
comma
op_star
id|ldt
op_assign
id|old_ldt
suffix:semicolon
multiline_comment|/* default LDT - use the one from init_task */
id|p-&gt;tss.ldt
op_assign
id|_LDT
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_ldt
)paren
(brace
r_if
c_cond
(paren
id|new_mm
)paren
(brace
id|ldt
op_assign
id|vmalloc
c_func
(paren
id|LDT_ENTRIES
op_star
id|LDT_ENTRY_SIZE
)paren
suffix:semicolon
id|new_mm-&gt;segments
op_assign
id|ldt
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ldt
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ldt allocation failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|ldt
comma
id|old_ldt
comma
id|LDT_ENTRIES
op_star
id|LDT_ENTRY_SIZE
)paren
suffix:semicolon
)brace
id|p-&gt;tss.ldt
op_assign
id|_LDT
c_func
(paren
id|nr
)paren
suffix:semicolon
id|set_ldt_desc
c_func
(paren
id|nr
comma
id|ldt
comma
id|LDT_ENTRIES
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Save a segment.&n; */
DECL|macro|savesegment
mdefine_line|#define savesegment(seg,value) &bslash;&n;&t;asm volatile(&quot;movl %%&quot; #seg &quot;,%0&quot;:&quot;=m&quot; (*(int *)&amp;(value)))
DECL|function|copy_thread
r_int
id|copy_thread
c_func
(paren
r_int
id|nr
comma
r_int
r_int
id|clone_flags
comma
r_int
r_int
id|esp
comma
r_struct
id|task_struct
op_star
id|p
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|pt_regs
op_star
id|childregs
suffix:semicolon
id|childregs
op_assign
(paren
(paren
r_struct
id|pt_regs
op_star
)paren
(paren
l_int|2
op_star
id|PAGE_SIZE
op_plus
(paren
r_int
r_int
)paren
id|p
)paren
)paren
op_minus
l_int|1
suffix:semicolon
op_star
id|childregs
op_assign
op_star
id|regs
suffix:semicolon
id|childregs-&gt;eax
op_assign
l_int|0
suffix:semicolon
id|childregs-&gt;esp
op_assign
id|esp
suffix:semicolon
id|p-&gt;tss.esp
op_assign
(paren
r_int
r_int
)paren
id|childregs
suffix:semicolon
id|p-&gt;tss.esp0
op_assign
(paren
r_int
r_int
)paren
(paren
id|childregs
op_plus
l_int|1
)paren
suffix:semicolon
id|p-&gt;tss.ss0
op_assign
id|__KERNEL_DS
suffix:semicolon
id|p-&gt;tss.tr
op_assign
id|_TSS
c_func
(paren
id|nr
)paren
suffix:semicolon
id|set_tss_desc
c_func
(paren
id|nr
comma
op_amp
(paren
id|p-&gt;tss
)paren
)paren
suffix:semicolon
id|p-&gt;tss.eip
op_assign
(paren
r_int
r_int
)paren
id|ret_from_fork
suffix:semicolon
id|savesegment
c_func
(paren
id|fs
comma
id|p-&gt;tss.fs
)paren
suffix:semicolon
id|savesegment
c_func
(paren
id|gs
comma
id|p-&gt;tss.gs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * a bitmap offset pointing outside of the TSS limit causes a nicely&n;&t; * controllable SIGSEGV. The first sys_ioperm() call sets up the&n;&t; * bitmap properly.&n;&t; */
id|p-&gt;tss.bitmap
op_assign
r_sizeof
(paren
r_struct
id|thread_struct
)paren
suffix:semicolon
id|unlazy_fpu
c_func
(paren
id|current
)paren
suffix:semicolon
id|p-&gt;tss.i387
op_assign
id|current-&gt;tss.i387
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * fill in the FPU structure for a core dump.&n; */
DECL|function|dump_fpu
r_int
id|dump_fpu
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|user_i387_struct
op_star
id|fpu
)paren
(brace
r_int
id|fpvalid
suffix:semicolon
r_struct
id|task_struct
op_star
id|tsk
op_assign
id|current
suffix:semicolon
id|fpvalid
op_assign
id|tsk-&gt;used_math
suffix:semicolon
r_if
c_cond
(paren
id|fpvalid
)paren
(brace
id|unlazy_fpu
c_func
(paren
id|tsk
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|fpu
comma
op_amp
id|tsk-&gt;tss.i387.hard
comma
r_sizeof
(paren
op_star
id|fpu
)paren
)paren
suffix:semicolon
)brace
r_return
id|fpvalid
suffix:semicolon
)brace
multiline_comment|/*&n; * fill in the user structure for a core dump..&n; */
DECL|function|dump_thread
r_void
id|dump_thread
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_struct
id|user
op_star
id|dump
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* changed the size calculations - should hopefully work better. lbt */
id|dump-&gt;magic
op_assign
id|CMAGIC
suffix:semicolon
id|dump-&gt;start_code
op_assign
l_int|0
suffix:semicolon
id|dump-&gt;start_stack
op_assign
id|regs-&gt;esp
op_amp
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|dump-&gt;u_tsize
op_assign
(paren
(paren
r_int
r_int
)paren
id|current-&gt;mm-&gt;end_code
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|dump-&gt;u_dsize
op_assign
(paren
(paren
r_int
r_int
)paren
(paren
id|current-&gt;mm-&gt;brk
op_plus
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
)paren
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|dump-&gt;u_dsize
op_sub_assign
id|dump-&gt;u_tsize
suffix:semicolon
id|dump-&gt;u_ssize
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
id|dump-&gt;u_debugreg
(braket
id|i
)braket
op_assign
id|current-&gt;tss.debugreg
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dump-&gt;start_stack
OL
id|TASK_SIZE
)paren
id|dump-&gt;u_ssize
op_assign
(paren
(paren
r_int
r_int
)paren
(paren
id|TASK_SIZE
op_minus
id|dump-&gt;start_stack
)paren
)paren
op_rshift
id|PAGE_SHIFT
suffix:semicolon
id|dump-&gt;regs.ebx
op_assign
id|regs-&gt;ebx
suffix:semicolon
id|dump-&gt;regs.ecx
op_assign
id|regs-&gt;ecx
suffix:semicolon
id|dump-&gt;regs.edx
op_assign
id|regs-&gt;edx
suffix:semicolon
id|dump-&gt;regs.esi
op_assign
id|regs-&gt;esi
suffix:semicolon
id|dump-&gt;regs.edi
op_assign
id|regs-&gt;edi
suffix:semicolon
id|dump-&gt;regs.ebp
op_assign
id|regs-&gt;ebp
suffix:semicolon
id|dump-&gt;regs.eax
op_assign
id|regs-&gt;eax
suffix:semicolon
id|dump-&gt;regs.ds
op_assign
id|regs-&gt;xds
suffix:semicolon
id|dump-&gt;regs.es
op_assign
id|regs-&gt;xes
suffix:semicolon
id|savesegment
c_func
(paren
id|fs
comma
id|dump-&gt;regs.fs
)paren
suffix:semicolon
id|savesegment
c_func
(paren
id|gs
comma
id|dump-&gt;regs.gs
)paren
suffix:semicolon
id|dump-&gt;regs.orig_eax
op_assign
id|regs-&gt;orig_eax
suffix:semicolon
id|dump-&gt;regs.eip
op_assign
id|regs-&gt;eip
suffix:semicolon
id|dump-&gt;regs.cs
op_assign
id|regs-&gt;xcs
suffix:semicolon
id|dump-&gt;regs.eflags
op_assign
id|regs-&gt;eflags
suffix:semicolon
id|dump-&gt;regs.esp
op_assign
id|regs-&gt;esp
suffix:semicolon
id|dump-&gt;regs.ss
op_assign
id|regs-&gt;xss
suffix:semicolon
id|dump-&gt;u_fpvalid
op_assign
id|dump_fpu
(paren
id|regs
comma
op_amp
id|dump-&gt;i387
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This special macro can be used to load a debugging register&n; */
DECL|macro|loaddebug
mdefine_line|#define loaddebug(tsk,register) &bslash;&n;&t;&t;__asm__(&quot;movl %0,%%db&quot; #register  &bslash;&n;&t;&t;&t;: /* no output */ &bslash;&n;&t;&t;&t;:&quot;r&quot; (tsk-&gt;tss.debugreg[register]))
multiline_comment|/*&n; *&t;switch_to(x,yn) should switch tasks from x to y.&n; *&n; * We fsave/fwait so that an exception goes off at the right time&n; * (as a call from the fsave or fwait in effect) rather than to&n; * the wrong process. Lazy FP saving no longer makes any sense&n; * with modern CPU&squot;s, and this simplifies a lot of things (SMP&n; * and UP become the same).&n; *&n; * NOTE! We used to use the x86 hardware context switching. The&n; * reason for not using it any more becomes apparent when you&n; * try to recover gracefully from saved state that is no longer&n; * valid (stale segment register values in particular). With the&n; * hardware task-switch, there is no way to fix up bad state in&n; * a reasonable manner.&n; *&n; * The fact that Intel documents the hardware task-switching to&n; * be slow is a fairly red herring - this code is not noticeably&n; * faster. However, there _is_ some room for improvement here,&n; * so the performance issues may eventually be a valid point.&n; * More important, however, is the fact that this allows us much&n; * more flexibility.&n; */
DECL|function|__switch_to
r_void
id|__switch_to
c_func
(paren
r_struct
id|task_struct
op_star
id|prev
comma
r_struct
id|task_struct
op_star
id|next
)paren
(brace
multiline_comment|/* Do the FPU save and set TS if it wasn&squot;t set before.. */
id|unlazy_fpu
c_func
(paren
id|prev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reload TR, LDT and the page table pointers..&n;&t; *&n;&t; * We need TR for the IO permission bitmask (and&n;&t; * the vm86 bitmasks in case we ever use enhanced&n;&t; * v86 mode properly).&n;&t; *&n;&t; * We may want to get rid of the TR register some&n;&t; * day, and copy the bitmaps around by hand. Oh,&n;&t; * well. In the meantime we have to clear the busy&n;&t; * bit in the TSS entry, ugh.&n;&t; */
id|gdt_table
(braket
id|next-&gt;tss.tr
op_rshift
l_int|3
)braket
dot
id|b
op_and_assign
l_int|0xfffffdff
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;ltr %0&quot;
suffix:colon
suffix:colon
l_string|&quot;g&quot;
(paren
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|next-&gt;tss.tr
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Save away %fs and %gs. No need to save %es and %ds, as&n;&t; * those are always kernel segments while inside the kernel.&n;&t; */
id|asm
r_volatile
(paren
l_string|&quot;movl %%fs,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
op_star
(paren
r_int
op_star
)paren
op_amp
id|prev-&gt;tss.fs
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;movl %%gs,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
op_star
(paren
r_int
op_star
)paren
op_amp
id|prev-&gt;tss.gs
)paren
)paren
suffix:semicolon
multiline_comment|/* Re-load LDT if necessary */
r_if
c_cond
(paren
id|next-&gt;mm-&gt;segments
op_ne
id|prev-&gt;mm-&gt;segments
)paren
id|asm
r_volatile
(paren
l_string|&quot;lldt %0&quot;
suffix:colon
suffix:colon
l_string|&quot;g&quot;
(paren
op_star
(paren
r_int
r_int
op_star
)paren
op_amp
id|next-&gt;tss.ldt
)paren
)paren
suffix:semicolon
multiline_comment|/* Re-load page tables */
(brace
r_int
r_int
id|new_cr3
op_assign
id|next-&gt;tss.cr3
suffix:semicolon
r_if
c_cond
(paren
id|new_cr3
op_ne
id|prev-&gt;tss.cr3
)paren
id|asm
r_volatile
(paren
l_string|&quot;movl %0,%%cr3&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|new_cr3
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Restore %fs and %gs.&n;&t; */
id|loadsegment
c_func
(paren
id|fs
comma
id|next-&gt;tss.fs
)paren
suffix:semicolon
id|loadsegment
c_func
(paren
id|gs
comma
id|next-&gt;tss.gs
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now maybe reload the debug registers&n;&t; */
r_if
c_cond
(paren
id|next-&gt;tss.debugreg
(braket
l_int|7
)braket
)paren
(brace
id|loaddebug
c_func
(paren
id|next
comma
l_int|0
)paren
suffix:semicolon
id|loaddebug
c_func
(paren
id|next
comma
l_int|1
)paren
suffix:semicolon
id|loaddebug
c_func
(paren
id|next
comma
l_int|2
)paren
suffix:semicolon
id|loaddebug
c_func
(paren
id|next
comma
l_int|3
)paren
suffix:semicolon
id|loaddebug
c_func
(paren
id|next
comma
l_int|6
)paren
suffix:semicolon
id|loaddebug
c_func
(paren
id|next
comma
l_int|7
)paren
suffix:semicolon
)brace
)brace
DECL|function|sys_fork
id|asmlinkage
r_int
id|sys_fork
c_func
(paren
r_struct
id|pt_regs
id|regs
)paren
(brace
r_return
id|do_fork
c_func
(paren
id|SIGCHLD
comma
id|regs.esp
comma
op_amp
id|regs
)paren
suffix:semicolon
)brace
DECL|function|sys_clone
id|asmlinkage
r_int
id|sys_clone
c_func
(paren
r_struct
id|pt_regs
id|regs
)paren
(brace
r_int
r_int
id|clone_flags
suffix:semicolon
r_int
r_int
id|newsp
suffix:semicolon
id|clone_flags
op_assign
id|regs.ebx
suffix:semicolon
id|newsp
op_assign
id|regs.ecx
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newsp
)paren
id|newsp
op_assign
id|regs.esp
suffix:semicolon
r_return
id|do_fork
c_func
(paren
id|clone_flags
comma
id|newsp
comma
op_amp
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is trivial, and on the face of it looks like it&n; * could equally well be done in user mode.&n; *&n; * Not so, for quite unobvious reasons - register pressure.&n; * In user mode vfork() cannot have a stack frame, and if&n; * done by calling the &quot;clone()&quot; system call directly, you&n; * do not have enough call-clobbered registers to hold all&n; * the information you need.&n; */
DECL|function|sys_vfork
id|asmlinkage
r_int
id|sys_vfork
c_func
(paren
r_struct
id|pt_regs
id|regs
)paren
(brace
r_return
id|do_fork
c_func
(paren
id|CLONE_VFORK
op_or
id|CLONE_VM
op_or
id|SIGCHLD
comma
id|regs.esp
comma
op_amp
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * sys_execve() executes a new program.&n; */
DECL|function|sys_execve
id|asmlinkage
r_int
id|sys_execve
c_func
(paren
r_struct
id|pt_regs
id|regs
)paren
(brace
r_int
id|error
suffix:semicolon
r_char
op_star
id|filename
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|filename
op_assign
id|getname
c_func
(paren
(paren
r_char
op_star
)paren
id|regs.ebx
)paren
suffix:semicolon
id|error
op_assign
id|PTR_ERR
c_func
(paren
id|filename
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_ERR
c_func
(paren
id|filename
)paren
)paren
r_goto
id|out
suffix:semicolon
id|error
op_assign
id|do_execve
c_func
(paren
id|filename
comma
(paren
r_char
op_star
op_star
)paren
id|regs.ecx
comma
(paren
r_char
op_star
op_star
)paren
id|regs.edx
comma
op_amp
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
id|current-&gt;flags
op_and_assign
op_complement
id|PF_DTRACE
suffix:semicolon
id|putname
c_func
(paren
id|filename
)paren
suffix:semicolon
id|out
suffix:colon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
eof
