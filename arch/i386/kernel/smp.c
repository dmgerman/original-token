multiline_comment|/*&n; *&t;Intel MP v1.1 specification support routines for multi-pentium &n; *&t;hosts.&n; *&n; *&t;(c) 1995 Alan Cox, CymruNET Ltd  &lt;alan@cymru.net&gt;&n; *&t;Supported by Caldera http://www.caldera.com.&n; *&t;Much of the core SMP work is based on previous work by Thomas Radke, to&n; *&t;whom a great many thanks are extended.&n; *&n; *&t;This code is released under the GNU public license version 2 or&n; *&t;later.&n; *&n; *&t;Fixes&n; *&t;&t;Felix Koop&t;:&t;NR_CPUS used properly&n; *&t;&t;Jose Renau&t;:&t;Handle single CPU case.&n; *&t;&t;Alan Cox&t;:&t;By repeated request 8) - Total BogoMIP report.&n; *&t;&t;Greg Wright&t;:&t;Fix for kernel stacks panic.&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/i82489.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
r_extern
r_void
op_star
id|vremap
c_func
(paren
r_int
r_int
id|offset
comma
r_int
r_int
id|size
)paren
suffix:semicolon
multiline_comment|/* Linus hasnt put this in the headers yet */
DECL|variable|smp_found_config
r_static
r_int
id|smp_found_config
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Have we found an SMP box &t;&t;&t;&t;*/
DECL|variable|cpu_present_map
r_int
r_int
id|cpu_present_map
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Bitmask of existing CPU&squot;s &t;&t;&t;&t;*/
DECL|variable|smp_num_cpus
r_int
id|smp_num_cpus
suffix:semicolon
multiline_comment|/* Total count of live CPU&squot;s &t;&t;&t;&t;*/
DECL|variable|smp_threads_ready
r_int
id|smp_threads_ready
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set when the idlers are all forked &t;&t;&t;*/
DECL|variable|cpu_callin_map
r_volatile
r_int
r_int
id|cpu_callin_map
(braket
id|NR_CPUS
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* We always use 0 the rest is ready for parallel delivery */
DECL|variable|smp_invalidate_needed
r_volatile
r_int
r_int
id|smp_invalidate_needed
suffix:semicolon
multiline_comment|/* Used for the invalidate map thats also checked in the spinlock */
DECL|variable|cpu_data
r_struct
id|cpuinfo_x86
id|cpu_data
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* Per cpu bogomips and other parameters &t;&t;*/
DECL|variable|num_processors
r_static
r_int
r_int
id|num_processors
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Internal processor count&t;&t;&t;&t;*/
DECL|variable|io_apic_addr
r_static
r_int
r_int
id|io_apic_addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Address of the I/O apic (not yet used) &t;&t;*/
DECL|variable|boot_cpu_id
r_int
r_char
id|boot_cpu_id
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Processor that is doing the boot up &t;&t;&t;*/
DECL|variable|kstack_base
DECL|variable|kstack_end
r_static
r_int
r_char
op_star
id|kstack_base
comma
op_star
id|kstack_end
suffix:semicolon
multiline_comment|/* Kernel stack list pointers &t;&t;&t;&t;*/
DECL|variable|smp_activated
r_static
r_int
id|smp_activated
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Tripped once we need to start cross invalidating &t;*/
DECL|variable|smp_commenced
r_static
r_volatile
r_int
id|smp_commenced
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Tripped when we start scheduling &t;&t;    &t;*/
DECL|variable|nlong
r_static
r_int
r_char
id|nlong
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Apparent value for boot CPU &t;&t;&t;&t;*/
DECL|variable|apic_reg
r_int
r_char
op_star
id|apic_reg
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|nlong
)paren
op_minus
l_int|0x20
suffix:semicolon
multiline_comment|/* Later set to the vremap() of the APIC &t;&t;*/
DECL|variable|apic_retval
r_int
r_int
id|apic_retval
suffix:semicolon
multiline_comment|/* Just debugging the assembler.. &t;&t;&t;*/
DECL|variable|kernel_stacks
r_int
r_char
op_star
id|kernel_stacks
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* Kernel stack pointers for CPU&squot;s (debugging)&t;&t;*/
DECL|variable|smp_cpu_in_msg
r_static
r_volatile
r_int
r_char
id|smp_cpu_in_msg
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* True if this processor is sending an IPI&t;&t;*/
DECL|variable|smp_msg_data
r_static
r_volatile
r_int
r_int
id|smp_msg_data
suffix:semicolon
multiline_comment|/* IPI data pointer&t;&t;&t;&t;&t;*/
DECL|variable|smp_src_cpu
r_static
r_volatile
r_int
id|smp_src_cpu
suffix:semicolon
multiline_comment|/* IPI sender processor&t;&t;&t;&t;&t;*/
DECL|variable|smp_msg_id
r_static
r_volatile
r_int
id|smp_msg_id
suffix:semicolon
multiline_comment|/* Message being sent&t;&t;&t;&t;&t;*/
DECL|variable|kernel_flag
r_volatile
r_int
r_int
id|kernel_flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Kernel spinlock &t;&t;&t;&t;&t;*/
DECL|variable|active_kernel_processor
r_volatile
r_int
r_char
id|active_kernel_processor
op_assign
id|NO_PROC_ID
suffix:semicolon
multiline_comment|/* Processor holding kernel spinlock&t;&t;*/
DECL|variable|kernel_counter
r_volatile
r_int
r_int
id|kernel_counter
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Number of times the processor holds the lock&t;&t;*/
DECL|variable|syscall_count
r_volatile
r_int
r_int
id|syscall_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Number of times the processor holds the syscall lock&t;*/
DECL|variable|ipi_count
r_volatile
r_int
r_int
id|ipi_count
suffix:semicolon
multiline_comment|/* Number of IPI&squot;s delivered&t;&t;&t;&t;*/
macro_line|#ifdef __SMP_PROF__
DECL|variable|smp_spins
r_volatile
r_int
r_int
id|smp_spins
(braket
id|NR_CPUS
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Count interrupt spins &t;&t;&t;&t;*/
DECL|variable|smp_spins_syscall
r_volatile
r_int
r_int
id|smp_spins_syscall
(braket
id|NR_CPUS
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Count syscall spins                   &t;&t;*/
DECL|variable|smp_spins_syscall_cur
r_volatile
r_int
r_int
id|smp_spins_syscall_cur
(braket
id|NR_CPUS
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Count spins for the actual syscall                 */
DECL|variable|smp_spins_sys_idle
r_volatile
r_int
r_int
id|smp_spins_sys_idle
(braket
id|NR_CPUS
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Count spins for sys_idle &t;&t;&t;&t;*/
DECL|variable|smp_idle_count
r_volatile
r_int
r_int
id|smp_idle_count
(braket
l_int|1
op_plus
id|NR_CPUS
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Count idle ticks&t;&t;&t;&t;&t;*/
macro_line|#endif
macro_line|#if defined (__SMP_PROF__)
DECL|variable|smp_idle_map
r_volatile
r_int
r_int
id|smp_idle_map
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Map for idle processors &t;&t;&t;&t;*/
macro_line|#endif
multiline_comment|/* &n; *&t;Checksum an MP configuration block.&n; */
DECL|function|mpf_checksum
r_static
r_int
id|mpf_checksum
c_func
(paren
r_int
r_char
op_star
id|mp
comma
r_int
id|len
)paren
(brace
r_int
id|sum
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
id|sum
op_add_assign
op_star
id|mp
op_increment
suffix:semicolon
)brace
r_return
id|sum
op_amp
l_int|0xFF
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Processor encoding in an MP configuration block&n; */
DECL|function|mpc_family
r_static
r_char
op_star
id|mpc_family
c_func
(paren
r_int
id|family
comma
r_int
id|model
)paren
(brace
r_static
r_char
id|n
(braket
l_int|32
)braket
suffix:semicolon
r_static
r_char
op_star
id|model_defs
(braket
)braket
op_assign
(brace
l_string|&quot;80486DX&quot;
comma
l_string|&quot;80486DX&quot;
comma
l_string|&quot;80486SX&quot;
comma
l_string|&quot;80486DX/2 or 80487&quot;
comma
l_string|&quot;80486SL&quot;
comma
l_string|&quot;Intel5X2(tm)&quot;
comma
l_string|&quot;Unknown&quot;
comma
l_string|&quot;Unknown&quot;
comma
l_string|&quot;80486DX/4&quot;
)brace
suffix:semicolon
r_if
c_cond
(paren
id|family
op_eq
l_int|0x5
)paren
(brace
r_return
l_string|&quot;Pentium(tm)&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|family
op_eq
l_int|0x0F
op_logical_and
id|model
op_eq
l_int|0x0F
)paren
(brace
r_return
l_string|&quot;Special controller&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|family
op_eq
l_int|0x04
op_logical_and
id|model
OL
l_int|9
)paren
(brace
r_return
id|model_defs
(braket
id|model
)braket
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|n
comma
l_string|&quot;Unknown CPU [%d:%d]&quot;
comma
id|family
comma
id|model
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Read the MPC&n; */
DECL|function|smp_read_mpc
r_static
r_int
id|smp_read_mpc
c_func
(paren
r_struct
id|mp_config_table
op_star
id|mpc
)paren
(brace
r_char
id|str
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|count
op_assign
r_sizeof
(paren
op_star
id|mpc
)paren
suffix:semicolon
r_int
id|apics
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|mpt
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|mpc
)paren
op_plus
id|count
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|mpc-&gt;mpc_signature
comma
id|MPC_SIGNATURE
comma
l_int|4
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bad signature [%c%c%c%c].&bslash;n&quot;
comma
id|mpc-&gt;mpc_signature
(braket
l_int|0
)braket
comma
id|mpc-&gt;mpc_signature
(braket
l_int|1
)braket
comma
id|mpc-&gt;mpc_signature
(braket
l_int|2
)braket
comma
id|mpc-&gt;mpc_signature
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mpf_checksum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|mpc
comma
id|mpc-&gt;mpc_length
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Checksum error.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mpc-&gt;mpc_spec
op_ne
l_int|0x01
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unsupported version (%d)&bslash;n&quot;
comma
id|mpc-&gt;mpc_spec
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|str
comma
id|mpc-&gt;mpc_oem
comma
l_int|8
)paren
suffix:semicolon
id|str
(braket
l_int|8
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;OEM ID: %s &quot;
comma
id|str
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|str
comma
id|mpc-&gt;mpc_productid
comma
l_int|12
)paren
suffix:semicolon
id|str
(braket
l_int|12
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Product ID: %s &quot;
comma
id|str
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;APIC at: 0x%lX&bslash;n&quot;
comma
id|mpc-&gt;mpc_lapic
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now process the configuration blocks.&n;&t; */
r_while
c_loop
(paren
id|count
OL
id|mpc-&gt;mpc_length
)paren
(brace
r_switch
c_cond
(paren
op_star
id|mpt
)paren
(brace
r_case
id|MP_PROCESSOR
suffix:colon
(brace
r_struct
id|mpc_config_processor
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_processor
op_star
)paren
id|mpt
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;mpc_cpuflag
op_amp
id|CPU_ENABLED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Processor #%d %s APIC version %d&bslash;n&quot;
comma
id|m-&gt;mpc_apicid
comma
id|mpc_family
c_func
(paren
(paren
id|m-&gt;mpc_cpufeature
op_amp
id|CPU_FAMILY_MASK
)paren
op_rshift
l_int|8
comma
(paren
id|m-&gt;mpc_cpufeature
op_amp
id|CPU_MODEL_MASK
)paren
op_rshift
l_int|4
)paren
comma
id|m-&gt;mpc_apicver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;mpc_featureflag
op_amp
(paren
l_int|1
op_lshift
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;    Floating point unit present.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m-&gt;mpc_featureflag
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;    Machine Exception supported.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m-&gt;mpc_featureflag
op_amp
(paren
l_int|1
op_lshift
l_int|8
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;    64 bit compare &amp; exchange supported.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m-&gt;mpc_featureflag
op_amp
(paren
l_int|1
op_lshift
l_int|9
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;    Internal APIC present.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m-&gt;mpc_cpuflag
op_amp
id|CPU_BOOTPROCESSOR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;    Bootup CPU&bslash;n&quot;
)paren
suffix:semicolon
id|boot_cpu_id
op_assign
id|m-&gt;mpc_apicid
suffix:semicolon
id|nlong
op_assign
id|boot_cpu_id
op_lshift
l_int|24
suffix:semicolon
multiline_comment|/* Dummy &squot;self&squot; for bootup */
)brace
r_else
multiline_comment|/* Boot CPU already counted */
id|num_processors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;mpc_apicid
OG
id|NR_CPUS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Processor #%d unused. (Max %d processors).&bslash;n&quot;
comma
id|m-&gt;mpc_apicid
comma
id|NR_CPUS
)paren
suffix:semicolon
)brace
r_else
id|cpu_present_map
op_or_assign
(paren
l_int|1
op_lshift
id|m-&gt;mpc_apicid
)paren
suffix:semicolon
)brace
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_BUS
suffix:colon
(brace
r_struct
id|mpc_config_bus
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_bus
op_star
)paren
id|mpt
suffix:semicolon
id|memcpy
c_func
(paren
id|str
comma
id|m-&gt;mpc_bustype
comma
l_int|6
)paren
suffix:semicolon
id|str
(braket
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Bus #%d is %s&bslash;n&quot;
comma
id|m-&gt;mpc_busid
comma
id|str
)paren
suffix:semicolon
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_IOAPIC
suffix:colon
(brace
r_struct
id|mpc_config_ioapic
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_ioapic
op_star
)paren
id|mpt
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;mpc_flags
op_amp
id|MPC_APIC_USABLE
)paren
(brace
id|apics
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;I/O APIC #%d Version %d at 0x%lX.&bslash;n&quot;
comma
id|m-&gt;mpc_apicid
comma
id|m-&gt;mpc_apicver
comma
id|m-&gt;mpc_apicaddr
)paren
suffix:semicolon
id|io_apic_addr
op_assign
id|m-&gt;mpc_apicaddr
suffix:semicolon
)brace
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_INTSRC
suffix:colon
(brace
r_struct
id|mpc_config_intsrc
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_intsrc
op_star
)paren
id|mpt
suffix:semicolon
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_LINTSRC
suffix:colon
(brace
r_struct
id|mpc_config_intlocal
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_intlocal
op_star
)paren
id|mpt
suffix:semicolon
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|apics
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: Multiple APIC&squot;s not supported.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|num_processors
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Scan the memory blocks for an SMP configuration block.&n; */
DECL|function|smp_scan_config
r_void
id|smp_scan_config
c_func
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|length
)paren
(brace
r_int
r_int
op_star
id|bp
op_assign
(paren
r_int
r_int
op_star
)paren
id|base
suffix:semicolon
r_struct
id|intel_mp_floating
op_star
id|mpf
suffix:semicolon
multiline_comment|/*&t;printk(&quot;Scan SMP from %p for %ld bytes.&bslash;n&quot;,&n;&t;&t;bp,length);*/
r_if
c_cond
(paren
r_sizeof
(paren
op_star
id|mpf
)paren
op_ne
l_int|16
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error: MPF size&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|length
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_star
id|bp
op_eq
id|SMP_MAGIC_IDENT
)paren
(brace
id|mpf
op_assign
(paren
r_struct
id|intel_mp_floating
op_star
)paren
id|bp
suffix:semicolon
r_if
c_cond
(paren
id|mpf-&gt;mpf_length
op_eq
l_int|1
op_logical_and
op_logical_neg
id|mpf_checksum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|bp
comma
l_int|16
)paren
op_logical_and
id|mpf-&gt;mpf_specification
op_eq
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Intel multiprocessing (MPv1.1) available.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpf-&gt;mpf_feature2
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;    IMCR and PIC mode supported.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|smp_found_config
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Now see if we need to read further.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|mpf-&gt;mpf_feature1
op_ne
l_int|0
)paren
(brace
id|num_processors
op_assign
l_int|2
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;I/O APIC at 0xFEC00000.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Bus#0 is &quot;
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|mpf-&gt;mpf_feature1
)paren
(brace
r_case
l_int|1
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ISA&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EISA with no IRQ8 chaining&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EISA&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|printk
c_func
(paren
l_string|&quot;MCA&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ISA&bslash;nBus#1 is PCI&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EISA&bslash;nBus #1 is PCI&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|printk
c_func
(paren
l_string|&quot;MCA&bslash;nBus #1 is PCI&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;???&bslash;nUnknown standard configuration %d&bslash;n&quot;
comma
id|mpf-&gt;mpf_feature1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Read the physical hardware table. If there isn&squot;t one&n;&t;&t;&t;&t; *&t;the processors present are 0 and 1.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|mpf-&gt;mpf_physptr
)paren
(brace
id|smp_read_mpc
c_func
(paren
(paren
r_void
op_star
)paren
id|mpf-&gt;mpf_physptr
)paren
suffix:semicolon
)brace
r_else
id|cpu_present_map
op_assign
l_int|3
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Processors: %d&bslash;n&quot;
comma
id|num_processors
)paren
suffix:semicolon
)brace
)brace
id|bp
op_add_assign
l_int|4
suffix:semicolon
id|length
op_sub_assign
l_int|16
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Trampoline 80x86 program as an array.&n; */
DECL|variable|trampoline_data
r_static
r_int
r_char
id|trampoline_data
(braket
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/*&n; *&t;Currently trivial. Write the real-&gt;protected mode&n; *&t;bootstrap into the page concerned. The caller&n; *&t;has made sure its suitably aligned.&n; */
DECL|function|install_trampoline
r_static
r_void
id|install_trampoline
c_func
(paren
r_int
r_char
op_star
id|mp
)paren
(brace
id|memcpy
c_func
(paren
id|mp
comma
id|trampoline_data
comma
r_sizeof
(paren
id|trampoline_data
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;We are called very early to get the low memory for the trampoline/kernel stacks&n; *&t;This has to be done by mm/init.c to parcel us out nice low memory. We allocate&n; *&t;the kernel stacks at 4K, 8K, 12K... currently (0-03FF is preserved for SMM and&n; *&t;other things).&n; */
DECL|function|smp_alloc_memory
r_int
r_int
id|smp_alloc_memory
c_func
(paren
r_int
r_int
id|mem_base
)paren
(brace
r_int
id|size
op_assign
(paren
id|num_processors
op_minus
l_int|1
)paren
op_star
id|PAGE_SIZE
suffix:semicolon
multiline_comment|/* Number of stacks needed */
multiline_comment|/*&n;&t; *&t;Our stacks have to be below the 1Mb line, and mem_base on entry&n;&t; *&t;is 4K aligned.&n;&t; */
r_if
c_cond
(paren
id|mem_base
op_plus
id|size
op_ge
l_int|0x9F000
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;smp_alloc_memory: Insufficient low memory for kernel stacks.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|kstack_base
op_assign
(paren
r_void
op_star
)paren
id|mem_base
suffix:semicolon
id|mem_base
op_add_assign
id|size
suffix:semicolon
id|kstack_end
op_assign
(paren
r_void
op_star
)paren
id|mem_base
suffix:semicolon
r_return
id|mem_base
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Hand out stacks one at a time.&n; */
DECL|function|get_kernel_stack
r_static
r_void
op_star
id|get_kernel_stack
c_func
(paren
r_void
)paren
(brace
r_void
op_star
id|stack
op_assign
id|kstack_base
suffix:semicolon
r_if
c_cond
(paren
id|kstack_base
op_ge
id|kstack_end
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|kstack_base
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_return
id|stack
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The bootstrap kernel entry code has set these up. Save them for&n; *&t;a given CPU&n; */
DECL|function|smp_store_cpu_info
r_void
id|smp_store_cpu_info
c_func
(paren
r_int
id|id
)paren
(brace
r_struct
id|cpuinfo_x86
op_star
id|c
op_assign
op_amp
id|cpu_data
(braket
id|id
)braket
suffix:semicolon
id|c-&gt;hard_math
op_assign
id|hard_math
suffix:semicolon
multiline_comment|/* Always assumed same currently */
id|c-&gt;x86
op_assign
id|x86
suffix:semicolon
id|c-&gt;x86_model
op_assign
id|x86_model
suffix:semicolon
id|c-&gt;x86_mask
op_assign
id|x86_mask
suffix:semicolon
id|c-&gt;x86_capability
op_assign
id|x86_capability
suffix:semicolon
id|c-&gt;fdiv_bug
op_assign
id|fdiv_bug
suffix:semicolon
id|c-&gt;wp_works_ok
op_assign
id|wp_works_ok
suffix:semicolon
multiline_comment|/* Always assumed the same currently */
id|c-&gt;hlt_works_ok
op_assign
id|hlt_works_ok
suffix:semicolon
id|c-&gt;udelay_val
op_assign
id|loops_per_sec
suffix:semicolon
id|strcpy
c_func
(paren
id|c-&gt;x86_vendor_id
comma
id|x86_vendor_id
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Architecture specific routine called by the kernel just before init is&n; *&t;fired off. This allows the BP to have everything in order [we hope].&n; *&t;At the end of this all the AP&squot;s will hit the system scheduling and off&n; *&t;we go. Each AP will load the system gdt&squot;s and jump through the kernel&n; *&t;init into idle(). At this point the scheduler will one day take over &n; * &t;and give them jobs to do. smp_callin is a standard routine&n; *&t;we use to track CPU&squot;s as they power up.&n; */
DECL|function|smp_commence
r_void
id|smp_commence
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; *&t;Lets the callin&squot;s below out of their loop.&n;&t; */
id|smp_commenced
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|smp_callin
r_void
id|smp_callin
c_func
(paren
r_void
)paren
(brace
r_int
id|cpuid
op_assign
id|GET_APIC_ID
c_func
(paren
id|apic_read
c_func
(paren
id|APIC_ID
)paren
)paren
suffix:semicolon
r_int
r_int
id|l
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Activate our APIC&n;&t; */
multiline_comment|/*&t;printk(&quot;CALLIN %d&bslash;n&quot;,smp_processor_id());*/
id|l
op_assign
id|apic_read
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
id|l
op_or_assign
(paren
l_int|1
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Enable */
id|apic_write
c_func
(paren
id|APIC_SPIV
comma
id|l
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Get our bogomips.&n;&t; */
id|calibrate_delay
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Save our processor parameters&n;&t; */
id|smp_store_cpu_info
c_func
(paren
id|cpuid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allow the master to continue.&n;&t; */
id|set_bit
c_func
(paren
id|cpuid
comma
op_amp
id|cpu_callin_map
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Until we are ready for SMP scheduling&n;&t; */
id|load_ldt
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&t;printk(&quot;Testing faulting...&bslash;n&quot;);&n;&t;*(long *)0=1;&t;&t; OOPS... */
id|local_invalidate
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|smp_commenced
)paren
(brace
suffix:semicolon
)brace
id|local_invalidate
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&t;printk(&quot;Commenced..&bslash;n&quot;);*/
multiline_comment|/* This assumes the processor id&squot;s are consecutive 0..n-1 -  FIXME */
id|load_TR
c_func
(paren
id|cpuid
)paren
suffix:semicolon
multiline_comment|/*&t;while(1);*/
)brace
multiline_comment|/*&n; *&t;Cycle through the processors sending pentium IPI&squot;s to boot each.&n; */
DECL|function|smp_boot_cpus
r_void
id|smp_boot_cpus
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
id|cpucount
op_assign
l_int|0
suffix:semicolon
r_void
op_star
id|stack
suffix:semicolon
r_extern
r_int
r_int
id|init_user_stack
(braket
)braket
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Map the local APIC into kernel space&n;&t; */
multiline_comment|/* Mapping on non-Intel conforming platforms is a bad move. */
r_if
c_cond
(paren
l_int|1
OL
id|cpu_present_map
)paren
id|apic_reg
op_assign
id|vremap
c_func
(paren
l_int|0xFEE00000
comma
l_int|4096
)paren
suffix:semicolon
r_if
c_cond
(paren
id|apic_reg
op_eq
l_int|NULL
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Unable to map local apic.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Now scan the cpu present map and fire up anything we find.&n;&t; */
id|kernel_stacks
(braket
id|boot_cpu_id
)braket
op_assign
(paren
r_void
op_star
)paren
id|init_user_stack
suffix:semicolon
multiline_comment|/* Set up for boot processor first */
id|smp_store_cpu_info
c_func
(paren
id|boot_cpu_id
)paren
suffix:semicolon
multiline_comment|/* Final full version of the data */
id|active_kernel_processor
op_assign
id|boot_cpu_id
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|cpu_present_map
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_logical_and
id|i
op_ne
id|boot_cpu_id
)paren
multiline_comment|/* Rebooting yourself is a bad move */
(brace
r_int
r_int
id|cfg
suffix:semicolon
r_int
id|timeout
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;We need a kernel stack for each processor.&n;&t;&t;&t; */
id|stack
op_assign
id|get_kernel_stack
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* We allocated these earlier */
r_if
c_cond
(paren
id|stack
op_eq
l_int|NULL
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;No memory for processor stacks.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|kernel_stacks
(braket
id|i
)braket
op_assign
id|stack
suffix:semicolon
id|install_trampoline
c_func
(paren
id|stack
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Booting processor %d stack %p: &quot;
comma
id|i
comma
id|stack
)paren
suffix:semicolon
multiline_comment|/* So we set whats up   */
multiline_comment|/*&n;&t;&t;&t; *&t;Enable the local APIC&n;&t;&t;&t; */
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
id|cfg
op_or_assign
(paren
l_int|1
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Enable APIC */
id|apic_write
c_func
(paren
id|APIC_SPIV
comma
id|cfg
)paren
suffix:semicolon
r_for
c_loop
(paren
id|timeout
op_assign
l_int|0
suffix:semicolon
id|timeout
OL
l_int|50000
suffix:semicolon
id|timeout
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;This gunge sends an IPI (Inter Processor Interrupt) to the&n;&t;&t;&t;&t; *&t;processor we wish to wake. When the startup IPI is received&n;&t;&t;&t;&t; *&t;the target CPU does a real mode jump to the stack base.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; *&t;We do the following&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; *&t;Time 0&t;: Send a STARTUP IPI (This is all that is needed).&n;&t;&t;&t;&t; *&t;Time 20000  : Send an INIT IPI for broken boards.&n;&t;&t;&t;&t; *&t;Time 20001  : Send a second STARTUP IPI for broken boards.&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; *&t;We can&squot;t just do INIT/STARTUP - that breaks the correctly&n;&t;&t;&t;&t; *&t;implemented ASUS boards.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|timeout
op_eq
l_int|20000
)paren
(brace
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR2
)paren
suffix:semicolon
id|cfg
op_and_assign
l_int|0x00FFFFFF
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR2
comma
id|cfg
op_or
id|SET_APIC_DEST_FIELD
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
multiline_comment|/* Target chip     &t;*/
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
suffix:semicolon
id|cfg
op_and_assign
op_complement
l_int|0xFDFFF
suffix:semicolon
multiline_comment|/* Clear bits &t;&t;*/
id|cfg
op_or_assign
id|APIC_DEST_DM_INIT
suffix:semicolon
multiline_comment|/* INIT the CPU         */
id|apic_write
c_func
(paren
id|APIC_ICR
comma
id|cfg
)paren
suffix:semicolon
multiline_comment|/* Kick the second      */
id|printk
c_func
(paren
l_string|&quot;&bslash;nBuggy motherboard ?, trying an INIT IPI: &quot;
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Masses of time       */
)brace
r_if
c_cond
(paren
id|timeout
op_eq
l_int|0
op_logical_or
id|timeout
op_eq
l_int|20001
)paren
(brace
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
suffix:semicolon
id|cfg
op_and_assign
op_complement
l_int|0xFDFFF
suffix:semicolon
multiline_comment|/* Clear bits           */
id|cfg
op_or_assign
id|APIC_DEST_FIELD
op_or
id|APIC_DEST_DM_STARTUP
op_or
(paren
(paren
(paren
r_int
r_int
)paren
id|stack
)paren
op_rshift
l_int|12
)paren
suffix:semicolon
multiline_comment|/* Boot on the stack &t;*/
id|apic_write
c_func
(paren
id|APIC_ICR
comma
id|cfg
)paren
suffix:semicolon
multiline_comment|/* Kick the second &t;*/
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Masses of time &t;*/
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ESR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfg
op_amp
l_int|4
)paren
(brace
multiline_comment|/* Send accept error */
id|printk
c_func
(paren
l_string|&quot;Processor refused startup request.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cpu_callin_map
(braket
l_int|0
)braket
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* It has booted */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Wait 5s total for a response */
)brace
r_if
c_cond
(paren
id|cpu_callin_map
(braket
l_int|0
)braket
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
id|cpucount
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;At this point we should set up a BIOS warm start and try&n;&t;&t;&t;&t; *&t;a RESTART IPI. The 486+82489 MP pair don&squot;t support STARTUP IPI&squot;s&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_star
(paren
(paren
r_int
r_char
op_star
)paren
l_int|8192
)paren
op_eq
l_int|0xA5
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Stuck ??&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Not responding.&bslash;n&quot;
)paren
suffix:semicolon
id|cpu_present_map
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; *&t;Allow the user to impress friends.&n;&t; */
r_if
c_cond
(paren
id|cpucount
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error: only one processor found.&bslash;n&quot;
)paren
suffix:semicolon
id|cpu_present_map
op_assign
(paren
l_int|1
op_lshift
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|bogosum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_present_map
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
id|bogosum
op_add_assign
id|cpu_data
(braket
id|i
)braket
dot
id|udelay_val
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;Total of %d processors activated (%lu.%02lu BogoMIPS).&bslash;n&quot;
comma
id|cpucount
op_plus
l_int|1
comma
(paren
id|bogosum
op_plus
l_int|2500
)paren
op_div
l_int|500000
comma
(paren
(paren
id|bogosum
op_plus
l_int|2500
)paren
op_div
l_int|5000
)paren
op_mod
l_int|100
)paren
suffix:semicolon
id|smp_activated
op_assign
l_int|1
suffix:semicolon
id|smp_num_cpus
op_assign
id|cpucount
op_plus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;A non wait message cannot pass data or cpu source info. This current setup&n; *&t;is only safe because the kernel lock owner is the only person who can send a message.&n; *&n; *&t;Wrapping this whole block in a spinlock is not the safe answer either. A processor may&n; *&t;get stuck with irq&squot;s off waiting to send a message and thus not replying to the person&n; *&t;spinning for a reply....&n; *&n; *&t;In the end invalidate ought to be the NMI and a very very short function (to avoid the old&n; *&t;IDE disk problems), and other messages sent with IRQ&squot;s enabled in a civilised fashion. That&n; *&t;will also boost performance.&n; */
DECL|function|smp_message_pass
r_void
id|smp_message_pass
c_func
(paren
r_int
id|target
comma
r_int
id|msg
comma
r_int
r_int
id|data
comma
r_int
id|wait
)paren
(brace
r_int
r_int
id|cfg
suffix:semicolon
r_int
r_int
id|target_map
suffix:semicolon
r_int
id|p
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|irq
op_assign
l_int|0x2d
suffix:semicolon
multiline_comment|/* IRQ 13 */
r_int
id|ct
op_assign
l_int|0
suffix:semicolon
r_static
r_volatile
r_int
id|message_cpu
op_assign
id|NO_PROC_ID
suffix:semicolon
multiline_comment|/*&n;&t; *&t;During boot up send no messages&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|smp_activated
op_logical_or
op_logical_neg
id|smp_commenced
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Skip the reschedule if we are waiting to clear a&n;&t; *&t;message at this time. The reschedule cannot wait&n;&t; *&t;but is not critical.&n;&t; */
r_if
c_cond
(paren
id|msg
op_eq
id|MSG_RESCHEDULE
)paren
multiline_comment|/* Reschedules we do via trap 0x30 */
(brace
id|irq
op_assign
l_int|0x30
suffix:semicolon
r_if
c_cond
(paren
id|smp_cpu_in_msg
(braket
id|p
)braket
)paren
(brace
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Sanity check we don&squot;t re-enter this across CPU&squot;s. Only the kernel&n;&t; *&t;lock holder may send messages. For a STOP_CPU we are bringing the&n;&t; *&t;entire box to the fastest halt we can.. &n;&t; */
r_if
c_cond
(paren
id|message_cpu
op_ne
id|NO_PROC_ID
op_logical_and
id|msg
op_ne
id|MSG_STOP_CPU
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;CPU #%d: Message pass %d but pass in progress by %d of %d&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|msg
comma
id|message_cpu
comma
id|smp_msg_id
)paren
suffix:semicolon
)brace
id|message_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We are busy&n;&t; */
id|smp_cpu_in_msg
(braket
id|p
)braket
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Reschedule is currently special&n;&t; */
r_if
c_cond
(paren
id|msg
op_ne
id|MSG_RESCHEDULE
)paren
(brace
id|smp_src_cpu
op_assign
id|p
suffix:semicolon
id|smp_msg_id
op_assign
id|msg
suffix:semicolon
id|smp_msg_data
op_assign
id|data
suffix:semicolon
)brace
multiline_comment|/*&t;printk(&quot;SMP message pass #%d to %d of %d&bslash;n&quot;,&n;&t;&t;p, msg, target);*/
multiline_comment|/*&n;&t; *&t;Wait for the APIC to become ready - this should never occur. Its&n;&t; *&t;a debugging check really.&n;&t; */
r_while
c_loop
(paren
id|ct
OL
l_int|1000
)paren
(brace
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cfg
op_amp
(paren
l_int|1
op_lshift
l_int|12
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|ct
op_increment
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Just pray... there is nothing more we can do&n;&t; */
r_if
c_cond
(paren
id|ct
op_eq
l_int|1000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CPU #%d: previous IPI still not cleared after 10mS&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Program the APIC to deliver the IPI&n;&t; */
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR2
)paren
suffix:semicolon
id|cfg
op_and_assign
l_int|0x00FFFFFF
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR2
comma
id|cfg
op_or
id|SET_APIC_DEST_FIELD
c_func
(paren
id|target
)paren
)paren
suffix:semicolon
multiline_comment|/* Target chip     &t;&t;*/
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
suffix:semicolon
id|cfg
op_and_assign
op_complement
l_int|0xFDFFF
suffix:semicolon
multiline_comment|/* Clear bits &t;&t;&t;*/
id|cfg
op_or_assign
id|APIC_DEST_FIELD
op_or
id|APIC_DEST_DM_FIXED
op_or
id|irq
suffix:semicolon
multiline_comment|/* Send an IRQ 13&t;&t;*/
multiline_comment|/*&n;&t; *&t;Set the target requirement&n;&t; */
r_if
c_cond
(paren
id|target
op_eq
id|MSG_ALL_BUT_SELF
)paren
(brace
id|cfg
op_or_assign
id|APIC_DEST_ALLBUT
suffix:semicolon
id|target_map
op_assign
id|cpu_present_map
suffix:semicolon
id|cpu_callin_map
(braket
l_int|0
)braket
op_assign
(paren
l_int|1
op_lshift
id|smp_src_cpu
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|target
op_eq
id|MSG_ALL
)paren
(brace
id|cfg
op_or_assign
id|APIC_DEST_ALLINC
suffix:semicolon
id|target_map
op_assign
id|cpu_present_map
suffix:semicolon
id|cpu_callin_map
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|target_map
op_assign
(paren
l_int|1
op_lshift
id|target
)paren
suffix:semicolon
id|cpu_callin_map
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Send the IPI. The write to APIC_ICR fires this off.&n;&t; */
id|apic_write
c_func
(paren
id|APIC_ICR
comma
id|cfg
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Spin waiting for completion&n;&t; */
r_switch
c_cond
(paren
id|wait
)paren
(brace
r_case
l_int|1
suffix:colon
r_while
c_loop
(paren
id|cpu_callin_map
(braket
l_int|0
)braket
op_ne
id|target_map
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Spin on the pass&t;&t;*/
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_while
c_loop
(paren
id|smp_invalidate_needed
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Wait for invalidate map to clear */
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Record our completion&n;&t; */
id|smp_cpu_in_msg
(braket
id|p
)braket
op_decrement
suffix:semicolon
id|message_cpu
op_assign
id|NO_PROC_ID
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is fraught with deadlocks. Linus does an invalidate at a whim&n; *&t;even with IRQ&squot;s off. We have to avoid a pair of crossing invalidates&n; *&t;or we are doomed.  See the notes about smp_message_pass.&n; */
DECL|function|smp_invalidate
r_void
id|smp_invalidate
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|smp_activated
op_logical_and
id|smp_processor_id
c_func
(paren
)paren
op_ne
id|active_kernel_processor
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;CPU #%d:Attempted invalidate IPI when not AKP(=%d)&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|active_kernel_processor
)paren
suffix:semicolon
)brace
multiline_comment|/*&t;printk(&quot;SMI-&quot;);*/
multiline_comment|/*&n;&t; *&t;The assignment is safe because its volatile so the compiler cannot reorder it,&n;&t; *&t;because the i586 has strict memory ordering and because only the kernel lock holder&n;&t; *&t;may issue an invalidate. If you break any one of those three change this to an atomic&n;&t; *&t;bus locked or.&n;&t; */
id|smp_invalidate_needed
op_assign
id|cpu_present_map
op_amp
op_complement
(paren
l_int|1
op_lshift
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Processors spinning on the lock will see this IRQ late. The smp_invalidate_needed map will&n;&t; *&t;ensure they dont do a spurious invalidate or miss one.&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|smp_message_pass
c_func
(paren
id|MSG_ALL_BUT_SELF
comma
id|MSG_INVALIDATE_TLB
comma
l_int|0L
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Flush the local TLB&n;&t; */
id|local_invalidate
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Completed.&n;&t; */
multiline_comment|/*&t;printk(&quot;SMID&bslash;n&quot;);*/
)brace
multiline_comment|/*&t;&n; *&t;Reschedule call back&n; */
DECL|function|smp_reschedule_irq
r_void
id|smp_reschedule_irq
c_func
(paren
r_int
id|cpl
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
macro_line|#ifdef DEBUGGING_SMP_RESCHED
r_static
r_int
id|ct
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ct
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Beginning scheduling on CPU#%d&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|ct
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif&t;
r_if
c_cond
(paren
id|smp_processor_id
c_func
(paren
)paren
op_ne
id|active_kernel_processor
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;SMP Reschedule on CPU #%d, but #%d is active.&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|active_kernel_processor
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Update resource usage on the slave timer tick.&n;&t; */
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
(brace
id|current-&gt;utime
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;pid
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;priority
OL
l_int|15
)paren
id|kstat.cpu_nice
op_increment
suffix:semicolon
r_else
id|kstat.cpu_user
op_increment
suffix:semicolon
)brace
multiline_comment|/* Update ITIMER_VIRT for current task if not in a system call */
r_if
c_cond
(paren
id|current-&gt;it_virt_value
op_logical_and
op_logical_neg
(paren
op_decrement
id|current-&gt;it_virt_value
)paren
)paren
(brace
id|current-&gt;it_virt_value
op_assign
id|current-&gt;it_virt_incr
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGVTALRM
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|current-&gt;stime
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;pid
)paren
(brace
id|kstat.cpu_system
op_increment
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PROFILE
r_if
c_cond
(paren
id|prof_buffer
op_logical_and
id|current-&gt;pid
)paren
(brace
r_extern
r_int
id|_stext
suffix:semicolon
r_int
r_int
id|eip
op_assign
id|regs-&gt;eip
op_minus
(paren
r_int
r_int
)paren
op_amp
id|_stext
suffix:semicolon
id|eip
op_rshift_assign
id|CONFIG_PROFILE_SHIFT
suffix:semicolon
r_if
c_cond
(paren
id|eip
OL
id|prof_len
)paren
id|prof_buffer
(braket
id|eip
)braket
op_increment
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n;&t; * check the cpu time limit on the process.&n;&t; */
r_if
c_cond
(paren
(paren
id|current-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_max
op_ne
id|RLIM_INFINITY
)paren
op_logical_and
(paren
(paren
(paren
id|current-&gt;stime
op_plus
id|current-&gt;utime
)paren
op_div
id|HZ
)paren
op_ge
id|current-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_max
)paren
)paren
id|send_sig
c_func
(paren
id|SIGKILL
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_cur
op_ne
id|RLIM_INFINITY
)paren
op_logical_and
(paren
(paren
(paren
id|current-&gt;stime
op_plus
id|current-&gt;utime
)paren
op_mod
id|HZ
)paren
op_eq
l_int|0
)paren
)paren
(brace
r_int
r_int
id|psecs
op_assign
(paren
id|current-&gt;stime
op_plus
id|current-&gt;utime
)paren
op_div
id|HZ
suffix:semicolon
multiline_comment|/* send when equal */
r_if
c_cond
(paren
id|psecs
op_eq
id|current-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_cur
)paren
id|send_sig
c_func
(paren
id|SIGXCPU
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* and every five seconds thereafter. */
r_else
r_if
c_cond
(paren
(paren
id|psecs
OG
id|current-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_cur
)paren
op_logical_and
(paren
(paren
id|psecs
op_minus
id|current-&gt;rlim
(braket
id|RLIMIT_CPU
)braket
dot
id|rlim_cur
)paren
op_mod
l_int|5
)paren
op_eq
l_int|0
)paren
id|send_sig
c_func
(paren
id|SIGXCPU
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Update ITIMER_PROF for the current task */
r_if
c_cond
(paren
id|current-&gt;it_prof_value
op_logical_and
op_logical_neg
(paren
op_decrement
id|current-&gt;it_prof_value
)paren
)paren
(brace
id|current-&gt;it_prof_value
op_assign
id|current-&gt;it_prof_incr
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGPROF
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Don&squot;t reschedule if we are in an interrupt...&n;&t; *&t;[This is test code and not needed in the end]&n;&t; */
multiline_comment|/*&t;if(intr_count==1)&n;&t;{*/
multiline_comment|/*&n;&t;&t; *&t;See if the slave processors need a schedule.&n;&t;&t; */
r_if
c_cond
(paren
l_int|0
OG
op_decrement
id|current-&gt;counter
op_logical_or
id|current-&gt;pid
op_eq
l_int|0
)paren
(brace
id|current-&gt;counter
op_assign
l_int|0
suffix:semicolon
id|need_resched
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&t;}*/
multiline_comment|/*&n;&t; *&t;Clear the IPI&n;&t; */
id|apic_read
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
multiline_comment|/* Dummy read */
id|apic_write
c_func
(paren
id|APIC_EOI
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Docs say use 0 for future compatibility */
)brace
multiline_comment|/*&n; *&t;Message call back.&n; */
DECL|function|smp_message_irq
r_void
id|smp_message_irq
c_func
(paren
r_int
id|cpl
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&t;static int n=0;&n;&t;if(n++&lt;NR_CPUS)&n;&t;&t;printk(&quot;IPI %d-&gt;%d(%d,%ld)&bslash;n&quot;,smp_src_cpu,i,smp_msg_id,smp_msg_data);*/
r_switch
c_cond
(paren
id|smp_msg_id
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* IRQ 13 testing - boring */
r_return
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;A TLB flush is needed.&n;&t;&t; */
r_case
id|MSG_INVALIDATE_TLB
suffix:colon
r_if
c_cond
(paren
id|clear_bit
c_func
(paren
id|i
comma
op_amp
id|smp_invalidate_needed
)paren
)paren
(brace
id|local_invalidate
c_func
(paren
)paren
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|i
comma
op_amp
id|cpu_callin_map
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|cpu_callin_map
(braket
l_int|0
)braket
op_or_assign
l_int|1
op_lshift
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Halt other CPU&squot;s for a panic or reboot&n;&t;&t; */
r_case
id|MSG_STOP_CPU
suffix:colon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|cpu_data
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|hlt_works_ok
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;hlt&quot;
)paren
suffix:semicolon
)brace
)brace
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;CPU #%d sent invalid cross CPU message to CPU #%d: %X(%lX).&bslash;n&quot;
comma
id|smp_src_cpu
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|smp_msg_id
comma
id|smp_msg_data
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Clear the IPI, so we can receive future IPI&squot;s&n;&t; */
id|apic_read
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
multiline_comment|/* Dummy read */
id|apic_write
c_func
(paren
id|APIC_EOI
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Docs say use 0 for future compatibility */
)brace
eof
