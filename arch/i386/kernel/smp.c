multiline_comment|/*&n; *&t;Intel MP v1.1/v1.4 specification support routines for multi-pentium &n; *&t;hosts.&n; *&n; *&t;(c) 1995 Alan Cox, CymruNET Ltd  &lt;alan@cymru.net&gt;&n; *&t;Supported by Caldera http://www.caldera.com.&n; *&t;Much of the core SMP work is based on previous work by Thomas Radke, to&n; *&t;whom a great many thanks are extended.&n; *&n; *&t;Thanks to Intel for making available several different Pentium and&n; *&t;Pentium Pro MP machines.&n; *&n; *&t;This code is released under the GNU public license version 2 or&n; *&t;later.&n; *&n; *&t;Fixes&n; *&t;&t;Felix Koop&t;:&t;NR_CPUS used properly&n; *&t;&t;Jose Renau&t;:&t;Handle single CPU case.&n; *&t;&t;Alan Cox&t;:&t;By repeated request 8) - Total BogoMIP report.&n; *&t;&t;Greg Wright&t;:&t;Fix for kernel stacks panic.&n; *&t;&t;Erich Boleyn&t;:&t;MP v1.4 and additional changes.&n; *&t;Matthias Sattler&t;:&t;Changes for 2.1 kernel map.&n; *&t;Michel Lespinasse&t;:&t;Changes for 2.1 kernel map.&n; *&t;Michael Chastain&t;:&t;Change trampoline.S to gnu as.&n; *&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/mc146818rtc.h&gt;
macro_line|#include &lt;asm/i82489.h&gt;
macro_line|#include &lt;linux/smp.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/smp.h&gt;
macro_line|#include &lt;asm/io.h&gt;
multiline_comment|/*&n; *&t;Some notes on processor bugs:&n; *&n; *&t;Pentium and Pentium Pro (and all CPU&squot;s) have bugs. The Linux issues&n; *&t;for SMP are handled as follows.&n; *&n; *&t;Pentium Pro&n; *&t;&t;Occasional delivery of &squot;spurious interrupt&squot; as trap #16. This&n; *&t;is very very rare. The kernel logs the event and recovers&n; *&n; *&t;Pentium&n; *&t;&t;There is a marginal case where REP MOVS on 100MHz SMP&n; *&t;machines with B stepping processors can fail. XXX should provide&n; *&t;an L1cache=Writethrough or L1cache=off option. &n; *&n; *&t;&t;B stepping CPU&squot;s may hang. There are hardware work arounds&n; *&t;for this. We warn about it in case your board doesnt have the work&n; *&t;arounds. Basically thats so I can tell anyone with a B stepping&n; *&t;CPU and SMP problems &quot;tough&quot;.&n; *&n; *&t;Specific items [From Pentium Processor Specification Update]&n; *&n; *&t;1AP.&t;Linux doesn&squot;t use remote read&n; *&t;2AP.&t;Linux doesn&squot;t trust APIC errors&n; *&t;3AP.&t;We work around this&n; *&t;4AP.&t;Linux never generated 3 interrupts of the same priority&n; *&t;&t;to cause a lost local interrupt.&n; *&t;5AP.&t;Remote read is never used&n; *&t;9AP.&t;XXX NEED TO CHECK WE HANDLE THIS XXX&n; *&t;10AP.&t;XXX NEED TO CHECK WE HANDLE THIS XXX&n; *&t;11AP.&t;Linux read the APIC between writes to avoid this, as per&n; *&t;&t;the documentation. Make sure you preserve this as it affects&n; *&t;&t;the C stepping chips too.&n; *&n; *&t;If this sounds worrying believe me these bugs are ___RARE___ and&n; *&t;there&squot;s about nothing of note with C stepping upwards.&n; */
multiline_comment|/*&n; *&t;Why isn&squot;t this somewhere standard ??&n; */
DECL|function|max
r_extern
id|__inline
r_int
id|max
c_func
(paren
r_int
id|a
comma
r_int
id|b
)paren
(brace
r_if
c_cond
(paren
id|a
OG
id|b
)paren
(brace
r_return
id|a
suffix:semicolon
)brace
r_return
id|b
suffix:semicolon
)brace
DECL|variable|smp_b_stepping
r_static
r_int
id|smp_b_stepping
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set if we find a B stepping CPU&t;&t;&t;*/
DECL|variable|max_cpus
r_static
r_int
id|max_cpus
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Setup configured maximum number of CPUs to activate&t;*/
DECL|variable|smp_found_config
r_int
id|smp_found_config
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Have we found an SMP box &t;&t;&t;&t;*/
DECL|variable|cpu_present_map
r_int
r_int
id|cpu_present_map
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Bitmask of existing CPU&squot;s &t;&t;&t;&t;*/
DECL|variable|smp_num_cpus
r_int
id|smp_num_cpus
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Total count of live CPU&squot;s &t;&t;&t;&t;*/
DECL|variable|smp_threads_ready
r_int
id|smp_threads_ready
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set when the idlers are all forked &t;&t;&t;*/
DECL|variable|cpu_number_map
r_volatile
r_int
id|cpu_number_map
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* which CPU maps to which logical number&t;&t;*/
DECL|variable|cpu_logical_map
r_volatile
r_int
id|cpu_logical_map
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* which logical number maps to which CPU&t;&t;*/
DECL|variable|cpu_callin_map
r_volatile
r_int
r_int
id|cpu_callin_map
(braket
id|NR_CPUS
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* We always use 0 the rest is ready for parallel delivery */
DECL|variable|smp_invalidate_needed
r_volatile
r_int
r_int
id|smp_invalidate_needed
suffix:semicolon
multiline_comment|/* Used for the invalidate map that&squot;s also checked in the spinlock */
DECL|variable|kstack_ptr
r_volatile
r_int
r_int
id|kstack_ptr
suffix:semicolon
multiline_comment|/* Stack vector for booting CPU&squot;s&t;&t;&t;*/
DECL|variable|cpu_data
r_struct
id|cpuinfo_x86
id|cpu_data
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* Per cpu bogomips and other parameters &t;&t;*/
DECL|variable|num_processors
r_static
r_int
r_int
id|num_processors
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Internal processor count&t;&t;&t;&t;*/
DECL|variable|io_apic_addr
r_static
r_int
r_int
id|io_apic_addr
op_assign
l_int|0xFEC00000
suffix:semicolon
multiline_comment|/* Address of the I/O apic (not yet used) &t;&t;*/
DECL|variable|boot_cpu_id
r_int
r_char
id|boot_cpu_id
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Processor that is doing the boot up &t;&t;&t;*/
DECL|variable|kstack_base
DECL|variable|kstack_end
r_static
r_int
r_char
op_star
id|kstack_base
comma
op_star
id|kstack_end
suffix:semicolon
multiline_comment|/* Kernel stack list pointers &t;&t;&t;&t;*/
DECL|variable|smp_activated
r_static
r_int
id|smp_activated
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Tripped once we need to start cross invalidating &t;*/
DECL|variable|apic_version
r_int
id|apic_version
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* APIC version number&t;&t;&t;&t;&t;*/
DECL|variable|smp_commenced
r_static
r_volatile
r_int
id|smp_commenced
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Tripped when we start scheduling &t;&t;    &t;*/
DECL|variable|apic_addr
r_int
r_int
id|apic_addr
op_assign
l_int|0xFEE00000
suffix:semicolon
multiline_comment|/* Address of APIC (defaults to 0xFEE00000)&t;&t;*/
DECL|variable|nlong
r_int
r_int
id|nlong
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* dummy used for apic_reg address + 0x20&t;&t;*/
DECL|variable|apic_reg
r_int
r_char
op_star
id|apic_reg
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
(paren
op_amp
id|nlong
)paren
)paren
op_minus
l_int|0x20
suffix:semicolon
multiline_comment|/* Later set to the ioremap() of the APIC &t;&t;*/
DECL|variable|apic_retval
r_int
r_int
id|apic_retval
suffix:semicolon
multiline_comment|/* Just debugging the assembler.. &t;&t;&t;*/
DECL|variable|kernel_stacks
r_int
r_char
op_star
id|kernel_stacks
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* Kernel stack pointers for CPU&squot;s (debugging)&t;&t;*/
DECL|variable|smp_cpu_in_msg
r_static
r_volatile
r_int
r_char
id|smp_cpu_in_msg
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* True if this processor is sending an IPI&t;&t;*/
DECL|variable|smp_msg_data
r_static
r_volatile
r_int
r_int
id|smp_msg_data
suffix:semicolon
multiline_comment|/* IPI data pointer&t;&t;&t;&t;&t;*/
DECL|variable|smp_src_cpu
r_static
r_volatile
r_int
id|smp_src_cpu
suffix:semicolon
multiline_comment|/* IPI sender processor&t;&t;&t;&t;&t;*/
DECL|variable|smp_msg_id
r_static
r_volatile
r_int
id|smp_msg_id
suffix:semicolon
multiline_comment|/* Message being sent&t;&t;&t;&t;&t;*/
DECL|variable|kernel_flag
r_volatile
r_int
r_int
id|kernel_flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Kernel spinlock &t;&t;&t;&t;&t;*/
DECL|variable|active_kernel_processor
r_volatile
r_int
r_char
id|active_kernel_processor
op_assign
id|NO_PROC_ID
suffix:semicolon
multiline_comment|/* Processor holding kernel spinlock&t;&t;*/
DECL|variable|kernel_counter
r_volatile
r_int
r_int
id|kernel_counter
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Number of times the processor holds the lock&t;&t;*/
DECL|variable|syscall_count
r_volatile
r_int
r_int
id|syscall_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Number of times the processor holds the syscall lock&t;*/
DECL|variable|ipi_count
r_volatile
r_int
r_int
id|ipi_count
suffix:semicolon
multiline_comment|/* Number of IPI&squot;s delivered&t;&t;&t;&t;*/
macro_line|#ifdef __SMP_PROF__
DECL|variable|smp_spins
r_volatile
r_int
r_int
id|smp_spins
(braket
id|NR_CPUS
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Count interrupt spins &t;&t;&t;&t;*/
DECL|variable|smp_spins_syscall
r_volatile
r_int
r_int
id|smp_spins_syscall
(braket
id|NR_CPUS
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Count syscall spins                   &t;&t;*/
DECL|variable|smp_spins_syscall_cur
r_volatile
r_int
r_int
id|smp_spins_syscall_cur
(braket
id|NR_CPUS
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Count spins for the actual syscall                 */
DECL|variable|smp_spins_sys_idle
r_volatile
r_int
r_int
id|smp_spins_sys_idle
(braket
id|NR_CPUS
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Count spins for sys_idle &t;&t;&t;&t;*/
DECL|variable|smp_idle_count
r_volatile
r_int
r_int
id|smp_idle_count
(braket
l_int|1
op_plus
id|NR_CPUS
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Count idle ticks&t;&t;&t;&t;&t;*/
macro_line|#endif
macro_line|#if defined (__SMP_PROF__)
DECL|variable|smp_idle_map
r_volatile
r_int
r_int
id|smp_idle_map
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Map for idle processors &t;&t;&t;&t;*/
macro_line|#endif
DECL|variable|smp_proc_in_lock
r_volatile
r_int
r_int
id|smp_proc_in_lock
(braket
id|NR_CPUS
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* for computing process time */
DECL|variable|smp_process_available
r_volatile
r_int
id|smp_process_available
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*#define SMP_DEBUG*/
macro_line|#ifdef SMP_DEBUG
DECL|macro|SMP_PRINTK
mdefine_line|#define SMP_PRINTK(x)&t;printk x
macro_line|#else
DECL|macro|SMP_PRINTK
mdefine_line|#define SMP_PRINTK(x)
macro_line|#endif
multiline_comment|/*&n; *&t;Setup routine for controlling SMP activation&n; *&n; *&t;Command-line option of &quot;nosmp&quot; or &quot;maxcpus=0&quot; will disable SMP&n; *      activation entirely (the MPS table probe still happens, though).&n; *&n; *&t;Command-line option of &quot;maxcpus=&lt;NUM&gt;&quot;, where &lt;NUM&gt; is an integer&n; *&t;greater than 0, limits the maximum number of CPUs activated in&n; *&t;SMP mode to &lt;NUM&gt;.&n; */
DECL|function|smp_setup
r_void
id|smp_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_if
c_cond
(paren
id|ints
op_logical_and
id|ints
(braket
l_int|0
)braket
OG
l_int|0
)paren
id|max_cpus
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_else
id|max_cpus
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; *&t;Checksum an MP configuration block.&n; */
DECL|function|mpf_checksum
r_static
r_int
id|mpf_checksum
c_func
(paren
r_int
r_char
op_star
id|mp
comma
r_int
id|len
)paren
(brace
r_int
id|sum
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
id|sum
op_add_assign
op_star
id|mp
op_increment
suffix:semicolon
)brace
r_return
id|sum
op_amp
l_int|0xFF
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Processor encoding in an MP configuration block&n; */
DECL|function|mpc_family
r_static
r_char
op_star
id|mpc_family
c_func
(paren
r_int
id|family
comma
r_int
id|model
)paren
(brace
r_static
r_char
id|n
(braket
l_int|32
)braket
suffix:semicolon
r_static
r_char
op_star
id|model_defs
(braket
)braket
op_assign
(brace
l_string|&quot;80486DX&quot;
comma
l_string|&quot;80486DX&quot;
comma
l_string|&quot;80486SX&quot;
comma
l_string|&quot;80486DX/2 or 80487&quot;
comma
l_string|&quot;80486SL&quot;
comma
l_string|&quot;Intel5X2(tm)&quot;
comma
l_string|&quot;Unknown&quot;
comma
l_string|&quot;Unknown&quot;
comma
l_string|&quot;80486DX/4&quot;
)brace
suffix:semicolon
r_if
c_cond
(paren
id|family
op_eq
l_int|0x6
)paren
(brace
r_return
l_string|&quot;Pentium(tm) Pro&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|family
op_eq
l_int|0x5
)paren
(brace
r_return
l_string|&quot;Pentium(tm)&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|family
op_eq
l_int|0x0F
op_logical_and
id|model
op_eq
l_int|0x0F
)paren
(brace
r_return
l_string|&quot;Special controller&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|family
op_eq
l_int|0x04
op_logical_and
id|model
OL
l_int|9
)paren
(brace
r_return
id|model_defs
(braket
id|model
)braket
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|n
comma
l_string|&quot;Unknown CPU [%d:%d]&quot;
comma
id|family
comma
id|model
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Read the MPC&n; */
DECL|function|smp_read_mpc
r_static
r_int
id|smp_read_mpc
c_func
(paren
r_struct
id|mp_config_table
op_star
id|mpc
)paren
(brace
r_char
id|str
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|count
op_assign
r_sizeof
(paren
op_star
id|mpc
)paren
suffix:semicolon
r_int
id|apics
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|mpt
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|mpc
)paren
op_plus
id|count
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|mpc-&gt;mpc_signature
comma
id|MPC_SIGNATURE
comma
l_int|4
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bad signature [%c%c%c%c].&bslash;n&quot;
comma
id|mpc-&gt;mpc_signature
(braket
l_int|0
)braket
comma
id|mpc-&gt;mpc_signature
(braket
l_int|1
)braket
comma
id|mpc-&gt;mpc_signature
(braket
l_int|2
)braket
comma
id|mpc-&gt;mpc_signature
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mpf_checksum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|mpc
comma
id|mpc-&gt;mpc_length
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Checksum error.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mpc-&gt;mpc_spec
op_ne
l_int|0x01
op_logical_and
id|mpc-&gt;mpc_spec
op_ne
l_int|0x04
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bad Config Table version (%d)!!&bslash;n&quot;
comma
id|mpc-&gt;mpc_spec
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|str
comma
id|mpc-&gt;mpc_oem
comma
l_int|8
)paren
suffix:semicolon
id|str
(braket
l_int|8
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;OEM ID: %s &quot;
comma
id|str
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|str
comma
id|mpc-&gt;mpc_productid
comma
l_int|12
)paren
suffix:semicolon
id|str
(braket
l_int|12
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Product ID: %s &quot;
comma
id|str
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;APIC at: 0x%lX&bslash;n&quot;
comma
id|mpc-&gt;mpc_lapic
)paren
suffix:semicolon
multiline_comment|/* set the local APIC address */
id|apic_addr
op_assign
(paren
r_int
r_int
)paren
id|phys_to_virt
c_func
(paren
(paren
r_int
r_int
)paren
id|mpc-&gt;mpc_lapic
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now process the configuration blocks.&n;&t; */
r_while
c_loop
(paren
id|count
OL
id|mpc-&gt;mpc_length
)paren
(brace
r_switch
c_cond
(paren
op_star
id|mpt
)paren
(brace
r_case
id|MP_PROCESSOR
suffix:colon
(brace
r_struct
id|mpc_config_processor
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_processor
op_star
)paren
id|mpt
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;mpc_cpuflag
op_amp
id|CPU_ENABLED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Processor #%d %s APIC version %d&bslash;n&quot;
comma
id|m-&gt;mpc_apicid
comma
id|mpc_family
c_func
(paren
(paren
id|m-&gt;mpc_cpufeature
op_amp
id|CPU_FAMILY_MASK
)paren
op_rshift
l_int|8
comma
(paren
id|m-&gt;mpc_cpufeature
op_amp
id|CPU_MODEL_MASK
)paren
op_rshift
l_int|4
)paren
comma
id|m-&gt;mpc_apicver
)paren
suffix:semicolon
macro_line|#ifdef SMP_DEBUG&t;&t;&t;&t;&t;&t;
r_if
c_cond
(paren
id|m-&gt;mpc_featureflag
op_amp
(paren
l_int|1
op_lshift
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;    Floating point unit present.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m-&gt;mpc_featureflag
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;    Machine Exception supported.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m-&gt;mpc_featureflag
op_amp
(paren
l_int|1
op_lshift
l_int|8
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;    64 bit compare &amp; exchange supported.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|m-&gt;mpc_featureflag
op_amp
(paren
l_int|1
op_lshift
l_int|9
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;    Internal APIC present.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;&t;&t;
r_if
c_cond
(paren
id|m-&gt;mpc_cpuflag
op_amp
id|CPU_BOOTPROCESSOR
)paren
(brace
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;    Bootup CPU&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|boot_cpu_id
op_assign
id|m-&gt;mpc_apicid
suffix:semicolon
)brace
r_else
multiline_comment|/* Boot CPU already counted */
id|num_processors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;mpc_apicid
OG
id|NR_CPUS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Processor #%d unused. (Max %d processors).&bslash;n&quot;
comma
id|m-&gt;mpc_apicid
comma
id|NR_CPUS
)paren
suffix:semicolon
)brace
r_else
(brace
id|cpu_present_map
op_or_assign
(paren
l_int|1
op_lshift
id|m-&gt;mpc_apicid
)paren
suffix:semicolon
id|apic_version
(braket
id|m-&gt;mpc_apicid
)braket
op_assign
id|m-&gt;mpc_apicver
suffix:semicolon
)brace
)brace
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_BUS
suffix:colon
(brace
r_struct
id|mpc_config_bus
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_bus
op_star
)paren
id|mpt
suffix:semicolon
id|memcpy
c_func
(paren
id|str
comma
id|m-&gt;mpc_bustype
comma
l_int|6
)paren
suffix:semicolon
id|str
(braket
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Bus #%d is %s&bslash;n&quot;
comma
id|m-&gt;mpc_busid
comma
id|str
)paren
)paren
suffix:semicolon
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_IOAPIC
suffix:colon
(brace
r_struct
id|mpc_config_ioapic
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_ioapic
op_star
)paren
id|mpt
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;mpc_flags
op_amp
id|MPC_APIC_USABLE
)paren
(brace
id|apics
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;I/O APIC #%d Version %d at 0x%lX.&bslash;n&quot;
comma
id|m-&gt;mpc_apicid
comma
id|m-&gt;mpc_apicver
comma
id|m-&gt;mpc_apicaddr
)paren
suffix:semicolon
id|io_apic_addr
op_assign
(paren
r_int
r_int
)paren
id|phys_to_virt
c_func
(paren
id|m-&gt;mpc_apicaddr
)paren
suffix:semicolon
)brace
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_INTSRC
suffix:colon
(brace
r_struct
id|mpc_config_intsrc
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_intsrc
op_star
)paren
id|mpt
suffix:semicolon
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_LINTSRC
suffix:colon
(brace
r_struct
id|mpc_config_intlocal
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_intlocal
op_star
)paren
id|mpt
suffix:semicolon
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|apics
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: Multiple APIC&squot;s not supported.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|num_processors
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Scan the memory blocks for an SMP configuration block.&n; */
DECL|function|smp_scan_config
r_int
id|smp_scan_config
c_func
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|length
)paren
(brace
r_int
r_int
op_star
id|bp
op_assign
id|phys_to_virt
c_func
(paren
id|base
)paren
suffix:semicolon
r_struct
id|intel_mp_floating
op_star
id|mpf
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Scan SMP from %p for %ld bytes.&bslash;n&quot;
comma
id|bp
comma
id|length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
op_star
id|mpf
)paren
op_ne
l_int|16
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error: MPF size&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|length
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_star
id|bp
op_eq
id|SMP_MAGIC_IDENT
)paren
(brace
id|mpf
op_assign
(paren
r_struct
id|intel_mp_floating
op_star
)paren
id|bp
suffix:semicolon
r_if
c_cond
(paren
id|mpf-&gt;mpf_length
op_eq
l_int|1
op_logical_and
op_logical_neg
id|mpf_checksum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|bp
comma
l_int|16
)paren
op_logical_and
(paren
id|mpf-&gt;mpf_specification
op_eq
l_int|1
op_logical_or
id|mpf-&gt;mpf_specification
op_eq
l_int|4
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Intel MultiProcessor Specification v1.%d&bslash;n&quot;
comma
id|mpf-&gt;mpf_specification
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpf-&gt;mpf_feature2
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;    IMCR and PIC compatibility mode.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;    Virtual Wire compatibility mode.&bslash;n&quot;
)paren
suffix:semicolon
id|smp_found_config
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Now see if we need to read further.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|mpf-&gt;mpf_feature1
op_ne
l_int|0
)paren
(brace
r_int
r_int
id|cfg
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;We need to know what the local&n;&t;&t;&t;&t;&t; *&t;APIC id of the boot CPU is!&n;&t;&t;&t;&t;&t; */
multiline_comment|/*&n; *&n; *&t;HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK&n; *&n; *&t;It&squot;s not just a crazy hack...  ;-)&n; */
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;Standard page mapping&n;&t;&t;&t;&t;&t; *&t;functions don&squot;t work yet.&n;&t;&t;&t;&t;&t; *&t;We know that page 0 is not&n;&t;&t;&t;&t;&t; *&t;used.  Steal it for now!&n;&t;&t;&t;&t;&t; */
id|cfg
op_assign
id|pg0
(braket
l_int|0
)braket
suffix:semicolon
id|pg0
(braket
l_int|0
)braket
op_assign
(paren
id|apic_addr
op_or
l_int|7
)paren
suffix:semicolon
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
id|boot_cpu_id
op_assign
id|GET_APIC_ID
c_func
(paren
op_star
(paren
(paren
r_volatile
r_int
r_int
op_star
)paren
id|APIC_ID
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;Give it back&n;&t;&t;&t;&t;&t; */
id|pg0
(braket
l_int|0
)braket
op_assign
id|cfg
suffix:semicolon
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n; *&n; *&t;END OF HACK   END OF HACK   END OF HACK   END OF HACK   END OF HACK&n; *&n; */
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;2 CPUs, numbered 0 &amp; 1.&n;&t;&t;&t;&t;&t; */
id|cpu_present_map
op_assign
l_int|3
suffix:semicolon
id|num_processors
op_assign
l_int|2
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;I/O APIC at 0xFEC00000.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Bus#0 is &quot;
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|mpf-&gt;mpf_feature1
)paren
(brace
r_case
l_int|1
suffix:colon
r_case
l_int|5
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ISA&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EISA with no IRQ8 chaining&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
r_case
l_int|3
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EISA&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_case
l_int|7
suffix:colon
id|printk
c_func
(paren
l_string|&quot;MCA&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;???&bslash;nUnknown standard configuration %d&bslash;n&quot;
comma
id|mpf-&gt;mpf_feature1
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mpf-&gt;mpf_feature1
OG
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bus #1 is PCI&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;Set local APIC version to&n;&t;&t;&t;&t;&t; *&t;the integrated form.&n;&t;&t;&t;&t;&t; *&t;It&squot;s initialized to zero&n;&t;&t;&t;&t;&t; *&t;otherwise, representing&n;&t;&t;&t;&t;&t; *&t;a discrete 82489DX.&n;&t;&t;&t;&t;&t; */
id|apic_version
(braket
l_int|0
)braket
op_assign
l_int|0x10
suffix:semicolon
id|apic_version
(braket
l_int|1
)braket
op_assign
l_int|0x10
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Read the physical hardware table.&n;&t;&t;&t;&t; *&t;Anything here will override the&n;&t;&t;&t;&t; *&t;defaults.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|mpf-&gt;mpf_physptr
)paren
(brace
id|smp_read_mpc
c_func
(paren
(paren
r_void
op_star
)paren
id|mpf-&gt;mpf_physptr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Now that the boot CPU id is known,&n;&t;&t;&t;&t; *&t;set some other information about it.&n;&t;&t;&t;&t; */
id|nlong
op_assign
id|boot_cpu_id
op_lshift
l_int|24
suffix:semicolon
multiline_comment|/* Dummy &squot;self&squot; for bootup */
id|cpu_logical_map
(braket
l_int|0
)braket
op_assign
id|boot_cpu_id
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Processors: %d&bslash;n&quot;
comma
id|num_processors
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Only use the first configuration found.&n;&t;&t;&t;&t; */
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|bp
op_add_assign
l_int|4
suffix:semicolon
id|length
op_sub_assign
l_int|16
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Trampoline 80x86 program as an array.&n; */
r_extern
r_int
r_char
id|trampoline_data
(braket
)braket
suffix:semicolon
r_extern
r_int
r_char
id|trampoline_end
(braket
)braket
suffix:semicolon
multiline_comment|/*&n; *&t;Currently trivial. Write the real-&gt;protected mode&n; *&t;bootstrap into the page concerned. The caller&n; *&t;has made sure it&squot;s suitably aligned.&n; */
DECL|function|install_trampoline
r_static
r_void
id|install_trampoline
c_func
(paren
r_int
r_char
op_star
id|mp
)paren
(brace
id|memcpy
c_func
(paren
id|mp
comma
id|trampoline_data
comma
id|trampoline_end
op_minus
id|trampoline_data
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;We are called very early to get the low memory for the trampoline/kernel stacks&n; *&t;This has to be done by mm/init.c to parcel us out nice low memory. We allocate&n; *&t;the kernel stacks at 4K, 8K, 12K... currently (0-03FF is preserved for SMM and&n; *&t;other things).&n; */
DECL|function|smp_alloc_memory
r_int
r_int
id|smp_alloc_memory
c_func
(paren
r_int
r_int
id|mem_base
)paren
(brace
r_int
id|size
op_assign
(paren
id|num_processors
op_minus
l_int|1
)paren
op_star
id|PAGE_SIZE
suffix:semicolon
multiline_comment|/* Number of stacks needed */
multiline_comment|/*&n;&t; *&t;Our stacks have to be below the 1Mb line, and mem_base on entry&n;&t; *&t;is 4K aligned.&n;&t; */
r_if
c_cond
(paren
id|virt_to_phys
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|mem_base
op_plus
id|size
)paren
)paren
op_ge
l_int|0x9F000
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;smp_alloc_memory: Insufficient low memory for kernel stacks 0x%lx.&bslash;n&quot;
comma
id|mem_base
)paren
suffix:semicolon
)brace
id|kstack_base
op_assign
(paren
r_void
op_star
)paren
id|mem_base
suffix:semicolon
id|mem_base
op_add_assign
id|size
suffix:semicolon
id|kstack_end
op_assign
(paren
r_void
op_star
)paren
id|mem_base
suffix:semicolon
r_return
id|mem_base
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Hand out stacks one at a time.&n; */
DECL|function|get_kernel_stack
r_static
r_void
op_star
id|get_kernel_stack
c_func
(paren
r_void
)paren
(brace
r_void
op_star
id|stack
op_assign
id|kstack_base
suffix:semicolon
r_if
c_cond
(paren
id|kstack_base
op_ge
id|kstack_end
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|kstack_base
op_add_assign
id|PAGE_SIZE
suffix:semicolon
r_return
id|stack
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The bootstrap kernel entry code has set these up. Save them for&n; *&t;a given CPU&n; */
DECL|function|smp_store_cpu_info
r_void
id|smp_store_cpu_info
c_func
(paren
r_int
id|id
)paren
(brace
r_struct
id|cpuinfo_x86
op_star
id|c
op_assign
op_amp
id|cpu_data
(braket
id|id
)braket
suffix:semicolon
id|c-&gt;hard_math
op_assign
id|hard_math
suffix:semicolon
multiline_comment|/* Always assumed same currently */
id|c-&gt;x86
op_assign
id|x86
suffix:semicolon
id|c-&gt;x86_model
op_assign
id|x86_model
suffix:semicolon
id|c-&gt;x86_mask
op_assign
id|x86_mask
suffix:semicolon
r_if
c_cond
(paren
id|x86_mask
op_ge
l_int|1
op_logical_and
id|x86_mask
op_le
l_int|4
)paren
(brace
id|smp_b_stepping
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Remember we have B step CPUs */
id|c-&gt;x86_capability
op_assign
id|x86_capability
suffix:semicolon
id|c-&gt;fdiv_bug
op_assign
id|fdiv_bug
suffix:semicolon
id|c-&gt;wp_works_ok
op_assign
id|wp_works_ok
suffix:semicolon
multiline_comment|/* Always assumed the same currently */
id|c-&gt;hlt_works_ok
op_assign
id|hlt_works_ok
suffix:semicolon
id|c-&gt;have_cpuid
op_assign
id|have_cpuid
suffix:semicolon
id|c-&gt;udelay_val
op_assign
id|loops_per_sec
suffix:semicolon
id|strcpy
c_func
(paren
id|c-&gt;x86_vendor_id
comma
id|x86_vendor_id
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Architecture specific routine called by the kernel just before init is&n; *&t;fired off. This allows the BP to have everything in order [we hope].&n; *&t;At the end of this all the AP&squot;s will hit the system scheduling and off&n; *&t;we go. Each AP will load the system gdt&squot;s and jump through the kernel&n; *&t;init into idle(). At this point the scheduler will one day take over &n; * &t;and give them jobs to do. smp_callin is a standard routine&n; *&t;we use to track CPU&squot;s as they power up.&n; */
DECL|function|smp_commence
r_void
id|smp_commence
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; *&t;Lets the callin&squot;s below out of their loop.&n;&t; */
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Setting commenced=1, go go go&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|smp_commenced
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|smp_callin
r_void
id|smp_callin
c_func
(paren
r_void
)paren
(brace
r_extern
r_void
id|calibrate_delay
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|cpuid
op_assign
id|GET_APIC_ID
c_func
(paren
id|apic_read
c_func
(paren
id|APIC_ID
)paren
)paren
suffix:semicolon
r_int
r_int
id|l
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Activate our APIC&n;&t; */
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;CALLIN %d&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
)paren
suffix:semicolon
id|l
op_assign
id|apic_read
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
id|l
op_or_assign
(paren
l_int|1
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Enable */
id|apic_write
c_func
(paren
id|APIC_SPIV
comma
id|l
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Get our bogomips.&n;&t; */
id|calibrate_delay
c_func
(paren
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Stack at about %p&bslash;n&quot;
comma
op_amp
id|cpuid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Save our processor parameters&n;&t; */
id|smp_store_cpu_info
c_func
(paren
id|cpuid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allow the master to continue.&n;&t; */
id|set_bit
c_func
(paren
id|cpuid
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|cpu_callin_map
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Until we are ready for SMP scheduling&n;&t; */
id|load_ldt
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cpu_number_map
(braket
id|cpuid
)braket
op_eq
op_minus
l_int|1
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|task
(braket
id|cpuid
)braket
op_logical_or
id|current_set
(braket
id|cpuid
)braket
op_ne
id|task
(braket
id|cpu_number_map
(braket
id|cpuid
)braket
)braket
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
id|load_TR
c_func
(paren
id|cpu_number_map
(braket
id|cpuid
)braket
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|smp_commenced
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Commenced..&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Cycle through the processors sending APIC IPI&squot;s to boot each.&n; */
DECL|function|smp_boot_cpus
r_void
id|smp_boot_cpus
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|cpucount
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|cfg
suffix:semicolon
id|pgd_t
id|maincfg
suffix:semicolon
r_void
op_star
id|stack
suffix:semicolon
r_extern
r_int
r_int
id|init_user_stack
(braket
)braket
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Initialize the logical to physical cpu number mapping&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
id|cpu_number_map
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Setup boot CPU information&n;&t; */
id|kernel_stacks
(braket
id|boot_cpu_id
)braket
op_assign
(paren
r_void
op_star
)paren
id|init_user_stack
suffix:semicolon
multiline_comment|/* Set up for boot processor first */
id|smp_store_cpu_info
c_func
(paren
id|boot_cpu_id
)paren
suffix:semicolon
multiline_comment|/* Final full version of the data */
id|cpu_present_map
op_or_assign
(paren
l_int|1
op_lshift
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|cpu_number_map
(braket
id|boot_cpu_id
)braket
op_assign
l_int|0
suffix:semicolon
id|active_kernel_processor
op_assign
id|boot_cpu_id
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If SMP should be disabled, then really disable it!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|max_cpus
op_logical_and
id|smp_found_config
)paren
(brace
id|smp_found_config
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SMP mode deactivated, forcing use of dummy APIC emulation.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;If we don&squot;t conform to the Intel MPS standard, get out&n;&t; *&t;of here now!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|smp_found_config
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Map the local APIC into kernel space&n;&t; */
id|apic_reg
op_assign
id|ioremap
c_func
(paren
id|apic_addr
comma
l_int|4096
)paren
suffix:semicolon
r_if
c_cond
(paren
id|apic_reg
op_eq
l_int|NULL
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;Unable to map local apic.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef SMP_DEBUG&t;&t;
(brace
r_int
id|reg
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;This is to verify that we&squot;re looking at&n;&t;&t; *&t;a real local APIC.  Check these against&n;&t;&t; *&t;your board if the CPUs aren&squot;t getting&n;&t;&t; *&t;started for no apparent reason.&n;&t;&t; */
id|reg
op_assign
id|apic_read
c_func
(paren
id|APIC_VERSION
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Getting VERSION: %x&bslash;n&quot;
comma
id|reg
)paren
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_VERSION
comma
l_int|0
)paren
suffix:semicolon
id|reg
op_assign
id|apic_read
c_func
(paren
id|APIC_VERSION
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Getting VERSION: %x&bslash;n&quot;
comma
id|reg
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;The two version reads above should print the same&n;&t;&t; *&t;NON-ZERO!!! numbers.  If the second one is zero,&n;&t;&t; *&t;there is a problem with the APIC write/read&n;&t;&t; *&t;definitions.&n;&t;&t; *&n;&t;&t; *&t;The next two are just to see if we have sane values.&n;&t;&t; *&t;They&squot;re only really relevant if we&squot;re in Virtual Wire&n;&t;&t; *&t;compatibility mode, but most boxes are anymore.&n;&t;&t; */
id|reg
op_assign
id|apic_read
c_func
(paren
id|APIC_LVT0
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Getting LVT0: %x&bslash;n&quot;
comma
id|reg
)paren
)paren
suffix:semicolon
id|reg
op_assign
id|apic_read
c_func
(paren
id|APIC_LVT1
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Getting LVT1: %x&bslash;n&quot;
comma
id|reg
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Enable the local APIC&n;&t; */
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
id|cfg
op_or_assign
(paren
l_int|1
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Enable APIC */
id|apic_write
c_func
(paren
id|APIC_SPIV
comma
id|cfg
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now scan the cpu present map and fire up the other CPUs.&n;&t; */
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;CPU map: %lx&bslash;n&quot;
comma
id|cpu_present_map
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Don&squot;t even attempt to start the boot CPU!&n;&t;&t; */
r_if
c_cond
(paren
id|i
op_eq
id|boot_cpu_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cpu_present_map
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_logical_and
(paren
id|max_cpus
template_param
id|cpucount
op_plus
l_int|1
)paren
)paren
(brace
r_int
r_int
id|send_status
comma
id|accept_status
suffix:semicolon
r_int
id|timeout
comma
id|num_starts
comma
id|j
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;We need a kernel stack for each processor.&n;&t;&t;&t; */
id|stack
op_assign
id|get_kernel_stack
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* We allocated these earlier */
r_if
c_cond
(paren
id|stack
op_eq
l_int|NULL
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;No memory for processor stacks.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|kernel_stacks
(braket
id|i
)braket
op_assign
(paren
r_void
op_star
)paren
id|phys_to_virt
c_func
(paren
(paren
r_int
r_int
)paren
id|stack
)paren
suffix:semicolon
id|install_trampoline
c_func
(paren
id|stack
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Booting processor %d stack %p: &quot;
comma
id|i
comma
id|stack
)paren
suffix:semicolon
multiline_comment|/* So we set what&squot;s up   */
multiline_comment|/*&t;&t;&t;&t;&n;&t;&t;&t; *&t;This grunge runs the startup process for&n;&t;&t;&t; *&t;the targeted processor.&n;&t;&t;&t; */
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Setting warm reset code and vector.&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Install a writable page 0 entry.&n;&t;&t;&t; */
id|cfg
op_assign
id|pg0
(braket
l_int|0
)braket
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
l_int|0xa
comma
l_int|0xf
)paren
suffix:semicolon
id|pg0
(braket
l_int|0
)braket
op_assign
l_int|7
suffix:semicolon
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;1.&bslash;n&quot;
)paren
)paren
suffix:semicolon
op_star
(paren
(paren
r_volatile
r_int
r_int
op_star
)paren
id|phys_to_virt
c_func
(paren
l_int|0x469
)paren
)paren
op_assign
(paren
(paren
r_int
r_int
)paren
id|stack
)paren
op_rshift
l_int|4
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;2.&bslash;n&quot;
)paren
)paren
suffix:semicolon
op_star
(paren
(paren
r_volatile
r_int
r_int
op_star
)paren
id|phys_to_virt
c_func
(paren
l_int|0x467
)paren
)paren
op_assign
l_int|0
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;3.&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Protect it again&n;&t;&t;&t; */
id|pg0
(braket
l_int|0
)braket
op_assign
id|cfg
suffix:semicolon
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&t;walken modif&n;&t;&t;&t; *&t;enable mapping of the first 4M at virtual&n;&t;&t;&t; *&t;address zero&n;&t;&t;&t; */
id|maincfg
op_assign
id|swapper_pg_dir
(braket
l_int|0
)braket
suffix:semicolon
(paren
(paren
r_int
r_int
op_star
)paren
id|swapper_pg_dir
)paren
(braket
l_int|0
)braket
op_assign
l_int|0x102007
suffix:semicolon
multiline_comment|/* no need to local_flush_tlb :&n;&t;&t;&t;   we are setting this up for the slave processor ! */
multiline_comment|/*&n;&t;&t;&t; *&t;Be paranoid about clearing APIC errors.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|apic_version
(braket
id|i
)braket
op_amp
l_int|0xF0
)paren
(brace
id|apic_write
c_func
(paren
id|APIC_ESR
comma
l_int|0
)paren
suffix:semicolon
id|accept_status
op_assign
(paren
id|apic_read
c_func
(paren
id|APIC_ESR
)paren
op_amp
l_int|0xEF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *&t;Status is now clean&n;&t;&t;&t; */
id|send_status
op_assign
l_int|0
suffix:semicolon
id|accept_status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Starting actual IPI sequence...&n;&t;&t;&t; */
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Asserting INIT.&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Turn INIT on&n;&t;&t;&t; */
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR2
)paren
suffix:semicolon
id|cfg
op_and_assign
l_int|0x00FFFFFF
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR2
comma
id|cfg
op_or
id|SET_APIC_DEST_FIELD
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
multiline_comment|/* Target chip     &t;*/
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
suffix:semicolon
id|cfg
op_and_assign
op_complement
l_int|0xCDFFF
suffix:semicolon
multiline_comment|/* Clear bits &t;&t;*/
id|cfg
op_or_assign
(paren
id|APIC_DEST_FIELD
op_or
id|APIC_DEST_LEVELTRIG
op_or
id|APIC_DEST_ASSERT
op_or
id|APIC_DEST_DM_INIT
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR
comma
id|cfg
)paren
suffix:semicolon
multiline_comment|/* Send IPI */
id|udelay
c_func
(paren
l_int|200
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Deasserting INIT.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR2
)paren
suffix:semicolon
id|cfg
op_and_assign
l_int|0x00FFFFFF
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR2
comma
id|cfg
op_or
id|SET_APIC_DEST_FIELD
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
multiline_comment|/* Target chip     &t;*/
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
suffix:semicolon
id|cfg
op_and_assign
op_complement
l_int|0xCDFFF
suffix:semicolon
multiline_comment|/* Clear bits &t;&t;*/
id|cfg
op_or_assign
(paren
id|APIC_DEST_FIELD
op_or
id|APIC_DEST_LEVELTRIG
op_or
id|APIC_DEST_DM_INIT
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR
comma
id|cfg
)paren
suffix:semicolon
multiline_comment|/* Send IPI */
multiline_comment|/*&n;&t;&t;&t; *&t;Should we send STARTUP IPIs ?&n;&t;&t;&t; *&n;&t;&t;&t; *&t;Determine this based on the APIC version.&n;&t;&t;&t; *&t;If we don&squot;t have an integrated APIC, don&squot;t&n;&t;&t;&t; *&t;send the STARTUP IPIs.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|apic_version
(braket
id|i
)braket
op_amp
l_int|0xF0
)paren
id|num_starts
op_assign
l_int|2
suffix:semicolon
r_else
id|num_starts
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *&t;Run STARTUP IPI loop.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
op_logical_neg
(paren
id|send_status
op_logical_or
id|accept_status
)paren
op_logical_and
(paren
id|j
op_le
id|num_starts
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Sending STARTUP #%d.&bslash;n&quot;
comma
id|j
)paren
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ESR
comma
l_int|0
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;After apic_write.&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;STARTUP IPI&n;&t;&t;&t;&t; */
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR2
)paren
suffix:semicolon
id|cfg
op_and_assign
l_int|0x00FFFFFF
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR2
comma
id|cfg
op_or
id|SET_APIC_DEST_FIELD
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
multiline_comment|/* Target chip     &t;*/
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
suffix:semicolon
id|cfg
op_and_assign
op_complement
l_int|0xCDFFF
suffix:semicolon
multiline_comment|/* Clear bits &t;&t;*/
id|cfg
op_or_assign
(paren
id|APIC_DEST_FIELD
op_or
id|APIC_DEST_DM_STARTUP
op_or
(paren
(paren
(paren
r_int
)paren
id|virt_to_phys
c_func
(paren
id|stack
)paren
)paren
op_rshift
l_int|12
)paren
)paren
suffix:semicolon
multiline_comment|/* Boot on the stack &t;*/
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Before start apic_write.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR
comma
id|cfg
)paren
suffix:semicolon
multiline_comment|/* Kick the second &t;*/
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Startup point 1.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|timeout
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Sleeping.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000000
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|send_status
op_assign
(paren
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
op_amp
l_int|0x1000
)paren
)paren
op_logical_and
(paren
id|timeout
op_increment
OL
l_int|1000
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|200
)paren
suffix:semicolon
id|accept_status
op_assign
(paren
id|apic_read
c_func
(paren
id|APIC_ESR
)paren
op_amp
l_int|0xEF
)paren
suffix:semicolon
)brace
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;After Startup.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|send_status
)paren
multiline_comment|/* APIC never delivered?? */
id|printk
c_func
(paren
l_string|&quot;APIC never delivered???&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|accept_status
)paren
multiline_comment|/* Send accept error */
id|printk
c_func
(paren
l_string|&quot;APIC delivery error (%lx).&bslash;n&quot;
comma
id|accept_status
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|send_status
op_logical_or
id|accept_status
)paren
)paren
(brace
r_for
c_loop
(paren
id|timeout
op_assign
l_int|0
suffix:semicolon
id|timeout
OL
l_int|50000
suffix:semicolon
id|timeout
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_callin_map
(braket
l_int|0
)braket
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* It has booted */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Wait 5s total for a response */
)brace
r_if
c_cond
(paren
id|cpu_callin_map
(braket
l_int|0
)braket
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
id|cpucount
op_increment
suffix:semicolon
multiline_comment|/* number CPUs logically, starting from 1 (BSP is 0) */
id|cpu_number_map
(braket
id|i
)braket
op_assign
id|cpucount
suffix:semicolon
id|cpu_logical_map
(braket
id|cpucount
)braket
op_assign
id|i
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_star
(paren
(paren
r_volatile
r_int
r_char
op_star
)paren
id|phys_to_virt
c_func
(paren
l_int|8192
)paren
)paren
op_eq
l_int|0xA5
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Stuck ??&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;Not responding.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;CPU has booted.&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*      walken modif&n;                         *      restore mapping of the first 4M&n;                         */
id|swapper_pg_dir
(braket
l_int|0
)braket
op_assign
id|maincfg
suffix:semicolon
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* mark &quot;stuck&quot; area as not stuck */
op_star
(paren
(paren
r_volatile
r_int
r_int
op_star
)paren
id|phys_to_virt
c_func
(paren
l_int|8192
)paren
)paren
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; *&t;Make sure we unmap all failed CPUs&n;&t;&t; */
r_if
c_cond
(paren
id|cpu_number_map
(braket
id|i
)braket
op_eq
op_minus
l_int|1
)paren
id|cpu_present_map
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Cleanup possible dangling ends...&n;&t; */
multiline_comment|/*&n;&t; *&t;Install writable page 0 entry.&n;&t; */
id|cfg
op_assign
id|pg0
(braket
l_int|0
)braket
suffix:semicolon
id|pg0
(braket
l_int|0
)braket
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* writeable, present, addr 0 */
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Paranoid:  Set warm reset code and vector here back&n;&t; *&t;to default values.&n;&t; */
id|CMOS_WRITE
c_func
(paren
l_int|0
comma
l_int|0xf
)paren
suffix:semicolon
op_star
(paren
(paren
r_volatile
r_int
op_star
)paren
id|phys_to_virt
c_func
(paren
l_int|0x467
)paren
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Restore old page 0 entry.&n;&t; */
id|pg0
(braket
l_int|0
)braket
op_assign
id|cfg
suffix:semicolon
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allow the user to impress friends.&n;&t; */
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Before bogomips.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpucount
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error: only one processor found.&bslash;n&quot;
)paren
suffix:semicolon
id|cpu_present_map
op_assign
(paren
l_int|1
op_lshift
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|bogosum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_present_map
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
id|bogosum
op_add_assign
id|cpu_data
(braket
id|i
)braket
dot
id|udelay_val
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;Total of %d processors activated (%lu.%02lu BogoMIPS).&bslash;n&quot;
comma
id|cpucount
op_plus
l_int|1
comma
(paren
id|bogosum
op_plus
l_int|2500
)paren
op_div
l_int|500000
comma
(paren
(paren
id|bogosum
op_plus
l_int|2500
)paren
op_div
l_int|5000
)paren
op_mod
l_int|100
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Before bogocount - setting activated=1.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|smp_activated
op_assign
l_int|1
suffix:semicolon
id|smp_num_cpus
op_assign
id|cpucount
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|smp_b_stepping
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;WARNING: SMP operation may be unreliable with B stepping processors.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Boot done.&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;A non wait message cannot pass data or cpu source info. This current setup&n; *&t;is only safe because the kernel lock owner is the only person who can send a message.&n; *&n; *&t;Wrapping this whole block in a spinlock is not the safe answer either. A processor may&n; *&t;get stuck with irq&squot;s off waiting to send a message and thus not replying to the person&n; *&t;spinning for a reply....&n; *&n; *&t;In the end flush tlb ought to be the NMI and a very very short function (to avoid the old&n; *&t;IDE disk problems), and other messages sent with IRQ&squot;s enabled in a civilised fashion. That&n; *&t;will also boost performance.&n; */
DECL|function|smp_message_pass
r_void
id|smp_message_pass
c_func
(paren
r_int
id|target
comma
r_int
id|msg
comma
r_int
r_int
id|data
comma
r_int
id|wait
)paren
(brace
r_int
r_int
id|cfg
suffix:semicolon
r_int
r_int
id|target_map
suffix:semicolon
r_int
id|p
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|irq
op_assign
l_int|0x2d
suffix:semicolon
multiline_comment|/* IRQ 13 */
r_int
id|ct
op_assign
l_int|0
suffix:semicolon
r_static
r_volatile
r_int
id|message_cpu
op_assign
id|NO_PROC_ID
suffix:semicolon
multiline_comment|/*&n;&t; *&t;During boot up send no messages&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|smp_activated
op_logical_or
op_logical_neg
id|smp_commenced
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Skip the reschedule if we are waiting to clear a&n;&t; *&t;message at this time. The reschedule cannot wait&n;&t; *&t;but is not critical.&n;&t; */
r_if
c_cond
(paren
id|msg
op_eq
id|MSG_RESCHEDULE
)paren
multiline_comment|/* Reschedules we do via trap 0x30 */
(brace
id|irq
op_assign
l_int|0x30
suffix:semicolon
r_if
c_cond
(paren
id|smp_cpu_in_msg
(braket
id|p
)braket
)paren
(brace
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Sanity check we don&squot;t re-enter this across CPU&squot;s. Only the kernel&n;&t; *&t;lock holder may send messages. For a STOP_CPU we are bringing the&n;&t; *&t;entire box to the fastest halt we can.. A reschedule carries&n;&t; *&t;no data and can occur during a flush.. guess what panic&n;&t; *&t;I got to notice this bug...&n;&t; */
r_if
c_cond
(paren
id|message_cpu
op_ne
id|NO_PROC_ID
op_logical_and
id|msg
op_ne
id|MSG_STOP_CPU
op_logical_and
id|msg
op_ne
id|MSG_RESCHEDULE
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;CPU #%d: Message pass %d but pass in progress by %d of %d&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|msg
comma
id|message_cpu
comma
id|smp_msg_id
)paren
suffix:semicolon
)brace
id|message_cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We are busy&n;&t; */
id|smp_cpu_in_msg
(braket
id|p
)braket
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Reschedule is currently special&n;&t; */
r_if
c_cond
(paren
id|msg
op_ne
id|MSG_RESCHEDULE
)paren
(brace
id|smp_src_cpu
op_assign
id|p
suffix:semicolon
id|smp_msg_id
op_assign
id|msg
suffix:semicolon
id|smp_msg_data
op_assign
id|data
suffix:semicolon
)brace
multiline_comment|/*&t;printk(&quot;SMP message pass #%d to %d of %d&bslash;n&quot;,&n;&t;&t;p, msg, target);*/
multiline_comment|/*&n;&t; *&t;Wait for the APIC to become ready - this should never occur. Its&n;&t; *&t;a debugging check really.&n;&t; */
r_while
c_loop
(paren
id|ct
OL
l_int|1000
)paren
(brace
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cfg
op_amp
(paren
l_int|1
op_lshift
l_int|12
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|ct
op_increment
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Just pray... there is nothing more we can do&n;&t; */
r_if
c_cond
(paren
id|ct
op_eq
l_int|1000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CPU #%d: previous IPI still not cleared after 10mS&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Program the APIC to deliver the IPI&n;&t; */
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR2
)paren
suffix:semicolon
id|cfg
op_and_assign
l_int|0x00FFFFFF
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR2
comma
id|cfg
op_or
id|SET_APIC_DEST_FIELD
c_func
(paren
id|target
)paren
)paren
suffix:semicolon
multiline_comment|/* Target chip     &t;&t;*/
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
suffix:semicolon
id|cfg
op_and_assign
op_complement
l_int|0xFDFFF
suffix:semicolon
multiline_comment|/* Clear bits &t;&t;&t;*/
id|cfg
op_or_assign
id|APIC_DEST_FIELD
op_or
id|APIC_DEST_DM_FIXED
op_or
id|irq
suffix:semicolon
multiline_comment|/* Send an IRQ 13&t;&t;*/
multiline_comment|/*&n;&t; *&t;Set the target requirement&n;&t; */
r_if
c_cond
(paren
id|target
op_eq
id|MSG_ALL_BUT_SELF
)paren
(brace
id|cfg
op_or_assign
id|APIC_DEST_ALLBUT
suffix:semicolon
id|target_map
op_assign
id|cpu_present_map
suffix:semicolon
id|cpu_callin_map
(braket
l_int|0
)braket
op_assign
(paren
l_int|1
op_lshift
id|smp_src_cpu
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|target
op_eq
id|MSG_ALL
)paren
(brace
id|cfg
op_or_assign
id|APIC_DEST_ALLINC
suffix:semicolon
id|target_map
op_assign
id|cpu_present_map
suffix:semicolon
id|cpu_callin_map
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|target_map
op_assign
(paren
l_int|1
op_lshift
id|target
)paren
suffix:semicolon
id|cpu_callin_map
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Send the IPI. The write to APIC_ICR fires this off.&n;&t; */
id|apic_write
c_func
(paren
id|APIC_ICR
comma
id|cfg
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Spin waiting for completion&n;&t; */
r_switch
c_cond
(paren
id|wait
)paren
(brace
r_case
l_int|1
suffix:colon
r_while
c_loop
(paren
id|cpu_callin_map
(braket
l_int|0
)braket
op_ne
id|target_map
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Spin on the pass&t;&t;*/
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_while
c_loop
(paren
id|smp_invalidate_needed
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* Wait for invalidate map to clear */
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Record our completion&n;&t; */
id|smp_cpu_in_msg
(braket
id|p
)braket
op_decrement
suffix:semicolon
id|message_cpu
op_assign
id|NO_PROC_ID
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This is fraught with deadlocks. Linus does a flush tlb at a whim&n; *&t;even with IRQ&squot;s off. We have to avoid a pair of crossing flushes&n; *&t;or we are doomed.  See the notes about smp_message_pass.&n; */
DECL|function|smp_flush_tlb
r_void
id|smp_flush_tlb
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|smp_activated
op_logical_and
id|smp_processor_id
c_func
(paren
)paren
op_ne
id|active_kernel_processor
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;CPU #%d:Attempted flush tlb IPI when not AKP(=%d)&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|active_kernel_processor
)paren
suffix:semicolon
)brace
multiline_comment|/*&t;printk(&quot;SMI-&quot;);*/
multiline_comment|/*&n;&t; *&t;The assignment is safe because it&squot;s volatile so the compiler cannot reorder it,&n;&t; *&t;because the i586 has strict memory ordering and because only the kernel lock holder&n;&t; *&t;may issue a tlb flush. If you break any one of those three change this to an atomic&n;&t; *&t;bus locked or.&n;&t; */
id|smp_invalidate_needed
op_assign
id|cpu_present_map
op_amp
op_complement
(paren
l_int|1
op_lshift
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Processors spinning on the lock will see this IRQ late. The smp_invalidate_needed map will&n;&t; *&t;ensure they don&squot;t do a spurious flush tlb or miss one.&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|smp_message_pass
c_func
(paren
id|MSG_ALL_BUT_SELF
comma
id|MSG_INVALIDATE_TLB
comma
l_int|0L
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Flush the local TLB&n;&t; */
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Completed.&n;&t; */
multiline_comment|/*&t;printk(&quot;SMID&bslash;n&quot;);*/
)brace
multiline_comment|/*&t;&n; *&t;Reschedule call back&n; */
DECL|function|smp_reschedule_irq
r_void
id|smp_reschedule_irq
c_func
(paren
r_int
id|cpl
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|intr_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|smp_processor_id
c_func
(paren
)paren
op_ne
id|active_kernel_processor
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;SMP Reschedule on CPU #%d, but #%d is active.&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|active_kernel_processor
)paren
suffix:semicolon
)brace
id|need_resched
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Clear the IPI */
id|apic_read
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
multiline_comment|/* Dummy read */
id|apic_write
c_func
(paren
id|APIC_EOI
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Docs say use 0 for future compatibility */
id|intr_count
op_decrement
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Message call back.&n; */
DECL|function|smp_message_irq
r_void
id|smp_message_irq
c_func
(paren
r_int
id|cpl
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|i
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&t;static int n=0;&n;&t;if(n++&lt;NR_CPUS)&n;&t;&t;printk(&quot;IPI %d-&gt;%d(%d,%ld)&bslash;n&quot;,smp_src_cpu,i,smp_msg_id,smp_msg_data);*/
r_switch
c_cond
(paren
id|smp_msg_id
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* IRQ 13 testing - boring */
r_return
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;A TLB flush is needed.&n;&t;&t; */
r_case
id|MSG_INVALIDATE_TLB
suffix:colon
r_if
c_cond
(paren
id|clear_bit
c_func
(paren
id|i
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|smp_invalidate_needed
)paren
)paren
(brace
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
)brace
id|set_bit
c_func
(paren
id|i
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|cpu_callin_map
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&t;cpu_callin_map[0]|=1&lt;&lt;smp_processor_id();*/
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Halt other CPU&squot;s for a panic or reboot&n;&t;&t; */
r_case
id|MSG_STOP_CPU
suffix:colon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|cpu_data
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|hlt_works_ok
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;hlt&quot;
)paren
suffix:semicolon
)brace
)brace
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;CPU #%d sent invalid cross CPU message to CPU #%d: %X(%lX).&bslash;n&quot;
comma
id|smp_src_cpu
comma
id|smp_processor_id
c_func
(paren
)paren
comma
id|smp_msg_id
comma
id|smp_msg_data
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Clear the IPI, so we can receive future IPI&squot;s&n;&t; */
id|apic_read
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
multiline_comment|/* Dummy read */
id|apic_write
c_func
(paren
id|APIC_EOI
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Docs say use 0 for future compatibility */
)brace
eof
