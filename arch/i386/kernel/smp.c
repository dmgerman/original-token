multiline_comment|/*&n; *&t;Intel MP v1.1/v1.4 specification support routines for multi-pentium&n; *&t;hosts.&n; *&n; *&t;(c) 1995 Alan Cox, CymruNET Ltd  &lt;alan@cymru.net&gt;&n; *&t;(c) 1998 Ingo Molnar&n; *&n; *&t;Supported by Caldera http://www.caldera.com.&n; *&t;Much of the core SMP work is based on previous work by Thomas Radke, to&n; *&t;whom a great many thanks are extended.&n; *&n; *&t;Thanks to Intel for making available several different Pentium,&n; *&t;Pentium Pro and Pentium-II/Xeon MP machines.&n; *&n; *&t;This code is released under the GNU public license version 2 or&n; *&t;later.&n; *&n; *&t;Fixes&n; *&t;&t;Felix Koop&t;:&t;NR_CPUS used properly&n; *&t;&t;Jose Renau&t;:&t;Handle single CPU case.&n; *&t;&t;Alan Cox&t;:&t;By repeated request 8) - Total BogoMIP report.&n; *&t;&t;Greg Wright&t;:&t;Fix for kernel stacks panic.&n; *&t;&t;Erich Boleyn&t;:&t;MP v1.4 and additional changes.&n; *&t;Matthias Sattler&t;:&t;Changes for 2.1 kernel map.&n; *&t;Michel Lespinasse&t;:&t;Changes for 2.1 kernel map.&n; *&t;Michael Chastain&t;:&t;Change trampoline.S to gnu as.&n; *&t;&t;Alan Cox&t;:&t;Dumb bug: &squot;B&squot; step PPro&squot;s are fine&n; *&t;&t;Ingo Molnar&t;:&t;Added APIC timers, based on code&n; *&t;&t;&t;&t;&t;from Jose Renau&n; *&t;&t;Alan Cox&t;:&t;Added EBDA scanning&n; *&t;&t;Ingo Molnar&t;:&t;various cleanups and rewrites&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/mc146818rtc.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#ifdef CONFIG_MTRR
macro_line|#  include &lt;asm/mtrr.h&gt;
macro_line|#endif
DECL|macro|__KERNEL_SYSCALLS__
mdefine_line|#define __KERNEL_SYSCALLS__
macro_line|#include &lt;linux/unistd.h&gt;
macro_line|#include &quot;irq.h&quot;
r_extern
r_int
r_int
id|start_kernel
comma
id|_etext
suffix:semicolon
r_extern
r_void
id|update_one_process
c_func
(paren
r_struct
id|task_struct
op_star
id|p
comma
r_int
r_int
id|ticks
comma
r_int
r_int
id|user
comma
r_int
r_int
id|system
comma
r_int
id|cpu
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Some notes on processor bugs:&n; *&n; *&t;Pentium and Pentium Pro (and all CPUs) have bugs. The Linux issues&n; *&t;for SMP are handled as follows.&n; *&n; *&t;Pentium Pro&n; *&t;&t;Occasional delivery of &squot;spurious interrupt&squot; as trap #16. This&n; *&t;is very rare. The kernel logs the event and recovers&n; *&n; *&t;Pentium&n; *&t;&t;There is a marginal case where REP MOVS on 100MHz SMP&n; *&t;machines with B stepping processors can fail. XXX should provide&n; *&t;an L1cache=Writethrough or L1cache=off option.&n; *&n; *&t;&t;B stepping CPUs may hang. There are hardware work arounds&n; *&t;for this. We warn about it in case your board doesnt have the work&n; *&t;arounds. Basically thats so I can tell anyone with a B stepping&n; *&t;CPU and SMP problems &quot;tough&quot;.&n; *&n; *&t;Specific items [From Pentium Processor Specification Update]&n; *&n; *&t;1AP.&t;Linux doesn&squot;t use remote read&n; *&t;2AP.&t;Linux doesn&squot;t trust APIC errors&n; *&t;3AP.&t;We work around this&n; *&t;4AP.&t;Linux never generated 3 interrupts of the same priority&n; *&t;&t;to cause a lost local interrupt.&n; *&t;5AP.&t;Remote read is never used&n; *&t;9AP.&t;XXX NEED TO CHECK WE HANDLE THIS XXX&n; *&t;10AP.&t;XXX NEED TO CHECK WE HANDLE THIS XXX&n; *&t;11AP.&t;Linux reads the APIC between writes to avoid this, as per&n; *&t;&t;the documentation. Make sure you preserve this as it affects&n; *&t;&t;the C stepping chips too.&n; *&n; *&t;If this sounds worrying believe me these bugs are ___RARE___ and&n; *&t;there&squot;s about nothing of note with C stepping upwards.&n; */
multiline_comment|/* Kernel spinlock */
DECL|variable|kernel_flag
id|spinlock_t
id|kernel_flag
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; *&t;Why isn&squot;t this somewhere standard ??&n; *&n; * Maybe because this procedure is horribly buggy, and does&n; * not deserve to live.  Think about signedness issues for five&n; * seconds to see why.&t;&t;- Linus&n; */
DECL|function|max
r_extern
id|__inline
r_int
id|max
c_func
(paren
r_int
id|a
comma
r_int
id|b
)paren
(brace
r_if
c_cond
(paren
id|a
OG
id|b
)paren
r_return
id|a
suffix:semicolon
r_return
id|b
suffix:semicolon
)brace
multiline_comment|/*&n; * function prototypes:&n; */
r_static
r_void
id|cache_APIC_registers
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|stop_this_cpu
(paren
r_void
)paren
suffix:semicolon
DECL|variable|smp_b_stepping
r_static
r_int
id|smp_b_stepping
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set if we find a B stepping CPU&t;&t;&t;*/
DECL|variable|max_cpus
r_static
r_int
id|max_cpus
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Setup configured maximum number of CPUs to activate&t;*/
DECL|variable|smp_found_config
r_int
id|smp_found_config
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Have we found an SMP box &t;&t;&t;&t;*/
DECL|variable|cpu_present_map
r_int
r_int
id|cpu_present_map
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Bitmask of physically existing CPUs &t;&t;&t;&t;*/
DECL|variable|cpu_online_map
r_int
r_int
id|cpu_online_map
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Bitmask of currently online CPUs &t;&t;&t;&t;*/
DECL|variable|smp_num_cpus
r_int
id|smp_num_cpus
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Total count of live CPUs &t;&t;&t;&t;*/
DECL|variable|smp_threads_ready
r_int
id|smp_threads_ready
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set when the idlers are all forked &t;&t;&t;*/
DECL|variable|cpu_number_map
r_volatile
r_int
id|cpu_number_map
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* which CPU maps to which logical number&t;&t;*/
DECL|variable|__cpu_logical_map
r_volatile
r_int
id|__cpu_logical_map
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* which logical number maps to which CPU&t;&t;*/
DECL|variable|cpu_callin_map
r_static
r_volatile
r_int
r_int
id|cpu_callin_map
(braket
id|NR_CPUS
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* We always use 0 the rest is ready for parallel delivery */
DECL|variable|cpu_callout_map
r_static
r_volatile
r_int
r_int
id|cpu_callout_map
(braket
id|NR_CPUS
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* We always use 0 the rest is ready for parallel delivery */
DECL|variable|smp_invalidate_needed
r_volatile
r_int
r_int
id|smp_invalidate_needed
suffix:semicolon
multiline_comment|/* Used for the invalidate map that&squot;s also checked in the spinlock */
DECL|variable|kstack_ptr
r_volatile
r_int
r_int
id|kstack_ptr
suffix:semicolon
multiline_comment|/* Stack vector for booting CPUs&t;&t;&t;*/
DECL|variable|cpu_data
r_struct
id|cpuinfo_x86
id|cpu_data
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* Per CPU bogomips and other parameters &t;&t;*/
DECL|variable|num_processors
r_static
r_int
r_int
id|num_processors
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Internal processor count&t;&t;&t;&t;*/
DECL|variable|mp_ioapic_addr
r_int
r_int
id|mp_ioapic_addr
op_assign
l_int|0xFEC00000
suffix:semicolon
multiline_comment|/* Address of the I/O apic (not yet used) &t;&t;*/
DECL|variable|boot_cpu_id
r_int
r_char
id|boot_cpu_id
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Processor that is doing the boot up &t;&t;&t;*/
DECL|variable|smp_activated
r_static
r_int
id|smp_activated
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Tripped once we need to start cross invalidating &t;*/
DECL|variable|apic_version
r_int
id|apic_version
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/* APIC version number&t;&t;&t;&t;&t;*/
DECL|variable|apic_retval
r_int
r_int
id|apic_retval
suffix:semicolon
multiline_comment|/* Just debugging the assembler.. &t;&t;&t;*/
DECL|variable|kernel_counter
r_volatile
r_int
r_int
id|kernel_counter
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Number of times the processor holds the lock&t;&t;*/
DECL|variable|syscall_count
r_volatile
r_int
r_int
id|syscall_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Number of times the processor holds the syscall lock&t;*/
DECL|variable|ipi_count
r_volatile
r_int
r_int
id|ipi_count
suffix:semicolon
multiline_comment|/* Number of IPIs delivered&t;&t;&t;&t;*/
DECL|variable|lk_lockmsg
r_const
r_char
id|lk_lockmsg
(braket
)braket
op_assign
l_string|&quot;lock from interrupt context at %p&bslash;n&quot;
suffix:semicolon
DECL|variable|mp_bus_id_to_type
r_int
id|mp_bus_id_to_type
(braket
id|MAX_MP_BUSSES
)braket
op_assign
(brace
op_minus
l_int|1
comma
)brace
suffix:semicolon
r_extern
r_int
id|mp_irq_entries
suffix:semicolon
r_extern
r_struct
id|mpc_config_intsrc
id|mp_irqs
(braket
id|MAX_IRQ_SOURCES
)braket
suffix:semicolon
r_extern
r_int
id|mpc_default_type
suffix:semicolon
DECL|variable|mp_bus_id_to_pci_bus
r_int
id|mp_bus_id_to_pci_bus
(braket
id|MAX_MP_BUSSES
)braket
op_assign
(brace
op_minus
l_int|1
comma
)brace
suffix:semicolon
DECL|variable|mp_current_pci_id
r_int
id|mp_current_pci_id
op_assign
l_int|0
suffix:semicolon
DECL|variable|mp_lapic_addr
r_int
r_int
id|mp_lapic_addr
op_assign
l_int|0
suffix:semicolon
DECL|variable|skip_ioapic_setup
r_int
id|skip_ioapic_setup
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 1 if &quot;noapic&quot; boot option passed */
multiline_comment|/* #define SMP_DEBUG */
macro_line|#ifdef SMP_DEBUG
DECL|macro|SMP_PRINTK
mdefine_line|#define SMP_PRINTK(x)&t;printk x
macro_line|#else
DECL|macro|SMP_PRINTK
mdefine_line|#define SMP_PRINTK(x)
macro_line|#endif
multiline_comment|/*&n; *&t;Setup routine for controlling SMP activation&n; *&n; *&t;Command-line option of &quot;nosmp&quot; or &quot;maxcpus=0&quot; will disable SMP&n; *      activation entirely (the MPS table probe still happens, though).&n; *&n; *&t;Command-line option of &quot;maxcpus=&lt;NUM&gt;&quot;, where &lt;NUM&gt; is an integer&n; *&t;greater than 0, limits the maximum number of CPUs activated in&n; *&t;SMP mode to &lt;NUM&gt;.&n; */
DECL|function|smp_setup
r_void
id|__init
id|smp_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_if
c_cond
(paren
id|ints
op_logical_and
id|ints
(braket
l_int|0
)braket
OG
l_int|0
)paren
id|max_cpus
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_else
id|max_cpus
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|ack_APIC_irq
r_void
id|ack_APIC_irq
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Clear the IPI */
multiline_comment|/* Dummy read */
id|apic_read
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
multiline_comment|/* Docs say use 0 for future compatibility */
id|apic_write
c_func
(paren
id|APIC_EOI
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_X86_VISWS_APIC
multiline_comment|/*&n; * hacky!&n; */
DECL|function|smp_scan_config
r_int
id|__init
id|smp_scan_config
c_func
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|length
)paren
(brace
id|cpu_present_map
op_or_assign
l_int|2
suffix:semicolon
multiline_comment|/* or in id 1 */
id|apic_version
(braket
l_int|1
)braket
op_or_assign
l_int|0x10
suffix:semicolon
multiline_comment|/* integrated APIC */
id|num_processors
op_assign
l_int|2
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/*&n; *&t;Checksum an MP configuration block.&n; */
DECL|function|mpf_checksum
r_static
r_int
id|mpf_checksum
c_func
(paren
r_int
r_char
op_star
id|mp
comma
r_int
id|len
)paren
(brace
r_int
id|sum
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
)paren
(brace
id|sum
op_add_assign
op_star
id|mp
op_increment
suffix:semicolon
)brace
r_return
id|sum
op_amp
l_int|0xFF
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Processor encoding in an MP configuration block&n; */
DECL|function|mpc_family
r_static
r_char
op_star
id|mpc_family
c_func
(paren
r_int
id|family
comma
r_int
id|model
)paren
(brace
r_static
r_char
id|n
(braket
l_int|32
)braket
suffix:semicolon
r_static
r_char
op_star
id|model_defs
(braket
)braket
op_assign
(brace
l_string|&quot;80486DX&quot;
comma
l_string|&quot;80486DX&quot;
comma
l_string|&quot;80486SX&quot;
comma
l_string|&quot;80486DX/2 or 80487&quot;
comma
l_string|&quot;80486SL&quot;
comma
l_string|&quot;Intel5X2(tm)&quot;
comma
l_string|&quot;Unknown&quot;
comma
l_string|&quot;Unknown&quot;
comma
l_string|&quot;80486DX/4&quot;
)brace
suffix:semicolon
r_if
c_cond
(paren
id|family
op_eq
l_int|0x6
)paren
r_return
l_string|&quot;Pentium(tm) Pro&quot;
suffix:semicolon
r_if
c_cond
(paren
id|family
op_eq
l_int|0x5
)paren
r_return
l_string|&quot;Pentium(tm)&quot;
suffix:semicolon
r_if
c_cond
(paren
id|family
op_eq
l_int|0x0F
op_logical_and
id|model
op_eq
l_int|0x0F
)paren
r_return
l_string|&quot;Special controller&quot;
suffix:semicolon
r_if
c_cond
(paren
id|family
op_eq
l_int|0x04
op_logical_and
id|model
OL
l_int|9
)paren
r_return
id|model_defs
(braket
id|model
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|n
comma
l_string|&quot;Unknown CPU [%d:%d]&quot;
comma
id|family
comma
id|model
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Read the MPC&n; */
DECL|function|smp_read_mpc
r_static
r_int
id|__init
id|smp_read_mpc
c_func
(paren
r_struct
id|mp_config_table
op_star
id|mpc
)paren
(brace
r_char
id|str
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|count
op_assign
r_sizeof
(paren
op_star
id|mpc
)paren
suffix:semicolon
r_int
id|ioapics
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|mpt
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|mpc
)paren
op_plus
id|count
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|mpc-&gt;mpc_signature
comma
id|MPC_SIGNATURE
comma
l_int|4
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;SMP mptable: bad signature [%c%c%c%c]!&bslash;n&quot;
comma
id|mpc-&gt;mpc_signature
(braket
l_int|0
)braket
comma
id|mpc-&gt;mpc_signature
(braket
l_int|1
)braket
comma
id|mpc-&gt;mpc_signature
(braket
l_int|2
)braket
comma
id|mpc-&gt;mpc_signature
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mpf_checksum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|mpc
comma
id|mpc-&gt;mpc_length
)paren
)paren
(brace
id|panic
c_func
(paren
l_string|&quot;SMP mptable: checksum error!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mpc-&gt;mpc_spec
op_ne
l_int|0x01
op_logical_and
id|mpc-&gt;mpc_spec
op_ne
l_int|0x04
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bad Config Table version (%d)!!&bslash;n&quot;
comma
id|mpc-&gt;mpc_spec
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|str
comma
id|mpc-&gt;mpc_oem
comma
l_int|8
)paren
suffix:semicolon
id|str
(braket
l_int|8
)braket
op_assign
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
id|ioapic_OEM_ID
comma
id|str
comma
l_int|9
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;OEM ID: %s &quot;
comma
id|str
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|str
comma
id|mpc-&gt;mpc_productid
comma
l_int|12
)paren
suffix:semicolon
id|str
(braket
l_int|12
)braket
op_assign
l_int|0
suffix:semicolon
id|memcpy
c_func
(paren
id|ioapic_Product_ID
comma
id|str
comma
l_int|13
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Product ID: %s &quot;
comma
id|str
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;APIC at: 0x%lX&bslash;n&quot;
comma
id|mpc-&gt;mpc_lapic
)paren
suffix:semicolon
multiline_comment|/* save the local APIC address, it might be non-default */
id|mp_lapic_addr
op_assign
id|mpc-&gt;mpc_lapic
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now process the configuration blocks.&n;&t; */
r_while
c_loop
(paren
id|count
OL
id|mpc-&gt;mpc_length
)paren
(brace
r_switch
c_cond
(paren
op_star
id|mpt
)paren
(brace
r_case
id|MP_PROCESSOR
suffix:colon
(brace
r_struct
id|mpc_config_processor
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_processor
op_star
)paren
id|mpt
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;mpc_cpuflag
op_amp
id|CPU_ENABLED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Processor #%d %s APIC version %d&bslash;n&quot;
comma
id|m-&gt;mpc_apicid
comma
id|mpc_family
c_func
(paren
(paren
id|m-&gt;mpc_cpufeature
op_amp
id|CPU_FAMILY_MASK
)paren
op_rshift
l_int|8
comma
(paren
id|m-&gt;mpc_cpufeature
op_amp
id|CPU_MODEL_MASK
)paren
op_rshift
l_int|4
)paren
comma
id|m-&gt;mpc_apicver
)paren
suffix:semicolon
macro_line|#ifdef SMP_DEBUG
r_if
c_cond
(paren
id|m-&gt;mpc_featureflag
op_amp
(paren
l_int|1
op_lshift
l_int|0
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;    Floating point unit present.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;mpc_featureflag
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;    Machine Exception supported.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;mpc_featureflag
op_amp
(paren
l_int|1
op_lshift
l_int|8
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;    64 bit compare &amp; exchange supported.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;mpc_featureflag
op_amp
(paren
l_int|1
op_lshift
l_int|9
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;    Internal APIC present.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|m-&gt;mpc_cpuflag
op_amp
id|CPU_BOOTPROCESSOR
)paren
(brace
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;    Bootup CPU&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|boot_cpu_id
op_assign
id|m-&gt;mpc_apicid
suffix:semicolon
)brace
r_else
multiline_comment|/* Boot CPU already counted */
id|num_processors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;mpc_apicid
OG
id|NR_CPUS
)paren
id|printk
c_func
(paren
l_string|&quot;Processor #%d unused. (Max %d processors).&bslash;n&quot;
comma
id|m-&gt;mpc_apicid
comma
id|NR_CPUS
)paren
suffix:semicolon
r_else
(brace
id|cpu_present_map
op_or_assign
(paren
l_int|1
op_lshift
id|m-&gt;mpc_apicid
)paren
suffix:semicolon
id|apic_version
(braket
id|m-&gt;mpc_apicid
)braket
op_assign
id|m-&gt;mpc_apicver
suffix:semicolon
)brace
)brace
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_BUS
suffix:colon
(brace
r_struct
id|mpc_config_bus
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_bus
op_star
)paren
id|mpt
suffix:semicolon
id|memcpy
c_func
(paren
id|str
comma
id|m-&gt;mpc_bustype
comma
l_int|6
)paren
suffix:semicolon
id|str
(braket
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Bus #%d is %s&bslash;n&quot;
comma
id|m-&gt;mpc_busid
comma
id|str
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|strncmp
c_func
(paren
id|m-&gt;mpc_bustype
comma
l_string|&quot;ISA&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|strncmp
c_func
(paren
id|m-&gt;mpc_bustype
comma
l_string|&quot;EISA&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
)paren
id|mp_bus_id_to_type
(braket
id|m-&gt;mpc_busid
)braket
op_assign
id|MP_BUS_ISA
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
id|m-&gt;mpc_bustype
comma
l_string|&quot;PCI&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
id|mp_bus_id_to_type
(braket
id|m-&gt;mpc_busid
)braket
op_assign
id|MP_BUS_PCI
suffix:semicolon
id|mp_bus_id_to_pci_bus
(braket
id|m-&gt;mpc_busid
)braket
op_assign
id|mp_current_pci_id
suffix:semicolon
id|mp_current_pci_id
op_increment
suffix:semicolon
)brace
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_IOAPIC
suffix:colon
(brace
r_struct
id|mpc_config_ioapic
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_ioapic
op_star
)paren
id|mpt
suffix:semicolon
r_if
c_cond
(paren
id|m-&gt;mpc_flags
op_amp
id|MPC_APIC_USABLE
)paren
(brace
id|ioapics
op_increment
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;I/O APIC #%d Version %d at 0x%lX.&bslash;n&quot;
comma
id|m-&gt;mpc_apicid
comma
id|m-&gt;mpc_apicver
comma
id|m-&gt;mpc_apicaddr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * we use the first one only currently&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|ioapics
op_eq
l_int|1
)paren
id|mp_ioapic_addr
op_assign
id|m-&gt;mpc_apicaddr
suffix:semicolon
)brace
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_INTSRC
suffix:colon
(brace
r_struct
id|mpc_config_intsrc
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_intsrc
op_star
)paren
id|mpt
suffix:semicolon
id|mp_irqs
(braket
id|mp_irq_entries
)braket
op_assign
op_star
id|m
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|mp_irq_entries
op_eq
id|MAX_IRQ_SOURCES
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Max irq sources exceeded!!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Skipping remaining sources.&bslash;n&quot;
)paren
suffix:semicolon
op_decrement
id|mp_irq_entries
suffix:semicolon
)brace
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|MP_LINTSRC
suffix:colon
(brace
r_struct
id|mpc_config_intlocal
op_star
id|m
op_assign
(paren
r_struct
id|mpc_config_intlocal
op_star
)paren
id|mpt
suffix:semicolon
id|mpt
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
id|count
op_add_assign
r_sizeof
(paren
op_star
id|m
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|ioapics
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: Multiple IO-APICs not yet supported.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Warning: switching to non APIC mode.&bslash;n&quot;
)paren
suffix:semicolon
id|skip_ioapic_setup
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|num_processors
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Scan the memory blocks for an SMP configuration block.&n; */
DECL|function|smp_scan_config
r_int
id|__init
id|smp_scan_config
c_func
(paren
r_int
r_int
id|base
comma
r_int
r_int
id|length
)paren
(brace
r_int
r_int
op_star
id|bp
op_assign
id|phys_to_virt
c_func
(paren
id|base
)paren
suffix:semicolon
r_struct
id|intel_mp_floating
op_star
id|mpf
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Scan SMP from %p for %ld bytes.&bslash;n&quot;
comma
id|bp
comma
id|length
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
op_star
id|mpf
)paren
op_ne
l_int|16
)paren
id|printk
c_func
(paren
l_string|&quot;Error: MPF size&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|length
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_star
id|bp
op_eq
id|SMP_MAGIC_IDENT
)paren
(brace
id|mpf
op_assign
(paren
r_struct
id|intel_mp_floating
op_star
)paren
id|bp
suffix:semicolon
r_if
c_cond
(paren
id|mpf-&gt;mpf_length
op_eq
l_int|1
op_logical_and
op_logical_neg
id|mpf_checksum
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|bp
comma
l_int|16
)paren
op_logical_and
(paren
id|mpf-&gt;mpf_specification
op_eq
l_int|1
op_logical_or
id|mpf-&gt;mpf_specification
op_eq
l_int|4
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Intel MultiProcessor Specification v1.%d&bslash;n&quot;
comma
id|mpf-&gt;mpf_specification
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mpf-&gt;mpf_feature2
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;    IMCR and PIC compatibility mode.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;    Virtual Wire compatibility mode.&bslash;n&quot;
)paren
suffix:semicolon
id|smp_found_config
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Now see if we need to read further.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|mpf-&gt;mpf_feature1
op_ne
l_int|0
)paren
(brace
r_int
r_int
id|cfg
suffix:semicolon
multiline_comment|/* local APIC has default address */
id|mp_lapic_addr
op_assign
l_int|0xFEE00000
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;We need to know what the local&n;&t;&t;&t;&t;&t; *&t;APIC id of the boot CPU is!&n;&t;&t;&t;&t;&t; */
multiline_comment|/*&n; *&n; *&t;HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK HACK&n; *&n; *&t;It&squot;s not just a crazy hack.  ;-)&n; */
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;Standard page mapping&n;&t;&t;&t;&t;&t; *&t;functions don&squot;t work yet.&n;&t;&t;&t;&t;&t; *&t;We know that page 0 is not&n;&t;&t;&t;&t;&t; *&t;used.  Steal it for now!&n;&t;&t;&t;&t;&t; */
id|cfg
op_assign
id|pg0
(braket
l_int|0
)braket
suffix:semicolon
id|pg0
(braket
l_int|0
)braket
op_assign
(paren
id|mp_lapic_addr
op_or
l_int|7
)paren
suffix:semicolon
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
id|boot_cpu_id
op_assign
id|GET_APIC_ID
c_func
(paren
op_star
(paren
(paren
r_volatile
r_int
r_int
op_star
)paren
id|APIC_ID
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;Give it back&n;&t;&t;&t;&t;&t; */
id|pg0
(braket
l_int|0
)braket
op_assign
id|cfg
suffix:semicolon
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n; *&n; *&t;END OF HACK   END OF HACK   END OF HACK   END OF HACK   END OF HACK&n; *&n; */
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;2 CPUs, numbered 0 &amp; 1.&n;&t;&t;&t;&t;&t; */
id|cpu_present_map
op_assign
l_int|3
suffix:semicolon
id|num_processors
op_assign
l_int|2
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;I/O APIC at 0xFEC00000.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Save the default type number, we&n;&t;&t;&t;&t;&t; * need it later to set the IO-APIC&n;&t;&t;&t;&t;&t; * up properly:&n;&t;&t;&t;&t;&t; */
id|mpc_default_type
op_assign
id|mpf-&gt;mpf_feature1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Bus #0 is &quot;
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|mpf-&gt;mpf_feature1
)paren
(brace
r_case
l_int|1
suffix:colon
r_case
l_int|5
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ISA&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EISA with no IRQ8 chaining&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
r_case
l_int|3
suffix:colon
id|printk
c_func
(paren
l_string|&quot;EISA&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_case
l_int|7
suffix:colon
id|printk
c_func
(paren
l_string|&quot;MCA&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;???&bslash;nUnknown standard configuration %d&bslash;n&quot;
comma
id|mpf-&gt;mpf_feature1
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mpf-&gt;mpf_feature1
OG
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Bus #1 is PCI&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t; *&t;Set local APIC version to&n;&t;&t;&t;&t;&t; *&t;the integrated form.&n;&t;&t;&t;&t;&t; *&t;It&squot;s initialized to zero&n;&t;&t;&t;&t;&t; *&t;otherwise, representing&n;&t;&t;&t;&t;&t; *&t;a discrete 82489DX.&n;&t;&t;&t;&t;&t; */
id|apic_version
(braket
l_int|0
)braket
op_assign
l_int|0x10
suffix:semicolon
id|apic_version
(braket
l_int|1
)braket
op_assign
l_int|0x10
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Read the physical hardware table.&n;&t;&t;&t;&t; *&t;Anything here will override the&n;&t;&t;&t;&t; *&t;defaults.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|mpf-&gt;mpf_physptr
)paren
id|smp_read_mpc
c_func
(paren
(paren
r_void
op_star
)paren
id|mpf-&gt;mpf_physptr
)paren
suffix:semicolon
id|__cpu_logical_map
(braket
l_int|0
)braket
op_assign
id|boot_cpu_id
suffix:semicolon
id|global_irq_holder
op_assign
id|boot_cpu_id
suffix:semicolon
id|current-&gt;processor
op_assign
id|boot_cpu_id
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Processors: %d&bslash;n&quot;
comma
id|num_processors
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; *&t;Only use the first configuration found.&n;&t;&t;&t;&t; */
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|bp
op_add_assign
l_int|4
suffix:semicolon
id|length
op_sub_assign
l_int|16
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; *&t;Trampoline 80x86 program as an array.&n; */
r_extern
r_int
r_char
id|trampoline_data
(braket
)braket
suffix:semicolon
r_extern
r_int
r_char
id|trampoline_end
(braket
)braket
suffix:semicolon
DECL|variable|trampoline_base
r_static
r_int
r_char
op_star
id|trampoline_base
suffix:semicolon
multiline_comment|/*&n; *&t;Currently trivial. Write the real-&gt;protected mode&n; *&t;bootstrap into the page concerned. The caller&n; *&t;has made sure it&squot;s suitably aligned.&n; */
DECL|function|setup_trampoline
r_static
r_int
r_int
id|__init
id|setup_trampoline
c_func
(paren
r_void
)paren
(brace
id|memcpy
c_func
(paren
id|trampoline_base
comma
id|trampoline_data
comma
id|trampoline_end
op_minus
id|trampoline_data
)paren
suffix:semicolon
r_return
id|virt_to_phys
c_func
(paren
id|trampoline_base
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;We are called very early to get the low memory for the&n; *&t;SMP bootup trampoline page.&n; */
DECL|function|smp_alloc_memory
r_int
r_int
id|__init
id|smp_alloc_memory
c_func
(paren
r_int
r_int
id|mem_base
)paren
(brace
r_if
c_cond
(paren
id|virt_to_phys
c_func
(paren
(paren
r_void
op_star
)paren
id|mem_base
)paren
op_ge
l_int|0x9F000
)paren
id|panic
c_func
(paren
l_string|&quot;smp_alloc_memory: Insufficient low memory for kernel trampoline 0x%lx.&quot;
comma
id|mem_base
)paren
suffix:semicolon
id|trampoline_base
op_assign
(paren
r_void
op_star
)paren
id|mem_base
suffix:semicolon
r_return
id|mem_base
op_plus
id|PAGE_SIZE
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The bootstrap kernel entry code has set these up. Save them for&n; *&t;a given CPU&n; */
DECL|function|smp_store_cpu_info
r_void
id|__init
id|smp_store_cpu_info
c_func
(paren
r_int
id|id
)paren
(brace
r_struct
id|cpuinfo_x86
op_star
id|c
op_assign
op_amp
id|cpu_data
(braket
id|id
)braket
suffix:semicolon
op_star
id|c
op_assign
id|boot_cpu_data
suffix:semicolon
id|c-&gt;pte_quick
op_assign
l_int|0
suffix:semicolon
id|c-&gt;pgd_quick
op_assign
l_int|0
suffix:semicolon
id|c-&gt;pgtable_cache_sz
op_assign
l_int|0
suffix:semicolon
id|identify_cpu
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Mask B, Pentium, but not Pentium MMX&n;&t; */
r_if
c_cond
(paren
id|c-&gt;x86_vendor
op_eq
id|X86_VENDOR_INTEL
op_logical_and
id|c-&gt;x86
op_eq
l_int|5
op_logical_and
id|c-&gt;x86_mask
op_ge
l_int|1
op_logical_and
id|c-&gt;x86_mask
op_le
l_int|4
op_logical_and
id|c-&gt;x86_model
op_le
l_int|3
)paren
id|smp_b_stepping
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Remember we have B step Pentia with bugs */
)brace
multiline_comment|/*&n; *&t;Architecture specific routine called by the kernel just before init is&n; *&t;fired off. This allows the BP to have everything in order [we hope].&n; *&t;At the end of this all the APs will hit the system scheduling and off&n; *&t;we go. Each AP will load the system gdt&squot;s and jump through the kernel&n; *&t;init into idle(). At this point the scheduler will one day take over&n; * &t;and give them jobs to do. smp_callin is a standard routine&n; *&t;we use to track CPUs as they power up.&n; */
DECL|variable|smp_commenced
r_static
id|atomic_t
id|smp_commenced
op_assign
id|ATOMIC_INIT
c_func
(paren
l_int|0
)paren
suffix:semicolon
DECL|function|smp_commence
r_void
id|__init
id|smp_commence
c_func
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; *&t;Lets the callins below out of their loop.&n;&t; */
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Setting commenced=1, go go go&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|wmb
c_func
(paren
)paren
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|smp_commenced
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|enable_local_APIC
r_void
id|__init
id|enable_local_APIC
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|value
suffix:semicolon
id|value
op_assign
id|apic_read
c_func
(paren
id|APIC_SPIV
)paren
suffix:semicolon
id|value
op_or_assign
(paren
l_int|1
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Enable APIC (bit==1) */
id|value
op_and_assign
op_complement
(paren
l_int|1
op_lshift
l_int|9
)paren
suffix:semicolon
multiline_comment|/* Enable focus processor (bit==0) */
id|value
op_or_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* Set spurious IRQ vector to 0xff */
id|apic_write
c_func
(paren
id|APIC_SPIV
comma
id|value
)paren
suffix:semicolon
id|value
op_assign
id|apic_read
c_func
(paren
id|APIC_TASKPRI
)paren
suffix:semicolon
id|value
op_and_assign
op_complement
id|APIC_TPRI_MASK
suffix:semicolon
multiline_comment|/* Set Task Priority to &squot;accept all&squot; */
id|apic_write
c_func
(paren
id|APIC_TASKPRI
comma
id|value
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* B safe */
id|ack_APIC_irq
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
)brace
DECL|function|init_smp_mappings
r_int
r_int
id|__init
id|init_smp_mappings
c_func
(paren
r_int
r_int
id|memory_start
)paren
(brace
r_int
r_int
id|apic_phys
comma
id|ioapic_phys
suffix:semicolon
id|memory_start
op_assign
id|PAGE_ALIGN
c_func
(paren
id|memory_start
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smp_found_config
)paren
(brace
id|apic_phys
op_assign
id|mp_lapic_addr
suffix:semicolon
macro_line|#ifdef CONFIG_X86_IO_APIC
id|ioapic_phys
op_assign
id|mp_ioapic_addr
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * set up a fake all zeroes page to simulate the&n;&t;&t; * local APIC and another one for the IO-APIC. We&n;&t;&t; * could use the real zero-page, but it&squot;s safer&n;&t;&t; * this way if some buggy code writes to this page ...&n;&t;&t; */
id|apic_phys
op_assign
id|__pa
c_func
(paren
id|memory_start
)paren
suffix:semicolon
id|ioapic_phys
op_assign
id|__pa
c_func
(paren
id|memory_start
op_plus
id|PAGE_SIZE
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|memory_start
comma
l_int|0
comma
l_int|2
op_star
id|PAGE_SIZE
)paren
suffix:semicolon
id|memory_start
op_add_assign
l_int|2
op_star
id|PAGE_SIZE
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_X86_IO_APIC
id|set_fixmap
c_func
(paren
id|FIX_APIC_BASE
comma
id|apic_phys
)paren
suffix:semicolon
id|set_fixmap
c_func
(paren
id|FIX_IO_APIC_BASE
comma
id|ioapic_phys
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;mapped APIC to %08lx (%08lx)&bslash;n&quot;
comma
id|APIC_BASE
comma
id|apic_phys
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;mapped IOAPIC to %08lx (%08lx)&bslash;n&quot;
comma
id|fix_to_virt
c_func
(paren
id|FIX_IO_APIC_BASE
)paren
comma
id|ioapic_phys
)paren
suffix:semicolon
macro_line|#endif
r_return
id|memory_start
suffix:semicolon
)brace
r_extern
r_void
id|calibrate_delay
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|smp_callin
r_void
id|__init
id|smp_callin
c_func
(paren
r_void
)paren
(brace
r_int
id|cpuid
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
multiline_comment|/*&n;&t; * (This works even if the APIC is not enabled.)&n;&t; */
id|cpuid
op_assign
id|GET_APIC_ID
c_func
(paren
id|apic_read
c_func
(paren
id|APIC_ID
)paren
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;CPU#%d waiting for CALLOUT&bslash;n&quot;
comma
id|cpuid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * STARTUP IPIs are fragile beasts as they might sometimes&n;&t; * trigger some glue motherboard logic. Complete APIC bus&n;&t; * silence for 1 second, this overestimates the time the&n;&t; * boot CPU is spending to send the up to 2 STARTUP IPIs&n;&t; * by a factor of two. This should be enough.&n;&t; */
multiline_comment|/*&n;&t; * Waiting 2s total for startup (udelay is not yet working)&n;&t; */
id|timeout
op_assign
id|jiffies
op_plus
l_int|2
op_star
id|HZ
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Has the boot CPU finished it&squot;s STARTUP sequence?&n;&t;&t; */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|cpuid
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|cpu_callout_map
(braket
l_int|0
)braket
)paren
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;BUG: CPU%d started up but did not get a callout!&bslash;n&quot;
comma
id|cpuid
)paren
suffix:semicolon
id|stop_this_cpu
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * the boot CPU has finished the init stage and is spinning&n;&t; * on callin_map until we finish. We are free to set up this&n;&t; * CPU, first the APIC. (this is probably redundant on most&n;&t; * boards)&n;&t; */
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;CALLIN, before enable_local_APIC().&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|enable_local_APIC
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up our APIC timer.&n;&t; */
id|setup_APIC_clock
c_func
(paren
)paren
suffix:semicolon
id|__sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MTRR
multiline_comment|/*  Must be done before calibration delay is computed  */
id|mtrr_init_secondary_cpu
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Get our bogomips.&n;&t; */
id|calibrate_delay
c_func
(paren
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Stack at about %p&bslash;n&quot;
comma
op_amp
id|cpuid
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Save our processor parameters&n;&t; */
id|smp_store_cpu_info
c_func
(paren
id|cpuid
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allow the master to continue.&n;&t; */
id|set_bit
c_func
(paren
id|cpuid
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|cpu_callin_map
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
DECL|variable|cpucount
r_int
id|cpucount
op_assign
l_int|0
suffix:semicolon
r_extern
r_int
id|cpu_idle
c_func
(paren
r_void
op_star
id|unused
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Activate a secondary processor.&n; */
DECL|function|start_secondary
r_int
id|__init
id|start_secondary
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
multiline_comment|/*&n;&t; * Dont put anything before smp_callin(), SMP&n;&t; * booting is too fragile that we want to limit the&n;&t; * things done here to the most necessary things.&n;&t; */
id|smp_callin
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|atomic_read
c_func
(paren
op_amp
id|smp_commenced
)paren
)paren
multiline_comment|/* nothing */
suffix:semicolon
r_return
id|cpu_idle
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Everything has been set up for the secondary&n; * CPUs - they just need to reload everything&n; * from the task structure&n; */
DECL|function|initialize_secondary
r_void
id|__init
id|initialize_secondary
c_func
(paren
r_void
)paren
(brace
r_struct
id|thread_struct
op_star
id|p
op_assign
op_amp
id|current-&gt;tss
suffix:semicolon
multiline_comment|/*&n;&t; * Load up the LDT and the task register.&n;&t; */
id|asm
r_volatile
(paren
l_string|&quot;lldt %%ax&quot;
suffix:colon
suffix:colon
l_string|&quot;a&quot;
(paren
id|p-&gt;ldt
)paren
)paren
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;ltr %%ax&quot;
suffix:colon
suffix:colon
l_string|&quot;a&quot;
(paren
id|p-&gt;tr
)paren
)paren
suffix:semicolon
id|stts
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We don&squot;t actually need to load the full TSS,&n;&t; * basically just the stack pointer and the eip.&n;&t; */
id|asm
r_volatile
(paren
l_string|&quot;movl %0,%%esp&bslash;n&bslash;t&quot;
l_string|&quot;jmp *%1&quot;
suffix:colon
suffix:colon
l_string|&quot;r&quot;
(paren
id|p-&gt;esp
)paren
comma
l_string|&quot;r&quot;
(paren
id|p-&gt;eip
)paren
)paren
suffix:semicolon
)brace
r_extern
r_struct
(brace
DECL|member|esp
r_void
op_star
id|esp
suffix:semicolon
DECL|member|ss
r_int
r_int
id|ss
suffix:semicolon
)brace
id|stack_start
suffix:semicolon
DECL|function|do_boot_cpu
r_static
r_void
id|__init
id|do_boot_cpu
c_func
(paren
r_int
id|i
)paren
(brace
r_int
r_int
id|cfg
suffix:semicolon
id|pgd_t
id|maincfg
suffix:semicolon
r_struct
id|task_struct
op_star
id|idle
suffix:semicolon
r_int
r_int
id|send_status
comma
id|accept_status
suffix:semicolon
r_int
id|timeout
comma
id|num_starts
comma
id|j
suffix:semicolon
r_int
r_int
id|start_eip
suffix:semicolon
multiline_comment|/*&n;&t; *&t;We need an idle process for each processor.&n;&t; */
id|kernel_thread
c_func
(paren
id|start_secondary
comma
l_int|NULL
comma
id|CLONE_PID
)paren
suffix:semicolon
id|cpucount
op_increment
suffix:semicolon
id|idle
op_assign
id|task
(braket
id|cpucount
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|idle
)paren
id|panic
c_func
(paren
l_string|&quot;No idle process for CPU %d&quot;
comma
id|i
)paren
suffix:semicolon
id|idle-&gt;processor
op_assign
id|i
suffix:semicolon
id|__cpu_logical_map
(braket
id|cpucount
)braket
op_assign
id|i
suffix:semicolon
id|cpu_number_map
(braket
id|i
)braket
op_assign
id|cpucount
suffix:semicolon
multiline_comment|/* start_eip had better be page-aligned! */
id|start_eip
op_assign
id|setup_trampoline
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Booting processor %d eip %lx&bslash;n&quot;
comma
id|i
comma
id|start_eip
)paren
suffix:semicolon
multiline_comment|/* So we see what&squot;s up   */
id|stack_start.esp
op_assign
(paren
r_void
op_star
)paren
(paren
l_int|1024
op_plus
id|PAGE_SIZE
op_plus
(paren
r_char
op_star
)paren
id|idle
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;This grunge runs the startup process for&n;&t; *&t;the targeted processor.&n;&t; */
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Setting warm reset code and vector.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
l_int|0xa
comma
l_int|0xf
)paren
suffix:semicolon
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;1.&bslash;n&quot;
)paren
)paren
suffix:semicolon
op_star
(paren
(paren
r_volatile
r_int
r_int
op_star
)paren
id|phys_to_virt
c_func
(paren
l_int|0x469
)paren
)paren
op_assign
id|start_eip
op_rshift
l_int|4
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;2.&bslash;n&quot;
)paren
)paren
suffix:semicolon
op_star
(paren
(paren
r_volatile
r_int
r_int
op_star
)paren
id|phys_to_virt
c_func
(paren
l_int|0x467
)paren
)paren
op_assign
id|start_eip
op_amp
l_int|0xf
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;3.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|maincfg
op_assign
id|swapper_pg_dir
(braket
l_int|0
)braket
suffix:semicolon
(paren
(paren
r_int
r_int
op_star
)paren
id|swapper_pg_dir
)paren
(braket
l_int|0
)braket
op_assign
l_int|0x102007
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Be paranoid about clearing APIC errors.&n;&t; */
r_if
c_cond
(paren
id|apic_version
(braket
id|i
)braket
op_amp
l_int|0xF0
)paren
(brace
id|apic_write
c_func
(paren
id|APIC_ESR
comma
l_int|0
)paren
suffix:semicolon
id|accept_status
op_assign
(paren
id|apic_read
c_func
(paren
id|APIC_ESR
)paren
op_amp
l_int|0xEF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Status is now clean&n;&t; */
id|send_status
op_assign
l_int|0
suffix:semicolon
id|accept_status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Starting actual IPI sequence...&n;&t; */
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Asserting INIT.&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Turn INIT on&n;&t; */
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR2
)paren
suffix:semicolon
id|cfg
op_and_assign
l_int|0x00FFFFFF
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR2
comma
id|cfg
op_or
id|SET_APIC_DEST_FIELD
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
multiline_comment|/* Target chip     &t;*/
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
suffix:semicolon
id|cfg
op_and_assign
op_complement
l_int|0xCDFFF
suffix:semicolon
multiline_comment|/* Clear bits &t;&t;*/
id|cfg
op_or_assign
(paren
id|APIC_DEST_FIELD
op_or
id|APIC_DEST_LEVELTRIG
op_or
id|APIC_DEST_ASSERT
op_or
id|APIC_DEST_DM_INIT
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR
comma
id|cfg
)paren
suffix:semicolon
multiline_comment|/* Send IPI */
id|udelay
c_func
(paren
l_int|200
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Deasserting INIT.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR2
)paren
suffix:semicolon
id|cfg
op_and_assign
l_int|0x00FFFFFF
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR2
comma
id|cfg
op_or
id|SET_APIC_DEST_FIELD
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
multiline_comment|/* Target chip     &t;*/
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
suffix:semicolon
id|cfg
op_and_assign
op_complement
l_int|0xCDFFF
suffix:semicolon
multiline_comment|/* Clear bits &t;&t;*/
id|cfg
op_or_assign
(paren
id|APIC_DEST_FIELD
op_or
id|APIC_DEST_LEVELTRIG
op_or
id|APIC_DEST_DM_INIT
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR
comma
id|cfg
)paren
suffix:semicolon
multiline_comment|/* Send IPI */
multiline_comment|/*&n;&t; *&t;Should we send STARTUP IPIs ?&n;&t; *&n;&t; *&t;Determine this based on the APIC version.&n;&t; *&t;If we don&squot;t have an integrated APIC, don&squot;t&n;&t; *&t;send the STARTUP IPIs.&n;&t; */
r_if
c_cond
(paren
id|apic_version
(braket
id|i
)braket
op_amp
l_int|0xF0
)paren
id|num_starts
op_assign
l_int|2
suffix:semicolon
r_else
id|num_starts
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Run STARTUP IPI loop.&n;&t; */
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
op_logical_neg
(paren
id|send_status
op_logical_or
id|accept_status
)paren
op_logical_and
(paren
id|j
op_le
id|num_starts
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Sending STARTUP #%d.&bslash;n&quot;
comma
id|j
)paren
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ESR
comma
l_int|0
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;After apic_write.&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;STARTUP IPI&n;&t;&t; */
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR2
)paren
suffix:semicolon
id|cfg
op_and_assign
l_int|0x00FFFFFF
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR2
comma
id|cfg
op_or
id|SET_APIC_DEST_FIELD
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
multiline_comment|/* Target chip     &t;*/
id|cfg
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
suffix:semicolon
id|cfg
op_and_assign
op_complement
l_int|0xCDFFF
suffix:semicolon
multiline_comment|/* Clear bits &t;&t;*/
id|cfg
op_or_assign
(paren
id|APIC_DEST_FIELD
op_or
id|APIC_DEST_DM_STARTUP
op_or
(paren
id|start_eip
op_rshift
l_int|12
)paren
)paren
suffix:semicolon
multiline_comment|/* Boot on the stack &t;*/
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Before start apic_write.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR
comma
id|cfg
)paren
suffix:semicolon
multiline_comment|/* Kick the second &t;*/
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Startup point 1.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|timeout
op_assign
l_int|0
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Waiting for send to finish...&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_do
(brace
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;+&quot;
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|send_status
op_assign
id|apic_read
c_func
(paren
id|APIC_ICR
)paren
op_amp
l_int|0x1000
suffix:semicolon
)brace
r_while
c_loop
(paren
id|send_status
op_logical_and
(paren
id|timeout
op_increment
OL
l_int|1000
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Give the other CPU some time to accept the IPI.&n;&t;&t; */
id|udelay
c_func
(paren
l_int|200
)paren
suffix:semicolon
id|accept_status
op_assign
(paren
id|apic_read
c_func
(paren
id|APIC_ESR
)paren
op_amp
l_int|0xEF
)paren
suffix:semicolon
)brace
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;After Startup.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|send_status
)paren
multiline_comment|/* APIC never delivered?? */
id|printk
c_func
(paren
l_string|&quot;APIC never delivered???&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|accept_status
)paren
multiline_comment|/* Send accept error */
id|printk
c_func
(paren
l_string|&quot;APIC delivery error (%lx).&bslash;n&quot;
comma
id|accept_status
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|send_status
op_logical_or
id|accept_status
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * allow APs to start initializing.&n;&t;&t; */
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Before Callout %d.&bslash;n&quot;
comma
id|i
)paren
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|i
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|cpu_callout_map
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;After Callout %d.&bslash;n&quot;
comma
id|i
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|timeout
op_assign
l_int|0
suffix:semicolon
id|timeout
OL
l_int|50000
suffix:semicolon
id|timeout
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_callin_map
(braket
l_int|0
)braket
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* It has booted */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Wait 5s total for a response */
)brace
r_if
c_cond
(paren
id|cpu_callin_map
(braket
l_int|0
)braket
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
multiline_comment|/* number CPUs logically, starting from 1 (BSP is 0) */
macro_line|#if 0
id|cpu_number_map
(braket
id|i
)braket
op_assign
id|cpucount
suffix:semicolon
id|__cpu_logical_map
(braket
id|cpucount
)braket
op_assign
id|i
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;OK.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU%d: &quot;
comma
id|i
)paren
suffix:semicolon
id|print_cpu_info
c_func
(paren
op_amp
id|cpu_data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_star
(paren
(paren
r_volatile
r_int
r_char
op_star
)paren
id|phys_to_virt
c_func
(paren
l_int|8192
)paren
)paren
op_eq
l_int|0xA5
)paren
id|printk
c_func
(paren
l_string|&quot;Stuck ??&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;Not responding.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;CPU has booted.&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|__cpu_logical_map
(braket
id|cpucount
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|cpu_number_map
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|cpucount
op_decrement
suffix:semicolon
)brace
id|swapper_pg_dir
(braket
l_int|0
)braket
op_assign
id|maincfg
suffix:semicolon
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* mark &quot;stuck&quot; area as not stuck */
op_star
(paren
(paren
r_volatile
r_int
r_int
op_star
)paren
id|phys_to_virt
c_func
(paren
l_int|8192
)paren
)paren
op_assign
l_int|0
suffix:semicolon
)brace
DECL|variable|cacheflush_time
id|cycles_t
id|cacheflush_time
suffix:semicolon
r_extern
r_int
r_int
id|cpu_hz
suffix:semicolon
DECL|function|smp_tune_scheduling
r_static
r_void
id|smp_tune_scheduling
(paren
r_void
)paren
(brace
r_int
r_int
id|cachesize
suffix:semicolon
multiline_comment|/*&n;&t; * Rough estimation for SMP scheduling, this is the number of&n;&t; * cycles it takes for a fully memory-limited process to flush&n;&t; * the SMP-local cache.&n;&t; *&n;&t; * (For a P5 this pretty much means we will choose another idle&n;&t; *  CPU almost always at wakeup time (this is due to the small&n;&t; *  L1 cache), on PIIs it&squot;s around 50-100 usecs, depending on&n;&t; *  the cache size)&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cpu_hz
)paren
(brace
multiline_comment|/*&n;&t;&t; * this basically disables processor-affinity&n;&t;&t; * scheduling on SMP without a TSC.&n;&t;&t; */
id|cacheflush_time
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|cachesize
op_assign
id|boot_cpu_data.x86_cache_size
suffix:semicolon
r_if
c_cond
(paren
id|cachesize
op_eq
op_minus
l_int|1
)paren
id|cachesize
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* Pentiums */
id|cacheflush_time
op_assign
id|cpu_hz
op_div
l_int|1024
op_star
id|cachesize
op_div
l_int|5000
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;per-CPU timeslice cutoff: %ld.%02ld usecs.&bslash;n&quot;
comma
(paren
r_int
)paren
id|cacheflush_time
op_div
(paren
id|cpu_hz
op_div
l_int|1000000
)paren
comma
(paren
(paren
r_int
)paren
id|cacheflush_time
op_star
l_int|100
op_div
(paren
id|cpu_hz
op_div
l_int|1000000
)paren
)paren
op_mod
l_int|100
)paren
suffix:semicolon
)brace
DECL|variable|prof_multiplier
r_int
r_int
id|prof_multiplier
(braket
id|NR_CPUS
)braket
suffix:semicolon
DECL|variable|prof_counter
r_int
r_int
id|prof_counter
(braket
id|NR_CPUS
)braket
suffix:semicolon
multiline_comment|/*&n; *&t;Cycle through the processors sending APIC IPIs to boot each.&n; */
DECL|function|smp_boot_cpus
r_void
id|__init
id|smp_boot_cpus
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|cfg
suffix:semicolon
macro_line|#ifdef CONFIG_MTRR
multiline_comment|/*  Must be done before other processors booted  */
id|mtrr_init_boot_cpu
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; *&t;Initialize the logical to physical CPU number mapping&n;&t; *&t;and the per-CPU profiling counter/multiplier&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cpu_number_map
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|prof_counter
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
id|prof_multiplier
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Setup boot CPU information&n;&t; */
id|smp_store_cpu_info
c_func
(paren
id|boot_cpu_id
)paren
suffix:semicolon
multiline_comment|/* Final full version of the data */
id|smp_tune_scheduling
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CPU%d: &quot;
comma
id|boot_cpu_id
)paren
suffix:semicolon
id|print_cpu_info
c_func
(paren
op_amp
id|cpu_data
(braket
id|boot_cpu_id
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * not necessary because the MP table should list the boot&n;&t; * CPU too, but we do it for the sake of robustness anyway.&n;&t; * (and for the case when a non-SMP board boots an SMP kernel)&n;&t; */
id|cpu_present_map
op_or_assign
(paren
l_int|1
op_lshift
id|hard_smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
id|cpu_number_map
(braket
id|boot_cpu_id
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_X86_IO_APIC
multiline_comment|/*&n;&t; *&t;If we don&squot;t conform to the Intel MPS standard, get out&n;&t; *&t;of here now!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|smp_found_config
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;SMP motherboard not detected. Using dummy APIC emulation.&bslash;n&quot;
)paren
suffix:semicolon
id|io_apic_irqs
op_assign
l_int|0
suffix:semicolon
id|cpu_online_map
op_assign
id|cpu_present_map
suffix:semicolon
r_goto
id|smp_done
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t; *&t;If SMP should be disabled, then really disable it!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|max_cpus
)paren
(brace
id|smp_found_config
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;SMP mode deactivated, forcing use of dummy APIC emulation.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef SMP_DEBUG
(brace
r_int
id|reg
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;This is to verify that we&squot;re looking at&n;&t;&t; *&t;a real local APIC.  Check these against&n;&t;&t; *&t;your board if the CPUs aren&squot;t getting&n;&t;&t; *&t;started for no apparent reason.&n;&t;&t; */
id|reg
op_assign
id|apic_read
c_func
(paren
id|APIC_VERSION
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Getting VERSION: %x&bslash;n&quot;
comma
id|reg
)paren
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_VERSION
comma
l_int|0
)paren
suffix:semicolon
id|reg
op_assign
id|apic_read
c_func
(paren
id|APIC_VERSION
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Getting VERSION: %x&bslash;n&quot;
comma
id|reg
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;The two version reads above should print the same&n;&t;&t; *&t;NON-ZERO!!! numbers.  If the second one is zero,&n;&t;&t; *&t;there is a problem with the APIC write/read&n;&t;&t; *&t;definitions.&n;&t;&t; *&n;&t;&t; *&t;The next two are just to see if we have sane values.&n;&t;&t; *&t;They&squot;re only really relevant if we&squot;re in Virtual Wire&n;&t;&t; *&t;compatibility mode, but most boxes are anymore.&n;&t;&t; */
id|reg
op_assign
id|apic_read
c_func
(paren
id|APIC_LVT0
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Getting LVT0: %x&bslash;n&quot;
comma
id|reg
)paren
)paren
suffix:semicolon
id|reg
op_assign
id|apic_read
c_func
(paren
id|APIC_LVT1
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Getting LVT1: %x&bslash;n&quot;
comma
id|reg
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|enable_local_APIC
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up our local APIC timer:&n;&t; */
id|setup_APIC_clock
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Now scan the CPU present map and fire up the other CPUs.&n;&t; */
multiline_comment|/*&n;&t; * Add all detected CPUs. (later on we can down individual&n;&t; * CPUs which will change cpu_online_map but not necessarily&n;&t; * cpu_present_map. We are pretty much ready for hot-swap CPUs.)&n;&t; */
id|cpu_online_map
op_assign
id|cpu_present_map
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;CPU map: %lx&bslash;n&quot;
comma
id|cpu_present_map
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CPUS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Don&squot;t even attempt to start the boot CPU!&n;&t;&t; */
r_if
c_cond
(paren
id|i
op_eq
id|boot_cpu_id
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cpu_online_map
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_logical_and
(paren
id|max_cpus
template_param
id|cpucount
op_plus
l_int|1
)paren
)paren
(brace
id|do_boot_cpu
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Make sure we unmap all failed CPUs&n;&t;&t; */
r_if
c_cond
(paren
id|cpu_number_map
(braket
id|i
)braket
op_eq
op_minus
l_int|1
op_logical_and
(paren
id|cpu_online_map
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CPU #%d not responding. Removing from cpu_online_map.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|cpu_online_map
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;Cleanup possible dangling ends...&n;&t; */
multiline_comment|/*&n;&t; *&t;Install writable page 0 entry.&n;&t; */
id|cfg
op_assign
id|pg0
(braket
l_int|0
)braket
suffix:semicolon
id|pg0
(braket
l_int|0
)braket
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* writeable, present, addr 0 */
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Paranoid:  Set warm reset code and vector here back&n;&t; *&t;to default values.&n;&t; */
id|CMOS_WRITE
c_func
(paren
l_int|0
comma
l_int|0xf
)paren
suffix:semicolon
op_star
(paren
(paren
r_volatile
r_int
op_star
)paren
id|phys_to_virt
c_func
(paren
l_int|0x467
)paren
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Restore old page 0 entry.&n;&t; */
id|pg0
(braket
l_int|0
)braket
op_assign
id|cfg
suffix:semicolon
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Allow the user to impress friends.&n;&t; */
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Before bogomips.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpucount
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Error: only one processor found.&bslash;n&quot;
)paren
suffix:semicolon
id|cpu_online_map
op_assign
(paren
l_int|1
op_lshift
id|hard_smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|bogosum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cpu_online_map
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|bogosum
op_add_assign
id|cpu_data
(braket
id|i
)braket
dot
id|loops_per_sec
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Total of %d processors activated (%lu.%02lu BogoMIPS).&bslash;n&quot;
comma
id|cpucount
op_plus
l_int|1
comma
(paren
id|bogosum
op_plus
l_int|2500
)paren
op_div
l_int|500000
comma
(paren
(paren
id|bogosum
op_plus
l_int|2500
)paren
op_div
l_int|5000
)paren
op_mod
l_int|100
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Before bogocount - setting activated=1.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|smp_activated
op_assign
l_int|1
suffix:semicolon
id|smp_num_cpus
op_assign
id|cpucount
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|smp_b_stepping
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;WARNING: SMP operation may be unreliable with B stepping processors.&bslash;n&quot;
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;Boot done.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|cache_APIC_registers
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_X86_IO_APIC
multiline_comment|/*&n;&t; * Here we can be sure that there is an IO-APIC in the system. Let&squot;s&n;&t; * go and set it up:&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|skip_ioapic_setup
)paren
id|setup_IO_APIC
c_func
(paren
)paren
suffix:semicolon
id|smp_done
suffix:colon
macro_line|#endif
)brace
multiline_comment|/*&n; * the following functions deal with sending IPIs between CPUs.&n; *&n; * We use &squot;broadcast&squot;, CPU-&gt;CPU IPIs and self-IPIs too.&n; */
multiline_comment|/*&n; * Silly serialization to work around CPU bug in P5s.&n; * We can safely turn it off on a 686.&n; */
macro_line|#ifdef CONFIG_X86_GOOD_APIC
DECL|macro|FORCE_APIC_SERIALIZATION
macro_line|# define FORCE_APIC_SERIALIZATION 0
macro_line|#else
DECL|macro|FORCE_APIC_SERIALIZATION
macro_line|# define FORCE_APIC_SERIALIZATION 1
macro_line|#endif
DECL|variable|cached_APIC_ICR
r_static
r_int
r_int
id|cached_APIC_ICR
suffix:semicolon
DECL|variable|cached_APIC_ICR2
r_static
r_int
r_int
id|cached_APIC_ICR2
suffix:semicolon
multiline_comment|/*&n; * Caches reserved bits, APIC reads are (mildly) expensive&n; * and force otherwise unnecessary CPU synchronization.&n; *&n; * (We could cache other APIC registers too, but these are the&n; * main ones used in RL.)&n; */
DECL|macro|slow_ICR
mdefine_line|#define slow_ICR (apic_read(APIC_ICR) &amp; ~0xFDFFF)
DECL|macro|slow_ICR2
mdefine_line|#define slow_ICR2 (apic_read(APIC_ICR2) &amp; 0x00FFFFFF)
DECL|function|cache_APIC_registers
r_void
id|cache_APIC_registers
(paren
r_void
)paren
(brace
id|cached_APIC_ICR
op_assign
id|slow_ICR
suffix:semicolon
id|cached_APIC_ICR2
op_assign
id|slow_ICR2
suffix:semicolon
id|mb
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|__get_ICR
r_static
r_inline
r_int
r_int
id|__get_ICR
(paren
r_void
)paren
(brace
macro_line|#if FORCE_APIC_SERIALIZATION
multiline_comment|/*&n;&t; * Wait for the APIC to become ready - this should never occur. It&squot;s&n;&t; * a debugging check really.&n;&t; */
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|cfg
suffix:semicolon
r_while
c_loop
(paren
id|count
OL
l_int|1000
)paren
(brace
id|cfg
op_assign
id|slow_ICR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cfg
op_amp
(paren
l_int|1
op_lshift
l_int|12
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|count
)paren
id|atomic_add
c_func
(paren
id|count
comma
(paren
id|atomic_t
op_star
)paren
op_amp
id|ipi_count
)paren
suffix:semicolon
r_return
id|cfg
suffix:semicolon
)brace
id|count
op_increment
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;CPU #%d: previous IPI still not cleared after 10mS&bslash;n&quot;
comma
id|smp_processor_id
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
id|cfg
suffix:semicolon
macro_line|#else
r_return
id|cached_APIC_ICR
suffix:semicolon
macro_line|#endif
)brace
DECL|function|__get_ICR2
r_static
r_inline
r_int
r_int
id|__get_ICR2
(paren
r_void
)paren
(brace
macro_line|#if FORCE_APIC_SERIALIZATION
r_return
id|slow_ICR2
suffix:semicolon
macro_line|#else
r_return
id|cached_APIC_ICR2
suffix:semicolon
macro_line|#endif
)brace
DECL|function|__prepare_ICR
r_static
r_inline
r_int
id|__prepare_ICR
(paren
r_int
r_int
id|shortcut
comma
r_int
id|vector
)paren
(brace
r_int
r_int
id|cfg
suffix:semicolon
id|cfg
op_assign
id|__get_ICR
c_func
(paren
)paren
suffix:semicolon
id|cfg
op_or_assign
id|APIC_DEST_FIELD
op_or
id|APIC_DEST_DM_FIXED
op_or
id|shortcut
op_or
id|vector
suffix:semicolon
r_return
id|cfg
suffix:semicolon
)brace
DECL|function|__prepare_ICR2
r_static
r_inline
r_int
id|__prepare_ICR2
(paren
r_int
r_int
id|dest
)paren
(brace
r_int
r_int
id|cfg
suffix:semicolon
id|cfg
op_assign
id|__get_ICR2
c_func
(paren
)paren
suffix:semicolon
id|cfg
op_or_assign
id|SET_APIC_DEST_FIELD
c_func
(paren
id|dest
)paren
suffix:semicolon
r_return
id|cfg
suffix:semicolon
)brace
DECL|function|__send_IPI_shortcut
r_static
r_inline
r_void
id|__send_IPI_shortcut
c_func
(paren
r_int
r_int
id|shortcut
comma
r_int
id|vector
)paren
(brace
r_int
r_int
id|cfg
suffix:semicolon
multiline_comment|/*&n; * Subtle. In the case of the &squot;never do double writes&squot; workaround we&n; * have to lock out interrupts to be safe. Otherwise it&squot;s just one&n; * single atomic write to the APIC, no need for cli/sti.&n; */
macro_line|#if FORCE_APIC_SERIALIZATION
r_int
r_int
id|flags
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * No need to touch the target chip field&n;&t; */
id|cfg
op_assign
id|__prepare_ICR
c_func
(paren
id|shortcut
comma
id|vector
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Send the IPI. The write to APIC_ICR fires this off.&n;&t; */
id|apic_write
c_func
(paren
id|APIC_ICR
comma
id|cfg
)paren
suffix:semicolon
macro_line|#if FORCE_APIC_SERIALIZATION
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|send_IPI_allbutself
r_static
r_inline
r_void
id|send_IPI_allbutself
c_func
(paren
r_int
id|vector
)paren
(brace
id|__send_IPI_shortcut
c_func
(paren
id|APIC_DEST_ALLBUT
comma
id|vector
)paren
suffix:semicolon
)brace
DECL|function|send_IPI_all
r_static
r_inline
r_void
id|send_IPI_all
c_func
(paren
r_int
id|vector
)paren
(brace
id|__send_IPI_shortcut
c_func
(paren
id|APIC_DEST_ALLINC
comma
id|vector
)paren
suffix:semicolon
)brace
DECL|function|send_IPI_self
r_void
id|send_IPI_self
c_func
(paren
r_int
id|vector
)paren
(brace
id|__send_IPI_shortcut
c_func
(paren
id|APIC_DEST_SELF
comma
id|vector
)paren
suffix:semicolon
)brace
DECL|function|send_IPI_single
r_static
r_inline
r_void
id|send_IPI_single
c_func
(paren
r_int
id|dest
comma
r_int
id|vector
)paren
(brace
r_int
r_int
id|cfg
suffix:semicolon
macro_line|#if FORCE_APIC_SERIALIZATION
r_int
r_int
id|flags
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * prepare target chip field&n;&t; */
id|cfg
op_assign
id|__prepare_ICR2
c_func
(paren
id|dest
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_ICR2
comma
id|cfg
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * program the ICR &n;&t; */
id|cfg
op_assign
id|__prepare_ICR
c_func
(paren
l_int|0
comma
id|vector
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Send the IPI. The write to APIC_ICR fires this off.&n;&t; */
id|apic_write
c_func
(paren
id|APIC_ICR
comma
id|cfg
)paren
suffix:semicolon
macro_line|#if FORCE_APIC_SERIALIZATION
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * This is fraught with deadlocks. Probably the situation is not that&n; * bad as in the early days of SMP, so we might ease some of the&n; * paranoia here.&n; */
DECL|function|smp_flush_tlb
r_void
id|smp_flush_tlb
c_func
(paren
r_void
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
id|stuck
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * it&squot;s important that we do not generate any APIC traffic&n;&t; * until the AP CPUs have booted up!&n;&t; */
r_if
c_cond
(paren
id|cpu_online_map
)paren
(brace
multiline_comment|/*&n;&t;&t; * The assignment is safe because it&squot;s volatile so the&n;&t;&t; * compiler cannot reorder it, because the i586 has&n;&t;&t; * strict memory ordering and because only the kernel&n;&t;&t; * lock holder may issue a tlb flush. If you break any&n;&t;&t; * one of those three change this to an atomic bus&n;&t;&t; * locked or.&n;&t;&t; */
id|smp_invalidate_needed
op_assign
id|cpu_online_map
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Processors spinning on some lock with IRQs disabled&n;&t;&t; * will see this IRQ late. The smp_invalidate_needed&n;&t;&t; * map will ensure they don&squot;t do a spurious flush tlb&n;&t;&t; * or miss one.&n;&t;&t; */
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
id|send_IPI_allbutself
c_func
(paren
id|INVALIDATE_TLB_VECTOR
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Spin waiting for completion&n;&t;&t; */
id|stuck
op_assign
l_int|50000000
suffix:semicolon
r_while
c_loop
(paren
id|smp_invalidate_needed
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Take care of &quot;crossing&quot; invalidates&n;&t;&t;&t; */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|cpu
comma
op_amp
id|smp_invalidate_needed
)paren
)paren
id|clear_bit
c_func
(paren
id|cpu
comma
op_amp
id|smp_invalidate_needed
)paren
suffix:semicolon
op_decrement
id|stuck
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stuck
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;stuck on TLB IPI wait (CPU#%d)&bslash;n&quot;
comma
id|cpu
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Flush the local TLB&n;&t; */
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * this function sends a &squot;reschedule&squot; IPI to another CPU.&n; * it goes straight through and wastes no time serializing&n; * anything. Worst case is that we lose a reschedule ...&n; */
DECL|function|smp_send_reschedule
r_void
id|smp_send_reschedule
c_func
(paren
r_int
id|cpu
)paren
(brace
id|send_IPI_single
c_func
(paren
id|cpu
comma
id|RESCHEDULE_VECTOR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * this function sends a &squot;stop&squot; IPI to all other CPUs in the system.&n; * it goes straight through.&n; */
DECL|function|smp_send_stop
r_void
id|smp_send_stop
c_func
(paren
r_void
)paren
(brace
id|send_IPI_allbutself
c_func
(paren
id|STOP_CPU_VECTOR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * this function sends an &squot;reload MTRR state&squot; IPI to all other CPUs&n; * in the system. it goes straight through, completion processing&n; * is done on the mttr.c level.&n; */
DECL|function|smp_send_mtrr
r_void
id|smp_send_mtrr
c_func
(paren
r_void
)paren
(brace
id|send_IPI_allbutself
c_func
(paren
id|MTRR_CHANGE_VECTOR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Local timer interrupt handler. It does both profiling and&n; * process statistics/rescheduling.&n; *&n; * We do profiling in every local tick, statistics/rescheduling&n; * happen only every &squot;profiling multiplier&squot; ticks. The default&n; * multiplier is 1 and it can be changed by writing the new multiplier&n; * value into /proc/profile.&n; */
DECL|function|smp_local_timer_interrupt
r_void
id|smp_local_timer_interrupt
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The profiling function is SMP safe. (nothing can mess&n;&t; * around with &quot;current&quot;, and the profiling counters are&n;&t; * updated with atomic operations). This is especially&n;&t; * useful with a profiling multiplier != 1&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|user_mode
c_func
(paren
id|regs
)paren
)paren
id|x86_do_profile
c_func
(paren
id|regs-&gt;eip
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|prof_counter
(braket
id|cpu
)braket
)paren
(brace
r_int
id|user
op_assign
l_int|0
comma
id|system
op_assign
l_int|0
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
op_assign
id|current
suffix:semicolon
multiline_comment|/*&n;&t;&t; * After doing the above, we need to make like&n;&t;&t; * a normal interrupt - otherwise timer interrupts&n;&t;&t; * ignore the global interrupt lock, which is the&n;&t;&t; * WrongThing (tm) to do.&n;&t;&t; */
r_if
c_cond
(paren
id|user_mode
c_func
(paren
id|regs
)paren
)paren
id|user
op_assign
l_int|1
suffix:semicolon
r_else
id|system
op_assign
l_int|1
suffix:semicolon
id|irq_enter
c_func
(paren
id|cpu
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;pid
)paren
(brace
id|update_one_process
c_func
(paren
id|p
comma
l_int|1
comma
id|user
comma
id|system
comma
id|cpu
)paren
suffix:semicolon
id|p-&gt;counter
op_sub_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;counter
OL
l_int|0
)paren
(brace
id|p-&gt;counter
op_assign
l_int|0
suffix:semicolon
id|p-&gt;need_resched
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;priority
OL
id|DEF_PRIORITY
)paren
(brace
id|kstat.cpu_nice
op_add_assign
id|user
suffix:semicolon
id|kstat.per_cpu_nice
(braket
id|cpu
)braket
op_add_assign
id|user
suffix:semicolon
)brace
r_else
(brace
id|kstat.cpu_user
op_add_assign
id|user
suffix:semicolon
id|kstat.per_cpu_user
(braket
id|cpu
)braket
op_add_assign
id|user
suffix:semicolon
)brace
id|kstat.cpu_system
op_add_assign
id|system
suffix:semicolon
id|kstat.per_cpu_system
(braket
id|cpu
)braket
op_add_assign
id|system
suffix:semicolon
)brace
id|prof_counter
(braket
id|cpu
)braket
op_assign
id|prof_multiplier
(braket
id|cpu
)braket
suffix:semicolon
id|irq_exit
c_func
(paren
id|cpu
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We take the &squot;long&squot; return path, and there every subsystem&n;&t; * grabs the apropriate locks (kernel lock/ irq lock).&n;&t; *&n;&t; * we might want to decouple profiling from the &squot;long path&squot;,&n;&t; * and do the profiling totally in assembly.&n;&t; *&n;&t; * Currently this isn&squot;t too much of an issue (performance wise),&n;&t; * we can take more than 100K local irqs per second on a 100 MHz P5.&n;&t; */
)brace
multiline_comment|/*&n; * Local APIC timer interrupt. This is the most natural way for doing&n; * local interrupts, but local timer interrupts can be emulated by&n; * broadcast interrupts too. [in case the hw doesnt support APIC timers]&n; *&n; * [ if a single-CPU system runs an SMP kernel then we call the local&n; *   interrupt as well. Thus we cannot inline the local irq ... ]&n; */
DECL|function|smp_apic_timer_interrupt
r_void
id|smp_apic_timer_interrupt
c_func
(paren
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/*&n;&t; * NOTE! We&squot;d better ACK the irq immediately,&n;&t; * because timer handling can be slow, and we&n;&t; * want to be able to accept NMI tlb invalidates&n;&t; * during this time.&n;&t; */
id|ack_APIC_irq
c_func
(paren
)paren
suffix:semicolon
id|smp_local_timer_interrupt
c_func
(paren
id|regs
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Reschedule call back. Nothing to do,&n; * all the work is done automatically when&n; * we return from the interrupt.&n; */
DECL|function|smp_reschedule_interrupt
id|asmlinkage
r_void
id|smp_reschedule_interrupt
c_func
(paren
r_void
)paren
(brace
id|ack_APIC_irq
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Invalidate call-back&n; */
DECL|function|smp_invalidate_interrupt
id|asmlinkage
r_void
id|smp_invalidate_interrupt
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
op_amp
id|smp_invalidate_needed
)paren
)paren
id|local_flush_tlb
c_func
(paren
)paren
suffix:semicolon
id|ack_APIC_irq
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|stop_this_cpu
r_static
r_void
id|stop_this_cpu
(paren
r_void
)paren
(brace
multiline_comment|/*&n;&t; * Remove this CPU:&n;&t; */
id|clear_bit
c_func
(paren
id|smp_processor_id
c_func
(paren
)paren
comma
op_amp
id|cpu_online_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpu_data
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|hlt_works_ok
)paren
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;hlt&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;CPU halt call-back&n; */
DECL|function|smp_stop_cpu_interrupt
id|asmlinkage
r_void
id|smp_stop_cpu_interrupt
c_func
(paren
r_void
)paren
(brace
id|stop_this_cpu
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|mtrr_hook
r_void
(paren
op_star
id|mtrr_hook
)paren
(paren
r_void
)paren
op_assign
l_int|NULL
suffix:semicolon
DECL|function|smp_mtrr_interrupt
id|asmlinkage
r_void
id|smp_mtrr_interrupt
c_func
(paren
r_void
)paren
(brace
id|ack_APIC_irq
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mtrr_hook
)paren
(paren
op_star
id|mtrr_hook
)paren
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This interrupt should _never_ happen with our APIC/SMP architecture&n; */
DECL|function|smp_spurious_interrupt
id|asmlinkage
r_void
id|smp_spurious_interrupt
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* ack_APIC_irq();   see sw-dev-man vol 3, chapter 7.4.13.5 */
id|printk
c_func
(paren
l_string|&quot;spurious APIC interrupt, ayiee, should never happen.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This part sets up the APIC 32 bit clock in LVTT1, with HZ interrupts&n; * per second. We assume that the caller has already set up the local&n; * APIC.&n; *&n; * The APIC timer is not exactly sync with the external timer chip, it&n; * closely follows bus clocks.&n; */
DECL|macro|RDTSC
mdefine_line|#define RDTSC(x)&t;__asm__ __volatile__ (  &quot;rdtsc&quot; &bslash;&n;&t;&t;&t;&t;:&quot;=a&quot; (((unsigned long*)&amp;x)[0]),  &bslash;&n;&t;&t;&t;&t; &quot;=d&quot; (((unsigned long*)&amp;x)[1]))
multiline_comment|/*&n; * The timer chip is already set up at HZ interrupts per second here,&n; * but we do not accept timer interrupts yet. We only allow the BP&n; * to calibrate.&n; */
DECL|function|get_8254_timer_count
r_static
r_int
r_int
id|__init
id|get_8254_timer_count
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|count
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x00
comma
l_int|0x43
)paren
suffix:semicolon
id|count
op_assign
id|inb_p
c_func
(paren
l_int|0x40
)paren
suffix:semicolon
id|count
op_or_assign
id|inb_p
c_func
(paren
l_int|0x40
)paren
op_lshift
l_int|8
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; * This function sets up the local APIC timer, with a timeout of&n; * &squot;clocks&squot; APIC bus clock. During calibration we actually call&n; * this function twice, once with a bogus timeout value, second&n; * time for real. The other (noncalibrating) CPUs call this&n; * function only once, with the real value.&n; *&n; * We are strictly in irqs off mode here, as we do not want to&n; * get an APIC interrupt go off accidentally.&n; *&n; * We do reads before writes even if unnecessary, to get around the&n; * APIC double write bug.&n; */
DECL|macro|APIC_DIVISOR
mdefine_line|#define APIC_DIVISOR 16
DECL|function|setup_APIC_timer
r_void
id|setup_APIC_timer
c_func
(paren
r_int
r_int
id|clocks
)paren
(brace
r_int
r_int
id|lvtt1_value
suffix:semicolon
r_int
r_int
id|tmp_value
suffix:semicolon
multiline_comment|/*&n;&t; * Unfortunately the local APIC timer cannot be set up into NMI&n;&t; * mode. With the IO APIC we can re-route the external timer&n;&t; * interrupt and broadcast it as an NMI to all CPUs, so no pain.&n;&t; */
id|tmp_value
op_assign
id|apic_read
c_func
(paren
id|APIC_LVTT
)paren
suffix:semicolon
id|lvtt1_value
op_assign
id|APIC_LVT_TIMER_PERIODIC
op_or
id|LOCAL_TIMER_VECTOR
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_LVTT
comma
id|lvtt1_value
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Divide PICLK by 16&n;&t; */
id|tmp_value
op_assign
id|apic_read
c_func
(paren
id|APIC_TDCR
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_TDCR
comma
(paren
id|tmp_value
op_amp
op_complement
id|APIC_TDR_DIV_1
)paren
op_or
id|APIC_TDR_DIV_16
)paren
suffix:semicolon
id|tmp_value
op_assign
id|apic_read
c_func
(paren
id|APIC_TMICT
)paren
suffix:semicolon
id|apic_write
c_func
(paren
id|APIC_TMICT
comma
id|clocks
op_div
id|APIC_DIVISOR
)paren
suffix:semicolon
)brace
DECL|function|wait_8254_wraparound
r_void
id|__init
id|wait_8254_wraparound
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|curr_count
comma
id|prev_count
op_assign
op_complement
l_int|0
suffix:semicolon
r_int
id|delta
suffix:semicolon
id|curr_count
op_assign
id|get_8254_timer_count
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
id|prev_count
op_assign
id|curr_count
suffix:semicolon
id|curr_count
op_assign
id|get_8254_timer_count
c_func
(paren
)paren
suffix:semicolon
id|delta
op_assign
id|curr_count
op_minus
id|prev_count
suffix:semicolon
multiline_comment|/*&n;&t; * This limit for delta seems arbitrary, but it isn&squot;t, it&squot;s&n;&t; * slightly above the level of error a buggy Mercury/Neptune&n;&t; * chipset timer can cause.&n;&t; */
)brace
r_while
c_loop
(paren
id|delta
OL
l_int|300
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * In this function we calibrate APIC bus clocks to the external&n; * timer. Unfortunately we cannot use jiffies and the timer irq&n; * to calibrate, since some later bootup code depends on getting&n; * the first irq? Ugh.&n; *&n; * We want to do the calibration only once since we&n; * want to have local timer irqs syncron. CPUs connected&n; * by the same APIC bus have the very same bus frequency.&n; * And we want to have irqs off anyways, no accidental&n; * APIC irq that way.&n; */
DECL|function|calibrate_APIC_clock
r_int
id|__init
id|calibrate_APIC_clock
c_func
(paren
r_void
)paren
(brace
r_int
r_int
r_int
id|t1
comma
id|t2
suffix:semicolon
r_int
id|tt1
comma
id|tt2
suffix:semicolon
r_int
id|calibration_result
suffix:semicolon
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;calibrating APIC timer ... &quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Put whatever arbitrary (but long enough) timeout&n;&t; * value into the APIC clock, we just want to get the&n;&t; * counter running for calibration.&n;&t; */
id|setup_APIC_timer
c_func
(paren
l_int|1000000000
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The timer chip counts down to zero. Let&squot;s wait&n;&t; * for a wraparound to start exact measurement:&n;&t; * (the current tick might have been already half done)&n;&t; */
id|wait_8254_wraparound
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We wrapped around just now. Let&squot;s start:&n;&t; */
id|RDTSC
c_func
(paren
id|t1
)paren
suffix:semicolon
id|tt1
op_assign
id|apic_read
c_func
(paren
id|APIC_TMCCT
)paren
suffix:semicolon
DECL|macro|LOOPS
mdefine_line|#define LOOPS (HZ/10)
multiline_comment|/*&n;&t; * Let&squot;s wait LOOPS wraprounds:&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|LOOPS
suffix:semicolon
id|i
op_increment
)paren
id|wait_8254_wraparound
(paren
)paren
suffix:semicolon
id|tt2
op_assign
id|apic_read
c_func
(paren
id|APIC_TMCCT
)paren
suffix:semicolon
id|RDTSC
c_func
(paren
id|t2
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The APIC bus clock counter is 32 bits only, it&n;&t; * might have overflown, but note that we use signed&n;&t; * longs, thus no extra care needed.&n;&t; *&n;&t; * underflown to be exact, as the timer counts down ;)&n;&t; */
id|calibration_result
op_assign
(paren
id|tt1
op_minus
id|tt2
)paren
op_star
id|APIC_DIVISOR
op_div
id|LOOPS
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;&bslash;n..... %ld CPU clocks in 1 timer chip tick.&quot;
comma
(paren
r_int
r_int
)paren
(paren
id|t2
op_minus
id|t1
)paren
op_div
id|LOOPS
)paren
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;&bslash;n..... %ld APIC bus clocks in 1 timer chip tick.&quot;
comma
id|calibration_result
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n..... CPU clock speed is %ld.%04ld MHz.&bslash;n&quot;
comma
(paren
(paren
r_int
)paren
(paren
id|t2
op_minus
id|t1
)paren
op_div
id|LOOPS
)paren
op_div
(paren
l_int|1000000
op_div
id|HZ
)paren
comma
(paren
(paren
r_int
)paren
(paren
id|t2
op_minus
id|t1
)paren
op_div
id|LOOPS
)paren
op_mod
(paren
l_int|1000000
op_div
id|HZ
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;..... APIC bus clock speed is %ld.%04ld MHz.&bslash;n&quot;
comma
id|calibration_result
op_div
(paren
l_int|1000000
op_div
id|HZ
)paren
comma
id|calibration_result
op_mod
(paren
l_int|1000000
op_div
id|HZ
)paren
)paren
suffix:semicolon
DECL|macro|LOOPS
macro_line|#undef LOOPS
r_return
id|calibration_result
suffix:semicolon
)brace
DECL|variable|calibration_result
r_static
r_int
r_int
id|calibration_result
suffix:semicolon
DECL|function|setup_APIC_clock
r_void
id|__init
id|setup_APIC_clock
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_static
r_volatile
r_int
id|calibration_lock
suffix:semicolon
id|__save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|__cli
c_func
(paren
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;setup_APIC_clock() called.&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * [ setup_APIC_clock() is called from all CPUs, but we want&n;&t; *   to do this part of the setup only once ... and it fits&n;&t; *   here best ]&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|calibration_lock
)paren
)paren
(brace
id|calibration_result
op_assign
id|calibrate_APIC_clock
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; &t; * Signal completion to the other CPU[s]:&n;&t; &t; */
id|calibration_lock
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Other CPU is calibrating, wait for finish:&n;&t;&t; */
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;waiting for other CPU calibrating APIC ... &quot;
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|calibration_lock
op_eq
l_int|1
)paren
suffix:semicolon
id|SMP_PRINTK
c_func
(paren
(paren
l_string|&quot;done, continuing.&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Now set up the timer for real.&n; */
id|setup_APIC_timer
(paren
id|calibration_result
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We ACK the APIC, just in case there is something pending.&n;&t; */
id|ack_APIC_irq
(paren
)paren
suffix:semicolon
id|__restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * the frequency of the profiling timer can be changed&n; * by writing a multiplier value into /proc/profile.&n; *&n; * usually you want to run this on all CPUs ;)&n; */
DECL|function|setup_profiling_timer
r_int
id|setup_profiling_timer
c_func
(paren
r_int
r_int
id|multiplier
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * Sanity check. [at least 500 APIC cycles should be&n;&t; * between APIC interrupts as a rule of thumb, to avoid&n;&t; * irqs flooding us]&n;&t; */
r_if
c_cond
(paren
(paren
op_logical_neg
id|multiplier
)paren
op_logical_or
(paren
id|calibration_result
op_div
id|multiplier
OL
l_int|500
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|setup_APIC_timer
c_func
(paren
id|calibration_result
op_div
id|multiplier
)paren
suffix:semicolon
id|prof_multiplier
(braket
id|cpu
)braket
op_assign
id|multiplier
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|APIC_DIVISOR
macro_line|#undef APIC_DIVISOR
eof
