multiline_comment|/*&n; * x86 version of &quot;atomic_dec_and_lock()&quot; using&n; * the atomic &quot;cmpxchg&quot; instruction.&n; *&n; * (For CPU&squot;s lacking cmpxchg, we use the slow&n; * generic version, and this one never even gets&n; * compiled).&n; */
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
DECL|function|atomic_dec_and_lock
r_int
id|atomic_dec_and_lock
c_func
(paren
id|atomic_t
op_star
id|atomic
comma
id|spinlock_t
op_star
id|lock
)paren
(brace
r_int
id|counter
suffix:semicolon
r_int
id|newcount
suffix:semicolon
id|repeat
suffix:colon
id|counter
op_assign
id|atomic_read
c_func
(paren
id|atomic
)paren
suffix:semicolon
id|newcount
op_assign
id|counter
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|newcount
)paren
r_goto
id|slow_path
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;lock; cmpxchgl %1,%2&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|newcount
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|newcount
)paren
comma
l_string|&quot;m&quot;
(paren
id|atomic-&gt;counter
)paren
comma
l_string|&quot;0&quot;
(paren
id|counter
)paren
)paren
suffix:semicolon
multiline_comment|/* If the above failed, &quot;eax&quot; will have changed */
r_if
c_cond
(paren
id|newcount
op_ne
id|counter
)paren
r_goto
id|repeat
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|slow_path
suffix:colon
id|spin_lock
c_func
(paren
id|lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|atomic_dec_and_test
c_func
(paren
id|atomic
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|spin_unlock
c_func
(paren
id|lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
