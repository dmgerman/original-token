multiline_comment|/*&n; * INET&t;&t;An implementation of the TCP/IP protocol suite for the LINUX&n; *&t;&t;operating system.  INET is implemented using the  BSD Socket&n; *&t;&t;interface as the means of communication with the user level.&n; *&n; *&t;&t;IP/TCP/UDP checksumming routines&n; *&n; * Authors:&t;Jorge Cwik, &lt;jorge@laser.satlink.net&gt;&n; *&t;&t;Arnt Gulbrandsen, &lt;agulbra@nvg.unit.no&gt;&n; *&t;&t;Tom May, &lt;ftom@netcom.com&gt;&n; *              Pentium Pro/II routines:&n; *              Alexander Kjeldaas &lt;astor@guardian.no&gt;&n; *              Finn Arne Gangstad &lt;finnag@guardian.no&gt;&n; *&t;&t;Lots of code moved from tcp.c and ip.c; see those files&n; *&t;&t;for more names.&n; *&n; * Changes:     Ingo Molnar, converted csum_partial_copy() to 2.1 exception&n; *&t;&t;&t;     handling.&n; *&n; *&t;&t;This program is free software; you can redistribute it and/or&n; *&t;&t;modify it under the terms of the GNU General Public License&n; *&t;&t;as published by the Free Software Foundation; either version&n; *&t;&t;2 of the License, or (at your option) any later version.&n; */
macro_line|#include &lt;net/checksum.h&gt;
multiline_comment|/*&n; * computes a partial checksum, e.g. for TCP/UDP fragments&n; */
macro_line|#if CPU!=686
DECL|function|csum_partial
r_int
r_int
id|csum_partial
c_func
(paren
r_const
r_int
r_char
op_star
id|buff
comma
r_int
id|len
comma
r_int
r_int
id|sum
)paren
(brace
multiline_comment|/*&n;&t;   * Experiments with Ethernet and SLIP connections show that buff&n;&t;   * is aligned on either a 2-byte or 4-byte boundary.  We get at&n;&t;   * least a twofold speedup on 486 and Pentium if it is 4-byte aligned.&n;&t;   * Fortunately, it is easy to convert 2-byte alignment to 4-byte&n;&t;   * alignment for the unrolled loop.&n;&t;   */
id|__asm__
c_func
(paren
"&quot;"
id|testl
"$"
l_int|2
comma
op_mod
op_mod
id|esi
macro_line|# Check alignment.
id|jz
l_float|2f
macro_line|# Jump if alignment is ok.
id|subl
"$"
l_int|2
comma
op_mod
op_mod
id|ecx
macro_line|# Alignment uses up two bytes.
id|jae
l_float|1f
macro_line|# Jump if we had at least two bytes.
id|addl
"$"
l_int|2
comma
op_mod
op_mod
id|ecx
macro_line|# ecx was &lt; 2.  Deal with it.
id|jmp
l_float|4f
l_int|1
suffix:colon
id|movw
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|bx
id|addl
"$"
l_int|2
comma
op_mod
op_mod
id|esi
id|addw
op_mod
op_mod
id|bx
comma
op_mod
op_mod
id|ax
id|adcl
"$"
l_int|0
comma
op_mod
op_mod
id|eax
l_int|2
suffix:colon
id|movl
op_mod
op_mod
id|ecx
comma
op_mod
op_mod
id|edx
id|shrl
"$"
l_int|5
comma
op_mod
op_mod
id|ecx
id|jz
l_float|2f
id|testl
op_mod
op_mod
id|esi
comma
op_mod
op_mod
id|esi
l_int|1
suffix:colon
id|movl
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|ebx
id|adcl
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|eax
id|movl
l_int|4
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|ebx
id|adcl
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|eax
id|movl
l_int|8
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|ebx
id|adcl
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|eax
id|movl
l_int|12
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|ebx
id|adcl
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|eax
id|movl
l_int|16
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|ebx
id|adcl
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|eax
id|movl
l_int|20
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|ebx
id|adcl
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|eax
id|movl
l_int|24
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|ebx
id|adcl
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|eax
id|movl
l_int|28
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|ebx
id|adcl
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|eax
id|lea
l_int|32
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|esi
id|dec
op_mod
op_mod
id|ecx
id|jne
l_int|1
id|b
id|adcl
"$"
l_int|0
comma
op_mod
op_mod
id|eax
l_int|2
suffix:colon
id|movl
op_mod
op_mod
id|edx
comma
op_mod
op_mod
id|ecx
id|andl
"$"
l_int|0x1c
comma
op_mod
op_mod
id|edx
id|je
l_float|4f
id|shrl
"$"
l_int|2
comma
op_mod
op_mod
id|edx
macro_line|# This clears CF
l_int|3
suffix:colon
id|adcl
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|lea
l_int|4
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|esi
id|dec
op_mod
op_mod
id|edx
id|jne
l_int|3
id|b
id|adcl
"$"
l_int|0
comma
op_mod
op_mod
id|eax
l_int|4
suffix:colon
id|andl
"$"
l_int|3
comma
op_mod
op_mod
id|ecx
id|jz
l_float|7f
id|cmpl
"$"
l_int|2
comma
op_mod
op_mod
id|ecx
id|jb
l_float|5f
id|movw
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|cx
id|leal
l_int|2
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|esi
id|je
l_float|6f
id|shll
"$"
l_int|16
comma
op_mod
op_mod
id|ecx
l_int|5
suffix:colon
id|movb
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|cl
l_int|6
suffix:colon
id|addl
op_mod
op_mod
id|ecx
comma
op_mod
op_mod
id|eax
id|adcl
"$"
l_int|0
comma
op_mod
op_mod
id|eax
l_int|7
suffix:colon
"&quot;"
suffix:colon
l_string|&quot;=a&quot;
(paren
id|sum
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
comma
l_string|&quot;c&quot;
(paren
id|len
)paren
comma
l_string|&quot;S&quot;
(paren
id|buff
)paren
suffix:colon
l_string|&quot;bx&quot;
comma
l_string|&quot;cx&quot;
comma
l_string|&quot;dx&quot;
comma
l_string|&quot;si&quot;
)paren
suffix:semicolon
r_return
id|sum
suffix:semicolon
)brace
macro_line|#else  /* 686 */
DECL|function|csum_partial
r_int
r_int
id|csum_partial
c_func
(paren
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|len
comma
r_int
r_int
id|sum
)paren
(brace
id|__asm__
(paren
"&quot;"
id|testl
"$"
l_int|2
comma
op_mod
op_mod
id|esi
id|jnz
l_float|30f
l_int|10
suffix:colon
id|movl
op_mod
op_mod
id|ecx
comma
op_mod
op_mod
id|edx
id|movl
op_mod
op_mod
id|ecx
comma
op_mod
op_mod
id|ebx
id|andl
"$"
l_int|0x7c
comma
op_mod
op_mod
id|ebx
id|shrl
"$"
l_int|7
comma
op_mod
op_mod
id|ecx
id|addl
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|esi
id|shrl
"$"
l_int|2
comma
op_mod
op_mod
id|ebx
id|negl
op_mod
op_mod
id|ebx
id|lea
l_float|45f
(paren
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|ebx
comma
l_int|2
)paren
comma
op_mod
op_mod
id|ebx
id|testl
op_mod
op_mod
id|esi
comma
op_mod
op_mod
id|esi
id|jmp
op_star
op_mod
op_mod
id|ebx
macro_line|# Handle 2-byte-aligned regions
l_int|20
suffix:colon
id|addw
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|ax
id|lea
l_int|2
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|esi
id|adcl
"$"
l_int|0
comma
op_mod
op_mod
id|eax
id|jmp
l_int|10
id|b
l_int|30
suffix:colon
id|subl
"$"
l_int|2
comma
op_mod
op_mod
id|ecx
id|ja
l_int|20
id|b
id|je
l_float|32f
id|movzbl
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|ebx
macro_line|# csumming 1 byte, 2-aligned
id|addl
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|eax
id|adcl
"$"
l_int|0
comma
op_mod
op_mod
id|eax
id|jmp
l_float|80f
l_int|32
suffix:colon
id|addw
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|ax
macro_line|# csumming 2 bytes, 2-aligned
id|adcl
"$"
l_int|0
comma
op_mod
op_mod
id|eax
id|jmp
l_float|80f
l_int|40
suffix:colon
id|addl
op_minus
l_int|128
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|124
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|120
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|116
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|112
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|108
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|104
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|100
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|96
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|92
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|88
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|84
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|80
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|76
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|72
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|68
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|64
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|60
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|56
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|52
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|48
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|44
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|40
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|36
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|32
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|28
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|24
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|20
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|16
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|12
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|8
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
id|adcl
op_minus
l_int|4
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
l_int|45
suffix:colon
id|lea
l_int|128
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|esi
id|adcl
"$"
l_int|0
comma
op_mod
op_mod
id|eax
id|dec
op_mod
op_mod
id|ecx
id|jge
l_int|40
id|b
id|movl
op_mod
op_mod
id|edx
comma
op_mod
op_mod
id|ecx
l_int|50
suffix:colon
id|andl
"$"
l_int|3
comma
op_mod
op_mod
id|ecx
id|jz
l_float|80f
macro_line|# Handle the last 1-3 bytes without jumping
id|notl
op_mod
op_mod
id|ecx
macro_line|# 1-&gt;2, 2-&gt;1, 3-&gt;0, higher bits are masked
id|movl
"$"
l_int|0xffffff
comma
op_mod
op_mod
id|ebx
macro_line|# by the shll and shrl instructions
id|shll
"$"
l_int|3
comma
op_mod
op_mod
id|ecx
id|shrl
op_mod
op_mod
id|cl
comma
op_mod
op_mod
id|ebx
id|andl
op_minus
l_int|128
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|ebx
macro_line|# esi is 4-aligned so should be ok
id|addl
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|eax
id|adcl
"$"
l_int|0
comma
op_mod
op_mod
id|eax
l_int|80
suffix:colon
"&quot;"
suffix:colon
l_string|&quot;=a&quot;
(paren
id|sum
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
comma
l_string|&quot;c&quot;
(paren
id|len
)paren
comma
l_string|&quot;S&quot;
(paren
id|buf
)paren
suffix:colon
l_string|&quot;bx&quot;
comma
l_string|&quot;cx&quot;
comma
l_string|&quot;dx&quot;
comma
l_string|&quot;si&quot;
)paren
suffix:semicolon
r_return
id|sum
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Copy from ds while checksumming, otherwise like csum_partial&n; *&n; * The macros SRC and DST specify the type of access for the instruction.&n; * thus we can call a custom exception handler for all access types.&n; *&n; * FIXME: could someone double-check whether I haven&squot;t mixed up some SRC and&n; *&t;  DST definitions? It&squot;s damn hard to trigger all cases.  I hope I got&n; *&t;  them all but there&squot;s no guarantee.&n; */
DECL|macro|SRC
mdefine_line|#define SRC(y...)&t;&t;&t;&bslash;&n;&quot;&t;9999: &quot;#y&quot;;&t;&t;&t;&bslash;n &bslash;&n;&t;.section __ex_table, &bslash;&quot;a&bslash;&quot;;&t;&bslash;n &bslash;&n;&t;.long 9999b, 6001f&t;&t;&bslash;n &bslash;&n;&t;.previous&bslash;n&quot;
DECL|macro|DST
mdefine_line|#define DST(y...)&t;&t;&t;&bslash;&n;&quot;&t;9999: &quot;#y&quot;;&t;&t;&t;&bslash;n &bslash;&n;&t;.section __ex_table, &bslash;&quot;a&bslash;&quot;;&t;&bslash;n &bslash;&n;&t;.long 9999b, 6002f&t;&t;&bslash;n &bslash;&n;&t;.previous&bslash;n&quot;
macro_line|#if CPU!=686
DECL|function|csum_partial_copy_generic
r_int
r_int
id|csum_partial_copy_generic
(paren
r_const
r_char
op_star
id|src
comma
r_char
op_star
id|dst
comma
r_int
id|len
comma
r_int
id|sum
comma
r_int
op_star
id|src_err_ptr
comma
r_int
op_star
id|dst_err_ptr
)paren
(brace
id|__u32
id|tmp_var
suffix:semicolon
id|__asm__
id|__volatile__
(paren
"&quot;"
id|testl
"$"
l_int|2
comma
op_mod
op_mod
id|edi
macro_line|# Check alignment. 
id|jz
l_float|2f
macro_line|# Jump if alignment is ok.
id|subl
"$"
l_int|2
comma
op_mod
op_mod
id|ecx
macro_line|# Alignment uses up two bytes.
id|jae
l_float|1f
macro_line|# Jump if we had at least two bytes.
id|addl
"$"
l_int|2
comma
op_mod
op_mod
id|ecx
macro_line|# ecx was &lt; 2.  Deal with it.
id|jmp
l_float|4f
l_string|&quot;SRC(&t;1:&t;movw (%%esi), %%bx&t;&t;&t;&t;)&quot;
id|addl
"$"
l_int|2
comma
op_mod
op_mod
id|esi
l_string|&quot;DST(&t;&t;movw %%bx, (%%edi)&t;&t;&t;&t;)&quot;
id|addl
"$"
l_int|2
comma
op_mod
op_mod
id|edi
id|addw
op_mod
op_mod
id|bx
comma
op_mod
op_mod
id|ax
id|adcl
"$"
l_int|0
comma
op_mod
op_mod
id|eax
l_int|2
suffix:colon
id|movl
op_mod
op_mod
id|ecx
comma
op_mod
l_int|8
id|shrl
"$"
l_int|5
comma
op_mod
op_mod
id|ecx
id|jz
l_float|2f
id|testl
op_mod
op_mod
id|esi
comma
op_mod
op_mod
id|esi
l_string|&quot;SRC(&t;1:&t;movl (%%esi), %%ebx&t;&t;&t;&t;)&quot;
l_string|&quot;SRC(&t;&t;movl 4(%%esi), %%edx&t;&t;&t;&t;)&quot;
id|adcl
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|eax
l_string|&quot;DST(&t;&t;movl %%ebx, (%%edi)&t;&t;&t;&t;)&quot;
id|adcl
op_mod
op_mod
id|edx
comma
op_mod
op_mod
id|eax
l_string|&quot;DST(&t;&t;movl %%edx, 4(%%edi)&t;&t;&t;&t;)&quot;
l_string|&quot;SRC(&t;&t;movl 8(%%esi), %%ebx&t;&t;&t;&t;)&quot;
l_string|&quot;SRC(&t;&t;movl 12(%%esi), %%edx&t;&t;&t;&t;)&quot;
id|adcl
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|eax
l_string|&quot;DST(&t;&t;movl %%ebx, 8(%%edi)&t;&t;&t;&t;)&quot;
id|adcl
op_mod
op_mod
id|edx
comma
op_mod
op_mod
id|eax
l_string|&quot;DST(&t;&t;movl %%edx, 12(%%edi)&t;&t;&t;&t;)&quot;
l_string|&quot;SRC(&t;&t;movl 16(%%esi), %%ebx &t;&t;&t;&t;)&quot;
l_string|&quot;SRC(&t;&t;movl 20(%%esi), %%edx&t;&t;&t;&t;)&quot;
id|adcl
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|eax
l_string|&quot;DST(&t;&t;movl %%ebx, 16(%%edi)&t;&t;&t;&t;)&quot;
id|adcl
op_mod
op_mod
id|edx
comma
op_mod
op_mod
id|eax
l_string|&quot;DST(&t;&t;movl %%edx, 20(%%edi)&t;&t;&t;&t;)&quot;
l_string|&quot;SRC(&t;&t;movl 24(%%esi), %%ebx&t;&t;&t;&t;)&quot;
l_string|&quot;SRC(&t;&t;movl 28(%%esi), %%edx&t;&t;&t;&t;)&quot;
id|adcl
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|eax
l_string|&quot;DST(&t;&t;movl %%ebx, 24(%%edi)&t;&t;&t;&t;)&quot;
id|adcl
op_mod
op_mod
id|edx
comma
op_mod
op_mod
id|eax
l_string|&quot;DST(&t;&t;movl %%edx, 28(%%edi)&t;&t;&t;&t;)&quot;
l_string|&quot;SRC(&t;&t;lea 32(%%esi), %%esi&t;&t;&t;&t;)&quot;
l_string|&quot;DST(&t;&t;lea 32(%%edi), %%edi&t;&t;&t;&t;)&quot;
id|dec
op_mod
op_mod
id|ecx
id|jne
l_int|1
id|b
id|adcl
"$"
l_int|0
comma
op_mod
op_mod
id|eax
l_int|2
suffix:colon
id|movl
op_mod
l_int|8
comma
op_mod
op_mod
id|edx
id|movl
op_mod
op_mod
id|edx
comma
op_mod
op_mod
id|ecx
id|andl
"$"
l_int|0x1c
comma
op_mod
op_mod
id|edx
id|je
l_float|4f
id|shrl
"$"
l_int|2
comma
op_mod
op_mod
id|edx
macro_line|# This clears CF
l_string|&quot;SRC(&t;3:&t;movl (%%esi), %%ebx&t;&t;&t;&t;)&quot;
id|adcl
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|eax
l_string|&quot;DST(&t;&t;movl %%ebx, (%%edi)&t;&t;&t;&t;)&quot;
l_string|&quot;SRC(&t;&t;lea 4(%%esi), %%esi&t;&t;&t;&t;)&quot;
l_string|&quot;DST(&t;&t;lea 4(%%edi), %%edi&t;&t;&t;&t;)&quot;
id|dec
op_mod
op_mod
id|edx
id|jne
l_int|3
id|b
id|adcl
"$"
l_int|0
comma
op_mod
op_mod
id|eax
l_int|4
suffix:colon
id|andl
"$"
l_int|3
comma
op_mod
op_mod
id|ecx
id|jz
l_float|7f
id|cmpl
"$"
l_int|2
comma
op_mod
op_mod
id|ecx
id|jb
l_float|5f
l_string|&quot;SRC(&t;&t;movw (%%esi), %%cx&t;&t;&t;&t;)&quot;
l_string|&quot;SRC(&t;&t;leal 2(%%esi), %%esi&t;&t;&t;&t;)&quot;
l_string|&quot;DST(&t;&t;movw %%cx, (%%edi)&t;&t;&t;&t;)&quot;
l_string|&quot;DST(&t;&t;leal 2(%%edi), %%edi&t;&t;&t;&t;)&quot;
id|je
l_float|6f
id|shll
"$"
l_int|16
comma
op_mod
op_mod
id|ecx
l_string|&quot;SRC(&t;5:&t;movb (%%esi), %%cl&t;&t;&t;&t;)&quot;
l_string|&quot;DST(&t;&t;movb %%cl, (%%edi)&t;&t;&t;&t;)&quot;
l_int|6
suffix:colon
id|addl
op_mod
op_mod
id|ecx
comma
op_mod
op_mod
id|eax
id|adcl
"$"
l_int|0
comma
op_mod
op_mod
id|eax
l_int|7
suffix:colon
l_int|5000
suffix:colon
macro_line|# Exception handler:
macro_line|################################################
macro_line|#
dot
id|section
dot
id|fixup
comma
"&bslash;&quot;"
id|ax
"&bslash;&quot;"
macro_line|#
macro_line|#
l_int|6000
suffix:colon
macro_line|#
macro_line|#
id|movl
op_mod
l_int|7
comma
(paren
op_mod
op_mod
id|ebx
)paren
macro_line|#
macro_line|#
macro_line|# FIXME: do zeroing of rest of the buffer here. #
macro_line|#
id|jmp
l_int|5000
id|b
macro_line|#
macro_line|#
l_int|6001
suffix:colon
macro_line|#
id|movl
op_mod
l_int|1
comma
op_mod
op_mod
id|ebx
macro_line|#
id|jmp
l_int|6000
id|b
macro_line|#
macro_line|#
l_int|6002
suffix:colon
macro_line|#
id|movl
op_mod
l_int|2
comma
op_mod
op_mod
id|ebx
macro_line|#
id|jmp
l_int|6000
id|b
macro_line|#
macro_line|#
dot
id|previous
macro_line|#
macro_line|#
macro_line|################################################
"&quot;"
suffix:colon
l_string|&quot;=a&quot;
(paren
id|sum
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
id|src_err_ptr
)paren
comma
l_string|&quot;m&quot;
(paren
id|dst_err_ptr
)paren
comma
l_string|&quot;0&quot;
(paren
id|sum
)paren
comma
l_string|&quot;c&quot;
(paren
id|len
)paren
comma
l_string|&quot;S&quot;
(paren
id|src
)paren
comma
l_string|&quot;D&quot;
(paren
id|dst
)paren
comma
l_string|&quot;i&quot;
(paren
op_minus
id|EFAULT
)paren
comma
l_string|&quot;m&quot;
(paren
id|tmp_var
)paren
suffix:colon
l_string|&quot;bx&quot;
comma
l_string|&quot;cx&quot;
comma
l_string|&quot;dx&quot;
comma
l_string|&quot;si&quot;
comma
l_string|&quot;di&quot;
)paren
suffix:semicolon
r_return
id|sum
suffix:semicolon
)brace
macro_line|#else /* CPU == 686 */
DECL|macro|ROUND1
mdefine_line|#define ROUND1(x) &bslash;&n;        SRC(movl x(%%esi), %%ebx         ) &bslash;&n;        &quot;addl %%ebx, %%eax&bslash;n&quot; &bslash;&n;        DST(movl %%ebx, x(%%edi)         )
DECL|macro|ROUND
mdefine_line|#define ROUND(x) &bslash;&n;        SRC(movl x(%%esi), %%ebx         ) &bslash;&n;        &quot;adcl %%ebx, %%eax&bslash;n&quot; &bslash;&n;        DST(movl %%ebx, x(%%edi)         )
DECL|function|csum_partial_copy_generic
r_int
r_int
id|csum_partial_copy_generic
(paren
r_const
r_char
op_star
id|src
comma
r_char
op_star
id|dst
comma
r_int
id|len
comma
r_int
id|sum
comma
r_int
op_star
id|src_err_ptr
comma
r_int
op_star
id|dst_err_ptr
)paren
(brace
id|__asm__
id|__volatile__
(paren
"&quot;"
id|movl
op_mod
op_mod
id|ecx
comma
op_mod
op_mod
id|edx
id|movl
op_mod
op_mod
id|ecx
comma
op_mod
op_mod
id|ebx
id|shrl
"$"
l_int|6
comma
op_mod
op_mod
id|ecx
id|andl
"$"
l_int|0x3c
comma
op_mod
op_mod
id|ebx
id|negl
op_mod
op_mod
id|ebx
id|subl
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|esi
id|subl
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|edi
id|lea
l_float|3f
(paren
op_mod
op_mod
id|ebx
comma
op_mod
op_mod
id|ebx
)paren
comma
op_mod
op_mod
id|ebx
id|testl
op_mod
op_mod
id|esi
comma
op_mod
op_mod
id|esi
id|jmp
op_star
op_mod
op_mod
id|ebx
l_int|1
suffix:colon
id|addl
"$"
l_int|64
comma
op_mod
op_mod
id|esi
id|addl
"$"
l_int|64
comma
op_mod
op_mod
id|edi
"&bslash;"
id|n
"&quot;"
id|ROUND1
c_func
(paren
op_minus
l_int|64
)paren
id|ROUND
c_func
(paren
op_minus
l_int|60
)paren
id|ROUND
c_func
(paren
op_minus
l_int|56
)paren
id|ROUND
c_func
(paren
op_minus
l_int|52
)paren
id|ROUND
(paren
op_minus
l_int|48
)paren
id|ROUND
c_func
(paren
op_minus
l_int|44
)paren
id|ROUND
c_func
(paren
op_minus
l_int|40
)paren
id|ROUND
c_func
(paren
op_minus
l_int|36
)paren
id|ROUND
(paren
op_minus
l_int|32
)paren
id|ROUND
c_func
(paren
op_minus
l_int|28
)paren
id|ROUND
c_func
(paren
op_minus
l_int|24
)paren
id|ROUND
c_func
(paren
op_minus
l_int|20
)paren
id|ROUND
(paren
op_minus
l_int|16
)paren
id|ROUND
c_func
(paren
op_minus
l_int|12
)paren
id|ROUND
c_func
(paren
op_minus
l_int|8
)paren
id|ROUND
c_func
(paren
op_minus
l_int|4
)paren
"&quot;"
l_int|3
suffix:colon
id|adcl
"$"
l_int|0
comma
op_mod
op_mod
id|eax
id|dec
op_mod
op_mod
id|ecx
id|jge
l_int|1
id|b
l_int|4
suffix:colon
id|andl
"$"
l_int|3
comma
op_mod
op_mod
id|edx
id|jz
l_float|7f
id|cmpl
"$"
l_int|2
comma
op_mod
op_mod
id|edx
id|jb
l_float|5f
l_string|&quot; SRC(movw (%%esi), %%dx         )&quot;
id|leal
l_int|2
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|esi
l_string|&quot; DST(movw %%dx, (%%edi)         )&quot;
id|leal
l_int|2
(paren
op_mod
op_mod
id|edi
)paren
comma
op_mod
op_mod
id|edi
id|je
l_float|6f
id|shll
"$"
l_int|16
comma
op_mod
op_mod
id|edx
l_int|5
suffix:colon
l_string|&quot; SRC(movb (%%esi), %%dl         )&quot;
l_string|&quot; DST(movb %%dl, (%%edi)         )&quot;
l_int|6
suffix:colon
id|addl
op_mod
op_mod
id|edx
comma
op_mod
op_mod
id|eax
id|adcl
"$"
l_int|0
comma
op_mod
op_mod
id|eax
l_int|7
suffix:colon
dot
id|section
dot
id|fixup
comma
"&bslash;&quot;"
id|ax
"&bslash;&quot;"
l_int|6000
suffix:colon
id|movl
op_mod
l_int|7
comma
(paren
op_mod
op_mod
id|ebx
)paren
macro_line|# FIXME: do zeroing of rest of the buffer here.
id|jmp
l_int|7
id|b
l_int|6001
suffix:colon
id|movl
op_mod
l_int|1
comma
op_mod
op_mod
id|ebx
id|jmp
l_int|6000
id|b
l_int|6002
suffix:colon
id|movl
op_mod
l_int|2
comma
op_mod
op_mod
id|ebx
id|jmp
l_int|6000
id|b
dot
id|previous
"&quot;"
suffix:colon
l_string|&quot;=a&quot;
(paren
id|sum
)paren
comma
l_string|&quot;=m&quot;
(paren
id|src_err_ptr
)paren
comma
l_string|&quot;=m&quot;
(paren
id|dst_err_ptr
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|sum
)paren
comma
l_string|&quot;c&quot;
(paren
id|len
)paren
comma
l_string|&quot;S&quot;
(paren
id|src
)paren
comma
l_string|&quot;D&quot;
(paren
id|dst
)paren
comma
l_string|&quot;i&quot;
(paren
op_minus
id|EFAULT
)paren
suffix:colon
l_string|&quot;bx&quot;
comma
l_string|&quot;cx&quot;
comma
l_string|&quot;dx&quot;
comma
l_string|&quot;si&quot;
comma
l_string|&quot;di&quot;
)paren
suffix:semicolon
r_return
id|sum
suffix:semicolon
)brace
DECL|macro|ROUND
macro_line|#undef ROUND
DECL|macro|ROUND1
macro_line|#undef ROUND1
macro_line|#endif
DECL|macro|SRC
macro_line|#undef SRC
DECL|macro|DST
macro_line|#undef DST
multiline_comment|/*&n; * FIXME: old compatibility stuff, will be removed soon.&n; */
DECL|function|csum_partial_copy
r_int
r_int
id|csum_partial_copy
c_func
(paren
r_const
r_char
op_star
id|src
comma
r_char
op_star
id|dst
comma
r_int
id|len
comma
r_int
id|sum
)paren
(brace
r_int
id|src_err
op_assign
l_int|0
comma
id|dst_err
op_assign
l_int|0
suffix:semicolon
id|sum
op_assign
id|csum_partial_copy_generic
(paren
id|src
comma
id|dst
comma
id|len
comma
id|sum
comma
op_amp
id|src_err
comma
op_amp
id|dst_err
)paren
suffix:semicolon
r_if
c_cond
(paren
id|src_err
op_logical_or
id|dst_err
)paren
id|printk
c_func
(paren
l_string|&quot;old csum_partial_copy_fromuser(), tell mingo to convert me.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|sum
suffix:semicolon
)brace
eof
