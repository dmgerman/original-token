multiline_comment|/*---------------------------------------------------------------------------+&n; |  poly.h                                                                   |&n; |                                                                           |&n; |  Header file for the FPU-emu poly*.c source files.                        |&n; |                                                                           |&n; | Copyright (C) 1994,1999                                                   |&n; |                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,      |&n; |                       Australia.  E-mail   billm@melbpc.org.au            |&n; |                                                                           |&n; | Declarations and definitions for functions operating on Xsig (12-byte     |&n; | extended-significand) quantities.                                         |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
macro_line|#ifndef _POLY_H
DECL|macro|_POLY_H
mdefine_line|#define _POLY_H
multiline_comment|/* This 12-byte structure is used to improve the accuracy of computation&n;   of transcendental functions.&n;   Intended to be used to get results better than 8-byte computation&n;   allows. 9-byte would probably be sufficient.&n;   */
r_typedef
r_struct
(brace
DECL|member|lsw
r_int
r_int
id|lsw
suffix:semicolon
DECL|member|midw
r_int
r_int
id|midw
suffix:semicolon
DECL|member|msw
r_int
r_int
id|msw
suffix:semicolon
DECL|typedef|Xsig
)brace
id|Xsig
suffix:semicolon
id|asmlinkage
r_void
id|mul64
c_func
(paren
r_int
r_int
r_int
r_const
op_star
id|a
comma
r_int
r_int
r_int
r_const
op_star
id|b
comma
r_int
r_int
r_int
op_star
id|result
)paren
suffix:semicolon
id|asmlinkage
r_void
id|polynomial_Xsig
c_func
(paren
id|Xsig
op_star
comma
r_const
r_int
r_int
r_int
op_star
id|x
comma
r_const
r_int
r_int
r_int
id|terms
(braket
)braket
comma
r_const
r_int
id|n
)paren
suffix:semicolon
id|asmlinkage
r_void
id|mul32_Xsig
c_func
(paren
id|Xsig
op_star
comma
r_const
r_int
r_int
id|mult
)paren
suffix:semicolon
id|asmlinkage
r_void
id|mul64_Xsig
c_func
(paren
id|Xsig
op_star
comma
r_const
r_int
r_int
r_int
op_star
id|mult
)paren
suffix:semicolon
id|asmlinkage
r_void
id|mul_Xsig_Xsig
c_func
(paren
id|Xsig
op_star
id|dest
comma
r_const
id|Xsig
op_star
id|mult
)paren
suffix:semicolon
id|asmlinkage
r_void
id|shr_Xsig
c_func
(paren
id|Xsig
op_star
comma
r_const
r_int
id|n
)paren
suffix:semicolon
id|asmlinkage
r_int
id|round_Xsig
c_func
(paren
id|Xsig
op_star
)paren
suffix:semicolon
id|asmlinkage
r_int
id|norm_Xsig
c_func
(paren
id|Xsig
op_star
)paren
suffix:semicolon
id|asmlinkage
r_void
id|div_Xsig
c_func
(paren
id|Xsig
op_star
id|x1
comma
r_const
id|Xsig
op_star
id|x2
comma
r_const
id|Xsig
op_star
id|dest
)paren
suffix:semicolon
multiline_comment|/* Macro to extract the most significant 32 bits from a long long */
DECL|macro|LL_MSW
mdefine_line|#define LL_MSW(x)     (((unsigned long *)&amp;x)[1])
multiline_comment|/* Macro to initialize an Xsig struct */
DECL|macro|MK_XSIG
mdefine_line|#define MK_XSIG(a,b,c)     { c, b, a }
multiline_comment|/* Macro to access the 8 ms bytes of an Xsig as a long long */
DECL|macro|XSIG_LL
mdefine_line|#define XSIG_LL(x)         (*(unsigned long long *)&amp;x.midw)
multiline_comment|/*&n;   Need to run gcc with optimizations on to get these to&n;   actually be in-line.&n;   */
multiline_comment|/* Multiply two fixed-point 32 bit numbers, producing a 32 bit result.&n;   The answer is the ms word of the product. */
multiline_comment|/* Some versions of gcc make it difficult to stop eax from being clobbered.&n;   Merely specifying that it is used doesn&squot;t work...&n; */
DECL|function|mul_32_32
r_extern
r_inline
r_int
r_int
id|mul_32_32
c_func
(paren
r_const
r_int
r_int
id|arg1
comma
r_const
r_int
r_int
id|arg2
)paren
(brace
r_int
id|retval
suffix:semicolon
id|asm
r_volatile
(paren
l_string|&quot;mull %2; movl %%edx,%%eax&quot;
"&bslash;"
suffix:colon
l_string|&quot;=a&quot;
(paren
id|retval
)paren
"&bslash;"
suffix:colon
l_string|&quot;0&quot;
(paren
id|arg1
)paren
comma
l_string|&quot;g&quot;
(paren
id|arg2
)paren
"&bslash;"
suffix:colon
l_string|&quot;dx&quot;
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Add the 12 byte Xsig x2 to Xsig dest, with no checks for overflow. */
DECL|function|add_Xsig_Xsig
r_extern
r_inline
r_void
id|add_Xsig_Xsig
c_func
(paren
id|Xsig
op_star
id|dest
comma
r_const
id|Xsig
op_star
id|x2
)paren
(brace
id|asm
r_volatile
(paren
"&quot;"
id|movl
op_mod
l_int|1
comma
op_mod
op_mod
id|edi
suffix:semicolon
id|movl
op_mod
l_int|2
comma
op_mod
op_mod
id|esi
suffix:semicolon
id|movl
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
suffix:semicolon
id|addl
op_mod
op_mod
id|eax
comma
(paren
op_mod
op_mod
id|edi
)paren
suffix:semicolon
id|movl
l_int|4
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
suffix:semicolon
id|adcl
op_mod
op_mod
id|eax
comma
l_int|4
(paren
op_mod
op_mod
id|edi
)paren
suffix:semicolon
id|movl
l_int|8
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
suffix:semicolon
id|adcl
op_mod
op_mod
id|eax
comma
l_int|8
(paren
op_mod
op_mod
id|edi
)paren
suffix:semicolon
"&quot;"
suffix:colon
l_string|&quot;=g&quot;
(paren
op_star
id|dest
)paren
suffix:colon
l_string|&quot;g&quot;
(paren
id|dest
)paren
comma
l_string|&quot;g&quot;
(paren
id|x2
)paren
suffix:colon
l_string|&quot;ax&quot;
comma
l_string|&quot;si&quot;
comma
l_string|&quot;di&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Add the 12 byte Xsig x2 to Xsig dest, adjust exp if overflow occurs. */
multiline_comment|/* Note: the constraints in the asm statement didn&squot;t always work properly&n;   with gcc 2.5.8.  Changing from using edi to using ecx got around the&n;   problem, but keep fingers crossed! */
DECL|function|add_two_Xsig
r_extern
r_inline
r_void
id|add_two_Xsig
c_func
(paren
id|Xsig
op_star
id|dest
comma
r_const
id|Xsig
op_star
id|x2
comma
r_int
r_int
op_star
id|exp
)paren
(brace
id|asm
r_volatile
(paren
"&quot;"
id|movl
op_mod
l_int|2
comma
op_mod
op_mod
id|ecx
suffix:semicolon
id|movl
op_mod
l_int|3
comma
op_mod
op_mod
id|esi
suffix:semicolon
id|movl
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
suffix:semicolon
id|addl
op_mod
op_mod
id|eax
comma
(paren
op_mod
op_mod
id|ecx
)paren
suffix:semicolon
id|movl
l_int|4
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
suffix:semicolon
id|adcl
op_mod
op_mod
id|eax
comma
l_int|4
(paren
op_mod
op_mod
id|ecx
)paren
suffix:semicolon
id|movl
l_int|8
(paren
op_mod
op_mod
id|esi
)paren
comma
op_mod
op_mod
id|eax
suffix:semicolon
id|adcl
op_mod
op_mod
id|eax
comma
l_int|8
(paren
op_mod
op_mod
id|ecx
)paren
suffix:semicolon
id|jnc
l_float|0f
suffix:semicolon
id|rcrl
l_int|8
(paren
op_mod
op_mod
id|ecx
)paren
suffix:semicolon
id|rcrl
l_int|4
(paren
op_mod
op_mod
id|ecx
)paren
suffix:semicolon
id|rcrl
(paren
op_mod
op_mod
id|ecx
)paren
id|movl
op_mod
l_int|4
comma
op_mod
op_mod
id|ecx
suffix:semicolon
id|incl
(paren
op_mod
op_mod
id|ecx
)paren
id|movl
"$"
l_int|1
comma
op_mod
op_mod
id|eax
suffix:semicolon
id|jmp
l_float|1f
suffix:semicolon
l_int|0
suffix:colon
id|xorl
op_mod
op_mod
id|eax
comma
op_mod
op_mod
id|eax
suffix:semicolon
l_int|1
suffix:colon
"&quot;"
suffix:colon
l_string|&quot;=g&quot;
(paren
op_star
id|exp
)paren
comma
l_string|&quot;=g&quot;
(paren
op_star
id|dest
)paren
suffix:colon
l_string|&quot;g&quot;
(paren
id|dest
)paren
comma
l_string|&quot;g&quot;
(paren
id|x2
)paren
comma
l_string|&quot;g&quot;
(paren
id|exp
)paren
suffix:colon
l_string|&quot;cx&quot;
comma
l_string|&quot;si&quot;
comma
l_string|&quot;ax&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Negate (subtract from 1.0) the 12 byte Xsig */
multiline_comment|/* This is faster in a loop on my 386 than using the &quot;neg&quot; instruction. */
DECL|function|negate_Xsig
r_extern
r_inline
r_void
id|negate_Xsig
c_func
(paren
id|Xsig
op_star
id|x
)paren
(brace
id|asm
r_volatile
(paren
l_string|&quot;movl %1,%%esi; &quot;
l_string|&quot;xorl %%ecx,%%ecx; &quot;
l_string|&quot;movl %%ecx,%%eax; subl (%%esi),%%eax; movl %%eax,(%%esi); &quot;
l_string|&quot;movl %%ecx,%%eax; sbbl 4(%%esi),%%eax; movl %%eax,4(%%esi); &quot;
l_string|&quot;movl %%ecx,%%eax; sbbl 8(%%esi),%%eax; movl %%eax,8(%%esi); &quot;
suffix:colon
l_string|&quot;=g&quot;
(paren
op_star
id|x
)paren
suffix:colon
l_string|&quot;g&quot;
(paren
id|x
)paren
suffix:colon
l_string|&quot;si&quot;
comma
l_string|&quot;ax&quot;
comma
l_string|&quot;cx&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif _POLY_H
eof
