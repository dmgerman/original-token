multiline_comment|/*---------------------------------------------------------------------------+&n; |  get_address.c                                                            |&n; |                                                                           |&n; | Get the effective address from an FPU instruction.                        |&n; |                                                                           |&n; | Copyright (C) 1992,1993,1994,1997                                         |&n; |                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,      |&n; |                       Australia.  E-mail   billm@suburbia.net             |&n; |                                                                           |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
multiline_comment|/*---------------------------------------------------------------------------+&n; | Note:                                                                     |&n; |    The file contains code which accesses user memory.                     |&n; |    Emulator static data may change when user memory is accessed, due to   |&n; |    other processes using the emulator while swapping is in progress.      |&n; +---------------------------------------------------------------------------*/
macro_line|#include &lt;linux/stddef.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/desc.h&gt;
macro_line|#include &quot;fpu_system.h&quot;
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;fpu_emu.h&quot;
DECL|macro|FPU_WRITE_BIT
mdefine_line|#define FPU_WRITE_BIT 0x10
DECL|variable|reg_offset
r_static
r_int
id|reg_offset
(braket
)braket
op_assign
(brace
m_offsetof
(paren
r_struct
id|info
comma
id|___eax
)paren
comma
m_offsetof
(paren
r_struct
id|info
comma
id|___ecx
)paren
comma
m_offsetof
(paren
r_struct
id|info
comma
id|___edx
)paren
comma
m_offsetof
(paren
r_struct
id|info
comma
id|___ebx
)paren
comma
m_offsetof
(paren
r_struct
id|info
comma
id|___esp
)paren
comma
m_offsetof
(paren
r_struct
id|info
comma
id|___ebp
)paren
comma
m_offsetof
(paren
r_struct
id|info
comma
id|___esi
)paren
comma
m_offsetof
(paren
r_struct
id|info
comma
id|___edi
)paren
)brace
suffix:semicolon
DECL|macro|REG_
mdefine_line|#define REG_(x) (*(long *)(reg_offset[(x)]+(u_char *) FPU_info))
DECL|variable|reg_offset_vm86
r_static
r_int
id|reg_offset_vm86
(braket
)braket
op_assign
(brace
m_offsetof
(paren
r_struct
id|info
comma
id|___cs
)paren
comma
m_offsetof
(paren
r_struct
id|info
comma
id|___vm86_ds
)paren
comma
m_offsetof
(paren
r_struct
id|info
comma
id|___vm86_es
)paren
comma
m_offsetof
(paren
r_struct
id|info
comma
id|___vm86_fs
)paren
comma
m_offsetof
(paren
r_struct
id|info
comma
id|___vm86_gs
)paren
comma
m_offsetof
(paren
r_struct
id|info
comma
id|___ss
)paren
comma
m_offsetof
(paren
r_struct
id|info
comma
id|___vm86_ds
)paren
)brace
suffix:semicolon
DECL|macro|VM86_REG_
mdefine_line|#define VM86_REG_(x) (*(unsigned short *) &bslash;&n;&t;&t;      (reg_offset_vm86[((unsigned)x)]+(u_char *) FPU_info))
multiline_comment|/* These are dummy, fs and gs are not saved on the stack. */
DECL|macro|___FS
mdefine_line|#define ___FS ___ds
DECL|macro|___GS
mdefine_line|#define ___GS ___ds
DECL|variable|reg_offset_pm
r_static
r_int
id|reg_offset_pm
(braket
)braket
op_assign
(brace
m_offsetof
(paren
r_struct
id|info
comma
id|___cs
)paren
comma
m_offsetof
(paren
r_struct
id|info
comma
id|___ds
)paren
comma
m_offsetof
(paren
r_struct
id|info
comma
id|___es
)paren
comma
m_offsetof
(paren
r_struct
id|info
comma
id|___FS
)paren
comma
m_offsetof
(paren
r_struct
id|info
comma
id|___GS
)paren
comma
m_offsetof
(paren
r_struct
id|info
comma
id|___ss
)paren
comma
m_offsetof
(paren
r_struct
id|info
comma
id|___ds
)paren
)brace
suffix:semicolon
DECL|macro|PM_REG_
mdefine_line|#define PM_REG_(x) (*(unsigned short *) &bslash;&n;&t;&t;      (reg_offset_pm[((unsigned)x)]+(u_char *) FPU_info))
multiline_comment|/* Decode the SIB byte. This function assumes mod != 0 */
DECL|function|sib
r_static
r_int
id|sib
c_func
(paren
r_int
id|mod
comma
r_int
r_int
op_star
id|fpu_eip
)paren
(brace
id|u_char
id|ss
comma
id|index
comma
id|base
suffix:semicolon
r_int
id|offset
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_code_verify_area
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|base
comma
(paren
id|u_char
op_star
)paren
(paren
op_star
id|fpu_eip
)paren
)paren
suffix:semicolon
multiline_comment|/* The SIB byte */
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
(paren
op_star
id|fpu_eip
)paren
op_increment
suffix:semicolon
id|ss
op_assign
id|base
op_rshift
l_int|6
suffix:semicolon
id|index
op_assign
(paren
id|base
op_rshift
l_int|3
)paren
op_amp
l_int|7
suffix:semicolon
id|base
op_and_assign
l_int|7
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mod
op_eq
l_int|0
)paren
op_logical_and
(paren
id|base
op_eq
l_int|5
)paren
)paren
id|offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No base register */
r_else
id|offset
op_assign
id|REG_
c_func
(paren
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
l_int|4
)paren
(brace
multiline_comment|/* No index register */
multiline_comment|/* A non-zero ss is illegal */
r_if
c_cond
(paren
id|ss
)paren
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
)brace
r_else
(brace
id|offset
op_add_assign
(paren
id|REG_
c_func
(paren
id|index
)paren
)paren
op_lshift
id|ss
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mod
op_eq
l_int|1
)paren
(brace
multiline_comment|/* 8 bit signed displacement */
r_int
id|displacement
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_code_verify_area
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|displacement
comma
(paren
r_int
r_char
op_star
)paren
(paren
op_star
id|fpu_eip
)paren
)paren
suffix:semicolon
id|offset
op_add_assign
id|displacement
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
(paren
op_star
id|fpu_eip
)paren
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|mod
op_eq
l_int|2
op_logical_or
id|base
op_eq
l_int|5
)paren
multiline_comment|/* The second condition also has mod==0 */
(brace
multiline_comment|/* 32 bit displacement */
r_int
id|displacement
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_code_verify_area
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|displacement
comma
(paren
r_int
op_star
)paren
(paren
op_star
id|fpu_eip
)paren
)paren
suffix:semicolon
id|offset
op_add_assign
id|displacement
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
(paren
op_star
id|fpu_eip
)paren
op_add_assign
l_int|4
suffix:semicolon
)brace
r_return
id|offset
suffix:semicolon
)brace
DECL|function|vm86_segment
r_static
r_int
r_int
id|vm86_segment
c_func
(paren
id|u_char
id|segment
comma
r_struct
id|address
op_star
id|addr
)paren
(brace
id|segment
op_decrement
suffix:semicolon
macro_line|#ifdef PARANOID
r_if
c_cond
(paren
id|segment
OG
id|PREFIX_SS_
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x130
)paren
suffix:semicolon
id|math_abort
c_func
(paren
id|FPU_info
comma
id|SIGSEGV
)paren
suffix:semicolon
)brace
macro_line|#endif PARANOID
id|addr-&gt;selector
op_assign
id|VM86_REG_
c_func
(paren
id|segment
)paren
suffix:semicolon
r_return
(paren
r_int
r_int
)paren
id|VM86_REG_
c_func
(paren
id|segment
)paren
op_lshift
l_int|4
suffix:semicolon
)brace
multiline_comment|/* This should work for 16 and 32 bit protected mode. */
DECL|function|pm_address
r_static
r_int
id|pm_address
c_func
(paren
id|u_char
id|FPU_modrm
comma
id|u_char
id|segment
comma
r_struct
id|address
op_star
id|addr
comma
r_int
id|offset
)paren
(brace
r_struct
id|desc_struct
id|descriptor
suffix:semicolon
r_int
r_int
id|base_address
comma
id|limit
comma
id|address
comma
id|seg_top
suffix:semicolon
r_int
r_int
id|selector
suffix:semicolon
id|segment
op_decrement
suffix:semicolon
macro_line|#ifdef PARANOID
multiline_comment|/* segment is unsigned, so this also detects if segment was 0: */
r_if
c_cond
(paren
id|segment
OG
id|PREFIX_SS_
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x132
)paren
suffix:semicolon
id|math_abort
c_func
(paren
id|FPU_info
comma
id|SIGSEGV
)paren
suffix:semicolon
)brace
macro_line|#endif PARANOID
r_switch
c_cond
(paren
id|segment
)paren
(brace
multiline_comment|/* fs and gs aren&squot;t used by the kernel, so they still have their&n;&t; user-space values. */
r_case
id|PREFIX_FS_
op_minus
l_int|1
suffix:colon
multiline_comment|/* The cast is needed here to get gcc 2.8.0 to use a 16 bit register&n;&t; in the assembler statement. */
id|__asm__
c_func
(paren
l_string|&quot;mov %%fs,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|selector
)paren
)paren
suffix:semicolon
id|addr-&gt;selector
op_assign
id|selector
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PREFIX_GS_
op_minus
l_int|1
suffix:colon
multiline_comment|/* The cast is needed here to get gcc 2.8.0 to use a 16 bit register&n;&t; in the assembler statement. */
id|__asm__
c_func
(paren
l_string|&quot;mov %%gs,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|selector
)paren
)paren
suffix:semicolon
id|addr-&gt;selector
op_assign
id|selector
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|addr-&gt;selector
op_assign
id|PM_REG_
c_func
(paren
id|segment
)paren
suffix:semicolon
)brace
id|descriptor
op_assign
id|LDT_DESCRIPTOR
c_func
(paren
id|PM_REG_
c_func
(paren
id|segment
)paren
)paren
suffix:semicolon
id|base_address
op_assign
id|SEG_BASE_ADDR
c_func
(paren
id|descriptor
)paren
suffix:semicolon
id|address
op_assign
id|base_address
op_plus
id|offset
suffix:semicolon
id|limit
op_assign
id|base_address
op_plus
(paren
id|SEG_LIMIT
c_func
(paren
id|descriptor
)paren
op_plus
l_int|1
)paren
op_star
id|SEG_GRANULARITY
c_func
(paren
id|descriptor
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|limit
OL
id|base_address
)paren
id|limit
op_assign
l_int|0xffffffff
suffix:semicolon
r_if
c_cond
(paren
id|SEG_EXPAND_DOWN
c_func
(paren
id|descriptor
)paren
)paren
(brace
r_if
c_cond
(paren
id|SEG_G_BIT
c_func
(paren
id|descriptor
)paren
)paren
id|seg_top
op_assign
l_int|0xffffffff
suffix:semicolon
r_else
(brace
id|seg_top
op_assign
id|base_address
op_plus
(paren
l_int|1
op_lshift
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
id|seg_top
OL
id|base_address
)paren
id|seg_top
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
id|access_limit
op_assign
(paren
id|address
op_le
id|limit
)paren
op_logical_or
(paren
id|address
op_ge
id|seg_top
)paren
ques
c_cond
l_int|0
suffix:colon
(paren
(paren
id|seg_top
op_minus
id|address
)paren
op_ge
l_int|255
ques
c_cond
l_int|255
suffix:colon
id|seg_top
op_minus
id|address
)paren
suffix:semicolon
)brace
r_else
(brace
id|access_limit
op_assign
(paren
id|address
OG
id|limit
)paren
op_logical_or
(paren
id|address
OL
id|base_address
)paren
ques
c_cond
l_int|0
suffix:colon
(paren
(paren
id|limit
op_minus
id|address
)paren
op_ge
l_int|254
ques
c_cond
l_int|255
suffix:colon
id|limit
op_minus
id|address
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SEG_EXECUTE_ONLY
c_func
(paren
id|descriptor
)paren
op_logical_or
(paren
op_logical_neg
id|SEG_WRITE_PERM
c_func
(paren
id|descriptor
)paren
op_logical_and
(paren
id|FPU_modrm
op_amp
id|FPU_WRITE_BIT
)paren
)paren
)paren
(brace
id|access_limit
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|address
suffix:semicolon
)brace
multiline_comment|/*&n;       MOD R/M byte:  MOD == 3 has a special use for the FPU&n;                      SIB byte used iff R/M = 100b&n;&n;       7   6   5   4   3   2   1   0&n;       .....   .........   .........&n;        MOD    OPCODE(2)     R/M&n;&n;&n;       SIB byte&n;&n;       7   6   5   4   3   2   1   0&n;       .....   .........   .........&n;        SS      INDEX        BASE&n;&n;*/
DECL|function|FPU_get_address
r_void
op_star
id|FPU_get_address
c_func
(paren
id|u_char
id|FPU_modrm
comma
r_int
r_int
op_star
id|fpu_eip
comma
r_struct
id|address
op_star
id|addr
comma
id|fpu_addr_modes
id|addr_modes
)paren
(brace
id|u_char
id|mod
suffix:semicolon
r_int
id|rm
op_assign
id|FPU_modrm
op_amp
l_int|7
suffix:semicolon
r_int
op_star
id|cpu_reg_ptr
suffix:semicolon
r_int
id|address
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialized just to stop compiler warnings. */
multiline_comment|/* Memory accessed via the cs selector is write protected&n;     in `non-segmented&squot; 32 bit protected mode. */
r_if
c_cond
(paren
op_logical_neg
id|addr_modes.default_mode
op_logical_and
(paren
id|FPU_modrm
op_amp
id|FPU_WRITE_BIT
)paren
op_logical_and
(paren
id|addr_modes.override.segment
op_eq
id|PREFIX_CS_
)paren
)paren
(brace
id|math_abort
c_func
(paren
id|FPU_info
comma
id|SIGSEGV
)paren
suffix:semicolon
)brace
id|addr-&gt;selector
op_assign
id|FPU_DS
suffix:semicolon
multiline_comment|/* Default, for 32 bit non-segmented mode. */
id|mod
op_assign
(paren
id|FPU_modrm
op_rshift
l_int|6
)paren
op_amp
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|rm
op_eq
l_int|4
op_logical_and
id|mod
op_ne
l_int|3
)paren
(brace
id|address
op_assign
id|sib
c_func
(paren
id|mod
comma
id|fpu_eip
)paren
suffix:semicolon
)brace
r_else
(brace
id|cpu_reg_ptr
op_assign
op_amp
id|REG_
c_func
(paren
id|rm
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mod
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|rm
op_eq
l_int|5
)paren
(brace
multiline_comment|/* Special case: disp32 */
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_code_verify_area
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|address
comma
(paren
r_int
r_int
op_star
)paren
(paren
op_star
id|fpu_eip
)paren
)paren
suffix:semicolon
(paren
op_star
id|fpu_eip
)paren
op_add_assign
l_int|4
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
id|addr-&gt;offset
op_assign
id|address
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|address
suffix:semicolon
)brace
r_else
(brace
id|address
op_assign
op_star
id|cpu_reg_ptr
suffix:semicolon
multiline_comment|/* Just return the contents&n;&t;&t;&t;&t;&t;  of the cpu register */
id|addr-&gt;offset
op_assign
id|address
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|address
suffix:semicolon
)brace
r_case
l_int|1
suffix:colon
multiline_comment|/* 8 bit signed displacement */
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_code_verify_area
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|address
comma
(paren
r_int
r_char
op_star
)paren
(paren
op_star
id|fpu_eip
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
(paren
op_star
id|fpu_eip
)paren
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* 32 bit displacement */
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_code_verify_area
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|address
comma
(paren
r_int
op_star
)paren
(paren
op_star
id|fpu_eip
)paren
)paren
suffix:semicolon
(paren
op_star
id|fpu_eip
)paren
op_add_assign
l_int|4
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* Not legal for the FPU */
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
)brace
id|address
op_add_assign
op_star
id|cpu_reg_ptr
suffix:semicolon
)brace
id|addr-&gt;offset
op_assign
id|address
suffix:semicolon
r_switch
c_cond
(paren
id|addr_modes.default_mode
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
id|VM86
suffix:colon
id|address
op_add_assign
id|vm86_segment
c_func
(paren
id|addr_modes.override.segment
comma
id|addr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PM16
suffix:colon
r_case
id|SEG32
suffix:colon
id|address
op_assign
id|pm_address
c_func
(paren
id|FPU_modrm
comma
id|addr_modes.override.segment
comma
id|addr
comma
id|address
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x133
)paren
suffix:semicolon
)brace
r_return
(paren
r_void
op_star
)paren
id|address
suffix:semicolon
)brace
DECL|function|FPU_get_address_16
r_void
op_star
id|FPU_get_address_16
c_func
(paren
id|u_char
id|FPU_modrm
comma
r_int
r_int
op_star
id|fpu_eip
comma
r_struct
id|address
op_star
id|addr
comma
id|fpu_addr_modes
id|addr_modes
)paren
(brace
id|u_char
id|mod
suffix:semicolon
r_int
id|rm
op_assign
id|FPU_modrm
op_amp
l_int|7
suffix:semicolon
r_int
id|address
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Default used for mod == 0 */
multiline_comment|/* Memory accessed via the cs selector is write protected&n;     in `non-segmented&squot; 32 bit protected mode. */
r_if
c_cond
(paren
op_logical_neg
id|addr_modes.default_mode
op_logical_and
(paren
id|FPU_modrm
op_amp
id|FPU_WRITE_BIT
)paren
op_logical_and
(paren
id|addr_modes.override.segment
op_eq
id|PREFIX_CS_
)paren
)paren
(brace
id|math_abort
c_func
(paren
id|FPU_info
comma
id|SIGSEGV
)paren
suffix:semicolon
)brace
id|addr-&gt;selector
op_assign
id|FPU_DS
suffix:semicolon
multiline_comment|/* Default, for 32 bit non-segmented mode. */
id|mod
op_assign
(paren
id|FPU_modrm
op_rshift
l_int|6
)paren
op_amp
l_int|3
suffix:semicolon
r_switch
c_cond
(paren
id|mod
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|rm
op_eq
l_int|6
)paren
(brace
multiline_comment|/* Special case: disp16 */
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_code_verify_area
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|address
comma
(paren
r_int
r_int
op_star
)paren
(paren
op_star
id|fpu_eip
)paren
)paren
suffix:semicolon
(paren
op_star
id|fpu_eip
)paren
op_add_assign
l_int|2
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_goto
id|add_segment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* 8 bit signed displacement */
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_code_verify_area
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|address
comma
(paren
r_int
r_char
op_star
)paren
(paren
op_star
id|fpu_eip
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
(paren
op_star
id|fpu_eip
)paren
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* 16 bit displacement */
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_code_verify_area
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|address
comma
(paren
r_int
r_int
op_star
)paren
(paren
op_star
id|fpu_eip
)paren
)paren
suffix:semicolon
(paren
op_star
id|fpu_eip
)paren
op_add_assign
l_int|2
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* Not legal for the FPU */
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|rm
)paren
(brace
r_case
l_int|0
suffix:colon
id|address
op_add_assign
id|FPU_info-&gt;___ebx
op_plus
id|FPU_info-&gt;___esi
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|address
op_add_assign
id|FPU_info-&gt;___ebx
op_plus
id|FPU_info-&gt;___edi
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|address
op_add_assign
id|FPU_info-&gt;___ebp
op_plus
id|FPU_info-&gt;___esi
suffix:semicolon
r_if
c_cond
(paren
id|addr_modes.override.segment
op_eq
id|PREFIX_DEFAULT
)paren
id|addr_modes.override.segment
op_assign
id|PREFIX_SS_
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|address
op_add_assign
id|FPU_info-&gt;___ebp
op_plus
id|FPU_info-&gt;___edi
suffix:semicolon
r_if
c_cond
(paren
id|addr_modes.override.segment
op_eq
id|PREFIX_DEFAULT
)paren
id|addr_modes.override.segment
op_assign
id|PREFIX_SS_
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|address
op_add_assign
id|FPU_info-&gt;___esi
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|address
op_add_assign
id|FPU_info-&gt;___edi
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|address
op_add_assign
id|FPU_info-&gt;___ebp
suffix:semicolon
r_if
c_cond
(paren
id|addr_modes.override.segment
op_eq
id|PREFIX_DEFAULT
)paren
id|addr_modes.override.segment
op_assign
id|PREFIX_SS_
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|address
op_add_assign
id|FPU_info-&gt;___ebx
suffix:semicolon
r_break
suffix:semicolon
)brace
id|add_segment
suffix:colon
id|address
op_and_assign
l_int|0xffff
suffix:semicolon
id|addr-&gt;offset
op_assign
id|address
suffix:semicolon
r_switch
c_cond
(paren
id|addr_modes.default_mode
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
id|VM86
suffix:colon
id|address
op_add_assign
id|vm86_segment
c_func
(paren
id|addr_modes.override.segment
comma
id|addr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PM16
suffix:colon
r_case
id|SEG32
suffix:colon
id|address
op_assign
id|pm_address
c_func
(paren
id|FPU_modrm
comma
id|addr_modes.override.segment
comma
id|addr
comma
id|address
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x131
)paren
suffix:semicolon
)brace
r_return
(paren
r_void
op_star
)paren
id|address
suffix:semicolon
)brace
eof
