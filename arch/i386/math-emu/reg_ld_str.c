multiline_comment|/*---------------------------------------------------------------------------+&n; |  reg_ld_str.c                                                             |&n; |                                                                           |&n; | All of the functions which transfer data between user memory and FPU_REGs.|&n; |                                                                           |&n; | Copyright (C) 1992,1993,1994,1996,1997                                    |&n; |                  W. Metzenthen, 22 Parker St, Ormond, Vic 3163, Australia |&n; |                  E-mail   billm@suburbia.net                              |&n; |                                                                           |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
multiline_comment|/*---------------------------------------------------------------------------+&n; | Note:                                                                     |&n; |    The file contains code which accesses user memory.                     |&n; |    Emulator static data may change when user memory is accessed, due to   |&n; |    other processes using the emulator while swapping is in progress.      |&n; +---------------------------------------------------------------------------*/
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;fpu_system.h&quot;
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;reg_constant.h&quot;
macro_line|#include &quot;control_w.h&quot;
macro_line|#include &quot;status_w.h&quot;
DECL|macro|DOUBLE_Emax
mdefine_line|#define DOUBLE_Emax 1023         /* largest valid exponent */
DECL|macro|DOUBLE_Ebias
mdefine_line|#define DOUBLE_Ebias 1023
DECL|macro|DOUBLE_Emin
mdefine_line|#define DOUBLE_Emin (-1022)      /* smallest valid exponent */
DECL|macro|SINGLE_Emax
mdefine_line|#define SINGLE_Emax 127          /* largest valid exponent */
DECL|macro|SINGLE_Ebias
mdefine_line|#define SINGLE_Ebias 127
DECL|macro|SINGLE_Emin
mdefine_line|#define SINGLE_Emin (-126)       /* smallest valid exponent */
DECL|function|normalize_no_excep
r_static
id|u_char
id|normalize_no_excep
c_func
(paren
id|FPU_REG
op_star
id|r
comma
r_int
id|exp
comma
r_int
id|sign
)paren
(brace
id|u_char
id|tag
suffix:semicolon
id|setexponent16
c_func
(paren
id|r
comma
id|exp
)paren
suffix:semicolon
id|tag
op_assign
id|FPU_normalize_nuo
c_func
(paren
id|r
)paren
suffix:semicolon
id|stdexp
c_func
(paren
id|r
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sign
)paren
id|setnegative
c_func
(paren
id|r
)paren
suffix:semicolon
r_return
id|tag
suffix:semicolon
)brace
DECL|function|FPU_tagof
r_int
id|FPU_tagof
c_func
(paren
id|FPU_REG
op_star
id|ptr
)paren
(brace
r_int
id|exp
suffix:semicolon
id|exp
op_assign
id|exponent16
c_func
(paren
id|ptr
)paren
op_amp
l_int|0x7fff
suffix:semicolon
r_if
c_cond
(paren
id|exp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ptr-&gt;sigh
op_or
id|ptr-&gt;sigl
)paren
)paren
(brace
r_return
id|TAG_Zero
suffix:semicolon
)brace
multiline_comment|/* The number is a de-normal or pseudodenormal. */
r_return
id|TAG_Special
suffix:semicolon
)brace
r_if
c_cond
(paren
id|exp
op_eq
l_int|0x7fff
)paren
(brace
multiline_comment|/* Is an Infinity, a NaN, or an unsupported data type. */
r_return
id|TAG_Special
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ptr-&gt;sigh
op_amp
l_int|0x80000000
)paren
)paren
(brace
multiline_comment|/* Unsupported data type. */
multiline_comment|/* Valid numbers have the ms bit set to 1. */
multiline_comment|/* Unnormal. */
r_return
id|TAG_Special
suffix:semicolon
)brace
r_return
id|TAG_Valid
suffix:semicolon
)brace
multiline_comment|/* Get a long double from user memory */
DECL|function|FPU_load_extended
r_int
id|FPU_load_extended
c_func
(paren
r_int
r_float
op_star
id|s
comma
r_int
id|stnr
)paren
(brace
id|FPU_REG
op_star
id|sti_ptr
op_assign
op_amp
id|st
c_func
(paren
id|stnr
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_READ
comma
id|s
comma
l_int|10
)paren
suffix:semicolon
id|__copy_from_user
c_func
(paren
id|sti_ptr
comma
id|s
comma
l_int|10
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
id|FPU_tagof
c_func
(paren
id|sti_ptr
)paren
suffix:semicolon
)brace
multiline_comment|/* Get a double from user memory */
DECL|function|FPU_load_double
r_int
id|FPU_load_double
c_func
(paren
r_float
op_star
id|dfloat
comma
id|FPU_REG
op_star
id|loaded_data
)paren
(brace
r_int
id|exp
comma
id|tag
comma
id|negative
suffix:semicolon
r_int
id|m64
comma
id|l64
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_READ
comma
id|dfloat
comma
l_int|8
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|m64
comma
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|dfloat
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|l64
comma
(paren
r_int
r_int
op_star
)paren
id|dfloat
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
id|negative
op_assign
(paren
id|m64
op_amp
l_int|0x80000000
)paren
ques
c_cond
id|SIGN_Negative
suffix:colon
id|SIGN_Positive
suffix:semicolon
id|exp
op_assign
(paren
(paren
id|m64
op_amp
l_int|0x7ff00000
)paren
op_rshift
l_int|20
)paren
op_minus
id|DOUBLE_Ebias
op_plus
id|EXTENDED_Ebias
suffix:semicolon
id|m64
op_and_assign
l_int|0xfffff
suffix:semicolon
r_if
c_cond
(paren
id|exp
OG
id|DOUBLE_Emax
op_plus
id|EXTENDED_Ebias
)paren
(brace
multiline_comment|/* Infinity or NaN */
r_if
c_cond
(paren
(paren
id|m64
op_eq
l_int|0
)paren
op_logical_and
(paren
id|l64
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* +- infinity */
id|loaded_data-&gt;sigh
op_assign
l_int|0x80000000
suffix:semicolon
id|loaded_data-&gt;sigl
op_assign
l_int|0x00000000
suffix:semicolon
id|exp
op_assign
id|EXP_Infinity
op_plus
id|EXTENDED_Ebias
suffix:semicolon
id|tag
op_assign
id|TAG_Special
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Must be a signaling or quiet NaN */
id|exp
op_assign
id|EXP_NaN
op_plus
id|EXTENDED_Ebias
suffix:semicolon
id|loaded_data-&gt;sigh
op_assign
(paren
id|m64
op_lshift
l_int|11
)paren
op_or
l_int|0x80000000
suffix:semicolon
id|loaded_data-&gt;sigh
op_or_assign
id|l64
op_rshift
l_int|21
suffix:semicolon
id|loaded_data-&gt;sigl
op_assign
id|l64
op_lshift
l_int|11
suffix:semicolon
id|tag
op_assign
id|TAG_Special
suffix:semicolon
multiline_comment|/* The calling function must look for NaNs */
)brace
)brace
r_else
r_if
c_cond
(paren
id|exp
OL
id|DOUBLE_Emin
op_plus
id|EXTENDED_Ebias
)paren
(brace
multiline_comment|/* Zero or de-normal */
r_if
c_cond
(paren
(paren
id|m64
op_eq
l_int|0
)paren
op_logical_and
(paren
id|l64
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* Zero */
id|reg_copy
c_func
(paren
op_amp
id|CONST_Z
comma
id|loaded_data
)paren
suffix:semicolon
id|exp
op_assign
l_int|0
suffix:semicolon
id|tag
op_assign
id|TAG_Zero
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* De-normal */
id|loaded_data-&gt;sigh
op_assign
id|m64
op_lshift
l_int|11
suffix:semicolon
id|loaded_data-&gt;sigh
op_or_assign
id|l64
op_rshift
l_int|21
suffix:semicolon
id|loaded_data-&gt;sigl
op_assign
id|l64
op_lshift
l_int|11
suffix:semicolon
r_return
id|normalize_no_excep
c_func
(paren
id|loaded_data
comma
id|DOUBLE_Emin
comma
id|negative
)paren
op_or
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
ques
c_cond
id|FPU_Exception
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|loaded_data-&gt;sigh
op_assign
(paren
id|m64
op_lshift
l_int|11
)paren
op_or
l_int|0x80000000
suffix:semicolon
id|loaded_data-&gt;sigh
op_or_assign
id|l64
op_rshift
l_int|21
suffix:semicolon
id|loaded_data-&gt;sigl
op_assign
id|l64
op_lshift
l_int|11
suffix:semicolon
id|tag
op_assign
id|TAG_Valid
suffix:semicolon
)brace
id|setexponent16
c_func
(paren
id|loaded_data
comma
id|exp
op_or
id|negative
)paren
suffix:semicolon
r_return
id|tag
suffix:semicolon
)brace
multiline_comment|/* Get a float from user memory */
DECL|function|FPU_load_single
r_int
id|FPU_load_single
c_func
(paren
r_float
op_star
id|single
comma
id|FPU_REG
op_star
id|loaded_data
)paren
(brace
r_int
id|m32
suffix:semicolon
r_int
id|exp
comma
id|tag
comma
id|negative
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_READ
comma
id|single
comma
l_int|4
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|m32
comma
(paren
r_int
r_int
op_star
)paren
id|single
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
id|negative
op_assign
(paren
id|m32
op_amp
l_int|0x80000000
)paren
ques
c_cond
id|SIGN_Negative
suffix:colon
id|SIGN_Positive
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|m32
op_amp
l_int|0x7fffffff
)paren
)paren
(brace
multiline_comment|/* Zero */
id|reg_copy
c_func
(paren
op_amp
id|CONST_Z
comma
id|loaded_data
)paren
suffix:semicolon
id|addexponent
c_func
(paren
id|loaded_data
comma
id|negative
)paren
suffix:semicolon
r_return
id|TAG_Zero
suffix:semicolon
)brace
id|exp
op_assign
(paren
(paren
id|m32
op_amp
l_int|0x7f800000
)paren
op_rshift
l_int|23
)paren
op_minus
id|SINGLE_Ebias
op_plus
id|EXTENDED_Ebias
suffix:semicolon
id|m32
op_assign
(paren
id|m32
op_amp
l_int|0x7fffff
)paren
op_lshift
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|exp
OL
id|SINGLE_Emin
op_plus
id|EXTENDED_Ebias
)paren
(brace
multiline_comment|/* De-normals */
id|loaded_data-&gt;sigh
op_assign
id|m32
suffix:semicolon
id|loaded_data-&gt;sigl
op_assign
l_int|0
suffix:semicolon
r_return
id|normalize_no_excep
c_func
(paren
id|loaded_data
comma
id|SINGLE_Emin
comma
id|negative
)paren
op_or
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
ques
c_cond
id|FPU_Exception
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|exp
OG
id|SINGLE_Emax
op_plus
id|EXTENDED_Ebias
)paren
(brace
multiline_comment|/* Infinity or NaN */
r_if
c_cond
(paren
id|m32
op_eq
l_int|0
)paren
(brace
multiline_comment|/* +- infinity */
id|loaded_data-&gt;sigh
op_assign
l_int|0x80000000
suffix:semicolon
id|loaded_data-&gt;sigl
op_assign
l_int|0x00000000
suffix:semicolon
id|exp
op_assign
id|EXP_Infinity
op_plus
id|EXTENDED_Ebias
suffix:semicolon
id|tag
op_assign
id|TAG_Special
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Must be a signaling or quiet NaN */
id|exp
op_assign
id|EXP_NaN
op_plus
id|EXTENDED_Ebias
suffix:semicolon
id|loaded_data-&gt;sigh
op_assign
id|m32
op_or
l_int|0x80000000
suffix:semicolon
id|loaded_data-&gt;sigl
op_assign
l_int|0
suffix:semicolon
id|tag
op_assign
id|TAG_Special
suffix:semicolon
multiline_comment|/* The calling function must look for NaNs */
)brace
)brace
r_else
(brace
id|loaded_data-&gt;sigh
op_assign
id|m32
op_or
l_int|0x80000000
suffix:semicolon
id|loaded_data-&gt;sigl
op_assign
l_int|0
suffix:semicolon
id|tag
op_assign
id|TAG_Valid
suffix:semicolon
)brace
id|setexponent16
c_func
(paren
id|loaded_data
comma
id|exp
op_or
id|negative
)paren
suffix:semicolon
multiline_comment|/* Set the sign. */
r_return
id|tag
suffix:semicolon
)brace
multiline_comment|/* Get a long long from user memory */
DECL|function|FPU_load_int64
r_int
id|FPU_load_int64
c_func
(paren
r_int
r_int
op_star
id|_s
)paren
(brace
r_int
r_int
id|s
suffix:semicolon
r_int
id|sign
suffix:semicolon
id|FPU_REG
op_star
id|st0_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_READ
comma
id|_s
comma
l_int|8
)paren
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|s
comma
id|_s
comma
l_int|8
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_if
c_cond
(paren
id|s
op_eq
l_int|0
)paren
(brace
id|reg_copy
c_func
(paren
op_amp
id|CONST_Z
comma
id|st0_ptr
)paren
suffix:semicolon
r_return
id|TAG_Zero
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
OG
l_int|0
)paren
id|sign
op_assign
id|SIGN_Positive
suffix:semicolon
r_else
(brace
id|s
op_assign
op_minus
id|s
suffix:semicolon
id|sign
op_assign
id|SIGN_Negative
suffix:semicolon
)brace
id|significand
c_func
(paren
id|st0_ptr
)paren
op_assign
id|s
suffix:semicolon
r_return
id|normalize_no_excep
c_func
(paren
id|st0_ptr
comma
l_int|63
comma
id|sign
)paren
suffix:semicolon
)brace
multiline_comment|/* Get a long from user memory */
DECL|function|FPU_load_int32
r_int
id|FPU_load_int32
c_func
(paren
r_int
op_star
id|_s
comma
id|FPU_REG
op_star
id|loaded_data
)paren
(brace
r_int
id|s
suffix:semicolon
r_int
id|negative
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_READ
comma
id|_s
comma
l_int|4
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|s
comma
id|_s
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_if
c_cond
(paren
id|s
op_eq
l_int|0
)paren
(brace
id|reg_copy
c_func
(paren
op_amp
id|CONST_Z
comma
id|loaded_data
)paren
suffix:semicolon
r_return
id|TAG_Zero
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
OG
l_int|0
)paren
id|negative
op_assign
id|SIGN_Positive
suffix:semicolon
r_else
(brace
id|s
op_assign
op_minus
id|s
suffix:semicolon
id|negative
op_assign
id|SIGN_Negative
suffix:semicolon
)brace
id|loaded_data-&gt;sigh
op_assign
id|s
suffix:semicolon
id|loaded_data-&gt;sigl
op_assign
l_int|0
suffix:semicolon
r_return
id|normalize_no_excep
c_func
(paren
id|loaded_data
comma
l_int|31
comma
id|negative
)paren
suffix:semicolon
)brace
multiline_comment|/* Get a short from user memory */
DECL|function|FPU_load_int16
r_int
id|FPU_load_int16
c_func
(paren
r_int
op_star
id|_s
comma
id|FPU_REG
op_star
id|loaded_data
)paren
(brace
r_int
id|s
comma
id|negative
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_READ
comma
id|_s
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Cast as short to get the sign extended. */
id|FPU_get_user
c_func
(paren
id|s
comma
id|_s
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_if
c_cond
(paren
id|s
op_eq
l_int|0
)paren
(brace
id|reg_copy
c_func
(paren
op_amp
id|CONST_Z
comma
id|loaded_data
)paren
suffix:semicolon
r_return
id|TAG_Zero
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
OG
l_int|0
)paren
id|negative
op_assign
id|SIGN_Positive
suffix:semicolon
r_else
(brace
id|s
op_assign
op_minus
id|s
suffix:semicolon
id|negative
op_assign
id|SIGN_Negative
suffix:semicolon
)brace
id|loaded_data-&gt;sigh
op_assign
id|s
op_lshift
l_int|16
suffix:semicolon
id|loaded_data-&gt;sigl
op_assign
l_int|0
suffix:semicolon
r_return
id|normalize_no_excep
c_func
(paren
id|loaded_data
comma
l_int|15
comma
id|negative
)paren
suffix:semicolon
)brace
multiline_comment|/* Get a packed bcd array from user memory */
DECL|function|FPU_load_bcd
r_int
id|FPU_load_bcd
c_func
(paren
id|u_char
op_star
id|s
)paren
(brace
id|FPU_REG
op_star
id|st0_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_int
id|pos
suffix:semicolon
id|u_char
id|bcd
suffix:semicolon
r_int
r_int
id|l
op_assign
l_int|0
suffix:semicolon
r_int
id|sign
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_READ
comma
id|s
comma
l_int|10
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_for
c_loop
(paren
id|pos
op_assign
l_int|8
suffix:semicolon
id|pos
op_ge
l_int|0
suffix:semicolon
id|pos
op_decrement
)paren
(brace
id|l
op_mul_assign
l_int|10
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|bcd
comma
(paren
id|u_char
op_star
)paren
id|s
op_plus
id|pos
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
id|l
op_add_assign
id|bcd
op_rshift
l_int|4
suffix:semicolon
id|l
op_mul_assign
l_int|10
suffix:semicolon
id|l
op_add_assign
id|bcd
op_amp
l_int|0x0f
suffix:semicolon
)brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|sign
comma
(paren
id|u_char
op_star
)paren
id|s
op_plus
l_int|9
)paren
suffix:semicolon
id|sign
op_assign
id|sign
op_amp
l_int|0x80
ques
c_cond
id|SIGN_Negative
suffix:colon
id|SIGN_Positive
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_if
c_cond
(paren
id|l
op_eq
l_int|0
)paren
(brace
id|reg_copy
c_func
(paren
op_amp
id|CONST_Z
comma
id|st0_ptr
)paren
suffix:semicolon
id|addexponent
c_func
(paren
id|st0_ptr
comma
id|sign
)paren
suffix:semicolon
multiline_comment|/* Set the sign. */
r_return
id|TAG_Zero
suffix:semicolon
)brace
r_else
(brace
id|significand
c_func
(paren
id|st0_ptr
)paren
op_assign
id|l
suffix:semicolon
r_return
id|normalize_no_excep
c_func
(paren
id|st0_ptr
comma
l_int|63
comma
id|sign
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*===========================================================================*/
multiline_comment|/* Put a long double into user memory */
DECL|function|FPU_store_extended
r_int
id|FPU_store_extended
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
comma
r_int
r_float
op_star
id|d
)paren
(brace
multiline_comment|/*&n;    The only exception raised by an attempt to store to an&n;    extended format is the Invalid Stack exception, i.e.&n;    attempting to store from an empty register.&n;   */
r_if
c_cond
(paren
id|st0_tag
op_ne
id|TAG_Empty
)paren
(brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|10
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
id|st0_ptr-&gt;sigl
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
id|st0_ptr-&gt;sigh
comma
(paren
r_int
r_int
op_star
)paren
(paren
(paren
id|u_char
op_star
)paren
id|d
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
id|exponent16
c_func
(paren
id|st0_ptr
)paren
comma
(paren
r_int
r_int
op_star
)paren
(paren
(paren
id|u_char
op_star
)paren
id|d
op_plus
l_int|8
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
multiline_comment|/* The masked response */
multiline_comment|/* Put out the QNaN indefinite */
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|10
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
l_int|0
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
l_int|0xc0000000
comma
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
l_int|0xffff
comma
l_int|4
op_plus
(paren
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Put a double into user memory */
DECL|function|FPU_store_double
r_int
id|FPU_store_double
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
comma
r_float
op_star
id|dfloat
)paren
(brace
r_int
r_int
id|l
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
id|increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* avoid gcc warnings */
r_int
id|precision_loss
suffix:semicolon
r_int
id|exp
suffix:semicolon
id|FPU_REG
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Valid
)paren
(brace
id|reg_copy
c_func
(paren
id|st0_ptr
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|exp
op_assign
id|exponent
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exp
OL
id|DOUBLE_Emin
)paren
multiline_comment|/* It may be a denormal */
(brace
id|addexponent
c_func
(paren
op_amp
id|tmp
comma
op_minus
id|DOUBLE_Emin
op_plus
l_int|52
)paren
suffix:semicolon
multiline_comment|/* largest exp to be 51 */
id|denormal_arg
suffix:colon
r_if
c_cond
(paren
(paren
id|precision_loss
op_assign
id|FPU_round_to_int
c_func
(paren
op_amp
id|tmp
comma
id|st0_tag
)paren
)paren
)paren
(brace
macro_line|#ifdef PECULIAR_486
multiline_comment|/* Did it round to a non-denormal ? */
multiline_comment|/* This behaviour might be regarded as peculiar, it appears&n;&t;&t; that the 80486 rounds to the dest precision, then&n;&t;&t; converts to decide underflow. */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|tmp.sigh
op_eq
l_int|0x00100000
)paren
op_logical_and
(paren
id|tmp.sigl
op_eq
l_int|0
)paren
op_logical_and
(paren
id|st0_ptr-&gt;sigl
op_amp
l_int|0x000007ff
)paren
)paren
)paren
macro_line|#endif PECULIAR_486
(brace
id|EXCEPTION
c_func
(paren
id|EX_Underflow
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of&n;&t;&t;     the 80486 book */
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Underflow
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|EXCEPTION
c_func
(paren
id|precision_loss
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Precision
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|l
(braket
l_int|0
)braket
op_assign
id|tmp.sigl
suffix:semicolon
id|l
(braket
l_int|1
)braket
op_assign
id|tmp.sigh
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|tmp.sigl
op_amp
l_int|0x000007ff
)paren
(brace
id|precision_loss
op_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|control_word
op_amp
id|CW_RC
)paren
(brace
r_case
id|RC_RND
suffix:colon
multiline_comment|/* Rounding can get a little messy.. */
id|increment
op_assign
(paren
(paren
id|tmp.sigl
op_amp
l_int|0x7ff
)paren
OG
l_int|0x400
)paren
op_or
multiline_comment|/* nearest */
(paren
(paren
id|tmp.sigl
op_amp
l_int|0xc00
)paren
op_eq
l_int|0xc00
)paren
suffix:semicolon
multiline_comment|/* odd -&gt; even */
r_break
suffix:semicolon
r_case
id|RC_DOWN
suffix:colon
multiline_comment|/* towards -infinity */
id|increment
op_assign
id|signpositive
c_func
(paren
op_amp
id|tmp
)paren
ques
c_cond
l_int|0
suffix:colon
id|tmp.sigl
op_amp
l_int|0x7ff
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RC_UP
suffix:colon
multiline_comment|/* towards +infinity */
id|increment
op_assign
id|signpositive
c_func
(paren
op_amp
id|tmp
)paren
ques
c_cond
id|tmp.sigl
op_amp
l_int|0x7ff
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RC_CHOP
suffix:colon
id|increment
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Truncate the mantissa */
id|tmp.sigl
op_and_assign
l_int|0xfffff800
suffix:semicolon
r_if
c_cond
(paren
id|increment
)paren
(brace
r_if
c_cond
(paren
id|tmp.sigl
op_ge
l_int|0xfffff800
)paren
(brace
multiline_comment|/* the sigl part overflows */
r_if
c_cond
(paren
id|tmp.sigh
op_eq
l_int|0xffffffff
)paren
(brace
multiline_comment|/* The sigh part overflows */
id|tmp.sigh
op_assign
l_int|0x80000000
suffix:semicolon
id|exp
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|exp
op_ge
id|EXP_OVER
)paren
r_goto
id|overflow
suffix:semicolon
)brace
r_else
(brace
id|tmp.sigh
op_increment
suffix:semicolon
)brace
id|tmp.sigl
op_assign
l_int|0x00000000
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We only need to increment sigl */
id|tmp.sigl
op_add_assign
l_int|0x00000800
suffix:semicolon
)brace
)brace
)brace
r_else
id|precision_loss
op_assign
l_int|0
suffix:semicolon
id|l
(braket
l_int|0
)braket
op_assign
(paren
id|tmp.sigl
op_rshift
l_int|11
)paren
op_or
(paren
id|tmp.sigh
op_lshift
l_int|21
)paren
suffix:semicolon
id|l
(braket
l_int|1
)braket
op_assign
(paren
(paren
id|tmp.sigh
op_rshift
l_int|11
)paren
op_amp
l_int|0xfffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exp
OG
id|DOUBLE_Emax
)paren
(brace
id|overflow
suffix:colon
id|EXCEPTION
c_func
(paren
id|EX_Overflow
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Overflow
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Precision
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
multiline_comment|/* Overflow to infinity */
id|l
(braket
l_int|0
)braket
op_assign
l_int|0x00000000
suffix:semicolon
multiline_comment|/* Set to */
id|l
(braket
l_int|1
)braket
op_assign
l_int|0x7ff00000
suffix:semicolon
multiline_comment|/* + INF */
)brace
r_else
(brace
r_if
c_cond
(paren
id|precision_loss
)paren
(brace
r_if
c_cond
(paren
id|increment
)paren
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
r_else
id|set_precision_flag_down
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Add the exponent */
id|l
(braket
l_int|1
)braket
op_or_assign
(paren
(paren
(paren
id|exp
op_plus
id|DOUBLE_Ebias
)paren
op_amp
l_int|0x7ff
)paren
op_lshift
l_int|20
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Zero
)paren
(brace
multiline_comment|/* Number is zero */
id|l
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|l
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Special
)paren
(brace
id|st0_tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
(brace
multiline_comment|/* A denormal will always underflow. */
macro_line|#ifndef PECULIAR_486
multiline_comment|/* An 80486 is supposed to be able to generate&n;&t;     a denormal exception here, but... */
multiline_comment|/* Underflow has priority. */
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Underflow
)paren
id|denormal_operand
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif PECULIAR_486
id|reg_copy
c_func
(paren
id|st0_ptr
comma
op_amp
id|tmp
)paren
suffix:semicolon
r_goto
id|denormal_arg
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Infinity
)paren
(brace
id|l
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|l
(braket
l_int|1
)braket
op_assign
l_int|0x7ff00000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_NaN
)paren
(brace
multiline_comment|/* Is it really a NaN ? */
r_if
c_cond
(paren
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
op_eq
id|EXP_OVER
)paren
op_logical_and
(paren
id|st0_ptr-&gt;sigh
op_amp
l_int|0x80000000
)paren
)paren
(brace
multiline_comment|/* See if we can get a valid NaN from the FPU_REG */
id|l
(braket
l_int|0
)braket
op_assign
(paren
id|st0_ptr-&gt;sigl
op_rshift
l_int|11
)paren
op_or
(paren
id|st0_ptr-&gt;sigh
op_lshift
l_int|21
)paren
suffix:semicolon
id|l
(braket
l_int|1
)braket
op_assign
(paren
(paren
id|st0_ptr-&gt;sigh
op_rshift
l_int|11
)paren
op_amp
l_int|0xfffff
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|st0_ptr-&gt;sigh
op_amp
l_int|0x40000000
)paren
)paren
(brace
multiline_comment|/* It is a signalling NaN */
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|l
(braket
l_int|1
)braket
op_or_assign
(paren
l_int|0x40000000
op_rshift
l_int|11
)paren
suffix:semicolon
)brace
id|l
(braket
l_int|1
)braket
op_or_assign
l_int|0x7ff00000
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* It is an unsupported data type */
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|l
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|l
(braket
l_int|1
)braket
op_assign
l_int|0xfff80000
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Empty
)paren
(brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
multiline_comment|/* The masked response */
multiline_comment|/* Put out the QNaN indefinite */
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|dfloat
comma
l_int|8
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
l_int|0
comma
(paren
r_int
r_int
op_star
)paren
id|dfloat
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
l_int|0xfff80000
comma
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|dfloat
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|getsign
c_func
(paren
id|st0_ptr
)paren
)paren
id|l
(braket
l_int|1
)braket
op_or_assign
l_int|0x80000000
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|dfloat
comma
l_int|8
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
id|l
(braket
l_int|0
)braket
comma
(paren
r_int
r_int
op_star
)paren
id|dfloat
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
id|l
(braket
l_int|1
)braket
comma
l_int|1
op_plus
(paren
r_int
r_int
op_star
)paren
id|dfloat
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Put a float into user memory */
DECL|function|FPU_store_single
r_int
id|FPU_store_single
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
comma
r_float
op_star
id|single
)paren
(brace
r_int
id|templ
suffix:semicolon
r_int
r_int
id|increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* avoid gcc warnings */
r_int
id|precision_loss
suffix:semicolon
r_int
id|exp
suffix:semicolon
id|FPU_REG
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Valid
)paren
(brace
id|reg_copy
c_func
(paren
id|st0_ptr
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|exp
op_assign
id|exponent
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exp
OL
id|SINGLE_Emin
)paren
(brace
id|addexponent
c_func
(paren
op_amp
id|tmp
comma
op_minus
id|SINGLE_Emin
op_plus
l_int|23
)paren
suffix:semicolon
multiline_comment|/* largest exp to be 22 */
id|denormal_arg
suffix:colon
r_if
c_cond
(paren
(paren
id|precision_loss
op_assign
id|FPU_round_to_int
c_func
(paren
op_amp
id|tmp
comma
id|st0_tag
)paren
)paren
)paren
(brace
macro_line|#ifdef PECULIAR_486
multiline_comment|/* Did it round to a non-denormal ? */
multiline_comment|/* This behaviour might be regarded as peculiar, it appears&n;&t;&t; that the 80486 rounds to the dest precision, then&n;&t;&t; converts to decide underflow. */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|tmp.sigl
op_eq
l_int|0x00800000
)paren
op_logical_and
(paren
(paren
id|st0_ptr-&gt;sigh
op_amp
l_int|0x000000ff
)paren
op_logical_or
id|st0_ptr-&gt;sigl
)paren
)paren
)paren
macro_line|#endif PECULIAR_486
(brace
id|EXCEPTION
c_func
(paren
id|EX_Underflow
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of&n;&t;&t;     the 80486 book */
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Underflow
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|EXCEPTION
c_func
(paren
id|precision_loss
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Precision
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|templ
op_assign
id|tmp.sigl
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|tmp.sigl
op_or
(paren
id|tmp.sigh
op_amp
l_int|0x000000ff
)paren
)paren
(brace
r_int
r_int
id|sigh
op_assign
id|tmp.sigh
suffix:semicolon
r_int
r_int
id|sigl
op_assign
id|tmp.sigl
suffix:semicolon
id|precision_loss
op_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|control_word
op_amp
id|CW_RC
)paren
(brace
r_case
id|RC_RND
suffix:colon
id|increment
op_assign
(paren
(paren
id|sigh
op_amp
l_int|0xff
)paren
OG
l_int|0x80
)paren
multiline_comment|/* more than half */
op_logical_or
(paren
(paren
(paren
id|sigh
op_amp
l_int|0xff
)paren
op_eq
l_int|0x80
)paren
op_logical_and
id|sigl
)paren
multiline_comment|/* more than half */
op_logical_or
(paren
(paren
id|sigh
op_amp
l_int|0x180
)paren
op_eq
l_int|0x180
)paren
suffix:semicolon
multiline_comment|/* round to even */
r_break
suffix:semicolon
r_case
id|RC_DOWN
suffix:colon
multiline_comment|/* towards -infinity */
id|increment
op_assign
id|signpositive
c_func
(paren
op_amp
id|tmp
)paren
ques
c_cond
l_int|0
suffix:colon
(paren
id|sigl
op_or
(paren
id|sigh
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RC_UP
suffix:colon
multiline_comment|/* towards +infinity */
id|increment
op_assign
id|signpositive
c_func
(paren
op_amp
id|tmp
)paren
ques
c_cond
(paren
id|sigl
op_or
(paren
id|sigh
op_amp
l_int|0xff
)paren
)paren
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RC_CHOP
suffix:colon
id|increment
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Truncate part of the mantissa */
id|tmp.sigl
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|increment
)paren
(brace
r_if
c_cond
(paren
id|sigh
op_ge
l_int|0xffffff00
)paren
(brace
multiline_comment|/* The sigh part overflows */
id|tmp.sigh
op_assign
l_int|0x80000000
suffix:semicolon
id|exp
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|exp
op_ge
id|EXP_OVER
)paren
r_goto
id|overflow
suffix:semicolon
)brace
r_else
(brace
id|tmp.sigh
op_and_assign
l_int|0xffffff00
suffix:semicolon
id|tmp.sigh
op_add_assign
l_int|0x100
suffix:semicolon
)brace
)brace
r_else
(brace
id|tmp.sigh
op_and_assign
l_int|0xffffff00
suffix:semicolon
multiline_comment|/* Finish the truncation */
)brace
)brace
r_else
id|precision_loss
op_assign
l_int|0
suffix:semicolon
id|templ
op_assign
(paren
id|tmp.sigh
op_rshift
l_int|8
)paren
op_amp
l_int|0x007fffff
suffix:semicolon
r_if
c_cond
(paren
id|exp
OG
id|SINGLE_Emax
)paren
(brace
id|overflow
suffix:colon
id|EXCEPTION
c_func
(paren
id|EX_Overflow
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Overflow
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Precision
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book. */
multiline_comment|/* Masked response is overflow to infinity. */
id|templ
op_assign
l_int|0x7f800000
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|precision_loss
)paren
(brace
r_if
c_cond
(paren
id|increment
)paren
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
r_else
id|set_precision_flag_down
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Add the exponent */
id|templ
op_or_assign
(paren
(paren
id|exp
op_plus
id|SINGLE_Ebias
)paren
op_amp
l_int|0xff
)paren
op_lshift
l_int|23
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Zero
)paren
(brace
id|templ
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Special
)paren
(brace
id|st0_tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
(brace
id|reg_copy
c_func
(paren
id|st0_ptr
comma
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* A denormal will always underflow. */
macro_line|#ifndef PECULIAR_486
multiline_comment|/* An 80486 is supposed to be able to generate&n;&t;     a denormal exception here, but... */
multiline_comment|/* Underflow has priority. */
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Underflow
)paren
id|denormal_operand
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif PECULIAR_486
r_goto
id|denormal_arg
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Infinity
)paren
(brace
id|templ
op_assign
l_int|0x7f800000
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_NaN
)paren
(brace
multiline_comment|/* Is it really a NaN ? */
r_if
c_cond
(paren
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
op_eq
id|EXP_OVER
)paren
op_logical_and
(paren
id|st0_ptr-&gt;sigh
op_amp
l_int|0x80000000
)paren
)paren
(brace
multiline_comment|/* See if we can get a valid NaN from the FPU_REG */
id|templ
op_assign
id|st0_ptr-&gt;sigh
op_rshift
l_int|8
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|st0_ptr-&gt;sigh
op_amp
l_int|0x40000000
)paren
)paren
(brace
multiline_comment|/* It is a signalling NaN */
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|templ
op_or_assign
(paren
l_int|0x40000000
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
id|templ
op_or_assign
l_int|0x7f800000
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* It is an unsupported data type */
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|templ
op_assign
l_int|0xffc00000
suffix:semicolon
)brace
)brace
macro_line|#ifdef PARANOID
r_else
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x164
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Empty
)paren
(brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
multiline_comment|/* The masked response */
multiline_comment|/* Put out the QNaN indefinite */
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|single
comma
l_int|4
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
l_int|0xffc00000
comma
(paren
r_int
r_int
op_star
)paren
id|single
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
r_else
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x163
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|getsign
c_func
(paren
id|st0_ptr
)paren
)paren
id|templ
op_or_assign
l_int|0x80000000
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|single
comma
l_int|4
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
id|templ
comma
(paren
r_int
r_int
op_star
)paren
id|single
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Put a long long into user memory */
DECL|function|FPU_store_int64
r_int
id|FPU_store_int64
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
comma
r_int
r_int
op_star
id|d
)paren
(brace
id|FPU_REG
id|t
suffix:semicolon
r_int
r_int
id|tll
suffix:semicolon
r_int
id|precision_loss
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Empty
)paren
(brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_goto
id|invalid_operand
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Special
)paren
(brace
id|st0_tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TW_Infinity
)paren
op_logical_or
(paren
id|st0_tag
op_eq
id|TW_NaN
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_goto
id|invalid_operand
suffix:semicolon
)brace
)brace
id|reg_copy
c_func
(paren
id|st0_ptr
comma
op_amp
id|t
)paren
suffix:semicolon
id|precision_loss
op_assign
id|FPU_round_to_int
c_func
(paren
op_amp
id|t
comma
id|st0_tag
)paren
suffix:semicolon
(paren
(paren
r_int
op_star
)paren
op_amp
id|tll
)paren
(braket
l_int|0
)braket
op_assign
id|t.sigl
suffix:semicolon
(paren
(paren
r_int
op_star
)paren
op_amp
id|tll
)paren
(braket
l_int|1
)braket
op_assign
id|t.sigh
suffix:semicolon
r_if
c_cond
(paren
(paren
id|precision_loss
op_eq
l_int|1
)paren
op_logical_or
(paren
(paren
id|t.sigh
op_amp
l_int|0x80000000
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|t.sigh
op_eq
l_int|0x80000000
)paren
op_logical_and
(paren
id|t.sigl
op_eq
l_int|0
)paren
op_logical_and
id|signnegative
c_func
(paren
op_amp
id|t
)paren
)paren
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
id|invalid_operand
suffix:colon
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
multiline_comment|/* Produce something like QNaN &quot;indefinite&quot; */
id|tll
op_assign
l_int|0x8000000000000000LL
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|precision_loss
)paren
id|set_precision_flag
c_func
(paren
id|precision_loss
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signnegative
c_func
(paren
op_amp
id|t
)paren
)paren
id|tll
op_assign
op_minus
id|tll
suffix:semicolon
)brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|d
comma
l_int|8
)paren
suffix:semicolon
id|copy_to_user
c_func
(paren
id|d
comma
op_amp
id|tll
comma
l_int|8
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Put a long into user memory */
DECL|function|FPU_store_int32
r_int
id|FPU_store_int32
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
comma
r_int
op_star
id|d
)paren
(brace
id|FPU_REG
id|t
suffix:semicolon
r_int
id|precision_loss
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Empty
)paren
(brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_goto
id|invalid_operand
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Special
)paren
(brace
id|st0_tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TW_Infinity
)paren
op_logical_or
(paren
id|st0_tag
op_eq
id|TW_NaN
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_goto
id|invalid_operand
suffix:semicolon
)brace
)brace
id|reg_copy
c_func
(paren
id|st0_ptr
comma
op_amp
id|t
)paren
suffix:semicolon
id|precision_loss
op_assign
id|FPU_round_to_int
c_func
(paren
op_amp
id|t
comma
id|st0_tag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t.sigh
op_logical_or
(paren
(paren
id|t.sigl
op_amp
l_int|0x80000000
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|t.sigl
op_eq
l_int|0x80000000
)paren
op_logical_and
id|signnegative
c_func
(paren
op_amp
id|t
)paren
)paren
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
id|invalid_operand
suffix:colon
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
multiline_comment|/* Produce something like QNaN &quot;indefinite&quot; */
id|t.sigl
op_assign
l_int|0x80000000
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|precision_loss
)paren
id|set_precision_flag
c_func
(paren
id|precision_loss
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signnegative
c_func
(paren
op_amp
id|t
)paren
)paren
id|t.sigl
op_assign
op_minus
(paren
r_int
)paren
id|t.sigl
suffix:semicolon
)brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|4
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
id|t.sigl
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Put a short into user memory */
DECL|function|FPU_store_int16
r_int
id|FPU_store_int16
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
comma
r_int
op_star
id|d
)paren
(brace
id|FPU_REG
id|t
suffix:semicolon
r_int
id|precision_loss
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Empty
)paren
(brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_goto
id|invalid_operand
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Special
)paren
(brace
id|st0_tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TW_Infinity
)paren
op_logical_or
(paren
id|st0_tag
op_eq
id|TW_NaN
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_goto
id|invalid_operand
suffix:semicolon
)brace
)brace
id|reg_copy
c_func
(paren
id|st0_ptr
comma
op_amp
id|t
)paren
suffix:semicolon
id|precision_loss
op_assign
id|FPU_round_to_int
c_func
(paren
op_amp
id|t
comma
id|st0_tag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t.sigh
op_logical_or
(paren
(paren
id|t.sigl
op_amp
l_int|0xffff8000
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|t.sigl
op_eq
l_int|0x8000
)paren
op_logical_and
id|signnegative
c_func
(paren
op_amp
id|t
)paren
)paren
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
id|invalid_operand
suffix:colon
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
multiline_comment|/* Produce something like QNaN &quot;indefinite&quot; */
id|t.sigl
op_assign
l_int|0x8000
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|precision_loss
)paren
id|set_precision_flag
c_func
(paren
id|precision_loss
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signnegative
c_func
(paren
op_amp
id|t
)paren
)paren
id|t.sigl
op_assign
op_minus
id|t.sigl
suffix:semicolon
)brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|2
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
(paren
r_int
)paren
id|t.sigl
comma
(paren
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Put a packed bcd array into user memory */
DECL|function|FPU_store_bcd
r_int
id|FPU_store_bcd
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
comma
id|u_char
op_star
id|d
)paren
(brace
id|FPU_REG
id|t
suffix:semicolon
r_int
r_int
r_int
id|ll
suffix:semicolon
id|u_char
id|b
suffix:semicolon
r_int
id|i
comma
id|precision_loss
suffix:semicolon
id|u_char
id|sign
op_assign
(paren
id|getsign
c_func
(paren
id|st0_ptr
)paren
op_eq
id|SIGN_NEG
)paren
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Empty
)paren
(brace
multiline_comment|/* Empty register (stack underflow) */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_goto
id|invalid_operand
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Special
)paren
(brace
id|st0_tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TW_Infinity
)paren
op_logical_or
(paren
id|st0_tag
op_eq
id|TW_NaN
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_goto
id|invalid_operand
suffix:semicolon
)brace
)brace
id|reg_copy
c_func
(paren
id|st0_ptr
comma
op_amp
id|t
)paren
suffix:semicolon
id|precision_loss
op_assign
id|FPU_round_to_int
c_func
(paren
op_amp
id|t
comma
id|st0_tag
)paren
suffix:semicolon
id|ll
op_assign
id|significand
c_func
(paren
op_amp
id|t
)paren
suffix:semicolon
multiline_comment|/* Check for overflow, by comparing with 999999999999999999 decimal. */
r_if
c_cond
(paren
(paren
id|t.sigh
OG
l_int|0x0de0b6b3
)paren
op_logical_or
(paren
(paren
id|t.sigh
op_eq
l_int|0x0de0b6b3
)paren
op_logical_and
(paren
id|t.sigl
OG
l_int|0xa763ffff
)paren
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
multiline_comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
id|invalid_operand
suffix:colon
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
multiline_comment|/* Produce the QNaN &quot;indefinite&quot; */
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|10
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
id|FPU_put_user
c_func
(paren
l_int|0
comma
(paren
id|u_char
op_star
)paren
id|d
op_plus
id|i
)paren
suffix:semicolon
multiline_comment|/* These bytes &quot;undefined&quot; */
id|FPU_put_user
c_func
(paren
l_int|0xc0
comma
(paren
id|u_char
op_star
)paren
id|d
op_plus
l_int|7
)paren
suffix:semicolon
multiline_comment|/* This byte &quot;undefined&quot; */
id|FPU_put_user
c_func
(paren
l_int|0xff
comma
(paren
id|u_char
op_star
)paren
id|d
op_plus
l_int|8
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
l_int|0xff
comma
(paren
id|u_char
op_star
)paren
id|d
op_plus
l_int|9
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|precision_loss
)paren
(brace
multiline_comment|/* Precision loss doesn&squot;t stop the data transfer */
id|set_precision_flag
c_func
(paren
id|precision_loss
)paren
suffix:semicolon
)brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|10
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|9
suffix:semicolon
id|i
op_increment
)paren
(brace
id|b
op_assign
id|FPU_div_small
c_func
(paren
op_amp
id|ll
comma
l_int|10
)paren
suffix:semicolon
id|b
op_or_assign
(paren
id|FPU_div_small
c_func
(paren
op_amp
id|ll
comma
l_int|10
)paren
)paren
op_lshift
l_int|4
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_put_user
c_func
(paren
id|b
comma
(paren
id|u_char
op_star
)paren
id|d
op_plus
id|i
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
)brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_put_user
c_func
(paren
id|sign
comma
(paren
id|u_char
op_star
)paren
id|d
op_plus
l_int|9
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*===========================================================================*/
multiline_comment|/* r gets mangled such that sig is int, sign: &n;   it is NOT normalized */
multiline_comment|/* The return value (in eax) is zero if the result is exact,&n;   if bits are changed due to rounding, truncation, etc, then&n;   a non-zero value is returned */
multiline_comment|/* Overflow is signalled by a non-zero return value (in eax).&n;   In the case of overflow, the returned significand always has the&n;   largest possible value */
DECL|function|FPU_round_to_int
r_int
id|FPU_round_to_int
c_func
(paren
id|FPU_REG
op_star
id|r
comma
id|u_char
id|tag
)paren
(brace
id|u_char
id|very_big
suffix:semicolon
r_int
id|eax
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|TAG_Zero
)paren
(brace
multiline_comment|/* Make sure that zero is returned */
id|significand
c_func
(paren
id|r
)paren
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* o.k. */
)brace
r_if
c_cond
(paren
id|exponent
c_func
(paren
id|r
)paren
OG
l_int|63
)paren
(brace
id|r-&gt;sigl
op_assign
id|r-&gt;sigh
op_assign
op_complement
l_int|0
suffix:semicolon
multiline_comment|/* The largest representable number */
r_return
l_int|1
suffix:semicolon
multiline_comment|/* overflow */
)brace
id|eax
op_assign
id|FPU_shrxs
c_func
(paren
op_amp
id|r-&gt;sigl
comma
l_int|63
op_minus
id|exponent
c_func
(paren
id|r
)paren
)paren
suffix:semicolon
id|very_big
op_assign
op_logical_neg
(paren
op_complement
(paren
id|r-&gt;sigh
)paren
op_or
op_complement
(paren
id|r-&gt;sigl
)paren
)paren
suffix:semicolon
multiline_comment|/* test for 0xfff...fff */
DECL|macro|half_or_more
mdefine_line|#define&t;half_or_more&t;(eax &amp; 0x80000000)
DECL|macro|frac_part
mdefine_line|#define&t;frac_part&t;(eax)
DECL|macro|more_than_half
mdefine_line|#define more_than_half  ((eax &amp; 0x80000001) == 0x80000001)
r_switch
c_cond
(paren
id|control_word
op_amp
id|CW_RC
)paren
(brace
r_case
id|RC_RND
suffix:colon
r_if
c_cond
(paren
id|more_than_half
multiline_comment|/* nearest */
op_logical_or
(paren
id|half_or_more
op_logical_and
(paren
id|r-&gt;sigl
op_amp
l_int|1
)paren
)paren
)paren
multiline_comment|/* odd -&gt; even */
(brace
r_if
c_cond
(paren
id|very_big
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* overflow */
id|significand
c_func
(paren
id|r
)paren
op_increment
suffix:semicolon
r_return
id|PRECISION_LOST_UP
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RC_DOWN
suffix:colon
r_if
c_cond
(paren
id|frac_part
op_logical_and
id|getsign
c_func
(paren
id|r
)paren
)paren
(brace
r_if
c_cond
(paren
id|very_big
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* overflow */
id|significand
c_func
(paren
id|r
)paren
op_increment
suffix:semicolon
r_return
id|PRECISION_LOST_UP
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RC_UP
suffix:colon
r_if
c_cond
(paren
id|frac_part
op_logical_and
op_logical_neg
id|getsign
c_func
(paren
id|r
)paren
)paren
(brace
r_if
c_cond
(paren
id|very_big
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* overflow */
id|significand
c_func
(paren
id|r
)paren
op_increment
suffix:semicolon
r_return
id|PRECISION_LOST_UP
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|RC_CHOP
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|eax
ques
c_cond
id|PRECISION_LOST_DOWN
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*===========================================================================*/
DECL|function|fldenv
id|u_char
op_star
id|fldenv
c_func
(paren
id|fpu_addr_modes
id|addr_modes
comma
id|u_char
op_star
id|s
)paren
(brace
r_int
r_int
id|tag_word
op_assign
l_int|0
suffix:semicolon
id|u_char
id|tag
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|addr_modes.default_mode
op_eq
id|VM86
)paren
op_logical_or
(paren
(paren
id|addr_modes.default_mode
op_eq
id|PM16
)paren
op_xor
(paren
id|addr_modes.override.operand_size
op_eq
id|OP_SIZE_PREFIX
)paren
)paren
)paren
(brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_READ
comma
id|s
comma
l_int|0x0e
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|control_word
comma
(paren
r_int
r_int
op_star
)paren
id|s
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|partial_status
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|tag_word
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|instruction_address.offset
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|6
)paren
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|instruction_address.selector
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|8
)paren
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|operand_address.offset
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|0x0a
)paren
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|operand_address.selector
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|0x0c
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
id|s
op_add_assign
l_int|0x0e
suffix:semicolon
r_if
c_cond
(paren
id|addr_modes.default_mode
op_eq
id|VM86
)paren
(brace
id|instruction_address.offset
op_add_assign
(paren
id|instruction_address.selector
op_amp
l_int|0xf000
)paren
op_lshift
l_int|4
suffix:semicolon
id|operand_address.offset
op_add_assign
(paren
id|operand_address.selector
op_amp
l_int|0xf000
)paren
op_lshift
l_int|4
suffix:semicolon
)brace
)brace
r_else
(brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_READ
comma
id|s
comma
l_int|0x1c
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|control_word
comma
(paren
r_int
r_int
op_star
)paren
id|s
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|partial_status
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|tag_word
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|8
)paren
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|instruction_address.offset
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|0x0c
)paren
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|instruction_address.selector
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|0x10
)paren
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|instruction_address.opcode
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|0x12
)paren
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|operand_address.offset
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|0x14
)paren
)paren
suffix:semicolon
id|FPU_get_user
c_func
(paren
id|operand_address.selector
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|0x18
)paren
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
id|s
op_add_assign
l_int|0x1c
suffix:semicolon
)brace
macro_line|#ifdef PECULIAR_486
id|control_word
op_and_assign
op_complement
l_int|0xe080
suffix:semicolon
macro_line|#endif PECULIAR_486
id|top
op_assign
(paren
id|partial_status
op_rshift
id|SW_Top_Shift
)paren
op_amp
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|partial_status
op_amp
op_complement
id|control_word
op_amp
id|CW_Exceptions
)paren
id|partial_status
op_or_assign
(paren
id|SW_Summary
op_or
id|SW_Backward
)paren
suffix:semicolon
r_else
id|partial_status
op_and_assign
op_complement
(paren
id|SW_Summary
op_or
id|SW_Backward
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tag
op_assign
id|tag_word
op_amp
l_int|3
suffix:semicolon
id|tag_word
op_rshift_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|TAG_Empty
)paren
multiline_comment|/* New tag is empty.  Accept it */
id|FPU_settag
c_func
(paren
id|i
comma
id|TAG_Empty
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|FPU_gettag
c_func
(paren
id|i
)paren
op_eq
id|TAG_Empty
)paren
(brace
multiline_comment|/* Old tag is empty and new tag is not empty.  New tag is determined&n;&t;     by old reg contents */
r_if
c_cond
(paren
id|exponent
c_func
(paren
op_amp
id|fpu_register
c_func
(paren
id|i
)paren
)paren
op_eq
op_minus
id|EXTENDED_Ebias
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|fpu_register
c_func
(paren
id|i
)paren
dot
id|sigl
op_or
id|fpu_register
c_func
(paren
id|i
)paren
dot
id|sigh
)paren
)paren
id|FPU_settag
c_func
(paren
id|i
comma
id|TAG_Zero
)paren
suffix:semicolon
r_else
id|FPU_settag
c_func
(paren
id|i
comma
id|TAG_Special
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|exponent
c_func
(paren
op_amp
id|fpu_register
c_func
(paren
id|i
)paren
)paren
op_eq
l_int|0x7fff
op_minus
id|EXTENDED_Ebias
)paren
(brace
id|FPU_settag
c_func
(paren
id|i
comma
id|TAG_Special
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|fpu_register
c_func
(paren
id|i
)paren
dot
id|sigh
op_amp
l_int|0x80000000
)paren
id|FPU_settag
c_func
(paren
id|i
comma
id|TAG_Valid
)paren
suffix:semicolon
r_else
id|FPU_settag
c_func
(paren
id|i
comma
id|TAG_Special
)paren
suffix:semicolon
multiline_comment|/* An Un-normal */
)brace
multiline_comment|/* Else old tag is not empty and new tag is not empty.  Old tag&n;&t; remains correct */
)brace
r_return
id|s
suffix:semicolon
)brace
DECL|function|frstor
r_void
id|frstor
c_func
(paren
id|fpu_addr_modes
id|addr_modes
comma
id|u_char
op_star
id|data_address
)paren
(brace
r_int
id|i
comma
id|regnr
suffix:semicolon
id|u_char
op_star
id|s
op_assign
id|fldenv
c_func
(paren
id|addr_modes
comma
id|data_address
)paren
suffix:semicolon
r_int
id|offset
op_assign
(paren
id|top
op_amp
l_int|7
)paren
op_star
l_int|10
comma
id|other
op_assign
l_int|80
op_minus
id|offset
suffix:semicolon
multiline_comment|/* Copy all registers in stack order. */
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_READ
comma
id|s
comma
l_int|80
)paren
suffix:semicolon
id|__copy_from_user
c_func
(paren
id|register_base
op_plus
id|offset
comma
id|s
comma
id|other
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
id|__copy_from_user
c_func
(paren
id|register_base
comma
id|s
op_plus
id|other
comma
id|offset
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|regnr
op_assign
(paren
id|i
op_plus
id|top
)paren
op_amp
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|FPU_gettag
c_func
(paren
id|regnr
)paren
op_ne
id|TAG_Empty
)paren
multiline_comment|/* The loaded data over-rides all other cases. */
id|FPU_settag
c_func
(paren
id|regnr
comma
id|FPU_tagof
c_func
(paren
op_amp
id|st
c_func
(paren
id|i
)paren
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|fstenv
id|u_char
op_star
id|fstenv
c_func
(paren
id|fpu_addr_modes
id|addr_modes
comma
id|u_char
op_star
id|d
)paren
(brace
r_if
c_cond
(paren
(paren
id|addr_modes.default_mode
op_eq
id|VM86
)paren
op_logical_or
(paren
(paren
id|addr_modes.default_mode
op_eq
id|PM16
)paren
op_xor
(paren
id|addr_modes.override.operand_size
op_eq
id|OP_SIZE_PREFIX
)paren
)paren
)paren
(brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|14
)paren
suffix:semicolon
macro_line|#ifdef PECULIAR_486
id|FPU_put_user
c_func
(paren
id|control_word
op_amp
op_complement
l_int|0xe080
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
macro_line|#else
id|FPU_put_user
c_func
(paren
id|control_word
comma
(paren
r_int
r_int
op_star
)paren
id|d
)paren
suffix:semicolon
macro_line|#endif PECULIAR_486
id|FPU_put_user
c_func
(paren
id|status_word
c_func
(paren
)paren
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
id|fpu_tag_word
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|4
)paren
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
id|instruction_address.offset
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|6
)paren
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
id|operand_address.offset
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|0x0a
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr_modes.default_mode
op_eq
id|VM86
)paren
(brace
id|FPU_put_user
c_func
(paren
(paren
id|instruction_address.offset
op_amp
l_int|0xf0000
)paren
op_rshift
l_int|4
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|8
)paren
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
(paren
id|operand_address.offset
op_amp
l_int|0xf0000
)paren
op_rshift
l_int|4
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|0x0c
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|FPU_put_user
c_func
(paren
id|instruction_address.selector
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|8
)paren
)paren
suffix:semicolon
id|FPU_put_user
c_func
(paren
id|operand_address.selector
comma
(paren
r_int
r_int
op_star
)paren
(paren
id|d
op_plus
l_int|0x0c
)paren
)paren
suffix:semicolon
)brace
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
id|d
op_add_assign
l_int|0x0e
suffix:semicolon
)brace
r_else
(brace
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|7
op_star
l_int|4
)paren
suffix:semicolon
macro_line|#ifdef PECULIAR_486
id|control_word
op_and_assign
op_complement
l_int|0xe080
suffix:semicolon
multiline_comment|/* An 80486 sets nearly all of the reserved bits to 1. */
id|control_word
op_or_assign
l_int|0xffff0040
suffix:semicolon
id|partial_status
op_assign
id|status_word
c_func
(paren
)paren
op_or
l_int|0xffff0000
suffix:semicolon
id|fpu_tag_word
op_or_assign
l_int|0xffff0000
suffix:semicolon
id|I387.soft.fcs
op_and_assign
op_complement
l_int|0xf8000000
suffix:semicolon
id|I387.soft.fos
op_or_assign
l_int|0xffff0000
suffix:semicolon
macro_line|#endif PECULIAR_486
id|__copy_to_user
c_func
(paren
id|d
comma
op_amp
id|control_word
comma
l_int|7
op_star
l_int|4
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
id|d
op_add_assign
l_int|0x1c
suffix:semicolon
)brace
id|control_word
op_or_assign
id|CW_Exceptions
suffix:semicolon
id|partial_status
op_and_assign
op_complement
(paren
id|SW_Summary
op_or
id|SW_Backward
)paren
suffix:semicolon
r_return
id|d
suffix:semicolon
)brace
DECL|function|fsave
r_void
id|fsave
c_func
(paren
id|fpu_addr_modes
id|addr_modes
comma
id|u_char
op_star
id|data_address
)paren
(brace
id|u_char
op_star
id|d
suffix:semicolon
r_int
id|offset
op_assign
(paren
id|top
op_amp
l_int|7
)paren
op_star
l_int|10
comma
id|other
op_assign
l_int|80
op_minus
id|offset
suffix:semicolon
id|d
op_assign
id|fstenv
c_func
(paren
id|addr_modes
comma
id|data_address
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_OFF
suffix:semicolon
id|FPU_verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|d
comma
l_int|80
)paren
suffix:semicolon
multiline_comment|/* Copy all registers in stack order. */
id|__copy_to_user
c_func
(paren
id|d
comma
id|register_base
op_plus
id|offset
comma
id|other
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
)paren
id|__copy_to_user
c_func
(paren
id|d
op_plus
id|other
comma
id|register_base
comma
id|offset
)paren
suffix:semicolon
id|RE_ENTRANT_CHECK_ON
suffix:semicolon
id|finit
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*===========================================================================*/
eof
