multiline_comment|/*---------------------------------------------------------------------------+&n; |  poly_l2.c                                                                |&n; |                                                                           |&n; | Compute the base 2 log of a FPU_REG, using a polynomial approximation.    |&n; |                                                                           |&n; | Copyright (C) 1992,1993,1994,1997                                         |&n; |                  W. Metzenthen, 22 Parker St, Ormond, Vic 3163, Australia |&n; |                  E-mail   billm@suburbia.net                              |&n; |                                                                           |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;reg_constant.h&quot;
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &quot;fpu_system.h&quot;
macro_line|#include &quot;control_w.h&quot;
macro_line|#include &quot;poly.h&quot;
r_static
r_void
id|log2_kernel
c_func
(paren
id|FPU_REG
r_const
op_star
id|arg
comma
id|u_char
id|argsign
comma
id|Xsig
op_star
id|accum_result
comma
r_int
r_int
op_star
id|expon
)paren
suffix:semicolon
multiline_comment|/*--- poly_l2() -------------------------------------------------------------+&n; |   Base 2 logarithm by a polynomial approximation.                         |&n; +---------------------------------------------------------------------------*/
DECL|function|poly_l2
r_void
id|poly_l2
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|FPU_REG
op_star
id|st1_ptr
comma
id|u_char
id|st1_sign
)paren
(brace
r_int
r_int
id|exponent
comma
id|expon
comma
id|expon_expon
suffix:semicolon
id|Xsig
id|accumulator
comma
id|expon_accum
comma
id|yaccum
suffix:semicolon
id|u_char
id|sign
comma
id|argsign
suffix:semicolon
id|FPU_REG
id|x
suffix:semicolon
r_int
id|tag
suffix:semicolon
id|exponent
op_assign
id|exponent16
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
multiline_comment|/* From st0_ptr, make a number &gt; sqrt(2)/2 and &lt; sqrt(2) */
r_if
c_cond
(paren
id|st0_ptr-&gt;sigh
OG
(paren
r_int
)paren
l_int|0xb504f334
)paren
(brace
multiline_comment|/* Treat as  sqrt(2)/2 &lt; st0_ptr &lt; 1 */
id|significand
c_func
(paren
op_amp
id|x
)paren
op_assign
op_minus
id|significand
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
id|setexponent16
c_func
(paren
op_amp
id|x
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|exponent
op_increment
suffix:semicolon
id|argsign
op_assign
id|SIGN_NEG
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Treat as  1 &lt;= st0_ptr &lt; sqrt(2) */
id|x.sigh
op_assign
id|st0_ptr-&gt;sigh
op_minus
l_int|0x80000000
suffix:semicolon
id|x.sigl
op_assign
id|st0_ptr-&gt;sigl
suffix:semicolon
id|setexponent16
c_func
(paren
op_amp
id|x
comma
l_int|0
)paren
suffix:semicolon
id|argsign
op_assign
id|SIGN_POS
suffix:semicolon
)brace
id|tag
op_assign
id|FPU_normalize_nuo
c_func
(paren
op_amp
id|x
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|TAG_Zero
)paren
(brace
id|expon
op_assign
l_int|0
suffix:semicolon
id|accumulator.msw
op_assign
id|accumulator.midw
op_assign
id|accumulator.lsw
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|log2_kernel
c_func
(paren
op_amp
id|x
comma
id|argsign
comma
op_amp
id|accumulator
comma
op_amp
id|expon
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|exponent
OL
l_int|0
)paren
(brace
id|sign
op_assign
id|SIGN_NEG
suffix:semicolon
id|exponent
op_assign
op_minus
id|exponent
suffix:semicolon
)brace
r_else
id|sign
op_assign
id|SIGN_POS
suffix:semicolon
id|expon_accum.msw
op_assign
id|exponent
suffix:semicolon
id|expon_accum.midw
op_assign
id|expon_accum.lsw
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|exponent
)paren
(brace
id|expon_expon
op_assign
l_int|31
op_plus
id|norm_Xsig
c_func
(paren
op_amp
id|expon_accum
)paren
suffix:semicolon
id|shr_Xsig
c_func
(paren
op_amp
id|accumulator
comma
id|expon_expon
op_minus
id|expon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sign
op_xor
id|argsign
)paren
id|negate_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
id|add_Xsig_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|expon_accum
)paren
suffix:semicolon
)brace
r_else
(brace
id|expon_expon
op_assign
id|expon
suffix:semicolon
id|sign
op_assign
id|argsign
suffix:semicolon
)brace
id|yaccum.lsw
op_assign
l_int|0
suffix:semicolon
id|XSIG_LL
c_func
(paren
id|yaccum
)paren
op_assign
id|significand
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|yaccum
)paren
suffix:semicolon
id|expon_expon
op_add_assign
id|round_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
r_if
c_cond
(paren
id|accumulator.msw
op_eq
l_int|0
)paren
(brace
id|FPU_copy_to_reg1
c_func
(paren
op_amp
id|CONST_Z
comma
id|TAG_Zero
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|significand
c_func
(paren
id|st1_ptr
)paren
op_assign
id|XSIG_LL
c_func
(paren
id|accumulator
)paren
suffix:semicolon
id|setexponent16
c_func
(paren
id|st1_ptr
comma
id|expon_expon
op_plus
id|exponent16
c_func
(paren
id|st1_ptr
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|tag
op_assign
id|FPU_round
c_func
(paren
id|st1_ptr
comma
l_int|1
comma
l_int|0
comma
id|FULL_PRECISION
comma
id|sign
op_xor
id|st1_sign
)paren
suffix:semicolon
id|FPU_settagi
c_func
(paren
l_int|1
comma
id|tag
)paren
suffix:semicolon
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* 80486 appears to always do this */
r_return
suffix:semicolon
)brace
multiline_comment|/*--- poly_l2p1() -----------------------------------------------------------+&n; |   Base 2 logarithm by a polynomial approximation.                         |&n; |   log2(x+1)                                                               |&n; +---------------------------------------------------------------------------*/
DECL|function|poly_l2p1
r_int
id|poly_l2p1
c_func
(paren
id|u_char
id|sign0
comma
id|u_char
id|sign1
comma
id|FPU_REG
op_star
id|st0_ptr
comma
id|FPU_REG
op_star
id|st1_ptr
comma
id|FPU_REG
op_star
id|dest
)paren
(brace
id|u_char
id|tag
suffix:semicolon
r_int
r_int
id|exponent
suffix:semicolon
id|Xsig
id|accumulator
comma
id|yaccum
suffix:semicolon
r_if
c_cond
(paren
id|exponent16
c_func
(paren
id|st0_ptr
)paren
OL
l_int|0
)paren
(brace
id|log2_kernel
c_func
(paren
id|st0_ptr
comma
id|sign0
comma
op_amp
id|accumulator
comma
op_amp
id|exponent
)paren
suffix:semicolon
id|yaccum.lsw
op_assign
l_int|0
suffix:semicolon
id|XSIG_LL
c_func
(paren
id|yaccum
)paren
op_assign
id|significand
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|yaccum
)paren
suffix:semicolon
id|exponent
op_add_assign
id|round_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
id|exponent
op_add_assign
id|exponent16
c_func
(paren
id|st1_ptr
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|exponent
OL
id|EXP_WAY_UNDER
)paren
id|exponent
op_assign
id|EXP_WAY_UNDER
suffix:semicolon
id|significand
c_func
(paren
id|dest
)paren
op_assign
id|XSIG_LL
c_func
(paren
id|accumulator
)paren
suffix:semicolon
id|setexponent16
c_func
(paren
id|dest
comma
id|exponent
)paren
suffix:semicolon
id|tag
op_assign
id|FPU_round
c_func
(paren
id|dest
comma
l_int|1
comma
l_int|0
comma
id|FULL_PRECISION
comma
id|sign0
op_xor
id|sign1
)paren
suffix:semicolon
id|FPU_settagi
c_func
(paren
l_int|1
comma
id|tag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|TAG_Valid
)paren
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* 80486 appears to always do this */
)brace
r_else
(brace
multiline_comment|/* The magnitude of st0_ptr is far too large. */
r_if
c_cond
(paren
id|sign0
op_ne
id|SIGN_POS
)paren
(brace
multiline_comment|/* Trying to get the log of a negative number. */
macro_line|#ifdef PECULIAR_486   /* Stupid 80486 doesn&squot;t worry about log(negative). */
id|changesign
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
l_int|1
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
macro_line|#endif PECULIAR_486
)brace
multiline_comment|/* 80486 appears to do this */
r_if
c_cond
(paren
id|sign0
op_eq
id|SIGN_NEG
)paren
id|set_precision_flag_down
c_func
(paren
)paren
suffix:semicolon
r_else
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|exponent
c_func
(paren
id|dest
)paren
op_le
id|EXP_UNDER
)paren
id|EXCEPTION
c_func
(paren
id|EX_Underflow
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|HIPOWER
macro_line|#undef HIPOWER
DECL|macro|HIPOWER
mdefine_line|#define&t;HIPOWER&t;10
DECL|variable|logterms
r_static
r_const
r_int
r_int
r_int
id|logterms
(braket
id|HIPOWER
)braket
op_assign
(brace
l_int|0x2a8eca5705fc2ef0LL
comma
l_int|0xf6384ee1d01febceLL
comma
l_int|0x093bb62877cdf642LL
comma
l_int|0x006985d8a9ec439bLL
comma
l_int|0x0005212c4f55a9c8LL
comma
l_int|0x00004326a16927f0LL
comma
l_int|0x0000038d1d80a0e7LL
comma
l_int|0x0000003141cc80c6LL
comma
l_int|0x00000002b1668c9fLL
comma
l_int|0x000000002c7a46aaLL
)brace
suffix:semicolon
DECL|variable|leadterm
r_static
r_const
r_int
r_int
id|leadterm
op_assign
l_int|0xb8000000
suffix:semicolon
multiline_comment|/*--- log2_kernel() ---------------------------------------------------------+&n; |   Base 2 logarithm by a polynomial approximation.                         |&n; |   log2(x+1)                                                               |&n; +---------------------------------------------------------------------------*/
DECL|function|log2_kernel
r_static
r_void
id|log2_kernel
c_func
(paren
id|FPU_REG
r_const
op_star
id|arg
comma
id|u_char
id|argsign
comma
id|Xsig
op_star
id|accum_result
comma
r_int
r_int
op_star
id|expon
)paren
(brace
r_int
r_int
id|exponent
comma
id|adj
suffix:semicolon
r_int
r_int
r_int
id|Xsq
suffix:semicolon
id|Xsig
id|accumulator
comma
id|Numer
comma
id|Denom
comma
id|argSignif
comma
id|arg_signif
suffix:semicolon
id|exponent
op_assign
id|exponent16
c_func
(paren
id|arg
)paren
suffix:semicolon
id|Numer.lsw
op_assign
id|Denom.lsw
op_assign
l_int|0
suffix:semicolon
id|XSIG_LL
c_func
(paren
id|Numer
)paren
op_assign
id|XSIG_LL
c_func
(paren
id|Denom
)paren
op_assign
id|significand
c_func
(paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|argsign
op_eq
id|SIGN_POS
)paren
(brace
id|shr_Xsig
c_func
(paren
op_amp
id|Denom
comma
l_int|2
op_minus
(paren
l_int|1
op_plus
id|exponent
)paren
)paren
suffix:semicolon
id|Denom.msw
op_or_assign
l_int|0x80000000
suffix:semicolon
id|div_Xsig
c_func
(paren
op_amp
id|Numer
comma
op_amp
id|Denom
comma
op_amp
id|argSignif
)paren
suffix:semicolon
)brace
r_else
(brace
id|shr_Xsig
c_func
(paren
op_amp
id|Denom
comma
l_int|1
op_minus
(paren
l_int|1
op_plus
id|exponent
)paren
)paren
suffix:semicolon
id|negate_Xsig
c_func
(paren
op_amp
id|Denom
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Denom.msw
op_amp
l_int|0x80000000
)paren
(brace
id|div_Xsig
c_func
(paren
op_amp
id|Numer
comma
op_amp
id|Denom
comma
op_amp
id|argSignif
)paren
suffix:semicolon
id|exponent
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Denom must be 1.0 */
id|argSignif.lsw
op_assign
id|Numer.lsw
suffix:semicolon
id|argSignif.midw
op_assign
id|Numer.midw
suffix:semicolon
id|argSignif.msw
op_assign
id|Numer.msw
suffix:semicolon
)brace
)brace
macro_line|#ifndef PECULIAR_486
multiline_comment|/* Should check here that  |local_arg|  is within the valid range */
r_if
c_cond
(paren
id|exponent
op_ge
op_minus
l_int|2
)paren
(brace
r_if
c_cond
(paren
(paren
id|exponent
OG
op_minus
l_int|2
)paren
op_logical_or
(paren
id|argSignif.msw
OG
(paren
r_int
)paren
l_int|0xafb0ccc0
)paren
)paren
(brace
multiline_comment|/* The argument is too large */
)brace
)brace
macro_line|#endif PECULIAR_486
id|arg_signif.lsw
op_assign
id|argSignif.lsw
suffix:semicolon
id|XSIG_LL
c_func
(paren
id|arg_signif
)paren
op_assign
id|XSIG_LL
c_func
(paren
id|argSignif
)paren
suffix:semicolon
id|adj
op_assign
id|norm_Xsig
c_func
(paren
op_amp
id|argSignif
)paren
suffix:semicolon
id|accumulator.lsw
op_assign
id|argSignif.lsw
suffix:semicolon
id|XSIG_LL
c_func
(paren
id|accumulator
)paren
op_assign
id|XSIG_LL
c_func
(paren
id|argSignif
)paren
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|accumulator
)paren
suffix:semicolon
id|shr_Xsig
c_func
(paren
op_amp
id|accumulator
comma
l_int|2
op_star
(paren
op_minus
l_int|1
op_minus
(paren
l_int|1
op_plus
id|exponent
op_plus
id|adj
)paren
)paren
)paren
suffix:semicolon
id|Xsq
op_assign
id|XSIG_LL
c_func
(paren
id|accumulator
)paren
suffix:semicolon
r_if
c_cond
(paren
id|accumulator.lsw
op_amp
l_int|0x80000000
)paren
id|Xsq
op_increment
suffix:semicolon
id|accumulator.msw
op_assign
id|accumulator.midw
op_assign
id|accumulator.lsw
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do the basic fixed point polynomial evaluation */
id|polynomial_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|Xsq
comma
id|logterms
comma
id|HIPOWER
op_minus
l_int|1
)paren
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|argSignif
)paren
suffix:semicolon
id|shr_Xsig
c_func
(paren
op_amp
id|accumulator
comma
l_int|6
op_minus
id|adj
)paren
suffix:semicolon
id|mul32_Xsig
c_func
(paren
op_amp
id|arg_signif
comma
id|leadterm
)paren
suffix:semicolon
id|add_two_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|arg_signif
comma
op_amp
id|exponent
)paren
suffix:semicolon
op_star
id|expon
op_assign
id|exponent
op_plus
l_int|1
suffix:semicolon
id|accum_result-&gt;lsw
op_assign
id|accumulator.lsw
suffix:semicolon
id|accum_result-&gt;midw
op_assign
id|accumulator.midw
suffix:semicolon
id|accum_result-&gt;msw
op_assign
id|accumulator.msw
suffix:semicolon
)brace
eof
