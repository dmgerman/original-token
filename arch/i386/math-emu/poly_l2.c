multiline_comment|/*---------------------------------------------------------------------------+&n; |  poly_l2.c                                                                |&n; |                                                                           |&n; | Compute the base 2 log of a FPU_REG, using a polynomial approximation.    |&n; |                                                                           |&n; | Copyright (C) 1992,1993,1994                                              |&n; |                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,      |&n; |                       Australia.  E-mail   billm@vaxc.cc.monash.edu.au    |&n; |                                                                           |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;reg_constant.h&quot;
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &quot;control_w.h&quot;
macro_line|#include &quot;poly.h&quot;
r_static
r_void
id|log2_kernel
c_func
(paren
id|FPU_REG
r_const
op_star
id|arg
comma
id|Xsig
op_star
id|accum_result
comma
r_int
r_int
op_star
id|expon
)paren
suffix:semicolon
multiline_comment|/*--- poly_l2() -------------------------------------------------------------+&n; |   Base 2 logarithm by a polynomial approximation.                         |&n; +---------------------------------------------------------------------------*/
DECL|function|poly_l2
r_void
id|poly_l2
c_func
(paren
id|FPU_REG
r_const
op_star
id|arg
comma
id|FPU_REG
r_const
op_star
id|y
comma
id|FPU_REG
op_star
id|result
)paren
(brace
r_int
r_int
id|exponent
comma
id|expon
comma
id|expon_expon
suffix:semicolon
id|Xsig
id|accumulator
comma
id|expon_accum
comma
id|yaccum
suffix:semicolon
r_char
id|sign
suffix:semicolon
id|FPU_REG
id|x
suffix:semicolon
id|exponent
op_assign
id|arg-&gt;exp
op_minus
id|EXP_BIAS
suffix:semicolon
multiline_comment|/* From arg, make a number &gt; sqrt(2)/2 and &lt; sqrt(2) */
r_if
c_cond
(paren
id|arg-&gt;sigh
OG
(paren
r_int
)paren
l_int|0xb504f334
)paren
(brace
multiline_comment|/* Treat as  sqrt(2)/2 &lt; arg &lt; 1 */
id|significand
c_func
(paren
op_amp
id|x
)paren
op_assign
op_minus
id|significand
c_func
(paren
id|arg
)paren
suffix:semicolon
id|x.sign
op_assign
id|SIGN_NEG
suffix:semicolon
id|x.tag
op_assign
id|TW_Valid
suffix:semicolon
id|x.exp
op_assign
id|EXP_BIAS
op_minus
l_int|1
suffix:semicolon
id|exponent
op_increment
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|x
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Treat as  1 &lt;= arg &lt; sqrt(2) */
id|x.sigh
op_assign
id|arg-&gt;sigh
op_minus
l_int|0x80000000
suffix:semicolon
id|x.sigl
op_assign
id|arg-&gt;sigl
suffix:semicolon
id|x.sign
op_assign
id|SIGN_POS
suffix:semicolon
id|x.tag
op_assign
id|TW_Valid
suffix:semicolon
id|x.exp
op_assign
id|EXP_BIAS
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|x
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|x.tag
op_eq
id|TW_Zero
)paren
(brace
id|expon
op_assign
l_int|0
suffix:semicolon
id|accumulator.msw
op_assign
id|accumulator.midw
op_assign
id|accumulator.lsw
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|log2_kernel
c_func
(paren
op_amp
id|x
comma
op_amp
id|accumulator
comma
op_amp
id|expon
)paren
suffix:semicolon
)brace
id|sign
op_assign
id|exponent
OL
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sign
)paren
id|exponent
op_assign
op_minus
id|exponent
suffix:semicolon
id|expon_accum.msw
op_assign
id|exponent
suffix:semicolon
id|expon_accum.midw
op_assign
id|expon_accum.lsw
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|exponent
)paren
(brace
id|expon_expon
op_assign
l_int|31
op_plus
id|norm_Xsig
c_func
(paren
op_amp
id|expon_accum
)paren
suffix:semicolon
id|shr_Xsig
c_func
(paren
op_amp
id|accumulator
comma
id|expon_expon
op_minus
id|expon
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sign
op_xor
(paren
id|x.sign
op_eq
id|SIGN_NEG
)paren
)paren
id|negate_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
id|add_Xsig_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|expon_accum
)paren
suffix:semicolon
)brace
r_else
(brace
id|expon_expon
op_assign
id|expon
suffix:semicolon
id|sign
op_assign
id|x.sign
suffix:semicolon
)brace
id|yaccum.lsw
op_assign
l_int|0
suffix:semicolon
id|XSIG_LL
c_func
(paren
id|yaccum
)paren
op_assign
id|significand
c_func
(paren
id|y
)paren
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|yaccum
)paren
suffix:semicolon
id|expon_expon
op_add_assign
id|round_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
r_if
c_cond
(paren
id|accumulator.msw
op_eq
l_int|0
)paren
(brace
id|reg_move
c_func
(paren
op_amp
id|CONST_Z
comma
id|y
)paren
suffix:semicolon
)brace
r_else
(brace
id|result-&gt;exp
op_assign
id|expon_expon
op_plus
id|y-&gt;exp
op_plus
l_int|1
suffix:semicolon
id|significand
c_func
(paren
id|result
)paren
op_assign
id|XSIG_LL
c_func
(paren
id|accumulator
)paren
suffix:semicolon
id|result-&gt;tag
op_assign
id|TW_Valid
suffix:semicolon
multiline_comment|/* set the tags to Valid */
id|result-&gt;sign
op_assign
id|sign
op_xor
id|y-&gt;sign
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*--- poly_l2p1() -----------------------------------------------------------+&n; |   Base 2 logarithm by a polynomial approximation.                         |&n; |   log2(x+1)                                                               |&n; +---------------------------------------------------------------------------*/
DECL|function|poly_l2p1
r_int
id|poly_l2p1
c_func
(paren
id|FPU_REG
r_const
op_star
id|arg
comma
id|FPU_REG
r_const
op_star
id|y
comma
id|FPU_REG
op_star
id|result
)paren
(brace
r_char
id|sign
suffix:semicolon
r_int
r_int
id|exponent
suffix:semicolon
id|Xsig
id|accumulator
comma
id|yaccum
suffix:semicolon
id|sign
op_assign
id|arg-&gt;sign
suffix:semicolon
r_if
c_cond
(paren
id|arg-&gt;exp
OL
id|EXP_BIAS
)paren
(brace
id|log2_kernel
c_func
(paren
id|arg
comma
op_amp
id|accumulator
comma
op_amp
id|exponent
)paren
suffix:semicolon
id|yaccum.lsw
op_assign
l_int|0
suffix:semicolon
id|XSIG_LL
c_func
(paren
id|yaccum
)paren
op_assign
id|significand
c_func
(paren
id|y
)paren
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|yaccum
)paren
suffix:semicolon
id|exponent
op_add_assign
id|round_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
id|result-&gt;exp
op_assign
id|exponent
op_plus
id|y-&gt;exp
op_plus
l_int|1
suffix:semicolon
id|significand
c_func
(paren
id|result
)paren
op_assign
id|XSIG_LL
c_func
(paren
id|accumulator
)paren
suffix:semicolon
id|result-&gt;tag
op_assign
id|TW_Valid
suffix:semicolon
multiline_comment|/* set the tags to Valid */
id|result-&gt;sign
op_assign
id|sign
op_xor
id|y-&gt;sign
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The magnitude of arg is far too large. */
id|reg_move
c_func
(paren
id|y
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sign
op_ne
id|SIGN_POS
)paren
(brace
multiline_comment|/* Trying to get the log of a negative number. */
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
DECL|macro|HIPOWER
macro_line|#undef HIPOWER
DECL|macro|HIPOWER
mdefine_line|#define&t;HIPOWER&t;10
DECL|variable|logterms
r_static
r_const
r_int
r_int
r_int
id|logterms
(braket
id|HIPOWER
)braket
op_assign
(brace
l_int|0x2a8eca5705fc2ef0LL
comma
l_int|0xf6384ee1d01febceLL
comma
l_int|0x093bb62877cdf642LL
comma
l_int|0x006985d8a9ec439bLL
comma
l_int|0x0005212c4f55a9c8LL
comma
l_int|0x00004326a16927f0LL
comma
l_int|0x0000038d1d80a0e7LL
comma
l_int|0x0000003141cc80c6LL
comma
l_int|0x00000002b1668c9fLL
comma
l_int|0x000000002c7a46aaLL
)brace
suffix:semicolon
DECL|variable|leadterm
r_static
r_const
r_int
r_int
id|leadterm
op_assign
l_int|0xb8000000
suffix:semicolon
multiline_comment|/*--- log2_kernel() ---------------------------------------------------------+&n; |   Base 2 logarithm by a polynomial approximation.                         |&n; |   log2(x+1)                                                               |&n; +---------------------------------------------------------------------------*/
DECL|function|log2_kernel
r_static
r_void
id|log2_kernel
c_func
(paren
id|FPU_REG
r_const
op_star
id|arg
comma
id|Xsig
op_star
id|accum_result
comma
r_int
r_int
op_star
id|expon
)paren
(brace
r_char
id|sign
suffix:semicolon
r_int
r_int
id|exponent
comma
id|adj
suffix:semicolon
r_int
r_int
r_int
id|Xsq
suffix:semicolon
id|Xsig
id|accumulator
comma
id|Numer
comma
id|Denom
comma
id|argSignif
comma
id|arg_signif
suffix:semicolon
id|sign
op_assign
id|arg-&gt;sign
suffix:semicolon
id|exponent
op_assign
id|arg-&gt;exp
op_minus
id|EXP_BIAS
suffix:semicolon
id|Numer.lsw
op_assign
id|Denom.lsw
op_assign
l_int|0
suffix:semicolon
id|XSIG_LL
c_func
(paren
id|Numer
)paren
op_assign
id|XSIG_LL
c_func
(paren
id|Denom
)paren
op_assign
id|significand
c_func
(paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sign
op_eq
id|SIGN_POS
)paren
(brace
id|shr_Xsig
c_func
(paren
op_amp
id|Denom
comma
l_int|2
op_minus
(paren
l_int|1
op_plus
id|exponent
)paren
)paren
suffix:semicolon
id|Denom.msw
op_or_assign
l_int|0x80000000
suffix:semicolon
id|div_Xsig
c_func
(paren
op_amp
id|Numer
comma
op_amp
id|Denom
comma
op_amp
id|argSignif
)paren
suffix:semicolon
)brace
r_else
(brace
id|shr_Xsig
c_func
(paren
op_amp
id|Denom
comma
l_int|1
op_minus
(paren
l_int|1
op_plus
id|exponent
)paren
)paren
suffix:semicolon
id|negate_Xsig
c_func
(paren
op_amp
id|Denom
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Denom.msw
op_amp
l_int|0x80000000
)paren
(brace
id|div_Xsig
c_func
(paren
op_amp
id|Numer
comma
op_amp
id|Denom
comma
op_amp
id|argSignif
)paren
suffix:semicolon
id|exponent
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Denom must be 1.0 */
id|argSignif.lsw
op_assign
id|Numer.lsw
suffix:semicolon
id|argSignif.midw
op_assign
id|Numer.midw
suffix:semicolon
id|argSignif.msw
op_assign
id|Numer.msw
suffix:semicolon
)brace
)brace
macro_line|#ifndef PECULIAR_486
multiline_comment|/* Should check here that  |local_arg|  is within the valid range */
r_if
c_cond
(paren
id|exponent
op_ge
op_minus
l_int|2
)paren
(brace
r_if
c_cond
(paren
(paren
id|exponent
OG
op_minus
l_int|2
)paren
op_logical_or
(paren
id|argSignif.msw
OG
(paren
r_int
)paren
l_int|0xafb0ccc0
)paren
)paren
(brace
multiline_comment|/* The argument is too large */
)brace
)brace
macro_line|#endif PECULIAR_486
id|arg_signif.lsw
op_assign
id|argSignif.lsw
suffix:semicolon
id|XSIG_LL
c_func
(paren
id|arg_signif
)paren
op_assign
id|XSIG_LL
c_func
(paren
id|argSignif
)paren
suffix:semicolon
id|adj
op_assign
id|norm_Xsig
c_func
(paren
op_amp
id|argSignif
)paren
suffix:semicolon
id|accumulator.lsw
op_assign
id|argSignif.lsw
suffix:semicolon
id|XSIG_LL
c_func
(paren
id|accumulator
)paren
op_assign
id|XSIG_LL
c_func
(paren
id|argSignif
)paren
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|accumulator
)paren
suffix:semicolon
id|shr_Xsig
c_func
(paren
op_amp
id|accumulator
comma
l_int|2
op_star
(paren
op_minus
l_int|1
op_minus
(paren
l_int|1
op_plus
id|exponent
op_plus
id|adj
)paren
)paren
)paren
suffix:semicolon
id|Xsq
op_assign
id|XSIG_LL
c_func
(paren
id|accumulator
)paren
suffix:semicolon
r_if
c_cond
(paren
id|accumulator.lsw
op_amp
l_int|0x80000000
)paren
id|Xsq
op_increment
suffix:semicolon
id|accumulator.msw
op_assign
id|accumulator.midw
op_assign
id|accumulator.lsw
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Do the basic fixed point polynomial evaluation */
id|polynomial_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|Xsq
comma
id|logterms
comma
id|HIPOWER
op_minus
l_int|1
)paren
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|argSignif
)paren
suffix:semicolon
id|shr_Xsig
c_func
(paren
op_amp
id|accumulator
comma
l_int|6
op_minus
id|adj
)paren
suffix:semicolon
id|mul32_Xsig
c_func
(paren
op_amp
id|arg_signif
comma
id|leadterm
)paren
suffix:semicolon
id|add_two_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|arg_signif
comma
op_amp
id|exponent
)paren
suffix:semicolon
op_star
id|expon
op_assign
id|exponent
op_plus
l_int|1
suffix:semicolon
id|accum_result-&gt;lsw
op_assign
id|accumulator.lsw
suffix:semicolon
id|accum_result-&gt;midw
op_assign
id|accumulator.midw
suffix:semicolon
id|accum_result-&gt;msw
op_assign
id|accumulator.msw
suffix:semicolon
)brace
eof
