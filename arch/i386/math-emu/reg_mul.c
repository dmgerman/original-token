multiline_comment|/*---------------------------------------------------------------------------+&n; |  reg_mul.c                                                                |&n; |                                                                           |&n; | Multiply one FPU_REG by another, put the result in a destination FPU_REG. |&n; |                                                                           |&n; | Copyright (C) 1992,1993,1997                                              |&n; |                  W. Metzenthen, 22 Parker St, Ormond, Vic 3163, Australia |&n; |                  E-mail   billm@suburbia.net                              |&n; |                                                                           |&n; | Returns the tag of the result if no exceptions or errors occurred.        |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
multiline_comment|/*---------------------------------------------------------------------------+&n; | The destination may be any FPU_REG, including one of the source FPU_REGs. |&n; +---------------------------------------------------------------------------*/
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;reg_constant.h&quot;
macro_line|#include &quot;fpu_system.h&quot;
multiline_comment|/*&n;  Multiply two registers to give a register result.&n;  The sources are st(deststnr) and (b,tagb,signb).&n;  The destination is st(deststnr).&n;  */
multiline_comment|/* This routine must be called with non-empty source registers */
DECL|function|FPU_mul
r_int
id|FPU_mul
c_func
(paren
id|FPU_REG
r_const
op_star
id|b
comma
id|u_char
id|tagb
comma
r_int
id|deststnr
comma
r_int
id|control_w
)paren
(brace
id|FPU_REG
op_star
id|a
op_assign
op_amp
id|st
c_func
(paren
id|deststnr
)paren
suffix:semicolon
id|FPU_REG
op_star
id|dest
op_assign
id|a
suffix:semicolon
id|u_char
id|taga
op_assign
id|FPU_gettagi
c_func
(paren
id|deststnr
)paren
suffix:semicolon
id|u_char
id|saved_sign
op_assign
id|getsign
c_func
(paren
id|dest
)paren
suffix:semicolon
id|u_char
id|sign
op_assign
(paren
id|getsign
c_func
(paren
id|a
)paren
op_xor
id|getsign
c_func
(paren
id|b
)paren
)paren
suffix:semicolon
r_int
id|tag
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|taga
op_or
id|tagb
)paren
)paren
(brace
multiline_comment|/* Both regs Valid, this should be the most common case. */
id|tag
op_assign
id|FPU_u_mul
c_func
(paren
id|a
comma
id|b
comma
id|dest
comma
id|control_w
comma
id|sign
comma
id|exponent
c_func
(paren
id|a
)paren
op_plus
id|exponent
c_func
(paren
id|b
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
OL
l_int|0
)paren
(brace
id|setsign
c_func
(paren
id|dest
comma
id|saved_sign
)paren
suffix:semicolon
r_return
id|tag
suffix:semicolon
)brace
id|FPU_settagi
c_func
(paren
id|deststnr
comma
id|tag
)paren
suffix:semicolon
r_return
id|tag
suffix:semicolon
)brace
r_if
c_cond
(paren
id|taga
op_eq
id|TAG_Special
)paren
id|taga
op_assign
id|FPU_Special
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tagb
op_eq
id|TAG_Special
)paren
id|tagb
op_assign
id|FPU_Special
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|taga
op_eq
id|TAG_Valid
)paren
op_logical_and
(paren
id|tagb
op_eq
id|TW_Denormal
)paren
)paren
op_logical_or
(paren
(paren
id|taga
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|tagb
op_eq
id|TAG_Valid
)paren
)paren
op_logical_or
(paren
(paren
id|taga
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|tagb
op_eq
id|TW_Denormal
)paren
)paren
)paren
(brace
id|FPU_REG
id|x
comma
id|y
suffix:semicolon
r_if
c_cond
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
id|FPU_Exception
suffix:semicolon
id|FPU_to_exp16
c_func
(paren
id|a
comma
op_amp
id|x
)paren
suffix:semicolon
id|FPU_to_exp16
c_func
(paren
id|b
comma
op_amp
id|y
)paren
suffix:semicolon
id|tag
op_assign
id|FPU_u_mul
c_func
(paren
op_amp
id|x
comma
op_amp
id|y
comma
id|dest
comma
id|control_w
comma
id|sign
comma
id|exponent16
c_func
(paren
op_amp
id|x
)paren
op_plus
id|exponent16
c_func
(paren
op_amp
id|y
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
OL
l_int|0
)paren
(brace
id|setsign
c_func
(paren
id|dest
comma
id|saved_sign
)paren
suffix:semicolon
r_return
id|tag
suffix:semicolon
)brace
id|FPU_settagi
c_func
(paren
id|deststnr
comma
id|tag
)paren
suffix:semicolon
r_return
id|tag
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|taga
op_le
id|TW_Denormal
)paren
op_logical_and
(paren
id|tagb
op_le
id|TW_Denormal
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|tagb
op_eq
id|TW_Denormal
)paren
op_logical_or
(paren
id|taga
op_eq
id|TW_Denormal
)paren
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
id|FPU_Exception
suffix:semicolon
multiline_comment|/* Must have either both arguments == zero, or&n;&t; one valid and the other zero.&n;&t; The result is therefore zero. */
id|FPU_copy_to_regi
c_func
(paren
op_amp
id|CONST_Z
comma
id|TAG_Zero
comma
id|deststnr
)paren
suffix:semicolon
multiline_comment|/* The 80486 book says that the answer is +0, but a real&n;&t; 80486 behaves this way.&n;&t; IEEE-754 apparently says it should be this way. */
id|setsign
c_func
(paren
id|dest
comma
id|sign
)paren
suffix:semicolon
r_return
id|TAG_Zero
suffix:semicolon
)brace
multiline_comment|/* Must have infinities, NaNs, etc */
r_else
r_if
c_cond
(paren
(paren
id|taga
op_eq
id|TW_NaN
)paren
op_logical_or
(paren
id|tagb
op_eq
id|TW_NaN
)paren
)paren
(brace
r_return
id|real_2op_NaN
c_func
(paren
id|b
comma
id|tagb
comma
id|deststnr
comma
op_amp
id|st
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|taga
op_eq
id|TW_Infinity
)paren
op_logical_and
(paren
id|tagb
op_eq
id|TAG_Zero
)paren
)paren
op_logical_or
(paren
(paren
id|tagb
op_eq
id|TW_Infinity
)paren
op_logical_and
(paren
id|taga
op_eq
id|TAG_Zero
)paren
)paren
)paren
(brace
r_return
id|arith_invalid
c_func
(paren
id|deststnr
)paren
suffix:semicolon
multiline_comment|/* Zero*Infinity is invalid */
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|taga
op_eq
id|TW_Denormal
)paren
op_logical_or
(paren
id|tagb
op_eq
id|TW_Denormal
)paren
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
(brace
r_return
id|FPU_Exception
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|taga
op_eq
id|TW_Infinity
)paren
(brace
id|FPU_copy_to_regi
c_func
(paren
id|a
comma
id|TAG_Special
comma
id|deststnr
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|dest
comma
id|sign
)paren
suffix:semicolon
r_return
id|TAG_Special
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tagb
op_eq
id|TW_Infinity
)paren
(brace
id|FPU_copy_to_regi
c_func
(paren
id|b
comma
id|TAG_Special
comma
id|deststnr
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|dest
comma
id|sign
)paren
suffix:semicolon
r_return
id|TAG_Special
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
r_else
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x102
)paren
suffix:semicolon
r_return
id|FPU_Exception
suffix:semicolon
)brace
macro_line|#endif PARANOID
)brace
eof
