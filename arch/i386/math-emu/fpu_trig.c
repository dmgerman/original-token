multiline_comment|/*---------------------------------------------------------------------------+&n; |  fpu_trig.c                                                               |&n; |                                                                           |&n; | Implementation of the FPU &quot;transcendental&quot; functions.                     |&n; |                                                                           |&n; | Copyright (C) 1992,1993,1994,1997,1999                                    |&n; |                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,      |&n; |                       Australia.  E-mail   billm@melbpc.org.au            |&n; |                                                                           |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
macro_line|#include &quot;fpu_system.h&quot;
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &quot;status_w.h&quot;
macro_line|#include &quot;control_w.h&quot;
macro_line|#include &quot;reg_constant.h&quot;&t;
r_static
r_void
id|rem_kernel
c_func
(paren
r_int
r_int
r_int
id|st0
comma
r_int
r_int
r_int
op_star
id|y
comma
r_int
r_int
r_int
id|st1
comma
r_int
r_int
r_int
id|q
comma
r_int
id|n
)paren
suffix:semicolon
DECL|macro|BETTER_THAN_486
mdefine_line|#define BETTER_THAN_486
DECL|macro|FCOS
mdefine_line|#define FCOS  4
multiline_comment|/* Used only by fptan, fsin, fcos, and fsincos. */
multiline_comment|/* This routine produces very accurate results, similar to&n;   using a value of pi with more than 128 bits precision. */
multiline_comment|/* Limited measurements show no results worse than 64 bit precision&n;   except for the results for arguments close to 2^63, where the&n;   precision of the result sometimes degrades to about 63.9 bits */
DECL|function|trig_arg
r_static
r_int
id|trig_arg
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
r_int
id|even
)paren
(brace
id|FPU_REG
id|tmp
suffix:semicolon
id|u_char
id|tmptag
suffix:semicolon
r_int
r_int
r_int
id|q
suffix:semicolon
r_int
id|old_cw
op_assign
id|control_word
comma
id|saved_status
op_assign
id|partial_status
suffix:semicolon
r_int
id|tag
comma
id|st0_tag
op_assign
id|TAG_Valid
suffix:semicolon
r_if
c_cond
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
op_ge
l_int|63
)paren
(brace
id|partial_status
op_or_assign
id|SW_C2
suffix:semicolon
multiline_comment|/* Reduction incomplete. */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|control_word
op_and_assign
op_complement
id|CW_RC
suffix:semicolon
id|control_word
op_or_assign
id|RC_CHOP
suffix:semicolon
id|setpositive
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
id|tag
op_assign
id|FPU_u_div
c_func
(paren
id|st0_ptr
comma
op_amp
id|CONST_PI2
comma
op_amp
id|tmp
comma
id|PR_64_BITS
op_or
id|RC_CHOP
op_or
l_int|0x3f
comma
id|SIGN_POS
)paren
suffix:semicolon
id|FPU_round_to_int
c_func
(paren
op_amp
id|tmp
comma
id|tag
)paren
suffix:semicolon
multiline_comment|/* Fortunately, this can&squot;t overflow&n;&t;&t;&t;&t;   to 2^64 */
id|q
op_assign
id|significand
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
)paren
(brace
id|rem_kernel
c_func
(paren
id|significand
c_func
(paren
id|st0_ptr
)paren
comma
op_amp
id|significand
c_func
(paren
op_amp
id|tmp
)paren
comma
id|significand
c_func
(paren
op_amp
id|CONST_PI2
)paren
comma
id|q
comma
id|exponent
c_func
(paren
id|st0_ptr
)paren
op_minus
id|exponent
c_func
(paren
op_amp
id|CONST_PI2
)paren
)paren
suffix:semicolon
id|setexponent16
c_func
(paren
op_amp
id|tmp
comma
id|exponent
c_func
(paren
op_amp
id|CONST_PI2
)paren
)paren
suffix:semicolon
id|st0_tag
op_assign
id|FPU_normalize
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|tmp
comma
id|st0_tag
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|even
op_logical_and
op_logical_neg
(paren
id|q
op_amp
l_int|1
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|even
op_logical_and
(paren
id|q
op_amp
l_int|1
)paren
)paren
)paren
(brace
id|st0_tag
op_assign
id|FPU_sub
c_func
(paren
id|REV
op_or
id|LOADED
op_or
id|TAG_Valid
comma
(paren
r_int
)paren
op_amp
id|CONST_PI2
comma
id|FULL_PRECISION
)paren
suffix:semicolon
macro_line|#ifdef BETTER_THAN_486
multiline_comment|/* So far, the results are exact but based upon a 64 bit&n;&t; precision approximation to pi/2. The technique used&n;&t; now is equivalent to using an approximation to pi/2 which&n;&t; is accurate to about 128 bits. */
r_if
c_cond
(paren
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
op_le
id|exponent
c_func
(paren
op_amp
id|CONST_PI2extra
)paren
op_plus
l_int|64
)paren
op_logical_or
(paren
id|q
OG
l_int|1
)paren
)paren
(brace
multiline_comment|/* This code gives the effect of having pi/2 to better than&n;&t;     128 bits precision. */
id|significand
c_func
(paren
op_amp
id|tmp
)paren
op_assign
id|q
op_plus
l_int|1
suffix:semicolon
id|setexponent16
c_func
(paren
op_amp
id|tmp
comma
l_int|63
)paren
suffix:semicolon
id|FPU_normalize
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|tmptag
op_assign
id|FPU_u_mul
c_func
(paren
op_amp
id|CONST_PI2extra
comma
op_amp
id|tmp
comma
op_amp
id|tmp
comma
id|FULL_PRECISION
comma
id|SIGN_POS
comma
id|exponent
c_func
(paren
op_amp
id|CONST_PI2extra
)paren
op_plus
id|exponent
c_func
(paren
op_amp
id|tmp
)paren
)paren
suffix:semicolon
id|setsign
c_func
(paren
op_amp
id|tmp
comma
id|getsign
c_func
(paren
op_amp
id|CONST_PI2extra
)paren
)paren
suffix:semicolon
id|st0_tag
op_assign
id|FPU_add
c_func
(paren
op_amp
id|tmp
comma
id|tmptag
comma
l_int|0
comma
id|FULL_PRECISION
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signnegative
c_func
(paren
id|st0_ptr
)paren
)paren
(brace
multiline_comment|/* CONST_PI2extra is negative, so the result of the addition&n;&t;&t; can be negative. This means that the argument is actually&n;&t;&t; in a different quadrant. The correction is always &lt; pi/2,&n;&t;&t; so it can&squot;t overflow into yet another quadrant. */
id|setpositive
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
id|q
op_increment
suffix:semicolon
)brace
)brace
macro_line|#endif BETTER_THAN_486
)brace
macro_line|#ifdef BETTER_THAN_486
r_else
(brace
multiline_comment|/* So far, the results are exact but based upon a 64 bit&n;&t; precision approximation to pi/2. The technique used&n;&t; now is equivalent to using an approximation to pi/2 which&n;&t; is accurate to about 128 bits. */
r_if
c_cond
(paren
(paren
(paren
id|q
OG
l_int|0
)paren
op_logical_and
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
op_le
id|exponent
c_func
(paren
op_amp
id|CONST_PI2extra
)paren
op_plus
l_int|64
)paren
)paren
op_logical_or
(paren
id|q
OG
l_int|1
)paren
)paren
(brace
multiline_comment|/* This code gives the effect of having p/2 to better than&n;&t;     128 bits precision. */
id|significand
c_func
(paren
op_amp
id|tmp
)paren
op_assign
id|q
suffix:semicolon
id|setexponent16
c_func
(paren
op_amp
id|tmp
comma
l_int|63
)paren
suffix:semicolon
id|FPU_normalize
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
multiline_comment|/* This must return TAG_Valid */
id|tmptag
op_assign
id|FPU_u_mul
c_func
(paren
op_amp
id|CONST_PI2extra
comma
op_amp
id|tmp
comma
op_amp
id|tmp
comma
id|FULL_PRECISION
comma
id|SIGN_POS
comma
id|exponent
c_func
(paren
op_amp
id|CONST_PI2extra
)paren
op_plus
id|exponent
c_func
(paren
op_amp
id|tmp
)paren
)paren
suffix:semicolon
id|setsign
c_func
(paren
op_amp
id|tmp
comma
id|getsign
c_func
(paren
op_amp
id|CONST_PI2extra
)paren
)paren
suffix:semicolon
id|st0_tag
op_assign
id|FPU_sub
c_func
(paren
id|LOADED
op_or
(paren
id|tmptag
op_amp
l_int|0x0f
)paren
comma
(paren
r_int
)paren
op_amp
id|tmp
comma
id|FULL_PRECISION
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
op_eq
id|exponent
c_func
(paren
op_amp
id|CONST_PI2
)paren
)paren
op_logical_and
(paren
(paren
id|st0_ptr-&gt;sigh
OG
id|CONST_PI2.sigh
)paren
op_logical_or
(paren
(paren
id|st0_ptr-&gt;sigh
op_eq
id|CONST_PI2.sigh
)paren
op_logical_and
(paren
id|st0_ptr-&gt;sigl
OG
id|CONST_PI2.sigl
)paren
)paren
)paren
)paren
(brace
multiline_comment|/* CONST_PI2extra is negative, so the result of the&n;&t;&t; subtraction can be larger than pi/2. This means&n;&t;&t; that the argument is actually in a different quadrant.&n;&t;&t; The correction is always &lt; pi/2, so it can&squot;t overflow&n;&t;&t; into yet another quadrant. */
id|st0_tag
op_assign
id|FPU_sub
c_func
(paren
id|REV
op_or
id|LOADED
op_or
id|TAG_Valid
comma
(paren
r_int
)paren
op_amp
id|CONST_PI2
comma
id|FULL_PRECISION
)paren
suffix:semicolon
id|q
op_increment
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif BETTER_THAN_486
id|FPU_settag0
c_func
(paren
id|st0_tag
)paren
suffix:semicolon
id|control_word
op_assign
id|old_cw
suffix:semicolon
id|partial_status
op_assign
id|saved_status
op_amp
op_complement
id|SW_C2
suffix:semicolon
multiline_comment|/* Reduction complete. */
r_return
(paren
id|q
op_amp
l_int|3
)paren
op_or
id|even
suffix:semicolon
)brace
multiline_comment|/* Convert a long to register */
DECL|function|convert_l2reg
r_static
r_void
id|convert_l2reg
c_func
(paren
r_int
r_const
op_star
id|arg
comma
r_int
id|deststnr
)paren
(brace
r_int
id|tag
suffix:semicolon
r_int
id|num
op_assign
op_star
id|arg
suffix:semicolon
id|u_char
id|sign
suffix:semicolon
id|FPU_REG
op_star
id|dest
op_assign
op_amp
id|st
c_func
(paren
id|deststnr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num
op_eq
l_int|0
)paren
(brace
id|FPU_copy_to_regi
c_func
(paren
op_amp
id|CONST_Z
comma
id|TAG_Zero
comma
id|deststnr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|num
OG
l_int|0
)paren
(brace
id|sign
op_assign
id|SIGN_POS
suffix:semicolon
)brace
r_else
(brace
id|num
op_assign
op_minus
id|num
suffix:semicolon
id|sign
op_assign
id|SIGN_NEG
suffix:semicolon
)brace
id|dest-&gt;sigh
op_assign
id|num
suffix:semicolon
id|dest-&gt;sigl
op_assign
l_int|0
suffix:semicolon
id|setexponent16
c_func
(paren
id|dest
comma
l_int|31
)paren
suffix:semicolon
id|tag
op_assign
id|FPU_normalize
c_func
(paren
id|dest
)paren
suffix:semicolon
id|FPU_settagi
c_func
(paren
id|deststnr
comma
id|tag
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|dest
comma
id|sign
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|single_arg_error
r_static
r_void
id|single_arg_error
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
)paren
(brace
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Empty
)paren
id|FPU_stack_underflow
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Puts a QNaN in st(0) */
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_NaN
)paren
id|real_1op_NaN
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
multiline_comment|/* return with a NaN in st(0) */
macro_line|#ifdef PARANOID
r_else
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x0112
)paren
suffix:semicolon
macro_line|#endif PARANOID
)brace
DECL|function|single_arg_2_error
r_static
r_void
id|single_arg_2_error
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
)paren
(brace
r_int
id|isNaN
suffix:semicolon
r_switch
c_cond
(paren
id|st0_tag
)paren
(brace
r_case
id|TW_NaN
suffix:colon
id|isNaN
op_assign
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
op_eq
id|EXP_OVER
)paren
op_logical_and
(paren
id|st0_ptr-&gt;sigh
op_amp
l_int|0x80000000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isNaN
op_logical_and
op_logical_neg
(paren
id|st0_ptr-&gt;sigh
op_amp
l_int|0x40000000
)paren
)paren
multiline_comment|/* Signaling ? */
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
multiline_comment|/* The masked response */
multiline_comment|/* Convert to a QNaN */
id|st0_ptr-&gt;sigh
op_or_assign
l_int|0x40000000
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|FPU_copy_to_reg0
c_func
(paren
id|st0_ptr
comma
id|TAG_Special
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|isNaN
)paren
(brace
multiline_comment|/* A QNaN */
id|push
c_func
(paren
)paren
suffix:semicolon
id|FPU_copy_to_reg0
c_func
(paren
id|st0_ptr
comma
id|TAG_Special
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* pseudoNaN or other unsupported */
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
multiline_comment|/* The masked response */
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|CONST_QNaN
comma
id|TAG_Special
)paren
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|CONST_QNaN
comma
id|TAG_Special
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
multiline_comment|/* return with a NaN in st(0) */
macro_line|#ifdef PARANOID
r_default
suffix:colon
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x0112
)paren
suffix:semicolon
macro_line|#endif PARANOID
)brace
)brace
multiline_comment|/*---------------------------------------------------------------------------*/
DECL|function|f2xm1
r_static
r_void
id|f2xm1
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|tag
)paren
(brace
id|FPU_REG
id|a
suffix:semicolon
id|clear_C1
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|TAG_Valid
)paren
(brace
multiline_comment|/* For an 80486 FPU, the result is undefined if the arg is &gt;= 1.0 */
r_if
c_cond
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
OL
l_int|0
)paren
(brace
id|denormal_arg
suffix:colon
id|FPU_to_exp16
c_func
(paren
id|st0_ptr
comma
op_amp
id|a
)paren
suffix:semicolon
multiline_comment|/* poly_2xm1(x) requires 0 &lt; st(0) &lt; 1. */
id|poly_2xm1
c_func
(paren
id|getsign
c_func
(paren
id|st0_ptr
)paren
comma
op_amp
id|a
comma
id|st0_ptr
)paren
suffix:semicolon
)brace
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* 80486 appears to always do this */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tag
op_eq
id|TAG_Zero
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|TAG_Special
)paren
id|tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|tag
)paren
(brace
r_case
id|TW_Denormal
suffix:colon
r_if
c_cond
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
r_goto
id|denormal_arg
suffix:semicolon
r_case
id|TW_Infinity
suffix:colon
r_if
c_cond
(paren
id|signnegative
c_func
(paren
id|st0_ptr
)paren
)paren
(brace
multiline_comment|/* -infinity gives -1 (p16-10) */
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|CONST_1
comma
id|TAG_Valid
)paren
suffix:semicolon
id|setnegative
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
r_default
suffix:colon
id|single_arg_error
c_func
(paren
id|st0_ptr
comma
id|tag
)paren
suffix:semicolon
)brace
)brace
DECL|function|fptan
r_static
r_void
id|fptan
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
)paren
(brace
id|FPU_REG
op_star
id|st_new_ptr
suffix:semicolon
r_int
id|q
suffix:semicolon
id|u_char
id|arg_sign
op_assign
id|getsign
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
multiline_comment|/* Stack underflow has higher priority */
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Empty
)paren
(brace
id|FPU_stack_underflow
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Puts a QNaN in st(0) */
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
id|st_new_ptr
op_assign
op_amp
id|st
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|FPU_stack_underflow
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Puts a QNaN in the new st(0) */
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|STACK_OVERFLOW
)paren
(brace
id|FPU_stack_overflow
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Valid
)paren
(brace
r_if
c_cond
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
OG
op_minus
l_int|40
)paren
(brace
r_if
c_cond
(paren
(paren
id|q
op_assign
id|trig_arg
c_func
(paren
id|st0_ptr
comma
l_int|0
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Operand is out of range */
r_return
suffix:semicolon
)brace
id|poly_tan
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|st0_ptr
comma
(paren
id|q
op_amp
l_int|1
)paren
op_xor
(paren
id|arg_sign
op_ne
l_int|0
)paren
)paren
suffix:semicolon
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* We do not really know if up or down */
)brace
r_else
(brace
multiline_comment|/* For a small arg, the result == the argument */
multiline_comment|/* Underflow may happen */
id|denormal_arg
suffix:colon
id|FPU_to_exp16
c_func
(paren
id|st0_ptr
comma
id|st0_ptr
)paren
suffix:semicolon
id|st0_tag
op_assign
id|FPU_round
c_func
(paren
id|st0_ptr
comma
l_int|1
comma
l_int|0
comma
id|FULL_PRECISION
comma
id|arg_sign
)paren
suffix:semicolon
id|FPU_settag0
c_func
(paren
id|st0_tag
)paren
suffix:semicolon
)brace
id|push
c_func
(paren
)paren
suffix:semicolon
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|CONST_1
comma
id|TAG_Valid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Zero
)paren
(brace
id|push
c_func
(paren
)paren
suffix:semicolon
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|CONST_1
comma
id|TAG_Valid
)paren
suffix:semicolon
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Special
)paren
id|st0_tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
(brace
r_if
c_cond
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
r_goto
id|denormal_arg
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Infinity
)paren
(brace
multiline_comment|/* The 80486 treats infinity as an invalid operand */
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
l_int|0
)paren
op_ge
l_int|0
)paren
(brace
id|st_new_ptr
op_assign
op_amp
id|st
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|arith_invalid
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|single_arg_2_error
c_func
(paren
id|st0_ptr
comma
id|st0_tag
)paren
suffix:semicolon
)brace
DECL|function|fxtract
r_static
r_void
id|fxtract
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
)paren
(brace
id|FPU_REG
op_star
id|st_new_ptr
suffix:semicolon
id|u_char
id|sign
suffix:semicolon
r_register
id|FPU_REG
op_star
id|st1_ptr
op_assign
id|st0_ptr
suffix:semicolon
multiline_comment|/* anticipate */
r_if
c_cond
(paren
id|STACK_OVERFLOW
)paren
(brace
id|FPU_stack_overflow
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|clear_C1
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Valid
)paren
(brace
r_int
id|e
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|sign
op_assign
id|getsign
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
id|reg_copy
c_func
(paren
id|st1_ptr
comma
id|st_new_ptr
)paren
suffix:semicolon
id|setexponent16
c_func
(paren
id|st_new_ptr
comma
id|exponent
c_func
(paren
id|st_new_ptr
)paren
)paren
suffix:semicolon
id|denormal_arg
suffix:colon
id|e
op_assign
id|exponent16
c_func
(paren
id|st_new_ptr
)paren
suffix:semicolon
id|convert_l2reg
c_func
(paren
op_amp
id|e
comma
l_int|1
)paren
suffix:semicolon
id|setexponentpos
c_func
(paren
id|st_new_ptr
comma
l_int|0
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|st_new_ptr
comma
id|sign
)paren
suffix:semicolon
id|FPU_settag0
c_func
(paren
id|TAG_Valid
)paren
suffix:semicolon
multiline_comment|/* Needed if arg was a denormal */
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Zero
)paren
(brace
id|sign
op_assign
id|getsign
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FPU_divide_by_zero
c_func
(paren
l_int|0
comma
id|SIGN_NEG
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|CONST_Z
comma
id|TAG_Zero
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|st_new_ptr
comma
id|sign
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Special
)paren
id|st0_tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
(brace
r_if
c_cond
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|sign
op_assign
id|getsign
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
id|FPU_to_exp16
c_func
(paren
id|st1_ptr
comma
id|st_new_ptr
)paren
suffix:semicolon
r_goto
id|denormal_arg
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Infinity
)paren
(brace
id|sign
op_assign
id|getsign
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
id|setpositive
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|CONST_INF
comma
id|TAG_Special
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|st_new_ptr
comma
id|sign
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_NaN
)paren
(brace
r_if
c_cond
(paren
id|real_1op_NaN
c_func
(paren
id|st0_ptr
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|FPU_copy_to_reg0
c_func
(paren
id|st0_ptr
comma
id|TAG_Special
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Empty
)paren
(brace
multiline_comment|/* Is this the correct behaviour? */
r_if
c_cond
(paren
id|control_word
op_amp
id|EX_Invalid
)paren
(brace
id|FPU_stack_underflow
c_func
(paren
)paren
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|FPU_stack_underflow
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
r_else
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x119
)paren
suffix:semicolon
macro_line|#endif PARANOID
)brace
DECL|function|fdecstp
r_static
r_void
id|fdecstp
c_func
(paren
r_void
)paren
(brace
id|clear_C1
c_func
(paren
)paren
suffix:semicolon
id|top
op_decrement
suffix:semicolon
)brace
DECL|function|fincstp
r_static
r_void
id|fincstp
c_func
(paren
r_void
)paren
(brace
id|clear_C1
c_func
(paren
)paren
suffix:semicolon
id|top
op_increment
suffix:semicolon
)brace
DECL|function|fsqrt_
r_static
r_void
id|fsqrt_
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
)paren
(brace
r_int
id|expon
suffix:semicolon
id|clear_C1
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Valid
)paren
(brace
id|u_char
id|tag
suffix:semicolon
r_if
c_cond
(paren
id|signnegative
c_func
(paren
id|st0_ptr
)paren
)paren
(brace
id|arith_invalid
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* sqrt(negative) is invalid */
r_return
suffix:semicolon
)brace
multiline_comment|/* make st(0) in  [1.0 .. 4.0) */
id|expon
op_assign
id|exponent
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
id|denormal_arg
suffix:colon
id|setexponent16
c_func
(paren
id|st0_ptr
comma
(paren
id|expon
op_amp
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* Do the computation, the sign of the result will be positive. */
id|tag
op_assign
id|wm_sqrt
c_func
(paren
id|st0_ptr
comma
l_int|0
comma
l_int|0
comma
id|control_word
comma
id|SIGN_POS
)paren
suffix:semicolon
id|addexponent
c_func
(paren
id|st0_ptr
comma
id|expon
op_rshift
l_int|1
)paren
suffix:semicolon
id|FPU_settag0
c_func
(paren
id|tag
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Zero
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Special
)paren
id|st0_tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|signnegative
c_func
(paren
id|st0_ptr
)paren
)paren
id|arith_invalid
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* sqrt(-Infinity) is invalid */
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
(brace
r_if
c_cond
(paren
id|signnegative
c_func
(paren
id|st0_ptr
)paren
)paren
(brace
id|arith_invalid
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* sqrt(negative) is invalid */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
id|FPU_to_exp16
c_func
(paren
id|st0_ptr
comma
id|st0_ptr
)paren
suffix:semicolon
id|expon
op_assign
id|exponent16
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_goto
id|denormal_arg
suffix:semicolon
)brace
id|single_arg_error
c_func
(paren
id|st0_ptr
comma
id|st0_tag
)paren
suffix:semicolon
)brace
DECL|function|frndint_
r_static
r_void
id|frndint_
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
)paren
(brace
r_int
id|flags
comma
id|tag
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Valid
)paren
(brace
id|u_char
id|sign
suffix:semicolon
id|denormal_arg
suffix:colon
id|sign
op_assign
id|getsign
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
OG
l_int|63
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
(brace
r_if
c_cond
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/* Fortunately, this can&squot;t overflow to 2^64 */
r_if
c_cond
(paren
(paren
id|flags
op_assign
id|FPU_round_to_int
c_func
(paren
id|st0_ptr
comma
id|st0_tag
)paren
)paren
)paren
id|set_precision_flag
c_func
(paren
id|flags
)paren
suffix:semicolon
id|setexponent16
c_func
(paren
id|st0_ptr
comma
l_int|63
)paren
suffix:semicolon
id|tag
op_assign
id|FPU_normalize
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|st0_ptr
comma
id|sign
)paren
suffix:semicolon
id|FPU_settag0
c_func
(paren
id|tag
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Zero
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Special
)paren
id|st0_tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
r_goto
id|denormal_arg
suffix:semicolon
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Infinity
)paren
r_return
suffix:semicolon
r_else
id|single_arg_error
c_func
(paren
id|st0_ptr
comma
id|st0_tag
)paren
suffix:semicolon
)brace
DECL|function|fsin
r_static
r_int
id|fsin
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|tag
)paren
(brace
id|u_char
id|arg_sign
op_assign
id|getsign
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|TAG_Valid
)paren
(brace
r_int
id|q
suffix:semicolon
r_if
c_cond
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
OG
op_minus
l_int|40
)paren
(brace
r_if
c_cond
(paren
(paren
id|q
op_assign
id|trig_arg
c_func
(paren
id|st0_ptr
comma
l_int|0
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Operand is out of range */
r_return
l_int|1
suffix:semicolon
)brace
id|poly_sine
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|q
op_amp
l_int|2
)paren
id|changesign
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|st0_ptr
comma
id|getsign
c_func
(paren
id|st0_ptr
)paren
op_xor
id|arg_sign
)paren
suffix:semicolon
multiline_comment|/* We do not really know if up or down */
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* For a small arg, the result == the argument */
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Must be up. */
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tag
op_eq
id|TAG_Zero
)paren
(brace
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tag
op_eq
id|TAG_Special
)paren
id|tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|TW_Denormal
)paren
(brace
r_if
c_cond
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* For a small arg, the result == the argument */
multiline_comment|/* Underflow may happen */
id|FPU_to_exp16
c_func
(paren
id|st0_ptr
comma
id|st0_ptr
)paren
suffix:semicolon
id|tag
op_assign
id|FPU_round
c_func
(paren
id|st0_ptr
comma
l_int|1
comma
l_int|0
comma
id|FULL_PRECISION
comma
id|arg_sign
)paren
suffix:semicolon
id|FPU_settag0
c_func
(paren
id|tag
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tag
op_eq
id|TW_Infinity
)paren
(brace
multiline_comment|/* The 80486 treats infinity as an invalid operand */
id|arith_invalid
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|single_arg_error
c_func
(paren
id|st0_ptr
comma
id|tag
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|f_cos
r_static
r_int
id|f_cos
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|tag
)paren
(brace
id|u_char
id|st0_sign
suffix:semicolon
id|st0_sign
op_assign
id|getsign
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|TAG_Valid
)paren
(brace
r_int
id|q
suffix:semicolon
r_if
c_cond
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
OG
op_minus
l_int|40
)paren
(brace
r_if
c_cond
(paren
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
OL
l_int|0
)paren
op_logical_or
(paren
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|significand
c_func
(paren
id|st0_ptr
)paren
op_le
l_int|0xc90fdaa22168c234LL
)paren
)paren
)paren
(brace
id|poly_cos
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
multiline_comment|/* We do not really know if up or down */
id|set_precision_flag_down
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|q
op_assign
id|trig_arg
c_func
(paren
id|st0_ptr
comma
id|FCOS
)paren
)paren
op_ne
op_minus
l_int|1
)paren
(brace
id|poly_sine
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|q
op_plus
l_int|1
)paren
op_amp
l_int|2
)paren
id|changesign
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
multiline_comment|/* We do not really know if up or down */
id|set_precision_flag_down
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Operand is out of range */
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|denormal_arg
suffix:colon
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|CONST_1
comma
id|TAG_Valid
)paren
suffix:semicolon
macro_line|#ifdef PECULIAR_486
id|set_precision_flag_down
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* 80486 appears to do this. */
macro_line|#else
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Must be up. */
macro_line|#endif PECULIAR_486
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|tag
op_eq
id|TAG_Zero
)paren
(brace
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|CONST_1
comma
id|TAG_Valid
)paren
suffix:semicolon
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tag
op_eq
id|TAG_Special
)paren
id|tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|TW_Denormal
)paren
(brace
r_if
c_cond
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
l_int|1
suffix:semicolon
r_goto
id|denormal_arg
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tag
op_eq
id|TW_Infinity
)paren
(brace
multiline_comment|/* The 80486 treats infinity as an invalid operand */
id|arith_invalid
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|single_arg_error
c_func
(paren
id|st0_ptr
comma
id|tag
)paren
suffix:semicolon
multiline_comment|/* requires st0_ptr == &amp;st(0) */
r_return
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|fcos
r_static
r_void
id|fcos
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
)paren
(brace
id|f_cos
c_func
(paren
id|st0_ptr
comma
id|st0_tag
)paren
suffix:semicolon
)brace
DECL|function|fsincos
r_static
r_void
id|fsincos
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
)paren
(brace
id|FPU_REG
op_star
id|st_new_ptr
suffix:semicolon
id|FPU_REG
id|arg
suffix:semicolon
id|u_char
id|tag
suffix:semicolon
multiline_comment|/* Stack underflow has higher priority */
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Empty
)paren
(brace
id|FPU_stack_underflow
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Puts a QNaN in st(0) */
r_if
c_cond
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
(brace
id|st_new_ptr
op_assign
op_amp
id|st
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|push
c_func
(paren
)paren
suffix:semicolon
id|FPU_stack_underflow
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Puts a QNaN in the new st(0) */
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|STACK_OVERFLOW
)paren
(brace
id|FPU_stack_overflow
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Special
)paren
id|tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_else
id|tag
op_assign
id|st0_tag
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|TW_NaN
)paren
(brace
id|single_arg_2_error
c_func
(paren
id|st0_ptr
comma
id|TW_NaN
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tag
op_eq
id|TW_Infinity
)paren
(brace
multiline_comment|/* The 80486 treats infinity as an invalid operand */
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
l_int|0
)paren
op_ge
l_int|0
)paren
(brace
multiline_comment|/* Masked response */
id|push
c_func
(paren
)paren
suffix:semicolon
id|arith_invalid
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|reg_copy
c_func
(paren
id|st0_ptr
comma
op_amp
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fsin
c_func
(paren
id|st0_ptr
comma
id|st0_tag
)paren
)paren
(brace
id|push
c_func
(paren
)paren
suffix:semicolon
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|arg
comma
id|st0_tag
)paren
suffix:semicolon
id|f_cos
c_func
(paren
op_amp
id|st
c_func
(paren
l_int|0
)paren
comma
id|st0_tag
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* An error, so restore st(0) */
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|arg
comma
id|st0_tag
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*---------------------------------------------------------------------------*/
multiline_comment|/* The following all require two arguments: st(0) and st(1) */
multiline_comment|/* A lean, mean kernel for the fprem instructions. This relies upon&n;   the division and rounding to an integer in do_fprem giving an&n;   exact result. Because of this, rem_kernel() needs to deal only with&n;   the least significant 64 bits, the more significant bits of the&n;   result must be zero.&n; */
DECL|function|rem_kernel
r_static
r_void
id|rem_kernel
c_func
(paren
r_int
r_int
r_int
id|st0
comma
r_int
r_int
r_int
op_star
id|y
comma
r_int
r_int
r_int
id|st1
comma
r_int
r_int
r_int
id|q
comma
r_int
id|n
)paren
(brace
r_int
id|dummy
suffix:semicolon
r_int
r_int
r_int
id|x
suffix:semicolon
id|x
op_assign
id|st0
op_lshift
id|n
suffix:semicolon
multiline_comment|/* Do the required multiplication and subtraction in the one operation */
multiline_comment|/* lsw x -= lsw st1 * lsw q */
id|asm
r_volatile
(paren
l_string|&quot;mull %4; subl %%eax,%0; sbbl %%edx,%1&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|x
)paren
(braket
l_int|0
)braket
)paren
comma
l_string|&quot;=m&quot;
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|x
)paren
(braket
l_int|1
)braket
)paren
comma
l_string|&quot;=a&quot;
(paren
id|dummy
)paren
suffix:colon
l_string|&quot;2&quot;
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|st1
)paren
(braket
l_int|0
)braket
)paren
comma
l_string|&quot;m&quot;
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|q
)paren
(braket
l_int|0
)braket
)paren
suffix:colon
l_string|&quot;%dx&quot;
)paren
suffix:semicolon
multiline_comment|/* msw x -= msw st1 * lsw q */
id|asm
r_volatile
(paren
l_string|&quot;mull %3; subl %%eax,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|x
)paren
(braket
l_int|1
)braket
)paren
comma
l_string|&quot;=a&quot;
(paren
id|dummy
)paren
suffix:colon
l_string|&quot;1&quot;
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|st1
)paren
(braket
l_int|1
)braket
)paren
comma
l_string|&quot;m&quot;
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|q
)paren
(braket
l_int|0
)braket
)paren
suffix:colon
l_string|&quot;%dx&quot;
)paren
suffix:semicolon
multiline_comment|/* msw x -= lsw st1 * msw q */
id|asm
r_volatile
(paren
l_string|&quot;mull %3; subl %%eax,%0&quot;
suffix:colon
l_string|&quot;=m&quot;
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|x
)paren
(braket
l_int|1
)braket
)paren
comma
l_string|&quot;=a&quot;
(paren
id|dummy
)paren
suffix:colon
l_string|&quot;1&quot;
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|st1
)paren
(braket
l_int|0
)braket
)paren
comma
l_string|&quot;m&quot;
(paren
(paren
(paren
r_int
op_star
)paren
op_amp
id|q
)paren
(braket
l_int|1
)braket
)paren
suffix:colon
l_string|&quot;%dx&quot;
)paren
suffix:semicolon
op_star
id|y
op_assign
id|x
suffix:semicolon
)brace
multiline_comment|/* Remainder of st(0) / st(1) */
multiline_comment|/* This routine produces exact results, i.e. there is never any&n;   rounding or truncation, etc of the result. */
DECL|function|do_fprem
r_static
r_void
id|do_fprem
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
comma
r_int
id|round
)paren
(brace
id|FPU_REG
op_star
id|st1_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|u_char
id|st1_tag
op_assign
id|FPU_gettagi
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|st0_tag
op_xor
id|TAG_Valid
)paren
op_or
(paren
id|st1_tag
op_xor
id|TAG_Valid
)paren
)paren
)paren
(brace
id|FPU_REG
id|tmp
comma
id|st0
comma
id|st1
suffix:semicolon
id|u_char
id|st0_sign
comma
id|st1_sign
suffix:semicolon
id|u_char
id|tmptag
suffix:semicolon
r_int
id|tag
suffix:semicolon
r_int
id|old_cw
suffix:semicolon
r_int
id|expdif
suffix:semicolon
r_int
r_int
id|q
suffix:semicolon
r_int
r_int
id|saved_status
suffix:semicolon
r_int
id|cc
suffix:semicolon
id|fprem_valid
suffix:colon
multiline_comment|/* Convert registers for internal use. */
id|st0_sign
op_assign
id|FPU_to_exp16
c_func
(paren
id|st0_ptr
comma
op_amp
id|st0
)paren
suffix:semicolon
id|st1_sign
op_assign
id|FPU_to_exp16
c_func
(paren
id|st1_ptr
comma
op_amp
id|st1
)paren
suffix:semicolon
id|expdif
op_assign
id|exponent16
c_func
(paren
op_amp
id|st0
)paren
op_minus
id|exponent16
c_func
(paren
op_amp
id|st1
)paren
suffix:semicolon
id|old_cw
op_assign
id|control_word
suffix:semicolon
id|cc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We want the status following the denorm tests, but don&squot;t want&n;&t; the status changed by the arithmetic operations. */
id|saved_status
op_assign
id|partial_status
suffix:semicolon
id|control_word
op_and_assign
op_complement
id|CW_RC
suffix:semicolon
id|control_word
op_or_assign
id|RC_CHOP
suffix:semicolon
r_if
c_cond
(paren
id|expdif
OL
l_int|64
)paren
(brace
multiline_comment|/* This should be the most common case */
r_if
c_cond
(paren
id|expdif
OG
op_minus
l_int|2
)paren
(brace
id|u_char
id|sign
op_assign
id|st0_sign
op_xor
id|st1_sign
suffix:semicolon
id|tag
op_assign
id|FPU_u_div
c_func
(paren
op_amp
id|st0
comma
op_amp
id|st1
comma
op_amp
id|tmp
comma
id|PR_64_BITS
op_or
id|RC_CHOP
op_or
l_int|0x3f
comma
id|sign
)paren
suffix:semicolon
id|setsign
c_func
(paren
op_amp
id|tmp
comma
id|sign
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exponent
c_func
(paren
op_amp
id|tmp
)paren
op_ge
l_int|0
)paren
(brace
id|FPU_round_to_int
c_func
(paren
op_amp
id|tmp
comma
id|tag
)paren
suffix:semicolon
multiline_comment|/* Fortunately, this can&squot;t&n;&t;&t;&t;&t;&t;&t;   overflow to 2^64 */
id|q
op_assign
id|significand
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|rem_kernel
c_func
(paren
id|significand
c_func
(paren
op_amp
id|st0
)paren
comma
op_amp
id|significand
c_func
(paren
op_amp
id|tmp
)paren
comma
id|significand
c_func
(paren
op_amp
id|st1
)paren
comma
id|q
comma
id|expdif
)paren
suffix:semicolon
id|setexponent16
c_func
(paren
op_amp
id|tmp
comma
id|exponent16
c_func
(paren
op_amp
id|st1
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|reg_copy
c_func
(paren
op_amp
id|st0
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|q
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|round
op_eq
id|RC_RND
)paren
op_logical_and
(paren
id|tmp.sigh
op_amp
l_int|0xc0000000
)paren
)paren
(brace
multiline_comment|/* We may need to subtract st(1) once more,&n;&t;&t;     to get a result &lt;= 1/2 of st(1). */
r_int
r_int
r_int
id|x
suffix:semicolon
id|expdif
op_assign
id|exponent16
c_func
(paren
op_amp
id|st1
)paren
op_minus
id|exponent16
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|expdif
op_le
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|expdif
op_eq
l_int|0
)paren
id|x
op_assign
id|significand
c_func
(paren
op_amp
id|st1
)paren
op_minus
id|significand
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
r_else
multiline_comment|/* expdif is 1 */
id|x
op_assign
(paren
id|significand
c_func
(paren
op_amp
id|st1
)paren
op_lshift
l_int|1
)paren
op_minus
id|significand
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|x
OL
id|significand
c_func
(paren
op_amp
id|tmp
)paren
)paren
op_logical_or
multiline_comment|/* or equi-distant (from 0 &amp; st(1)) and q is odd */
(paren
(paren
id|x
op_eq
id|significand
c_func
(paren
op_amp
id|tmp
)paren
)paren
op_logical_and
(paren
id|q
op_amp
l_int|1
)paren
)paren
)paren
(brace
id|st0_sign
op_assign
op_logical_neg
id|st0_sign
suffix:semicolon
id|significand
c_func
(paren
op_amp
id|tmp
)paren
op_assign
id|x
suffix:semicolon
id|q
op_increment
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|q
op_amp
l_int|4
)paren
id|cc
op_or_assign
id|SW_C0
suffix:semicolon
r_if
c_cond
(paren
id|q
op_amp
l_int|2
)paren
id|cc
op_or_assign
id|SW_C3
suffix:semicolon
r_if
c_cond
(paren
id|q
op_amp
l_int|1
)paren
id|cc
op_or_assign
id|SW_C1
suffix:semicolon
)brace
r_else
(brace
id|control_word
op_assign
id|old_cw
suffix:semicolon
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* There is a large exponent difference ( &gt;= 64 ) */
multiline_comment|/* To make much sense, the code in this section should&n;&t;     be done at high precision. */
r_int
id|exp_1
comma
id|N
suffix:semicolon
id|u_char
id|sign
suffix:semicolon
multiline_comment|/* prevent overflow here */
multiline_comment|/* N is &squot;a number between 32 and 63&squot; (p26-113) */
id|reg_copy
c_func
(paren
op_amp
id|st0
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|tmptag
op_assign
id|st0_tag
suffix:semicolon
id|N
op_assign
(paren
id|expdif
op_amp
l_int|0x0000001f
)paren
op_plus
l_int|32
suffix:semicolon
multiline_comment|/* This choice gives results&n;&t;&t;&t;&t;&t;      identical to an AMD 486 */
id|setexponent16
c_func
(paren
op_amp
id|tmp
comma
id|N
)paren
suffix:semicolon
id|exp_1
op_assign
id|exponent16
c_func
(paren
op_amp
id|st1
)paren
suffix:semicolon
id|setexponent16
c_func
(paren
op_amp
id|st1
comma
l_int|0
)paren
suffix:semicolon
id|expdif
op_sub_assign
id|N
suffix:semicolon
id|sign
op_assign
id|getsign
c_func
(paren
op_amp
id|tmp
)paren
op_xor
id|st1_sign
suffix:semicolon
id|tag
op_assign
id|FPU_u_div
c_func
(paren
op_amp
id|tmp
comma
op_amp
id|st1
comma
op_amp
id|tmp
comma
id|PR_64_BITS
op_or
id|RC_CHOP
op_or
l_int|0x3f
comma
id|sign
)paren
suffix:semicolon
id|setsign
c_func
(paren
op_amp
id|tmp
comma
id|sign
)paren
suffix:semicolon
id|FPU_round_to_int
c_func
(paren
op_amp
id|tmp
comma
id|tag
)paren
suffix:semicolon
multiline_comment|/* Fortunately, this can&squot;t&n;&t;&t;&t;&t;&t;   overflow to 2^64 */
id|rem_kernel
c_func
(paren
id|significand
c_func
(paren
op_amp
id|st0
)paren
comma
op_amp
id|significand
c_func
(paren
op_amp
id|tmp
)paren
comma
id|significand
c_func
(paren
op_amp
id|st1
)paren
comma
id|significand
c_func
(paren
op_amp
id|tmp
)paren
comma
id|exponent
c_func
(paren
op_amp
id|tmp
)paren
)paren
suffix:semicolon
id|setexponent16
c_func
(paren
op_amp
id|tmp
comma
id|exp_1
op_plus
id|expdif
)paren
suffix:semicolon
multiline_comment|/* It is possible for the operation to be complete here.&n;&t;     What does the IEEE standard say? The Intel 80486 manual&n;&t;     implies that the operation will never be completed at this&n;&t;     point, and the behaviour of a real 80486 confirms this.&n;&t;   */
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp.sigh
op_or
id|tmp.sigl
)paren
)paren
(brace
multiline_comment|/* The result is zero */
id|control_word
op_assign
id|old_cw
suffix:semicolon
id|partial_status
op_assign
id|saved_status
suffix:semicolon
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|CONST_Z
comma
id|TAG_Zero
)paren
suffix:semicolon
id|setsign
c_func
(paren
op_amp
id|st0
comma
id|st0_sign
)paren
suffix:semicolon
macro_line|#ifdef PECULIAR_486
id|setcc
c_func
(paren
id|SW_C2
)paren
suffix:semicolon
macro_line|#else
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif PECULIAR_486
r_return
suffix:semicolon
)brace
id|cc
op_assign
id|SW_C2
suffix:semicolon
)brace
id|control_word
op_assign
id|old_cw
suffix:semicolon
id|partial_status
op_assign
id|saved_status
suffix:semicolon
id|tag
op_assign
id|FPU_normalize_nuo
c_func
(paren
op_amp
id|tmp
)paren
suffix:semicolon
id|reg_copy
c_func
(paren
op_amp
id|tmp
comma
id|st0_ptr
)paren
suffix:semicolon
multiline_comment|/* The only condition to be looked for is underflow,&n;&t; and it can occur here only if underflow is unmasked. */
r_if
c_cond
(paren
(paren
id|exponent16
c_func
(paren
op_amp
id|tmp
)paren
op_le
id|EXP_UNDER
)paren
op_logical_and
(paren
id|tag
op_ne
id|TAG_Zero
)paren
op_logical_and
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Underflow
)paren
)paren
(brace
id|setcc
c_func
(paren
id|cc
)paren
suffix:semicolon
id|tag
op_assign
id|arith_underflow
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|st0_ptr
comma
id|st0_sign
)paren
suffix:semicolon
id|FPU_settag0
c_func
(paren
id|tag
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|exponent16
c_func
(paren
op_amp
id|tmp
)paren
OG
id|EXP_UNDER
)paren
op_logical_or
(paren
id|tag
op_eq
id|TAG_Zero
)paren
)paren
(brace
id|stdexp
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|st0_ptr
comma
id|st0_sign
)paren
suffix:semicolon
)brace
r_else
(brace
id|tag
op_assign
id|FPU_round
c_func
(paren
id|st0_ptr
comma
l_int|0
comma
l_int|0
comma
id|FULL_PRECISION
comma
id|st0_sign
)paren
suffix:semicolon
)brace
id|FPU_settag0
c_func
(paren
id|tag
)paren
suffix:semicolon
id|setcc
c_func
(paren
id|cc
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Special
)paren
id|st0_tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TAG_Special
)paren
id|st1_tag
op_assign
id|FPU_Special
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|st0_tag
op_eq
id|TAG_Valid
)paren
op_logical_and
(paren
id|st1_tag
op_eq
id|TW_Denormal
)paren
)paren
op_logical_or
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|st1_tag
op_eq
id|TAG_Valid
)paren
)paren
op_logical_or
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|st1_tag
op_eq
id|TW_Denormal
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
r_goto
id|fprem_valid
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TAG_Empty
)paren
op_or
(paren
id|st1_tag
op_eq
id|TAG_Empty
)paren
)paren
(brace
id|FPU_stack_underflow
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Zero
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TAG_Valid
)paren
(brace
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Denormal
)paren
(brace
r_if
c_cond
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TAG_Zero
)paren
(brace
id|arith_invalid
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* fprem(?,0) always invalid */
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
(brace
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TAG_Valid
)paren
op_logical_or
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TAG_Zero
)paren
(brace
id|arith_invalid
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* fprem(Valid,Zero) is invalid */
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_ne
id|TW_NaN
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_Denormal
)paren
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
(brace
multiline_comment|/* fprem(Valid,Infinity) is o.k. */
id|setcc
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_ne
id|TW_NaN
)paren
(brace
id|arith_invalid
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* fprem(Infinity,?) is invalid */
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* One of the registers must contain a NaN if we got here. */
macro_line|#ifdef PARANOID
r_if
c_cond
(paren
(paren
id|st0_tag
op_ne
id|TW_NaN
)paren
op_logical_and
(paren
id|st1_tag
op_ne
id|TW_NaN
)paren
)paren
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x118
)paren
suffix:semicolon
macro_line|#endif PARANOID
id|real_2op_NaN
c_func
(paren
id|st1_ptr
comma
id|st1_tag
comma
l_int|0
comma
id|st1_ptr
)paren
suffix:semicolon
)brace
multiline_comment|/* ST(1) &lt;- ST(1) * log ST;  pop ST */
DECL|function|fyl2x
r_static
r_void
id|fyl2x
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
)paren
(brace
id|FPU_REG
op_star
id|st1_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|1
)paren
comma
id|exponent
suffix:semicolon
id|u_char
id|st1_tag
op_assign
id|FPU_gettagi
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|u_char
id|sign
suffix:semicolon
r_int
id|e
comma
id|tag
suffix:semicolon
id|clear_C1
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TAG_Valid
)paren
op_logical_and
(paren
id|st1_tag
op_eq
id|TAG_Valid
)paren
)paren
(brace
id|both_valid
suffix:colon
multiline_comment|/* Both regs are Valid or Denormal */
r_if
c_cond
(paren
id|signpositive
c_func
(paren
id|st0_ptr
)paren
)paren
(brace
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
id|FPU_to_exp16
c_func
(paren
id|st0_ptr
comma
id|st0_ptr
)paren
suffix:semicolon
r_else
multiline_comment|/* Convert st(0) for internal use. */
id|setexponent16
c_func
(paren
id|st0_ptr
comma
id|exponent
c_func
(paren
id|st0_ptr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st0_ptr-&gt;sigh
op_eq
l_int|0x80000000
)paren
op_logical_and
(paren
id|st0_ptr-&gt;sigl
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* Special case. The result can be precise. */
id|u_char
id|esign
suffix:semicolon
id|e
op_assign
id|exponent16
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
op_ge
l_int|0
)paren
(brace
id|exponent.sigh
op_assign
id|e
suffix:semicolon
id|esign
op_assign
id|SIGN_POS
suffix:semicolon
)brace
r_else
(brace
id|exponent.sigh
op_assign
op_minus
id|e
suffix:semicolon
id|esign
op_assign
id|SIGN_NEG
suffix:semicolon
)brace
id|exponent.sigl
op_assign
l_int|0
suffix:semicolon
id|setexponent16
c_func
(paren
op_amp
id|exponent
comma
l_int|31
)paren
suffix:semicolon
id|tag
op_assign
id|FPU_normalize_nuo
c_func
(paren
op_amp
id|exponent
)paren
suffix:semicolon
id|stdexp
c_func
(paren
op_amp
id|exponent
)paren
suffix:semicolon
id|setsign
c_func
(paren
op_amp
id|exponent
comma
id|esign
)paren
suffix:semicolon
id|tag
op_assign
id|FPU_mul
c_func
(paren
op_amp
id|exponent
comma
id|tag
comma
l_int|1
comma
id|FULL_PRECISION
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_ge
l_int|0
)paren
id|FPU_settagi
c_func
(paren
l_int|1
comma
id|tag
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The usual case */
id|sign
op_assign
id|getsign
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Denormal
)paren
id|FPU_to_exp16
c_func
(paren
id|st1_ptr
comma
id|st1_ptr
)paren
suffix:semicolon
r_else
multiline_comment|/* Convert st(1) for internal use. */
id|setexponent16
c_func
(paren
id|st1_ptr
comma
id|exponent
c_func
(paren
id|st1_ptr
)paren
)paren
suffix:semicolon
id|poly_l2
c_func
(paren
id|st0_ptr
comma
id|st1_ptr
comma
id|sign
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* negative */
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
l_int|1
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
)brace
id|FPU_pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Special
)paren
id|st0_tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TAG_Special
)paren
id|st1_tag
op_assign
id|FPU_Special
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TAG_Empty
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TAG_Empty
)paren
)paren
(brace
id|FPU_stack_underflow_pop
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|st0_tag
op_le
id|TW_Denormal
)paren
op_logical_and
(paren
id|st1_tag
op_le
id|TW_Denormal
)paren
)paren
(brace
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Zero
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TAG_Zero
)paren
(brace
multiline_comment|/* Both args zero is invalid */
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
l_int|1
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
)brace
r_else
(brace
id|u_char
id|sign
suffix:semicolon
id|sign
op_assign
id|getsign
c_func
(paren
id|st1_ptr
)paren
op_xor
id|SIGN_NEG
suffix:semicolon
r_if
c_cond
(paren
id|FPU_divide_by_zero
c_func
(paren
l_int|1
comma
id|sign
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
id|setsign
c_func
(paren
id|st1_ptr
comma
id|sign
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TAG_Zero
)paren
(brace
multiline_comment|/* st(1) contains zero, st(0) valid &lt;&gt; 0 */
multiline_comment|/* Zero is the valid answer */
id|sign
op_assign
id|getsign
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signnegative
c_func
(paren
id|st0_ptr
)paren
)paren
(brace
multiline_comment|/* log(negative) */
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
l_int|1
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
OL
l_int|0
)paren
id|sign
op_xor_assign
id|SIGN_NEG
suffix:semicolon
id|FPU_copy_to_reg1
c_func
(paren
op_amp
id|CONST_Z
comma
id|TAG_Zero
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|st1_ptr
comma
id|sign
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* One or both operands are denormals. */
r_if
c_cond
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
r_goto
id|both_valid
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TW_NaN
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_NaN
)paren
)paren
(brace
r_if
c_cond
(paren
id|real_2op_NaN
c_func
(paren
id|st0_ptr
comma
id|st0_tag
comma
l_int|1
comma
id|st0_ptr
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/* One or both arg must be an infinity */
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
(paren
id|signnegative
c_func
(paren
id|st0_ptr
)paren
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TAG_Zero
)paren
)paren
(brace
multiline_comment|/* log(-infinity) or 0*log(infinity) */
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
l_int|1
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
)brace
r_else
(brace
id|u_char
id|sign
op_assign
id|getsign
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st1_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
suffix:semicolon
id|FPU_copy_to_reg1
c_func
(paren
op_amp
id|CONST_INF
comma
id|TAG_Special
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|st1_ptr
comma
id|sign
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* st(1) must be infinity here */
r_else
r_if
c_cond
(paren
(paren
(paren
id|st0_tag
op_eq
id|TAG_Valid
)paren
op_logical_or
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
)paren
op_logical_and
(paren
id|signpositive
c_func
(paren
id|st0_ptr
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|st0_ptr-&gt;sigh
op_eq
l_int|0x80000000
)paren
op_logical_and
(paren
id|st0_ptr-&gt;sigl
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* st(0) holds 1.0 */
multiline_comment|/* infinity*log(1) */
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
l_int|1
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/* else st(0) is positive and &gt; 1.0 */
)brace
r_else
(brace
multiline_comment|/* st(0) is positive and &lt; 1.0 */
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
suffix:semicolon
id|changesign
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* st(0) must be zero or negative */
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Zero
)paren
(brace
multiline_comment|/* This should be invalid, but a real 80486 is happy with it. */
macro_line|#ifndef PECULIAR_486
id|sign
op_assign
id|getsign
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FPU_divide_by_zero
c_func
(paren
l_int|1
comma
id|sign
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
macro_line|#endif PECULIAR_486
id|changesign
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
l_int|1
)paren
OL
l_int|0
)paren
multiline_comment|/* log(negative) */
r_return
suffix:semicolon
)brace
id|FPU_pop
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fpatan
r_static
r_void
id|fpatan
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
)paren
(brace
id|FPU_REG
op_star
id|st1_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|u_char
id|st1_tag
op_assign
id|FPU_gettagi
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_int
id|tag
suffix:semicolon
id|clear_C1
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|st0_tag
op_xor
id|TAG_Valid
)paren
op_or
(paren
id|st1_tag
op_xor
id|TAG_Valid
)paren
)paren
)paren
(brace
id|valid_atan
suffix:colon
id|poly_atan
c_func
(paren
id|st0_ptr
comma
id|st0_tag
comma
id|st1_ptr
comma
id|st1_tag
)paren
suffix:semicolon
id|FPU_pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Special
)paren
id|st0_tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TAG_Special
)paren
id|st1_tag
op_assign
id|FPU_Special
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|st0_tag
op_eq
id|TAG_Valid
)paren
op_logical_and
(paren
id|st1_tag
op_eq
id|TW_Denormal
)paren
)paren
op_logical_or
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|st1_tag
op_eq
id|TAG_Valid
)paren
)paren
op_logical_or
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|st1_tag
op_eq
id|TW_Denormal
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
r_goto
id|valid_atan
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TAG_Empty
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TAG_Empty
)paren
)paren
(brace
id|FPU_stack_underflow_pop
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TW_NaN
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_NaN
)paren
)paren
(brace
r_if
c_cond
(paren
id|real_2op_NaN
c_func
(paren
id|st0_ptr
comma
id|st0_tag
comma
l_int|1
comma
id|st0_ptr
)paren
op_ge
l_int|0
)paren
id|FPU_pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TW_Infinity
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
)paren
(brace
id|u_char
id|sign
op_assign
id|getsign
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|signpositive
c_func
(paren
id|st0_ptr
)paren
)paren
(brace
id|FPU_copy_to_reg1
c_func
(paren
op_amp
id|CONST_PI4
comma
id|TAG_Valid
)paren
suffix:semicolon
)brace
r_else
(brace
id|setpositive
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
id|tag
op_assign
id|FPU_u_add
c_func
(paren
op_amp
id|CONST_PI4
comma
op_amp
id|CONST_PI2
comma
id|st1_ptr
comma
id|FULL_PRECISION
comma
id|SIGN_POS
comma
id|exponent
c_func
(paren
op_amp
id|CONST_PI4
)paren
comma
id|exponent
c_func
(paren
op_amp
id|CONST_PI2
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_ge
l_int|0
)paren
id|FPU_settagi
c_func
(paren
l_int|1
comma
id|tag
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|st1_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|signpositive
c_func
(paren
id|st0_ptr
)paren
)paren
(brace
id|FPU_copy_to_reg1
c_func
(paren
op_amp
id|CONST_Z
comma
id|TAG_Zero
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|st1_ptr
comma
id|sign
)paren
suffix:semicolon
multiline_comment|/* An 80486 preserves the sign */
id|FPU_pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|FPU_copy_to_reg1
c_func
(paren
op_amp
id|CONST_PI
comma
id|TAG_Valid
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* st(1) is infinity, st(0) not infinity */
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
suffix:semicolon
id|FPU_copy_to_reg1
c_func
(paren
op_amp
id|CONST_PI2
comma
id|TAG_Valid
)paren
suffix:semicolon
)brace
id|setsign
c_func
(paren
id|st1_ptr
comma
id|sign
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TAG_Zero
)paren
(brace
multiline_comment|/* st(0) must be valid or zero */
id|u_char
id|sign
op_assign
id|getsign
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|signpositive
c_func
(paren
id|st0_ptr
)paren
)paren
(brace
multiline_comment|/* An 80486 preserves the sign */
id|FPU_pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|FPU_copy_to_reg1
c_func
(paren
op_amp
id|CONST_PI
comma
id|TAG_Valid
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|st1_ptr
comma
id|sign
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Zero
)paren
(brace
multiline_comment|/* st(1) must be TAG_Valid here */
id|u_char
id|sign
op_assign
id|getsign
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st1_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
suffix:semicolon
id|FPU_copy_to_reg1
c_func
(paren
op_amp
id|CONST_PI2
comma
id|TAG_Valid
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|st1_ptr
comma
id|sign
)paren
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
r_else
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x125
)paren
suffix:semicolon
macro_line|#endif PARANOID
id|FPU_pop
c_func
(paren
)paren
suffix:semicolon
id|set_precision_flag_up
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* We do not really know if up or down */
)brace
DECL|function|fprem
r_static
r_void
id|fprem
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
)paren
(brace
id|do_fprem
c_func
(paren
id|st0_ptr
comma
id|st0_tag
comma
id|RC_CHOP
)paren
suffix:semicolon
)brace
DECL|function|fprem1
r_static
r_void
id|fprem1
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
)paren
(brace
id|do_fprem
c_func
(paren
id|st0_ptr
comma
id|st0_tag
comma
id|RC_RND
)paren
suffix:semicolon
)brace
DECL|function|fyl2xp1
r_static
r_void
id|fyl2xp1
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
)paren
(brace
id|u_char
id|sign
comma
id|sign1
suffix:semicolon
id|FPU_REG
op_star
id|st1_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|1
)paren
comma
id|a
comma
id|b
suffix:semicolon
id|u_char
id|st1_tag
op_assign
id|FPU_gettagi
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|clear_C1
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|st0_tag
op_xor
id|TAG_Valid
)paren
op_or
(paren
id|st1_tag
op_xor
id|TAG_Valid
)paren
)paren
)paren
(brace
id|valid_yl2xp1
suffix:colon
id|sign
op_assign
id|getsign
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
id|sign1
op_assign
id|getsign
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
id|FPU_to_exp16
c_func
(paren
id|st0_ptr
comma
op_amp
id|a
)paren
suffix:semicolon
id|FPU_to_exp16
c_func
(paren
id|st1_ptr
comma
op_amp
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|poly_l2p1
c_func
(paren
id|sign
comma
id|sign1
comma
op_amp
id|a
comma
op_amp
id|b
comma
id|st1_ptr
)paren
)paren
r_return
suffix:semicolon
id|FPU_pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Special
)paren
id|st0_tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TAG_Special
)paren
id|st1_tag
op_assign
id|FPU_Special
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|st0_tag
op_eq
id|TAG_Valid
)paren
op_logical_and
(paren
id|st1_tag
op_eq
id|TW_Denormal
)paren
)paren
op_logical_or
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|st1_tag
op_eq
id|TAG_Valid
)paren
)paren
op_logical_or
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|st1_tag
op_eq
id|TW_Denormal
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
r_goto
id|valid_yl2xp1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TAG_Empty
)paren
op_or
(paren
id|st1_tag
op_eq
id|TAG_Empty
)paren
)paren
(brace
id|FPU_stack_underflow_pop
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Zero
)paren
(brace
r_switch
c_cond
(paren
id|st1_tag
)paren
(brace
r_case
id|TW_Denormal
suffix:colon
r_if
c_cond
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
r_case
id|TAG_Zero
suffix:colon
r_case
id|TAG_Valid
suffix:colon
id|setsign
c_func
(paren
id|st0_ptr
comma
id|getsign
c_func
(paren
id|st0_ptr
)paren
op_xor
id|getsign
c_func
(paren
id|st1_ptr
)paren
)paren
suffix:semicolon
id|FPU_copy_to_reg1
c_func
(paren
id|st0_ptr
comma
id|st0_tag
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TW_Infinity
suffix:colon
multiline_comment|/* Infinity*log(1) */
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
l_int|1
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TW_NaN
suffix:colon
r_if
c_cond
(paren
id|real_2op_NaN
c_func
(paren
id|st0_ptr
comma
id|st0_tag
comma
l_int|1
comma
id|st0_ptr
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
macro_line|#ifdef PARANOID
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x116
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif PARANOID
)brace
)brace
r_else
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TAG_Valid
)paren
op_logical_or
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
)paren
(brace
r_switch
c_cond
(paren
id|st1_tag
)paren
(brace
r_case
id|TAG_Zero
suffix:colon
r_if
c_cond
(paren
id|signnegative
c_func
(paren
id|st0_ptr
)paren
)paren
(brace
r_if
c_cond
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
op_ge
l_int|0
)paren
(brace
multiline_comment|/* st(0) holds &lt;= -1.0 */
macro_line|#ifdef PECULIAR_486   /* Stupid 80486 doesn&squot;t worry about log(negative). */
id|changesign
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
l_int|1
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
macro_line|#endif PECULIAR_486
)brace
r_else
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
suffix:semicolon
r_else
id|changesign
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TW_Infinity
suffix:colon
r_if
c_cond
(paren
id|signnegative
c_func
(paren
id|st0_ptr
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
op_ge
l_int|0
)paren
op_logical_and
op_logical_neg
(paren
(paren
id|st0_ptr-&gt;sigh
op_eq
l_int|0x80000000
)paren
op_logical_and
(paren
id|st0_ptr-&gt;sigl
op_eq
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/* st(0) holds &lt; -1.0 */
macro_line|#ifdef PECULIAR_486   /* Stupid 80486 doesn&squot;t worry about log(negative). */
id|changesign
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
l_int|1
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
macro_line|#endif PECULIAR_486
)brace
r_else
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
suffix:semicolon
r_else
id|changesign
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TW_NaN
suffix:colon
r_if
c_cond
(paren
id|real_2op_NaN
c_func
(paren
id|st0_ptr
comma
id|st0_tag
comma
l_int|1
comma
id|st0_ptr
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_NaN
)paren
(brace
r_if
c_cond
(paren
id|real_2op_NaN
c_func
(paren
id|st0_ptr
comma
id|st0_tag
comma
l_int|1
comma
id|st0_ptr
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TW_NaN
)paren
(brace
r_if
c_cond
(paren
id|real_2op_NaN
c_func
(paren
id|st0_ptr
comma
id|st0_tag
comma
l_int|1
comma
id|st0_ptr
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|signnegative
c_func
(paren
id|st0_ptr
)paren
)paren
(brace
macro_line|#ifndef PECULIAR_486
multiline_comment|/* This should have higher priority than denormals, but... */
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
l_int|1
)paren
OL
l_int|0
)paren
multiline_comment|/* log(-infinity) */
r_return
suffix:semicolon
macro_line|#endif PECULIAR_486
r_if
c_cond
(paren
(paren
id|st1_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
suffix:semicolon
macro_line|#ifdef PECULIAR_486
multiline_comment|/* Denormal operands actually get higher priority */
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
l_int|1
)paren
OL
l_int|0
)paren
multiline_comment|/* log(-infinity) */
r_return
suffix:semicolon
macro_line|#endif PECULIAR_486
)brace
r_else
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TAG_Zero
)paren
(brace
multiline_comment|/* log(infinity) */
r_if
c_cond
(paren
id|arith_invalid
c_func
(paren
l_int|1
)paren
OL
l_int|0
)paren
r_return
suffix:semicolon
)brace
multiline_comment|/* st(1) must be valid here. */
r_else
r_if
c_cond
(paren
(paren
id|st1_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* The Manual says that log(Infinity) is invalid, but a real&n;&t; 80486 sensibly says that it is o.k. */
r_else
(brace
id|u_char
id|sign
op_assign
id|getsign
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
id|FPU_copy_to_reg1
c_func
(paren
op_amp
id|CONST_INF
comma
id|TAG_Special
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|st1_ptr
comma
id|sign
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef PARANOID
r_else
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x117
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif PARANOID
id|FPU_pop
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|fscale
r_static
r_void
id|fscale
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
comma
id|u_char
id|st0_tag
)paren
(brace
id|FPU_REG
op_star
id|st1_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|u_char
id|st1_tag
op_assign
id|FPU_gettagi
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_int
id|old_cw
op_assign
id|control_word
suffix:semicolon
id|u_char
id|sign
op_assign
id|getsign
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
id|clear_C1
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|st0_tag
op_xor
id|TAG_Valid
)paren
op_or
(paren
id|st1_tag
op_xor
id|TAG_Valid
)paren
)paren
)paren
(brace
r_int
id|scale
suffix:semicolon
id|FPU_REG
id|tmp
suffix:semicolon
multiline_comment|/* Convert register for internal use. */
id|setexponent16
c_func
(paren
id|st0_ptr
comma
id|exponent
c_func
(paren
id|st0_ptr
)paren
)paren
suffix:semicolon
id|valid_scale
suffix:colon
r_if
c_cond
(paren
id|exponent
c_func
(paren
id|st1_ptr
)paren
OG
l_int|30
)paren
(brace
multiline_comment|/* 2^31 is far too large, would require 2^(2^30) or 2^(-2^30) */
r_if
c_cond
(paren
id|signpositive
c_func
(paren
id|st1_ptr
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Overflow
)paren
suffix:semicolon
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|CONST_INF
comma
id|TAG_Special
)paren
suffix:semicolon
)brace
r_else
(brace
id|EXCEPTION
c_func
(paren
id|EX_Underflow
)paren
suffix:semicolon
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|CONST_Z
comma
id|TAG_Zero
)paren
suffix:semicolon
)brace
id|setsign
c_func
(paren
id|st0_ptr
comma
id|sign
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|control_word
op_and_assign
op_complement
id|CW_RC
suffix:semicolon
id|control_word
op_or_assign
id|RC_CHOP
suffix:semicolon
id|reg_copy
c_func
(paren
id|st1_ptr
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|FPU_round_to_int
c_func
(paren
op_amp
id|tmp
comma
id|st1_tag
)paren
suffix:semicolon
multiline_comment|/* This can never overflow here */
id|control_word
op_assign
id|old_cw
suffix:semicolon
id|scale
op_assign
id|signnegative
c_func
(paren
id|st1_ptr
)paren
ques
c_cond
op_minus
id|tmp.sigl
suffix:colon
id|tmp.sigl
suffix:semicolon
id|scale
op_add_assign
id|exponent16
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
id|setexponent16
c_func
(paren
id|st0_ptr
comma
id|scale
)paren
suffix:semicolon
multiline_comment|/* Use FPU_round() to properly detect under/overflow etc */
id|FPU_round
c_func
(paren
id|st0_ptr
comma
l_int|0
comma
l_int|0
comma
id|control_word
comma
id|sign
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Special
)paren
id|st0_tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st1_tag
op_eq
id|TAG_Special
)paren
id|st1_tag
op_assign
id|FPU_Special
c_func
(paren
id|st1_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TAG_Valid
)paren
op_logical_or
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
)paren
(brace
r_switch
c_cond
(paren
id|st1_tag
)paren
(brace
r_case
id|TAG_Valid
suffix:colon
multiline_comment|/* st(0) must be a denormal */
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
suffix:semicolon
id|FPU_to_exp16
c_func
(paren
id|st0_ptr
comma
id|st0_ptr
)paren
suffix:semicolon
multiline_comment|/* Will not be left on stack */
r_goto
id|valid_scale
suffix:semicolon
r_case
id|TAG_Zero
suffix:colon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
id|denormal_operand
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|TW_Denormal
suffix:colon
id|denormal_operand
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|TW_Infinity
suffix:colon
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|signpositive
c_func
(paren
id|st1_ptr
)paren
)paren
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|CONST_INF
comma
id|TAG_Special
)paren
suffix:semicolon
r_else
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|CONST_Z
comma
id|TAG_Zero
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|st0_ptr
comma
id|sign
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|TW_NaN
suffix:colon
id|real_2op_NaN
c_func
(paren
id|st1_ptr
comma
id|st1_tag
comma
l_int|0
comma
id|st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Zero
)paren
(brace
r_switch
c_cond
(paren
id|st1_tag
)paren
(brace
r_case
id|TAG_Valid
suffix:colon
r_case
id|TAG_Zero
suffix:colon
r_return
suffix:semicolon
r_case
id|TW_Denormal
suffix:colon
id|denormal_operand
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|TW_Infinity
suffix:colon
r_if
c_cond
(paren
id|signpositive
c_func
(paren
id|st1_ptr
)paren
)paren
id|arith_invalid
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Zero scaled by +Infinity */
r_return
suffix:semicolon
r_case
id|TW_NaN
suffix:colon
id|real_2op_NaN
c_func
(paren
id|st1_ptr
comma
id|st1_tag
comma
l_int|0
comma
id|st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_switch
c_cond
(paren
id|st1_tag
)paren
(brace
r_case
id|TAG_Valid
suffix:colon
r_case
id|TAG_Zero
suffix:colon
r_return
suffix:semicolon
r_case
id|TW_Denormal
suffix:colon
id|denormal_operand
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|TW_Infinity
suffix:colon
r_if
c_cond
(paren
id|signnegative
c_func
(paren
id|st1_ptr
)paren
)paren
id|arith_invalid
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Infinity scaled by -Infinity */
r_return
suffix:semicolon
r_case
id|TW_NaN
suffix:colon
id|real_2op_NaN
c_func
(paren
id|st1_ptr
comma
id|st1_tag
comma
l_int|0
comma
id|st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_NaN
)paren
(brace
r_if
c_cond
(paren
id|st1_tag
op_ne
id|TAG_Empty
)paren
(brace
id|real_2op_NaN
c_func
(paren
id|st1_ptr
comma
id|st1_tag
comma
l_int|0
comma
id|st0_ptr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#ifdef PARANOID
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|st0_tag
op_eq
id|TAG_Empty
)paren
op_logical_or
(paren
id|st1_tag
op_eq
id|TAG_Empty
)paren
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x115
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* At least one of st(0), st(1) must be empty */
id|FPU_stack_underflow
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*---------------------------------------------------------------------------*/
DECL|variable|trig_table_a
r_static
id|FUNC_ST0
r_const
id|trig_table_a
(braket
)braket
op_assign
(brace
id|f2xm1
comma
id|fyl2x
comma
id|fptan
comma
id|fpatan
comma
id|fxtract
comma
id|fprem1
comma
(paren
id|FUNC_ST0
)paren
id|fdecstp
comma
(paren
id|FUNC_ST0
)paren
id|fincstp
)brace
suffix:semicolon
DECL|function|FPU_triga
r_void
id|FPU_triga
c_func
(paren
r_void
)paren
(brace
(paren
id|trig_table_a
(braket
id|FPU_rm
)braket
)paren
(paren
op_amp
id|st
c_func
(paren
l_int|0
)paren
comma
id|FPU_gettag0
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
DECL|variable|trig_table_b
r_static
id|FUNC_ST0
r_const
id|trig_table_b
(braket
)braket
op_assign
(brace
id|fprem
comma
id|fyl2xp1
comma
id|fsqrt_
comma
id|fsincos
comma
id|frndint_
comma
id|fscale
comma
(paren
id|FUNC_ST0
)paren
id|fsin
comma
id|fcos
)brace
suffix:semicolon
DECL|function|FPU_trigb
r_void
id|FPU_trigb
c_func
(paren
r_void
)paren
(brace
(paren
id|trig_table_b
(braket
id|FPU_rm
)braket
)paren
(paren
op_amp
id|st
c_func
(paren
l_int|0
)paren
comma
id|FPU_gettag0
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
eof
