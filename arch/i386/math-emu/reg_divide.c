multiline_comment|/*---------------------------------------------------------------------------+&n; |  reg_divide.c                                                             |&n; |                                                                           |&n; | Divide one FPU_REG by another and put the result in a destination FPU_REG.|&n; |                                                                           |&n; | Copyright (C) 1996                                                        |&n; |                  W. Metzenthen, 22 Parker St, Ormond, Vic 3163, Australia |&n; |                  E-mail   billm@jacobi.maths.monash.edu.au                |&n; |                                                                           |&n; |    Return value is the tag of the answer, or-ed with FPU_Exception if     |&n; |    one was raised, or -1 on internal error.                               |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
multiline_comment|/*---------------------------------------------------------------------------+&n; | The destination may be any FPU_REG, including one of the source FPU_REGs. |&n; +---------------------------------------------------------------------------*/
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;reg_constant.h&quot;
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &quot;fpu_system.h&quot;
multiline_comment|/*&n;  Divide one register by another and put the result into a third register.&n;  */
DECL|function|FPU_div
r_int
id|FPU_div
c_func
(paren
r_int
id|flags
comma
r_int
id|rm
comma
r_int
id|control_w
)paren
(brace
id|FPU_REG
id|x
comma
id|y
suffix:semicolon
id|FPU_REG
r_const
op_star
id|a
comma
op_star
id|b
comma
op_star
id|st0_ptr
comma
op_star
id|st_ptr
suffix:semicolon
id|FPU_REG
op_star
id|dest
suffix:semicolon
id|u_char
id|taga
comma
id|tagb
comma
id|signa
comma
id|signb
comma
id|sign
comma
id|saved_sign
suffix:semicolon
r_int
id|tag
comma
id|deststnr
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|DEST_RM
)paren
id|deststnr
op_assign
id|rm
suffix:semicolon
r_else
id|deststnr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|REV
)paren
(brace
id|b
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|st0_ptr
op_assign
id|b
suffix:semicolon
id|tagb
op_assign
id|FPU_gettag0
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|LOADED
)paren
(brace
id|a
op_assign
(paren
id|FPU_REG
op_star
)paren
id|rm
suffix:semicolon
id|taga
op_assign
id|flags
op_amp
l_int|0x0f
suffix:semicolon
)brace
r_else
(brace
id|a
op_assign
op_amp
id|st
c_func
(paren
id|rm
)paren
suffix:semicolon
id|st_ptr
op_assign
id|a
suffix:semicolon
id|taga
op_assign
id|FPU_gettagi
c_func
(paren
id|rm
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|a
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|st0_ptr
op_assign
id|a
suffix:semicolon
id|taga
op_assign
id|FPU_gettag0
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|LOADED
)paren
(brace
id|b
op_assign
(paren
id|FPU_REG
op_star
)paren
id|rm
suffix:semicolon
id|tagb
op_assign
id|flags
op_amp
l_int|0x0f
suffix:semicolon
)brace
r_else
(brace
id|b
op_assign
op_amp
id|st
c_func
(paren
id|rm
)paren
suffix:semicolon
id|st_ptr
op_assign
id|b
suffix:semicolon
id|tagb
op_assign
id|FPU_gettagi
c_func
(paren
id|rm
)paren
suffix:semicolon
)brace
)brace
id|signa
op_assign
id|getsign
c_func
(paren
id|a
)paren
suffix:semicolon
id|signb
op_assign
id|getsign
c_func
(paren
id|b
)paren
suffix:semicolon
id|sign
op_assign
id|signa
op_xor
id|signb
suffix:semicolon
id|dest
op_assign
op_amp
id|st
c_func
(paren
id|deststnr
)paren
suffix:semicolon
id|saved_sign
op_assign
id|getsign
c_func
(paren
id|dest
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|taga
op_or
id|tagb
)paren
)paren
(brace
multiline_comment|/* Both regs Valid, this should be the most common case. */
id|reg_copy
c_func
(paren
id|a
comma
op_amp
id|x
)paren
suffix:semicolon
id|reg_copy
c_func
(paren
id|b
comma
op_amp
id|y
)paren
suffix:semicolon
id|setpositive
c_func
(paren
op_amp
id|x
)paren
suffix:semicolon
id|setpositive
c_func
(paren
op_amp
id|y
)paren
suffix:semicolon
id|tag
op_assign
id|FPU_u_div
c_func
(paren
op_amp
id|x
comma
op_amp
id|y
comma
id|dest
comma
id|control_w
comma
id|sign
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
OL
l_int|0
)paren
r_return
id|tag
suffix:semicolon
id|FPU_settagi
c_func
(paren
id|deststnr
comma
id|tag
)paren
suffix:semicolon
r_return
id|tag
suffix:semicolon
)brace
r_if
c_cond
(paren
id|taga
op_eq
id|TAG_Special
)paren
id|taga
op_assign
id|FPU_Special
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tagb
op_eq
id|TAG_Special
)paren
id|tagb
op_assign
id|FPU_Special
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|taga
op_eq
id|TAG_Valid
)paren
op_logical_and
(paren
id|tagb
op_eq
id|TW_Denormal
)paren
)paren
op_logical_or
(paren
(paren
id|taga
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|tagb
op_eq
id|TAG_Valid
)paren
)paren
op_logical_or
(paren
(paren
id|taga
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|tagb
op_eq
id|TW_Denormal
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
id|FPU_Exception
suffix:semicolon
id|FPU_to_exp16
c_func
(paren
id|a
comma
op_amp
id|x
)paren
suffix:semicolon
id|FPU_to_exp16
c_func
(paren
id|b
comma
op_amp
id|y
)paren
suffix:semicolon
id|tag
op_assign
id|FPU_u_div
c_func
(paren
op_amp
id|x
comma
op_amp
id|y
comma
id|dest
comma
id|control_w
comma
id|sign
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
OL
l_int|0
)paren
r_return
id|tag
suffix:semicolon
id|FPU_settagi
c_func
(paren
id|deststnr
comma
id|tag
)paren
suffix:semicolon
r_return
id|tag
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|taga
op_le
id|TW_Denormal
)paren
op_logical_and
(paren
id|tagb
op_le
id|TW_Denormal
)paren
)paren
(brace
r_if
c_cond
(paren
id|tagb
op_ne
id|TAG_Zero
)paren
(brace
multiline_comment|/* Want to find Zero/Valid */
r_if
c_cond
(paren
id|tagb
op_eq
id|TW_Denormal
)paren
(brace
r_if
c_cond
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
id|FPU_Exception
suffix:semicolon
)brace
multiline_comment|/* The result is zero. */
id|FPU_copy_to_regi
c_func
(paren
op_amp
id|CONST_Z
comma
id|TAG_Zero
comma
id|deststnr
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|dest
comma
id|sign
)paren
suffix:semicolon
r_return
id|TAG_Zero
suffix:semicolon
)brace
multiline_comment|/* We have an exception condition, either 0/0 or Valid/Zero. */
r_if
c_cond
(paren
id|taga
op_eq
id|TAG_Zero
)paren
(brace
multiline_comment|/* 0/0 */
r_return
id|arith_invalid
c_func
(paren
id|deststnr
)paren
suffix:semicolon
)brace
multiline_comment|/* Valid/Zero */
r_return
id|FPU_divide_by_zero
c_func
(paren
id|deststnr
comma
id|sign
)paren
suffix:semicolon
)brace
multiline_comment|/* Must have infinities, NaNs, etc */
r_else
r_if
c_cond
(paren
(paren
id|taga
op_eq
id|TW_NaN
)paren
op_logical_or
(paren
id|tagb
op_eq
id|TW_NaN
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|LOADED
)paren
r_return
id|real_2op_NaN
c_func
(paren
(paren
id|FPU_REG
op_star
)paren
id|rm
comma
id|flags
op_amp
l_int|0x0f
comma
l_int|0
comma
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|DEST_RM
)paren
(brace
r_int
id|tag
suffix:semicolon
id|tag
op_assign
id|FPU_gettag0
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|TAG_Special
)paren
id|tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_return
id|real_2op_NaN
c_func
(paren
id|st0_ptr
comma
id|tag
comma
id|rm
comma
(paren
id|flags
op_amp
id|REV
)paren
ques
c_cond
id|st0_ptr
suffix:colon
op_amp
id|st
c_func
(paren
id|rm
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|tag
suffix:semicolon
id|tag
op_assign
id|FPU_gettagi
c_func
(paren
id|rm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tag
op_eq
id|TAG_Special
)paren
id|tag
op_assign
id|FPU_Special
c_func
(paren
op_amp
id|st
c_func
(paren
id|rm
)paren
)paren
suffix:semicolon
r_return
id|real_2op_NaN
c_func
(paren
op_amp
id|st
c_func
(paren
id|rm
)paren
comma
id|tag
comma
l_int|0
comma
(paren
id|flags
op_amp
id|REV
)paren
ques
c_cond
id|st0_ptr
suffix:colon
op_amp
id|st
c_func
(paren
id|rm
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|taga
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
id|tagb
op_eq
id|TW_Infinity
)paren
(brace
multiline_comment|/* infinity/infinity */
r_return
id|arith_invalid
c_func
(paren
id|deststnr
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* tagb must be Valid or Zero */
r_if
c_cond
(paren
(paren
id|tagb
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
id|FPU_Exception
suffix:semicolon
multiline_comment|/* Infinity divided by Zero or Valid does&n;&t;     not raise and exception, but returns Infinity */
id|FPU_copy_to_regi
c_func
(paren
id|a
comma
id|TAG_Special
comma
id|deststnr
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|dest
comma
id|sign
)paren
suffix:semicolon
r_return
id|taga
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|tagb
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
(paren
id|taga
op_eq
id|TW_Denormal
)paren
op_logical_and
(paren
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
)paren
)paren
r_return
id|FPU_Exception
suffix:semicolon
multiline_comment|/* The result is zero. */
id|FPU_copy_to_regi
c_func
(paren
op_amp
id|CONST_Z
comma
id|TAG_Zero
comma
id|deststnr
)paren
suffix:semicolon
id|setsign
c_func
(paren
id|dest
comma
id|sign
)paren
suffix:semicolon
r_return
id|TAG_Zero
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
r_else
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x102
)paren
suffix:semicolon
r_return
id|FPU_Exception
suffix:semicolon
)brace
macro_line|#endif PARANOID
)brace
eof
