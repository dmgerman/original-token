multiline_comment|/*---------------------------------------------------------------------------+&n; |  reg_compare.c                                                            |&n; |                                                                           |&n; | Compare two floating point registers                                      |&n; |                                                                           |&n; | Copyright (C) 1992,1993,1994,1997                                         |&n; |                  W. Metzenthen, 22 Parker St, Ormond, Vic 3163, Australia |&n; |                  E-mail   billm@suburbia.net                              |&n; |                                                                           |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
multiline_comment|/*---------------------------------------------------------------------------+&n; | compare() is the core FPU_REG comparison function                         |&n; +---------------------------------------------------------------------------*/
macro_line|#include &quot;fpu_system.h&quot;
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &quot;control_w.h&quot;
macro_line|#include &quot;status_w.h&quot;
DECL|function|compare
r_static
r_int
id|compare
c_func
(paren
id|FPU_REG
r_const
op_star
id|b
comma
r_int
id|tagb
)paren
(brace
r_int
id|diff
comma
id|exp0
comma
id|expb
suffix:semicolon
id|u_char
id|st0_tag
suffix:semicolon
id|FPU_REG
op_star
id|st0_ptr
suffix:semicolon
id|FPU_REG
id|x
comma
id|y
suffix:semicolon
id|u_char
id|st0_sign
comma
id|signb
op_assign
id|getsign
c_func
(paren
id|b
)paren
suffix:semicolon
id|st0_ptr
op_assign
op_amp
id|st
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|st0_tag
op_assign
id|FPU_gettag0
c_func
(paren
)paren
suffix:semicolon
id|st0_sign
op_assign
id|getsign
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tagb
op_eq
id|TAG_Special
)paren
id|tagb
op_assign
id|FPU_Special
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Special
)paren
id|st0_tag
op_assign
id|FPU_Special
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|st0_tag
op_ne
id|TAG_Valid
)paren
op_logical_and
(paren
id|st0_tag
op_ne
id|TW_Denormal
)paren
)paren
op_logical_or
(paren
(paren
id|tagb
op_ne
id|TAG_Valid
)paren
op_logical_and
(paren
id|tagb
op_ne
id|TW_Denormal
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Zero
)paren
(brace
r_if
c_cond
(paren
id|tagb
op_eq
id|TAG_Zero
)paren
r_return
id|COMP_A_eq_B
suffix:semicolon
r_if
c_cond
(paren
id|tagb
op_eq
id|TAG_Valid
)paren
r_return
(paren
(paren
id|signb
op_eq
id|SIGN_POS
)paren
ques
c_cond
id|COMP_A_lt_B
suffix:colon
id|COMP_A_gt_B
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tagb
op_eq
id|TW_Denormal
)paren
r_return
(paren
(paren
id|signb
op_eq
id|SIGN_POS
)paren
ques
c_cond
id|COMP_A_lt_B
suffix:colon
id|COMP_A_gt_B
)paren
op_or
id|COMP_Denormal
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tagb
op_eq
id|TAG_Zero
)paren
(brace
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TAG_Valid
)paren
r_return
(paren
(paren
id|st0_sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
id|COMP_A_gt_B
suffix:colon
id|COMP_A_lt_B
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
r_return
(paren
(paren
id|st0_sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
id|COMP_A_gt_B
suffix:colon
id|COMP_A_lt_B
)paren
op_or
id|COMP_Denormal
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
(paren
id|tagb
op_eq
id|TAG_Valid
)paren
op_logical_or
(paren
id|tagb
op_eq
id|TAG_Zero
)paren
)paren
r_return
(paren
(paren
id|st0_sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
id|COMP_A_gt_B
suffix:colon
id|COMP_A_lt_B
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tagb
op_eq
id|TW_Denormal
)paren
r_return
(paren
(paren
id|st0_sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
id|COMP_A_gt_B
suffix:colon
id|COMP_A_lt_B
)paren
op_or
id|COMP_Denormal
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tagb
op_eq
id|TW_Infinity
)paren
(brace
multiline_comment|/* The 80486 book says that infinities can be equal! */
r_return
(paren
id|st0_sign
op_eq
id|signb
)paren
ques
c_cond
id|COMP_A_eq_B
suffix:colon
(paren
(paren
id|st0_sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
id|COMP_A_gt_B
suffix:colon
id|COMP_A_lt_B
)paren
suffix:semicolon
)brace
multiline_comment|/* Fall through to the NaN code */
)brace
r_else
r_if
c_cond
(paren
id|tagb
op_eq
id|TW_Infinity
)paren
(brace
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TAG_Valid
)paren
op_logical_or
(paren
id|st0_tag
op_eq
id|TAG_Zero
)paren
)paren
r_return
(paren
(paren
id|signb
op_eq
id|SIGN_POS
)paren
ques
c_cond
id|COMP_A_lt_B
suffix:colon
id|COMP_A_gt_B
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
r_return
(paren
(paren
id|signb
op_eq
id|SIGN_POS
)paren
ques
c_cond
id|COMP_A_lt_B
suffix:colon
id|COMP_A_gt_B
)paren
op_or
id|COMP_Denormal
suffix:semicolon
multiline_comment|/* Fall through to the NaN code */
)brace
multiline_comment|/* The only possibility now should be that one of the arguments&n;&t; is a NaN */
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TW_NaN
)paren
op_logical_or
(paren
id|tagb
op_eq
id|TW_NaN
)paren
)paren
(brace
r_int
id|signalling
op_assign
l_int|0
comma
id|unsupported
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|st0_tag
op_eq
id|TW_NaN
)paren
(brace
id|signalling
op_assign
(paren
id|st0_ptr-&gt;sigh
op_amp
l_int|0xc0000000
)paren
op_eq
l_int|0x80000000
suffix:semicolon
id|unsupported
op_assign
op_logical_neg
(paren
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
op_eq
id|EXP_OVER
)paren
op_logical_and
(paren
id|st0_ptr-&gt;sigh
op_amp
l_int|0x80000000
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tagb
op_eq
id|TW_NaN
)paren
(brace
id|signalling
op_or_assign
(paren
id|b-&gt;sigh
op_amp
l_int|0xc0000000
)paren
op_eq
l_int|0x80000000
suffix:semicolon
id|unsupported
op_or_assign
op_logical_neg
(paren
(paren
id|exponent
c_func
(paren
id|b
)paren
op_eq
id|EXP_OVER
)paren
op_logical_and
(paren
id|b-&gt;sigh
op_amp
l_int|0x80000000
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signalling
op_logical_or
id|unsupported
)paren
r_return
id|COMP_No_Comp
op_or
id|COMP_SNaN
op_or
id|COMP_NaN
suffix:semicolon
r_else
multiline_comment|/* Neither is a signaling NaN */
r_return
id|COMP_No_Comp
op_or
id|COMP_NaN
suffix:semicolon
)brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st0_sign
op_ne
id|signb
)paren
(brace
r_return
(paren
(paren
id|st0_sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
id|COMP_A_gt_B
suffix:colon
id|COMP_A_lt_B
)paren
op_or
(paren
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_or
(paren
id|tagb
op_eq
id|TW_Denormal
)paren
)paren
ques
c_cond
id|COMP_Denormal
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_or
(paren
id|tagb
op_eq
id|TW_Denormal
)paren
)paren
(brace
id|FPU_to_exp16
c_func
(paren
id|st0_ptr
comma
op_amp
id|x
)paren
suffix:semicolon
id|FPU_to_exp16
c_func
(paren
id|b
comma
op_amp
id|y
)paren
suffix:semicolon
id|st0_ptr
op_assign
op_amp
id|x
suffix:semicolon
id|b
op_assign
op_amp
id|y
suffix:semicolon
id|exp0
op_assign
id|exponent16
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
id|expb
op_assign
id|exponent16
c_func
(paren
id|b
)paren
suffix:semicolon
)brace
r_else
(brace
id|exp0
op_assign
id|exponent
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
id|expb
op_assign
id|exponent
c_func
(paren
id|b
)paren
suffix:semicolon
)brace
macro_line|#ifdef PARANOID
r_if
c_cond
(paren
op_logical_neg
(paren
id|st0_ptr-&gt;sigh
op_amp
l_int|0x80000000
)paren
)paren
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|b-&gt;sigh
op_amp
l_int|0x80000000
)paren
)paren
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
macro_line|#endif PARANOID
id|diff
op_assign
id|exp0
op_minus
id|expb
suffix:semicolon
r_if
c_cond
(paren
id|diff
op_eq
l_int|0
)paren
(brace
id|diff
op_assign
id|st0_ptr-&gt;sigh
op_minus
id|b-&gt;sigh
suffix:semicolon
multiline_comment|/* Works only if ms bits are&n;&t;&t;&t;&t;&t;      identical */
r_if
c_cond
(paren
id|diff
op_eq
l_int|0
)paren
(brace
id|diff
op_assign
id|st0_ptr-&gt;sigl
OG
id|b-&gt;sigl
suffix:semicolon
r_if
c_cond
(paren
id|diff
op_eq
l_int|0
)paren
id|diff
op_assign
op_minus
(paren
id|st0_ptr-&gt;sigl
OL
id|b-&gt;sigl
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|diff
OG
l_int|0
)paren
(brace
r_return
(paren
(paren
id|st0_sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
id|COMP_A_gt_B
suffix:colon
id|COMP_A_lt_B
)paren
op_or
(paren
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_or
(paren
id|tagb
op_eq
id|TW_Denormal
)paren
)paren
ques
c_cond
id|COMP_Denormal
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|diff
OL
l_int|0
)paren
(brace
r_return
(paren
(paren
id|st0_sign
op_eq
id|SIGN_POS
)paren
ques
c_cond
id|COMP_A_lt_B
suffix:colon
id|COMP_A_gt_B
)paren
op_or
(paren
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_or
(paren
id|tagb
op_eq
id|TW_Denormal
)paren
)paren
ques
c_cond
id|COMP_Denormal
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|COMP_A_eq_B
op_or
(paren
(paren
(paren
id|st0_tag
op_eq
id|TW_Denormal
)paren
op_logical_or
(paren
id|tagb
op_eq
id|TW_Denormal
)paren
)paren
ques
c_cond
id|COMP_Denormal
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* This function requires that st(0) is not empty */
DECL|function|FPU_compare_st_data
r_int
id|FPU_compare_st_data
c_func
(paren
id|FPU_REG
r_const
op_star
id|loaded_data
comma
id|u_char
id|loaded_tag
)paren
(brace
r_int
id|f
comma
id|c
suffix:semicolon
id|c
op_assign
id|compare
c_func
(paren
id|loaded_data
comma
id|loaded_tag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_amp
id|COMP_NaN
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
id|f
op_assign
id|SW_C3
op_or
id|SW_C2
op_or
id|SW_C0
suffix:semicolon
)brace
r_else
r_switch
c_cond
(paren
id|c
op_amp
l_int|7
)paren
(brace
r_case
id|COMP_A_lt_B
suffix:colon
id|f
op_assign
id|SW_C0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMP_A_eq_B
suffix:colon
id|f
op_assign
id|SW_C3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMP_A_gt_B
suffix:colon
id|f
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMP_No_Comp
suffix:colon
id|f
op_assign
id|SW_C3
op_or
id|SW_C2
op_or
id|SW_C0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef PARANOID
r_default
suffix:colon
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x121
)paren
suffix:semicolon
id|f
op_assign
id|SW_C3
op_or
id|SW_C2
op_or
id|SW_C0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif PARANOID
)brace
id|setcc
c_func
(paren
id|f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_amp
id|COMP_Denormal
)paren
(brace
r_return
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|compare_st_st
r_static
r_int
id|compare_st_st
c_func
(paren
r_int
id|nr
)paren
(brace
r_int
id|f
comma
id|c
suffix:semicolon
id|FPU_REG
op_star
id|st_ptr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NOT_EMPTY
c_func
(paren
l_int|0
)paren
op_logical_or
op_logical_neg
id|NOT_EMPTY
c_func
(paren
id|nr
)paren
)paren
(brace
id|setcc
c_func
(paren
id|SW_C3
op_or
id|SW_C2
op_or
id|SW_C0
)paren
suffix:semicolon
multiline_comment|/* Stack fault */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_return
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
suffix:semicolon
)brace
id|st_ptr
op_assign
op_amp
id|st
c_func
(paren
id|nr
)paren
suffix:semicolon
id|c
op_assign
id|compare
c_func
(paren
id|st_ptr
comma
id|FPU_gettagi
c_func
(paren
id|nr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_amp
id|COMP_NaN
)paren
(brace
id|setcc
c_func
(paren
id|SW_C3
op_or
id|SW_C2
op_or
id|SW_C0
)paren
suffix:semicolon
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_return
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
suffix:semicolon
)brace
r_else
r_switch
c_cond
(paren
id|c
op_amp
l_int|7
)paren
(brace
r_case
id|COMP_A_lt_B
suffix:colon
id|f
op_assign
id|SW_C0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMP_A_eq_B
suffix:colon
id|f
op_assign
id|SW_C3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMP_A_gt_B
suffix:colon
id|f
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMP_No_Comp
suffix:colon
id|f
op_assign
id|SW_C3
op_or
id|SW_C2
op_or
id|SW_C0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef PARANOID
r_default
suffix:colon
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x122
)paren
suffix:semicolon
id|f
op_assign
id|SW_C3
op_or
id|SW_C2
op_or
id|SW_C0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif PARANOID
)brace
id|setcc
c_func
(paren
id|f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_amp
id|COMP_Denormal
)paren
(brace
r_return
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|compare_u_st_st
r_static
r_int
id|compare_u_st_st
c_func
(paren
r_int
id|nr
)paren
(brace
r_int
id|f
comma
id|c
suffix:semicolon
id|FPU_REG
op_star
id|st_ptr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NOT_EMPTY
c_func
(paren
l_int|0
)paren
op_logical_or
op_logical_neg
id|NOT_EMPTY
c_func
(paren
id|nr
)paren
)paren
(brace
id|setcc
c_func
(paren
id|SW_C3
op_or
id|SW_C2
op_or
id|SW_C0
)paren
suffix:semicolon
multiline_comment|/* Stack fault */
id|EXCEPTION
c_func
(paren
id|EX_StackUnder
)paren
suffix:semicolon
r_return
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
suffix:semicolon
)brace
id|st_ptr
op_assign
op_amp
id|st
c_func
(paren
id|nr
)paren
suffix:semicolon
id|c
op_assign
id|compare
c_func
(paren
id|st_ptr
comma
id|FPU_gettagi
c_func
(paren
id|nr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_amp
id|COMP_NaN
)paren
(brace
id|setcc
c_func
(paren
id|SW_C3
op_or
id|SW_C2
op_or
id|SW_C0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_amp
id|COMP_SNaN
)paren
multiline_comment|/* This is the only difference between&n;&t;&t;&t;&t;  un-ordered and ordinary comparisons */
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
r_return
op_logical_neg
(paren
id|control_word
op_amp
id|CW_Invalid
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_switch
c_cond
(paren
id|c
op_amp
l_int|7
)paren
(brace
r_case
id|COMP_A_lt_B
suffix:colon
id|f
op_assign
id|SW_C0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMP_A_eq_B
suffix:colon
id|f
op_assign
id|SW_C3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMP_A_gt_B
suffix:colon
id|f
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMP_No_Comp
suffix:colon
id|f
op_assign
id|SW_C3
op_or
id|SW_C2
op_or
id|SW_C0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef PARANOID
r_default
suffix:colon
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x123
)paren
suffix:semicolon
id|f
op_assign
id|SW_C3
op_or
id|SW_C2
op_or
id|SW_C0
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif PARANOID
)brace
id|setcc
c_func
(paren
id|f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_amp
id|COMP_Denormal
)paren
(brace
r_return
id|denormal_operand
c_func
(paren
)paren
OL
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*---------------------------------------------------------------------------*/
DECL|function|fcom_st
r_void
id|fcom_st
c_func
(paren
)paren
(brace
multiline_comment|/* fcom st(i) */
id|compare_st_st
c_func
(paren
id|FPU_rm
)paren
suffix:semicolon
)brace
DECL|function|fcompst
r_void
id|fcompst
c_func
(paren
)paren
(brace
multiline_comment|/* fcomp st(i) */
r_if
c_cond
(paren
op_logical_neg
id|compare_st_st
c_func
(paren
id|FPU_rm
)paren
)paren
id|FPU_pop
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fcompp
r_void
id|fcompp
c_func
(paren
)paren
(brace
multiline_comment|/* fcompp */
r_if
c_cond
(paren
id|FPU_rm
op_ne
l_int|1
)paren
(brace
id|FPU_illegal
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|compare_st_st
c_func
(paren
l_int|1
)paren
)paren
id|poppop
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fucom_
r_void
id|fucom_
c_func
(paren
)paren
(brace
multiline_comment|/* fucom st(i) */
id|compare_u_st_st
c_func
(paren
id|FPU_rm
)paren
suffix:semicolon
)brace
DECL|function|fucomp
r_void
id|fucomp
c_func
(paren
)paren
(brace
multiline_comment|/* fucomp st(i) */
r_if
c_cond
(paren
op_logical_neg
id|compare_u_st_st
c_func
(paren
id|FPU_rm
)paren
)paren
id|FPU_pop
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fucompp
r_void
id|fucompp
c_func
(paren
)paren
(brace
multiline_comment|/* fucompp */
r_if
c_cond
(paren
id|FPU_rm
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|compare_u_st_st
c_func
(paren
l_int|1
)paren
)paren
id|poppop
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|FPU_illegal
c_func
(paren
)paren
suffix:semicolon
)brace
eof
