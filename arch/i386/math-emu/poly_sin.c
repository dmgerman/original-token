multiline_comment|/*---------------------------------------------------------------------------+&n; |  poly_sin.c                                                               |&n; |                                                                           |&n; |  Computation of an approximation of the sin function and the cosine       |&n; |  function by a polynomial.                                                |&n; |                                                                           |&n; | Copyright (C) 1992,1993,1994,1997,1999                                    |&n; |                  W. Metzenthen, 22 Parker St, Ormond, Vic 3163, Australia |&n; |                  E-mail   billm@melbpc.org.au                             |&n; |                                                                           |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;reg_constant.h&quot;
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &quot;fpu_system.h&quot;
macro_line|#include &quot;control_w.h&quot;
macro_line|#include &quot;poly.h&quot;
DECL|macro|N_COEFF_P
mdefine_line|#define&t;N_COEFF_P&t;4
DECL|macro|N_COEFF_N
mdefine_line|#define&t;N_COEFF_N&t;4
DECL|variable|pos_terms_l
r_static
r_const
r_int
r_int
r_int
id|pos_terms_l
(braket
id|N_COEFF_P
)braket
op_assign
(brace
l_int|0xaaaaaaaaaaaaaaabLL
comma
l_int|0x00d00d00d00cf906LL
comma
l_int|0x000006b99159a8bbLL
comma
l_int|0x000000000d7392e6LL
)brace
suffix:semicolon
DECL|variable|neg_terms_l
r_static
r_const
r_int
r_int
r_int
id|neg_terms_l
(braket
id|N_COEFF_N
)braket
op_assign
(brace
l_int|0x2222222222222167LL
comma
l_int|0x0002e3bc74aab624LL
comma
l_int|0x0000000b09229062LL
comma
l_int|0x00000000000c7973LL
)brace
suffix:semicolon
DECL|macro|N_COEFF_PH
mdefine_line|#define&t;N_COEFF_PH&t;4
DECL|macro|N_COEFF_NH
mdefine_line|#define&t;N_COEFF_NH&t;4
DECL|variable|pos_terms_h
r_static
r_const
r_int
r_int
r_int
id|pos_terms_h
(braket
id|N_COEFF_PH
)braket
op_assign
(brace
l_int|0x0000000000000000LL
comma
l_int|0x05b05b05b05b0406LL
comma
l_int|0x000049f93edd91a9LL
comma
l_int|0x00000000c9c9ed62LL
)brace
suffix:semicolon
DECL|variable|neg_terms_h
r_static
r_const
r_int
r_int
r_int
id|neg_terms_h
(braket
id|N_COEFF_NH
)braket
op_assign
(brace
l_int|0xaaaaaaaaaaaaaa98LL
comma
l_int|0x001a01a01a019064LL
comma
l_int|0x0000008f76c68a77LL
comma
l_int|0x0000000000d58f5eLL
)brace
suffix:semicolon
multiline_comment|/*--- poly_sine() -----------------------------------------------------------+&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
DECL|function|poly_sine
r_void
id|poly_sine
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
)paren
(brace
r_int
id|exponent
comma
id|echange
suffix:semicolon
id|Xsig
id|accumulator
comma
id|argSqrd
comma
id|argTo4
suffix:semicolon
r_int
r_int
id|fix_up
comma
id|adj
suffix:semicolon
r_int
r_int
r_int
id|fixed_arg
suffix:semicolon
id|FPU_REG
id|result
suffix:semicolon
id|exponent
op_assign
id|exponent
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
id|accumulator.lsw
op_assign
id|accumulator.midw
op_assign
id|accumulator.msw
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Split into two ranges, for arguments below and above 1.0 */
multiline_comment|/* The boundary between upper and lower is approx 0.88309101259 */
r_if
c_cond
(paren
(paren
id|exponent
OL
op_minus
l_int|1
)paren
op_logical_or
(paren
(paren
id|exponent
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
id|st0_ptr-&gt;sigh
op_le
l_int|0xe21240aa
)paren
)paren
)paren
(brace
multiline_comment|/* The argument is &lt;= 0.88309101259 */
id|argSqrd.msw
op_assign
id|st0_ptr-&gt;sigh
suffix:semicolon
id|argSqrd.midw
op_assign
id|st0_ptr-&gt;sigl
suffix:semicolon
id|argSqrd.lsw
op_assign
l_int|0
suffix:semicolon
id|mul64_Xsig
c_func
(paren
op_amp
id|argSqrd
comma
op_amp
id|significand
c_func
(paren
id|st0_ptr
)paren
)paren
suffix:semicolon
id|shr_Xsig
c_func
(paren
op_amp
id|argSqrd
comma
l_int|2
op_star
(paren
op_minus
l_int|1
op_minus
id|exponent
)paren
)paren
suffix:semicolon
id|argTo4.msw
op_assign
id|argSqrd.msw
suffix:semicolon
id|argTo4.midw
op_assign
id|argSqrd.midw
suffix:semicolon
id|argTo4.lsw
op_assign
id|argSqrd.lsw
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|argTo4
comma
op_amp
id|argTo4
)paren
suffix:semicolon
id|polynomial_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|XSIG_LL
c_func
(paren
id|argTo4
)paren
comma
id|neg_terms_l
comma
id|N_COEFF_N
op_minus
l_int|1
)paren
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|argSqrd
)paren
suffix:semicolon
id|negate_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
id|polynomial_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|XSIG_LL
c_func
(paren
id|argTo4
)paren
comma
id|pos_terms_l
comma
id|N_COEFF_P
op_minus
l_int|1
)paren
suffix:semicolon
id|shr_Xsig
c_func
(paren
op_amp
id|accumulator
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Divide by four */
id|accumulator.msw
op_or_assign
l_int|0x80000000
suffix:semicolon
multiline_comment|/* Add 1.0 */
id|mul64_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|significand
c_func
(paren
id|st0_ptr
)paren
)paren
suffix:semicolon
id|mul64_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|significand
c_func
(paren
id|st0_ptr
)paren
)paren
suffix:semicolon
id|mul64_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|significand
c_func
(paren
id|st0_ptr
)paren
)paren
suffix:semicolon
multiline_comment|/* Divide by four, FPU_REG compatible, etc */
id|exponent
op_assign
l_int|3
op_star
id|exponent
suffix:semicolon
multiline_comment|/* The minimum exponent difference is 3 */
id|shr_Xsig
c_func
(paren
op_amp
id|accumulator
comma
id|exponent
c_func
(paren
id|st0_ptr
)paren
op_minus
id|exponent
)paren
suffix:semicolon
id|negate_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
id|XSIG_LL
c_func
(paren
id|accumulator
)paren
op_add_assign
id|significand
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
id|echange
op_assign
id|round_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
id|setexponentpos
c_func
(paren
op_amp
id|result
comma
id|exponent
c_func
(paren
id|st0_ptr
)paren
op_plus
id|echange
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The argument is &gt; 0.88309101259 */
multiline_comment|/* We use sin(st(0)) = cos(pi/2-st(0)) */
id|fixed_arg
op_assign
id|significand
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exponent
op_eq
l_int|0
)paren
(brace
multiline_comment|/* The argument is &gt;= 1.0 */
multiline_comment|/* Put the binary point at the left. */
id|fixed_arg
op_lshift_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* pi/2 in hex is: 1.921fb54442d18469 898CC51701B839A2 52049C1 */
id|fixed_arg
op_assign
l_int|0x921fb54442d18469LL
op_minus
id|fixed_arg
suffix:semicolon
multiline_comment|/* There is a special case which arises due to rounding, to fix here. */
r_if
c_cond
(paren
id|fixed_arg
op_eq
l_int|0xffffffffffffffffLL
)paren
id|fixed_arg
op_assign
l_int|0
suffix:semicolon
id|XSIG_LL
c_func
(paren
id|argSqrd
)paren
op_assign
id|fixed_arg
suffix:semicolon
id|argSqrd.lsw
op_assign
l_int|0
suffix:semicolon
id|mul64_Xsig
c_func
(paren
op_amp
id|argSqrd
comma
op_amp
id|fixed_arg
)paren
suffix:semicolon
id|XSIG_LL
c_func
(paren
id|argTo4
)paren
op_assign
id|XSIG_LL
c_func
(paren
id|argSqrd
)paren
suffix:semicolon
id|argTo4.lsw
op_assign
id|argSqrd.lsw
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|argTo4
comma
op_amp
id|argTo4
)paren
suffix:semicolon
id|polynomial_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|XSIG_LL
c_func
(paren
id|argTo4
)paren
comma
id|neg_terms_h
comma
id|N_COEFF_NH
op_minus
l_int|1
)paren
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|argSqrd
)paren
suffix:semicolon
id|negate_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
id|polynomial_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|XSIG_LL
c_func
(paren
id|argTo4
)paren
comma
id|pos_terms_h
comma
id|N_COEFF_PH
op_minus
l_int|1
)paren
suffix:semicolon
id|negate_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
id|mul64_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|fixed_arg
)paren
suffix:semicolon
id|mul64_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|fixed_arg
)paren
suffix:semicolon
id|shr_Xsig
c_func
(paren
op_amp
id|accumulator
comma
l_int|3
)paren
suffix:semicolon
id|negate_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
id|add_Xsig_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|argSqrd
)paren
suffix:semicolon
id|shr_Xsig
c_func
(paren
op_amp
id|accumulator
comma
l_int|1
)paren
suffix:semicolon
id|accumulator.lsw
op_or_assign
l_int|1
suffix:semicolon
multiline_comment|/* A zero accumulator here would cause problems */
id|negate_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
multiline_comment|/* The basic computation is complete. Now fix the answer to&n;&t; compensate for the error due to the approximation used for&n;&t; pi/2&n;&t; */
multiline_comment|/* This has an exponent of -65 */
id|fix_up
op_assign
l_int|0x898cc517
suffix:semicolon
multiline_comment|/* The fix-up needs to be improved for larger args */
r_if
c_cond
(paren
id|argSqrd.msw
op_amp
l_int|0xffc00000
)paren
(brace
multiline_comment|/* Get about 32 bit precision in these: */
id|fix_up
op_sub_assign
id|mul_32_32
c_func
(paren
l_int|0x898cc517
comma
id|argSqrd.msw
)paren
op_div
l_int|6
suffix:semicolon
)brace
id|fix_up
op_assign
id|mul_32_32
c_func
(paren
id|fix_up
comma
id|LL_MSW
c_func
(paren
id|fixed_arg
)paren
)paren
suffix:semicolon
id|adj
op_assign
id|accumulator.lsw
suffix:semicolon
multiline_comment|/* temp save */
id|accumulator.lsw
op_sub_assign
id|fix_up
suffix:semicolon
r_if
c_cond
(paren
id|accumulator.lsw
OG
id|adj
)paren
id|XSIG_LL
c_func
(paren
id|accumulator
)paren
op_decrement
suffix:semicolon
id|echange
op_assign
id|round_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
id|setexponentpos
c_func
(paren
op_amp
id|result
comma
id|echange
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|significand
c_func
(paren
op_amp
id|result
)paren
op_assign
id|XSIG_LL
c_func
(paren
id|accumulator
)paren
suffix:semicolon
id|setsign
c_func
(paren
op_amp
id|result
comma
id|getsign
c_func
(paren
id|st0_ptr
)paren
)paren
suffix:semicolon
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|result
comma
id|TAG_Valid
)paren
suffix:semicolon
macro_line|#ifdef PARANOID
r_if
c_cond
(paren
(paren
id|exponent
c_func
(paren
op_amp
id|result
)paren
op_ge
l_int|0
)paren
op_logical_and
(paren
id|significand
c_func
(paren
op_amp
id|result
)paren
OG
l_int|0x8000000000000000LL
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x150
)paren
suffix:semicolon
)brace
macro_line|#endif PARANOID
)brace
multiline_comment|/*--- poly_cos() ------------------------------------------------------------+&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
DECL|function|poly_cos
r_void
id|poly_cos
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
)paren
(brace
id|FPU_REG
id|result
suffix:semicolon
r_int
r_int
id|exponent
comma
id|exp2
comma
id|echange
suffix:semicolon
id|Xsig
id|accumulator
comma
id|argSqrd
comma
id|fix_up
comma
id|argTo4
suffix:semicolon
r_int
r_int
r_int
id|fixed_arg
suffix:semicolon
macro_line|#ifdef PARANOID
r_if
c_cond
(paren
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
OG
l_int|0
)paren
op_logical_or
(paren
(paren
id|exponent
c_func
(paren
id|st0_ptr
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|significand
c_func
(paren
id|st0_ptr
)paren
OG
l_int|0xc90fdaa22168c234LL
)paren
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_Invalid
)paren
suffix:semicolon
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|CONST_QNaN
comma
id|TAG_Special
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif PARANOID
id|exponent
op_assign
id|exponent
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
id|accumulator.lsw
op_assign
id|accumulator.midw
op_assign
id|accumulator.msw
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|exponent
OL
op_minus
l_int|1
)paren
op_logical_or
(paren
(paren
id|exponent
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
id|st0_ptr-&gt;sigh
op_le
l_int|0xb00d6f54
)paren
)paren
)paren
(brace
multiline_comment|/* arg is &lt; 0.687705 */
id|argSqrd.msw
op_assign
id|st0_ptr-&gt;sigh
suffix:semicolon
id|argSqrd.midw
op_assign
id|st0_ptr-&gt;sigl
suffix:semicolon
id|argSqrd.lsw
op_assign
l_int|0
suffix:semicolon
id|mul64_Xsig
c_func
(paren
op_amp
id|argSqrd
comma
op_amp
id|significand
c_func
(paren
id|st0_ptr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exponent
OL
op_minus
l_int|1
)paren
(brace
multiline_comment|/* shift the argument right by the required places */
id|shr_Xsig
c_func
(paren
op_amp
id|argSqrd
comma
l_int|2
op_star
(paren
op_minus
l_int|1
op_minus
id|exponent
)paren
)paren
suffix:semicolon
)brace
id|argTo4.msw
op_assign
id|argSqrd.msw
suffix:semicolon
id|argTo4.midw
op_assign
id|argSqrd.midw
suffix:semicolon
id|argTo4.lsw
op_assign
id|argSqrd.lsw
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|argTo4
comma
op_amp
id|argTo4
)paren
suffix:semicolon
id|polynomial_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|XSIG_LL
c_func
(paren
id|argTo4
)paren
comma
id|neg_terms_h
comma
id|N_COEFF_NH
op_minus
l_int|1
)paren
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|argSqrd
)paren
suffix:semicolon
id|negate_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
id|polynomial_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|XSIG_LL
c_func
(paren
id|argTo4
)paren
comma
id|pos_terms_h
comma
id|N_COEFF_PH
op_minus
l_int|1
)paren
suffix:semicolon
id|negate_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
id|mul64_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|significand
c_func
(paren
id|st0_ptr
)paren
)paren
suffix:semicolon
id|mul64_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|significand
c_func
(paren
id|st0_ptr
)paren
)paren
suffix:semicolon
id|shr_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_minus
l_int|2
op_star
(paren
l_int|1
op_plus
id|exponent
)paren
)paren
suffix:semicolon
id|shr_Xsig
c_func
(paren
op_amp
id|accumulator
comma
l_int|3
)paren
suffix:semicolon
id|negate_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
id|add_Xsig_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|argSqrd
)paren
suffix:semicolon
id|shr_Xsig
c_func
(paren
op_amp
id|accumulator
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* It doesn&squot;t matter if accumulator is all zero here, the&n;&t; following code will work ok */
id|negate_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
r_if
c_cond
(paren
id|accumulator.lsw
op_amp
l_int|0x80000000
)paren
id|XSIG_LL
c_func
(paren
id|accumulator
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|accumulator.msw
op_eq
l_int|0
)paren
(brace
multiline_comment|/* The result is 1.0 */
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|CONST_1
comma
id|TAG_Valid
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|significand
c_func
(paren
op_amp
id|result
)paren
op_assign
id|XSIG_LL
c_func
(paren
id|accumulator
)paren
suffix:semicolon
multiline_comment|/* will be a valid positive nr with expon = -1 */
id|setexponentpos
c_func
(paren
op_amp
id|result
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|fixed_arg
op_assign
id|significand
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exponent
op_eq
l_int|0
)paren
(brace
multiline_comment|/* The argument is &gt;= 1.0 */
multiline_comment|/* Put the binary point at the left. */
id|fixed_arg
op_lshift_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* pi/2 in hex is: 1.921fb54442d18469 898CC51701B839A2 52049C1 */
id|fixed_arg
op_assign
l_int|0x921fb54442d18469LL
op_minus
id|fixed_arg
suffix:semicolon
multiline_comment|/* There is a special case which arises due to rounding, to fix here. */
r_if
c_cond
(paren
id|fixed_arg
op_eq
l_int|0xffffffffffffffffLL
)paren
id|fixed_arg
op_assign
l_int|0
suffix:semicolon
id|exponent
op_assign
op_minus
l_int|1
suffix:semicolon
id|exp2
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* A shift is needed here only for a narrow range of arguments,&n;&t; i.e. for fixed_arg approx 2^-32, but we pick up more... */
r_if
c_cond
(paren
op_logical_neg
(paren
id|LL_MSW
c_func
(paren
id|fixed_arg
)paren
op_amp
l_int|0xffff0000
)paren
)paren
(brace
id|fixed_arg
op_lshift_assign
l_int|16
suffix:semicolon
id|exponent
op_sub_assign
l_int|16
suffix:semicolon
id|exp2
op_sub_assign
l_int|16
suffix:semicolon
)brace
id|XSIG_LL
c_func
(paren
id|argSqrd
)paren
op_assign
id|fixed_arg
suffix:semicolon
id|argSqrd.lsw
op_assign
l_int|0
suffix:semicolon
id|mul64_Xsig
c_func
(paren
op_amp
id|argSqrd
comma
op_amp
id|fixed_arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exponent
OL
op_minus
l_int|1
)paren
(brace
multiline_comment|/* shift the argument right by the required places */
id|shr_Xsig
c_func
(paren
op_amp
id|argSqrd
comma
l_int|2
op_star
(paren
op_minus
l_int|1
op_minus
id|exponent
)paren
)paren
suffix:semicolon
)brace
id|argTo4.msw
op_assign
id|argSqrd.msw
suffix:semicolon
id|argTo4.midw
op_assign
id|argSqrd.midw
suffix:semicolon
id|argTo4.lsw
op_assign
id|argSqrd.lsw
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|argTo4
comma
op_amp
id|argTo4
)paren
suffix:semicolon
id|polynomial_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|XSIG_LL
c_func
(paren
id|argTo4
)paren
comma
id|neg_terms_l
comma
id|N_COEFF_N
op_minus
l_int|1
)paren
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|argSqrd
)paren
suffix:semicolon
id|negate_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
id|polynomial_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|XSIG_LL
c_func
(paren
id|argTo4
)paren
comma
id|pos_terms_l
comma
id|N_COEFF_P
op_minus
l_int|1
)paren
suffix:semicolon
id|shr_Xsig
c_func
(paren
op_amp
id|accumulator
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Divide by four */
id|accumulator.msw
op_or_assign
l_int|0x80000000
suffix:semicolon
multiline_comment|/* Add 1.0 */
id|mul64_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|fixed_arg
)paren
suffix:semicolon
id|mul64_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|fixed_arg
)paren
suffix:semicolon
id|mul64_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|fixed_arg
)paren
suffix:semicolon
multiline_comment|/* Divide by four, FPU_REG compatible, etc */
id|exponent
op_assign
l_int|3
op_star
id|exponent
suffix:semicolon
multiline_comment|/* The minimum exponent difference is 3 */
id|shr_Xsig
c_func
(paren
op_amp
id|accumulator
comma
id|exp2
op_minus
id|exponent
)paren
suffix:semicolon
id|negate_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
id|XSIG_LL
c_func
(paren
id|accumulator
)paren
op_add_assign
id|fixed_arg
suffix:semicolon
multiline_comment|/* The basic computation is complete. Now fix the answer to&n;&t; compensate for the error due to the approximation used for&n;&t; pi/2&n;&t; */
multiline_comment|/* This has an exponent of -65 */
id|XSIG_LL
c_func
(paren
id|fix_up
)paren
op_assign
l_int|0x898cc51701b839a2ll
suffix:semicolon
id|fix_up.lsw
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* The fix-up needs to be improved for larger args */
r_if
c_cond
(paren
id|argSqrd.msw
op_amp
l_int|0xffc00000
)paren
(brace
multiline_comment|/* Get about 32 bit precision in these: */
id|fix_up.msw
op_sub_assign
id|mul_32_32
c_func
(paren
l_int|0x898cc517
comma
id|argSqrd.msw
)paren
op_div
l_int|2
suffix:semicolon
id|fix_up.msw
op_add_assign
id|mul_32_32
c_func
(paren
l_int|0x898cc517
comma
id|argTo4.msw
)paren
op_div
l_int|24
suffix:semicolon
)brace
id|exp2
op_add_assign
id|norm_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
id|shr_Xsig
c_func
(paren
op_amp
id|accumulator
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Prevent overflow */
id|exp2
op_increment
suffix:semicolon
id|shr_Xsig
c_func
(paren
op_amp
id|fix_up
comma
l_int|65
op_plus
id|exp2
)paren
suffix:semicolon
id|add_Xsig_Xsig
c_func
(paren
op_amp
id|accumulator
comma
op_amp
id|fix_up
)paren
suffix:semicolon
id|echange
op_assign
id|round_Xsig
c_func
(paren
op_amp
id|accumulator
)paren
suffix:semicolon
id|setexponentpos
c_func
(paren
op_amp
id|result
comma
id|exp2
op_plus
id|echange
)paren
suffix:semicolon
id|significand
c_func
(paren
op_amp
id|result
)paren
op_assign
id|XSIG_LL
c_func
(paren
id|accumulator
)paren
suffix:semicolon
)brace
id|FPU_copy_to_reg0
c_func
(paren
op_amp
id|result
comma
id|TAG_Valid
)paren
suffix:semicolon
macro_line|#ifdef PARANOID
r_if
c_cond
(paren
(paren
id|exponent
c_func
(paren
op_amp
id|result
)paren
op_ge
l_int|0
)paren
op_logical_and
(paren
id|significand
c_func
(paren
op_amp
id|result
)paren
OG
l_int|0x8000000000000000LL
)paren
)paren
(brace
id|EXCEPTION
c_func
(paren
id|EX_INTERNAL
op_or
l_int|0x151
)paren
suffix:semicolon
)brace
macro_line|#endif PARANOID
)brace
eof
