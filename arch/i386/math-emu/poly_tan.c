multiline_comment|/*---------------------------------------------------------------------------+&n; |  poly_tan.c                                                               |&n; |                                                                           |&n; | Compute the tan of a FPU_REG, using a polynomial approximation.           |&n; |                                                                           |&n; | Copyright (C) 1992,1993,1994,1997,1999                                    |&n; |                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,      |&n; |                       Australia.  E-mail   billm@melbpc.org.au            |&n; |                                                                           |&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
macro_line|#include &quot;exception.h&quot;
macro_line|#include &quot;reg_constant.h&quot;
macro_line|#include &quot;fpu_emu.h&quot;
macro_line|#include &quot;fpu_system.h&quot;
macro_line|#include &quot;control_w.h&quot;
macro_line|#include &quot;poly.h&quot;
DECL|macro|HiPOWERop
mdefine_line|#define&t;HiPOWERop&t;3&t;/* odd poly, positive terms */
DECL|variable|oddplterm
r_static
r_const
r_int
r_int
r_int
id|oddplterm
(braket
id|HiPOWERop
)braket
op_assign
(brace
l_int|0x0000000000000000LL
comma
l_int|0x0051a1cf08fca228LL
comma
l_int|0x0000000071284ff7LL
)brace
suffix:semicolon
DECL|macro|HiPOWERon
mdefine_line|#define&t;HiPOWERon&t;2&t;/* odd poly, negative terms */
DECL|variable|oddnegterm
r_static
r_const
r_int
r_int
r_int
id|oddnegterm
(braket
id|HiPOWERon
)braket
op_assign
(brace
l_int|0x1291a9a184244e80LL
comma
l_int|0x0000583245819c21LL
)brace
suffix:semicolon
DECL|macro|HiPOWERep
mdefine_line|#define&t;HiPOWERep&t;2&t;/* even poly, positive terms */
DECL|variable|evenplterm
r_static
r_const
r_int
r_int
r_int
id|evenplterm
(braket
id|HiPOWERep
)braket
op_assign
(brace
l_int|0x0e848884b539e888LL
comma
l_int|0x00003c7f18b887daLL
)brace
suffix:semicolon
DECL|macro|HiPOWERen
mdefine_line|#define&t;HiPOWERen&t;2&t;/* even poly, negative terms */
DECL|variable|evennegterm
r_static
r_const
r_int
r_int
r_int
id|evennegterm
(braket
id|HiPOWERen
)braket
op_assign
(brace
l_int|0xf1f0200fd51569ccLL
comma
l_int|0x003afb46105c4432LL
)brace
suffix:semicolon
DECL|variable|twothirds
r_static
r_const
r_int
r_int
r_int
id|twothirds
op_assign
l_int|0xaaaaaaaaaaaaaaabLL
suffix:semicolon
multiline_comment|/*--- poly_tan() ------------------------------------------------------------+&n; |                                                                           |&n; +---------------------------------------------------------------------------*/
DECL|function|poly_tan
r_void
id|poly_tan
c_func
(paren
id|FPU_REG
op_star
id|st0_ptr
)paren
(brace
r_int
r_int
id|exponent
suffix:semicolon
r_int
id|invert
suffix:semicolon
id|Xsig
id|argSq
comma
id|argSqSq
comma
id|accumulatoro
comma
id|accumulatore
comma
id|accum
comma
id|argSignif
comma
id|fix_up
suffix:semicolon
r_int
r_int
id|adj
suffix:semicolon
id|exponent
op_assign
id|exponent
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
macro_line|#ifdef PARANOID
r_if
c_cond
(paren
id|signnegative
c_func
(paren
id|st0_ptr
)paren
)paren
multiline_comment|/* Can&squot;t hack a number &lt; 0.0 */
(brace
id|arith_invalid
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Need a positive number */
macro_line|#endif PARANOID
multiline_comment|/* Split the problem into two domains, smaller and larger than pi/4 */
r_if
c_cond
(paren
(paren
id|exponent
op_eq
l_int|0
)paren
op_logical_or
(paren
(paren
id|exponent
op_eq
op_minus
l_int|1
)paren
op_logical_and
(paren
id|st0_ptr-&gt;sigh
OG
l_int|0xc90fdaa2
)paren
)paren
)paren
(brace
multiline_comment|/* The argument is greater than (approx) pi/4 */
id|invert
op_assign
l_int|1
suffix:semicolon
id|accum.lsw
op_assign
l_int|0
suffix:semicolon
id|XSIG_LL
c_func
(paren
id|accum
)paren
op_assign
id|significand
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exponent
op_eq
l_int|0
)paren
(brace
multiline_comment|/* The argument is &gt;= 1.0 */
multiline_comment|/* Put the binary point at the left. */
id|XSIG_LL
c_func
(paren
id|accum
)paren
op_lshift_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* pi/2 in hex is: 1.921fb54442d18469 898CC51701B839A2 52049C1 */
id|XSIG_LL
c_func
(paren
id|accum
)paren
op_assign
l_int|0x921fb54442d18469LL
op_minus
id|XSIG_LL
c_func
(paren
id|accum
)paren
suffix:semicolon
multiline_comment|/* This is a special case which arises due to rounding. */
r_if
c_cond
(paren
id|XSIG_LL
c_func
(paren
id|accum
)paren
op_eq
l_int|0xffffffffffffffffLL
)paren
(brace
id|FPU_settag0
c_func
(paren
id|TAG_Valid
)paren
suffix:semicolon
id|significand
c_func
(paren
id|st0_ptr
)paren
op_assign
l_int|0x8a51e04daabda360LL
suffix:semicolon
id|setexponent16
c_func
(paren
id|st0_ptr
comma
(paren
l_int|0x41
op_plus
id|EXTENDED_Ebias
)paren
op_or
id|SIGN_Negative
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|argSignif.lsw
op_assign
id|accum.lsw
suffix:semicolon
id|XSIG_LL
c_func
(paren
id|argSignif
)paren
op_assign
id|XSIG_LL
c_func
(paren
id|accum
)paren
suffix:semicolon
id|exponent
op_assign
op_minus
l_int|1
op_plus
id|norm_Xsig
c_func
(paren
op_amp
id|argSignif
)paren
suffix:semicolon
)brace
r_else
(brace
id|invert
op_assign
l_int|0
suffix:semicolon
id|argSignif.lsw
op_assign
l_int|0
suffix:semicolon
id|XSIG_LL
c_func
(paren
id|accum
)paren
op_assign
id|XSIG_LL
c_func
(paren
id|argSignif
)paren
op_assign
id|significand
c_func
(paren
id|st0_ptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|exponent
OL
op_minus
l_int|1
)paren
(brace
multiline_comment|/* shift the argument right by the required places */
r_if
c_cond
(paren
id|FPU_shrx
c_func
(paren
op_amp
id|XSIG_LL
c_func
(paren
id|accum
)paren
comma
op_minus
l_int|1
op_minus
id|exponent
)paren
op_ge
l_int|0x80000000U
)paren
id|XSIG_LL
c_func
(paren
id|accum
)paren
op_increment
suffix:semicolon
multiline_comment|/* round up */
)brace
)brace
id|XSIG_LL
c_func
(paren
id|argSq
)paren
op_assign
id|XSIG_LL
c_func
(paren
id|accum
)paren
suffix:semicolon
id|argSq.lsw
op_assign
id|accum.lsw
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|argSq
comma
op_amp
id|argSq
)paren
suffix:semicolon
id|XSIG_LL
c_func
(paren
id|argSqSq
)paren
op_assign
id|XSIG_LL
c_func
(paren
id|argSq
)paren
suffix:semicolon
id|argSqSq.lsw
op_assign
id|argSq.lsw
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|argSqSq
comma
op_amp
id|argSqSq
)paren
suffix:semicolon
multiline_comment|/* Compute the negative terms for the numerator polynomial */
id|accumulatoro.msw
op_assign
id|accumulatoro.midw
op_assign
id|accumulatoro.lsw
op_assign
l_int|0
suffix:semicolon
id|polynomial_Xsig
c_func
(paren
op_amp
id|accumulatoro
comma
op_amp
id|XSIG_LL
c_func
(paren
id|argSqSq
)paren
comma
id|oddnegterm
comma
id|HiPOWERon
op_minus
l_int|1
)paren
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|accumulatoro
comma
op_amp
id|argSq
)paren
suffix:semicolon
id|negate_Xsig
c_func
(paren
op_amp
id|accumulatoro
)paren
suffix:semicolon
multiline_comment|/* Add the positive terms */
id|polynomial_Xsig
c_func
(paren
op_amp
id|accumulatoro
comma
op_amp
id|XSIG_LL
c_func
(paren
id|argSqSq
)paren
comma
id|oddplterm
comma
id|HiPOWERop
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Compute the positive terms for the denominator polynomial */
id|accumulatore.msw
op_assign
id|accumulatore.midw
op_assign
id|accumulatore.lsw
op_assign
l_int|0
suffix:semicolon
id|polynomial_Xsig
c_func
(paren
op_amp
id|accumulatore
comma
op_amp
id|XSIG_LL
c_func
(paren
id|argSqSq
)paren
comma
id|evenplterm
comma
id|HiPOWERep
op_minus
l_int|1
)paren
suffix:semicolon
id|mul_Xsig_Xsig
c_func
(paren
op_amp
id|accumulatore
comma
op_amp
id|argSq
)paren
suffix:semicolon
id|negate_Xsig
c_func
(paren
op_amp
id|accumulatore
)paren
suffix:semicolon
multiline_comment|/* Add the negative terms */
id|polynomial_Xsig
c_func
(paren
op_amp
id|accumulatore
comma
op_amp
id|XSIG_LL
c_func
(paren
id|argSqSq
)paren
comma
id|evennegterm
comma
id|HiPOWERen
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Multiply by arg^2 */
id|mul64_Xsig
c_func
(paren
op_amp
id|accumulatore
comma
op_amp
id|XSIG_LL
c_func
(paren
id|argSignif
)paren
)paren
suffix:semicolon
id|mul64_Xsig
c_func
(paren
op_amp
id|accumulatore
comma
op_amp
id|XSIG_LL
c_func
(paren
id|argSignif
)paren
)paren
suffix:semicolon
multiline_comment|/* de-normalize and divide by 2 */
id|shr_Xsig
c_func
(paren
op_amp
id|accumulatore
comma
op_minus
l_int|2
op_star
(paren
l_int|1
op_plus
id|exponent
)paren
op_plus
l_int|1
)paren
suffix:semicolon
id|negate_Xsig
c_func
(paren
op_amp
id|accumulatore
)paren
suffix:semicolon
multiline_comment|/* This does 1 - accumulator */
multiline_comment|/* Now find the ratio. */
r_if
c_cond
(paren
id|accumulatore.msw
op_eq
l_int|0
)paren
(brace
multiline_comment|/* accumulatoro must contain 1.0 here, (actually, 0) but it&n;&t; really doesn&squot;t matter what value we use because it will&n;&t; have negligible effect in later calculations&n;&t; */
id|XSIG_LL
c_func
(paren
id|accum
)paren
op_assign
l_int|0x8000000000000000LL
suffix:semicolon
id|accum.lsw
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|div_Xsig
c_func
(paren
op_amp
id|accumulatoro
comma
op_amp
id|accumulatore
comma
op_amp
id|accum
)paren
suffix:semicolon
)brace
multiline_comment|/* Multiply by 1/3 * arg^3 */
id|mul64_Xsig
c_func
(paren
op_amp
id|accum
comma
op_amp
id|XSIG_LL
c_func
(paren
id|argSignif
)paren
)paren
suffix:semicolon
id|mul64_Xsig
c_func
(paren
op_amp
id|accum
comma
op_amp
id|XSIG_LL
c_func
(paren
id|argSignif
)paren
)paren
suffix:semicolon
id|mul64_Xsig
c_func
(paren
op_amp
id|accum
comma
op_amp
id|XSIG_LL
c_func
(paren
id|argSignif
)paren
)paren
suffix:semicolon
id|mul64_Xsig
c_func
(paren
op_amp
id|accum
comma
op_amp
id|twothirds
)paren
suffix:semicolon
id|shr_Xsig
c_func
(paren
op_amp
id|accum
comma
op_minus
l_int|2
op_star
(paren
id|exponent
op_plus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* tan(arg) = arg + accum */
id|add_two_Xsig
c_func
(paren
op_amp
id|accum
comma
op_amp
id|argSignif
comma
op_amp
id|exponent
)paren
suffix:semicolon
r_if
c_cond
(paren
id|invert
)paren
(brace
multiline_comment|/* We now have the value of tan(pi_2 - arg) where pi_2 is an&n;&t; approximation for pi/2&n;&t; */
multiline_comment|/* The next step is to fix the answer to compensate for the&n;&t; error due to the approximation used for pi/2&n;&t; */
multiline_comment|/* This is (approx) delta, the error in our approx for pi/2&n;&t; (see above). It has an exponent of -65&n;&t; */
id|XSIG_LL
c_func
(paren
id|fix_up
)paren
op_assign
l_int|0x898cc51701b839a2LL
suffix:semicolon
id|fix_up.lsw
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|exponent
op_eq
l_int|0
)paren
id|adj
op_assign
l_int|0xffffffff
suffix:semicolon
multiline_comment|/* We want approx 1.0 here, but&n;&t;&t;&t;       this is close enough. */
r_else
r_if
c_cond
(paren
id|exponent
OG
op_minus
l_int|30
)paren
(brace
id|adj
op_assign
id|accum.msw
op_rshift
op_minus
(paren
id|exponent
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* tan */
id|adj
op_assign
id|mul_32_32
c_func
(paren
id|adj
comma
id|adj
)paren
suffix:semicolon
multiline_comment|/* tan^2 */
)brace
r_else
id|adj
op_assign
l_int|0
suffix:semicolon
id|adj
op_assign
id|mul_32_32
c_func
(paren
l_int|0x898cc517
comma
id|adj
)paren
suffix:semicolon
multiline_comment|/* delta * tan^2 */
id|fix_up.msw
op_add_assign
id|adj
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|fix_up.msw
op_amp
l_int|0x80000000
)paren
)paren
multiline_comment|/* did fix_up overflow ? */
(brace
multiline_comment|/* Yes, we need to add an msb */
id|shr_Xsig
c_func
(paren
op_amp
id|fix_up
comma
l_int|1
)paren
suffix:semicolon
id|fix_up.msw
op_or_assign
l_int|0x80000000
suffix:semicolon
id|shr_Xsig
c_func
(paren
op_amp
id|fix_up
comma
l_int|64
op_plus
id|exponent
)paren
suffix:semicolon
)brace
r_else
id|shr_Xsig
c_func
(paren
op_amp
id|fix_up
comma
l_int|65
op_plus
id|exponent
)paren
suffix:semicolon
id|add_two_Xsig
c_func
(paren
op_amp
id|accum
comma
op_amp
id|fix_up
comma
op_amp
id|exponent
)paren
suffix:semicolon
multiline_comment|/* accum now contains tan(pi/2 - arg).&n;&t; Use tan(arg) = 1.0 / tan(pi/2 - arg)&n;&t; */
id|accumulatoro.lsw
op_assign
id|accumulatoro.midw
op_assign
l_int|0
suffix:semicolon
id|accumulatoro.msw
op_assign
l_int|0x80000000
suffix:semicolon
id|div_Xsig
c_func
(paren
op_amp
id|accumulatoro
comma
op_amp
id|accum
comma
op_amp
id|accum
)paren
suffix:semicolon
id|exponent
op_assign
op_minus
id|exponent
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Transfer the result */
id|round_Xsig
c_func
(paren
op_amp
id|accum
)paren
suffix:semicolon
id|FPU_settag0
c_func
(paren
id|TAG_Valid
)paren
suffix:semicolon
id|significand
c_func
(paren
id|st0_ptr
)paren
op_assign
id|XSIG_LL
c_func
(paren
id|accum
)paren
suffix:semicolon
id|setexponent16
c_func
(paren
id|st0_ptr
comma
id|exponent
op_plus
id|EXTENDED_Ebias
)paren
suffix:semicolon
multiline_comment|/* Result is positive. */
)brace
eof
