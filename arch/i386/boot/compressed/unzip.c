multiline_comment|/* unzip.c -- decompress files in gzip or pkzip format.&n; * Copyright (C) 1992-1993 Jean-loup Gailly&n; *&n; * Adapted for Linux booting by Hannu Savolainen 1993&n; *&n; * This is free software; you can redistribute it and/or modify it under the&n; * terms of the GNU General Public License, see the file COPYING.&n; *&n; * The code in this file is derived from the file funzip.c written&n; * and put in the public domain by Mark Adler.&n; */
multiline_comment|/*&n;   This version can extract files in gzip or pkzip format.&n;   For the latter, only the first entry is extracted, and it has to be&n;   either deflated or stored.&n; */
macro_line|#ifndef lint
DECL|variable|rcsid
r_static
r_char
id|rcsid
(braket
)braket
op_assign
l_string|&quot;$Id: unzip.c,v 0.9 1993/02/10 16:07:22 jloup Exp $&quot;
suffix:semicolon
macro_line|#endif
macro_line|#include &quot;gzip.h&quot;
macro_line|#include &quot;crypt.h&quot;
macro_line|#include &lt;stdio.h&gt;
multiline_comment|/* PKZIP header definitions */
DECL|macro|LOCSIG
mdefine_line|#define LOCSIG 0x04034b50L      /* four-byte lead-in (lsb first) */
DECL|macro|LOCFLG
mdefine_line|#define LOCFLG 6                /* offset of bit flag */
DECL|macro|CRPFLG
mdefine_line|#define  CRPFLG 1               /*  bit for encrypted entry */
DECL|macro|EXTFLG
mdefine_line|#define  EXTFLG 8               /*  bit for extended local header */
DECL|macro|LOCHOW
mdefine_line|#define LOCHOW 8                /* offset of compression method */
DECL|macro|LOCTIM
mdefine_line|#define LOCTIM 10               /* file mod time (for decryption) */
DECL|macro|LOCCRC
mdefine_line|#define LOCCRC 14               /* offset of crc */
DECL|macro|LOCSIZ
mdefine_line|#define LOCSIZ 18               /* offset of compressed size */
DECL|macro|LOCLEN
mdefine_line|#define LOCLEN 22               /* offset of uncompressed length */
DECL|macro|LOCFIL
mdefine_line|#define LOCFIL 26               /* offset of file name field length */
DECL|macro|LOCEXT
mdefine_line|#define LOCEXT 28               /* offset of extra field length */
DECL|macro|LOCHDR
mdefine_line|#define LOCHDR 30               /* size of local header, including sig */
DECL|macro|EXTHDR
mdefine_line|#define EXTHDR 16               /* size of extended local header, inc sig */
multiline_comment|/* Globals */
DECL|variable|decrypt
r_int
id|decrypt
suffix:semicolon
multiline_comment|/* flag to turn on decryption */
DECL|variable|key
r_char
op_star
id|key
suffix:semicolon
multiline_comment|/* not used--needed to link crypt.c */
DECL|variable|pkzip
r_int
id|pkzip
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set for a pkzip file */
DECL|variable|extended
r_int
id|extended
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set if extended local header */
multiline_comment|/* ===========================================================================&n; * Check zip file and advance inptr to the start of the compressed data.&n; * Get ofname from the local header if necessary.&n; */
DECL|function|check_zipfile
r_int
id|check_zipfile
c_func
(paren
id|in
)paren
r_int
id|in
suffix:semicolon
multiline_comment|/* input file descriptors */
(brace
id|uch
op_star
id|h
op_assign
id|inbuf
op_plus
id|inptr
suffix:semicolon
multiline_comment|/* first local header */
multiline_comment|/* ifd = in; */
multiline_comment|/* Check validity of local header, and skip name and extra fields */
id|inptr
op_add_assign
id|LOCHDR
op_plus
id|SH
c_func
(paren
id|h
op_plus
id|LOCFIL
)paren
op_plus
id|SH
c_func
(paren
id|h
op_plus
id|LOCEXT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inptr
OG
id|insize
op_logical_or
id|LG
c_func
(paren
id|h
)paren
op_ne
id|LOCSIG
)paren
(brace
id|error
c_func
(paren
l_string|&quot;input not a zip&quot;
)paren
suffix:semicolon
)brace
id|method
op_assign
id|h
(braket
id|LOCHOW
)braket
suffix:semicolon
r_if
c_cond
(paren
id|method
op_ne
id|STORED
op_logical_and
id|method
op_ne
id|DEFLATED
)paren
(brace
id|error
c_func
(paren
l_string|&quot;first entry not deflated or stored--can&squot;t extract&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* If entry encrypted, decrypt and validate encryption header */
r_if
c_cond
(paren
(paren
id|decrypt
op_assign
id|h
(braket
id|LOCFLG
)braket
op_amp
id|CRPFLG
)paren
op_ne
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;encrypted file&bslash;n&quot;
)paren
suffix:semicolon
id|exit_code
op_assign
id|ERROR
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Save flags for unzip() */
id|extended
op_assign
(paren
id|h
(braket
id|LOCFLG
)braket
op_amp
id|EXTFLG
)paren
op_ne
l_int|0
suffix:semicolon
id|pkzip
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Get ofname and time stamp from local header (to be done) */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Unzip in to out.  This routine works on both gzip and pkzip files.&n; *&n; * IN assertions: the buffer inbuf contains already the beginning of&n; *   the compressed data, from offsets inptr to insize-1 included.&n; *   The magic header has already been checked. The output buffer is cleared.&n; */
DECL|function|unzip
r_void
id|unzip
c_func
(paren
id|in
comma
id|out
)paren
r_int
id|in
comma
id|out
suffix:semicolon
multiline_comment|/* input and output file descriptors */
(brace
id|ulg
id|orig_crc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* original crc */
id|ulg
id|orig_len
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* original uncompressed length */
r_int
id|n
suffix:semicolon
id|uch
id|buf
(braket
id|EXTHDR
)braket
suffix:semicolon
multiline_comment|/* extended local header */
multiline_comment|/* ifd = in;&n;    ofd = out; */
id|updcrc
c_func
(paren
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* initialize crc */
r_if
c_cond
(paren
id|pkzip
op_logical_and
op_logical_neg
id|extended
)paren
(brace
multiline_comment|/* crc and length at the end otherwise */
id|orig_crc
op_assign
id|LG
c_func
(paren
id|inbuf
op_plus
id|LOCCRC
)paren
suffix:semicolon
id|orig_len
op_assign
id|LG
c_func
(paren
id|inbuf
op_plus
id|LOCLEN
)paren
suffix:semicolon
)brace
multiline_comment|/* Decompress */
r_if
c_cond
(paren
id|method
op_eq
id|DEFLATED
)paren
(brace
r_int
id|res
op_assign
id|inflate
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
op_eq
l_int|3
)paren
(brace
id|error
c_func
(paren
l_string|&quot;out of memory&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|res
op_ne
l_int|0
)paren
(brace
id|error
c_func
(paren
l_string|&quot;invalid compressed format&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|pkzip
op_logical_and
id|method
op_eq
id|STORED
)paren
(brace
r_register
id|ulg
id|n
op_assign
id|LG
c_func
(paren
id|inbuf
op_plus
id|LOCLEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
op_ne
id|LG
c_func
(paren
id|inbuf
op_plus
id|LOCSIZ
)paren
op_minus
(paren
id|decrypt
ques
c_cond
id|RAND_HEAD_LEN
suffix:colon
l_int|0
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;length mismatch&quot;
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|n
op_decrement
)paren
(brace
id|uch
id|c
op_assign
(paren
id|uch
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CRYPT
r_if
c_cond
(paren
id|decrypt
)paren
id|zdecode
c_func
(paren
id|c
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|test
)paren
id|put_char
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|error
c_func
(paren
l_string|&quot;internal error, invalid method&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the crc and original length */
r_if
c_cond
(paren
op_logical_neg
id|pkzip
)paren
(brace
multiline_comment|/* crc32  (see algorithm.doc)&n;&t; * uncompressed input size modulo 2^32&n;         */
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
l_int|8
suffix:semicolon
id|n
op_increment
)paren
(brace
id|buf
(braket
id|n
)braket
op_assign
(paren
id|uch
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* may cause an error if EOF */
)brace
id|orig_crc
op_assign
id|LG
c_func
(paren
id|buf
)paren
suffix:semicolon
id|orig_len
op_assign
id|LG
c_func
(paren
id|buf
op_plus
l_int|4
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|extended
)paren
(brace
multiline_comment|/* If extended header, check it */
multiline_comment|/* signature - 4bytes: 0x50 0x4b 0x07 0x08&n;&t; * CRC-32 value&n;         * compressed size 4-bytes&n;         * uncompressed size 4-bytes&n;&t; */
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|EXTHDR
suffix:semicolon
id|n
op_increment
)paren
(brace
id|buf
(braket
id|n
)braket
op_assign
(paren
id|uch
)paren
id|get_byte
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* may cause an error if EOF */
)brace
id|orig_crc
op_assign
id|LG
c_func
(paren
id|buf
op_plus
l_int|4
)paren
suffix:semicolon
id|orig_len
op_assign
id|LG
c_func
(paren
id|buf
op_plus
l_int|12
)paren
suffix:semicolon
)brace
multiline_comment|/* Validate decompression */
r_if
c_cond
(paren
id|orig_crc
op_ne
id|updcrc
c_func
(paren
id|outbuf
comma
l_int|0
)paren
)paren
(brace
id|error
c_func
(paren
l_string|&quot;crc error&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|orig_len
op_ne
id|bytes_out
)paren
(brace
id|error
c_func
(paren
l_string|&quot;length error&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if there are more entries in a pkzip file */
r_if
c_cond
(paren
id|pkzip
op_logical_and
id|inptr
op_plus
l_int|4
OL
id|insize
op_logical_and
id|LG
c_func
(paren
id|inbuf
op_plus
id|inptr
)paren
op_eq
id|LOCSIG
)paren
(brace
id|error
c_func
(paren
l_string|&quot;zip file has more than one entry&quot;
)paren
suffix:semicolon
)brace
id|extended
op_assign
id|pkzip
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* for next file */
)brace
eof
