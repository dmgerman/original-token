macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;ieee-math.h&quot;
DECL|macro|OPC_PAL
mdefine_line|#define&t;OPC_PAL&t;&t;0x00
DECL|macro|OPC_INTA
mdefine_line|#define OPC_INTA&t;0x10
DECL|macro|OPC_INTL
mdefine_line|#define OPC_INTL&t;0x11
DECL|macro|OPC_INTS
mdefine_line|#define OPC_INTS&t;0x12
DECL|macro|OPC_INTM
mdefine_line|#define OPC_INTM&t;0x13
DECL|macro|OPC_FLTC
mdefine_line|#define OPC_FLTC&t;0x14
DECL|macro|OPC_FLTV
mdefine_line|#define OPC_FLTV&t;0x15
DECL|macro|OPC_FLTI
mdefine_line|#define OPC_FLTI&t;0x16
DECL|macro|OPC_FLTL
mdefine_line|#define OPC_FLTL&t;0x17
DECL|macro|OPC_MISC
mdefine_line|#define OPC_MISC&t;0x18
DECL|macro|OPC_JSR
mdefine_line|#define&t;OPC_JSR&t;&t;0x1a
DECL|macro|OP_FUN
mdefine_line|#define OP_FUN(OP,FUN)&t;((OP &lt;&lt; 26) | (FUN &lt;&lt; 5))
multiline_comment|/*&n; * &quot;Base&quot; function codes for the FLTI-class instructions.&n; * Note that in most cases these actually correspond to the &quot;chopped&quot;&n; * form of the instruction.  Not to worry---we extract the qualifier&n; * bits separately and deal with them separately.  Notice that base&n; * function code 0x2c is used for both CVTTS and CVTST.  The other bits&n; * in the function code are used to distinguish the two.&n; */
DECL|macro|FLTI_FUNC_ADDS
mdefine_line|#define FLTI_FUNC_ADDS&t;&t;&t;OP_FUN(OPC_FLTI, 0x000)
DECL|macro|FLTI_FUNC_ADDT
mdefine_line|#define FLTI_FUNC_ADDT&t;&t;&t;OP_FUN(OPC_FLTI, 0x020)
DECL|macro|FLTI_FUNC_CMPTEQ
mdefine_line|#define FLTI_FUNC_CMPTEQ&t;&t;OP_FUN(OPC_FLTI, 0x025)
DECL|macro|FLTI_FUNC_CMPTLT
mdefine_line|#define FLTI_FUNC_CMPTLT&t;&t;OP_FUN(OPC_FLTI, 0x026)
DECL|macro|FLTI_FUNC_CMPTLE
mdefine_line|#define FLTI_FUNC_CMPTLE&t;&t;OP_FUN(OPC_FLTI, 0x027)
DECL|macro|FLTI_FUNC_CMPTUN
mdefine_line|#define FLTI_FUNC_CMPTUN&t;&t;OP_FUN(OPC_FLTI, 0x024)
DECL|macro|FLTI_FUNC_CVTTS_or_CVTST
mdefine_line|#define FLTI_FUNC_CVTTS_or_CVTST&t;OP_FUN(OPC_FLTI, 0x02c)
DECL|macro|FLTI_FUNC_CVTTQ
mdefine_line|#define FLTI_FUNC_CVTTQ&t;&t;&t;OP_FUN(OPC_FLTI, 0x02f)
DECL|macro|FLTI_FUNC_CVTQS
mdefine_line|#define FLTI_FUNC_CVTQS&t;&t;&t;OP_FUN(OPC_FLTI, 0x03c)
DECL|macro|FLTI_FUNC_CVTQT
mdefine_line|#define FLTI_FUNC_CVTQT&t;&t;&t;OP_FUN(OPC_FLTI, 0x03e)
DECL|macro|FLTI_FUNC_DIVS
mdefine_line|#define FLTI_FUNC_DIVS&t;&t;&t;OP_FUN(OPC_FLTI, 0x003)
DECL|macro|FLTI_FUNC_DIVT
mdefine_line|#define FLTI_FUNC_DIVT&t;&t;&t;OP_FUN(OPC_FLTI, 0x023)
DECL|macro|FLTI_FUNC_MULS
mdefine_line|#define FLTI_FUNC_MULS&t;&t;&t;OP_FUN(OPC_FLTI, 0x002)
DECL|macro|FLTI_FUNC_MULT
mdefine_line|#define FLTI_FUNC_MULT&t;&t;&t;OP_FUN(OPC_FLTI, 0x022)
DECL|macro|FLTI_FUNC_SUBS
mdefine_line|#define FLTI_FUNC_SUBS&t;&t;&t;OP_FUN(OPC_FLTI, 0x001)
DECL|macro|FLTI_FUNC_SUBT
mdefine_line|#define FLTI_FUNC_SUBT&t;&t;&t;OP_FUN(OPC_FLTI, 0x021)
DECL|macro|FLTC_FUNC_SQRTS
mdefine_line|#define FLTC_FUNC_SQRTS&t;&t;&t;OP_FUN(OPC_FLTC, 0x00B)
DECL|macro|FLTC_FUNC_SQRTT
mdefine_line|#define FLTC_FUNC_SQRTT&t;&t;&t;OP_FUN(OPC_FLTC, 0x02B)
DECL|macro|FLTL_FUNC_CVTQL
mdefine_line|#define FLTL_FUNC_CVTQL&t;&t;&t;OP_FUN(OPC_FLTL, 0x030)
DECL|macro|MISC_TRAPB
mdefine_line|#define MISC_TRAPB&t;0x0000
DECL|macro|MISC_EXCB
mdefine_line|#define MISC_EXCB&t;0x0400
r_extern
r_int
r_int
id|alpha_read_fp_reg
(paren
r_int
r_int
id|reg
)paren
suffix:semicolon
r_extern
r_void
id|alpha_write_fp_reg
(paren
r_int
r_int
id|reg
comma
r_int
r_int
id|val
)paren
suffix:semicolon
macro_line|#ifdef MODULE
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;FP Software completion module&quot;
)paren
suffix:semicolon
r_extern
r_int
(paren
op_star
id|alpha_fp_emul_imprecise
)paren
(paren
r_struct
id|pt_regs
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_extern
r_int
(paren
op_star
id|alpha_fp_emul
)paren
(paren
r_int
r_int
id|pc
)paren
suffix:semicolon
DECL|variable|save_emul_imprecise
r_static
r_int
(paren
op_star
id|save_emul_imprecise
)paren
(paren
r_struct
id|pt_regs
op_star
comma
r_int
r_int
)paren
suffix:semicolon
DECL|variable|save_emul
r_static
r_int
(paren
op_star
id|save_emul
)paren
(paren
r_int
r_int
id|pc
)paren
suffix:semicolon
r_int
id|do_alpha_fp_emul_imprecise
c_func
(paren
r_struct
id|pt_regs
op_star
comma
r_int
r_int
)paren
suffix:semicolon
r_int
id|do_alpha_fp_emul
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
id|save_emul_imprecise
op_assign
id|alpha_fp_emul_imprecise
suffix:semicolon
id|save_emul
op_assign
id|alpha_fp_emul
suffix:semicolon
id|alpha_fp_emul_imprecise
op_assign
id|do_alpha_fp_emul_imprecise
suffix:semicolon
id|alpha_fp_emul
op_assign
id|do_alpha_fp_emul
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|alpha_fp_emul_imprecise
op_assign
id|save_emul_imprecise
suffix:semicolon
id|alpha_fp_emul
op_assign
id|save_emul
suffix:semicolon
)brace
DECL|macro|alpha_fp_emul_imprecise
macro_line|#undef  alpha_fp_emul_imprecise
DECL|macro|alpha_fp_emul_imprecise
mdefine_line|#define alpha_fp_emul_imprecise&t;&t;do_alpha_fp_emul_imprecise
DECL|macro|alpha_fp_emul
macro_line|#undef  alpha_fp_emul
DECL|macro|alpha_fp_emul
mdefine_line|#define alpha_fp_emul&t;&t;&t;do_alpha_fp_emul
macro_line|#endif /* MODULE */
multiline_comment|/*&n; * Emulate the floating point instruction at address PC.  Returns 0 if&n; * emulation fails.  Notice that the kernel does not and cannot use FP&n; * regs.  This is good because it means that instead of&n; * saving/restoring all fp regs, we simply stick the result of the&n; * operation into the appropriate register.&n; */
r_int
DECL|function|alpha_fp_emul
id|alpha_fp_emul
(paren
r_int
r_int
id|pc
)paren
(brace
r_int
r_int
id|op_fun
comma
id|fa
comma
id|fb
comma
id|fc
comma
id|func
comma
id|mode
suffix:semicolon
r_int
r_int
id|fpcw
op_assign
id|current-&gt;tss.flags
suffix:semicolon
r_int
r_int
id|va
comma
id|vb
comma
id|vc
comma
id|res
comma
id|fpcr
suffix:semicolon
id|__u32
id|insn
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|get_user
c_func
(paren
id|insn
comma
(paren
id|__u32
op_star
)paren
id|pc
)paren
suffix:semicolon
id|fc
op_assign
(paren
id|insn
op_rshift
l_int|0
)paren
op_amp
l_int|0x1f
suffix:semicolon
multiline_comment|/* destination register */
id|fb
op_assign
(paren
id|insn
op_rshift
l_int|16
)paren
op_amp
l_int|0x1f
suffix:semicolon
id|fa
op_assign
(paren
id|insn
op_rshift
l_int|21
)paren
op_amp
l_int|0x1f
suffix:semicolon
id|func
op_assign
(paren
id|insn
op_rshift
l_int|5
)paren
op_amp
l_int|0x7ff
suffix:semicolon
id|mode
op_assign
(paren
id|insn
op_rshift
l_int|5
)paren
op_amp
l_int|0xc0
suffix:semicolon
id|op_fun
op_assign
id|insn
op_amp
id|OP_FUN
c_func
(paren
l_int|0x3f
comma
l_int|0x3f
)paren
suffix:semicolon
id|va
op_assign
id|alpha_read_fp_reg
c_func
(paren
id|fa
)paren
suffix:semicolon
id|vb
op_assign
id|alpha_read_fp_reg
c_func
(paren
id|fb
)paren
suffix:semicolon
id|fpcr
op_assign
id|rdfpcr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Try the operation in software.  First, obtain the rounding&n;&t; * mode...&n;&t; */
r_if
c_cond
(paren
id|mode
op_eq
l_int|0xc0
)paren
(brace
multiline_comment|/* dynamic---get rounding mode from fpcr: */
id|mode
op_assign
(paren
(paren
id|fpcr
op_amp
id|FPCR_DYN_MASK
)paren
op_rshift
id|FPCR_DYN_SHIFT
)paren
op_lshift
id|ROUND_SHIFT
suffix:semicolon
)brace
id|mode
op_or_assign
(paren
id|fpcw
op_amp
id|IEEE_TRAP_ENABLE_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|IEEE_TRAP_ENABLE_MASK
op_amp
l_int|0xc0
)paren
)paren
(brace
r_extern
r_int
id|something_is_wrong
(paren
r_void
)paren
suffix:semicolon
id|something_is_wrong
c_func
(paren
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|op_fun
)paren
(brace
r_case
id|FLTI_FUNC_CMPTEQ
suffix:colon
id|res
op_assign
id|ieee_CMPTEQ
c_func
(paren
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_CMPTLT
suffix:colon
id|res
op_assign
id|ieee_CMPTLT
c_func
(paren
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_CMPTLE
suffix:colon
id|res
op_assign
id|ieee_CMPTLE
c_func
(paren
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_CMPTUN
suffix:colon
id|res
op_assign
id|ieee_CMPTUN
c_func
(paren
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTL_FUNC_CVTQL
suffix:colon
multiline_comment|/*&n;&t;&t; * Notice: We can get here only due to an integer&n;&t;&t; * overflow.  Such overflows are reported as invalid&n;&t;&t; * ops.  We return the result the hw would have&n;&t;&t; * computed.&n;&t;&t; */
id|vc
op_assign
(paren
(paren
id|vb
op_amp
l_int|0xc0000000
)paren
op_lshift
l_int|32
op_or
multiline_comment|/* sign and msb */
(paren
id|vb
op_amp
l_int|0x3fffffff
)paren
op_lshift
l_int|29
)paren
suffix:semicolon
multiline_comment|/* rest of the integer */
id|res
op_assign
id|FPCR_INV
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_CVTQS
suffix:colon
id|res
op_assign
id|ieee_CVTQS
c_func
(paren
id|mode
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_CVTQT
suffix:colon
id|res
op_assign
id|ieee_CVTQT
c_func
(paren
id|mode
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_CVTTS_or_CVTST
suffix:colon
r_if
c_cond
(paren
id|func
op_eq
l_int|0x6ac
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * 0x2ac is also CVTST, but if the /S&n;&t;&t;&t; * qualifier isn&squot;t set, we wouldn&squot;t be here in&n;&t;&t;&t; * the first place...&n;&t;&t;&t; */
id|res
op_assign
id|ieee_CVTST
c_func
(paren
id|mode
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
)brace
r_else
(brace
id|res
op_assign
id|ieee_CVTTS
c_func
(paren
id|mode
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_DIVS
suffix:colon
id|res
op_assign
id|ieee_DIVS
c_func
(paren
id|mode
comma
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_DIVT
suffix:colon
id|res
op_assign
id|ieee_DIVT
c_func
(paren
id|mode
comma
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_MULS
suffix:colon
id|res
op_assign
id|ieee_MULS
c_func
(paren
id|mode
comma
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_MULT
suffix:colon
id|res
op_assign
id|ieee_MULT
c_func
(paren
id|mode
comma
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_SUBS
suffix:colon
id|res
op_assign
id|ieee_SUBS
c_func
(paren
id|mode
comma
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_SUBT
suffix:colon
id|res
op_assign
id|ieee_SUBT
c_func
(paren
id|mode
comma
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_ADDS
suffix:colon
id|res
op_assign
id|ieee_ADDS
c_func
(paren
id|mode
comma
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_ADDT
suffix:colon
id|res
op_assign
id|ieee_ADDT
c_func
(paren
id|mode
comma
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_CVTTQ
suffix:colon
id|res
op_assign
id|ieee_CVTTQ
c_func
(paren
id|mode
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTC_FUNC_SQRTS
suffix:colon
id|res
op_assign
id|ieee_SQRTS
c_func
(paren
id|mode
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTC_FUNC_SQRTT
suffix:colon
id|res
op_assign
id|ieee_SQRTT
c_func
(paren
id|mode
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;alpha_fp_emul: unexpected function code %#lx at %#lx&bslash;n&quot;
comma
id|func
op_amp
l_int|0x3f
comma
id|pc
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Take the appropriate action for each possible&n;&t; * floating-point result:&n;&t; *&n;&t; *&t;- Set the appropriate bits in the FPCR&n;&t; *&t;- If the specified exception is enabled in the FPCR,&n;&t; *&t;  return.  The caller (entArith) will dispatch&n;&t; *&t;  the appropriate signal to the translated program.&n;&t; *&n;&t; * In addition, properly track the exception state in software&n;&t; * as described in the Alpha Architectre Handbook section 4.7.7.3.&n;&t; */
r_if
c_cond
(paren
id|res
)paren
(brace
multiline_comment|/* Record exceptions in software control word.  */
id|current-&gt;tss.flags
op_assign
id|fpcw
op_or_assign
id|res
op_rshift
l_int|35
suffix:semicolon
multiline_comment|/* Update hardware control register */
id|fpcr
op_and_assign
(paren
op_complement
id|FPCR_MASK
op_or
id|FPCR_DYN_MASK
)paren
suffix:semicolon
id|fpcr
op_or_assign
id|ieee_swcr_to_fpcr
c_func
(paren
id|fpcw
)paren
suffix:semicolon
id|wrfpcr
c_func
(paren
id|fpcr
)paren
suffix:semicolon
multiline_comment|/* Do we generate a signal?  */
r_if
c_cond
(paren
id|res
op_rshift
l_int|51
op_amp
id|fpcw
op_amp
id|IEEE_TRAP_ENABLE_MASK
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Whoo-kay... we got this far, and we&squot;re not generating a signal&n;&t; * to the translated program.  All that remains is to write the&n;&t; * result:&n;&t; */
id|alpha_write_fp_reg
c_func
(paren
id|fc
comma
id|vc
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|alpha_fp_emul_imprecise
id|alpha_fp_emul_imprecise
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|write_mask
)paren
(brace
r_int
r_int
id|trigger_pc
op_assign
id|regs-&gt;pc
op_minus
l_int|4
suffix:semicolon
r_int
r_int
id|insn
comma
id|opcode
comma
id|rc
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/*&n;&t; * Turn off the bits corresponding to registers that are the&n;&t; * target of instructions that set bits in the exception&n;&t; * summary register.  We have some slack doing this because a&n;&t; * register that is the target of a trapping instruction can&n;&t; * be written at most once in the trap shadow.&n;&t; *&n;&t; * Branches, jumps, TRAPBs, EXCBs and calls to PALcode all&n;&t; * bound the trap shadow, so we need not look any further than&n;&t; * up to the first occurrence of such an instruction.&n;&t; */
r_while
c_loop
(paren
id|write_mask
)paren
(brace
id|get_user
c_func
(paren
id|insn
comma
(paren
id|__u32
op_star
)paren
(paren
id|trigger_pc
)paren
)paren
suffix:semicolon
id|opcode
op_assign
id|insn
op_rshift
l_int|26
suffix:semicolon
id|rc
op_assign
id|insn
op_amp
l_int|0x1f
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|OPC_PAL
suffix:colon
r_case
id|OPC_JSR
suffix:colon
r_case
l_int|0x30
dot
dot
dot
l_int|0x3f
suffix:colon
multiline_comment|/* branches */
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|OPC_MISC
suffix:colon
r_switch
c_cond
(paren
id|insn
op_amp
l_int|0xffff
)paren
(brace
r_case
id|MISC_TRAPB
suffix:colon
r_case
id|MISC_EXCB
suffix:colon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OPC_INTA
suffix:colon
r_case
id|OPC_INTL
suffix:colon
r_case
id|OPC_INTS
suffix:colon
r_case
id|OPC_INTM
suffix:colon
id|write_mask
op_and_assign
op_complement
(paren
l_int|1UL
op_lshift
id|rc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPC_FLTC
suffix:colon
r_case
id|OPC_FLTV
suffix:colon
r_case
id|OPC_FLTI
suffix:colon
r_case
id|OPC_FLTL
suffix:colon
id|write_mask
op_and_assign
op_complement
(paren
l_int|1UL
op_lshift
(paren
id|rc
op_plus
l_int|32
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|write_mask
)paren
(brace
r_if
c_cond
(paren
id|alpha_fp_emul
c_func
(paren
id|trigger_pc
)paren
)paren
(brace
multiline_comment|/* re-execute insns in trap-shadow: */
id|regs-&gt;pc
op_assign
id|trigger_pc
op_plus
l_int|4
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|trigger_pc
op_sub_assign
l_int|4
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
