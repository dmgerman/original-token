macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &quot;ieee-math.h&quot;
DECL|macro|OPC_PAL
mdefine_line|#define&t;OPC_PAL&t;&t;0x00
DECL|macro|OPC_INTA
mdefine_line|#define OPC_INTA&t;0x10
DECL|macro|OPC_INTL
mdefine_line|#define OPC_INTL&t;0x11
DECL|macro|OPC_INTS
mdefine_line|#define OPC_INTS&t;0x12
DECL|macro|OPC_INTM
mdefine_line|#define OPC_INTM&t;0x13
DECL|macro|OPC_FLTV
mdefine_line|#define OPC_FLTV&t;0x14
DECL|macro|OPC_FLTI
mdefine_line|#define OPC_FLTI&t;0x15
DECL|macro|OPC_FLTL
mdefine_line|#define OPC_FLTL&t;0x16
DECL|macro|OPC_MISC
mdefine_line|#define OPC_MISC&t;0x18
DECL|macro|OPC_JSR
mdefine_line|#define&t;OPC_JSR&t;&t;0x1a
multiline_comment|/*&n; * &quot;Base&quot; function codes for the FLTI-class instructions.  These&n; * instructions all have opcode 0x16.  Note that in most cases these&n; * actually correspond to the &quot;chopped&quot; form of the instruction.  Not&n; * to worry---we extract the qualifier bits separately and deal with&n; * them separately.  Notice that base function code 0x2c is used for&n; * both CVTTS and CVTST.  The other bits in the function code are used&n; * to distinguish the two.&n; */
DECL|macro|FLTI_FUNC_ADDS
mdefine_line|#define FLTI_FUNC_ADDS&t;&t;&t;0x000
DECL|macro|FLTI_FUNC_ADDT
mdefine_line|#define FLTI_FUNC_ADDT&t;&t;&t;0x020
DECL|macro|FLTI_FUNC_CMPTEQ
mdefine_line|#define FLTI_FUNC_CMPTEQ&t;&t;0x0a5
DECL|macro|FLTI_FUNC_CMPTLT
mdefine_line|#define FLTI_FUNC_CMPTLT&t;&t;0x0a6
DECL|macro|FLTI_FUNC_CMPTLE
mdefine_line|#define FLTI_FUNC_CMPTLE&t;&t;0x0a7
DECL|macro|FLTI_FUNC_CMPTUN
mdefine_line|#define FLTI_FUNC_CMPTUN&t;&t;0x0a4
DECL|macro|FLTI_FUNC_CVTTS_or_CVTST
mdefine_line|#define FLTI_FUNC_CVTTS_or_CVTST&t;0x02c
DECL|macro|FLTI_FUNC_CVTTQ
mdefine_line|#define FLTI_FUNC_CVTTQ&t;&t;&t;0x02f
DECL|macro|FLTI_FUNC_CVTQS
mdefine_line|#define FLTI_FUNC_CVTQS&t;&t;&t;0x03c
DECL|macro|FLTI_FUNC_CVTQT
mdefine_line|#define FLTI_FUNC_CVTQT&t;&t;&t;0x03e
DECL|macro|FLTI_FUNC_DIVS
mdefine_line|#define FLTI_FUNC_DIVS&t;&t;&t;0x003
DECL|macro|FLTI_FUNC_DIVT
mdefine_line|#define FLTI_FUNC_DIVT&t;&t;&t;0x023
DECL|macro|FLTI_FUNC_MULS
mdefine_line|#define FLTI_FUNC_MULS&t;&t;&t;0x002
DECL|macro|FLTI_FUNC_MULT
mdefine_line|#define FLTI_FUNC_MULT&t;&t;&t;0x022
DECL|macro|FLTI_FUNC_SUBS
mdefine_line|#define FLTI_FUNC_SUBS&t;&t;&t;0x001
DECL|macro|FLTI_FUNC_SUBT
mdefine_line|#define FLTI_FUNC_SUBT&t;&t;&t;0x021
DECL|macro|FLTI_FUNC_CVTQL
mdefine_line|#define FLTI_FUNC_CVTQL&t;&t;&t;0x030&t;/* opcode 0x17 */
DECL|macro|MISC_TRAPB
mdefine_line|#define MISC_TRAPB&t;0x0000
DECL|macro|MISC_EXCB
mdefine_line|#define MISC_EXCB&t;0x0400
r_extern
r_int
r_int
id|rdfpcr
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|wrfpcr
(paren
r_int
r_int
)paren
suffix:semicolon
r_int
r_int
DECL|function|alpha_read_fp_reg
id|alpha_read_fp_reg
(paren
r_int
r_int
id|reg
)paren
(brace
r_int
r_int
id|r
suffix:semicolon
r_switch
c_cond
(paren
id|reg
)paren
(brace
r_case
l_int|0
suffix:colon
id|asm
(paren
l_string|&quot;stt  $f0,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|asm
(paren
l_string|&quot;stt  $f1,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|asm
(paren
l_string|&quot;stt  $f2,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|asm
(paren
l_string|&quot;stt  $f3,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|asm
(paren
l_string|&quot;stt  $f4,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|asm
(paren
l_string|&quot;stt  $f5,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|asm
(paren
l_string|&quot;stt  $f6,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|asm
(paren
l_string|&quot;stt  $f7,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
id|asm
(paren
l_string|&quot;stt  $f8,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
id|asm
(paren
l_string|&quot;stt  $f9,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10
suffix:colon
id|asm
(paren
l_string|&quot;stt $f10,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|11
suffix:colon
id|asm
(paren
l_string|&quot;stt $f11,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
id|asm
(paren
l_string|&quot;stt $f12,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|13
suffix:colon
id|asm
(paren
l_string|&quot;stt $f13,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|14
suffix:colon
id|asm
(paren
l_string|&quot;stt $f14,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|15
suffix:colon
id|asm
(paren
l_string|&quot;stt $f15,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|16
suffix:colon
id|asm
(paren
l_string|&quot;stt $f16,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|17
suffix:colon
id|asm
(paren
l_string|&quot;stt $f17,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|18
suffix:colon
id|asm
(paren
l_string|&quot;stt $f18,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|19
suffix:colon
id|asm
(paren
l_string|&quot;stt $f19,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|20
suffix:colon
id|asm
(paren
l_string|&quot;stt $f20,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|21
suffix:colon
id|asm
(paren
l_string|&quot;stt $f21,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|22
suffix:colon
id|asm
(paren
l_string|&quot;stt $f22,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|23
suffix:colon
id|asm
(paren
l_string|&quot;stt $f23,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|24
suffix:colon
id|asm
(paren
l_string|&quot;stt $f24,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|25
suffix:colon
id|asm
(paren
l_string|&quot;stt $f25,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|26
suffix:colon
id|asm
(paren
l_string|&quot;stt $f26,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|27
suffix:colon
id|asm
(paren
l_string|&quot;stt $f27,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|28
suffix:colon
id|asm
(paren
l_string|&quot;stt $f28,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|29
suffix:colon
id|asm
(paren
l_string|&quot;stt $f29,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|30
suffix:colon
id|asm
(paren
l_string|&quot;stt $f30,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|31
suffix:colon
id|asm
(paren
l_string|&quot;stt $f31,%0&quot;
suffix:colon
l_string|&quot;m=&quot;
(paren
id|r
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; * This is IMHO the better way of implementing LDT().  But it&n; * has the disadvantage that gcc 2.7.0 refuses to compile it&n; * (invalid operand constraints), so instead, we use the uglier&n; * macro below.&n; */
macro_line|# define LDT(reg,val)&t;&bslash;&n;  asm volatile (&quot;ldt $f&quot;#reg&quot;,%0&quot; :: &quot;m&quot;(val));
macro_line|#else
DECL|macro|LDT
macro_line|# define LDT(reg,val)&t;&bslash;&n;  asm volatile (&quot;ldt $f&quot;#reg&quot;,0(%0)&quot; :: &quot;r&quot;(&amp;val));
macro_line|#endif
r_void
DECL|function|alpha_write_fp_reg
id|alpha_write_fp_reg
(paren
r_int
r_int
id|reg
comma
r_int
r_int
id|val
)paren
(brace
r_switch
c_cond
(paren
id|reg
)paren
(brace
r_case
l_int|0
suffix:colon
id|LDT
c_func
(paren
l_int|0
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|LDT
c_func
(paren
l_int|1
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|LDT
c_func
(paren
l_int|2
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|LDT
c_func
(paren
l_int|3
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|LDT
c_func
(paren
l_int|4
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|LDT
c_func
(paren
l_int|5
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|LDT
c_func
(paren
l_int|6
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|LDT
c_func
(paren
l_int|7
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
id|LDT
c_func
(paren
l_int|8
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
id|LDT
c_func
(paren
l_int|9
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10
suffix:colon
id|LDT
c_func
(paren
l_int|10
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|11
suffix:colon
id|LDT
c_func
(paren
l_int|11
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
id|LDT
c_func
(paren
l_int|12
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|13
suffix:colon
id|LDT
c_func
(paren
l_int|13
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|14
suffix:colon
id|LDT
c_func
(paren
l_int|14
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|15
suffix:colon
id|LDT
c_func
(paren
l_int|15
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|16
suffix:colon
id|LDT
c_func
(paren
l_int|16
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|17
suffix:colon
id|LDT
c_func
(paren
l_int|17
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|18
suffix:colon
id|LDT
c_func
(paren
l_int|18
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|19
suffix:colon
id|LDT
c_func
(paren
l_int|19
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|20
suffix:colon
id|LDT
c_func
(paren
l_int|20
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|21
suffix:colon
id|LDT
c_func
(paren
l_int|21
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|22
suffix:colon
id|LDT
c_func
(paren
l_int|22
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|23
suffix:colon
id|LDT
c_func
(paren
l_int|23
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|24
suffix:colon
id|LDT
c_func
(paren
l_int|24
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|25
suffix:colon
id|LDT
c_func
(paren
l_int|25
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|26
suffix:colon
id|LDT
c_func
(paren
l_int|26
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|27
suffix:colon
id|LDT
c_func
(paren
l_int|27
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|28
suffix:colon
id|LDT
c_func
(paren
l_int|28
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|29
suffix:colon
id|LDT
c_func
(paren
l_int|29
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|30
suffix:colon
id|LDT
c_func
(paren
l_int|30
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|31
suffix:colon
id|LDT
c_func
(paren
l_int|31
comma
id|val
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Emulate the floating point instruction at address PC.  Returns 0 if&n; * emulation fails.  Notice that the kernel does not and cannot use FP&n; * regs.  This is good because it means that instead of&n; * saving/restoring all fp regs, we simply stick the result of the&n; * operation into the appropriate register.&n; */
r_int
DECL|function|alpha_fp_emul
id|alpha_fp_emul
(paren
r_int
r_int
id|pc
)paren
(brace
r_int
r_int
id|opcode
comma
id|fa
comma
id|fb
comma
id|fc
comma
id|func
comma
id|mode
suffix:semicolon
r_int
r_int
id|fpcw
op_assign
id|current-&gt;tss.flags
suffix:semicolon
r_int
r_int
id|va
comma
id|vb
comma
id|vc
comma
id|res
comma
id|fpcr
suffix:semicolon
id|__u32
id|insn
suffix:semicolon
id|insn
op_assign
id|get_user
c_func
(paren
(paren
id|__u32
op_star
)paren
id|pc
)paren
suffix:semicolon
id|fc
op_assign
(paren
id|insn
op_rshift
l_int|0
)paren
op_amp
l_int|0x1f
suffix:semicolon
multiline_comment|/* destination register */
id|func
op_assign
(paren
id|insn
op_rshift
l_int|5
)paren
op_amp
l_int|0x3ff
suffix:semicolon
id|fb
op_assign
(paren
id|insn
op_rshift
l_int|16
)paren
op_amp
l_int|0x1f
suffix:semicolon
id|fa
op_assign
(paren
id|insn
op_rshift
l_int|21
)paren
op_amp
l_int|0x1f
suffix:semicolon
id|opcode
op_assign
id|insn
op_rshift
l_int|26
suffix:semicolon
id|va
op_assign
id|alpha_read_fp_reg
c_func
(paren
id|fa
)paren
suffix:semicolon
id|vb
op_assign
id|alpha_read_fp_reg
c_func
(paren
id|fb
)paren
suffix:semicolon
id|fpcr
op_assign
id|rdfpcr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Try the operation in software.  First, obtain the rounding&n;&t; * mode...&n;&t; */
id|mode
op_assign
id|func
op_amp
l_int|0xc0
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
l_int|0xc0
)paren
(brace
multiline_comment|/* dynamic---get rounding mode from fpcr: */
id|mode
op_assign
(paren
(paren
id|fpcr
op_amp
id|FPCR_DYN_MASK
)paren
op_rshift
id|FPCR_DYN_SHIFT
)paren
op_lshift
id|ROUND_SHIFT
suffix:semicolon
)brace
id|mode
op_or_assign
(paren
id|fpcw
op_amp
id|IEEE_TRAP_ENABLE_MASK
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|IEEE_TRAP_ENABLE_MASK
op_amp
l_int|0xc0
)paren
)paren
(brace
r_extern
r_int
id|something_is_wrong
(paren
r_void
)paren
suffix:semicolon
id|something_is_wrong
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* least 6 bits contain operation code: */
r_switch
c_cond
(paren
id|func
op_amp
l_int|0x3f
)paren
(brace
r_case
id|FLTI_FUNC_CMPTEQ
suffix:colon
id|res
op_assign
id|ieee_CMPTEQ
c_func
(paren
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_CMPTLT
suffix:colon
id|res
op_assign
id|ieee_CMPTLT
c_func
(paren
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_CMPTLE
suffix:colon
id|res
op_assign
id|ieee_CMPTLE
c_func
(paren
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_CMPTUN
suffix:colon
id|res
op_assign
id|ieee_CMPTUN
c_func
(paren
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_CVTQL
suffix:colon
multiline_comment|/*&n;&t;&t; * Notice: We can get here only due to an integer&n;&t;&t; * overflow.  Such overflows are reported as invalid&n;&t;&t; * ops.  We return the result the hw would have&n;&t;&t; * computed.&n;&t;&t; */
id|vc
op_assign
(paren
(paren
id|vb
op_amp
l_int|0xc0000000
)paren
op_lshift
l_int|32
op_or
multiline_comment|/* sign and msb */
(paren
id|vb
op_amp
l_int|0x3fffffff
)paren
op_lshift
l_int|29
)paren
suffix:semicolon
multiline_comment|/* rest of the integer */
id|res
op_assign
id|FPCR_INV
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_CVTQS
suffix:colon
id|res
op_assign
id|ieee_CVTQS
c_func
(paren
id|mode
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_CVTQT
suffix:colon
id|res
op_assign
id|ieee_CVTQT
c_func
(paren
id|mode
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_CVTTS_or_CVTST
suffix:colon
r_if
c_cond
(paren
id|func
op_eq
l_int|0x6ac
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * 0x2ac is also CVTST, but if the /S&n;&t;&t;&t; * qualifier isn&squot;t set, we wouldn&squot;t be here in&n;&t;&t;&t; * the first place...&n;&t;&t;&t; */
id|res
op_assign
id|ieee_CVTST
c_func
(paren
id|mode
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
)brace
r_else
(brace
id|res
op_assign
id|ieee_CVTTS
c_func
(paren
id|mode
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_DIVS
suffix:colon
id|res
op_assign
id|ieee_DIVS
c_func
(paren
id|mode
comma
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_DIVT
suffix:colon
id|res
op_assign
id|ieee_DIVT
c_func
(paren
id|mode
comma
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_MULS
suffix:colon
id|res
op_assign
id|ieee_MULS
c_func
(paren
id|mode
comma
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_MULT
suffix:colon
id|res
op_assign
id|ieee_MULT
c_func
(paren
id|mode
comma
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_SUBS
suffix:colon
id|res
op_assign
id|ieee_SUBS
c_func
(paren
id|mode
comma
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_SUBT
suffix:colon
id|res
op_assign
id|ieee_SUBT
c_func
(paren
id|mode
comma
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_ADDS
suffix:colon
id|res
op_assign
id|ieee_ADDS
c_func
(paren
id|mode
comma
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_ADDT
suffix:colon
id|res
op_assign
id|ieee_ADDT
c_func
(paren
id|mode
comma
id|va
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FLTI_FUNC_CVTTQ
suffix:colon
id|res
op_assign
id|ieee_CVTTQ
c_func
(paren
id|mode
comma
id|vb
comma
op_amp
id|vc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;alpha_fp_emul: unexpected function code %#lx at %#lx&quot;
comma
id|opcode
comma
id|pc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Take the appropriate action for each possible&n;&t; * floating-point result:&n;&t; *&n;&t; *&t;- Set the appropriate bits in the FPCR&n;&t; *&t;- If the specified exception is enabled in the FPCR,&n;&t; *&t;  return.  The caller (mxr_signal_handler) will dispatch&n;&t; *&t;  the appropriate signal to the translated program.&n;&t; */
r_if
c_cond
(paren
id|res
)paren
(brace
id|fpcr
op_or_assign
id|FPCR_SUM
op_or
id|res
suffix:semicolon
id|wrfpcr
c_func
(paren
id|fpcr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|res
op_amp
id|FPCR_INV
)paren
op_logical_and
(paren
id|fpcw
op_amp
id|IEEE_TRAP_ENABLE_INV
)paren
)paren
op_logical_or
(paren
(paren
id|res
op_amp
id|FPCR_DZE
)paren
op_logical_and
(paren
id|fpcw
op_amp
id|IEEE_TRAP_ENABLE_DZE
)paren
)paren
op_logical_or
(paren
(paren
id|res
op_amp
id|FPCR_OVF
)paren
op_logical_and
(paren
id|fpcw
op_amp
id|IEEE_TRAP_ENABLE_OVF
)paren
)paren
op_logical_or
(paren
(paren
id|res
op_amp
id|FPCR_UNF
)paren
op_logical_and
(paren
id|fpcw
op_amp
id|IEEE_TRAP_ENABLE_UNF
)paren
)paren
op_logical_or
(paren
(paren
id|res
op_amp
id|FPCR_INE
)paren
op_logical_and
(paren
id|fpcw
op_amp
id|IEEE_TRAP_ENABLE_INE
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Whoo-kay... we got this far, and we&squot;re not generating a signal&n;&t; * to the translated program.  All that remains is to write the&n;&t; * result:&n;&t; */
id|alpha_write_fp_reg
c_func
(paren
id|fc
comma
id|vc
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|alpha_fp_emul_imprecise
id|alpha_fp_emul_imprecise
(paren
r_struct
id|pt_regs
op_star
id|regs
comma
r_int
r_int
id|write_mask
)paren
(brace
r_int
r_int
id|trigger_pc
op_assign
id|regs-&gt;pc
op_minus
l_int|4
suffix:semicolon
r_int
r_int
id|insn
comma
id|opcode
comma
id|rc
suffix:semicolon
multiline_comment|/*&n;&t; * Turn off the bits corresponding to registers that are the&n;&t; * target of instructions that set bits in the exception&n;&t; * summary register.  We have some slack doing this because a&n;&t; * register that is the target of a trapping instruction can&n;&t; * be written at most once in the trap shadow.&n;&t; *&n;&t; * Branches, jumps, TRAPBs, EXCBs and calls to PALcode all&n;&t; * bound the trap shadow, so we need not look any further than&n;&t; * up to the first occurance of such an instruction.&n;&t; */
r_while
c_loop
(paren
id|write_mask
)paren
(brace
id|insn
op_assign
id|get_user
c_func
(paren
(paren
id|__u32
op_star
)paren
(paren
id|trigger_pc
)paren
)paren
suffix:semicolon
id|opcode
op_assign
id|insn
op_rshift
l_int|26
suffix:semicolon
id|rc
op_assign
id|insn
op_amp
l_int|0x1f
suffix:semicolon
r_switch
c_cond
(paren
id|opcode
)paren
(brace
r_case
id|OPC_PAL
suffix:colon
r_case
id|OPC_JSR
suffix:colon
r_case
l_int|0x30
dot
dot
dot
l_int|0x3f
suffix:colon
multiline_comment|/* branches */
r_return
l_int|0
suffix:semicolon
r_case
id|OPC_MISC
suffix:colon
r_switch
c_cond
(paren
id|insn
op_amp
l_int|0xffff
)paren
(brace
r_case
id|MISC_TRAPB
suffix:colon
r_case
id|MISC_EXCB
suffix:colon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OPC_INTA
suffix:colon
r_case
id|OPC_INTL
suffix:colon
r_case
id|OPC_INTS
suffix:colon
r_case
id|OPC_INTM
suffix:colon
id|write_mask
op_and_assign
op_complement
(paren
l_int|1UL
op_lshift
id|rc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPC_FLTV
suffix:colon
r_case
id|OPC_FLTI
suffix:colon
r_case
id|OPC_FLTL
suffix:colon
id|write_mask
op_and_assign
op_complement
(paren
l_int|1UL
op_lshift
(paren
id|rc
op_plus
l_int|32
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|write_mask
)paren
(brace
r_if
c_cond
(paren
(paren
id|opcode
op_eq
id|OPC_FLTI
op_logical_or
id|opcode
op_eq
id|OPC_FLTL
)paren
op_logical_and
id|alpha_fp_emul
c_func
(paren
id|trigger_pc
)paren
)paren
(brace
multiline_comment|/* re-execute insns in trap-shadow: */
id|regs-&gt;pc
op_assign
id|trigger_pc
op_plus
l_int|4
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|trigger_pc
op_sub_assign
l_int|4
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
