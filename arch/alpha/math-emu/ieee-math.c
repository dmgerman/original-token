multiline_comment|/*&n; * ieee-math.c - IEEE floating point emulation code&n; * Copyright (C) 1989,1990,1991,1995 by&n; * Digital Equipment Corporation, Maynard, Massachusetts.&n; *&n; * Heavily modified for Linux/Alpha.  Changes are Copyright (c) 1995&n; * by David Mosberger (davidm@azstarnet.com).&n; *&n; * This file may be redistributed according to the terms of the&n; * GNU General Public License.&n; */
multiline_comment|/*&n; * The original code did not have any comments. I have created many&n; * comments as I fix the bugs in the code.  My comments are based on&n; * my observation and interpretation of the code.  If the original&n; * author would have spend a few minutes to comment the code, we would&n; * never had a problem of misinterpretation.  -HA&n; *&n; * This code could probably be a lot more optimized (especially the&n; * division routine).  However, my foremost concern was to get the&n; * IEEE behavior right.  Performance is less critical as these&n; * functions are used on exceptional numbers only (well, assuming you&n; * don&squot;t turn on the &quot;trap on inexact&quot;...).&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &quot;ieee-math.h&quot;
DECL|macro|STICKY_S
mdefine_line|#define STICKY_S&t;0x20000000&t;/* both in longword 0 of fraction */
DECL|macro|STICKY_T
mdefine_line|#define STICKY_T&t;1
multiline_comment|/*&n; * Careful: order matters here!&n; */
r_enum
(brace
DECL|enumerator|NaN
DECL|enumerator|QNaN
DECL|enumerator|INFTY
DECL|enumerator|ZERO
DECL|enumerator|DENORM
DECL|enumerator|NORMAL
id|NaN
comma
id|QNaN
comma
id|INFTY
comma
id|ZERO
comma
id|DENORM
comma
id|NORMAL
)brace
suffix:semicolon
r_enum
(brace
DECL|enumerator|SINGLE
DECL|enumerator|DOUBLE
id|SINGLE
comma
id|DOUBLE
)brace
suffix:semicolon
DECL|typedef|fpclass_t
r_typedef
r_int
r_int
id|fpclass_t
suffix:semicolon
DECL|macro|IEEE_TMAX
mdefine_line|#define IEEE_TMAX&t;0x7fefffffffffffff
DECL|macro|IEEE_SMAX
mdefine_line|#define IEEE_SMAX&t;0x47efffffe0000000
DECL|macro|IEEE_SNaN
mdefine_line|#define IEEE_SNaN&t;0xfff00000000f0000
DECL|macro|IEEE_QNaN
mdefine_line|#define IEEE_QNaN&t;0xfff8000000000000
DECL|macro|IEEE_PINF
mdefine_line|#define IEEE_PINF&t;0x7ff0000000000000
DECL|macro|IEEE_NINF
mdefine_line|#define IEEE_NINF&t;0xfff0000000000000
multiline_comment|/*&n; * The memory format of S floating point numbers differs from the&n; * register format.  In the following, the bitnumbers above the&n; * diagram below give the memory format while the numbers below give&n; * the register format.&n; *&n; *&t;  31 30&t;     23 22&t;&t;&t;&t;0&n; *&t;+-----------------------------------------------+&n; * S&t;| s |&t;exp    |       fraction&t;&t;&t;|&n; *&t;+-----------------------------------------------+&n; *&t;  63 62&t;     52 51&t;&t;&t;      29&n; *&t;&n; * For T floating point numbers, the register and memory formats&n; * match:&n; *&n; *&t;+-------------------------------------------------------------------+&n; * T&t;| s |&t;     exp&t;|&t;    frac | tion&t;&t;&t;    |&n; *&t;+-------------------------------------------------------------------+&n; *&t;  63 62&t;&t;      52 51&t;       32 31&t;&t;&t;   0&n; */
r_typedef
r_struct
(brace
DECL|member|f
r_int
r_int
id|f
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* bit 55 in f[0] is the factor of 2^0*/
DECL|member|s
r_int
id|s
suffix:semicolon
multiline_comment|/* 1 bit sign (0 for +, 1 for -) */
DECL|member|e
r_int
id|e
suffix:semicolon
multiline_comment|/* 16 bit signed exponent */
DECL|typedef|EXTENDED
)brace
id|EXTENDED
suffix:semicolon
multiline_comment|/*&n; * Return the sign of a Q integer, S or T fp number in the register&n; * format.&n; */
r_static
r_inline
r_int
DECL|function|sign
id|sign
(paren
r_int
r_int
id|a
)paren
(brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|a
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|cmp128
id|cmp128
(paren
r_const
r_int
id|a
(braket
l_int|2
)braket
comma
r_const
r_int
id|b
(braket
l_int|2
)braket
)paren
(brace
r_if
c_cond
(paren
id|a
(braket
l_int|1
)braket
OL
id|b
(braket
l_int|1
)braket
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|a
(braket
l_int|1
)braket
OG
id|b
(braket
l_int|1
)braket
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|a
(braket
l_int|0
)braket
op_minus
id|b
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|sll128
id|sll128
(paren
r_int
r_int
id|a
(braket
l_int|2
)braket
)paren
(brace
id|a
(braket
l_int|1
)braket
op_assign
(paren
id|a
(braket
l_int|1
)braket
op_lshift
l_int|1
)paren
op_or
(paren
id|a
(braket
l_int|0
)braket
op_rshift
l_int|63
)paren
suffix:semicolon
id|a
(braket
l_int|0
)braket
op_lshift_assign
l_int|1
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|srl128
id|srl128
(paren
r_int
r_int
id|a
(braket
l_int|2
)braket
)paren
(brace
id|a
(braket
l_int|0
)braket
op_assign
(paren
id|a
(braket
l_int|0
)braket
op_rshift
l_int|1
)paren
op_or
(paren
id|a
(braket
l_int|1
)braket
op_lshift
l_int|63
)paren
suffix:semicolon
id|a
(braket
l_int|1
)braket
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|add128
id|add128
(paren
r_const
r_int
r_int
id|a
(braket
l_int|2
)braket
comma
r_const
r_int
r_int
id|b
(braket
l_int|2
)braket
comma
r_int
r_int
id|c
(braket
l_int|2
)braket
)paren
(brace
r_int
r_int
id|carry
op_assign
id|a
(braket
l_int|0
)braket
OG
(paren
l_int|0xffffffffffffffff
op_minus
id|b
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|c
(braket
l_int|0
)braket
op_assign
id|a
(braket
l_int|0
)braket
op_plus
id|b
(braket
l_int|0
)braket
suffix:semicolon
id|c
(braket
l_int|1
)braket
op_assign
id|a
(braket
l_int|1
)braket
op_plus
id|b
(braket
l_int|1
)braket
op_plus
id|carry
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|sub128
id|sub128
(paren
r_const
r_int
r_int
id|a
(braket
l_int|2
)braket
comma
r_const
r_int
r_int
id|b
(braket
l_int|2
)braket
comma
r_int
r_int
id|c
(braket
l_int|2
)braket
)paren
(brace
r_int
r_int
id|borrow
op_assign
id|a
(braket
l_int|0
)braket
OL
id|b
(braket
l_int|0
)braket
suffix:semicolon
id|c
(braket
l_int|0
)braket
op_assign
id|a
(braket
l_int|0
)braket
op_minus
id|b
(braket
l_int|0
)braket
suffix:semicolon
id|c
(braket
l_int|1
)braket
op_assign
id|a
(braket
l_int|1
)braket
op_minus
id|b
(braket
l_int|1
)braket
op_minus
id|borrow
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|mul64
id|mul64
(paren
r_const
r_int
r_int
id|a
comma
r_const
r_int
r_int
id|b
comma
r_int
r_int
id|c
(braket
l_int|2
)braket
)paren
(brace
id|c
(braket
l_int|0
)braket
op_assign
id|a
op_star
id|b
suffix:semicolon
id|asm
(paren
l_string|&quot;umulh %1,%2,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|c
(braket
l_int|1
)braket
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|a
)paren
comma
l_string|&quot;r&quot;
(paren
id|b
)paren
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|div128
id|div128
(paren
r_int
r_int
id|a
(braket
l_int|2
)braket
comma
r_int
r_int
id|b
(braket
l_int|2
)braket
comma
r_int
r_int
id|c
(braket
l_int|2
)braket
)paren
(brace
r_int
r_int
id|mask
(braket
l_int|2
)braket
op_assign
(brace
l_int|1
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n;&t; * Shift b until either the sign bit is set or until it is at&n;&t; * least as big as the dividend:&n;&t; */
r_while
c_loop
(paren
id|cmp128
c_func
(paren
id|b
comma
id|a
)paren
OL
l_int|0
op_logical_and
id|sign
c_func
(paren
id|b
(braket
l_int|1
)braket
)paren
op_ge
l_int|0
)paren
(brace
id|sll128
c_func
(paren
id|b
)paren
suffix:semicolon
id|sll128
c_func
(paren
id|mask
)paren
suffix:semicolon
)brace
id|c
(braket
l_int|0
)braket
op_assign
id|c
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|cmp128
c_func
(paren
id|a
comma
id|b
)paren
op_ge
l_int|0
)paren
(brace
id|sub128
c_func
(paren
id|a
comma
id|b
comma
id|a
)paren
suffix:semicolon
id|add128
c_func
(paren
id|mask
comma
id|c
comma
id|c
)paren
suffix:semicolon
)brace
id|srl128
c_func
(paren
id|mask
)paren
suffix:semicolon
id|srl128
c_func
(paren
id|b
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|mask
(braket
l_int|0
)braket
op_logical_or
id|mask
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|normalize
id|normalize
(paren
id|EXTENDED
op_star
id|a
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|a-&gt;f
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|a-&gt;f
(braket
l_int|1
)braket
)paren
r_return
suffix:semicolon
multiline_comment|/* zero fraction, unnormalizable... */
multiline_comment|/*&n;&t; * In &quot;extended&quot; format, the &quot;1&quot; in &quot;1.f&quot; is explicit; it is&n;&t; * in bit 55 of f[0], and the decimal point is understood to&n;&t; * be between bit 55 and bit 54.  To normalize, shift the&n;&t; * fraction until we have a &quot;1&quot; in bit 55.&n;&t; */
r_if
c_cond
(paren
(paren
id|a-&gt;f
(braket
l_int|0
)braket
op_amp
l_int|0xff00000000000000
)paren
op_ne
l_int|0
op_logical_or
id|a-&gt;f
(braket
l_int|1
)braket
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * Mantissa is greater than 1.0:&n;&t;&t; */
r_while
c_loop
(paren
(paren
id|a-&gt;f
(braket
l_int|0
)braket
op_amp
l_int|0xff80000000000000
)paren
op_ne
l_int|0x0080000000000000
op_logical_or
id|a-&gt;f
(braket
l_int|1
)braket
op_ne
l_int|0
)paren
(brace
r_int
r_int
id|sticky
suffix:semicolon
op_increment
id|a-&gt;e
suffix:semicolon
id|sticky
op_assign
id|a-&gt;f
(braket
l_int|0
)braket
op_amp
l_int|1
suffix:semicolon
id|srl128
c_func
(paren
id|a-&gt;f
)paren
suffix:semicolon
id|a-&gt;f
(braket
l_int|0
)braket
op_or_assign
id|sticky
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|a-&gt;f
(braket
l_int|0
)braket
op_amp
l_int|0x0080000000000000
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Mantissa is less than 1.0:&n;&t;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
id|a-&gt;f
(braket
l_int|0
)braket
op_amp
l_int|0x0080000000000000
)paren
)paren
(brace
op_decrement
id|a-&gt;e
suffix:semicolon
id|a-&gt;f
(braket
l_int|0
)braket
op_lshift_assign
l_int|1
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
)brace
r_static
r_inline
id|fpclass_t
DECL|function|ieee_fpclass
id|ieee_fpclass
(paren
r_int
r_int
id|a
)paren
(brace
r_int
r_int
id|exp
comma
id|fract
suffix:semicolon
id|exp
op_assign
(paren
id|a
op_rshift
l_int|52
)paren
op_amp
l_int|0x7ff
suffix:semicolon
multiline_comment|/* 11 bits of exponent */
id|fract
op_assign
id|a
op_amp
l_int|0x000fffffffffffff
suffix:semicolon
multiline_comment|/* 52 bits of fraction */
r_if
c_cond
(paren
id|exp
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|fract
op_eq
l_int|0
)paren
r_return
id|ZERO
suffix:semicolon
r_return
id|DENORM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|exp
op_eq
l_int|0x7ff
)paren
(brace
r_if
c_cond
(paren
id|fract
op_eq
l_int|0
)paren
r_return
id|INFTY
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|fract
op_rshift
l_int|51
)paren
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
r_return
id|QNaN
suffix:semicolon
r_return
id|NaN
suffix:semicolon
)brace
r_return
id|NORMAL
suffix:semicolon
)brace
multiline_comment|/*&n; * Translate S/T fp number in register format into extended format.&n; */
r_static
id|fpclass_t
DECL|function|extend_ieee
id|extend_ieee
(paren
r_int
r_int
id|a
comma
id|EXTENDED
op_star
id|b
comma
r_int
id|prec
)paren
(brace
id|fpclass_t
id|result_kind
suffix:semicolon
id|b-&gt;s
op_assign
id|a
op_rshift
l_int|63
suffix:semicolon
id|b-&gt;e
op_assign
(paren
(paren
id|a
op_rshift
l_int|52
)paren
op_amp
l_int|0x7ff
)paren
op_minus
l_int|0x3ff
suffix:semicolon
multiline_comment|/* remove bias */
id|b-&gt;f
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * We shift f[1] left three bits so that the higher order bits&n;&t; * of the fraction will reside in bits 55 through 0 of f[0].&n;&t; */
id|b-&gt;f
(braket
l_int|0
)braket
op_assign
(paren
id|a
op_amp
l_int|0x000fffffffffffff
)paren
op_lshift
l_int|3
suffix:semicolon
id|result_kind
op_assign
id|ieee_fpclass
c_func
(paren
id|a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result_kind
op_eq
id|NORMAL
)paren
(brace
multiline_comment|/* set implied 1. bit: */
id|b-&gt;f
(braket
l_int|0
)braket
op_or_assign
l_int|1UL
op_lshift
l_int|55
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result_kind
op_eq
id|DENORM
)paren
(brace
r_if
c_cond
(paren
id|prec
op_eq
id|SINGLE
)paren
id|b-&gt;e
op_assign
op_minus
l_int|126
suffix:semicolon
r_else
id|b-&gt;e
op_assign
op_minus
l_int|1022
suffix:semicolon
)brace
r_return
id|result_kind
suffix:semicolon
)brace
multiline_comment|/*&n; * INPUT PARAMETERS:&n; *       a           a number in EXTENDED format to be converted to&n; *                   s-floating format.&n; *&t; f&t;     rounding mode and exception enable bits.&n; * OUTPUT PARAMETERS:&n; *       b          will contain the s-floating number that &quot;a&quot; was&n; *                  converted to (in register format).&n; */
r_static
r_int
r_int
DECL|function|make_s_ieee
id|make_s_ieee
(paren
r_int
id|f
comma
id|EXTENDED
op_star
id|a
comma
r_int
r_int
op_star
id|b
)paren
(brace
r_int
r_int
id|res
comma
id|sticky
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|a-&gt;e
op_logical_and
op_logical_neg
id|a-&gt;f
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|a-&gt;f
(braket
l_int|1
)braket
)paren
(brace
op_star
id|b
op_assign
(paren
r_int
r_int
)paren
id|a-&gt;s
op_lshift
l_int|63
suffix:semicolon
multiline_comment|/* return +/-0 */
r_return
l_int|0
suffix:semicolon
)brace
id|normalize
c_func
(paren
id|a
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;e
OL
op_minus
l_int|0x7e
)paren
(brace
id|res
op_assign
id|FPCR_INE
suffix:semicolon
r_if
c_cond
(paren
id|f
op_amp
id|IEEE_TRAP_ENABLE_UNF
)paren
(brace
id|res
op_or_assign
id|FPCR_UNF
suffix:semicolon
id|a-&gt;e
op_add_assign
l_int|0xc0
suffix:semicolon
multiline_comment|/* scale up result by 2^alpha */
)brace
r_else
(brace
multiline_comment|/* try making denormalized number: */
r_while
c_loop
(paren
id|a-&gt;e
OL
op_minus
l_int|0x7e
)paren
(brace
op_increment
id|a-&gt;e
suffix:semicolon
id|sticky
op_assign
id|a-&gt;f
(braket
l_int|0
)braket
op_amp
l_int|1
suffix:semicolon
id|srl128
c_func
(paren
id|a-&gt;f
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|a-&gt;f
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|a-&gt;f
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* underflow: replace with exact 0 */
id|res
op_or_assign
id|FPCR_UNF
suffix:semicolon
r_break
suffix:semicolon
)brace
id|a-&gt;f
(braket
l_int|0
)braket
op_or_assign
id|sticky
suffix:semicolon
)brace
id|a-&gt;e
op_assign
op_minus
l_int|0x3ff
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|a-&gt;e
op_ge
l_int|0x80
)paren
(brace
id|res
op_assign
id|FPCR_OVF
op_or
id|FPCR_INE
suffix:semicolon
r_if
c_cond
(paren
id|f
op_amp
id|IEEE_TRAP_ENABLE_OVF
)paren
(brace
id|a-&gt;e
op_sub_assign
l_int|0xc0
suffix:semicolon
multiline_comment|/* scale down result by 2^alpha */
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Overflow without trap enabled, substitute&n;&t;&t;&t; * result according to rounding mode:&n;&t;&t;&t; */
r_switch
c_cond
(paren
id|RM
c_func
(paren
id|f
)paren
)paren
(brace
r_case
id|ROUND_NEAR
suffix:colon
op_star
id|b
op_assign
id|IEEE_PINF
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ROUND_CHOP
suffix:colon
op_star
id|b
op_assign
id|IEEE_SMAX
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ROUND_NINF
suffix:colon
r_if
c_cond
(paren
id|a-&gt;s
)paren
(brace
op_star
id|b
op_assign
id|IEEE_PINF
suffix:semicolon
)brace
r_else
(brace
op_star
id|b
op_assign
id|IEEE_SMAX
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ROUND_PINF
suffix:colon
r_if
c_cond
(paren
id|a-&gt;s
)paren
(brace
op_star
id|b
op_assign
id|IEEE_SMAX
suffix:semicolon
)brace
r_else
(brace
op_star
id|b
op_assign
id|IEEE_PINF
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
op_star
id|b
op_or_assign
(paren
(paren
r_int
r_int
)paren
id|a-&gt;s
op_lshift
l_int|63
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
)brace
op_star
id|b
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|a-&gt;s
op_lshift
l_int|63
)paren
op_or
(paren
(paren
(paren
r_int
r_int
)paren
id|a-&gt;e
op_plus
l_int|0x3ff
)paren
op_lshift
l_int|52
)paren
op_or
(paren
(paren
id|a-&gt;f
(braket
l_int|0
)braket
op_rshift
l_int|3
)paren
op_amp
l_int|0x000fffffe0000000
)paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|make_t_ieee
id|make_t_ieee
(paren
r_int
id|f
comma
id|EXTENDED
op_star
id|a
comma
r_int
r_int
op_star
id|b
)paren
(brace
r_int
r_int
id|res
comma
id|sticky
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|a-&gt;e
op_logical_and
op_logical_neg
id|a-&gt;f
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|a-&gt;f
(braket
l_int|1
)braket
)paren
(brace
op_star
id|b
op_assign
(paren
r_int
r_int
)paren
id|a-&gt;s
op_lshift
l_int|63
suffix:semicolon
multiline_comment|/* return +/-0 */
r_return
l_int|0
suffix:semicolon
)brace
id|normalize
c_func
(paren
id|a
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|a-&gt;e
OL
op_minus
l_int|0x3fe
)paren
(brace
id|res
op_assign
id|FPCR_INE
suffix:semicolon
r_if
c_cond
(paren
id|f
op_amp
id|IEEE_TRAP_ENABLE_UNF
)paren
(brace
id|res
op_or_assign
id|FPCR_UNF
suffix:semicolon
id|a-&gt;e
op_add_assign
l_int|0x600
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* try making denormalized number: */
r_while
c_loop
(paren
id|a-&gt;e
OL
op_minus
l_int|0x3fe
)paren
(brace
op_increment
id|a-&gt;e
suffix:semicolon
id|sticky
op_assign
id|a-&gt;f
(braket
l_int|0
)braket
op_amp
l_int|1
suffix:semicolon
id|srl128
c_func
(paren
id|a-&gt;f
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|a-&gt;f
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|a-&gt;f
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* underflow: replace with exact 0 */
id|res
op_or_assign
id|FPCR_UNF
suffix:semicolon
r_break
suffix:semicolon
)brace
id|a-&gt;f
(braket
l_int|0
)braket
op_or_assign
id|sticky
suffix:semicolon
)brace
id|a-&gt;e
op_assign
op_minus
l_int|0x3ff
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|a-&gt;e
op_ge
l_int|0x3ff
)paren
(brace
id|res
op_assign
id|FPCR_OVF
op_or
id|FPCR_INE
suffix:semicolon
r_if
c_cond
(paren
id|f
op_amp
id|IEEE_TRAP_ENABLE_OVF
)paren
(brace
id|a-&gt;e
op_sub_assign
l_int|0x600
suffix:semicolon
multiline_comment|/* scale down result by 2^alpha */
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Overflow without trap enabled, substitute&n;&t;&t;&t; * result according to rounding mode:&n;&t;&t;&t; */
r_switch
c_cond
(paren
id|RM
c_func
(paren
id|f
)paren
)paren
(brace
r_case
id|ROUND_NEAR
suffix:colon
op_star
id|b
op_assign
id|IEEE_PINF
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ROUND_CHOP
suffix:colon
op_star
id|b
op_assign
id|IEEE_TMAX
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ROUND_NINF
suffix:colon
r_if
c_cond
(paren
id|a-&gt;s
)paren
(brace
op_star
id|b
op_assign
id|IEEE_PINF
suffix:semicolon
)brace
r_else
(brace
op_star
id|b
op_assign
id|IEEE_TMAX
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ROUND_PINF
suffix:colon
r_if
c_cond
(paren
id|a-&gt;s
)paren
(brace
op_star
id|b
op_assign
id|IEEE_TMAX
suffix:semicolon
)brace
r_else
(brace
op_star
id|b
op_assign
id|IEEE_PINF
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
op_star
id|b
op_or_assign
(paren
(paren
r_int
r_int
)paren
id|a-&gt;s
op_lshift
l_int|63
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
)brace
op_star
id|b
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|a-&gt;s
op_lshift
l_int|63
)paren
op_or
(paren
(paren
(paren
r_int
r_int
)paren
id|a-&gt;e
op_plus
l_int|0x3ff
)paren
op_lshift
l_int|52
)paren
op_or
(paren
(paren
id|a-&gt;f
(braket
l_int|0
)braket
op_rshift
l_int|3
)paren
op_amp
l_int|0x000fffffffffffff
)paren
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/*&n; * INPUT PARAMETERS:&n; *       a          EXTENDED format number to be rounded.&n; *       rm&t;    integer with value ROUND_NEAR, ROUND_CHOP, etc.&n; *                  indicates how &quot;a&quot; should be rounded to produce &quot;b&quot;.&n; * OUTPUT PARAMETERS:&n; *       b          s-floating number produced by rounding &quot;a&quot;.&n; * RETURN VALUE:&n; *       if no errors occurred, will be zero.  Else will contain flags&n; *       like FPCR_INE_OP, etc.&n; */
r_static
r_int
r_int
DECL|function|round_s_ieee
id|round_s_ieee
(paren
r_int
id|f
comma
id|EXTENDED
op_star
id|a
comma
r_int
r_int
op_star
id|b
)paren
(brace
r_int
r_int
id|diff1
comma
id|diff2
comma
id|res
op_assign
l_int|0
suffix:semicolon
id|EXTENDED
id|z1
comma
id|z2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|a-&gt;f
(braket
l_int|0
)braket
op_amp
l_int|0xffffffff
)paren
)paren
(brace
r_return
id|make_s_ieee
c_func
(paren
id|f
comma
id|a
comma
id|b
)paren
suffix:semicolon
multiline_comment|/* no rounding error */
)brace
multiline_comment|/*&n;&t; * z1 and z2 are the S-floating numbers with the next smaller/greater&n;&t; * magnitude than a, respectively.&n;&t; */
id|z1.s
op_assign
id|z2.s
op_assign
id|a-&gt;s
suffix:semicolon
id|z1.e
op_assign
id|z2.e
op_assign
id|a-&gt;e
suffix:semicolon
id|z1.f
(braket
l_int|0
)braket
op_assign
id|z2.f
(braket
l_int|0
)braket
op_assign
id|a-&gt;f
(braket
l_int|0
)braket
op_amp
l_int|0xffffffff00000000
suffix:semicolon
id|z1.f
(braket
l_int|1
)braket
op_assign
id|z2.f
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|z2.f
(braket
l_int|0
)braket
op_add_assign
l_int|0x100000000
suffix:semicolon
multiline_comment|/* next bigger S float number */
r_switch
c_cond
(paren
id|RM
c_func
(paren
id|f
)paren
)paren
(brace
r_case
id|ROUND_NEAR
suffix:colon
id|diff1
op_assign
id|a-&gt;f
(braket
l_int|0
)braket
op_minus
id|z1.f
(braket
l_int|0
)braket
suffix:semicolon
id|diff2
op_assign
id|z2.f
(braket
l_int|0
)braket
op_minus
id|a-&gt;f
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|diff1
OG
id|diff2
)paren
id|res
op_assign
id|make_s_ieee
c_func
(paren
id|f
comma
op_amp
id|z2
comma
id|b
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|diff2
OG
id|diff1
)paren
id|res
op_assign
id|make_s_ieee
c_func
(paren
id|f
comma
op_amp
id|z1
comma
id|b
)paren
suffix:semicolon
r_else
multiline_comment|/* equal distance: round towards even */
r_if
c_cond
(paren
id|z1.f
(braket
l_int|0
)braket
op_amp
l_int|0x100000000
)paren
id|res
op_assign
id|make_s_ieee
c_func
(paren
id|f
comma
op_amp
id|z2
comma
id|b
)paren
suffix:semicolon
r_else
id|res
op_assign
id|make_s_ieee
c_func
(paren
id|f
comma
op_amp
id|z1
comma
id|b
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ROUND_CHOP
suffix:colon
id|res
op_assign
id|make_s_ieee
c_func
(paren
id|f
comma
op_amp
id|z1
comma
id|b
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ROUND_PINF
suffix:colon
r_if
c_cond
(paren
id|a-&gt;s
)paren
(brace
id|res
op_assign
id|make_s_ieee
c_func
(paren
id|f
comma
op_amp
id|z1
comma
id|b
)paren
suffix:semicolon
)brace
r_else
(brace
id|res
op_assign
id|make_s_ieee
c_func
(paren
id|f
comma
op_amp
id|z2
comma
id|b
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ROUND_NINF
suffix:colon
r_if
c_cond
(paren
id|a-&gt;s
)paren
(brace
id|res
op_assign
id|make_s_ieee
c_func
(paren
id|f
comma
op_amp
id|z2
comma
id|b
)paren
suffix:semicolon
)brace
r_else
(brace
id|res
op_assign
id|make_s_ieee
c_func
(paren
id|f
comma
op_amp
id|z1
comma
id|b
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
id|FPCR_INE
op_or
id|res
suffix:semicolon
)brace
r_static
r_int
r_int
DECL|function|round_t_ieee
id|round_t_ieee
(paren
r_int
id|f
comma
id|EXTENDED
op_star
id|a
comma
r_int
r_int
op_star
id|b
)paren
(brace
r_int
r_int
id|diff1
comma
id|diff2
comma
id|res
suffix:semicolon
id|EXTENDED
id|z1
comma
id|z2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|a-&gt;f
(braket
l_int|0
)braket
op_amp
l_int|0x7
)paren
)paren
(brace
multiline_comment|/* no rounding error */
r_return
id|make_t_ieee
c_func
(paren
id|f
comma
id|a
comma
id|b
)paren
suffix:semicolon
)brace
id|z1.s
op_assign
id|z2.s
op_assign
id|a-&gt;s
suffix:semicolon
id|z1.e
op_assign
id|z2.e
op_assign
id|a-&gt;e
suffix:semicolon
id|z1.f
(braket
l_int|0
)braket
op_assign
id|z2.f
(braket
l_int|0
)braket
op_assign
id|a-&gt;f
(braket
l_int|0
)braket
op_amp
op_complement
l_int|0x7
suffix:semicolon
id|z1.f
(braket
l_int|1
)braket
op_assign
id|z2.f
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|z2.f
(braket
l_int|0
)braket
op_add_assign
(paren
l_int|1
op_lshift
l_int|3
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|RM
c_func
(paren
id|f
)paren
)paren
(brace
r_case
id|ROUND_NEAR
suffix:colon
id|diff1
op_assign
id|a-&gt;f
(braket
l_int|0
)braket
op_minus
id|z1.f
(braket
l_int|0
)braket
suffix:semicolon
id|diff2
op_assign
id|z2.f
(braket
l_int|0
)braket
op_minus
id|a-&gt;f
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|diff1
OG
id|diff2
)paren
id|res
op_assign
id|make_t_ieee
c_func
(paren
id|f
comma
op_amp
id|z2
comma
id|b
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|diff2
OG
id|diff1
)paren
id|res
op_assign
id|make_t_ieee
c_func
(paren
id|f
comma
op_amp
id|z1
comma
id|b
)paren
suffix:semicolon
r_else
multiline_comment|/* equal distance: round towards even */
r_if
c_cond
(paren
id|z1.f
(braket
l_int|0
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|3
)paren
)paren
id|res
op_assign
id|make_t_ieee
c_func
(paren
id|f
comma
op_amp
id|z2
comma
id|b
)paren
suffix:semicolon
r_else
id|res
op_assign
id|make_t_ieee
c_func
(paren
id|f
comma
op_amp
id|z1
comma
id|b
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ROUND_CHOP
suffix:colon
id|res
op_assign
id|make_t_ieee
c_func
(paren
id|f
comma
op_amp
id|z1
comma
id|b
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ROUND_PINF
suffix:colon
r_if
c_cond
(paren
id|a-&gt;s
)paren
(brace
id|res
op_assign
id|make_t_ieee
c_func
(paren
id|f
comma
op_amp
id|z1
comma
id|b
)paren
suffix:semicolon
)brace
r_else
(brace
id|res
op_assign
id|make_t_ieee
c_func
(paren
id|f
comma
op_amp
id|z2
comma
id|b
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ROUND_NINF
suffix:colon
r_if
c_cond
(paren
id|a-&gt;s
)paren
(brace
id|res
op_assign
id|make_t_ieee
c_func
(paren
id|f
comma
op_amp
id|z2
comma
id|b
)paren
suffix:semicolon
)brace
r_else
(brace
id|res
op_assign
id|make_t_ieee
c_func
(paren
id|f
comma
op_amp
id|z1
comma
id|b
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
id|FPCR_INE
op_or
id|res
suffix:semicolon
)brace
r_static
id|fpclass_t
DECL|function|add_kernel_ieee
id|add_kernel_ieee
(paren
id|EXTENDED
op_star
id|op_a
comma
id|EXTENDED
op_star
id|op_b
comma
id|EXTENDED
op_star
id|op_c
)paren
(brace
r_int
r_int
id|mask
comma
id|fa
comma
id|fb
comma
id|fc
suffix:semicolon
r_int
id|diff
suffix:semicolon
id|diff
op_assign
id|op_a-&gt;e
op_minus
id|op_b-&gt;e
suffix:semicolon
id|fa
op_assign
id|op_a-&gt;f
(braket
l_int|0
)braket
suffix:semicolon
id|fb
op_assign
id|op_b-&gt;f
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|diff
OL
l_int|0
)paren
(brace
id|diff
op_assign
op_minus
id|diff
suffix:semicolon
id|op_c-&gt;e
op_assign
id|op_b-&gt;e
suffix:semicolon
id|mask
op_assign
(paren
l_int|1UL
op_lshift
id|diff
)paren
op_minus
l_int|1
suffix:semicolon
id|fa
op_rshift_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|op_a-&gt;f
(braket
l_int|0
)braket
op_amp
id|mask
)paren
(brace
id|fa
op_or_assign
l_int|1
suffix:semicolon
multiline_comment|/* set sticky bit */
)brace
)brace
r_else
(brace
id|op_c-&gt;e
op_assign
id|op_a-&gt;e
suffix:semicolon
id|mask
op_assign
(paren
l_int|1UL
op_lshift
id|diff
)paren
op_minus
l_int|1
suffix:semicolon
id|fb
op_rshift_assign
id|diff
suffix:semicolon
r_if
c_cond
(paren
id|op_b-&gt;f
(braket
l_int|0
)braket
op_amp
id|mask
)paren
(brace
id|fb
op_or_assign
l_int|1
suffix:semicolon
multiline_comment|/* set sticky bit */
)brace
)brace
r_if
c_cond
(paren
id|op_a-&gt;s
)paren
id|fa
op_assign
op_minus
id|fa
suffix:semicolon
r_if
c_cond
(paren
id|op_b-&gt;s
)paren
id|fb
op_assign
op_minus
id|fb
suffix:semicolon
id|fc
op_assign
id|fa
op_plus
id|fb
suffix:semicolon
id|op_c-&gt;f
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|op_c-&gt;s
op_assign
id|fc
op_rshift
l_int|63
suffix:semicolon
r_if
c_cond
(paren
id|op_c-&gt;s
)paren
(brace
id|fc
op_assign
op_minus
id|fc
suffix:semicolon
)brace
id|op_c-&gt;f
(braket
l_int|0
)braket
op_assign
id|fc
suffix:semicolon
id|normalize
c_func
(paren
id|op_c
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * converts s-floating &quot;a&quot; to t-floating &quot;b&quot;.&n; *&n; * INPUT PARAMETERS:&n; *       a           a s-floating number to be converted&n; *       f           the rounding mode (ROUND_NEAR, etc. )&n; * OUTPUT PARAMETERS:&n; *       b           the t-floating number that &quot;a&quot; is converted to.&n; * RETURN VALUE:&n; *       error flags - i.e., zero if no errors occurred,&n; *       FPCR_INV if invalid operation occurred, etc.&n; */
r_int
r_int
DECL|function|ieee_CVTST
id|ieee_CVTST
(paren
r_int
id|f
comma
r_int
r_int
id|a
comma
r_int
r_int
op_star
id|b
)paren
(brace
id|EXTENDED
id|temp
suffix:semicolon
id|fpclass_t
id|a_type
suffix:semicolon
id|a_type
op_assign
id|extend_ieee
c_func
(paren
id|a
comma
op_amp
id|temp
comma
id|SINGLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_ge
id|NaN
op_logical_and
id|a_type
op_le
id|INFTY
)paren
(brace
op_star
id|b
op_assign
id|a
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
)paren
(brace
op_star
id|b
op_or_assign
(paren
l_int|1UL
op_lshift
l_int|51
)paren
suffix:semicolon
multiline_comment|/* turn SNaN into QNaN */
r_return
id|FPCR_INV
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|round_t_ieee
c_func
(paren
id|f
comma
op_amp
id|temp
comma
id|b
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * converts t-floating &quot;a&quot; to s-floating &quot;b&quot;.&n; *&n; * INPUT PARAMETERS:&n; *       a           a t-floating number to be converted&n; *       f           the rounding mode (ROUND_NEAR, etc. )&n; * OUTPUT PARAMETERS:&n; *       b           the s-floating number that &quot;a&quot; is converted to.&n; * RETURN VALUE:&n; *       error flags - i.e., zero if no errors occurred,&n; *       FPCR_INV if invalid operation occurred, etc.&n; */
r_int
r_int
DECL|function|ieee_CVTTS
id|ieee_CVTTS
(paren
r_int
id|f
comma
r_int
r_int
id|a
comma
r_int
r_int
op_star
id|b
)paren
(brace
id|EXTENDED
id|temp
suffix:semicolon
id|fpclass_t
id|a_type
suffix:semicolon
id|a_type
op_assign
id|extend_ieee
c_func
(paren
id|a
comma
op_amp
id|temp
comma
id|DOUBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_ge
id|NaN
op_logical_and
id|a_type
op_le
id|INFTY
)paren
(brace
op_star
id|b
op_assign
id|a
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
)paren
(brace
op_star
id|b
op_or_assign
(paren
l_int|1UL
op_lshift
l_int|51
)paren
suffix:semicolon
multiline_comment|/* turn SNaN into QNaN */
r_return
id|FPCR_INV
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|round_s_ieee
c_func
(paren
id|f
comma
op_amp
id|temp
comma
id|b
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * converts q-format (64-bit integer) &quot;a&quot; to s-floating &quot;b&quot;.&n; *&n; * INPUT PARAMETERS:&n; *       a           an 64-bit integer to be converted.&n; *       f           the rounding mode (ROUND_NEAR, etc. )&n; * OUTPUT PARAMETERS:&n; *       b           the s-floating number &quot;a&quot; is converted to.&n; * RETURN VALUE:&n; *       error flags - i.e., zero if no errors occurred,&n; *       FPCR_INV if invalid operation occurred, etc.&n; */
r_int
r_int
DECL|function|ieee_CVTQS
id|ieee_CVTQS
(paren
r_int
id|f
comma
r_int
r_int
id|a
comma
r_int
r_int
op_star
id|b
)paren
(brace
id|EXTENDED
id|op_b
suffix:semicolon
id|op_b.s
op_assign
l_int|0
suffix:semicolon
id|op_b.f
(braket
l_int|0
)braket
op_assign
id|a
suffix:semicolon
id|op_b.f
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sign
c_func
(paren
id|a
)paren
OL
l_int|0
)paren
(brace
id|op_b.s
op_assign
l_int|1
suffix:semicolon
id|op_b.f
(braket
l_int|0
)braket
op_assign
op_minus
id|a
suffix:semicolon
)brace
id|op_b.e
op_assign
l_int|55
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|op_b
)paren
suffix:semicolon
r_return
id|round_s_ieee
c_func
(paren
id|f
comma
op_amp
id|op_b
comma
id|b
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * converts 64-bit integer &quot;a&quot; to t-floating &quot;b&quot;.&n; *&n; * INPUT PARAMETERS:&n; *       a           a 64-bit integer to be converted.&n; *       f           the rounding mode (ROUND_NEAR, etc.)&n; * OUTPUT PARAMETERS:&n; *       b           the t-floating number &quot;a&quot; is converted to.&n; * RETURN VALUE:&n; *       error flags - i.e., zero if no errors occurred,&n; *       FPCR_INV if invalid operation occurred, etc.&n; */
r_int
r_int
DECL|function|ieee_CVTQT
id|ieee_CVTQT
(paren
r_int
id|f
comma
r_int
r_int
id|a
comma
r_int
r_int
op_star
id|b
)paren
(brace
id|EXTENDED
id|op_b
suffix:semicolon
id|op_b.s
op_assign
l_int|0
suffix:semicolon
id|op_b.f
(braket
l_int|0
)braket
op_assign
id|a
suffix:semicolon
id|op_b.f
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sign
c_func
(paren
id|a
)paren
OL
l_int|0
)paren
(brace
id|op_b.s
op_assign
l_int|1
suffix:semicolon
id|op_b.f
(braket
l_int|0
)braket
op_assign
op_minus
id|a
suffix:semicolon
)brace
id|op_b.e
op_assign
l_int|55
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|op_b
)paren
suffix:semicolon
r_return
id|round_t_ieee
c_func
(paren
id|f
comma
op_amp
id|op_b
comma
id|b
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * converts t-floating &quot;a&quot; to 64-bit integer (q-format) &quot;b&quot;.&n; *&n; * INPUT PARAMETERS:&n; *       a           a t-floating number to be converted.&n; *       f           the rounding mode (ROUND_NEAR, etc. )&n; * OUTPUT PARAMETERS:&n; *       b           the 64-bit integer &quot;a&quot; is converted to.&n; * RETURN VALUE:&n; *       error flags - i.e., zero if no errors occurred,&n; *       FPCR_INV if invalid operation occurred, etc.&n; */
r_int
r_int
DECL|function|ieee_CVTTQ
id|ieee_CVTTQ
(paren
r_int
id|f
comma
r_int
r_int
id|a
comma
r_int
r_int
op_star
id|pb
)paren
(brace
r_int
r_int
id|midway
suffix:semicolon
r_int
r_int
id|ov
comma
id|uv
comma
id|res
comma
id|b
suffix:semicolon
id|fpclass_t
id|a_type
suffix:semicolon
id|EXTENDED
id|temp
suffix:semicolon
id|a_type
op_assign
id|extend_ieee
c_func
(paren
id|a
comma
op_amp
id|temp
comma
id|DOUBLE
)paren
suffix:semicolon
id|b
op_assign
l_int|0x7fffffffffffffff
suffix:semicolon
id|res
op_assign
id|FPCR_INV
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
op_logical_or
id|a_type
op_eq
id|INFTY
)paren
r_goto
id|out
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
id|temp.e
OG
l_int|0
)paren
(brace
id|ov
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|temp.e
OG
l_int|0
)paren
(brace
op_decrement
id|temp.e
suffix:semicolon
id|ov
op_or_assign
id|temp.f
(braket
l_int|1
)braket
op_rshift
l_int|63
suffix:semicolon
id|sll128
c_func
(paren
id|temp.f
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ov
op_logical_or
(paren
id|temp.f
(braket
l_int|1
)braket
op_amp
l_int|0xffc0000000000000
)paren
)paren
id|res
op_or_assign
id|FPCR_IOV
op_or
id|FPCR_INE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|temp.e
OL
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|temp.e
OL
l_int|0
)paren
(brace
op_increment
id|temp.e
suffix:semicolon
id|uv
op_assign
id|temp.f
(braket
l_int|0
)braket
op_amp
l_int|1
suffix:semicolon
multiline_comment|/* save sticky bit */
id|srl128
c_func
(paren
id|temp.f
)paren
suffix:semicolon
id|temp.f
(braket
l_int|0
)braket
op_or_assign
id|uv
suffix:semicolon
)brace
)brace
id|b
op_assign
(paren
id|temp.f
(braket
l_int|1
)braket
op_lshift
l_int|9
)paren
op_or
(paren
id|temp.f
(braket
l_int|0
)braket
op_rshift
l_int|55
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Notice: the fraction is only 52 bits long.  Thus, rounding&n;&t; * cannot possibly result in an integer overflow.&n;&t; */
r_switch
c_cond
(paren
id|RM
c_func
(paren
id|f
)paren
)paren
(brace
r_case
id|ROUND_NEAR
suffix:colon
r_if
c_cond
(paren
id|temp.f
(braket
l_int|0
)braket
op_amp
l_int|0x0040000000000000
)paren
(brace
id|midway
op_assign
(paren
id|temp.f
(braket
l_int|0
)braket
op_amp
l_int|0x003fffffffffffff
)paren
op_eq
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|midway
op_logical_and
(paren
id|temp.f
(braket
l_int|0
)braket
op_amp
l_int|0x0080000000000000
)paren
)paren
op_logical_or
op_logical_neg
id|midway
)paren
op_increment
id|b
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ROUND_PINF
suffix:colon
id|b
op_add_assign
(paren
(paren
id|temp.f
(braket
l_int|0
)braket
op_amp
l_int|0x007fffffffffffff
)paren
op_ne
l_int|0
op_logical_and
op_logical_neg
id|temp.s
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ROUND_NINF
suffix:colon
id|b
op_add_assign
(paren
(paren
id|temp.f
(braket
l_int|0
)braket
op_amp
l_int|0x007fffffffffffff
)paren
op_ne
l_int|0
op_logical_and
id|temp.s
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ROUND_CHOP
suffix:colon
multiline_comment|/* no action needed */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|temp.f
(braket
l_int|0
)braket
op_amp
l_int|0x007fffffffffffff
)paren
op_ne
l_int|0
)paren
id|res
op_or_assign
id|FPCR_INE
suffix:semicolon
r_if
c_cond
(paren
id|temp.s
)paren
(brace
id|b
op_assign
op_minus
id|b
suffix:semicolon
)brace
id|out
suffix:colon
op_star
id|pb
op_assign
id|b
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
r_int
r_int
DECL|function|ieee_CMPTEQ
id|ieee_CMPTEQ
(paren
r_int
r_int
id|a
comma
r_int
r_int
id|b
comma
r_int
r_int
op_star
id|c
)paren
(brace
id|EXTENDED
id|op_a
comma
id|op_b
suffix:semicolon
id|fpclass_t
id|a_type
comma
id|b_type
suffix:semicolon
op_star
id|c
op_assign
l_int|0
suffix:semicolon
id|a_type
op_assign
id|extend_ieee
c_func
(paren
id|a
comma
op_amp
id|op_a
comma
id|DOUBLE
)paren
suffix:semicolon
id|b_type
op_assign
id|extend_ieee
c_func
(paren
id|b
comma
op_amp
id|op_b
comma
id|DOUBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
op_logical_or
id|b_type
op_eq
id|NaN
)paren
r_return
id|FPCR_INV
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
op_logical_or
id|b_type
op_eq
id|QNaN
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|op_a.e
op_eq
id|op_b.e
op_logical_and
id|op_a.s
op_eq
id|op_b.s
op_logical_and
id|op_a.f
(braket
l_int|0
)braket
op_eq
id|op_b.f
(braket
l_int|0
)braket
op_logical_and
id|op_a.f
(braket
l_int|1
)braket
op_eq
id|op_b.f
(braket
l_int|1
)braket
)paren
op_logical_or
(paren
id|a_type
op_eq
id|ZERO
op_logical_and
id|b_type
op_eq
id|ZERO
)paren
)paren
op_star
id|c
op_assign
l_int|0x4000000000000000
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
r_int
DECL|function|ieee_CMPTLT
id|ieee_CMPTLT
(paren
r_int
r_int
id|a
comma
r_int
r_int
id|b
comma
r_int
r_int
op_star
id|c
)paren
(brace
id|fpclass_t
id|a_type
comma
id|b_type
suffix:semicolon
id|EXTENDED
id|op_a
comma
id|op_b
suffix:semicolon
op_star
id|c
op_assign
l_int|0
suffix:semicolon
id|a_type
op_assign
id|extend_ieee
c_func
(paren
id|a
comma
op_amp
id|op_a
comma
id|DOUBLE
)paren
suffix:semicolon
id|b_type
op_assign
id|extend_ieee
c_func
(paren
id|b
comma
op_amp
id|op_b
comma
id|DOUBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
op_logical_or
id|b_type
op_eq
id|NaN
)paren
r_return
id|FPCR_INV
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
op_logical_or
id|b_type
op_eq
id|QNaN
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|op_a.s
op_eq
l_int|1
op_logical_and
id|op_b.s
op_eq
l_int|0
op_logical_and
(paren
id|a_type
op_ne
id|ZERO
op_logical_or
id|b_type
op_ne
id|ZERO
)paren
)paren
op_logical_or
(paren
id|op_a.s
op_eq
l_int|1
op_logical_and
id|op_b.s
op_eq
l_int|1
op_logical_and
(paren
id|op_a.e
OG
id|op_b.e
op_logical_or
(paren
id|op_a.e
op_eq
id|op_b.e
op_logical_and
id|cmp128
c_func
(paren
id|op_a.f
comma
id|op_b.f
)paren
OG
l_int|0
)paren
)paren
)paren
op_logical_or
(paren
id|op_a.s
op_eq
l_int|0
op_logical_and
id|op_b.s
op_eq
l_int|0
op_logical_and
(paren
id|op_a.e
OL
id|op_b.e
op_logical_or
(paren
id|op_a.e
op_eq
id|op_b.e
op_logical_and
id|cmp128
c_func
(paren
id|op_a.f
comma
id|op_b.f
)paren
OL
l_int|0
)paren
)paren
)paren
)paren
op_star
id|c
op_assign
l_int|0x4000000000000000
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
r_int
DECL|function|ieee_CMPTLE
id|ieee_CMPTLE
(paren
r_int
r_int
id|a
comma
r_int
r_int
id|b
comma
r_int
r_int
op_star
id|c
)paren
(brace
id|fpclass_t
id|a_type
comma
id|b_type
suffix:semicolon
id|EXTENDED
id|op_a
comma
id|op_b
suffix:semicolon
op_star
id|c
op_assign
l_int|0
suffix:semicolon
id|a_type
op_assign
id|extend_ieee
c_func
(paren
id|a
comma
op_amp
id|op_a
comma
id|DOUBLE
)paren
suffix:semicolon
id|b_type
op_assign
id|extend_ieee
c_func
(paren
id|b
comma
op_amp
id|op_b
comma
id|DOUBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
op_logical_or
id|b_type
op_eq
id|NaN
)paren
r_return
id|FPCR_INV
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
op_logical_or
id|b_type
op_eq
id|QNaN
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|a_type
op_eq
id|ZERO
op_logical_and
id|b_type
op_eq
id|ZERO
)paren
op_logical_or
(paren
id|op_a.s
op_eq
l_int|1
op_logical_and
id|op_b.s
op_eq
l_int|0
)paren
op_logical_or
(paren
id|op_a.s
op_eq
l_int|1
op_logical_and
id|op_b.s
op_eq
l_int|1
op_logical_and
(paren
id|op_a.e
OG
id|op_b.e
op_logical_or
(paren
id|op_a.e
op_eq
id|op_b.e
op_logical_and
id|cmp128
c_func
(paren
id|op_a.f
comma
id|op_b.f
)paren
op_ge
l_int|0
)paren
)paren
)paren
op_logical_or
(paren
id|op_a.s
op_eq
l_int|0
op_logical_and
id|op_b.s
op_eq
l_int|0
op_logical_and
(paren
id|op_a.e
OL
id|op_b.e
op_logical_or
(paren
id|op_a.e
op_eq
id|op_b.e
op_logical_and
id|cmp128
c_func
(paren
id|op_a.f
comma
id|op_b.f
)paren
op_le
l_int|0
)paren
)paren
)paren
)paren
op_star
id|c
op_assign
l_int|0x4000000000000000
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
r_int
DECL|function|ieee_CMPTUN
id|ieee_CMPTUN
(paren
r_int
r_int
id|a
comma
r_int
r_int
id|b
comma
r_int
r_int
op_star
id|c
)paren
(brace
id|fpclass_t
id|a_type
comma
id|b_type
suffix:semicolon
id|EXTENDED
id|op_a
comma
id|op_b
suffix:semicolon
op_star
id|c
op_assign
l_int|0x4000000000000000
suffix:semicolon
id|a_type
op_assign
id|extend_ieee
c_func
(paren
id|a
comma
op_amp
id|op_a
comma
id|DOUBLE
)paren
suffix:semicolon
id|b_type
op_assign
id|extend_ieee
c_func
(paren
id|b
comma
op_amp
id|op_b
comma
id|DOUBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
op_logical_or
id|b_type
op_eq
id|NaN
)paren
r_return
id|FPCR_INV
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
op_logical_or
id|b_type
op_eq
id|QNaN
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|c
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a + b = c, where a, b, and c are ieee s-floating numbers.  &quot;f&quot;&n; * contains the rounding mode etc.&n; */
r_int
r_int
DECL|function|ieee_ADDS
id|ieee_ADDS
(paren
r_int
id|f
comma
r_int
r_int
id|a
comma
r_int
r_int
id|b
comma
r_int
r_int
op_star
id|c
)paren
(brace
id|fpclass_t
id|a_type
comma
id|b_type
suffix:semicolon
id|EXTENDED
id|op_a
comma
id|op_b
comma
id|op_c
suffix:semicolon
id|a_type
op_assign
id|extend_ieee
c_func
(paren
id|a
comma
op_amp
id|op_a
comma
id|SINGLE
)paren
suffix:semicolon
id|b_type
op_assign
id|extend_ieee
c_func
(paren
id|b
comma
op_amp
id|op_b
comma
id|SINGLE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|a_type
op_ge
id|NaN
op_logical_and
id|a_type
op_le
id|INFTY
)paren
op_logical_or
(paren
id|b_type
op_ge
id|NaN
op_logical_and
id|b_type
op_le
id|INFTY
)paren
)paren
(brace
multiline_comment|/* propagate NaNs according to arch. ref. handbook: */
r_if
c_cond
(paren
id|b_type
op_eq
id|QNaN
)paren
op_star
id|c
op_assign
id|b
suffix:semicolon
r_else
r_if
c_cond
(paren
id|b_type
op_eq
id|NaN
)paren
op_star
id|c
op_assign
id|b
op_or
(paren
l_int|1UL
op_lshift
l_int|51
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
)paren
op_star
id|c
op_assign
id|a
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
)paren
op_star
id|c
op_assign
id|a
op_or
(paren
l_int|1UL
op_lshift
l_int|51
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
op_logical_or
id|b_type
op_eq
id|NaN
)paren
r_return
id|FPCR_INV
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
op_logical_or
id|b_type
op_eq
id|QNaN
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|INFTY
op_logical_and
id|b_type
op_eq
id|INFTY
op_logical_and
id|sign
c_func
(paren
id|a
)paren
op_ne
id|sign
c_func
(paren
id|b
)paren
)paren
(brace
op_star
id|c
op_assign
id|IEEE_QNaN
suffix:semicolon
r_return
id|FPCR_INV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|a_type
op_eq
id|INFTY
)paren
op_star
id|c
op_assign
id|a
suffix:semicolon
r_else
op_star
id|c
op_assign
id|b
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|add_kernel_ieee
c_func
(paren
op_amp
id|op_a
comma
op_amp
id|op_b
comma
op_amp
id|op_c
)paren
suffix:semicolon
multiline_comment|/* special case for -0 + -0 ==&gt; -0 */
r_if
c_cond
(paren
id|a_type
op_eq
id|ZERO
op_logical_and
id|b_type
op_eq
id|ZERO
)paren
id|op_c.s
op_assign
id|op_a.s
op_logical_and
id|op_b.s
suffix:semicolon
r_return
id|round_s_ieee
c_func
(paren
id|f
comma
op_amp
id|op_c
comma
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Add a + b = c, where a, b, and c are ieee t-floating numbers.  &quot;f&quot;&n; * contains the rounding mode etc.&n; */
r_int
r_int
DECL|function|ieee_ADDT
id|ieee_ADDT
(paren
r_int
id|f
comma
r_int
r_int
id|a
comma
r_int
r_int
id|b
comma
r_int
r_int
op_star
id|c
)paren
(brace
id|fpclass_t
id|a_type
comma
id|b_type
suffix:semicolon
id|EXTENDED
id|op_a
comma
id|op_b
comma
id|op_c
suffix:semicolon
id|a_type
op_assign
id|extend_ieee
c_func
(paren
id|a
comma
op_amp
id|op_a
comma
id|DOUBLE
)paren
suffix:semicolon
id|b_type
op_assign
id|extend_ieee
c_func
(paren
id|b
comma
op_amp
id|op_b
comma
id|DOUBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|a_type
op_ge
id|NaN
op_logical_and
id|a_type
op_le
id|INFTY
)paren
op_logical_or
(paren
id|b_type
op_ge
id|NaN
op_logical_and
id|b_type
op_le
id|INFTY
)paren
)paren
(brace
multiline_comment|/* propagate NaNs according to arch. ref. handbook: */
r_if
c_cond
(paren
id|b_type
op_eq
id|QNaN
)paren
op_star
id|c
op_assign
id|b
suffix:semicolon
r_else
r_if
c_cond
(paren
id|b_type
op_eq
id|NaN
)paren
op_star
id|c
op_assign
id|b
op_or
(paren
l_int|1UL
op_lshift
l_int|51
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
)paren
op_star
id|c
op_assign
id|a
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
)paren
op_star
id|c
op_assign
id|a
op_or
(paren
l_int|1UL
op_lshift
l_int|51
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
op_logical_or
id|b_type
op_eq
id|NaN
)paren
r_return
id|FPCR_INV
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
op_logical_or
id|b_type
op_eq
id|QNaN
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|INFTY
op_logical_and
id|b_type
op_eq
id|INFTY
op_logical_and
id|sign
c_func
(paren
id|a
)paren
op_ne
id|sign
c_func
(paren
id|b
)paren
)paren
(brace
op_star
id|c
op_assign
id|IEEE_QNaN
suffix:semicolon
r_return
id|FPCR_INV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|a_type
op_eq
id|INFTY
)paren
op_star
id|c
op_assign
id|a
suffix:semicolon
r_else
op_star
id|c
op_assign
id|b
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|add_kernel_ieee
c_func
(paren
op_amp
id|op_a
comma
op_amp
id|op_b
comma
op_amp
id|op_c
)paren
suffix:semicolon
multiline_comment|/* special case for -0 + -0 ==&gt; -0 */
r_if
c_cond
(paren
id|a_type
op_eq
id|ZERO
op_logical_and
id|b_type
op_eq
id|ZERO
)paren
id|op_c.s
op_assign
id|op_a.s
op_logical_and
id|op_b.s
suffix:semicolon
r_return
id|round_t_ieee
c_func
(paren
id|f
comma
op_amp
id|op_c
comma
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Subtract a - b = c, where a, b, and c are ieee s-floating numbers.&n; * &quot;f&quot; contains the rounding mode etc.&n; */
r_int
r_int
DECL|function|ieee_SUBS
id|ieee_SUBS
(paren
r_int
id|f
comma
r_int
r_int
id|a
comma
r_int
r_int
id|b
comma
r_int
r_int
op_star
id|c
)paren
(brace
id|fpclass_t
id|a_type
comma
id|b_type
suffix:semicolon
id|EXTENDED
id|op_a
comma
id|op_b
comma
id|op_c
suffix:semicolon
id|a_type
op_assign
id|extend_ieee
c_func
(paren
id|a
comma
op_amp
id|op_a
comma
id|SINGLE
)paren
suffix:semicolon
id|b_type
op_assign
id|extend_ieee
c_func
(paren
id|b
comma
op_amp
id|op_b
comma
id|SINGLE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|a_type
op_ge
id|NaN
op_logical_and
id|a_type
op_le
id|INFTY
)paren
op_logical_or
(paren
id|b_type
op_ge
id|NaN
op_logical_and
id|b_type
op_le
id|INFTY
)paren
)paren
(brace
multiline_comment|/* propagate NaNs according to arch. ref. handbook: */
r_if
c_cond
(paren
id|b_type
op_eq
id|QNaN
)paren
op_star
id|c
op_assign
id|b
suffix:semicolon
r_else
r_if
c_cond
(paren
id|b_type
op_eq
id|NaN
)paren
op_star
id|c
op_assign
id|b
op_or
(paren
l_int|1UL
op_lshift
l_int|51
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
)paren
op_star
id|c
op_assign
id|a
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
)paren
op_star
id|c
op_assign
id|a
op_or
(paren
l_int|1UL
op_lshift
l_int|51
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
op_logical_or
id|b_type
op_eq
id|NaN
)paren
r_return
id|FPCR_INV
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
op_logical_or
id|b_type
op_eq
id|QNaN
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|INFTY
op_logical_and
id|b_type
op_eq
id|INFTY
op_logical_and
id|sign
c_func
(paren
id|a
)paren
op_eq
id|sign
c_func
(paren
id|b
)paren
)paren
(brace
op_star
id|c
op_assign
id|IEEE_QNaN
suffix:semicolon
r_return
id|FPCR_INV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|a_type
op_eq
id|INFTY
)paren
op_star
id|c
op_assign
id|a
suffix:semicolon
r_else
op_star
id|c
op_assign
id|b
op_xor
(paren
l_int|1UL
op_lshift
l_int|63
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|op_b.s
op_assign
op_logical_neg
id|op_b.s
suffix:semicolon
id|add_kernel_ieee
c_func
(paren
op_amp
id|op_a
comma
op_amp
id|op_b
comma
op_amp
id|op_c
)paren
suffix:semicolon
multiline_comment|/* special case for -0 - +0 ==&gt; -0 */
r_if
c_cond
(paren
id|a_type
op_eq
id|ZERO
op_logical_and
id|b_type
op_eq
id|ZERO
)paren
id|op_c.s
op_assign
id|op_a.s
op_logical_and
id|op_b.s
suffix:semicolon
r_return
id|round_s_ieee
c_func
(paren
id|f
comma
op_amp
id|op_c
comma
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Subtract a - b = c, where a, b, and c are ieee t-floating numbers.&n; * &quot;f&quot; contains the rounding mode etc.&n; */
r_int
r_int
DECL|function|ieee_SUBT
id|ieee_SUBT
(paren
r_int
id|f
comma
r_int
r_int
id|a
comma
r_int
r_int
id|b
comma
r_int
r_int
op_star
id|c
)paren
(brace
id|fpclass_t
id|a_type
comma
id|b_type
suffix:semicolon
id|EXTENDED
id|op_a
comma
id|op_b
comma
id|op_c
suffix:semicolon
id|a_type
op_assign
id|extend_ieee
c_func
(paren
id|a
comma
op_amp
id|op_a
comma
id|DOUBLE
)paren
suffix:semicolon
id|b_type
op_assign
id|extend_ieee
c_func
(paren
id|b
comma
op_amp
id|op_b
comma
id|DOUBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|a_type
op_ge
id|NaN
op_logical_and
id|a_type
op_le
id|INFTY
)paren
op_logical_or
(paren
id|b_type
op_ge
id|NaN
op_logical_and
id|b_type
op_le
id|INFTY
)paren
)paren
(brace
multiline_comment|/* propagate NaNs according to arch. ref. handbook: */
r_if
c_cond
(paren
id|b_type
op_eq
id|QNaN
)paren
op_star
id|c
op_assign
id|b
suffix:semicolon
r_else
r_if
c_cond
(paren
id|b_type
op_eq
id|NaN
)paren
op_star
id|c
op_assign
id|b
op_or
(paren
l_int|1UL
op_lshift
l_int|51
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
)paren
op_star
id|c
op_assign
id|a
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
)paren
op_star
id|c
op_assign
id|a
op_or
(paren
l_int|1UL
op_lshift
l_int|51
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
op_logical_or
id|b_type
op_eq
id|NaN
)paren
r_return
id|FPCR_INV
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
op_logical_or
id|b_type
op_eq
id|QNaN
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|INFTY
op_logical_and
id|b_type
op_eq
id|INFTY
op_logical_and
id|sign
c_func
(paren
id|a
)paren
op_eq
id|sign
c_func
(paren
id|b
)paren
)paren
(brace
op_star
id|c
op_assign
id|IEEE_QNaN
suffix:semicolon
r_return
id|FPCR_INV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|a_type
op_eq
id|INFTY
)paren
op_star
id|c
op_assign
id|a
suffix:semicolon
r_else
op_star
id|c
op_assign
id|b
op_xor
(paren
l_int|1UL
op_lshift
l_int|63
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|op_b.s
op_assign
op_logical_neg
id|op_b.s
suffix:semicolon
id|add_kernel_ieee
c_func
(paren
op_amp
id|op_a
comma
op_amp
id|op_b
comma
op_amp
id|op_c
)paren
suffix:semicolon
multiline_comment|/* special case for -0 - +0 ==&gt; -0 */
r_if
c_cond
(paren
id|a_type
op_eq
id|ZERO
op_logical_and
id|b_type
op_eq
id|ZERO
)paren
id|op_c.s
op_assign
id|op_a.s
op_logical_and
id|op_b.s
suffix:semicolon
r_return
id|round_t_ieee
c_func
(paren
id|f
comma
op_amp
id|op_c
comma
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Multiply a x b = c, where a, b, and c are ieee s-floating numbers.&n; * &quot;f&quot; contains the rounding mode.&n; */
r_int
r_int
DECL|function|ieee_MULS
id|ieee_MULS
(paren
r_int
id|f
comma
r_int
r_int
id|a
comma
r_int
r_int
id|b
comma
r_int
r_int
op_star
id|c
)paren
(brace
id|fpclass_t
id|a_type
comma
id|b_type
suffix:semicolon
id|EXTENDED
id|op_a
comma
id|op_b
comma
id|op_c
suffix:semicolon
id|a_type
op_assign
id|extend_ieee
c_func
(paren
id|a
comma
op_amp
id|op_a
comma
id|SINGLE
)paren
suffix:semicolon
id|b_type
op_assign
id|extend_ieee
c_func
(paren
id|b
comma
op_amp
id|op_b
comma
id|SINGLE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|a_type
op_ge
id|NaN
op_logical_and
id|a_type
op_le
id|INFTY
)paren
op_logical_or
(paren
id|b_type
op_ge
id|NaN
op_logical_and
id|b_type
op_le
id|INFTY
)paren
)paren
(brace
multiline_comment|/* propagate NaNs according to arch. ref. handbook: */
r_if
c_cond
(paren
id|b_type
op_eq
id|QNaN
)paren
op_star
id|c
op_assign
id|b
suffix:semicolon
r_else
r_if
c_cond
(paren
id|b_type
op_eq
id|NaN
)paren
op_star
id|c
op_assign
id|b
op_or
(paren
l_int|1UL
op_lshift
l_int|51
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
)paren
op_star
id|c
op_assign
id|a
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
)paren
op_star
id|c
op_assign
id|a
op_or
(paren
l_int|1UL
op_lshift
l_int|51
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
op_logical_or
id|b_type
op_eq
id|NaN
)paren
r_return
id|FPCR_INV
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
op_logical_or
id|b_type
op_eq
id|QNaN
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|a_type
op_eq
id|INFTY
op_logical_and
id|b_type
op_eq
id|ZERO
)paren
op_logical_or
(paren
id|b_type
op_eq
id|INFTY
op_logical_and
id|a_type
op_eq
id|ZERO
)paren
)paren
(brace
op_star
id|c
op_assign
id|IEEE_QNaN
suffix:semicolon
multiline_comment|/* return canonical QNaN */
r_return
id|FPCR_INV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|a_type
op_eq
id|INFTY
)paren
op_star
id|c
op_assign
id|a
op_xor
(paren
(paren
id|b
op_rshift
l_int|63
)paren
op_lshift
l_int|63
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|b_type
op_eq
id|INFTY
)paren
op_star
id|c
op_assign
id|b
op_xor
(paren
(paren
id|a
op_rshift
l_int|63
)paren
op_lshift
l_int|63
)paren
suffix:semicolon
r_else
multiline_comment|/* either of a and b are +/-0 */
op_star
id|c
op_assign
(paren
(paren
r_int
r_int
)paren
id|op_a.s
op_xor
id|op_b.s
)paren
op_lshift
l_int|63
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|op_c.s
op_assign
id|op_a.s
op_xor
id|op_b.s
suffix:semicolon
id|op_c.e
op_assign
id|op_a.e
op_plus
id|op_b.e
op_minus
l_int|55
suffix:semicolon
id|mul64
c_func
(paren
id|op_a.f
(braket
l_int|0
)braket
comma
id|op_b.f
(braket
l_int|0
)braket
comma
id|op_c.f
)paren
suffix:semicolon
r_return
id|round_s_ieee
c_func
(paren
id|f
comma
op_amp
id|op_c
comma
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Multiply a x b = c, where a, b, and c are ieee t-floating numbers.&n; * &quot;f&quot; contains the rounding mode.&n; */
r_int
r_int
DECL|function|ieee_MULT
id|ieee_MULT
(paren
r_int
id|f
comma
r_int
r_int
id|a
comma
r_int
r_int
id|b
comma
r_int
r_int
op_star
id|c
)paren
(brace
id|fpclass_t
id|a_type
comma
id|b_type
suffix:semicolon
id|EXTENDED
id|op_a
comma
id|op_b
comma
id|op_c
suffix:semicolon
op_star
id|c
op_assign
id|IEEE_QNaN
suffix:semicolon
id|a_type
op_assign
id|extend_ieee
c_func
(paren
id|a
comma
op_amp
id|op_a
comma
id|DOUBLE
)paren
suffix:semicolon
id|b_type
op_assign
id|extend_ieee
c_func
(paren
id|b
comma
op_amp
id|op_b
comma
id|DOUBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|a_type
op_ge
id|NaN
op_logical_and
id|a_type
op_le
id|ZERO
)paren
op_logical_or
(paren
id|b_type
op_ge
id|NaN
op_logical_and
id|b_type
op_le
id|ZERO
)paren
)paren
(brace
multiline_comment|/* propagate NaNs according to arch. ref. handbook: */
r_if
c_cond
(paren
id|b_type
op_eq
id|QNaN
)paren
op_star
id|c
op_assign
id|b
suffix:semicolon
r_else
r_if
c_cond
(paren
id|b_type
op_eq
id|NaN
)paren
op_star
id|c
op_assign
id|b
op_or
(paren
l_int|1UL
op_lshift
l_int|51
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
)paren
op_star
id|c
op_assign
id|a
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
)paren
op_star
id|c
op_assign
id|a
op_or
(paren
l_int|1UL
op_lshift
l_int|51
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
op_logical_or
id|b_type
op_eq
id|NaN
)paren
r_return
id|FPCR_INV
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
op_logical_or
id|b_type
op_eq
id|QNaN
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|a_type
op_eq
id|INFTY
op_logical_and
id|b_type
op_eq
id|ZERO
)paren
op_logical_or
(paren
id|b_type
op_eq
id|INFTY
op_logical_and
id|a_type
op_eq
id|ZERO
)paren
)paren
(brace
op_star
id|c
op_assign
id|IEEE_QNaN
suffix:semicolon
multiline_comment|/* return canonical QNaN */
r_return
id|FPCR_INV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|a_type
op_eq
id|INFTY
)paren
op_star
id|c
op_assign
id|a
op_xor
(paren
(paren
id|b
op_rshift
l_int|63
)paren
op_lshift
l_int|63
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|b_type
op_eq
id|INFTY
)paren
op_star
id|c
op_assign
id|b
op_xor
(paren
(paren
id|a
op_rshift
l_int|63
)paren
op_lshift
l_int|63
)paren
suffix:semicolon
r_else
multiline_comment|/* either of a and b are +/-0 */
op_star
id|c
op_assign
(paren
(paren
r_int
r_int
)paren
id|op_a.s
op_xor
id|op_b.s
)paren
op_lshift
l_int|63
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|op_c.s
op_assign
id|op_a.s
op_xor
id|op_b.s
suffix:semicolon
id|op_c.e
op_assign
id|op_a.e
op_plus
id|op_b.e
op_minus
l_int|55
suffix:semicolon
id|mul64
c_func
(paren
id|op_a.f
(braket
l_int|0
)braket
comma
id|op_b.f
(braket
l_int|0
)braket
comma
id|op_c.f
)paren
suffix:semicolon
r_return
id|round_t_ieee
c_func
(paren
id|f
comma
op_amp
id|op_c
comma
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Divide a / b = c, where a, b, and c are ieee s-floating numbers.&n; * &quot;f&quot; contains the rounding mode etc.&n; */
r_int
r_int
DECL|function|ieee_DIVS
id|ieee_DIVS
(paren
r_int
id|f
comma
r_int
r_int
id|a
comma
r_int
r_int
id|b
comma
r_int
r_int
op_star
id|c
)paren
(brace
id|fpclass_t
id|a_type
comma
id|b_type
suffix:semicolon
id|EXTENDED
id|op_a
comma
id|op_b
comma
id|op_c
suffix:semicolon
id|a_type
op_assign
id|extend_ieee
c_func
(paren
id|a
comma
op_amp
id|op_a
comma
id|SINGLE
)paren
suffix:semicolon
id|b_type
op_assign
id|extend_ieee
c_func
(paren
id|b
comma
op_amp
id|op_b
comma
id|SINGLE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|a_type
op_ge
id|NaN
op_logical_and
id|a_type
op_le
id|ZERO
)paren
op_logical_or
(paren
id|b_type
op_ge
id|NaN
op_logical_and
id|b_type
op_le
id|ZERO
)paren
)paren
(brace
r_int
r_int
id|res
suffix:semicolon
multiline_comment|/* propagate NaNs according to arch. ref. handbook: */
r_if
c_cond
(paren
id|b_type
op_eq
id|QNaN
)paren
op_star
id|c
op_assign
id|b
suffix:semicolon
r_else
r_if
c_cond
(paren
id|b_type
op_eq
id|NaN
)paren
op_star
id|c
op_assign
id|b
op_or
(paren
l_int|1UL
op_lshift
l_int|51
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
)paren
op_star
id|c
op_assign
id|a
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
)paren
op_star
id|c
op_assign
id|a
op_or
(paren
l_int|1UL
op_lshift
l_int|51
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
op_logical_or
id|b_type
op_eq
id|NaN
)paren
r_return
id|FPCR_INV
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
op_logical_or
id|b_type
op_eq
id|QNaN
)paren
r_return
l_int|0
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
op_star
id|c
op_assign
id|IEEE_PINF
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|INFTY
)paren
(brace
r_if
c_cond
(paren
id|b_type
op_eq
id|INFTY
)paren
(brace
op_star
id|c
op_assign
id|IEEE_QNaN
suffix:semicolon
r_return
id|FPCR_INV
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|b_type
op_eq
id|ZERO
)paren
(brace
r_if
c_cond
(paren
id|a_type
op_eq
id|ZERO
)paren
(brace
op_star
id|c
op_assign
id|IEEE_QNaN
suffix:semicolon
r_return
id|FPCR_INV
suffix:semicolon
)brace
id|res
op_assign
id|FPCR_DZE
suffix:semicolon
)brace
r_else
multiline_comment|/* a_type == ZERO || b_type == INFTY */
op_star
id|c
op_assign
l_int|0
suffix:semicolon
op_star
id|c
op_or_assign
(paren
r_int
r_int
)paren
(paren
id|op_a.s
op_xor
id|op_b.s
)paren
op_lshift
l_int|63
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
id|op_c.s
op_assign
id|op_a.s
op_xor
id|op_b.s
suffix:semicolon
id|op_c.e
op_assign
id|op_a.e
op_minus
id|op_b.e
suffix:semicolon
id|op_a.f
(braket
l_int|1
)braket
op_assign
id|op_a.f
(braket
l_int|0
)braket
suffix:semicolon
id|op_a.f
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|div128
c_func
(paren
id|op_a.f
comma
id|op_b.f
comma
id|op_c.f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_ne
id|ZERO
)paren
multiline_comment|/* force a sticky bit because DIVs never hit exact .5: */
id|op_c.f
(braket
l_int|0
)braket
op_or_assign
id|STICKY_S
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|op_c
)paren
suffix:semicolon
id|op_c.e
op_sub_assign
l_int|9
suffix:semicolon
multiline_comment|/* remove excess exp from original shift */
r_return
id|round_s_ieee
c_func
(paren
id|f
comma
op_amp
id|op_c
comma
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Divide a/b = c, where a, b, and c are ieee t-floating numbers.  &quot;f&quot;&n; * contains the rounding mode etc.&n; */
r_int
r_int
DECL|function|ieee_DIVT
id|ieee_DIVT
(paren
r_int
id|f
comma
r_int
r_int
id|a
comma
r_int
r_int
id|b
comma
r_int
r_int
op_star
id|c
)paren
(brace
id|fpclass_t
id|a_type
comma
id|b_type
suffix:semicolon
id|EXTENDED
id|op_a
comma
id|op_b
comma
id|op_c
suffix:semicolon
op_star
id|c
op_assign
id|IEEE_QNaN
suffix:semicolon
id|a_type
op_assign
id|extend_ieee
c_func
(paren
id|a
comma
op_amp
id|op_a
comma
id|DOUBLE
)paren
suffix:semicolon
id|b_type
op_assign
id|extend_ieee
c_func
(paren
id|b
comma
op_amp
id|op_b
comma
id|DOUBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|a_type
op_ge
id|NaN
op_logical_and
id|a_type
op_le
id|ZERO
)paren
op_logical_or
(paren
id|b_type
op_ge
id|NaN
op_logical_and
id|b_type
op_le
id|ZERO
)paren
)paren
(brace
r_int
r_int
id|res
suffix:semicolon
multiline_comment|/* propagate NaNs according to arch. ref. handbook: */
r_if
c_cond
(paren
id|b_type
op_eq
id|QNaN
)paren
op_star
id|c
op_assign
id|b
suffix:semicolon
r_else
r_if
c_cond
(paren
id|b_type
op_eq
id|NaN
)paren
op_star
id|c
op_assign
id|b
op_or
(paren
l_int|1UL
op_lshift
l_int|51
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
)paren
op_star
id|c
op_assign
id|a
suffix:semicolon
r_else
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
)paren
op_star
id|c
op_assign
id|a
op_or
(paren
l_int|1UL
op_lshift
l_int|51
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|NaN
op_logical_or
id|b_type
op_eq
id|NaN
)paren
r_return
id|FPCR_INV
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|QNaN
op_logical_or
id|b_type
op_eq
id|QNaN
)paren
r_return
l_int|0
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
op_star
id|c
op_assign
id|IEEE_PINF
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_eq
id|INFTY
)paren
(brace
r_if
c_cond
(paren
id|b_type
op_eq
id|INFTY
)paren
(brace
op_star
id|c
op_assign
id|IEEE_QNaN
suffix:semicolon
r_return
id|FPCR_INV
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|b_type
op_eq
id|ZERO
)paren
(brace
r_if
c_cond
(paren
id|a_type
op_eq
id|ZERO
)paren
(brace
op_star
id|c
op_assign
id|IEEE_QNaN
suffix:semicolon
r_return
id|FPCR_INV
suffix:semicolon
)brace
id|res
op_assign
id|FPCR_DZE
suffix:semicolon
)brace
r_else
multiline_comment|/* a_type == ZERO || b_type == INFTY */
op_star
id|c
op_assign
l_int|0
suffix:semicolon
op_star
id|c
op_or_assign
(paren
r_int
r_int
)paren
(paren
id|op_a.s
op_xor
id|op_b.s
)paren
op_lshift
l_int|63
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
id|op_c.s
op_assign
id|op_a.s
op_xor
id|op_b.s
suffix:semicolon
id|op_c.e
op_assign
id|op_a.e
op_minus
id|op_b.e
suffix:semicolon
id|op_a.f
(braket
l_int|1
)braket
op_assign
id|op_a.f
(braket
l_int|0
)braket
suffix:semicolon
id|op_a.f
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|div128
c_func
(paren
id|op_a.f
comma
id|op_b.f
comma
id|op_c.f
)paren
suffix:semicolon
r_if
c_cond
(paren
id|a_type
op_ne
id|ZERO
)paren
multiline_comment|/* force a sticky bit because DIVs never hit exact .5 */
id|op_c.f
(braket
l_int|0
)braket
op_or_assign
id|STICKY_T
suffix:semicolon
id|normalize
c_func
(paren
op_amp
id|op_c
)paren
suffix:semicolon
id|op_c.e
op_sub_assign
l_int|9
suffix:semicolon
multiline_comment|/* remove excess exp from original shift */
r_return
id|round_t_ieee
c_func
(paren
id|f
comma
op_amp
id|op_c
comma
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Sqrt a = b, where a and b are ieee s-floating numbers.  &quot;f&quot;&n; * contains the rounding mode etc.&n; */
r_int
r_int
DECL|function|ieee_SQRTS
id|ieee_SQRTS
(paren
r_int
id|f
comma
r_int
r_int
id|a
comma
r_int
r_int
op_star
id|b
)paren
(brace
id|fpclass_t
id|a_type
suffix:semicolon
id|EXTENDED
id|op_a
comma
id|op_b
suffix:semicolon
op_star
id|b
op_assign
id|IEEE_QNaN
suffix:semicolon
id|a_type
op_assign
id|extend_ieee
c_func
(paren
id|a
comma
op_amp
id|op_a
comma
id|SINGLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|op_a.s
op_eq
l_int|0
)paren
(brace
multiline_comment|/* FIXME -- handle positive denormals.  */
id|send_sig
c_func
(paren
id|SIGFPE
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|FPCR_INV
suffix:semicolon
)brace
multiline_comment|/*&n; * Sqrt a = b, where a and b are ieee t-floating numbers.  &quot;f&quot;&n; * contains the rounding mode etc.&n; */
r_int
r_int
DECL|function|ieee_SQRTT
id|ieee_SQRTT
(paren
r_int
id|f
comma
r_int
r_int
id|a
comma
r_int
r_int
op_star
id|b
)paren
(brace
id|fpclass_t
id|a_type
suffix:semicolon
id|EXTENDED
id|op_a
comma
id|op_b
suffix:semicolon
op_star
id|b
op_assign
id|IEEE_QNaN
suffix:semicolon
id|a_type
op_assign
id|extend_ieee
c_func
(paren
id|a
comma
op_amp
id|op_a
comma
id|DOUBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|op_a.s
op_eq
l_int|0
)paren
(brace
multiline_comment|/* FIXME -- handle positive denormals.  */
id|send_sig
c_func
(paren
id|SIGFPE
comma
id|current
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|FPCR_INV
suffix:semicolon
)brace
eof
