multiline_comment|/*&n; * arch/alpha/boot/main.c&n; *&n; * Copyright (C) 1994, 1995 Linus Torvalds&n; *&n; * This file is the bootloader for the Linux/AXP kernel&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/console.h&gt;
macro_line|#include &lt;asm/hwrpb.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &quot;ksize.h&quot;
r_extern
r_int
id|vsprintf
c_func
(paren
r_char
op_star
comma
r_const
r_char
op_star
comma
id|va_list
)paren
suffix:semicolon
r_extern
r_int
r_int
id|switch_to_osf_pal
c_func
(paren
r_int
r_int
id|nr
comma
r_struct
id|pcb_struct
op_star
id|pcb_va
comma
r_struct
id|pcb_struct
op_star
id|pcb_pa
comma
r_int
r_int
op_star
id|vptb
)paren
suffix:semicolon
DECL|variable|hwrpb
r_struct
id|hwrpb_struct
op_star
id|hwrpb
op_assign
id|INIT_HWRPB
suffix:semicolon
DECL|variable|pcb_va
r_static
r_struct
id|pcb_struct
id|pcb_va
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/*&n; * Find a physical address of a virtual object..&n; *&n; * This is easy using the virtual page table address.&n; */
r_static
r_inline
r_void
op_star
DECL|function|find_pa
id|find_pa
c_func
(paren
r_int
r_int
op_star
id|vptb
comma
r_void
op_star
id|ptr
)paren
(brace
r_int
r_int
id|address
op_assign
(paren
r_int
r_int
)paren
id|ptr
suffix:semicolon
r_int
r_int
id|result
suffix:semicolon
id|result
op_assign
id|vptb
(braket
id|address
op_rshift
l_int|13
)braket
suffix:semicolon
id|result
op_rshift_assign
l_int|32
suffix:semicolon
id|result
op_lshift_assign
l_int|13
suffix:semicolon
id|result
op_or_assign
id|address
op_amp
l_int|0x1fff
suffix:semicolon
r_return
(paren
r_void
op_star
)paren
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * This function moves into OSF/1 pal-code, and has a temporary&n; * PCB for that. The kernel proper should replace this PCB with&n; * the real one as soon as possible.&n; *&n; * The page table muckery in here depends on the fact that the boot&n; * code has the L1 page table identity-map itself in the second PTE&n; * in the L1 page table. Thus the L1-page is virtually addressable&n; * itself (through three levels) at virtual address 0x200802000.&n; */
DECL|macro|VPTB
mdefine_line|#define VPTB&t;((unsigned long *) 0x200000000)
DECL|macro|L1
mdefine_line|#define L1&t;((unsigned long *) 0x200802000)
r_void
DECL|function|pal_init
id|pal_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
comma
id|rev
suffix:semicolon
r_struct
id|percpu_struct
op_star
id|percpu
suffix:semicolon
r_struct
id|pcb_struct
op_star
id|pcb_pa
suffix:semicolon
multiline_comment|/* Create the dummy PCB.  */
id|pcb_va-&gt;ksp
op_assign
l_int|0
suffix:semicolon
id|pcb_va-&gt;usp
op_assign
l_int|0
suffix:semicolon
id|pcb_va-&gt;ptbr
op_assign
id|L1
(braket
l_int|1
)braket
op_rshift
l_int|32
suffix:semicolon
id|pcb_va-&gt;asn
op_assign
l_int|0
suffix:semicolon
id|pcb_va-&gt;pcc
op_assign
l_int|0
suffix:semicolon
id|pcb_va-&gt;unique
op_assign
l_int|0
suffix:semicolon
id|pcb_va-&gt;flags
op_assign
l_int|1
suffix:semicolon
id|pcb_va-&gt;res1
op_assign
l_int|0
suffix:semicolon
id|pcb_va-&gt;res2
op_assign
l_int|0
suffix:semicolon
id|pcb_pa
op_assign
id|find_pa
c_func
(paren
id|VPTB
comma
id|pcb_va
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * a0 = 2 (OSF)&n;&t; * a1 = return address, but we give the asm the vaddr of the PCB&n;&t; * a2 = physical addr of PCB&n;&t; * a3 = new virtual page table pointer&n;&t; * a4 = KSP (but the asm sets it)&n;&t; */
id|srm_printk
c_func
(paren
l_string|&quot;Switching to OSF PAL-code .. &quot;
)paren
suffix:semicolon
id|i
op_assign
id|switch_to_osf_pal
c_func
(paren
l_int|2
comma
id|pcb_va
comma
id|pcb_pa
comma
id|VPTB
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
(brace
id|srm_printk
c_func
(paren
l_string|&quot;failed, code %ld&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|__halt
c_func
(paren
)paren
suffix:semicolon
)brace
id|percpu
op_assign
(paren
r_struct
id|percpu_struct
op_star
)paren
(paren
id|INIT_HWRPB-&gt;processor_offset
op_plus
(paren
r_int
r_int
)paren
id|INIT_HWRPB
)paren
suffix:semicolon
id|rev
op_assign
id|percpu-&gt;pal_revision
op_assign
id|percpu-&gt;palcode_avail
(braket
l_int|2
)braket
suffix:semicolon
id|srm_printk
c_func
(paren
l_string|&quot;Ok (rev %lx)&bslash;n&quot;
comma
id|rev
)paren
suffix:semicolon
id|tbia
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* do it directly in case we are SMP */
)brace
DECL|function|openboot
r_static
r_inline
r_int
id|openboot
c_func
(paren
r_void
)paren
(brace
r_char
id|bootdev
(braket
l_int|256
)braket
suffix:semicolon
r_int
id|result
suffix:semicolon
id|result
op_assign
id|callback_getenv
c_func
(paren
id|ENV_BOOTED_DEV
comma
id|bootdev
comma
l_int|255
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
r_return
id|callback_open
c_func
(paren
id|bootdev
comma
id|result
op_amp
l_int|255
)paren
suffix:semicolon
)brace
DECL|function|close
r_static
r_inline
r_int
id|close
c_func
(paren
r_int
id|dev
)paren
(brace
r_return
id|callback_close
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|load
r_static
r_inline
r_int
id|load
c_func
(paren
r_int
id|dev
comma
r_int
r_int
id|addr
comma
r_int
r_int
id|count
)paren
(brace
r_char
id|bootfile
(braket
l_int|256
)braket
suffix:semicolon
r_extern
r_char
id|_end
suffix:semicolon
r_int
id|result
comma
id|boot_size
op_assign
op_amp
id|_end
op_minus
(paren
r_char
op_star
)paren
id|BOOT_ADDR
suffix:semicolon
id|result
op_assign
id|callback_getenv
c_func
(paren
id|ENV_BOOTED_FILE
comma
id|bootfile
comma
l_int|255
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
r_return
id|result
suffix:semicolon
id|result
op_and_assign
l_int|255
suffix:semicolon
id|bootfile
(braket
id|result
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
id|srm_printk
c_func
(paren
l_string|&quot;Boot file specification (%s) not implemented&bslash;n&quot;
comma
id|bootfile
)paren
suffix:semicolon
r_return
id|callback_read
c_func
(paren
id|dev
comma
id|count
comma
id|addr
comma
id|boot_size
op_div
l_int|512
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Start the kernel.&n; */
DECL|function|runkernel
r_static
r_void
id|runkernel
c_func
(paren
r_void
)paren
(brace
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;bis %1,%1,$30&bslash;n&bslash;t&quot;
l_string|&quot;bis %0,%0,$26&bslash;n&bslash;t&quot;
l_string|&quot;ret ($26)&quot;
suffix:colon
multiline_comment|/* no outputs: it doesn&squot;t even return */
suffix:colon
l_string|&quot;r&quot;
(paren
id|START_ADDR
)paren
comma
l_string|&quot;r&quot;
(paren
id|PAGE_SIZE
op_plus
id|INIT_STACK
)paren
)paren
suffix:semicolon
)brace
DECL|function|start_kernel
r_void
id|start_kernel
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|dev
suffix:semicolon
r_int
id|nbytes
suffix:semicolon
r_char
id|envval
(braket
l_int|256
)braket
suffix:semicolon
id|srm_printk
c_func
(paren
l_string|&quot;Linux/AXP bootloader for Linux &quot;
id|UTS_RELEASE
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|INIT_HWRPB-&gt;pagesize
op_ne
l_int|8192
)paren
(brace
id|srm_printk
c_func
(paren
l_string|&quot;Expected 8kB pages, got %ldkB&bslash;n&quot;
comma
id|INIT_HWRPB-&gt;pagesize
op_rshift
l_int|10
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pal_init
c_func
(paren
)paren
suffix:semicolon
id|dev
op_assign
id|openboot
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
OL
l_int|0
)paren
(brace
id|srm_printk
c_func
(paren
l_string|&quot;Unable to open boot device: %016lx&bslash;n&quot;
comma
id|dev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev
op_and_assign
l_int|0xffffffff
suffix:semicolon
id|srm_printk
c_func
(paren
l_string|&quot;Loading vmlinux ...&quot;
)paren
suffix:semicolon
id|i
op_assign
id|load
c_func
(paren
id|dev
comma
id|START_ADDR
comma
id|KERNEL_SIZE
)paren
suffix:semicolon
id|close
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|KERNEL_SIZE
)paren
(brace
id|srm_printk
c_func
(paren
l_string|&quot;Failed (%lx)&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|nbytes
op_assign
id|callback_getenv
c_func
(paren
id|ENV_BOOTED_OSFLAGS
comma
id|envval
comma
r_sizeof
(paren
id|envval
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nbytes
OL
l_int|0
)paren
(brace
id|nbytes
op_assign
l_int|0
suffix:semicolon
)brace
id|envval
(braket
id|nbytes
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|strcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|ZERO_PGE
comma
id|envval
)paren
suffix:semicolon
id|srm_printk
c_func
(paren
l_string|&quot; Ok&bslash;nNow booting the kernel&bslash;n&quot;
)paren
suffix:semicolon
id|runkernel
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x100000000
suffix:semicolon
id|i
op_increment
)paren
multiline_comment|/* nothing */
suffix:semicolon
id|__halt
c_func
(paren
)paren
suffix:semicolon
)brace
eof
