multiline_comment|/*&n; * arch/alpha/boot/tools/objstrip.c&n; *&n; * Strip the object file headers/trailers from an executable (ELF or ECOFF).&n; *&n; * Copyright (C) 1996 David Mosberger-Tang.&n; */
multiline_comment|/*&n; * Converts an ECOFF or ELF object file into a bootable file.  The&n; * object file must be a OMAGIC file (i.e., data and bss follow immediatly&n; * behind the text).  See DEC &quot;Assembly Language Programmer&squot;s Guide&quot;&n; * documentation for details.  The SRM boot process is documented in&n; * the Alpha AXP Architecture Reference Manual, Second Edition by&n; * Richard L. Sites and Richard T. Witek.&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;sys/fcntl.h&gt;
macro_line|#include &lt;sys/stat.h&gt;
macro_line|#include &lt;sys/types.h&gt;
macro_line|#include &lt;linux/a.out.h&gt;
macro_line|#include &lt;linux/coff.h&gt;
macro_line|#include &lt;linux/param.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#ifdef __ELF__
macro_line|# include &lt;asm/elf.h&gt;
macro_line|# include &lt;linux/elf.h&gt;
macro_line|#endif
multiline_comment|/* bootfile size must be multiple of BLOCK_SIZE: */
DECL|macro|BLOCK_SIZE
mdefine_line|#define BLOCK_SIZE&t;512
DECL|variable|prog_name
r_const
r_char
op_star
id|prog_name
suffix:semicolon
r_void
DECL|function|usage
id|usage
(paren
r_void
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;usage: %s [-v] -p file primary&bslash;n&quot;
l_string|&quot;       %s [-vb] file [secondary]&bslash;n&quot;
comma
id|prog_name
comma
id|prog_name
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_int
DECL|function|main
id|main
(paren
r_int
id|argc
comma
r_char
op_star
id|argv
(braket
)braket
)paren
(brace
r_int
id|nwritten
comma
id|tocopy
comma
id|n
comma
id|mem_size
comma
id|fil_size
comma
id|pad
op_assign
l_int|0
suffix:semicolon
r_int
id|fd
comma
id|ofd
comma
id|i
comma
id|j
comma
id|verbose
op_assign
l_int|0
comma
id|primary
op_assign
l_int|0
suffix:semicolon
r_char
id|buf
(braket
l_int|8192
)braket
comma
op_star
id|inname
suffix:semicolon
r_struct
id|exec
op_star
id|aout
suffix:semicolon
multiline_comment|/* includes file &amp; aout header */
r_int
id|offset
suffix:semicolon
macro_line|#ifdef __ELF__
r_struct
id|elfhdr
op_star
id|elf
suffix:semicolon
r_struct
id|elf_phdr
op_star
id|elf_phdr
suffix:semicolon
multiline_comment|/* program header */
r_int
r_int
r_int
id|e_entry
suffix:semicolon
macro_line|#endif
id|prog_name
op_assign
id|argv
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|argc
op_logical_and
id|argv
(braket
id|i
)braket
(braket
l_int|0
)braket
op_eq
l_char|&squot;-&squot;
suffix:semicolon
op_increment
id|i
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|argv
(braket
id|i
)braket
(braket
id|j
)braket
suffix:semicolon
op_increment
id|j
)paren
(brace
r_switch
c_cond
(paren
id|argv
(braket
id|i
)braket
(braket
id|j
)braket
)paren
(brace
r_case
l_char|&squot;v&squot;
suffix:colon
id|verbose
op_assign
op_complement
id|verbose
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;b&squot;
suffix:colon
id|pad
op_assign
id|BLOCK_SIZE
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;p&squot;
suffix:colon
id|primary
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* make primary bootblock */
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|i
op_ge
id|argc
)paren
(brace
id|usage
c_func
(paren
)paren
suffix:semicolon
)brace
id|inname
op_assign
id|argv
(braket
id|i
op_increment
)braket
suffix:semicolon
id|fd
op_assign
id|open
c_func
(paren
id|inname
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
op_eq
op_minus
l_int|1
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;open&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|ofd
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|argc
)paren
(brace
id|ofd
op_assign
id|open
c_func
(paren
id|argv
(braket
id|i
op_increment
)braket
comma
id|O_WRONLY
op_or
id|O_CREAT
op_or
id|O_TRUNC
comma
l_int|0666
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
op_eq
op_minus
l_int|1
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;open&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|primary
)paren
(brace
multiline_comment|/* generate bootblock for primary loader */
r_int
r_int
id|bb
(braket
l_int|64
)braket
comma
id|sum
op_assign
l_int|0
suffix:semicolon
r_struct
id|stat
id|st
suffix:semicolon
id|off_t
id|size
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|ofd
op_eq
l_int|1
)paren
(brace
id|usage
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fstat
c_func
(paren
id|fd
comma
op_amp
id|st
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;fstat&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|size
op_assign
(paren
id|st.st_size
op_plus
id|BLOCK_SIZE
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
id|BLOCK_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|memset
c_func
(paren
id|bb
comma
l_int|0
comma
r_sizeof
(paren
id|bb
)paren
)paren
suffix:semicolon
id|strcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|bb
comma
l_string|&quot;Linux SRM bootblock&quot;
)paren
suffix:semicolon
id|bb
(braket
l_int|60
)braket
op_assign
id|size
op_div
id|BLOCK_SIZE
suffix:semicolon
multiline_comment|/* count */
id|bb
(braket
l_int|61
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* starting sector # */
id|bb
(braket
l_int|62
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* flags---must be 0 */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|63
suffix:semicolon
op_increment
id|i
)paren
(brace
id|sum
op_add_assign
id|bb
(braket
id|i
)braket
suffix:semicolon
)brace
id|bb
(braket
l_int|63
)braket
op_assign
id|sum
suffix:semicolon
r_if
c_cond
(paren
id|write
c_func
(paren
id|ofd
comma
id|bb
comma
r_sizeof
(paren
id|bb
)paren
)paren
op_ne
r_sizeof
(paren
id|bb
)paren
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;boot-block write&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;%lu&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* read and inspect exec header: */
r_if
c_cond
(paren
id|read
c_func
(paren
id|fd
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
)paren
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;read&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#ifdef __ELF__
id|elf
op_assign
(paren
r_struct
id|elfhdr
op_star
)paren
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|elf-&gt;e_ident
(braket
l_int|0
)braket
op_eq
l_int|0x7f
op_logical_and
id|strncmp
c_func
(paren
id|elf-&gt;e_ident
op_plus
l_int|1
comma
l_string|&quot;ELF&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|elf-&gt;e_type
op_ne
id|ET_EXEC
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: %s is not an ELF executable&bslash;n&quot;
comma
id|prog_name
comma
id|inname
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|elf_check_arch
c_func
(paren
id|elf
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: is not for this processor (e_machine=%d)&bslash;n&quot;
comma
id|prog_name
comma
id|elf-&gt;e_machine
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|elf-&gt;e_phnum
op_ne
l_int|1
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: %d program headers (forgot to link with -N?)&bslash;n&quot;
comma
id|prog_name
comma
id|elf-&gt;e_phnum
)paren
suffix:semicolon
)brace
id|e_entry
op_assign
id|elf-&gt;e_entry
suffix:semicolon
id|lseek
c_func
(paren
id|fd
comma
id|elf-&gt;e_phoff
comma
id|SEEK_SET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read
c_func
(paren
id|fd
comma
id|buf
comma
r_sizeof
(paren
op_star
id|elf_phdr
)paren
)paren
op_ne
r_sizeof
(paren
op_star
id|elf_phdr
)paren
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;read&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|elf_phdr
op_assign
(paren
r_struct
id|elf_phdr
op_star
)paren
id|buf
suffix:semicolon
id|offset
op_assign
id|elf_phdr-&gt;p_offset
suffix:semicolon
id|mem_size
op_assign
id|elf_phdr-&gt;p_memsz
suffix:semicolon
id|fil_size
op_assign
id|elf_phdr-&gt;p_filesz
suffix:semicolon
multiline_comment|/* work around ELF bug: */
r_if
c_cond
(paren
id|elf_phdr-&gt;p_vaddr
OL
id|e_entry
)paren
(brace
r_int
r_int
id|delta
op_assign
id|e_entry
op_minus
id|elf_phdr-&gt;p_vaddr
suffix:semicolon
id|offset
op_add_assign
id|delta
suffix:semicolon
id|mem_size
op_sub_assign
id|delta
suffix:semicolon
id|fil_size
op_sub_assign
id|delta
suffix:semicolon
id|elf_phdr-&gt;p_vaddr
op_add_assign
id|delta
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verbose
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: extracting %#016lx-%#016lx (at %lx)&bslash;n&quot;
comma
id|prog_name
comma
(paren
r_int
)paren
id|elf_phdr-&gt;p_vaddr
comma
id|elf_phdr-&gt;p_vaddr
op_plus
id|fil_size
comma
id|offset
)paren
suffix:semicolon
)brace
)brace
r_else
macro_line|#endif
(brace
id|aout
op_assign
(paren
r_struct
id|exec
op_star
)paren
id|buf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|aout-&gt;fh.f_flags
op_amp
id|COFF_F_EXEC
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: %s is not in executable format&bslash;n&quot;
comma
id|prog_name
comma
id|inname
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aout-&gt;fh.f_opthdr
op_ne
r_sizeof
(paren
id|aout-&gt;ah
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: %s has unexpected optional header size&bslash;n&quot;
comma
id|prog_name
comma
id|inname
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|N_MAGIC
c_func
(paren
op_star
id|aout
)paren
op_ne
id|OMAGIC
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: %s is not an OMAGIC file&bslash;n&quot;
comma
id|prog_name
comma
id|inname
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|offset
op_assign
id|N_TXTOFF
c_func
(paren
op_star
id|aout
)paren
suffix:semicolon
id|fil_size
op_assign
id|aout-&gt;ah.tsize
op_plus
id|aout-&gt;ah.dsize
suffix:semicolon
id|mem_size
op_assign
id|fil_size
op_plus
id|aout-&gt;ah.bsize
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: extracting %#016lx-%#016lx (at %lx)&bslash;n&quot;
comma
id|prog_name
comma
id|aout-&gt;ah.text_start
comma
id|aout-&gt;ah.text_start
op_plus
id|fil_size
comma
id|offset
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|lseek
c_func
(paren
id|fd
comma
id|offset
comma
id|SEEK_SET
)paren
op_ne
id|offset
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;lseek&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verbose
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: copying %lu byte from %s&bslash;n&quot;
comma
id|prog_name
comma
(paren
r_int
r_int
)paren
id|fil_size
comma
id|inname
)paren
suffix:semicolon
)brace
id|tocopy
op_assign
id|fil_size
suffix:semicolon
r_while
c_loop
(paren
id|tocopy
OG
l_int|0
)paren
(brace
id|n
op_assign
id|tocopy
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
r_sizeof
(paren
id|buf
)paren
)paren
(brace
id|n
op_assign
r_sizeof
(paren
id|buf
)paren
suffix:semicolon
)brace
id|tocopy
op_sub_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|read
c_func
(paren
id|fd
comma
id|buf
comma
id|n
)paren
op_ne
id|n
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;read&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_do
(brace
id|nwritten
op_assign
id|write
c_func
(paren
id|ofd
comma
id|buf
comma
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ssize_t
)paren
id|nwritten
op_eq
op_minus
l_int|1
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;write&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|n
op_sub_assign
id|nwritten
suffix:semicolon
)brace
r_while
c_loop
(paren
id|n
OG
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pad
)paren
(brace
id|mem_size
op_assign
(paren
(paren
id|mem_size
op_plus
id|pad
op_minus
l_int|1
)paren
op_div
id|pad
)paren
op_star
id|pad
suffix:semicolon
)brace
id|tocopy
op_assign
id|mem_size
op_minus
id|fil_size
suffix:semicolon
r_if
c_cond
(paren
id|tocopy
OG
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: zero-filling bss and aligning to %lu with %lu bytes&bslash;n&quot;
comma
id|prog_name
comma
id|pad
comma
(paren
r_int
r_int
)paren
id|tocopy
)paren
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0x00
comma
r_sizeof
(paren
id|buf
)paren
)paren
suffix:semicolon
r_do
(brace
id|n
op_assign
id|tocopy
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
r_sizeof
(paren
id|buf
)paren
)paren
(brace
id|n
op_assign
r_sizeof
(paren
id|buf
)paren
suffix:semicolon
)brace
id|nwritten
op_assign
id|write
c_func
(paren
id|ofd
comma
id|buf
comma
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ssize_t
)paren
id|nwritten
op_eq
op_minus
l_int|1
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;write&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|tocopy
op_sub_assign
id|nwritten
suffix:semicolon
)brace
r_while
c_loop
(paren
id|tocopy
OG
l_int|0
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
