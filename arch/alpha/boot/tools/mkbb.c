multiline_comment|/* This utility makes a bootblock suitable for the SRM console/miniloader */
multiline_comment|/* Usage:&n; *&t;mkbb &lt;device&gt; &lt;lxboot&gt;&n; *&n; * Where &lt;device&gt; is the name of the device to install the bootblock on,&n; * and &lt;lxboot&gt; is the name of a bootblock to merge in.  This bootblock&n; * contains the offset and size of the bootloader.  It must be exactly&n; * 512 bytes long.&n; */
macro_line|#include &lt;fcntl.h&gt;
macro_line|#include &lt;unistd.h&gt;
macro_line|#include &lt;stdio.h&gt;
multiline_comment|/* Minimal definition of disklabel, so we don&squot;t have to include&n; * asm/disklabel.h (confuses make)&n; */
macro_line|#ifndef MAXPARTITIONS
DECL|macro|MAXPARTITIONS
mdefine_line|#define MAXPARTITIONS   8                       /* max. # of partitions */
macro_line|#endif
macro_line|#ifndef u8
DECL|macro|u8
mdefine_line|#define u8 unsigned char
macro_line|#endif
macro_line|#ifndef u16
DECL|macro|u16
mdefine_line|#define u16 unsigned short
macro_line|#endif
macro_line|#ifndef u32
DECL|macro|u32
mdefine_line|#define u32 unsigned int
macro_line|#endif
DECL|struct|disklabel
r_struct
id|disklabel
(brace
DECL|member|d_magic
id|u32
id|d_magic
suffix:semicolon
multiline_comment|/* must be DISKLABELMAGIC */
DECL|member|d_type
DECL|member|d_subtype
id|u16
id|d_type
comma
id|d_subtype
suffix:semicolon
DECL|member|d_typename
id|u8
id|d_typename
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|d_packname
id|u8
id|d_packname
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|d_secsize
id|u32
id|d_secsize
suffix:semicolon
DECL|member|d_nsectors
id|u32
id|d_nsectors
suffix:semicolon
DECL|member|d_ntracks
id|u32
id|d_ntracks
suffix:semicolon
DECL|member|d_ncylinders
id|u32
id|d_ncylinders
suffix:semicolon
DECL|member|d_secpercyl
id|u32
id|d_secpercyl
suffix:semicolon
DECL|member|d_secprtunit
id|u32
id|d_secprtunit
suffix:semicolon
DECL|member|d_sparespertrack
id|u16
id|d_sparespertrack
suffix:semicolon
DECL|member|d_sparespercyl
id|u16
id|d_sparespercyl
suffix:semicolon
DECL|member|d_acylinders
id|u32
id|d_acylinders
suffix:semicolon
DECL|member|d_rpm
DECL|member|d_interleave
DECL|member|d_trackskew
DECL|member|d_cylskew
id|u16
id|d_rpm
comma
id|d_interleave
comma
id|d_trackskew
comma
id|d_cylskew
suffix:semicolon
DECL|member|d_headswitch
DECL|member|d_trkseek
DECL|member|d_flags
id|u32
id|d_headswitch
comma
id|d_trkseek
comma
id|d_flags
suffix:semicolon
DECL|member|d_drivedata
id|u32
id|d_drivedata
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|d_spare
id|u32
id|d_spare
(braket
l_int|5
)braket
suffix:semicolon
DECL|member|d_magic2
id|u32
id|d_magic2
suffix:semicolon
multiline_comment|/* must be DISKLABELMAGIC */
DECL|member|d_checksum
id|u16
id|d_checksum
suffix:semicolon
DECL|member|d_npartitions
id|u16
id|d_npartitions
suffix:semicolon
DECL|member|d_bbsize
DECL|member|d_sbsize
id|u32
id|d_bbsize
comma
id|d_sbsize
suffix:semicolon
DECL|struct|d_partition
r_struct
id|d_partition
(brace
DECL|member|p_size
id|u32
id|p_size
suffix:semicolon
DECL|member|p_offset
id|u32
id|p_offset
suffix:semicolon
DECL|member|p_fsize
id|u32
id|p_fsize
suffix:semicolon
DECL|member|p_fstype
id|u8
id|p_fstype
suffix:semicolon
DECL|member|p_frag
id|u8
id|p_frag
suffix:semicolon
DECL|member|p_cpg
id|u16
id|p_cpg
suffix:semicolon
DECL|member|d_partitions
)brace
id|d_partitions
(braket
id|MAXPARTITIONS
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|union|__bootblock
r_typedef
r_union
id|__bootblock
(brace
r_struct
(brace
DECL|member|__pad1
r_char
id|__pad1
(braket
l_int|64
)braket
suffix:semicolon
DECL|member|__label
r_struct
id|disklabel
id|__label
suffix:semicolon
DECL|member|__u1
)brace
id|__u1
suffix:semicolon
r_struct
(brace
DECL|member|__pad2
r_int
r_int
id|__pad2
(braket
l_int|63
)braket
suffix:semicolon
DECL|member|__checksum
r_int
r_int
id|__checksum
suffix:semicolon
DECL|member|__u2
)brace
id|__u2
suffix:semicolon
DECL|member|bootblock_bytes
r_char
id|bootblock_bytes
(braket
l_int|512
)braket
suffix:semicolon
DECL|member|bootblock_quadwords
r_int
r_int
id|bootblock_quadwords
(braket
l_int|64
)braket
suffix:semicolon
DECL|typedef|bootblock
)brace
id|bootblock
suffix:semicolon
DECL|macro|bootblock_label
mdefine_line|#define&t;bootblock_label&t;&t;__u1.__label
DECL|macro|bootblock_checksum
mdefine_line|#define bootblock_checksum&t;__u2.__checksum
DECL|function|main
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
op_star
id|argv
)paren
(brace
id|bootblock
id|bootblock_from_disk
suffix:semicolon
id|bootblock
id|bootloader_image
suffix:semicolon
r_int
id|dev
comma
id|fd
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|nread
suffix:semicolon
multiline_comment|/* Make sure of the arg count */
r_if
c_cond
(paren
id|argc
op_ne
l_int|3
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Usage: %s device lxboot&bslash;n&quot;
comma
id|argv
(braket
l_int|0
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* First, open the device and make sure it&squot;s accessible */
id|dev
op_assign
id|open
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
id|O_RDWR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|argv
(braket
l_int|1
)braket
)paren
suffix:semicolon
m_exit
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Now open the lxboot and make sure it&squot;s reasonable */
id|fd
op_assign
id|open
c_func
(paren
id|argv
(braket
l_int|2
)braket
comma
id|O_RDONLY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd
OL
l_int|0
)paren
(brace
id|perror
c_func
(paren
id|argv
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|close
c_func
(paren
id|dev
)paren
suffix:semicolon
m_exit
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Read in the lxboot */
id|nread
op_assign
id|read
c_func
(paren
id|fd
comma
op_amp
id|bootloader_image
comma
r_sizeof
(paren
id|bootblock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nread
op_ne
r_sizeof
(paren
id|bootblock
)paren
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;lxboot read&quot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;expected %d, got %d&bslash;n&quot;
comma
r_sizeof
(paren
id|bootblock
)paren
comma
id|nread
)paren
suffix:semicolon
m_exit
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Read in the bootblock from disk. */
id|nread
op_assign
id|read
c_func
(paren
id|dev
comma
op_amp
id|bootblock_from_disk
comma
r_sizeof
(paren
id|bootblock
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nread
op_ne
r_sizeof
(paren
id|bootblock
)paren
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;bootblock read&quot;
)paren
suffix:semicolon
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;expected %d, got %d&bslash;n&quot;
comma
r_sizeof
(paren
id|bootblock
)paren
comma
id|nread
)paren
suffix:semicolon
m_exit
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Swap the bootblock&squot;s disklabel into the bootloader */
id|bootloader_image.bootblock_label
op_assign
id|bootblock_from_disk.bootblock_label
suffix:semicolon
multiline_comment|/* Calculate the bootblock checksum */
id|bootloader_image.bootblock_checksum
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|63
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bootloader_image.bootblock_checksum
op_add_assign
id|bootloader_image.bootblock_quadwords
(braket
id|i
)braket
suffix:semicolon
)brace
multiline_comment|/* Write the whole thing out! */
id|lseek
c_func
(paren
id|dev
comma
l_int|0L
comma
id|SEEK_SET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|write
c_func
(paren
id|dev
comma
op_amp
id|bootloader_image
comma
r_sizeof
(paren
id|bootblock
)paren
)paren
op_ne
r_sizeof
(paren
id|bootblock
)paren
)paren
(brace
id|perror
c_func
(paren
l_string|&quot;bootblock write&quot;
)paren
suffix:semicolon
m_exit
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|close
c_func
(paren
id|fd
)paren
suffix:semicolon
id|close
c_func
(paren
id|dev
)paren
suffix:semicolon
m_exit
(paren
l_int|0
)paren
suffix:semicolon
)brace
eof
