multiline_comment|/*&n; *  linux/arch/alpha/lib/memcpy.c&n; *&n; *  Copyright (C) 1995  Linus Torvalds&n; */
multiline_comment|/*&n; * This is a reasonably optimized memcpy() routine.&n; */
multiline_comment|/*&n; * Note that the C code is written to be optimized into good assembly. However,&n; * at this point gcc is unable to sanely compile &quot;if (n &gt;= 0)&quot;, resulting in a&n; * explicit compare against 0 (instead of just using the proper &quot;blt reg, xx&quot; or&n; * &quot;bge reg, xx&quot;). I hope alpha-gcc will be fixed to notice this eventually..&n; */
macro_line|#include &lt;linux/types.h&gt;
multiline_comment|/*&n; * This should be done in one go with ldq_u*2/mask/stq_u. Do it&n; * with a macro so that we can fix it up later..&n; */
DECL|macro|ALIGN_DEST_TO8_UP
mdefine_line|#define ALIGN_DEST_TO8_UP(d,s,n) &bslash;&n;&t;while (d &amp; 7) { &bslash;&n;&t;&t;if (n &lt;= 0) return; &bslash;&n;&t;&t;n--; &bslash;&n;&t;&t;*(char *) d = *(char *) s; &bslash;&n;&t;&t;d++; s++; &bslash;&n;&t;}
DECL|macro|ALIGN_DEST_TO8_DN
mdefine_line|#define ALIGN_DEST_TO8_DN(d,s,n) &bslash;&n;&t;while (d &amp; 7) { &bslash;&n;&t;&t;if (n &lt;= 0) return; &bslash;&n;&t;&t;n--; &bslash;&n;&t;&t;d--; s--; &bslash;&n;&t;&t;*(char *) d = *(char *) s; &bslash;&n;&t;}
multiline_comment|/*&n; * This should similarly be done with ldq_u*2/mask/stq. The destination&n; * is aligned, but we don&squot;t fill in a full quad-word&n; */
DECL|macro|DO_REST_UP
mdefine_line|#define DO_REST_UP(d,s,n) &bslash;&n;&t;while (n &gt; 0) { &bslash;&n;&t;&t;n--; &bslash;&n;&t;&t;*(char *) d = *(char *) s; &bslash;&n;&t;&t;d++; s++; &bslash;&n;&t;}
DECL|macro|DO_REST_DN
mdefine_line|#define DO_REST_DN(d,s,n) &bslash;&n;&t;while (n &gt; 0) { &bslash;&n;&t;&t;n--; &bslash;&n;&t;&t;d--; s--; &bslash;&n;&t;&t;*(char *) d = *(char *) s; &bslash;&n;&t;}
multiline_comment|/*&n; * This should be done with ldq/mask/stq. The source and destination are&n; * aligned, but we don&squot;t fill in a full quad-word&n; */
DECL|macro|DO_REST_ALIGNED_UP
mdefine_line|#define DO_REST_ALIGNED_UP(d,s,n) DO_REST_UP(d,s,n)
DECL|macro|DO_REST_ALIGNED_DN
mdefine_line|#define DO_REST_ALIGNED_DN(d,s,n) DO_REST_DN(d,s,n)
multiline_comment|/*&n; * This does unaligned memory copies. We want to avoid storing to&n; * an unaligned address, as that would do a read-modify-write cycle.&n; * We also want to avoid double-reading the unaligned reads.&n; *&n; * Note the ordering to try to avoid load (and address generation) latencies.&n; */
DECL|function|__memcpy_unaligned_up
r_static
r_inline
r_void
id|__memcpy_unaligned_up
(paren
r_int
r_int
id|d
comma
r_int
r_int
id|s
comma
r_int
id|n
)paren
(brace
id|ALIGN_DEST_TO8_UP
c_func
(paren
id|d
comma
id|s
comma
id|n
)paren
suffix:semicolon
id|n
op_sub_assign
l_int|8
suffix:semicolon
multiline_comment|/* to avoid compare against 8 in the loop */
r_if
c_cond
(paren
id|n
op_ge
l_int|0
)paren
(brace
r_int
r_int
id|low_word
comma
id|high_word
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;ldq_u %0,%1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|low_word
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|s
)paren
)paren
suffix:semicolon
r_do
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;ldq_u %0,%1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|high_word
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|s
op_plus
l_int|8
)paren
)paren
)paren
suffix:semicolon
id|n
op_sub_assign
l_int|8
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;extql %1,%2,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|low_word
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|low_word
)paren
comma
l_string|&quot;r&quot;
(paren
id|s
)paren
)paren
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;extqh %1,%2,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|high_word
)paren
comma
l_string|&quot;r&quot;
(paren
id|s
)paren
)paren
suffix:semicolon
id|s
op_add_assign
l_int|8
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|d
op_assign
id|low_word
op_or
id|tmp
suffix:semicolon
id|d
op_add_assign
l_int|8
suffix:semicolon
id|low_word
op_assign
id|high_word
suffix:semicolon
)brace
r_while
c_loop
(paren
id|n
op_ge
l_int|0
)paren
suffix:semicolon
)brace
id|n
op_add_assign
l_int|8
suffix:semicolon
id|DO_REST_UP
c_func
(paren
id|d
comma
id|s
comma
id|n
)paren
suffix:semicolon
)brace
DECL|function|__memcpy_unaligned_dn
r_static
r_inline
r_void
id|__memcpy_unaligned_dn
(paren
r_int
r_int
id|d
comma
r_int
r_int
id|s
comma
r_int
id|n
)paren
(brace
multiline_comment|/* I don&squot;t understand AXP assembler well enough for this. -Tim */
id|s
op_add_assign
id|n
suffix:semicolon
id|d
op_add_assign
id|n
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
)paren
op_star
(paren
r_char
op_star
)paren
op_decrement
id|d
op_assign
op_star
(paren
r_char
op_star
)paren
op_decrement
id|s
suffix:semicolon
)brace
multiline_comment|/*&n; * Hmm.. Strange. The __asm__ here is there to make gcc use an integer register&n; * for the load-store. I don&squot;t know why, but it would seem that using a floating&n; * point register for the move seems to slow things down (very small difference,&n; * though).&n; *&n; * Note the ordering to try to avoid load (and address generation) latencies.&n; */
DECL|function|__memcpy_aligned_up
r_static
r_inline
r_void
id|__memcpy_aligned_up
(paren
r_int
r_int
id|d
comma
r_int
r_int
id|s
comma
r_int
id|n
)paren
(brace
id|ALIGN_DEST_TO8_UP
c_func
(paren
id|d
comma
id|s
comma
id|n
)paren
suffix:semicolon
id|n
op_sub_assign
l_int|8
suffix:semicolon
r_while
c_loop
(paren
id|n
op_ge
l_int|0
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;ldq %0,%1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|s
)paren
)paren
suffix:semicolon
id|n
op_sub_assign
l_int|8
suffix:semicolon
id|s
op_add_assign
l_int|8
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|d
op_assign
id|tmp
suffix:semicolon
id|d
op_add_assign
l_int|8
suffix:semicolon
)brace
id|n
op_add_assign
l_int|8
suffix:semicolon
id|DO_REST_ALIGNED_UP
c_func
(paren
id|d
comma
id|s
comma
id|n
)paren
suffix:semicolon
)brace
DECL|function|__memcpy_aligned_dn
r_static
r_inline
r_void
id|__memcpy_aligned_dn
(paren
r_int
r_int
id|d
comma
r_int
r_int
id|s
comma
r_int
id|n
)paren
(brace
id|s
op_add_assign
id|n
suffix:semicolon
id|d
op_add_assign
id|n
suffix:semicolon
id|ALIGN_DEST_TO8_DN
c_func
(paren
id|d
comma
id|s
comma
id|n
)paren
suffix:semicolon
id|n
op_sub_assign
l_int|8
suffix:semicolon
r_while
c_loop
(paren
id|n
op_ge
l_int|0
)paren
(brace
r_int
r_int
id|tmp
suffix:semicolon
id|s
op_sub_assign
l_int|8
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;ldq %0,%1&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|tmp
)paren
suffix:colon
l_string|&quot;m&quot;
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|s
)paren
)paren
suffix:semicolon
id|n
op_sub_assign
l_int|8
suffix:semicolon
id|d
op_sub_assign
l_int|8
suffix:semicolon
op_star
(paren
r_int
r_int
op_star
)paren
id|d
op_assign
id|tmp
suffix:semicolon
)brace
id|n
op_add_assign
l_int|8
suffix:semicolon
id|DO_REST_ALIGNED_DN
c_func
(paren
id|d
comma
id|s
comma
id|n
)paren
suffix:semicolon
)brace
DECL|function|memcpy
r_void
op_star
id|memcpy
c_func
(paren
r_void
op_star
id|dest
comma
r_const
r_void
op_star
id|src
comma
r_int
id|n
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
r_int
r_int
)paren
id|dest
op_xor
(paren
r_int
r_int
)paren
id|src
)paren
op_amp
l_int|7
)paren
)paren
(brace
id|__memcpy_aligned_up
(paren
(paren
r_int
r_int
)paren
id|dest
comma
(paren
r_int
r_int
)paren
id|src
comma
id|n
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
id|__memcpy_unaligned_up
(paren
(paren
r_int
r_int
)paren
id|dest
comma
(paren
r_int
r_int
)paren
id|src
comma
id|n
)paren
suffix:semicolon
r_return
id|dest
suffix:semicolon
)brace
multiline_comment|/* For backward modules compatibility, define __memcpy.  */
id|asm
c_func
(paren
l_string|&quot;__memcpy = memcpy; .globl __memcpy&quot;
)paren
suffix:semicolon
eof
