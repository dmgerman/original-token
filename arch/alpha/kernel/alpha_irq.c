multiline_comment|/*&n; * Alpha specific irq code.&n; */
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/irq.h&gt;
macro_line|#include &lt;asm/machvec.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &quot;proto.h&quot;
macro_line|#include &quot;irq_impl.h&quot;
multiline_comment|/* Only uniprocessor needs this IRQ/BH locking depth, on SMP it lives&n;   in the per-cpu structure for cache reasons.  */
macro_line|#ifndef CONFIG_SMP
DECL|variable|__local_irq_count
r_int
id|__local_irq_count
suffix:semicolon
DECL|variable|__local_bh_count
r_int
id|__local_bh_count
suffix:semicolon
DECL|variable|__irq_attempt
r_int
r_int
id|__irq_attempt
(braket
id|NR_IRQS
)braket
suffix:semicolon
macro_line|#endif
multiline_comment|/* Hack minimum IPL during interupt processing for broken hardware.  */
macro_line|#ifdef CONFIG_ALPHA_BROKEN_IRQ_MASK
DECL|variable|__min_ipl
r_int
id|__min_ipl
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Performance counter hook.  A module can override this to&n; * do something useful.&n; */
r_static
r_void
DECL|function|dummy_perf
id|dummy_perf
c_func
(paren
r_int
r_int
id|vector
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|irq_err_count
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Performance counter interrupt!&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|perf_irq
r_void
(paren
op_star
id|perf_irq
)paren
(paren
r_int
r_int
comma
r_struct
id|pt_regs
op_star
)paren
op_assign
id|dummy_perf
suffix:semicolon
multiline_comment|/*&n; * Dispatch device interrupts.&n; */
multiline_comment|/* Handle ISA interrupt via the PICs. */
macro_line|#if defined(CONFIG_ALPHA_GENERIC)
DECL|macro|IACK_SC
macro_line|# define IACK_SC&t;alpha_mv.iack_sc
macro_line|#elif defined(CONFIG_ALPHA_APECS)
DECL|macro|IACK_SC
macro_line|# define IACK_SC&t;APECS_IACK_SC
macro_line|#elif defined(CONFIG_ALPHA_LCA)
DECL|macro|IACK_SC
macro_line|# define IACK_SC&t;LCA_IACK_SC
macro_line|#elif defined(CONFIG_ALPHA_CIA)
DECL|macro|IACK_SC
macro_line|# define IACK_SC&t;CIA_IACK_SC
macro_line|#elif defined(CONFIG_ALPHA_PYXIS)
DECL|macro|IACK_SC
macro_line|# define IACK_SC&t;PYXIS_IACK_SC
macro_line|#elif defined(CONFIG_ALPHA_TSUNAMI)
DECL|macro|IACK_SC
macro_line|# define IACK_SC&t;TSUNAMI_IACK_SC
macro_line|#elif defined(CONFIG_ALPHA_POLARIS)
DECL|macro|IACK_SC
macro_line|# define IACK_SC&t;POLARIS_IACK_SC
macro_line|#elif defined(CONFIG_ALPHA_IRONGATE)
DECL|macro|IACK_SC
macro_line|# define IACK_SC        IRONGATE_IACK_SC
macro_line|#endif
macro_line|#if defined(IACK_SC)
r_void
DECL|function|isa_device_interrupt
id|isa_device_interrupt
c_func
(paren
r_int
r_int
id|vector
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/*&n;&t; * Generate a PCI interrupt acknowledge cycle.  The PIC will&n;&t; * respond with the interrupt vector of the highest priority&n;&t; * interrupt that is pending.  The PALcode sets up the&n;&t; * interrupts vectors such that irq level L generates vector L.&n;&t; */
r_int
id|j
op_assign
op_star
(paren
id|vuip
)paren
id|IACK_SC
suffix:semicolon
id|j
op_and_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
l_int|7
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
l_int|0x20
)paren
op_amp
l_int|0x80
)paren
)paren
(brace
multiline_comment|/* It&squot;s only a passive release... */
r_return
suffix:semicolon
)brace
)brace
id|handle_irq
c_func
(paren
id|j
comma
id|regs
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if defined(CONFIG_ALPHA_GENERIC) || !defined(IACK_SC)
r_void
DECL|function|isa_no_iack_sc_device_interrupt
id|isa_no_iack_sc_device_interrupt
c_func
(paren
r_int
r_int
id|vector
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|pic
suffix:semicolon
multiline_comment|/*&n;&t; * It seems to me that the probability of two or more *device*&n;&t; * interrupts occurring at almost exactly the same time is&n;&t; * pretty low.  So why pay the price of checking for&n;&t; * additional interrupts here if the common case can be&n;&t; * handled so much easier?&n;&t; */
multiline_comment|/* &n;&t; *  The first read of gives you *all* interrupting lines.&n;&t; *  Therefore, read the mask register and and out those lines&n;&t; *  not enabled.  Note that some documentation has 21 and a1 &n;&t; *  write only.  This is not true.&n;&t; */
id|pic
op_assign
id|inb
c_func
(paren
l_int|0x20
)paren
op_or
(paren
id|inb
c_func
(paren
l_int|0xA0
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* read isr */
id|pic
op_and_assign
l_int|0xFFFB
suffix:semicolon
multiline_comment|/* mask out cascade &amp; hibits */
r_while
c_loop
(paren
id|pic
)paren
(brace
r_int
id|j
op_assign
id|ffz
c_func
(paren
op_complement
id|pic
)paren
suffix:semicolon
id|pic
op_and_assign
id|pic
op_minus
l_int|1
suffix:semicolon
id|handle_irq
c_func
(paren
id|j
comma
id|regs
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n; * The main interrupt entry point.&n; */
id|asmlinkage
r_void
DECL|function|do_entInt
id|do_entInt
c_func
(paren
r_int
r_int
id|type
comma
r_int
r_int
id|vector
comma
r_int
r_int
id|la_ptr
comma
r_int
r_int
id|a3
comma
r_int
r_int
id|a4
comma
r_int
r_int
id|a5
comma
r_struct
id|pt_regs
id|regs
)paren
(brace
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
l_int|0
suffix:colon
macro_line|#ifdef CONFIG_SMP
id|handle_ipi
c_func
(paren
op_amp
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#else
id|irq_err_count
op_increment
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Interprocessor interrupt? &quot;
l_string|&quot;You must be kidding!&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
macro_line|#ifdef CONFIG_SMP
id|cpu_data
(braket
id|smp_processor_id
c_func
(paren
)paren
)braket
dot
id|smp_local_irq_count
op_increment
suffix:semicolon
id|smp_percpu_timer_interrupt
c_func
(paren
op_amp
id|regs
)paren
suffix:semicolon
r_if
c_cond
(paren
id|smp_processor_id
c_func
(paren
)paren
op_eq
id|boot_cpuid
)paren
macro_line|#endif
id|handle_irq
c_func
(paren
id|RTC_IRQ
comma
op_amp
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|2
suffix:colon
id|irq_err_count
op_increment
suffix:semicolon
id|alpha_mv
dot
id|machine_check
c_func
(paren
id|vector
comma
id|la_ptr
comma
op_amp
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|3
suffix:colon
id|alpha_mv
dot
id|device_interrupt
c_func
(paren
id|vector
comma
op_amp
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|4
suffix:colon
id|perf_irq
c_func
(paren
id|vector
comma
op_amp
id|regs
)paren
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;Hardware intr %ld %lx? Huh?&bslash;n&quot;
comma
id|type
comma
id|vector
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;PC = %016lx PS=%04lx&bslash;n&quot;
comma
id|regs.pc
comma
id|regs.ps
)paren
suffix:semicolon
)brace
r_void
id|__init
DECL|function|common_init_isa_dma
id|common_init_isa_dma
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
id|DMA1_RESET_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|DMA2_RESET_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|DMA1_CLR_MASK_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|DMA2_CLR_MASK_REG
)paren
suffix:semicolon
)brace
r_void
id|__init
DECL|function|init_IRQ
id|init_IRQ
c_func
(paren
r_void
)paren
(brace
id|alpha_mv
dot
id|init_irq
c_func
(paren
)paren
suffix:semicolon
id|wrent
c_func
(paren
id|entInt
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * machine error checks&n; */
DECL|macro|MCHK_K_TPERR
mdefine_line|#define MCHK_K_TPERR           0x0080
DECL|macro|MCHK_K_TCPERR
mdefine_line|#define MCHK_K_TCPERR          0x0082
DECL|macro|MCHK_K_HERR
mdefine_line|#define MCHK_K_HERR            0x0084
DECL|macro|MCHK_K_ECC_C
mdefine_line|#define MCHK_K_ECC_C           0x0086
DECL|macro|MCHK_K_ECC_NC
mdefine_line|#define MCHK_K_ECC_NC          0x0088
DECL|macro|MCHK_K_OS_BUGCHECK
mdefine_line|#define MCHK_K_OS_BUGCHECK     0x008A
DECL|macro|MCHK_K_PAL_BUGCHECK
mdefine_line|#define MCHK_K_PAL_BUGCHECK    0x0090
macro_line|#ifndef CONFIG_SMP
DECL|variable|__mcheck_info
r_struct
id|mcheck_info
id|__mcheck_info
suffix:semicolon
macro_line|#endif
r_void
DECL|function|process_mcheck_info
id|process_mcheck_info
c_func
(paren
r_int
r_int
id|vector
comma
r_int
r_int
id|la_ptr
comma
r_struct
id|pt_regs
op_star
id|regs
comma
r_const
r_char
op_star
id|machine
comma
r_int
id|expected
)paren
(brace
r_struct
id|el_common
op_star
id|mchk_header
suffix:semicolon
r_const
r_char
op_star
id|reason
suffix:semicolon
multiline_comment|/*&n;&t; * See if the machine check is due to a badaddr() and if so,&n;&t; * ignore it.&n;&t; */
macro_line|#if DEBUG_MCHECK &gt; 0
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s machine check %s&bslash;n&quot;
comma
id|machine
comma
id|expected
ques
c_cond
l_string|&quot;expected.&quot;
suffix:colon
l_string|&quot;NOT expected!!!&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|expected
)paren
(brace
r_int
id|cpu
op_assign
id|smp_processor_id
c_func
(paren
)paren
suffix:semicolon
id|mcheck_expected
c_func
(paren
id|cpu
)paren
op_assign
l_int|0
suffix:semicolon
id|mcheck_taken
c_func
(paren
id|cpu
)paren
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|mchk_header
op_assign
(paren
r_struct
id|el_common
op_star
)paren
id|la_ptr
suffix:semicolon
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;%s machine check: vector=0x%lx pc=0x%lx code=0x%lx&bslash;n&quot;
comma
id|machine
comma
id|vector
comma
id|regs-&gt;pc
comma
id|mchk_header-&gt;code
)paren
suffix:semicolon
r_switch
c_cond
(paren
(paren
r_int
r_int
)paren
id|mchk_header-&gt;code
)paren
(brace
multiline_comment|/* Machine check reasons.  Defined according to PALcode sources.  */
r_case
l_int|0x80
suffix:colon
id|reason
op_assign
l_string|&quot;tag parity error&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x82
suffix:colon
id|reason
op_assign
l_string|&quot;tag control parity error&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x84
suffix:colon
id|reason
op_assign
l_string|&quot;generic hard error&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x86
suffix:colon
id|reason
op_assign
l_string|&quot;correctable ECC error&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x88
suffix:colon
id|reason
op_assign
l_string|&quot;uncorrectable ECC error&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x8A
suffix:colon
id|reason
op_assign
l_string|&quot;OS-specific PAL bugcheck&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x90
suffix:colon
id|reason
op_assign
l_string|&quot;callsys in kernel mode&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x96
suffix:colon
id|reason
op_assign
l_string|&quot;i-cache read retryable error&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x98
suffix:colon
id|reason
op_assign
l_string|&quot;processor detected hard error&quot;
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* System specific (these are for Alcor, at least): */
r_case
l_int|0x202
suffix:colon
id|reason
op_assign
l_string|&quot;system detected hard error&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x203
suffix:colon
id|reason
op_assign
l_string|&quot;system detected uncorrectable ECC error&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x204
suffix:colon
id|reason
op_assign
l_string|&quot;SIO SERR occurred on PCI bus&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x205
suffix:colon
id|reason
op_assign
l_string|&quot;parity error detected by CIA&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x206
suffix:colon
id|reason
op_assign
l_string|&quot;SIO IOCHK occurred on ISA bus&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x207
suffix:colon
id|reason
op_assign
l_string|&quot;non-existent memory error&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x208
suffix:colon
id|reason
op_assign
l_string|&quot;MCHK_K_DCSR&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x209
suffix:colon
id|reason
op_assign
l_string|&quot;PCI SERR detected&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x20b
suffix:colon
id|reason
op_assign
l_string|&quot;PCI data parity error detected&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x20d
suffix:colon
id|reason
op_assign
l_string|&quot;PCI address parity error detected&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x20f
suffix:colon
id|reason
op_assign
l_string|&quot;PCI master abort error&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x211
suffix:colon
id|reason
op_assign
l_string|&quot;PCI target abort error&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x213
suffix:colon
id|reason
op_assign
l_string|&quot;scatter/gather PTE invalid error&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x215
suffix:colon
id|reason
op_assign
l_string|&quot;flash ROM write error&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x217
suffix:colon
id|reason
op_assign
l_string|&quot;IOA timeout detected&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x219
suffix:colon
id|reason
op_assign
l_string|&quot;IOCHK#, EISA add-in board parity or other catastrophic error&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x21b
suffix:colon
id|reason
op_assign
l_string|&quot;EISA fail-safe timer timeout&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x21d
suffix:colon
id|reason
op_assign
l_string|&quot;EISA bus time-out&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x21f
suffix:colon
id|reason
op_assign
l_string|&quot;EISA software generated NMI&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x221
suffix:colon
id|reason
op_assign
l_string|&quot;unexpected ev5 IRQ[3] interrupt&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|reason
op_assign
l_string|&quot;unknown&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;machine check type: %s%s&bslash;n&quot;
comma
id|reason
comma
id|mchk_header-&gt;retry
ques
c_cond
l_string|&quot; (retryable)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|dik_show_regs
c_func
(paren
id|regs
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#if DEBUG_MCHECK &gt; 1
(brace
multiline_comment|/* Dump the logout area to give all info.  */
r_int
r_int
op_star
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
id|la_ptr
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mchk_header-&gt;size
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
id|i
op_add_assign
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;   +%8lx %016lx %016lx&bslash;n&quot;
comma
id|i
op_star
r_sizeof
(paren
r_int
)paren
comma
id|ptr
(braket
id|i
)braket
comma
id|ptr
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
multiline_comment|/* RTC */
DECL|function|enable_rtc
r_static
r_void
id|enable_rtc
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
)brace
DECL|function|startup_rtc
r_static
r_int
r_int
id|startup_rtc
c_func
(paren
r_int
r_int
id|irq
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|shutdown_rtc
mdefine_line|#define shutdown_rtc&t;enable_rtc
DECL|macro|end_rtc
mdefine_line|#define end_rtc&t;&t;enable_rtc
DECL|macro|ack_rtc
mdefine_line|#define ack_rtc&t;&t;enable_rtc
DECL|macro|disable_rtc
mdefine_line|#define disable_rtc&t;enable_rtc
DECL|variable|timer_irqaction
r_struct
id|irqaction
id|timer_irqaction
op_assign
(brace
id|timer_interrupt
comma
id|SA_INTERRUPT
comma
l_int|0
comma
l_string|&quot;timer&quot;
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
r_void
id|__init
DECL|function|init_rtc_irq
id|init_rtc_irq
c_func
(paren
r_void
)paren
(brace
r_static
r_struct
id|hw_interrupt_type
id|rtc_irq_type
op_assign
(brace
l_string|&quot;RTC&quot;
comma
id|startup_rtc
comma
id|shutdown_rtc
comma
id|enable_rtc
comma
id|disable_rtc
comma
id|ack_rtc
comma
id|end_rtc
)brace
suffix:semicolon
id|irq_desc
(braket
id|RTC_IRQ
)braket
dot
id|status
op_assign
id|IRQ_DISABLED
suffix:semicolon
id|irq_desc
(braket
id|RTC_IRQ
)braket
dot
id|handler
op_assign
op_amp
id|rtc_irq_type
suffix:semicolon
id|setup_irq
c_func
(paren
id|RTC_IRQ
comma
op_amp
id|timer_irqaction
)paren
suffix:semicolon
)brace
multiline_comment|/* dummy irqactions */
DECL|variable|isa_cascade_irqaction
r_struct
id|irqaction
id|isa_cascade_irqaction
op_assign
(brace
id|handler
suffix:colon
id|no_action
comma
id|name
suffix:colon
l_string|&quot;isa-cascade&quot;
)brace
suffix:semicolon
DECL|variable|timer_cascade_irqaction
r_struct
id|irqaction
id|timer_cascade_irqaction
op_assign
(brace
id|handler
suffix:colon
id|no_action
comma
id|name
suffix:colon
l_string|&quot;timer-cascade&quot;
)brace
suffix:semicolon
DECL|variable|halt_switch_irqaction
r_struct
id|irqaction
id|halt_switch_irqaction
op_assign
(brace
id|handler
suffix:colon
id|no_action
comma
id|name
suffix:colon
l_string|&quot;halt-switch&quot;
)brace
suffix:semicolon
eof
